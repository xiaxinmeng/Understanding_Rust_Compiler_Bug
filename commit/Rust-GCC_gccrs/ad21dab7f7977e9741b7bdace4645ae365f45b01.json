{"sha": "ad21dab7f7977e9741b7bdace4645ae365f45b01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWQyMWRhYjdmNzk3N2U5NzQxYjdiZGFjZTQ2NDVhZTM2NWY0NWIwMQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-23T23:05:28Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2007-03-23T23:05:28Z"}, "message": "tracer.c (tracer): Don't take FLAGS argument.\n\n\t* tracer.c (tracer): Don't take FLAGS argument.  Assert we are\n\tin cfglayout mode.  Don't go into and out of cfglayout mode.\n\tLink the blocks in the order of the constructed traces.\n\t(rest_of_handle_tracer): Adjust call to tracer.\n\t* loop-init.c (rtl_loop_init): Assert we are in cfglayout mode.\n\tDon't go into cfglayout mode.\n\t(rtl_loop_done): Don't go out of cfglayout mode.\n\t* cfglayout.c (relink_block_chain): New function, split out from...\n\t(fixup_reorder_chain): ...here.  Remove redundant checking.\n\t(cfg_layout_finalize): Don't clear the header, footer, and aux\n\tfields here, move the code to do so to relink_block_chain.  Likewise\n\tfor free_original_copy_tables.\n\t* rtl.h (tracer): Update prototype.\n\t* bb-reorder.c (reorder_basic_blocks): Don't take FLAGS argument.\n\tAssert we are in cfglayout mode.  Don't go into and out of cfglayout\n\tmode.  Use relink_block_chain to serialize the CFG according to the\n\tnew basic block order.  Move targetm.cannot_modify_jumps_p check from\n\there...\n\t(gate_handle_reorder_blocks): ...to here.\n\t(duplicate_computed_gotos): Move targetm.cannot_modify_jumps_p check\n\tfrom here...\n\t(gate_duplicate_computed_gotos): ...to here.\n\t(rest_of_handle_reorder_blocks): Don't see if anything has changed,\n\tsomething always changes when going into and out of cfglayout mode.\n\tPerform an expensive cfg cleanup while going into cfglayout mode.\n\tAlways update liveness information on HAVE_conditional_execution\n\ttargets.  Reserialize the basic blocks and go out of cfglayout mode.\n\t* reg-stack.c: Include cfglayout.h.\n\t(rest_of_handle_stack_regs): Go into and out of cfglayout mode around\n\tthe call to reorder_basic_blocks.\n\t* basic-block.h (reorder_basic_blocks): Update prototype.\n\t(relink_block_chain): New prototype.\n\t* passes.c (pass_outof_cfg_layout_mode): Move after cse2.\n\nFrom-SVN: r123167", "tree": {"sha": "a15eb2e5e903aed64b074a1be1be2b4bb4d71136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a15eb2e5e903aed64b074a1be1be2b4bb4d71136"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ad21dab7f7977e9741b7bdace4645ae365f45b01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad21dab7f7977e9741b7bdace4645ae365f45b01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad21dab7f7977e9741b7bdace4645ae365f45b01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad21dab7f7977e9741b7bdace4645ae365f45b01/comments", "author": null, "committer": null, "parents": [{"sha": "1f93ef9228b60d66677a2880c32c4b78b19400e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f93ef9228b60d66677a2880c32c4b78b19400e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f93ef9228b60d66677a2880c32c4b78b19400e7"}], "stats": {"total": 732, "additions": 632, "deletions": 100}, "files": [{"sha": "5544abb4c890fbeefd7766c8ca56f74b9f84a229", "filename": "gcc/ChangeLog", "status": "modified", "additions": 502, "deletions": 0, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -1,3 +1,505 @@\n+2007-03-23  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* tracer.c (tracer): Don't take FLAGS argument.  Assert we are\n+\tin cfglayout mode.  Don't go into and out of cfglayout mode.\n+\tLink the blocks in the order of the constructed traces.\n+\t(rest_of_handle_tracer): Adjust call to tracer.\n+\t* loop-init.c (rtl_loop_init): Assert we are in cfglayout mode.\n+\tDon't go into cfglayout mode.\n+\t(rtl_loop_done): Don't go out of cfglayout mode.\n+\t* cfglayout.c (relink_block_chain): New function, split out from...\n+\t(fixup_reorder_chain): ...here.  Remove redundant checking.\n+\t(cfg_layout_finalize): Don't clear the header, footer, and aux\n+\tfields here, move the code to do so to relink_block_chain.  Likewise\n+\tfor free_original_copy_tables.\n+\t* rtl.h (tracer): Update prototype.\n+\t* bb-reorder.c (reorder_basic_blocks): Don't take FLAGS argument.\n+\tAssert we are in cfglayout mode.  Don't go into and out of cfglayout\n+\tmode.  Use relink_block_chain to serialize the CFG according to the\n+\tnew basic block order.  Move targetm.cannot_modify_jumps_p check from\n+\there...\n+\t(gate_handle_reorder_blocks): ...to here.\n+\t(duplicate_computed_gotos): Move targetm.cannot_modify_jumps_p check\n+\tfrom here...\n+\t(gate_duplicate_computed_gotos): ...to here.\n+\t(rest_of_handle_reorder_blocks): Don't see if anything has changed,\n+\tsomething always changes when going into and out of cfglayout mode.\n+\tPerform an expensive cfg cleanup while going into cfglayout mode.\n+\tAlways update liveness information on HAVE_conditional_execution\n+\ttargets.  Reserialize the basic blocks and go out of cfglayout mode.\n+\t* reg-stack.c: Include cfglayout.h.\n+\t(rest_of_handle_stack_regs): Go into and out of cfglayout mode around\n+\tthe call to reorder_basic_blocks.\n+\t* basic-block.h (reorder_basic_blocks): Update prototype.\n+\t(relink_block_chain): New prototype.\n+\t* passes.c (pass_outof_cfg_layout_mode): Move after cse2.\n+\n+Index: tracer.c\n+===================================================================\n+--- tracer.c\t(revision 122857)\n++++ tracer.c\t(working copy)\n+@@ -357,24 +357,25 @@ layout_superblocks (void)\n+     }\n+ }\n+ \n+-/* Main entry point to this file.  FLAGS is the set of flags to pass\n+-   to cfg_layout_initialize().  */\n++/* Main entry point to this file.  */\n+ \n+ void\n+-tracer (unsigned int flags)\n++tracer (void)\n+ {\n++  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n++\n+   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+     return;\n+ \n+-  cfg_layout_initialize (flags);\n+   mark_dfs_back_edges ();\n+   if (dump_file)\n+     dump_flow_info (dump_file, dump_flags);\n+   tail_duplicate ();\n+   layout_superblocks ();\n++  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n++  \n+   if (dump_file)\n+     dump_flow_info (dump_file, dump_flags);\n+-  cfg_layout_finalize ();\n+ \n+   /* Merge basic blocks in duplicated traces.  */\n+   cleanup_cfg (CLEANUP_EXPENSIVE);\n+@@ -392,7 +393,7 @@ rest_of_handle_tracer (void)\n+ {\n+   if (dump_file)\n+     dump_flow_info (dump_file, dump_flags);\n+-  tracer (0);\n++  tracer ();\n+   reg_scan (get_insns (), max_reg_num ());\n+   return 0;\n+ }\n+Index: loop-init.c\n+===================================================================\n+--- loop-init.c\t(revision 122857)\n++++ loop-init.c\t(working copy)\n+@@ -171,12 +171,11 @@ struct tree_opt_pass pass_loop2 =\n+ static unsigned int\n+ rtl_loop_init (void)\n+ {\n++  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n++  \n+   if (dump_file)\n+     dump_flow_info (dump_file, dump_flags);\n+ \n+-  /* Initialize structures for layout changes.  */\n+-  cfg_layout_initialize (0);\n+-\n+   loop_optimizer_init (LOOPS_NORMAL);\n+   return 0;\n+ }\n+@@ -204,17 +203,9 @@ struct tree_opt_pass pass_rtl_loop_init \n+ static unsigned int\n+ rtl_loop_done (void)\n+ {\n+-  basic_block bb;\n+-\n+   loop_optimizer_finalize ();\n+   free_dominance_info (CDI_DOMINATORS);\n+ \n+-  /* Finalize layout changes.  */\n+-  FOR_EACH_BB (bb)\n+-    if (bb->next_bb != EXIT_BLOCK_PTR)\n+-      bb->aux = bb->next_bb;\n+-  cfg_layout_finalize ();\n+-\n+   cleanup_cfg (CLEANUP_EXPENSIVE);\n+   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n+   reg_scan (get_insns (), max_reg_num ());\n+Index: cfglayout.c\n+===================================================================\n+--- cfglayout.c\t(revision 122858)\n++++ cfglayout.c\t(working copy)\n+@@ -634,13 +634,83 @@ reemit_insn_block_notes (void)\n+   reorder_blocks ();\n+ }\n+ \f\n++\n++/* Link the basic blocks in the correct order, compacting the basic\n++   block queue while at it.  This also clears the visited flag on\n++   all basic blocks.  If STAY_IN_CFGLAYOUT_MODE is false, this function\n++   also clears the basic block header and footer fields.\n++\n++   This function is usually called after a pass (e.g. tracer) finishes\n++   some transformations while in cfglayout mode.  The required sequence\n++   of the basic blocks is in a linked list along the bb->aux field.\n++   This functions re-links the basic block prev_bb and next_bb pointers\n++   accordingly, and it compacts and renumbers the blocks.  */\n++\n++void\n++relink_block_chain (bool stay_in_cfglayout_mode)\n++{\n++  basic_block bb, prev_bb;\n++  int index;\n++\n++  /* Maybe dump the re-ordered sequence.  */\n++  if (dump_file)\n++    {\n++      fprintf (dump_file, \"Reordered sequence:\\n\");\n++      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n++\t   bb;\n++\t   bb = bb->aux, index++)\n++\t{\n++\t  fprintf (dump_file, \" %i \", index);\n++\t  if (get_bb_original (bb))\n++\t    fprintf (dump_file, \"duplicate of %i \",\n++\t\t     get_bb_original (bb)->index);\n++\t  else if (forwarder_block_p (bb)\n++\t\t   && !LABEL_P (BB_HEAD (bb)))\n++\t    fprintf (dump_file, \"compensation \");\n++\t  else\n++\t    fprintf (dump_file, \"bb %i \", bb->index);\n++\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n++\t}\n++    }\n++\n++  /* Now reorder the blocks.  */\n++  prev_bb = ENTRY_BLOCK_PTR;\n++  bb = ENTRY_BLOCK_PTR->next_bb;\n++  for (; bb; prev_bb = bb, bb = bb->aux)\n++    {\n++      bb->prev_bb = prev_bb;\n++      prev_bb->next_bb = bb;\n++    }\n++  prev_bb->next_bb = EXIT_BLOCK_PTR;\n++  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n++\n++  /* Then, clean up the aux and visited fields.  */\n++  FOR_ALL_BB (bb)\n++    {\n++      bb->aux = NULL;\n++      bb->il.rtl->visited = 0;\n++      if (!stay_in_cfglayout_mode)\n++\tbb->il.rtl->header = bb->il.rtl->footer = NULL;\n++    }\n++\n++  /* Maybe reset the original copy tables, they are not valid anymore\n++     when we renumber the basic blocks in compact_blocks.  If we are\n++     are going out of cfglayout mode, don't re-allocate the tables.  */\n++  free_original_copy_tables ();\n++  if (stay_in_cfglayout_mode)\n++    initialize_original_copy_tables ();\n++  \n++  /* Finally, put basic_block_info in the new order.  */\n++  compact_blocks ();\n++}\n++\f\n++\n+ /* Given a reorder chain, rearrange the code to match.  */\n+ \n+ static void\n+ fixup_reorder_chain (void)\n+ {\n+-  basic_block bb, prev_bb;\n+-  int index;\n++  basic_block bb;\n+   rtx insn = NULL;\n+ \n+   if (cfg_layout_function_header)\n+@@ -654,9 +724,7 @@ fixup_reorder_chain (void)\n+   /* First do the bulk reordering -- rechain the blocks without regard to\n+      the needed changes to jumps and labels.  */\n+ \n+-  for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n+-       bb != 0;\n+-       bb = bb->aux, index++)\n++  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = bb->aux)\n+     {\n+       if (bb->il.rtl->header)\n+ \t{\n+@@ -684,8 +752,6 @@ fixup_reorder_chain (void)\n+ \t}\n+     }\n+ \n+-  gcc_assert (index == n_basic_blocks);\n+-\n+   NEXT_INSN (insn) = cfg_layout_function_footer;\n+   if (cfg_layout_function_footer)\n+     PREV_INSN (cfg_layout_function_footer) = insn;\n+@@ -838,42 +904,7 @@ fixup_reorder_chain (void)\n+ \t}\n+     }\n+ \n+-  /* Put basic_block_info in the new order.  */\n+-\n+-  if (dump_file)\n+-    {\n+-      fprintf (dump_file, \"Reordered sequence:\\n\");\n+-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n+-\t   bb;\n+-\t   bb = bb->aux, index++)\n+-\t{\n+-\t  fprintf (dump_file, \" %i \", index);\n+-\t  if (get_bb_original (bb))\n+-\t    fprintf (dump_file, \"duplicate of %i \",\n+-\t\t     get_bb_original (bb)->index);\n+-\t  else if (forwarder_block_p (bb)\n+-\t\t   && !LABEL_P (BB_HEAD (bb)))\n+-\t    fprintf (dump_file, \"compensation \");\n+-\t  else\n+-\t    fprintf (dump_file, \"bb %i \", bb->index);\n+-\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n+-\t}\n+-    }\n+-\n+-  prev_bb = ENTRY_BLOCK_PTR;\n+-  bb = ENTRY_BLOCK_PTR->next_bb;\n+-  index = NUM_FIXED_BLOCKS;\n+-\n+-  for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n+-    {\n+-      bb->index = index;\n+-      SET_BASIC_BLOCK (index, bb);\n+-\n+-      bb->prev_bb = prev_bb;\n+-      prev_bb->next_bb = bb;\n+-    }\n+-  prev_bb->next_bb = EXIT_BLOCK_PTR;\n+-  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n++  relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n+ \n+   /* Annoying special case - jump around dead jumptables left in the code.  */\n+   FOR_EACH_BB (bb)\n+@@ -1179,8 +1210,6 @@ break_superblocks (void)\n+ void\n+ cfg_layout_finalize (void)\n+ {\n+-  basic_block bb;\n+-\n+ #ifdef ENABLE_CHECKING\n+   verify_flow_info ();\n+ #endif\n+@@ -1195,19 +1224,8 @@ cfg_layout_finalize (void)\n+ \n+ #ifdef ENABLE_CHECKING\n+   verify_insn_chain ();\n+-#endif\n+-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n+-  {\n+-    bb->il.rtl->header = bb->il.rtl->footer = NULL;\n+-    bb->aux = NULL;\n+-    bb->il.rtl->visited = 0;\n+-  }\n+-\n+-#ifdef ENABLE_CHECKING\n+   verify_flow_info ();\n+ #endif\n+-\n+-  free_original_copy_tables ();\n+ }\n+ \n+ /* Checks whether all N blocks in BBS array can be copied.  */\n+Index: rtl.h\n+===================================================================\n+--- rtl.h\t(revision 122857)\n++++ rtl.h\t(working copy)\n+@@ -2259,7 +2259,7 @@ extern bool expensive_function_p (int);\n+ /* In cfgexpand.c */\n+ extern void add_reg_br_prob_note (rtx last, int probability);\n+ /* In tracer.c */\n+-extern void tracer (unsigned int);\n++extern void tracer (void);\n+ \n+ /* In var-tracking.c */\n+ extern unsigned int variable_tracking_main (void);\n+Index: bb-reorder.c\n+===================================================================\n+--- bb-reorder.c\t(revision 122857)\n++++ bb-reorder.c\t(working copy)\n+@@ -1889,20 +1889,17 @@ verify_hot_cold_block_grouping (void)\n+    the set of flags to pass to cfg_layout_initialize().  */\n+ \n+ void\n+-reorder_basic_blocks (unsigned int flags)\n++reorder_basic_blocks (void)\n+ {\n+   int n_traces;\n+   int i;\n+   struct trace *traces;\n+ \n+-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+-    return;\n++  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n+ \n+-  if (targetm.cannot_modify_jumps_p ())\n++  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+     return;\n+ \n+-  cfg_layout_initialize (flags);\n+-\n+   set_edge_can_fallthru_flag ();\n+   mark_dfs_back_edges ();\n+ \n+@@ -1930,10 +1927,11 @@ reorder_basic_blocks (unsigned int flags\n+   FREE (traces);\n+   FREE (bbd);\n+ \n++  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n++\n+   if (dump_file)\n+     dump_flow_info (dump_file, dump_flags);\n+ \n+-  cfg_layout_finalize ();\n+   if (flag_reorder_blocks_and_partition)\n+     verify_hot_cold_block_grouping ();\n+ }\n+@@ -1976,6 +1974,8 @@ insert_section_boundary_note (void)\n+ static bool\n+ gate_duplicate_computed_gotos (void)\n+ {\n++  if (targetm.cannot_modify_jumps_p ())\n++    return false;\n+   return (optimize > 0 && flag_expensive_optimizations && !optimize_size);\n+ }\n+ \n+@@ -1990,9 +1990,6 @@ duplicate_computed_gotos (void)\n+   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n+     return 0;\n+ \n+-  if (targetm.cannot_modify_jumps_p ())\n+-    return 0;\n+-\n+   cfg_layout_initialize (0);\n+ \n+   /* We are estimating the length of uncond jump insn only once\n+@@ -2198,6 +2195,8 @@ partition_hot_cold_basic_blocks (void)\n+ static bool\n+ gate_handle_reorder_blocks (void)\n+ {\n++  if (targetm.cannot_modify_jumps_p ())\n++    return false;\n+   return (optimize > 0);\n+ }\n+ \n+@@ -2206,34 +2205,39 @@ gate_handle_reorder_blocks (void)\n+ static unsigned int\n+ rest_of_handle_reorder_blocks (void)\n+ {\n+-  bool changed;\n+   unsigned int liveness_flags;\n++  basic_block bb;\n+ \n+   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n+      splitting possibly introduced more crossjumping opportunities.  */\n+   liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n+-  changed = cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n++  cfg_layout_initialize (CLEANUP_EXPENSIVE | liveness_flags);\n+ \n+   if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n+     {\n+       timevar_push (TV_TRACER);\n+-      tracer (liveness_flags);\n++      tracer ();\n+       timevar_pop (TV_TRACER);\n+     }\n+ \n+   if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n+-    reorder_basic_blocks (liveness_flags);\n++    reorder_basic_blocks ();\n+   if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n+       || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n+-    changed |= cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n++    cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n+ \n+   /* On conditional execution targets we can not update the life cheaply, so\n+      we deffer the updating to after both cleanups.  This may lose some cases\n+      but should not be terribly bad.  */\n+-  if (changed && HAVE_conditional_execution)\n++  if (HAVE_conditional_execution)\n+     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n+ \t\t      PROP_DEATH_NOTES);\n+ \n++  FOR_EACH_BB (bb)\n++    if (bb->next_bb != EXIT_BLOCK_PTR)\n++      bb->aux = bb->next_bb;\n++  cfg_layout_finalize ();\n++\n+   /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n+   insert_section_boundary_note ();\n+   return 0;\n+Index: reg-stack.c\n+===================================================================\n+--- reg-stack.c\t(revision 122857)\n++++ reg-stack.c\t(working copy)\n+@@ -167,6 +167,7 @@\n+ #include \"recog.h\"\n+ #include \"output.h\"\n+ #include \"basic-block.h\"\n++#include \"cfglayout.h\"\n+ #include \"varray.h\"\n+ #include \"reload.h\"\n+ #include \"ggc.h\"\n+@@ -3197,8 +3198,17 @@ rest_of_handle_stack_regs (void)\n+                        | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n+           && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n+         {\n+-          reorder_basic_blocks (0);\n+-          cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n++\t  basic_block bb;\n++\n++\t  cfg_layout_initialize (0);\n++\n++\t  reorder_basic_blocks ();\n++\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n++\n++\t  FOR_EACH_BB (bb)\n++\t    if (bb->next_bb != EXIT_BLOCK_PTR)\n++\t      bb->aux = bb->next_bb;\n++\t  cfg_layout_finalize ();\n+         }\n+     }\n+   else \n+Index: basic-block.h\n+===================================================================\n+--- basic-block.h\t(revision 122857)\n++++ basic-block.h\t(working copy)\n+@@ -929,7 +929,7 @@ extern bool control_flow_insn_p (rtx);\n+ extern rtx get_last_bb_insn (basic_block);\n+ \n+ /* In bb-reorder.c */\n+-extern void reorder_basic_blocks (unsigned int);\n++extern void reorder_basic_blocks (void);\n+ \n+ /* In dominance.c */\n+ \n+@@ -976,6 +976,7 @@ unsigned bb_dom_dfs_out (enum cdi_direct\n+ \n+ extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n+ extern void break_superblocks (void);\n++extern void relink_block_chain (bool);\n+ extern void check_bb_profile (basic_block, FILE *);\n+ extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n+ extern void init_rtl_bb_info (basic_block);\n+Index: passes.c\n+===================================================================\n+--- passes.c\t(revision 122858)\n++++ passes.c\t(working copy)\n+@@ -666,7 +666,6 @@ init_optimization_passes (void)\n+       NEXT_PASS (pass_gcse);\n+       NEXT_PASS (pass_jump_bypass);\n+       NEXT_PASS (pass_rtl_ifcvt);\n+-      NEXT_PASS (pass_outof_cfg_layout_mode);\n+       NEXT_PASS (pass_tracer);\n+       /* Perform loop optimizations.  It might be better to do them a bit\n+ \t sooner, but we want the profile feedback to work more\n+@@ -685,6 +684,7 @@ init_optimization_passes (void)\n+       NEXT_PASS (pass_web);\n+       NEXT_PASS (pass_cse2);\n+       NEXT_PASS (pass_rtl_fwprop_addr);\n++      NEXT_PASS (pass_outof_cfg_layout_mode);\n+       NEXT_PASS (pass_life);\n+       NEXT_PASS (pass_combine);\n+       NEXT_PASS (pass_if_after_combine);\n+\n 2007-03-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* config/mips/mips.md (type, hazard, *movdi_32bit,"}, {"sha": "f8ddacc6afe0c39d45f70c090daff7f4aa073dcf", "filename": "gcc/basic-block.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -929,7 +929,7 @@ extern bool control_flow_insn_p (rtx);\n extern rtx get_last_bb_insn (basic_block);\n \n /* In bb-reorder.c */\n-extern void reorder_basic_blocks (unsigned int);\n+extern void reorder_basic_blocks (void);\n \n /* In dominance.c */\n \n@@ -976,6 +976,7 @@ unsigned bb_dom_dfs_out (enum cdi_direction, basic_block);\n \n extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void break_superblocks (void);\n+extern void relink_block_chain (bool);\n extern void check_bb_profile (basic_block, FILE *);\n extern void update_bb_profile_for_threading (basic_block, int, gcov_type, edge);\n extern void init_rtl_bb_info (basic_block);"}, {"sha": "27f24fc1c5e023ff89dfcf2ec62c8a5d4ee5c5c5", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -1889,20 +1889,17 @@ verify_hot_cold_block_grouping (void)\n    the set of flags to pass to cfg_layout_initialize().  */\n \n void\n-reorder_basic_blocks (unsigned int flags)\n+reorder_basic_blocks (void)\n {\n   int n_traces;\n   int i;\n   struct trace *traces;\n \n-  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n-    return;\n+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n \n-  if (targetm.cannot_modify_jumps_p ())\n+  if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n-  cfg_layout_initialize (flags);\n-\n   set_edge_can_fallthru_flag ();\n   mark_dfs_back_edges ();\n \n@@ -1930,10 +1927,11 @@ reorder_basic_blocks (unsigned int flags)\n   FREE (traces);\n   FREE (bbd);\n \n+  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n+\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n \n-  cfg_layout_finalize ();\n   if (flag_reorder_blocks_and_partition)\n     verify_hot_cold_block_grouping ();\n }\n@@ -1976,6 +1974,8 @@ insert_section_boundary_note (void)\n static bool\n gate_duplicate_computed_gotos (void)\n {\n+  if (targetm.cannot_modify_jumps_p ())\n+    return false;\n   return (optimize > 0 && flag_expensive_optimizations && !optimize_size);\n }\n \n@@ -1990,9 +1990,6 @@ duplicate_computed_gotos (void)\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return 0;\n \n-  if (targetm.cannot_modify_jumps_p ())\n-    return 0;\n-\n   cfg_layout_initialize (0);\n \n   /* We are estimating the length of uncond jump insn only once\n@@ -2198,6 +2195,8 @@ partition_hot_cold_basic_blocks (void)\n static bool\n gate_handle_reorder_blocks (void)\n {\n+  if (targetm.cannot_modify_jumps_p ())\n+    return false;\n   return (optimize > 0);\n }\n \n@@ -2206,34 +2205,39 @@ gate_handle_reorder_blocks (void)\n static unsigned int\n rest_of_handle_reorder_blocks (void)\n {\n-  bool changed;\n   unsigned int liveness_flags;\n+  basic_block bb;\n \n   /* Last attempt to optimize CFG, as scheduling, peepholing and insn\n      splitting possibly introduced more crossjumping opportunities.  */\n   liveness_flags = (!HAVE_conditional_execution ? CLEANUP_UPDATE_LIFE : 0);\n-  changed = cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n+  cfg_layout_initialize (CLEANUP_EXPENSIVE | liveness_flags);\n \n   if (flag_sched2_use_traces && flag_schedule_insns_after_reload)\n     {\n       timevar_push (TV_TRACER);\n-      tracer (liveness_flags);\n+      tracer ();\n       timevar_pop (TV_TRACER);\n     }\n \n   if (flag_reorder_blocks || flag_reorder_blocks_and_partition)\n-    reorder_basic_blocks (liveness_flags);\n+    reorder_basic_blocks ();\n   if (flag_reorder_blocks || flag_reorder_blocks_and_partition\n       || (flag_sched2_use_traces && flag_schedule_insns_after_reload))\n-    changed |= cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n+    cleanup_cfg (CLEANUP_EXPENSIVE | liveness_flags);\n \n   /* On conditional execution targets we can not update the life cheaply, so\n      we deffer the updating to after both cleanups.  This may lose some cases\n      but should not be terribly bad.  */\n-  if (changed && HAVE_conditional_execution)\n+  if (HAVE_conditional_execution)\n     update_life_info (NULL, UPDATE_LIFE_GLOBAL_RM_NOTES,\n \t\t      PROP_DEATH_NOTES);\n \n+  FOR_EACH_BB (bb)\n+    if (bb->next_bb != EXIT_BLOCK_PTR)\n+      bb->aux = bb->next_bb;\n+  cfg_layout_finalize ();\n+\n   /* Add NOTE_INSN_SWITCH_TEXT_SECTIONS notes.  */\n   insert_section_boundary_note ();\n   return 0;"}, {"sha": "01784319c192d65fd71b57f654ff1f1e1c4adbd9", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 74, "deletions": 56, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -634,13 +634,83 @@ reemit_insn_block_notes (void)\n   reorder_blocks ();\n }\n \f\n+\n+/* Link the basic blocks in the correct order, compacting the basic\n+   block queue while at it.  This also clears the visited flag on\n+   all basic blocks.  If STAY_IN_CFGLAYOUT_MODE is false, this function\n+   also clears the basic block header and footer fields.\n+\n+   This function is usually called after a pass (e.g. tracer) finishes\n+   some transformations while in cfglayout mode.  The required sequence\n+   of the basic blocks is in a linked list along the bb->aux field.\n+   This functions re-links the basic block prev_bb and next_bb pointers\n+   accordingly, and it compacts and renumbers the blocks.  */\n+\n+void\n+relink_block_chain (bool stay_in_cfglayout_mode)\n+{\n+  basic_block bb, prev_bb;\n+  int index;\n+\n+  /* Maybe dump the re-ordered sequence.  */\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Reordered sequence:\\n\");\n+      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n+\t   bb;\n+\t   bb = bb->aux, index++)\n+\t{\n+\t  fprintf (dump_file, \" %i \", index);\n+\t  if (get_bb_original (bb))\n+\t    fprintf (dump_file, \"duplicate of %i \",\n+\t\t     get_bb_original (bb)->index);\n+\t  else if (forwarder_block_p (bb)\n+\t\t   && !LABEL_P (BB_HEAD (bb)))\n+\t    fprintf (dump_file, \"compensation \");\n+\t  else\n+\t    fprintf (dump_file, \"bb %i \", bb->index);\n+\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n+\t}\n+    }\n+\n+  /* Now reorder the blocks.  */\n+  prev_bb = ENTRY_BLOCK_PTR;\n+  bb = ENTRY_BLOCK_PTR->next_bb;\n+  for (; bb; prev_bb = bb, bb = bb->aux)\n+    {\n+      bb->prev_bb = prev_bb;\n+      prev_bb->next_bb = bb;\n+    }\n+  prev_bb->next_bb = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n+\n+  /* Then, clean up the aux and visited fields.  */\n+  FOR_ALL_BB (bb)\n+    {\n+      bb->aux = NULL;\n+      bb->il.rtl->visited = 0;\n+      if (!stay_in_cfglayout_mode)\n+\tbb->il.rtl->header = bb->il.rtl->footer = NULL;\n+    }\n+\n+  /* Maybe reset the original copy tables, they are not valid anymore\n+     when we renumber the basic blocks in compact_blocks.  If we are\n+     are going out of cfglayout mode, don't re-allocate the tables.  */\n+  free_original_copy_tables ();\n+  if (stay_in_cfglayout_mode)\n+    initialize_original_copy_tables ();\n+  \n+  /* Finally, put basic_block_info in the new order.  */\n+  compact_blocks ();\n+}\n+\f\n+\n /* Given a reorder chain, rearrange the code to match.  */\n \n static void\n fixup_reorder_chain (void)\n {\n-  basic_block bb, prev_bb;\n-  int index;\n+  basic_block bb;\n   rtx insn = NULL;\n \n   if (cfg_layout_function_header)\n@@ -654,9 +724,7 @@ fixup_reorder_chain (void)\n   /* First do the bulk reordering -- rechain the blocks without regard to\n      the needed changes to jumps and labels.  */\n \n-  for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n-       bb != 0;\n-       bb = bb->aux, index++)\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb; bb = bb->aux)\n     {\n       if (bb->il.rtl->header)\n \t{\n@@ -684,8 +752,6 @@ fixup_reorder_chain (void)\n \t}\n     }\n \n-  gcc_assert (index == n_basic_blocks);\n-\n   NEXT_INSN (insn) = cfg_layout_function_footer;\n   if (cfg_layout_function_footer)\n     PREV_INSN (cfg_layout_function_footer) = insn;\n@@ -837,42 +903,7 @@ fixup_reorder_chain (void)\n \t}\n     }\n \n-  /* Put basic_block_info in the new order.  */\n-\n-  if (dump_file)\n-    {\n-      fprintf (dump_file, \"Reordered sequence:\\n\");\n-      for (bb = ENTRY_BLOCK_PTR->next_bb, index = NUM_FIXED_BLOCKS;\n-\t   bb;\n-\t   bb = bb->aux, index++)\n-\t{\n-\t  fprintf (dump_file, \" %i \", index);\n-\t  if (get_bb_original (bb))\n-\t    fprintf (dump_file, \"duplicate of %i \",\n-\t\t     get_bb_original (bb)->index);\n-\t  else if (forwarder_block_p (bb)\n-\t\t   && !LABEL_P (BB_HEAD (bb)))\n-\t    fprintf (dump_file, \"compensation \");\n-\t  else\n-\t    fprintf (dump_file, \"bb %i \", bb->index);\n-\t  fprintf (dump_file, \" [%i]\\n\", bb->frequency);\n-\t}\n-    }\n-\n-  prev_bb = ENTRY_BLOCK_PTR;\n-  bb = ENTRY_BLOCK_PTR->next_bb;\n-  index = NUM_FIXED_BLOCKS;\n-\n-  for (; bb; prev_bb = bb, bb = bb->aux, index ++)\n-    {\n-      bb->index = index;\n-      SET_BASIC_BLOCK (index, bb);\n-\n-      bb->prev_bb = prev_bb;\n-      prev_bb->next_bb = bb;\n-    }\n-  prev_bb->next_bb = EXIT_BLOCK_PTR;\n-  EXIT_BLOCK_PTR->prev_bb = prev_bb;\n+  relink_block_chain (/*stay_in_cfglayout_mode=*/false);\n \n   /* Annoying special case - jump around dead jumptables left in the code.  */\n   FOR_EACH_BB (bb)\n@@ -1178,8 +1209,6 @@ break_superblocks (void)\n void\n cfg_layout_finalize (void)\n {\n-  basic_block bb;\n-\n #ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n@@ -1197,19 +1226,8 @@ cfg_layout_finalize (void)\n \n #ifdef ENABLE_CHECKING\n   verify_insn_chain ();\n-#endif\n-  FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-  {\n-    bb->il.rtl->header = bb->il.rtl->footer = NULL;\n-    bb->aux = NULL;\n-    bb->il.rtl->visited = 0;\n-  }\n-\n-#ifdef ENABLE_CHECKING\n   verify_flow_info ();\n #endif\n-\n-  free_original_copy_tables ();\n }\n \n /* Checks whether all N blocks in BBS array can be copied.  */"}, {"sha": "70d4ef4d17d0f33f23e4f4122f05411d6f84b9ad", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -2711,13 +2711,18 @@ cond_move_process_if_block (struct ce_if_block *ce_info)\n static int\n process_if_block (struct ce_if_block * ce_info)\n {\n-  if (! reload_completed\n-      && noce_process_if_block (ce_info))\n-    return TRUE;\n+  /* Only perform the noce transformations before register allocation.\n+     They could be made to run later, but this would require a lot of\n+     work, and it doesn't seem to be worth it.  */\n+  if (! reload_completed)\n+    {\n+      if (noce_process_if_block (ce_info))\n+\treturn TRUE;\n \n-  if (HAVE_conditional_move\n-      && cond_move_process_if_block (ce_info))\n-    return TRUE;\n+      if (HAVE_conditional_move\n+\t  && cond_move_process_if_block (ce_info))\n+\treturn TRUE;\n+    }\n \n   if (HAVE_conditional_execution && reload_completed)\n     {"}, {"sha": "f1c3df248d7f2767ac812d0b29129b201de1b497", "filename": "gcc/loop-init.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Floop-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Floop-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-init.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -171,12 +171,11 @@ struct tree_opt_pass pass_loop2 =\n static unsigned int\n rtl_loop_init (void)\n {\n+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n+  \n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n \n-  /* Initialize structures for layout changes.  */\n-  cfg_layout_initialize (0);\n-\n   loop_optimizer_init (LOOPS_NORMAL);\n   return 0;\n }\n@@ -204,17 +203,9 @@ struct tree_opt_pass pass_rtl_loop_init =\n static unsigned int\n rtl_loop_done (void)\n {\n-  basic_block bb;\n-\n   loop_optimizer_finalize ();\n   free_dominance_info (CDI_DOMINATORS);\n \n-  /* Finalize layout changes.  */\n-  FOR_EACH_BB (bb)\n-    if (bb->next_bb != EXIT_BLOCK_PTR)\n-      bb->aux = bb->next_bb;\n-  cfg_layout_finalize ();\n-\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n   delete_trivially_dead_insns (get_insns (), max_reg_num ());\n   reg_scan (get_insns (), max_reg_num ());"}, {"sha": "a0b4aa4b875d79d74ea805b11f2ba03fbecfe5ee", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -666,7 +666,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_gcse);\n       NEXT_PASS (pass_jump_bypass);\n       NEXT_PASS (pass_rtl_ifcvt);\n-      NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_tracer);\n       /* Perform loop optimizations.  It might be better to do them a bit\n \t sooner, but we want the profile feedback to work more\n@@ -685,6 +684,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_web);\n       NEXT_PASS (pass_cse2);\n       NEXT_PASS (pass_rtl_fwprop_addr);\n+      NEXT_PASS (pass_outof_cfg_layout_mode);\n       NEXT_PASS (pass_life);\n       NEXT_PASS (pass_combine);\n       NEXT_PASS (pass_if_after_combine);"}, {"sha": "0cc3629858feff81bda1d2b68ebda115c4476a7d", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -167,6 +167,7 @@\n #include \"recog.h\"\n #include \"output.h\"\n #include \"basic-block.h\"\n+#include \"cfglayout.h\"\n #include \"varray.h\"\n #include \"reload.h\"\n #include \"ggc.h\"\n@@ -3197,8 +3198,17 @@ rest_of_handle_stack_regs (void)\n                        | (flag_crossjumping ? CLEANUP_CROSSJUMP : 0))\n           && (flag_reorder_blocks || flag_reorder_blocks_and_partition))\n         {\n-          reorder_basic_blocks (0);\n-          cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+\t  basic_block bb;\n+\n+\t  cfg_layout_initialize (0);\n+\n+\t  reorder_basic_blocks ();\n+\t  cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n+\n+\t  FOR_EACH_BB (bb)\n+\t    if (bb->next_bb != EXIT_BLOCK_PTR)\n+\t      bb->aux = bb->next_bb;\n+\t  cfg_layout_finalize ();\n         }\n     }\n   else "}, {"sha": "81ed8bc8659af40461ec0c0888805253067a0d04", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -2259,7 +2259,7 @@ extern bool expensive_function_p (int);\n /* In cfgexpand.c */\n extern void add_reg_br_prob_note (rtx last, int probability);\n /* In tracer.c */\n-extern void tracer (unsigned int);\n+extern void tracer (void);\n \n /* In var-tracking.c */\n extern unsigned int variable_tracking_main (void);"}, {"sha": "529f9f9d84dbaebeb412873c58dd78974ca47f8b", "filename": "gcc/tracer.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ad21dab7f7977e9741b7bdace4645ae365f45b01/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=ad21dab7f7977e9741b7bdace4645ae365f45b01", "patch": "@@ -357,24 +357,25 @@ layout_superblocks (void)\n     }\n }\n \n-/* Main entry point to this file.  FLAGS is the set of flags to pass\n-   to cfg_layout_initialize().  */\n+/* Main entry point to this file.  */\n \n void\n-tracer (unsigned int flags)\n+tracer (void)\n {\n+  gcc_assert (current_ir_type () == IR_RTL_CFGLAYOUT);\n+\n   if (n_basic_blocks <= NUM_FIXED_BLOCKS + 1)\n     return;\n \n-  cfg_layout_initialize (flags);\n   mark_dfs_back_edges ();\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n   tail_duplicate ();\n   layout_superblocks ();\n+  relink_block_chain (/*stay_in_cfglayout_mode=*/true);\n+  \n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n-  cfg_layout_finalize ();\n \n   /* Merge basic blocks in duplicated traces.  */\n   cleanup_cfg (CLEANUP_EXPENSIVE);\n@@ -392,7 +393,7 @@ rest_of_handle_tracer (void)\n {\n   if (dump_file)\n     dump_flow_info (dump_file, dump_flags);\n-  tracer (0);\n+  tracer ();\n   reg_scan (get_insns (), max_reg_num ());\n   return 0;\n }"}]}