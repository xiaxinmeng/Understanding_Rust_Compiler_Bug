{"sha": "1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNjYmVmY2VmMjE4MzZkMzU0ZTI4YzA3ZTkyZmU5YTViNWVhZWRjZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-09-12T01:51:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-09-12T01:51:28Z"}, "message": "Replace recog_foo with recog_data.foo.\n\nFrom-SVN: r29349", "tree": {"sha": "b5b69b2ec9f19fc214cfaa49317c6f80265bed44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b5b69b2ec9f19fc214cfaa49317c6f80265bed44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/comments", "author": null, "committer": null, "parents": [{"sha": "24bef15854919b1b36f74ea8208c71b146975a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24bef15854919b1b36f74ea8208c71b146975a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24bef15854919b1b36f74ea8208c71b146975a0b"}], "stats": {"total": 1036, "additions": 539, "deletions": 497}, "files": [{"sha": "2b3426af9eee41bbbc7455c60d8bdbd3e5a916f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1,3 +1,40 @@\n+Sat Sep 11 18:37:04 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* recog.h (struct recog_data, recog_data): New.\n+\t(recog_foo variables): Kill.\n+\t* recog.c (recog_operand, recog_operand_loc): Kill.\n+\t(recog_dup_loc, recog_dup_num, recog_n_operands): Kill.\n+\t(recog_n_dups, recog_n_alternatives, recog_operand_mode): Kill.\n+\t(recog_constraints, recog_op_type, recog_operand_address_p): Kill.\n+\t(recog_data): Define.\n+\t(extract_insn): Update all recog_foo references to use recog_data.\n+\t(preprocess_constraints, constrain_operands): Likewise.\n+\t* final.c (final_scan_insn, cleanup_subreg_operands): Likewise.\n+\t* genattrtab.c (main): Likewise.\n+\t* genextract.c (main): Likewise.\n+\t* genoutput.c: Likewise.\n+\t* genrecog.c (write_subroutine, main): Likewise.\n+\t* local-alloc.c (block_alloc): Likewise.\n+\t* reg-stack.c (record_asm_reg_life, subst_asm_stack_regs): Likewise.\n+\t* regclass.c (scan_one_insn, record_reg_classes): Likewise.\n+\t* regmove.c (regmove_optimize, find_matches, fixup_match_1): Likewise.\n+\t* reload.c (find_reloads, find_reloads_toplev): Likewise.\n+\t* reload1.c (maybe_fix_stack_asms, eliminate_regs_in_insn): Likewise.\n+\t(reload_cse_simplify_operands): Likewise.\n+\n+\t* arc/arc.c (arc_final_prescan_insn): Likewise.\n+\t* arm/arm.c (note_invalid_constants, arm_final_prescan_insn): Likewise.\n+\t* h8300/h8300.c (notice_update_cc): Likewise.\n+\t* i386/i386.c (ix86_attr_length_default, ix86_agi_dependant): Likewise.\n+\t* i860/i860.c (output_delayed_branch, output_delay_insn): Likewise.\n+\t* mn10200/mn10200.c (notice_update_cc): Likewise.\n+\t* mn10300/mn10300.c (notice_update_cc): Likewise.\n+\t* romp/romp.c (update_cc): Likewise.\n+\t* sparc/sparc.c (check_pic): Likewise.\n+\t* v850/v850.c (notice_update_cc): Likewise.\n+\n+\t* genemit.c (main): Don't declare recog_operand.\n+\n Sat Sep 11 12:41:55 1999  Alex Samuel  <samuel@codesourcery.com>\n \n \t* ggc.h (rtvec_def): Forward declare."}, {"sha": "372ba0429b6fbd75e92f28b5cd69f548d74c300a", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -2152,7 +2152,7 @@ arc_final_prescan_insn (insn, opvec, noperands)\n \t    arc_ccfsm_current_cc = ARC_INVERSE_CONDITION_CODE (arc_ccfsm_current_cc);\n \t}\n \n-      /* Restore recog_operand.  Getting the attributes of other insns can\n+      /* Restore recog_data.  Getting the attributes of other insns can\n \t destroy this array, but final.c assumes that it remains intact\n \t across this call; since the insn has been recognized already we\n \t call insn_extract direct. */"}, {"sha": "42331079ef30a2afad780fc309e9913d20640f16", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -4258,7 +4258,7 @@ note_invalid_constants (insn, address)\n   /* Preprocess the constraints, to extract some useful information.  */\n   preprocess_constraints ();\n \n-  for (opno = 0; opno < recog_n_operands; opno++)\n+  for (opno = 0; opno < recog_data.n_operands; opno++)\n     {\n       /* Things we need to fix can only occur in inputs */\n       if (recog_op_type[opno] != OP_IN)\n@@ -4270,22 +4270,23 @@ note_invalid_constants (insn, address)\n \t now so that we output the right code.  */\n       if (recog_op_alt[opno][which_alternative].memory_ok)\n \t{\n-\t  rtx op = recog_operand[opno];\n+\t  rtx op = recog_data.operand[opno];\n \n \t  if (CONSTANT_P (op))\n-\t    push_minipool_fix (insn, address, recog_operand_loc[opno],\n-\t\t\t       recog_operand_mode[opno], op);\n+\t    push_minipool_fix (insn, address, recog_data.operand_loc[opno],\n+\t\t\t       recog_data.operand_mode[opno], op);\n #ifndef AOF_ASSEMBLER\n \t  else if (GET_CODE (op) == UNSPEC && XINT (op, 1) == 3)\n-\t    push_minipool_fix (insn, address, recog_operand_loc[opno],\n-\t\t\t       recog_operand_mode[opno], XVECEXP (op, 0, 0));\n+\t    push_minipool_fix (insn, address, recog_data.operand_loc[opno],\n+\t\t\t       recog_data.operand_mode[opno],\n+\t\t\t       XVECEXP (op, 0, 0));\n #endif\n-\t  else if (recog_operand_mode[opno] == SImode\n+\t  else if (recog_data.operand_mode[opno] == SImode\n \t\t   && GET_CODE (op) == MEM\n \t\t   && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n \t\t   && CONSTANT_POOL_ADDRESS_P (XEXP (op, 0)))\n-\t    push_minipool_fix (insn, address, recog_operand_loc[opno],\n-\t\t\t       recog_operand_mode[opno],\n+\t    push_minipool_fix (insn, address, recog_data.operand_loc[opno],\n+\t\t\t       recog_data.operand_mode[opno],\n \t\t\t       get_pool_constant (XEXP (op, 0)));\n \t}\n     }\n@@ -6711,7 +6712,8 @@ arm_final_prescan_insn (insn)\n \t  if (reverse || then_not_else)\n \t    arm_current_cc = ARM_INVERSE_CONDITION_CODE (arm_current_cc);\n \t}\n-      /* restore recog_operand (getting the attributes of other insns can\n+\n+      /* Restore recog_data (getting the attributes of other insns can\n \t destroy this array, but final.c assumes that it remains intact\n \t across this call; since the insn has been recognized already we\n \t call recog direct). */"}, {"sha": "8710e23d992a0c42006bce944b568dab8edf98ac", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1607,26 +1607,26 @@ notice_update_cc (body, insn)\n     case CC_NONE_0HIT:\n       /* Insn does not change CC, but the 0'th operand has been changed.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n       break;\n \n     case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n \t The V flag is unusable.  The C flag may or may not be known but\n \t that's ok because alter_cond will change tests to use EQ/NE.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n \t The C flag may or may not be known but that's ok because\n \t alter_cond will change tests to use EQ/NE.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_COMPARE:"}, {"sha": "38ef20ea0a5850077ae5e78ccc86470fb42e895c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -5103,29 +5103,29 @@ ix86_attr_length_default (insn)\n     case TYPE_IDIV:\n     case TYPE_PUSH:\n     case TYPE_POP:\n-      for (i = recog_n_operands - 1; i >= 0; --i)\n-        if (CONSTANT_P (recog_operand[i]))\n+      for (i = recog_data.n_operands - 1; i >= 0; --i)\n+        if (CONSTANT_P (recog_data.operand[i]))\n \t  {\n-\t    if (GET_CODE (recog_operand[i]) == CONST_INT\n-\t\t&& CONST_OK_FOR_LETTER_P (INTVAL (recog_operand[i]), 'K'))\n+\t    if (GET_CODE (recog_data.operand[i]) == CONST_INT\n+\t\t&& CONST_OK_FOR_LETTER_P (INTVAL (recog_data.operand[i]), 'K'))\n \t      len += 1;\n \t    else\n-\t      len += GET_MODE_SIZE (GET_MODE (recog_operand[0]));\n+\t      len += GET_MODE_SIZE (GET_MODE (recog_data.operand[0]));\n \t  }\n       break;\n \n     case TYPE_IMOV:\n-      if (CONSTANT_P (recog_operand[1]))\n-        len += GET_MODE_SIZE (GET_MODE (recog_operand[0]));\n+      if (CONSTANT_P (recog_data.operand[1]))\n+        len += GET_MODE_SIZE (GET_MODE (recog_data.operand[0]));\n       break;\n \n     case TYPE_CALL:\n-      if (constant_call_address_operand (recog_operand[0]))\n+      if (constant_call_address_operand (recog_data.operand[0]))\n \treturn 5;\n       break;\n \n     case TYPE_CALLV:\n-      if (constant_call_address_operand (recog_operand[1]))\n+      if (constant_call_address_operand (recog_data.operand[1]))\n \treturn 5;\n       break;\n \n@@ -5138,19 +5138,19 @@ ix86_attr_length_default (insn)\n       return 15;\n \n     case TYPE_FXCH:\n-      if (STACK_TOP_P (recog_operand[0]))\n-\treturn 2 + (REGNO (recog_operand[1]) != FIRST_STACK_REG + 1);\n+      if (STACK_TOP_P (recog_data.operand[0]))\n+\treturn 2 + (REGNO (recog_data.operand[1]) != FIRST_STACK_REG + 1);\n       else\n-\treturn 2 + (REGNO (recog_operand[0]) != FIRST_STACK_REG + 1);\n+\treturn 2 + (REGNO (recog_data.operand[0]) != FIRST_STACK_REG + 1);\n \n     default:\n       abort ();\n     }\n \n-  for (i = recog_n_operands - 1; i >= 0; --i)\n-    if (GET_CODE (recog_operand[i]) == MEM)\n+  for (i = recog_data.n_operands - 1; i >= 0; --i)\n+    if (GET_CODE (recog_data.operand[i]) == MEM)\n       {\n-\tlen += memory_address_length (XEXP (recog_operand[i], 0));\n+\tlen += memory_address_length (XEXP (recog_data.operand[i], 0));\n \tbreak;\n       }\n \n@@ -5239,10 +5239,10 @@ ix86_agi_dependant (insn, dep_insn, insn_type)\n     {\n       int i;\n       extract_insn (insn);\n-      for (i = recog_n_operands - 1; i >= 0; --i)\n-\tif (GET_CODE (recog_operand[i]) == MEM)\n+      for (i = recog_data.n_operands - 1; i >= 0; --i)\n+\tif (GET_CODE (recog_data.operand[i]) == MEM)\n \t  {\n-\t    addr = XEXP (recog_operand[i], 0);\n+\t    addr = XEXP (recog_data.operand[i], 0);\n \t    goto found;\n \t  }\n       return 0;"}, {"sha": "cb7e7f7ba28388178b8d65fd8ba1ae93516d8e65", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1440,16 +1440,16 @@ output_delayed_branch (template, operands, insn)\n \n       /* Now recognize the insn which we put in its delay slot.\n \t We must do this after outputting the branch insn,\n-\t since operands may just be a pointer to `recog_operand'.  */\n+\t since operands may just be a pointer to `recog_data.operand'.  */\n       INSN_CODE (delay_insn) = insn_code_number\n \t= recog (pat, delay_insn, NULL_PTR);\n       if (insn_code_number == -1)\n \tabort ();\n \n       for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n \t{\n-\t  if (GET_CODE (recog_operand[i]) == SUBREG)\n-\t    recog_operand[i] = alter_subreg (recog_operand[i]);\n+\t  if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+\t    recog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n \t}\n \n       insn_extract (delay_insn);\n@@ -1458,8 +1458,9 @@ output_delayed_branch (template, operands, insn)\n \n       template = insn_template[insn_code_number];\n       if (template == 0)\n-\ttemplate = (*insn_outfun[insn_code_number]) (recog_operand, delay_insn);\n-      output_asm_insn (template, recog_operand);\n+\ttemplate = ((*insn_outfun[insn_code_number])\n+\t\t    (recog_data.operand, delay_insn));\n+      output_asm_insn (template, recog_data.operand);\n     }\n   CC_STATUS_INIT;\n   return \"\";\n@@ -1476,7 +1477,7 @@ output_delay_insn (delay_insn)\n \n   /* Now recognize the insn which we put in its delay slot.\n      We must do this after outputting the branch insn,\n-     since operands may just be a pointer to `recog_operand'.  */\n+     since operands may just be a pointer to `recog_data.operand'.  */\n   insn_code_number = recog_memoized (delay_insn);\n   if (insn_code_number == -1)\n     abort ();\n@@ -1491,8 +1492,8 @@ output_delay_insn (delay_insn)\n      make sure they get fixed up here.  -- This is a kludge.  */\n   for (i = 0; i < insn_n_operands[insn_code_number]; i++)\n     {\n-      if (GET_CODE (recog_operand[i]) == SUBREG)\n-\trecog_operand[i] = alter_subreg (recog_operand[i]);\n+      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+\trecog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n     }\n \n #ifdef REGISTER_CONSTRAINTS\n@@ -1514,8 +1515,9 @@ output_delay_insn (delay_insn)\n \n   template = insn_template[insn_code_number];\n   if (template == 0)\n-    template = (*insn_outfun[insn_code_number]) (recog_operand, delay_insn);\n-  output_asm_insn (template, recog_operand);\n+    template = ((*insn_outfun[insn_code_number])\n+\t\t(recog_data.operand, delay_insn));\n+  output_asm_insn (template, recog_data.operand);\n   return \"\";\n }\n #endif"}, {"sha": "2364064d5a89d62ab35b7d51406edc9e9dfe07e2", "filename": "gcc/config/mn10200/mn10200.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fmn10200%2Fmn10200.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10200%2Fmn10200.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -818,24 +818,24 @@ notice_update_cc (body, insn)\n     case CC_NONE_0HIT:\n       /* Insn does not change CC, but the 0'th operand has been changed.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n       break;\n \n     case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n \t V,C is in an unusable state.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n \t C is in an unusable state.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_COMPARE:"}, {"sha": "80236d28177845ed7bc81d8ed92466ae003901ff", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -482,24 +482,24 @@ notice_update_cc (body, insn)\n     case CC_NONE_0HIT:\n       /* Insn does not change CC, but the 0'th operand has been changed.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n       break;\n \n     case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n \t V,C are unusable.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY | CC_OVERFLOW_UNUSABLE;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n \t C is unusable.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_COMPARE:"}, {"sha": "51bd7499d07b73f6a445193be5730c9712fbae83", "filename": "gcc/config/romp/romp.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fromp%2Fromp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fromp%2Fromp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fromp%2Fromp.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -140,11 +140,11 @@ update_cc (body, insn)\n       /* Insn doesn't affect the CC but does modify operand[0], known to be\n \t a register.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n \n       if (cc_status.value2 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))\n \tcc_status.value2 = 0;\n \n       break;\n@@ -153,20 +153,20 @@ update_cc (body, insn)\n       /* Insn copies operand[1] to operand[0], both registers, but doesn't\n          affect the CC.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n \n       if (cc_status.value2 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value2))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value2))\n \tcc_status.value2 = 0;\n \n       if (cc_status.value1 != 0\n-\t  && rtx_equal_p (cc_status.value1, recog_operand[1]))\n-\tcc_status.value2 = recog_operand[0];\n+\t  && rtx_equal_p (cc_status.value1, recog_data.operand[1]))\n+\tcc_status.value2 = recog_data.operand[0];\n \n       if (cc_status.value2 != 0\n-\t  && rtx_equal_p (cc_status.value2, recog_operand[1]))\n-\tcc_status.value1 = recog_operand[0];\n+\t  && rtx_equal_p (cc_status.value2, recog_data.operand[1]))\n+\tcc_status.value1 = recog_data.operand[0];\n \n       break;\n \n@@ -176,10 +176,10 @@ update_cc (body, insn)\n       break;\n \n     case CC_SETS:\n-      /* Insn sets CC to recog_operand[0], but overflow is impossible.  */\n+      /* Insn sets CC to recog_data.operand[0], but overflow is impossible.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_OVERFLOW;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n    case CC_COMPARE:"}, {"sha": "6d33f4e69e8762e0da4ab3459611d830f911e8ba", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -2373,12 +2373,12 @@ check_pic (i)\n   switch (flag_pic)\n     {\n     case 1:\n-      if (GET_CODE (recog_operand[i]) == SYMBOL_REF\n-\t  || (GET_CODE (recog_operand[i]) == CONST\n-\t      && ! (GET_CODE (XEXP (recog_operand[i], 0)) == MINUS\n-\t\t    && (XEXP (XEXP (recog_operand[i], 0), 0)\n+      if (GET_CODE (recog_data.operand[i]) == SYMBOL_REF\n+\t  || (GET_CODE (recog_data.operand[i]) == CONST\n+\t      && ! (GET_CODE (XEXP (recog_data.operand[i], 0)) == MINUS\n+\t\t    && (XEXP (XEXP (recog_data.operand[i], 0), 0)\n \t\t\t== global_offset_table)\n-\t\t    && (GET_CODE (XEXP (XEXP (recog_operand[i], 0), 1))\n+\t\t    && (GET_CODE (XEXP (XEXP (recog_data.operand[i], 0), 1))\n \t\t\t== CONST))))\n \tabort ();\n     case 2:"}, {"sha": "0b68cede1eaae709193b8d1a9f5990b1ba5a55b8", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1959,24 +1959,24 @@ notice_update_cc (body, insn)\n     case CC_NONE_0HIT:\n       /* Insn does not change CC, but the 0'th operand has been changed.  */\n       if (cc_status.value1 != 0\n-\t  && reg_overlap_mentioned_p (recog_operand[0], cc_status.value1))\n+\t  && reg_overlap_mentioned_p (recog_data.operand[0], cc_status.value1))\n \tcc_status.value1 = 0;\n       break;\n \n     case CC_SET_ZN:\n-      /* Insn sets the Z,N flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N flags of CC to recog_data.operand[0].\n \t V,C is in an unusable state.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_OVERFLOW_UNUSABLE | CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_SET_ZNV:\n-      /* Insn sets the Z,N,V flags of CC to recog_operand[0].\n+      /* Insn sets the Z,N,V flags of CC to recog_data.operand[0].\n \t C is in an unusable state.  */\n       CC_STATUS_INIT;\n       cc_status.flags |= CC_NO_CARRY;\n-      cc_status.value1 = recog_operand[0];\n+      cc_status.value1 = recog_data.operand[0];\n       break;\n \n     case CC_COMPARE:"}, {"sha": "6ace9b24f940910063291b2afdd9a92a6a197bef", "filename": "gcc/final.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -2873,7 +2873,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \t   it is output.  */\n \n #ifdef FINAL_PRESCAN_INSN\n-\tFINAL_PRESCAN_INSN (insn, recog_operand, recog_n_operands);\n+\tFINAL_PRESCAN_INSN (insn, recog_data.operand, recog_data.n_operands);\n #endif\n \n #ifdef HAVE_cc0\n@@ -2901,7 +2901,8 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \ttemplate = insn_template[insn_code_number];\n \tif (template == 0)\n \t  {\n-\t    template = (*insn_outfun[insn_code_number]) (recog_operand, insn);\n+\t    template = ((*insn_outfun[insn_code_number])\n+\t\t\t(recog_data.operand, insn));\n \n \t    /* If the C code returns 0, it means that it is a jump insn\n \t       which follows a deleted test insn, and that test insn\n@@ -2941,7 +2942,7 @@ final_scan_insn (insn, file, optimize, prescan, nopeepholes)\n \n \t/* Output assembler code from the template.  */\n \n-\toutput_asm_insn (template, recog_operand);\n+\toutput_asm_insn (template, recog_data.operand);\n \n #if defined (DWARF2_UNWIND_INFO)\n #if !defined (ACCUMULATE_OUTGOING_ARGS)\n@@ -3050,22 +3051,22 @@ cleanup_subreg_operands (insn)\n   int i;\n \n   extract_insn (insn);\n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n-      if (GET_CODE (recog_operand[i]) == SUBREG)\n-        recog_operand[i] = alter_subreg (recog_operand[i]);\n-      else if (GET_CODE (recog_operand[i]) == PLUS\n-               || GET_CODE (recog_operand[i]) == MULT)\n-       recog_operand[i] = walk_alter_subreg (recog_operand[i]);\n+      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n+        recog_data.operand[i] = alter_subreg (recog_data.operand[i]);\n+      else if (GET_CODE (recog_data.operand[i]) == PLUS\n+               || GET_CODE (recog_data.operand[i]) == MULT)\n+       recog_data.operand[i] = walk_alter_subreg (recog_data.operand[i]);\n     }\n \n-  for (i = 0; i < recog_n_dups; i++)\n+  for (i = 0; i < recog_data.n_dups; i++)\n     {\n-      if (GET_CODE (*recog_dup_loc[i]) == SUBREG)\n-        *recog_dup_loc[i] = alter_subreg (*recog_dup_loc[i]);\n-      else if (GET_CODE (*recog_dup_loc[i]) == PLUS\n-               || GET_CODE (*recog_dup_loc[i]) == MULT)\n-        *recog_dup_loc[i] = walk_alter_subreg (*recog_dup_loc[i]);\n+      if (GET_CODE (*recog_data.dup_loc[i]) == SUBREG)\n+        *recog_data.dup_loc[i] = alter_subreg (*recog_data.dup_loc[i]);\n+      else if (GET_CODE (*recog_data.dup_loc[i]) == PLUS\n+               || GET_CODE (*recog_data.dup_loc[i]) == MULT)\n+        *recog_data.dup_loc[i] = walk_alter_subreg (*recog_data.dup_loc[i]);\n     }\n }\n "}, {"sha": "4196c7d81246c18c4c5cc7711ccb8e2d43651093", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -6083,7 +6083,7 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"insn-attr.h\\\"\\n\");\n   printf (\"#include \\\"toplev.h\\\"\\n\");\n   printf (\"\\n\");  \n-  printf (\"#define operands recog_operand\\n\\n\");\n+  printf (\"#define operands recog_data.operand\\n\\n\");\n \n   /* Make `insn_alternatives'.  */\n   insn_alternatives = (int *) oballoc (insn_code_number * sizeof (int));"}, {"sha": "bad78b537f54fc2b46e1d7f6c4cec0b2c9bf60a1", "filename": "gcc/genemit.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenemit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenemit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenemit.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -818,7 +818,6 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"#include \\\"hard-reg-set.h\\\"\\n\");\n   printf (\"#include \\\"resource.h\\\"\\n\");\n   printf (\"#include \\\"reload.h\\\"\\n\\n\");\n-  printf (\"extern rtx recog_operand[];\\n\");\n   printf (\"#define FAIL return (end_sequence (), _val)\\n\");\n   printf (\"#define DONE return (_val = gen_sequence (), end_sequence (), _val)\\n\");\n "}, {"sha": "35ffbd099bcc996fa739dc7566b106f1b6849180", "filename": "gcc/genextract.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenextract.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -424,8 +424,8 @@ from the machine description file `md'.  */\\n\\n\");\n   printf (\"void\\ninsn_extract (insn)\\n\");\n   printf (\"     rtx insn;\\n\");\n   printf (\"{\\n\");\n-  printf (\"  register rtx *ro = recog_operand;\\n\");\n-  printf (\"  register rtx **ro_loc = recog_operand_loc;\\n\");\n+  printf (\"  register rtx *ro = recog_data.operand;\\n\");\n+  printf (\"  register rtx **ro_loc = recog_data.operand_loc;\\n\");\n   printf (\"  rtx pat = PATTERN (insn);\\n\");\n   printf (\"  int i ATTRIBUTE_UNUSED;\\n\\n\");\n   printf (\"  memset (ro, 0, sizeof (*ro) * MAX_RECOG_OPERANDS);\\n\");\n@@ -506,10 +506,10 @@ from the machine description file `md'.  */\\n\\n\");\n \n       for (i = 0; i < p->dup_count; i++)\n \t{\n-\t  printf (\"      recog_dup_loc[%d] = &\", i);\n+\t  printf (\"      recog_data.dup_loc[%d] = &\", i);\n \t  print_path (p->duplocs[i]);\n \t  printf (\";\\n\");\n-\t  printf (\"      recog_dup_num[%d] = %d;\\n\", i, p->dupnums[i]);\n+\t  printf (\"      recog_data.dup_num[%d] = %d;\\n\", i, p->dupnums[i]);\n \t}\n \n       printf (\"      break;\\n\\n\");"}, {"sha": "87c8b98a70a0b1649dcb81bbf8cc57440e3917fd", "filename": "gcc/genoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenoutput.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -44,7 +44,7 @@ Boston, MA 02111-1307, USA.  */\n \n    6. An array of ints `insn_n_dups' which is indexed by insn code number\n    and contains the number of match_dup's that appear in the insn's pattern.\n-   This says how many elements of `recog_dup_loc' are significant\n+   This says how many elements of `recog_data.dup_loc' are significant\n    after an insn has been recognized.\n \n    7. An array of arrays of operand constraint strings,"}, {"sha": "2c2978b4b050c25a28178dc323d47160f8d38c63", "filename": "gcc/genrecog.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1142,7 +1142,7 @@ write_subroutine (tree, type)\n     printf (\"     rtx *_plast_insn ATTRIBUTE_UNUSED;\\n\");\n \n   printf (\"{\\n\");\n-  printf (\"  register rtx *ro = &recog_operand[0];\\n\");\n+  printf (\"  register rtx *ro = &recog_data.operand[0];\\n\");\n \n   printf (\"  register rtx \");\n   for (i = 1; i < max_depth; i++)\n@@ -1969,7 +1969,7 @@ from the machine description file `md'.  */\\n\\n\");\n \n   printf (\"*/\\n\\n\");\n \n-  printf (\"#define operands recog_operand\\n\\n\");\n+  printf (\"#define operands recog_data.operand\\n\\n\");\n \n   next_subroutine_number = 0;\n   break_out_subroutines (recog_tree, RECOG, 1);"}, {"sha": "76c384a1604d0370cab2a57142b91433d6e5ae94", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1111,12 +1111,12 @@ block_alloc (b)\n \n \t  if (1\n #ifdef REGISTER_CONSTRAINTS\n-\t      && recog_n_operands > 1\n-\t      && recog_constraints[0][0] == '='\n-\t      && recog_constraints[0][1] != '&'\n+\t      && recog_data.n_operands > 1\n+\t      && recog_data.constraints[0][0] == '='\n+\t      && recog_data.constraints[0][1] != '&'\n #else\n \t      && GET_CODE (PATTERN (insn)) == SET\n-\t      && rtx_equal_p (SET_DEST (PATTERN (insn)), recog_operand[0])\n+\t      && rtx_equal_p (SET_DEST (PATTERN (insn)), recog_data.operand[0])\n #endif\n \t      )\n \t    {\n@@ -1127,19 +1127,19 @@ block_alloc (b)\n \t\t operand 0.  */\n \t      int n_matching_alts = 0;\n \n-\t      for (i = 1; i < recog_n_operands; i++)\n+\t      for (i = 1; i < recog_data.n_operands; i++)\n \t\t{\n-\t\t  const char *p = recog_constraints[i];\n+\t\t  const char *p = recog_data.constraints[i];\n \t\t  int this_match = (requires_inout (p));\n \n \t\t  n_matching_alts += this_match;\n-\t\t  if (this_match == recog_n_alternatives)\n+\t\t  if (this_match == recog_data.n_alternatives)\n \t\t    must_match_0 = i;\n \t\t}\n #endif\n \n-\t      r0 = recog_operand[0];\n-\t      for (i = 1; i < recog_n_operands; i++)\n+\t      r0 = recog_data.operand[0];\n+\t      for (i = 1; i < recog_data.n_operands; i++)\n \t\t{\n #ifdef REGISTER_CONSTRAINTS\n \t\t  /* Skip this operand if we found an operand that\n@@ -1148,31 +1148,31 @@ block_alloc (b)\n \n \t\t  if (must_match_0 >= 0 && i != must_match_0\n \t\t      && ! (i == must_match_0 + 1\n-\t\t\t    && recog_constraints[i-1][0] == '%')\n+\t\t\t    && recog_data.constraints[i-1][0] == '%')\n \t\t      && ! (i == must_match_0 - 1\n-\t\t\t    && recog_constraints[i][0] == '%'))\n+\t\t\t    && recog_data.constraints[i][0] == '%'))\n \t\t    continue;\n \n \t\t  /* Likewise if each alternative has some operand that\n \t\t     must match operand zero.  In that case, skip any \n \t\t     operand that doesn't list operand 0 since we know that\n \t\t     the operand always conflicts with operand 0.  We\n \t\t     ignore commutatity in this case to keep things simple.  */\n-\t\t  if (n_matching_alts == recog_n_alternatives\n-\t\t      && 0 == requires_inout (recog_constraints[i]))\n+\t\t  if (n_matching_alts == recog_data.n_alternatives\n+\t\t      && 0 == requires_inout (recog_data.constraints[i]))\n \t\t    continue;\n #endif\n \n-\t\t  r1 = recog_operand[i];\n+\t\t  r1 = recog_data.operand[i];\n \n \t\t  /* If the operand is an address, find a register in it.\n \t\t     There may be more than one register, but we only try one\n \t\t     of them.  */\n \t\t  if (\n #ifdef REGISTER_CONSTRAINTS\n-\t\t      recog_constraints[i][0] == 'p'\n+\t\t      recog_data.constraints[i][0] == 'p'\n #else\n-\t\t      recog_operand_address_p[i]\n+\t\t      recog_data.operand_address_p[i]\n #endif\n \t\t      )\n \t\t    while (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n@@ -1186,7 +1186,7 @@ block_alloc (b)\n \t\t\t priority to an equivalence found from that insn.  */\n \t\t      int may_save_copy\n #ifdef REGISTER_CONSTRAINTS\n-\t\t\t= (r1 == recog_operand[i] && must_match_0 >= 0);\n+\t\t\t= (r1 == recog_data.operand[i] && must_match_0 >= 0);\n #else\n \t\t\t= (SET_DEST (body) == r0 && SET_SRC (body) == r1);\n #endif"}, {"sha": "2ec59111f64c9ccb3bf7527b445f6faabf71f04b", "filename": "gcc/recog.c", "status": "modified", "additions": 51, "deletions": 88, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -68,45 +68,7 @@ static int insn_invalid_p\t\tPROTO((rtx));\n \n int volatile_ok;\n \n-/* The next variables are set up by extract_insn.  The first four of them\n-   are also set up during insn_extract.  */\n-\n-/* Indexed by N, gives value of operand N.  */\n-rtx recog_operand[MAX_RECOG_OPERANDS];\n-\n-/* Indexed by N, gives location where operand N was found.  */\n-rtx *recog_operand_loc[MAX_RECOG_OPERANDS];\n-\n-/* Indexed by N, gives location where the Nth duplicate-appearance of\n-   an operand was found.  This is something that matched MATCH_DUP.  */\n-rtx *recog_dup_loc[MAX_RECOG_OPERANDS];\n-\n-/* Indexed by N, gives the operand number that was duplicated in the\n-   Nth duplicate-appearance of an operand.  */\n-char recog_dup_num[MAX_RECOG_OPERANDS];\n-\n-/* The number of operands of the insn.  */\n-int recog_n_operands;\n-\n-/* The number of MATCH_DUPs in the insn.  */\n-int recog_n_dups;\n-\n-/* The number of alternatives in the constraints for the insn.  */\n-int recog_n_alternatives;\n-\n-/* Indexed by N, gives the mode of operand N.  */\n-enum machine_mode recog_operand_mode[MAX_RECOG_OPERANDS];\n-\n-/* Indexed by N, gives the constraint string for operand N.  */\n-const char *recog_constraints[MAX_RECOG_OPERANDS];\n-\n-/* Indexed by N, gives the type (in, out, inout) for operand N.  */\n-enum op_type recog_op_type[MAX_RECOG_OPERANDS];\n-\n-#ifndef REGISTER_CONSTRAINTS\n-/* Indexed by N, nonzero if operand N should be an address.  */\n-char recog_operand_address_p[MAX_RECOG_OPERANDS];\n-#endif\n+struct recog_data recog_data;\n \n /* Contains a vector of operand_alternative structures for every operand.\n    Set up by preprocess_constraints.  */\n@@ -2000,11 +1962,8 @@ adj_offsettable_operand (op, offset)\n   abort ();\n }\n \f\n-/* Analyze INSN and compute the variables recog_n_operands, recog_n_dups,\n-   recog_n_alternatives, recog_operand, recog_operand_loc, recog_constraints,\n-   recog_operand_mode, recog_dup_loc and recog_dup_num.\n-   If REGISTER_CONSTRAINTS is not defined, also compute\n-   recog_operand_address_p.  */\n+/* Analyze INSN and fill in recog_data.  */\n+\n void\n extract_insn (insn)\n      rtx insn;\n@@ -2014,9 +1973,9 @@ extract_insn (insn)\n   int noperands;\n   rtx body = PATTERN (insn);\n \n-  recog_n_operands = 0;\n-  recog_n_alternatives = 0;\n-  recog_n_dups = 0;\n+  recog_data.n_operands = 0;\n+  recog_data.n_alternatives = 0;\n+  recog_data.n_dups = 0;\n \n   switch (GET_CODE (body))\n     {\n@@ -2030,7 +1989,7 @@ extract_insn (insn)\n     case SET:\n     case PARALLEL:\n     case ASM_OPERANDS:\n-      recog_n_operands = noperands = asm_noperands (body);\n+      recog_data.n_operands = noperands = asm_noperands (body);\n       if (noperands >= 0)\n \t{\n \t  /* This insn is an `asm' with operands.  */\n@@ -2040,17 +1999,20 @@ extract_insn (insn)\n \t    abort ();\n \n \t  /* Now get the operand values and constraints out of the insn.  */\n-\t  decode_asm_operands (body, recog_operand, recog_operand_loc,\n-\t\t\t       recog_constraints, recog_operand_mode);\n+\t  decode_asm_operands (body, recog_data.operand,\n+\t\t\t       recog_data.operand_loc,\n+\t\t\t       recog_data.constraints,\n+\t\t\t       recog_data.operand_mode);\n \t  if (noperands > 0)\n \t    {\n-\t      const char *p =  recog_constraints[0];\n-\t      recog_n_alternatives = 1;\n+\t      const char *p =  recog_data.constraints[0];\n+\t      recog_data.n_alternatives = 1;\n \t      while (*p)\n-\t\trecog_n_alternatives += (*p++ == ',');\n+\t\trecog_data.n_alternatives += (*p++ == ',');\n \t    }\n #ifndef REGISTER_CONSTRAINTS\n-\t  bzero (recog_operand_address_p, sizeof recog_operand_address_p);\n+\t  bzero (recog_data.operand_address_p,\n+\t\t sizeof recog_data.operand_address_p);\n #endif\n \t  break;\n \t}\n@@ -2065,28 +2027,29 @@ extract_insn (insn)\n       if (icode < 0)\n \tfatal_insn_not_found (insn);\n \n-      recog_n_operands = noperands = insn_n_operands[icode];\n-      recog_n_alternatives = insn_n_alternatives[icode];\n-      recog_n_dups = insn_n_dups[icode];\n+      recog_data.n_operands = noperands = insn_n_operands[icode];\n+      recog_data.n_alternatives = insn_n_alternatives[icode];\n+      recog_data.n_dups = insn_n_dups[icode];\n \n       insn_extract (insn);\n \n       for (i = 0; i < noperands; i++)\n \t{\n #ifdef REGISTER_CONSTRAINTS\n-\t  recog_constraints[i] = insn_operand_constraint[icode][i];\n+\t  recog_data.constraints[i] = insn_operand_constraint[icode][i];\n #else\n-\t  recog_operand_address_p[i] = insn_operand_address_p[icode][i];\n+\t  recog_data.operand_address_p[i] = insn_operand_address_p[icode][i];\n #endif\n-\t  recog_operand_mode[i] = insn_operand_mode[icode][i];\n+\t  recog_data.operand_mode[i] = insn_operand_mode[icode][i];\n \t}\n     }\n   for (i = 0; i < noperands; i++)\n-    recog_op_type[i] = (recog_constraints[i][0] == '=' ? OP_OUT\n-\t\t\t: recog_constraints[i][0] == '+' ? OP_INOUT\n-\t\t\t: OP_IN);\n+    recog_data.operand_type[i]\n+      = (recog_data.constraints[i][0] == '=' ? OP_OUT\n+\t : recog_data.constraints[i][0] == '+' ? OP_INOUT\n+\t : OP_IN);\n \n-  if (recog_n_alternatives > MAX_RECOG_ALTERNATIVES)\n+  if (recog_data.n_alternatives > MAX_RECOG_ALTERNATIVES)\n     abort ();\n }\n \n@@ -2099,15 +2062,15 @@ preprocess_constraints ()\n   int i;\n \n   bzero (recog_op_alt, sizeof recog_op_alt);\n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n       int j;\n       struct operand_alternative *op_alt;\n-      const char *p = recog_constraints[i];\n+      const char *p = recog_data.constraints[i];\n \n       op_alt = recog_op_alt[i];\n \n-      for (j = 0; j < recog_n_alternatives; j++)\n+      for (j = 0; j < recog_data.n_alternatives; j++)\n \t{\n \t  op_alt[j].class = NO_REGS;\n \t  op_alt[j].constraint = p;\n@@ -2241,26 +2204,26 @@ constrain_operands (strict)\n   struct funny_match funny_match[MAX_RECOG_OPERANDS];\n   int funny_match_index;\n \n-  if (recog_n_operands == 0 || recog_n_alternatives == 0)\n+  if (recog_data.n_operands == 0 || recog_data.n_alternatives == 0)\n     return 1;\n \n-  for (c = 0; c < recog_n_operands; c++)\n+  for (c = 0; c < recog_data.n_operands; c++)\n     {\n-      constraints[c] = recog_constraints[c];\n+      constraints[c] = recog_data.constraints[c];\n       matching_operands[c] = -1;\n     }\n \n   which_alternative = 0;\n \n-  while (which_alternative < recog_n_alternatives)\n+  while (which_alternative < recog_data.n_alternatives)\n     {\n       register int opno;\n       int lose = 0;\n       funny_match_index = 0;\n \n-      for (opno = 0; opno < recog_n_operands; opno++)\n+      for (opno = 0; opno < recog_data.n_operands; opno++)\n \t{\n-\t  register rtx op = recog_operand[opno];\n+\t  register rtx op = recog_data.operand[opno];\n \t  enum machine_mode mode = GET_MODE (op);\n \t  register const char *p = constraints[opno];\n \t  int offset = 0;\n@@ -2320,8 +2283,8 @@ constrain_operands (strict)\n \t\t  val = 1;\n \t\telse\n \t\t  {\n-\t\t    rtx op1 = recog_operand[c - '0'];\n-\t\t    rtx op2 = recog_operand[opno];\n+\t\t    rtx op1 = recog_data.operand[c - '0'];\n+\t\t    rtx op2 = recog_data.operand[opno];\n \n \t            /* A unary operator may be accepted by the predicate,\n \t\t       but it is irrelevant for matching constraints.  */\n@@ -2354,7 +2317,7 @@ constrain_operands (strict)\n \t\t   strictly valid, i.e., that all pseudos requiring hard regs\n \t\t   have gotten them.  */\n \t\tif (strict <= 0\n-\t\t    || (strict_memory_address_p (recog_operand_mode[opno],\n+\t\t    || (strict_memory_address_p (recog_data.operand_mode[opno],\n \t\t\t\t\t\t op)))\n \t\t  win = 1;\n \t\tbreak;\n@@ -2535,31 +2498,31 @@ constrain_operands (strict)\n \t     operand.  */\n \n \t  if (strict > 0)\n-\t    for (eopno = 0; eopno < recog_n_operands; eopno++)\n+\t    for (eopno = 0; eopno < recog_data.n_operands; eopno++)\n \t      /* Ignore earlyclobber operands now in memory,\n \t\t because we would often report failure when we have\n \t\t two memory operands, one of which was formerly a REG.  */\n \t      if (earlyclobber[eopno]\n-\t\t  && GET_CODE (recog_operand[eopno]) == REG)\n-\t\tfor (opno = 0; opno < recog_n_operands; opno++)\n-\t\t  if ((GET_CODE (recog_operand[opno]) == MEM\n-\t\t       || recog_op_type[opno] != OP_OUT)\n+\t\t  && GET_CODE (recog_data.operand[eopno]) == REG)\n+\t\tfor (opno = 0; opno < recog_data.n_operands; opno++)\n+\t\t  if ((GET_CODE (recog_data.operand[opno]) == MEM\n+\t\t       || recog_data.operand_type[opno] != OP_OUT)\n \t\t      && opno != eopno\n \t\t      /* Ignore things like match_operator operands.  */\n-\t\t      && *recog_constraints[opno] != 0\n+\t\t      && *recog_data.constraints[opno] != 0\n \t\t      && ! (matching_operands[opno] == eopno\n-\t\t\t    && operands_match_p (recog_operand[opno],\n-\t\t\t\t\t\t recog_operand[eopno]))\n-\t\t      && ! safe_from_earlyclobber (recog_operand[opno],\n-\t\t\t\t\t\t   recog_operand[eopno]))\n+\t\t\t    && operands_match_p (recog_data.operand[opno],\n+\t\t\t\t\t\t recog_data.operand[eopno]))\n+\t\t      && ! safe_from_earlyclobber (recog_data.operand[opno],\n+\t\t\t\t\t\t   recog_data.operand[eopno]))\n \t\t    lose = 1;\n \n \t  if (! lose)\n \t    {\n \t      while (--funny_match_index >= 0)\n \t\t{\n-\t\t  recog_operand[funny_match[funny_match_index].other]\n-\t\t    = recog_operand[funny_match[funny_match_index].this];\n+\t\t  recog_data.operand[funny_match[funny_match_index].other]\n+\t\t    = recog_data.operand[funny_match[funny_match_index].this];\n \t\t}\n \n \t      return 1;"}, {"sha": "55ddb29c26aeb3f54be43a6799d8fcbef6ff28b8", "filename": "gcc/recog.h", "status": "modified", "additions": 36, "deletions": 27, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -127,44 +127,53 @@ extern int which_alternative;\n \n /* The following vectors hold the results from insn_extract.  */\n \n-/* Indexed by N, gives value of operand N.  */\n-extern rtx recog_operand[];\n+struct recog_data\n+{\n+  /* It is very tempting to make the 5 operand related arrays into a\n+     structure and index on that.  However, to be source compatible\n+     with all of the existing md file insn constraints and output\n+     templates, we need `operand' as a flat array.  Without that\n+     member, making an array for the rest seems pointless.  */\n \n-/* Indexed by N, gives location where operand N was found.  */\n-extern rtx *recog_operand_loc[];\n+  /* Gives value of operand N.  */\n+  rtx operand[MAX_RECOG_OPERANDS];\n \n-/* Indexed by N, gives location where the Nth duplicate-appearance of\n-   an operand was found.  This is something that matched MATCH_DUP.  */\n-extern rtx *recog_dup_loc[];\n+  /* Gives location where operand N was found.  */\n+  rtx *operand_loc[MAX_RECOG_OPERANDS];\n \n-/* Indexed by N, gives the operand number that was duplicated in the\n-   Nth duplicate-appearance of an operand.  */\n-extern char recog_dup_num[];\n+  /* Gives the constraint string for operand N.  */\n+  const char *constraints[MAX_RECOG_OPERANDS];\n \n-/* The next variables are set up by extract_insn.  */\n+  /* Gives the mode of operand N.  */\n+  enum machine_mode operand_mode[MAX_RECOG_OPERANDS];\n \n-/* The number of operands of the insn.  */\n-extern int recog_n_operands;\n+  /* Gives the type (in, out, inout) for operand N.  */\n+  enum op_type operand_type[MAX_RECOG_OPERANDS];\n \n-/* The number of MATCH_DUPs in the insn.  */\n-extern int recog_n_dups;\n+  /* Gives location where the Nth duplicate-appearance of an operand\n+     was found.  This is something that matched MATCH_DUP.  */\n+  rtx *dup_loc[MAX_DUP_OPERANDS];\n \n-/* The number of alternatives in the constraints for the insn.  */\n-extern int recog_n_alternatives;\n+  /* Gives the operand number that was duplicated in the Nth\n+     duplicate-appearance of an operand.  */\n+  unsigned char dup_num[MAX_DUP_OPERANDS];\n \n-/* Indexed by N, gives the mode of operand N.  */\n-extern enum machine_mode recog_operand_mode[];\n+#ifndef REGISTER_CONSTRAINTS\n+  /* Nonzero if operand N should be an address.  */\n+  unsigned char operand_address_p[MAX_RECOG_OPERANDS];\n+#endif\n \n-/* Indexed by N, gives the constraint string for operand N.  */\n-extern const char *recog_constraints[];\n+  /* The number of operands of the insn.  */\n+  unsigned char n_operands;\n \n-/* Indexed by N, gives the type (in, out, inout) for operand N.  */\n-extern enum op_type recog_op_type[];\n+  /* The number of MATCH_DUPs in the insn.  */\n+  unsigned char n_dups;\n \n-#ifndef REGISTER_CONSTRAINTS\n-/* Indexed by N, nonzero if operand N should be an address.  */\n-extern char recog_operand_address_p[];\n-#endif\n+  /* The number of alternatives in the constraints for the insn.  */\n+  unsigned char n_alternatives;\n+};\n+\n+extern struct recog_data recog_data;\n \n /* Contains a vector of operand_alternative structures for every operand.\n    Set up by preprocess_constraints.  */"}, {"sha": "f1b35b82d5678b6e3e168b138dc65de20e525feb", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -711,7 +711,7 @@ record_asm_reg_life (insn, regstack)\n   preprocess_constraints ();\n \n   n_inputs = get_asm_operand_n_inputs (body);\n-  n_outputs = recog_n_operands - n_inputs;\n+  n_outputs = recog_data.n_operands - n_inputs;\n \n   if (alt < 0)\n     {\n@@ -723,10 +723,10 @@ record_asm_reg_life (insn, regstack)\n     }\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n-  for (i = 0; i < recog_n_operands; i++)\n-    if (GET_CODE (recog_operand[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (recog_operand[i])) == REG)\n-      recog_operand[i] = SUBREG_REG (recog_operand[i]);\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    if (GET_CODE (recog_data.operand[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (recog_data.operand[i])) == REG)\n+      recog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n \n   /* Set up CLOBBER_REG.  */\n \n@@ -762,15 +762,15 @@ record_asm_reg_life (insn, regstack)\n \n   bzero ((char *) reg_used_as_output, sizeof (reg_used_as_output));\n   for (i = 0; i < n_outputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n \tif (reg_class_size[(int) recog_op_alt[i][alt].class] != 1)\n \t  {\n \t    error_for_asm (insn, \"Output constraint %d must specify a single register\", i);\n \t    malformed_asm = 1;\n \t  }\n         else\n-\t  reg_used_as_output[REGNO (recog_operand[i])] = 1;\n+\t  reg_used_as_output[REGNO (recog_data.operand[i])] = 1;\n       }\n \n \n@@ -796,18 +796,18 @@ record_asm_reg_life (insn, regstack)\n \n   bzero ((char *) implicitly_dies, sizeof (implicitly_dies));\n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n \t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n-\t  if (operands_match_p (clobber_reg[j], recog_operand[i]))\n+\t  if (operands_match_p (clobber_reg[j], recog_data.operand[i]))\n \t    break;\n \n \tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n-\t  implicitly_dies[REGNO (recog_operand[i])] = 1;\n+\t  implicitly_dies[REGNO (recog_data.operand[i])] = 1;\n       }\n \n   /* Search for first non-popped reg.  */\n@@ -839,7 +839,7 @@ record_asm_reg_life (insn, regstack)\n \tint j;\n \n \tfor (j = 0; j < n_outputs; j++)\n-\t  if (operands_match_p (recog_operand[j], recog_operand[i]))\n+\t  if (operands_match_p (recog_data.operand[j], recog_data.operand[i]))\n \t    {\n \t      error_for_asm (insn,\n \t\t\t     \"Output operand %d must use `&' constraint\", j);\n@@ -858,7 +858,7 @@ record_asm_reg_life (insn, regstack)\n   /* Process all outputs */\n   for (i = 0; i < n_outputs; i++)\n     {\n-      rtx op = recog_operand[i];\n+      rtx op = recog_data.operand[i];\n \n       if (! STACK_REG_P (op))\n \t{\n@@ -882,7 +882,7 @@ record_asm_reg_life (insn, regstack)\n   /* Process all inputs */\n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n     {\n-      rtx op = recog_operand[i];\n+      rtx op = recog_data.operand[i];\n       if (! STACK_REG_P (op))\n \t{\n \t  if (stack_regs_mentioned_p (op))\n@@ -2280,18 +2280,18 @@ subst_asm_stack_regs (insn, regstack)\n   preprocess_constraints ();\n \n   n_inputs = get_asm_operand_n_inputs (body);\n-  n_outputs = recog_n_operands - n_inputs;\n+  n_outputs = recog_data.n_operands - n_inputs;\n   \n   if (alt < 0)\n     abort ();\n \n   /* Strip SUBREGs here to make the following code simpler.  */\n-  for (i = 0; i < recog_n_operands; i++)\n-    if (GET_CODE (recog_operand[i]) == SUBREG\n-\t&& GET_CODE (SUBREG_REG (recog_operand[i])) == REG)\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    if (GET_CODE (recog_data.operand[i]) == SUBREG\n+\t&& GET_CODE (SUBREG_REG (recog_data.operand[i])) == REG)\n       {\n-\trecog_operand_loc[i] = & SUBREG_REG (recog_operand[i]);\n-\trecog_operand[i] = SUBREG_REG (recog_operand[i]);\n+\trecog_data.operand_loc[i] = & SUBREG_REG (recog_data.operand[i]);\n+\trecog_data.operand[i] = SUBREG_REG (recog_data.operand[i]);\n       }\n \n   /* Set up NOTE_REG, NOTE_LOC and NOTE_KIND.  */\n@@ -2362,34 +2362,34 @@ subst_asm_stack_regs (insn, regstack)\n   /* Put the input regs into the desired place in TEMP_STACK.  */\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (STACK_REG_P (recog_operand[i])\n+    if (STACK_REG_P (recog_data.operand[i])\n \t&& reg_class_subset_p (recog_op_alt[i][alt].class,\n \t\t\t       FLOAT_REGS)\n \t&& recog_op_alt[i][alt].class != FLOAT_REGS)\n       {\n \t/* If an operand needs to be in a particular reg in\n \t   FLOAT_REGS, the constraint was either 't' or 'u'.  Since\n-\t   these constraints are for single register classes, and reload\n-\t   guaranteed that operand[i] is already in that class, we can\n-\t   just use REGNO (recog_operand[i]) to know which actual reg this\n-\t   operand needs to be in.  */\n+\t   these constraints are for single register classes, and\n+\t   reload guaranteed that operand[i] is already in that class,\n+\t   we can just use REGNO (recog_data.operand[i]) to know which\n+\t   actual reg this operand needs to be in.  */\n \n-\tint regno = get_hard_regnum (&temp_stack, recog_operand[i]);\n+\tint regno = get_hard_regnum (&temp_stack, recog_data.operand[i]);\n \n \tif (regno < 0)\n \t  abort ();\n \n-\tif (regno != REGNO (recog_operand[i]))\n+\tif (regno != REGNO (recog_data.operand[i]))\n \t  {\n-\t    /* recog_operand[i] is not in the right place.  Find it\n-\t       and swap it with whatever is already in I's place.\n-\t       K is where recog_operand[i] is now.  J is where it should\n-\t       be.  */\n+\t    /* recog_data.operand[i] is not in the right place.  Find\n+\t       it and swap it with whatever is already in I's place.\n+\t       K is where recog_data.operand[i] is now.  J is where it\n+\t       should be.  */\n \t    int j, k, temp;\n \n \t    k = temp_stack.top - (regno - FIRST_STACK_REG);\n \t    j = (temp_stack.top\n-\t\t - (REGNO (recog_operand[i]) - FIRST_STACK_REG));\n+\t\t - (REGNO (recog_data.operand[i]) - FIRST_STACK_REG));\n \n \t    temp = temp_stack.reg[k];\n \t    temp_stack.reg[k] = temp_stack.reg[j];\n@@ -2406,14 +2406,14 @@ subst_asm_stack_regs (insn, regstack)\n      clobbers too, because these are for inputs, not outputs.  */\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n-\tint regnum = get_hard_regnum (regstack, recog_operand[i]);\n+\tint regnum = get_hard_regnum (regstack, recog_data.operand[i]);\n \n \tif (regnum < 0)\n \t  abort ();\n \n-\treplace_reg (recog_operand_loc[i], regnum);\n+\treplace_reg (recog_data.operand_loc[i], regnum);\n       }\n \n   for (i = 0; i < n_notes; i++)\n@@ -2446,23 +2446,23 @@ subst_asm_stack_regs (insn, regstack)\n   /* Now remove from REGSTACK any inputs that the asm implicitly popped.  */\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n \t/* An input reg is implicitly popped if it is tied to an\n \t   output, or if there is a CLOBBER for it.  */\n \tint j;\n \n \tfor (j = 0; j < n_clobbers; j++)\n-\t  if (operands_match_p (clobber_reg[j], recog_operand[i]))\n+\t  if (operands_match_p (clobber_reg[j], recog_data.operand[i]))\n \t    break;\n \n \tif (j < n_clobbers || recog_op_alt[i][alt].matches >= 0)\n \t  {\n-\t    /* recog_operand[i] might not be at the top of stack.  But that's\n-\t       OK, because all we need to do is pop the right number of regs\n-\t       off of the top of the reg-stack.  record_asm_stack_regs\n-\t       guaranteed that all implicitly popped regs were grouped\n-\t       at the top of the reg-stack.  */\n+\t    /* recog_data.operand[i] might not be at the top of stack.\n+\t       But that's OK, because all we need to do is pop the\n+\t       right number of regs off of the top of the reg-stack.\n+\t       record_asm_stack_regs guaranteed that all implicitly\n+\t       popped regs were grouped at the top of the reg-stack.  */\n \n \t    CLEAR_HARD_REG_BIT (regstack->reg_set,\n \t\t\t\tregstack->reg[regstack->top]);\n@@ -2480,7 +2480,8 @@ subst_asm_stack_regs (insn, regstack)\n       int j;\n \n       for (j = 0; j < n_outputs; j++)\n-\tif (STACK_REG_P (recog_operand[j]) && REGNO (recog_operand[j]) == i)\n+\tif (STACK_REG_P (recog_data.operand[j])\n+\t    && REGNO (recog_data.operand[j]) == i)\n \t  {\n \t    regstack->reg[++regstack->top] = i;\n \t    SET_HARD_REG_BIT (regstack->reg_set, i);\n@@ -2496,32 +2497,32 @@ subst_asm_stack_regs (insn, regstack)\n      in the death notes have already been substituted.  */\n \n   for (i = 0; i < n_outputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n \tint j;\n \n \tfor (j = 0; j < n_notes; j++)\n-\t  if (REGNO (recog_operand[i]) == REGNO (note_reg[j])\n+\t  if (REGNO (recog_data.operand[i]) == REGNO (note_reg[j])\n \t      && note_kind[j] == REG_UNUSED)\n \t    {\n-\t      insn = emit_pop_insn (insn, regstack, recog_operand[i],\n+\t      insn = emit_pop_insn (insn, regstack, recog_data.operand[i],\n \t\t\t\t    emit_insn_after);\n \t      break;\n \t    }\n       }\n \n   for (i = n_outputs; i < n_outputs + n_inputs; i++)\n-    if (STACK_REG_P (recog_operand[i]))\n+    if (STACK_REG_P (recog_data.operand[i]))\n       {\n \tint j;\n \n \tfor (j = 0; j < n_notes; j++)\n-\t  if (REGNO (recog_operand[i]) == REGNO (note_reg[j])\n+\t  if (REGNO (recog_data.operand[i]) == REGNO (note_reg[j])\n \t      && note_kind[j] == REG_DEAD\n \t      && TEST_HARD_REG_BIT (regstack->reg_set,\n-\t\t\t\t    REGNO (recog_operand[i])))\n+\t\t\t\t    REGNO (recog_data.operand[i])))\n \t    {\n-\t      insn = emit_pop_insn (insn, regstack, recog_operand[i],\n+\t      insn = emit_pop_insn (insn, regstack, recog_data.operand[i],\n \t\t\t\t    emit_insn_after);\n \t      break;\n \t    }"}, {"sha": "5867024c93bd8037a4c922081e8c1ecd8596cb7a", "filename": "gcc/regclass.c", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -791,10 +791,10 @@ scan_one_insn (insn, pass)\n   set = single_set (insn);\n   extract_insn (insn);\n \n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n-      constraints[i] = recog_constraints[i];\n-      modes[i] = recog_operand_mode[i];\n+      constraints[i] = recog_data.constraints[i];\n+      modes[i] = recog_data.operand_mode[i];\n     }\n   memset (subreg_changes_size, 0, sizeof (subreg_changes_size));\n \n@@ -830,24 +830,22 @@ scan_one_insn (insn, pass)\n      do this during our first pass.  */\n \n   if (pass == 0 && optimize\n-      && recog_n_operands >= 3\n-      && recog_constraints[1][0] == '0'\n-      && recog_constraints[1][1] == 0\n-      && CONSTANT_P (recog_operand[1])\n-      && ! rtx_equal_p (recog_operand[0], recog_operand[1])\n-      && ! rtx_equal_p (recog_operand[0], recog_operand[2])\n-      && GET_CODE (recog_operand[0]) == REG\n-      && MODES_TIEABLE_P (GET_MODE (recog_operand[0]),\n-\t\t\t  recog_operand_mode[1]))\n+      && recog_data.n_operands >= 3\n+      && recog_data.constraints[1][0] == '0'\n+      && recog_data.constraints[1][1] == 0\n+      && CONSTANT_P (recog_data.operand[1])\n+      && ! rtx_equal_p (recog_data.operand[0], recog_data.operand[1])\n+      && ! rtx_equal_p (recog_data.operand[0], recog_data.operand[2])\n+      && GET_CODE (recog_data.operand[0]) == REG\n+      && MODES_TIEABLE_P (GET_MODE (recog_data.operand[0]),\n+\t\t\t  recog_data.operand_mode[1]))\n     {\n       rtx previnsn = prev_real_insn (insn);\n       rtx dest\n-\t= gen_lowpart (recog_operand_mode[1],\n-\t\t       recog_operand[0]);\n+\t= gen_lowpart (recog_data.operand_mode[1],\n+\t\t       recog_data.operand[0]);\n       rtx newinsn\n-\t= emit_insn_before (gen_move_insn (dest,\n-\t\t\t\t\t   recog_operand[1]),\n-\t\t\t    insn);\n+\t= emit_insn_before (gen_move_insn (dest, recog_data.operand[1]), insn);\n \n       /* If this insn was the start of a basic block,\n \t include the new insn in that block.\n@@ -863,12 +861,12 @@ scan_one_insn (insn, pass)\n \t}\n \n       /* This makes one more setting of new insns's dest.  */\n-      REG_N_SETS (REGNO (recog_operand[0]))++;\n+      REG_N_SETS (REGNO (recog_data.operand[0]))++;\n \n-      *recog_operand_loc[1] = recog_operand[0];\n-      for (i = recog_n_dups - 1; i >= 0; i--)\n-\tif (recog_dup_num[i] == 1)\n-\t  *recog_dup_loc[i] = recog_operand[0];\n+      *recog_data.operand_loc[1] = recog_data.operand[0];\n+      for (i = recog_data.n_dups - 1; i >= 0; i--)\n+\tif (recog_data.dup_num[i] == 1)\n+\t  *recog_data.dup_loc[i] = recog_data.operand[0];\n \n       return PREV_INSN (newinsn);\n     }\n@@ -879,31 +877,31 @@ scan_one_insn (insn, pass)\n      classes for any pseudos, doing it twice if some pair of\n      operands are commutative.  */\n \t     \n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n       op_costs[i] = init_cost;\n \n-      if (GET_CODE (recog_operand[i]) == SUBREG)\n+      if (GET_CODE (recog_data.operand[i]) == SUBREG)\n \t{\n-\t  rtx inner = SUBREG_REG (recog_operand[i]);\n+\t  rtx inner = SUBREG_REG (recog_data.operand[i]);\n \t  if (GET_MODE_SIZE (modes[i]) != GET_MODE_SIZE (GET_MODE (inner)))\n \t    subreg_changes_size[i] = 1;\n-\t  recog_operand[i] = inner;\n+\t  recog_data.operand[i] = inner;\n \t}\n \n-      if (GET_CODE (recog_operand[i]) == MEM)\n-\trecord_address_regs (XEXP (recog_operand[i], 0),\n+      if (GET_CODE (recog_data.operand[i]) == MEM)\n+\trecord_address_regs (XEXP (recog_data.operand[i], 0),\n \t\t\t     BASE_REG_CLASS, loop_cost * 2);\n       else if (constraints[i][0] == 'p')\n-\trecord_address_regs (recog_operand[i],\n+\trecord_address_regs (recog_data.operand[i],\n \t\t\t     BASE_REG_CLASS, loop_cost * 2);\n     }\n \n   /* Check for commutative in a separate loop so everything will\n      have been initialized.  We must do this even if one operand\n      is a constant--see addsi3 in m68k.md.  */\n \n-  for (i = 0; i < recog_n_operands - 1; i++)\n+  for (i = 0; i < recog_data.n_operands - 1; i++)\n     if (constraints[i][0] == '%')\n       {\n \tconst char *xconstraints[MAX_RECOG_OPERANDS];\n@@ -912,27 +910,28 @@ scan_one_insn (insn, pass)\n \t/* Handle commutative operands by swapping the constraints.\n \t   We assume the modes are the same.  */\n \n-\tfor (j = 0; j < recog_n_operands; j++)\n+\tfor (j = 0; j < recog_data.n_operands; j++)\n \t  xconstraints[j] = constraints[j];\n \n \txconstraints[i] = constraints[i+1];\n \txconstraints[i+1] = constraints[i];\n-\trecord_reg_classes (recog_n_alternatives, recog_n_operands,\n-\t\t\t    recog_operand, modes, subreg_changes_size,\n+\trecord_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n+\t\t\t    recog_data.operand, modes, subreg_changes_size,\n \t\t\t    xconstraints, insn);\n       }\n \n-  record_reg_classes (recog_n_alternatives, recog_n_operands, recog_operand,\n-\t\t      modes, subreg_changes_size, constraints, insn);\n+  record_reg_classes (recog_data.n_alternatives, recog_data.n_operands,\n+\t\t      recog_data.operand, modes, subreg_changes_size,\n+\t\t      constraints, insn);\n \n   /* Now add the cost for each operand to the total costs for\n      its register.  */\n \n-  for (i = 0; i < recog_n_operands; i++)\n-    if (GET_CODE (recog_operand[i]) == REG\n-\t&& REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n+  for (i = 0; i < recog_data.n_operands; i++)\n+    if (GET_CODE (recog_data.operand[i]) == REG\n+\t&& REGNO (recog_data.operand[i]) >= FIRST_PSEUDO_REGISTER)\n       {\n-\tint regno = REGNO (recog_operand[i]);\n+\tint regno = REGNO (recog_data.operand[i]);\n \tstruct costs *p = &costs[regno], *q = &op_costs[i];\n \n \tp->mem_cost += q->mem_cost * loop_cost;\n@@ -1472,10 +1471,10 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \n \t  else if (classes[i] != NO_REGS)\n \t    {\n-\t      if (recog_op_type[i] != OP_OUT)\n+\t      if (recog_data.operand_type[i] != OP_OUT)\n \t\talt_cost += copy_cost (op, mode, classes[i], 1);\n \n-\t      if (recog_op_type[i] != OP_IN)\n+\t      if (recog_data.operand_type[i] != OP_IN)\n \t\talt_cost += copy_cost (op, mode, classes[i], 0);\n \t    }\n \n@@ -1499,7 +1498,7 @@ record_reg_classes (n_alts, n_ops, ops, modes, subreg_changes_size,\n \t    && REGNO (ops[i]) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    struct costs *pp = &op_costs[i], *qq = &this_op_costs[i];\n-\t    int scale = 1 + (recog_op_type[i] == OP_INOUT);\n+\t    int scale = 1 + (recog_data.operand_type[i] == OP_INOUT);\n \n \t    pp->mem_cost = MIN (pp->mem_cost,\n \t\t\t\t(qq->mem_cost + alt_cost) * scale);"}, {"sha": "fea96c9dabe2f1597f3d252abf7df6afbf141c0a", "filename": "gcc/regmove.c", "status": "modified", "additions": 34, "deletions": 26, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1173,7 +1173,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t     If it dies there, then replace the dest in both operands with\n \t     the source operand.  */\n \n-\t  for (op_no = 0; op_no < recog_n_operands; op_no++)\n+\t  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n \t    {\n \t      rtx src, dst, src_subreg;\n \t      enum reg_class src_class, dst_class;\n@@ -1184,8 +1184,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      if (match_no < 0)\n \t\tcontinue;\n \n-\t      src = recog_operand[op_no];\n-\t      dst = recog_operand[match_no];\n+\t      src = recog_data.operand[op_no];\n+\t      dst = recog_data.operand[match_no];\n \n \t      if (GET_CODE (src) != REG)\n \t\tcontinue;\n@@ -1225,20 +1225,23 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\tcontinue;\n \n \t      /* Make sure match_operand is the destination.  */\n-\t      if (recog_operand[match_no] != SET_DEST (set))\n+\t      if (recog_data.operand[match_no] != SET_DEST (set))\n \t\tcontinue;\n \n-\t      /* If the operands already match, then there is nothing to do.  */\n-\t      /* But in the commutative case, we might find a better match.  */\n-\t      if (operands_match_p (src, dst)\n-\t\t  || (match.commutative[op_no] >= 0\n-\t\t      && operands_match_p (recog_operand[match.commutative\n-\t\t\t\t\t\t\t [op_no]], dst)\n-\t\t      && (replacement_quality (recog_operand[match.commutative\n-\t\t\t\t\t\t\t     [op_no]])\n-\t\t\t  >= replacement_quality (src))))\n+\t      /* If the operands already match, then there is nothing to do. */\n+\t      if (operands_match_p (src, dst))\n \t\tcontinue;\n \n+\t      /* But in the commutative case, we might find a better match.  */\n+\t      if (match.commutative[op_no] >= 0)\n+\t\t{\n+\t\t  rtx comm = recog_data.operand[match.commutative[op_no]];\n+\t\t  if (operands_match_p (comm, dst)\n+\t\t      && (replacement_quality (comm)\n+\t\t\t  >= replacement_quality (src)))\n+\t\t    continue;\n+\t\t}\n+\n \t      src_class = reg_preferred_class (REGNO (src));\n \t      dst_class = reg_preferred_class (REGNO (dst));\n \t      if (! regclass_compatible_p (src_class, dst_class))\n@@ -1284,7 +1287,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \n \t  copy_src = NULL_RTX;\n \t  copy_dst = NULL_RTX;\n-\t  for (op_no = 0; op_no < recog_n_operands; op_no++)\n+\t  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n \t    {\n \t      rtx set, p, src, dst;\n \t      rtx src_note, dst_note;\n@@ -1298,8 +1301,8 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t      if (match_no < 0)\n \t\tcontinue;\n \n-\t      dst = recog_operand[match_no];\n-\t      src = recog_operand[op_no];\n+\t      dst = recog_data.operand[match_no];\n+\t      src = recog_data.operand[op_no];\n \n \t      if (GET_CODE (src) != REG)\n \t\tcontinue;\n@@ -1309,12 +1312,17 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t  || REG_LIVE_LENGTH (REGNO (dst)) < 0)\n \t\tcontinue;\n \n-\t      /* If the operands already match, then there is nothing to do.  */\n-\t      if (operands_match_p (src, dst)\n-\t\t  || (match.commutative[op_no] >= 0\n-\t\t      && operands_match_p (recog_operand[match.commutative[op_no]], dst)))\n+\t      /* If the operands already match, then there is nothing to do. */\n+\t      if (operands_match_p (src, dst))\n \t\tcontinue;\n \n+\t      if (match.commutative[op_no] >= 0)\n+\t\t{\n+\t\t  rtx comm = recog_data.operand[match.commutative[op_no]];\n+\t\t  if (operands_match_p (comm, dst))\n+\t\t    continue;\n+\t\t}\n+\n \t      set = single_set (insn);\n \t      if (! set)\n \t\tcontinue;\n@@ -1330,7 +1338,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\tcontinue;\n \n \t      /* Make sure match_no is the destination.  */\n-\t      if (recog_operand[match_no] != SET_DEST (set))\n+\t      if (recog_data.operand[match_no] != SET_DEST (set))\n \t\tcontinue;\n \n \t      if (REGNO (src) < FIRST_PSEUDO_REGISTER)\n@@ -1450,7 +1458,7 @@ regmove_optimize (f, nregs, regmove_dump_file)\n \t\t\t      validate_replace_rtx (dst, src, insn);\n \t\t\t      /* Now make sure the dst is right.  */\n \t\t\t      validate_change (insn,\n-\t\t\t\t\t       recog_operand_loc[match_no],\n+\t\t\t\t\t       recog_data.operand_loc[match_no],\n \t\t\t\t\t       dst, 0);\n \t\t\t    }\n \t\t\t}\n@@ -1582,16 +1590,16 @@ find_matches (insn, matchp)\n   /* Must initialize this before main loop, because the code for\n      the commutative case may set matches for operands other than\n      the current one.  */\n-  for (op_no = recog_n_operands; --op_no >= 0; )\n+  for (op_no = recog_data.n_operands; --op_no >= 0; )\n     matchp->with[op_no] = matchp->commutative[op_no] = -1;\n \n-  for (op_no = 0; op_no < recog_n_operands; op_no++)\n+  for (op_no = 0; op_no < recog_data.n_operands; op_no++)\n     {\n       const char *p;\n       char c;\n       int i = 0;\n \n-      p = recog_constraints[op_no];\n+      p = recog_data.constraints[op_no];\n \n       likely_spilled[op_no] = 0;\n       matchp->use[op_no] = READ;\n@@ -1841,7 +1849,7 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t      validate_change (q, &XEXP (SET_SRC (set2), 1),\n \t\t\t       GEN_INT (newconst), 1);\n \t    }\n-\t  validate_change (insn, recog_operand_loc[match_number], src, 1);\n+\t  validate_change (insn, recog_data.operand_loc[match_number], src, 1);\n \t  if (validate_replace_rtx (dst, src_subreg, p))\n \t    success = 1;\n \t  break;"}, {"sha": "d8afc6e70fc5c11d5a33627037456c68bb4284f0", "filename": "gcc/reload.c", "status": "modified", "additions": 139, "deletions": 119, "changes": 258, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -2515,8 +2515,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   extract_insn (insn);\n \n-  noperands = reload_n_operands = recog_n_operands;\n-  n_alternatives = recog_n_alternatives;\n+  noperands = reload_n_operands = recog_data.n_operands;\n+  n_alternatives = recog_data.n_alternatives;\n \n   /* Just return \"no reloads\" if insn has no operands with constraints.  */\n   if (noperands == 0 || n_alternatives == 0)\n@@ -2525,9 +2525,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   insn_code_number = INSN_CODE (insn);\n   this_insn_is_asm = insn_code_number < 0;\n \n-  bcopy ((char *) recog_operand_mode, (char *) operand_mode,\n+  bcopy ((char *) recog_data.operand_mode, (char *) operand_mode,\n \t noperands * sizeof (enum machine_mode));\n-  bcopy ((char *) recog_constraints, (char *) constraints,\n+  bcopy ((char *) recog_data.constraints, (char *) constraints,\n \t noperands * sizeof (char *));\n \n   commutative = -1;\n@@ -2542,7 +2542,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       register char *p;\n       register int c;\n \n-      substed_operand[i] = recog_operand[i];\n+      substed_operand[i] = recog_data.operand[i];\n       p = constraints[i];\n \n       modified[i] = RELOAD_READ;\n@@ -2568,7 +2568,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    {\n \t      c -= '0';\n \t      operands_match[c][i]\n-\t\t= operands_match_p (recog_operand[c], recog_operand[i]);\n+\t\t= operands_match_p (recog_data.operand[c],\n+\t\t\t\t    recog_data.operand[i]);\n \n \t      /* An operand may not match itself.  */\n \t      if (c == i)\n@@ -2582,13 +2583,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t    {\n \t\t      int other = c + (c == commutative ? 1 : -1);\n \t\t      operands_match[other][i]\n-\t\t\t= operands_match_p (recog_operand[other], recog_operand[i]);\n+\t\t\t= operands_match_p (recog_data.operand[other],\n+\t\t\t\t\t    recog_data.operand[i]);\n \t\t    }\n \t\t  if (i == commutative || i == commutative + 1)\n \t\t    {\n \t\t      int other = i + (i == commutative ? 1 : -1);\n \t\t      operands_match[c][other]\n-\t\t\t= operands_match_p (recog_operand[c], recog_operand[other]);\n+\t\t\t= operands_match_p (recog_data.operand[c],\n+\t\t\t\t\t    recog_data.operand[other]);\n \t\t    }\n \t\t  /* Note that C is supposed to be less than I.\n \t\t     No need to consider altering both C and I because in\n@@ -2608,7 +2611,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   for (i = 0; i < noperands; i++)\n     {\n-      register RTX_CODE code = GET_CODE (recog_operand[i]);\n+      register RTX_CODE code = GET_CODE (recog_data.operand[i]);\n \n       address_reloaded[i] = 0;\n       operand_type[i] = (modified[i] == RELOAD_READ ? RELOAD_FOR_INPUT\n@@ -2625,42 +2628,45 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       else if (constraints[i][0] == 'p')\n \t{\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n-\t\t\t\trecog_operand[i], recog_operand_loc[i],\n+\t\t\t\trecog_data.operand[i],\n+\t\t\t\trecog_data.operand_loc[i],\n \t\t\t\ti, operand_type[i], ind_levels, insn);\n \n \t  /* If we now have a simple operand where we used to have a\n \t     PLUS or MULT, re-recognize and try again.  */\n-\t  if ((GET_RTX_CLASS (GET_CODE (*recog_operand_loc[i])) == 'o'\n-\t       || GET_CODE (*recog_operand_loc[i]) == SUBREG)\n-\t      && (GET_CODE (recog_operand[i]) == MULT\n-\t\t  || GET_CODE (recog_operand[i]) == PLUS))\n+\t  if ((GET_RTX_CLASS (GET_CODE (*recog_data.operand_loc[i])) == 'o'\n+\t       || GET_CODE (*recog_data.operand_loc[i]) == SUBREG)\n+\t      && (GET_CODE (recog_data.operand[i]) == MULT\n+\t\t  || GET_CODE (recog_data.operand[i]) == PLUS))\n \t    {\n \t      INSN_CODE (insn) = -1;\n \t      retval = find_reloads (insn, replace, ind_levels, live_known,\n \t\t\t\t     reload_reg_p);\n \t      return retval;\n \t    }\n \n-\t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n+\t  recog_data.operand[i] = *recog_data.operand_loc[i];\n+\t  substed_operand[i] = recog_data.operand[i];\n \t}\n       else if (code == MEM)\n \t{\n \t  address_reloaded[i]\n-\t    = find_reloads_address (GET_MODE (recog_operand[i]),\n-\t\t\t\t    recog_operand_loc[i],\n-\t\t\t\t    XEXP (recog_operand[i], 0),\n-\t\t\t\t    &XEXP (recog_operand[i], 0),\n+\t    = find_reloads_address (GET_MODE (recog_data.operand[i]),\n+\t\t\t\t    recog_data.operand_loc[i],\n+\t\t\t\t    XEXP (recog_data.operand[i], 0),\n+\t\t\t\t    &XEXP (recog_data.operand[i], 0),\n \t\t\t\t    i, address_type[i], ind_levels, insn);\n-\t  substed_operand[i] = recog_operand[i] = *recog_operand_loc[i];\n+\t  recog_data.operand[i] = *recog_data.operand_loc[i];\n+\t  substed_operand[i] = recog_data.operand[i];\n \t}\n       else if (code == SUBREG)\n \t{\n-\t  rtx reg = SUBREG_REG (recog_operand[i]);\n+\t  rtx reg = SUBREG_REG (recog_data.operand[i]);\n \t  rtx op\n-\t    = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\t    = find_reloads_toplev (recog_data.operand[i], i, address_type[i],\n \t\t\t\t   ind_levels,\n \t\t\t\t   set != 0\n-\t\t\t\t   && &SET_DEST (set) == recog_operand_loc[i],\n+\t\t\t\t   && &SET_DEST (set) == recog_data.operand_loc[i],\n \t\t\t\t   insn);\n \n \t  /* If we made a MEM to load (a part of) the stackslot of a pseudo\n@@ -2677,14 +2683,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      = gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t\t   reg_equiv_memory_loc[REGNO (reg)], NULL_RTX);\n \n-\t  substed_operand[i] = recog_operand[i] = op;\n+\t  substed_operand[i] = recog_data.operand[i] = op;\n \t}\n       else if (code == PLUS || GET_RTX_CLASS (code) == '1')\n \t/* We can get a PLUS as an \"operand\" as a result of register\n \t   elimination.  See eliminate_regs and gen_reload.  We handle\n \t   a unary operator by reloading the operand.  */\n-\tsubsted_operand[i] = recog_operand[i]\n-\t  = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\tsubsted_operand[i] = recog_data.operand[i]\n+\t  = find_reloads_toplev (recog_data.operand[i], i, address_type[i],\n \t\t\t\t ind_levels, 0, insn);\n       else if (code == REG)\n \t{\n@@ -2694,36 +2700,39 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     we replace it by the constant.  We must be sure, however,\n \t     that we don't try to replace it in the insn in which it\n \t     is being set.   */\n-\t  register int regno = REGNO (recog_operand[i]);\n+\t  register int regno = REGNO (recog_data.operand[i]);\n \t  if (reg_equiv_constant[regno] != 0\n-\t      && (set == 0 || &SET_DEST (set) != recog_operand_loc[i]))\n+\t      && (set == 0 || &SET_DEST (set) != recog_data.operand_loc[i]))\n \t    {\n \t      /* Record the existing mode so that the check if constants are\n \t\t allowed will work when operand_mode isn't specified. */\n \n \t      if (operand_mode[i] == VOIDmode)\n-\t\toperand_mode[i] = GET_MODE (recog_operand[i]);\n+\t\toperand_mode[i] = GET_MODE (recog_data.operand[i]);\n \n-\t      substed_operand[i] = recog_operand[i]\n+\t      substed_operand[i] = recog_data.operand[i]\n \t\t= reg_equiv_constant[regno];\n \t    }\n \t  if (reg_equiv_memory_loc[regno] != 0\n \t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n \t    /* We need not give a valid is_set_dest argument since the case\n \t       of a constant equivalence was checked above.  */\n-\t    substed_operand[i] = recog_operand[i]\n-\t      = find_reloads_toplev (recog_operand[i], i, address_type[i],\n+\t    substed_operand[i] = recog_data.operand[i]\n+\t      = find_reloads_toplev (recog_data.operand[i], i, address_type[i],\n \t\t\t\t     ind_levels, 0, insn);\n \t}\n       /* If the operand is still a register (we didn't replace it with an\n \t equivalent), get the preferred class to reload it into.  */\n-      code = GET_CODE (recog_operand[i]);\n+      code = GET_CODE (recog_data.operand[i]);\n       preferred_class[i]\n-\t= ((code == REG && REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER)\n-\t   ? reg_preferred_class (REGNO (recog_operand[i])) : NO_REGS);\n+\t= ((code == REG && REGNO (recog_data.operand[i])\n+\t    >= FIRST_PSEUDO_REGISTER)\n+\t   ? reg_preferred_class (REGNO (recog_data.operand[i]))\n+\t   : NO_REGS);\n       pref_or_nothing[i]\n-\t= (code == REG && REGNO (recog_operand[i]) >= FIRST_PSEUDO_REGISTER\n-\t   && reg_alternate_class (REGNO (recog_operand[i])) == NO_REGS);\n+\t= (code == REG\n+\t   && REGNO (recog_data.operand[i]) >= FIRST_PSEUDO_REGISTER\n+\t   && reg_alternate_class (REGNO (recog_data.operand[i])) == NO_REGS);\n     }\n \n #ifdef HAVE_cc0\n@@ -2737,8 +2746,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   /* If this is simply a copy from operand 1 to operand 0, merge the\n      preferred classes for the operands.  */\n-  if (set != 0 && noperands >= 2 && recog_operand[0] == SET_DEST (set)\n-      && recog_operand[1] == SET_SRC (set))\n+  if (set != 0 && noperands >= 2 && recog_data.operand[0] == SET_DEST (set)\n+      && recog_data.operand[1] == SET_SRC (set))\n     {\n       preferred_class[0] = preferred_class[1]\n \t= reg_class_subunion[(int) preferred_class[0]][(int) preferred_class[1]];\n@@ -2793,7 +2802,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  /* 0 => this operand can be reloaded if the alternative allows regs.  */\n \t  int winreg = 0;\n \t  int c;\n-\t  register rtx operand = recog_operand[i];\n+\t  register rtx operand = recog_data.operand[i];\n \t  int offset = 0;\n \t  /* Nonzero means this is a MEM that must be reloaded into a reg\n \t     regardless of what the constraint says.  */\n@@ -2958,7 +2967,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t       offsettable address was expected, then we must reject\n \t\t       this combination, because we can't reload it.  */\n \t\t    if (this_alternative_offmemok[c]\n-\t\t\t&& GET_CODE (recog_operand[c]) == MEM\n+\t\t\t&& GET_CODE (recog_data.operand[c]) == MEM\n \t\t\t&& this_alternative[c] == (int) NO_REGS\n \t\t\t&& ! this_alternative_win[c])\n \t\t      bad = 1;\n@@ -2979,8 +2988,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t    /* But count the pair only once in the total badness of\n \t\t       this alternative, if the pair can be a dummy reload.  */\n \t\t    value\n-\t\t      = find_dummy_reload (recog_operand[i], recog_operand[c],\n-\t\t\t\t\t   recog_operand_loc[i], recog_operand_loc[c],\n+\t\t      = find_dummy_reload (recog_data.operand[i],\n+\t\t\t\t\t   recog_data.operand[c],\n+\t\t\t\t\t   recog_data.operand_loc[i],\n+\t\t\t\t\t   recog_data.operand_loc[c],\n \t\t\t\t\t   operand_mode[i], operand_mode[c],\n \t\t\t\t\t   this_alternative[c], -1,\n \t\t\t\t\t   this_alternative_earlyclobber[c]);\n@@ -3206,7 +3217,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\twinreg = 1;\n \t\tif (GET_CODE (operand) == REG\n \t\t    && reg_fits_class_p (operand, this_alternative[i],\n-\t\t\t\t\t offset, GET_MODE (recog_operand[i])))\n+\t\t\t\t\t offset, GET_MODE (recog_data.operand[i])))\n \t\t  win = 1;\n \t\tbreak;\n \t      }\n@@ -3355,7 +3366,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    struct decomposition early_data;\n \n-\t    early_data = decompose (recog_operand[i]);\n+\t    early_data = decompose (recog_data.operand[i]);\n \n \t    if (modified[i] == RELOAD_READ)\n \t      abort ();\n@@ -3372,23 +3383,25 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t    for (j = 0; j < noperands; j++)\n \t      /* Is this an input operand or a memory ref?  */\n-\t      if ((GET_CODE (recog_operand[j]) == MEM\n+\t      if ((GET_CODE (recog_data.operand[j]) == MEM\n \t\t   || modified[j] != RELOAD_WRITE)\n \t\t  && j != i\n \t\t  /* Ignore things like match_operator operands.  */\n-\t\t  && *recog_constraints[j] != 0\n+\t\t  && *recog_data.constraints[j] != 0\n \t\t  /* Don't count an input operand that is constrained to match\n \t\t     the early clobber operand.  */\n \t\t  && ! (this_alternative_matches[j] == i\n-\t\t\t&& rtx_equal_p (recog_operand[i], recog_operand[j]))\n+\t\t\t&& rtx_equal_p (recog_data.operand[i],\n+\t\t\t\t\trecog_data.operand[j]))\n \t\t  /* Is it altered by storing the earlyclobber operand?  */\n-\t\t  && !immune_p (recog_operand[j], recog_operand[i], early_data))\n+\t\t  && !immune_p (recog_data.operand[j], recog_data.operand[i],\n+\t\t\t\tearly_data))\n \t\t{\n \t\t  /* If the output is in a single-reg class,\n \t\t     it's costly to reload it, so reload the input instead.  */\n \t\t  if (reg_class_size[this_alternative[i]] == 1\n-\t\t      && (GET_CODE (recog_operand[j]) == REG\n-\t\t\t  || GET_CODE (recog_operand[j]) == SUBREG))\n+\t\t      && (GET_CODE (recog_data.operand[j]) == REG\n+\t\t\t  || GET_CODE (recog_data.operand[j]) == SUBREG))\n \t\t    {\n \t\t      losers++;\n \t\t      this_alternative_win[j] = 0;\n@@ -3419,8 +3432,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  /* Unswap these so that they are never swapped at `finish'.  */\n \t  if (commutative >= 0)\n \t    {\n-\t      recog_operand[commutative] = substed_operand[commutative];\n-\t      recog_operand[commutative + 1]\n+\t      recog_data.operand[commutative] = substed_operand[commutative];\n+\t      recog_data.operand[commutative + 1]\n \t\t= substed_operand[commutative + 1];\n \t    }\n \t  for (i = 0; i < noperands; i++)\n@@ -3482,8 +3495,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  register enum reg_class tclass;\n \t  register int t;\n \n-\t  recog_operand[commutative] = substed_operand[commutative + 1];\n-\t  recog_operand[commutative + 1] = substed_operand[commutative];\n+\t  recog_data.operand[commutative] = substed_operand[commutative + 1];\n+\t  recog_data.operand[commutative + 1] = substed_operand[commutative];\n \n \t  tclass = preferred_class[commutative];\n \t  preferred_class[commutative] = preferred_class[commutative + 1];\n@@ -3493,14 +3506,15 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  pref_or_nothing[commutative] = pref_or_nothing[commutative + 1];\n \t  pref_or_nothing[commutative + 1] = t;\n \n-\t  bcopy ((char *) recog_constraints, (char *) constraints,\n+\t  bcopy ((char *) recog_data.constraints, (char *) constraints,\n \t\t noperands * sizeof (char *));\n \t  goto try_swapped;\n \t}\n       else\n \t{\n-\t  recog_operand[commutative] = substed_operand[commutative];\n-\t  recog_operand[commutative + 1] = substed_operand[commutative + 1];\n+\t  recog_data.operand[commutative] = substed_operand[commutative];\n+\t  recog_data.operand[commutative + 1]\n+\t    = substed_operand[commutative + 1];\n \t}\n     }\n \n@@ -3550,12 +3564,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       tem = substed_operand[commutative];\n       substed_operand[commutative] = substed_operand[commutative + 1];\n       substed_operand[commutative + 1] = tem;\n-      tem = recog_operand[commutative];\n-      recog_operand[commutative] = recog_operand[commutative + 1];\n-      recog_operand[commutative + 1] = tem;\n-      tem = *recog_operand_loc[commutative];\n-      *recog_operand_loc[commutative] = *recog_operand_loc[commutative+1];\n-      *recog_operand_loc[commutative+1] = tem;\n+      tem = recog_data.operand[commutative];\n+      recog_data.operand[commutative] = recog_data.operand[commutative + 1];\n+      recog_data.operand[commutative + 1] = tem;\n+      tem = *recog_data.operand_loc[commutative];\n+      *recog_data.operand_loc[commutative]\n+\t= *recog_data.operand_loc[commutative + 1];\n+      *recog_data.operand_loc[commutative+1] = tem;\n \n       for (i = 0; i < n_reloads; i++)\n \t{\n@@ -3589,28 +3604,28 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       if (goal_alternative_earlyclobber[i] && operand_type[i] != RELOAD_OTHER)\n \toperand_type[i]\n-\t  = (find_reg_note (insn, REG_UNUSED, recog_operand[i])\n+\t  = (find_reg_note (insn, REG_UNUSED, recog_data.operand[i])\n \t     ? RELOAD_FOR_INSN : RELOAD_OTHER);\n     }\n \n   /* Any constants that aren't allowed and can't be reloaded\n      into registers are here changed into memory references.  */\n   for (i = 0; i < noperands; i++)\n     if (! goal_alternative_win[i]\n-\t&& CONSTANT_P (recog_operand[i])\n+\t&& CONSTANT_P (recog_data.operand[i])\n \t/* force_const_mem does not accept HIGH.  */\n-\t&& GET_CODE (recog_operand[i]) != HIGH\n-\t&& ((PREFERRED_RELOAD_CLASS (recog_operand[i],\n+\t&& GET_CODE (recog_data.operand[i]) != HIGH\n+\t&& ((PREFERRED_RELOAD_CLASS (recog_data.operand[i],\n \t\t\t\t     (enum reg_class) goal_alternative[i])\n \t     == NO_REGS)\n \t    || no_input_reloads)\n \t&& operand_mode[i] != VOIDmode)\n       {\n-\tsubsted_operand[i] = recog_operand[i]\n+\tsubsted_operand[i] = recog_data.operand[i]\n \t  = find_reloads_toplev (force_const_mem (operand_mode[i],\n-\t\t\t\t\t\t  recog_operand[i]),\n+\t\t\t\t\t\t  recog_data.operand[i]),\n \t\t\t\t i, address_type[i], ind_levels, 0, insn);\n-\tif (alternative_allows_memconst (recog_constraints[i],\n+\tif (alternative_allows_memconst (recog_data.constraints[i],\n \t\t\t\t\t goal_alternative_number))\n \t  goal_alternative_win[i] = 1;\n       }\n@@ -3619,7 +3634,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   if (goal_earlyclobber)\n     for (i = 0; i < noperands; i++)\n       if (goal_alternative_earlyclobber[i])\n-\treload_earlyclobbers[n_earlyclobbers++] = recog_operand[i];\n+\treload_earlyclobbers[n_earlyclobbers++] = recog_data.operand[i];\n \n   /* Now record reloads for all the operands that need them.  */\n   for (i = 0; i < noperands; i++)\n@@ -3637,15 +3652,16 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   so we don't bother with it.  It may not be worth doing.  */\n \telse if (goal_alternative_matched[i] == -1\n \t\t && goal_alternative_offmemok[i]\n-\t\t && GET_CODE (recog_operand[i]) == MEM)\n+\t\t && GET_CODE (recog_data.operand[i]) == MEM)\n \t  {\n \t    operand_reloadnum[i]\n-\t      = push_reload (XEXP (recog_operand[i], 0), NULL_RTX,\n-\t\t\t     &XEXP (recog_operand[i], 0), NULL_PTR,\n-\t\t\t     BASE_REG_CLASS, GET_MODE (XEXP (recog_operand[i], 0)),\n+\t      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,\n+\t\t\t     &XEXP (recog_data.operand[i], 0), NULL_PTR,\n+\t\t\t     BASE_REG_CLASS,\n+\t\t\t     GET_MODE (XEXP (recog_data.operand[i], 0)),\n \t\t\t     VOIDmode, 0, 0, i, RELOAD_FOR_INPUT);\n \t    reload_inc[operand_reloadnum[i]]\n-\t      = GET_MODE_SIZE (GET_MODE (recog_operand[i]));\n+\t      = GET_MODE_SIZE (GET_MODE (recog_data.operand[i]));\n \n \t    /* If this operand is an output, we will have made any\n \t       reloads for its address as RELOAD_FOR_OUTPUT_ADDRESS, but\n@@ -3671,12 +3687,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  {\n \t    operand_reloadnum[i]\n \t      = push_reload ((modified[i] != RELOAD_WRITE\n-\t\t\t      ? recog_operand[i] : 0),\n-\t\t\t     modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n+\t\t\t      ? recog_data.operand[i] : 0),\n+\t\t\t     (modified[i] != RELOAD_READ\n+\t\t\t      ? recog_data.operand[i] : 0),\n \t\t\t     (modified[i] != RELOAD_WRITE\n-\t\t\t      ? recog_operand_loc[i] : 0),\n+\t\t\t      ? recog_data.operand_loc[i] : 0),\n \t\t\t     (modified[i] != RELOAD_READ\n-\t\t\t      ? recog_operand_loc[i] : 0),\n+\t\t\t      ? recog_data.operand_loc[i] : 0),\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     (modified[i] == RELOAD_WRITE\n \t\t\t      ? VOIDmode : operand_mode[i]),\n@@ -3693,10 +3710,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t && modified[goal_alternative_matched[i]] == RELOAD_WRITE)\n \t  {\n \t    operand_reloadnum[i]\n-\t      = push_reload (recog_operand[i],\n-\t\t\t     recog_operand[goal_alternative_matched[i]],\n-\t\t\t     recog_operand_loc[i],\n-\t\t\t     recog_operand_loc[goal_alternative_matched[i]],\n+\t      = push_reload (recog_data.operand[i],\n+\t\t\t     recog_data.operand[goal_alternative_matched[i]],\n+\t\t\t     recog_data.operand_loc[i],\n+\t\t\t     recog_data.operand_loc[goal_alternative_matched[i]],\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n@@ -3707,10 +3724,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t && modified[goal_alternative_matched[i]] == RELOAD_READ)\n \t  {\n \t    operand_reloadnum[goal_alternative_matched[i]]\n-\t      = push_reload (recog_operand[goal_alternative_matched[i]],\n-\t\t\t     recog_operand[i],\n-\t\t\t     recog_operand_loc[goal_alternative_matched[i]],\n-\t\t\t     recog_operand_loc[i],\n+\t      = push_reload (recog_data.operand[goal_alternative_matched[i]],\n+\t\t\t     recog_data.operand[i],\n+\t\t\t     recog_data.operand_loc[goal_alternative_matched[i]],\n+\t\t\t     recog_data.operand_loc[i],\n \t\t\t     (enum reg_class) goal_alternative[i],\n \t\t\t     operand_mode[goal_alternative_matched[i]],\n \t\t\t     operand_mode[i],\n@@ -3736,7 +3753,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t   that didn't get a hard register, make an optional reload.\n \t   This may get done even if the insn needs no reloads otherwise.  */\n \n-\trtx operand = recog_operand[i];\n+\trtx operand = recog_data.operand[i];\n \n \twhile (GET_CODE (operand) == SUBREG)\n \t  operand = XEXP (operand, 0);\n@@ -3759,12 +3776,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    && (modified[i] == RELOAD_READ\n \t\t|| (! no_output_reloads && ! this_insn_is_asm)))\n \t  operand_reloadnum[i]\n-\t    = push_reload (modified[i] != RELOAD_WRITE ? recog_operand[i] : 0,\n-\t\t\t   modified[i] != RELOAD_READ ? recog_operand[i] : 0,\n+\t    = push_reload ((modified[i] != RELOAD_WRITE\n+\t\t\t    ? recog_data.operand[i] : 0),\n+\t\t\t   (modified[i] != RELOAD_READ\n+\t\t\t    ? recog_data.operand[i] : 0),\n \t\t\t   (modified[i] != RELOAD_WRITE\n-\t\t\t    ? recog_operand_loc[i] : 0),\n+\t\t\t    ? recog_data.operand_loc[i] : 0),\n \t\t\t   (modified[i] != RELOAD_READ\n-\t\t\t    ? recog_operand_loc[i] : 0),\n+\t\t\t    ? recog_data.operand_loc[i] : 0),\n \t\t\t   (enum reg_class) goal_alternative[i],\n \t\t\t   (modified[i] == RELOAD_WRITE\n \t\t\t    ? VOIDmode : operand_mode[i]),\n@@ -3784,7 +3803,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t && REGNO (operand) >= FIRST_PSEUDO_REGISTER\n \t\t\t && reg_renumber [REGNO (operand)] < 0)))\n \t  {\n-\t    operand = *recog_operand_loc[i];\n+\t    operand = *recog_data.operand_loc[i];\n \n \t    while (GET_CODE (operand) == SUBREG)\n \t      operand = XEXP (operand, 0);\n@@ -3807,7 +3826,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t/* Similarly, make an optional reload for a pair of matching\n \t   objects that are in MEM or a pseudo that didn't get a hard reg.  */\n \n-\trtx operand = recog_operand[i];\n+\trtx operand = recog_data.operand[i];\n \n \twhile (GET_CODE (operand) == SUBREG)\n \t  operand = XEXP (operand, 0);\n@@ -3817,10 +3836,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t    && ((enum reg_class) goal_alternative[goal_alternative_matches[i]]\n \t\t!= NO_REGS))\n \t  operand_reloadnum[i] = operand_reloadnum[goal_alternative_matches[i]]\n-\t    = push_reload (recog_operand[goal_alternative_matches[i]],\n-\t\t\t   recog_operand[i],\n-\t\t\t   recog_operand_loc[goal_alternative_matches[i]],\n-\t\t\t   recog_operand_loc[i],\n+\t    = push_reload (recog_data.operand[goal_alternative_matches[i]],\n+\t\t\t   recog_data.operand[i],\n+\t\t\t   recog_data.operand_loc[goal_alternative_matches[i]],\n+\t\t\t   recog_data.operand_loc[i],\n \t\t\t   (enum reg_class) goal_alternative[goal_alternative_matches[i]],\n \t\t\t   operand_mode[goal_alternative_matches[i]],\n \t\t\t   operand_mode[i],\n@@ -3842,7 +3861,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t{\n \t  rtx substitution = substed_operand[i];\n \n-\t  *recog_operand_loc[i] = substitution;\n+\t  *recog_data.operand_loc[i] = substitution;\n \n \t  /* If we're replacing an operand with a LABEL_REF, we need\n \t     to make sure that there's a REG_LABEL note attached to\n@@ -3855,7 +3874,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\t\t\t  REG_NOTES (insn));\n \t}\n       else\n-\tretval |= (substed_operand[i] != *recog_operand_loc[i]);\n+\tretval |= (substed_operand[i] != *recog_data.operand_loc[i]);\n     }\n \n   /* If this insn pattern contains any MATCH_DUP's, make sure that\n@@ -3869,10 +3888,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   if (insn_code_number >= 0 && replace)\n     for (i = insn_n_dups[insn_code_number] - 1; i >= 0; i--)\n       {\n-\tint opno = recog_dup_num[i];\n-\t*recog_dup_loc[i] = *recog_operand_loc[opno];\n+\tint opno = recog_data.dup_num[i];\n+\t*recog_data.dup_loc[i] = *recog_data.operand_loc[opno];\n \tif (operand_reloadnum[opno] >= 0)\n-\t  push_replacement (recog_dup_loc[i], operand_reloadnum[opno],\n+\t  push_replacement (recog_data.dup_loc[i], operand_reloadnum[opno],\n \t\t\t    insn_operand_mode[insn_code_number][opno]);\n       }\n \n@@ -4243,47 +4262,48 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n   extract_insn (insn);\n \n-  noperands = reload_n_operands = recog_n_operands;\n+  noperands = reload_n_operands = recog_data.n_operands;\n \n   /* Return if the insn needs no reload processing.  */\n   if (noperands == 0)\n     return;\n \n   for (i = 0; i < noperands; i++)\n     {\n-      register RTX_CODE code = GET_CODE (recog_operand[i]);\n+      register RTX_CODE code = GET_CODE (recog_data.operand[i]);\n       int is_set_dest = GET_CODE (body) == SET && (i == 0);\n \n       if (insn_code_number >= 0)\n \tif (insn_operand_address_p[insn_code_number][i])\n \t  find_reloads_address (VOIDmode, NULL_PTR,\n-\t\t\t\trecog_operand[i], recog_operand_loc[i],\n+\t\t\t\trecog_data.operand[i],\n+\t\t\t\trecog_data.operand_loc[i],\n \t\t\t\ti, RELOAD_FOR_INPUT, ind_levels, insn);\n \n       /* In these cases, we can't tell if the operand is an input\n \t or an output, so be conservative.  In practice it won't be\n \t problem.  */\n \n       if (code == MEM)\n-\tfind_reloads_address (GET_MODE (recog_operand[i]),\n-\t\t\t      recog_operand_loc[i],\n-\t\t\t      XEXP (recog_operand[i], 0),\n-\t\t\t      &XEXP (recog_operand[i], 0),\n+\tfind_reloads_address (GET_MODE (recog_data.operand[i]),\n+\t\t\t      recog_data.operand_loc[i],\n+\t\t\t      XEXP (recog_data.operand[i], 0),\n+\t\t\t      &XEXP (recog_data.operand[i], 0),\n \t\t\t      i, RELOAD_OTHER, ind_levels, insn);\n       if (code == SUBREG)\n-\trecog_operand[i] = *recog_operand_loc[i]\n-\t  = find_reloads_toplev (recog_operand[i], i, RELOAD_OTHER,\n+\trecog_data.operand[i] = *recog_data.operand_loc[i]\n+\t  = find_reloads_toplev (recog_data.operand[i], i, RELOAD_OTHER,\n \t\t\t\t ind_levels, is_set_dest);\n       if (code == REG)\n \t{\n-\t  register int regno = REGNO (recog_operand[i]);\n+\t  register int regno = REGNO (recog_data.operand[i]);\n \t  if (reg_equiv_constant[regno] != 0 && !is_set_dest)\n-\t    recog_operand[i] = *recog_operand_loc[i]\n+\t    recog_data.operand[i] = *recog_data.operand_loc[i]\n \t      = reg_equiv_constant[regno];\n #if 0 /* This might screw code in reload1.c to delete prior output-reload\n \t that feeds this insn.  */\n \t  if (reg_equiv_mem[regno] != 0)\n-\t    recog_operand[i] = *recog_operand_loc[i]\n+\t    recog_data.operand[i] = *recog_data.operand_loc[i]\n \t      = reg_equiv_mem[regno];\n #endif\n \t}\n@@ -4376,7 +4396,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n \t      /* If this is not a toplevel operand, find_reloads doesn't see\n \t\t this substitution.  We have to emit a USE of the pseudo so\n \t\t that delete_output_reload can see it.  */\n-\t      if (replace_reloads && recog_operand[opnum] != x)\n+\t      if (replace_reloads && recog_data.operand[opnum] != x)\n \t\temit_insn_before (gen_rtx_USE (VOIDmode, x), insn);\n \t      x = mem;\n \t      find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n@@ -5677,7 +5697,7 @@ find_reloads_subreg_address (x, force_replace, opnum, type,\n \t      /* If this is not a toplevel operand, find_reloads doesn't see\n \t\t this substitution.  We have to emit a USE of the pseudo so\n \t\t that delete_output_reload can see it.  */\n-\t      if (replace_reloads && recog_operand[opnum] != x)\n+\t      if (replace_reloads && recog_data.operand[opnum] != x)\n \t\temit_insn_before (gen_rtx_USE (VOIDmode, SUBREG_REG (x)), insn);\n \t      x = tem;\n \t    }"}, {"sha": "c8a914af91b865cdffb5fca57021ffcf8ce3c48f", "filename": "gcc/reload1.c", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ccbefcef21836d354e28c07e92fe9a5b5eaedcd/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=1ccbefcef21836d354e28c07e92fe9a5b5eaedcd", "patch": "@@ -1264,7 +1264,7 @@ maybe_fix_stack_asms ()\n \t}\n \n       /* Get the operand values and constraints out of the insn.  */\n-      decode_asm_operands (pat, recog_operand, recog_operand_loc,\n+      decode_asm_operands (pat, recog_data.operand, recog_data.operand_loc,\n \t\t\t   constraints, operand_mode);\n \n       /* For every operand, see what registers are allowed.  */\n@@ -3442,13 +3442,13 @@ eliminate_regs_in_insn (insn, replace)\n \t       && (GET_CODE (new_body) != SET\n \t\t   || GET_CODE (SET_SRC (new_body)) != REG))\n \t      /* If this was a load from or store to memory, compare\n-\t\t the MEM in recog_operand to the one in the insn.  If they\n-\t\t are not equal, then rerecognize the insn.  */\n+\t\t the MEM in recog_data.operand to the one in the insn.\n+\t\t If they are not equal, then rerecognize the insn.  */\n \t      || (old_set != 0\n \t\t  && ((GET_CODE (SET_SRC (old_set)) == MEM\n-\t\t       && SET_SRC (old_set) != recog_operand[1])\n+\t\t       && SET_SRC (old_set) != recog_data.operand[1])\n \t\t      || (GET_CODE (SET_DEST (old_set)) == MEM\n-\t\t\t  && SET_DEST (old_set) != recog_operand[0])))\n+\t\t\t  && SET_DEST (old_set) != recog_data.operand[0])))\n \t      /* If this was an add insn before, rerecognize.  */\n \t      || GET_CODE (SET_SRC (old_set)) == PLUS))\n \t{\n@@ -9155,31 +9155,31 @@ reload_cse_simplify_operands (insn)\n \n   extract_insn (insn);\n \n-  if (recog_n_alternatives == 0 || recog_n_operands == 0)\n+  if (recog_data.n_alternatives == 0 || recog_data.n_operands == 0)\n     return 0;\n \n   /* Figure out which alternative currently matches.  */\n   if (! constrain_operands (1))\n     fatal_insn_not_found (insn);\n \n-  alternative_reject = (int *) alloca (recog_n_alternatives * sizeof (int));\n-  alternative_nregs = (int *) alloca (recog_n_alternatives * sizeof (int));\n-  alternative_order = (int *) alloca (recog_n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_reject, recog_n_alternatives * sizeof (int));\n-  bzero ((char *)alternative_nregs, recog_n_alternatives * sizeof (int));\n+  alternative_reject = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_nregs = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  alternative_order = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+  bzero ((char *)alternative_reject, recog_data.n_alternatives * sizeof (int));\n+  bzero ((char *)alternative_nregs, recog_data.n_alternatives * sizeof (int));\n \n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n       enum machine_mode mode;\n       int regno;\n       const char *p;\n \n-      op_alt_regno[i] = (int *) alloca (recog_n_alternatives * sizeof (int));\n-      for (j = 0; j < recog_n_alternatives; j++)\n+      op_alt_regno[i] = (int *) alloca (recog_data.n_alternatives * sizeof (int));\n+      for (j = 0; j < recog_data.n_alternatives; j++)\n \top_alt_regno[i][j] = -1;\n \n-      p = constraints[i] = recog_constraints[i];\n-      mode = recog_operand_mode[i];\n+      p = constraints[i] = recog_data.constraints[i];\n+      mode = recog_data.operand_mode[i];\n \n       /* Add the reject values for each alternative given by the constraints\n \t for this operand.  */\n@@ -9197,7 +9197,7 @@ reload_cse_simplify_operands (insn)\n \n       /* We won't change operands which are already registers.  We\n \t also don't want to modify output operands.  */\n-      regno = true_regnum (recog_operand[i]);\n+      regno = true_regnum (recog_data.operand[i]);\n       if (regno >= 0\n \t  || constraints[i][0] == '='\n \t  || constraints[i][0] == '+')\n@@ -9207,7 +9207,7 @@ reload_cse_simplify_operands (insn)\n \t{\n \t  int class = (int) NO_REGS;\n \n-\t  if (! reload_cse_regno_equal_p (regno, recog_operand[i], mode))\n+\t  if (! reload_cse_regno_equal_p (regno, recog_data.operand[i], mode))\n \t    continue;\n \n \t  REGNO (reg) = regno;\n@@ -9257,8 +9257,9 @@ reload_cse_simplify_operands (insn)\n \t\t     a cheap CONST_INT. */\n \t\t  if (op_alt_regno[i][j] == -1\n \t\t      && reg_fits_class_p (reg, class, 0, mode)\n-\t\t      && (GET_CODE (recog_operand[i]) != CONST_INT\n-\t\t\t  || rtx_cost (recog_operand[i], SET) > rtx_cost (reg, SET)))\n+\t\t      && (GET_CODE (recog_data.operand[i]) != CONST_INT\n+\t\t\t  || (rtx_cost (recog_data.operand[i], SET)\n+\t\t\t      > rtx_cost (reg, SET))))\n \t\t    {\n \t\t      alternative_nregs[j]++;\n \t\t      op_alt_regno[i][j] = regno;\n@@ -9275,21 +9276,21 @@ reload_cse_simplify_operands (insn)\n \n   /* Record all alternatives which are better or equal to the currently\n      matching one in the alternative_order array.  */\n-  for (i = j = 0; i < recog_n_alternatives; i++)\n+  for (i = j = 0; i < recog_data.n_alternatives; i++)\n     if (alternative_reject[i] <= alternative_reject[which_alternative])\n       alternative_order[j++] = i;\n-  recog_n_alternatives = j;\n+  recog_data.n_alternatives = j;\n \n   /* Sort it.  Given a small number of alternatives, a dumb algorithm\n      won't hurt too much.  */\n-  for (i = 0; i < recog_n_alternatives - 1; i++)\n+  for (i = 0; i < recog_data.n_alternatives - 1; i++)\n     {\n       int best = i;\n       int best_reject = alternative_reject[alternative_order[i]];\n       int best_nregs = alternative_nregs[alternative_order[i]];\n       int tmp;\n \n-      for (j = i + 1; j < recog_n_alternatives; j++)\n+      for (j = i + 1; j < recog_data.n_alternatives; j++)\n \t{\n \t  int this_reject = alternative_reject[alternative_order[j]];\n \t  int this_nregs = alternative_nregs[alternative_order[j]];\n@@ -9315,25 +9316,25 @@ reload_cse_simplify_operands (insn)\n   /* Pop back to the real obstacks while changing the insn.  */\n   pop_obstacks ();\n \n-  for (i = 0; i < recog_n_operands; i++)\n+  for (i = 0; i < recog_data.n_operands; i++)\n     {\n-      enum machine_mode mode = recog_operand_mode[i];\n+      enum machine_mode mode = recog_data.operand_mode[i];\n       if (op_alt_regno[i][j] == -1)\n \tcontinue;\n \n-      validate_change (insn, recog_operand_loc[i],\n+      validate_change (insn, recog_data.operand_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[i][j]), 1);\n     }\n \n-  for (i = recog_n_dups - 1; i >= 0; i--)\n+  for (i = recog_data.n_dups - 1; i >= 0; i--)\n     {\n-      int op = recog_dup_num[i];\n-      enum machine_mode mode = recog_operand_mode[op];\n+      int op = recog_data.dup_num[i];\n+      enum machine_mode mode = recog_data.operand_mode[op];\n \n       if (op_alt_regno[op][j] == -1)\n \tcontinue;\n \n-      validate_change (insn, recog_dup_loc[i],\n+      validate_change (insn, recog_data.dup_loc[i],\n \t\t       gen_rtx_REG (mode, op_alt_regno[op][j]), 1);\n     }\n "}]}