{"sha": "dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGM3YjFkZGE2MGJhOGM4YWEwM2RhMjZmNTU1NWQwNzA3NGNkY2UzZg==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2002-07-12T12:52:44Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2002-07-12T12:52:44Z"}, "message": "natThrowable.cc (printRawStackTrace): removed.\n\n\t* java/lang/natThrowable.cc (printRawStackTrace): removed.\n\t(getStackTrace0): new method.\n\t* java/lang/Throwable.java (CPlusPlusDemangler): removed.\n\t(printStackTrace(PrintWriter)): replace with pure java implementation.\n\t(printRawStackTrace): removed.\n\t(getStackTrace0): new method.\n\t* java/lang/StackTraceElement.java (toString): add extra whitespace.\n\t* gcj/javaprims.h: regenerate class list.\n\t* include/name-finder.h (lookup): new returns StackTraceElement*.\n\t(method_name, file_name): fields removed.\n\t(pid2, f2_pipe, b2_pipe, b2_pipe_fd): new fields.\n\t(~_Jv_name_finder): close new descriptors.\n\t* name-finder.cc(_Jv_name_finder): setup c++filt helper process.\n\t(createStackTraceElement): new method.\n\t(lookup): returns StackTraceElement*, uses createStackTraceElement().\n\nFrom-SVN: r55424", "tree": {"sha": "fd16f76f98f4b5e364614153e8902a370d5f36e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd16f76f98f4b5e364614153e8902a370d5f36e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/comments", "author": null, "committer": null, "parents": [{"sha": "26af4041b70d3722d36c4e0d95640bd4f7f9b691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26af4041b70d3722d36c4e0d95640bd4f7f9b691", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26af4041b70d3722d36c4e0d95640bd4f7f9b691"}], "stats": {"total": 500, "additions": 339, "deletions": 161}, "files": [{"sha": "204836c3aa3ccb4da4fce9761e141c943b2cbf68", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -1,3 +1,21 @@\n+2002-07-12  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/lang/natThrowable.cc (printRawStackTrace): removed.\n+\t(getStackTrace0): new method.\n+\t* java/lang/Throwable.java (CPlusPlusDemangler): removed.\n+\t(printStackTrace(PrintWriter)): replace with pure java implementation.\n+\t(printRawStackTrace): removed.\n+\t(getStackTrace0): new method.\n+\t* java/lang/StackTraceElement.java (toString): add extra whitespace.\n+\t* gcj/javaprims.h: regenerate class list.\n+\t* include/name-finder.h (lookup): new returns StackTraceElement*.\n+\t(method_name, file_name): fields removed.\n+\t(pid2, f2_pipe, b2_pipe, b2_pipe_fd): new fields.\n+\t(~_Jv_name_finder): close new descriptors.\n+\t* name-finder.cc(_Jv_name_finder): setup c++filt helper process.\n+\t(createStackTraceElement): new method.\n+\t(lookup): returns StackTraceElement*, uses createStackTraceElement().\n+\n 2002-07-10  Tom Tromey  <tromey@redhat.com>\n \n \t* configure: Rebuilt."}, {"sha": "99442c5ca2ae009326963732b4f87e3b741b37d8", "filename": "libjava/gcj/javaprims.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fgcj%2Fjavaprims.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fgcj%2Fjavaprims.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgcj%2Fjavaprims.h?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -134,7 +134,6 @@ extern \"Java\"\n       class AssertionError;\n       class Boolean;\n       class Byte;\n-      class CPlusPlusDemangler;\n       class CharSequence;\n       class Character;\n       class Character$Subset;"}, {"sha": "67ae0587fb017b0f48e422a7281a6d0fc0099347", "filename": "libjava/include/name-finder.h", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Finclude%2Fname-finder.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Finclude%2Fname-finder.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fname-finder.h?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -29,6 +29,8 @@ details.  */\n #include <unistd.h>\n #endif\n \n+#include <java/lang/StackTraceElement.h>\n+\n /* _Jv_name_finder is a class wrapper around a mechanism that can\n    convert addresses of methods to their names and the names of files\n    in which they appear. */\n@@ -47,38 +49,48 @@ class _Jv_name_finder\n       if (b_pipe_fd != NULL)\n \tfclose (b_pipe_fd);\n \n+      myclose (f2_pipe[0]);\n+      myclose (f2_pipe[1]);\n+      myclose (b2_pipe[0]);\n+      myclose (b2_pipe[1]);\n+      if (b2_pipe_fd != NULL)\n+\tfclose (b2_pipe_fd);\n+\n       if (pid >= 0)\n \t{\n \t  int wstat;\n \t  // We don't care about errors here.\n \t  waitpid (pid, &wstat, 0);\n \t}\n+\n+      if (pid2 >= 0)\n+\t{\n+\t  int wstat;\n+\t  // We don't care about errors here.\n+\t  waitpid (pid2, &wstat, 0);\n+\t}\n #endif\n     }\n \n /* Given a pointer to a function or method, try to convert it into a\n    name and the appropriate line and source file.  The caller passes\n    the code pointer in p.\n \n-   Returns false if the lookup fails.  Even if this happens, the field\n-   hex will have been correctly filled in with the pointer. \n+   Returns NULL if the lookup fails.  Even if this happens, the field\n+   hex will have been correctly filled in with the pointer. */\n \n-   The other fields are method_name and file_name, which lookup will\n-   attempt to fill appropriately.  If the lookup has failed, these\n-   fields contain garbage.*/\n-  bool lookup (void *p);\n+  java::lang::StackTraceElement* lookup (void *p);\n \n-  char method_name[1024];\n-  char file_name[1024];\n   char hex[sizeof (void *) * 2 + 5];\n \n private:\n   void toHex (void *p);\n+  java::lang::StackTraceElement* createStackTraceElement(char *s, char *f);\n #if defined (HAVE_PIPE) && defined (HAVE_FORK)\n-  pid_t pid;\n-  int f_pipe[2], b_pipe[2];\n-  FILE *b_pipe_fd;\n-  int error;\n+  pid_t pid, pid2;\n+  int f_pipe[2], b_pipe[2], f2_pipe[2], b2_pipe[2];\n+  FILE *b_pipe_fd, *b2_pipe_fd;\n+  int demangling_error, lookup_error;\n \n   // Close a descriptor only if it has not been closed.\n   void myclose (int fd)"}, {"sha": "d9e8a31b72483778df90dde4398c7339d0685f06", "filename": "libjava/java/lang/StackTraceElement.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FStackTraceElement.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FStackTraceElement.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FStackTraceElement.java?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -191,7 +191,7 @@ public String toString()\n       }\n     if (methodName != null)\n       sb.append(methodName);\n-    sb.append('(');\n+    sb.append(\" (\");\n     if (fileName != null)\n       sb.append(fileName);\n     else"}, {"sha": "56c9d542a500e014cc761693b8aa7263f4f32ff1", "filename": "libjava/java/lang/Throwable.java", "status": "modified", "additions": 94, "deletions": 86, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FThrowable.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FThrowable.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThrowable.java?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -57,76 +57,6 @@\n  * bytecode not implemented.  JDK 1.1.\n  */\n \n-/* A CPlusPlusDemangler sits on top of a PrintWriter.  All input is\n- * passed through the \"c++filt\" program (part of GNU binutils) which\n- * demangles internal symbols to their C++ source form.\n- *\n- * Closing a CPlusPlusDemangler doesn't close the underlying\n- * PrintWriter; it does, however close underlying process and flush\n- * all its buffers, so it's possible to guarantee that after a\n- * CPlusPlusDemangler has been closed no more will ever be written to\n- * the underlying PrintWriter.\n- *\n- * FIXME: This implictly converts data from the input stream, which is\n- * a stream of characters, to a stream of bytes.  We need a way of\n- * handling Unicode characters in demangled identifiers.  */\n-\n-class CPlusPlusDemangler extends OutputStream\n-{\n-  java.io.OutputStream procOut;\n-  java.io.InputStream procIn;\n-  java.lang.Process proc;\n-  PrintWriter p;\n-\n-  /* The number of bytes written to the underlying PrintWriter.  This\n-     provides a crude but fairly portable way to determine whether or\n-     not the attempt to exec c++filt worked. */  \n-  public int written = 0;\n-\n-  CPlusPlusDemangler (PrintWriter writer) throws IOException\n-  {\n-    p = writer;\n-    proc = Runtime.getRuntime ().exec (\"c++filt -s java\");\n-    procOut = proc.getOutputStream ();\n-    procIn = proc.getInputStream ();\n-  }\n-\n-  public void write (int b) throws IOException\n-  {\n-    procOut.write (b);\n-    while (procIn.available () != 0)\n-      {\n-\tint c = procIn.read ();\n-\tif (c == -1)\n-\t  break;\n-\telse\n-\t  {\n-\t    p.write (c);\n-\t    written++;\n-\t  }\n-      }\n-  }\n-  \n-  public void close () throws IOException\n-  {\n-    procOut.close ();\n-    int c;\n-    while ((c = procIn.read ()) != -1)\n-      {\n-\tp.write (c);\n-\twritten++;\n-      }\n-    p.flush ();\n-    try\n-      {\n-\tproc.waitFor ();\n-      }\n-    catch (InterruptedException _)\n-      {\n-      }\n-  }    \n-}\n-\n /**\n  * Throwable is the superclass of all exceptions that can be raised.\n  *\n@@ -219,8 +149,7 @@ public class Throwable implements Serializable\n    *         no null entries\n    * @since 1.4\n    */\n-  // XXX Don't initialize this, once fillInStackTrace() does it.\n-  private StackTraceElement[] stackTrace = {};\n+  private StackTraceElement[] stackTrace;\n \n   /**\n    * Instantiate this Throwable with an empty message. The cause remains\n@@ -449,26 +378,102 @@ public void printStackTrace(PrintStream s)\n   }\n \n   /**\n-   * Print a stack trace to the specified PrintWriter. See\n-   * {@link #printStackTrace()} for the sample format.\n+   * <p>Prints the exception, the detailed message and the stack trace\n+   * associated with this Throwable to the given <code>PrintWriter</code>.\n+   * The actual output written is implemention specific. Use the result of\n+   * <code>getStackTrace()</code> when more precise information is needed.\n+   *\n+   * <p>This implementation first prints a line with the result of this\n+   * object's <code>toString()</code> method.\n+   * <br>\n+   * Then for all elements given by <code>getStackTrace</code> it prints\n+   * a line containing three spaces, the string \"at \" and the result of calling\n+   * the <code>toString()</code> method on the <code>StackTraceElement</code>\n+   * object. If <code>getStackTrace()</code> returns an empty array it prints\n+   * a line containing three spaces and the string\n+   * \"&lt;&lt;No stacktrace available&gt;&gt;\".\n+   * <br>\n+   * Then if <code>getCause()</code> doesn't return null it adds a line\n+   * starting with \"Caused by: \" and the result of calling\n+   * <code>toString()</code> on the cause.\n+   * <br>\n+   * Then for every cause (of a cause, etc) the stacktrace is printed the\n+   * same as for the top level <code>Throwable</code> except that as soon\n+   * as all the remaining stack frames of the cause are the same as the\n+   * the last stack frames of the throwable that the cause is wrapped in\n+   * then a line starting with three spaces and the string \"... X more\" is\n+   * printed, where X is the number of remaining stackframes.\n    *\n    * @param w the PrintWriter to write the trace to\n    * @since 1.1\n    */\n-  public void printStackTrace (PrintWriter wr)\n+  public void printStackTrace (PrintWriter pw)\n   {\n-    try\n+    // First line\n+    pw.println(toString());\n+\n+    // The stacktrace\n+    StackTraceElement[] stack = getStackTrace();\n+    if (stack == null || stack.length == 0)\n       {\n-\tCPlusPlusDemangler cPlusPlusFilter = new CPlusPlusDemangler (wr);\n-\tPrintWriter writer = new PrintWriter (cPlusPlusFilter);\n-\tprintRawStackTrace (writer);\n-\twriter.close ();\n-\tif (cPlusPlusFilter.written == 0) // The demangler has failed...\n-\t  printRawStackTrace (wr);\n+\tpw.println(\"   <<No stacktrace available>>\");\n+\treturn;\n       }\n-    catch (Exception e1)\n+    else\n+      {\n+\tfor (int i = 0; i < stack.length; i++)\n+\t  pw.println(\"   at \" + stack[i]);\n+      }\n+\n+    // The cause(s)\n+    Throwable cause = getCause();\n+    while (cause != null)\n       {\n-\tprintRawStackTrace (wr);\n+        // Cause first line\n+        pw.println(\"Caused by: \" + cause);\n+\n+        // Cause stacktrace\n+        StackTraceElement[] parentStack = stack;\n+        stack = cause.getStackTrace();\n+\tif (stack == null || stack.length == 0)\n+\t  {\n+\t    pw.println(\"   <<No stacktrace available>>\");\n+\t  }\n+\telse if (parentStack == null || parentStack.length == 0)\n+\t  {\n+\t    for (int i = 0; i < stack.length; i++)\n+\t      pw.println(\"   at \" + stack[i]);\n+\t  }\n+\telse\n+\t  {\n+\t    boolean equal = false; // Is rest of stack equal to parent frame?\n+\t    for (int i = 0; i < stack.length && ! equal; i++)\n+\t      {\n+\t\t// Check if we already printed the rest of the stack\n+\t\t// since it was the tail of the parent stack\n+\t\tint remaining = stack.length - i;\n+\t\tint element = i;\n+\t\tint parentElement = parentStack.length - remaining;\n+\t\tequal = parentElement >= 0\n+\t\t      && parentElement < parentStack.length; // be optimistic\n+\t\twhile (equal && element < stack.length)\n+\t\t  {\n+\t\t    if (stack[element].equals(parentStack[parentElement]))\n+\t\t      {\n+\t\t\telement++;\n+\t\t\tparentElement++;\n+\t\t      }\n+\t\t    else\n+\t\t      equal = false;\n+\t\t  }\n+\t\t// Print stacktrace element or indicate the rest is equal \n+\t\tif (! equal)\n+\t\t  pw.println(\"   at \" + stack[i]);\n+\t\telse\n+\t\t  pw.println(\"   ...\" + remaining + \" more\");\n+\t      }\n+\t  }\n+        cause = cause.getCause();\n       }\n   }\n \n@@ -493,6 +498,9 @@ public void printStackTrace (PrintWriter wr)\n    */\n   public StackTraceElement[] getStackTrace()\n   {\n+    if (stackTrace == null)\n+      stackTrace = getStackTrace0();\n+\n     return stackTrace;\n   }\n \n@@ -513,8 +521,8 @@ public void setStackTrace(StackTraceElement[] stackTrace)\n     this.stackTrace = stackTrace;\n   }\n \n-  private native final void printRawStackTrace (PrintWriter wr);\n-  \n+  private native final StackTraceElement[] getStackTrace0 ();\n+\n   // Setting this flag to false prevents fillInStackTrace() from running.\n   static boolean trace_enabled = true;\n   private transient byte stackTraceBytes[];"}, {"sha": "c2f7d1b8d8dc3d02371415270b3edbe72cf3d61e", "filename": "libjava/java/lang/natThrowable.cc", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FnatThrowable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fjava%2Flang%2FnatThrowable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThrowable.cc?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -22,6 +22,7 @@ details.  */\n #include <java/lang/Object.h>\n #include <java-threads.h>\n #include <java/lang/Throwable.h>\n+#include <java/lang/StackTraceElement.h>\n #include <java/io/PrintStream.h>\n #include <java/io/PrintWriter.h>\n #include <java/io/IOException.h>\n@@ -67,38 +68,32 @@ java::lang::Throwable::fillInStackTrace (void)\n   return this;\n }\n \n-void \n-java::lang::Throwable::printRawStackTrace (java::io::PrintWriter *wr)\n+JArray<java::lang::StackTraceElement*> *\n+java::lang::Throwable::getStackTrace0 ()\n {\n-  wr->println (toString ());\n #ifdef HAVE_BACKTRACE\n   if (!stackTraceBytes)\n-    return;\n+    return NULL;\n \n   int depth = stackTraceBytes->length / sizeof (void *);\n   void *p[depth];\n+  // This memcpy is esential; it ensures that the array of void* is\n+  // correctly aligned.\n   memcpy (p, elements (stackTraceBytes), sizeof p);\n \n+  JArray<java::lang::StackTraceElement*> *result;\n+  java::lang::StackTraceElement** el;\n+  result = reinterpret_cast <JArray<java::lang::StackTraceElement *>*>\n+    (JvNewObjectArray (depth, &java::lang::StackTraceElement::class$, NULL));\n+  el = elements (result);\n+\n   _Jv_name_finder finder (_Jv_ThisExecutable ());\n \n   for (int i = 0; i < depth; i++)\n-    {\n-      bool found = finder.lookup (p[i]);\n-      wr->print (JvNewStringLatin1 (\"   at \"));\n-      wr->print (JvNewStringLatin1 (finder.hex));\n-      if (found)\n-\t{\n-\t  wr->print (JvNewStringLatin1 (\": \"));\n-\t  wr->print (JvNewStringLatin1 (finder.method_name));\n-\t  if (finder.file_name[0])\n-\t    {\n-\t      wr->print (JvNewStringLatin1 (\" (\"));\n-\t      wr->print (JvNewStringLatin1 (finder.file_name));\n-\t      wr->print (JvNewStringLatin1 (\")\"));\n-\t    }\n-\t}\n-      wr->println ();\n-    }\n+    el[i] = finder.lookup (p[i]);\n+\n+  return result;\n+#else\n+  return NULL;\n #endif /* HAVE_BACKTRACE */\n-  wr->flush ();\n }"}, {"sha": "2d383aaa2508f5c1e5c928910e21fedd0ad5c290", "filename": "libjava/name-finder.cc", "status": "modified", "additions": 185, "deletions": 39, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fname-finder.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc7b1dda60ba8c8aa03da26f5555d07074cdce3f/libjava%2Fname-finder.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fname-finder.cc?ref=dc7b1dda60ba8c8aa03da26f5555d07074cdce3f", "patch": "@@ -59,7 +59,7 @@ details.  */\n _Jv_name_finder::_Jv_name_finder (char *executable)\n {\n #if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n-  error = 0;\n+  demangling_error = lookup_error = 0;\n \n   // Initialize file descriptors so that shutdown works properly.\n   f_pipe[0] = -1;\n@@ -68,25 +68,32 @@ _Jv_name_finder::_Jv_name_finder (char *executable)\n   b_pipe[1] = -1;\n   b_pipe_fd = NULL;\n \n-  char *argv[6];\n+  f2_pipe[0] = -1;\n+  f2_pipe[1] = -1;\n+  b2_pipe[0] = -1;\n+  b2_pipe[1] = -1;\n+  b2_pipe_fd = NULL;\n+\n+  // addr2line helper process.\n+\n+  char *argv[5];\n   {\n     int arg = 0;\n #ifdef __ia64__\n     argv[arg++] = \"addr2name.awk\";\n #else\n     argv[arg++] = \"addr2line\";\n-    argv[arg++] = \"-C\";\n     argv[arg++] = \"-f\";\n     argv[arg++] = \"-e\";\n #endif\n     argv[arg++] = executable;\n     argv[arg] = NULL;\n   }\n \n-  error |= pipe (f_pipe) < 0;\n-  error |= pipe (b_pipe) < 0;\n+  lookup_error |= pipe (f_pipe) < 0;\n+  lookup_error |= pipe (b_pipe) < 0;\n \n-  if (error)\n+  if (lookup_error)\n     return;\n \n   pid = fork ();\n@@ -109,18 +116,65 @@ _Jv_name_finder::_Jv_name_finder (char *executable)\n \n   if (pid < 0)\n     {\n-      error |= 1; \n+      lookup_error |= 1; \n       return;\n     }\n \n   b_pipe_fd = fdopen (b_pipe[0], \"r\");\n-  error |= !b_pipe_fd;\n+  lookup_error |= !b_pipe_fd;\n \n-  if (! error)\n+  if (! lookup_error)\n     {\n       // Don't try to close the fd twice.\n       b_pipe[0] = -1;\n     }\n+\n+  // c++filt helper process.\n+  \n+  char *argv2[4];\n+  argv2[0] = \"c++filt\";\n+  argv2[1] = \"-s\";\n+  argv2[2] = \"java\";\n+  argv2[3] = NULL;\n+\n+  demangling_error |= pipe (f2_pipe) < 0;\n+  demangling_error |= pipe (b2_pipe) < 0;\n+\n+  if (demangling_error)\n+    return;\n+\n+  pid2 = fork ();\n+  if (pid2 == 0)\n+    {\n+      close (f2_pipe[1]);\n+      close (b2_pipe[0]);\n+      dup2 (f2_pipe[0], fileno (stdin));\n+      dup2 (b2_pipe[1], fileno (stdout));\n+      execvp (argv2[0], argv2);\n+      _exit (127);\n+    }\n+\n+  // Close child end of pipes.  Set local descriptors to -1 so we\n+  // don't try to close the fd again.\n+  close (f2_pipe [0]);\n+  f2_pipe[0] = -1;\n+  close (b2_pipe [1]);\n+  b2_pipe[1] = -1;\n+\n+  if (pid2 < 0)\n+    {\n+      demangling_error |= 1; \n+      return;\n+    }\n+\n+  b2_pipe_fd = fdopen (b2_pipe[0], \"r\");\n+  demangling_error |= !b2_pipe_fd;\n+\n+  if (! demangling_error)\n+    {\n+      // Don't try to close the fd twice.\n+      b2_pipe[0] = -1;\n+    }\n #endif\n }\n \n@@ -144,19 +198,112 @@ _Jv_name_finder::toHex (void *p)\n   hex [digits+2] = 0;\n }   \n \n+/* Creates a StackTraceElement given a string and a filename.\n+   Splits the given string into the class and method part.\n+   The string s will be a demangled to a fully qualified java method string.\n+   The string f will be decomposed into a file name and a possible line number.\n+   The given strings will be altered.  */\n+\n+java::lang::StackTraceElement*\n+_Jv_name_finder::createStackTraceElement(char *s, char *f)\n+{\n+  char *c;\n+  char *class_name = NULL;\n+  char *method_name = NULL;\n+\n+#if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n+  if (demangling_error)\n+    goto fail;\n+\n+  demangling_error |= write (f2_pipe[1], s, strlen (s)) < 0;\n+  if (demangling_error)\n+    goto fail;\n+  demangling_error |= write (f2_pipe[1], \"\\n\", 1) < 0;\n+  if (demangling_error)\n+    goto fail;\n+\n+  char name[1024];\n+  demangling_error |= (fgets (name, sizeof name, b2_pipe_fd) == NULL);\n+  if (demangling_error)\n+    goto fail;\n+\n+  c = strchr (name, '\\n');\n+  if (c)\n+    *c = 0;\n+  s = name;\n+#endif\n+\n+  c = strchr (s, '(');\n+  if (c)\n+    {\n+      while(c-->s)\n+\tif (*c == '.')\n+\t  break;\n+\n+      if (*c == '.')\n+\t{\n+\t  *c = 0;\n+\t  class_name = s;\n+\t  method_name = c+1;\n+\t}\n+      else\n+\t{\n+\t  class_name = NULL;\n+\t  method_name = s;\n+\t}\n+    }\n+  else\n+    {\n+      class_name = NULL;\n+      method_name = s;\n+    }\n+\n+  // Get line number\n+  int line_number;\n+  c = strrchr (f, ':');\n+  if (c)\n+    {\n+      if (c[1] != 0)\n+\tline_number = atoi(c+1);\n+      else\n+\tline_number = -1;\n+      *c = 0;\n+    }\n+  else\n+    {\n+      line_number = -1;\n+      c = strchr (f, '\\n');\n+      if (c)\n+\t*c = 0;\n+    }\n+\n+ fail:\n+  return new java::lang::StackTraceElement(\n+\t\t  f ? JvNewStringLatin1 (f) : NULL,\n+\t\t  line_number,\n+\t\t  class_name ? JvNewStringLatin1 (class_name) : NULL,\n+\t\t  JvNewStringLatin1 (method_name ? method_name : s),\n+\t\t  false);\n+}\n+\n /* Given a pointer to a function or method, try to convert it into a\n    name and the appropriate line and source file.  The caller passes\n    the code pointer in p.\n \n    Returns false if the lookup fails.  Even if this happens, the field\n    he will have been correctly filled in with the pointer.  */\n \n-bool\n+java::lang::StackTraceElement*\n _Jv_name_finder::lookup (void *p)\n {\n   extern char **_Jv_argv;\n   toHex (p);\n       \n+  char name[1024];\n+  char file_name[1024];\n+\n+  file_name[0] = 0;\n+\n #if defined (HAVE_DLFCN_H) && defined (HAVE_DLADDR)\n   {\n     Dl_info dl_info;\n@@ -166,45 +313,44 @@ _Jv_name_finder::lookup (void *p)\n         if (dl_info.dli_fname)\n \t  strncpy (file_name, dl_info.dli_fname, sizeof file_name);\n \tif (dl_info.dli_sname)\n-\t  strncpy (method_name, dl_info.dli_sname, sizeof method_name);\n+\t  strncpy (name, dl_info.dli_sname, sizeof name);\n        \n        /* Don't trust dladdr() if the address is from the main program. */\n        if (dl_info.dli_fname != NULL\n            && dl_info.dli_sname != NULL\n \t   && (_Jv_argv == NULL || strcmp (file_name, _Jv_argv[0]) != 0))\n-         return true;\n+         return createStackTraceElement (name, file_name);\n       }\n   }\n #endif\n \n+  memcpy (name, hex, strlen (hex) + 1);\n+\n #if defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP)\n-  if (error)\n-    return false;\n-\n-  error |= write (f_pipe[1], hex, strlen (hex)) < 0;\n-  if (error)\n-    return false;\n-  error |= write (f_pipe[1], \"\\n\", 1) < 0;\n-  if (error)\n-    return false;\n-\n-  error |= (fgets (method_name, sizeof method_name, b_pipe_fd) == NULL);\n-  if (error)\n-    return false;\n-  error |= (fgets (file_name, sizeof file_name, b_pipe_fd) == NULL);\n-  if (error)\n-    return false;\n-\n-  char *newline = strchr (method_name, '\\n');\n-  if (newline)\n-    *newline = 0;\n-  newline = strchr (file_name, '\\n');\n-  if (newline)\n-    *newline = 0;\n-\n-  return true;\n+  if (lookup_error)\n+    goto fail;\n+\n+  lookup_error |= write (f_pipe[1], hex, strlen (hex)) < 0;\n+  if (lookup_error)\n+    goto fail;\n+  lookup_error |= write (f_pipe[1], \"\\n\", 1) < 0;\n+  if (lookup_error)\n+    goto fail;\n+\n+  lookup_error |= (fgets (name, sizeof name, b_pipe_fd) == NULL);\n+  if (lookup_error)\n+    goto fail;\n+  lookup_error |= (fgets (file_name, sizeof file_name, b_pipe_fd) == NULL);\n+  if (lookup_error)\n+    goto fail;\n \n-#else\n-  return false;\n+  {\n+    char *newline = strchr (name, '\\n');\n+    if (newline)\n+      *newline = 0;\n+  }\n #endif /* defined (HAVE_PIPE) && defined (HAVE_FORK) && defined (HAVE_EXECVP) */\n+\n+ fail:\n+  return (createStackTraceElement (name, file_name));\n }"}]}