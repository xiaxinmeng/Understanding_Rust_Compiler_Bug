{"sha": "ba326d364d03223720932db63da569371603ef92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEzMjZkMzY0ZDAzMjIzNzIwOTMyZGI2M2RhNTY5MzcxNjAzZWY5Mg==", "commit": {"author": {"name": "Mike Stump", "email": "mikestump@comcast.net", "date": "2011-02-13T07:52:52Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "2011-02-13T07:52:52Z"}, "message": "t-darwin (build/slashify): Allow others to reuse easier.\n\ngcc:\n\t* config/t-darwin (build/slashify): Allow others to reuse easier.\n\nobjcp:\n\t* Make-lang.in (obj-c++.tags): Plugify Objective-C++.\n\t* plugin/parser.h: Likewise.\n\t* plugin/parser.c: Likewise.\n\ncp:\n\t* Make-lang.in (build/slashify): Plugify Objective-C++.\n\t(cp/parser.o): Likewise.\n\t(objcp/plugin/parser.h): Likewise.\n\nFrom-SVN: r170101", "tree": {"sha": "1fb08d86d6092f2c0472878f4dd46621fed436d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fb08d86d6092f2c0472878f4dd46621fed436d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba326d364d03223720932db63da569371603ef92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba326d364d03223720932db63da569371603ef92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba326d364d03223720932db63da569371603ef92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba326d364d03223720932db63da569371603ef92/comments", "author": null, "committer": null, "parents": [{"sha": "8efc91cde4e098f3c23fede96ad1561ea90f5500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8efc91cde4e098f3c23fede96ad1561ea90f5500", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8efc91cde4e098f3c23fede96ad1561ea90f5500"}], "stats": {"total": 4202, "additions": 2179, "deletions": 2023}, "files": [{"sha": "19dc3adbeb072e69a472099d1f180dbcb6786aec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -1,3 +1,7 @@\n+2011-02-12  Mike Stump  <mikestump@comcast.net>\n+\n+\t* config/t-darwin (build/slashify): Allow others to reuse easier.\n+\n 2011-02-12  Mike Stump  <mikestump@comcast.net>\n \n \t* config/darwin.h: Make pretty."}, {"sha": "202823b01d432850817bac11b9e783c136e53223", "filename": "gcc/config/t-darwin", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fconfig%2Ft-darwin", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fconfig%2Ft-darwin", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ft-darwin?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -17,8 +17,8 @@\n # along with GCC; see the file COPYING3.  If not see\n # <http://www.gnu.org/licenses/>.\n \n-build/slashify: $(srcdir)/config/slashify.c\n-\t$(COMPILER_FOR_BUILD) $< -o $@\n+build/slashify:: $(srcdir)/config/slashify.c\n+\t$(COMPILER_FOR_BUILD) $(srcdir)/config/slashify.c -o $@\n \n $(srcdir)/config/darwin.h: config/darwin.h.rebuild\n "}, {"sha": "ac18f21d9f991cf57eaa47191579f4fec377a26c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -1,3 +1,10 @@\n+2011-02-12  Mike Stump  <mikestump@comcast.net>\n+\n+\t* Make-lang.in (build/slashify): Plugify Objective-C++.\n+\t(cp/parser.o): Likewise.\n+\t(objcp/plugin/parser.h): Likewise.\n+\t* parser.c (cp_parser_token_starts_cast_expression): Likewise.\n+\n 2011-02-09  Jason Merrill  <jason@redhat.com>\n \n \t* decl.c (cp_make_fname_decl): Set DECL_THIS_STATIC at toplevel."}, {"sha": "7d8abaf01e50a46038c826c780519b352a66341e", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -326,3 +326,16 @@ cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \n cp/cxx-pretty-print.o: cp/cxx-pretty-print.c $(CXX_PRETTY_PRINT_H) \\\n   $(CONFIG_H) $(SYSTEM_H) $(TM_H) coretypes.h $(CXX_TREE_H) tree-pretty-print.h\n+\n+\n+# Objective-C++ related rules:\n+\n+cp/parser.o: $(objdir)/objcp/plugin/parser.h $(srcdir)/objcp/plugin/parser.c\n+\n+build/slashify:: $(srcdir)/config/slashify.c\n+\t$(COMPILER_FOR_BUILD) $(srcdir)/config/slashify.c -o $@\n+\n+$(objdir)/objcp/plugin/parser.h: $(srcdir)/objcp/plugin/parser.h | build/slashify\n+\ttest -d objcp || mkdir objcp\n+\ttest -d objcp/plugin || mkdir objcp/plugin\n+\tbuild/slashify < $< > $@"}, {"sha": "ecdc66c9a867fecd8eebd5deb9d9f4faf56f4fbf", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 17, "deletions": 2020, "changes": 2037, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -35,7 +35,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"cgraph.h\"\n #include \"c-family/c-common.h\"\n-#include \"c-family/c-objc.h\"\n #include \"plugin.h\"\n \n \f\n@@ -2099,44 +2098,7 @@ enum pragma_context { pragma_external, pragma_stmt, pragma_compound };\n static bool cp_parser_pragma\n   (cp_parser *, enum pragma_context);\n \n-/* Objective-C++ Productions */\n-\n-static tree cp_parser_objc_message_receiver\n-  (cp_parser *);\n-static tree cp_parser_objc_message_args\n-  (cp_parser *);\n-static tree cp_parser_objc_message_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_encode_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_defs_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_protocol_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_selector_expression\n-  (cp_parser *);\n-static tree cp_parser_objc_expression\n-  (cp_parser *);\n-static bool cp_parser_objc_selector_p\n-  (enum cpp_ttype);\n-static tree cp_parser_objc_selector\n-  (cp_parser *);\n-static tree cp_parser_objc_protocol_refs_opt\n-  (cp_parser *);\n-static void cp_parser_objc_declaration\n-  (cp_parser *, tree);\n-static tree cp_parser_objc_statement\n-  (cp_parser *);\n-static bool cp_parser_objc_valid_prefix_attributes\n-  (cp_parser *, tree *);\n-static void cp_parser_objc_at_property_declaration \n-  (cp_parser *) ;\n-static void cp_parser_objc_at_synthesize_declaration \n-  (cp_parser *) ;\n-static void cp_parser_objc_at_dynamic_declaration\n-  (cp_parser *) ;\n-static tree cp_parser_objc_struct_declaration\n-  (cp_parser *) ;\n+#include \"objcp/plugin/parser.h\"\n \n /* Utility Routines */\n \n@@ -3709,18 +3671,11 @@ cp_parser_primary_expression (cp_parser *parser,\n       }\n \n     case CPP_OPEN_SQUARE:\n-      if (c_dialect_objc ())\n-        /* We have an Objective-C++ message. */\n-        return cp_parser_objc_expression (parser);\n+      PLUGIN_PRIMARY_EXPRESSION_3(parser);\n       maybe_warn_cpp0x (CPP0X_LAMBDA_EXPR);\n       return cp_parser_lambda_expression (parser);\n \n-    case CPP_OBJC_STRING:\n-      if (c_dialect_objc ())\n-\t/* We have an Objective-C++ string literal. */\n-        return cp_parser_objc_expression (parser);\n-      cp_parser_error (parser, \"expected primary-expression\");\n-      return error_mark_node;\n+    PLUGIN_PRIMARY_EXPRESSION_2(parser, cp_parser_error)\n \n     case CPP_KEYWORD:\n       switch (token->keyword)\n@@ -3851,11 +3806,7 @@ cp_parser_primary_expression (cp_parser *parser,\n \tcase RID_IS_LITERAL_TYPE:\n \t  return cp_parser_trait_expr (parser, token->keyword);\n \n-\t/* Objective-C++ expressions.  */\n-\tcase RID_AT_ENCODE:\n-\tcase RID_AT_PROTOCOL:\n-\tcase RID_AT_SELECTOR:\n-\t  return cp_parser_objc_expression (parser);\n+\tPLUGIN_PRIMARY_EXPRESSION_1(parser)\n \n \tcase RID_TEMPLATE:\n \t  if (parser->in_function_body\n@@ -3939,25 +3890,8 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    if (ambiguous_decls)\n \t      return error_mark_node;\n \n-\t    /* In Objective-C++, we may have an Objective-C 2.0\n-\t       dot-syntax for classes here.  */\n-\t    if (c_dialect_objc ()\n-\t\t&& cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n-\t\t&& TREE_CODE (decl) == TYPE_DECL\n-\t\t&& objc_is_class_name (decl))\n-\t      {\n-\t\ttree component;\n-\t\tcp_lexer_consume_token (parser->lexer);\n-\t\tcomponent = cp_parser_identifier (parser);\n-\t\tif (component == error_mark_node)\n-\t\t  return error_mark_node;\n-\n-\t\treturn objc_build_class_component_ref (id_expression, component);\n-\t      }\n-\n-\t    /* In Objective-C++, an instance variable (ivar) may be preferred\n-\t       to whatever cp_parser_lookup_name() found.  */\n-\t    decl = objc_lookup_ivar (decl, id_expression);\n+\t    PLUGIN_PRIMARY_EXPRESSION (parser, decl, cp_lexer_consume_token,\n+\t\t\t\t       cp_lexer_peek_token);\n \n \t    /* If name lookup gives us a SCOPE_REF, then the\n \t       qualifying scope was dependent.  */\n@@ -6595,9 +6529,9 @@ cp_parser_token_starts_cast_expression (cp_token *token)\n     case CPP_EOF:\n       return false;\n \n-      /* '[' may start a primary-expression in obj-c++.  */\n     case CPP_OPEN_SQUARE:\n-      return c_dialect_objc ();\n+      PLUGIN_TOKEN_STARTS_CAST_EXPR;\n+      return false;\n \n     default:\n       return true;\n@@ -8082,14 +8016,7 @@ cp_parser_statement (cp_parser* parser, tree in_statement_expr,\n \t  statement = cp_parser_jump_statement (parser);\n \t  break;\n \n-\t  /* Objective-C++ exception-handling constructs.  */\n-\tcase RID_AT_TRY:\n-\tcase RID_AT_CATCH:\n-\tcase RID_AT_FINALLY:\n-\tcase RID_AT_SYNCHRONIZED:\n-\tcase RID_AT_THROW:\n-\t  statement = cp_parser_objc_statement (parser);\n-\t  break;\n+\tPLUGIN_STATEMENT\n \n \tcase RID_TRY:\n \t  statement = cp_parser_try_block (parser);\n@@ -9474,13 +9401,7 @@ cp_parser_declaration (cp_parser* parser)\n   else if (token1.keyword == RID_INLINE\n \t   && token2.keyword == RID_NAMESPACE)\n     cp_parser_namespace_definition (parser);\n-  /* Objective-C++ declaration/definition.  */\n-  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n-    cp_parser_objc_declaration (parser, NULL_TREE);\n-  else if (c_dialect_objc ()\n-\t   && token1.keyword == RID_ATTRIBUTE\n-\t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n-    cp_parser_objc_declaration (parser, attributes);\n+  PLUGIN_DECLARATION\n   /* We must have either a block declaration or a function\n      definition.  */\n   else\n@@ -12879,25 +12800,7 @@ cp_parser_simple_type_specifier (cp_parser* parser,\n \n   if (type && type != error_mark_node)\n     {\n-      /* See if TYPE is an Objective-C type, and if so, parse and\n-\t accept any protocol references following it.  Do this before\n-\t the cp_parser_check_for_invalid_template_id() call, because\n-\t Objective-C types can be followed by '<...>' which would\n-\t enclose protocol names rather than template arguments, and so\n-\t everything is fine.  */\n-      if (c_dialect_objc () && !parser->scope\n-\t  && (objc_is_id (type) || objc_is_class_name (type)))\n-\t{\n-\t  tree protos = cp_parser_objc_protocol_refs_opt (parser);\n-\t  tree qual_type = objc_get_protocol_qualified_type (type, protos);\n-\n-\t  /* Clobber the \"unqualified\" type previously entered into\n-\t     DECL_SPECS with the new, improved protocol-qualified version.  */\n-\t  if (decl_specs)\n-\t    decl_specs->type = qual_type;\n-\n-\t  return qual_type;\n-\t}\n+      PLUGIN_SIMPLE_TYPE_SPECIFIER;\n \n       /* There is no valid C++ program where a non-template type is\n \t followed by a \"<\".  That usually indicates that the user\n@@ -12973,26 +12876,11 @@ cp_parser_nonclass_name (cp_parser* parser)\n   /* Look up the type-name.  */\n   type_decl = cp_parser_lookup_name_simple (parser, identifier, token->location);\n \n-  if (TREE_CODE (type_decl) != TYPE_DECL\n-      && (objc_is_id (identifier) || objc_is_class_name (identifier)))\n-    {\n-      /* See if this is an Objective-C type.  */\n-      tree protos = cp_parser_objc_protocol_refs_opt (parser);\n-      tree type = objc_get_protocol_qualified_type (identifier, protos);\n-      if (type)\n-\ttype_decl = TYPE_NAME (type);\n-    }\n+  PLUGIN_NONCLASS_NAME1;\n \n   /* Issue an error if we did not find a type-name.  */\n   if (TREE_CODE (type_decl) != TYPE_DECL\n-      /* In Objective-C, we have the complication that class names are\n-\t normally type names and start declarations (eg, the\n-\t \"NSObject\" in \"NSObject *object;\"), but can be used in an\n-\t Objective-C 2.0 dot-syntax (as in \"NSObject.version\") which\n-\t is an expression.  So, a classname followed by a dot is not a\n-\t valid type-name.  */\n-      || (objc_is_class_name (TREE_TYPE (type_decl))\n-\t  && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT))\n+      PLUGIN_NONCLASS_NAME)\n     {\n       if (!cp_parser_simulate_error (parser))\n \tcp_parser_name_lookup_error (parser, identifier, type_decl,\n@@ -16836,11 +16724,7 @@ cp_parser_class_name (cp_parser *parser,\n   else if (TREE_CODE (decl) != TYPE_DECL\n \t   || TREE_TYPE (decl) == error_mark_node\n \t   || !MAYBE_CLASS_TYPE_P (TREE_TYPE (decl))\n-\t   /* In Objective-C 2.0, a classname followed by '.' starts a\n-\t      dot-syntax expression, and it's not a type-name.  */\n-\t   || (c_dialect_objc ()\n-\t       && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n-\t       && objc_is_class_name (decl)))\n+\t   PLUGIN_CLASS_NAME)\n     decl = error_mark_node;\n \n   if (decl == error_mark_node)\n@@ -17701,21 +17585,7 @@ cp_parser_member_declaration (cp_parser* parser)\n       return;\n     }\n \n-  /* Check for @defs.  */\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_DEFS))\n-    {\n-      tree ivar, member;\n-      tree ivar_chains = cp_parser_objc_defs_expression (parser);\n-      ivar = ivar_chains;\n-      while (ivar)\n-\t{\n-\t  member = ivar;\n-\t  ivar = TREE_CHAIN (member);\n-\t  TREE_CHAIN (member) = NULL_TREE;\n-\t  finish_member_declaration (member);\n-\t}\n-      return;\n-    }\n+  PLUGIN_MEMBER_DECLARATION;\n \n   /* If the next token is `static_assert' we have a static assertion.  */\n   if (cp_lexer_next_token_is_keyword (parser->lexer, RID_STATIC_ASSERT))\n@@ -21431,1884 +21301,11 @@ cp_parser_allow_gnu_extensions_p (cp_parser* parser)\n {\n   return parser->allow_gnu_extensions_p;\n }\n+\n \f\n /* Objective-C++ Productions */\n \n-\n-/* Parse an Objective-C expression, which feeds into a primary-expression\n-   above.\n-\n-   objc-expression:\n-     objc-message-expression\n-     objc-string-literal\n-     objc-encode-expression\n-     objc-protocol-expression\n-     objc-selector-expression\n-\n-  Returns a tree representation of the expression.  */\n-\n-static tree\n-cp_parser_objc_expression (cp_parser* parser)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (kwd->type)\n-    {\n-    case CPP_OPEN_SQUARE:\n-      return cp_parser_objc_message_expression (parser);\n-\n-    case CPP_OBJC_STRING:\n-      kwd = cp_lexer_consume_token (parser->lexer);\n-      return objc_build_string_object (kwd->u.value);\n-\n-    case CPP_KEYWORD:\n-      switch (kwd->keyword)\n-\t{\n-\tcase RID_AT_ENCODE:\n-\t  return cp_parser_objc_encode_expression (parser);\n-\n-\tcase RID_AT_PROTOCOL:\n-\t  return cp_parser_objc_protocol_expression (parser);\n-\n-\tcase RID_AT_SELECTOR:\n-\t  return cp_parser_objc_selector_expression (parser);\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    default:\n-      error_at (kwd->location,\n-\t\t\"misplaced %<@%D%> Objective-C++ construct\",\n-\t\tkwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-\n-  return error_mark_node;\n-}\n-\n-/* Parse an Objective-C message expression.\n-\n-   objc-message-expression:\n-     [ objc-message-receiver objc-message-args ]\n-\n-   Returns a representation of an Objective-C message.  */\n-\n-static tree\n-cp_parser_objc_message_expression (cp_parser* parser)\n-{\n-  tree receiver, messageargs;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n-  receiver = cp_parser_objc_message_receiver (parser);\n-  messageargs = cp_parser_objc_message_args (parser);\n-  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-\n-  return objc_build_message_expr (build_tree_list (receiver, messageargs));\n-}\n-\n-/* Parse an objc-message-receiver.\n-\n-   objc-message-receiver:\n-     expression\n-     simple-type-specifier\n-\n-  Returns a representation of the type or expression.  */\n-\n-static tree\n-cp_parser_objc_message_receiver (cp_parser* parser)\n-{\n-  tree rcv;\n-\n-  /* An Objective-C message receiver may be either (1) a type\n-     or (2) an expression.  */\n-  cp_parser_parse_tentatively (parser);\n-  rcv = cp_parser_expression (parser, false, NULL);\n-\n-  if (cp_parser_parse_definitely (parser))\n-    return rcv;\n-\n-  rcv = cp_parser_simple_type_specifier (parser,\n-\t\t\t\t\t /*decl_specs=*/NULL,\n-\t\t\t\t\t CP_PARSER_FLAGS_NONE);\n-\n-  return objc_get_class_reference (rcv);\n-}\n-\n-/* Parse the arguments and selectors comprising an Objective-C message.\n-\n-   objc-message-args:\n-     objc-selector\n-     objc-selector-args\n-     objc-selector-args , objc-comma-args\n-\n-   objc-selector-args:\n-     objc-selector [opt] : assignment-expression\n-     objc-selector-args objc-selector [opt] : assignment-expression\n-\n-   objc-comma-args:\n-     assignment-expression\n-     objc-comma-args , assignment-expression\n-\n-   Returns a TREE_LIST, with TREE_PURPOSE containing a list of\n-   selector arguments and TREE_VALUE containing a list of comma\n-   arguments.  */\n-\n-static tree\n-cp_parser_objc_message_args (cp_parser* parser)\n-{\n-  tree sel_args = NULL_TREE, addl_args = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n-    {\n-      tree selector = NULL_TREE, arg;\n-\n-      if (token->type != CPP_COLON)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      /* Detect if we have a unary selector.  */\n-      if (maybe_unary_selector_p\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\treturn build_tree_list (selector, NULL_TREE);\n-\n-      maybe_unary_selector_p = false;\n-      cp_parser_require (parser, CPP_COLON, RT_COLON);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n-\n-      sel_args\n-\t= chainon (sel_args,\n-\t\t   build_tree_list (selector, arg));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  /* Handle non-selector arguments, if any. */\n-  while (token->type == CPP_COMMA)\n-    {\n-      tree arg;\n-\n-      cp_lexer_consume_token (parser->lexer);\n-      arg = cp_parser_assignment_expression (parser, false, NULL);\n-\n-      addl_args\n-\t= chainon (addl_args,\n-\t\t   build_tree_list (NULL_TREE, arg));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (sel_args == NULL_TREE && addl_args == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ message argument(s) are expected\");\n-      return build_tree_list (error_mark_node, error_mark_node);\n-    }\n-\n-  return build_tree_list (sel_args, addl_args);\n-}\n-\n-/* Parse an Objective-C encode expression.\n-\n-   objc-encode-expression:\n-     @encode objc-typename\n-\n-   Returns an encoded representation of the type argument.  */\n-\n-static tree\n-cp_parser_objc_encode_expression (cp_parser* parser)\n-{\n-  tree type;\n-  cp_token *token;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  token = cp_lexer_peek_token (parser->lexer);\n-  type = complete_type (cp_parser_type_id (parser));\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  if (!type)\n-    {\n-      error_at (token->location, \n-\t\t\"%<@encode%> must specify a type as an argument\");\n-      return error_mark_node;\n-    }\n-\n-  /* This happens if we find @encode(T) (where T is a template\n-     typename or something dependent on a template typename) when\n-     parsing a template.  In that case, we can't compile it\n-     immediately, but we rather create an AT_ENCODE_EXPR which will\n-     need to be instantiated when the template is used.\n-  */\n-  if (dependent_type_p (type))\n-    {\n-      tree value = build_min (AT_ENCODE_EXPR, size_type_node, type);\n-      TREE_READONLY (value) = 1;\n-      return value;\n-    }\n-\n-  return objc_build_encode_expr (type);\n-}\n-\n-/* Parse an Objective-C @defs expression.  */\n-\n-static tree\n-cp_parser_objc_defs_expression (cp_parser *parser)\n-{\n-  tree name;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  name = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_get_class_ivars (name);\n-}\n-\n-/* Parse an Objective-C protocol expression.\n-\n-  objc-protocol-expression:\n-    @protocol ( identifier )\n-\n-  Returns a representation of the protocol expression.  */\n-\n-static tree\n-cp_parser_objc_protocol_expression (cp_parser* parser)\n-{\n-  tree proto;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  proto = cp_parser_identifier (parser);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_build_protocol_expr (proto);\n-}\n-\n-/* Parse an Objective-C selector expression.\n-\n-   objc-selector-expression:\n-     @selector ( objc-method-signature )\n-\n-   objc-method-signature:\n-     objc-selector\n-     objc-selector-seq\n-\n-   objc-selector-seq:\n-     objc-selector :\n-     objc-selector-seq objc-selector :\n-\n-  Returns a representation of the method selector.  */\n-\n-static tree\n-cp_parser_objc_selector_expression (cp_parser* parser)\n-{\n-  tree sel_seq = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token;\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n-\t || token->type == CPP_SCOPE)\n-    {\n-      tree selector = NULL_TREE;\n-\n-      if (token->type != CPP_COLON\n-\t  || token->type == CPP_SCOPE)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON)\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n-\t{\n-\t  /* Detect if we have a unary selector.  */\n-\t  if (maybe_unary_selector_p)\n-\t    {\n-\t      sel_seq = selector;\n-\t      goto finish_selector;\n-\t    }\n-\t  else\n-\t    {\n-\t      cp_parser_error (parser, \"expected %<:%>\");\n-\t    }\n-\t}\n-      maybe_unary_selector_p = false;\n-      token = cp_lexer_consume_token (parser->lexer);\n-\n-      if (token->type == CPP_SCOPE)\n-\t{\n-\t  sel_seq\n-\t    = chainon (sel_seq,\n-\t\t       build_tree_list (selector, NULL_TREE));\n-\t  sel_seq\n-\t    = chainon (sel_seq,\n-\t\t       build_tree_list (NULL_TREE, NULL_TREE));\n-\t}\n-      else\n-\tsel_seq\n-\t  = chainon (sel_seq,\n-\t\t     build_tree_list (selector, NULL_TREE));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n- finish_selector:\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  return objc_build_selector_expr (loc, sel_seq);\n-}\n-\n-/* Parse a list of identifiers.\n-\n-   objc-identifier-list:\n-     identifier\n-     objc-identifier-list , identifier\n-\n-   Returns a TREE_LIST of identifier nodes.  */\n-\n-static tree\n-cp_parser_objc_identifier_list (cp_parser* parser)\n-{\n-  tree identifier;\n-  tree list;\n-  cp_token *sep;\n-\n-  identifier = cp_parser_identifier (parser);\n-  if (identifier == error_mark_node)\n-    return error_mark_node;      \n-\n-  list = build_tree_list (NULL_TREE, identifier);\n-  sep = cp_lexer_peek_token (parser->lexer);\n-\n-  while (sep->type == CPP_COMMA)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-      identifier = cp_parser_identifier (parser);\n-      if (identifier == error_mark_node)\n-\treturn list;\n-\n-      list = chainon (list, build_tree_list (NULL_TREE,\n-\t\t\t\t\t     identifier));\n-      sep = cp_lexer_peek_token (parser->lexer);\n-    }\n-  \n-  return list;\n-}\n-\n-/* Parse an Objective-C alias declaration.\n-\n-   objc-alias-declaration:\n-     @compatibility_alias identifier identifier ;\n-\n-   This function registers the alias mapping with the Objective-C front end.\n-   It returns nothing.  */\n-\n-static void\n-cp_parser_objc_alias_declaration (cp_parser* parser)\n-{\n-  tree alias, orig;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@compatibility_alias'.  */\n-  alias = cp_parser_identifier (parser);\n-  orig = cp_parser_identifier (parser);\n-  objc_declare_alias (alias, orig);\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse an Objective-C class forward-declaration.\n-\n-   objc-class-declaration:\n-     @class objc-identifier-list ;\n-\n-   The function registers the forward declarations with the Objective-C\n-   front end.  It returns nothing.  */\n-\n-static void\n-cp_parser_objc_class_declaration (cp_parser* parser)\n-{\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@class'.  */\n-  objc_declare_class (cp_parser_objc_identifier_list (parser));\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse a list of Objective-C protocol references.\n-\n-   objc-protocol-refs-opt:\n-     objc-protocol-refs [opt]\n-\n-   objc-protocol-refs:\n-     < objc-identifier-list >\n-\n-   Returns a TREE_LIST of identifiers, if any.  */\n-\n-static tree\n-cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n-{\n-  tree protorefs = NULL_TREE;\n-\n-  if(cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n-      protorefs = cp_parser_objc_identifier_list (parser);\n-      cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n-    }\n-\n-  return protorefs;\n-}\n-\n-/* Parse a Objective-C visibility specification.  */\n-\n-static void\n-cp_parser_objc_visibility_spec (cp_parser* parser)\n-{\n-  cp_token *vis = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (vis->keyword)\n-    {\n-    case RID_AT_PRIVATE:\n-      objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);\n-      break;\n-    case RID_AT_PROTECTED:\n-      objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);\n-      break;\n-    case RID_AT_PUBLIC:\n-      objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);\n-      break;\n-    case RID_AT_PACKAGE:\n-      objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);\n-      break;\n-    default:\n-      return;\n-    }\n-\n-  /* Eat '@private'/'@protected'/'@public'.  */\n-  cp_lexer_consume_token (parser->lexer);\n-}\n-\n-/* Parse an Objective-C method type.  Return 'true' if it is a class\n-   (+) method, and 'false' if it is an instance (-) method.  */\n-\n-static inline bool\n-cp_parser_objc_method_type (cp_parser* parser)\n-{\n-  if (cp_lexer_consume_token (parser->lexer)->type == CPP_PLUS)\n-    return true;\n-  else\n-    return false;\n-}\n-\n-/* Parse an Objective-C protocol qualifier.  */\n-\n-static tree\n-cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n-{\n-  tree quals = NULL_TREE, node;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  node = token->u.value;\n-\n-  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n-\t && (node == ridpointers [(int) RID_IN]\n-\t     || node == ridpointers [(int) RID_OUT]\n-\t     || node == ridpointers [(int) RID_INOUT]\n-\t     || node == ridpointers [(int) RID_BYCOPY]\n-\t     || node == ridpointers [(int) RID_BYREF]\n-\t     || node == ridpointers [(int) RID_ONEWAY]))\n-    {\n-      quals = tree_cons (NULL_TREE, node, quals);\n-      cp_lexer_consume_token (parser->lexer);\n-      token = cp_lexer_peek_token (parser->lexer);\n-      node = token->u.value;\n-    }\n-\n-  return quals;\n-}\n-\n-/* Parse an Objective-C typename.  */\n-\n-static tree\n-cp_parser_objc_typename (cp_parser* parser)\n-{\n-  tree type_name = NULL_TREE;\n-\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    {\n-      tree proto_quals, cp_type = NULL_TREE;\n-\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n-      proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n-\n-      /* An ObjC type name may consist of just protocol qualifiers, in which\n-\t case the type shall default to 'id'.  */\n-      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n-\t{\n-\t  cp_type = cp_parser_type_id (parser);\n-\t  \n-\t  /* If the type could not be parsed, an error has already\n-\t     been produced.  For error recovery, behave as if it had\n-\t     not been specified, which will use the default type\n-\t     'id'.  */\n-\t  if (cp_type == error_mark_node)\n-\t    {\n-\t      cp_type = NULL_TREE;\n-\t      /* We need to skip to the closing parenthesis as\n-\t\t cp_parser_type_id() does not seem to do it for\n-\t\t us.  */\n-\t      cp_parser_skip_to_closing_parenthesis (parser,\n-\t\t\t\t\t\t     /*recovering=*/true,\n-\t\t\t\t\t\t     /*or_comma=*/false,\n-\t\t\t\t\t\t     /*consume_paren=*/false);\n-\t    }\n-\t}\n-\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      type_name = build_tree_list (proto_quals, cp_type);\n-    }\n-\n-  return type_name;\n-}\n-\n-/* Check to see if TYPE refers to an Objective-C selector name.  */\n-\n-static bool\n-cp_parser_objc_selector_p (enum cpp_ttype type)\n-{\n-  return (type == CPP_NAME || type == CPP_KEYWORD\n-\t  || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND\n-\t  || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT\n-\t  || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ\n-\t  || type == CPP_XOR || type == CPP_XOR_EQ);\n-}\n-\n-/* Parse an Objective-C selector.  */\n-\n-static tree\n-cp_parser_objc_selector (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_consume_token (parser->lexer);\n-\n-  if (!cp_parser_objc_selector_p (token->type))\n-    {\n-      error_at (token->location, \"invalid Objective-C++ selector name\");\n-      return error_mark_node;\n-    }\n-\n-  /* C++ operator names are allowed to appear in ObjC selectors.  */\n-  switch (token->type)\n-    {\n-    case CPP_AND_AND: return get_identifier (\"and\");\n-    case CPP_AND_EQ: return get_identifier (\"and_eq\");\n-    case CPP_AND: return get_identifier (\"bitand\");\n-    case CPP_OR: return get_identifier (\"bitor\");\n-    case CPP_COMPL: return get_identifier (\"compl\");\n-    case CPP_NOT: return get_identifier (\"not\");\n-    case CPP_NOT_EQ: return get_identifier (\"not_eq\");\n-    case CPP_OR_OR: return get_identifier (\"or\");\n-    case CPP_OR_EQ: return get_identifier (\"or_eq\");\n-    case CPP_XOR: return get_identifier (\"xor\");\n-    case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n-    default: return token->u.value;\n-    }\n-}\n-\n-/* Parse an Objective-C params list.  */\n-\n-static tree\n-cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n-{\n-  tree params = NULL_TREE;\n-  bool maybe_unary_selector_p = true;\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n-    {\n-      tree selector = NULL_TREE, type_name, identifier;\n-      tree parm_attr = NULL_TREE;\n-\n-      if (token->keyword == RID_ATTRIBUTE)\n-\tbreak;\n-\n-      if (token->type != CPP_COLON)\n-\tselector = cp_parser_objc_selector (parser);\n-\n-      /* Detect if we have a unary selector.  */\n-      if (maybe_unary_selector_p\n-\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t{\n-\t  params = selector; /* Might be followed by attributes.  */\n-\t  break;\n-\t}\n-\n-      maybe_unary_selector_p = false;\n-      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n-\t{\n-\t  /* Something went quite wrong.  There should be a colon\n-\t     here, but there is not.  Stop parsing parameters.  */\n-\t  break;\n-\t}\n-      type_name = cp_parser_objc_typename (parser);\n-      /* New ObjC allows attributes on parameters too.  */\n-      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n-\tparm_attr = cp_parser_attributes_opt (parser);\n-      identifier = cp_parser_identifier (parser);\n-\n-      params\n-\t= chainon (params,\n-\t\t   objc_build_keyword_decl (selector,\n-\t\t\t\t\t    type_name,\n-\t\t\t\t\t    identifier,\n-\t\t\t\t\t    parm_attr));\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (params == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n-      return error_mark_node;\n-    }\n-\n-  /* We allow tail attributes for the method.  */\n-  if (token->keyword == RID_ATTRIBUTE)\n-    {\n-      *attributes = cp_parser_attributes_opt (parser);\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n-\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\treturn params;\n-      cp_parser_error (parser, \n-\t\t       \"method attributes must be specified at the end\");\n-      return error_mark_node;\n-    }\n-\n-  if (params == NULL_TREE)\n-    {\n-      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n-      return error_mark_node;\n-    }\n-  return params;\n-}\n-\n-/* Parse the non-keyword Objective-C params.  */\n-\n-static tree\n-cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n-\t\t\t\t       tree* attributes)\n-{\n-  tree params = make_node (TREE_LIST);\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-  *ellipsisp = false;  /* Initially, assume no ellipsis.  */\n-\n-  while (token->type == CPP_COMMA)\n-    {\n-      cp_parameter_declarator *parmdecl;\n-      tree parm;\n-\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-\n-      if (token->type == CPP_ELLIPSIS)\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);  /* Eat '...'.  */\n-\t  *ellipsisp = true;\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  break;\n-\t}\n-\n-      /* TODO: parse attributes for tail parameters.  */\n-      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n-      parm = grokdeclarator (parmdecl->declarator,\n-\t\t\t     &parmdecl->decl_specifiers,\n-\t\t\t     PARM, /*initialized=*/0,\n-\t\t\t     /*attrlist=*/NULL);\n-\n-      chainon (params, build_tree_list (NULL_TREE, parm));\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  /* We allow tail attributes for the method.  */\n-  if (token->keyword == RID_ATTRIBUTE)\n-    {\n-      if (*attributes == NULL_TREE)\n-\t{\n-\t  *attributes = cp_parser_attributes_opt (parser);\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n-\t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n-\t    return params;\n-\t}\n-      else        \n-\t/* We have an error, but parse the attributes, so that we can \n-\t   carry on.  */\n-\t*attributes = cp_parser_attributes_opt (parser);\n-\n-      cp_parser_error (parser, \n-\t\t       \"method attributes must be specified at the end\");\n-      return error_mark_node;\n-    }\n-\n-  return params;\n-}\n-\n-/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */\n-\n-static void\n-cp_parser_objc_interstitial_code (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  /* If the next token is `extern' and the following token is a string\n-     literal, then we have a linkage specification.  */\n-  if (token->keyword == RID_EXTERN\n-      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n-    cp_parser_linkage_specification (parser);\n-  /* Handle #pragma, if any.  */\n-  else if (token->type == CPP_PRAGMA)\n-    cp_parser_pragma (parser, pragma_external);\n-  /* Allow stray semicolons.  */\n-  else if (token->type == CPP_SEMICOLON)\n-    cp_lexer_consume_token (parser->lexer);\n-  /* Mark methods as optional or required, when building protocols.  */\n-  else if (token->keyword == RID_AT_OPTIONAL)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      objc_set_method_opt (true);\n-    }\n-  else if (token->keyword == RID_AT_REQUIRED)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      objc_set_method_opt (false);\n-    }\n-  else if (token->keyword == RID_NAMESPACE)\n-    cp_parser_namespace_definition (parser);\n-  /* Other stray characters must generate errors.  */\n-  else if (token->type == CPP_OPEN_BRACE || token->type == CPP_CLOSE_BRACE)\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      error (\"stray %qs between Objective-C++ methods\",\n-\t     token->type == CPP_OPEN_BRACE ? \"{\" : \"}\");\n-    }\n-  /* Finally, try to parse a block-declaration, or a function-definition.  */\n-  else\n-    cp_parser_block_declaration (parser, /*statement_p=*/false);\n-}\n-\n-/* Parse a method signature.  */\n-\n-static tree\n-cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n-{\n-  tree rettype, kwdparms, optparms;\n-  bool ellipsis = false;\n-  bool is_class_method;\n-\n-  is_class_method = cp_parser_objc_method_type (parser);\n-  rettype = cp_parser_objc_typename (parser);\n-  *attributes = NULL_TREE;\n-  kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);\n-  if (kwdparms == error_mark_node)\n-    return error_mark_node;\n-  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis, attributes);\n-  if (optparms == error_mark_node)\n-    return error_mark_node;\n-\n-  return objc_build_method_signature (is_class_method, rettype, kwdparms, optparms, ellipsis);\n-}\n-\n-static bool\n-cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n-{\n-  tree tattr;  \n-  cp_lexer_save_tokens (parser->lexer);\n-  tattr = cp_parser_attributes_opt (parser);\n-  gcc_assert (tattr) ;\n-  \n-  /* If the attributes are followed by a method introducer, this is not allowed.\n-     Dump the attributes and flag the situation.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n-      || cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n-    return true;\n-\n-  /* Otherwise, the attributes introduce some interstitial code, possibly so\n-     rewind to allow that check.  */\n-  cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n-}\n-\n-/* Parse an Objective-C method prototype list.  */\n-\n-static void\n-cp_parser_objc_method_prototype_list (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n-\t{\n-\t  tree attributes, sig;\n-\t  bool is_class_method;\n-\t  if (token->type == CPP_PLUS)\n-\t    is_class_method = true;\n-\t  else\n-\t    is_class_method = false;\n-\t  sig = cp_parser_objc_method_signature (parser, &attributes);\n-\t  if (sig == error_mark_node)\n-\t    {\n-\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      continue;\n-\t    }\n-\t  objc_add_method_declaration (is_class_method, sig, attributes);\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t}\n-      else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n-      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n-\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n-\t\t    OPT_Wattributes, \n-\t\t    \"prefix attributes are ignored for methods\");\n-      else\n-\t/* Allow for interspersed non-ObjC++ code.  */\n-\tcp_parser_objc_interstitial_code (parser);\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  else\n-    cp_parser_error (parser, \"expected %<@end%>\");\n-\n-  objc_finish_interface ();\n-}\n-\n-/* Parse an Objective-C method definition list.  */\n-\n-static void\n-cp_parser_objc_method_definition_list (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      tree meth;\n-\n-      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n-\t{\n-\t  cp_token *ptk;\n-\t  tree sig, attribute;\n-\t  bool is_class_method;\n-\t  if (token->type == CPP_PLUS)\n-\t    is_class_method = true;\n-\t  else\n-\t    is_class_method = false;\n-\t  push_deferring_access_checks (dk_deferred);\n-\t  sig = cp_parser_objc_method_signature (parser, &attribute);\n-\t  if (sig == error_mark_node)\n-\t    {\n-\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n-\t      token = cp_lexer_peek_token (parser->lexer);\n-\t      continue;\n-\t    }\n-\t  objc_start_method_definition (is_class_method, sig, attribute);\n-\n-\t  /* For historical reasons, we accept an optional semicolon.  */\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\n-\t  ptk = cp_lexer_peek_token (parser->lexer);\n-\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n-\t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n-\t    {\n-\t      perform_deferred_access_checks ();\n-\t      stop_deferring_access_checks ();\n-\t      meth = cp_parser_function_definition_after_declarator (parser,\n-\t\t\t\t\t\t\t\t     false);\n-\t      pop_deferring_access_checks ();\n-\t      objc_finish_method_definition (meth);\n-\t    }\n-\t}\n-      /* The following case will be removed once @synthesize is\n-\t completely implemented.  */\n-      else if (token->keyword == RID_AT_PROPERTY)\n-\tcp_parser_objc_at_property_declaration (parser);\n-      else if (token->keyword == RID_AT_SYNTHESIZE)\n-\tcp_parser_objc_at_synthesize_declaration (parser);\n-      else if (token->keyword == RID_AT_DYNAMIC)\n-\tcp_parser_objc_at_dynamic_declaration (parser);\n-      else if (token->keyword == RID_ATTRIBUTE \n-      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n-\twarning_at (token->location, OPT_Wattributes,\n-\t       \t    \"prefix attributes are ignored for methods\");\n-      else\n-\t/* Allow for interspersed non-ObjC++ code.  */\n-\tcp_parser_objc_interstitial_code (parser);\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  else\n-    cp_parser_error (parser, \"expected %<@end%>\");\n-\n-  objc_finish_implementation ();\n-}\n-\n-/* Parse Objective-C ivars.  */\n-\n-static void\n-cp_parser_objc_class_ivars (cp_parser* parser)\n-{\n-  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-\n-  if (token->type != CPP_OPEN_BRACE)\n-    return;\t/* No ivars specified.  */\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n-  token = cp_lexer_peek_token (parser->lexer);\n-\n-  while (token->type != CPP_CLOSE_BRACE \n-\t&& token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    {\n-      cp_decl_specifier_seq declspecs;\n-      int decl_class_or_enum_p;\n-      tree prefix_attributes;\n-\n-      cp_parser_objc_visibility_spec (parser);\n-\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n-\tbreak;\n-\n-      cp_parser_decl_specifier_seq (parser,\n-\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n-\t\t\t\t    &declspecs,\n-\t\t\t\t    &decl_class_or_enum_p);\n-\n-      /* auto, register, static, extern, mutable.  */\n-      if (declspecs.storage_class != sc_none)\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n-\t  declspecs.storage_class = sc_none;\n-\t}\n-\n-      /* __thread.  */\n-      if (declspecs.specs[(int) ds_thread])\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_thread] = 0;\n-\t}\n-      \n-      /* typedef.  */\n-      if (declspecs.specs[(int) ds_typedef])\n-\t{\n-\t  cp_parser_error (parser, \"invalid type for instance variable\");\n-\t  declspecs.specs[(int) ds_typedef] = 0;\n-\t}\n-\n-      prefix_attributes = declspecs.attributes;\n-      declspecs.attributes = NULL_TREE;\n-\n-      /* Keep going until we hit the `;' at the end of the\n-\t declaration.  */\n-      while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-\t{\n-\t  tree width = NULL_TREE, attributes, first_attribute, decl;\n-\t  cp_declarator *declarator = NULL;\n-\t  int ctor_dtor_or_conv_p;\n-\n-\t  /* Check for a (possibly unnamed) bitfield declaration.  */\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\t  if (token->type == CPP_COLON)\n-\t    goto eat_colon;\n-\n-\t  if (token->type == CPP_NAME\n-\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n-\t\t  == CPP_COLON))\n-\t    {\n-\t      /* Get the name of the bitfield.  */\n-\t      declarator = make_id_declarator (NULL_TREE,\n-\t\t\t\t\t       cp_parser_identifier (parser),\n-\t\t\t\t\t       sfk_none);\n-\n-\t     eat_colon:\n-\t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n-\t      /* Get the width of the bitfield.  */\n-\t      width\n-\t\t= cp_parser_constant_expression (parser,\n-\t\t\t\t\t\t /*allow_non_constant=*/false,\n-\t\t\t\t\t\t NULL);\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Parse the declarator.  */\n-\t      declarator\n-\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t&ctor_dtor_or_conv_p,\n-\t\t\t\t\t/*parenthesized_p=*/NULL,\n-\t\t\t\t\t/*member_p=*/false);\n-\t    }\n-\n-\t  /* Look for attributes that apply to the ivar.  */\n-\t  attributes = cp_parser_attributes_opt (parser);\n-\t  /* Remember which attributes are prefix attributes and\n-\t     which are not.  */\n-\t  first_attribute = attributes;\n-\t  /* Combine the attributes.  */\n-\t  attributes = chainon (prefix_attributes, attributes);\n-\n-\t  if (width)\n-\t      /* Create the bitfield declaration.  */\n-\t      decl = grokbitfield (declarator, &declspecs,\n-\t\t\t\t   width,\n-\t\t\t\t   attributes);\n-\t  else\n-\t    decl = grokfield (declarator, &declspecs,\n-\t\t\t      NULL_TREE, /*init_const_expr_p=*/false,\n-\t\t\t      NULL_TREE, attributes);\n-\n-\t  /* Add the instance variable.  */\n-\t  objc_add_instance_variable (decl);\n-\n-\t  /* Reset PREFIX_ATTRIBUTES.  */\n-\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\t    attributes = TREE_CHAIN (attributes);\n-\t  if (attributes)\n-\t    TREE_CHAIN (attributes) = NULL_TREE;\n-\n-\t  token = cp_lexer_peek_token (parser->lexer);\n-\n-\t  if (token->type == CPP_COMMA)\n-\t    {\n-\t      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-\t      continue;\n-\t    }\n-\t  break;\n-\t}\n-\n-      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-      token = cp_lexer_peek_token (parser->lexer);\n-    }\n-\n-  if (token->keyword == RID_AT_END)\n-    cp_parser_error (parser, \"expected %<}%>\");\n-\n-  /* Do not consume the RID_AT_END, so it will be read again as terminating\n-     the @interface of @implementation.  */ \n-  if (token->keyword != RID_AT_END && token->type != CPP_EOF)\n-    cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n-    \n-  /* For historical reasons, we accept an optional semicolon.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-    cp_lexer_consume_token (parser->lexer);\n-}\n-\n-/* Parse an Objective-C protocol declaration.  */\n-\n-static void\n-cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n-{\n-  tree proto, protorefs;\n-  cp_token *tok;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-    {\n-      tok = cp_lexer_peek_token (parser->lexer);\n-      error_at (tok->location, \"identifier expected after %<@protocol%>\");\n-      goto finish;\n-    }\n-\n-  /* See if we have a forward declaration or a definition.  */\n-  tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n-\n-  /* Try a forward declaration first.  */\n-  if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n-    {\n-      objc_declare_protocols (cp_parser_objc_identifier_list (parser), \n-\t\t\t      attributes);\n-     finish:\n-      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-    }\n-\n-  /* Ok, we got a full-fledged definition (or at least should).  */\n-  else\n-    {\n-      proto = cp_parser_identifier (parser);\n-      protorefs = cp_parser_objc_protocol_refs_opt (parser);\n-      objc_start_protocol (proto, protorefs, attributes);\n-      cp_parser_objc_method_prototype_list (parser);\n-    }\n-}\n-\n-/* Parse an Objective-C superclass or category.  */\n-\n-static void\n-cp_parser_objc_superclass_or_category (cp_parser *parser, \n-\t\t\t\t       bool iface_p,\n-\t\t\t\t       tree *super,\n-\t\t\t\t       tree *categ, bool *is_class_extension)\n-{\n-  cp_token *next = cp_lexer_peek_token (parser->lexer);\n-\n-  *super = *categ = NULL_TREE;\n-  *is_class_extension = false;\n-  if (next->type == CPP_COLON)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n-      *super = cp_parser_identifier (parser);\n-    }\n-  else if (next->type == CPP_OPEN_PAREN)\n-    {\n-      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n-\n-      /* If there is no category name, and this is an @interface, we\n-\t have a class extension.  */\n-      if (iface_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-\t{\n-\t  *categ = NULL_TREE;\n-\t  *is_class_extension = true;\n-\t}\n-      else\n-\t*categ = cp_parser_identifier (parser);\n-\n-      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-    }\n-}\n-\n-/* Parse an Objective-C class interface.  */\n-\n-static void\n-cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n-{\n-  tree name, super, categ, protos;\n-  bool is_class_extension;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n-  name = cp_parser_identifier (parser);\n-  if (name == error_mark_node)\n-    {\n-      /* It's hard to recover because even if valid @interface stuff\n-\t is to follow, we can't compile it (or validate it) if we\n-\t don't even know which class it refers to.  Let's assume this\n-\t was a stray '@interface' token in the stream and skip it.\n-      */\n-      return;\n-    }\n-  cp_parser_objc_superclass_or_category (parser, true, &super, &categ,\n-\t\t\t\t\t &is_class_extension);\n-  protos = cp_parser_objc_protocol_refs_opt (parser);\n-\n-  /* We have either a class or a category on our hands.  */\n-  if (categ || is_class_extension)\n-    objc_start_category_interface (name, categ, protos, attributes);\n-  else\n-    {\n-      objc_start_class_interface (name, super, protos, attributes);\n-      /* Handle instance variable declarations, if any.  */\n-      cp_parser_objc_class_ivars (parser);\n-      objc_continue_interface ();\n-    }\n-\n-  cp_parser_objc_method_prototype_list (parser);\n-}\n-\n-/* Parse an Objective-C class implementation.  */\n-\n-static void\n-cp_parser_objc_class_implementation (cp_parser* parser)\n-{\n-  tree name, super, categ;\n-  bool is_class_extension;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n-  name = cp_parser_identifier (parser);\n-  if (name == error_mark_node)\n-    {\n-      /* It's hard to recover because even if valid @implementation\n-\t stuff is to follow, we can't compile it (or validate it) if\n-\t we don't even know which class it refers to.  Let's assume\n-\t this was a stray '@implementation' token in the stream and\n-\t skip it.\n-      */\n-      return;\n-    }\n-  cp_parser_objc_superclass_or_category (parser, false, &super, &categ,\n-\t\t\t\t\t &is_class_extension);\n-\n-  /* We have either a class or a category on our hands.  */\n-  if (categ)\n-    objc_start_category_implementation (name, categ);\n-  else\n-    {\n-      objc_start_class_implementation (name, super);\n-      /* Handle instance variable declarations, if any.  */\n-      cp_parser_objc_class_ivars (parser);\n-      objc_continue_implementation ();\n-    }\n-\n-  cp_parser_objc_method_definition_list (parser);\n-}\n-\n-/* Consume the @end token and finish off the implementation.  */\n-\n-static void\n-cp_parser_objc_end_implementation (cp_parser* parser)\n-{\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n-  objc_finish_implementation ();\n-}\n-\n-/* Parse an Objective-C declaration.  */\n-\n-static void\n-cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  if (attributes)\n-    switch (kwd->keyword)\n-      {\n-\tcase RID_AT_ALIAS:\n-\tcase RID_AT_CLASS:\n-\tcase RID_AT_END:\n-\t  error_at (kwd->location, \"attributes may not be specified before\"\n-\t            \" the %<@%D%> Objective-C++ keyword\",\n-\t\t    kwd->u.value);\n-\t  attributes = NULL;\n-\t  break;\n-\tcase RID_AT_IMPLEMENTATION:\n-\t  warning_at (kwd->location, OPT_Wattributes,\n-\t\t      \"prefix attributes are ignored before %<@%D%>\",\n-\t\t      kwd->u.value);\n-\t  attributes = NULL;\n-\tdefault:\n-\t  break;\n-      }\n-\n-  switch (kwd->keyword)\n-    {\n-    case RID_AT_ALIAS:\n-      cp_parser_objc_alias_declaration (parser);\n-      break;\n-    case RID_AT_CLASS:\n-      cp_parser_objc_class_declaration (parser);\n-      break;\n-    case RID_AT_PROTOCOL:\n-      cp_parser_objc_protocol_declaration (parser, attributes);\n-      break;\n-    case RID_AT_INTERFACE:\n-      cp_parser_objc_class_interface (parser, attributes);\n-      break;\n-    case RID_AT_IMPLEMENTATION:\n-      cp_parser_objc_class_implementation (parser);\n-      break;\n-    case RID_AT_END:\n-      cp_parser_objc_end_implementation (parser);\n-      break;\n-    default:\n-      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n-\t\tkwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-}\n-\n-/* Parse an Objective-C try-catch-finally statement.\n-\n-   objc-try-catch-finally-stmt:\n-     @try compound-statement objc-catch-clause-seq [opt]\n-       objc-finally-clause [opt]\n-\n-   objc-catch-clause-seq:\n-     objc-catch-clause objc-catch-clause-seq [opt]\n-\n-   objc-catch-clause:\n-     @catch ( objc-exception-declaration ) compound-statement\n-\n-   objc-finally-clause:\n-     @finally compound-statement\n-\n-   objc-exception-declaration:\n-     parameter-declaration\n-     '...'\n-\n-   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n-\n-   Returns NULL_TREE.\n-\n-   PS: This function is identical to c_parser_objc_try_catch_finally_statement\n-   for C.  Keep them in sync.  */   \n-\n-static tree\n-cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n-{\n-  location_t location;\n-  tree stmt;\n-\n-  cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);\n-  location = cp_lexer_peek_token (parser->lexer)->location;\n-  objc_maybe_warn_exceptions (location);\n-  /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n-     node, lest it get absorbed into the surrounding block.  */\n-  stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false);\n-  objc_begin_try_stmt (location, pop_stmt_list (stmt));\n-\n-  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n-    {\n-      cp_parameter_declarator *parm;\n-      tree parameter_declaration = error_mark_node;\n-      bool seen_open_paren = false;\n-\n-      cp_lexer_consume_token (parser->lexer);\n-      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n-\tseen_open_paren = true;\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n-\t{\n-\t  /* We have \"@catch (...)\" (where the '...' are literally\n-\t     what is in the code).  Skip the '...'.\n-\t     parameter_declaration is set to NULL_TREE, and\n-\t     objc_being_catch_clauses() knows that that means\n-\t     '...'.  */\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  parameter_declaration = NULL_TREE;\n-\t}\n-      else\n-\t{\n-\t  /* We have \"@catch (NSException *exception)\" or something\n-\t     like that.  Parse the parameter declaration.  */\n-\t  parm = cp_parser_parameter_declaration (parser, false, NULL);\n-\t  if (parm == NULL)\n-\t    parameter_declaration = error_mark_node;\n-\t  else\n-\t    parameter_declaration = grokdeclarator (parm->declarator,\n-\t\t\t\t\t\t    &parm->decl_specifiers,\n-\t\t\t\t\t\t    PARM, /*initialized=*/0,\n-\t\t\t\t\t\t    /*attrlist=*/NULL);\n-\t}\n-      if (seen_open_paren)\n-\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      else\n-\t{\n-\t  /* If there was no open parenthesis, we are recovering from\n-\t     an error, and we are trying to figure out what mistake\n-\t     the user has made.  */\n-\n-\t  /* If there is an immediate closing parenthesis, the user\n-\t     probably forgot the opening one (ie, they typed \"@catch\n-\t     NSException *e)\".  Parse the closing parenthesis and keep\n-\t     going.  */\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t  \n-\t  /* If these is no immediate closing parenthesis, the user\n-\t     probably doesn't know that parenthesis are required at\n-\t     all (ie, they typed \"@catch NSException *e\").  So, just\n-\t     forget about the closing parenthesis and keep going.  */\n-\t}\n-      objc_begin_catch_clause (parameter_declaration);\n-      cp_parser_compound_statement (parser, NULL, false);\n-      objc_finish_catch_clause ();\n-    }\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n-    {\n-      cp_lexer_consume_token (parser->lexer);\n-      location = cp_lexer_peek_token (parser->lexer)->location;\n-      /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n-\t node, lest it get absorbed into the surrounding block.  */\n-      stmt = push_stmt_list ();\n-      cp_parser_compound_statement (parser, NULL, false);\n-      objc_build_finally_clause (location, pop_stmt_list (stmt));\n-    }\n-\n-  return objc_finish_try_stmt ();\n-}\n-\n-/* Parse an Objective-C synchronized statement.\n-\n-   objc-synchronized-stmt:\n-     @synchronized ( expression ) compound-statement\n-\n-   Returns NULL_TREE.  */\n-\n-static tree\n-cp_parser_objc_synchronized_statement (cp_parser *parser)\n-{\n-  location_t location;\n-  tree lock, stmt;\n-\n-  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);\n-\n-  location = cp_lexer_peek_token (parser->lexer)->location;\n-  objc_maybe_warn_exceptions (location);\n-  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n-  lock = cp_parser_expression (parser, false, NULL);\n-  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-\n-  /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n-     node, lest it get absorbed into the surrounding block.  */\n-  stmt = push_stmt_list ();\n-  cp_parser_compound_statement (parser, NULL, false);\n-\n-  return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n-}\n-\n-/* Parse an Objective-C throw statement.\n-\n-   objc-throw-stmt:\n-     @throw assignment-expression [opt] ;\n-\n-   Returns a constructed '@throw' statement.  */\n-\n-static tree\n-cp_parser_objc_throw_statement (cp_parser *parser)\n-{\n-  tree expr = NULL_TREE;\n-  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n-\n-  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n-\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\n-  return objc_build_throw_stmt (loc, expr);\n-}\n-\n-/* Parse an Objective-C statement.  */\n-\n-static tree\n-cp_parser_objc_statement (cp_parser * parser)\n-{\n-  /* Try to figure out what kind of declaration is present.  */\n-  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n-\n-  switch (kwd->keyword)\n-    {\n-    case RID_AT_TRY:\n-      return cp_parser_objc_try_catch_finally_statement (parser);\n-    case RID_AT_SYNCHRONIZED:\n-      return cp_parser_objc_synchronized_statement (parser);\n-    case RID_AT_THROW:\n-      return cp_parser_objc_throw_statement (parser);\n-    default:\n-      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n-\t       kwd->u.value);\n-      cp_parser_skip_to_end_of_block_or_statement (parser);\n-    }\n-\n-  return error_mark_node;\n-}\n-\n-/* If we are compiling ObjC++ and we see an __attribute__ we neeed to \n-   look ahead to see if an objc keyword follows the attributes.  This\n-   is to detect the use of prefix attributes on ObjC @interface and \n-   @protocol.  */\n-\n-static bool\n-cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n-{\n-  cp_lexer_save_tokens (parser->lexer);\n-  *attrib = cp_parser_attributes_opt (parser);\n-  gcc_assert (*attrib);\n-  if (OBJC_IS_AT_KEYWORD (cp_lexer_peek_token (parser->lexer)->keyword))\n-    {\n-      cp_lexer_commit_tokens (parser->lexer);\n-      return true;\n-    }\n-  cp_lexer_rollback_tokens (parser->lexer);\n-  return false;  \n-}\n-\n-/* This routine is a minimal replacement for\n-   c_parser_struct_declaration () used when parsing the list of\n-   types/names or ObjC++ properties.  For example, when parsing the\n-   code\n-\n-   @property (readonly) int a, b, c;\n-\n-   this function is responsible for parsing \"int a, int b, int c\" and\n-   returning the declarations as CHAIN of DECLs.\n-\n-   TODO: Share this code with cp_parser_objc_class_ivars.  It's very\n-   similar parsing.  */\n-static tree\n-cp_parser_objc_struct_declaration (cp_parser *parser)\n-{\n-  tree decls = NULL_TREE;\n-  cp_decl_specifier_seq declspecs;\n-  int decl_class_or_enum_p;\n-  tree prefix_attributes;\n-\n-  cp_parser_decl_specifier_seq (parser,\n-\t\t\t\tCP_PARSER_FLAGS_NONE,\n-\t\t\t\t&declspecs,\n-\t\t\t\t&decl_class_or_enum_p);\n-\n-  if (declspecs.type == error_mark_node)\n-    return error_mark_node;\n-\n-  /* auto, register, static, extern, mutable.  */\n-  if (declspecs.storage_class != sc_none)\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.storage_class = sc_none;\n-    }\n-  \n-  /* __thread.  */\n-  if (declspecs.specs[(int) ds_thread])\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_thread] = 0;\n-    }\n-  \n-  /* typedef.  */\n-  if (declspecs.specs[(int) ds_typedef])\n-    {\n-      cp_parser_error (parser, \"invalid type for property\");\n-      declspecs.specs[(int) ds_typedef] = 0;\n-    }\n-\n-  prefix_attributes = declspecs.attributes;\n-  declspecs.attributes = NULL_TREE;\n-\n-  /* Keep going until we hit the `;' at the end of the declaration. */\n-  while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n-    {\n-      tree attributes, first_attribute, decl;\n-      cp_declarator *declarator;\n-      cp_token *token;\n-\n-      /* Parse the declarator.  */\n-      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n-\t\t\t\t\t NULL, NULL, false);\n-\n-      /* Look for attributes that apply to the ivar.  */\n-      attributes = cp_parser_attributes_opt (parser);\n-      /* Remember which attributes are prefix attributes and\n-\t which are not.  */\n-      first_attribute = attributes;\n-      /* Combine the attributes.  */\n-      attributes = chainon (prefix_attributes, attributes);\n-      \n-      decl = grokfield (declarator, &declspecs,\n-\t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n-\t\t\tNULL_TREE, attributes);\n-\n-      if (decl == error_mark_node || decl == NULL_TREE)\n-\treturn error_mark_node;\n-      \n-      /* Reset PREFIX_ATTRIBUTES.  */\n-      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n-\tattributes = TREE_CHAIN (attributes);\n-      if (attributes)\n-\tTREE_CHAIN (attributes) = NULL_TREE;\n-\n-      DECL_CHAIN (decl) = decls;\n-      decls = decl;\n-\n-      token = cp_lexer_peek_token (parser->lexer);\n-      if (token->type == CPP_COMMA)\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n-\t  continue;\n-\t}\n-      else\n-\tbreak;\n-    }\n-  return decls;\n-}\n-\n-/* Parse an Objective-C @property declaration.  The syntax is:\n-\n-   objc-property-declaration:\n-     '@property' objc-property-attributes[opt] struct-declaration ;\n-\n-   objc-property-attributes:\n-    '(' objc-property-attribute-list ')'\n-\n-   objc-property-attribute-list:\n-     objc-property-attribute\n-     objc-property-attribute-list, objc-property-attribute\n-\n-   objc-property-attribute\n-     'getter' = identifier\n-     'setter' = identifier\n-     'readonly'\n-     'readwrite'\n-     'assign'\n-     'retain'\n-     'copy'\n-     'nonatomic'\n-\n-  For example:\n-    @property NSString *name;\n-    @property (readonly) id object;\n-    @property (retain, nonatomic, getter=getTheName) id name;\n-    @property int a, b, c;\n-\n-   PS: This function is identical to\n-   c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n-static void \n-cp_parser_objc_at_property_declaration (cp_parser *parser)\n-{\n-  /* The following variables hold the attributes of the properties as\n-     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n-     seen.  When we see an attribute, we set them to 'true' (if they\n-     are boolean properties) or to the identifier (if they have an\n-     argument, ie, for getter and setter).  Note that here we only\n-     parse the list of attributes, check the syntax and accumulate the\n-     attributes that we find.  objc_add_property_declaration() will\n-     then process the information.  */\n-  bool property_assign = false;\n-  bool property_copy = false;\n-  tree property_getter_ident = NULL_TREE;\n-  bool property_nonatomic = false;\n-  bool property_readonly = false;\n-  bool property_readwrite = false;\n-  bool property_retain = false;\n-  tree property_setter_ident = NULL_TREE;\n-\n-  /* 'properties' is the list of properties that we read.  Usually a\n-     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n-     are three).  */\n-  tree properties;\n-  location_t loc;\n-\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n-\n-  /* Parse the optional attribute list...  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n-    {\n-      /* Eat the '('.  */\n-      cp_lexer_consume_token (parser->lexer);\n-\n-      while (true)\n-\t{\n-\t  bool syntax_error = false;\n-\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n-      \t  enum rid keyword;\n-\n-\t  if (token->type != CPP_NAME)\n-\t    {\n-\t      cp_parser_error (parser, \"expected identifier\");\n-\t      break;\n-\t    }\n-\t  keyword = C_RID_CODE (token->u.value);\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  switch (keyword)\n-\t    {\n-\t    case RID_ASSIGN:    property_assign = true;    break;\n-\t    case RID_COPY:      property_copy = true;      break;\n-\t    case RID_NONATOMIC: property_nonatomic = true; break;\n-\t    case RID_READONLY:  property_readonly = true;  break;\n-\t    case RID_READWRITE: property_readwrite = true; break;\n-\t    case RID_RETAIN:    property_retain = true;    break;\n-\n-\t    case RID_GETTER:\n-\t    case RID_SETTER:\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n-\t\t{\n-\t\t  if (keyword == RID_GETTER)\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<getter%> attribute)\");\n-\t\t  else\n-\t\t    cp_parser_error (parser,\n-\t\t\t\t     \"missing %<=%> (after %<setter%> attribute)\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n-\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n-\t\t{\n-\t\t  cp_parser_error (parser, \"expected identifier\");\n-\t\t  syntax_error = true;\n-\t\t  break;\n-\t\t}\n-\t      if (keyword == RID_SETTER)\n-\t\t{\n-\t\t  if (property_setter_ident != NULL_TREE)\n-\t\t    cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_setter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n-\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n-\t\t  else\n-\t\t    cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (property_getter_ident != NULL_TREE)\n-\t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n-\t\t  else\n-\t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n-\t\t  cp_lexer_consume_token (parser->lexer);\n-\t\t}\n-\t      break;\n-\t    default:\n-\t      cp_parser_error (parser, \"unknown property attribute\");\n-\t      syntax_error = true;\n-\t      break;\n-\t    }\n-\n-\t  if (syntax_error)\n-\t    break;\n-\n-\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\t    cp_lexer_consume_token (parser->lexer);\n-\t  else\n-\t    break;\n-\t}\n-\n-      /* FIXME: \"@property (setter, assign);\" will generate a spurious\n-\t \"error: expected \u2018)\u2019 before \u2018,\u2019 token\".  This is because\n-\t cp_parser_require, unlike the C counterpart, will produce an\n-\t error even if we are in error recovery.  */\n-      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n-\t{\n-\t  cp_parser_skip_to_closing_parenthesis (parser,\n-\t\t\t\t\t\t /*recovering=*/true,\n-\t\t\t\t\t\t /*or_comma=*/false,\n-\t\t\t\t\t\t /*consume_paren=*/true);\n-\t}\n-    }\n-\n-  /* ... and the property declaration(s).  */\n-  properties = cp_parser_objc_struct_declaration (parser);\n-\n-  if (properties == error_mark_node)\n-    {\n-      cp_parser_skip_to_end_of_statement (parser);\n-      /* If the next token is now a `;', consume it.  */\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n-\tcp_lexer_consume_token (parser->lexer);\n-      return;\n-    }\n-\n-  if (properties == NULL_TREE)\n-    cp_parser_error (parser, \"expected identifier\");\n-  else\n-    {\n-      /* Comma-separated properties are chained together in\n-\t reverse order; add them one by one.  */\n-      properties = nreverse (properties);\n-      \n-      for (; properties; properties = TREE_CHAIN (properties))\n-\tobjc_add_property_declaration (loc, copy_node (properties),\n-\t\t\t\t       property_readonly, property_readwrite,\n-\t\t\t\t       property_assign, property_retain,\n-\t\t\t\t       property_copy, property_nonatomic,\n-\t\t\t\t       property_getter_ident, property_setter_ident);\n-    }\n-  \n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-}\n-\n-/* Parse an Objective-C++ @synthesize declaration.  The syntax is:\n-\n-   objc-synthesize-declaration:\n-     @synthesize objc-synthesize-identifier-list ;\n-\n-   objc-synthesize-identifier-list:\n-     objc-synthesize-identifier\n-     objc-synthesize-identifier-list, objc-synthesize-identifier\n-\n-   objc-synthesize-identifier\n-     identifier\n-     identifier = identifier\n-\n-  For example:\n-    @synthesize MyProperty;\n-    @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;\n-\n-  PS: This function is identical to c_parser_objc_at_synthesize_declaration\n-  for C.  Keep them in sync.\n-*/\n-static void \n-cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n-{\n-  tree list = NULL_TREE;\n-  location_t loc;\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@synthesize'.  */\n-  while (true)\n-    {\n-      tree property, ivar;\n-      property = cp_parser_identifier (parser);\n-      if (property == error_mark_node)\n-\t{\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t  return;\n-\t}\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n-\t{\n-\t  cp_lexer_consume_token (parser->lexer);\n-\t  ivar = cp_parser_identifier (parser);\n-\t  if (ivar == error_mark_node)\n-\t    {\n-\t      cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t      return;\n-\t    }\n-\t}\n-      else\n-\tivar = NULL_TREE;\n-      list = chainon (list, build_tree_list (ivar, property));\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else\n-\tbreak;\n-    }\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-  objc_add_synthesize_declaration (loc, list);\n-}\n-\n-/* Parse an Objective-C++ @dynamic declaration.  The syntax is:\n-\n-   objc-dynamic-declaration:\n-     @dynamic identifier-list ;\n-\n-   For example:\n-     @dynamic MyProperty;\n-     @dynamic MyProperty, AnotherProperty;\n-\n-  PS: This function is identical to c_parser_objc_at_dynamic_declaration\n-  for C.  Keep them in sync.\n-*/\n-static void \n-cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n-{\n-  tree list = NULL_TREE;\n-  location_t loc;\n-  loc = cp_lexer_peek_token (parser->lexer)->location;\n-\n-  cp_lexer_consume_token (parser->lexer);  /* Eat '@dynamic'.  */\n-  while (true)\n-    {\n-      tree property;\n-      property = cp_parser_identifier (parser);\n-      if (property == error_mark_node)\n-\t{\n-\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-\t  return;\n-\t}\n-      list = chainon (list, build_tree_list (NULL, property));\n-      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n-\tcp_lexer_consume_token (parser->lexer);\n-      else\n-\tbreak;\n-    }\n-  cp_parser_consume_semicolon_at_end_of_statement (parser);\n-  objc_add_dynamic_declaration (loc, list);\n-}\n+#include \"../objcp/plugin/parser.c\"\n \n \f\n /* OpenMP 2.5 parsing routines.  */"}, {"sha": "d3bae1c95dc1176f0f99a32f0efe676d7cec89b3", "filename": "gcc/objcp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FChangeLog?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -1,3 +1,9 @@\n+2011-02-12  Mike Stump  <mikestump@comcast.net>\n+\n+\t* Make-lang.in (obj-c++.tags): Plugify Objective-C++.\n+\t* plugin/parser.h: Likewise.\n+\t* plugin/parser.c: Likewise.\n+\n 2011-02-07  Mike Stump  <mikestump@comcast.net>\n \n \t* Make-lang.in (obj-c++.tags): Don't include *.y."}, {"sha": "41950defe9d6f46e817883bb4624a61ce0d126e8", "filename": "gcc/objcp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2FMake-lang.in?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -110,7 +110,7 @@ obj-c++.man:\n obj-c++.install-plugin:\n \n obj-c++.tags: force\n-\tcd $(srcdir)/objcp; etags -o TAGS.sub *.c *.h; \\\n+\tcd $(srcdir)/objcp; etags -o TAGS.sub *.c *.h plugin/*.h plugin/*.c; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n \n lang_checks += check-obj-c++"}, {"sha": "964c69768de53e39f2133023bb3ee9440bd3c9e0", "filename": "gcc/objcp/plugin/parser.c", "status": "added", "additions": 1902, "deletions": 0, "changes": 1902, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2Fplugin%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2Fplugin%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fplugin%2Fparser.c?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -0,0 +1,1902 @@\n+/* Objective-C++ Parser plugin\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n+   2005, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+#ifdef HIDE_OBJC\n+\n+/* Objective-C++ Productions */\n+\n+\n+/* Parse an Objective-C expression, which feeds into a primary-expression\n+   above.\n+\n+   objc-expression:\n+     objc-message-expression\n+     objc-string-literal\n+     objc-encode-expression\n+     objc-protocol-expression\n+     objc-selector-expression\n+\n+  Returns a tree representation of the expression.  */\n+\n+static tree\n+cp_parser_objc_expression (cp_parser* parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->type)\n+    {\n+    case CPP_OPEN_SQUARE:\n+      return cp_parser_objc_message_expression (parser);\n+\n+    case CPP_OBJC_STRING:\n+      kwd = cp_lexer_consume_token (parser->lexer);\n+      return objc_build_string_object (kwd->u.value);\n+\n+    case CPP_KEYWORD:\n+      switch (kwd->keyword)\n+\t{\n+\tcase RID_AT_ENCODE:\n+\t  return cp_parser_objc_encode_expression (parser);\n+\n+\tcase RID_AT_PROTOCOL:\n+\t  return cp_parser_objc_protocol_expression (parser);\n+\n+\tcase RID_AT_SELECTOR:\n+\t  return cp_parser_objc_selector_expression (parser);\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    default:\n+      error_at (kwd->location,\n+\t\t\"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* Parse an Objective-C message expression.\n+\n+   objc-message-expression:\n+     [ objc-message-receiver objc-message-args ]\n+\n+   Returns a representation of an Objective-C message.  */\n+\n+static tree\n+cp_parser_objc_message_expression (cp_parser* parser)\n+{\n+  tree receiver, messageargs;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '['.  */\n+  receiver = cp_parser_objc_message_receiver (parser);\n+  messageargs = cp_parser_objc_message_args (parser);\n+  cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n+\n+  return objc_build_message_expr (build_tree_list (receiver, messageargs));\n+}\n+\n+/* Parse an objc-message-receiver.\n+\n+   objc-message-receiver:\n+     expression\n+     simple-type-specifier\n+\n+  Returns a representation of the type or expression.  */\n+\n+static tree\n+cp_parser_objc_message_receiver (cp_parser* parser)\n+{\n+  tree rcv;\n+\n+  /* An Objective-C message receiver may be either (1) a type\n+     or (2) an expression.  */\n+  cp_parser_parse_tentatively (parser);\n+  rcv = cp_parser_expression (parser, false, NULL);\n+\n+  if (cp_parser_parse_definitely (parser))\n+    return rcv;\n+\n+  rcv = cp_parser_simple_type_specifier (parser,\n+\t\t\t\t\t /*decl_specs=*/NULL,\n+\t\t\t\t\t CP_PARSER_FLAGS_NONE);\n+\n+  return objc_get_class_reference (rcv);\n+}\n+\n+/* Parse the arguments and selectors comprising an Objective-C message.\n+\n+   objc-message-args:\n+     objc-selector\n+     objc-selector-args\n+     objc-selector-args , objc-comma-args\n+\n+   objc-selector-args:\n+     objc-selector [opt] : assignment-expression\n+     objc-selector-args objc-selector [opt] : assignment-expression\n+\n+   objc-comma-args:\n+     assignment-expression\n+     objc-comma-args , assignment-expression\n+\n+   Returns a TREE_LIST, with TREE_PURPOSE containing a list of\n+   selector arguments and TREE_VALUE containing a list of comma\n+   arguments.  */\n+\n+static tree\n+cp_parser_objc_message_args (cp_parser* parser)\n+{\n+  tree sel_args = NULL_TREE, addl_args = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, arg;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\treturn build_tree_list (selector, NULL_TREE);\n+\n+      maybe_unary_selector_p = false;\n+      cp_parser_require (parser, CPP_COLON, RT_COLON);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n+\n+      sel_args\n+\t= chainon (sel_args,\n+\t\t   build_tree_list (selector, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  /* Handle non-selector arguments, if any. */\n+  while (token->type == CPP_COMMA)\n+    {\n+      tree arg;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      arg = cp_parser_assignment_expression (parser, false, NULL);\n+\n+      addl_args\n+\t= chainon (addl_args,\n+\t\t   build_tree_list (NULL_TREE, arg));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (sel_args == NULL_TREE && addl_args == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ message argument(s) are expected\");\n+      return build_tree_list (error_mark_node, error_mark_node);\n+    }\n+\n+  return build_tree_list (sel_args, addl_args);\n+}\n+\n+/* Parse an Objective-C encode expression.\n+\n+   objc-encode-expression:\n+     @encode objc-typename\n+\n+   Returns an encoded representation of the type argument.  */\n+\n+static tree\n+cp_parser_objc_encode_expression (cp_parser* parser)\n+{\n+  tree type;\n+  cp_token *token;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@encode'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  token = cp_lexer_peek_token (parser->lexer);\n+  type = complete_type (cp_parser_type_id (parser));\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  if (!type)\n+    {\n+      error_at (token->location, \n+\t\t\"%<@encode%> must specify a type as an argument\");\n+      return error_mark_node;\n+    }\n+\n+  /* This happens if we find @encode(T) (where T is a template\n+     typename or something dependent on a template typename) when\n+     parsing a template.  In that case, we can't compile it\n+     immediately, but we rather create an AT_ENCODE_EXPR which will\n+     need to be instantiated when the template is used.\n+  */\n+  if (dependent_type_p (type))\n+    {\n+      tree value = build_min (AT_ENCODE_EXPR, size_type_node, type);\n+      TREE_READONLY (value) = 1;\n+      return value;\n+    }\n+\n+  return objc_build_encode_expr (type);\n+}\n+\n+/* Parse an Objective-C @defs expression.  */\n+\n+static tree\n+cp_parser_objc_defs_expression (cp_parser *parser)\n+{\n+  tree name;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@defs'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  name = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_get_class_ivars (name);\n+}\n+\n+/* Parse an Objective-C protocol expression.\n+\n+  objc-protocol-expression:\n+    @protocol ( identifier )\n+\n+  Returns a representation of the protocol expression.  */\n+\n+static tree\n+cp_parser_objc_protocol_expression (cp_parser* parser)\n+{\n+  tree proto;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  proto = cp_parser_identifier (parser);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_build_protocol_expr (proto);\n+}\n+\n+/* Parse an Objective-C selector expression.\n+\n+   objc-selector-expression:\n+     @selector ( objc-method-signature )\n+\n+   objc-method-signature:\n+     objc-selector\n+     objc-selector-seq\n+\n+   objc-selector-seq:\n+     objc-selector :\n+     objc-selector-seq objc-selector :\n+\n+  Returns a representation of the method selector.  */\n+\n+static tree\n+cp_parser_objc_selector_expression (cp_parser* parser)\n+{\n+  tree sel_seq = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@selector'.  */\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON\n+\t || token->type == CPP_SCOPE)\n+    {\n+      tree selector = NULL_TREE;\n+\n+      if (token->type != CPP_COLON\n+\t  || token->type == CPP_SCOPE)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON)\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n+\t{\n+\t  /* Detect if we have a unary selector.  */\n+\t  if (maybe_unary_selector_p)\n+\t    {\n+\t      sel_seq = selector;\n+\t      goto finish_selector;\n+\t    }\n+\t  else\n+\t    {\n+\t      cp_parser_error (parser, \"expected %<:%>\");\n+\t    }\n+\t}\n+      maybe_unary_selector_p = false;\n+      token = cp_lexer_consume_token (parser->lexer);\n+\n+      if (token->type == CPP_SCOPE)\n+\t{\n+\t  sel_seq\n+\t    = chainon (sel_seq,\n+\t\t       build_tree_list (selector, NULL_TREE));\n+\t  sel_seq\n+\t    = chainon (sel_seq,\n+\t\t       build_tree_list (NULL_TREE, NULL_TREE));\n+\t}\n+      else\n+\tsel_seq\n+\t  = chainon (sel_seq,\n+\t\t     build_tree_list (selector, NULL_TREE));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+ finish_selector:\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  return objc_build_selector_expr (loc, sel_seq);\n+}\n+\n+/* Parse a list of identifiers.\n+\n+   objc-identifier-list:\n+     identifier\n+     objc-identifier-list , identifier\n+\n+   Returns a TREE_LIST of identifier nodes.  */\n+\n+static tree\n+cp_parser_objc_identifier_list (cp_parser* parser)\n+{\n+  tree identifier;\n+  tree list;\n+  cp_token *sep;\n+\n+  identifier = cp_parser_identifier (parser);\n+  if (identifier == error_mark_node)\n+    return error_mark_node;      \n+\n+  list = build_tree_list (NULL_TREE, identifier);\n+  sep = cp_lexer_peek_token (parser->lexer);\n+\n+  while (sep->type == CPP_COMMA)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      identifier = cp_parser_identifier (parser);\n+      if (identifier == error_mark_node)\n+\treturn list;\n+\n+      list = chainon (list, build_tree_list (NULL_TREE,\n+\t\t\t\t\t     identifier));\n+      sep = cp_lexer_peek_token (parser->lexer);\n+    }\n+  \n+  return list;\n+}\n+\n+/* Parse an Objective-C alias declaration.\n+\n+   objc-alias-declaration:\n+     @compatibility_alias identifier identifier ;\n+\n+   This function registers the alias mapping with the Objective-C front end.\n+   It returns nothing.  */\n+\n+static void\n+cp_parser_objc_alias_declaration (cp_parser* parser)\n+{\n+  tree alias, orig;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@compatibility_alias'.  */\n+  alias = cp_parser_identifier (parser);\n+  orig = cp_parser_identifier (parser);\n+  objc_declare_alias (alias, orig);\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse an Objective-C class forward-declaration.\n+\n+   objc-class-declaration:\n+     @class objc-identifier-list ;\n+\n+   The function registers the forward declarations with the Objective-C\n+   front end.  It returns nothing.  */\n+\n+static void\n+cp_parser_objc_class_declaration (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@class'.  */\n+  objc_declare_class (cp_parser_objc_identifier_list (parser));\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse a list of Objective-C protocol references.\n+\n+   objc-protocol-refs-opt:\n+     objc-protocol-refs [opt]\n+\n+   objc-protocol-refs:\n+     < objc-identifier-list >\n+\n+   Returns a TREE_LIST of identifiers, if any.  */\n+\n+static tree\n+cp_parser_objc_protocol_refs_opt (cp_parser* parser)\n+{\n+  tree protorefs = NULL_TREE;\n+\n+  if(cp_lexer_next_token_is (parser->lexer, CPP_LESS))\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '<'.  */\n+      protorefs = cp_parser_objc_identifier_list (parser);\n+      cp_parser_require (parser, CPP_GREATER, RT_GREATER);\n+    }\n+\n+  return protorefs;\n+}\n+\n+/* Parse a Objective-C visibility specification.  */\n+\n+static void\n+cp_parser_objc_visibility_spec (cp_parser* parser)\n+{\n+  cp_token *vis = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (vis->keyword)\n+    {\n+    case RID_AT_PRIVATE:\n+      objc_set_visibility (OBJC_IVAR_VIS_PRIVATE);\n+      break;\n+    case RID_AT_PROTECTED:\n+      objc_set_visibility (OBJC_IVAR_VIS_PROTECTED);\n+      break;\n+    case RID_AT_PUBLIC:\n+      objc_set_visibility (OBJC_IVAR_VIS_PUBLIC);\n+      break;\n+    case RID_AT_PACKAGE:\n+      objc_set_visibility (OBJC_IVAR_VIS_PACKAGE);\n+      break;\n+    default:\n+      return;\n+    }\n+\n+  /* Eat '@private'/'@protected'/'@public'.  */\n+  cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C method type.  Return 'true' if it is a class\n+   (+) method, and 'false' if it is an instance (-) method.  */\n+\n+static inline bool\n+cp_parser_objc_method_type (cp_parser* parser)\n+{\n+  if (cp_lexer_consume_token (parser->lexer)->type == CPP_PLUS)\n+    return true;\n+  else\n+    return false;\n+}\n+\n+/* Parse an Objective-C protocol qualifier.  */\n+\n+static tree\n+cp_parser_objc_protocol_qualifiers (cp_parser* parser)\n+{\n+  tree quals = NULL_TREE, node;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  node = token->u.value;\n+\n+  while (node && TREE_CODE (node) == IDENTIFIER_NODE\n+\t && (node == ridpointers [(int) RID_IN]\n+\t     || node == ridpointers [(int) RID_OUT]\n+\t     || node == ridpointers [(int) RID_INOUT]\n+\t     || node == ridpointers [(int) RID_BYCOPY]\n+\t     || node == ridpointers [(int) RID_BYREF]\n+\t     || node == ridpointers [(int) RID_ONEWAY]))\n+    {\n+      quals = tree_cons (NULL_TREE, node, quals);\n+      cp_lexer_consume_token (parser->lexer);\n+      token = cp_lexer_peek_token (parser->lexer);\n+      node = token->u.value;\n+    }\n+\n+  return quals;\n+}\n+\n+/* Parse an Objective-C typename.  */\n+\n+static tree\n+cp_parser_objc_typename (cp_parser* parser)\n+{\n+  tree type_name = NULL_TREE;\n+\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      tree proto_quals, cp_type = NULL_TREE;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+      proto_quals = cp_parser_objc_protocol_qualifiers (parser);\n+\n+      /* An ObjC type name may consist of just protocol qualifiers, in which\n+\t case the type shall default to 'id'.  */\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  cp_type = cp_parser_type_id (parser);\n+\t  \n+\t  /* If the type could not be parsed, an error has already\n+\t     been produced.  For error recovery, behave as if it had\n+\t     not been specified, which will use the default type\n+\t     'id'.  */\n+\t  if (cp_type == error_mark_node)\n+\t    {\n+\t      cp_type = NULL_TREE;\n+\t      /* We need to skip to the closing parenthesis as\n+\t\t cp_parser_type_id() does not seem to do it for\n+\t\t us.  */\n+\t      cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t     /*recovering=*/true,\n+\t\t\t\t\t\t     /*or_comma=*/false,\n+\t\t\t\t\t\t     /*consume_paren=*/false);\n+\t    }\n+\t}\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      type_name = build_tree_list (proto_quals, cp_type);\n+    }\n+\n+  return type_name;\n+}\n+\n+/* Check to see if TYPE refers to an Objective-C selector name.  */\n+\n+static bool\n+cp_parser_objc_selector_p (enum cpp_ttype type)\n+{\n+  return (type == CPP_NAME || type == CPP_KEYWORD\n+\t  || type == CPP_AND_AND || type == CPP_AND_EQ || type == CPP_AND\n+\t  || type == CPP_OR || type == CPP_COMPL || type == CPP_NOT\n+\t  || type == CPP_NOT_EQ || type == CPP_OR_OR || type == CPP_OR_EQ\n+\t  || type == CPP_XOR || type == CPP_XOR_EQ);\n+}\n+\n+/* Parse an Objective-C selector.  */\n+\n+static tree\n+cp_parser_objc_selector (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_consume_token (parser->lexer);\n+\n+  if (!cp_parser_objc_selector_p (token->type))\n+    {\n+      error_at (token->location, \"invalid Objective-C++ selector name\");\n+      return error_mark_node;\n+    }\n+\n+  /* C++ operator names are allowed to appear in ObjC selectors.  */\n+  switch (token->type)\n+    {\n+    case CPP_AND_AND: return get_identifier (\"and\");\n+    case CPP_AND_EQ: return get_identifier (\"and_eq\");\n+    case CPP_AND: return get_identifier (\"bitand\");\n+    case CPP_OR: return get_identifier (\"bitor\");\n+    case CPP_COMPL: return get_identifier (\"compl\");\n+    case CPP_NOT: return get_identifier (\"not\");\n+    case CPP_NOT_EQ: return get_identifier (\"not_eq\");\n+    case CPP_OR_OR: return get_identifier (\"or\");\n+    case CPP_OR_EQ: return get_identifier (\"or_eq\");\n+    case CPP_XOR: return get_identifier (\"xor\");\n+    case CPP_XOR_EQ: return get_identifier (\"xor_eq\");\n+    default: return token->u.value;\n+    }\n+}\n+\n+/* Parse an Objective-C params list.  */\n+\n+static tree\n+cp_parser_objc_method_keyword_params (cp_parser* parser, tree* attributes)\n+{\n+  tree params = NULL_TREE;\n+  bool maybe_unary_selector_p = true;\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (cp_parser_objc_selector_p (token->type) || token->type == CPP_COLON)\n+    {\n+      tree selector = NULL_TREE, type_name, identifier;\n+      tree parm_attr = NULL_TREE;\n+\n+      if (token->keyword == RID_ATTRIBUTE)\n+\tbreak;\n+\n+      if (token->type != CPP_COLON)\n+\tselector = cp_parser_objc_selector (parser);\n+\n+      /* Detect if we have a unary selector.  */\n+      if (maybe_unary_selector_p\n+\t  && cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t{\n+\t  params = selector; /* Might be followed by attributes.  */\n+\t  break;\n+\t}\n+\n+      maybe_unary_selector_p = false;\n+      if (!cp_parser_require (parser, CPP_COLON, RT_COLON))\n+\t{\n+\t  /* Something went quite wrong.  There should be a colon\n+\t     here, but there is not.  Stop parsing parameters.  */\n+\t  break;\n+\t}\n+      type_name = cp_parser_objc_typename (parser);\n+      /* New ObjC allows attributes on parameters too.  */\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_ATTRIBUTE))\n+\tparm_attr = cp_parser_attributes_opt (parser);\n+      identifier = cp_parser_identifier (parser);\n+\n+      params\n+\t= chainon (params,\n+\t\t   objc_build_keyword_decl (selector,\n+\t\t\t\t\t    type_name,\n+\t\t\t\t\t    identifier,\n+\t\t\t\t\t    parm_attr));\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (params == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n+      return error_mark_node;\n+    }\n+\n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      *attributes = cp_parser_attributes_opt (parser);\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t  || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\treturn params;\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n+  if (params == NULL_TREE)\n+    {\n+      cp_parser_error (parser, \"objective-c++ method declaration is expected\");\n+      return error_mark_node;\n+    }\n+  return params;\n+}\n+\n+/* Parse the non-keyword Objective-C params.  */\n+\n+static tree\n+cp_parser_objc_method_tail_params_opt (cp_parser* parser, bool *ellipsisp, \n+\t\t\t\t       tree* attributes)\n+{\n+  tree params = make_node (TREE_LIST);\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+  *ellipsisp = false;  /* Initially, assume no ellipsis.  */\n+\n+  while (token->type == CPP_COMMA)\n+    {\n+      cp_parameter_declarator *parmdecl;\n+      tree parm;\n+\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+      token = cp_lexer_peek_token (parser->lexer);\n+\n+      if (token->type == CPP_ELLIPSIS)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat '...'.  */\n+\t  *ellipsisp = true;\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  break;\n+\t}\n+\n+      /* TODO: parse attributes for tail parameters.  */\n+      parmdecl = cp_parser_parameter_declaration (parser, false, NULL);\n+      parm = grokdeclarator (parmdecl->declarator,\n+\t\t\t     &parmdecl->decl_specifiers,\n+\t\t\t     PARM, /*initialized=*/0,\n+\t\t\t     /*attrlist=*/NULL);\n+\n+      chainon (params, build_tree_list (NULL_TREE, parm));\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  /* We allow tail attributes for the method.  */\n+  if (token->keyword == RID_ATTRIBUTE)\n+    {\n+      if (*attributes == NULL_TREE)\n+\t{\n+\t  *attributes = cp_parser_attributes_opt (parser);\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON)\n+\t      || cp_lexer_next_token_is (parser->lexer, CPP_OPEN_BRACE))\n+\t    return params;\n+\t}\n+      else        \n+\t/* We have an error, but parse the attributes, so that we can \n+\t   carry on.  */\n+\t*attributes = cp_parser_attributes_opt (parser);\n+\n+      cp_parser_error (parser, \n+\t\t       \"method attributes must be specified at the end\");\n+      return error_mark_node;\n+    }\n+\n+  return params;\n+}\n+\n+/* Parse a linkage specification, a pragma, an extra semicolon or a block.  */\n+\n+static void\n+cp_parser_objc_interstitial_code (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  /* If the next token is `extern' and the following token is a string\n+     literal, then we have a linkage specification.  */\n+  if (token->keyword == RID_EXTERN\n+      && cp_parser_is_string_literal (cp_lexer_peek_nth_token (parser->lexer, 2)))\n+    cp_parser_linkage_specification (parser);\n+  /* Handle #pragma, if any.  */\n+  else if (token->type == CPP_PRAGMA)\n+    cp_parser_pragma (parser, pragma_external);\n+  /* Allow stray semicolons.  */\n+  else if (token->type == CPP_SEMICOLON)\n+    cp_lexer_consume_token (parser->lexer);\n+  /* Mark methods as optional or required, when building protocols.  */\n+  else if (token->keyword == RID_AT_OPTIONAL)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      objc_set_method_opt (true);\n+    }\n+  else if (token->keyword == RID_AT_REQUIRED)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      objc_set_method_opt (false);\n+    }\n+  else if (token->keyword == RID_NAMESPACE)\n+    cp_parser_namespace_definition (parser);\n+  /* Other stray characters must generate errors.  */\n+  else if (token->type == CPP_OPEN_BRACE || token->type == CPP_CLOSE_BRACE)\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      error (\"stray %qs between Objective-C++ methods\",\n+\t     token->type == CPP_OPEN_BRACE ? \"{\" : \"}\");\n+    }\n+  /* Finally, try to parse a block-declaration, or a function-definition.  */\n+  else\n+    cp_parser_block_declaration (parser, /*statement_p=*/false);\n+}\n+\n+/* Parse a method signature.  */\n+\n+static tree\n+cp_parser_objc_method_signature (cp_parser* parser, tree* attributes)\n+{\n+  tree rettype, kwdparms, optparms;\n+  bool ellipsis = false;\n+  bool is_class_method;\n+\n+  is_class_method = cp_parser_objc_method_type (parser);\n+  rettype = cp_parser_objc_typename (parser);\n+  *attributes = NULL_TREE;\n+  kwdparms = cp_parser_objc_method_keyword_params (parser, attributes);\n+  if (kwdparms == error_mark_node)\n+    return error_mark_node;\n+  optparms = cp_parser_objc_method_tail_params_opt (parser, &ellipsis, attributes);\n+  if (optparms == error_mark_node)\n+    return error_mark_node;\n+\n+  return objc_build_method_signature (is_class_method, rettype, kwdparms, optparms, ellipsis);\n+}\n+\n+static bool\n+cp_parser_objc_method_maybe_bad_prefix_attributes (cp_parser* parser)\n+{\n+  tree tattr;  \n+  cp_lexer_save_tokens (parser->lexer);\n+  tattr = cp_parser_attributes_opt (parser);\n+  gcc_assert (tattr) ;\n+  \n+  /* If the attributes are followed by a method introducer, this is not allowed.\n+     Dump the attributes and flag the situation.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_PLUS)\n+      || cp_lexer_next_token_is (parser->lexer, CPP_MINUS))\n+    return true;\n+\n+  /* Otherwise, the attributes introduce some interstitial code, possibly so\n+     rewind to allow that check.  */\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return false;  \n+}\n+\n+/* Parse an Objective-C method prototype list.  */\n+\n+static void\n+cp_parser_objc_method_prototype_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  tree attributes, sig;\n+\t  bool is_class_method;\n+\t  if (token->type == CPP_PLUS)\n+\t    is_class_method = true;\n+\t  else\n+\t    is_class_method = false;\n+\t  sig = cp_parser_objc_method_signature (parser, &attributes);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      continue;\n+\t    }\n+\t  objc_add_method_declaration (is_class_method, sig, attributes);\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t}\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property_declaration (parser);\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (cp_lexer_peek_token (parser->lexer)->location, \n+\t\t    OPT_Wattributes, \n+\t\t    \"prefix attributes are ignored for methods\");\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  else\n+    cp_parser_error (parser, \"expected %<@end%>\");\n+\n+  objc_finish_interface ();\n+}\n+\n+/* Parse an Objective-C method definition list.  */\n+\n+static void\n+cp_parser_objc_method_definition_list (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      tree meth;\n+\n+      if (token->type == CPP_PLUS || token->type == CPP_MINUS)\n+\t{\n+\t  cp_token *ptk;\n+\t  tree sig, attribute;\n+\t  bool is_class_method;\n+\t  if (token->type == CPP_PLUS)\n+\t    is_class_method = true;\n+\t  else\n+\t    is_class_method = false;\n+\t  push_deferring_access_checks (dk_deferred);\n+\t  sig = cp_parser_objc_method_signature (parser, &attribute);\n+\t  if (sig == error_mark_node)\n+\t    {\n+\t      cp_parser_skip_to_end_of_block_or_statement (parser);\n+\t      token = cp_lexer_peek_token (parser->lexer);\n+\t      continue;\n+\t    }\n+\t  objc_start_method_definition (is_class_method, sig, attribute);\n+\n+\t  /* For historical reasons, we accept an optional semicolon.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\n+\t  ptk = cp_lexer_peek_token (parser->lexer);\n+\t  if (!(ptk->type == CPP_PLUS || ptk->type == CPP_MINUS \n+\t\t|| ptk->type == CPP_EOF || ptk->keyword == RID_AT_END))\n+\t    {\n+\t      perform_deferred_access_checks ();\n+\t      stop_deferring_access_checks ();\n+\t      meth = cp_parser_function_definition_after_declarator (parser,\n+\t\t\t\t\t\t\t\t     false);\n+\t      pop_deferring_access_checks ();\n+\t      objc_finish_method_definition (meth);\n+\t    }\n+\t}\n+      /* The following case will be removed once @synthesize is\n+\t completely implemented.  */\n+      else if (token->keyword == RID_AT_PROPERTY)\n+\tcp_parser_objc_at_property_declaration (parser);\n+      else if (token->keyword == RID_AT_SYNTHESIZE)\n+\tcp_parser_objc_at_synthesize_declaration (parser);\n+      else if (token->keyword == RID_AT_DYNAMIC)\n+\tcp_parser_objc_at_dynamic_declaration (parser);\n+      else if (token->keyword == RID_ATTRIBUTE \n+      \t       && cp_parser_objc_method_maybe_bad_prefix_attributes(parser))\n+\twarning_at (token->location, OPT_Wattributes,\n+\t       \t    \"prefix attributes are ignored for methods\");\n+      else\n+\t/* Allow for interspersed non-ObjC++ code.  */\n+\tcp_parser_objc_interstitial_code (parser);\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  else\n+    cp_parser_error (parser, \"expected %<@end%>\");\n+\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse Objective-C ivars.  */\n+\n+static void\n+cp_parser_objc_class_ivars (cp_parser* parser)\n+{\n+  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+\n+  if (token->type != CPP_OPEN_BRACE)\n+    return;\t/* No ivars specified.  */\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '{'.  */\n+  token = cp_lexer_peek_token (parser->lexer);\n+\n+  while (token->type != CPP_CLOSE_BRACE \n+\t&& token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    {\n+      cp_decl_specifier_seq declspecs;\n+      int decl_class_or_enum_p;\n+      tree prefix_attributes;\n+\n+      cp_parser_objc_visibility_spec (parser);\n+\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_BRACE))\n+\tbreak;\n+\n+      cp_parser_decl_specifier_seq (parser,\n+\t\t\t\t    CP_PARSER_FLAGS_OPTIONAL,\n+\t\t\t\t    &declspecs,\n+\t\t\t\t    &decl_class_or_enum_p);\n+\n+      /* auto, register, static, extern, mutable.  */\n+      if (declspecs.storage_class != sc_none)\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\t  \n+\t  declspecs.storage_class = sc_none;\n+\t}\n+\n+      /* __thread.  */\n+      if (declspecs.specs[(int) ds_thread])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_thread] = 0;\n+\t}\n+      \n+      /* typedef.  */\n+      if (declspecs.specs[(int) ds_typedef])\n+\t{\n+\t  cp_parser_error (parser, \"invalid type for instance variable\");\n+\t  declspecs.specs[(int) ds_typedef] = 0;\n+\t}\n+\n+      prefix_attributes = declspecs.attributes;\n+      declspecs.attributes = NULL_TREE;\n+\n+      /* Keep going until we hit the `;' at the end of the\n+\t declaration.  */\n+      while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+\t{\n+\t  tree width = NULL_TREE, attributes, first_attribute, decl;\n+\t  cp_declarator *declarator = NULL;\n+\t  int ctor_dtor_or_conv_p;\n+\n+\t  /* Check for a (possibly unnamed) bitfield declaration.  */\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\t  if (token->type == CPP_COLON)\n+\t    goto eat_colon;\n+\n+\t  if (token->type == CPP_NAME\n+\t      && (cp_lexer_peek_nth_token (parser->lexer, 2)->type\n+\t\t  == CPP_COLON))\n+\t    {\n+\t      /* Get the name of the bitfield.  */\n+\t      declarator = make_id_declarator (NULL_TREE,\n+\t\t\t\t\t       cp_parser_identifier (parser),\n+\t\t\t\t\t       sfk_none);\n+\n+\t     eat_colon:\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+\t      /* Get the width of the bitfield.  */\n+\t      width\n+\t\t= cp_parser_constant_expression (parser,\n+\t\t\t\t\t\t /*allow_non_constant=*/false,\n+\t\t\t\t\t\t NULL);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Parse the declarator.  */\n+\t      declarator\n+\t\t= cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t&ctor_dtor_or_conv_p,\n+\t\t\t\t\t/*parenthesized_p=*/NULL,\n+\t\t\t\t\t/*member_p=*/false);\n+\t    }\n+\n+\t  /* Look for attributes that apply to the ivar.  */\n+\t  attributes = cp_parser_attributes_opt (parser);\n+\t  /* Remember which attributes are prefix attributes and\n+\t     which are not.  */\n+\t  first_attribute = attributes;\n+\t  /* Combine the attributes.  */\n+\t  attributes = chainon (prefix_attributes, attributes);\n+\n+\t  if (width)\n+\t      /* Create the bitfield declaration.  */\n+\t      decl = grokbitfield (declarator, &declspecs,\n+\t\t\t\t   width,\n+\t\t\t\t   attributes);\n+\t  else\n+\t    decl = grokfield (declarator, &declspecs,\n+\t\t\t      NULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\t      NULL_TREE, attributes);\n+\n+\t  /* Add the instance variable.  */\n+\t  objc_add_instance_variable (decl);\n+\n+\t  /* Reset PREFIX_ATTRIBUTES.  */\n+\t  while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\t    attributes = TREE_CHAIN (attributes);\n+\t  if (attributes)\n+\t    TREE_CHAIN (attributes) = NULL_TREE;\n+\n+\t  token = cp_lexer_peek_token (parser->lexer);\n+\n+\t  if (token->type == CPP_COMMA)\n+\t    {\n+\t      cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+      token = cp_lexer_peek_token (parser->lexer);\n+    }\n+\n+  if (token->keyword == RID_AT_END)\n+    cp_parser_error (parser, \"expected %<}%>\");\n+\n+  /* Do not consume the RID_AT_END, so it will be read again as terminating\n+     the @interface of @implementation.  */ \n+  if (token->keyword != RID_AT_END && token->type != CPP_EOF)\n+    cp_lexer_consume_token (parser->lexer);  /* Eat '}'.  */\n+    \n+  /* For historical reasons, we accept an optional semicolon.  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+    cp_lexer_consume_token (parser->lexer);\n+}\n+\n+/* Parse an Objective-C protocol declaration.  */\n+\n+static void\n+cp_parser_objc_protocol_declaration (cp_parser* parser, tree attributes)\n+{\n+  tree proto, protorefs;\n+  cp_token *tok;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@protocol'.  */\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+    {\n+      tok = cp_lexer_peek_token (parser->lexer);\n+      error_at (tok->location, \"identifier expected after %<@protocol%>\");\n+      goto finish;\n+    }\n+\n+  /* See if we have a forward declaration or a definition.  */\n+  tok = cp_lexer_peek_nth_token (parser->lexer, 2);\n+\n+  /* Try a forward declaration first.  */\n+  if (tok->type == CPP_COMMA || tok->type == CPP_SEMICOLON)\n+    {\n+      objc_declare_protocols (cp_parser_objc_identifier_list (parser), \n+\t\t\t      attributes);\n+     finish:\n+      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+    }\n+\n+  /* Ok, we got a full-fledged definition (or at least should).  */\n+  else\n+    {\n+      proto = cp_parser_identifier (parser);\n+      protorefs = cp_parser_objc_protocol_refs_opt (parser);\n+      objc_start_protocol (proto, protorefs, attributes);\n+      cp_parser_objc_method_prototype_list (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C superclass or category.  */\n+\n+static void\n+cp_parser_objc_superclass_or_category (cp_parser *parser, \n+\t\t\t\t       bool iface_p,\n+\t\t\t\t       tree *super,\n+\t\t\t\t       tree *categ, bool *is_class_extension)\n+{\n+  cp_token *next = cp_lexer_peek_token (parser->lexer);\n+\n+  *super = *categ = NULL_TREE;\n+  *is_class_extension = false;\n+  if (next->type == CPP_COLON)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat ':'.  */\n+      *super = cp_parser_identifier (parser);\n+    }\n+  else if (next->type == CPP_OPEN_PAREN)\n+    {\n+      cp_lexer_consume_token (parser->lexer);  /* Eat '('.  */\n+\n+      /* If there is no category name, and this is an @interface, we\n+\t have a class extension.  */\n+      if (iface_p && cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t{\n+\t  *categ = NULL_TREE;\n+\t  *is_class_extension = true;\n+\t}\n+      else\n+\t*categ = cp_parser_identifier (parser);\n+\n+      cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+    }\n+}\n+\n+/* Parse an Objective-C class interface.  */\n+\n+static void\n+cp_parser_objc_class_interface (cp_parser* parser, tree attributes)\n+{\n+  tree name, super, categ, protos;\n+  bool is_class_extension;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@interface'.  */\n+  name = cp_parser_identifier (parser);\n+  if (name == error_mark_node)\n+    {\n+      /* It's hard to recover because even if valid @interface stuff\n+\t is to follow, we can't compile it (or validate it) if we\n+\t don't even know which class it refers to.  Let's assume this\n+\t was a stray '@interface' token in the stream and skip it.\n+      */\n+      return;\n+    }\n+  cp_parser_objc_superclass_or_category (parser, true, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n+  protos = cp_parser_objc_protocol_refs_opt (parser);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ || is_class_extension)\n+    objc_start_category_interface (name, categ, protos, attributes);\n+  else\n+    {\n+      objc_start_class_interface (name, super, protos, attributes);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_interface ();\n+    }\n+\n+  cp_parser_objc_method_prototype_list (parser);\n+}\n+\n+/* Parse an Objective-C class implementation.  */\n+\n+static void\n+cp_parser_objc_class_implementation (cp_parser* parser)\n+{\n+  tree name, super, categ;\n+  bool is_class_extension;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@implementation'.  */\n+  name = cp_parser_identifier (parser);\n+  if (name == error_mark_node)\n+    {\n+      /* It's hard to recover because even if valid @implementation\n+\t stuff is to follow, we can't compile it (or validate it) if\n+\t we don't even know which class it refers to.  Let's assume\n+\t this was a stray '@implementation' token in the stream and\n+\t skip it.\n+      */\n+      return;\n+    }\n+  cp_parser_objc_superclass_or_category (parser, false, &super, &categ,\n+\t\t\t\t\t &is_class_extension);\n+\n+  /* We have either a class or a category on our hands.  */\n+  if (categ)\n+    objc_start_category_implementation (name, categ);\n+  else\n+    {\n+      objc_start_class_implementation (name, super);\n+      /* Handle instance variable declarations, if any.  */\n+      cp_parser_objc_class_ivars (parser);\n+      objc_continue_implementation ();\n+    }\n+\n+  cp_parser_objc_method_definition_list (parser);\n+}\n+\n+/* Consume the @end token and finish off the implementation.  */\n+\n+static void\n+cp_parser_objc_end_implementation (cp_parser* parser)\n+{\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@end'.  */\n+  objc_finish_implementation ();\n+}\n+\n+/* Parse an Objective-C declaration.  */\n+\n+static void\n+cp_parser_objc_declaration (cp_parser* parser, tree attributes)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  if (attributes)\n+    switch (kwd->keyword)\n+      {\n+\tcase RID_AT_ALIAS:\n+\tcase RID_AT_CLASS:\n+\tcase RID_AT_END:\n+\t  error_at (kwd->location, \"attributes may not be specified before\"\n+\t            \" the %<@%D%> Objective-C++ keyword\",\n+\t\t    kwd->u.value);\n+\t  attributes = NULL;\n+\t  break;\n+\tcase RID_AT_IMPLEMENTATION:\n+\t  warning_at (kwd->location, OPT_Wattributes,\n+\t\t      \"prefix attributes are ignored before %<@%D%>\",\n+\t\t      kwd->u.value);\n+\t  attributes = NULL;\n+\tdefault:\n+\t  break;\n+      }\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_ALIAS:\n+      cp_parser_objc_alias_declaration (parser);\n+      break;\n+    case RID_AT_CLASS:\n+      cp_parser_objc_class_declaration (parser);\n+      break;\n+    case RID_AT_PROTOCOL:\n+      cp_parser_objc_protocol_declaration (parser, attributes);\n+      break;\n+    case RID_AT_INTERFACE:\n+      cp_parser_objc_class_interface (parser, attributes);\n+      break;\n+    case RID_AT_IMPLEMENTATION:\n+      cp_parser_objc_class_implementation (parser);\n+      break;\n+    case RID_AT_END:\n+      cp_parser_objc_end_implementation (parser);\n+      break;\n+    default:\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t\tkwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+}\n+\n+/* Parse an Objective-C try-catch-finally statement.\n+\n+   objc-try-catch-finally-stmt:\n+     @try compound-statement objc-catch-clause-seq [opt]\n+       objc-finally-clause [opt]\n+\n+   objc-catch-clause-seq:\n+     objc-catch-clause objc-catch-clause-seq [opt]\n+\n+   objc-catch-clause:\n+     @catch ( objc-exception-declaration ) compound-statement\n+\n+   objc-finally-clause:\n+     @finally compound-statement\n+\n+   objc-exception-declaration:\n+     parameter-declaration\n+     '...'\n+\n+   where '...' is to be interpreted literally, that is, it means CPP_ELLIPSIS.\n+\n+   Returns NULL_TREE.\n+\n+   PS: This function is identical to c_parser_objc_try_catch_finally_statement\n+   for C.  Keep them in sync.  */   \n+\n+static tree\n+cp_parser_objc_try_catch_finally_statement (cp_parser *parser)\n+{\n+  location_t location;\n+  tree stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_TRY, RT_AT_TRY);\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  objc_maybe_warn_exceptions (location);\n+  /* NB: The @try block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+  objc_begin_try_stmt (location, pop_stmt_list (stmt));\n+\n+  while (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_CATCH))\n+    {\n+      cp_parameter_declarator *parm;\n+      tree parameter_declaration = error_mark_node;\n+      bool seen_open_paren = false;\n+\n+      cp_lexer_consume_token (parser->lexer);\n+      if (cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n+\tseen_open_paren = true;\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_ELLIPSIS))\n+\t{\n+\t  /* We have \"@catch (...)\" (where the '...' are literally\n+\t     what is in the code).  Skip the '...'.\n+\t     parameter_declaration is set to NULL_TREE, and\n+\t     objc_being_catch_clauses() knows that that means\n+\t     '...'.  */\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  parameter_declaration = NULL_TREE;\n+\t}\n+      else\n+\t{\n+\t  /* We have \"@catch (NSException *exception)\" or something\n+\t     like that.  Parse the parameter declaration.  */\n+\t  parm = cp_parser_parameter_declaration (parser, false, NULL);\n+\t  if (parm == NULL)\n+\t    parameter_declaration = error_mark_node;\n+\t  else\n+\t    parameter_declaration = grokdeclarator (parm->declarator,\n+\t\t\t\t\t\t    &parm->decl_specifiers,\n+\t\t\t\t\t\t    PARM, /*initialized=*/0,\n+\t\t\t\t\t\t    /*attrlist=*/NULL);\n+\t}\n+      if (seen_open_paren)\n+\tcp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+      else\n+\t{\n+\t  /* If there was no open parenthesis, we are recovering from\n+\t     an error, and we are trying to figure out what mistake\n+\t     the user has made.  */\n+\n+\t  /* If there is an immediate closing parenthesis, the user\n+\t     probably forgot the opening one (ie, they typed \"@catch\n+\t     NSException *e)\".  Parse the closing parenthesis and keep\n+\t     going.  */\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  \n+\t  /* If these is no immediate closing parenthesis, the user\n+\t     probably doesn't know that parenthesis are required at\n+\t     all (ie, they typed \"@catch NSException *e\").  So, just\n+\t     forget about the closing parenthesis and keep going.  */\n+\t}\n+      objc_begin_catch_clause (parameter_declaration);\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_finish_catch_clause ();\n+    }\n+  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_FINALLY))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      location = cp_lexer_peek_token (parser->lexer)->location;\n+      /* NB: The @finally block needs to be wrapped in its own STATEMENT_LIST\n+\t node, lest it get absorbed into the surrounding block.  */\n+      stmt = push_stmt_list ();\n+      cp_parser_compound_statement (parser, NULL, false);\n+      objc_build_finally_clause (location, pop_stmt_list (stmt));\n+    }\n+\n+  return objc_finish_try_stmt ();\n+}\n+\n+/* Parse an Objective-C synchronized statement.\n+\n+   objc-synchronized-stmt:\n+     @synchronized ( expression ) compound-statement\n+\n+   Returns NULL_TREE.  */\n+\n+static tree\n+cp_parser_objc_synchronized_statement (cp_parser *parser)\n+{\n+  location_t location;\n+  tree lock, stmt;\n+\n+  cp_parser_require_keyword (parser, RID_AT_SYNCHRONIZED, RT_AT_SYNCHRONIZED);\n+\n+  location = cp_lexer_peek_token (parser->lexer)->location;\n+  objc_maybe_warn_exceptions (location);\n+  cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN);\n+  lock = cp_parser_expression (parser, false, NULL);\n+  cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n+\n+  /* NB: The @synchronized block needs to be wrapped in its own STATEMENT_LIST\n+     node, lest it get absorbed into the surrounding block.  */\n+  stmt = push_stmt_list ();\n+  cp_parser_compound_statement (parser, NULL, false);\n+\n+  return objc_build_synchronized (location, lock, pop_stmt_list (stmt));\n+}\n+\n+/* Parse an Objective-C throw statement.\n+\n+   objc-throw-stmt:\n+     @throw assignment-expression [opt] ;\n+\n+   Returns a constructed '@throw' statement.  */\n+\n+static tree\n+cp_parser_objc_throw_statement (cp_parser *parser)\n+{\n+  tree expr = NULL_TREE;\n+  location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_parser_require_keyword (parser, RID_AT_THROW, RT_AT_THROW);\n+\n+  if (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    expr = cp_parser_expression (parser, /*cast_p=*/false, NULL);\n+\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\n+  return objc_build_throw_stmt (loc, expr);\n+}\n+\n+/* Parse an Objective-C statement.  */\n+\n+static tree\n+cp_parser_objc_statement (cp_parser * parser)\n+{\n+  /* Try to figure out what kind of declaration is present.  */\n+  cp_token *kwd = cp_lexer_peek_token (parser->lexer);\n+\n+  switch (kwd->keyword)\n+    {\n+    case RID_AT_TRY:\n+      return cp_parser_objc_try_catch_finally_statement (parser);\n+    case RID_AT_SYNCHRONIZED:\n+      return cp_parser_objc_synchronized_statement (parser);\n+    case RID_AT_THROW:\n+      return cp_parser_objc_throw_statement (parser);\n+    default:\n+      error_at (kwd->location, \"misplaced %<@%D%> Objective-C++ construct\",\n+\t       kwd->u.value);\n+      cp_parser_skip_to_end_of_block_or_statement (parser);\n+    }\n+\n+  return error_mark_node;\n+}\n+\n+/* If we are compiling ObjC++ and we see an __attribute__ we neeed to \n+   look ahead to see if an objc keyword follows the attributes.  This\n+   is to detect the use of prefix attributes on ObjC @interface and \n+   @protocol.  */\n+\n+static bool\n+cp_parser_objc_valid_prefix_attributes (cp_parser* parser, tree *attrib)\n+{\n+  cp_lexer_save_tokens (parser->lexer);\n+  *attrib = cp_parser_attributes_opt (parser);\n+  gcc_assert (*attrib);\n+  if (OBJC_IS_AT_KEYWORD (cp_lexer_peek_token (parser->lexer)->keyword))\n+    {\n+      cp_lexer_commit_tokens (parser->lexer);\n+      return true;\n+    }\n+  cp_lexer_rollback_tokens (parser->lexer);\n+  return false;  \n+}\n+\n+/* This routine is a minimal replacement for\n+   c_parser_struct_declaration () used when parsing the list of\n+   types/names or ObjC++ properties.  For example, when parsing the\n+   code\n+\n+   @property (readonly) int a, b, c;\n+\n+   this function is responsible for parsing \"int a, int b, int c\" and\n+   returning the declarations as CHAIN of DECLs.\n+\n+   TODO: Share this code with cp_parser_objc_class_ivars.  It's very\n+   similar parsing.  */\n+static tree\n+cp_parser_objc_struct_declaration (cp_parser *parser)\n+{\n+  tree decls = NULL_TREE;\n+  cp_decl_specifier_seq declspecs;\n+  int decl_class_or_enum_p;\n+  tree prefix_attributes;\n+\n+  cp_parser_decl_specifier_seq (parser,\n+\t\t\t\tCP_PARSER_FLAGS_NONE,\n+\t\t\t\t&declspecs,\n+\t\t\t\t&decl_class_or_enum_p);\n+\n+  if (declspecs.type == error_mark_node)\n+    return error_mark_node;\n+\n+  /* auto, register, static, extern, mutable.  */\n+  if (declspecs.storage_class != sc_none)\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.storage_class = sc_none;\n+    }\n+  \n+  /* __thread.  */\n+  if (declspecs.specs[(int) ds_thread])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_thread] = 0;\n+    }\n+  \n+  /* typedef.  */\n+  if (declspecs.specs[(int) ds_typedef])\n+    {\n+      cp_parser_error (parser, \"invalid type for property\");\n+      declspecs.specs[(int) ds_typedef] = 0;\n+    }\n+\n+  prefix_attributes = declspecs.attributes;\n+  declspecs.attributes = NULL_TREE;\n+\n+  /* Keep going until we hit the `;' at the end of the declaration. */\n+  while (cp_lexer_next_token_is_not (parser->lexer, CPP_SEMICOLON))\n+    {\n+      tree attributes, first_attribute, decl;\n+      cp_declarator *declarator;\n+      cp_token *token;\n+\n+      /* Parse the declarator.  */\n+      declarator = cp_parser_declarator (parser, CP_PARSER_DECLARATOR_NAMED,\n+\t\t\t\t\t NULL, NULL, false);\n+\n+      /* Look for attributes that apply to the ivar.  */\n+      attributes = cp_parser_attributes_opt (parser);\n+      /* Remember which attributes are prefix attributes and\n+\t which are not.  */\n+      first_attribute = attributes;\n+      /* Combine the attributes.  */\n+      attributes = chainon (prefix_attributes, attributes);\n+      \n+      decl = grokfield (declarator, &declspecs,\n+\t\t\tNULL_TREE, /*init_const_expr_p=*/false,\n+\t\t\tNULL_TREE, attributes);\n+\n+      if (decl == error_mark_node || decl == NULL_TREE)\n+\treturn error_mark_node;\n+      \n+      /* Reset PREFIX_ATTRIBUTES.  */\n+      while (attributes && TREE_CHAIN (attributes) != first_attribute)\n+\tattributes = TREE_CHAIN (attributes);\n+      if (attributes)\n+\tTREE_CHAIN (attributes) = NULL_TREE;\n+\n+      DECL_CHAIN (decl) = decls;\n+      decls = decl;\n+\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_COMMA)\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);  /* Eat ','.  */\n+\t  continue;\n+\t}\n+      else\n+\tbreak;\n+    }\n+  return decls;\n+}\n+\n+/* Parse an Objective-C @property declaration.  The syntax is:\n+\n+   objc-property-declaration:\n+     '@property' objc-property-attributes[opt] struct-declaration ;\n+\n+   objc-property-attributes:\n+    '(' objc-property-attribute-list ')'\n+\n+   objc-property-attribute-list:\n+     objc-property-attribute\n+     objc-property-attribute-list, objc-property-attribute\n+\n+   objc-property-attribute\n+     'getter' = identifier\n+     'setter' = identifier\n+     'readonly'\n+     'readwrite'\n+     'assign'\n+     'retain'\n+     'copy'\n+     'nonatomic'\n+\n+  For example:\n+    @property NSString *name;\n+    @property (readonly) id object;\n+    @property (retain, nonatomic, getter=getTheName) id name;\n+    @property int a, b, c;\n+\n+   PS: This function is identical to\n+   c_parser_objc_at_property_declaration for C.  Keep them in sync.  */\n+static void \n+cp_parser_objc_at_property_declaration (cp_parser *parser)\n+{\n+  /* The following variables hold the attributes of the properties as\n+     parsed.  They are 'false' or 'NULL_TREE' if the attribute was not\n+     seen.  When we see an attribute, we set them to 'true' (if they\n+     are boolean properties) or to the identifier (if they have an\n+     argument, ie, for getter and setter).  Note that here we only\n+     parse the list of attributes, check the syntax and accumulate the\n+     attributes that we find.  objc_add_property_declaration() will\n+     then process the information.  */\n+  bool property_assign = false;\n+  bool property_copy = false;\n+  tree property_getter_ident = NULL_TREE;\n+  bool property_nonatomic = false;\n+  bool property_readonly = false;\n+  bool property_readwrite = false;\n+  bool property_retain = false;\n+  tree property_setter_ident = NULL_TREE;\n+\n+  /* 'properties' is the list of properties that we read.  Usually a\n+     single one, but maybe more (eg, in \"@property int a, b, c;\" there\n+     are three).  */\n+  tree properties;\n+  location_t loc;\n+\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@property'.  */\n+\n+  /* Parse the optional attribute list...  */\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      /* Eat the '('.  */\n+      cp_lexer_consume_token (parser->lexer);\n+\n+      while (true)\n+\t{\n+\t  bool syntax_error = false;\n+\t  cp_token *token = cp_lexer_peek_token (parser->lexer);\n+      \t  enum rid keyword;\n+\n+\t  if (token->type != CPP_NAME)\n+\t    {\n+\t      cp_parser_error (parser, \"expected identifier\");\n+\t      break;\n+\t    }\n+\t  keyword = C_RID_CODE (token->u.value);\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  switch (keyword)\n+\t    {\n+\t    case RID_ASSIGN:    property_assign = true;    break;\n+\t    case RID_COPY:      property_copy = true;      break;\n+\t    case RID_NONATOMIC: property_nonatomic = true; break;\n+\t    case RID_READONLY:  property_readonly = true;  break;\n+\t    case RID_READWRITE: property_readwrite = true; break;\n+\t    case RID_RETAIN:    property_retain = true;    break;\n+\n+\t    case RID_GETTER:\n+\t    case RID_SETTER:\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_EQ))\n+\t\t{\n+\t\t  if (keyword == RID_GETTER)\n+\t\t    cp_parser_error (parser,\n+\t\t\t\t     \"missing %<=%> (after %<getter%> attribute)\");\n+\t\t  else\n+\t\t    cp_parser_error (parser,\n+\t\t\t\t     \"missing %<=%> (after %<setter%> attribute)\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      cp_lexer_consume_token (parser->lexer); /* eat the = */\n+\t      if (cp_lexer_next_token_is_not (parser->lexer, CPP_NAME))\n+\t\t{\n+\t\t  cp_parser_error (parser, \"expected identifier\");\n+\t\t  syntax_error = true;\n+\t\t  break;\n+\t\t}\n+\t      if (keyword == RID_SETTER)\n+\t\t{\n+\t\t  if (property_setter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<setter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_setter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t  if (cp_lexer_next_token_is_not (parser->lexer, CPP_COLON))\n+\t\t    cp_parser_error (parser, \"setter name must terminate with %<:%>\");\n+\t\t  else\n+\t\t    cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  if (property_getter_ident != NULL_TREE)\n+\t\t    cp_parser_error (parser, \"the %<getter%> attribute may only be specified once\");\n+\t\t  else\n+\t\t    property_getter_ident = cp_lexer_peek_token (parser->lexer)->u.value;\n+\t\t  cp_lexer_consume_token (parser->lexer);\n+\t\t}\n+\t      break;\n+\t    default:\n+\t      cp_parser_error (parser, \"unknown property attribute\");\n+\t      syntax_error = true;\n+\t      break;\n+\t    }\n+\n+\t  if (syntax_error)\n+\t    break;\n+\n+\t  if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\t    cp_lexer_consume_token (parser->lexer);\n+\t  else\n+\t    break;\n+\t}\n+\n+      /* FIXME: \"@property (setter, assign);\" will generate a spurious\n+\t \"error: expected \u2018)\u2019 before \u2018,\u2019 token\".  This is because\n+\t cp_parser_require, unlike the C counterpart, will produce an\n+\t error even if we are in error recovery.  */\n+      if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n+\t{\n+\t  cp_parser_skip_to_closing_parenthesis (parser,\n+\t\t\t\t\t\t /*recovering=*/true,\n+\t\t\t\t\t\t /*or_comma=*/false,\n+\t\t\t\t\t\t /*consume_paren=*/true);\n+\t}\n+    }\n+\n+  /* ... and the property declaration(s).  */\n+  properties = cp_parser_objc_struct_declaration (parser);\n+\n+  if (properties == error_mark_node)\n+    {\n+      cp_parser_skip_to_end_of_statement (parser);\n+      /* If the next token is now a `;', consume it.  */\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_SEMICOLON))\n+\tcp_lexer_consume_token (parser->lexer);\n+      return;\n+    }\n+\n+  if (properties == NULL_TREE)\n+    cp_parser_error (parser, \"expected identifier\");\n+  else\n+    {\n+      /* Comma-separated properties are chained together in\n+\t reverse order; add them one by one.  */\n+      properties = nreverse (properties);\n+      \n+      for (; properties; properties = TREE_CHAIN (properties))\n+\tobjc_add_property_declaration (loc, copy_node (properties),\n+\t\t\t\t       property_readonly, property_readwrite,\n+\t\t\t\t       property_assign, property_retain,\n+\t\t\t\t       property_copy, property_nonatomic,\n+\t\t\t\t       property_getter_ident, property_setter_ident);\n+    }\n+  \n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+}\n+\n+/* Parse an Objective-C++ @synthesize declaration.  The syntax is:\n+\n+   objc-synthesize-declaration:\n+     @synthesize objc-synthesize-identifier-list ;\n+\n+   objc-synthesize-identifier-list:\n+     objc-synthesize-identifier\n+     objc-synthesize-identifier-list, objc-synthesize-identifier\n+\n+   objc-synthesize-identifier\n+     identifier\n+     identifier = identifier\n+\n+  For example:\n+    @synthesize MyProperty;\n+    @synthesize OneProperty, AnotherProperty=MyIvar, YetAnotherProperty;\n+\n+  PS: This function is identical to c_parser_objc_at_synthesize_declaration\n+  for C.  Keep them in sync.\n+*/\n+static void \n+cp_parser_objc_at_synthesize_declaration (cp_parser *parser)\n+{\n+  tree list = NULL_TREE;\n+  location_t loc;\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@synthesize'.  */\n+  while (true)\n+    {\n+      tree property, ivar;\n+      property = cp_parser_identifier (parser);\n+      if (property == error_mark_node)\n+\t{\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t  return;\n+\t}\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_EQ))\n+\t{\n+\t  cp_lexer_consume_token (parser->lexer);\n+\t  ivar = cp_parser_identifier (parser);\n+\t  if (ivar == error_mark_node)\n+\t    {\n+\t      cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\tivar = NULL_TREE;\n+      list = chainon (list, build_tree_list (ivar, property));\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+  objc_add_synthesize_declaration (loc, list);\n+}\n+\n+/* Parse an Objective-C++ @dynamic declaration.  The syntax is:\n+\n+   objc-dynamic-declaration:\n+     @dynamic identifier-list ;\n+\n+   For example:\n+     @dynamic MyProperty;\n+     @dynamic MyProperty, AnotherProperty;\n+\n+  PS: This function is identical to c_parser_objc_at_dynamic_declaration\n+  for C.  Keep them in sync.\n+*/\n+static void \n+cp_parser_objc_at_dynamic_declaration (cp_parser *parser)\n+{\n+  tree list = NULL_TREE;\n+  location_t loc;\n+  loc = cp_lexer_peek_token (parser->lexer)->location;\n+\n+  cp_lexer_consume_token (parser->lexer);  /* Eat '@dynamic'.  */\n+  while (true)\n+    {\n+      tree property;\n+      property = cp_parser_identifier (parser);\n+      if (property == error_mark_node)\n+\t{\n+\t  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+\t  return;\n+\t}\n+      list = chainon (list, build_tree_list (NULL, property));\n+      if (cp_lexer_next_token_is (parser->lexer, CPP_COMMA))\n+\tcp_lexer_consume_token (parser->lexer);\n+      else\n+\tbreak;\n+    }\n+  cp_parser_consume_semicolon_at_end_of_statement (parser);\n+  objc_add_dynamic_declaration (loc, list);\n+}\n+\n+#endif"}, {"sha": "e18142e0862bdce5b19d5087fadde600cba35dcd", "filename": "gcc/objcp/plugin/parser.h", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2Fplugin%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba326d364d03223720932db63da569371603ef92/gcc%2Fobjcp%2Fplugin%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjcp%2Fplugin%2Fparser.h?ref=ba326d364d03223720932db63da569371603ef92", "patch": "@@ -0,0 +1,227 @@\n+/* Objective-C++ Parser plugin\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004,\n+   2005, 2007, 2008, 2009, 2010, 2011  Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* This isn't defined anywhere, yet, but it could be.  This will turn off\n+   the entire C++ Objective-C++ plugin.  */\n+#ifdef HIDE_OBJC\n+\n+#include \"c-family/c-objc.h\"\n+\n+\n+/* Objective-C++ Productions */\n+\n+static tree cp_parser_objc_message_receiver\n+  (cp_parser *);\n+static tree cp_parser_objc_message_args\n+  (cp_parser *);\n+static tree cp_parser_objc_message_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_encode_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_defs_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_selector_expression\n+  (cp_parser *);\n+static tree cp_parser_objc_expression\n+  (cp_parser *);\n+static bool cp_parser_objc_selector_p\n+  (enum cpp_ttype);\n+static tree cp_parser_objc_selector\n+  (cp_parser *);\n+static tree cp_parser_objc_protocol_refs_opt\n+  (cp_parser *);\n+static void cp_parser_objc_declaration\n+  (cp_parser *, tree);\n+static tree cp_parser_objc_statement\n+  (cp_parser *);\n+static bool cp_parser_objc_valid_prefix_attributes\n+  (cp_parser *, tree *);\n+static void cp_parser_objc_at_property_declaration \n+  (cp_parser *) ;\n+static void cp_parser_objc_at_synthesize_declaration \n+  (cp_parser *) ;\n+static void cp_parser_objc_at_dynamic_declaration\n+  (cp_parser *) ;\n+static tree cp_parser_objc_struct_declaration\n+  (cp_parser *) ;\n+\n+#define PLUGIN_PRIMARY_EXPRESSION_3(parser) @(\n+  do {\n+    if (c_dialect_objc ())\n+      /* We have an Objective-C++ message. */\n+      return cp_parser_objc_expression (parser);\n+  } while (0)@)\n+\n+#define PLUGIN_PRIMARY_EXPRESSION_2(parser, cp_parser_error) @(\n+  case CPP_OBJC_STRING:\n+    if (c_dialect_objc ())\n+      /* We have an Objective-C++ string literal. */\n+      return cp_parser_objc_expression (parser);\n+    cp_parser_error (parser, \"expected primary-expression\");\n+    return error_mark_node;@)\n+\n+#define PLUGIN_PRIMARY_EXPRESSION_1(parser) @(\n+  /* Objective-C++ expressions.  */\n+  case RID_AT_ENCODE:\n+  case RID_AT_PROTOCOL:\n+  case RID_AT_SELECTOR:\n+    return cp_parser_objc_expression (parser);@)\n+\n+#define PLUGIN_PRIMARY_EXPRESSION(parser, decl, cp_lexer_consume_token, cp_lexer_peek_token) @(\n+  do {\n+    /* In Objective-C++, we may have an Objective-C 2.0\n+       dot-syntax for classes here.  */\n+    if (c_dialect_objc ()\n+\t&& cp_lexer_peek_token (parser->lexer)->type == CPP_DOT\n+\t&& TREE_CODE (decl) == TYPE_DECL\n+\t&& objc_is_class_name (decl))\n+      {\n+\ttree component;\n+\tcp_lexer_consume_token (parser->lexer);\n+\tcomponent = cp_parser_identifier (parser);\n+\tif (component == error_mark_node)\n+\t  return error_mark_node;\n+\n+\treturn objc_build_class_component_ref (id_expression, component);\n+      }\n+\n+    /* In Objective-C++, an instance variable (ivar) may be preferred\n+       to whatever cp_parser_lookup_name() found.  */\n+    decl = objc_lookup_ivar (decl, id_expression);\n+  } while (0)@)\n+\n+#define PLUGIN_TOKEN_STARTS_CAST_EXPR @(\n+  do {\n+    /* '[' may start a primary-expression in obj-c++.  */\n+    return c_dialect_objc ();\n+  } while (0)@)\n+\n+#define PLUGIN_STATEMENT @(\n+  /* Objective-C++ exception-handling constructs.  */\n+ case RID_AT_TRY:\n+ case RID_AT_CATCH:\n+ case RID_AT_FINALLY:\n+ case RID_AT_SYNCHRONIZED:\n+ case RID_AT_THROW:\n+   statement = cp_parser_objc_statement (parser);\n+   break;@)\n+\n+\n+#define PLUGIN_DECLARATION @(\n+  /* Objective-C++ declaration/definition.  */\n+  else if (c_dialect_objc () && OBJC_IS_AT_KEYWORD (token1.keyword))\n+    cp_parser_objc_declaration (parser, NULL_TREE);\n+  else if (c_dialect_objc ()\n+\t   && token1.keyword == RID_ATTRIBUTE\n+\t   && cp_parser_objc_valid_prefix_attributes (parser, &attributes))\n+    cp_parser_objc_declaration (parser, attributes);@)\n+\n+#define PLUGIN_SIMPLE_TYPE_SPECIFIER @(\n+  do {\n+    /* See if TYPE is an Objective-C type, and if so, parse and\n+       accept any protocol references following it.  Do this before\n+       the cp_parser_check_for_invalid_template_id() call, because\n+       Objective-C types can be followed by '<...>' which would\n+       enclose protocol names rather than template arguments, and so\n+       everything is fine.  */\n+    if (c_dialect_objc () && !parser->scope\n+\t&& (objc_is_id (type) || objc_is_class_name (type)))\n+      {\n+\ttree protos = cp_parser_objc_protocol_refs_opt (parser);\n+\ttree qual_type = objc_get_protocol_qualified_type (type, protos);\n+\n+\t/* Clobber the \"unqualified\" type previously entered into\n+\t   DECL_SPECS with the new, improved protocol-qualified version.  */\n+\tif (decl_specs)\n+\t  decl_specs->type = qual_type;\n+\n+\treturn qual_type;\n+      }\n+  } while (0)@)\n+\n+\n+#define PLUGIN_NONCLASS_NAME1 @(\n+  do {\n+    if (TREE_CODE (type_decl) != TYPE_DECL\n+\t&& (objc_is_id (identifier) || objc_is_class_name (identifier)))\n+      {\n+\t/* See if this is an Objective-C type.  */\n+\ttree protos = cp_parser_objc_protocol_refs_opt (parser);\n+\ttree type = objc_get_protocol_qualified_type (identifier, protos);\n+\tif (type)\n+\t  type_decl = TYPE_NAME (type);\n+      }\n+  } while (0)@)\n+\n+#define PLUGIN_NONCLASS_NAME @(\n+  /* In Objective-C, we have the complication that class names are\n+     normally type names and start declarations (eg, the\n+     \"NSObject\" in \"NSObject *object;\"), but can be used in an\n+     Objective-C 2.0 dot-syntax (as in \"NSObject.version\") which\n+     is an expression.  So, a classname followed by a dot is not a\n+     valid type-name.  */\n+  || (objc_is_class_name (TREE_TYPE (type_decl))\n+      && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT)@)\n+\n+#define PLUGIN_CLASS_NAME @(\n+  /* In Objective-C 2.0, a classname followed by '.' starts a\n+     dot-syntax expression, and it's not a type-name.  */\n+  || (c_dialect_objc ()\n+      && cp_lexer_peek_token (parser->lexer)->type == CPP_DOT \n+      && objc_is_class_name (decl))@)\n+\n+#define PLUGIN_MEMBER_DECLARATION @(\n+  do {\n+    /* Check for @defs.  */\n+    if (cp_lexer_next_token_is_keyword (parser->lexer, RID_AT_DEFS))\n+      {\n+\ttree ivar, member;\n+\ttree ivar_chains = cp_parser_objc_defs_expression (parser);\n+\tivar = ivar_chains;\n+\twhile (ivar)\n+\t  {\n+\t    member = ivar;\n+\t    ivar = TREE_CHAIN (member);\n+\t    TREE_CHAIN (member) = NULL_TREE;\n+\t    finish_member_declaration (member);\n+\t  }\n+\treturn;\n+      }\n+  } while (0)@)\n+\n+#else\n+\n+#define PLUGIN_PRIMARY_EXPRESSION_3(parser)\n+#define PLUGIN_PRIMARY_EXPRESSION_2(parser, cp_parser_error)\n+#define PLUGIN_PRIMARY_EXPRESSION_1(parser)\n+#define PLUGIN_PRIMARY_EXPRESSION(parser, decl, cp_lexer_consume_token, cp_lexer_peek_token)\n+#define PLUGIN_TOKEN_STARTS_CAST_EXPR\n+#define PLUGIN_STATEMENT\n+#define PLUGIN_DECLARATION\n+#define PLUGIN_SIMPLE_TYPE_SPECIFIER\n+#define PLUGIN_NONCLASS_NAME1\n+#define PLUGIN_NONCLASS_NAME\n+#define PLUGIN_CLASS_NAME\n+#define PLUGIN_MEMBER_DECLARATION\n+\n+#endif"}]}