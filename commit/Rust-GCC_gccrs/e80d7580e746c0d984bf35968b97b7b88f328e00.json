{"sha": "e80d7580e746c0d984bf35968b97b7b88f328e00", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgwZDc1ODBlNzQ2YzBkOTg0YmYzNTk2OGI5N2I3Yjg4ZjMyOGUwMA==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-04-24T09:48:41Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-04-24T09:48:41Z"}, "message": "tree-flow.h (vrp_evaluate_conditional): Change signature.\n\n2008-04-24  Rafael Espindola  <espindola@google.com>\n\n\t* tree-flow.h (vrp_evaluate_conditional): Change signature.\n\t* tree-ssa-propagate.c (fold_predicate_in): Update call to\n\tvrp_evaluate_conditional.\n\t* tree-vrp.c (vrp_evaluate_conditional_warnv): Remove.\n        (vrp_evaluate_conditional): Split the cond argument.\n        (vrp_visit_cond_stmt): Use vrp_evaluate_conditional_warnv_with_ops.\n        (simplify_stmt_for_jump_threading): Update call to\n\tvrp_evaluate_conditional.\n\nFrom-SVN: r134625", "tree": {"sha": "831bbe410099a9e9cd9808e14ec5ced2f9d783b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/831bbe410099a9e9cd9808e14ec5ced2f9d783b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e80d7580e746c0d984bf35968b97b7b88f328e00", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d7580e746c0d984bf35968b97b7b88f328e00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e80d7580e746c0d984bf35968b97b7b88f328e00", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e80d7580e746c0d984bf35968b97b7b88f328e00/comments", "author": null, "committer": null, "parents": [{"sha": "0e37a1c243896f03ad5fbfd4d3306802e20bc564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e37a1c243896f03ad5fbfd4d3306802e20bc564", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e37a1c243896f03ad5fbfd4d3306802e20bc564"}], "stats": {"total": 126, "additions": 57, "deletions": 69}, "files": [{"sha": "3bd5e7f6cc4807a9aee094e9b2617bc6ecce257e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e80d7580e746c0d984bf35968b97b7b88f328e00", "patch": "@@ -1,3 +1,14 @@\n+2008-04-24  Rafael Espindola  <espindola@google.com>\n+\n+\t* tree-flow.h (vrp_evaluate_conditional): Change signature.\n+\t* tree-ssa-propagate.c (fold_predicate_in): Update call to\n+\tvrp_evaluate_conditional.\n+\t* tree-vrp.c (vrp_evaluate_conditional_warnv): Remove.\n+        (vrp_evaluate_conditional): Split the cond argument.\n+        (vrp_visit_cond_stmt): Use vrp_evaluate_conditional_warnv_with_ops.\n+        (simplify_stmt_for_jump_threading): Update call to\n+\tvrp_evaluate_conditional.\n+\n 2008-04-24  Ira Rosen  <irar@il.ibm.com>\n \n \tPR tree-optimization/35982"}, {"sha": "f26181fb9e1dc1a5d84835351fb6bc48e58b86fe", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=e80d7580e746c0d984bf35968b97b7b88f328e00", "patch": "@@ -944,7 +944,7 @@ tree get_symbol_constant_value (tree);\n tree fold_const_aggregate_ref (tree);\n \n /* In tree-vrp.c  */\n-tree vrp_evaluate_conditional (tree, tree);\n+tree vrp_evaluate_conditional (enum tree_code, tree, tree, tree);\n void simplify_stmt_using_ranges (tree);\n \n /* In tree-ssa-dom.c  */"}, {"sha": "6423ec6ba524b979143ff19bd95082eae0baa876", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=e80d7580e746c0d984bf35968b97b7b88f328e00", "patch": "@@ -1148,7 +1148,17 @@ fold_predicate_in (tree stmt)\n   else\n     return false;\n \n-  val = vrp_evaluate_conditional (*pred_p, stmt);\n+  if (TREE_CODE (*pred_p) == SSA_NAME)\n+    val = vrp_evaluate_conditional (EQ_EXPR,\n+\t\t\t\t    *pred_p,\n+\t\t\t\t    boolean_true_node,\n+\t\t\t\t    stmt);\n+  else\n+    val = vrp_evaluate_conditional (TREE_CODE (*pred_p),\n+\t\t\t\t    TREE_OPERAND (*pred_p, 0),\n+\t\t\t\t    TREE_OPERAND (*pred_p, 1),\n+\t\t\t\t    stmt);\n+\n   if (val)\n     {\n       if (modify_stmt_p)"}, {"sha": "f65a3c397c83c1294557d9cde7dc53e1569816d7", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 34, "deletions": 67, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e80d7580e746c0d984bf35968b97b7b88f328e00/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=e80d7580e746c0d984bf35968b97b7b88f328e00", "patch": "@@ -46,7 +46,6 @@ static sbitmap found_in_subgraph;\n static int compare_values (tree val1, tree val2);\n static int compare_values_warnv (tree val1, tree val2, bool *);\n static void vrp_meet (value_range_t *, value_range_t *);\n-static tree vrp_evaluate_conditional_warnv (tree, bool, bool *);\n static tree vrp_evaluate_conditional_warnv_with_ops (enum tree_code,\n \t\t\t\t\t\t     tree, tree, bool, bool *);\n \n@@ -5272,78 +5271,25 @@ vrp_evaluate_conditional_warnv_with_ops (enum tree_code code, tree op0,\n   return NULL_TREE;\n }\n \n-/* Given a conditional predicate COND, try to determine if COND yields\n-   true or false based on the value ranges of its operands.  Return\n-   BOOLEAN_TRUE_NODE if the conditional always evaluates to true,\n-   BOOLEAN_FALSE_NODE if the conditional always evaluates to false, and,\n-   NULL if the conditional cannot be evaluated at compile time.\n-\n-   If USE_EQUIV_P is true, the ranges of all the names equivalent with\n-   the operands in COND are used when trying to compute its value.\n-   This is only used during final substitution.  During propagation,\n-   we only check the range of each variable and not its equivalents.\n-\n-   Set *STRICT_OVERFLOW_P to indicate whether we relied on an overflow\n-   infinity to produce the result.  */\n-\n-static tree\n-vrp_evaluate_conditional_warnv (tree cond, bool use_equiv_p,\n-\t\t\t\tbool *strict_overflow_p)\n-{\n-  gcc_assert (TREE_CODE (cond) == SSA_NAME\n-              || TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison);\n-\n-  if (TREE_CODE (cond) == SSA_NAME)\n-    {\n-      value_range_t *vr;\n-      tree retval;\n-\n-      if (use_equiv_p)\n-\tretval = compare_name_with_value (NE_EXPR, cond, boolean_false_node,\n-\t\t\t\t\t  strict_overflow_p);\n-      else\n-\t{\n-\t  value_range_t *vr = get_value_range (cond);\n-\t  retval = compare_range_with_value (NE_EXPR, vr, boolean_false_node,\n-\t\t\t\t\t     strict_overflow_p);\n-\t}\n-\n-      /* If COND has a known boolean range, return it.  */\n-      if (retval)\n-\treturn retval;\n-\n-      /* Otherwise, if COND has a symbolic range of exactly one value,\n-\t return it.  */\n-      vr = get_value_range (cond);\n-      if (vr->type == VR_RANGE && vr->min == vr->max)\n-\treturn vr->min;\n-    }\n-  else\n-    return vrp_evaluate_conditional_warnv_with_ops (TREE_CODE (cond),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 0),\n-\t\t\t\t\t\t    TREE_OPERAND (cond, 1),\n-\t\t\t\t\t\t    use_equiv_p,\n-\t\t\t\t\t\t    strict_overflow_p);\n-\n-  /* Anything else cannot be computed statically.  */\n-  return NULL_TREE;\n-}\n-\n-/* Given COND within STMT, try to simplify it based on value range\n+/* Given (CODE OP0 OP1) within STMT, try to simplify it based on value range\n    information.  Return NULL if the conditional can not be evaluated.\n    The ranges of all the names equivalent with the operands in COND\n    will be used when trying to compute the value.  If the result is\n    based on undefined signed overflow, issue a warning if\n    appropriate.  */\n \n tree\n-vrp_evaluate_conditional (tree cond, tree stmt)\n+vrp_evaluate_conditional (enum tree_code code, tree op0, tree op1, tree stmt)\n {\n   bool sop;\n   tree ret;\n \n   sop = false;\n-  ret = vrp_evaluate_conditional_warnv (cond, true, &sop);\n+  ret = vrp_evaluate_conditional_warnv_with_ops (code,\n+\t\t\t\t\t\t op0,\n+\t\t\t\t\t\t op1,\n+\t\t\t\t\t\t true,\n+\t\t\t\t\t\t &sop);\n \n   if (ret && sop)\n     {\n@@ -5377,17 +5323,15 @@ vrp_evaluate_conditional (tree cond, tree stmt)\n \n   if (warn_type_limits\n       && ret\n-      && TREE_CODE_CLASS (TREE_CODE (cond)) == tcc_comparison\n-      && TREE_CODE (TREE_OPERAND (cond, 0)) == SSA_NAME)\n+      && TREE_CODE_CLASS (code) == tcc_comparison\n+      && TREE_CODE (op0) == SSA_NAME)\n     {\n       /* If the comparison is being folded and the operand on the LHS\n \t is being compared against a constant value that is outside of\n \t the natural range of OP0's type, then the predicate will\n \t always fold regardless of the value of OP0.  If -Wtype-limits\n \t was specified, emit a warning.  */\n       const char *warnmsg = NULL;\n-      tree op0 = TREE_OPERAND (cond, 0);\n-      tree op1 = TREE_OPERAND (cond, 1);\n       tree type = TREE_TYPE (op0);\n       value_range_t *vr0 = get_value_range (op0);\n \n@@ -5499,7 +5443,19 @@ vrp_visit_cond_stmt (tree stmt, edge *taken_edge_p)\n      MICO, TRAMP3D and SPEC2000) showed that doing this results in\n      4 more predicates folded in SPEC.  */\n   sop = false;\n-  val = vrp_evaluate_conditional_warnv (cond, false, &sop);\n+\n+  if (TREE_CODE (cond) == SSA_NAME)\n+    val = vrp_evaluate_conditional_warnv_with_ops (EQ_EXPR,\n+\t\t\t\t\t\t   cond,\n+\t\t\t\t\t\t   boolean_true_node,\n+\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t   &sop);\n+  else\n+    val = vrp_evaluate_conditional_warnv_with_ops (TREE_CODE (cond),\n+\t\t\t\t\t\t   TREE_OPERAND (cond, 0),\n+\t\t\t\t\t\t   TREE_OPERAND (cond, 1),\n+\t\t\t\t\t\t   false,\n+\t\t\t\t\t\t   &sop);\n   if (val)\n     {\n       if (!sop)\n@@ -6470,13 +6426,24 @@ static VEC(tree,heap) *stack;\n static tree\n simplify_stmt_for_jump_threading (tree stmt, tree within_stmt)\n {\n+  tree conditional;\n   /* We only use VRP information to simplify conditionals.  This is\n      overly conservative, but it's unclear if doing more would be\n      worth the compile time cost.  */\n   if (TREE_CODE (stmt) != COND_EXPR)\n     return NULL;\n \n-  return vrp_evaluate_conditional (COND_EXPR_COND (stmt), within_stmt);\n+  conditional = COND_EXPR_COND (stmt);\n+  if (TREE_CODE (conditional) == SSA_NAME)\n+    return vrp_evaluate_conditional (EQ_EXPR,\n+\t\t\t\t     conditional,\n+\t\t\t\t     boolean_true_node,\n+\t\t\t\t     within_stmt);\n+  else\n+    return vrp_evaluate_conditional (TREE_CODE (conditional),\n+\t\t\t\t     TREE_OPERAND (conditional, 0),\n+\t\t\t\t     TREE_OPERAND (conditional, 1),\n+\t\t\t\t     within_stmt);\n }\n \n /* Blocks which have more than one predecessor and more than"}]}