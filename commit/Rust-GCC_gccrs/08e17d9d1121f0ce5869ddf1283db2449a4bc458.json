{"sha": "08e17d9d1121f0ce5869ddf1283db2449a4bc458", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhlMTdkOWQxMTIxZjBjZTU4NjlkZGYxMjgzZGIyNDQ5YTRiYzQ1OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-10-21T21:23:42Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-10-21T21:23:42Z"}, "message": "re PR c++/18073 (mmintrin.h rejected by C++ frontend)\n\n\tPR c++/18073\n\tPR c++/10841\n\t* cp-tree.h (convert_to_base): Change prototype.\n\t(build_ptrmemfunc): Likewise.\n\t(convert_ptrmem): New function.\n\t* call.c (struct conversion): Adjust documentation for base_p.\n\t(standard_conversion): Set base_p for ck_pmem conversions as\n\tappropriate.\n\t(convert_like_real): Use convert_to_base for ck_pmem and ck_ptr\n\tconversions.\n\t* class.c (convert_to_base): Handle both pointers and objects.\n\tAdd nonnull parameter.\n\t(build_vfield_ref): Adjust call to convert_to_base.\n\t* cvt.c (cp_convert_to_pointer): Adjust call to build_ptrmemfunc.\n\t(convert_force): Likewise.\n\t* typeck.c (build_unary_op): Likewise.\n\t(convert_ptrmem): New function.\n\t(build_static_cast_1): Use it.\n\t(build_reinterpret_cast): Allow conversions to vector types.\n\t(get_delta_difference): Add c_cast_p parameter.\n\t(build_ptrmemfunc): Likewise.  Adjust calls to\n\tget_delta_difference.\n\n\tPR c++/10841\n\t* g++.dg/conversion/cast1.C: New test.\n\t* g++.dg/overload/pmf1.C: Adjust error marker.\n\nFrom-SVN: r89403", "tree": {"sha": "f2b7fac0767818e1f51fd05dc1e3af743cc2df4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f2b7fac0767818e1f51fd05dc1e3af743cc2df4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08e17d9d1121f0ce5869ddf1283db2449a4bc458", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e17d9d1121f0ce5869ddf1283db2449a4bc458", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08e17d9d1121f0ce5869ddf1283db2449a4bc458", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08e17d9d1121f0ce5869ddf1283db2449a4bc458/comments", "author": null, "committer": null, "parents": [{"sha": "8265f931175625977cb6ad5191a2ae286f71002e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8265f931175625977cb6ad5191a2ae286f71002e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8265f931175625977cb6ad5191a2ae286f71002e"}], "stats": {"total": 215, "additions": 154, "deletions": 61}, "files": [{"sha": "2c78f23b265c811f5f51f9c3ae3cc0fe7c981dbe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -1,3 +1,28 @@\n+2004-10-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/18073\n+\tPR c++/10841\n+\t* cp-tree.h (convert_to_base): Change prototype.\n+\t(build_ptrmemfunc): Likewise.\n+\t(convert_ptrmem): New function.\n+\t* call.c (struct conversion): Adjust documentation for base_p.\n+\t(standard_conversion): Set base_p for ck_pmem conversions as\n+\tappropriate.\n+\t(convert_like_real): Use convert_to_base for ck_pmem and ck_ptr\n+\tconversions.\n+\t* class.c (convert_to_base): Handle both pointers and objects.\n+\tAdd nonnull parameter.\n+\t(build_vfield_ref): Adjust call to convert_to_base.\n+\t* cvt.c (cp_convert_to_pointer): Adjust call to build_ptrmemfunc.\n+\t(convert_force): Likewise.\n+\t* typeck.c (build_unary_op): Likewise.\n+\t(convert_ptrmem): New function.\n+\t(build_static_cast_1): Use it.\n+\t(build_reinterpret_cast): Allow conversions to vector types.\n+\t(get_delta_difference): Add c_cast_p parameter.\n+\t(build_ptrmemfunc): Likewise.  Adjust calls to\n+\tget_delta_difference.\n+\n 2004-10-21  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR c++/13560"}, {"sha": "aedc9278b9d735c3393e7b649f471d329e866368", "filename": "gcc/cp/call.c", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -92,8 +92,8 @@ struct conversion {\n      copy constructor must be accessible, even though it is not being\n      used.  */\n   BOOL_BITFIELD check_copy_constructor_p : 1;\n-  /* If KIND is ck_ptr, true to indicate that a conversion from a\n-     pointer-to-derived to pointer-to-base is being performed.  */\n+  /* If KIND is ck_ptr or ck_pmem, true to indicate that a conversion\n+     from a pointer-to-derived to pointer-to-base is being performed.  */ \n   BOOL_BITFIELD base_p : 1;\n   /* The type of the expression resulting from the conversion.  */\n   tree type;\n@@ -779,6 +779,7 @@ standard_conversion (tree to, tree from, tree expr)\n \t\t\t\t\t TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n       from = build_ptrmemfunc_type (build_pointer_type (from));\n       conv = build_conv (ck_pmem, from, conv);\n+      conv->base_p = true;\n     }\n   else if (tcode == BOOLEAN_TYPE)\n     {\n@@ -4270,8 +4271,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    check_constructor_callable (TREE_TYPE (expr), expr);\n \t  /* Build an expression for `*((base*) &expr)'.  */\n \t  expr = build_unary_op (ADDR_EXPR, expr, 0);\n-\t  expr = perform_implicit_conversion (build_pointer_type (totype), \n-\t\t\t\t\t      expr);\n+\t  expr = convert_to_base (expr, build_pointer_type (totype),\n+\t\t\t\t  !c_cast_p, /*nonnull=*/true);\n \t  expr = build_indirect_ref (expr, \"implicit conversion\");\n \t  return expr;\n \t}\n@@ -4338,19 +4339,14 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n     case ck_ptr:\n       if (convs->base_p)\n-\t{\n-\t  tree binfo;\n-\n-\t  binfo = lookup_base (TREE_TYPE (TREE_TYPE (expr)),\n-\t\t\t       TREE_TYPE (totype), \n-\t\t\t       c_cast_p ? ba_unique : ba_check,\n-\t\t\t       NULL);\n-\t  if (binfo == error_mark_node)\n-\t    return error_mark_node;\n-\t  expr = build_base_path (PLUS_EXPR, expr, binfo, /*nonnull=*/0);\n-\t}\n+\texpr = convert_to_base (expr, totype, !c_cast_p,\n+\t\t\t\t/*nonnull=*/false);\n       return build_nop (totype, expr);\n \n+    case ck_pmem:\n+      return convert_ptrmem (totype, expr, /*allow_inverse_p=*/false,\n+\t\t\t     c_cast_p);\n+\n     default:\n       break;\n     }"}, {"sha": "15ca26ad460273814e7aca1e7e91f973197e011f", "filename": "gcc/cp/class.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -426,22 +426,34 @@ build_simple_base_path (tree expr, tree binfo)\n   gcc_unreachable ();\n }\n \n-/* Convert OBJECT to the base TYPE.  If CHECK_ACCESS is true, an error\n-   message is emitted if TYPE is inaccessible.  OBJECT is assumed to\n-   be non-NULL.  */\n+/* Convert OBJECT to the base TYPE.  OBJECT is an expression whose\n+   type is a class type or a pointer to a class type.  In the former\n+   case, TYPE is also a class type; in the latter it is another\n+   pointer type.  If CHECK_ACCESS is true, an error message is emitted\n+   if TYPE is inaccessible.  If OBJECT has pointer type, the value is\n+   assumed to be non-NULL.  */\n \n tree\n-convert_to_base (tree object, tree type, bool check_access)\n+convert_to_base (tree object, tree type, bool check_access, bool nonnull)\n {\n   tree binfo;\n+  tree object_type;\n \n-  binfo = lookup_base (TREE_TYPE (object), type, \n+  if (TYPE_PTR_P (TREE_TYPE (object)))\n+    {\n+      object_type = TREE_TYPE (TREE_TYPE (object));\n+      type = TREE_TYPE (type);\n+    }\n+  else\n+    object_type = TREE_TYPE (object);\n+\n+  binfo = lookup_base (object_type, type,\n \t\t       check_access ? ba_check : ba_unique, \n \t\t       NULL);\n   if (!binfo || binfo == error_mark_node)\n     return error_mark_node;\n \n-  return build_base_path (PLUS_EXPR, object, binfo, /*nonnull=*/1);\n+  return build_base_path (PLUS_EXPR, object, binfo, nonnull);\n }\n \n /* EXPR is an expression with unqualified class type.  BASE is a base\n@@ -485,7 +497,8 @@ build_vfield_ref (tree datum, tree type)\n \n   /* First, convert to the requested type.  */\n   if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n-    datum = convert_to_base (datum, type, /*check_access=*/false);\n+    datum = convert_to_base (datum, type, /*check_access=*/false,\n+\t\t\t     /*nonnull=*/true);\n \n   /* Second, the requested type may not be the owner of its own vptr.\n      If not, convert to the base class that owns it.  We cannot use"}, {"sha": "580a73b4db87ddd4f7c2a08637df4813cd2453c4", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -3594,7 +3594,7 @@ extern void validate_conversion_obstack (void);\n \n /* in class.c */\n extern tree build_base_path\t\t\t(enum tree_code, tree, tree, int);\n-extern tree convert_to_base                     (tree, tree, bool);\n+extern tree convert_to_base                     (tree, tree, bool, bool);\n extern tree convert_to_base_statically (tree, tree);\n extern tree build_vtbl_ref\t\t\t(tree, tree);\n extern tree build_vfn_ref\t\t\t(tree, tree);\n@@ -4267,7 +4267,7 @@ extern tree dubious_conversion_warnings         (tree, tree, const char *, tree,\n extern tree convert_for_initialization\t\t(tree, tree, tree, int, const char *, tree, int);\n extern int comp_ptr_ttypes\t\t\t(tree, tree);\n extern int ptr_reasonably_similar\t\t(tree, tree);\n-extern tree build_ptrmemfunc\t\t\t(tree, tree, int);\n+extern tree build_ptrmemfunc\t\t\t(tree, tree, int, bool);\n extern int cp_type_quals                        (tree);\n extern bool cp_has_mutable_p                     (tree);\n extern bool at_least_as_qualified_p              (tree, tree);\n@@ -4291,6 +4291,7 @@ extern tree non_reference                       (tree);\n extern tree lookup_anon_field                   (tree, tree);\n extern bool invalid_nonstatic_memfn_p           (tree);\n extern tree convert_member_func_to_ptr          (tree, tree);\n+extern tree convert_ptrmem                      (tree, tree, bool, bool);\n \n /* in typeck2.c */\n extern void require_complete_eh_spec_types\t(tree, tree);"}, {"sha": "7f0f64c9c46f767fabf40c8ba95a528036602101", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -217,7 +217,8 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n       return build_nop (type, expr);\n     }\n   else if (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype))\n-    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n+    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n+\t\t\t     /*c_cast_p=*/false);\n   else if (TYPE_PTRMEMFUNC_P (intype))\n     {\n       if (!warn_pmf2ptr)\n@@ -241,7 +242,8 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n   if (integer_zerop (expr))\n     {\n       if (TYPE_PTRMEMFUNC_P (type))\n-\treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n+\treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0,\n+\t\t\t\t /*c_cast_p=*/false);\n \n       if (TYPE_PTRMEM_P (type))\n \t{\n@@ -960,10 +962,9 @@ convert_force (tree type, tree expr, int convtype)\n        || integer_zerop (e)\n        || TYPE_PTRMEMFUNC_P (TREE_TYPE (e)))\n       && TYPE_PTRMEMFUNC_P (type))\n-    {\n-      /* compatible pointer to member functions.  */\n-      return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1);\n-    }\n+    /* compatible pointer to member functions.  */\n+    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), e, 1,\n+\t\t\t     /*c_cast_p=*/1);\n \n   return ocp_convert (type, e, CONV_C_CAST|convtype, LOOKUP_NORMAL);\n }"}, {"sha": "cc91b653aae01646d68e4cb9582b8ecf70216e32", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 59, "deletions": 30, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -52,7 +52,7 @@ static bool comp_except_types (tree, tree, bool);\n static bool comp_array_types (tree, tree, bool);\n static tree common_base_type (tree, tree);\n static tree pointer_diff (tree, tree, tree);\n-static tree get_delta_difference (tree, tree, int);\n+static tree get_delta_difference (tree, tree, bool, bool);\n static void casts_away_constness_r (tree *, tree *);\n static bool casts_away_constness (tree, tree);\n static void maybe_warn_about_returning_address_of_local (tree);\n@@ -4146,7 +4146,8 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t    && TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n \t  {\n \t    build_ptrmemfunc_type (argtype);\n-\t    addr = build_ptrmemfunc (argtype, addr, 0);\n+\t    addr = build_ptrmemfunc (argtype, addr, 0,\n+\t\t\t\t     /*c_cast_p=*/false);\n \t  }\n \n \treturn addr;\n@@ -4485,6 +4486,38 @@ check_for_casting_away_constness (tree src_type, tree dest_type,\n \t   description, src_type, dest_type);\n }\n \n+/* Convert EXPR (an expression with pointer-to-member type) to TYPE\n+   (another pointer-to-member type in the same hierarchy) and return\n+   the converted expression.  If ALLOW_INVERSE_P is permitted, a\n+   pointer-to-derived may be converted to pointer-to-base; otherwise,\n+   only the other direction is permitted.  If C_CAST_P is true, this\n+   conversion is taking place as part of a C-style cast.  */\n+\n+tree \n+convert_ptrmem (tree type, tree expr, bool allow_inverse_p,\n+\t\tbool c_cast_p)\n+{\n+  if (TYPE_PTRMEM_P (type))\n+    {\n+      tree delta;\n+\n+      if (TREE_CODE (expr) == PTRMEM_CST)\n+\texpr = cplus_expand_constant (expr);\n+      delta = get_delta_difference (TYPE_PTRMEM_CLASS_TYPE (TREE_TYPE (expr)),\n+\t\t\t\t    TYPE_PTRMEM_CLASS_TYPE (type), \n+\t\t\t\t    allow_inverse_p,\n+\t\t\t\t    c_cast_p);\n+      if (!integer_zerop (delta))\n+\texpr = cp_build_binary_op (PLUS_EXPR, \n+\t\t\t\t   build_nop (ptrdiff_type_node, expr),\n+\t\t\t\t   delta);\n+      return build_nop (type, expr);\n+    }\n+  else\n+    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, \n+\t\t\t     allow_inverse_p, c_cast_p);\n+}\n+\n /* Perform a static_cast from EXPR to TYPE.  When C_CAST_P is true,\n    this static_cast is being attempted as one of the possible casts\n    allowed by a C-style cast.  (In that case, accessibility of base\n@@ -4691,23 +4724,10 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n       if (can_convert (t1, t2))\n \t{\n \t  if (!c_cast_p)\n-\t    check_for_casting_away_constness (intype, type, diag_fn, desc);\n-\t  if (TYPE_PTRMEM_P (type))\n-\t    {\n-\t      tree delta;\n-\n-\t      if (TREE_CODE (expr) == PTRMEM_CST)\n-\t\texpr = cplus_expand_constant (expr);\n-\t      delta = get_delta_difference (c1, c2, /*force=*/1);\n-\t      if (!integer_zerop (delta))\n-\t\texpr = cp_build_binary_op (PLUS_EXPR, \n-\t\t\t\t\t   build_nop (ptrdiff_type_node, expr),\n-\t\t\t\t\t   delta);\n-\t      return build_nop (type, expr);\n-\t    }\n-\t  else\n-\t    return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, \n-\t\t\t\t     /*force=*/1);\n+\t    check_for_casting_away_constness (intype, type, diag_fn, \n+\t\t\t\t\t      desc);\n+\t  return convert_ptrmem (type, expr, /*allow_inverse_p=*/1,\n+\t\t\t\t c_cast_p);\n \t}\n     }\n     \n@@ -4945,6 +4965,8 @@ build_reinterpret_cast_1 (tree type, tree expr, bool c_cast_p,\n       expr = decl_constant_value (expr);\n       return fold_if_not_in_template (build_nop (type, expr));\n     }\n+  else if (TREE_CODE (type) == VECTOR_TYPE)\n+    return fold_if_not_in_template (convert_to_vector (type, expr));\n   else\n     {\n       if (valid_p)\n@@ -5546,16 +5568,20 @@ build_x_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \f\n /* Get difference in deltas for different pointer to member function\n    types.  Returns an integer constant of type PTRDIFF_TYPE_NODE.  If\n-   the conversion is invalid, the constant is zero.  If FORCE is true,\n-   then allow reverse conversions as well.\n+   the conversion is invalid, the constant is zero.  If\n+   ALLOW_INVERSE_P is true, then allow reverse conversions as well.\n+   If C_CAST_P is true this conversion is taking place as part of a\n+   C-style cast.\n \n    Note that the naming of FROM and TO is kind of backwards; the return\n    value is what we add to a TO in order to get a FROM.  They are named\n    this way because we call this function to find out how to convert from\n    a pointer to member of FROM to a pointer to member of TO.  */\n \n static tree\n-get_delta_difference (tree from, tree to, int force)\n+get_delta_difference (tree from, tree to, \n+\t\t      bool allow_inverse_p,\n+\t\t      bool c_cast_p)\n {\n   tree binfo;\n   tree virt_binfo;\n@@ -5564,19 +5590,20 @@ get_delta_difference (tree from, tree to, int force)\n \n   /* Assume no conversion is required.  */\n   result = integer_zero_node;\n-  binfo = lookup_base (to, from, ba_check, &kind);\n+  binfo = lookup_base (to, from, c_cast_p ? ba_unique : ba_check, &kind);\n   if (kind == bk_inaccessible || kind == bk_ambig)\n     error (\"   in pointer to member function conversion\");\n   else if (!binfo)\n     {\n-      if (!force)\n+      if (!allow_inverse_p)\n \t{\n \t  error_not_base_type (from, to);\n \t  error (\"   in pointer to member conversion\");\n \t}\n       else\n \t{\n-\t  binfo = lookup_base (from, to, ba_check, &kind);\n+\t  binfo = lookup_base (from, to, c_cast_p ? ba_unique : ba_check, \n+\t\t\t       &kind);\n \t  if (binfo)\n \t    {\n \t      virt_binfo = binfo_from_vbase (binfo);\n@@ -5597,7 +5624,7 @@ get_delta_difference (tree from, tree to, int force)\n       else\n \t{\n \t  /* This is a reinterpret cast, we choose to do nothing.  */\n-\t  if (force)\n+\t  if (allow_inverse_p)\n \t    warning (\"pointer to member cast via virtual base %qT\",\n \t\t     BINFO_TYPE (virt_binfo));\n \t  else\n@@ -5648,12 +5675,12 @@ build_ptrmemfunc1 (tree type, tree delta, tree pfn)\n \n    If FORCE is nonzero, then force this conversion, even if\n    we would rather not do it.  Usually set when using an explicit\n-   cast.\n+   cast.  A C-style cast is being processed iff C_CAST_P is true.\n \n    Return error_mark_node, if something goes wrong.  */\n \n tree\n-build_ptrmemfunc (tree type, tree pfn, int force)\n+build_ptrmemfunc (tree type, tree pfn, int force, bool c_cast_p)\n {\n   tree fn;\n   tree pfn_type;\n@@ -5679,7 +5706,8 @@ build_ptrmemfunc (tree type, tree pfn, int force)\n \n       n = get_delta_difference (TYPE_PTRMEMFUNC_OBJECT_TYPE (pfn_type),\n \t\t\t\tTYPE_PTRMEMFUNC_OBJECT_TYPE (to_type),\n-\t\t\t\tforce);\n+\t\t\t\tforce,\n+\t\t\t\tc_cast_p);\n \n       /* We don't have to do any conversion to convert a\n \t pointer-to-member to its own type.  But, we don't want to\n@@ -5754,7 +5782,8 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n   ptr_class = TYPE_PTRMEMFUNC_OBJECT_TYPE (type);\n \n   /* First, calculate the adjustment to the function's class.  */\n-  *delta = get_delta_difference (fn_class, ptr_class, /*force=*/0);\n+  *delta = get_delta_difference (fn_class, ptr_class, /*force=*/0,\n+\t\t\t\t /*c_cast_p=*/0);\n \n   if (!DECL_VIRTUAL_P (fn))\n     *pfn = convert (TYPE_PTRMEMFUNC_FN_TYPE (type), build_addr_func (fn));"}, {"sha": "ae6231295cb96e2a54951013aa66ca64b83aa84f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -1,3 +1,9 @@\n+2004-10-21  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/10841\n+\t* g++.dg/conversion/cast1.C: New test.\n+\t* g++.dg/overload/pmf1.C: Adjust error marker.\n+\n 2004-10-21  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR objc/17923"}, {"sha": "f90b42165a80f34d9b2671fdc1086995698683f5", "filename": "gcc/testsuite/g++.dg/conversion/cast1.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fcast1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fcast1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fcast1.C?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -0,0 +1,22 @@\n+// PR c++/10841\n+\n+int main() {\n+  class Base { \n+  public: \n+    int i, j, k; \n+    void f(); };\n+\n+  class Derived : private Base { \n+  public: \n+    int m, n, p; \n+    void g(); \n+  };\n+\n+  Derived derived;\n+  Base &base = (Base &)derived;\n+  (int Base::*)&Derived::n;\n+  (int Derived::*)&Base::j;\n+  (void (Base::*)(void))&Derived::g;\n+  (void (Derived::*)(void))&Base::f;\n+}\n+"}, {"sha": "d20074931797df1c80cd4cbafd42d816df6d9953", "filename": "gcc/testsuite/g++.dg/overload/pmf1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08e17d9d1121f0ce5869ddf1283db2449a4bc458/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Foverload%2Fpmf1.C?ref=08e17d9d1121f0ce5869ddf1283db2449a4bc458", "patch": "@@ -17,5 +17,5 @@ void f (C) {}         // even though this would be well-formed\n \n int main ()\n {\n-  f (aip);  // { dg-error \"'A' is an inaccessible base of 'B'\" \"\" }\n+  f (aip);  // { dg-error \"'A' is an inaccessible base of 'B'|conversion\" \"\" }\n }"}]}