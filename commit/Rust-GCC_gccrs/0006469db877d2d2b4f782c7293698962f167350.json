{"sha": "0006469db877d2d2b4f782c7293698962f167350", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAwNjQ2OWRiODc3ZDJkMmI0Zjc4MmM3MjkzNjk4OTYyZjE2NzM1MA==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:55:43Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1993-03-23T12:55:43Z"}, "message": "(expand_builtin...\n\n(expand_builtin, BUILT_IN_SAVEREGS): Use these to put the\n\tcode at the start of the function, even when inside a sequence.\n\n\t(apply_args_value): New variable.\n\t(init_expr, save_expr_status, restore_expr_status): Initialize,\n\tsave, and restore apply_args_value.\n\t(expand_builtin): Implement new built-in functions.\n\t(apply_args_mode, apply_result_mode): New variables.\n\t(apply_args_size, apply_result_size, result_vector,\n\texpand_builtin_apply_args, expand_builtin_apply,\n\texpand_builtin_return): New functions.\n\t(INCOMING_REGNO, OUTGOING_REGNO): Supply default definitions.\n\nFrom-SVN: r3845", "tree": {"sha": "d6b5898d29f6de2af6c4850cbad60a7f7cd38801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6b5898d29f6de2af6c4850cbad60a7f7cd38801"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0006469db877d2d2b4f782c7293698962f167350", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006469db877d2d2b4f782c7293698962f167350", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0006469db877d2d2b4f782c7293698962f167350", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0006469db877d2d2b4f782c7293698962f167350/comments", "author": null, "committer": null, "parents": [{"sha": "d12b538233fccee699f04e9e46fe4016ac9f28f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d12b538233fccee699f04e9e46fe4016ac9f28f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d12b538233fccee699f04e9e46fe4016ac9f28f7"}], "stats": {"total": 543, "additions": 533, "deletions": 10}, "files": [{"sha": "8902d82e16a2c7d0ee6b9b6a57acef934c06b205", "filename": "gcc/expr.c", "status": "modified", "additions": 533, "deletions": 10, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0006469db877d2d2b4f782c7293698962f167350/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0006469db877d2d2b4f782c7293698962f167350/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0006469db877d2d2b4f782c7293698962f167350", "patch": "@@ -86,6 +86,9 @@ int inhibit_defer_pop;\n    function calls being expanded by expand_call.  */\n tree cleanups_this_call;\n \n+/* Similarly for __builtin_apply_args.  */\n+static rtx apply_args_value;\n+\n /* Nonzero means __builtin_saveregs has already been done in this function.\n    The value is the pseudoreg containing the value __builtin_saveregs\n    returned.  */\n@@ -128,6 +131,12 @@ static int get_pointer_alignment PROTO((tree, unsigned));\n static tree string_constant\tPROTO((tree, tree *));\n static tree c_strlen\t\tPROTO((tree));\n static rtx expand_builtin  PROTO((tree, rtx, rtx, enum machine_mode, int));\n+static int apply_args_size\tPROTO((void));\n+static int apply_result_size\tPROTO((void));\n+static rtx result_vector\tPROTO((int, rtx));\n+static rtx expand_builtin_apply_args PROTO((void));\n+static rtx expand_builtin_apply\tPROTO((rtx, rtx, rtx));\n+static void expand_builtin_return PROTO((rtx));\n static rtx expand_increment\tPROTO((tree, int));\n static void preexpand_calls\tPROTO((tree));\n static void do_jump_by_parts_greater PROTO((tree, int, rtx, rtx));\n@@ -165,6 +174,14 @@ static enum insn_code movstr_optab[NUM_MACHINE_MODES];\n #ifndef SLOW_UNALIGNED_ACCESS\n #define SLOW_UNALIGNED_ACCESS 0\n #endif\n+\n+/* Register mappings for target machines without register windows.  */\n+#ifndef INCOMING_REGNO\n+#define INCOMING_REGNO(OUT) (OUT)\n+#endif\n+#ifndef OUTGOING_REGNO\n+#define OUTGOING_REGNO(IN) (IN)\n+#endif\n \f\n /* This is run once per compilation to set up which modes can be used\n    directly in memory and to initialize the block move optab.  */\n@@ -267,6 +284,7 @@ init_expr ()\n   inhibit_defer_pop = 0;\n   cleanups_this_call = 0;\n   saveregs_value = 0;\n+  apply_args_value = 0;\n   forced_labels = 0;\n }\n \n@@ -284,12 +302,14 @@ save_expr_status (p)\n   p->inhibit_defer_pop = inhibit_defer_pop;\n   p->cleanups_this_call = cleanups_this_call;\n   p->saveregs_value = saveregs_value;\n+  p->apply_args_value = apply_args_value;\n   p->forced_labels = forced_labels;\n \n   pending_stack_adjust = 0;\n   inhibit_defer_pop = 0;\n   cleanups_this_call = 0;\n   saveregs_value = 0;\n+  apply_args_value = 0;\n   forced_labels = 0;\n }\n \n@@ -304,6 +324,7 @@ restore_expr_status (p)\n   inhibit_defer_pop = p->inhibit_defer_pop;\n   cleanups_this_call = p->cleanups_this_call;\n   saveregs_value = p->saveregs_value;\n+  apply_args_value = p->apply_args_value;\n   forced_labels = p->forced_labels;\n }\n \f\n@@ -6175,6 +6196,83 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n  \n       return target;\n \n+      /* __builtin_apply_args returns block of memory allocated on\n+\t the stack into which is stored the arg pointer, structure\n+\t value address, static chain, and all the registers that might\n+\t possibly be used in performing a function call.  The code is\n+\t moved to the start of the function so the incoming values are\n+\t saved.  */\n+    case BUILT_IN_APPLY_ARGS:\n+      /* Don't do __builtin_apply_args more than once in a function.\n+\t Save the result of the first call and reuse it.  */\n+      if (apply_args_value != 0)\n+\treturn apply_args_value;\n+      {\n+\t/* When this function is called, it means that registers must be\n+\t   saved on entry to this function.  So we migrate the\n+\t   call to the first insn of this function.  */\n+\trtx temp;\n+\trtx seq;\n+\n+\tstart_sequence ();\n+\ttemp = expand_builtin_apply_args ();\n+\tseq = get_insns ();\n+\tend_sequence ();\n+\n+\tapply_args_value = temp;\n+\n+\t/* Put the sequence after the NOTE that starts the function.\n+\t   If this is inside a SEQUENCE, make the outer-level insn\n+\t   chain current, so the code is placed at the start of the\n+\t   function.  */\n+\tpush_topmost_sequence ();\n+\temit_insns_before (seq, NEXT_INSN (get_insns ()));\n+\tpop_topmost_sequence ();\n+\treturn temp;\n+      }\n+\n+      /* __builtin_apply (FUNCTION, ARGUMENTS, ARGSIZE) invokes\n+\t FUNCTION with a copy of the parameters described by\n+\t ARGUMENTS, and ARGSIZE.  It returns a block of memory\n+\t allocated on the stack into which is stored all the registers\n+\t that might possibly be used for returning the result of a\n+\t function.  ARGUMENTS is the value returned by\n+\t __builtin_apply_args.  ARGSIZE is the number of bytes of\n+\t arguments that must be copied.  ??? How should this value be\n+\t computed?  We'll also need a safe worst case value for varargs\n+\t functions.  */\n+    case BUILT_IN_APPLY:\n+      if (arglist == 0\n+\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) != POINTER_TYPE\n+\t  || TREE_CHAIN (arglist) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist)))) != POINTER_TYPE\n+\t  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0\n+\t  || TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))))) != INTEGER_TYPE)\n+\treturn const0_rtx;\n+      else\n+\t{\n+\t  int i;\n+\t  tree t;\n+\t  rtx ops[3];\n+\n+\t  for (t = arglist, i = 0; t; t = TREE_CHAIN (t), i++)\n+\t    ops[i] = expand_expr (TREE_VALUE (t), NULL_RTX, VOIDmode, 0);\n+\n+\t  return expand_builtin_apply (ops[0], ops[1], ops[2]);\n+\t}\n+\n+      /* __builtin_return (RESULT) causes the function to return the\n+\t value described by RESULT.  RESULT is address of the block of\n+\t memory returned by __builtin_apply.  */\n+    case BUILT_IN_RETURN:\n+      if (arglist\n+\t  /* Arg could be non-pointer if user redeclared this fcn wrong.  */\n+\t  && TREE_CODE (TREE_TYPE (TREE_VALUE (arglist))) == POINTER_TYPE)\n+\texpand_builtin_return (expand_expr (TREE_VALUE (arglist),\n+\t\t\t\t\t    NULL_RTX, VOIDmode, 0));\n+      return const0_rtx;\n+\n     case BUILT_IN_SAVEREGS:\n       /* Don't do __builtin_saveregs more than once in a function.\n \t Save the result of the first call and reuse it.  */\n@@ -6218,17 +6316,13 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n \n \tsaveregs_value = temp;\n \n-\t/* This won't work inside a SEQUENCE--it really has to be\n-\t   at the start of the function.  */\n-\tif (in_sequence_p ())\n-\t  {\n-\t    /* Better to do this than to crash.  */\n-\t    error (\"`va_start' used within `({...})'\");\n-\t    return temp;\n-\t  }\n-\n-\t/* Put the sequence after the NOTE that starts the function.  */\n+\t/* Put the sequence after the NOTE that starts the function.\n+\t   If this is inside a SEQUENCE, make the outer-level insn\n+\t   chain current, so the code is placed at the start of the\n+\t   function.  */\n+\tpush_topmost_sequence ();\n \temit_insns_before (seq, NEXT_INSN (get_insns ()));\n+\tpop_topmost_sequence ();\n \treturn temp;\n       }\n \n@@ -6755,6 +6849,435 @@ expand_builtin (exp, target, subtarget, mode, ignore)\n   return expand_call (exp, target, ignore);\n }\n \f\n+/* Built-in functions to perform an untyped call and return.  */\n+\n+/* For each register that may be used for calling a function, this\n+   gives a mode used to copy the register's value.  VOIDmode indicates\n+   the register is not used for calling a function.  If the machine\n+   has register windows, this gives only the outbound registers.\n+   INCOMING_REGNO gives the corresponding inbound register.  */\n+static enum machine_mode apply_args_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* For each register that may be used for returning values, this gives\n+   a mode used to copy the register's value.  VOIDmode indicates the\n+   register is not used for returning values.  If the machine has\n+   register windows, this gives only the outbound registers.\n+   INCOMING_REGNO gives the corresponding inbound register.  */\n+static enum machine_mode apply_result_mode[FIRST_PSEUDO_REGISTER];\n+\n+/* Return the size required for the block returned by __builtin_apply_args,\n+   and initialize apply_args_mode.  */\n+static int\n+apply_args_size ()\n+{\n+  static int size = -1;\n+  int align, regno;\n+  enum machine_mode mode;\n+\n+  /* The values computed by this function never change.  */\n+  if (size < 0)\n+    {\n+      /* The first value is the incoming arg-pointer.  */\n+      size = GET_MODE_SIZE (Pmode);\n+\n+      /* The second value is the structure value address unless this is\n+\t passed as an \"invisible\" first argument.  */\n+      if (struct_value_rtx)\n+\tsize += GET_MODE_SIZE (Pmode);\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (FUNCTION_ARG_REGNO_P (regno))\n+\t  {\n+\t    /* Search for the proper mode for copying this register's\n+\t       value.  I'm not sure this is right, but it works so far.  */\n+\t    enum machine_mode best_mode = VOIDmode;\n+\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t mode != VOIDmode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n+\t      if (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t  && HARD_REGNO_NREGS (regno, mode) == 1)\n+\t\tbest_mode = mode;\n+\n+\t    if (best_mode == VOIDmode)\n+\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t\t   mode != VOIDmode;\n+\t\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t    && (mov_optab->handlers[(int) mode].insn_code\n+\t\t\t!= CODE_FOR_nothing))\n+\t\t  best_mode = mode;\n+\n+\t    mode = best_mode;\n+\t    if (mode == VOIDmode)\n+\t      abort ();\n+\n+\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\t    if (size % align != 0)\n+\t      size = CEIL (size, align) * align;\n+\t    size += GET_MODE_SIZE (mode);\n+\t    apply_args_mode[regno] = mode;\n+\t  }\n+\telse\n+\t  apply_args_mode[regno] = VOIDmode;\n+    }\n+  return size;\n+}\n+\n+/* Return the size required for the block returned by __builtin_apply,\n+   and initialize apply_result_mode.  */\n+static int\n+apply_result_size ()\n+{\n+  static int size = -1;\n+  int align, regno;\n+  enum machine_mode mode;\n+\n+  /* The values computed by this function never change.  */\n+  if (size < 0)\n+    {\n+      size = 0;\n+\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif (FUNCTION_VALUE_REGNO_P (regno))\n+\t  {\n+\t    /* Search for the proper mode for copying this register's\n+\t       value.  I'm not sure this is right, but it works so far.  */\n+\t    enum machine_mode best_mode = VOIDmode;\n+\n+\t    for (mode = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t\t mode != TImode;\n+\t\t mode = GET_MODE_WIDER_MODE (mode))\n+\t      if (HARD_REGNO_MODE_OK (regno, mode))\n+\t\tbest_mode = mode;\n+\n+\t    if (best_mode == VOIDmode)\n+\t      for (mode = GET_CLASS_NARROWEST_MODE (MODE_FLOAT);\n+\t\t   mode != VOIDmode;\n+\t\t   mode = GET_MODE_WIDER_MODE (mode))\n+\t\tif (HARD_REGNO_MODE_OK (regno, mode)\n+\t\t    && (mov_optab->handlers[(int) mode].insn_code\n+\t\t\t!= CODE_FOR_nothing))\n+\t\t  best_mode = mode;\n+\n+\t    mode = best_mode;\n+\t    if (mode == VOIDmode)\n+\t      abort ();\n+\n+\t    align = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\t    if (size % align != 0)\n+\t      size = CEIL (size, align) * align;\n+\t    size += GET_MODE_SIZE (mode);\n+\t    apply_result_mode[regno] = mode;\n+\t  }\n+\telse\n+\t  apply_result_mode[regno] = VOIDmode;\n+\n+      /* Allow targets that use untyped_call and untyped_return to override\n+\t the size so that machine-specific information can be stored here.  */\n+#ifdef APPLY_RESULT_SIZE\n+      size = APPLY_RESULT_SIZE;\n+#endif\n+    }\n+  return size;\n+}\n+\n+#if defined (HAVE_untyped_call) || defined (HAVE_untyped_return)\n+/* Create a vector describing the result block RESULT.  If SAVEP is true,\n+   the result block is used to save the values; otherwise it is used to\n+   restore the values.  */\n+static rtx\n+result_vector (savep, result)\n+     int savep;\n+     rtx result;\n+{\n+  int regno, size, align, nelts;\n+  enum machine_mode mode;\n+  rtx reg, mem;\n+  rtx *savevec = (rtx *) alloca (FIRST_PSEUDO_REGISTER * sizeof (rtx));\n+  \n+  size = nelts = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_result_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx (REG, mode, savep ? INCOMING_REGNO (regno) : regno);\n+\tmem = change_address (result, mode,\n+\t\t\t      plus_constant (XEXP (result, 0), size));\n+\tsavevec[nelts++] = (savep\n+\t\t\t    ? gen_rtx (SET, VOIDmode, mem, reg)\n+\t\t\t    : gen_rtx (SET, VOIDmode, reg, mem));\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+  return gen_rtx (PARALLEL, VOIDmode, gen_rtvec_v (nelts, savevec));\n+}\n+#endif /* HAVE_untyped_call or HAVE_untyped_return */\n+\n+\n+/* Save the state required to perform an untyped call with the same\n+   arguments as were passed to the current function.  */\n+static rtx\n+expand_builtin_apply_args ()\n+{\n+  rtx registers;\n+  int size, align, regno;\n+  enum machine_mode mode;\n+\n+  /* Create a block where the arg-pointer, structure value address,\n+     and argument registers can be saved.  */\n+  registers = assign_stack_local (BLKmode, apply_args_size (), -1);\n+\n+  /* Walk past the arg-pointer and structure value address.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    size += GET_MODE_SIZE (Pmode);\n+\n+  /* Save each register used in calling a function to the block.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_args_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\temit_move_insn (change_address (registers, mode,\n+\t\t\t\t\tplus_constant (XEXP (registers, 0),\n+\t\t\t\t\t\t       size)),\n+\t\t\tgen_rtx (REG, mode, INCOMING_REGNO (regno)));\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Save the arg pointer to the block.  */\n+  emit_move_insn (change_address (registers, Pmode, XEXP (registers, 0)),\n+\t\t  copy_to_reg (virtual_incoming_args_rtx));\n+  size = GET_MODE_SIZE (Pmode);\n+\n+  /* Save the structure value address unless this is passed as an\n+     \"invisible\" first argument.  */\n+  if (struct_value_incoming_rtx)\n+    {\n+      emit_move_insn (change_address (registers, Pmode,\n+\t\t\t\t      plus_constant (XEXP (registers, 0),\n+\t\t\t\t\t\t     size)),\n+\t\t      copy_to_reg (struct_value_incoming_rtx));\n+      size += GET_MODE_SIZE (Pmode);\n+    }\n+\n+  /* Return the address of the block.  */\n+  return copy_addr_to_reg (XEXP (registers, 0));\n+}\n+\n+/* Perform an untyped call and save the state required to perform an\n+   untyped return of whatever value was returned by the given function.  */\n+static rtx\n+expand_builtin_apply (function, arguments, argsize)\n+     rtx function, arguments, argsize;\n+{\n+  int size, align, regno;\n+  enum machine_mode mode;\n+  rtx incoming_args, result, reg, dest, call_insn;\n+  rtx old_stack_level = 0;\n+  rtx use_insns = 0;\n+\n+  /* Create a block where the return registers can be saved.  */\n+  result = assign_stack_local (BLKmode, apply_result_size (), -1);\n+\n+  /* ??? The argsize value should be adjusted here.  */\n+\n+  /* Fetch the arg pointer from the ARGUMENTS block.  */\n+  incoming_args = gen_reg_rtx (Pmode);\n+  emit_move_insn (incoming_args,\n+\t\t  gen_rtx (MEM, Pmode, arguments));\n+#ifndef STACK_GROWS_DOWNWARD\n+  incoming_args = expand_binop (Pmode, add_optab, incoming_args, argsize,\n+\t\t\t\tincoming_args, 0, OPTAB_LIB_WIDEN);\n+#endif\n+\n+  /* Perform postincrements before actually calling the function.  */\n+  emit_queue ();\n+\n+  /* Push a new argument block and copy the arguments.  */\n+  do_pending_stack_adjust ();\n+  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n+\n+  /* Push a block of memory onto the stack to store the memory arguments.\n+     Save the address in a register, and copy the memory arguments.  ??? I\n+     haven't figured out how the calling convention macros effect this,\n+     but it's likely that the source and/or destination addresses in\n+     the block copy will need updating in machine specific ways.  */\n+  dest = copy_addr_to_reg (push_block (argsize, 0, 0));\n+  emit_block_move (gen_rtx (MEM, BLKmode, dest),\n+\t\t   gen_rtx (MEM, BLKmode, incoming_args),\n+\t\t   argsize,\n+\t\t   PARM_BOUNDARY / BITS_PER_UNIT);\n+\n+  /* Refer to the argument block.  */\n+  apply_args_size ();\n+  arguments = gen_rtx (MEM, BLKmode, arguments);\n+\n+  /* Walk past the arg-pointer and structure value address.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    size += GET_MODE_SIZE (Pmode);\n+\n+  /* Restore each of the registers previously saved.  Make USE insns\n+     for each of these registers for use in making the call.  */\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_args_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx (REG, mode, regno);\n+\temit_move_insn (reg,\n+\t\t\tchange_address (arguments, mode,\n+\t\t\t\t\tplus_constant (XEXP (arguments, 0),\n+\t\t\t\t\t\t       size)));\n+\n+\tpush_to_sequence (use_insns);\n+\temit_insn (gen_rtx (USE, VOIDmode, reg));\n+\tuse_insns = get_insns ();\n+\tend_sequence ();\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Restore the structure value address unless this is passed as an\n+     \"invisible\" first argument.  */\n+  size = GET_MODE_SIZE (Pmode);\n+  if (struct_value_rtx)\n+    {\n+      rtx value = gen_reg_rtx (Pmode);\n+      emit_move_insn (value,\n+\t\t      change_address (arguments, Pmode,\n+\t\t\t\t      plus_constant (XEXP (arguments, 0),\n+\t\t\t\t\t\t     size)));\n+      emit_move_insn (struct_value_rtx, value);\n+      if (GET_CODE (struct_value_rtx) == REG)\n+\t{\n+\t  push_to_sequence (use_insns);\n+\t  emit_insn (gen_rtx (USE, VOIDmode, struct_value_rtx));\n+\t  use_insns = get_insns ();\n+\t  end_sequence ();\n+\t}\n+      size += GET_MODE_SIZE (Pmode);\n+    }\n+\n+  /* All arguments and registers used for the call are set up by now!  */\n+  function = prepare_call_address (function, NULL_TREE, &use_insns);\n+\n+  /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n+     and we don't want to load it into a register as an optimization,\n+     because prepare_call_address already did it if it should be done.  */\n+  if (GET_CODE (function) != SYMBOL_REF)\n+    function = memory_address (FUNCTION_MODE, function);\n+\n+  /* Generate the actual call instruction and save the return value.  */\n+#ifdef HAVE_untyped_call\n+  if (HAVE_untyped_call)\n+    emit_call_insn (gen_untyped_call (gen_rtx (MEM, FUNCTION_MODE, function),\n+\t\t\t\t      result, result_vector (1, result)));\n+  else\n+#endif\n+#ifdef HAVE_call_value\n+  if (HAVE_call_value)\n+    {\n+      rtx valreg = 0;\n+\n+      /* Locate the unique return register.  It is not possible to\n+\t express a call that sets more than one return register using\n+\t call_value; use untyped_call for that.  In fact, untyped_call\n+\t only needs to save the return registers in the given block.  */\n+      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\tif ((mode = apply_result_mode[regno]) != VOIDmode)\n+\t  {\n+\t    if (valreg)\n+\t      abort (); /* HAVE_untyped_call required.  */\n+\t    valreg = gen_rtx (REG, mode, regno);\n+\t  }\n+\n+      emit_call_insn (gen_call_value (valreg,\n+\t\t\t\t      gen_rtx (MEM, FUNCTION_MODE, function),\n+\t\t\t\t      const0_rtx, NULL_RTX, const0_rtx));\n+\n+      emit_move_insn (change_address (result, GET_MODE (valreg),\n+\t\t\t\t      XEXP (result, 0)),\n+\t\t      valreg);\n+    }\n+  else\n+#endif\n+    abort ();\n+\n+  /* Find the CALL insn we just emitted and write the USE insns before it.  */\n+  for (call_insn = get_last_insn ();\n+       call_insn && GET_CODE (call_insn) != CALL_INSN;\n+       call_insn = PREV_INSN (call_insn))\n+    ;\n+\n+  if (! call_insn)\n+    abort ();\n+\n+  /* Put the USE insns before the CALL.  */\n+  emit_insns_before (use_insns, call_insn);\n+\n+  /* Restore the stack.  */\n+  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n+\n+  /* Return the address of the result block.  */\n+  return copy_addr_to_reg (XEXP (result, 0));\n+}\n+\n+/* Perform an untyped return.  */\n+static void\n+expand_builtin_return (result)\n+     rtx result;\n+{\n+  int size, align, regno;\n+  enum machine_mode mode;\n+  rtx reg;\n+  rtx use_insns = 0;\n+\n+  apply_result_size ();\n+  result = gen_rtx (MEM, BLKmode, result);\n+\n+#ifdef HAVE_untyped_return\n+  if (HAVE_untyped_return)\n+    {\n+      emit_jump_insn (gen_untyped_return (result, result_vector (0, result)));\n+      emit_barrier ();\n+      return;\n+    }\n+#endif\n+\n+  /* Restore the return value and note that each value is used.  */\n+  size = 0;\n+  for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+    if ((mode = apply_result_mode[regno]) != VOIDmode)\n+      {\n+\talign = GET_MODE_ALIGNMENT (mode) / BITS_PER_UNIT;\n+\tif (size % align != 0)\n+\t  size = CEIL (size, align) * align;\n+\treg = gen_rtx (REG, mode, INCOMING_REGNO (regno));\n+\temit_move_insn (reg,\n+\t\t\tchange_address (result, mode,\n+\t\t\t\t\tplus_constant (XEXP (result, 0),\n+\t\t\t\t\t\t       size)));\n+\n+\tpush_to_sequence (use_insns);\n+\temit_insn (gen_rtx (USE, VOIDmode, reg));\n+\tuse_insns = get_insns ();\n+\tend_sequence ();\n+\tsize += GET_MODE_SIZE (mode);\n+      }\n+\n+  /* Put the USE insns before the return.  */\n+  emit_insns (use_insns);\n+\n+  /* Return whatever values was restored by jumping directly to the end\n+     of the function.  */\n+  expand_null_return ();\n+}\n+\f\n /* Expand code for a post- or pre- increment or decrement\n    and return the RTX for the result.\n    POST is 1 for postinc/decrements and 0 for preinc/decrements.  */"}]}