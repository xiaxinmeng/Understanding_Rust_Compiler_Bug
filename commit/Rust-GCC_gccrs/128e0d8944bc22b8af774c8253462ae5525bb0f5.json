{"sha": "128e0d8944bc22b8af774c8253462ae5525bb0f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTI4ZTBkODk0NGJjMjJiOGFmNzc0YzgyNTM0NjJhZTU1MjViYjBmNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-09-12T21:51:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-09-12T21:51:14Z"}, "message": "re PR fortran/48636 (Enable more inlining with -O2 and higher)\n\n\n\tPR fortran/48636\n\t* gcc.dg/ipa/inlinehint-2.c: New testcase.\n\t* ipa-inline-analysis.c (dump_inline_hints): Dump loop stride.\n\t(set_hint_predicate): New function.\n\t(reset_inline_summary): Reset loop stride.\n\t(remap_predicate_after_duplication): New function.\n\t(remap_hint_predicate_after_duplication): New function.\n\t(inline_node_duplication_hook): Update.\n\t(dump_inline_summary): Dump stride summaries.\n\t(estimate_function_body_sizes): Compute strides.\n\t(remap_hint_predicate): New function.\n\t(inline_merge_summary): Use it.\n\t(inline_read_section): Read stride.\n\t(inline_write_summary): Write stride.\n\t* ipa-inline.c (want_inline_small_function_p): Handle strides.\n\t(edge_badness): Likewise.\n\t* ipa-inline.h (inline_hints_vals): Add stride hint.\n\t(inline_summary): Update stride.\n\nFrom-SVN: r191232", "tree": {"sha": "b96eb907a02e6b06812636a77d534f0a89958844", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b96eb907a02e6b06812636a77d534f0a89958844"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/128e0d8944bc22b8af774c8253462ae5525bb0f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128e0d8944bc22b8af774c8253462ae5525bb0f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/128e0d8944bc22b8af774c8253462ae5525bb0f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/128e0d8944bc22b8af774c8253462ae5525bb0f5/comments", "author": null, "committer": null, "parents": [{"sha": "cb261eb7275388a6a96a4cb388dee97274e05c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb261eb7275388a6a96a4cb388dee97274e05c45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb261eb7275388a6a96a4cb388dee97274e05c45"}], "stats": {"total": 362, "additions": 265, "deletions": 97}, "files": [{"sha": "ff6dd5746b54169e98c0e048823138062c06fffa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -1,3 +1,23 @@\n+2012-09-12  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR fortran/48636\n+\t* ipa-inline-analysis.c (dump_inline_hints): Dump loop stride.\n+\t(set_hint_predicate): New function.\n+\t(reset_inline_summary): Reset loop stride.\n+\t(remap_predicate_after_duplication): New function.\n+\t(remap_hint_predicate_after_duplication): New function.\n+\t(inline_node_duplication_hook): Update.\n+\t(dump_inline_summary): Dump stride summaries.\n+\t(estimate_function_body_sizes): Compute strides.\n+\t(remap_hint_predicate): New function.\n+\t(inline_merge_summary): Use it.\n+\t(inline_read_section): Read stride.\n+\t(inline_write_summary): Write stride.\n+\t* ipa-inline.c (want_inline_small_function_p): Handle strides.\n+\t(edge_badness): Likewise.\n+\t* ipa-inline.h (inline_hints_vals): Add stride hint.\n+\t(inline_summary): Update stride.\n+\n 2012-09-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386.c (x86_prefetch_sse): Change to unsigned char."}, {"sha": "268f0777cfde0aa5f985d2d0123c175c0f04902b", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 216, "deletions": 92, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -634,6 +634,11 @@ dump_inline_hints (FILE *f, inline_hints hints)\n       hints &= ~INLINE_HINT_loop_iterations;\n       fprintf (f, \" loop_iterations\");\n     }\n+  if (hints & INLINE_HINT_loop_stride)\n+    {\n+      hints &= ~INLINE_HINT_loop_stride;\n+      fprintf (f, \" loop_stride\");\n+    }\n   gcc_assert (!hints);\n }\n \n@@ -719,6 +724,26 @@ edge_set_predicate (struct cgraph_edge *e, struct predicate *predicate)\n     }\n }\n \n+/* Set predicate for hint *P.  */\n+\n+static void\n+set_hint_predicate (struct predicate **p, struct predicate new_predicate)\n+{\n+  if (false_predicate_p (&new_predicate)\n+      || true_predicate_p (&new_predicate))\n+    {\n+      if (*p)\n+\tpool_free (edge_predicate_pool, *p);\n+      *p = NULL;\n+    }\n+  else\n+    {\n+      if (!*p)\n+\t*p = (struct predicate *)pool_alloc (edge_predicate_pool);\n+      **p = new_predicate;\n+    }\n+}\n+\n \n /* KNOWN_VALS is partial mapping of parameters of NODE to constant values.\n    KNOWN_AGGS is a vector of aggreggate jump functions for each parameter.\n@@ -953,6 +978,11 @@ reset_inline_summary (struct cgraph_node *node)\n       pool_free (edge_predicate_pool, info->loop_iterations);\n       info->loop_iterations = NULL;\n     }\n+  if (info->loop_stride)\n+    {\n+      pool_free (edge_predicate_pool, info->loop_stride);\n+      info->loop_stride = NULL;\n+    }\n   VEC_free (condition, gc, info->conds);\n   VEC_free (size_time_entry,gc, info->entry);\n   for (e = node->callees; e; e = e->next_callee)\n@@ -975,6 +1005,52 @@ inline_node_removal_hook (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n   memset (info, 0, sizeof (inline_summary_t));\n }\n \n+/* Remap predicate P of former function to be predicate of duplicated functoin.\n+   POSSIBLE_TRUTHS is clause of possible truths in the duplicated node,\n+   INFO is inline summary of the duplicated node.  */\n+\n+static struct predicate\n+remap_predicate_after_duplication (struct predicate *p,\n+\t\t\t\t   clause_t possible_truths,\n+\t\t\t\t   struct inline_summary *info)\n+{\n+  struct predicate new_predicate = true_predicate ();\n+  int j;\n+  for (j = 0; p->clause[j]; j++)\n+    if (!(possible_truths & p->clause[j]))\n+      {\n+\tnew_predicate = false_predicate ();\n+\tbreak;\n+      }\n+    else\n+      add_clause (info->conds, &new_predicate,\n+\t\t  possible_truths & p->clause[j]);\n+  return new_predicate;\n+}\n+\n+/* Same as remap_predicate_after_duplication but handle hint predicate *P.\n+   Additionally care about allocating new memory slot for updated predicate\n+   and set it to NULL when it becomes true or false (and thus uninteresting).\n+ */\n+\n+static void\n+remap_hint_predicate_after_duplication (struct predicate **p,\n+\t\t\t\t\tclause_t possible_truths,\n+\t\t\t\t\tstruct inline_summary *info)\n+{\n+  struct predicate new_predicate;\n+\n+  if (!*p)\n+    return;\n+\n+  new_predicate = remap_predicate_after_duplication (*p,\n+\t\t\t\t\t\t     possible_truths,\n+\t\t\t\t\t\t     info);\n+  /* We do not want to free previous predicate; it is used by node origin.  */\n+  *p = NULL;\n+  set_hint_predicate (p, new_predicate);\n+}\n+\n \n /* Hook that is called by cgraph.c when a node is duplicated.  */\n \n@@ -1042,16 +1118,10 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t to be true.  */\n       for (i = 0; VEC_iterate (size_time_entry, entry, i, e); i++)\n \t{\n-\t  struct predicate new_predicate = true_predicate ();\n-\t  for (j = 0; e->predicate.clause[j]; j++)\n-\t    if (!(possible_truths & e->predicate.clause[j]))\n-\t      {\n-\t\tnew_predicate = false_predicate ();\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      add_clause (info->conds, &new_predicate,\n-\t\t\t  possible_truths & e->predicate.clause[j]);\n+\t  struct predicate new_predicate;\n+\t  new_predicate = remap_predicate_after_duplication (&e->predicate,\n+\t\t\t\t\t\t\t     possible_truths,\n+\t\t\t\t\t\t\t     info);\n \t  if (false_predicate_p (&new_predicate))\n \t    {\n \t      optimized_out_size += e->size;\n@@ -1065,22 +1135,16 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t Also copy constantness arrays.   */\n       for (edge = dst->callees; edge; edge = edge->next_callee)\n \t{\n-\t  struct predicate new_predicate = true_predicate ();\n+\t  struct predicate new_predicate;\n \t  struct inline_edge_summary *es = inline_edge_summary (edge);\n \n \t  if (!edge->inline_failed)\n \t    inlined_to_p = true;\n \t  if (!es->predicate)\n \t    continue;\n-\t  for (j = 0; es->predicate->clause[j]; j++)\n-\t    if (!(possible_truths & es->predicate->clause[j]))\n-\t      {\n-\t\tnew_predicate = false_predicate ();\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      add_clause (info->conds, &new_predicate,\n-\t\t\t  possible_truths & es->predicate->clause[j]);\n+\t  new_predicate = remap_predicate_after_duplication (es->predicate,\n+\t\t\t\t\t\t\t     possible_truths,\n+\t\t\t\t\t\t\t     info);\n \t  if (false_predicate_p (&new_predicate)\n \t      && !false_predicate_p (es->predicate))\n \t    {\n@@ -1097,22 +1161,15 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t Also copy constantness arrays.   */\n       for (edge = dst->indirect_calls; edge; edge = edge->next_callee)\n \t{\n-\t  struct predicate new_predicate = true_predicate ();\n+\t  struct predicate new_predicate;\n \t  struct inline_edge_summary *es = inline_edge_summary (edge);\n \n-\t  if (!edge->inline_failed)\n-\t    inlined_to_p = true;\n+\t  gcc_checking_assert (edge->inline_failed);\n \t  if (!es->predicate)\n \t    continue;\n-\t  for (j = 0; es->predicate->clause[j]; j++)\n-\t    if (!(possible_truths & es->predicate->clause[j]))\n-\t      {\n-\t\tnew_predicate = false_predicate ();\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      add_clause (info->conds, &new_predicate,\n-\t\t\t  possible_truths & es->predicate->clause[j]);\n+\t  new_predicate = remap_predicate_after_duplication (es->predicate,\n+\t\t\t\t\t\t\t     possible_truths,\n+\t\t\t\t\t\t\t     info);\n \t  if (false_predicate_p (&new_predicate)\n \t      && !false_predicate_p (es->predicate))\n \t    {\n@@ -1124,28 +1181,12 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n \t    }\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n-      if (info->loop_iterations)\n-\t{\n-\t  struct predicate new_predicate = true_predicate ();\n-\n-\t  for (j = 0; info->loop_iterations->clause[j]; j++)\n-\t    if (!(possible_truths & info->loop_iterations->clause[j]))\n-\t      {\n-\t\tnew_predicate = false_predicate ();\n-\t\tbreak;\n-\t      }\n-\t    else\n-\t      add_clause (info->conds, &new_predicate,\n-\t\t\t  possible_truths & info->loop_iterations->clause[j]);\n-\t  if (false_predicate_p (&new_predicate)\n-\t      || true_predicate_p (&new_predicate))\n-\t    info->loop_iterations = NULL;\n-\t  else\n-\t    {\n-\t      info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n-\t      *info->loop_iterations = new_predicate;\n-\t    }\n-\t}\n+      remap_hint_predicate_after_duplication (&info->loop_iterations,\n+\t\t\t\t\t      possible_truths,\n+\t\t\t\t\t      info);\n+      remap_hint_predicate_after_duplication (&info->loop_stride,\n+\t\t\t\t\t      possible_truths,\n+\t\t\t\t\t      info);\n \n       /* If inliner or someone after inliner will ever start producing\n \t non-trivial clones, we will get trouble with lack of information\n@@ -1175,8 +1216,14 @@ inline_node_duplication_hook (struct cgraph_node *src, struct cgraph_node *dst,\n       if (info->loop_iterations)\n \t{\n \t  predicate p = *info->loop_iterations;\n-\t  info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n-\t  *info->loop_iterations = p;\n+\t  info->loop_iterations = NULL;\n+\t  set_hint_predicate (&info->loop_iterations, p);\n+\t}\n+      if (info->loop_stride)\n+\t{\n+\t  predicate p = *info->loop_stride;\n+\t  info->loop_stride = NULL;\n+\t  set_hint_predicate (&info->loop_stride, p);\n \t}\n     }\n }\n@@ -1355,6 +1402,11 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n \t  fprintf (f, \"  loop iterations:\");\n \t  dump_predicate (f, s->conds, s->loop_iterations);\n \t}\n+      if (s->loop_stride)\n+\t{\n+\t  fprintf (f, \"  loop stride:\");\n+\t  dump_predicate (f, s->conds, s->loop_stride);\n+\t}\n       fprintf (f, \"  calls:\\n\");\n       dump_inline_edge_summary (f, 4, node, s);\n       fprintf (f, \"\\n\");\n@@ -1851,13 +1903,37 @@ will_be_nonconstant_expr_predicate (struct ipa_node_params *info,\n   if (TREE_CODE (expr) == SSA_NAME)\n     return VEC_index (predicate_t, nonconstant_names,\n                       SSA_NAME_VERSION (expr));\n-  if (BINARY_CLASS_P (expr))\n+  if (BINARY_CLASS_P (expr)\n+      || COMPARISON_CLASS_P (expr))\n+    {\n+      struct predicate p1 = will_be_nonconstant_expr_predicate\n+\t\t\t      (info, summary, TREE_OPERAND (expr, 0),\n+\t\t\t       nonconstant_names);\n+      struct predicate p2;\n+      if (true_predicate_p (&p1))\n+\treturn p1;\n+      p2 = will_be_nonconstant_expr_predicate (info, summary,\n+\t\t\t\t\t       TREE_OPERAND (expr, 1),\n+\t\t\t\t\t       nonconstant_names);\n+      return or_predicates (summary->conds, &p1, &p2);\n+    }\n+  else if (TREE_CODE (expr) == COND_EXPR)\n     {\n-      struct predicate p1 =  will_be_nonconstant_expr_predicate (info, summary, TREE_OPERAND (expr, 0), nonconstant_names);\n+      struct predicate p1 = will_be_nonconstant_expr_predicate\n+\t\t\t      (info, summary, TREE_OPERAND (expr, 0),\n+\t\t\t       nonconstant_names);\n       struct predicate p2;\n       if (true_predicate_p (&p1))\n \treturn p1;\n-      p2 = will_be_nonconstant_expr_predicate (info, summary, TREE_OPERAND (expr, 0), nonconstant_names);\n+      p2 = will_be_nonconstant_expr_predicate (info, summary,\n+\t\t\t\t\t       TREE_OPERAND (expr, 1),\n+\t\t\t\t\t       nonconstant_names);\n+      if (true_predicate_p (&p2))\n+\treturn p2;\n+      p1 = or_predicates (summary->conds, &p1, &p2);\n+      p2 = will_be_nonconstant_expr_predicate (info, summary,\n+\t\t\t\t\t       TREE_OPERAND (expr, 2),\n+\t\t\t\t\t       nonconstant_names);\n       return or_predicates (summary->conds, &p1, &p2);\n     }\n   else\n@@ -2390,6 +2466,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n       struct loop *loop;\n       loop_iterator li;\n       predicate loop_iterations = true_predicate ();\n+      predicate loop_stride = true_predicate ();\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loops_dump (dump_file, NULL, 0);\n@@ -2398,8 +2475,9 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t{\n           VEC (edge, heap) *exits;\n           edge ex;\n-\t  unsigned int j;\n+\t  unsigned int j, i;\n \t  struct tree_niter_desc niter_desc;\n+\t  basic_block *body = get_loop_body (loop);\n \n \t  exits = get_loop_exit_edges (loop);\n           FOR_EACH_VEC_ELT (edge, exits, j, ex)\n@@ -2416,12 +2494,39 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t  loop_iterations = and_predicates (info->conds, &loop_iterations, &will_be_nonconstant);\n \t      }\n           VEC_free (edge, heap, exits);\n+\n+          for (i = 0; i < loop->num_nodes; i++)\n+\t    {\n+\t      gimple_stmt_iterator gsi;\n+\t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t\t{\n+\t\t  gimple stmt = gsi_stmt (gsi);\n+\t\t  affine_iv iv;\n+\t\t  ssa_op_iter iter;\n+\t\t  tree use;\n+\n+\t\t  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\t\t    {\n+\t\t      predicate will_be_nonconstant;\n+\n+\t\t      if (!simple_iv (loop, loop_containing_stmt (stmt), use, &iv, true)\n+\t\t\t  || is_gimple_min_invariant (iv.step))\n+\t\t\tcontinue;\n+\t\t      will_be_nonconstant\n+\t\t       = will_be_nonconstant_expr_predicate (parms_info, info,\n+\t\t\t\t\t\t\t     iv.step, nonconstant_names);\n+\t\t      if (!true_predicate_p (&will_be_nonconstant)\n+\t\t\t  && !false_predicate_p (&will_be_nonconstant))\n+\t\t\t/* This is slightly inprecise.  We may want to represent each loop with\n+\t\t\t   independent predicate.  */\n+\t\t\tloop_stride = and_predicates (info->conds, &loop_stride, &will_be_nonconstant);\n+\t\t    }\n+\t\t}\n+\t    }\n+\t  free (body);\n \t}\n-      if (!true_predicate_p (&loop_iterations))\n-\t{\n-          inline_summary (node)->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n-          *inline_summary (node)->loop_iterations = loop_iterations;\n-\t}\n+      set_hint_predicate (&inline_summary (node)->loop_iterations, loop_iterations);\n+      set_hint_predicate (&inline_summary (node)->loop_stride, loop_stride);\n       scev_finalize ();\n     }\n   inline_summary (node)->self_time = time;\n@@ -2715,6 +2820,9 @@ estimate_node_size_and_time (struct cgraph_node *node,\n   if (info->loop_iterations\n       && !evaluate_predicate (info->loop_iterations, possible_truths))\n     hints |=INLINE_HINT_loop_iterations;\n+  if (info->loop_stride\n+      && !evaluate_predicate (info->loop_stride, possible_truths))\n+    hints |=INLINE_HINT_loop_stride;\n \n   if (time > MAX_TIME * INLINE_TIME_SCALE)\n     time = MAX_TIME * INLINE_TIME_SCALE;\n@@ -3011,6 +3119,37 @@ remap_edge_summaries  (struct cgraph_edge *inlined_edge,\n     }\n }\n \n+/* Same as remap_predicate, but set result into hint *HINT.  */\n+\n+static void\n+remap_hint_predicate (struct inline_summary *info,\n+\t\t      struct inline_summary *callee_info,\n+\t\t      struct predicate **hint,\n+\t\t      VEC (int, heap) *operand_map,\n+\t\t      VEC (int, heap) *offset_map,\n+\t\t      clause_t possible_truths,\n+\t\t      struct predicate *toplev_predicate)\n+{\n+  predicate p;\n+\n+  if (!*hint)\n+    return;\n+  p = remap_predicate (info, callee_info,\n+\t\t       *hint,\n+\t\t       operand_map, offset_map,\n+\t\t       possible_truths,\n+\t\t       toplev_predicate);\n+  if (!false_predicate_p (&p)\n+      && !true_predicate_p (&p))\n+    {\n+      if (!*hint)\n+\tset_hint_predicate (hint, p);\n+      else\n+\t**hint = and_predicates (info->conds, \n+\t\t\t\t *hint,\n+\t\t\t\t &p);\n+    }\n+}\n \n /* We inlined EDGE.  Update summary of the function we inlined into.  */\n \n@@ -3102,28 +3241,14 @@ inline_merge_summary (struct cgraph_edge *edge)\n     }\n   remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n \t\t\toffset_map, clause, &toplev_predicate);\n-  if (callee_info->loop_iterations)\n-    {\n-      predicate p = remap_predicate (info, callee_info,\n-\t\t\t\t     callee_info->loop_iterations,\n-\t\t\t\t     operand_map, offset_map,\n-\t\t\t\t     clause,\n-\t\t\t\t     &toplev_predicate);\n-      if (!false_predicate_p (&p)\n-\t  && !true_predicate_p (&p))\n-\t{\n-\t  if (!info->loop_iterations)\n-\t    {\n-\t      info->loop_iterations\n-\t\t = (struct predicate *)pool_alloc (edge_predicate_pool);\n-\t      *info->loop_iterations = p;\n-\t    }\n-\t  else\n-\t    *info->loop_iterations = and_predicates (info->conds, \n-\t\t\t\t\t\t     info->loop_iterations,\n-\t\t\t\t\t\t     &p);\n-\t}\n-    }\n+  remap_hint_predicate (info, callee_info,\n+\t\t\t&callee_info->loop_iterations,\n+\t\t\toperand_map, offset_map,\n+\t\t\tclause, &toplev_predicate);\n+  remap_hint_predicate (info, callee_info,\n+\t\t\t&callee_info->loop_stride,\n+\t\t\toperand_map, offset_map,\n+\t\t\tclause, &toplev_predicate);\n \n   inline_update_callee_summaries (edge->callee,\n \t\t\t\t  inline_edge_summary (edge)->loop_depth);\n@@ -3595,11 +3720,9 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t}\n      \n       p = read_predicate (&ib);\n-      if (!true_predicate_p (&p))\n-\t{\n-\t  info->loop_iterations = (struct predicate *)pool_alloc (edge_predicate_pool);\n-\t  *info->loop_iterations = p;\n-\t}\n+      set_hint_predicate (&info->loop_iterations, p);\n+      p = read_predicate (&ib);\n+      set_hint_predicate (&info->loop_stride, p);\n       for (e = node->callees; e; e = e->next_callee)\n \tread_inline_edge_summary (&ib, e);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -3747,6 +3870,7 @@ inline_write_summary (void)\n \t      write_predicate (ob, &e->predicate);\n \t    }\n \t  write_predicate (ob, info->loop_iterations);\n+\t  write_predicate (ob, info->loop_stride);\n \t  for (edge = node->callees; edge; edge = edge->next_callee)\n \t    write_inline_edge_summary (ob, edge);\n \t  for (edge = node->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "f5c255ca0b7e16b2f7f5f8a1866a658028b46c06", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -481,7 +481,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n       else if (DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE\n \t       && !(hints & (INLINE_HINT_indirect_call\n-\t\t\t     | INLINE_HINT_loop_iterations)))\n+\t\t\t     | INLINE_HINT_loop_iterations\n+\t\t\t     | INLINE_HINT_loop_stride)))\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n \t  want_inline = false;\n@@ -533,7 +534,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t inlining given function is very profitable.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && growth >= ((hints & (INLINE_HINT_indirect_call\n-\t\t\t\t       | INLINE_HINT_loop_iterations))\n+\t\t\t\t       | INLINE_HINT_loop_iterations\n+\t\t\t\t       | INLINE_HINT_loop_stride))\n \t\t\t     ? MAX (MAX_INLINE_INSNS_AUTO,\n \t\t\t\t    MAX_INLINE_INSNS_SINGLE)\n \t\t\t     : MAX_INLINE_INSNS_AUTO))\n@@ -866,7 +868,8 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t    fprintf (dump_file, \"Badness overflow\\n\");\n \t}\n       if (hints & (INLINE_HINT_indirect_call\n-\t\t   | INLINE_HINT_loop_iterations))\n+\t\t   | INLINE_HINT_loop_iterations\n+\t\t   | INLINE_HINT_loop_stride))\n \tbadness /= 8;\n       if (dump)\n \t{"}, {"sha": "ec9cf4d13ace49967cde9720be144d6d78b1cf9b", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -46,7 +46,8 @@ typedef struct GTY(()) condition\n    They are represtented as bitmap of the following values.  */\n enum inline_hints_vals {\n   INLINE_HINT_indirect_call = 1,\n-  INLINE_HINT_loop_iterations = 2\n+  INLINE_HINT_loop_iterations = 2,\n+  INLINE_HINT_loop_stride = 4\n };\n typedef int inline_hints;\n \n@@ -120,9 +121,12 @@ struct GTY(()) inline_summary\n   conditions conds;\n   VEC(size_time_entry,gc) *entry;\n \n-  /* Predicate on when some loop in the function sbecomes to have known\n+  /* Predicate on when some loop in the function becomes to have known\n      bounds.   */\n   struct predicate * GTY((skip)) loop_iterations;\n+  /* Predicate on when some loop in the function becomes to have known\n+     stride.   */\n+  struct predicate * GTY((skip)) loop_stride;\n };\n \n "}, {"sha": "2ad0dfd292efbfdf03546760a88a7575d09c5198", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -1,3 +1,7 @@\n+2012-09-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/ipa/inlinehint-2.c: New testcase.\n+\n 2012-09-12  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/54445"}, {"sha": "a06d725562948e54cf674d4a802883daec262411", "filename": "gcc/testsuite/gcc.dg/ipa/inlinehint-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/128e0d8944bc22b8af774c8253462ae5525bb0f5/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finlinehint-2.c?ref=128e0d8944bc22b8af774c8253462ae5525bb0f5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-options \"-O3 -c -fdump-ipa-inline-details -fno-early-inlining -fno-ipa-cp\"  } */\n+t(int s, void **p)\n+{\n+  int i;\n+  for (i;i<10000;i+=s)\n+    p[i]=0;\n+}\n+m(void **p)\n+{\n+  t (10, p);\n+}\n+/* { dg-final { scan-ipa-dump \"loop_stride\"  \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */"}]}