{"sha": "ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VlYmRiMDk4MGJlZTMzY2JkN2IwOGRjZDM1MGY0ZmFhNzYzNGYyNw==", "commit": {"author": {"name": "Philip Blundell", "email": "philb@gnu.org", "date": "2001-01-04T20:19:48Z"}, "committer": {"name": "Phil Blundell", "email": "pb@gcc.gnu.org", "date": "2001-01-04T20:19:48Z"}, "message": "arm.c (arm_gen_constant): Prefer to emit constants from bit 31 downwards, if this requires no more insns.\n\n2001-01-04  Philip Blundell  <philb@gnu.org>\n\n\t* config/arm/arm.c (arm_gen_constant): Prefer to emit constants\n\tfrom bit 31 downwards, if this requires no more insns.\n\t(count_insns_for_constant): New helper function for above.\n\nFrom-SVN: r38690", "tree": {"sha": "3ec75373ca28b0ad0d63d95fb668c8f7327670ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3ec75373ca28b0ad0d63d95fb668c8f7327670ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceebdb0980bee33cbd7b08dcd350f4faa7634f27/comments", "author": {"login": "philb", "id": 227468, "node_id": "MDQ6VXNlcjIyNzQ2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/227468?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philb", "html_url": "https://github.com/philb", "followers_url": "https://api.github.com/users/philb/followers", "following_url": "https://api.github.com/users/philb/following{/other_user}", "gists_url": "https://api.github.com/users/philb/gists{/gist_id}", "starred_url": "https://api.github.com/users/philb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philb/subscriptions", "organizations_url": "https://api.github.com/users/philb/orgs", "repos_url": "https://api.github.com/users/philb/repos", "events_url": "https://api.github.com/users/philb/events{/privacy}", "received_events_url": "https://api.github.com/users/philb/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1fd4f141391f8f683be28c3353d6753bd24d6905", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1fd4f141391f8f683be28c3353d6753bd24d6905", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1fd4f141391f8f683be28c3353d6753bd24d6905"}], "stats": {"total": 66, "additions": 63, "deletions": 3}, "files": [{"sha": "6a2c343d36c78dc91125359d0c00641bd28f7ca1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceebdb0980bee33cbd7b08dcd350f4faa7634f27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceebdb0980bee33cbd7b08dcd350f4faa7634f27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "patch": "@@ -1,3 +1,9 @@\n+2001-01-04  Philip Blundell  <philb@gnu.org>\n+\n+\t* config/arm/arm.c (arm_gen_constant): Prefer to emit constants\n+\tfrom bit 31 downwards, if this requires no more insns.\n+\t(count_insns_for_constant): New helper function for above.\n+\n 2001-01-04  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* gencodes.c (output_predicate_decls): Remove empty initializer."}, {"sha": "d71dcd1c1dbeea881cb70803b8027911a95c23d3", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 57, "deletions": 3, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceebdb0980bee33cbd7b08dcd350f4faa7634f27/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceebdb0980bee33cbd7b08dcd350f4faa7634f27/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ceebdb0980bee33cbd7b08dcd350f4faa7634f27", "patch": "@@ -986,6 +986,33 @@ arm_split_constant (code, mode, val, target, source, subtargets)\n   return arm_gen_constant (code, mode, val, target, source, subtargets, 1);\n }\n \n+static int\n+count_insns_for_constant (HOST_WIDE_INT remainder, int i)\n+{\n+  HOST_WIDE_INT temp1;\n+  int num_insns = 0;\n+  do\n+    {\n+      int end;\n+\t  \n+      if (i <= 0)\n+\ti += 32;\n+      if (remainder & (3 << (i - 2)))\n+\t{\n+\t  end = i - 8;\n+\t  if (end < 0)\n+\t    end += 32;\n+\t  temp1 = remainder & ((0x0ff << end)\n+\t\t\t\t    | ((i < end) ? (0xff >> (32 - end)) : 0));\n+\t  remainder &= ~temp1;\n+\t  num_insns++;\n+\t  i -= 6;\n+\t}\n+      i -= 2;\n+    } while (remainder);\n+  return num_insns;\n+}\n+\n /* As above, but extra parameter GENERATE which, if clear, suppresses\n    RTL generation.  */\n static int\n@@ -1466,9 +1493,36 @@ arm_gen_constant (code, mode, val, target, source, subtargets, generate)\n \t  }\n       }\n \n-    /* Now start emitting the insns, starting with the one with the highest\n-       bit set: we do this so that the smallest number will be emitted last;\n-       this is more likely to be combinable with addressing insns.  */\n+    /* So long as it won't require any more insns to do so, it's\n+       desirable to emit a small constant (in bits 0...9) in the last\n+       insn.  This way there is more chance that it can be combined with\n+       a later addressing insn to form a pre-indexed load or store\n+       operation.  Consider:\n+\n+\t       *((volatile int *)0xe0000100) = 1;\n+\t       *((volatile int *)0xe0000110) = 2;\n+\n+       We want this to wind up as:\n+\n+\t\tmov rA, #0xe0000000\n+\t\tmov rB, #1\n+\t\tstr rB, [rA, #0x100]\n+\t\tmov rB, #2\n+\t\tstr rB, [rA, #0x110]\n+\n+       rather than having to synthesize both large constants from scratch.\n+\n+       Therefore, we calculate how many insns would be required to emit\n+       the constant starting from `best_start', and also starting from \n+       zero (ie with bit 31 first to be output).  If `best_start' doesn't \n+       yield a shorter sequence, we may as well use zero.  */\n+    if (best_start != 0\n+\t&& ((((unsigned HOST_WIDE_INT) 1) << best_start) < remainder)\n+\t&& (count_insns_for_constant (remainder, 0) <= \n+\t    count_insns_for_constant (remainder, best_start)))\n+      best_start = 0;\n+\n+    /* Now start emitting the insns.  */\n     i = best_start;\n     do\n       {"}]}