{"sha": "dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGQ0YmE5Mzk4MzlkZGYwYjM0YjZlYTg0N2M1NWY2Yjc3OThhZWZiOQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2007-11-15T12:22:04Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2007-11-15T12:22:04Z"}, "message": "spu.c (spu_emit_branch_or_set): Remove PROCESSOR_CELL condition from HONOR_NANS test.\n\n\t* config/spu/spu.c (spu_emit_branch_or_set): Remove PROCESSOR_CELL\n\tcondition from HONOR_NANS test.\n\t* config/spu/spu.md (ceq_df): Always generate comparison code\n\tinline, including checks for NaNs and infinities.\n\t(cgt_df): Likewise.\n\t(cgt_v2df): Likewise.\n\t(cmpdf): Make this expander unconditional.\n\ntestsuite/\n\t* gcc.target/spu/compare-dp.c: New test.\n\nFrom-SVN: r130198", "tree": {"sha": "0f57310f8091bf926ee60593a87870c6561896f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f57310f8091bf926ee60593a87870c6561896f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/comments", "author": null, "committer": null, "parents": [{"sha": "4a648c5d7df866a1e1b25aa1d73b1b3651461f8a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a648c5d7df866a1e1b25aa1d73b1b3651461f8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a648c5d7df866a1e1b25aa1d73b1b3651461f8a"}], "stats": {"total": 257, "additions": 190, "deletions": 67}, "files": [{"sha": "23ba940d8a7312d7108a70df5ea29382d519cc06", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "patch": "@@ -1,3 +1,13 @@\n+2007-11-15  Sa Liu  <saliu@de.ibm.com>\n+\n+\t* config/spu/spu.c (spu_emit_branch_or_set): Remove PROCESSOR_CELL\n+\tcondition from HONOR_NANS test.\n+\t* config/spu/spu.md (ceq_df): Always generate comparison code\n+\tinline, including checks for NaNs and infinities.\n+\t(cgt_df): Likewise.\n+\t(cgt_v2df): Likewise.\n+\t(cmpdf): Make this expander unconditional.\n+\n 2007-11-15  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa-alias.c (create_overlap_variables_for): Make sure"}, {"sha": "1f2efb65c08b44567c0824a2a04c9460fe89bc99", "filename": "gcc/config/spu/spu.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Fconfig%2Fspu%2Fspu.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Fconfig%2Fspu%2Fspu.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.c?ref=dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "patch": "@@ -765,7 +765,7 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n     {\n     case GE:\n       scode = SPU_GT;\n-      if (HONOR_NANS (op_mode) && spu_arch == PROCESSOR_CELLEDP)\n+      if (HONOR_NANS (op_mode))\n \t{\n \t  reverse_compare = 0;\n \t  reverse_test = 0;\n@@ -780,7 +780,7 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n       break;\n     case LE:\n       scode = SPU_GT;\n-      if (HONOR_NANS (op_mode) && spu_arch == PROCESSOR_CELLEDP)\n+      if (HONOR_NANS (op_mode))\n \t{\n \t  reverse_compare = 1;\n \t  reverse_test = 0;\n@@ -883,23 +883,9 @@ spu_emit_branch_or_set (int is_set, enum rtx_code code, rtx operands[])\n       abort ();\n     }\n \n-  if (GET_MODE (spu_compare_op1) == DFmode)\n-    {\n-      rtx reg = gen_reg_rtx (DFmode);\n-      if ((!flag_unsafe_math_optimizations && spu_arch == PROCESSOR_CELL)\n-\t  || (scode != SPU_GT && scode != SPU_EQ))\n-\tabort ();\n-      if (spu_arch == PROCESSOR_CELL)\n-      {\n-        if (reverse_compare)\n-\t  emit_insn (gen_subdf3 (reg, spu_compare_op1, spu_compare_op0));\n-        else\n-\t  emit_insn (gen_subdf3 (reg, spu_compare_op0, spu_compare_op1));\n-        reverse_compare = 0;\n-        spu_compare_op0 = reg;\n-        spu_compare_op1 = CONST0_RTX (DFmode);\n-      }\n-    }\n+  if (GET_MODE (spu_compare_op1) == DFmode\n+      && (scode != SPU_GT && scode != SPU_EQ))\n+    abort ();\n \n   if (is_set == 0 && spu_compare_op1 == const0_rtx\n       && (GET_MODE (spu_compare_op0) == SImode"}, {"sha": "827e5e8b3681676fd86c0f6ef35f19b873c6cbdc", "filename": "gcc/config/spu/spu.md", "status": "modified", "additions": 161, "deletions": 48, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Fconfig%2Fspu%2Fspu.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Fconfig%2Fspu%2Fspu.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fspu%2Fspu.md?ref=dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "patch": "@@ -2534,34 +2534,72 @@\n   \"\"\n   \"fcmeq\\t%0,%1,%2\")\n \n-;; These implementations of ceq_df and cgt_df do not correctly handle\n-;; NAN or INF.  We will also get incorrect results when the result\n-;; of the double subtract is too small.\n+;; These implementations will ignore checking of NaN or INF if\n+;; compiled with option -ffinite-math-only.\n (define_expand \"ceq_df\"\n   [(set (match_operand:SI 0 \"spu_reg_operand\" \"=r\")\n         (eq:SI (match_operand:DF 1 \"spu_reg_operand\" \"r\")\n                (match_operand:DF 2 \"const_zero_operand\" \"i\")))]\n   \"\"\n {\n-  if (flag_unsafe_math_optimizations && spu_arch == PROCESSOR_CELL)\n-    {\n-      rtx s0_ti = gen_reg_rtx(TImode);\n-      rtx s1_v4 = gen_reg_rtx(V4SImode);\n-      rtx s0_v4 = spu_gen_subreg(V4SImode, s0_ti);\n-      rtx to_ti = gen_reg_rtx(TImode);\n-      rtx to_v4 = gen_reg_rtx(V4SImode);\n-      rtx l_v4 = gen_reg_rtx(V4SImode);\n-      emit_insn (gen_spu_convert (l_v4, operands[1]));\n-      emit_insn (gen_movv4si(s1_v4, spu_const(V4SImode, -0x80000000ll)));\n-      emit_insn (gen_ceq_v4si(s0_v4, l_v4, CONST0_RTX(V4SImode)));\n-      emit_insn (gen_ceq_v4si(s1_v4, l_v4, s1_v4));\n-      emit_insn (gen_rotqby_ti(to_ti, s0_ti, GEN_INT(4)));\n-      emit_insn (gen_spu_convert (to_v4, to_ti));\n-      emit_insn (gen_iorv4si3(s1_v4, s0_v4, s1_v4));\n-      emit_insn (gen_andv4si3(to_v4, to_v4, s1_v4));\n-      emit_insn (gen_spu_convert (operands[0], to_v4));\n-      DONE;\n-    }\n+  if (spu_arch == PROCESSOR_CELL)\n+      {\n+        rtx ra = gen_reg_rtx (V4SImode);\n+        rtx rb = gen_reg_rtx (V4SImode);\n+        rtx temp = gen_reg_rtx (TImode);\n+        rtx temp_v4si = spu_gen_subreg (V4SImode, temp);\n+        rtx temp2 = gen_reg_rtx (V4SImode);\n+        rtx biteq = gen_reg_rtx (V4SImode);\n+        rtx ahi_inf = gen_reg_rtx (V4SImode);\n+        rtx a_nan = gen_reg_rtx (V4SImode);\n+        rtx a_abs = gen_reg_rtx (V4SImode);\n+        rtx b_abs = gen_reg_rtx (V4SImode);\n+        rtx iszero = gen_reg_rtx (V4SImode);\n+        rtx sign_mask = gen_reg_rtx (V4SImode);\n+        rtx nan_mask = gen_reg_rtx (V4SImode);\n+        rtx hihi_promote = gen_reg_rtx (TImode);\n+        rtx pat = spu_const_from_ints (V4SImode, 0x7FFFFFFF, 0xFFFFFFFF,\n+                                                 0x7FFFFFFF, 0xFFFFFFFF);\n+\n+        emit_move_insn (sign_mask, pat);\n+        pat = spu_const_from_ints (V4SImode, 0x7FF00000, 0x0,\n+                                             0x7FF00000, 0x0);\n+        emit_move_insn (nan_mask, pat);\n+        pat = spu_const_from_ints (TImode, 0x00010203, 0x10111213,\n+                                           0x08090A0B, 0x18191A1B);\n+        emit_move_insn (hihi_promote, pat);\n+\n+        emit_insn (gen_spu_convert (ra, operands[1]));\n+        emit_insn (gen_spu_convert (rb, operands[2]));\n+        emit_insn (gen_ceq_v4si (biteq, ra, rb));\n+        emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, biteq),\n+\t\t\t\tGEN_INT (4 * 8)));\n+        emit_insn (gen_andv4si3 (biteq, biteq, temp_v4si));\n+\n+        emit_insn (gen_andv4si3 (a_abs, ra, sign_mask));\n+        emit_insn (gen_andv4si3 (b_abs, rb, sign_mask));\n+\tif (!flag_finite_math_only)\n+          {\n+            emit_insn (gen_clgt_v4si (a_nan, a_abs, nan_mask));\n+            emit_insn (gen_ceq_v4si (ahi_inf, a_abs, nan_mask));\n+            emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, a_nan),\n+                                   GEN_INT (4 * 8)));\n+            emit_insn (gen_andv4si3 (temp2, temp_v4si, ahi_inf));\n+            emit_insn (gen_iorv4si3 (a_nan, a_nan, temp2));\n+\t  }\n+        emit_insn (gen_iorv4si3 (temp2, a_abs, b_abs));\n+        emit_insn (gen_ceq_v4si (iszero, temp2, CONST0_RTX (V4SImode)));\n+        emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, iszero),\n+\t\t\t\tGEN_INT (4 * 8)));\n+        emit_insn (gen_andv4si3 (iszero, iszero, temp_v4si));\n+        emit_insn (gen_iorv4si3 (temp2, biteq, iszero));\n+\tif (!flag_finite_math_only)\n+          {\n+            emit_insn (gen_andc_v4si (temp2, temp2, a_nan));\n+\t  }\n+        emit_insn (gen_shufb (operands[0], temp2, temp2, hihi_promote));\n+        DONE;\n+      }\n })\n \n (define_insn \"ceq_<mode>_celledp\"\n@@ -2777,24 +2815,102 @@ selb\\t%0,%5,%0,%3\"\n                (match_operand:DF 2 \"const_zero_operand\" \"i\")))]\n   \"\"\n {\n-  if (flag_unsafe_math_optimizations && spu_arch == PROCESSOR_CELL)\n+  if (spu_arch == PROCESSOR_CELL)\n     {\n-      rtx s0_ti = gen_reg_rtx(TImode);\n-      rtx s1_v4 = gen_reg_rtx(V4SImode);\n-      rtx s0_v4 = spu_gen_subreg(V4SImode, s0_ti);\n-      rtx to_ti = gen_reg_rtx(TImode);\n-      rtx to_v4 = gen_reg_rtx(V4SImode);\n-      rtx l_v4 = gen_reg_rtx(V4SImode);\n-      emit_insn (gen_spu_convert(l_v4, operands[1]));\n-      emit_insn (gen_ceq_v4si(s0_v4, l_v4, const0_rtx));\n-      emit_insn (gen_cgt_v4si(s1_v4, l_v4, const0_rtx));\n-      emit_insn (gen_rotqby_ti(to_ti, s0_ti, GEN_INT(4)));\n-      emit_insn (gen_spu_convert(to_v4, to_ti));\n-      emit_insn (gen_andc_v4si(to_v4, s0_v4, to_v4));\n-      emit_insn (gen_iorv4si3(to_v4, to_v4, s1_v4));\n-      emit_insn (gen_spu_convert(operands[0], to_v4));\n+      rtx ra = gen_reg_rtx (V4SImode);\n+      rtx rb = gen_reg_rtx (V4SImode);\n+      rtx zero = gen_reg_rtx (V4SImode);\n+      rtx temp = gen_reg_rtx (TImode);\n+      rtx temp_v4si = spu_gen_subreg (V4SImode, temp);\n+      rtx temp2 = gen_reg_rtx (V4SImode);\n+      rtx hi_inf = gen_reg_rtx (V4SImode);\n+      rtx a_nan = gen_reg_rtx (V4SImode);\n+      rtx b_nan = gen_reg_rtx (V4SImode);\n+      rtx a_abs = gen_reg_rtx (V4SImode);\n+      rtx b_abs = gen_reg_rtx (V4SImode);\n+      rtx asel = gen_reg_rtx (V4SImode);\n+      rtx bsel = gen_reg_rtx (V4SImode);\n+      rtx abor = gen_reg_rtx (V4SImode);\n+      rtx bbor = gen_reg_rtx (V4SImode);\n+      rtx gt_hi = gen_reg_rtx (V4SImode);\n+      rtx gt_lo = gen_reg_rtx (V4SImode);\n+      rtx sign_mask = gen_reg_rtx (V4SImode);\n+      rtx nan_mask = gen_reg_rtx (V4SImode);\n+      rtx hi_promote = gen_reg_rtx (TImode);\n+      rtx borrow_shuffle = gen_reg_rtx (TImode);\n+\n+      rtx pat = spu_const_from_ints (V4SImode, 0x7FFFFFFF, 0xFFFFFFFF,\n+                                               0x7FFFFFFF, 0xFFFFFFFF);\n+      emit_move_insn (sign_mask, pat);\n+      pat = spu_const_from_ints (V4SImode, 0x7FF00000, 0x0,\n+                                             0x7FF00000, 0x0);\n+      emit_move_insn (nan_mask, pat);\n+      pat = spu_const_from_ints (TImode, 0x00010203, 0x00010203,\n+                                         0x08090A0B, 0x08090A0B);\n+      emit_move_insn (hi_promote, pat);\n+      pat = spu_const_from_ints (TImode, 0x04050607, 0xC0C0C0C0,\n+                                         0x0C0D0E0F, 0xC0C0C0C0);\n+      emit_move_insn (borrow_shuffle, pat);\n+\n+      emit_insn (gen_spu_convert (ra, operands[1]));\n+      emit_insn (gen_spu_convert (rb, operands[2]));\n+      emit_insn (gen_andv4si3 (a_abs, ra, sign_mask));\n+      emit_insn (gen_andv4si3 (b_abs, rb, sign_mask));\n+\n+      if (!flag_finite_math_only)\n+\t{\n+\t  /* check if ra is NaN  */\n+          emit_insn (gen_ceq_v4si (hi_inf, a_abs, nan_mask));\n+          emit_insn (gen_clgt_v4si (a_nan, a_abs, nan_mask));\n+          emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, a_nan),\n+                                  GEN_INT (4 * 8)));\n+          emit_insn (gen_andv4si3 (temp2, temp_v4si, hi_inf));\n+          emit_insn (gen_iorv4si3 (a_nan, a_nan, temp2));\n+          emit_insn (gen_shufb (a_nan, a_nan, a_nan, hi_promote));\n+\n+\t  /* check if rb is NaN  */\n+          emit_insn (gen_ceq_v4si (hi_inf, b_abs, nan_mask));\n+          emit_insn (gen_clgt_v4si (b_nan, b_abs, nan_mask));\n+          emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, b_nan),\n+                                  GEN_INT (4 * 8)));\n+          emit_insn (gen_andv4si3 (temp2, temp_v4si, hi_inf));\n+          emit_insn (gen_iorv4si3 (b_nan, b_nan, temp2));\n+          emit_insn (gen_shufb (b_nan, b_nan, b_nan, hi_promote));\n+\n+\t  /* check if ra or rb is NaN  */\n+          emit_insn (gen_iorv4si3 (a_nan, a_nan, b_nan));\n+\t}\n+      emit_move_insn (zero, CONST0_RTX (V4SImode));\n+      emit_insn (gen_ashrv4si3 (asel, ra, spu_const (V4SImode, 31)));\n+      emit_insn (gen_shufb (asel, asel, asel, hi_promote));\n+      emit_insn (gen_bg_v4si (abor, zero, a_abs));\n+      emit_insn (gen_shufb (abor, abor, abor, borrow_shuffle));\n+      emit_insn (gen_sfx_v4si (abor, zero, a_abs, abor));\n+      emit_insn (gen_selb (abor, a_abs, abor, asel));\n+\n+      emit_insn (gen_ashrv4si3 (bsel, rb, spu_const (V4SImode, 31)));\n+      emit_insn (gen_shufb (bsel, bsel, bsel, hi_promote));\n+      emit_insn (gen_bg_v4si (bbor, zero, b_abs));\n+      emit_insn (gen_shufb (bbor, bbor, bbor, borrow_shuffle));\n+      emit_insn (gen_sfx_v4si (bbor, zero, b_abs, bbor));\n+      emit_insn (gen_selb (bbor, b_abs, bbor, bsel));\n+\n+      emit_insn (gen_cgt_v4si (gt_hi, abor, bbor));\n+      emit_insn (gen_clgt_v4si (gt_lo, abor, bbor));\n+      emit_insn (gen_ceq_v4si (temp2, abor, bbor));\n+      emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, gt_lo),\n+                                GEN_INT (4 * 8)));\n+      emit_insn (gen_andv4si3 (temp2, temp2, temp_v4si));\n+      emit_insn (gen_iorv4si3 (temp2, gt_hi, temp2));\n+      emit_insn (gen_shufb (temp2, temp2, temp2, hi_promote));\n+      if (!flag_finite_math_only)\n+        {\n+\t  /* correct for NaNs  */\n+          emit_insn (gen_andc_v4si (temp2, temp2, a_nan));\n+\t}\n+      emit_insn (gen_spu_convert (operands[0], temp2));\n       DONE;\n-    } \n+    }\n })\n \n (define_insn \"cgt_<mode>_celledp\"\n@@ -2855,17 +2971,17 @@ selb\\t%0,%5,%0,%3\"\n                                          0x0C0D0E0F, 0xC0C0C0C0);\n       emit_move_insn (borrow_shuffle, pat);\n \n-      emit_insn (gen_andv4si3 (a_nan, ra, sign_mask));\n-      emit_insn (gen_ceq_v4si (hi_inf, a_nan, nan_mask));\n-      emit_insn (gen_clgt_v4si (a_nan, a_nan, nan_mask));\n+      emit_insn (gen_andv4si3 (a_abs, ra, sign_mask));\n+      emit_insn (gen_ceq_v4si (hi_inf, a_abs, nan_mask));\n+      emit_insn (gen_clgt_v4si (a_nan, a_abs, nan_mask));\n       emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, a_nan), \n                                                     GEN_INT (4 * 8)));\n       emit_insn (gen_andv4si3 (temp2, temp_v4si, hi_inf));\n       emit_insn (gen_iorv4si3 (a_nan, a_nan, temp2));\n       emit_insn (gen_shufb (a_nan, a_nan, a_nan, hi_promote));\n-      emit_insn (gen_andv4si3 (b_nan, rb, sign_mask));\n-      emit_insn (gen_ceq_v4si (hi_inf, b_nan, nan_mask));\n-      emit_insn (gen_clgt_v4si (b_nan, b_nan, nan_mask));\n+      emit_insn (gen_andv4si3 (b_abs, rb, sign_mask));\n+      emit_insn (gen_ceq_v4si (hi_inf, b_abs, nan_mask));\n+      emit_insn (gen_clgt_v4si (b_nan, b_abs, nan_mask));\n       emit_insn (gen_rotlti3 (temp, spu_gen_subreg (TImode, b_nan), \n                                                     GEN_INT (4 * 8)));\n       emit_insn (gen_andv4si3 (temp2, temp_v4si, hi_inf));\n@@ -2875,14 +2991,12 @@ selb\\t%0,%5,%0,%3\"\n       emit_move_insn (zero, CONST0_RTX (V4SImode));\n       emit_insn (gen_ashrv4si3 (asel, ra, spu_const (V4SImode, 31)));\n       emit_insn (gen_shufb (asel, asel, asel, hi_promote));\n-      emit_insn (gen_andv4si3 (a_abs, ra, sign_mask));\n       emit_insn (gen_bg_v4si (abor, zero, a_abs));\n       emit_insn (gen_shufb (abor, abor, abor, borrow_shuffle));\n       emit_insn (gen_sfx_v4si (abor, zero, a_abs, abor));\n       emit_insn (gen_selb (abor, a_abs, abor, asel));\n       emit_insn (gen_ashrv4si3 (bsel, rb, spu_const (V4SImode, 31)));\n       emit_insn (gen_shufb (bsel, bsel, bsel, hi_promote));\n-      emit_insn (gen_andv4si3 (b_abs, rb, sign_mask));\n       emit_insn (gen_bg_v4si (bbor, zero, b_abs));\n       emit_insn (gen_shufb (bbor, bbor, bbor, borrow_shuffle));\n       emit_insn (gen_sfx_v4si (bbor, zero, b_abs, bbor));\n@@ -3267,8 +3381,7 @@ selb\\t%0,%4,%0,%3\"\n   [(set (cc0)\n         (compare (match_operand:DF 0 \"register_operand\" \"\")\n                  (match_operand:DF 1 \"register_operand\" \"\")))]\n-  \"(flag_unsafe_math_optimizations && spu_arch == PROCESSOR_CELL) \n-    || spu_arch == PROCESSOR_CELLEDP \"\n+  \"\"\n   \"{\n   spu_compare_op0 = operands[0];\n   spu_compare_op1 = operands[1];"}, {"sha": "d937f4fd4a8701aed24c5921841ac873f2dda672", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "patch": "@@ -1,3 +1,7 @@\n+2007-11-15  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* gcc.target/spu/compare-dp.c: New test.\n+\n 2007-11-14  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.dg/pr33923.c: New test."}, {"sha": "cbc7663b967c42db2e3272ce5d2b4e045392a3c3", "filename": "gcc/testsuite/gcc.target/spu/compare-dp.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dd4ba939839ddf0b34b6ea847c55f6b7798aefb9/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fspu%2Fcompare-dp.c?ref=dd4ba939839ddf0b34b6ea847c55f6b7798aefb9", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-final { scan-assembler-not \"__eqdf2\" } } */\n+\n+/* Ensure double precision comparisons are always inlined.  */\n+\n+int test (double a, double b) __attribute__((noinline));\n+int test (double a, double b)\n+{\n+  return a == b;\n+}"}]}