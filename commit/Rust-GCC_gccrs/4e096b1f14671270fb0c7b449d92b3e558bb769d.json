{"sha": "4e096b1f14671270fb0c7b449d92b3e558bb769d", "node_id": "C_kwDOANBUbNoAKDRlMDk2YjFmMTQ2NzEyNzBmYjBjN2I0NDlkOTJiM2U1NThiYjc2OWQ", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-02-20T14:03:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-02-20T14:03:54Z"}, "message": "Merge #951\n\n951: Add name resolution to slices r=philberty a=philberty\n\nThis is the first part to support slices where we complete the name\r\nresolution of the SliceType with its element as well as the range\r\nexpressions used in construction.\r\n\r\nThis patch also includes separation of the implementation from the\r\nheaders to try and incrementally improve build speed.\r\n\r\nAddresses #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "78a11bc9609835f9d9cec8cb645df08193eece16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78a11bc9609835f9d9cec8cb645df08193eece16"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e096b1f14671270fb0c7b449d92b3e558bb769d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiEkpKCRBK7hj4Ov3rIwAAmZYIAIvkhZmJPZF72uAG0jTybV/N\nY7/WEziMvnw6+9JeQpOBHC/YyrRvQ74PL7UIoEiV6Nf2taUyGmuHPhFDaZqSztvq\nOkuA6Y0IsOj/joUBbYGiX5nxId5Z2E4CnEVNbQ9fl4kZoLzN6he5yVvE3x/cY8a/\nvpQjfBZHz+Zol7Hsb2ZSLFsY7sFe0c5HIi4FOt8nQwRrXMc9GjHcd4sNKCjE45xs\ntHflTP8nsF/UeuzMt1Ion+TY2Mem972C5HP6WS8a7x97+eprVj+w068NDIsmNsd/\nzLVb5mUl4KbGk949BknSoI/vJlb2BQ6sy/RrrGdwfSYwZIr2Sb/CfUio8w40WiE=\n=kjek\n-----END PGP SIGNATURE-----\n", "payload": "tree 78a11bc9609835f9d9cec8cb645df08193eece16\nparent 31387e76090007b12da82d7ef11b042e88df0ba5\nparent 3dd4ce76a69e786b56a9af8b911590fc6410cc97\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1645365834 +0000\ncommitter GitHub <noreply@github.com> 1645365834 +0000\n\nMerge #951\n\n951: Add name resolution to slices r=philberty a=philberty\n\nThis is the first part to support slices where we complete the name\r\nresolution of the SliceType with its element as well as the range\r\nexpressions used in construction.\r\n\r\nThis patch also includes separation of the implementation from the\r\nheaders to try and incrementally improve build speed.\r\n\r\nAddresses #849 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e096b1f14671270fb0c7b449d92b3e558bb769d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e096b1f14671270fb0c7b449d92b3e558bb769d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e096b1f14671270fb0c7b449d92b3e558bb769d/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31387e76090007b12da82d7ef11b042e88df0ba5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31387e76090007b12da82d7ef11b042e88df0ba5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31387e76090007b12da82d7ef11b042e88df0ba5"}, {"sha": "3dd4ce76a69e786b56a9af8b911590fc6410cc97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3dd4ce76a69e786b56a9af8b911590fc6410cc97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3dd4ce76a69e786b56a9af8b911590fc6410cc97"}], "stats": {"total": 1327, "additions": 772, "deletions": 555}, "files": [{"sha": "65c9bbabc14534d145dfb6aaf9e1a085a01ef123", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -81,6 +81,8 @@ GRS_OBJS = \\\n     rust/rust-ast-lower-pattern.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-pattern.o \\\n+    rust/rust-ast-resolve-expr.o \\\n+    rust/rust-ast-resolve-type.o \\\n     rust/rust-hir-type-check.o \\\n     rust/rust-tyty.o \\\n     rust/rust-tyctx.o \\"}, {"sha": "19f8169a9db01de8f7ef2dde1f2a47a3a32f5ec1", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.cc", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.cc?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -0,0 +1,513 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-stmt.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n+#include \"rust-ast-verify-assignee.h\"\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-pattern.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+void\n+ResolveExpr::go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n+\t\t const CanonicalPath &canonical_prefix)\n+{\n+  ResolveExpr resolver (parent, prefix, canonical_prefix);\n+  expr->accept_vis (resolver);\n+}\n+\n+void\n+ResolveExpr::visit (AST::MacroInvocation &expr)\n+{\n+  AST::ASTFragment &fragment = expr.get_fragment ();\n+  for (auto &node : fragment.get_nodes ())\n+    node.accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleIndexExpr &expr)\n+{\n+  resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::TupleExpr &expr)\n+{\n+  if (expr.is_unit ())\n+    return;\n+\n+  for (auto &elem : expr.get_tuple_elems ())\n+    resolve_expr (elem.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::PathInExpression &expr)\n+{\n+  ResolvePath::go (&expr, parent);\n+}\n+\n+void\n+ResolveExpr::visit (AST::QualifiedPathInExpression &expr)\n+{\n+  ResolvePath::go (&expr, parent);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ReturnExpr &expr)\n+{\n+  if (expr.has_returned_expr ())\n+    resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::CallExpr &expr)\n+{\n+  resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n+  auto const &in_params = expr.get_params ();\n+  for (auto &param : in_params)\n+    resolve_expr (param.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::MethodCallExpr &expr)\n+{\n+  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+\n+  if (expr.get_method_name ().has_generic_args ())\n+    {\n+      AST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n+      ResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n+    }\n+\n+  auto const &in_params = expr.get_params ();\n+  for (auto &param : in_params)\n+    resolve_expr (param.get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::AssignmentExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IdentifierExpr &expr)\n+{\n+  if (resolver->get_name_scope ().lookup (\n+\tCanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t&resolved_node))\n+    {\n+      resolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t       Definition{expr.get_node_id (), parent});\n+    }\n+  else if (resolver->get_type_scope ().lookup (\n+\t     CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n+\t     &resolved_node))\n+    {\n+      resolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n+      resolver->insert_new_definition (expr.get_node_id (),\n+\t\t\t\t       Definition{expr.get_node_id (), parent});\n+    }\n+  else\n+    {\n+      rust_error_at (expr.get_locus (), \"failed to find name: %s\",\n+\t\t     expr.as_string ().c_str ());\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::CompoundAssignmentExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+\n+  // need to verify the assignee\n+  VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ComparisonExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::LazyBooleanExpr &expr)\n+{\n+  resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::NegationExpr &expr)\n+{\n+  resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::TypeCastExpr &expr)\n+{\n+  ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExpr &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqElse &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::IfExprConseqIf &expr)\n+{\n+  resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::BlockExpr &expr)\n+{\n+  NodeId scope_node_id = expr.get_node_id ();\n+  resolver->get_name_scope ().push (scope_node_id);\n+  resolver->get_type_scope ().push (scope_node_id);\n+  resolver->get_label_scope ().push (scope_node_id);\n+  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (s->is_item ())\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  for (auto &s : expr.get_statements ())\n+    {\n+      if (!s->is_item ())\n+\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n+\t\t\t CanonicalPath::create_empty ());\n+    }\n+\n+  if (expr.has_tail_expr ())\n+    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n+\n+  resolver->get_name_scope ().pop ();\n+  resolver->get_type_scope ().pop ();\n+  resolver->get_label_scope ().pop ();\n+}\n+\n+void\n+ResolveExpr::visit (AST::UnsafeBlockExpr &expr)\n+{\n+  expr.get_block_expr ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsValues &elems)\n+{\n+  for (auto &elem : elems.get_values ())\n+    resolve_expr (elem.get (), elems.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayExpr &expr)\n+{\n+  expr.get_array_elems ()->accept_vis (*this);\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayIndexExpr &expr)\n+{\n+  resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ArrayElemsCopied &elems)\n+{\n+  resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n+  resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n+}\n+\n+// this this an empty struct constructor like 'S {}'\n+void\n+ResolveExpr::visit (AST::StructExprStruct &struct_expr)\n+{\n+  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+}\n+\n+// this this a struct constructor with fields\n+void\n+ResolveExpr::visit (AST::StructExprStructFields &struct_expr)\n+{\n+  resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n+\n+  if (struct_expr.has_struct_base ())\n+    {\n+      AST::StructBase &base = struct_expr.get_struct_base ();\n+      resolve_expr (base.get_base_struct ().get (), struct_expr.get_node_id ());\n+    }\n+\n+  auto const &struct_fields = struct_expr.get_fields ();\n+  for (auto &struct_field : struct_fields)\n+    {\n+      ResolveStructExprField::go (struct_field.get (),\n+\t\t\t\t  struct_expr.get_node_id (), prefix,\n+\t\t\t\t  canonical_prefix);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::GroupedExpr &expr)\n+{\n+  resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::FieldAccessExpr &expr)\n+{\n+  resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::LoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (expr.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+      resolver->insert_new_definition (label_lifetime_node_id,\n+\t\t\t\t       Definition{label_lifetime_node_id,\n+\t\t\t\t\t\t  label.get_node_id ()});\n+    }\n+  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::BreakExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+\n+  if (expr.has_break_expr ())\n+    resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::WhileLoopExpr &expr)\n+{\n+  if (expr.has_loop_label ())\n+    {\n+      auto label = expr.get_loop_label ();\n+      if (label.get_lifetime ().get_lifetime_type ()\n+\t  != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      auto label_name = label.get_lifetime ().get_lifetime_name ();\n+      auto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n+      resolver->get_label_scope ().insert (\n+\tCanonicalPath::new_seg (label.get_node_id (), label_name),\n+\tlabel_lifetime_node_id, label.get_locus (), false,\n+\t[&] (const CanonicalPath &, NodeId, Location locus) -> void {\n+\t  rust_error_at (label.get_locus (), \"label redefined multiple times\");\n+\t  rust_error_at (locus, \"was defined here\");\n+\t});\n+      resolver->insert_new_definition (label_lifetime_node_id,\n+\t\t\t\t       Definition{label_lifetime_node_id,\n+\t\t\t\t\t\t  label.get_node_id ()});\n+    }\n+  resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::ContinueExpr &expr)\n+{\n+  if (expr.has_label ())\n+    {\n+      auto label = expr.get_label ();\n+      if (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n+\t{\n+\t  rust_error_at (label.get_locus (),\n+\t\t\t \"Labels must be a named lifetime value\");\n+\t  return;\n+\t}\n+\n+      NodeId resolved_node = UNKNOWN_NODEID;\n+      if (!resolver->get_label_scope ().lookup (\n+\t    CanonicalPath::new_seg (label.get_node_id (),\n+\t\t\t\t    label.get_lifetime_name ()),\n+\t    &resolved_node))\n+\t{\n+\t  rust_error_at (expr.get_label ().get_locus (),\n+\t\t\t \"failed to resolve label\");\n+\t  return;\n+\t}\n+      resolver->insert_resolved_label (label.get_node_id (), resolved_node);\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::BorrowExpr &expr)\n+{\n+  resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::DereferenceExpr &expr)\n+{\n+  resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::MatchExpr &expr)\n+{\n+  resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n+  for (auto &match_case : expr.get_match_cases ())\n+    {\n+      // each arm is in its own scope\n+      NodeId scope_node_id = match_case.get_node_id ();\n+      resolver->get_name_scope ().push (scope_node_id);\n+      resolver->get_type_scope ().push (scope_node_id);\n+      resolver->get_label_scope ().push (scope_node_id);\n+      resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n+      resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n+      resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n+\n+      // resolve\n+      AST::MatchArm &arm = match_case.get_arm ();\n+      if (arm.has_match_arm_guard ())\n+\tresolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n+\n+      // insert any possible new patterns\n+      for (auto &pattern : arm.get_patterns ())\n+\t{\n+\t  PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n+\t}\n+\n+      // resolve the body\n+      resolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n+\n+      // done\n+      resolver->get_name_scope ().pop ();\n+      resolver->get_type_scope ().pop ();\n+      resolver->get_label_scope ().pop ();\n+    }\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromToExpr &expr)\n+{\n+  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromExpr &expr)\n+{\n+  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeToExpr &expr)\n+{\n+  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFullExpr &expr)\n+{\n+  // nothing to do\n+}\n+\n+void\n+ResolveExpr::visit (AST::RangeFromToInclExpr &expr)\n+{\n+  resolve_expr (expr.get_from_expr ().get (), expr.get_node_id ());\n+  resolve_expr (expr.get_to_expr ().get (), expr.get_node_id ());\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "d8bd203c7369ba24e1e60f05889c28b8a5f45089", "filename": "gcc/rust/resolve/rust-ast-resolve-expr.h", "status": "modified", "additions": 44, "deletions": 350, "changes": 394, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-expr.h?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -21,10 +21,6 @@\n \n #include \"rust-ast-resolve-base.h\"\n #include \"rust-ast-full.h\"\n-#include \"rust-ast-resolve-struct-expr-field.h\"\n-#include \"rust-ast-verify-assignee.h\"\n-#include \"rust-ast-resolve-type.h\"\n-#include \"rust-ast-resolve-pattern.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -64,393 +60,91 @@ class ResolveExpr : public ResolverBase\n \n public:\n   static void go (AST::Expr *expr, NodeId parent, const CanonicalPath &prefix,\n-\t\t  const CanonicalPath &canonical_prefix)\n-  {\n-    ResolveExpr resolver (parent, prefix, canonical_prefix);\n-    expr->accept_vis (resolver);\n-  };\n+\t\t  const CanonicalPath &canonical_prefix);\n \n-  void visit (AST::MacroInvocation &expr) override\n-  {\n-    AST::ASTFragment &fragment = expr.get_fragment ();\n-    for (auto &node : fragment.get_nodes ())\n-      node.accept_vis (*this);\n-  }\n+  void visit (AST::MacroInvocation &expr) override;\n \n-  void visit (AST::TupleIndexExpr &expr) override\n-  {\n-    resolve_expr (expr.get_tuple_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::TupleIndexExpr &expr) override;\n \n-  void visit (AST::TupleExpr &expr) override\n-  {\n-    if (expr.is_unit ())\n-      return;\n+  void visit (AST::TupleExpr &expr) override;\n \n-    for (auto &elem : expr.get_tuple_elems ())\n-      resolve_expr (elem.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::PathInExpression &expr) override;\n \n-  void visit (AST::PathInExpression &expr) override\n-  {\n-    ResolvePath::go (&expr, parent);\n-  }\n+  void visit (AST::QualifiedPathInExpression &expr) override;\n \n-  void visit (AST::QualifiedPathInExpression &expr) override\n-  {\n-    ResolvePath::go (&expr, parent);\n-  }\n+  void visit (AST::ReturnExpr &expr) override;\n \n-  void visit (AST::ReturnExpr &expr) override\n-  {\n-    if (expr.has_returned_expr ())\n-      resolve_expr (expr.get_returned_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::CallExpr &expr) override;\n \n-  void visit (AST::CallExpr &expr) override\n-  {\n-    resolve_expr (expr.get_function_expr ().get (), expr.get_node_id ());\n-    auto const &in_params = expr.get_params ();\n-    for (auto &param : in_params)\n-      resolve_expr (param.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::MethodCallExpr &expr) override;\n \n-  void visit (AST::MethodCallExpr &expr) override\n-  {\n-    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n+  void visit (AST::AssignmentExpr &expr) override;\n \n-    if (expr.get_method_name ().has_generic_args ())\n-      {\n-\tAST::GenericArgs &args = expr.get_method_name ().get_generic_args ();\n-\tResolveTypeToCanonicalPath::type_resolve_generic_args (args);\n-      }\n+  void visit (AST::IdentifierExpr &expr) override;\n \n-    auto const &in_params = expr.get_params ();\n-    for (auto &param : in_params)\n-      resolve_expr (param.get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ArithmeticOrLogicalExpr &expr) override;\n \n-  void visit (AST::AssignmentExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  void visit (AST::CompoundAssignmentExpr &expr) override;\n \n-    // need to verify the assignee\n-    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ComparisonExpr &expr) override;\n \n-  void visit (AST::IdentifierExpr &expr) override\n-  {\n-    if (resolver->get_name_scope ().lookup (\n-\t  CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n-\t  &resolved_node))\n-      {\n-\tresolver->insert_resolved_name (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    else if (resolver->get_type_scope ().lookup (\n-\t       CanonicalPath::new_seg (expr.get_node_id (), expr.as_string ()),\n-\t       &resolved_node))\n-      {\n-\tresolver->insert_resolved_type (expr.get_node_id (), resolved_node);\n-\tresolver->insert_new_definition (expr.get_node_id (),\n-\t\t\t\t\t Definition{expr.get_node_id (),\n-\t\t\t\t\t\t    parent});\n-      }\n-    else\n-      {\n-\trust_error_at (expr.get_locus (), \"failed to find name: %s\",\n-\t\t       expr.as_string ().c_str ());\n-      }\n-  }\n+  void visit (AST::LazyBooleanExpr &expr) override;\n \n-  void visit (AST::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::NegationExpr &expr) override;\n \n-  void visit (AST::CompoundAssignmentExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n+  void visit (AST::TypeCastExpr &expr) override;\n \n-    // need to verify the assignee\n-    VerifyAsignee::go (expr.get_left_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExpr &expr) override;\n \n-  void visit (AST::ComparisonExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExprConseqElse &expr) override;\n \n-  void visit (AST::LazyBooleanExpr &expr) override\n-  {\n-    resolve_expr (expr.get_left_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_right_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::IfExprConseqIf &expr) override;\n \n-  void visit (AST::NegationExpr &expr) override\n-  {\n-    resolve_expr (expr.get_negated_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::BlockExpr &expr) override;\n \n-  void visit (AST::TypeCastExpr &expr) override\n-  {\n-    ResolveType::go (expr.get_type_to_cast_to ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_casted_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::UnsafeBlockExpr &expr) override;\n \n-  void visit (AST::IfExpr &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ArrayElemsValues &elems) override;\n \n-  void visit (AST::IfExprConseqElse &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_else_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ArrayExpr &expr) override;\n \n-  void visit (AST::IfExprConseqIf &expr) override\n-  {\n-    resolve_expr (expr.get_condition_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_if_block ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_conseq_if_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ArrayIndexExpr &expr) override;\n \n-  void visit (AST::BlockExpr &expr) override;\n+  void visit (AST::ArrayElemsCopied &elems) override;\n \n-  void visit (AST::UnsafeBlockExpr &expr) override\n-  {\n-    expr.get_block_expr ()->accept_vis (*this);\n-  }\n+  // this this an empty struct constructor like 'S {}'\n+  void visit (AST::StructExprStruct &struct_expr) override;\n \n-  void visit (AST::ArrayElemsValues &elems) override\n-  {\n-    for (auto &elem : elems.get_values ())\n-      resolve_expr (elem.get (), elems.get_node_id ());\n-  }\n+  // this this a struct constructor with fields\n+  void visit (AST::StructExprStructFields &struct_expr) override;\n \n-  void visit (AST::ArrayExpr &expr) override\n-  {\n-    expr.get_array_elems ()->accept_vis (*this);\n-  }\n+  void visit (AST::GroupedExpr &expr) override;\n \n-  void visit (AST::ArrayIndexExpr &expr) override\n-  {\n-    resolve_expr (expr.get_array_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_index_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::FieldAccessExpr &expr) override;\n \n-  void visit (AST::ArrayElemsCopied &elems) override\n-  {\n-    resolve_expr (elems.get_num_copies ().get (), elems.get_node_id ());\n-    resolve_expr (elems.get_elem_to_copy ().get (), elems.get_node_id ());\n-  }\n+  void visit (AST::LoopExpr &expr) override;\n \n-  // this this an empty struct constructor like 'S {}'\n-  void visit (AST::StructExprStruct &struct_expr) override\n-  {\n-    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n-  }\n+  void visit (AST::BreakExpr &expr) override;\n \n-  // this this a struct constructor with fields\n-  void visit (AST::StructExprStructFields &struct_expr) override\n-  {\n-    resolve_expr (&struct_expr.get_struct_name (), struct_expr.get_node_id ());\n-\n-    if (struct_expr.has_struct_base ())\n-      {\n-\tAST::StructBase &base = struct_expr.get_struct_base ();\n-\tresolve_expr (base.get_base_struct ().get (),\n-\t\t      struct_expr.get_node_id ());\n-      }\n-\n-    auto const &struct_fields = struct_expr.get_fields ();\n-    for (auto &struct_field : struct_fields)\n-      {\n-\tResolveStructExprField::go (struct_field.get (),\n-\t\t\t\t    struct_expr.get_node_id (), prefix,\n-\t\t\t\t    canonical_prefix);\n-      }\n-  }\n+  void visit (AST::WhileLoopExpr &expr) override;\n \n-  void visit (AST::GroupedExpr &expr) override\n-  {\n-    resolve_expr (expr.get_expr_in_parens ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::ContinueExpr &expr) override;\n \n-  void visit (AST::FieldAccessExpr &expr) override\n-  {\n-    resolve_expr (expr.get_receiver_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::BorrowExpr &expr) override;\n \n-  void visit (AST::LoopExpr &expr) override\n-  {\n-    if (expr.has_loop_label ())\n-      {\n-\tauto label = expr.get_loop_label ();\n-\tif (label.get_lifetime ().get_lifetime_type ()\n-\t    != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tauto label_name = label.get_lifetime ().get_lifetime_name ();\n-\tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n-\tresolver->get_label_scope ().insert (\n-\t  CanonicalPath::new_seg (expr.get_node_id (), label_name),\n-\t  label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"label redefined multiple times\");\n-\t    rust_error_at (locus, \"was defined here\");\n-\t  });\n-\tresolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t\t Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t    label.get_node_id ()});\n-      }\n-    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::DereferenceExpr &expr) override;\n \n-  void visit (AST::BreakExpr &expr) override\n-  {\n-    if (expr.has_label ())\n-      {\n-\tauto label = expr.get_label ();\n-\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath::new_seg (label.get_node_id (),\n-\t\t\t\t      label.get_lifetime_name ()),\n-\t      &resolved_node))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to resolve label\");\n-\t    return;\n-\t  }\n-\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n-      }\n-\n-    if (expr.has_break_expr ())\n-      resolve_expr (expr.get_break_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::MatchExpr &expr) override;\n \n-  void visit (AST::WhileLoopExpr &expr) override\n-  {\n-    if (expr.has_loop_label ())\n-      {\n-\tauto label = expr.get_loop_label ();\n-\tif (label.get_lifetime ().get_lifetime_type ()\n-\t    != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tauto label_name = label.get_lifetime ().get_lifetime_name ();\n-\tauto label_lifetime_node_id = label.get_lifetime ().get_node_id ();\n-\tresolver->get_label_scope ().insert (\n-\t  CanonicalPath::new_seg (label.get_node_id (), label_name),\n-\t  label_lifetime_node_id, label.get_locus (), false,\n-\t  [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"label redefined multiple times\");\n-\t    rust_error_at (locus, \"was defined here\");\n-\t  });\n-\tresolver->insert_new_definition (label_lifetime_node_id,\n-\t\t\t\t\t Definition{label_lifetime_node_id,\n-\t\t\t\t\t\t    label.get_node_id ()});\n-      }\n-    resolve_expr (expr.get_predicate_expr ().get (), expr.get_node_id ());\n-    resolve_expr (expr.get_loop_block ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::RangeFromToExpr &expr) override;\n \n-  void visit (AST::ContinueExpr &expr) override\n-  {\n-    if (expr.has_label ())\n-      {\n-\tauto label = expr.get_label ();\n-\tif (label.get_lifetime_type () != AST::Lifetime::LifetimeType::NAMED)\n-\t  {\n-\t    rust_error_at (label.get_locus (),\n-\t\t\t   \"Labels must be a named lifetime value\");\n-\t    return;\n-\t  }\n-\n-\tNodeId resolved_node = UNKNOWN_NODEID;\n-\tif (!resolver->get_label_scope ().lookup (\n-\t      CanonicalPath::new_seg (label.get_node_id (),\n-\t\t\t\t      label.get_lifetime_name ()),\n-\t      &resolved_node))\n-\t  {\n-\t    rust_error_at (expr.get_label ().get_locus (),\n-\t\t\t   \"failed to resolve label\");\n-\t    return;\n-\t  }\n-\tresolver->insert_resolved_label (label.get_node_id (), resolved_node);\n-      }\n-  }\n+  void visit (AST::RangeFromExpr &expr) override;\n \n-  void visit (AST::BorrowExpr &expr) override\n-  {\n-    resolve_expr (expr.get_borrowed_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::RangeToExpr &expr) override;\n \n-  void visit (AST::DereferenceExpr &expr) override\n-  {\n-    resolve_expr (expr.get_dereferenced_expr ().get (), expr.get_node_id ());\n-  }\n+  void visit (AST::RangeFullExpr &expr) override;\n \n-  void visit (AST::MatchExpr &expr) override\n-  {\n-    resolve_expr (expr.get_scrutinee_expr ().get (), expr.get_node_id ());\n-    for (auto &match_case : expr.get_match_cases ())\n-      {\n-\t// each arm is in its own scope\n-\tNodeId scope_node_id = match_case.get_node_id ();\n-\tresolver->get_name_scope ().push (scope_node_id);\n-\tresolver->get_type_scope ().push (scope_node_id);\n-\tresolver->get_label_scope ().push (scope_node_id);\n-\tresolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-\tresolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-\tresolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-\t// resolve\n-\tAST::MatchArm &arm = match_case.get_arm ();\n-\tif (arm.has_match_arm_guard ())\n-\t  resolve_expr (arm.get_guard_expr ().get (), expr.get_node_id ());\n-\n-\t// insert any possible new patterns\n-\tfor (auto &pattern : arm.get_patterns ())\n-\t  {\n-\t    PatternDeclaration::go (pattern.get (), expr.get_node_id ());\n-\t  }\n-\n-\t// resolve the body\n-\tresolve_expr (match_case.get_expr ().get (), expr.get_node_id ());\n-\n-\t// done\n-\tresolver->get_name_scope ().pop ();\n-\tresolver->get_type_scope ().pop ();\n-\tresolver->get_label_scope ().pop ();\n-      }\n-  }\n+  void visit (AST::RangeFromToInclExpr &expr) override;\n \n protected:\n   void resolve_expr (AST::Expr *e, NodeId parent)"}, {"sha": "252d1cae8aa969e906820d4eae0a10e7d0800791", "filename": "gcc/rust/resolve/rust-ast-resolve-type.cc", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.cc?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -0,0 +1,207 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-resolve-type.h\"\n+#include \"rust-ast-resolve-expr.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// rust-ast-resolve-type.h\n+\n+std::string\n+ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n+{\n+  std::string buf;\n+\n+  size_t i = 0;\n+  size_t total = args.get_type_args ().size ();\n+\n+  for (auto &ty_arg : args.get_type_args ())\n+    {\n+      buf += ty_arg->as_string ();\n+      if ((i + 1) < total)\n+\tbuf += \",\";\n+\n+      i++;\n+    }\n+\n+  return \"<\" + buf + \">\";\n+}\n+\n+bool\n+ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n+{\n+  for (auto &gt : args.get_type_args ())\n+    {\n+      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n+      // FIXME error handling here for inference variable since they do not have\n+      // a node to resolve to\n+      // if (resolved == UNKNOWN_NODEID) return false;\n+    }\n+  return true;\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  if (!seg.has_generic_args ())\n+    {\n+      auto ident_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ());\n+      result = result.append (ident_segment);\n+      return;\n+    }\n+\n+  if (type_resolve_generic_args_flag)\n+    {\n+      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n+      failure_flag = !ok;\n+    }\n+\n+  if (include_generic_args_flag)\n+    {\n+      std::string generics\n+\t= canonicalize_generic_args (seg.get_generic_args ());\n+      auto generic_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ()\n+\t\t\t\t    + \"::\" + generics);\n+      result = result.append (generic_segment);\n+      return;\n+    }\n+\n+  auto ident_segment\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_segment);\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n+{\n+  if (seg.is_error ())\n+    {\n+      failure_flag = true;\n+      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n+\t\t     seg.as_string ().c_str ());\n+      return;\n+    }\n+\n+  CanonicalPath ident_seg\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_seg);\n+}\n+\n+void\n+ResolveType::visit (AST::ArrayType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+  // FIXME\n+  // the capacity expr can contain block-expr with functions but these should be\n+  // folded via constexpr code\n+  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n+\t\t   CanonicalPath::create_empty (),\n+\t\t   CanonicalPath::create_empty ());\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n+{\n+  NodeId bound_resolved_id\n+    = ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n+  ok = bound_resolved_id != UNKNOWN_NODEID;\n+}\n+\n+void\n+ResolveType::visit (AST::TraitObjectType &type)\n+{\n+  ok = true;\n+  for (auto &bound : type.get_type_param_bounds ())\n+    {\n+      /* NodeId bound_resolved_id = */\n+      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n+    }\n+}\n+\n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n+{\n+  auto inner_type\n+    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n+\t\t\t\t\t   include_generic_args_flag,\n+\t\t\t\t\t   type_resolve_generic_args_flag);\n+\n+  std::string segment_string (\"&\");\n+  if (ref.get_has_mut ())\n+    segment_string += \"mut \";\n+\n+  segment_string += inner_type.get ();\n+\n+  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n+  result = result.append (ident_seg);\n+}\n+\n+void\n+ResolveType::visit (AST::ReferenceType &type)\n+{\n+  type.get_type_referenced ()->accept_vis (*this);\n+\n+  if (canonical_path != nullptr && canonical_path->size () > 0)\n+    {\n+      std::string seg = canonical_path->get ();\n+      *canonical_path = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n+    }\n+}\n+\n+void\n+ResolveType::visit (AST::RawPointerType &type)\n+{\n+  type.get_type_pointed_to ()->accept_vis (*this);\n+\n+  if (canonical_path != nullptr && canonical_path->size () > 0)\n+    {\n+      std::string seg = canonical_path->get ();\n+      *canonical_path = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n+    }\n+}\n+\n+void\n+ResolveType::visit (AST::InferredType &type)\n+{\n+  ok = true;\n+}\n+\n+void\n+ResolveType::visit (AST::SliceType &type)\n+{\n+  type.get_elem_type ()->accept_vis (*this);\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "d835e00c77c3f0289cb544485bf1405aec996e5b", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 5, "deletions": 23, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -382,36 +382,18 @@ class ResolveType : public ResolverBase\n \n   void visit (AST::ArrayType &type) override;\n \n-  void visit (AST::ReferenceType &type) override\n-  {\n-    type.get_type_referenced ()->accept_vis (*this);\n-\n-    if (canonical_path != nullptr && canonical_path->size () > 0)\n-      {\n-\tstd::string seg = canonical_path->get ();\n-\t*canonical_path\n-\t  = CanonicalPath::new_seg (type.get_node_id (), \"&\" + seg);\n-      }\n-  }\n+  void visit (AST::ReferenceType &type) override;\n \n-  void visit (AST::InferredType &type) override { ok = true; }\n+  void visit (AST::InferredType &type) override;\n \n-  void visit (AST::RawPointerType &type) override\n-  {\n-    type.get_type_pointed_to ()->accept_vis (*this);\n-\n-    if (canonical_path != nullptr && canonical_path->size () > 0)\n-      {\n-\tstd::string seg = canonical_path->get ();\n-\t*canonical_path\n-\t  = CanonicalPath::new_seg (type.get_node_id (), \"*\" + seg);\n-      }\n-  }\n+  void visit (AST::RawPointerType &type) override;\n \n   void visit (AST::TraitObjectTypeOneBound &type) override;\n \n   void visit (AST::TraitObjectType &type) override;\n \n+  void visit (AST::SliceType &type) override;\n+\n private:\n   ResolveType (NodeId parent, bool canonicalize_type_with_generics,\n \t       CanonicalPath *canonical_path)"}, {"sha": "094fa4a2946b17d6885333ee586857c2fb90a665", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 1, "deletions": 182, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e096b1f14671270fb0c7b449d92b3e558bb769d/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=4e096b1f14671270fb0c7b449d92b3e558bb769d", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-ast-resolve-toplevel.h\"\n #include \"rust-ast-resolve-item.h\"\n #include \"rust-ast-resolve-expr.h\"\n+#include \"rust-ast-resolve-struct-expr-field.h\"\n \n #define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n   do                                                                           \\\n@@ -388,41 +389,6 @@ NameResolution::go (AST::Crate &crate)\n     ResolveItem::go (it->get (), CanonicalPath::create_empty (), crate_prefix);\n }\n \n-// rust-ast-resolve-expr.h\n-\n-void\n-ResolveExpr::visit (AST::BlockExpr &expr)\n-{\n-  NodeId scope_node_id = expr.get_node_id ();\n-  resolver->get_name_scope ().push (scope_node_id);\n-  resolver->get_type_scope ().push (scope_node_id);\n-  resolver->get_label_scope ().push (scope_node_id);\n-  resolver->push_new_name_rib (resolver->get_name_scope ().peek ());\n-  resolver->push_new_type_rib (resolver->get_type_scope ().peek ());\n-  resolver->push_new_label_rib (resolver->get_type_scope ().peek ());\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n-\t\t\t CanonicalPath::create_empty ());\n-    }\n-\n-  for (auto &s : expr.get_statements ())\n-    {\n-      if (!s->is_item ())\n-\tResolveStmt::go (s.get (), s->get_node_id (), prefix, canonical_prefix,\n-\t\t\t CanonicalPath::create_empty ());\n-    }\n-\n-  if (expr.has_tail_expr ())\n-    resolve_expr (expr.get_tail_expr ().get (), expr.get_node_id ());\n-\n-  resolver->get_name_scope ().pop ();\n-  resolver->get_type_scope ().pop ();\n-  resolver->get_label_scope ().pop ();\n-}\n-\n // rust-ast-resolve-struct-expr-field.h\n \n void\n@@ -448,120 +414,6 @@ ResolveStructExprField::visit (AST::StructExprFieldIdentifier &field)\n   ResolveExpr::go (&expr, field.get_node_id (), prefix, canonical_prefix);\n }\n \n-// rust-ast-resolve-type.h\n-\n-std::string\n-ResolveTypeToCanonicalPath::canonicalize_generic_args (AST::GenericArgs &args)\n-{\n-  std::string buf;\n-\n-  size_t i = 0;\n-  size_t total = args.get_type_args ().size ();\n-\n-  for (auto &ty_arg : args.get_type_args ())\n-    {\n-      buf += ty_arg->as_string ();\n-      if ((i + 1) < total)\n-\tbuf += \",\";\n-\n-      i++;\n-    }\n-\n-  return \"<\" + buf + \">\";\n-}\n-\n-bool\n-ResolveTypeToCanonicalPath::type_resolve_generic_args (AST::GenericArgs &args)\n-{\n-  for (auto &gt : args.get_type_args ())\n-    {\n-      ResolveType::go (gt.get (), UNKNOWN_NODEID);\n-      // FIXME error handling here for inference variable since they do not have\n-      // a node to resolve to\n-      // if (resolved == UNKNOWN_NODEID) return false;\n-    }\n-  return true;\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  if (!seg.has_generic_args ())\n-    {\n-      auto ident_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ());\n-      result = result.append (ident_segment);\n-      return;\n-    }\n-\n-  if (type_resolve_generic_args_flag)\n-    {\n-      bool ok = type_resolve_generic_args (seg.get_generic_args ());\n-      failure_flag = !ok;\n-    }\n-\n-  if (include_generic_args_flag)\n-    {\n-      std::string generics\n-\t= canonicalize_generic_args (seg.get_generic_args ());\n-      auto generic_segment\n-\t= CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t  seg.get_ident_segment ().as_string ()\n-\t\t\t\t    + \"::\" + generics);\n-      result = result.append (generic_segment);\n-      return;\n-    }\n-\n-  auto ident_segment\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_segment);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n-{\n-  if (seg.is_error ())\n-    {\n-      failure_flag = true;\n-      rust_error_at (seg.get_locus (), \"segment has error: %s\",\n-\t\t     seg.as_string ().c_str ());\n-      return;\n-    }\n-\n-  CanonicalPath ident_seg\n-    = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t      seg.get_ident_segment ().as_string ());\n-  result = result.append (ident_seg);\n-}\n-\n-void\n-ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n-{\n-  auto inner_type\n-    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n-\t\t\t\t\t   include_generic_args_flag,\n-\t\t\t\t\t   type_resolve_generic_args_flag);\n-\n-  std::string segment_string (\"&\");\n-  if (ref.get_has_mut ())\n-    segment_string += \"mut \";\n-\n-  segment_string += inner_type.get ();\n-\n-  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n-  result = result.append (ident_seg);\n-}\n-\n // rust-ast-resolve-expr.h\n \n void\n@@ -799,39 +651,6 @@ ResolvePath::resolve_segments (CanonicalPath prefix, size_t offs,\n     }\n }\n \n-// rust-ast-resolve-type.h\n-\n-void\n-ResolveType::visit (AST::ArrayType &type)\n-{\n-  type.get_elem_type ()->accept_vis (*this);\n-  // FIXME\n-  // the capacity expr can contain block-expr with functions but these should be\n-  // folded via constexpr code\n-  ResolveExpr::go (type.get_size_expr ().get (), type.get_node_id (),\n-\t\t   CanonicalPath::create_empty (),\n-\t\t   CanonicalPath::create_empty ());\n-}\n-\n-void\n-ResolveType::visit (AST::TraitObjectTypeOneBound &type)\n-{\n-  NodeId bound_resolved_id\n-    = ResolveTypeBound::go (&type.get_trait_bound (), type.get_node_id ());\n-  ok = bound_resolved_id != UNKNOWN_NODEID;\n-}\n-\n-void\n-ResolveType::visit (AST::TraitObjectType &type)\n-{\n-  ok = true;\n-  for (auto &bound : type.get_type_param_bounds ())\n-    {\n-      /* NodeId bound_resolved_id = */\n-      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n-    }\n-}\n-\n // rust-ast-resolve-item.h\n \n void"}]}