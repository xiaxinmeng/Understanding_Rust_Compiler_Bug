{"sha": "6467930b062a0adc1562ad54dfa0075ec29eda97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjQ2NzkzMGIwNjJhMGFkYzE1NjJhZDU0ZGZhMDA3NWVjMjllZGE5Nw==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-08T22:08:30Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-08-08T22:08:30Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r12602", "tree": {"sha": "5f812ca193a1c6b6f60d64c3bd5ac1566d65c73a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f812ca193a1c6b6f60d64c3bd5ac1566d65c73a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6467930b062a0adc1562ad54dfa0075ec29eda97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6467930b062a0adc1562ad54dfa0075ec29eda97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6467930b062a0adc1562ad54dfa0075ec29eda97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6467930b062a0adc1562ad54dfa0075ec29eda97/comments", "author": null, "committer": null, "parents": [{"sha": "7a389b48df6a1622eb12ad09d5def385f357734b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a389b48df6a1622eb12ad09d5def385f357734b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a389b48df6a1622eb12ad09d5def385f357734b"}], "stats": {"total": 3198, "additions": 1912, "deletions": 1286}, "files": [{"sha": "28b15cfce228301869e9d042e3c976137ec59b4a", "filename": "gcc/cp/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMakefile.in?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -238,7 +238,7 @@ search.o : search.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../stack.h $(srcdir)/../\n tree.o : tree.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n ptree.o : ptree.c $(CONFIG_H) $(CXX_TREE_H)\n rtti.o : rtti.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h\n-except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H)\n+except.o : except.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../flags.h $(RTL_H) $(srcdir)/../except.h\n expr.o : expr.c $(CONFIG_H) $(CXX_TREE_H) $(RTL_H) $(srcdir)/../flags.h \\\n   $(srcdir)/../expr.h ../insn-codes.h\n xref.o : xref.c $(CONFIG_H) $(CXX_TREE_H) $(srcdir)/../input.h"}, {"sha": "741e703c1bb524dd18d7eafd0d92de4287bb8605", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -2792,7 +2792,7 @@ build_overload_call_real (fnname, parms, flags, final_cp, require_complete)\n \n \t  i = type_unification (DECL_TEMPLATE_PARMS (function), targs,\n \t\t\t\tTYPE_ARG_TYPES (TREE_TYPE (function)),\n-\t\t\t\tparms, &template_cost, 0);\n+\t\t\t\tparms, &template_cost, 0, 0);\n \t  if (i == 0)\n \t    {\n \t      function = instantiate_template (function, targs);"}, {"sha": "01d59247b8c3b9f11e8206e95bb30c5b8d07fa45", "filename": "gcc/cp/class.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -3017,8 +3017,8 @@ extern int interface_only, interface_unknown;\n    or otherwise in a type-consistent manner.  */\n \n tree\n-finish_struct_1 (t, attributes, warn_anon)\n-     tree t, attributes;\n+finish_struct_1 (t, warn_anon)\n+     tree t;\n      int warn_anon;\n {\n   int old;\n@@ -3073,8 +3073,6 @@ finish_struct_1 (t, attributes, warn_anon)\n   TYPE_SIZE (t) = NULL_TREE;\n   CLASSTYPE_GOT_SEMICOLON (t) = 0;\n \n-  cplus_decl_attributes (t, attributes, NULL_TREE);\n-\n #if 0\n   /* This is in general too late to do this.  I moved the main case up to\n      left_curly, what else needs to move?  */\n@@ -4371,6 +4369,8 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n   *tail = NULL_TREE;\n   TYPE_FIELDS (t) = fields;\n \n+  cplus_decl_attributes (t, attributes, NULL_TREE);\n+\n   if (processing_template_decl)\n     {\n       tree d = getdecls ();\n@@ -4395,7 +4395,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n       TYPE_SIZE (t) = integer_zero_node;\n     }      \n   else\n-    t = finish_struct_1 (t, attributes, warn_anon);\n+    t = finish_struct_1 (t, warn_anon);\n \n   TYPE_BEING_DEFINED (t) = 0;\n \n@@ -4997,7 +4997,7 @@ instantiate_type (lhstype, rhs, complain)\n \t\t    int i, d = 0;\n \t\t    i = type_unification (DECL_TEMPLATE_PARMS (elem), t,\n \t\t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (elem)),\n-\t\t\t\t\t  TYPE_ARG_TYPES (lhstype), &d, 0);\n+\t\t\t\t\t  TYPE_ARG_TYPES (lhstype), &d, 0, 1);\n \t\t    if (i == 0)\n \t\t      {\n \t\t\tif (save_elem)"}, {"sha": "d8342041704854302f9b6279827945dde14d2c2c", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -138,7 +138,7 @@ DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", \"e\", 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", \"e\", 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", \"e\", 2)\n \n-DEFTREECODE (EXACT_CONV, \"exact_conv\", \"e\", 1)\n+DEFTREECODE (IDENTITY_CONV, \"identity_conv\", \"e\", 1)\n DEFTREECODE (LVALUE_CONV, \"lvalue_conv\", \"e\", 1)\n DEFTREECODE (QUAL_CONV, \"qual_conv\", \"e\", 1)\n DEFTREECODE (STD_CONV, \"std_conv\", \"e\", 1)\n@@ -148,3 +148,4 @@ DEFTREECODE (BASE_CONV, \"base_conv\", \"e\", 1)\n DEFTREECODE (REF_BIND, \"ref_bind\", \"e\", 1)\n DEFTREECODE (USER_CONV, \"user_conv\", \"e\", 4)\n DEFTREECODE (AMBIG_CONV, \"ambig_conv\", \"e\", 1)\n+DEFTREECODE (RVALUE_CONV, \"rvalue_conv\", \"e\", 1)"}, {"sha": "7f6fd80500629a3075d9a7c06870e1bf73432668", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -295,11 +295,6 @@ extern int flag_elide_constructors;\n \n extern int flag_ansi;\n \n-/* Nonzero means recognize and handle ansi-style exception handling\n-   constructs.  */\n-\n-extern int flag_handle_exceptions;\n-\n /* Nonzero means recognize and handle signature language constructs.  */\n \n extern int flag_handle_signatures;\n@@ -336,8 +331,8 @@ enum languages { lang_c, lang_cplusplus };\n #define IS_AGGR_TYPE_2(TYPE1,TYPE2) \\\n   (TREE_CODE (TYPE1) == TREE_CODE (TYPE2)\t\\\n    && IS_AGGR_TYPE (TYPE1)&IS_AGGR_TYPE (TYPE2))\n-#define IS_OVERLOAD_TYPE_CODE(t) (IS_AGGR_TYPE_CODE (t) || t == ENUMERAL_TYPE)\n-#define IS_OVERLOAD_TYPE(t) (IS_OVERLOAD_TYPE_CODE (TREE_CODE (t)))\n+#define IS_OVERLOAD_TYPE(t) \\\n+  (IS_AGGR_TYPE (t) || TREE_CODE (t) == ENUMERAL_TYPE)\n \n /* In a *_TYPE, nonzero means a built-in type.  */\n #define TYPE_BUILT_IN(NODE) TYPE_LANG_FLAG_6(NODE)\n@@ -1951,7 +1946,7 @@ extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n extern tree finish_struct\t\t\tPROTO((tree, tree, tree, int));\n-extern tree finish_struct_1\t\t\tPROTO((tree, tree, int));\n+extern tree finish_struct_1\t\t\tPROTO((tree, int));\n extern tree finish_struct_methods\t\tPROTO((tree, tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n@@ -2122,9 +2117,9 @@ extern void mark_used\t\t\t\tPROTO((tree));\n \n /* in except.c */\n extern tree protect_list;\n-extern void start_protect\t\t\tPROTO((void));\n-extern void end_protect\t\t\t\tPROTO((tree));\n-extern void end_protect_partials\t\t();\n+extern void expand_eh_region_start\t\tPROTO((void));\n+extern void expand_eh_region_end\t\tPROTO((tree));\n+extern void end_protect_partials\t\tPROTO((void));\n extern void expand_exception_blocks\t\tPROTO((void));\n extern void expand_start_try_stmts\t\tPROTO((void));\n extern void expand_end_try_stmts\t\tPROTO((void));\n@@ -2133,8 +2128,6 @@ extern void expand_end_all_catch\t\tPROTO((void));\n extern void start_catch_block\t\t\tPROTO((tree, tree));\n extern void end_catch_block\t\t\tPROTO((void));\n extern void expand_throw\t\t\tPROTO((tree));\n-extern int might_have_exceptions_p\t\tPROTO((void));\n-extern void emit_exception_table\t\tPROTO((void));\n extern tree build_throw\t\t\t\tPROTO((tree));\n extern void init_exception_processing\t\tPROTO((void));\n extern void expand_builtin_throw\t\tPROTO((void));\n@@ -2292,7 +2285,7 @@ extern int uses_template_parms\t\t\tPROTO((tree));\n extern tree instantiate_class_template\t\tPROTO((tree));\n extern tree instantiate_template\t\tPROTO((tree, tree *));\n extern void overload_template_name\t\tPROTO((tree));\n-extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int));\n+extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, int *, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n extern void mark_class_instantiated\t\tPROTO((tree, int));"}, {"sha": "a4c68e2180b76db37d4bec9a77080f42748d6b56", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1521, "deletions": 243, "changes": 1764, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -719,8 +719,6 @@ convert_to_reference (reftype, expr, convtype, flags, decl)\n #ifdef NEW_OVER\n       rval_as_conversion\n \t= build_type_conversion (CONVERT_EXPR, reftype, expr, 1);\n-      if (rval_as_conversion)\n-\trval_as_conversion = convert_from_reference (rval_as_conversion);\n #else\n       rval_as_conversion = build_type_conversion (CONVERT_EXPR, type, expr, 1);\n #endif\n@@ -1344,6 +1342,9 @@ cp_convert (type, expr, convtype, flags)\n \n #ifndef NEW_OVER\n       if (TYPE_HAS_CONSTRUCTOR (complete_type (type)))\n+#else\n+      if (TYPE_HAS_CONSTRUCTOR (complete_type (type)) && ! conversion)\n+#endif\n \tctor = build_method_call (NULL_TREE, ctor_identifier,\n \t\t\t\t  build_tree_list (NULL_TREE, e),\n \t\t\t\t  TYPE_BINFO (type),\n@@ -1369,14 +1370,13 @@ cp_convert (type, expr, convtype, flags)\n \t    return NULL_TREE;\n \t  return error_mark_node;\n \t}\n+      else if (conversion)\n+\treturn conversion;\n       else if (ctor)\n \t{\n \t  ctor = build_cplus_new (type, ctor);\n \t  return ctor;\n \t}\n-#endif\n-      else if (conversion)\n-\treturn conversion;\n     }\n \n   /* If TYPE or TREE_TYPE (E) is not on the permanent_obstack,\n@@ -1853,7 +1853,6 @@ type_promotes_to (type)\n   return cp_build_type_variant (type, constp, volatilep);\n }\n \n-#ifdef NEW_OVER\n /* Work in progress.  Ask jason before removing.  */\n \n struct z_candidate {\n@@ -1866,12 +1865,13 @@ struct z_candidate {\n   struct z_candidate *next;\n };\n \n-#define EXACT_RANK 0\n-#define PROMO_RANK 1\n-#define STD_RANK 2\n-#define PBOOL_RANK 3\n-#define USER_RANK 4\n-#define ELLIPSIS_RANK 5\n+#define IDENTITY_RANK 0\n+#define EXACT_RANK 1\n+#define PROMO_RANK 2\n+#define STD_RANK 3\n+#define PBOOL_RANK 4\n+#define USER_RANK 5\n+#define ELLIPSIS_RANK 6\n \n #define ICS_RANK(NODE)\t\t\t\t\\\n   (ICS_ELLIPSIS_FLAG (NODE) ? ELLIPSIS_RANK\t\\\n@@ -1885,10 +1885,11 @@ struct z_candidate {\n \n #define USER_CONV_FN(NODE) TREE_OPERAND (NODE, 1)\n \n-struct z_candidate * build_user_type_conversion_1 ();\n-tree convert_like ();\n-tree build_over_call ();\n-struct z_candidate * tourney ();\n+static struct z_candidate * build_user_type_conversion_1 ();\n+static tree convert_like ();\n+static tree build_over_call ();\n+static struct z_candidate * tourney ();\n+static void enforce_access ();\n \n int\n null_ptr_cst (t)\n@@ -1914,6 +1915,12 @@ build_conv (code, type, from)\n \trank = STD_RANK;\n       break;\n \n+    case LVALUE_CONV:\n+    case QUAL_CONV:\n+    case RVALUE_CONV:\n+      if (rank < EXACT_RANK)\n+\trank = EXACT_RANK;\n+\n     default:\n       break;\n     }\n@@ -1931,6 +1938,10 @@ non_reference (t)\n   return t;\n }\n \n+/* Returns the standard conversion path (see [conv]) from type FROM to type\n+   TO, if any.  For proper handling of null pointer constants, you must\n+   also pass the expression EXPR to convert from.  */\n+\n tree\n standard_conversion (to, from, expr)\n      tree to, from, expr;\n@@ -1941,7 +1952,7 @@ standard_conversion (to, from, expr)\n   fcode = TREE_CODE (from);\n   tcode = TREE_CODE (to);\n \n-  conv = build1 (EXACT_CONV, from, expr);\n+  conv = build1 (IDENTITY_CONV, from, expr);\n \n   if (from == to)\n     return conv;\n@@ -1986,7 +1997,7 @@ standard_conversion (to, from, expr)\n \t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n \t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n \n-\t  if (DERIVED_FROM_P (tbase, fbase)\n+\t  if (DERIVED_FROM_P (fbase, tbase)\n \t      && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n \t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))),\n \t\t\t     1)))\n@@ -2031,7 +2042,7 @@ standard_conversion (to, from, expr)\n       tree fbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fromfn)));\n       tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n \n-      if (! DERIVED_FROM_P (tbase, fbase)\n+      if (! DERIVED_FROM_P (fbase, tbase)\n \t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n \t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n \t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)), 1)\n@@ -2056,7 +2067,10 @@ standard_conversion (to, from, expr)\n \t  && ICS_STD_RANK (conv) < PBOOL_RANK)\n \tICS_STD_RANK (conv) = PBOOL_RANK;\n     }\n-  else if (INTEGRAL_CODE_P (tcode) || tcode == REAL_TYPE)\n+  /* We don't check for ENUMERAL_TYPE here because there are no standard\n+     conversions to enum type.  */\n+  else if (tcode == INTEGER_TYPE || tcode == BOOLEAN_TYPE\n+\t   || tcode == REAL_TYPE)\n     {\n       if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n \treturn 0;\n@@ -2076,32 +2090,38 @@ standard_conversion (to, from, expr)\n   return conv;\n }\n \n+/* Returns the conversion path from type FROM to reference type TO for\n+   purposes of reference binding.  For lvalue binding, either pass a\n+   reference type to FROM or an lvalue expression to EXPR.\n+\n+   Currently does not distinguish in the generated trees between binding to\n+   an lvalue and a temporary.  Should it?  */\n+\n tree\n-reference_binding (to, from, expr)\n-     tree to, from, expr;\n+reference_binding (rto, from, expr)\n+     tree rto, from, expr;\n {\n   tree conv;\n   int lvalue = 1;\n-  \n-  to = TREE_TYPE (to);\n+  tree to = TREE_TYPE (rto);\n \n   if (TREE_CODE (from) == REFERENCE_TYPE)\n     from = TREE_TYPE (from);\n-  else if (! expr || ! lvalue_p (expr))\n+  else if (! expr || ! real_lvalue_p (expr))\n     lvalue = 0;\n \n   if (lvalue\n       && TYPE_READONLY (to) >= TYPE_READONLY (from)\n       && TYPE_VOLATILE (to) >= TYPE_VOLATILE (from))\n     {\n-      conv = build1 (EXACT_CONV, from, expr);\n+      conv = build1 (IDENTITY_CONV, from, expr);\n \n       if (TYPE_MAIN_VARIANT (to) == TYPE_MAIN_VARIANT (from))\n-\tconv = build_conv (REF_BIND, to, conv);\n+\tconv = build_conv (REF_BIND, rto, conv);\n       else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n \t       && DERIVED_FROM_P (to, from))\n \t{\n-\t  conv = build_conv (REF_BIND, to, conv);\n+\t  conv = build_conv (REF_BIND, rto, conv);\n \t  ICS_STD_RANK (conv) = STD_RANK;\n \t}\n       else\n@@ -2115,12 +2135,23 @@ reference_binding (to, from, expr)\n       conv = standard_conversion\n \t(TYPE_MAIN_VARIANT (to), TYPE_MAIN_VARIANT (from), expr);\n       if (conv)\n-\tconv = build_conv (REF_BIND, to, conv);\n+\t{\n+\t  conv = build_conv (REF_BIND, rto, conv);\n+\n+\t  /* Bind directly to a base subobject of a class rvalue.  */\n+\t  if (TREE_CODE (TREE_OPERAND (conv, 0)) == BASE_CONV)\n+\t    TREE_OPERAND (conv, 0) = TREE_OPERAND (TREE_OPERAND (conv, 0), 0);\n+\t}\n     }\n \n   return conv;\n }\n \n+/* Returns the implicit conversion sequence (see [over.ics]) from type FROM\n+   to type TO.  The optional expression EXPR may affect the conversion.\n+   FLAGS are the usual overloading flags.  Only LOOKUP_NO_CONVERSION is\n+   significant.  */\n+\n tree\n implicit_conversion (to, from, expr, flags)\n      tree to, from, expr;\n@@ -2145,29 +2176,41 @@ implicit_conversion (to, from, expr, flags)\n        TYPE_MAIN_VARIANT (non_reference (from)), expr);\n \n   if (conv)\n-    ;\n+    {\n+      if (TREE_CODE (conv) == IDENTITY_CONV && IS_AGGR_TYPE (to)\n+\t  && (TREE_CODE (from) == REFERENCE_TYPE || (expr && real_lvalue_p (expr))))\n+\tconv = build_conv (RVALUE_CONV, to, conv);\n+    }\n   else if ((IS_AGGR_TYPE (non_reference (from))\n \t    || IS_AGGR_TYPE (non_reference (to)))\n \t   && (flags & LOOKUP_NO_CONVERSION) == 0)\n     {\n-      cand = build_user_type_conversion_1 (to, expr, LOOKUP_ONLYCONVERTING);\n-      if (cand)\n-\tconv = cand->second_conv;\n-      else if (TREE_CODE (to) == REFERENCE_TYPE\n-\t       && TYPE_READONLY (TREE_TYPE (to))\n-\t       && ! TYPE_VOLATILE (TREE_TYPE (to)))\n+      if (TREE_CODE (to) == REFERENCE_TYPE\n+\t  && TYPE_READONLY (TREE_TYPE (to))\n+\t  && ! TYPE_VOLATILE (TREE_TYPE (to)))\n \t{\n \t  cand = build_user_type_conversion_1\n \t    (TYPE_MAIN_VARIANT (TREE_TYPE (to)), expr, LOOKUP_ONLYCONVERTING);\n \t  if (cand)\n-\t    conv = build_conv (REF_BIND, TREE_TYPE (to), cand->second_conv);\n+\t    conv = build_conv (REF_BIND, to, cand->second_conv);\n+\t}\n+      else\n+\t{\n+\t  cand = build_user_type_conversion_1\n+\t    (to, expr, LOOKUP_ONLYCONVERTING);\n+\t  if (cand)\n+\t    conv = cand->second_conv;\n \t}\n     }\n \n   return conv;\n }\n \n-struct z_candidate *\n+/* Create an overload candidate for the function or method FN called with\n+   the argument list ARGLIST and add it to CANDIDATES.  FLAGS is passed on\n+   to implicit_conversion.  */\n+\n+static struct z_candidate *\n add_function_candidate (candidates, fn, arglist, flags)\n      struct z_candidate *candidates;\n      tree fn, arglist;\n@@ -2181,6 +2224,8 @@ add_function_candidate (candidates, fn, arglist, flags)\n   int viable = 1;\n   struct z_candidate *cand;\n \n+  /* The `this' and `in_chrg' arguments to constructors are not considered\n+     in overload resolution.  */\n   if (DECL_CONSTRUCTOR_P (fn))\n     {\n       parmnode = TREE_CHAIN (parmnode);\n@@ -2203,7 +2248,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n \tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n       else\n \t{\n-\t  t = build1 (EXACT_CONV, argtype, arg);\n+\t  t = build1 (IDENTITY_CONV, argtype, arg);\n \t  ICS_ELLIPSIS_FLAG (t) = 1;\n \t}\n \n@@ -2219,6 +2264,7 @@ add_function_candidate (candidates, fn, arglist, flags)\n   if (i < len)\n     viable = 0;\n \n+  /* Make sure there are default args for the rest of the parms.  */\n   for (; parmnode && parmnode != void_list_node;\n        parmnode = TREE_CHAIN (parmnode))\n     if (! TREE_PURPOSE (parmnode))\n@@ -2240,216 +2286,970 @@ add_function_candidate (candidates, fn, arglist, flags)\n   return cand;\n }\n \n-struct z_candidate *\n-add_template_candidate (candidates, tmpl, arglist, flags)\n+/* Create an overload candidate for the conversion function FN which will\n+   be invoked for expression OBJ, producing a pointer-to-function which\n+   will in turn be called with the argument list ARGLIST, and add it to\n+   CANDIDATES.  FLAGS is passed on to implicit_conversion.  */\n+\n+static struct z_candidate *\n+add_conv_candidate (candidates, fn, obj, arglist)\n      struct z_candidate *candidates;\n-     tree tmpl, arglist;\n-     int flags;\n+     tree fn, obj, arglist;\n {\n-  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n-  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+  tree totype = TREE_TYPE (TREE_TYPE (fn));\n+  tree parmlist = TYPE_ARG_TYPES (TREE_TYPE (totype));\n+  int i, len = list_length (arglist) + 1;\n+  tree convs = make_tree_vec (len);\n+  tree parmnode = parmlist;\n+  tree argnode = arglist;\n+  int viable = 1;\n   struct z_candidate *cand;\n-  int i, dummy; \n-  tree fn;\n+  int flags = LOOKUP_NORMAL;\n \n-  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n-\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n-\t\t\targlist, &dummy, 0);\n-  if (i != 0)\n-    return candidates;\n+  for (i = 0; i < len; ++i)\n+    {\n+      tree arg = i == 0 ? obj : TREE_VALUE (argnode);\n+      tree argtype = TREE_TYPE (arg);\n+      tree t;\n \n-  fn = instantiate_template (tmpl, targs);\n-  if (fn == error_mark_node)\n-    return candidates;\n+      argtype = cp_build_type_variant\n+\t(argtype, TREE_READONLY (arg), TREE_THIS_VOLATILE (arg));\n \n-  cand = add_function_candidate (candidates, fn, arglist, flags);\n-  cand->template = DECL_TEMPLATE_INFO (fn);\n-  return cand;\n-}\n+      if (i == 0)\n+\tt = implicit_conversion (totype, argtype, arg, flags);\n+      else if (parmnode == void_list_node)\n+\tbreak;\n+      else if (parmnode)\n+\tt = implicit_conversion (TREE_VALUE (parmnode), argtype, arg, flags);\n+      else\n+\t{\n+\t  t = build1 (IDENTITY_CONV, argtype, arg);\n+\t  ICS_ELLIPSIS_FLAG (t) = 1;\n+\t}\n \n-int\n-any_viable (cands)\n-     struct z_candidate *cands;\n-{\n-  for (; cands; cands = cands->next)\n-    if (cands->viable)\n-      return 1;\n-  return 0;\n-}\n+      TREE_VEC_ELT (convs, i) = t;\n+      if (! t)\n+\tbreak;\n \n-struct z_candidate *\n-splice_viable (cands)\n-     struct z_candidate *cands;\n-{\n-  struct z_candidate **p = &cands;\n+      if (i == 0)\n+\tcontinue;\n \n-  for (; *p; )\n-    {\n-      if ((*p)->viable)\n-\tp = &((*p)->next);\n-      else\n-\t*p = (*p)->next;\n+      if (parmnode)\n+\tparmnode = TREE_CHAIN (parmnode);\n+      argnode = TREE_CHAIN (argnode);\n     }\n \n-  return cands;\n-}\n+  if (i < len)\n+    viable = 0;\n \n-tree\n-build_this (obj)\n-     tree obj;\n-{\n-  /* Fix this to work on non-lvalues.  */\n-  return build_unary_op (ADDR_EXPR, obj, 0);\n-}\n+  for (; parmnode && parmnode != void_list_node;\n+       parmnode = TREE_CHAIN (parmnode))\n+    if (! TREE_PURPOSE (parmnode))\n+      {\n+\tviable = 0;\n+\tbreak;\n+      }\n \n-void\n-print_z_candidates (candidates)\n-     struct z_candidate *candidates;\n-{\n-  cp_error_at (\"candidates are: %D\", candidates->fn);\n-  candidates = candidates->next;\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n \n-  for (; candidates; candidates = candidates->next)\n-    cp_error_at (\"                %D\", candidates->fn);\n-}\n+  cand->fn = fn;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->next = candidates;\n \n-/* Returns the best overload candidate to perform the requested\n-   conversion.  */\n+  return cand;\n+}\n \n-struct z_candidate *\n-build_user_type_conversion_1 (totype, expr, flags)\n-     tree totype, expr;\n-     int flags;\n+int\n+ptr_complete_ob (t)\n+     tree t;\n {\n-  struct z_candidate *candidates, *cand;\n-  tree fromtype = TREE_TYPE (expr);\n-  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n-  tree args;\n-\n-  if (IS_AGGR_TYPE (totype))\n-    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n-  if (IS_AGGR_TYPE (fromtype))\n-    convs = lookup_conversions (fromtype);\n+  return (TREE_CODE (t) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != OFFSET_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != FUNCTION_TYPE\n+\t  && TREE_CODE (TREE_TYPE (t)) != VOID_TYPE\n+\t  && TYPE_SIZE (complete_type (TREE_TYPE (t))) != NULL_TREE);\n+}\n \n-  candidates = 0;\n-  flags |= LOOKUP_NO_CONVERSION;\n+#define TYPE_PTRMEM_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) == OFFSET_TYPE)\n+#define TYPE_PTR_P(NODE)\t\t\t\t\\\n+  (TREE_CODE (NODE) == POINTER_TYPE\t\t\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != OFFSET_TYPE)\n+#define TYPE_PTROB_P(NODE)\t\t\t\t\t\t\\\n+  (TYPE_PTR_P (NODE) && TREE_CODE (TREE_TYPE (NODE)) != FUNCTION_TYPE\t\\\n+   && TREE_CODE (TREE_TYPE (NODE)) != VOID_TYPE)\n+\n+static struct z_candidate *\n+build_builtin_candidate (candidates, fnname, type1, type2,\n+\t\t\t args, argtypes, flags)\n+     struct z_candidate *candidates;\n+     tree fnname, type1, type2, *args, *argtypes;\n+     int flags;\n \n-  if (ctors)\n-    {\n-      ctors = TREE_VALUE (ctors);\n-      args = build_tree_list (NULL_TREE, expr);\n-    }\n-  for (; ctors; ctors = DECL_CHAIN (ctors))\n-    {\n-      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n-\tcontinue;\n+{\n+  tree t, convs;\n+  int viable = 1, i;\n+  struct z_candidate *cand;\n+  tree types[2];\n \n-      candidates = add_function_candidate (candidates, ctors, args, flags);\n-      candidates->second_conv = build1 (EXACT_CONV, totype, NULL_TREE);\n-      candidates->basetype_path = TYPE_BINFO (totype);\n-    }\n+  types[0] = type1;\n+  types[1] = type2;\n \n-  if (convs)\n-    args = build_tree_list (NULL_TREE, build_this (expr));\n+  convs = make_tree_vec (args[2] ? 3 : (args[1] ? 2 : 1));\n \n-  for (; convs; convs = TREE_CHAIN (convs))\n+  for (i = 0; i < 2; ++i)\n     {\n-      tree fn = TREE_VALUE (convs);\n-      tree ics = implicit_conversion\n-\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, LOOKUP_NO_CONVERSION);\n-      if (ics)\n-\t{\n-\t  candidates = add_function_candidate (candidates, fn, args, flags);\n-\t  candidates->second_conv = ics;\n-\t  candidates->basetype_path = TREE_PURPOSE (convs);\n-\t}\n-    }\n+      if (! args[i])\n+\tbreak;\n \n-  if (! any_viable (candidates))\n-    {\n-#if 0\n-      if (flags & LOOKUP_COMPLAIN)\n+      t = implicit_conversion (types[i], argtypes[i], args[i], flags);\n+      if (! t)\n \t{\n-\t  if (candidates && ! candidates->next)\n-\t    /* say why this one won't work or try to be loose */;\n-\t  else\n-\t    cp_error (\"no viable candidates\");\n+\t  viable = 0;\n+\t  /* We need something for printing the candidate.  */\n+\t  t = build1 (IDENTITY_CONV, types[i], NULL_TREE);\n \t}\n-#endif\n-\n-      return 0;\n+      TREE_VEC_ELT (convs, i) = t;\n     }\n \n-  candidates = splice_viable (candidates);\n-  cand = tourney (candidates, totype);\n-\n-  if (cand == 0)\n+  /* For COND_EXPR we rearranged the arguments; undo that now.  */\n+  if (args[2])\n     {\n-      if (flags & LOOKUP_COMPLAIN)\n-\t{\n-\t  cp_error (\"ambiguous user-defined type conversion\");\n-\t  print_z_candidates (candidates);\n-\t}\n-\n-      cand = candidates;\t/* any one will do */\n-      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n-\n-      return cand;\n-    }\n+      TREE_VEC_ELT (convs, 2) = TREE_VEC_ELT (convs, 1);\n+      TREE_VEC_ELT (convs, 1) = TREE_VEC_ELT (convs, 0);\n+      t = implicit_conversion (boolean_type_node, argtypes[2], args[2], flags);\n+      if (t)\n+\tTREE_VEC_ELT (convs, 0) = t;\n+      else\n+\tviable = 0;\n+    }      \n \n-  for (p = &(cand->second_conv); TREE_CODE (*p) != EXACT_CONV; )\n-    p = &(TREE_OPERAND (*p, 0));\n+  cand = (struct z_candidate *) oballoc (sizeof (struct z_candidate));\n \n-  *p = build\n-    (USER_CONV,\n-     (DECL_CONSTRUCTOR_P (cand->fn)\n-      ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n-     NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n-  ICS_USER_FLAG (cand->second_conv) = 1;\n+  cand->fn = fnname;\n+  cand->convs = convs;\n+  cand->second_conv = NULL_TREE;\n+  cand->viable = viable;\n+  cand->basetype_path = NULL_TREE;\n+  cand->template = NULL_TREE;\n+  cand->next = candidates;\n \n   return cand;\n }\n \n-tree\n-build_user_type_conversion (totype, expr, flags)\n-     tree totype, expr, flags;\n+int\n+is_complete (t)\n+     tree t;\n {\n-  struct z_candidate *cand\n-    = build_user_type_conversion_1 (totype, expr, flags);\n+  return TYPE_SIZE (complete_type (t)) != NULL_TREE;\n+}\n \n-  if (cand)\n+/* Create any builtin operator overload candidates for the operator in\n+   question given the converted operand types TYPE1 and TYPE2.  The other\n+   args are passed through from add_builtin_candidates to\n+   build_builtin_candidate.  */\n+\n+static struct z_candidate *\n+add_builtin_candidate (candidates, code, code2, fnname, type1, type2,\n+\t\t       args, argtypes, flags)\n+     struct z_candidate *candidates;\n+     enum tree_code code, code2;\n+     tree fnname, type1, type2, *args, *argtypes;\n+     int flags;\n+{\n+  switch (code)\n     {\n-      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n-\treturn error_mark_node;\n-      return convert_like (cand->second_conv, expr);\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      args[1] = integer_zero_node;\n+      type2 = integer_type_node;\n     }\n-  return NULL_TREE;\n-}\n \n-tree\n-build_new_function_call (fn, args, obj)\n-     tree fn, args, obj;\n-{\n-  struct z_candidate *candidates = 0, *cand;\n- \n-  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n+  switch (code)\n     {\n-      tree t = TREE_VALUE (fn);\n \n-      for (; t; t = DECL_CHAIN (t))\n+/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n+     and  VQ  is  either  volatile or empty, there exist candidate operator\n+     functions of the form\n+\t     VQ T&   operator++(VQ T&);\n+\t     T       operator++(VQ T&, int);\n+   5 For every pair T, VQ), where T is an enumeration type or an arithmetic\n+     type  other than bool, and VQ is either volatile or empty, there exist\n+     candidate operator functions of the form\n+\t     VQ T&   operator--(VQ T&);\n+\t     T       operator--(VQ T&, int);\n+   6 For every pair T, VQ), where T is  a  cv-qualified  or  cv-unqualified\n+     complete  object type, and VQ is either volatile or empty, there exist\n+     candidate operator functions of the form\n+\t     T*VQ&   operator++(T*VQ&);\n+\t     T*VQ&   operator--(T*VQ&);\n+\t     T*      operator++(T*VQ&, int);\n+\t     T*      operator--(T*VQ&, int);  */\n+\n+    case POSTDECREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+      if (TREE_CODE (type1) == BOOLEAN_TYPE)\n+\treturn candidates;\n+    case POSTINCREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) || ptr_complete_ob (type1))\n \t{\n-\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n-\t    candidates = add_template_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n-\t  else\n-\t    candidates = add_function_candidate\n-\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t  type1 = build_reference_type (type1);\n+\t  break;\n \t}\n+      return candidates;\n \n-      if (! any_viable (candidates))\n-\t{\n-\t  if (candidates && ! candidates->next)\n-\t    return build_function_call (candidates->fn, args);\n+/* 7 For every cv-qualified or cv-unqualified complete object type T, there\n+     exist candidate operator functions of the form\n+\n+\t     T&      operator*(T*);\n+\n+   8 For every function type T, there exist candidate operator functions of\n+     the form\n+\t     T&      operator*(T*);  */\n+\n+    case INDIRECT_REF:\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && (ptr_complete_ob (type1)\n+\t      || TREE_CODE (TREE_TYPE (type1)) == FUNCTION_TYPE))\n+\tbreak;\n+      return candidates;\n+\n+/* 9 For every type T, there exist candidate operator functions of the form\n+\t     T*      operator+(T*);\n+\n+   10For  every  promoted arithmetic type T, there exist candidate operator\n+     functions of the form\n+\t     T       operator+(T);\n+\t     T       operator-(T);  */\n+\n+    case CONVERT_EXPR: /* unary + */\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (type1)) != OFFSET_TYPE)\n+\tbreak;\n+    case NEGATE_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1))\n+\tbreak;\n+      return candidates;\n+\n+/* 11For every promoted integral type T,  there  exist  candidate  operator\n+     functions of the form\n+\t     T       operator~(T);  */\n+\n+    case BIT_NOT_EXPR:\n+      if (INTEGRAL_TYPE_P (type1))\n+\tbreak;\n+      return candidates;\n+\n+/* 12For every quintuple C1, C2, T, CV1, CV2), where C2 is a class type, C1\n+     is the same type as C2 or is a derived class of C2, T  is  a  complete\n+     object type or a function type, and CV1 and CV2 are cv-qualifier-seqs,\n+     there exist candidate operator functions of the form\n+\t     CV12 T& operator->*(CV1 C1*, CV2 T C2::*);\n+     where CV12 is the union of CV1 and CV2.  */\n+\n+    case MEMBER_REF:\n+      if (TREE_CODE (type1) == POINTER_TYPE\n+\t  && (TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2)))\n+\t{\n+\t  tree c1 = TREE_TYPE (type1);\n+\t  tree c2 = (TYPE_PTRMEMFUNC_P (type2)\n+\t\t     ? TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (type2))\n+\t\t     : TYPE_OFFSET_BASETYPE (TREE_TYPE (type2)));\n+\n+\t  if (IS_AGGR_TYPE (c1) && DERIVED_FROM_P (c2, c1)\n+\t      && (TYPE_PTRMEMFUNC_P (type2)\n+\t\t  || is_complete (TREE_TYPE (TREE_TYPE (type2)))))\n+\t    break;\n+\t}\n+      return candidates;\n+\n+/* 13For every pair of promoted arithmetic types L and R, there exist  can-\n+     didate operator functions of the form\n+\t     LR      operator*(L, R);\n+\t     LR      operator/(L, R);\n+\t     LR      operator+(L, R);\n+\t     LR      operator-(L, R);\n+\t     bool    operator<(L, R);\n+\t     bool    operator>(L, R);\n+\t     bool    operator<=(L, R);\n+\t     bool    operator>=(L, R);\n+\t     bool    operator==(L, R);\n+\t     bool    operator!=(L, R);\n+     where  LR  is  the  result of the usual arithmetic conversions between\n+     types L and R.\n+\n+   14For every pair of types T and I, where T  is  a  cv-qualified  or  cv-\n+     unqualified  complete  object  type and I is a promoted integral type,\n+     there exist candidate operator functions of the form\n+\t     T*      operator+(T*, I);\n+\t     T&      operator[](T*, I);\n+\t     T*      operator-(T*, I);\n+\t     T*      operator+(I, T*);\n+\t     T&      operator[](I, T*);\n+\n+   15For every T, where T is a pointer to complete object type, there exist\n+     candidate operator functions of the form112)\n+\t     ptrdiff_t operator-(T, T);\n+\n+   16For  every pointer type T, there exist candidate operator functions of\n+     the form\n+\t     bool    operator<(T, T);\n+\t     bool    operator>(T, T);\n+\t     bool    operator<=(T, T);\n+\t     bool    operator>=(T, T);\n+\t     bool    operator==(T, T);\n+\t     bool    operator!=(T, T);\n+\n+   17For every pointer to member type T,  there  exist  candidate  operator\n+     functions of the form\n+\t     bool    operator==(T, T);\n+\t     bool    operator!=(T, T);  */\n+\n+    case MINUS_EXPR:\n+      if (ptr_complete_ob (type1) && ptr_complete_ob (type2))\n+\tbreak;\n+      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t{\n+\t  type2 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+      return candidates;\n+\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+      if (TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2)\n+\t  || TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\tbreak;\n+      if ((TYPE_PTRMEMFUNC_P (type1) || TYPE_PTRMEM_P (type1))\n+\t  && null_ptr_cst (args[1]))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if ((TYPE_PTRMEMFUNC_P (type2) || TYPE_PTRMEM_P (type2))\n+\t  && null_ptr_cst (args[0]))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+    case LT_EXPR:\n+    case GT_EXPR:\n+    case LE_EXPR:\n+    case GE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2)\n+\t  || TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+\tbreak;\n+      if (TYPE_PTR_P (type1) && null_ptr_cst (args[1]))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if (null_ptr_cst (args[0]) && TYPE_PTR_P (type2))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+    case PLUS_EXPR:\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+    case ARRAY_REF:\n+      if (INTEGRAL_TYPE_P (type1) && ptr_complete_ob (type2))\n+\t{\n+\t  type1 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+      if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t{\n+\t  type2 = ptrdiff_type_node;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+/* 18For  every pair of promoted integral types L and R, there exist candi-\n+     date operator functions of the form\n+\t     LR      operator%(L, R);\n+\t     LR      operator&(L, R);\n+\t     LR      operator^(L, R);\n+\t     LR      operator|(L, R);\n+\t     L       operator<<(L, R);\n+\t     L       operator>>(L, R);\n+     where LR is the result of the  usual  arithmetic  conversions  between\n+     types L and R.  */\n+\n+    case TRUNC_MOD_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+\tbreak;\n+      return candidates;\n+\n+/* 19For  every  triple  L, VQ, R), where L is an arithmetic or enumeration\n+     type, VQ is either volatile or empty, and R is a  promoted  arithmetic\n+     type, there exist candidate operator functions of the form\n+\t     VQ L&   operator=(VQ L&, R);\n+\t     VQ L&   operator*=(VQ L&, R);\n+\t     VQ L&   operator/=(VQ L&, R);\n+\t     VQ L&   operator+=(VQ L&, R);\n+\t     VQ L&   operator-=(VQ L&, R);\n+\n+   20For  every  pair T, VQ), where T is any type and VQ is either volatile\n+     or empty, there exist candidate operator functions of the form\n+\t     T*VQ&   operator=(T*VQ&, T*);\n+\n+   21For every pair T, VQ), where T is a pointer to member type and  VQ  is\n+     either  volatile or empty, there exist candidate operator functions of\n+     the form\n+\t     VQ T&   operator=(VQ T&, T);\n+\n+   22For every triple  T,  VQ,  I),  where  T  is  a  cv-qualified  or  cv-\n+     unqualified  complete object type, VQ is either volatile or empty, and\n+     I is a promoted integral type, there exist  candidate  operator  func-\n+     tions of the form\n+\t     T*VQ&   operator+=(T*VQ&, I);\n+\t     T*VQ&   operator-=(T*VQ&, I);\n+\n+   23For  every  triple  L,  VQ,  R), where L is an integral or enumeration\n+     type, VQ is either volatile or empty, and R  is  a  promoted  integral\n+     type, there exist candidate operator functions of the form\n+\n+\t     VQ L&   operator%=(VQ L&, R);\n+\t     VQ L&   operator<<=(VQ L&, R);\n+\t     VQ L&   operator>>=(VQ L&, R);\n+\t     VQ L&   operator&=(VQ L&, R);\n+\t     VQ L&   operator^=(VQ L&, R);\n+\t     VQ L&   operator|=(VQ L&, R);  */\n+\n+    case MODIFY_EXPR:\n+      switch (code2)\n+\t{\n+\tcase PLUS_EXPR:\n+\tcase MINUS_EXPR:\n+\t  if (ptr_complete_ob (type1) && INTEGRAL_TYPE_P (type2))\n+\t    {\n+\t      type2 = ptrdiff_type_node;\n+\t      break;\n+\t    }\n+\tcase MULT_EXPR:\n+\tcase TRUNC_DIV_EXPR:\n+\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\t    break;\n+\t  return candidates;\n+\n+\tcase TRUNC_MOD_EXPR:\n+\tcase BIT_AND_EXPR:\n+\tcase BIT_IOR_EXPR:\n+\tcase BIT_XOR_EXPR:\n+\tcase LSHIFT_EXPR:\n+\tcase RSHIFT_EXPR:\n+\t  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2))\n+\t    break;\n+\t  return candidates;\n+\n+\tcase NOP_EXPR:\n+\t  if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\t    break;\n+\t  if ((TYPE_PTRMEMFUNC_P (type1) && TYPE_PTRMEMFUNC_P (type2))\n+\t      || (TYPE_PTR_P (type1) && TYPE_PTR_P (type2))\n+\t      || (TYPE_PTRMEM_P (type1) && TYPE_PTRMEM_P (type2))\n+\t      || ((TYPE_PTRMEMFUNC_P (type1)\n+\t\t   || TREE_CODE (type1) == POINTER_TYPE)\n+\t\t  && null_ptr_cst (args[1])))\n+\t    {\n+\t      type2 = type1;\n+\t      break;\n+\t    }\n+\t  return candidates;\n+\n+\tdefault:\n+\t  my_friendly_abort (367);\n+\t}\n+      type1 = build_reference_type (type1);\n+      break;\n+\n+    case COND_EXPR:\n+      if (TREE_CODE (type1) == ENUMERAL_TYPE && type1 == type2)\n+\tbreak;\n+      else if (TREE_CODE (type1) == ENUMERAL_TYPE\n+\t       || TREE_CODE (type2) == ENUMERAL_TYPE)\n+\treturn candidates;\n+      if (ARITHMETIC_TYPE_P (type1) && ARITHMETIC_TYPE_P (type2))\n+\tbreak;\n+      if (TREE_CODE (type1) == TREE_CODE (type2)\n+\t  && (TREE_CODE (type1) == REFERENCE_TYPE\n+\t      || TREE_CODE (type1) == POINTER_TYPE\n+\t      || TYPE_PTRMEMFUNC_P (type1)\n+\t      || IS_AGGR_TYPE (type1)))\n+\tbreak;\n+      if (TREE_CODE (type1) == REFERENCE_TYPE\n+\t  || TREE_CODE (type2) == REFERENCE_TYPE)\n+\treturn candidates;\n+      if (((TYPE_PTRMEMFUNC_P (type1) || TREE_CODE (type1) == POINTER_TYPE)\n+\t   && null_ptr_cst (args[1]))\n+\t  || IS_AGGR_TYPE (type1))\n+\t{\n+\t  type2 = type1;\n+\t  break;\n+\t}\n+      if (((TYPE_PTRMEMFUNC_P (type2) || TREE_CODE (type2) == POINTER_TYPE)\n+\t   && null_ptr_cst (args[0]))\n+\t  || IS_AGGR_TYPE (type2))\n+\t{\n+\t  type1 = type2;\n+\t  break;\n+\t}\n+      return candidates;\n+\n+    default:\n+      my_friendly_abort (367);\n+    }\n+\n+  /* If we're dealing with two pointer types, we need candidates\n+     for both of them.  */\n+  if (type2 && type1 != type2\n+      && TREE_CODE (type1) == TREE_CODE (type2)\n+      && (TREE_CODE (type1) == REFERENCE_TYPE\n+\t  || TREE_CODE (type1) == POINTER_TYPE\n+\t  || TYPE_PTRMEMFUNC_P (type1)\n+\t  || IS_AGGR_TYPE (type1)))\n+    {\n+      candidates = build_builtin_candidate\n+\t(candidates, fnname, type1, type1, args, argtypes, flags);\n+      return build_builtin_candidate\n+\t(candidates, fnname, type2, type2, args, argtypes, flags);\n+    }\n+\n+  return build_builtin_candidate\n+    (candidates, fnname, type1, type2, args, argtypes, flags);\n+}\n+\n+tree\n+type_decays_to (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return build_pointer_type (TREE_TYPE (type));\n+  if (TREE_CODE (type) == FUNCTION_TYPE)\n+    return build_pointer_type (type);\n+  return type;\n+}\n+\n+/* There are three conditions of builtin candidates:\n+\n+   1) bool-taking candidates.  These are the same regardless of the input.\n+   2) pointer-pair taking candidates.  These are generated for each type\n+      one of the input types converts to.\n+   3) arithmetic candidates.  According to the WP, we should generate\n+      all of these, but I'm trying not to... */\n+\n+static struct z_candidate *\n+add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n+     struct z_candidate *candidates;\n+     enum tree_code code, code2;\n+     tree fnname, *args;\n+     int flags;\n+{\n+  int ref1, i;\n+  tree type, argtypes[3], types[2];\n+\n+  for (i = 0; i < 3; ++i)\n+    {\n+      if (args[i])\n+\targtypes[i]  = cp_build_type_variant\n+\t  (TREE_TYPE (args[i]), TREE_READONLY (args[i]),\n+\t   TREE_THIS_VOLATILE (args[i]));\n+      else\n+\targtypes[i] = NULL_TREE;\n+    }\n+\n+  switch (code)\n+    {\n+/* 4 For every pair T, VQ), where T is an arithmetic or  enumeration  type,\n+     and  VQ  is  either  volatile or empty, there exist candidate operator\n+     functions of the form\n+\t\t VQ T&   operator++(VQ T&);  */\n+\n+    case POSTINCREMENT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case MODIFY_EXPR:\n+      ref1 = 1;\n+      break;\n+\n+/* 24There also exist candidate operator functions of the form\n+\t     bool    operator!(bool);\n+\t     bool    operator&&(bool, bool);\n+\t     bool    operator||(bool, bool);  */\n+\n+    case TRUTH_NOT_EXPR:\n+      return build_builtin_candidate\n+\t(candidates, fnname, boolean_type_node,\n+\t NULL_TREE, args, argtypes, flags);\n+\n+    case TRUTH_ORIF_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+      return build_builtin_candidate\n+\t(candidates, fnname, boolean_type_node,\n+\t boolean_type_node, args, argtypes, flags);\n+\n+    case ADDR_EXPR:\n+    case COMPOUND_EXPR:\n+    case COMPONENT_REF:\n+      return candidates;\n+\n+    default:\n+      ref1 = 0;\n+    }\n+\n+  types[0] = types[1] = NULL_TREE;\n+\n+  for (i = 0; i < 2; ++i)\n+    {\n+      if (! args[i])\n+\t;\n+      else if (IS_AGGR_TYPE (argtypes[i]))\n+\t{\n+\t  tree convs = lookup_conversions (argtypes[i]);\n+\n+\t  if (code == COND_EXPR)\n+\t    {\n+\t      if (real_lvalue_p (args[i]))\n+\t\ttypes[i] = tree_cons\n+\t\t  (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n+\n+\t      types[i] = tree_cons\n+\t\t(NULL_TREE, TYPE_MAIN_VARIANT (argtypes[i]), types[i]);\n+\t    }\n+\t\t\n+\t  else if (! convs || (i == 0 && code == MODIFY_EXPR))\n+\t    return candidates;\n+\n+\t  for (; convs; convs = TREE_CHAIN (convs))\n+\t    {\n+\t      type = TREE_TYPE (TREE_TYPE (TREE_VALUE (convs)));\n+\n+\t      if (i == 0 && ref1\n+\t\t  && (TREE_CODE (type) != REFERENCE_TYPE\n+\t\t      || TYPE_READONLY (TREE_TYPE (type))))\n+\t\tcontinue;\n+\n+\t      if (code == COND_EXPR && TREE_CODE (type) == REFERENCE_TYPE)\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\n+\t      type = non_reference (type);\n+\t      if (i != 0 || ! ref1)\n+\t\t{\n+\t\t  type = type_decays_to (TYPE_MAIN_VARIANT (type));\n+\t\t  if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\t    types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t\t  type = type_promotes_to (type);\n+\t\t}\n+\n+\t      if (! value_member (type, types[i]))\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (code == COND_EXPR && real_lvalue_p (args[i]))\n+\t    types[i] = tree_cons\n+\t      (NULL_TREE, build_reference_type (argtypes[i]), types[i]);\n+\t  type = non_reference (argtypes[i]);\n+\t  if (i != 0 || ! ref1)\n+\t    {\n+\t      type = type_decays_to (TYPE_MAIN_VARIANT (type));\n+\t      if (code == COND_EXPR && TREE_CODE (type) == ENUMERAL_TYPE)\n+\t\ttypes[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t      type = type_promotes_to (type);\n+\t    }\n+\t  types[i] = tree_cons (NULL_TREE, type, types[i]);\n+\t}\n+    }\n+\n+  for (; types[0]; types[0] = TREE_CHAIN (types[0]))\n+    {\n+      if (types[1])\n+\tfor (type = types[1]; type; type = TREE_CHAIN (type))\n+\t  candidates = add_builtin_candidate\n+\t    (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n+\t     TREE_VALUE (type), args, argtypes, flags);\n+      else\n+\tcandidates = add_builtin_candidate\n+\t  (candidates, code, code2, fnname, TREE_VALUE (types[0]),\n+\t   NULL_TREE, args, argtypes, flags);\n+    }\n+\n+  return candidates;\n+}\n+\n+static struct z_candidate *\n+add_template_candidate (candidates, tmpl, arglist, flags)\n+     struct z_candidate *candidates;\n+     tree tmpl, arglist;\n+     int flags;\n+{\n+  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (tmpl));\n+  tree *targs = (tree *) alloca (sizeof (tree) * ntparms);\n+  struct z_candidate *cand;\n+  int i, dummy; \n+  tree fn;\n+\n+  i = type_unification (DECL_TEMPLATE_PARMS (tmpl), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (tmpl)),\n+\t\t\targlist, &dummy, 0, 0);\n+  if (i != 0)\n+    return candidates;\n+\n+  fn = instantiate_template (tmpl, targs);\n+  if (fn == error_mark_node)\n+    return candidates;\n+\n+  cand = add_function_candidate (candidates, fn, arglist, flags);\n+  cand->template = DECL_TEMPLATE_INFO (fn);\n+  return cand;\n+}\n+\n+static int\n+any_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  for (; cands; cands = cands->next)\n+    if (cands->viable)\n+      return 1;\n+  return 0;\n+}\n+\n+static struct z_candidate *\n+splice_viable (cands)\n+     struct z_candidate *cands;\n+{\n+  struct z_candidate **p = &cands;\n+\n+  for (; *p; )\n+    {\n+      if ((*p)->viable)\n+\tp = &((*p)->next);\n+      else\n+\t*p = (*p)->next;\n+    }\n+\n+  return cands;\n+}\n+\n+tree\n+build_this (obj)\n+     tree obj;\n+{\n+  /* Fix this to work on non-lvalues.  */\n+  return build_unary_op (ADDR_EXPR, obj, 0);\n+}\n+\n+static void\n+print_z_candidates (candidates)\n+     struct z_candidate *candidates;\n+{\n+  if (! candidates)\n+    return;\n+\n+  if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n+    {\n+      if (candidates->fn == ansi_opname [COND_EXPR])\n+\tcp_error (\"candidates are: %D(%T, %T, %T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n+      else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n+\tcp_error (\"candidates are: %D(%T, %T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n+      else\n+\tcp_error (\"candidates are: %D(%T) <builtin>\", candidates->fn,\n+\t\t  TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n+    }\n+  else\n+    cp_error_at (\"candidates are: %D\", candidates->fn);\n+  candidates = candidates->next;\n+\n+  for (; candidates; candidates = candidates->next)\n+    {\n+      if (TREE_CODE (candidates->fn) == IDENTIFIER_NODE)\n+\t{\n+\t  if (candidates->fn == ansi_opname [COND_EXPR])\n+\t    cp_error (\"                %D(%T, %T, %T) <builtin>\",\n+\t\t      candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 2)));\n+\t  else if (TREE_VEC_LENGTH (candidates->convs) == 2)\n+\t    cp_error (\"                %D(%T, %T) <builtin>\", candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)),\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 1)));\n+\t  else\n+\t    cp_error (\"                %D(%T) <builtin>\", candidates->fn,\n+\t\t      TREE_TYPE (TREE_VEC_ELT (candidates->convs, 0)));\n+\t}\n+      else\n+\tcp_error_at (\"                %D\", candidates->fn);\n+    }\n+}\n+\n+/* Returns the best overload candidate to perform the requested\n+   conversion.  */\n+\n+static struct z_candidate *\n+build_user_type_conversion_1 (totype, expr, flags)\n+     tree totype, expr;\n+     int flags;\n+{\n+  struct z_candidate *candidates, *cand;\n+  tree fromtype = TREE_TYPE (expr);\n+  tree ctors = NULL_TREE, convs = NULL_TREE, *p;\n+  tree args;\n+\n+  if (IS_AGGR_TYPE (totype))\n+    ctors = lookup_fnfields (TYPE_BINFO (totype), ctor_identifier, 0);\n+  if (IS_AGGR_TYPE (fromtype)\n+      && (! IS_AGGR_TYPE (totype) || ! DERIVED_FROM_P (totype, fromtype)))\n+    convs = lookup_conversions (fromtype);\n+\n+  candidates = 0;\n+  flags |= LOOKUP_NO_CONVERSION;\n+\n+  if (ctors)\n+    {\n+      ctors = TREE_VALUE (ctors);\n+      args = build_tree_list (NULL_TREE, expr);\n+    }\n+  for (; ctors; ctors = DECL_CHAIN (ctors))\n+    {\n+      if ((flags & LOOKUP_ONLYCONVERTING) && DECL_NONCONVERTING_P (ctors))\n+\tcontinue;\n+\n+      candidates = add_function_candidate (candidates, ctors, args, flags);\n+      candidates->second_conv = build1 (IDENTITY_CONV, totype, NULL_TREE);\n+      candidates->basetype_path = TYPE_BINFO (totype);\n+    }\n+\n+  if (convs)\n+    args = build_tree_list (NULL_TREE, build_this (expr));\n+\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree fn = TREE_VALUE (convs);\n+      tree ics = implicit_conversion\n+\t(totype, TREE_TYPE (TREE_TYPE (fn)), 0, LOOKUP_NO_CONVERSION);\n+      if (ics)\n+\tfor (; fn; fn = DECL_CHAIN (fn))\n+\t  {\n+\t    candidates = add_function_candidate (candidates, fn, args, flags);\n+\t    candidates->second_conv = ics;\n+\t    candidates->basetype_path = TREE_PURPOSE (convs);\n+\t  }\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+#if 0\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    /* say why this one won't work or try to be loose */;\n+\t  else\n+\t    cp_error (\"no viable candidates\");\n+\t}\n+#endif\n+\n+      return 0;\n+    }\n+\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, totype);\n+\n+  if (cand == 0)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  cp_error (\"ambiguous user-defined type conversion\");\n+\t  print_z_candidates (candidates);\n+\t}\n+\n+      cand = candidates;\t/* any one will do */\n+      cand->second_conv = build1 (AMBIG_CONV, totype, expr);\n+      ICS_USER_FLAG (cand->second_conv) = 1;\n+\n+      return cand;\n+    }\n+\n+  for (p = &(cand->second_conv); TREE_CODE (*p) != IDENTITY_CONV; )\n+    p = &(TREE_OPERAND (*p, 0));\n+\n+  *p = build\n+    (USER_CONV,\n+     (DECL_CONSTRUCTOR_P (cand->fn)\n+      ? totype : non_reference (TREE_TYPE (TREE_TYPE (cand->fn)))),\n+     NULL_TREE, cand->fn, cand->convs, cand->basetype_path);\n+  ICS_USER_FLAG (cand->second_conv) = 1;\n+\n+  return cand;\n+}\n+\n+tree\n+build_user_type_conversion (totype, expr, flags)\n+     tree totype, expr, flags;\n+{\n+  struct z_candidate *cand\n+    = build_user_type_conversion_1 (totype, expr, flags);\n+\n+  if (cand)\n+    {\n+      if (TREE_CODE (cand->second_conv) == AMBIG_CONV)\n+\treturn error_mark_node;\n+      return convert_from_reference (convert_like (cand->second_conv, expr));\n+    }\n+  return NULL_TREE;\n+}\n+\n+tree\n+build_new_function_call (fn, args, obj)\n+     tree fn, args, obj;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+ \n+  if (obj == NULL_TREE && TREE_CODE (fn) == TREE_LIST)\n+    {\n+      tree t = TREE_VALUE (fn);\n+\n+      for (; t; t = DECL_CHAIN (t))\n+\t{\n+\t  if (TREE_CODE (t) == TEMPLATE_DECL)\n+\t    candidates = add_template_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t  else\n+\t    candidates = add_function_candidate\n+\t      (candidates, t, args, LOOKUP_NORMAL);\n+\t}\n+\n+      if (! any_viable (candidates))\n+\t{\n+\t  if (candidates && ! candidates->next)\n+\t    return build_function_call (candidates->fn, args);\n \t  else\n \t    cp_error (\"no viable candidates\");\n \t  return error_mark_node;\n@@ -2470,6 +3270,420 @@ build_new_function_call (fn, args, obj)\n   return build_function_call (fn, args);\n }\n \n+tree\n+build_object_call (obj, args)\n+     tree obj, args;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree fns, convs, mem_args, *p;\n+  enum tree_code code2 = NOP_EXPR;\n+  tree type = TREE_TYPE (obj);\n+\n+  fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname [CALL_EXPR], 0);\n+\n+  if (fns)\n+    {\n+      tree fn = TREE_VALUE (fns);\n+      mem_args = tree_cons (NULL_TREE, build_this (obj), args);\n+\n+      for (; fn; fn = DECL_CHAIN (fn))\n+\t{\n+\t  candidates = add_function_candidate\n+\t    (candidates, fn, mem_args, LOOKUP_NORMAL);\n+\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t}\n+    }\n+\n+  convs = lookup_conversions (type);\n+\n+  for (; convs; convs = TREE_CHAIN (convs))\n+    {\n+      tree fn = TREE_VALUE (convs);\n+      tree totype = TREE_TYPE (TREE_TYPE (fn));\n+\n+      if (TREE_CODE (totype) == POINTER_TYPE\n+\t  && TREE_CODE (TREE_TYPE (totype)) == FUNCTION_TYPE)\n+\t{\n+\t  candidates = add_conv_candidate (candidates, fn, obj, args);\n+\t  candidates->basetype_path = TREE_PURPOSE (convs);\n+\t}\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+      cp_error (\"no viable candidates\");\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, NULL_TREE);\n+\n+  if (cand == 0)\n+    {\n+      cp_error (\"ambiguous object call\");\n+      print_z_candidates (candidates);\n+      return error_mark_node;\n+    }\n+\n+  if (DECL_NAME (cand->fn) == ansi_opname [CALL_EXPR])\n+    return build_over_call (cand->fn, cand->convs, mem_args, LOOKUP_NORMAL);\n+\n+  obj = convert_like (TREE_VEC_ELT (cand->convs, 0), obj);\n+\n+  /* FIXME */\n+  return build_function_call (obj, args);\n+}\n+\n+static void\n+op_error (code, code2, arg1, arg2, arg3, problem)\n+     enum tree_code code, code2;\n+     tree arg1, arg2, arg3;\n+     char *problem;\n+{\n+  char * opname\n+    = (code == MODIFY_EXPR ? assignop_tab [code2] : opname_tab [code]);\n+\n+  switch (code)\n+    {\n+    case COND_EXPR:\n+      cp_error (\"%s for `%T ? %T : %T'\", problem,\n+\t\tTREE_TYPE (arg1), TREE_TYPE (arg2), TREE_TYPE (arg3));\n+      break;\n+    case POSTINCREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      cp_error (\"%s for `%T%s'\", problem, TREE_TYPE (arg1), opname);\n+      break;\n+    case ARRAY_REF:\n+      cp_error (\"%s for `%T[%T]'\", problem,\n+\t\tTREE_TYPE (arg1), TREE_TYPE (arg2));\n+      break;\n+    default:\n+      if (arg2)\n+\tcp_error (\"%s for `%T %s %T'\", problem,\n+\t\t  TREE_TYPE (arg1), opname, TREE_TYPE (arg2));\n+      else\n+\tcp_error (\"%s for `%s%T'\", problem, opname, TREE_TYPE (arg1));\n+    }\n+}\n+\n+tree\n+build_new_op (code, flags, arg1, arg2, arg3)\n+     enum tree_code code;\n+     int flags;\n+     tree arg1, arg2, arg3;\n+{\n+  struct z_candidate *candidates = 0, *cand;\n+  tree fns, mem_arglist, arglist, fnname, *p;\n+  enum tree_code code2 = NOP_EXPR;\n+\n+  if (arg1 == error_mark_node)\n+    return error_mark_node;\n+\n+  if (code == MODIFY_EXPR)\n+    {\n+      code2 = TREE_CODE (arg3);\n+      arg3 = NULL_TREE;\n+      fnname = ansi_assopname[code2];\n+    }\n+  else\n+    fnname = ansi_opname[code];\n+\n+  switch (code)\n+    {\n+    case NEW_EXPR:\n+    case VEC_NEW_EXPR:\n+      {\n+\ttree rval;\n+\n+\targlist = tree_cons (NULL_TREE, arg2, arg3);\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_new_function_call\n+\t    (lookup_name_nonclass (fnname), arglist, NULL_TREE);\n+\n+\t/* FIXME */\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, arg1, error_mark_node),\n+\t\t\t       \"new\"),\n+\t   fnname, arglist, NULL_TREE, flags);\n+\tif (rval == error_mark_node)\n+\t  /* User might declare fancy operator new, but invoke it\n+\t     like standard one.  */\n+\t  return rval;\n+\n+\tTREE_TYPE (rval) = arg1;\n+\tTREE_CALLS_NEW (rval) = 1;\n+\treturn rval;\n+      }\n+\n+    case VEC_DELETE_EXPR:\n+    case DELETE_EXPR:\n+      {\n+\ttree rval;\n+\n+\tif (flags & LOOKUP_GLOBAL)\n+\t  return build_new_function_call\n+\t    (lookup_name_nonclass (fnname),\n+\t     build_tree_list (NULL_TREE, arg1), NULL_TREE);\n+\n+\targlist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+\n+\targ1 = TREE_TYPE (arg1);\n+\n+\t/* This handles the case where we're trying to delete\n+\t   X (*a)[10];\n+\t   a=new X[5][10];\n+\t   delete[] a; */\n+\t   \n+\tif (TREE_CODE (TREE_TYPE (arg1)) == ARRAY_TYPE)\n+\t  {\n+\t    /* Strip off the pointer and the array.  */\n+\t    arg1 = TREE_TYPE (TREE_TYPE (arg1));\n+\n+\t    while (TREE_CODE (arg1) == ARRAY_TYPE)\n+\t\targ1 = (TREE_TYPE (arg1));\n+\n+\t    arg1 = build_pointer_type (arg1);\n+\t  }\n+\n+\t/* FIXME */\n+\trval = build_method_call\n+\t  (build_indirect_ref (build1 (NOP_EXPR, arg1,\n+\t\t\t\t       error_mark_node),\n+\t\t\t       NULL_PTR),\n+\t   fnname, arglist, NULL_TREE, flags);\n+#if 0\n+\t/* This can happen when operator delete is protected.  */\n+\tmy_friendly_assert (rval != error_mark_node, 250);\n+\tTREE_TYPE (rval) = void_type_node;\n+#endif\n+\treturn rval;\n+      }\n+\n+    case CALL_EXPR:\n+      return build_object_call (arg1, arg2);\n+    }\n+\n+  /* The comma operator can have void args.  */\n+  if (TREE_CODE (arg1) == OFFSET_REF)\n+    arg1 = resolve_offset_ref (arg1);\n+  if (arg2 && TREE_CODE (arg2) == OFFSET_REF)\n+    arg2 = resolve_offset_ref (arg2);\n+  if (arg3 && TREE_CODE (arg3) == OFFSET_REF)\n+    arg3 = resolve_offset_ref (arg3);\n+\n+  if (! IS_OVERLOAD_TYPE (TREE_TYPE (arg1))\n+      && (! arg2 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg2)))\n+      && (! arg3 || ! IS_OVERLOAD_TYPE (TREE_TYPE (arg3))))\n+    return NULL_TREE;\n+\n+  if (code == POSTINCREMENT_EXPR || code == POSTDECREMENT_EXPR)\n+    arg2 = integer_zero_node;\n+\n+  fns = lookup_name_nonclass (fnname);\n+  /* + Koenig lookup */\n+\n+  if (arg2 && arg3)\n+    arglist = tree_cons (NULL_TREE, arg1, tree_cons\n+\t\t      (NULL_TREE, arg2, build_tree_list (NULL_TREE, arg3)));\n+  else if (arg2)\n+    arglist = tree_cons (NULL_TREE, arg1, build_tree_list (NULL_TREE, arg2));\n+  else\n+    arglist = build_tree_list (NULL_TREE, arg1);\n+\n+  if (fns && TREE_CODE (fns) == TREE_LIST)\n+    fns = TREE_VALUE (fns);\n+  for (; fns; fns = DECL_CHAIN (fns))\n+    {\n+      if (TREE_CODE (fns) == TEMPLATE_DECL)\n+\tcandidates = add_template_candidate (candidates, fns, arglist, flags);\n+      else\n+\tcandidates = add_function_candidate (candidates, fns, arglist, flags);\n+    }\n+\n+  if (IS_AGGR_TYPE (TREE_TYPE (arg1)))\n+    fns = lookup_fnfields (TYPE_BINFO (TREE_TYPE (arg1)), fnname, 0);\n+  else\n+    fns = NULL_TREE;\n+\n+  if (fns)\n+    {\n+      tree fn = TREE_VALUE (fns);\n+      mem_arglist = tree_cons (NULL_TREE, build_this (arg1), TREE_CHAIN (arglist));\n+      for (; fn; fn = DECL_CHAIN (fn))\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (fn)) == METHOD_TYPE)\n+\t    candidates = add_function_candidate\n+\t      (candidates, fn, mem_arglist, flags);\n+\t  else\n+\t    candidates = add_function_candidate (candidates, fn, arglist, flags);\n+\t  \n+\t  candidates->basetype_path = TREE_PURPOSE (fns);\n+\t}\n+    }\n+\n+#if 0 /* Don't handle builtin COND_EXPR for now */\n+  if (code != COND_EXPR)\n+#endif\n+    {\n+      tree args[3];\n+\n+      /* Rearrange the arguments for ?: so that add_builtin_candidate only has\n+\t to know about two args; a builtin candidate will always have a first\n+\t parameter of type bool.  We'll handle that in\n+\t build_builtin_candidate.  */\n+      if (code == COND_EXPR)\n+\t{\n+\t  args[0] = arg2;\n+\t  args[1] = arg3;\n+\t  args[2] = arg1;\n+\t}\n+      else\n+\t{\n+\t  args[0] = arg1;\n+\t  args[1] = arg2;\n+\t  args[2] = NULL_TREE;\n+\t}\n+\n+      candidates = add_builtin_candidates\n+\t(candidates, code, code2, fnname, args, flags);\n+    }\n+\n+  if (! any_viable (candidates))\n+    {\n+      switch (code)\n+\t{\n+\tcase POSTINCREMENT_EXPR:\n+\tcase POSTDECREMENT_EXPR:\n+\t  /* Look for an `operator++ (int)'.  If they didn't have\n+\t     one, then we fall back to the old way of doing things.  */\n+\t  if (flags & LOOKUP_COMPLAIN)\n+\t    cp_pedwarn (\"no `%D (int)' declared for postfix `%s', trying prefix operator instead\",\n+\t\t\tfnname, opname_tab [code]);\n+\t  if (code == POSTINCREMENT_EXPR)\n+\t    code = PREINCREMENT_EXPR;\n+\t  else\n+\t    code = PREDECREMENT_EXPR;\t\n+\t  return build_new_op (code, flags, arg1, NULL_TREE, NULL_TREE);\n+\t  \n+\t  /* FIXME */\n+\tcase ADDR_EXPR:\n+\t  /*return build_unary_op (code, arg1, 1);*/\n+\tcase COMPOUND_EXPR:\n+\t  /*return build (COMPOUND_EXPR, TREE_TYPE (arg2),\n+\t\t\tbreak_out_cleanups (arg1), arg2);*/\n+\tcase COMPONENT_REF:\n+\t  /*return build_x_arrow (arg1);*/\n+#if 0 /* Don't handle builtin COND_EXPR for now */\n+\tcase COND_EXPR:\n+#endif\n+\t  return NULL_TREE;\n+\t}\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  op_error (code, code2, arg1, arg2, arg3, \"no match\");\n+\t  print_z_candidates (candidates);\n+\t}\n+      return error_mark_node;\n+    }\n+  candidates = splice_viable (candidates);\n+  cand = tourney (candidates, NULL_TREE);\n+\n+  if (cand == 0)\n+    {\n+      if (flags & LOOKUP_COMPLAIN)\n+\t{\n+\t  op_error (code, code2, arg1, arg2, arg3, \"ambiguous overload\");\n+\t  print_z_candidates (candidates);\n+\t}\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (cand->fn) == FUNCTION_DECL)\n+    {\n+      extern int warn_synth;\n+      if (warn_synth\n+\t  && fnname == ansi_opname[MODIFY_EXPR]\n+\t  && DECL_ARTIFICIAL (cand->fn)\n+\t  && candidates->next\n+\t  && ! candidates->next->next)\n+\t{\n+\t  cp_warning (\"using synthesized `%#D' for copy assignment\",\n+\t\t      cand->fn);\n+\t  cp_warning_at (\"  where cfront would use `%#D'\",\n+\t\t\t cand == candidates\n+\t\t\t ? candidates->next->fn\n+\t\t\t : candidates->fn);\n+\t}\n+\n+      if (DECL_FUNCTION_MEMBER_P (cand->fn))\n+\tenforce_access (cand->basetype_path, cand->fn);\n+\n+      return build_over_call\n+\t(cand->fn, cand->convs,\n+\t TREE_CODE (TREE_TYPE (cand->fn)) == METHOD_TYPE\n+\t ? mem_arglist : arglist,\n+\t LOOKUP_NORMAL);\n+    }\n+\n+  arg1 = convert_from_reference\n+    (convert_like (TREE_VEC_ELT (cand->convs, 0), arg1));\n+  if (arg2)\n+    arg2 = convert_like (TREE_VEC_ELT (cand->convs, 1), arg2);\n+  if (arg3)\n+    arg3 = convert_like (TREE_VEC_ELT (cand->convs, 2), arg3);\n+\n+  switch (code)\n+    {\n+    case MODIFY_EXPR:\n+      return build_modify_expr (arg1, code2, arg2);\n+\n+    case INDIRECT_REF:\n+      return build_indirect_ref (arg1, \"unary *\");\n+\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case TRUNC_DIV_EXPR:\n+    case GT_EXPR:\n+    case LT_EXPR:\n+    case GE_EXPR:\n+    case LE_EXPR:\n+    case EQ_EXPR:\n+    case NE_EXPR:\n+    case MAX_EXPR:\n+    case MIN_EXPR:\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+    case TRUNC_MOD_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case TRUTH_ANDIF_EXPR:\n+    case TRUTH_ORIF_EXPR:\n+      return build_binary_op_nodefault (code, arg1, arg2, code);\n+\n+    case CONVERT_EXPR:\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+    case TRUTH_NOT_EXPR:\n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      return build_unary_op (code, arg1, 1);\n+\n+    case ARRAY_REF:\n+      return build_array_ref (arg1, arg2);\n+\n+    case COND_EXPR:\n+      return build_conditional_expr (arg1, arg2, arg3);\n+\n+    default:\n+      my_friendly_abort (367);\n+    }\n+}\n+\n void\n enforce_access (basetype_path, function)\n      tree basetype_path, function;\n@@ -2492,7 +3706,9 @@ enforce_access (basetype_path, function)\n     }\n }\n \n-tree\n+/* Perform the conversions in CONVS on the expression EXPR.  */\n+\n+static tree\n convert_like (convs, expr)\n      tree convs, expr;\n {\n@@ -2514,7 +3730,7 @@ convert_like (convs, expr)\n \n \treturn expr;\n       }\n-    case EXACT_CONV:\n+    case IDENTITY_CONV:\n       if (type_unknown_p (expr))\n \texpr = instantiate_type (TREE_TYPE (convs), expr, 1);\n       return expr;\n@@ -2525,20 +3741,28 @@ convert_like (convs, expr)\n     };\n \n   expr = convert_like (TREE_OPERAND (convs, 0), expr);\n+  if (expr == error_mark_node)\n+    return error_mark_node;\n+\n   switch (TREE_CODE (convs))\n     {\n+    case BASE_CONV:\n+    case RVALUE_CONV:\n+      return build_user_type_conversion\n+\t(TREE_TYPE (convs), expr, LOOKUP_NORMAL);\n     case REF_BIND:\n       return convert_to_reference\n-\t(build_reference_type (TREE_TYPE (convs)), expr,\n-\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION, error_mark_node);\n+\t(TREE_TYPE (convs), expr,\n+\t CONV_IMPLICIT, LOOKUP_NORMAL|LOOKUP_NO_CONVERSION|INDIRECT_BIND,\n+\t error_mark_node);\n     case LVALUE_CONV:\n       return decay_conversion (expr);\n     }\n   return cp_convert (TREE_TYPE (convs), expr, CONV_IMPLICIT,\n \t\t     LOOKUP_NORMAL|LOOKUP_NO_CONVERSION);\n }\n \n-tree\n+static tree\n convert_default_arg (type, arg)\n      tree type, arg;\n {\n@@ -2569,15 +3793,15 @@ convert_default_arg (type, arg)\n   return arg;\n }\n \n-tree\n+static tree\n build_over_call (fn, convs, args, flags)\n      tree fn, convs, args;\n      int flags;\n {\n   tree converted_args = NULL_TREE;\n   tree parm = TYPE_ARG_TYPES (TREE_TYPE (fn));\n-  tree conv, arg;\n-  int i;\n+  tree conv, arg, val;\n+  int i = 0;\n \n   if (args && TREE_CODE (args) != TREE_LIST)\n     args = build_tree_list (NULL_TREE, args);\n@@ -2605,14 +3829,23 @@ build_over_call (fn, convs, args, flags)\n \t converted_args);\n       parm = TREE_CHAIN (parm);\n       arg = TREE_CHAIN (arg);\n-      conv = TREE_CHAIN (conv);\n+      ++i;\n     }\n \n-  for (i = 0; conv = TREE_VEC_ELT (convs, i), arg && parm;\n+  for (; conv = TREE_VEC_ELT (convs, i), arg && parm;\n        parm = TREE_CHAIN (parm), arg = TREE_CHAIN (arg), ++i)\n-    converted_args = tree_cons\n-      (NULL_TREE, convert_like (conv, TREE_VALUE (arg)),\n-       converted_args);\n+    {\n+      tree type = TREE_VALUE (parm);\n+      val = convert_like (conv, TREE_VALUE (arg));\n+\n+#ifdef PROMOTE_PROTOTYPES\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == ENUMERAL_TYPE)\n+\t  && (TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)))\n+\tval = default_conversion (val);\n+#endif\n+      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+    }\n \n   /* Default arguments */\n   for (; parm && parm != void_list_node; parm = TREE_CHAIN (parm))\n@@ -2623,8 +3856,24 @@ build_over_call (fn, convs, args, flags)\n \n   /* Ellipsis */\n   for (; arg; arg = TREE_CHAIN (arg))\n-    converted_args = tree_cons\n-      (NULL_TREE, default_conversion (TREE_VALUE (arg)), converted_args);\n+    {\n+      val = TREE_VALUE (arg);\n+\n+      if (TREE_CODE (TREE_TYPE (val)) == REAL_TYPE\n+\t  && (TYPE_PRECISION (TREE_TYPE (val))\n+\t      < TYPE_PRECISION (double_type_node)))\n+\t/* Convert `float' to `double'.  */\n+\tval = convert (double_type_node, val);\n+      else if (TYPE_LANG_SPECIFIC (TREE_TYPE (val))\n+\t       && ! TYPE_HAS_TRIVIAL_INIT_REF (TREE_TYPE (val)))\n+\tcp_warning (\"cannot pass objects of type `%T' through `...'\",\n+\t\t    TREE_TYPE (val));\n+      else\n+\t/* Convert `short' and `char' to full-size `int'.  */\n+\tval = default_conversion (val);\n+\n+      converted_args = tree_cons (NULL_TREE, val, converted_args);\n+    }\n \n   converted_args = nreverse (converted_args);\n \n@@ -2648,8 +3897,10 @@ build_over_call (fn, convs, args, flags)\n   else\n     fn = build_addr_func (fn);\n \n-  return convert_from_reference\n-    (build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args));\n+  fn = build_call (fn, TREE_TYPE (TREE_TYPE (TREE_TYPE (fn))), converted_args);\n+  if (TREE_TYPE (fn) == void_type_node)\n+    return fn;\n+  return convert_from_reference (require_complete_type (fn));\n }\n \n /* Compare two implicit conversion sequences that differ only in their\n@@ -2662,16 +3913,13 @@ compare_qual (ics1, ics2)\n   tree to1 = TREE_TYPE (ics1);\n   tree to2 = TREE_TYPE (ics2);\n \n-  if (TREE_CODE (ics1) != REF_BIND)\n+  to1 = TREE_TYPE (to1);\n+  to2 = TREE_TYPE (to2);\n+\n+  if (TREE_CODE (to1) == OFFSET_TYPE)\n     {\n       to1 = TREE_TYPE (to1);\n       to2 = TREE_TYPE (to2);\n-\n-      if (TREE_CODE (to1) == OFFSET_TYPE)\n-\t{\n-\t  to1 = TREE_TYPE (to1);\n-\t  to2 = TREE_TYPE (to2);\n-\t}\n     }\n \n   if (TYPE_READONLY (to1) >= TYPE_READONLY (to2)\n@@ -2696,7 +3944,7 @@ compare_qual (ics1, ics2)\n      -1: ics2 is better than ics1\n       0: ics1 and ics2 are indistinguishable */\n \n-int\n+static int\n compare_ics (ics1, ics2)\n      tree ics1, ics2;\n {\n@@ -2718,9 +3966,11 @@ compare_ics (ics1, ics2)\n       tree t1, t2;\n \n       for (t1 = ics1; TREE_CODE (t1) != USER_CONV; t1 = TREE_OPERAND (t1, 0))\n-\t;\n+\tif (TREE_CODE (t1) == AMBIG_CONV)\n+\t  return 0;\n       for (t2 = ics2; TREE_CODE (t2) != USER_CONV; t2 = TREE_OPERAND (t2, 0))\n-\t;\n+\tif (TREE_CODE (t2) == AMBIG_CONV)\n+\t  return 0;\n \n       if (USER_CONV_FN (t1) != USER_CONV_FN (t2))\n \treturn 0;\n@@ -2751,21 +4001,23 @@ compare_ics (ics1, ics2)\n   if (TREE_CODE (main1) != TREE_CODE (main2))\n     return 0;\n \n-  if (TREE_CODE (main1) == EXACT_CONV\n+  if (TREE_CODE (main1) == IDENTITY_CONV\n       && (TREE_CODE (TREE_TYPE (main1)) == POINTER_TYPE\n \t  || TYPE_PTRMEMFUNC_P (TREE_TYPE (main1))))\n     {\n       if (TREE_TYPE (main1) == TREE_TYPE (main2))\n \treturn compare_qual (ics1, ics2);\n \n+#if 0 /* This is now handled by making identity better than anything else.  */\n       /* existing practice, not WP-endorsed: const char * -> const char *\n \t is better than char * -> const char *.  (jason 6/29/96) */\n       if (TREE_TYPE (ics1) == TREE_TYPE (ics2))\n \treturn -compare_qual (main1, main2);\n+#endif\n     }\n \n   if (TREE_CODE (main1) == PTR_CONV || TREE_CODE (main1) == PMEM_CONV\n-      || TREE_CODE (main1) == REF_BIND)\n+      || TREE_CODE (main1) == REF_BIND || TREE_CODE (main1) == BASE_CONV)\n     {\n       tree to1 = TREE_TYPE (main1);\n       tree from1 = TREE_TYPE (TREE_OPERAND (main1, 0));\n@@ -2783,21 +4035,23 @@ compare_ics (ics1, ics2)\n \t binding15).  */\n       if (TREE_CODE (main1) == REF_BIND)\n \t{\n-\t  if (TYPE_MAIN_VARIANT (to1) == TYPE_MAIN_VARIANT (to2))\n+\t  if (TYPE_MAIN_VARIANT (TREE_TYPE (to1))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (to2)))\n \t    return compare_qual (ics1, ics2);\n \t}\n-      else if (from1 == from2 && to1 == to2)\n+      else if (TREE_CODE (main1) != BASE_CONV && from1 == from2 && to1 == to2)\n \treturn compare_qual (ics1, ics2);\n \t\n       if (TYPE_PTRMEMFUNC_P (to1))\n \t{\n \t  to1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to1));\n \t  from1 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from1));\n \t}\n-      else if (TREE_CODE (main1) != REF_BIND)\n+      else if (TREE_CODE (main1) != BASE_CONV)\n \t{\n \t  to1 = TREE_TYPE (to1);\n-\t  from1 = TREE_TYPE (from1);\n+\t  if (TREE_CODE (main1) != REF_BIND)\n+\t    from1 = TREE_TYPE (from1);\n \n \t  if (TREE_CODE (to1) == OFFSET_TYPE)\n \t    {\n@@ -2811,10 +4065,11 @@ compare_ics (ics1, ics2)\n \t  to2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (to2));\n \t  from2 = TYPE_METHOD_BASETYPE (TYPE_PTRMEMFUNC_FN_TYPE (from2));\n \t}\n-      else if (TREE_CODE (main2) != REF_BIND)\n+      else if (TREE_CODE (main1) != BASE_CONV)\n \t{\n \t  to2 = TREE_TYPE (to2);\n-\t  from2 = TREE_TYPE (from2);\n+\t  if (TREE_CODE (main1) != REF_BIND)\n+\t    from2 = TREE_TYPE (from2);\n \n \t  if (TREE_CODE (to2) == OFFSET_TYPE)\n \t    {\n@@ -2826,6 +4081,14 @@ compare_ics (ics1, ics2)\n       if (! (IS_AGGR_TYPE (from1) && IS_AGGR_TYPE (from2)))\n \treturn 0;\n \n+      /* The sense of pmem conversions is reversed from that of the other\n+\t conversions.  */\n+      if (TREE_CODE (main1) == PMEM_CONV)\n+\t{\n+\t  tree t = from1; from1 = from2; from2 = t;\n+\t  t = to1; to1 = to2; to2 = t;\n+\t}\n+\n       distf = get_base_distance (from1, from2, 0, 0);\n       if (distf == -1)\n \t{\n@@ -2894,7 +4157,8 @@ compare_ics (ics1, ics2)\n      -1: cand2 is better than cand1\n       0: cand1 and cand2 are indistinguishable */\n \n-int joust (cand1, cand2)\n+static int\n+joust (cand1, cand2)\n      struct z_candidate *cand1, *cand2;\n {\n   int winner = 0;\n@@ -2931,6 +4195,9 @@ int joust (cand1, cand2)\n     return 1;\n   else if (cand1->template && ! cand2->template)\n     return -1;\n+  else if (cand1->template && cand2->template)\n+    winner = more_specialized\n+      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template));\n \n   /* or, if not that,\n      the  context  is  an  initialization by user-defined conversion (see\n@@ -2940,9 +4207,21 @@ int joust (cand1, cand2)\n      sequence  than the standard conversion sequence from the return type\n      of F2 to the destination type.  */\n \n-  if (cand1->second_conv)\n+  if (! winner && cand1->second_conv)\n     winner = compare_ics (cand1->second_conv, cand2->second_conv);\n \n+  /* If the built-in candidates are the same, arbitrarily pick one.  */\n+  if (! winner && cand1->fn == cand2->fn\n+      && TREE_CODE (cand1->fn) == IDENTIFIER_NODE)\n+    {\n+      for (i = 0; i < TREE_VEC_LENGTH (cand1->convs); ++i)\n+\tif (! comptypes (TREE_TYPE (TREE_VEC_ELT (cand1->convs, i)),\n+\t\t\t TREE_TYPE (TREE_VEC_ELT (cand2->convs, i)), 1))\n+\t  break;\n+      if (i == TREE_VEC_LENGTH (cand1->convs))\n+\treturn 1;\n+    }\n+\n   return winner;\n }\n \n@@ -2951,7 +4230,7 @@ int joust (cand1, cand2)\n    case of O(n/2) (totally ambiguous); much better than a sorting\n    algorithm.  */\n \n-struct z_candidate *\n+static struct z_candidate *\n tourney (candidates)\n      struct z_candidate *candidates;\n {\n@@ -2995,4 +4274,3 @@ tourney (candidates)\n \n   return champ;\n }\n-#endif"}, {"sha": "6aa922f3f86f9922ec29b751f157a803b5b763f9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -126,8 +126,6 @@ static struct stack_level *decl_stack;\n static tree grokparms\t\t\t\tPROTO((tree, int));\n static tree lookup_nested_type\t\t\tPROTO((tree, tree));\n static char *redeclaration_error_message\tPROTO((tree, tree));\n-extern void* push_eh_context\t\t \tPROTO(());\n-extern void pop_eh_context\t\t \tPROTO((void *));\n \n tree define_function\t\t\n \tPROTO((char *, tree, enum built_in_function, void (*)(), char *));\n@@ -5493,7 +5491,7 @@ init_decl_processing ()\n   init_search_processing ();\n   init_rtti_processing ();\n \n-  if (flag_handle_exceptions)\n+  if (flag_exceptions)\n     init_exception_processing ();\n   if (flag_no_inline)\n     {\n@@ -10892,7 +10890,6 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n   current_function_parms_stored = 0;\n   original_result_rtx = NULL_RTX;\n   base_init_expr = NULL_TREE;\n-  protect_list = NULL_TREE;\n   current_base_init_list = NULL_TREE;\n   current_member_init_list = NULL_TREE;\n   ctor_label = dtor_label = NULL_TREE;\n@@ -11092,7 +11089,11 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \t  = (interface_only\n \t     || (DECL_THIS_INLINE (decl1) && ! flag_implement_inlines));\n       else\n-\tDECL_EXTERNAL (decl1) = 0;\n+\t{\n+\t  DECL_EXTERNAL (decl1) = 0;\n+\t  if (DECL_C_STATIC (decl1))\n+\t    TREE_PUBLIC (decl1) = 0;\n+\t}\t  \n       DECL_NOT_REALLY_EXTERN (decl1) = 0;\n       DECL_INTERFACE_KNOWN (decl1) = 1;\n     }\n@@ -11227,27 +11228,44 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n }\n \f\n void\n-expand_start_early_try_stmts ()\n-{\n-  rtx insns;\n-  start_sequence ();\n-  expand_start_try_stmts ();\n-  insns = get_insns ();\n-  end_sequence ();\n-  store_in_parms (insns);\n-}\n-\n-void\n-store_in_parms (insns)\n+store_after_parms (insns)\n      rtx insns;\n {\n-  rtx last_parm_insn;\n+  rtx x;\n+\n+  for (x = get_insns (); x; x = next_insn (x))\n+    {\n+      if (GET_CODE (x) == NOTE && NOTE_LINE_NUMBER (x) == NOTE_INSN_FUNCTION_BEG)\n+\t{\n+\t  emit_insns_after (insns, x);\n+\t  return;\n+\t}\n+    }\n+#if 0\n+  /* This doesn't work, because the inline output routine doesn't reset\n+     last_parm_insn correctly for get_first_nonparm_insn () to work.  */\n \n   last_parm_insn = get_first_nonparm_insn ();\n   if (last_parm_insn == NULL_RTX)\n     emit_insns (insns);\n   else\n-    emit_insns_before (insns, previous_insn (last_parm_insn));\n+    emit_insns_before (insns,  last_parm_insn);\n+#endif\n+}\n+\n+void\n+expand_start_early_try_stmts ()\n+{\n+  rtx insns;\n+  start_sequence ();\n+  expand_start_try_stmts ();\n+  insns = get_insns ();\n+  end_sequence ();\n+#if 1\n+  emit_insns_after (insns, get_insns ());\n+#else\n+  store_after_parms (insns);\n+#endif\n }\n \n /* Store the parameter declarations into the current function declaration.\n@@ -11395,23 +11413,27 @@ store_parm_decls ()\n     }\n \n   /* Take care of exception handling things. */\n-  if (! current_template_parms && flag_handle_exceptions)\n+  if (! current_template_parms && flag_exceptions)\n     {\n       rtx insns;\n       start_sequence ();\n \n+#if 0\n       /* Mark the start of a stack unwinder if we need one.  */\n       start_eh_unwinder ();\n+#endif\n \n+#if 0\n       /* Do the starting of the exception specifications, if we have any.  */\n       if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n \texpand_start_eh_spec ();\n+#endif\n \n       insns = get_insns ();\n       end_sequence ();\n \n       if (insns)\n-\tstore_in_parms (insns);\n+\tstore_after_parms (insns);\n     }\n   last_dtor_insn = get_last_insn ();\n }\n@@ -11915,7 +11937,7 @@ finish_function (lineno, call_poplevel, nested)\n       /* Generate rtl for function exit.  */\n       expand_function_end (input_filename, lineno, 1);\n \n-      if (flag_handle_exceptions)\n+      if (flag_exceptions)\n \texpand_exception_blocks ();\n     }\n \n@@ -12478,7 +12500,6 @@ struct cp_function\n   tree ctor_label;\n   tree dtor_label;\n   rtx last_dtor_insn;\n-  tree protect_list;\n   tree base_init_list;\n   tree member_init_list;\n   tree base_init_expr;\n@@ -12487,7 +12508,6 @@ struct cp_function\n   rtx result_rtx;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n-  void* eh_context;\n };\n \n \n@@ -12525,14 +12545,11 @@ push_cp_function_context (context)\n   p->parms_stored = current_function_parms_stored;\n   p->result_rtx = original_result_rtx;\n   p->base_init_expr = base_init_expr;\n-  p->protect_list = protect_list;\n   p->temp_name_counter = temp_name_counter;\n   p->base_init_list = current_base_init_list;\n   p->member_init_list = current_member_init_list;\n   p->current_class_ptr = current_class_ptr;\n   p->current_class_ref = current_class_ref;\n-\n-  p->eh_context = push_eh_context ();\n }\n \n /* Restore the variables used during compilation of a C++ function.  */\n@@ -12563,7 +12580,6 @@ pop_cp_function_context (context)\n   ctor_label = p->ctor_label;\n   dtor_label = p->dtor_label;\n   last_dtor_insn = p->last_dtor_insn;\n-  protect_list = p->protect_list;\n   current_function_assigns_this = p->assigns_this;\n   current_function_just_assigned_this = p->just_assigned_this;\n   current_function_parms_stored = p->parms_stored;\n@@ -12575,8 +12591,6 @@ pop_cp_function_context (context)\n   current_class_ptr = p->current_class_ptr;\n   current_class_ref = p->current_class_ref;\n \n-  pop_eh_context (p->eh_context);\n-\n   free (p);\n }\n "}, {"sha": "632ce767c03fff0ec94142c38121421c890e98cd", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -155,7 +155,7 @@ int warn_implicit = 1;\n int warn_ctor_dtor_privacy = 1;\n \n /* True if we want to implement vtables using \"thunks\".\n-   The default is off by default, on if explicitly supported.  */\n+   The default is off.  */\n \n int flag_vtable_thunks;\n \n@@ -301,11 +301,6 @@ int write_virtuals;\n \n int flag_elide_constructors;\n \n-/* Nonzero means recognize and handle exception handling constructs.\n-   Use ansi syntax and semantics.  WORK IN PROGRESS!  */\n-\n-int flag_handle_exceptions;\n-\n /* Nonzero means recognize and handle signature language constructs.  */\n \n int flag_handle_signatures;\n@@ -405,7 +400,6 @@ static struct { char *string; int *variable; int on_value;} lang_f_options[] =\n   {\"all-virtual\", &flag_all_virtual, 1},\n   {\"memoize-lookups\", &flag_memoize_lookups, 1},\n   {\"elide-constructors\", &flag_elide_constructors, 1},\n-  {\"handle-exceptions\", &flag_handle_exceptions, 1},\n   {\"handle-signatures\", &flag_handle_signatures, 1},\n   {\"default-inline\", &flag_default_inline, 1},\n   {\"dollars-in-identifiers\", &dollars_in_ident, 1},\n@@ -2542,10 +2536,6 @@ import_export_vtable (decl, type, final)\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_WEAK (decl) = 1;\n \t    }\n-#ifdef ASM_OUTPUT_EXTERNAL\n-\t  else if (TREE_PUBLIC (decl))\n-\t    cp_error (\"all virtual functions redeclared inline\");\n-#endif\n \t  else\n \t    TREE_PUBLIC (decl) = 0;\n \t  DECL_EXTERNAL (decl) = 0;\n@@ -2995,7 +2985,7 @@ finish_file ()\n \n   vars = static_aggregates;\n \n-  if (static_ctors || vars || might_have_exceptions_p ())\n+  if (static_ctors || vars || exception_table_p ())\n     needs_messing_up = 1;\n   if (static_dtors)\n     needs_cleaning = 1;\n@@ -3096,7 +3086,7 @@ finish_file ()\n       push_momentary ();\n       expand_start_bindings (0);\n \n-      if (might_have_exceptions_p ())\n+      if (exception_table_p ())\n \tregister_exception_table ();\n \n       while (vars)\n@@ -3318,9 +3308,6 @@ finish_file ()\n \tTREE_PUBLIC (vars) = 0;\n     }\n \n-  if (might_have_exceptions_p ())\n-    emit_exception_table ();\n-\n   if (write_virtuals == 2)\n     {\n       /* Now complain about an virtual function tables promised"}, {"sha": "4dd7e6096d3cf64176341bc1604f854195fa4a7c", "filename": "gcc/cp/error.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -720,6 +720,8 @@ dump_decl (t, v)\n \n \tif (TREE_CODE (DECL_TEMPLATE_RESULT (t)) == TYPE_DECL)\n \t  dump_type (TREE_TYPE (t), v);\n+\telse if (TREE_TYPE (t) == NULL_TREE)\n+\t   my_friendly_abort (353);\n \telse switch (NEXT_CODE (t))\n \t  {\n \t  case METHOD_TYPE:\n@@ -738,7 +740,7 @@ dump_decl (t, v)\n       break;\n \n     case CONST_DECL:\n-      if (NEXT_CODE (t) == ENUMERAL_TYPE\n+      if ((TREE_TYPE (t) != NULL_TREE && NEXT_CODE (t) == ENUMERAL_TYPE)\n \t  || TREE_CODE (DECL_INITIAL (t)) == TEMPLATE_CONST_PARM)\n \tgoto general;\n       else\n@@ -1075,7 +1077,7 @@ dump_expr (t, nop)\n \tif (TREE_CODE (fn) == ADDR_EXPR)\n \t  fn = TREE_OPERAND (fn, 0);\n \n-\tif (NEXT_CODE (fn) == METHOD_TYPE)\n+\tif (TREE_TYPE (fn) != NULL_TREE && NEXT_CODE (fn) == METHOD_TYPE)\n \t  {\n \t    tree ob = TREE_VALUE (args);\n \t    if (TREE_CODE (ob) == ADDR_EXPR)\n@@ -1198,7 +1200,8 @@ dump_expr (t, nop)\n \t}\n       else\n \t{\n-\t  if (NEXT_CODE (TREE_OPERAND (t, 0)) == REFERENCE_TYPE)\n+\t  if (TREE_OPERAND (t,0) != NULL_TREE\n+\t      && NEXT_CODE (TREE_OPERAND (t, 0)) == REFERENCE_TYPE)\n \t    dump_expr (TREE_OPERAND (t, 0), nop);\n \t  else\n \t    dump_unary_op (\"*\", t, nop);\n@@ -1225,7 +1228,7 @@ dump_expr (t, nop)\n       /* FIXME: This is a KLUDGE workaround for a parsing problem.  There\n \t should be another level of INDIRECT_REF so that I don't have to do\n \t this.  */\n-      if (NEXT_CODE (t) == POINTER_TYPE)\n+      if (TREE_TYPE (t) != NULL_TREE && NEXT_CODE (t) == POINTER_TYPE)\n \t{\n \t  tree next = TREE_TYPE (TREE_TYPE (t));\n \n@@ -1251,7 +1254,7 @@ dump_expr (t, nop)\n \n     case CONSTRUCTOR:\n       OB_PUTC ('{');\n-      dump_expr_list (CONSTRUCTOR_ELTS (t), 0);\n+      dump_expr_list (CONSTRUCTOR_ELTS (t));\n       OB_PUTC ('}');\n       break;\n \n@@ -1296,7 +1299,7 @@ dump_expr (t, nop)\n \t{\n \t  dump_type (TREE_TYPE (t), 0);\n \t  OB_PUTC ('(');\n-\t  dump_expr_list (TREE_OPERAND (t, 0), 0);\n+\t  dump_expr_list (TREE_OPERAND (t, 0));\n \t  OB_PUTC (')');\n \t}\n       else"}, {"sha": "1d207e54664b282d219d7d039b09b011a3199d04", "filename": "gcc/cp/except.c", "status": "modified", "additions": 97, "deletions": 849, "changes": 946, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -1,5 +1,5 @@\n /* Handle exceptional things in C++.\n-   Copyright (C) 1989, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.\n+   Copyright (C) 1989, 92-95, 1996 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann <tiemann@cygnus.com>\n    Rewritten by Mike Stump <mrs@cygnus.com>, based upon an\n    initial re-implementation courtesy Tad Hunt.\n@@ -22,8 +22,6 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n \n-/* High-level class interface. */\n-\n #include \"config.h\"\n #include \"tree.h\"\n #include \"rtl.h\"\n@@ -32,48 +30,13 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"expr.h\"\n #include \"output.h\"\n+#include \"except.h\"\n+#include \"function.h\"\n \n-tree protect_list;\n-\n-extern void (*interim_eh_hook)\tPROTO((tree));\n rtx expand_builtin_return_addr\tPROTO((enum built_in_function, int, rtx));\n-static void end_eh_unwinder PROTO((rtx));\n \n /* holds the fndecl for __builtin_return_address () */\n tree builtin_return_address_fndecl;\n-tree throw_fndecl;\n-\n-static int\n-doing_eh (do_warn)\n-     int do_warn;\n-{\n-  if (! flag_handle_exceptions)\n-    {\n-      static int warned = 0;\n-      if (! warned && do_warn)\n-\t{\n-\t  error (\"exception handling disabled, use -fhandle-exceptions to enable.\");\n-\t  warned = 1;\n-\t}\n-      return 0;\n-    }\n-  return 1;\n-}\n-\n-\n-/*\n-NO GNEWS IS GOOD GNEWS WITH GARRY GNUS: This version is much closer\n-to supporting exception handling as per ANSI C++ working draft.\n-It is a complete rewrite of all the EH stuff that was here before\n-\tShortcomings:\n-\t\t1. Throw specifications of functions still don't work.\n-\tCool Things:\n-\t\t1. Destructors are called properly :-)\n-\t\t2. No overhead for the non-exception thrown case.\n-\t\t3. Fixing shortcoming 1 is simple.\n-\t\t\t-Tad Hunt\t(tad@mail.csh.rit.edu)\n-\n-*/\n \n /* A couple of backend routines from m88k.c */\n \n@@ -83,20 +46,6 @@ static tree BuiltinReturnAddress;\n \n #include <stdio.h>\n \n-/* XXX - Tad: for EH */\n-/* output an exception table entry */\n-\n-static void\n-output_exception_table_entry (file, start_label, end_label, eh_label)\n-     FILE *file;\n-     rtx start_label, end_label, eh_label;\n-{\n-  assemble_integer (start_label, GET_MODE_SIZE (Pmode), 1);\n-  assemble_integer (end_label, GET_MODE_SIZE (Pmode), 1);\n-  assemble_integer (eh_label, GET_MODE_SIZE (Pmode), 1);\n-  putc ('\\n', file);\t\t/* blank line */\n-}\n-   \n static void\n easy_expand_asm (str)\n      char *str;\n@@ -115,8 +64,8 @@ easy_expand_asm (str)\n \n #ifdef EXCEPT_SECTION_ASM_OP\n typedef struct {\n-    void *start_protect;\n-    void *end_protect;\n+    void *start_region;\n+    void *end_region;\n     void *exception_handler;\n  } exception_table;\n #endif /* EXCEPT_SECTION_ASM_OP */\n@@ -145,45 +94,9 @@ asm (TEXT_SECTION_ASM_OP);\n \n #endif\n \n-static void\n-exception_section ()\n-{\n-#ifdef ASM_OUTPUT_SECTION_NAME\n-  named_section (NULL_TREE, \".gcc_except_table\");\n-#else\n-  if (flag_pic)\n-    data_section ();\n-  else\n-#if defined (TARGET_POWERPC) /* are we on a __rs6000? */\n-    data_section ();\n-#else\n-    readonly_data_section ();\n-#endif\n-#endif\n-}\n-\n-\n-\n-\n-/* from: my-cp-except.c */\n-\n-/* VI: \":set ts=4\" */\n-#if 0\n-#include <stdio.h> */\n-#include \"config.h\"\n-#include \"tree.h\"\n-#include \"rtl.h\"\n-#include \"cp-tree.h\"\n-#endif\n #include \"decl.h\"\n-#if 0\n-#include \"flags.h\"\n-#endif\n #include \"insn-flags.h\"\n #include \"obstack.h\"\n-#if 0\n-#include \"expr.h\"\n-#endif\n \n /* ======================================================================\n    Briefly the algorithm works like this:\n@@ -194,15 +107,15 @@ exception_section ()\n      output to start the protection for that block.\n \n      When a destructor or end try block is encountered, pop_eh_entry\n-     (&eh_stack) is called.  Pop_eh_entry () returns the ehEntry it\n-     created when push_eh_entry () was called.  The ehEntry structure\n+     (&eh_stack) is called.  Pop_eh_entry () returns the eh_entry it\n+     created when push_eh_entry () was called.  The eh_entry structure\n      contains three things at this point.  The start protect label,\n      the end protect label, and the exception handler label.  The end\n      protect label should be output before the call to the destructor\n      (if any). If it was a destructor, then its parse tree is stored\n-     in the finalization variable in the ehEntry structure.  Otherwise\n+     in the finalization variable in the eh_entry structure.  Otherwise\n      the finalization variable is set to NULL to reflect the fact that\n-     is the the end of a try block.  Next, this modified ehEntry node\n+     is the the end of a try block.  Next, this modified eh_entry node\n      is enqueued in the finalizations queue by calling\n      enqueue_eh_entry (&queue,entry).\n \n@@ -231,12 +144,12 @@ exception_section ()\n      any of those finalizations throw an exception, we must call\n      terminate according to the ARM (section r.15.6.1).  What this\n      means is that we need to dequeue and emit finalizations for each\n-     entry in the ehQueue until we get to an entry with a NULL\n+     entry in the eh_queue until we get to an entry with a NULL\n      finalization field.  For any of the finalization entries, if it\n      is not a call to terminate (), we must protect it by giving it\n      another start label, end label, and exception handler label,\n      setting its finalization tree to be a call to terminate (), and\n-     enqueue'ing this new ehEntry to be output at an outer level.\n+     enqueue'ing this new eh_entry to be output at an outer level.\n      Finally, after all that is done, we can get around to outputting\n      the catch block which basically wraps all the \"catch (...) {...}\"\n      statements in a big if/then/else construct that matches the\n@@ -252,7 +165,7 @@ extern rtx gen_nop\t\tPROTO(());\n \n /* used to cache \"terminate ()\", \"unexpected ()\", \"set_terminate ()\", and\n    \"set_unexpected ()\" after default_conversion. (lib-except.c)  */\n-static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch, Throw;\n+static tree Terminate, Unexpected, SetTerminate, SetUnexpected, CatchMatch;\n \n /* used to cache __find_first_exception_table_match ()\n    for throw (lib-except.c)  */\n@@ -269,46 +182,6 @@ static tree empty_fndecl;\n /* ====================================================================== */\n \n \n-\n-/* data structures for my various quick and dirty stacks and queues\n-   Eventually, most of this should go away, because I think it can be\n-   integrated with stuff already built into the compiler.  */\n-\n-/* =================================================================== */\n-\n-struct labelNode {\n-  union {\n-    rtx rlabel;\n-    tree tlabel;\n-  } u;\n-  struct labelNode *chain;\n-};\n-\n-\n-/* this is the most important structure here.  Basically this is how I store\n-   an exception table entry internally. */\n-struct ehEntry {\n-  rtx start_label;\n-  rtx end_label;\n-  rtx exception_handler_label;\n-\n-  tree finalization;\n-  tree context;\n-};\n-\n-struct ehNode {\n-  struct ehEntry *entry;\n-  struct ehNode *chain;\n-};\n-\n-struct ehStack {\n-  struct ehNode *top;\n-};\n-\n-struct ehQueue {\n-  struct ehNode *head;\n-  struct ehNode *tail;\n-};\n /* ========================================================================= */\n \n \n@@ -329,264 +202,13 @@ static tree saved_cleanup;\n /* Indicates if we are in a catch clause.  */\n static tree saved_in_catch;\n \n-static int throw_used;\n+extern int throw_used;\n+extern rtx catch_clauses;\n \n-static rtx catch_clauses;\n-\n-static struct ehStack ehstack;\n-static struct ehQueue ehqueue;\n-static struct ehQueue eh_table_output_queue;\n-static struct labelNode *false_label_stack = NULL;\n-static struct labelNode *caught_return_label_stack = NULL;\n /* ========================================================================= */\n \n-/* function prototypes */\n-static struct ehEntry *pop_eh_entry\tPROTO((struct ehStack *stack));\n-static void enqueue_eh_entry\t\tPROTO((struct ehQueue *queue, struct ehEntry *entry));\n-static rtx push_eh_entry\t\tPROTO((struct ehStack *stack));\n-static struct ehEntry *dequeue_eh_entry\tPROTO((struct ehQueue *queue));\n-static void new_eh_queue\t\tPROTO((struct ehQueue *queue));\n-static void new_eh_stack\t\tPROTO((struct ehStack *stack));\n-static void push_label_entry\t\tPROTO((struct labelNode **labelstack, rtx rlabel, tree tlabel));\n-static rtx pop_label_entry\t\tPROTO((struct labelNode **labelstack));\n-static tree top_label_entry\t\tPROTO((struct labelNode **labelstack));\n-static struct ehEntry *copy_eh_entry\tPROTO((struct ehEntry *entry));\n-\n-\n-/* Routines to save and restore eh context information.  */\n-struct eh_context {\n-  struct ehStack ehstack;\n-  struct ehQueue ehqueue;\n-  rtx catch_clauses;\n-  struct labelNode *false_label_stack;\n-  struct labelNode *caught_return_label_stack;\n-  tree protect_list;\n-};\n-\n-/* Save the context and push into a new one.  */\n-void*\n-push_eh_context ()\n-{\n-  struct eh_context *p\n-    = (struct eh_context*)xmalloc (sizeof (struct eh_context));\n-\n-  p->ehstack = ehstack;\n-  p->ehqueue = ehqueue;\n-  p->catch_clauses = catch_clauses;\n-  p->false_label_stack = false_label_stack;\n-  p->caught_return_label_stack = caught_return_label_stack;\n-  p->protect_list = protect_list;\n-\n-  new_eh_stack (&ehstack);\n-  new_eh_queue (&ehqueue);\n-  catch_clauses = NULL_RTX;\n-  false_label_stack = NULL;\n-  caught_return_label_stack = NULL;\n-  protect_list = NULL_TREE;\n-  \n-  return p;\n-}\n-\n-/* Pop and restore the context.  */\n-void\n-pop_eh_context (vp)\n-     void *vp;\n-{\n-  struct eh_context *p = (struct eh_context *)vp;\n-\n-  protect_list = p->protect_list;\n-  caught_return_label_stack = p->caught_return_label_stack;\n-  false_label_stack = p->false_label_stack;\n-  catch_clauses\t= p->catch_clauses;\n-  ehqueue = p->ehqueue;\n-  ehstack = p->ehstack;\n-\n-  free (p);\n-}\n-\n-\n-\n-/* All my cheesy stack/queue/misc data structure handling routines\n-\n-   ========================================================================= */\n-\n-static void\n-push_label_entry (labelstack, rlabel, tlabel)\n-     struct labelNode **labelstack;\n-     rtx rlabel;\n-     tree tlabel;\n-{\n-  struct labelNode *newnode=(struct labelNode*)xmalloc (sizeof (struct labelNode));\n-\n-  if (rlabel)\n-    newnode->u.rlabel = rlabel;\n-  else\n-    newnode->u.tlabel = tlabel;\n-  newnode->chain = *labelstack;\n-  *labelstack = newnode;\n-}\n-\n-static rtx\n-pop_label_entry (labelstack)\n-     struct labelNode **labelstack;\n-{\n-  rtx label;\n-  struct labelNode *tempnode;\n-\n-  if (! *labelstack) return NULL_RTX;\n-\n-  tempnode = *labelstack;\n-  label = tempnode->u.rlabel;\n-  *labelstack = (*labelstack)->chain;\n-  free (tempnode);\n-\n-  return label;\n-}\n-\n-static tree\n-top_label_entry (labelstack)\n-     struct labelNode **labelstack;\n-{\n-  if (! *labelstack) return NULL_TREE;\n-\n-  return (*labelstack)->u.tlabel;\n-}\n-\n-/* Push to permanent obstack for rtl generation.\n-   One level only!  */\n-static struct obstack *saved_rtl_obstack;\n-\n-static void\n-push_rtl_perm ()\n-{\n-  extern struct obstack permanent_obstack;\n-  extern struct obstack *rtl_obstack;\n-  \n-  saved_rtl_obstack = rtl_obstack;\n-  rtl_obstack = &permanent_obstack;\n-}\n-\n-/* Pop back to normal rtl handling.  */\n-static void\n-pop_rtl_from_perm ()\n-{\n-  extern struct obstack *rtl_obstack;\n-  rtl_obstack = saved_rtl_obstack;\n-}\n-\n-static rtx\n-push_eh_entry (stack)\n-     struct ehStack *stack;\n-{\n-  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));\n-  struct ehEntry *entry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));\n-\n-  /* These are saved for the exception table.  */\n-  push_rtl_perm ();\n-  entry->start_label = gen_label_rtx ();\n-  entry->end_label = gen_label_rtx ();\n-  entry->exception_handler_label = gen_label_rtx ();\n-  pop_rtl_from_perm ();\n-\n-  LABEL_PRESERVE_P (entry->start_label) = 1;\n-  LABEL_PRESERVE_P (entry->end_label) = 1;\n-  LABEL_PRESERVE_P (entry->exception_handler_label) = 1;\n-\n-  entry->finalization = NULL_TREE;\n-  entry->context = current_function_decl;\n-\n-  node->entry = entry;\n-  node->chain = stack->top;\n-  stack->top = node;\n-\n-  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (entry));\n-\n-  return entry->start_label;\n-}\n-\n-/* Pop an entry from the given STACK.  */\n-static struct ehEntry *\n-pop_eh_entry (stack)\n-     struct ehStack *stack;\n-{\n-  struct ehNode *tempnode;\n-  struct ehEntry *tempentry;\n-  \n-  tempnode = stack->top;\n-  tempentry = tempnode->entry;\n-  stack->top = stack->top->chain;\n-  free (tempnode);\n-\n-  return tempentry;\n-}\n-\n-static struct ehEntry *\n-copy_eh_entry (entry)\n-     struct ehEntry *entry;\n-{\n-  struct ehEntry *newentry;\n-\n-  newentry = (struct ehEntry*)xmalloc (sizeof (struct ehEntry));\n-  memcpy ((void*)newentry, (void*)entry, sizeof (struct ehEntry));\n-\n-  return newentry;\n-}\n-\n-static void\n-enqueue_eh_entry (queue, entry)\n-     struct ehQueue *queue;\n-     struct ehEntry *entry;\n-{\n-  struct ehNode *node = (struct ehNode*)xmalloc (sizeof (struct ehNode));\n-\n-  node->entry = entry;\n-  node->chain = NULL;\n-\n-  if (queue->head == NULL)\n-    {\n-      queue->head = node;\n-    }\n-  else\n-    {\n-      queue->tail->chain = node;\n-    }\n-  queue->tail = node;\n-}\n-\n-static struct ehEntry *\n-dequeue_eh_entry (queue)\n-     struct ehQueue *queue;\n-{\n-  struct ehNode *tempnode;\n-  struct ehEntry *tempentry;\n-\n-  if (queue->head == NULL)\n-    return NULL;\n+/* Cheesyness to save some typing.  Returns the return value rtx.  */\n \n-  tempnode = queue->head;\n-  queue->head = queue->head->chain;\n-\n-  tempentry = tempnode->entry;\n-  free (tempnode);\n-\n-  return tempentry;\n-}\n-\n-static void\n-new_eh_queue (queue)\n-     struct ehQueue *queue;\n-{\n-  queue->head = queue->tail = NULL;\n-}\n-\n-static void\n-new_eh_stack (stack)\n-     struct ehStack *stack;\n-{\n-  stack->top = NULL;\n-}\n-\n-/* cheesyness to save some typing. returns the return value rtx */\n static rtx\n do_function_call (func, params, return_type)\n      tree func, params, return_type;\n@@ -599,42 +221,15 @@ do_function_call (func, params, return_type)\n   return NULL_RTX;\n }\n \n-static void\n-expand_internal_throw (pc)\n-     rtx pc;\n-{\n-  emit_move_insn (DECL_RTL (saved_pc), pc);\n-#ifdef JUMP_TO_THROW\n-  emit_indirect_jump (gen_rtx (SYMBOL_REF, Pmode, \"__throw\"));\n-#else\n-  do_function_call (Throw, NULL_TREE, NULL_TREE);\n-#endif\n-  throw_used = 1;\n-}\n-\n /* ========================================================================= */\n \n-static void\n-lang_interim_eh (finalization)\n-     tree finalization;\n-{\n-  if (finalization)\n-    end_protect (finalization);\n-  else\n-    start_protect ();\n-}\n-\n extern tree auto_function PROTO((tree, tree, enum built_in_function));\n \n /* sets up all the global eh stuff that needs to be initialized at the\n    start of compilation.\n \n    This includes:\n-\t\t- Setting up all the function call trees\n-\t\t- Initializing the ehqueue\n-\t\t- Initializing the eh_table_output_queue\n-\t\t- Initializing the ehstack\n-*/\n+\t\t- Setting up all the function call trees.  */\n \n void\n init_exception_processing ()\n@@ -671,8 +266,6 @@ init_exception_processing ()\n   terminate_fndecl = auto_function (get_identifier (\"terminate\"),\n \t\t\t\t    vtype, NOT_BUILT_IN);\n \n-  interim_eh_hook = lang_interim_eh;\n-\n   push_lang_context (lang_name_c);\n \n   catch_match_fndecl =\n@@ -697,12 +290,6 @@ init_exception_processing ()\n \t\t\t\t\t   tree_cons (NULL_TREE, ptr_type_node,\n \t\t\t\t\t\t      void_list_node)),\n \t\t      NOT_BUILT_IN, NULL_PTR);\n-  throw_fndecl =\n-    builtin_function (\"__throw\",\n-\t\t      build_function_type (void_type_node, void_list_node),\n-\t\t      NOT_BUILT_IN, NULL_PTR);\n-  DECL_EXTERNAL (throw_fndecl) = 0;\n-  TREE_PUBLIC (throw_fndecl) = 0;\n   empty_fndecl =\n     builtin_function (\"__empty\",\n \t\t      build_function_type (void_type_node, void_list_node),\n@@ -717,17 +304,12 @@ init_exception_processing ()\n   CatchMatch = default_conversion (catch_match_fndecl);\n   FirstExceptionMatch = default_conversion (find_first_exception_match_fndecl);\n   Unwind = default_conversion (unwind_fndecl);\n-  Throw = default_conversion (throw_fndecl);\n   BuiltinReturnAddress = default_conversion (builtin_return_address_fndecl);\n \n   TerminateFunctionCall = build_function_call (Terminate, NULL_TREE);\n \n   pop_lang_context ();\n \n-  new_eh_queue (&ehqueue);\n-  new_eh_queue (&eh_table_output_queue);\n-  new_eh_stack (&ehstack);\n-\n   declspecs = tree_cons (NULL_TREE, get_identifier (\"void\"), NULL_TREE);\n   d = build_parse_node (INDIRECT_REF, get_identifier (\"__eh_pc\"));\n   d = start_decl (d, declspecs, 0, NULL_TREE);\n@@ -765,150 +347,26 @@ init_exception_processing ()\n   saved_in_catch = lookup_name (get_identifier (\"__eh_in_catch\"), 0);\n }\n \n-/* call this to begin a block of unwind protection (ie: when an object is\n-   constructed) */\n-void\n-start_protect ()\n-{\n-  if (! doing_eh (0))\n-    return;\n-\n-  emit_label (push_eh_entry (&ehstack));\n-}\n-   \n-/* call this to end a block of unwind protection.  the finalization tree is\n-   the finalization which needs to be run in order to cleanly unwind through\n-   this level of protection. (ie: call this when a scope is exited)*/\n-void\n-end_protect (finalization)\n-     tree finalization;\n-{\n-  struct ehEntry *entry;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  entry = pop_eh_entry (&ehstack);\n-\n-  emit_label (entry->end_label);\n-  /* Put in something that takes up space, as otherwise the end\n-     address for the EH region could have the exact same address as\n-     the outer region, causing us to miss the fact that resuming\n-     exception handling with this PC value would be inside the outer\n-     region.  */\n-  emit_insn (gen_nop ());\n-\n-  entry->finalization = finalization;\n+/* Call this on start of a try block.  */\n \n-  enqueue_eh_entry (&ehqueue, entry);\n-}\n-\n-/* call this on start of a try block. */\n void\n expand_start_try_stmts ()\n {\n   if (! doing_eh (1))\n     return;\n \n-  start_protect ();\n+  expand_eh_region_start ();\n }\n \n void\n expand_end_try_stmts ()\n {\n-  end_protect (integer_zero_node);\n-}\n-\n-\n-/* call this to start processing of all the catch blocks. */\n-void\n-expand_start_all_catch ()\n-{\n-  struct ehEntry *entry;\n-  tree label;\n-\n-  if (! doing_eh (1))\n-    return;\n-\n-  emit_line_note (input_filename, lineno);\n-  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-\n-  /* The label for the exception handling block we will save.  This is\n-     Lresume, in the documention.  */\n-  expand_label (label);\n-  \n-  /* Put in something that takes up space, as otherwise the end\n-     address for the EH region could have the exact same address as\n-     the outer region, causing us to miss the fact that resuming\n-     exception handling with this PC value would be inside the outer\n-     region.  */\n-  emit_insn (gen_nop ());\n-\n-  push_label_entry (&caught_return_label_stack, NULL_RTX, label);\n-\n-  /* Start a new sequence for all the catch blocks.  We will add this\n-     to the gloabl sequence catch_clauses, when we have completed all\n-     the handlers in this handler-seq.  */\n-  start_sequence ();\n-\n-  while (1)\n-    {\n-      entry = dequeue_eh_entry (&ehqueue);\n-      emit_label (entry->exception_handler_label);\n-\n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n-\n-      /* When we get down to the matching entry, stop.  */\n-      if (entry->finalization == integer_zero_node)\n-\tbreak;\n-\n-      /* The below can be optimized away, and we could just fall into the\n-\t next EH handler, if we are certain they are nested.  */\n-      /* Code to throw out to outer context, if we fall off end of the\n-\t handler.  */\n-      expand_internal_throw (gen_rtx (LABEL_REF,\n-\t\t\t\t      Pmode,\n-\t\t\t\t      entry->end_label));\n-      free (entry);\n-    }\n-}\n-\n-/* call this to end processing of all the catch blocks. */\n-void\n-expand_end_all_catch ()\n-{\n-  rtx new_catch_clause;\n-\n-  if (! doing_eh (1))\n-    return;\n-\n-  /* Code to throw out to outer context, if we fall off end of catch\n-     handlers.  This is rethrow (Lresume, same id, same obj); in the\n-     documentation.  */\n-  expand_internal_throw (gen_rtx (LABEL_REF,\n-\t\t\t\t  Pmode,\n-\t\t\t\t  DECL_RTL (top_label_entry (&caught_return_label_stack))));\n-\n-  /* Now we have the complete catch sequence.  */\n-  new_catch_clause = get_insns ();\n-  end_sequence ();\n-  \n-  /* this level of catch blocks is done, so set up the successful catch jump\n-     label for the next layer of catch blocks. */\n-  pop_label_entry (&caught_return_label_stack);\n-\n-  /* Add the new sequence of catchs to the main one for this\n-     function.  */\n-  push_to_sequence (catch_clauses);\n-  emit_insns (new_catch_clause);\n-  catch_clauses = get_insns ();\n-  end_sequence ();\n-  \n-  /* Here we fall through into the continuation code.  */\n+  expand_eh_region_end (integer_zero_node);\n }\n \n /* Build a type value for use at runtime for a type that is matched\n    against by the exception handling system.  */\n+\n static tree\n build_eh_type_type (type)\n      tree type;\n@@ -938,6 +396,7 @@ build_eh_type_type (type)\n \n /* Build a type value for use at runtime for a exp that is thrown or\n    matched against by the exception handling system.  */\n+\n static tree\n build_eh_type (exp)\n      tree exp;\n@@ -951,6 +410,7 @@ build_eh_type (exp)\n }\n \n /* This routine creates the cleanup for the exception handling object.  */\n+\n static void\n push_eh_cleanup ()\n {\n@@ -973,12 +433,12 @@ push_eh_cleanup ()\n    matter.  If typename is NULL, that means its a \"catch (...)\" or catch\n    everything.  In that case we don't need to do any type checking.\n    (ie: it ends up as the \"else\" clause rather than an \"else if\" clause) */\n+\n void\n expand_start_catch_block (declspecs, declarator)\n      tree declspecs, declarator;\n {\n   rtx false_label_rtx;\n-  rtx protect_label_rtx;\n   tree decl = NULL_TREE;\n   tree init;\n \n@@ -989,12 +449,7 @@ expand_start_catch_block (declspecs, declarator)\n   expand_start_bindings (0);\n \n   false_label_rtx = gen_label_rtx ();\n-  /* This is saved for the exception table.  */\n-  push_rtl_perm ();\n-  protect_label_rtx = gen_label_rtx ();\n-  pop_rtl_from_perm ();\n   push_label_entry (&false_label_stack, false_label_rtx, NULL_TREE);\n-  push_label_entry (&false_label_stack, protect_label_rtx, NULL_TREE);\n \n   if (declspecs)\n     {\n@@ -1008,6 +463,9 @@ expand_start_catch_block (declspecs, declarator)\n       if (decl == NULL_TREE)\n \t{\n \t  error (\"invalid catch parameter\");\n+\n+\t  /* This is cheap, but we want to maintain the data structures.  */\n+\t  expand_eh_region_start ();\n \t  return;\n \t}\n \n@@ -1058,115 +516,62 @@ expand_start_catch_block (declspecs, declarator)\n     }\n \n   emit_move_insn (DECL_RTL (saved_in_catch), const1_rtx);\n-  /* This is the starting of something to protect.  */\n-  emit_label (protect_label_rtx);\n-\n-  emit_line_note (input_filename, lineno);\n-}\n-\n-\n-/* this is called from expand_exception_blocks and\n-   expand_end_catch_block to expand the toplevel finalizations for a\n-   function.  We return the first label emitted, if any, otherwise\n-   return NULL_RTX.  */\n-static rtx\n-expand_leftover_cleanups ()\n-{\n-  struct ehEntry *entry;\n-  rtx first_label = NULL_RTX;\n-\n-  while ((entry = dequeue_eh_entry (&ehqueue)) != 0)\n-    {\n-      if (! first_label)\n-\tfirst_label = entry->exception_handler_label;\n-      emit_label (entry->exception_handler_label);\n \n-      expand_expr (entry->finalization, const0_rtx, VOIDmode, 0);\n+  /* Because we are reordered out of line, we arrange\n+     to rethrow in the outer context, should we encounter\n+     an exception in the catch handler.\n \n-      /* The below can be optimized away, and we could just fall into the\n-\t next EH handler, if we are certain they are nested.  */\n-      /* Code to throw out to outer context, if we fall off end of the\n-\t handler.  */\n-      expand_internal_throw (gen_rtx (LABEL_REF,\n-\t\t\t\t      Pmode,\n-\t\t\t\t      entry->end_label));\n+     Matches the end in expand_end_catch_block ().  */\n+  expand_eh_region_start ();\n \n-      /* leftover try block, opps.  */\n-      if (entry->finalization == integer_zero_node)\n-\tabort ();\n+  emit_line_note (input_filename, lineno);\n+}\n \n-      free (entry);\n-    }\n \n-  return first_label;\n-}\n \n /* Call this to end a catch block.  Its responsible for emitting the\n    code to handle jumping back to the correct place, and for emitting\n    the label to jump to if this catch block didn't match.  */\n+\n void expand_end_catch_block ()\n {\n-  rtx start_protect_label_rtx;\n-  rtx end_protect_label_rtx;\n-  tree decls;\n-  struct ehEntry entry;\n+  rtx start_region_label_rtx;\n+  rtx end_region_label_rtx;\n+  tree decls, t;\n \n   if (! doing_eh (1))\n     return;\n \n-  /* fall to outside the try statement when done executing handler and\n+  /* Fall to outside the try statement when done executing handler and\n      we fall off end of handler.  This is jump Lresume in the\n      documentation.  */\n   expand_goto (top_label_entry (&caught_return_label_stack));\n \n-  /* We end the rethrow protection region as soon as we hit a label. */\n-  end_protect_label_rtx = expand_leftover_cleanups ();\n-\n-  /* Code to throw out to outer context, if we get a throw from within\n-     our catch handler. */\n-  /* These are saved for the exception table.  */\n-  push_rtl_perm ();\n-  entry.exception_handler_label = gen_label_rtx ();\n-  pop_rtl_from_perm ();\n-  /* This label is Lhandler in the documentation.  */\n-  emit_label (entry.exception_handler_label);\n-  expand_internal_throw (gen_rtx (LABEL_REF,\n-\t\t\t\t  Pmode,\n-\t\t\t\t  DECL_RTL (top_label_entry (&caught_return_label_stack))));\n-\n-  /* No associated finalization.  */\n-  entry.finalization = NULL_TREE;\n-  entry.context = current_function_decl;\n+  t = make_node (RTL_EXPR);\n+  TREE_TYPE (t) = void_type_node;\n+  RTL_EXPR_RTL (t) = const0_rtx;\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  start_sequence_for_rtl_expr (t);\n+  expand_internal_throw (DECL_RTL (top_label_entry (&caught_return_label_stack)));\n+  RTL_EXPR_SEQUENCE (t) = get_insns ();\n+  end_sequence ();\n \n-  if (end_protect_label_rtx == NULL_RTX)\n-    end_protect_label_rtx = entry.exception_handler_label;\n+  /* Matches the start in expand_start_catch_block ().  */\n+  expand_eh_region_end (t);\n \n-  /* Because we are emitted out of line, we have to protect this. */\n-  /* label for the start of the protection region.  */\n-  start_protect_label_rtx = pop_label_entry (&false_label_stack);\n+  expand_leftover_cleanups ();\n \n   /* Cleanup the EH parameter.  */\n   decls = getdecls ();\n   expand_end_bindings (decls, decls != NULL_TREE, 0);\n       \n-  /* label we emit to jump to if this catch block didn't match. */\n+  /* label we emit to jump to if this catch block didn't match.  */\n   /* This the closing } in the `if (eq) {' of the documentation.  */\n   emit_label (pop_label_entry (&false_label_stack));\n-\n-  /* Because we are reordered out of line, we have to protect this. */\n-  entry.start_label = start_protect_label_rtx;\n-  entry.end_label = end_protect_label_rtx;\n-\n-  LABEL_PRESERVE_P (entry.start_label) = 1;\n-  LABEL_PRESERVE_P (entry.end_label) = 1;\n-  LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n-\n-  /* These set up a call to throw the caught exception into the outer\n-     context.  */\n-  enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n }\n \n-/* unwind the stack. */\n+/* unwind the stack.  */\n+\n static void\n do_unwind (inner_throw_label)\n      rtx inner_throw_label;\n@@ -1248,48 +653,6 @@ do_unwind (inner_throw_label)\n }\n \n \n-/* Given the return address, compute the new pc to throw.  This has to\n-   work for the current frame of the current function, and the one\n-   above it in the case of throw.  */\n-static rtx\n-eh_outer_context (addr)\n-     rtx addr;\n-{\n-#if defined (ARM_FRAME_RTX)  /* was __arm */\n-  /* On the ARM, '__builtin_return_address',  must have 4\n-     subtracted from it. */\n-  emit_insn (gen_add2_insn (addr, GEN_INT (-4)));\n-\n-  /* If we are generating code for an ARM2/ARM3 machine or for an ARM6\n-     in 26 bit mode, the condition codes must be masked out of the\n-     return value, or else they will confuse BuiltinReturnAddress.\n-     This does not apply to ARM6 and later processors when running in\n-     32 bit mode. */\n-  if (!TARGET_6)\n-    emit_insn (gen_rtx (SET, Pmode,\n-\t\t\taddr,\n-\t\t\tgen_rtx (AND, Pmode,\n-\t\t\t\t addr, GEN_INT (0x03fffffc))));\n-#else\n-#if ! defined (SPARC_STACK_ALIGN) /* was sparc */\n-#if defined (TARGET_SNAKE)\n-  /* On HPPA, the low order two bits hold the priviledge level, so we\n-     must get rid of them.  */\n-  emit_insn (gen_rtx (SET, Pmode,\n-\t\t      addr,\n-\t\t      gen_rtx (AND, Pmode,\n-\t\t\t       addr, GEN_INT (0xfffffffc))));\n-#endif\n-\n-  /* On the SPARC, __builtin_return_address is already -8 or -12, no\n-     need to subtract any more from it. */\n-  addr = plus_constant (addr, -1);\n-#endif\n-#endif\n-\n-  return addr;\n-}\n-\n /* is called from expand_exception_blocks () to generate the code in a function\n    to \"throw\" if anything in the function needs to perform a throw.\n \n@@ -1303,9 +666,8 @@ eh_outer_context (addr)\n \tgotta_rethrow_it:\n \t\tsaved_pc = __builtin_return_address (0);\n \t\tpop_to_previous_level ();\n-\t\tgoto throw;\n+\t\tgoto throw;  */\n \n- */\n void\n expand_builtin_throw ()\n {\n@@ -1391,7 +753,7 @@ expand_builtin_throw ()\n   return_val_rtx = eh_outer_context (return_val_rtx);\n \n   /* Yes it did.  */\n-  emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);\n+  emit_move_insn (eh_saved_pc_rtx, return_val_rtx);\n \n   do_unwind (gen_rtx (LABEL_REF, Pmode, top_of_loop));\n   emit_jump (top_of_loop);\n@@ -1429,7 +791,7 @@ expand_builtin_throw ()\n void\n expand_start_eh_spec ()\n {\n-  start_protect ();\n+  expand_eh_region_start ();\n }\n \n static void\n@@ -1472,11 +834,11 @@ expand_end_eh_spec (raises)\n   emit_jump (check);\n   emit_label (cont);\n   jumpif (make_tree (integer_type_node, flag), end);\n-  start_protect ();\n+  expand_eh_region_start ();\n   do_function_call (Unexpected, NULL_TREE, NULL_TREE);\n   assemble_external (TREE_OPERAND (Unexpected, 0));\n   emit_barrier ();\n-  end_protect (second_try);\n+  expand_eh_region_end (second_try);\n   \n   emit_label (check);\n   emit_move_insn (flag, const1_rtx);\n@@ -1511,17 +873,19 @@ expand_end_eh_spec (raises)\n   RTL_EXPR_SEQUENCE (expr) = get_insns ();\n   end_sequence ();\n   \n-  end_protect (expr);\n+  expand_eh_region_end (expr);\n }\n \n /* This is called to expand all the toplevel exception handling\n    finalization for a function.  It should only be called once per\n    function.  */\n+\n void\n expand_exception_blocks ()\n {\n   rtx funcend;\n   rtx insns;\n+  rtx eh_spec_insns = NULL_RTX;\n \n   start_sequence ();\n \n@@ -1540,11 +904,22 @@ expand_exception_blocks ()\n   insns = get_insns ();\n   end_sequence ();\n   \n-  /* Do this after we expand leftover cleanups, so that the end_protect\n-     that expand_end_eh_spec does will match the right start_protect,\n+  /* Do this after we expand leftover cleanups, so that the expand_eh_region_end\n+     that expand_end_eh_spec does will match the right expand_eh_region_start,\n      and make sure it comes out before the terminate protected region.  */\n   if (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)))\n     {\n+#if 1\n+      {\n+\trtx insns;\n+\t/* New...  */\n+\tstart_sequence ();\n+\texpand_start_eh_spec ();\n+\teh_spec_insns = get_insns ();\n+\tend_sequence ();\n+      }\n+#endif\n+\n       expand_end_eh_spec (TYPE_RAISES_EXCEPTIONS (TREE_TYPE (current_function_decl)));\n       push_to_sequence (insns);\n \n@@ -1557,39 +932,22 @@ expand_exception_blocks ()\n \n   if (insns)\n     {\n-      struct ehEntry entry;\n-\n-      /* These are saved for the exception table.  */\n-      push_rtl_perm ();\n-      entry.start_label = gen_label_rtx ();\n-      entry.end_label = gen_label_rtx ();\n-      entry.exception_handler_label = gen_label_rtx ();\n-      entry.finalization = TerminateFunctionCall;\n-      entry.context = current_function_decl;\n+      /* Is this necessary?  */\n       assemble_external (TREE_OPERAND (Terminate, 0));\n-      pop_rtl_from_perm ();\n-\n-      LABEL_PRESERVE_P (entry.start_label) = 1;\n-      LABEL_PRESERVE_P (entry.end_label) = 1;\n-      LABEL_PRESERVE_P (entry.exception_handler_label) = 1;\n \n-      emit_label (entry.start_label);\n+      expand_eh_region_start ();\n       emit_insns (insns);\n-\n-      enqueue_eh_entry (&eh_table_output_queue, copy_eh_entry (&entry));\n-\n-      emit_label (entry.exception_handler_label);\n-      expand_expr (entry.finalization, const0_rtx, VOIDmode, 0);\n-      emit_label (entry.end_label);\n-      emit_barrier ();\n+      expand_eh_region_end (TerminateFunctionCall);\n+      expand_leftover_cleanups ();\n     }\n \n   {\n     /* Mark the end of the stack unwinder.  */\n     rtx unwind_insns;\n     start_sequence ();\n-    end_eh_unwinder (funcend);\n-    expand_leftover_cleanups ();\n+#if 0\n+    end_eh_unwinder ();\n+#endif\n     unwind_insns = get_insns ();\n     end_sequence ();\n     if (unwind_insns)\n@@ -1607,6 +965,14 @@ expand_exception_blocks ()\n     insns = get_insns ();\n   end_sequence ();\n \n+#if 1\n+  if (eh_spec_insns)\n+    emit_insns_after (eh_spec_insns, get_insns ());\n+#else\n+  if (eh_spec_insns)\n+    store_after_parms (eh_spec_insns);\n+#endif\n+\n   emit_insns (insns);\n }\n \n@@ -1661,7 +1027,7 @@ end_anon_func ()\n   pop_cp_function_context (NULL_TREE);\n }\n \n-/* call this to expand a throw statement.  This follows the following\n+/* Expand a throw statement.  This follows the following\n    algorithm:\n \n \t1. Allocate space to save the current PC onto the stack.\n@@ -1670,6 +1036,7 @@ end_anon_func ()\n \t3. If this is the first call to throw in this function:\n \t\tgenerate a label for the throw block\n \t4. jump to the throw block label.  */\n+\n void\n expand_throw (exp)\n      tree exp;\n@@ -1679,12 +1046,6 @@ expand_throw (exp)\n   if (! doing_eh (1))\n     return;\n \n-  /* This is the label that represents where in the code we were, when\n-     we got an exception.  This needs to be updated when we rethrow an\n-     exception, so that the matching routine knows to search out.  */\n-  label = gen_label_rtx ();\n-  emit_label (label);\n-\n   if (exp)\n     {\n       tree throw_type;\n@@ -1760,75 +1121,17 @@ expand_throw (exp)\n       /* This part is easy, as we don't have to do anything else.  */\n     }\n \n-  expand_internal_throw (gen_rtx (LABEL_REF, Pmode, label));\n-}\n-\n-void\n-end_protect_partials () {\n-  while (protect_list)\n-    {\n-      end_protect (TREE_VALUE (protect_list));\n-      protect_list = TREE_CHAIN (protect_list);\n-    }\n-}\n-\n-int\n-might_have_exceptions_p ()\n-{\n-  if (eh_table_output_queue.head)\n-    return 1;\n-  return 0;\n-}\n-\n-/* Output the exception table.\n- Return the number of handlers.  */\n-void\n-emit_exception_table ()\n-{\n-  int count = 0;\n-  extern FILE *asm_out_file;\n-  struct ehEntry *entry;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  exception_section ();\n-\n-  /* Beginning marker for table. */\n-  assemble_align (GET_MODE_ALIGNMENT (Pmode));\n-  assemble_label (\"__EXCEPTION_TABLE__\");\n-  output_exception_table_entry (asm_out_file,\n-\t\t\t\tconst0_rtx, const0_rtx, const0_rtx);\n-\n- while (entry = dequeue_eh_entry (&eh_table_output_queue))\n-   {\n-     tree context = entry->context;\n-\n-     if (context && ! TREE_ASM_WRITTEN (context))\n-       continue;\n-\n-     count++;\n-     output_exception_table_entry (asm_out_file,\n-\t\t\t\t   entry->start_label, entry->end_label,\n-\t\t\t\t   entry->exception_handler_label);\n-  }\n-\n-  /* Ending marker for table. */\n-  assemble_label (\"__EXCEPTION_END__\");\n-  output_exception_table_entry (asm_out_file,\n-\t\t\t\tconstm1_rtx, constm1_rtx, constm1_rtx);\n-}\n+  /* This is the label that represents where in the code we were, when\n+     we got an exception.  This needs to be updated when we rethrow an\n+     exception, so that the matching routine knows to search out.  */\n+  label = gen_label_rtx ();\n+  emit_label (label);\n \n-void\n-register_exception_table ()\n-{\n-  emit_library_call (gen_rtx (SYMBOL_REF, Pmode, \"__register_exceptions\"), 0,\n-\t\t     VOIDmode, 1,\n-\t\t     gen_rtx (SYMBOL_REF, Pmode, \"__EXCEPTION_TABLE__\"),\n-\t\t     Pmode);\n+  expand_internal_throw (label);\n }\n \n /* Build a throw expression.  */\n+\n tree\n build_throw (e)\n      tree e;\n@@ -1843,58 +1146,3 @@ build_throw (e)\n     }\n   return e;\n }\n-\n-void\n-start_eh_unwinder ()\n-{\n-  start_protect ();\n-}\n-\n-static void\n-end_eh_unwinder (end)\n-     rtx end;\n-{\n-  tree expr;\n-  rtx return_val_rtx, ret_val, label;\n-\n-  if (! doing_eh (0))\n-    return;\n-\n-  expr = make_node (RTL_EXPR);\n-  TREE_TYPE (expr) = void_type_node;\n-  RTL_EXPR_RTL (expr) = const0_rtx;\n-  TREE_SIDE_EFFECTS (expr) = 1;\n-  start_sequence_for_rtl_expr (expr);\n-\n-  ret_val = expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n-\t\t\t\t\t0, hard_frame_pointer_rtx);\n-  return_val_rtx = copy_to_reg (ret_val);\n-\n-  return_val_rtx = eh_outer_context (return_val_rtx);\n-\n-  emit_move_insn (DECL_RTL (saved_pc), return_val_rtx);\n-  \n-#ifdef JUMP_TO_THROW\n-  emit_move_insn (ret_val, gen_rtx (SYMBOL_REF, Pmode, \"__throw\"));\n-#else\n-  label = gen_label_rtx ();\n-  emit_move_insn (ret_val, gen_rtx (LABEL_REF, Pmode, label));\n-#endif\n-\n-#ifdef RETURN_ADDR_OFFSET\n-  return_val_rtx = plus_constant (ret_val, -RETURN_ADDR_OFFSET);\n-  if (return_val_rtx != ret_val)\n-    emit_move_insn (ret_val, return_val_rtx);\n-#endif\n-  \n-  emit_jump (end);  \n-\n-#ifndef JUMP_TO_THROW\n-  emit_label (label);\n-  do_function_call (Throw, NULL_TREE, NULL_TREE);\n-#endif\n-  \n-  RTL_EXPR_SEQUENCE (expr) = get_insns ();\n-  end_sequence ();\n-  end_protect (expr);\n-}"}, {"sha": "62e3909c86b12108127c4f293ecfe9aa35207446", "filename": "gcc/cp/init.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -245,7 +245,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n \n       if (expr != error_mark_node)\n \t{\n-\t  start_protect ();\n+\t  expand_eh_region_start ();\n \t  *protect_list = tree_cons (NULL_TREE, expr, *protect_list);\n \t}\n     }\n@@ -618,7 +618,7 @@ emit_base_init (t, immediately)\n \n       if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (base_binfo)))\n \t{\n-\t  start_protect ();\n+\t  expand_eh_region_start ();\n \n \t  /* All cleanups must be on the function_obstack.  */\n \t  push_obstacks_nochange ();\n@@ -3369,7 +3369,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n       expand_start_cond (build (GE_EXPR, boolean_type_node,\n \t\t\t\titerator, integer_zero_node), 0);\n       if (TYPE_NEEDS_DESTRUCTOR (type))\n-\tstart_protect ();\n+\texpand_eh_region_start ();\n       expand_start_loop_continue_elsewhere (1);\n \n       if (from_array)\n@@ -3429,7 +3429,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    use_variable (DECL_RTL (base2));\n \t}\n       expand_end_loop ();\n-      if (TYPE_NEEDS_DESTRUCTOR (type) && flag_handle_exceptions)\n+      if (TYPE_NEEDS_DESTRUCTOR (type) && flag_exceptions)\n \t{\n \t  /* We have to ensure that this can live to the cleanup\n \t     expansion time, since we know it is only ever needed\n@@ -3450,7 +3450,7 @@ expand_vec_init (decl, base, maxindex, init, from_array)\n \t    expand_expr (e1, const0_rtx, VOIDmode, 0);\n \t    RTL_EXPR_SEQUENCE (e2) = get_insns ();\n \t    end_sequence ();\n-\t    end_protect (e2);\n+\t    expand_eh_region_end (e2);\n \t  }\n \t  pop_obstacks ();\n \t}"}, {"sha": "54c214e2e488dd3a539c5ee338c592dc2258e547", "filename": "gcc/cp/lang-options.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flang-options.h?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -50,8 +50,6 @@ Boston, MA 02111-1307, USA.  */\n   \"-fno-for-scope\",\n   \"-fgnu-keywords\",\n   \"-fno-gnu-keywords\",\n-  \"-fhandle-exceptions\",\n-  \"-fno-handle-exceptions\",\n   \"-fhandle-signatures\",\n   \"-fno-handle-signatures\",\n   \"-fhuge-objects\","}, {"sha": "56cf159cdc9b62dbbf8c41e4024c9d17734a0dee", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -676,14 +676,14 @@ init_lex ()\n   opname_tab[(int) COMPONENT_REF] = \"->\";\n   opname_tab[(int) MEMBER_REF] = \"->*\";\n   opname_tab[(int) METHOD_CALL_EXPR] = \"->()\";\n-  opname_tab[(int) INDIRECT_REF] = \"(unary *)\";\n+  opname_tab[(int) INDIRECT_REF] = \"*\";\n   opname_tab[(int) ARRAY_REF] = \"[]\";\n   opname_tab[(int) MODIFY_EXPR] = \"=\";\n   opname_tab[(int) NEW_EXPR] = \"new\";\n   opname_tab[(int) DELETE_EXPR] = \"delete\";\n   opname_tab[(int) VEC_NEW_EXPR] = \"new []\";\n   opname_tab[(int) VEC_DELETE_EXPR] = \"delete []\";\n-  opname_tab[(int) COND_EXPR] = \"... ? ... : ...\";\n+  opname_tab[(int) COND_EXPR] = \"?:\";\n   opname_tab[(int) CALL_EXPR] = \"()\";\n   opname_tab[(int) PLUS_EXPR] = \"+\";\n   opname_tab[(int) MINUS_EXPR] = \"-\";\n@@ -720,9 +720,9 @@ init_lex ()\n   opname_tab[(int) EQ_EXPR] = \"==\";\n   opname_tab[(int) NE_EXPR] = \"!=\";\n   opname_tab[(int) IN_EXPR] = \"in\";\n-  opname_tab[(int) RANGE_EXPR] = \"..\";\n-  opname_tab[(int) CONVERT_EXPR] = \"(unary +)\";\n-  opname_tab[(int) ADDR_EXPR] = \"(unary &)\";\n+  opname_tab[(int) RANGE_EXPR] = \"...\";\n+  opname_tab[(int) CONVERT_EXPR] = \"+\";\n+  opname_tab[(int) ADDR_EXPR] = \"&\";\n   opname_tab[(int) PREDECREMENT_EXPR] = \"--\";\n   opname_tab[(int) PREINCREMENT_EXPR] = \"++\";\n   opname_tab[(int) POSTDECREMENT_EXPR] = \"--\";\n@@ -764,7 +764,7 @@ init_lex ()\n \n #if 0\n   /* let's parse things, and if they use it, then give them an error.  */\n-  if (!flag_handle_exceptions)\n+  if (!flag_exceptions)\n     {\n       UNSET_RESERVED_WORD (\"throw\");\n       UNSET_RESERVED_WORD (\"try\");\n@@ -3039,7 +3039,7 @@ real_yylex ()\n \t    || strcmp (\"try\", token_buffer) == 0)\n \t  {\n \t    static int did_warn = 0;\n-\t    if (! did_warn  && ! flag_handle_exceptions)\n+\t    if (! did_warn  && ! flag_exceptions)\n \t      {\n \t\tpedwarn (\"`catch', `throw', and `try' are all C++ reserved words\");\n \t\tdid_warn = 1;"}, {"sha": "bb8a2046688a9071ea85e533be1eae050bb5c933", "filename": "gcc/cp/method.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -1193,6 +1193,10 @@ build_opfncall (code, flags, xarg1, xarg2, arg3)\n   int try_second;\n   int binary_is_unary;\n \n+#ifdef NEW_OVER\n+  return build_new_op (code, flags, xarg1, xarg2, arg3);\n+#endif\n+\n   if (xarg1 == error_mark_node)\n     return error_mark_node;\n \n@@ -2203,7 +2207,12 @@ synthesize_method (fndecl)\n       /* Turn off DECL_INLINE for the moment so function_cannot_inline_p\n          will check our size.  */\n       DECL_INLINE (fndecl) = 0;\n-      if (function_cannot_inline_p (fndecl) == 0)\n+\n+      /* We say !at_eof because at the end of the file some of the rtl\n+\t for fndecl may have been allocated on the temporary obstack.\n+\t (The function_obstack is the temporary one if we're not in a\n+\t function). */\n+      if ((! at_eof) && function_cannot_inline_p (fndecl) == 0)\n \tDECL_INLINE (fndecl) = 1;\n     }\n "}, {"sha": "d86e852f4010aa5ca1f032ff2bf2950f028ffc83", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 101, "deletions": 31, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -1181,6 +1181,8 @@ instantiate_class_template (type)\n     = TYPE_USES_COMPLEX_INHERITANCE (pattern);\n   TYPE_USES_VIRTUAL_BASECLASSES (type)\n     = TYPE_USES_VIRTUAL_BASECLASSES (pattern);\n+  TYPE_PACKED (type) = TYPE_PACKED (pattern);\n+  TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n \n   if (! uses_template_parms (type))\n     {\n@@ -1189,8 +1191,7 @@ instantiate_class_template (type)\n \tif (TREE_CODE (tmp) == FIELD_DECL)\n \t  require_complete_type (tmp);\n \n-      /* XXX handle attributes */\n-      type = finish_struct_1 (type, NULL_TREE, 0);\n+      type = finish_struct_1 (type, 0);\n       CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \n       repo_template_used (type);\n@@ -2265,6 +2266,13 @@ tsubst_expr (t, args, nargs, in_decl)\n \terror (\"break statement not within loop or switch\");\n       break;\n \n+    case CONTINUE_STMT:\n+      lineno = TREE_COMPLEXITY (t);\n+      emit_line_note (input_filename, lineno);\n+      if (! expand_continue_loop (0))\n+\terror (\"continue statement not within a loop\");\n+      break;\n+\n     case SWITCH_STMT:\n       {\n \ttree val, tmp;\n@@ -2403,12 +2411,15 @@ overload_template_name (type)\n \n    If SUBR is 1, we're being called recursively (to unify the arguments of\n    a function or method parameter of a function template), so don't zero\n-   out targs and don't fail on an incomplete match.  */\n+   out targs and don't fail on an incomplete match.\n+\n+   If STRICT is 1, the match must be exact (for casts of overloaded\n+   addresses, explicit instantiation, and more_specialized).  */\n \n int\n-type_unification (tparms, targs, parms, args, nsubsts, subr)\n+type_unification (tparms, targs, parms, args, nsubsts, subr, strict)\n      tree tparms, *targs, parms, args;\n-     int *nsubsts, subr;\n+     int *nsubsts, subr, strict;\n {\n   tree parm, arg;\n   int i;\n@@ -2472,7 +2483,7 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n \t      parm = tree_cons (NULL_TREE, parm, NULL_TREE);\n \t      return type_unification (DECL_TEMPLATE_PARMS (arg), targs,\n \t\t\t\t       TYPE_ARG_TYPES (TREE_TYPE (arg)),\n-\t\t\t\t       parm, &nsubsts, 0);\n+\t\t\t\t       parm, &nsubsts, 0, strict);\n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n@@ -2491,7 +2502,7 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n \t    arg = TYPE_MAIN_VARIANT (arg);\n \t}\n \n-      switch (unify (tparms, targs, ntparms, parm, arg, nsubsts))\n+      switch (unify (tparms, targs, ntparms, parm, arg, nsubsts, strict))\n \t{\n \tcase 0:\n \t  break;\n@@ -2521,9 +2532,9 @@ type_unification (tparms, targs, parms, args, nsubsts, subr)\n /* Tail recursion is your friend.  */\n \n static int\n-unify (tparms, targs, ntparms, parm, arg, nsubsts)\n+unify (tparms, targs, ntparms, parm, arg, nsubsts, strict)\n      tree tparms, *targs, parm, arg;\n-     int *nsubsts, ntparms;\n+     int *nsubsts, ntparms, strict;\n {\n   int idx;\n \n@@ -2546,6 +2557,9 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n     case TEMPLATE_TYPE_PARM:\n       (*nsubsts)++;\n       idx = TEMPLATE_TYPE_IDX (parm);\n+      if (strict && (TYPE_READONLY (arg) < TYPE_READONLY (parm)\n+\t\t     || TYPE_VOLATILE (arg) < TYPE_VOLATILE (parm)))\n+\treturn 1;\n #if 0\n       /* Template type parameters cannot contain cv-quals; i.e.\n          template <class T> void f (T& a, T& b) will not generate\n@@ -2606,26 +2620,27 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n     case POINTER_TYPE:\n       if (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n \treturn unify (tparms, targs, ntparms, parm,\n-\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), nsubsts);\n+\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), nsubsts, strict);\n \n       if (TREE_CODE (arg) != POINTER_TYPE)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    nsubsts);\n+\t\t    nsubsts, strict);\n \n     case REFERENCE_TYPE:\n       if (TREE_CODE (arg) == REFERENCE_TYPE)\n \targ = TREE_TYPE (arg);\n-      return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg, nsubsts);\n+      return unify (tparms, targs, ntparms, TREE_TYPE (parm), arg,\n+\t\t    nsubsts, strict);\n \n     case ARRAY_TYPE:\n       if (TREE_CODE (arg) != ARRAY_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, ntparms, TYPE_DOMAIN (parm), TYPE_DOMAIN (arg),\n-\t\t nsubsts) != 0)\n+\t\t nsubsts, strict) != 0)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),\n-\t\t    nsubsts);\n+\t\t    nsubsts, strict);\n \n     case REAL_TYPE:\n     case INTEGER_TYPE:\n@@ -2635,12 +2650,12 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n       if (TREE_CODE (parm) == INTEGER_TYPE)\n \t{\n \t  if (TYPE_MIN_VALUE (parm) && TYPE_MIN_VALUE (arg)\n-\t      && unify (tparms, targs, ntparms,\n-\t\t\tTYPE_MIN_VALUE (parm), TYPE_MIN_VALUE (arg), nsubsts))\n+\t      && unify (tparms, targs, ntparms, TYPE_MIN_VALUE (parm),\n+\t\t\tTYPE_MIN_VALUE (arg), nsubsts, strict))\n \t    return 1;\n \t  if (TYPE_MAX_VALUE (parm) && TYPE_MAX_VALUE (arg)\n-\t      && unify (tparms, targs, ntparms,\n-\t\t\tTYPE_MAX_VALUE (parm), TYPE_MAX_VALUE (arg), nsubsts))\n+\t      && unify (tparms, targs, ntparms, TYPE_MAX_VALUE (parm),\n+\t\t\tTYPE_MAX_VALUE (arg), nsubsts, strict))\n \t    return 1;\n \t}\n       /* As far as unification is concerned, this wins.\t Later checks\n@@ -2660,7 +2675,7 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \tt2 = TREE_OPERAND (parm, 1);\n \treturn unify (tparms, targs, ntparms, t1,\n \t\t      fold (build (PLUS_EXPR, integer_type_node, arg, t2)),\n-\t\t      nsubsts);\n+\t\t      nsubsts, strict);\n       }\n \n     case TREE_VEC:\n@@ -2673,29 +2688,38 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \tfor (i = TREE_VEC_LENGTH (parm) - 1; i >= 0; i--)\n \t  if (unify (tparms, targs, ntparms,\n \t\t     TREE_VEC_ELT (parm, i), TREE_VEC_ELT (arg, i),\n-\t\t     nsubsts))\n+\t\t     nsubsts, strict))\n \t    return 1;\n \treturn 0;\n       }\n \n     case RECORD_TYPE:\n       if (TYPE_PTRMEMFUNC_FLAG (parm))\n \treturn unify (tparms, targs, ntparms, TYPE_PTRMEMFUNC_FN_TYPE (parm),\n-\t\t      arg, nsubsts);\n+\t\t      arg, nsubsts, strict);\n \n       /* Allow trivial conversions.  */\n       if (TREE_CODE (arg) != RECORD_TYPE\n \t  || TYPE_READONLY (parm) < TYPE_READONLY (arg)\n \t  || TYPE_VOLATILE (parm) < TYPE_VOLATILE (arg))\n \treturn 1;\n \n-      if (CLASSTYPE_TEMPLATE_INFO (parm) && CLASSTYPE_TEMPLATE_INFO (arg)\n-\t  && uses_template_parms (parm))\n+      if (CLASSTYPE_TEMPLATE_INFO (parm) && uses_template_parms (parm))\n \t{\n-\t  if (CLASSTYPE_TI_TEMPLATE (parm) != CLASSTYPE_TI_TEMPLATE (arg))\n+\t  tree t = NULL_TREE;\n+#ifdef NEW_OVER\n+\t  if (! strict)\n+\t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n+\t  else\n+#endif\n+\t  if (CLASSTYPE_TEMPLATE_INFO (arg)\n+\t      && CLASSTYPE_TI_TEMPLATE (parm) == CLASSTYPE_TI_TEMPLATE (arg))\n+\t    t = arg;\n+\t  if (! t || t == error_mark_node)\n \t    return 1;\n+\n \t  return unify (tparms, targs, ntparms, CLASSTYPE_TI_ARGS (parm),\n-\t\t\tCLASSTYPE_TI_ARGS (arg), nsubsts);\n+\t\t\tCLASSTYPE_TI_ARGS (t), nsubsts, strict);\n \t}\n       else if (TYPE_MAIN_VARIANT (parm) != TYPE_MAIN_VARIANT (arg))\n \treturn 1;\n@@ -2711,19 +2735,19 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n \treturn 1;\n      check_args:\n       if (unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t TREE_TYPE (arg), nsubsts))\n+\t\t TREE_TYPE (arg), nsubsts, strict))\n \treturn 1;\n       return type_unification (tparms, targs, TYPE_ARG_TYPES (parm),\n-\t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1);\n+\t\t\t       TYPE_ARG_TYPES (arg), nsubsts, 1, strict);\n \n     case OFFSET_TYPE:\n       if (TREE_CODE (arg) != OFFSET_TYPE)\n \treturn 1;\n       if (unify (tparms, targs, ntparms, TYPE_OFFSET_BASETYPE (parm),\n-\t\t TYPE_OFFSET_BASETYPE (arg), nsubsts))\n+\t\t TYPE_OFFSET_BASETYPE (arg), nsubsts, strict))\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm),\n-\t\t    TREE_TYPE (arg), nsubsts);\n+\t\t    TREE_TYPE (arg), nsubsts, strict);\n \n     default:\n       sorry (\"use of `%s' in template type unification\",\n@@ -2748,6 +2772,44 @@ mark_decl_instantiated (result, extern_p)\n     }\n }\n \n+/* Given two function templates PAT1 and PAT2, return:\n+\n+   1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n+   -1 if PAT2 is more specialized than PAT1.\n+   0 if neither is more specialized.  */\n+   \n+int\n+more_specialized (pat1, pat2)\n+     tree pat1, pat2;\n+{\n+  int ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (pat1));\n+  tree *targs = (tree *) malloc (sizeof (tree) * ntparms);\n+  int i, dummy = 0, winner = 0;\n+\n+  i = type_unification (DECL_TEMPLATE_PARMS (pat1), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat1)),\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat2)),\n+\t\t\t&dummy, 0, 1);\n+\n+  free (targs);\n+  if (i == 0)\n+    --winner;\n+\n+  ntparms = TREE_VEC_LENGTH (DECL_TEMPLATE_PARMS (pat2));\n+  targs = (tree *) malloc (sizeof (tree) * ntparms);\n+\n+  i = type_unification (DECL_TEMPLATE_PARMS (pat2), targs,\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat2)),\n+\t\t\tTYPE_ARG_TYPES (TREE_TYPE (pat1)),\n+\t\t\t&dummy, 0, 1);\n+\n+  free (targs);\n+  if (i == 0)\n+    ++winner;\n+\n+  return winner;\n+}\n+  \n /* called from the parser.  */\n \n void\n@@ -2794,11 +2856,19 @@ do_function_instantiation (declspecs, declarator, storage)\n \t    i = type_unification (DECL_TEMPLATE_PARMS (fn), targs,\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (fn)),\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (decl)),\n-\t\t\t\t  &dummy, 0);\n+\t\t\t\t  &dummy, 0, 1);\n \t    if (i == 0)\n \t      {\n \t\tif (result)\n-\t\t  cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n+\t\t  {\n+\t\t    int win = more_specialized (DECL_TI_TEMPLATE (result), fn);\n+\n+\t\t    if (win == 0)\n+\t\t      cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n+\t\t    else if (win == -1)\n+\t\t      result = instantiate_template (fn, targs);\n+\t\t    /* else keep current winner */\n+\t\t  }\n \t\telse\n \t\t  result = instantiate_template (fn, targs);\n \t      }"}, {"sha": "ed7843329ec76b53339344a578dfef5315aa59e8", "filename": "gcc/cp/search.c", "status": "modified", "additions": 86, "deletions": 4, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -919,7 +919,7 @@ compute_access (basetype_path, field)\n \t{\n \t  if (current_class_type\n \t      && static_mem\n-  \t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n+\t      && ACCESSIBLY_DERIVED_FROM_P (context, current_class_type))\n \t    PUBLIC_RETURN;\n \t  else\n \t    PROTECTED_RETURN;\n@@ -1580,7 +1580,7 @@ lookup_fnfields_1 (type, name)\n    which gives the following information (in a list):\n \n    TREE_TYPE: list of basetypes needed to get to...\n-   TREE_VALUE: list of all functions in of given type\n+   TREE_VALUE: list of all functions in a given type\n    which have name NAME.\n \n    No access information is computed by this function,\n@@ -1898,7 +1898,7 @@ lookup_fnfields (basetype_path, name, complain)\n \n /* Search a multiple inheritance hierarchy by breadth-first search.\n \n-   TYPE is an aggregate type, possibly in a multiple-inheritance hierarchy.\n+   BINFO is an aggregate type, possibly in a multiple-inheritance hierarchy.\n    TESTFN is a function, which, if true, means that our condition has been met,\n    and its return value should be returned.\n    QFN, if non-NULL, is a predicate dictating whether the type should\n@@ -3084,11 +3084,14 @@ build_mi_matrix (type)\n     }\n #endif\n \n+  dfs_walk (binfo, dfs_number, unnumberedp);\n+\n   mi_size = CLASSTYPE_N_SUPERCLASSES (type) + CLASSTYPE_N_VBASECLASSES (type);\n+  if (mi_size < cid)\n+    mi_size = cid;\n   mi_matrix = (char *)xmalloc ((mi_size + 1) * (mi_size + 1));\n   mi_type = type;\n   bzero (mi_matrix, (mi_size + 1) * (mi_size + 1));\n-  dfs_walk (binfo, dfs_number, unnumberedp);\n   dfs_walk (binfo, dfs_record_inheritance, unmarkedp);\n   dfs_walk (binfo, dfs_unmark, markedp);\n }\n@@ -3559,3 +3562,82 @@ lookup_conversions (type)\n     dfs_walk (TYPE_BINFO (type), add_conversions, 0);\n   return conversions;\n }\n+\n+/* Subroutine of get_template_base.  */\n+\n+static tree\n+get_template_base_recursive (binfo, rval, template, via_virtual)\n+     tree binfo, template, rval;\n+     int via_virtual;\n+{\n+  tree binfos;\n+  int i, n_baselinks;\n+  tree type = BINFO_TYPE (binfo);\n+\n+  if (CLASSTYPE_TEMPLATE_INFO (type)\n+      && CLASSTYPE_TI_TEMPLATE (type) == template)\n+    {\n+      if (rval == NULL_TREE || rval == type)\n+\treturn type;\n+      else\n+\treturn error_mark_node;\n+    }\n+\n+  binfos = BINFO_BASETYPES (binfo);\n+  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos) : 0;\n+\n+  /* Process base types.  */\n+  for (i = 0; i < n_baselinks; i++)\n+    {\n+      tree base_binfo = TREE_VEC_ELT (binfos, i);\n+\n+      /* Find any specific instance of a virtual base, when searching with\n+\t a binfo...  */\n+      if (BINFO_MARKED (base_binfo) == 0)\n+\t{\n+\t  int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n+\n+\t  /* When searching for a non-virtual, we cannot mark\n+\t     virtually found binfos.  */\n+\t  if (! this_virtual)\n+\t    SET_BINFO_MARKED (base_binfo);\n+\n+\t  rval = get_template_base_recursive\n+\t    (base_binfo, rval, template, this_virtual);\n+\t  if (rval == error_mark_node)\n+\t    return rval;\n+\t}\n+    }\n+\n+  return rval;\n+}\n+\n+/* Given a class template TEMPLATE and a class type or binfo node BINFO,\n+   find the unique base type in BINFO that is an instance of TEMPLATE.\n+   If there are more than one, return error_mark_node.  Used by unify.  */\n+\n+tree\n+get_template_base (template, binfo)\n+     register tree template, binfo;\n+{\n+  tree type, rval;\n+\n+  if (TREE_CODE (binfo) == TREE_VEC)\n+    type = BINFO_TYPE (binfo);\n+  else if (IS_AGGR_TYPE_CODE (TREE_CODE (binfo)))\n+    {\n+      type = complete_type (binfo);\n+      binfo = TYPE_BINFO (type);\n+    }\n+  else\n+    my_friendly_abort (92);\n+\n+  if (CLASSTYPE_TEMPLATE_INFO (type)\n+      && CLASSTYPE_TI_TEMPLATE (type) == template)\n+    return type;\n+\n+  rval = get_template_base_recursive (binfo, NULL_TREE, template, 0);\n+  dfs_walk (binfo, dfs_unmark, markedp);\n+\n+  return rval;\n+}"}, {"sha": "775e2c813181808edc0f8af2fb54f69ad3d0b7ac", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 67, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -132,8 +132,9 @@ complete_type (type)\n   else if (TREE_CODE (type) == ARRAY_TYPE && TYPE_DOMAIN (type))\n     {\n       tree t = complete_type (TREE_TYPE (type));\n-      if (TYPE_SIZE (t) != NULL_TREE)\n-\ttype = build_cplus_array_type (t, TYPE_DOMAIN (type));\n+      if (TYPE_SIZE (t) != NULL_TREE\n+\t  && current_template_parms == NULL_TREE)\n+\tlayout_type (type);\n     }\n   else if (IS_AGGR_TYPE (type) && CLASSTYPE_TEMPLATE_INSTANTIATION (type))\n     instantiate_class_template (TYPE_MAIN_VARIANT (type));\n@@ -1632,65 +1633,7 @@ build_component_ref_1 (datum, field, protect)\n      tree datum, field;\n      int protect;\n {\n-  register tree basetype = TREE_TYPE (datum);\n-  register enum tree_code code = TREE_CODE (basetype);\n-  register tree ref;\n-\n-  if (code == REFERENCE_TYPE)\n-    {\n-      datum = convert_from_reference (datum);\n-      basetype = TREE_TYPE (datum);\n-      code = TREE_CODE (basetype);\n-    }\n-\n-  if (! IS_AGGR_TYPE_CODE (code))\n-    {\n-      if (code != ERROR_MARK)\n-\tcp_error (\"request for member `%D' in `%E', which is of non-aggregate type `%T'\",\n-\t\t  field, datum, basetype);\n-      return error_mark_node;\n-    }\n-\n-  if (TYPE_SIZE (basetype) == 0)\n-    {\n-      incomplete_type_error (0, basetype);\n-      return error_mark_node;\n-    }\n-\n-  /* Look up component name in the structure type definition.  */\n-\n-  if (field == error_mark_node)\n-    my_friendly_abort (115);\n-\n-  if (TREE_STATIC (field))\n-    return field;\n-\n-  if (datum == current_class_ref)\n-    {\n-      tree access = compute_access (TYPE_BINFO (current_class_type), field);\n-\n-      if (access == access_private_node)\n-\t{\n-\t  cp_error (\"field `%D' is private\", field);\n-\t  return error_mark_node;\n-\t}\n-      else if (access == access_protected_node)\n-\t{\n-\t  cp_error (\"field `%D' is protected\", field);\n-\t  return error_mark_node;\n-\t}\n-    }\n-\n-  ref = build (COMPONENT_REF, TREE_TYPE (field), datum, field);\n-\n-  if (TREE_READONLY (datum) || TREE_READONLY (field))\n-    TREE_READONLY (ref) = 1;\n-  if (TREE_THIS_VOLATILE (datum) || TREE_THIS_VOLATILE (field))\n-    TREE_THIS_VOLATILE (ref) = 1;\n-  if (DECL_MUTABLE_P (field))\n-    TREE_READONLY (ref) = 0;\n-\n-  return ref;\n+  return build_component_ref (datum, field, NULL_TREE, protect);\n }\n \n /* Given a COND_EXPR in T, return it in a form that we can, for\n@@ -2414,8 +2357,7 @@ build_x_function_call (function, params, decl)\n       if (TREE_CODE (type) == REFERENCE_TYPE)\n \ttype = TREE_TYPE (type);\n \n-      if (TYPE_LANG_SPECIFIC (type)\n-\t  && TYPE_OVERLOADS_CALL_EXPR (complete_type (type)))\n+      if (IS_AGGR_TYPE (type))\n \treturn build_opfncall (CALL_EXPR, LOOKUP_NORMAL, function, params, NULL_TREE);\n     }\n \n@@ -5586,10 +5528,8 @@ build_modify_expr (lhs, modifycode, rhs)\n       else if (TYPE_HAS_TRIVIAL_ASSIGN_REF (lhstype)\n \t       && TYPE_MAIN_VARIANT (lhstype) == TYPE_MAIN_VARIANT (TREE_TYPE (newrhs)))\n \t{\n-\t  if (warn_synth)\n-\t    /* If we care about this, do overload resolution.  */\n-\t    build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n-\t\t\t    lhs, rhs, make_node (NOP_EXPR));\n+\t  build_opfncall (MODIFY_EXPR, LOOKUP_NORMAL,\n+\t\t\t  lhs, rhs, make_node (NOP_EXPR));\n \n \t  /* Do the default thing */;\n \t}\n@@ -6778,6 +6718,8 @@ convert_for_initialization (exp, type, rhs, flags, errtype, fndecl, parmnum)\n   if (TREE_CODE (rhstype) == REFERENCE_TYPE)\n     rhstype = TREE_TYPE (rhstype);\n \n+  type = complete_type (type);\n+\n   if (TYPE_LANG_SPECIFIC (type)\n       && (IS_SIGNATURE_POINTER (type) || IS_SIGNATURE_REFERENCE (type)))\n     return build_signature_pointer_constructor (type, rhs);"}, {"sha": "16b29dc0c5d7cfceeb5f179bf51e86c875418776", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6467930b062a0adc1562ad54dfa0075ec29eda97/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6467930b062a0adc1562ad54dfa0075ec29eda97", "patch": "@@ -302,7 +302,7 @@ ack (s, v, v2)\n    silly.  So instead, we just do the equivalent of a call to fatal in the\n    same situation (call exit).  */\n \n-/* First used: 0 (reserved), Last used: 366.  Free: */\n+/* First used: 0 (reserved), Last used: 367.  Free: */\n \n static int abortcount = 0;\n \n@@ -1091,7 +1091,8 @@ process_init_constructor (type, init, elts)\n \n       /* Find the first named field.  ANSI decided in September 1990\n \t that only named fields count here.  */\n-      while (field && DECL_NAME (field) == 0)\n+      while (field && (DECL_NAME (field) == 0\n+\t\t       || TREE_CODE (field) != FIELD_DECL))\n \tfield = TREE_CHAIN (field);\n \n       /* If this element specifies a field, initialize via that field.  */"}]}