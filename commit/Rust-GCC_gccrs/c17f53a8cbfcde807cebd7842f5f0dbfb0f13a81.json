{"sha": "c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzE3ZjUzYThjYmZjZGU4MDdjZWJkNzg0MmY1ZjBkYmZiMGYxM2E4MQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-02T21:27:38Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1996-01-02T21:27:38Z"}, "message": "(gen_shifty_op): Output a NOP for a shift by 0.\n\n(find_barrier): New variables si_limit, hi_limit.  Set them depending\non whether we are optimizing.  Set found_hi if the destination is\nHImode.\n(machine_dependent_reorg): If not optimizing, then change scan to a\nnote instead of calling delete_insn.\n\nFrom-SVN: r10937", "tree": {"sha": "fdee7c2544ed9187225cafde1d35bd888ed5bcf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdee7c2544ed9187225cafde1d35bd888ed5bcf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81/comments", "author": null, "committer": null, "parents": [{"sha": "403aec4f5703a8850fcfd9933c9f08585f3c6e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/403aec4f5703a8850fcfd9933c9f08585f3c6e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/403aec4f5703a8850fcfd9933c9f08585f3c6e28"}], "stats": {"total": 55, "additions": 49, "deletions": 6}, "files": [{"sha": "4d93874bb3ea85186078db434e573c2bcd1ac51b", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=c17f53a8cbfcde807cebd7842f5f0dbfb0f13a81", "patch": "@@ -915,6 +915,14 @@ gen_shifty_op (code, operands)\n \t    }\n \t}\n     }\n+  else if (value == 0)\n+    {\n+      /* This can happen when not optimizing.  We must output something here\n+\t to prevent the compiler from aborting in final.c after the try_split\n+\t call.  */\n+      emit_insn (gen_nop ());\n+      return;\n+    }\n \n   max = shift_insns[value];\n   for (i = 0; i < max; i++)\n@@ -1232,6 +1240,8 @@ find_barrier (from)\n   int found_si = 0;\n   rtx found_barrier = 0;\n   rtx found_mova = 0;\n+  int si_limit;\n+  int hi_limit;\n \n   /* For HImode: range is 510, add 4 because pc counts from address of\n      second instruction after this one, subtract 2 for the jump instruction\n@@ -1240,7 +1250,24 @@ find_barrier (from)\n      second instruction after this one, subtract 2 in case pc is 2 byte\n      aligned, subtract 2 for the jump instruction that we may need to emit\n      before the table.  This gives 1020.  */\n-  while (from && count_si < 1020 && count_hi < 512)\n+\n+  /* If not optimizing, then it is possible that the jump instruction we add\n+     won't be shortened, and thus will have a length of 14 instead of 2.\n+     We must adjust the limits downwards to account for this, giving a limit\n+     of 1008 for SImode and 500 for HImode.  */\n+\n+  if (optimize)\n+    {\n+      si_limit = 1020;\n+      hi_limit = 512;\n+    }\n+  else\n+    {\n+      si_limit = 1008;\n+      hi_limit = 500;\n+    }\n+\n+  while (from && count_si < si_limit && count_hi < hi_limit)\n     {\n       int inc = get_attr_length (from);\n \n@@ -1249,9 +1276,15 @@ find_barrier (from)\n \n       if (broken_move (from))\n \t{\n-\t  rtx src = SET_SRC (PATTERN (from));\n-\n-\t  if (hi_const (src))\n+\t  rtx pat = PATTERN (from);\n+\t  rtx src = SET_SRC (pat);\n+\t  rtx dst = SET_DEST (pat);\n+\t  enum machine_mode mode = GET_MODE (dst);\n+\n+\t  /* We must explicitly check the mode, because sometimes the\n+\t     front end will generate code to load unsigned constants into\n+\t     HImode targets without properly sign extending them.  */\n+\t  if (mode == HImode || (mode == SImode && hi_const (src)))\n \t    {\n \t      found_hi = 1;\n \t      /* We put the short constants before the long constants, so\n@@ -1296,7 +1329,7 @@ find_barrier (from)\n       /* If we exceeded the range, then we must back up over the last\n \t instruction we looked at.  Otherwise, we just need to undo the\n \t NEXT_INSN at the end of the loop.  */\n-      if (count_hi > 512 || count_si > 1020)\n+      if (count_hi > hi_limit || count_si > si_limit)\n \tfrom = PREV_INSN (PREV_INSN (from));\n       else\n \tfrom = PREV_INSN (from);\n@@ -1646,7 +1679,17 @@ machine_dependent_reorg (first)\n \t\t\t\t\t\t      dst, newsrc), scan);\n \t\t  REG_NOTES (newinsn) = REG_NOTES (scan);\n \t\t  REG_NOTES (scan) = NULL_RTX;\n-\t\t  delete_insn (scan);\n+\t\t  /* If not optimizing, then delete_insn doesn't remove the\n+\t\t     insn from the chain, and hence is not useful.  We\n+\t\t     convert the instruction to a NOTE in that case.  */\n+\t\t  if (optimize)\n+\t\t    delete_insn (scan);\n+\t\t  else\n+\t\t    {\n+\t\t      PUT_CODE (scan, NOTE);\n+\t\t      NOTE_LINE_NUMBER (scan) = NOTE_INSN_DELETED;\n+\t\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t\t    }\n \t\t  scan = newinsn;\n \t\t}\n \t    }"}]}