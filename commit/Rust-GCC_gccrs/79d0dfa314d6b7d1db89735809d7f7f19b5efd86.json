{"sha": "79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlkMGRmYTMxNGQ2YjdkMWRiODk3MzU4MDlkN2Y3ZjE5YjVlZmQ4Ng==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-05-17T15:37:47Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-05-17T15:37:47Z"}, "message": "unwind-dw2-fde-glibc.c (base_from_cb_data, [...]): Use gcc_assert and gcc_unreachable as appropriate.\n\n\t* unwind-dw2-fde-glibc.c (base_from_cb_data,\n\t_Unwind_IteratePhdrCallback): Use gcc_assert and gcc_unreachable as\n\tappropriate.\n\t* unwind-dw2-fde.c (__deregister_frame_info_bases,\n\tbase_from_object, fde_split, end_fde_sort): Likewise.\n\t* unwind-dw2.c (_Unwind_GetGR, _Unwind_SetGR, execute_stack_op,\n\texecute_cfa_program, _Unwind_SetSpColumn, uw_update_context_1,\n\tuw_init_context_1): Likewise.\n\t* unwind.inc (_Unwind_RaiseException_Phase2, _Unwind_Resume,\n\t_Unwind_Resume_or_Rethrow): Likewise.\n\t* unwind-pe.h (__gxx_abort): Do not define.\n\t(size_of_encoded_value, base_of_encoded_value,\n\tread_encoded_value_with_base): Use gcc_unreachable.\n\t* unwind.h (_Unwind_GetTextRelBase): Likewise.\n\nFrom-SVN: r99835", "tree": {"sha": "386dad5929e3765399d5b24a1e7d76be228b6d15", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/386dad5929e3765399d5b24a1e7d76be228b6d15"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/comments", "author": null, "committer": null, "parents": [{"sha": "d0f11b16532d9c96c3a32ec284bd4470c67ba4b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d0f11b16532d9c96c3a32ec284bd4470c67ba4b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d0f11b16532d9c96c3a32ec284bd4470c67ba4b4"}], "stats": {"total": 181, "additions": 93, "deletions": 88}, "files": [{"sha": "4ad39e000240bd612c1343bcac0044ae13385992", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -1,3 +1,20 @@\n+2005-05-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* unwind-dw2-fde-glibc.c (base_from_cb_data,\n+\t_Unwind_IteratePhdrCallback): Use gcc_assert and gcc_unreachable as\n+\tappropriate.\n+\t* unwind-dw2-fde.c (__deregister_frame_info_bases,\n+\tbase_from_object, fde_split, end_fde_sort): Likewise.\n+\t* unwind-dw2.c (_Unwind_GetGR, _Unwind_SetGR, execute_stack_op, \n+\texecute_cfa_program, _Unwind_SetSpColumn, uw_update_context_1,\n+\tuw_init_context_1): Likewise.\n+\t* unwind.inc (_Unwind_RaiseException_Phase2, _Unwind_Resume,\n+\t_Unwind_Resume_or_Rethrow): Likewise.\n+\t* unwind-pe.h (__gxx_abort): Do not define.\n+\t(size_of_encoded_value, base_of_encoded_value,\n+\tread_encoded_value_with_base): Use gcc_unreachable.\n+\t* unwind.h (_Unwind_GetTextRelBase): Likewise.\n+\n 2005-05-17  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* config/arm/lib1funcs.asm (cfi_pop, cfi_push, cfi_start)"}, {"sha": "306afdda0ac5aa55effbe6012058a1d056d393bb", "filename": "gcc/unwind-dw2-fde-glibc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2-fde-glibc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2-fde-glibc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde-glibc.c?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -118,8 +118,9 @@ base_from_cb_data (unsigned char encoding, struct unw_eh_callback_data *data)\n       return (_Unwind_Ptr) data->tbase;\n     case DW_EH_PE_datarel:\n       return (_Unwind_Ptr) data->dbase;\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n static int\n@@ -358,8 +359,7 @@ _Unwind_IteratePhdrCallback (struct dl_phdr_info *info, size_t size, void *ptr)\n \t\t    break;\n \t\t}\n \n-\t      if (lo >= hi)\n-\t\t__gxx_abort ();\n+\t      gcc_assert (lo < hi);\n \t    }\n \n \t  f = (fde *) (table[mid].fde + data_base);"}, {"sha": "15cdd57f69b4ec53c80ffd9c3bafc2ce0a3ae8c4", "filename": "gcc/unwind-dw2-fde.c", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2-fde.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2-fde.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2-fde.c?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -164,7 +164,7 @@ __register_frame_table (void *begin)\n    from crtbegin (wherein it is declared weak), and this object does\n    not get pulled from libgcc.a for other reasons, then the\n    invocation of __deregister_frame_info will be resolved from glibc.\n-   Since the registration did not happen there, we'll abort.\n+   Since the registration did not happen there, we'll die.\n \n    Therefore, declare a new deregistration entry point that does the\n    exact same thing, but will resolve to the same library as\n@@ -212,11 +212,9 @@ __deregister_frame_info_bases (const void *begin)\n \t  }\n       }\n \n-  __gthread_mutex_unlock (&object_mutex);\n-  abort ();\n-\n  out:\n   __gthread_mutex_unlock (&object_mutex);\n+  gcc_assert (ob);\n   return (void *) ob;\n }\n \n@@ -255,8 +253,9 @@ base_from_object (unsigned char encoding, struct object *ob)\n       return (_Unwind_Ptr) ob->tbase;\n     case DW_EH_PE_datarel:\n       return (_Unwind_Ptr) ob->dbase;\n+    default:\n+      gcc_unreachable ();\n     }\n-  abort ();\n }\n \n /* Return the FDE pointer encoding from the CIE.  */\n@@ -441,8 +440,7 @@ fde_split (struct object *ob, fde_compare_t fde_compare,\n   /* This should optimize out, but it is wise to make sure this assumption\n      is correct. Should these have different sizes, we cannot cast between\n      them and the overlaying onto ERRATIC will not work.  */\n-  if (sizeof (const fde *) != sizeof (const fde **))\n-    abort ();\n+  gcc_assert (sizeof (const fde *) == sizeof (const fde **));\n \n   for (i = 0; i < count; i++)\n     {\n@@ -566,8 +564,7 @@ end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n {\n   fde_compare_t fde_compare;\n \n-  if (accu->linear && accu->linear->count != count)\n-    abort ();\n+  gcc_assert (!accu->linear || accu->linear->count == count);\n \n   if (ob->s.b.mixed_encoding)\n     fde_compare = fde_mixed_encoding_compare;\n@@ -579,8 +576,7 @@ end_fde_sort (struct object *ob, struct fde_accumulator *accu, size_t count)\n   if (accu->erratic)\n     {\n       fde_split (ob, fde_compare, accu->linear, accu->erratic);\n-      if (accu->linear->count + accu->erratic->count != count)\n-\tabort ();\n+      gcc_assert (accu->linear->count + accu->erratic->count == count);\n       frame_heapsort (ob, fde_compare, accu->erratic);\n       fde_merge (ob, fde_compare, accu->linear, accu->erratic);\n       free (accu->erratic);"}, {"sha": "b50ae010283dd14af61437fce7360eb6154ee26a", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -131,19 +131,18 @@ _Unwind_GetGR (struct _Unwind_Context *context, int index)\n #endif\n \n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n-  if (index >= (int) sizeof(dwarf_reg_size_table))\n-    abort ();\n+  gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n   size = dwarf_reg_size_table[index];\n   ptr = context->reg[index];\n \n   /* This will segfault if the register hasn't been saved.  */\n   if (size == sizeof(_Unwind_Ptr))\n     return * (_Unwind_Ptr *) ptr;\n-\n-  if (size == sizeof(_Unwind_Word))\n-    return * (_Unwind_Word *) ptr;\n-\n-  abort ();\n+  else\n+    {\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      return * (_Unwind_Word *) ptr;\n+    }\n }\n \n static inline void *\n@@ -169,17 +168,17 @@ _Unwind_SetGR (struct _Unwind_Context *context, int index, _Unwind_Word val)\n   void *ptr;\n \n   index = DWARF_REG_TO_UNWIND_COLUMN (index);\n-  if (index >= (int) sizeof(dwarf_reg_size_table))\n-    abort ();\n+  gcc_assert (index < (int) sizeof(dwarf_reg_size_table));\n   size = dwarf_reg_size_table[index];\n   ptr = context->reg[index];\n \n   if (size == sizeof(_Unwind_Ptr))\n     * (_Unwind_Ptr *) ptr = val;\n-  else if (size == sizeof(_Unwind_Word))\n-    * (_Unwind_Word *) ptr = val;\n   else\n-    abort ();\n+    {\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      * (_Unwind_Word *) ptr = val;\n+    }\n }\n \n /* Get the pointer to a register INDEX as saved in CONTEXT.  */\n@@ -518,35 +517,31 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  break;\n \n \tcase DW_OP_dup:\n-\t  if (stack_elt < 1)\n-\t    abort ();\n+\t  gcc_assert (stack_elt);\n \t  result = stack[stack_elt - 1];\n \t  break;\n \n \tcase DW_OP_drop:\n-\t  if (--stack_elt < 0)\n-\t    abort ();\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n \t  goto no_push;\n \n \tcase DW_OP_pick:\n \t  offset = *op_ptr++;\n-\t  if (offset >= stack_elt - 1)\n-\t    abort ();\n+\t  gcc_assert (offset < stack_elt - 1);\n \t  result = stack[stack_elt - 1 - offset];\n \t  break;\n \n \tcase DW_OP_over:\n-\t  if (stack_elt < 2)\n-\t    abort ();\n+\t  gcc_assert (stack_elt >= 2);\n \t  result = stack[stack_elt - 2];\n \t  break;\n \n \tcase DW_OP_rot:\n \t  {\n \t    _Unwind_Word t1, t2, t3;\n \n-\t    if (stack_elt < 3)\n-\t      abort ();\n+\t    gcc_assert (stack_elt >= 3);\n \t    t1 = stack[stack_elt - 1];\n \t    t2 = stack[stack_elt - 2];\n \t    t3 = stack[stack_elt - 3];\n@@ -563,8 +558,9 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \tcase DW_OP_not:\n \tcase DW_OP_plus_uconst:\n \t  /* Unary operations.  */\n-\t  if (--stack_elt < 0)\n-\t    abort ();\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n+\t  \n \t  result = stack[stack_elt];\n \n \t  switch (op)\n@@ -594,7 +590,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t\t    result = read_8u (ptr);\n \t\t    break;\n \t\t  default:\n-\t\t    abort ();\n+\t\t    gcc_unreachable ();\n \t\t  }\n \t      }\n \t      break;\n@@ -615,7 +611,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t      break;\n \n \t    default:\n-\t      abort ();\n+\t      gcc_unreachable ();\n \t    }\n \t  break;\n \n@@ -639,8 +635,9 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  {\n \t    /* Binary operations.  */\n \t    _Unwind_Word first, second;\n-\t    if ((stack_elt -= 2) < 0)\n-\t      abort ();\n+\t    gcc_assert (stack_elt >= 2);\n+\t    stack_elt -= 2;\n+\t    \n \t    second = stack[stack_elt];\n \t    first = stack[stack_elt + 1];\n \n@@ -699,7 +696,7 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t\tbreak;\n \n \t      default:\n-\t\tabort ();\n+\t\tgcc_unreachable ();\n \t      }\n \t  }\n \t  break;\n@@ -711,8 +708,9 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  goto no_push;\n \n \tcase DW_OP_bra:\n-\t  if (--stack_elt < 0)\n-\t    abort ();\n+\t  gcc_assert (stack_elt);\n+\t  stack_elt -= 1;\n+\t  \n \t  offset = read_2s (op_ptr);\n \t  op_ptr += 2;\n \t  if (stack[stack_elt] != 0)\n@@ -723,20 +721,19 @@ execute_stack_op (const unsigned char *op_ptr, const unsigned char *op_end,\n \t  goto no_push;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       /* Most things push a result value.  */\n-      if ((size_t) stack_elt >= sizeof(stack)/sizeof(*stack))\n-\tabort ();\n+      gcc_assert ((size_t) stack_elt < sizeof(stack)/sizeof(*stack));\n       stack[stack_elt++] = result;\n     no_push:;\n     }\n \n   /* We were executing this program to get a value.  It should be\n      at top of stack.  */\n-  if (--stack_elt < 0)\n-    abort ();\n+  gcc_assert (stack_elt);\n+  stack_elt -= 1;\n   return stack[stack_elt];\n }\n \n@@ -944,7 +941,7 @@ execute_cfa_program (const unsigned char *insn_ptr,\n \t  break;\n \n \tdefault:\n-\t  abort ();\n+\t  gcc_unreachable ();\n \t}\n     }\n }\n@@ -1088,10 +1085,11 @@ _Unwind_SetSpColumn (struct _Unwind_Context *context, void *cfa,\n   \n   if (size == sizeof(_Unwind_Ptr))\n     tmp_sp->ptr = (_Unwind_Ptr) cfa;\n-  else if (size == sizeof(_Unwind_Word))\n-    tmp_sp->word = (_Unwind_Ptr) cfa;\n   else\n-    abort ();\n+    {\n+      gcc_assert (size == sizeof(_Unwind_Word));\n+      tmp_sp->word = (_Unwind_Ptr) cfa;\n+    }\n   _Unwind_SetGRPtr (context, __builtin_dwarf_sp_column (), tmp_sp);\n }\n \n@@ -1145,7 +1143,7 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n       }\n \n     default:\n-      abort ();\n+      gcc_unreachable ();\n     }\n   context->cfa = cfa;\n \n@@ -1229,12 +1227,13 @@ uw_init_context_1 (struct _Unwind_Context *context,\n   void *ra = __builtin_extract_return_addr (__builtin_return_address (0));\n   _Unwind_FrameState fs;\n   _Unwind_SpTmp sp_slot;\n+  _Unwind_Reason_Code code;\n \n   memset (context, 0, sizeof (struct _Unwind_Context));\n   context->ra = ra;\n \n-  if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)\n-    abort ();\n+  code = uw_frame_state_for (context, &fs);\n+  gcc_assert (code == _URC_NO_REASON);\n \n #if __GTHREADS\n   {"}, {"sha": "ce7d6943c0a3734724280efa40f9dd2d10e46c6c", "filename": "gcc/unwind-pe.h", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-pe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind-pe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-pe.h?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -34,13 +34,6 @@\n #ifndef GCC_UNWIND_PE_H\n #define GCC_UNWIND_PE_H\n \n-/* If using C++, references to abort have to be qualified with std::.  */\n-#if __cplusplus\n-#define __gxx_abort std::abort\n-#else\n-#define __gxx_abort abort\n-#endif\n-\n /* Pointer encodings, from dwarf2.h.  */\n #define DW_EH_PE_absptr         0x00\n #define DW_EH_PE_omit           0xff\n@@ -86,8 +79,9 @@ size_of_encoded_value (unsigned char encoding)\n       return 4;\n     case DW_EH_PE_udata8:\n       return 8;\n+    default:\n+      gcc_unreachable ();\n     }\n-  __gxx_abort ();\n }\n \n #endif\n@@ -118,8 +112,9 @@ base_of_encoded_value (unsigned char encoding, struct _Unwind_Context *context)\n       return _Unwind_GetDataRelBase (context);\n     case DW_EH_PE_funcrel:\n       return _Unwind_GetRegionStart (context);\n+    default:\n+      gcc_unreachable ();\n     }\n-  __gxx_abort ();\n }\n \n #endif\n@@ -256,7 +251,7 @@ read_encoded_value_with_base (unsigned char encoding, _Unwind_Ptr base,\n \t  break;\n \n \tdefault:\n-\t  __gxx_abort ();\n+\t  gcc_unreachable ();\n \t}\n \n       if (result != 0)"}, {"sha": "978b9f09c5e6327db11a10e12f83416ed2042ab5", "filename": "gcc/unwind.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.h?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -214,8 +214,7 @@ _Unwind_GetDataRelBase (struct _Unwind_Context *_C)\n static inline _Unwind_Ptr\n _Unwind_GetTextRelBase (struct _Unwind_Context *_C __attribute__ ((__unused__)))\n {\n-  abort ();\n-  return 0;\n+  gcc_unreachable ();\n }\n \n /* @@@ Retrieve the Backing Store Pointer of the given context.  */"}, {"sha": "dc4708ecd9c32bd25c0d73fba10dd9104ed3f7d3", "filename": "gcc/unwind.inc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/gcc%2Funwind.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind.inc?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -72,8 +72,7 @@ _Unwind_RaiseException_Phase2(struct _Unwind_Exception *exc,\n \t}\n \n       /* Don't let us unwind past the handler context.  */\n-      if (match_handler)\n-\tabort ();\n+      gcc_assert (!match_handler);\n \n       uw_update_context (context, &fs);\n     }\n@@ -144,8 +143,8 @@ _Unwind_RaiseException(struct _Unwind_Exception *exc)\n /* Subroutine of _Unwind_ForcedUnwind also invoked from _Unwind_Resume.  */\n \n static _Unwind_Reason_Code\n-_Unwind_ForcedUnwind_Phase2(struct _Unwind_Exception *exc,\n-\t\t\t    struct _Unwind_Context *context)\n+_Unwind_ForcedUnwind_Phase2 (struct _Unwind_Exception *exc,\n+\t\t\t     struct _Unwind_Context *context)\n {\n   _Unwind_Stop_Fn stop = (_Unwind_Stop_Fn) (_Unwind_Ptr) exc->private_1;\n   void *stop_argument = (void *) (_Unwind_Ptr) exc->private_2;\n@@ -235,8 +234,7 @@ _Unwind_Resume (struct _Unwind_Exception *exc)\n   else\n     code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n \n-  if (code != _URC_INSTALL_CONTEXT)\n-    abort ();\n+  gcc_assert (code == _URC_INSTALL_CONTEXT);\n \n   uw_install_context (&this_context, &cur_context);\n }\n@@ -261,8 +259,7 @@ _Unwind_Resume_or_Rethrow (struct _Unwind_Exception *exc)\n \n   code = _Unwind_ForcedUnwind_Phase2 (exc, &cur_context);\n \n-  if (code != _URC_INSTALL_CONTEXT)\n-    abort ();\n+  gcc_assert (code == _URC_INSTALL_CONTEXT);\n \n   uw_install_context (&this_context, &cur_context);\n }"}, {"sha": "585acb2271e25b92c6560fcaf200d50a41de51b5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -1,3 +1,8 @@\n+2005-05-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* exception.cc (abort): Remove std::abort hack.\n+\t(gcc_unreacheable): Define.\n+\n 2005-05-17  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* Makefile.am (Makefile.deps): Do not create native.list and"}, {"sha": "4bab412d5baf4081c678440db0fcc6ab74010b6d", "filename": "libjava/exception.cc", "status": "modified", "additions": 3, "deletions": 11, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libjava%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libjava%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fexception.cc?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -19,17 +19,9 @@ details.  */\n #include <gcj/cni.h>\n #include <jvm.h>\n \n-// unwind-pe.h uses std::abort(), but sometimes we compile libjava\n-// without libstdc++-v3. The following hack forces it to use\n-// stdlib.h's abort().\n-namespace std\n-{\n-  static __attribute__ ((__noreturn__)) void\n-  abort ()\n-  {\n-    ::abort ();\n-  }\n-}\n+// Sometimes we compile libjava without libstdc++-v3. Therefore make\n+// sure we use stdlib.h's abort().\n+#define gcc_unreachable() ::abort ()\n #include \"unwind.h\"\n \n struct alignment_test_struct"}, {"sha": "b265c8b48bf7b0d8c320b7d1fb309467578d4a44", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -1,3 +1,7 @@\n+2005-05-17  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* libsupc++/eh_personality.cc (gcc_unreachable): Define.\n+\n 2005-05-16  Paolo Carlini  <pcarlini@suse.de>\n \n \t* docs/html/install.html: Update list of required named"}, {"sha": "ae8756b04ce863304c22cdbce324edaf07711b9f", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79d0dfa314d6b7d1db89735809d7f7f19b5efd86/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=79d0dfa314d6b7d1db89735809d7f7f19b5efd86", "patch": "@@ -35,6 +35,7 @@\n \n using namespace __cxxabiv1;\n \n+#define gcc_unreachable() std::abort()\n #include \"unwind-pe.h\"\n \n \f"}]}