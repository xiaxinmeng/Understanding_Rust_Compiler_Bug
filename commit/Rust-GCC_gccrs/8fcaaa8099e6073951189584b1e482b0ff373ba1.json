{"sha": "8fcaaa8099e6073951189584b1e482b0ff373ba1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZjYWFhODA5OWU2MDczOTUxMTg5NTg0YjFlNDgyYjBmZjM3M2JhMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-19T20:50:36Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-19T20:50:36Z"}, "message": "i386.h (enum reg_class): Add FLOAT_INT_REGS.\n\n\t* i386.h (enum reg_class): Add FLOAT_INT_REGS.\n\t(REG_CLASS_NAMES): Likewise.\n\t(REG_CLASS_CONTENTS): Define FLOAT_INT_REGS as union of FLOAT_REGS\n\tand GENERAL_REGS.\n\t* i386.md (pushsf): Do not preferre FLOAT_REGS over GENERAL_REGS.\n\t(movsf): Likewise; unify 4th and 5th alternative.\n\t(pushdf): Likewise.\n\t(movdf_1): Likewise; rename to movdf_integer.\n\t(pushxf): Likewise; rename to pushxf_integer; fix output template;\n\tremove redundant splitter.\n\t(movxf_1): Likewise; rename to movxf_integer; fix splitter's condition.\n\t(movdf_nointeger): New.\n\t(movxf_nointeger): New.\n\t(pushxf_nointeger): New.\n\nFrom-SVN: r30594", "tree": {"sha": "f03313c0d43159024dfdfe2c450a61c59e8730d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f03313c0d43159024dfdfe2c450a61c59e8730d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fcaaa8099e6073951189584b1e482b0ff373ba1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcaaa8099e6073951189584b1e482b0ff373ba1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fcaaa8099e6073951189584b1e482b0ff373ba1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fcaaa8099e6073951189584b1e482b0ff373ba1/comments", "author": null, "committer": null, "parents": [{"sha": "f97d9ec3779fba07c222b4241da011afb1664a24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f97d9ec3779fba07c222b4241da011afb1664a24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f97d9ec3779fba07c222b4241da011afb1664a24"}], "stats": {"total": 236, "additions": 191, "deletions": 45}, "files": [{"sha": "3e1552b3c36f188cc551cfb2b533c059bebb684e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fcaaa8099e6073951189584b1e482b0ff373ba1", "patch": "@@ -1,5 +1,20 @@\n Fri Nov 19 06:32:19 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n \n+\t* i386.h (enum reg_class): Add FLOAT_INT_REGS.\n+\t(REG_CLASS_NAMES): Likewise.\n+\t(REG_CLASS_CONTENTS): Define FLOAT_INT_REGS as union of FLOAT_REGS\n+\tand GENERAL_REGS.\n+\t* i386.md (pushsf): Do not preferre FLOAT_REGS over GENERAL_REGS.\n+\t(movsf): Likewise; unify 4th and 5th alternative.\n+\t(pushdf): Likewise.\n+\t(movdf_1): Likewise; rename to movdf_integer.\n+\t(pushxf): Likewise; rename to pushxf_integer; fix output template;\n+\tremove redundant splitter.\n+\t(movxf_1): Likewise; rename to movxf_integer; fix splitter's condition.\n+\t(movdf_nointeger): New.\n+\t(movxf_nointeger): New.\n+\t(pushxf_nointeger): New.\n+\n \t* i386.md (extend?f?f): Split to expander and pattern, refuse two\n \tmemory operands in patterns.\n \t(fop*): Refuse two memory operands."}, {"sha": "e832a44952792c5284cc1cf5d361f825c7404ceb", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=8fcaaa8099e6073951189584b1e482b0ff373ba1", "patch": "@@ -835,6 +835,7 @@ enum reg_class\n   GENERAL_REGS,\t\t\t/* %eax %ebx %ecx %edx %esi %edi %ebp %esp */\n   FP_TOP_REG, FP_SECOND_REG,\t/* %st(0) %st(1) */\n   FLOAT_REGS,\n+  FLOAT_INT_REGS,\t\t/* FLOAT_REGS and GENERAL_REGS.  */\n   ALL_REGS, LIM_REG_CLASSES\n };\n \n@@ -854,6 +855,7 @@ enum reg_class\n    \"GENERAL_REGS\",\t\t\t\\\n    \"FP_TOP_REG\", \"FP_SECOND_REG\",\t\\\n    \"FLOAT_REGS\",\t\t\t\\\n+   \"FLOAT_INT_REGS\",\t\t\t\\\n    \"ALL_REGS\" }\n \n /* Define which registers fit in which classes.\n@@ -871,6 +873,7 @@ enum reg_class\n  {0x100ff},\t\t\t/* GENERAL_REGS */\t\t\\\n   {0x0100}, {0x0200},\t\t/* FP_TOP_REG, FP_SECOND_REG */\t\\\n   {0xff00},\t\t\t/* FLOAT_REGS */\t\t\\\n+  {0x1ffff},\t\t\t/* FLOAT_INT_REGS */\t\t\\\n  {0x7ffff}\t\t\t\t\t\t\t\\\n }\n "}, {"sha": "bd429b89bff67bffb08e950c42e7c39b25d1dbf9", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 173, "deletions": 45, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fcaaa8099e6073951189584b1e482b0ff373ba1/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=8fcaaa8099e6073951189584b1e482b0ff373ba1", "patch": "@@ -1697,7 +1697,7 @@\n \n (define_insn \"*pushsf\"\n   [(set (match_operand:SF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:SF 1 \"general_operand\" \"f,Ffm*r\"))]\n+\t(match_operand:SF 1 \"general_operand\" \"f#r,rFm#f\"))]\n   \"\"\n   \"*\n {\n@@ -1731,9 +1731,9 @@\n    (set (mem:SF (reg:SI 7)) (match_dup 1))])\n \n (define_insn \"*movsf_1\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f,m,f,*r,m,*r\")\n-\t(match_operand:SF 1 \"general_operand\" \"fm,f,G,*rm,F*r,GF\"))]\n-  \"\"\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,m\")\n+\t(match_operand:SF 1 \"general_operand\" \"fm#r,f#r,G,rmF#f,Fr#f\"))]\n+  \"GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM\"\n   \"*\n {\n   switch (which_alternative)\n@@ -1765,14 +1765,13 @@\n \n     case 3:\n     case 4:\n-    case 5:\n       return \\\"mov{l}\\\\t{%1, %0|%0, %1}\\\";\n \n     default:\n       abort();\n     }\n }\"\n-  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov,imov\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,imov,imov\")])\n \n (define_insn \"swapsf\"\n   [(set (match_operand:SF 0 \"register_operand\" \"+f\")\n@@ -1795,9 +1794,14 @@\n   \"\"\n   \"ix86_expand_move (DFmode, operands); DONE;\")\n \n+;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n+;; Size of pushdf using integer insturctions is 2+2*memory operand size\n+;; On the average, pushdf using integers can be still shorter.  Allow this\n+;; pattern for optimize_size too.\n+\n (define_insn \"*pushdf\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:DF 1 \"general_operand\" \"f,ofF*r\"))]\n+\t(match_operand:DF 1 \"general_operand\" \"f#r,rFo#f\"))]\n   \"\"\n   \"*\n {\n@@ -1838,10 +1842,59 @@\n   [(const_int 0)]\n   \"if (!ix86_split_long_move (operands)) abort (); DONE;\")\n \n-(define_insn \"*movdf_1\"\n+;; Moving is usually shorter when only FP registers are used. This separate\n+;; movdf pattern avoids the use of integer registers for FP operations\n+;; when optimizing for size.\n+\n+(define_insn \"*movdf_nointeger\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n \t(match_operand:DF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n-  \"\"\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && optimize_size\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n+\n+    case 1:\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fst%z0\\\\t%y0\\\";\n+\n+    case 2:\n+      switch (standard_80387_constant_p (operands[1]))\n+        {\n+        case 1:\n+\t  return \\\"fldz\\\";\n+\tcase 2:\n+\t  return \\\"fld1\\\";\n+\t}\n+      abort();\n+\n+    case 3:\n+    case 4:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort();\n+    }\n+}\"\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")])\n+\n+(define_insn \"*movdf_integer\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n+\t(match_operand:DF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && !optimize_size\"\n   \"*\n {\n   switch (which_alternative)\n@@ -1917,20 +1970,65 @@\n   \"\"\n   \"ix86_expand_move (XFmode, operands); DONE;\")\n \n-(define_insn \"*pushxf\"\n+;; Size of pushdf is 3 (for sub) + 2 (for fstp) + memory operand size.\n+;; Size of pushdf using integer insturctions is 3+3*memory operand size\n+;; Pushing using integer instructions is longer except for constants\n+;; and direct memory references.\n+;; (assuming that any given constant is pushed only once, but this ought to be\n+;;  handled elsewhere).\n+\n+(define_insn \"*pushxf_nointeger\"\n+  [(set (match_operand:XF 0 \"push_operand\" \"=<,<,<\")\n+\t(match_operand:XF 1 \"general_operand\" \"f,Fo,*r\"))]\n+  \"optimize_size\"\n+  \"*\n+{\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (12);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+    case 2:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n+}\"\n+  [(set_attr \"type\" \"multi\")])\n+\n+(define_insn \"*pushxf_integer\"\n   [(set (match_operand:XF 0 \"push_operand\" \"=<,<\")\n-\t(match_operand:XF 1 \"register_operand\" \"f,oF*r\"))]\n-  \"\"\n+\t(match_operand:XF 1 \"general_operand\" \"f#r,rFo#f\"))]\n+  \"!optimize_size\"\n   \"*\n {\n-  /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n-  operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n-  operands[2] = stack_pointer_rtx;\n-  operands[3] = GEN_INT (12);\n-  if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n-    return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n-  else\n-    return \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      /* %%% We loose REG_DEAD notes for controling pops if we split late.  */\n+      operands[0] = gen_rtx_MEM (XFmode, stack_pointer_rtx);\n+      operands[2] = stack_pointer_rtx;\n+      operands[3] = GEN_INT (12);\n+      if (find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fstp%z0\\\\t%y0\\\";\n+      else\n+\treturn \\\"sub{l}\\\\t{%3, %2|%2, %3}\\;fst%z0\\\\t%y0\\\";\n+\n+    case 1:\n+      return \\\"#\\\";\n+\n+    default:\n+      abort ();\n+    }\n }\"\n   [(set_attr \"type\" \"multi\")])\n \n@@ -1949,30 +2047,55 @@\n   [(set (reg:SI 7) (plus:SI (reg:SI 7) (const_int -12)))\n    (set (mem:XF (reg:SI 7)) (match_dup 1))])\n \n-(define_split\n-  [(set (match_operand:DF 0 \"push_operand\" \"\")\n-\t(match_operand:DF 1 \"memory_operand\" \"\"))]\n-  \"reload_completed\"\n-  [(set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 2))\n-   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 1))\n-   (set (mem:SI (pre_dec:SI (reg:SI 7))) (match_dup 0))]\n-  \"\n+;; Do not use integer registers when optimizing for size\n+(define_insn \"*movxf_nointeger\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,F*r\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && optimize_size\"\n+  \"*\n {\n-  operands[0] = change_address (operands[1], SImode, NULL_RTX);\n-  operands[1] = adj_offsettable_operand (operands[0], 4);\n-  operands[2] = adj_offsettable_operand (operands[0], 8);\n-  /* Compensate for the fact that we're changing stack offsets in\n-     the middle of this operation.  */\n-  if (reg_mentioned_p (stack_pointer_rtx, operands[1]))\n-    operands[1] = adj_offsettable_operand (operands[1], 4);\n-  if (reg_mentioned_p (stack_pointer_rtx, operands[0]))\n-    operands[0] = adj_offsettable_operand (operands[0], 8);\n-}\")\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      if (REG_P (operands[1])\n+          && find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp\\\\t%y0\\\";\n+      else if (STACK_TOP_P (operands[0]))\n+        return \\\"fld%z1\\\\t%y1\\\";\n+      else\n+        return \\\"fst\\\\t%y0\\\";\n \n-(define_insn \"*movxf_1\"\n-  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f,m,f,*r,o\")\n-\t(match_operand:XF 1 \"general_operand\" \"fm,f,G,*roF,*r\"))]\n-  \"\"\n+    case 1:\n+      /* There is no non-popping store to memory for XFmode.  So if\n+\t we need one, follow the store with a load.  */\n+      if (! find_regno_note (insn, REG_DEAD, REGNO (operands[1])))\n+        return \\\"fstp%z0\\\\t%y0\\;fld%z0\\\\t%y0\\\";\n+      else\n+        return \\\"fstp%z0\\\\t%y0\\\";\n+\n+    case 2:\n+      switch (standard_80387_constant_p (operands[1]))\n+        {\n+        case 1:\n+\t  return \\\"fldz\\\";\n+\tcase 2:\n+\t  return \\\"fld1\\\";\n+\t}\n+      break;\n+\n+    case 3: case 4:\n+      return \\\"#\\\";\n+    }\n+  abort();\n+}\"\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")])\n+\n+(define_insn \"*movxf_integer\"\n+  [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=f#r,m,f#r,r#f,o\")\n+\t(match_operand:XF 1 \"general_operand\" \"fm#r,f#r,G,roF#f,Fr#f\"))]\n+  \"(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && !optimize_size\"\n   \"*\n {\n   switch (which_alternative)\n@@ -2009,14 +2132,19 @@\n     }\n   abort();\n }\"\n-  [(set_attr \"type\" \"fmov\")])\n+  [(set_attr \"type\" \"fmov,fmov,fmov,multi,multi\")])\n \n (define_split\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:XF 1 \"general_operand\" \"\"))]\n   \"reload_completed\n-   && ((REG_P (operands[0]) && ! FP_REGNO_P (REGNO (operands[0])))\n-        || (REG_P (operands[1]) && ! FP_REGNO_P (REGNO (operands[1]))))\"\n+   && (GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)\n+   && ! (FP_REG_P (operands[0]) || \n+\t (GET_CODE (operands[0]) == SUBREG\n+\t  && FP_REG_P (SUBREG_REG (operands[0]))))\n+   && ! (FP_REG_P (operands[1]) || \n+\t (GET_CODE (operands[1]) == SUBREG\n+\t  && FP_REG_P (SUBREG_REG (operands[1]))))\"\n   [(set (match_dup 2) (match_dup 5))\n    (set (match_dup 3) (match_dup 6))\n    (set (match_dup 4) (match_dup 7))]"}]}