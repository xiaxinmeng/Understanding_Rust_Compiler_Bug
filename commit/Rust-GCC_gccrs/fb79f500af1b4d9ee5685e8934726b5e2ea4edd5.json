{"sha": "fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmI3OWY1MDBhZjFiNGQ5ZWU1Njg1ZTg5MzQ3MjZiNWUyZWE0ZWRkNQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-06-22T20:39:25Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-06-22T20:39:25Z"}, "message": "re PR libgomp/49490 (suboptimal load balancing in loops)\n\n\tPR libgomp/49490\n\t* omp-low.c (expand_omp_for_static_nochunk): Only\n\tuse n ceil/ nthreads size for the first\n\tn % nthreads threads in the team instead of\n\tall threads except for the last few ones which\n\tget less work or none at all.\n\n\t* iter.c (gomp_iter_static_next): For chunk size 0\n\tonly use n ceil/ nthreads size for the first\n\tn % nthreads threads in the team instead of\n\tall threads except for the last few ones which\n\tget less work or none at all.\n\t* iter_ull.c (gomp_iter_ull_static_next): Likewise.\n\t* env.c (parse_schedule): If OMP_SCHEDULE doesn't have\n\tchunk argument, set run_sched_modifier to 0 for static\n\tresp. 1 for other kinds.  If chunk argument is 0\n\tand not static, set value to 1.\n\nFrom-SVN: r175315", "tree": {"sha": "c2cc34ab7a462c76b41fcd457b365ba285e84685", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c2cc34ab7a462c76b41fcd457b365ba285e84685"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4fb489e7968448aaa9321d863660530a81d06f4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fb489e7968448aaa9321d863660530a81d06f4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fb489e7968448aaa9321d863660530a81d06f4c"}], "stats": {"total": 125, "additions": 96, "deletions": 29}, "files": [{"sha": "d4ee63b825df15852eb0c93d1a5cb7be675460be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -1,5 +1,12 @@\n 2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR libgomp/49490\n+\t* omp-low.c (expand_omp_for_static_nochunk): Only\n+\tuse n ceil/ nthreads size for the first\n+\tn % nthreads threads in the team instead of\n+\tall threads except for the last few ones which\n+\tget less work or none at all.\n+\n \tPR debug/49496\n \t* tree-vect-patterns.c (vect_recog_widen_mult_pattern): Ignore debug\n \tuses."}, {"sha": "05646bf8833ceb521d799be6c891b4a631d2bb50", "filename": "gcc/omp-low.c", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -3,7 +3,7 @@\n    marshalling to implement data sharing and copying clauses.\n    Contributed by Diego Novillo <dnovillo@redhat.com>\n \n-   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+   Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -4108,9 +4108,14 @@ expand_omp_for_generic (struct omp_region *region,\n \telse\n \t  n = (adj + N2 - N1) / STEP;\n \tq = n / nthreads;\n-\tq += (q * nthreads != n);\n-\ts0 = q * threadid;\n-\te0 = min(s0 + q, n);\n+\ttt = n % nthreads;\n+\tif (threadid < tt) goto L3; else goto L4;\n+    L3:\n+\ttt = 0;\n+\tq = q + 1;\n+    L4:\n+\ts0 = q * threadid + tt;\n+\te0 = s0 + q;\n \tV = s0 * STEP + N1;\n \tif (s0 >= e0) goto L2; else goto L0;\n     L0:\n@@ -4126,12 +4131,14 @@ static void\n expand_omp_for_static_nochunk (struct omp_region *region,\n \t\t\t       struct omp_for_data *fd)\n {\n-  tree n, q, s0, e0, e, t, nthreads, threadid;\n+  tree n, q, s0, e0, e, t, tt, nthreads, threadid;\n   tree type, itype, vmain, vback;\n-  basic_block entry_bb, exit_bb, seq_start_bb, body_bb, cont_bb;\n+  basic_block entry_bb, second_bb, third_bb, exit_bb, seq_start_bb;\n+  basic_block body_bb, cont_bb;\n   basic_block fin_bb;\n   gimple_stmt_iterator gsi;\n   gimple stmt;\n+  edge ep;\n \n   itype = type = TREE_TYPE (fd->loop.v);\n   if (POINTER_TYPE_P (type))\n@@ -4185,19 +4192,39 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   t = fold_convert (itype, t);\n   n = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n+  q = create_tmp_var (itype, \"q\");\n   t = fold_build2 (TRUNC_DIV_EXPR, itype, n, nthreads);\n-  q = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n+  t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE, true, GSI_SAME_STMT);\n+  gsi_insert_before (&gsi, gimple_build_assign (q, t), GSI_SAME_STMT);\n+\n+  tt = create_tmp_var (itype, \"tt\");\n+  t = fold_build2 (TRUNC_MOD_EXPR, itype, n, nthreads);\n+  t = force_gimple_operand_gsi (&gsi, t, false, NULL_TREE, true, GSI_SAME_STMT);\n+  gsi_insert_before (&gsi, gimple_build_assign (tt, t), GSI_SAME_STMT);\n \n-  t = fold_build2 (MULT_EXPR, itype, q, nthreads);\n-  t = fold_build2 (NE_EXPR, itype, t, n);\n-  t = fold_build2 (PLUS_EXPR, itype, q, t);\n-  q = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n+  t = build2 (LT_EXPR, boolean_type_node, threadid, tt);\n+  stmt = gimple_build_cond_empty (t);\n+  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\n+  second_bb = split_block (entry_bb, stmt)->dest;\n+  gsi = gsi_last_bb (second_bb);\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n+\n+  gsi_insert_before (&gsi, gimple_build_assign (tt, build_int_cst (itype, 0)),\n+\t\t     GSI_SAME_STMT);\n+  stmt = gimple_build_assign_with_ops (PLUS_EXPR, q, q,\n+\t\t\t\t       build_int_cst (itype, 1));\n+  gsi_insert_before (&gsi, stmt, GSI_SAME_STMT);\n+\n+  third_bb = split_block (second_bb, stmt)->dest;\n+  gsi = gsi_last_bb (third_bb);\n+  gcc_assert (gimple_code (gsi_stmt (gsi)) == GIMPLE_OMP_FOR);\n \n   t = build2 (MULT_EXPR, itype, q, threadid);\n+  t = build2 (PLUS_EXPR, itype, t, tt);\n   s0 = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n   t = fold_build2 (PLUS_EXPR, itype, s0, q);\n-  t = fold_build2 (MIN_EXPR, itype, t, n);\n   e0 = force_gimple_operand_gsi (&gsi, t, true, NULL_TREE, true, GSI_SAME_STMT);\n \n   t = build2 (GE_EXPR, boolean_type_node, s0, e0);\n@@ -4263,13 +4290,20 @@ expand_omp_for_static_nochunk (struct omp_region *region,\n   gsi_remove (&gsi, true);\n \n   /* Connect all the blocks.  */\n-  find_edge (entry_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n-  find_edge (entry_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n+  ep = make_edge (entry_bb, third_bb, EDGE_FALSE_VALUE);\n+  ep->probability = REG_BR_PROB_BASE / 4 * 3;\n+  ep = find_edge (entry_bb, second_bb);\n+  ep->flags = EDGE_TRUE_VALUE;\n+  ep->probability = REG_BR_PROB_BASE / 4;\n+  find_edge (third_bb, seq_start_bb)->flags = EDGE_FALSE_VALUE;\n+  find_edge (third_bb, fin_bb)->flags = EDGE_TRUE_VALUE;\n \n   find_edge (cont_bb, body_bb)->flags = EDGE_TRUE_VALUE;\n   find_edge (cont_bb, fin_bb)->flags = EDGE_FALSE_VALUE;\n \n-  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, second_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, third_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, seq_start_bb, third_bb);\n   set_immediate_dominator (CDI_DOMINATORS, body_bb,\n \t\t\t   recompute_dominator (CDI_DOMINATORS, body_bb));\n   set_immediate_dominator (CDI_DOMINATORS, fin_bb,"}, {"sha": "1d93273b919042e3797e634353363064e7d3afa6", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -1,3 +1,17 @@\n+2011-06-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/49490\n+\t* iter.c (gomp_iter_static_next): For chunk size 0\n+\tonly use n ceil/ nthreads size for the first\n+\tn % nthreads threads in the team instead of\n+\tall threads except for the last few ones which\n+\tget less work or none at all.\n+\t* iter_ull.c (gomp_iter_ull_static_next): Likewise.\n+\t* env.c (parse_schedule): If OMP_SCHEDULE doesn't have\n+\tchunk argument, set run_sched_modifier to 0 for static\n+\tresp. 1 for other kinds.  If chunk argument is 0\n+\tand not static, set value to 1.\n+\n 2011-05-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/49043"}, {"sha": "0ca9a1c9e0060433e9d19b245a95870a6c7f1416", "filename": "libgomp/env.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010\n+/* Copyright (C) 2005, 2006, 2007, 2008, 2009, 2010, 2011\n    Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n@@ -108,7 +108,11 @@ parse_schedule (void)\n   while (isspace ((unsigned char) *env))\n     ++env;\n   if (*env == '\\0')\n-    return;\n+    {\n+      gomp_global_icv.run_sched_modifier\n+\t= gomp_global_icv.run_sched_var != GFS_STATIC;\n+      return;\n+    }\n   if (*env++ != ',')\n     goto unknown;\n   while (isspace ((unsigned char) *env))\n@@ -129,6 +133,8 @@ parse_schedule (void)\n   if ((int)value != value)\n     goto invalid;\n \n+  if (value == 0 && gomp_global_icv.run_sched_var != GFS_STATIC)\n+    value = 1;\n   gomp_global_icv.run_sched_modifier = value;\n   return;\n "}, {"sha": "cd9484a1ea4cb6593bb93aa54f9db6c5ce8caf51", "filename": "libgomp/iter.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fiter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fiter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fiter.c?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -59,7 +59,7 @@ gomp_iter_static_next (long *pstart, long *pend)\n      trip through the outer loop.  */\n   if (ws->chunk_size == 0)\n     {\n-      unsigned long n, q, i;\n+      unsigned long n, q, i, t;\n       unsigned long s0, e0;\n       long s, e;\n \n@@ -74,11 +74,14 @@ gomp_iter_static_next (long *pstart, long *pend)\n       /* Compute the \"zero-based\" start and end points.  That is, as\n          if the loop began at zero and incremented by one.  */\n       q = n / nthreads;\n-      q += (q * nthreads != n);\n-      s0 = q * i;\n+      t = n % nthreads;\n+      if (i < t)\n+\t{\n+\t  t = 0;\n+\t  q++;\n+\t}\n+      s0 = q * i + t;\n       e0 = s0 + q;\n-      if (e0 > n)\n-        e0 = n;\n \n       /* Notice when no iterations allocated for this thread.  */\n       if (s0 >= e0)"}, {"sha": "a393920b55e48f84a9b48a7522fc0177225e0264", "filename": "libgomp/iter_ull.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fiter_ull.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fb79f500af1b4d9ee5685e8934726b5e2ea4edd5/libgomp%2Fiter_ull.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fiter_ull.c?ref=fb79f500af1b4d9ee5685e8934726b5e2ea4edd5", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 2005, 2008, 2009 Free Software Foundation, Inc.\n+/* Copyright (C) 2005, 2008, 2009, 2011 Free Software Foundation, Inc.\n    Contributed by Richard Henderson <rth@redhat.com>.\n \n    This file is part of the GNU OpenMP Library (libgomp).\n@@ -60,7 +60,7 @@ gomp_iter_ull_static_next (gomp_ull *pstart, gomp_ull *pend)\n      trip through the outer loop.  */\n   if (ws->chunk_size_ull == 0)\n     {\n-      gomp_ull n, q, i, s0, e0, s, e;\n+      gomp_ull n, q, i, t, s0, e0, s, e;\n \n       if (thr->ts.static_trip > 0)\n \treturn 1;\n@@ -75,11 +75,14 @@ gomp_iter_ull_static_next (gomp_ull *pstart, gomp_ull *pend)\n       /* Compute the \"zero-based\" start and end points.  That is, as\n \t if the loop began at zero and incremented by one.  */\n       q = n / nthreads;\n-      q += (q * nthreads != n);\n-      s0 = q * i;\n+      t = n % nthreads;\n+      if (i < t)\n+\t{\n+\t  t = 0;\n+\t  q++;\n+\t}\n+      s0 = q * i + t;\n       e0 = s0 + q;\n-      if (e0 > n)\n-\te0 = n;\n \n       /* Notice when no iterations allocated for this thread.  */\n       if (s0 >= e0)"}]}