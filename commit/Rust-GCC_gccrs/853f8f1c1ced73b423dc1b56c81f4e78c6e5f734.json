{"sha": "853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUzZjhmMWMxY2VkNzNiNDIzZGMxYjU2YzgxZjRlNzhjNmU1ZjczNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-02T15:46:26Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-02T15:46:26Z"}, "message": "optabs.c (add_equal_note): Do not create self-referencing REG_EQUAL notes.\n\n\t* optabs.c (add_equal_note): Do not create self-referencing REG_EQUAL\n\tnotes.\n\t* fwprop.c (forward_propagate_and_simplify): Likewise.\n\nFrom-SVN: r194054", "tree": {"sha": "413cf367e7b936822c65e09dddbfcca70f28aceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/413cf367e7b936822c65e09dddbfcca70f28aceb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/comments", "author": null, "committer": null, "parents": [{"sha": "fa967f341ce38053b0baf106454139e29786d061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa967f341ce38053b0baf106454139e29786d061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa967f341ce38053b0baf106454139e29786d061"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "bada8f2acd19c8647c1538013438c41f0277b6fc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "patch": "@@ -1,3 +1,9 @@\n+2012-12-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* optabs.c (add_equal_note): Do not create self-referencing REG_EQUAL\n+\tnotes.\n+\t* fwprop.c (forward_propagate_and_simplify): Likewise.\n+\n 2012-12-02  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* function.h (struct rtl_data): Remove epilogue_delay_list."}, {"sha": "35c82d7ed7f1694ea5a5af74a9ee8c3a45c6ccf4", "filename": "gcc/fwprop.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "patch": "@@ -1315,9 +1315,12 @@ forward_propagate_and_simplify (df_ref use, rtx def_insn, rtx def_set)\n       /* Do not replace an existing REG_EQUAL note if the insn is not\n \t recognized.  Either we're already replacing in the note, or we'll\n \t separately try plugging the definition in the note and simplifying.\n-\t And only install a REQ_EQUAL note when the destination is a REG,\n-\t as the note would be invalid otherwise.  */\n-      set_reg_equal = (note == NULL_RTX && REG_P (SET_DEST (use_set)));\n+\t And only install a REQ_EQUAL note when the destination is a REG\n+\t that isn't mentioned in USE_SET, as the note would be invalid\n+\t otherwise.  */\n+      set_reg_equal = (note == NULL_RTX && REG_P (SET_DEST (use_set))\n+\t\t       && ! reg_mentioned_p (SET_DEST (use_set),\n+\t\t\t\t\t     SET_SRC (use_set)));\n     }\n \n   if (GET_MODE (*loc) == VOIDmode)"}, {"sha": "d59a1eae3c199f74f81d3513618e1fe3382005e0", "filename": "gcc/optabs.c", "status": "modified", "additions": 10, "deletions": 19, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/853f8f1c1ced73b423dc1b56c81f4e78c6e5f734/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=853f8f1c1ced73b423dc1b56c81f4e78c6e5f734", "patch": "@@ -170,14 +170,14 @@ optab_libfunc (optab optab, enum machine_mode mode)\n \n    If the last insn does not set TARGET, don't do anything, but return 1.\n \n-   If a previous insn sets TARGET and TARGET is one of OP0 or OP1,\n-   don't add the REG_EQUAL note but return 0.  Our caller can then try\n-   again, ensuring that TARGET is not one of the operands.  */\n+   If the last insn or a previous insn sets TARGET and TARGET is one of OP0\n+   or OP1, don't add the REG_EQUAL note but return 0.  Our caller can then\n+   try again, ensuring that TARGET is not one of the operands.  */\n \n static int\n add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n {\n-  rtx last_insn, insn, set;\n+  rtx last_insn, set;\n   rtx note;\n \n   gcc_assert (insns && INSN_P (insns) && NEXT_INSN (insns));\n@@ -192,6 +192,12 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n   if (GET_CODE (target) == ZERO_EXTRACT)\n     return 1;\n \n+  /* If TARGET is in OP0 or OP1, punt.  We'd end up with a note referencing\n+     a value changing in the insn, so the note would be invalid for CSE.  */\n+  if (reg_overlap_mentioned_p (target, op0)\n+      || (op1 && reg_overlap_mentioned_p (target, op1)))\n+    return 0;\n+\n   for (last_insn = insns;\n        NEXT_INSN (last_insn) != NULL_RTX;\n        last_insn = NEXT_INSN (last_insn))\n@@ -207,21 +213,6 @@ add_equal_note (rtx insns, rtx target, enum rtx_code code, rtx op0, rtx op1)\n \t  || ! rtx_equal_p (XEXP (SET_DEST (set), 0), target)))\n     return 1;\n \n-  /* If TARGET is in OP0 or OP1, check if anything in SEQ sets TARGET\n-     besides the last insn.  */\n-  if (reg_overlap_mentioned_p (target, op0)\n-      || (op1 && reg_overlap_mentioned_p (target, op1)))\n-    {\n-      insn = PREV_INSN (last_insn);\n-      while (insn != NULL_RTX)\n-\t{\n-\t  if (reg_set_p (target, insn))\n-\t    return 0;\n-\n-\t  insn = PREV_INSN (insn);\n-\t}\n-    }\n-\n   if (GET_RTX_CLASS (code) == RTX_UNARY)\n     switch (code)\n       {"}]}