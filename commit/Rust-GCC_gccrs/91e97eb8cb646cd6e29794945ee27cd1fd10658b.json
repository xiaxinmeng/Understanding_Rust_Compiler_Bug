{"sha": "91e97eb8cb646cd6e29794945ee27cd1fd10658b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlOTdlYjhjYjY0NmNkNmUyOTc5NDk0NWVlMjdjZDFmZDEwNjU4Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:29:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-05-06T22:29:26Z"}, "message": "(TYPE_HASH): Move definition to top of file.\n\n(make_node): Add support for SET_DEFAULT_TYPE_ATTRIBUTES.\n(build_type_attribute_variant): New function.\n(type_hash_lookup): Check if the attributes match.\n(attribute_list_{equal,contained}): New functions.\n\nFrom-SVN: r7253", "tree": {"sha": "5db5b77f8edc181f58dcf075e29cef02ad4e0d6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5db5b77f8edc181f58dcf075e29cef02ad4e0d6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91e97eb8cb646cd6e29794945ee27cd1fd10658b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e97eb8cb646cd6e29794945ee27cd1fd10658b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91e97eb8cb646cd6e29794945ee27cd1fd10658b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91e97eb8cb646cd6e29794945ee27cd1fd10658b/comments", "author": null, "committer": null, "parents": [{"sha": "660b43c8658a5a87bceb90721115b30381affd22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/660b43c8658a5a87bceb90721115b30381affd22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/660b43c8658a5a87bceb90721115b30381affd22"}], "stats": {"total": 113, "additions": 109, "deletions": 4}, "files": [{"sha": "6e15640f9446359115ac5eff9f5653133a4176b4", "filename": "gcc/tree.c", "status": "modified", "additions": 109, "deletions": 4, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91e97eb8cb646cd6e29794945ee27cd1fd10658b/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91e97eb8cb646cd6e29794945ee27cd1fd10658b/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=91e97eb8cb646cd6e29794945ee27cd1fd10658b", "patch": "@@ -257,6 +257,10 @@ static int next_decl_uid;\n /* Unique id for next type created.  */\n static int next_type_uid = 1;\n \n+/* Here is how primitive or already-canonicalized types' hash\n+   codes are made.  */\n+#define TYPE_HASH(TYPE) ((HOST_WIDE_INT) (TYPE) & 0777777)\n+\n extern char *mode_name[];\n \n void gcc_obstack_init ();\n@@ -999,6 +1003,10 @@ make_node (code)\n       TYPE_ALIGN (t) = 1;\n       TYPE_MAIN_VARIANT (t) = t;\n       TYPE_OBSTACK (t) = obstack;\n+      TYPE_ATTRIBUTES (t) = NULL_TREE;\n+#ifdef SET_DEFAULT_TYPE_ATTRIBUTES\n+      SET_DEFAULT_TYPE_ATTRIBUTES (t);\n+#endif\n       break;\n \n     case 'c':\n@@ -2696,6 +2704,65 @@ build_block (vars, tags, subblocks, supercontext, chain)\n   return block;\n }\n \f\n+/* Return a type like TTYPE except that its TYPE_ATTRIBUTE\n+   is ATTRIBUTE.\n+\n+   Such modified types already made are recorded so that duplicates\n+   are not made. */\n+\n+tree\n+build_type_attribute_variant (ttype, attribute)\n+     tree ttype, attribute;\n+{\n+  if ( ! attribute_list_equal (TYPE_ATTRIBUTES (ttype), attribute))\n+    {\n+      register int hashcode;\n+      register struct obstack *ambient_obstack = current_obstack;\n+      tree ntype;\n+\n+      if (ambient_obstack != &permanent_obstack)\n+        current_obstack = TYPE_OBSTACK (ttype);\n+\n+      ntype = copy_node (ttype);\n+      current_obstack = ambient_obstack;\n+\n+      TYPE_POINTER_TO (ntype) = 0;\n+      TYPE_REFERENCE_TO (ntype) = 0;\n+      TYPE_ATTRIBUTES (ntype) = attribute;\n+\n+      /* Create a new main variant of TYPE.  */\n+      TYPE_MAIN_VARIANT (ntype) = ntype;\n+      TYPE_NEXT_VARIANT (ntype) = 0;\n+      TYPE_READONLY (ntype) = TYPE_VOLATILE (ntype) = 0;\n+\n+      hashcode = TYPE_HASH (TREE_CODE (ntype))\n+\t\t + TYPE_HASH (TREE_TYPE (ntype))\n+\t\t + type_hash_list (attribute);\n+\n+      switch (TREE_CODE (ntype))\n+        {\n+\t  case FUNCTION_TYPE:\n+\t    hashcode += TYPE_HASH (TYPE_ARG_TYPES (ntype));\n+\t    break;\n+\t  case ARRAY_TYPE:\n+\t    hashcode += TYPE_HASH (TYPE_DOMAIN (ntype));\n+\t    break;\n+\t  case INTEGER_TYPE:\n+\t    hashcode += TYPE_HASH (TYPE_MAX_VALUE (ntype));\n+\t    break;\n+\t  case REAL_TYPE:\n+\t    hashcode += TYPE_HASH (TYPE_PRECISION (ntype));\n+\t    break;\n+        }\n+\n+      ntype = type_hash_canon (hashcode, ntype);\n+      ttype = build_type_variant (ntype, TYPE_READONLY (ttype),\n+\t\t\t\t  TYPE_VOLATILE (ttype));\n+    }\n+\n+  return ttype;\n+}\n+\f\n /* Return a type like TYPE except that its TYPE_READONLY is CONSTP\n    and its TYPE_VOLATILE is VOLATILEP.\n \n@@ -2818,10 +2885,6 @@ struct type_hash\n #define TYPE_HASH_SIZE 59\n struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n \n-/* Here is how primitive or already-canonicalized types' hash\n-   codes are made.  */\n-#define TYPE_HASH(TYPE) ((HOST_WIDE_INT) (TYPE) & 0777777)\n-\n /* Compute a hash code for a list of types (chain of TREE_LIST nodes\n    with types in the TREE_VALUE slots), by adding the hash codes\n    of the individual types.  */\n@@ -2850,6 +2913,8 @@ type_hash_lookup (hashcode, type)\n     if (h->hashcode == hashcode\n \t&& TREE_CODE (h->type) == TREE_CODE (type)\n \t&& TREE_TYPE (h->type) == TREE_TYPE (type)\n+        && attribute_list_equal (TYPE_ATTRIBUTES (h->type),\n+\t\t\t\t   TYPE_ATTRIBUTES (type))\n \t&& (TYPE_MAX_VALUE (h->type) == TYPE_MAX_VALUE (type)\n \t    || tree_int_cst_equal (TYPE_MAX_VALUE (h->type),\n \t\t\t\t   TYPE_MAX_VALUE (type)))\n@@ -2925,6 +2990,46 @@ type_hash_canon (hashcode, type)\n   return type;\n }\n \n+/* Given two lists of attributes, return true if list l2 is\n+   equivalent to l1.  */\n+\n+int\n+attribute_list_equal (l1, l2)\n+     tree l1, l2;\n+{\n+   return attribute_list_contained (l1, l2)\n+\t  && attribute_list_contained (l2, l1);\n+}\n+\n+/* Given two lists of attributes, return true if list l2 is\n+   completely contained within l1.  */\n+\n+int\n+attribute_list_contained (l1, l2)\n+     tree l1, l2;\n+{\n+  register tree t1, t2;\n+\n+  /* First check the obvious, maybe the lists are identical.  */\n+  if (l1 == l2)\n+     return 1;\n+\n+  /* Then check the obvious, maybe the lists are similar.  */\n+  for (t1 = l1, t2 = l2;\n+       t1 && t2\n+        && TREE_VALUE (t1) == TREE_VALUE (t2);\n+       t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2));\n+\n+  /* Maybe the lists are equal.  */\n+  if (t1 == 0 && t2 == 0)\n+     return 1;\n+\n+  for (; t2; t2 = TREE_CHAIN (t2))\n+     if (!value_member (l1, t2))\n+\treturn 0;\n+  return 1;\n+}\n+\n /* Given two lists of types\n    (chains of TREE_LIST nodes with types in the TREE_VALUE slots)\n    return 1 if the lists contain the same types in the same order."}]}