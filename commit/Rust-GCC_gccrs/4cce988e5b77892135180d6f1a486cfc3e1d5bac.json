{"sha": "4cce988e5b77892135180d6f1a486cfc3e1d5bac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjZTk4OGU1Yjc3ODkyMTM1MTgwZDZmMWE0ODZjZmMzZTFkNWJhYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-10-24T07:45:26Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-10-24T07:45:26Z"}, "message": "cfglayout.c (fixup_reorder_chain): When ensuring that there is at least one insn with a locus corresponding to an...\n\n\t* cfglayout.c (fixup_reorder_chain): When ensuring that there is at\n\tleast one insn with a locus corresponding to an edge's goto_locus,\n\tdisregard non-fallthru edges to the exit block and merge the blocks\n\tcreated for the same goto_locus.\n\nFrom-SVN: r165897", "tree": {"sha": "28e69a6ab8a84a8bba7c04bb6a5015a69b04ea57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e69a6ab8a84a8bba7c04bb6a5015a69b04ea57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cce988e5b77892135180d6f1a486cfc3e1d5bac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cce988e5b77892135180d6f1a486cfc3e1d5bac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cce988e5b77892135180d6f1a486cfc3e1d5bac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cce988e5b77892135180d6f1a486cfc3e1d5bac/comments", "author": null, "committer": null, "parents": [{"sha": "be8cf3b55e32b8bd1eb0672d90f91fc246586178", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8cf3b55e32b8bd1eb0672d90f91fc246586178", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be8cf3b55e32b8bd1eb0672d90f91fc246586178"}], "stats": {"total": 36, "additions": 32, "deletions": 4}, "files": [{"sha": "189f349a4b357dd96604f0a389a3cb486d869660", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cce988e5b77892135180d6f1a486cfc3e1d5bac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cce988e5b77892135180d6f1a486cfc3e1d5bac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cce988e5b77892135180d6f1a486cfc3e1d5bac", "patch": "@@ -1,3 +1,10 @@\n+2010-10-24  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* cfglayout.c (fixup_reorder_chain): When ensuring that there is at\n+\tleast one insn with a locus corresponding to an edge's goto_locus,\n+\tdisregard non-fallthru edges to the exit block and merge the blocks\n+\tcreated for the same goto_locus.\n+\n 2010-10-23  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.c (n_switches_alloc_debug_check): New."}, {"sha": "d599b36e70a38c40a7f4c13b157a9b3b90611358", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cce988e5b77892135180d6f1a486cfc3e1d5bac/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cce988e5b77892135180d6f1a486cfc3e1d5bac/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=4cce988e5b77892135180d6f1a486cfc3e1d5bac", "patch": "@@ -940,7 +940,9 @@ fixup_reorder_chain (void)\n         FOR_EACH_EDGE (e, ei, bb->succs)\n \t  if (e->goto_locus && !(e->flags & EDGE_ABNORMAL))\n \t    {\n-\t      basic_block nb;\n+\t      edge e2;\n+\t      edge_iterator ei2;\n+\t      basic_block dest, nb;\n \t      rtx end;\n \n \t      insn = BB_END (e->src);\n@@ -957,10 +959,17 @@ fixup_reorder_chain (void)\n \t\t  INSN_LOCATOR (BB_END (e->src)) = e->goto_locus;\n \t\t  continue;\n \t\t}\n-\t      if (e->dest != EXIT_BLOCK_PTR)\n+\t      dest = e->dest;\n+\t      if (dest == EXIT_BLOCK_PTR)\n \t\t{\n-\t\t  insn = BB_HEAD (e->dest);\n-\t\t  end = NEXT_INSN (BB_END (e->dest));\n+\t\t  /* Non-fallthru edges to the exit block cannot be split.  */\n+\t\t  if (!(e->flags & EDGE_FALLTHRU))\n+\t\t    continue;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  insn = BB_HEAD (dest);\n+\t\t  end = NEXT_INSN (BB_END (dest));\n \t\t  while (insn != end && !NONDEBUG_INSN_P (insn))\n \t\t    insn = NEXT_INSN (insn);\n \t\t  if (insn != end && INSN_LOCATOR (insn)\n@@ -972,6 +981,18 @@ fixup_reorder_chain (void)\n \t\tBB_END (nb) = emit_insn_after_noloc (gen_nop (), BB_END (nb),\n \t\t\t\t\t\t     nb);\n \t      INSN_LOCATOR (BB_END (nb)) = e->goto_locus;\n+\n+\t      /* If there are other incoming edges to the destination block\n+\t\t with the same goto locus, redirect them to the new block as\n+\t\t well, this can prevent other such blocks from being created\n+\t\t in subsequent iterations of the loop.  */\n+\t      for (ei2 = ei_start (dest->preds); (e2 = ei_safe_edge (ei2)); )\n+\t\tif (e2->goto_locus\n+\t\t    && !(e2->flags & (EDGE_ABNORMAL | EDGE_FALLTHRU))\n+\t\t    && locator_eq (e->goto_locus, e2->goto_locus))\n+\t\t  redirect_edge_and_branch (e2, nb);\n+\t\telse\n+\t\t  ei_next (&ei2);\n \t    }\n       }\n }"}]}