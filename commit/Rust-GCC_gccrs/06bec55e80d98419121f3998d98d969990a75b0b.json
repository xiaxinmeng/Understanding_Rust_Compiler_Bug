{"sha": "06bec55e80d98419121f3998d98d969990a75b0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZiZWM1NWU4MGQ5ODQxOTEyMWYzOTk4ZDk4ZDk2OTk5MGE3NWIwYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-14T15:14:47Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-10-14T15:29:36Z"}, "message": "i386: Improve chaining of _{addcarry,subborrow}_u{32,64} [PR97387]\n\nThese builtins have two known issues and this patch fixes one of them.\n\nOne issue is that the builtins effectively return two results and\nthey make the destination addressable until expansion, which means\na stack slot is allocated for them and e.g. with -fstack-protector*\nDSE isn't able to optimize that away.  I think for that we want to use\nthe technique of returning complex value; the patch doesn't handle that\nthough.  See PR93990 for that.\n\nThe other problem is optimization of successive uses of the builtin\ne.g. for arbitrary precision arithmetic additions/subtractions.\nAs shown PR93990, combine is able to optimize the case when the first\nargument to these builtins is 0 (the first instance when several are used\ntogether), and also the last one if the last one ignores its result (i.e.\nthe carry/borrow is dead and thrown away in that case).\nAs shown in this PR, combiner refuses to optimize the rest, where it sees:\n(insn 10 9 11 2 (set (reg:QI 88 [ _31 ])\n        (ltu:QI (reg:CCC 17 flags)\n            (const_int 0 [0]))) \"include/adxintrin.h\":69:10 785 {*setcc_qi}\n     (expr_list:REG_DEAD (reg:CCC 17 flags)\n        (nil)))\n- set pseudo 88 to CF from flags, then some uninteresting insns that\ndon't modify flags, and finally:\n(insn 17 15 18 2 (parallel [\n            (set (reg:CCC 17 flags)\n                (compare:CCC (plus:QI (reg:QI 88 [ _31 ])\n                        (const_int -1 [0xffffffffffffffff]))\n                    (reg:QI 88 [ _31 ])))\n            (clobber (scratch:QI))\n        ]) \"include/adxintrin.h\":69:10 350 {*addqi3_cconly_overflow_1}\n     (expr_list:REG_DEAD (reg:QI 88 [ _31 ])\n        (nil)))\nto set CF in flags back to what we saved earlier.  The combiner just punts\ntrying to combine the 10, 17 and following addcarrydi (etc.) instruction,\nbecause\n  if (i1 && !can_combine_p (i1, i3, i0, NULL, i2, NULL, &i1dest, &i1src))\n    {\n      if (dump_file && (dump_flags & TDF_DETAILS))\n        fprintf (dump_file, \"Can't combine i1 into i3\\n\");\n      undo_all ();\n      return 0;\n    }\nfails - the 3 insns aren't all adjacent and\n      || (! all_adjacent\n          && (((!MEM_P (src)\n                || ! find_reg_note (insn, REG_EQUIV, src))\n               && modified_between_p (src, insn, i3))\nsrc (flags hard register) is modified between the first and third insn - in\nthe second insn.\n\nThe following patch optimizes this by optimizing just the two insns,\n10 and 17 above, i.e. save CF into pseudo, set CF from that pseudo, into\na nop.  The new define_insn_and_split matches how combine simplifies those\ntwo together (except without the ix86_cc_mode change it was choosing CCmode\nfor the destination instead of CCCmode, so had to change that function too,\nand also adjust costs so that combiner understand it is beneficial).\n\nWith this, all the testcases are optimized, so that the:\n        setc    %dl\n...\n        addb    $-1, %dl\ninsns in between the ad[dc][lq] or s[ub]b[lq] instructions are all optimized\naway (sure, if something would clobber flags in between they wouldn't, but\nthere is nothing that can be done about that).\n\n2020-10-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR target/97387\n\t* config/i386/i386.md (CC_CCC): New mode iterator.\n\t(*setcc_qi_addqi3_cconly_overflow_1_<mode>): New\n\tdefine_insn_and_split.\n\t* config/i386/i386.c (ix86_cc_mode): Return CCCmode\n\tfor *setcc_qi_addqi3_cconly_overflow_1_<mode> pattern operands.\n\t(ix86_rtx_costs): Return true and *total = 0;\n\tfor *setcc_qi_addqi3_cconly_overflow_1_<mode> pattern.  Use op0 and\n\top1 temporaries to simplify COMPARE checks.\n\n\t* gcc.target/i386/pr97387-1.c: New test.\n\t* gcc.target/i386/pr97387-2.c: New test.", "tree": {"sha": "29ef374a6458cfb84459cf028daa2a26f73362f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29ef374a6458cfb84459cf028daa2a26f73362f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06bec55e80d98419121f3998d98d969990a75b0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bec55e80d98419121f3998d98d969990a75b0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06bec55e80d98419121f3998d98d969990a75b0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06bec55e80d98419121f3998d98d969990a75b0b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b9c09a78b048328e41419e6b941cf0207bfd6bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b9c09a78b048328e41419e6b941cf0207bfd6bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b9c09a78b048328e41419e6b941cf0207bfd6bc"}], "stats": {"total": 144, "additions": 132, "deletions": 12}, "files": [{"sha": "54c2cdaf060c683d4742eab22d495b2bdf7371bb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 56, "deletions": 12, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=06bec55e80d98419121f3998d98d969990a75b0b", "patch": "@@ -15131,11 +15131,32 @@ ix86_cc_mode (enum rtx_code code, rtx op0, rtx op1)\n       /* Codes needing carry flag.  */\n     case GEU:\t\t\t/* CF=0 */\n     case LTU:\t\t\t/* CF=1 */\n+      rtx geu;\n       /* Detect overflow checks.  They need just the carry flag.  */\n       if (GET_CODE (op0) == PLUS\n \t  && (rtx_equal_p (op1, XEXP (op0, 0))\n \t      || rtx_equal_p (op1, XEXP (op0, 1))))\n \treturn CCCmode;\n+      /* Similarly for *setcc_qi_addqi3_cconly_overflow_1_* patterns.\n+\t Match LTU of op0\n+\t (neg:QI (geu:QI (reg:CC_CCC FLAGS_REG) (const_int 0)))\n+\t and op1\n+\t (ltu:QI (reg:CC_CCC FLAGS_REG) (const_int 0))\n+\t where CC_CCC is either CC or CCC.  */\n+      else if (code == LTU\n+\t       && GET_CODE (op0) == NEG\n+\t       && GET_CODE (geu = XEXP (op0, 0)) == GEU\n+\t       && REG_P (XEXP (geu, 0))\n+\t       && (GET_MODE (XEXP (geu, 0)) == CCCmode\n+\t\t   || GET_MODE (XEXP (geu, 0)) == CCmode)\n+\t       && REGNO (XEXP (geu, 0)) == FLAGS_REG\n+\t       && XEXP (geu, 1) == const0_rtx\n+\t       && GET_CODE (op1) == LTU\n+\t       && REG_P (XEXP (op1, 0))\n+\t       && GET_MODE (XEXP (op1, 0)) == GET_MODE (XEXP (geu, 0))\n+\t       && REGNO (XEXP (op1, 0)) == FLAGS_REG\n+\t       && XEXP (op1, 1) == const0_rtx)\n+\treturn CCCmode;\n       else\n \treturn CCmode;\n     case GTU:\t\t\t/* CF=0 & ZF=0 */\n@@ -19749,33 +19770,56 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       return false;\n \n     case COMPARE:\n-      if (GET_CODE (XEXP (x, 0)) == ZERO_EXTRACT\n-\t  && XEXP (XEXP (x, 0), 1) == const1_rtx\n-\t  && CONST_INT_P (XEXP (XEXP (x, 0), 2))\n-\t  && XEXP (x, 1) == const0_rtx)\n+      rtx op0, op1;\n+      op0 = XEXP (x, 0);\n+      op1 = XEXP (x, 1);\n+      if (GET_CODE (op0) == ZERO_EXTRACT\n+\t  && XEXP (op0, 1) == const1_rtx\n+\t  && CONST_INT_P (XEXP (op0, 2))\n+\t  && op1 == const0_rtx)\n \t{\n \t  /* This kind of construct is implemented using test[bwl].\n \t     Treat it as if we had an AND.  */\n-\t  mode = GET_MODE (XEXP (XEXP (x, 0), 0));\n+\t  mode = GET_MODE (XEXP (op0, 0));\n \t  *total = (cost->add\n-\t\t    + rtx_cost (XEXP (XEXP (x, 0), 0), mode, outer_code,\n+\t\t    + rtx_cost (XEXP (op0, 0), mode, outer_code,\n \t\t\t\topno, speed)\n \t\t    + rtx_cost (const1_rtx, mode, outer_code, opno, speed));\n \t  return true;\n \t}\n \n-      if (GET_CODE (XEXP (x, 0)) == PLUS\n-\t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1)))\n+      if (GET_CODE (op0) == PLUS && rtx_equal_p (XEXP (op0, 0), op1))\n \t{\n \t  /* This is an overflow detection, count it as a normal compare.  */\n-\t  *total = rtx_cost (XEXP (x, 0), GET_MODE (XEXP (x, 0)),\n-\t\t\t     COMPARE, 0, speed);\n+\t  *total = rtx_cost (op0, GET_MODE (op0), COMPARE, 0, speed);\n+\t  return true;\n+\t}\n+\n+      rtx geu;\n+      /* Match x\n+\t (compare:CCC (neg:QI (geu:QI (reg:CC_CCC FLAGS_REG) (const_int 0)))\n+\t\t      (ltu:QI (reg:CC_CCC FLAGS_REG) (const_int 0)))  */\n+      if (mode == CCCmode\n+\t  && GET_CODE (op0) == NEG\n+\t  && GET_CODE (geu = XEXP (op0, 0)) == GEU\n+\t  && REG_P (XEXP (geu, 0))\n+\t  && (GET_MODE (XEXP (geu, 0)) == CCCmode\n+\t      || GET_MODE (XEXP (geu, 0)) == CCmode)\n+\t  && REGNO (XEXP (geu, 0)) == FLAGS_REG\n+\t  && XEXP (geu, 1) == const0_rtx\n+\t  && GET_CODE (op1) == LTU\n+\t  && REG_P (XEXP (op1, 0))\n+\t  && GET_MODE (XEXP (op1, 0)) == GET_MODE (XEXP (geu, 0))\n+\t  && REGNO (XEXP (op1, 0)) == FLAGS_REG\n+\t  && XEXP (op1, 1) == const0_rtx)\n+\t{\n+\t  /* This is *setcc_qi_addqi3_cconly_overflow_1_* patterns, a nop.  */\n+\t  *total = 0;\n \t  return true;\n \t}\n \n       /* The embedded comparison operand is completely free.  */\n-      if (!general_operand (XEXP (x, 0), GET_MODE (XEXP (x, 0)))\n-\t  && XEXP (x, 1) == const0_rtx)\n+      if (!general_operand (op0, GET_MODE (op0)) && op1 == const0_rtx)\n \t*total = 0;\n \n       return false;"}, {"sha": "d1350cf2c6ec306dbb881c8ac29e5cabd7388dcc", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=06bec55e80d98419121f3998d98d969990a75b0b", "patch": "@@ -7039,6 +7039,20 @@\n       (set (match_operand:SWI48 0 \"register_operand\")\n \t   (minus:SWI48 (match_dup 1) (match_dup 2)))])]\n   \"ix86_binary_operator_ok (MINUS, <MODE>mode, operands)\")\n+\n+(define_mode_iterator CC_CCC [CC CCC])\n+\n+;; Pre-reload splitter to optimize\n+;; *setcc_qi followed by *addqi3_cconly_overflow_1 with the same QI\n+;; operand and no intervening flags modifications into nothing.\n+(define_insn_and_split \"*setcc_qi_addqi3_cconly_overflow_1_<mode>\"\n+  [(set (reg:CCC FLAGS_REG)\n+\t(compare:CCC (neg:QI (geu:QI (reg:CC_CCC FLAGS_REG) (const_int 0)))\n+\t\t     (ltu:QI (reg:CC_CCC FLAGS_REG) (const_int 0))))]\n+  \"ix86_pre_reload_split ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(const_int 0)])\n \f\n ;; Overflow setting add instructions\n "}, {"sha": "352092a97f6280fe9bd7fee439ce1ca1afb88219", "filename": "gcc/testsuite/gcc.target/i386/pr97387-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-1.c?ref=06bec55e80d98419121f3998d98d969990a75b0b", "patch": "@@ -0,0 +1,31 @@\n+/* PR target/97387 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fomit-frame-pointer\" } */\n+/* { dg-final { scan-assembler-times \"\\taddl\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tadcl\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tsubl\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tsbbl\\t\" 3 } } */\n+/* { dg-final { scan-assembler-not \"\\tset\\[bc]\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\taddb\\t\" } } */\n+\n+#include <x86intrin.h>\n+\n+void\n+foo (unsigned int a[4], unsigned int b[4])\n+{\n+  unsigned char carry = 0;\n+  carry = _addcarry_u32 (carry, a[0], b[0], &a[0]);\n+  carry = _addcarry_u32 (carry, a[1], b[1], &a[1]);\n+  carry = _addcarry_u32 (carry, a[2], b[2], &a[2]);\n+  _addcarry_u32 (carry, a[3], b[3], &a[3]);\n+}\n+\n+void\n+bar (unsigned int a[4], unsigned int b[4])\n+{\n+  unsigned char carry = 0;\n+  carry = _subborrow_u32 (carry, a[0], b[0], &a[0]);\n+  carry = _subborrow_u32 (carry, a[1], b[1], &a[1]);\n+  carry = _subborrow_u32 (carry, a[2], b[2], &a[2]);\n+  _subborrow_u32 (carry, a[3], b[3], &a[3]);\n+}"}, {"sha": "21d8cce2475c175a3c7862c4e07de49676abd98e", "filename": "gcc/testsuite/gcc.target/i386/pr97387-2.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06bec55e80d98419121f3998d98d969990a75b0b/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr97387-2.c?ref=06bec55e80d98419121f3998d98d969990a75b0b", "patch": "@@ -0,0 +1,31 @@\n+/* PR target/97387 */\n+/* { dg-do compile { target { ! ia32 } } } */\n+/* { dg-options \"-O2 -fomit-frame-pointer\" } */\n+/* { dg-final { scan-assembler-times \"\\taddq\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tadcq\\t\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\tsubq\\t\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\tsbbq\\t\" 3 } } */\n+/* { dg-final { scan-assembler-not \"\\tset\\[bc]\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\taddb\\t\" } } */\n+\n+#include <x86intrin.h>\n+\n+void\n+foo (unsigned long long a[4], unsigned long long b[4])\n+{\n+  unsigned char carry = 0;\n+  carry = _addcarry_u64 (carry, a[0], b[0], &a[0]);\n+  carry = _addcarry_u64 (carry, a[1], b[1], &a[1]);\n+  carry = _addcarry_u64 (carry, a[2], b[2], &a[2]);\n+  _addcarry_u64 (carry, a[3], b[3], &a[3]);\n+}\n+\n+void\n+bar (unsigned long long a[4], unsigned long long b[4])\n+{\n+  unsigned char carry = 0;\n+  carry = _subborrow_u64 (carry, a[0], b[0], &a[0]);\n+  carry = _subborrow_u64 (carry, a[1], b[1], &a[1]);\n+  carry = _subborrow_u64 (carry, a[2], b[2], &a[2]);\n+  _subborrow_u64 (carry, a[3], b[3], &a[3]);\n+}"}]}