{"sha": "8fdc414d439bc7148e079d27220e597b3b602a47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkYzQxNGQ0MzliYzcxNDhlMDc5ZDI3MjIwZTU5N2IzYjYwMmE0Nw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2013-11-05T19:47:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-11-05T19:47:44Z"}, "message": "Makefile.in (OBJS): Add gimple-ssa-isolate-paths.o\n\n\t* Makefile.in (OBJS): Add gimple-ssa-isolate-paths.o\n\t* common.opt (-fisolate-erroneous-paths): Add option and\n\tdocumentation.\n\t* gimple-ssa-isolate-paths.c: New file.\n\t* gimple.c (check_loadstore): New function.\n\t(infer_nonnull_range): Moved into gimple.c from tree-vrp.c\n\tVerify OP is in the argument list and the argument corresponding\n\tto OP is a pointer type.  Use operand_equal_p rather than\n\tpointer equality when testing if OP is on the nonnull list.\n\tUse check_loadstore rather than count_ptr_derefs.  Handle\n\tGIMPLE_RETURN statements.\n\t* tree-vrp.c (infer_nonnull_range): Remove.\n\t* gimple.h (infer_nonnull_range): Declare.\n\t* opts.c (default_options_table): Add\n\t* OPT_fisolate_erroneous_paths.\n\t* passes.def: Add pass_isolate_erroneous_paths.\n\t* timevar.def (TV_ISOLATE_ERRONEOUS_PATHS): New timevar.\n\t* tree-pass.h (make_pass_isolate_erroneous_paths): Declare.\n\t* tree-ssa.c (struct count_ptr_d): Remove.\n\t(count_ptr_derefs, count_uses_and_derefs): Remove.\n\t* tree-ssa.h (count_uses_and_derefs): Remove.\n\n\t* gcc.dg/pr38984.c: Add -fno-isolate-erroneous-paths.\n\t* gcc.dg/tree-ssa/isolate-1.c: New test.\n\t* gcc.dg/tree-ssa/isolate-2.c: New test.\n\t* gcc.dg/tree-ssa/isolate-3.c: New test.\n\t* gcc.dg/tree-ssa/isolate-4.c: New test.\n\nFrom-SVN: r204414", "tree": {"sha": "faf2cabbd865647a82ca5248eea0cae3bb79f870", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/faf2cabbd865647a82ca5248eea0cae3bb79f870"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fdc414d439bc7148e079d27220e597b3b602a47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdc414d439bc7148e079d27220e597b3b602a47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fdc414d439bc7148e079d27220e597b3b602a47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fdc414d439bc7148e079d27220e597b3b602a47/comments", "author": null, "committer": null, "parents": [{"sha": "50fae5a679990a4bba7dc30de21e6d4132d778fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50fae5a679990a4bba7dc30de21e6d4132d778fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50fae5a679990a4bba7dc30de21e6d4132d778fb"}], "stats": {"total": 806, "additions": 656, "deletions": 150}, "files": [{"sha": "b189eda2cafcbec74d6894ae8c4e7a7070a6b7de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -1,3 +1,26 @@\n+2013-11-05  Jeff Law  <law@redhat.com>\n+\n+\t* Makefile.in (OBJS): Add gimple-ssa-isolate-paths.o\n+\t* common.opt (-fisolate-erroneous-paths): Add option and\n+\tdocumentation.\n+\t* gimple-ssa-isolate-paths.c: New file.\n+\t* gimple.c (check_loadstore): New function.\n+\t(infer_nonnull_range): Moved into gimple.c from tree-vrp.c\n+\tVerify OP is in the argument list and the argument corresponding\n+\tto OP is a pointer type.  Use operand_equal_p rather than\n+\tpointer equality when testing if OP is on the nonnull list.\n+\tUse check_loadstore rather than count_ptr_derefs.  Handle\n+\tGIMPLE_RETURN statements.\n+\t* tree-vrp.c (infer_nonnull_range): Remove.\n+\t* gimple.h (infer_nonnull_range): Declare.\n+\t* opts.c (default_options_table): Add OPT_fisolate_erroneous_paths.\n+\t* passes.def: Add pass_isolate_erroneous_paths.\n+\t* timevar.def (TV_ISOLATE_ERRONEOUS_PATHS): New timevar.\n+\t* tree-pass.h (make_pass_isolate_erroneous_paths): Declare.\n+\t* tree-ssa.c (struct count_ptr_d): Remove.\n+\t(count_ptr_derefs, count_uses_and_derefs): Remove.\n+\t* tree-ssa.h (count_uses_and_derefs): Remove.\n+\n 2013-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/58997"}, {"sha": "afb97c9d9d267e3cda7773c109c067cdb0be61a3", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -1235,6 +1235,7 @@ OBJS = \\\n \tgimple-fold.o \\\n \tgimple-low.o \\\n \tgimple-pretty-print.o \\\n+\tgimple-ssa-isolate-paths.o \\\n \tgimple-ssa-strength-reduction.o \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\"}, {"sha": "bda479071c4e3a94bbde40300291b0330bd5dd47", "filename": "gcc/common.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -2109,6 +2109,12 @@ foptimize-strlen\n Common Report Var(flag_optimize_strlen) Optimization\n Enable string length optimizations on trees\n \n+fisolate-erroneous-paths\n+Common Report Var(flag_isolate_erroneous_paths) Optimization\n+Detect paths which trigger erroneous or undefined behaviour.  Isolate those\n+paths from the main control flow and turn the statement with erroneous or\n+undefined behaviour into a trap.\n+\n ftree-loop-distribution\n Common Report Var(flag_tree_loop_distribution) Optimization\n Enable loop distribution on trees"}, {"sha": "4868867308fccfa85730420912d0b527d746a2a7", "filename": "gcc/gimple-ssa-isolate-paths.c", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple-ssa-isolate-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple-ssa-isolate-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-isolate-paths.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -0,0 +1,325 @@\n+/* Detect paths through the CFG which can never be executed in a conforming\n+   program and isolate them.\n+\n+   Copyright (C) 2013\n+   Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"flags.h\"\n+#include \"basic-block.h\"\n+#include \"gimple.h\"\n+#include \"tree-ssa.h\"\n+#include \"tree-ssanames.h\"\n+#include \"gimple-ssa.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"tree-phinodes.h\"\n+#include \"ssa-iterators.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-pass.h\"\n+\n+\n+static bool cfg_altered;\n+\n+/* Insert a trap before SI and remove SI and all statements after SI.  */\n+\n+static void\n+insert_trap_and_remove_trailing_statements (gimple_stmt_iterator *si_p)\n+{\n+  gimple_seq seq = NULL;\n+  gimple stmt = gimple_build_call (builtin_decl_explicit (BUILT_IN_TRAP), 0);\n+  gimple_seq_add_stmt (&seq, stmt);\n+  gsi_insert_before (si_p, seq, GSI_SAME_STMT);\n+\n+  /* Now delete all remaining statements in this block.  */\n+  for (; !gsi_end_p (*si_p);)\n+    {\n+      stmt = gsi_stmt (*si_p);\n+      unlink_stmt_vdef (stmt);\n+      gsi_remove (si_p, true);\n+      release_defs (stmt);\n+    }\n+}\n+\n+/* BB when reached via incoming edge E will exhibit undefined behaviour\n+   at STMT.  Isolate and optimize the path which exhibits undefined\n+   behaviour.\n+\n+   Isolation is simple.  Duplicate BB and redirect E to BB'.\n+\n+   Optimization is simple as well.  Replace STMT in BB' with an\n+   unconditional trap and remove all outgoing edges from BB'.\n+\n+   DUPLICATE is a pre-existing duplicate, use it as BB' if it exists.\n+\n+   Return BB'.  */\n+\n+basic_block\n+isolate_path (basic_block bb, basic_block duplicate, edge e, gimple stmt)\n+{\n+  gimple_stmt_iterator si, si2;\n+  edge_iterator ei;\n+  edge e2;\n+  \n+\n+  /* First duplicate BB if we have not done so already and remove all\n+     the duplicate's outgoing edges as duplicate is going to unconditionally\n+     trap.  Removing the outgoing edges is both an optimization and ensures\n+     we don't need to do any PHI node updates.  */\n+  if (!duplicate)\n+    {\n+      duplicate = duplicate_block (bb, NULL, NULL);\n+      for (ei = ei_start (duplicate->succs); (e2 = ei_safe_edge (ei)); )\n+\tremove_edge (e2);\n+    }\n+\n+  /* Complete the isolation step by redirecting E to reach DUPLICATE.  */\n+  e2 = redirect_edge_and_branch (e, duplicate);\n+  if (e2)\n+    flush_pending_stmts (e2);\n+\n+\n+  /* There may be more than one statement in DUPLICATE which exhibits\n+     undefined behaviour.  Ultimately we want the first such statement in\n+     DUPLCIATE so that we're able to delete as much code as possible.\n+\n+     So each time we discover undefined behaviour in DUPLICATE, search for\n+     the statement which triggers undefined behaviour.  If found, then\n+     transform the statement into a trap and delete everything after the\n+     statement.  If not found, then this particular instance was subsumed by\n+     an earlier instance of undefined behaviour and there's nothing to do. \n+\n+     This is made more complicated by the fact that we have STMT, which is in\n+     BB rather than in DUPLICATE.  So we set up two iterators, one for each\n+     block and walk forward looking for STMT in BB, advancing each iterator at\n+     each step.\n+\n+     When we find STMT the second iterator should point to STMT's equivalent in\n+     duplicate.  If DUPLICATE ends before STMT is found in BB, then there's\n+     nothing to do. \n+\n+     Ignore labels and debug statements.  */\n+  si = gsi_start_nondebug_after_labels_bb (bb);\n+  si2 = gsi_start_nondebug_after_labels_bb (duplicate);\n+  while (!gsi_end_p (si) && !gsi_end_p (si2) && gsi_stmt (si) != stmt)\n+    {\n+      gsi_next_nondebug (&si);\n+      gsi_next_nondebug (&si2);\n+    }\n+\n+  /* This would be an indicator that we never found STMT in BB, which should\n+     never happen.  */\n+  gcc_assert (!gsi_end_p (si));\n+\n+  /* If we did not run to the end of DUPLICATE, then SI points to STMT and\n+     SI2 points to the duplicate of STMT in DUPLICATE.  Insert a trap\n+     before SI2 and remove SI2 and all trailing statements.  */\n+  if (!gsi_end_p (si2))\n+    insert_trap_and_remove_trailing_statements (&si2);\n+\n+  return duplicate;\n+}\n+\n+/* Search the function for statements which, if executed, would cause\n+   the program to fault such as a dereference of a NULL pointer.\n+\n+   Such a program can't be valid if such a statement was to execute\n+   according to ISO standards.\n+\n+   We detect explicit NULL pointer dereferences as well as those implied\n+   by a PHI argument having a NULL value which unconditionally flows into\n+   a dereference in the same block as the PHI.\n+\n+   In the former case we replace the offending statement with an\n+   unconditional trap and eliminate the outgoing edges from the statement's\n+   basic block.  This may expose secondary optimization opportunities.\n+\n+   In the latter case, we isolate the path(s) with the NULL PHI \n+   feeding the dereference.  We can then replace the offending statement\n+   and eliminate the outgoing edges in the duplicate.  Again, this may\n+   expose secondary optimization opportunities.\n+\n+   A warning for both cases may be advisable as well.\n+\n+   Other statically detectable violations of the ISO standard could be\n+   handled in a similar way, such as out-of-bounds array indexing.  */\n+\n+static unsigned int\n+gimple_ssa_isolate_erroneous_paths (void)\n+{\n+  basic_block bb;\n+\n+  initialize_original_copy_tables ();\n+\n+  /* Search all the blocks for edges which, if traversed, will\n+     result in undefined behaviour.  */\n+  cfg_altered = false;\n+  FOR_EACH_BB (bb)\n+    {\n+      gimple_stmt_iterator si;\n+\n+      /* First look for a PHI which sets a pointer to NULL and which\n+ \t is then dereferenced within BB.  This is somewhat overly\n+\t conservative, but probably catches most of the interesting\n+\t cases.   */\n+      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple phi = gsi_stmt (si);\n+\t  tree lhs = gimple_phi_result (phi);\n+\n+\t  /* If the result is not a pointer, then there is no need to\n+ \t     examine the arguments.  */\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (lhs)))\n+\t    continue;\n+\n+\t  /* PHI produces a pointer result.  See if any of the PHI's\n+\t     arguments are NULL. \n+\n+\t     When we remove an edge, we want to reprocess the current\n+\t     index, hence the ugly way we update I for each iteration.  */\n+\t  basic_block duplicate = NULL;\n+\t  for (unsigned i = 0, next_i = 0;\n+\t       i < gimple_phi_num_args (phi);\n+\t       i = next_i)\n+\t    {\n+\t      tree op = gimple_phi_arg_def (phi, i);\n+\n+\t      next_i = i + 1;\n+\t\n+\t      if (!integer_zerop (op))\n+\t\tcontinue;\n+\n+\t      edge e = gimple_phi_arg_edge (phi, i);\n+\t      imm_use_iterator iter;\n+\t      gimple use_stmt;\n+\n+\t      /* We've got a NULL PHI argument.  Now see if the\n+ \t         PHI's result is dereferenced within BB.  */\n+\t      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n+\t        {\n+\t          /* We only care about uses in BB.  Catching cases in\n+\t\t     in other blocks would require more complex path\n+\t\t     isolation code.  */\n+\t\t  if (gimple_bb (use_stmt) != bb)\n+\t\t    continue;\n+\n+\t\t  if (infer_nonnull_range (use_stmt, lhs))\n+\t\t    {\n+\t\t      duplicate = isolate_path (bb, duplicate,\n+\t\t\t\t\t\te, use_stmt);\n+\n+\t\t      /* When we remove an incoming edge, we need to\n+\t\t\t reprocess the Ith element.  */\n+\t\t      next_i = i;\n+\t\t      cfg_altered = true;\n+\t\t    }\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Now look at the statements in the block and see if any of\n+\t them explicitly dereference a NULL pointer.  This happens\n+\t because of jump threading and constant propagation.  */\n+      for (si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next (&si))\n+\t{\n+\t  gimple stmt = gsi_stmt (si);\n+\n+\t  /* By passing null_pointer_node, we can use infer_nonnull_range\n+\t     to detect explicit NULL pointer dereferences and other uses\n+\t     where a non-NULL value is required.  */\n+\t  if (infer_nonnull_range (stmt, null_pointer_node))\n+\t    {\n+\t      insert_trap_and_remove_trailing_statements (&si);\n+\n+\t      /* And finally, remove all outgoing edges from BB.  */\n+\t      edge e;\n+\t      for (edge_iterator ei = ei_start (bb->succs);\n+\t\t   (e = ei_safe_edge (ei)); )\n+\t\tremove_edge (e);\n+\n+\t      /* Ignore any more operands on this statement and\n+\t\t continue the statement iterator (which should\n+\t\t terminate its loop immediately.  */\n+\t      cfg_altered = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  free_original_copy_tables ();\n+\n+  /* We scramble the CFG and loop structures a bit, clean up \n+     appropriately.  We really should incrementally update the\n+     loop structures, in theory it shouldn't be that hard.  */\n+  if (cfg_altered)\n+    {\n+      free_dominance_info (CDI_DOMINATORS);\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      loops_state_set (LOOPS_NEED_FIXUP);\n+      return TODO_cleanup_cfg | TODO_update_ssa;\n+    }\n+  return 0;\n+}\n+\n+static bool\n+gate_isolate_erroneous_paths (void)\n+{\n+  /* If we do not have a suitable builtin function for the trap statement,\n+     then do not perform the optimization.  */\n+  return (flag_isolate_erroneous_paths != 0\n+\t  && builtin_decl_explicit (BUILT_IN_TRAP) != NULL);\n+}\n+\n+namespace {\n+const pass_data pass_data_isolate_erroneous_paths =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"isolate-paths\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  true, /* has_gate */\n+  true, /* has_execute */\n+  TV_ISOLATE_ERRONEOUS_PATHS, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  TODO_verify_ssa, /* todo_flags_finish */\n+};\n+\n+class pass_isolate_erroneous_paths : public gimple_opt_pass\n+{\n+public:\n+  pass_isolate_erroneous_paths (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_isolate_erroneous_paths, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  opt_pass * clone () { return new pass_isolate_erroneous_paths (m_ctxt); }\n+  bool gate () { return gate_isolate_erroneous_paths (); }\n+  unsigned int execute () { return gimple_ssa_isolate_erroneous_paths (); }\n+\n+}; // class pass_uncprop\n+}\n+\n+gimple_opt_pass *\n+make_pass_isolate_erroneous_paths (gcc::context *ctxt)\n+{\n+  return new pass_isolate_erroneous_paths (ctxt);\n+}"}, {"sha": "55dd09106bba595155ca22f6caa03bbf442211e7", "filename": "gcc/gimple.c", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -3347,3 +3347,84 @@ nonfreeing_call_p (gimple call)\n \n   return false;\n }\n+\n+/* Callback for walk_stmt_load_store_ops.\n+ \n+   Return TRUE if OP will dereference the tree stored in DATA, FALSE\n+   otherwise.\n+\n+   This routine only makes a superficial check for a dereference.  Thus\n+   it must only be used if it is safe to return a false negative.  */\n+static bool\n+check_loadstore (gimple stmt ATTRIBUTE_UNUSED, tree op, void *data)\n+{\n+  if ((TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+      && operand_equal_p (TREE_OPERAND (op, 0), (tree)data, 0))\n+    return true;\n+  return false;\n+}\n+\n+/* If OP can be inferred to be non-zero after STMT executes, return true.  */\n+\n+bool\n+infer_nonnull_range (gimple stmt, tree op)\n+{\n+  /* We can only assume that a pointer dereference will yield\n+     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n+  if (!flag_delete_null_pointer_checks\n+      || !POINTER_TYPE_P (TREE_TYPE (op))\n+      || gimple_code (stmt) == GIMPLE_ASM)\n+    return false;\n+\n+  if (walk_stmt_load_store_ops (stmt, (void *)op,\n+\t\t\t\tcheck_loadstore, check_loadstore))\n+    return true;\n+\n+  if (is_gimple_call (stmt) && !gimple_call_internal_p (stmt))\n+    {\n+      tree fntype = gimple_call_fntype (stmt);\n+      tree attrs = TYPE_ATTRIBUTES (fntype);\n+      for (; attrs; attrs = TREE_CHAIN (attrs))\n+\t{\n+\t  attrs = lookup_attribute (\"nonnull\", attrs);\n+\n+\t  /* If \"nonnull\" wasn't specified, we know nothing about\n+\t     the argument.  */\n+\t  if (attrs == NULL_TREE)\n+\t    return false;\n+\n+\t  /* If \"nonnull\" applies to all the arguments, then ARG\n+\t     is non-null if it's in the argument list.  */\n+\t  if (TREE_VALUE (attrs) == NULL_TREE)\n+\t    {\n+\t      for (unsigned int i = 0; i < gimple_call_num_args (stmt); i++)\n+\t\t{\n+\t\t  if (operand_equal_p (op, gimple_call_arg (stmt, i), 0)\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (stmt, i))))\n+\t\t    return true;\n+\t\t}\n+\t      return false;\n+\t    }\n+\n+\t  /* Now see if op appears in the nonnull list.  */\n+\t  for (tree t = TREE_VALUE (attrs); t; t = TREE_CHAIN (t))\n+\t    {\n+\t      int idx = TREE_INT_CST_LOW (TREE_VALUE (t)) - 1;\n+\t      tree arg = gimple_call_arg (stmt, idx);\n+\t      if (operand_equal_p (op, arg, 0))\n+\t\treturn true;\n+\t    }\n+\t}\n+    }\n+\n+  /* If this function is marked as returning non-null, then we can\n+     infer OP is non-null if it is used in the return statement.  */\n+  if (gimple_code (stmt) == GIMPLE_RETURN\n+      && gimple_return_retval (stmt)\n+      && operand_equal_p (gimple_return_retval (stmt), op, 0)\n+      && lookup_attribute (\"returns_nonnull\",\n+\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))))\n+    return true;\n+\n+  return false;\n+}"}, {"sha": "a548a5b45e83fbefd8e91df2559cb7564e0c0038", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -1038,6 +1038,7 @@ extern gimple_predicate rhs_predicate_for (tree);\n extern tree canonicalize_cond_expr_cond (tree);\n extern void dump_decl_set (FILE *, bitmap);\n extern bool nonfreeing_call_p (gimple);\n+extern bool infer_nonnull_range (gimple, tree);\n \n /* In trans-mem.c.  */\n extern void diagnose_tm_safe_errors (tree);"}, {"sha": "3a939ac92b9bb1d03044957268c85f1b3e3f6c4d", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -493,6 +493,7 @@ static const struct default_options default_options_table[] =\n     { OPT_LEVELS_2_PLUS, OPT_fvect_cost_model_, NULL, VECT_COST_MODEL_CHEAP },\n     { OPT_LEVELS_2_PLUS_SPEED_ONLY, OPT_foptimize_strlen, NULL, 1 },\n     { OPT_LEVELS_2_PLUS, OPT_fhoist_adjacent_loads, NULL, 1 },\n+    { OPT_LEVELS_2_PLUS, OPT_fisolate_erroneous_paths, NULL, 1 },\n \n     /* -O3 optimizations.  */\n     { OPT_LEVELS_3_PLUS, OPT_ftree_loop_distribute_patterns, NULL, 1 },"}, {"sha": "1e2c4dc00ca0e0151946c0229c502920367d52c8", "filename": "gcc/passes.def", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -167,9 +167,16 @@ along with GCC; see the file COPYING3.  If not see\n \t is removed, and this place fits nicely.  Remember this when\n \t trying to move or duplicate pass_dominator somewhere earlier.  */\n       NEXT_PASS (pass_dominator);\n+      /* At this point the majority of const/copy propagations\n+\t are exposed.  Go ahead and identify paths that should never\n+\t be executed in a conforming program and isolate those paths.\n+\n+\t This will expose more degenerate PHIs in the main path and\n+\t expose more PRE/DOM optimization opportunities.  */\n+      NEXT_PASS (pass_isolate_erroneous_paths);\n       /* The only const/copy propagation opportunities left after\n-\t DOM should be due to degenerate PHI nodes.  So rather than\n-\t run the full propagators, run a specialized pass which\n+\t DOM and erroneous path isolation should be due to degenerate PHI nodes.\n+\t So rather than run the full propagators, run a specialized pass which\n \t only examines PHIs to discover const/copy propagation\n \t opportunities.  */\n       NEXT_PASS (pass_phi_only_cprop);"}, {"sha": "a348d7e0b28c3e53e37f47efadbce660dfa38494", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -1,3 +1,11 @@\n+2013-10-05  Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/pr38984.c: Add -fno-isolate-erroneous-paths.\n+\t* gcc.dg/tree-ssa/isolate-1.c: New test.\n+\t* gcc.dg/tree-ssa/isolate-2.c: New test.\n+\t* gcc.dg/tree-ssa/isolate-3.c: New test.\n+\t* gcc.dg/tree-ssa/isolate-4.c: New test.\n+\n 2013-11-05  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/58997"}, {"sha": "0c031805ea80fa5a16d434a3fa2666d42a973cfc", "filename": "gcc/testsuite/gcc.dg/pr38984.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38984.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38984.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr38984.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-delete-null-pointer-checks -fdump-tree-optimized\" }\n+/* { dg-options \"-O2 -fno-delete-null-pointer-checks -fdump-tree-optimized -fno-isolate-erroneous-paths\" }\n  * */\n \n int f(int *p)"}, {"sha": "6b779b4a4bc21d03806e5530159a92319f60cff1", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-1.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-1.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -0,0 +1,58 @@\n+\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-isolate-paths\" } */\n+\n+\n+struct demangle_component\n+{\n+\n+  int type;\n+  int zzz;\n+\n+};\n+\n+\n+struct d_info\n+{\n+  struct demangle_component *comps;\n+  int next_comp;\n+  int num_comps;\n+};\n+\n+\n+static struct demangle_component *\n+d_make_empty (struct d_info *di)\n+{\n+  struct demangle_component *p;\n+\n+  if (di->next_comp >= di->num_comps)\n+    return ((void *)0);\n+  p = &di->comps[di->next_comp];\n+  return p;\n+}\n+\n+\n+\n+struct demangle_component *\n+d_type (struct d_info *di)\n+{\n+   struct demangle_component *ret;\n+   ret = d_make_empty (di);\n+   ret->type = 42;\n+   ret->zzz = -1;\n+   return ret;\n+}\n+\n+/* We're testing two aspects of isolation here.  First that isolation\n+   occurs, second that if we have two null dereferences in a block that\n+   that we delete everything from the first dereferece to the end of the\n+   block, regardless of which comes first in the immediate use iterator.  */\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->type\" 1 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"->zzz\" 1 \"isolate-paths\"} } */\n+/* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n+\n+\n+\n+\n+"}, {"sha": "290b44c5bd430787defa356b97e9600c2cf8e6b2", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -0,0 +1,43 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-isolate-paths -fdump-tree-phicprop1\" } */\n+\n+\n+int z;\n+int y;\n+\n+int * foo(int a) __attribute__((returns_nonnull));\n+int * bar(void) __attribute__((returns_nonnull));\n+\n+int *\n+foo(int a)\n+\n+{\n+  switch (a)\n+    {\n+      case 0:\n+        return &z;\n+      default:\n+        return (int *)0;\n+    }\n+}\n+\n+\n+int *\n+bar (void)\n+{\n+  return 0;\n+}\n+\n+/* We testing that the path isolation code can take advantage of the\n+   returns non-null attribute to isolate a path where NULL flows into\n+   a return statement.  We test this twice, once where the NULL flows\n+   from a PHI, the second with an explicit return 0 in the IL.\n+\n+   We also verify that after isolation phi-cprop simplifies the\n+   return statement so that it returns &z directly.\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 2 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"return &z;\" 1 \"phicprop1\"} } */\n+/* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n+/* { dg-final { cleanup-tree-dump \"phicprop1\" } } */\n+\n+"}, {"sha": "7dddd8062c0e9309631ba28af5aebec7c57d2516", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-3.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-3.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-isolate-paths\" } */\n+\n+\n+typedef long unsigned int size_t;\n+extern void *memset (void *__s, int __c, size_t __n)\n+  __attribute__ ((__nothrow__, __leaf__)) __attribute__ ((__nonnull__ (1)));\n+struct rtx_def;\n+typedef struct rtx_def *rtx;\n+typedef struct VEC_rtx_base\n+\n+{\n+  unsigned num;\n+  unsigned alloc;\n+  rtx vec[1];\n+} VEC_rtx_base;\n+static __inline__ rtx *\n+VEC_rtx_base_address (VEC_rtx_base * vec_)\n+{\n+  return vec_ ? vec_->vec : 0;\n+}\n+typedef struct VEC_rtx_gc\n+{\n+  VEC_rtx_base base;\n+} VEC_rtx_gc;\n+\n+static __inline__ void\n+VEC_rtx_gc_safe_grow (VEC_rtx_gc ** vec_, int size_, const char *file_,\n+                      unsigned line_, const char *function_)\n+{\n+  ((*vec_) ? &(*vec_)->base : 0)->num = size_;\n+} \n+\n+static __inline__ void\n+VEC_rtx_gc_safe_grow_cleared (VEC_rtx_gc ** vec_, int size_,\n+                              const char *file_, unsigned line_,\n+                              const char *function_, int oldsize)\n+{\n+  VEC_rtx_gc_safe_grow (vec_, size_, file_, line_, function_);\n+  memset (&(VEC_rtx_base_address ((*vec_) ? &(*vec_)->base : 0))[oldsize], 0,\n+          sizeof (rtx) * (size_ - oldsize));\n+}\n+\n+static VEC_rtx_gc *reg_base_value;\n+void\n+init_alias_analysis (void)\n+{\n+  unsigned int maxreg = max_reg_num ();\n+  (VEC_rtx_gc_safe_grow_cleared\n+   (&(reg_base_value), maxreg, \"../../../gcc-4.6.0/gcc/alias.c\", 2755,\n+    __FUNCTION__, arf ()));\n+}\n+\n+\n+\n+/* This is an example of how a NULL pointer dereference can show up\n+   without a PHI.  Note VEC_rtx_gcc_safe_grow.  If an earlier pass\n+   (such as VRP) isolates the NULL path for some reason or another\n+   we end up with an explicit NULL dereference in the IL.  Yes, it\n+   started with a PHI, but by the time the path isolation code runs\n+   its explicit in the IL.  */\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 1 \"isolate-paths\"} } */\n+/* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n+\n+"}, {"sha": "6937d25580ad02b88ba3a96dd4cc9cd1c0c49eca", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-4.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-isolate-paths -fdump-tree-phicprop1\" } */\n+\n+\n+extern void foo(void *) __attribute__ ((__nonnull__ (1)));\n+\n+int z;\n+\n+void\n+com (int a)\n+{\n+    foo (a == 42 ? &z  : (void *) 0);\n+}\n+\n+void\n+bar (void)\n+{\n+  foo ((void *)0);\n+}\n+\n+/* We testing that the path isolation code can take advantage of the\n+   returns non-null attribute to isolate a path where NULL flows into\n+   a return statement.\n+\n+   We also verify that after isolation phi-cprop simplifies the\n+   return statement so that it returns &z directly.\n+/* { dg-final { scan-tree-dump-times \"__builtin_trap\" 2 \"isolate-paths\"} } */\n+/* { dg-final { scan-tree-dump-times \"foo .&z.;\" 1 \"phicprop1\"} } */\n+/* { dg-final { cleanup-tree-dump \"isolate-paths\" } } */\n+/* { dg-final { cleanup-tree-dump \"phicprop1\" } } */\n+\n+"}, {"sha": "afdadb878a7e9290665d65812770685f29cacd15", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -144,6 +144,7 @@ DEFTIMEVAR (TV_TREE_SSA_INCREMENTAL  , \"tree SSA incremental\")\n DEFTIMEVAR (TV_TREE_OPS\t             , \"tree operand scan\")\n DEFTIMEVAR (TV_TREE_SSA_DOMINATOR_OPTS   , \"dominator optimization\")\n DEFTIMEVAR (TV_TREE_SRA              , \"tree SRA\")\n+DEFTIMEVAR (TV_ISOLATE_ERRONEOUS_PATHS    , \"isolate eroneous paths\")\n DEFTIMEVAR (TV_TREE_CCP\t\t     , \"tree CCP\")\n DEFTIMEVAR (TV_TREE_PHI_CPROP\t     , \"tree PHI const/copy prop\")\n DEFTIMEVAR (TV_TREE_SPLIT_EDGES      , \"tree split crit edges\")"}, {"sha": "3aeaeeb114b3e294b14139283be671f574f74353", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -425,6 +425,7 @@ extern gimple_opt_pass *make_pass_sink_code (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fre (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_check_data_deps (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_copy_prop (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_isolate_erroneous_paths (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_vrp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_uncprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_return_slot (gcc::context *ctxt);"}, {"sha": "ba8045d470226c75f0dc080181f9f29b94225378", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -236,100 +236,6 @@ flush_pending_stmts (edge e)\n   redirect_edge_var_map_clear (e);\n }\n \n-\n-/* Data structure used to count the number of dereferences to PTR\n-   inside an expression.  */\n-struct count_ptr_d\n-{\n-  tree ptr;\n-  unsigned num_stores;\n-  unsigned num_loads;\n-};\n-\n-\n-/* Helper for count_uses_and_derefs.  Called by walk_tree to look for\n-   (ALIGN/MISALIGNED_)INDIRECT_REF nodes for the pointer passed in DATA.  */\n-\n-static tree\n-count_ptr_derefs (tree *tp, int *walk_subtrees, void *data)\n-{\n-  struct walk_stmt_info *wi_p = (struct walk_stmt_info *) data;\n-  struct count_ptr_d *count_p = (struct count_ptr_d *) wi_p->info;\n-\n-  /* Do not walk inside ADDR_EXPR nodes.  In the expression &ptr->fld,\n-     pointer 'ptr' is *not* dereferenced, it is simply used to compute\n-     the address of 'fld' as 'ptr + offsetof(fld)'.  */\n-  if (TREE_CODE (*tp) == ADDR_EXPR)\n-    {\n-      *walk_subtrees = 0;\n-      return NULL_TREE;\n-    }\n-\n-  if (TREE_CODE (*tp) == MEM_REF && TREE_OPERAND (*tp, 0) == count_p->ptr)\n-    {\n-      if (wi_p->is_lhs)\n-\tcount_p->num_stores++;\n-      else\n-\tcount_p->num_loads++;\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-\n-/* Count the number of direct and indirect uses for pointer PTR in\n-   statement STMT.  The number of direct uses is stored in\n-   *NUM_USES_P.  Indirect references are counted separately depending\n-   on whether they are store or load operations.  The counts are\n-   stored in *NUM_STORES_P and *NUM_LOADS_P.  */\n-\n-void\n-count_uses_and_derefs (tree ptr, gimple stmt, unsigned *num_uses_p,\n-\t\t       unsigned *num_loads_p, unsigned *num_stores_p)\n-{\n-  ssa_op_iter i;\n-  tree use;\n-\n-  *num_uses_p = 0;\n-  *num_loads_p = 0;\n-  *num_stores_p = 0;\n-\n-  /* Find out the total number of uses of PTR in STMT.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, i, SSA_OP_USE)\n-    if (use == ptr)\n-      (*num_uses_p)++;\n-\n-  /* Now count the number of indirect references to PTR.  This is\n-     truly awful, but we don't have much choice.  There are no parent\n-     pointers inside INDIRECT_REFs, so an expression like\n-     '*x_1 = foo (x_1, *x_1)' needs to be traversed piece by piece to\n-     find all the indirect and direct uses of x_1 inside.  The only\n-     shortcut we can take is the fact that GIMPLE only allows\n-     INDIRECT_REFs inside the expressions below.  */\n-  if (is_gimple_assign (stmt)\n-      || gimple_code (stmt) == GIMPLE_RETURN\n-      || gimple_code (stmt) == GIMPLE_ASM\n-      || is_gimple_call (stmt))\n-    {\n-      struct walk_stmt_info wi;\n-      struct count_ptr_d count;\n-\n-      count.ptr = ptr;\n-      count.num_stores = 0;\n-      count.num_loads = 0;\n-\n-      memset (&wi, 0, sizeof (wi));\n-      wi.info = &count;\n-      walk_gimple_op (stmt, count_ptr_derefs, &wi);\n-\n-      *num_stores_p = count.num_stores;\n-      *num_loads_p = count.num_loads;\n-    }\n-\n-  gcc_assert (*num_uses_p >= *num_loads_p + *num_stores_p);\n-}\n-\n-\n /* Replace the LHS of STMT, an assignment, either a GIMPLE_ASSIGN or a\n    GIMPLE_CALL, with NLHS, in preparation for modifying the RHS to an\n    expression with a different value."}, {"sha": "89ea5c64c76583101e11a70a2268dab5117f78b3", "filename": "gcc/tree-ssa.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.h?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -39,8 +39,6 @@ extern edge_var_map_vector *redirect_edge_var_map_vector (edge);\n extern void redirect_edge_var_map_destroy (void);\n extern edge ssa_redirect_edge (edge, basic_block);\n extern void flush_pending_stmts (edge);\n-extern void count_uses_and_derefs (tree, gimple, unsigned *, unsigned *,\n-\t\t\t\t   unsigned *);\n extern void gimple_replace_ssa_lhs (gimple, tree);\n extern tree target_for_debug_bind (tree);\n extern void insert_debug_temp_for_var_def (gimple_stmt_iterator *, tree);"}, {"sha": "2a9043049417fc24325f302fd6e0dc0d321c758b", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fdc414d439bc7148e079d27220e597b3b602a47/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=8fdc414d439bc7148e079d27220e597b3b602a47", "patch": "@@ -4476,57 +4476,6 @@ fp_predicate (gimple stmt)\n   return FLOAT_TYPE_P (TREE_TYPE (gimple_cond_lhs (stmt)));\n }\n \n-\n-/* If OP can be inferred to be non-zero after STMT executes, return true.  */\n-\n-static bool\n-infer_nonnull_range (gimple stmt, tree op)\n-{\n-  /* We can only assume that a pointer dereference will yield\n-     non-NULL if -fdelete-null-pointer-checks is enabled.  */\n-  if (!flag_delete_null_pointer_checks\n-      || !POINTER_TYPE_P (TREE_TYPE (op))\n-      || gimple_code (stmt) == GIMPLE_ASM)\n-    return false;\n-\n-  unsigned num_uses, num_loads, num_stores;\n-\n-  count_uses_and_derefs (op, stmt, &num_uses, &num_loads, &num_stores);\n-  if (num_loads + num_stores > 0)\n-    return true;\n-\n-  if (is_gimple_call (stmt) && !gimple_call_internal_p (stmt))\n-    {\n-      tree fntype = gimple_call_fntype (stmt);\n-      tree attrs = TYPE_ATTRIBUTES (fntype);\n-      for (; attrs; attrs = TREE_CHAIN (attrs))\n-\t{\n-\t  attrs = lookup_attribute (\"nonnull\", attrs);\n-\n-\t  /* If \"nonnull\" wasn't specified, we know nothing about\n-\t     the argument.  */\n-\t  if (attrs == NULL_TREE)\n-\t    return false;\n-\n-\t  /* If \"nonnull\" applies to all the arguments, then ARG\n-\t     is non-null.  */\n-\t  if (TREE_VALUE (attrs) == NULL_TREE)\n-\t    return true;\n-\n-\t  /* Now see if op appears in the nonnull list.  */\n-\t  for (tree t = TREE_VALUE (attrs); t; t = TREE_CHAIN (t))\n-\t    {\n-\t      int idx = TREE_INT_CST_LOW (TREE_VALUE (t)) - 1;\n-\t      tree arg = gimple_call_arg (stmt, idx);\n-\t      if (op == arg)\n-\t\treturn true;\n-\t    }\n-\t}\n-    }\n-\n-  return false;\n-}\n-\n /* If the range of values taken by OP can be inferred after STMT executes,\n    return the comparison code (COMP_CODE_P) and value (VAL_P) that\n    describes the inferred range.  Return true if a range could be"}]}