{"sha": "bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmMyYjFhMjMyYjE4MjViNDIxYTFhYWEyMWEwODY1YjJkMWU0ZTA4Yw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-02T11:31:48Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-07-31T08:57:50Z"}, "message": "libgcov: support overloaded malloc\n\ngcc/ChangeLog:\n\n\t* gcov-io.h (GCOV_PREALLOCATED_KVP): New.\n\nlibgcc/ChangeLog:\n\n\t* libgcov-driver.c: Add __gcov_kvp_pool\n\tand __gcov_kvp_pool_index variables.\n\t* libgcov.h (allocate_gcov_kvp): New.\n\t(gcov_topn_add_value): Use it.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/tree-prof/indir-call-prof-malloc.c: New test.", "tree": {"sha": "ca7bba49f12a55544ae9fa3ab9c44dfa5d9d0742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca7bba49f12a55544ae9fa3ab9c44dfa5d9d0742"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "072a8b8fb6e861d8ac2db847bcc81dbcb1ef1b35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072a8b8fb6e861d8ac2db847bcc81dbcb1ef1b35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/072a8b8fb6e861d8ac2db847bcc81dbcb1ef1b35"}], "stats": {"total": 107, "additions": 105, "deletions": 2}, "files": [{"sha": "4dba01c78ce5e9c348730253ebf362723e4c3523", "filename": "gcc/gcov-io.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/gcc%2Fgcov-io.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/gcc%2Fgcov-io.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.h?ref=bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "patch": "@@ -292,6 +292,9 @@ GCOV_COUNTERS\n /* Maximum number of tracked TOP N value profiles.  */\n #define GCOV_TOPN_MAXIMUM_TRACKED_VALUES 32\n \n+/* Number of pre-allocated gcov_kvp structures.  */\n+#define GCOV_PREALLOCATED_KVP 16\n+\n /* Convert a counter index to a tag.  */\n #define GCOV_TAG_FOR_COUNTER(COUNT)\t\t\t\t\\\n \t(GCOV_TAG_COUNTER_BASE + ((gcov_unsigned_t)(COUNT) << 17))"}, {"sha": "454e224c95fdc87fab954974050a9966535a94d3", "filename": "gcc/testsuite/gcc.dg/tree-prof/indir-call-prof-malloc.c", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Findir-call-prof-malloc.c?ref=bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "patch": "@@ -0,0 +1,49 @@\n+/* { dg-options \"-O2 -ldl\" } */\n+\n+#define _GNU_SOURCE\n+#include <stdio.h>\n+#include <stdint.h>\n+#include <dlfcn.h>\n+\n+int global;\n+int global2;\n+\n+void report1 (size_t size)\n+{\n+  global++;\n+}\n+\n+void report2 (size_t size)\n+{\n+  global2++;\n+}\n+\n+typedef void (*tp) (size_t);\n+static tp fns[] = {report1, report2};\n+\n+void* malloc(size_t size)\n+{\n+  static void* (*real_malloc)(size_t) = NULL;\n+  if (!real_malloc)\n+      real_malloc = dlsym(RTLD_NEXT, \"malloc\");\n+\n+  void *p = real_malloc (size);\n+  fns[size % 2] (size);\n+  // fprintf(stderr, \"malloc(%d) = %p\\n\", size, p);\n+  return p;\n+}\n+\n+void *calloc (size_t n, size_t size)\n+{\n+  void *ptr = malloc (n * size);\n+  __builtin_memset (ptr, 0, n * size);\n+  return ptr;\n+}\n+\n+void *ptr;\n+\n+int main()\n+{\n+  ptr = malloc (16);\n+  return 0;\n+}"}, {"sha": "58914268d4ece0b3a3a7dcb9cb21c4fa197fd770", "filename": "libgcc/libgcov-driver.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/libgcc%2Flibgcov-driver.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/libgcc%2Flibgcov-driver.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov-driver.c?ref=bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "patch": "@@ -588,6 +588,12 @@ struct gcov_root __gcov_root;\n struct gcov_master __gcov_master = \n   {GCOV_VERSION, 0};\n \n+/* Pool of pre-allocated gcov_kvp strutures.  */\n+struct gcov_kvp __gcov_kvp_pool[GCOV_PREALLOCATED_KVP];\n+\n+/* Index to first free gcov_kvp in the pool.  */\n+unsigned __gcov_kvp_pool_index;\n+\n void\n __gcov_exit (void)\n {"}, {"sha": "8be5bebcac08a8f5d761eba75b700f1db8b6ced0", "filename": "libgcc/libgcov.h", "status": "modified", "additions": 47, "deletions": 2, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/libgcc%2Flibgcov.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c/libgcc%2Flibgcov.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcov.h?ref=bc2b1a232b1825b421a1aaa21a0865b2d1e4e08c", "patch": "@@ -250,6 +250,8 @@ struct indirect_call_tuple\n   \n /* Exactly one of these will be active in the process.  */\n extern struct gcov_master __gcov_master;\n+extern struct gcov_kvp __gcov_kvp_pool[GCOV_PREALLOCATED_KVP];\n+extern unsigned __gcov_kvp_pool_index;\n \n /* Dump a set of gcov objects.  */\n extern void __gcov_dump_one (struct gcov_root *) ATTRIBUTE_HIDDEN;\n@@ -402,6 +404,47 @@ gcov_counter_add (gcov_type *counter, gcov_type value,\n     *counter += value;\n }\n \n+/* Allocate gcov_kvp from heap.  If we are recursively called, then allocate\n+   it from a list of pre-allocated pool.  */\n+\n+static inline struct gcov_kvp *\n+allocate_gcov_kvp (void)\n+{\n+  struct gcov_kvp *new_node = NULL;\n+\n+  static\n+#if defined(HAVE_CC_TLS)\n+__thread\n+#endif\n+  volatile unsigned in_recursion ATTRIBUTE_UNUSED = 0;\n+\n+#if !defined(IN_GCOV_TOOL) && !defined(L_gcov_merge_topn)\n+  if (__builtin_expect (in_recursion, 0))\n+    {\n+      unsigned index;\n+#if GCOV_SUPPORTS_ATOMIC\n+      index\n+\t= __atomic_fetch_add (&__gcov_kvp_pool_index, 1, __ATOMIC_RELAXED);\n+#else\n+      index = __gcov_kvp_pool_index++;\n+#endif\n+      if (index < GCOV_PREALLOCATED_KVP)\n+\tnew_node = &__gcov_kvp_pool[index];\n+      else\n+\t/* Do not crash in the situation.  */\n+\treturn NULL;\n+    }\n+  else\n+#endif\n+    {\n+      in_recursion = 1;\n+      new_node = (struct gcov_kvp *)xcalloc (1, sizeof (struct gcov_kvp));\n+      in_recursion = 0;\n+    }\n+\n+  return new_node;\n+}\n+\n /* Add key value pair VALUE:COUNT to a top N COUNTERS.  When INCREMENT_TOTAL\n    is true, add COUNT to total of the TOP counter.  If USE_ATOMIC is true,\n    do it in atomic way.  */\n@@ -443,8 +486,10 @@ gcov_topn_add_value (gcov_type *counters, gcov_type value, gcov_type count,\n     }\n   else\n     {\n-      struct gcov_kvp *new_node\n-\t= (struct gcov_kvp *)xcalloc (1, sizeof (struct gcov_kvp));\n+      struct gcov_kvp *new_node = allocate_gcov_kvp ();\n+      if (new_node == NULL)\n+\treturn;\n+\n       new_node->value = value;\n       new_node->count = count;\n "}]}