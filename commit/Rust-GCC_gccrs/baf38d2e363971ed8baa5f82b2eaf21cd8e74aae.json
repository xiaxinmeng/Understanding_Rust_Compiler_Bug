{"sha": "baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFmMzhkMmUzNjM5NzFlZDhiYWE1ZjgyYjJlYWYyMWNkOGU3NGFhZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-11-13T21:33:50Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-11-15T17:07:13Z"}, "message": "c++: Check abstract type only on object creation. [PR86252]\n\nAbstract checking has been problematic for a while; when I implemented an\nearlier issue resolution to do more checking it led to undesirable\ninstantiations, and so backed some of it out.  During the C++20 process we\ndecided with P0929R2 that we should go the other way, and only check\nabstractness when we're actually creating an object, not when merely forming\nan array or function type.  This means that we can remove the machinery for\nchecking whether a newly complete class makes some earlier declaration\nill-formed.  This change was moved as a DR, so I'm applying it to all\nstandard levels.  This could be reconsidered if it causes problems, but I\ndon't expect it to.\n\nThe change to the libstdc++ result_of test brings the expected behavior in\nline with that for incomplete types, but as in PR97841 I think the libstdc++\nhandling of incomplete types in this and other type_traits is itself wrong,\nso I expect these lines and others to change again before long.\n\ngcc/cp/ChangeLog:\n\n\t* decl.c (cp_finish_decl): Only check abstractness on definition.\n\t(require_complete_types_for_parms): Check abstractness here.\n\t(create_array_type_for_decl): Not here.\n\t(grokdeclarator, grokparms, complete_vars): Not here.\n\t* pt.c (tsubst, tsubst_arg_types, tsubst_function_type): Not here.\n\t* typeck2.c (struct pending_abstract_type): Remove.\n\t(struct abstract_type_hasher): Remove.\n\t(abstract_pending_vars, complete_type_check_abstract): Remove.\n\t(abstract_virtuals_error_sfinae): Handle arrays.\n\t* call.c (conv_is_prvalue): Split out from...\n\t(conv_binds_ref_to_prvalue): ...here.\n\t(implicit_conversion_1): Rename from implicit_conversion.\n\t(implicit_conversion): An abstract prvalue is bad.\n\t(convert_like_internal): Don't complain if expr is already\n\terror_mark_node.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/other/abstract1.C: Adjust.\n\t* g++.dg/other/abstract2.C: Adjust.\n\t* g++.dg/other/abstract4.C: Adjust.\n\t* g++.dg/other/abstract5.C: Adjust.\n\t* g++.dg/other/abstract8.C: New test.\n\t* g++.dg/template/sfinae-dr657.C: Adjust.\n\t* g++.old-deja/g++.other/decl3.C: Adjust.\n\nlibstdc++-v3/ChangeLog:\n\n\t* testsuite/20_util/result_of/sfinae_friendly_1.cc: Adjust.", "tree": {"sha": "f5888a935e669ab96ba8aef052e2f514213f9d80", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f5888a935e669ab96ba8aef052e2f514213f9d80"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "82b6d25d289195d41e53fc91f63325864e3e28d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82b6d25d289195d41e53fc91f63325864e3e28d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82b6d25d289195d41e53fc91f63325864e3e28d0"}], "stats": {"total": 404, "additions": 156, "deletions": 248}, "files": [{"sha": "3a6ad1332a7801c2089801b1395dd81cbf744745", "filename": "gcc/cp/call.c", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -213,6 +213,7 @@ static conversion *merge_conversion_sequences (conversion *, conversion *);\n static tree build_temp (tree, tree, int, diagnostic_t *, tsubst_flags_t);\n static conversion *build_identity_conv (tree, tree);\n static inline bool conv_binds_to_array_of_unknown_bound (conversion *);\n+static bool conv_is_prvalue (conversion *);\n static tree prevent_lifetime_extension (tree);\n \n /* Returns nonzero iff the destructor name specified in NAME matches BASETYPE.\n@@ -1963,14 +1964,12 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n   return conv;\n }\n \n-/* Returns the implicit conversion sequence (see [over.ics]) from type\n-   FROM to type TO.  The optional expression EXPR may affect the\n-   conversion.  FLAGS are the usual overloading flags.  If C_CAST_P is\n-   true, this conversion is coming from a C-style cast.  */\n+/* Most of the implementation of implicit_conversion, with the same\n+   parameters.  */\n \n static conversion *\n-implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n-\t\t     int flags, tsubst_flags_t complain)\n+implicit_conversion_1 (tree to, tree from, tree expr, bool c_cast_p,\n+\t\t       int flags, tsubst_flags_t complain)\n {\n   conversion *conv;\n \n@@ -2096,6 +2095,26 @@ implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n   return NULL;\n }\n \n+/* Returns the implicit conversion sequence (see [over.ics]) from type\n+   FROM to type TO.  The optional expression EXPR may affect the\n+   conversion.  FLAGS are the usual overloading flags.  If C_CAST_P is\n+   true, this conversion is coming from a C-style cast.  */\n+\n+static conversion *\n+implicit_conversion (tree to, tree from, tree expr, bool c_cast_p,\n+\t\t     int flags, tsubst_flags_t complain)\n+{\n+  conversion *conv = implicit_conversion_1 (to, from, expr, c_cast_p,\n+\t\t\t\t\t    flags, complain);\n+  if (!conv || conv->bad_p)\n+    return conv;\n+  if (conv_is_prvalue (conv)\n+      && CLASS_TYPE_P (conv->type)\n+      && CLASSTYPE_PURE_VIRTUALS (conv->type))\n+    conv->bad_p = true;\n+  return conv;\n+}\n+\n /* Like implicit_conversion, but return NULL if the conversion is bad.\n \n    This is not static so that check_non_deducible_conversion can call it within\n@@ -7407,7 +7426,7 @@ convert_like_internal (conversion *convs, tree expr, tree fn, int argnum,\n \t  else if (t->kind == ck_identity)\n \t    break;\n \t}\n-      if (!complained)\n+      if (!complained && expr != error_mark_node)\n \t{\n \t  range_label_for_type_mismatch label (TREE_TYPE (expr), totype);\n \t  gcc_rich_location richloc (loc, &label);\n@@ -8438,20 +8457,15 @@ unsafe_copy_elision_p (tree target, tree exp)\n \t  && !AGGR_INIT_VIA_CTOR_P (init));\n }\n \n-/* True iff C is a conversion that binds a reference to a prvalue.  */\n+/* True IFF the result of the conversion C is a prvalue.  */\n \n static bool\n-conv_binds_ref_to_prvalue (conversion *c)\n+conv_is_prvalue (conversion *c)\n {\n-  if (c->kind != ck_ref_bind)\n-    return false;\n-  if (c->need_temporary_p)\n-    return true;\n-\n-  c = next_conversion (c);\n-\n   if (c->kind == ck_rvalue)\n     return true;\n+  if (c->kind == ck_base && c->need_temporary_p)\n+    return true;\n   if (c->kind == ck_user && !TYPE_REF_P (c->type))\n     return true;\n   if (c->kind == ck_identity && c->u.expr\n@@ -8461,6 +8475,19 @@ conv_binds_ref_to_prvalue (conversion *c)\n   return false;\n }\n \n+/* True iff C is a conversion that binds a reference to a prvalue.  */\n+\n+static bool\n+conv_binds_ref_to_prvalue (conversion *c)\n+{\n+  if (c->kind != ck_ref_bind)\n+    return false;\n+  if (c->need_temporary_p)\n+    return true;\n+\n+  return conv_is_prvalue (next_conversion (c));\n+}\n+\n /* True iff converting EXPR to a reference type TYPE does not involve\n    creating a temporary.  */\n "}, {"sha": "89bae06cd6bbb1a70ffc2fd868314a09575777d9", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 4, "deletions": 20, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -7926,10 +7926,9 @@ cp_finish_decl (tree decl, tree init, bool init_const_expr_p,\n \n       make_rtl_for_nonlocal_decl (decl, init, asmspec);\n \n-      /* Check for abstractness of the type. Notice that there is no\n-\t need to strip array types here since the check for those types\n-\t is already done within create_array_type_for_decl.  */\n-      abstract_virtuals_error (decl, type);\n+      /* Check for abstractness of the type.  */\n+      if (var_definition_p)\n+\tabstract_virtuals_error (decl, type);\n \n       if (TREE_TYPE (decl) == error_mark_node)\n \t/* No initialization required.  */\n@@ -10701,11 +10700,6 @@ create_array_type_for_decl (tree name, tree type, tree size, location_t loc)\n     itype = compute_array_index_type_loc (loc, name, size,\n \t\t\t\t\t  tf_warning_or_error);\n \n-  /* [dcl.array]\n-     T is called the array element type; this type shall not be [...] an\n-     abstract class type.  */\n-  abstract_virtuals_error (name, type);\n-\n   return build_cplus_array_type (type, itype);\n }\n \n@@ -12097,11 +12091,6 @@ grokdeclarator (const cp_declarator *declarator,\n \n \t    /* Declaring a function type.  */\n \n-\t    {\n-\t      iloc_sentinel ils (declspecs->locations[ds_type_spec]);\n-\t      abstract_virtuals_error (ACU_RETURN, type);\n-\t    }\n-\n \t    /* Pick up type qualifiers which should be applied to `this'.  */\n \t    memfn_quals = declarator->u.function.qualifiers;\n \t    /* Pick up virt-specifiers.  */\n@@ -13872,6 +13861,7 @@ require_complete_types_for_parms (tree parms)\n \t  relayout_decl (parms);\n \t  DECL_ARG_TYPE (parms) = type_passed_as (TREE_TYPE (parms));\n \n+\t  abstract_virtuals_error (parms, TREE_TYPE (parms));\n \t  maybe_warn_parm_abi (TREE_TYPE (parms),\n \t\t\t       DECL_SOURCE_LOCATION (parms));\n \t}\n@@ -14109,9 +14099,6 @@ grokparms (tree parmlist, tree *parms)\n \t      type = build_pointer_type (type);\n \t      TREE_TYPE (decl) = type;\n \t    }\n-\t  else if (abstract_virtuals_error (decl, type))\n-\t    /* Ignore any default argument.  */\n-\t    init = NULL_TREE;\n \t  else if (cxx_dialect < cxx17 && INDIRECT_TYPE_P (type))\n \t    {\n \t      /* Before C++17 DR 393:\n@@ -17427,9 +17414,6 @@ complete_vars (tree type)\n       else\n \tix++;\n     }\n-\n-  /* Check for pending declarations which may have abstract type.  */\n-  complete_type_check_abstract (type);\n }\n \n /* If DECL is of a type which needs a cleanup, build and return an"}, {"sha": "1babf833d3212e45b0857b515ef820c49596bd6d", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -14932,9 +14932,6 @@ tsubst_arg_types (tree arg_types,\n           }\n         return error_mark_node;\n     }\n-    /* DR 657. */\n-    if (abstract_virtuals_error_sfinae (ACU_PARM, type, complain))\n-      return error_mark_node;\n \n     /* Do array-to-pointer, function-to-pointer conversion, and ignore\n        top-level qualifiers as required.  */\n@@ -15052,9 +15049,6 @@ tsubst_function_type (tree t,\n \t}\n       return error_mark_node;\n     }\n-  /* And DR 657. */\n-  if (abstract_virtuals_error_sfinae (ACU_RETURN, return_type, complain))\n-    return error_mark_node;\n \n   if (!late_return_type_p)\n     {\n@@ -15880,9 +15874,6 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n \t    return error_mark_node;\n \t  }\n \n-\tif (abstract_virtuals_error_sfinae (ACU_ARRAY, type, complain))\n-\t  return error_mark_node;\n-\n \tr = build_cplus_array_type (type, domain);\n \n \tif (!valid_array_size_p (input_location, r, in_decl,"}, {"sha": "412869946a5393b895be148d3da164ddc243e4c2", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 152, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -123,123 +123,6 @@ cxx_readonly_error (location_t loc, tree arg, enum lvalue_use errstring)\n     readonly_error (loc, arg, errstring);\n }\n \f\n-/* Structure that holds information about declarations whose type was\n-   incomplete and we could not check whether it was abstract or not.  */\n-\n-struct GTY((chain_next (\"%h.next\"), for_user)) pending_abstract_type {\n-  /* Declaration which we are checking for abstractness. It is either\n-     a DECL node, or an IDENTIFIER_NODE if we do not have a full\n-     declaration available.  */\n-  tree decl;\n-\n-  /* Type which will be checked for abstractness.  */\n-  tree type;\n-\n-  /* Kind of use in an unnamed declarator.  */\n-  enum abstract_class_use use;\n-\n-  /* Position of the declaration. This is only needed for IDENTIFIER_NODEs,\n-     because DECLs already carry locus information.  */\n-  location_t locus;\n-\n-  /* Link to the next element in list.  */\n-  struct pending_abstract_type* next;\n-};\n-\n-struct abstract_type_hasher : ggc_ptr_hash<pending_abstract_type>\n-{\n-  typedef tree compare_type;\n-  static hashval_t hash (pending_abstract_type *);\n-  static bool equal (pending_abstract_type *, tree);\n-};\n-\n-/* Compute the hash value of the node VAL. This function is used by the\n-   hash table abstract_pending_vars.  */\n-\n-hashval_t\n-abstract_type_hasher::hash (pending_abstract_type *pat)\n-{\n-  return (hashval_t) TYPE_UID (pat->type);\n-}\n-\n-\n-/* Compare node VAL1 with the type VAL2. This function is used by the\n-   hash table abstract_pending_vars.  */\n-\n-bool\n-abstract_type_hasher::equal (pending_abstract_type *pat1, tree type2)\n-{\n-  return (pat1->type == type2);\n-}\n-\n-/* Hash table that maintains pending_abstract_type nodes, for which we still\n-   need to check for type abstractness.  The key of the table is the type\n-   of the declaration.  */\n-static GTY (()) hash_table<abstract_type_hasher> *abstract_pending_vars = NULL;\n-\n-static int abstract_virtuals_error_sfinae (tree, tree, abstract_class_use, tsubst_flags_t);\n-\n-/* This function is called after TYPE is completed, and will check if there\n-   are pending declarations for which we still need to verify the abstractness\n-   of TYPE, and emit a diagnostic (through abstract_virtuals_error) if TYPE\n-   turned out to be incomplete.  */\n-\n-void\n-complete_type_check_abstract (tree type)\n-{\n-  struct pending_abstract_type *pat;\n-  location_t cur_loc = input_location;\n-\n-  gcc_assert (COMPLETE_TYPE_P (type));\n-\n-  if (!abstract_pending_vars)\n-    return;\n-\n-  /* Retrieve the list of pending declarations for this type.  */\n-  pending_abstract_type **slot\n-    = abstract_pending_vars->find_slot_with_hash (type, TYPE_UID (type),\n-\t\t\t\t\t\t  NO_INSERT);\n-  if (!slot)\n-    return;\n-  pat = *slot;\n-  gcc_assert (pat);\n-\n-  /* If the type is not abstract, do not do anything.  */\n-  if (CLASSTYPE_PURE_VIRTUALS (type))\n-    {\n-      struct pending_abstract_type *prev = 0, *next;\n-\n-      /* Reverse the list to emit the errors in top-down order.  */\n-      for (; pat; pat = next)\n-\t{\n-\t  next = pat->next;\n-\t  pat->next = prev;\n-\t  prev = pat;\n-\t}\n-      pat = prev;\n-\n-      /* Go through the list, and call abstract_virtuals_error for each\n-\telement: it will issue a diagnostic if the type is abstract.  */\n-      while (pat)\n-\t{\n-\t  gcc_assert (type == pat->type);\n-\n-\t  /* Tweak input_location so that the diagnostic appears at the correct\n-\t    location. Notice that this is only needed if the decl is an\n-\t    IDENTIFIER_NODE.  */\n-\t  input_location = pat->locus;\n-\t  abstract_virtuals_error_sfinae (pat->decl, pat->type, pat->use,\n-\t\t\t\t\t  tf_warning_or_error);\n-\t  pat = pat->next;\n-\t}\n-    }\n-\n-  abstract_pending_vars->clear_slot (slot);\n-\n-  input_location = cur_loc;\n-}\n-\n-\n /* If TYPE has abstract virtual functions, issue an error about trying\n    to create an object of that type.  DECL is the object declared, or\n    NULL_TREE if the declaration is unavailable, in which case USE specifies\n@@ -252,6 +135,13 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n {\n   vec<tree, va_gc> *pure;\n \n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    {\n+      decl = NULL_TREE;\n+      use = ACU_ARRAY;\n+      type = strip_array_types (type);\n+    }\n+\n   /* This function applies only to classes. Any other entity can never\n      be abstract.  */\n   if (!CLASS_TYPE_P (type))\n@@ -266,38 +156,6 @@ abstract_virtuals_error_sfinae (tree decl, tree type, abstract_class_use use,\n     complete_type (type);\n #endif\n \n-  /* If the type is incomplete, we register it within a hash table,\n-     so that we can check again once it is completed. This makes sense\n-     only for objects for which we have a declaration or at least a\n-     name.  */\n-  if (!COMPLETE_TYPE_P (type) && (complain & tf_error))\n-    {\n-      struct pending_abstract_type *pat;\n-\n-      gcc_assert (!decl || DECL_P (decl) || identifier_p (decl));\n-\n-      if (!abstract_pending_vars)\n-\tabstract_pending_vars\n-\t  = hash_table<abstract_type_hasher>::create_ggc (31);\n-\n-      pending_abstract_type **slot\n-       \t= abstract_pending_vars->find_slot_with_hash (type, TYPE_UID (type),\n-\t\t\t\t\t\t      INSERT);\n-\n-      pat = ggc_alloc<pending_abstract_type> ();\n-      pat->type = type;\n-      pat->decl = decl;\n-      pat->use = use;\n-      pat->locus = ((decl && DECL_P (decl))\n-\t\t    ? DECL_SOURCE_LOCATION (decl)\n-\t\t    : input_location);\n-\n-      pat->next = *slot;\n-      *slot = pat;\n-\n-      return 0;\n-    }\n-\n   if (!TYPE_SIZE (type))\n     /* TYPE is being defined, and during that time\n        CLASSTYPE_PURE_VIRTUALS holds the inline friends.  */\n@@ -2594,6 +2452,3 @@ require_complete_eh_spec_types (tree fntype, tree decl)\n \t}\n     }\n }\n-\n-\f\n-#include \"gt-cp-typeck2.h\""}, {"sha": "6ded7ec7547601cfccdd47eeeaa5cb2cb70c76f2", "filename": "gcc/testsuite/g++.dg/other/abstract1.C", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract1.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -5,34 +5,38 @@\n // c++/9256: Make sure that a pointer to an array of abstract elements\n //  cannot be created, not even during template substitution (DR337).\n \n+// Changed massively by P0929R2: now only creating an object of the array type\n+// is ill-formed, not merely forming the array type.\n+\n struct Abstract { virtual void f() = 0; };  // { dg-message \"note\" } \n struct Complete { void f(); };\n \n \n /*\n  * TEST 1\n- * Arrays of abstract elements cannot be declared.\n+ * Arrays of abstract elements cannot be defined.\n  */\n \n Abstract a0[2];        // { dg-error \"\" }\n-Abstract (*a1)[2];     // { dg-error \"\" }\n-Abstract (**a2)[2];    // { dg-error \"\" }\n-Abstract (***a3)[2];   // { dg-error \"\" }\n+Abstract (*a1)[2];\n+Abstract (**a2)[2];\n+Abstract (***a3)[2];\n Abstract *a4;\n Abstract *a5[2];\n-Abstract (*a6[2])[2];  // { dg-error \"\" }\n+Abstract (*a6[2])[2];\n Abstract **a7[2];\n-Abstract *(*a8[2])[2];  \n-Abstract (**a9[2])[2]; // { dg-error \"\" }\n+Abstract *(*a8[2])[2];\n+Abstract (**a9[2])[2];\n \n /*\n  * TEST 2\n- * If a pointer to an array of abstract elements is created during template\n+ * If an array of abstract elements is created during template\n  *  instantiation, an error should occur.\n  */\n \n template <class T> struct K {\n-  T (*a)[2];   // { dg-error \"abstract class type\" }\n+  T (*a1)[2];\n+  T (a2)[2];   // { dg-error \"abstract\" }\n };\n \n template struct K<Abstract>;  // { dg-message \"required\" }\n@@ -41,8 +45,9 @@ template struct K<Abstract>;  // { dg-message \"required\" }\n \n /*\n  * TEST 3\n- * Deducing an array of abstract elements during type deduction is a silent\n- *  failure (rejects overload).\n+\n+ * Deducing an array of abstract elements during type deduction is no longer a\n+ *  silent failure.\n  */\n \n template <bool> struct StaticAssert;\n@@ -54,6 +59,6 @@ typedef struct { char x[2]; } No;\n template<typename U> No  is_abstract(U (*k)[1]);\n template<typename U> Yes is_abstract(...);\n \n-StaticAssert<sizeof(is_abstract<Abstract>(0)) == sizeof(Yes)> b1;\n+StaticAssert<sizeof(is_abstract<Abstract>(0)) == sizeof(No)> b1;\n StaticAssert<sizeof(is_abstract<Complete>(0)) == sizeof(No)> b2;\n StaticAssert<sizeof(is_abstract<int>(0)) == sizeof(No)> b3;"}, {"sha": "0a8009e9bb3964519b4e8ae5df811dfe88bb39b2", "filename": "gcc/testsuite/g++.dg/other/abstract2.C", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract2.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -5,54 +5,59 @@\n namespace N1 {\n   struct X;\n \n-  struct Y1 {\n-    void g(X parm1);         // { dg-error \"abstract\" }\n-    void g(X parm2[2]);      // { dg-error \"abstract\" }\n-    void g(X (*parm3)[2]);   // { dg-error \"abstract\" }\n+  struct X {  // { dg-message \"note\" }\n+    virtual void xfunc(void) = 0;  // { dg-message \"note\" }\n   };\n \n+  struct Y1 {\n+    void g(X parm1) {}         // { dg-error \"abstract\" }\n+    void g(X parm2[2]) {}\n+    void g(X (*parm3)[2]) {}\n+  };\n \n   template <int N>\n   struct Y2 {\n-    void g(X parm4);         // { dg-error \"abstract\" }\n-    void g(X parm5[2]);      // { dg-error \"abstract\" }\n-    void g(X (*parm6)[2]);   // { dg-error \"abstract\" }\n+    void g(X parm4) {}         // { dg-error \"abstract\" }\n+    void g(X parm5[2]) {}\n+    void g(X (*parm6)[2]) {}\n   };\n \n-  struct X {  // { dg-message \"note\" }\n-    virtual void xfunc(void) = 0;  // { dg-message \"note\" }\n-  };\n+  template struct Y2<42>;\n }\n \n namespace N2 {\n   struct X1 { // { dg-message \"note\" }\n     virtual void xfunc(void) = 0;  // { dg-message \"note\" }\n-    void g(X1 parm7);        // { dg-error \"abstract\" }\n-    void g(X1 parm8[2]);     // { dg-error \"abstract\" }\n-    void g(X1 (*parm9)[2]);  // { dg-error \"abstract\" }\n+    void g(X1 parm7) {}        // { dg-error \"abstract\" }\n+    void g(X1 parm8[2]) {}\n+    void g(X1 (*parm9)[2]) {}\n   };\n \n   template <int N>\n   struct X2 { // { dg-message \"note\" }\n     virtual void xfunc(void) = 0; // { dg-message \"note\" }\n-    void g(X2 parm10);        // { dg-error \"abstract\" }\n-    void g(X2 parm11[2]);     // { dg-error \"abstract\" }\n-    void g(X2 (*parm12)[2]);  // { dg-error \"abstract\" }\n+    void g(X2 parm10) {}        // { dg-error \"abstract\" }\n+    void g(X2 parm11[2]) {}\n+    void g(X2 (*parm12)[2]) {}\n   };\n+\n+  template struct X2<42>;\n }\n \n namespace N3 {\n   struct X { // { dg-message \"note\" }\n     virtual void xfunc(void) = 0;  // { dg-message \"note\" }\n   };\n-  void g(X parm13);          // { dg-error \"abstract\" }\n-  void g(X parm14[2]);       // { dg-error \"abstract\" }\n-  void g(X (*parm15)[2]);    // { dg-error \"abstract\" }\n-\n-  template <int N> \n-  void g(X parm16);          // { dg-error \"abstract\" }\n-  template <int N> \n-  void g(X parm17[2]);       // { dg-error \"abstract\" }\n-  template <int N> \n-  void g(X (*parm18)[2]);    // { dg-error \"abstract\" }\n+  void g(X parm13) {}          // { dg-error \"abstract\" }\n+  void g(X parm14[2]) {}\n+  void g(X (*parm15)[2]) {}\n+\n+  template <int N>\n+  void g(X parm16) {}          // { dg-error \"abstract\" }\n+  template <int N>\n+  void g(X parm17[2]) {}\n+  template <int N>\n+  void g(X (*parm18)[2]) {}\n+\n+  template void g<42>(X);\n }"}, {"sha": "6a8c8c75918d53daa1178a22c411c1d4e5bf5e70", "filename": "gcc/testsuite/g++.dg/other/abstract4.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract4.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -13,6 +13,6 @@ struct Abs\n \n int main()\n {\n-  S<Abs(int)> s;     // { dg-error \"abstract\" }\n-  foo<Abs(int)>();   // { dg-error \"abstract\" }\n+  S<Abs(int)> s;\n+  foo<Abs(int)>();\n }"}, {"sha": "c17d60d3a3a0ae53c2d5816c8a5d55e4441e48bb", "filename": "gcc/testsuite/g++.dg/other/abstract5.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract5.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -3,4 +3,4 @@ struct A\n   virtual void f() = 0;\n };\n \n-typedef A (*fp)();\t\t// { dg-error \"abstract\" }\n+typedef A (*fp)();"}, {"sha": "bc5afbbdc7f05a547535b4c65e00f5026ac8d783", "filename": "gcc/testsuite/g++.dg/other/abstract8.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fabstract8.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -0,0 +1,40 @@\n+// P0929R2: Checking for abstract class types.\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options -Wno-return-type }\n+\n+struct A\n+{\n+ virtual void f() = 0;\n+};\n+\n+struct B\n+{\n+  A a;\t\t\t\t// { dg-error \"abstract\" }\n+  A ar[4];\t\t\t// { dg-error \"abstract\" }\n+};\n+\n+using Aa = A[4];\t\t// OK\n+Aa* aap;\t\t\t// OK\n+\n+extern A a;\t\t\t// OK\n+extern Aa aa;\t\t\t// OK\n+A f();\t\t\t\t// OK\n+void g(A);\t\t\t// OK\n+\n+A a;\t\t\t\t// { dg-error \"abstract\" }\n+Aa aa;\t\t\t\t// { dg-error \"abstract\" }\n+A f() { }\t\t\t// { dg-error \"abstract\" }\n+void g(A) { }\t\t\t// { dg-error \"abstract\" }\n+\n+int main()\n+{\n+  (A(a));\t\t\t// { dg-error \"abstract\" }\n+  A{};\t\t\t\t// { dg-error \"abstract\" }\n+  static_cast<A>(a);\t\t// { dg-error \"abstract\" }\n+  Aa{};\t\t\t\t// { dg-error \"abstract\" }\n+  f();\t\t\t\t// { dg-error \"abstract\" }\n+  decltype(f())* p;\t\t// OK\n+  g(a);\t\t\t\t// { dg-error \"abstract\" }\n+\n+  throw a;\t\t\t// { dg-error \"abstract\" }\n+}"}, {"sha": "36c11e6591867c3329701458af0ea98570f84dd3", "filename": "gcc/testsuite/g++.dg/template/sfinae-dr657.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr657.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr657.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fsfinae-dr657.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -1,6 +1,7 @@\n-// DR 657\n-// Test that a return or parameter type with abstract class type causes a\n-// deduction failure.\n+// DR 657 SUPERSEDED BY DR 1646\n+// Test that a return or parameter type with abstract class type DOES NOT cause\n+// a deduction failure, but there is no implicit conversion sequence for\n+// a parameter of abstract class type.\n \n struct A\n {\n@@ -17,6 +18,6 @@ template<class T> int arg(...);\n \n int main()\n {\n-  int i = declval<A>();\n+  int i = declval<A>();\t\t// { dg-error \"ambiguous\" }\n   i = arg<A>(1);\n }"}, {"sha": "4534bd16aadb5a6d4dd4978c788216675ebde1ad", "filename": "gcc/testsuite/g++.old-deja/g++.other/decl3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdecl3.C?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -13,7 +13,7 @@ struct cow_t { // { dg-message \"pure\" }\n \n int main()\n {\n-  cow_t cow[2];  // { dg-error \"invalid abstract type\" }\n+  cow_t cow[2];  // { dg-error \"abstract\" }\n   cow[0].f();\n   return 0;\n }"}, {"sha": "cce481292bd636fbd86569a344dde4990beea6fd", "filename": "libstdc++-v3/testsuite/20_util/result_of/sfinae_friendly_1.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/baf38d2e363971ed8baa5f82b2eaf21cd8e74aae/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fresult_of%2Fsfinae_friendly_1.cc?ref=baf38d2e363971ed8baa5f82b2eaf21cd8e74aae", "patch": "@@ -379,19 +379,19 @@ static_assert(is_type<std::result_of<ident_functor(const volatile Abstract&)>,\n \t      const volatile Abstract&>(), \"Error!\");\n \n static_assert(!has_type<std::result_of<ident_functor(int(&&)[1])>>(), \"Error!\");\n-static_assert(!has_type<std::result_of<ident_functor(Abstract&&)>>(), \"Error!\");\n+static_assert(is_type<std::result_of<ident_functor(Abstract&&)>,Abstract>(), \"Error!\");\n static_assert(!has_type<std::result_of<ident_functor(const int(&&)[1])>>(),\n \t      \"Error!\");\n-static_assert(!has_type<std::result_of<ident_functor(const Abstract&&)>>(),\n+static_assert(is_type<std::result_of<ident_functor(const Abstract&&)>,const Abstract>(),\n \t      \"Error!\");\n static_assert(!has_type<std::result_of<ident_functor_noref(int(&)[1])>>(),\n \t      \"Error!\");\n static_assert(!has_type<std::result_of<ident_functor_noref\n \t      (const int(&)[1])>>(), \"Error!\");\n-static_assert(!has_type<std::result_of<ident_functor_noref(Abstract&)>>(),\n+static_assert(is_type<std::result_of<ident_functor_noref(Abstract&)>,Abstract>(),\n \t      \"Error!\");\n-static_assert(!has_type<std::result_of\n-\t      <ident_functor_noref(const Abstract&)>>(), \"Error!\");\n+static_assert(is_type<std::result_of\n+\t      <ident_functor_noref(const Abstract&)>,const Abstract>(), \"Error!\");\n static_assert(!has_type<std::result_of<ident_functor_noref(void(&)())>>(),\n \t      \"Error!\");\n static_assert(!has_type<std::result_of<ident_functor_noref(void(&&)())>>(),"}]}