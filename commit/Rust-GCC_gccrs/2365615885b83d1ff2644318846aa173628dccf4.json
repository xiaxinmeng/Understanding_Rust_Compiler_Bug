{"sha": "2365615885b83d1ff2644318846aa173628dccf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjM2NTYxNTg4NWI4M2QxZmYyNjQ0MzE4ODQ2YWExNzM2MjhkY2NmNA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-22T01:08:46Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-22T01:08:46Z"}, "message": "cp-tree.h (SET_BINFO_NEW_VTABLE_MARKED): Add sanity checks.\n\n\t* cp-tree.h (SET_BINFO_NEW_VTABLE_MARKED): Add sanity checks.\n\t(VTT_NAME_PREFIX): New macro.\n\t(CTOR_VTBL_NAME_PREFIX): Likewise.\n\t(get_ctor_vtbl_name): New function.\n\t* class.c (get_vtable_name): Simplify.\n\t(get_vtt_name): New function.\n\t(get_vtable_decl): Don't set IDENTIFIER_GLOBAL_VALUE.\n\t(dfs_mark_primary_bases): Update the CLASSTYPE_VBASECLASSES list\n\twhen a virtual base becomes primary.\n\t(finish_struct_1): Set CLASSTYPE_VFIELDS a little earlier.  Build\n\tVTTs.\n\t(finish_vtbls): Adjust calls to accumulate_vtbl_inits to pass in\n\tadditional parameters.\n\t(dfs_finish_vtbls): Don't clear BINFO_NEW_VTABLE_MARKED.\n\t(initialize_array): New function.\n\t(build_vtt): Likewise.\n\t(build_vtt_inits): Likewise.\n\t(dfs_build_vtt_inits): Likewise.\n\t(dfs_fixup_binfo_vtbls): Likewise.\n\t(build_ctor_vtbl_group): Likewise.\n\t(initialize_vtable): Use initialize_array.\n\t(accumulate_vtbl_inits): Reimplement to handle construction\n\tvtables.\n\t(dfs_accumulate_vtbl_inits): Likewise.\n\t(bulid_vtbl_initializer): Adjust parameter name.\n\t* method.c (build_typename_overload): Remove #if 0'd code.\n\t(get_ctor_vtbl_name): New function.\n\t* search.c (dfs_walk_real): Use BINFO_N_BASETYPES.\n\t(init_vbase_pointers): Don't mess with the TREE_CHAIN of a binfo.\n\nFrom-SVN: r34069", "tree": {"sha": "a3ce5a7731f9c1eb90d7f0928f3936935b196047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a3ce5a7731f9c1eb90d7f0928f3936935b196047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2365615885b83d1ff2644318846aa173628dccf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2365615885b83d1ff2644318846aa173628dccf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2365615885b83d1ff2644318846aa173628dccf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2365615885b83d1ff2644318846aa173628dccf4/comments", "author": null, "committer": null, "parents": [{"sha": "f85cf63648f6612b7638347f387ba2971ddaf820", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f85cf63648f6612b7638347f387ba2971ddaf820", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f85cf63648f6612b7638347f387ba2971ddaf820"}], "stats": {"total": 536, "additions": 446, "deletions": 90}, "files": [{"sha": "9f63976d9b1c900d1f4cd77f2bd0fb2892cf07f9", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2365615885b83d1ff2644318846aa173628dccf4", "patch": "@@ -1,5 +1,35 @@\n 2000-05-21  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.h (SET_BINFO_NEW_VTABLE_MARKED): Add sanity checks.\n+\t(VTT_NAME_PREFIX): New macro.\n+\t(CTOR_VTBL_NAME_PREFIX): Likewise.\n+\t(get_ctor_vtbl_name): New function.\n+\t* class.c (get_vtable_name): Simplify.\n+\t(get_vtt_name): New function.\n+\t(get_vtable_decl): Don't set IDENTIFIER_GLOBAL_VALUE.\n+\t(dfs_mark_primary_bases): Update the CLASSTYPE_VBASECLASSES list\n+\twhen a virtual base becomes primary.\n+\t(finish_struct_1): Set CLASSTYPE_VFIELDS a little earlier.  Build\n+\tVTTs.\n+\t(finish_vtbls): Adjust calls to accumulate_vtbl_inits to pass in\n+\tadditional parameters.\n+\t(dfs_finish_vtbls): Don't clear BINFO_NEW_VTABLE_MARKED.\n+\t(initialize_array): New function.\n+\t(build_vtt): Likewise.\n+\t(build_vtt_inits): Likewise.\n+\t(dfs_build_vtt_inits): Likewise.\n+\t(dfs_fixup_binfo_vtbls): Likewise.\n+\t(build_ctor_vtbl_group): Likewise.\n+\t(initialize_vtable): Use initialize_array.\n+\t(accumulate_vtbl_inits): Reimplement to handle construction\n+\tvtables.\n+\t(dfs_accumulate_vtbl_inits): Likewise.\n+\t(bulid_vtbl_initializer): Adjust parameter name.\n+\t* method.c (build_typename_overload): Remove #if 0'd code.\n+\t(get_ctor_vtbl_name): New function.\n+\t* search.c (dfs_walk_real): Use BINFO_N_BASETYPES.\n+\t(init_vbase_pointers): Don't mess with the TREE_CHAIN of a binfo.\n+\t\n \t* cp-tree.h (struct lang_type): Remove search_slot.\n \t(CLASSTYPE_SEARCH_SLOT): Remove.\n \t(emit_base_init): Change prototype."}, {"sha": "3fcb0f400987222f4ad888de391b44e81cc54904", "filename": "gcc/cp/class.c", "status": "modified", "additions": 369, "deletions": 82, "changes": 451, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=2365615885b83d1ff2644318846aa173628dccf4", "patch": "@@ -93,7 +93,8 @@ static tree get_basefndecls PARAMS ((tree, tree));\n static int build_primary_vtable PARAMS ((tree, tree));\n static int build_secondary_vtable PARAMS ((tree, tree));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n-static tree dfs_accumulate_vtbl_inits PARAMS ((tree, void *));\n+static tree dfs_accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree,\n+\t\t\t\t\t       tree));\n static void finish_vtbls PARAMS ((tree));\n static void modify_vtable_entry PARAMS ((tree, tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n@@ -157,6 +158,7 @@ static void dump_class_hierarchy_r PARAMS ((tree, tree, int));\n extern void dump_class_hierarchy PARAMS ((tree));\n static tree build_vtable PARAMS ((tree, tree, tree));\n static void initialize_vtable PARAMS ((tree, tree));\n+static void initialize_array PARAMS ((tree, tree));\n static void layout_nonempty_base_or_field PARAMS ((record_layout_info,\n \t\t\t\t\t\t   tree, tree,\n \t\t\t\t\t\t   varray_type));\n@@ -166,7 +168,7 @@ static tree dfs_search_base_offsets PARAMS ((tree, void *));\n static int layout_conflict_p PARAMS ((tree, varray_type));\n static unsigned HOST_WIDE_INT end_of_class PARAMS ((tree, int));\n static void layout_empty_base PARAMS ((tree, tree, varray_type));\n-static void accumulate_vtbl_inits PARAMS ((tree, tree));\n+static void accumulate_vtbl_inits PARAMS ((tree, tree, tree, tree, tree));\n static void set_vindex PARAMS ((tree, tree, int *));\n static tree build_rtti_vtbl_entries PARAMS ((tree, tree));\n static void build_vcall_and_vbase_vtbl_entries PARAMS ((tree, \n@@ -177,6 +179,11 @@ static void clone_constructors_and_destructors PARAMS ((tree));\n static tree build_clone PARAMS ((tree, tree));\n static void update_vtable_entry_for_fn PARAMS ((tree, tree, tree, tree *));\n static tree copy_virtuals PARAMS ((tree));\n+static void build_ctor_vtbl_group PARAMS ((tree, tree));\n+static void build_vtt PARAMS ((tree));\n+static tree *build_vtt_inits PARAMS ((tree, tree, tree *));\n+static tree dfs_build_vtt_inits PARAMS ((tree, void *));\n+static tree dfs_fixup_binfo_vtbls PARAMS ((tree, void *));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -621,22 +628,19 @@ static tree\n get_vtable_name (type)\n      tree type;\n {\n-  tree type_id = build_typename_overload (type);\n-  char *buf = (char *) alloca (strlen (VTABLE_NAME_PREFIX)\n-\t\t\t       + IDENTIFIER_LENGTH (type_id) + 2);\n-  const char *ptr = IDENTIFIER_POINTER (type_id);\n-  int i;\n-  for (i = 0; ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++) ;\n-#if 0\n-  /* We don't take off the numbers; build_secondary_vtable uses the\n-     DECL_ASSEMBLER_NAME for the type, which includes the number\n-     in `3foo'.  If we were to pull them off here, we'd end up with\n-     something like `_vt.foo.3bar', instead of a uniform definition.  */\n-  while (ptr[i] >= '0' && ptr[i] <= '9')\n-    i += 1;\n-#endif\n-  sprintf (buf, \"%s%s\", VTABLE_NAME_PREFIX, ptr+i);\n-  return get_identifier (buf);\n+  return build_overload_with_type (get_identifier (VTABLE_NAME_PREFIX),\n+\t\t\t\t   type);\n+}\n+\n+/* Return an IDENTIFIER_NODE for the name of the virtual table table\n+   for TYPE.  */\n+\n+static tree\n+get_vtt_name (type)\n+     tree type;\n+{\n+  return build_overload_with_type (get_identifier (VTT_NAME_PREFIX),\n+\t\t\t\t   type);\n }\n \n /* Return the offset to the main vtable for a given base BINFO.  */\n@@ -727,7 +731,8 @@ get_vtable_decl (type, complete)\n   \n   decl = build_vtable (type, name, void_type_node);\n   decl = pushdecl_top_level (decl);\n-  SET_IDENTIFIER_GLOBAL_VALUE (name, decl);\n+  my_friendly_assert (IDENTIFIER_GLOBAL_VALUE (name) == decl,\n+\t\t      20000517);\n   \n   /* At one time the vtable info was grabbed 2 words at a time.  This\n      fails on sparc unless you have 8-byte alignment.  (tiemann) */\n@@ -1692,15 +1697,23 @@ dfs_mark_primary_bases (binfo, data)\n   else\n     {\n       tree shared_binfo;\n+      tree type;\n \n-      shared_binfo \n-\t= binfo_for_vbase (BINFO_TYPE (base_binfo), (tree) data);\n+      type = (tree) data;\n+      shared_binfo = binfo_for_vbase (BINFO_TYPE (base_binfo), type);\n \n       /* If this virtual base is not already primary somewhere else in\n \t the hiearchy, then we'll be using this copy.  */\n       if (!BINFO_VBASE_PRIMARY_P (shared_binfo))\n \t{\n-\t  BINFO_VBASE_PRIMARY_P (shared_binfo) = 1;\n+\t  /* Make sure the CLASSTYPE_VBASECLASSES list contains the\n+\t     primary copy; it's the one that really exists.  */\n+\t  if (base_binfo != shared_binfo)\n+\t    TREE_VALUE (purpose_member (BINFO_TYPE (base_binfo),\n+\t\t\t\t\tCLASSTYPE_VBASECLASSES (type)))\n+\t      = base_binfo;\n+\n+\t  BINFO_VBASE_PRIMARY_P (base_binfo) = 1;\n \t  BINFO_PRIMARY_MARKED_P (base_binfo) = 1;\n \t}\n     }\n@@ -4900,6 +4913,12 @@ finish_struct_1 (t)\n   overridden_virtuals \n     = modify_all_vtables (t, &vfuns, nreverse (overridden_virtuals));\n \n+  /* If we created a new vtbl pointer for this class, add it to the\n+     list.  */\n+  if (TYPE_VFIELD (t) && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n+    CLASSTYPE_VFIELDS (t) \n+      = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n+\n   /* If necessary, create the primary vtable for this class.  */\n   if (new_virtuals\n       || overridden_virtuals\n@@ -4962,12 +4981,6 @@ finish_struct_1 (t)\n \t= chainon (TYPE_BINFO_VIRTUALS (t), overridden_virtuals);\n     }\n \n-  /* If we created a new vtbl pointer for this class, add it to the\n-     list.  */\n-  if (TYPE_VFIELD (t) && !CLASSTYPE_HAS_PRIMARY_BASE_P (t))\n-    CLASSTYPE_VFIELDS (t) \n-      = chainon (CLASSTYPE_VFIELDS (t), build_tree_list (NULL_TREE, t));\n-\n   finish_struct_bits (t);\n \n   /* Complete the rtl for any static member objects of the type we're\n@@ -5020,6 +5033,8 @@ finish_struct_1 (t)\n   /* Make the rtl for any new vtables we have created, and unmark\n      the base types we marked.  */\n   finish_vtbls (t);\n+  /* Build the VTT for T.  */\n+  build_vtt (t);\n \n   if (TYPE_VFIELD (t))\n     {\n@@ -6373,16 +6388,16 @@ finish_vtbls (t)\n \t first, followed by the non-virtual secondary vtables in\n \t inheritance graph order.  */\n       list = build_tree_list (TYPE_BINFO_VTABLE (t), NULL_TREE);\n-      TREE_TYPE (list) = t;\n-      accumulate_vtbl_inits (TYPE_BINFO (t), list);\n+      accumulate_vtbl_inits (TYPE_BINFO (t), TYPE_BINFO (t),\n+\t\t\t     TYPE_BINFO (t), t, list);\n       /* Then come the virtual bases, also in inheritance graph\n \t order.  */\n       for (vbase = TYPE_BINFO (t); vbase; vbase = TREE_CHAIN (vbase))\n \t{\n \t  if (!TREE_VIA_VIRTUAL (vbase))\n \t    continue;\n-\t  accumulate_vtbl_inits (binfo_for_vbase (BINFO_TYPE (vbase), t),\n-\t\t\t\t list);\n+\n+\t  accumulate_vtbl_inits (vbase, vbase, TYPE_BINFO (t), t, list);\n \t}\n \n       if (TYPE_BINFO_VTABLE (t))\n@@ -6406,14 +6421,11 @@ dfs_finish_vtbls (binfo, data)\n {\n   tree t = (tree) data;\n \n-  if (!BINFO_PRIMARY_MARKED_P (binfo)\n-      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n+  if (BINFO_NEW_VTABLE_MARKED (binfo, t))\n     initialize_vtable (binfo, \n \t\t       build_vtbl_initializer (binfo, binfo, t, \n \t\t\t\t\t       TYPE_BINFO (t), NULL));\n \n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n   SET_BINFO_MARKED (binfo);\n \n   return NULL_TREE;\n@@ -6426,107 +6438,382 @@ initialize_vtable (binfo, inits)\n      tree binfo;\n      tree inits;\n {\n-  tree context;\n   tree decl;\n \n   layout_vtable_decl (binfo, list_length (inits));\n   decl = get_vtbl_decl_for_binfo (binfo);\n+  initialize_array (decl, inits);\n+}\n+\n+/* Initialize DECL (a declaration for a namespace-scope array) with\n+   the INITS.  */\n+\n+static void\n+initialize_array (decl, inits)\n+  tree decl;\n+  tree inits;\n+{\n+  tree context;\n+\n   context = DECL_CONTEXT (decl);\n-  DECL_CONTEXT (decl) = 0;\n+  DECL_CONTEXT (decl) = NULL_TREE;\n   DECL_INITIAL (decl) = build_nt (CONSTRUCTOR, NULL_TREE, inits);\n   cp_finish_decl (decl, DECL_INITIAL (decl), NULL_TREE, 0);\n   DECL_CONTEXT (decl) = context;\n }\n \n+/* Build the VTT (virtual table table) for T.  */\n+\n+static void\n+build_vtt (t)\n+     tree t;\n+{\n+  tree inits;\n+  tree type;\n+  tree vtt;\n+\n+  /* Under the old ABI, we don't use VTTs.  */\n+  if (!flag_new_abi)\n+    return;\n+\n+  /* Build up the initializers for the VTT.  */\n+  inits = NULL_TREE;\n+  build_vtt_inits (TYPE_BINFO (t), t, &inits);\n+\n+  /* If we didn't need a VTT, we're done.  */\n+  if (!inits)\n+    return;\n+\n+  /* Figure out the type of the VTT.  */\n+  type = build_index_type (size_int (list_length (inits)));\n+  type = build_cplus_array_type (const_ptr_type_node, type);\n+\t\t\t\t \n+  /* Now, build the VTT object itself.  */\n+  vtt = build_vtable (t, get_vtt_name (t), type);\n+  pushdecl_top_level (vtt);\n+  initialize_array (vtt, inits);\n+}\n+\n+/* Recursively build the VTT-initializer for BINFO (which is in the\n+   hierarchy dominated by T).  INITS points to the end of the\n+   initializer list to date.  */\n+\n+static tree *\n+build_vtt_inits (binfo, t, inits)\n+     tree binfo;\n+     tree t;\n+     tree *inits;\n+{\n+  int i;\n+  tree b;\n+  tree init;\n+  tree secondary_vptrs;\n+  int ctor_vtbl_p;\n+\n+  /* We only need VTTs for subobjects with virtual bases.  */\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n+    return inits;\n+\n+  /* We need to use a construction vtable if this is not the primary\n+     VTT.  */\n+  ctor_vtbl_p = !same_type_p (TREE_TYPE (binfo), t);\n+  if (ctor_vtbl_p)\n+    build_ctor_vtbl_group (binfo, t);\n+\n+  /* Add the address of the primary vtable for the complete object.  */\n+  init = BINFO_VTABLE (binfo);\n+  if (TREE_CODE (init) == TREE_LIST)\n+    init = TREE_PURPOSE (init);\n+  *inits = build_tree_list (NULL_TREE, init);\n+  inits = &TREE_CHAIN (*inits);\n+\n+  /* Recursively add the secondary VTTs for non-virtual bases.  */\n+  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+    {\n+      b = BINFO_BASETYPE (binfo, i);\n+      if (!TREE_VIA_VIRTUAL (b))\n+\tinits = build_vtt_inits (BINFO_BASETYPE (binfo, i), t, inits);\n+    }\n+\n+  /* Add secondary virtual pointers for all subobjects of BINFO with\n+     either virtual bases or virtual functions overridden along a\n+     virtual path between the declaration and D, except subobjects\n+     that are non-virtual primary bases.  */\n+  secondary_vptrs = build_tree_list (BINFO_TYPE (binfo), NULL_TREE);\n+  dfs_walk_real (binfo,\n+\t\t dfs_build_vtt_inits,\n+\t\t NULL,\n+\t\t dfs_unmarked_real_bases_queue_p,\n+\t\t secondary_vptrs);\n+  dfs_walk (binfo, dfs_fixup_binfo_vtbls, dfs_marked_real_bases_queue_p,\n+\t    BINFO_TYPE (binfo));\n+\n+  /* The secondary vptrs come back in reverse order.  After we reverse\n+     them, and add the INITS, the last init will be the first element\n+     of the chain.  */\n+  secondary_vptrs = TREE_VALUE (secondary_vptrs);\n+  if (secondary_vptrs)\n+    {\n+      *inits = nreverse (secondary_vptrs);\n+      inits = &TREE_CHAIN (secondary_vptrs);\n+      my_friendly_assert (*inits == NULL_TREE, 20000517);\n+    }\n+\n+  /* Add the secondary VTTs for virtual bases.  */\n+  for (b = TYPE_BINFO (BINFO_TYPE (binfo)); b; b = TREE_CHAIN (b))\n+    {\n+      tree vbase;\n+\n+      if (!TREE_VIA_VIRTUAL (b))\n+\tcontinue;\n+\n+      vbase = binfo_for_vbase (BINFO_TYPE (b), t);\n+      inits = build_vtt_inits (vbase, t, inits);\n+    }\n+\n+  return inits;\n+}\n+\n+/* Called from build_vtt_inits via dfs_walk.  */\n+\n+static tree\n+dfs_build_vtt_inits (binfo, data)\n+     tree binfo;\n+     void *data;\n+{\n+  tree l; \n+  tree t;\n+  tree init;\n+\n+  l = (tree) data;\n+  t = TREE_PURPOSE (l);\n+\n+  SET_BINFO_MARKED (binfo);\n+\n+  /* We don't care about bases that don't have vtables.  */\n+  if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n+    return NULL_TREE;\n+\n+  /* We're only interested in proper subobjects of T.  */\n+  if (same_type_p (BINFO_TYPE (binfo), t))\n+    return NULL_TREE;\n+\n+  /* We're not interested in non-virtual primary bases.  */\n+  if (!TREE_VIA_VIRTUAL (binfo) && BINFO_PRIMARY_MARKED_P (binfo))\n+    return NULL_TREE;\n+\n+  /* If BINFO doesn't have virtual bases, then we have to look to see\n+     whether or not any virtual functions were overidden along a\n+     virtual path between the declaration and T.  */\n+  if (!TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n+    /* FIXME: Implement this.  */\n+    ;\n+\n+  /* Add the initializer for this secondary vptr.  */\n+  init = BINFO_VTABLE (binfo);\n+  if (TREE_CODE (init) == TREE_LIST)\n+    init = TREE_PURPOSE (init);\n+\n+  TREE_VALUE (l) = tree_cons (NULL_TREE, init, TREE_VALUE (l));\n+  \n+  return NULL_TREE;\n+}\n+\n+/* Called from build_vtt_inits via dfs_walk.  */\n+\n+static tree\n+dfs_fixup_binfo_vtbls (binfo, data)\n+     tree binfo;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  CLEAR_BINFO_MARKED (binfo);\n+\n+  /* We don't care about bases that don't have vtables.  */\n+  if (!TYPE_VFIELD (BINFO_TYPE (binfo)))\n+    return NULL_TREE;\n+\n+  /* If we scribbled the construction vtable vptr into BINFO, clear it\n+     out now.  */\n+  if (TREE_CODE (BINFO_VTABLE (binfo)) == TREE_LIST)\n+    BINFO_VTABLE (binfo) = TREE_VALUE (BINFO_VTABLE (binfo));\n+\n+  return NULL_TREE;\n+}\n+\n+/* Build the construction vtable group for BINFO which is in the\n+   hierarchy dominated by T.  */\n+\n+static void\n+build_ctor_vtbl_group (binfo, t)\n+     tree binfo;\n+     tree t;\n+{\n+  tree list;\n+  tree type;\n+  tree vtbl;\n+  tree inits;\n+  tree id;\n+\n+  /* See if we've already create this construction vtable group.  */\n+  id = get_ctor_vtbl_name (t, binfo);\n+  if (IDENTIFIER_GLOBAL_VALUE (id))\n+    return;\n+\n+  /* Build a version of VTBL (with the wrong type) for use in\n+     constructing the addresses of secondary vtables in the\n+     construction vtable group.  */\n+  vtbl = build_vtable (BINFO_TYPE (binfo), id, vtable_entry_type);\n+  list = build_tree_list (vtbl, NULL_TREE);\n+  accumulate_vtbl_inits (binfo, TYPE_BINFO (TREE_TYPE (binfo)),\n+\t\t\t binfo, t, list);\n+\n+  /* Figure out the type of the construction vtable.  */\n+  type = build_index_type (size_int (list_length (inits)));\n+  type = build_cplus_array_type (vtable_entry_type, type);\n+  TREE_TYPE (vtbl) = type;\n+\n+  /* Initialize the construction vtable.  */\n+  pushdecl_top_level (vtbl);\n+  initialize_array (vtbl, inits);\n+}\n+\n /* Add the vtbl initializers for BINFO (and its non-primary,\n-   non-virtual bases) to the list of INITS.  */\n+   non-virtual bases) to the list of INITS.  BINFO is in the hierarchy\n+   dominated by T.  ORIG_BINFO must have the same type as BINFO, but\n+   may be different from BINFO if we are building a construction\n+   vtable.  RTTI_BINFO gives the object that should be used as the\n+   complete object for BINFO.  */\n \n static void\n-accumulate_vtbl_inits (binfo, inits)\n+accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, inits)\n      tree binfo;\n+     tree orig_binfo;\n+     tree rtti_binfo;\n+     tree t;\n      tree inits;\n {\n+  int i;\n+  int ctor_vtbl_p;\n+\n+  my_friendly_assert (same_type_p (BINFO_TYPE (binfo),\n+\t\t\t\t   BINFO_TYPE (orig_binfo)),\n+\t\t      20000517);\n+\n+  /* This is a construction vtable if the RTTI type is not the most\n+     derived type in the hierarchy.  */\n+  ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n+\n+  /* If we're building a construction vtable, we're not interested in\n+     subobjects that don't require construction vtables.  */\n+  if (ctor_vtbl_p \n+      && !TYPE_USES_VIRTUAL_BASECLASSES (BINFO_TYPE (binfo)))\n+    return;\n+\n+  /* Build the initializers for the BINFO-in-T vtable.  */\n+  TREE_VALUE (inits) \n+    = chainon (TREE_VALUE (inits),\n+\t       dfs_accumulate_vtbl_inits (binfo, orig_binfo,\n+\t\t\t\t\t  rtti_binfo, t, inits));\n+\t\t      \n   /* Walk the BINFO and its bases.  We walk in preorder so that as we\n      initialize each vtable we can figure out at what offset the\n-     secondary vtable lies from the primary vtable.  */\n-  dfs_walk_real (binfo,\n-\t\t dfs_accumulate_vtbl_inits,\n-\t\t NULL,\n-\t\t dfs_skip_vbases,\n-\t\t inits);\n+     secondary vtable lies from the primary vtable.  We can't use\n+     dfs_walk here because we need to iterate through bases of BINFO\n+     and RTTI_BINFO simultaneously.  */\n+  for (i = 0; i < BINFO_N_BASETYPES (binfo); ++i)\n+    {\n+      tree base_binfo;\n+\n+      base_binfo = BINFO_BASETYPE (binfo, i);\n+      /* Skip virtual bases.  */\n+      if (TREE_VIA_VIRTUAL (base_binfo))\n+\tcontinue;\n+      accumulate_vtbl_inits (base_binfo,\n+\t\t\t     BINFO_BASETYPE (orig_binfo, i),\n+\t\t\t     rtti_binfo,\n+\t\t\t     t,\n+\t\t\t     inits);\n+    }\n }\n \n /* Called from finish_vtbls via dfs_walk when using the new ABI.\n    Accumulates the vtable initializers for all of the vtables into\n-   TREE_VALUE (DATA).  */\n+   TREE_VALUE (DATA).  Returns the initializers for the BINFO vtable.  */\n \n static tree\n-dfs_accumulate_vtbl_inits (binfo, data)\n+dfs_accumulate_vtbl_inits (binfo, orig_binfo, rtti_binfo, t, l)\n      tree binfo;\n-     void *data;\n+     tree orig_binfo;\n+     tree rtti_binfo;\n+     tree t;\n+     tree l;\n {\n-  tree l;\n-  tree t;\n+  tree inits = NULL_TREE;\n+  int ctor_vtbl_p;\n \n-  l = (tree) data;\n-  t = TREE_TYPE (l);\n+  /* This is a construction vtable if the RTTI type is not the most\n+     derived type in the hierarchy.  */\n+  ctor_vtbl_p = !same_type_p (BINFO_TYPE (rtti_binfo), t);\n \n-  if (!BINFO_PRIMARY_MARKED_P (binfo)\n-      && CLASSTYPE_VFIELDS (BINFO_TYPE (binfo))\n-      && BINFO_NEW_VTABLE_MARKED (binfo, t))\n+  if (BINFO_NEW_VTABLE_MARKED (binfo, t)\n+      /* We need a new vtable, even for a primary base, when we're\n+\t building a construction vtable.  */\n+      || (ctor_vtbl_p && orig_binfo == rtti_binfo))\n     {\n-      tree inits;\n       tree vtbl;\n       tree index;\n       int non_fn_entries;\n \n       /* Compute the initializer for this vtable.  */\n-      inits = build_vtbl_initializer (binfo, binfo, t, TYPE_BINFO (t), \n+      inits = build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo,\n \t\t\t\t      &non_fn_entries);\n \n-      /* Set BINFO_VTABLE to the address where the VPTR should point.  */\n+      /* Figure out the position to which the VPTR should point.  */\n       vtbl = TREE_PURPOSE (l);\n       vtbl = build1 (ADDR_EXPR, \n-\t\t     build_pointer_type (TREE_TYPE (vtbl)),\n+\t\t     vtbl_ptr_type_node,\n \t\t     vtbl);\n       index = size_binop (PLUS_EXPR,\n \t\t\t  size_int (non_fn_entries),\n \t\t\t  size_int (list_length (TREE_VALUE (l))));\n-      BINFO_VTABLE (binfo)\n-\t= build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl,\n-\t\t size_binop (MULT_EXPR,\n-\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (vtbl)),\n-\t\t\t     index));\n-\n-      /* Add the initializers for this vtable to the initializers for\n-\t the other vtables we've already got.  */\n-      TREE_VALUE (l) = chainon (TREE_VALUE (l), inits);\n+      index = size_binop (MULT_EXPR,\n+\t\t\t  TYPE_SIZE_UNIT (vtable_entry_type),\n+\t\t\t  index);\n+      vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n+      TREE_CONSTANT (vtbl) = 1;\n+\n+      /* For an ordinary vtable, set BINFO_VTABLE.  */\n+      if (!ctor_vtbl_p)\n+\tBINFO_VTABLE (binfo) = vtbl;\n+      /* For a construction vtable, we can't overwrite BINFO_VTABLE.\n+\t So, we make a TREE_LIST.  Later, dfs_fixup_binfo_vtbls will\n+\t straighten this out.  */\n+      else\n+\tBINFO_VTABLE (binfo) = build_tree_list (vtbl,\n+\t\t\t\t\t\tBINFO_VTABLE (binfo));\n     }\n \n-  CLEAR_BINFO_NEW_VTABLE_MARKED (binfo, t);\n-\n-  return NULL_TREE;\n+  return inits;\n }\n \n /* Construct the initializer for BINFOs virtual function table.  BINFO\n    is part of the hierarchy dominated by T.  If we're building a\n-   construction vtable, the ORIGINAL_BINFO is the binfo we should use\n-   to find the actual function pointers to put in the vtable.\n-   Otherwise, ORIGINAL_BINFO should be the same as BINFO.  The\n-   RTTI_DOMINATOR is the BINFO that should be indicated by the RTTI\n-   information in the vtable; it will be a base class of T, rather\n-   than T itself, if we are building a construction vtable.\n+   construction vtable, the ORIG_BINFO is the binfo we should use to\n+   find the actual function pointers to put in the vtable.  Otherwise,\n+   ORIG_BINFO should be the same as BINFO.  The RTTI_DOMINATOR is the\n+   BINFO that should be indicated by the RTTI information in the\n+   vtable; it will be a base class of T, rather than T itself, if we\n+   are building a construction vtable.\n \n    The value returned is a TREE_LIST suitable for wrapping in a\n    CONSTRUCTOR to use as the DECL_INITIAL for a vtable.  If\n    NON_FN_ENTRIES_P is not NULL, *NON_FN_ENTRIES_P is set to the\n    number of non-function entries in the vtable.  */\n \n static tree\n-build_vtbl_initializer (binfo, original_binfo, t, rtti_binfo,\n-\t\t\tnon_fn_entries_p)\n+build_vtbl_initializer (binfo, orig_binfo, t, rtti_binfo, non_fn_entries_p)\n      tree binfo;\n-     tree original_binfo;\n+     tree orig_binfo;\n      tree t;\n      tree rtti_binfo;\n      int *non_fn_entries_p;\n@@ -6563,7 +6850,7 @@ build_vtbl_initializer (binfo, original_binfo, t, rtti_binfo,\n   /* Go through all the ordinary virtual functions, building up\n      initializers.  */\n   vfun_inits = NULL_TREE;\n-  for (v = BINFO_VIRTUALS (original_binfo); v; v = TREE_CHAIN (v))\n+  for (v = BINFO_VIRTUALS (orig_binfo); v; v = TREE_CHAIN (v))\n     {\n       tree delta;\n       tree vcall_index;"}, {"sha": "d21a195af23b044e0b066a0649920a7d3f1ef722", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2365615885b83d1ff2644318846aa173628dccf4", "patch": "@@ -1597,7 +1597,11 @@ struct lang_type\n /* A chain of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n    order.  (In other words, these bases appear in the order that they\n-   should be initialized.)  */\n+   should be initialized.)  If a virtual base is primary, then the\n+   primary copy will appear on this list.  Thus, the BINFOs on this\n+   list are all \"real\"; they are the same BINFOs that will be\n+   encountered when using dfs_unmarked_real_bases_queue_p and related\n+   functions.  */\n #define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n \n /* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n@@ -1721,8 +1725,15 @@ struct lang_type\n    B is part of the hierarchy dominated by C.  */\n #define BINFO_NEW_VTABLE_MARKED(B, C) \\\n   (TREE_LANG_FLAG_4 (CANONICAL_BINFO (B, C)))\n-#define SET_BINFO_NEW_VTABLE_MARKED(B, C) \\\n-  (BINFO_NEW_VTABLE_MARKED (B, C) = 1)\n+\n+/* Any subobject that needs a new vtable must have a vptr and must not\n+   be a primary base (since it would then use the vtable from a\n+   derived class.)  */\n+#define SET_BINFO_NEW_VTABLE_MARKED(B, C)\t\t       \t\t \\\n+  (BINFO_NEW_VTABLE_MARKED (B, C) = 1,\t\t\t\t\t \\\n+   my_friendly_assert (!BINFO_PRIMARY_MARKED_P (B), 20000517),\t\t \\\n+   my_friendly_assert (CLASSTYPE_VFIELDS (BINFO_TYPE (B)) != NULL_TREE,  \\\n+\t\t       20000517))\n #define CLEAR_BINFO_NEW_VTABLE_MARKED(B, C) \\\n   (BINFO_NEW_VTABLE_MARKED (B, C) = 0)\n \n@@ -3438,6 +3449,15 @@ extern tree original_function_name;\n \n #define EXCEPTION_CLEANUP_NAME \t\"exception cleanup\"\n \n+/* The name used as a prefix for VTTs.  When the new ABI mangling\n+   scheme is implemented, this should be removed.  */\n+\n+#define VTT_NAME_PREFIX \"__vtt_\"\n+\n+/* The name used as a prefix for construction vtables.  */\n+\n+#define CTOR_VTBL_NAME_PREFIX \"__ctorvt_\"\n+\n #define THIS_NAME_P(ID_NODE) (strcmp(IDENTIFIER_POINTER (ID_NODE), \"this\") == 0)\n \n #if !defined(NO_DOLLAR_IN_LABEL) || !defined(NO_DOT_IN_LABEL)\n@@ -4187,6 +4207,7 @@ extern void emit_thunk\t\t\t\tPARAMS ((tree));\n extern void synthesize_method\t\t\tPARAMS ((tree));\n extern tree get_id_2\t\t\t\tPARAMS ((const char *, tree));\n extern tree implicitly_declare_fn               PARAMS ((special_function_kind, tree, int));\n+extern tree get_ctor_vtbl_name                  PARAMS ((tree, tree));\n \n /* In optimize.c */\n extern void optimize_function                   PARAMS ((tree));"}, {"sha": "bbb580d622b4aeaa3471875847c7afdc0966365d", "filename": "gcc/cp/method.c", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=2365615885b83d1ff2644318846aa173628dccf4", "patch": "@@ -1766,9 +1766,6 @@ build_typename_overload (type)\n   build_mangled_name (type, 0, 1);\n   id = get_identifier (obstack_base (&scratch_obstack));\n   IDENTIFIER_OPNAME_P (id) = 1;\n-#if 0\n-  IDENTIFIER_GLOBAL_VALUE (id) = TYPE_MAIN_DECL (type);\n-#endif\n   TREE_TYPE (id) = type;\n   end_squangling ();\n   return id;\n@@ -1800,6 +1797,28 @@ get_id_2 (name, name2)\n   return get_identifier (obstack_base (&scratch_obstack));\n }\n \n+/* Returns the name of a construction vtable group.  TYPE is the most\n+   derived class in the hierarhcy.  BINFO is the most derived class in\n+   the construction vtable group.  */\n+\n+tree\n+get_ctor_vtbl_name (type, binfo)\n+     tree type;\n+     tree binfo;\n+{\n+  start_squangling ();\n+  OB_INIT ();\n+  OB_PUTCP (CTOR_VTBL_NAME_PREFIX);\n+  build_mangled_name (type, 0, 0);\n+  OB_PUTC ('_');\n+  build_mangled_name (BINFO_TYPE (binfo), 0, 0);\n+  OB_PUTC ('_');\n+  build_overload_int (BINFO_OFFSET (binfo), mf_none);\n+  OB_FINISH ();\n+  end_squangling ();\n+  return get_identifier (obstack_base (&scratch_obstack));\n+}\n+\n /* Returns a DECL_ASSEMBLER_NAME for the destructor of type TYPE.  */\n \n tree"}, {"sha": "bebca052a5def8f8d8c5208e80299347d97b525a", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2365615885b83d1ff2644318846aa173628dccf4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2365615885b83d1ff2644318846aa173628dccf4", "patch": "@@ -1859,7 +1859,7 @@ dfs_walk_real (binfo, prefn, postfn, qfn, data)\n \n   /* Process the basetypes.  */\n   binfos = BINFO_BASETYPES (binfo);\n-  n_baselinks = binfos ? TREE_VEC_LENGTH (binfos): 0;\n+  n_baselinks = BINFO_N_BASETYPES (binfo);\n   for (i = 0; i < n_baselinks; i++)\n     {\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n@@ -2521,7 +2521,6 @@ init_vbase_pointers (type, decl_ptr)\n       vi.inits = NULL_TREE;\n \n       /* Build up a list of the initializers.  */\n-      TREE_CHAIN (binfo) = decl_ptr;\n       dfs_walk_real (binfo, \n \t\t     dfs_init_vbase_pointers, 0,\n \t\t     unmarked_vtable_pathp,"}]}