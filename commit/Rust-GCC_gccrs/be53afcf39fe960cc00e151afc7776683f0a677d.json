{"sha": "be53afcf39fe960cc00e151afc7776683f0a677d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU1M2FmY2YzOWZlOTYwY2MwMGUxNTFhZmM3Nzc2NjgzZjBhNjc3ZA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "weigand@informatik.uni-erlangen.de", "date": "2005-08-15T20:26:46Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2005-08-15T20:26:46Z"}, "message": "mf-hooks3.c (main_seen_p): Remove.\n\n\t* mf-hooks3.c (main_seen_p): Remove.\n\t(__mf_get_state): Remove attempt to recognize the main thread.\n\nFrom-SVN: r103119", "tree": {"sha": "451b60bad31ed0f5a24f54ae16b155e76ffe759a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/451b60bad31ed0f5a24f54ae16b155e76ffe759a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be53afcf39fe960cc00e151afc7776683f0a677d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be53afcf39fe960cc00e151afc7776683f0a677d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be53afcf39fe960cc00e151afc7776683f0a677d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be53afcf39fe960cc00e151afc7776683f0a677d/comments", "author": null, "committer": null, "parents": [{"sha": "b5568f074bbe4dcda0995e58cad7778b3c0ceebf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5568f074bbe4dcda0995e58cad7778b3c0ceebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5568f074bbe4dcda0995e58cad7778b3c0ceebf"}], "stats": {"total": 28, "additions": 9, "deletions": 19}, "files": [{"sha": "4bd53167e79ff7b6f082ce02e657e9b857c7316d", "filename": "libmudflap/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be53afcf39fe960cc00e151afc7776683f0a677d/libmudflap%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be53afcf39fe960cc00e151afc7776683f0a677d/libmudflap%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2FChangeLog?ref=be53afcf39fe960cc00e151afc7776683f0a677d", "patch": "@@ -1,3 +1,8 @@\n+2005-08-15  Ulrich Weigand  <weigand@informatik.uni-erlangen.de>\n+\n+\t* mf-hooks3.c (main_seen_p): Remove.\n+\t(__mf_get_state): Remove attempt to recognize the main thread.\n+\n 2005-08-15  Maciej W. Rozycki  <macro@linux-mips.org>\n \n \t* configure.ac: Test for the name of the symbol used for the entry"}, {"sha": "e32f13a58efae5c1a6368b74f063358ab20a6d14", "filename": "libmudflap/mf-hooks3.c", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be53afcf39fe960cc00e151afc7776683f0a677d/libmudflap%2Fmf-hooks3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be53afcf39fe960cc00e151afc7776683f0a677d/libmudflap%2Fmf-hooks3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libmudflap%2Fmf-hooks3.c?ref=be53afcf39fe960cc00e151afc7776683f0a677d", "patch": "@@ -104,11 +104,6 @@ struct mf_thread_data\n static struct mf_thread_data mf_thread_data[LIBMUDFLAPTH_THREADS_MAX];\n static pthread_mutex_t mf_thread_data_lock = PTHREAD_MUTEX_INITIALIZER;\n \n-/* Try to identify the main thread when filling in mf_thread_data.  We\n-   should always be called at least once from the main thread before \n-   any new threads are spawned.  */\n-static int main_seen_p;\n-\n #define PTHREAD_HASH(p) ((unsigned long) (p) % LIBMUDFLAPTH_THREADS_MAX)\n \n static struct mf_thread_data *\n@@ -176,11 +171,9 @@ __mf_get_state (void)\n   if (data)\n     return data->state;\n \n-  /* The main thread needs to default to active state, so that the global\n-     constructors are processed in the active state.  Child threads should\n-     be considered to be in the reentrant state, so that we don't wind up\n-     doing Screwy Things inside the thread library; it'll get reset to \n-     active state in __mf_pthread_spawner before user code is invoked.\n+  /* If we've never seen this thread before, consider it to be in the\n+     reentrant state.  The state gets reset to active for the main thread\n+     in __mf_init, and for child threads in __mf_pthread_spawner.\n \n      The trickiest bit here is that the LinuxThreads pthread_manager thread\n      should *always* be considered to be reentrant, so that none of our \n@@ -189,15 +182,7 @@ __mf_get_state (void)\n      stuff isn't initialized, leading to SEGV very quickly.  Even calling\n      pthread_self is a bit suspect, but it happens to work.  */\n \n-  if (main_seen_p)\n-    return reentrant;\n-  else\n-    {\n-      main_seen_p = 1;\n-      data = __mf_find_threadinfo (1);\n-      data->state = active;\n-      return active;\n-    }\n+  return reentrant;\n }\n \n void"}]}