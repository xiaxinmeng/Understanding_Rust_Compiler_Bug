{"sha": "e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTYxZDdiNzgxZWNjMTQ5Mzk3NWZkY2Y1OGJhMjhhMzRmNGI1Y2M3ZA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-19T15:38:25Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-19T15:38:25Z"}, "message": "tree-cfg.c (thread_jumps): Use a do-while loop instead of a loop with goto.\n\n\t* tree-cfg.c (thread_jumps): Use a do-while loop instead of a\n\tloop with goto.\n\nFrom-SVN: r89276", "tree": {"sha": "169897e902c568b2745e1db9788c40be1d3ed8ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/169897e902c568b2745e1db9788c40be1d3ed8ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d/comments", "author": null, "committer": null, "parents": [{"sha": "e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e836a5a26a9e40de2a2d5c07266c0f8321c5532c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e836a5a26a9e40de2a2d5c07266c0f8321c5532c"}], "stats": {"total": 293, "additions": 152, "deletions": 141}, "files": [{"sha": "d4e95c14179c6f53846c8776e3e94417ffc0e8ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "patch": "@@ -1,3 +1,8 @@\n+2004-10-19  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-cfg.c (thread_jumps): Use a do-while loop instead of a\n+\tloop with goto.\n+\n 2004-10-19  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* expr.c (expand_assignment): Remove the last argument."}, {"sha": "0722df15ac3486e6a6b2b9b8640f38814977674c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 147, "deletions": 141, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=e61d7b781ecc1493975fdcf58ba28a34f4b5cc7d", "patch": "@@ -3781,173 +3781,179 @@ thread_jumps (void)\n   FOR_EACH_BB (bb)\n     bb_ann (bb)->forwardable = tree_forwarder_block_p (bb);\n \n- restart:\n-  rerun = false;\n-  FOR_EACH_BB (bb)\n+  do\n     {\n-      edge_iterator ei;\n-      bool this_jump_threaded = false;\n-\n-      /* Don't waste time on forwarders.  */\n-      if (bb_ann (bb)->forwardable)\n-\tcontinue;\n-\n-      /* Examine each of our block's successors to see if it is\n-\t forwardable.  */\n-      for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n+      rerun = false;\n+      FOR_EACH_BB (bb)\n \t{\n-\t  int freq;\n-\t  gcov_type count;\n+\t  edge_iterator ei;\n+\t  bool this_jump_threaded = false;\n \n-\t  /* If the edge is abnormal or its destination is not\n-\t     forwardable, then there's nothing to do.  */\n-\t  if ((e->flags & EDGE_ABNORMAL)\n-\t      || !bb_ann (e->dest)->forwardable)\n-\t    {\n-\t      ei_next (&ei);\n-\t      continue;\n-\t    }\n+\t  /* Don't waste time on forwarders.  */\n+\t  if (bb_ann (bb)->forwardable)\n+\t    continue;\n \n-\t  count = e->count;\n-\t  freq = EDGE_FREQUENCY (e);\n-\n-\t  /* Now walk through as many forwarder blocks as possible to\n-\t     find the ultimate destination we want to thread our jump\n-\t     to.  */\n-\t  last = EDGE_SUCC (e->dest, 0);\n-\t  bb_ann (e->dest)->forwardable = 0;\n-\t  for (dest = EDGE_SUCC (e->dest, 0)->dest;\n-\t       bb_ann (dest)->forwardable;\n-\t       last = EDGE_SUCC (dest, 0),\n-\t       dest = EDGE_SUCC (dest, 0)->dest)\n-\t    bb_ann (dest)->forwardable = 0;\n-\n-\t  /* Reset the forwardable marks to 1.  */\n-\t  for (tmp = e->dest;\n-\t       tmp != dest;\n-\t       tmp = EDGE_SUCC (tmp, 0)->dest)\n-\t    bb_ann (tmp)->forwardable = 1;\n-\n-\t  if (dest == e->dest)\n+\t  /* Examine each of our block's successors to see if it is\n+\t     forwardable.  */\n+\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t    {\n-\t      ei_next (&ei);\n-\t      continue;\n-\t    }\n+\t      int freq;\n+\t      gcov_type count;\n+\n+\t      /* If the edge is abnormal or its destination is not\n+\t\t forwardable, then there's nothing to do.  */\n+\t      if ((e->flags & EDGE_ABNORMAL)\n+\t\t  || !bb_ann (e->dest)->forwardable)\n+\t\t{\n+\t\t  ei_next (&ei);\n+\t\t  continue;\n+\t\t}\n+\n+\t      count = e->count;\n+\t      freq = EDGE_FREQUENCY (e);\n+\n+\t      /* Now walk through as many forwarder blocks as possible to\n+\t\t find the ultimate destination we want to thread our jump\n+\t\t to.  */\n+\t      last = EDGE_SUCC (e->dest, 0);\n+\t      bb_ann (e->dest)->forwardable = 0;\n+\t      for (dest = EDGE_SUCC (e->dest, 0)->dest;\n+\t\t   bb_ann (dest)->forwardable;\n+\t\t   last = EDGE_SUCC (dest, 0),\n+\t\t     dest = EDGE_SUCC (dest, 0)->dest)\n+\t\tbb_ann (dest)->forwardable = 0;\n+\n+\t      /* Reset the forwardable marks to 1.  */\n+\t      for (tmp = e->dest;\n+\t\t   tmp != dest;\n+\t\t   tmp = EDGE_SUCC (tmp, 0)->dest)\n+\t\tbb_ann (tmp)->forwardable = 1;\n+\n+\t      if (dest == e->dest)\n+\t\t{\n+\t\t  ei_next (&ei);\n+\t\t  continue;\n+\t\t}\n \t      \n-\t  old = find_edge (bb, dest);\n-\t  if (old)\n-\t    {\n-\t      /* If there already is an edge, check whether the values\n-\t\t in phi nodes differ.  */\n-\t      if (!phi_alternatives_equal (dest, last, old))\n+\t      old = find_edge (bb, dest);\n+\t      if (old)\n \t\t{\n-\t\t  /* The previous block is forwarder.  Redirect our jump\n-\t\t     to that target instead since we know it has no PHI\n-\t\t     nodes that will need updating.  */\n-\t\t  dest = last->src;\n-\t  \n-\t\t  /* That might mean that no forwarding at all is possible.  */\n-\t\t  if (dest == e->dest)\n+\t\t  /* If there already is an edge, check whether the values\n+\t\t     in phi nodes differ.  */\n+\t\t  if (!phi_alternatives_equal (dest, last, old))\n \t\t    {\n-\t\t      ei_next (&ei);\n-\t\t      continue;\n+\t\t      /* The previous block is forwarder.  Redirect our jump\n+\t\t\t to that target instead since we know it has no PHI\n+\t\t\t nodes that will need updating.  */\n+\t\t      dest = last->src;\n+\t  \n+\t\t      /* That might mean that no forwarding at all is\n+\t\t\t possible.  */\n+\t\t      if (dest == e->dest)\n+\t\t\t{\n+\t\t\t  ei_next (&ei);\n+\t\t\t  continue;\n+\t\t\t}\n+\n+\t\t      old = find_edge (bb, dest);\n \t\t    }\n-\n-\t\t  old = find_edge (bb, dest);\n \t\t}\n-\t    }\n \n-\t  /* Perform the redirection.  */\n-\t  retval = this_jump_threaded = true;\n-\t  old_dest = e->dest;\n-\t  e = redirect_edge_and_branch (e, dest);\n+\t      /* Perform the redirection.  */\n+\t      retval = this_jump_threaded = true;\n+\t      old_dest = e->dest;\n+\t      e = redirect_edge_and_branch (e, dest);\n \n-\t  /* Update the profile.  */\n-\t  if (profile_status != PROFILE_ABSENT)\n-\t    for (curr = old_dest; curr != dest; curr = EDGE_SUCC (curr, 0)->dest)\n-\t      {\n-\t\tcurr->frequency -= freq;\n-\t\tif (curr->frequency < 0)\n-\t\t  curr->frequency = 0;\n-\t\tcurr->count -= count;\n-\t\tif (curr->count < 0)\n-\t\t  curr->count = 0;\n-\t\tEDGE_SUCC (curr, 0)->count -= count;\n-\t\tif (EDGE_SUCC (curr, 0)->count < 0)\n-\t\t  EDGE_SUCC (curr, 0)->count = 0;\n-\t      }\n+\t      /* Update the profile.  */\n+\t      if (profile_status != PROFILE_ABSENT)\n+\t\tfor (curr = old_dest;\n+\t\t     curr != dest;\n+\t\t     curr = EDGE_SUCC (curr, 0)->dest)\n+\t\t  {\n+\t\t    curr->frequency -= freq;\n+\t\t    if (curr->frequency < 0)\n+\t\t      curr->frequency = 0;\n+\t\t    curr->count -= count;\n+\t\t    if (curr->count < 0)\n+\t\t      curr->count = 0;\n+\t\t    EDGE_SUCC (curr, 0)->count -= count;\n+\t\t    if (EDGE_SUCC (curr, 0)->count < 0)\n+\t\t      EDGE_SUCC (curr, 0)->count = 0;\n+\t\t  }\n \n-\t  if (!old)\n-\t    {\n-\t      /* Update PHI nodes.   We know that the new argument should\n-\t\t have the same value as the argument associated with LAST.\n-\t\t Otherwise we would have changed our target block above.  */\n-\t      for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t      if (!old)\n \t\t{\n-\t\t  arg = phi_arg_from_edge (phi, last);\n-\t\t  gcc_assert (arg >= 0);\n-\t\t  add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n+\t\t  /* Update PHI nodes.  We know that the new argument\n+\t\t     should have the same value as the argument\n+\t\t     associated with LAST.  Otherwise we would have\n+\t\t     changed our target block above.  */\n+\t\t  for (phi = phi_nodes (dest); phi; phi = PHI_CHAIN (phi))\n+\t\t    {\n+\t\t      arg = phi_arg_from_edge (phi, last);\n+\t\t      gcc_assert (arg >= 0);\n+\t\t      add_phi_arg (&phi, PHI_ARG_DEF (phi, arg), e);\n+\t\t    }\n \t\t}\n-\t    }\n-\n-\t  /* Remove the unreachable blocks (observe that if all blocks\n-\t     were reachable before, only those in the path we threaded\n-\t     over and did not have any predecessor outside of the path\n-\t     become unreachable).  */\n-\t  for (; old_dest != dest; old_dest = tmp)\n-\t    {\n-\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n-\n-\t      if (EDGE_COUNT (old_dest->preds) > 0)\n-\t\tbreak;\n-\n-\t      delete_basic_block (old_dest);\n-\t    }\n-\n-\t  /* Update the dominators.  */\n-\t  if (dom_info_available_p (CDI_DOMINATORS))\n-\t    {\n-\t      /* If the dominator of the destination was in the path, set its\n-\t\t dominator to the start of the redirected edge.  */\n-\t      if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n-\t\tset_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n-\n-\t      /* Now proceed like if we forwarded just over one edge at a time.\n-\t\t Algorithm for forwarding edge S --> A over edge A --> B then\n-\t\t is\n-\n-\t\t if (idom (B) == A\n-\t\t     && !dominated_by (S, B))\n-\t\t   idom (B) = idom (A);\n-\t\t recount_idom (A);  */\n \n+\t      /* Remove the unreachable blocks (observe that if all blocks\n+\t\t were reachable before, only those in the path we threaded\n+\t\t over and did not have any predecessor outside of the path\n+\t\t become unreachable).  */\n \t      for (; old_dest != dest; old_dest = tmp)\n \t\t{\n \t\t  tmp = EDGE_SUCC (old_dest, 0)->dest;\n \n-\t\t  if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n-\t\t      && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n+\t\t  if (EDGE_COUNT (old_dest->preds) > 0)\n+\t\t    break;\n+\n+\t\t  delete_basic_block (old_dest);\n+\t\t}\n+\n+\t      /* Update the dominators.  */\n+\t      if (dom_info_available_p (CDI_DOMINATORS))\n+\t\t{\n+\t\t  /* If the dominator of the destination was in the\n+\t\t     path, set its dominator to the start of the\n+\t\t     redirected edge.  */\n+\t\t  if (get_immediate_dominator (CDI_DOMINATORS, old_dest) == NULL)\n+\t\t    set_immediate_dominator (CDI_DOMINATORS, old_dest, bb);\n+\n+\t\t  /* Now proceed like if we forwarded just over one\n+\t\t     edge at a time.  Algorithm for forwarding edge\n+\t\t     S --> A over edge A --> B then is\n+\n+\t\t     if (idom (B) == A\n+\t\t         && !dominated_by (S, B))\n+\t\t       idom (B) = idom (A);\n+\t\t     recount_idom (A);  */\n+\n+\t\t  for (; old_dest != dest; old_dest = tmp)\n \t\t    {\n-\t\t      dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n-  \t\t      set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n-\t\t    }\n+\t\t      tmp = EDGE_SUCC (old_dest, 0)->dest;\n+\n+\t\t      if (get_immediate_dominator (CDI_DOMINATORS, tmp) == old_dest\n+\t\t\t  && !dominated_by_p (CDI_DOMINATORS, bb, tmp))\n+\t\t\t{\n+\t\t\t  dom = get_immediate_dominator (CDI_DOMINATORS, old_dest);\n+\t\t\t  set_immediate_dominator (CDI_DOMINATORS, tmp, dom);\n+\t\t\t}\n \n-\t\t  dom = recount_dominator (CDI_DOMINATORS, old_dest);\n-\t\t  set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n+\t\t      dom = recount_dominator (CDI_DOMINATORS, old_dest);\n+\t\t      set_immediate_dominator (CDI_DOMINATORS, old_dest, dom);\n+\t\t    }\n \t\t}\n \t    }\n-\t}\n \n-      /* If we succeeded in threading a jump at BB, update the\n-\t forwardable mark as BB may have become a new forwarder block.\n-\t This could happen if we have a useless \"if\" statement whose\n-\t two arms eventually merge without any intervening\n-\t statements.  */\n-      if (this_jump_threaded && tree_forwarder_block_p (bb))\n-\tbb_ann (bb)->forwardable = rerun = true;\n+\t  /* If we succeeded in threading a jump at BB, update the\n+\t     forwardable mark as BB may have become a new forwarder\n+\t     block.  This could happen if we have a useless \"if\"\n+\t     statement whose two arms eventually merge without any\n+\t     intervening statements.  */\n+\t  if (this_jump_threaded && tree_forwarder_block_p (bb))\n+\t    bb_ann (bb)->forwardable = rerun = true;\n+\t}\n     }\n-  if (rerun)\n-    goto restart;\n+  while (rerun);\n \n   return retval;\n }"}]}