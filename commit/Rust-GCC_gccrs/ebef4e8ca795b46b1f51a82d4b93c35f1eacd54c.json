{"sha": "ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlZjRlOGNhNzk1YjQ2YjFmNTFhODJkNGI5M2MzNWYxZWFjZDU0Yw==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-04-14T18:42:47Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-04-14T18:42:47Z"}, "message": "cpperror.c (print_location): Don't print include chain if line == 0.\n\n\t* cpperror.c (print_location): Don't print include chain\n\tif line == 0.\n\t(cpp_begin_message): Update to use DL_ macros.\n\t(cpp_ice, cpp_fatal, cpp_error_from_errno, cpp_warning,\n\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n\tcpp_notice, cpp_notice_from_errno): Remove.\n\t(cpp_error, cpp_error_with_line): Update to take a diagnostic\n\tlevel.\n\t(cpp_errno): New.\n\t* cppexp.c (CPP_ICE): Remove.\n\t(SYNTAX_ERROR, SYNTAX_ERROR2, parse_number, parse_defined,\n\tlex, integer_overflow, _cpp_parse_expr): Update.\n\t* cppfiles.c (read_include_file, find_include_file,\n\thandle_missing_header, _cpp_read_file, remap_filename): Update.\n\t* cpphash.h (enum error_type): Remove.\n\t(_cpp_begin_message): Update.\n\t* cppinit.c (append_include_chain, remove_dup_dirs, output_deps,\n\tcpp_handle_option, cpp_post_options): Update.\n\t* cpplex.c (trigraph_p, skip_escaped_newlines, skip_block_comment,\n\tskip_whitespace, parse_identifier, parse_slow, parse_string,\n\t_cpp_lex_direct, cpp_spell_token, maybe_read_ucs, cpp_parse_escape,\n\tcpp_interpret_charconst): Update.\n\t* cpplib.c (check_eol, directive_diagnostics, _cpp_handle_directive,\n\tlex_macro_node, do_undef, glue_header_name, parse_include,\n\tdo_include_common, read_flag, do_line, do_linemarker, do_ident,\n\tcpp_register_pragma, do_pragma_once, do_pragma_system_header,\n\tdo_pragma_poison, do_pragma_dependency, _cpp_do__Pragma, do_else,\n\tdo_elif, do_endif, parse_answer, parse_assertion, do_assert,\n\t_cpp_pop_buffer, do_diagnostic): Update.\n\t* cpplib.h (DL_WARNING, DL_WARNING_SYSHDR, DL_PEDWARN, DL_ERROR,\n\tDL_FATAL, DL_ICE, DL_EXTRACT, DL_WARNING_P): New.\n\t(cpp_ice, cpp_fatal, cpp_error_from_errno, cpp_warning,\n\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n\tcpp_notice, cpp_notice_from_errno): Remove.\n\t(cpp_error, cpp_error_with_line): Update to take a diagnostic\n\tlevel.\n\t(cpp_errno): New.\n\t* cppmacro.c (builtin_macro, stringify_arg, paste_all_tokens,\n\tcollect_args, enter_macro_context, save_parameter, parse_params,\n\t_cpp_create_definition, check_trad_stringification,\n\tcpp_macro_definition): Update.\n\t* cppmain.c (cpp_preprocess_file): Update.\n\t* fix-header.c (read_scan_file): Update.\n\nFrom-SVN: r52302", "tree": {"sha": "75fa26f503af564c85d2a564dac4f51a833dca58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75fa26f503af564c85d2a564dac4f51a833dca58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/comments", "author": null, "committer": null, "parents": [{"sha": "c19a385911ad926bd88713535b5a93c947d9f1bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c19a385911ad926bd88713535b5a93c947d9f1bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c19a385911ad926bd88713535b5a93c947d9f1bd"}], "stats": {"total": 776, "additions": 386, "deletions": 390}, "files": [{"sha": "8461ac91193c98bf4ed6edac6822c45a56f82eb1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -1,3 +1,49 @@\n+2002-04-14  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cpperror.c (print_location): Don't print include chain\n+\tif line == 0.\n+\t(cpp_begin_message): Update to use DL_ macros.\n+\t(cpp_ice, cpp_fatal, cpp_error_from_errno, cpp_warning,\n+\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n+\tcpp_notice, cpp_notice_from_errno): Remove.\n+\t(cpp_error, cpp_error_with_line): Update to take a diagnostic\n+\tlevel.\n+\t(cpp_errno): New.\n+\t* cppexp.c (CPP_ICE): Remove.\n+\t(SYNTAX_ERROR, SYNTAX_ERROR2, parse_number, parse_defined,\n+\tlex, integer_overflow, _cpp_parse_expr): Update.\n+\t* cppfiles.c (read_include_file, find_include_file,\n+\thandle_missing_header, _cpp_read_file, remap_filename): Update.\n+\t* cpphash.h (enum error_type): Remove.\n+\t(_cpp_begin_message): Update.\n+\t* cppinit.c (append_include_chain, remove_dup_dirs, output_deps,\n+\tcpp_handle_option, cpp_post_options): Update.\n+\t* cpplex.c (trigraph_p, skip_escaped_newlines, skip_block_comment,\n+\tskip_whitespace, parse_identifier, parse_slow, parse_string,\n+\t_cpp_lex_direct, cpp_spell_token, maybe_read_ucs, cpp_parse_escape,\n+\tcpp_interpret_charconst): Update.\n+\t* cpplib.c (check_eol, directive_diagnostics, _cpp_handle_directive,\n+\tlex_macro_node, do_undef, glue_header_name, parse_include,\n+\tdo_include_common, read_flag, do_line, do_linemarker, do_ident,\n+\tcpp_register_pragma, do_pragma_once, do_pragma_system_header,\n+\tdo_pragma_poison, do_pragma_dependency, _cpp_do__Pragma, do_else,\n+\tdo_elif, do_endif, parse_answer, parse_assertion, do_assert,\n+\t_cpp_pop_buffer, do_diagnostic): Update.\n+\t* cpplib.h (DL_WARNING, DL_WARNING_SYSHDR, DL_PEDWARN, DL_ERROR,\n+\tDL_FATAL, DL_ICE, DL_EXTRACT, DL_WARNING_P): New.\n+\t(cpp_ice, cpp_fatal, cpp_error_from_errno, cpp_warning,\n+\tcpp_warning_with_line, cpp_pedwarn, cpp_pedwarn_with_line,\n+\tcpp_notice, cpp_notice_from_errno): Remove.\n+\t(cpp_error, cpp_error_with_line): Update to take a diagnostic\n+\tlevel.\n+\t(cpp_errno): New.\n+\t* cppmacro.c (builtin_macro, stringify_arg, paste_all_tokens,\n+\tcollect_args, enter_macro_context, save_parameter, parse_params,\n+\t_cpp_create_definition, check_trad_stringification,\n+\tcpp_macro_definition): Update.\n+\t* cppmain.c (cpp_preprocess_file): Update.\n+\t* fix-header.c (read_scan_file): Update.\n+\n 2002-04-14  Andreas Schwab  <schwab@suse.de>\n \n \t* config/ia64/linux.h (CPP_PREDEFINES): Fix missing backslash."}, {"sha": "7d74b2ea684f279a4c3a1e8a4bcac610c52f5272", "filename": "gcc/cpperror.c", "status": "modified", "additions": 57, "deletions": 171, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -31,32 +31,21 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n static void print_location PARAMS ((cpp_reader *, unsigned int, unsigned int));\n \n-/* Don't remove the blank before do, as otherwise the exgettext\n-   script will mistake this as a function definition */\n-#define v_message(msgid, ap) \\\n- do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n-\n /* Print the logical file location (LINE, COL) in preparation for a\n-   diagnostic.  Outputs the #include chain if it has changed.  */\n+   diagnostic.  Outputs the #include chain if it has changed.  A line\n+   of zero suppresses the include stack, and outputs the program name\n+   instead.  */\n static void\n print_location (pfile, line, col)\n      cpp_reader *pfile;\n      unsigned int line, col;\n {\n-  cpp_buffer *buffer = pfile->buffer;\n-\n-  if (!buffer)\n+  if (!pfile->buffer || line == 0)\n     fprintf (stderr, \"%s: \", progname);\n   else\n     {\n       const struct line_map *map;\n \n-      if (line == 0)\n-\t{\n-\t  line = pfile->cur_token[-1].line;\n-\t  col = pfile->cur_token[-1].col;\n-\t}\n-\n       map = lookup_line (&pfile->line_maps, line);\n       print_containing_files (&pfile->line_maps, map);\n \n@@ -75,226 +64,123 @@ print_location (pfile, line, col)\n     }\n }\n \n-/* Set up for an error message: print the file and line, bump the error\n+/* Set up for a diagnostic: print the file and line, bump the error\n    counter, etc.  LINE is the logical line number; zero means to print\n-   at the location of the previously lexed token, which tends to be the\n-   correct place by default.  Returns 0 if the error has been suppressed.  */\n+   at the location of the previously lexed token, which tends to be\n+   the correct place by default.  Returns 0 if the error has been\n+   suppressed.  */\n int\n _cpp_begin_message (pfile, code, line, column)\n      cpp_reader *pfile;\n-     enum error_type code;\n+     int code;\n      unsigned int line, column;\n {\n-  int is_warning = 0;\n+  int level = DL_EXTRACT (code);\n \n-  switch (code)\n+  switch (level)\n     {\n-    case PEDWARN:\n-    case WARNING:\n+    case DL_WARNING:\n+    case DL_PEDWARN:\n       if (CPP_IN_SYSTEM_HEADER (pfile)\n \t  && ! CPP_OPTION (pfile, warn_system_headers))\n \treturn 0;\n-    case WARNING_SYSHDR:\n+      /* Fall through.  */\n+\n+    case DL_WARNING_SYSHDR:\n       if (CPP_OPTION (pfile, warnings_are_errors)\n-\t  || (code == PEDWARN && CPP_OPTION (pfile, pedantic_errors)))\n+\t  || (level == DL_PEDWARN && CPP_OPTION (pfile, pedantic_errors)))\n \t{\n \t  if (CPP_OPTION (pfile, inhibit_errors))\n \t    return 0;\n \t  if (pfile->errors < CPP_FATAL_LIMIT)\n \t    pfile->errors++;\n \t}\n-      else\n-\t{\n-          if (CPP_OPTION (pfile, inhibit_warnings))\n-\t    return 0;\n-\t  is_warning = 1;\n-\t}\n+      else if (CPP_OPTION (pfile, inhibit_warnings))\n+\treturn 0;\n       break;\n \t\n-    case ERROR:\n+    case DL_ERROR:\n       if (CPP_OPTION (pfile, inhibit_errors))\n \treturn 0;\n       if (pfile->errors < CPP_FATAL_LIMIT)\n \tpfile->errors++;\n       break;\n+\n       /* Fatal errors cannot be inhibited.  */\n-    case FATAL:\n-      pfile->errors = CPP_FATAL_LIMIT;\n-      break;\n-    case ICE:\n-      fprintf (stderr, _(\"internal error: \"));\n+    case DL_FATAL:\n+    case DL_ICE:\n       pfile->errors = CPP_FATAL_LIMIT;\n       break;\n     }\n \n   print_location (pfile, line, column);\n-  if (is_warning)\n+  if (DL_WARNING_P (level))\n     fputs (_(\"warning: \"), stderr);\n+  else if (level == DL_ICE)\n+    fputs (_(\"internal error: \"), stderr);\n \n   return 1;\n }\n \n-/* Exported interface.  */\n-\n-/* For reporting internal errors.  Prints \"internal error: \" for you,\n-   otherwise identical to cpp_fatal.  */\n-void\n-cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n-{  \n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (_cpp_begin_message (pfile, ICE, 0, 0))\n-    v_message (msgid, ap);\n-\n-  VA_CLOSE (ap);\n-}\n-\n-/* Same as cpp_error, except we consider the error to be \"fatal\",\n-   such as inconsistent options.  I.e. there is little point in continuing.\n-   (We do not exit, to support use of cpplib as a library.\n-   Instead, it is the caller's responsibility to check\n-   CPP_FATAL_ERRORS.  */\n-void\n-cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n-{  \n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (_cpp_begin_message (pfile, FATAL, 0, 0))\n-    v_message (msgid, ap);\n+/* Don't remove the blank before do, as otherwise the exgettext\n+   script will mistake this as a function definition */\n+#define v_message(msgid, ap) \\\n+ do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n-  VA_CLOSE (ap);\n-}\n+/* Exported interface.  */\n \n /* Print an error at the location of the previously lexed token.  */\n void\n-cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (_cpp_begin_message (pfile, ERROR, 0, 0))\n-    v_message (msgid, ap);\n-\n-  VA_CLOSE (ap);\n-}\n-\n-/* Print an error at a specific location.  */\n-void\n-cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n-\t\t\t     const char *msgid, ...))\n+cpp_error VPARAMS ((cpp_reader * pfile, int level, const char *msgid, ...))\n {\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, int, line);\n-  VA_FIXEDARG (ap, int, column);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (_cpp_begin_message (pfile, ERROR, line, column))\n-    v_message (msgid, ap);\n+  unsigned int line, column;\n \n-  VA_CLOSE (ap);\n-}\n-\n-/* Error including a message from `errno'.  */\n-void\n-cpp_error_from_errno (pfile, name)\n-     cpp_reader *pfile;\n-     const char *name;\n-{\n-  cpp_error (pfile, \"%s: %s\", name, xstrerror (errno));\n-}\n-\n-/* Print a warning at the location of the previously lexed token.  */\n-void\n-cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (_cpp_begin_message (pfile, WARNING, 0, 0))\n-    v_message (msgid, ap);\n-\n-  VA_CLOSE (ap);\n-}\n-\n-/* Print a warning at a specific location.  */\n-void\n-cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n-\t\t\t       const char *msgid, ...))\n-{\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, int, line);\n-  VA_FIXEDARG (ap, int, column);\n+  VA_FIXEDARG (ap, int, level);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, WARNING, line, column))\n-    v_message (msgid, ap);\n-\n-  VA_CLOSE (ap);\n-}\n-\n-/* Pedwarn at the location of the previously lexed token.  */\n-void\n-cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n-{\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n+  if (pfile->buffer)\n+    {\n+      line = pfile->cur_token[-1].line;\n+      column = pfile->cur_token[-1].col;\n+    }\n+  else\n+    line = column = 0;\n \n-  if (_cpp_begin_message (pfile, PEDWARN, 0, 0))\n+  if (_cpp_begin_message (pfile, level, line, column))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n }\n \n-/* Pedwarn at a specific location.  */\n+/* Print an error at a specific location.  */\n void\n-cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n-\t\t\t       const char *msgid, ...))\n+cpp_error_with_line VPARAMS ((cpp_reader *pfile, int level,\n+\t\t\t      unsigned int line, unsigned int column,\n+\t\t\t      const char *msgid, ...))\n {\n   VA_OPEN (ap, msgid);\n   VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, int, line);\n-  VA_FIXEDARG (ap, int, column);\n+  VA_FIXEDARG (ap, int, level);\n+  VA_FIXEDARG (ap, unsigned int, line);\n+  VA_FIXEDARG (ap, unsigned int, column);\n   VA_FIXEDARG (ap, const char *, msgid);\n \n-  if (_cpp_begin_message (pfile, PEDWARN, line, column))\n+  if (_cpp_begin_message (pfile, level, line, column))\n     v_message (msgid, ap);\n \n   VA_CLOSE (ap);\n }\n \n-/* Print an error message not associated with the translation unit.  */\n void\n-cpp_notice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n-{\n-  VA_OPEN (ap, msgid);\n-  VA_FIXEDARG (ap, cpp_reader *, pfile);\n-  VA_FIXEDARG (ap, const char *, msgid);\n-\n-  if (pfile->errors < CPP_FATAL_LIMIT)\n-    pfile->errors++;\n-\n-  v_message (msgid, ap);\n-\n-  VA_CLOSE (ap);\n-}\n-\n-/* Print an error message originating from ERRNO and not associated\n-   with the translation unit.  */\n-void\n-cpp_notice_from_errno (pfile, name)\n+cpp_errno (pfile, level, msgid)\n      cpp_reader *pfile;\n-     const char *name;\n+     int level;\n+     const char *msgid;\n {\n-  if (name[0] == '\\0')\n-    name = \"stdout\";\n-  cpp_notice (pfile, \"%s: %s\", name, xstrerror (errno));\n+  if (msgid[0] == '\\0')\n+    msgid = _(\"stdout\");\n+\n+  cpp_error (pfile, level, \"%s: %s\", msgid, xstrerror (errno));\n }"}, {"sha": "e5b5ef7ae60d364e848fc68ca646ae0d96022f57", "filename": "gcc/cppexp.c", "status": "modified", "additions": 33, "deletions": 24, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -54,12 +54,10 @@ struct op\n \n /* With -O2, gcc appears to produce nice code, moving the error\n    message load and subsequent jump completely out of the main path.  */\n-#define CPP_ICE(msgid) \\\n-  do { cpp_ice (pfile, msgid); goto syntax_error; } while(0)\n #define SYNTAX_ERROR(msgid) \\\n-  do { cpp_error (pfile, msgid); goto syntax_error; } while(0)\n+  do { cpp_error (pfile, DL_ERROR, msgid); goto syntax_error; } while(0)\n #define SYNTAX_ERROR2(msgid, arg) \\\n-  do { cpp_error (pfile, msgid, arg); goto syntax_error; } while(0)\n+  do { cpp_error (pfile, DL_ERROR, msgid, arg); goto syntax_error; } while(0)\n \n struct suffix\n {\n@@ -172,23 +170,26 @@ parse_number (pfile, tok)\n       if (CPP_WTRADITIONAL (pfile)\n \t  && sufftab[i].u\n \t  && ! cpp_sys_macro_p (pfile))\n-\tcpp_warning (pfile, \"traditional C rejects the `U' suffix\");\n+\tcpp_error (pfile, DL_WARNING, \"traditional C rejects the `U' suffix\");\n       if (sufftab[i].l == 2 && CPP_OPTION (pfile, pedantic)\n \t  && ! CPP_OPTION (pfile, c99))\n-\tcpp_pedwarn (pfile, \"too many 'l' suffixes in integer constant\");\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"too many 'l' suffixes in integer constant\");\n     }\n   \n   if (base <= largest_digit)\n-    cpp_pedwarn (pfile, \"integer constant contains digits beyond the radix\");\n+    cpp_error (pfile, DL_PEDWARN,\n+\t       \"integer constant contains digits beyond the radix\");\n \n   if (overflow)\n-    cpp_pedwarn (pfile, \"integer constant out of range\");\n+    cpp_error (pfile, DL_PEDWARN, \"integer constant out of range\");\n \n   /* If too big to be signed, consider it unsigned.  */\n   else if ((HOST_WIDEST_INT) n < 0 && ! op.unsignedp)\n     {\n       if (base == 10)\n-\tcpp_warning (pfile, \"integer constant is so large that it is unsigned\");\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"integer constant is so large that it is unsigned\");\n       op.unsignedp = 1;\n     }\n \n@@ -197,7 +198,7 @@ parse_number (pfile, tok)\n   return op;\n \n  invalid_suffix:\n-  cpp_error (pfile, \"invalid suffix '%.*s' on integer constant\",\n+  cpp_error (pfile, DL_ERROR, \"invalid suffix '%.*s' on integer constant\",\n \t     (int) (end - p), p);\n  syntax_error:\n   op.op = CPP_ERROR;\n@@ -230,20 +231,21 @@ parse_defined (pfile)\n       node = token->val.node;\n       if (paren && cpp_get_token (pfile)->type != CPP_CLOSE_PAREN)\n \t{\n-\t  cpp_error (pfile, \"missing ')' after \\\"defined\\\"\");\n+\t  cpp_error (pfile, DL_ERROR, \"missing ')' after \\\"defined\\\"\");\n \t  node = 0;\n \t}\n     }\n   else\n     {\n-      cpp_error (pfile, \"operator \\\"defined\\\" requires an identifier\");\n+      cpp_error (pfile, DL_ERROR,\n+\t\t \"operator \\\"defined\\\" requires an identifier\");\n       if (token->flags & NAMED_OP)\n \t{\n \t  cpp_token op;\n \n \t  op.flags = 0;\n \t  op.type = token->type;\n-\t  cpp_error (pfile,\n+\t  cpp_error (pfile, DL_ERROR,\n \t\t     \"(\\\"%s\\\" is an alternative token for \\\"%s\\\" in C++)\",\n \t\t     cpp_token_as_text (pfile, token),\n \t\t     cpp_token_as_text (pfile, &op));\n@@ -255,7 +257,8 @@ parse_defined (pfile)\n   else\n     {\n       if (pfile->context != initial_context)\n-\tcpp_warning (pfile, \"this use of \\\"defined\\\" may not be portable\");\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"this use of \\\"defined\\\" may not be portable\");\n \n       op.value = node->type == NT_MACRO;\n       op.unsignedp = 0;\n@@ -326,8 +329,9 @@ lex (pfile, skip_evaluation)\n \t     and stdbool.h has not been included.  */\n \t  if (CPP_PEDANTIC (pfile)\n \t      && ! cpp_defined (pfile, DSC(\"__bool_true_false_are_defined\")))\n-\t    cpp_pedwarn (pfile, \"ISO C++ does not permit \\\"%s\\\" in #if\",\n-\t\t\t NODE_NAME (token->val.node));\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"ISO C++ does not permit \\\"%s\\\" in #if\",\n+\t\t       NODE_NAME (token->val.node));\n \t  return op;\n \t}\n       else\n@@ -337,8 +341,8 @@ lex (pfile, skip_evaluation)\n \t  op.value = 0;\n \n \t  if (CPP_OPTION (pfile, warn_undef) && !skip_evaluation)\n-\t    cpp_warning (pfile, \"\\\"%s\\\" is not defined\",\n-\t\t\t NODE_NAME (token->val.node));\n+\t    cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" is not defined\",\n+\t\t       NODE_NAME (token->val.node));\n \t  return op;\n \t}\n \n@@ -378,7 +382,8 @@ integer_overflow (pfile)\n      cpp_reader *pfile;\n {\n   if (CPP_PEDANTIC (pfile))\n-    cpp_pedwarn (pfile, \"integer overflow in preprocessor expression\");\n+    cpp_error (pfile, DL_PEDWARN,\n+\t       \"integer overflow in preprocessor expression\");\n }\n \n /* Handle shifting A left by B bits.  UNSIGNEDP is non-zero if A is\n@@ -657,8 +662,8 @@ _cpp_parse_expr (pfile)\n \t  switch (top[1].op)\n \t    {\n \t    default:\n-\t      cpp_ice (pfile, \"impossible operator '%s'\",\n-\t\t\t       op_as_text (pfile, top[1].op));\n+\t      cpp_error (pfile, DL_ICE, \"impossible operator '%s'\",\n+\t\t\t op_as_text (pfile, top[1].op));\n \t      goto syntax_error;\n \n \t    case CPP_NOT:\t UNARY(!);\tbreak;\n@@ -688,7 +693,7 @@ _cpp_parse_expr (pfile)\n \t\t  top->flags |= HAVE_VALUE;\n \n \t\t  if (CPP_WTRADITIONAL (pfile))\n-\t\t    cpp_warning (pfile,\n+\t\t    cpp_error (pfile, DL_WARNING,\n \t\t\t\"traditional C rejects the unary plus operator\");\n \t\t}\n \t      else\n@@ -767,7 +772,8 @@ _cpp_parse_expr (pfile)\n \t      break;\n \t    case CPP_COMMA:\n \t      if (CPP_PEDANTIC (pfile))\n-\t\tcpp_pedwarn (pfile, \"comma operator in operand of #if\");\n+\t\tcpp_error (pfile, DL_PEDWARN,\n+\t\t\t   \"comma operator in operand of #if\");\n \t      top->value = v2;\n \t      top->unsignedp = unsigned2;\n \t      break;\n@@ -860,7 +866,10 @@ _cpp_parse_expr (pfile)\n   result = (top[1].value != 0);\n \n   if (top != stack)\n-    CPP_ICE (\"unbalanced stack in #if\");\n+    {\n+      cpp_error (pfile, DL_ICE, \"unbalanced stack in #if\");\n+      goto syntax_error;\n+    }\n   else if (!(top[1].flags & HAVE_VALUE))\n     {\n       SYNTAX_ERROR (\"#if with no expression\");"}, {"sha": "c1e6bfc6c173c150012bb7b59b2c1b2dbd7ae85b", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -392,7 +392,7 @@ read_include_file (pfile, inc)\n \t does not bite us.  */\n       if (inc->st.st_size > INTTYPE_MAXIMUM (ssize_t))\n \t{\n-\t  cpp_error (pfile, \"%s is too large\", inc->name);\n+\t  cpp_error (pfile, DL_ERROR, \"%s is too large\", inc->name);\n \t  goto fail;\n \t}\n       size = inc->st.st_size;\n@@ -422,8 +422,8 @@ read_include_file (pfile, inc)\n \t      if (count == 0)\n \t\t{\n \t\t  if (!STAT_SIZE_TOO_BIG (inc->st))\n-\t\t    cpp_warning\n-\t\t      (pfile, \"%s is shorter than expected\", inc->name);\n+\t\t    cpp_error (pfile, DL_WARNING,\n+\t\t\t       \"%s is shorter than expected\", inc->name);\n \t\t  size = offset;\n \t\t  buf = xrealloc (buf, size + 1);\n \t\t  inc->st.st_size = size;\n@@ -437,7 +437,7 @@ read_include_file (pfile, inc)\n     }\n   else if (S_ISBLK (inc->st.st_mode))\n     {\n-      cpp_error (pfile, \"%s is a block device\", inc->name);\n+      cpp_error (pfile, DL_ERROR, \"%s is a block device\", inc->name);\n       goto fail;\n     }\n   else\n@@ -473,7 +473,7 @@ read_include_file (pfile, inc)\n   return 0;\n \n  perror_fail:\n-  cpp_error_from_errno (pfile, inc->name);\n+  cpp_errno (pfile, DL_ERROR, inc->name);\n  fail:\n   return 1;\n }\n@@ -563,7 +563,8 @@ find_include_file (pfile, header, type)\n \n   if (path == NULL)\n     {\n-      cpp_error (pfile, \"no include path in which to find %s\", fname);\n+      cpp_error (pfile, DL_ERROR, \"no include path in which to find %s\",\n+\t\t fname);\n       return NO_INCLUDE_PATH;\n     }\n \n@@ -685,12 +686,10 @@ handle_missing_header (pfile, fname, angle_brackets)\n      we can still produce correct output.  Otherwise, we can't produce\n      correct output, because there may be dependencies we need inside\n      the missing file, and we don't know what directory this missing\n-     file exists in.  FIXME: Use a future cpp_diagnostic_with_errno ()\n-     for both of these cases.  */\n-  else if (CPP_PRINT_DEPS (pfile) && ! print_dep)\n-    cpp_warning (pfile, \"%s: %s\", fname, xstrerror (errno));\n+     file exists in.  */\n   else\n-    cpp_error_from_errno (pfile, fname);\n+    cpp_errno (pfile, CPP_PRINT_DEPS (pfile) && ! print_dep\n+\t       ? DL_WARNING: DL_ERROR, fname);\n }\n \n /* Handles #include-family directives (distinguished by TYPE),\n@@ -754,7 +753,7 @@ _cpp_read_file (pfile, fname)\n \n   if (f == NULL)\n     {\n-      cpp_error_from_errno (pfile, fname);\n+      cpp_errno (pfile, DL_ERROR, fname);\n       return false;\n     }\n \n@@ -1026,7 +1025,7 @@ remap_filename (pfile, name, loc)\n \n   /* We know p != name as absolute paths don't call remap_filename.  */\n   if (p == name)\n-    cpp_ice (pfile, \"absolute file name in remap_filename\");\n+    cpp_error (pfile, DL_ICE, \"absolute file name in remap_filename\");\n \n   dir = (char *) alloca (p - name + 1);\n   memcpy (dir, name, p - name);"}, {"sha": "11483b0edef1506047a539c2627dcefb1bb9a91b", "filename": "gcc/cpphash.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -356,8 +356,7 @@ extern unsigned char _cpp_trigraph_map[UCHAR_MAX + 1];\n #define CPP_WTRADITIONAL(PF) CPP_OPTION (PF, warn_traditional)\n \n /* In cpperror.c  */\n-enum error_type { WARNING = 0, WARNING_SYSHDR, PEDWARN, ERROR, FATAL, ICE };\n-extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n+extern int _cpp_begin_message PARAMS ((cpp_reader *, int,\n \t\t\t\t       unsigned int, unsigned int));\n \n /* In cppmacro.c */"}, {"sha": "a9092edf429c4e2ef867282e258f0f14a525f26d", "filename": "gcc/cppinit.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -225,7 +225,7 @@ append_include_chain (pfile, dir, path, cxx_aware)\n     {\n       /* Dirs that don't exist are silently ignored.  */\n       if (errno != ENOENT)\n-\tcpp_notice_from_errno (pfile, dir);\n+\tcpp_errno (pfile, DL_ERROR, dir);\n       else if (CPP_OPTION (pfile, verbose))\n \tfprintf (stderr, _(\"ignoring nonexistent directory \\\"%s\\\"\\n\"), dir);\n       free (dir);\n@@ -234,7 +234,7 @@ append_include_chain (pfile, dir, path, cxx_aware)\n \n   if (!S_ISDIR (st.st_mode))\n     {\n-      cpp_notice (pfile, \"%s: Not a directory\", dir);\n+      cpp_error_with_line (pfile, DL_ERROR, 0, 0, \"%s: Not a directory\", dir);\n       free (dir);\n       return;\n     }\n@@ -308,16 +308,16 @@ remove_dup_dirs (pfile, head)\n \t  {\n \t    if (cur->sysp && !other->sysp)\n \t      {\n-\t\tcpp_warning (pfile,\n-\t\t\t     \"changing search order for system directory \\\"%s\\\"\",\n-\t\t\t     cur->name);\n+\t\tcpp_error (pfile, DL_WARNING,\n+\t\t\t   \"changing search order for system directory \\\"%s\\\"\",\n+\t\t\t   cur->name);\n \t\tif (strcmp (cur->name, other->name))\n-\t\t  cpp_warning (pfile, \n-\t\t\t       \"  as it is the same as non-system directory \\\"%s\\\"\",\n-\t\t\t       other->name);\n+\t\t  cpp_error (pfile, DL_WARNING,\n+\t\t\t     \"  as it is the same as non-system directory \\\"%s\\\"\",\n+\t\t\t     other->name);\n \t\telse\n-\t\t  cpp_warning (pfile, \n-\t\t\t       \"  as it has already been specified as a non-system directory\");\n+\t\t  cpp_error (pfile, DL_WARNING,\n+\t\t\t     \"  as it has already been specified as a non-system directory\");\n \t      }\n \t    cur = remove_dup_dir (pfile, prev);\n \t    break;\n@@ -1092,7 +1092,7 @@ output_deps (pfile)\n       deps_stream = fopen (CPP_OPTION (pfile, deps_file), deps_mode);\n       if (deps_stream == 0)\n \t{\n-\t  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, deps_file));\n+\t  cpp_errno (pfile, DL_ERROR, CPP_OPTION (pfile, deps_file));\n \t  return;\n \t}\n     }\n@@ -1106,7 +1106,7 @@ output_deps (pfile)\n   if (deps_stream != stdout)\n     {\n       if (ferror (deps_stream) || fclose (deps_stream) != 0)\n-\tcpp_fatal (pfile, \"I/O error on output\");\n+\tcpp_error (pfile, DL_FATAL, \"I/O error on output\");\n     }\n }\n \n@@ -1350,7 +1350,8 @@ cpp_handle_option (pfile, argc, argv, ignore)\n       else if (CPP_OPTION (pfile, out_fname) == NULL)\n \tCPP_OPTION (pfile, out_fname) = argv[i];\n       else\n-\tcpp_fatal (pfile, \"too many filenames. Type %s --help for usage info\",\n+\tcpp_error (pfile, DL_FATAL,\n+\t\t   \"too many filenames. Type %s --help for usage info\",\n \t\t   progname);\n     }\n   else\n@@ -1377,7 +1378,8 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t      arg = argv[++i];\n \t      if (!arg)\n \t\t{\n-\t\t  cpp_fatal (pfile, cl_options[opt_index].msg, argv[i - 1]);\n+\t\t  cpp_error (pfile, DL_FATAL,\n+\t\t\t     cl_options[opt_index].msg, argv[i - 1]);\n \t\t  return argc;\n \t\t}\n \t    }\n@@ -1545,7 +1547,7 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t    CPP_OPTION (pfile, out_fname) = arg;\n \t  else\n \t    {\n-\t      cpp_fatal (pfile, \"output filename specified twice\");\n+\t      cpp_error (pfile, DL_FATAL, \"output filename specified twice\");\n \t      return argc;\n \t    }\n \t  break;\n@@ -1657,7 +1659,7 @@ cpp_handle_option (pfile, argc, argv, ignore)\n \t\t}\n \t      else\n \t\t{\n-\t\t  cpp_fatal (pfile, \"-I- specified twice\");\n+\t\t  cpp_error (pfile, DL_FATAL, \"-I- specified twice\");\n \t\t  return argc;\n \t\t}\n  \t    }\n@@ -1843,7 +1845,8 @@ cpp_post_options (pfile)\n       (CPP_OPTION (pfile, print_deps_missing_files)\n        || CPP_OPTION (pfile, deps_file)\n        || CPP_OPTION (pfile, deps_phony_targets)))\n-    cpp_fatal (pfile, \"you must additionally specify either -M or -MM\");\n+    cpp_error (pfile, DL_FATAL,\n+\t       \"you must additionally specify either -M or -MM\");\n }\n \n /* Set up dependency-file output.  On exit, if print_deps is non-zero"}, {"sha": "47b1bcf86402020457b6bf0c8bdbf24b1416b483", "filename": "gcc/cpplex.c", "status": "modified", "additions": 62, "deletions": 48, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -150,16 +150,17 @@ trigraph_p (pfile)\n   if (CPP_OPTION (pfile, warn_trigraphs) && !pfile->state.lexing_comment)\n     {\n       if (accept)\n-\tcpp_warning_with_line (pfile, pfile->line, CPP_BUF_COL (buffer) - 1,\n-\t\t\t       \"trigraph ??%c converted to %c\",\n-\t\t\t       (int) from_char,\n-\t\t\t       (int) _cpp_trigraph_map[from_char]);\n+\tcpp_error_with_line (pfile, DL_WARNING,\n+\t\t\t     pfile->line, CPP_BUF_COL (buffer) - 1,\n+\t\t\t     \"trigraph ??%c converted to %c\",\n+\t\t\t     (int) from_char,\n+\t\t\t     (int) _cpp_trigraph_map[from_char]);\n       else if (buffer->cur != buffer->last_Wtrigraphs)\n \t{\n \t  buffer->last_Wtrigraphs = buffer->cur;\n-\t  cpp_warning_with_line (pfile, pfile->line,\n-\t\t\t\t CPP_BUF_COL (buffer) - 1,\n-\t\t\t\t \"trigraph ??%c ignored\", (int) from_char);\n+\t  cpp_error_with_line (pfile, DL_WARNING,\n+\t\t\t       pfile->line, CPP_BUF_COL (buffer) - 1,\n+\t\t\t       \"trigraph ??%c ignored\", (int) from_char);\n \t}\n     }\n \n@@ -215,13 +216,15 @@ skip_escaped_newlines (pfile)\n \n \t  if (saved_cur != buffer->cur - 1\n \t      && !pfile->state.lexing_comment)\n-\t    cpp_warning (pfile, \"backslash and newline separated by space\");\n+\t    cpp_error (pfile, DL_WARNING,\n+\t\t       \"backslash and newline separated by space\");\n \n \t  handle_newline (pfile);\n \t  buffer->backup_to = buffer->cur;\n \t  if (buffer->cur == buffer->rlimit)\n \t    {\n-\t      cpp_pedwarn (pfile, \"backslash-newline at end of file\");\n+\t      cpp_error (pfile, DL_PEDWARN,\n+\t\t\t \"backslash-newline at end of file\");\n \t      next = EOF;\n \t    }\n \t  else\n@@ -285,9 +288,9 @@ skip_block_comment (pfile)\n \t     Don't bother to get it right across escaped newlines.  */\n \t  if (CPP_OPTION (pfile, warn_comments)\n \t      && buffer->cur[0] == '*' && buffer->cur[1] != '/')\n-\t    cpp_warning_with_line (pfile,\n-\t\t\t\t   pfile->line, CPP_BUF_COL (buffer),\n-\t\t\t\t   \"\\\"/*\\\" within comment\");\n+\t    cpp_error_with_line (pfile, DL_WARNING,\n+\t\t\t\t pfile->line, CPP_BUF_COL (buffer),\n+\t\t\t\t \"\\\"/*\\\" within comment\");\n \t}\n       else if (is_vspace (c))\n \thandle_newline (pfile);\n@@ -370,15 +373,15 @@ skip_whitespace (pfile, c)\n \t    return 0;\n \t  if (!warned)\n \t    {\n-\t      cpp_warning (pfile, \"null character(s) ignored\");\n+\t      cpp_error (pfile, DL_WARNING, \"null character(s) ignored\");\n \t      warned = 1;\n \t    }\n \t}\n       else if (pfile->state.in_directive && CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn_with_line (pfile, pfile->line,\n-\t\t\t       CPP_BUF_COL (buffer),\n-\t\t\t       \"%s in preprocessing directive\",\n-\t\t\t       c == '\\f' ? \"form feed\" : \"vertical tab\");\n+\tcpp_error_with_line (pfile, DL_PEDWARN, pfile->line,\n+\t\t\t     CPP_BUF_COL (buffer),\n+\t\t\t     \"%s in preprocessing directive\",\n+\t\t\t     c == '\\f' ? \"form feed\" : \"vertical tab\");\n \n       c = *buffer->cur++;\n     }\n@@ -450,14 +453,14 @@ parse_identifier (pfile)\n     {\n       /* It is allowed to poison the same identifier twice.  */\n       if ((result->flags & NODE_POISONED) && !pfile->state.poisoned_ok)\n-\tcpp_error (pfile, \"attempt to use poisoned \\\"%s\\\"\",\n+\tcpp_error (pfile, DL_ERROR, \"attempt to use poisoned \\\"%s\\\"\",\n \t\t   NODE_NAME (result));\n \n       /* Constraint 6.10.3.5: __VA_ARGS__ should only appear in the\n \t replacement list of a variadic macro.  */\n       if (result == pfile->spec_nodes.n__VA_ARGS__\n \t  && !pfile->state.va_args_ok)\n-\tcpp_pedwarn (pfile,\n+\tcpp_error (pfile, DL_PEDWARN,\n \t\"__VA_ARGS__ can only appear in the expansion of a C99 variadic macro\");\n     }\n \n@@ -530,7 +533,7 @@ parse_slow (pfile, cur, number_p, plen)\n      accepted as an extension.  Don't warn about it in skipped\n      conditional blocks.  */\n   if (saw_dollar && CPP_PEDANTIC (pfile) && ! pfile->state.skipping)\n-    cpp_pedwarn (pfile, \"'$' character(s) in identifier or number\");\n+    cpp_error (pfile, DL_PEDWARN, \"'$' character(s) in identifier or number\");\n \n   /* Identifiers and numbers are null-terminated.  */\n   *plen = obstack_object_size (stack);\n@@ -647,7 +650,8 @@ parse_string (pfile, token, terminator)\n \t     comments are.  */\n \tunterminated:\n \t  if (CPP_OPTION (pfile, lang) != CLK_ASM || terminator == '>')\n-\t    cpp_error (pfile, \"missing terminating %c character\", terminator);\n+\t    cpp_error (pfile, DL_ERROR, \"missing terminating %c character\",\n+\t\t       terminator);\n \t  buffer->cur--;\n \t  break;\n \t}\n@@ -658,7 +662,8 @@ parse_string (pfile, token, terminator)\n \t  if (!warned_nulls)\n \t    {\n \t      warned_nulls = true;\n-\t      cpp_warning (pfile, \"null character(s) preserved in literal\");\n+\t      cpp_error (pfile, DL_WARNING,\n+\t\t\t \"null character(s) preserved in literal\");\n \t    }\n \t}\n \n@@ -881,7 +886,7 @@ _cpp_lex_direct (pfile)\n \t      /* Non-empty files should end in a newline.  Don't warn\n \t\t for command line and _Pragma buffers.  */\n \t      if (!buffer->from_stage3)\n-\t\tcpp_pedwarn (pfile, \"no newline at end of file\");\n+\t\tcpp_error (pfile, DL_PEDWARN, \"no newline at end of file\");\n \t      handle_newline (pfile);\n \t    }\n \n@@ -1001,7 +1006,7 @@ _cpp_lex_direct (pfile)\n       if (c == '*')\n \t{\n \t  if (skip_block_comment (pfile))\n-\t    cpp_error (pfile, \"unterminated comment\");\n+\t    cpp_error (pfile, DL_ERROR, \"unterminated comment\");\n \t}\n       else if (c == '/' && (CPP_OPTION (pfile, cplusplus_comments)\n \t\t\t    || CPP_IN_SYSTEM_HEADER (pfile)))\n@@ -1011,15 +1016,15 @@ _cpp_lex_direct (pfile)\n \t  if (CPP_OPTION (pfile, lang) == CLK_GNUC89 && CPP_PEDANTIC (pfile)\n \t      && ! buffer->warned_cplusplus_comments)\n \t    {\n-\t      cpp_pedwarn (pfile,\n+\t      cpp_error (pfile, DL_PEDWARN,\n \t\t\t   \"C++ style comments are not allowed in ISO C89\");\n-\t      cpp_pedwarn (pfile,\n-\t\t\t   \"(this will be reported only once per input file)\");\n+\t      cpp_error (pfile, DL_PEDWARN,\n+\t\t\t \"(this will be reported only once per input file)\");\n \t      buffer->warned_cplusplus_comments = 1;\n \t    }\n \n \t  if (skip_line_comment (pfile) && CPP_OPTION (pfile, warn_comments))\n-\t    cpp_warning (pfile, \"multi-line comment\");\n+\t    cpp_error (pfile, DL_WARNING, \"multi-line comment\");\n \t}\n       else if (c == '=')\n \t{\n@@ -1334,7 +1339,8 @@ cpp_spell_token (pfile, token, buffer)\n     \t  case CPP_WCHAR:\tleft = '\\''; right = '\\''; tag = 'L';  break;\n \t  case CPP_HEADER_NAME:\tleft = '<';  right = '>';  tag = '\\0'; break;\n \t  default:\n-\t    cpp_ice (pfile, \"unknown string token %s\\n\", TOKEN_NAME (token));\n+\t    cpp_error (pfile, DL_ICE, \"unknown string token %s\\n\",\n+\t\t       TOKEN_NAME (token));\n \t    return buffer;\n \t  }\n \tif (tag) *buffer++ = tag;\n@@ -1346,7 +1352,7 @@ cpp_spell_token (pfile, token, buffer)\n       break;\n \n     case SPELL_NONE:\n-      cpp_ice (pfile, \"unspellable token %s\", TOKEN_NAME (token));\n+      cpp_error (pfile, DL_ICE, \"unspellable token %s\", TOKEN_NAME (token));\n       break;\n     }\n \n@@ -1602,13 +1608,14 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n     return 1;\n \n   if (CPP_WTRADITIONAL (pfile))\n-    cpp_warning (pfile, \"the meaning of '\\\\%c' is different in traditional C\", c);\n+    cpp_error (pfile, DL_WARNING,\n+\t       \"the meaning of '\\\\%c' is different in traditional C\", c);\n \n   length = (c == 'u' ? 4: 8);\n \n   if ((size_t) (limit - p) < length)\n     {\n-      cpp_error (pfile, \"incomplete universal-character-name\");\n+      cpp_error (pfile, DL_ERROR, \"incomplete universal-character-name\");\n       /* Skip to the end to avoid more diagnostics.  */\n       p = limit;\n     }\n@@ -1621,7 +1628,7 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n \t    code = (code << 4) + hex_digit_value (c);\n \t  else\n \t    {\n-\t      cpp_error (pfile,\n+\t      cpp_error (pfile, DL_ERROR,\n \t\t\t \"non-hex digit '%c' in universal-character-name\", c);\n \t      /* We shouldn't skip in case there are multibyte chars.  */\n \t      break;\n@@ -1630,7 +1637,7 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n     }\n \n #ifdef TARGET_EBCDIC\n-  cpp_error (pfile, \"universal-character-name on EBCDIC target\");\n+  cpp_error (pfile, DL_ERROR, \"universal-character-name on EBCDIC target\");\n   code = 0x3f;  /* EBCDIC invalid character */\n #else\n  /* True extended characters are OK.  */\n@@ -1644,7 +1651,7 @@ maybe_read_ucs (pfile, pstr, limit, pc)\n     ;\n   /* Don't give another error if one occurred above.  */\n   else if (length == 0)\n-    cpp_error (pfile, \"universal-character-name out of range\");\n+    cpp_error (pfile, DL_ERROR, \"universal-character-name out of range\");\n #endif\n \n   *pstr = p;\n@@ -1687,13 +1694,15 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n \n     case 'a':\n       if (CPP_WTRADITIONAL (pfile))\n-\tcpp_warning (pfile, \"the meaning of '\\\\a' is different in traditional C\");\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"the meaning of '\\\\a' is different in traditional C\");\n       c = TARGET_BELL;\n       break;\n \n     case 'e': case 'E':\n       if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn (pfile, \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"non-ISO-standard escape sequence, '\\\\%c'\", c);\n       c = TARGET_ESC;\n       break;\n       \n@@ -1703,7 +1712,8 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n \n     case 'x':\n       if (CPP_WTRADITIONAL (pfile))\n-\tcpp_warning (pfile, \"the meaning of '\\\\x' is different in traditional C\");\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"the meaning of '\\\\x' is different in traditional C\");\n \n \t{\n \t  unsigned int i = 0, overflow = 0;\n@@ -1721,11 +1731,13 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n \t    }\n \n \t  if (!digits_found)\n-\t    cpp_error (pfile, \"\\\\x used with no following hex digits\");\n+\t    cpp_error (pfile, DL_ERROR, \n+\t\t       \"\\\\x used with no following hex digits\");\n \n \t  if (overflow | (i != (i & mask)))\n \t    {\n-\t      cpp_pedwarn (pfile, \"hex escape sequence out of range\");\n+\t      cpp_error (pfile, DL_PEDWARN,\n+\t\t\t \"hex escape sequence out of range\");\n \t      i &= mask;\n \t    }\n \t  c = i;\n@@ -1749,7 +1761,8 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n \n \tif (i != (i & mask))\n \t  {\n-\t    cpp_pedwarn (pfile, \"octal escape sequence out of range\");\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"octal escape sequence out of range\");\n \t    i &= mask;\n \t  }\n \tc = i;\n@@ -1764,13 +1777,13 @@ cpp_parse_escape (pfile, pstr, limit, mask)\n   if (unknown)\n     {\n       if (ISGRAPH (c))\n-\tcpp_pedwarn (pfile, \"unknown escape sequence '\\\\%c'\", c);\n+\tcpp_error (pfile, DL_PEDWARN, \"unknown escape sequence '\\\\%c'\", c);\n       else\n-\tcpp_pedwarn (pfile, \"unknown escape sequence: '\\\\%03o'\", c);\n+\tcpp_error (pfile, DL_PEDWARN, \"unknown escape sequence: '\\\\%03o'\", c);\n     }\n \n   if (c > mask)\n-    cpp_pedwarn (pfile, \"escape sequence out of range for character\");\n+    cpp_error (pfile, DL_PEDWARN, \"escape sequence out of range for type\");\n \n   *pstr = str;\n   return c;\n@@ -1833,7 +1846,8 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n       char_len = local_mbtowc (&wc, str, limit - str);\n       if (char_len == -1)\n \t{\n-\t  cpp_warning (pfile, \"ignoring invalid multibyte character\");\n+\t  cpp_error (pfile, DL_WARNING,\n+\t\t     \"ignoring invalid multibyte character\");\n \t  c = *str++;\n \t}\n       else\n@@ -1864,14 +1878,14 @@ cpp_interpret_charconst (pfile, token, warn_multi, pchars_seen)\n     }\n \n   if (chars_seen == 0)\n-    cpp_error (pfile, \"empty character constant\");\n+    cpp_error (pfile, DL_ERROR, \"empty character constant\");\n   else if (chars_seen > max_chars)\n     {\n       chars_seen = max_chars;\n-      cpp_warning (pfile, \"character constant too long\");\n+      cpp_error (pfile, DL_WARNING, \"character constant too long\");\n     }\n   else if (chars_seen > 1 && warn_multi)\n-    cpp_warning (pfile, \"multi-character character constant\");\n+    cpp_error (pfile, DL_WARNING, \"multi-character character constant\");\n \n   /* If relevant type is signed, sign-extend the constant.  */\n   if (chars_seen)"}, {"sha": "52c394055c8030ff511fff3df11214ab864555e6", "filename": "gcc/cpplib.c", "status": "modified", "additions": 75, "deletions": 64, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -107,7 +107,7 @@ static U_CHAR *dequote_string\tPARAMS ((cpp_reader *, const U_CHAR *,\n \t\t\t\t\t unsigned int));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n-static void do_diagnostic\tPARAMS ((cpp_reader *, enum error_type, int));\n+static void do_diagnostic\tPARAMS ((cpp_reader *, int, int));\n static cpp_hashnode *lex_macro_node\tPARAMS ((cpp_reader *));\n static void do_include_common\tPARAMS ((cpp_reader *, enum include_type));\n static struct pragma_entry *lookup_pragma_entry\n@@ -225,8 +225,8 @@ check_eol (pfile)\n      cpp_reader *pfile;\n {\n   if (! SEEN_EOL () && _cpp_lex_token (pfile)->type != CPP_EOF)\n-    cpp_pedwarn (pfile, \"extra tokens at end of #%s directive\",\n-\t\t pfile->directive->name);\n+    cpp_error (pfile, DL_PEDWARN, \"extra tokens at end of #%s directive\",\n+\t       pfile->directive->name);\n }\n \n /* Called when entering a directive, _Pragma or command-line directive.  */\n@@ -278,7 +278,7 @@ directive_diagnostics (pfile, dir, indented)\n   if (CPP_PEDANTIC (pfile)\n       && ! pfile->state.skipping\n       && dir->origin == EXTENSION)\n-    cpp_pedwarn (pfile, \"#%s is a GCC extension\", dir->name);\n+    cpp_error (pfile, DL_PEDWARN, \"#%s is a GCC extension\", dir->name);\n \n   /* Traditionally, a directive is ignored unless its # is in\n      column 1.  Therefore in code intended to work with K+R\n@@ -289,15 +289,16 @@ directive_diagnostics (pfile, dir, indented)\n   if (CPP_WTRADITIONAL (pfile))\n     {\n       if (dir == &dtable[T_ELIF])\n-\tcpp_warning (pfile, \"suggest not using #elif in traditional C\");\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"suggest not using #elif in traditional C\");\n       else if (indented && dir->origin == KANDR)\n-\tcpp_warning (pfile,\n-\t\t     \"traditional C ignores #%s with the # indented\",\n-\t\t     dir->name);\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"traditional C ignores #%s with the # indented\",\n+\t\t   dir->name);\n       else if (!indented && dir->origin != KANDR)\n-\tcpp_warning (pfile,\n-\t\t     \"suggest hiding #%s from traditional C with an indented #\",\n-\t\t     dir->name);\n+\tcpp_error (pfile, DL_WARNING,\n+\t\t   \"suggest hiding #%s from traditional C with an indented #\",\n+\t\t   dir->name);\n     }\n }\n \n@@ -319,7 +320,7 @@ _cpp_handle_directive (pfile, indented)\n   if (was_parsing_args)\n     {\n       if (CPP_OPTION (pfile, pedantic))\n-\tcpp_pedwarn (pfile,\n+\tcpp_error (pfile, DL_PEDWARN,\n \t     \"embedding a directive within macro arguments is not portable\");\n       pfile->state.parsing_args = 0;\n       pfile->state.prevent_expansion = 0;\n@@ -339,7 +340,8 @@ _cpp_handle_directive (pfile, indented)\n       dir = &linemarker_dir;\n       if (CPP_PEDANTIC (pfile) && ! CPP_OPTION (pfile, preprocessed)\n \t  && ! pfile->state.skipping)\n-\tcpp_pedwarn (pfile, \"style of line directive is a GCC extension\");\n+\tcpp_error (pfile, DL_PEDWARN,\n+\t\t   \"style of line directive is a GCC extension\");\n     }\n \n   if (dir)\n@@ -388,7 +390,7 @@ _cpp_handle_directive (pfile, indented)\n       if (CPP_OPTION (pfile, lang) == CLK_ASM)\n \tskip = 0;\n       else if (!pfile->state.skipping)\n-\tcpp_error (pfile, \"invalid preprocessing directive #%s\",\n+\tcpp_error (pfile, DL_ERROR, \"invalid preprocessing directive #%s\",\n \t\t   cpp_token_as_text (pfile, dname));\n     }\n \n@@ -466,14 +468,14 @@ lex_macro_node (pfile)\n   if (token->type != CPP_NAME)\n     {\n       if (token->type == CPP_EOF)\n-\tcpp_error (pfile, \"no macro name given in #%s directive\",\n+\tcpp_error (pfile, DL_ERROR, \"no macro name given in #%s directive\",\n \t\t   pfile->directive->name);\n       else if (token->flags & NAMED_OP)\n-\tcpp_error (pfile,\n+\tcpp_error (pfile, DL_ERROR,\n \t   \"\\\"%s\\\" cannot be used as a macro name as it is an operator in C++\",\n \t\t   NODE_NAME (token->val.node));\n       else\n-\tcpp_error (pfile, \"macro names must be identifiers\");\n+\tcpp_error (pfile, DL_ERROR, \"macro names must be identifiers\");\n \n       return 0;\n     }\n@@ -484,7 +486,7 @@ lex_macro_node (pfile)\n \n   if (node == pfile->spec_nodes.n_defined)\n     {\n-      cpp_error (pfile, \"\\\"%s\\\" cannot be used as a macro name\",\n+      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" cannot be used as a macro name\",\n \t\t NODE_NAME (node));\n       return 0;\n     }\n@@ -522,7 +524,7 @@ do_undef (pfile)\n \t(*pfile->cb.undef) (pfile, pfile->directive_line, node);\n \n       if (node->flags & NODE_WARN)\n-\tcpp_warning (pfile, \"undefining \\\"%s\\\"\", NODE_NAME (node));\n+\tcpp_error (pfile, DL_WARNING, \"undefining \\\"%s\\\"\", NODE_NAME (node));\n \n       _cpp_free_definition (node);\n     }\n@@ -565,7 +567,7 @@ glue_header_name (pfile)\n     }\n \n   if (token->type == CPP_EOF)\n-    cpp_error (pfile, \"missing terminating > character\");\n+    cpp_error (pfile, DL_ERROR, \"missing terminating > character\");\n   else\n     {\n       unsigned char *token_mem = _cpp_unaligned_alloc (pfile, total_len + 1);\n@@ -603,7 +605,8 @@ parse_include (pfile)\n     {\n       if (header->type != CPP_LESS)\n \t{\n-\t  cpp_error (pfile, \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", dir);\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"#%s expects \\\"FILENAME\\\" or <FILENAME>\", dir);\n \t  return NULL;\n \t}\n \n@@ -614,7 +617,7 @@ parse_include (pfile)\n \n   if (header->val.str.len == 0)\n     {\n-      cpp_error (pfile, \"empty file name in #%s\", dir);\n+      cpp_error (pfile, DL_ERROR, \"empty file name in #%s\", dir);\n       return NULL;\n     }\n \n@@ -633,13 +636,13 @@ do_include_common (pfile, type)\n      use the normal search logic.  */\n   if (type == IT_INCLUDE_NEXT && ! pfile->buffer->prev)\n     {\n-      cpp_warning (pfile, \"#include_next in primary source file\");\n+      cpp_error (pfile, DL_WARNING, \"#include_next in primary source file\");\n       type = IT_INCLUDE;\n     }\n   else if (type == IT_IMPORT && CPP_OPTION (pfile, warn_import))\n     {\n       CPP_OPTION (pfile, warn_import) = 0;\n-      cpp_warning (pfile,\n+      cpp_error (pfile, DL_WARNING,\n \t   \"#import is obsolete, use an #ifndef wrapper in the header file\");\n     }\n \n@@ -648,7 +651,7 @@ do_include_common (pfile, type)\n     {\n       /* Prevent #include recursion.  */\n       if (pfile->line_maps.depth >= CPP_STACK_MAX)\n-\tcpp_fatal (pfile, \"#include nested too deeply\");\n+\tcpp_error (pfile, DL_FATAL, \"#include nested too deeply\");\n       else\n \t{\n \t  check_eol (pfile);\n@@ -706,7 +709,7 @@ read_flag (pfile, last)\n     }\n \n   if (token->type != CPP_EOF)\n-    cpp_error (pfile, \"invalid flag \\\"%s\\\" in line directive\",\n+    cpp_error (pfile, DL_ERROR, \"invalid flag \\\"%s\\\" in line directive\",\n \t       cpp_token_as_text (pfile, token));\n   return 0;\n }\n@@ -788,13 +791,14 @@ do_line (pfile)\n       || strtoul_for_line (token->val.str.text, token->val.str.len,\n \t\t\t   &new_lineno))\n     {\n-      cpp_error (pfile, \"\\\"%s\\\" after #line is not a positive integer\",\n+      cpp_error (pfile, DL_ERROR,\n+\t\t \"\\\"%s\\\" after #line is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }      \n \n   if (CPP_PEDANTIC (pfile) && (new_lineno == 0 || new_lineno > cap))\n-    cpp_pedwarn (pfile, \"line number out of range\");\n+    cpp_error (pfile, DL_PEDWARN, \"line number out of range\");\n \n   token = cpp_get_token (pfile);\n   if (token->type == CPP_STRING)\n@@ -805,7 +809,7 @@ do_line (pfile)\n     }\n   else if (token->type != CPP_EOF)\n     {\n-      cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n+      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n@@ -840,7 +844,7 @@ do_linemarker (pfile)\n       || strtoul_for_line (token->val.str.text, token->val.str.len,\n \t\t\t   &new_lineno))\n     {\n-      cpp_error (pfile, \"\\\"%s\\\" after # is not a positive integer\",\n+      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" after # is not a positive integer\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }      \n@@ -876,7 +880,7 @@ do_linemarker (pfile)\n     }\n   else if (token->type != CPP_EOF)\n     {\n-      cpp_error (pfile, \"\\\"%s\\\" is not a valid filename\",\n+      cpp_error (pfile, DL_ERROR, \"\\\"%s\\\" is not a valid filename\",\n \t\t cpp_token_as_text (pfile, token));\n       return;\n     }\n@@ -909,10 +913,12 @@ _cpp_do_file_change (pfile, reason, to_file, file_line, sysp)\n static void\n do_diagnostic (pfile, code, print_dir)\n      cpp_reader *pfile;\n-     enum error_type code;\n+     int code;\n      int print_dir;\n {\n-  if (_cpp_begin_message (pfile, code, 0, 0))\n+  if (_cpp_begin_message (pfile, code,\n+\t\t\t  pfile->cur_token[-1].line,\n+\t\t\t  pfile->cur_token[-1].col))\n     {\n       if (print_dir)\n \tfprintf (stderr, \"#%s \", pfile->directive->name);\n@@ -926,15 +932,15 @@ static void\n do_error (pfile)\n      cpp_reader *pfile;\n {\n-  do_diagnostic (pfile, ERROR, 1);\n+  do_diagnostic (pfile, DL_ERROR, 1);\n }\n \n static void\n do_warning (pfile)\n      cpp_reader *pfile;\n {\n   /* We want #warning diagnostics to be emitted in system headers too.  */\n-  do_diagnostic (pfile, WARNING_SYSHDR, 1);\n+  do_diagnostic (pfile, DL_WARNING_SYSHDR, 1);\n }\n \n /* Report program identification.  */\n@@ -945,7 +951,7 @@ do_ident (pfile)\n   const cpp_token *str = cpp_get_token (pfile);\n \n   if (str->type != CPP_STRING)\n-    cpp_error (pfile, \"invalid #ident directive\");\n+    cpp_error (pfile, DL_ERROR, \"invalid #ident directive\");\n   else if (pfile->cb.ident)\n     (*pfile->cb.ident) (pfile, pfile->directive_line, &str->val.str);\n \n@@ -1032,13 +1038,14 @@ cpp_register_pragma (pfile, space, name, handler)\n     {\n       if (entry->is_nspace)\n \tclash:\n-\tcpp_ice (pfile,\n+\tcpp_error (pfile, DL_ICE,\n \t\t \"registering \\\"%s\\\" as both a pragma and a pragma namespace\",\n \t\t NODE_NAME (node));\n       else if (space)\n-\tcpp_ice (pfile, \"#pragma %s %s is already registered\", space, name);\n+\tcpp_error (pfile, DL_ICE, \"#pragma %s %s is already registered\",\n+\t\t   space, name);\n       else\n-\tcpp_ice (pfile, \"#pragma %s is already registered\", name);\n+\tcpp_error (pfile, DL_ICE, \"#pragma %s is already registered\", name);\n     }\n   else\n     insert_pragma_entry (pfile, chain, node, handler);\n@@ -1113,10 +1120,10 @@ static void\n do_pragma_once (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_warning (pfile, \"#pragma once is obsolete\");\n+  cpp_error (pfile, DL_WARNING, \"#pragma once is obsolete\");\n  \n   if (pfile->buffer->prev == NULL)\n-    cpp_warning (pfile, \"#pragma once in main file\");\n+    cpp_error (pfile, DL_WARNING, \"#pragma once in main file\");\n   else\n     _cpp_never_reread (pfile->buffer->inc);\n \n@@ -1140,7 +1147,7 @@ do_pragma_poison (pfile)\n \tbreak;\n       if (tok->type != CPP_NAME)\n \t{\n-\t  cpp_error (pfile, \"invalid #pragma GCC poison directive\");\n+\t  cpp_error (pfile, DL_ERROR, \"invalid #pragma GCC poison directive\");\n \t  break;\n \t}\n \n@@ -1149,7 +1156,8 @@ do_pragma_poison (pfile)\n \tcontinue;\n \n       if (hp->type == NT_MACRO)\n-\tcpp_warning (pfile, \"poisoning existing macro \\\"%s\\\"\", NODE_NAME (hp));\n+\tcpp_error (pfile, DL_WARNING, \"poisoning existing macro \\\"%s\\\"\",\n+\t\t   NODE_NAME (hp));\n       _cpp_free_definition (hp);\n       hp->flags |= NODE_POISONED | NODE_DIAGNOSTIC;\n     }\n@@ -1169,7 +1177,8 @@ do_pragma_system_header (pfile)\n   cpp_buffer *buffer = pfile->buffer;\n \n   if (buffer->prev == 0)\n-    cpp_warning (pfile, \"#pragma system_header ignored outside include file\");\n+    cpp_error (pfile, DL_WARNING,\n+\t       \"#pragma system_header ignored outside include file\");\n   else\n     {\n       check_eol (pfile);\n@@ -1194,16 +1203,16 @@ do_pragma_dependency (pfile)\n \n   ordering = _cpp_compare_file_date (pfile, header);\n   if (ordering < 0)\n-    cpp_warning (pfile, \"cannot find source %s\",\n-\t\t cpp_token_as_text (pfile, header));\n+    cpp_error (pfile, DL_WARNING, \"cannot find source %s\",\n+\t       cpp_token_as_text (pfile, header));\n   else if (ordering > 0)\n     {\n-      cpp_warning (pfile, \"current file is older than %s\",\n-\t\t   cpp_token_as_text (pfile, header));\n+      cpp_error (pfile, DL_WARNING, \"current file is older than %s\",\n+\t\t cpp_token_as_text (pfile, header));\n       if (cpp_get_token (pfile)->type != CPP_EOF)\n \t{\n \t  _cpp_backup_tokens (pfile, 1);\n-\t  do_diagnostic (pfile, WARNING, 0);\n+\t  do_diagnostic (pfile, DL_WARNING, 0);\n \t}\n     }\n }\n@@ -1273,7 +1282,8 @@ _cpp_do__Pragma (pfile)\n   const cpp_token *string = get__Pragma_string (pfile);\n \n   if (!string)\n-    cpp_error (pfile, \"_Pragma takes a parenthesized string literal\");\n+    cpp_error (pfile, DL_ERROR,\n+\t       \"_Pragma takes a parenthesized string literal\");\n   else\n     {\n       /* Ideally, we'd like\n@@ -1372,13 +1382,13 @@ do_else (pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, \"#else without #if\");\n+    cpp_error (pfile, DL_ERROR, \"#else without #if\");\n   else\n     {\n       if (ifs->type == T_ELSE)\n \t{\n-\t  cpp_error (pfile, \"#else after #else\");\n-\t  cpp_error_with_line (pfile, ifs->line, 0,\n+\t  cpp_error (pfile, DL_ERROR, \"#else after #else\");\n+\t  cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELSE;\n@@ -1406,13 +1416,13 @@ do_elif (pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, \"#elif without #if\");\n+    cpp_error (pfile, DL_ERROR, \"#elif without #if\");\n   else\n     {\n       if (ifs->type == T_ELSE)\n \t{\n-\t  cpp_error (pfile, \"#elif after #else\");\n-\t  cpp_error_with_line (pfile, ifs->line, 0,\n+\t  cpp_error (pfile, DL_ERROR, \"#elif after #else\");\n+\t  cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n \t\t\t       \"the conditional began here\");\n \t}\n       ifs->type = T_ELIF;\n@@ -1442,7 +1452,7 @@ do_endif (pfile)\n   struct if_stack *ifs = buffer->if_stack;\n \n   if (ifs == NULL)\n-    cpp_error (pfile, \"#endif without #if\");\n+    cpp_error (pfile, DL_ERROR, \"#endif without #if\");\n   else\n     {\n       /* Only check EOL if was not originally skipping.  */\n@@ -1525,7 +1535,7 @@ parse_answer (pfile, answerp, type)\n       if (type == T_UNASSERT && paren->type == CPP_EOF)\n \treturn 0;\n \n-      cpp_error (pfile, \"missing '(' after predicate\");\n+      cpp_error (pfile, DL_ERROR, \"missing '(' after predicate\");\n       return 1;\n     }\n \n@@ -1540,7 +1550,7 @@ parse_answer (pfile, answerp, type)\n \n       if (token->type == CPP_EOF)\n \t{\n-\t  cpp_error (pfile, \"missing ')' to complete answer\");\n+\t  cpp_error (pfile, DL_ERROR, \"missing ')' to complete answer\");\n \t  return 1;\n \t}\n \n@@ -1560,7 +1570,7 @@ parse_answer (pfile, answerp, type)\n \n   if (acount == 0)\n     {\n-      cpp_error (pfile, \"predicate's answer is empty\");\n+      cpp_error (pfile, DL_ERROR, \"predicate's answer is empty\");\n       return 1;\n     }\n \n@@ -1590,9 +1600,9 @@ parse_assertion (pfile, answerp, type)\n   *answerp = 0;\n   predicate = cpp_get_token (pfile);\n   if (predicate->type == CPP_EOF)\n-    cpp_error (pfile, \"assertion without predicate\");\n+    cpp_error (pfile, DL_ERROR, \"assertion without predicate\");\n   else if (predicate->type != CPP_NAME)\n-    cpp_error (pfile, \"predicate must be an identifier\");\n+    cpp_error (pfile, DL_ERROR, \"predicate must be an identifier\");\n   else if (parse_answer (pfile, answerp, type) == 0)\n     {\n       unsigned int len = NODE_LEN (predicate->val.node);\n@@ -1674,7 +1684,8 @@ do_assert (pfile)\n \t{\n \t  if (*find_answer (node, new_answer))\n \t    {\n-\t      cpp_warning (pfile, \"\\\"%s\\\" re-asserted\", NODE_NAME (node) + 1);\n+\t      cpp_error (pfile, DL_WARNING, \"\\\"%s\\\" re-asserted\",\n+\t\t\t NODE_NAME (node) + 1);\n \t      return;\n \t    }\n \t  new_answer->next = node->value.answers;\n@@ -1903,7 +1914,7 @@ _cpp_pop_buffer (pfile)\n   /* Walk back up the conditional stack till we reach its level at\n      entry to this file, issuing error messages.  */\n   for (ifs = buffer->if_stack; ifs; ifs = ifs->next)\n-    cpp_error_with_line (pfile, ifs->line, 0,\n+    cpp_error_with_line (pfile, DL_ERROR, ifs->line, 0,\n \t\t\t \"unterminated #%s\", dtable[ifs->type].name);\n \n   /* In case of a missing #endif.  */"}, {"sha": "359326e0138384e2ce21e734f01e43c85a37e9ea", "filename": "gcc/cpplib.h", "status": "modified", "additions": 38, "deletions": 20, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -546,32 +546,50 @@ extern cpp_buffer *cpp_push_buffer PARAMS ((cpp_reader *,\n \t\t\t\t\t    int, int));\n extern int cpp_defined PARAMS ((cpp_reader *, const unsigned char *, int));\n \n+/* Diagnostic levels.  To get a dianostic without associating a\n+   position in the translation unit with it, use cpp_error_with_line\n+   with a line number of zero.  */\n+\n+/* Warning, an error with -Werror.  */\n+#define DL_WARNING\t\t0x00\n+/* Same as DL_WARNING, except it is not suppressed in system headers.  */\n+#define DL_WARNING_SYSHDR\t0x01\n+/* Warning, an error with -pedantic-errors or -Werror.  */\n+#define DL_PEDWARN\t\t0x02\n+/* An error.  */\n+#define DL_ERROR\t\t0x03\n+/* A fatal error.  We do not exit, to support use of cpplib as a\n+   library, but may only return CPP_EOF tokens thereon.  It is the\n+   caller's responsibility to check CPP_FATAL_ERRORS.  */\n+#define DL_FATAL\t\t0x04\n+/* An internal consistency check failed.  Prints \"internal error: \",\n+   otherwise the same as DL_FATAL.  */\n+#define DL_ICE\t\t\t0x05\n+/* Extracts a diagnostic level from an int.  */\n+#define DL_EXTRACT(l)\t\t(l & 0xf)\n+/* Non-zero if a diagnostic level is one of the warnings.  */\n+#define DL_WARNING_P(l)\t\t(DL_EXTRACT (l) >= DL_WARNING \\\n+\t\t\t\t && DL_EXTRACT (l) <= DL_PEDWARN)\n+\n /* N.B. The error-message-printer prototypes have not been nicely\n    formatted because exgettext needs to see 'msgid' on the same line\n    as the name of the function in order to work properly.  Only the\n    string argument gets a name in an effort to keep the lines from\n    getting ridiculously oversized.  */\n \n-extern void cpp_ice PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_fatal PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_error PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_warning PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_pedwarn PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_notice PARAMS ((cpp_reader *, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_2;\n-extern void cpp_error_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_4;\n-extern void cpp_warning_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_4;\n-extern void cpp_pedwarn_with_line PARAMS ((cpp_reader *, int, int, const char *msgid, ...))\n-  ATTRIBUTE_PRINTF_4;\n-extern void cpp_error_from_errno PARAMS ((cpp_reader *, const char *));\n-extern void cpp_notice_from_errno PARAMS ((cpp_reader *, const char *));\n+/* Output a diagnostic of some kind.  */\n+extern void cpp_error PARAMS ((cpp_reader *, int, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_3;\n+\n+/* Output a diagnostic of severity LEVEL, with \"MSG: \" preceding the\n+   error string of errno.  No location is printed.  */\n+extern void cpp_errno PARAMS ((cpp_reader *, int level, const char *msg));\n+\n+/* Same as cpp_error, except additionally specifies a position as a\n+   (translation unit) physical line and physical column.  If the line is\n+   zero, then no location is printed.  */\n+extern void cpp_error_with_line PARAMS ((cpp_reader *, int, unsigned, unsigned, const char *msgid, ...))\n+  ATTRIBUTE_PRINTF_5;\n \n /* In cpplex.c */\n extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,"}, {"sha": "207085175ea4fedbf030194622e322fceab9dd45", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -143,7 +143,8 @@ builtin_macro (pfile, node)\n   switch (node->value.builtin)\n     {\n     default:\n-      cpp_ice (pfile, \"invalid built-in macro \\\"%s\\\"\", NODE_NAME (node));\n+      cpp_error (pfile, DL_ICE, \"invalid built-in macro \\\"%s\\\"\",\n+\t\t NODE_NAME (node));\n       return 0;\n \n     case BT_FILE:\n@@ -344,7 +345,8 @@ stringify_arg (pfile, arg)\n   /* Ignore the final \\ of invalid string literals.  */\n   if (backslash_count & 1)\n     {\n-      cpp_warning (pfile, \"invalid string literal, ignoring final '\\\\'\");\n+      cpp_error (pfile, DL_WARNING,\n+\t\t \"invalid string literal, ignoring final '\\\\'\");\n       dest--;\n     }\n \n@@ -435,10 +437,10 @@ paste_all_tokens (pfile, lhs)\n \n \t  /* Mandatory warning for all apart from assembler.  */\n \t  if (CPP_OPTION (pfile, lang) != CLK_ASM)\n-\t    cpp_warning (pfile,\n+\t    cpp_error (pfile, DL_WARNING,\n \t \"pasting \\\"%s\\\" and \\\"%s\\\" does not give a valid preprocessing token\",\n-\t\t\t cpp_token_as_text (pfile, lhs),\n-\t\t\t cpp_token_as_text (pfile, rhs));\n+\t\t       cpp_token_as_text (pfile, lhs),\n+\t\t       cpp_token_as_text (pfile, rhs));\n \t  break;\n \t}\n     }\n@@ -555,7 +557,8 @@ collect_args (pfile, node)\n \t callers at the end of an -include-d file.  */\n       if (pfile->context->prev || pfile->state.in_directive)\n \t_cpp_backup_tokens (pfile, 1);\n-      cpp_error (pfile, \"unterminated argument list invoking macro \\\"%s\\\"\",\n+      cpp_error (pfile, DL_ERROR,\n+\t\t \"unterminated argument list invoking macro \\\"%s\\\"\",\n \t\t NODE_NAME (node));\n       error = true;\n     }\n@@ -572,11 +575,12 @@ collect_args (pfile, node)\n       if (argc + 1 == macro->paramc && macro->variadic)\n \t{\n \t  if (CPP_PEDANTIC (pfile) && ! macro->syshdr)\n-\t    cpp_pedwarn (pfile, \"ISO C99 requires rest arguments to be used\");\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"ISO C99 requires rest arguments to be used\");\n \t}\n       else\n \t{\n-\t  cpp_error (pfile,\n+\t  cpp_error (pfile, DL_ERROR,\n \t\t     \"macro \\\"%s\\\" requires %u arguments, but only %u given\",\n \t\t     NODE_NAME (node), macro->paramc, argc);\n \t  error = true;\n@@ -587,7 +591,7 @@ collect_args (pfile, node)\n       /* Empty argument to a macro taking no arguments is OK.  */\n       if (argc != 1 || arg->count)\n \t{\n-\t  cpp_error (pfile,\n+\t  cpp_error (pfile, DL_ERROR,\n \t\t     \"macro \\\"%s\\\" passed %u arguments, but takes just %u\",\n \t\t     NODE_NAME (node), argc, macro->paramc);\n \t  error = true;\n@@ -670,9 +674,9 @@ enter_macro_context (pfile, node)\n \t  if (buff == NULL)\n \t    {\n \t      if (CPP_WTRADITIONAL (pfile) && ! node->value.macro->syshdr)\n-\t\tcpp_warning (pfile,\n+\t\tcpp_error (pfile, DL_WARNING,\n  \"function-like macro \\\"%s\\\" must be used with arguments in traditional C\",\n-\t\t\t     NODE_NAME (node));\n+\t\t\t   NODE_NAME (node));\n \n \t      return 0;\n \t    }\n@@ -1169,7 +1173,8 @@ save_parameter (pfile, macro, node)\n   /* Constraint 6.10.3.6 - duplicate parameter names.  */\n   if (node->arg_index)\n     {\n-      cpp_error (pfile, \"duplicate macro parameter \\\"%s\\\"\", NODE_NAME (node));\n+      cpp_error (pfile, DL_ERROR, \"duplicate macro parameter \\\"%s\\\"\",\n+\t\t NODE_NAME (node));\n       return 1;\n     }\n \n@@ -1203,14 +1208,16 @@ parse_params (pfile, macro)\n \t      && ! CPP_OPTION (pfile, discard_comments_in_macro_exp))\n \t    continue;\n \n-\t  cpp_error (pfile, \"\\\"%s\\\" may not appear in macro parameter list\",\n+\t  cpp_error (pfile, DL_ERROR,\n+\t\t     \"\\\"%s\\\" may not appear in macro parameter list\",\n \t\t     cpp_token_as_text (pfile, token));\n \t  return 0;\n \n \tcase CPP_NAME:\n \t  if (prev_ident)\n \t    {\n-\t      cpp_error (pfile, \"macro parameters must be comma-separated\");\n+\t      cpp_error (pfile, DL_ERROR,\n+\t\t\t \"macro parameters must be comma-separated\");\n \t      return 0;\n \t    }\n \t  prev_ident = 1;\n@@ -1227,7 +1234,7 @@ parse_params (pfile, macro)\n \tcase CPP_COMMA:\n \t  if (!prev_ident)\n \t    {\n-\t      cpp_error (pfile, \"parameter name missing\");\n+\t      cpp_error (pfile, DL_ERROR, \"parameter name missing\");\n \t      return 0;\n \t    }\n \t  prev_ident = 0;\n@@ -1240,11 +1247,12 @@ parse_params (pfile, macro)\n \t      save_parameter (pfile, macro, pfile->spec_nodes.n__VA_ARGS__);\n \t      pfile->state.va_args_ok = 1;\n \t      if (! CPP_OPTION (pfile, c99) && CPP_OPTION (pfile, pedantic))\n-\t\tcpp_pedwarn (pfile,\n-\t\t     \"anonymous variadic macros were introduced in C99\");\n+\t\tcpp_error (pfile, DL_PEDWARN,\n+\t\t\t   \"anonymous variadic macros were introduced in C99\");\n \t    }\n \t  else if (CPP_OPTION (pfile, pedantic))\n-\t    cpp_pedwarn (pfile, \"ISO C does not permit named variadic macros\");\n+\t    cpp_error (pfile, DL_PEDWARN,\n+\t\t       \"ISO C does not permit named variadic macros\");\n \n \t  /* We're at the end, and just expect a closing parenthesis.  */\n \t  token = _cpp_lex_token (pfile);\n@@ -1253,7 +1261,7 @@ parse_params (pfile, macro)\n \t  /* Fall through.  */\n \n \tcase CPP_EOF:\n-\t  cpp_error (pfile, \"missing ')' in macro parameter list\");\n+\t  cpp_error (pfile, DL_ERROR, \"missing ')' in macro parameter list\");\n \t  return 0;\n \t}\n     }\n@@ -1331,7 +1339,8 @@ _cpp_create_definition (pfile, node)\n       macro->fun_like = 1;\n     }\n   else if (ctoken->type != CPP_EOF && !(ctoken->flags & PREV_WHITE))\n-    cpp_pedwarn (pfile, \"ISO C requires whitespace after the macro name\");\n+    cpp_error (pfile, DL_PEDWARN,\n+\t       \"ISO C requires whitespace after the macro name\");\n \n   saved_cur_token = pfile->cur_token;\n \n@@ -1361,7 +1370,8 @@ _cpp_create_definition (pfile, node)\n \t  else if (CPP_OPTION (pfile, lang) != CLK_ASM)\n \t    {\n \t      ok = 0;\n-\t      cpp_error (pfile, \"'#' is not followed by a macro parameter\");\n+\t      cpp_error (pfile, DL_ERROR,\n+\t\t\t \"'#' is not followed by a macro parameter\");\n \t      goto cleanup1;\n \t    }\n \t}\n@@ -1380,7 +1390,7 @@ _cpp_create_definition (pfile, node)\n \t  if (macro->count == 0 || token->type == CPP_EOF)\n \t    {\n \t      ok = 0;\n-\t      cpp_error (pfile,\n+\t      cpp_error (pfile, DL_ERROR,\n \t\t\t \"'##' cannot appear at either end of a macro expansion\");\n \t      goto cleanup1;\n \t    }\n@@ -1416,11 +1426,11 @@ _cpp_create_definition (pfile, node)\n     {\n       if (warn_of_redefinition (node, macro))\n \t{\n-\t  cpp_pedwarn_with_line (pfile, pfile->directive_line, 0,\n-\t\t\t\t \"\\\"%s\\\" redefined\", NODE_NAME (node));\n+\t  cpp_error_with_line (pfile, DL_PEDWARN, pfile->directive_line, 0,\n+\t\t\t       \"\\\"%s\\\" redefined\", NODE_NAME (node));\n \n \t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n-\t    cpp_pedwarn_with_line (pfile, node->value.macro->line, 0,\n+\t    cpp_error_with_line (pfile, DL_PEDWARN, node->value.macro->line, 0,\n \t\t\t    \"this is the location of the previous definition\");\n \t}\n       _cpp_free_definition (node);\n@@ -1484,9 +1494,9 @@ check_trad_stringification (pfile, macro, string)\n \t  if (NODE_LEN (node) == len\n \t      && !memcmp (p, NODE_NAME (node), len))\n \t    {\n-\t      cpp_warning (pfile,\n+\t      cpp_error (pfile, DL_WARNING,\n \t   \"macro argument \\\"%s\\\" would be stringified in traditional C\",\n-\t\t\t   NODE_NAME (node));\n+\t\t\t NODE_NAME (node));\n \t      break;\n \t    }\n \t}\n@@ -1509,7 +1519,8 @@ cpp_macro_definition (pfile, node)\n \n   if (node->type != NT_MACRO || (node->flags & NODE_BUILTIN))\n     {\n-      cpp_ice (pfile, \"invalid hash type %d in cpp_macro_definition\", node->type);\n+      cpp_error (pfile, DL_ICE,\n+\t\t \"invalid hash type %d in cpp_macro_definition\", node->type);\n       return 0;\n     }\n "}, {"sha": "bab1ff6cd76d6a73760a2ee2919517323ca84a6e", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -89,7 +89,7 @@ cpp_preprocess_file (pfile)\n       print.outf = fopen (options->out_fname, \"w\");\n       if (print.outf == NULL)\n \t{\n-\t  cpp_notice_from_errno (pfile, options->out_fname);\n+\t  cpp_errno (pfile, DL_ERROR, options->out_fname);\n \t  return;\n \t}\n     }\n@@ -120,7 +120,7 @@ cpp_preprocess_file (pfile)\n   if (print.outf != stdout)\n     {\n       if (ferror (print.outf) || fclose (print.outf))\n-\tcpp_notice_from_errno (pfile, options->out_fname);\n+\tcpp_errno (pfile, DL_ERROR, options->out_fname);\n     }\n }\n "}, {"sha": "6d054b5c1076f64f80d7bd06b00bf827d761631d", "filename": "gcc/fix-header.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Ffix-header.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c/gcc%2Ffix-header.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffix-header.c?ref=ebef4e8ca795b46b1f51a82d4b93c35f1eacd54c", "patch": "@@ -633,7 +633,7 @@ read_scan_file (in_fname, argc, argv)\n \n   i = cpp_handle_options (scan_in, argc, argv);\n   if (i < argc && ! CPP_FATAL_ERRORS (scan_in))\n-    cpp_fatal (scan_in, \"Invalid option `%s'\", argv[i]);\n+    cpp_error (scan_in, DL_FATAL, \"invalid option `%s'\", argv[i]);\n   cpp_post_options (scan_in);\n   if (CPP_FATAL_ERRORS (scan_in))\n     exit (FATAL_EXIT_CODE);"}]}