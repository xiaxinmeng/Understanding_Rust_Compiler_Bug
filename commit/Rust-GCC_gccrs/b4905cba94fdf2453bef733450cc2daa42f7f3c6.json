{"sha": "b4905cba94fdf2453bef733450cc2daa42f7f3c6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ5MDVjYmE5NGZkZjI0NTNiZWY3MzM0NTBjYzJkYWE0MmY3ZjNjNg==", "commit": {"author": {"name": "Roman Lechtchinsky", "email": "rl@cs.tu-berlin.de", "date": "2001-09-07T22:19:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-09-07T22:19:05Z"}, "message": "reload.c (push_reload): Check for subreg_lowpart_p instead of SUBREG_BYTE being 0 when...\n\n        * reload.c (push_reload): Check for subreg_lowpart_p instead of\n        SUBREG_BYTE being 0 when determining if the inner part of a subreg\n        can be reloaded.\n\nFrom-SVN: r45480", "tree": {"sha": "3c0d11e97a3715d261f4563df14c5535a43ad08a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c0d11e97a3715d261f4563df14c5535a43ad08a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4905cba94fdf2453bef733450cc2daa42f7f3c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4905cba94fdf2453bef733450cc2daa42f7f3c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4905cba94fdf2453bef733450cc2daa42f7f3c6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4905cba94fdf2453bef733450cc2daa42f7f3c6/comments", "author": null, "committer": null, "parents": [{"sha": "4a063bec6e3b164cf467ee99e423f9271177be86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a063bec6e3b164cf467ee99e423f9271177be86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a063bec6e3b164cf467ee99e423f9271177be86"}], "stats": {"total": 14, "additions": 10, "deletions": 4}, "files": [{"sha": "23382d9443e7512d3592063c03cc66bc9a678b15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4905cba94fdf2453bef733450cc2daa42f7f3c6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4905cba94fdf2453bef733450cc2daa42f7f3c6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4905cba94fdf2453bef733450cc2daa42f7f3c6", "patch": "@@ -1,3 +1,9 @@\n+2001-09-07  Roman Lechtchinsky <rl@cs.tu-berlin.de>\n+\n+\t* reload.c (push_reload): Check for subreg_lowpart_p instead of\n+\tSUBREG_BYTE being 0 when determining if the inner part of a subreg\n+\tcan be reloaded.\n+\n 2001-09-07  Roman Lechtchinsky  <rl@cs.tu-berlin.de>\n \n \t* c-common.c (signed_or_unsigned_type): Handle machine mode types"}, {"sha": "ad4b4e858f673e90ff741370751ec41e40ebd174", "filename": "gcc/reload.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4905cba94fdf2453bef733450cc2daa42f7f3c6/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4905cba94fdf2453bef733450cc2daa42f7f3c6/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=b4905cba94fdf2453bef733450cc2daa42f7f3c6", "patch": "@@ -937,13 +937,13 @@ push_reload (in, out, inloc, outloc, class,\n \n      Finally, reload the inner expression if it is a register that is in\n      the class whose registers cannot be referenced in a different size\n-     and M1 is not the same size as M2.  If SUBREG_BYTE is nonzero, we\n+     and M1 is not the same size as M2.  If subreg_lowpart_p is false, we\n      cannot reload just the inside since we might end up with the wrong\n      register class.  But if it is inside a STRICT_LOW_PART, we have\n      no choice, so we hope we do get the right register class there.  */\n \n   if (in != 0 && GET_CODE (in) == SUBREG\n-      && (SUBREG_BYTE (in) == 0 || strict_low)\n+      && (subreg_lowpart_p (in) || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n       && (class != CLASS_CANNOT_CHANGE_MODE\n \t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (in)), inmode))\n@@ -977,7 +977,7 @@ push_reload (in, out, inloc, outloc, class,\n \t      && REGNO (SUBREG_REG (in)) < FIRST_PSEUDO_REGISTER\n \t      /* The case where out is nonzero\n \t\t is handled differently in the following statement.  */\n-\t      && (out == 0 || SUBREG_BYTE (in) == 0)\n+\t      && (out == 0 || subreg_lowpart_p (in))\n \t      && ((GET_MODE_SIZE (inmode) <= UNITS_PER_WORD\n \t\t   && (GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t       > UNITS_PER_WORD)\n@@ -1056,7 +1056,7 @@ push_reload (in, out, inloc, outloc, class,\n      (except in the case of STRICT_LOW_PART,\n      and in that case the constraint should label it input-output.)  */\n   if (out != 0 && GET_CODE (out) == SUBREG\n-      && (SUBREG_BYTE (out) == 0 || strict_low)\n+      && (subreg_lowpart_p (out) || strict_low)\n #ifdef CLASS_CANNOT_CHANGE_MODE\n       && (class != CLASS_CANNOT_CHANGE_MODE\n \t  || ! CLASS_CANNOT_CHANGE_MODE_P (GET_MODE (SUBREG_REG (out)),"}]}