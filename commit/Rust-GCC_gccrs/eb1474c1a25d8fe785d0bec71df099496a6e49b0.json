{"sha": "eb1474c1a25d8fe785d0bec71df099496a6e49b0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWIxNDc0YzFhMjVkOGZlNzg1ZDBiZWM3MWRmMDk5NDk2YTZlNDliMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-10-30T12:01:46Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-10-30T12:01:46Z"}, "message": "re PR rtl-optimization/10474 (shrink wrapping for functions)\n\n2013-10-30  Martin Jambor  <mjambor@suse.cz>\n\n\tPR rtl-optimization/10474\n\t* ira.c (find_moveable_pseudos): Do not calculate dominance info\n\tnor df analysis.\n\t(interesting_dest_for_shprep): New function.\n\t(split_live_ranges_for_shrink_wrap): Likewise.\n\t(ira): Calculate dominance info and df analysis. Call\n\tsplit_live_ranges_for_shrink_wrap.\n\ntestsuite/\n\t* gcc.dg/pr10474.c: New testcase.\n\t* gcc.dg/ira-shrinkwrap-prep-1.c: Likewise.\n\t* gcc.dg/ira-shrinkwrap-prep-2.c: Likewise.\n\nFrom-SVN: r204205", "tree": {"sha": "ba0ed341c5acf6d9800c3b276fccdedb22ee7e02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba0ed341c5acf6d9800c3b276fccdedb22ee7e02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb1474c1a25d8fe785d0bec71df099496a6e49b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1474c1a25d8fe785d0bec71df099496a6e49b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1474c1a25d8fe785d0bec71df099496a6e49b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1474c1a25d8fe785d0bec71df099496a6e49b0/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "55ebf587382e3e1a41b9c1705a74e4a1ed6acae5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55ebf587382e3e1a41b9c1705a74e4a1ed6acae5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55ebf587382e3e1a41b9c1705a74e4a1ed6acae5"}], "stats": {"total": 305, "additions": 300, "deletions": 5}, "files": [{"sha": "fff372650f140c2e3726514c6f453ddd3989a588", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -1,3 +1,13 @@\n+2013-10-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR rtl-optimization/10474\n+\t* ira.c (find_moveable_pseudos): Do not calculate dominance info\n+\tnor df analysis.\n+\t(interesting_dest_for_shprep): New function.\n+\t(split_live_ranges_for_shrink_wrap): Likewise.\n+\t(ira): Calculate dominance info and df analysis. Call\n+\tsplit_live_ranges_for_shrink_wrap.\n+\n 2013-10-30  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/58854"}, {"sha": "113413515f4012d22558e017c0d3d01c1a82923d", "filename": "gcc/ira.c", "status": "modified", "additions": 200, "deletions": 5, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -3993,9 +3993,6 @@ find_moveable_pseudos (void)\n   pseudo_replaced_reg.release ();\n   pseudo_replaced_reg.safe_grow_cleared (max_regs);\n \n-  df_analyze ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   i = 0;\n   bitmap_initialize (&live, 0);\n   bitmap_initialize (&used, 0);\n@@ -4315,7 +4312,196 @@ find_moveable_pseudos (void)\n   regstat_free_ri ();\n   regstat_init_n_sets_and_refs ();\n   regstat_compute_ri ();\n-  free_dominance_info (CDI_DOMINATORS);\n+}\n+\n+\n+/* If insn is interesting for parameter range-splitting shring-wrapping\n+   preparation, i.e. it is a single set from a hard register to a pseudo, which\n+   is live at CALL_DOM, return the destination.  Otherwise return NULL.  */\n+\n+static rtx\n+interesting_dest_for_shprep (rtx insn, basic_block call_dom)\n+{\n+  rtx set = single_set (insn);\n+  if (!set)\n+    return NULL;\n+  rtx src = SET_SRC (set);\n+  rtx dest = SET_DEST (set);\n+  if (!REG_P (src) || !HARD_REGISTER_P (src)\n+      || !REG_P (dest) || HARD_REGISTER_P (dest)\n+      || (call_dom && !bitmap_bit_p (df_get_live_in (call_dom), REGNO (dest))))\n+    return NULL;\n+  return dest;\n+}\n+\n+/* Split live ranges of pseudos that are loaded from hard registers in the\n+   first BB in a BB that dominates all non-sibling call if such a BB can be\n+   found and is not in a loop.  Return true if the function has made any\n+   changes.  */\n+\n+static bool\n+split_live_ranges_for_shrink_wrap (void)\n+{\n+  basic_block bb, call_dom = NULL;\n+  basic_block first = single_succ (ENTRY_BLOCK_PTR);\n+  rtx insn, last_interesting_insn = NULL;\n+  bitmap_head need_new, reachable;\n+  vec<basic_block> queue;\n+\n+  if (!flag_shrink_wrap)\n+    return false;\n+\n+  bitmap_initialize (&need_new, 0);\n+  bitmap_initialize (&reachable, 0);\n+  queue.create (n_basic_blocks);\n+\n+  FOR_EACH_BB (bb)\n+    FOR_BB_INSNS (bb, insn)\n+      if (CALL_P (insn) && !SIBLING_CALL_P (insn))\n+\t{\n+\t  if (bb == first)\n+\t    {\n+\t      bitmap_clear (&need_new);\n+\t      bitmap_clear (&reachable);\n+\t      queue.release ();\n+\t      return false;\n+\t    }\n+\n+\t  bitmap_set_bit (&need_new, bb->index);\n+\t  bitmap_set_bit (&reachable, bb->index);\n+\t  queue.quick_push (bb);\n+\t  break;\n+\t}\n+\n+  if (queue.is_empty ())\n+    {\n+      bitmap_clear (&need_new);\n+      bitmap_clear (&reachable);\n+      queue.release ();\n+      return false;\n+    }\n+\n+  while (!queue.is_empty ())\n+    {\n+      edge e;\n+      edge_iterator ei;\n+\n+      bb = queue.pop ();\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\tif (e->dest != EXIT_BLOCK_PTR\n+\t    && bitmap_set_bit (&reachable, e->dest->index))\n+\t  queue.quick_push (e->dest);\n+    }\n+  queue.release ();\n+\n+  FOR_BB_INSNS (first, insn)\n+    {\n+      rtx dest = interesting_dest_for_shprep (insn, NULL);\n+      if (!dest)\n+\tcontinue;\n+\n+      if (DF_REG_DEF_COUNT (REGNO (dest)) > 1)\n+\t{\n+\t  bitmap_clear (&need_new);\n+\t  bitmap_clear (&reachable);\n+\t  return false;\n+\t}\n+\n+      for (df_ref use = DF_REG_USE_CHAIN (REGNO(dest));\n+\t   use;\n+\t   use = DF_REF_NEXT_REG (use))\n+\t{\n+\t  if (NONDEBUG_INSN_P (DF_REF_INSN (use))\n+\t      && GET_CODE (DF_REF_REG (use)) == SUBREG)\n+\t    {\n+\t      /* This is necessary to avoid hitting an assert at\n+\t\t postreload.c:2294 in libstc++ testcases on x86_64-linux.  I'm\n+\t\t not really sure what the probblem actually is there.  */\n+\t      bitmap_clear (&need_new);\n+\t      bitmap_clear (&reachable);\n+\t      return false;\n+\t    }\n+\n+\t  int ubbi = DF_REF_BB (use)->index;\n+\t  if (bitmap_bit_p (&reachable, ubbi))\n+\t    bitmap_set_bit (&need_new, ubbi);\n+\t}\n+      last_interesting_insn = insn;\n+    }\n+\n+  bitmap_clear (&reachable);\n+  if (!last_interesting_insn)\n+    {\n+      bitmap_clear (&need_new);\n+      return false;\n+    }\n+\n+  call_dom = nearest_common_dominator_for_set (CDI_DOMINATORS, &need_new);\n+  bitmap_clear (&need_new);\n+  if (call_dom == first)\n+    return false;\n+\n+  loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n+  while (bb_loop_depth (call_dom) > 0)\n+    call_dom = get_immediate_dominator (CDI_DOMINATORS, call_dom);\n+  loop_optimizer_finalize ();\n+\n+  if (call_dom == first)\n+    return false;\n+\n+  calculate_dominance_info (CDI_POST_DOMINATORS);\n+  if (dominated_by_p (CDI_POST_DOMINATORS, first, call_dom))\n+    {\n+      free_dominance_info (CDI_POST_DOMINATORS);\n+      return false;\n+    }\n+  free_dominance_info (CDI_POST_DOMINATORS);\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Will split live ranges of parameters at BB %i\\n\",\n+\t     call_dom->index);\n+\n+  bool ret = false;\n+  FOR_BB_INSNS (first, insn)\n+    {\n+      rtx dest = interesting_dest_for_shprep (insn, call_dom);\n+      if (!dest)\n+\tcontinue;\n+\n+      rtx newreg = NULL_RTX;\n+      df_ref use, next;\n+      for (use = DF_REG_USE_CHAIN (REGNO(dest)); use; use = next)\n+\t{\n+\t  rtx uin = DF_REF_INSN (use);\n+\t  next = DF_REF_NEXT_REG (use);\n+\n+\t  basic_block ubb = BLOCK_FOR_INSN (uin);\n+\t  if (ubb == call_dom\n+\t      || dominated_by_p (CDI_DOMINATORS, ubb, call_dom))\n+\t    {\n+\t      if (!newreg)\n+\t\tnewreg = ira_create_new_reg (dest);\n+\t      validate_change (uin, DF_REF_LOC (use), newreg, true);\n+\t    }\n+\t}\n+\n+      if (newreg)\n+\t{\n+\t  rtx new_move = gen_move_insn (newreg, dest);\n+\t  emit_insn_after (new_move, bb_note (call_dom));\n+\t  if (dump_file)\n+\t    {\n+\t      fprintf (dump_file, \"Split live-range of register \");\n+\t      print_rtl_single (dump_file, dest);\n+\t    }\n+\t  ret = true;\n+\t}\n+\n+      if (insn == last_interesting_insn)\n+\tbreak;\n+    }\n+  apply_change_group ();\n+  return ret;\n }\n \n /* Perform the second half of the transformation started in\n@@ -4526,7 +4712,16 @@ ira (FILE *f)\n      allocation because of -O0 usage or because the function is too\n      big.  */\n   if (ira_conflicts_p)\n-    find_moveable_pseudos ();\n+    {\n+      df_analyze ();\n+      calculate_dominance_info (CDI_DOMINATORS);\n+\n+      find_moveable_pseudos ();\n+      if (split_live_ranges_for_shrink_wrap ())\n+\tdf_analyze ();\n+\n+      free_dominance_info (CDI_DOMINATORS);\n+    }\n \n   max_regno_before_ira = max_reg_num ();\n   ira_setup_eliminable_regset (true);"}, {"sha": "f938522ec46d5c0879a2de3eb2dee4151915d546", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -1,3 +1,10 @@\n+2013-10-30  Martin Jambor  <mjambor@suse.cz>\n+\n+\tPR rtl-optimization/10474\n+\t* gcc.dg/pr10474.c: New testcase.\n+\t* gcc.dg/ira-shrinkwrap-prep-1.c: Likewise.\n+\t* gcc.dg/ira-shrinkwrap-prep-2.c: Likewise.\n+\n 2013-10-29  Andrew Pinski <apinski@cavium.com>\n             Zhenqiang Chen  <zhenqiang.chen@linaro.org>\n "}, {"sha": "fe497c25922a81e601c795ece93114c7e7e99323", "filename": "gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-1.c?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-rtl-ira -fdump-rtl-pro_and_epilogue\"  } */\n+\n+int __attribute__((noinline, noclone))\n+foo (int a)\n+{\n+  return a + 5;\n+}\n+\n+static int g;\n+\n+int __attribute__((noinline, noclone))\n+bar (int a)\n+{\n+  int r;\n+\n+  if (a)\n+    {\n+      r = foo (a);\n+      g = r + a;\n+    }\n+  else\n+    r = a+1;\n+  return r;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Will split live ranges of parameters\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Split live-range of register\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"ira\" } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}, {"sha": "872a7573a98355bc38d884e94780c9443ba498a5", "filename": "gcc/testsuite/gcc.dg/ira-shrinkwrap-prep-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fira-shrinkwrap-prep-2.c?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-rtl-ira -fdump-rtl-pro_and_epilogue\"  } */\n+\n+int __attribute__((noinline, noclone))\n+foo (int a)\n+{\n+  return a + 5;\n+}\n+\n+static int g;\n+\n+int __attribute__((noinline, noclone))\n+bar (int a)\n+{\n+  int r;\n+\n+  if (a)\n+    {\n+      r = a;\n+      while (r < 500)\n+\tif (r % 2)\n+\t  r = foo (r);\n+\telse\n+\t  r = foo (r+1);\n+      g = r + a;\n+    }\n+  else\n+    r = g+1;\n+  return r;\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Will split live ranges of parameters\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Split live-range of register\" \"ira\"  } } */\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"ira\" } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}, {"sha": "ee085c3dbe84fbd9579edba4a0b4c31500f58f57", "filename": "gcc/testsuite/gcc.dg/pr10474.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb1474c1a25d8fe785d0bec71df099496a6e49b0/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr10474.c?ref=eb1474c1a25d8fe785d0bec71df099496a6e49b0", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-rtl-pro_and_epilogue\"  } */\n+\n+void f(int *i)\n+{\n+\tif (!i)\n+\t\treturn;\n+\telse\n+\t{\n+\t\t__builtin_printf(\"Hi\");\n+\t\t*i=0;\n+\t}\n+}\n+\n+/* { dg-final { scan-rtl-dump \"Performing shrink-wrapping\" \"pro_and_epilogue\"  } } */\n+/* { dg-final { cleanup-rtl-dump \"pro_and_epilogue\" } } */"}]}