{"sha": "3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U3YjA5MzhmMTNmOTM3ZGY5NzFhMWJjNDJmMWRkMzJjYThhODFiYg==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-05-05T23:54:16Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-05-05T23:54:16Z"}, "message": "compiler: Handle recursive pointer types for unary indirection.\n\n\t* go-gcc.cc (Gcc_backend::indirect_expression): Add btype\n\tparameter.\n\t(Gcc_backend::temporary_variable): Check for erroneous function.\n\nFrom-SVN: r210087", "tree": {"sha": "878897e3dcd2a16f934a8fc05a29418d9e14f066", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/878897e3dcd2a16f934a8fc05a29418d9e14f066"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/comments", "author": null, "committer": null, "parents": [{"sha": "e400f0815936f54b1993e6ea64316327baa75253", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e400f0815936f54b1993e6ea64316327baa75253", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e400f0815936f54b1993e6ea64316327baa75253"}], "stats": {"total": 90, "additions": 58, "deletions": 32}, "files": [{"sha": "4e4afdb64baf3aa7ab0736f8094df7786918aaab", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "patch": "@@ -1,3 +1,9 @@\n+2014-05-05  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::indirect_expression): Add btype\n+\tparameter.\n+\t(Gcc_backend::temporary_variable): Check for erroneous function.\n+\n 2014-04-30  Chris Manghane  <cmang@google.com>\n \n \t* go-backend.c: #include \"diagnostics.h\"."}, {"sha": "343661ec9d28874d304d7dd0abbd580e6df2357f", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "patch": "@@ -229,7 +229,7 @@ class Gcc_backend : public Backend\n   var_expression(Bvariable* var, Location);\n \n   Bexpression*\n-  indirect_expression(Bexpression* expr, bool known_valid, Location);\n+  indirect_expression(Btype*, Bexpression* expr, bool known_valid, Location);\n \n   Bexpression*\n   named_constant_expression(Btype* btype, const std::string& name,\n@@ -1147,14 +1147,26 @@ Gcc_backend::var_expression(Bvariable* var, Location)\n // An expression that indirectly references an expression.\n \n Bexpression*\n-Gcc_backend::indirect_expression(Bexpression* expr, bool known_valid,\n-                                 Location location)\n+Gcc_backend::indirect_expression(Btype* btype, Bexpression* expr,\n+\t\t\t\t bool known_valid, Location location)\n {\n+  tree expr_tree = expr->get_tree();\n+  tree type_tree = btype->get_tree();\n+  if (expr_tree == error_mark_node || type_tree == error_mark_node)\n+    return this->error_expression();\n+\n+  // If the type of EXPR is a recursive pointer type, then we\n+  // need to insert a cast before indirecting.\n+  tree target_type_tree = TREE_TYPE(TREE_TYPE(expr_tree));\n+  if (VOID_TYPE_P(target_type_tree))\n+    expr_tree = fold_convert_loc(location.gcc_location(),\n+\t\t\t\t build_pointer_type(type_tree), expr_tree);\n+\n   tree ret = build_fold_indirect_ref_loc(location.gcc_location(),\n-                                         expr->get_tree());\n+                                         expr_tree);\n   if (known_valid)\n     TREE_THIS_NOTRAP(ret) = 1;\n-  return tree_to_expr(ret);\n+  return this->make_expression(ret);\n }\n \n // Return an expression that declares a constant named NAME with the\n@@ -2406,17 +2418,18 @@ Gcc_backend::temporary_variable(Bfunction* function, Bblock* bblock,\n \t\t\t\tLocation location,\n \t\t\t\tBstatement** pstatement)\n {\n+  gcc_assert(function != NULL);\n+  tree decl = function->get_tree();\n   tree type_tree = btype->get_tree();\n   tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree();\n-  if (type_tree == error_mark_node || init_tree == error_mark_node)\n+  if (type_tree == error_mark_node\n+      || init_tree == error_mark_node\n+      || decl == error_mark_node)\n     {\n       *pstatement = this->error_statement();\n       return this->error_variable();\n     }\n \n-  gcc_assert(function != NULL);\n-  tree decl = function->get_tree();\n-\n   tree var;\n   // We can only use create_tmp_var if the type is not addressable.\n   if (!TREE_ADDRESSABLE(type_tree))"}, {"sha": "e49cedf54cc16b0bfbff1812ed777fcf5e7f5886", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "patch": "@@ -253,9 +253,11 @@ class Backend\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n-  // is known to point to a valid memory location.\n+  // is known to point to a valid memory location.  BTYPE is the expected type\n+  // of the indirected EXPR.\n   virtual Bexpression*\n-  indirect_expression(Bexpression* expr, bool known_valid, Location) = 0;\n+  indirect_expression(Btype* btype, Bexpression* expr, bool known_valid,\n+\t\t      Location) = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE."}, {"sha": "b1d9bcc9839c97a1647cda1fc3db9897eb335b15", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "patch": "@@ -760,16 +760,24 @@ Var_expression::do_get_tree(Translate_context* context)\n \t\t\t\t\t\t\t  context->function());\n   bool is_in_heap;\n   Location loc = this->location();\n+  Btype* btype;\n+  Gogo* gogo = context->gogo();\n   if (this->variable_->is_variable())\n-    is_in_heap = this->variable_->var_value()->is_in_heap();\n+    {\n+      is_in_heap = this->variable_->var_value()->is_in_heap();\n+      btype = this->variable_->var_value()->type()->get_backend(gogo);\n+    }\n   else if (this->variable_->is_result_variable())\n-    is_in_heap = this->variable_->result_var_value()->is_in_heap();\n+    {\n+      is_in_heap = this->variable_->result_var_value()->is_in_heap();\n+      btype = this->variable_->result_var_value()->type()->get_backend(gogo);\n+    }\n   else\n     go_unreachable();\n \n   Bexpression* ret = context->backend()->var_expression(bvar, loc);\n   if (is_in_heap)\n-    ret = context->backend()->indirect_expression(ret, true, loc);\n+    ret = context->backend()->indirect_expression(btype, ret, true, loc);\n   return expr_to_tree(ret);\n }\n \n@@ -4168,20 +4176,7 @@ Unary_expression::do_get_tree(Translate_context* context)\n \n \t      }\n \t  }\n-\n-\t// If the type of EXPR is a recursive pointer type, then we\n-\t// need to insert a cast before indirecting.\n-        tree expr = expr_to_tree(bexpr);\n-        tree target_type_tree = TREE_TYPE(TREE_TYPE(expr));\n-        if (VOID_TYPE_P(target_type_tree))\n-          {\n-            tree ind = type_to_tree(pbtype);\n-            expr = fold_convert_loc(loc.gcc_location(),\n-                                    build_pointer_type(ind), expr);\n-            bexpr = tree_to_expr(expr);\n-          }\n-\n-        ret = gogo->backend()->indirect_expression(bexpr, false, loc);\n+        ret = gogo->backend()->indirect_expression(pbtype, bexpr, false, loc);\n       }\n       break;\n \n@@ -10329,7 +10324,10 @@ Array_index_expression::do_get_tree(Translate_context* context)\n               array_type->get_value_pointer(gogo, this->array_);\n \t  Bexpression* ptr = tree_to_expr(valptr->get_tree(context));\n           ptr = gogo->backend()->pointer_offset_expression(ptr, start, loc);\n-\t  ret = gogo->backend()->indirect_expression(ptr, true, loc);\n+\n+\t  Type* ele_type = this->array_->type()->array_type()->element_type();\n+\t  Btype* ele_btype = ele_type->get_backend(gogo);\n+\t  ret = gogo->backend()->indirect_expression(ele_btype, ptr, true, loc);\n \t}\n       return expr_to_tree(ret);\n     }\n@@ -10667,7 +10665,9 @@ String_index_expression::do_get_tree(Translate_context* context)\n       Bexpression* bstart = tree_to_expr(start->get_tree(context));\n       Bexpression* ptr = tree_to_expr(bytes->get_tree(context));\n       ptr = gogo->backend()->pointer_offset_expression(ptr, bstart, loc);\n-      Bexpression* index = gogo->backend()->indirect_expression(ptr, true, loc);\n+      Btype* ubtype = Type::lookup_integer_type(\"uint8\")->get_backend(gogo);\n+      Bexpression* index = \n+\tgogo->backend()->indirect_expression(ubtype, ptr, true, loc);\n \n       Btype* byte_btype = bytes->type()->points_to()->get_backend(gogo);\n       Bexpression* index_error = tree_to_expr(bad_index->get_tree(context));\n@@ -13816,7 +13816,9 @@ Heap_expression::do_get_tree(Translate_context* context)\n     gogo->backend()->temporary_variable(fndecl, context->bblock(), btype,\n \t\t\t\t\tspace, true, loc, &decl);\n   space = gogo->backend()->var_expression(space_temp, loc);\n-  Bexpression* ref = gogo->backend()->indirect_expression(space, true, loc);\n+  Btype* expr_btype = this->expr_->type()->get_backend(gogo);\n+  Bexpression* ref =\n+    gogo->backend()->indirect_expression(expr_btype, space, true, loc);\n \n   Bexpression* bexpr = tree_to_expr(this->expr_->get_tree(context));\n   Bstatement* assn = gogo->backend()->assignment_statement(ref, bexpr, loc);"}, {"sha": "e0ddc2f35ffabe30e5b08c778a5c02a4dcbd47e6", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e7b0938f13f937df971a1bc42f1dd32ca8a81bb/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=3e7b0938f13f937df971a1bc42f1dd32ca8a81bb", "patch": "@@ -5210,7 +5210,10 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n       Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n       Bexpression* val = gogo->backend()->var_expression(bvar, location);\n       if (no->result_var_value()->is_in_heap())\n-        val = gogo->backend()->indirect_expression(val, true, location);\n+\t{\n+\t  Btype* bt = no->result_var_value()->type()->get_backend(gogo);\n+\t  val = gogo->backend()->indirect_expression(bt, val, true, location);\n+\t}\n       vals[i] = val;\n     }\n   return gogo->backend()->return_statement(this->fndecl_, vals, location);"}]}