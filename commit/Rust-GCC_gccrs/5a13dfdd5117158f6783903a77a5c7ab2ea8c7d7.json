{"sha": "5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWExM2RmZGQ1MTE3MTU4ZjY3ODM5MDNhNzdhNWM3YWIyZWE4YzdkNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-23T20:11:13Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-07-23T20:11:13Z"}, "message": "entered into RCS\n\nFrom-SVN: r1676", "tree": {"sha": "4e0f95bac4a006d98c79d789f2576cb6c0af3e9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e0f95bac4a006d98c79d789f2576cb6c0af3e9a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7/comments", "author": null, "committer": null, "parents": [{"sha": "09927bb00b0bd8103615274d8c908495d4ff04c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09927bb00b0bd8103615274d8c908495d4ff04c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09927bb00b0bd8103615274d8c908495d4ff04c0"}], "stats": {"total": 8, "additions": 4, "deletions": 4}, "files": [{"sha": "90e763d59b0d78e429a03908a3e877b8cadfe0ab", "filename": "gcc/flow.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=5a13dfdd5117158f6783903a77a5c7ab2ea8c7d7", "patch": "@@ -1167,7 +1167,7 @@ propagate_block (old, first, last, final, significant, bnum)\n      In each element, OFFSET is the byte-number within a regset\n      for the register described by the element, and BIT is a mask\n      for that register's bit within the byte.  */\n-  register struct foo { short offset; short bit; } *regs_sometimes_live;\n+  register struct sometimes { short offset; short bit; } *regs_sometimes_live;\n   int sometimes_max = 0;\n   /* This regset has 1 for each reg that we have seen live so far.\n      It and REGS_SOMETIMES_LIVE are updated together.  */\n@@ -1206,7 +1206,7 @@ propagate_block (old, first, last, final, significant, bnum)\n       maxlive = (regset) alloca (regset_bytes);\n       bcopy (old, maxlive, regset_bytes);\n       regs_sometimes_live\n-\t= (struct foo *) alloca (max_regno * sizeof (struct foo));\n+\t= (struct sometimes *) alloca (max_regno * sizeof (struct sometimes));\n \n       /* Process the regs live at the end of the block.\n \t Enter them in MAXLIVE and REGS_SOMETIMES_LIVE.\n@@ -1427,7 +1427,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t     must not go in a register clobbered by calls.\n \t\t     Find all regs now live and record this for them.  */\n \n-\t\t  register struct foo *p = regs_sometimes_live;\n+\t\t  register struct sometimes *p = regs_sometimes_live;\n \n \t\t  for (i = 0; i < sometimes_max; i++, p++)\n \t\t    if (old[p->offset] & (1 << p->bit))\n@@ -1461,7 +1461,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t}\n \n \t      {\n-\t\tregister struct foo *p = regs_sometimes_live;\n+\t\tregister struct sometimes *p = regs_sometimes_live;\n \t\tfor (i = 0; i < sometimes_max; i++, p++)\n \t\t  {\n \t\t    if (old[p->offset] & ((REGSET_ELT_TYPE) 1 << p->bit))"}]}