{"sha": "a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "node_id": "C_kwDOANBUbNoAKGEyM2IzM2ExYmRlZmY3YmMyMjg5ZDllYmI3Y2I3YjdlYzBhNjA1ZjU", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-06T20:33:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2023-03-30T11:23:03Z"}, "message": "c++: lambda mangling alias issues [PR107897]\n\nIn 107897, by the time we are looking at the mangling clash, the\nalias has already been removed from the symbol table by analyze_functions,\nso we can't look at n->cpp_implicit_alias.  So just assume that it's an\nalias if it's internal.\n\nIn 108887 the problem is that removing the mangling alias from the symbol\ntable confuses analyze_functions, because it ended up as first_analyzed\nsomehow, so it becomes a dangling pointer.  So instead we call reset()\nto neutralize the alias.  To make this work for variables, I needed to move\nreset() from cgraph_node to symtab_node.\n\n\tPR c++/107897\n\tPR c++/108887\n\ngcc/ChangeLog:\n\n\t* cgraph.h: Move reset() from cgraph_node to symtab_node.\n\t* cgraphunit.cc (symtab_node::reset): Adjust.  Also call\n\tremove_from_same_comdat_group.\n\ngcc/cp/ChangeLog:\n\n\t* decl2.cc (record_mangling): Use symtab_node::reset.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp2a/concepts-lambda3.C: Use -flto if supported.\n\t* g++.dg/cpp0x/lambda/lambda-mangle7.C: New test.", "tree": {"sha": "4f51903b45adbda5e35a27168a8cb0216308953f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f51903b45adbda5e35a27168a8cb0216308953f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "04b0a7b1a6d9e0f3782888f1ebf187c26690038b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04b0a7b1a6d9e0f3782888f1ebf187c26690038b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04b0a7b1a6d9e0f3782888f1ebf187c26690038b"}], "stats": {"total": 133, "additions": 108, "deletions": 25}, "files": [{"sha": "bfea97104ef89b309dcfbcda3e1f33fb1523bb3a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "patch": "@@ -152,6 +152,9 @@ struct GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* Remove symbol from symbol table.  */\n   void remove (void);\n \n+  /* Undo any definition or use of the symbol.  */\n+  void reset (void);\n+\n   /* Dump symtab node to F.  */\n   void dump (FILE *f);\n \n@@ -1066,14 +1069,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Expand function specified by node.  */\n   void expand (void);\n \n-  /* As an GCC extension we allow redefinition of the function.  The\n-     semantics when both copies of bodies differ is not well defined.\n-     We replace the old body with new body so in unit at a time mode\n-     we always use new body, while in normal mode we may end up with\n-     old body inlined into some functions and new body expanded and\n-     inlined in others.  */\n-  void reset (void);\n-\n   /* Creates a wrapper from cgraph_node to TARGET node. Thunk is used for this\n      kind of wrapper method.  */\n   void create_wrapper (cgraph_node *target);"}, {"sha": "bccd2f2abb5a3faf757c27a2064a3facd79b8cdb", "filename": "gcc/cgraphunit.cc", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcgraphunit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcgraphunit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.cc?ref=a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "patch": "@@ -378,30 +378,38 @@ symbol_table::process_new_functions (void)\n    inlined in others.\n \n    ??? It may make more sense to use one body for inlining and other\n-   body for expanding the function but this is difficult to do.  */\n+   body for expanding the function but this is difficult to do.\n+\n+   This is also used to cancel C++ mangling aliases, which can be for\n+   functions or variables.  */\n \n void\n-cgraph_node::reset (void)\n+symtab_node::reset (void)\n {\n-  /* If process is set, then we have already begun whole-unit analysis.\n-     This is *not* testing for whether we've already emitted the function.\n-     That case can be sort-of legitimately seen with real function redefinition\n-     errors.  I would argue that the front end should never present us with\n-     such a case, but don't enforce that for now.  */\n-  gcc_assert (!process);\n-\n   /* Reset our data structures so we can analyze the function again.  */\n-  inlined_to = NULL;\n-  memset (&rtl, 0, sizeof (rtl));\n   analyzed = false;\n   definition = false;\n   alias = false;\n   transparent_alias = false;\n   weakref = false;\n   cpp_implicit_alias = false;\n \n-  remove_callees ();\n   remove_all_references ();\n+  remove_from_same_comdat_group ();\n+\n+  if (cgraph_node *cn = dyn_cast <cgraph_node *> (this))\n+    {\n+      /* If process is set, then we have already begun whole-unit analysis.\n+\t This is *not* testing for whether we've already emitted the function.\n+\t That case can be sort-of legitimately seen with real function\n+\t redefinition errors.  I would argue that the front end should never\n+\t present us with such a case, but don't enforce that for now.  */\n+      gcc_assert (!cn->process);\n+\n+      memset (&cn->rtl, 0, sizeof (cn->rtl));\n+      cn->inlined_to = NULL;\n+      cn->remove_callees ();\n+    }\n }\n \n /* Return true when there are references to the node.  INCLUDE_SELF is"}, {"sha": "201f1e6b6b96861dccb3b193c98f7d5f8191154d", "filename": "gcc/cp/decl2.cc", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcp%2Fdecl2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Fcp%2Fdecl2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.cc?ref=a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "patch": "@@ -4742,15 +4742,24 @@ record_mangling (tree decl, bool need_warning)\n     = mangled_decls->find_slot_with_hash (id, IDENTIFIER_HASH_VALUE (id),\n \t\t\t\t\t  INSERT);\n \n-  /* If this is already an alias, remove the alias, because the real\n+  /* If this is already an alias, cancel the alias, because the real\n      decl takes precedence.  */\n   if (*slot && DECL_ARTIFICIAL (*slot) && DECL_IGNORED_P (*slot))\n-    if (symtab_node *n = symtab_node::get (*slot))\n-      if (n->cpp_implicit_alias)\n+    {\n+      if (symtab_node *n = symtab_node::get (*slot))\n \t{\n-\t  n->remove ();\n-\t  *slot = NULL_TREE;\n+\t  if (n->cpp_implicit_alias)\n+\t    /* Actually removing the node isn't safe if other code is already\n+\t       holding a pointer to it, so just neutralize it.  */\n+\t    n->reset ();\n \t}\n+      else\n+\t/* analyze_functions might have already removed the alias from the\n+\t   symbol table if it's internal.  */\n+\tgcc_checking_assert (!TREE_PUBLIC (*slot));\n+\n+      *slot = NULL_TREE;\n+    }\n \n   if (!*slot)\n     *slot = decl;"}, {"sha": "c7946a2be0848ae4a7d7116d907807f279e84515", "filename": "gcc/testsuite/g++.dg/cpp0x/lambda/lambda-mangle7.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Flambda%2Flambda-mangle7.C?ref=a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "patch": "@@ -0,0 +1,70 @@\n+// PR c++/108887\n+// { dg-do compile { target c++11 } }\n+\n+template <int __v> struct integral_constant {\n+  static constexpr int value = __v;\n+};\n+using false_type = integral_constant<false>;\n+template <bool, bool, typename...> struct __result_of_impl;\n+template <typename _Functor, typename... _ArgTypes>\n+struct __result_of_impl<false, false, _Functor, _ArgTypes...> {\n+  typedef decltype(0) type;\n+};\n+template <typename... _ArgTypes>\n+struct __invoke_result\n+    : __result_of_impl<false_type::value, false_type::value, _ArgTypes...> {};\n+template <typename, typename _Fn, typename... _Args>\n+void __invoke_impl(_Fn __f, _Args... __args) {\n+  __f(__args...);\n+}\n+template <typename, typename _Callable, typename... _Args>\n+void __invoke_r(_Callable __fn, _Args... __args) {\n+  using __result = __invoke_result<_Args...>;\n+  using __type = typename __result::type;\n+  __invoke_impl<__type>(__fn, __args...);\n+}\n+struct QString {\n+  QString(const char *);\n+};\n+template <typename> class function;\n+template <typename _Functor> struct _Base_manager {\n+  static _Functor _M_get_pointer(int) { __builtin_abort (); }\n+};\n+template <typename, typename> class _Function_handler;\n+template <typename _Res, typename _Functor, typename... _ArgTypes>\n+struct _Function_handler<_Res(_ArgTypes...), _Functor> {\n+  using _Base = _Base_manager<_Functor>;\n+  static _Res _M_invoke(const int &__functor, _ArgTypes &&...__args) {\n+    auto __trans_tmp_1 = _Base::_M_get_pointer(__functor);\n+    __invoke_r<_Res>(__trans_tmp_1, __args...);\n+  }\n+};\n+template <typename _Res, typename... _ArgTypes>\n+struct function<_Res(_ArgTypes...)> {\n+  template <typename _Functor>\n+  using _Handler = _Function_handler<_Res(_ArgTypes...), _Functor>;\n+  template <typename _Functor> function(_Functor) {\n+    using _My_handler = _Handler<_Functor>;\n+    _M_invoker = _My_handler::_M_invoke;\n+  }\n+  using _Invoker_type = _Res (*)(const int &, _ArgTypes &&...);\n+  _Invoker_type _M_invoker;\n+};\n+struct QRegularExpression {\n+  QRegularExpression(QString);\n+};\n+struct AbstractAccount {\n+  void get(function<void(AbstractAccount *)>,\n+           function<void(AbstractAccount *)>);\n+};\n+struct AbstractTimelineModel {\n+  AbstractAccount m_account;\n+};\n+struct LinkPaginationTimelineModel : AbstractTimelineModel {\n+  void fillTimeline();\n+};\n+void LinkPaginationTimelineModel::fillTimeline() {\n+  [] {};\n+  m_account.get([](AbstractAccount *) { static QRegularExpression re(\"\"); },\n+                [](AbstractAccount *) {});\n+}"}, {"sha": "987984be5fd04799011584311ed8968488e02f44", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda3.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda3.C?ref=a23b33a1bdeff7bc2289d9ebb7cb7b7ec0a605f5", "patch": "@@ -1,6 +1,7 @@\n // { dg-do run { target c++20 } }\n // { dg-do compile { target c++17_down } }\n // { dg-excess-errors \"\" { target { c++17_down } } } (PR108972)\n+// { dg-additional-options \"-flto\" { target lto } } (PR107897)\n \n template<typename T>\n concept C1 = __is_same_as(T, int)"}]}