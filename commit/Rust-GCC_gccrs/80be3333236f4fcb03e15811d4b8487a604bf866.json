{"sha": "80be3333236f4fcb03e15811d4b8487a604bf866", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBiZTMzMzMyMzZmNGZjYjAzZTE1ODExZDRiODQ4N2E2MDRiZjg2Ng==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-07-03T16:30:43Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-07-03T16:30:43Z"}, "message": "Avoid minimum - 1 confusion in vectoriser\n\nThe variables that claimed to be the \"minimum number of iterations\" for\nwhich vectorisation was profitable were actually the maximum number of\niterations for which vectorisation wasn't profitable.  The loop threshold\nwas too.\n\nThis patch makes the values be what the variable names suggest.\n\n2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-loop.c (vect_analyze_loop_2): Treat min_scalar_loop_bound,\n\tmin_profitable_iters, and th as inclusive lower bounds.\n\tFix LOOP_VINFO_PEELING_FOR_GAPS condition.\n\t(vect_estimate_min_profitable_iters): Return inclusive lower bounds\n\tfor min_profitable_iters and min_profitable_estimate.\n\t(vect_transform_loop): Treat th as an inclusive lower bound.\n\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n\nFrom-SVN: r249927", "tree": {"sha": "7006103ac2e8bee34e40994c44f7f22d07c0ec3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7006103ac2e8bee34e40994c44f7f22d07c0ec3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80be3333236f4fcb03e15811d4b8487a604bf866", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80be3333236f4fcb03e15811d4b8487a604bf866", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80be3333236f4fcb03e15811d4b8487a604bf866", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80be3333236f4fcb03e15811d4b8487a604bf866/comments", "author": null, "committer": null, "parents": [{"sha": "be58770875623c5c92a4b6af7027c67568d4c061", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be58770875623c5c92a4b6af7027c67568d4c061", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be58770875623c5c92a4b6af7027c67568d4c061"}], "stats": {"total": 46, "additions": 23, "deletions": 23}, "files": [{"sha": "ae68b7c3ee8fee04f683ddb62b8812e1be82a5a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80be3333236f4fcb03e15811d4b8487a604bf866", "patch": "@@ -1,3 +1,13 @@\n+2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_2): Treat min_scalar_loop_bound,\n+\tmin_profitable_iters, and th as inclusive lower bounds.\n+\tFix LOOP_VINFO_PEELING_FOR_GAPS condition.\n+\t(vect_estimate_min_profitable_iters): Return inclusive lower bounds\n+\tfor min_profitable_iters and min_profitable_estimate.\n+\t(vect_transform_loop): Treat th as an inclusive lower bound.\n+\t* tree-vect-loop-manip.c (vect_loop_versioning): Likewise.\n+\n 2017-07-03  Dominique d'Humieres  <dominiq@lps.ens.fr>\n \n \tPR target/81033"}, {"sha": "34e4aa246fa10ee9dec1b987a4b9102b5f1dd8f2", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=80be3333236f4fcb03e15811d4b8487a604bf866", "patch": "@@ -2142,7 +2142,7 @@ vect_loop_versioning (loop_vec_info loop_vinfo,\n   bool version_niter = LOOP_REQUIRES_VERSIONING_FOR_NITERS (loop_vinfo);\n \n   if (check_profitability)\n-    cond_expr = fold_build2 (GT_EXPR, boolean_type_node, scalar_loop_iters,\n+    cond_expr = fold_build2 (GE_EXPR, boolean_type_node, scalar_loop_iters,\n \t\t\t     build_int_cst (TREE_TYPE (scalar_loop_iters),\n \t\t\t\t\t\t       th));\n "}, {"sha": "ae41ffaa335b36726af2946df22e5cd3e651429a", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80be3333236f4fcb03e15811d4b8487a604bf866/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=80be3333236f4fcb03e15811d4b8487a604bf866", "patch": "@@ -2135,21 +2135,17 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       goto again;\n     }\n \n-  min_scalar_loop_bound = ((PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n-\t\t\t    * vectorization_factor) - 1);\n+  min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+\t\t\t   * vectorization_factor);\n \n   /* Use the cost model only if it is more conservative than user specified\n      threshold.  */\n-  th = (unsigned) min_scalar_loop_bound;\n-  if (min_profitable_iters\n-      && (!min_scalar_loop_bound\n-          || min_profitable_iters > min_scalar_loop_bound))\n-    th = (unsigned) min_profitable_iters;\n+  th = (unsigned) MAX (min_scalar_loop_bound, min_profitable_iters);\n \n   LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = th;\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n-      && LOOP_VINFO_INT_NITERS (loop_vinfo) <= th)\n+      && LOOP_VINFO_INT_NITERS (loop_vinfo) < th)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2168,7 +2164,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n     estimated_niter = max_niter;\n   if (estimated_niter != -1\n       && ((unsigned HOST_WIDE_INT) estimated_niter\n-          <= MAX (th, (unsigned)min_profitable_estimate)))\n+          < MAX (th, (unsigned) min_profitable_estimate)))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -2185,9 +2181,9 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n \n   /* Decide whether we need to create an epilogue loop to handle\n      remaining scalar iterations.  */\n-  th = ((LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) + 1)\n-        / LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n-       * LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  th = ((LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo)\n+\t / LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n+\t* LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && LOOP_VINFO_PEELING_FOR_ALIGNMENT (loop_vinfo) > 0)\n@@ -2250,7 +2246,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal)\n       /* Niters for at least one iteration of vectorized loop.  */\n       niters_th += LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n       /* One additional iteration because of peeling for gap.  */\n-      if (!LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n+      if (LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo))\n \tniters_th++;\n       if (LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) < niters_th)\n \tLOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo) = niters_th;\n@@ -3550,7 +3546,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   if ((scalar_single_iter_cost * vf) > (int) vec_inside_cost)\n     {\n       if (vec_outside_cost <= 0)\n-        min_profitable_iters = 1;\n+        min_profitable_iters = 0;\n       else\n         {\n           min_profitable_iters = ((vec_outside_cost - scalar_outside_cost) * vf\n@@ -3591,11 +3587,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   min_profitable_iters =\n \tmin_profitable_iters < vf ? vf : min_profitable_iters;\n \n-  /* Because the condition we create is:\n-     if (niters <= min_profitable_iters)\n-       then skip the vectorized loop.  */\n-  min_profitable_iters--;\n-\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"  Runtime profitability threshold = %d\\n\",\n@@ -3611,7 +3602,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n      SIC * niters > VIC * ((niters-PL_ITERS-EP_ITERS)/VF) + VOC + SOC  */\n \n   if (vec_outside_cost <= 0)\n-    min_profitable_estimate = 1;\n+    min_profitable_estimate = 0;\n   else\n     {\n       min_profitable_estimate = ((vec_outside_cost + scalar_outside_cost) * vf\n@@ -3620,7 +3611,6 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t\t / ((scalar_single_iter_cost * vf)\n \t\t\t\t   - vec_inside_cost);\n     }\n-  min_profitable_estimate --;\n   min_profitable_estimate = MAX (min_profitable_estimate, min_profitable_iters);\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -7276,7 +7266,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n      run at least the vectorization factor number of times checking\n      is pointless, too.  */\n   th = LOOP_VINFO_COST_MODEL_THRESHOLD (loop_vinfo);\n-  if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo) - 1\n+  if (th >= LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n       && !LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n     {\n       if (dump_enabled_p ())"}]}