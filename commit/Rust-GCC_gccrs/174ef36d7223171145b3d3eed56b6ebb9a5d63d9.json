{"sha": "174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc0ZWYzNmQ3MjIzMTcxMTQ1YjNkM2VlZDU2YjZlYmI5YTVkNjNkOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2008-08-08T15:01:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-08-08T15:01:05Z"}, "message": "tree-ssa-ccp.c (likely_value): Calls are not all varying.\n\n2008-08-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree-ssa-ccp.c (likely_value): Calls are not all varying.\n\t(surely_varying_stmt_p): Calls are varying only if they are\n\tnon-builtin and not indirect or have no result.\n\t(ccp_fold): Re-instantiate code before the tuples merge.\n\n\t* gcc.dg/tree-ssa/ssa-ccp-20.c: New testcase.\n\nFrom-SVN: r138882", "tree": {"sha": "a4edba721d11775cb5881bd39e35b3624e96afb6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4edba721d11775cb5881bd39e35b3624e96afb6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70d904ca8edc145e16c7d5720059eb437e439ee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d904ca8edc145e16c7d5720059eb437e439ee2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d904ca8edc145e16c7d5720059eb437e439ee2"}], "stats": {"total": 92, "additions": 75, "deletions": 17}, "files": [{"sha": "5c6811c214654b76524886e7275eb376d840b261", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "patch": "@@ -1,3 +1,10 @@\n+2008-08-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree-ssa-ccp.c (likely_value): Calls are not all varying.\n+\t(surely_varying_stmt_p): Calls are varying only if they are\n+\tnon-builtin and not indirect or have no result.\n+\t(ccp_fold): Re-instantiate code before the tuples merge.\n+\n 2008-08-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37056"}, {"sha": "ba897b0311da65de465d8f4b7755616954f69db0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "patch": "@@ -1,3 +1,7 @@\n+2008-08-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* gcc.dg/tree-ssa/ssa-ccp-20.c: New testcase.\n+\n 2008-08-08  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/37056"}, {"sha": "63febd0e04fad4cf376abc1891bd4f6dead5286f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-20.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-20.c?ref=174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-ccp1\" } */\n+\n+/* Make sure CCP propagates through indirect calls.  */\n+\n+int foo (void)\n+{\n+  int i = -5;\n+  int (*fn)(int) = __builtin_abs;\n+  int j = fn(i);\n+  return j + 5;\n+}\n+\n+/* { dg-final { scan-tree-dump \"return 10;\" \"ccp1\" } } */\n+/* { dg-final { cleanup-tree-dump \"ccp1\" } } */"}, {"sha": "af102cd25e1338e83744b4e89b808bc361cac8e2", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 49, "deletions": 17, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/174ef36d7223171145b3d3eed56b6ebb9a5d63d9/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=174ef36d7223171145b3d3eed56b6ebb9a5d63d9", "patch": "@@ -528,17 +528,10 @@ likely_value (gimple stmt)\n       && !ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n     return VARYING;\n \n-  /* A GIMPLE_CALL is assumed to be varying.  NOTE: This may be overly\n-     conservative, in the presence of const and pure calls.  */\n-  if (code == GIMPLE_CALL)\n-    return VARYING;\n-\n   /* Note that only a GIMPLE_SINGLE_RHS assignment can satisfy\n      is_gimple_min_invariant, so we do not consider calls or\n      other forms of assignment.  */\n-  if (code == GIMPLE_ASSIGN\n-      && (get_gimple_rhs_class (gimple_assign_rhs_code (stmt))\n-          == GIMPLE_SINGLE_RHS)\n+  if (gimple_assign_single_p (stmt)\n       && is_gimple_min_invariant (gimple_assign_rhs1 (stmt)))\n     return CONSTANT;\n \n@@ -630,15 +623,23 @@ surely_varying_stmt_p (gimple stmt)\n \treturn true;\n     }\n \n-  /* If it contains a call, it is varying.  */\n+  /* If it is a call and does not return a value or is not a\n+     builtin and not an indirect call, it is varying.  */\n   if (is_gimple_call (stmt))\n-    return true;\n+    {\n+      tree fndecl;\n+      if (!gimple_call_lhs (stmt)\n+\t  || ((fndecl = gimple_call_fndecl (stmt)) != NULL_TREE\n+\t      && DECL_BUILT_IN (fndecl)))\n+\treturn true;\n+    }\n \n   /* Anything other than assignments and conditional jumps are not\n      interesting for CCP.  */\n   if (gimple_code (stmt) != GIMPLE_ASSIGN\n-      && (gimple_code (stmt) != GIMPLE_COND)\n-      && (gimple_code (stmt) != GIMPLE_SWITCH))\n+      && gimple_code (stmt) != GIMPLE_COND\n+      && gimple_code (stmt) != GIMPLE_SWITCH\n+      && gimple_code (stmt) != GIMPLE_CALL)\n     return true;\n \n   return false;\n@@ -1034,11 +1035,42 @@ ccp_fold (gimple stmt)\n       break;\n \n     case GIMPLE_CALL:\n-      /* It may be possible to fold away calls to builtin functions if\n-         their arguments are constants.  At present, such folding will not\n-         be attempted, as likely_value classifies all calls as VARYING.  */\n-      gcc_unreachable ();\n-      break;\n+      {\n+\ttree fn = gimple_call_fn (stmt);\n+\tprop_value_t *val;\n+\n+\tif (TREE_CODE (fn) == SSA_NAME)\n+\t  {\n+\t    val = get_value (fn);\n+\t    if (val->lattice_val == CONSTANT)\n+\t      fn = val->value;\n+\t  }\n+\tif (TREE_CODE (fn) == ADDR_EXPR\n+\t    && DECL_BUILT_IN (TREE_OPERAND (fn, 0)))\n+\t  {\n+\t    tree *args = XALLOCAVEC (tree, gimple_call_num_args (stmt));\n+\t    tree call, retval;\n+\t    unsigned i;\n+\t    for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t      {\n+\t\targs[i] = gimple_call_arg (stmt, i);\n+\t\tif (TREE_CODE (args[i]) == SSA_NAME)\n+\t\t  {\n+\t\t    val = get_value (args[i]);\n+\t\t    if (val->lattice_val == CONSTANT)\n+\t\t      args[i] = val->value;\n+\t\t  }\n+\t      }\n+\t    call = build_call_array (gimple_call_return_type (stmt),\n+\t\t\t\t     fn, gimple_call_num_args (stmt), args);\n+\t    retval = fold_call_expr (call, false);\n+\t    if (retval)\n+\t      /* fold_call_expr wraps the result inside a NOP_EXPR.  */\n+\t      STRIP_NOPS (retval);\n+\t    return retval;\n+\t  }\n+\treturn NULL_TREE;\n+      }\n \n     case GIMPLE_COND:\n       {"}]}