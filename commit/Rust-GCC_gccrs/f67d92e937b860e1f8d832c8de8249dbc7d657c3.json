{"sha": "f67d92e937b860e1f8d832c8de8249dbc7d657c3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY3ZDkyZTkzN2I4NjBlMWY4ZDgzMmM4ZGU4MjQ5ZGJjN2Q2NTdjMw==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-09-16T16:16:14Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-09-16T16:16:14Z"}, "message": "[multiple changes]\n\n2004-09-16  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* cfgloop.h (duplicate_loop):  Add prototype.\n\t* cfgloopmanip.c (duplicate_loop): Make non-static.\n\t* lambda-code.c (perfect_nestify): Factor out test whether\n\twe can handle this loop into separate function.\n\tCall it.\n\t(can_convert_to_perfect_nest): New function.\n\t(replace_uses_of_x_with_y): Add modify_stmt call.\n\t* tree-loop-linear.c (linear_transform_loops): Call\n\trewrite_into_loop_closed_ssa and free_df.\n\n2004-09-16  Daniel Berlin  <dberlin@dberlin.org>\n\n\t* lambda-code.c (invariant_in_loop): is_gimple_min_invariant is\n\tloop invariant as well.\n\t(perfect_nestify): new function.\n\t(gcc_loop_to_lambda_loop): New parameters to track lower bounds,\n\tupper bounds, and steps.\n\tSet outerinductionvar properly.\n\t(gcc_loopnest_to_lambda_loopnest): Add loops and need_perfect\n\tparameters.\n\tReturn NULL if we need a perfect loop and can't make one.\n\t(lambda_loopnest_to_gcc_loopnest): Correct algorithm.\n\t(not_interesting_stmt): New function.\n\t(phi_loop_edge_uses_def): Ditto.\n\t(stmt_uses_phi_result): Ditto.\n\t(stmt_is_bumper_for_loop): Ditto.\n\t(perfect_nest_p): Ditto.\n\t(nestify_update_pending_stmts): Ditto.\n\t(replace_uses_of_x_with_y): Ditto.\n\t(stmt_uses_op): Ditto.\n\t(perfect_nestify): Ditto.\n\t* lambda-mat.c (lambda_matrix_id_p): New function.\n\t* lambda-trans.c (lambda_trans_matrix_id_p): Ditto.\n\t* lambda.h: Update prototypes.\n\t* tree-loop-linear (linear_transform_loop): Use new\n\tperfect_nest_p. Detect and ignore identity transform.\n\t* tree-ssa-loop.c (pass_linear_transform): Use TODO_write_loop_closed.\n\n2004-09-16  Sebastian Pop  <pop@cri.ensmp.fr>\n\n\t* tree-loop-linear.c (gather_interchange_stats): Add more comments.\n\tGather also strides of accessed data.  Pass in the data references\n\tarray.\n\t(try_interchange_loops): Add a new heuristic for handling the temporal\n\tlocality.  Pass in the data references array.\n\t(linear_transform_loops): Pass the data references array to\n\ttry_interchange_loops.\n\nFrom-SVN: r87607", "tree": {"sha": "6b5fc0131113b7a19fd3ee91525ce7bcdff98ba3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5fc0131113b7a19fd3ee91525ce7bcdff98ba3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f67d92e937b860e1f8d832c8de8249dbc7d657c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67d92e937b860e1f8d832c8de8249dbc7d657c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f67d92e937b860e1f8d832c8de8249dbc7d657c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f67d92e937b860e1f8d832c8de8249dbc7d657c3/comments", "author": null, "committer": null, "parents": [{"sha": "83c9948608ee6c4baec7065a15be34bfc3ae8cd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83c9948608ee6c4baec7065a15be34bfc3ae8cd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83c9948608ee6c4baec7065a15be34bfc3ae8cd2"}], "stats": {"total": 930, "additions": 786, "deletions": 144}, "files": [{"sha": "265495f32c5c6c1579cc82c4f9a2d6866607c1c8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -1,3 +1,53 @@\n+2004-09-16  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* cfgloop.h (duplicate_loop):  Add prototype.\n+\t* cfgloopmanip.c (duplicate_loop): Make non-static.\n+\t* lambda-code.c (perfect_nestify): Factor out test whether\n+\twe can handle this loop into separate function.\n+\tCall it.\n+\t(can_convert_to_perfect_nest): New function.\n+\t(replace_uses_of_x_with_y): Add modify_stmt call.\n+\t* tree-loop-linear.c (linear_transform_loops): Call\n+\trewrite_into_loop_closed_ssa and free_df.\n+\n+2004-09-16  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* lambda-code.c (invariant_in_loop): is_gimple_min_invariant is\n+\tloop invariant as well.\n+\t(perfect_nestify): new function.\n+\t(gcc_loop_to_lambda_loop): New parameters to track lower bounds,\n+\tupper bounds, and steps. \n+\tSet outerinductionvar properly.\n+\t(gcc_loopnest_to_lambda_loopnest): Add loops and need_perfect\n+\tparameters.\n+\tReturn NULL if we need a perfect loop and can't make one.\n+\t(lambda_loopnest_to_gcc_loopnest): Correct algorithm.\n+\t(not_interesting_stmt): New function.\n+\t(phi_loop_edge_uses_def): Ditto.\n+\t(stmt_uses_phi_result): Ditto.\n+\t(stmt_is_bumper_for_loop): Ditto.\n+\t(perfect_nest_p): Ditto.\n+\t(nestify_update_pending_stmts): Ditto.\n+\t(replace_uses_of_x_with_y): Ditto.\n+\t(stmt_uses_op): Ditto.\n+\t(perfect_nestify): Ditto.\n+\t* lambda-mat.c (lambda_matrix_id_p): New function.\n+\t* lambda-trans.c (lambda_trans_matrix_id_p): Ditto.\n+\t* lambda.h: Update prototypes.\n+\t* tree-loop-linear (linear_transform_loop): Use new\n+\tperfect_nest_p. Detect and ignore identity transform.\n+\t* tree-ssa-loop.c (pass_linear_transform): Use TODO_write_loop_closed.\n+\n+2004-09-16  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* tree-loop-linear.c (gather_interchange_stats): Add more comments.\n+\tGather also strides of accessed data.  Pass in the data references \n+\tarray.\n+\t(try_interchange_loops): Add a new heuristic for handling the temporal \n+\tlocality.  Pass in the data references array.\n+\t(linear_transform_loops): Pass the data references array to\n+\ttry_interchange_loops.\n+\n 2004-09-16  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* doc/invoke.texi: Fix typos.  Follow spelling conventions."}, {"sha": "cfa8e10007813da4222d446c0e4f13910d17b1b4", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -308,6 +308,8 @@ extern bool can_duplicate_loop_p (struct loop *loop);\n #define DLTHE_FLAG_UPDATE_FREQ\t1\t/* Update frequencies in\n \t\t\t\t\t   duplicate_loop_to_header_edge.  */\n \n+extern struct loop * duplicate_loop (struct loops *, struct loop *,\n+\t\t\t\t     struct loop *);\n extern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n \t\t\t\t\t  unsigned, sbitmap, edge, edge *,\n \t\t\t\t\t  unsigned *, int);"}, {"sha": "616909700db12447301539d27253470b390964bb", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -29,8 +29,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"cfglayout.h\"\n #include \"output.h\"\n \n-static struct loop * duplicate_loop (struct loops *, struct loop *,\n-\t\t\t\t     struct loop *);\n static void duplicate_subloops (struct loops *, struct loop *, struct loop *);\n static void copy_loops_to (struct loops *, struct loop **, int,\n \t\t\t   struct loop *);\n@@ -701,7 +699,7 @@ place_new_loop (struct loops *loops, struct loop *loop)\n \n /* Copies copy of LOOP as subloop of TARGET loop, placing newly\n    created loop into LOOPS structure.  */\n-static struct loop *\n+struct loop *\n duplicate_loop (struct loops *loops, struct loop *loop, struct loop *target)\n {\n   struct loop *cloop;"}, {"sha": "f438fb6e27cf0e80563d3b822cf363e367185cf5", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 560, "deletions": 93, "changes": 653, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -115,6 +115,13 @@\n  Fourier-Motzkin elimination is used to compute the bounds of the base space\n  of the lattice.  */\n \n+\n+\n+DEF_VEC_GC_P(int);\n+\n+static bool perfect_nestify (struct loops *, \n+\t\t\t     struct loop *, VEC (tree) *, \n+\t\t\t     VEC (tree) *, VEC (int) *, VEC (tree) *);\n /* Lattice stuff that is internal to the code generation algorithm.  */\n \n typedef struct\n@@ -1160,20 +1167,23 @@ gcc_tree_to_linear_expression (int depth, tree expr,\n static bool\n invariant_in_loop (struct loop *loop, tree op)\n {\n+  if (is_gimple_min_invariant (op))\n+    return true;\n   if (loop->depth == 0)\n     return true;\n   if (TREE_CODE (op) == SSA_NAME)\n     {\n+      tree def;\n+      def = SSA_NAME_DEF_STMT (op);\n       if (TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL\n-\t  && IS_EMPTY_STMT (SSA_NAME_DEF_STMT (op)))\n+\t  && IS_EMPTY_STMT (def))\n \treturn true;\n-      if (IS_EMPTY_STMT (SSA_NAME_DEF_STMT (op)))\n+      if (IS_EMPTY_STMT (def))\n \treturn false;\n-      if (loop->outer)\n-\tif (!invariant_in_loop (loop->outer, op))\n+      if (loop->outer \n+\t  && !invariant_in_loop (loop->outer, op))\n \t  return false;\n-      return !flow_bb_inside_loop_p (loop,\n-\t\t\t\t     bb_for_stmt (SSA_NAME_DEF_STMT (op)));\n+      return !flow_bb_inside_loop_p (loop, bb_for_stmt (def));\n     }\n   return false;\n }\n@@ -1190,7 +1200,10 @@ static lambda_loop\n gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t VEC (tree) ** invariants,\n \t\t\t tree * ourinductionvar,\n-\t\t\t VEC (tree) * outerinductionvars)\n+\t\t\t VEC (tree) * outerinductionvars,\n+\t\t\t VEC (tree) ** lboundvars,\n+\t\t\t VEC (tree) ** uboundvars,\n+\t\t\t VEC (int) ** steps)\n {\n   tree phi;\n   tree exit_cond;\n@@ -1201,15 +1214,11 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n   tree test;\n   int stepint;\n   int extra = 0;\n-  tree uboundvar;\n+  tree lboundvar, uboundvar;\n   use_optype uses;\n \n-  /* Find out induction var and set the pointer so that the caller can\n-     append it to the outerinductionvars array later.  */\n-\n+  /* Find out induction var and exit condition.  */\n   inductionvar = find_induction_var_from_exit_cond (loop);\n-  *ourinductionvar = inductionvar;\n-\n   exit_cond = get_loop_exit_condition (loop);\n \n   if (inductionvar == NULL || exit_cond == NULL)\n@@ -1260,7 +1269,9 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t}\n \n     }\n-\n+  /* The induction variable name/version we want to put in the array is the\n+     result of the induction variable phi node.  */\n+  *ourinductionvar = PHI_RESULT (phi);\n   access_fn = instantiate_parameters\n     (loop, analyze_scalar_evolution (loop, PHI_RESULT (phi)));\n   if (!access_fn)\n@@ -1316,14 +1327,20 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n     }\n \n   if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, 0)->src))\n-\n-    lbound = gcc_tree_to_linear_expression (depth, PHI_ARG_DEF (phi, 1),\n-\t\t\t\t\t    outerinductionvars, *invariants,\n-\t\t\t\t\t    0);\n+    {\n+      lboundvar = PHI_ARG_DEF (phi, 1);\n+      lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n+\t\t\t\t\t      outerinductionvars, *invariants,\n+\t\t\t\t\t      0);\n+    }\n   else\n-    lbound = gcc_tree_to_linear_expression (depth, PHI_ARG_DEF (phi, 0),\n-\t\t\t\t\t    outerinductionvars, *invariants,\n-\t\t\t\t\t    0);\n+    {\n+      lboundvar = PHI_ARG_DEF (phi, 0);\n+      lbound = gcc_tree_to_linear_expression (depth, lboundvar,\n+\t\t\t\t\t      outerinductionvars, *invariants,\n+\t\t\t\t\t      0);\n+    }\n+  \n   if (!lbound)\n     {\n \n@@ -1368,6 +1385,11 @@ gcc_loop_to_lambda_loop (struct loop *loop, int depth,\n \t\t\t\t\t  uboundvar,\n \t\t\t\t\t  outerinductionvars,\n \t\t\t\t\t  *invariants, extra);\n+  VEC_safe_push (tree, *uboundvars, build (PLUS_EXPR, integer_type_node,\n+\t\t\t\t\tuboundvar,\n+\t\t\t\t\tbuild_int_cst (integer_type_node, extra)));\n+  VEC_safe_push (tree, *lboundvars, lboundvar);\n+  VEC_safe_push (int, *steps, stepint);\n   if (!ubound)\n     {\n \n@@ -1400,7 +1422,7 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   test = TREE_OPERAND (expr, 0);\n   if (TREE_CODE_CLASS (TREE_CODE (test)) != '<')\n     return NULL_TREE;\n- /* This is a guess.  We say that for a <,!=,<= b, a is the induction\n+  /* This is a guess.  We say that for a <,!=,<= b, a is the induction\n      variable.\n      For >, >=, we guess b is the induction variable.\n      If we are wrong, it'll fail the rest of the induction variable tests, and\n@@ -1433,15 +1455,20 @@ DEF_VEC_GC_P(lambda_loop);\n    during this process.  */\n \n lambda_loopnest\n-gcc_loopnest_to_lambda_loopnest (struct loop * loop_nest,\n+gcc_loopnest_to_lambda_loopnest (struct loops *currloops,\n+\t\t\t\t struct loop * loop_nest,\n \t\t\t\t VEC (tree) **inductionvars,\n-\t\t\t\t VEC (tree) **invariants)\n+\t\t\t\t VEC (tree) **invariants,\n+\t\t\t\t bool need_perfect_nest)\n {\n   lambda_loopnest ret;\n   struct loop *temp;\n   int depth = 0;\n   size_t i;\n   VEC (lambda_loop) *loops;\n+  VEC (tree) *uboundvars;\n+  VEC (tree) *lboundvars;\n+  VEC (int) *steps;\n   lambda_loop newloop;\n   tree inductionvar = NULL;\n \n@@ -1454,18 +1481,30 @@ gcc_loopnest_to_lambda_loopnest (struct loop * loop_nest,\n   loops = VEC_alloc (lambda_loop, 1);\n   *inductionvars = VEC_alloc (tree, 1);\n   *invariants = VEC_alloc (tree, 1);\n+  lboundvars = VEC_alloc (tree, 1);\n+  uboundvars = VEC_alloc (tree, 1);\n+  steps = VEC_alloc (int, 1);\n   temp = loop_nest;\n   while (temp)\n     {\n       newloop = gcc_loop_to_lambda_loop (temp, depth, invariants,\n-\t\t\t\t\t &inductionvar, *inductionvars);\n+\t\t\t\t\t &inductionvar, *inductionvars,\n+\t\t\t\t\t &lboundvars, &uboundvars,\n+\t\t\t\t\t &steps);\n       if (!newloop)\n \treturn NULL;\n       VEC_safe_push (tree, *inductionvars, inductionvar);\n       VEC_safe_push (lambda_loop, loops, newloop);\n       temp = temp->inner;\n     }\n-\n+  if (need_perfect_nest \n+      && !perfect_nestify (currloops, loop_nest, \n+\t\t\t   lboundvars, uboundvars, steps, *inductionvars))\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not a perfect nest and couldn't convert to one.\\n\");    \n+      return NULL;\n+    }\n   ret = lambda_loopnest_new (depth, 2 * depth);\n   for (i = 0; VEC_iterate (lambda_loop, loops, i, newloop); i++)\n     LN_LOOPS (ret)[i] = newloop;\n@@ -1489,7 +1528,7 @@ lbv_to_gcc_expression (lambda_body_vector lbv,\n \n   /* Create a statement list and a linear expression temporary.  */\n   stmts = alloc_stmt_list ();\n-  resvar = create_tmp_var (integer_type_node, \"lletmp\");\n+  resvar = create_tmp_var (integer_type_node, \"lbvtmp\");\n   add_referenced_tmp_var (resvar);\n \n   /* Start at 0.  */\n@@ -1767,7 +1806,6 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n   size_t depth = 0;\n   VEC(tree) *new_ivs;\n   block_stmt_iterator bsi;\n-  basic_block *bbs;\n \n   if (dump_file)\n     {\n@@ -1849,66 +1887,56 @@ lambda_loopnest_to_gcc_loopnest (struct loop *old_loopnest,\n       i++;\n       temp = temp->inner;\n     }\n-\n-  /* Go through the loop and make iv replacements.  */\n-  bbs = get_loop_body (old_loopnest);\n-  for (i = 0; i < old_loopnest->num_nodes; i++)\n-    for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n-      {\n-\ttree stmt = bsi_stmt (bsi);\n-\tuse_optype uses;\n-\tsize_t j;\n-\n-\tget_stmt_operands (stmt);\n-\tuses = STMT_USE_OPS (stmt);\n-\tfor (j = 0; j < NUM_USES (uses); j++)\n-\t  {\n-\t    size_t k;\n-\t    use_operand_p use = USE_OP_PTR (uses, j);\n-\t    for (k = 0; k <  VEC_length (tree, old_ivs); k++)\n-\t      {\n-\t\ttree oldiv = VEC_index (tree, old_ivs, k);\n-\t\tif (USE_FROM_PTR (use) == oldiv)\n-\t\t  {\n-\t\t    tree newiv, stmts;\n-\t\t    lambda_body_vector lbv;\n-\n-\t\t    /* Compute the new expression for the induction\n-\t\t       variable.  */\n-\t\t    depth = VEC_length (tree, new_ivs);\n-\t\t    lbv = lambda_body_vector_new (depth);\n-\t\t    LBV_COEFFICIENTS (lbv)[k] = 1;\n-\t\t    lbv = lambda_body_vector_compute_new (transform, lbv);\n-\t\t    newiv = lbv_to_gcc_expression (lbv, new_ivs, &stmts);\n-\n-\t\t    /* Insert the statements to build that\n-\t\t       expression.  */\n-\t\t    bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n-\n-\t\t    /* Replace the use with the result of that\n-\t\t       expression.  */\n-\t\t    if (dump_file)\n-\t\t      {\n-\t\t\tfprintf (dump_file,\n-\t\t\t\t \"Replacing induction variable use of \");\n-\t\t\tprint_generic_stmt (dump_file, USE_FROM_PTR (use), 0);\n-\t\t\tfprintf (dump_file, \" with \");\n-\t\t\tprint_generic_stmt (dump_file, newiv, 0);\n-\t\t\tfprintf (dump_file, \"\\n\");\n-\t\t      }\n-\t\t    SET_USE (use, newiv);\n-\t\t  }\n-\t      }\n-\n-\t  }\n-      }\n+  \n+  /* Rewrite uses of the old ivs so that they are now specified in terms of\n+     the new ivs.  */\n+  temp = old_loopnest;\n+  for (i = 0; i < VEC_length (tree, old_ivs); i++)\n+    {\n+      int j;\n+      tree oldiv = VEC_index (tree, old_ivs, i);\n+      dataflow_t imm = get_immediate_uses (SSA_NAME_DEF_STMT (oldiv));\n+      for (j = 0; j < num_immediate_uses (imm); j++)\n+\t{\n+\t  size_t k;\n+\t  tree stmt = immediate_use (imm, j);\n+\t  use_optype uses;\n+\t  get_stmt_operands (stmt);\n+\t  uses = STMT_USE_OPS (stmt);\n+\t  for (k = 0; k < NUM_USES (uses); k++)\n+\t    {\n+\t      use_operand_p use = USE_OP_PTR (uses, k);\n+\t      if (USE_FROM_PTR (use) == oldiv)\n+\t\t{\n+\t\t  tree newiv, stmts;\n+\t\t  lambda_body_vector lbv;\n+\t\t  /* Compute the new expression for the induction\n+\t\t     variable.  */\n+\t\t  depth = VEC_length (tree, new_ivs);\n+\t\t  lbv = lambda_body_vector_new (depth);\n+\t\t  LBV_COEFFICIENTS (lbv)[i] = 1;\n+\t\t  lbv = lambda_body_vector_compute_new (transform, lbv);\n+\t\t  newiv = lbv_to_gcc_expression (lbv, new_ivs, &stmts);\n+\t\t  bsi = stmt_for_bsi (stmt);\n+\t\t  /* Insert the statements to build that\n+\t\t     expression.  */\n+\t\t  bsi_insert_before (&bsi, stmts, BSI_SAME_STMT);\n+\t\t  SET_USE (use, newiv);\n+\t\t  modify_stmt (stmt);\n+\t\t  \n+\t\t}\n+\t    }\n+\t}\n+    }\n }\n \n+\n /* Returns true when the vector V is lexicographically positive, in\n    other words, when the first non zero element is positive.  */\n \n static bool\n-lambda_vector_lexico_pos (lambda_vector v, unsigned n)\n+lambda_vector_lexico_pos (lambda_vector v, \n+\t\t\t  unsigned n)\n {\n   unsigned i;\n   for (i = 0; i < n; i++)\n@@ -1923,6 +1951,442 @@ lambda_vector_lexico_pos (lambda_vector v, unsigned n)\n   return true;\n }\n \n+\n+/* Return TRUE if this is not interesting statement from the perspective of\n+   determining if we have a perfect loop nest.  */\n+\n+static bool\n+not_interesting_stmt (tree stmt)\n+{\n+  /* Note that COND_EXPR's aren't interesting because if they were exiting the\n+     loop, we would have already failed the number of exits tests.  */\n+  if (TREE_CODE (stmt) == LABEL_EXPR\n+      || TREE_CODE (stmt) == GOTO_EXPR\n+      || TREE_CODE (stmt) == COND_EXPR)\n+    return true;\n+  return false;\n+}\n+\n+/* Return TRUE if PHI uses DEF for it's in-the-loop edge for LOOP.  */\n+\n+static bool\n+phi_loop_edge_uses_def (struct loop *loop, tree phi, tree def)\n+{\n+  int i;\n+  for (i = 0; i < PHI_NUM_ARGS (phi); i++)\n+    if (flow_bb_inside_loop_p (loop, PHI_ARG_EDGE (phi, i)->src))\n+      if (PHI_ARG_DEF (phi, i) == def)\n+\treturn true;\n+  return false;\n+}\n+\n+/* Return TRUE if STMT is a use of PHI_RESULT.  */\n+\n+static bool\n+stmt_uses_phi_result (tree stmt, tree phi_result)\n+{\n+  use_optype uses = STMT_USE_OPS (stmt);\n+  \n+  /* This is conservatively true, because we only want SIMPLE bumpers\n+     of the form x +- constant for our pass. */\n+  if (NUM_USES (uses) != 1)\n+    return false;\n+  if (USE_OP (uses, 0) == phi_result)\n+    return true;\n+  \n+  return false;\n+}\n+\n+/* STMT is a bumper stmt for LOOP if the version it defines is used in the\n+   in-loop-edge in a phi node, and the operand it uses is the result of that\n+   phi node. \n+   I.E. i_29 = i_3 + 1\n+        i_3 = PHI (0, i_29);  */\n+\n+static bool\n+stmt_is_bumper_for_loop (struct loop *loop, tree stmt)\n+{\n+  tree use;\n+  tree def;\n+  def_optype defs = STMT_DEF_OPS (stmt);\n+  dataflow_t imm;\n+  int i;\n+  \n+  if (NUM_DEFS (defs) != 1)\n+    return false;\n+  def = DEF_OP (defs, 0);\n+  imm = get_immediate_uses (stmt);\n+  for (i = 0; i < num_immediate_uses (imm); i++)\n+    {\n+      use = immediate_use (imm, i);\n+      if (TREE_CODE (use) == PHI_NODE)\n+\t{\n+\t  if (phi_loop_edge_uses_def (loop, use, def))\n+\t    if (stmt_uses_phi_result (stmt, PHI_RESULT (use)))\n+\t      return true;\n+\t} \n+    }\n+  return false;\n+}\n+/* Return true if LOOP is a perfect loop nest.\n+   Perfect loop nests are those loop nests where all code occurs in the\n+   innermost loop body.\n+   If S is a program statement, then\n+\n+   ie \n+   DO I = 1, 20\n+       S1\n+       DO J = 1, 20\n+       ...\n+       END DO\n+   END DO\n+   is not a perfect loop nest because of S1.\n+   \n+   DO I = 1, 20\n+      DO J = 1, 20\n+        S1\n+\t...\n+      END DO\n+   END DO \n+   is a perfect loop nest.  \n+\n+   Since we don't have high level loops anymore, we basically have to walk our\n+   statements and ignore those that are there because the loop needs them (IE\n+   the induction variable increment, and jump back to the top of the loop).  */\n+\n+bool\n+perfect_nest_p (struct loop *loop)\n+{\n+  basic_block *bbs;\n+  size_t i;\n+  tree exit_cond;\n+\n+  if (!loop->inner)\n+    return true;\n+  bbs = get_loop_body (loop);\n+  exit_cond = get_loop_exit_condition (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (bbs[i]->loop_father == loop)\n+\t{\n+\t  block_stmt_iterator bsi;\n+\t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t    {\n+\t      tree stmt = bsi_stmt (bsi);\n+\t      if (stmt == exit_cond\n+\t\t  || not_interesting_stmt (stmt)\n+\t\t  || stmt_is_bumper_for_loop (loop, stmt))\n+\t\tcontinue;\n+\t      free (bbs);\n+\t      return false;\n+\t    }\n+\t}\n+    }\n+  free (bbs);\n+  /* See if the inner loops are perfectly nested as well.  */\n+  if (loop->inner)    \n+    return perfect_nest_p (loop->inner);\n+  return true;\n+}\n+\n+\n+/* Add phi args using PENDINT_STMT list.  */\n+\n+static void\n+nestify_update_pending_stmts (edge e)\n+{\n+  basic_block dest;\n+  tree phi, arg, def;\n+\n+  if (!PENDING_STMT (e))\n+    return;\n+\n+  dest = e->dest;\n+\n+  for (phi = phi_nodes (dest), arg = PENDING_STMT (e);\n+       phi;\n+       phi = TREE_CHAIN (phi), arg = TREE_CHAIN (arg))\n+    {\n+      def = TREE_VALUE (arg);\n+      add_phi_arg (&phi, def, e);\n+    }\n+\n+  PENDING_STMT (e) = NULL;\n+}\n+\n+/* Replace the USES of tree X in STMT with tree Y */\n+\n+static void\n+replace_uses_of_x_with_y (tree stmt, tree x, tree y)\n+{\n+  use_optype uses = STMT_USE_OPS (stmt);\n+  size_t i;\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    {\n+      if (USE_OP (uses, i) == x)\n+\tSET_USE_OP (uses, i, y);\n+    }\n+}\n+\n+/* Return TRUE if STMT uses tree OP in it's uses. */\n+\n+static bool\n+stmt_uses_op (tree stmt, tree op)\n+{\n+  use_optype uses = STMT_USE_OPS (stmt);\n+  size_t i;\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    {\n+      if (USE_OP (uses, i) == op)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+/* Return TRUE if LOOP is an imperfect nest that we can convert to a perfect\n+   one.  LOOPIVS is a vector of induction variables, one per loop.  \n+   ATM, we only handle imperfect nests of depth 2, where all of the statements\n+   occur after the inner loop.  */\n+\n+static bool\n+can_convert_to_perfect_nest (struct loop *loop,\n+\t\t\t     VEC (tree) *loopivs)\n+{\n+  basic_block *bbs;\n+  tree exit_condition;\n+  size_t i;\n+  block_stmt_iterator bsi;\n+\n+  /* Can't handle triply nested+ loops yet.  */\n+  if (!loop->inner || loop->inner->inner)\n+    return false;\n+  \n+  /* We only handle moving the after-inner-body statements right now, so make\n+     sure all the statements we need to move are located in that position.  */\n+  bbs = get_loop_body (loop);\n+  exit_condition = get_loop_exit_condition (loop);\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      if (bbs[i]->loop_father == loop)\n+\t{\n+\t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t    { \n+\t      size_t j;\n+\t      tree stmt = bsi_stmt (bsi);\n+\t      if (stmt == exit_condition\n+\t\t  || not_interesting_stmt (stmt)\n+\t\t  || stmt_is_bumper_for_loop (loop, stmt))\n+\t\tcontinue;\n+\t      /* If the statement uses inner loop ivs, we == screwed.  */\n+\t      for (j = 1; j < VEC_length (tree, loopivs); j++)\n+\t\tif (stmt_uses_op (stmt, VEC_index (tree, loopivs, j)))\n+\t\t  {\n+\t\t    free (bbs);\n+\t\t    return false;\n+\t\t  }\n+\t      \n+\t      /* If the bb of a statement we care about isn't dominated by \n+\t\t the header of the inner loop, then we are also screwed. */\n+\t      if (!dominated_by_p (CDI_DOMINATORS,\n+\t\t\t\t   bb_for_stmt (stmt), \n+\t\t\t\t   loop->inner->header))\n+\t\t{\n+\t\t  free (bbs);\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+    }  \n+  return true;\n+}\n+\n+/* Transform the loop nest into a perfect nest, if possible.\n+   LOOPS is the current struct loops *\n+   LOOP is the loop nest to transform into a perfect nest\n+   LBOUNDS are the lower bounds for the loops to transform\n+   UBOUNDS are the upper bounds for the loops to transform\n+   STEPS is the STEPS for the loops to transform.\n+   LOOPIVS is the induction variables for the loops to transform.\n+   \n+   Basically, for the case of\n+\n+   FOR (i = 0; i < 50; i++)\n+    {\n+     FOR (j =0; j < 50; j++)\n+     {\n+        <whatever>\n+     }\n+     <some code>\n+    }\n+\n+   This function will transform it into a perfect loop nest by splitting the\n+   outer loop into two loops, like so:\n+\n+   FOR (i = 0; i < 50; i++)\n+   {\n+     FOR (j = 0; j < 50; j++)\n+     {\n+         <whatever>\n+     }\n+   }\n+   \n+   FOR (i = 0; i < 50; i ++)\n+   {\n+    <some code>\n+   }\n+\n+   Return FALSE if we can't make this loop into a perfect nest.  */\n+static bool\n+perfect_nestify (struct loops *loops,\n+\t\t struct loop *loop,\n+\t\t VEC (tree) *lbounds,\n+\t\t VEC (tree) *ubounds,\n+\t\t VEC (int) *steps,\n+\t\t VEC (tree) *loopivs)\n+{\n+  basic_block *bbs;\n+  tree exit_condition;\n+  tree then_label, else_label, cond_stmt;\n+  basic_block preheaderbb, headerbb, bodybb, latchbb, olddest;\n+  size_t i;\n+  block_stmt_iterator bsi;\n+  edge e;\n+  struct loop *newloop;\n+  tree phi;\n+  tree uboundvar;\n+  tree stmt;\n+  tree ivvar, ivvarinced;\n+  VEC (tree) *phis;\n+\n+  if (!can_convert_to_perfect_nest (loop, loopivs))\n+    return false;\n+\n+  phis = VEC_alloc (tree, 1);\n+  \n+  /* Create the new loop */\n+\n+  olddest = loop->single_exit->dest;\n+  preheaderbb =  loop_split_edge_with (loop->single_exit, NULL);\n+  headerbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n+  \n+  /* This is done because otherwise, it will release the ssa_name too early\n+     when the edge gets redirected and it will get reused, causing the use of\n+     the phi node to get rewritten.  */\n+\n+  for (phi = phi_nodes (olddest); phi; phi = PHI_CHAIN (phi))\n+    {\n+      /* These should be simple exit phi copies.  */\n+      if (PHI_NUM_ARGS (phi) != 1)\n+\treturn false;\n+      VEC_safe_push (tree, phis, PHI_RESULT (phi));\n+      VEC_safe_push (tree, phis, PHI_ARG_DEF (phi, 0));\n+      mark_for_rewrite (PHI_RESULT (phi));\n+    }\n+  e = redirect_edge_and_branch (preheaderbb->succ, headerbb);\n+  unmark_all_for_rewrite ();\n+  bb_ann (olddest)->phi_nodes = NULL;\n+  /* Add back the old exit phis.  */\n+  while (VEC_length (tree, phis) != 0)\n+    {\n+      tree def;\n+      tree phiname;\n+      def = VEC_pop (tree, phis);\n+      phiname = VEC_pop (tree, phis);\n+      \n+      phi = create_phi_node (phiname, preheaderbb);\n+      add_phi_arg (&phi, def, preheaderbb->pred);\n+    } \n+      \n+  nestify_update_pending_stmts (e);\n+  bodybb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n+  latchbb = create_empty_bb (EXIT_BLOCK_PTR->prev_bb);\n+  make_edge (headerbb, bodybb, EDGE_FALLTHRU); \n+  then_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (latchbb));\n+  else_label = build1 (GOTO_EXPR, void_type_node, tree_block_label (olddest));\n+  cond_stmt = build (COND_EXPR, void_type_node,\n+\t\t     build (NE_EXPR, boolean_type_node, \n+\t\t\t    integer_one_node, \n+\t\t\t    integer_zero_node), \n+\t\t     then_label, else_label);\n+  bsi = bsi_start (bodybb);\n+  bsi_insert_after (&bsi, cond_stmt, BSI_NEW_STMT);\n+  e = make_edge (bodybb, olddest, EDGE_FALSE_VALUE);\n+  make_edge (bodybb, latchbb, EDGE_TRUE_VALUE);\n+  make_edge (latchbb, headerbb, EDGE_FALLTHRU);\n+\n+  /* Update the loop structures.  */\n+  newloop = duplicate_loop (loops, loop, olddest->loop_father);  \n+  newloop->header = headerbb;\n+  newloop->latch = latchbb;\n+  newloop->single_exit = e;\n+  add_bb_to_loop (latchbb, newloop);\n+  add_bb_to_loop (bodybb, newloop);\n+  add_bb_to_loop (headerbb, newloop);\n+  add_bb_to_loop (preheaderbb, olddest->loop_father);\n+  set_immediate_dominator (CDI_DOMINATORS, bodybb, headerbb);\n+  set_immediate_dominator (CDI_DOMINATORS, headerbb, preheaderbb);\n+  set_immediate_dominator (CDI_DOMINATORS, preheaderbb, \n+\t\t\t   loop->single_exit->src);\n+  set_immediate_dominator (CDI_DOMINATORS, latchbb, bodybb);\n+  set_immediate_dominator (CDI_DOMINATORS, olddest, bodybb);\n+  /* Create the new iv.  */\n+  ivvar = create_tmp_var (integer_type_node, \"perfectiv\");\n+  add_referenced_tmp_var (ivvar);\n+  bsi = bsi_last (newloop->latch->pred->src);\n+  create_iv (VEC_index (tree, lbounds, 0),\n+\t     build_int_cst (integer_type_node, \n+\t\t\t    VEC_index (int, steps, 0)),\n+\t     ivvar, newloop, &bsi, false, &ivvar, &ivvarinced);\t     \n+\n+  /* Create the new upper bound.  This may be not just a variable, so we copy\n+     it to one just in case.  */\n+\n+  exit_condition = get_loop_exit_condition (newloop);\n+  uboundvar = create_tmp_var (integer_type_node, \"uboundvar\");\n+  add_referenced_tmp_var (uboundvar);\n+  stmt = build (MODIFY_EXPR, void_type_node, uboundvar, \n+\t\tVEC_index (tree, ubounds, 0));\n+  uboundvar = make_ssa_name (uboundvar, stmt);\n+  TREE_OPERAND (stmt, 0) = uboundvar;\n+  bsi_insert_before (&bsi, stmt, BSI_SAME_STMT);\n+  COND_EXPR_COND (exit_condition) = build (LE_EXPR, \n+\t\t\t\t\t   boolean_type_node,\n+\t\t\t\t\t   ivvarinced, \n+\t\t\t\t\t   uboundvar);\n+\n+  bbs = get_loop_body (loop); \n+  /* Now replace the induction variable in the moved statements with the\n+     correct loop induction variable.  */\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      block_stmt_iterator tobsi = bsi_last (bodybb);\n+      if (bbs[i]->loop_father == loop)\n+\t{\n+\t  /* Note that the bsi only needs to be explicitly incremented\n+\t     when we don't move something, since it is automatically\n+\t     incremented when we do.  */\n+\t  for (bsi = bsi_start (bbs[i]); !bsi_end_p (bsi);)\n+\t    { \n+\t      tree stmt = bsi_stmt (bsi);\n+\t      if (stmt == exit_condition\n+\t\t  || not_interesting_stmt (stmt)\n+\t\t  || stmt_is_bumper_for_loop (loop, stmt))\n+\t\t{\n+\t\t  bsi_next (&bsi);\n+\t\t  continue;\n+\t\t}\n+\t      replace_uses_of_x_with_y (stmt, \n+\t\t\t\t\tVEC_index (tree, loopivs, 0),\n+\t\t\t\t\tivvar);\n+\t      bsi_move_before (&bsi, &tobsi);\n+\t    }\n+\t}\n+    }\n+  free (bbs);\n+  flow_loops_find (loops, LOOP_ALL);\n+  return perfect_nest_p (loop);\n+}\n+\n /* Return true if TRANS is a legal transformation matrix that respects\n    the dependence vectors in DISTS and DIRS.  The conservative answer\n    is false.\n@@ -1931,27 +2395,29 @@ lambda_vector_lexico_pos (lambda_vector v, unsigned n)\n    matrix T is legal when applied to a loop nest with a set of\n    lexicographically non-negative distance vectors RDG if and only if\n    for each vector d in RDG, (T.d >= 0) is lexicographically positive.\n-   i.e.: if and only if it transforms the lexicographically positive\n+   ie.: if and only if it transforms the lexicographically positive\n    distance vectors to lexicographically positive vectors.  Note that\n    a unimodular matrix must transform the zero vector (and only it) to\n    the zero vector.\" S.Muchnick.  */\n \n bool\n-lambda_transform_legal_p (lambda_trans_matrix trans,\n-\t\t\t  int nb_loops, varray_type dependence_relations)\n+lambda_transform_legal_p (lambda_trans_matrix trans, \n+\t\t\t  int nb_loops,\n+\t\t\t  varray_type dependence_relations)\n {\n   unsigned int i;\n   lambda_vector distres;\n   struct data_dependence_relation *ddr;\n \n #if defined ENABLE_CHECKING\n-  gcc_assert (LTM_COLSIZE (trans) == nb_loops \n-\t      && LTM_ROWSIZE (trans) == nb_loops);\n+  if (LTM_COLSIZE (trans) != nb_loops\n+      || LTM_ROWSIZE (trans) != nb_loops)\n+    abort ();\n #endif\n \n   /* When there is an unknown relation in the dependence_relations, we\n      know that it is no worth looking at this loop nest: give up.  */\n-  ddr = (struct data_dependence_relation *)\n+  ddr = (struct data_dependence_relation *) \n     VARRAY_GENERIC_PTR (dependence_relations, 0);\n   if (ddr == NULL)\n     return true;\n@@ -1963,12 +2429,14 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n   /* For each distance vector in the dependence graph.  */\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n     {\n-      ddr = (struct data_dependence_relation *)\n+      ddr = (struct data_dependence_relation *) \n \tVARRAY_GENERIC_PTR (dependence_relations, i);\n \n+     \n+\n       /* Don't care about relations for which we know that there is no\n-         dependence, nor about read-read (aka. output-dependences):\n-         these data accesses can happen in any order.  */\n+\t dependence, nor about read-read (aka. output-dependences):\n+\t these data accesses can happen in any order.  */\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_known\n \t  || (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr))))\n \tcontinue;\n@@ -1977,12 +2445,11 @@ lambda_transform_legal_p (lambda_trans_matrix trans,\n \treturn false;\n \n       /* Compute trans.dist_vect */\n-      lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops,\n+      lambda_matrix_vector_mult (LTM_MATRIX (trans), nb_loops, nb_loops, \n \t\t\t\t DDR_DIST_VECT (ddr), distres);\n \n       if (!lambda_vector_lexico_pos (distres, nb_loops))\n \treturn false;\n     }\n-\n   return true;\n }"}, {"sha": "8f4cbd0e48549e68fbcc86df8283e9200c262ab2", "filename": "gcc/lambda-mat.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -70,6 +70,29 @@ lambda_matrix_id (lambda_matrix mat, int size)\n       mat[i][j] = (i == j) ? 1 : 0;\n }\n \n+/* Return true if MAT is the identity matrix of SIZE */\n+\n+bool\n+lambda_matrix_id_p (lambda_matrix mat, int size)\n+{\n+  int i, j;\n+  for (i = 0; i < size; i++)\n+    for (j = 0; j < size; j++)\n+      {\n+\tif (i == j)\n+\t  {\n+\t    if (mat[i][j] != 1)\n+\t      return false;\n+\t  }\n+\telse\n+\t  {\n+\t    if (mat[i][j] != 0)\n+\t      return false;\n+\t  }\n+      }\n+  return true;\n+}\n+\n /* Negate the elements of the M x N matrix MAT1 and store it in MAT2.  */\n \n void"}, {"sha": "2179c7f113e4e9934544963b028f2c3c062387cb", "filename": "gcc/lambda-trans.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-trans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda-trans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-trans.c?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -45,7 +45,18 @@ lambda_trans_matrix_new (int colsize, int rowsize)\n   return ret;\n }\n \n-/* Compute the inverse of the transformation.  */\n+/* Return true if MAT is an identity matrix.  */\n+\n+bool\n+lambda_trans_matrix_id_p (lambda_trans_matrix mat)\n+{\n+  if (LTM_ROWSIZE (mat) != LTM_COLSIZE (mat))\n+    return false;\n+  return lambda_matrix_id_p (LTM_MATRIX (mat), LTM_ROWSIZE (mat));\n+}\n+\n+\n+/* Compute the inverse of the transformation matrix MAT.  */\n \n lambda_trans_matrix \n lambda_trans_matrix_inverse (lambda_trans_matrix mat)"}, {"sha": "b7360241acc7e28ea9eb4747a33adf4b0cd9269e", "filename": "gcc/lambda.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -105,7 +105,9 @@ typedef struct\n \n lambda_loopnest lambda_loopnest_new (int, int);\n lambda_loopnest lambda_loopnest_transform (lambda_loopnest, lambda_trans_matrix);\n-\n+struct loop;\n+struct loops;\n+bool perfect_nest_p (struct loop *);\n bool lambda_transform_legal_p (lambda_trans_matrix, int, varray_type);\n void print_lambda_loopnest (FILE *, lambda_loopnest, char);\n \n@@ -116,6 +118,7 @@ void print_lambda_loop (FILE *, lambda_loop, int, int, char);\n lambda_matrix lambda_matrix_new (int, int);\n \n void lambda_matrix_id (lambda_matrix, int);\n+bool lambda_matrix_id_p (lambda_matrix, int);\n void lambda_matrix_copy (lambda_matrix, lambda_matrix, int, int);\n void lambda_matrix_negate (lambda_matrix, lambda_matrix, int, int);\n void lambda_matrix_transpose (lambda_matrix, lambda_matrix, int, int);\n@@ -153,16 +156,17 @@ lambda_trans_matrix lambda_trans_matrix_inverse (lambda_trans_matrix);\n void print_lambda_trans_matrix (FILE *, lambda_trans_matrix);\n void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector, \n \t\t\t\tlambda_vector);\n+bool lambda_trans_matrix_id_p (lambda_trans_matrix);\n \n lambda_body_vector lambda_body_vector_new (int);\n lambda_body_vector lambda_body_vector_compute_new (lambda_trans_matrix, \n \t\t\t\t\t\t   lambda_body_vector);\n void print_lambda_body_vector (FILE *, lambda_body_vector);\n-struct loop;\n-\n-lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loop *,\n+lambda_loopnest gcc_loopnest_to_lambda_loopnest (struct loops *,\n+\t\t\t\t\t\t struct loop *,\n+\t\t\t\t\t\t VEC(tree) **,\n \t\t\t\t\t\t VEC(tree) **,\n-\t\t\t\t\t\t VEC(tree) **);\n+\t\t\t\t\t\t bool);\n void lambda_loopnest_to_gcc_loopnest (struct loop *, VEC(tree) *,\n \t\t\t\t      VEC(tree) *,\n \t\t\t\t      lambda_loopnest, "}, {"sha": "de16a1ecf92d5a8175b699e8a251f11c70e51ae3", "filename": "gcc/tree-loop-linear.c", "status": "modified", "additions": 129, "deletions": 42, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Ftree-loop-linear.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f67d92e937b860e1f8d832c8de8249dbc7d657c3/gcc%2Ftree-loop-linear.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-linear.c?ref=f67d92e937b860e1f8d832c8de8249dbc7d657c3", "patch": "@@ -55,69 +55,133 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    transform matrix for locality purposes.\n    TODO: Completion of partial transforms.  */\n \n-/* Gather statistics for loop interchange.  Initializes SUM the sum of\n-   all the data dependence distances carried by loop LOOP_NUMBER.\n-   NB_DEPS_NOT_CARRIED_BY_LOOP is initialized to the number of\n-   dependence relations for which the loop LOOP_NUMBER is not carrying\n-   any dependence.  */\n+/* Gather statistics for loop interchange.  LOOP_NUMBER is a relative\n+   index in the considered loop nest.  The first loop in the\n+   considered loop nest is FIRST_LOOP, and consequently the index of\n+   the considered loop is obtained by FIRST_LOOP + LOOP_NUMBER.\n+   \n+   Initializes:\n+   - DEPENDENCE_STEPS the sum of all the data dependence distances\n+   carried by loop LOOP_NUMBER,\n+\n+   - NB_DEPS_NOT_CARRIED_BY_LOOP the number of dependence relations\n+   for which the loop LOOP_NUMBER is not carrying any dependence,\n+\n+   - ACCESS_STRIDES the sum of all the strides in LOOP_NUMBER.\n+\n+   Example: for the following loop,\n+\n+   | loop_1 runs 1335 times\n+   |   loop_2 runs 1335 times\n+   |     A[{{0, +, 1}_1, +, 1335}_2]\n+   |     B[{{0, +, 1}_1, +, 1335}_2]\n+   |   endloop_2\n+   |   A[{0, +, 1336}_1]\n+   | endloop_1\n+\n+   gather_interchange_stats (in loop_1) will return \n+   DEPENDENCE_STEPS = 3002\n+   NB_DEPS_NOT_CARRIED_BY_LOOP = 5\n+   ACCESS_STRIDES = 10694\n+\n+   gather_interchange_stats (in loop_2) will return \n+   DEPENDENCE_STEPS = 3000\n+   NB_DEPS_NOT_CARRIED_BY_LOOP = 7\n+   ACCESS_STRIDES = 8010\n+  */\n \n static void\n gather_interchange_stats (varray_type dependence_relations, \n+\t\t\t  varray_type datarefs,\n \t\t\t  unsigned int loop_number, \n-\t\t\t  unsigned int *sum, \n-\t\t\t  unsigned int *nb_deps_not_carried_by_loop)\n+\t\t\t  unsigned int first_loop,\n+\t\t\t  unsigned int *dependence_steps, \n+\t\t\t  unsigned int *nb_deps_not_carried_by_loop, \n+\t\t\t  unsigned int *access_strides)\n {\n   unsigned int i;\n \n-  *sum = 0;\n+  *dependence_steps = 0;\n   *nb_deps_not_carried_by_loop = 0;\n+  *access_strides = 0;\n+\n   for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n     {\n       int dist;\n       struct data_dependence_relation *ddr = \n \t(struct data_dependence_relation *) \n \tVARRAY_GENERIC_PTR (dependence_relations, i);\n \n+      /* Compute the dependence strides.  */\n+\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n \t{\n-\t  /* Some constants will need tweaking, but not something that should\n-\t     be user-accessible.  Thus, no --param.  */\n-\t  *sum += 100;\n+\t  (*dependence_steps) += 0;\n \t  continue;\n \t}\n \n       /* When we know that there is no dependence, we know that there\n \t is no reuse of the data.  */\n       if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n \t{\n-\t  /* Ditto on the no --param here */\n-\t  *sum += 1000;\n+\t  (*dependence_steps) += 0;\n \t  continue;\n \t}\n \n       dist = DDR_DIST_VECT (ddr)[loop_number];\n       if (dist == 0)\n-\t*nb_deps_not_carried_by_loop++;\n+\t(*nb_deps_not_carried_by_loop) += 1;\n       else if (dist < 0)\n-\t*sum += -dist;\n+\t(*dependence_steps) += -dist;\n       else\n-\t*sum += dist;\n+\t(*dependence_steps) += dist;\n+    }\n+\n+  /* Compute the access strides.  */\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+    {\n+      unsigned int it;\n+      struct data_reference *dr = VARRAY_GENERIC_PTR (datarefs, i);\n+      tree stmt = DR_STMT (dr);\n+      struct loop *stmt_loop = loop_containing_stmt (stmt);\n+      struct loop *inner_loop = current_loops->parray[first_loop + 1];\n+\n+      if (!flow_loop_nested_p (inner_loop, stmt_loop)\n+\t  && inner_loop->num != stmt_loop->num)\n+\tcontinue;\n+\n+      for (it = 0; it < DR_NUM_DIMENSIONS (dr); it++)\n+\t{\n+\t  tree chrec = DR_ACCESS_FN (dr, it);\n+\t  tree tstride = evolution_part_in_loop_num \n+\t    (chrec, first_loop + loop_number);\n+\t  \n+\t  if (tstride == NULL_TREE\n+\t      || TREE_CODE (tstride) != INTEGER_CST)\n+\t    continue;\n+\t  \n+\t  (*access_strides) += int_cst_value (tstride);\n+\t}\n     }\n }\n \n /* Apply to TRANS any loop interchange that minimize inner loop steps.\n-   DEPTH is the depth of the loop nest, and DEPENDENCE_RELATIONS is an array\n-   of dependence relations.\n    Returns the new transform matrix.  The smaller the reuse vector\n-   distances in the inner loops, the fewer the cache misses.  */\n+   distances in the inner loops, the fewer the cache misses.\n+   FIRST_LOOP is the loop->num of the first loop in the analyzed loop\n+   nest.  */\n+\n \n static lambda_trans_matrix\n try_interchange_loops (lambda_trans_matrix trans, \n \t\t       unsigned int depth,\t\t       \n-\t\t       varray_type dependence_relations)\n+\t\t       varray_type dependence_relations,\n+\t\t       varray_type datarefs, \n+\t\t       unsigned int first_loop)\n {\n   unsigned int loop_i, loop_j;\n-  unsigned int steps_i, steps_j;\n+  unsigned int dependence_steps_i, dependence_steps_j;\n+  unsigned int access_strides_i, access_strides_j;\n   unsigned int nb_deps_not_carried_by_i, nb_deps_not_carried_by_j;\n   struct data_dependence_relation *ddr;\n \n@@ -132,33 +196,40 @@ try_interchange_loops (lambda_trans_matrix trans,\n   for (loop_j = 1; loop_j < depth; loop_j++)\n     for (loop_i = 0; loop_i < loop_j; loop_i++)\n       {\n-\tgather_interchange_stats (dependence_relations, loop_i, &steps_i, \n-\t\t\t\t  &nb_deps_not_carried_by_i);\n-\tgather_interchange_stats (dependence_relations, loop_j, &steps_j, \n-\t\t\t\t  &nb_deps_not_carried_by_j);\n+\tgather_interchange_stats (dependence_relations, datarefs,\n+\t\t\t\t  loop_i, first_loop,\n+\t\t\t\t  &dependence_steps_i, \n+\t\t\t\t  &nb_deps_not_carried_by_i,\n+\t\t\t\t  &access_strides_i);\n+\tgather_interchange_stats (dependence_relations, datarefs,\n+\t\t\t\t  loop_j, first_loop,\n+\t\t\t\t  &dependence_steps_j, \n+\t\t\t\t  &nb_deps_not_carried_by_j, \n+\t\t\t\t  &access_strides_j);\n \t\n \t/* Heuristics for loop interchange profitability:\n-\t   1. Inner loops should have smallest steps.\n-\t   2. Inner loops should contain more dependence relations not\n-\t   carried by the loop.\n+\n+\t   1. (spatial locality) Inner loops should have smallest\n+              dependence steps.\n+\n+\t   2. (spatial locality) Inner loops should contain more\n+\t   dependence relations not carried by the loop.\n+\n+\t   3. (temporal locality) Inner loops should have smallest \n+\t      array access strides.\n \t*/\n-\tif (steps_i < steps_j \n-\t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j)\n+\tif (dependence_steps_i < dependence_steps_j \n+\t    || nb_deps_not_carried_by_i > nb_deps_not_carried_by_j\n+\t    || access_strides_i < access_strides_j)\n \t  {\n \t    lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n-\t\n \t    /* Validate the resulting matrix.  When the transformation\n-\t       is not valid, reverse to the previous matrix.  \n-\t       \n-\t       FIXME: In this case of transformation it could be\n-\t       faster to verify the validity of the interchange\n-\t       without applying the transform to the matrix.  But for\n-\t       the moment do it cleanly: this is just a prototype.  */\n+\t       is not valid, reverse to the previous transformation.  */\n \t    if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n \t      lambda_matrix_row_exchange (LTM_MATRIX (trans), loop_i, loop_j);\n \t  }\n       }\n-  \n+\n   return trans;\n }\n \n@@ -181,6 +252,7 @@ linear_transform_loops (struct loops *loops)\n       lambda_loopnest before, after;\n       lambda_trans_matrix trans;\n       bool problem = false;\n+      bool need_perfect_nest = false;\n       /* If it's not a loop nest, we don't want it.\n          We also don't handle sibling loops properly, \n          which are loops of the following form:\n@@ -197,7 +269,8 @@ linear_transform_loops (struct loops *loops)\n            } */\n       if (!loop_nest->inner)\n \tcontinue;\n-      for (temp = loop_nest; temp; temp = temp->inner)\n+      depth = 1;\n+      for (temp = loop_nest->inner; temp; temp = temp->inner)\n \t{\n \t  flow_loop_scan (temp, LOOP_ALL);\n \t  /* If we have a sibling loop or multiple exit edges, jump ship.  */\n@@ -246,7 +319,15 @@ linear_transform_loops (struct loops *loops)\n       /* Build the transformation matrix.  */\n       trans = lambda_trans_matrix_new (depth, depth);\n       lambda_matrix_id (LTM_MATRIX (trans), depth);\n-      trans = try_interchange_loops (trans, depth, dependence_relations);\n+      trans = try_interchange_loops (trans, depth, dependence_relations,\n+\t\t\t\t     datarefs, loop_nest->num);\n+\n+      if (lambda_trans_matrix_id_p (trans))\n+\t{\n+\t  if (dump_file)\n+\t   fprintf (dump_file, \"Won't transform loop. Optimal transform is the identity transform\\n\");\n+\t  continue;\n+\t}\n \n       /* Check whether the transformation is legal.  */\n       if (!lambda_transform_legal_p (trans, depth, dependence_relations))\n@@ -255,8 +336,12 @@ linear_transform_loops (struct loops *loops)\n \t    fprintf (dump_file, \"Can't transform loop, transform is illegal:\\n\");\n \t  continue;\n \t}\n-      before = gcc_loopnest_to_lambda_loopnest (loop_nest, &oldivs, \n-\t\t\t\t\t\t&invariants);\n+      if (!perfect_nest_p (loop_nest))\n+\tneed_perfect_nest = true;\n+      before = gcc_loopnest_to_lambda_loopnest (loops,\n+\t\t\t\t\t\tloop_nest, &oldivs, \n+\t\t\t\t\t\t&invariants,\n+\t\t\t\t\t\tneed_perfect_nest);\n       if (!before)\n \tcontinue;\n             \n@@ -279,4 +364,6 @@ linear_transform_loops (struct loops *loops)\n       free_dependence_relations (dependence_relations);\n       free_data_refs (datarefs);\n     }\n+  rewrite_into_loop_closed_ssa ();\n+  free_df ();\n }"}]}