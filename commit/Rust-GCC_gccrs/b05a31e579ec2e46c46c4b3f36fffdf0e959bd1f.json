{"sha": "b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "node_id": "C_kwDOANBUbNoAKGIwNWEzMWU1NzllYzJlNDZjNDZjNGIzZjM2ZmZmZGYwZTk1OWJkMWY", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2022-05-20T07:41:30Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-06-02T09:06:45Z"}, "message": "[Ada] Remove redundant checks for missing lists\n\nWhen iterating over list elements with First/Next there is no need to\ncheck if the list is present, because First intentionally returns Empty\nif list is not present and the condition of subsequent loop will not be\nsatisfied.\n\nCode cleanup; semantics is unaffected.\n\nOccurrences of the redundant pattern were found with:\n\n  $ grep First -B 3 | less\n\nand examining the output for the calls to Present.\n\ngcc/ada/\n\n\t* exp_ch13.adb, exp_ch5.adb, exp_ch9.adb, exp_strm.adb,\n\tsem_ch10.adb, sem_ch13.adb, sem_ch5.adb, sem_ch6.adb,\n\tsem_ch8.adb, sem_elab.adb, sem_eval.adb, sem_prag.adb,\n\tsem_util.adb: Remove checks for the missing list before\n\titerating with First/Next; reindent code and refill comments.", "tree": {"sha": "fccac0415278884fdcc26f23e557960b669f4d79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fccac0415278884fdcc26f23e557960b669f4d79"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "89e037d0e36654e84823c47980ef19dc0f77b8ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89e037d0e36654e84823c47980ef19dc0f77b8ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89e037d0e36654e84823c47980ef19dc0f77b8ce"}], "stats": {"total": 874, "additions": 411, "deletions": 463}, "files": [{"sha": "444f75294452910d7d83cc62a8e1cb06414681fd", "filename": "gcc/ada/exp_ch13.adb", "status": "modified", "additions": 45, "deletions": 47, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch13.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -631,58 +631,56 @@ package body Exp_Ch13 is\n       --  assignments, and wrappers may need checks. Other freezing actions\n       --  should be compiled with all checks off.\n \n-      if Present (Actions (N)) then\n-         Decl := First (Actions (N));\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Subprogram_Body\n-              and then (Is_Init_Proc (Defining_Entity (Decl))\n-                          or else\n-                            Chars (Defining_Entity (Decl)) = Name_uAssign\n-                          or else\n-                            (Present (Corresponding_Spec (Decl))\n-                               and then Is_Wrapper\n-                                          (Corresponding_Spec (Decl))))\n-            then\n-               Analyze (Decl);\n+      Decl := First (Actions (N));\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Subprogram_Body\n+           and then (Is_Init_Proc (Defining_Entity (Decl))\n+                       or else\n+                         Chars (Defining_Entity (Decl)) = Name_uAssign\n+                       or else\n+                         (Present (Corresponding_Spec (Decl))\n+                            and then Is_Wrapper\n+                                       (Corresponding_Spec (Decl))))\n+         then\n+            Analyze (Decl);\n \n-            --  A subprogram body created for a renaming_as_body completes\n-            --  a previous declaration, which may be in a different scope.\n-            --  Establish the proper scope before analysis.\n+         --  A subprogram body created for a renaming_as_body completes\n+         --  a previous declaration, which may be in a different scope.\n+         --  Establish the proper scope before analysis.\n \n-            elsif Nkind (Decl) = N_Subprogram_Body\n-              and then Present (Corresponding_Spec (Decl))\n-              and then Scope (Corresponding_Spec (Decl)) /= Current_Scope\n-            then\n-               Push_Scope (Scope (Corresponding_Spec (Decl)));\n-               Analyze (Decl, Suppress => All_Checks);\n-               Pop_Scope;\n-\n-            --  We treat generated equality specially, if validity checks are\n-            --  enabled, in order to detect components default-initialized\n-            --  with invalid values.\n-\n-            elsif Nkind (Decl) = N_Subprogram_Body\n-              and then Chars (Defining_Entity (Decl)) = Name_Op_Eq\n-              and then Validity_Checks_On\n-              and then Initialize_Scalars\n-            then\n-               declare\n-                  Save_Force : constant Boolean := Force_Validity_Checks;\n-               begin\n-                  Force_Validity_Checks := True;\n-                  Analyze (Decl);\n-                  Force_Validity_Checks := Save_Force;\n-               end;\n+         elsif Nkind (Decl) = N_Subprogram_Body\n+           and then Present (Corresponding_Spec (Decl))\n+           and then Scope (Corresponding_Spec (Decl)) /= Current_Scope\n+         then\n+            Push_Scope (Scope (Corresponding_Spec (Decl)));\n+            Analyze (Decl, Suppress => All_Checks);\n+            Pop_Scope;\n+\n+         --  We treat generated equality specially, if validity checks are\n+         --  enabled, in order to detect components default-initialized with\n+         --  invalid values.\n+\n+         elsif Nkind (Decl) = N_Subprogram_Body\n+           and then Chars (Defining_Entity (Decl)) = Name_Op_Eq\n+           and then Validity_Checks_On\n+           and then Initialize_Scalars\n+         then\n+            declare\n+               Save_Force : constant Boolean := Force_Validity_Checks;\n+            begin\n+               Force_Validity_Checks := True;\n+               Analyze (Decl);\n+               Force_Validity_Checks := Save_Force;\n+            end;\n \n-            --  All other freezing actions\n+         --  All other freezing actions\n \n-            else\n-               Analyze (Decl, Suppress => All_Checks);\n-            end if;\n+         else\n+            Analyze (Decl, Suppress => All_Checks);\n+         end if;\n \n-            Next (Decl);\n-         end loop;\n-      end if;\n+         Next (Decl);\n+      end loop;\n \n       --  If we are to delete this N_Freeze_Entity, do so by rewriting so that\n       --  a loop on all nodes being inserted will work propertly."}, {"sha": "2072935d2ca61a9b3d228ccad3135cd72bee1d25", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 51, "deletions": 54, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -4530,75 +4530,72 @@ package body Exp_Ch5 is\n       --  Loop through elsif parts, dealing with constant conditions and\n       --  possible condition actions that are present.\n \n-      if Present (Elsif_Parts (N)) then\n-         E := First (Elsif_Parts (N));\n-         while Present (E) loop\n+      E := First (Elsif_Parts (N));\n+      while Present (E) loop\n \n-            --  Do not consider controlled objects found in an if statement\n-            --  which actually models an if expression because their early\n-            --  finalization will affect the result of the expression.\n+         --  Do not consider controlled objects found in an if statement which\n+         --  actually models an if expression because their early finalization\n+         --  will affect the result of the expression.\n \n-            if not From_Conditional_Expression (N) then\n-               Process_Statements_For_Controlled_Objects (E);\n-            end if;\n+         if not From_Conditional_Expression (N) then\n+            Process_Statements_For_Controlled_Objects (E);\n+         end if;\n \n-            Adjust_Condition (Condition (E));\n+         Adjust_Condition (Condition (E));\n \n-            --  If there are condition actions, then rewrite the if statement\n-            --  as indicated above. We also do the same rewrite for a True or\n-            --  False condition. The further processing of this constant\n-            --  condition is then done by the recursive call to expand the\n-            --  newly created if statement\n+         --  If there are condition actions, then rewrite the if statement as\n+         --  indicated above. We also do the same rewrite for a True or False\n+         --  condition. The further processing of this constant condition is\n+         --  then done by the recursive call to expand the newly created if\n+         --  statement\n \n-            if Present (Condition_Actions (E))\n-              or else Compile_Time_Known_Value (Condition (E))\n-            then\n-               New_If :=\n-                 Make_If_Statement (Sloc (E),\n-                   Condition       => Condition (E),\n-                   Then_Statements => Then_Statements (E),\n-                   Elsif_Parts     => No_List,\n-                   Else_Statements => Else_Statements (N));\n-\n-               --  Elsif parts for new if come from remaining elsif's of parent\n-\n-               while Present (Next (E)) loop\n-                  if No (Elsif_Parts (New_If)) then\n-                     Set_Elsif_Parts (New_If, New_List);\n-                  end if;\n+         if Present (Condition_Actions (E))\n+           or else Compile_Time_Known_Value (Condition (E))\n+         then\n+            New_If :=\n+              Make_If_Statement (Sloc (E),\n+                Condition       => Condition (E),\n+                Then_Statements => Then_Statements (E),\n+                Elsif_Parts     => No_List,\n+                Else_Statements => Else_Statements (N));\n+\n+            --  Elsif parts for new if come from remaining elsif's of parent\n+\n+            while Present (Next (E)) loop\n+               if No (Elsif_Parts (New_If)) then\n+                  Set_Elsif_Parts (New_If, New_List);\n+               end if;\n \n-                  Append (Remove_Next (E), Elsif_Parts (New_If));\n-               end loop;\n+               Append (Remove_Next (E), Elsif_Parts (New_If));\n+            end loop;\n \n-               Set_Else_Statements (N, New_List (New_If));\n+            Set_Else_Statements (N, New_List (New_If));\n \n-               Insert_List_Before (New_If, Condition_Actions (E));\n+            Insert_List_Before (New_If, Condition_Actions (E));\n \n-               Remove (E);\n+            Remove (E);\n \n-               if Is_Empty_List (Elsif_Parts (N)) then\n-                  Set_Elsif_Parts (N, No_List);\n-               end if;\n+            if Is_Empty_List (Elsif_Parts (N)) then\n+               Set_Elsif_Parts (N, No_List);\n+            end if;\n \n-               Analyze (New_If);\n+            Analyze (New_If);\n \n-               --  Note this is not an implicit if statement, since it is part\n-               --  of an explicit if statement in the source (or of an implicit\n-               --  if statement that has already been tested). We set the flag\n-               --  after calling Analyze to avoid generating extra warnings\n-               --  specific to pure if statements, however (see\n-               --  Sem_Ch5.Analyze_If_Statement).\n+            --  Note this is not an implicit if statement, since it is part of\n+            --  an explicit if statement in the source (or of an implicit if\n+            --  statement that has already been tested). We set the flag after\n+            --  calling Analyze to avoid generating extra warnings specific to\n+            --  pure if statements, however (see Sem_Ch5.Analyze_If_Statement).\n \n-               Preserve_Comes_From_Source (New_If, N);\n-               return;\n+            Preserve_Comes_From_Source (New_If, N);\n+            return;\n \n-            --  No special processing for that elsif part, move to next\n+         --  No special processing for that elsif part, move to next\n \n-            else\n-               Next (E);\n-            end if;\n-         end loop;\n-      end if;\n+         else\n+            Next (E);\n+         end if;\n+      end loop;\n \n       --  Some more optimizations applicable if we still have an IF statement\n "}, {"sha": "ed6844ea3f05883bd9f204a26fa5c9ef8807536d", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 143, "deletions": 149, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -9303,171 +9303,167 @@ package body Exp_Ch9 is\n \n       --  Add private field components\n \n-      if Present (Private_Declarations (Pdef)) then\n-         Priv := First (Private_Declarations (Pdef));\n-         while Present (Priv) loop\n-            if Nkind (Priv) = N_Component_Declaration then\n-               if not Static_Component_Size (Defining_Identifier (Priv)) then\n-\n-                  --  When compiling for a restricted profile, the private\n-                  --  components must have a static size. If not, this is an\n-                  --  error for a single protected declaration, and rates a\n-                  --  warning on a protected type declaration.\n-\n-                  if not Comes_From_Source (Prot_Typ) then\n-\n-                     --  It's ok to be checking this restriction at expansion\n-                     --  time, because this is only for the restricted profile,\n-                     --  which is not subject to strict RM conformance, so it\n-                     --  is OK to miss this check in -gnatc mode.\n-\n-                     Check_Restriction (No_Implicit_Heap_Allocations, Priv);\n-                     Check_Restriction\n-                       (No_Implicit_Protected_Object_Allocations, Priv);\n-\n-                  elsif Restriction_Active (No_Implicit_Heap_Allocations) then\n-                     if not Discriminated_Size (Defining_Identifier (Priv))\n-                     then\n-                        --  Any object of the type will be non-static\n+      Priv := First (Private_Declarations (Pdef));\n+      while Present (Priv) loop\n+         if Nkind (Priv) = N_Component_Declaration then\n+            if not Static_Component_Size (Defining_Identifier (Priv)) then\n \n-                        Error_Msg_N (\"component has non-static size??\", Priv);\n-                        Error_Msg_NE\n-                          (\"\\creation of protected object of type& will \"\n-                           & \"violate restriction \"\n-                           & \"No_Implicit_Heap_Allocations??\", Priv, Prot_Typ);\n-                     else\n-                        --  Object will be non-static if discriminants are\n+               --  When compiling for a restricted profile, the private\n+               --  components must have a static size. If not, this is an error\n+               --  for a single protected declaration, and rates a warning on a\n+               --  protected type declaration.\n \n-                        Error_Msg_NE\n-                          (\"creation of protected object of type& with \"\n-                           & \"non-static discriminants will violate \"\n-                           & \"restriction No_Implicit_Heap_Allocations??\",\n-                           Priv, Prot_Typ);\n-                     end if;\n+               if not Comes_From_Source (Prot_Typ) then\n+\n+                  --  It's ok to be checking this restriction at expansion\n+                  --  time, because this is only for the restricted profile,\n+                  --  which is not subject to strict RM conformance, so it\n+                  --  is OK to miss this check in -gnatc mode.\n \n-                  --  Likewise for No_Implicit_Protected_Object_Allocations\n+                  Check_Restriction (No_Implicit_Heap_Allocations, Priv);\n+                  Check_Restriction\n+                    (No_Implicit_Protected_Object_Allocations, Priv);\n \n-                  elsif Restriction_Active\n-                    (No_Implicit_Protected_Object_Allocations)\n+               elsif Restriction_Active (No_Implicit_Heap_Allocations) then\n+                  if not Discriminated_Size (Defining_Identifier (Priv))\n                   then\n-                     if not Discriminated_Size (Defining_Identifier (Priv))\n-                     then\n-                        --  Any object of the type will be non-static\n-\n-                        Error_Msg_N (\"component has non-static size??\", Priv);\n-                        Error_Msg_NE\n-                          (\"\\creation of protected object of type& will \"\n-                           & \"violate restriction \"\n-                           & \"No_Implicit_Protected_Object_Allocations??\",\n-                           Priv, Prot_Typ);\n-                     else\n-                        --  Object will be non-static if discriminants are\n-\n-                        Error_Msg_NE\n-                          (\"creation of protected object of type& with \"\n-                           & \"non-static discriminants will violate \"\n-                           & \"restriction \"\n-                           & \"No_Implicit_Protected_Object_Allocations??\",\n-                           Priv, Prot_Typ);\n-                     end if;\n+                     --  Any object of the type will be non-static\n+\n+                     Error_Msg_N (\"component has non-static size??\", Priv);\n+                     Error_Msg_NE\n+                       (\"\\creation of protected object of type& will \"\n+                        & \"violate restriction \"\n+                        & \"No_Implicit_Heap_Allocations??\", Priv, Prot_Typ);\n+                  else\n+                     --  Object will be non-static if discriminants are\n+\n+                     Error_Msg_NE\n+                       (\"creation of protected object of type& with \"\n+                        & \"non-static discriminants will violate \"\n+                        & \"restriction No_Implicit_Heap_Allocations??\",\n+                        Priv, Prot_Typ);\n+                  end if;\n+\n+               --  Likewise for No_Implicit_Protected_Object_Allocations\n+\n+               elsif Restriction_Active\n+                 (No_Implicit_Protected_Object_Allocations)\n+               then\n+                  if not Discriminated_Size (Defining_Identifier (Priv)) then\n+                     --  Any object of the type will be non-static\n+\n+                     Error_Msg_N (\"component has non-static size??\", Priv);\n+                     Error_Msg_NE\n+                       (\"\\creation of protected object of type& will violate \"\n+                        & \"restriction \"\n+                        & \"No_Implicit_Protected_Object_Allocations??\",\n+                        Priv, Prot_Typ);\n+                  else\n+                     --  Object will be non-static if discriminants are\n+\n+                     Error_Msg_NE\n+                       (\"creation of protected object of type& with \"\n+                        & \"non-static discriminants will violate restriction \"\n+                        & \"No_Implicit_Protected_Object_Allocations??\",\n+                        Priv, Prot_Typ);\n                   end if;\n                end if;\n+            end if;\n \n-               --  The component definition consists of a subtype indication,\n-               --  or (in Ada 2005) an access definition. Make a copy of the\n-               --  proper definition.\n+            --  The component definition consists of a subtype indication, or\n+            --  (in Ada 2005) an access definition. Make a copy of the proper\n+            --  definition.\n \n-               declare\n-                  Old_Comp : constant Node_Id   := Component_Definition (Priv);\n-                  Oent     : constant Entity_Id := Defining_Identifier (Priv);\n-                  Nent     : constant Entity_Id :=\n-                               Make_Defining_Identifier (Sloc (Oent),\n-                                 Chars => Chars (Oent));\n-                  New_Comp : Node_Id;\n+            declare\n+               Old_Comp : constant Node_Id   := Component_Definition (Priv);\n+               Oent     : constant Entity_Id := Defining_Identifier (Priv);\n+               Nent     : constant Entity_Id :=\n+                            Make_Defining_Identifier (Sloc (Oent),\n+                              Chars => Chars (Oent));\n+               New_Comp : Node_Id;\n \n-               begin\n-                  if Present (Subtype_Indication (Old_Comp)) then\n-                     New_Comp :=\n-                       Make_Component_Definition (Sloc (Oent),\n-                         Aliased_Present    => False,\n-                         Subtype_Indication =>\n-                           New_Copy_Tree\n-                             (Subtype_Indication (Old_Comp), Discr_Map));\n-                  else\n-                     New_Comp :=\n-                       Make_Component_Definition (Sloc (Oent),\n-                         Aliased_Present    => False,\n-                         Access_Definition  =>\n-                           New_Copy_Tree\n-                             (Access_Definition (Old_Comp), Discr_Map));\n-\n-                      --  A self-reference in the private part becomes a\n-                      --  self-reference to the corresponding record.\n-\n-                     if Entity (Subtype_Mark (Access_Definition (New_Comp)))\n-                       = Prot_Typ\n-                     then\n-                        Replace_Access_Definition (New_Comp);\n-                     end if;\n+            begin\n+               if Present (Subtype_Indication (Old_Comp)) then\n+                  New_Comp :=\n+                    Make_Component_Definition (Sloc (Oent),\n+                      Aliased_Present    => False,\n+                      Subtype_Indication =>\n+                        New_Copy_Tree\n+                          (Subtype_Indication (Old_Comp), Discr_Map));\n+               else\n+                  New_Comp :=\n+                    Make_Component_Definition (Sloc (Oent),\n+                      Aliased_Present   => False,\n+                      Access_Definition =>\n+                        New_Copy_Tree\n+                          (Access_Definition (Old_Comp), Discr_Map));\n+\n+                   --  A self-reference in the private part becomes a\n+                   --  self-reference to the corresponding record.\n+\n+                  if Entity (Subtype_Mark (Access_Definition (New_Comp)))\n+                    = Prot_Typ\n+                  then\n+                     Replace_Access_Definition (New_Comp);\n                   end if;\n+               end if;\n \n-                  New_Priv :=\n-                    Make_Component_Declaration (Loc,\n-                      Defining_Identifier  => Nent,\n-                      Component_Definition => New_Comp,\n-                      Expression           => Expression (Priv));\n+               New_Priv :=\n+                 Make_Component_Declaration (Loc,\n+                   Defining_Identifier  => Nent,\n+                   Component_Definition => New_Comp,\n+                   Expression           => Expression (Priv));\n \n-                  Set_Has_Per_Object_Constraint (Nent,\n-                    Has_Per_Object_Constraint (Oent));\n+               Set_Has_Per_Object_Constraint (Nent,\n+                 Has_Per_Object_Constraint (Oent));\n \n-                  Append_To (Cdecls, New_Priv);\n-               end;\n+               Append_To (Cdecls, New_Priv);\n+            end;\n \n-            elsif Nkind (Priv) = N_Subprogram_Declaration then\n+         elsif Nkind (Priv) = N_Subprogram_Declaration then\n \n-               --  Make the unprotected version of the subprogram available\n-               --  for expansion of intra object calls. There is need for\n-               --  a protected version only if the subprogram is an interrupt\n-               --  handler, otherwise  this operation can only be called from\n-               --  within the body.\n+            --  Make the unprotected version of the subprogram available for\n+            --  expansion of intra object calls. There is need for a protected\n+            --  version only if the subprogram is an interrupt handler,\n+            --  otherwise this operation can only be called from within the\n+            --  body.\n \n-               Sub :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification =>\n-                     Build_Protected_Sub_Specification\n-                       (Priv, Prot_Typ, Unprotected_Mode));\n+            Sub :=\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Build_Protected_Sub_Specification\n+                    (Priv, Prot_Typ, Unprotected_Mode));\n \n-               Insert_After (Current_Node, Sub);\n-               Analyze (Sub);\n+            Insert_After (Current_Node, Sub);\n+            Analyze (Sub);\n \n-               Set_Protected_Body_Subprogram\n-                 (Defining_Unit_Name (Specification (Priv)),\n-                  Defining_Unit_Name (Specification (Sub)));\n-               Check_Inlining (Defining_Unit_Name (Specification (Priv)));\n-               Current_Node := Sub;\n+            Set_Protected_Body_Subprogram\n+              (Defining_Unit_Name (Specification (Priv)),\n+               Defining_Unit_Name (Specification (Sub)));\n+            Check_Inlining (Defining_Unit_Name (Specification (Priv)));\n+            Current_Node := Sub;\n \n-               Sub :=\n-                 Make_Subprogram_Declaration (Loc,\n-                   Specification =>\n-                     Build_Protected_Sub_Specification\n-                       (Priv, Prot_Typ, Protected_Mode));\n+            Sub :=\n+              Make_Subprogram_Declaration (Loc,\n+                Specification =>\n+                  Build_Protected_Sub_Specification\n+                    (Priv, Prot_Typ, Protected_Mode));\n \n-               Insert_After (Current_Node, Sub);\n-               Analyze (Sub);\n-               Current_Node := Sub;\n+            Insert_After (Current_Node, Sub);\n+            Analyze (Sub);\n+            Current_Node := Sub;\n \n-               if Is_Interrupt_Handler\n-                 (Defining_Unit_Name (Specification (Priv)))\n-               then\n-                  if not Restricted_Profile then\n-                     Register_Handler;\n-                  end if;\n+            if Is_Interrupt_Handler\n+              (Defining_Unit_Name (Specification (Priv)))\n+            then\n+               if not Restricted_Profile then\n+                  Register_Handler;\n                end if;\n             end if;\n+         end if;\n \n-            Next (Priv);\n-         end loop;\n-      end if;\n+         Next (Priv);\n+      end loop;\n \n       --  Except for the lock-free implementation, append the _Object field\n       --  with the right type to the component list. We need to compute the\n@@ -9708,16 +9704,14 @@ package body Exp_Ch9 is\n       --  If there are some private entry declarations, expand it as if they\n       --  were visible entries.\n \n-      if Present (Private_Declarations (Pdef)) then\n-         Comp := First (Private_Declarations (Pdef));\n-         while Present (Comp) loop\n-            if Nkind (Comp) = N_Entry_Declaration then\n-               Expand_Entry_Declaration (Comp);\n-            end if;\n+      Comp := First (Private_Declarations (Pdef));\n+      while Present (Comp) loop\n+         if Nkind (Comp) = N_Entry_Declaration then\n+            Expand_Entry_Declaration (Comp);\n+         end if;\n \n-            Next (Comp);\n-         end loop;\n-      end if;\n+         Next (Comp);\n+      end loop;\n \n       --  Create the declaration of an array object which contains the values\n       --  of aspect/pragma Max_Queue_Length for all entries of the protected"}, {"sha": "d7a73f511644017414f9919bdb36b399900618fc", "filename": "gcc/ada/exp_strm.adb", "status": "modified", "additions": 24, "deletions": 29, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_strm.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fexp_strm.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_strm.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -1548,37 +1548,32 @@ package body Exp_Strm is\n \n       function Make_Field_Attributes (Clist : List_Id) return List_Id is\n          Item   : Node_Id;\n-         Result : List_Id;\n+         Result : constant List_Id := New_List;\n \n       begin\n-         Result := New_List;\n-\n-         if Present (Clist) then\n-            Item := First (Clist);\n-\n-            --  Loop through components, skipping all internal components,\n-            --  which are not part of the value (e.g. _Tag), except that we\n-            --  don't skip the _Parent, since we do want to process that\n-            --  recursively. If _Parent is an interface type, being abstract\n-            --  with no components there is no need to handle it.\n-\n-            while Present (Item) loop\n-               if Nkind (Item) = N_Component_Declaration\n-                 and then\n-                   ((Chars (Defining_Identifier (Item)) = Name_uParent\n-                       and then not Is_Interface\n-                                      (Etype (Defining_Identifier (Item))))\n-                     or else\n-                    not Is_Internal_Name (Chars (Defining_Identifier (Item))))\n-               then\n-                  Append_To\n-                    (Result,\n-                     Make_Field_Attribute (Defining_Identifier (Item)));\n-               end if;\n-\n-               Next (Item);\n-            end loop;\n-         end if;\n+         --  Loop through components, skipping all internal components, which\n+         --  are not part of the value (e.g. _Tag), except that we don't skip\n+         --  the _Parent, since we do want to process that recursively. If\n+         --  _Parent is an interface type, being abstract with no components\n+         --  there is no need to handle it.\n+\n+         Item := First (Clist);\n+         while Present (Item) loop\n+            if Nkind (Item) = N_Component_Declaration\n+              and then\n+                ((Chars (Defining_Identifier (Item)) = Name_uParent\n+                 and then not Is_Interface\n+                   (Etype (Defining_Identifier (Item))))\n+                or else\n+                  not Is_Internal_Name (Chars (Defining_Identifier (Item))))\n+            then\n+               Append_To\n+                 (Result,\n+                  Make_Field_Attribute (Defining_Identifier (Item)));\n+            end if;\n+\n+            Next (Item);\n+         end loop;\n \n          return Result;\n       end Make_Field_Attributes;"}, {"sha": "5976b4dd7e3e6693c94c8f3ea869c4105f1f2419", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 18, "deletions": 22, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -946,16 +946,14 @@ package body Sem_Ch10 is\n \n       --  Treat compilation unit pragmas that appear after the library unit\n \n-      if Present (Pragmas_After (Aux_Decls_Node (N))) then\n-         declare\n-            Prag_Node : Node_Id := First (Pragmas_After (Aux_Decls_Node (N)));\n-         begin\n-            while Present (Prag_Node) loop\n-               Analyze (Prag_Node);\n-               Next (Prag_Node);\n-            end loop;\n-         end;\n-      end if;\n+      declare\n+         Prag_Node : Node_Id := First (Pragmas_After (Aux_Decls_Node (N)));\n+      begin\n+         while Present (Prag_Node) loop\n+            Analyze (Prag_Node);\n+            Next (Prag_Node);\n+         end loop;\n+      end;\n \n       --  Analyze the contract of a [generic] subprogram that acts as a\n       --  compilation unit after all compilation pragmas have been analyzed.\n@@ -3353,19 +3351,17 @@ package body Sem_Ch10 is\n    --  Start of processing for Has_With_Clause\n \n    begin\n-      if Present (Context_Items (C_Unit)) then\n-         Item := First (Context_Items (C_Unit));\n-         while Present (Item) loop\n-            if Nkind (Item) = N_With_Clause\n-              and then Limited_Present (Item) = Is_Limited\n-              and then Named_Unit (Item) = Pack\n-            then\n-               return True;\n-            end if;\n+      Item := First (Context_Items (C_Unit));\n+      while Present (Item) loop\n+         if Nkind (Item) = N_With_Clause\n+           and then Limited_Present (Item) = Is_Limited\n+           and then Named_Unit (Item) = Pack\n+         then\n+            return True;\n+         end if;\n \n-            Next (Item);\n-         end loop;\n-      end if;\n+         Next (Item);\n+      end loop;\n \n       return False;\n    end Has_With_Clause;"}, {"sha": "0b8911b8dcd6adb9170285184cb5f8ad0030c051", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -11755,13 +11755,11 @@ package body Sem_Ch13 is\n          Nod1 : Node_Id;\n \n       begin\n-         if Present (Lst) then\n-            Nod1 := First (Lst);\n-            while Present (Nod1) loop\n-               Check_Expr_Constants (Nod1);\n-               Next (Nod1);\n-            end loop;\n-         end if;\n+         Nod1 := First (Lst);\n+         while Present (Nod1) loop\n+            Check_Expr_Constants (Nod1);\n+            Next (Nod1);\n+         end loop;\n       end Check_List_Constants;\n \n    --  Start of processing for Check_Constant_Address_Clause"}, {"sha": "c5c8a7c87acfe02d48ba1bbfa19a719574e334c4", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -2019,13 +2019,11 @@ package body Sem_Ch5 is\n \n       --  Now to analyze the elsif parts if any are present\n \n-      if Present (Elsif_Parts (N)) then\n-         E := First (Elsif_Parts (N));\n-         while Present (E) loop\n-            Analyze_Cond_Then (E);\n-            Next (E);\n-         end loop;\n-      end if;\n+      E := First (Elsif_Parts (N));\n+      while Present (E) loop\n+         Analyze_Cond_Then (E);\n+         Next (E);\n+      end loop;\n \n       if Present (Else_Statements (N)) then\n          Analyze_Statements (Else_Statements (N));\n@@ -2054,13 +2052,11 @@ package body Sem_Ch5 is\n          if Is_True (Expr_Value (Condition (N))) then\n             Remove_Warning_Messages (Else_Statements (N));\n \n-            if Present (Elsif_Parts (N)) then\n-               E := First (Elsif_Parts (N));\n-               while Present (E) loop\n-                  Remove_Warning_Messages (Then_Statements (E));\n-                  Next (E);\n-               end loop;\n-            end if;\n+            E := First (Elsif_Parts (N));\n+            while Present (E) loop\n+               Remove_Warning_Messages (Then_Statements (E));\n+               Next (E);\n+            end loop;\n \n          else\n             Remove_Warning_Messages (Then_Statements (N));"}, {"sha": "8fd88ade84e69bc10358eefcd54ab523d151e945", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 58, "deletions": 72, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -712,14 +712,12 @@ package body Sem_Ch6 is\n \n       --  Otherwise analyze the parameters\n \n-      if Present (Actuals) then\n-         Actual := First (Actuals);\n-         while Present (Actual) loop\n-            Analyze (Actual);\n-            Check_Parameterless_Call (Actual);\n-            Next (Actual);\n-         end loop;\n-      end if;\n+      Actual := First (Actuals);\n+      while Present (Actual) loop\n+         Analyze (Actual);\n+         Check_Parameterless_Call (Actual);\n+         Next (Actual);\n+      end loop;\n \n       Analyze_Call (N);\n    end Analyze_Function_Call;\n@@ -2300,15 +2298,13 @@ package body Sem_Ch6 is\n \n       --  Otherwise analyze the parameters\n \n-      if Present (Actuals) then\n-         Actual := First (Actuals);\n+      Actual := First (Actuals);\n \n-         while Present (Actual) loop\n-            Analyze (Actual);\n-            Check_Parameterless_Call (Actual);\n-            Next (Actual);\n-         end loop;\n-      end if;\n+      while Present (Actual) loop\n+         Analyze (Actual);\n+         Check_Parameterless_Call (Actual);\n+         Next (Actual);\n+      end loop;\n \n       --  Special processing for Elab_Spec, Elab_Body and Elab_Subp_Body calls\n \n@@ -3061,31 +3057,27 @@ package body Sem_Ch6 is\n       begin\n          --  Check for aspects that may generate a contract\n \n-         if Present (Aspect_Specifications (N)) then\n-            Item := First (Aspect_Specifications (N));\n-            while Present (Item) loop\n-               if Is_Subprogram_Contract_Annotation (Item) then\n-                  return True;\n-               end if;\n+         Item := First (Aspect_Specifications (N));\n+         while Present (Item) loop\n+            if Is_Subprogram_Contract_Annotation (Item) then\n+               return True;\n+            end if;\n \n-               Next (Item);\n-            end loop;\n-         end if;\n+            Next (Item);\n+         end loop;\n \n          --  Check for pragmas that may generate a contract\n \n-         if Present (Decls) then\n-            Item := First (Decls);\n-            while Present (Item) loop\n-               if Nkind (Item) = N_Pragma\n-                 and then Is_Subprogram_Contract_Annotation (Item)\n-               then\n-                  return True;\n-               end if;\n+         Item := First (Decls);\n+         while Present (Item) loop\n+            if Nkind (Item) = N_Pragma\n+              and then Is_Subprogram_Contract_Annotation (Item)\n+            then\n+               return True;\n+            end if;\n \n-               Next (Item);\n-            end loop;\n-         end if;\n+            Next (Item);\n+         end loop;\n \n          return False;\n       end Body_Has_Contract;\n@@ -3101,41 +3093,37 @@ package body Sem_Ch6 is\n       begin\n          --  Check for SPARK_Mode aspect\n \n-         if Present (Aspect_Specifications (N)) then\n-            Item := First (Aspect_Specifications (N));\n-            while Present (Item) loop\n-               if Get_Aspect_Id (Item) = Aspect_SPARK_Mode then\n-                  return Get_SPARK_Mode_From_Annotation (Item) = On;\n-               end if;\n+         Item := First (Aspect_Specifications (N));\n+         while Present (Item) loop\n+            if Get_Aspect_Id (Item) = Aspect_SPARK_Mode then\n+               return Get_SPARK_Mode_From_Annotation (Item) = On;\n+            end if;\n \n-               Next (Item);\n-            end loop;\n-         end if;\n+            Next (Item);\n+         end loop;\n \n          --  Check for SPARK_Mode pragma\n \n-         if Present (Decls) then\n-            Item := First (Decls);\n-            while Present (Item) loop\n+         Item := First (Decls);\n+         while Present (Item) loop\n \n-               --  Pragmas that apply to a subprogram body are usually grouped\n-               --  together. Look for a potential pragma SPARK_Mode among them.\n+            --  Pragmas that apply to a subprogram body are usually grouped\n+            --  together. Look for a potential pragma SPARK_Mode among them.\n \n-               if Nkind (Item) = N_Pragma then\n-                  if Get_Pragma_Id (Item) = Pragma_SPARK_Mode then\n-                     return Get_SPARK_Mode_From_Annotation (Item) = On;\n-                  end if;\n+            if Nkind (Item) = N_Pragma then\n+               if Get_Pragma_Id (Item) = Pragma_SPARK_Mode then\n+                  return Get_SPARK_Mode_From_Annotation (Item) = On;\n+               end if;\n \n-               --  Otherwise the first non-pragma declarative item terminates\n-               --  the region where pragma SPARK_Mode may appear.\n+            --  Otherwise the first non-pragma declarative item terminates the\n+            --  region where pragma SPARK_Mode may appear.\n \n-               else\n-                  exit;\n-               end if;\n+            else\n+               exit;\n+            end if;\n \n-               Next (Item);\n-            end loop;\n-         end if;\n+            Next (Item);\n+         end loop;\n \n          --  Otherwise, the applicable SPARK_Mode is inherited from the\n          --  enclosing subprogram or package.\n@@ -7792,17 +7780,15 @@ package body Sem_Ch6 is\n             Check_Statement_Sequence (Then_Statements (Last_Stm));\n             Check_Statement_Sequence (Else_Statements (Last_Stm));\n \n-            if Present (Elsif_Parts (Last_Stm)) then\n-               declare\n-                  Elsif_Part : Node_Id := First (Elsif_Parts (Last_Stm));\n+            declare\n+               Elsif_Part : Node_Id := First (Elsif_Parts (Last_Stm));\n \n-               begin\n-                  while Present (Elsif_Part) loop\n-                     Check_Statement_Sequence (Then_Statements (Elsif_Part));\n-                     Next (Elsif_Part);\n-                  end loop;\n-               end;\n-            end if;\n+            begin\n+               while Present (Elsif_Part) loop\n+                  Check_Statement_Sequence (Then_Statements (Elsif_Part));\n+                  Next (Elsif_Part);\n+               end loop;\n+            end;\n \n             return;\n "}, {"sha": "0e75bb4ab63da2cc03b155789fe75b043ebf00ec", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -9831,22 +9831,20 @@ package body Sem_Ch8 is\n       Decl : Node_Id;\n \n    begin\n-      if Present (L) then\n-         Decl := First (L);\n-         while Present (Decl) loop\n-            if Nkind (Decl) = N_Use_Package_Clause then\n-               Chain_Use_Clause (Decl);\n-               Use_One_Package (Decl, Name (Decl));\n+      Decl := First (L);\n+      while Present (Decl) loop\n+         if Nkind (Decl) = N_Use_Package_Clause then\n+            Chain_Use_Clause (Decl);\n+            Use_One_Package (Decl, Name (Decl));\n \n-            elsif Nkind (Decl) = N_Use_Type_Clause then\n-               Chain_Use_Clause (Decl);\n-               Use_One_Type (Subtype_Mark (Decl));\n+         elsif Nkind (Decl) = N_Use_Type_Clause then\n+            Chain_Use_Clause (Decl);\n+            Use_One_Type (Subtype_Mark (Decl));\n \n-            end if;\n+         end if;\n \n-            Next (Decl);\n-         end loop;\n-      end if;\n+         Next (Decl);\n+      end loop;\n    end Set_Use;\n \n    -----------------------------"}, {"sha": "077c988aee45139b3691cc122547a05e9d35ccc8", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -18910,18 +18910,16 @@ package body Sem_Elab is\n \n       procedure Collect_Tasks (Decls : List_Id) is\n       begin\n-         if Present (Decls) then\n-            Decl := First (Decls);\n-            while Present (Decl) loop\n-               if Nkind (Decl) = N_Object_Declaration\n-                 and then Has_Task (Etype (Defining_Identifier (Decl)))\n-               then\n-                  Add_Task_Proc (Etype (Defining_Identifier (Decl)));\n-               end if;\n+         Decl := First (Decls);\n+         while Present (Decl) loop\n+            if Nkind (Decl) = N_Object_Declaration\n+              and then Has_Task (Etype (Defining_Identifier (Decl)))\n+            then\n+               Add_Task_Proc (Etype (Defining_Identifier (Decl)));\n+            end if;\n \n-               Next (Decl);\n-            end loop;\n-         end if;\n+            Next (Decl);\n+         end loop;\n       end Collect_Tasks;\n \n       ----------------"}, {"sha": "114c90460ba7108e918871b73ebc3e74314d5f13", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -7485,17 +7485,15 @@ package body Sem_Eval is\n                   return;\n                end if;\n \n-               if Present (Expressions (N)) then\n-                  Exp := First (Expressions (N));\n-                  while Present (Exp) loop\n-                     if Raises_Constraint_Error (Exp) then\n-                        Why_Not_Static (Exp);\n-                        return;\n-                     end if;\n+               Exp := First (Expressions (N));\n+               while Present (Exp) loop\n+                  if Raises_Constraint_Error (Exp) then\n+                     Why_Not_Static (Exp);\n+                     return;\n+                  end if;\n \n-                     Next (Exp);\n-                  end loop;\n-               end if;\n+                  Next (Exp);\n+               end loop;\n \n             --  Special case a subtype name\n "}, {"sha": "4d678415c5ad48351f38f669daeca1db3f320037", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -3292,27 +3292,25 @@ package body Sem_Prag is\n          --  Collect all objects that appear in the visible declarations of the\n          --  related package.\n \n-         if Present (Visible_Declarations (Pack_Spec)) then\n-            Decl := First (Visible_Declarations (Pack_Spec));\n-            while Present (Decl) loop\n-               if Comes_From_Source (Decl)\n-                 and then Nkind (Decl) in N_Object_Declaration\n-                                        | N_Object_Renaming_Declaration\n-               then\n-                  Append_New_Elmt (Defining_Entity (Decl), States_And_Objs);\n+         Decl := First (Visible_Declarations (Pack_Spec));\n+         while Present (Decl) loop\n+            if Comes_From_Source (Decl)\n+              and then Nkind (Decl) in N_Object_Declaration\n+                                     | N_Object_Renaming_Declaration\n+            then\n+               Append_New_Elmt (Defining_Entity (Decl), States_And_Objs);\n \n-               elsif Nkind (Decl) = N_Package_Declaration then\n-                  Collect_States_And_Objects (Decl);\n+            elsif Nkind (Decl) = N_Package_Declaration then\n+               Collect_States_And_Objects (Decl);\n \n-               elsif Is_Single_Concurrent_Type_Declaration (Decl) then\n-                  Append_New_Elmt\n-                    (Anonymous_Object (Defining_Entity (Decl)),\n-                     States_And_Objs);\n-               end if;\n+            elsif Is_Single_Concurrent_Type_Declaration (Decl) then\n+               Append_New_Elmt\n+                 (Anonymous_Object (Defining_Entity (Decl)),\n+                  States_And_Objs);\n+            end if;\n \n-               Next (Decl);\n-            end loop;\n-         end if;\n+            Next (Decl);\n+         end loop;\n       end Collect_States_And_Objects;\n \n       --  Local variables"}, {"sha": "9f861a2a85052b0ef28d5bc95161cfebad368bd1", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 17, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=b05a31e579ec2e46c46c4b3f36fffdf0e959bd1f", "patch": "@@ -7129,16 +7129,14 @@ package body Sem_Util is\n \n       --  Create new entities for the formal parameters\n \n-      if Present (Parameter_Specifications (Result)) then\n-         Formal_Spec := First (Parameter_Specifications (Result));\n-         while Present (Formal_Spec) loop\n-            Def_Id := Defining_Identifier (Formal_Spec);\n-            Set_Defining_Identifier (Formal_Spec,\n-              Make_Defining_Identifier (Sloc (Def_Id), Chars (Def_Id)));\n-\n-            Next (Formal_Spec);\n-         end loop;\n-      end if;\n+      Formal_Spec := First (Parameter_Specifications (Result));\n+      while Present (Formal_Spec) loop\n+         Def_Id := Defining_Identifier (Formal_Spec);\n+         Set_Defining_Identifier (Formal_Spec,\n+           Make_Defining_Identifier (Sloc (Def_Id), Chars (Def_Id)));\n+\n+         Next (Formal_Spec);\n+      end loop;\n \n       return Result;\n    end Copy_Subprogram_Spec;\n@@ -19095,13 +19093,11 @@ package body Sem_Util is\n          Nod : Node_Id;\n \n       begin\n-         if Present (List) then\n-            Nod := First (List);\n-            while Present (Nod) loop\n-               Visit (Nod);\n-               Next (Nod);\n-            end loop;\n-         end if;\n+         Nod := First (List);\n+         while Present (Nod) loop\n+            Visit (Nod);\n+            Next (Nod);\n+         end loop;\n       end Visit_List;\n \n       ------------------"}]}