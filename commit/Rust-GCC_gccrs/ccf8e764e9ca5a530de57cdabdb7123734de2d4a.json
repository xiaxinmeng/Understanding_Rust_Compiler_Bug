{"sha": "ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NmOGU3NjRlOWNhNWE1MzBkZTU3Y2RhYmRiNzEyMzczNGRlMmQ0YQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2007-03-30T21:45:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2007-03-30T21:45:03Z"}, "message": "cygming.h (DWARF2_DEBUGGING_INFO): Enable by default for 64-bit.\n\ngcc/\n\t* config/i386/cygming.h (DWARF2_DEBUGGING_INFO): Enable by\n\tdefault for 64-bit.\n\t(PREFERRED_DEBUGGING_TYPE): Prefer dwarf2 for 64-bit.\n\t(TARGET_64BIT_MS_ABI): New.\n\t(DBX_REGISTER_NUMBER): Handle 64-bit.\n\t(SIZE_TYPE, PTRDIFF_TYPE): Use long long for 64-bit.\n\t(LONG_TYPE_SIZE): Force to 32.\n\t(REG_PARM_STACK_SPACE): New.\n\t(OUTGOING_REG_PARM_STACK_SPACE): New.\n\t(REGPARM_MAX, SSE_REGPARM_MAX): New.\n\t(HANDLE_PRAGMA_PUSH_POP_MACRO): New.\n\t(STACK_BOUNDARY): Use 128 for 64-bit.\n\t* config/i386/cygwin.asm: Use push/ret to preserve call stack.\n\tAdd 64-bit implementation.\n\t* config/i386/gthr-win32.c (__gthr_win32_key_create): Mark dtor\n\targument unused.\n\t* config/i386/i386.c (x86_64_ms_abi_int_parameter_registers): New.\n\t(override_options): Set ix86_cmodel for TARGET_64BIT_MS_ABI.\n\tWarn for -mregparm, -mrtd in 64-bit mode; force ix86_regparm\n\tfor 64-bit; use TARGET_SUBTARGET64_DEFAULT.\n\t(ix86_handle_cconv_attribute): Don't warn when ignoring if\n\tTARGET_64BIT_MS_ABI.\n\t(ix86_function_arg_regno_p): Handle TARGET_64BIT_MS_ABI.\n\t(ix86_pass_by_reference): Likewise.\n\t(ix86_function_value_regno_p): Likewise.\n\t(ix86_build_builtin_va_list): Likewise.\n\t(ix86_va_start, ix86_gimplify_va_arg): Likewise.\n\t(function_arg_advance_ms_64): New.\n\t(function_arg_advance): Call it.\n\t(function_arg_ms_64): New.\n\t(function_arg): Call it.\n\t(function_value_ms_64): New.\n\t(ix86_function_value_1): Call it.\n\t(return_in_memory_ms_64): New.\n\t(ix86_return_in_memory): Call it.\n\t(setup_incoming_varargs_ms_64): New.\n\t(ix86_setup_incoming_varargs): Call it.\n\t(ix86_expand_prologue): Handle 64-bit stack probing.\n\t(legitimize_pic_address): Handle TARGET_64BIT_MS_ABI.\n\t(output_pic_addr_const): Likewise.\n\t(x86_this_parameter): Likewise.\n\t(x86_output_mi_thunk): Likewise.\n\t(x86_function_profiler): Likewise.\n\t(TARGET_STRICT_ARGUMENT_NAMING): New.\n\t* config/i386/i386.h (TARGET_SUBTARGET64_DEFAULT): New.\n\t(TARGET_64BIT_MS_ABI): New.\n\t(CONDITIONAL_REGISTER_USAGE): Handle TARGET_64BIT_MS_ABI.\n\t* config/i386/i386.md (allocate_stack_worker): Remove.\n\t(allocate_stack_worker_32): Rename from allocate_stack_worker_1;\n\tdescribe the clobber of eax without a match_scratch.\n\t(allocate_stack_worker_postreload): Remove.\n\t(allocate_stack_worker_64): Rename from allocate_stack_worker_rex64;\n\tdescribe the clobbers of rax, r10, r11 properly; use __chkstk symbol.\n\t(allocate_stack_worker_rex64_postreload): Remove.\n\t(allocate_stack): Handle 64-bit.\n\t* config/i386/i386elf (TARGET_SUBTARGET_DEFAULT): Remove.\n\t* config/i386/mingw32.h (TARGET_VERSION): Set correctly for 64-bit.\n\t(EXTRA_OS_CPP_BUILTINS): Handle 64-bit.\n\t(STANDARD_INCLUDE_DIR): Handle TARGET_64BIT_DEFAULT.\n\t(STANDARD_STARTFILE_PREFIX_1): Likewise.\n\t* config/i386/unix.h (TARGET_SUBTARGET64_DEFAULT): New.\n\t* config.build (x86_64-*-mingw*): New host.\n\t* config.host (x86_64-*-mingw*): New host.\n\t* config.gcc (x86_64-*-mingw*): New target.\n\t* gthr-win32.h (__gthread_key_create): Mark dtor unused.\nlibgcc/\n\t* config.host (x86_64-*-mingw*): New target.\n\nCo-Authored-By: Kai Tietz <kai.tietz@onevision.com>\n\nFrom-SVN: r123372", "tree": {"sha": "740f1648846b62e38649ab4639fe02ff63c22ab5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/740f1648846b62e38649ab4639fe02ff63c22ab5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/comments", "author": null, "committer": null, "parents": [{"sha": "8318b0d99afacde466752a417e0f6c544b15b644", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8318b0d99afacde466752a417e0f6c544b15b644", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8318b0d99afacde466752a417e0f6c544b15b644"}], "stats": {"total": 713, "additions": 524, "deletions": 189}, "files": [{"sha": "b048bc7532a87fa3edaa245fee2a046998be9dda", "filename": "gcc/ChangeLog", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -1,3 +1,80 @@\n+2007-03-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-ssa-loop-ivopts.c: Include target.h.\n+\t(produce_memory_decl_rtl): Pass the rtx through encode_section_info.\n+\t(get_address_cost): Force SYMBOL_FLAG_LOCAL set.\n+\t(force_expr_to_var_cost): Use produce_memory_decl_rtl.\n+\t* Makefile.in (tree-ssa-loop-ivopts.o): Depend on TARGET_H.\n+\n+2007-03-30  Richard Henderson  <rth@redhat.com>\n+\t    Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config/i386/cygming.h (DWARF2_DEBUGGING_INFO): Enable by\n+\tdefault for 64-bit.\n+\t(PREFERRED_DEBUGGING_TYPE): Prefer dwarf2 for 64-bit.\n+\t(TARGET_64BIT_MS_ABI): New.\n+\t(DBX_REGISTER_NUMBER): Handle 64-bit.\n+\t(SIZE_TYPE, PTRDIFF_TYPE): Use long long for 64-bit.\n+\t(LONG_TYPE_SIZE): Force to 32.\n+\t(REG_PARM_STACK_SPACE): New.\n+\t(OUTGOING_REG_PARM_STACK_SPACE): New.\n+\t(REGPARM_MAX, SSE_REGPARM_MAX): New.\n+\t(HANDLE_PRAGMA_PUSH_POP_MACRO): New.\n+\t(STACK_BOUNDARY): Use 128 for 64-bit.\n+\t* config/i386/cygwin.asm: Use push/ret to preserve call stack.\n+\tAdd 64-bit implementation.\n+\t* config/i386/gthr-win32.c (__gthr_win32_key_create): Mark dtor\n+\targument unused.\n+\t* config/i386/i386.c (x86_64_ms_abi_int_parameter_registers): New.\n+\t(override_options): Set ix86_cmodel for TARGET_64BIT_MS_ABI.\n+\tWarn for -mregparm, -mrtd in 64-bit mode; force ix86_regparm\n+\tfor 64-bit; use TARGET_SUBTARGET64_DEFAULT.\n+\t(ix86_handle_cconv_attribute): Don't warn when ignoring if\n+\tTARGET_64BIT_MS_ABI.\n+\t(ix86_function_arg_regno_p): Handle TARGET_64BIT_MS_ABI.\n+\t(ix86_pass_by_reference): Likewise.\n+\t(ix86_function_value_regno_p): Likewise.\n+\t(ix86_build_builtin_va_list): Likewise.\n+\t(ix86_va_start, ix86_gimplify_va_arg): Likewise.\n+\t(function_arg_advance_ms_64): New.\n+\t(function_arg_advance): Call it.\n+\t(function_arg_ms_64): New.\n+\t(function_arg): Call it.\n+\t(function_value_ms_64): New.\n+\t(ix86_function_value_1): Call it.\n+\t(return_in_memory_ms_64): New.\n+\t(ix86_return_in_memory): Call it.\n+\t(setup_incoming_varargs_ms_64): New.\n+\t(ix86_setup_incoming_varargs): Call it.\n+\t(ix86_expand_prologue): Handle 64-bit stack probing.\n+\t(legitimize_pic_address): Handle TARGET_64BIT_MS_ABI.\n+\t(output_pic_addr_const): Likewise.\n+\t(x86_this_parameter): Likewise.\n+\t(x86_output_mi_thunk): Likewise.\n+\t(x86_function_profiler): Likewise.\n+\t(TARGET_STRICT_ARGUMENT_NAMING): New.\n+\t* config/i386/i386.h (TARGET_SUBTARGET64_DEFAULT): New.\n+\t(TARGET_64BIT_MS_ABI): New.\n+\t(CONDITIONAL_REGISTER_USAGE): Handle TARGET_64BIT_MS_ABI.\n+\t* config/i386/i386.md (allocate_stack_worker): Remove.\n+\t(allocate_stack_worker_32): Rename from allocate_stack_worker_1;\n+\tdescribe the clobber of eax without a match_scratch.\n+\t(allocate_stack_worker_postreload): Remove.\n+\t(allocate_stack_worker_64): Rename from allocate_stack_worker_rex64;\n+\tdescribe the clobbers of rax, r10, r11 properly; use __chkstk symbol.\n+\t(allocate_stack_worker_rex64_postreload): Remove.\n+\t(allocate_stack): Handle 64-bit.\n+\t* config/i386/i386elf (TARGET_SUBTARGET_DEFAULT): Remove.\n+\t* config/i386/mingw32.h (TARGET_VERSION): Set correctly for 64-bit.\n+\t(EXTRA_OS_CPP_BUILTINS): Handle 64-bit.\n+\t(STANDARD_INCLUDE_DIR): Handle TARGET_64BIT_DEFAULT.\n+\t(STANDARD_STARTFILE_PREFIX_1): Likewise.\n+\t* config/i386/unix.h (TARGET_SUBTARGET64_DEFAULT): New.\n+\t* config.build (x86_64-*-mingw*): New host.\n+\t* config.host (x86_64-*-mingw*): New host.\n+\t* config.gcc (x86_64-*-mingw*): New target.\n+\t* gthr-win32.h (__gthread_key_create): Mark dtor unused.\n+\n 2007-03-30  Richard Henderson  <rth@redhat.com>\n \t    Kai Tietz  <kai.tietz@onevision.com>\n "}, {"sha": "bfc0d435d09c32284ee6e35ca12022fb24c79921", "filename": "gcc/config.build", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.build", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.build", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.build?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -77,7 +77,7 @@ case $build in\n     build_xm_file=i386/xm-cygwin.h\n     build_exeext=.exe\n     ;;\n-  i[34567]86-*-mingw32*)\n+  i[34567]86-*-mingw32* | x86_64-*-mingw*)\n     build_xm_file=i386/xm-mingw32.h\n     build_exeext=.exe\n     ;;"}, {"sha": "7cf32997eaa7731b9291a45b6c966fd0d7c1983f", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -1343,7 +1343,7 @@ i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \t\tthread_file='posix'\n \tfi\n \t;;\n-i[34567]86-*-mingw32*)\n+i[34567]86-*-mingw32* | x86_64-*-mingw32*)\n \ttm_file=\"${tm_file} i386/unix.h i386/bsd.h i386/gas.h dbxcoff.h i386/cygming.h i386/mingw32.h\"\n \txm_file=i386/xm-mingw32.h\n \ttmake_file=\"i386/t-cygming i386/t-mingw32\""}, {"sha": "150a4336496a6a92123b60001c546cd82303727a", "filename": "gcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.host?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -168,7 +168,7 @@ case ${host} in\n     host_xmake_file=\"${host_xmake_file} i386/x-cygwin\"\n     host_exeext=.exe\n     ;;\n-  i[34567]86-*-mingw32*)\n+  i[34567]86-*-mingw32* | x86_64-*-mingw*)\n     host_xm_file=i386/xm-mingw32.h\n     host_xmake_file=\"${host_xmake_file} i386/x-mingw32\"\n     host_exeext=.exe"}, {"sha": "f7e8febb16eef0227c869a0b145c1fcce102fdf4", "filename": "gcc/config/i386/cygming.h", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fcygming.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fcygming.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygming.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -21,18 +21,35 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n \n+#if TARGET_64BIT_DEFAULT\n+#ifndef DWARF2_DEBUGGING_INFO\n+#define DWARF2_DEBUGGING_INFO 1\n+#endif\n+#ifndef DWARF2_UNWIND_INFO\n+#define DWARF2_UNWIND_INFO 1\n+#endif\n+#endif\n+\n #define DBX_DEBUGGING_INFO 1\n #define SDB_DEBUGGING_INFO 1\n #undef PREFERRED_DEBUGGING_TYPE\n+#if TARGET_64BIT_DEFAULT\n+#define PREFERRED_DEBUGGING_TYPE DWARF2_DEBUG\n+#else\n #define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+#endif\n+\n+#undef TARGET_64BIT_MS_ABI\n+#define TARGET_64BIT_MS_ABI TARGET_64BIT\n \n #ifdef HAVE_GAS_PE_SECREL32_RELOC\n #define DWARF2_DEBUGGING_INFO 1\n \n #undef DBX_REGISTER_NUMBER\n-#define DBX_REGISTER_NUMBER(n) (write_symbols == DWARF2_DEBUG   \\\n-                                ? svr4_dbx_register_map[n]      \\\n-                                : dbx_register_map[n])\n+#define DBX_REGISTER_NUMBER(n)\t\t\t\t\\\n+  (TARGET_64BIT ? dbx64_register_map[n]\t\t\t\\\n+   : (write_symbols == DWARF2_DEBUG\t\t\t\\\n+      ? svr4_dbx_register_map[n] : dbx_register_map[n]))\n \n /* Use section relative relocations for debugging offsets.  Unlike\n    other targets that fake this by putting the section VMA at 0, PE\n@@ -97,14 +114,32 @@ Boston, MA 02110-1301, USA.  */\n #undef MATH_LIBRARY\n #define MATH_LIBRARY \"\"\n \n-#define SIZE_TYPE \"unsigned int\"\n-#define PTRDIFF_TYPE \"int\"\n+#define SIZE_TYPE (TARGET_64BIT ? \"long long unsigned int\" : \"unsigned int\")\n+#define PTRDIFF_TYPE (TARGET_64BIT ? \"long long int\" : \"int\")\n+\n #define WCHAR_TYPE_SIZE 16\n #define WCHAR_TYPE \"short unsigned int\"\n \n+/* Windows64 continues to use a 32-bit long type.  */\n+#undef LONG_TYPE_SIZE\n+#define LONG_TYPE_SIZE 32\n+\f\n+#undef REG_PARM_STACK_SPACE\n+#define REG_PARM_STACK_SPACE(FNDECL) (TARGET_64BIT_MS_ABI ? 32 : 0)\n+\n+#undef OUTGOING_REG_PARM_STACK_SPACE\n+#define OUTGOING_REG_PARM_STACK_SPACE (TARGET_64BIT_MS_ABI ? 1 : 0)\n+\n+#undef REGPARM_MAX\n+#define REGPARM_MAX (TARGET_64BIT_MS_ABI ? 4 : 3)\n+\n+#undef SSE_REGPARM_MAX\n+#define SSE_REGPARM_MAX (TARGET_64BIT_MS_ABI ? 4 : TARGET_SSE ? 3 : 0)\n \f\n /* Enable parsing of #pragma pack(push,<n>) and #pragma pack(pop).  */\n #define HANDLE_PRAGMA_PACK_PUSH_POP 1\n+/* Enable push_macro & pop_macro */\n+#define HANDLE_PRAGMA_PUSH_POP_MACRO 1\n \n union tree_node;\n #define TREE union tree_node *\n@@ -166,19 +201,21 @@ do {\t\t\t\t\t\t\t\\\n } while (0)\n \n \f\n-/* Emit code to check the stack when allocating more that 4000\n+/* Emit code to check the stack when allocating more than 4000\n    bytes in one go.  */\n-\n #define CHECK_STACK_LIMIT 4000\n \n+#undef STACK_BOUNDARY\n+#define STACK_BOUNDARY\t(TARGET_64BIT_MS_ABI ? 128 : BITS_PER_WORD)\n+\n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    returns float values in the 387 and needs stack probes.\n    We also align doubles to 64-bits for MSVC default compatibility.  */\n \n #undef TARGET_SUBTARGET_DEFAULT\n #define TARGET_SUBTARGET_DEFAULT \\\n-   (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS | MASK_STACK_PROBE \\\n-    | MASK_ALIGN_DOUBLE)\n+\t(MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS \\\n+\t | MASK_STACK_PROBE | MASK_ALIGN_DOUBLE)\n \n /* This is how to output an assembler line\n    that says to advance the location counter\n@@ -245,7 +282,9 @@ do {\t\t\t\t\t\t\t\\\n /* DWARF2 Unwinding doesn't work with exception handling yet.  To make\n    it work, we need to build a libgcc_s.dll, and dcrt0.o should be\n    changed to call __register_frame_info/__deregister_frame_info.  */\n+#ifndef DWARF2_UNWIND_INFO\n #define DWARF2_UNWIND_INFO 0\n+#endif\n \n /* Don't assume anything about the header files.  */\n #define NO_IMPLICIT_EXTERN_C\n@@ -346,8 +385,8 @@ do {\t\t\t\t\t\t\t\\\n #define TARGET_USE_LOCAL_THUNK_ALIAS_P(DECL) (!DECL_ONE_ONLY (DECL))\n \n #define SUBTARGET_ATTRIBUTE_TABLE \\\n-  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */ \\\n   { \"selectany\", 0, 0, true, false, false, ix86_handle_selectany_attribute }\n+  /* { name, min_len, max_len, decl_req, type_req, fn_type_req, handler } */\n \n /*  mcount() does not need a counter variable.  */\n #undef NO_PROFILE_COUNTERS"}, {"sha": "371feae8864ee4ce3dee4c75a9689320dbb6ef68", "filename": "gcc/config/i386/cygwin.asm", "status": "modified", "additions": 55, "deletions": 16, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fcygwin.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fcygwin.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fcygwin.asm?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -42,27 +42,66 @@\n \n \t.global ___chkstk\n \t.global\t__alloca\n+#ifndef _WIN64\n ___chkstk:\n __alloca:\n-\tpushl  %ecx\t\t/* save temp */\n-\tmovl   %esp,%ecx\t/* get sp */\n-\taddl   $0x8,%ecx\t/* and point to return addr */\n+\tpushl\t%ecx\t\t/* save temp */\n+\tleal\t8(%esp), %ecx\t/* point past return addr */\n+\tcmpl\t$0x1000, %eax\t/* > 4k ?*/\n+\tjb\tLdone\n \n-probe: \tcmpl   $0x1000,%eax\t/* > 4k ?*/\n-\tjb    done\t\t\n+Lprobe:\n+\tsubl\t$0x1000, %ecx  \t\t/* yes, move pointer down 4k*/\n+\torl\t$0x0, (%ecx)   \t\t/* probe there */\n+\tsubl\t$0x1000, %eax  \t \t/* decrement count */\n+\tcmpl\t$0x1000, %eax\n+\tja\tLprobe         \t \t/* and do it again */\n \n-\tsubl   $0x1000,%ecx  \t\t/* yes, move pointer down 4k*/\n-\torl    $0x0,(%ecx)   \t\t/* probe there */\n-\tsubl   $0x1000,%eax  \t \t/* decrement count */\n-\tjmp    probe           \t \t/* and do it again */\n+Ldone:\n+\tsubl\t%eax, %ecx\t   \n+\torl\t$0x0, (%ecx)\t/* less than 4k, just peek here */\n \n-done: \tsubl   %eax,%ecx\t   \n-\torl    $0x0,(%ecx)\t/* less that 4k, just peek here */\n+\tmovl\t%esp, %eax\t/* save old stack pointer */\n+\tmovl\t%ecx, %esp\t/* decrement stack */\n+\tmovl\t(%eax), %ecx\t/* recover saved temp */\n+\tmovl\t4(%eax), %eax\t/* recover return address */\n \n-\tmovl   %esp,%eax\n-\tmovl   %ecx,%esp\t/* decrement stack */\n+\t/* Push the return value back.  Doing this instead of just\n+\t   jumping to %eax preserves the cached call-return stack\n+\t   used by most modern processors.  */\n+\tpushl\t%eax\n+\tret\n+#else\n+/* __alloca is a normal function call, which uses %rcx as the argument.  */\n+__alloca:\n+\tmovq\t%rcx, %rax\n+\t/* FALLTHRU */\n+\n+/* ___chkstk is a *special* function call, which uses %rax as the argument.\n+   We avoid clobbering the 4 integer argument registers, %rcx, %rdx, \n+   %r8 and %r9, which leaves us with %rax, %r10, and %r11 to use.  */\n+___chkstk:\n+\tpopq\t%r11\t\t/* pop return address */\n+\tmovq\t%rsp, %r10\t/* get sp */\n+\tcmpq\t$0x1000, %rax\t/* > 4k ?*/\n+\tjb\tLdone\n \n-\tmovl   (%eax),%ecx\t/* recover saved temp */\n-\tmovl   4(%eax),%eax\t/* get return address */\n-\tjmp    *%eax\t\n+Lprobe:\n+\tsubq\t$0x1000, %r10  \t\t/* yes, move pointer down 4k*/\n+\torl\t$0x0, (%r10)   \t\t/* probe there */\n+\tsubq\t$0x1000, %rax  \t \t/* decrement count */\n+\tcmpq\t$0x1000, %rax\n+\tja\tLprobe         \t \t/* and do it again */\n+\n+Ldone:\n+\tsubq\t%rax, %r10\n+\torl\t$0x0, (%r10)\t/* less than 4k, just peek here */\n+\tmovq\t%r10, %rsp\t/* decrement stack */\n+\n+\t/* Push the return value back.  Doing this instead of just\n+\t   jumping to %r11 preserves the cached call-return stack\n+\t   used by most modern processors.  */\n+\tpushq\t%r11\n+\tret\n+#endif\n #endif"}, {"sha": "c87a771ed8f34684c1834eedb58a25523fb78833", "filename": "gcc/config/i386/gthr-win32.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fgthr-win32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fgthr-win32.c?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -102,7 +102,8 @@ __gthr_win32_once (__gthread_once_t *once, void (*func) (void))\n    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n \n int\n-__gthr_win32_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthr_win32_key_create (__gthread_key_t *key,\n+\t\t\t void (*dtor) (void *) __attribute__((unused)))\n {\n   int status = 0;\n   DWORD tls_index = TlsAlloc ();"}, {"sha": "7106e87eae71b82b67ea34bf42da8efac430fd95", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 240, "deletions": 71, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -1308,9 +1308,15 @@ static int const x86_64_int_parameter_registers[6] =\n   FIRST_REX_INT_REG /*R8 */, FIRST_REX_INT_REG + 1 /*R9 */\n };\n \n+static int const x86_64_ms_abi_int_parameter_registers[4] =\n+{\n+  2 /*RCX*/, 1 /*RDX*/,\n+  FIRST_REX_INT_REG /*R8 */, FIRST_REX_INT_REG + 1 /*R9 */\n+};\n+\n static int const x86_64_int_return_registers[4] =\n {\n-  0 /*RAX*/, 1 /*RDI*/, 5 /*RDI*/, 4 /*RSI*/\n+  0 /*RAX*/, 1 /*RDX*/, 5 /*RDI*/, 4 /*RSI*/\n };\n \n /* The \"default\" register map used in 64bit mode.  */\n@@ -1857,9 +1863,16 @@ override_options (void)\n     }\n   else\n     {\n-      ix86_cmodel = CM_32;\n-      if (TARGET_64BIT)\n+      /* For TARGET_64BIT_MS_ABI, force pic on, in order to enable the\n+\t use of rip-relative addressing.  This eliminates fixups that\n+\t would otherwise be needed if this object is to be placed in a\n+\t DLL, and is essentially just as efficient as direct addressing.  */\n+      if (TARGET_64BIT_MS_ABI)\n+\tix86_cmodel = CM_SMALL_PIC, flag_pic = 1;\n+      else if (TARGET_64BIT)\n \tix86_cmodel = flag_pic ? CM_SMALL_PIC : CM_SMALL;\n+      else\n+        ix86_cmodel = CM_32;\n     }\n   if (ix86_asm_string != 0)\n     {\n@@ -1981,15 +1994,16 @@ override_options (void)\n   /* Validate -mregparm= value.  */\n   if (ix86_regparm_string)\n     {\n+      if (TARGET_64BIT)\n+\twarning (0, \"-mregparm is ignored in 64-bit mode\");\n       i = atoi (ix86_regparm_string);\n       if (i < 0 || i > REGPARM_MAX)\n \terror (\"-mregparm=%d is not between 0 and %d\", i, REGPARM_MAX);\n       else\n \tix86_regparm = i;\n     }\n-  else\n-   if (TARGET_64BIT)\n-     ix86_regparm = REGPARM_MAX;\n+  if (TARGET_64BIT)\n+    ix86_regparm = REGPARM_MAX;\n \n   /* If the user has provided any of the -malign-* options,\n      warn and use that value only if -falign-* is not set.\n@@ -2135,18 +2149,16 @@ override_options (void)\n \n   if (TARGET_64BIT)\n     {\n-      if (TARGET_ALIGN_DOUBLE)\n-\terror (\"-malign-double makes no sense in the 64bit mode\");\n       if (TARGET_RTD)\n-\terror (\"-mrtd calling convention not supported in the 64bit mode\");\n+\twarning (0, \"-mrtd is ignored in 64bit mode\");\n \n       /* Enable by default the SSE and MMX builtins.  Do allow the user to\n \t explicitly disable any of these.  In particular, disabling SSE and\n \t MMX for kernel code is extremely useful.  */\n       target_flags\n-\t|= ((MASK_SSE2 | MASK_SSE | MASK_MMX | MASK_128BIT_LONG_DOUBLE)\n+\t|= ((MASK_SSE2 | MASK_SSE | MASK_MMX | TARGET_SUBTARGET64_DEFAULT)\n \t    & ~target_flags_explicit);\n-     }\n+    }\n   else\n     {\n       /* i386 ABI does not specify red zone.  It still makes sense to use it\n@@ -2644,8 +2656,10 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \n   if (TARGET_64BIT)\n     {\n-      warning (OPT_Wattributes, \"%qs attribute ignored\",\n-\t       IDENTIFIER_POINTER (name));\n+      /* Do not warn when emulating the MS ABI.  */\n+      if (!TARGET_64BIT_MS_ABI)\n+\twarning (OPT_Wattributes, \"%qs attribute ignored\",\n+\t         IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -2932,6 +2946,7 @@ bool\n ix86_function_arg_regno_p (int regno)\n {\n   int i;\n+  const int *parm_regs;\n \n   if (!TARGET_64BIT)\n     {\n@@ -2959,11 +2974,15 @@ ix86_function_arg_regno_p (int regno)\n     }\n \n   /* RAX is used as hidden argument to va_arg functions.  */\n-  if (regno == 0)\n+  if (!TARGET_64BIT_MS_ABI && regno == 0)\n     return true;\n \n+  if (TARGET_64BIT_MS_ABI)\n+    parm_regs = x86_64_ms_abi_int_parameter_registers;\n+  else\n+    parm_regs = x86_64_int_parameter_registers;\n   for (i = 0; i < REGPARM_MAX; i++)\n-    if (regno == x86_64_int_parameter_registers[i])\n+    if (regno == parm_regs[i])\n       return true;\n   return false;\n }\n@@ -3741,6 +3760,21 @@ function_arg_advance_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n     cum->words += words;\n }\n \n+static void\n+function_arg_advance_ms_64 (CUMULATIVE_ARGS *cum, HOST_WIDE_INT bytes,\n+\t\t\t    HOST_WIDE_INT words)\n+{\n+  /* Otherwise, this should be passed indirect.  */\n+  gcc_assert (bytes == 1 || bytes == 2 || bytes == 4 || bytes == 8);\n+\n+  cum->words += words;\n+  if (cum->nregs > 0)\n+    {\n+      cum->nregs -= 1;\n+      cum->regno += 1;\n+    }\n+}\n+\n void\n function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t      tree type, int named ATTRIBUTE_UNUSED)\n@@ -3756,7 +3790,9 @@ function_arg_advance (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (type)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_MS_ABI)\n+    function_arg_advance_ms_64 (cum, bytes, words);\n+  else if (TARGET_64BIT)\n     function_arg_advance_64 (cum, mode, type, words);\n   else\n     function_arg_advance_32 (cum, mode, type, bytes, words);\n@@ -3887,9 +3923,47 @@ function_arg_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t      cum->sse_regno);\n }\n \n+static rtx\n+function_arg_ms_64 (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n+\t\t    enum machine_mode orig_mode, int named)\n+{\n+  unsigned int regno;\n+\n+  /* Avoid the AL settings for the Unix64 ABI.  */\n+  if (mode == VOIDmode)\n+    return constm1_rtx;\n+\n+  /* If we've run out of registers, it goes on the stack.  */\n+  if (cum->nregs == 0)\n+    return NULL_RTX;\n+\n+  regno = x86_64_ms_abi_int_parameter_registers[cum->regno];\n+\n+  /* Only floating point modes are passed in anything but integer regs.  */\n+  if (TARGET_SSE && (mode == SFmode || mode == DFmode))\n+    {\n+      if (named)\n+\tregno = cum->regno + FIRST_SSE_REG;\n+      else\n+\t{\n+\t  rtx t1, t2;\n+\n+\t  /* Unnamed floating parameters are passed in both the\n+\t     SSE and integer registers.  */\n+\t  t1 = gen_rtx_REG (mode, cum->regno + FIRST_SSE_REG);\n+\t  t2 = gen_rtx_REG (mode, regno);\n+\t  t1 = gen_rtx_EXPR_LIST (VOIDmode, t1, const0_rtx);\n+\t  t2 = gen_rtx_EXPR_LIST (VOIDmode, t2, const0_rtx);\n+\t  return gen_rtx_PARALLEL (mode, gen_rtvec (2, t1, t2));\n+\t}\n+    }\n+\n+  return gen_reg_or_parallel (mode, orig_mode, regno);\n+}\n+\n rtx\n function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n-\t      tree type, int named ATTRIBUTE_UNUSED)\n+\t      tree type, int named)\n {\n   enum machine_mode mode = omode;\n   HOST_WIDE_INT bytes, words;\n@@ -3905,7 +3979,9 @@ function_arg (CUMULATIVE_ARGS *cum, enum machine_mode omode,\n   if (type && TREE_CODE (type) == VECTOR_TYPE)\n     mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_MS_ABI)\n+    return function_arg_ms_64 (cum, mode, omode, named);\n+  else if (TARGET_64BIT)\n     return function_arg_64 (cum, mode, omode, type);\n   else\n     return function_arg_32 (cum, mode, omode, type, bytes, words);\n@@ -3922,7 +3998,30 @@ ix86_pass_by_reference (CUMULATIVE_ARGS *cum ATTRIBUTE_UNUSED,\n \t\t\tenum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\ttree type, bool named ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)\n+  if (TARGET_64BIT_MS_ABI)\n+    {\n+      if (type)\n+\t{\n+\t  /* Arrays are passed by reference.  */\n+\t  if (TREE_CODE (type) == ARRAY_TYPE)\n+\t    return true;\n+\n+\t  if (AGGREGATE_TYPE_P (type))\n+\t    {\n+\t      /* Structs/unions of sizes other than 8, 16, 32, or 64 bits\n+\t         are passed by reference.  */\n+\t      int el2 = exact_log2 (int_size_in_bytes (type));\n+\t      return !(el2 >= 0 && el2 <= 3);\n+\t    }\n+\t}\n+\n+      /* __m128 is passed by reference.  */\n+      /* ??? How to handle complex?  For now treat them as structs,\n+\t and pass them by reference if they're too large.  */\n+      if (GET_MODE_SIZE (mode) > 8)\n+\treturn true;\n+    }\n+  else if (TARGET_64BIT && type && int_size_in_bytes (type) == -1)\n     return 1;\n \n   return 0;\n@@ -4025,6 +4124,8 @@ ix86_function_value_regno_p (int regno)\n       return true;\n \n     case FIRST_FLOAT_REG:\n+      if (TARGET_64BIT_MS_ABI)\n+\treturn false;\n       return TARGET_FLOAT_RETURNS_IN_80387;\n \n     case FIRST_SSE_REG:\n@@ -4131,6 +4232,22 @@ function_value_64 (enum machine_mode orig_mode, enum machine_mode mode,\n   return ret;\n }\n \n+static rtx\n+function_value_ms_64 (enum machine_mode orig_mode, enum machine_mode mode)\n+{\n+  unsigned int regno = 0;\n+\n+  if (TARGET_SSE)\n+    {\n+      if (mode == SFmode || mode == DFmode)\n+\tregno = FIRST_SSE_REG;\n+      else if (VECTOR_MODE_P (mode) || GET_MODE_SIZE (mode) == 16)\n+\tregno = FIRST_SSE_REG;\n+    }\n+\n+  return gen_rtx_REG (orig_mode, regno);\n+}\n+\n static rtx\n ix86_function_value_1 (tree valtype, tree fntype_or_decl,\n \t\t       enum machine_mode orig_mode, enum machine_mode mode)\n@@ -4142,7 +4259,9 @@ ix86_function_value_1 (tree valtype, tree fntype_or_decl,\n     fn = fntype_or_decl;\n   fntype = fn ? TREE_TYPE (fn) : fntype_or_decl;\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_MS_ABI)\n+    return function_value_ms_64 (orig_mode, mode);\n+  else if (TARGET_64BIT)\n     return function_value_64 (orig_mode, mode, valtype);\n   else\n     return function_value_32 (orig_mode, mode, fntype, fn);\n@@ -4214,12 +4333,27 @@ return_in_memory_64 (tree type, enum machine_mode mode)\n   return !examine_argument (mode, type, 1, &needed_intregs, &needed_sseregs);\n }\n \n+static int\n+return_in_memory_ms_64 (tree type, enum machine_mode mode)\n+{\n+  HOST_WIDE_INT size = int_size_in_bytes (type);\n+\n+  /* __m128 and friends are returned in xmm0.  */\n+  if (size == 16 && VECTOR_MODE_P (mode))\n+    return 0;\n+\n+  /* Otherwise, the size must be exactly in [1248].  */\n+  return (size != 1 && size != 2 && size != 4 && size != 8);\n+}\n+\n int\n ix86_return_in_memory (tree type)\n {\n   enum machine_mode mode = type_natural_mode (type);\n \n-  if (TARGET_64BIT)\n+  if (TARGET_64BIT_MS_ABI)\n+    return return_in_memory_ms_64 (type, mode);\n+  else if (TARGET_64BIT)\n     return return_in_memory_64 (type, mode);\n   else\n     return return_in_memory_32 (type, mode);\n@@ -4280,7 +4414,7 @@ ix86_build_builtin_va_list (void)\n   tree f_gpr, f_fpr, f_ovf, f_sav, record, type_decl;\n \n   /* For i386 we use plain pointer to argument area.  */\n-  if (!TARGET_64BIT)\n+  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n     return build_pointer_type (char_type_node);\n \n   record = (*lang_hooks.types.make_type) (RECORD_TYPE);\n@@ -4399,6 +4533,27 @@ setup_incoming_varargs_64 (CUMULATIVE_ARGS *cum)\n     }\n }\n \n+static void\n+setup_incoming_varargs_ms_64 (CUMULATIVE_ARGS *cum)\n+{\n+  int set = get_varargs_alias_set ();\n+  int i;\n+\n+  for (i = cum->regno; i < REGPARM_MAX; i++)\n+    {\n+      rtx reg, mem;\n+\n+      mem = gen_rtx_MEM (Pmode,\n+\t\t\t plus_constant (virtual_incoming_args_rtx,\n+\t\t\t\t\ti * UNITS_PER_WORD));\n+      MEM_NOTRAP_P (mem) = 1;\n+      set_mem_alias_set (mem, set);\n+\n+      reg = gen_rtx_REG (Pmode, x86_64_ms_abi_int_parameter_registers[i]);\n+      emit_move_insn (mem, reg);\n+    }\n+}\n+\n static void\n ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n \t\t\t     tree type, int *pretend_size ATTRIBUTE_UNUSED,\n@@ -4426,7 +4581,10 @@ ix86_setup_incoming_varargs (CUMULATIVE_ARGS *cum, enum machine_mode mode,\n   if (stdarg_p)\n     function_arg_advance (&next_cum, mode, type, 1);\n \n-  setup_incoming_varargs_64 (&next_cum);\n+  if (TARGET_64BIT_MS_ABI)\n+    setup_incoming_varargs_ms_64 (&next_cum);\n+  else\n+    setup_incoming_varargs_64 (&next_cum);\n }\n \n /* Implement va_start.  */\n@@ -4440,7 +4598,7 @@ ix86_va_start (tree valist, rtx nextarg)\n   tree type;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT)\n+  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n     {\n       std_expand_builtin_va_start (valist, nextarg);\n       return;\n@@ -4519,7 +4677,7 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   enum machine_mode nat_mode;\n \n   /* Only 64bit target needs something special.  */\n-  if (!TARGET_64BIT)\n+  if (!TARGET_64BIT || TARGET_64BIT_MS_ABI)\n     return std_gimplify_va_arg_expr (valist, type, pre_p, post_p);\n \n   f_gpr = TYPE_FIELDS (TREE_TYPE (va_list_type_node));\n@@ -5711,21 +5869,30 @@ ix86_expand_prologue (void)\n   else\n     {\n       /* Only valid for Win32.  */\n-      rtx eax = gen_rtx_REG (SImode, 0);\n-      bool eax_live = ix86_eax_live_at_start_p ();\n+      rtx eax = gen_rtx_REG (Pmode, 0);\n+      bool eax_live;\n       rtx t;\n \n-      gcc_assert (!TARGET_64BIT);\n+      gcc_assert (!TARGET_64BIT || TARGET_64BIT_MS_ABI);\n+\n+      if (TARGET_64BIT_MS_ABI)\n+\teax_live = false;\n+      else\n+\teax_live = ix86_eax_live_at_start_p ();\n \n       if (eax_live)\n \t{\n \t  emit_insn (gen_push (eax));\n-\t  allocate -= 4;\n+\t  allocate -= UNITS_PER_WORD;\n \t}\n \n       emit_move_insn (eax, GEN_INT (allocate));\n \n-      insn = emit_insn (gen_allocate_stack_worker (eax));\n+      if (TARGET_64BIT)\n+\tinsn = gen_allocate_stack_worker_64 (eax);\n+      else\n+\tinsn = gen_allocate_stack_worker_32 (eax);\n+      insn = emit_insn (insn);\n       RTX_FRAME_RELATED_P (insn) = 1;\n       t = gen_rtx_PLUS (Pmode, stack_pointer_rtx, GEN_INT (-allocate));\n       t = gen_rtx_SET (VOIDmode, stack_pointer_rtx, t);\n@@ -5741,7 +5908,7 @@ ix86_expand_prologue (void)\n \t\t\t       - frame.nregs * UNITS_PER_WORD);\n \t  else\n \t    t = plus_constant (stack_pointer_rtx, allocate);\n-\t  emit_move_insn (eax, gen_rtx_MEM (SImode, t));\n+\t  emit_move_insn (eax, gen_rtx_MEM (Pmode, t));\n \t}\n     }\n \n@@ -5995,7 +6162,7 @@ ix86_expand_epilogue (int style)\n \t{\n \t  rtx ecx = gen_rtx_REG (SImode, 2);\n \n-\t  /* There is no \"pascal\" calling convention in 64bit ABI.  */\n+\t  /* There is no \"pascal\" calling convention in any 64bit ABI.  */\n \t  gcc_assert (!TARGET_64BIT);\n \n \t  emit_insn (gen_popsi1 (ecx));\n@@ -6848,7 +7015,8 @@ legitimize_pic_address (rtx orig, rtx reg)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n \t  {\n-            new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (addr, 0)), UNSPEC_GOTOFF);\n+            new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (addr, 0)),\n+\t\t\t\t  UNSPEC_GOTOFF);\n \t    new = gen_rtx_PLUS (Pmode, new, XEXP (addr, 1));\n \t  }\n \telse\n@@ -6879,7 +7047,8 @@ legitimize_pic_address (rtx orig, rtx reg)\n \taddr = XEXP (addr, 0);\n       if (GET_CODE (addr) == PLUS)\n \t  {\n-            new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (addr, 0)), UNSPEC_GOTOFF);\n+            new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, XEXP (addr, 0)),\n+\t\t\t\t  UNSPEC_GOTOFF);\n \t    new = gen_rtx_PLUS (Pmode, new, XEXP (addr, 1));\n \t  }\n \telse\n@@ -6898,6 +7067,11 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t      see gotoff_operand.  */\n \t   || (TARGET_VXWORKS_RTP && GET_CODE (addr) == LABEL_REF))\n     {\n+      /* Given that we've already handled dllimport variables separately\n+\t in legitimize_address, and all other variables should satisfy\n+\t legitimate_pic_address_disp_p, we should never arrive here.  */\n+      gcc_assert (!TARGET_64BIT_MS_ABI);\n+\n       if (TARGET_64BIT && ix86_cmodel != CM_LARGE_PIC)\n \t{\n \t  new = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, addr), UNSPEC_GOTPCREL);\n@@ -7505,7 +7679,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n \t{\n \t  const char *name = XSTR (x, 0);\n \n-\t  /* Mark the decl as referenced so that cgraph will output the function.  */\n+\t  /* Mark the decl as referenced so that cgraph will\n+\t     output the function.  */\n \t  if (SYMBOL_REF_DECL (x))\n \t    mark_decl_referenced (SYMBOL_REF_DECL (x));\n \n@@ -7516,7 +7691,8 @@ output_pic_addr_const (FILE *file, rtx x, int code)\n #endif\n \t  assemble_name (file, name);\n \t}\n-      if (!TARGET_MACHO && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n+      if (!TARGET_MACHO && !TARGET_64BIT_MS_ABI\n+\t  && code == 'P' && ! SYMBOL_REF_LOCAL_P (x))\n \tfputs (\"@PLT\", file);\n       break;\n \n@@ -9291,7 +9467,6 @@ ix86_expand_clear (rtx dest)\n   /* Avoid HImode and its attendant prefix byte.  */\n   if (GET_MODE_SIZE (GET_MODE (dest)) < 4)\n     dest = gen_rtx_REG (SImode, REGNO (dest));\n-\n   tmp = gen_rtx_SET (VOIDmode, dest, const0_rtx);\n \n   /* This predicate should match that for movsi_xor and movdi_xor_rex64.  */\n@@ -19508,37 +19683,29 @@ static rtx\n x86_this_parameter (tree function)\n {\n   tree type = TREE_TYPE (function);\n+  bool aggr = aggregate_value_p (TREE_TYPE (type), type) != 0;\n \n   if (TARGET_64BIT)\n     {\n-      int n = aggregate_value_p (TREE_TYPE (type), type) != 0;\n-      return gen_rtx_REG (DImode, x86_64_int_parameter_registers[n]);\n+      const int *parm_regs;\n+\n+      if (TARGET_64BIT_MS_ABI)\n+        parm_regs = x86_64_ms_abi_int_parameter_registers;\n+      else\n+        parm_regs = x86_64_int_parameter_registers;\n+      return gen_rtx_REG (DImode, parm_regs[aggr]);\n     }\n \n-  if (ix86_function_regparm (type, function) > 0)\n+  if (ix86_function_regparm (type, function) > 0\n+      && !type_has_variadic_args_p (type))\n     {\n-      tree parm;\n-\n-      parm = TYPE_ARG_TYPES (type);\n-      /* Figure out whether or not the function has a variable number of\n-\t arguments.  */\n-      for (; parm; parm = TREE_CHAIN (parm))\n-\tif (TREE_VALUE (parm) == void_type_node)\n-\t  break;\n-      /* If not, the this parameter is in the first argument.  */\n-      if (parm)\n-\t{\n-\t  int regno = 0;\n-\t  if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n-\t    regno = 2;\n-\t  return gen_rtx_REG (SImode, regno);\n-\t}\n+      int regno = 0;\n+      if (lookup_attribute (\"fastcall\", TYPE_ATTRIBUTES (type)))\n+\tregno = 2;\n+      return gen_rtx_REG (SImode, regno);\n     }\n \n-  if (aggregate_value_p (TREE_TYPE (type), type))\n-    return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 8));\n-  else\n-    return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, 4));\n+  return gen_rtx_MEM (SImode, plus_constant (stack_pointer_rtx, aggr ? 8 : 4));\n }\n \n /* Determine whether x86_output_mi_thunk can succeed.  */\n@@ -19627,7 +19794,7 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n \t{\n \t  int tmp_regno = 2 /* ECX */;\n \t  if (lookup_attribute (\"fastcall\",\n-\t      TYPE_ATTRIBUTES (TREE_TYPE (function))))\n+\t\t\t\tTYPE_ATTRIBUTES (TREE_TYPE (function))))\n \t    tmp_regno = 0 /* EAX */;\n \t  tmp = gen_rtx_REG (SImode, tmp_regno);\n \t}\n@@ -19669,6 +19836,10 @@ x86_output_mi_thunk (FILE *file ATTRIBUTE_UNUSED,\n     {\n       if (!flag_pic || (*targetm.binds_local_p) (function))\n \toutput_asm_insn (\"jmp\\t%P0\", xops);\n+      /* All thunks should be in the same object as their target,\n+\t and thus binds_local_p should be true.  */\n+      else if (TARGET_64BIT_MS_ABI)\n+\tgcc_unreachable ();\n       else\n \t{\n \t  tmp = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, xops[0]), UNSPEC_GOTPCREL);\n@@ -19745,20 +19916,16 @@ void\n x86_function_profiler (FILE *file, int labelno ATTRIBUTE_UNUSED)\n {\n   if (TARGET_64BIT)\n-    if (flag_pic)\n-      {\n+    {\n #ifndef NO_PROFILE_COUNTERS\n-\tfprintf (file, \"\\tleaq\\t%sP%d@(%%rip),%%r11\\n\", LPREFIX, labelno);\n+      fprintf (file, \"\\tleaq\\t%sP%d@(%%rip),%%r11\\n\", LPREFIX, labelno);\n #endif\n+\n+      if (!TARGET_64BIT_MS_ABI && flag_pic)\n \tfprintf (file, \"\\tcall\\t*%s@GOTPCREL(%%rip)\\n\", MCOUNT_NAME);\n-      }\n-    else\n-      {\n-#ifndef NO_PROFILE_COUNTERS\n-\tfprintf (file, \"\\tmovq\\t$%sP%d,%%r11\\n\", LPREFIX, labelno);\n-#endif\n+      else\n \tfprintf (file, \"\\tcall\\t%s\\n\", MCOUNT_NAME);\n-      }\n+    }\n   else if (flag_pic)\n     {\n #ifndef NO_PROFILE_COUNTERS\n@@ -21817,6 +21984,8 @@ static const struct attribute_spec ix86_attribute_table[] =\n #define TARGET_INTERNAL_ARG_POINTER ix86_internal_arg_pointer\n #undef TARGET_DWARF_HANDLE_FRAME_UNSPEC\n #define TARGET_DWARF_HANDLE_FRAME_UNSPEC ix86_dwarf_handle_frame_unspec\n+#undef TARGET_STRICT_ARGUMENT_NAMING\n+#define TARGET_STRICT_ARGUMENT_NAMING hook_bool_CUMULATIVE_ARGS_true\n \n #undef TARGET_GIMPLIFY_VA_ARG_EXPR\n #define TARGET_GIMPLIFY_VA_ARG_EXPR ix86_gimplify_va_arg"}, {"sha": "e86bb7273fe9fe8d42b45a10be02da55e21bfdfe", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -20,6 +20,21 @@ along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n \n+/* The purpose of this file is to define the characteristics of the i386,\n+   independent of assembler syntax or operating system.\n+\n+   Three other files build on this one to describe a specific assembler syntax:\n+   bsd386.h, att386.h, and sun386.h.\n+\n+   The actual tm.h file for a particular system should include\n+   this file, and then the file for the appropriate assembler syntax.\n+\n+   Many macros that specify assembler syntax are omitted entirely from\n+   this file because they really belong in the files for particular\n+   assemblers.  These include RP, IP, LPREFIX, PUT_OP_SIZE, USE_STAR,\n+   ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE, PRINT_B_I_S, and many\n+   that start with ASM_ or end in ASM_OP.  */\n+\n #include \"config/vxworks-dummy.h\"\n \n /* Algorithm to expand string function with.  */\n@@ -34,7 +49,9 @@ enum stringop_alg\n    loop,\n    unrolled_loop\n };\n+\n #define NAX_STRINGOP_ALGS 4\n+\n /* Specify what algorithm to use for stringops on known size.\n    When size is unknown, the UNKNOWN_SIZE alg is used.  When size is\n    known at compile time or estimated via feedback, the SIZE array\n@@ -43,8 +60,7 @@ enum stringop_alg\n    For example initializer:\n     {{256, loop}, {-1, rep_prefix_4_byte}}\t\t\n    will use loop for blocks smaller or equal to 256 bytes, rep prefix will\n-   be used otherwise.\n-*/\n+   be used otherwise.  */\n struct stringop_algs\n {\n   const enum stringop_alg unknown_size;\n@@ -54,21 +70,6 @@ struct stringop_algs\n   } size [NAX_STRINGOP_ALGS];\n };\n \n-/* The purpose of this file is to define the characteristics of the i386,\n-   independent of assembler syntax or operating system.\n-\n-   Three other files build on this one to describe a specific assembler syntax:\n-   bsd386.h, att386.h, and sun386.h.\n-\n-   The actual tm.h file for a particular system should include\n-   this file, and then the file for the appropriate assembler syntax.\n-\n-   Many macros that specify assembler syntax are omitted entirely from\n-   this file because they really belong in the files for particular\n-   assemblers.  These include RP, IP, LPREFIX, PUT_OP_SIZE, USE_STAR,\n-   ADDR_BEG, ADDR_END, PRINT_IREG, PRINT_SCALE, PRINT_B_I_S, and many\n-   that start with ASM_ or end in ASM_OP.  */\n-\n /* Define the specific costs for a given cpu */\n \n struct processor_costs {\n@@ -372,11 +373,17 @@ extern int x86_prefetch_sse;\n    the frame pointer in leaf functions.  */\n #define TARGET_DEFAULT 0\n \n+/* Extra bits to force on w/ 64-bit mode.  */\n+#define TARGET_SUBTARGET64_DEFAULT 0\n+\n /* This is not really a target flag, but is done this way so that\n    it's analogous to similar code for Mach-O on PowerPC.  darwin.h\n    redefines this to 1.  */\n #define TARGET_MACHO 0\n \n+/* Likewise, for the Windows 64-bit ABI.  */\n+#define TARGET_64BIT_MS_ABI 0\n+\n /* Subtargets may reset this to 1 in order to enable 96-bit long double\n    with the rounding mode forced to 53 bits.  */\n #define TARGET_96_ROUND_53_LONG_DOUBLE 0\n@@ -998,6 +1005,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n \tfor (i = FIRST_REX_SSE_REG; i <= LAST_REX_SSE_REG; i++)\t\t\\\n \t  reg_names[i] = \"\";\t\t\t\t\t\t\\\n       }\t\t\t\t\t\t\t\t\t\\\n+    if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+        call_used_regs[4 /*RSI*/] = 0;                                  \\\n+        call_used_regs[5 /*RDI*/] = 0;                                  \\\n+      }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* Return number of consecutive hard regs needed starting at reg REGNO"}, {"sha": "2fc4f5f1072efcac8dd99308f10f55323f93eefb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 32, "deletions": 62, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -19611,86 +19611,56 @@\n   [(set_attr \"type\" \"alu,lea\")\n    (set_attr \"mode\" \"DI\")])\n \n-(define_expand \"allocate_stack_worker\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")]\n-  \"TARGET_STACK_PROBE\"\n-{\n-  if (reload_completed)\n-    {\n-      if (TARGET_64BIT)\n-\temit_insn (gen_allocate_stack_worker_rex64_postreload (operands[0]));\n-      else\n-\temit_insn (gen_allocate_stack_worker_postreload (operands[0]));\n-    }\n-  else\n-    {\n-      if (TARGET_64BIT)\n-\temit_insn (gen_allocate_stack_worker_rex64 (operands[0]));\n-      else\n-\temit_insn (gen_allocate_stack_worker_1 (operands[0]));\n-    }\n-  DONE;\n-})\n-\n-(define_insn \"allocate_stack_worker_1\"\n-  [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"a\")]\n-    UNSPECV_STACK_PROBE)\n+(define_insn \"allocate_stack_worker_32\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"+a\")\n+\t(unspec_volatile:SI [(match_dup 0)] UNSPECV_STACK_PROBE))\n    (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))\n-   (clobber (match_scratch:SI 1 \"=0\"))\n    (clobber (reg:CC FLAGS_REG))]\n   \"!TARGET_64BIT && TARGET_STACK_PROBE\"\n   \"call\\t__alloca\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \n-(define_expand \"allocate_stack_worker_postreload\"\n-  [(parallel [(unspec_volatile:SI [(match_operand:SI 0 \"register_operand\" \"a\")]\n-\t\t\t\t    UNSPECV_STACK_PROBE)\n-\t      (set (reg:SI SP_REG) (minus:SI (reg:SI SP_REG) (match_dup 0)))\n-\t      (clobber (match_dup 0))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  \"\")\n-\n-(define_insn \"allocate_stack_worker_rex64\"\n-  [(unspec_volatile:DI [(match_operand:DI 0 \"register_operand\" \"a\")]\n-    UNSPECV_STACK_PROBE)\n+(define_insn \"allocate_stack_worker_64\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n+\t(unspec_volatile:DI [(match_dup 0)] UNSPECV_STACK_PROBE))\n    (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))\n-   (clobber (match_scratch:DI 1 \"=0\"))\n+   (clobber (reg:DI R10_REG))\n+   (clobber (reg:DI R11_REG))\n    (clobber (reg:CC FLAGS_REG))]\n   \"TARGET_64BIT && TARGET_STACK_PROBE\"\n-  \"call\\t__alloca\"\n+  \"call\\t___chkstk\"\n   [(set_attr \"type\" \"multi\")\n    (set_attr \"length\" \"5\")])\n \n-(define_expand \"allocate_stack_worker_rex64_postreload\"\n-  [(parallel [(unspec_volatile:DI [(match_operand:DI 0 \"register_operand\" \"a\")]\n-\t\t\t\t    UNSPECV_STACK_PROBE)\n-\t      (set (reg:DI SP_REG) (minus:DI (reg:DI SP_REG) (match_dup 0)))\n-\t      (clobber (match_dup 0))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n-  \"\"\n-  \"\")\n-\n (define_expand \"allocate_stack\"\n-  [(parallel [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t\t   (minus:SI (reg:SI SP_REG)\n-\t\t\t     (match_operand:SI 1 \"general_operand\" \"\")))\n-\t      (clobber (reg:CC FLAGS_REG))])\n-   (parallel [(set (reg:SI SP_REG)\n-\t\t   (minus:SI (reg:SI SP_REG) (match_dup 1)))\n-\t      (clobber (reg:CC FLAGS_REG))])]\n+  [(match_operand 0 \"register_operand\" \"\")\n+   (match_operand 1 \"general_operand\" \"\")]\n   \"TARGET_STACK_PROBE\"\n {\n-#ifdef CHECK_STACK_LIMIT\n-  if (CONST_INT_P (operands[1])\n+  rtx x;\n+\n+#ifndef CHECK_STACK_LIMIT\n+#define CHECK_STACK_LIMIT 0\n+#endif\n+\n+  if (CHECK_STACK_LIMIT && CONST_INT_P (operands[1])\n       && INTVAL (operands[1]) < CHECK_STACK_LIMIT)\n-    emit_insn (gen_subsi3 (stack_pointer_rtx, stack_pointer_rtx,\n-\t\t\t   operands[1]));\n+    {\n+      x = expand_simple_binop (Pmode, MINUS, stack_pointer_rtx, operands[1],\n+\t\t\t       stack_pointer_rtx, 0, OPTAB_DIRECT);\n+      if (x != stack_pointer_rtx)\n+\temit_move_insn (stack_pointer_rtx, x);\n+    }\n   else\n-#endif\n-    emit_insn (gen_allocate_stack_worker (copy_to_mode_reg (SImode,\n-\t\t\t\t\t\t\t    operands[1])));\n+    {\n+      x = copy_to_mode_reg (Pmode, operands[1]);\n+      if (TARGET_64BIT)\n+\tx = gen_allocate_stack_worker_64 (x);\n+      else\n+\tx = gen_allocate_stack_worker_32 (x);\n+      emit_insn (x);\n+    }\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n   DONE;"}, {"sha": "15078cc19c4c13ec757098dd2a5603302abbe83d", "filename": "gcc/config/i386/i386elf.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fi386elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386elf.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -27,11 +27,6 @@ Boston, MA 02110-1301, USA.  */\n \n #define TARGET_VERSION fprintf (stderr, \" (i386 bare ELF target)\");\n \n-/* By default, target has a 80387, uses IEEE compatible arithmetic,\n-   and returns float values in the 387.  */\n-\n-#define TARGET_SUBTARGET_DEFAULT (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS)\n-\n /* The ELF ABI for the i386 says that records and unions are returned\n    in memory.  */\n "}, {"sha": "c608826be11a48eb804c1757ad071eaf88fd6fad", "filename": "gcc/config/i386/mingw32.h", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fmingw32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Fmingw32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fmingw32.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -21,7 +21,11 @@ the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n Boston, MA 02110-1301, USA.  */\n \n #undef TARGET_VERSION\n-#define TARGET_VERSION fprintf (stderr, \" (x86 MinGW)\"); \n+#if TARGET_64BIT_DEFAULT\n+#define TARGET_VERSION fprintf (stderr,\"(x86_64 MinGW\");\n+#else\n+#define TARGET_VERSION fprintf (stderr,\" (x86 MinGW)\");\n+#endif\n \n /* See i386/crtdll.h for an alternative definition.  */\n #define EXTRA_OS_CPP_BUILTINS()\t\t\t\t\t\\\n@@ -32,13 +36,28 @@ Boston, MA 02110-1301, USA.  */\n       builtin_define (\"_WIN32\");\t\t\t\t\\\n       builtin_define_std (\"WIN32\");\t\t\t\t\\\n       builtin_define_std (\"WINNT\");\t\t\t\t\\\n+      if (TARGET_64BIT_MS_ABI)\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  builtin_define (\"__MINGW64__\");\t\t\t\\\n+\t  builtin_define_with_value(\"_INTEGRAL_MAX_BITS\",\"64\",0); \\\n+\t  builtin_define_std (\"WIN64\");\t\t\t\t\\\n+\t  builtin_define_std (\"_WIN64\");\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  builtin_define_with_value(\"_INTEGRAL_MAX_BITS\",\"32\",0); \\\n+\t}\t\t\t\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   while (0)\n \n /* Override the standard choice of /usr/include as the default prefix\n    to try when searching for header files.  */\n #undef STANDARD_INCLUDE_DIR\n+#if TARGET_64BIT_DEFAULT\n+#define STANDARD_INCLUDE_DIR \"/mingw/include64\"\n+#else\n #define STANDARD_INCLUDE_DIR \"/mingw/include\"\n+#endif\n #undef STANDARD_INCLUDE_COMPONENT\n #define STANDARD_INCLUDE_COMPONENT \"MINGW\"\n \n@@ -71,8 +90,12 @@ Boston, MA 02110-1301, USA.  */\n \n /* Override startfile prefix defaults.  */\n #ifndef STANDARD_STARTFILE_PREFIX_1\n+#if TARGET_64BIT_DEFAULT\n+#define STANDARD_STARTFILE_PREFIX_1 \"/mingw/lib64/\"\n+#else\n #define STANDARD_STARTFILE_PREFIX_1 \"/mingw/lib/\"\n #endif\n+#endif\n #ifndef STANDARD_STARTFILE_PREFIX_2\n #define STANDARD_STARTFILE_PREFIX_2 \"\"\n #endif"}, {"sha": "d27fd1c085bd5181128f0731ba1d290c55fea403", "filename": "gcc/config/i386/unix.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Funix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fconfig%2Fi386%2Funix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Funix.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -61,5 +61,10 @@ Boston, MA 02110-1301, USA.  */\n \n /* By default, target has a 80387, uses IEEE compatible arithmetic,\n    and returns float values in the 387.  */\n+#define TARGET_SUBTARGET_DEFAULT \\\n+\t(MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS)\n \n-#define TARGET_SUBTARGET_DEFAULT (MASK_80387 | MASK_IEEE_FP | MASK_FLOAT_RETURNS)\n+/* By default, 64-bit mode uses 128-bit long double.  */\n+#undef TARGET_SUBTARGET64_DEFAULT\n+#define TARGET_SUBTARGET64_DEFAULT \\\n+\tMASK_128BIT_LONG_DOUBLE"}, {"sha": "80b2b71c9e7b94422e29a6dd86770def92e8b8c5", "filename": "gcc/gthr-win32.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fgthr-win32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/gcc%2Fgthr-win32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgthr-win32.h?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -562,7 +562,8 @@ __gthread_once (__gthread_once_t *once, void (*func) (void))\n    leaks, especially in threaded applications making extensive use of\n    C++ EH. Mingw uses a thread-support DLL to work-around this problem.  */\n static inline int\n-__gthread_key_create (__gthread_key_t *key, void (*dtor) (void *))\n+__gthread_key_create (__gthread_key_t *key,\n+\t\t      void (*dtor) (void *) __attribute__((unused)))\n {\n   int status = 0;\n   DWORD tls_index = TlsAlloc ();"}, {"sha": "de59b9d56da6450f0dfeac87157a264ab0f8fdba", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -1,3 +1,7 @@\n+2007-02-30  Kai Tietz  <kai.tietz@onevision.com>\n+\n+\t* config.host (x86_64-*-mingw*): New target.\n+\n 2007-03-23  Michael Meissner  <michael.meissner@amd.com>\n \t    H.J. Lu  <hongjiu.lu@intel.com>\n "}, {"sha": "f5fff3709413d0c5a2d3e48a85e259bd159bafcd", "filename": "libgcc/config.host", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf8e764e9ca5a530de57cdabdb7123734de2d4a/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=ccf8e764e9ca5a530de57cdabdb7123734de2d4a", "patch": "@@ -364,7 +364,7 @@ i[4567]86-wrs-vxworks|i[4567]86-wrs-vxworksae)\n \t;;\n i[34567]86-*-pe | i[34567]86-*-cygwin*)\n \t;;\n-i[34567]86-*-mingw32*)\n+i[34567]86-*-mingw32* | x86_64-*-mingw*)\n \t;;\n i[34567]86-*-uwin*)\n \t;;"}]}