{"sha": "edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWRjMDNlOGFhMmFkMzQ1ODRiYTQwY2FmYTgyNzc0ZGM2OWRjMjVmNw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-09T23:47:17Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-02-09T23:47:17Z"}, "message": "Initial revision\n\nFrom-SVN: r3452", "tree": {"sha": "8bdd8ce3ca83d75aae22de224e3c06f07c7e6ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bdd8ce3ca83d75aae22de224e3c06f07c7e6ac3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edc03e8aa2ad34584ba40cafa82774dc69dc25f7/comments", "author": null, "committer": null, "parents": [{"sha": "7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7988fd364ac120730ec4fdaf48e2bbc5c1df1443", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7988fd364ac120730ec4fdaf48e2bbc5c1df1443"}], "stats": {"total": 2354, "additions": 2354, "deletions": 0}, "files": [{"sha": "5ffef080b270d7ce07a7d0de60494bde28b5c248", "filename": "gcc/config/clipper/clipper.h", "status": "added", "additions": 1070, "deletions": 0, "changes": 1070, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edc03e8aa2ad34584ba40cafa82774dc69dc25f7/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edc03e8aa2ad34584ba40cafa82774dc69dc25f7/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "patch": "@@ -0,0 +1,1070 @@\n+/* Definitions of target machine for GNU compiler.  Clipper version.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+   Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+extern struct rtx_def *clipper_builtin_saveregs ();\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (clipper)\");\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"\", TARGET_DEFAULT} }\n+\n+/* Default target_flags if no switches specified.  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\f\n+/* Target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields. */\n+\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Largest alignment for stack parameters (if greater than PARM_BOUNDARY).  */\n+#define MAX_PARM_BOUNDARY 64\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 128\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* A bitfield declared as `int' forces `int' alignment for the struct.  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 64\n+\n+/* No structure field wants to be aligned rounder than this.  */\n+#define BIGGEST_FIELD_ALIGNMENT 64\n+\n+/*  Make strcpy of constants fast. */\n+#define CONSTANT_ALIGNMENT(CODE, TYPEALIGN) \\\n+  ((TYPEALIGN) < 32 ? 32 : (TYPEALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Set this nonzero if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT 1\n+\n+/* Let's keep the stack somewhat aligned.  */\n+#define STACK_BOUNDARY 64\n+\n+/* Define this macro if it is advisible to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases, \n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.\n+\n+   For Clipper, we always store objects in a full register. */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)  \\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\\\n+    {\t\t\t\t\t\t\\\n+      (UNSIGNEDP) = 0;\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\\\n+    }\n+\n+\n+/* Define this if function arguments should also be promoted using the above\n+   procedure.  */\n+\n+/* FIXME: do we loose compatibility to acc if we define this? */\n+\n+/* #define PROMOTE_FUNCTION_ARGS */\n+\n+/* Likewise, if the function return value is promoted.  */\n+\n+/* #define PROMOTE_FUNCTION_RETURN */\n+\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 32\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the clipper, these are the FP and SP .  */\n+#define FIXED_REGISTERS \\\n+{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\\\n+ 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1} /* FIXME: C300 only */\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+{1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\\\n+ 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1} /* FIXME: C300 only */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On the clipper, fp registers are 64 bits.  */\n+\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+  ((REGNO) >= 16 ? 1 \\\n+   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the clipper, 0-15 hold int, 16-31 hold float.  */\n+\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n+  ((GET_MODE_CLASS(MODE) == MODE_FLOAT) ? (REGNO) >= 16 : (REGNO) < 16)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2)  ((MODE1) == (MODE2))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* clipper has extra PC  */\n+/* #define PC_REGNUM */\n+\n+/* Register to use for pushing function arguments.  */\n+#define STACK_POINTER_REGNUM 15\n+\n+/* Base register for access to local variables of the function.  */\n+#define FRAME_POINTER_REGNUM 14\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM FRAME_POINTER_REGNUM\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 2\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 0\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+/* The clipper has general and FP regs.  */\n+\n+enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, ALL_REGS, LIM_REG_CLASSES};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x0000ffff, 0xffff0000, 0xffffffff}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) ((REGNO) >= 16 ? FLOAT_REGS : GENERAL_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) \\\n+  ((C) == 'r' ? GENERAL_REGS : ((C) == 'f' ? FLOAT_REGS: NO_REGS))\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C. */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself. */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+/* Optional extra constraints for this machine. */\n+\n+/* #define EXTRA_CONSTRAINT(OP, C) */\n+\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((CLASS) == FLOAT_REGS\t\t\t\\\n+  ? 1\t\t\t\t\t\\\n+  : (GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if longjmp restores from saved registers\n+   rather than from what setjmp saved.  */\n+/* #define LONGJMP_RESTORE_FROM_STACK */\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Given an rtx for the address of a frame,\n+   return an rtx for the address of the word in the frame\n+   that holds the dynamic chain--the previous frame's address.  */\n+#define DYNAMIC_CHAIN_ADDRESS(frame) (frame)\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by. */\n+\n+/* #define PUSH_ROUNDING(BYTES) (BYTES) */\n+\n+/* Keep the stack pointer constant throughout the function. */\n+/* we can't set this for clipper as library calls may have 3 args and we pass\n+   only 2 args in regs. */\n+\n+/* #define ACCUMULATE_OUTGOING_ARGS */\n+  \n+\n+/* Offset of first parameter from the argument pointer register value.\n+   size of PC + FP  */\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 8\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack. */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE) 0\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), ((TYPE_MODE (VALTYPE) == SFmode ||\\\n+\t\t\t\t       TYPE_MODE (VALTYPE) == DFmode) ? \\\n+\t\t\t\t        16 : 0))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+#define LIBCALL_VALUE(MODE)  \\\n+  gen_rtx (REG, (MODE), ((MODE) == SFmode || (MODE) == DFmode ? 16 : 0))\n+\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == 0 || (N) == 16)\n+\n+/* 1 if N is a possible register number for function argument passing.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  ((N) == 0 || (N) == 1 || (N) == 16 || (N) == 17)\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   Clipper uses 2 register 'slots' that pass arguments in r0/r1 or f0/f1.\n+   An argument that must be passed in memory (struct... ) leaves that slot\n+   free.\n+   We pass 'long long' only in registers when both slots are free.\n+   Returned structs must be allocated by the caller, the address is passed\n+   in r0.\n+\n+   struct ss {..}\n+\n+   fun (i,j,k)\t\ti in r0, j in r1, k on stack\n+   fun (s,j,k)\t\ts on stack, j in r1, k on stack\n+   fun (i,s,k)\t\ti in r0, s on stack, k on stack\n+   s1 = fun (i,s,k)\t&s1 in r0, i in r1, s on stack, k on stack\n+\n+   We must keep enough information for varargs/stdargs.\n+\n+   _clipper_cum_args is a struct of 2 integers, with\n+\tnum =  slots used\n+\tsize = size of all stack args = offset to next arg without alignment\n+\n+   If we use stdarg.h, size points to the first unnamed arg,\n+   see va-clipper.h */\n+\n+struct _clipper_cum_args { int num; int size; };\n+\n+#define CUMULATIVE_ARGS struct _clipper_cum_args\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   clipper passes the address of a struct in r0, set num = 1 in this case */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  ((CUM).num = ((FNTYPE) != 0 && aggregate_value_p (FNTYPE)), \\\n+   (CUM).size = 0)\n+\n+/* internal helper : size of an argument */\n+\n+#define CLIPPER_ARG_SIZE(MODE, TYPE)\t\t\t\t\\\n+((MODE) != BLKmode\t\t\t\t\t\t\t\\\n+ ? (GET_MODE_SIZE (MODE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD \t\\\n+ : (int_size_in_bytes (TYPE) + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+do\t\t\t\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if ((CUM).num == 0 && (MODE) == DImode)\t\t\t\t\\\n+    (CUM).num = 2;\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    (CUM).num++;       \t\t\t\t\t\t\t\\\n+  if ((CUM).num > 2 || (MODE) == BLKmode)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int align = FUNCTION_ARG_BOUNDARY (MODE, TYPE) / BITS_PER_UNIT;\t\\\n+      (CUM).size += align - 1;\t\t\t\t\t\t\\\n+      (CUM).size &= align - 1;\t\t\t\t\t\t\\\n+      (CUM).size += CLIPPER_ARG_SIZE (MODE, TYPE);\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* 2 args go into regs, float in f0/f1, anything else in r0/r1 */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\\\n+  (((CUM).num >= 2 || (MODE) == BLKmode || \t\\\n+    ((MODE) == DImode && (CUM).num)) ? 0 :\t\\\n+   gen_rtx (REG, (MODE),\t\t\t\t\t\\\n+\t    GET_MODE_CLASS(MODE) == MODE_FLOAT ? (CUM).num+16 : (CUM).num))\n+\n+/* If defined, a C expression that gives the alignment boundary, in bits,\n+   of an argument with the specified mode and type.  If it is not defined,\n+   `PARM_BOUNDARY' is used for all arguments.  */\n+\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE) \\\n+  (((TYPE) ? TYPE_ALIGN (TYPE) : GET_MODE_SIZE (MODE)) <= PARM_BOUNDARY \\\n+    ? PARM_BOUNDARY : 2 * PARM_BOUNDARY)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)  0\n+\n+/* Generate necessary RTL for __builtin_saveregs().\n+   ARGLIST is the argument list; see expr.c.  */\n+#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) clipper_builtin_saveregs (ARGLIST)\n+\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) output_function_prologue (FILE,SIZE)\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  /* FIXME */\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.  */\n+\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  /* FIXME */\n+\n+/* Output assembler code to FILE to increment the entry-count for\n+   the BLOCKNO'th basic block in this source file.  */\n+\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t/* FIXME */\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.  */\n+\n+#define EXIT_IGNORE_STACK 1\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) output_function_epilogue(FILE,SIZE)\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.\n+\n+   On the Clipper, FRAME_POINTER_REQUIRED is  1, so the definition of this\n+   this macro doesn't matter.  But it must be defined.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 0;\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t      \\\n+{\t\t\t\t\t\t\t\t\t      \\\n+  fputs (\"\\tcall   sp,.+4\\n\", FILE);\t\t\t\t\t      \\\n+  fputs (\"\\tmovw   (sp),r3\\n\", FILE);\t\t\t\t\t      \\\n+  fputs (\"\\taddq   $4,sp\\n\", FILE);\t\t\t\t\t      \\\n+  fputs (\"\\tloadw  32(r3),r2\\n\", FILE);\t\t\t\t\t      \\\n+  fputs (\"\\tloadw  36(r3),r3\\n\", FILE);\t\t\t\t\t      \\\n+  fputs (\"\\tb      (r3)\\n\", FILE);\t\t\t\t\t      \\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 44\n+\n+/* Alignment required for a trampoline.  128 is used to find the\n+   beginning of a line in the instruction cache and to allow for\n+   instruction cache lines of up to 128 bytes.  */\n+\n+#define TRAMPOLINE_ALIGNMENT 128\n+\n+/* Section in which to place the trampoline.  */\n+\n+#define TRAMPOLINE_SECTION text_section\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 36)), CXT); \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 40)), FNADDR); \\\n+}\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+((regno) < 16 || (unsigned)reg_renumber[regno] < 16)\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+((regno) < 16 || (unsigned)reg_renumber[regno] < 16)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+  /* clipper doesn't have true indexing */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (REGNO (X) < 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+\n+#define REG_OK_FOR_BASE_P(X) \\\n+  (REGNO (X) < 16 || REGNO(X) >= FIRST_PSEUDO_REGISTER)\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) (REGNO(X) < 16)\n+\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) (REGNO(X) < 16)\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+/* Non-zero if X is an address which can be indirected. */\n+\n+#define INDIRECTABLE_CONSTANT_ADDRESS_P(X) 0\n+\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\n+\n+/* Go to ADDR if X is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)\t\\\n+{ if (CONSTANT_ADDRESS_P (X)) goto ADDR;\t\\\n+  if (INDIRECTABLE_ADDRESS_P (X)) goto ADDR; }\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR) \\\n+{ register rtx xfoo = (X);\t\t\t\\\n+  GO_IF_NONINDEXED_ADDRESS (xfoo, ADDR);\t\\\n+  if (GET_CODE (xfoo) == PLUS)\t\t\t\\\n+    { register rtx xfoo0, xfoo1;\t\t\\\n+      xfoo0 = XEXP (xfoo, 0);\t\t\t\\\n+      xfoo1 = XEXP (xfoo, 1);\t\t\t\\\n+    /* handle reg + reg -> [r1](r0) */\t\t\\\n+      if (INDIRECTABLE_ADDRESS_P (xfoo0) && INDIRECTABLE_ADDRESS_P (xfoo1)) \\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+    /* Handle <symbol>(reg) -> xxx(r0) */\t\t\t\t\\\n+      if (INDIRECTABLE_ADDRESS_P (xfoo0) && CONSTANT_ADDRESS_P (xfoo1))\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+      if (INDIRECTABLE_ADDRESS_P (xfoo1) && CONSTANT_ADDRESS_P (xfoo0))\t\\\n+\tgoto ADDR; }}\n+\n+\f\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the clipper, nothing needs to be done.  */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for. */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL) {}\n+\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the case instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/* #define CASE_VECTOR_PC_RELATIVE */\n+\n+/* Define this if the case instruction drops through after the table\n+   when the index is out of range.  Don't define it if the case insn\n+   jumps to the default label instead.  */\n+/* #define CASE_DROPS_THROUGH */\n+\n+/* Define this macro if an instruction to load a value narrower than a\n+   word from memory into a register also sign-extends the value to\n+   the whole register. */\n+#define BYTE_LOADS_SIGN_EXTEND\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* MOVE_RATIO is the number of move instructions that is better than a\n+   block move.  Make this large on clipper, since the block move is very\n+   inefficient with small blocks, and the hard register needs of the\n+   block move require much reload work. */\n+\n+#define MOVE_RATIO 20\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* This machine uses IEEE floats.  */\n+\n+#define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n+\n+/* Check a `double' value for validity for a particular machine mode.\n+   This is defined to avoid crashes outputting certain constants.\n+   Since we output the number in hex, the assembler won't choke on it.  */\n+/* #define CHECK_FLOAT_VALUE(MODE,VALUE) */\n+\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+/* On a Clipper, constants from 0..15 are cheap because they can use the\n+   'quick' mode. */\n+\n+#define CONST_COSTS(RTX,CODE,OUTER_CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (0 <= INTVAL (RTX) && INTVAL(RTX) <= 15 ) return 0;\t\\\n+      return 1;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\n+/* Provide the costs of a rtl expression.  This is in the body of a\n+   switch on CODE.  */\n+\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\t\\\n+  case MULT:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (4);\t\t\t\t\\\n+  case DIV:\t\t\t\t\t\t\\\n+  case UDIV:\t\t\t\t\t\t\\\n+  case MOD:\t\t\t\t\t\t\\\n+  case UMOD:\t\t\t\t\t\t\\\n+    return COSTS_N_INSNS (40);\t\t\t\t\\\n+  case LSHIFT:\t\t\t\t\t\t\\\n+  case ASHIFT:\t\t\t\t\t\t\\\n+  case LSHIFTRT:\t\t\t\t\t\\\n+  case ASHIFTRT:\t\t\t\t\t\\\n+    return COSTS_N_INSNS (2);\t\t\t\t\\\n+ case SIGN_EXTEND:\t\t\t\t\t\\\n+    return (GET_CODE (XEXP (X,0)) == REG ? COSTS_N_INSNS (3) : 4);\n+\n+/* Specify the cost of a branch insn; roughly the number of extra insns that\n+   should be added to avoid a branch */\n+\n+/* #define BRANCH_COST 0 */\n+\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the clipper.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{\t\t\t\t\t\t\t\t\t      \\\n+  enum attr_cc cc = get_attr_cc (INSN);\t\t\t\t\t      \\\n+  rtx dest = SET_DEST (EXP);\t\t\t\t\t\t      \\\n+  switch (cc)\t\t\t\t\t\t\t\t      \\\n+    {\t\t\t\t\t\t\t\t\t      \\\n+    case CC_CHANGE0:\t\t\t\t\t\t\t      \\\n+      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n+      if (cc_status.value1 && rtx_equal_p (dest, cc_status.value1) ||\t      \\\n+\t  cc_status.value2 && rtx_equal_p (dest, cc_status.value2))\t      \\\n+\tCC_STATUS_INIT;\t\t\t\t\t\t\t      \\\n+      break;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    case CC_SET1:\t\t\t\t\t\t\t      \\\n+      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n+      cc_status.flags = 0;\t\t\t\t\t\t      \\\n+      cc_status.value1 = dest;\t\t\t\t\t\t      \\\n+      cc_status.value2 = 0;\t\t\t\t\t\t      \\\n+      break;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    case CC_SET2:\t\t\t\t\t\t\t      \\\n+      if (GET_CODE (EXP) == PARALLEL) abort();\t\t\t\t      \\\n+      cc_status.flags = 0;\t\t\t\t\t\t      \\\n+      cc_status.value1 = dest;\t\t\t\t\t\t      \\\n+      cc_status.value2 = SET_SRC (EXP);\t\t\t\t\t      \\\n+      break;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    case CC_UNCHANGED:\t\t\t\t\t\t\t      \\\n+      break;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    case CC_CLOBBER:\t\t\t\t\t\t\t      \\\n+      CC_STATUS_INIT;\t\t\t\t\t\t\t      \\\n+      break;\t\t\t\t\t\t\t\t      \\\n+\t\t\t\t\t\t\t\t\t      \\\n+    default:\t\t\t\t\t\t\t\t      \\\n+      abort ();\t\t\t\t\t\t\t\t      \\\n+    }\t\t\t\t\t\t\t\t\t      \\\n+}\n+\n+\f\n+/* Control the assembler format that we output.  */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) fprintf (FILE, \"#NO_APP\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\", \\\n+ \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"fp\", \"sp\", \\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \\\n+ \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\" }\n+\n+/* How to renumber registers for dbx and gdb.\n+   Clipper needs no change in the numeration.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubq   $8,sp\\n\\t%s  %s,(sp)\\n\",\t\\\n+\t   (REGNO) < 16 ? \"storw\" : \"stord\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\t%s  (sp),%s\\n\\t\\addq  $8,sp\\n\",\t\\\n+\t   (REGNO) < 16 ? \"loadw\" : \"loadd\", reg_names[REGNO])\n+/* This is how to output an element of a case-vector that is absolute */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long .L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter by SIZE bytes.  */\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_ALIGNED_LOCAL(FILE,NAME,SIZE,ALIGN)\t\\\n+( data_section (),\t\t\t\t\t\\\n+  fputs (\"\\t.bss\\t\", (FILE)),\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\\\n+  fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN)/BITS_PER_UNIT))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'.\n+\n+Clipper operand formatting codes:\n+\n+ letter\t   print\n+   C\treverse branch condition\n+*/\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == 'C')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ extern char *rev_cond_name ();\t\t\t\t\t\\\n+  if (CODE == 'C')\t\t\t\t\t\t\t\\\n+    fputs (rev_cond_name (X), FILE);\t\t\t\t\t\\\n+  else if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names[REGNO (X)]);\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }}\n+\n+/* Print a memory operand whose address is X, on file FILE.\n+   This uses a function in output-clipper.c.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+ print_operand_address (FILE, ADDR)\n+\n+/* Define the codes that are matched by predicates in clipper.c */\n+\n+#define PREDICATE_CODES \\\n+  {\"int_reg_operand\", {SUBREG, REG}},\t\\\n+  {\"fp_reg_operand\", {SUBREG, REG}},"}, {"sha": "72758fabd57120d337163142c48a9c76268c7d19", "filename": "gcc/config/clipper/clipper.md", "status": "added", "additions": 1284, "deletions": 0, "changes": 1284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/edc03e8aa2ad34584ba40cafa82774dc69dc25f7/gcc%2Fconfig%2Fclipper%2Fclipper.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/edc03e8aa2ad34584ba40cafa82774dc69dc25f7/gcc%2Fconfig%2Fclipper%2Fclipper.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.md?ref=edc03e8aa2ad34584ba40cafa82774dc69dc25f7", "patch": "@@ -0,0 +1,1284 @@\n+;;- Machine description for GNU compiler, Clipper Version\n+;;   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n+\n+;; Contributed by Holger Teutsch (holger@hotbso.rhein-main.de)\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;;- Instruction patterns.  When multiple patterns apply,\n+;;- the first one in the file is chosen.\n+;;-\n+;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+;;-\n+;;- cpp macro #define NOTICE_UPDATE_CC in file tm.h handles condition code\n+;;- updates for most instructions.\n+\n+;;\n+;; define attributes\n+;;\n+;; instruction type\n+;;\n+;; unknown is temporary in order to generate 'cc clobber' until attribute\n+;; assignment is consistent\n+;;\n+(define_attr \"type\" \"load,store,arith,fp,branch,unknown\"\n+ (const_string \"unknown\"))\n+\n+;; condition code setting\n+;;\n+;; clobber\tdestroyed\n+;; unchanged\n+;; set1\t\tset cc_status.value1, e.g. sub r0,r1\n+;; set2\t\tset value1 and value2, e.g. mov r0,r1\n+;; change0\tmay be side effect, i.e. load mem,r0\n+;;\n+;; note: loadi and loadq are 'arith' instructions that set the condition codes\n+;;       mul,div,mod do NOT set the condition codes\n+;;\n+(define_attr \"cc\" \"clobber,unchanged,set1,set2,change0\"\n+ (cond [(eq_attr \"type\" \"load\")\t(const_string \"change0\")\n+\t(eq_attr \"type\" \"store,branch\") (const_string \"unchanged\")\n+\t(eq_attr \"type\" \"arith\") (if_then_else (match_operand:SI 0 \"\" \"\")\n+\t\t\t\t  (const_string \"set1\")\n+\t\t\t\t  (const_string \"clobber\"))\n+\t]\n+  (const_string \"clobber\")))\n+\n+;;\n+;; clipper seems to be a tradional risc processor\n+;; we define a functional unit 'memory'\n+;;\n+(define_function_unit \"memory\" 1 1 (eq_attr \"type\" \"load\") 4 0)     \n+\n+\f\n+;; We don't want to allow a constant operand for test insns because\n+;; (set (cc0) (const_int foo)) has no mode information.  Such insns will\n+;; be folded while optimizing anyway.\n+\n+(define_insn \"tstsi\"\n+  [(set (cc0)\n+\t(match_operand:SI 0 \"int_reg_operand\" \"r\"))]\n+  \"\"\n+  \"cmpq   $0,%0\")\n+\n+(define_insn \"cmpsi\"\n+  [(set (cc0)\n+\t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"r,r,n\")\n+\t\t (match_operand:SI 1 \"nonmemory_operand\" \"r,n,r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\n+    return \\\"cmpw   %1,%0\\\";\n+\n+  if (which_alternative == 1)\n+    return \\\"cmpi   %1,%0\\\";\n+\n+  cc_status.flags |= CC_REVERSED;\t/* immediate must be first */\n+  return \\\"cmpi   %0,%1\\\";\n+}\")\n+\n+(define_insn \"cmpdf\"\n+  [(set (cc0)\n+\t(compare (match_operand:DF 0 \"fp_reg_operand\" \"f\")\n+\t\t (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"cmpd   %1,%0\")\n+\n+(define_insn \"cmpsf\"\n+  [(set (cc0)\n+\t(compare (match_operand:SF 0 \"fp_reg_operand\" \"f\")\n+\t\t (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"cmps   %1,%0\")\n+\n+\f\n+;;\n+;; double and single float move\n+;;\n+(define_expand \"movdf\"\n+  [(set (match_operand:DF 0 \"general_operand\" \"\")\n+\t(match_operand:DF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\toperands[1] = force_reg (DFmode,\n+\t\t\t\t force_const_mem (DFmode, operands[1]));\n+      else if (GET_CODE (operands[1]) != REG)\n+\toperands[1] = force_reg (DFmode, operands[1]);\n+    }\n+\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (DFmode, operands[1]);\n+}\")\n+\n+;;\n+;; provide two patterns with different predicates as we don't want combine\n+;; to recombine a mem -> mem move\n+;; \n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:DF 1 \"nonimmediate_operand\" \"rfo\"))]\n+  \"\"\n+  \"*\n+{\n+#define FP_REG_P(X) (GET_CODE (X) == REG && REGNO (X) >= 16)\n+\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\t/* f -> f */\n+\treturn \\\"movd   %1,%0\\\";\n+\n+      if (GET_CODE (operands[1]) == REG) /* r -> f */\n+\treturn \\\"movld  %1,%0\\\";\n+\n+      return \\\"loadd  %1,%0\\\";\t\t/* m -> f */\n+    }\n+\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG) /* f -> r */\n+\treturn \\\"movdl  %1,%0\\\";\n+\n+      abort ();\n+    }\n+\n+  if (GET_CODE (operands[1]) == MEM)\t/* m -> r */\n+    {\n+      rtx xops[4];\n+      xops[0] = operands[0];\n+      xops[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xops[2] = operands[1];\n+      xops[3] = adj_offsettable_operand (operands[1], 4);\n+      output_asm_insn (\\\"loadw  %2,%0\\;loadw  %3,%1\\\", xops);\n+      return \\\"\\\";\n+    }\n+\n+  if (GET_CODE (operands[1]) == REG)\t/* r -> r */\n+    {\n+      rtx xops[4];\n+      xops[0] = operands[0];\n+      xops[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+      xops[2] = operands[1];\n+      xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      output_asm_insn (\\\"movw   %2,%0\\;movw   %3,%1\\\", xops);\n+      return \\\"\\\";\n+    }\n+\n+  abort ();\n+#undef FP_REG_P\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"memory_operand\" \"=o,m\")\n+\t(match_operand:DF 1 \"register_operand\" \"r,f\"))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 0)\t\t/* r -> o */\n+    {\n+      rtx xops[4];\n+      xops[0] = operands[0];\n+      xops[1] = adj_offsettable_operand (operands[0], 4);\n+      xops[2] = operands[1];\n+      xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n+      return \\\"\\\";\n+    }\n+\n+  return \\\"stord  %1,%0\\\";\t\t/* f-> m */\n+}\")\n+\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand\" \"\")\n+\t(match_operand:SF 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+\toperands[1] = force_reg (SFmode,\n+\t\t\t\t force_const_mem (SFmode, operands[1]));\n+      else if (GET_CODE (operands[1]) != REG)\n+\toperands[1] = force_reg (SFmode, operands[1]);\n+    }\n+\n+  else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n+    operands[1] = force_const_mem (SFmode, operands[1]);\n+}\")\n+\n+;;\n+;; provide two patterns with different predicates as we don't want combine\n+;; to recombine a mem -> mem move\n+;; \n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=rf\")\n+\t(match_operand:SF 1 \"nonimmediate_operand\" \"rfm\"))]\n+  \"\"\n+  \"*\n+{\n+#define FP_REG_P(X) (GET_CODE (X) == REG && REGNO (X) >= 16)\n+\n+  if (FP_REG_P (operands[0]))\n+    {\n+      if (FP_REG_P (operands[1]))\t/* f -> f */\n+\treturn \\\"movs   %1,%0\\\";\n+      if (GET_CODE (operands[1]) == REG) /* r -> f */\n+\treturn\n+\t  \\\"subq   $8,sp\\;storw  %1,(sp)\\;loads  (sp),%0\\;addq   $8,sp\\\";\n+      return \\\"loads  %1,%0\\\";\t\t/* m -> f */\n+    }\n+\n+  if (FP_REG_P (operands[1]))\n+    {\n+      if (GET_CODE (operands[0]) == REG) /* f -> r */\n+\treturn\n+\t  \\\"subq   $8,sp\\;stors  %1,(sp)\\;loadw  (sp),%0\\;addq   $8,sp\\\";\n+      abort ();\n+    }\n+\n+  if (GET_CODE (operands[1]) == MEM)\t/* m -> r */\n+    return \\\"loadw   %1,%0\\\";\n+\n+  if (GET_CODE (operands[1]) == REG)\t/* r -> r */\n+    return \\\"movw    %1,%0\\\";\n+\n+  abort ();\n+#undef FP_REG_P\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SF 1 \"register_operand\" \"rf\"))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) >= 16)\n+    return \\\"stors  %1,%0\\\";\t\t/* f-> m */\n+\n+  return \\\"storw   %1,%0\\\";\t\t/* r -> m */\n+}\")\n+\n+\n+(define_expand \"movdi\"\n+  [(set (match_operand:DI 0 \"general_operand\" \"\")\n+\t(match_operand:DI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) != REG)\n+    operands[1] = force_reg (DImode, operands[1]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r,r,r\")\n+\t(match_operand:DI 1 \"general_operand\"   \"r,n,o\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[2],yoperands[2];\n+\n+  xoperands[0] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+\n+  if (which_alternative == 0)\t\t/* r -> r */\n+    {\n+      output_asm_insn (\\\"movw   %1,%0\\\", operands);\n+      xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+      output_asm_insn (\\\"movw   %1,%0\\\", xoperands);\n+      return \\\"\\\";\n+    }\n+\n+  if (which_alternative == 1)\t\t/* n -> r */\n+    {\n+      if (GET_CODE (operands[1]) == CONST_INT)\n+\t{\n+\t  output_asm_insn (\\\"loadi   %1,%0\\\", operands);\n+\t  output_asm_insn (\\\"loadq   $0,%0\\\", xoperands);\n+\t  return \\\"\\\";\n+\t}\n+\n+      if (GET_CODE (operands[1]) != CONST_DOUBLE)\n+\tabort ();\n+\n+      yoperands[0] = operands[0];\n+      yoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t      CONST_DOUBLE_LOW (operands[1]));\n+      output_asm_insn (\\\"loadi  %1,%0\\\", yoperands);\n+\n+      xoperands[1] = gen_rtx (CONST_INT, VOIDmode,\n+\t\t\t      CONST_DOUBLE_HIGH (operands[1]));\n+      output_asm_insn (\\\"loadi  %1,%0\\\", xoperands);\n+      return \\\"\\\";\n+    }\n+\t\t\t\t\t/* m -> r */\n+  output_asm_insn (\\\"loadw  %1,%0\\\", operands);\n+  xoperands[1] = adj_offsettable_operand (operands[1], 4);\n+  output_asm_insn (\\\"loadw  %1,%0\\\", xoperands);\n+  return \\\"\\\";\n+}\" \n+[(set_attr \"type\" \"arith,arith,load\")\n+  (set_attr \"cc\" \"clobber,clobber,clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:DI 0 \"memory_operand\" \"=o\")\n+\t(match_operand:DI 1 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[4];\n+  xops[0] = operands[0];\n+  xops[1] = adj_offsettable_operand (operands[0], 4);\n+  xops[2] = operands[1];\n+  xops[3] = gen_rtx (REG, SImode, REGNO (operands[1]) + 1);\n+  output_asm_insn (\\\"storw  %2,%0\\;storw  %3,%1\\\", xops);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"type\" \"store\")\n+ (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM &&\n+      GET_CODE (operands[1]) != REG)\n+    operands[1] = force_reg (SImode, operands[1]);\n+}\")\n+\n+;; provide 2 patterns with different predicates as 'general_operand' in both\n+;; positions results in a 'mem -> mem' move from combine that must be reloaded \n+;;\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r,r,r,r\")\n+\t(match_operand:SI 1 \"general_operand\"   \"r,m,n,i\"))]\n+  \"\"\n+  \"*\n+{\n+  int val;\n+\n+  if (which_alternative == 0)\n+    return \\\"movw   %1,%0\\\";\t\t/* reg -> reg */\n+\n+  if (which_alternative == 1)\n+    return \\\"loadw  %1,%0\\\";\t\t/* mem -> reg */\n+\n+  if (which_alternative == 2)\n+    {\n+      val = INTVAL (operands[1]);\t/* known const ->reg */\n+      if (val < 0 || val >= 16)\n+\treturn \\\"loadi  %1,%0\\\";\n+\n+      return \\\"loadq  %1,%0\\\";\n+    }\n+\n+  if (which_alternative == 3)\t\t/* unknown const */\n+    return \\\"loada  %a1,%0\\\";\n+}\"\n+[(set_attr \"type\" \"arith,load,arith,load\")\n+ (set_attr \"cc\" \"set2,change0,set1,change0\")])\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:SI 1 \"int_reg_operand\" \"r\"))]\n+  \"\"\n+  \"storw  %1,%0\"\n+[(set_attr \"type\" \"store\")])\n+\n+;; movhi\n+;;\n+;; loadh  mem to reg\n+;; storh  reg to mem\n+;;\n+;;\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"\")\n+\t(match_operand:HI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM\n+      && ! register_operand (operands[1], HImode))\n+    operands[1] = force_reg (HImode, operands[1]);\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r,r,r\")\n+\t(match_operand:HI 1 \"general_operand\"   \"r,m,n\"))]\n+  \"\"\n+  \"@\n+   movw   %1,%0\n+   loadh  %1,%0\n+   loadi  %1,%0\"\n+[(set_attr \"type\" \"arith,load,arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"memory_operand\"  \"=m\")\n+\t(match_operand:HI 1 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"storh  %1,%0\"\n+ [(set_attr \"type\" \"store\")])\n+\n+;; movqi\n+;;\n+;; loadb  mem to reg\n+;; storb  reg to mem\n+;;\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"\")\n+\t(match_operand:QI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[0]) == MEM && \n+      ! register_operand (operands[1], QImode))\n+    operands[1] = force_reg (QImode, operands[1]);\n+}\")\n+\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r\")\n+\t(match_operand:QI 1 \"general_operand\"   \"r,m,n\"))]\n+  \"\"\n+  \"@\n+   movw   %1,%0\n+   loadb  %1,%0\n+   loadi  %1,%0\"\n+[(set_attr \"type\" \"arith,load,arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"storb  %1,%0\"\n+[(set_attr \"type\" \"store\")])\n+\n+;;\n+;; block move\n+;;\n+(define_expand \"movstrsi\"\n+  [(parallel\n+    [(set (match_operand:BLK 0 \"memory_operand\" \"\")\n+          (match_operand:BLK 1 \"memory_operand\" \"\"))\n+     (use (match_operand:SI 2 \"general_operand\" \"\"))\n+     (use (match_operand:SI 3 \"const_int_operand\" \"\"))\n+     (clobber (match_scratch:SI 4 \"\"))\n+     (clobber (match_scratch:SI 5 \"\"))\n+     (clobber (match_dup 6))\n+     (clobber (match_dup 7))])]\n+  \"\"\n+  \"\n+{\n+  rtx addr0, addr1;\n+\n+  addr0 = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+  addr1 = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+\n+  operands[6] = addr0;\n+  operands[7] = addr1;\n+\n+  operands[0] = gen_rtx (MEM, BLKmode, addr0);\n+  operands[1] = gen_rtx (MEM, BLKmode, addr1);\n+\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = force_reg (SImode, operands[2]);\n+}\")\n+\n+;;\n+;; there is a problem with this insn in gcc-2.2.3\n+;; (clobber (match_dup 2)) does not prevent use of this operand later\n+;; we always use a scratch register and leave operand 2 unchanged\n+;;\n+(define_insn \"\"\n+  [(set (mem:BLK (match_operand:SI 0 \"register_operand\" \"r\"))\n+\t(mem:BLK (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"nonmemory_operand\" \"rn\"))\n+   (use (match_operand:SI 3 \"const_int_operand\" \"n\"))\n+   (clobber (match_scratch:SI 4 \"=r\"))\n+   (clobber (match_scratch:SI 5 \"=r\"))\n+   (clobber (match_dup 0))\n+   (clobber (match_dup 1))]\n+  \"\"\n+  \"*\n+{\n+  extern void clipper_movstr ();\n+  clipper_movstr (operands);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"cc\" \"clobber\")])\n+\n+\n+\f\n+;; Extension and truncation insns.\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:HI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $65535,%0\\;xori   $32768,%0\\;subi   $32768,%0\n+   loadh  %1,%0\"\n+[(set_attr \"type\" \"arith,load\")])\n+\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"int_reg_operand\" \"=r,r\")\n+\t(sign_extend:HI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $255,%0\\;xori   $128,%0\\;subi   $128,%0\n+   loadb  %1,%0\"\n+[(set_attr \"type\" \"arith,load\")\n+ (set_attr \"cc\" \"set1,change0\")])\n+\n+\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(sign_extend:SI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $255,%0\\;xori   $128,%0\\;subi   $128,%0\n+   loadb  %1,%0\"\n+[(set_attr \"type\" \"arith,load\")])\n+\n+\n+(define_insn \"extendsfdf2\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(float_extend:DF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"cnvsd  %1,%0\")\n+\n+(define_insn \"truncdfsf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(float_truncate:SF (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"cnvds  %1,%0\")\n+\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:HI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $65535,%0\n+   loadhu %1,%0\"\n+[(set_attr \"type\" \"arith,load\")])\n+\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"int_reg_operand\" \"=r,r\")\n+\t(zero_extend:HI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $255,%0\n+   loadbu %1,%0\"\n+[(set_attr \"type\" \"arith,load\")\n+ (set_attr \"cc\" \"clobber,clobber\")])\n+\n+\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(zero_extend:SI (match_operand:QI 1 \"general_operand\" \"0,m\")))]\n+  \"\"\n+  \"@\n+   andi   $255,%0\n+   loadbu %1,%0\"\n+[(set_attr \"type\" \"arith,load\")])\n+\n+\n+\f\n+;; Fix-to-float conversion insns.\n+\n+(define_insn \"floatsisf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(float:SF (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"cnvws  %1,%0\")\n+\n+(define_insn \"floatsidf2\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(float:DF (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"cnvwd  %1,%0\")\n+\n+\f\n+;; Float-to-fix conversion insns.\n+\n+(define_insn \"fix_truncsfsi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(fix:SI (fix:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\"))))]\n+  \"\"\n+  \"cnvtsw %1,%0\")\n+\n+(define_insn \"fix_truncdfsi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(fix:SI (fix:DF (match_operand:DF 1 \"fp_reg_operand\" \"f\"))))]\n+  \"\"\n+  \"cnvtdw %1,%0\")\n+\f\n+;;- All kinds of add instructions.\n+\n+(define_insn \"adddf3\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n+\t\t (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"addd   %2,%0\")\n+\n+\n+(define_insn \"addsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(plus:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n+\t\t (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"adds   %2,%0\")\n+\n+(define_insn \"adddi3\"\n+  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n+\t(plus:DI (match_operand:DI 1 \"int_reg_operand\" \"%0\")\n+\t\t (match_operand:DI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[4];\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[2] = operands[2];\n+  xoperands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  output_asm_insn (\\\"addw   %2,%0\\;addwc  %3,%1\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"type\" \"arith\")\n+ (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"addsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r,r\")\n+\t(plus:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,r,r\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"rn,0,rn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (which_alternative == 2)\t\t/* 3 address version */\n+    {\n+      if (GET_CODE (operands[2]) == CONST_INT)\n+\treturn \\\"loada  %a2(%1),%0\\\";\n+      return \\\"loada  [%2](%1),%0\\\";\n+    }\n+\t\t\t\t\t/* 2 address version */\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int val = INTVAL (operands[2]);\n+\n+      if (val >= 16 || val == 0x80000000)\n+\treturn \\\"addi   %2,%0\\\";\n+\n+      if (val < 0)\t\t\t/* change to sub */\n+\t{\n+\t  rtx xops[2];\n+\n+\t  val = -val;\n+\n+\t  xops[0] = operands[0];\n+\t  xops[1] = gen_rtx (CONST_INT, VOIDmode, val);\n+\n+\t  if (val >= 16)\n+\t    output_asm_insn (\\\"subi   %1,%0\\\", xops);\n+\t  else\n+\t    output_asm_insn (\\\"subq   %1,%0\\\", xops);\n+\n+\t  return \\\"\\\";\n+\t}\n+\n+      return \\\"addq   %2,%0\\\";\n+    }\n+\n+  if (which_alternative == 0)\n+    return \\\"addw   %2,%0\\\";\n+\n+  return \\\"addw   %1,%0\\\";\n+}\"\n+[(set_attr \"type\" \"arith,arith,arith\")\n+ (set_attr \"cc\" \"set1,set1,change0\")])\n+\n+\f\n+;;- All kinds of subtract instructions.\n+\n+(define_insn \"subdi3\"\n+  [(set (match_operand:DI 0 \"int_reg_operand\" \"=r\")\n+\t(minus:DI (match_operand:DI 1 \"int_reg_operand\" \"%0\")\n+\t\t  (match_operand:DI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  rtx xoperands[4];\n+\n+  xoperands[0] = operands[0];\n+  xoperands[1] = gen_rtx (REG, SImode, REGNO (operands[0]) + 1);\n+  xoperands[2] = operands[2];\n+  xoperands[3] = gen_rtx (REG, SImode, REGNO (operands[2]) + 1);\n+  output_asm_insn (\\\"subw   %2,%0\\;subwc  %3,%1\\\", xoperands);\n+  return \\\"\\\";\n+}\"\n+[(set_attr \"type\" \"arith\")\n+ (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"subsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(minus:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"rn\")))]\n+  \"\"\n+  \"*\n+{\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      int val = INTVAL (operands[2]);\n+\n+      if (val < 0 || val >= 16)\n+\treturn \\\"subi   %2,%0\\\";\n+      else\n+\treturn \\\"subq   %2,%0\\\";\n+    }\n+\n+  return \\\"subw   %2,%0\\\";\n+}\"\n+[(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"subdf3\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"subd   %2,%0\")\n+\n+(define_insn \"subsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(minus:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n+\t\t  (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"subs   %2,%0\")\n+\n+\f\n+;;- Multiply instructions.\n+\n+(define_insn \"muldf3\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n+\t\t (match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"muld   %2,%0\")\n+\n+(define_insn \"mulsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n+\t\t (match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"muls   %2,%0\")\n+\n+(define_insn \"mulsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(mult:SI (match_operand:SI 1 \"int_reg_operand\" \"%0\")\n+\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"mulw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"clobber\")])\n+\n+\n+\f\n+;;- Divide and mod instructions.\n+\n+(define_insn \"divdf3\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"fp_reg_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"divd   %2,%0\")\n+\n+(define_insn \"divsf3\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(div:SF (match_operand:SF 1 \"fp_reg_operand\" \"0\")\n+\t\t(match_operand:SF 2 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"divs   %2,%0\")\n+\n+(define_insn \"divsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(div:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"divw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"udivsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(udiv:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"divwu  %2,%0\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"clobber\")])\n+\n+\n+(define_insn \"modsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(mod:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"modw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"umodsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(umod:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t         (match_operand:SI 2 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"modwu  %2,%0\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"clobber\")])\n+\f\n+;;\n+;; bit and/or instructions\n+;;\n+(define_insn \"andsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+        (and:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   andw   %2,%0\n+   andi   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"iorsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(ior:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n+\t        (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   orw    %2,%0\n+   ori    %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"xorsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(xor:SI (match_operand:SI 1 \"int_reg_operand\" \"%0,0\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   xorw   %2,%0\n+   xori   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\f\n+(define_insn \"negdf2\"\n+  [(set (match_operand:DF 0 \"fp_reg_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"negd   %1,%0\")\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"fp_reg_operand\" \"=f\")\n+\t(neg:SF (match_operand:SF 1 \"fp_reg_operand\" \"f\")))]\n+  \"\"\n+  \"negs   %1,%0\")\n+\n+(define_insn \"negsi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(neg:SI (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"negw   %1,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+\f\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"int_reg_operand\" \"r\")))]\n+  \"\"\n+  \"notw   %1,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+\n+\f\n+;; Right shift on the clipper works by negating the shift count,\n+;; then emitting a right shift with the shift count negated.  This means\n+;; that all actual shift counts in the RTL will be positive.\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n+\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"shai   $%n2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n+  \"\"\n+  \"shaw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(ashift:SI (match_operand:SI 1 \"int_reg_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"*\n+{\n+  int val;\n+\n+  if (which_alternative == 0)\n+   return \\\"shaw   %2,%0\\\";\n+\n+  val = INTVAL (operands[2]);\n+\n+  if (val == 2)\n+    return \\\"addw   %0,%0\\;addw   %0,%0\\\";\n+\n+  if (val == 1)\n+    return \\\"addw   %0,%0\\\";\n+\n+  return \\\"shai   %2,%0\\\";\n+}\"\n+[(set_attr \"type\" \"arith\")])\n+\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n+\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"shli   $%n2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n+  \"\"\n+  \"shlw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"lshlsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(lshift:SI (match_operand:SI 1 \"int_reg_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   shlw   %2,%0\n+   shli   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+;; rotate\n+(define_expand \"rotrsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"\")\n+\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"\")\n+\t             (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (GET_CODE (operands[2]) != CONST_INT)\n+    operands[2] = gen_rtx (NEG, SImode, negate_rtx (SImode, operands[2]));\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n+  \"\"\n+  \"roti   $%n2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r\")\n+\t(rotatert:SI (match_operand:SI 1 \"int_reg_operand\" \"0\")\n+\t\t     (neg:SI (match_operand:SI 2 \"nonmemory_operand\" \"r\"))))]\n+  \"\"\n+  \"rotw   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+(define_insn \"rotlsi3\"\n+  [(set (match_operand:SI 0 \"int_reg_operand\" \"=r,r\")\n+\t(rotate:SI (match_operand:SI 1 \"int_reg_operand\" \"0,0\")\n+\t\t   (match_operand:SI 2 \"nonmemory_operand\" \"r,n\")))]\n+  \"\"\n+  \"@\n+   rotw   %2,%0\n+   roti   %2,%0\"\n+ [(set_attr \"type\" \"arith\")])\n+\n+\f\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"b      %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"b      (%0)\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"breq   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brne   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brgt   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brgtu  %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brlt   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brltu  %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brge   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"brgeu  %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+ \"\"\n+ \"brle   %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+(define_insn \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+ \"\"\n+ \"brleu  %l0\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+;; Recognize reversed jumps.\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t\t      [(cc0)\n+\t\t\t\t       (const_int 0)])\n+\t\t      (pc)\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))))]\n+ \"\"\n+ \"br%C0    %l1\" ; %C0 negates condition\n+ [(set_attr \"type\" \"branch\")])\n+\f\n+;;\n+;; call instructions\n+;;\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"general_operand\" \"m\")\n+\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  ;; Operand 1 not used on the clipper.\n+  \"\"\n+  \"call   sp,%0\")\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (match_operand:QI 1 \"general_operand\" \"m\")\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  ;; Operand 2 not used on the clipper\n+  \"\"\n+  \"call   sp,%1\")\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"b      (%0)\"\n+ [(set_attr \"type\" \"branch\")])\n+\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"noop\"\n+ [(set_attr \"type\" \"arith\")\n+  (set_attr \"cc\" \"unchanged\")])\n+\n+\f\n+;;\n+;; define insns for loops\n+;; subtract, test and branch are tied together and the test can be omitted\n+;;\n+\n+;; while (--foo > 0)\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (gt (plus:SI (match_operand:SI 0 \"int_reg_operand\" \"+r\")\n+\t\t      (const_int -1))\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"subq   $1,%0\\;brgt   %l1\")\n+\n+;; while (--foo >= 0)\n+;;\n+;; this does not work and I don't know why\n+;; gcc 2.3.3 says that is doesn't match its contraint ?!?\n+;; the problem seem to be the \"+r\" constraint. \"r\" works, but is this okay??\n+;;\n+;;(define_insn \"\"\n+;;  [(set (pc)\n+;;\t(if_then_else\n+;;\t (ge (plus:SI (match_operand:SI 0 \"int_reg_operand\" \"+r\")\n+;;\t\t      (const_int -1))\n+;;\t     (const_int 0))\n+;;\t (label_ref (match_operand 1 \"\" \"\"))\n+;;\t (pc)))\n+;;   (set (match_dup 0)\n+;;\t(plus:SI (match_dup 0)\n+;;\t\t (const_int -1)))]\n+;;  \"\"\n+;;  \"subq   $1,%0\\;brge   %l1\")\n+\n+\n+;;  `while (foo--)'  ->  `while (--foo != -1)'.\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (ne (match_operand:SI 0 \"int_reg_operand\" \"+r\")\n+\t     (const_int 0))\n+\t (label_ref (match_operand 1 \"\" \"\"))\n+\t (pc)))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (const_int -1)))]\n+  \"\"\n+  \"subq   $1,%0\\;brgeu  %l1\")\n+\n+\f\n+;;- Local variables:\n+;;- mode:c\n+;;- comment-start: \";;- \"\n+;;- eval: (set-syntax-table (copy-sequence (syntax-table)))\n+;;- eval: (modify-syntax-entry ?[ \"(]\")\n+;;- eval: (modify-syntax-entry ?] \")[\")\n+;;- eval: (modify-syntax-entry ?{ \"(}\")\n+;;- eval: (modify-syntax-entry ?} \"){\")\n+;;- End:"}]}