{"sha": "b1af4cb2903711183e62f922fc235d48c7a738bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjFhZjRjYjI5MDM3MTExODNlNjJmOTIyZmMyMzVkNDhjN2E3MzhiYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-06-29T07:16:37Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-06-29T07:16:37Z"}, "message": "expr.c (expand_expr_real_1): Apply the big-endian adjustment for bit-fields to all aggregate types.\n\n\t* expr.c (expand_expr_real_1) <BIT_FIELD_REF>: Apply the big-endian\n\tadjustment for bit-fields to all aggregate types.\nada/\n\t* gcc-interface/gigi.h (make_packable_type): Remove default value.\n\t(value_factor_p): Tweak prototype.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add comment.\n\t(gnat_to_gnu_component_type): Likewise.\n\t(gnat_to_gnu_field): Likewise.  Fetch the position of the field earlier\n\tand simplify the condition under which the type is packed.  Declare\n \tlocal variable is_bitfield.  Pass 1 as max_align to make_packable_type\n\tif it is set to true.\n\t(copy_and_substitute_in_layout): Pass 0 to make_packable_type.\n\t* gcc-interface/utils.c (make_packable_array_type): New function.\n\t(make_packable_type): Use it to rewrite the type of array field.\n\t(maybe_pad_type): Pass align parameter to make_packable_type.\n\t(create_field_decl): Minor tweaks.\n\t(value_factor_p): Assert that FACTOR is a power of 2 and replace the\n\tmodulo computation by a masking operation.\n\nFrom-SVN: r272810", "tree": {"sha": "e52fb1419869e176950e8aab90f65e8e32ade6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e52fb1419869e176950e8aab90f65e8e32ade6ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b1af4cb2903711183e62f922fc235d48c7a738bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1af4cb2903711183e62f922fc235d48c7a738bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1af4cb2903711183e62f922fc235d48c7a738bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1af4cb2903711183e62f922fc235d48c7a738bb/comments", "author": null, "committer": null, "parents": [{"sha": "43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43e1e8b5b8ed9f0e4311c0974b9e459471a275b0"}], "stats": {"total": 247, "additions": 193, "deletions": 54}, "files": [{"sha": "18ca5919b72f2b54a52bf6d9642dd4a3ffa75c12", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -1,3 +1,8 @@\n+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* expr.c (expand_expr_real_1) <BIT_FIELD_REF>: Apply the big-endian\n+\tadjustment for bit-fields to all aggregate types.\n+\n 2019-06-28   Michael Meissner  <meissner@linux.ibm.com>\n \n \t* config/rs6000/predicates.md (pcrel_address):  Use"}, {"sha": "bf00e6baea7e8c2f25462c5dccaadf72c9c14018", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -1,3 +1,21 @@\n+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (make_packable_type): Remove default value.\n+\t(value_factor_p): Tweak prototype.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Add comment.\n+\t(gnat_to_gnu_component_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise.  Fetch the position of the field earlier\n+\tand simplify the condition under which the type is packed.  Declare\n+ \tlocal variable is_bitfield.  Pass 1 as max_align to make_packable_type\n+\tif it is set to true.\n+\t(copy_and_substitute_in_layout): Pass 0 to make_packable_type.\n+\t* gcc-interface/utils.c (make_packable_array_type): New function.\n+\t(make_packable_type): Use it to rewrite the type of array field.\n+\t(maybe_pad_type): Pass align parameter to make_packable_type.\n+\t(create_field_decl): Minor tweaks.\n+\t(value_factor_p): Assert that FACTOR is a power of 2 and replace the\n+\tmodulo computation by a masking operation.\n+\n 2019-06-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Remove superfluous test"}, {"sha": "4d338146fe4d99dc0000ed7c158043698b298af6", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -4481,6 +4481,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t}\n \t    }\n \n+      /* Now check if the type allows atomic access.  */\n       if (Is_Atomic_Or_VFA (gnat_entity))\n \tcheck_ok_for_atomic_type (gnu_type, gnat_entity, false);\n \n@@ -5100,6 +5101,7 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n \t}\n     }\n \n+  /* Now check if the type of the component allows atomic access.  */\n   if (Has_Atomic_Components (gnat_array) || Is_Atomic_Or_VFA (gnat_type))\n     check_ok_for_atomic_type (gnu_type, gnat_array, true);\n \n@@ -6901,6 +6903,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n      boundaries, but that should be guaranteed by the GCC memory model.  */\n   const bool needs_strict_alignment\n     = (is_atomic || is_aliased || is_independent || is_strict_alignment);\n+  bool is_bitfield;\n   tree gnu_field_type = gnat_to_gnu_type (gnat_field_type);\n   tree gnu_field_id = get_entity_name (gnat_field);\n   tree gnu_field, gnu_size, gnu_pos;\n@@ -6915,7 +6918,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   /* If a size is specified, use it.  Otherwise, if the record type is packed,\n      use the official RM size.  See \"Handling of Type'Size Values\" in Einfo\n      for further details.  */\n-  if (Known_Esize (gnat_field) || Present (gnat_clause))\n+  if (Present (gnat_clause) || Known_Esize (gnat_field))\n     gnu_size = validate_size (Esize (gnat_field), gnu_field_type, gnat_field,\n \t\t\t      FIELD_DECL, false, true);\n   else if (packed == 1)\n@@ -6927,12 +6930,36 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n   else\n     gnu_size = NULL_TREE;\n \n-  /* If we have a specified size that is smaller than that of the field's type,\n-     or a position is specified, and the field's type is a record that doesn't\n-     require strict alignment, see if we can get either an integral mode form\n-     of the type or a smaller form.  If we can, show a size was specified for\n-     the field if there wasn't one already, so we know to make this a bitfield\n-     and avoid making things wider.\n+  /* Likewise for the position.  */\n+  if (Present (gnat_clause))\n+    {\n+      gnu_pos = UI_To_gnu (Component_Bit_Offset (gnat_field), bitsizetype);\n+      is_bitfield = !value_factor_p (gnu_pos, BITS_PER_UNIT);\n+    }\n+\n+  /* If the record has rep clauses and this is the tag field, make a rep\n+     clause for it as well.  */\n+  else if (Has_Specified_Layout (gnat_record_type)\n+\t   && Chars (gnat_field) == Name_uTag)\n+    {\n+      gnu_pos = bitsize_zero_node;\n+      gnu_size = TYPE_SIZE (gnu_field_type);\n+      is_bitfield = false;\n+    }\n+\n+  else\n+    {\n+      gnu_pos = NULL_TREE;\n+      is_bitfield = false;\n+    }\n+\n+  /* If the field's type is a fixed-size record that does not require strict\n+     alignment, and the record is packed or we have a position specified for\n+     the field that makes it a bitfield or we have a specified size that is\n+     smaller than that of the field's type, then see if we can get either an\n+     integral mode form of the field's type or a smaller form.  If we can,\n+     consider that a size was specified for the field if there wasn't one\n+     already, so we know to make it a bitfield and avoid making things wider.\n \n      Changing to an integral mode form is useful when the record is packed as\n      we can then place the field at a non-byte-aligned position and so achieve\n@@ -6954,14 +6981,12 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       && !TYPE_FAT_POINTER_P (gnu_field_type)\n       && tree_fits_uhwi_p (TYPE_SIZE (gnu_field_type))\n       && (packed == 1\n+\t  || is_bitfield\n \t  || (gnu_size\n-\t      && (tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type))\n-\t\t  || (Present (gnat_clause)\n-\t\t      && !(UI_To_Int (Component_Bit_Offset (gnat_field))\n-\t\t\t   % BITS_PER_UNIT == 0\n-\t\t\t   && value_factor_p (gnu_size, BITS_PER_UNIT)))))))\n+\t      && tree_int_cst_lt (gnu_size, TYPE_SIZE (gnu_field_type)))))\n     {\n-      tree gnu_packable_type = make_packable_type (gnu_field_type, true);\n+      tree gnu_packable_type\n+\t= make_packable_type (gnu_field_type, true, is_bitfield ? 1 : 0);\n       if (gnu_packable_type != gnu_field_type)\n \t{\n \t  gnu_field_type = gnu_packable_type;\n@@ -6970,6 +6995,7 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t}\n     }\n \n+  /* Now check if the type of the field allows atomic access.  */\n   if (Is_Atomic_Or_VFA (gnat_field))\n     {\n       const unsigned int align\n@@ -6981,12 +7007,11 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n       check_ok_for_atomic_type (gnu_field_type, gnat_field, false);\n     }\n \n-  if (Present (gnat_clause))\n+  /* If a position is specified, check that it is valid.  */\n+  if (gnu_pos)\n     {\n       Entity_Id gnat_parent = Parent_Subtype (gnat_record_type);\n \n-      gnu_pos = UI_To_gnu (Component_Bit_Offset (gnat_field), bitsizetype);\n-\n       /* Ensure the position does not overlap with the parent subtype, if there\n \t is one.  This test is omitted if the parent of the tagged type has a\n \t full rep clause since, in this case, component clauses are allowed to\n@@ -7092,19 +7117,8 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t}\n     }\n \n-  /* If the record has rep clauses and this is the tag field, make a rep\n-     clause for it as well.  */\n-  else if (Has_Specified_Layout (gnat_record_type)\n-\t   && Chars (gnat_field) == Name_uTag)\n-    {\n-      gnu_pos = bitsize_zero_node;\n-      gnu_size = TYPE_SIZE (gnu_field_type);\n-    }\n-\n   else\n     {\n-      gnu_pos = NULL_TREE;\n-\n       /* If we are packing the record and the field is BLKmode, round the\n \t size up to a byte boundary.  */\n       if (packed && TYPE_MODE (gnu_field_type) == BLKmode && gnu_size)\n@@ -9681,7 +9695,7 @@ copy_and_substitute_in_layout (Entity_Id gnat_new_type,\n \t    if (RECORD_OR_UNION_TYPE_P (gnu_field_type)\n \t\t&& !TYPE_FAT_POINTER_P (gnu_field_type)\n \t\t&& tree_fits_uhwi_p (TYPE_SIZE (gnu_field_type)))\n-\t      gnu_field_type = make_packable_type (gnu_field_type, true);\n+\t      gnu_field_type = make_packable_type (gnu_field_type, true, 0);\n \t  }\n \n \telse"}, {"sha": "f7415c7f1f132abc5fc165fbd8c4cedf3e6b6f02", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -126,7 +126,7 @@ extern tree make_aligning_type (tree type, unsigned int align, tree size,\n    MAX_ALIGN alignment if the value is non-zero.  If so, return the new\n    type; if not, return the original type.  */\n extern tree make_packable_type (tree type, bool in_record,\n-\t\t\t\tunsigned int max_align = 0);\n+\t\t\t\tunsigned int max_align);\n \n /* Given a type TYPE, return a new type whose size is appropriate for SIZE.\n    If TYPE is the best type, return it.  Otherwise, make a new type.  We\n@@ -837,7 +837,7 @@ extern unsigned int known_alignment (tree exp);\n \n /* Return true if VALUE is a multiple of FACTOR. FACTOR must be a power\n    of 2.  */\n-extern bool value_factor_p (tree value, HOST_WIDE_INT factor);\n+extern bool value_factor_p (tree value, unsigned HOST_WIDE_INT factor);\n \n /* Build an atomic load for the underlying atomic object in SRC.  SYNC is\n    true if the load requires synchronization.  */"}, {"sha": "c4842b2e72097dc10ba0079ab47ebc7e910f4cba", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 65, "deletions": 20, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -984,20 +984,55 @@ make_aligning_type (tree type, unsigned int align, tree size,\n   return record_type;\n }\n \n+/* TYPE is an ARRAY_TYPE that is being used as the type of a field in a packed\n+   record.  See if we can rewrite it as a type that has non-BLKmode, which we\n+   can pack tighter in the packed record.  If so, return the new type; if not,\n+   return the original type.  */\n+\n+static tree\n+make_packable_array_type (tree type)\n+{\n+  const unsigned HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE (type));\n+  unsigned HOST_WIDE_INT new_size;\n+  unsigned int new_align;\n+\n+  /* No point in doing anything if the size is either zero or too large for an\n+     integral mode, or if the type already has non-BLKmode.  */\n+  if (size == 0 || size > MAX_FIXED_MODE_SIZE || TYPE_MODE (type) != BLKmode)\n+    return type;\n+\n+  /* Punt if the component type is an aggregate type for now.  */\n+  if (AGGREGATE_TYPE_P (TREE_TYPE (type)))\n+    return type;\n+\n+  tree new_type = copy_type (type);\n+\n+  new_size = ceil_pow2 (size);\n+  new_align = MIN (new_size, BIGGEST_ALIGNMENT);\n+  SET_TYPE_ALIGN (new_type, new_align);\n+\n+  TYPE_SIZE (new_type) = bitsize_int (new_size);\n+  TYPE_SIZE_UNIT (new_type) = size_int (new_size / BITS_PER_UNIT);\n+\n+  SET_TYPE_MODE (new_type, mode_for_size (new_size, MODE_INT, 1).else_blk ());\n+\n+  return new_type;\n+}\n+\n /* TYPE is a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE that is being used\n-   as the field type of a packed record if IN_RECORD is true, or as the\n-   component type of a packed array if IN_RECORD is false.  See if we can\n-   rewrite it either as a type that has non-BLKmode, which we can pack\n+   as the type of a field in a packed record if IN_RECORD is true, or as\n+   the component type of a packed array if IN_RECORD is false.  See if we\n+   can rewrite it either as a type that has non-BLKmode, which we can pack\n    tighter in the packed record case, or as a smaller type with at most\n    MAX_ALIGN alignment if the value is non-zero.  If so, return the new\n    type; if not, return the original type.  */\n \n tree\n make_packable_type (tree type, bool in_record, unsigned int max_align)\n {\n-  unsigned HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE (type));\n+  const unsigned HOST_WIDE_INT size = tree_to_uhwi (TYPE_SIZE (type));\n+  const unsigned int align = TYPE_ALIGN (type);\n   unsigned HOST_WIDE_INT new_size;\n-  unsigned int align = TYPE_ALIGN (type);\n   unsigned int new_align;\n \n   /* No point in doing anything if the size is zero.  */\n@@ -1058,10 +1093,19 @@ make_packable_type (tree type, bool in_record, unsigned int max_align)\n       tree new_field_type = TREE_TYPE (field);\n       tree new_field, new_field_size;\n \n-      if (RECORD_OR_UNION_TYPE_P (new_field_type)\n-\t  && !TYPE_FAT_POINTER_P (new_field_type)\n+      if (AGGREGATE_TYPE_P (new_field_type)\n \t  && tree_fits_uhwi_p (TYPE_SIZE (new_field_type)))\n-\tnew_field_type = make_packable_type (new_field_type, true, max_align);\n+\t{\n+\t  if (RECORD_OR_UNION_TYPE_P (new_field_type)\n+\t      && !TYPE_FAT_POINTER_P (new_field_type))\n+\t    new_field_type\n+\t      = make_packable_type (new_field_type, true, max_align);\n+\t  else if (in_record\n+\t\t   && max_align > 0\n+\t\t   && max_align < BITS_PER_UNIT\n+\t\t   && TREE_CODE (new_field_type) == ARRAY_TYPE)\n+\t    new_field_type = make_packable_array_type (new_field_type);\n+\t}\n \n       /* However, for the last field in a not already packed record type\n \t that is of an aggregate type, we need to use the RM size in the\n@@ -1411,7 +1455,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n      different modes, a VIEW_CONVERT_EXPR will be required for converting\n      between them and it might be hard to overcome afterwards, including\n      at the RTL level when the stand-alone object is accessed as a whole.  */\n-  if (align != 0\n+  if (align > 0\n       && RECORD_OR_UNION_TYPE_P (type)\n       && TYPE_MODE (type) == BLKmode\n       && !TYPE_BY_REFERENCE_P (type)\n@@ -1422,7 +1466,7 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n \t  || (TREE_CODE (size) == INTEGER_CST\n \t      && compare_tree_int (size, MAX_FIXED_MODE_SIZE) <= 0)))\n     {\n-      tree packable_type = make_packable_type (type, true);\n+      tree packable_type = make_packable_type (type, true, align);\n       if (TYPE_MODE (packable_type) != BLKmode\n \t  && align >= TYPE_ALIGN (packable_type))\n         type = packable_type;\n@@ -2790,10 +2834,9 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n \tsize = round_up (size, BITS_PER_UNIT);\n     }\n \n-  /* If we may, according to ADDRESSABLE, make a bitfield when the size is\n-     specified for two reasons: first if the size differs from the natural\n-     size; second, if the alignment is insufficient.  There are a number of\n-     ways the latter can be true.\n+  /* If we may, according to ADDRESSABLE, then make a bitfield when the size\n+     is specified for two reasons: first, when it differs from the natural\n+     size; second, when the alignment is insufficient.\n \n      We never make a bitfield if the type of the field has a nonconstant size,\n      because no such entity requiring bitfield operations should reach here.\n@@ -2809,17 +2852,17 @@ create_field_decl (tree name, tree type, tree record_type, tree size, tree pos,\n       && size\n       && TREE_CODE (size) == INTEGER_CST\n       && TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST\n-      && (!tree_int_cst_equal (size, TYPE_SIZE (type))\n+      && (packed\n+\t  || !tree_int_cst_equal (size, TYPE_SIZE (type))\n \t  || (pos && !value_factor_p (pos, TYPE_ALIGN (type)))\n-\t  || packed\n-\t  || (TYPE_ALIGN (record_type) != 0\n+\t  || (TYPE_ALIGN (record_type)\n \t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (type))))\n     {\n       DECL_BIT_FIELD (field_decl) = 1;\n       DECL_SIZE (field_decl) = size;\n       if (!packed && !pos)\n \t{\n-\t  if (TYPE_ALIGN (record_type) != 0\n+\t  if (TYPE_ALIGN (record_type)\n \t      && TYPE_ALIGN (record_type) < TYPE_ALIGN (type))\n \t    SET_DECL_ALIGN (field_decl, TYPE_ALIGN (record_type));\n \t  else\n@@ -3001,10 +3044,12 @@ process_attributes (tree *node, struct attrib **attr_list, bool in_place,\n    a power of 2. */\n \n bool\n-value_factor_p (tree value, HOST_WIDE_INT factor)\n+value_factor_p (tree value, unsigned HOST_WIDE_INT factor)\n {\n+  gcc_checking_assert (pow2p_hwi (factor));\n+\n   if (tree_fits_uhwi_p (value))\n-    return tree_to_uhwi (value) % factor == 0;\n+    return (tree_to_uhwi (value) & (factor - 1)) == 0;\n \n   if (TREE_CODE (value) == MULT_EXPR)\n     return (value_factor_p (TREE_OPERAND (value, 0), factor)"}, {"sha": "4acf250dd3ce0e5cf995cd2f3dfe32ce028d97a6", "filename": "gcc/expr.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -10893,12 +10893,12 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t    if (MEM_P (op0) && REG_P (XEXP (op0, 0)))\n \t      mark_reg_pointer (XEXP (op0, 0), MEM_ALIGN (op0));\n \n-\t    /* If the result has a record type and the extraction is done in\n+\t    /* If the result has aggregate type and the extraction is done in\n \t       an integral mode, then the field may be not aligned on a byte\n \t       boundary; in this case, if it has reverse storage order, it\n \t       needs to be extracted as a scalar field with reverse storage\n \t       order and put back into memory order afterwards.  */\n-\t    if (TREE_CODE (type) == RECORD_TYPE\n+\t    if (AGGREGATE_TYPE_P (type)\n \t\t&& GET_MODE_CLASS (ext_mode) == MODE_INT)\n \t      reversep = TYPE_REVERSE_STORAGE_ORDER (type);\n \n@@ -10908,13 +10908,13 @@ expand_expr_real_1 (tree exp, rtx target, machine_mode tmode,\n \t\t\t\t      ? NULL_RTX : target),\n \t\t\t\t     ext_mode, ext_mode, reversep, alt_rtl);\n \n-\t    /* If the result has a record type and the mode of OP0 is an\n+\t    /* If the result has aggregate type and the mode of OP0 is an\n \t       integral mode then, if BITSIZE is narrower than this mode\n \t       and this is for big-endian data, we must put the field\n \t       into the high-order bits.  And we must also put it back\n \t       into memory order if it has been previously reversed.  */\n \t    scalar_int_mode op0_mode;\n-\t    if (TREE_CODE (type) == RECORD_TYPE\n+\t    if (AGGREGATE_TYPE_P (type)\n \t\t&& is_int_mode (GET_MODE (op0), &op0_mode))\n \t      {\n \t\tHOST_WIDE_INT size = GET_MODE_BITSIZE (op0_mode);"}, {"sha": "7766716fd54b2716124a1c6d08904abb74981ea0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -1,3 +1,8 @@\n+2019-06-29  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/array35.adb: New test.\n+\t* gnat.dg/array36.adb: Likewise.\n+\n 2019-06-28  Jan Beulich  <jbeulich@suse.com>\n \n \t* gcc.target/i386/gfni-5.c: New."}, {"sha": "1c0f998551d398ebf9af2d0e0f6cec3564db62b1", "filename": "gcc/testsuite/gnat.dg/array35.adb", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2Fgnat.dg%2Farray35.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2Fgnat.dg%2Farray35.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray35.adb?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -0,0 +1,24 @@\n+--  { dg-do run }\n+\n+procedure Array35 is\n+\n+   subtype Str is String (1 .. 3);\n+\n+   type T is record\n+      B : Boolean;\n+      S : Str;\n+   end record;\n+\n+   for T use record\n+      B at 0 range 0 .. 0;\n+      S at 0 range 1 .. 24;\n+   end record;\n+\n+   X : T := (B => True, S => \"123\");\n+\n+begin\n+   X.B := False;\n+   if X.S /= \"123\" then\n+      raise Program_Error;\n+   end if;\n+end;"}, {"sha": "9f4314cb9ad630b76aad36890da37c6d28014f6a", "filename": "gcc/testsuite/gnat.dg/array36.adb", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2Fgnat.dg%2Farray36.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b1af4cb2903711183e62f922fc235d48c7a738bb/gcc%2Ftestsuite%2Fgnat.dg%2Farray36.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray36.adb?ref=b1af4cb2903711183e62f922fc235d48c7a738bb", "patch": "@@ -0,0 +1,28 @@\n+--  { dg-do run }\n+\n+procedure Array36 is\n+\n+   subtype Str is String (1 .. 3);\n+\n+   type Rec is record\n+      S : Str;\n+   end record;\n+\n+   type T is record\n+      B : Boolean;\n+      R : Rec;\n+   end record;\n+\n+   for T use record\n+      B at 0 range 0 .. 0;\n+      R at 0 range 1 .. 24;\n+   end record;\n+\n+   X : T := (B => True, R => (S => \"123\"));\n+\n+begin\n+   X.B := False;\n+   if X.R.S /= \"123\" then\n+      raise Program_Error;\n+   end if;\n+end;"}]}