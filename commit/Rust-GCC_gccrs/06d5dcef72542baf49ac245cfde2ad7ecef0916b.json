{"sha": "06d5dcef72542baf49ac245cfde2ad7ecef0916b", "node_id": "C_kwDOANBUbNoAKDA2ZDVkY2VmNzI1NDJiYWY0OWFjMjQ1Y2ZkZTJhZDdlY2VmMDkxNmI", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-12-10T20:38:35Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-12-15T22:47:43Z"}, "message": "c++: Allow constexpr decltype(auto) [PR102229]\n\nMy r11-2202 was trying to enforce [dcl.type.auto.deduct]/4, which says\n\"If the placeholder-type-specifier is of the form type-constraint[opt]\ndecltype(auto), T shall be the placeholder alone.\"  But this made us\nreject 'constexpr decltype(auto)', which, after clarification from CWG,\nshould be valid.  [dcl.type.auto.deduct]/4 is supposed to be a syntactic\nconstraint, not semantic, so it's OK that the constexpr marks the object\nas const.\n\nAs a consequence, checking TYPE_QUALS in do_auto_deduction is too late,\nand we have a FIXME there anyway.  So in this patch I'm attempting to\ndetect 'const decltype(auto)' earlier.  If I'm going to use TYPE_QUALS,\nit needs to happen before we mark the object as const due to constexpr,\nthat is, before grokdeclarator's\n\n  /* A `constexpr' specifier used in an object declaration declares\n     the object as `const'.  */\n  if (constexpr_p && innermost_code != cdk_function)\n    ...\n\nConstrained decltype(auto) was a little problem, hence the TYPENAME\ncheck.  But in a typename context you can't use decltype(auto) anyway,\nI think.\n\n\tPR c++/102229\n\ngcc/cp/ChangeLog:\n\n\t* decl.c (check_decltype_auto): New.\n\t(grokdeclarator): Call it.\n\t* pt.c (do_auto_deduction): Don't check decltype(auto) here.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1y/decltype-auto5.C: New test.", "tree": {"sha": "e988e7ac830e95c16f9028d6a3e83d67ac84afcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e988e7ac830e95c16f9028d6a3e83d67ac84afcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d5dcef72542baf49ac245cfde2ad7ecef0916b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d5dcef72542baf49ac245cfde2ad7ecef0916b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d5dcef72542baf49ac245cfde2ad7ecef0916b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d5dcef72542baf49ac245cfde2ad7ecef0916b/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45b768cb80930c0beeb735727349c44ec66f7dd2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45b768cb80930c0beeb735727349c44ec66f7dd2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45b768cb80930c0beeb735727349c44ec66f7dd2"}], "stats": {"total": 106, "additions": 74, "deletions": 32}, "files": [{"sha": "2e0339858c33c35bfbb18f1f04b033cb55413aec", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=06d5dcef72542baf49ac245cfde2ad7ecef0916b", "patch": "@@ -11354,6 +11354,33 @@ name_unnamed_type (tree type, tree decl)\n   gcc_assert (!TYPE_UNNAMED_P (type));\n }\n \n+/* Check that decltype(auto) was well-formed: only plain decltype(auto)\n+   is allowed.  TYPE might contain a decltype(auto).  Returns true if\n+   there was a problem, false otherwise.  */\n+\n+static bool\n+check_decltype_auto (location_t loc, tree type)\n+{\n+  if (tree a = type_uses_auto (type))\n+    {\n+      if (AUTO_IS_DECLTYPE (a))\n+\t{\n+\t  if (a != type)\n+\t    {\n+\t      error_at (loc, \"%qT as type rather than plain \"\n+\t\t\t\"%<decltype(auto)%>\", type);\n+\t      return true;\n+\t    }\n+\t  else if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n+\t    {\n+\t      error_at (loc, \"%<decltype(auto)%> cannot be cv-qualified\");\n+\t      return true;\n+\t    }\n+\t}\n+    }\n+  return false;\n+}\n+\n /* Given declspecs and a declarator (abstract or otherwise), determine\n    the name and type of the object declared and construct a DECL node\n    for it.\n@@ -12702,25 +12729,9 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t\t  \"allowed\");\n \t\treturn error_mark_node;\n \t      }\n-\t    /* Only plain decltype(auto) is allowed.  */\n-\t    if (tree a = type_uses_auto (type))\n-\t      {\n-\t\tif (AUTO_IS_DECLTYPE (a))\n-\t\t  {\n-\t\t    if (a != type)\n-\t\t      {\n-\t\t\terror_at (typespec_loc, \"%qT as type rather than \"\n-\t\t\t\t  \"plain %<decltype(auto)%>\", type);\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t    else if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n-\t\t      {\n-\t\t\terror_at (typespec_loc, \"%<decltype(auto)%> cannot be \"\n-\t\t\t\t  \"cv-qualified\");\n-\t\t\treturn error_mark_node;\n-\t\t      }\n-\t\t  }\n-\t      }\n+\n+\t    if (check_decltype_auto (typespec_loc, type))\n+\t      return error_mark_node;\n \n \t    if (ctype == NULL_TREE\n \t\t&& decl_context == FIELD\n@@ -13080,6 +13091,15 @@ grokdeclarator (const cp_declarator *declarator,\n \n   id_loc = declarator ? declarator->id_loc : input_location;\n \n+  if (innermost_code != cdk_function\n+    /* Don't check this if it can be the artifical decltype(auto)\n+       we created when building a constraint in a compound-requirement:\n+       that the type-constraint is plain is going to be checked in\n+       cp_parser_compound_requirement.  */\n+      && decl_context != TYPENAME\n+      && check_decltype_auto (id_loc, type))\n+    return error_mark_node;\n+\n   /* A `constexpr' specifier used in an object declaration declares\n      the object as `const'.  */\n   if (constexpr_p && innermost_code != cdk_function)"}, {"sha": "62a058d583f877ef9ba909114129907b3bdefb47", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=06d5dcef72542baf49ac245cfde2ad7ecef0916b", "patch": "@@ -29894,19 +29894,6 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n \treturn error_mark_node;\n       targs = make_tree_vec (1);\n       TREE_VEC_ELT (targs, 0) = deduced;\n-      /* FIXME: These errors ought to be diagnosed at parse time. */\n-      if (type != auto_node)\n-\t{\n-          if (complain & tf_error)\n-\t    error (\"%qT as type rather than plain %<decltype(auto)%>\", type);\n-\t  return error_mark_node;\n-\t}\n-      else if (TYPE_QUALS (type) != TYPE_UNQUALIFIED)\n-\t{\n-\t  if (complain & tf_error)\n-\t    error (\"%<decltype(auto)%> cannot be cv-qualified\");\n-\t  return error_mark_node;\n-\t}\n     }\n   else\n     {"}, {"sha": "01cc54fb71d5e7a4c2bb3c7368611abca76b57c9", "filename": "gcc/testsuite/g++.dg/cpp1y/decltype-auto5.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5dcef72542baf49ac245cfde2ad7ecef0916b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto5.C?ref=06d5dcef72542baf49ac245cfde2ad7ecef0916b", "patch": "@@ -0,0 +1,35 @@\n+// PR c++/102229\n+// { dg-do compile { target c++14 } }\n+\n+struct S {\n+  constexpr static decltype(auto) x = 42;\n+  const constexpr static decltype(auto) y = 42; // { dg-error \"cannot be cv-qualified\" }\n+\n+  constexpr decltype(auto) mfn1 () { return 0; }\n+  const constexpr decltype(auto) mfn2 () { return 0; } // { dg-error \"cannot be cv-qualified\" }\n+};\n+\n+constexpr decltype(auto) i = 42;\n+const constexpr decltype(auto) j = 42; // { dg-error \"cannot be cv-qualified\" }\n+\n+constexpr decltype(auto) fn() { return 42; }\n+const decltype(auto) fn2() { return 42; } // { dg-error \"cannot be cv-qualified\" }\n+\n+auto constexpr foo() -> const decltype(auto) // { dg-error \"cannot be cv-qualified\" }\n+{\n+  return 0;\n+}\n+\n+#if __cpp_concepts\n+template<typename>\n+concept C = true;\n+\n+constexpr C decltype(auto) x1 = 0;\n+const constexpr C decltype(auto) x2 = 0; // { dg-error \"cannot be cv-qualified\" \"\" { target c++20 } }\n+\n+constexpr C decltype(auto) fn3() { return 0; }\n+const constexpr C decltype(auto) fn4() { return 0; } // { dg-error \"cannot be cv-qualified\" \"\" { target c++20 } }\n+#endif\n+\n+template<const decltype(auto) = 42> // { dg-error \"cannot be cv-qualified\" }\n+void g ();"}]}