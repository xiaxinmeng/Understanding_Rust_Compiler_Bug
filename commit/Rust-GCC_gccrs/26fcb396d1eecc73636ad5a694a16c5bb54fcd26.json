{"sha": "26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjZmY2IzOTZkMWVlY2M3MzYzNmFkNWE2OTRhMTZjNWJiNTRmY2QyNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-23T22:04:53Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-23T22:04:53Z"}, "message": "compiler: add go_debug and use it for debug messages\n    \n    GCC recently added a new warning -Wformat-diag which does a lot of\n    rigorous checks on GCC diagnostic messages.  This produces a number of\n    unnecessary diagnostics on gofrontend diagnostic output, such as\n    \n    ../../trunk/gcc/go/gofrontend/escape.cc: In member function \u2018virtual int Escape_analysis_assign::statement(Block*, size_t*, Statement*)\u2019:\n    ../../trunk/gcc/go/gofrontend/escape.cc:1336:33: warning: spurious leading punctuation sequence \u2018[\u2019 in format [-Wformat-diag]\n     1336 |       go_inform(s->location(), \"[%d] %s esc: %s\",\n          |                                 ^\n    \n    ../../trunk/gcc/go/gofrontend/escape.cc: In member function \u2018void Escape_analysis_assign::call(Call_expression*)\u2019:\n    ../../trunk/gcc/go/gofrontend/escape.cc:1964:17: warning: unquoted operator \u2018::\u2019 in format [-Wformat-diag]\n     1964 |         \"esccall:: indirect call <- %s, untracked\",\n          |                 ^~\n    \n    ../../trunk/gcc/go/gofrontend/escape.cc:1964:34: warning: unbalanced punctuation character \u2018<\u2019 in format [-Wformat-diag]\n     1964 |         \"esccall:: indirect call <- %s, untracked\",\n          |                                  ^\n    \n    Avoid these messages by adding a new function go_debug that uses only\n    printf formatting, not GCC diagnostic formatting, and change all the\n    optimization debugging messages to use it.  None of the debugging\n    messages used the GCC diagnostic formatting specifiers anyhow.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/183437\n\nFrom-SVN: r272607", "tree": {"sha": "53b821c50064bde8bbd29d5745b030eb7d96c1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53b821c50064bde8bbd29d5745b030eb7d96c1f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/comments", "author": null, "committer": null, "parents": [{"sha": "d7e96c4608ae4e37334add5ecc2bea594a9e940a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7e96c4608ae4e37334add5ecc2bea594a9e940a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7e96c4608ae4e37334add5ecc2bea594a9e940a"}], "stats": {"total": 240, "additions": 137, "deletions": 103}, "files": [{"sha": "1f9c94ff8f790eab508e41324b36c0a0a0a0d21a", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -1,4 +1,4 @@\n-9b5a43baaf391005989d140109261e5a8e1b1b63\n+6bb63a21434b3360dbe7e4bd34889734f361d434\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "4cfb48021f8338a303bb72889f14e19419d5523e", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 99, "deletions": 99, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -964,9 +964,9 @@ Gogo::analyze_escape()\n                 {\n                   done = false;\n                   if (this->debug_escape_level() > 2)\n-                    go_inform((*n)->location(), \"Reflooding %s %s\",\n-                              debug_function_name((*n)->state(context, NULL)->fn).c_str(),\n-                              (*n)->ast_format(this).c_str());\n+                    go_debug((*n)->location(), \"Reflooding %s %s\",\n+\t\t\t     debug_function_name((*n)->state(context, NULL)->fn).c_str(),\n+\t\t\t     (*n)->ast_format(this).c_str());\n                   escapes[*n] = (*n)->encoding();\n                   this->propagate_escape(context, *n);\n                 }\n@@ -990,9 +990,9 @@ Gogo::analyze_escape()\n \t    {\n \t      Node::Escape_state* state = (*n)->state(context, NULL);\n \t      if ((*n)->encoding() == Node::ESCAPE_NONE)\n-\t\tgo_inform((*n)->location(), \"%s %s does not escape\",\n-\t\t\t  strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n-\t\t\t  (*n)->ast_format(this).c_str());\n+\t\tgo_debug((*n)->location(), \"%s %s does not escape\",\n+\t\t\t strip_packed_prefix(this, debug_function_name(state->fn)).c_str(),\n+\t\t\t (*n)->ast_format(this).c_str());\n \t    }\n \t}\n       delete context;\n@@ -1333,9 +1333,9 @@ Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n     {\n       Node* n = Node::make_node(s);\n       std::string fn_name = this->context_->current_function_name();\n-      go_inform(s->location(), \"[%d] %s esc: %s\",\n-\t        this->context_->loop_depth(), fn_name.c_str(),\n-\t        n->ast_format(gogo).c_str());\n+      go_debug(s->location(), \"[%d] %s esc: %s\",\n+\t       this->context_->loop_depth(), fn_name.c_str(),\n+\t       n->ast_format(gogo).c_str());\n     }\n \n   switch (s->classification())\n@@ -1495,9 +1495,9 @@ move_to_heap(Gogo* gogo, Expression *expr)\n     {\n       Node* n = Node::make_node(expr);\n       if (gogo->debug_escape_level() != 0)\n-        go_inform(n->definition_location(),\n-                  \"moved to heap: %s\",\n-                  n->ast_format(gogo).c_str());\n+        go_debug(n->definition_location(),\n+\t\t \"moved to heap: %s\",\n+\t\t n->ast_format(gogo).c_str());\n       if (gogo->compiling_runtime() && gogo->package_name() == \"runtime\")\n         go_error_at(expr->location(),\n                     \"%s escapes to heap, not allowed in runtime\",\n@@ -1519,8 +1519,8 @@ Escape_analysis_assign::expression(Expression** pexpr)\n       && n->is_big(this->context_))\n     {\n       if (debug_level > 1)\n-\tgo_inform((*pexpr)->location(), \"%s too large for stack\",\n-                  n->ast_format(gogo).c_str());\n+\tgo_debug((*pexpr)->location(), \"%s too large for stack\",\n+\t\t n->ast_format(gogo).c_str());\n       move_to_heap(gogo, *pexpr);\n       n->set_encoding(Node::ESCAPE_HEAP);\n       (*pexpr)->address_taken(true);\n@@ -1534,9 +1534,9 @@ Escape_analysis_assign::expression(Expression** pexpr)\n     {\n       Node* n = Node::make_node(*pexpr);\n       std::string fn_name = this->context_->current_function_name();\n-      go_inform((*pexpr)->location(), \"[%d] %s esc: %s\",\n-\t\tthis->context_->loop_depth(), fn_name.c_str(),\n-\t\tn->ast_format(gogo).c_str());\n+      go_debug((*pexpr)->location(), \"[%d] %s esc: %s\",\n+\t       this->context_->loop_depth(), fn_name.c_str(),\n+\t       n->ast_format(gogo).c_str());\n     }\n \n   switch ((*pexpr)->classification())\n@@ -1566,8 +1566,8 @@ Escape_analysis_assign::expression(Expression** pexpr)\n                       Node* appended = Node::make_node(call->args()->back());\n                       this->assign_deref(this->context_->sink(), appended);\n                       if (debug_level > 2)\n-                        go_inform((*pexpr)->location(),\n-                                  \"special treatment of append(slice1, slice2...)\");\n+                        go_debug((*pexpr)->location(),\n+\t\t\t\t \"special treatment of append(slice1, slice2...)\");\n                     }\n                   else\n                     {\n@@ -1960,9 +1960,9 @@ Escape_analysis_assign::call(Call_expression* call)\n            ++p)\n \t{\n \t  if (debug_level > 2)\n-\t    go_inform(call->location(),\n-\t\t      \"esccall:: indirect call <- %s, untracked\",\n-\t\t      (*p)->ast_format(gogo).c_str());\n+\t    go_debug(call->location(),\n+\t\t     \"esccall:: indirect call <- %s, untracked\",\n+\t\t     (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n \n@@ -1987,8 +1987,8 @@ Escape_analysis_assign::call(Call_expression* call)\n       && !fntype->is_tagged())\n     {\n       if (debug_level > 2)\n-\tgo_inform(call->location(), \"esccall:: %s in recursive group\",\n-\t\t  call_node->ast_format(gogo).c_str());\n+\tgo_debug(call->location(), \"esccall:: %s in recursive group\",\n+\t\t call_node->ast_format(gogo).c_str());\n \n       Function* f = fn->named_object()->func_value();\n       const Bindings* callee_bindings = f->block()->bindings();\n@@ -2059,8 +2059,8 @@ Escape_analysis_assign::call(Call_expression* call)\n \t  for (; p != arg_nodes.end(); ++p)\n \t    {\n \t      if (debug_level > 2)\n-\t\tgo_inform(call->location(), \"esccall:: ... <- %s, untracked\",\n-\t\t\t  (*p)->ast_format(gogo).c_str());\n+\t\tgo_debug(call->location(), \"esccall:: ... <- %s, untracked\",\n+\t\t\t (*p)->ast_format(gogo).c_str());\n \t      this->assign(this->context_->sink(), *p);\n \t    }\n \t}\n@@ -2069,8 +2069,8 @@ Escape_analysis_assign::call(Call_expression* call)\n     }\n \n   if (debug_level > 2)\n-    go_inform(call->location(), \"esccall:: %s not recursive\",\n-\t      call_node->ast_format(gogo).c_str());\n+    go_debug(call->location(), \"esccall:: %s not recursive\",\n+\t     call_node->ast_format(gogo).c_str());\n \n   Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n   if (!call_state->retvals.empty())\n@@ -2146,8 +2146,8 @@ Escape_analysis_assign::call(Call_expression* call)\n       for (; p != arg_nodes.end(); ++p)\n \t{\n \t  if (debug_level > 2)\n-\t    go_inform(call->location(), \"esccall:: ... <- %s, untracked\",\n-                      (*p)->ast_format(gogo).c_str());\n+\t    go_debug(call->location(), \"esccall:: ... <- %s, untracked\",\n+\t\t     (*p)->ast_format(gogo).c_str());\n \t  this->assign(this->context_->sink(), *p);\n \t}\n     }\n@@ -2165,13 +2165,13 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n   Gogo* gogo = this->context_->gogo();\n   int debug_level = gogo->debug_escape_level();\n   if (debug_level > 1)\n-    go_inform(dst->location(), \"[%d] %s escassign: %s(%s)[%s] = %s(%s)[%s]\",\n-\t      this->context_->loop_depth(),\n-\t      strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n-\t      dst->ast_format(gogo).c_str(), dst->details().c_str(),\n-\t      dst->op_format().c_str(),\n-\t      src->ast_format(gogo).c_str(), src->details().c_str(),\n-\t      src->op_format().c_str());\n+    go_debug(dst->location(), \"[%d] %s escassign: %s(%s)[%s] = %s(%s)[%s]\",\n+\t     this->context_->loop_depth(),\n+\t     strip_packed_prefix(gogo, this->context_->current_function_name()).c_str(),\n+\t     dst->ast_format(gogo).c_str(), dst->details().c_str(),\n+\t     dst->op_format().c_str(),\n+\t     src->ast_format(gogo).c_str(), src->details().c_str(),\n+\t     src->op_format().c_str());\n \n   if (dst->is_indirect())\n     // Lose track of the dereference.\n@@ -2637,9 +2637,9 @@ Escape_analysis_assign::assign_from_note(std::string* note,\n     }\n \n   if (this->context_->gogo()->debug_escape_level() > 2)\n-    go_inform(src->location(), \"assignfromtag:: src=%s em=%s\",\n-              src->ast_format(context_->gogo()).c_str(),\n-\t      Escape_note::make_tag(enc).c_str());\n+    go_debug(src->location(), \"assignfromtag:: src=%s em=%s\",\n+\t     src->ast_format(context_->gogo()).c_str(),\n+\t     Escape_note::make_tag(enc).c_str());\n \n   if (enc == Node::ESCAPE_UNKNOWN)\n     {\n@@ -2707,8 +2707,8 @@ Escape_analysis_assign::flows(Node* dst, Node* src)\n \n   Gogo* gogo = this->context_->gogo();\n   if (gogo->debug_escape_level() > 2)\n-    go_inform(Linemap::unknown_location(), \"flows:: %s <- %s\",\n-              dst->ast_format(gogo).c_str(), src->ast_format(gogo).c_str());\n+    go_debug(Linemap::unknown_location(), \"flows:: %s <- %s\",\n+\t     dst->ast_format(gogo).c_str(), src->ast_format(gogo).c_str());\n \n   if (dst_state->flows.empty())\n     this->context_->add_dst(dst);\n@@ -2864,18 +2864,18 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n   Gogo* gogo = this->context_->gogo();\n   int debug_level = gogo->debug_escape_level();\n   if (debug_level > 1)\n-    go_inform(Linemap::unknown_location(),\n-\t      \"escwalk: level:{%d %d} depth:%d \"\n-\t      \"op=%s %s(%s) \"\n-\t      \"scope:%s[%d] \"\n-\t      \"extraloopdepth=%d\",\n-\t      level.value(), level.suffix_value(), this->context_->pdepth(),\n-\t      src->op_format().c_str(),\n-\t      src->ast_format(gogo).c_str(),\n-\t      src->details().c_str(),\n-\t      debug_function_name(src_state->fn).c_str(),\n-\t      src_state->loop_depth,\n-\t      extra_loop_depth);\n+    go_debug(Linemap::unknown_location(),\n+\t     \"escwalk: level:{%d %d} depth:%d \"\n+\t     \"op=%s %s(%s) \"\n+\t     \"scope:%s[%d] \"\n+\t     \"extraloopdepth=%d\",\n+\t     level.value(), level.suffix_value(), this->context_->pdepth(),\n+\t     src->op_format().c_str(),\n+\t     src->ast_format(gogo).c_str(),\n+\t     src->details().c_str(),\n+\t     debug_function_name(src_state->fn).c_str(),\n+\t     src_state->loop_depth,\n+\t     extra_loop_depth);\n \n   this->context_->increase_pdepth();\n \n@@ -2911,17 +2911,17 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       if (debug_level != 0)\n \t{\n \t  if (debug_level == 1)\n-\t    go_inform(src->definition_location(),\n-\t\t      \"leaking param: %s to result %s level=%d\",\n-\t\t      src->ast_format(gogo).c_str(),\n-\t\t      dst->ast_format(gogo).c_str(),\n-\t\t      level.value());\n+\t    go_debug(src->definition_location(),\n+\t\t     \"leaking param: %s to result %s level=%d\",\n+\t\t     src->ast_format(gogo).c_str(),\n+\t\t     dst->ast_format(gogo).c_str(),\n+\t\t     level.value());\n \t  else\n-\t    go_inform(src->definition_location(),\n-\t\t      \"leaking param: %s to result %s level={%d %d}\",\n-\t\t      src->ast_format(gogo).c_str(),\n-\t\t      dst->ast_format(gogo).c_str(),\n-\t\t      level.value(), level.suffix_value());\n+\t    go_debug(src->definition_location(),\n+\t\t     \"leaking param: %s to result %s level={%d %d}\",\n+\t\t     src->ast_format(gogo).c_str(),\n+\t\t     dst->ast_format(gogo).c_str(),\n+\t\t     level.value(), level.suffix_value());\n \t}\n \n       if ((src->encoding() & ESCAPE_MASK) != Node::ESCAPE_RETURN)\n@@ -2959,8 +2959,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t   Node::ESCAPE_NONE);\n       src->set_encoding(enc);\n       if (debug_level != 0)\n-\tgo_inform(src->definition_location(), \"mark escaped content: %s\",\n-\t\t  src->ast_format(gogo).c_str());\n+\tgo_debug(src->definition_location(), \"mark escaped content: %s\",\n+\t\t src->ast_format(gogo).c_str());\n     }\n \n   // A src object leaks if its value or address is assigned to a dst object\n@@ -2984,14 +2984,14 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t\t       Node::ESCAPE_NONE);\n \t  src->set_encoding(enc);\n \t  if (debug_level != 0 && osrcesc != src->encoding())\n-\t    go_inform(src->definition_location(), \"leaking param content: %s\",\n-\t\t      src->ast_format(gogo).c_str());\n+\t    go_debug(src->definition_location(), \"leaking param content: %s\",\n+\t\t     src->ast_format(gogo).c_str());\n \t}\n       else\n \t{\n \t  if (debug_level != 0)\n-\t    go_inform(src->definition_location(), \"leaking param: %s\",\n-                      src->ast_format(gogo).c_str());\n+\t    go_debug(src->definition_location(), \"leaking param: %s\",\n+\t\t     src->ast_format(gogo).c_str());\n \t  src->set_encoding(Node::ESCAPE_HEAP);\n \t}\n     }\n@@ -3001,8 +3001,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n       if (e->enclosed_var_expression() != NULL)\n \t{\n \t  if (src_leaks && debug_level != 0)\n-\t    go_inform(src->location(), \"leaking closure reference %s\",\n-\t\t      src->ast_format(gogo).c_str());\n+\t    go_debug(src->location(), \"leaking closure reference %s\",\n+\t\t     src->ast_format(gogo).c_str());\n \n \t  Node* enclosed_node =\n \t    Node::make_node(e->enclosed_var_expression()->variable());\n@@ -3030,15 +3030,15 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n                 {\n                   move_to_heap(gogo, underlying);\n                   if (debug_level > 1)\n-                    go_inform(src->location(),\n-                              \"%s escapes to heap, level={%d %d}, \"\n-                              \"dst.eld=%d, src.eld=%d\",\n-                              src->ast_format(gogo).c_str(), level.value(),\n-                              level.suffix_value(), dst_state->loop_depth,\n-                              mod_loop_depth);\n+                    go_debug(src->location(),\n+\t\t\t     \"%s escapes to heap, level={%d %d}, \"\n+\t\t\t     \"dst.eld=%d, src.eld=%d\",\n+\t\t\t     src->ast_format(gogo).c_str(), level.value(),\n+\t\t\t     level.suffix_value(), dst_state->loop_depth,\n+\t\t\t     mod_loop_depth);\n                   else if (debug_level > 0)\n-                    go_inform(src->location(), \"%s escapes to heap\",\n-                              src->ast_format(gogo).c_str());\n+                    go_debug(src->location(), \"%s escapes to heap\",\n+\t\t\t     src->ast_format(gogo).c_str());\n                 }\n \n \t      this->flood(level.decrease(), dst,\n@@ -3068,8 +3068,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t    {\n \t      src->set_encoding(Node::ESCAPE_HEAP);\n \t      if (debug_level != 0 && osrcesc != src->encoding())\n-\t\tgo_inform(src->location(), \"%s escapes to heap\",\n-\t\t\t  src->ast_format(gogo).c_str());\n+\t\tgo_debug(src->location(), \"%s escapes to heap\",\n+\t\t\t src->ast_format(gogo).c_str());\n \t      extra_loop_depth = mod_loop_depth;\n \t    }\n \t}\n@@ -3100,8 +3100,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n                     {\n                       src->set_encoding(Node::ESCAPE_HEAP);\n                       if (debug_level != 0 && osrcesc != src->encoding())\n-                        go_inform(src->location(), \"%s escapes to heap\",\n-                                  src->ast_format(gogo).c_str());\n+                        go_debug(src->location(), \"%s escapes to heap\",\n+\t\t\t\t src->ast_format(gogo).c_str());\n                       extra_loop_depth = mod_loop_depth;\n                     }\n                   break;\n@@ -3119,11 +3119,11 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n               // This can only happen with functions returning a single result.\n               go_assert(src_state->retvals.size() == 1);\n               if (debug_level > 2)\n-                go_inform(src->location(), \"[%d] dst %s escwalk replace src: %s with %s\",\n-                          this->context_->loop_depth(),\n-                          dst->ast_format(gogo).c_str(),\n-                          src->ast_format(gogo).c_str(),\n-                          src_state->retvals[0]->ast_format(gogo).c_str());\n+                go_debug(src->location(), \"[%d] dst %s escwalk replace src: %s with %s\",\n+\t\t\t this->context_->loop_depth(),\n+\t\t\t dst->ast_format(gogo).c_str(),\n+\t\t\t src->ast_format(gogo).c_str(),\n+\t\t\t src_state->retvals[0]->ast_format(gogo).c_str());\n               src = src_state->retvals[0];\n               src_state = src->state(this->context_, NULL);\n             }\n@@ -3133,8 +3133,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t  // Calls to Runtime::NEW get lowered into an allocation expression.\n \t  src->set_encoding(Node::ESCAPE_HEAP);\n \t  if (debug_level != 0 && osrcesc != src->encoding())\n-\t    go_inform(src->location(), \"%s escapes to heap\",\n-                      src->ast_format(gogo).c_str());\n+\t    go_debug(src->location(), \"%s escapes to heap\",\n+\t\t     src->ast_format(gogo).c_str());\n           extra_loop_depth = mod_loop_depth;\n \t}\n       else if ((e->map_literal() != NULL\n@@ -3145,8 +3145,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n         {\n           src->set_encoding(Node::ESCAPE_HEAP);\n           if (debug_level != 0 && osrcesc != src->encoding())\n-            go_inform(src->location(), \"%s escapes to heap\",\n-                      src->ast_format(gogo).c_str());\n+            go_debug(src->location(), \"%s escapes to heap\",\n+\t\t     src->ast_format(gogo).c_str());\n           extra_loop_depth = mod_loop_depth;\n         }\n       else if (e->conversion_expression() != NULL && src_leaks)\n@@ -3163,8 +3163,8 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n               // interface(T)\n               src->set_encoding(Node::ESCAPE_HEAP);\n               if (debug_level != 0 && osrcesc != src->encoding())\n-                go_inform(src->location(), \"%s escapes to heap\",\n-                          src->ast_format(gogo).c_str());\n+                go_debug(src->location(), \"%s escapes to heap\",\n+\t\t\t src->ast_format(gogo).c_str());\n               extra_loop_depth = mod_loop_depth;\n               if (tt->interface_type() != NULL\n                   && ft->has_pointer()\n@@ -3276,10 +3276,10 @@ Gogo::propagate_escape(Escape_context* context, Node* dst)\n   Node::Escape_state* state = dst->state(context, NULL);\n   Gogo* gogo = context->gogo();\n   if (gogo->debug_escape_level() > 1)\n-    go_inform(Linemap::unknown_location(), \"escflood:%d: dst %s scope:%s[%d]\",\n-\t      context->flood_id(), dst->ast_format(gogo).c_str(),\n-\t      debug_function_name(state->fn).c_str(),\n-\t      state->loop_depth);\n+    go_debug(Linemap::unknown_location(), \"escflood:%d: dst %s scope:%s[%d]\",\n+\t     context->flood_id(), dst->ast_format(gogo).c_str(),\n+\t     debug_function_name(state->fn).c_str(),\n+\t     state->loop_depth);\n \n   Escape_analysis_flood eaf(context);\n   for (std::set<Node*>::const_iterator p = state->flows.begin();"}, {"sha": "782899cc1853db5fc0f36cb55dc000f542df9d54", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -4026,7 +4026,7 @@ Type_conversion_expression::do_get_backend(Translate_context* context)\n           if (this->no_copy_)\n             {\n               if (gogo->debug_optimization())\n-                go_inform(loc, \"no copy string([]byte)\");\n+                go_debug(loc, \"no copy string([]byte)\");\n               Expression* ptr = Expression::make_slice_info(this->expr_,\n                                                             SLICE_INFO_VALUE_POINTER,\n                                                             loc);"}, {"sha": "4a091e313c128c40d0e35d8794a2bbb1d02c30de", "filename": "gcc/go/gofrontend/go-diagnostics.cc", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.cc?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -175,3 +175,25 @@ go_inform(const Location location, const char* fmt, ...)\n   go_be_inform(location, expand_message(fmt, ap));\n   va_end(ap);\n }\n+\n+// go_debug uses normal printf formatting, not GCC diagnostic formatting.\n+\n+void\n+go_debug(const Location location, const char* fmt, ...)\n+{\n+  va_list ap;\n+\n+  va_start(ap, fmt);\n+  char* mbuf = NULL;\n+  int nwr = vasprintf(&mbuf, fmt, ap);\n+  va_end(ap);\n+  if (nwr == -1)\n+    {\n+      go_be_error_at(Linemap::unknown_location(),\n+\t\t     \"memory allocation failed in vasprintf\");\n+      go_assert(0);\n+    }\n+  std::string rval = std::string(mbuf);\n+  free(mbuf);\n+  go_be_inform(location, rval);\n+}"}, {"sha": "a687553dffbf84f39e6fc631b09fcac7f60f777c", "filename": "gcc/go/gofrontend/go-diagnostics.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo-diagnostics.h?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -15,6 +15,12 @@\n #define GO_ATTRIBUTE_GCC_DIAG(m,  n)\n #endif\n \n+#if __GNUC__ >= 3\n+#define GO_ATTRIBUTE_PRINTF(m, n) __attribute__ ((__format__ (__printf__, m, n))) __attribute__ ((__nonnull__ (m)))\n+#else\n+#define GO_ATTRIBUTE_PRINTF(m, n)\n+#endif\n+\n // These declarations define the interface through which the frontend\n // reports errors and warnings. These functions accept printf-like\n // format specifiers (e.g. %d, %f, %s, etc), with the following additional\n@@ -41,6 +47,12 @@ extern void go_fatal_error(const Location, const char* fmt, ...)\n extern void go_inform(const Location, const char* fmt, ...)\n     GO_ATTRIBUTE_GCC_DIAG(2,3);\n \n+// go_debug is used to report a debugging message at a location.  This\n+// uses standard printf formatting.\n+\n+extern void go_debug(const Location, const char* fmt, ...)\n+  GO_ATTRIBUTE_PRINTF(2, 3);\n+\n // These interfaces provide a way for the front end to ask for\n // the open/close quote characters it should use when formatting\n // diagnostics (warnings, errors)."}, {"sha": "4a0116caec1ea8fff8172796a839405b5c2fc598", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26fcb396d1eecc73636ad5a694a16c5bb54fcd26/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=26fcb396d1eecc73636ad5a694a16c5bb54fcd26", "patch": "@@ -6085,7 +6085,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n       if (clear != NULL)\n         {\n           if (gogo->debug_optimization())\n-            go_inform(loc, \"map range clear\");\n+            go_debug(loc, \"map range clear\");\n           temp_block->add_statement(clear);\n           return Statement::make_block_statement(temp_block, loc);\n         }\n@@ -6102,7 +6102,7 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n       if (clear != NULL)\n         {\n           if (gogo->debug_optimization())\n-            go_inform(loc, \"array range clear\");\n+            go_debug(loc, \"array range clear\");\n           temp_block->add_statement(clear);\n           return Statement::make_block_statement(temp_block, loc);\n         }"}]}