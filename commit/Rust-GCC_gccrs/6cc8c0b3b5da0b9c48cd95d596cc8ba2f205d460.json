{"sha": "6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmNjOGMwYjNiNWRhMGI5YzQ4Y2Q5NWQ1OTZjYzhiYTJmMjA1ZDQ2MA==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@cygnus.com", "date": "1999-02-25T10:20:21Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "1999-02-25T10:20:21Z"}, "message": "Tidy up previous delta\n\nFrom-SVN: r25431", "tree": {"sha": "44cefa946a96e91677979018199462ae4fdf24ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44cefa946a96e91677979018199462ae4fdf24ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/comments", "author": null, "committer": null, "parents": [{"sha": "592e5d21b1994911eee8c785222ac9ca217453e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/592e5d21b1994911eee8c785222ac9ca217453e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/592e5d21b1994911eee8c785222ac9ca217453e2"}], "stats": {"total": 149, "additions": 117, "deletions": 32}, "files": [{"sha": "8a40b4535616f9785f1a73b14ad3edc147130a36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -1,3 +1,31 @@\n+Thu Feb 25 10:17:32 1999  Nick Clifton  <nickc@cygnus.com>\n+\n+\t* config/arm/arm.c (return_in_memory): Float fields in unions\n+\tforce a return in memory.\n+\t(load_multiple_sequence): Add comment explaining why two LDR\n+\tinstructions can be better than an LDMIA instruction.\n+\n+\t* config/arm/arm.h (TARGET_SHORT_BY_BYTES): Add comment\n+\tdescribing the real meaning of this option.\n+\t(FIXED_REGISTERS): Default r10 to not-fixed.\n+\t(CALL_USED_REGISTERS): Default r10 to not-call-used.\n+\t(SUBTARGET_CONDITIONAL_REGISTER_USAGE): If not defined, define\n+\tas empty. \n+\t(CONDITIONAL_REGISTER_USAGE): Fix r10 if TARGET_APCS_STACK is\n+\ttrue.  Invoke SUBTARGET_CONDITIONAL_REGISTER_USAGE after\n+\tperforming other checks.\n+\n+\t* config/arm/arm.md (zero_extendhisi2): Undo previous change.\n+\t(extendhisi2): Undo previous change.\n+\tAlso add comments describing why TARGET_SHORT_BY_BYTES can be\n+\tignored for armv4(t) architectures. \n+\n+\t* config/arm/riscix.h (SUBTARGET_CONDITIONAL_REGISTER_USAGE):\n+\tDefine to fix r10.\n+\n+\t* config/arm/riscix1-1.h\n+\t(SUBTARGET_CONDITIONAL_REGISTER_USAGE): Define to fix r10. \n+\n Thu Feb 25 12:09:04 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cse.c (dump_class): Make the function definition static to match"}, {"sha": "54607b7fff3fe8ef9436adbe2c18ff2dd3114298", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -1328,6 +1328,9 @@ arm_return_in_memory (type)\n \t  if (TREE_CODE (field) != FIELD_DECL)\n \t    continue;\n \n+\t  if (FLOAT_TYPE_P (TREE_TYPE (field)))\n+\t    return 1;\n+\t  \n \t  if (RETURN_IN_MEMORY (TREE_TYPE (field)))\n \t    return 1;\n \t}\n@@ -2700,7 +2703,32 @@ load_multiple_sequence (operands, nops, regs, base, load_offset)\n     return 4; /* ldmdb */\n \n   /* For ARM8,9 & StrongARM, 2 ldr instructions are faster than an ldm if\n-     the offset isn't small enough */\n+     the offset isn't small enough.  The reason 2 ldrs are faster is because\n+     these ARMs are able to do more than one cache access in a single cycle.\n+     The ARM9 and StrongARM have Harvard caches, whilst the ARM8 has a double \n+     bandwidth cache.  This means that these cores can do both an instruction \n+     fetch and a data fetch in a single cycle, so the trick of calculating the \n+     address into a scratch register (one of the result regs) and then doing a \n+     load multiple actually becomes slower (and no smaller in code size).  That \n+     is the transformation\n+ \n+ \tldr\trd1, [rbase + offset]\n+ \tldr\trd2, [rbase + offset + 4]\n+ \n+     to\n+ \n+ \tadd\trd1, rbase, offset\n+ \tldmia\trd1, {rd1, rd2}\n+ \n+     produces worse code -- '3 cycles + any stalls on rd2' instead of '2 cycles \n+     + any stalls on rd2'.  On ARMs with only one cache access per cycle, the \n+     first sequence could never complete in less than 6 cycles, whereas the ldm \n+     sequence would only take 5 and would make better use of sequential accesses\n+     if not hitting the cache.\n+\n+     We cheat here and test 'arm_ld_sched' which we currently know to only be\n+     true for the ARM8, ARM9 and StrongARM.  If this ever changes, then the test\n+     below needs to be reworked.  */\n   if (nops == 2 && arm_ld_sched)\n     return 0;\n "}, {"sha": "685a2672329fdcce636fdb02370bddbda07b785a", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -337,6 +337,13 @@ function tries to return. */\n #define TARGET_APCS_STACK\t\t(target_flags & ARM_FLAG_APCS_STACK)\n #define TARGET_APCS_FLOAT\t\t(target_flags & ARM_FLAG_APCS_FLOAT)\n #define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n+/* Note: TARGET_SHORT_BY_BYTES is really a misnomer.  What it means is\n+   that short values sould not be accessed using word load instructions\n+   as there is a possibility that they may not be word aligned and this\n+   would generate an MMU fault.  On processors which do not have a 16 bit\n+   load instruction therefore, short values must be loaded by individual\n+   byte accesses rather than loading a word and then shifting the desired\n+   value into place.  */\n #define TARGET_SHORT_BY_BYTES\t\t(target_flags & ARM_FLAG_SHORT_BYTE)\n #define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n #define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n@@ -677,7 +684,7 @@ extern char * structure_size_string;\n #define FIXED_REGISTERS  \\\n {                        \\\n   0,0,0,0,0,0,0,0,\t \\\n-  0,0,1,1,0,1,0,1,\t \\\n+  0,0,0,1,0,1,0,1,\t \\\n   0,0,0,0,0,0,0,0,\t \\\n   1,1,1\t\t\t \\\n }\n@@ -693,11 +700,15 @@ extern char * structure_size_string;\n #define CALL_USED_REGISTERS  \\\n {                            \\\n   1,1,1,1,0,0,0,0,\t     \\\n-  0,0,1,1,1,1,1,1,\t     \\\n+  0,0,0,1,1,1,1,1,\t     \\\n   1,1,1,1,0,0,0,0,\t     \\\n   1,1,1\t\t\t     \\\n }\n \n+#ifndef SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE\n+#endif\n+\n /* If doing stupid life analysis, avoid a bug causing a return value r0 to be\n    trampled.  This effectively reduces the number of available registers by 1.\n    XXX It is a hack, I know.\n@@ -717,11 +728,12 @@ extern char * structure_size_string;\n       fixed_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\t\t\\\n       call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 0;\t\\\n     }\t\t\t\t\t\t\t\\\n-  else if (! TARGET_APCS_STACK)\t\t\t\t\\\n+  else if (TARGET_APCS_STACK)\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n-      fixed_regs[10]     = 0;\t\t\t\t\\\n-      call_used_regs[10] = 0;\t\t\t\t\\\n+      fixed_regs[10]     = 1;\t\t\t\t\\\n+      call_used_regs[10] = 1;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n+  SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\t        \\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO"}, {"sha": "23dcbcdc1e74dd1966ee824989addce375fd41c7", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -2167,20 +2167,20 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n+    {\n+     /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+\there because the insn below will generate an LDRH instruction\n+\trather than an LDR instruction, so we cannot get an unaligned\n+\tword access.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t\t      gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n+      DONE;\n+    }\n+  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n     {\n-      if (TARGET_SHORT_BY_BYTES)\n-        {\n-\t  emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n-          DONE;\n-        }\n-      else if (arm_arch4)\n-        {\n-          emit_insn (gen_rtx_SET (VOIDmode,\n-\t\t\t\t  operands[0],\n-\t\t\t\t  gen_rtx_ZERO_EXTEND (SImode, operands[1])));\n-          DONE;\n-        }\n+      emit_insn (gen_movhi_bytes (operands[0], operands[1]));\n+      DONE;\n     }\n   if (! s_register_operand (operands[1], HImode))\n     operands[1] = copy_to_mode_reg (HImode, operands[1]);\n@@ -2273,20 +2273,22 @@\n   \"\"\n   \"\n {\n-  if (GET_CODE (operands[1]) == MEM)\n+  if (arm_arch4 && GET_CODE (operands[1]) == MEM)\n     {\n-      if (TARGET_SHORT_BY_BYTES)\n-        {\n-          emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n-          DONE;\n-        }\n-      else if (arm_arch4)\n-        {\n-          emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n-\t\t     gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n-          DONE;\n-        }\n-     }\n+     /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+\there because the insn below will generate an LDRH instruction\n+\trather than an LDR instruction, so we cannot get an unaligned\n+\tword access.  */\n+      emit_insn (gen_rtx_SET (VOIDmode, operands[0],\n+\t\t gen_rtx_SIGN_EXTEND (SImode, operands[1])));\n+      DONE;\n+    }\n+\n+  if (TARGET_SHORT_BY_BYTES && GET_CODE (operands[1]) == MEM)\n+    {\n+      emit_insn (gen_extendhisi2_mem (operands[0], operands[1]));\n+      DONE;\n+    }\n   if (! s_register_operand (operands[1], HImode))\n     operands[1] = copy_to_mode_reg (HImode, operands[1]);\n   operands[1] = gen_lowpart (SImode, operands[1]);\n@@ -2894,6 +2896,10 @@\n \t}\n       else if (! arm_arch4)\n \t{\n+\t /* Note: We do not have to worry about TARGET_SHORT_BY_BYTES\n+\t    for v4 and up architectures because LDRH instructions will\n+\t    be used to access the HI values, and these cannot generate\n+\t    unaligned word access faults in the MMU.  */\n \t  if (GET_CODE (operands[1]) == MEM)\n \t    {\n \t      if (TARGET_SHORT_BY_BYTES)"}, {"sha": "7c5f1ce01ca06e863b0c9765ce68152c311a32b3", "filename": "gcc/config/arm/riscix.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Friscix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Friscix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix.h?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -120,6 +120,11 @@ Boston, MA 02111-1307, USA.  */\n /* Override the normal default CPU */\n #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm2\n \n+/* r10 is reserved by RISCiX  */\n+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\\\n+  fixed_regs[10] = 1;\t\t\t\t\\\n+  call_used_regs[10] = 1;\n+\n #include \"arm/aout.h\"\n \n /* The RISCiX assembler does not understand .set */"}, {"sha": "7311067e9d2d94cb9f3792832107844a4b213786", "filename": "gcc/config/arm/riscix1-1.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Friscix1-1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460/gcc%2Fconfig%2Farm%2Friscix1-1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Friscix1-1.h?ref=6cc8c0b3b5da0b9c48cd95d596cc8ba2f205d460", "patch": "@@ -80,6 +80,12 @@ Boston, MA 02111-1307, USA.  */\n /* Override the normal default CPU */\n #define SUBTARGET_CPU_DEFAULT TARGET_CPU_arm2\n \n+/* r10 is reserved by RISCiX  */\n+#define SUBTARGET_CONDITIONAL_REGISTER_USAGE \t\\\n+  fixed_regs[10] = 1;\t\t\t\t\\\n+  call_used_regs[10] = 1;\n+\n+\n #include \"arm/aout.h\"\n \n #undef CPP_SPEC"}]}