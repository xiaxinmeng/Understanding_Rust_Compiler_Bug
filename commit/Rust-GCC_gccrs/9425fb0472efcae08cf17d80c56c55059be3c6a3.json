{"sha": "9425fb0472efcae08cf17d80c56c55059be3c6a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQyNWZiMDQ3MmVmY2FlMDhjZjE3ZDgwYzU2YzU1MDU5YmUzYzZhMw==", "commit": {"author": {"name": "Peter Barada", "email": "peter@baradas.org", "date": "2003-08-21T01:03:37Z"}, "committer": {"name": "Bernardo Innocenti", "email": "bernie@gcc.gnu.org", "date": "2003-08-21T01:03:37Z"}, "message": "m68k-none.h: Introduce new ColdFire archs.\n\n\t* config/m68k/m68k-none.h: Introduce new ColdFire archs.\n\t* config/m68k/m68k.h: Likewise.\n\t* config/m68k/lb1sf68.asm: Rename __mcf5200__ to __mcoldfire__.\n\t* config/m68k/coff.h: Rename TARGET_5200 to TARGET_COLDFIRE.\n\t* config/m68k/linux.h: Likewise.\n\t* config/m68k/m68k.c: Likewise.\n\t* config/m68k/m68k.md: Likewise.\n\t* config/m68k/m68kelf.h: Likewise.\n\t* config/m68k/netbsd-elf.h: Likewise.\n\t* config/m68k/t-m68kelf: Add multilib targets for new ColdFire archs.\n\nCo-Authored-By: Bernardo Innocenti <bernie@develer.com>\n\nFrom-SVN: r70630", "tree": {"sha": "a112dd443a9e95a729ba1fd9b22dff2736a49519", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a112dd443a9e95a729ba1fd9b22dff2736a49519"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9425fb0472efcae08cf17d80c56c55059be3c6a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9425fb0472efcae08cf17d80c56c55059be3c6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9425fb0472efcae08cf17d80c56c55059be3c6a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9425fb0472efcae08cf17d80c56c55059be3c6a3/comments", "author": null, "committer": null, "parents": [{"sha": "03d4ad277b172dc5fc466e00e5ed17a6538dd00f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03d4ad277b172dc5fc466e00e5ed17a6538dd00f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03d4ad277b172dc5fc466e00e5ed17a6538dd00f"}], "stats": {"total": 946, "additions": 533, "deletions": 413}, "files": [{"sha": "30394f9e0857306fd006d64522dbd363b61b7a55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -1,3 +1,17 @@\n+2003-08-06  Peter Barada <peter@baradas.org>\n+            Bernardo Innocenti  <bernie@develer.com>\n+\n+\t* config/m68k/m68k-none.h: Introduce new ColdFire archs.\n+\t* config/m68k/m68k.h: Likewise.\n+\t* config/m68k/lb1sf68.asm: Rename __mcf5200__ to __mcoldfire__.\n+\t* config/m68k/coff.h: Rename TARGET_5200 to TARGET_COLDFIRE.\n+\t* config/m68k/linux.h: Likewise.\n+\t* config/m68k/m68k.c: Likewise.\n+\t* config/m68k/m68k.md: Likewise.\n+\t* config/m68k/m68kelf.h: Likewise.\n+\t* config/m68k/netbsd-elf.h: Likewise.\n+\t* config/m68k/t-m68kelf: Add multilib targets for new ColdFire archs.\n+\n 2003-08-20  Bernardo Innocenti  <bernie@develer.com>\n \n \t* config/m68k/m68k.c: Strip away code depending on NO_ADDSUB_Q definition."}, {"sha": "7b9565ebf2c0199536932eb40683ac488acf36c2", "filename": "gcc/config/m68k/coff.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fcoff.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fcoff.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fcoff.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -57,7 +57,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n+    if (TARGET_COLDFIRE)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tif (ADDRESS_REG_P (operands[0]))\t\t\\\n \t  return \"jmp %%pc@(2,%0:l)\";\t\t\t\\"}, {"sha": "d424e9787f1d07905616f66ad3dbbfcec50c8957", "filename": "gcc/config/m68k/lb1sf68.asm", "status": "modified", "additions": 181, "deletions": 181, "changes": 362, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flb1sf68.asm?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -214,7 +214,7 @@ TRUNCDFSF    = 7\n | void __clear_sticky_bits(void);\n SYM (__clear_sticky_bit):\t\t\n \tlea\tSYM (_fpCCR),a0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmovew\tIMM (0),a0@(STICK)\n #else\n \tclr.w\ta0@(STICK)\n@@ -248,7 +248,7 @@ FPTRAP = 15\n $_exception_handler:\n \tlea\tSYM (_fpCCR),a0\n \tmovew\td7,a0@(EBITS)\t| set __exception_bits\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td7,a0@(STICK)\t| and __sticky_bits\n #else\n \tmovew\ta0@(STICK),d4\n@@ -259,7 +259,7 @@ $_exception_handler:\n \tmovew\td5,a0@(LASTO)\t| and __last_operation\n \n | Now put the operands in place:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (SINGLE_FLOAT),d6\n #else\n \tcmpl\tIMM (SINGLE_FLOAT),d6\n@@ -274,7 +274,7 @@ $_exception_handler:\n \tmovel\ta6@(12),a0@(OPER2)\n 2:\n | And check whether the exception is trap-enabled:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tandw\ta0@(TRAPE),d7\t| is exception trap-enabled?\n #else\n \tclrl\td6\n@@ -284,7 +284,7 @@ $_exception_handler:\n \tbeq\t1f\t\t| no, exit\n \tpea\tSYM (_fpCCR)\t| yes, push address of _fpCCR\n \ttrap\tIMM (FPTRAP)\t| and trap\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n 1:\tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n 1:\tmoveml\tsp@,d2-d7\n@@ -304,7 +304,7 @@ SYM (__mulsi3):\n \tmuluw\tsp@(10), d0\t/* x0*y1 */\n \tmovew\tsp@(6), d1\t/* x1 -> d1 */\n \tmuluw\tsp@(8), d1\t/* x1*y0 */\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\td1, d0\n #else\n \taddl\td1, d0\n@@ -323,7 +323,7 @@ SYM (__mulsi3):\n \t.proc\n \t.globl\tSYM (__udivsi3)\n SYM (__udivsi3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmovel\td2, sp@-\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tmovel\tsp@(8), d0\t/* d0 = dividend */\n@@ -368,7 +368,7 @@ L5:\tsubql\tIMM (1), d0\t/* adjust quotient */\n L6:\tmovel\tsp@+, d2\n \trts\n \n-#else /* __mcf5200__ */\n+#else /* __mcoldfire__ */\n \n /* Coldfire implementation of non-restoring division algorithm from\n    Hennessy & Patterson, Appendix A. */\n@@ -390,7 +390,7 @@ L2:\tsubql\tIMM (1),d4\n \tmoveml\tsp@,d2-d4\t| restore data registers\n \tunlk\ta6\t\t| and return\n \trts\n-#endif /* __mcf5200__ */\n+#endif /* __mcoldfire__ */\n \n #endif /* L_udivsi3 */\n \n@@ -405,15 +405,15 @@ SYM (__divsi3):\n \tmovel\tsp@(12), d1\t/* d1 = divisor */\n \tjpl\tL1\n \tnegl\td1\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tnegb\td2\t\t/* change sign because divisor <0  */\n #else\n \tnegl\td2\t\t/* change sign because divisor <0  */\n #endif\n L1:\tmovel\tsp@(8), d0\t/* d0 = dividend */\n \tjpl\tL2\n \tnegl\td0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tnegb\td2\n #else\n \tnegl\td2\n@@ -444,7 +444,7 @@ SYM (__umodsi3):\n \tjbsr\tSYM (__udivsi3)\n \taddql\tIMM (8), sp\n \tmovel\tsp@(8), d1\t/* d1 = divisor */\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__mulsi3)\t/* d0 = (a/b)*b */\n@@ -470,7 +470,7 @@ SYM (__modsi3):\n \tjbsr\tSYM (__divsi3)\n \taddql\tIMM (8), sp\n \tmovel\tsp@(8), d1\t/* d1 = divisor */\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmovel\td1, sp@-\n \tmovel\td0, sp@-\n \tjbsr\tSYM (__mulsi3)\t/* d0 = (a/b)*b */\n@@ -611,7 +611,7 @@ SYM (__subdf3):\n \n | double __adddf3(double, double);\n SYM (__adddf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\t| everything will be done in registers\n \tmoveml\td2-d7,sp@-\t| save all data registers and a2 (but d0-d1)\n #else\n@@ -635,7 +635,7 @@ SYM (__adddf3):\n \n \tandl\tIMM (0x80000000),d7 | isolate a's sign bit '\n         swap\td6\t\t| and also b's sign bit '\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tandw\tIMM (0x8000),d6\t|\n \torw\td6,d7\t\t| and combine them into d7, so that a's sign '\n \t\t\t\t| bit is in the high word and b's is in the '\n@@ -662,7 +662,7 @@ SYM (__adddf3):\n \torl\td7,d0\t\t| and put hidden bit back\n Ladddf$1:\n \tswap\td4\t\t| shift right exponent so that it starts\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (5),d4\t| in bit 0 and not bit 20\n #else\n \tlsrl\tIMM (5),d4\t| in bit 0 and not bit 20\n@@ -678,7 +678,7 @@ Ladddf$1:\n \torl\td7,d2\t\t| and put hidden bit back\n Ladddf$2:\n \tswap\td5\t\t| shift right exponent so that it starts\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (5),d5\t| in bit 0 and not bit 20\n #else\n \tlsrl\tIMM (5),d5\t| in bit 0 and not bit 20\n@@ -693,7 +693,7 @@ Ladddf$2:\n | and d4-d5-d6-d7 for the second. To do this we store (temporarily) the\n | exponents in a2-a3.\n \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\ta2-a3,sp@-\t| save the address registers\n #else\n \tmovel\ta2,sp@-\t\n@@ -713,7 +713,7 @@ Ladddf$2:\n \n | Here we shift the numbers until the exponents are the same, and put \n | the largest exponent in a2.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td4,a2\t\t| get exponents back\n \texg\td5,a3\t\t|\n \tcmpw\td4,d5\t\t| compare the exponents\n@@ -732,7 +732,7 @@ Ladddf$2:\n | Here we have a's exponent larger than b's, so we have to shift b. We do \n | this by using as counter d2:\n 1:\tmovew\td4,d2\t\t| move largest exponent to d2\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\td5,d2\t\t| and subtract second exponent\n \texg\td4,a2\t\t| get back the longs we saved\n \texg\td5,a3\t\t|\n@@ -746,20 +746,20 @@ Ladddf$2:\n \tmovel\ta4,a3\n #endif\n | if difference is too large we don't shift (actually, we can just exit) '\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (DBL_MANT_DIG+2),d2\n #else\n \tcmpl\tIMM (DBL_MANT_DIG+2),d2\n #endif\n \tbge\tLadddf$b$small\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (32),d2\t| if difference >= 32, shift by longs\n #else\n \tcmpl\tIMM (32),d2\t| if difference >= 32, shift by longs\n #endif\n \tbge\t5f\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (16),d2\t| if difference >= 16, shift by words\t\n #else\n \tcmpl\tIMM (16),d2\t| if difference >= 16, shift by words\t\n@@ -768,7 +768,7 @@ Ladddf$2:\n \tbra\t3f\t\t| enter dbra loop\n \n 4:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d4\n \troxrl\tIMM (1),d5\n \troxrl\tIMM (1),d6\n@@ -789,7 +789,7 @@ Ladddf$2:\n 12:\tlsrl\tIMM (1),d4\n #endif\n 3:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td2,4b\n #else\n \tsubql\tIMM (1),d2\n@@ -803,7 +803,7 @@ Ladddf$2:\n \tmovel\td5,d6\n \tmovel\td4,d5\n \tmovel\tIMM (0),d4\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (32),d2\n #else\n \tsubl\tIMM (32),d2\n@@ -818,15 +818,15 @@ Ladddf$2:\n \tswap\td5\n \tmovew\tIMM (0),d4\n \tswap\td4\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (16),d2\n #else\n \tsubl\tIMM (16),d2\n #endif\n \tbra\t3b\n \t\n 9:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td4,d5\n \tmovew\td4,d6\n \tsubw\td5,d6\t\t| keep d5 (largest exponent) in d4\n@@ -845,20 +845,20 @@ Ladddf$2:\n \tmovel\ta4,a3\n #endif\n | if difference is too large we don't shift (actually, we can just exit) '\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (DBL_MANT_DIG+2),d6\n #else\n \tcmpl\tIMM (DBL_MANT_DIG+2),d6\n #endif\n \tbge\tLadddf$a$small\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (32),d6\t| if difference >= 32, shift by longs\n #else\n \tcmpl\tIMM (32),d6\t| if difference >= 32, shift by longs\n #endif\n \tbge\t5f\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (16),d6\t| if difference >= 16, shift by words\t\n #else\n \tcmpl\tIMM (16),d6\t| if difference >= 16, shift by words\t\n@@ -867,7 +867,7 @@ Ladddf$2:\n \tbra\t3f\t\t| enter dbra loop\n \n 4:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -888,7 +888,7 @@ Ladddf$2:\n 12:\tlsrl\tIMM (1),d0\n #endif\n 3:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td6,4b\n #else\n \tsubql\tIMM (1),d6\n@@ -902,7 +902,7 @@ Ladddf$2:\n \tmovel\td1,d2\n \tmovel\td0,d1\n \tmovel\tIMM (0),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (32),d6\n #else\n \tsubl\tIMM (32),d6\n@@ -917,14 +917,14 @@ Ladddf$2:\n \tswap\td1\n \tmovew\tIMM (0),d0\n \tswap\td0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (16),d6\n #else\n \tsubl\tIMM (16),d6\n #endif\n \tbra\t3b\n Ladddf$3:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td4,a2\t\n \texg\td5,a3\n #else\n@@ -940,7 +940,7 @@ Ladddf$4:\n | the signs in a4.\n \n | Here we have to decide whether to add or subtract the numbers:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a0\t\t| get the signs \n \texg\td6,a3\t\t| a3 is free to be used\n #else\n@@ -958,7 +958,7 @@ Ladddf$4:\n \teorl\td7,d6\t\t| compare the signs\n \tbmi\tLsubdf$0\t| if the signs are different we have \n \t\t\t\t| to subtract\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a0\t\t| else we add the numbers\n \texg\td6,a3\t\t|\n #else\n@@ -978,7 +978,7 @@ Ladddf$4:\n \tmovel\ta0,d7\t\t| \n \tandl\tIMM (0x80000000),d7 | d7 now has the sign\n \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\t\n #else\n \tmovel\tsp@+,a4\t\n@@ -992,7 +992,7 @@ Ladddf$4:\n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -1017,12 +1017,12 @@ Ladddf$4:\n 1:\n \tlea\tLadddf$5,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -1032,20 +1032,20 @@ Ladddf$4:\n \tbra\tLround$to$plus\n Ladddf$5:\n | Put back the exponent and check for overflow\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (0x7ff),d4\t| is the exponent big?\n #else\n \tcmpl\tIMM (0x7ff),d4\t| is the exponent big?\n #endif\n \tbge\t1f\n \tbclr\tIMM (DBL_MANT_DIG-1),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (4),d4\t| put exponent back into position\n #else\n \tlsll\tIMM (4),d4\t| put exponent back into position\n #endif\n \tswap\td0\t\t| \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td4,d0\t\t|\n #else\n \torl\td4,d0\t\t|\n@@ -1058,7 +1058,7 @@ Ladddf$5:\n \n Lsubdf$0:\n | Here we do the subtraction.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a0\t\t| put sign back in a0\n \texg\td6,a3\t\t|\n #else\n@@ -1086,7 +1086,7 @@ Lsubdf$0:\n \tmovel\ta2,d4\t\t| return exponent to d4\n \tmovel\ta0,d7\n \tandl\tIMM (0x80000000),d7 | isolate sign bit\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\t|\n #else\n \tmovel\tsp@+,a4\n@@ -1100,7 +1100,7 @@ Lsubdf$0:\n | one more bit we check this:\n \tbtst\tIMM (DBL_MANT_DIG+1),d0\t\n \tbeq\t1f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -1125,12 +1125,12 @@ Lsubdf$0:\n 1:\n \tlea\tLsubdf$1,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -1141,13 +1141,13 @@ Lsubdf$0:\n Lsubdf$1:\n | Put back the exponent and sign (we don't have overflow). '\n \tbclr\tIMM (DBL_MANT_DIG-1),d0\t\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (4),d4\t| put exponent back into position\n #else\n \tlsll\tIMM (4),d4\t| put exponent back into position\n #endif\n \tswap\td0\t\t| \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td4,d0\t\t|\n #else\n \torl\td4,d0\t\t|\n@@ -1159,7 +1159,7 @@ Lsubdf$1:\n | DBL_MANT_DIG+1) we return the other (and now we don't have to '\n | check for finiteness or zero).\n Ladddf$a$small:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\t\n #else\n \tmovel\tsp@+,a4\n@@ -1170,7 +1170,7 @@ Ladddf$a$small:\n \tmovel\ta6@(20),d1\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -1181,7 +1181,7 @@ Ladddf$a$small:\n \trts\n \n Ladddf$b$small:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\t\n #else\n \tmovel\tsp@+,a4\t\n@@ -1192,7 +1192,7 @@ Ladddf$b$small:\n \tmovel\ta6@(12),d1\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -1238,7 +1238,7 @@ Ladddf$a:\n \tbra\tLd$infty\t\t|\n \t\n Ladddf$ret$1:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\t| restore regs and exit\n #else\n \tmovel\tsp@+,a4\n@@ -1251,7 +1251,7 @@ Ladddf$ret:\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n \torl\td7,d0\t\t| put sign bit back\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -1263,7 +1263,7 @@ Ladddf$ret:\n \n Ladddf$ret$den:\n | Return a denormalized number.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\t| shift right once more\n \troxrl\tIMM (1),d1\t|\n #else\n@@ -1329,7 +1329,7 @@ Ladddf$nf:\n \n | double __muldf3(double, double);\n SYM (__muldf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -1370,7 +1370,7 @@ SYM (__muldf3):\n \tandl\td6,d0\t\t\t| isolate fraction\n \torl\tIMM (0x00100000),d0\t| and put hidden bit back\n \tswap\td4\t\t\t| I like exponents in the first byte\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (4),d4\t\t| \n #else\n \tlsrl\tIMM (4),d4\t\t| \n@@ -1381,13 +1381,13 @@ Lmuldf$1:\n \tandl\td6,d2\t\t\t|\n \torl\tIMM (0x00100000),d2\t| and put hidden bit back\n \tswap\td5\t\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (4),d5\t\t|\n #else\n \tlsrl\tIMM (4),d5\t\t|\n #endif\n Lmuldf$2:\t\t\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\td5,d4\t\t\t| add exponents\n \tsubw\tIMM (D_BIAS+1),d4\t| and subtract bias (plus one)\n #else\n@@ -1405,7 +1405,7 @@ Lmuldf$2:\t\t\t\t|\n | enough to keep everything in them. So we use the address registers to keep\n | some intermediate data.\n \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\ta2-a3,sp@-\t| save a2 and a3 for temporary use\n #else\n \tmovel\ta2,sp@-\n@@ -1416,7 +1416,7 @@ Lmuldf$2:\t\t\t\t|\n \tmovel\td4,a3\t\t| and a3 will preserve the exponent\n \n | First, shift d2-d3 so bit 20 becomes bit 31:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \trorl\tIMM (5),d2\t| rotate d2 5 places right\n \tswap\td2\t\t| and swap it\n \trorl\tIMM (5),d3\t| do the same thing with d3\n@@ -1447,7 +1447,7 @@ Lmuldf$2:\t\t\t\t|\n \n | We use a1 as counter:\t\n \tmovel\tIMM (DBL_MANT_DIG-1),a1\t\t\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a1\n #else\n \tmovel\td7,a4\n@@ -1456,7 +1456,7 @@ Lmuldf$2:\t\t\t\t|\n #endif\n \n 1:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a1\t\t| put counter back in a1\n #else\n \tmovel\td7,a4\n@@ -1470,7 +1470,7 @@ Lmuldf$2:\t\t\t\t|\n \taddl\td7,d7\t\t|\n \taddxl\td6,d6\t\t|\n \tbcc\t2f\t\t| if bit clear skip the following\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a2\t\t|\n #else\n \tmovel\td7,a4\n@@ -1481,15 +1481,15 @@ Lmuldf$2:\t\t\t\t|\n \taddxl\td4,d2\t\t|\n \taddxl\td7,d1\t\t|\n \taddxl\td7,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a2\t\t| \n #else\n \tmovel\td7,a4\n \tmovel\ta2,d7\n \tmovel\ta4,a2\n #endif\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td7,a1\t\t| put counter in d7\n \tdbf\td7,1b\t\t| decrement and branch\n #else\n@@ -1501,7 +1501,7 @@ Lmuldf$2:\t\t\t\t|\n #endif\n \n \tmovel\ta3,d4\t\t| restore exponent\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,a2-a3\n #else\n \tmovel\tsp@+,a4\n@@ -1520,7 +1520,7 @@ Lmuldf$2:\t\t\t\t|\n \tswap\td3\n \tmovew\td3,d2\n \tmovew\tIMM (0),d3\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -1556,7 +1556,7 @@ Lmuldf$2:\t\t\t\t|\n \n \tbtst\tIMM (DBL_MANT_DIG+1-32),d0\n \tbeq\tLround$exit\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d4\n@@ -1592,7 +1592,7 @@ Lmuldf$a$nf:\n | NaN, in which case we return NaN.\n Lmuldf$b$0:\n \tmovew\tIMM (MULTIPLY),d5\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td2,d0\t\t| put b (==0) into d0-d1\n \texg\td3,d1\t\t| and a (with sign bit cleared) into d2-d3\n #else\n@@ -1612,7 +1612,7 @@ Lmuldf$a$0:\n \tbge\tLd$inop\t\t| in case NaN or +/-INFINITY return NaN\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -1631,7 +1631,7 @@ Lmuldf$a$den:\n \tandl\td6,d0\n 1:\taddl\td1,d1           | shift a left until bit 20 is set\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d4\t| and adjust exponent\n #else\n \tsubl\tIMM (1),d4\t| and adjust exponent\n@@ -1645,7 +1645,7 @@ Lmuldf$b$den:\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d5\t| and adjust exponent\n #else\n \tsubql\tIMM (1),d5\t| and adjust exponent\n@@ -1661,7 +1661,7 @@ Lmuldf$b$den:\n \n | double __divdf3(double, double);\n SYM (__divdf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -1706,7 +1706,7 @@ SYM (__divdf3):\n \tandl\td6,d0\t\t| and isolate fraction\n \torl\tIMM (0x00100000),d0 | and put hidden bit back\n \tswap\td4\t\t| I like exponents in the first byte\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (4),d4\t| \n #else\n \tlsrl\tIMM (4),d4\t| \n@@ -1717,13 +1717,13 @@ Ldivdf$1:\t\t\t|\n \tandl\td6,d2\t\t|\n \torl\tIMM (0x00100000),d2\n \tswap\td5\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (4),d5\t|\n #else\n \tlsrl\tIMM (4),d5\t|\n #endif\n Ldivdf$2:\t\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\td5,d4\t\t| subtract exponents\n \taddw\tIMM (D_BIAS),d4\t| and add bias\n #else\n@@ -1760,7 +1760,7 @@ Ldivdf$2:\t\t\t|\n \tbset\td5,d6\t\t| set the corresponding bit in d6\n 3:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td5,1b\t\t| and branch back\n #else\n \tsubql\tIMM (1), d5\n@@ -1782,7 +1782,7 @@ Ldivdf$2:\t\t\t|\n \tbset\td5,d7\t\t| set the corresponding bit in d7\n 3:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td5,1b\t\t| and branch back\n #else\n \tsubql\tIMM (1), d5\n@@ -1800,7 +1800,7 @@ Ldivdf$2:\t\t\t|\n \tbeq\t3f\t\t| if d0==d2 check d1 and d3\n 2:\taddl\td1,d1\t\t| shift a by 1\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td5,1b\t\t| and branch back\n #else\n \tsubql\tIMM (1), d5\n@@ -1816,7 +1816,7 @@ Ldivdf$2:\t\t\t|\n | to it; if you don't do this the algorithm loses in some cases). '\n \tmovel\tIMM (0),d2\n \tmovel\td2,d3\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (DBL_MANT_DIG),d5\n \taddw\tIMM (63),d5\n \tcmpw\tIMM (31),d5\n@@ -1828,7 +1828,7 @@ Ldivdf$2:\t\t\t|\n \tbhi\t2f\n 1:\tbset\td5,d3\n \tbra\t5f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (32),d5\n #else\n \tsubl\tIMM (32),d5\n@@ -1847,7 +1847,7 @@ Ldivdf$2:\t\t\t|\n | not set:\n \tbtst\tIMM (DBL_MANT_DIG-32+1),d0\n \tbeq\t1f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \troxrl\tIMM (1),d2\n@@ -1897,7 +1897,7 @@ Ldivdf$a$0:\n \tmovel\td0,d1\t\t| \n \tlea\tSYM (_fpCCR),a0\t| clear exception flags\n \tmovew\tIMM (0),a0@\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| \n #else\n \tmoveml\tsp@,d2-d7\t| \n@@ -1945,7 +1945,7 @@ Ldivdf$a$den:\n \tandl\td6,d0\n 1:\taddl\td1,d1\t\t| shift a left until bit 20 is set\n \taddxl\td0,d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d4\t| and adjust exponent\n #else\n \tsubl\tIMM (1),d4\t| and adjust exponent\n@@ -1959,7 +1959,7 @@ Ldivdf$b$den:\n \tandl\td6,d2\n 1:\taddl\td3,d3\t\t| shift b left until bit 20 is set\n \taddxl\td2,d2\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d5\t| and adjust exponent\n #else\n \tsubql\tIMM (1),d5\t| and adjust exponent\n@@ -1974,7 +1974,7 @@ Lround$exit:\n | so that 2^21 <= d0 < 2^22, and the exponent is in the lower byte of d4.\n \n | First check for underlow in the exponent:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (-DBL_MANT_DIG-1),d4\t\t\n #else\n \tcmpl\tIMM (-DBL_MANT_DIG-1),d4\t\t\n@@ -1987,14 +1987,14 @@ Lround$exit:\n \tmovel\td7,a0\t\t|\n \tmovel\tIMM (0),d6\t| use d6-d7 to collect bits flushed right\n \tmovel\td6,d7\t\t| use d6-d7 to collect bits flushed right\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (1),d4\t| if the exponent is less than 1 we \n #else\n \tcmpl\tIMM (1),d4\t| if the exponent is less than 1 we \n #endif\n \tbge\t2f\t\t| have to shift right (denormalize)\n 1:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\tIMM (1),d4\t| adjust the exponent\n \tlsrl\tIMM (1),d0\t| shift right once \n \troxrl\tIMM (1),d1\t|\n@@ -2037,12 +2037,12 @@ Lround$exit:\n | Now call the rounding routine (which takes care of denormalized numbers):\n \tlea\tLround$0,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -2058,7 +2058,7 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 0x7ff).\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (0x07ff),d4\n #else\n \tcmpl\tIMM (0x07ff),d4\n@@ -2069,14 +2069,14 @@ Lround$0:\n \tbeq\tLd$den\n 1:\n | Put back the exponents and sign and return.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (4),d4\t| exponent back to fourth byte\n #else\n \tlsll\tIMM (4),d4\t| exponent back to fourth byte\n #endif\n \tbclr\tIMM (DBL_MANT_DIG-32-1),d0\n \tswap\td0\t\t| and put back exponent\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td4,d0\t\t| \n #else\n \torl\td4,d0\t\t| \n@@ -2086,7 +2086,7 @@ Lround$0:\n \n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2102,7 +2102,7 @@ Lround$0:\n \n | double __negdf2(double, double);\n SYM (__negdf2):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -2128,7 +2128,7 @@ SYM (__negdf2):\n \tbra\tLd$infty\t\t\n 1:\tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2150,7 +2150,7 @@ EQUAL   =  0\n \n | int __cmpdf2(double, double);\n SYM (__cmpdf2):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@- \t| save registers\n #else\n@@ -2194,7 +2194,7 @@ Lcmpdf$1:\n \ttstl\td6\n \tbpl\t1f\n | If both are negative exchange them\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td0,d2\n \texg\td1,d3\n #else\n@@ -2217,7 +2217,7 @@ Lcmpdf$1:\n \tbne\tLcmpdf$a$gt$b\t| |b| < |a|\n | If we got here a == b.\n \tmovel\tIMM (EQUAL),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2228,7 +2228,7 @@ Lcmpdf$1:\n \trts\n Lcmpdf$a$gt$b:\n \tmovel\tIMM (GREATER),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2239,7 +2239,7 @@ Lcmpdf$a$gt$b:\n \trts\n Lcmpdf$b$gt$a:\n \tmovel\tIMM (LESS),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2287,7 +2287,7 @@ Lround$to$nearest:\n | Normalize shifting left until bit #DBL_MANT_DIG-32 is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -D_BIAS+1).\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (1),d4\t| remember that the exponent is at least one\n #else\n \tcmpl\tIMM (1),d4\t| remember that the exponent is at least one\n@@ -2297,7 +2297,7 @@ Lround$to$nearest:\n \taddxl\td2,d2\t\t|\n \taddxl\td1,d1\t\t|\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td4,1b\t\t|\n #else\n \tsubql\tIMM (1), d4\n@@ -2325,7 +2325,7 @@ Lround$to$nearest:\n \taddxl\td2,d0\n | Shift right once (because we used bit #DBL_MANT_DIG-32!).\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\t\t\n #else\n@@ -2340,7 +2340,7 @@ Lround$to$nearest:\n | 'fraction overflow' ...).\n \tbtst\tIMM (DBL_MANT_DIG-32),d0\t\n \tbeq\t1f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d4\n@@ -2491,7 +2491,7 @@ SYM (__subsf3):\n \n | float __addsf3(float, float);\n SYM (__addsf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\t| everything will be done in registers\n \tmoveml\td2-d7,sp@-\t| save all data registers but d0-d1\n #else\n@@ -2551,7 +2551,7 @@ Laddsf$2:\n | same, and put the largest exponent in d6. Note that we are using two\n | registers for each number (see the discussion by D. Knuth in \"Seminumerical \n | Algorithms\").\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\td6,d7\t\t| compare exponents\n #else\n \tcmpl\td6,d7\t\t| compare exponents\n@@ -2561,32 +2561,32 @@ Laddsf$2:\n 1:\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (8),d7\t| put difference in lower byte\n #else\n \tlsrl\tIMM (8),d7\t| put difference in lower byte\n #endif\n | if difference is too large we don't shift (actually, we can just exit) '\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n #else\n \tcmpl\tIMM (FLT_MANT_DIG+2),d7\t\t\n #endif\n \tbge\tLaddsf$b$small\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n #else\n \tcmpl\tIMM (16),d7\t| if difference >= 16 swap\n #endif\n \tbge\t4f\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d7\n #else\n \tsubql\tIMM (1), d7\n #endif\n 3:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d2\t| shift right second operand\n \troxrl\tIMM (1),d3\n \tdbra\td7,3b\n@@ -2605,15 +2605,15 @@ Laddsf$2:\n \tswap\td3\n \tmovew\td3,d2\n \tswap\td2\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (16),d7\n #else\n \tsubl\tIMM (16),d7\n #endif\n \tbne\t2b\t\t| if still more bits, go back to normal case\n \tbra\tLaddsf$3\n 5:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td6,d7\t\t| exchange the exponents\n #else\n \teorl\td6,d7\n@@ -2622,32 +2622,32 @@ Laddsf$2:\n #endif\n \tsubl\td6,d7\t\t| keep the largest exponent\n \tnegl\td7\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (8),d7\t| put difference in lower byte\n #else\n \tlsrl\tIMM (8),d7\t| put difference in lower byte\n #endif\n | if difference is too large we don't shift (and exit!) '\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (FLT_MANT_DIG+2),d7\t\t\n #else\n \tcmpl\tIMM (FLT_MANT_DIG+2),d7\t\t\n #endif\n \tbge\tLaddsf$a$small\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (16),d7\t| if difference >= 16 swap\n #else\n \tcmpl\tIMM (16),d7\t| if difference >= 16 swap\n #endif\n \tbge\t8f\n 6:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d7\n #else\n \tsubl\tIMM (1),d7\n #endif\n 7:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\t| shift right first operand\n \troxrl\tIMM (1),d1\n \tdbra\td7,7b\n@@ -2666,7 +2666,7 @@ Laddsf$2:\n \tswap\td1\n \tmovew\td1,d0\n \tswap\td0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (16),d7\n #else\n \tsubl\tIMM (16),d7\n@@ -2679,7 +2679,7 @@ Laddsf$2:\n \n Laddsf$3:\n | Here we have to decide whether to add or subtract the numbers\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td6,a0\t\t| get signs back\n \texg\td7,a1\t\t| and save the exponents\n #else\n@@ -2696,7 +2696,7 @@ Laddsf$3:\n \t\t\t\t| numbers\n \n | Here we have both positive or both negative\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td6,a0\t\t| now we have the exponent in d6\n #else\n \tmovel\td6,d4\n@@ -2713,7 +2713,7 @@ Laddsf$3:\n | Put the exponent, in the first byte, in d2, to use the \"standard\" rounding\n | routines:\n \tmovel\td6,d2\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (8),d2\n #else\n \tlsrl\tIMM (8),d2\n@@ -2725,7 +2725,7 @@ Laddsf$3:\n | one more bit we check this:\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\t\n \tbeq\t1f\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n #else\n@@ -2739,12 +2739,12 @@ Laddsf$3:\n 1:\n \tlea\tLaddsf$4,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -2754,14 +2754,14 @@ Laddsf$3:\n \tbra\tLround$to$plus\n Laddsf$4:\n | Put back the exponent, but check for overflow.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (0xff),d2\n #else\n \tcmpl\tIMM (0xff),d2\n #endif\n \tbhi\t1f\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (7),d2\n #else\n \tlsll\tIMM (7),d2\n@@ -2787,7 +2787,7 @@ Lsubsf$0:\n \tnegl\td1\n \tnegxl\td0\n 1:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td2,a0\t\t| now we have the exponent in d2\n \tlsrw\tIMM (8),d2\t| put it in the first byte\n #else\n@@ -2804,12 +2804,12 @@ Lsubsf$0:\n | the rounding routines themselves.\n \tlea\tLsubsf$1,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -2820,7 +2820,7 @@ Lsubsf$0:\n Lsubsf$1:\n | Put back the exponent (we can't have overflow!). '\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (7),d2\n #else\n \tlsll\tIMM (7),d2\n@@ -2836,7 +2836,7 @@ Laddsf$a$small:\n \tmovel\ta6@(12),d0\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2850,7 +2850,7 @@ Laddsf$b$small:\n \tmovel\ta6@(8),d0\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2908,7 +2908,7 @@ Laddsf$ret:\n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n \torl\td7,d0\t\t| put sign bit\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| restore data registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -2975,7 +2975,7 @@ Laddsf$nf:\n \n | float __mulsf3(float, float);\n SYM (__mulsf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -3010,7 +3010,7 @@ SYM (__mulsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (7),d2\t| \n #else\n \tlsrl\tIMM (7),d2\t| \n@@ -3021,13 +3021,13 @@ Lmulsf$1:\t\t\t| number\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (7),d3\t|\n #else\n \tlsrl\tIMM (7),d3\t|\n #endif\n Lmulsf$2:\t\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\td3,d2\t\t| add exponents\n \tsubw\tIMM (F_BIAS+1),d2 | and subtract bias (plus one)\n #else\n@@ -3060,7 +3060,7 @@ Lmulsf$2:\t\t\t|\n \taddl\td5,d1\t\t| add a\n \taddxl\td4,d0\n 2:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbf\td3,1b\t\t| loop back\n #else\n \tsubql\tIMM (1),d3\n@@ -3070,7 +3070,7 @@ Lmulsf$2:\t\t\t|\n | Now we have the product in d0-d1, with bit (FLT_MANT_DIG - 1) + FLT_MANT_DIG\n | (mod 32) of d0 set. The first thing to do now is to normalize it so bit \n | FLT_MANT_DIG is set (to do the rounding).\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \trorl\tIMM (6),d1\n \tswap\td1\n \tmovew\td1,d3\n@@ -3089,7 +3089,7 @@ Lmulsf$2:\t\t\t|\n \tlsll\tIMM (8),d0\n \taddl\td0,d0\n \taddl\td0,d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td3,d0\n #else\n \torl\td3,d0\n@@ -3099,7 +3099,7 @@ Lmulsf$2:\t\t\t|\n \t\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\n \tbeq\tLround$exit\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrl\tIMM (1),d0\n \troxrl\tIMM (1),d1\n \taddw\tIMM (1),d2\n@@ -3143,7 +3143,7 @@ Lmulsf$a$0:\n \tbge\tLf$inop\t\t| if b is +/-INFINITY or NaN return NaN\n \tlea\tSYM (_fpCCR),a0\t| else return zero\n \tmovew\tIMM (0),a0@\t| \n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t| \n #else\n \tmoveml\tsp@,d2-d7\n@@ -3161,7 +3161,7 @@ Lmulsf$a$den:\n \tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left (until bit 23 is set)\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d2\t| and adjust exponent\n #else\n \tsubql\tIMM (1),d2\t| and adjust exponent\n@@ -3174,7 +3174,7 @@ Lmulsf$b$den:\n \tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit 23 is set\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d3\t| and adjust exponent\n #else\n \tsubl\tIMM (1),d3\t| and adjust exponent\n@@ -3189,7 +3189,7 @@ Lmulsf$b$den:\n \n | float __divsf3(float, float);\n SYM (__divsf3):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -3226,7 +3226,7 @@ SYM (__divsf3):\n \tandl\td5,d0\t\t| and isolate fraction\n \torl\td4,d0\t\t| and put hidden bit back\n \tswap\td2\t\t| I like exponents in the first byte\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (7),d2\t| \n #else\n \tlsrl\tIMM (7),d2\t| \n@@ -3237,13 +3237,13 @@ Ldivsf$1:\t\t\t|\n \tandl\td5,d1\t\t|\n \torl\td4,d1\t\t|\n \tswap\td3\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlsrw\tIMM (7),d3\t|\n #else\n \tlsrl\tIMM (7),d3\t|\n #endif\n Ldivsf$2:\t\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\td3,d2\t\t| subtract exponents\n  \taddw\tIMM (F_BIAS),d2\t| and add bias\n #else\n@@ -3270,7 +3270,7 @@ Ldivsf$2:\t\t\t|\n \tsubl\td1,d0\t\t| if a >= b  a <-- a-b\n \tbeq\t3f\t\t| if a is zero, exit\n 2:\taddl\td0,d0\t\t| multiply a by 2\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td3,1b\n #else\n \tsubql\tIMM (1),d3\n@@ -3282,7 +3282,7 @@ Ldivsf$2:\t\t\t|\n 1:\tcmpl\td0,d1\n \tble\t2f\n \taddl\td0,d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td3,1b\n #else\n \tsubql\tIMM(1),d3\n@@ -3291,7 +3291,7 @@ Ldivsf$2:\t\t\t|\n \tmovel\tIMM (0),d1\n \tbra\t3f\n 2:\tmovel\tIMM (0),d1\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (FLT_MANT_DIG),d3\n \taddw\tIMM (31),d3\n #else\n@@ -3309,7 +3309,7 @@ Ldivsf$2:\t\t\t|\n \tbtst\tIMM (FLT_MANT_DIG+1),d0\t\t\n \tbeq\t1f              | if it is not set, then bit 24 is set\n \tlsrl\tIMM (1),d0\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\tIMM (1),d2\t|\n #else\n \taddl\tIMM (1),d2\t|\n@@ -3343,7 +3343,7 @@ Ldivsf$a$0:\n \tmovel\tIMM (0),d0\t\t| else return zero\n \tlea\tSYM (_fpCCR),a0\t\t|\n \tmovew\tIMM (0),a0@\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\t\t| \n #else\n \tmoveml\tsp@,d2-d7\t\t| \n@@ -3375,7 +3375,7 @@ Ldivsf$a$den:\n \tmovel\tIMM (1),d2\n \tandl\td5,d0\n 1:\taddl\td0,d0\t\t| shift a left until bit FLT_MANT_DIG-1 is set\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d2\t| and adjust exponent\n #else\n \tsubl\tIMM (1),d2\t| and adjust exponent\n@@ -3388,7 +3388,7 @@ Ldivsf$b$den:\n \tmovel\tIMM (1),d3\n \tandl\td5,d1\n 1:\taddl\td1,d1\t\t| shift b left until bit FLT_MANT_DIG is set\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tsubw\tIMM (1),d3\t| and adjust exponent\n #else\n \tsubl\tIMM (1),d3\t| and adjust exponent\n@@ -3401,7 +3401,7 @@ Lround$exit:\n | This is a common exit point for __mulsf3 and __divsf3. \n \n | First check for underlow in the exponent:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (-FLT_MANT_DIG-1),d2\t\t\n #else\n \tcmpl\tIMM (-FLT_MANT_DIG-1),d2\t\t\n@@ -3412,14 +3412,14 @@ Lround$exit:\n | exponent until it becomes 1 or the fraction is zero (in the latter case \n | we signal underflow and return zero).\n \tmovel\tIMM (0),d6\t| d6 is used temporarily\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (1),d2\t| if the exponent is less than 1 we \n #else\n \tcmpl\tIMM (1),d2\t| if the exponent is less than 1 we \n #endif\n \tbge\t2f\t\t| have to shift right (denormalize)\n 1:\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\tIMM (1),d2\t| adjust the exponent\n \tlsrl\tIMM (1),d0\t| shift right once \n \troxrl\tIMM (1),d1\t|\n@@ -3446,12 +3446,12 @@ Lround$exit:\n | Now call the rounding routine (which takes care of denormalized numbers):\n \tlea\tLround$0,a0\t| to return from rounding routine\n \tlea\tSYM (_fpCCR),a1\t| check the rounding mode\n-#ifdef __mcf5200__\n+#ifdef __mcoldfire__\n \tclrl\td6\n #endif\n \tmovew\ta1@(6),d6\t| rounding mode in d6\n \tbeq\tLround$to$nearest\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (ROUND_TO_PLUS),d6\n #else\n \tcmpl\tIMM (ROUND_TO_PLUS),d6\n@@ -3467,7 +3467,7 @@ Lround$0:\n | check again for underflow!). We have to check for overflow or for a \n | denormalized number (which also signals underflow).\n | Check for overflow (i.e., exponent >= 255).\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (0x00ff),d2\n #else\n \tcmpl\tIMM (0x00ff),d2\n@@ -3478,14 +3478,14 @@ Lround$0:\n \tbeq\tLf$den\n 1:\n | Put back the exponents and sign and return.\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlslw\tIMM (7),d2\t| exponent back to fourth byte\n #else\n \tlsll\tIMM (7),d2\t| exponent back to fourth byte\n #endif\n \tbclr\tIMM (FLT_MANT_DIG-1),d0\n \tswap\td0\t\t| and put back exponent\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \torw\td2,d0\t\t| \n #else\n \torl\td2,d0\n@@ -3495,7 +3495,7 @@ Lround$0:\n \n \tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -3514,7 +3514,7 @@ Lround$0:\n \n | float __negsf2(float);\n SYM (__negsf2):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@-\n #else\n@@ -3536,7 +3536,7 @@ SYM (__negsf2):\n \tbra\tLf$infty\t\t\n 1:\tlea\tSYM (_fpCCR),a0\n \tmovew\tIMM (0),a0@\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7\n #else\n \tmoveml\tsp@,d2-d7\n@@ -3558,7 +3558,7 @@ EQUAL   =  0\n \n | int __cmpsf2(float, float);\n SYM (__cmpsf2):\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tlink\ta6,IMM (0)\n \tmoveml\td2-d7,sp@- \t| save registers\n #else\n@@ -3595,7 +3595,7 @@ Lcmpsf$2:\n \ttstl\td6\n \tbpl\t1f\n | If both are negative exchange them\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \texg\td0,d1\n #else\n \tmovel\td0,d7\n@@ -3610,7 +3610,7 @@ Lcmpsf$2:\n \tbne\tLcmpsf$a$gt$b\t| |b| < |a|\n | If we got here a == b.\n \tmovel\tIMM (EQUAL),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -3619,7 +3619,7 @@ Lcmpsf$2:\n \trts\n Lcmpsf$a$gt$b:\n \tmovel\tIMM (GREATER),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -3630,7 +3630,7 @@ Lcmpsf$a$gt$b:\n \trts\n Lcmpsf$b$gt$a:\n \tmovel\tIMM (LESS),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tmoveml\tsp@+,d2-d7 \t| put back the registers\n #else\n \tmoveml\tsp@,d2-d7\n@@ -3668,15 +3668,15 @@ Lround$to$nearest:\n | Normalize shifting left until bit #FLT_MANT_DIG is set or the exponent \n | is one (remember that a denormalized number corresponds to an \n | exponent of -F_BIAS+1).\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tcmpw\tIMM (1),d2\t| remember that the exponent is at least one\n #else\n \tcmpl\tIMM (1),d2\t| remember that the exponent is at least one\n #endif\n  \tbeq\t2f\t\t| an exponent of one means denormalized\n \taddl\td1,d1\t\t| else shift and adjust the exponent\n \taddxl\td0,d0\t\t|\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \tdbra\td2,1b\t\t|\n #else\n \tsubql\tIMM (1),d2\n@@ -3705,7 +3705,7 @@ Lround$to$nearest:\n \tbtst\tIMM (FLT_MANT_DIG),d0\t\n \tbeq\t1f\n \tlsrl\tIMM (1),d0\n-#ifndef __mcf5200__\n+#ifndef __mcoldfire__\n \taddw\tIMM (1),d2\n #else\n \taddql\tIMM (1),d2"}, {"sha": "99996a4e670486e3dd582d8f6be854cd71741872", "filename": "gcc/config/m68k/linux.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Flinux.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -171,7 +171,7 @@ Boston, MA 02111-1307, USA.  */\n #undef ASM_OUTPUT_CASE_LABEL\n #define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n+    if (TARGET_COLDFIRE)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tif (ADDRESS_REG_P (operands[0]))\t\t\\\n \t  return \"jmp %%pc@(2,%0:l)\";\t\t\t\\"}, {"sha": "8bd885521e38d9d617651cb1e129159cb4d9c1a4", "filename": "gcc/config/m68k/m68k-none.h", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k-none.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-none.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -91,7 +91,7 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n #undef CPP_FPU_SPEC\n #if TARGET_DEFAULT & MASK_68881\n #define CPP_FPU_SPEC \"\\\n-%{!mc68000:%{!m68000:%{!m68302:%{!mcpu32:%{!m68332:%{!m5200:%{!msoft-float:%{!mno-68881:-D__HAVE_68881__ }}}}}}}} \\\n+%{!mc68000:%{!m68000:%{!m68302:%{!mcpu32:%{!m68332:%{!m5200:%{!m5206e:%{!m528x:%{!m5307:%{!m5407:%{!msoft-float:%{!mno-68881:-D__HAVE_68881__ }}}}}}}}}}}} \\\n %{m68881:-D__HAVE_68881__ }\"\n #else\n #define CPP_FPU_SPEC \"\\\n@@ -113,25 +113,34 @@ Unrecognized value in TARGET_CPU_DEFAULT.\n    -m68302: define mc68302 \n    -m68332: define mc68332 mcpu32\n    -mcpu32: define mcpu32\n-   -m5200: define mcf5200\n+   -m5200: define mcoldfire mcf5200\n+   -m5206e: define mcoldfire mcf5200 mcf5206e\n+   -m528x: define mcoldfire mc5200 mc528x\n+   -m5307: define mcoldfire mc5300 mc5307\n+   -m5407: define mcoldfire mc5400 mc5407\n+\n    default: define as above appropriately\n \n    GCC won't automatically add __'d versions, we have to mention them\n    explicitly.  */\n \n #undef CPP_SPEC\n #define CPP_SPEC \"\\\n-%(cpp_fpu)%{!ansi:%{m68302:-Dmc68302 }%{m68010:-Dmc68010 }%{m68020:-Dmc68020 }%{mc68020:-Dmc68020 }%{m68030:-Dmc68030 }%{m68040:-Dmc68040 }%{m68020-40:-Dmc68020 -Dmc68030 -Dmc68040 }%{m68020-60:-Dmc68020 -Dmc68030 -Dmc68040 -Dmc68060 }%{m68060:-Dmc68060 }%{mcpu32:-Dmcpu32 } %{m68332:-Dmc68332 -Dmcpu32 }%{m5200:-Dmcf5200 }} \\\n-%{m68302:-D__mc68302__ -D__mc68302 }%{m68010:-D__mc68010__ -D__mc68010 }%{m68020:-D__mc68020__ -D__mc68020 }%{mc68020:-D__mc68020__ -D__mc68020 }%{m68030:-D__mc68030__ -D__mc68030 }%{m68040:-D__mc68040__ -D__mc68040 }%{m68020-40:-D__mc68020__ -D__mc68030__ -D__mc68040__ -D__mc68020 -D__mc68030 -D__mc68040 }%{m68020-60:-D__mc68020__ -D__mc68030__ -D__mc68040__ -D__mc68020 -D__mc68030 -D__mc68040 -D__mc68060__ -D__mc68060 }%{m68060:-D__mc68060__ -D__mc68060 }%{mcpu32:-D__mcpu32__ -D__mcpu32 }%{m68332:-D__mc68332__ -D__mc68332 -D__mcpu32__ -D__mcpu32 }%{m5200:-D__mcf5200__ -D__mcf5200 } \\\n-%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32: %{!m68332:%{!m5200:%(cpp_cpu_default)}}}}}}}}}}}}}} \\\n+%(cpp_fpu)%{!ansi:%{m68302:-Dmc68302 }%{m68010:-Dmc68010 }%{m68020:-Dmc68020 }%{mc68020:-Dmc68020 }%{m68030:-Dmc68030 }%{m68040:-Dmc68040 }%{m68020-40:-Dmc68020 -Dmc68030 -Dmc68040 }%{m68020-60:-Dmc68020 -Dmc68030 -Dmc68040 -Dmc68060 }%{m68060:-Dmc68060 }%{mcpu32:-Dmcpu32 } %{m68332:-Dmc68332 -Dmcpu32 }%{m5200:-Dmcoldfire -Dmcf5200 }%{m5206e:-Dmcoldfire -Dmcf5200 -Dmcf5206e }%{m528x:-Dmcoldfire -Dmcf5200 -Dmcf528x }%{m5307:-Dmcoldfire -Dmcf5300 -Dmcf5307 }%{m5407: -Dmcoldfire -Dmcf5400 -Dmcf5407 }} \\\n+%{m68302:-D__mc68302__ -D__mc68302 }%{m68010:-D__mc68010__ -D__mc68010 }%{m68020:-D__mc68020__ -D__mc68020 }%{mc68020:-D__mc68020__ -D__mc68020 }%{m68030:-D__mc68030__ -D__mc68030 }%{m68040:-D__mc68040__ -D__mc68040 }%{m68020-40:-D__mc68020__ -D__mc68030__ -D__mc68040__ -D__mc68020 -D__mc68030 -D__mc68040 }%{m68020-60:-D__mc68020__ -D__mc68030__ -D__mc68040__ -D__mc68020 -D__mc68030 -D__mc68040 -D__mc68060__ -D__mc68060 }%{m68060:-D__mc68060__ -D__mc68060 }%{mcpu32:-D__mcpu32__ -D__mcpu32 }%{m68332:-D__mc68332__ -D__mc68332 -D__mcpu32__ -D__mcpu32 }%{m5200:-D__mcf5200__ -D__mcf5200 -D__mcoldfire__ } \\\n+%{m5206e:-D__mcoldfire__ -D__mcf5200__ -D__mcf5200 -D__mcf5206e__ -D__mcf5206e } \\\n+%{m528x:-D__mcoldfire__ -D__mcf5200__ -D__mcf5200 -D__mcf528x__ -D__mcf528x } \\\n+%{m5307:-D__mcoldfire__ -D__mcf5300__ -D__mcf5300 -D__mcf5307__ -D__mcf5307 } \\\n+%{m5407:-D__mcoldfire__ -D__mcf5400__ -D__mcf5400 -D__mcf5407__ -D__mcf5407 } \\\n+%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32: %{!m68332:%{!m5200:%{!m5206e:%{!m528x:%{!m5307:%{!m5407:%(cpp_cpu_default)}}}}}}}}}}}}}}}}}} \\\n %(cpp_subtarget) \\\n \"\n \n /* Pass flags to gas indicating which type of processor we have.  */\n \n #undef ASM_SPEC\n #define ASM_SPEC \"\\\n-%{m68851}%{mno-68851}%{m68881}%{mno-68881}%{msoft-float:-mno-68881} %{m68000}%{m68302}%{mc68000}%{m68010}%{m68020}%{mc68020}%{m68030}%{m68040}%{m68020-40:-mc68040} %{m68020-60:-mc68040} %{m68060}%{mcpu32}%{m68332}%{m5200}%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32:%{!m68332:%{!m5200:%(asm_cpu_default)}}}}}}}}}}}}}} \\\n+%{m68851}%{mno-68851}%{m68881}%{mno-68881}%{msoft-float:-mno-68881} %{m68000}%{m68302}%{mc68000}%{m68010}%{m68020}%{mc68020}%{m68030}%{m68040}%{m68020-40:-mc68040} %{m68020-60:-mc68040} %{m68060}%{mcpu32}%{m68332}%{m5200}%{m5206e}%{m528x}%{m5307}%{m5407}%{!mc68000:%{!m68000:%{!m68302:%{!m68010:%{!mc68020:%{!m68020:%{!m68030:%{!m68040:%{!m68020-40:%{!m68020-60:%{!m68060:%{!mcpu32:%{!m68332:%{!m5200:%{!m5206e:%{!m528x:%{!m5307:%{!m5407:%(asm_cpu_default)}}}}}}}}}}}}}}}}}} \\\n \"\n \n /* cc1/cc1plus always receives all the -m flags. If the specs strings above "}, {"sha": "e304a655962bebc6c5450425df73b2ce809fe593", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -347,7 +347,7 @@ m68k_output_function_prologue (stream, size)\n \t{\n \t  if (fsize + 4 <= 8)\n \t    {\n-\t      if (!TARGET_5200)\n+\t      if (!TARGET_COLDFIRE)\n \t\t{\n \t\t  /* asm_fprintf() cannot handle %.  */\n #ifdef MOTOROLA\n@@ -511,7 +511,7 @@ m68k_output_function_prologue (stream, size)\n     }\n   else if (mask)\n     {\n-      if (TARGET_5200)\n+      if (TARGET_COLDFIRE)\n \t{\n \t  /* The coldfire does not support the predecrement form of the \n \t     movml instruction, so we must adjust the stack pointer and\n@@ -666,7 +666,7 @@ m68k_output_function_epilogue (stream, size)\n #endif\n       fsize = 0, big = 1;\n     }\n-  if (TARGET_5200 || nregs <= 2)\n+  if (TARGET_COLDFIRE || nregs <= 2)\n     {\n       /* Restore each separately in the same order moveml does.\n          Using two movel instructions instead of a single moveml\n@@ -799,7 +799,7 @@ m68k_output_function_epilogue (stream, size)\n     {\n       if (fsize + 4 <= 8) \n \t{\n-\t  if (!TARGET_5200)\n+\t  if (!TARGET_COLDFIRE)\n \t    {\n #ifdef MOTOROLA\n \t      asm_fprintf (stream, \"\\taddq.w %I%wd,%Rsp\\n\", fsize + 4);\n@@ -1091,7 +1091,7 @@ output_scc_di(op, operand1, operand2, dest)\n     }\n   else\n     {\n-      if (TARGET_68020 || TARGET_5200 || ! ADDRESS_REG_P (loperands[0]))\n+      if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (loperands[0]))\n \toutput_asm_insn (\"tst%.l %0\", loperands);\n       else\n \t{\n@@ -1108,7 +1108,7 @@ output_scc_di(op, operand1, operand2, dest)\n       output_asm_insn (\"jne %l4\", loperands);\n #endif\n \n-      if (TARGET_68020 || TARGET_5200 || ! ADDRESS_REG_P (loperands[1]))\n+      if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (loperands[1]))\n \toutput_asm_insn (\"tst%.l %1\", loperands);\n       else\n \t{\n@@ -1426,7 +1426,7 @@ const_method (constant)\n \n   /* The Coldfire doesn't have byte or word operations.  */\n   /* FIXME: This may not be useful for the m68060 either */\n-  if (!TARGET_5200) \n+  if (!TARGET_COLDFIRE) \n     {\n       /* if -256 < N < 256 but N is not in range for a moveq\n \t N^ff will be, so use moveq #N^ff, dreg; not.b dreg.  */\n@@ -1630,7 +1630,7 @@ output_move_simode_const (operands)\n \t  || GET_CODE (operands[0]) == MEM)\n       /* clr insns on 68000 read before writing.\n \t This isn't so on the 68010, but we have no TARGET_68010.  */\n-      && ((TARGET_68020 || TARGET_5200)\n+      && ((TARGET_68020 || TARGET_COLDFIRE)\n \t  || !(GET_CODE (operands[0]) == MEM\n \t       && MEM_VOLATILE_P (operands[0]))))\n     return \"clr%.l %0\";\n@@ -1680,7 +1680,7 @@ output_move_himode (operands)\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n \t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && ((TARGET_68020 || TARGET_5200)\n+\t  && ((TARGET_68020 || TARGET_COLDFIRE)\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n \treturn \"clr%.w %0\";\n@@ -1746,7 +1746,7 @@ output_move_qimode (operands)\n       && GET_CODE (XEXP (operands[0], 0)) == PRE_DEC\n       && XEXP (XEXP (operands[0], 0), 0) == stack_pointer_rtx\n       && ! ADDRESS_REG_P (operands[1])\n-      && ! TARGET_5200)\n+      && ! TARGET_COLDFIRE)\n     {\n       xoperands[1] = operands[1];\n       xoperands[2]\n@@ -1767,12 +1767,12 @@ output_move_qimode (operands)\n   /* clr and st insns on 68000 read before writing.\n      This isn't so on the 68010, but we have no TARGET_68010.  */\n   if (!ADDRESS_REG_P (operands[0])\n-      && ((TARGET_68020 || TARGET_5200)\n+      && ((TARGET_68020 || TARGET_COLDFIRE)\n \t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     {\n       if (operands[1] == const0_rtx)\n \treturn \"clr%.b %0\";\n-      if ((!TARGET_5200 || DATA_REG_P (operands[0]))\n+      if ((!TARGET_COLDFIRE || DATA_REG_P (operands[0]))\n \t  && GET_CODE (operands[1]) == CONST_INT\n \t  && (INTVAL (operands[1]) & 255) == 255)\n \t{\n@@ -1805,7 +1805,7 @@ output_move_stricthi (operands)\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n \t This isn't so on the 68010, but we have no TARGET_68010.  */\n-      && ((TARGET_68020 || TARGET_5200)\n+      && ((TARGET_68020 || TARGET_COLDFIRE)\n \t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     return \"clr%.w %0\";\n   return \"move%.w %1,%0\";\n@@ -1818,7 +1818,7 @@ output_move_strictqi (operands)\n   if (operands[1] == const0_rtx\n       /* clr insns on 68000 read before writing.\n          This isn't so on the 68010, but we have no TARGET_68010.  */\n-      && ((TARGET_68020 || TARGET_5200)\n+      && ((TARGET_68020 || TARGET_COLDFIRE)\n           || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     return \"clr%.b %0\";\n   return \"move%.b %1,%0\";\n@@ -3303,7 +3303,7 @@ output_andsi3 (operands)\n       && (INTVAL (operands[2]) | 0xffff) == 0xffffffff\n       && (DATA_REG_P (operands[0])\n \t  || offsettable_memref_p (operands[0]))\n-      && !TARGET_5200)\n+      && !TARGET_COLDFIRE)\n     {\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adjust_address (operands[0], HImode, 2);\n@@ -3344,7 +3344,7 @@ output_iorsi3 (operands)\n       && INTVAL (operands[2]) >> 16 == 0\n       && (DATA_REG_P (operands[0])\n \t  || offsettable_memref_p (operands[0]))\n-      && !TARGET_5200)\n+      && !TARGET_COLDFIRE)\n     {\n       if (GET_CODE (operands[0]) != REG)\n         operands[0] = adjust_address (operands[0], HImode, 2);\n@@ -3380,7 +3380,7 @@ output_xorsi3 (operands)\n   if (GET_CODE (operands[2]) == CONST_INT\n       && INTVAL (operands[2]) >> 16 == 0\n       && (offsettable_memref_p (operands[0]) || DATA_REG_P (operands[0]))\n-      && !TARGET_5200)\n+      && !TARGET_COLDFIRE)\n     {\n       if (! DATA_REG_P (operands[0]))\n \toperands[0] = adjust_address (operands[0], HImode, 2);"}, {"sha": "808a93a73d053310c52406012aa0b1daa945e70b", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 58, "deletions": 18, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -143,23 +143,47 @@ extern int target_flags;\n #define MASK_NO_STRICT_ALIGNMENT 16384\n #define TARGET_STRICT_ALIGNMENT  (~target_flags & MASK_NO_STRICT_ALIGNMENT)\n \n+/* Build for ColdFire v3 */\n+#define MASK_CFV3\t0x8000\n+#define TARGET_CFV3\t(target_flags & MASK_CFV3)\n+\n+/* Build for ColdFire v4 */\n+#define MASK_CFV4\t0x10000\n+#define TARGET_CFV4\t(target_flags & MASK_CFV4)\n+\n+/* Divide support for ColdFire */\n+#define MASK_CF_HWDIV\t0x40000\n+#define TARGET_CF_HWDIV\t(target_flags & MASK_CF_HWDIV)\n+\n+/* Compile for mcf582 */\n+#define MASK_528x\t0x80000\n+#define TARGET_528x (target_flags & MASK_528x)\n+\n+\n+/* Is the target a coldfire */\n+#define MASK_COLDFIRE\t(MASK_5200|MASK_528x|MASK_CFV3|MASK_CFV4)\n+#define TARGET_COLDFIRE\t(target_flags & MASK_COLDFIRE)\n+\n+/* Which bits can be set by specifying a coldfire */\n+#define MASK_ALL_CF_BITS\t(MASK_COLDFIRE|MASK_CF_HWDIV)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n    where VALUE is the bits to set or minus the bits to clear.\n    An empty string NAME is used to identify the default VALUE.  */\n \n #define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n-  { { \"68020\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n+  { { \"68020\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n       N_(\"Generate code for a 68020\") },\t\t\t\t\\\n-    { \"c68020\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n+    { \"c68020\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n       N_(\"Generate code for a 68020\") },\t\t\t\t\\\n     { \"68020\", (MASK_68020|MASK_BITFIELD), \"\" },\t\t\t\\\n     { \"c68020\", (MASK_68020|MASK_BITFIELD), \"\" },\t\t\t\\\n-    { \"68000\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n+    { \"68000\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n \t\t|MASK_68020|MASK_BITFIELD|MASK_68881),\t\t\t\\\n       N_(\"Generate code for a 68000\") },\t\t\t\t\\\n-    { \"c68000\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n+    { \"c68000\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n \t\t|MASK_68020|MASK_BITFIELD|MASK_68881),\t\t\t\\\n       N_(\"Generate code for a 68000\") },\t\t\t\t\\\n     { \"bitfield\", MASK_BITFIELD,\t\t\t\t\t\\\n@@ -177,40 +201,56 @@ extern int target_flags;\n     { \"68881\", MASK_68881, \"\" },\t\t\t\t\t\\\n     { \"soft-float\", - (MASK_68040_ONLY|MASK_68881),\t\t\t\\\n       N_(\"Generate code with library calls for floating point\") },\t\\\n-    { \"68020-40\", -(MASK_5200|MASK_68060|MASK_68040_ONLY),\t\t\\\n+    { \"68020-40\", -(MASK_ALL_CF_BITS|MASK_68060|MASK_68040_ONLY),\t\t\\\n       N_(\"Generate code for a 68040, without any new instructions\") },\t\\\n     { \"68020-40\", (MASK_BITFIELD|MASK_68881|MASK_68020|MASK_68040), \"\"},\\\n-    { \"68020-60\", -(MASK_5200|MASK_68040_ONLY),\t\t\t\t\\\n+    { \"68020-60\", -(MASK_ALL_CF_BITS|MASK_68040_ONLY),\t\t\t\t\\\n       N_(\"Generate code for a 68060, without any new instructions\") },\t\\\n     { \"68020-60\", (MASK_BITFIELD|MASK_68881|MASK_68020|MASK_68040\t\\\n \t\t   |MASK_68060), \"\" },\t\t\t\t\t\\\n-    { \"68030\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n+    { \"68030\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY),\t\\\n       N_(\"Generate code for a 68030\") },\t\t\t\t\\\n     { \"68030\", (MASK_68020|MASK_BITFIELD), \"\" },\t\t\t\\\n-    { \"68040\", - (MASK_5200|MASK_68060),\t\t\t\t\\\n+    { \"68040\", - (MASK_ALL_CF_BITS|MASK_68060),\t\t\t\t\\\n       N_(\"Generate code for a 68040\") },\t\t\t\t\\\n     { \"68040\", (MASK_68020|MASK_68881|MASK_BITFIELD\t\t\t\\\n \t\t|MASK_68040_ONLY|MASK_68040), \"\" },\t\t\t\\\n-    { \"68060\", - (MASK_5200|MASK_68040),\t\t\t\t\\\n+    { \"68060\", - (MASK_ALL_CF_BITS|MASK_68040),\t\t\t\t\\\n       N_(\"Generate code for a 68060\") },\t\t\t\t\\\n     { \"68060\", (MASK_68020|MASK_68881|MASK_BITFIELD\t\t\t\\\n \t\t|MASK_68040_ONLY|MASK_68060), \"\" },\t\t\t\\\n-    { \"5200\", - (MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n+    { \"5200\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n \t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a 520X\") },\t\t\t\t\t\\\n     { \"5200\", (MASK_5200), \"\" },\t\t\t\t\t\\\n+    { \"5206e\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n+\t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n+      N_(\"Generate code for a 5206e\") },\t\t\t\t\t\\\n+    { \"5206e\", (MASK_5200|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"528x\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n+\t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n+      N_(\"Generate code for a 528x\") },\t\t\t\t\t\\\n+    { \"528x\", (MASK_528x|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"5307\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n+\t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n+      N_(\"Generate code for a 5307\") },\t\t\t\t\t\\\n+    { \"5307\", (MASK_CFV3|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n+    { \"5407\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY|MASK_68020\t\\\n+\t\t|MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n+      N_(\"Generate code for a 5407\") },\t\t\t\t\t\\\n+    { \"5407\", (MASK_CFV4|MASK_CF_HWDIV), \"\" },\t\t\t\t\t\\\n     { \"68851\", 0,\t\t\t\t\t\t\t\\\n       N_(\"Generate code for a 68851\") },\t\t\t\t\\\n     { \"no-68851\", 0,\t\t\t\t\t\t\t\\\n       N_(\"Do no generate code for a 68851\") },\t\t\t\t\\\n-    { \"68302\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n+    { \"68302\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n \t\t  |MASK_68020|MASK_BITFIELD|MASK_68881),\t\t\\\n       N_(\"Generate code for a 68302\") },\t\t\t\t\\\n-    { \"68332\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n+    { \"68332\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n \t\t  |MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a 68332\") },\t\t\t\t\\\n     { \"68332\", MASK_68020, \"\" },\t\t\t\t\t\\\n-    { \"cpu32\", - (MASK_5200|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n+    { \"cpu32\", - (MASK_ALL_CF_BITS|MASK_68060|MASK_68040|MASK_68040_ONLY\t\\\n \t\t  |MASK_BITFIELD|MASK_68881),\t\t\t\t\\\n       N_(\"Generate code for a cpu32\") },\t\t\t\t\\\n     { \"cpu32\", MASK_68020, \"\" },\t\t\t\t\t\\\n@@ -688,12 +728,12 @@ enum reg_class {\n    this says how many the stack pointer really advances by.\n    On the 68000, sp@- in a byte insn really pushes a word.\n    On the 5200 (coldfire), sp@- in a byte insn pushes just a byte.  */\n-#define PUSH_ROUNDING(BYTES) (TARGET_5200 ? BYTES : ((BYTES) + 1) & ~1)\n+#define PUSH_ROUNDING(BYTES) (TARGET_COLDFIRE ? BYTES : ((BYTES) + 1) & ~1)\n \n /* We want to avoid trying to push bytes.  */\n #define MOVE_BY_PIECES_P(SIZE, ALIGN) \\\n   (move_by_pieces_ninsns (SIZE, ALIGN) < MOVE_RATIO \\\n-    && (((SIZE) >=16 && (ALIGN) >= 16) || (TARGET_5200)))\n+    && (((SIZE) >=16 && (ALIGN) >= 16) || (TARGET_COLDFIRE)))\n \n /* Offset of first parameter from the argument pointer register value.  */\n #define FIRST_PARM_OFFSET(FNDECL) 8\n@@ -1122,7 +1162,7 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n /* coldfire/5200 does not allow HImode index registers.  */\n #define LEGITIMATE_INDEX_REG_P(X)   \\\n   ((GET_CODE (X) == REG && REG_OK_FOR_INDEX_P (X))\t\\\n-   || (! TARGET_5200\t\t\t\t\t\\\n+   || (! TARGET_COLDFIRE\t\t\t\t\t\\\n        && GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n        && GET_CODE (XEXP (X, 0)) == REG\t\t\t\\\n        && GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n@@ -1133,12 +1173,12 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n #define LEGITIMATE_INDEX_P(X)   \\\n    (LEGITIMATE_INDEX_REG_P (X)\t\t\t\t\\\n-    || ((TARGET_68020 || TARGET_5200) && GET_CODE (X) == MULT \\\n+    || ((TARGET_68020 || TARGET_COLDFIRE) && GET_CODE (X) == MULT \\\n \t&& LEGITIMATE_INDEX_REG_P (XEXP (X, 0))\t\t\\\n \t&& GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\\\n \t&& (INTVAL (XEXP (X, 1)) == 2\t\t\t\\\n \t    || INTVAL (XEXP (X, 1)) == 4\t\t\\\n-\t    || (INTVAL (XEXP (X, 1)) == 8 && !TARGET_5200))))\n+\t    || (INTVAL (XEXP (X, 1)) == 8 && !TARGET_COLDFIRE))))\n \n /* If pic, we accept INDEX+LABEL, which is what do_tablejump makes.  */\n #define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\"}, {"sha": "1917717076dc7ee82735ff9d8794576356e8f0ef", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 237, "deletions": 183, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -24,7 +24,7 @@\n ;;- The MCF5200 \"ColdFire\" architecture is a reduced version of the\n ;;- 68k ISA.  Differences include reduced support for byte and word\n ;;- operands and the removal of BCD, bitfield, rotate, and integer\n-;;- divide instructions.  The TARGET_5200 flag turns the use of the\n+;;- divide instructions.  The TARGET_COLDFIRE flag turns the use of the\n ;;- removed opcodes and addressing modes off.\n ;;- \n \n@@ -199,7 +199,7 @@\n   \"\"\n   \"*\n {\n-  if (TARGET_68020 || TARGET_5200 || ! ADDRESS_REG_P (operands[0]))\n+  if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (operands[0]))\n     return \\\"tst%.l %0\\\";\n   /* If you think that the 68020 does not support tstl a0,\n      reread page B-167 of the 68020 manual more carefully.  */\n@@ -333,7 +333,7 @@\n   [(set (cc0)\n         (compare (match_operand:SI 0 \"nonimmediate_operand\" \"rKT,rKs,mSr,mSa,>\")\n                  (match_operand:SI 1 \"general_src_operand\" \"mSr,mSa,KTr,Ksr,>\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n@@ -373,7 +373,7 @@\n   [(set (cc0)\n \t(compare (match_operand:SI 0 \"nonimmediate_operand\" \"mrKs,r\")\n \t\t (match_operand:SI 1 \"general_operand\" \"r,mrKs\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   if (REG_P (operands[1])\n@@ -396,14 +396,14 @@\n   [(set (cc0)\n         (compare (match_operand:HI 0 \"nonimmediate_src_operand\" \"\")\n                  (match_operand:HI 1 \"general_src_operand\" \"\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n (define_insn \"\"\n   [(set (cc0)\n         (compare (match_operand:HI 0 \"nonimmediate_src_operand\" \"rnmS,d,n,mS,>\")\n                  (match_operand:HI 1 \"general_src_operand\" \"d,rnmS,mS,n,>\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n@@ -432,14 +432,14 @@\n   [(set (cc0)\n         (compare (match_operand:QI 0 \"nonimmediate_src_operand\" \"\")\n                  (match_operand:QI 1 \"general_src_operand\" \"\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"m68k_last_compare_had_fp_operands = 0;\")\n \n (define_insn \"\"\n   [(set (cc0)\n         (compare (match_operand:QI 0 \"nonimmediate_src_operand\" \"dn,dmS,>\")\n                  (match_operand:QI 1 \"general_src_operand\" \"dmS,nd,>\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[0]) == MEM && GET_CODE (operands[1]) == MEM)\n@@ -557,7 +557,7 @@\n \t\t\t    (const_int 1)\n \t\t\t    (minus:SI (const_int 7)\n \t\t\t\t      (match_operand:SI 1 \"general_operand\" \"di\"))))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n \n ;; This is the same as the above pattern except for the constraints.  The 'i'\n@@ -568,7 +568,7 @@\n \t\t\t    (const_int 1)\n \t\t\t    (minus:SI (const_int 7)\n \t\t\t\t      (match_operand:SI 1 \"general_operand\" \"d\"))))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* { return output_btst (operands, operands[1], operands[0], insn, 7); }\")\n \n (define_insn \"\"\n@@ -609,7 +609,7 @@\n   [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n-  \"(unsigned) INTVAL (operands[1]) < 8 && !TARGET_5200\"\n+  \"(unsigned) INTVAL (operands[1]) < 8 && !TARGET_COLDFIRE\"\n   \"*\n {\n   operands[1] = GEN_INT (7 - INTVAL (operands[1]));\n@@ -620,7 +620,7 @@\n   [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"do\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[0]) == MEM)\n@@ -641,7 +641,7 @@\n   [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"dQ\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[0]) == MEM)\n@@ -688,7 +688,7 @@\n \t(const_int 0))]\n   ;; clr insns on 68000 read before writing.\n   ;; This isn't so on the 68010, but we have no TARGET_68010.\n-  \"((TARGET_68020 || TARGET_5200)\n+  \"((TARGET_68020 || TARGET_COLDFIRE)\n     || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0])))\"\n   \"*\n {\n@@ -712,7 +712,7 @@\n \t}\n     }\n   /* moveq is faster on the 68000.  */\n-  if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_5200))\n+  if (DATA_REG_P (operands[0]) && (!TARGET_68020 && !TARGET_COLDFIRE))\n     return \\\"moveq %#0,%0\\\";\n   return \\\"clr%.l %0\\\";\n }\")\n@@ -763,7 +763,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=g,d,a<\")\n         (match_operand:SI 1 \"general_src_operand\" \"daymSKT,n,i\"))]\n \n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   return output_move_simode (operands);\n@@ -772,7 +772,7 @@\n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r<Q>,g\")\n \t(match_operand:SI 1 \"general_operand\" \"g,r<Q>\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_simode (operands);\")\n \n ;; Special case of fullword move, where we need to get a non-GOT PIC\n@@ -797,13 +797,13 @@\n (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=g\")\n         (match_operand:HI 1 \"general_src_operand\" \"gS\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"* return output_move_himode (operands);\")\n \n  (define_insn \"\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r<Q>,g\")\n \t(match_operand:HI 1 \"general_operand\" \"g,r<Q>\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_himode (operands);\")\n \n (define_expand \"movstricthi\"\n@@ -815,13 +815,13 @@\n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(match_operand:HI 1 \"general_src_operand\" \"rmSn\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"* return output_move_stricthi (operands);\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+d,m\"))\n \t(match_operand:HI 1 \"general_src_operand\" \"rmn,r\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_stricthi (operands);\")\n \n (define_expand \"movqi\"\n@@ -833,13 +833,13 @@\n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d,*a,m\")\n \t(match_operand:QI 1 \"general_src_operand\" \"dmSi*a,di*a,dmSi\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"* return output_move_qimode (operands);\")\n \n (define_insn \"\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d<Q>,dm,d*a\")\n \t(match_operand:QI 1 \"general_src_operand\" \"dmi,d<Q>,di*a\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_qimode (operands);\")\n \n (define_expand \"movstrictqi\"\n@@ -851,20 +851,20 @@\n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(match_operand:QI 1 \"general_src_operand\" \"dmSn\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"* return output_move_strictqi (operands);\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+d,m\"))\n \t(match_operand:QI 1 \"general_src_operand\" \"dmn,d\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_strictqi (operands);\")\n \n (define_expand \"pushqi1\"\n   [(set (reg:SI 15) (plus:SI (reg:SI 15) (const_int -2)))\n    (set (mem:QI (plus:SI (reg:SI 15) (const_int 1)))\n \t(match_operand:QI 0 \"general_operand\" \"\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"\")\n \n (define_expand \"movsf\"\n@@ -876,7 +876,7 @@\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=rmf\")\n \t(match_operand:SF 1 \"general_operand\" \"rmfF\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (FP_REG_P (operands[0]))\n@@ -898,7 +898,7 @@\n   if (operands[1] == CONST0_RTX (SFmode)\n       /* clr insns on 68000 read before writing.\n \t This isn't so on the 68010, but we have no TARGET_68010.  */\n-      && ((TARGET_68020 || TARGET_5200)\n+      && ((TARGET_68020 || TARGET_COLDFIRE)\n \t  || !(GET_CODE (operands[0]) == MEM && MEM_VOLATILE_P (operands[0]))))\n     {\n       if (ADDRESS_REG_P (operands[0]))\n@@ -921,7 +921,7 @@\n \t    }\n \t}\n       /* moveq is faster on the 68000.  */\n-      if (DATA_REG_P (operands[0]) && !(TARGET_68020 || TARGET_5200))\n+      if (DATA_REG_P (operands[0]) && !(TARGET_68020 || TARGET_COLDFIRE))\n \t{\n \t  return \\\"moveq %#0,%0\\\";\n \t}\n@@ -933,7 +933,7 @@\n (define_insn \"\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:SF 1 \"general_operand\" \"g,r\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return \\\"move%.l %1,%0\\\";\")\n \n (define_expand \"movdf\"\n@@ -947,7 +947,7 @@\n \t(match_operand:DF 1 \"general_operand\" \"*rf,m,0,*rofE<>\"))]\n ;  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=rm,&rf,&rof<>\")\n ;\t(match_operand:DF 1 \"general_operand\" \"rf,m,rofF<>\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (FP_REG_P (operands[0]))\n@@ -983,7 +983,7 @@\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:DF 1 \"general_operand\" \"g,r\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_double (operands);\")\n \n ;; ??? The XFmode patterns are schizophrenic about whether constants are\n@@ -1062,7 +1062,7 @@\n (define_insn \"\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=rm,rf,&rof<>\")\n \t(match_operand:XF 1 \"nonimmediate_operand\" \"rf,m,rof<>\"))]\n-  \"! TARGET_68881 && ! TARGET_5200\"\n+  \"! TARGET_68881 && ! TARGET_COLDFIRE\"\n   \"*\n {\n   if (FP_REG_P (operands[0]))\n@@ -1103,7 +1103,7 @@\n (define_insn \"\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:XF 1 \"nonimmediate_operand\" \"g,r\"))]\n-  \"! TARGET_68881 && TARGET_5200\"\n+  \"! TARGET_68881 && TARGET_COLDFIRE\"\n   \"* return output_move_double (operands);\")\n \n (define_expand \"movdi\"\n@@ -1122,7 +1122,7 @@\n ;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF\"))]\n ;  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm,&rf,&ro<>,!&rm,!&f\")\n ;\t(match_operand:DI 1 \"general_operand\" \"r,m,roi<>,fF,rfF\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (FP_REG_P (operands[0]))\n@@ -1158,7 +1158,7 @@\n (define_insn \"\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,g\")\n \t(match_operand:DI 1 \"general_operand\" \"g,r\"))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_move_double (operands);\")\n \n ;; Thus goes after the move instructions\n@@ -1273,7 +1273,7 @@\n (define_insn \"*zero_extendsidi2_cf\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,m\")\n     (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm,r\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -1297,7 +1297,7 @@\n (define_insn \"*zero_extendsidi2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=rm\")\n     (zero_extend:DI (match_operand:SI 1 \"general_operand\" \"rm\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -1398,9 +1398,9 @@\n     {\n       if (GET_CODE (operands[1]) == REG\n \t  && REGNO (operands[0]) == REGNO (operands[1]))\n-\treturn (!TARGET_5200 ? \\\"and%.w %#0xFF,%0\\\" : \\\"and%.l %#0xFF,%0\\\");\n+\treturn (!TARGET_COLDFIRE ? \\\"and%.w %#0xFF,%0\\\" : \\\"and%.l %#0xFF,%0\\\");\n       if (reg_mentioned_p (operands[0], operands[1]))\n-\treturn (!TARGET_5200 ? \\\"move%.b %1,%0\\;and%.w %#0xFF,%0\\\" \n+\treturn (!TARGET_COLDFIRE ? \\\"move%.b %1,%0\\;and%.w %#0xFF,%0\\\" \n \t\t\t     : \\\"move%.b %1,%0\\;and%.l %#0xFF,%0\\\");\n       return \\\"clr%.w %0\\;move%.b %1,%0\\\";\n     }\n@@ -1490,7 +1490,7 @@\n {\n   CC_STATUS_INIT;\n   operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     return \\\"move%.b %1,%2\\;extb%.l %2\\;smi %0\\;extb%.l %0\\\";\n   else\n     return \\\"move%.b %1,%2\\;ext%.w %0\\;ext%.l %2\\;move%.l %2,%0\\;smi %0\\\";\n@@ -1505,7 +1505,7 @@\n {\n   CC_STATUS_INIT;\n   operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     return \\\"move%.w %1,%2\\;ext%.l %2\\;smi %0\\;extb%.l %0\\\";\n   else\n     return \\\"move%.w %1,%2\\;ext%.l %2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n@@ -1520,7 +1520,7 @@\n {\n   CC_STATUS_INIT;\n   operands[2] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     return \\\"move%.l %1,%2\\;smi %0\\;extb%.l %0\\\";\n   else\n     return \\\"move%.l %1,%2\\;smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n@@ -1552,7 +1552,7 @@\n     output_asm_insn (\\\"add%.l %2,%3\\\", operands);\n   else\n     output_asm_insn (\\\"move%.l %2,%3\\;add%.l %1,%3\\\", operands);\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     return \\\"smi %0\\;extb%.l %0\\\";\n   else\n     return \\\"smi %0\\;ext%.w %0\\;ext%.l %0\\\";\n@@ -1579,7 +1579,7 @@\n (define_insn \"extendqisi2\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(sign_extend:SI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))]\n-  \"TARGET_68020 || TARGET_5200\"\n+  \"TARGET_68020 || TARGET_COLDFIRE\"\n   \"extb%.l %0\")\n \f\n ;; Conversions between float and double.\n@@ -1836,7 +1836,7 @@\n    && GET_CODE (XEXP (operands[1], 0)) == PRE_DEC)\n     output_asm_insn (\\\"move%.l %4,%3\\\", operands);\n   output_asm_insn (\\\"move%.l %1,%0\\;smi %2\\\", operands);\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     output_asm_insn (\\\"extb%.l %2\\\", operands);\n   else\n     output_asm_insn (\\\"ext%.w %2\\;ext%.l %2\\\", operands);\n@@ -1853,7 +1853,7 @@\n             (const_int 32))\n         (match_operand:DI 2 \"general_operand\" \"0,0,0,0\")))\n    (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2031,29 +2031,29 @@\n                  (match_operand:SI 2 \"general_src_operand\" \"dIKLT,rJK,a,mSrIKLT,mSrIKLs\")))]\n \n \n-  \"! TARGET_5200\"\n+  \"! TARGET_COLDFIRE\"\n   \"* return output_addsi3 (operands);\")\n \n (define_insn \"*addsi3_5200\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,?a,?a,r\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"%0,a,rJK,0\")\n \t\t (match_operand:SI 2 \"general_src_operand\" \"d,rJK,a,mrIKLs\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"* return output_addsi3 (operands);\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=a\")\n \t(plus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t (sign_extend:SI\n \t\t  (match_operand:HI 2 \"nonimmediate_src_operand\" \"rmS\"))))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"add%.w %2,%0\")\n \n (define_insn \"addhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,r\")\n \t(plus:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t (match_operand:HI 2 \"general_src_operand\" \"dn,rmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -2113,7 +2113,7 @@\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(plus:HI (match_dup 0)\n \t\t (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -2167,7 +2167,7 @@\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(plus:HI (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")\n \t\t (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -2221,7 +2221,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(plus:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n \t\t (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n@@ -2245,7 +2245,7 @@\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(plus:QI (match_dup 0)\n \t\t (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -2269,7 +2269,7 @@\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(plus:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[1]) == CONST_INT)\n@@ -2377,7 +2377,7 @@\n         (ashift:DI (sign_extend:DI (match_operand:HI 2 \"general_operand\" \"rm,rm,rm,rm\"))\n             (const_int 32))))\n    (clobber (match_scratch:SI 3 \"=&d,X,a,?d\"))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2501,35 +2501,35 @@\n \t(minus:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t  (sign_extend:SI\n \t\t   (match_operand:HI 2 \"nonimmediate_src_operand\" \"rmS\"))))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"sub%.w %2,%0\")\n \n (define_insn \"subhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,r\")\n \t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0\")\n \t\t  (match_operand:HI 2 \"general_src_operand\" \"dn,rmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"sub%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(minus:HI (match_dup 0)\n \t\t  (match_operand:HI 1 \"general_src_operand\" \"dn,rmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"sub%.w %1,%0\")\n \n (define_insn \"subqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(minus:QI (match_operand:QI 1 \"general_operand\" \"0,0\")\n \t\t  (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"sub%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(minus:QI (match_dup 0)\n \t\t  (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"sub%.b %1,%0\")\n \n (define_expand \"subdf3\"\n@@ -2663,7 +2663,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"\")\n \t\t (match_operand:SI 2 \"general_operand\" \"\")))]\n-  \"TARGET_68020 || TARGET_5200\"\n+  \"TARGET_68020 || TARGET_COLDFIRE\"\n   \"\")\n \n (define_insn \"\"\n@@ -2678,7 +2678,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(mult:SI (match_operand:SI 1 \"general_operand\" \"%0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"d<Q>\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"muls%.l %2,%0\")\n \n (define_insn \"umulhisi3\"\n@@ -2724,7 +2724,7 @@\n \t  (truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t     (zero_extend:DI (match_dup 2)))\n \t\t\t\t    (const_int 32))))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"\")\n \n (define_insn \"\"\n@@ -2735,7 +2735,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t   (zero_extend:DI (match_dup 2)))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %2,%3:%0\")\n \n ; Match immediate case.  For 2.4 only match things < 2^31.\n@@ -2750,7 +2750,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (zero_extend:DI (match_dup 1))\n \t\t\t\t\t   (match_dup 2))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\n    && (unsigned) INTVAL (operands[2]) <= 0x7fffffff\"\n   \"mulu%.l %2,%3:%0\")\n \n@@ -2763,7 +2763,7 @@\n \t  (truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t     (sign_extend:DI (match_dup 2)))\n \t\t\t\t    (const_int 32))))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"\")\n \n (define_insn \"\"\n@@ -2774,7 +2774,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t   (sign_extend:DI (match_dup 2)))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %2,%3:%0\")\n \n (define_insn \"\"\n@@ -2785,7 +2785,7 @@\n \t(truncate:SI (lshiftrt:DI (mult:DI (sign_extend:DI (match_dup 1))\n \t\t\t\t\t   (match_dup 2))\n \t\t\t\t  (const_int 32))))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %2,%3:%0\")\n \n (define_expand \"umulsi3_highpart\"\n@@ -2797,7 +2797,7 @@\n \t\t     (zero_extend:DI (match_operand:SI 2 \"general_operand\" \"\")))\n \t    (const_int 32))))\n      (clobber (match_dup 3))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"\n {\n   operands[3] = gen_reg_rtx (SImode);\n@@ -2822,7 +2822,7 @@\n \t\t   (zero_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"dm\")))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %3,%0:%1\")\n \n (define_insn \"const_umulsi3_highpart\"\n@@ -2833,7 +2833,7 @@\n \t\t   (match_operand:DI 3 \"const_uint32_operand\" \"n\"))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"mulu%.l %3,%0:%1\")\n \n (define_expand \"smulsi3_highpart\"\n@@ -2845,7 +2845,7 @@\n \t\t     (sign_extend:DI (match_operand:SI 2 \"general_operand\" \"\")))\n \t    (const_int 32))))\n      (clobber (match_dup 3))])]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"\n {\n   operands[3] = gen_reg_rtx (SImode);\n@@ -2866,7 +2866,7 @@\n \t\t   (sign_extend:DI (match_operand:SI 3 \"nonimmediate_operand\" \"dm\")))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %3,%0:%1\")\n \n (define_insn \"const_smulsi3_highpart\"\n@@ -2877,7 +2877,7 @@\n \t\t   (match_operand:DI 3 \"const_sint32_operand\" \"n\"))\n \t  (const_int 32))))\n    (clobber (match_operand:SI 1 \"register_operand\" \"=d\"))]\n-  \"TARGET_68020 && !TARGET_68060 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_68060 && !TARGET_COLDFIRE\"\n   \"muls%.l %3,%0:%1\")\n \n (define_expand \"muldf3\"\n@@ -3089,13 +3089,40 @@\n \f\n ;; Remainder instructions.\n \n-(define_insn \"divmodsi4\"\n+(define_expand \"divmodsi4\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+          (div:SI (match_operand:SI 1 \"general_operand\" \"\")\n+                  (match_operand:SI 2 \"general_src_operand\" \"\")))\n+     (set (match_operand:SI 3 \"nonimmediate_operand\" \"\")\n+          (mod:SI (match_dup 1) (match_dup 2)))])]\n+  \"TARGET_68020 || TARGET_CF_HWDIV\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n+\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:SI 2 \"general_src_operand\" \"d<Q>U\")))\n+   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=&d\")\n+\t(mod:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_CF_HWDIV\"\n+  \"*\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \\\"divs%.l %2,%0\\\";\n+  else if (find_reg_note (insn, REG_UNUSED, operands[0]))\n+    return \\\"rems%.l %2,%3:%0\\\";\n+  else\n+    return \\\"rems%.l %2,%3:%0\\;divs%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t(match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))\n    (set (match_operand:SI 3 \"nonimmediate_operand\" \"=d\")\n \t(mod:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_68020 && !TARGET_5200\"\n+  \"TARGET_68020\"\n   \"*\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n@@ -3104,13 +3131,40 @@\n     return \\\"divsl%.l %2,%3:%0\\\";\n }\")\n \n-(define_insn \"udivmodsi4\"\n+(define_expand \"udivmodsi4\"\n+  [(parallel\n+    [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n+          (udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+                   (match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))\n+     (set (match_operand:SI 3 \"nonimmediate_operand\" \"=d\")\n+          (umod:SI (match_dup 1) (match_dup 2)))])]\n+  \"TARGET_68020 || TARGET_CF_HWDIV\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n+\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:SI 2 \"general_src_operand\" \"d<Q>U\")))\n+   (set (match_operand:SI 3 \"nonimmediate_operand\" \"=&d\")\n+\t(umod:SI (match_dup 1) (match_dup 2)))]\n+  \"TARGET_CF_HWDIV\"\n+  \"*\n+{\n+  if (find_reg_note (insn, REG_UNUSED, operands[3]))\n+    return \\\"divu%.l %2,%0\\\";\n+  else if (find_reg_note (insn, REG_UNUSED, operands[0]))\n+    return \\\"remu%.l %2,%3:%0\\\";\n+  else\n+    return \\\"remu%.l %2,%3:%0\\;divu%.l %2,%0\\\";\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n \t\t (match_operand:SI 2 \"general_src_operand\" \"dmSTK\")))\n    (set (match_operand:SI 3 \"nonimmediate_operand\" \"=d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_68020 && !TARGET_5200\"\n+  \"TARGET_68020 && !TARGET_COLDFIRE\"\n   \"*\n {\n   if (find_reg_note (insn, REG_UNUSED, operands[3]))\n@@ -3125,7 +3179,7 @@\n \t\t(match_operand:HI 2 \"general_src_operand\" \"dmSKT\")))\n    (set (match_operand:HI 3 \"nonimmediate_operand\" \"=d\")\n \t(mod:HI (match_dup 1) (match_dup 2)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE || TARGET_CF_HWDIV\"\n   \"*\n {\n #ifdef MOTOROLA\n@@ -3148,7 +3202,7 @@\n \t\t (match_operand:HI 2 \"general_src_operand\" \"dmSKT\")))\n    (set (match_operand:HI 3 \"nonimmediate_operand\" \"=d\")\n \t(umod:HI (match_dup 1) (match_dup 2)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE || TARGET_CF_HWDIV\"\n   \"*\n {\n #ifdef MOTOROLA\n@@ -3172,7 +3226,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o,d\")\n \t(and:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -3249,7 +3303,7 @@\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"general_src_operand\" \"dKT,dmSM\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   return output_andsi3 (operands);\n@@ -3259,49 +3313,49 @@\n   [(set (match_operand:SI 0 \"not_sp_operand\" \"=m,d\")\n \t(and:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"general_src_operand\" \"d,dmsK\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"and%.l %2,%0\")\n \n (define_insn \"andhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(and:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(and:HI (match_dup 0)\n \t\t(match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.w %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(and:HI (match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.w %1,%0\")\n \n (define_insn \"andqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(and:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(and:QI (match_dup 0)\n \t\t(match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.b %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(and:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"and%.b %1,%0\")\n \f\n ;; inclusive-or instructions\n@@ -3310,7 +3364,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o,d\")\n     (ior:DI (zero_extend:DI (match_operand 1 \"general_operand\" \"dn,dmn\"))\n         (match_operand:DI 2 \"general_operand\" \"0,0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   int byte_mode;\n@@ -3337,7 +3391,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=o,d\")\n \t(ior:DI (match_operand:DI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:DI 2 \"general_operand\" \"dn,don\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -3414,7 +3468,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n                 (match_operand:SI 2 \"general_src_operand\" \"dKT,dmSMT\")))]\n-  \"! TARGET_5200\"\n+  \"! TARGET_COLDFIRE\"\n   \"*\n {\n   return output_iorsi3 (operands);\n@@ -3424,49 +3478,49 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(ior:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"general_src_operand\" \"d,dmsK\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"or%.l %2,%0\")\n \n (define_insn \"iorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:HI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(ior:HI (match_dup 0)\n \t\t(match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.w %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(ior:HI (match_operand:HI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.w %1,%0\")\n \n (define_insn \"iorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=m,d\")\n \t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n                 (match_operand:QI 2 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n \t(ior:QI (match_dup 0)\n                 (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.b %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+m,d\"))\n         (ior:QI (match_operand:QI 1 \"general_src_operand\" \"dn,dmSn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"or%.b %1,%0\")\n \n ;; On all 68k models, this makes faster code in a special case.\n@@ -3493,7 +3547,7 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=o,d\")\n     (ior:SI (zero_extend:SI (match_operand 1 \"general_operand\" \"dn,dmn\"))\n         (match_operand:SI 2 \"general_operand\" \"0,0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   int byte_mode;\n@@ -3516,7 +3570,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=od\")\n \t(xor:DI (match_operand:DI 1 \"general_operand\" \"%0\")\n \t\t(match_operand:DI 2 \"general_operand\" \"dn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -3597,7 +3651,7 @@\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n                 (match_operand:SI 2 \"general_operand\" \"di,dKT\")))]\n \n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   return output_xorsi3 (operands);\n@@ -3607,49 +3661,49 @@\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm,d\")\n \t(xor:SI (match_operand:SI 1 \"general_operand\" \"%0,0\")\n \t\t(match_operand:SI 2 \"general_operand\" \"d,Ks\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"eor%.l %2,%0\")\n \n (define_insn \"xorhi3\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"dn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(xor:HI (match_dup 0)\n \t\t(match_operand:HI 1 \"general_operand\" \"dn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.w %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(xor:HI (match_operand:HI 1 \"general_operand\" \"dn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.w %1,%0\")\n \n (define_insn \"xorqi3\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n \t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n \t\t(match_operand:QI 2 \"general_operand\" \"dn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(xor:QI (match_dup 0)\n \t\t(match_operand:QI 1 \"general_operand\" \"dn\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.b %1,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(xor:QI (match_operand:QI 1 \"general_operand\" \"dn\")\n \t\t(match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"eor%.b %1,%0\")\n \f\n ;; negation instructions\n@@ -3660,7 +3714,7 @@\n   \"\"\n   \"\n {\n-  if (TARGET_5200)\n+  if (TARGET_COLDFIRE)\n     emit_insn (gen_negdi2_5200 (operands[0], operands[1]));\n   else\n     emit_insn (gen_negdi2_internal (operands[0], operands[1]));\n@@ -3670,7 +3724,7 @@\n (define_insn \"negdi2_internal\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=<,do,!*a\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0,0,0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (which_alternative == 0)\n@@ -3688,7 +3742,7 @@\n (define_insn \"negdi2_5200\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   operands[1] = gen_rtx_REG (SImode, REGNO (operands[0]) + 1);\n@@ -3701,7 +3755,7 @@\n   \"\"\n   \"\n {\n-  if (TARGET_5200)\n+  if (TARGET_COLDFIRE)\n     emit_insn (gen_negsi2_5200 (operands[0], operands[1]));\n   else\n     emit_insn (gen_negsi2_internal (operands[0], operands[1]));\n@@ -3711,37 +3765,37 @@\n (define_insn \"negsi2_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"neg%.l %0\")\n \n (define_insn \"negsi2_5200\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(neg:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"neg%.l %0\")\n \n (define_insn \"neghi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n \t(neg:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"neg%.w %0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(neg:HI (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"neg%.w %0\")\n \n (define_insn \"negqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n \t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"neg%.b %0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(neg:QI (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"neg%.b %0\")\n \n ;; If using software floating point, just flip the sign bit.\n@@ -3957,7 +4011,7 @@\n (define_insn \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=dm\")\n \t(not:DI (match_operand:DI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -3977,7 +4031,7 @@\n   \"\"\n   \"\n {\n-  if (TARGET_5200)\n+  if (TARGET_COLDFIRE)\n     emit_insn (gen_one_cmplsi2_5200 (operands[0], operands[1]));\n   else\n     emit_insn (gen_one_cmplsi2_internal (operands[0], operands[1]));\n@@ -3987,37 +4041,37 @@\n (define_insn \"one_cmplsi2_internal\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=dm\")\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"not%.l %0\")\n \n (define_insn \"one_cmplsi2_5200\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d\")\n \t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"not%.l %0\")\n \n (define_insn \"one_cmplhi2\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=dm\")\n \t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"not%.w %0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(not:HI (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"not%.w %0\")\n \n (define_insn \"one_cmplqi2\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n \t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"not%.b %0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"nonimmediate_operand\" \"+dm\"))\n \t(not:QI (match_dup 0)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"not%.b %0\")\n \f\n ;; arithmetic shift instructions\n@@ -4101,7 +4155,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n \t(ashift:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"(!TARGET_5200\n+  \"(!TARGET_COLDFIRE\n     && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n \t|| INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n \t|| (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)))\"\n@@ -4133,7 +4187,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(ashift:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"\n {\n   /* ???  This is a named pattern like this is not allowed to FAIL based\n@@ -4167,7 +4221,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_5200\n+  \"(! TARGET_68020 && !TARGET_COLDFIRE\n     && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n@@ -4196,28 +4250,28 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsl%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(ashift:HI (match_dup 0)\n \t\t   (match_operand:HI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsl%.w %1,%0\")\n \n (define_insn \"ashlqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsl%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(ashift:QI (match_dup 0)\n \t\t   (match_operand:QI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsl%.b %1,%0\")\n \n ;; On most 68k models, this makes faster code in a special case.\n@@ -4235,7 +4289,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_5200\n+  \"(! TARGET_68020 && !TARGET_COLDFIRE\n     && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n@@ -4304,7 +4358,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"(!TARGET_5200 \n+  \"(!TARGET_COLDFIRE \n     && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n \t|| INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n \t|| INTVAL (operands[2]) == 31\n@@ -4344,7 +4398,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(ashiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"\n {\n   /* ???  This is a named pattern like this is not allowed to FAIL based\n@@ -4379,28 +4433,28 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"asr%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(ashiftrt:HI (match_dup 0)\n \t\t     (match_operand:HI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"asr%.w %1,%0\")\n \n (define_insn \"ashrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"asr%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(ashiftrt:QI (match_dup 0)\n \t\t     (match_operand:QI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"asr%.b %1,%0\")\n \f\n ;; logical shift instructions\n@@ -4477,7 +4531,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=d\")\n \t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"0\")\n \t\t     (match_operand 2 \"const_int_operand\" \"n\")))]\n-  \"(!TARGET_5200\n+  \"(!TARGET_COLDFIRE\n     && ((INTVAL (operands[2]) >= 1 && INTVAL (operands[2]) <= 3)\n \t || INTVAL (operands[2]) == 8 || INTVAL (operands[2]) == 16\n \t || (INTVAL (operands[2]) > 32 && INTVAL (operands[2]) <= 63)))\"\n@@ -4512,7 +4566,7 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(lshiftrt:DI (match_operand:DI 1 \"general_operand\" \"\")\n \t\t     (match_operand 2 \"const_int_operand\" \"\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"\n {\n   /* ???  This is a named pattern like this is not allowed to FAIL based\n@@ -4555,7 +4609,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"const_int_operand\" \"n\")))]\n-  \"(! TARGET_68020 && !TARGET_5200\n+  \"(! TARGET_68020 && !TARGET_COLDFIRE\n     && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 24)\"\n   \"*\n {\n@@ -4575,28 +4629,28 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsr%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(lshiftrt:HI (match_dup 0)\n \t\t     (match_operand:HI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsr%.w %1,%0\")\n \n (define_insn \"lshrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsr%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(lshiftrt:QI (match_dup 0)\n \t\t     (match_operand:QI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"lsr%.b %1,%0\")\n \f\n ;; rotate instructions\n@@ -4605,7 +4659,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:SI 2 \"general_operand\" \"dINO\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) == 16)\n@@ -4623,7 +4677,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(rotate:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:HI 2 \"general_operand\" \"dIP\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 8)\n@@ -4639,7 +4693,7 @@\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(rotate:HI (match_dup 0)\n \t\t   (match_operand:HI 1 \"general_operand\" \"dIP\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 8)\n@@ -4655,7 +4709,7 @@\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(rotate:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t   (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 4)\n@@ -4671,7 +4725,7 @@\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(rotate:QI (match_dup 0)\n \t\t   (match_operand:QI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   if (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) >= 4)\n@@ -4687,35 +4741,35 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n \t(rotatert:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:SI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"ror%.l %2,%0\")\n \n (define_insn \"rotrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n \t(rotatert:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:HI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"ror%.w %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:HI 0 \"register_operand\" \"+d\"))\n \t(rotatert:HI (match_dup 0)\n \t\t     (match_operand:HI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"ror%.w %1,%0\")\n \n (define_insn \"rotrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=d\")\n \t(rotatert:QI (match_operand:QI 1 \"register_operand\" \"0\")\n \t\t     (match_operand:QI 2 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"ror%.b %2,%0\")\n \n (define_insn \"\"\n   [(set (strict_low_part (match_operand:QI 0 \"register_operand\" \"+d\"))\n \t(rotatert:QI (match_dup 0)\n \t\t     (match_operand:QI 1 \"general_operand\" \"dI\")))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"ror%.b %1,%0\")\n \f\n \n@@ -5179,7 +5233,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=dm\")\n     (match_operator 1 \"valid_dbcc_comparison_p\"\n       [(match_operand:DI 2 \"general_operand\" \"ro\") (const_int 0)]))]\n-  \"! TARGET_5200\"\n+  \"! TARGET_COLDFIRE\"\n   \"*\n {\n   return output_scc_di (operands[1], operands[2], const0_rtx, operands[0]);\n@@ -5189,7 +5243,7 @@\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=d\")\n     (match_operator 1 \"valid_dbcc_comparison_p\"\n       [(match_operand:DI 2 \"general_operand\" \"ro\") (const_int 0)]))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   return output_scc_di (operands[1], operands[2], const0_rtx, operands[0]);\n@@ -5200,7 +5254,7 @@\n     (match_operator 1 \"valid_dbcc_comparison_p\"\n       [(match_operand:DI 2 \"general_operand\" \"ro,r\")\n        (match_operand:DI 3 \"general_operand\" \"r,ro\")]))]\n-  \"! TARGET_5200\"\n+  \"! TARGET_COLDFIRE\"\n   \"*\n {\n   return output_scc_di (operands[1], operands[2], operands[3], operands[0]);\n@@ -5211,7 +5265,7 @@\n     (match_operator 1 \"valid_dbcc_comparison_p\"\n       [(match_operand:DI 2 \"general_operand\" \"ro,r\")\n        (match_operand:DI 3 \"general_operand\" \"r,ro\")]))]\n-  \"TARGET_5200\"\n+  \"TARGET_COLDFIRE\"\n   \"*\n {\n   return output_scc_di (operands[1], operands[2], operands[3], operands[0]);\n@@ -5658,7 +5712,7 @@\n #endif\n     }\n   operands[4] = gen_label_rtx();\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     {\n #ifdef MOTOROLA\n       output_asm_insn (\\\"tst%.l %0\\;jbne %l4\\;tst%.l %3\\;jbeq %l1\\\", operands);\n@@ -5737,7 +5791,7 @@\n       return \\\"move%.l %0,%2\\;or%.l %3,%2\\;jne %l1\\\";\n #endif\n     }\n-  if (TARGET_68020 || TARGET_5200)\n+  if (TARGET_68020 || TARGET_COLDFIRE)\n     {\n #ifdef MOTOROLA\n       return \\\"tst%.l %0\\;jbne %l1\\;tst%.l %3\\;jbne %l1\\\";\n@@ -5792,7 +5846,7 @@\n \t}\n     }\n   CC_STATUS_INIT;\n-  if (TARGET_68020 || TARGET_5200 || ! ADDRESS_REG_P (operands[0]))\n+  if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (operands[0]))\n     output_asm_insn(\\\"tst%.l %0\\\", operands);\n   else\n     {\n@@ -5844,7 +5898,7 @@\n \t}\n     }\n   CC_STATUS_INIT;\n-  if (TARGET_68020 || TARGET_5200 || ! ADDRESS_REG_P (operands[0]))\n+  if (TARGET_68020 || TARGET_COLDFIRE || ! ADDRESS_REG_P (operands[0]))\n     output_asm_insn(\\\"tst%.l %0\\\", operands);\n   else\n     {\n@@ -6463,7 +6517,7 @@\n #else\n #ifdef SGS\n #ifdef ASM_OUTPUT_CASE_LABEL\n-  if (TARGET_5200) \n+  if (TARGET_COLDFIRE) \n     {\n       if (ADDRESS_REG_P (operands[0]))\n \treturn \\\"jmp 6(%%pc,%0.l)\\\";\n@@ -6473,7 +6527,7 @@\n   else\n     return \\\"jmp 6(%%pc,%0.w)\\\";\n #else\n-  if (TARGET_5200)\n+  if (TARGET_COLDFIRE)\n     {\n       if (ADDRESS_REG_P (operands[0]))\n \treturn \\\"jmp 2(%%pc,%0.l)\\\";\n@@ -6484,7 +6538,7 @@\n     return \\\"jmp 2(%%pc,%0.w)\\\";\n #endif\n #else /* not SGS */\n-  if (TARGET_5200)\n+  if (TARGET_COLDFIRE)\n     {\n       if (ADDRESS_REG_P (operands[0]))\n \t{\n@@ -6526,7 +6580,7 @@\n    (set (match_dup 0)\n \t(plus:HI (match_dup 0)\n \t\t (const_int -1)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -6561,7 +6615,7 @@\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))]\n-  \"!TARGET_5200\"\n+  \"!TARGET_COLDFIRE\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -6597,7 +6651,7 @@\n    (set (match_dup 0)\n \t(plus:HI (match_dup 0)\n \t\t (const_int -1)))]\n-  \"!TARGET_5200 && find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"!TARGET_COLDFIRE && find_reg_note (insn, REG_NONNEG, 0)\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -6645,7 +6699,7 @@\n    (set (match_dup 0)\n \t(plus:SI (match_dup 0)\n \t\t (const_int -1)))]\n-  \"!TARGET_5200 && find_reg_note (insn, REG_NONNEG, 0)\"\n+  \"!TARGET_COLDFIRE && find_reg_note (insn, REG_NONNEG, 0)\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -6973,7 +7027,7 @@\n       xoperands[1] = GEN_INT (INTVAL (operands[0]) - 4);\n       if (INTVAL (xoperands[1]) <= 8)\n \t{\n-\t  if (!TARGET_5200)\n+\t  if (!TARGET_COLDFIRE)\n \t    output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n \t  else\n \t    output_asm_insn (\\\"addq%.l %1,%0\\\", xoperands);\n@@ -7020,7 +7074,7 @@\n       xoperands[1] = GEN_INT (INTVAL (operands[0]) - 4);\n       if (INTVAL (xoperands[1]) <= 8)\n \t{\n-\t  if (!TARGET_5200)\n+\t  if (!TARGET_COLDFIRE)\n \t    output_asm_insn (\\\"addq%.w %1,%0\\\", xoperands);\n \t  else\n \t    output_asm_insn (\\\"addq%.l %1,%0\\\", xoperands);\n@@ -7069,7 +7123,7 @@\n   xoperands[2]\n     = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, 3));\n   xoperands[3] = stack_pointer_rtx;\n-  if (!TARGET_5200)\n+  if (!TARGET_COLDFIRE)\n     output_asm_insn (\\\"subq%.w %#4,%3\\;move%.b %1,%2\\\", xoperands);\n   else\n     output_asm_insn (\\\"subq%.l %#4,%3\\;move%.b %1,%2\\\", xoperands);\n@@ -7091,7 +7145,7 @@\n \t      || GET_CODE (operands[0]) == MEM)\n \t  /* clr insns on 68000 read before writing.\n \t     This isn't so on the 68010, but we have no TARGET_68010.  */\n-\t  && ((TARGET_68020 || TARGET_5200)\n+\t  && ((TARGET_68020 || TARGET_COLDFIRE)\n \t      || !(GET_CODE (operands[0]) == MEM\n \t\t   && MEM_VOLATILE_P (operands[0]))))\n \treturn \\\"clr%.w %0\\\";\n@@ -7131,7 +7185,7 @@\n      (set (match_dup 0)\n \t  (plus:HI (match_dup 0)\n \t\t   (const_int -1)))])]\n-  \"!TARGET_5200 && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n+  \"!TARGET_COLDFIRE && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -7154,7 +7208,7 @@\n      (set (match_dup 0)\n \t  (plus:SI (match_dup 0)\n \t\t   (const_int -1)))])]\n-  \"!TARGET_5200 && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n+  \"!TARGET_COLDFIRE && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -7178,7 +7232,7 @@\n      (set (match_dup 0)\n \t  (plus:HI (match_dup 0)\n \t\t   (const_int -1)))])]\n-  \"!TARGET_5200 && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n+  \"!TARGET_COLDFIRE && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -7202,7 +7256,7 @@\n      (set (match_dup 0)\n \t  (plus:SI (match_dup 0)\n \t\t   (const_int -1)))])]\n-  \"!TARGET_5200 && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n+  \"!TARGET_COLDFIRE && DATA_REG_P (operands[0]) && ! flags_in_68881 ()\"\n   \"*\n {\n   CC_STATUS_INIT;"}, {"sha": "bb9edccf3caa27352eac93c5f64c340643ac404e", "filename": "gcc/config/m68k/m68kelf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fm68kelf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68kelf.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -75,7 +75,7 @@ Boston, MA 02111-1307, USA.  */\n \n #define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n+    if (TARGET_COLDFIRE)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tif (ADDRESS_REG_P (operands[0]))\t\t\\\n \t  return \"jmp %%pc@(2,%0:l)\";\t\t\t\\"}, {"sha": "cae6cb1d8c9cb747ee1362a35bab4e4170251c3b", "filename": "gcc/config/m68k/netbsd-elf.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fnetbsd-elf.h?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -204,7 +204,7 @@ while (0)\n #undef ASM_OUTPUT_CASE_LABEL\n #define ASM_RETURN_CASE_JUMP\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\\\n-    if (TARGET_5200)\t\t\t\t\t\\\n+    if (TARGET_COLDFIRE)\t\t\t\t\\\n       {\t\t\t\t\t\t\t\\\n \tif (ADDRESS_REG_P (operands[0]))\t\t\\\n \t  return \"jmp %%pc@(2,%0:l)\";\t\t\t\\"}, {"sha": "686e2d49054f2aee2349ae5dc7446fdfb9127ada", "filename": "gcc/config/m68k/t-m68kelf", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9425fb0472efcae08cf17d80c56c55059be3c6a3/gcc%2Fconfig%2Fm68k%2Ft-m68kelf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Ft-m68kelf?ref=9425fb0472efcae08cf17d80c56c55059be3c6a3", "patch": "@@ -12,11 +12,14 @@ xfgnulib.c: $(srcdir)/config/m68k/fpgnulib.c\n \techo '#define EXTFLOAT' > xfgnulib.c\n \tcat $(srcdir)/config/m68k/fpgnulib.c >> xfgnulib.c\n \n-MULTILIB_OPTIONS = m68000/m68020/m5200/mcpu32/m68040/m68060 m68881/msoft-float\n+MULTILIB_OPTIONS = m68000/m68020/m5200/m5206e/m528x/m5307/m5407/mcpu32/m68040/m68060 m68881/msoft-float\n MULTILIB_DIRNAMES =\n-MULTILIB_MATCHES = m68000=mc68000 m68000=m68302 mcpu32=m68332 m68020=mc68020\n-MULTILIB_EXCEPTIONS = m68000/msoft-float m5200/m68881 m5200/msoft-float mcpu32/m68881 mcpu32/msoft-float m68040/m68881 m68040/msoft-float m68060/m68881 m68060/msoft-float\n-\n+MULTILIB_MATCHES = m68000=mc68000 m68000=m68302 mcpu32=m68332 m68020=mc68020 m5206e=m5272\n+MULTILIB_EXCEPTIONS = m68000/msoft-float m5200/m68881 m5200/msoft-float \\\n+\t\t    m5206e/m68881 m5206e/msoft-float m528x/m68881 m528x/msoft-float \\\n+\t\t    m5307/m68881 m5307/msoft-float m5407/m68881 m5407/msoft-float \\\n+\t\t    mcpu32/m68881 mcpu32/msoft-float m68040/m68881 m68040/msoft-float \\\n+\t\t    m68060/m68881 m68060/msoft-float \n LIBGCC = stmp-multilib\n INSTALL_LIBGCC = install-multilib\n "}]}