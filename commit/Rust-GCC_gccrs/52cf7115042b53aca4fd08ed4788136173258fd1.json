{"sha": "52cf7115042b53aca4fd08ed4788136173258fd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJjZjcxMTUwNDJiNTNhY2E0ZmQwOGVkNDc4ODEzNjE3MzI1OGZkMQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1998-08-18T17:49:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-08-18T17:49:28Z"}, "message": "expr.c (emit_block_move): Do not call memcpy as a libcall instead build up a CALL_EXPR and call it like...\n\n        * expr.c (emit_block_move): Do not call memcpy as a libcall\n        instead build up a CALL_EXPR and call it like any other\n        function.\n        (clear_storage): Similarly for memset.\n\nFrom-SVN: r21831", "tree": {"sha": "204fa56dd26f617dfbc77b6524547796e4392cb0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/204fa56dd26f617dfbc77b6524547796e4392cb0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52cf7115042b53aca4fd08ed4788136173258fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52cf7115042b53aca4fd08ed4788136173258fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52cf7115042b53aca4fd08ed4788136173258fd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52cf7115042b53aca4fd08ed4788136173258fd1/comments", "author": null, "committer": null, "parents": [{"sha": "e27a51061835b998d7baa5e7fae34172dfae3f64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e27a51061835b998d7baa5e7fae34172dfae3f64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e27a51061835b998d7baa5e7fae34172dfae3f64"}], "stats": {"total": 138, "additions": 121, "deletions": 17}, "files": [{"sha": "97dea44cce24cb42f282d1fc595a2c1c2936395c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52cf7115042b53aca4fd08ed4788136173258fd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52cf7115042b53aca4fd08ed4788136173258fd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52cf7115042b53aca4fd08ed4788136173258fd1", "patch": "@@ -5,6 +5,11 @@ Tue Aug 18 12:40:27 1998  Richard Henderson  <rth@cygnus.com>\n \n Tue Aug 18 10:33:30 1998  Jeffrey A Law  (law@cygnus.com)\n \n+\t* expr.c (emit_block_move): Do not call memcpy as a libcall\n+\tinstead build up a CALL_EXPR and call it like any other\n+\tfunction.\n+\t(clear_storage): Similarly for memset.\n+\n \t* regmove.c (fixup_match_2): Do not call reg_overlap_mentioned_p\n \ton notes.\n "}, {"sha": "e14517bf58c7beaebca120aee25309fcab8d0be3", "filename": "gcc/expr.c", "status": "modified", "additions": 116, "deletions": 17, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52cf7115042b53aca4fd08ed4788136173258fd1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52cf7115042b53aca4fd08ed4788136173258fd1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=52cf7115042b53aca4fd08ed4788136173258fd1", "patch": "@@ -1616,6 +1616,10 @@ emit_block_move (x, y, size, align)\n      int align;\n {\n   rtx retval = 0;\n+#ifdef TARGET_MEM_FUNCTIONS\n+  static tree fn;\n+  tree call_expr, arg_list;\n+#endif\n \n   if (GET_MODE (x) != BLKmode)\n     abort ();\n@@ -1689,13 +1693,60 @@ emit_block_move (x, y, size, align)\n \t}\n \n #ifdef TARGET_MEM_FUNCTIONS\n-      retval\n-\t= emit_library_call_value (memcpy_libfunc, NULL_RTX, 0,\n-\t\t\t\t   ptr_mode, 3, XEXP (x, 0), Pmode,\n-\t\t\t\t   XEXP (y, 0), Pmode,\n-\t\t\t\t   convert_to_mode (TYPE_MODE (sizetype), size,\n-\t\t\t\t\t\t    TREE_UNSIGNED (sizetype)),\n-\t\t\t\t   TYPE_MODE (sizetype));\n+      /* It is incorrect to use the libcall calling conventions to call\n+\t memcpy in this context.\n+\n+\t This could be a user call to memcpy and the user may wish to\n+\t examine the return value from memcpy.\n+\n+\t For targets where libcalls and normal calls have different conventions\n+\t for returning pointers, we could end up generating incorrect code. \n+\n+\t So instead of using a libcall sequence we build up a suitable\n+\t CALL_EXPR and expand the call in the normal fashion.  */\n+      if (fn == NULL_TREE)\n+\t{\n+\t  tree fntype;\n+\n+\t  /* This was copied from except.c, I don't know if all this is\n+\t     necessary in this context or not.  */\n+\t  fn = get_identifier (\"memcpy\");\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  fntype = build_pointer_type (void_type_node);\n+\t  fntype = build_function_type (fntype, NULL_TREE);\n+\t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  TREE_PUBLIC (fn) = 1;\n+\t  DECL_ARTIFICIAL (fn) = 1;\n+\t  make_decl_rtl (fn, NULL_PTR, 1);\n+\t  assemble_external (fn);\n+\t  pop_obstacks ();\n+\t}\n+\n+      /* We need to make an argument list for the function call. \n+\n+\t memcpy has three arguments, the first two are void * addresses and\n+\t the last is a size_t byte count for the copy.  */\n+      arg_list\n+\t= build_tree_list (NULL_TREE,\n+\t\t\t    make_tree (build_pointer_type (void_type_node),\n+\t\t\t\t       XEXP (x, 0)));\n+      TREE_CHAIN (arg_list)\n+\t= build_tree_list (NULL_TREE,\n+\t\t\t   make_tree (build_pointer_type (void_type_node),\n+\t\t\t\t      XEXP (y, 0)));\n+      TREE_CHAIN (TREE_CHAIN (arg_list))\n+\t = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n+      TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n+\n+      /* Now we have to build up the CALL_EXPR itself.  */\n+      call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t call_expr, arg_list, NULL_TREE);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+      retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n       emit_library_call (bcopy_libfunc, 0,\n \t\t\t VOIDmode, 3, XEXP (y, 0), Pmode,\n@@ -2211,6 +2262,10 @@ clear_storage (object, size, align)\n      rtx size;\n      int align;\n {\n+#ifdef TARGET_MEM_FUNCTIONS\n+  static tree fn;\n+  tree call_expr, arg_list;\n+#endif\n   rtx retval = 0;\n \n   if (GET_MODE (object) == BLKmode)\n@@ -2275,16 +2330,60 @@ clear_storage (object, size, align)\n \n \n #ifdef TARGET_MEM_FUNCTIONS\n-\t  retval\n-\t    = emit_library_call_value (memset_libfunc, NULL_RTX, 0,\n-\t\t\t\t       ptr_mode, 3,\n-\t\t\t\t       XEXP (object, 0), Pmode,\n-\t\t\t\t       const0_rtx,\n-\t\t\t\t       TYPE_MODE (integer_type_node),\n-\t\t\t\t       convert_to_mode\n-\t\t\t\t       (TYPE_MODE (sizetype), size,\n-\t\t\t\t\tTREE_UNSIGNED (sizetype)),\n-\t\t\t\t       TYPE_MODE (sizetype));\n+      /* It is incorrect to use the libcall calling conventions to call\n+\t memset in this context.\n+\n+\t This could be a user call to memset and the user may wish to\n+\t examine the return value from memset.\n+\n+\t For targets where libcalls and normal calls have different conventions\n+\t for returning pointers, we could end up generating incorrect code. \n+\n+\t So instead of using a libcall sequence we build up a suitable\n+\t CALL_EXPR and expand the call in the normal fashion.  */\n+      if (fn == NULL_TREE)\n+\t{\n+\t  tree fntype;\n+\n+\t  /* This was copied from except.c, I don't know if all this is\n+\t     necessary in this context or not.  */\n+\t  fn = get_identifier (\"memset\");\n+\t  push_obstacks_nochange ();\n+\t  end_temporary_allocation ();\n+\t  fntype = build_pointer_type (void_type_node);\n+\t  fntype = build_function_type (fntype, NULL_TREE);\n+\t  fn = build_decl (FUNCTION_DECL, fn, fntype);\n+\t  DECL_EXTERNAL (fn) = 1;\n+\t  TREE_PUBLIC (fn) = 1;\n+\t  DECL_ARTIFICIAL (fn) = 1;\n+\t  make_decl_rtl (fn, NULL_PTR, 1);\n+\t  assemble_external (fn);\n+\t  pop_obstacks ();\n+\t}\n+\n+      /* We need to make an argument list for the function call. \n+\n+\t memset has three arguments, the first is a void * addresses, the\n+\t second a integer with the initialization value, the last is a size_t\n+\t byte count for the copy.  */\n+      arg_list\n+\t= build_tree_list (NULL_TREE,\n+\t\t\t    make_tree (build_pointer_type (void_type_node),\n+\t\t\t\t       XEXP (object, 0)));\n+      TREE_CHAIN (arg_list)\n+\t= build_tree_list (NULL_TREE,\n+\t\t\t   make_tree (integer_type_node, const0_rtx));\n+      TREE_CHAIN (TREE_CHAIN (arg_list))\n+\t = build_tree_list (NULL_TREE, make_tree (sizetype, size));\n+      TREE_CHAIN (TREE_CHAIN (TREE_CHAIN (arg_list))) = NULL_TREE;\n+\n+      /* Now we have to build up the CALL_EXPR itself.  */\n+      call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n+      call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n+\t\t\t call_expr, arg_list, NULL_TREE);\n+      TREE_SIDE_EFFECTS (call_expr) = 1;\n+\n+      retval = expand_expr (call_expr, NULL_RTX, VOIDmode, 0);\n #else\n \t  emit_library_call (bzero_libfunc, 0,\n \t\t\t     VOIDmode, 2,"}]}