{"sha": "339329463663199b22e18901d101b680979c980e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM5MzI5NDYzNjYzMTk5YjIyZTE4OTAxZDEwMWI2ODA5NzljOTgwZQ==", "commit": {"author": {"name": "Stuart Hastings", "email": "stuart@apple.com", "date": "2006-05-18T00:34:44Z"}, "committer": {"name": "Stuart Hastings", "email": "stuart@gcc.gnu.org", "date": "2006-05-18T00:34:44Z"}, "message": "i386.opt (-mstackrealign): New flag.\n\n        * gcc/config/i386/i386.opt (-mstackrealign): New flag.  *\n\tgcc/config/i386/i386.c (force_align_arg_pointer): New attribute.\n\t(ix86_handle_cconv_attribute): Emit error when\n\tforce_align_arg_pointer attribute collides with too many regparms.\n\t(ix86_function_regparm): Limit regparms when used with\n\tforce_align_arg_pointer attribute.  (ix86_internal_arg_pointer):\n\tSupport stack-realigning prologue in non-main functions.  Emit\n\twarning for nested functions under -mstackrealign, emit error for\n\tnested functions with force_align_arg_pointer attribute.\n\t* gcc/doc/extend.texi (force_align_arg_pointer): Document it.\n\t* gcc/doc/invoke.texi (-mstackrealign): Document it.\n\t* testsuite/gcc.target/i386/20060512-1.c: New.\n\t* testsuite/gcc.target/i386/20060512-2.c: New.\n\t* testsuite/gcc.target/i386/20060512-3.c: New.\n\t* testsuite/gcc.target/i386/20060512-4.c: New.\n\nFrom-SVN: r113880", "tree": {"sha": "76255841987be3306d958753a8feba9aea4e6b6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/76255841987be3306d958753a8feba9aea4e6b6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/339329463663199b22e18901d101b680979c980e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339329463663199b22e18901d101b680979c980e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/339329463663199b22e18901d101b680979c980e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/339329463663199b22e18901d101b680979c980e/comments", "author": null, "committer": null, "parents": [{"sha": "71abbf1620f10d59cd6afcbf56b47f2f488ff1bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71abbf1620f10d59cd6afcbf56b47f2f488ff1bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71abbf1620f10d59cd6afcbf56b47f2f488ff1bf"}], "stats": {"total": 190, "additions": 185, "deletions": 5}, "files": [{"sha": "4759c32b81c1df626b0f0113bcd64578cb54bff4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -1,3 +1,17 @@\n+2006-05-12  Stuart Hastings  <stuart@apple.com>\n+\n+        * gcc/config/i386/i386.opt (-mstackrealign): New flag.  *\n+\tgcc/config/i386/i386.c (force_align_arg_pointer): New attribute.\n+\t(ix86_handle_cconv_attribute): Emit error when\n+\tforce_align_arg_pointer attribute collides with too many regparms.\n+\t(ix86_function_regparm): Limit regparms when used with\n+\tforce_align_arg_pointer attribute.  (ix86_internal_arg_pointer):\n+\tSupport stack-realigning prologue in non-main functions.  Emit\n+\twarning for nested functions under -mstackrealign, emit error for\n+\tnested functions with force_align_arg_pointer attribute.\n+\t* gcc/doc/extend.texi (force_align_arg_pointer): Document it.\n+\t* gcc/doc/invoke.texi (-mstackrealign): Document it.\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n 2006-05-17  Kazu Hirata  <kazu@codesourcery.com>\n \n \tPR rtl-optimization/27477"}, {"sha": "cfdcb2fc9264b7e5f665b1dd4594b1e3944ba834", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -1049,6 +1049,10 @@ int x86_prefetch_sse;\n /* ix86_regparm_string as a number */\n static int ix86_regparm;\n \n+/* -mstackrealign option */\n+extern int ix86_force_align_arg_pointer;\n+static const char ix86_force_align_arg_pointer_string[] = \"force_align_arg_pointer\";\n+\n /* Preferred alignment for stack boundary in bits.  */\n unsigned int ix86_preferred_stack_boundary;\n \n@@ -2225,6 +2229,9 @@ const struct attribute_spec ix86_attribute_table[] =\n   /* Sseregparm attribute says we are using x86_64 calling conventions\n      for FP arguments.  */\n   { \"sseregparm\", 0, 0, false, true, true, ix86_handle_cconv_attribute },\n+  /* force_align_arg_pointer says this function realigns the stack at entry.  */\n+  { (const char *)&ix86_force_align_arg_pointer_string, 0, 0,\n+    false, true,  true, ix86_handle_cconv_attribute },\n #if TARGET_DLLIMPORT_DECL_ATTRIBUTES\n   { \"dllimport\", 0, 0, false, false, false, handle_dll_attribute },\n   { \"dllexport\", 0, 0, false, false, false, handle_dll_attribute },\n@@ -2367,6 +2374,15 @@ ix86_handle_cconv_attribute (tree *node, tree name,\n \t  *no_add_attrs = true;\n \t}\n \n+      if (!TARGET_64BIT\n+\t  && lookup_attribute (ix86_force_align_arg_pointer_string,\n+\t\t\t       TYPE_ATTRIBUTES (*node))\n+\t  && compare_tree_int (cst, REGPARM_MAX-1))\n+\t{\n+\t  error (\"%s functions limited to %d register parameters\",\n+\t\t ix86_force_align_arg_pointer_string, REGPARM_MAX-1);\n+\t}\n+\n       return NULL_TREE;\n     }\n \n@@ -2506,6 +2522,18 @@ ix86_function_regparm (tree type, tree decl)\n \t\t  && decl_function_context (decl)\n \t\t  && !DECL_NO_STATIC_CHAIN (decl))\n \t\tlocal_regparm = 2;\n+\t      /* If the function realigns its stackpointer, the\n+\t\t prologue will clobber %ecx.  If we've already\n+\t\t generated code for the callee, the callee\n+\t\t DECL_STRUCT_FUNCTION is gone, so we fall back to\n+\t\t scanning the attributes for the self-realigning\n+\t\t property.  */\n+\t      if ((DECL_STRUCT_FUNCTION (decl)\n+\t\t   && DECL_STRUCT_FUNCTION (decl)->machine->force_align_arg_pointer)\n+\t\t  || (!DECL_STRUCT_FUNCTION (decl)\n+\t\t      && lookup_attribute (ix86_force_align_arg_pointer_string,\n+\t\t\t\t\t   TYPE_ATTRIBUTES (TREE_TYPE (decl)))))\n+\t\tlocal_regparm = 2;\n \t      /* Each global register variable increases register preassure,\n \t\t so the more global reg vars there are, the smaller regparm\n \t\t optimization use, unless requested by the user explicitly.  */\n@@ -5181,11 +5209,28 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset, int style)\n static rtx\n ix86_internal_arg_pointer (void)\n {\n-  if (FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n-      && DECL_NAME (current_function_decl)\n-      && MAIN_NAME_P (DECL_NAME (current_function_decl))\n-      && DECL_FILE_SCOPE_P (current_function_decl))\n-    {\n+  bool has_force_align_arg_pointer =\n+    (0 != lookup_attribute (ix86_force_align_arg_pointer_string,\n+\t\t\t    TYPE_ATTRIBUTES (TREE_TYPE (current_function_decl))));\n+  if ((FORCE_PREFERRED_STACK_BOUNDARY_IN_MAIN\n+       && DECL_NAME (current_function_decl)\n+       && MAIN_NAME_P (DECL_NAME (current_function_decl))\n+       && DECL_FILE_SCOPE_P (current_function_decl))\n+      || ix86_force_align_arg_pointer\n+      || has_force_align_arg_pointer)\n+    {\n+      /* Nested functions can't realign the stack due to a register\n+\t conflict.  */\n+      if (DECL_CONTEXT (current_function_decl)\n+\t  && TREE_CODE (DECL_CONTEXT (current_function_decl)) == FUNCTION_DECL)\n+\t{\n+\t  if (ix86_force_align_arg_pointer)\n+\t    warning (0, \"-mstackrealign ignored for nested functions\");\n+\t  if (has_force_align_arg_pointer)\n+\t    error (\"%s not supported for nested functions\",\n+\t\t   ix86_force_align_arg_pointer_string);\n+\t  return virtual_incoming_args_rtx;\n+\t}\n       cfun->machine->force_align_arg_pointer = gen_rtx_REG (Pmode, 2);\n       return copy_to_reg (cfun->machine->force_align_arg_pointer);\n     }"}, {"sha": "6581291208d2706bf370bb553181b92324287231", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -205,6 +205,10 @@ msselibm\n Target Mask(SSELIBM)\n Use SSE2 ABI libgcc-math routines if using SSE math\n \n+mstackrealign\n+Target Report Var(ix86_force_align_arg_pointer)\n+Realign stack in prologue\n+\n msvr3-shlib\n Target Report Mask(SVR3_SHLIB)\n Uninitialized locals in .bss"}, {"sha": "a281f92cbc9b1854e6161bd0c34e7b8e0537bfb2", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -2207,6 +2207,20 @@ SSE registers instead of on the stack.  Functions that take a\n variable number of arguments will continue to pass all of their\n floating point arguments on the stack.\n \n+@item force_align_arg_pointer\n+@cindex @code{force_align_arg_pointer} attribute\n+On the Intel x86, the @code{force_align_arg_pointer} attribute may be\n+applied to individual function definitions, generating an alternate\n+prologue and epilogue that realigns the runtime stack.  This supports\n+mixing legacy codes that run with a 4-byte aligned stack with modern\n+codes that keep a 16-byte stack for SSE compatibility.  The alternate\n+prologue and epilogue are slower and bigger than the regular ones, and\n+the alternate prologue requires a scratch register; this lowers the\n+number of registers available if used in conjunction with the\n+@code{regparm} attribute.  The @code{force_align_arg_pointer}\n+attribute is incompatible with nested functions; this is considered a\n+hard error.\n+\n @item returns_twice\n @cindex @code{returns_twice} attribute\n The @code{returns_twice} attribute tells the compiler that a function may"}, {"sha": "9ac49e999ebd3a9c502590e024eeed726b7ced43", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -537,6 +537,7 @@ Objective-C and Objective-C++ Dialects}.\n -mthreads  -mno-align-stringops  -minline-all-stringops @gol\n -mpush-args  -maccumulate-outgoing-args  -m128bit-long-double @gol\n -m96bit-long-double  -mregparm=@var{num}  -msseregparm @gol\n+-mstackrealign @gol\n -momit-leaf-frame-pointer  -mno-red-zone -mno-tls-direct-seg-refs @gol\n -mcmodel=@var{code-model} @gol\n -m32  -m64 -mlarge-data-threshold=@var{num}}\n@@ -9464,6 +9465,21 @@ function by using the function attribute @samp{sseregparm}.\n modules with the same value, including any libraries.  This includes\n the system libraries and startup modules.\n \n+@item -mstackrealign\n+@opindex mstackrealign\n+Realign the stack at entry.  On the Intel x86, the\n+@option{-mstackrealign} option will generate an alternate prologue and\n+epilogue that realigns the runtime stack.  This supports mixing legacy\n+codes that keep a 4-byte aligned stack with modern codes that keep a\n+16-byte stack for SSE compatibility.  The alternate prologue and\n+epilogue are slower and bigger than the regular ones, and the\n+alternate prologue requires an extra scratch register; this lowers the\n+number of registers available if used in conjunction with the\n+@code{regparm} attribute.  The @option{-mstackrealign} option is\n+incompatible with the nested function prologue; this is considered a\n+hard error.  See also the attribute @code{force_align_arg_pointer},\n+applicable to individual functions.\n+\n @item -mpreferred-stack-boundary=@var{num}\n @opindex mpreferred-stack-boundary\n Attempt to keep the stack boundary aligned to a 2 raised to @var{num}"}, {"sha": "e270f7a879117c6abfd7c99b27b3e341d77e9dd9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -1,3 +1,10 @@\n+2006-05-12  Stuart Hastings  <stuart@apple.com>\n+\n+\t* testsuite/gcc.target/i386/20060512-1.c: New.\n+\t* testsuite/gcc.target/i386/20060512-2.c: New.\n+\t* testsuite/gcc.target/i386/20060512-3.c: New.\n+\t* testsuite/gcc.target/i386/20060512-4.c: New.\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n 2006-05-17  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/26122"}, {"sha": "a3724ec47ba476a82809a64f7ab22f168387c946", "filename": "gcc/testsuite/gcc.target/i386/20060512-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-1.c?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run { target i?86-*-* } } */\n+/* { dg-options \"-std=gnu99\" } */\n+#include <emmintrin.h>\n+__m128i __attribute__ ((__noinline__))\n+vector_using_function ()\n+{\n+  volatile __m128i vx;\t/* We want to force a vector-aligned store into the stack.  */\n+  vx = _mm_xor_si128 (vx, vx);\n+  return vx;\n+}\n+int __attribute__ ((__noinline__, __force_align_arg_pointer__))\n+self_aligning_function (int x, int y)\n+{\n+  __m128i ignored = vector_using_function ();\n+  return (x + y);\n+}\n+int g_1 = 20;\n+int g_2 = 22;\n+int\n+main ()\n+{\n+  int result;\n+  asm (\"pushl %esi\");\t\t/* Disalign runtime stack.  */\n+  result = self_aligning_function (g_1, g_2);\n+  asm (\"popl %esi\");\n+  if (result != 42)\n+    abort ();\n+}"}, {"sha": "4f411c4a5205b1252b5668cabcecbbf5e95eee4a", "filename": "gcc/testsuite/gcc.target/i386/20060512-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-2.c?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-std=gnu99\" } */\n+int\n+outer_function (int x, int y)\n+{\n+  int __attribute__ ((__noinline__, __force_align_arg_pointer__))\n+  nested_function (int x, int y)\n+    { /* { dg-error \"force_align_arg_pointer not supported for nested functions\" } */\n+      return (x + y);\n+    }\n+  return (3 + nested_function (x, y));\n+}"}, {"sha": "72f0da00bb66fbeda23a63c1e2907e5230975959", "filename": "gcc/testsuite/gcc.target/i386/20060512-3.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-3.c?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do run { target i?86-*-* } } */\n+/* { dg-options \"-std=gnu99 -mstackrealign\" } */\n+#include <emmintrin.h>\n+__m128i __attribute__ ((__noinline__))\n+vector_using_function ()\n+{\n+  volatile __m128i vx;\t/* We want to force a vector-aligned store into the stack.  */\n+  vx = _mm_xor_si128 (vx, vx);\n+  return vx;\n+}\n+int __attribute__ ((__noinline__))\n+self_aligning_function (int x, int y)\n+{\n+  __m128i ignored = vector_using_function ();\n+  return (x + y);\n+}\n+int g_1 = 20;\n+int g_2 = 22;\n+int\n+main ()\n+{\n+  int result;\n+  asm (\"pushl %esi\");\t\t/* Disalign runtime stack.  */\n+  result = self_aligning_function (g_1, g_2);\n+  asm (\"popl %esi\");\n+  if (result != 42)\n+    abort ();\n+}"}, {"sha": "cd569108b70cf12296d7515494d6e180215b6fcf", "filename": "gcc/testsuite/gcc.target/i386/20060512-4.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/339329463663199b22e18901d101b680979c980e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F20060512-4.c?ref=339329463663199b22e18901d101b680979c980e", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target i?86-*-* } } */\n+/* { dg-options \"-mstackrealign\" } */\n+int\n+outer_function (int x, int y)\n+{\n+  int __attribute__ ((__noinline__))\n+  nested_function (int x, int y)\n+    { /* { dg-error \"-mstackrealign ignored for nested functions\" } */\n+      return (x + y);\n+    }\n+  return (3 + nested_function (x, y));\n+}"}]}