{"sha": "046a3beb1673bf4a61c131373b6a5e84158e92bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDQ2YTNiZWIxNjczYmY0YTYxYzEzMTM3M2I2YTVlODQxNThlOTJiZg==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-06-03T14:35:50Z"}, "committer": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2021-06-14T16:39:21Z"}, "message": "arm: Auto-vectorization for MVE: add pack/unpack patterns\n\nThis patch adds vec_unpack<US>_hi_<mode>, vec_unpack<US>_lo_<mode>,\nvec_pack_trunc_<mode> patterns for MVE.\n\nIt does so by moving the unpack patterns from neon.md to\nvec-common.md, while adding them support for MVE. The pack expander is\nderived from the Neon one (which in turn is renamed into\nneon_quad_vec_pack_trunc_<mode>).\n\nThe patch introduces mve_vec_unpack<US>_lo_<mode> and\nmve_vec_unpack<US>_hi_<mode> which are similar to their Neon\ncounterparts, except for the assembly syntax.\n\nThe patch introduces mve_vec_pack_trunc_lo_<mode> to avoid the need for a\nzero-initialized temporary, which is needed if the\nvec_pack_trunc_<mode> expander calls @mve_vmovn[bt]q_<supf><mode>\ninstead.\n\nWith this patch, we can now vectorize the 16 and 8-bit versions of\nvclz and vshl, although the generated code could still be improved.\nFor test_clz_s16, we now generate\n        vldrh.16        q3, [r1]\n        vmovlb.s16   q2, q3\n        vmovlt.s16   q3, q3\n        vclz.i32  q2, q2\n        vclz.i32  q3, q3\n        vmovnb.i32      q1, q2\n        vmovnt.i32      q1, q3\n        vstrh.16        q1, [r0]\nwhich could be improved to\n        vldrh.16        q3, [r1]\n\tvclz.i16\tq1, q3\n        vstrh.16        q1, [r0]\nif we could avoid the need for unpack/pack steps.\n\nFor reference, clang-12 generates:\n\tvldrh.s32       q0, [r1]\n\tvldrh.s32       q1, [r1, #8]\n\tvclz.i32        q0, q0\n\tvstrh.32        q0, [r0]\n\tvclz.i32        q0, q1\n\tvstrh.32        q0, [r0, #8]\n\n2021-06-11  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\tgcc/\n\t* config/arm/mve.md (mve_vec_unpack<US>_lo_<mode>): New pattern.\n\t(mve_vec_unpack<US>_hi_<mode>): New pattern.\n\t(@mve_vec_pack_trunc_lo_<mode>): New pattern.\n\t(mve_vmovntq_<supf><mode>): Prefix with '@'.\n\t* config/arm/neon.md (vec_unpack<US>_hi_<mode>): Move to\n\tvec-common.md.\n\t(vec_unpack<US>_lo_<mode>): Likewise.\n\t(vec_pack_trunc_<mode>): Rename to\n\tneon_quad_vec_pack_trunc_<mode>.\n\t* config/arm/vec-common.md (vec_unpack<US>_hi_<mode>): New\n\tpattern.\n\t(vec_unpack<US>_lo_<mode>): New.\n\t(vec_pack_trunc_<mode>): New.\n\n\tgcc/testsuite/\n\t* gcc.target/arm/simd/mve-vclz.c: Update expected results.\n\t* gcc.target/arm/simd/mve-vshl.c: Likewise.\n\t* gcc.target/arm/simd/mve-vec-pack.c: New test.\n\t* gcc.target/arm/simd/mve-vec-unpack.c: New test.", "tree": {"sha": "492b33eefb5e745a6009ad8d51496c39e9a6eccf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/492b33eefb5e745a6009ad8d51496c39e9a6eccf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/046a3beb1673bf4a61c131373b6a5e84158e92bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046a3beb1673bf4a61c131373b6a5e84158e92bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/046a3beb1673bf4a61c131373b6a5e84158e92bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/046a3beb1673bf4a61c131373b6a5e84158e92bf/comments", "author": null, "committer": null, "parents": [{"sha": "12d13cf50fe68c898ee65d71d1ba9cdb3ea07996", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12d13cf50fe68c898ee65d71d1ba9cdb3ea07996", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12d13cf50fe68c898ee65d71d1ba9cdb3ea07996"}], "stats": {"total": 211, "additions": 168, "deletions": 43}, "files": [{"sha": "e393518ea882041428cc5880ab2cfbcd34f2fb37", "filename": "gcc/config/arm/mve.md", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fmve.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fmve.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fmve.md?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -535,6 +535,26 @@\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n+(define_insn \"mve_vec_unpack<US>_lo_<mode>\"\n+  [(set (match_operand:<V_unpack> 0 \"register_operand\" \"=w\")\n+\t(SE:<V_unpack> (vec_select:<V_HALF>\n+\t\t\t  (match_operand:MVE_3 1 \"register_operand\" \"w\")\n+\t\t\t  (match_operand:MVE_3 2 \"vect_par_constant_low\" \"\"))))]\n+  \"TARGET_HAVE_MVE\"\n+  \"vmovlb.<US>%#<V_sz_elem> %q0, %q1\"\n+  [(set_attr \"type\" \"mve_move\")]\n+)\n+\n+(define_insn \"mve_vec_unpack<US>_hi_<mode>\"\n+  [(set (match_operand:<V_unpack> 0 \"register_operand\" \"=w\")\n+\t(SE:<V_unpack> (vec_select:<V_HALF>\n+\t\t\t  (match_operand:MVE_3 1 \"register_operand\" \"w\")\n+\t\t\t  (match_operand:MVE_3 2 \"vect_par_constant_high\" \"\"))))]\n+  \"TARGET_HAVE_MVE\"\n+  \"vmovlt.<US>%#<V_sz_elem> %q0, %q1\"\n+  [(set_attr \"type\" \"mve_move\")]\n+)\n+\n ;;\n ;; [vcvtpq_s, vcvtpq_u])\n ;;\n@@ -2199,10 +2219,23 @@\n   [(set_attr \"type\" \"mve_move\")\n ])\n \n+;; vmovnb pattern used by the vec_pack_trunc expander to avoid the\n+;; need for an uninitialized input operand.\n+(define_insn \"@mve_vec_pack_trunc_lo_<mode>\"\n+  [\n+   (set (match_operand:<V_narrow_pack> 0 \"s_register_operand\" \"=w\")\n+\t(unspec:<V_narrow_pack> [(match_operand:MVE_5 1 \"s_register_operand\" \"w\")]\n+\t VMOVNBQ_S))\n+  ]\n+  \"TARGET_HAVE_MVE\"\n+  \"vmovnb.i%#<V_sz_elem>\t%q0, %q1\"\n+  [(set_attr \"type\" \"mve_move\")\n+])\n+\n ;;\n ;; [vmovntq_s, vmovntq_u])\n ;;\n-(define_insn \"mve_vmovntq_<supf><mode>\"\n+(define_insn \"@mve_vmovntq_<supf><mode>\"\n   [\n    (set (match_operand:<V_narrow_pack> 0 \"s_register_operand\" \"=w\")\n \t(unspec:<V_narrow_pack> [(match_operand:<V_narrow_pack> 1 \"s_register_operand\" \"0\")"}, {"sha": "392d960791916e6ba1233fd93ee6fa89341b18ef", "filename": "gcc/config/arm/neon.md", "status": "modified", "additions": 1, "deletions": 38, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fneon.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fneon.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fneon.md?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -5924,43 +5924,6 @@ if (BYTES_BIG_ENDIAN)\n   [(set_attr \"type\" \"neon_shift_imm_long\")]\n )\n \n-(define_expand \"vec_unpack<US>_hi_<mode>\"\n-  [(match_operand:<V_unpack> 0 \"register_operand\")\n-   (SE:<V_unpack> (match_operand:VU 1 \"register_operand\"))]\n- \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n-  {\n-   rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;\n-   rtx t1;\n-   int i;\n-   for (i = 0; i < (<V_mode_nunits>/2); i++)\n-     RTVEC_ELT (v, i) = GEN_INT ((<V_mode_nunits>/2) + i);\n-  \n-   t1 = gen_rtx_PARALLEL (<MODE>mode, v);\n-   emit_insn (gen_neon_vec_unpack<US>_hi_<mode> (operands[0], \n-                                                 operands[1], \n-\t\t\t\t\t         t1));\n-   DONE;\n-  }\n-)\n-\n-(define_expand \"vec_unpack<US>_lo_<mode>\"\n-  [(match_operand:<V_unpack> 0 \"register_operand\")\n-   (SE:<V_unpack> (match_operand:VU 1 \"register_operand\"))]\n- \"TARGET_NEON && !BYTES_BIG_ENDIAN\"\n-  {\n-   rtvec v = rtvec_alloc (<V_mode_nunits>/2)  ;\n-   rtx t1;\n-   int i;\n-   for (i = 0; i < (<V_mode_nunits>/2) ; i++)\n-     RTVEC_ELT (v, i) = GEN_INT (i);\n-   t1 = gen_rtx_PARALLEL (<MODE>mode, v);\n-   emit_insn (gen_neon_vec_unpack<US>_lo_<mode> (operands[0], \n-                                                 operands[1], \n-\t\t\t\t   \t         t1));\n-   DONE;\n-  }\n-)\n-\n (define_insn \"neon_vec_<US>mult_lo_<mode>\"\n  [(set (match_operand:<V_unpack> 0 \"register_operand\" \"=w\")\n        (mult:<V_unpack> (SE:<V_unpack> (vec_select:<V_HALF>\n@@ -6176,7 +6139,7 @@ if (BYTES_BIG_ENDIAN)\n ; because the ordering of vector elements in Q registers is different from what\n ; the semantics of the instructions require.\n \n-(define_insn \"vec_pack_trunc_<mode>\"\n+(define_insn \"neon_quad_vec_pack_trunc_<mode>\"\n  [(set (match_operand:<V_narrow_pack> 0 \"register_operand\" \"=&w\")\n        (vec_concat:<V_narrow_pack> \n \t\t(truncate:<V_narrow> "}, {"sha": "f90afa4cdb916a8cb5995a64f5b508867b0d20d8", "filename": "gcc/config/arm/vec-common.md", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fvec-common.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Fconfig%2Farm%2Fvec-common.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvec-common.md?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -632,3 +632,73 @@\n   \"ARM_HAVE_<MODE>_ARITH\n    && !TARGET_REALLY_IWMMXT\"\n )\n+\n+;; vmovl[tb] are not available for V4SI on MVE\n+(define_expand \"vec_unpack<US>_hi_<mode>\"\n+  [(set (match_operand:<V_unpack> 0 \"register_operand\")\n+\t(SE:<V_unpack> (vec_select:<V_HALF>\n+\t\t\t (match_operand:VU 1 \"register_operand\")\n+\t\t\t (match_dup 2))))]\n+ \"ARM_HAVE_<MODE>_ARITH\n+  && !TARGET_REALLY_IWMMXT\n+  && ! (<MODE>mode == V4SImode && TARGET_HAVE_MVE)\n+  && !BYTES_BIG_ENDIAN\"\n+  {\n+    rtvec v = rtvec_alloc (<V_mode_nunits>/2);\n+    int i;\n+    for (i = 0; i < (<V_mode_nunits>/2); i++)\n+      RTVEC_ELT (v, i) = GEN_INT ((<V_mode_nunits>/2) + i);\n+\n+    operands[2] = gen_rtx_PARALLEL (<MODE>mode, v);\n+  }\n+)\n+\n+;; vmovl[tb] are not available for V4SI on MVE\n+(define_expand \"vec_unpack<US>_lo_<mode>\"\n+  [(set (match_operand:<V_unpack> 0 \"register_operand\")\n+\t(SE:<V_unpack> (vec_select:<V_HALF>\n+\t\t\t (match_operand:VU 1 \"register_operand\")\n+\t\t\t (match_dup 2))))]\n+ \"ARM_HAVE_<MODE>_ARITH\n+  && !TARGET_REALLY_IWMMXT\n+  && ! (<MODE>mode == V4SImode && TARGET_HAVE_MVE)\n+  && !BYTES_BIG_ENDIAN\"\n+  {\n+    rtvec v = rtvec_alloc (<V_mode_nunits>/2);\n+    int i;\n+    for (i = 0; i < (<V_mode_nunits>/2) ; i++)\n+      RTVEC_ELT (v, i) = GEN_INT (i);\n+\n+    operands[2] = gen_rtx_PARALLEL (<MODE>mode, v);\n+\n+  }\n+)\n+\n+;; vmovn[tb] are not available for V2DI on MVE\n+(define_expand \"vec_pack_trunc_<mode>\"\n+ [(set (match_operand:<V_narrow_pack> 0 \"register_operand\")\n+       (vec_concat:<V_narrow_pack>\n+\t\t(truncate:<V_narrow>\n+\t\t\t(match_operand:VN 1 \"register_operand\"))\n+\t\t(truncate:<V_narrow>\n+\t\t\t(match_operand:VN 2 \"register_operand\"))))]\n+ \"ARM_HAVE_<MODE>_ARITH\n+  && !TARGET_REALLY_IWMMXT\n+  && ! (<MODE>mode == V2DImode && TARGET_HAVE_MVE)\n+  && !BYTES_BIG_ENDIAN\"\n+ {\n+   if (TARGET_NEON)\n+     {\n+       emit_insn (gen_neon_quad_vec_pack_trunc_<mode> (operands[0], operands[1],\n+\t\t\t\t\t\t       operands[2]));\n+     }\n+   else\n+     {\n+       rtx tmpreg = gen_reg_rtx (<V_narrow_pack>mode);\n+       emit_insn (gen_mve_vec_pack_trunc_lo (<MODE>mode, tmpreg, operands[1]));\n+       emit_insn (gen_mve_vmovntq (VMOVNTQ_S, <MODE>mode,\n+\t\t\t\t   operands[0], tmpreg, operands[2]));\n+     }\n+   DONE;\n+ }\n+)"}, {"sha": "5d6e991cfc6d83b34122c75b85e4d457d90e8660", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vclz.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vclz.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vclz.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vclz.c?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -21,8 +21,9 @@ FUNC(u, uint, 16, clz)\n FUNC(s, int, 8, clz)\n FUNC(u, uint, 8, clz)\n \n-/* 16 and 8-bit versions are not vectorized because they need pack/unpack\n-   patterns since __builtin_clz uses 32-bit parameter and return value.  */\n-/* { dg-final { scan-assembler-times {vclz\\.i32  q[0-9]+, q[0-9]+} 2 } } */\n+/* 16 and 8-bit versions still use 32-bit intermediate temporaries, so for\n+   instance instead of using vclz.i8, we need 4 vclz.i32, leading to a total of\n+   14 vclz.i32 expected in this testcase.  */\n+/* { dg-final { scan-assembler-times {vclz\\.i32  q[0-9]+, q[0-9]+} 14 } } */\n /* { dg-final { scan-assembler-times {vclz\\.i16  q[0-9]+, q[0-9]+} 2 { xfail *-*-* } } } */\n /* { dg-final { scan-assembler-times {vclz\\.i8  q[0-9]+, q[0-9]+} 2 { xfail *-*-* } } } */"}, {"sha": "43642b2fec582abc9ea703114094602a1561ad51", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vec-pack.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-pack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-pack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-pack.c?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC(SIGN, TYPE, DSTBITS, BITS, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##DSTBITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a) {\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (256 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = a[i];\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC(s, int, 16, 32, pack)\n+FUNC(u, uint, 16, 32, pack)\n+FUNC(s, int, 8, 16, pack)\n+FUNC(u, uint, 8, 16, pack)\n+\n+/* { dg-final { scan-assembler-times {vmovnt\\.i32\\tq[0-9]+, q[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler-times {vmovnb\\.i32\\tq[0-9]+, q[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler-times {vmovnt\\.i16\\tq[0-9]+, q[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler-times {vmovnb\\.i16\\tq[0-9]+, q[0-9]+} 2 } } */\n+/* { dg-final { scan-assembler-not {vldr\\.64\\td[0-9]+, \\.L} } } */"}, {"sha": "cdc62f854ad1942a3ffa2d4dcfed002db80f5e9a", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vec-unpack.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-unpack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-unpack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vec-unpack.c?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_v8_1m_mve_ok } */\n+/* { dg-add-options arm_v8_1m_mve } */\n+/* { dg-additional-options \"-O3\" } */\n+\n+#include <stdint.h>\n+\n+#define FUNC(SIGN, TYPE, DSTBITS, BITS, NAME)\t\t\t\t\\\n+  void test_ ## NAME ##_ ## SIGN ## BITS (TYPE##DSTBITS##_t * __restrict__ dest, \\\n+\t\t\t\t\t  TYPE##BITS##_t *a) {\t\t\\\n+    int i;\t\t\t\t\t\t\t\t\\\n+    for (i=0; i < (128 / BITS); i++) {\t\t\t\t\t\\\n+      dest[i] = a[i];\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+FUNC(s, int, 32, 16, unpack)\n+FUNC(u, uint, 32, 16, unpack)\n+FUNC(s, int, 16, 8, unpack)\n+FUNC(u, uint, 16, 8, unpack)\n+\n+/* { dg-final { scan-assembler-times {vmovlt\\.s16 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlb\\.s16 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlt\\.u16 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlb\\.u16 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlt\\.s8 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlb\\.s8 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlt\\.u8 q[0-9]+, q[0-9]+} 1 } } */\n+/* { dg-final { scan-assembler-times {vmovlb\\.u8 q[0-9]+, q[0-9]+} 1 } } */"}, {"sha": "91dd942d818f49615e4df517ea48c8fb02b015b2", "filename": "gcc/testsuite/gcc.target/arm/simd/mve-vshl.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/046a3beb1673bf4a61c131373b6a5e84158e92bf/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fsimd%2Fmve-vshl.c?ref=046a3beb1673bf4a61c131373b6a5e84158e92bf", "patch": "@@ -56,7 +56,10 @@ FUNC_IMM(u, uint, 8, 16, <<, vshlimm)\n /* MVE has only 128-bit vectors, so we can vectorize only half of the\n    functions above.  */\n /* We only emit vshl.u, which is equivalent to vshl.s anyway.  */\n-/* { dg-final { scan-assembler-times {vshl.u[0-9]+\\tq[0-9]+, q[0-9]+} 2 } } */\n+/* 16 and 8-bit versions still use 32-bit intermediate temporaries, so for\n+   instance instead of using vshl.u8, we need 4 vshl.i32, leading to a total of\n+   14 vshl.i32 expected in this testcase.  */\n+/* { dg-final { scan-assembler-times {vshl.u[0-9]+\\tq[0-9]+, q[0-9]+} 14 } } */\n \n /* We emit vshl.i when the shift amount is an immediate.  */\n /* { dg-final { scan-assembler-times {vshl.i[0-9]+\\tq[0-9]+, q[0-9]+} 6 } } */"}]}