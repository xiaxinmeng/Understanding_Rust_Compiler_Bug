{"sha": "7dac2f891f43324a2e3dddc79a384d5d96374900", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhYzJmODkxZjQzMzI0YTJlM2RkZGM3OWEzODRkNWQ5NjM3NDkwMA==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2001-07-06T07:32:43Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2001-07-06T07:32:43Z"}, "message": "[multiple changes]\n\n2001-07-05  Eric Christopher  <echristo@redhat.com>\n\n        * config/mips/mips.h (MASK_MIPS3900): Remove.\n        (MASK_MIPS16,MASK_NO_CHECK_ZERO_DIV,MASK_CHECK_RANGE_DIV,\n        MASK_UNINIT_CONST_IN_RODATA): Change for 3900 mask removal.\n        (TARGET_MIPS3900): Change to use mips_arch.\n        (TARGET_MIPS4000): New.\n        (TARGET_MIPS4100): New.\n        (TARGET_MIPS4300): New.\n        (TARGET_SWITCHES): Change 3900 and 4650 options to NULL.\n        (SUBTARGET_TARGET_OPTIONS): Add -march. Change help text\n        for -mipsX.\n        (GENERATE_BRANCHLIKELY): Move TARGET_MIPS3900.\n        (ISA_HAS_BRANCHLIKELY): To here.\n        (CC1_CPU_SPEC):  New.\n        (CC1_SPEC): Use here.  Remove 4650 and 3900 options.\n        (mips_arch_string): Declare.\n        (mips_arch): Declare.\n        (TARGET_OPTIONS): Add -march and -mtune.\n\n        * config/mips/mips.c (mips_arch_string): New.\n        (mips_arch): New.\n        (override_options): Handle -march for codegen and -mtune\n        for scheduling. Use mips_arch. Move tx39 target default here.\n        (mips_parse_cpu): Move error message to override_options.\n\n        * config/mips/r3900.h (TARGET_DEFAULT): Remove.\n\n        * config/mips/mips.md: Use TARGET_MIPS4000 and TARGET_MIPS4300.\n\n        * doc/invoke.texi (Option Summary): Add -march and -mtune entries.\n        (MIPS Options): Ditto.  Change mcpu entry to historical text.\n\n2001-07-05  H.J. Lu  (hjl@gnu.org)\n\n        * config/mips/mips.c (mips_parse_cpu): New function to parse\n        -march=*/-mcpu=*.\n\nFrom-SVN: r43803", "tree": {"sha": "61140b6c79b7765bdda176c54f728935cf108b3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61140b6c79b7765bdda176c54f728935cf108b3b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dac2f891f43324a2e3dddc79a384d5d96374900", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dac2f891f43324a2e3dddc79a384d5d96374900", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dac2f891f43324a2e3dddc79a384d5d96374900", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dac2f891f43324a2e3dddc79a384d5d96374900/comments", "author": null, "committer": null, "parents": [{"sha": "8a7496476ac9eb69da4d650175dbb9376262d8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a7496476ac9eb69da4d650175dbb9376262d8db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a7496476ac9eb69da4d650175dbb9376262d8db"}], "stats": {"total": 1040, "additions": 600, "deletions": 440}, "files": [{"sha": "da11f96aca8690df7b3c2737771afba7e4e7dcc2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -1,3 +1,41 @@\n+2001-07-05  Eric Christopher  <echristo@redhat.com>\n+\n+        * config/mips/mips.h (MASK_MIPS3900): Remove.\n+        (MASK_MIPS16,MASK_NO_CHECK_ZERO_DIV,MASK_CHECK_RANGE_DIV,\n+        MASK_UNINIT_CONST_IN_RODATA): Change for 3900 mask removal.\n+        (TARGET_MIPS3900): Change to use mips_arch.\n+        (TARGET_MIPS4000): New.\n+        (TARGET_MIPS4100): New.\n+        (TARGET_MIPS4300): New.\n+        (TARGET_SWITCHES): Change 3900 and 4650 options to NULL.\n+        (SUBTARGET_TARGET_OPTIONS): Add -march. Change help text\n+        for -mipsX.\n+        (GENERATE_BRANCHLIKELY): Move TARGET_MIPS3900.\n+        (ISA_HAS_BRANCHLIKELY): To here.\n+        (CC1_CPU_SPEC):  New.\n+        (CC1_SPEC): Use here.  Remove 4650 and 3900 options.\n+        (mips_arch_string): Declare.\n+        (mips_arch): Declare.\n+        (TARGET_OPTIONS): Add -march and -mtune.\n+\n+        * config/mips/mips.c (mips_arch_string): New.\n+        (mips_arch): New.\n+        (override_options): Handle -march for codegen and -mtune\n+        for scheduling. Use mips_arch. Move tx39 target default here.\n+        (mips_parse_cpu): Move error message to override_options.\n+\n+        * config/mips/r3900.h (TARGET_DEFAULT): Remove.\n+\n+        * config/mips/mips.md: Use TARGET_MIPS4000 and TARGET_MIPS4300.\n+\n+        * doc/invoke.texi (Option Summary): Add -march and -mtune entries.\n+        (MIPS Options): Ditto.  Change mcpu entry to historical text.\n+\n+2001-07-05  H.J. Lu  (hjl@gnu.org)\n+\n+        * config/mips/mips.c (mips_parse_cpu): New function to parse\n+        -march=*/-mcpu=*.\n+\n 2001-07-05  Jim Wilson  <wilson@redhat.com>\n \n \t* config/ia64/lib1funcs.asm: Revert 2001-07-02 change.\n@@ -10,8 +48,8 @@\n \n 2001-07-04  Stephane Carrez  <Stephane.Carrez@worldnet.fr>\n \n-\t* config/m68hc11/m68hc11.md (\"*ashlsi3\"): Operand 1 can be a memory \n-\treference using the stack pointer, adjust it since we push Y \n+\t* config/m68hc11/m68hc11.md (\"*ashlsi3\"): Operand 1 can be a memory\n+\treference using the stack pointer, adjust it since we push Y\n \ttemporarily.\n \t(\"*ashrsi3\"): Likewise.\n \t(\"*lshrsi3\"): Likewise."}, {"sha": "f2805e2d00ea8c533ed715d82ff949b60af0836d", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 414, "deletions": 342, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -86,7 +86,7 @@ static int mips16_simple_memory_operand\t\tPARAMS ((rtx, rtx,\n \t\t\t\t\t\t\tenum machine_mode));\n static int m16_check_op\t\t\t\tPARAMS ((rtx, int, int, int));\n static void block_move_loop\t\t\tPARAMS ((rtx, rtx,\n-\t\t\t\t\t\t\t unsigned int, \n+\t\t\t\t\t\t\t unsigned int,\n \t\t\t\t\t\t\t int,\n \t\t\t\t\t\t\t rtx, rtx));\n static void block_move_call\t\t\tPARAMS ((rtx, rtx, rtx));\n@@ -107,6 +107,7 @@ static void abort_with_insn\t\t\tPARAMS ((rtx, const char *))\n   ATTRIBUTE_NORETURN;\n static int symbolic_expression_p                PARAMS ((rtx));\n static void mips_add_gc_roots                   PARAMS ((void));\n+static enum processor_type mips_parse_cpu       PARAMS ((const char *));\n \n /* Global variables for machine-dependent things.  */\n \n@@ -193,7 +194,13 @@ enum cmp_type branch_type;\n static int prev_half_pic_ptrs = 0;\n static int prev_half_pic_refs = 0;\n \n-/* which cpu are we scheduling for */\n+/* The target cpu for code generation.  */\n+enum processor_type mips_arch;\n+\n+/* The target cpu for optimization and scheduling.  */\n+enum processor_type mips_tune;\n+\n+/* Historical option for code generation and scheduling.  */\n enum processor_type mips_cpu;\n \n /* which instruction set architecture to use.  */\n@@ -207,6 +214,8 @@ int mips_abi;\n \n /* Strings to hold which cpu and instruction set architecture to use.  */\n const char *mips_cpu_string;\t/* for -mcpu=<xxx> */\n+const char *mips_arch_string;   /* for -march=<xxx> */\n+const char *mips_tune_string;   /* for -mtune=<xxx> */\n const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n const char *mips_abi_string;\t/* for -mabi={32,n32,64,eabi} */\n \n@@ -219,7 +228,7 @@ int mips16;\n    just a way to avoid using up another bit in target_flags.  */\n const char *mips_no_mips16_string;\n \n-/* This is only used to determine if an type size setting option was \n+/* This is only used to determine if an type size setting option was\n    explicitly specified (-mlong64, -mint64, -mlong32).  The specs\n    set this option if such an option is used. */\n const char *mips_explicit_type_size_string;\n@@ -1220,7 +1229,7 @@ int\n mips_check_split (address, mode)\n      rtx address;\n      enum machine_mode mode;\n-{     \n+{\n   /* ??? This is the same check used in simple_memory_operand.\n      We use it here because LO_SUM is not offsettable.  */\n   if (GET_MODE_SIZE (mode) > (unsigned) UNITS_PER_WORD)\n@@ -1244,7 +1253,7 @@ mips_reg_mode_ok_for_base_p (reg, mode, strict)\n      enum machine_mode mode;\n      int strict;\n {\n-  return (strict \n+  return (strict\n \t  ? REGNO_MODE_OK_FOR_BASE_P (REGNO (reg), mode)\n \t  : GP_REG_OR_PSEUDO_NONSTRICT_P (REGNO (reg), mode));\n }\n@@ -1260,111 +1269,111 @@ mips_legitimate_address_p (mode, xinsn, strict)\n      rtx xinsn;\n      int strict;\n {\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      GO_PRINTF2 (\"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\t\n-\t\t  strict ? \"\" : \"not \");\t\t\t\n-      GO_DEBUG_RTX (xinsn);\t\t\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  /* Check for constant before stripping off SUBREG, so that we don't\t\n-     accept (subreg (const_int)) which will fail to reload. */   \t\n-  if (CONSTANT_ADDRESS_P (xinsn)\t\t\t\t\t\n+  if (TARGET_DEBUG_B_MODE)\n+    {\n+      GO_PRINTF2 (\"\\n========== GO_IF_LEGITIMATE_ADDRESS, %sstrict\\n\",\n+\t\t  strict ? \"\" : \"not \");\n+      GO_DEBUG_RTX (xinsn);\n+    }\n+\n+  /* Check for constant before stripping off SUBREG, so that we don't\n+     accept (subreg (const_int)) which will fail to reload. */\n+  if (CONSTANT_ADDRESS_P (xinsn)\n       && ! (mips_split_addresses && mips_check_split (xinsn, mode))\n-      && (! TARGET_MIPS16 || mips16_constant (xinsn, mode, 1, 0)))\t\n-    return 1;\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  while (GET_CODE (xinsn) == SUBREG)\t\t\t\t\t\n-    xinsn = SUBREG_REG (xinsn);\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  /* The mips16 can only use the stack pointer as a base register when\t\n-     loading SImode or DImode values.  */\t\t\t\t\n-  if (GET_CODE (xinsn) == REG \n-      && mips_reg_mode_ok_for_base_p (xinsn, mode, strict))\t\n-    return 1;\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  if (GET_CODE (xinsn) == LO_SUM && mips_split_addresses)\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      register rtx xlow0 = XEXP (xinsn, 0);\t\t\t\t\n-      register rtx xlow1 = XEXP (xinsn, 1);\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-      while (GET_CODE (xlow0) == SUBREG)\t\t\t\t\n-\txlow0 = SUBREG_REG (xlow0);\t\t\t\t\t\n-      if (GET_CODE (xlow0) == REG\t\t\t\t\t\n+      && (! TARGET_MIPS16 || mips16_constant (xinsn, mode, 1, 0)))\n+    return 1;\n+\n+  while (GET_CODE (xinsn) == SUBREG)\n+    xinsn = SUBREG_REG (xinsn);\n+\n+  /* The mips16 can only use the stack pointer as a base register when\n+     loading SImode or DImode values.  */\n+  if (GET_CODE (xinsn) == REG\n+      && mips_reg_mode_ok_for_base_p (xinsn, mode, strict))\n+    return 1;\n+\n+  if (GET_CODE (xinsn) == LO_SUM && mips_split_addresses)\n+    {\n+      register rtx xlow0 = XEXP (xinsn, 0);\n+      register rtx xlow1 = XEXP (xinsn, 1);\n+\n+      while (GET_CODE (xlow0) == SUBREG)\n+\txlow0 = SUBREG_REG (xlow0);\n+      if (GET_CODE (xlow0) == REG\n \t  && mips_reg_mode_ok_for_base_p (xlow0, mode, strict)\n \t  && mips_check_split (xlow1, mode))\n-\treturn 1;\t\t\t\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  if (GET_CODE (xinsn) == PLUS)\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      register rtx xplus0 = XEXP (xinsn, 0);\t\t\t\t\n-      register rtx xplus1 = XEXP (xinsn, 1);\t\t\t\t\n-      register enum rtx_code code0;\t\t\t\t\t\n-      register enum rtx_code code1;\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-      while (GET_CODE (xplus0) == SUBREG)\t\t\t\t\n-\txplus0 = SUBREG_REG (xplus0);\t\t\t\t\t\n-      code0 = GET_CODE (xplus0);\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-      while (GET_CODE (xplus1) == SUBREG)\t\t\t\t\n-\txplus1 = SUBREG_REG (xplus1);\t\t\t\t\t\n-      code1 = GET_CODE (xplus1);\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-      /* The mips16 can only use the stack pointer as a base register\t\n-         when loading SImode or DImode values.  */\t\t\t\n-      if (code0 == REG \n-\t  && mips_reg_mode_ok_for_base_p (xplus0, mode, strict))\t\n-\t{\t\t\t\t\t\t\t\t\n+\treturn 1;\n+    }\n+\n+  if (GET_CODE (xinsn) == PLUS)\n+    {\n+      register rtx xplus0 = XEXP (xinsn, 0);\n+      register rtx xplus1 = XEXP (xinsn, 1);\n+      register enum rtx_code code0;\n+      register enum rtx_code code1;\n+\n+      while (GET_CODE (xplus0) == SUBREG)\n+\txplus0 = SUBREG_REG (xplus0);\n+      code0 = GET_CODE (xplus0);\n+\n+      while (GET_CODE (xplus1) == SUBREG)\n+\txplus1 = SUBREG_REG (xplus1);\n+      code1 = GET_CODE (xplus1);\n+\n+      /* The mips16 can only use the stack pointer as a base register\n+         when loading SImode or DImode values.  */\n+      if (code0 == REG\n+\t  && mips_reg_mode_ok_for_base_p (xplus0, mode, strict))\n+\t{\n \t  if (code1 == CONST_INT && SMALL_INT (xplus1))\n \t    return 1;\n-\t\t\t\t\t\t\t\t\t\n-\t  /* On the mips16, we represent GP relative offsets in RTL.\t\n-             These are 16 bit signed values, and can serve as register\t\n-             offsets.  */\t\t\t\t\t\t\n-\t  if (TARGET_MIPS16\t\t\t\t\t\t\n-\t      && mips16_gp_offset_p (xplus1))\t\t\t\t\n-\t    return 1;\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-\t  /* For some code sequences, you actually get better code by\t\n-\t     pretending that the MIPS supports an address mode of a\t\n-\t     constant address + a register, even though the real\t\n-\t     machine doesn't support it.  This is because the\t\t\n-\t     assembler can use $r1 to load just the high 16 bits, add\t\n-\t     in the register, and fold the low 16 bits into the memory\t\n-\t     reference, whereas the compiler generates a 4 instruction\t\n-\t     sequence.  On the other hand, CSE is not as effective.\t\n-\t     It would be a win to generate the lui directly, but the\t\n-\t     MIPS assembler does not have syntax to generate the\t\n-\t     appropriate relocation.  */\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-\t  /* Also accept CONST_INT addresses here, so no else.  */\t\n-\t  /* Reject combining an embedded PIC text segment reference\t\n-\t     with a register.  That requires an additional\t\t\n-\t     instruction.  */\t\t\t\t\t\t\n-          /* ??? Reject combining an address with a register for the MIPS  \n-\t     64 bit ABI, because the SGI assembler can not handle this.  */ \n-\t  if (!TARGET_DEBUG_A_MODE\t\t\t\t\t\n-\t      && (mips_abi == ABI_32\t\t\t\t\t\n-\t\t  || mips_abi == ABI_O64\t\t\t\t\n-\t\t  || mips_abi == ABI_EABI)\t\t\t\t\n-\t      && CONSTANT_ADDRESS_P (xplus1)\t\t\t\t\n-\t      && ! mips_split_addresses\t\t\t\t\t\n-\t      && (!TARGET_EMBEDDED_PIC\t\t\t\t\t\n-\t\t  || code1 != CONST\t\t\t\t\t\n-\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS)\t\t\n-\t      /* When assembling for machines with 64 bit registers, \n+\n+\t  /* On the mips16, we represent GP relative offsets in RTL.\n+             These are 16 bit signed values, and can serve as register\n+             offsets.  */\n+\t  if (TARGET_MIPS16\n+\t      && mips16_gp_offset_p (xplus1))\n+\t    return 1;\n+\n+\t  /* For some code sequences, you actually get better code by\n+\t     pretending that the MIPS supports an address mode of a\n+\t     constant address + a register, even though the real\n+\t     machine doesn't support it.  This is because the\n+\t     assembler can use $r1 to load just the high 16 bits, add\n+\t     in the register, and fold the low 16 bits into the memory\n+\t     reference, whereas the compiler generates a 4 instruction\n+\t     sequence.  On the other hand, CSE is not as effective.\n+\t     It would be a win to generate the lui directly, but the\n+\t     MIPS assembler does not have syntax to generate the\n+\t     appropriate relocation.  */\n+\n+\t  /* Also accept CONST_INT addresses here, so no else.  */\n+\t  /* Reject combining an embedded PIC text segment reference\n+\t     with a register.  That requires an additional\n+\t     instruction.  */\n+          /* ??? Reject combining an address with a register for the MIPS\n+\t     64 bit ABI, because the SGI assembler can not handle this.  */\n+\t  if (!TARGET_DEBUG_A_MODE\n+\t      && (mips_abi == ABI_32\n+\t\t  || mips_abi == ABI_O64\n+\t\t  || mips_abi == ABI_EABI)\n+\t      && CONSTANT_ADDRESS_P (xplus1)\n+\t      && ! mips_split_addresses\n+\t      && (!TARGET_EMBEDDED_PIC\n+\t\t  || code1 != CONST\n+\t\t  || GET_CODE (XEXP (xplus1, 0)) != MINUS)\n+\t      /* When assembling for machines with 64 bit registers,\n \t         the assembler will not sign-extend the constant \"foo\"\n \t\t in \"la x, foo(x)\" */\n \t      && (!TARGET_64BIT || (INTVAL (xplus1) > 0))\n-\t      && !TARGET_MIPS16)\t\t\t\t\t\n-\t    return 1;\t\t\t\t\t\t\t\n-\t}\t\t\t\t\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-\t\t\t\t\t\t\t\t\t\n-  if (TARGET_DEBUG_B_MODE)\t\t\t\t\t\t\n+\t      && !TARGET_MIPS16)\n+\t    return 1;\n+\t}\n+    }\n+\n+  if (TARGET_DEBUG_B_MODE)\n     GO_PRINTF (\"Not a legitimate address\\n\");\n-  \n+\n   /* The address was not legitimate.  */\n   return 0;\n }\n@@ -1793,7 +1802,7 @@ embedded_pic_offset (x)\n       rtx seq;\n \n       embedded_pic_fnaddr_rtx = gen_reg_rtx (Pmode);\n-      \n+\n       /* Output code at function start to initialize the pseudo-reg.  */\n       /* ??? We used to do this in FINALIZE_PIC, but that does not work for\n \t inline functions, because it is called after RTL for the function\n@@ -2199,7 +2208,7 @@ mips_move_1word (operands, insn, unsignedp)\n \n \t  if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n \t    abort ();\n-\t  \n+\n \t  sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n \t  ret = volatile_buffer;\n \t}\n@@ -2259,7 +2268,7 @@ mips_move_2words (operands, insn)\n       op1 = SUBREG_REG (op1);\n       code1 = GET_CODE (op1);\n     }\n-      \n+\n   /* Sanity check.  */\n   if (GET_CODE (operands[1]) == SIGN_EXTEND\n       && code1 != REG\n@@ -2392,7 +2401,7 @@ mips_move_2words (operands, insn)\n \t\t       or higher.  For !TARGET_64BIT && gp registers we\n \t\t       need to avoid this by using two li instructions\n \t\t       instead.  */\n-\t\t    if (ISA_HAS_64BIT_REGS \n+\t\t    if (ISA_HAS_64BIT_REGS\n \t\t\t&& ! TARGET_64BIT\n \t\t\t&& ! FP_REG_P (regno0))\n \t\t      {\n@@ -2460,7 +2469,7 @@ mips_move_2words (operands, insn)\n \t\t      : \"mt%0\\t%.\\n\");\n \t    }\n \t}\n-\t\n+\n       else if (code1 == CONST_INT && GET_MODE (op0) == DImode\n \t       && GP_REG_P (regno0))\n \t{\n@@ -2661,7 +2670,7 @@ mips_move_2words (operands, insn)\n \n \t  if (i > sizeof (volatile_buffer) - sizeof (\"%{%}\"))\n \t    abort ();\n-\t  \n+\n \t  sprintf (volatile_buffer, \"%%{%s%%}\", ret);\n \t  ret = volatile_buffer;\n \t}\n@@ -2748,7 +2757,7 @@ mips_address_cost (addr)\n   return 4;\n }\n \n-/* Return nonzero if X is an address which needs a temporary register when \n+/* Return nonzero if X is an address which needs a temporary register when\n    reloaded while generating PIC code.  */\n \n int\n@@ -3059,7 +3068,7 @@ gen_conditional_branch (operands, test_code)\n       emit_insn (gen_rtx_SET (VOIDmode, reg,\n \t\t\t      gen_rtx (test_code == NE ? EQ : test_code,\n \t\t\t\t       CCmode, cmp0, cmp1)));\n-      \n+\n       test_code = test_code == NE ? EQ : NE;\n       mode = CCmode;\n       cmp0 = reg;\n@@ -3156,7 +3165,7 @@ gen_conditional_move (operands)\n     }\n   else if (cmp_code == NE)\n     cmp_code = EQ, move_code = EQ;\n-\t  \n+\n   if (mode == SImode || mode == DImode)\n     cmp_mode = mode;\n   else if (mode == SFmode || mode == DFmode)\n@@ -3381,7 +3390,7 @@ expand_block_move (operands)\n   else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES\n \t   && align == (unsigned) UNITS_PER_WORD)\n     move_by_pieces (orig_dest, orig_src, bytes, align * BITS_PER_WORD);\n-\t\n+\n   else if (constp && bytes <= (unsigned)2 * MAX_MOVE_BYTES)\n     emit_insn (gen_movstrsi_internal (replace_equiv_address (orig_dest,\n \t\t\t\t\t\t\t     dest_reg),\n@@ -3445,7 +3454,7 @@ expand_block_move (operands)\n     block_move_call (dest_reg, src_reg, bytes_rtx);\n }\n \f\n-/* Emit load/stores for a small constant block_move. \n+/* Emit load/stores for a small constant block_move.\n \n    operands[0] is the memory address of the destination.\n    operands[1] is the memory address of the source.\n@@ -3945,7 +3954,7 @@ function_arg (cum, mode, type, named)\n       fprintf (stderr, HOST_PTR_PRINTF, (const PTR) type);\n       fprintf (stderr, \", %d ) = \", named);\n     }\n-  \n+\n \n   cum->last_arg_fp = 0;\n   switch (mode)\n@@ -4108,8 +4117,8 @@ function_arg (cum, mode, type, named)\n \t\t\t\t       regno + FP_ARG_FIRST - GP_ARG_FIRST);\n \t\t  else\n \t\t    reg = gen_rtx_REG (word_mode, regno);\n-\t\t  \n-\t\t  XVECEXP (ret, 0, i) \n+\n+\t\t  XVECEXP (ret, 0, i)\n \t\t    = gen_rtx_EXPR_LIST (VOIDmode, reg,\n \t\t\t\t\t GEN_INT (bitpos / BITS_PER_UNIT));\n \n@@ -4219,15 +4228,15 @@ function_arg_partial_nregs (cum, mode, type, named)\n \f\n /* Create the va_list data type.\n    We keep 3 pointers, and two offsets.\n-   Two pointers are to the overflow area, which starts at the CFA. \n+   Two pointers are to the overflow area, which starts at the CFA.\n      One of these is constant, for addressing into the GPR save area below it.\n      The other is advanced up the stack through the overflow region.\n    The third pointer is to the GPR save area.  Since the FPR save area\n      is just below it, we can address FPR slots off this pointer.\n    We also keep two one-byte offsets, which are to be subtracted from the\n      constant pointers to yield addresses in the GPR and FPR save areas.\n-     These are downcounted as float or non-float arguments are used, \n-     and when they get to zero, the argument must be obtained from the \n+     These are downcounted as float or non-float arguments are used,\n+     and when they get to zero, the argument must be obtained from the\n      overflow region.\n    If TARGET_SOFT_FLOAT or TARGET_SINGLE_FLOAT, then no FPR save area exists,\n      and a single pointer is enough.  It's started at the GPR save area,\n@@ -4307,8 +4316,8 @@ mips_va_start (stdarg_p, valist, nextarg)\n \n       if (!TARGET_SOFT_FLOAT && !TARGET_SINGLE_FLOAT)\n \t{\n-\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff; \n-\t  tree ovfl, gtop, ftop, goff, foff; \n+\t  tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n+\t  tree ovfl, gtop, ftop, goff, foff;\n \t  tree gprv;\n \t  int float_formals, fpr_offset, size_excess, floats_passed_in_regs;\n \t  int fpr_save_offset;\n@@ -4347,7 +4356,7 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t     8 byte boundary.  This means that the above calculation should\n \t     take into account the exact sequence of floats and non-floats\n \t     which make up the excess.  That calculation should be rolled\n-\t     into the code which sets the current_function_args_info struct.  \n+\t     into the code which sets the current_function_args_info struct.\n \t     The above then reduces to a fetch from that struct. */\n \n \n@@ -4377,7 +4386,7 @@ mips_va_start (stdarg_p, valist, nextarg)\n \t        fpr_save_offset += 4;\n \t    }\n \t  if (fpr_save_offset)\n-\t    gprv = build (PLUS_EXPR, TREE_TYPE (ftop), gprv, \n+\t    gprv = build (PLUS_EXPR, TREE_TYPE (ftop), gprv,\n \t      \tbuild_int_2 (-fpr_save_offset,-1));\n \t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, gprv);\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4459,8 +4468,8 @@ mips_va_arg (valist, type)\n     {\n       int indirect;\n       rtx r, lab_over = NULL_RTX, lab_false;\n-      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff; \n-      tree ovfl, gtop, ftop, goff, foff; \n+      tree f_ovfl, f_gtop, f_ftop, f_goff, f_foff;\n+      tree ovfl, gtop, ftop, goff, foff;\n \n       indirect\n \t= function_arg_pass_by_reference (NULL, TYPE_MODE (type), type, 0);\n@@ -4484,13 +4493,13 @@ mips_va_arg (valist, type)\n \t    {\n \t      t = build (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n \t\t     build_int_2 (2*UNITS_PER_WORD - 1, 0));\n-\t      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, \n+\t      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n \t\t     build_int_2 (-2*UNITS_PER_WORD, -1));\n \t      t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n \t      expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t    }\n \n-      \t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr, \n+      \t  t = build (POSTINCREMENT_EXPR, TREE_TYPE (gpr), gpr,\n \t\tsize_int (rsize));\n       \t  r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n      \t  if (r != addr_rtx)\n@@ -4545,7 +4554,7 @@ mips_va_arg (valist, type)\n           if (r != addr_rtx)\n       \t    emit_move_insn (addr_rtx, r);\n \n-          /* Emit code for foff-=8. \n+          /* Emit code for foff-=8.\n       \t     Advances the offset up FPR save area by one double */\n           t = build (MINUS_EXPR, TREE_TYPE (foff), foff, build_int_2 (8, 0));\n           t = build (MODIFY_EXPR, TREE_TYPE (foff), foff, t);\n@@ -4555,8 +4564,8 @@ mips_va_arg (valist, type)\n           emit_jump (lab_over);\n           emit_barrier ();\n           emit_label (lab_false);\n-\t      \n-\t  if (!TARGET_64BIT) \n+\n+\t  if (!TARGET_64BIT)\n \t    {\n \t      /* For mips2, the overflow area contains mixed size items.\n \t\t If a 4-byte int is followed by an 8-byte float, then\n@@ -4571,7 +4580,7 @@ mips_va_arg (valist, type)\n \n           /* Emit code for addr_rtx = the ovfl pointer into overflow area.\n \t     Regardless of mips2, postincrement the ovfl pointer by 8. */\n-          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl, \n+          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n \t\tsize_int (8));\n           r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n           if (r != addr_rtx)\n@@ -4590,7 +4599,7 @@ mips_va_arg (valist, type)\n \t      && TREE_CODE (type) == INTEGER_TYPE\n \t      && TYPE_PRECISION (type) == 64)\n \t    {\n-\t      /* In mips2, int takes 32 bits of the GPR save area, but \n+\t      /* In mips2, int takes 32 bits of the GPR save area, but\n \t\t longlong takes an aligned 64 bits.  So, emit code\n \t\t to zero the low order bits of goff, thus aligning\n \t\t the later calculation of (gtop-goff) upwards. */\n@@ -4620,7 +4629,7 @@ mips_va_arg (valist, type)\n \n           /* Emit code for goff = goff - step_size.\n       \t     Advances the offset up GPR save area over the item. */\n-          t = build (MINUS_EXPR, TREE_TYPE (goff), goff, \n+          t = build (MINUS_EXPR, TREE_TYPE (goff), goff,\n \t\tbuild_int_2 (step_size, 0));\n           t = build (MODIFY_EXPR, TREE_TYPE (goff), goff, t);\n           expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -4629,9 +4638,9 @@ mips_va_arg (valist, type)\n           emit_jump (lab_over);\n           emit_barrier ();\n           emit_label (lab_false);\n-\t      \n+\n           /* Emit code for addr_rtx -> overflow area, postinc by step_size */\n-          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl, \n+          t = build (POSTINCREMENT_EXPR, TREE_TYPE(ovfl), ovfl,\n \t    \tsize_int (step_size));\n           r = expand_expr (t, addr_rtx, Pmode, EXPAND_NORMAL);\n           if (r != addr_rtx)\n@@ -4659,7 +4668,7 @@ mips_va_arg (valist, type)\n       /* Not EABI. */\n       int align;\n \n-      /* ??? The original va-mips.h did always align, despite the fact \n+      /* ??? The original va-mips.h did always align, despite the fact\n \t that alignments <= UNITS_PER_WORD are preserved by the va_arg\n \t increment mechanism.  */\n \n@@ -4669,7 +4678,7 @@ mips_va_arg (valist, type)\n \talign = 8;\n       else\n \talign = 4;\n-\t\n+\n       t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n \t\t build_int_2 (align - 1, 0));\n       t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n@@ -4712,7 +4721,7 @@ override_options ()\n \n   /* If both single-float and soft-float are set, then clear the one that\n      was set by TARGET_DEFAULT, leaving the one that was set by the\n-     user.  We assume here that the specs prevent both being set by the \n+     user.  We assume here that the specs prevent both being set by the\n      user. */\n #ifdef TARGET_DEFAULT\n   if (TARGET_SINGLE_FLOAT && TARGET_SOFT_FLOAT)\n@@ -4773,7 +4782,7 @@ override_options ()\n     error (\"bad value (%s) for -mabi= switch\", mips_abi_string);\n \n   /* A specified ISA defaults the ABI if it was not specified.  */\n-  if (mips_abi_string == 0 && mips_isa_string \n+  if (mips_abi_string == 0 && mips_isa_string\n       && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n     {\n       if (! ISA_HAS_64BIT_REGS)\n@@ -4783,7 +4792,7 @@ override_options ()\n     }\n \n   /* A specified ABI defaults the ISA if it was not specified.  */\n-  else if (mips_isa_string == 0 && mips_abi_string \n+  else if (mips_isa_string == 0 && mips_abi_string\n \t   && mips_abi != ABI_EABI && mips_abi != ABI_O64)\n     {\n       if (mips_abi == ABI_32)\n@@ -4829,133 +4838,111 @@ override_options ()\n      greater than that supported by the default processor, then the user gets\n      an error.  Normally, the compiler will just default to the base level cpu\n      for the indicated isa.  */\n-  if (mips_cpu_string == 0)\n-    mips_cpu_string = MIPS_CPU_STRING_DEFAULT;\n+  if (mips_arch_string == 0)\n+    mips_arch_string = MIPS_CPU_STRING_DEFAULT;\n+  if (mips_tune_string == 0)\n+    mips_tune_string = MIPS_CPU_STRING_DEFAULT;\n #endif\n \n   /* Identify the processor type.  */\n-  if (mips_cpu_string == 0\n-      || ! strcmp (mips_cpu_string, \"default\")\n-      || ! strcmp (mips_cpu_string, \"DEFAULT\"))\n+\n+  if (mips_cpu_string != 0)\n+    {\n+      mips_cpu = mips_parse_cpu (mips_cpu_string);\n+      if (mips_cpu == PROCESSOR_DEFAULT)\n+\t{\n+\t  error (\"bad value (%s) for -mcpu= switch\", mips_arch_string);\n+\t  mips_cpu_string = \"default\";\n+\t}\n+      mips_arch = mips_cpu;\n+      mips_tune = mips_cpu;\n+    }\n+\n+  if (mips_arch_string == 0\n+      || ! strcmp (mips_arch_string, \"default\")\n+      || ! strcmp (mips_arch_string, \"DEFAULT\"))\n     {\n       switch (mips_isa)\n \t{\n \tdefault:\n-\t  mips_cpu_string = \"3000\";\n-\t  mips_cpu = PROCESSOR_R3000;\n+\t  mips_arch_string = \"3000\";\n+\t  mips_arch = PROCESSOR_R3000;\n \t  break;\n \tcase 2:\n-\t  mips_cpu_string = \"6000\";\n-\t  mips_cpu = PROCESSOR_R6000;\n+\t  mips_arch_string = \"6000\";\n+\t  mips_arch = PROCESSOR_R6000;\n \t  break;\n \tcase 3:\n-\t  mips_cpu_string = \"4000\";\n-\t  mips_cpu = PROCESSOR_R4000;\n+\t  mips_arch_string = \"4000\";\n+\t  mips_arch = PROCESSOR_R4000;\n \t  break;\n \tcase 4:\n-\t  mips_cpu_string = \"8000\";\n-\t  mips_cpu = PROCESSOR_R8000;\n+\t  mips_arch_string = \"8000\";\n+\t  mips_arch = PROCESSOR_R8000;\n \t  break;\n \t}\n     }\n   else\n     {\n-      const char *p = mips_cpu_string;\n-      int seen_v = 0;\n-\n-      /* We need to cope with the various \"vr\" prefixes for the NEC 4300\n-\t and 4100 processors.  */\n-      if (*p == 'v' || *p == 'V')\n-\tseen_v = 1, p++;\n-\n-      if (*p == 'r' || *p == 'R')\n-\tp++;\n-\n-      /* Since there is no difference between a R2000 and R3000 in\n-\t terms of the scheduler, we collapse them into just an R3000.  */\n-\n-      mips_cpu = PROCESSOR_DEFAULT;\n-      switch (*p)\n+      mips_arch = mips_parse_cpu (mips_arch_string);\n+      if (mips_arch == PROCESSOR_DEFAULT)\n \t{\n-\tcase '2':\n-\t  if (!strcmp (p, \"2000\") || !strcmp (p, \"2k\") || !strcmp (p, \"2K\"))\n-\t    mips_cpu = PROCESSOR_R3000;\n-\t  break;\n-\n-\tcase '3':\n-\t  if (!strcmp (p, \"3000\") || !strcmp (p, \"3k\") || !strcmp (p, \"3K\"))\n-\t    mips_cpu = PROCESSOR_R3000;\n-\t  else if (!strcmp (p, \"3900\"))\n-\t    mips_cpu = PROCESSOR_R3900;\n-\t  break;\n-\n-\tcase '4':\n-\t  if (!strcmp (p, \"4000\") || !strcmp (p, \"4k\") || !strcmp (p, \"4K\"))\n-\t    mips_cpu = PROCESSOR_R4000;\n-          /* The vr4100 is a non-FP ISA III processor with some extra\n-             instructions.  */\n-\t  else if (!strcmp (p, \"4100\"))\n-\t    {\n-              mips_cpu = PROCESSOR_R4100;\n-              target_flags |= MASK_SOFT_FLOAT ;\n-\t    }\n-\t  /* The vr4300 is a standard ISA III processor, but with a different\n-\t     pipeline.  */\n-\t  else if (!strcmp (p, \"4300\"))\n-            mips_cpu = PROCESSOR_R4300;\n-\t  /* The r4400 is exactly the same as the r4000 from the compiler's\n-\t     viewpoint.  */\n-\t  else if (!strcmp (p, \"4400\"))\n-\t    mips_cpu = PROCESSOR_R4000;\n-\t  else if (!strcmp (p, \"4600\"))\n-\t    mips_cpu = PROCESSOR_R4600;\n-\t  else if (!strcmp (p, \"4650\"))\n-\t    mips_cpu = PROCESSOR_R4650;\n-\t  break;\n-\n-\tcase '5':\n-\t  if (!strcmp (p, \"5000\") || !strcmp (p, \"5k\") || !strcmp (p, \"5K\"))\n-\t    mips_cpu = PROCESSOR_R5000;\n+\t  error (\"bad value (%s) for -march= switch\", mips_arch_string);\n+\t  mips_arch_string = \"default\";\n+\t}\n+    }\n+  if (mips_tune_string == 0\n+      || ! strcmp (mips_tune_string, \"default\")\n+      || ! strcmp (mips_tune_string, \"DEFAULT\"))\n+    {\n+      if (mips_arch != PROCESSOR_DEFAULT)\n+\tmips_tune == mips_arch;\n+      else\n+      switch (mips_isa)\n+\t{\n+\tdefault:\n+\t  mips_tune_string = \"3000\";\n+\t  mips_tune = PROCESSOR_R3000;\n \t  break;\n-\n-\tcase '6':\n-\t  if (!strcmp (p, \"6000\") || !strcmp (p, \"6k\") || !strcmp (p, \"6K\"))\n-\t    mips_cpu = PROCESSOR_R6000;\n+\tcase 2:\n+\t  mips_tune_string = \"6000\";\n+\t  mips_tune = PROCESSOR_R6000;\n \t  break;\n-\n-\tcase '8':\n-\t  if (!strcmp (p, \"8000\"))\n-\t    mips_cpu = PROCESSOR_R8000;\n+\tcase 3:\n+\t  mips_tune_string = \"4000\";\n+\t  mips_tune = PROCESSOR_R4000;\n \t  break;\n-\n-\tcase 'o':\n-\t  if (!strcmp (p, \"orion\"))\n-\t    mips_cpu = PROCESSOR_R4600;\n+\tcase 4:\n+\t  mips_tune_string = \"8000\";\n+\t  mips_tune = PROCESSOR_R8000;\n \t  break;\n \t}\n \n-      if (seen_v\n-\t  && mips_cpu != PROCESSOR_R4300\n-\t  && mips_cpu != PROCESSOR_R4100\n-\t  && mips_cpu != PROCESSOR_R5000)\n-\tmips_cpu = PROCESSOR_DEFAULT;\n-\n-      if (mips_cpu == PROCESSOR_DEFAULT)\n+    }\n+  else\n+    {\n+       mips_tune = mips_parse_cpu (mips_tune_string);\n+      if (mips_tune == PROCESSOR_DEFAULT)\n \t{\n-\t  error (\"bad value (%s) for -mcpu= switch\", mips_cpu_string);\n-\t  mips_cpu_string = \"default\";\n+\t  error (\"bad value (%s) for -mtune= switch\", mips_tune_string);\n+\t  mips_tune_string = \"default\";\n \t}\n     }\n \n-  if ((mips_cpu == PROCESSOR_R3000 && (mips_isa != 1))\n-      || (mips_cpu == PROCESSOR_R6000 && mips_isa != 1 && mips_isa != 2)\n-      || ((mips_cpu == PROCESSOR_R4000\n-           || mips_cpu == PROCESSOR_R4100\n-           || mips_cpu == PROCESSOR_R4300\n-\t   || mips_cpu == PROCESSOR_R4600\n-\t   || mips_cpu == PROCESSOR_R4650)\n+   /* Handle processor configuration based on architecture.  */\n+   if (TARGET_MIPS4100 || TARGET_MIPS3900)\n+     target_flags |= MASK_SOFT_FLOAT;\n+\n+\n+  if ((mips_arch == PROCESSOR_R3000 && (mips_isa != 1))\n+      || (mips_arch == PROCESSOR_R6000 && mips_isa != 1 && mips_isa != 2)\n+      || ((mips_arch == PROCESSOR_R4000\n+           || mips_arch == PROCESSOR_R4100\n+           || mips_arch == PROCESSOR_R4300\n+\t   || mips_arch == PROCESSOR_R4600\n+\t   || mips_arch == PROCESSOR_R4650)\n \t  && mips_isa != 1 && mips_isa != 2 && mips_isa != 3))\n-    error (\"-mcpu=%s does not support -mips%d\", mips_cpu_string, mips_isa);\n+    error (\"-march=%s does not support -mips%d\", mips_arch_string, mips_isa);\n \n   /* make sure sizes of ints/longs/etc. are ok */\n   if (! ISA_HAS_64BIT_REGS)\n@@ -5185,11 +5172,11 @@ override_options ()\n   /* Provide default values for align_* for 64-bit targets.  */\n   if (TARGET_64BIT && !TARGET_MIPS16)\n     {\n-      if (align_loops == 0) \n+      if (align_loops == 0)\n \talign_loops = 8;\n-      if (align_jumps == 0) \n+      if (align_jumps == 0)\n \talign_jumps = 8;\n-      if (align_functions == 0) \n+      if (align_functions == 0)\n \talign_functions = 8;\n     }\n \n@@ -5407,7 +5394,7 @@ print_operand (file, op, letter)\n \t    fputs (\".set\\tnoat\\n\\t\", file);\n \t  break;\n \n-\tcase ']': \n+\tcase ']':\n \t  if (set_noat == 0)\n \t    error (\"internal error: %%] found without a %%[ in assembler pattern\");\n \t  else if (--set_noat == 0)\n@@ -5880,14 +5867,14 @@ mips_output_lineno (stream, line)\n       fprintf (stream, \"\\n\\t%s.loc\\t%d %d\\n\",\n \t       (ignore_line_number) ? \"#\" : \"\",\n \t       num_source_filenames, line);\n-  \n+\n       LABEL_AFTER_LOC (stream);\n     }\n }\n \f\n /* Output an ASCII string, in a space-saving way.  */\n \n-void \n+void\n mips_output_ascii (stream, string_param, len)\n      FILE *stream;\n      const char *string_param;\n@@ -5898,70 +5885,70 @@ mips_output_ascii (stream, string_param, len)\n   register const unsigned char *string =\n     (const unsigned char *)string_param;\n \n-  fprintf (stream, \"\\t.ascii\\t\\\"\");\t\t\t\t\t\n-  for (i = 0; i < len; i++)\t\t\t\t\t\t\n-    {\t\t\t\t\t\t\t\t\t\n-      register int c = string[i];\t\t\t\t\t\n-      \n-      switch (c)\t\t\t\t\t\t\t\n-\t{\t\t\t\t\t\t\t\t\n-\tcase '\\\"':\t\t\t\t\t\t\t\n-\tcase '\\\\':\t\t\t\t\t\t\t\n-\t  putc ('\\\\', stream);\t\t\t\t\t\n-\t  putc (c, stream);\t\t\t\t\t\t\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tcase TARGET_NEWLINE:\t\t\t\t\t\t\n-\t  fputs (\"\\\\n\", stream);\t\t\t\t\t\n-\t  if (i+1 < len\t\t\t\t\t\t\t\n-\t      && (((c = string[i+1]) >= '\\040' && c <= '~')\t\t\n-\t\t  || c == TARGET_TAB))\t\t\t\t\t\n-\t    cur_pos = 32767;\t\t/* break right here */\t\t\n-\t  else\t\t\t\t\t\t\t\t\n-\t    cur_pos += 2;\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tcase TARGET_TAB:\t\t\t\t\t\t\n-\t  fputs (\"\\\\t\", stream);\t\t\t\t\t\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tcase TARGET_FF:\t\t\t\t\t\t\t\n-\t  fputs (\"\\\\f\", stream);\t\t\t\t\t\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tcase TARGET_BS:\t\t\t\t\t\t\t\n-\t  fputs (\"\\\\b\", stream);\t\t\t\t\t\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tcase TARGET_CR:\t\t\t\t\t\t\t\n-\t  fputs (\"\\\\r\", stream);\t\t\t\t\t\n-\t  cur_pos += 2;\t\t\t\t\t\t\t\n-\t  break;\t\t\t\t\t\t\t\n-\t  \n-\tdefault:\t\t\t\t\t\t\t\n-\t  if (c >= ' ' && c < 0177)\t\t\t\t\t\n-\t    {\t\t\t\t\t\t\t\t\n-\t      putc (c, stream);\t\t\t\t\t\n-\t      cur_pos++;\t\t\t\t\t\t\n-\t    }\t\t\t\t\t\t\t\t\n-\t  else\t\t\t\t\t\t\t\t\n-\t    {\t\t\t\t\t\t\t\t\n-\t      fprintf (stream, \"\\\\%03o\", c);\t\t\t\t\n-\t      cur_pos += 4;\t\t\t\t\t\t\n-\t    }\t\t\t\t\t\t\t\t\n-\t}\t\t\t\t\t\t\t\t\n-      \n-      if (cur_pos > 72 && i+1 < len)\t\t\t\t\t\n-\t{\t\t\t\t\t\t\t\t\n-\t  cur_pos = 17;\t\t\t\t\t\t\t\n-\t  fprintf (stream, \"\\\"\\n\\t.ascii\\t\\\"\");\t\t\t\n-\t}\t\t\t\t\t\t\t\t\n-    }\t\t\t\t\t\t\t\t\t\n-  fprintf (stream, \"\\\"\\n\");\t\t\t\t\t\t\n+  fprintf (stream, \"\\t.ascii\\t\\\"\");\n+  for (i = 0; i < len; i++)\n+    {\n+      register int c = string[i];\n+\n+      switch (c)\n+\t{\n+\tcase '\\\"':\n+\tcase '\\\\':\n+\t  putc ('\\\\', stream);\n+\t  putc (c, stream);\n+\t  cur_pos += 2;\n+\t  break;\n+\n+\tcase TARGET_NEWLINE:\n+\t  fputs (\"\\\\n\", stream);\n+\t  if (i+1 < len\n+\t      && (((c = string[i+1]) >= '\\040' && c <= '~')\n+\t\t  || c == TARGET_TAB))\n+\t    cur_pos = 32767;\t\t/* break right here */\n+\t  else\n+\t    cur_pos += 2;\n+\t  break;\n+\n+\tcase TARGET_TAB:\n+\t  fputs (\"\\\\t\", stream);\n+\t  cur_pos += 2;\n+\t  break;\n+\n+\tcase TARGET_FF:\n+\t  fputs (\"\\\\f\", stream);\n+\t  cur_pos += 2;\n+\t  break;\n+\n+\tcase TARGET_BS:\n+\t  fputs (\"\\\\b\", stream);\n+\t  cur_pos += 2;\n+\t  break;\n+\n+\tcase TARGET_CR:\n+\t  fputs (\"\\\\r\", stream);\n+\t  cur_pos += 2;\n+\t  break;\n+\n+\tdefault:\n+\t  if (c >= ' ' && c < 0177)\n+\t    {\n+\t      putc (c, stream);\n+\t      cur_pos++;\n+\t    }\n+\t  else\n+\t    {\n+\t      fprintf (stream, \"\\\\%03o\", c);\n+\t      cur_pos += 4;\n+\t    }\n+\t}\n+\n+      if (cur_pos > 72 && i+1 < len)\n+\t{\n+\t  cur_pos = 17;\n+\t  fprintf (stream, \"\\\"\\n\\t.ascii\\t\\\"\");\n+\t}\n+    }\n+  fprintf (stream, \"\\\"\\n\");\n }\n \f\n /* If defined, a C statement to be executed just prior to the output of\n@@ -6068,9 +6055,9 @@ mips_asm_file_start (stream)\n     asm_out_data_file = asm_out_text_file = stream;\n \n   if (flag_verbose_asm)\n-    fprintf (stream, \"\\n%s -G value = %d, Cpu = %s, ISA = %d\\n\",\n+    fprintf (stream, \"\\n%s -G value = %d, Arch = %s, ISA = %d\\n\",\n \t     ASM_COMMENT_START,\n-\t     mips_section_threshold, mips_cpu_string, mips_isa);\n+\t     mips_section_threshold, mips_arch_string, mips_isa);\n }\n \f\n /* If we are optimizing the global pointer, emit the text section now and any\n@@ -6117,7 +6104,7 @@ mips_asm_file_end (file)\n \t    }\n \t}\n     }\n-      \n+\n   if (TARGET_FILE_SWITCHING && ! TARGET_MIPS16)\n     {\n       fprintf (file, \"\\n\\t.text\\n\");\n@@ -6373,7 +6360,7 @@ compute_frame_size (size)\n      The gp reg is callee saved in the 64 bit ABI, so all routines must\n      save the gp reg.  This is not a leaf routine if -p, because of the\n      call to mcount.  */\n-  if (total_size == extra_size \n+  if (total_size == extra_size\n       && (mips_abi == ABI_32 || mips_abi == ABI_O64 || mips_abi == ABI_EABI)\n       && ! profile_flag)\n     total_size = extra_size = 0;\n@@ -6646,7 +6633,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t    insn = emit_move_insn (mem_rtx, reg_rtx);\n \t\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t\t  }\n-\t\telse if (!TARGET_ABICALLS \n+\t\telse if (!TARGET_ABICALLS\n \t\t\t || (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \t\t\t || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t  {\n@@ -6660,7 +6647,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t      }\n \t    else\n \t      {\n-\t\tif (store_p || !TARGET_ABICALLS \n+\t\tif (store_p || !TARGET_ABICALLS\n \t\t    || (mips_abi != ABI_32 && mips_abi != ABI_O64)\n \t\t    || regno != (PIC_OFFSET_TABLE_REGNUM - GP_REG_FIRST))\n \t\t  {\n@@ -6690,7 +6677,7 @@ save_restore_insns (store_p, large_reg, large_offset, file)\n \t\t\t      ? (store_p) ? \"sd\" : \"ld\"\n \t\t\t      : (store_p) ? \"sw\" : \"lw\"),\n \t\t\t     reg_names[r]);\n-\t\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC, \n+\t\t    fprintf (file, HOST_WIDE_INT_PRINT_DEC,\n \t\t\t     gp_offset - base_offset);\n \t\t    fprintf (file, \"(%s)\\n\", reg_names[REGNO(base_reg_rtx)]);\n \t\t    if (! store_p\n@@ -7103,10 +7090,10 @@ mips_expand_prologue ()\n \n   /* For arguments passed in registers, find the register number\n      of the first argument in the variable part of the argument list,\n-     otherwise GP_ARG_LAST+1.  Note also if the last argument is \n+     otherwise GP_ARG_LAST+1.  Note also if the last argument is\n      the varargs special argument, and treat it as part of the\n      variable arguments.\n-     \n+\n      This is only needed if store_args_on_stack is true. */\n \n   INIT_CUMULATIVE_ARGS (args_so_far, fntype, NULL_RTX, 0);\n@@ -7602,7 +7589,7 @@ mips_expand_epilogue ()\n \t\t\t\t\t   g6_rtx));\n \t\t  tsize = 0;\n \t\t}\n-\t      \n+\n \t      if (tsize && tsize != orig_tsize)\n \t\ttsize_rtx = GEN_INT (tsize);\n \t    }\n@@ -7705,7 +7692,7 @@ symbolic_expression_p (x)\n \n   if (GET_CODE (x) == CONST)\n     return symbolic_expression_p (XEXP (x, 0));\n-  \n+\n   if (GET_RTX_CLASS (GET_CODE (x)) == '1')\n     return symbolic_expression_p (XEXP (x, 0));\n \n@@ -7742,7 +7729,7 @@ mips_select_rtx_section (mode, x)\n     {\n       /* For hosted applications, always put constants in small data if\n \t possible, as this gives the best performance.  */\n-     \n+\n       if (GET_MODE_SIZE (mode) <= (unsigned) mips_section_threshold\n \t  && mips_section_threshold > 0)\n \tSMALL_DATA_SECTION ();\n@@ -7863,8 +7850,8 @@ mips_function_value (valtype, func)\n     }\n \n   else if (TREE_CODE (valtype) == RECORD_TYPE\n-\t   && mips_abi != ABI_32 \n-\t   && mips_abi != ABI_O64 \n+\t   && mips_abi != ABI_32\n+\t   && mips_abi != ABI_O64\n \t   && mips_abi != ABI_EABI)\n     {\n       /* A struct with only one or two floating point fields is returned in\n@@ -7883,7 +7870,7 @@ mips_function_value (valtype, func)\n \n \t  fields[i++] = field;\n \t}\n-\t  \n+\n       /* Must check i, so that we reject structures with no elements.  */\n       if (! field)\n \t{\n@@ -7954,8 +7941,8 @@ function_arg_pass_by_reference (cum, mode, type, named)\n      here hopefully is not relevant to mips_va_arg.  */\n   if (cum && MUST_PASS_IN_STACK (mode, type))\n      {\n-       /* Don't pass the actual CUM to FUNCTION_ARG, because we would \n-\t  get double copies of any offsets generated for small structs \n+       /* Don't pass the actual CUM to FUNCTION_ARG, because we would\n+\t  get double copies of any offsets generated for small structs\n \t  passed in registers. */\n        CUMULATIVE_ARGS temp;\n        temp = *cum;\n@@ -8569,7 +8556,7 @@ build_mips16_call_stub (retval, fnmem, arg_size, fp_code)\n       && strncmp (XSTR (fn, 0), \"__mips16_\", 9) == 0)\n     return 0;\n \n-  /* This code will only work for o32 and o64 abis.  The other ABI's \n+  /* This code will only work for o32 and o64 abis.  The other ABI's\n      require more sophisticated support.  */\n   if (mips_abi != ABI_32 && mips_abi != ABI_O64)\n     abort ();\n@@ -9000,7 +8987,7 @@ mips16_optimize_gp (first)\n \t      emit_insn_after (gen_rtx (SET, VOIDmode, SET_DEST (set1),\n \t\t\t\t\tforce_const_mem (Pmode, sym)),\n \t\t\t       next);\n-\t      \n+\n \t      PUT_CODE (insn, NOTE);\n \t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t      NOTE_SOURCE_FILE (insn) = 0;\n@@ -9365,10 +9352,10 @@ machine_dependent_reorg (first)\n \t  constants = NULL;\n \t  first_constant_ref = -1;\n \t}\n-      \n+\n       if (constants != NULL\n-\t       && (NEXT_INSN (insn) == NULL \n-\t\t   || (first_constant_ref >= 0 \n+\t       && (NEXT_INSN (insn) == NULL\n+\t\t   || (first_constant_ref >= 0\n \t\t       && (((addr - first_constant_ref)\n \t\t\t    + 2 /* for alignment */\n \t\t\t    + 2 /* for a short jump insn */\n@@ -9380,7 +9367,7 @@ machine_dependent_reorg (first)\n              emit a barrier now. */\n \n \t  rtx label, jump, barrier;\n-\t      \n+\n \t  label = gen_label_rtx ();\n \t  jump = emit_jump_insn_after (gen_jump (label), insn);\n \t  JUMP_LABEL (jump) = label;\n@@ -9422,7 +9409,7 @@ highpart_shift_operator (x, mode)\n \t  || code == ROTATE);\n }\n \n-/* Return the length of INSN.  LENGTH is the initial length computed by \n+/* Return the length of INSN.  LENGTH is the initial length computed by\n    attributes in the machine-description file.  */\n \n int\n@@ -9434,7 +9421,7 @@ mips_adjust_insn_length (insn, length)\n      of a sequence.  A conditional jump normally has a delay slot, but\n      does not on MIPS16.  */\n   if (simplejump_p (insn)\n-      || (!TARGET_MIPS16  && (GET_CODE (insn) == JUMP_INSN \n+      || (!TARGET_MIPS16  && (GET_CODE (insn) == JUMP_INSN\n \t\t\t      || GET_CODE (insn) == CALL_INSN)))\n     length += 4;\n \n@@ -9445,7 +9432,7 @@ mips_adjust_insn_length (insn, length)\n   return length;\n }\n \n-/* Output assembly instructions to peform a conditional branch.  \n+/* Output assembly instructions to peform a conditional branch.\n \n    INSN is the branch instruction.  OPERANDS[0] is the condition.\n    OPERANDS[1] is the target of the branch.  OPERANDS[2] is the target\n@@ -9460,8 +9447,8 @@ mips_adjust_insn_length (insn, length)\n    That tells us whether to generate a simple conditional branch, or a\n    reversed conditional branch around a `jr' instruction.  */\n char *\n-mips_output_conditional_branch (insn, \n-\t\t\t\toperands, \n+mips_output_conditional_branch (insn,\n+\t\t\t\toperands,\n \t\t\t\ttwo_operands_p,\n \t\t\t\tfloat_p,\n \t\t\t\tinverted_p,\n@@ -9537,7 +9524,7 @@ mips_output_conditional_branch (insn,\n      equality comparisons are done between two operands, and therefore\n      do not require a `z' in the assembly language output.  */\n   need_z_p = (!float_p && code != EQ && code != NE);\n-  /* For comparisons against zero, the zero is not provided \n+  /* For comparisons against zero, the zero is not provided\n      explicitly.  */\n   if (need_z_p)\n     op2 = \"\";\n@@ -9546,7 +9533,7 @@ mips_output_conditional_branch (insn,\n      strcat to add to it.  */\n   buffer[0] = '\\0';\n \n-  switch (length) \n+  switch (length)\n     {\n     case 4:\n     case 8:\n@@ -9585,18 +9572,18 @@ mips_output_conditional_branch (insn,\n \t   wait until the next instruction is output; it might be a\n \t   macro and take up more than four bytes.  Once again, we see\n \t   why we want to eliminate macros.)\n-\t   \n+\n \t   If the branch is annulled, we jump four more bytes that we\n \t   would otherwise; that way we skip the annulled instruction\n \t   in the delay slot.  */\n \n-\tconst char *target \n+\tconst char *target\n \t  = ((mips_branch_likely || length == 16) ? \".+16\" : \".+12\");\n \tchar *c;\n \n \tstrcpy (buffer, \"%(%<\");\n \tc = strchr (buffer, '\\0');\n-\t/* Generate the reversed comparision.  This takes four \n+\t/* Generate the reversed comparision.  This takes four\n \t   bytes.  */\n \tif (float_p)\n \t  sprintf (c, \"%%*b%s\\t%%Z2%s\",\n@@ -9652,7 +9639,7 @@ mips_output_conditional_branch (insn,\n \t   generate only a four-byte sequence, rather than eight, and\n \t   there seems to be no way to tell it not to.  Thus, we can't\n \t   just use a `.+x' addressing form; we don't know what value\n-\t   to give for `x'.  \n+\t   to give for `x'.\n \n \t   So, we resort to using the explicit relocation syntax\n \t   available in the assembler and do:\n@@ -9667,15 +9654,15 @@ mips_output_conditional_branch (insn,\n \t   anything.  */\n \n \t/* The target of the reversed branch.  */\n-\tconst char *target \n+\tconst char *target\n \t  = ((mips_branch_likely || length == 20) ? \".+20\" : \".+16\");\n \tconst char *at_register = mips_reg_names[ASSEMBLER_SCRATCH_REGNUM];\n \tconst char *gp_register = mips_reg_names[PIC_OFFSET_TABLE_REGNUM];\n \tchar *c;\n \n \tstrcpy (buffer, \"%(%<%[\");\n \tc = strchr (buffer, '\\0');\n-\t/* Generate the reversed comparision.  This takes four \n+\t/* Generate the reversed comparision.  This takes four\n \t   bytes.  */\n \tif (float_p)\n \t  sprintf (c, \"%%*b%s\\t%%Z2%s\",\n@@ -9730,3 +9717,88 @@ mips_add_gc_roots ()\n   ggc_add_rtx_root (&embedded_pic_fnaddr_rtx, 1);\n   ggc_add_rtx_root (&mips16_gp_pseudo_rtx, 1);\n }\n+\n+static enum processor_type\n+mips_parse_cpu (cpu_string)\n+     const char *cpu_string;\n+{\n+  const char *p = cpu_string;\n+  int seen_v = 0;\n+  enum processor_type cpu;\n+\n+  /* We need to cope with the various \"vr\" prefixes for the NEC 4300\n+     and 4100 processors.  */\n+  if (*p == 'v' || *p == 'V')\n+    seen_v = 1, p++;\n+\n+  if (*p == 'r' || *p == 'R')\n+    p++;\n+\n+  /* Since there is no difference between a R2000 and R3000 in\n+     terms of the scheduler, we collapse them into just an R3000.  */\n+\n+  cpu = PROCESSOR_DEFAULT;\n+  switch (*p)\n+    {\n+    case '2':\n+      if (!strcmp (p, \"2000\") || !strcmp (p, \"2k\") || !strcmp (p, \"2K\"))\n+\tcpu = PROCESSOR_R3000;\n+      break;\n+\n+    case '3':\n+      if (!strcmp (p, \"3000\") || !strcmp (p, \"3k\") || !strcmp (p, \"3K\"))\n+\tcpu = PROCESSOR_R3000;\n+      else if (!strcmp (p, \"3900\"))\n+\tcpu = PROCESSOR_R3900;\n+      break;\n+\n+    case '4':\n+      if (!strcmp (p, \"4000\") || !strcmp (p, \"4k\") || !strcmp (p, \"4K\"))\n+\tcpu = PROCESSOR_R4000;\n+      /* The vr4100 is a non-FP ISA III processor with some extra\n+\t instructions.  */\n+      else if (!strcmp (p, \"4100\"))\n+\t  cpu = PROCESSOR_R4100;\n+      /* The vr4300 is a standard ISA III processor, but with a different\n+\t pipeline.  */\n+      else if (!strcmp (p, \"4300\"))\n+\tcpu = PROCESSOR_R4300;\n+      /* The r4400 is exactly the same as the r4000 from the compiler's\n+\t viewpoint.  */\n+      else if (!strcmp (p, \"4400\"))\n+\tcpu = PROCESSOR_R4000;\n+      else if (!strcmp (p, \"4600\"))\n+\tcpu = PROCESSOR_R4600;\n+      else if (!strcmp (p, \"4650\"))\n+\tcpu = PROCESSOR_R4650;\n+      break;\n+\n+    case '5':\n+      if (!strcmp (p, \"5000\") || !strcmp (p, \"5k\") || !strcmp (p, \"5K\"))\n+\tcpu = PROCESSOR_R5000;\n+      break;\n+\n+    case '6':\n+      if (!strcmp (p, \"6000\") || !strcmp (p, \"6k\") || !strcmp (p, \"6K\"))\n+\tcpu = PROCESSOR_R6000;\n+      break;\n+\n+    case '8':\n+      if (!strcmp (p, \"8000\"))\n+\tcpu = PROCESSOR_R8000;\n+      break;\n+\n+    case 'o':\n+      if (!strcmp (p, \"orion\"))\n+\tcpu = PROCESSOR_R4600;\n+      break;\n+    }\n+\n+  if (seen_v\n+      && cpu != PROCESSOR_R4300\n+      && cpu != PROCESSOR_R4100\n+      && cpu != PROCESSOR_R5000)\n+    cpu = PROCESSOR_DEFAULT;\n+\n+  return cpu;\n+}"}, {"sha": "453396e207f82fec4e5544b31adfa5799738c99e", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 103, "deletions": 74, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -133,13 +133,17 @@ extern int mips_branch_likely;\t\t/* emit 'l' after br (branch likely) */\n extern int mips_dbx_regno[];\t\t/* Map register # to debug register # */\n extern struct rtx_def *branch_cmp[2];\t/* operands for compare */\n extern enum cmp_type branch_type;\t/* what type of branch to use */\n-extern enum processor_type mips_cpu;\t/* which cpu are we scheduling for */\n+extern enum processor_type mips_arch;   /* which cpu to codegen for */\n+extern enum processor_type mips_tune;   /* which cpu to schedule for */\n+extern enum processor_type mips_cpu;\t/* historical codegen/sched */\n extern enum mips_abicalls_type mips_abicalls;/* for svr4 abi pic calls */\n extern int mips_isa;\t\t\t/* architectural level */\n extern int mips16;\t\t\t/* whether generating mips16 code */\n extern int mips16_hard_float;\t\t/* mips16 without -msoft-float */\n extern int mips_entry;\t\t\t/* generate entry/exit for mips16 */\n extern const char *mips_cpu_string;\t/* for -mcpu=<xxx> */\n+extern const char *mips_arch_string;    /* for -march=<xxx> */\n+extern const char *mips_tune_string;    /* for -mtune=<xxx> */\n extern const char *mips_isa_string;\t/* for -mips{1,2,3,4} */\n extern const char *mips_abi_string;\t/* for -mabi={32,n32,64} */\n extern const char *mips_entry_string;\t/* for -mentry */\n@@ -212,14 +216,13 @@ extern void\t\tsbss_section PARAMS ((void));\n #define MASK_SINGLE_FLOAT  0x00020000\t/* Only single precision FPU.  */\n #define MASK_MAD\t   0x00040000\t/* Generate mad/madu as on 4650.  */\n #define MASK_4300_MUL_FIX  0x00080000   /* Work-around early Vr4300 CPU bug */\n-#define MASK_MIPS3900\t   0x00100000\t/* like -mips1 only 3900 */\n-#define MASK_MIPS16\t   0x00200000\t/* Generate mips16 code */\n+#define MASK_MIPS16\t   0x00100000\t/* Generate mips16 code */\n #define MASK_NO_CHECK_ZERO_DIV \\\n-\t\t\t   0x00400000\t/* divide by zero checking */\n+\t\t\t   0x00200000\t/* divide by zero checking */\n #define MASK_CHECK_RANGE_DIV \\\n-\t\t\t   0x00800000\t/* divide result range checking */\n+\t\t\t   0x00400000\t/* divide result range checking */\n #define MASK_UNINIT_CONST_IN_RODATA \\\n-\t\t\t   0x01000000\t/* Store uninitialized\n+\t\t\t   0x00800000\t/* Store uninitialized\n \t\t\t\t\t   consts in rodata */\n \n \t\t\t\t\t/* Debug switches, not documented */\n@@ -246,9 +249,6 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t/* Mips vs. GNU linker */\n #define TARGET_SPLIT_ADDRESSES\t(target_flags & MASK_SPLIT_ADDR)\n \n-/* generate mips 3900 insns */\n-#define TARGET_MIPS3900         (target_flags & MASK_MIPS3900)\n-\n \t\t\t\t\t/* Mips vs. GNU assembler */\n #define TARGET_GAS\t\t(target_flags & MASK_GAS)\n #define TARGET_MIPS_AS\t\t(!TARGET_GAS)\n@@ -330,6 +330,19 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t\t\t/* Generate mips16 code */\n #define TARGET_MIPS16\t\t(target_flags & MASK_MIPS16)\n \n+/* Architecture target defines.  */\n+#define TARGET_MIPS3900             (mips_arch == PROCESSOR_R3900)\n+#define TARGET_MIPS4000             (mips_arch == PROCESSOR_R4000)\n+#define TARGET_MIPS4100             (mips_arch == PROCESSOR_R4100)\n+#define TARGET_MIPS4300             (mips_arch == PROCESSOR_R4300)\n+\n+/* Scheduling target defines.  */\n+#define TUNE_MIPS3000               (mips_cpu == PROCESSOR_R3000)\n+#define TUNE_MIPS3900               (mips_cpu == PROCESSOR_R3900)\n+#define TUNE_MIPS4000               (mips_cpu == PROCESSOR_R4000)\n+#define TUNE_MIPS5000               (mips_cpu == PROCESSOR_R5000)\n+#define TUNE_MIPS6000               (mips_cpu == PROCESSOR_R6000)\n+\n /* Macro to define tables used to set the flags.\n    This is a list in braces of pairs in braces,\n    each pair being { \"NAME\", VALUE }\n@@ -430,10 +443,10 @@ extern void\t\tsbss_section PARAMS ((void));\n      N_(\"Work around early 4300 hardware bug\")},\t\t\t\\\n   {\"no-fix4300\",         -MASK_4300_MUL_FIX,\t\t\t\t\\\n      N_(\"Don't work around early 4300 hardware bug\")},\t\t\t\\\n-  {\"4650\",\t\t  MASK_MAD | MASK_SINGLE_FLOAT,\t\t\t\\\n-     N_(\"Optimize for 4650\")},\t\t\t\t\t\t\\\n-  {\"3900\",\t\t  MASK_MIPS3900,\t\t\t\t\\\n+  {\"3900\",\t\t  0,\t\t\t\t                \\\n      N_(\"Optimize for 3900\")},\t\t\t\t\t\t\\\n+  {\"4650\",\t\t  0,                    \t\t\t\\\n+     N_(\"Optimize for 4650\")},\t\t\t\t\t\t\\\n   {\"check-zero-division\",-MASK_NO_CHECK_ZERO_DIV,\t\t\t\\\n      N_(\"Trap on integer divide by zero\")},\t\t\t\t\\\n   {\"no-check-zero-division\", MASK_NO_CHECK_ZERO_DIV,\t\t\t\\\n@@ -466,7 +479,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \t\t\t   | TARGET_CPU_DEFAULT\t\t\t\t\\\n \t\t\t   | TARGET_ENDIAN_DEFAULT),\t\t\t\\\n      NULL},\t\t\t\t\t\t\t\t\\\n-}     \n+}\n \n /* Default target_flags if no switches are specified  */\n \n@@ -550,7 +563,7 @@ extern void\t\tsbss_section PARAMS ((void));\n    initializer with a subgrouping for each command option.\n \n    Each subgrouping contains a string constant, that defines the\n-   fixed part of the option name, and the address of a variable. \n+   fixed part of the option name, and the address of a variable.\n    The variable, type `char *', is set to the variable part of the\n    given option if the fixed part matches.  The actual option name\n    is made by appending `-m' to the specified name.\n@@ -567,8 +580,12 @@ extern void\t\tsbss_section PARAMS ((void));\n   SUBTARGET_TARGET_OPTIONS\t\t\t\t\t\t\\\n   { \"cpu=\",\t&mips_cpu_string,\t\t\t\t\t\\\n       N_(\"Specify CPU for scheduling purposes\")},\t\t\t\\\n+  { \"tune=\",    &mips_tune_string,                                   \\\n+      N_(\"Specify CPU for scheduling purposes\")},                       \\\n+  { \"arch=\",    &mips_arch_string,                                      \\\n+      N_(\"Specify CPU for code generation purposes\")},                  \\\n   { \"ips\",\t&mips_isa_string,\t\t\t\t\t\\\n-      N_(\"Specify MIPS ISA\")},\t\t\t\t\t\t\\\n+      N_(\"Specify a Standard MIPS ISA\")},\t\t\t\t\\\n   { \"entry\",\t&mips_entry_string,\t\t\t\t\t\\\n       N_(\"Use mips16 entry/exit psuedo ops\")},\t\t\t\t\\\n   { \"no-mips16\", &mips_no_mips16_string,\t\t\t\t\\\n@@ -580,7 +597,7 @@ extern void\t\tsbss_section PARAMS ((void));\n /* This is meant to be redefined in the host dependent files.  */\n #define SUBTARGET_TARGET_OPTIONS\n \n-#define GENERATE_BRANCHLIKELY  (!TARGET_MIPS16 && (TARGET_MIPS3900 || ISA_HAS_BRANCHLIKELY))\n+#define GENERATE_BRANCHLIKELY  (!TARGET_MIPS16 && ISA_HAS_BRANCHLIKELY)\n \n /* Generate three-operand multiply instructions for both SImode and DImode.  */\n #define GENERATE_MULT3         (TARGET_MIPS3900\t\t\t\t\\\n@@ -596,8 +613,11 @@ extern void\t\tsbss_section PARAMS ((void));\n #define ISA_HAS_64BIT_REGS\t(mips_isa == 3 || mips_isa == 4 \t\\\n                                 )\n \n-/* ISA has branch likely instructions (eg. mips2). */ \n-#define ISA_HAS_BRANCHLIKELY\t(mips_isa != 1)\n+/* ISA has branch likely instructions (eg. mips2). */\n+/* Disable branchlikely for tx39 until compare rewrite.  They haven't\n+   been generated up to this point.  */\n+#define ISA_HAS_BRANCHLIKELY\t(mips_isa != 1                          \\\n+\t\t\t\t /* || TARGET_MIPS3900 */)\n \n /* ISA has the conditional move instructions introduced in mips4. */\n #define ISA_HAS_CONDMOVE        (mips_isa == 4\t\t\t\t\\\n@@ -615,7 +635,7 @@ extern void\t\tsbss_section PARAMS ((void));\n \n \n /* This is a catch all for the other new mips4 instructions: indexed load and\n-   indexed prefetch instructions, the FP madd,msub,nmadd, and nmsub instructions, \n+   indexed prefetch instructions, the FP madd,msub,nmadd, and nmsub instructions,\n    and the FP recip and recip sqrt instructions */\n #define ISA_HAS_FP4             (mips_isa == 4\t\t\t\t\\\n \t\t\t\t)\n@@ -791,7 +811,7 @@ while (0)\n /* GAS_ASM_SPEC is passed when using gas, rather than the MIPS\n    assembler.  */\n \n-#define GAS_ASM_SPEC \"%{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64}\"\n+#define GAS_ASM_SPEC \"%{march=*} %{mtune=*} %{mcpu=*} %{m4650} %{mmad:-m4650} %{m3900} %{v} %{mgp32} %{mgp64}\"\n \n /* TARGET_ASM_SPEC is used to select either MIPS_AS_ASM_SPEC or\n    GAS_ASM_SPEC as the default, depending upon the value of\n@@ -909,6 +929,16 @@ while (0)\n #define SUBTARGET_CC1_SPEC \"\"\n #endif\n \n+/* Deal with historic options.  */\n+#ifndef CC1_CPU_SPEC\n+#define CC1_CPU_SPEC \"\\\n+%{!mcpu*: \\\n+%{m3900:-march=r3900 -mips1 -mfp32 -mgp32 \\\n+%n`-m3900' is deprecated. Use `-march=r3900' instead.\\n} \\\n+%{m4650:-march=r4650 -mmad -msingle-float \\\n+%n`-m4650' is deprecated. Use `-march=r4650' instead.\\n}}\"\n+#endif\n+\n /* CC1_SPEC is the set of arguments to pass to the compiler proper.  */\n \n #ifndef CC1_SPEC\n@@ -920,15 +950,14 @@ while (0)\n %{mfp64:%{msingle-float:%emay not use both -mfp64 and -msingle-float}} \\\n %{mfp64:%{m4650:%emay not use both -mfp64 and -m4650}} \\\n %{mint64|mlong64|mlong32:-mexplicit-type-size }\\\n-%{m4650:-mcpu=r4650} \\\n-%{m3900:-mips1 -mcpu=r3900 -mfp32 -mgp32} \\\n %{G*} %{EB:-meb} %{EL:-mel} %{EB:%{EL:%emay not use both -EB and -EL}} \\\n %{pic-none:   -mno-half-pic} \\\n %{pic-lib:    -mhalf-pic} \\\n %{pic-extern: -mhalf-pic} \\\n %{pic-calls:  -mhalf-pic} \\\n %{save-temps: } \\\n-%(subtarget_cc1_spec) \"\n+%(subtarget_cc1_spec) \\\n+%(cc1_cpu_spec)\"\n #endif\n \n /* Preprocessor specs.  */\n@@ -1111,7 +1140,7 @@ while (0)\n #define EH_RETURN_DATA_REGNO(N) ((N) < 4 ? (N) + GP_ARG_FIRST : INVALID_REGNUM)\n #define EH_RETURN_STACKADJ_RTX  gen_rtx_REG (Pmode, GP_REG_FIRST + 3)\n \n-/* Offsets recorded in opcodes are a multiple of this alignment factor.  \n+/* Offsets recorded in opcodes are a multiple of this alignment factor.\n    The default for this in 64-bit mode is 8, which causes problems with\n    SFmode register saves.  */\n #define DWARF_CIE_DATA_ALIGNMENT 4\n@@ -1490,7 +1519,7 @@ do {\t\t\t\t\t\t\t\\\n /* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n    will either zero-extend or sign-extend.  The value of this macro should\n    be the code that says which one of the two operations is implicitly\n-   done, NIL if none. \n+   done, NIL if none.\n \n    When in 64 bit mode, mips_move_1word will sign extend SImode and CCmode\n    moves.  All other referces are zero extended.  */\n@@ -1499,7 +1528,7 @@ do {\t\t\t\t\t\t\t\\\n    ? SIGN_EXTEND : ZERO_EXTEND)\n \n /* Define this macro if it is advisable to hold scalars in registers\n-   in a wider mode than that declared by the program.  In such cases, \n+   in a wider mode than that declared by the program.  In such cases,\n    the value is constrained to be within the bounds of the declared\n    type, but kept valid in the wider mode.  The signedness of the\n    extension may differ from that of the type.\n@@ -1731,7 +1760,7 @@ extern char mips_hard_regno_mode_ok[][FIRST_PSEUDO_REGISTER];\n \n /* The register number of the register used to address a table of\n    static data addresses in memory.  In some cases this register is\n-   defined by a processor's \"application binary interface\" (ABI). \n+   defined by a processor's \"application binary interface\" (ABI).\n    When this macro is defined, RTL is generated for this register\n    once, as with the stack pointer and frame pointer registers.  If\n    this macro is not defined, it is up to the machine-dependent\n@@ -1989,7 +2018,7 @@ extern enum reg_class mips_char_to_class[];\n    && (VALUE) == CONST0_RTX (GET_MODE (VALUE)))\n \n /* Letters in the range `Q' through `U' may be defined in a\n-   machine-dependent fashion to stand for arbitrary operand types. \n+   machine-dependent fashion to stand for arbitrary operand types.\n    The machine description macro `EXTRA_CONSTRAINT' is passed the\n    operand as its first argument and the constraint letter as its\n    second operand.\n@@ -2181,7 +2210,7 @@ extern struct mips_frame_info current_frame_info;\n \n    On some machines, the position of the argument pointer is not\n    known until the compilation is completed.  In such a case, a\n-   separate hard register must be used for the argument pointer. \n+   separate hard register must be used for the argument pointer.\n    This register can be eliminated by replacing it with either the\n    frame pointer or the argument pointer, depending on whether or not\n    the frame pointer has been eliminated.\n@@ -2333,9 +2362,9 @@ extern struct mips_frame_info current_frame_info;\n   ((MAX_ARGS_IN_REGISTERS*UNITS_PER_WORD) - FIRST_PARM_OFFSET (FNDECL))\n \n /* Define this if it is the responsibility of the caller to\n-   allocate the area reserved for arguments passed in registers. \n+   allocate the area reserved for arguments passed in registers.\n    If `ACCUMULATE_OUTGOING_ARGS' is also defined, the only effect\n-   of this macro is to determine whether the space is included in \n+   of this macro is to determine whether the space is included in\n    `current_function_outgoing_args_size'.  */\n #define OUTGOING_REG_PARM_STACK_SPACE\n \n@@ -2496,7 +2525,7 @@ typedef struct mips_args {\n   int fp_code;\t\t\t/* Mode of FP arguments (mips16) */\n   unsigned int num_adjusts;\t/* number of adjustments made */\n \t\t\t\t/* Adjustments made to args pass in regs.  */\n-\t\t\t\t/* ??? The size is doubled to work around a \n+\t\t\t\t/* ??? The size is doubled to work around a\n \t\t\t\t   bug in the code that sets the adjustments\n \t\t\t\t   in function_arg.  */\n   struct rtx_def *adjust[MAX_ARGS_IN_REGISTERS*2];\n@@ -2634,7 +2663,7 @@ typedef struct mips_args {\n \n \f\n /* A C statement to output, on the stream FILE, assembler code for a\n-   block of data that contains the constant parts of a trampoline. \n+   block of data that contains the constant parts of a trampoline.\n    This code should not include a label--the label is taken care of\n    automatically.  */\n \n@@ -2684,7 +2713,7 @@ typedef struct mips_args {\n #define CACHE_FLUSH_FUNC \"_flush_cache\"\n #endif\n \n-/* A C statement to initialize the variable parts of a trampoline. \n+/* A C statement to initialize the variable parts of a trampoline.\n    ADDR is an RTX for the address of the trampoline; FNADDR is an\n    RTX for the address of the nested function; STATIC_CHAIN is an\n    RTX for the static chain value that should be passed to the\n@@ -2782,7 +2811,7 @@ typedef struct mips_args {\n    to understand.\n \n    This macro must exist in two variants: a strict variant and a\n-   non-strict one.  The strict variant is used in the reload pass. \n+   non-strict one.  The strict variant is used in the reload pass.\n    It must be defined so that any pseudo-register that has not been\n    allocated a hard register is considered a memory reference.  In\n    contexts where some kind of register is required, a\n@@ -2819,7 +2848,7 @@ typedef struct mips_args {\n    On some machines, whether a symbolic address is legitimate\n    depends on the section that the address refers to.  On these\n    machines, define the macro `ENCODE_SECTION_INFO' to store the\n-   information into the `symbol_ref', and then check for it here. \n+   information into the `symbol_ref', and then check for it here.\n    When you see a `const', you will have to look inside it to find\n    the `symbol_ref' in order to determine the section.  */\n \n@@ -2880,7 +2909,7 @@ typedef struct mips_args {\n    to be generated at present.  Also, the MIPS assembler does not\n    grok li.d Infinity.  */\n \n-/* ??? SGI Irix 6 assembler fails for CONST address, so reject them.  \n+/* ??? SGI Irix 6 assembler fails for CONST address, so reject them.\n    Note that the Irix 6 assembler problem may already be fixed.\n    Note also that the GET_CODE (X) == CONST test catches the mips16\n    gp pseudo reg (see mips16_gp_pseudo_reg) deciding it is not\n@@ -2932,7 +2961,7 @@ typedef struct mips_args {\n \n    When PIC, convert addresses of the form memory (symbol+large int) to\n    memory (reg+large int).  */\n-   \n+\n \n #define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -3033,7 +3062,7 @@ typedef struct mips_args {\n    function named by the symbol (such as what section it is in).\n \n    The macro definition, if any, is executed immediately after the\n-   rtl for DECL has been created and stored in `DECL_RTL (DECL)'. \n+   rtl for DECL has been created and stored in `DECL_RTL (DECL)'.\n    The value of the rtl will be a `mem' whose address is a\n    `symbol_ref'.\n \n@@ -3043,7 +3072,7 @@ typedef struct mips_args {\n    information).\n \n    The best way to modify the name string is by adding text to the\n-   beginning, with suitable punctuation to prevent any ambiguity. \n+   beginning, with suitable punctuation to prevent any ambiguity.\n    Allocate the new name in `saveable_obstack'.  You will have to\n    modify `ASM_OUTPUT_LABELREF' to remove and decode the added text\n    and output the name accordingly.\n@@ -3062,7 +3091,7 @@ typedef struct mips_args {\n    constants which are put in the .text section.  We also record the\n    total length of all such strings; this total is used to decide\n    whether we need to split the constant table, and need not be\n-   precisely correct. \n+   precisely correct.\n \n    When not mips16 code nor embedded PIC, if a symbol is in a\n    gp addresable section, SYMBOL_REF_FLAG is set prevent gcc from\n@@ -3455,10 +3484,10 @@ while (0)\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode || xmode == DFmode)\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n-              || mips_cpu == PROCESSOR_R3900)\t\t\t\t\\\n+\t  if (TUNE_MIPS3000                                             \\\n+              || TUNE_MIPS3900)         \t\t\t\t\\\n \t    return COSTS_N_INSNS (2);\t\t\t\t\t\\\n-\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t  else if (TUNE_MIPS6000)       \t\t\t\t\\\n \t    return COSTS_N_INSNS (3);\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n@@ -3481,35 +3510,35 @@ while (0)\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n-\t      || mips_cpu == PROCESSOR_R3900\t\t\t\t\\\n-\t      || mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+\t  if (TUNE_MIPS3000\t\t\t\t\\\n+\t      || TUNE_MIPS3900\t\t\t\t\\\n+\t      || TUNE_MIPS5000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (4);\t\t\t\t\t\\\n-\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t  else if (TUNE_MIPS6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    return COSTS_N_INSNS (7);\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n-\t      || mips_cpu == PROCESSOR_R3900\t\t\t\t\\\n-\t      || mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+\t  if (TUNE_MIPS3000\t\t\t\t\\\n+\t      || TUNE_MIPS3900\t\t\t\t\\\n+\t      || TUNE_MIPS5000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (5);\t\t\t\t\t\\\n-\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t  else if (TUNE_MIPS6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (6);\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    return COSTS_N_INSNS (8);\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      if (mips_cpu == PROCESSOR_R3000)\t\t\t\t\t\\\n+      if (TUNE_MIPS3000)\t\t\t\t\t\\\n \treturn COSTS_N_INSNS (12);\t\t\t\t\t\\\n-      else if (mips_cpu == PROCESSOR_R3900)\t\t\t\t\\\n+      else if (TUNE_MIPS3900)\t\t\t\t\\\n \treturn COSTS_N_INSNS (2);\t\t\t\t\t\\\n-      else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+      else if (TUNE_MIPS6000)\t\t\t\t\\\n \treturn COSTS_N_INSNS (17);\t\t\t\t\t\\\n-      else if (mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+      else if (TUNE_MIPS5000)\t\t\t\t\\\n \treturn COSTS_N_INSNS (5);\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \treturn COSTS_N_INSNS (10);\t\t\t\t\t\\\n@@ -3521,21 +3550,21 @@ while (0)\n       enum machine_mode xmode = GET_MODE (X);\t\t\t\t\\\n       if (xmode == SFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n-              || mips_cpu == PROCESSOR_R3900)\t\t\t\t\\\n+\t  if (TUNE_MIPS3000\t\t\t\t\\\n+              || TUNE_MIPS3900)\t\t\t\t\\\n \t    return COSTS_N_INSNS (12);\t\t\t\t\t\\\n-\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t  else if (TUNE_MIPS6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (15);\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    return COSTS_N_INSNS (23);\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n       if (xmode == DFmode)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (mips_cpu == PROCESSOR_R3000\t\t\t\t\\\n-              || mips_cpu == PROCESSOR_R3900)\t\t\t\t\\\n+\t  if (TUNE_MIPS3000\t\t\t\t\\\n+              || TUNE_MIPS3900)\t\t\t\t\\\n \t    return COSTS_N_INSNS (19);\t\t\t\t\t\\\n-\t  else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+\t  else if (TUNE_MIPS6000)\t\t\t\t\\\n \t    return COSTS_N_INSNS (16);\t\t\t\t\t\\\n \t  else\t\t\t\t\t\t\t\t\\\n \t    return COSTS_N_INSNS (36);\t\t\t\t\t\\\n@@ -3545,12 +3574,12 @@ while (0)\n \t\t\t\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\t\t\\\n   case UMOD:\t\t\t\t\t\t\t\t\\\n-    if (mips_cpu == PROCESSOR_R3000\t\t\t\t\t\\\n-        || mips_cpu == PROCESSOR_R3900)\t\t\t\t\t\\\n+    if (TUNE_MIPS3000\t\t\t\t\t\\\n+        || TUNE_MIPS3900)\t\t\t\t\t\\\n       return COSTS_N_INSNS (35);\t\t\t\t\t\\\n-    else if (mips_cpu == PROCESSOR_R6000)\t\t\t\t\\\n+    else if (TUNE_MIPS6000)\t\t\t\t\\\n       return COSTS_N_INSNS (38);\t\t\t\t\t\\\n-    else if (mips_cpu == PROCESSOR_R5000)\t\t\t\t\\\n+    else if (TUNE_MIPS5000)\t\t\t\t\\\n       return COSTS_N_INSNS (36);\t\t\t\t\t\\\n     else\t\t\t\t\t\t\t\t\\\n       return COSTS_N_INSNS (69);\t\t\t\t\t\\\n@@ -3587,7 +3616,7 @@ while (0)\n    used.\n \n    For example, suppose an address that is equal to the sum of a\n-   register and a constant is used twice in the same basic block. \n+   register and a constant is used twice in the same basic block.\n    When this macro is not defined, the address will be computed in\n    a register and memory references will be indirect through that\n    register.  On machines where the cost of the addressing mode\n@@ -3607,7 +3636,7 @@ while (0)\n    defining `ADDRESS_COST' to reflect this can cause two registers\n    to be live over a region of code where only one would have been\n    if `ADDRESS_COST' were not defined in that manner.  This effect\n-   should be considered in the definition of this macro. \n+   should be considered in the definition of this macro.\n    Equivalent costs should probably only be given to addresses with\n    different numbers of registers on machines with lots of registers.\n \n@@ -3668,7 +3697,7 @@ while (0)\n \n /* ??? Fix this to be right for the R8000.  */\n #define MEMORY_MOVE_COST(MODE,CLASS,TO_P) \\\n-  (((mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000) ? 6 : 4) \\\n+  (((TUNE_MIPS4000 || TUNE_MIPS6000) ? 6 : 4) \\\n    + memory_move_secondary_cost ((MODE), (CLASS), (TO_P)))\n \n /* Define if copies to/from condition code registers should be avoided.\n@@ -3684,7 +3713,7 @@ while (0)\n /* ??? Fix this to be right for the R8000.  */\n #define BRANCH_COST\t\t\t\t\t\t\t\\\n   ((! TARGET_MIPS16\t\t\t\t\t\t\t\\\n-    && (mips_cpu == PROCESSOR_R4000 || mips_cpu == PROCESSOR_R6000))\t\\\n+    && (TUNE_MIPS4000 || TUNE_MIPS6000))\t\\\n    ? 2 : 1)\n \n /* A C statement (sans semicolon) to update the integer variable COST\n@@ -3720,7 +3749,7 @@ while (0)\n \n    Defining this macro does not affect the generated code (however,\n    incorrect definitions that omit an rtl code that may be matched\n-   by the predicate can cause the compiler to malfunction). \n+   by the predicate can cause the compiler to malfunction).\n    Instead, it allows the table built by `genrecog' to be more\n    compact and efficient, thus speeding up the compiler.  The most\n    important predicates to include in the list specified by this\n@@ -4138,7 +4167,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* A C statement (sans semicolon) to output to the stdio stream\n    STREAM any text necessary for declaring the name NAME of an\n    initialized variable which is being defined.  This macro must\n-   output the label definition (perhaps using `ASM_OUTPUT_LABEL'). \n+   output the label definition (perhaps using `ASM_OUTPUT_LABEL').\n    The argument DECL is the `VAR_DECL' tree node representing the\n    variable.\n \n@@ -4274,11 +4303,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n } while (0)\n \n-/* Likewise for 64 bit, `char' and `short' constants.  \n+/* Likewise for 64 bit, `char' and `short' constants.\n \n    FIXME: operand_subword can't handle some complex constant expressions\n    that output_addr_const can (for example it does not call\n-   simplify_subtraction).  Since GAS can handle dword, even for mipsII, \n+   simplify_subtraction).  Since GAS can handle dword, even for mipsII,\n    rely on that to avoid operand_subword for most of the cases where this\n    matters.  Try gcc.c-torture/compile/930326-1.c with -mips2 -mlong64,\n    or the same case with the type of 'i' changed to long long."}, {"sha": "e77c295c5067ab83a9df6db4f7ae583e38d563cc", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -1626,7 +1626,7 @@\n   \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n   \"\n {\n-  if (mips_cpu != PROCESSOR_R4300)\n+  if (TARGET_MIPS4300)\n     emit_insn (gen_muldf3_internal (operands[0], operands[1], operands[2]));\n   else\n     emit_insn (gen_muldf3_r4300 (operands[0], operands[1], operands[2]));\n@@ -1637,7 +1637,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && mips_cpu != PROCESSOR_R4300\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_MIPS4300\"\n   \"mul.d\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fmul\")\n    (set_attr \"mode\"\t\"DF\")])\n@@ -1646,7 +1646,7 @@\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(mult:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t (match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && mips_cpu == PROCESSOR_R4300\"\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_MIPS4300\"\n   \"*\n {\n   output_asm_insn (\\\"mul.d\\\\t%0,%1,%2\\\", operands);\n@@ -1665,7 +1665,7 @@\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (mips_cpu != PROCESSOR_R4300)\n+  if (!TARGET_MIPS4300)\n     emit_insn( gen_mulsf3_internal (operands[0], operands[1], operands[2]));\n   else\n     emit_insn( gen_mulsf3_r4300 (operands[0], operands[1], operands[2]));\n@@ -1676,7 +1676,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && mips_cpu != PROCESSOR_R4300\"\n+  \"TARGET_HARD_FLOAT && !TARGET_MIPS4300\"\n   \"mul.s\\\\t%0,%1,%2\"\n   [(set_attr \"type\"\t\"fmul\")\n    (set_attr \"mode\"\t\"SF\")])\n@@ -1685,7 +1685,7 @@\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t (match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && mips_cpu == PROCESSOR_R4300\"\n+  \"TARGET_HARD_FLOAT && TARGET_MIPS4300\"\n   \"*\n {\n   output_asm_insn (\\\"mul.s\\\\t%0,%1,%2\\\", operands);\n@@ -1713,7 +1713,7 @@\n {\n   if (HAVE_mulsi3_mult3)\n     emit_insn (gen_mulsi3_mult3 (operands[0], operands[1], operands[2]));\n-  else if (mips_cpu != PROCESSOR_R4000 || TARGET_MIPS16)\n+  else if (!TARGET_MIPS4000 || TARGET_MIPS16)\n     emit_insn (gen_mulsi3_internal (operands[0], operands[1], operands[2]));\n   else\n     emit_insn (gen_mulsi3_r4000 (operands[0], operands[1], operands[2]));\n@@ -1746,7 +1746,7 @@\n \t\t (match_operand:SI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:SI 3 \"=h\"))\n    (clobber (match_scratch:SI 4 \"=a\"))]\n-  \"mips_cpu != PROCESSOR_R4000 || TARGET_MIPS16\"\n+  \"!TARGET_MIPS4000 || TARGET_MIPS16\"\n   \"mult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"SI\")])\n@@ -1758,7 +1758,7 @@\n    (clobber (match_scratch:SI 3 \"=h\"))\n    (clobber (match_scratch:SI 4 \"=l\"))\n    (clobber (match_scratch:SI 5 \"=a\"))]\n-  \"mips_cpu == PROCESSOR_R4000 && !TARGET_MIPS16\"\n+  \"TARGET_MIPS4000 && !TARGET_MIPS16\"\n   \"*\n {\n   rtx xoperands[10];\n@@ -1855,7 +1855,7 @@\n \n   \"\n {\n-  if (GENERATE_MULT3 || mips_cpu == PROCESSOR_R4000 || TARGET_MIPS16)\n+  if (GENERATE_MULT3 || TARGET_MIPS4000 || TARGET_MIPS16)\n     emit_insn (gen_muldi3_internal2 (operands[0], operands[1], operands[2]));\n   else\n     emit_insn (gen_muldi3_internal (operands[0], operands[1], operands[2]));\n@@ -1873,7 +1873,7 @@\n \t\t (match_operand:DI 2 \"register_operand\" \"d\")))\n    (clobber (match_scratch:DI 3 \"=h\"))\n    (clobber (match_scratch:DI 4 \"=a\"))]\n-  \"TARGET_64BIT && mips_cpu != PROCESSOR_R4000 && !TARGET_MIPS16\"\n+  \"TARGET_64BIT && !TARGET_MIPS4000 && !TARGET_MIPS16\"\n   \"dmult\\\\t%1,%2\"\n   [(set_attr \"type\"\t\"imul\")\n    (set_attr \"mode\"\t\"DI\")])\n@@ -1885,7 +1885,7 @@\n    (clobber (match_scratch:DI 3 \"=h\"))\n    (clobber (match_scratch:DI 4 \"=l\"))\n    (clobber (match_scratch:DI 5 \"=a\"))]\n-  \"TARGET_64BIT && (GENERATE_MULT3 || mips_cpu == PROCESSOR_R4000 || TARGET_MIPS16)\"\n+  \"TARGET_64BIT && (GENERATE_MULT3 || TARGET_MIPS4000 || TARGET_MIPS16)\"\n   \"*\n {\n   if (GENERATE_MULT3)"}, {"sha": "238774db2f209a03225269d8bbec4042f10737a6", "filename": "gcc/config/mips/r3900.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fr3900.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fconfig%2Fmips%2Fr3900.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fr3900.h?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -43,7 +43,6 @@ Boston, MA 02111-1307, USA.  */\n %{msingle-float:%{msoft-float: \\\n   %e-msingle-float and -msoft-float can not both be specified.}}\"\n \n-#define TARGET_DEFAULT (MASK_SOFT_FLOAT | MASK_MIPS3900)\n #define MIPS_CPU_STRING_DEFAULT \"R3900\"\n #define MIPS_ISA_DEFAULT 1\n "}, {"sha": "6915e62b08b1b651f2e4f30a036a33d71cce17d6", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dac2f891f43324a2e3dddc79a384d5d96374900/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=7dac2f891f43324a2e3dddc79a384d5d96374900", "patch": "@@ -447,8 +447,8 @@ in the following sections.\n \n @emph{MIPS Options}\n @gccoptlist{\n--mabicalls  -mcpu=@var{cpu-type} @gol\n--membedded-data  -muninit-const-in-rodata @gol\n+-mabicalls -march=@var{cpu-type} -mtune=@var{cpu=type} @gol\n+-mcpu=@var{cpu-type} -membedded-data  -muninit-const-in-rodata @gol\n -membedded-pic  -mfp32  -mfp64  -mgas  -mgp32  -mgp64 @gol\n -mgpopt  -mhalf-pic  -mhard-float  -mint64  -mips1 @gol\n -mips2  -mips3  -mips4  -mlong64  -mlong32  -mlong-calls  -mmemcpy @gol\n@@ -935,9 +935,16 @@ names @samp{c9x} and @samp{iso9899:199x} are deprecated.\n Default, ISO C89 plus GNU extensions (including some C99 features).\n \n @item gnu99\n-@itemx gnu9x\n-ISO C99 plus GNU extensions.  When ISO C99 is fully implemented in GCC,\n-this will become the default.  The name @samp{gnu9x} is deprecated.\n+iso9899:1999 + gnu extensions\n+\n+@item iso9899:199x\n+same as @option{-std=iso9899:1999}, deprecated\n+\n+@item c9x\n+same as @option{-std=iso9899:1999}, deprecated\n+\n+@item gnu9x\n+same as @option{-std=gnu99}, deprecated\n \n @end table\n \n@@ -3804,7 +3811,7 @@ optimization.  If more memory than specified is required, the\n optimization will not be done.\n \n @item max-gcse-passes\n-The maximum number of passes of GCSE to run. \n+The maximum number of passes of GCSE to run.\n \n @item max-inline-insns\n If an function contains more than this many instructions, it\n@@ -4451,7 +4458,7 @@ Variables}.\n As a special kludge, if the path provided by @option{-B} is\n @file{[dir/]stage@var{N}/}, where @var{N} is a number in the range 0 to\n 9, then it will be replaced by @file{[dir/]include}.  This is to help\n-with boot-strapping the compiler. \n+with boot-strapping the compiler.\n \n @item -specs=@var{file}\n @opindex specs\n@@ -7031,8 +7038,19 @@ option @option{-mhc-struct-return}.\n These @samp{-m} options are defined for the MIPS family of computers:\n \n @table @gcctabopt\n-@item -mcpu=@var{cpu-type}\n-@opindex mcpu\n+\n+@item -march=@var{cpu-type}\n+@opindex march\n+Assume the defaults for the machine type @var{cpu-type} when generating\n+instructions.  The choices for @var{cpu-type} are  @samp{r2000}, @samp{r3000},\n+@samp{r3900}, @samp{r4000}, @samp{r4100}, @samp{r4300}, @samp{r4400},\n+@samp{r4600}, @samp{r4650}, @samp{r5000}, @samp{r6000}, @samp{r8000},\n+and @samp{orion}.  Additionally, the @samp{r2000}, @samp{r3000},\n+@samp{r4000}, @samp{r5000}, and @samp{r6000} can be abbreviated as\n+@samp{r2k} (or @samp{r2K}), @samp{r3k}, etc.\n+\n+@item -mtune=@var{cpu-type}\n+@opindex mtune\n Assume the defaults for the machine type @var{cpu-type} when scheduling\n instructions.  The choices for @var{cpu-type} are @samp{r2000}, @samp{r3000},\n @samp{r3900}, @samp{r4000}, @samp{r4100}, @samp{r4300}, @samp{r4400},\n@@ -7045,6 +7063,10 @@ chip, the compiler will not generate any code that does not meet level 1\n of the MIPS ISA (instruction set architecture) without a @option{-mipsX}\n or @option{-mabi} switch being used.\n \n+@item -mcpu=@var{cpu-type}\n+@opindex mcpu\n+This is identical to specifying both @option{-march} and @option{-mtune}.\n+\n @item -mips1\n @opindex mips1\n Issue instructions from level 1 of the MIPS ISA@.  This is the default."}]}