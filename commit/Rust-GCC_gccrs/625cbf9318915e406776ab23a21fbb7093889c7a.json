{"sha": "625cbf9318915e406776ab23a21fbb7093889c7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI1Y2JmOTMxODkxNWU0MDY3NzZhYjIzYTIxZmJiNzA5Mzg4OWM3YQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-03-15T16:16:18Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-03-15T16:16:18Z"}, "message": "re PR c++/14550 (trouble with pointers in templates)\n\n\tPR c++/14550\n\t* parser.c (cp_parser_non_integral_constant_expression): Encode\n\tmore of the idiom that surrounded calls to this function within\n\tthe function itself\n\t(cp_parser_primary_expression): Adjust accordingly.\n\t(cp_parser_postfix_expression): Likewise.\n\t(cp_parser_unary_expression): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_assignment_expression): Likewise.\n\t(cp_parser_expression): Likewise.\n\t(cp_parser_new_expression): Note that new-expressions are not\n\tallowed in integral constant expressions.\n\t(cp_parser_delete_expression): Likewise.\n\n\tPR c++/14550\n\t* g++.dg/parse/template14.C: New test.\n\nFrom-SVN: r79498", "tree": {"sha": "6ca3ec63bda60cceb911971973b8af475954de44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ca3ec63bda60cceb911971973b8af475954de44"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/625cbf9318915e406776ab23a21fbb7093889c7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625cbf9318915e406776ab23a21fbb7093889c7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/625cbf9318915e406776ab23a21fbb7093889c7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/625cbf9318915e406776ab23a21fbb7093889c7a/comments", "author": null, "committer": null, "parents": [{"sha": "983e64842fe8236e78dc11f6d0f569a224f0767f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/983e64842fe8236e78dc11f6d0f569a224f0767f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/983e64842fe8236e78dc11f6d0f569a224f0767f"}], "stats": {"total": 208, "additions": 114, "deletions": 94}, "files": [{"sha": "5dc9e7614846b3d42c830ed7aa16d452910fd370", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=625cbf9318915e406776ab23a21fbb7093889c7a", "patch": "@@ -1,3 +1,19 @@\n+2004-03-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14550\n+\t* parser.c (cp_parser_non_integral_constant_expression): Encode\n+\tmore of the idiom that surrounded calls to this function within\n+\tthe function itself\n+\t(cp_parser_primary_expression): Adjust accordingly.\n+\t(cp_parser_postfix_expression): Likewise.\n+\t(cp_parser_unary_expression): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_assignment_expression): Likewise.\n+\t(cp_parser_expression): Likewise.\n+\t(cp_parser_new_expression): Note that new-expressions are not\n+\tallowed in integral constant expressions.\n+\t(cp_parser_delete_expression): Likewise.\n+\n 2004-03-12  Matt Austern  <austern@apple.com>\n \n \t* decl2.c (maybe_make_one_only): Look at"}, {"sha": "20588b0469d21ad3dddd3cd5e53af65f69aca1e6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 76, "deletions": 94, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=625cbf9318915e406776ab23a21fbb7093889c7a", "patch": "@@ -1719,8 +1719,8 @@ static void cp_parser_check_for_definition_in_return_type\n   (tree, int);\n static void cp_parser_check_for_invalid_template_id\n   (cp_parser *, tree);\n-static tree cp_parser_non_integral_constant_expression\n-  (const char *);\n+static bool cp_parser_non_integral_constant_expression\n+  (cp_parser *, const char *);\n static void cp_parser_diagnose_invalid_type_name\n   (cp_parser *, tree, tree);\n static bool cp_parser_parse_and_diagnose_invalid_type_name\n@@ -1922,14 +1922,24 @@ cp_parser_check_for_invalid_template_id (cp_parser* parser,\n     }\n }\n \n-/* Issue an error message about the fact that THING appeared in a\n-   constant-expression.  Returns ERROR_MARK_NODE.  */\n+/* If parsing an integral constant-expression, issue an error message\n+   about the fact that THING appeared and return true.  Otherwise,\n+   return false, marking the current expression as non-constant.  */\n \n-static tree\n-cp_parser_non_integral_constant_expression (const char *thing)\n+static bool\n+cp_parser_non_integral_constant_expression (cp_parser  *parser,\n+\t\t\t\t\t    const char *thing)\n {\n-  error (\"%s cannot appear in a constant-expression\", thing);\n-  return error_mark_node;\n+  if (parser->integral_constant_expression_p)\n+    {\n+      if (!parser->allow_non_integral_constant_expression_p)\n+\t{\n+\t  error (\"%s cannot appear in a constant-expression\", thing);\n+\t  return true;\n+\t}\n+      parser->non_integral_constant_expression_p = true;\n+    }\n+  return false;\n }\n \n /* Emit a diagnostic for an invalid type name. Consider also if it is\n@@ -2542,12 +2552,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t      return error_mark_node;\n \t    }\n \t  /* Pointers cannot appear in constant-expressions.  */\n-\t  if (parser->integral_constant_expression_p)\n-\t    {\n-\t      if (!parser->allow_non_integral_constant_expression_p)\n-\t\treturn cp_parser_non_integral_constant_expression (\"`this'\");\n-\t      parser->non_integral_constant_expression_p = true;\n-\t    }\n+\t  if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t  \"`this'\"))\n+\t    return error_mark_node;\n \t  return finish_this_expr ();\n \n \t  /* The `operator' keyword can be the beginning of an\n@@ -2589,12 +2596,9 @@ cp_parser_primary_expression (cp_parser *parser,\n \t    cp_parser_require (parser, CPP_CLOSE_PAREN, \"`)'\");\n \t    /* Using `va_arg' in a constant-expression is not\n \t       allowed.  */\n-\t    if (parser->integral_constant_expression_p)\n-\t      {\n-\t\tif (!parser->allow_non_integral_constant_expression_p)\n-\t\t  return cp_parser_non_integral_constant_expression (\"`va_arg'\");\n-\t\tparser->non_integral_constant_expression_p = true;\n-\t      }\n+\t    if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t    \"`va_arg'\"))\n+\t      return error_mark_node;\n \t    return build_x_va_arg (expression, type);\n \t  }\n \n@@ -3518,14 +3522,12 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n \t    /* A cast to pointer or reference type is allowed in the\n \t       implementation of \"offsetof\".  */\n-\t    && !(parser->in_offsetof_p && POINTER_TYPE_P (type)))\n-\t  {\n-\t    if (!parser->allow_non_integral_constant_expression_p)\n-\t      return (cp_parser_non_integral_constant_expression\n-\t\t      (\"a cast to a type other than an integral or \"\n-\t\t       \"enumeration type\"));\n-\t    parser->non_integral_constant_expression_p = true;\n-\t  }\n+\t    && !(parser->in_offsetof_p && POINTER_TYPE_P (type))\n+\t    && (cp_parser_non_integral_constant_expression \n+\t\t(parser,\n+\t\t \"a cast to a type other than an integral or \"\n+\t\t \"enumeration type\")))\n+\t  return error_mark_node;\n \n \tswitch (keyword)\n \t  {\n@@ -3771,13 +3773,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    idk = CP_ID_KIND_NONE;\n \t    /* Array references are not permitted in\n \t       constant-expressions.  */\n-\t    if (parser->integral_constant_expression_p)\n-\t      {\n-\t\tif (!parser->allow_non_integral_constant_expression_p)\n-\t\t  postfix_expression\n-\t\t    = cp_parser_non_integral_constant_expression (\"an array reference\");\n-\t\tparser->non_integral_constant_expression_p = true;\n-\t      }\n+\t    if (cp_parser_non_integral_constant_expression \n+\t\t(parser, \"an array reference\"))\n+\t      postfix_expression = error_mark_node;\n \t  }\n \t  break;\n \n@@ -3796,15 +3794,11 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \n \t    /* Function calls are not permitted in\n \t       constant-expressions.  */\n-\t    if (parser->integral_constant_expression_p)\n+\t    if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t    \"a function call\"))\n \t      {\n-\t\tif (!parser->allow_non_integral_constant_expression_p)\n-\t\t  {\n-\t\t    postfix_expression\n-\t\t      = cp_parser_non_integral_constant_expression (\"a function call\");\n-\t\t    break;\n-\t\t  }\n-\t\tparser->non_integral_constant_expression_p = true;\n+\t\tpostfix_expression = error_mark_node;\n+\t\tbreak;\n \t      }\n \n \t    koenig_p = false;\n@@ -3999,18 +3993,14 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t       operator.  */\n \t    parser->context->object_type = NULL_TREE;\n \t    /* These operators may not appear in constant-expressions.  */\n-\t    if (parser->integral_constant_expression_p\n-\t\t/* The \"->\" operator is allowed in the implementation\n+\t    if (/* The \"->\" operator is allowed in the implementation\n \t\t   of \"offsetof\".  The \".\" operator may appear in the\n \t\t   name of the member.  */\n-\t\t&& !parser->in_offsetof_p)\n-\t      {\n-\t\tif (!parser->allow_non_integral_constant_expression_p)\n-\t\t  postfix_expression\n-\t\t    = (cp_parser_non_integral_constant_expression\n-\t\t       (token_type == CPP_DEREF ? \"'->'\" : \"`.'\"));\n-\t\tparser->non_integral_constant_expression_p = true;\n-\t      }\n+\t\t!parser->in_offsetof_p\n+\t\t&& (cp_parser_non_integral_constant_expression \n+\t\t    (parser,\n+\t\t     token_type == CPP_DEREF ? \"'->'\" : \"`.'\")))\n+\t      postfix_expression = error_mark_node;\n \t  }\n \t  break;\n \n@@ -4023,13 +4013,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    = finish_increment_expr (postfix_expression,\n \t\t\t\t     POSTINCREMENT_EXPR);\n \t  /* Increments may not appear in constant-expressions.  */\n-\t  if (parser->integral_constant_expression_p)\n-\t    {\n-\t      if (!parser->allow_non_integral_constant_expression_p)\n-\t\tpostfix_expression\n-\t\t  = cp_parser_non_integral_constant_expression (\"an increment\");\n-\t      parser->non_integral_constant_expression_p = true;\n-\t    }\n+\t  if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t  \"an increment\"))\n+\t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n \t  break;\n \n@@ -4042,13 +4028,9 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t    = finish_increment_expr (postfix_expression,\n \t\t\t\t     POSTDECREMENT_EXPR);\n \t  /* Decrements may not appear in constant-expressions.  */\n-\t  if (parser->integral_constant_expression_p)\n-\t    {\n-\t      if (!parser->allow_non_integral_constant_expression_p)\n-\t\tpostfix_expression\n-\t\t  = cp_parser_non_integral_constant_expression (\"a decrement\");\n-\t      parser->non_integral_constant_expression_p = true;\n-\t    }\n+\t  if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t  \"a decrement\"))\n+\t    postfix_expression = error_mark_node;\n \t  idk = CP_ID_KIND_NONE;\n \t  break;\n \n@@ -4447,12 +4429,10 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t  abort ();\n \t}\n \n-      if (non_constant_p && parser->integral_constant_expression_p)\n-\t{\n-\t  if (!parser->allow_non_integral_constant_expression_p)\n-\t    return cp_parser_non_integral_constant_expression (non_constant_p);\n-\t  parser->non_integral_constant_expression_p = true;\n-\t}\n+      if (non_constant_p \n+\t  && cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t non_constant_p))\n+\texpression = error_mark_node;\n \n       return expression;\n     }\n@@ -4553,6 +4533,11 @@ cp_parser_new_expression (cp_parser* parser)\n   else\n     initializer = NULL_TREE;\n \n+  /* A new-expression may not appear in an integral constant\n+     expression.  */\n+  if (cp_parser_non_integral_constant_expression (parser, \"`new'\"))\n+    return error_mark_node;\n+\n   /* Create a representation of the new-expression.  */\n   return build_new (placement, type, initializer, global_scope_p);\n }\n@@ -4781,6 +4766,11 @@ cp_parser_delete_expression (cp_parser* parser)\n   /* Parse the cast-expression.  */\n   expression = cp_parser_simple_cast_expression (parser);\n \n+  /* A delete-expression may not appear in an integral constant\n+     expression.  */\n+  if (cp_parser_non_integral_constant_expression (parser, \"`delete'\"))\n+    return error_mark_node;\n+\n   return delete_sanity (expression, NULL_TREE, array_p, global_scope_p);\n }\n \n@@ -4878,14 +4868,13 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n \t     can be used in constant-expressions.  */\n \t  if (parser->integral_constant_expression_p\n \t      && !dependent_type_p (type)\n-\t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type))\n-\t    {\n-\t      if (!parser->allow_non_integral_constant_expression_p)\n-\t\treturn (cp_parser_non_integral_constant_expression\n-\t\t\t(\"a casts to a type other than an integral or \"\n-\t\t\t \"enumeration type\"));\n-\t      parser->non_integral_constant_expression_p = true;\n-\t    }\n+\t      && !INTEGRAL_OR_ENUMERATION_TYPE_P (type)\n+\t      && (cp_parser_non_integral_constant_expression \n+\t\t  (parser,\n+\t\t   \"a cast to a type other than an integral or \"\n+\t\t   \"enumeration type\")))\n+\t    return error_mark_node;\n+\n \t  /* Perform the cast.  */\n \t  expr = build_c_cast (type, expr);\n \t  return expr;\n@@ -5238,12 +5227,9 @@ cp_parser_assignment_expression (cp_parser* parser)\n \t      rhs = cp_parser_assignment_expression (parser);\n \t      /* An assignment may not appear in a\n \t\t constant-expression.  */\n-\t      if (parser->integral_constant_expression_p)\n-\t\t{\n-\t\t  if (!parser->allow_non_integral_constant_expression_p)\n-\t\t    return cp_parser_non_integral_constant_expression (\"an assignment\");\n-\t\t  parser->non_integral_constant_expression_p = true;\n-\t\t}\n+\t      if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t\t      \"an assignment\"))\n+\t\treturn error_mark_node;\n \t      /* Build the assignment expression.  */\n \t      expr = build_x_modify_expr (expr,\n \t\t\t\t\t  assignment_operator,\n@@ -5381,13 +5367,9 @@ cp_parser_expression (cp_parser* parser)\n       /* Consume the `,'.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* A comma operator cannot appear in a constant-expression.  */\n-      if (parser->integral_constant_expression_p)\n-\t{\n-\t  if (!parser->allow_non_integral_constant_expression_p)\n-\t    expression\n-\t      = cp_parser_non_integral_constant_expression (\"a comma operator\");\n-\t  parser->non_integral_constant_expression_p = true;\n-\t}\n+      if (cp_parser_non_integral_constant_expression (parser,\n+\t\t\t\t\t\t      \"a comma operator\"))\n+\texpression = error_mark_node;\n     }\n \n   return expression;"}, {"sha": "7d1450fb100e4ab1e5407798024b35237bd8483b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=625cbf9318915e406776ab23a21fbb7093889c7a", "patch": "@@ -1,3 +1,8 @@\n+2004-03-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/14550\n+\t* g++.dg/parse/template14.C: New test.\n+\n 2004-03-13  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \t* gcc.c-torture/execute/20040313-1.c: New test."}, {"sha": "ada87524352026b7c88d69db833bea8a2136e84e", "filename": "gcc/testsuite/g++.dg/parse/template14.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate14.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/625cbf9318915e406776ab23a21fbb7093889c7a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate14.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ftemplate14.C?ref=625cbf9318915e406776ab23a21fbb7093889c7a", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/14550\n+\n+struct A { \n+  A();\n+};\n+\n+template <int> void foo()\n+{\n+  A *p = new A;\n+}\n+\n+void bar()\n+{\n+  foo<0>();\n+}\n+\n+"}]}