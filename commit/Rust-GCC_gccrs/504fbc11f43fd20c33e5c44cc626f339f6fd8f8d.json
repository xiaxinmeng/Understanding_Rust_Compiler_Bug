{"sha": "504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA0ZmJjMTFmNDNmZDIwYzMzZTVjNDRjYzYyNmYzMzlmNmZkOGY4ZA==", "commit": {"author": {"name": "Abderrazek Zaafrani", "email": "a.zaafrani@samsung.com", "date": "2015-11-07T01:32:20Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2015-11-07T01:32:20Z"}, "message": "do not create unnecessary dimensions in scop scattering\n\n           * graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons): Remove.\n           (build_pbb_minimal_scattering_polyhedrons): New.\n           (build_scop_scattering): Remove.\n           (build_scop_minimal_scattering): New.\n           (build_scop_scattering): Call build_pbb_minimal_scattering_polyhedrons.\n           (build_poly_scop): Call build_scop_minimal_scattering.\n\nFrom-SVN: r229909", "tree": {"sha": "6079b1abd20dada3bbb07939afacf3a980a36c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6079b1abd20dada3bbb07939afacf3a980a36c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5eb9a8ec6cff02f52d7a29d96ec6641d2a06de1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5eb9a8ec6cff02f52d7a29d96ec6641d2a06de1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5eb9a8ec6cff02f52d7a29d96ec6641d2a06de1"}], "stats": {"total": 199, "additions": 145, "deletions": 54}, "files": [{"sha": "bac7eb8719999e60b2be9dfa862a0d0a16f71192", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "patch": "@@ -1,3 +1,12 @@\n+2015-11-06  Abderrazek Zaafrani  <a.zaafrani@samsung.com>\n+\n+\t* graphite-sese-to-poly.c (build_pbb_scattering_polyhedrons): Remove.\n+\t(build_pbb_minimal_scattering_polyhedrons): New.\n+\t(build_scop_scattering): Remove.\n+\t(build_scop_minimal_scattering): New.\n+\t(build_scop_scattering): Call build_pbb_minimal_scattering_polyhedrons.\n+\t(build_poly_scop): Call build_scop_minimal_scattering.\n+\n 2015-11-06  Jeff Law <jeff@redhat.com>\n \n \t* cfg-flags.def (IGNORE): New edge flag."}, {"sha": "394a281a97ec64d7f2968779fa7ad0f1f7225ab4", "filename": "gcc/graphite-sese-to-poly.c", "status": "modified", "additions": 136, "deletions": 54, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d/gcc%2Fgraphite-sese-to-poly.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504fbc11f43fd20c33e5c44cc626f339f6fd8f8d/gcc%2Fgraphite-sese-to-poly.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-sese-to-poly.c?ref=504fbc11f43fd20c33e5c44cc626f339f6fd8f8d", "patch": "@@ -231,101 +231,181 @@ isl_id_for_pbb (scop_p s, poly_bb_p pbb)\n    | 0   0   1   0   0   0   0   0  -5  = 0  */\n \n static void\n-build_pbb_scattering_polyhedrons (isl_aff *static_sched,\n-\t\t\t\t  poly_bb_p pbb)\n+build_pbb_minimal_scattering_polyhedrons (isl_aff *static_sched, poly_bb_p pbb,\n+\t\t\t\t\t  int *sequence_dims,\n+\t\t\t\t\t  int nb_sequence_dim)\n {\n-  isl_val *val;\n+  int local_dim = isl_set_dim (pbb->domain, isl_dim_set);\n+\n+  /* Remove a sequence dimension if irrelevant to domain of current pbb.  */\n+  int actual_nb_dim = 0;\n+  for (int i = 0; i < nb_sequence_dim; i++)\n+    if (sequence_dims[i] <= local_dim)\n+      actual_nb_dim++;\n+\n+  /* Build an array that combines sequence dimensions and loops dimensions info.\n+     This is used later to compute the static scattering polyhedrons.  */\n+  bool *sequence_and_loop_dims = NULL;\n+  if (local_dim + actual_nb_dim > 0)\n+    {\n+      sequence_and_loop_dims = XNEWVEC (bool, local_dim + actual_nb_dim);\n \n-  int scattering_dimensions = isl_set_dim (pbb->domain, isl_dim_set) * 2 + 1;\n+      int i = 0, j = 0;\n+      for (; i < local_dim; i++)\n+\t{\n+\t  if (sequence_dims && sequence_dims[j] == i)\n+\t    {\n+\t      /* True for sequence dimension.  */\n+\t      sequence_and_loop_dims[i + j] = true;\n+\t      j++;\n+\t    }\n+\t  /* False for loop dimension.  */\n+\t  sequence_and_loop_dims[i + j] = false;\n+\t}\n+      /* Fake loops make things shifted by one.  */\n+      if (sequence_dims && sequence_dims[j] == i)\n+\tsequence_and_loop_dims[i + j] = true;\n+    }\n \n+  int scattering_dimensions = local_dim + actual_nb_dim;\n   isl_space *dc = isl_set_get_space (pbb->domain);\n-  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc),\n-\t\t\t\t      isl_dim_out, scattering_dimensions);\n+  isl_space *dm = isl_space_add_dims (isl_space_from_domain (dc), isl_dim_out,\n+\t\t\t\t      scattering_dimensions);\n   pbb->schedule = isl_map_universe (dm);\n \n+  int k = 0;\n   for (int i = 0; i < scattering_dimensions; i++)\n     {\n-      /* Textual order inside this loop.  */\n-      if ((i % 2) == 0)\n+      if (!sequence_and_loop_dims[i])\n \t{\n-\t  isl_constraint *c = isl_equality_alloc\n-\t      (isl_local_space_from_space (isl_map_get_space (pbb->schedule)));\n-\n-\t  val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, i / 2);\n-\t  gcc_assert (val && isl_val_is_int (val));\n-\n-\t  val = isl_val_neg (val);\n-\t  c = isl_constraint_set_constant_val (c, val);\n-\t  c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n-\t  pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n-\t}\n-\n-      /* Iterations of this loop.  */\n-      else /* if ((i % 2) == 1) */\n-\t{\n-\t  int loop = (i - 1) / 2;\n-\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, loop,\n+\t  /* Iterations of this loop - loop dimension.  */\n+\t  pbb->schedule = isl_map_equate (pbb->schedule, isl_dim_in, k,\n \t\t\t\t\t  isl_dim_out, i);\n+\t  k++;\n+\t  continue;\n \t}\n+\n+      /* Textual order inside this loop - sequence dimension.  */\n+      isl_space *s = isl_map_get_space (pbb->schedule);\n+      isl_local_space *ls = isl_local_space_from_space (s);\n+      isl_constraint *c = isl_equality_alloc (ls);\n+      isl_val *val = isl_aff_get_coefficient_val (static_sched, isl_dim_in, k);\n+      gcc_assert (val && isl_val_is_int (val));\n+      val = isl_val_neg (val);\n+      c = isl_constraint_set_constant_val (c, val);\n+      c = isl_constraint_set_coefficient_si (c, isl_dim_out, i, 1);\n+      pbb->schedule = isl_map_add_constraint (pbb->schedule, c);\n     }\n \n+  XDELETEVEC (sequence_and_loop_dims);\n   pbb->transformed = isl_map_copy (pbb->schedule);\n }\n \n-/* Build for BB the static schedule.\n-\n-   The static schedule is a Dewey numbering of the abstract syntax\n-   tree: http://en.wikipedia.org/wiki/Dewey_Decimal_Classification\n+/* Build the static schedule for BB.  This function minimizes the number of\n+   dimensions used for pbb sequences.\n \n    The following example informally defines the static schedule:\n \n    A\n    for (i: ...)\n      {\n        for (j: ...)\n-         {\n-           B\n-           C\n-         }\n-\n+\t{\n+\t  B\n+\t  C\n+\t}\n+     }\n+   for (i: ...)\n+     {\n        for (k: ...)\n-         {\n-           D\n-           E\n-         }\n+\t{\n+\t  D\n+\t  E\n+\t}\n      }\n    F\n \n    Static schedules for A to F:\n \n-     DEPTH\n-     0 1 2\n-   A 0\n-   B 1 0 0\n-   C 1 0 1\n-   D 1 1 0\n-   E 1 1 1\n-   F 2\n+   A (0)\n+   B (1 i0 i1 0)\n+   C (1 i0 i1 1)\n+   D (2 i0 i1 2)\n+   E (2 i0 i1 3)\n+   F (3)\n */\n \n static void\n-build_scop_scattering (scop_p scop)\n+build_scop_minimal_scattering (scop_p scop)\n {\n   gimple_poly_bb_p previous_gbb = NULL;\n-  isl_space *dc = isl_set_get_space (scop->param_context);\n-  isl_aff *static_sched;\n+  int *temp_for_sequence_dims = NULL;\n+  int i;\n+  poly_bb_p pbb;\n+\n+  /* Go through the pbbs to determine the minimum number of dimensions needed to\n+     build the static schedule.  */\n+  int nb_dims = 0;\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    {\n+      int dim = isl_set_dim (pbb->domain, isl_dim_set);\n+      if (dim > nb_dims)\n+\tnb_dims = dim;\n+    }\n+\n+  /* One extra dimension for the outer fake loop.  */\n+  nb_dims++;\n+  temp_for_sequence_dims = XCNEWVEC (int, nb_dims);\n \n+  /* Record the number of common loops for each dimension.  */\n+  FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n+    {\n+      gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n+      int prefix = 0;\n+\n+      if (previous_gbb)\n+\t{\n+\t  prefix = nb_common_loops (scop->scop_info->region, previous_gbb, gbb);\n+\t  temp_for_sequence_dims[prefix] += 1;\n+\t}\n+      previous_gbb = gbb;\n+    }\n+\n+  /* Analyze the info in temp_for_sequence_dim and determine the minimal number\n+     of sequence dimensions.  A dimension that did not appear as common\n+     dimension should not be considered as a sequence dimension.  */\n+  int nb_sequence_params = 0;\n+  for (i = 0; i < nb_dims; i++)\n+    if (temp_for_sequence_dims[i] > 0)\n+      nb_sequence_params++;\n+\n+  int *sequence_dims = NULL;\n+  if (nb_sequence_params > 0)\n+    {\n+      int j = 0;\n+      sequence_dims = XNEWVEC (int, nb_sequence_params);\n+      for (i = 0; i < nb_dims; i++)\n+\tif (temp_for_sequence_dims[i] > 0)\n+\t  {\n+\t    sequence_dims[j] = i;\n+\t    j++;\n+\t  }\n+    }\n+\n+  XDELETEVEC (temp_for_sequence_dims);\n+\n+  isl_space *dc = isl_set_get_space (scop->param_context);\n   dc = isl_space_add_dims (dc, isl_dim_set, number_of_loops (cfun));\n-  static_sched = isl_aff_zero_on_domain (isl_local_space_from_space (dc));\n+  isl_local_space *local_space = isl_local_space_from_space (dc);\n+  isl_aff *static_sched = isl_aff_zero_on_domain (local_space);\n \n   /* We have to start schedules at 0 on the first component and\n      because we cannot compare_prefix_loops against a previous loop,\n      prefix will be equal to zero, and that index will be\n      incremented before copying.  */\n   static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in, 0, -1);\n \n-  int i;\n-  poly_bb_p pbb;\n+  previous_gbb = NULL;\n   FOR_EACH_VEC_ELT (scop->pbbs, i, pbb)\n     {\n       gimple_poly_bb_p gbb = PBB_BLACK_BOX (pbb);\n@@ -338,9 +418,11 @@ build_scop_scattering (scop_p scop)\n \n       static_sched = isl_aff_add_coefficient_si (static_sched, isl_dim_in,\n \t\t\t\t\t\t prefix, 1);\n-      build_pbb_scattering_polyhedrons (static_sched, pbb);\n+      build_pbb_minimal_scattering_polyhedrons (static_sched, pbb,\n+\t\t\t\t\t\tsequence_dims, nb_sequence_params);\n     }\n \n+  XDELETEVEC (sequence_dims);\n   isl_aff_free (static_sched);\n }\n \n@@ -1716,7 +1798,7 @@ build_poly_scop (scop_p scop)\n   rewrite_cross_bb_scalar_deps_out_of_ssa (scop);\n \n   build_scop_drs (scop);\n-  build_scop_scattering (scop);\n+  build_scop_minimal_scattering (scop);\n \n   /* This SCoP has been translated to the polyhedral\n      representation.  */"}]}