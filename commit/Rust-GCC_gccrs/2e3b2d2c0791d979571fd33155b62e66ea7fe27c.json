{"sha": "2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmUzYjJkMmMwNzkxZDk3OTU3MWZkMzMxNTViNjJlNjZlYTdmZTI3Yw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-09-21T16:01:45Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-09-21T16:01:45Z"}, "message": "parse.h: (WFL_STRIP_BRACKET): Re-written using build_type_name_from_array_name.\n\n2001-09-19  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* parse.h: (WFL_STRIP_BRACKET): Re-written using\n\tbuild_type_name_from_array_name.\n\t(STRING_STRIP_BRACKETS): New macro.\n\t* parse.y (build_type_name_from_array_name): New function.\n\t(array_creation_expression:): Accumulate []s instead of [s.\n\t(cast_expression:): Accumulate []s instead of [s after cast type\n\tname.\n\t(build_array_from_name): Local string deleted, use\n\tbuild_type_name_from_array_name.\n\t(build_unresolved_array_type): Accumulate []s instead of [s after\n\ttype name.\n\t(register_fields): Fixed comment.\n\t(resolve_class): Local name, base deleted, new locals tname and\n\tarray_dims. Use build_type_name_from_array_name. Use array_dims to\n\tbuild array type.\n\t(purify_type_name): Use STRING_STRIP_BRACKETS.\n\n( http://gcc.gnu.org/ml/gcc-patches/2001-09/msg00779.html )\n\nFrom-SVN: r45732", "tree": {"sha": "30481005378fd20ffc8b2a59df9a4f96dfebfa5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30481005378fd20ffc8b2a59df9a4f96dfebfa5f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/comments", "author": null, "committer": null, "parents": [{"sha": "4bad9e39d1985c1cc951d966104bfe33db631b03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bad9e39d1985c1cc951d966104bfe33db631b03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bad9e39d1985c1cc951d966104bfe33db631b03"}], "stats": {"total": 162, "additions": 104, "deletions": 58}, "files": [{"sha": "a2ba2a6ebcefd8cfd63b3ca25d87d807d05e5963", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "patch": "@@ -1,3 +1,22 @@\n+2001-09-19  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* parse.h: (WFL_STRIP_BRACKET): Re-written using\n+\tbuild_type_name_from_array_name.\n+\t(STRING_STRIP_BRACKETS): New macro.\n+\t* parse.y (build_type_name_from_array_name): New function.\n+\t(array_creation_expression:): Accumulate []s instead of [s.\n+\t(cast_expression:): Accumulate []s instead of [s after cast type\n+\tname.\n+\t(build_array_from_name): Local string deleted, use\n+\tbuild_type_name_from_array_name.\n+\t(build_unresolved_array_type): Accumulate []s instead of [s after\n+\ttype name.\n+\t(register_fields): Fixed comment.\n+\t(resolve_class): Local name, base deleted, new locals tname and\n+\tarray_dims. Use build_type_name_from_array_name. Use array_dims to\n+\tbuild array type.\n+\t(purify_type_name): Use STRING_STRIP_BRACKETS.\n+\n 2001-09-18  Andreas Jaeger  <aj@suse.de>\n \n \t* parse.y: Use VA_OPEN/VA_CLOSE/VA_FIXEDARG throughout."}, {"sha": "f425750e4598323bd8b3d770c89df356e94f2d77", "filename": "gcc/java/parse.h", "status": "modified", "additions": 28, "deletions": 18, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.h?ref=2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "patch": "@@ -562,24 +562,34 @@ typedef struct _jdeplist {\n       }\t\t\t\t\t\t\t\t\t\\\n   }\n \n-#define WFL_STRIP_BRACKET(TARGET, TYPE)\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n-  tree __type = (TYPE);\t\t\t\t\t\t\t\\\n-  if (TYPE && TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION)\t\t\\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      tree _node = EXPR_WFL_NODE (TYPE);\t\t\t\t\\\n-      const char *_ptr = IDENTIFIER_POINTER (_node);\t\t\t\\\n-      const char *_ref = _ptr;\t\t\t\t\t\t\\\n-      while (_ptr[0] == '[')\t\t\t\t\t\t\\\n-\t  _ptr++;\t\t\t\t\t\t\t\\\n-      if (_ref != _ptr)\t\t\t\t\t\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  tree _new = copy_node (TYPE);\t\t\t\t\t\\\n-\t  EXPR_WFL_NODE (_new) = get_identifier (_ptr);\t\t\t\\\n-\t  __type = _new;\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    }\t\t\t\t\t\t\t\t\t\\\n-  (TARGET) = __type;\t\t\t\t\t\t\t\\\n+#define WFL_STRIP_BRACKET(TARGET, TYPE)\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  tree __type = (TYPE);\t\t\t\t\t\t\t  \\\n+  if (TYPE && TREE_CODE (TYPE) == EXPR_WITH_FILE_LOCATION)\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      tree _node;\t\t\t\t\t\t\t  \\\n+      if (build_type_name_from_array_name (EXPR_WFL_NODE (TYPE), &_node)) \\\n+        {\t\t\t\t\t\t\t\t  \\\n+          tree _new = copy_node (TYPE);\t\t\t\t\t  \\\n+          EXPR_WFL_NODE (_new) = _node;\t\t\t\t  \t  \\\n+          __type = _new;\t\t\t\t\t\t  \\\n+        }\t\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n+  (TARGET) = __type;\t\t\t\t\t\t\t  \\\n+}\n+\n+/* If NAME contains one or more trailing []s, NAMELEN will be the\n+   adjusted to be the index of the last non bracket character in\n+   NAME. ARRAY_DIMS will contain the number of []s found.  */\n+\n+#define STRING_STRIP_BRACKETS(NAME, NAMELEN, ARRAY_DIMS)                  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  ARRAY_DIMS = 0;\t\t\t\t\t\t\t  \\\n+  while (NAMELEN >= 2 && (NAME)[NAMELEN - 1] == ']')\t\t\t  \\\n+    {\t\t\t\t\t\t\t\t\t  \\\n+      NAMELEN -= 2;\t\t\t\t\t\t\t  \\\n+      (ARRAY_DIMS)++;\t\t\t\t\t\t\t  \\\n+    }\t\t\t\t\t\t\t\t\t  \\\n }\n \n /* Promote a type if it won't be registered as a patch */"}, {"sha": "0c8953e0efe491b6c1e082812ef90b0f4a32d686", "filename": "gcc/java/parse.y", "status": "modified", "additions": 57, "deletions": 40, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2e3b2d2c0791d979571fd33155b62e66ea7fe27c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=2e3b2d2c0791d979571fd33155b62e66ea7fe27c", "patch": "@@ -179,6 +179,7 @@ static int valid_method_invocation_conversion_p PARAMS ((tree, tree));\n static tree try_builtin_assignconv PARAMS ((tree, tree, tree));\n static tree try_reference_assignconv PARAMS ((tree, tree));\n static tree build_unresolved_array_type PARAMS ((tree));\n+static int build_type_name_from_array_name PARAMS ((tree, tree *));\n static tree build_array_from_name PARAMS ((tree, tree, tree, tree *));\n static tree build_array_ref PARAMS ((int, tree, tree));\n static tree patch_array_ref PARAMS ((tree));\n@@ -2121,7 +2122,8 @@ array_creation_expression:\n \t\t  char *sig;\n \t\t  int osb = pop_current_osb (ctxp);\n \t\t  while (osb--)\n-\t\t    obstack_1grow (&temporary_obstack, '[');\n+\t\t    obstack_grow (&temporary_obstack, \"[]\", 2);\n+\t\t  obstack_1grow (&temporary_obstack, '\\0');\n \t\t  sig = obstack_finish (&temporary_obstack);\n \t\t  $$ = build (NEW_ANONYMOUS_ARRAY_EXPR, NULL_TREE,\n \t\t\t      $2, get_identifier (sig), $4);\n@@ -2366,11 +2368,12 @@ cast_expression:\t\t/* Error handling here is potentially weak */\n \t\t{ \n \t\t  const char *ptr;\n \t\t  int osb = pop_current_osb (ctxp); \n+\t\t  obstack_grow (&temporary_obstack, \n+\t\t\t\tIDENTIFIER_POINTER (EXPR_WFL_NODE ($2)),\n+\t\t\t\tIDENTIFIER_LENGTH (EXPR_WFL_NODE ($2)));\n \t\t  while (osb--)\n-\t\t    obstack_1grow (&temporary_obstack, '[');\n-\t\t  obstack_grow0 (&temporary_obstack, \n-\t\t\t\t IDENTIFIER_POINTER (EXPR_WFL_NODE ($2)),\n-\t\t\t\t IDENTIFIER_LENGTH (EXPR_WFL_NODE ($2)));\n+\t\t    obstack_grow (&temporary_obstack, \"[]\", 2);\n+\t\t  obstack_1grow (&temporary_obstack, '\\0');\n \t\t  ptr = obstack_finish (&temporary_obstack);\n \t\t  EXPR_WFL_NODE ($2) = get_identifier (ptr);\n \t\t  $$ = build_cast ($1.location, $2, $5);\n@@ -3254,25 +3257,42 @@ variable_redefinition_error (context, name, type, line)\n \t\t       type_name, IDENTIFIER_POINTER (name), line);\n }\n \n+/* If ANAME is terminated with `[]', it indicates an array. This\n+   function returns the number of `[]' found and if this number is\n+   greater than zero, it extracts the array type name and places it in\n+   the node pointed to by TRIMMED unless TRIMMED is null.  */\n+\n+static int\n+build_type_name_from_array_name (aname, trimmed)\n+     tree aname;\n+     tree *trimmed;\n+{\n+  const char *name = IDENTIFIER_POINTER (aname);\n+  int len = IDENTIFIER_LENGTH (aname);\n+  int array_dims;\n+\n+  STRING_STRIP_BRACKETS (name, len, array_dims);\n+\n+  if (array_dims && trimmed)\n+    *trimmed = get_identifier_with_length (name, len);\n+\n+  return array_dims;\n+}\n+\n static tree\n build_array_from_name (type, type_wfl, name, ret_name)\n      tree type, type_wfl, name, *ret_name;\n {\n   int more_dims = 0;\n-  const char *string;\n \n   /* Eventually get more dims */\n-  string = IDENTIFIER_POINTER (name);\n-  while (string [more_dims] == '[')\n-    more_dims++;\n+  more_dims = build_type_name_from_array_name (name, &name);\n   \n   /* If we have, then craft a new type for this variable */\n   if (more_dims)\n     {\n       tree save = type;\n \n-      name = get_identifier (&string [more_dims]);\n-\n       /* If we have a pointer, use its type */\n       if (TREE_CODE (type) == POINTER_TYPE)\n         type = TREE_TYPE (type);\n@@ -3289,12 +3309,9 @@ build_array_from_name (type, type_wfl, name, ret_name)\n          on adding dimensions) */\n       else if (type_wfl)\n \t{\n-\t  int i = 0;\n \t  type = type_wfl;\n-\t  string = IDENTIFIER_POINTER (TYPE_NAME (save));\n-\t  while (string[i]  == '[')\n-\t    ++i;\n-\t  more_dims += i;\n+\t  more_dims += build_type_name_from_array_name (TYPE_NAME (save),\n+\t\t\t\t\t\t\tNULL);\n \t}\n \n       /* Add all the dimensions */\n@@ -3327,10 +3344,10 @@ build_unresolved_array_type (type_or_wfl)\n   if (TREE_CODE (type_or_wfl) == RECORD_TYPE)\n     return build_java_array_type (type_or_wfl, -1);\n \n-  obstack_1grow (&temporary_obstack, '[');\n-  obstack_grow0 (&temporary_obstack,\n+  obstack_grow (&temporary_obstack,\n \t\t IDENTIFIER_POINTER (EXPR_WFL_NODE (type_or_wfl)),\n \t\t IDENTIFIER_LENGTH (EXPR_WFL_NODE (type_or_wfl)));\n+  obstack_grow0 (&temporary_obstack, \"[]\", 2);\n   ptr = obstack_finish (&temporary_obstack);\n   wfl = build_expr_wfl (get_identifier (ptr),\n \t\t\tEXPR_WFL_FILENAME (type_or_wfl),\n@@ -4391,7 +4408,7 @@ register_fields (flags, type, variable_list)\n /* Generate finit$, using the list of initialized fields to populate\n    its body. finit$'s parameter(s) list is adjusted to include the\n    one(s) used to initialized the field(s) caching outer context\n-   local(s). */\n+   local(s).  */\n \n static tree\n generate_finit (class_type)\n@@ -5680,9 +5697,9 @@ static tree\n resolve_class (enclosing, class_type, decl, cl)\n      tree enclosing, class_type, decl, cl;\n {\n-  const char *name = IDENTIFIER_POINTER (TYPE_NAME (class_type));\n-  const char *base = name;\n+  tree tname = TYPE_NAME (class_type);\n   tree resolved_type = TREE_TYPE (class_type);\n+  int array_dims = 0;\n   tree resolved_type_decl;\n   \n   if (resolved_type != NULL_TREE)\n@@ -5700,13 +5717,9 @@ resolve_class (enclosing, class_type, decl, cl)\n \n   /* 1- Check to see if we have an array. If true, find what we really\n      want to resolve  */\n-  while (name[0] == '[')\n-    name++;\n-  if (base != name)\n-    {\n-      TYPE_NAME (class_type) = get_identifier (name);\n-      WFL_STRIP_BRACKET (cl, cl);\n-    }\n+  if ((array_dims = build_type_name_from_array_name (tname,\n+\t\t\t\t\t\t     &TYPE_NAME (class_type))))\n+    WFL_STRIP_BRACKET (cl, cl);\n \n   /* 2- Resolve the bare type */\n   if (!(resolved_type_decl = do_resolve_class (enclosing, class_type, \n@@ -5715,15 +5728,10 @@ resolve_class (enclosing, class_type, decl, cl)\n   resolved_type = TREE_TYPE (resolved_type_decl);\n \n   /* 3- If we have and array, reconstruct the array down to its nesting */\n-  if (base != name)\n+  if (array_dims)\n     {\n-      while (base != name)\n-\t{\n-\t  resolved_type = build_java_array_type (resolved_type, -1);\n-\t  name--;\n-\t}\n-      /* A TYPE_NAME that is a TYPE_DECL was set in\n-         build_java_array_type, return it. */\n+      for (; array_dims; array_dims--)\n+\tresolved_type = build_java_array_type (resolved_type, -1);\n       resolved_type_decl = TYPE_NAME (resolved_type);\n     }\n   TREE_TYPE (class_type) = resolved_type;\n@@ -5943,15 +5951,24 @@ resolve_no_layout (name, cl)\n   return decl;\n }\n \n-/* Called when reporting errors. Skip leader '[' in a complex array\n-   type description that failed to be resolved.  */\n+/* Called when reporting errors. Skip the '[]'s in a complex array\n+   type description that failed to be resolved. purify_type_name can't\n+   use an identifier tree.  */\n \n static const char *\n purify_type_name (name)\n      const char *name;\n {\n-  while (*name && *name == '[')\n-    name++;\n+  int len = strlen (name);\n+  int bracket_found;\n+\n+  STRING_STRIP_BRACKETS (name, len, bracket_found);\n+  if (bracket_found)\n+    {\n+      char *stripped_name = xmemdup (name, len, len+1);\n+      stripped_name [len] = '\\0';\n+      return stripped_name;\n+    }\n   return name;\n }\n "}]}