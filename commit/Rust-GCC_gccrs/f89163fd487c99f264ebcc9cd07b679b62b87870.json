{"sha": "f89163fd487c99f264ebcc9cd07b679b62b87870", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Zjg5MTYzZmQ0ODdjOTlmMjY0ZWJjYzljZDA3YjY3OWI2MmI4Nzg3MA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2013-10-12T07:52:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2013-10-12T07:52:15Z"}, "message": "re PR libgomp/58691 (OpenMP 4: Surprising results with OMP_PLACES=)\n\n\tPR libgomp/58691\n\t* config/linux/proc.c (gomp_cpuset_popcount): Add unused attribute\n\tto check variable.\n\t(gomp_init_num_threads): Move i variable declaration into\n\t#ifdef CPU_ALLOC_SIZE block.\n\t* config/linux/affinity.c (gomp_affinity_init_level): Test\n\tgomp_places_list_len == 0 rather than gomp_places_list == 0\n\twhen checking for topology reading error.\n\t* team.c (gomp_team_start): Don't handle bind == omp_proc_bind_false.\n\t* env.c (parse_affinity): Add ignore argument, if true, don't populate\n\tgomp_places_list, only parse env var and always return false.\n\t(parse_places_var): Likewise.  Don't check gomp_global_icv.bind_var.\n\t(initialize_env): Always parse OMP_PLACES and GOMP_CPU_AFFINITY env\n\tvars, default to OMP_PROC_BIND=true if OMP_PROC_BIND wasn't specified\n\tand either of these variables were parsed correctly into a places\n\tlist.\n\nFrom-SVN: r203479", "tree": {"sha": "5760fed5f9e50ee90f8b5a5eeaf2cff3e8f4abcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5760fed5f9e50ee90f8b5a5eeaf2cff3e8f4abcf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f89163fd487c99f264ebcc9cd07b679b62b87870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89163fd487c99f264ebcc9cd07b679b62b87870", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f89163fd487c99f264ebcc9cd07b679b62b87870", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f89163fd487c99f264ebcc9cd07b679b62b87870/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e1d5961cea09a63ce6ed2d0ebf443a1eaf39958", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e1d5961cea09a63ce6ed2d0ebf443a1eaf39958", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e1d5961cea09a63ce6ed2d0ebf443a1eaf39958"}], "stats": {"total": 80, "additions": 61, "deletions": 19}, "files": [{"sha": "cfcc48aa3a75ed1c1ea1fc7ef903272147b9b7c3", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=f89163fd487c99f264ebcc9cd07b679b62b87870", "patch": "@@ -1,3 +1,22 @@\n+2013-10-12  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR libgomp/58691\n+\t* config/linux/proc.c (gomp_cpuset_popcount): Add unused attribute\n+\tto check variable.\n+\t(gomp_init_num_threads): Move i variable declaration into\n+\t#ifdef CPU_ALLOC_SIZE block.\n+\t* config/linux/affinity.c (gomp_affinity_init_level): Test\n+\tgomp_places_list_len == 0 rather than gomp_places_list == 0\n+\twhen checking for topology reading error.\n+\t* team.c (gomp_team_start): Don't handle bind == omp_proc_bind_false.\n+\t* env.c (parse_affinity): Add ignore argument, if true, don't populate\n+\tgomp_places_list, only parse env var and always return false.\n+\t(parse_places_var): Likewise.  Don't check gomp_global_icv.bind_var.\n+\t(initialize_env): Always parse OMP_PLACES and GOMP_CPU_AFFINITY env\n+\tvars, default to OMP_PROC_BIND=true if OMP_PROC_BIND wasn't specified\n+\tand either of these variables were parsed correctly into a places\n+\tlist.\n+\n 2013-10-11  Thomas Schwinge  <thomas@codesourcery.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "bc5c9fcb656aa44a2731c30ecb37b659bd8c05d5", "filename": "libgomp/config/linux/affinity.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fconfig%2Flinux%2Faffinity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fconfig%2Flinux%2Faffinity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Faffinity.c?ref=f89163fd487c99f264ebcc9cd07b679b62b87870", "patch": "@@ -309,7 +309,7 @@ gomp_affinity_init_level (int level, unsigned long count, bool quiet)\n \t\tfclose (f);\n \t      }\n \t  }\n-      if (gomp_places_list == 0)\n+      if (gomp_places_list_len == 0)\n \t{\n \t  if (!quiet)\n \t    gomp_error (\"Error reading %s topology\","}, {"sha": "76616dd37a08634914c72e3db05e477b8face171", "filename": "libgomp/config/linux/proc.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fconfig%2Flinux%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fconfig%2Flinux%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Flinux%2Fproc.c?ref=f89163fd487c99f264ebcc9cd07b679b62b87870", "patch": "@@ -59,7 +59,7 @@ gomp_cpuset_popcount (unsigned long cpusetsize, cpu_set_t *cpusetp)\n   size_t i;\n   unsigned long ret = 0;\n   extern int check[sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int)\n-\t\t   ? 1 : -1];\n+\t\t   ? 1 : -1] __attribute__((unused));\n \n   for (i = 0; i < cpusetsize / sizeof (cpusetp->__bits[0]); i++)\n     {\n@@ -94,14 +94,14 @@ gomp_init_num_threads (void)\n \t\t\t\t\tgomp_cpusetp);\n       if (ret == 0)\n \t{\n-\t  unsigned long i;\n \t  /* Count only the CPUs this process can use.  */\n \t  gomp_global_icv.nthreads_var\n \t    = gomp_cpuset_popcount (gomp_cpuset_size, gomp_cpusetp);\n \t  if (gomp_global_icv.nthreads_var == 0)\n \t    break;\n \t  gomp_get_cpuset_size = gomp_cpuset_size;\n #ifdef CPU_ALLOC_SIZE\n+\t  unsigned long i;\n \t  for (i = gomp_cpuset_size * 8; i; i--)\n \t    if (CPU_ISSET_S (i - 1, gomp_cpuset_size, gomp_cpusetp))\n \t      break;"}, {"sha": "75483385b807f866f0046b538ee47297ea35f0f1", "filename": "libgomp/env.c", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fenv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fenv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fenv.c?ref=f89163fd487c99f264ebcc9cd07b679b62b87870", "patch": "@@ -548,7 +548,7 @@ parse_one_place (char **envp, bool *negatep, unsigned long *lenp,\n }\n \n static bool\n-parse_places_var (const char *name)\n+parse_places_var (const char *name, bool ignore)\n {\n   char *env = getenv (name), *end;\n   bool any_negate = false;\n@@ -604,6 +604,10 @@ parse_places_var (const char *name)\n \t  if (*env != '\\0')\n \t    goto invalid;\n \t}\n+\n+      if (ignore)\n+\treturn false;\n+\n       return gomp_affinity_init_level (level, count, false);\n     }\n \n@@ -634,7 +638,7 @@ parse_places_var (const char *name)\n     }\n   while (1);\n \n-  if (gomp_global_icv.bind_var == omp_proc_bind_false)\n+  if (ignore)\n     return false;\n \n   gomp_places_list_len = 0;\n@@ -911,7 +915,7 @@ parse_wait_policy (void)\n    present and it was successfully parsed.  */\n \n static bool\n-parse_affinity (void)\n+parse_affinity (bool ignore)\n {\n   char *env, *end, *start;\n   int pass;\n@@ -928,6 +932,9 @@ parse_affinity (void)\n       env = start;\n       if (pass == 1)\n \t{\n+\t  if (ignore)\n+\t    return false;\n+\n \t  gomp_places_list_len = 0;\n \t  gomp_places_list = gomp_affinity_alloc (count, true);\n \t  if (gomp_places_list == NULL)\n@@ -995,6 +1002,7 @@ parse_affinity (void)\n     {\n       free (gomp_places_list);\n       gomp_places_list = NULL;\n+      return false;\n     }\n   return true;\n \n@@ -1183,14 +1191,34 @@ initialize_env (void)\n \t\t\t\t &gomp_nthreads_var_list,\n \t\t\t\t &gomp_nthreads_var_list_len))\n     gomp_global_icv.nthreads_var = gomp_available_cpus;\n-  if (!parse_bind_var (\"OMP_PROC_BIND\",\n-\t\t       &gomp_global_icv.bind_var,\n-\t\t       &gomp_bind_var_list,\n-\t\t       &gomp_bind_var_list_len))\n-    gomp_global_icv.bind_var = omp_proc_bind_false;\n-  if (parse_places_var (\"OMP_PLACES\")\n-      || parse_affinity ()\n-      || gomp_global_icv.bind_var)\n+  bool ignore = false;\n+  if (parse_bind_var (\"OMP_PROC_BIND\",\n+\t\t      &gomp_global_icv.bind_var,\n+\t\t      &gomp_bind_var_list,\n+\t\t      &gomp_bind_var_list_len)\n+      && gomp_global_icv.bind_var == omp_proc_bind_false)\n+    ignore = true;\n+  /* Make sure OMP_PLACES and GOMP_CPU_AFFINITY env vars are always\n+     parsed if present in the environment.  If OMP_PROC_BIND was set\n+     explictly to false, don't populate places list though.  If places\n+     list was successfully set from OMP_PLACES, only parse but don't process\n+     GOMP_CPU_AFFINITY.  If OMP_PROC_BIND was not set in the environment,\n+     default to OMP_PROC_BIND=true if OMP_PLACES or GOMP_CPU_AFFINITY\n+     was successfully parsed into a places list, otherwise to\n+     OMP_PROC_BIND=false.  */\n+  if (parse_places_var (\"OMP_PLACES\", ignore))\n+    {\n+      if (gomp_global_icv.bind_var == omp_proc_bind_false)\n+\tgomp_global_icv.bind_var = true;\n+      ignore = true;\n+    }\n+  if (parse_affinity (ignore))\n+    {\n+      if (gomp_global_icv.bind_var == omp_proc_bind_false)\n+\tgomp_global_icv.bind_var = true;\n+      ignore = true;\n+    }\n+  if (gomp_global_icv.bind_var != omp_proc_bind_false)\n     gomp_init_affinity ();\n   wait_policy = parse_wait_policy ();\n   if (!parse_spincount (\"GOMP_SPINCOUNT\", &gomp_spin_count_var))"}, {"sha": "20f5f91750cd0eb0d42358d90d2daa3a6d608bfd", "filename": "libgomp/team.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fteam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f89163fd487c99f264ebcc9cd07b679b62b87870/libgomp%2Fteam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fteam.c?ref=f89163fd487c99f264ebcc9cd07b679b62b87870", "patch": "@@ -339,18 +339,13 @@ gomp_team_start (void (*fn) (void *), void *data, unsigned nthreads,\n \n   if (__builtin_expect (gomp_places_list != NULL, 0))\n     {\n-      if (bind == omp_proc_bind_false)\n-\tbind = omp_proc_bind_true;\n       /* Depending on chosen proc_bind model, set subpartition\n \t for the master thread and initialize helper variables\n \t P and optionally S, K and/or REST used by later place\n \t computation for each additional thread.  */\n       p = thr->place - 1;\n       switch (bind)\n \t{\n-\tcase omp_proc_bind_false:\n-\t  bind = omp_proc_bind_true;\n-\t  /* FALLTHRU */\n \tcase omp_proc_bind_true:\n \tcase omp_proc_bind_close:\n \t  if (nthreads > thr->ts.place_partition_len)"}]}