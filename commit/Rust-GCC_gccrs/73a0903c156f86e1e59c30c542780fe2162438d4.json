{"sha": "73a0903c156f86e1e59c30c542780fe2162438d4", "node_id": "C_kwDOANBUbNoAKDczYTA5MDNjMTU2Zjg2ZTFlNTljMzBjNTQyNzgwZmUyMTYyNDM4ZDQ", "commit": {"author": {"name": "M V V S Manoj Kumar", "email": "mvvsmanojkumar@gmail.com", "date": "2021-11-20T02:31:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-11-20T02:31:36Z"}, "message": "Merge branch 'Rust-GCC:master' into master", "tree": {"sha": "d608a5ee3f316d63f259113ae7fed2da4149a6ce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d608a5ee3f316d63f259113ae7fed2da4149a6ce"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73a0903c156f86e1e59c30c542780fe2162438d4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhmF4JCRBK7hj4Ov3rIwAAVggIACEdNWGuCIT3icTZM31w8Ugr\ndG8/lWYCZIX1os37ICOTrZTNRkKfaERi3SH4fFzFbUM8eviyX/muEuZW9m42kcMs\nku7BHNgP0kuGRh62HIO1YKs2rLfSJEVLoWBQv5EJq623ip7KyThUQ6e9t0f1Nrg8\nYzARaRoHGd9C/Qpk4iYjh6NwJtj1eLhvwiaCvXb+vqX7HSvInR0omRcwJNO5HT+A\nPNWFdtKu/oFYb6oNHZt474x/hebHngQg+5y/EDo6x6eyHFCSjJDnOGu0T6Mc6rxf\ncseJ9kCuGrtezK+H84GlBvftJvXrnOpA6rF+jzdiOb7rGrz2c2s9fRhE6YPF90c=\n=/d+F\n-----END PGP SIGNATURE-----\n", "payload": "tree d608a5ee3f316d63f259113ae7fed2da4149a6ce\nparent 9c4e3db7789dc32ae08a2302b13c2772f51d5bea\nparent fece068309e8a3cbeb81539fba14e1c970740a94\nauthor M V V S Manoj Kumar <mvvsmanojkumar@gmail.com> 1637375496 +0530\ncommitter GitHub <noreply@github.com> 1637375496 +0530\n\nMerge branch 'Rust-GCC:master' into master\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a0903c156f86e1e59c30c542780fe2162438d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73a0903c156f86e1e59c30c542780fe2162438d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73a0903c156f86e1e59c30c542780fe2162438d4/comments", "author": {"login": "mvvsmk", "id": 71825974, "node_id": "MDQ6VXNlcjcxODI1OTc0", "avatar_url": "https://avatars.githubusercontent.com/u/71825974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mvvsmk", "html_url": "https://github.com/mvvsmk", "followers_url": "https://api.github.com/users/mvvsmk/followers", "following_url": "https://api.github.com/users/mvvsmk/following{/other_user}", "gists_url": "https://api.github.com/users/mvvsmk/gists{/gist_id}", "starred_url": "https://api.github.com/users/mvvsmk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mvvsmk/subscriptions", "organizations_url": "https://api.github.com/users/mvvsmk/orgs", "repos_url": "https://api.github.com/users/mvvsmk/repos", "events_url": "https://api.github.com/users/mvvsmk/events{/privacy}", "received_events_url": "https://api.github.com/users/mvvsmk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c4e3db7789dc32ae08a2302b13c2772f51d5bea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9c4e3db7789dc32ae08a2302b13c2772f51d5bea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9c4e3db7789dc32ae08a2302b13c2772f51d5bea"}, {"sha": "fece068309e8a3cbeb81539fba14e1c970740a94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fece068309e8a3cbeb81539fba14e1c970740a94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fece068309e8a3cbeb81539fba14e1c970740a94"}], "stats": {"total": 4836, "additions": 2836, "deletions": 2000}, "files": [{"sha": "e1c81ad4f00d64c504a10b35a603c0f64fd74629", "filename": ".github/workflows/clang-format.yml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/.github%2Fworkflows%2Fclang-format.yml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/.github%2Fworkflows%2Fclang-format.yml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/.github%2Fworkflows%2Fclang-format.yml?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -13,6 +13,7 @@ jobs:\n     runs-on: ubuntu-latest\n \n     steps:\n+    # If updating these steps, please also correspondingly update '../../CONTRIBUTING.md', \"Running `clang-format` locally\".\n     - uses: actions/checkout@v2\n     - name: Copy .clang-format file\n       run: cp contrib/clang-format .clang-format"}, {"sha": "c0d75d7e9e4af1f70985df941ef44fd934345d03", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 75, "deletions": 3, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/CONTRIBUTING.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/CONTRIBUTING.md?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -40,9 +40,81 @@ These will be imported into a GitHub PR to follow the normal review process, and\n \n * Where possible please add test cases to `gcc/testsuite/rust/` for all PRs. Some issues may not be testable via dejagnu/automation such as debug dump changes.\n \n-* PR's cannot be merged untill clang format and the build and tests pass.\n-\n-* Please take the time to create good git commit messages see the existing format of them in the git log or refer to something like: https://chris.beams.io/posts/git-commit/\n+* Follow the [GCC coding style](https://gcc.gnu.org/codingconventions.html) (see `clang-format` below).\n+\n+* PRs won't be merged until the build and tests pass.\n+\n+* Please take the time to create good git commit messages. See the existing format of them in the git log or refer to something like: https://chris.beams.io/posts/git-commit/\n+\n+#### Running `clang-format` locally\n+\n+* on all files using python scripts\n+... corresponding to what the _Clang Format Lint_ (`.github/workflows/clang-format.yml`) is doing, with `clang-format-10` being available locally, and avoiding the Docker overhead.\n+\n+```shell\n+$ wget 'https://github.com/DoozyX/clang-format-lint-action/raw/v0.11/run-clang-format.py'\n+$ cp contrib/clang-format .clang-format\n+$ python3 run-clang-format.py --clang-format-executable clang-format-10 --recursive --extensions h,cc gcc/rust/\n+```\n+\n+* on a given patch using python scripts\n+See the [clang-format documentation](https://clang.llvm.org/docs/ClangFormat.html#script-for-patch-reformatting) :\n+\n+    $ git diff -U0 --no-color HEAD^ | clang-format-diff.py -i -p1\n+\n+* using `git` interface\n+\n+At least on Debian and its derivative, each `clang-format` packages also comes\n+with `git-clang-format` command that can be used easily. It applies on staged\n+changes, and any modification can be seen as unstaged changes:\n+\n+```diff\n+$ git diff --cached\n+diff --git a/gcc/rust/rust-abi.h b/gcc/rust/rust-abi.h\n+index bd3043295ce..9559374ce60 100644\n+--- a/gcc/rust/rust-abi.h\n++++ b/gcc/rust/rust-abi.h\n+@@ -22,10 +22,10 @@ namespace Rust {\n+ enum ABI\n+ {\n+   UNKNOWN,\n+-  RUST,\n++     RUST,\n+   INTRINSIC,\n+   C,\n+-  CDECL,\n++     CDECL,\n+   STDCALL,\n+   FASTCALL,\n+ };\n+ \n+gccrs/gcc/rust on \ue0a0 dkm/clang_format [$!+?]\n+\u276f git clang-format\n+changed files:\n+    gcc/rust/rust-abi.h\n+ \n+gccrs/gcc/rust on \ue0a0 dkm/clang_format [$!+?]\n+$ git diff rust-abi.h\n+diff --git a/gcc/rust/rust-abi.h b/gcc/rust/rust-abi.h\n+index 9559374ce60..bd3043295ce 100644\n+--- a/gcc/rust/rust-abi.h\n++++ b/gcc/rust/rust-abi.h\n+@@ -22,10 +22,10 @@ namespace Rust {\n+ enum ABI\n+ {\n+   UNKNOWN,\n+-     RUST,\n++  RUST,\n+   INTRINSIC,\n+   C,\n+-     CDECL,\n++  CDECL,\n+   STDCALL,\n+   FASTCALL,\n+ };\n+```\n+\n+Also note that you can use a given version of `clang-format` by using `git clang-format-10` if you have installed that particular version.\n \n Thanks! :heart: :heart: :heart:\n "}, {"sha": "f0e9bc338254227701a39ee6c75d0abe91535ff7", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -86,10 +86,12 @@ GRS_OBJS = \\\n     rust/rust-hir-const-fold.o \\\n     rust/rust-hir-type-check-type.o \\\n     rust/rust-hir-type-check-struct.o \\\n+    rust/rust-substitution-mapper.o \\\n     rust/rust-lint-marklive.o \\\n     rust/rust-hir-type-check-path.o \\\n     rust/rust-compile-intrinsic.o \\\n     rust/rust-base62.o \\\n+    rust/rust-compile-expr.o \\\n     $(END)\n # removed object files from here\n "}, {"sha": "05779e7be0ba640ebd41fae87e140dfb4585d448", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -542,6 +542,13 @@ struct Attribute\n class AttrInput\n {\n public:\n+  enum AttrInputType\n+  {\n+    LITERAL,\n+    META_ITEM,\n+    TOKEN_TREE,\n+  };\n+\n   virtual ~AttrInput () {}\n \n   // Unique pointer custom clone function\n@@ -564,6 +571,8 @@ class AttrInput\n   // Returns whether attr input has been parsed to meta item syntax.\n   virtual bool is_meta_item () const = 0;\n \n+  virtual AttrInputType get_attr_input_type () const = 0;\n+\n protected:\n   // pure virtual clone implementation\n   virtual AttrInput *clone_attr_input_impl () const = 0;\n@@ -650,6 +659,11 @@ class AttrInputMetaItemContainer : public AttrInput\n \n   bool check_cfg_predicate (const Session &session) const override;\n \n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::META_ITEM;\n+  }\n+\n   // Clones this object.\n   std::unique_ptr<AttrInputMetaItemContainer>\n   clone_attr_input_meta_item_container () const\n@@ -767,6 +781,11 @@ class DelimTokenTree : public TokenTree, public AttrInput\n   }\n \n   bool is_meta_item () const override { return false; }\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::TOKEN_TREE;\n+  }\n };\n \n /* Forward decl - definition moved to rust-expr.h as it requires LiteralExpr to"}, {"sha": "3463f5a2f1cac2dabe5e27ff6d86adb518b11ce3", "filename": "gcc/rust/ast/rust-expr.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -102,13 +102,7 @@ class LiteralExpr : public ExprWithoutBlock\n // Literal expression attribute body (non-macro attribute)\n class AttrInputLiteral : public AttrInput\n {\n-  // Literal expression WITHOUT SUFFIX\n-  // std::unique_ptr<LiteralExpr> literal_expr;\n-  LiteralExpr\n-    literal_expr; // as not using polymorphic behaviour, doesn't require pointer\n-  // TODO: will require pointer if LiteralExpr is changed to have subclassing\n-\n-  // TODO: should this store location data?\n+  LiteralExpr literal_expr;\n \n public:\n   AttrInputLiteral (LiteralExpr lit_expr) : literal_expr (std::move (lit_expr))\n@@ -127,6 +121,13 @@ class AttrInputLiteral : public AttrInput\n \n   bool is_meta_item () const override { return false; }\n \n+  LiteralExpr &get_literal () { return literal_expr; }\n+\n+  AttrInputType get_attr_input_type () const final override\n+  {\n+    return AttrInput::AttrInputType::LITERAL;\n+  }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "af0ea408ccdf0cd69ceb059405d6f06ac8449222", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -193,23 +193,21 @@ class HIRCompileBase : public HIR::HIRVisitor\n \n   Context *get_context () { return ctx; }\n \n-  void compile_function_body (Bfunction *fndecl,\n+  void compile_function_body (tree fndecl,\n \t\t\t      std::unique_ptr<HIR::BlockExpr> &function_body,\n \t\t\t      bool has_return_type);\n \n-  bool compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+  bool compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t std::vector<Bvariable *> &locals);\n \n-  Bexpression *coercion_site (Bexpression *compiled_ref, TyTy::BaseType *actual,\n-\t\t\t      TyTy::BaseType *expected, Location locus);\n+  tree coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t      TyTy::BaseType *expected, Location locus);\n \n-  Bexpression *coerce_to_dyn_object (Bexpression *compiled_ref,\n-\t\t\t\t     const TyTy::BaseType *actual,\n-\t\t\t\t     const TyTy::BaseType *expected,\n-\t\t\t\t     const TyTy::DynamicObjectType *ty,\n-\t\t\t\t     Location locus);\n+  tree coerce_to_dyn_object (tree compiled_ref, const TyTy::BaseType *actual,\n+\t\t\t     const TyTy::BaseType *expected,\n+\t\t\t     const TyTy::DynamicObjectType *ty, Location locus);\n \n-  Bexpression *compute_address_for_trait_item (\n+  tree compute_address_for_trait_item (\n     const Resolver::TraitItemReference *ref,\n     const TyTy::TypeBoundPredicate *predicate,\n     std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>"}, {"sha": "af90671da01dc2d17cab77369e9eec52b80cc108", "filename": "gcc/rust/backend/rust-compile-block.h", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-block.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -30,7 +30,7 @@ class CompileBlock : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bblock *compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n+  static tree compile (HIR::BlockExpr *expr, Context *ctx, Bvariable *result)\n   {\n     CompileBlock compiler (ctx, result);\n     expr->accept_vis (compiler);\n@@ -44,7 +44,7 @@ class CompileBlock : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bblock *translated;\n+  tree translated;\n   Bvariable *result;\n };\n \n@@ -53,8 +53,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::IfExpr *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::IfExpr *expr, Context *ctx, Bvariable *result)\n   {\n     CompileConditionalBlocks resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -72,7 +71,7 @@ class CompileConditionalBlocks : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n \n@@ -81,8 +80,8 @@ class CompileExprWithBlock : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bstatement *compile (HIR::ExprWithBlock *expr, Context *ctx,\n-\t\t\t      Bvariable *result)\n+  static tree compile (HIR::ExprWithBlock *expr, Context *ctx,\n+\t\t       Bvariable *result)\n   {\n     CompileExprWithBlock resolver (ctx, result);\n     expr->accept_vis (resolver);\n@@ -109,7 +108,7 @@ class CompileExprWithBlock : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr), result (result)\n   {}\n \n-  Bstatement *translated;\n+  tree translated;\n   Bvariable *result;\n };\n "}, {"sha": "668e8ba8f52c14275887dd224905c8d193c11d7e", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 92, "deletions": 99, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -35,7 +35,7 @@ namespace Compile {\n \n struct fncontext\n {\n-  ::Bfunction *fndecl;\n+  tree fndecl;\n   ::Bvariable *ret_addr;\n };\n \n@@ -60,20 +60,20 @@ class Context\n \tok = tyctx->lookup_type (ref, &lookup);\n \trust_assert (ok);\n \n-\tBtype *compiled = TyTyCompile::compile (backend, lookup);\n-\tcompiled_type_map.insert (std::pair<HirId, Btype *> (ref, compiled));\n+\ttree compiled = TyTyCompile::compile (backend, lookup);\n+\tcompiled_type_map.insert (std::pair<HirId, tree> (ref, compiled));\n \tbuiltin_range.insert (ref);\n       }\n   }\n \n-  bool lookup_compiled_types (HirId id, ::Btype **type,\n+  bool lookup_compiled_types (HirId id, tree *type,\n \t\t\t      const TyTy::BaseType *ref = nullptr)\n   {\n     if (ref != nullptr)\n       {\n \tfor (auto it = mono.begin (); it != mono.end (); it++)\n \t  {\n-\t    std::pair<HirId, ::Btype *> &val = it->second;\n+\t    std::pair<HirId, tree> &val = it->second;\n \t    const TyTy::BaseType *r = it->first;\n \n \t    if (ref->is_equal (*r))\n@@ -94,14 +94,14 @@ class Context\n     return true;\n   }\n \n-  void insert_compiled_type (HirId id, ::Btype *type,\n+  void insert_compiled_type (HirId id, tree type,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     rust_assert (builtin_range.find (id) == builtin_range.end ());\n-    compiled_type_map.insert (std::pair<HirId, Btype *> (id, type));\n+    compiled_type_map.insert (std::pair<HirId, tree> (id, type));\n     if (ref != nullptr)\n       {\n-\tstd::pair<HirId, ::Btype *> elem (id, type);\n+\tstd::pair<HirId, tree> elem (id, type);\n \tmono[ref] = std::move (elem);\n       }\n   }\n@@ -112,13 +112,13 @@ class Context\n   Analysis::Mappings *get_mappings () { return mappings; }\n   ConstFold::Context *get_const_ctx () { return const_ctx; }\n \n-  void push_block (Bblock *scope)\n+  void push_block (tree scope)\n   {\n     scope_stack.push_back (scope);\n     statements.push_back ({});\n   }\n \n-  Bblock *pop_block ()\n+  tree pop_block ()\n   {\n     auto block = scope_stack.back ();\n     scope_stack.pop_back ();\n@@ -131,20 +131,20 @@ class Context\n     return block;\n   }\n \n-  Bblock *peek_enclosing_scope ()\n+  tree peek_enclosing_scope ()\n   {\n     if (scope_stack.size () == 0)\n       return nullptr;\n \n     return scope_stack.back ();\n   }\n \n-  void add_statement_to_enclosing_scope (Bstatement *stmt)\n+  void add_statement_to_enclosing_scope (tree stmt)\n   {\n     statements.at (statements.size () - 2).push_back (stmt);\n   }\n \n-  void add_statement (Bstatement *stmt) { statements.back ().push_back (stmt); }\n+  void add_statement (tree stmt) { statements.back ().push_back (stmt); }\n \n   void insert_var_decl (HirId id, ::Bvariable *decl)\n   {\n@@ -161,7 +161,7 @@ class Context\n     return true;\n   }\n \n-  void insert_function_decl (const TyTy::FnType *ref, ::Bfunction *fn)\n+  void insert_function_decl (const TyTy::FnType *ref, tree fn)\n   {\n     auto id = ref->get_ty_ref ();\n     auto dId = ref->get_id ();\n@@ -176,8 +176,7 @@ class Context\n     mono_fns[dId].push_back ({ref, fn});\n   }\n \n-  bool lookup_function_decl (HirId id, ::Bfunction **fn,\n-\t\t\t     DefId dId = UNKNOWN_DEFID,\n+  bool lookup_function_decl (HirId id, tree *fn, DefId dId = UNKNOWN_DEFID,\n \t\t\t     const TyTy::BaseType *ref = nullptr)\n   {\n     // for for any monomorphized fns\n@@ -192,7 +191,7 @@ class Context\n \tfor (auto &e : mono_fns[dId])\n \t  {\n \t    const TyTy::BaseType *r = e.first;\n-\t    ::Bfunction *f = e.second;\n+\t    tree f = e.second;\n \t    if (ref->is_equal (*r))\n \t      {\n \t\t*fn = f;\n@@ -210,12 +209,9 @@ class Context\n     return true;\n   }\n \n-  void insert_const_decl (HirId id, ::Bexpression *expr)\n-  {\n-    compiled_consts[id] = expr;\n-  }\n+  void insert_const_decl (HirId id, tree expr) { compiled_consts[id] = expr; }\n \n-  bool lookup_const_decl (HirId id, ::Bexpression **expr)\n+  bool lookup_const_decl (HirId id, tree *expr)\n   {\n     auto it = compiled_consts.find (id);\n     if (it == compiled_consts.end ())\n@@ -225,12 +221,9 @@ class Context\n     return true;\n   }\n \n-  void insert_label_decl (HirId id, ::Blabel *label)\n-  {\n-    compiled_labels[id] = label;\n-  }\n+  void insert_label_decl (HirId id, tree label) { compiled_labels[id] = label; }\n \n-  bool lookup_label_decl (HirId id, ::Blabel **label)\n+  bool lookup_label_decl (HirId id, tree *label)\n   {\n     auto it = compiled_labels.find (id);\n     if (it == compiled_labels.end ())\n@@ -240,29 +233,29 @@ class Context\n     return true;\n   }\n \n-  void push_fn (::Bfunction *fn, ::Bvariable *ret_addr)\n+  void push_fn (tree fn, ::Bvariable *ret_addr)\n   {\n     fn_stack.push_back (fncontext{fn, ret_addr});\n   }\n   void pop_fn () { fn_stack.pop_back (); }\n   fncontext peek_fn () { return fn_stack.back (); }\n \n-  void push_type (::Btype *t) { type_decls.push_back (t); }\n+  void push_type (tree t) { type_decls.push_back (t); }\n   void push_var (::Bvariable *v) { var_decls.push_back (v); }\n-  void push_const (::Bexpression *c) { const_decls.push_back (c); }\n-  void push_function (::Bfunction *f) { func_decls.push_back (f); }\n+  void push_const (tree c) { const_decls.push_back (c); }\n+  void push_function (tree f) { func_decls.push_back (f); }\n \n   void write_to_backend ()\n   {\n     backend->write_global_definitions (type_decls, const_decls, func_decls,\n \t\t\t\t       var_decls);\n   }\n \n-  bool function_completed (Bfunction *fn)\n+  bool function_completed (tree fn)\n   {\n     for (auto it = func_decls.begin (); it != func_decls.end (); it++)\n       {\n-\tBfunction *i = (*it);\n+\ttree i = (*it);\n \tif (i == fn)\n \t  {\n \t    return true;\n@@ -282,16 +275,16 @@ class Context\n     return back;\n   }\n \n-  void push_loop_begin_label (Blabel *label)\n+  void push_loop_begin_label (tree label)\n   {\n     loop_begin_labels.push_back (label);\n   }\n \n-  Blabel *peek_loop_begin_label () { return loop_begin_labels.back (); }\n+  tree peek_loop_begin_label () { return loop_begin_labels.back (); }\n \n-  Blabel *pop_loop_begin_label ()\n+  tree pop_loop_begin_label ()\n   {\n-    Blabel *pop = loop_begin_labels.back ();\n+    tree pop = loop_begin_labels.back ();\n     loop_begin_labels.pop_back ();\n     return pop;\n   }\n@@ -322,30 +315,30 @@ class Context\n   // state\n   std::vector<fncontext> fn_stack;\n   std::map<HirId, ::Bvariable *> compiled_var_decls;\n-  std::map<HirId, ::Btype *> compiled_type_map;\n-  std::map<HirId, ::Bfunction *> compiled_fn_map;\n-  std::map<HirId, ::Bexpression *> compiled_consts;\n-  std::map<HirId, ::Blabel *> compiled_labels;\n-  std::vector<::std::vector<Bstatement *>> statements;\n-  std::vector<::Bblock *> scope_stack;\n+  std::map<HirId, tree> compiled_type_map;\n+  std::map<HirId, tree> compiled_fn_map;\n+  std::map<HirId, tree> compiled_consts;\n+  std::map<HirId, tree> compiled_labels;\n+  std::vector<::std::vector<tree>> statements;\n+  std::vector<tree> scope_stack;\n   std::vector<::Bvariable *> loop_value_stack;\n-  std::vector<::Blabel *> loop_begin_labels;\n-  std::map<const TyTy::BaseType *, std::pair<HirId, ::Btype *>> mono;\n-  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, ::Bfunction *>>>\n+  std::vector<tree> loop_begin_labels;\n+  std::map<const TyTy::BaseType *, std::pair<HirId, tree>> mono;\n+  std::map<DefId, std::vector<std::pair<const TyTy::BaseType *, tree>>>\n     mono_fns;\n \n   // To GCC middle-end\n-  std::vector<::Btype *> type_decls;\n+  std::vector<tree> type_decls;\n   std::vector<::Bvariable *> var_decls;\n-  std::vector<::Bexpression *> const_decls;\n-  std::vector<::Bfunction *> func_decls;\n+  std::vector<tree> const_decls;\n+  std::vector<tree> func_decls;\n };\n \n class TyTyResolveCompile : public TyTy::TyConstVisitor\n {\n public:\n-  static ::Btype *compile (Context *ctx, const TyTy::BaseType *ty,\n-\t\t\t   bool trait_object_mode = false)\n+  static tree compile (Context *ctx, const TyTy::BaseType *ty,\n+\t\t       bool trait_object_mode = false)\n   {\n     TyTyResolveCompile compiler (ctx, trait_object_mode);\n     ty->accept_vis (compiler);\n@@ -375,16 +368,16 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret\n \t  = TyTyResolveCompile::compile (ctx, hir_type, trait_object_mode);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret,\n \t  ctx->get_mappings ()->lookup_location (hir_type->get_ref ())));\n       }\n@@ -395,7 +388,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \tauto compiled_param_type\n \t  = TyTyResolveCompile::compile (ctx, param_tyty, trait_object_mode);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pair.first->as_string (), compiled_param_type,\n \t  ctx->get_mappings ()->lookup_location (param_tyty->get_ref ()));\n \n@@ -414,12 +407,12 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::FnPtr &type) override\n   {\n-    Btype *result_type\n+    tree result_type\n       = TyTyResolveCompile::compile (ctx, type.get_return_type ());\n \n-    std::vector<Btype *> parameters;\n+    std::vector<tree> parameters;\n     type.iterate_params ([&] (TyTy::BaseType *p) mutable -> bool {\n-      Btype *pty = TyTyResolveCompile::compile (ctx, p);\n+      tree pty = TyTyResolveCompile::compile (ctx, p);\n       parameters.push_back (pty);\n       return true;\n     });\n@@ -439,25 +432,25 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n     rust_assert (type.number_of_variants () == 1);\n \n     TyTy::VariantDef &variant = *type.get_variants ().at (0);\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < variant.num_fields (); i++)\n       {\n \tconst TyTy::StructFieldType *field = variant.get_field_at_index (i);\n-\tBtype *compiled_field_ty\n+\ttree compiled_field_ty\n \t  = TyTyResolveCompile::compile (ctx, field->get_field_type ());\n \n-\tBackend::Btyped_identifier f (field->get_name (), compiled_field_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (field->get_name (), compiled_field_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record;\n+    tree type_record;\n     if (type.is_union ())\n       type_record = ctx->get_backend ()->union_type (fields);\n     else\n       type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -482,27 +475,27 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n       return;\n \n     // create implicit struct\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n     for (size_t i = 0; i < type.num_fields (); i++)\n       {\n \tTyTy::BaseType *field = type.get_field (i);\n-\tBtype *compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n+\ttree compiled_field_ty = TyTyResolveCompile::compile (ctx, field);\n \n \t// rustc uses the convention __N, where N is an integer, to\n \t// name the fields of a tuple.  We follow this as well,\n \t// because this is used by GDB.  One further reason to prefer\n \t// this, rather than simply emitting the integer, is that this\n \t// approach makes it simpler to use a C-only debugger, or\n \t// GDB's C mode, when debugging Rust.\n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i),\n-\t\t\t\t      compiled_field_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i),\n+\t\t\t\t     compiled_field_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -514,71 +507,71 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::ArrayType &type) override\n   {\n-    Btype *element_type\n+    tree element_type\n       = TyTyResolveCompile::compile (ctx, type.get_element_type ());\n     translated\n       = ctx->get_backend ()->array_type (element_type, type.get_capacity ());\n   }\n \n   void visit (const TyTy::BoolType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::IntType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::UintType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::FloatType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::USizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ISizeType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::CharType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n   }\n \n   void visit (const TyTy::ReferenceType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -593,7 +586,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::PointerType &type) override\n   {\n-    Btype *base_compiled_type\n+    tree base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base (), trait_object_mode);\n     if (type.is_mutable ())\n       {\n@@ -608,7 +601,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   void visit (const TyTy::StrType &type) override\n   {\n-    ::Btype *compiled_type = nullptr;\n+    tree compiled_type = nullptr;\n     bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &compiled_type);\n     rust_assert (ok);\n     translated = compiled_type;\n@@ -633,32 +626,32 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n     // create implicit struct\n     auto items = type.get_object_items ();\n-    std::vector<Backend::Btyped_identifier> fields;\n+    std::vector<Backend::typed_identifier> fields;\n \n-    Btype *uint = ctx->get_backend ()->integer_type (\n+    tree uint = ctx->get_backend ()->integer_type (\n       true, ctx->get_backend ()->get_pointer_size ());\n-    Btype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+    tree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-    Backend::Btyped_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n-\t\t\t\t  ctx->get_mappings ()->lookup_location (\n-\t\t\t\t    type.get_ty_ref ()));\n+    Backend::typed_identifier f (\"__receiver_trait_obj_ptr\", uintptr_ty,\n+\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t   type.get_ty_ref ()));\n     fields.push_back (std::move (f));\n \n     for (size_t i = 0; i < items.size (); i++)\n       {\n \t// mrustc seems to make a vtable consisting of uintptr's\n-\tBtype *uint = ctx->get_backend ()->integer_type (\n+\ttree uint = ctx->get_backend ()->integer_type (\n \t  true, ctx->get_backend ()->get_pointer_size ());\n-\tBtype *uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n+\ttree uintptr_ty = ctx->get_backend ()->pointer_type (uint);\n \n-\tBackend::Btyped_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n-\t\t\t\t      ctx->get_mappings ()->lookup_location (\n-\t\t\t\t\ttype.get_ty_ref ()));\n+\tBackend::typed_identifier f (\"__\" + std::to_string (i), uintptr_ty,\n+\t\t\t\t     ctx->get_mappings ()->lookup_location (\n+\t\t\t\t       type.get_ty_ref ()));\n \tfields.push_back (std::move (f));\n       }\n \n-    Btype *type_record = ctx->get_backend ()->struct_type (fields);\n-    Btype *named_struct\n+    tree type_record = ctx->get_backend ()->struct_type (fields);\n+    tree named_struct\n       = ctx->get_backend ()->named_type (type.get_name (), type_record,\n \t\t\t\t\t ctx->get_mappings ()->lookup_location (\n \t\t\t\t\t   type.get_ty_ref ()));\n@@ -679,7 +672,7 @@ class TyTyResolveCompile : public TyTy::TyConstVisitor\n \n   Context *ctx;\n   bool trait_object_mode;\n-  ::Btype *translated;\n+  tree translated;\n   size_t recursion_count;\n \n   static const size_t kDefaultRecusionLimit = 5;"}, {"sha": "fb01d8d41225a0fde71d791daae92710e84a49fc", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "added", "additions": 393, "deletions": 0, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,393 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-compile.h\"\n+#include \"rust-compile-item.h\"\n+#include \"rust-compile-expr.h\"\n+#include \"rust-compile-struct-field-expr.h\"\n+#include \"rust-hir-trait-resolve.h\"\n+#include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n+#include \"rust-hir-dot-operator.h\"\n+\n+namespace Rust {\n+namespace Compile {\n+\n+void\n+CompileExpr::visit (HIR::ArithmeticOrLogicalExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+      translated = resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t\t      expr.get_lhs (), expr.get_rhs ());\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+}\n+\n+void\n+CompileExpr::visit (HIR::CompoundAssignmentExpr &expr)\n+{\n+  fncontext fn = ctx->peek_fn ();\n+\n+  auto op = expr.get_expr_type ();\n+  auto lhs = CompileExpr::Compile (expr.get_left_expr ().get (), ctx);\n+  auto rhs = CompileExpr::Compile (expr.get_right_expr ().get (), ctx);\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\t  expr.get_expr_type ());\n+      auto compound_assignment\n+\t= resolve_operator_overload (lang_item_type, expr, lhs, rhs,\n+\t\t\t\t     expr.get_left_expr ().get (),\n+\t\t\t\t     expr.get_right_expr ().get ());\n+      auto assignment\n+\t= ctx->get_backend ()->expression_statement (fn.fndecl,\n+\t\t\t\t\t\t     compound_assignment);\n+      ctx->add_statement (assignment);\n+\n+      return;\n+    }\n+\n+  auto operator_expr\n+    = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n+\t\t\t\t\t\t\t     expr.get_locus ());\n+  tree assignment\n+    = ctx->get_backend ()->assignment_statement (fn.fndecl, lhs, operator_expr,\n+\t\t\t\t\t\t expr.get_locus ());\n+  ctx->add_statement (assignment);\n+}\n+\n+void\n+CompileExpr::visit (HIR::NegationExpr &expr)\n+{\n+  auto op = expr.get_expr_type ();\n+  auto negated_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+  auto location = expr.get_locus ();\n+\n+  // this might be an operator overload situation lets check\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  if (is_op_overload)\n+    {\n+      auto lang_item_type\n+\t= Analysis::RustLangItem::NegationOperatorToLangItem (op);\n+      translated\n+\t= resolve_operator_overload (lang_item_type, expr, negated_expr,\n+\t\t\t\t     nullptr, expr.get_expr ().get (), nullptr);\n+      return;\n+    }\n+\n+  translated\n+    = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n+}\n+\n+tree\n+CompileExpr::compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t\tTyTy::BaseType *receiver,\n+\t\t\t\t\tTyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t\tstd::vector<HIR::Expr *> &arguments,\n+\t\t\t\t\tLocation expr_locus)\n+{\n+  size_t offs = 0;\n+  const Resolver::TraitItemReference *ref = nullptr;\n+  for (auto &bound : dyn->get_object_items ())\n+    {\n+      const Resolver::TraitItemReference *item = bound.first;\n+      auto t = item->get_tyty ();\n+      rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n+      auto ft = static_cast<TyTy::FnType *> (t);\n+\n+      if (ft->get_id () == fntype->get_id ())\n+\t{\n+\t  ref = item;\n+\t  break;\n+\t}\n+      offs++;\n+    }\n+\n+  if (ref == nullptr)\n+    return ctx->get_backend ()->error_expression ();\n+\n+  // get any indirection sorted out\n+  if (receiver->get_kind () == TyTy::TypeKind::REF)\n+    {\n+      TyTy::ReferenceType *r = static_cast<TyTy::ReferenceType *> (receiver);\n+      auto indirect_ty = r->get_base ();\n+      tree indrect_compiled_tyty\n+\t= TyTyResolveCompile::compile (ctx, indirect_ty);\n+\n+      tree indirect\n+\t= ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n+\t\t\t\t\t\t    receiver_ref, true,\n+\t\t\t\t\t\t    expr_locus);\n+      receiver_ref = indirect;\n+    }\n+\n+  // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n+  tree self_argument\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // access the vtable for the fn\n+  tree fn_vtable_access\n+    = ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n+\t\t\t\t\t\t    expr_locus);\n+\n+  // cast it to the correct fntype\n+  tree expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n+  tree fn_convert_expr\n+    = ctx->get_backend ()->convert_expression (expected_fntype,\n+\t\t\t\t\t       fn_vtable_access, expr_locus);\n+\n+  fncontext fnctx = ctx->peek_fn ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  bool is_address_taken = false;\n+  tree ret_var_stmt = NULL_TREE;\n+  Bvariable *fn_convert_expr_tmp\n+    = ctx->get_backend ()->temporary_variable (fnctx.fndecl, enclosing_scope,\n+\t\t\t\t\t       expected_fntype, fn_convert_expr,\n+\t\t\t\t\t       is_address_taken, expr_locus,\n+\t\t\t\t\t       &ret_var_stmt);\n+  ctx->add_statement (ret_var_stmt);\n+\n+  std::vector<tree> args;\n+  args.push_back (self_argument);\n+  for (auto &argument : arguments)\n+    {\n+      tree compiled_expr = CompileExpr::Compile (argument, ctx);\n+      args.push_back (compiled_expr);\n+    }\n+\n+  tree fn_expr\n+    = ctx->get_backend ()->var_expression (fn_convert_expr_tmp, expr_locus);\n+\n+  return ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr_locus);\n+}\n+\n+tree\n+CompileExpr::resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t\t     TyTy::BaseType *receiver,\n+\t\t\t\t     HIR::PathIdentSegment &segment,\n+\t\t\t\t     Analysis::NodeMapping expr_mappings,\n+\t\t\t\t     Location expr_locus)\n+{\n+  // lookup compiled functions since it may have already been compiled\n+  tree fn = NULL_TREE;\n+  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n+    {\n+      return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n+    }\n+\n+  // Now we can try and resolve the address since this might be a forward\n+  // declared function, generic function which has not be compiled yet or\n+  // its an not yet trait bound function\n+  HIR::ImplItem *resolved_item\n+    = ctx->get_mappings ()->lookup_hir_implitem (expr_mappings.get_crate_num (),\n+\t\t\t\t\t\t ref, nullptr);\n+  if (resolved_item != nullptr)\n+    {\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, resolved_item, ctx,\n+\t\t\t\t\t       true, fntype);\n+    }\n+\n+  // it might be resolved to a trait item\n+  HIR::TraitItem *trait_item = ctx->get_mappings ()->lookup_hir_trait_item (\n+    expr_mappings.get_crate_num (), ref);\n+  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n+    trait_item->get_mappings ().get_hirid ());\n+\n+  Resolver::TraitReference *trait_ref\n+    = &Resolver::TraitReference::error_node ();\n+  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n+    trait->get_mappings ().get_defid (), &trait_ref);\n+  rust_assert (ok);\n+\n+  // the type resolver can only resolve type bounds to their trait\n+  // item so its up to us to figure out if this path should resolve\n+  // to an trait-impl-block-item or if it can be defaulted to the\n+  // trait-impl-item's definition\n+\n+  auto root = receiver->get_root ();\n+  std::vector<Resolver::PathProbeCandidate> candidates\n+    = Resolver::PathProbeType::Probe (root, segment, true, false, true);\n+\n+  if (candidates.size () == 0)\n+    {\n+      // this means we are defaulting back to the trait_item if\n+      // possible\n+      Resolver::TraitItemReference *trait_item_ref = nullptr;\n+      bool ok = trait_ref->lookup_hir_trait_item (*trait_item, &trait_item_ref);\n+      rust_assert (ok);\t\t\t\t    // found\n+      rust_assert (trait_item_ref->is_optional ()); // has definition\n+\n+      // FIXME Optional means it has a definition and an associated\n+      // block which can be a default implementation, if it does not\n+      // contain an implementation we should actually return\n+      // error_mark_node\n+\n+      return CompileTraitItem::Compile (receiver,\n+\t\t\t\t\ttrait_item_ref->get_hir_trait_item (),\n+\t\t\t\t\tctx, fntype, true, expr_locus);\n+    }\n+  else\n+    {\n+      std::vector<Resolver::Adjustment> adjustments;\n+      Resolver::PathProbeCandidate *candidate\n+\t= Resolver::MethodResolution::Select (candidates, root, adjustments);\n+\n+      // FIXME this will be a case to return error_mark_node, there is\n+      // an error scenario where a Trait Foo has a method Bar, but this\n+      // receiver does not implement this trait or has an incompatible\n+      // implementation and we should just return error_mark_node\n+      rust_assert (candidate != nullptr);\n+      rust_assert (candidate->is_impl_candidate ());\n+\n+      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n+      if (!fntype->has_subsititions_defined ())\n+\treturn CompileInherentImplItem::Compile (receiver, impl_item, ctx,\n+\t\t\t\t\t\t true);\n+\n+      return CompileInherentImplItem::Compile (receiver, impl_item, ctx, true,\n+\t\t\t\t\t       fntype);\n+    }\n+}\n+\n+tree\n+CompileExpr::resolve_operator_overload (\n+  Analysis::RustLangItem::ItemType lang_item_type, HIR::OperatorExpr &expr,\n+  tree lhs, tree rhs, HIR::Expr *lhs_expr, HIR::Expr *rhs_expr)\n+{\n+  TyTy::FnType *fntype;\n+  bool is_op_overload = ctx->get_tyctx ()->lookup_operator_overload (\n+    expr.get_mappings ().get_hirid (), &fntype);\n+  rust_assert (is_op_overload);\n+\n+  // lookup the resolved name\n+  NodeId resolved_node_id = UNKNOWN_NODEID;\n+  bool ok = ctx->get_resolver ()->lookup_resolved_name (\n+    expr.get_mappings ().get_nodeid (), &resolved_node_id);\n+  rust_assert (ok);\n+\n+  // reverse lookup\n+  HirId ref;\n+  ok = ctx->get_mappings ()->lookup_node_to_hir (\n+    expr.get_mappings ().get_crate_num (), resolved_node_id, &ref);\n+  rust_assert (ok);\n+\n+  TyTy::BaseType *receiver = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_receiver (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\t   &receiver);\n+  rust_assert (ok);\n+\n+  bool is_dyn_dispatch\n+    = receiver->get_root ()->get_kind () == TyTy::TypeKind::DYNAMIC;\n+  bool is_generic_receiver = receiver->get_kind () == TyTy::TypeKind::PARAM;\n+  if (is_generic_receiver)\n+    {\n+      TyTy::ParamType *p = static_cast<TyTy::ParamType *> (receiver);\n+      receiver = p->resolve ();\n+    }\n+\n+  if (is_dyn_dispatch)\n+    {\n+      const TyTy::DynamicObjectType *dyn\n+\t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n+\n+      std::vector<HIR::Expr *> arguments;\n+      if (rhs_expr != nullptr) // can be null for negation_expr (unary ones)\n+\targuments.push_back (rhs_expr);\n+\n+      return compile_dyn_dispatch_call (dyn, receiver, fntype, lhs, arguments,\n+\t\t\t\t\texpr.get_locus ());\n+    }\n+\n+  // lookup compiled functions since it may have already been compiled\n+  HIR::PathIdentSegment segment_name (\n+    Analysis::RustLangItem::ToString (lang_item_type));\n+  tree fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n+\n+  // lookup the autoderef mappings\n+  std::vector<Resolver::Adjustment> *adjustments = nullptr;\n+  ok = ctx->get_tyctx ()->lookup_autoderef_mappings (\n+    expr.get_mappings ().get_hirid (), &adjustments);\n+  rust_assert (ok);\n+\n+  // FIXME refactor this out\n+  tree self = lhs;\n+  for (auto &adjustment : *adjustments)\n+    {\n+      switch (adjustment.get_type ())\n+\t{\n+\tcase Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\tcase Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t  self\n+\t    = ctx->get_backend ()->address_expression (self,\n+\t\t\t\t\t\t       lhs_expr->get_locus ());\n+\t  break;\n+\n+\tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t  tree expected_type\n+\t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n+\t  self\n+\t    = ctx->get_backend ()->indirect_expression (expected_type, self,\n+\t\t\t\t\t\t\ttrue, /* known_valid*/\n+\t\t\t\t\t\t\tlhs_expr->get_locus ());\n+\t  break;\n+\t}\n+    }\n+\n+  std::vector<tree> args;\n+  args.push_back (self); // adjusted self\n+  if (rhs != nullptr)\t // can be null for negation_expr (unary ones)\n+    args.push_back (rhs);\n+\n+  auto fncontext = ctx->peek_fn ();\n+  return ctx->get_backend ()->call_expression (fncontext.fndecl, fn_expr, args,\n+\t\t\t\t\t       nullptr, expr.get_locus ());\n+}\n+\n+} // namespace Compile\n+} // namespace Rust"}, {"sha": "2bf969beef988015cf5e18a3406caa848e11f3ab", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 97, "deletions": 100, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -33,7 +33,7 @@ class CompileExpr : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Expr *expr, Context *ctx)\n+  static tree Compile (HIR::Expr *expr, Context *ctx)\n   {\n     CompileExpr compiler (ctx);\n     expr->accept_vis (compiler);\n@@ -45,7 +45,7 @@ class CompileExpr : public HIRCompileBase\n     HIR::Expr *tuple_expr = expr.get_tuple_expr ().get ();\n     TupleIndex index = expr.get_tuple_index ();\n \n-    Bexpression *receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n+    tree receiver_ref = CompileExpr::Compile (tuple_expr, ctx);\n \n     TyTy::BaseType *tuple_expr_ty = nullptr;\n     bool ok = ctx->get_tyctx ()->lookup_type (\n@@ -58,9 +58,9 @@ class CompileExpr : public HIRCompileBase\n \tTyTy::ReferenceType *r\n \t  = static_cast<TyTy::ReferenceType *> (tuple_expr_ty);\n \tTyTy::BaseType *tuple_type = r->get_base ();\n-\tBtype *tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n+\ttree tuple_tyty = TyTyResolveCompile::compile (ctx, tuple_type);\n \n-\tBexpression *indirect\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (tuple_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -88,11 +88,11 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree tuple_type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (tuple_type != nullptr);\n \n     // this assumes all fields are in order from type resolution\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n \tauto e = CompileExpr::Compile (elem.get (), ctx);\n@@ -108,10 +108,10 @@ class CompileExpr : public HIRCompileBase\n   {\n     auto fncontext = ctx->peek_fn ();\n \n-    std::vector<Bexpression *> retstmts;\n+    std::vector<tree> retstmts;\n     if (expr.has_return_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.return_expr.get (), ctx);\n \trust_assert (compiled_expr != nullptr);\n \n@@ -204,7 +204,7 @@ class CompileExpr : public HIRCompileBase\n \tgcc_unreachable ();\n       }\n \n-    Bfunction *fn = nullptr;\n+    tree fn = NULL_TREE;\n     Bvariable *var = nullptr;\n     if (ctx->lookup_const_decl (ref, &translated))\n       {\n@@ -259,7 +259,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -285,7 +285,7 @@ class CompileExpr : public HIRCompileBase\n \t      return;\n \t    }\n \n-\t  Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+\t  tree type = TyTyResolveCompile::compile (ctx, tyty);\n \t  translated\n \t    = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n@@ -330,21 +330,19 @@ class CompileExpr : public HIRCompileBase\n \t  auto array_tyty = static_cast<TyTy::ArrayType *> (base_tyty);\n \n \t  std::string value_str = expr.get_literal ()->as_string ();\n-\t  std::vector<Bexpression *> vals;\n+\t  std::vector<tree> vals;\n \t  std::vector<unsigned long> indexes;\n \t  for (size_t i = 0; i < value_str.size (); i++)\n \t    {\n \t      char b = value_str.at (i);\n-\t      Bexpression *bb\n-\t\t= ctx->get_backend ()->char_constant_expression (b);\n+\t      tree bb = ctx->get_backend ()->char_constant_expression (b);\n \t      vals.push_back (bb);\n \t      indexes.push_back (i);\n \t    }\n \n-\t  Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n-\t  Bexpression *constructed\n-\t    = ctx->get_backend ()->array_constructor_expression (\n-\t      array_type, indexes, vals, expr.get_locus ());\n+\t  tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+\t  tree constructed = ctx->get_backend ()->array_constructor_expression (\n+\t    array_type, indexes, vals, expr.get_locus ());\n \n \t  translated\n \t    = ctx->get_backend ()->address_expression (constructed,\n@@ -381,17 +379,19 @@ class CompileExpr : public HIRCompileBase\n \n     rvalue = coercion_site (rvalue, actual, expected, expr.get_locus ());\n \n-    Bstatement *assignment\n+    tree assignment\n       = ctx->get_backend ()->assignment_statement (fn.fndecl, lvalue, rvalue,\n \t\t\t\t\t\t   expr.get_locus ());\n \n     ctx->add_statement (assignment);\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override;\n+\n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n-    Bexpression *index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n+    tree array = CompileExpr::Compile (expr.get_array_expr (), ctx);\n+    tree index = CompileExpr::Compile (expr.get_index_expr (), ctx);\n     translated\n       = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t     expr.get_locus ());\n@@ -412,7 +412,7 @@ class CompileExpr : public HIRCompileBase\n     TyTy::ArrayType *array_tyty = static_cast<TyTy::ArrayType *> (tyty);\n     capacity_expr = array_tyty->get_capacity ();\n \n-    Btype *array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n+    tree array_type = TyTyResolveCompile::compile (ctx, array_tyty);\n     rust_assert (array_type != nullptr);\n \n     expr.get_internal_elements ()->accept_vis (*this);\n@@ -430,14 +430,14 @@ class CompileExpr : public HIRCompileBase\n   {\n     for (auto &elem : elems.get_values ())\n       {\n-\tBexpression *translated_expr = CompileExpr::Compile (elem.get (), ctx);\n+\ttree translated_expr = CompileExpr::Compile (elem.get (), ctx);\n \tconstructor.push_back (translated_expr);\n       }\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems) override\n   {\n-    Bexpression *translated_expr\n+    tree translated_expr\n       = CompileExpr::Compile (elems.get_elem_to_copy (), ctx);\n \n     size_t capacity;\n@@ -448,17 +448,7 @@ class CompileExpr : public HIRCompileBase\n       constructor.push_back (translated_expr);\n   }\n \n-  void visit (HIR::ArithmeticOrLogicalExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto lhs = CompileExpr::Compile (expr.get_lhs (), ctx);\n-    auto rhs = CompileExpr::Compile (expr.get_rhs (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->arithmetic_or_logical_expression (op, lhs, rhs,\n-\t\t\t\t\t\t\t       location);\n-  }\n+  void visit (HIR::ArithmeticOrLogicalExpr &expr) override;\n \n   void visit (HIR::ComparisonExpr &expr) override\n   {\n@@ -482,15 +472,7 @@ class CompileExpr : public HIRCompileBase\n       = ctx->get_backend ()->lazy_boolean_expression (op, lhs, rhs, location);\n   }\n \n-  void visit (HIR::NegationExpr &expr) override\n-  {\n-    auto op = expr.get_expr_type ();\n-    auto negated_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n-    auto location = expr.get_locus ();\n-\n-    translated\n-      = ctx->get_backend ()->negation_expression (op, negated_expr, location);\n-  }\n+  void visit (HIR::NegationExpr &expr) override;\n \n   void visit (HIR::TypeCastExpr &expr) override\n   {\n@@ -532,11 +514,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -569,11 +551,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, if_type);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, if_type);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -605,11 +587,11 @@ class CompileExpr : public HIRCompileBase\n     if (needs_temp)\n       {\n \tfncontext fnctx = ctx->peek_fn ();\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = nullptr;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -656,15 +638,15 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree type = TyTyResolveCompile::compile (ctx, tyty);\n     rust_assert (type != nullptr);\n \n     // this assumes all fields are in order from type resolution and if a base\n     // struct was specified those fields are filed via accesors\n-    std::vector<Bexpression *> vals;\n+    std::vector<tree> vals;\n     for (auto &field : struct_expr.get_fields ())\n       {\n-\tBexpression *expr = CompileStructExprField::Compile (field.get (), ctx);\n+\ttree expr = CompileStructExprField::Compile (field.get (), ctx);\n \tvals.push_back (expr);\n       }\n \n@@ -681,7 +663,7 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::FieldAccessExpr &expr) override\n   {\n-    Bexpression *receiver_ref\n+    tree receiver_ref\n       = CompileExpr::Compile (expr.get_receiver_expr ().get (), ctx);\n \n     // resolve the receiver back to ADT type\n@@ -721,8 +703,8 @@ class CompileExpr : public HIRCompileBase\n \t\t\t\t\t &field_index);\n \trust_assert (ok);\n \n-\tBtype *adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n-\tBexpression *indirect\n+\ttree adt_tyty = TyTyResolveCompile::compile (ctx, adt);\n+\ttree indirect\n \t  = ctx->get_backend ()->indirect_expression (adt_tyty, receiver_ref,\n \t\t\t\t\t\t      true, expr.get_locus ());\n \treceiver_ref = indirect;\n@@ -758,11 +740,11 @@ class CompileExpr : public HIRCompileBase\n     bool needs_temp = !block_tyty->is_unit ();\n     if (needs_temp)\n       {\n-\tBblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-\tBtype *block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n+\ttree enclosing_scope = ctx->peek_enclosing_scope ();\n+\ttree block_type = TyTyResolveCompile::compile (ctx, block_tyty);\n \n \tbool is_address_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \ttmp = ctx->get_backend ()->temporary_variable (\n \t  fnctx.fndecl, enclosing_scope, block_type, NULL, is_address_taken,\n \t  expr.get_locus (), &ret_var_stmt);\n@@ -773,29 +755,29 @@ class CompileExpr : public HIRCompileBase\n     if (expr.has_loop_label ())\n       {\n \tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\tBlabel *label\n+\ttree label\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n \t  loop_label.get_lifetime ().get_mappings ().get_hirid (), label);\n       }\n \n-    Blabel *loop_begin_label\n+    tree loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n \n-    Bblock *code_block\n+    tree code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (code_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n \n@@ -814,11 +796,11 @@ class CompileExpr : public HIRCompileBase\n     if (expr.has_loop_label ())\n       {\n \tHIR::LoopLabel &loop_label = expr.get_loop_label ();\n-\tBlabel *label\n+\ttree label\n \t  = ctx->get_backend ()->label (fnctx.fndecl,\n \t\t\t\t\tloop_label.get_lifetime ().get_name (),\n \t\t\t\t\tloop_label.get_locus ());\n-\tBstatement *label_decl\n+\ttree label_decl\n \t  = ctx->get_backend ()->label_definition_statement (label);\n \tctx->add_statement (label_decl);\n \tctx->insert_label_decl (\n@@ -829,39 +811,38 @@ class CompileExpr : public HIRCompileBase\n     Location start_location = expr.get_loop_block ()->get_locus ();\n     Location end_location = expr.get_loop_block ()->get_locus (); // FIXME\n \n-    Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-    Bblock *loop_block\n+    tree enclosing_scope = ctx->peek_enclosing_scope ();\n+    tree loop_block\n       = ctx->get_backend ()->block (fnctx.fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (loop_block);\n \n-    Blabel *loop_begin_label\n+    tree loop_begin_label\n       = ctx->get_backend ()->label (fnctx.fndecl, \"\", expr.get_locus ());\n-    Bstatement *loop_begin_label_decl\n+    tree loop_begin_label_decl\n       = ctx->get_backend ()->label_definition_statement (loop_begin_label);\n     ctx->add_statement (loop_begin_label_decl);\n     ctx->push_loop_begin_label (loop_begin_label);\n \n-    Bexpression *condition\n+    tree condition\n       = CompileExpr::Compile (expr.get_predicate_expr ().get (), ctx);\n-    Bexpression *exit_expr\n+    tree exit_expr\n       = ctx->get_backend ()->exit_expression (condition, expr.get_locus ());\n-    Bstatement *break_stmt\n+    tree break_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n     ctx->add_statement (break_stmt);\n \n-    Bblock *code_block\n+    tree code_block\n       = CompileBlock::compile (expr.get_loop_block ().get (), ctx, nullptr);\n-    Bstatement *code_block_stmt\n-      = ctx->get_backend ()->block_statement (code_block);\n+    tree code_block_stmt = ctx->get_backend ()->block_statement (code_block);\n     ctx->add_statement (code_block_stmt);\n \n     ctx->pop_loop_begin_label ();\n     ctx->pop_block ();\n \n-    Bexpression *loop_expr\n+    tree loop_expr\n       = ctx->get_backend ()->loop_expression (loop_block, expr.get_locus ());\n-    Bstatement *loop_stmt\n+    tree loop_stmt\n       = ctx->get_backend ()->expression_statement (fnctx.fndecl, loop_expr);\n     ctx->add_statement (loop_stmt);\n   }\n@@ -871,14 +852,14 @@ class CompileExpr : public HIRCompileBase\n     fncontext fnctx = ctx->peek_fn ();\n     if (expr.has_break_expr ())\n       {\n-\tBexpression *compiled_expr\n+\ttree compiled_expr\n \t  = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n \tBvariable *loop_result_holder = ctx->peek_loop_context ();\n-\tBexpression *result_reference = ctx->get_backend ()->var_expression (\n+\ttree result_reference = ctx->get_backend ()->var_expression (\n \t  loop_result_holder, expr.get_expr ()->get_locus ());\n \n-\tBstatement *assignment = ctx->get_backend ()->assignment_statement (\n+\ttree assignment = ctx->get_backend ()->assignment_statement (\n \t  fnctx.fndecl, result_reference, compiled_expr, expr.get_locus ());\n \tctx->add_statement (assignment);\n       }\n@@ -906,32 +887,32 @@ class CompileExpr : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBlabel *label = nullptr;\n+\ttree label = NULL_TREE;\n \tif (!ctx->lookup_label_decl (ref, &label))\n \t  {\n \t    rust_error_at (expr.get_label ().get_locus (),\n \t\t\t   \"failed to lookup compiled label\");\n \t    return;\n \t  }\n \n-\tBstatement *goto_label\n+\ttree goto_label\n \t  = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n \tctx->add_statement (goto_label);\n       }\n     else\n       {\n-\tBexpression *exit_expr = ctx->get_backend ()->exit_expression (\n+\ttree exit_expr = ctx->get_backend ()->exit_expression (\n \t  ctx->get_backend ()->boolean_constant_expression (true),\n \t  expr.get_locus ());\n-\tBstatement *break_stmt\n+\ttree break_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, exit_expr);\n \tctx->add_statement (break_stmt);\n       }\n   }\n \n   void visit (HIR::ContinueExpr &expr) override\n   {\n-    Blabel *label = ctx->peek_loop_begin_label ();\n+    tree label = ctx->peek_loop_begin_label ();\n     if (expr.has_label ())\n       {\n \tNodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -963,24 +944,22 @@ class CompileExpr : public HIRCompileBase\n \t  }\n       }\n \n-    Bstatement *goto_label\n+    tree goto_label\n       = ctx->get_backend ()->goto_statement (label, expr.get_locus ());\n     ctx->add_statement (goto_label);\n   }\n \n   void visit (HIR::BorrowExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     translated\n       = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override\n   {\n-    Bexpression *main_expr\n-      = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n+    tree main_expr = CompileExpr::Compile (expr.get_expr ().get (), ctx);\n \n     TyTy::BaseType *tyty = nullptr;\n     if (!ctx->get_tyctx ()->lookup_type (expr.get_mappings ().get_hirid (),\n@@ -991,22 +970,40 @@ class CompileExpr : public HIRCompileBase\n \treturn;\n       }\n \n-    Btype *expected_type = TyTyResolveCompile::compile (ctx, tyty);\n+    tree expected_type = TyTyResolveCompile::compile (ctx, tyty);\n     bool known_valid = true;\n     translated\n       = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n \t\t\t\t\t\t  known_valid,\n \t\t\t\t\t\t  expr.get_locus ());\n   }\n \n+protected:\n+  tree compile_dyn_dispatch_call (const TyTy::DynamicObjectType *dyn,\n+\t\t\t\t  TyTy::BaseType *receiver,\n+\t\t\t\t  TyTy::FnType *fntype, tree receiver_ref,\n+\t\t\t\t  std::vector<HIR::Expr *> &arguments,\n+\t\t\t\t  Location expr_locus);\n+\n+  tree resolve_method_address (TyTy::FnType *fntype, HirId ref,\n+\t\t\t       TyTy::BaseType *receiver,\n+\t\t\t       HIR::PathIdentSegment &segment,\n+\t\t\t       Analysis::NodeMapping expr_mappings,\n+\t\t\t       Location expr_locus);\n+\n+  tree\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, tree lhs, tree rhs,\n+\t\t\t     HIR::Expr *lhs_expr, HIR::Expr *rhs_expr);\n+\n private:\n   CompileExpr (Context *ctx)\n     : HIRCompileBase (ctx), translated (nullptr), capacity_expr (nullptr)\n   {}\n \n-  Bexpression *translated;\n-  Bexpression *capacity_expr;\n-  std::vector<Bexpression *> constructor;\n+  tree translated;\n+  tree capacity_expr;\n+  std::vector<tree> constructor;\n };\n \n } // namespace Compile"}, {"sha": "aa73509f634a02ada963ade4267eeeb91c8b4711", "filename": "gcc/rust/backend/rust-compile-extern.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-extern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-extern.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -55,7 +55,7 @@ class CompileExternItem : public HIRCompileBase\n     // FIXME this is assuming C ABI\n     std::string asm_name = name;\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n     bool is_external = true;\n     bool is_hidden = false;\n     bool in_unique_section = false;\n@@ -99,14 +99,14 @@ class CompileExternItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      ctx->insert_function_decl (fntype, lookup);\n \n@@ -123,12 +123,12 @@ class CompileExternItem : public HIRCompileBase\n     if (fntype->get_abi () == ABI::INTRINSIC)\n       {\n \tIntrinsics compile (ctx);\n-\tBfunction *fndecl = compile.compile (fntype);\n+\ttree fndecl = compile.compile (fntype);\n \tctx->insert_function_decl (fntype, fndecl);\n \treturn;\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n     compiled_fn_type\n       = ctx->get_backend ()->specify_abi_attribute (compiled_fn_type,\n \t\t\t\t\t\t    fntype->get_abi ());\n@@ -139,7 +139,7 @@ class CompileExternItem : public HIRCompileBase\n     std::string ir_symbol_name = function.get_item_name ();\n     std::string asm_name = function.get_item_name ();\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);"}, {"sha": "629f0f5a873db43244949c83254a8ed4796af0aa", "filename": "gcc/rust/backend/rust-compile-fnparam.h", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-fnparam.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -29,8 +29,8 @@ class CompileFnParam : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::FunctionParam *param, Btype *decl_type,\n+  static Bvariable *compile (Context *ctx, tree fndecl,\n+\t\t\t     HIR::FunctionParam *param, tree decl_type,\n \t\t\t     Location locus)\n   {\n     CompileFnParam compiler (ctx, fndecl, decl_type, locus);\n@@ -51,24 +51,22 @@ class CompileFnParam : public HIRCompileBase\n   }\n \n private:\n-  CompileFnParam (Context *ctx, ::Bfunction *fndecl, ::Btype *decl_type,\n-\t\t  Location locus)\n+  CompileFnParam (Context *ctx, tree fndecl, tree decl_type, Location locus)\n     : HIRCompileBase (ctx), fndecl (fndecl), decl_type (decl_type),\n       locus (locus), translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n-  ::Btype *decl_type;\n+  tree fndecl;\n+  tree decl_type;\n   Location locus;\n   ::Bvariable *translated;\n };\n \n class CompileSelfParam : public HIRCompileBase\n {\n public:\n-  static Bvariable *compile (Context *ctx, Bfunction *fndecl,\n-\t\t\t     HIR::SelfParam &self, Btype *decl_type,\n-\t\t\t     Location locus)\n+  static Bvariable *compile (Context *ctx, tree fndecl, HIR::SelfParam &self,\n+\t\t\t     tree decl_type, Location locus)\n   {\n     bool is_immutable\n       = self.get_self_kind () == HIR::SelfParam::ImplicitSelfKind::IMM"}, {"sha": "7b412266a0a9fddbbcb7b7975bd7962b18b3fd7f", "filename": "gcc/rust/backend/rust-compile-implitem.h", "status": "modified", "additions": 35, "deletions": 36, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-implitem.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -34,11 +34,11 @@ class CompileInherentImplItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n-\t\t\t       Context *ctx, bool compile_fns,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::ImplItem *item,\n+\t\t       Context *ctx, bool compile_fns,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileInherentImplItem compiler (self, ctx, compile_fns, concrete,\n \t\t\t\t      ref_locus);\n@@ -60,8 +60,8 @@ class CompileInherentImplItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -70,7 +70,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_identifier (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -110,14 +110,14 @@ class CompileInherentImplItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -136,7 +136,7 @@ class CompileInherentImplItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n \n@@ -156,7 +156,7 @@ class CompileInherentImplItem : public HIRCompileBase\n     std::string asm_name\n       = ctx->mangle_impl_item (self, fntype, function.get_function_name ());\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -178,7 +178,7 @@ class CompileInherentImplItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self_param ().get_locus (),\n@@ -262,23 +262,23 @@ class CompileInherentImplItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -319,7 +319,7 @@ class CompileInherentImplItem : public HIRCompileBase\n   const TyTy::BaseType *self;\n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n \n@@ -328,10 +328,10 @@ class CompileTraitItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n-\t\t\t       Context *ctx, TyTy::BaseType *concrete,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree Compile (const TyTy::BaseType *self, HIR::TraitItem *item,\n+\t\t       Context *ctx, TyTy::BaseType *concrete,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileTraitItem compiler (self, ctx, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -349,9 +349,8 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (concrete != nullptr);\n     TyTy::BaseType *resolved_type = concrete;\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value\n-      = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr ().get (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     bool ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -360,7 +359,7 @@ class CompileTraitItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr = ctx->get_backend ()->named_constant_expression (\n+    tree const_expr = ctx->get_backend ()->named_constant_expression (\n       type, constant.get_name (), value, constant.get_locus ());\n \n     ctx->push_const (const_expr);\n@@ -378,14 +377,14 @@ class CompileTraitItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -404,7 +403,7 @@ class CompileTraitItem : public HIRCompileBase\n       }\n \n     // convert to the actual function type\n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     HIR::TraitFunctionDecl &function = func.get_decl ();\n     unsigned int flags = 0;\n@@ -418,7 +417,7 @@ class CompileTraitItem : public HIRCompileBase\n     std::string fn_identifier = canonical_path->get ();\n     std::string asm_name = ctx->mangle_item (fntype, *canonical_path);\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, fn_identifier,\n \t\t\t\t       asm_name, flags, func.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -440,7 +439,7 @@ class CompileTraitItem : public HIRCompileBase\n \t    return;\n \t  }\n \n-\tBtype *self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n+\ttree self_type = TyTyResolveCompile::compile (ctx, self_tyty_lookup);\n \tif (self_type == nullptr)\n \t  {\n \t    rust_error_at (function.get_self ().get_locus (),\n@@ -523,23 +522,23 @@ class CompileTraitItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = func.get_block_expr ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -578,7 +577,7 @@ class CompileTraitItem : public HIRCompileBase\n \n   const TyTy::BaseType *self;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "69626a930e955753529624771b865b1681a76755", "filename": "gcc/rust/backend/rust-compile-intrinsic.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -21,7 +21,7 @@ namespace Compile {\n \n Intrinsics::Intrinsics (Context *ctx) : ctx (ctx) {}\n \n-Bfunction *\n+tree\n Intrinsics::compile (TyTy::FnType *fntype)\n {\n   rust_assert (fntype->get_abi () == ABI::INTRINSIC);\n@@ -77,7 +77,7 @@ Intrinsics::compile (TyTy::FnType *fntype)\n   // };\n   // Some(cx.get_intrinsic(&llvm_name))\n \n-  Bfunction *builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n+  tree builtin = ctx->get_backend ()->lookup_builtin_by_rust_name (\n     fntype->get_identifier ());\n   if (builtin != nullptr)\n     return builtin;"}, {"sha": "2d44baa037cf78b3eae22b12b5ec9c46b69d393e", "filename": "gcc/rust/backend/rust-compile-intrinsic.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-intrinsic.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -27,7 +27,7 @@ class Intrinsics\n public:\n   Intrinsics (Context *ctx);\n \n-  Bfunction *compile (TyTy::FnType *fntype);\n+  tree compile (TyTy::FnType *fntype);\n \n private:\n   Context *ctx;"}, {"sha": "5af9ab31847491da383ac5546e4c85ce327f6cc2", "filename": "gcc/rust/backend/rust-compile-item.h", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -37,11 +37,10 @@ class CompileItem : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *compile (HIR::Item *item, Context *ctx,\n-\t\t\t       bool compile_fns = true,\n-\t\t\t       TyTy::BaseType *concrete = nullptr,\n-\t\t\t       bool is_query_mode = false,\n-\t\t\t       Location ref_locus = Location ())\n+  static tree compile (HIR::Item *item, Context *ctx, bool compile_fns = true,\n+\t\t       TyTy::BaseType *concrete = nullptr,\n+\t\t       bool is_query_mode = false,\n+\t\t       Location ref_locus = Location ())\n   {\n     CompileItem compiler (ctx, compile_fns, concrete, ref_locus);\n     item->accept_vis (compiler);\n@@ -61,8 +60,8 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t      &resolved_type);\n     rust_assert (ok);\n \n-    Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (var.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (var.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -97,8 +96,8 @@ class CompileItem : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -107,7 +106,7 @@ class CompileItem : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -148,14 +147,14 @@ class CompileItem : public HIRCompileBase\n \n     // items can be forward compiled which means we may not need to invoke this\n     // code. We might also have already compiled this generic function as well.\n-    Bfunction *lookup = nullptr;\n+    tree lookup = NULL_TREE;\n     if (ctx->lookup_function_decl (fntype->get_ty_ref (), &lookup,\n \t\t\t\t   fntype->get_id (), fntype))\n       {\n \t// has this been added to the list then it must be finished\n \tif (ctx->function_completed (lookup))\n \t  {\n-\t    Bfunction *dummy = nullptr;\n+\t    tree dummy = NULL_TREE;\n \t    if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &dummy))\n \t      {\n \t\tctx->insert_function_decl (fntype, lookup);\n@@ -174,7 +173,7 @@ class CompileItem : public HIRCompileBase\n \tfntype->override_context ();\n       }\n \n-    ::Btype *compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n+    tree compiled_fn_type = TyTyResolveCompile::compile (ctx, fntype);\n \n     unsigned int flags = 0;\n     bool is_main_fn = function.get_function_name ().compare (\"main\") == 0;\n@@ -202,7 +201,7 @@ class CompileItem : public HIRCompileBase\n \tasm_name = ctx->mangle_item (fntype, *canonical_path);\n       }\n \n-    Bfunction *fndecl\n+    tree fndecl\n       = ctx->get_backend ()->function (compiled_fn_type, ir_symbol_name,\n \t\t\t\t       asm_name, flags, function.get_locus ());\n     ctx->insert_function_decl (fntype, fndecl);\n@@ -262,23 +261,23 @@ class CompileItem : public HIRCompileBase\n     ok = compile_locals_for_block (*rib, fndecl, locals);\n     rust_assert (ok);\n \n-    Bblock *enclosing_scope = NULL;\n+    tree enclosing_scope = NULL_TREE;\n     HIR::BlockExpr *function_body = function.get_definition ().get ();\n     Location start_location = function_body->get_locus ();\n     Location end_location = function_body->get_closing_locus ();\n \n-    Bblock *code_block\n+    tree code_block\n       = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n \t\t\t\t    start_location, end_location);\n     ctx->push_block (code_block);\n \n     Bvariable *return_address = nullptr;\n     if (function.has_function_return_type ())\n       {\n-\tBtype *return_type = TyTyResolveCompile::compile (ctx, tyret);\n+\ttree return_type = TyTyResolveCompile::compile (ctx, tyret);\n \n \tbool address_is_taken = false;\n-\tBstatement *ret_var_stmt = nullptr;\n+\ttree ret_var_stmt = NULL_TREE;\n \n \treturn_address = ctx->get_backend ()->temporary_variable (\n \t  fndecl, code_block, return_type, NULL, address_is_taken,\n@@ -347,7 +346,7 @@ class CompileItem : public HIRCompileBase\n \n   bool compile_fns;\n   TyTy::BaseType *concrete;\n-  Bexpression *reference;\n+  tree reference;\n   Location ref_locus;\n };\n "}, {"sha": "cb3f0df8db03d2e89e19d77ec64dc39ea0c51c11", "filename": "gcc/rust/backend/rust-compile-resolve-path.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -40,7 +40,7 @@ ResolvePathRef::visit (HIR::PathInExpression &expr)\n \t\t      expr.get_mappings (), expr.get_locus (), false);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\t const Analysis::NodeMapping &mappings,\n \t\t\t Location expr_locus, bool is_qualified_path)\n@@ -76,7 +76,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n     }\n \n   // might be a constant\n-  Bexpression *constant_expr;\n+  tree constant_expr;\n   if (ctx->lookup_const_decl (ref, &constant_expr))\n     return constant_expr;\n \n@@ -92,7 +92,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n   if (lookup->get_kind () == TyTy::TypeKind::FNDEF)\n     {\n       TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n-      Bfunction *fn = nullptr;\n+      tree fn = NULL_TREE;\n       if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n \t{\n \t  return ctx->get_backend ()->function_code_expression (fn, expr_locus);\n@@ -104,7 +104,7 @@ ResolvePathRef::resolve (const HIR::PathIdentSegment &final_segment,\n \t\t\tis_qualified_path);\n }\n \n-Bexpression *\n+tree\n ResolvePathRef::query_compile (HirId ref, TyTy::BaseType *lookup,\n \t\t\t       const HIR::PathIdentSegment &final_segment,\n \t\t\t       const Analysis::NodeMapping &mappings,"}, {"sha": "56f82d1e6bca9a81aa43b2fec678f07ceab09b31", "filename": "gcc/rust/backend/rust-compile-resolve-path.h", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-resolve-path.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -30,15 +30,14 @@ class ResolvePathRef : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::QualifiedPathInExpression &expr,\n-\t\t\t       Context *ctx)\n+  static tree Compile (HIR::QualifiedPathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n     return resolver.resolved;\n   }\n \n-  static Bexpression *Compile (HIR::PathInExpression &expr, Context *ctx)\n+  static tree Compile (HIR::PathInExpression &expr, Context *ctx)\n   {\n     ResolvePathRef resolver (ctx);\n     expr.accept_vis (resolver);\n@@ -54,16 +53,16 @@ class ResolvePathRef : public HIRCompileBase\n     : HIRCompileBase (ctx), resolved (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *resolve (const HIR::PathIdentSegment &final_segment,\n-\t\t\tconst Analysis::NodeMapping &mappings, Location locus,\n-\t\t\tbool is_qualified_path);\n+  tree resolve (const HIR::PathIdentSegment &final_segment,\n+\t\tconst Analysis::NodeMapping &mappings, Location locus,\n+\t\tbool is_qualified_path);\n \n-  Bexpression *query_compile (HirId ref, TyTy::BaseType *lookup,\n-\t\t\t      const HIR::PathIdentSegment &final_segment,\n-\t\t\t      const Analysis::NodeMapping &mappings,\n-\t\t\t      Location expr_locus, bool is_qualified_path);\n+  tree query_compile (HirId ref, TyTy::BaseType *lookup,\n+\t\t      const HIR::PathIdentSegment &final_segment,\n+\t\t      const Analysis::NodeMapping &mappings,\n+\t\t      Location expr_locus, bool is_qualified_path);\n \n-  Bexpression *resolved;\n+  tree resolved;\n };\n \n } // namespace Compile"}, {"sha": "f3ee69d984837b0d9f2fc2f807e7a705c4b6a8dc", "filename": "gcc/rust/backend/rust-compile-stmt.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-stmt.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -31,7 +31,7 @@ class CompileStmt : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::Stmt *stmt, Context *ctx)\n+  static tree Compile (HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileStmt compiler (ctx);\n     stmt->accept_vis (compiler);\n@@ -56,8 +56,8 @@ class CompileStmt : public HIRCompileBase\n \t\t\t\t\t&resolved_type);\n     rust_assert (ok);\n \n-    ::Btype *type = TyTyResolveCompile::compile (ctx, resolved_type);\n-    Bexpression *value = CompileExpr::Compile (constant.get_expr (), ctx);\n+    tree type = TyTyResolveCompile::compile (ctx, resolved_type);\n+    tree value = CompileExpr::Compile (constant.get_expr (), ctx);\n \n     const Resolver::CanonicalPath *canonical_path = nullptr;\n     ok = ctx->get_mappings ()->lookup_canonical_path (\n@@ -66,7 +66,7 @@ class CompileStmt : public HIRCompileBase\n     rust_assert (ok);\n \n     std::string ident = canonical_path->get ();\n-    Bexpression *const_expr\n+    tree const_expr\n       = ctx->get_backend ()->named_constant_expression (type, ident, value,\n \t\t\t\t\t\t\tconstant.get_locus ());\n \n@@ -101,7 +101,7 @@ class CompileStmt : public HIRCompileBase\n \treturn;\n       }\n \n-    Bexpression *init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n+    tree init = CompileExpr::Compile (stmt.get_init_expr (), ctx);\n     // FIXME use error_mark_node, check that CompileExpr returns error_mark_node\n     // on failure and make this an assertion\n     if (init == nullptr)\n@@ -118,7 +118,7 @@ class CompileStmt : public HIRCompileBase\n     auto fnctx = ctx->peek_fn ();\n     if (ty->is_unit ())\n       {\n-\tBstatement *expr_stmt\n+\ttree expr_stmt\n \t  = ctx->get_backend ()->expression_statement (fnctx.fndecl, init);\n \tctx->add_statement (expr_stmt);\n       }\n@@ -132,7 +132,7 @@ class CompileStmt : public HIRCompileBase\n private:\n   CompileStmt (Context *ctx) : HIRCompileBase (ctx), translated (nullptr) {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "6754e8c4242504b2763eda2b7b9c3e1722d52db1", "filename": "gcc/rust/backend/rust-compile-struct-field-expr.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-struct-field-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -30,7 +30,7 @@ class CompileStructExprField : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static Bexpression *Compile (HIR::StructExprField *field, Context *ctx)\n+  static tree Compile (HIR::StructExprField *field, Context *ctx)\n   {\n     CompileStructExprField compiler (ctx);\n     field->accept_vis (compiler);\n@@ -49,7 +49,7 @@ class CompileStructExprField : public HIRCompileBase\n     : HIRCompileBase (ctx), translated (nullptr)\n   {}\n \n-  Bexpression *translated;\n+  tree translated;\n };\n \n } // namespace Compile"}, {"sha": "04a3ecd222ea0c4db1134ed876a1c64de09e16ec", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -34,7 +34,7 @@ namespace Compile {\n class TyTyCompile : public TyTy::TyVisitor\n {\n public:\n-  static ::Btype *compile (::Backend *backend, TyTy::BaseType *ty)\n+  static tree compile (::Backend *backend, TyTy::BaseType *ty)\n   {\n     TyTyCompile compiler (backend);\n     ty->accept_vis (compiler);\n@@ -72,15 +72,15 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::FnType &type) override\n   {\n-    Backend::Btyped_identifier receiver;\n-    std::vector<Backend::Btyped_identifier> parameters;\n-    std::vector<Backend::Btyped_identifier> results;\n+    Backend::typed_identifier receiver;\n+    std::vector<Backend::typed_identifier> parameters;\n+    std::vector<Backend::typed_identifier> results;\n \n     if (!type.get_return_type ()->is_unit ())\n       {\n \tauto hir_type = type.get_return_type ();\n \tauto ret = TyTyCompile::compile (backend, hir_type);\n-\tresults.push_back (Backend::Btyped_identifier (\n+\tresults.push_back (Backend::typed_identifier (\n \t  \"_\", ret, mappings->lookup_location (hir_type->get_ref ())));\n       }\n \n@@ -90,7 +90,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \tauto param_tyty = params.second;\n \tauto compiled_param_type = TyTyCompile::compile (backend, param_tyty);\n \n-\tauto compiled_param = Backend::Btyped_identifier (\n+\tauto compiled_param = Backend::typed_identifier (\n \t  param_pattern->as_string (), compiled_param_type,\n \t  mappings->lookup_location (param_tyty->get_ref ()));\n \n@@ -227,7 +227,7 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -248,7 +248,7 @@ class TyTyCompile : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  tree translated;\n   Analysis::Mappings *mappings;\n };\n "}, {"sha": "a964fa2206bfa015b3b74983a94530aa9ea4d1a6", "filename": "gcc/rust/backend/rust-compile-var-decl.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-var-decl.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -29,8 +29,7 @@ class CompileVarDecl : public HIRCompileBase\n   using Rust::Compile::HIRCompileBase::visit;\n \n public:\n-  static ::Bvariable *compile (::Bfunction *fndecl, HIR::Stmt *stmt,\n-\t\t\t       Context *ctx)\n+  static ::Bvariable *compile (tree fndecl, HIR::Stmt *stmt, Context *ctx)\n   {\n     CompileVarDecl compiler (ctx, fndecl);\n     stmt->accept_vis (compiler);\n@@ -64,13 +63,13 @@ class CompileVarDecl : public HIRCompileBase\n   }\n \n private:\n-  CompileVarDecl (Context *ctx, ::Bfunction *fndecl)\n+  CompileVarDecl (Context *ctx, tree fndecl)\n     : HIRCompileBase (ctx), fndecl (fndecl), translated_type (nullptr),\n       translated (nullptr)\n   {}\n \n-  ::Bfunction *fndecl;\n-  ::Btype *translated_type;\n+  tree fndecl;\n+  tree translated_type;\n   Location locus;\n   ::Bvariable *translated;\n };"}, {"sha": "579b323ab8bb2c2af414721e85e05936f982dcc9", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 57, "deletions": 267, "changes": 324, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -72,15 +72,15 @@ CompileExpr::visit (HIR::CallExpr &expr)\n     {\n       rust_assert (tyty->get_kind () == TyTy::TypeKind::ADT);\n       TyTy::ADTType *adt = static_cast<TyTy::ADTType *> (tyty);\n-      Btype *compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n+      tree compiled_adt_type = TyTyResolveCompile::compile (ctx, tyty);\n \n       rust_assert (!adt->is_enum ());\n       rust_assert (adt->number_of_variants () == 1);\n       auto variant = adt->get_variants ().at (0);\n \n       // this assumes all fields are in order from type resolution and if a\n       // base struct was specified those fields are filed via accesors\n-      std::vector<Bexpression *> vals;\n+      std::vector<tree> vals;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -150,7 +150,7 @@ CompileExpr::visit (HIR::CallExpr &expr)\n \t  required_num_args = fn->num_params ();\n \t}\n \n-      std::vector<Bexpression *> args;\n+      std::vector<tree> args;\n       for (size_t i = 0; i < expr.get_arguments ().size (); i++)\n \t{\n \t  auto &argument = expr.get_arguments ().at (i);\n@@ -195,7 +195,7 @@ void\n CompileExpr::visit (HIR::MethodCallExpr &expr)\n {\n   // method receiver\n-  Bexpression *self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n+  tree self = CompileExpr::Compile (expr.get_receiver ().get (), ctx);\n \n   // lookup the resolved name\n   NodeId resolved_node_id = UNKNOWN_NODEID;\n@@ -242,220 +242,21 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n       const TyTy::DynamicObjectType *dyn\n \t= static_cast<const TyTy::DynamicObjectType *> (receiver->get_root ());\n \n-      size_t offs = 0;\n-      const Resolver::TraitItemReference *ref = nullptr;\n-      for (auto &bound : dyn->get_object_items ())\n-\t{\n-\t  const Resolver::TraitItemReference *item = bound.first;\n-\t  auto t = item->get_tyty ();\n-\t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n-\t  auto ft = static_cast<TyTy::FnType *> (t);\n-\n-\t  if (ft->get_id () == fntype->get_id ())\n-\t    {\n-\t      ref = item;\n-\t      break;\n-\t    }\n-\t  offs++;\n-\t}\n-\n-      if (ref == nullptr)\n-\t{\n-\t  translated = ctx->get_backend ()->error_expression ();\n-\t  return;\n-\t}\n-\n-      // get any indirection sorted out\n-      auto receiver_ref = self;\n-      if (receiver->get_kind () == TyTy::TypeKind::REF)\n-\t{\n-\t  TyTy::ReferenceType *r\n-\t    = static_cast<TyTy::ReferenceType *> (receiver);\n-\t  auto indirect_ty = r->get_base ();\n-\t  Btype *indrect_compiled_tyty\n-\t    = TyTyResolveCompile::compile (ctx, indirect_ty);\n-\n-\t  Bexpression *indirect\n-\t    = ctx->get_backend ()->indirect_expression (indrect_compiled_tyty,\n-\t\t\t\t\t\t\treceiver_ref, true,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\t  receiver_ref = indirect;\n-\t}\n-\n-      // access the offs + 1 for the fnptr and offs=0 for the reciever obj\n-      Bexpression *self_argument\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, 0,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // access the vtable for the fn\n-      Bexpression *fn_vtable_access\n-\t= ctx->get_backend ()->struct_field_expression (receiver_ref, offs + 1,\n-\t\t\t\t\t\t\texpr.get_locus ());\n-\n-      // cast it to the correct fntype\n-      Btype *expected_fntype = TyTyResolveCompile::compile (ctx, fntype, true);\n-      Bexpression *fn_convert_expr\n-\t= ctx->get_backend ()->convert_expression (expected_fntype,\n-\t\t\t\t\t\t   fn_vtable_access,\n-\t\t\t\t\t\t   expr.get_locus ());\n-\n-      fncontext fnctx = ctx->peek_fn ();\n-      Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-      bool is_address_taken = false;\n-      Bstatement *ret_var_stmt = nullptr;\n-\n-      Bvariable *fn_convert_expr_tmp = ctx->get_backend ()->temporary_variable (\n-\tfnctx.fndecl, enclosing_scope, expected_fntype, fn_convert_expr,\n-\tis_address_taken, expr.get_locus (), &ret_var_stmt);\n-      ctx->add_statement (ret_var_stmt);\n-\n-      std::vector<Bexpression *> args;\n-      args.push_back (self_argument);\n-      for (auto &argument : expr.get_arguments ())\n-\t{\n-\t  Bexpression *compiled_expr\n-\t    = CompileExpr::Compile (argument.get (), ctx);\n-\t  args.push_back (compiled_expr);\n-\t}\n-\n-      Bexpression *fn_expr\n-\t= ctx->get_backend ()->var_expression (fn_convert_expr_tmp,\n-\t\t\t\t\t       expr.get_locus ());\n+      std::vector<HIR::Expr *> arguments;\n+      for (auto &arg : expr.get_arguments ())\n+\targuments.push_back (arg.get ());\n \n-      translated\n-\t= ctx->get_backend ()->call_expression (fnctx.fndecl, fn_expr, args,\n-\t\t\t\t\t\tnullptr, expr.get_locus ());\n+      translated = compile_dyn_dispatch_call (dyn, receiver, fntype, self,\n+\t\t\t\t\t      arguments, expr.get_locus ());\n       return;\n     }\n \n-  // address of compiled function\n-  Bexpression *fn_expr = ctx->get_backend ()->error_expression ();\n-\n   // lookup compiled functions since it may have already been compiled\n-  Bfunction *fn = nullptr;\n-  if (ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-    {\n-      fn_expr\n-\t= ctx->get_backend ()->function_code_expression (fn, expr.get_locus ());\n-    }\n-  else\n-    {\n-      // Now we can try and resolve the address since this might be a forward\n-      // declared function, generic function which has not be compiled yet or\n-      // its an not yet trait bound function\n-      HIR::ImplItem *resolved_item = ctx->get_mappings ()->lookup_hir_implitem (\n-\texpr.get_mappings ().get_crate_num (), ref, nullptr);\n-      if (resolved_item == nullptr)\n-\t{\n-\t  // it might be resolved to a trait item\n-\t  HIR::TraitItem *trait_item\n-\t    = ctx->get_mappings ()->lookup_hir_trait_item (\n-\t      expr.get_mappings ().get_crate_num (), ref);\n-\t  HIR::Trait *trait = ctx->get_mappings ()->lookup_trait_item_mapping (\n-\t    trait_item->get_mappings ().get_hirid ());\n-\n-\t  Resolver::TraitReference *trait_ref\n-\t    = &Resolver::TraitReference::error_node ();\n-\t  bool ok = ctx->get_tyctx ()->lookup_trait_reference (\n-\t    trait->get_mappings ().get_defid (), &trait_ref);\n-\t  rust_assert (ok);\n-\n-\t  // the type resolver can only resolve type bounds to their trait\n-\t  // item so its up to us to figure out if this path should resolve\n-\t  // to an trait-impl-block-item or if it can be defaulted to the\n-\t  // trait-impl-item's definition\n-\n-\t  auto root = receiver->get_root ();\n-\t  std::vector<Resolver::PathProbeCandidate> candidates\n-\t    = Resolver::PathProbeType::Probe (\n-\t      root, expr.get_method_name ().get_segment (), true, false, true);\n-\n-\t  if (candidates.size () == 0)\n-\t    {\n-\t      // this means we are defaulting back to the trait_item if\n-\t      // possible\n-\t      Resolver::TraitItemReference *trait_item_ref = nullptr;\n-\t      bool ok = trait_ref->lookup_hir_trait_item (*trait_item,\n-\t\t\t\t\t\t\t  &trait_item_ref);\n-\t      rust_assert (ok);\t\t\t\t    // found\n-\t      rust_assert (trait_item_ref->is_optional ()); // has definition\n-\n-\t      // FIXME Optional means it has a definition and an associated\n-\t      // block which can be a default implementation, if it does not\n-\t      // contain an implementation we should actually return\n-\t      // error_mark_node\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      fn_expr = CompileTraitItem::Compile (\n-\t\tself_type, trait_item_ref->get_hir_trait_item (), ctx, fntype,\n-\t\ttrue, expr.get_locus ());\n-\t    }\n-\t  else\n-\t    {\n-\t      std::vector<Resolver::Adjustment> adjustments;\n-\t      Resolver::PathProbeCandidate *candidate\n-\t\t= Resolver::MethodResolution::Select (candidates, root,\n-\t\t\t\t\t\t      adjustments);\n-\n-\t      // FIXME this will be a case to return error_mark_node, there is\n-\t      // an error scenario where a Trait Foo has a method Bar, but this\n-\t      // receiver does not implement this trait or has an incompatible\n-\t      // implementation and we should just return error_mark_node\n-\t      rust_assert (candidate != nullptr);\n-\t      rust_assert (candidate->is_impl_candidate ());\n-\n-\t      HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n-\n-\t      TyTy::BaseType *self_type = nullptr;\n-\t      if (!ctx->get_tyctx ()->lookup_type (\n-\t\t    expr.get_receiver ()->get_mappings ().get_hirid (),\n-\t\t    &self_type))\n-\t\t{\n-\t\t  rust_error_at (expr.get_locus (),\n-\t\t\t\t \"failed to resolve type for self param\");\n-\t\t  return;\n-\t\t}\n-\n-\t      if (!fntype->has_subsititions_defined ())\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true);\n-\t      else\n-\t\tfn_expr\n-\t\t  = CompileInherentImplItem::Compile (self_type, impl_item, ctx,\n-\t\t\t\t\t\t      true, fntype);\n-\t    }\n-\t}\n-      else\n-\t{\n-\t  TyTy::BaseType *self_type = nullptr;\n-\t  if (!ctx->get_tyctx ()->lookup_type (\n-\t\texpr.get_receiver ()->get_mappings ().get_hirid (), &self_type))\n-\t    {\n-\t      rust_error_at (expr.get_locus (),\n-\t\t\t     \"failed to resolve type for self param\");\n-\t      return;\n-\t    }\n-\n-\t  if (!fntype->has_subsititions_defined ())\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true);\n-\t  else\n-\t    fn_expr\n-\t      = CompileInherentImplItem::Compile (self_type, resolved_item, ctx,\n-\t\t\t\t\t\t  true, fntype);\n-\t}\n-    }\n+  HIR::PathExprSegment method_name = expr.get_method_name ();\n+  HIR::PathIdentSegment segment_name = method_name.get_segment ();\n+  tree fn_expr\n+    = resolve_method_address (fntype, ref, receiver, segment_name,\n+\t\t\t      expr.get_mappings (), expr.get_locus ());\n \n   // lookup the autoderef mappings\n   std::vector<Resolver::Adjustment> *adjustments = nullptr;\n@@ -474,7 +275,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t  break;\n \n \tcase Resolver::Adjustment::AdjustmentType::DEREF_REF:\n-\t  Btype *expected_type\n+\t  tree expected_type\n \t    = TyTyResolveCompile::compile (ctx, adjustment.get_expected ());\n \t  self = ctx->get_backend ()->indirect_expression (\n \t    expected_type, self, true, /* known_valid*/\n@@ -483,7 +284,7 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \t}\n     }\n \n-  std::vector<Bexpression *> args;\n+  std::vector<tree> args;\n   args.push_back (self); // adjusted self\n \n   // normal args\n@@ -521,7 +322,7 @@ void\n CompileBlock::visit (HIR::BlockExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n+  tree fndecl = fnctx.fndecl;\n   Location start_location = expr.get_locus ();\n   Location end_location = expr.get_closing_locus ();\n   auto body_mappings = expr.get_mappings ();\n@@ -537,18 +338,17 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n   bool ok = compile_locals_for_block (*rib, fndecl, locals);\n   rust_assert (ok);\n \n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-  Bblock *new_block\n-    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t  start_location, end_location);\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree new_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t       start_location, end_location);\n   ctx->push_block (new_block);\n \n   for (auto &s : expr.get_statements ())\n     {\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n@@ -559,23 +359,22 @@ CompileBlock::visit (HIR::BlockExpr &expr)\n     {\n       // the previous passes will ensure this is a valid return or\n       // a valid trailing expression\n-      Bexpression *compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n+      tree compiled_expr = CompileExpr::Compile (expr.expr.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n \t  if (result == nullptr)\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n \t    }\n \t  else\n \t    {\n-\t      Bexpression *result_reference\n-\t\t= ctx->get_backend ()->var_expression (\n-\t\t  result, expr.get_final_expr ()->get_locus ());\n+\t      tree result_reference = ctx->get_backend ()->var_expression (\n+\t\tresult, expr.get_final_expr ()->get_locus ());\n \n-\t      Bstatement *assignment\n+\t      tree assignment\n \t\t= ctx->get_backend ()->assignment_statement (fnctx.fndecl,\n \t\t\t\t\t\t\t     result_reference,\n \t\t\t\t\t\t\t     compiled_expr,\n@@ -593,11 +392,9 @@ void\n CompileConditionalBlocks::visit (HIR::IfExpr &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -608,13 +405,10 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqElse &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n-  Bblock *else_block\n-    = CompileBlock::compile (expr.get_else_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree else_block = CompileBlock::compile (expr.get_else_block (), ctx, result);\n \n   translated\n     = ctx->get_backend ()->if_statement (fndecl, condition_expr, then_block,\n@@ -625,23 +419,20 @@ void\n CompileConditionalBlocks::visit (HIR::IfExprConseqIf &expr)\n {\n   fncontext fnctx = ctx->peek_fn ();\n-  Bfunction *fndecl = fnctx.fndecl;\n-  Bexpression *condition_expr\n-    = CompileExpr::Compile (expr.get_if_condition (), ctx);\n-  Bblock *then_block\n-    = CompileBlock::compile (expr.get_if_block (), ctx, result);\n+  tree fndecl = fnctx.fndecl;\n+  tree condition_expr = CompileExpr::Compile (expr.get_if_condition (), ctx);\n+  tree then_block = CompileBlock::compile (expr.get_if_block (), ctx, result);\n \n   // else block\n   std::vector<Bvariable *> locals;\n   Location start_location = expr.get_conseq_if_expr ()->get_locus ();\n   Location end_location = expr.get_conseq_if_expr ()->get_locus (); // FIXME\n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n-  Bblock *else_block\n-    = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n-\t\t\t\t  start_location, end_location);\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree else_block = ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t\t\tstart_location, end_location);\n   ctx->push_block (else_block);\n \n-  Bstatement *else_stmt_decl\n+  tree else_stmt_decl\n     = CompileConditionalBlocks::compile (expr.get_conseq_if_expr (), ctx,\n \t\t\t\t\t result);\n   ctx->add_statement (else_stmt_decl);\n@@ -681,15 +472,15 @@ CompileStructExprField::visit (HIR::StructExprFieldIdentifier &field)\n \n void\n HIRCompileBase::compile_function_body (\n-  Bfunction *fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n+  tree fndecl, std::unique_ptr<HIR::BlockExpr> &function_body,\n   bool has_return_type)\n {\n   for (auto &s : function_body->get_statements ())\n     {\n       auto compiled_expr = CompileStmt::Compile (s.get (), ctx);\n       if (compiled_expr != nullptr)\n \t{\n-\t  Bstatement *compiled_stmt\n+\t  tree compiled_stmt\n \t    = ctx->get_backend ()->expression_statement (fndecl, compiled_expr);\n \t  ctx->add_statement (compiled_stmt);\n \t}\n@@ -699,14 +490,14 @@ HIRCompileBase::compile_function_body (\n     {\n       // the previous passes will ensure this is a valid return\n       // or a valid trailing expression\n-      Bexpression *compiled_expr\n+      tree compiled_expr\n \t= CompileExpr::Compile (function_body->expr.get (), ctx);\n \n       if (compiled_expr != nullptr)\n \t{\n \t  if (has_return_type)\n \t    {\n-\t      std::vector<Bexpression *> retstmts;\n+\t      std::vector<tree> retstmts;\n \t      retstmts.push_back (compiled_expr);\n \n \t      auto ret = ctx->get_backend ()->return_statement (\n@@ -716,7 +507,7 @@ HIRCompileBase::compile_function_body (\n \t    }\n \t  else\n \t    {\n-\t      Bstatement *final_stmt\n+\t      tree final_stmt\n \t\t= ctx->get_backend ()->expression_statement (fndecl,\n \t\t\t\t\t\t\t     compiled_expr);\n \t      ctx->add_statement (final_stmt);\n@@ -726,7 +517,7 @@ HIRCompileBase::compile_function_body (\n }\n \n bool\n-HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n+HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, tree fndecl,\n \t\t\t\t\t  std::vector<Bvariable *> &locals)\n {\n   rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n@@ -760,10 +551,9 @@ HIRCompileBase::compile_locals_for_block (Resolver::Rib &rib, Bfunction *fndecl,\n   return true;\n }\n \n-Bexpression *\n-HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n-\t\t\t       TyTy::BaseType *actual, TyTy::BaseType *expected,\n-\t\t\t       Location locus)\n+tree\n+HIRCompileBase::coercion_site (tree compiled_ref, TyTy::BaseType *actual,\n+\t\t\t       TyTy::BaseType *expected, Location locus)\n {\n   auto root_actual_kind = actual->get_root ()->get_kind ();\n   auto root_expected_kind = expected->get_root ()->get_kind ();\n@@ -779,14 +569,14 @@ HIRCompileBase::coercion_site (Bexpression *compiled_ref,\n   return compiled_ref;\n }\n \n-Bexpression *\n-HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n+tree\n+HIRCompileBase::coerce_to_dyn_object (tree compiled_ref,\n \t\t\t\t      const TyTy::BaseType *actual,\n \t\t\t\t      const TyTy::BaseType *expected,\n \t\t\t\t      const TyTy::DynamicObjectType *ty,\n \t\t\t\t      Location locus)\n {\n-  Btype *dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n+  tree dynamic_object = TyTyResolveCompile::compile (ctx, ty);\n \n   //' this assumes ordering and current the structure is\n   // __trait_object_ptr\n@@ -796,7 +586,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n     probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n \n-  std::vector<Bexpression *> vals;\n+  std::vector<tree> vals;\n   vals.push_back (compiled_ref);\n   for (auto &bound : ty->get_object_items ())\n     {\n@@ -809,14 +599,14 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n       vals.push_back (address);\n     }\n \n-  Bexpression *constructed_trait_object\n+  tree constructed_trait_object\n     = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n \t\t\t\t\t\t   locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n-  Bblock *enclosing_scope = ctx->peek_enclosing_scope ();\n+  tree enclosing_scope = ctx->peek_enclosing_scope ();\n   bool is_address_taken = false;\n-  Bstatement *ret_var_stmt = nullptr;\n+  tree ret_var_stmt = NULL_TREE;\n \n   Bvariable *dyn_tmp = ctx->get_backend ()->temporary_variable (\n     fnctx.fndecl, enclosing_scope, dynamic_object, constructed_trait_object,\n@@ -858,7 +648,7 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   return resulting_dyn_object_ref;\n }\n \n-Bexpression *\n+tree\n HIRCompileBase::compute_address_for_trait_item (\n   const Resolver::TraitItemReference *ref,\n   const TyTy::TypeBoundPredicate *predicate,"}, {"sha": "f36096b44efc548c11446e7265ecf10ea21cfd94", "filename": "gcc/rust/hir/rust-ast-lower-expr.h", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -452,11 +452,8 @@ class ASTLoweringExpr : public ASTLoweringBase\n \t\t\t       expr.get_locus ());\n   }\n \n-  /* Compound assignment expression is compiled away. */\n   void visit (AST::CompoundAssignmentExpr &expr) override\n   {\n-    /* First we need to find the corresponding arithmetic or logical operator.\n-     */\n     ArithmeticOrLogicalOperator op;\n     switch (expr.get_expr_type ())\n       {\n@@ -503,15 +500,10 @@ class ASTLoweringExpr : public ASTLoweringBase\n     Analysis::NodeMapping mapping (crate_num, expr.get_node_id (),\n \t\t\t\t   mappings->get_next_hir_id (crate_num),\n \t\t\t\t   UNKNOWN_LOCAL_DEFID);\n-    HIR::Expr *operator_expr\n-      = new HIR::ArithmeticOrLogicalExpr (mapping, asignee_expr->clone_expr (),\n-\t\t\t\t\t  std::unique_ptr<HIR::Expr> (value),\n-\t\t\t\t\t  op, expr.get_locus ());\n-    translated\n-      = new HIR::AssignmentExpr (mapping,\n-\t\t\t\t std::unique_ptr<HIR::Expr> (asignee_expr),\n-\t\t\t\t std::unique_ptr<HIR::Expr> (operator_expr),\n-\t\t\t\t expr.get_locus ());\n+\n+    translated = new HIR::CompoundAssignmentExpr (\n+      mapping, std::unique_ptr<HIR::Expr> (asignee_expr),\n+      std::unique_ptr<HIR::Expr> (value), op, expr.get_locus ());\n   }\n \n   void visit (AST::StructExprStruct &struct_expr) override"}, {"sha": "65a49213986968e4afda2789f0586988d344a917", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -613,29 +613,6 @@ class ASTLoweringItem : public ASTLoweringBase\n     if (trait.has_generics ())\n       {\n \tgeneric_params = lower_generic_params (trait.get_generic_params ());\n-\n-\tfor (auto &generic_param : generic_params)\n-\t  {\n-\t    switch (generic_param->get_kind ())\n-\t      {\n-\t\tcase HIR::GenericParam::GenericKind::TYPE: {\n-\t\t  const HIR::TypeParam &t\n-\t\t    = static_cast<const HIR::TypeParam &> (*generic_param);\n-\n-\t\t  if (t.has_type ())\n-\t\t    {\n-\t\t      // see https://github.com/rust-lang/rust/issues/36887\n-\t\t      rust_error_at (\n-\t\t\tt.get_locus (),\n-\t\t\t\"defaults for type parameters are not allowed here\");\n-\t\t    }\n-\t\t}\n-\t\tbreak;\n-\n-\t      default:\n-\t\tbreak;\n-\t      }\n-\t  }\n       }\n \n     std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;"}, {"sha": "901feda5e316790ccc1df271fcbee575ce0357cb", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 74, "deletions": 5, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -666,6 +666,80 @@ class AssignmentExpr : public OperatorExpr\n   }\n };\n \n+class CompoundAssignmentExpr : public OperatorExpr\n+{\n+public:\n+  using ExprType = ArithmeticOrLogicalOperator;\n+\n+private:\n+  // Note: overloading trait specified in comments\n+  ExprType expr_type;\n+  std::unique_ptr<Expr> right_expr;\n+\n+public:\n+  std::string as_string () const override;\n+\n+  ExprType get_expr_type () const { return expr_type; }\n+\n+  // Use pointers in constructor to enable polymorphism\n+  CompoundAssignmentExpr (Analysis::NodeMapping mappings,\n+\t\t\t  std::unique_ptr<Expr> value_to_assign_to,\n+\t\t\t  std::unique_ptr<Expr> value_to_assign,\n+\t\t\t  ExprType expr_kind, Location locus)\n+    : OperatorExpr (std::move (mappings), std::move (value_to_assign_to),\n+\t\t    AST::AttrVec (), locus),\n+      expr_type (expr_kind), right_expr (std::move (value_to_assign))\n+  {}\n+  // outer attributes not allowed\n+\n+  // Have clone in copy constructor\n+  CompoundAssignmentExpr (CompoundAssignmentExpr const &other)\n+    : OperatorExpr (other), expr_type (other.expr_type),\n+      right_expr (other.right_expr->clone_expr ())\n+  {}\n+\n+  // Overload assignment operator to clone\n+  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr const &other)\n+  {\n+    OperatorExpr::operator= (other);\n+    // main_or_left_expr = other.main_or_left_expr->clone_expr();\n+    right_expr = other.right_expr->clone_expr ();\n+    expr_type = other.expr_type;\n+    // outer_attrs = other.outer_attrs;\n+\n+    return *this;\n+  }\n+\n+  // move constructors\n+  CompoundAssignmentExpr (CompoundAssignmentExpr &&other) = default;\n+  CompoundAssignmentExpr &operator= (CompoundAssignmentExpr &&other) = default;\n+\n+  void accept_vis (HIRVisitor &vis) override;\n+\n+  std::unique_ptr<Expr> &get_left_expr ()\n+  {\n+    rust_assert (main_or_left_expr != nullptr);\n+    return main_or_left_expr;\n+  }\n+\n+  std::unique_ptr<Expr> &get_right_expr ()\n+  {\n+    rust_assert (right_expr != nullptr);\n+    return right_expr;\n+  }\n+\n+  void visit_lhs (HIRVisitor &vis) { main_or_left_expr->accept_vis (vis); }\n+  void visit_rhs (HIRVisitor &vis) { right_expr->accept_vis (vis); }\n+\n+protected:\n+  /* Use covariance to implement clone function as returning this object rather\n+   * than base */\n+  CompoundAssignmentExpr *clone_expr_without_block_impl () const override\n+  {\n+    return new CompoundAssignmentExpr (*this);\n+  }\n+};\n+\n // Expression in parentheses (i.e. like literally just any 3 + (2 * 6))\n class GroupedExpr : public ExprWithoutBlock\n {\n@@ -1635,18 +1709,13 @@ class MethodCallExpr : public ExprWithoutBlock\n {\n   std::unique_ptr<Expr> receiver;\n   PathExprSegment method_name;\n-  // inlined form of CallParams\n   std::vector<std::unique_ptr<Expr> > params;\n \n   Location locus;\n \n public:\n   std::string as_string () const override;\n \n-  /*inline std::vector<std::unique_ptr<Expr>> get_params() const {\n-      return params;\n-  }*/\n-\n   MethodCallExpr (Analysis::NodeMapping mappings,\n \t\t  std::unique_ptr<Expr> call_receiver,\n \t\t  PathExprSegment method_path,"}, {"sha": "843e32ca1af6f558954468b7cbfd6b29fc5f5f47", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1315,6 +1315,67 @@ AssignmentExpr::as_string () const\n \t + \"::\" + get_mappings ().as_string ();\n }\n \n+std::string\n+CompoundAssignmentExpr::as_string () const\n+{\n+  std::string operator_str;\n+  operator_str.reserve (1);\n+\n+  // get operator string\n+  switch (expr_type)\n+    {\n+    case ArithmeticOrLogicalOperator::ADD:\n+      operator_str = \"+\";\n+      break;\n+    case ArithmeticOrLogicalOperator::SUBTRACT:\n+      operator_str = \"-\";\n+      break;\n+    case ArithmeticOrLogicalOperator::MULTIPLY:\n+      operator_str = \"*\";\n+      break;\n+    case ArithmeticOrLogicalOperator::DIVIDE:\n+      operator_str = \"/\";\n+      break;\n+    case ArithmeticOrLogicalOperator::MODULUS:\n+      operator_str = \"%\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_AND:\n+      operator_str = \"&\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_OR:\n+      operator_str = \"|\";\n+      break;\n+    case ArithmeticOrLogicalOperator::BITWISE_XOR:\n+      operator_str = \"^\";\n+      break;\n+    case ArithmeticOrLogicalOperator::LEFT_SHIFT:\n+      operator_str = \"<<\";\n+      break;\n+    case ArithmeticOrLogicalOperator::RIGHT_SHIFT:\n+      operator_str = \">>\";\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+\n+  operator_str += \"=\";\n+\n+  std::string str (\"CompoundAssignmentExpr: \");\n+  if (main_or_left_expr == nullptr || right_expr == nullptr)\n+    {\n+      str += \"error. this is probably a parsing failure.\";\n+    }\n+  else\n+    {\n+      str += \"\\n left: \" + main_or_left_expr->as_string ();\n+      str += \"\\n right: \" + right_expr->as_string ();\n+      str += \"\\n operator: \" + operator_str;\n+    }\n+\n+  return str;\n+}\n+\n std::string\n AsyncBlockExpr::as_string () const\n {\n@@ -3818,6 +3879,12 @@ AssignmentExpr::accept_vis (HIRVisitor &vis)\n   vis.visit (*this);\n }\n \n+void\n+CompoundAssignmentExpr::accept_vis (HIRVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n void\n GroupedExpr::accept_vis (HIRVisitor &vis)\n {"}, {"sha": "ea125d9d082f53cb9e82454cfc59ac6f05bf480a", "filename": "gcc/rust/hir/tree/rust-hir-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-visitor.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -47,6 +47,7 @@ class HIRVisitor\n   virtual void visit (LazyBooleanExpr &expr) = 0;\n   virtual void visit (TypeCastExpr &expr) = 0;\n   virtual void visit (AssignmentExpr &expr) = 0;\n+  virtual void visit (CompoundAssignmentExpr &expr) = 0;\n   virtual void visit (GroupedExpr &expr) = 0;\n   virtual void visit (ArrayElemsValues &elems) = 0;\n   virtual void visit (ArrayElemsCopied &elems) = 0;"}, {"sha": "e0494d702eb25cb10e6477be09fdc5b72543824a", "filename": "gcc/rust/lint/rust-lint-marklive-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive-base.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -53,7 +53,7 @@ class MarkLiveBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "bcf792b98626b766e7ba9f028c358b5f84863399", "filename": "gcc/rust/lint/rust-lint-marklive.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Flint%2Frust-lint-marklive.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flint%2Frust-lint-marklive.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -186,6 +186,12 @@ class MarkLive : public MarkLiveBase\n     expr.visit_rhs (*this);\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override\n+  {\n+    expr.visit_lhs (*this);\n+    expr.visit_rhs (*this);\n+  }\n+\n   void visit (HIR::IfExpr &expr) override\n   {\n     expr.get_if_condition ()->accept_vis (*this);"}, {"sha": "f60732c6f77d13e792700e5cdca945eecda22c18", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -35,29 +35,14 @@ class ResolveTraitItems : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n-  static void go (AST::TraitItem *item, const CanonicalPath &self)\n+  static void go (AST::TraitItem *item)\n   {\n-    ResolveTraitItems resolver (self);\n+    ResolveTraitItems resolver;\n     item->accept_vis (resolver);\n   };\n \n   void visit (AST::TraitItemType &type) override\n   {\n-    // insert Self::type_alias for TypePath lookup\n-    auto path\n-      = self.append (ResolveTraitItemTypeToCanonicalPath::resolve (type));\n-    resolver->get_type_scope ().insert (\n-      path, type.get_node_id (), type.get_locus (), false,\n-      [&] (const CanonicalPath &, NodeId, Location locus) -> void {\n-\tRichLocation r (type.get_locus ());\n-\tr.add_range (locus);\n-\trust_error_at (r, \"redefined multiple times\");\n-      });\n-\n-    // FIXME this stops the erronious unused decls which will be fixed later on\n-    resolver->get_type_scope ().append_reference_for_def (type.get_node_id (),\n-\t\t\t\t\t\t\t  type.get_node_id ());\n-\n     for (auto &bound : type.get_type_param_bounds ())\n       ResolveTypeBound::go (bound.get (), type.get_node_id ());\n   }\n@@ -189,11 +174,7 @@ class ResolveTraitItems : public ResolverBase\n   }\n \n private:\n-  ResolveTraitItems (const CanonicalPath &self)\n-    : ResolverBase (UNKNOWN_NODEID), self (self)\n-  {}\n-\n-  const CanonicalPath &self;\n+  ResolveTraitItems () : ResolverBase (UNKNOWN_NODEID) {}\n };\n \n class ResolveItem : public ResolverBase\n@@ -649,7 +630,7 @@ class ResolveItem : public ResolverBase\n \n     for (auto &item : trait.get_trait_items ())\n       {\n-\tResolveTraitItems::go (item.get (), Self);\n+\tResolveTraitItems::go (item.get ());\n       }\n \n     resolver->get_type_scope ().pop ();"}, {"sha": "2bcf79d3decb424171b5ce5ee618dcf6d237503f", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -101,6 +101,7 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n   using Rust::Resolver::ResolverBase::visit;\n \n public:\n+  // FIXME this should really only take AST::TypeNoBounds&\n   static CanonicalPath resolve (AST::Type &type,\n \t\t\t\tbool include_generic_args = true,\n \t\t\t\tbool type_resolve_generic_args = true)\n@@ -121,6 +122,8 @@ class ResolveTypeToCanonicalPath : public ResolverBase\n       }\n   }\n \n+  void visit (AST::ReferenceType &ref) override;\n+\n   void visit (AST::TypePathSegmentGeneric &seg) override;\n \n   void visit (AST::TypePathSegment &seg) override;"}, {"sha": "9a0d349a2fd553b6622b94074d2b0c917642ca41", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -439,8 +439,10 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n \n   if (!seg.has_generic_args ())\n     {\n-      result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t       seg.get_ident_segment ().as_string ());\n+      auto ident_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ());\n+      result = result.append (ident_segment);\n       return;\n     }\n \n@@ -454,14 +456,18 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegmentGeneric &seg)\n     {\n       std::string generics\n \t= canonicalize_generic_args (seg.get_generic_args ());\n-      result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t       seg.get_ident_segment ().as_string ()\n-\t\t\t\t\t + \"::\" + generics);\n+      auto generic_segment\n+\t= CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t\t  seg.get_ident_segment ().as_string ()\n+\t\t\t\t    + \"::\" + generics);\n+      result = result.append (generic_segment);\n       return;\n     }\n \n-  result = CanonicalPath::new_seg (seg.get_node_id (),\n-\t\t\t\t   seg.get_ident_segment ().as_string ());\n+  auto ident_segment\n+    = CanonicalPath::new_seg (seg.get_node_id (),\n+\t\t\t      seg.get_ident_segment ().as_string ());\n+  result = result.append (ident_segment);\n }\n \n void\n@@ -481,6 +487,24 @@ ResolveTypeToCanonicalPath::visit (AST::TypePathSegment &seg)\n   result = result.append (ident_seg);\n }\n \n+void\n+ResolveTypeToCanonicalPath::visit (AST::ReferenceType &ref)\n+{\n+  auto inner_type\n+    = ResolveTypeToCanonicalPath::resolve (*ref.get_type_referenced ().get (),\n+\t\t\t\t\t   include_generic_args_flag,\n+\t\t\t\t\t   type_resolve_generic_args_flag);\n+\n+  std::string segment_string (\"&\");\n+  if (ref.get_has_mut ())\n+    segment_string += \"mut \";\n+\n+  segment_string += inner_type.get ();\n+\n+  auto ident_seg = CanonicalPath::new_seg (ref.get_node_id (), segment_string);\n+  result = result.append (ident_seg);\n+}\n+\n // rust-ast-resolve-expr.h\n \n void"}, {"sha": "d362fe431de4676553de4e58e1e592614ff780e8", "filename": "gcc/rust/resolve/rust-ast-verify-assignee.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-verify-assignee.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -75,6 +75,13 @@ class VerifyAsignee : public ResolverBase\n       }\n   }\n \n+  void visit (AST::DereferenceExpr &expr) override\n+  {\n+    expr.get_dereferenced_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (AST::PathInExpression &expr) override { ok = true; }\n+\n private:\n   VerifyAsignee (NodeId parent) : ResolverBase (parent), ok (false) {}\n "}, {"sha": "64144bcaf805ea15a7fbb8ea20c69d968b6f93d1", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 157, "deletions": 297, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -29,6 +29,8 @@\n #include \"operator.h\"\n #include \"rust-abi.h\"\n \n+#include \"tree.h\"\n+\n extern bool\n saw_errors (void);\n \n@@ -39,27 +41,9 @@ saw_errors (void);\n // frontend, and passed back to the backend.  The types must be\n // defined by the backend using these names.\n \n-// The backend representation of a type.\n-class Btype;\n-\n-// The backend represention of an expression.\n-class Bexpression;\n-\n-// The backend representation of a statement.\n-class Bstatement;\n-\n-// The backend representation of a function definition or declaration.\n-class Bfunction;\n-\n-// The backend representation of a block.\n-class Bblock;\n-\n // The backend representation of a variable.\n class Bvariable;\n \n-// The backend representation of a label.\n-class Blabel;\n-\n // The backend interface.  This is a pure abstract class that a\n // specific backend will implement.\n \n@@ -70,35 +54,30 @@ class Backend\n \n   // Name/type/location.  Used for function parameters, struct fields,\n   // interface methods.\n-  struct Btyped_identifier\n+  struct typed_identifier\n   {\n     std::string name;\n-    Btype *btype;\n+    tree type;\n     Location location;\n \n-    Btyped_identifier ()\n-      : name (), btype (NULL), location (Linemap::unknown_location ())\n+    typed_identifier ()\n+      : name (), type (NULL_TREE), location (Linemap::unknown_location ())\n     {}\n \n-    Btyped_identifier (const std::string &a_name, Btype *a_btype,\n-\t\t       Location a_location)\n-      : name (a_name), btype (a_btype), location (a_location)\n+    typed_identifier (const std::string &a_name, tree a_type,\n+\t\t      Location a_location)\n+      : name (a_name), type (a_type), location (a_location)\n     {}\n   };\n \n   // debug\n-  virtual void debug (Btype *) = 0;\n-  virtual void debug (Bexpression *) = 0;\n-  virtual void debug (Bstatement *) = 0;\n-  virtual void debug (Bfunction *) = 0;\n-  virtual void debug (Bblock *) = 0;\n+  virtual void debug (tree) = 0;\n   virtual void debug (Bvariable *) = 0;\n-  virtual void debug (Blabel *) = 0;\n \n   // const folder helpers\n-  virtual bool const_size_cast (Bexpression *, size_t *) = 0;\n-  virtual std::string const_size_val_to_string (Bexpression *) = 0;\n-  virtual bool const_values_equal (Bexpression *, Bexpression *) = 0;\n+  virtual bool const_size_cast (tree, size_t *) = 0;\n+  virtual std::string const_size_val_to_string (tree) = 0;\n+  virtual bool const_values_equal (tree, tree) = 0;\n \n   static Rust::ABI get_abi_from_string (const std::string &abi, Location locus)\n   {\n@@ -147,50 +126,50 @@ class Backend\n \n   // Produce an error type.  Actually the backend could probably just\n   // crash if this is called.\n-  virtual Btype *error_type () = 0;\n+  virtual tree error_type () = 0;\n \n   // Get a void type.  This is used in (at least) two ways: 1) as the\n   // return type of a function with no result parameters; 2)\n   // unsafe.Pointer is represented as *void.\n-  virtual Btype *void_type () = 0;\n+  virtual tree void_type () = 0;\n \n   // get unit-type\n-  virtual Btype *unit_type () = 0;\n+  virtual tree unit_type () = 0;\n \n   // Get the unnamed boolean type.\n-  virtual Btype *bool_type () = 0;\n+  virtual tree bool_type () = 0;\n \n   // Get the char type\n-  virtual Btype *char_type () = 0;\n+  virtual tree char_type () = 0;\n \n   // Get the wchar type\n-  virtual Btype *wchar_type () = 0;\n+  virtual tree wchar_type () = 0;\n \n   // Get the Host pointer size in bits\n   virtual int get_pointer_size () = 0;\n \n   // Get the raw str type const char*\n-  virtual Btype *raw_str_type () = 0;\n+  virtual tree raw_str_type () = 0;\n \n   // Get an unnamed integer type with the given signedness and number\n   // of bits.\n-  virtual Btype *integer_type (bool is_unsigned, int bits) = 0;\n+  virtual tree integer_type (bool is_unsigned, int bits) = 0;\n \n   // Get an unnamed floating point type with the given number of bits\n   // (32 or 64).\n-  virtual Btype *float_type (int bits) = 0;\n+  virtual tree float_type (int bits) = 0;\n \n   // Get an unnamed complex type with the given number of bits (64 or 128).\n-  virtual Btype *complex_type (int bits) = 0;\n+  virtual tree complex_type (int bits) = 0;\n \n   // Get a pointer type.\n-  virtual Btype *pointer_type (Btype *to_type) = 0;\n+  virtual tree pointer_type (tree to_type) = 0;\n \n   // Get a reference type.\n-  virtual Btype *reference_type (Btype *to_type) = 0;\n+  virtual tree reference_type (tree to_type) = 0;\n \n   // make type immutable\n-  virtual Btype *immutable_type (Btype *base) = 0;\n+  virtual tree immutable_type (tree base) = 0;\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n@@ -201,346 +180,235 @@ class Backend\n   // one result, RESULT_STRUCT is a struct type to hold the results,\n   // and RESULTS may be ignored; if there are zero or one results,\n   // RESULT_STRUCT is NULL.\n-  virtual Btype *\n-  function_type (const Btyped_identifier &receiver,\n-\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t const std::vector<Btyped_identifier> &results,\n-\t\t Btype *result_struct, Location location)\n+  virtual tree function_type (const typed_identifier &receiver,\n+\t\t\t      const std::vector<typed_identifier> &parameters,\n+\t\t\t      const std::vector<typed_identifier> &results,\n+\t\t\t      tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *\n-  function_type_varadic (const Btyped_identifier &receiver,\n-\t\t\t const std::vector<Btyped_identifier> &parameters,\n-\t\t\t const std::vector<Btyped_identifier> &results,\n-\t\t\t Btype *result_struct, Location location)\n+  virtual tree\n+  function_type_varadic (const typed_identifier &receiver,\n+\t\t\t const std::vector<typed_identifier> &parameters,\n+\t\t\t const std::vector<typed_identifier> &results,\n+\t\t\t tree result_struct, Location location)\n     = 0;\n \n-  virtual Btype *function_ptr_type (Btype *result,\n-\t\t\t\t    const std::vector<Btype *> &praameters,\n-\t\t\t\t    Location location)\n+  virtual tree function_ptr_type (tree result,\n+\t\t\t\t  const std::vector<tree> &praameters,\n+\t\t\t\t  Location location)\n     = 0;\n \n   // Get a struct type.\n-  virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree struct_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get a union type.\n-  virtual Btype *union_type (const std::vector<Btyped_identifier> &fields) = 0;\n+  virtual tree union_type (const std::vector<typed_identifier> &fields) = 0;\n \n   // Get an array type.\n-  virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n-\n-  // Create a placeholder pointer type.  This is used for a named\n-  // pointer type, since in Go a pointer type may refer to itself.\n-  // NAME is the name of the type, and the location is where the named\n-  // type is defined.  This function is also used for unnamed function\n-  // types with multiple results, in which case the type has no name\n-  // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n-  // pointer to function type.  A Go func type is represented as a\n-  // pointer to a struct, and the first field of the struct is a C\n-  // pointer to function.  The return value will later be passed as\n-  // the first parameter to set_placeholder_pointer_type or\n-  // set_placeholder_function_type.\n-  virtual Btype *placeholder_pointer_type (const std::string &name, Location,\n-\t\t\t\t\t   bool for_function)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a pointer.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // point to the type that TO_TYPE points to (that is, PLACEHOLDER\n-  // becomes the same type as TO_TYPE).  Returns true on success,\n-  // false on failure.\n-  virtual bool set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-    = 0;\n-\n-  // Fill in a placeholder pointer type as a function.  This takes a\n-  // type returned by placeholder_pointer_type and arranges for it to\n-  // become a real Go function type (which corresponds to a C/C++\n-  // pointer to function type).  FT will be something returned by the\n-  // function_type method.  Returns true on success, false on failure.\n-  virtual bool set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-    = 0;\n-\n-  // Create a placeholder struct type.  This is used for a named\n-  // struct type, as with placeholder_pointer_type.  It is also used\n-  // for interface types, in which case NAME will be the empty string.\n-  virtual Btype *placeholder_struct_type (const std::string &name, Location)\n-    = 0;\n-\n-  // Fill in a placeholder struct type.  This takes a type returned by\n-  // placeholder_struct_type and arranges for it to become a real\n-  // struct type.  The parameter is as for struct_type.  Returns true\n-  // on success, false on failure.\n-  virtual bool\n-  set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t       const std::vector<Btyped_identifier> &fields)\n-    = 0;\n-\n-  // Create a placeholder array type.  This is used for a named array\n-  // type, as with placeholder_pointer_type, to handle cases like\n-  // type A []*A.\n-  virtual Btype *placeholder_array_type (const std::string &name, Location) = 0;\n-\n-  // Fill in a placeholder array type.  This takes a type returned by\n-  // placeholder_array_type and arranges for it to become a real array\n-  // type.  The parameters are as for array_type.  Returns true on\n-  // success, false on failure.\n-  virtual bool set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t   Btype *element_type,\n-\t\t\t\t\t   Bexpression *length)\n-    = 0;\n+  virtual tree array_type (tree element_type, tree length) = 0;\n \n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n   // created via placeholder_pointer_type, placeholder_struct_type, or\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n-  virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n-\n-  // Create a marker for a circular pointer type.  Go pointer and\n-  // function types can refer to themselves in ways that are not\n-  // permitted in C/C++.  When a circular type is found, this function\n-  // is called for the circular reference.  This permits the backend\n-  // to decide how to handle such a type.  PLACEHOLDER is the\n-  // placeholder type which has already been created; if the backend\n-  // is prepared to handle a circular pointer type, it may simply\n-  // return PLACEHOLDER.  FOR_FUNCTION is true if this is for a\n-  // function type.\n-  //\n-  // For \"type P *P\" the sequence of calls will be\n-  //   bt1 = placeholder_pointer_type();\n-  //   bt2 = circular_pointer_type(bt1, false);\n-  //   set_placeholder_pointer_type(bt1, bt2);\n-  virtual Btype *circular_pointer_type (Btype *placeholder, bool for_function)\n-    = 0;\n-\n-  // Return whether the argument could be a special type created by\n-  // circular_pointer_type.  This is used to introduce explicit type\n-  // conversions where needed.  If circular_pointer_type returns its\n-  // PLACEHOLDER parameter, this may safely always return false.\n-  virtual bool is_circular_pointer_type (Btype *) = 0;\n+  virtual tree named_type (const std::string &name, tree, Location) = 0;\n \n   // Return the size of a type.\n-  virtual int64_t type_size (Btype *) = 0;\n+  virtual int64_t type_size (tree) = 0;\n \n   // Return the alignment of a type.\n-  virtual int64_t type_alignment (Btype *) = 0;\n+  virtual int64_t type_alignment (tree) = 0;\n \n   // Return the alignment of a struct field of this type.  This is\n   // normally the same as type_alignment, but not always.\n-  virtual int64_t type_field_alignment (Btype *) = 0;\n+  virtual int64_t type_field_alignment (tree) = 0;\n \n   // Return the offset of field INDEX in a struct type.  INDEX is the\n   // entry in the FIELDS std::vector parameter of struct_type or\n   // set_placeholder_struct_type.\n-  virtual int64_t type_field_offset (Btype *, size_t index) = 0;\n+  virtual int64_t type_field_offset (tree, size_t index) = 0;\n \n   // Expressions.\n \n   // Return an expression for a zero value of the given type.  This is\n   // used for cases such as local variable initialization and\n   // converting nil to other types.\n-  virtual Bexpression *zero_expression (Btype *) = 0;\n+  virtual tree zero_expression (tree) = 0;\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bexpression *error_expression () = 0;\n+  virtual tree error_expression () = 0;\n \n   // return whether this is error_mark_node\n-  virtual bool is_error_expression (Bexpression *) = 0;\n+  virtual bool is_error_expression (tree) = 0;\n \n   // Create a nil pointer expression.\n-  virtual Bexpression *nil_pointer_expression () = 0;\n+  virtual tree nil_pointer_expression () = 0;\n \n-  virtual Bexpression *unit_expression () = 0;\n+  virtual tree unit_expression () = 0;\n \n   // Create a reference to a variable.\n-  virtual Bexpression *var_expression (Bvariable *var, Location) = 0;\n+  virtual tree var_expression (Bvariable *var, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n   // is known to point to a valid memory location.  BTYPE is the expected type\n   // of the indirected EXPR.\n-  virtual Bexpression *indirect_expression (Btype *btype, Bexpression *expr,\n-\t\t\t\t\t    bool known_valid, Location)\n+  virtual tree indirect_expression (tree btype, tree expr, bool known_valid,\n+\t\t\t\t    Location)\n     = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE.\n-  virtual Bexpression *named_constant_expression (Btype *btype,\n-\t\t\t\t\t\t  const std::string &name,\n-\t\t\t\t\t\t  Bexpression *val, Location)\n+  virtual tree named_constant_expression (tree btype, const std::string &name,\n+\t\t\t\t\t  tree val, Location)\n     = 0;\n \n   // Return an expression for the multi-precision integer VAL in BTYPE.\n-  virtual Bexpression *integer_constant_expression (Btype *btype, mpz_t val)\n-    = 0;\n+  virtual tree integer_constant_expression (tree btype, mpz_t val) = 0;\n \n   // Return an expression for the floating point value VAL in BTYPE.\n-  virtual Bexpression *float_constant_expression (Btype *btype, mpfr_t val) = 0;\n+  virtual tree float_constant_expression (tree btype, mpfr_t val) = 0;\n \n   // Return an expression for the complex value VAL in BTYPE.\n-  virtual Bexpression *complex_constant_expression (Btype *btype, mpc_t val)\n-    = 0;\n+  virtual tree complex_constant_expression (tree btype, mpc_t val) = 0;\n \n   // Return an expression for the string value VAL.\n-  virtual Bexpression *string_constant_expression (const std::string &val) = 0;\n+  virtual tree string_constant_expression (const std::string &val) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *char_constant_expression (char c) = 0;\n+  virtual tree char_constant_expression (char c) = 0;\n \n   // Get a char literal\n-  virtual Bexpression *wchar_constant_expression (wchar_t c) = 0;\n+  virtual tree wchar_constant_expression (wchar_t c) = 0;\n \n   // Return an expression for the boolean value VAL.\n-  virtual Bexpression *boolean_constant_expression (bool val) = 0;\n+  virtual tree boolean_constant_expression (bool val) = 0;\n \n   // Return an expression for the real part of BCOMPLEX.\n-  virtual Bexpression *real_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree real_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the imaginary part of BCOMPLEX.\n-  virtual Bexpression *imag_part_expression (Bexpression *bcomplex, Location)\n-    = 0;\n+  virtual tree imag_part_expression (tree bcomplex, Location) = 0;\n \n   // Return an expression for the complex number (BREAL, BIMAG).\n-  virtual Bexpression *complex_expression (Bexpression *breal,\n-\t\t\t\t\t   Bexpression *bimag, Location)\n-    = 0;\n+  virtual tree complex_expression (tree breal, tree bimag, Location) = 0;\n \n   // Return an expression that converts EXPR to TYPE.\n-  virtual Bexpression *convert_expression (Btype *type, Bexpression *expr,\n-\t\t\t\t\t   Location)\n-    = 0;\n+  virtual tree convert_expression (tree type, tree expr, Location) = 0;\n \n   // Create an expression for the address of a function.  This is used to\n   // get the address of the code for a function.\n-  virtual Bexpression *function_code_expression (Bfunction *, Location) = 0;\n+  virtual tree function_code_expression (tree, Location) = 0;\n \n   // Create an expression that takes the address of an expression.\n-  virtual Bexpression *address_expression (Bexpression *, Location) = 0;\n+  virtual tree address_expression (tree, Location) = 0;\n \n   // Return an expression for the field at INDEX in BSTRUCT.\n-  virtual Bexpression *struct_field_expression (Bexpression *bstruct,\n-\t\t\t\t\t\tsize_t index, Location)\n+  virtual tree struct_field_expression (tree bstruct, size_t index, Location)\n     = 0;\n \n   // Create an expression that executes BSTAT before BEXPR.\n-  virtual Bexpression *compound_expression (Bstatement *bstat,\n-\t\t\t\t\t    Bexpression *bexpr, Location)\n-    = 0;\n+  virtual tree compound_expression (tree bstat, tree bexpr, Location) = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual Bexpression *\n-  conditional_expression (Bfunction *function, Btype *btype,\n-\t\t\t  Bexpression *condition, Bexpression *then_expr,\n-\t\t\t  Bexpression *else_expr, Location)\n+  virtual tree conditional_expression (tree function, tree btype,\n+\t\t\t\t       tree condition, tree then_expr,\n+\t\t\t\t       tree else_expr, Location)\n     = 0;\n \n   // Return an expression for the negation operation OP EXPR.\n   // Supported values of OP are enumerated in NegationOperator.\n-  virtual Bexpression *negation_expression (NegationOperator op,\n-\t\t\t\t\t    Bexpression *expr, Location)\n+  virtual tree negation_expression (NegationOperator op, tree expr, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ArithmeticOrLogicalOperator.\n-  virtual Bexpression *\n-  arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t    Bexpression *left, Bexpression *right,\n-\t\t\t\t    Location)\n+  virtual tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t\t tree left, tree right,\n+\t\t\t\t\t\t Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in ComparisonOperator.\n-  virtual Bexpression *comparison_expression (ComparisonOperator op,\n-\t\t\t\t\t      Bexpression *left,\n-\t\t\t\t\t      Bexpression *right, Location)\n+  virtual tree comparison_expression (ComparisonOperator op, tree left,\n+\t\t\t\t      tree right, Location)\n     = 0;\n \n   // Return an expression for the operation LEFT OP RIGHT.\n   // Supported values of OP are enumerated in LazyBooleanOperator.\n-  virtual Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\t\tBexpression *left,\n-\t\t\t\t\t\tBexpression *right, Location)\n+  virtual tree lazy_boolean_expression (LazyBooleanOperator op, tree left,\n+\t\t\t\t\ttree right, Location)\n     = 0;\n \n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n-  virtual Bexpression *\n-  constructor_expression (Btype *btype, const std::vector<Bexpression *> &vals,\n-\t\t\t  int, Location)\n+  virtual tree constructor_expression (tree btype,\n+\t\t\t\t       const std::vector<tree> &vals, int,\n+\t\t\t\t       Location)\n     = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and\n   // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n   // in INDEXES must be in the same order as the corresponding value in VALS.\n-  virtual Bexpression *array_constructor_expression (\n-    Btype *btype, const std::vector<unsigned long> &indexes,\n-    const std::vector<Bexpression *> &vals, Location)\n+  virtual tree\n+  array_constructor_expression (tree btype,\n+\t\t\t\tconst std::vector<unsigned long> &indexes,\n+\t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n   // Return an expression for the address of BASE[INDEX].\n   // BASE has a pointer type.  This is used for slice indexing.\n-  virtual Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t\t  Bexpression *index, Location)\n-    = 0;\n+  virtual tree pointer_offset_expression (tree base, tree index, Location) = 0;\n \n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n-  virtual Bexpression *array_index_expression (Bexpression *array,\n-\t\t\t\t\t       Bexpression *index, Location)\n-    = 0;\n+  virtual tree array_index_expression (tree array, tree index, Location) = 0;\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\t\tBexpression *static_chain, Location)\n+  virtual tree call_expression (tree caller, tree fn,\n+\t\t\t\tconst std::vector<tree> &args,\n+\t\t\t\ttree static_chain, Location)\n     = 0;\n \n   // Statements.\n \n   // Create an error statement.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bstatement *error_statement () = 0;\n+  virtual tree error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual Bstatement *expression_statement (Bfunction *, Bexpression *) = 0;\n+  virtual tree expression_statement (tree, tree) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual Bstatement *init_statement (Bfunction *, Bvariable *var,\n-\t\t\t\t      Bexpression *init)\n-    = 0;\n+  virtual tree init_statement (tree, Bvariable *var, tree init) = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t\t    Bexpression *rhs, Location)\n-    = 0;\n+  virtual tree assignment_statement (tree, tree lhs, tree rhs, Location) = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual Bstatement *\n-  return_statement (Bfunction *, const std::vector<Bexpression *> &, Location)\n-    = 0;\n+  virtual tree return_statement (tree, const std::vector<tree> &, Location) = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual Bstatement *if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t\t    Bblock *then_block, Bblock *else_block,\n-\t\t\t\t    Location)\n+  virtual tree if_statement (tree, tree condition, tree then_block,\n+\t\t\t     tree else_block, Location)\n     = 0;\n \n   // infinite loop expressions\n-  virtual Bexpression *loop_expression (Bblock *body, Location) = 0;\n+  virtual tree loop_expression (tree body, Location) = 0;\n \n   // exit expressions\n-  virtual Bexpression *exit_expression (Bexpression *condition, Location) = 0;\n+  virtual tree exit_expression (tree condition, Location) = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -549,26 +417,24 @@ class Backend\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n-  virtual Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location)\n+  virtual tree switch_statement (tree function, tree value,\n+\t\t\t\t const std::vector<std::vector<tree> > &cases,\n+\t\t\t\t const std::vector<tree> &statements, Location)\n     = 0;\n \n   // Create a single statement from two statements.\n-  virtual Bstatement *compound_statement (Bstatement *, Bstatement *) = 0;\n+  virtual tree compound_statement (tree, tree) = 0;\n \n   // Create a single statement from a list of statements.\n-  virtual Bstatement *statement_list (const std::vector<Bstatement *> &) = 0;\n+  virtual tree statement_list (const std::vector<tree> &) = 0;\n \n   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n   // if not NULL, it will always be executed.  This is used for handling defers\n   // in Go functions.  In C++, the resulting code is of this form:\n   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n-  virtual Bstatement *\n-  exception_handler_statement (Bstatement *bstat, Bstatement *except_stmt,\n-\t\t\t       Bstatement *finally_stmt, Location)\n+  virtual tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t\t    tree finally_stmt, Location)\n     = 0;\n \n   // Blocks.\n@@ -583,22 +449,20 @@ class Backend\n   // the initial curly brace.  END_LOCATION is the location of the end\n   // of the block, more or less the location of the final curly brace.\n   // The statements will be added after the block is created.\n-  virtual Bblock *block (Bfunction *function, Bblock *enclosing,\n-\t\t\t const std::vector<Bvariable *> &vars,\n-\t\t\t Location start_location, Location end_location)\n+  virtual tree block (tree function, tree enclosing,\n+\t\t      const std::vector<Bvariable *> &vars,\n+\t\t      Location start_location, Location end_location)\n     = 0;\n \n   // Add the statements to a block.  The block is created first.  Then\n   // the statements are created.  Then the statements are added to the\n   // block.  This will called exactly once per block.  The vector may\n   // be empty if there are no statements.\n-  virtual void block_add_statements (Bblock *,\n-\t\t\t\t     const std::vector<Bstatement *> &)\n-    = 0;\n+  virtual void block_add_statements (tree, const std::vector<tree> &) = 0;\n \n   // Return the block as a statement.  This is used to include a block\n   // in a list of statements.\n-  virtual Bstatement *block_statement (Bblock *) = 0;\n+  virtual tree block_statement (tree) = 0;\n \n   // Variables.\n \n@@ -618,7 +482,7 @@ class Backend\n   // permit the linker to garbage collect the variable if it is not\n   // referenced.  LOCATION is where the variable was defined.\n   virtual Bvariable *global_variable (const std::string &name,\n-\t\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t\t      const std::string &asm_name, tree btype,\n \t\t\t\t      bool is_external, bool is_hidden,\n \t\t\t\t      bool in_unique_section, Location location)\n     = 0;\n@@ -629,7 +493,7 @@ class Backend\n   // global_variable_set_init to set the initial value.  If this is\n   // not called, the backend should initialize a global variable to 0.\n   // The init function may then assign a value to it.\n-  virtual void global_variable_set_init (Bvariable *, Bexpression *) = 0;\n+  virtual void global_variable_set_init (Bvariable *, tree) = 0;\n \n   // Create a local variable.  The frontend will create the local\n   // variables first, and then create the block which contains them.\n@@ -643,23 +507,23 @@ class Backend\n   // the function, as otherwise the variable would be on the heap).\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n-  virtual Bvariable *\n-  local_variable (Bfunction *function, const std::string &name, Btype *type,\n-\t\t  Bvariable *decl_var, bool is_address_taken, Location location)\n+  virtual Bvariable *local_variable (tree function, const std::string &name,\n+\t\t\t\t     tree type, Bvariable *decl_var,\n+\t\t\t\t     bool is_address_taken, Location location)\n     = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n-  virtual Bvariable *\n-  parameter_variable (Bfunction *function, const std::string &name, Btype *type,\n-\t\t      bool is_address_taken, Location location)\n+  virtual Bvariable *parameter_variable (tree function, const std::string &name,\n+\t\t\t\t\t tree type, bool is_address_taken,\n+\t\t\t\t\t Location location)\n     = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n-  virtual Bvariable *static_chain_variable (Bfunction *function,\n-\t\t\t\t\t    const std::string &name,\n-\t\t\t\t\t    Btype *type, Location location)\n+  virtual Bvariable *static_chain_variable (tree function,\n+\t\t\t\t\t    const std::string &name, tree type,\n+\t\t\t\t\t    Location location)\n     = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n@@ -673,10 +537,9 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable *\n-  temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *init,\n-\t\t      bool address_is_taken, Location location,\n-\t\t      Bstatement **pstatement)\n+  virtual Bvariable *temporary_variable (tree, tree, tree, tree init,\n+\t\t\t\t\t bool address_is_taken,\n+\t\t\t\t\t Location location, tree *pstatement)\n     = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n@@ -705,10 +568,10 @@ class Backend\n   // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable *\n-  implicit_variable (const std::string &name, const std::string &asm_name,\n-\t\t     Btype *type, bool is_hidden, bool is_constant,\n-\t\t     bool is_common, int64_t alignment)\n+  virtual Bvariable *implicit_variable (const std::string &name,\n+\t\t\t\t\tconst std::string &asm_name, tree type,\n+\t\t\t\t\tbool is_hidden, bool is_constant,\n+\t\t\t\t\tbool is_common, int64_t alignment)\n     = 0;\n \n   // Set the initial value of a variable created by implicit_variable.\n@@ -722,9 +585,9 @@ class Backend\n   // If IS_COMMON is true, INIT will be NULL, and the\n   // variable should be initialized to all zeros.\n   virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n-\t\t\t\t\t   Btype *type, bool is_hidden,\n+\t\t\t\t\t   tree type, bool is_hidden,\n \t\t\t\t\t   bool is_constant, bool is_common,\n-\t\t\t\t\t   Bexpression *init)\n+\t\t\t\t\t   tree init)\n     = 0;\n \n   // Create a reference to a named implicit variable defined in some\n@@ -734,7 +597,7 @@ class Backend\n   // variable in C.\n   virtual Bvariable *implicit_variable_reference (const std::string &name,\n \t\t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t\t  Btype *type)\n+\t\t\t\t\t\t  tree type)\n     = 0;\n \n   // Create a named immutable initialized data structure.  This is\n@@ -767,7 +630,7 @@ class Backend\n   // immutable_struct_set_init.\n   virtual Bvariable *\n   immutable_struct (const std::string &name, const std::string &asm_name,\n-\t\t    bool is_hidden, bool is_common, Btype *type, Location)\n+\t\t    bool is_hidden, bool is_common, tree type, Location)\n     = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n@@ -779,8 +642,7 @@ class Backend\n   // immutable_struct.\n   virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n \t\t\t\t\t  bool is_hidden, bool is_common,\n-\t\t\t\t\t  Btype *type, Location,\n-\t\t\t\t\t  Bexpression *initializer)\n+\t\t\t\t\t  tree type, Location, tree initializer)\n     = 0;\n \n   // Create a reference to a named immutable initialized data\n@@ -790,35 +652,35 @@ class Backend\n   // corresponds to an extern const global variable in C.\n   virtual Bvariable *immutable_struct_reference (const std::string &name,\n \t\t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t\t Btype *type, Location)\n+\t\t\t\t\t\t tree type, Location)\n     = 0;\n \n   // Labels.\n \n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n   // where the label is defined.\n-  virtual Blabel *label (Bfunction *, const std::string &name, Location) = 0;\n+  virtual tree label (tree, const std::string &name, Location) = 0;\n \n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n   // defined.\n-  virtual Bstatement *label_definition_statement (Blabel *) = 0;\n+  virtual tree label_definition_statement (tree) = 0;\n \n   // Create a goto statement to a label.\n-  virtual Bstatement *goto_statement (Blabel *, Location) = 0;\n+  virtual tree goto_statement (tree, Location) = 0;\n \n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n   // recover.\n-  virtual Bexpression *label_address (Blabel *, Location) = 0;\n+  virtual tree label_address (tree, Location) = 0;\n \n   // Functions.\n \n   // Create an error function.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n   // going without crashing.\n-  virtual Bfunction *error_function () = 0;\n+  virtual tree error_function () = 0;\n \n   // Bit flags to pass to the function method.\n \n@@ -857,49 +719,47 @@ class Backend\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n-  virtual Bfunction *function (Btype *fntype, const std::string &name,\n-\t\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t\t       Location)\n+  virtual tree function (tree fntype, const std::string &name,\n+\t\t\t const std::string &asm_name, unsigned int flags,\n+\t\t\t Location)\n     = 0;\n \n-  virtual Btype *specify_abi_attribute (Btype *type, Rust::ABI abi) = 0;\n+  virtual tree specify_abi_attribute (tree type, Rust::ABI abi) = 0;\n \n   // Create a statement that runs all deferred calls for FUNCTION.  This should\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual Bstatement *\n-  function_defer_statement (Bfunction *function, Bexpression *undefer,\n-\t\t\t    Bexpression *check_defer, Location)\n+  virtual tree function_defer_statement (tree function, tree undefer,\n+\t\t\t\t\t tree check_defer, Location)\n     = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n   // This will only be called for a function definition.  Returns true on\n   // success, false on failure.\n   virtual bool\n-  function_set_parameters (Bfunction *function,\n+  function_set_parameters (tree function,\n \t\t\t   const std::vector<Bvariable *> &param_vars)\n     = 0;\n \n   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n   // true on success, false on failure.\n-  virtual bool function_set_body (Bfunction *function, Bstatement *code_stmt)\n-    = 0;\n+  virtual bool function_set_body (tree function, tree code_stmt) = 0;\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction *lookup_gcc_builtin (const std::string &) = 0;\n+  virtual tree lookup_gcc_builtin (const std::string &) = 0;\n \n-  virtual Bfunction *lookup_builtin_by_rust_name (const std::string &) = 0;\n+  virtual tree lookup_builtin_by_rust_name (const std::string &) = 0;\n \n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n   virtual void\n-  write_global_definitions (const std::vector<Btype *> &type_decls,\n-\t\t\t    const std::vector<Bexpression *> &constant_decls,\n-\t\t\t    const std::vector<Bfunction *> &function_decls,\n+  write_global_definitions (const std::vector<tree> &type_decls,\n+\t\t\t    const std::vector<tree> &constant_decls,\n+\t\t\t    const std::vector<tree> &function_decls,\n \t\t\t    const std::vector<Bvariable *> &variable_decls)\n     = 0;\n "}, {"sha": "1c2ec84ccd22e9669e93cfbf486b5b9d138eb033", "filename": "gcc/rust/rust-diagnostics.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-diagnostics.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-diagnostics.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-diagnostics.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -48,6 +48,7 @@\n // All other format specifiers are as defined by 'sprintf'. The final resulting\n // message is then sent to the back end via rust_be_error_at/rust_be_warning_at.\n \n+// clang-format off\n // simple location\n extern void\n rust_internal_error_at (const Location, const char *fmt, ...)\n@@ -71,6 +72,7 @@ rust_inform (const Location, const char *fmt, ...)\n extern void\n rust_error_at (const RichLocation &, const char *fmt, ...)\n   RUST_ATTRIBUTE_GCC_DIAG (2, 3);\n+// clang-format on\n \n // These interfaces provide a way for the front end to ask for\n // the open/close quote characters it should use when formatting\n@@ -86,6 +88,7 @@ rust_close_quote ();\n // instead use the equivalent routines above. The back end is required to\n // implement these routines.\n \n+// clang-format off\n extern void\n rust_be_internal_error_at (const Location, const std::string &errmsg)\n   RUST_ATTRIBUTE_NORETURN;\n@@ -104,6 +107,7 @@ extern void\n rust_be_get_quotechars (const char **open_quote, const char **close_quote);\n extern bool\n rust_be_debug_p (void);\n+// clang-format on\n \n namespace Rust {\n /* A structure used to represent an error. Useful for enabling"}, {"sha": "12df7699879f9ba4bac1cb2ae70773d2da7a3719", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 521, "deletions": 921, "changes": 1442, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -53,58 +53,6 @@\n \n // TODO: this will have to be significantly modified to work with Rust\n \n-// A class wrapping a tree.\n-\n-class Gcc_tree\n-{\n-public:\n-  Gcc_tree (tree t) : t_ (t) {}\n-\n-  tree get_tree () const { return this->t_; }\n-\n-  void set_tree (tree t) { this->t_ = t; }\n-\n-private:\n-  tree t_;\n-};\n-\n-// In gcc, types, expressions, and statements are all trees.\n-class Btype : public Gcc_tree\n-{\n-public:\n-  Btype (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bexpression : public Gcc_tree\n-{\n-public:\n-  Bexpression (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bstatement : public Gcc_tree\n-{\n-public:\n-  Bstatement (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bfunction : public Gcc_tree\n-{\n-public:\n-  Bfunction (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Bblock : public Gcc_tree\n-{\n-public:\n-  Bblock (tree t) : Gcc_tree (t) {}\n-};\n-\n-class Blabel : public Gcc_tree\n-{\n-public:\n-  Blabel (tree t) : Gcc_tree (t) {}\n-};\n-\n // Bvariable is a bit more complicated, because of zero-sized types.\n // The GNU linker does not permit dynamic variables with zero size.\n // When we see such a variable, we generate a version of the type with\n@@ -159,22 +107,17 @@ class Gcc_backend : public Backend\n public:\n   Gcc_backend ();\n \n-  void debug (Btype *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bexpression *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bstatement *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bfunction *t) { debug_tree (t->get_tree ()); };\n-  void debug (Bblock *t) { debug_tree (t->get_tree ()); };\n+  void debug (tree t) { debug_tree (t); };\n   void debug (Bvariable *t) { debug_tree (t->get_decl ()); };\n-  void debug (Blabel *t) { debug_tree (t->get_tree ()); };\n \n   // Types.\n-  Btype *error_type () { return this->make_type (error_mark_node); }\n+  tree error_type () { return error_mark_node; }\n \n-  Btype *void_type () { return this->make_type (void_type_node); }\n+  tree void_type () { return void_type_node; }\n \n-  Btype *unit_type ()\n+  tree unit_type ()\n   {\n-    static Btype *unit_type;\n+    static tree unit_type;\n     if (unit_type == nullptr)\n       {\n \tauto unit_type_node = integer_type (true, 0);\n@@ -185,18 +128,18 @@ class Gcc_backend : public Backend\n     return unit_type;\n   }\n \n-  Btype *bool_type () { return this->make_type (boolean_type_node); }\n+  tree bool_type () { return boolean_type_node; }\n \n-  Btype *char_type () { return this->make_type (char_type_node); }\n+  tree char_type () { return char_type_node; }\n \n-  bool const_size_cast (Bexpression *expr, size_t *result)\n+  bool const_size_cast (tree expr, size_t *result)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     if (ret <= 0)\n       return false;\n \n@@ -205,344 +148,276 @@ class Gcc_backend : public Backend\n     return true;\n   }\n \n-  std::string const_size_val_to_string (Bexpression *expr)\n+  std::string const_size_val_to_string (tree expr)\n   {\n-    rust_assert (TREE_CONSTANT (expr->get_tree ()));\n+    rust_assert (TREE_CONSTANT (expr));\n \n     unsigned char buf[sizeof (size_t) + 1];\n     memset (buf, 0, sizeof (buf));\n \n-    int ret = native_encode_expr (expr->get_tree (), buf, sizeof (buf), 0);\n+    int ret = native_encode_expr (expr, buf, sizeof (buf), 0);\n     rust_assert (ret > 0);\n \n     size_t *ptr = (size_t *) buf;\n     return std::to_string (*ptr);\n   }\n \n-  bool const_values_equal (Bexpression *a, Bexpression *b)\n+  bool const_values_equal (tree a, tree b)\n   {\n-    return operand_equal_p (a->get_tree (), b->get_tree (),\n-\t\t\t    OEP_ONLY_CONST | OEP_PURE_SAME);\n+    return operand_equal_p (a, b, OEP_ONLY_CONST | OEP_PURE_SAME);\n     // printf (\"comparing!\\n\");\n     // debug_tree (a->get_tree ());\n     // debug_tree (b->get_tree ());\n     // printf (\"ok = %s\\n\", ok ? \"true\" : \"false\");\n   }\n \n-  Btype *wchar_type ()\n+  tree wchar_type ()\n   {\n     tree wchar = make_unsigned_type (32);\n     TYPE_STRING_FLAG (wchar) = 1;\n-    return this->make_type (wchar);\n+    return wchar;\n   }\n \n   int get_pointer_size ();\n \n-  Btype *raw_str_type ();\n-\n-  Btype *integer_type (bool, int);\n-\n-  Btype *float_type (int);\n-\n-  Btype *complex_type (int);\n-\n-  Btype *pointer_type (Btype *);\n-\n-  Btype *reference_type (Btype *);\n-\n-  Btype *immutable_type (Btype *);\n-\n-  Btype *specify_abi_attribute (Btype *, Rust::ABI);\n-\n-  Btype *insert_type_attribute (Btype *, const std::string &);\n-\n-  Btype *function_type (const Btyped_identifier &,\n-\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n-\t\t\tconst Location);\n+  tree raw_str_type ();\n \n-  Btype *function_type_varadic (const Btyped_identifier &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &,\n-\t\t\t\tconst std::vector<Btyped_identifier> &, Btype *,\n-\t\t\t\tconst Location);\n+  tree integer_type (bool, int);\n \n-  Btype *function_ptr_type (Btype *, const std::vector<Btype *> &, Location);\n+  tree float_type (int);\n \n-  Btype *struct_type (const std::vector<Btyped_identifier> &);\n+  tree complex_type (int);\n \n-  Btype *union_type (const std::vector<Btyped_identifier> &);\n+  tree pointer_type (tree);\n \n-  Btype *array_type (Btype *, Bexpression *);\n+  tree reference_type (tree);\n \n-  Btype *placeholder_pointer_type (const std::string &, Location, bool);\n+  tree immutable_type (tree);\n \n-  bool set_placeholder_pointer_type (Btype *, Btype *);\n+  tree specify_abi_attribute (tree, Rust::ABI);\n \n-  bool set_placeholder_function_type (Btype *, Btype *);\n+  tree insert_type_attribute (tree, const std::string &);\n \n-  Btype *placeholder_struct_type (const std::string &, Location);\n+  tree function_type (const typed_identifier &,\n+\t\t      const std::vector<typed_identifier> &,\n+\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t      const Location);\n \n-  bool set_placeholder_struct_type (Btype *placeholder,\n-\t\t\t\t    const std::vector<Btyped_identifier> &);\n+  tree function_type_varadic (const typed_identifier &,\n+\t\t\t      const std::vector<typed_identifier> &,\n+\t\t\t      const std::vector<typed_identifier> &, tree,\n+\t\t\t      const Location);\n \n-  Btype *placeholder_array_type (const std::string &, Location);\n+  tree function_ptr_type (tree, const std::vector<tree> &, Location);\n \n-  bool set_placeholder_array_type (Btype *, Btype *, Bexpression *);\n+  tree struct_type (const std::vector<typed_identifier> &);\n \n-  Btype *named_type (const std::string &, Btype *, Location);\n+  tree union_type (const std::vector<typed_identifier> &);\n \n-  Btype *circular_pointer_type (Btype *, bool);\n+  tree array_type (tree, tree);\n \n-  bool is_circular_pointer_type (Btype *);\n+  tree named_type (const std::string &, tree, Location);\n \n-  int64_t type_size (Btype *);\n+  int64_t type_size (tree);\n \n-  int64_t type_alignment (Btype *);\n+  int64_t type_alignment (tree);\n \n-  int64_t type_field_alignment (Btype *);\n+  int64_t type_field_alignment (tree);\n \n-  int64_t type_field_offset (Btype *, size_t index);\n+  int64_t type_field_offset (tree, size_t index);\n \n   // Expressions.\n \n-  Bexpression *zero_expression (Btype *);\n+  tree zero_expression (tree);\n \n-  Bexpression *error_expression ()\n-  {\n-    return this->make_expression (error_mark_node);\n-  }\n+  tree error_expression () { return error_mark_node; }\n \n-  bool is_error_expression (Bexpression *expr)\n-  {\n-    return expr->get_tree () == error_mark_node;\n-  }\n+  bool is_error_expression (tree expr) { return expr == error_mark_node; }\n \n-  Bexpression *nil_pointer_expression ()\n-  {\n-    return this->make_expression (null_pointer_node);\n-  }\n+  tree nil_pointer_expression () { return null_pointer_node; }\n \n-  Bexpression *unit_expression ()\n-  {\n-    return this->make_expression (integer_zero_node);\n-  }\n+  tree unit_expression () { return integer_zero_node; }\n \n-  Bexpression *var_expression (Bvariable *var, Location);\n+  tree var_expression (Bvariable *var, Location);\n \n-  Bexpression *indirect_expression (Btype *, Bexpression *expr,\n-\t\t\t\t    bool known_valid, Location);\n+  tree indirect_expression (tree, tree expr, bool known_valid, Location);\n \n-  Bexpression *named_constant_expression (Btype *btype, const std::string &name,\n-\t\t\t\t\t  Bexpression *val, Location);\n+  tree named_constant_expression (tree type, const std::string &name, tree val,\n+\t\t\t\t  Location);\n \n-  Bexpression *integer_constant_expression (Btype *btype, mpz_t val);\n+  tree integer_constant_expression (tree type, mpz_t val);\n \n-  Bexpression *float_constant_expression (Btype *btype, mpfr_t val);\n+  tree float_constant_expression (tree type, mpfr_t val);\n \n-  Bexpression *complex_constant_expression (Btype *btype, mpc_t val);\n+  tree complex_constant_expression (tree type, mpc_t val);\n \n-  Bexpression *string_constant_expression (const std::string &val);\n+  tree string_constant_expression (const std::string &val);\n \n-  Bexpression *wchar_constant_expression (wchar_t c);\n+  tree wchar_constant_expression (wchar_t c);\n \n-  Bexpression *char_constant_expression (char c);\n+  tree char_constant_expression (char c);\n \n-  Bexpression *boolean_constant_expression (bool val);\n+  tree boolean_constant_expression (bool val);\n \n-  Bexpression *real_part_expression (Bexpression *bcomplex, Location);\n+  tree real_part_expression (tree bcomplex, Location);\n \n-  Bexpression *imag_part_expression (Bexpression *bcomplex, Location);\n+  tree imag_part_expression (tree bcomplex, Location);\n \n-  Bexpression *complex_expression (Bexpression *breal, Bexpression *bimag,\n-\t\t\t\t   Location);\n+  tree complex_expression (tree breal, tree bimag, Location);\n \n-  Bexpression *convert_expression (Btype *type, Bexpression *expr, Location);\n+  tree convert_expression (tree type, tree expr, Location);\n \n-  Bexpression *function_code_expression (Bfunction *, Location);\n+  tree function_code_expression (tree, Location);\n \n-  Bexpression *address_expression (Bexpression *, Location);\n+  tree address_expression (tree, Location);\n \n-  Bexpression *struct_field_expression (Bexpression *, size_t, Location);\n+  tree struct_field_expression (tree, size_t, Location);\n \n-  Bexpression *compound_expression (Bstatement *, Bexpression *, Location);\n+  tree compound_expression (tree, tree, Location);\n \n-  Bexpression *conditional_expression (Bfunction *, Btype *, Bexpression *,\n-\t\t\t\t       Bexpression *, Bexpression *, Location);\n+  tree conditional_expression (tree, tree, tree, tree, tree, Location);\n \n-  Bexpression *negation_expression (NegationOperator op, Bexpression *expr,\n-\t\t\t\t    Location);\n+  tree negation_expression (NegationOperator op, tree expr, Location);\n \n-  Bexpression *arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t\t Bexpression *left,\n-\t\t\t\t\t\t Bexpression *right, Location);\n+  tree arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n+\t\t\t\t\t tree left, tree right, Location);\n \n-  Bexpression *comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location);\n+  tree comparison_expression (ComparisonOperator op, tree left, tree right,\n+\t\t\t      Location);\n \n-  Bexpression *lazy_boolean_expression (LazyBooleanOperator op,\n-\t\t\t\t\tBexpression *left, Bexpression *right,\n-\t\t\t\t\tLocation);\n+  tree lazy_boolean_expression (LazyBooleanOperator op, tree left, tree right,\n+\t\t\t\tLocation);\n \n-  Bexpression *constructor_expression (Btype *,\n-\t\t\t\t       const std::vector<Bexpression *> &, int,\n-\t\t\t\t       Location);\n+  tree constructor_expression (tree, const std::vector<tree> &, int, Location);\n \n-  Bexpression *array_constructor_expression (Btype *,\n-\t\t\t\t\t     const std::vector<unsigned long> &,\n-\t\t\t\t\t     const std::vector<Bexpression *> &,\n-\t\t\t\t\t     Location);\n+  tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n+\t\t\t\t     const std::vector<tree> &, Location);\n \n-  Bexpression *pointer_offset_expression (Bexpression *base,\n-\t\t\t\t\t  Bexpression *offset, Location);\n+  tree pointer_offset_expression (tree base, tree offset, Location);\n \n-  Bexpression *array_index_expression (Bexpression *array, Bexpression *index,\n-\t\t\t\t       Location);\n+  tree array_index_expression (tree array, tree index, Location);\n \n-  Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n-\t\t\t\tconst std::vector<Bexpression *> &args,\n-\t\t\t\tBexpression *static_chain, Location);\n+  tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n+\t\t\ttree static_chain, Location);\n \n   // Statements.\n \n-  Bstatement *error_statement ()\n-  {\n-    return this->make_statement (error_mark_node);\n-  }\n+  tree error_statement () { return error_mark_node; }\n \n-  Bstatement *expression_statement (Bfunction *, Bexpression *);\n+  tree expression_statement (tree, tree);\n \n-  Bstatement *init_statement (Bfunction *, Bvariable *var, Bexpression *init);\n+  tree init_statement (tree, Bvariable *var, tree init);\n \n-  Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n-\t\t\t\t    Bexpression *rhs, Location);\n+  tree assignment_statement (tree, tree lhs, tree rhs, Location);\n \n-  Bstatement *return_statement (Bfunction *, const std::vector<Bexpression *> &,\n-\t\t\t\tLocation);\n+  tree return_statement (tree, const std::vector<tree> &, Location);\n \n-  Bstatement *if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t    Bblock *then_block, Bblock *else_block, Location);\n+  tree if_statement (tree, tree condition, tree then_block, tree else_block,\n+\t\t     Location);\n \n-  Bstatement *\n-  switch_statement (Bfunction *function, Bexpression *value,\n-\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n-\t\t    const std::vector<Bstatement *> &statements, Location);\n+  tree switch_statement (tree function, tree value,\n+\t\t\t const std::vector<std::vector<tree>> &cases,\n+\t\t\t const std::vector<tree> &statements, Location);\n \n-  Bstatement *compound_statement (Bstatement *, Bstatement *);\n+  tree compound_statement (tree, tree);\n \n-  Bstatement *statement_list (const std::vector<Bstatement *> &);\n+  tree statement_list (const std::vector<tree> &);\n \n-  Bstatement *exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t   Bstatement *except_stmt,\n-\t\t\t\t\t   Bstatement *finally_stmt, Location);\n+  tree exception_handler_statement (tree bstat, tree except_stmt,\n+\t\t\t\t    tree finally_stmt, Location);\n \n-  Bexpression *loop_expression (Bblock *body, Location);\n+  tree loop_expression (tree body, Location);\n \n-  Bexpression *exit_expression (Bexpression *condition, Location);\n+  tree exit_expression (tree condition, Location);\n \n   // Blocks.\n \n-  Bblock *block (Bfunction *, Bblock *, const std::vector<Bvariable *> &,\n-\t\t Location, Location);\n+  tree block (tree, tree, const std::vector<Bvariable *> &, Location, Location);\n \n-  void block_add_statements (Bblock *, const std::vector<Bstatement *> &);\n+  void block_add_statements (tree, const std::vector<tree> &);\n \n-  Bstatement *block_statement (Bblock *);\n+  tree block_statement (tree);\n \n   // Variables.\n \n   Bvariable *error_variable () { return new Bvariable (error_mark_node); }\n \n   Bvariable *global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location);\n \n-  void global_variable_set_init (Bvariable *, Bexpression *);\n+  void global_variable_set_init (Bvariable *, tree);\n \n-  Bvariable *local_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t     Bvariable *, bool, Location);\n+  Bvariable *local_variable (tree, const std::string &, tree, Bvariable *, bool,\n+\t\t\t     Location);\n \n-  Bvariable *parameter_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t\t bool, Location);\n+  Bvariable *parameter_variable (tree, const std::string &, tree, bool,\n+\t\t\t\t Location);\n \n-  Bvariable *static_chain_variable (Bfunction *, const std::string &, Btype *,\n-\t\t\t\t    Location);\n+  Bvariable *static_chain_variable (tree, const std::string &, tree, Location);\n \n-  Bvariable *temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *,\n-\t\t\t\t bool, Location, Bstatement **);\n+  Bvariable *temporary_variable (tree, tree, tree, tree, bool, Location,\n+\t\t\t\t tree *);\n \n-  Bvariable *implicit_variable (const std::string &, const std::string &,\n-\t\t\t\tBtype *, bool, bool, bool, int64_t);\n+  Bvariable *implicit_variable (const std::string &, const std::string &, tree,\n+\t\t\t\tbool, bool, bool, int64_t);\n \n-  void implicit_variable_set_init (Bvariable *, const std::string &, Btype *,\n-\t\t\t\t   bool, bool, bool, Bexpression *);\n+  void implicit_variable_set_init (Bvariable *, const std::string &, tree, bool,\n+\t\t\t\t   bool, bool, tree);\n \n   Bvariable *implicit_variable_reference (const std::string &,\n-\t\t\t\t\t  const std::string &, Btype *);\n+\t\t\t\t\t  const std::string &, tree);\n \n   Bvariable *immutable_struct (const std::string &, const std::string &, bool,\n-\t\t\t       bool, Btype *, Location);\n+\t\t\t       bool, tree, Location);\n \n   void immutable_struct_set_init (Bvariable *, const std::string &, bool, bool,\n-\t\t\t\t  Btype *, Location, Bexpression *);\n+\t\t\t\t  tree, Location, tree);\n \n   Bvariable *immutable_struct_reference (const std::string &,\n-\t\t\t\t\t const std::string &, Btype *,\n-\t\t\t\t\t Location);\n+\t\t\t\t\t const std::string &, tree, Location);\n \n   // Labels.\n \n-  Blabel *label (Bfunction *, const std::string &name, Location);\n+  tree label (tree, const std::string &name, Location);\n \n-  Bstatement *label_definition_statement (Blabel *);\n+  tree label_definition_statement (tree);\n \n-  Bstatement *goto_statement (Blabel *, Location);\n+  tree goto_statement (tree, Location);\n \n-  Bexpression *label_address (Blabel *, Location);\n+  tree label_address (tree, Location);\n \n   // Functions.\n \n-  Bfunction *error_function () { return this->make_function (error_mark_node); }\n+  tree error_function () { return error_mark_node; }\n \n-  Bfunction *function (Btype *fntype, const std::string &name,\n-\t\t       const std::string &asm_name, unsigned int flags,\n-\t\t       Location);\n+  tree function (tree fntype, const std::string &name,\n+\t\t const std::string &asm_name, unsigned int flags, Location);\n \n-  Bstatement *function_defer_statement (Bfunction *function,\n-\t\t\t\t\tBexpression *undefer,\n-\t\t\t\t\tBexpression *defer, Location);\n+  tree function_defer_statement (tree function, tree undefer, tree defer,\n+\t\t\t\t Location);\n \n-  bool function_set_parameters (Bfunction *function,\n+  bool function_set_parameters (tree function,\n \t\t\t\tconst std::vector<Bvariable *> &);\n \n-  bool function_set_body (Bfunction *function, Bstatement *code_stmt);\n+  bool function_set_body (tree function, tree code_stmt);\n \n-  Bfunction *lookup_gcc_builtin (const std::string &);\n+  tree lookup_gcc_builtin (const std::string &);\n \n-  Bfunction *lookup_builtin_by_rust_name (const std::string &);\n+  tree lookup_builtin_by_rust_name (const std::string &);\n \n-  void write_global_definitions (const std::vector<Btype *> &,\n-\t\t\t\t const std::vector<Bexpression *> &,\n-\t\t\t\t const std::vector<Bfunction *> &,\n+  void write_global_definitions (const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n+\t\t\t\t const std::vector<tree> &,\n \t\t\t\t const std::vector<Bvariable *> &);\n \n   void write_export_data (const char *bytes, unsigned int size);\n \n private:\n-  // Make a Bexpression from a tree.\n-  Bexpression *make_expression (tree t) { return new Bexpression (t); }\n-\n-  // Make a Bstatement from a tree.\n-  Bstatement *make_statement (tree t) { return new Bstatement (t); }\n+  tree fill_in_fields (tree, const std::vector<typed_identifier> &);\n \n-  // Make a Btype from a tree.\n-  Btype *make_type (tree t) { return new Btype (t); }\n-\n-  Bfunction *make_function (tree t) { return new Bfunction (t); }\n-\n-  Btype *fill_in_fields (Btype *, const std::vector<Btyped_identifier> &);\n-\n-  Btype *fill_in_array (Btype *, Btype *, Bexpression *);\n+  tree fill_in_array (tree, tree, tree);\n \n   tree non_zero_size_type (tree);\n \n@@ -558,7 +433,7 @@ class Gcc_backend : public Backend\n \t\t       int flags);\n \n   // A mapping of the GCC built-ins exposed to GCCRust.\n-  std::map<std::string, Bfunction *> builtin_functions_;\n+  std::map<std::string, tree> builtin_functions_;\n   std::map<std::string, std::string> rust_intrinsic_to_gcc_builtin;\n };\n \n@@ -810,15 +685,15 @@ Gcc_backend::get_pointer_size ()\n   return POINTER_SIZE;\n }\n \n-Btype *\n+tree\n Gcc_backend::raw_str_type ()\n {\n   tree char_ptr = build_pointer_type (char_type_node);\n   tree const_char_type = build_qualified_type (char_ptr, TYPE_QUAL_CONST);\n-  return this->make_type (const_char_type);\n+  return const_char_type;\n }\n \n-Btype *\n+tree\n Gcc_backend::integer_type (bool is_unsigned, int bits)\n {\n   tree type;\n@@ -848,12 +723,12 @@ Gcc_backend::integer_type (bool is_unsigned, int bits)\n       else\n \ttype = make_signed_type (bits);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed float type.\n \n-Btype *\n+tree\n Gcc_backend::float_type (int bits)\n {\n   tree type;\n@@ -869,12 +744,12 @@ Gcc_backend::float_type (int bits)\n       TYPE_PRECISION (type) = bits;\n       layout_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get an unnamed complex type.\n \n-Btype *\n+tree\n Gcc_backend::complex_type (int bits)\n {\n   tree type;\n@@ -891,49 +766,46 @@ Gcc_backend::complex_type (int bits)\n       layout_type (type);\n       type = build_complex_type (type);\n     }\n-  return this->make_type (type);\n+  return type;\n }\n \n // Get a pointer type.\n \n-Btype *\n-Gcc_backend::pointer_type (Btype *to_type)\n+tree\n+Gcc_backend::pointer_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_pointer_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_pointer_type (to_type);\n+  return type;\n }\n \n // Get a reference type.\n \n-Btype *\n-Gcc_backend::reference_type (Btype *to_type)\n+tree\n+Gcc_backend::reference_type (tree to_type)\n {\n-  tree to_type_tree = to_type->get_tree ();\n-  if (to_type_tree == error_mark_node)\n+  if (to_type == error_mark_node)\n     return this->error_type ();\n-  tree type = build_reference_type (to_type_tree);\n-  return this->make_type (type);\n+  tree type = build_reference_type (to_type);\n+  return type;\n }\n \n // Get immutable type\n \n-Btype *\n-Gcc_backend::immutable_type (Btype *base)\n+tree\n+Gcc_backend::immutable_type (tree base)\n {\n-  tree type_tree = base->get_tree ();\n-  if (type_tree == error_mark_node)\n+  if (base == error_mark_node)\n     return this->error_type ();\n-  tree constified = build_qualified_type (type_tree, TYPE_QUAL_CONST);\n-  return this->make_type (constified);\n+  tree constified = build_qualified_type (base, TYPE_QUAL_CONST);\n+  return constified;\n }\n \n // ABI\n \n-Btype *\n-Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n+tree\n+Gcc_backend::specify_abi_attribute (tree type, Rust::ABI abi)\n {\n   std::string abi_string;\n   switch (abi)\n@@ -959,46 +831,46 @@ Gcc_backend::specify_abi_attribute (Btype *type, Rust::ABI abi)\n   return insert_type_attribute (type, abi_string);\n }\n \n-Btype *\n-Gcc_backend::insert_type_attribute (Btype *type, const std::string &attrname)\n+tree\n+Gcc_backend::insert_type_attribute (tree type, const std::string &attrname)\n {\n   tree ident = get_identifier (attrname.c_str ());\n \n   tree attribs = NULL_TREE;\n-  tree old_attrs = TYPE_ATTRIBUTES (type->get_tree ());\n+  tree old_attrs = TYPE_ATTRIBUTES (type);\n   if (old_attrs)\n     attribs = merge_type_attributes (old_attrs,\n \t\t\t\t     tree_cons (ident, NULL_TREE, NULL_TREE));\n   else\n     attribs = tree_cons (ident, NULL_TREE, NULL_TREE);\n \n-  tree res = build_type_attribute_variant (type->get_tree (), attribs);\n-  return this->make_type (res);\n+  tree res = build_type_attribute_variant (type, attribs);\n+  return res;\n }\n \n // Make a function type.\n \n-Btype *\n-Gcc_backend::function_type (const Btyped_identifier &receiver,\n-\t\t\t    const std::vector<Btyped_identifier> &parameters,\n-\t\t\t    const std::vector<Btyped_identifier> &results,\n-\t\t\t    Btype *result_struct, Location)\n+tree\n+Gcc_backend::function_type (const typed_identifier &receiver,\n+\t\t\t    const std::vector<typed_identifier> &parameters,\n+\t\t\t    const std::vector<typed_identifier> &results,\n+\t\t\t    tree result_struct, Location)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n@@ -1013,11 +885,11 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n       gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1034,32 +906,32 @@ Gcc_backend::function_type (const Btyped_identifier &receiver,\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n+tree\n Gcc_backend::function_type_varadic (\n-  const Btyped_identifier &receiver,\n-  const std::vector<Btyped_identifier> &parameters,\n-  const std::vector<Btyped_identifier> &results, Btype *result_struct, Location)\n+  const typed_identifier &receiver,\n+  const std::vector<typed_identifier> &parameters,\n+  const std::vector<typed_identifier> &results, tree result_struct, Location)\n {\n-  size_t n = parameters.size () + (receiver.btype != NULL ? 1 : 0);\n+  size_t n = parameters.size () + (receiver.type != NULL_TREE ? 1 : 0);\n   tree *args = XALLOCAVEC (tree, n);\n   size_t offs = 0;\n \n-  if (receiver.btype != NULL)\n+  if (receiver.type != NULL_TREE)\n     {\n-      tree t = receiver.btype->get_tree ();\n+      tree t = receiver.type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n \n       args[offs++] = t;\n     }\n \n-  for (std::vector<Btyped_identifier>::const_iterator p = parameters.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = parameters.begin ();\n        p != parameters.end (); ++p)\n     {\n-      tree t = p->btype->get_tree ();\n+      tree t = p->type;\n       if (t == error_mark_node)\n \treturn this->error_type ();\n       args[offs++] = t;\n@@ -1069,11 +941,11 @@ Gcc_backend::function_type_varadic (\n   if (results.empty ())\n     result = void_type_node;\n   else if (results.size () == 1)\n-    result = results.front ().btype->get_tree ();\n+    result = results.front ().type;\n   else\n     {\n-      gcc_assert (result_struct != NULL);\n-      result = result_struct->get_tree ();\n+      gcc_assert (result_struct != NULL_TREE);\n+      result = result_struct;\n     }\n   if (result == error_mark_node)\n     return this->error_type ();\n@@ -1090,113 +962,105 @@ Gcc_backend::function_type_varadic (\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n-Btype *\n-Gcc_backend::function_ptr_type (Btype *result_type,\n-\t\t\t\tconst std::vector<Btype *> &parameters,\n+tree\n+Gcc_backend::function_ptr_type (tree result_type,\n+\t\t\t\tconst std::vector<tree> &parameters,\n \t\t\t\tLocation /* locus */)\n {\n   tree args = NULL_TREE;\n   tree *pp = &args;\n \n   for (auto &param : parameters)\n     {\n-      tree t = param->get_tree ();\n-      if (t == error_mark_node)\n+      if (param == error_mark_node)\n \treturn this->error_type ();\n \n-      *pp = tree_cons (NULL_TREE, t, NULL_TREE);\n+      *pp = tree_cons (NULL_TREE, param, NULL_TREE);\n       pp = &TREE_CHAIN (*pp);\n     }\n \n   *pp = void_list_node;\n \n-  tree result = result_type->get_tree ();\n+  tree result = result_type;\n   if (result != void_type_node && int_size_in_bytes (result) == 0)\n     result = void_type_node;\n \n   tree fntype = build_function_type (result, args);\n   if (fntype == error_mark_node)\n     return this->error_type ();\n \n-  return this->make_type (build_pointer_type (fntype));\n+  return build_pointer_type (fntype);\n }\n \n // Make a struct type.\n \n-Btype *\n-Gcc_backend::struct_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::struct_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (RECORD_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (RECORD_TYPE), fields);\n }\n \n // Make a union type.\n \n-Btype *\n-Gcc_backend::union_type (const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::union_type (const std::vector<typed_identifier> &fields)\n {\n-  return this->fill_in_fields (this->make_type (make_node (UNION_TYPE)),\n-\t\t\t       fields);\n+  return this->fill_in_fields (make_node (UNION_TYPE), fields);\n }\n \n // Fill in the fields of a struct or union type.\n \n-Btype *\n-Gcc_backend::fill_in_fields (Btype *fill,\n-\t\t\t     const std::vector<Btyped_identifier> &fields)\n+tree\n+Gcc_backend::fill_in_fields (tree fill,\n+\t\t\t     const std::vector<typed_identifier> &fields)\n {\n-  tree fill_tree = fill->get_tree ();\n   tree field_trees = NULL_TREE;\n   tree *pp = &field_trees;\n-  for (std::vector<Btyped_identifier>::const_iterator p = fields.begin ();\n+  for (std::vector<typed_identifier>::const_iterator p = fields.begin ();\n        p != fields.end (); ++p)\n     {\n       tree name_tree = get_identifier_from_string (p->name);\n-      tree type_tree = p->btype->get_tree ();\n+      tree type_tree = p->type;\n       if (type_tree == error_mark_node)\n \treturn this->error_type ();\n       tree field = build_decl (p->location.gcc_location (), FIELD_DECL,\n \t\t\t       name_tree, type_tree);\n-      DECL_CONTEXT (field) = fill_tree;\n+      DECL_CONTEXT (field) = fill;\n       *pp = field;\n       pp = &DECL_CHAIN (field);\n     }\n-  TYPE_FIELDS (fill_tree) = field_trees;\n-  layout_type (fill_tree);\n+  TYPE_FIELDS (fill) = field_trees;\n+  layout_type (fill);\n \n   // Because Rust permits converting between named struct types and\n   // equivalent struct types, for which we use VIEW_CONVERT_EXPR, and\n   // because we don't try to maintain TYPE_CANONICAL for struct types,\n   // we need to tell the middle-end to use structural equality.\n-  SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n+  SET_TYPE_STRUCTURAL_EQUALITY (fill);\n \n   return fill;\n }\n \n // Make an array type.\n \n-Btype *\n-Gcc_backend::array_type (Btype *element_btype, Bexpression *length)\n+tree\n+Gcc_backend::array_type (tree element_type, tree length)\n {\n-  return this->fill_in_array (this->make_type (make_node (ARRAY_TYPE)),\n-\t\t\t      element_btype, length);\n+  return this->fill_in_array (make_node (ARRAY_TYPE), element_type, length);\n }\n \n // Fill in an array type.\n \n-Btype *\n-Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n-\t\t\t    Bexpression *length)\n+tree\n+Gcc_backend::fill_in_array (tree fill, tree element_type, tree length_tree)\n {\n-  tree element_type_tree = element_type->get_tree ();\n-  tree length_tree = length->get_tree ();\n-  if (element_type_tree == error_mark_node || length_tree == error_mark_node)\n+  if (element_type == error_mark_node || length_tree == error_mark_node)\n     return this->error_type ();\n \n-  gcc_assert (TYPE_SIZE (element_type_tree) != NULL_TREE);\n+  gcc_assert (TYPE_SIZE (element_type) != NULL_TREE);\n \n   length_tree = fold_convert (sizetype, length_tree);\n \n@@ -1205,160 +1069,26 @@ Gcc_backend::fill_in_array (Btype *fill, Btype *element_type,\n   tree index_type_tree = build_index_type (\n     fold_build2 (MINUS_EXPR, sizetype, length_tree, size_one_node));\n \n-  tree fill_tree = fill->get_tree ();\n-  TREE_TYPE (fill_tree) = element_type_tree;\n-  TYPE_DOMAIN (fill_tree) = index_type_tree;\n-  TYPE_ADDR_SPACE (fill_tree) = TYPE_ADDR_SPACE (element_type_tree);\n-  layout_type (fill_tree);\n+  TREE_TYPE (fill) = element_type;\n+  TYPE_DOMAIN (fill) = index_type_tree;\n+  TYPE_ADDR_SPACE (fill) = TYPE_ADDR_SPACE (element_type);\n+  layout_type (fill);\n \n-  if (TYPE_STRUCTURAL_EQUALITY_P (element_type_tree))\n-    SET_TYPE_STRUCTURAL_EQUALITY (fill_tree);\n-  else if (TYPE_CANONICAL (element_type_tree) != element_type_tree\n+  if (TYPE_STRUCTURAL_EQUALITY_P (element_type))\n+    SET_TYPE_STRUCTURAL_EQUALITY (fill);\n+  else if (TYPE_CANONICAL (element_type) != element_type\n \t   || TYPE_CANONICAL (index_type_tree) != index_type_tree)\n-    TYPE_CANONICAL (fill_tree)\n-      = build_array_type (TYPE_CANONICAL (element_type_tree),\n-\t\t\t  TYPE_CANONICAL (index_type_tree));\n+    TYPE_CANONICAL (fill) = build_array_type (TYPE_CANONICAL (element_type),\n+\t\t\t\t\t      TYPE_CANONICAL (index_type_tree));\n \n   return fill;\n }\n \n-// Create a placeholder for a pointer type.\n-\n-Btype *\n-Gcc_backend::placeholder_pointer_type (const std::string &name,\n-\t\t\t\t       Location location, bool)\n-{\n-  tree ret = build_distinct_type_copy (ptr_type_node);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Set the real target type for a placeholder pointer type.\n-\n-bool\n-Gcc_backend::set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n-{\n-  tree pt = placeholder->get_tree ();\n-  if (pt == error_mark_node)\n-    return false;\n-  gcc_assert (TREE_CODE (pt) == POINTER_TYPE);\n-  tree tt = to_type->get_tree ();\n-  if (tt == error_mark_node)\n-    {\n-      placeholder->set_tree (error_mark_node);\n-      return false;\n-    }\n-  gcc_assert (TREE_CODE (tt) == POINTER_TYPE);\n-  TREE_TYPE (pt) = TREE_TYPE (tt);\n-  TYPE_CANONICAL (pt) = TYPE_CANONICAL (tt);\n-  if (TYPE_NAME (pt) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_variant_type_copy (pt);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (pt)) = copy;\n-    }\n-  return true;\n-}\n-\n-// Set the real values for a placeholder function type.\n-\n-bool\n-Gcc_backend::set_placeholder_function_type (Btype *placeholder, Btype *ft)\n-{\n-  return this->set_placeholder_pointer_type (placeholder, ft);\n-}\n-\n-// Create a placeholder for a struct type.\n-\n-Btype *\n-Gcc_backend::placeholder_struct_type (const std::string &name,\n-\t\t\t\t      Location location)\n-{\n-  tree ret = make_node (RECORD_TYPE);\n-  if (!name.empty ())\n-    {\n-      tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t      get_identifier_from_string (name), ret);\n-      TYPE_NAME (ret) = decl;\n-\n-      // The struct type that eventually replaces this placeholder will require\n-      // structural equality. The placeholder must too, so that the requirement\n-      // for structural equality propagates to references that are constructed\n-      // before the replacement occurs.\n-      SET_TYPE_STRUCTURAL_EQUALITY (ret);\n-    }\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder struct type.\n-\n-bool\n-Gcc_backend::set_placeholder_struct_type (\n-  Btype *placeholder, const std::vector<Btyped_identifier> &fields)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == RECORD_TYPE && TYPE_FIELDS (t) == NULL_TREE);\n-  Btype *r = this->fill_in_fields (placeholder, fields);\n-\n-  if (TYPE_NAME (t) != NULL_TREE)\n-    {\n-      // Build the data structure gcc wants to see for a typedef.\n-      tree copy = build_distinct_type_copy (t);\n-      TYPE_NAME (copy) = NULL_TREE;\n-      DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-      TYPE_SIZE (copy) = NULL_TREE;\n-      Btype *bc = this->make_type (copy);\n-      this->fill_in_fields (bc, fields);\n-      delete bc;\n-    }\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n-// Create a placeholder for an array type.\n-\n-Btype *\n-Gcc_backend::placeholder_array_type (const std::string &name, Location location)\n-{\n-  tree ret = make_node (ARRAY_TYPE);\n-  tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n-\t\t\t  get_identifier_from_string (name), ret);\n-  TYPE_NAME (ret) = decl;\n-  return this->make_type (ret);\n-}\n-\n-// Fill in the fields of a placeholder array type.\n-\n-bool\n-Gcc_backend::set_placeholder_array_type (Btype *placeholder,\n-\t\t\t\t\t Btype *element_btype,\n-\t\t\t\t\t Bexpression *length)\n-{\n-  tree t = placeholder->get_tree ();\n-  gcc_assert (TREE_CODE (t) == ARRAY_TYPE && TREE_TYPE (t) == NULL_TREE);\n-  Btype *r = this->fill_in_array (placeholder, element_btype, length);\n-\n-  // Build the data structure gcc wants to see for a typedef.\n-  tree copy = build_distinct_type_copy (t);\n-  TYPE_NAME (copy) = NULL_TREE;\n-  DECL_ORIGINAL_TYPE (TYPE_NAME (t)) = copy;\n-\n-  return r->get_tree () != error_mark_node;\n-}\n-\n // Return a named version of a type.\n \n-Btype *\n-Gcc_backend::named_type (const std::string &name, Btype *btype,\n-\t\t\t Location location)\n+tree\n+Gcc_backend::named_type (const std::string &name, tree type, Location location)\n {\n-  tree type = btype->get_tree ();\n   if (type == error_mark_node)\n     return this->error_type ();\n \n@@ -1374,39 +1104,22 @@ Gcc_backend::named_type (const std::string &name, Btype *btype,\n       tree decl = build_decl (BUILTINS_LOCATION, TYPE_DECL,\n \t\t\t      get_identifier_from_string (name), type);\n       TYPE_NAME (type) = decl;\n-      return this->make_type (type);\n+      return type;\n     }\n \n   tree copy = build_variant_type_copy (type);\n   tree decl = build_decl (location.gcc_location (), TYPE_DECL,\n \t\t\t  get_identifier_from_string (name), copy);\n   DECL_ORIGINAL_TYPE (decl) = type;\n   TYPE_NAME (copy) = decl;\n-  return this->make_type (copy);\n-}\n-\n-// Return a pointer type used as a marker for a circular type.\n-\n-Btype *\n-Gcc_backend::circular_pointer_type (Btype *, bool)\n-{\n-  return this->make_type (ptr_type_node);\n-}\n-\n-// Return whether we might be looking at a circular type.\n-\n-bool\n-Gcc_backend::is_circular_pointer_type (Btype *btype)\n-{\n-  return btype->get_tree () == ptr_type_node;\n+  return copy;\n }\n \n // Return the size of a type.\n \n int64_t\n-Gcc_backend::type_size (Btype *btype)\n+Gcc_backend::type_size (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   if (t == void_type_node)\n@@ -1423,9 +1136,8 @@ Gcc_backend::type_size (Btype *btype)\n // Return the alignment of a type.\n \n int64_t\n-Gcc_backend::type_alignment (Btype *btype)\n+Gcc_backend::type_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return TYPE_ALIGN_UNIT (t);\n@@ -1434,9 +1146,8 @@ Gcc_backend::type_alignment (Btype *btype)\n // Return the alignment of a struct field of type BTYPE.\n \n int64_t\n-Gcc_backend::type_field_alignment (Btype *btype)\n+Gcc_backend::type_field_alignment (tree t)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return 1;\n   return rust_field_alignment (t);\n@@ -1445,9 +1156,8 @@ Gcc_backend::type_field_alignment (Btype *btype)\n // Return the offset of a field in a struct.\n \n int64_t\n-Gcc_backend::type_field_offset (Btype *btype, size_t index)\n+Gcc_backend::type_field_offset (tree struct_tree, size_t index)\n {\n-  tree struct_tree = btype->get_tree ();\n   if (struct_tree == error_mark_node)\n     return 0;\n   gcc_assert (TREE_CODE (struct_tree) == RECORD_TYPE);\n@@ -1465,37 +1175,34 @@ Gcc_backend::type_field_offset (Btype *btype, size_t index)\n \n // Return the zero value for a type.\n \n-Bexpression *\n-Gcc_backend::zero_expression (Btype *btype)\n+tree\n+Gcc_backend::zero_expression (tree t)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     ret = error_mark_node;\n   else\n     ret = build_zero_cst (t);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that references a variable.\n \n-Bexpression *\n+tree\n Gcc_backend::var_expression (Bvariable *var, Location location)\n {\n   tree ret = var->get_tree (location);\n   if (ret == error_mark_node)\n     return this->error_expression ();\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that indirectly references an expression.\n \n-Bexpression *\n-Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n+tree\n+Gcc_backend::indirect_expression (tree type_tree, tree expr_tree,\n \t\t\t\t  bool known_valid, Location location)\n {\n-  tree expr_tree = expr->get_tree ();\n-  tree type_tree = btype->get_tree ();\n   if (expr_tree == error_mark_node || type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1509,18 +1216,16 @@ Gcc_backend::indirect_expression (Btype *btype, Bexpression *expr,\n   tree ret = build_fold_indirect_ref_loc (location.gcc_location (), expr_tree);\n   if (known_valid)\n     TREE_THIS_NOTRAP (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that declares a constant named NAME with the\n // constant value VAL in BTYPE.\n \n-Bexpression *\n-Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n-\t\t\t\t\tBexpression *val, Location location)\n+tree\n+Gcc_backend::named_constant_expression (tree type_tree, const std::string &name,\n+\t\t\t\t\ttree const_val, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n-  tree const_val = val->get_tree ();\n   if (type_tree == error_mark_node || const_val == error_mark_node)\n     return this->error_expression ();\n \n@@ -1532,28 +1237,26 @@ Gcc_backend::named_constant_expression (Btype *btype, const std::string &name,\n   TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return this->make_expression (decl);\n+  return decl;\n }\n \n // Return a typed value as a constant integer.\n \n-Bexpression *\n-Gcc_backend::integer_constant_expression (Btype *btype, mpz_t val)\n+tree\n+Gcc_backend::integer_constant_expression (tree t, mpz_t val)\n {\n-  tree t = btype->get_tree ();\n   if (t == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = double_int_to_tree (t, mpz_get_double_int (t, val, true));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed value as a constant floating-point number.\n \n-Bexpression *\n-Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n+tree\n+Gcc_backend::float_constant_expression (tree t, mpfr_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1563,15 +1266,14 @@ Gcc_backend::float_constant_expression (Btype *btype, mpfr_t val)\n   REAL_VALUE_TYPE r2;\n   real_convert (&r2, TYPE_MODE (t), &r1);\n   ret = build_real (t, r2);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return a typed real and imaginary value as a constant complex number.\n \n-Bexpression *\n-Gcc_backend::complex_constant_expression (Btype *btype, mpc_t val)\n+tree\n+Gcc_backend::complex_constant_expression (tree t, mpc_t val)\n {\n-  tree t = btype->get_tree ();\n   tree ret;\n   if (t == error_mark_node)\n     return this->error_expression ();\n@@ -1588,12 +1290,12 @@ Gcc_backend::complex_constant_expression (Btype *btype, mpc_t val)\n \n   ret = build_complex (t, build_real (TREE_TYPE (t), r2),\n \t\t       build_real (TREE_TYPE (t), r4));\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a constant string expression.\n \n-Bexpression *\n+tree\n Gcc_backend::string_constant_expression (const std::string &val)\n {\n   tree index_type = build_index_type (size_int (val.length ()));\n@@ -1603,70 +1305,63 @@ Gcc_backend::string_constant_expression (const std::string &val)\n   tree string_val = build_string (val.length (), val.data ());\n   TREE_TYPE (string_val) = string_type;\n \n-  return this->make_expression (string_val);\n+  return string_val;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::wchar_constant_expression (wchar_t c)\n {\n-  tree ret = build_int_cst (this->wchar_type ()->get_tree (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->wchar_type (), c);\n }\n \n-Bexpression *\n+tree\n Gcc_backend::char_constant_expression (char c)\n {\n-  tree ret = build_int_cst (this->char_type ()->get_tree (), c);\n-  return this->make_expression (ret);\n+  return build_int_cst (this->char_type (), c);\n }\n \n // Make a constant boolean expression.\n \n-Bexpression *\n+tree\n Gcc_backend::boolean_constant_expression (bool val)\n {\n-  tree bool_cst = val ? boolean_true_node : boolean_false_node;\n-  return this->make_expression (bool_cst);\n+  return val ? boolean_true_node : boolean_false_node;\n }\n \n // Return the real part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::real_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::real_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), REALPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return the imaginary part of a complex expression.\n \n-Bexpression *\n-Gcc_backend::imag_part_expression (Bexpression *bcomplex, Location location)\n+tree\n+Gcc_backend::imag_part_expression (tree complex_tree, Location location)\n {\n-  tree complex_tree = bcomplex->get_tree ();\n   if (complex_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (COMPLEX_FLOAT_TYPE_P (TREE_TYPE (complex_tree)));\n   tree ret\n     = fold_build1_loc (location.gcc_location (), IMAGPART_EXPR,\n \t\t       TREE_TYPE (TREE_TYPE (complex_tree)), complex_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Make a complex expression given its real and imaginary parts.\n \n-Bexpression *\n-Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n+tree\n+Gcc_backend::complex_expression (tree real_tree, tree imag_tree,\n \t\t\t\t Location location)\n {\n-  tree real_tree = breal->get_tree ();\n-  tree imag_tree = bimag->get_tree ();\n   if (real_tree == error_mark_node || imag_tree == error_mark_node)\n     return this->error_expression ();\n   gcc_assert (TYPE_MAIN_VARIANT (TREE_TYPE (real_tree))\n@@ -1675,23 +1370,22 @@ Gcc_backend::complex_expression (Bexpression *breal, Bexpression *bimag,\n   tree ret = fold_build2_loc (location.gcc_location (), COMPLEX_EXPR,\n \t\t\t      build_complex_type (TREE_TYPE (real_tree)),\n \t\t\t      real_tree, imag_tree);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression that converts an expression to a different type.\n \n-Bexpression *\n-Gcc_backend::convert_expression (Btype *type, Bexpression *expr,\n+tree\n+Gcc_backend::convert_expression (tree type_tree, tree expr_tree,\n \t\t\t\t Location location)\n {\n-  tree type_tree = type->get_tree ();\n-  tree expr_tree = expr->get_tree ();\n   if (type_tree == error_mark_node || expr_tree == error_mark_node\n       || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n   tree ret;\n-  if (this->type_size (type) == 0 || TREE_TYPE (expr_tree) == void_type_node)\n+  if (this->type_size (type_tree) == 0\n+      || TREE_TYPE (expr_tree) == void_type_node)\n     {\n       // Do not convert zero-sized types.\n       ret = expr_tree;\n@@ -1712,42 +1406,38 @@ Gcc_backend::convert_expression (Btype *type, Bexpression *expr,\n   else\n     ret = fold_convert_loc (location.gcc_location (), type_tree, expr_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of a function.\n \n-Bexpression *\n-Gcc_backend::function_code_expression (Bfunction *bfunc, Location location)\n+tree\n+Gcc_backend::function_code_expression (tree func, Location location)\n {\n-  tree func = bfunc->get_tree ();\n   if (func == error_mark_node)\n     return this->error_expression ();\n \n   tree ret = build_fold_addr_expr_loc (location.gcc_location (), func);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Get the address of an expression.\n \n-Bexpression *\n-Gcc_backend::address_expression (Bexpression *bexpr, Location location)\n+tree\n+Gcc_backend::address_expression (tree expr, Location location)\n {\n-  tree expr = bexpr->get_tree ();\n   if (expr == error_mark_node)\n     return this->error_expression ();\n \n-  tree ret = build_fold_addr_expr_loc (location.gcc_location (), expr);\n-  return this->make_expression (ret);\n+  return build_fold_addr_expr_loc (location.gcc_location (), expr);\n }\n \n // Return an expression for the field at INDEX in BSTRUCT.\n \n-Bexpression *\n-Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n+tree\n+Gcc_backend::struct_field_expression (tree struct_tree, size_t index,\n \t\t\t\t      Location location)\n {\n-  tree struct_tree = bstruct->get_tree ();\n   if (struct_tree == error_mark_node\n       || TREE_TYPE (struct_tree) == error_mark_node)\n     return this->error_expression ();\n@@ -1771,43 +1461,35 @@ Gcc_backend::struct_field_expression (Bexpression *bstruct, size_t index,\n \t\t\t      TREE_TYPE (field), struct_tree, field, NULL_TREE);\n   if (TREE_CONSTANT (struct_tree))\n     TREE_CONSTANT (ret) = 1;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes BSTAT before BEXPR.\n \n-Bexpression *\n-Gcc_backend::compound_expression (Bstatement *bstat, Bexpression *bexpr,\n-\t\t\t\t  Location location)\n+tree\n+Gcc_backend::compound_expression (tree stat, tree expr, Location location)\n {\n-  tree stat = bstat->get_tree ();\n-  tree expr = bexpr->get_tree ();\n   if (stat == error_mark_node || expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t      TREE_TYPE (expr), stat, expr);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression that executes THEN_EXPR if CONDITION is true, or\n // ELSE_EXPR otherwise.\n \n-Bexpression *\n-Gcc_backend::conditional_expression (Bfunction *, Btype *btype,\n-\t\t\t\t     Bexpression *condition,\n-\t\t\t\t     Bexpression *then_expr,\n-\t\t\t\t     Bexpression *else_expr, Location location)\n-{\n-  tree type_tree = btype == NULL ? void_type_node : btype->get_tree ();\n-  tree cond_tree = condition->get_tree ();\n-  tree then_tree = then_expr->get_tree ();\n-  tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree ();\n-  if (type_tree == error_mark_node || cond_tree == error_mark_node\n-      || then_tree == error_mark_node || else_tree == error_mark_node)\n+tree\n+Gcc_backend::conditional_expression (tree, tree type_tree, tree cond_expr,\n+\t\t\t\t     tree then_expr, tree else_expr,\n+\t\t\t\t     Location location)\n+{\n+  if (type_tree == error_mark_node || cond_expr == error_mark_node\n+      || then_expr == error_mark_node || else_expr == error_mark_node)\n     return this->error_expression ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, type_tree,\n-\t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_expression (ret);\n+\t\t\t cond_expr, then_expr, else_expr);\n+  return ret;\n }\n \n /* Helper function that converts rust operators to equivalent GCC tree_code.\n@@ -1909,13 +1591,12 @@ is_floating_point (tree t)\n }\n \n // Return an expression for the negation operation OP EXPR.\n-Bexpression *\n-Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n+tree\n+Gcc_backend::negation_expression (NegationOperator op, tree expr_tree,\n \t\t\t\t  Location location)\n {\n   /* Check if the expression is an error, in which case we return an error\n      expression. */\n-  auto expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node || TREE_TYPE (expr_tree) == error_mark_node)\n     return this->error_expression ();\n \n@@ -1944,20 +1625,17 @@ Gcc_backend::negation_expression (NegationOperator op, Bexpression *expr,\n \t\t\t\t   tree_type, expr_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, expr_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the arithmetic or logical operation LEFT OP RIGHT.\n-Bexpression *\n+tree\n Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n-\t\t\t\t\t       Bexpression *left,\n-\t\t\t\t\t       Bexpression *right,\n+\t\t\t\t\t       tree left_tree, tree right_tree,\n \t\t\t\t\t       Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -1990,18 +1668,16 @@ Gcc_backend::arithmetic_or_logical_expression (ArithmeticOrLogicalOperator op,\n \t\t\t\t   tree_type, left_tree, right_tree);\n   if (floating_point && extended_type != NULL_TREE)\n     new_tree = convert (original_type, new_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the comparison operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n-\t\t\t\t    Bexpression *right, Location location)\n+tree\n+Gcc_backend::comparison_expression (ComparisonOperator op, tree left_tree,\n+\t\t\t\t    tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2012,18 +1688,16 @@ Gcc_backend::comparison_expression (ComparisonOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression for the lazy boolean operation LEFT OP RIGHT.\n-Bexpression *\n-Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n-\t\t\t\t      Bexpression *right, Location location)\n+tree\n+Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, tree left_tree,\n+\t\t\t\t      tree right_tree, Location location)\n {\n   /* Check if either expression is an error, in which case we return an error\n      expression. */\n-  auto left_tree = left->get_tree ();\n-  auto right_tree = right->get_tree ();\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2035,17 +1709,16 @@ Gcc_backend::lazy_boolean_expression (LazyBooleanOperator op, Bexpression *left,\n   /* Construct a new tree and build an expression from it. */\n   auto new_tree = fold_build2_loc (location.gcc_location (), tree_code,\n \t\t\t\t   tree_type, left_tree, right_tree);\n-  return this->make_expression (new_tree);\n+  return new_tree;\n }\n \n // Return an expression that constructs BTYPE with VALS.\n \n-Bexpression *\n-Gcc_backend::constructor_expression (Btype *btype,\n-\t\t\t\t     const std::vector<Bexpression *> &vals,\n+tree\n+Gcc_backend::constructor_expression (tree type_tree,\n+\t\t\t\t     const std::vector<tree> &vals,\n \t\t\t\t     int union_index, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2058,7 +1731,7 @@ Gcc_backend::constructor_expression (Btype *btype,\n   if (union_index != -1)\n     {\n       gcc_assert (TREE_CODE (type_tree) == UNION_TYPE);\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       for (int i = 0; i < union_index; i++)\n \t{\n \t  gcc_assert (field != NULL_TREE);\n@@ -2090,11 +1763,11 @@ Gcc_backend::constructor_expression (Btype *btype,\n   else\n     {\n       gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); ++p, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (TREE_TYPE (field) == error_mark_node || val == error_mark_node\n \t      || TREE_TYPE (val) == error_mark_node)\n \t    return this->error_expression ();\n@@ -2125,15 +1798,14 @@ Gcc_backend::constructor_expression (Btype *btype,\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n-Bexpression *\n+tree\n Gcc_backend::array_constructor_expression (\n-  Btype *array_btype, const std::vector<unsigned long> &indexes,\n-  const std::vector<Bexpression *> &vals, Location location)\n+  tree type_tree, const std::vector<unsigned long> &indexes,\n+  const std::vector<tree> &vals, Location location)\n {\n-  tree type_tree = array_btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_expression ();\n \n@@ -2149,7 +1821,7 @@ Gcc_backend::array_constructor_expression (\n   for (size_t i = 0; i < vals.size (); ++i)\n     {\n       tree index = size_int (indexes[i]);\n-      tree val = (vals[i])->get_tree ();\n+      tree val = vals[i];\n \n       if (index == error_mark_node || val == error_mark_node)\n \treturn this->error_expression ();\n@@ -2179,17 +1851,15 @@ Gcc_backend::array_constructor_expression (\n   if (sink != NULL_TREE)\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR, type_tree,\n \t\t\t   sink, ret);\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Return an expression for the address of BASE[INDEX].\n \n-Bexpression *\n-Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n+tree\n+Gcc_backend::pointer_offset_expression (tree base_tree, tree index_tree,\n \t\t\t\t\tLocation location)\n {\n-  tree base_tree = base->get_tree ();\n-  tree index_tree = index->get_tree ();\n   tree element_type_tree = TREE_TYPE (TREE_TYPE (base_tree));\n   if (base_tree == error_mark_node || TREE_TYPE (base_tree) == error_mark_node\n       || index_tree == error_mark_node || element_type_tree == error_mark_node)\n@@ -2202,17 +1872,15 @@ Gcc_backend::pointer_offset_expression (Bexpression *base, Bexpression *index,\n \t\t\t\t index_tree, element_size);\n   tree ptr = fold_build2_loc (location.gcc_location (), POINTER_PLUS_EXPR,\n \t\t\t      TREE_TYPE (base_tree), base_tree, offset);\n-  return this->make_expression (ptr);\n+  return ptr;\n }\n \n // Return an expression representing ARRAY[INDEX]\n \n-Bexpression *\n-Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n+tree\n+Gcc_backend::array_index_expression (tree array_tree, tree index_tree,\n \t\t\t\t     Location location)\n {\n-  tree array_tree = array->get_tree ();\n-  tree index_tree = index->get_tree ();\n   if (array_tree == error_mark_node || TREE_TYPE (array_tree) == error_mark_node\n       || index_tree == error_mark_node)\n     return this->error_expression ();\n@@ -2229,17 +1897,15 @@ Gcc_backend::array_index_expression (Bexpression *array, Bexpression *index,\n     ret = fold_build2_loc (location.gcc_location (), COMPOUND_EXPR,\n \t\t\t   void_type_node, array_tree, index_tree);\n \n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // Create an expression for a call to FN_EXPR with FN_ARGS.\n-Bexpression *\n-Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n-\t\t\t      Bexpression *fn_expr,\n-\t\t\t      const std::vector<Bexpression *> &fn_args,\n-\t\t\t      Bexpression *chain_expr, Location location)\n+tree\n+Gcc_backend::call_expression (tree, // containing fcn for call\n+\t\t\t      tree fn, const std::vector<tree> &fn_args,\n+\t\t\t      tree chain_expr, Location location)\n {\n-  tree fn = fn_expr->get_tree ();\n   if (fn == error_mark_node || TREE_TYPE (fn) == error_mark_node)\n     return this->error_expression ();\n \n@@ -2250,7 +1916,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n   tree *args = nargs == 0 ? NULL : new tree[nargs];\n   for (size_t i = 0; i < nargs; ++i)\n     {\n-      args[i] = fn_args.at (i)->get_tree ();\n+      args[i] = fn_args.at (i);\n       if (args[i] == error_mark_node)\n \treturn this->error_expression ();\n     }\n@@ -2296,7 +1962,7 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n \t\t\t    fn, nargs, args);\n \n   if (chain_expr)\n-    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr->get_tree ();\n+    CALL_EXPR_STATIC_CHAIN (ret) = chain_expr;\n \n   if (excess_type != NULL_TREE)\n     {\n@@ -2306,24 +1972,23 @@ Gcc_backend::call_expression (Bfunction *, // containing fcn for call\n     }\n \n   delete[] args;\n-  return this->make_expression (ret);\n+  return ret;\n }\n \n // An expression as a statement.\n \n-Bstatement *\n-Gcc_backend::expression_statement (Bfunction *, Bexpression *expr)\n+tree\n+Gcc_backend::expression_statement (tree, tree expr)\n {\n-  return this->make_statement (expr->get_tree ());\n+  return expr;\n }\n \n // Variable initialization.\n \n-Bstatement *\n-Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n+tree\n+Gcc_backend::init_statement (tree, Bvariable *var, tree init_tree)\n {\n   tree var_tree = var->get_decl ();\n-  tree init_tree = init->get_tree ();\n   if (var_tree == error_mark_node || init_tree == error_mark_node)\n     return this->error_statement ();\n   gcc_assert (TREE_CODE (var_tree) == VAR_DECL);\n@@ -2347,18 +2012,16 @@ Gcc_backend::init_statement (Bfunction *, Bvariable *var, Bexpression *init)\n     ret = build2_loc (DECL_SOURCE_LOCATION (var_tree), COMPOUND_EXPR,\n \t\t      void_type_node, init_tree, ret);\n \n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Assignment.\n \n-Bstatement *\n-Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n-\t\t\t\t   Bexpression *rhs, Location location)\n+tree\n+Gcc_backend::assignment_statement (tree bfn, tree lhs, tree rhs,\n+\t\t\t\t   Location location)\n {\n-  tree lhs_tree = lhs->get_tree ();\n-  tree rhs_tree = rhs->get_tree ();\n-  if (lhs_tree == error_mark_node || rhs_tree == error_mark_node)\n+  if (lhs == error_mark_node || rhs == error_mark_node)\n     return this->error_statement ();\n \n   // To avoid problems with GNU ld, we don't make zero-sized\n@@ -2367,28 +2030,25 @@ Gcc_backend::assignment_statement (Bfunction *bfn, Bexpression *lhs,\n   // expression; avoid crashes here by avoiding assignments of\n   // zero-sized expressions.  Such assignments don't really mean\n   // anything anyhow.\n-  if (TREE_TYPE (lhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (lhs_tree)) == 0\n-      || TREE_TYPE (rhs_tree) == void_type_node\n-      || int_size_in_bytes (TREE_TYPE (rhs_tree)) == 0)\n+  if (TREE_TYPE (lhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (lhs)) == 0\n+      || TREE_TYPE (rhs) == void_type_node\n+      || int_size_in_bytes (TREE_TYPE (rhs)) == 0)\n     return this->compound_statement (this->expression_statement (bfn, lhs),\n \t\t\t\t     this->expression_statement (bfn, rhs));\n \n-  rhs_tree = this->convert_tree (TREE_TYPE (lhs_tree), rhs_tree, location);\n+  rhs = this->convert_tree (TREE_TYPE (lhs), rhs, location);\n \n-  return this->make_statement (fold_build2_loc (location.gcc_location (),\n-\t\t\t\t\t\tMODIFY_EXPR, void_type_node,\n-\t\t\t\t\t\tlhs_tree, rhs_tree));\n+  return fold_build2_loc (location.gcc_location (), MODIFY_EXPR, void_type_node,\n+\t\t\t  lhs, rhs);\n }\n \n // Return.\n \n-Bstatement *\n-Gcc_backend::return_statement (Bfunction *bfunction,\n-\t\t\t       const std::vector<Bexpression *> &vals,\n+tree\n+Gcc_backend::return_statement (tree fntree, const std::vector<tree> &vals,\n \t\t\t       Location location)\n {\n-  tree fntree = bfunction->get_tree ();\n   if (fntree == error_mark_node)\n     return this->error_statement ();\n   tree result = DECL_RESULT (fntree);\n@@ -2402,18 +2062,18 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n   if (res_type == void_type_node || int_size_in_bytes (res_type) == 0)\n     {\n       tree stmt_list = NULL_TREE;\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++)\n \t{\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (val, &stmt_list);\n \t}\n       tree ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t\t  void_type_node, NULL_TREE);\n       append_to_statement_list (ret, &stmt_list);\n-      return this->make_statement (stmt_list);\n+      return stmt_list;\n     }\n \n   tree ret;\n@@ -2422,12 +2082,11 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n \t\t\t   void_type_node, NULL_TREE);\n   else if (vals.size () == 1)\n     {\n-      tree val = vals.front ()->get_tree ();\n+      tree val = vals.front ();\n       if (val == error_mark_node)\n \treturn this->error_statement ();\n-      tree set\n-\t= fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t   void_type_node, result, vals.front ()->get_tree ());\n+      tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n+\t\t\t\t  void_type_node, result, vals.front ());\n       ret = fold_build1_loc (location.gcc_location (), RETURN_EXPR,\n \t\t\t     void_type_node, set);\n     }\n@@ -2448,18 +2107,18 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       pop_cfun ();\n \n       tree field = TYPE_FIELDS (rettype);\n-      for (std::vector<Bexpression *>::const_iterator p = vals.begin ();\n+      for (std::vector<tree>::const_iterator p = vals.begin ();\n \t   p != vals.end (); p++, field = DECL_CHAIN (field))\n \t{\n \t  gcc_assert (field != NULL_TREE);\n \t  tree ref\n \t    = fold_build3_loc (location.gcc_location (), COMPONENT_REF,\n \t\t\t       TREE_TYPE (field), rettmp, field, NULL_TREE);\n-\t  tree val = (*p)->get_tree ();\n+\t  tree val = (*p);\n \t  if (val == error_mark_node)\n \t    return this->error_statement ();\n \t  tree set = fold_build2_loc (location.gcc_location (), MODIFY_EXPR,\n-\t\t\t\t      void_type_node, ref, (*p)->get_tree ());\n+\t\t\t\t      void_type_node, ref, (*p));\n \t  append_to_statement_list (set, &stmt_list);\n \t}\n       gcc_assert (field == NULL_TREE);\n@@ -2470,7 +2129,7 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n       append_to_statement_list (ret_expr, &stmt_list);\n       ret = stmt_list;\n     }\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if an\n@@ -2479,142 +2138,127 @@ Gcc_backend::return_statement (Bfunction *bfunction,\n // functions.  In C++, the resulting code is of this form:\n //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n \n-Bstatement *\n-Gcc_backend::exception_handler_statement (Bstatement *bstat,\n-\t\t\t\t\t  Bstatement *except_stmt,\n-\t\t\t\t\t  Bstatement *finally_stmt,\n-\t\t\t\t\t  Location location)\n+tree\n+Gcc_backend::exception_handler_statement (tree try_stmt, tree except_stmt,\n+\t\t\t\t\t  tree finally_stmt, Location location)\n {\n-  tree stat_tree = bstat->get_tree ();\n-  tree except_tree = except_stmt == NULL ? NULL_TREE : except_stmt->get_tree ();\n-  tree finally_tree\n-    = finally_stmt == NULL ? NULL_TREE : finally_stmt->get_tree ();\n-\n-  if (stat_tree == error_mark_node || except_tree == error_mark_node\n-      || finally_tree == error_mark_node)\n+  if (try_stmt == error_mark_node || except_stmt == error_mark_node\n+      || finally_stmt == error_mark_node)\n     return this->error_statement ();\n \n-  if (except_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n-\t\t\t    void_type_node, stat_tree,\n-\t\t\t    build2_loc (location.gcc_location (), CATCH_EXPR,\n-\t\t\t\t\tvoid_type_node, NULL, except_tree));\n-  if (finally_tree != NULL_TREE)\n-    stat_tree = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n-\t\t\t    void_type_node, stat_tree, finally_tree);\n-  return this->make_statement (stat_tree);\n+  if (except_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_CATCH_EXPR,\n+\t\t\t   void_type_node, try_stmt,\n+\t\t\t   build2_loc (location.gcc_location (), CATCH_EXPR,\n+\t\t\t\t       void_type_node, NULL, except_stmt));\n+  if (finally_stmt != NULL_TREE)\n+    try_stmt = build2_loc (location.gcc_location (), TRY_FINALLY_EXPR,\n+\t\t\t   void_type_node, try_stmt, finally_stmt);\n+  return try_stmt;\n }\n \n // If.\n \n-Bstatement *\n-Gcc_backend::if_statement (Bfunction *, Bexpression *condition,\n-\t\t\t   Bblock *then_block, Bblock *else_block,\n+tree\n+Gcc_backend::if_statement (tree, tree cond_tree, tree then_tree, tree else_tree,\n \t\t\t   Location location)\n {\n-  tree cond_tree = condition->get_tree ();\n-  tree then_tree = then_block->get_tree ();\n-  tree else_tree = else_block == NULL ? NULL_TREE : else_block->get_tree ();\n   if (cond_tree == error_mark_node || then_tree == error_mark_node\n       || else_tree == error_mark_node)\n     return this->error_statement ();\n   tree ret = build3_loc (location.gcc_location (), COND_EXPR, void_type_node,\n \t\t\t cond_tree, then_tree, else_tree);\n-  return this->make_statement (ret);\n+  return ret;\n }\n \n // Loops\n \n-Bexpression *\n-Gcc_backend::loop_expression (Bblock *body, Location locus)\n+tree\n+Gcc_backend::loop_expression (tree body, Location locus)\n {\n-  tree loop_expr_tree = fold_build1_loc (locus.gcc_location (), LOOP_EXPR,\n-\t\t\t\t\t void_type_node, body->get_tree ());\n-  return this->make_expression (loop_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), LOOP_EXPR, void_type_node,\n+\t\t\t  body);\n }\n \n-Bexpression *\n-Gcc_backend::exit_expression (Bexpression *condition, Location locus)\n+tree\n+Gcc_backend::exit_expression (tree cond_tree, Location locus)\n {\n-  tree cond_tree = condition->get_tree ();\n-  tree exit_expr_tree = fold_build1_loc (locus.gcc_location (), EXIT_EXPR,\n-\t\t\t\t\t void_type_node, cond_tree);\n-  return this->make_expression (exit_expr_tree);\n+  return fold_build1_loc (locus.gcc_location (), EXIT_EXPR, void_type_node,\n+\t\t\t  cond_tree);\n }\n \n // Switch.\n \n-Bstatement *\n-Gcc_backend::switch_statement (\n-  Bfunction *function, Bexpression *value,\n-  const std::vector<std::vector<Bexpression *> > &cases,\n-  const std::vector<Bstatement *> &statements, Location switch_location)\n+tree\n+Gcc_backend::switch_statement (tree decl, tree value,\n+\t\t\t       const std::vector<std::vector<tree>> &cases,\n+\t\t\t       const std::vector<tree> &statements,\n+\t\t\t       Location switch_location)\n {\n   gcc_assert (cases.size () == statements.size ());\n \n-  tree decl = function->get_tree ();\n   if (DECL_STRUCT_FUNCTION (decl) == NULL)\n     push_struct_function (decl);\n   else\n     push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n   tree stmt_list = NULL_TREE;\n-  std::vector<std::vector<Bexpression *> >::const_iterator pc = cases.begin ();\n-  for (std::vector<Bstatement *>::const_iterator ps = statements.begin ();\n+  std::vector<std::vector<tree>>::const_iterator pc = cases.begin ();\n+  for (std::vector<tree>::const_iterator ps = statements.begin ();\n        ps != statements.end (); ++ps, ++pc)\n     {\n       if (pc->empty ())\n \t{\n-\t  location_t loc = (*ps != NULL ? EXPR_LOCATION ((*ps)->get_tree ())\n-\t\t\t\t\t: UNKNOWN_LOCATION);\n+\t  location_t loc\n+\t    = (*ps != NULL ? EXPR_LOCATION (*ps) : UNKNOWN_LOCATION);\n \t  tree label = create_artificial_label (loc);\n \t  tree c = build_case_label (NULL_TREE, NULL_TREE, label);\n \t  append_to_statement_list (c, &stmt_list);\n \t}\n       else\n \t{\n-\t  for (std::vector<Bexpression *>::const_iterator pcv = pc->begin ();\n+\t  for (std::vector<tree>::const_iterator pcv = pc->begin ();\n \t       pcv != pc->end (); ++pcv)\n \t    {\n-\t      tree t = (*pcv)->get_tree ();\n+\t      tree t = (*pcv);\n \t      if (t == error_mark_node)\n \t\treturn this->error_statement ();\n \t      location_t loc = EXPR_LOCATION (t);\n \t      tree label = create_artificial_label (loc);\n-\t      tree c = build_case_label ((*pcv)->get_tree (), NULL_TREE, label);\n+\t      tree c = build_case_label ((*pcv), NULL_TREE, label);\n \t      append_to_statement_list (c, &stmt_list);\n \t    }\n \t}\n \n       if (*ps != NULL)\n \t{\n-\t  tree t = (*ps)->get_tree ();\n+\t  tree t = (*ps);\n \t  if (t == error_mark_node)\n \t    return this->error_statement ();\n \t  append_to_statement_list (t, &stmt_list);\n \t}\n     }\n   pop_cfun ();\n \n-  tree tv = value->get_tree ();\n+  tree tv = value;\n   if (tv == error_mark_node)\n     return this->error_statement ();\n   tree t = build2_loc (switch_location.gcc_location (), SWITCH_EXPR, NULL_TREE,\n \t\t       tv, stmt_list);\n-  return this->make_statement (t);\n+  return t;\n }\n \n // Pair of statements.\n \n-Bstatement *\n-Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n+tree\n+Gcc_backend::compound_statement (tree s1, tree s2)\n {\n   tree stmt_list = NULL_TREE;\n-  tree t = s1->get_tree ();\n+  tree t = s1;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n-  t = s2->get_tree ();\n+  t = s2;\n   if (t == error_mark_node)\n     return this->error_statement ();\n   append_to_statement_list (t, &stmt_list);\n@@ -2624,40 +2268,39 @@ Gcc_backend::compound_statement (Bstatement *s1, Bstatement *s2)\n   if (stmt_list == NULL_TREE)\n     stmt_list = integer_zero_node;\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // List of statements.\n \n-Bstatement *\n-Gcc_backend::statement_list (const std::vector<Bstatement *> &statements)\n+tree\n+Gcc_backend::statement_list (const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree t = (*p)->get_tree ();\n+      tree t = (*p);\n       if (t == error_mark_node)\n \treturn this->error_statement ();\n       append_to_statement_list (t, &stmt_list);\n     }\n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Make a block.  For some reason gcc uses a dual structure for\n // blocks: BLOCK tree nodes and BIND_EXPR tree nodes.  Since the\n // BIND_EXPR node points to the BLOCK node, we store the BIND_EXPR in\n // the Bblock.\n \n-Bblock *\n-Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n+tree\n+Gcc_backend::block (tree fndecl, tree enclosing,\n \t\t    const std::vector<Bvariable *> &vars,\n \t\t    Location start_location, Location)\n {\n   tree block_tree = make_node (BLOCK);\n   if (enclosing == NULL)\n     {\n-      tree fndecl = function->get_tree ();\n       gcc_assert (fndecl != NULL_TREE);\n \n       // We may have already created a block for local variables when\n@@ -2680,8 +2323,7 @@ Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n     }\n   else\n     {\n-      tree superbind_tree = enclosing->get_tree ();\n-      tree superblock_tree = BIND_EXPR_BLOCK (superbind_tree);\n+      tree superblock_tree = BIND_EXPR_BLOCK (enclosing);\n       gcc_assert (TREE_CODE (superblock_tree) == BLOCK);\n \n       BLOCK_SUPERCONTEXT (block_tree) = superblock_tree;\n@@ -2708,37 +2350,35 @@ Gcc_backend::block (Bfunction *function, Bblock *enclosing,\n     = build3_loc (start_location.gcc_location (), BIND_EXPR, void_type_node,\n \t\t  BLOCK_VARS (block_tree), NULL_TREE, block_tree);\n   TREE_SIDE_EFFECTS (bind_tree) = 1;\n-  return new Bblock (bind_tree);\n+  return bind_tree;\n }\n \n // Add statements to a block.\n \n void\n-Gcc_backend::block_add_statements (Bblock *bblock,\n-\t\t\t\t   const std::vector<Bstatement *> &statements)\n+Gcc_backend::block_add_statements (tree bind_tree,\n+\t\t\t\t   const std::vector<tree> &statements)\n {\n   tree stmt_list = NULL_TREE;\n-  for (std::vector<Bstatement *>::const_iterator p = statements.begin ();\n+  for (std::vector<tree>::const_iterator p = statements.begin ();\n        p != statements.end (); ++p)\n     {\n-      tree s = (*p)->get_tree ();\n+      tree s = (*p);\n       if (s != error_mark_node)\n \tappend_to_statement_list (s, &stmt_list);\n     }\n \n-  tree bind_tree = bblock->get_tree ();\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n   BIND_EXPR_BODY (bind_tree) = stmt_list;\n }\n \n // Return a block as a statement.\n \n-Bstatement *\n-Gcc_backend::block_statement (Bblock *bblock)\n+tree\n+Gcc_backend::block_statement (tree bind_tree)\n {\n-  tree bind_tree = bblock->get_tree ();\n   gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n-  return this->make_statement (bind_tree);\n+  return bind_tree;\n }\n \n // This is not static because we declare it with GTY(()) in rust-c.h.\n@@ -2839,11 +2479,10 @@ Gcc_backend::convert_tree (tree type_tree, tree expr_tree, Location location)\n \n Bvariable *\n Gcc_backend::global_variable (const std::string &var_name,\n-\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t      const std::string &asm_name, tree type_tree,\n \t\t\t      bool is_external, bool is_hidden,\n \t\t\t      bool in_unique_section, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -2881,9 +2520,8 @@ Gcc_backend::global_variable (const std::string &var_name,\n // Set the initial value of a global variable.\n \n void\n-Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n+Gcc_backend::global_variable_set_init (Bvariable *var, tree expr_tree)\n {\n-  tree expr_tree = expr->get_tree ();\n   if (expr_tree == error_mark_node)\n     return;\n   gcc_assert (TREE_CONSTANT (expr_tree));\n@@ -2906,16 +2544,15 @@ Gcc_backend::global_variable_set_init (Bvariable *var, Bexpression *expr)\n // Make a local variable.\n \n Bvariable *\n-Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n-\t\t\t     Btype *btype, Bvariable *decl_var,\n+Gcc_backend::local_variable (tree function, const std::string &name,\n+\t\t\t     tree type_tree, Bvariable *decl_var,\n \t\t\t     bool is_address_taken, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n     TREE_ADDRESSABLE (decl) = 1;\n@@ -2931,16 +2568,15 @@ Gcc_backend::local_variable (Bfunction *function, const std::string &name,\n // Make a function parameter variable.\n \n Bvariable *\n-Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n-\t\t\t\t Btype *btype, bool is_address_taken,\n+Gcc_backend::parameter_variable (tree function, const std::string &name,\n+\t\t\t\t tree type_tree, bool is_address_taken,\n \t\t\t\t Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  DECL_CONTEXT (decl) = function->get_tree ();\n+  DECL_CONTEXT (decl) = function;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n   if (is_address_taken)\n@@ -2952,16 +2588,13 @@ Gcc_backend::parameter_variable (Bfunction *function, const std::string &name,\n // Make a static chain variable.\n \n Bvariable *\n-Gcc_backend::static_chain_variable (Bfunction *function,\n-\t\t\t\t    const std::string &name, Btype *btype,\n-\t\t\t\t    Location location)\n+Gcc_backend::static_chain_variable (tree fndecl, const std::string &name,\n+\t\t\t\t    tree type_tree, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   tree decl = build_decl (location.gcc_location (), PARM_DECL,\n \t\t\t  get_identifier_from_string (name), type_tree);\n-  tree fndecl = function->get_tree ();\n   DECL_CONTEXT (decl) = fndecl;\n   DECL_ARG_TYPE (decl) = type_tree;\n   TREE_USED (decl) = 1;\n@@ -2987,17 +2620,13 @@ Gcc_backend::static_chain_variable (Bfunction *function,\n // Make a temporary variable.\n \n Bvariable *\n-Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n-\t\t\t\t Btype *btype, Bexpression *binit,\n-\t\t\t\t bool is_address_taken, Location location,\n-\t\t\t\t Bstatement **pstatement)\n-{\n-  gcc_assert (function != NULL);\n-  tree decl = function->get_tree ();\n-  tree type_tree = btype->get_tree ();\n-  tree init_tree = binit == NULL ? NULL_TREE : binit->get_tree ();\n+Gcc_backend::temporary_variable (tree fndecl, tree bind_tree, tree type_tree,\n+\t\t\t\t tree init_tree, bool is_address_taken,\n+\t\t\t\t Location location, tree *pstatement)\n+{\n+  gcc_assert (fndecl != NULL_TREE);\n   if (type_tree == error_mark_node || init_tree == error_mark_node\n-      || decl == error_mark_node)\n+      || fndecl == error_mark_node)\n     {\n       *pstatement = this->error_statement ();\n       return this->error_variable ();\n@@ -3007,26 +2636,25 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n   // We can only use create_tmp_var if the type is not addressable.\n   if (!TREE_ADDRESSABLE (type_tree))\n     {\n-      if (DECL_STRUCT_FUNCTION (decl) == NULL)\n-\tpush_struct_function (decl);\n+      if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n+\tpush_struct_function (fndecl);\n       else\n-\tpush_cfun (DECL_STRUCT_FUNCTION (decl));\n+\tpush_cfun (DECL_STRUCT_FUNCTION (fndecl));\n \n       var = create_tmp_var (type_tree, \"RUSTTMP\");\n       pop_cfun ();\n     }\n   else\n     {\n-      gcc_assert (bblock != NULL);\n+      gcc_assert (bind_tree != NULL_TREE);\n       var = build_decl (location.gcc_location (), VAR_DECL,\n \t\t\tcreate_tmp_var_name (\"RUSTTMP\"), type_tree);\n       DECL_ARTIFICIAL (var) = 1;\n       DECL_IGNORED_P (var) = 1;\n       TREE_USED (var) = 1;\n-      DECL_CONTEXT (var) = decl;\n+      DECL_CONTEXT (var) = fndecl;\n \n       // We have to add this variable to the BLOCK and the BIND_EXPR.\n-      tree bind_tree = bblock->get_tree ();\n       gcc_assert (TREE_CODE (bind_tree) == BIND_EXPR);\n       tree block_tree = BIND_EXPR_BLOCK (bind_tree);\n       gcc_assert (TREE_CODE (block_tree) == BLOCK);\n@@ -3035,24 +2663,23 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n       BIND_EXPR_VARS (bind_tree) = BLOCK_VARS (block_tree);\n     }\n \n-  if (this->type_size (btype) != 0 && init_tree != NULL_TREE\n+  if (this->type_size (type_tree) != 0 && init_tree != NULL_TREE\n       && TREE_TYPE (init_tree) != void_type_node)\n     DECL_INITIAL (var) = this->convert_tree (type_tree, init_tree, location);\n \n   if (is_address_taken)\n     TREE_ADDRESSABLE (var) = 1;\n \n-  *pstatement = this->make_statement (\n-    build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var));\n+  *pstatement\n+    = build1_loc (location.gcc_location (), DECL_EXPR, void_type_node, var);\n \n   // For a zero sized type, don't initialize VAR with BINIT, but still\n   // evaluate BINIT for its side effects.\n   if (init_tree != NULL_TREE\n-      && (this->type_size (btype) == 0\n+      && (this->type_size (type_tree) == 0\n \t  || TREE_TYPE (init_tree) == void_type_node))\n-    *pstatement\n-      = this->compound_statement (this->expression_statement (function, binit),\n-\t\t\t\t  *pstatement);\n+    *pstatement = this->compound_statement (\n+      this->expression_statement (fndecl, init_tree), *pstatement);\n \n   return new Bvariable (var);\n }\n@@ -3062,11 +2689,10 @@ Gcc_backend::temporary_variable (Bfunction *function, Bblock *bblock,\n \n Bvariable *\n Gcc_backend::implicit_variable (const std::string &name,\n-\t\t\t\tconst std::string &asm_name, Btype *type,\n+\t\t\t\tconst std::string &asm_name, tree type_tree,\n \t\t\t\tbool is_hidden, bool is_constant,\n \t\t\t\tbool is_common, int64_t alignment)\n {\n-  tree type_tree = type->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -3117,15 +2743,10 @@ Gcc_backend::implicit_variable (const std::string &name,\n \n void\n Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\t Btype *, bool, bool, bool is_common,\n-\t\t\t\t\t Bexpression *init)\n+\t\t\t\t\t tree, bool, bool, bool is_common,\n+\t\t\t\t\t tree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree;\n-  if (init == NULL)\n-    init_tree = NULL_TREE;\n-  else\n-    init_tree = init->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3149,9 +2770,8 @@ Gcc_backend::implicit_variable_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::implicit_variable_reference (const std::string &name,\n \t\t\t\t\t  const std::string &asm_name,\n-\t\t\t\t\t  Btype *btype)\n+\t\t\t\t\t  tree type_tree)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n \n@@ -3172,9 +2792,9 @@ Gcc_backend::implicit_variable_reference (const std::string &name,\n Bvariable *\n Gcc_backend::immutable_struct (const std::string &name,\n \t\t\t       const std::string &asm_name, bool is_hidden,\n-\t\t\t       bool is_common, Btype *btype, Location location)\n+\t\t\t       bool is_common, tree type_tree,\n+\t\t\t       Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3218,11 +2838,10 @@ Gcc_backend::immutable_struct (const std::string &name,\n \n void\n Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n-\t\t\t\t\tbool, bool is_common, Btype *, Location,\n-\t\t\t\t\tBexpression *initializer)\n+\t\t\t\t\tbool, bool is_common, tree, Location,\n+\t\t\t\t\ttree init_tree)\n {\n   tree decl = var->get_decl ();\n-  tree init_tree = initializer->get_tree ();\n   if (decl == error_mark_node || init_tree == error_mark_node)\n     return;\n \n@@ -3249,9 +2868,8 @@ Gcc_backend::immutable_struct_set_init (Bvariable *var, const std::string &,\n Bvariable *\n Gcc_backend::immutable_struct_reference (const std::string &name,\n \t\t\t\t\t const std::string &asm_name,\n-\t\t\t\t\t Btype *btype, Location location)\n+\t\t\t\t\t tree type_tree, Location location)\n {\n-  tree type_tree = btype->get_tree ();\n   if (type_tree == error_mark_node)\n     return this->error_variable ();\n   gcc_assert (TREE_CODE (type_tree) == RECORD_TYPE);\n@@ -3271,14 +2889,12 @@ Gcc_backend::immutable_struct_reference (const std::string &name,\n \n // Make a label.\n \n-Blabel *\n-Gcc_backend::label (Bfunction *function, const std::string &name,\n-\t\t    Location location)\n+tree\n+Gcc_backend::label (tree func_tree, const std::string &name, Location location)\n {\n   tree decl;\n   if (name.empty ())\n     {\n-      tree func_tree = function->get_tree ();\n       if (DECL_STRUCT_FUNCTION (func_tree) == NULL)\n \tpush_struct_function (func_tree);\n       else\n@@ -3293,56 +2909,50 @@ Gcc_backend::label (Bfunction *function, const std::string &name,\n       tree id = get_identifier_from_string (name);\n       decl\n \t= build_decl (location.gcc_location (), LABEL_DECL, id, void_type_node);\n-      DECL_CONTEXT (decl) = function->get_tree ();\n+      DECL_CONTEXT (decl) = func_tree;\n     }\n-  return new Blabel (decl);\n+  return decl;\n }\n \n // Make a statement which defines a label.\n \n-Bstatement *\n-Gcc_backend::label_definition_statement (Blabel *label)\n+tree\n+Gcc_backend::label_definition_statement (tree label)\n {\n-  tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (DECL_SOURCE_LOCATION (lab), LABEL_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (DECL_SOURCE_LOCATION (label), LABEL_EXPR,\n+\t\t\t  void_type_node, label);\n }\n \n // Make a goto statement.\n \n-Bstatement *\n-Gcc_backend::goto_statement (Blabel *label, Location location)\n+tree\n+Gcc_backend::goto_statement (tree label, Location location)\n {\n-  tree lab = label->get_tree ();\n-  tree ret = fold_build1_loc (location.gcc_location (), GOTO_EXPR,\n-\t\t\t      void_type_node, lab);\n-  return this->make_statement (ret);\n+  return fold_build1_loc (location.gcc_location (), GOTO_EXPR, void_type_node,\n+\t\t\t  label);\n }\n \n // Get the address of a label.\n \n-Bexpression *\n-Gcc_backend::label_address (Blabel *label, Location location)\n+tree\n+Gcc_backend::label_address (tree label, Location location)\n {\n-  tree lab = label->get_tree ();\n-  TREE_USED (lab) = 1;\n-  TREE_ADDRESSABLE (lab) = 1;\n+  TREE_USED (label) = 1;\n+  TREE_ADDRESSABLE (label) = 1;\n   tree ret\n     = fold_convert_loc (location.gcc_location (), ptr_type_node,\n \t\t\tbuild_fold_addr_expr_loc (location.gcc_location (),\n-\t\t\t\t\t\t  lab));\n-  return this->make_expression (ret);\n+\t\t\t\t\t\t  label));\n+  return ret;\n }\n \n // Declare or define a new function.\n \n-Bfunction *\n-Gcc_backend::function (Btype *fntype, const std::string &name,\n+tree\n+Gcc_backend::function (tree functype, const std::string &name,\n \t\t       const std::string &asm_name, unsigned int flags,\n \t\t       Location location)\n {\n-  tree functype = fntype->get_tree ();\n   if (functype != error_mark_node)\n     {\n       gcc_assert (FUNCTION_POINTER_TYPE_P (functype));\n@@ -3386,58 +2996,52 @@ Gcc_backend::function (Btype *fntype, const std::string &name,\n     TREE_READONLY (decl) = 1;\n \n   rust_preserve_from_gc (decl);\n-  return new Bfunction (decl);\n+  return decl;\n }\n \n // Create a statement that runs all deferred calls for FUNCTION.  This should\n // be a statement that looks like this in C++:\n //   finish:\n //     try { UNDEFER; } catch { CHECK_DEFER; goto finish; }\n \n-Bstatement *\n-Gcc_backend::function_defer_statement (Bfunction *function,\n-\t\t\t\t       Bexpression *undefer, Bexpression *defer,\n-\t\t\t\t       Location location)\n+tree\n+Gcc_backend::function_defer_statement (tree function, tree undefer_tree,\n+\t\t\t\t       tree defer_tree, Location location)\n {\n-  tree undefer_tree = undefer->get_tree ();\n-  tree defer_tree = defer->get_tree ();\n-  tree fntree = function->get_tree ();\n-\n   if (undefer_tree == error_mark_node || defer_tree == error_mark_node\n-      || fntree == error_mark_node)\n+      || function == error_mark_node)\n     return this->error_statement ();\n \n-  if (DECL_STRUCT_FUNCTION (fntree) == NULL)\n-    push_struct_function (fntree);\n+  if (DECL_STRUCT_FUNCTION (function) == NULL)\n+    push_struct_function (function);\n   else\n-    push_cfun (DECL_STRUCT_FUNCTION (fntree));\n+    push_cfun (DECL_STRUCT_FUNCTION (function));\n \n   tree stmt_list = NULL;\n-  Blabel *blabel = this->label (function, \"\", location);\n-  Bstatement *label_def = this->label_definition_statement (blabel);\n-  append_to_statement_list (label_def->get_tree (), &stmt_list);\n+  tree label = this->label (function, \"\", location);\n+  tree label_def = this->label_definition_statement (label);\n+  append_to_statement_list (label_def, &stmt_list);\n \n-  Bstatement *jump_stmt = this->goto_statement (blabel, location);\n-  tree jump = jump_stmt->get_tree ();\n-  tree catch_body = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump);\n+  tree jump_stmt = this->goto_statement (label, location);\n+  tree catch_body\n+    = build2 (COMPOUND_EXPR, void_type_node, defer_tree, jump_stmt);\n   catch_body = build2 (CATCH_EXPR, void_type_node, NULL, catch_body);\n   tree try_catch\n     = build2 (TRY_CATCH_EXPR, void_type_node, undefer_tree, catch_body);\n   append_to_statement_list (try_catch, &stmt_list);\n   pop_cfun ();\n \n-  return this->make_statement (stmt_list);\n+  return stmt_list;\n }\n \n // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n // This will only be called for a function definition.\n \n bool\n Gcc_backend::function_set_parameters (\n-  Bfunction *function, const std::vector<Bvariable *> &param_vars)\n+  tree function, const std::vector<Bvariable *> &param_vars)\n {\n-  tree func_tree = function->get_tree ();\n-  if (func_tree == error_mark_node)\n+  if (function == error_mark_node)\n     return false;\n \n   tree params = NULL_TREE;\n@@ -3450,36 +3054,33 @@ Gcc_backend::function_set_parameters (\n       pp = &DECL_CHAIN (*pp);\n     }\n   *pp = NULL_TREE;\n-  DECL_ARGUMENTS (func_tree) = params;\n+  DECL_ARGUMENTS (function) = params;\n   return true;\n }\n \n // Set the function body for FUNCTION using the code in CODE_BLOCK.\n \n bool\n-Gcc_backend::function_set_body (Bfunction *function, Bstatement *code_stmt)\n+Gcc_backend::function_set_body (tree function, tree code_stmt)\n {\n-  tree func_tree = function->get_tree ();\n-  tree code = code_stmt->get_tree ();\n-\n-  if (func_tree == error_mark_node || code == error_mark_node)\n+  if (function == error_mark_node || code_stmt == error_mark_node)\n     return false;\n-  DECL_SAVED_TREE (func_tree) = code;\n+  DECL_SAVED_TREE (function) = code_stmt;\n   return true;\n }\n \n // Look up a named built-in function in the current backend implementation.\n // Returns NULL if no built-in function by that name exists.\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_gcc_builtin (const std::string &name)\n {\n   if (this->builtin_functions_.count (name) != 0)\n     return this->builtin_functions_[name];\n   return NULL;\n }\n \n-Bfunction *\n+tree\n Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n {\n   auto it = rust_intrinsic_to_gcc_builtin.find (name);\n@@ -3495,9 +3096,8 @@ Gcc_backend::lookup_builtin_by_rust_name (const std::string &name)\n \n void\n Gcc_backend::write_global_definitions (\n-  const std::vector<Btype *> &type_decls,\n-  const std::vector<Bexpression *> &constant_decls,\n-  const std::vector<Bfunction *> &function_decls,\n+  const std::vector<tree> &type_decls, const std::vector<tree> &constant_decls,\n+  const std::vector<tree> &function_decls,\n   const std::vector<Bvariable *> &variable_decls)\n {\n   size_t count_definitions = type_decls.size () + constant_decls.size ()\n@@ -3519,10 +3119,10 @@ Gcc_backend::write_global_definitions (\n \t}\n     }\n \n-  for (std::vector<Btype *>::const_iterator p = type_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = type_decls.begin ();\n        p != type_decls.end (); ++p)\n     {\n-      tree type_tree = (*p)->get_tree ();\n+      tree type_tree = (*p);\n       if (type_tree != error_mark_node && IS_TYPE_OR_DECL_P (type_tree))\n \t{\n \t  defs[i] = TYPE_NAME (type_tree);\n@@ -3531,20 +3131,20 @@ Gcc_backend::write_global_definitions (\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bexpression *>::const_iterator p = constant_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = constant_decls.begin ();\n        p != constant_decls.end (); ++p)\n     {\n-      if ((*p)->get_tree () != error_mark_node)\n+      if ((*p) != error_mark_node)\n \t{\n-\t  defs[i] = (*p)->get_tree ();\n+\t  defs[i] = (*p);\n \t  rust_preserve_from_gc (defs[i]);\n \t  ++i;\n \t}\n     }\n-  for (std::vector<Bfunction *>::const_iterator p = function_decls.begin ();\n+  for (std::vector<tree>::const_iterator p = function_decls.begin ();\n        p != function_decls.end (); ++p)\n     {\n-      tree decl = (*p)->get_tree ();\n+      tree decl = (*p);\n       if (decl != error_mark_node)\n \t{\n \t  rust_preserve_from_gc (decl);\n@@ -3592,7 +3192,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n   if ((flags & builtin_novops) != 0)\n     DECL_IS_NOVOPS (decl) = 1;\n   set_builtin_decl (bcode, decl, true);\n-  this->builtin_functions_[name] = this->make_function (decl);\n+  this->builtin_functions_[name] = decl;\n   if (libname != NULL)\n     {\n       decl = add_builtin_function (libname, fntype, bcode, BUILT_IN_NORMAL,\n@@ -3603,7 +3203,7 @@ Gcc_backend::define_builtin (const std::string rust_name,\n \tTREE_THIS_VOLATILE (decl) = 1;\n       if ((flags & builtin_novops) != 0)\n \tDECL_IS_NOVOPS (decl) = 1;\n-      this->builtin_functions_[libname] = this->make_function (decl);\n+      this->builtin_functions_[libname] = decl;\n     }\n \n   rust_intrinsic_to_gcc_builtin[rust_name] = name;"}, {"sha": "db347551e846f6ddbafd87b19d6d238bf39cb3c8", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -68,6 +68,47 @@ class Adjustment\n   const TyTy::BaseType *expected;\n };\n \n+class Adjuster\n+{\n+public:\n+  Adjuster (const TyTy::BaseType *ty) : base (ty) {}\n+\n+  TyTy::BaseType *adjust_type (std::vector<Adjustment> adjustments)\n+  {\n+    TyTy::BaseType *ty = base->clone ();\n+    for (auto &adjustment : adjustments)\n+      {\n+\tswitch (adjustment.get_type ())\n+\t  {\n+\t  case Resolver::Adjustment::AdjustmentType::IMM_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Imm);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::MUT_REF:\n+\t    ty = new TyTy::ReferenceType (ty->get_ref (),\n+\t\t\t\t\t  TyTy::TyVar (ty->get_ref ()),\n+\t\t\t\t\t  Mutability::Mut);\n+\t    break;\n+\n+\t  case Resolver::Adjustment::AdjustmentType::DEREF_REF:\n+\t    // FIXME this really needs to support deref lang-item operator\n+\t    // overloads\n+\t    rust_assert (ty->get_kind () == TyTy::TypeKind::REF);\n+\t    const TyTy::ReferenceType *rr\n+\t      = static_cast<const TyTy::ReferenceType *> (ty);\n+\t    ty = rr->get_base ();\n+\t    break;\n+\t  }\n+      }\n+    return ty;\n+  }\n+\n+private:\n+  const TyTy::BaseType *base;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "0b4105324249558611dac8c33d477d77f6ea7626", "filename": "gcc/rust/typecheck/rust-hir-const-fold-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-base.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -56,7 +56,7 @@ class ConstFoldBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "a3f5a16118ef870796afdea1c4c0a8227f100f23", "filename": "gcc/rust/typecheck/rust-hir-const-fold-ctx.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold-ctx.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -36,15 +36,15 @@ class Context\n \n   ::Backend *get_backend () { return backend; }\n \n-  bool lookup_const (HirId id, Bexpression **expr);\n+  bool lookup_const (HirId id, tree *expr);\n \n-  void insert_const (HirId, Bexpression *expr);\n+  void insert_const (HirId, tree expr);\n \n private:\n   Context (::Backend *backend);\n \n   ::Backend *backend;\n-  std::map<HirId, Bexpression *> ctx;\n+  std::map<HirId, tree> ctx;\n };\n \n } // namespace ConstFold"}, {"sha": "6acedd19b0fc015f13590094af7d7b6ba23eb258", "filename": "gcc/rust/typecheck/rust-hir-const-fold.cc", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -41,7 +41,7 @@ Context::get ()\n }\n \n bool\n-Context::lookup_const (HirId id, Bexpression **expr)\n+Context::lookup_const (HirId id, tree *expr)\n {\n   auto it = ctx.find (id);\n   if (it == ctx.end ())\n@@ -52,7 +52,7 @@ Context::lookup_const (HirId id, Bexpression **expr)\n }\n \n void\n-Context::insert_const (HirId id, Bexpression *expr)\n+Context::insert_const (HirId id, tree expr)\n {\n   rust_assert (ctx.find (id) == ctx.end ());\n   ctx[id] = expr;\n@@ -75,7 +75,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n {\n   unsigned long index = 0;\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -85,7 +85,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \n   for (auto &value : elems.get_values ())\n     {\n@@ -94,15 +94,15 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsValues &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n \n void\n ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n {\n   std::vector<unsigned long> indices;\n-  std::vector<Bexpression *> values;\n+  std::vector<tree> values;\n \n   TyTy::BaseType *tyty = nullptr;\n   if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n@@ -112,12 +112,12 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n       return;\n     }\n \n-  Btype *btype = ConstFoldType::fold (tyty, ctx->get_backend ());\n-  Bexpression *elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n+  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+  tree elem = ConstFoldExpr::fold (elems.get_elem_to_copy ());\n \n   // num copies expr was already folded in rust-hir-type-check-expr; lookup the\n   // earlier result\n-  Bexpression *num_copies_expr = ctx->get_backend ()->error_expression ();\n+  tree num_copies_expr = ctx->get_backend ()->error_expression ();\n   ctx->lookup_const (elems.get_num_copies_expr ()->get_mappings ().get_hirid (),\n \t\t     &num_copies_expr);\n \n@@ -132,7 +132,7 @@ ConstFoldArrayElems::visit (HIR::ArrayElemsCopied &elems)\n     }\n \n   folded\n-    = ctx->get_backend ()->array_constructor_expression (btype, indices, values,\n+    = ctx->get_backend ()->array_constructor_expression (type, indices, values,\n \t\t\t\t\t\t\t expr.get_locus ());\n }\n "}, {"sha": "c965e25017c183ff334b08b3e08a74f706fe92b7", "filename": "gcc/rust/typecheck/rust-hir-const-fold.h", "status": "modified", "additions": 72, "deletions": 16, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-const-fold.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -28,7 +28,7 @@ namespace ConstFold {\n class ConstFoldType : public TyTy::TyVisitor\n {\n public:\n-  static Btype *fold (TyTy::BaseType *type, ::Backend *backend)\n+  static tree fold (TyTy::BaseType *type, ::Backend *backend)\n   {\n     ConstFoldType folder (backend);\n     type->accept_vis (folder);\n@@ -43,13 +43,37 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::ArrayType &type) override\n   {\n-    Btype *element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n+    tree element_ty = ConstFoldType::fold (type.get_element_type (), backend);\n     translated = backend->array_type (element_ty, type.get_capacity ());\n   }\n \n-  void visit (TyTy::ReferenceType &) override { gcc_unreachable (); }\n+  void visit (TyTy::ReferenceType &type) override\n+  {\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    if (type.is_mutable ())\n+      {\n+\ttranslated = backend->reference_type (base_compiled_type);\n+      }\n+    else\n+      {\n+\tauto base = backend->immutable_type (base_compiled_type);\n+\ttranslated = backend->reference_type (base);\n+      }\n+  }\n \n-  void visit (TyTy::PointerType &) override { gcc_unreachable (); }\n+  void visit (TyTy::PointerType &type) override\n+  {\n+    tree base_compiled_type = ConstFoldType::fold (type.get_base (), backend);\n+    if (type.is_mutable ())\n+      {\n+\ttranslated = backend->pointer_type (base_compiled_type);\n+      }\n+    else\n+      {\n+\tauto base = backend->immutable_type (base_compiled_type);\n+\ttranslated = backend->pointer_type (base);\n+      }\n+  }\n \n   void visit (TyTy::ParamType &) override { gcc_unreachable (); }\n \n@@ -188,7 +212,7 @@ class ConstFoldType : public TyTy::TyVisitor\n \n   void visit (TyTy::StrType &) override\n   {\n-    Btype *raw_str = backend->raw_str_type ();\n+    tree raw_str = backend->raw_str_type ();\n     translated\n       = backend->named_type (\"str\", raw_str, Linemap::predeclared_location ());\n   }\n@@ -205,15 +229,15 @@ class ConstFoldType : public TyTy::TyVisitor\n   {}\n \n   ::Backend *backend;\n-  ::Btype *translated;\n+  ::tree translated;\n };\n \n class ConstFoldItem : public ConstFoldBase\n {\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Item &item)\n+  static tree fold (HIR::Item &item)\n   {\n     ConstFoldItem folder;\n     item.accept_vis (folder);\n@@ -234,15 +258,15 @@ class ConstFoldItem : public ConstFoldBase\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n class ConstFoldArrayElems : public ConstFoldBase\n {\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::ArrayExpr &expr)\n+  static tree fold (HIR::ArrayExpr &expr)\n   {\n     ConstFoldArrayElems folder (expr);\n     HIR::ArrayElems *elems = expr.get_internal_elements ();\n@@ -259,7 +283,7 @@ class ConstFoldArrayElems : public ConstFoldBase\n       expr (expr)\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n   HIR::ArrayExpr &expr;\n };\n \n@@ -268,7 +292,7 @@ class ConstFoldExpr : public ConstFoldBase\n   using ConstFoldBase::visit;\n \n public:\n-  static Bexpression *fold (HIR::Expr *expr)\n+  static tree fold (HIR::Expr *expr)\n   {\n     ConstFoldExpr folder;\n     expr->accept_vis (folder);\n@@ -345,7 +369,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded\n \t    = ctx->get_backend ()->integer_constant_expression (type, ival);\n \t}\n@@ -376,7 +400,7 @@ class ConstFoldExpr : public ConstFoldBase\n \t      return;\n \t    }\n \n-\t  Btype *type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+\t  tree type = ConstFoldType::fold (tyty, ctx->get_backend ());\n \t  folded = ctx->get_backend ()->float_constant_expression (type, fval);\n \t}\n \treturn;\n@@ -429,19 +453,51 @@ class ConstFoldExpr : public ConstFoldBase\n \n   void visit (HIR::ArrayIndexExpr &expr) override\n   {\n-    Bexpression *array = ConstFoldExpr::fold (expr.get_array_expr ());\n-    Bexpression *index = ConstFoldExpr::fold (expr.get_index_expr ());\n+    tree array = ConstFoldExpr::fold (expr.get_array_expr ());\n+    tree index = ConstFoldExpr::fold (expr.get_index_expr ());\n \n     folded = ctx->get_backend ()->array_index_expression (array, index,\n \t\t\t\t\t\t\t  expr.get_locus ());\n   }\n \n+  void visit (HIR::BorrowExpr &expr) override\n+  {\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+\n+    folded\n+      = ctx->get_backend ()->address_expression (main_expr, expr.get_locus ());\n+  }\n+\n+  void visit (HIR::DereferenceExpr &expr) override\n+  {\n+    tree main_expr = ConstFoldExpr::fold (expr.get_expr ().get ());\n+\n+    TyTy::BaseType *tyty = nullptr;\n+    if (!tyctx->lookup_type (expr.get_mappings ().get_hirid (), &tyty))\n+      {\n+\trust_fatal_error (expr.get_locus (),\n+\t\t\t  \"did not resolve type for this TupleExpr\");\n+\treturn;\n+      }\n+\n+    tree expected_type = ConstFoldType::fold (tyty, ctx->get_backend ());\n+    bool known_valid = true;\n+    folded = ctx->get_backend ()->indirect_expression (expected_type, main_expr,\n+\t\t\t\t\t\t       known_valid,\n+\t\t\t\t\t\t       expr.get_locus ());\n+  }\n+\n+  void visit (HIR::GroupedExpr &expr) override\n+  {\n+    folded = ConstFoldExpr::fold (expr.get_expr_in_parens ().get ());\n+  }\n+\n private:\n   ConstFoldExpr ()\n     : ConstFoldBase (), folded (ctx->get_backend ()->error_expression ())\n   {}\n \n-  Bexpression *folded;\n+  tree folded;\n };\n \n } // namespace ConstFold"}, {"sha": "0c618d32e0161d0e7496ac17b309e86d79722a9e", "filename": "gcc/rust/typecheck/rust-hir-path-probe.h", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-path-probe.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -119,9 +119,10 @@ class PathProbeType : public TypeCheckBase\n   static std::vector<PathProbeCandidate>\n   Probe (const TyTy::BaseType *receiver,\n \t const HIR::PathIdentSegment &segment_name, bool probe_impls,\n-\t bool probe_bounds, bool ignore_mandatory_trait_items)\n+\t bool probe_bounds, bool ignore_mandatory_trait_items,\n+\t DefId specific_trait_id = UNKNOWN_DEFID)\n   {\n-    PathProbeType probe (receiver, segment_name);\n+    PathProbeType probe (receiver, segment_name, specific_trait_id);\n     if (probe_impls)\n       {\n \tif (receiver->get_kind () == TyTy::TypeKind::ADT)\n@@ -145,6 +146,13 @@ class PathProbeType : public TypeCheckBase\n \tfor (auto &candidate : probed_bounds)\n \t  {\n \t    const TraitReference *trait_ref = candidate.first;\n+\t    if (specific_trait_id != UNKNOWN_DEFID)\n+\t      {\n+\t\tif (trait_ref->get_mappings ().get_defid ()\n+\t\t    != specific_trait_id)\n+\t\t  continue;\n+\t      }\n+\n \t    HIR::ImplBlock *impl = candidate.second;\n \t    probe.process_associated_trait_for_candidates (\n \t      trait_ref, impl, ignore_mandatory_trait_items);\n@@ -154,6 +162,13 @@ class PathProbeType : public TypeCheckBase\n     for (const TyTy::TypeBoundPredicate &predicate :\n \t receiver->get_specified_bounds ())\n       {\n+\tconst TraitReference *trait_ref = predicate.get ();\n+\tif (specific_trait_id != UNKNOWN_DEFID)\n+\t  {\n+\t    if (trait_ref->get_mappings ().get_defid () != specific_trait_id)\n+\t      continue;\n+\t  }\n+\n \tprobe.process_predicate_for_candidates (predicate,\n \t\t\t\t\t\tignore_mandatory_trait_items);\n       }\n@@ -221,6 +236,9 @@ class PathProbeType : public TypeCheckBase\n protected:\n   void process_enum_item_for_candiates (const TyTy::ADTType *adt)\n   {\n+    if (specific_trait_id != UNKNOWN_DEFID)\n+      return;\n+\n     TyTy::VariantDef *v;\n     if (!adt->lookup_variant (search.as_string (), &v))\n       return;\n@@ -385,9 +403,9 @@ class PathProbeType : public TypeCheckBase\n \n protected:\n   PathProbeType (const TyTy::BaseType *receiver,\n-\t\t const HIR::PathIdentSegment &query)\n+\t\t const HIR::PathIdentSegment &query, DefId specific_trait_id)\n     : TypeCheckBase (), receiver (receiver), search (query),\n-      current_impl (nullptr)\n+      current_impl (nullptr), specific_trait_id (specific_trait_id)\n   {}\n \n   std::vector<std::pair<const TraitReference *, HIR::ImplBlock *>>\n@@ -427,6 +445,7 @@ class PathProbeType : public TypeCheckBase\n   const HIR::PathIdentSegment &search;\n   std::vector<PathProbeCandidate> candidates;\n   HIR::ImplBlock *current_impl;\n+  DefId specific_trait_id;\n };\n \n class ReportMultipleCandidateError : private TypeCheckBase\n@@ -507,7 +526,8 @@ class PathProbeImplTrait : public PathProbeType\n   PathProbeImplTrait (const TyTy::BaseType *receiver,\n \t\t      const HIR::PathIdentSegment &query,\n \t\t      const TraitReference *trait_reference)\n-    : PathProbeType (receiver, query), trait_reference (trait_reference)\n+    : PathProbeType (receiver, query, UNKNOWN_DEFID),\n+      trait_reference (trait_reference)\n   {}\n \n   const TraitReference *trait_reference;"}, {"sha": "b2deb91045f332bdc1817ccb385e4c4257db2ad4", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -116,7 +116,7 @@ TraitItemReference::resolve_item (HIR::TraitItemFunc &func)\n   // need to get the return type from this\n   TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (item_tyty);\n   auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-  context->push_return_type (expected_ret_tyty);\n+  context->push_return_type (TypeCheckContextItem (&func), expected_ret_tyty);\n \n   auto block_expr_ty\n     = TypeCheckExpr::Resolve (func.get_block_expr ().get (), false);"}, {"sha": "54591ce9fffe7dc873dd2f9cc9f2327e873581ac", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-trait-ref.h\"\n+#include \"rust-expr.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -206,6 +207,31 @@ class TraitResolver : public TypeCheckBase\n     // loop of trying to resolve traits as required by the types\n     tref->on_resolved ();\n \n+    // does this have any lang-item attributes?\n+    for (auto &attr : trait_reference->get_outer_attrs ())\n+      {\n+\tbool is_lang_item = attr.get_path ().as_string ().compare (\"lang\") == 0\n+\t\t\t    && attr.has_attr_input ()\n+\t\t\t    && attr.get_attr_input ().get_attr_input_type ()\n+\t\t\t\t == AST::AttrInput::AttrInputType::LITERAL;\n+\tif (is_lang_item)\n+\t  {\n+\t    auto &literal\n+\t      = static_cast<AST::AttrInputLiteral &> (attr.get_attr_input ());\n+\t    const auto &lang_item_type_str\n+\t      = literal.get_literal ().as_string ();\n+\t    auto lang_item_type\n+\t      = Analysis::RustLangItem::Parse (lang_item_type_str);\n+\t    if (lang_item_type == Analysis::RustLangItem::ItemType::UNKNOWN)\n+\t      {\n+\t\trust_error_at (attr.get_locus (), \"unknown lang item\");\n+\t\treturn tref;\n+\t      }\n+\t    mappings->insert_lang_item (\n+\t      lang_item_type, trait_reference->get_mappings ().get_defid ());\n+\t  }\n+      }\n+\n     return tref;\n   }\n "}, {"sha": "52dea212170b94abe075dcbd2b97aa7557c4c271", "filename": "gcc/rust/typecheck/rust-hir-type-check-base.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-base.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -58,7 +58,7 @@ class TypeCheckBase : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "9eef755e1407fbd58ce149bf3a46130778cfc509", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 276, "deletions": 16, "changes": 292, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -265,15 +265,29 @@ class TypeCheckExpr : public TypeCheckBase\n     bool probe_impls = !receiver_is_generic;\n     bool ignore_mandatory_trait_items = !receiver_is_generic;\n \n+    auto probe_type = probe_impls ? receiver_tyty : root;\n     auto candidates\n-      = PathProbeType::Probe (root, expr.get_method_name ().get_segment (),\n+      = PathProbeType::Probe (probe_type,\n+\t\t\t      expr.get_method_name ().get_segment (),\n \t\t\t      probe_impls, probe_bounds,\n \t\t\t      ignore_mandatory_trait_items);\n     if (candidates.empty ())\n       {\n-\trust_error_at (expr.get_locus (),\n-\t\t       \"failed to resolve the PathExprSegment to any item\");\n-\treturn;\n+\tif (probe_impls)\n+\t  {\n+\t    candidates\n+\t      = PathProbeType::Probe (root,\n+\t\t\t\t      expr.get_method_name ().get_segment (),\n+\t\t\t\t      probe_impls, probe_bounds,\n+\t\t\t\t      ignore_mandatory_trait_items);\n+\t  }\n+\n+\tif (candidates.empty ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"failed to resolve the PathExprSegment to any item\");\n+\t    return;\n+\t  }\n       }\n \n     std::vector<Adjustment> adjustments;\n@@ -295,6 +309,10 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n+    // Get the adjusted self\n+    Adjuster adj (receiver_tyty);\n+    TyTy::BaseType *adjusted_self = adj.adjust_type (adjustments);\n+\n     // store the adjustments for code-generation to know what to do\n     context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n \t\t\t\t\tstd::move (adjustments));\n@@ -401,7 +419,8 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     TyTy::BaseType *function_ret_tyty\n-      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, context);\n+      = TyTy::TypeCheckMethodCallExpr::go (lookup, expr, adjusted_self,\n+\t\t\t\t\t   context);\n     if (function_ret_tyty == nullptr\n \t|| function_ret_tyty->get_kind () == TyTy::TypeKind::ERROR)\n       {\n@@ -470,6 +489,39 @@ class TypeCheckExpr : public TypeCheckBase\n       result->clone ());\n   }\n \n+  void visit (HIR::CompoundAssignmentExpr &expr) override\n+  {\n+    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid ());\n+\n+    auto lhs = TypeCheckExpr::Resolve (expr.get_left_expr ().get (), false);\n+    auto rhs = TypeCheckExpr::Resolve (expr.get_right_expr ().get (), false);\n+\n+    // we dont care about the result of the unify from a compound assignment\n+    // since this is a unit-type expr\n+    auto result = lhs->unify (rhs);\n+    if (result->get_kind () == TyTy::TypeKind::ERROR)\n+      return;\n+\n+    auto lang_item_type\n+      = Analysis::RustLangItem::CompoundAssignmentOperatorToLangItem (\n+\texpr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n+\n+    bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n+    bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n+    bool valid = valid_lhs && valid_rhs;\n+    if (!valid)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"cannot apply this operator to types %s and %s\",\n+\t\t       lhs->as_string ().c_str (), rhs->as_string ().c_str ());\n+\treturn;\n+      }\n+  }\n+\n   void visit (HIR::IdentifierExpr &expr) override\n   {\n     NodeId ast_node_id = expr.get_mappings ().get_nodeid ();\n@@ -654,7 +706,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\t\t\t  UNKNOWN_LOCAL_DEFID);\n \n \t  /* Capacity is the size of the string (number of chars).\n-\t     It is a constant, but for fold it to get a Bexpression.  */\n+\t     It is a constant, but for fold it to get a tree.  */\n \t  std::string capacity_str\n \t    = std::to_string (expr.get_literal ()->as_string ().size ());\n \t  HIR::LiteralExpr literal_capacity (capacity_mapping, capacity_str,\n@@ -667,8 +719,7 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t\t\tnew TyTy::USizeType (\n \t\t\t\t  capacity_mapping.get_hirid ()));\n \n-\t  Bexpression *capacity\n-\t    = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n+\t  tree capacity = ConstFold::ConstFoldExpr::fold (&literal_capacity);\n \n \t  Analysis::NodeMapping array_mapping (crate_num, UNKNOWN_NODEID,\n \t\t\t\t\t       mappings->get_next_hir_id (\n@@ -699,6 +750,13 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n+    auto lang_item_type\n+      = Analysis::RustLangItem::OperatorToLangItem (expr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, lhs, rhs);\n+    if (operator_overloaded)\n+      return;\n+\n     bool valid_lhs = validate_arithmetic_type (lhs, expr.get_expr_type ());\n     bool valid_rhs = validate_arithmetic_type (rhs, expr.get_expr_type ());\n     bool valid = valid_lhs && valid_rhs;\n@@ -711,8 +769,6 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = lhs->unify (rhs);\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::ComparisonExpr &expr) override\n@@ -736,24 +792,31 @@ class TypeCheckExpr : public TypeCheckBase\n     // we expect the lhs and rhs must be bools at this point\n     TyTy::BoolType elhs (expr.get_mappings ().get_hirid ());\n     lhs = elhs.unify (lhs);\n-    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     TyTy::BoolType rlhs (expr.get_mappings ().get_hirid ());\n     rhs = elhs.unify (rhs);\n-    if (lhs == nullptr || lhs->get_kind () == TyTy::TypeKind::ERROR)\n+    if (lhs->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n     infered = lhs->unify (rhs);\n-    infered->append_reference (lhs->get_ref ());\n-    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::NegationExpr &expr) override\n   {\n     auto negated_expr_ty\n       = TypeCheckExpr::Resolve (expr.get_expr ().get (), false);\n \n+    // check for operator overload\n+    auto lang_item_type = Analysis::RustLangItem::NegationOperatorToLangItem (\n+      expr.get_expr_type ());\n+    bool operator_overloaded\n+      = resolve_operator_overload (lang_item_type, expr, negated_expr_ty,\n+\t\t\t\t   nullptr);\n+    if (operator_overloaded)\n+      return;\n+\n     // https://doc.rust-lang.org/reference/expressions/operator-expr.html#negation-operators\n     switch (expr.get_expr_type ())\n       {\n@@ -1174,6 +1237,203 @@ class TypeCheckExpr : public TypeCheckBase\n     infered = expr_to_convert->cast (tyty_to_convert_to);\n   }\n \n+protected:\n+  bool\n+  resolve_operator_overload (Analysis::RustLangItem::ItemType lang_item_type,\n+\t\t\t     HIR::OperatorExpr &expr, TyTy::BaseType *lhs,\n+\t\t\t     TyTy::BaseType *rhs)\n+  {\n+    // in order to probe of the correct type paths we need the root type, which\n+    // strips any references\n+    const TyTy::BaseType *root = lhs->get_root ();\n+\n+    // look up lang item for arithmetic type\n+    std::vector<PathProbeCandidate> candidates;\n+    std::string associated_item_name\n+      = Analysis::RustLangItem::ToString (lang_item_type);\n+    DefId respective_lang_item_id = UNKNOWN_DEFID;\n+    bool lang_item_defined\n+      = mappings->lookup_lang_item (lang_item_type, &respective_lang_item_id);\n+\n+    // probe for the lang-item\n+    if (lang_item_defined)\n+      {\n+\tbool receiver_is_type_param\n+\t  = root->get_kind () == TyTy::TypeKind::PARAM;\n+\tbool receiver_is_dyn = root->get_kind () == TyTy::TypeKind::DYNAMIC;\n+\n+\tbool receiver_is_generic = receiver_is_type_param || receiver_is_dyn;\n+\tbool probe_bounds = true;\n+\tbool probe_impls = !receiver_is_generic;\n+\tbool ignore_mandatory_trait_items = !receiver_is_generic;\n+\n+\tcandidates = PathProbeType::Probe (\n+\t  root, HIR::PathIdentSegment (associated_item_name), probe_impls,\n+\t  probe_bounds, ignore_mandatory_trait_items, respective_lang_item_id);\n+      }\n+\n+    // autoderef\n+    std::vector<Adjustment> adjustments;\n+    PathProbeCandidate *resolved_candidate\n+      = MethodResolution::Select (candidates, lhs, adjustments);\n+\n+    // is this the case we are recursive\n+    // handle the case where we are within the impl block for this lang_item\n+    // otherwise we end up with a recursive operator overload such as the i32\n+    // operator overload trait\n+    if (lang_item_defined && resolved_candidate != nullptr)\n+      {\n+\tTypeCheckContextItem &fn_context = context->peek_context ();\n+\tif (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+\t  {\n+\t    auto &impl_item = fn_context.get_impl_item ();\n+\t    HIR::ImplBlock *parent = impl_item.first;\n+\t    HIR::Function *fn = impl_item.second;\n+\n+\t    if (parent->has_trait_ref ()\n+\t\t&& fn->get_function_name ().compare (associated_item_name) == 0)\n+\t      {\n+\t\tTraitReference *trait_reference\n+\t\t  = TraitResolver::Lookup (*parent->get_trait_ref ().get ());\n+\t\tif (!trait_reference->is_error ())\n+\t\t  {\n+\t\t    TyTy::BaseType *lookup = nullptr;\n+\t\t    bool ok\n+\t\t      = context->lookup_type (fn->get_mappings ().get_hirid (),\n+\t\t\t\t\t      &lookup);\n+\t\t    rust_assert (ok);\n+\t\t    rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+\t\t    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+\t\t    rust_assert (fntype->is_method ());\n+\n+\t\t    Adjuster adj (lhs);\n+\t\t    TyTy::BaseType *adjusted = adj.adjust_type (adjustments);\n+\n+\t\t    bool is_lang_item_impl\n+\t\t      = trait_reference->get_mappings ().get_defid ()\n+\t\t\t== respective_lang_item_id;\n+\t\t    bool self_is_lang_item_self\n+\t\t      = fntype->get_self_type ()->is_equal (*adjusted);\n+\t\t    bool recursive_operator_overload\n+\t\t      = is_lang_item_impl && self_is_lang_item_self;\n+\n+\t\t    lang_item_defined = !recursive_operator_overload;\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    bool have_implementation_for_lang_item = resolved_candidate != nullptr;\n+    if (!lang_item_defined || !have_implementation_for_lang_item)\n+      {\n+\t// no operator overload exists for this\n+\treturn false;\n+      }\n+\n+    // now its just like a method-call-expr\n+    context->insert_receiver (expr.get_mappings ().get_hirid (), lhs);\n+\n+    // store the adjustments for code-generation to know what to do\n+    context->insert_autoderef_mappings (expr.get_mappings ().get_hirid (),\n+\t\t\t\t\tstd::move (adjustments));\n+\n+    TyTy::BaseType *lookup_tyty = resolved_candidate->ty;\n+    NodeId resolved_node_id\n+      = resolved_candidate->is_impl_candidate ()\n+\t  ? resolved_candidate->item.impl.impl_item->get_impl_mappings ()\n+\t      .get_nodeid ()\n+\t  : resolved_candidate->item.trait.item_ref->get_mappings ()\n+\t      .get_nodeid ();\n+\n+    rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+    TyTy::BaseType *lookup = lookup_tyty;\n+    TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+    rust_assert (fn->is_method ());\n+\n+    if (root->get_kind () == TyTy::TypeKind::ADT)\n+      {\n+\tconst TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (root);\n+\tif (adt->has_substitutions () && fn->needs_substitution ())\n+\t  {\n+\t    // consider the case where we have:\n+\t    //\n+\t    // struct Foo<X,Y>(X,Y);\n+\t    //\n+\t    // impl<T> Foo<T, i32> {\n+\t    //   fn test<X>(self, a:X) -> (T,X) { (self.0, a) }\n+\t    // }\n+\t    //\n+\t    // In this case we end up with an fn type of:\n+\t    //\n+\t    // fn <T,X> test(self:Foo<T,i32>, a:X) -> (T,X)\n+\t    //\n+\t    // This means the instance or self we are calling this method for\n+\t    // will be substituted such that we can get the inherited type\n+\t    // arguments but then need to use the turbo fish if available or\n+\t    // infer the remaining arguments. Luckily rust does not allow for\n+\t    // default types GenericParams on impl blocks since these must\n+\t    // always be at the end of the list\n+\n+\t    auto s = fn->get_self_type ()->get_root ();\n+\t    rust_assert (s->can_eq (adt, false, false));\n+\t    rust_assert (s->get_kind () == TyTy::TypeKind::ADT);\n+\t    const TyTy::ADTType *self_adt\n+\t      = static_cast<const TyTy::ADTType *> (s);\n+\n+\t    // we need to grab the Self substitutions as the inherit type\n+\t    // parameters for this\n+\t    if (self_adt->needs_substitution ())\n+\t      {\n+\t\trust_assert (adt->was_substituted ());\n+\n+\t\tTyTy::SubstitutionArgumentMappings used_args_in_prev_segment\n+\t\t  = GetUsedSubstArgs::From (adt);\n+\n+\t\tTyTy::SubstitutionArgumentMappings inherit_type_args\n+\t\t  = self_adt->solve_mappings_from_receiver_for_self (\n+\t\t    used_args_in_prev_segment);\n+\n+\t\t// there may or may not be inherited type arguments\n+\t\tif (!inherit_type_args.is_error ())\n+\t\t  {\n+\t\t    // need to apply the inherited type arguments to the\n+\t\t    // function\n+\t\t    lookup = fn->handle_substitions (inherit_type_args);\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+\n+    // type check the arguments if required\n+    TyTy::FnType *type = static_cast<TyTy::FnType *> (lookup);\n+    if (rhs == nullptr)\n+      {\n+\trust_assert (type->num_params () == 1);\n+      }\n+    else\n+      {\n+\trust_assert (type->num_params () == 2);\n+\tauto fnparam = type->param_at (1);\n+\tfnparam.second->unify (rhs); // typecheck the rhs\n+      }\n+\n+    // get the return type\n+    TyTy::BaseType *function_ret_tyty = fn->get_return_type ()->clone ();\n+\n+    // store the expected fntype\n+    context->insert_operator_overload (expr.get_mappings ().get_hirid (), type);\n+\n+    // set up the resolved name on the path\n+    resolver->insert_resolved_name (expr.get_mappings ().get_nodeid (),\n+\t\t\t\t    resolved_node_id);\n+\n+    // return the result of the function back\n+    infered = function_ret_tyty;\n+\n+    return true;\n+  }\n+\n private:\n   TypeCheckExpr (bool inside_loop)\n     : TypeCheckBase (), infered (nullptr), infered_array_elems (nullptr),\n@@ -1249,11 +1509,11 @@ class TypeCheckExpr : public TypeCheckBase\n   /* The return value of visit(ArrayElemsValues&) and visit(ArrayElemsCopied&)\n      Stores the type of array elements, if `expr` is ArrayExpr. */\n   TyTy::BaseType *infered_array_elems;\n-  Bexpression *folded_array_capacity;\n+  tree folded_array_capacity;\n   Location root_array_expr_locus;\n \n   bool inside_loop;\n-};\n+}; // namespace Resolver\n \n } // namespace Resolver\n } // namespace Rust"}, {"sha": "64853f5d013dc888276d27096ca125f39140538c", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -310,9 +310,10 @@ class TypeCheckImplItem : public TypeCheckBase\n public:\n   using Rust::Resolver::TypeCheckBase::visit;\n \n-  static void Resolve (HIR::ImplItem *item, TyTy::BaseType *self)\n+  static void Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item,\n+\t\t       TyTy::BaseType *self)\n   {\n-    TypeCheckImplItem resolver (self);\n+    TypeCheckImplItem resolver (parent, self);\n     item->accept_vis (resolver);\n   }\n \n@@ -336,7 +337,8 @@ class TypeCheckImplItem : public TypeCheckBase\n     // need to get the return type from this\n     TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n     auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (parent, &function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n@@ -346,8 +348,11 @@ class TypeCheckImplItem : public TypeCheckBase\n   }\n \n protected:\n-  TypeCheckImplItem (TyTy::BaseType *self) : TypeCheckBase (), self (self) {}\n+  TypeCheckImplItem (HIR::ImplBlock *parent, TyTy::BaseType *self)\n+    : TypeCheckBase (), parent (parent), self (self)\n+  {}\n \n+  HIR::ImplBlock *parent;\n   TyTy::BaseType *self;\n };\n \n@@ -357,11 +362,12 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n public:\n   static const TraitItemReference &\n-  Resolve (HIR::ImplItem *item, TyTy::BaseType *self,\n+  Resolve (HIR::ImplBlock *parent, HIR::ImplItem *item, TyTy::BaseType *self,\n \t   TraitReference &trait_reference,\n \t   std::vector<TyTy::SubstitutionParamMapping> substitutions)\n   {\n-    TypeCheckImplItemWithTrait resolver (self, trait_reference, substitutions);\n+    TypeCheckImplItemWithTrait resolver (parent, self, trait_reference,\n+\t\t\t\t\t substitutions);\n     item->accept_vis (resolver);\n     return resolver.resolved_trait_item;\n   }\n@@ -514,9 +520,10 @@ class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n \n private:\n   TypeCheckImplItemWithTrait (\n-    TyTy::BaseType *self, TraitReference &trait_reference,\n+    HIR::ImplBlock *parent, TyTy::BaseType *self,\n+    TraitReference &trait_reference,\n     std::vector<TyTy::SubstitutionParamMapping> substitutions)\n-    : TypeCheckImplItem (self), trait_reference (trait_reference),\n+    : TypeCheckImplItem (parent, self), trait_reference (trait_reference),\n       resolved_trait_item (TraitItemReference::error_node ()),\n       substitutions (substitutions)\n   {"}, {"sha": "cc102dff63877533e5600392442b3d3e11f0256d", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -118,11 +118,12 @@ class TypeCheckItem : public TypeCheckBase\n     for (auto &impl_item : impl_block.get_impl_items ())\n       {\n \tif (!is_trait_impl_block)\n-\t  TypeCheckImplItem::Resolve (impl_item.get (), self);\n+\t  TypeCheckImplItem::Resolve (&impl_block, impl_item.get (), self);\n \telse\n \t  {\n \t    auto &trait_item_ref\n-\t      = TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n+\t      = TypeCheckImplItemWithTrait::Resolve (&impl_block,\n+\t\t\t\t\t\t     impl_item.get (), self,\n \t\t\t\t\t\t     *trait_reference,\n \t\t\t\t\t\t     substitutions);\n \t    trait_item_refs.push_back (trait_item_ref);\n@@ -210,7 +211,8 @@ class TypeCheckItem : public TypeCheckBase\n     // need to get the return type from this\n     TyTy::FnType *resolved_fn_type = static_cast<TyTy::FnType *> (lookup);\n     auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);"}, {"sha": "fb0e04758212c2d40631ad5ca7fe8c03f4e8ad4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -424,7 +424,8 @@ class TypeCheckStmt : public TypeCheckBase\n \n     TyTy::FnType *resolved_fn_type = fnType;\n     auto expected_ret_tyty = resolved_fn_type->get_return_type ();\n-    context->push_return_type (expected_ret_tyty);\n+    context->push_return_type (TypeCheckContextItem (&function),\n+\t\t\t       expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);"}, {"sha": "f078df6abd298c0d9c061190e96e104d48d40729", "filename": "gcc/rust/typecheck/rust-hir-type-check-util.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-util.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -51,7 +51,7 @@ class SimpleHirVisitor : public HIR::HIRVisitor\n   virtual void visit (HIR::LazyBooleanExpr &) override {}\n   virtual void visit (HIR::TypeCastExpr &) override {}\n   virtual void visit (HIR::AssignmentExpr &) override {}\n-\n+  virtual void visit (HIR::CompoundAssignmentExpr &) override {}\n   virtual void visit (HIR::GroupedExpr &) override {}\n \n   virtual void visit (HIR::ArrayElemsValues &) override {}"}, {"sha": "1add4faa59ae1aba9a1d8a2425d14e9a505329a2", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 88, "deletions": 2, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -28,6 +28,68 @@\n namespace Rust {\n namespace Resolver {\n \n+class TypeCheckContextItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ITEM,\n+    IMPL_ITEM,\n+    TRAIT_ITEM,\n+  };\n+\n+  TypeCheckContextItem (HIR::Function *item)\n+    : type (ItemType::ITEM), item (item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::ImplBlock *impl_block, HIR::Function *item)\n+    : type (ItemType::IMPL_ITEM), item (impl_block, item)\n+  {}\n+\n+  TypeCheckContextItem (HIR::TraitItemFunc *trait_item)\n+    : type (ItemType::TRAIT_ITEM), item (trait_item)\n+  {}\n+\n+  ItemType get_type () const { return type; }\n+\n+  HIR::Function *get_item ()\n+  {\n+    rust_assert (get_type () == ItemType::ITEM);\n+    return item.item;\n+  }\n+\n+  std::pair<HIR::ImplBlock *, HIR::Function *> &get_impl_item ()\n+  {\n+    rust_assert (get_type () == ItemType::IMPL_ITEM);\n+    return item.impl_item;\n+  };\n+\n+  HIR::TraitItemFunc *get_trait_item ()\n+  {\n+    rust_assert (get_type () == ItemType::TRAIT_ITEM);\n+    return item.trait_item;\n+  }\n+\n+private:\n+  union Item\n+  {\n+    HIR::Function *item;\n+    std::pair<HIR::ImplBlock *, HIR::Function *> impl_item;\n+    HIR::TraitItemFunc *trait_item;\n+\n+    Item (HIR::Function *item) : item (item) {}\n+\n+    Item (HIR::ImplBlock *impl_block, HIR::Function *item)\n+      : impl_item ({impl_block, item})\n+    {}\n+\n+    Item (HIR::TraitItemFunc *trait_item) : trait_item (trait_item) {}\n+  };\n+\n+  ItemType type;\n+  Item item;\n+};\n+\n class TypeCheckContext\n {\n public:\n@@ -49,7 +111,9 @@ class TypeCheckContext\n   bool lookup_type_by_node_id (NodeId ref, HirId *id);\n \n   TyTy::BaseType *peek_return_type ();\n-  void push_return_type (TyTy::BaseType *return_type);\n+  TypeCheckContextItem &peek_context ();\n+  void push_return_type (TypeCheckContextItem item,\n+\t\t\t TyTy::BaseType *return_type);\n   void pop_return_type ();\n \n   void iterate (std::function<bool (HirId, TyTy::BaseType *)> cb)\n@@ -232,13 +296,32 @@ class TypeCheckContext\n     return true;\n   }\n \n+  void insert_operator_overload (HirId id, TyTy::FnType *call_site)\n+  {\n+    auto it = operator_overloads.find (id);\n+    rust_assert (it == operator_overloads.end ());\n+\n+    operator_overloads[id] = call_site;\n+  }\n+\n+  bool lookup_operator_overload (HirId id, TyTy::FnType **call)\n+  {\n+    auto it = operator_overloads.find (id);\n+    if (it == operator_overloads.end ())\n+      return false;\n+\n+    *call = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n   std::map<NodeId, HirId> node_id_refs;\n   std::map<HirId, TyTy::BaseType *> resolved;\n   std::vector<std::unique_ptr<TyTy::BaseType>> builtins;\n-  std::vector<TyTy::BaseType *> return_type_stack;\n+  std::vector<std::pair<TypeCheckContextItem, TyTy::BaseType *>>\n+    return_type_stack;\n   std::vector<TyTy::BaseType *> loop_type_stack;\n   std::map<DefId, TraitReference> trait_context;\n   std::map<HirId, TyTy::BaseType *> receiver_context;\n@@ -253,6 +336,9 @@ class TypeCheckContext\n   // adjustment mappings\n   std::map<HirId, std::vector<Adjustment>> autoderef_mappings;\n \n+  // operator overloads\n+  std::map<HirId, TyTy::FnType *> operator_overloads;\n+\n   // variants\n   std::map<HirId, HirId> variants;\n };"}, {"sha": "a439416b698df6cea1f7d3ace58002601d151341", "filename": "gcc/rust/typecheck/rust-substitution-mapper.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,49 @@\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-substitution-mapper.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+TyTy::BaseType *\n+SubstMapperInternal::Resolve (TyTy::BaseType *base,\n+\t\t\t      TyTy::SubstitutionArgumentMappings &mappings)\n+{\n+  SubstMapperInternal mapper (base->get_ref (), mappings);\n+  base->accept_vis (mapper);\n+  rust_assert (mapper.resolved != nullptr);\n+\n+  // insert these new implict types into the context\n+  bool is_fn = mapper.resolved->get_kind () == TyTy::TypeKind::FNDEF;\n+  bool is_adt = mapper.resolved->get_kind () == TyTy::TypeKind::ADT;\n+  bool is_param = mapper.resolved->get_kind () == TyTy::TypeKind::PARAM;\n+  if (!is_fn && !is_adt && !is_param)\n+    {\n+      auto context = TypeCheckContext::get ();\n+      context->insert_type (\n+\tAnalysis::NodeMapping (0, 0, mapper.resolved->get_ty_ref (), 0),\n+\tmapper.resolved);\n+    }\n+\n+  return mapper.resolved;\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "0932038d8c2554f8d9fcfeff6822b7ed36c1b65a", "filename": "gcc/rust/typecheck/rust-substitution-mapper.h", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-substitution-mapper.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -154,13 +154,7 @@ class SubstMapperInternal : public TyTy::TyVisitor\n {\n public:\n   static TyTy::BaseType *Resolve (TyTy::BaseType *base,\n-\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings)\n-  {\n-    SubstMapperInternal mapper (base->get_ref (), mappings);\n-    base->accept_vis (mapper);\n-    rust_assert (mapper.resolved != nullptr);\n-    return mapper.resolved;\n-  }\n+\t\t\t\t  TyTy::SubstitutionArgumentMappings &mappings);\n \n   void visit (TyTy::FnType &type) override\n   {"}, {"sha": "31f8ae571cbd63ce3492b422434e597cfebe684b", "filename": "gcc/rust/typecheck/rust-tyctx.cc", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyctx.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -122,13 +122,14 @@ TypeCheckContext::lookup_type_by_node_id (NodeId ref, HirId *id)\n TyTy::BaseType *\n TypeCheckContext::peek_return_type ()\n {\n-  return return_type_stack.back ();\n+  return return_type_stack.back ().second;\n }\n \n void\n-TypeCheckContext::push_return_type (TyTy::BaseType *return_type)\n+TypeCheckContext::push_return_type (TypeCheckContextItem item,\n+\t\t\t\t    TyTy::BaseType *return_type)\n {\n-  return_type_stack.push_back (return_type);\n+  return_type_stack.push_back ({std::move (item), return_type});\n }\n \n void\n@@ -137,5 +138,11 @@ TypeCheckContext::pop_return_type ()\n   return_type_stack.pop_back ();\n }\n \n+TypeCheckContextItem &\n+TypeCheckContext::peek_context ()\n+{\n+  return return_type_stack.back ().first;\n+}\n+\n } // namespace Resolver\n } // namespace Rust"}, {"sha": "30804273f753db8230bca10c6d63cb6797f816f2", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -88,9 +88,10 @@ class TypeCheckMethodCallExpr : private TyVisitor\n public:\n   // Resolve the Method parameters and return back the return type\n   static BaseType *go (BaseType *ref, HIR::MethodCallExpr &call,\n+\t\t       TyTy::BaseType *adjusted_self,\n \t\t       Resolver::TypeCheckContext *context)\n   {\n-    TypeCheckMethodCallExpr checker (call, context);\n+    TypeCheckMethodCallExpr checker (call, adjusted_self, context);\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n@@ -125,13 +126,15 @@ class TypeCheckMethodCallExpr : private TyVisitor\n \n private:\n   TypeCheckMethodCallExpr (HIR::MethodCallExpr &c,\n+\t\t\t   TyTy::BaseType *adjusted_self,\n \t\t\t   Resolver::TypeCheckContext *context)\n-    : resolved (nullptr), call (c), context (context),\n-      mappings (Analysis::Mappings::get ())\n+    : resolved (nullptr), call (c), adjusted_self (adjusted_self),\n+      context (context), mappings (Analysis::Mappings::get ())\n   {}\n \n   BaseType *resolved;\n   HIR::MethodCallExpr &call;\n+  TyTy::BaseType *adjusted_self;\n   Resolver::TypeCheckContext *context;\n   Analysis::Mappings *mappings;\n };"}, {"sha": "add4dbe695a685c39bdb0c2c1ff3d6c97b8bc1e1", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -2786,6 +2786,8 @@ TypeCheckCallExpr::visit (FnPtr &type)\n void\n TypeCheckMethodCallExpr::visit (FnType &type)\n {\n+  adjusted_self->unify (type.get_self_type ());\n+\n   // +1 for the receiver self\n   size_t num_args_to_call = call.num_params () + 1;\n   if (num_args_to_call != type.num_params ())"}, {"sha": "915aad9909bc702ce41e8ebb3ad62b90041ec971", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1324,7 +1324,7 @@ class FnType : public BaseType, public SubstitutionRef\n       params (std::move (params)), type (type), flags (flags),\n       identifier (identifier), id (id), abi (abi)\n   {\n-    LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n+    LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n@@ -1339,7 +1339,7 @@ class FnType : public BaseType, public SubstitutionRef\n       params (params), type (type), flags (flags), identifier (identifier),\n       id (id), abi (abi)\n   {\n-    LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n+    LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n@@ -1519,7 +1519,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n       parameter_types (std::move (parameter_types)),\n       result_type (std::move (result_type)), id (id)\n   {\n-    LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n+    LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n@@ -1533,7 +1533,7 @@ class ClosureType : public BaseType, public SubstitutionRef\n       parameter_types (std::move (parameter_types)),\n       result_type (std::move (result_type)), id (id)\n   {\n-    LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n+    LocalDefId local_def_id = id.localDefId;\n     rust_assert (local_def_id != UNKNOWN_LOCAL_DEFID);\n   }\n \n@@ -1588,13 +1588,13 @@ class ClosureType : public BaseType, public SubstitutionRef\n class ArrayType : public BaseType\n {\n public:\n-  ArrayType (HirId ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, Bexpression *capacity, TyVar base,\n+  ArrayType (HirId ref, HirId ty_ref, tree capacity, TyVar base,\n \t     std::set<HirId> refs = std::set<HirId> ())\n     : BaseType (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n       element_type (base)\n@@ -1615,7 +1615,7 @@ class ArrayType : public BaseType\n \n   bool is_equal (const BaseType &other) const override;\n \n-  Bexpression *get_capacity () const { return capacity; }\n+  tree get_capacity () const { return capacity; }\n   std::string capacity_string () const;\n \n   BaseType *get_element_type () const;\n@@ -1628,7 +1628,7 @@ class ArrayType : public BaseType\n   }\n \n private:\n-  Bexpression *capacity;\n+  tree capacity;\n   TyVar element_type;\n };\n "}, {"sha": "9e5b50951780e0cb3fa9c55ba25024780522e622", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -63,7 +63,7 @@ NodeMapping::get_defid () const\n DefId\n NodeMapping::get_defid (CrateNum crate_num, LocalDefId local_defid)\n {\n-  return ((uint64_t) crate_num << 32) | local_defid;\n+  return DefId{crate_num, local_defid};\n }\n \n std::string\n@@ -209,8 +209,8 @@ Mappings::insert_hir_crate (HIR::Crate *crate)\n void\n Mappings::insert_defid_mapping (DefId id, HIR::Item *item)\n {\n-  CrateNum crate_num = (id & DEF_ID_CRATE_MASK) >> 32;\n-  LocalDefId local_def_id = id & DEF_ID_LOCAL_DEF_MASK;\n+  CrateNum crate_num = id.crateNum;\n+  LocalDefId local_def_id = id.localDefId;\n \n   rust_assert (lookup_defid (id) == nullptr);\n   rust_assert (lookup_local_defid (crate_num, local_def_id) == nullptr);"}, {"sha": "4f8c3899a338e0ee75ae6674fec4b305d67e5005", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 197, "deletions": 4, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -23,13 +23,185 @@\n #include \"rust-location.h\"\n #include \"rust-mapping-common.h\"\n #include \"rust-canonical-path.h\"\n-\n #include \"rust-ast-full-decls.h\"\n #include \"rust-hir-full-decls.h\"\n+#include \"operator.h\"\n \n namespace Rust {\n namespace Analysis {\n \n+// https://github.com/rust-lang/rust/blob/master/library/core/src/ops/arith.rs\n+class RustLangItem\n+{\n+public:\n+  enum ItemType\n+  {\n+    ADD,\n+    SUBTRACT,\n+    MULTIPLY,\n+    DIVIDE,\n+    REMAINDER,\n+\n+    NEGATION,\n+    NOT,\n+\n+    ADD_ASSIGN,\n+    SUB_ASSIGN,\n+    MUL_ASSIGN,\n+    DIV_ASSIGN,\n+    REM_ASSIGN,\n+\n+    UNKNOWN,\n+  };\n+\n+  static ItemType Parse (const std::string &item)\n+  {\n+    if (item.compare (\"add\") == 0)\n+      {\n+\treturn ItemType::ADD;\n+      }\n+    else if (item.compare (\"sub\") == 0)\n+      {\n+\treturn ItemType::SUBTRACT;\n+      }\n+    else if (item.compare (\"mul\") == 0)\n+      {\n+\treturn ItemType::MULTIPLY;\n+      }\n+    else if (item.compare (\"div\") == 0)\n+      {\n+\treturn ItemType::DIVIDE;\n+      }\n+    else if (item.compare (\"rem\") == 0)\n+      {\n+\treturn ItemType::REMAINDER;\n+      }\n+    else if (item.compare (\"neg\") == 0)\n+      {\n+\treturn ItemType::NEGATION;\n+      }\n+    else if (item.compare (\"not\") == 0)\n+      {\n+\treturn ItemType::NOT;\n+      }\n+    else if (item.compare (\"add_assign\") == 0)\n+      {\n+\treturn ItemType::ADD_ASSIGN;\n+      }\n+    else if (item.compare (\"sub_assign\") == 0)\n+      {\n+\treturn ItemType::SUB_ASSIGN;\n+      }\n+    else if (item.compare (\"mul_assign\") == 0)\n+      {\n+\treturn ItemType::MUL_ASSIGN;\n+      }\n+    else if (item.compare (\"div_assign\") == 0)\n+      {\n+\treturn ItemType::DIV_ASSIGN;\n+      }\n+    else if (item.compare (\"rem_assign\") == 0)\n+      {\n+\treturn ItemType::REM_ASSIGN;\n+      }\n+\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static std::string ToString (ItemType type)\n+  {\n+    switch (type)\n+      {\n+      case ADD:\n+\treturn \"add\";\n+      case SUBTRACT:\n+\treturn \"sub\";\n+      case MULTIPLY:\n+\treturn \"mul\";\n+      case DIVIDE:\n+\treturn \"div\";\n+      case REMAINDER:\n+\treturn \"rem\";\n+      case NEGATION:\n+\treturn \"neg\";\n+      case NOT:\n+\treturn \"not\";\n+      case ADD_ASSIGN:\n+\treturn \"add_assign\";\n+      case SUB_ASSIGN:\n+\treturn \"sub_assign\";\n+      case MUL_ASSIGN:\n+\treturn \"mul_assign\";\n+      case DIV_ASSIGN:\n+\treturn \"div_assign\";\n+      case REM_ASSIGN:\n+\treturn \"rem_assign\";\n+\n+      case UNKNOWN:\n+\tbreak;\n+      }\n+    return \"<UNKNOWN>\";\n+  }\n+\n+  static ItemType OperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUBTRACT;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MULTIPLY;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIVIDE;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REMAINDER;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType\n+  CompoundAssignmentOperatorToLangItem (ArithmeticOrLogicalOperator op)\n+  {\n+    switch (op)\n+      {\n+      case ArithmeticOrLogicalOperator::ADD:\n+\treturn ItemType::ADD_ASSIGN;\n+      case ArithmeticOrLogicalOperator::SUBTRACT:\n+\treturn ItemType::SUB_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MULTIPLY:\n+\treturn ItemType::MUL_ASSIGN;\n+      case ArithmeticOrLogicalOperator::DIVIDE:\n+\treturn ItemType::DIV_ASSIGN;\n+      case ArithmeticOrLogicalOperator::MODULUS:\n+\treturn ItemType::REM_ASSIGN;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+\n+  static ItemType NegationOperatorToLangItem (NegationOperator op)\n+  {\n+    switch (op)\n+      {\n+      case NegationOperator::NEGATE:\n+\treturn ItemType::NEGATION;\n+      case NegationOperator::NOT:\n+\treturn ItemType::NOT;\n+\n+      default:\n+\treturn ItemType::UNKNOWN;\n+      }\n+    return ItemType::UNKNOWN;\n+  }\n+};\n+\n class NodeMapping\n {\n public:\n@@ -237,9 +409,9 @@ class Mappings\n     const Resolver::CanonicalPath *p = nullptr;\n     if (lookup_canonical_path (crate, id, &p))\n       {\n-\t// if we have already stored a canonical path this is ok so long as this\n-\t// new path is equal or is smaller that the existing one but in that\n-\t// case we ignore it.\n+\t// if we have already stored a canonical path this is ok so long as\n+\t// this new path is equal or is smaller that the existing one but in\n+\t// that case we ignore it.\n \tif (p->is_equal (path))\n \t  return;\n \telse\n@@ -267,6 +439,24 @@ class Mappings\n     return true;\n   }\n \n+  void insert_lang_item (RustLangItem::ItemType item_type, DefId id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    rust_assert (it == lang_item_mappings.end ());\n+\n+    lang_item_mappings[item_type] = id;\n+  }\n+\n+  bool lookup_lang_item (RustLangItem::ItemType item_type, DefId *id)\n+  {\n+    auto it = lang_item_mappings.find (item_type);\n+    if (it == lang_item_mappings.end ())\n+      return false;\n+\n+    *id = it->second;\n+    return true;\n+  }\n+\n private:\n   Mappings ();\n \n@@ -304,6 +494,9 @@ class Mappings\n     hirGenericParamMappings;\n   std::map<HirId, HIR::Trait *> hirTraitItemsToTraitMappings;\n \n+  // this maps the lang=<item_type> to DefId mappings\n+  std::map<RustLangItem::ItemType, DefId> lang_item_mappings;\n+\n   // canonical paths\n   std::map<CrateNum, std::map<NodeId, const Resolver::CanonicalPath> > paths;\n "}, {"sha": "066577961813dd389a45e9156f2cdf64a6c1b7dc", "filename": "gcc/rust/util/rust-mapping-common.h", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-mapping-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Frust%2Futil%2Frust-mapping-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-mapping-common.h?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -31,17 +31,32 @@ typedef uint32_t NodeId;\n typedef uint32_t HirId;\n // refers to any top-level decl in HIR\n typedef uint32_t LocalDefId;\n-// refers to <Crate><DefId>\n-typedef uint64_t DefId;\n \n-#define DEF_ID_CRATE_MASK 0xFFFFFFFF00000000\n-#define DEF_ID_LOCAL_DEF_MASK 0x00000000FFFFFFFF\n+struct DefId\n+{\n+  CrateNum crateNum;\n+  LocalDefId localDefId;\n+\n+  bool operator== (const DefId &other) const\n+  {\n+    return this->crateNum == other.crateNum\n+\t   && this->localDefId == other.localDefId;\n+  }\n+\n+  bool operator!= (const DefId &other) const { return !(*this == other); }\n+\n+  bool operator< (const DefId &other) const\n+  {\n+    return ((uint64_t) this->crateNum << 32 | this->localDefId)\n+\t   < ((uint64_t) other.crateNum << 32 | other.localDefId);\n+  }\n+};\n \n #define UNKNOWN_CREATENUM ((uint32_t) (0))\n #define UNKNOWN_NODEID ((uint32_t) (0))\n #define UNKNOWN_HIRID ((uint32_t) (0))\n #define UNKNOWN_LOCAL_DEFID ((uint32_t) (0))\n-#define UNKNOWN_DEFID ((uint64_t) (0))\n+#define UNKNOWN_DEFID (DefId{0, 0})\n \n } // namespace Rust\n "}, {"sha": "9aa00fe0d0864f084bfb31b0fef41467de1cdea9", "filename": "gcc/testsuite/rust/compile/torture/issue-808.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fissue-808.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,22 @@\n+pub trait Foo {\n+    type Target;\n+\n+    fn bar(&self) -> &Self::Target;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Foo::bar.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl<T> Foo for &T {\n+    type Target = T;\n+\n+    fn bar(&self) -> &T {\n+        *self\n+    }\n+}\n+\n+pub fn main() {\n+    let a: i32 = 123;\n+    let b: &i32 = &a;\n+\n+    b.bar();\n+}"}, {"sha": "41c82f01b6ddcd2402fce86c48bae5722ea7269c", "filename": "gcc/testsuite/rust/compile/torture/traits11.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits11.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1,6 +1,5 @@\n trait Foo {\n     type A;\n-    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n \n     fn test(a: Self::A) -> Self::A {\n         a"}, {"sha": "10d9479fb0da76a8b8cfc2debc936ff100f65baa", "filename": "gcc/testsuite/rust/compile/torture/traits4.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits4.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1,8 +1,6 @@\n trait Foo {\n     type A;\n-    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n     type B;\n-    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n \n     fn new(a: Self::A, b: Self::B) -> Self;\n     // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }"}, {"sha": "4a396a0ffa5dae9d5b14ee4a8c6049053fe8f0e4", "filename": "gcc/testsuite/rust/compile/torture/traits5.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits5.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1,8 +1,6 @@\n trait Foo {\n     type A;\n-    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n     type B;\n-    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n \n     fn new(a: Self::A, b: Self::B) -> Self;\n     // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }"}, {"sha": "a69c6fd14a6c1aea7307840ddb49284f5c34d2ce", "filename": "gcc/testsuite/rust/compile/torture/traits6.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits6.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -1,6 +1,5 @@\n trait Foo {\n     type A;\n-    // { dg-warning \"unused name .Foo::A.\" \"\" { target *-*-* } .-1 }\n \n     fn baz(a: Self::A) -> Self::A;\n     // { dg-warning \"unused name .a.\" \"\" { target *-*-* } .-1 }"}, {"sha": "997ab04f5f186ef7886a6bd16858711883e1a065", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_1.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = 1 + 2;\n+\n+    0\n+}"}, {"sha": "8d6a0739ff0f421b2af487e3817fb98d94d67280", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_2.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_2.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+struct Foo(i32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "50ff7991a30e17809805ed189ae04fd70040a007", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_3.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_3.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-output \"3\\n3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<Rhs = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: Rhs) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .rhs.\" \"\" { target *-*-* } .-2 }\n+    // { dg-warning \"unused name .Add::add.\" \"\" { target *-*-* } .-3 }\n+}\n+\n+impl Add for i32 {\n+    type Output = i32;\n+\n+    fn add(self, other: i32) -> i32 {\n+        let res = self + other;\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res);\n+        }\n+\n+        res\n+    }\n+}\n+\n+struct Foo(i32);\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, other: Foo) -> Foo {\n+        let res = Foo(self.0 + other.0);\n+\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, res.0);\n+        }\n+\n+        res\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(1) + Foo(2);\n+\n+    0\n+}"}, {"sha": "5ca5c7aec50254d084df3114dd45547cd9b495cb", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_4.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_4.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-output \"neg\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"neg\"]\n+pub trait Neg {\n+    type Output;\n+\n+    fn neg(self) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Neg::neg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl Neg for i32 {\n+    type Output = i32;\n+\n+    fn neg(self) -> i32 {\n+        unsafe {\n+            let a = \"neg\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+        -self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a: i32 = 1;\n+    let _b = -a;\n+\n+    0\n+}"}, {"sha": "5aac3ad0589a902f83abe64212799f2ee43bceb4", "filename": "gcc/testsuite/rust/execute/torture/operator_overload_5.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73a0903c156f86e1e59c30c542780fe2162438d4/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Foperator_overload_5.rs?ref=73a0903c156f86e1e59c30c542780fe2162438d4", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-output \"not\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+#[lang = \"not\"]\n+pub trait Not {\n+    type Output;\n+\n+    fn not(self) -> Self::Output;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .Not::not.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+impl Not for i32 {\n+    type Output = i32;\n+\n+    fn not(self) -> i32 {\n+        unsafe {\n+            let a = \"not\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c);\n+        }\n+        !self\n+    }\n+}\n+\n+fn main() -> i32 {\n+    let a: i32 = 1;\n+    let _b = !a;\n+\n+    0\n+}"}]}