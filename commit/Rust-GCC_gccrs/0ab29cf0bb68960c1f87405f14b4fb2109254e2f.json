{"sha": "0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "node_id": "C_kwDOANBUbNoAKDBhYjI5Y2YwYmI2ODk2MGMxZjg3NDA1ZjE0YjRmYjIxMDkyNTRlMmY", "commit": {"author": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-12-08T14:28:03Z"}, "committer": {"name": "Chung-Lin Tang", "email": "cltang@codesourcery.com", "date": "2021-12-08T14:29:06Z"}, "message": "openmp: Improve OpenMP target support for C++ (PR92120)\n\nThis patch implements several C++ specific mapping capabilities introduced for\nOpenMP 5.0, including implicit mapping of this[:1] for non-static member\nfunctions, zero-length array section mapping of pointer-typed members,\nlambda captured variable access in target regions, and use of lambda objects\ninside target regions.\n\nSeveral adjustments to the C/C++ front-ends to allow more member-access syntax\nas valid is also included.\n\n\tPR middle-end/92120\n\ngcc/cp/ChangeLog:\n\n\t* cp-tree.h (finish_omp_target): New declaration.\n\t(finish_omp_target_clauses): Likewise.\n\t* parser.c (cp_parser_omp_clause_map): Adjust call to\n\tcp_parser_omp_var_list_no_open to set 'allow_deref' argument to true.\n\t(cp_parser_omp_target): Factor out code, adjust into calls to new\n\tfunction finish_omp_target.\n\t* pt.c (tsubst_expr): Add call to finish_omp_target_clauses for\n\tOMP_TARGET case.\n\t* semantics.c (handle_omp_array_sections_1): Add handling to create\n\t'this->member' from 'member' FIELD_DECL. Remove case of rejecting\n\t'this' when not in declare simd.\n\t(handle_omp_array_sections): Likewise.\n\t(finish_omp_clauses): Likewise. Adjust to allow 'this[]' in OpenMP\n\tmap clauses. Handle 'A->member' case in map clauses. Remove case of\n\trejecting 'this' when not in declare simd.\n\t(struct omp_target_walk_data): New struct for walking over\n\ttarget-directive tree body.\n\t(finish_omp_target_clauses_r): New function for tree walk.\n\t(finish_omp_target_clauses): New function.\n\t(finish_omp_target): New function.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.c (c_parser_omp_clause_map): Set 'allow_deref' argument in\n\tcall to c_parser_omp_variable_list to 'true'.\n\t* c-typeck.c (handle_omp_array_sections_1): Add strip of MEM_REF in\n\tarray base handling.\n\t(c_finish_omp_clauses): Handle 'A->member' case in map clauses.\n\ngcc/ChangeLog:\n\n\t* gimplify.c (\"tree-hash-traits.h\"): Add include.\n\t(gimplify_scan_omp_clauses): Change struct_map_to_clause to type\n\thash_map<tree_operand, tree> *. Adjust struct map handling to handle\n\tcases of *A and A->B expressions. Under !DECL_P case of\n\tGOMP_CLAUSE_MAP handling, add STRIP_NOPS for indir_p case, add to\n\tstruct_deref_set for map(*ptr_to_struct) cases. Add MEM_REF case when\n\thandling component_ref_p case. Add unshare_expr and gimplification\n\twhen created GOMP_MAP_STRUCT is not a DECL. Add code to add\n\tfirstprivate pointer for *pointer-to-struct case.\n\t(gimplify_adjust_omp_clauses): Move GOMP_MAP_STRUCT removal code for\n\texit data directives code to earlier position.\n\t* omp-low.c (lower_omp_target):\n\tHandle GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION, and\n\tGOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION map kinds.\n\t* tree-pretty-print.c (dump_omp_clause): Likewise.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/gomp/target-3.c: New testcase.\n\t* g++.dg/gomp/target-3.C: New testcase.\n\t* g++.dg/gomp/target-lambda-1.C: New testcase.\n\t* g++.dg/gomp/target-lambda-2.C: New testcase.\n\t* g++.dg/gomp/target-this-1.C: New testcase.\n\t* g++.dg/gomp/target-this-2.C: New testcase.\n\t* g++.dg/gomp/target-this-3.C: New testcase.\n\t* g++.dg/gomp/target-this-4.C: New testcase.\n\t* g++.dg/gomp/target-this-5.C: New testcase.\n\t* g++.dg/gomp/this-2.C: Adjust testcase.\n\ninclude/ChangeLog:\n\n\t* gomp-constants.h (enum gomp_map_kind):\n\tAdd GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION, and\n\tGOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION map kinds.\n\t(GOMP_MAP_POINTER_P):\n\tInclude GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION.\n\nlibgomp/ChangeLog:\n\n\t* libgomp.h (gomp_attach_pointer): Add bool parameter.\n\t* oacc-mem.c (acc_attach_async): Update call to gomp_attach_pointer.\n\t(goacc_enter_data_internal): Likewise.\n\t* target.c (gomp_map_vars_existing): Update assert condition to\n\tinclude GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION.\n\t(gomp_map_pointer): Add 'bool allow_zero_length_array_sections'\n\tparameter, add support for mapping a pointer with NULL target.\n\t(gomp_attach_pointer): Add 'bool allow_zero_length_array_sections'\n\tparameter, add support for attaching a pointer with NULL target.\n\t(gomp_map_vars_internal): Update calls to gomp_map_pointer and\n\tgomp_attach_pointer, add handling for\n\tGOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION, and\n\tGOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION cases.\n\t* testsuite/libgomp.c++/target-23.C: New testcase.\n\t* testsuite/libgomp.c++/target-lambda-1.C: New testcase.\n\t* testsuite/libgomp.c++/target-lambda-2.C: New testcase.\n\t* testsuite/libgomp.c++/target-this-1.C: New testcase.\n\t* testsuite/libgomp.c++/target-this-2.C: New testcase.\n\t* testsuite/libgomp.c++/target-this-3.C: New testcase.\n\t* testsuite/libgomp.c++/target-this-4.C: New testcase.\n\t* testsuite/libgomp.c++/target-this-5.C: New testcase.", "tree": {"sha": "dc3a692a82f7a3f39c6b7b1f4dbb00c7088a8fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc3a692a82f7a3f39c6b7b1f4dbb00c7088a8fa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/comments", "author": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cltang", "id": 4055966, "node_id": "MDQ6VXNlcjQwNTU5NjY=", "avatar_url": "https://avatars.githubusercontent.com/u/4055966?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cltang", "html_url": "https://github.com/cltang", "followers_url": "https://api.github.com/users/cltang/followers", "following_url": "https://api.github.com/users/cltang/following{/other_user}", "gists_url": "https://api.github.com/users/cltang/gists{/gist_id}", "starred_url": "https://api.github.com/users/cltang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cltang/subscriptions", "organizations_url": "https://api.github.com/users/cltang/orgs", "repos_url": "https://api.github.com/users/cltang/repos", "events_url": "https://api.github.com/users/cltang/events{/privacy}", "received_events_url": "https://api.github.com/users/cltang/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbf8bd3c2f2cd2d27ca4f0fe379bd9490273c6d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbf8bd3c2f2cd2d27ca4f0fe379bd9490273c6d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbf8bd3c2f2cd2d27ca4f0fe379bd9490273c6d7"}], "stats": {"total": 1909, "additions": 1766, "deletions": 143}, "files": [{"sha": "1ea2c72eb1a5449b0c6f60ba0fcc5cea48c9ae6b", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -16194,7 +16194,8 @@ c_parser_omp_clause_map (c_parser *parser, tree list)\n       c_parser_consume_token (parser);\n     }\n \n-  nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list);\n+  nl = c_parser_omp_variable_list (parser, clause_loc, OMP_CLAUSE_MAP, list,\n+\t\t\t\t   true);\n \n   for (c = nl; c != list; c = OMP_CLAUSE_CHAIN (c))\n     OMP_CLAUSE_SET_MAP_KIND (c, kind);"}, {"sha": "b77ecb651ce5065939365fb98bb943ed1621daaa", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -13241,6 +13241,11 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == MEM_REF)\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t  STRIP_NOPS (t);\n+\t\t}\n \t      if (ort == C_ORT_ACC && TREE_CODE (t) == MEM_REF)\n \t\t{\n \t\t  if (maybe_ne (mem_ref_offset (t), 0))\n@@ -14085,6 +14090,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   tree ordered_clause = NULL_TREE;\n   tree schedule_clause = NULL_TREE;\n   bool oacc_async = false;\n+  bool indir_component_ref_p = false;\n   tree last_iterators = NULL_TREE;\n   bool last_iterators_remove = false;\n   tree *nogroup_seen = NULL;\n@@ -14886,6 +14892,11 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t    {\n \t\t      while (TREE_CODE (t) == COMPONENT_REF)\n \t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (TREE_CODE (t) == MEM_REF)\n+\t\t\t{\n+\t\t\t  t = TREE_OPERAND (t, 0);\n+\t\t\t  STRIP_NOPS (t);\n+\t\t\t}\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n \t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n@@ -14952,6 +14963,14 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t       bias) to zero here, so it is not set erroneously to the pointer\n \t       size later on in gimplify.c.  */\n \t    OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t  indir_component_ref_p = false;\n+\t  if (TREE_CODE (t) == COMPONENT_REF\n+\t      && TREE_CODE (TREE_OPERAND (t, 0)) == MEM_REF)\n+\t    {\n+\t      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\t      indir_component_ref_p = true;\n+\t      STRIP_NOPS (t);\n+\t    }\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n \t    {\n@@ -15024,6 +15043,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t  else if ((OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n \t\t    || (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t!= GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\t\t   && !indir_component_ref_p\n \t\t   && !c_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n@@ -15080,8 +15100,7 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tbitmap_set_bit (&map_firstprivate_head, DECL_UID (t));\n \t    }\n \t  else if (bitmap_bit_p (&map_head, DECL_UID (t))\n-\t\t   && (ort == C_ORT_ACC\n-\t\t       || !bitmap_bit_p (&map_field_head, DECL_UID (t))))\n+\t\t   && !bitmap_bit_p (&map_field_head, DECL_UID (t)))\n \t    {\n \t      if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP)\n \t\terror_at (OMP_CLAUSE_LOCATION (c),"}, {"sha": "b1c3bc5ed1f1c9a59ea045dcd04934523dec973f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -7671,6 +7671,8 @@ extern tree start_lambda_function\t\t(tree fn, tree lambda_expr);\n extern void finish_lambda_function\t\t(tree body);\n extern bool regenerated_lambda_fn_p\t\t(tree);\n extern tree most_general_lambda\t\t\t(tree);\n+extern tree finish_omp_target\t\t\t(location_t, tree, tree, bool);\n+extern void finish_omp_target_clauses\t\t(location_t, tree, tree *);\n \n /* in tree.c */\n extern int cp_tree_operand_length\t\t(const_tree);"}, {"sha": "ed367095334e26bdb9629a8e8df8440298a94483", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 13, "deletions": 56, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -39315,7 +39315,7 @@ cp_parser_omp_clause_map (cp_parser *parser, tree list)\n     }\n \n   nlist = cp_parser_omp_var_list_no_open (parser, OMP_CLAUSE_MAP, list,\n-\t\t\t\t\t  NULL);\n+\t\t\t\t\t  NULL, true);\n \n   for (c = nlist; c != list; c = OMP_CLAUSE_CHAIN (c))\n     OMP_CLAUSE_SET_MAP_KIND (c, kind);\n@@ -44105,8 +44105,6 @@ static bool\n cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t\t      enum pragma_context context, bool *if_p)\n {\n-  tree *pc = NULL, stmt;\n-\n   if (flag_openmp)\n     omp_requires_mask\n       = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n@@ -44211,16 +44209,10 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \t\t\t= cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n \t\t      cclauses[C_OMP_CLAUSE_SPLIT_TARGET] = tc;\n \t\t    }\n-\t  tree stmt = make_node (OMP_TARGET);\n-\t  TREE_TYPE (stmt) = void_type_node;\n-\t  OMP_TARGET_CLAUSES (stmt) = cclauses[C_OMP_CLAUSE_SPLIT_TARGET];\n-\t  c_omp_adjust_map_clauses (OMP_TARGET_CLAUSES (stmt), true);\n-\t  OMP_TARGET_BODY (stmt) = body;\n-\t  OMP_TARGET_COMBINED (stmt) = 1;\n-\t  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n-\t  add_stmt (stmt);\n-\t  pc = &OMP_TARGET_CLAUSES (stmt);\n-\t  goto check_clauses;\n+\t  c_omp_adjust_map_clauses (cclauses[C_OMP_CLAUSE_SPLIT_TARGET], true);\n+\t  finish_omp_target (pragma_tok->location,\n+\t\t\t     cclauses[C_OMP_CLAUSE_SPLIT_TARGET], body, true);\n+\t  return true;\n \t}\n       else if (!flag_openmp)  /* flag_openmp_simd  */\n \t{\n@@ -44255,13 +44247,10 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n       return false;\n     }\n \n-  stmt = make_node (OMP_TARGET);\n-  TREE_TYPE (stmt) = void_type_node;\n-\n-  OMP_TARGET_CLAUSES (stmt)\n-    = cp_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n-\t\t\t\t \"#pragma omp target\", pragma_tok, false);\n-  for (tree c = OMP_TARGET_CLAUSES (stmt); c; c = OMP_CLAUSE_CHAIN (c))\n+  tree clauses = cp_parser_omp_all_clauses (parser, OMP_TARGET_CLAUSE_MASK,\n+\t\t\t\t\t    \"#pragma omp target\", pragma_tok,\n+\t\t\t\t\t    false);\n+  for (tree c = clauses; c; c = OMP_CLAUSE_CHAIN (c))\n     if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_IN_REDUCTION)\n       {\n \ttree nc = build_omp_clause (OMP_CLAUSE_LOCATION (c), OMP_CLAUSE_MAP);\n@@ -44270,45 +44259,13 @@ cp_parser_omp_target (cp_parser *parser, cp_token *pragma_tok,\n \tOMP_CLAUSE_CHAIN (nc) = OMP_CLAUSE_CHAIN (c);\n \tOMP_CLAUSE_CHAIN (c) = nc;\n       }\n-  OMP_TARGET_CLAUSES (stmt)\n-    = finish_omp_clauses (OMP_TARGET_CLAUSES (stmt), C_ORT_OMP_TARGET);\n-  c_omp_adjust_map_clauses (OMP_TARGET_CLAUSES (stmt), true);\n+  clauses = finish_omp_clauses (clauses, C_ORT_OMP_TARGET);\n \n-  pc = &OMP_TARGET_CLAUSES (stmt);\n+  c_omp_adjust_map_clauses (clauses, true);\n   keep_next_level (true);\n-  OMP_TARGET_BODY (stmt) = cp_parser_omp_structured_block (parser, if_p);\n-\n-  SET_EXPR_LOCATION (stmt, pragma_tok->location);\n-  add_stmt (stmt);\n+  tree body = cp_parser_omp_structured_block (parser, if_p);\n \n-check_clauses:\n-  while (*pc)\n-    {\n-      if (OMP_CLAUSE_CODE (*pc) == OMP_CLAUSE_MAP)\n-\tswitch (OMP_CLAUSE_MAP_KIND (*pc))\n-\t  {\n-\t  case GOMP_MAP_TO:\n-\t  case GOMP_MAP_ALWAYS_TO:\n-\t  case GOMP_MAP_FROM:\n-\t  case GOMP_MAP_ALWAYS_FROM:\n-\t  case GOMP_MAP_TOFROM:\n-\t  case GOMP_MAP_ALWAYS_TOFROM:\n-\t  case GOMP_MAP_ALLOC:\n-\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n-\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n-\t  case GOMP_MAP_ALWAYS_POINTER:\n-\t  case GOMP_MAP_ATTACH_DETACH:\n-\t    break;\n-\t  default:\n-\t    error_at (OMP_CLAUSE_LOCATION (*pc),\n-\t\t      \"%<#pragma omp target%> with map-type other \"\n-\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n-\t\t      \"on %<map%> clause\");\n-\t    *pc = OMP_CLAUSE_CHAIN (*pc);\n-\t    continue;\n-\t  }\n-      pc = &OMP_CLAUSE_CHAIN (*pc);\n-    }\n+  finish_omp_target (pragma_tok->location, clauses, body, false);\n   return true;\n }\n "}, {"sha": "9834baf34dbc2eb98d77bd3ee700de8a771f18c3", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -18975,6 +18975,11 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n       t = copy_node (t);\n       OMP_BODY (t) = stmt;\n       OMP_CLAUSES (t) = tmp;\n+\n+      if (TREE_CODE (t) == OMP_TARGET)\n+\tfinish_omp_target_clauses (EXPR_LOCATION (t), OMP_BODY (t),\n+\t\t\t\t   &OMP_CLAUSES (t));\n+\n       if (TREE_CODE (t) == OMP_TARGET && OMP_TARGET_COMBINED (t))\n \t{\n \t  tree teams = cp_walk_tree (&stmt, tsubst_find_omp_teams, NULL, NULL);"}, {"sha": "9ebb1ac88b707c9862225e5fb889800b47ec8bc7", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 555, "deletions": 26, "changes": 581, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -5049,15 +5049,16 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t  return error_mark_node;\n \t\t}\n \t      t = TREE_OPERAND (t, 0);\n-\t      if (ort == C_ORT_ACC && TREE_CODE (t) == INDIRECT_REF)\n-\t\tt = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == INDIRECT_REF)\n+\t\t{\n+\t\t  t = TREE_OPERAND (t, 0);\n+\t\t  STRIP_NOPS (t);\n+\t\t}\n \t    }\n \t  if (REFERENCE_REF_P (t))\n \t    t = TREE_OPERAND (t, 0);\n \t}\n-      if (TREE_CODE (t) == FIELD_DECL\n-\t  && (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_AFFINITY\n-\t      || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_DEPEND))\n+      if (TREE_CODE (t) == FIELD_DECL)\n \tret = finish_non_static_data_member (t, NULL_TREE, NULL_TREE);\n       else if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t{\n@@ -5073,18 +5074,6 @@ handle_omp_array_sections_1 (tree c, tree t, vec<tree> &types,\n \t\t      omp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t  return error_mark_node;\n \t}\n-      else if ((ort & C_ORT_OMP_DECLARE_SIMD) == C_ORT_OMP\n-\t       && TREE_CODE (t) == PARM_DECL\n-\t       && DECL_ARTIFICIAL (t)\n-\t       && DECL_NAME (t) == this_identifier\n-\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n-\t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND)\n-\t{\n-\t  error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t    \"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t    \" clauses\");\n-\t  return error_mark_node;\n-\t}\n       else if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_AFFINITY\n \t       && OMP_CLAUSE_CODE (c) != OMP_CLAUSE_DEPEND\n \t       && VAR_P (t) && CP_DECL_THREAD_LOCAL_P (t))\n@@ -5599,6 +5588,8 @@ handle_omp_array_sections (tree c, enum c_omp_region_type ort)\n \t    }\n \t  OMP_CLAUSE_DECL (c) = first;\n \t  OMP_CLAUSE_SIZE (c) = size;\n+\t  if (TREE_CODE (t) == FIELD_DECL)\n+\t    t = finish_non_static_data_member (t, NULL_TREE, NULL_TREE);\n \t  if (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n \t      || (TREE_CODE (t) == COMPONENT_REF\n \t\t  && TREE_CODE (TREE_TYPE (t)) == ARRAY_TYPE))\n@@ -6611,6 +6602,7 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n   bool order_seen = false;\n   bool schedule_seen = false;\n   bool oacc_async = false;\n+  bool indir_component_ref_p = false;\n   tree last_iterators = NULL_TREE;\n   bool last_iterators_remove = false;\n   /* 1 if normal/task reduction has been seen, -1 if inscan reduction\n@@ -7862,6 +7854,11 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tt = TREE_OPERAND (t, 0);\n \t\t      if (REFERENCE_REF_P (t))\n \t\t\tt = TREE_OPERAND (t, 0);\n+\t\t      if (TREE_CODE (t) == INDIRECT_REF)\n+\t\t\t{\n+\t\t\t  t = TREE_OPERAND (t, 0);\n+\t\t\t  STRIP_NOPS (t);\n+\t\t\t}\n \t\t      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n \t\t\t  && OMP_CLAUSE_MAP_IMPLICIT (c)\n \t\t\t  && (bitmap_bit_p (&map_head, DECL_UID (t))\n@@ -7934,9 +7931,14 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t      t = TREE_OPERAND (t, 0);\n \t      OMP_CLAUSE_DECL (c) = t;\n \t    }\n+\t  indir_component_ref_p = false;\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && TREE_CODE (TREE_OPERAND (t, 0)) == INDIRECT_REF)\n-\t    t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\t    {\n+\t      t = TREE_OPERAND (TREE_OPERAND (t, 0), 0);\n+\t      indir_component_ref_p = true;\n+\t      STRIP_NOPS (t);\n+\t    }\n \t  if (TREE_CODE (t) == COMPONENT_REF\n \t      && OMP_CLAUSE_CODE (c) != OMP_CLAUSE__CACHE_)\n \t    {\n@@ -7983,6 +7985,13 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t    goto handle_map_references;\n \t\t}\n \t    }\n+\t  if (!processing_template_decl\n+\t      && TREE_CODE (t) == FIELD_DECL)\n+\t    {\n+\t      OMP_CLAUSE_DECL (c) = finish_non_static_data_member (t, NULL_TREE,\n+\t\t\t\t\t\t\t\t   NULL_TREE);\n+\t      break;\n+\t    }\n \t  if (!VAR_P (t) && TREE_CODE (t) != PARM_DECL)\n \t    {\n \t      if (processing_template_decl && TREE_CODE (t) != OVERLOAD)\n@@ -8009,19 +8018,12 @@ finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\t\tomp_clause_code_name[OMP_CLAUSE_CODE (c)]);\n \t      remove = true;\n \t    }\n-\t  else if (ort != C_ORT_ACC && t == current_class_ptr)\n-\t    {\n-\t      error_at (OMP_CLAUSE_LOCATION (c),\n-\t\t\t\"%<this%> allowed in OpenMP only in %<declare simd%>\"\n-\t\t\t\" clauses\");\n-\t      remove = true;\n-\t      break;\n-\t    }\n \t  else if (!processing_template_decl\n \t\t   && !TYPE_REF_P (TREE_TYPE (t))\n \t\t   && (OMP_CLAUSE_CODE (c) != OMP_CLAUSE_MAP\n \t\t       || (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t   != GOMP_MAP_FIRSTPRIVATE_POINTER))\n+\t\t   && !indir_component_ref_p\n \t\t   && !cxx_mark_addressable (t))\n \t    remove = true;\n \t  else if (!(OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP\n@@ -9177,6 +9179,533 @@ finish_omp_construct (enum tree_code code, tree body, tree clauses)\n   return add_stmt (stmt);\n }\n \n+/* Used to walk OpenMP target directive body.  */\n+\n+struct omp_target_walk_data\n+{\n+  /* Holds the 'this' expression found in current function.  */\n+  tree current_object;\n+\n+  /* True if the 'this' expression was accessed in the target body.  */\n+  bool this_expr_accessed;\n+\n+  /* For non-static functions, record which pointer-typed members were\n+     accessed, and the whole expression.  */\n+  hash_map<tree, tree> ptr_members_accessed;\n+\n+  /* Record which lambda objects were accessed in target body.  */\n+  hash_set<tree> lambda_objects_accessed;\n+\n+  /* For lambda functions, the __closure object expression of the current\n+     function, and the set of captured variables accessed in target body.  */\n+  tree current_closure;\n+  hash_set<tree> closure_vars_accessed;\n+\n+  /* Local variables declared inside a BIND_EXPR, used to filter out such\n+     variables when recording lambda_objects_accessed.  */\n+  hash_set<tree> local_decls;\n+};\n+\n+/* Helper function of finish_omp_target_clauses, called via\n+   cp_walk_tree_without_duplicates.  Traverse body of OpenMP target\n+   directive *TP, and fill out omp_target_walk_data passed in *PTR.  */\n+\n+static tree\n+finish_omp_target_clauses_r (tree *tp, int *walk_subtrees, void *ptr)\n+{\n+  tree t = *tp;\n+  struct omp_target_walk_data *data = (struct omp_target_walk_data *) ptr;\n+  tree current_object = data->current_object;\n+  tree current_closure = data->current_closure;\n+\n+  /* References inside of these expression codes shouldn't incur any\n+     form of mapping, so return early.  */\n+  if (TREE_CODE (t) == SIZEOF_EXPR\n+      || TREE_CODE (t) == ALIGNOF_EXPR)\n+    {\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (current_object)\n+    {\n+      tree this_expr = TREE_OPERAND (current_object, 0);\n+\n+      if (operand_equal_p (t, this_expr))\n+\t{\n+\t  data->this_expr_accessed = true;\n+\t  *walk_subtrees = 0;\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (TREE_CODE (t) == COMPONENT_REF\n+\t  && POINTER_TYPE_P (TREE_TYPE (t))\n+\t  && operand_equal_p (TREE_OPERAND (t, 0), current_object)\n+\t  && TREE_CODE (TREE_OPERAND (t, 1)) == FIELD_DECL)\n+\t{\n+\t  data->this_expr_accessed = true;\n+\t  tree fld = TREE_OPERAND (t, 1);\n+\t  if (data->ptr_members_accessed.get (fld) == NULL)\n+\t    {\n+\t      if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n+\t\tt = convert_from_reference (t);\n+\t      data->ptr_members_accessed.put (fld, t);\n+\t    }\n+\t  *walk_subtrees = 0;\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  /* When the current_function_decl is a lambda function, the closure object\n+     argument's type seems to not yet have fields layed out, so a recording\n+     of DECL_VALUE_EXPRs during the target body walk seems the only way to\n+     find them.  */\n+  if (current_closure\n+      && (TREE_CODE (t) == VAR_DECL\n+\t  || TREE_CODE (t) == PARM_DECL\n+\t  || TREE_CODE (t) == RESULT_DECL)\n+      && DECL_HAS_VALUE_EXPR_P (t)\n+      && TREE_CODE (DECL_VALUE_EXPR (t)) == COMPONENT_REF\n+      && operand_equal_p (current_closure,\n+\t\t\t  TREE_OPERAND (DECL_VALUE_EXPR (t), 0)))\n+    {\n+      if (!data->closure_vars_accessed.contains (t))\n+\tdata->closure_vars_accessed.add (t);\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (t) == BIND_EXPR)\n+    {\n+      tree block = BIND_EXPR_BLOCK (t);\n+      for (tree var = BLOCK_VARS (block); var; var = DECL_CHAIN (var))\n+\tif (!data->local_decls.contains (var))\n+\t  data->local_decls.add (var);\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_TYPE (t) && LAMBDA_TYPE_P (TREE_TYPE (t)))\n+    {\n+      tree lt = TREE_TYPE (t);\n+      gcc_assert (CLASS_TYPE_P (lt));\n+\n+      if (!data->lambda_objects_accessed.contains (t)\n+\t  /* Do not prepare to create target maps for locally declared\n+\t     lambdas or anonymous ones.  */\n+\t  && !data->local_decls.contains (t)\n+\t  && TREE_CODE (t) != TARGET_EXPR)\n+\tdata->lambda_objects_accessed.add (t);\n+      *walk_subtrees = 0;\n+      return NULL_TREE;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Helper function for finish_omp_target, and also from tsubst_expr.\n+   Create additional clauses for mapping of non-static members, lambda objects,\n+   etc.  */\n+\n+void\n+finish_omp_target_clauses (location_t loc, tree body, tree *clauses_ptr)\n+{\n+  omp_target_walk_data data;\n+  data.this_expr_accessed = false;\n+\n+  tree ct = current_nonlambda_class_type ();\n+  if (ct)\n+    {\n+      tree object = maybe_dummy_object (ct, NULL);\n+      object = maybe_resolve_dummy (object, true);\n+      data.current_object = object;\n+    }\n+  else\n+    data.current_object = NULL_TREE;\n+\n+  if (DECL_LAMBDA_FUNCTION_P (current_function_decl))\n+    {\n+      tree closure = DECL_ARGUMENTS (current_function_decl);\n+      data.current_closure = build_indirect_ref (loc, closure, RO_UNARY_STAR);\n+    }\n+  else\n+    data.current_closure = NULL_TREE;\n+\n+  cp_walk_tree_without_duplicates (&body, finish_omp_target_clauses_r, &data);\n+\n+  auto_vec<tree, 16> new_clauses;\n+\n+  tree omp_target_this_expr = NULL_TREE;\n+  tree *explicit_this_deref_map = NULL;\n+  if (data.this_expr_accessed)\n+    {\n+      omp_target_this_expr = TREE_OPERAND (data.current_object, 0);\n+\n+      /* See if explicit user-specified map(this[:]) clause already exists.\n+\t If not, we create an implicit map(tofrom:this[:1]) clause.  */\n+      for (tree *cp = clauses_ptr; *cp; cp = &OMP_CLAUSE_CHAIN (*cp))\n+\tif (OMP_CLAUSE_CODE (*cp) == OMP_CLAUSE_MAP\n+\t    && (TREE_CODE (OMP_CLAUSE_DECL (*cp)) == INDIRECT_REF\n+\t\t|| TREE_CODE (OMP_CLAUSE_DECL (*cp)) == MEM_REF)\n+\t    && operand_equal_p (TREE_OPERAND (OMP_CLAUSE_DECL (*cp), 0),\n+\t\t\t\tomp_target_this_expr))\n+\t  {\n+\t    explicit_this_deref_map = cp;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (DECL_LAMBDA_FUNCTION_P (current_function_decl)\n+      && (data.this_expr_accessed\n+\t  || !data.closure_vars_accessed.is_empty ()))\n+    {\n+      /* For lambda functions, we need to first create a copy of the\n+\t __closure object.  */\n+      tree closure = DECL_ARGUMENTS (current_function_decl);\n+      tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_TO);\n+      OMP_CLAUSE_DECL (c)\n+\t= build_indirect_ref (loc, closure, RO_UNARY_STAR);\n+      OMP_CLAUSE_SIZE (c)\n+\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (closure)));\n+      new_clauses.safe_push (c);\n+\n+      tree closure_obj = OMP_CLAUSE_DECL (c);\n+      tree closure_type = TREE_TYPE (closure_obj);\n+\n+      gcc_assert (LAMBDA_TYPE_P (closure_type)\n+\t\t  && CLASS_TYPE_P (closure_type));\n+\n+      tree c2 = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (c2, GOMP_MAP_FIRSTPRIVATE_POINTER);\n+      OMP_CLAUSE_DECL (c2) = closure;\n+      OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+      new_clauses.safe_push (c2);\n+    }\n+\n+  if (data.this_expr_accessed)\n+    {\n+      /* If the this-expr was accessed, create a map(*this) clause.  */\n+      enum gomp_map_kind kind = GOMP_MAP_TOFROM;\n+      if (explicit_this_deref_map)\n+\t{\n+\t  tree this_map = *explicit_this_deref_map;\n+\t  tree nc = OMP_CLAUSE_CHAIN (this_map);\n+\t  gcc_assert (nc != NULL_TREE\n+\t\t      && OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n+\t\t      && (OMP_CLAUSE_MAP_KIND (nc)\n+\t\t\t  == GOMP_MAP_FIRSTPRIVATE_POINTER));\n+\t  kind = OMP_CLAUSE_MAP_KIND (this_map);\n+\t  /* Remove the original 'map(*this) map(firstprivate_ptr:this)'\n+\t     two-map sequence away from the chain.  */\n+\t  *explicit_this_deref_map = OMP_CLAUSE_CHAIN (nc);\n+\t}\n+      tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (c, kind);\n+      OMP_CLAUSE_DECL (c)\n+\t= build_indirect_ref (loc, omp_target_this_expr, RO_UNARY_STAR);\n+      OMP_CLAUSE_SIZE (c)\n+\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (omp_target_this_expr)));\n+      new_clauses.safe_push (c);\n+\n+      /* If we're in a lambda function, the this-pointer will actually be\n+\t '__closure->this', a mapped member of __closure, hence always_pointer.\n+\t Otherwise it's a firstprivate pointer.  */\n+      enum gomp_map_kind ptr_kind\n+\t= (DECL_LAMBDA_FUNCTION_P (current_function_decl)\n+\t   ? GOMP_MAP_ALWAYS_POINTER\n+\t   : GOMP_MAP_FIRSTPRIVATE_POINTER);\n+      c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (c, ptr_kind);\n+      OMP_CLAUSE_DECL (c) = omp_target_this_expr;\n+      OMP_CLAUSE_SIZE (c) = size_zero_node;\n+      new_clauses.safe_push (c);\n+    }\n+\n+  if (DECL_LAMBDA_FUNCTION_P (current_function_decl))\n+    {\n+      if (omp_target_this_expr)\n+\t{\n+\t  STRIP_NOPS (omp_target_this_expr);\n+\t  gcc_assert (DECL_HAS_VALUE_EXPR_P (omp_target_this_expr));\n+\t  omp_target_this_expr = DECL_VALUE_EXPR (omp_target_this_expr);\n+\t}\n+\n+      for (hash_set<tree>::iterator i = data.closure_vars_accessed.begin ();\n+\t   i != data.closure_vars_accessed.end (); ++i)\n+\t{\n+\t  tree orig_decl = *i;\n+\t  tree closure_expr = DECL_VALUE_EXPR (orig_decl);\n+\n+\t  if (TREE_CODE (TREE_TYPE (orig_decl)) == POINTER_TYPE\n+\t      || TREE_CODE (TREE_TYPE (orig_decl)) == REFERENCE_TYPE)\n+\t    {\n+\t      /* this-pointer is processed above, outside this loop.  */\n+\t      if (omp_target_this_expr\n+\t\t  && operand_equal_p (closure_expr, omp_target_this_expr))\n+\t\tcontinue;\n+\n+\t      bool ptr_p = TREE_CODE (TREE_TYPE (orig_decl)) == POINTER_TYPE;\n+\t      enum gomp_map_kind kind, ptr_kind, nc_kind;\n+\t      tree size;\n+\n+\t      if (ptr_p)\n+\t\t{\n+\t\t  /* For pointers, default mapped as zero-length array\n+\t\t     section.  */\n+\t\t  kind = GOMP_MAP_ALLOC;\n+\t\t  nc_kind = GOMP_MAP_FIRSTPRIVATE_POINTER;\n+\t\t  ptr_kind = GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION;\n+\t\t  size = size_zero_node;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* For references, default mapped as appearing on map\n+\t\t     clause.  */\n+\t\t  kind = GOMP_MAP_TOFROM;\n+\t\t  nc_kind = GOMP_MAP_FIRSTPRIVATE_REFERENCE;\n+\t\t  ptr_kind = GOMP_MAP_ALWAYS_POINTER;\n+\t\t  size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (closure_expr)));\n+\t\t}\n+\n+\t      for (tree *p = clauses_ptr; *p; p = &OMP_CLAUSE_CHAIN (*p))\n+\t\tif (OMP_CLAUSE_CODE (*p) == OMP_CLAUSE_MAP\n+\t\t    && (TREE_CODE (OMP_CLAUSE_DECL (*p)) == INDIRECT_REF\n+\t\t\t|| TREE_CODE (OMP_CLAUSE_DECL (*p)) == MEM_REF)\n+\t\t    && operand_equal_p (TREE_OPERAND (OMP_CLAUSE_DECL (*p), 0),\n+\t\t\t\t\torig_decl))\n+\t\t  {\n+\t\t    /* If this was already specified by user as a map,\n+\t\t       save the user specified map kind, delete the\n+\t\t       \"map(*ptr/ref), map(firstprivate ptr/ref)\" sequence,\n+\t\t       and insert our own sequence:\n+\t\t       \"map(*__closure->ptr/ref), map(<ptr_kind>:__closure->ref\"\n+\t\t    */\n+\t\t    tree nc = OMP_CLAUSE_CHAIN (*p);\n+\t\t    gcc_assert (nc != NULL_TREE\n+\t\t\t\t&& OMP_CLAUSE_CODE (nc) == OMP_CLAUSE_MAP\n+\t\t\t\t&& OMP_CLAUSE_MAP_KIND (nc) == nc_kind);\n+\t\t    /* Update with user specified kind and size.  */\n+\t\t    kind = OMP_CLAUSE_MAP_KIND (*p);\n+\t\t    size = OMP_CLAUSE_SIZE (*p);\n+\t\t    *p = OMP_CLAUSE_CHAIN (nc);\n+\t\t    break;\n+\t\t  }\n+\n+\t      tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, kind);\n+\t      OMP_CLAUSE_DECL (c)\n+\t\t= build_indirect_ref (loc, closure_expr, RO_UNARY_STAR);\n+\t      OMP_CLAUSE_SIZE (c) = size;\n+\t      if (ptr_p)\n+\t\tOMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\t      new_clauses.safe_push (c);\n+\n+\t      c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, ptr_kind);\n+\t      OMP_CLAUSE_DECL (c) = closure_expr;\n+\t      OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t      new_clauses.safe_push (c);\n+\t    }\n+\t}\n+    }\n+\n+  if (!data.ptr_members_accessed.is_empty ())\n+    for (hash_map<tree, tree>::iterator i = data.ptr_members_accessed.begin ();\n+\t i != data.ptr_members_accessed.end (); ++i)\n+      {\n+\t/* For each referenced member that is of pointer or reference-to-pointer\n+\t   type, create the equivalent of map(alloc:this->ptr[:0]).  */\n+\ttree field_decl = (*i).first;\n+\ttree ptr_member = (*i).second;\n+\n+\tfor (tree c = *clauses_ptr; c; c = OMP_CLAUSE_CHAIN (c))\n+\t  {\n+\t    /* If map(this->ptr[:N] already exists, avoid creating another\n+\t       such map.  */\n+\t    tree decl = OMP_CLAUSE_DECL (c);\n+\t    if ((TREE_CODE (decl) == INDIRECT_REF\n+\t\t || TREE_CODE (decl) == MEM_REF)\n+\t\t&& operand_equal_p (TREE_OPERAND (decl, 0), ptr_member))\n+\t      goto next_ptr_member;\n+\t  }\n+\n+\tif (!cxx_mark_addressable (ptr_member))\n+\t  gcc_unreachable ();\n+\n+\tif (TREE_CODE (TREE_TYPE (field_decl)) == REFERENCE_TYPE)\n+\t  {\n+\t    /* For reference to pointers, we need to map the referenced\n+\t       pointer first for things to be correct.  */\n+\t    tree ptr_member_type = TREE_TYPE (ptr_member);\n+\n+\t    /* Map pointer target as zero-length array section.  */\n+\t    tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t    OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALLOC);\n+\t    OMP_CLAUSE_DECL (c)\n+\t      = build1 (INDIRECT_REF, TREE_TYPE (ptr_member_type), ptr_member);\n+\t    OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t    OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\n+\t    /* Map pointer to zero-length array section.  */\n+\t    tree c2 = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t    OMP_CLAUSE_SET_MAP_KIND\n+\t      (c2, GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION);\n+\t    OMP_CLAUSE_DECL (c2) = ptr_member;\n+\t    OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\n+\t    /* Attach reference-to-pointer field to pointer.  */\n+\t    tree c3 = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t    OMP_CLAUSE_SET_MAP_KIND (c3, GOMP_MAP_ATTACH);\n+\t    OMP_CLAUSE_DECL (c3) = TREE_OPERAND (ptr_member, 0);\n+\t    OMP_CLAUSE_SIZE (c3) = size_zero_node;\n+\n+\t    new_clauses.safe_push (c);\n+\t    new_clauses.safe_push (c2);\n+\t    new_clauses.safe_push (c3);\n+\t  }\n+\telse if (TREE_CODE (TREE_TYPE (field_decl)) == POINTER_TYPE)\n+\t  {\n+\t    /* Map pointer target as zero-length array section.  */\n+\t    tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t    OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALLOC);\n+\t    OMP_CLAUSE_DECL (c) = build_indirect_ref (loc, ptr_member,\n+\t\t\t\t\t\t      RO_UNARY_STAR);\n+\t    OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t    OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\n+\t    /* Attach zero-length array section to pointer.  */\n+\t    tree c2 = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t    OMP_CLAUSE_SET_MAP_KIND\n+\t      (c2, GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION);\n+\t    OMP_CLAUSE_DECL (c2) = ptr_member;\n+\t    OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\n+\t    new_clauses.safe_push (c);\n+\t    new_clauses.safe_push (c2);\n+\t  }\n+\telse\n+\t  gcc_unreachable ();\n+\n+      next_ptr_member:\n+\t;\n+      }\n+\n+  for (hash_set<tree>::iterator i = data.lambda_objects_accessed.begin ();\n+       i != data.lambda_objects_accessed.end (); ++i)\n+    {\n+      tree lobj = *i;\n+      if (TREE_CODE (lobj) == TARGET_EXPR)\n+\tlobj = TREE_OPERAND (lobj, 0);\n+\n+      tree lt = TREE_TYPE (lobj);\n+      gcc_assert (LAMBDA_TYPE_P (lt) && CLASS_TYPE_P (lt));\n+\n+      tree lc = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+      OMP_CLAUSE_SET_MAP_KIND (lc, GOMP_MAP_TO);\n+      OMP_CLAUSE_DECL (lc) = lobj;\n+      OMP_CLAUSE_SIZE (lc) = TYPE_SIZE_UNIT (lt);\n+      new_clauses.safe_push (lc);\n+\n+      for (tree fld = TYPE_FIELDS (lt); fld; fld = DECL_CHAIN (fld))\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (fld)) == POINTER_TYPE)\n+\t    {\n+\t      tree exp = build3 (COMPONENT_REF, TREE_TYPE (fld),\n+\t\t\t\t lobj, fld, NULL_TREE);\n+\t      tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALLOC);\n+\t      OMP_CLAUSE_DECL (c)\n+\t\t= build_indirect_ref (loc, exp, RO_UNARY_STAR);\n+\t      OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t      OMP_CLAUSE_MAP_MAYBE_ZERO_LENGTH_ARRAY_SECTION (c) = 1;\n+\t      new_clauses.safe_push (c);\n+\n+\t      c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND\n+\t\t(c, GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION);\n+\t      OMP_CLAUSE_DECL (c) = exp;\n+\t      OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t      new_clauses.safe_push (c);\n+\t    }\n+\t  else if (TREE_CODE (TREE_TYPE (fld)) == REFERENCE_TYPE)\n+\t    {\n+\t      tree exp = build3 (COMPONENT_REF, TREE_TYPE (fld),\n+\t\t\t\t lobj, fld, NULL_TREE);\n+\t      tree c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_TOFROM);\n+\t      OMP_CLAUSE_DECL (c)\n+\t\t= build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (exp)), exp);\n+\t      OMP_CLAUSE_SIZE (c)\n+\t\t= TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (exp)));\n+\t      new_clauses.safe_push (c);\n+\n+\t      c = build_omp_clause (loc, OMP_CLAUSE_MAP);\n+\t      OMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALWAYS_POINTER);\n+\t      OMP_CLAUSE_DECL (c) = exp;\n+\t      OMP_CLAUSE_SIZE (c) = size_zero_node;\n+\t      new_clauses.safe_push (c);\n+\t    }\n+\t}\n+    }\n+\n+  tree c = *clauses_ptr;\n+  for (int i = new_clauses.length () - 1; i >= 0; i--)\n+    {\n+      OMP_CLAUSE_CHAIN (new_clauses[i]) = c;\n+      c = new_clauses[i];\n+    }\n+  *clauses_ptr = c;\n+}\n+\n+/* Called from cp_parser_omp_target.  Create additional implicit clauses for\n+   OpenMP target directives, and do sanity checks.  */\n+\n+tree\n+finish_omp_target (location_t loc, tree clauses, tree body, bool combined_p)\n+{\n+  if (!processing_template_decl)\n+    finish_omp_target_clauses (loc, body, &clauses);\n+\n+  tree stmt = make_node (OMP_TARGET);\n+  TREE_TYPE (stmt) = void_type_node;\n+  OMP_TARGET_CLAUSES (stmt) = clauses;\n+  OMP_TARGET_BODY (stmt) = body;\n+  OMP_TARGET_COMBINED (stmt) = combined_p;\n+  SET_EXPR_LOCATION (stmt, loc);\n+\n+  tree c = clauses;\n+  while (c)\n+    {\n+      if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_MAP)\n+\tswitch (OMP_CLAUSE_MAP_KIND (c))\n+\t  {\n+\t  case GOMP_MAP_TO:\n+\t  case GOMP_MAP_ALWAYS_TO:\n+\t  case GOMP_MAP_FROM:\n+\t  case GOMP_MAP_ALWAYS_FROM:\n+\t  case GOMP_MAP_TOFROM:\n+\t  case GOMP_MAP_ALWAYS_TOFROM:\n+\t  case GOMP_MAP_ALLOC:\n+\t  case GOMP_MAP_FIRSTPRIVATE_POINTER:\n+\t  case GOMP_MAP_FIRSTPRIVATE_REFERENCE:\n+\t  case GOMP_MAP_ALWAYS_POINTER:\n+\t  case GOMP_MAP_ATTACH_DETACH:\n+\t  case GOMP_MAP_ATTACH:\n+\t  case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+\t  case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+\t    break;\n+\t  default:\n+\t    error_at (OMP_CLAUSE_LOCATION (c),\n+\t\t      \"%<#pragma omp target%> with map-type other \"\n+\t\t      \"than %<to%>, %<from%>, %<tofrom%> or %<alloc%> \"\n+\t\t      \"on %<map%> clause\");\n+\t    break;\n+\t  }\n+      c = OMP_CLAUSE_CHAIN (c);\n+    }\n+  return add_stmt (stmt);\n+}\n+\n tree\n finish_omp_parallel (tree clauses, tree body)\n {"}, {"sha": "0a55bf71c67775aafe30f2f675033fc1a515fa19", "filename": "gcc/gimplify.c", "status": "modified", "additions": 108, "deletions": 17, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"langhooks.h\"\n #include \"tree-cfg.h\"\n #include \"tree-ssa.h\"\n+#include \"tree-hash-traits.h\"\n #include \"omp-general.h\"\n #include \"omp-low.h\"\n #include \"gimple-low.h\"\n@@ -8921,7 +8922,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n {\n   struct gimplify_omp_ctx *ctx, *outer_ctx;\n   tree c;\n-  hash_map<tree, tree> *struct_map_to_clause = NULL;\n+  hash_map<tree_operand_hash, tree> *struct_map_to_clause = NULL;\n   hash_set<tree> *struct_deref_set = NULL;\n   tree *prev_list_p = NULL, *orig_list_p = list_p;\n   int handled_depend_iterators = -1;\n@@ -9365,7 +9366,14 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t\t  GOVD_FIRSTPRIVATE | GOVD_SEEN);\n \t    }\n \n-\t  if (!DECL_P (decl))\n+\t  if (TREE_CODE (decl) == TARGET_EXPR)\n+\t    {\n+\t      if (gimplify_expr (&OMP_CLAUSE_DECL (c), pre_p, NULL,\n+\t\t\t\t is_gimple_lvalue, fb_lvalue)\n+\t\t  == GS_ERROR)\n+\t\tremove = true;\n+\t    }\n+\t  else if (!DECL_P (decl))\n \t    {\n \t      tree d = decl, *pd;\n \t      if (TREE_CODE (d) == ARRAY_REF)\n@@ -9381,12 +9389,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  && TREE_CODE (decl) == INDIRECT_REF\n \t\t  && TREE_CODE (TREE_OPERAND (decl, 0)) == COMPONENT_REF\n \t\t  && (TREE_CODE (TREE_TYPE (TREE_OPERAND (decl, 0)))\n-\t\t      == REFERENCE_TYPE))\n+\t\t      == REFERENCE_TYPE)\n+\t\t  && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t      != GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION))\n \t\t{\n \t\t  pd = &TREE_OPERAND (decl, 0);\n \t\t  decl = TREE_OPERAND (decl, 0);\n \t\t}\n \t      bool indir_p = false;\n+\t      bool component_ref_p = false;\n \t      tree orig_decl = decl;\n \t      tree decl_ref = NULL_TREE;\n \t      if ((region_type & (ORT_ACC | ORT_TARGET | ORT_TARGET_DATA)) != 0\n@@ -9397,6 +9408,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n \t\t    {\n \t\t      decl = TREE_OPERAND (decl, 0);\n+\t\t      component_ref_p = true;\n \t\t      if (((TREE_CODE (decl) == MEM_REF\n \t\t\t    && integer_zerop (TREE_OPERAND (decl, 1)))\n \t\t\t   || INDIRECT_REF_P (decl))\n@@ -9405,6 +9417,7 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t{\n \t\t\t  indir_p = true;\n \t\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t\t  STRIP_NOPS (decl);\n \t\t\t}\n \t\t      if (TREE_CODE (decl) == INDIRECT_REF\n \t\t\t  && DECL_P (TREE_OPERAND (decl, 0))\n@@ -9416,8 +9429,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t}\n \t\t    }\n \t\t}\n-\t      else if (TREE_CODE (decl) == COMPONENT_REF)\n+\t      else if (TREE_CODE (decl) == COMPONENT_REF\n+\t\t       && (OMP_CLAUSE_MAP_KIND (c)\n+\t\t\t   != GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION))\n \t\t{\n+\t\t  component_ref_p = true;\n \t\t  while (TREE_CODE (decl) == COMPONENT_REF)\n \t\t    decl = TREE_OPERAND (decl, 0);\n \t\t  if (TREE_CODE (decl) == INDIRECT_REF\n@@ -9487,7 +9503,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t      if (code == OACC_UPDATE\n \t\t  && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ATTACH_DETACH)\n \t\tOMP_CLAUSE_SET_MAP_KIND (c, GOMP_MAP_ALWAYS_POINTER);\n-\t      if (DECL_P (decl)\n+\t      if ((DECL_P (decl)\n+\t\t   || (component_ref_p\n+\t\t       && (INDIRECT_REF_P (decl)\n+\t\t\t   || TREE_CODE (decl) == MEM_REF)))\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_TO_PSET\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_DETACH\n@@ -9544,7 +9563,10 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  gcc_assert (base == decl);\n \n \t\t  splay_tree_node n\n-\t\t    = splay_tree_lookup (ctx->variables, (splay_tree_key)decl);\n+\t\t    = (DECL_P (decl)\n+\t\t       ? splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t    (splay_tree_key) decl)\n+\t\t       : NULL);\n \t\t  bool ptr = (OMP_CLAUSE_MAP_KIND (c)\n \t\t\t      == GOMP_MAP_ALWAYS_POINTER);\n \t\t  bool attach_detach = (OMP_CLAUSE_MAP_KIND (c)\n@@ -9570,7 +9592,11 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      OMP_CLAUSE_SET_MAP_KIND (c, k);\n \t\t      has_attachments = true;\n \t\t    }\n-\t\t  if (n == NULL || (n->value & GOVD_MAP) == 0)\n+\t\t  if ((DECL_P (decl)\n+\t\t       && (n == NULL || (n->value & GOVD_MAP) == 0))\n+\t\t      || (!DECL_P (decl)\n+\t\t\t  && (!struct_map_to_clause\n+\t\t\t      || struct_map_to_clause->get (decl) == NULL)))\n \t\t    {\n \t\t      tree l = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n \t\t\t\t\t\t OMP_CLAUSE_MAP);\n@@ -9581,15 +9607,27 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t      if (base_ref)\n \t\t\tOMP_CLAUSE_DECL (l) = unshare_expr (base_ref);\n \t\t      else\n-\t\t\tOMP_CLAUSE_DECL (l) = decl;\n+\t\t\t{\n+\t\t\t  OMP_CLAUSE_DECL (l) = unshare_expr (decl);\n+\t\t\t  if (!DECL_P (OMP_CLAUSE_DECL (l))\n+\t\t\t      && (gimplify_expr (&OMP_CLAUSE_DECL (l),\n+\t\t\t\t\t\t pre_p, NULL, is_gimple_lvalue,\n+\t\t\t\t\t\t fb_lvalue)\n+\t\t\t\t  == GS_ERROR))\n+\t\t\t    {\n+\t\t\t      remove = true;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t}\n \t\t      OMP_CLAUSE_SIZE (l)\n \t\t\t= (!attach\n \t\t\t   ? size_int (1)\n \t\t\t   : DECL_P (OMP_CLAUSE_DECL (l))\n \t\t\t   ? DECL_SIZE_UNIT (OMP_CLAUSE_DECL (l))\n \t\t\t   : TYPE_SIZE_UNIT (TREE_TYPE (OMP_CLAUSE_DECL (l))));\n \t\t      if (struct_map_to_clause == NULL)\n-\t\t\tstruct_map_to_clause = new hash_map<tree, tree>;\n+\t\t\tstruct_map_to_clause\n+\t\t\t  = new hash_map<tree_operand_hash, tree>;\n \t\t      struct_map_to_clause->put (decl, l);\n \t\t      if (ptr || attach_detach)\n \t\t\t{\n@@ -9623,15 +9661,41 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\tflags |= GOVD_SEEN;\n \t\t      if (has_attachments)\n \t\t\tflags |= GOVD_MAP_HAS_ATTACHMENTS;\n-\t\t      goto do_add_decl;\n+\n+\t\t      /* If this is a *pointer-to-struct expression, make sure a\n+\t\t\t firstprivate map of the base-pointer exists.  */\n+\t\t      if (component_ref_p\n+\t\t\t  && ((TREE_CODE (decl) == MEM_REF\n+\t\t\t       && integer_zerop (TREE_OPERAND (decl, 1)))\n+\t\t\t      || INDIRECT_REF_P (decl))\n+\t\t\t  && DECL_P (TREE_OPERAND (decl, 0))\n+\t\t\t  && !splay_tree_lookup (ctx->variables,\n+\t\t\t\t\t\t ((splay_tree_key)\n+\t\t\t\t\t\t  TREE_OPERAND (decl, 0))))\n+\t\t\t{\n+\t\t\t  decl = TREE_OPERAND (decl, 0);\n+\t\t\t  tree c2 = build_omp_clause (OMP_CLAUSE_LOCATION (c),\n+\t\t\t\t\t\t      OMP_CLAUSE_MAP);\n+\t\t\t  enum gomp_map_kind mkind\n+\t\t\t    = GOMP_MAP_FIRSTPRIVATE_POINTER;\n+\t\t\t  OMP_CLAUSE_SET_MAP_KIND (c2, mkind);\n+\t\t\t  OMP_CLAUSE_DECL (c2) = decl;\n+\t\t\t  OMP_CLAUSE_SIZE (c2) = size_zero_node;\n+\t\t\t  OMP_CLAUSE_CHAIN (c2) = OMP_CLAUSE_CHAIN (c);\n+\t\t\t  OMP_CLAUSE_CHAIN (c) = c2;\n+\t\t\t}\n+\n+\t\t      if (DECL_P (decl))\n+\t\t\tgoto do_add_decl;\n \t\t    }\n \t\t  else if (struct_map_to_clause)\n \t\t    {\n \t\t      tree *osc = struct_map_to_clause->get (decl);\n \t\t      tree *sc = NULL, *scp = NULL;\n-\t\t      if (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n-\t\t\t  || ptr\n-\t\t\t  || attach_detach)\n+\t\t      if (n != NULL\n+\t\t\t  && (GOMP_MAP_ALWAYS_P (OMP_CLAUSE_MAP_KIND (c))\n+\t\t\t      || ptr\n+\t\t\t      || attach_detach))\n \t\t\tn->value |= GOVD_SEEN;\n \t\t      sc = &OMP_CLAUSE_CHAIN (*osc);\n \t\t      if (*sc != c\n@@ -9732,6 +9796,13 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t\t}\n \t\t      else if (*sc != c)\n \t\t\t{\n+\t\t\t  if (gimplify_expr (pd, pre_p, NULL, is_gimple_lvalue,\n+\t\t\t\t\t     fb_lvalue)\n+\t\t\t      == GS_ERROR)\n+\t\t\t    {\n+\t\t\t      remove = true;\n+\t\t\t      break;\n+\t\t\t    }\n \t\t\t  *list_p = OMP_CLAUSE_CHAIN (c);\n \t\t\t  OMP_CLAUSE_CHAIN (c) = *sc;\n \t\t\t  *sc = c;\n@@ -9867,6 +9938,24 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t  break;\n \t\t}\n \n+\t      /* If this was of the form map(*pointer_to_struct), then the\n+\t\t 'pointer_to_struct' DECL should be considered deref'ed.  */\n+\t      if ((OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_ALLOC\n+\t\t   || GOMP_MAP_COPY_TO_P (OMP_CLAUSE_MAP_KIND (c))\n+\t\t   || GOMP_MAP_COPY_FROM_P (OMP_CLAUSE_MAP_KIND (c)))\n+\t\t  && INDIRECT_REF_P (orig_decl)\n+\t\t  && DECL_P (TREE_OPERAND (orig_decl, 0))\n+\t\t  && TREE_CODE (TREE_TYPE (orig_decl)) == RECORD_TYPE)\n+\t\t{\n+\t\t  tree ptr = TREE_OPERAND (orig_decl, 0);\n+\t\t  if (!struct_deref_set || !struct_deref_set->contains (ptr))\n+\t\t    {\n+\t\t      if (!struct_deref_set)\n+\t\t\tstruct_deref_set = new hash_set<tree> ();\n+\t\t      struct_deref_set->add (ptr);\n+\t\t    }\n+\t\t}\n+\n \t      if (!remove\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ALWAYS_POINTER\n \t\t  && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_ATTACH_DETACH\n@@ -11216,6 +11305,12 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t\t    }\n \t\t}\n \t    }\n+\t  if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT\n+\t      && (code == OMP_TARGET_EXIT_DATA || code == OACC_EXIT_DATA))\n+\t    {\n+\t      remove = true;\n+\t      break;\n+\t    }\n \t  if (!DECL_P (decl))\n \t    {\n \t      if ((ctx->region_type & ORT_TARGET) != 0\n@@ -11262,10 +11357,6 @@ gimplify_adjust_omp_clauses (gimple_seq *pre_p, gimple_seq body, tree *list_p,\n \t\t      = OMP_CLAUSE_CHAIN (OMP_CLAUSE_CHAIN (c));\n \t\t}\n \t    }\n-\t  else if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_STRUCT\n-\t\t   && (code == OMP_TARGET_EXIT_DATA\n-\t\t       || code == OACC_EXIT_DATA))\n-\t    remove = true;\n \t  else if (DECL_SIZE (decl)\n \t\t   && TREE_CODE (DECL_SIZE (decl)) != INTEGER_CST\n \t\t   && OMP_CLAUSE_MAP_KIND (c) != GOMP_MAP_POINTER"}, {"sha": "2a07beb4eaf5514cb454c575da0c03f9b10eb7d3", "filename": "gcc/omp-low.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -12635,6 +12635,8 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n \t  case GOMP_MAP_ALWAYS_POINTER:\n \t  case GOMP_MAP_ATTACH:\n \t  case GOMP_MAP_DETACH:\n+\t  case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+\t  case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n \t    break;\n \t  case GOMP_MAP_IF_PRESENT:\n \t  case GOMP_MAP_FORCE_ALLOC:"}, {"sha": "f4d40ec8e4b9bc3c7c2053dae504beb54938c565", "filename": "gcc/testsuite/g++.dg/gomp/target-3.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-3.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do compile }\n+// { dg-options \"-fopenmp -fdump-tree-gimple\" }\n+\n+struct S\n+{\n+  int a, b;\n+  void bar (int);\n+};\n+\n+void\n+S::bar (int x)\n+{\n+  #pragma omp target map (alloc: a, b)\n+    ;\n+  #pragma omp target enter data map (alloc: a, b)\n+}\n+\n+template <int N>\n+struct T\n+{\n+  int a, b;\n+  void bar (int);\n+};\n+\n+template <int N>\n+void\n+T<N>::bar (int x)\n+{\n+  #pragma omp target map (alloc: a, b)\n+    ;\n+  #pragma omp target enter data map (alloc: a, b)\n+}\n+\n+template struct T<0>;\n+\n+/* { dg-final { scan-tree-dump-times \"map\\\\(struct:\\\\*this \\\\\\[len: 2\\\\\\]\\\\) map\\\\(alloc:this->a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:this->b \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" 4 \"gimple\" } } */"}, {"sha": "7f83f92ec93900ab0d174cfd2c7b3739067ccf9b", "filename": "gcc/testsuite/g++.dg/gomp/target-lambda-1.C", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-1.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,94 @@\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-additional-options \"-std=c++14 -fdump-tree-gimple\" }\n+#include <cstdlib>\n+#include <cstring>\n+\n+template <typename L>\n+void\n+omp_target_loop (int begin, int end, L loop)\n+{\n+  #pragma omp target teams distribute parallel for\n+  for (int i = begin; i < end; i++)\n+    loop (i);\n+}\n+\n+struct S\n+{\n+  int a, len;\n+  int *ptr;\n+\n+  auto merge_data_func (int *iptr, int &b)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  mapped = (ptr != NULL && iptr != NULL);\n+\t  if (mapped)\n+\t    {\n+\t      for (int i = 0; i < len; i++)\n+\t\tptr[i] += a + b + iptr[i];\n+\t    }\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+};\n+\n+int x = 1;\n+\n+int main (void)\n+{\n+  const int N = 10;\n+  int *data1 = new int[N];\n+  int *data2 = new int[N];\n+  memset (data1, 0xab, sizeof (int) * N);\n+  memset (data1, 0xcd, sizeof (int) * N);\n+\n+  int val = 1;\n+  int &valref = val;\n+  #pragma omp target enter data map(alloc: data1[:N], data2[:N])\n+\n+  omp_target_loop (0, N, [=](int i) { data1[i] = val; });\n+  omp_target_loop (0, N, [=](int i) { data2[i] = valref + 1; });\n+\n+  #pragma omp target update from(data1[:N], data2[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      if (data1[i] != 1) abort ();\n+      if (data2[i] != 2) abort ();\n+    }\n+\n+  #pragma omp target exit data map(delete: data1[:N], data2[:N])\n+\n+  int b = 8;\n+  S s = { 4, N, data1 };\n+  auto f = s.merge_data_func (data2, b);\n+\n+  if (f ()) abort ();\n+\n+  #pragma omp target enter data map(to: data1[:N])\n+  if (f ()) abort ();\n+\n+  #pragma omp target enter data map(to: data2[:N])\n+  if (!f ()) abort ();\n+\n+  #pragma omp target exit data map(from: data1[:N], data2[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      if (data1[i] != 0xf) abort ();\n+      if (data2[i] != 2) abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(b\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:iptr \\[pointer assign, bias: 0\\]\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:__closure->__iptr \\[bias: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(attach_zero_length_array_section:loop\\.__data1 \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(end\\) firstprivate\\(begin\\) map\\(to:loop \\[len: [0-9]+\\]\\) map\\(attach_zero_length_array_section:loop\\.__data2 \\[bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */"}, {"sha": "bdf2564cd042d1f18ee184ee9597ddec958b6719", "filename": "gcc/testsuite/g++.dg/gomp/target-lambda-2.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-lambda-2.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,35 @@\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-additional-options \"-std=c++14 -fdump-tree-gimple\" }\n+#include <cstdlib>\n+\n+#define N 10\n+int main (void)\n+{\n+  int X, Y;\n+  #pragma omp target map(from: X, Y)\n+  {\n+    int x = 0, y = 0;\n+\n+    for (int i = 0; i < N; i++)\n+      [&] (int v) { x += v; } (i);\n+\n+    auto yinc = [&y] { y++; };\n+    for (int i = 0; i < N; i++)\n+      yinc ();\n+\n+    X = x;\n+    Y = y;\n+  }\n+\n+  int Xs = 0;\n+  for (int i = 0; i < N; i++)\n+    Xs += i;\n+  if (X != Xs)\n+    abort ();\n+\n+  if (Y != N)\n+    abort ();\n+}\n+\n+/* Make sure lambda objects do NOT appear in target maps.  */\n+/* { dg-final { scan-tree-dump {(?n)#pragma omp target num_teams.* map\\(from:Y \\[len: [0-9]+\\]\\) map\\(from:X \\[len: [0-9]+\\]\\)$} \"gimple\" } } */"}, {"sha": "de93a3e5e5798ec906f8a54f26a11baf99c486e6", "filename": "gcc/testsuite/g++.dg/gomp/target-this-1.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-1.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,33 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int a, b, c, d;\n+\n+  int sum (void)\n+  {\n+    int val = 0;\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+\n+  int sum_offload (void)\n+  {\n+    int val = 0;\n+    #pragma omp target map(val)\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+};\n+\n+int main (void)\n+{\n+  S s = { 1, 2, 3, 4 };\n+  if (s.sum () != s.sum_offload ())\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "8a76bb836f8af78814f0b0eac1ed7fa0bc432ab0", "filename": "gcc/testsuite/g++.dg/gomp/target-this-2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-2.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,49 @@\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-do compile }\n+// { dg-additional-options \"-std=c++14 -fdump-tree-gimple\" }\n+\n+extern \"C\" void abort ();\n+\n+struct T\n+{\n+  int x, y;\n+\n+  auto sum_func (int n)\n+  {\n+    auto fn = [=](int m) -> int\n+      {\n+\tint v;\n+\tv = (x + y) * n + m;\n+\treturn v;\n+      };\n+    return fn;\n+  }\n+\n+  auto sum_func_offload (int n)\n+  {\n+    auto fn = [=](int m) -> int\n+      {\n+\tint v;\n+\t#pragma omp target map(from:v)\n+\tv = (x + y) * n + m;\n+\treturn v;\n+      };\n+    return fn;\n+  }\n+\n+};\n+\n+int main (void)\n+{\n+  T a = { 1, 2 };\n+\n+  auto s1 = a.sum_func (3);\n+  auto s2 = a.sum_func_offload (3);\n+\n+  if (s1 (1) != s2 (1))\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(m\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(from:v \\[len: [0-9]+\\]\\)} \"gimple\" } } */"}, {"sha": "91cfbd6ef205f99e186045759e5cdedac9de735d", "filename": "gcc/testsuite/g++.dg/gomp/target-this-3.C", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-3.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,105 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+#include <cstdlib>\n+#include <cstring>\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int * ptr;\n+  int ptr_len;\n+\n+  int *&refptr;\n+  int refptr_len;\n+\n+  bool set_ptr (int n)\n+  {\n+    bool mapped;\n+    #pragma omp target map(from:mapped)\n+    {\n+      if (ptr != NULL)\n+\tfor (int i = 0; i < ptr_len; i++)\n+\t  ptr[i] = n;\n+      mapped = (ptr != NULL);\n+    }\n+    return mapped;\n+  }\n+\n+  bool set_refptr (int n)\n+  {\n+    bool mapped;\n+    #pragma omp target map(from:mapped)\n+    {\n+      if (refptr != NULL)\n+\tfor (int i = 0; i < refptr_len; i++)\n+\t  refptr[i] = n;\n+      mapped = (refptr != NULL);\n+    }\n+    return mapped;\n+  }\n+};\n+\n+int main (void)\n+{\n+  #define N 10\n+  int *ptr1 = new int[N];\n+  int *ptr2 = new int[N];\n+\n+  memset (ptr1, 0, sizeof (int) * N);\n+  memset (ptr2, 0, sizeof (int) * N);\n+\n+  S s = { ptr1, N, ptr2, N };\n+\n+  bool mapped;\n+  int val = 123;\n+\n+  mapped = s.set_ptr (val);\n+  if (mapped)\n+    abort ();\n+  if (s.ptr != ptr1)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 0)\n+      abort ();\n+\n+  mapped = s.set_refptr (val);\n+  if (mapped)\n+    abort ();\n+  if (s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 0)\n+      abort ();\n+\n+  #pragma omp target data map(ptr1[:N])\n+  mapped = s.set_ptr (val);\n+\n+  if (!mapped)\n+    abort ();\n+  if (s.set_refptr (0))\n+    abort ();\n+  if (s.ptr != ptr1 || s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != val)\n+      abort ();\n+\n+  #pragma omp target data map(ptr2[:N])\n+  mapped = s.set_refptr (val);\n+\n+  if (!mapped)\n+    abort ();\n+  if (s.set_ptr (0))\n+    abort ();\n+  if (s.ptr != ptr1 || s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != val)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:this->refptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) firstprivate\\(n\\) map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:this->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */"}, {"sha": "e4b2a71bbb4fffef1018ba028deb7c54c53187ef", "filename": "gcc/testsuite/g++.dg/gomp/target-this-4.C", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-4.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,107 @@\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-additional-options \"-std=c++14 -fdump-tree-gimple\" }\n+#include <cstdlib>\n+#include <cstring>\n+\n+struct T\n+{\n+  int *ptr;\n+  int ptr_len;\n+\n+  int *&refptr;\n+  int refptr_len;\n+\n+  auto set_ptr_func (int n)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  if (ptr)\n+\t    for (int i = 0; i < ptr_len; i++)\n+\t      ptr[i] = n;\n+\t  mapped = (ptr != NULL);\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+\n+  auto set_refptr_func (int n)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  if (refptr)\n+\t    for (int i = 0; i < refptr_len; i++)\n+\t      refptr[i] = n;\n+\t  mapped = (refptr != NULL);\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+};\n+\n+int main (void)\n+{\n+  #define N 10\n+  int *ptr1 = new int[N];\n+  int *ptr2 = new int[N];\n+\n+  memset (ptr1, 0, sizeof (int) * N);\n+  memset (ptr2, 0, sizeof (int) * N);\n+\n+  T a = { ptr1, N, ptr2, N };\n+\n+  auto p1 = a.set_ptr_func (1);\n+  auto r2 = a.set_refptr_func (2);\n+\n+  if (p1 ())\n+    abort ();\n+  if (r2 ())\n+    abort ();\n+\n+  if (a.ptr != ptr1)\n+    abort ();\n+  if (a.refptr != ptr2)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 0)\n+      abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 0)\n+      abort ();\n+\n+  #pragma omp target data map(ptr1[:N], ptr2[:N])\n+  {\n+    if (!p1 ())\n+      abort ();\n+    if (!r2 ())\n+      abort ();\n+  }\n+\n+  if (a.ptr != ptr1)\n+    abort ();\n+  if (a.refptr != ptr2)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 1)\n+      abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 2)\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(attach_zero_length_array_section:_[0-9]+->ptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */\n+\n+/* { dg-final { scan-tree-dump {#pragma omp target num_teams.* firstprivate\\(n\\) map\\(alloc:MEM.* \\[len: 0\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\) map\\(to:\\*__closure \\[len: [0-9]+\\]\\) map\\(firstprivate:__closure \\[pointer assign, bias: 0\\]\\) map\\(tofrom:\\*_[0-9]+ \\[len: [0-9]+\\]\\) map\\(always_pointer:__closure->__this \\[pointer assign, bias: 0\\]\\) map\\(alloc:\\*_[0-9]+ \\[pointer assign, zero-length array section, bias: 0\\]\\) map\\(attach:_[0-9]+->refptr \\[bias: 0\\]\\) map\\(from:mapped \\[len: [0-9]+\\]\\) map\\(alloc:\\*_[0-9]+ \\[len: 0\\]\\)} \"gimple\" } } */"}, {"sha": "a9ac74bcf1f8e647b10d8255d8b8f026253458aa", "filename": "gcc/testsuite/g++.dg/gomp/target-this-5.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Ftarget-this-5.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+// { dg-additional-options \"-fdump-tree-gimple\" }\n+extern \"C\" void abort ();\n+\n+template<typename T>\n+struct S\n+{\n+  T a, b, c, d;\n+\n+  T sum (void)\n+  {\n+    T val = 0;\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+\n+  T sum_offload (void)\n+  {\n+    T val = 0;\n+    #pragma omp target map(val)\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+};\n+\n+int main (void)\n+{\n+  S<int> s = { 1, 2, 3, 4 };\n+  if (s.sum () != s.sum_offload ())\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {map\\(tofrom:\\*this \\[len: [0-9]+\\]\\) map\\(firstprivate:this \\[pointer assign, bias: 0\\]\\)} \"gimple\" } } */"}, {"sha": "b521a4faf5e0f456720cef8da83eac550342d69b", "filename": "gcc/testsuite/g++.dg/gomp/this-2.C", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fthis-2.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -9,14 +9,14 @@ struct S\n void\n S::bar (int x)\n {\n-  #pragma omp target map (this, x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target map (this, x)\t\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n     ;\n-  #pragma omp target map (this[0], x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target map (this[0], x)\n     ;\n-  #pragma omp target update to (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update to (this[0], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update from (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update from (this[1], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update to (this, x)\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n+  #pragma omp target update to (this[0], x)\n+  #pragma omp target update from (this, x)\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n+  #pragma omp target update from (this[1], x)\n }\n \n template <int N>\n@@ -29,14 +29,14 @@ template <int N>\n void\n T<N>::bar (int x)\n {\n-  #pragma omp target map (this, x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target map (this, x)\t\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n     ;\n-  #pragma omp target map (this[0], x)\t\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target map (this[0], x)\n     ;\n-  #pragma omp target update to (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update to (this[0], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update from (this, x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n-  #pragma omp target update from (this[1], x)\t// { dg-error \".this. allowed in OpenMP only in .declare simd. clauses\" }\n+  #pragma omp target update to (this, x)\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n+  #pragma omp target update to (this[0], x)\n+  #pragma omp target update from (this, x)\t// { dg-error \"cannot take the address of .this., which is an rvalue expression\" }\n+  #pragma omp target update from (this[1], x)\n }\n \n template struct T<0>;"}, {"sha": "3e7921270c921697223bbd8518ef8cb506979358", "filename": "gcc/testsuite/gcc.dg/gomp/target-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Ftarget-3.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fopenmp -fdump-tree-gimple\" } */\n+\n+struct S\n+{\n+  int a, b;\n+};\n+\n+void foo (struct S *s)\n+{\n+  #pragma omp target map (alloc: s->a, s->b)\n+    ;\n+  #pragma omp target enter data map (alloc: s->a, s->b)\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"map\\\\(struct:\\\\*s \\\\\\[len: 2\\\\\\]\\\\) map\\\\(alloc:s->a \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:s->b \\\\\\[len: \\[0-9\\]+\\\\\\]\\\\)\" 2 \"gimple\" } } */"}, {"sha": "a81ba401ef91bb3b62dd953f64643aeccbec49a0", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -858,6 +858,7 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t{\n \tcase GOMP_MAP_ALLOC:\n \tcase GOMP_MAP_POINTER:\n+\tcase GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n \t  pp_string (pp, \"alloc\");\n \t  break;\n \tcase GOMP_MAP_IF_PRESENT:\n@@ -936,6 +937,9 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \tcase GOMP_MAP_ATTACH_DETACH:\n \t  pp_string (pp, \"attach_detach\");\n \t  break;\n+\tcase GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n+\t  pp_string (pp, \"attach_zero_length_array_section\");\n+\t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n@@ -954,13 +958,17 @@ dump_omp_clause (pretty_printer *pp, tree clause, int spc, dump_flags_t flags)\n \t    case GOMP_MAP_ALWAYS_POINTER:\n \t      pp_string (pp, \" [pointer assign, bias: \");\n \t      break;\n+\t    case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+\t      pp_string (pp, \" [pointer assign, zero-length array section, bias: \");\n+\t      break;\n \t    case GOMP_MAP_TO_PSET:\n \t      pp_string (pp, \" [pointer set, len: \");\n \t      break;\n \t    case GOMP_MAP_ATTACH:\n \t    case GOMP_MAP_DETACH:\n \t    case GOMP_MAP_FORCE_DETACH:\n \t    case GOMP_MAP_ATTACH_DETACH:\n+\t    case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n \t      pp_string (pp, \" [bias: \");\n \t      break;\n \t    default:"}, {"sha": "9e7db69f0823c31717168d1261232248b455ae2d", "filename": "include/gomp-constants.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -143,6 +143,11 @@ enum gomp_map_kind\n        No refcount is bumped by this, and the store is done unconditionally.  */\n     GOMP_MAP_ALWAYS_POINTER =\t\t(GOMP_MAP_FLAG_SPECIAL_2\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 1),\n+    /* Like GOMP_MAP_POINTER, but allow zero-length array section, i.e. set to\n+       NULL if target is not mapped.  */\n+    GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION\n+      =\t\t\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL | 2),\n     /* Forced deallocation of zero length array section.  */\n     GOMP_MAP_DELETE_ZERO_LEN_ARRAY_SECTION\n       =\t\t\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n@@ -163,6 +168,12 @@ enum gomp_map_kind\n     GOMP_MAP_FORCE_DETACH =\t\t(GOMP_MAP_DEEP_COPY\n \t\t\t\t\t | GOMP_MAP_FLAG_FORCE | 1),\n \n+    /* Like GOMP_MAP_ATTACH, but allow attaching to zero-length array sections\n+       (i.e. set to NULL when array section is not mapped) Currently only used\n+       by OpenMP.  */\n+    GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION\n+      =\t\t\t\t\t(GOMP_MAP_DEEP_COPY | 2),\n+\n     /* Internal to GCC, not used in libgomp.  */\n     /* Do not map, but pointer assign a pointer instead.  */\n     GOMP_MAP_FIRSTPRIVATE_POINTER =\t(GOMP_MAP_LAST | 1),\n@@ -186,7 +197,8 @@ enum gomp_map_kind\n   ((X) == GOMP_MAP_ALWAYS_POINTER)\n \n #define GOMP_MAP_POINTER_P(X) \\\n-  ((X) == GOMP_MAP_POINTER)\n+  ((X) == GOMP_MAP_POINTER \\\n+   || (X) == GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION)\n \n #define GOMP_MAP_ALWAYS_TO_P(X) \\\n   (((X) == GOMP_MAP_ALWAYS_TO) || ((X) == GOMP_MAP_ALWAYS_TOFROM))"}, {"sha": "832ca6eec307141cbd9bf73c60275bcdfcab5799", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -1283,7 +1283,7 @@ extern uintptr_t gomp_map_val (struct target_mem_desc *, void **, size_t);\n extern void gomp_attach_pointer (struct gomp_device_descr *,\n \t\t\t\t struct goacc_asyncqueue *, splay_tree,\n \t\t\t\t splay_tree_key, uintptr_t, size_t,\n-\t\t\t\t struct gomp_coalesce_buf *);\n+\t\t\t\t struct gomp_coalesce_buf *, bool);\n extern void gomp_detach_pointer (struct gomp_device_descr *,\n \t\t\t\t struct goacc_asyncqueue *, splay_tree_key,\n \t\t\t\t uintptr_t, bool, struct gomp_coalesce_buf *);"}, {"sha": "82d8dacfa1c3900a8aba24fdd4838335aead985a", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -937,7 +937,7 @@ acc_attach_async (void **hostaddr, int async)\n     }\n \n   gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n, (uintptr_t) hostaddr,\n-\t\t       0, NULL);\n+\t\t       0, NULL, false);\n \n   gomp_mutex_unlock (&acc_dev->lock);\n }\n@@ -1141,7 +1141,7 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  if ((kinds[i] & 0xff) == GOMP_MAP_ATTACH)\n \t    {\n \t      gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n,\n-\t\t\t\t   (uintptr_t) h, s, NULL);\n+\t\t\t\t   (uintptr_t) h, s, NULL, false);\n \t      /* OpenACC 'attach'/'detach' doesn't affect structured/dynamic\n \t\t reference counts ('n->refcount', 'n->dynamic_refcount').  */\n \t    }\n@@ -1159,7 +1159,8 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\tsplay_tree_key m\n \t\t  = lookup_host (acc_dev, hostaddrs[j], sizeof (void *));\n \t\tgomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, m,\n-\t\t\t\t     (uintptr_t) hostaddrs[j], sizes[j], NULL);\n+\t\t\t\t     (uintptr_t) hostaddrs[j], sizes[j], NULL,\n+\t\t\t\t     false);\n \t      }\n \n \t  bool processed = false;"}, {"sha": "6b02daf89d09ccbcd25d951c9ef0226997b09c17", "filename": "libgomp/target.c", "status": "modified", "additions": 52, "deletions": 24, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -543,7 +543,8 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n \t\t\tstruct gomp_coalesce_buf *cbuf,\n \t\t\thtab_t *refcount_set)\n {\n-  assert (kind != GOMP_MAP_ATTACH);\n+  assert (kind != GOMP_MAP_ATTACH\n+\t  || kind != GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION);\n \n   tgt_var->key = oldn;\n   tgt_var->copy_from = GOMP_MAP_COPY_FROM_P (kind);\n@@ -616,7 +617,8 @@ get_implicit (bool short_mapkind, void *kinds, int idx)\n static void\n gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,\n \t\t  uintptr_t host_ptr, uintptr_t target_offset, uintptr_t bias,\n-\t\t  struct gomp_coalesce_buf *cbuf)\n+\t\t  struct gomp_coalesce_buf *cbuf,\n+\t\t  bool allow_zero_length_array_sections)\n {\n   struct gomp_device_descr *devicep = tgt->device_descr;\n   struct splay_tree_s *mem_map = &devicep->mem_map;\n@@ -638,16 +640,24 @@ gomp_map_pointer (struct target_mem_desc *tgt, struct goacc_asyncqueue *aq,\n   splay_tree_key n = gomp_map_lookup (mem_map, &cur_node);\n   if (n == NULL)\n     {\n-      gomp_mutex_unlock (&devicep->lock);\n-      gomp_fatal (\"Pointer target of array section wasn't mapped\");\n-    }\n-  cur_node.host_start -= n->host_start;\n-  cur_node.tgt_offset\n-    = n->tgt->tgt_start + n->tgt_offset + cur_node.host_start;\n-  /* At this point tgt_offset is target address of the\n-     array section.  Now subtract bias to get what we want\n-     to initialize the pointer with.  */\n-  cur_node.tgt_offset -= bias;\n+      if (allow_zero_length_array_sections)\n+\tcur_node.tgt_offset = 0;\n+      else\n+\t{\n+\t  gomp_mutex_unlock (&devicep->lock);\n+\t  gomp_fatal (\"Pointer target of array section wasn't mapped\");\n+\t}\n+    }\n+  else\n+    {\n+      cur_node.host_start -= n->host_start;\n+      cur_node.tgt_offset\n+\t= n->tgt->tgt_start + n->tgt_offset + cur_node.host_start;\n+      /* At this point tgt_offset is target address of the\n+\t array section.  Now subtract bias to get what we want\n+\t to initialize the pointer with.  */\n+      cur_node.tgt_offset -= bias;\n+    }\n   gomp_copy_host2dev (devicep, aq, (void *) (tgt->tgt_start + target_offset),\n \t\t      (void *) &cur_node.tgt_offset, sizeof (void *),\n \t\t      true, cbuf);\n@@ -724,7 +734,8 @@ attribute_hidden void\n gomp_attach_pointer (struct gomp_device_descr *devicep,\n \t\t     struct goacc_asyncqueue *aq, splay_tree mem_map,\n \t\t     splay_tree_key n, uintptr_t attach_to, size_t bias,\n-\t\t     struct gomp_coalesce_buf *cbufp)\n+\t\t     struct gomp_coalesce_buf *cbufp,\n+\t\t     bool allow_zero_length_array_sections)\n {\n   struct splay_tree_key_s s;\n   size_t size, idx;\n@@ -776,11 +787,19 @@ gomp_attach_pointer (struct gomp_device_descr *devicep,\n \n       if (!tn)\n \t{\n-\t  gomp_mutex_unlock (&devicep->lock);\n-\t  gomp_fatal (\"pointer target not mapped for attach\");\n+\t  if (allow_zero_length_array_sections)\n+\t    /* When allowing attachment to zero-length array sections, we\n+\t       allow attaching to NULL pointers when the target region is not\n+\t       mapped.  */\n+\t    data = 0;\n+\t  else\n+\t    {\n+\t      gomp_mutex_unlock (&devicep->lock);\n+\t      gomp_fatal (\"pointer target not mapped for attach\");\n+\t    }\n \t}\n-\n-      data = tn->tgt->tgt_start + tn->tgt_offset + target - tn->host_start;\n+      else\n+\tdata = tn->tgt->tgt_start + tn->tgt_offset + target - tn->host_start;\n \n       gomp_debug (1,\n \t\t  \"%s: attaching host %p, target %p (struct base %p) to %p\\n\",\n@@ -1038,7 +1057,9 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  has_firstprivate = true;\n \t  continue;\n \t}\n-      else if ((kind & typemask) == GOMP_MAP_ATTACH)\n+      else if ((kind & typemask) == GOMP_MAP_ATTACH\n+\t       || ((kind & typemask)\n+\t\t   == GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION))\n \t{\n \t  tgt->list[i].key = NULL;\n \t  has_firstprivate = true;\n@@ -1287,7 +1308,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t      (uintptr_t) *(void **) hostaddrs[j],\n \t\t\t\t      k->tgt_offset + ((uintptr_t) hostaddrs[j]\n \t\t\t\t\t\t       - k->host_start),\n-\t\t\t\t      sizes[j], cbufp);\n+\t\t\t\t      sizes[j], cbufp, false);\n \t\t  }\n \t      }\n \t    i = j - 1;\n@@ -1416,6 +1437,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t  ++i;\n \t\tcontinue;\n \t      case GOMP_MAP_ATTACH:\n+\t      case GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION:\n \t\t{\n \t\t  cur_node.host_start = (uintptr_t) hostaddrs[i];\n \t\t  cur_node.host_end = cur_node.host_start + sizeof (void *);\n@@ -1432,9 +1454,12 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t structured/dynamic reference counts ('n->refcount',\n \t\t\t 'n->dynamic_refcount').  */\n \n+\t\t      bool zlas\n+\t\t\t= ((kind & typemask)\n+\t\t\t   == GOMP_MAP_ATTACH_ZERO_LENGTH_ARRAY_SECTION);\n \t\t      gomp_attach_pointer (devicep, aq, mem_map, n,\n \t\t\t\t\t   (uintptr_t) hostaddrs[i], sizes[i],\n-\t\t\t\t\t   cbufp);\n+\t\t\t\t\t   cbufp, zlas);\n \t\t    }\n \t\t  else if ((pragma_kind & GOMP_MAP_VARS_OPENACC) != 0)\n \t\t    {\n@@ -1545,9 +1570,12 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\tfalse, cbufp);\n \t\t    break;\n \t\t  case GOMP_MAP_POINTER:\n-\t\t    gomp_map_pointer (tgt, aq,\n-\t\t\t\t      (uintptr_t) *(void **) k->host_start,\n-\t\t\t\t      k->tgt_offset, sizes[i], cbufp);\n+\t\t  case GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION:\n+\t\t    gomp_map_pointer\n+\t\t      (tgt, aq, (uintptr_t) *(void **) k->host_start,\n+\t\t       k->tgt_offset, sizes[i], cbufp,\n+\t\t       ((kind & typemask)\n+\t\t\t== GOMP_MAP_POINTER_TO_ZERO_LENGTH_ARRAY_SECTION));\n \t\t    break;\n \t\t  case GOMP_MAP_TO_PSET:\n \t\t    gomp_copy_host2dev (devicep, aq,\n@@ -1589,7 +1617,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t\t\t      k->tgt_offset\n \t\t\t\t\t      + ((uintptr_t) hostaddrs[j]\n \t\t\t\t\t\t - k->host_start),\n-\t\t\t\t\t      sizes[j], cbufp);\n+\t\t\t\t\t      sizes[j], cbufp, false);\n \t\t\t  }\n \t\t\t}\n \t\t    i = j - 1;"}, {"sha": "d4f9ff3e983a2ba81877ac8bf885cf391893bf17", "filename": "libgomp/testsuite/libgomp.c++/target-23.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-23.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,34 @@\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int *data;\n+};\n+\n+int\n+main (void)\n+{\n+  #define SZ 10\n+  S *s = new S ();\n+  s->data = new int[SZ];\n+\n+  for (int i = 0; i < SZ; i++)\n+    s->data[i] = 0;\n+\n+  #pragma omp target enter data map(to: s)\n+  #pragma omp target enter data map(to: s->data[:SZ])\n+  #pragma omp target\n+  {\n+    for (int i = 0; i < SZ; i++)\n+      s->data[i] = i;\n+  }\n+  #pragma omp target exit data map(from: s->data[:SZ])\n+  #pragma omp target exit data map(from: s)\n+\n+  for (int i = 0; i < SZ; i++)\n+    if (s->data[i] != i)\n+      abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "06c6470b4ffd9765881123ab3101cdc9ef6b3634", "filename": "libgomp/testsuite/libgomp.c++/target-lambda-1.C", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-1.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,86 @@\n+#include <cstdlib>\n+#include <cstring>\n+\n+template <typename L>\n+void\n+omp_target_loop (int begin, int end, L loop)\n+{\n+  #pragma omp target teams distribute parallel for\n+  for (int i = begin; i < end; i++)\n+    loop (i);\n+}\n+\n+struct S\n+{\n+  int a, len;\n+  int *ptr;\n+\n+  auto merge_data_func (int *iptr, int &b)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  mapped = (ptr != NULL && iptr != NULL);\n+\t  if (mapped)\n+\t    {\n+\t      for (int i = 0; i < len; i++)\n+\t\tptr[i] += a + b + iptr[i];\n+\t    }\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+};\n+\n+int x = 1;\n+\n+int main (void)\n+{\n+  const int N = 10;\n+  int *data1 = new int[N];\n+  int *data2 = new int[N];\n+  memset (data1, 0xab, sizeof (int) * N);\n+  memset (data1, 0xcd, sizeof (int) * N);\n+\n+  int val = 1;\n+  int &valref = val;\n+  #pragma omp target enter data map(alloc: data1[:N], data2[:N])\n+\n+  omp_target_loop (0, N, [=](int i) { data1[i] = val; });\n+  omp_target_loop (0, N, [=](int i) { data2[i] = valref + 1; });\n+\n+  #pragma omp target update from(data1[:N], data2[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      if (data1[i] != 1) abort ();\n+      if (data2[i] != 2) abort ();\n+    }\n+\n+  #pragma omp target exit data map(delete: data1[:N], data2[:N])\n+\n+  int b = 8;\n+  S s = { 4, N, data1 };\n+  auto f = s.merge_data_func (data2, b);\n+\n+  if (f ()) abort ();\n+\n+  #pragma omp target enter data map(to: data1[:N])\n+  if (f ()) abort ();\n+\n+  #pragma omp target enter data map(to: data2[:N])\n+  if (!f ()) abort ();\n+\n+  #pragma omp target exit data map(from: data1[:N], data2[:N])\n+\n+  for (int i = 0; i < N; i++)\n+    {\n+      if (data1[i] != 0xf) abort ();\n+      if (data2[i] != 2) abort ();\n+    }\n+\n+  return 0;\n+}"}, {"sha": "1d3561ffbd79d51d2411cd89b03bfa89924106e4", "filename": "libgomp/testsuite/libgomp.c++/target-lambda-2.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-lambda-2.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,30 @@\n+#include <cstdlib>\n+\n+#define N 10\n+int main (void)\n+{\n+  int X, Y;\n+  #pragma omp target map(from: X, Y)\n+  {\n+    int x = 0, y = 0;\n+\n+    for (int i = 0; i < N; i++)\n+      [&] (int v) { x += v; } (i);\n+\n+    auto yinc = [&y] { y++; };\n+    for (int i = 0; i < N; i++)\n+      yinc ();\n+\n+    X = x;\n+    Y = y;\n+  }\n+\n+  int Xs = 0;\n+  for (int i = 0; i < N; i++)\n+    Xs += i;\n+  if (X != Xs)\n+    abort ();\n+\n+  if (Y != N)\n+    abort ();\n+}"}, {"sha": "a591ea4c56435f4f4aafb3b72afc20e0d8b5defb", "filename": "libgomp/testsuite/libgomp.c++/target-this-1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-1.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,29 @@\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int a, b, c, d;\n+\n+  int sum (void)\n+  {\n+    int val = 0;\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+\n+  int sum_offload (void)\n+  {\n+    int val = 0;\n+    #pragma omp target map(val)\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+};\n+\n+int main (void)\n+{\n+  S s = { 1, 2, 3, 4 };\n+  if (s.sum () != s.sum_offload ())\n+    abort ();\n+  return 0;\n+}"}, {"sha": "8119be8c2c5df9ddcbf9f47a0d539f435900214a", "filename": "libgomp/testsuite/libgomp.c++/target-this-2.C", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-2.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,47 @@\n+\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-additional-options \"-std=c++14\" }\n+\n+extern \"C\" void abort ();\n+\n+struct T\n+{\n+  int x, y;\n+\n+  auto sum_func (int n)\n+  {\n+    auto fn = [=](int m) -> int\n+      {\n+\tint v;\n+\tv = (x + y) * n + m;\n+\treturn v;\n+      };\n+    return fn;\n+  }\n+\n+  auto sum_func_offload (int n)\n+  {\n+    auto fn = [=](int m) -> int\n+      {\n+\tint v;\n+\t#pragma omp target map(from:v)\n+\tv = (x + y) * n + m;\n+\treturn v;\n+      };\n+    return fn;\n+  }\n+\n+};\n+\n+int main (void)\n+{\n+  T a = { 1, 2 };\n+\n+  auto s1 = a.sum_func (3);\n+  auto s2 = a.sum_func_offload (3);\n+\n+  if (s1 (1) != s2 (1))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e15f69a16233e352a743a1b26bb55d51287a5e6f", "filename": "libgomp/testsuite/libgomp.c++/target-this-3.C", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-3.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,99 @@\n+#include <stdio.h>\n+#include <string.h>\n+extern \"C\" void abort ();\n+\n+struct S\n+{\n+  int * ptr;\n+  int ptr_len;\n+\n+  int *&refptr;\n+  int refptr_len;\n+\n+  bool set_ptr (int n)\n+  {\n+    bool mapped;\n+    #pragma omp target map(from:mapped)\n+    {\n+      if (ptr != NULL)\n+\tfor (int i = 0; i < ptr_len; i++)\n+\t  ptr[i] = n;\n+      mapped = (ptr != NULL);\n+    }\n+    return mapped;\n+  }\n+\n+  bool set_refptr (int n)\n+  {\n+    bool mapped;\n+    #pragma omp target map(from:mapped)\n+    {\n+      if (refptr != NULL)\n+\tfor (int i = 0; i < refptr_len; i++)\n+\t  refptr[i] = n;\n+      mapped = (refptr != NULL);\n+    }\n+    return mapped;\n+  }\n+};\n+\n+int main (void)\n+{\n+  #define N 10\n+  int *ptr1 = new int[N];\n+  int *ptr2 = new int[N];\n+\n+  memset (ptr1, 0, sizeof (int) * N);\n+  memset (ptr2, 0, sizeof (int) * N);\n+\n+  S s = { ptr1, N, ptr2, N };\n+\n+  bool mapped;\n+  int val = 123;\n+\n+  mapped = s.set_ptr (val);\n+  if (mapped)\n+    abort ();\n+  if (s.ptr != ptr1)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 0)\n+      abort ();\n+\n+  mapped = s.set_refptr (val);\n+  if (mapped)\n+    abort ();\n+  if (s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 0)\n+      abort ();\n+\n+  #pragma omp target data map(ptr1[:N])\n+  mapped = s.set_ptr (val);\n+\n+  if (!mapped)\n+    abort ();\n+  if (s.set_refptr (0))\n+    abort ();\n+  if (s.ptr != ptr1 || s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != val)\n+      abort ();\n+\n+  #pragma omp target data map(ptr2[:N])\n+  mapped = s.set_refptr (val);\n+\n+  if (!mapped)\n+    abort ();\n+  if (s.set_ptr (0))\n+    abort ();\n+  if (s.ptr != ptr1 || s.refptr != ptr2)\n+    abort ();\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != val)\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "9f53677a24004f2e6f9f31dd6aa5bd3aeb497112", "filename": "libgomp/testsuite/libgomp.c++/target-this-4.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-4.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,104 @@\n+\n+// We use 'auto' without a function return type, so specify dialect here\n+// { dg-additional-options \"-std=c++14\" }\n+#include <cstdlib>\n+#include <cstring>\n+\n+struct T\n+{\n+  int *ptr;\n+  int ptr_len;\n+\n+  int *&refptr;\n+  int refptr_len;\n+\n+  auto set_ptr_func (int n)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  if (ptr)\n+\t    for (int i = 0; i < ptr_len; i++)\n+\t      ptr[i] = n;\n+\t  mapped = (ptr != NULL);\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+\n+  auto set_refptr_func (int n)\n+  {\n+    auto fn = [=](void) -> bool\n+      {\n+\tbool mapped;\n+\t#pragma omp target map(from:mapped)\n+\t{\n+\t  if (refptr)\n+\t    for (int i = 0; i < refptr_len; i++)\n+\t      refptr[i] = n;\n+\t  mapped = (refptr != NULL);\n+\t}\n+\treturn mapped;\n+      };\n+    return fn;\n+  }\n+};\n+\n+int main (void)\n+{\n+  #define N 10\n+  int *ptr1 = new int[N];\n+  int *ptr2 = new int[N];\n+\n+  memset (ptr1, 0, sizeof (int) * N);\n+  memset (ptr2, 0, sizeof (int) * N);\n+\n+  T a = { ptr1, N, ptr2, N };\n+\n+  auto p1 = a.set_ptr_func (1);\n+  auto r2 = a.set_refptr_func (2);\n+\n+  if (p1 ())\n+    abort ();\n+  if (r2 ())\n+    abort ();\n+\n+  if (a.ptr != ptr1)\n+    abort ();\n+  if (a.refptr != ptr2)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 0)\n+      abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 0)\n+      abort ();\n+\n+  #pragma omp target data map(ptr1[:N], ptr2[:N])\n+  {\n+    if (!p1 ())\n+      abort ();\n+    if (!r2 ())\n+      abort ();\n+  }\n+\n+  if (a.ptr != ptr1)\n+    abort ();\n+  if (a.refptr != ptr2)\n+    abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr1[i] != 1)\n+      abort ();\n+\n+  for (int i = 0; i < N; i++)\n+    if (ptr2[i] != 2)\n+      abort ();\n+\n+  return 0;\n+}"}, {"sha": "e71c566687d71595f43858dffd45827c1d941bd5", "filename": "libgomp/testsuite/libgomp.c++/target-this-5.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab29cf0bb68960c1f87405f14b4fb2109254e2f/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2B%2B%2Ftarget-this-5.C?ref=0ab29cf0bb68960c1f87405f14b4fb2109254e2f", "patch": "@@ -0,0 +1,30 @@\n+extern \"C\" void abort ();\n+\n+template<typename T>\n+struct S\n+{\n+  T a, b, c, d;\n+\n+  T sum (void)\n+  {\n+    T val = 0;\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+\n+  T sum_offload (void)\n+  {\n+    T val = 0;\n+    #pragma omp target map(val)\n+    val += a + b + this->c + this->d;\n+    return val;\n+  }\n+};\n+\n+int main (void)\n+{\n+  S<int> s = { 1, 2, 3, 4 };\n+  if (s.sum () != s.sum_offload ())\n+    abort ();\n+  return 0;\n+}"}]}