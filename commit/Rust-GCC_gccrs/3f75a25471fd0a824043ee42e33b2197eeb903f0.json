{"sha": "3f75a25471fd0a824043ee42e33b2197eeb903f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y3NWEyNTQ3MWZkMGE4MjQwNDNlZTQyZTMzYjIxOTdlZWI5MDNmMA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-10-03T20:53:05Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-10-03T20:53:05Z"}, "message": "c-aux-info.c, [...]: Follow code formatting conventions.\n\n\t* c-aux-info.c, c-common.c, c-common.h, c-cppbuiltin.c, c-decl.c,\n\tc-format.c, c-incpath.c, c-lex.c, c-objc-common.c, c-opts.c,\n\tc-parse.in, c-pch.c, c-ppoutput.c, c-pragma.c, c-typeck.c: Follow\n\tcode formatting conventions.\n\nFrom-SVN: r88462", "tree": {"sha": "9317be258ee227dd26354b571fba81483592c1ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9317be258ee227dd26354b571fba81483592c1ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f75a25471fd0a824043ee42e33b2197eeb903f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f75a25471fd0a824043ee42e33b2197eeb903f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f75a25471fd0a824043ee42e33b2197eeb903f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f75a25471fd0a824043ee42e33b2197eeb903f0/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57c1f13e476cea29f362f827c802e01b59f21025", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57c1f13e476cea29f362f827c802e01b59f21025", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57c1f13e476cea29f362f827c802e01b59f21025"}], "stats": {"total": 419, "additions": 213, "deletions": 206}, "files": [{"sha": "c934ea515677bec79e2cbcf51723b3a305e2356f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -1,3 +1,10 @@\n+2004-10-03  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* c-aux-info.c, c-common.c, c-common.h, c-cppbuiltin.c, c-decl.c,\n+\tc-format.c, c-incpath.c, c-lex.c, c-objc-common.c, c-opts.c,\n+\tc-parse.in, c-pch.c, c-ppoutput.c, c-pragma.c, c-typeck.c: Follow\n+\tcode formatting conventions.\n+\n 2004-10-03  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (<u>mulsidi3_32bit_r4000): Fix unsigned case."}, {"sha": "ddc3e376e92241b3004d09d1b2a0d71953198de5", "filename": "gcc/c-aux-info.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-aux-info.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-aux-info.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-aux-info.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -559,7 +559,7 @@ gen_aux_info_record (tree fndecl, int is_definition, int is_implicit,\n       /* Each output .X file must have a header line.  Write one now if we\n \t have not yet done so.  */\n \n-      if (! compiled_from_record++)\n+      if (!compiled_from_record++)\n \t{\n \t  /* The first line tells which directory file names are relative to.\n \t     Currently, -aux-info works only for files in the working"}, {"sha": "b2751f39226183faa82f907eae05b8cd26d95049", "filename": "gcc/c-common.c", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -735,7 +735,7 @@ fname_as_string (int pretty_p)\n   char *namep;\n   int vrb = 2;\n \n-  if (! pretty_p)\n+  if (!pretty_p)\n     {\n       name = \"\";\n       vrb = 0;\n@@ -1009,8 +1009,8 @@ convert_and_check (tree type, tree expr)\n \t       don't warn unless pedantic.  */\n \t    if ((pedantic\n \t\t || TYPE_UNSIGNED (type)\n-\t\t || ! constant_fits_type_p (expr,\n-\t\t\t\t\t    c_common_unsigned_type (type)))\n+\t\t || !constant_fits_type_p (expr,\n+\t\t\t\t\t   c_common_unsigned_type (type)))\n \t\t&& skip_evaluation == 0)\n \t      warning (\"overflow in implicit constant conversion\");\n \t}\n@@ -1080,9 +1080,9 @@ add_tlist (struct tlist **to, struct tlist *add, tree exclude_writer, int copy)\n   while (add)\n     {\n       struct tlist *next = add->next;\n-      if (! copy)\n+      if (!copy)\n \tadd->next = *to;\n-      if (! exclude_writer || add->writer != exclude_writer)\n+      if (!exclude_writer || add->writer != exclude_writer)\n \t*to = copy ? new_tlist (*to, add->expr, add->writer) : add;\n       add = next;\n     }\n@@ -1112,10 +1112,10 @@ merge_tlist (struct tlist **to, struct tlist *add, int copy)\n \tif (tmp2->expr == add->expr)\n \t  {\n \t    found = 1;\n-\t    if (! tmp2->writer)\n+\t    if (!tmp2->writer)\n \t      tmp2->writer = add->writer;\n \t  }\n-      if (! found)\n+      if (!found)\n \t{\n \t  *end = copy ? add : new_tlist (NULL, add->expr, add->writer);\n \t  end = &(*end)->next;\n@@ -1144,7 +1144,7 @@ warn_for_collisions_1 (tree written, tree writer, struct tlist *list,\n     {\n       if (list->expr == written\n \t  && list->writer != writer\n-\t  && (! only_writes || list->writer)\n+\t  && (!only_writes || list->writer)\n \t  && DECL_NAME (list->expr))\n \t{\n \t  warned_ids = new_tlist (warned_ids, written, NULL_TREE);\n@@ -1333,7 +1333,7 @@ verify_tree (tree x, struct tlist **pbefore_sp, struct tlist **pno_sp,\n \t  if (t->expr == x)\n \t    break;\n \n-\tif (! t)\n+\tif (!t)\n \t  {\n \t    t = XOBNEW (&tlist_obstack, struct tlist_cache);\n \t    t->next = save_expr_cache;\n@@ -1711,7 +1711,7 @@ c_common_signed_type (tree type)\n tree\n c_common_signed_or_unsigned_type (int unsignedp, tree type)\n {\n-  if (! INTEGRAL_TYPE_P (type)\n+  if (!INTEGRAL_TYPE_P (type)\n       || TYPE_UNSIGNED (type) == unsignedp)\n     return type;\n \n@@ -1803,7 +1803,7 @@ min_precision (tree value, int unsignedp)\n   else\n     log = tree_floor_log2 (value);\n \n-  return log + 1 + ! unsignedp;\n+  return log + 1 + !unsignedp;\n }\n \f\n /* Print an error message for invalid operands to arith operation\n@@ -1921,7 +1921,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n      the second arg is 0.  */\n \n   if (TREE_CONSTANT (primop0)\n-      && ! integer_zerop (primop1) && ! real_zerop (primop1))\n+      && !integer_zerop (primop1) && !real_zerop (primop1))\n     {\n       tree tem = primop0;\n       int temi = unsignedp0;\n@@ -1993,7 +1993,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t enumerated type itself.  In C++, TYPE_MAX_VALUE and\n \t TYPE_MIN_VALUE have already been set correctly on the\n \t enumeration type.  */\n-      if (!c_dialect_cxx() && TREE_CODE (type) == ENUMERAL_TYPE)\n+      if (!c_dialect_cxx () && TREE_CODE (type) == ENUMERAL_TYPE)\n \ttype = c_common_type_for_size (TYPE_PRECISION (type), unsignedp0);\n \n       maxval = TYPE_MAX_VALUE (type);\n@@ -2181,18 +2181,18 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t\t >= 0, the signedness of the comparison isn't an issue,\n \t\t so suppress the warning.  */\n \t      if (extra_warnings && !in_system_header\n-\t\t  && ! (TREE_CODE (primop0) == INTEGER_CST\n-\t\t\t&& ! TREE_OVERFLOW (convert (c_common_signed_type (type),\n-\t\t\t\t\t\t     primop0))))\n+\t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n+\t\t\t\t\t\t   primop0))))\n \t\twarning (\"comparison of unsigned expression >= 0 is always true\");\n \t      value = truthvalue_true_node;\n \t      break;\n \n \t    case LT_EXPR:\n \t      if (extra_warnings && !in_system_header\n-\t\t  && ! (TREE_CODE (primop0) == INTEGER_CST\n-\t\t\t&& ! TREE_OVERFLOW (convert (c_common_signed_type (type),\n-\t\t\t\t\t\t     primop0))))\n+\t\t  && !(TREE_CODE (primop0) == INTEGER_CST\n+\t\t       && !TREE_OVERFLOW (convert (c_common_signed_type (type),\n+\t\t\t\t\t\t   primop0))))\n \t\twarning (\"comparison of unsigned expression < 0 is always false\");\n \t      value = truthvalue_false_node;\n \t      break;\n@@ -2259,7 +2259,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      This helps produce common subexpressions.  */\n \n   if ((TREE_CODE (intop) == PLUS_EXPR || TREE_CODE (intop) == MINUS_EXPR)\n-      && ! TREE_CONSTANT (intop)\n+      && !TREE_CONSTANT (intop)\n       && TREE_CONSTANT (TREE_OPERAND (intop, 1))\n       && TREE_CONSTANT (size_exp)\n       /* If the constant comes from pointer subtraction,\n@@ -2268,7 +2268,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n       /* If the constant is unsigned, and smaller than the pointer size,\n \t then we must skip this optimization.  This is because it could cause\n \t an overflow error if the constant is negative but INTOP is not.  */\n-      && (! TYPE_UNSIGNED (TREE_TYPE (intop))\n+      && (!TYPE_UNSIGNED (TREE_TYPE (intop))\n \t  || (TYPE_PRECISION (TREE_TYPE (intop))\n \t      == TYPE_PRECISION (TREE_TYPE (ptrop)))))\n     {\n@@ -2351,7 +2351,7 @@ c_common_truthvalue_conversion (tree expr)\n     case ADDR_EXPR:\n       {\n \tif (TREE_CODE (TREE_OPERAND (expr, 0)) == FUNCTION_DECL\n-\t    && ! DECL_WEAK (TREE_OPERAND (expr, 0)))\n+\t    && !DECL_WEAK (TREE_OPERAND (expr, 0)))\n \t  {\n \t    /* Common Ada/Pascal programmer's mistake.  We always warn\n \t       about this since it is so bad.  */\n@@ -2559,7 +2559,7 @@ c_type_hash (const void *p)\n {\n   int i = 0;\n   int shift, size;\n-  tree t = (tree)p;\n+  tree t = (tree) p;\n   tree t2;\n   switch (TREE_CODE (t))\n     {\n@@ -2616,7 +2616,7 @@ c_common_get_alias_set (tree t)\n       return 0;\n \n   /* That's all the expressions we handle specially.  */\n-  if (! TYPE_P (t))\n+  if (!TYPE_P (t))\n     return -1;\n \n   /* The C standard guarantees that any object may be accessed via an\n@@ -3550,8 +3550,8 @@ c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n      expression.  If both low_value and high_value are out of range,\n      don't insert the case label and return NULL_TREE.  */\n   if (low_value\n-      && ! check_case_bounds (type, orig_type,\n-\t\t\t      &low_value, high_value ? &high_value : NULL))\n+      && !check_case_bounds (type, orig_type,\n+\t\t\t     &low_value, high_value ? &high_value : NULL))\n     return NULL_TREE;\n \n   /* Look up the LOW_VALUE in the table of case labels we already\n@@ -4294,11 +4294,11 @@ handle_mode_attribute (tree *node, tree name, tree args,\n \n       /* Change this type to have a type with the specified mode.\n \t First check for the special modes.  */\n-      if (! strcmp (p, \"byte\"))\n+      if (!strcmp (p, \"byte\"))\n \tmode = byte_mode;\n       else if (!strcmp (p, \"word\"))\n \tmode = word_mode;\n-      else if (! strcmp (p, \"pointer\"))\n+      else if (!strcmp (p, \"pointer\"))\n \tmode = ptr_mode;\n       else\n \tfor (j = 0; j < NUM_MACHINE_MODES; j++)\n@@ -4410,7 +4410,7 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t{\n \t  if (TREE_CODE (decl) == VAR_DECL\n \t      && current_function_decl != NULL_TREE\n-\t      && ! TREE_STATIC (decl))\n+\t      && !TREE_STATIC (decl))\n \t    {\n \t      error (\"%Jsection attribute cannot be specified for \"\n \t\t     \"local variables\", decl);\n@@ -4548,7 +4548,7 @@ handle_alias_attribute (tree *node, tree name, tree args,\n   tree decl = *node;\n \n   if ((TREE_CODE (decl) == FUNCTION_DECL && DECL_INITIAL (decl))\n-      || (TREE_CODE (decl) != FUNCTION_DECL && ! DECL_EXTERNAL (decl)))\n+      || (TREE_CODE (decl) != FUNCTION_DECL && !DECL_EXTERNAL (decl)))\n     {\n       error (\"%J%qD defined both normally and as an alias\", decl, decl);\n       *no_add_attrs = true;\n@@ -4613,7 +4613,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n          return NULL_TREE;\n        }\n     }\n-  else if (decl_function_context (decl) != 0 || ! TREE_PUBLIC (decl))\n+  else if (decl_function_context (decl) != 0 || !TREE_PUBLIC (decl))\n     {\n       warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n@@ -4629,7 +4629,7 @@ handle_visibility_attribute (tree *node, tree name, tree args,\n   if (TYPE_P (decl))\n     {\n       decl = TYPE_NAME (decl);\n-      if (! decl)\n+      if (!decl)\n         return NULL_TREE;\n     }\n \n@@ -4699,7 +4699,7 @@ handle_tls_model_attribute (tree *node, tree name, tree args,\n {\n   tree decl = *node;\n \n-  if (! DECL_THREAD_LOCAL (decl))\n+  if (!DECL_THREAD_LOCAL (decl))\n     {\n       warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       *no_add_attrs = true;\n@@ -4899,7 +4899,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n   if (TREE_CODE (size) == NON_LVALUE_EXPR)\n     size = TREE_OPERAND (size, 0);\n \n-  if (! host_integerp (size, 1))\n+  if (!host_integerp (size, 1))\n     {\n       warning (\"%qs attribute ignored\", IDENTIFIER_POINTER (name));\n       return NULL_TREE;\n@@ -4928,7 +4928,7 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n   if (TREE_CODE (type) == RECORD_TYPE\n       || (GET_MODE_CLASS (orig_mode) != MODE_FLOAT\n \t  && GET_MODE_CLASS (orig_mode) != MODE_INT)\n-      || ! host_integerp (TYPE_SIZE_UNIT (type), 1))\n+      || !host_integerp (TYPE_SIZE_UNIT (type), 1))\n     {\n       error (\"invalid vector type for attribute %qs\",\n \t     IDENTIFIER_POINTER (name));\n@@ -4963,9 +4963,9 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n   /* If no arguments are specified, all pointer arguments should be\n      non-null.  Verify a full prototype is given so that the arguments\n      will have the correct types when we actually check them later.  */\n-  if (! args)\n+  if (!args)\n     {\n-      if (! TYPE_ARG_TYPES (type))\n+      if (!TYPE_ARG_TYPES (type))\n \t{\n \t  error (\"nonnull attribute without arguments on a non-prototype\");\n \t  *no_add_attrs = true;\n@@ -4980,7 +4980,7 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n       tree argument;\n       unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n \n-      if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n+      if (!get_nonnull_operand (TREE_VALUE (args), &arg_num))\n \t{\n \t  error (\"nonnull argument has invalid operand number (arg %lu)\",\n \t\t (unsigned long) attr_arg_num);\n@@ -4993,12 +4993,12 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n \t{\n \t  for (ck_num = 1; ; ck_num++)\n \t    {\n-\t      if (! argument || ck_num == arg_num)\n+\t      if (!argument || ck_num == arg_num)\n \t\tbreak;\n \t      argument = TREE_CHAIN (argument);\n \t    }\n \n-\t  if (! argument\n+\t  if (!argument\n \t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n \t    {\n \t      error (\"nonnull argument with out-of-range operand number (arg %lu, operand %lu)\",\n@@ -5042,9 +5042,9 @@ check_function_nonnull (tree attrs, tree params)\n \t  for (param = params, param_num = 1; ;\n \t       param_num++, param = TREE_CHAIN (param))\n \t    {\n-\t      if (! param)\n+\t      if (!param)\n \tbreak;\n-\t      if (! args || nonnull_check_p (args, param_num))\n+\t      if (!args || nonnull_check_p (args, param_num))\n \tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n \t\t\t\t\t  TREE_VALUE (param),\n \t\t\t\t\t  param_num);"}, {"sha": "77a415d7f03aad4fad018f60a99e801a7e6696e8", "filename": "gcc/c-common.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -113,16 +113,16 @@ enum rid\n };\n \n #define OBJC_IS_AT_KEYWORD(rid) \\\n-  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_AT && \\\n-   (unsigned int)(rid) <= (unsigned int)RID_LAST_AT)\n+  ((unsigned int) (rid) >= (unsigned int) RID_FIRST_AT && \\\n+   (unsigned int) (rid) <= (unsigned int) RID_LAST_AT)\n \n #define OBJC_IS_PQ_KEYWORD(rid) \\\n-  ((unsigned int)(rid) >= (unsigned int)RID_FIRST_PQ && \\\n-   (unsigned int)(rid) <= (unsigned int)RID_LAST_PQ)\n+  ((unsigned int) (rid) >= (unsigned int) RID_FIRST_PQ && \\\n+   (unsigned int) (rid) <= (unsigned int) RID_LAST_PQ)\n \n /* The elements of `ridpointers' are identifier nodes for the reserved\n    type names and storage classes.  It is indexed by a RID_... value.  */\n-extern GTY ((length (\"(int)RID_MAX\"))) tree *ridpointers;\n+extern GTY ((length (\"(int) RID_MAX\"))) tree *ridpointers;\n \n /* Standard named or nameless data types of the C compiler.  */\n "}, {"sha": "a970df5d53837147dac6299bc63fec3bd9592527", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -259,7 +259,7 @@ define__GNUC__ (void)\n      ([^0-9]*-)?[0-9]+[.][0-9]+([.][0-9]+)?([- ].*)?  */\n   const char *q, *v = version_string;\n \n-  while (*v && ! ISDIGIT (*v))\n+  while (*v && !ISDIGIT (*v))\n     v++;\n   gcc_assert (*v && (v <= version_string || v[-1] == '-'));\n "}, {"sha": "df61736c4aa38afcc6b7a43e33a29ee3777eef87", "filename": "gcc/c-decl.c", "status": "modified", "additions": 38, "deletions": 38, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -205,17 +205,17 @@ struct c_binding GTY((chain_next (\"%h.prev\")))\n #define B_IN_EXTERNAL_SCOPE(b) ((b)->depth == 0 /*external_scope->depth*/)\n \n #define I_SYMBOL_BINDING(node) \\\n-  (((struct lang_identifier *)IDENTIFIER_NODE_CHECK(node))->symbol_binding)\n+  (((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->symbol_binding)\n #define I_SYMBOL_DECL(node) \\\n  (I_SYMBOL_BINDING(node) ? I_SYMBOL_BINDING(node)->decl : 0)\n \n #define I_TAG_BINDING(node) \\\n-  (((struct lang_identifier *)IDENTIFIER_NODE_CHECK(node))->tag_binding)\n+  (((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->tag_binding)\n #define I_TAG_DECL(node) \\\n  (I_TAG_BINDING(node) ? I_TAG_BINDING(node)->decl : 0)\n \n #define I_LABEL_BINDING(node) \\\n-  (((struct lang_identifier *)IDENTIFIER_NODE_CHECK(node))->label_binding)\n+  (((struct lang_identifier *) IDENTIFIER_NODE_CHECK(node))->label_binding)\n #define I_LABEL_DECL(node) \\\n  (I_LABEL_BINDING(node) ? I_LABEL_BINDING(node)->decl : 0)\n \n@@ -239,7 +239,7 @@ extern char C_SIZEOF_STRUCT_LANG_IDENTIFIER_isnt_accurate\n \n union lang_tree_node\n   GTY((desc (\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *)TYPE_NEXT_VARIANT (&%h.generic) : (union lang_tree_node *)TREE_CHAIN (&%h.generic)\")))\n+       chain_next (\"TREE_CODE (&%h.generic) == INTEGER_TYPE ? (union lang_tree_node *) TYPE_NEXT_VARIANT (&%h.generic) : (union lang_tree_node *) TREE_CHAIN (&%h.generic)\")))\n {\n   union tree_node GTY ((tag (\"0\"),\n \t\t\tdesc (\"tree_node_structure (&%h)\")))\n@@ -518,7 +518,7 @@ c_finish_incomplete_decl (tree decl)\n       tree type = TREE_TYPE (decl);\n       if (type != error_mark_node\n \t  && TREE_CODE (type) == ARRAY_TYPE\n-\t  && ! DECL_EXTERNAL (decl)\n+\t  && !DECL_EXTERNAL (decl)\n \t  && TYPE_DOMAIN (type) == 0)\n \t{\n \t  warning (\"%Jarray %qD assumed to have one element\", decl, decl);\n@@ -752,7 +752,7 @@ pop_scope (void)\n \tcase FUNCTION_DECL:\n \t  /* Propagate TREE_ADDRESSABLE from nested functions to their\n \t     containing functions.  */\n-\t  if (! TREE_ASM_WRITTEN (p)\n+\t  if (!TREE_ASM_WRITTEN (p)\n \t      && DECL_INITIAL (p) != 0\n \t      && TREE_ADDRESSABLE (p)\n \t      && DECL_ABSTRACT_ORIGIN (p) != 0\n@@ -965,10 +965,10 @@ match_builtin_function_types (tree newtype, tree oldtype)\n \n   while (oldargs || newargs)\n     {\n-      if (! oldargs\n-\t  || ! newargs\n-\t  || ! TREE_VALUE (oldargs)\n-\t  || ! TREE_VALUE (newargs)\n+      if (!oldargs\n+\t  || !newargs\n+\t  || !TREE_VALUE (oldargs)\n+\t  || !TREE_VALUE (newargs)\n \t  || TYPE_MODE (TREE_VALUE (oldargs))\n \t     != TYPE_MODE (TREE_VALUE (newargs)))\n \treturn 0;\n@@ -1063,7 +1063,7 @@ validate_proto_after_old_defn (tree newdecl, tree newtype, tree oldtype)\n \n       /* Type for passing arg must be consistent with that declared\n \t for the arg.  */\n-      else if (! comptypes (oldargtype, newargtype))\n+      else if (!comptypes (oldargtype, newargtype))\n \t{\n \t  error (\"%Jprototype for %qD declares arg %d with incompatible type\",\n \t\t newdecl, newdecl, i);\n@@ -1522,7 +1522,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n      in its new location and clear TREE_ASM_WRITTEN (it's not a\n      forward decl anymore).  */\n   if (TREE_CODE (newdecl) == PARM_DECL\n-      && TREE_ASM_WRITTEN (olddecl) && ! TREE_ASM_WRITTEN (newdecl))\n+      && TREE_ASM_WRITTEN (olddecl) && !TREE_ASM_WRITTEN (newdecl))\n     {\n       struct c_binding *b, **here;\n \n@@ -1646,7 +1646,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t copy the attributes of NEWDECL into OLDDECL.  */\n       TREE_PUBLIC (olddecl) = TREE_PUBLIC (newdecl);\n       /* If this clears `static', clear it in the identifier too.  */\n-      if (! TREE_PUBLIC (olddecl))\n+      if (!TREE_PUBLIC (olddecl))\n \tTREE_PUBLIC (DECL_NAME (olddecl)) = 0;\n     }\n   if (DECL_EXTERNAL (newdecl))\n@@ -1656,7 +1656,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \n       /* An extern decl does not override previous storage class.  */\n       TREE_PUBLIC (newdecl) = TREE_PUBLIC (olddecl);\n-      if (! DECL_EXTERNAL (newdecl))\n+      if (!DECL_EXTERNAL (newdecl))\n \t{\n \t  DECL_CONTEXT (newdecl) = DECL_CONTEXT (olddecl);\n \t  DECL_COMMON (newdecl) = DECL_COMMON (olddecl);\n@@ -1709,7 +1709,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t}\n \n       /* Also preserve various other info from the definition.  */\n-      if (! new_is_definition)\n+      if (!new_is_definition)\n \t{\n \t  DECL_RESULT (newdecl) = DECL_RESULT (olddecl);\n \t  DECL_INITIAL (newdecl) = DECL_INITIAL (olddecl);\n@@ -1719,7 +1719,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \n \t  /* Set DECL_INLINE on the declaration if we've got a body\n \t     from which to instantiate.  */\n-\t  if (DECL_INLINE (olddecl) && ! DECL_UNINLINABLE (newdecl))\n+\t  if (DECL_INLINE (olddecl) && !DECL_UNINLINABLE (newdecl))\n \t    {\n \t      DECL_INLINE (newdecl) = 1;\n \t      DECL_ABSTRACT_ORIGIN (newdecl)\n@@ -1731,7 +1731,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n \t  /* If a previous declaration said inline, mark the\n \t     definition as inlinable.  */\n \t  if (DECL_DECLARED_INLINE_P (newdecl)\n-\t      && ! DECL_UNINLINABLE (newdecl))\n+\t      && !DECL_UNINLINABLE (newdecl))\n \t    DECL_INLINE (newdecl) = 1;\n \t}\n     }\n@@ -1820,7 +1820,7 @@ warn_if_shadowing (tree new_decl)\n \t\t   new_decl, new_decl);\n \n \tif (TREE_CODE (old_decl) != FUNCTION_DECL\n-\t    || ! DECL_BUILT_IN (old_decl))\n+\t    || !DECL_BUILT_IN (old_decl))\n \t  warning (\"%Jshadowed declaration is here\", old_decl);\n \n \tbreak;\n@@ -1909,7 +1909,7 @@ pushdecl (tree x)\n   bool nested = false;\n \n   /* Functions need the lang_decl data.  */\n-  if (TREE_CODE (x) == FUNCTION_DECL && ! DECL_LANG_SPECIFIC (x))\n+  if (TREE_CODE (x) == FUNCTION_DECL && !DECL_LANG_SPECIFIC (x))\n     DECL_LANG_SPECIFIC (x) = GGC_CNEW (struct lang_decl);\n \n   /* Must set DECL_CONTEXT for everything not at file scope or\n@@ -2286,7 +2286,7 @@ undeclared_variable (tree id)\n     {\n       error (\"%qE undeclared (first use in this function)\", id);\n \n-      if (! already)\n+      if (!already)\n \t{\n \t  error (\"(Each undeclared identifier is reported only once\");\n \t  error (\"for each function it appears in.)\");\n@@ -3143,7 +3143,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t     If it is not `static', then do not mark extern;\n \t     finish_incomplete_decl will give it a default size\n \t     and it will get allocated.  */\n-\t  else if (!pedantic && TREE_STATIC (decl) && ! TREE_PUBLIC (decl))\n+\t  else if (!pedantic && TREE_STATIC (decl) && !TREE_PUBLIC (decl))\n \t    DECL_EXTERNAL (decl) = 1;\n \t}\n \n@@ -3239,7 +3239,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t     ordinary, non-register local variable.  Historically,\n \t     GCC has accepted -- but ignored -- the ASMSPEC in\n \t     this case.  */\n-\t  if (! DECL_FILE_SCOPE_P (decl)\n+\t  if (!DECL_FILE_SCOPE_P (decl)\n \t      && TREE_CODE (decl) == VAR_DECL\n \t      && !C_DECL_REGISTER (decl)\n \t      && !TREE_STATIC (decl))\n@@ -3303,7 +3303,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t  /* Recompute the RTL of a local array now\n \t     if it used to be an incomplete type.  */\n \t  if (was_incomplete\n-\t      && ! TREE_STATIC (decl) && ! DECL_EXTERNAL (decl))\n+\t      && !TREE_STATIC (decl) && !DECL_EXTERNAL (decl))\n \t    {\n \t      /* If we used it already as memory, it must stay in memory.  */\n \t      TREE_ADDRESSABLE (decl) = TREE_USED (decl);\n@@ -3817,7 +3817,7 @@ grokdeclarator (const struct c_declarator *declarator,\n       if (volatilep > 1)\n \tpedwarn (\"duplicate %<volatile%>\");\n     }\n-  if (! flag_gen_aux_info && (TYPE_QUALS (type)))\n+  if (!flag_gen_aux_info && (TYPE_QUALS (type)))\n     type = TYPE_MAIN_VARIANT (type);\n   type_quals = ((constp ? TYPE_QUAL_CONST : 0)\n \t\t| (restrictp ? TYPE_QUAL_RESTRICT : 0)\n@@ -4009,7 +4009,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \t\t   lvalue.  */\n \t\tSTRIP_TYPE_NOPS (size);\n \t\t\n-\t\tif (! INTEGRAL_TYPE_P (TREE_TYPE (size)))\n+\t\tif (!INTEGRAL_TYPE_P (TREE_TYPE (size)))\n \t\t  {\n \t\t    error (\"size of array %qs has non-integer type\", name);\n \t\t    size = integer_one_node;\n@@ -4308,7 +4308,7 @@ grokdeclarator (const struct c_declarator *declarator,\n      a better error message can be made later.  */\n \n   if (VOID_TYPE_P (type) && decl_context != PARM\n-      && ! ((decl_context != FIELD && TREE_CODE (type) != FUNCTION_TYPE)\n+      && !((decl_context != FIELD && TREE_CODE (type) != FUNCTION_TYPE)\n \t    && (storage_class == csc_extern\n \t\t|| (current_scope == file_scope\n \t\t    && !(storage_class == csc_static\n@@ -4436,7 +4436,7 @@ grokdeclarator (const struct c_declarator *declarator,\n \n \tDECL_LANG_SPECIFIC (decl) = GGC_CNEW (struct lang_decl);\n \n-\tif (pedantic && type_quals && ! DECL_IN_SYSTEM_HEADER (decl))\n+\tif (pedantic && type_quals && !DECL_IN_SYSTEM_HEADER (decl))\n \t  pedwarn (\"ISO C forbids qualified function types\");\n \n \t/* GNU C interprets a volatile-qualified function type to indicate\n@@ -4637,7 +4637,7 @@ grokparms (struct c_arg_info *arg_info, bool funcdef_flag)\n \n   else if (arg_types && TREE_CODE (TREE_VALUE (arg_types)) == IDENTIFIER_NODE)\n     {\n-      if (! funcdef_flag)\n+      if (!funcdef_flag)\n \tpedwarn (\"parameter names (without types) in function declaration\");\n \n       arg_info->parms = arg_info->types;\n@@ -4824,7 +4824,7 @@ get_parm_info (bool ellipsis)\n \t\twarning (\"anonymous %s declared inside parameter list\",\n \t\t\t keyword);\n \n-\t      if (! explained_incomplete_types)\n+\t      if (!explained_incomplete_types)\n \t\t{\n \t\t  warning (\"its scope is only this definition or declaration,\"\n \t\t\t   \" which is probably not what you want\");\n@@ -5183,7 +5183,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t      error (\"%Jflexible array member not at end of struct\", x);\n \t      TREE_TYPE (x) = error_mark_node;\n \t    }\n-\t  else if (! saw_named_field)\n+\t  else if (!saw_named_field)\n \t    {\n \t      error (\"%Jflexible array member in otherwise empty struct\", x);\n \t      TREE_TYPE (x) = error_mark_node;\n@@ -5315,7 +5315,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n \t  if (c_dialect_objc ())\n \t    objc_check_decl (decl);\n \t  rest_of_decl_compilation (decl, toplevel, 0);\n-\t  if (! toplevel)\n+\t  if (!toplevel)\n \t    expand_decl (decl);\n \t}\n     }\n@@ -5568,7 +5568,7 @@ build_enumerator (tree name, tree value)\n \terror (\"overflow in enumeration values\");\n     }\n \n-  if (pedantic && ! int_fits_type_p (value, integer_type_node))\n+  if (pedantic && !int_fits_type_p (value, integer_type_node))\n     {\n       pedwarn (\"ISO C restricts enumerator values to range of %<int%>\");\n       /* XXX This causes -pedantic to change the meaning of the program.\n@@ -5683,7 +5683,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   /* Optionally warn of any global def with no previous prototype.  */\n   else if (warn_missing_prototypes\n \t   && TREE_PUBLIC (decl1)\n-\t   && ! MAIN_NAME_P (DECL_NAME (decl1))\n+\t   && !MAIN_NAME_P (DECL_NAME (decl1))\n \t   && C_DECL_ISNT_PROTOTYPE (old_decl))\n     warning (\"%Jno previous prototype for %qD\", decl1, decl1);\n   /* Optionally warn of any def with no previous prototype\n@@ -5697,7 +5697,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n   else if (warn_missing_declarations\n \t   && TREE_PUBLIC (decl1)\n \t   && old_decl == 0\n-\t   && ! MAIN_NAME_P (DECL_NAME (decl1)))\n+\t   && !MAIN_NAME_P (DECL_NAME (decl1)))\n     warning (\"%Jno previous declaration for %qD\", decl1, decl1);\n   /* Optionally warn of any def with no previous declaration\n      if the function has already been used.  */\n@@ -5782,7 +5782,7 @@ start_function (struct c_declspecs *declspecs, struct c_declarator *declarator,\n       if (argct > 0 && (argct < 2 || argct > 3))\n \tpedwarn (\"%J%qD takes only zero or two arguments\", decl1, decl1);\n \n-      if (! TREE_PUBLIC (decl1))\n+      if (!TREE_PUBLIC (decl1))\n \tpedwarn (\"%J%qD is normally a non-static function\", decl1, decl1);\n     }\n \n@@ -5965,7 +5965,7 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  TREE_TYPE (parm) = error_mark_node;\n \t}\n \n-      if (! DECL_WEAK (parm))\n+      if (!DECL_WEAK (parm))\n \t{\n \t  error (\"%Jdeclaration for parameter %qD but no such parameter\",\n \t\t parm, parm);\n@@ -6025,8 +6025,8 @@ store_parm_decls_oldstyle (tree fndecl, const struct c_arg_info *arg_info)\n \t  /* Type for passing arg must be consistent with that\n \t     declared for the arg.  ISO C says we take the unqualified\n \t     type for parameters declared with qualified type.  */\n-\t  if (! comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n-\t\t\t   TYPE_MAIN_VARIANT (TREE_VALUE (type))))\n+\t  if (!comptypes (TYPE_MAIN_VARIANT (DECL_ARG_TYPE (parm)),\n+\t\t\t  TYPE_MAIN_VARIANT (TREE_VALUE (type))))\n \t    {\n \t      if (TYPE_MAIN_VARIANT (TREE_TYPE (parm))\n \t\t  == TYPE_MAIN_VARIANT (TREE_VALUE (type)))"}, {"sha": "e5009a32fea2584b4675e90f3ab25e9bebab6f9c", "filename": "gcc/c-format.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -232,10 +232,10 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n    or inheriting from, for the purpose of format features supported.  */\n #define CPLUSPLUS_STD_VER\tSTD_C94\n /* The C standard version we are checking formats against when pedantic.  */\n-#define C_STD_VER\t\t((int)(c_dialect_cxx ()\t\t\t  \\\n-\t\t\t\t ? CPLUSPLUS_STD_VER\t\t\t  \\\n-\t\t\t\t : (flag_isoc99\t\t\t\t  \\\n-\t\t\t\t    ? STD_C99\t\t\t\t  \\\n+#define C_STD_VER\t\t((int) (c_dialect_cxx ()\t\t   \\\n+\t\t\t\t ? CPLUSPLUS_STD_VER\t\t\t   \\\n+\t\t\t\t : (flag_isoc99\t\t\t\t   \\\n+\t\t\t\t    ? STD_C99\t\t\t\t   \\\n \t\t\t\t    : (flag_isoc94 ? STD_C94 : STD_C89))))\n /* The name to give to the standard version we are warning about when\n    pedantic.  FEATURE_VER is the version in which the feature warned out\n@@ -247,7 +247,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \t\t\t\t    : \"ISO C90\"))\n /* Adjust a C standard version, which may be STD_C9L, to account for\n    -Wno-long-long.  Returns other standard versions unchanged.  */\n-#define ADJ_STD(VER)\t\t((int)((VER) == STD_C9L\t\t\t      \\\n+#define ADJ_STD(VER)\t\t((int) ((VER) == STD_C9L\t\t      \\\n \t\t\t\t       ? (warn_long_long ? STD_C99 : STD_C89) \\\n \t\t\t\t       : (VER)))\n \n@@ -924,7 +924,7 @@ maybe_read_dollar_number (const char **format,\n   int argnum;\n   int overflow_flag;\n   const char *fcp = *format;\n-  if (! ISDIGIT (*fcp))\n+  if (!ISDIGIT (*fcp))\n     {\n       if (dollar_needed)\n \t{\n@@ -1744,7 +1744,7 @@ check_format_info_main (format_check_results *res,\n \t  ++fci;\n       if (fci->format_chars == 0)\n \t{\n-          if (ISGRAPH(format_char))\n+          if (ISGRAPH (format_char))\n \t    warning (\"unknown conversion type character %qc in format\",\n \t\t     format_char);\n \t  else\n@@ -2150,15 +2150,15 @@ check_format_types (format_wanted_type *types, const char *format_start,\n \t a second level of indirection.  */\n       if (TREE_CODE (wanted_type) == INTEGER_TYPE\n \t  && TREE_CODE (cur_type) == INTEGER_TYPE\n-\t  && (! pedantic || i == 0 || (i == 1 && char_type_flag))\n+\t  && (!pedantic || i == 0 || (i == 1 && char_type_flag))\n \t  && (TYPE_UNSIGNED (wanted_type)\n \t      ? wanted_type == c_common_unsigned_type (cur_type)\n \t      : wanted_type == c_common_signed_type (cur_type)))\n \tcontinue;\n       /* Likewise, \"signed char\", \"unsigned char\" and \"char\" are\n \t equivalent but the above test won't consider them equivalent.  */\n       if (wanted_type == char_type_node\n-\t  && (! pedantic || i < 2)\n+\t  && (!pedantic || i < 2)\n \t  && char_type_flag)\n \tcontinue;\n       /* Now we have a type mismatch.  */\n@@ -2350,7 +2350,7 @@ init_dynamic_diag_info (void)\n       /* Assign the new data for use.  */\n \n       /* All the GCC diag formats use the same length specs.  */\n-      if (! diag_ls)\n+      if (!diag_ls)\n \tdynamic_format_types[gcc_diag_format_type].length_char_specs =\n \t  dynamic_format_types[gcc_cdiag_format_type].length_char_specs =\n \t  dynamic_format_types[gcc_cxxdiag_format_type].length_char_specs =\n@@ -2371,12 +2371,12 @@ init_dynamic_diag_info (void)\n \t}\n \n       /* Handle the __gcc_diag__ format specifics.  */\n-      if (! diag_fci)\n+      if (!diag_fci)\n \tdynamic_format_types[gcc_diag_format_type].conversion_specs =\n \t  diag_fci = (format_char_info *)\n \t\t     xmemdup (gcc_diag_char_table,\n-\t\t\t      sizeof(gcc_diag_char_table),\n-\t\t\t      sizeof(gcc_diag_char_table));\n+\t\t\t      sizeof (gcc_diag_char_table),\n+\t\t\t      sizeof (gcc_diag_char_table));\n       if (loc)\n         {\n \t  i = find_char_info_specifier_index (diag_fci, 'H');\n@@ -2391,12 +2391,12 @@ init_dynamic_diag_info (void)\n \t}\n \n       /* Handle the __gcc_cdiag__ format specifics.  */\n-      if (! cdiag_fci)\n+      if (!cdiag_fci)\n \tdynamic_format_types[gcc_cdiag_format_type].conversion_specs =\n \t  cdiag_fci = (format_char_info *)\n \t\t      xmemdup (gcc_cdiag_char_table,\n-\t\t\t       sizeof(gcc_cdiag_char_table),\n-\t\t\t       sizeof(gcc_cdiag_char_table));\n+\t\t\t       sizeof (gcc_cdiag_char_table),\n+\t\t\t       sizeof (gcc_cdiag_char_table));\n       if (loc)\n         {\n \t  i = find_char_info_specifier_index (cdiag_fci, 'H');\n@@ -2415,12 +2415,12 @@ init_dynamic_diag_info (void)\n \t}\n \n       /* Handle the __gcc_cxxdiag__ format specifics.  */\n-      if (! cxxdiag_fci)\n+      if (!cxxdiag_fci)\n \tdynamic_format_types[gcc_cxxdiag_format_type].conversion_specs =\n \t  cxxdiag_fci = (format_char_info *)\n \t\t\txmemdup (gcc_cxxdiag_char_table,\n-\t\t\t\t sizeof(gcc_cxxdiag_char_table),\n-\t\t\t\t sizeof(gcc_cxxdiag_char_table));\n+\t\t\t\t sizeof (gcc_cxxdiag_char_table),\n+\t\t\t\t sizeof (gcc_cxxdiag_char_table));\n       if (loc)\n         {\n \t  i = find_char_info_specifier_index (cxxdiag_fci, 'H');\n@@ -2527,15 +2527,15 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       /* If this is format __asm_fprintf__, we have to initialize\n          GCC's notion of HOST_WIDE_INT for checking %wd.  */\n       if (info.format_type == asm_fprintf_format_type)\n-\tinit_dynamic_asm_fprintf_info();\n+\tinit_dynamic_asm_fprintf_info ();\n       /* If this is one of the diagnostic attributes, then we have to\n          initialize 'location_t' and 'tree' at runtime.  */\n       else if (info.format_type == gcc_diag_format_type\n \t       || info.format_type == gcc_cdiag_format_type\n \t       || info.format_type == gcc_cxxdiag_format_type)\n-\tinit_dynamic_diag_info();\n+\tinit_dynamic_diag_info ();\n       else\n-\tgcc_unreachable();\n+\tgcc_unreachable ();\n     }\n \n   return NULL_TREE;"}, {"sha": "177af983d8d0048d484704ce14f7a6aa1508f6cd", "filename": "gcc/c-incpath.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-incpath.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-incpath.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-incpath.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -37,7 +37,7 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n # define INO_T_EQ(A, B) (!memcmp (&(A), &(B), sizeof (A)))\n # define INO_T_COPY(DEST, SRC) memcpy(&(DEST), &(SRC), sizeof (SRC))\n #else\n-# if (defined _WIN32 && ! defined (_UWIN)) || defined __MSDOS__\n+# if (defined _WIN32 && !defined (_UWIN)) || defined __MSDOS__\n #  define INO_T_EQ(A, B) 0\n # else\n #  define INO_T_EQ(A, B) ((A) == (B))"}, {"sha": "98f60f639d40165e8cd2cf372b1895d336dc2e29", "filename": "gcc/c-lex.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -121,9 +121,9 @@ get_fileinfo (const char *name)\n   struct c_fileinfo *fi;\n \n   if (!file_info_tree)\n-    file_info_tree = splay_tree_new ((splay_tree_compare_fn)strcmp,\n+    file_info_tree = splay_tree_new ((splay_tree_compare_fn) strcmp,\n \t\t\t\t     0,\n-\t\t\t\t     (splay_tree_delete_value_fn)free);\n+\t\t\t\t     (splay_tree_delete_value_fn) free);\n \n   n = splay_tree_lookup (file_info_tree, (splay_tree_key) name);\n   if (n)\n@@ -172,7 +172,7 @@ dump_time_statistics (void)\n   print_time (\"header files (total)\", header_time);\n   print_time (\"main file (total)\", this_time - body_time);\n   fprintf (stderr, \"ratio = %g : 1\\n\",\n-\t   (double)header_time / (double)(this_time - body_time));\n+\t   (double) header_time / (double) (this_time - body_time));\n   fprintf (stderr, \"\\n******\\n\");\n \n   splay_tree_foreach (file_info_tree, dump_one_header, 0);\n@@ -184,14 +184,14 @@ cb_ident (cpp_reader * ARG_UNUSED (pfile),\n \t  const cpp_string * ARG_UNUSED (str))\n {\n #ifdef ASM_OUTPUT_IDENT\n-  if (! flag_no_ident)\n+  if (!flag_no_ident)\n     {\n       /* Convert escapes in the string.  */\n       cpp_string cstr = { 0, 0 };\n       if (cpp_interpret_string (pfile, str, 1, &cstr, false))\n \t{\n \t  ASM_OUTPUT_IDENT (asm_out_file, (const char *) cstr.text);\n-\t  free ((void *)cstr.text);\n+\t  free ((void *) cstr.text);\n \t}\n     }\n #endif\n@@ -225,7 +225,7 @@ fe_file_change (const struct line_map *new_map)\n     {\n       /* Don't stack the main buffer on the input stack;\n \t we already did in compile_file.  */\n-      if (! MAIN_FILE_P (new_map))\n+      if (!MAIN_FILE_P (new_map))\n \t{\n #ifdef USE_MAPPED_LOCATION\n           int included_at = LAST_SOURCE_LINE_LOCATION (new_map - 1);\n@@ -437,7 +437,7 @@ c_lex_with_flags (tree *value, unsigned char *cpp_flags)\n       /* else fall through */\n \n     case CPP_PRAGMA:\n-      *value = build_string (tok->val.str.len, (char *)tok->val.str.text);\n+      *value = build_string (tok->val.str.len, (char *) tok->val.str.text);\n       break;\n \n       /* These tokens should not be visible outside cpplib.  */\n@@ -451,7 +451,7 @@ c_lex_with_flags (tree *value, unsigned char *cpp_flags)\n       break;\n     }\n \n-  if (! no_more_pch)\n+  if (!no_more_pch)\n     {\n       no_more_pch = true;\n       c_common_no_more_pch ();\n@@ -490,8 +490,8 @@ narrowest_unsigned_type (unsigned HOST_WIDE_INT low,\n     {\n       tree upper = TYPE_MAX_VALUE (integer_types[itk]);\n \n-      if ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) > high\n-\t  || ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) == high\n+      if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) > high\n+\t  || ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) == high\n \t      && TREE_INT_CST_LOW (upper) >= low))\n \treturn itk;\n     }\n@@ -518,8 +518,8 @@ narrowest_signed_type (unsigned HOST_WIDE_INT low,\n     {\n       tree upper = TYPE_MAX_VALUE (integer_types[itk]);\n       \n-      if ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) > high\n-\t  || ((unsigned HOST_WIDE_INT)TREE_INT_CST_HIGH (upper) == high\n+      if ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) > high\n+\t  || ((unsigned HOST_WIDE_INT) TREE_INT_CST_HIGH (upper) == high\n \t      && TREE_INT_CST_LOW (upper) >= low))\n \treturn itk;\n     }\n@@ -592,7 +592,7 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n \n   if (itk > itk_unsigned_long\n       && (flags & CPP_N_WIDTH) != CPP_N_LARGE\n-      && ! in_system_header && ! flag_isoc99)\n+      && !in_system_header && !flag_isoc99)\n     pedwarn (\"integer constant is too large for %qs type\",\n \t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n@@ -741,8 +741,8 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n        ? cpp_interpret_string : cpp_interpret_string_notranslate)\n       (parse_in, strs, count, &istr, wide))\n     {\n-      value = build_string (istr.len, (char *)istr.text);\n-      free ((void *)istr.text);\n+      value = build_string (istr.len, (char *) istr.text);\n+      free ((void *) istr.text);\n \n       if (c_lex_string_translate == -1)\n \t{\n@@ -752,17 +752,17 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string)\n \t     then the untranslated parsing will always succeed.  */\n \t  gcc_assert (xlated);\n \t  \n-\t  if (TREE_STRING_LENGTH (value) != (int)istr.len\n-\t      || 0 != strncmp (TREE_STRING_POINTER (value), (char *)istr.text,\n+\t  if (TREE_STRING_LENGTH (value) != (int) istr.len\n+\t      || 0 != strncmp (TREE_STRING_POINTER (value), (char *) istr.text,\n \t\t\t       istr.len))\n \t    {\n \t      /* Arrange for us to return the untranslated string in\n \t\t *valp, but to set up the C type of the translated\n \t\t one.  */\n-\t      *valp = build_string (istr.len, (char *)istr.text);\n+\t      *valp = build_string (istr.len, (char *) istr.text);\n \t      valp = &TREE_CHAIN (*valp);\n \t    }\n-\t  free ((void *)istr.text);\n+\t  free ((void *) istr.text);\n \t}\n     }\n   else"}, {"sha": "278529ec99455bad81ceacfc2de4029a481d71ec", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -93,7 +93,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n       goto cannot_inline;\n     }\n \n-  if (! function_attribute_inlinable_p (fn))\n+  if (!function_attribute_inlinable_p (fn))\n     {\n       if (do_warning)\n \twarning (\"%Jfunction %qF can never be inlined because it uses \"\n@@ -117,7 +117,7 @@ c_cannot_inline_tree_fn (tree *fnp)\n \t}\n     }\n \n-  if (! DECL_FILE_SCOPE_P (fn))\n+  if (!DECL_FILE_SCOPE_P (fn))\n     {\n       /* If a nested function has pending sizes, we may have already\n          saved them.  */"}, {"sha": "0377a5d3fee41d1f0ac6294fb66e8166a3b30d6e", "filename": "gcc/c-opts.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -1036,7 +1036,7 @@ c_common_post_options (const char **pfilename)\n     }\n \n   if (flag_working_directory\n-      && flag_preprocess_only && ! flag_no_line_commands)\n+      && flag_preprocess_only && !flag_no_line_commands)\n     pp_dir_change (parse_in, get_src_pwd ());\n \n   return flag_preprocess_only;\n@@ -1343,7 +1343,7 @@ push_command_line_include (void)\n     {\n       struct deferred_opt *opt = &deferred_opts[include_cursor++];\n \n-      if (! cpp_opts->preprocessed && opt->code == OPT_include\n+      if (!cpp_opts->preprocessed && opt->code == OPT_include\n \t  && cpp_push_include (parse_in, opt->arg))\n \treturn;\n     }\n@@ -1354,7 +1354,7 @@ push_command_line_include (void)\n       /* -Wunused-macros should only warn about macros defined hereafter.  */\n       cpp_opts->warn_unused_macros = warn_unused_macros;\n       /* Restore the line map from <command line>.  */\n-      if (! cpp_opts->preprocessed)\n+      if (!cpp_opts->preprocessed)\n \tcpp_change_file (parse_in, LC_RENAME, main_input_filename);\n \n       /* Set this here so the client can change the option if it wishes,\n@@ -1380,7 +1380,7 @@ cb_file_change (cpp_reader * ARG_UNUSED (pfile),\n void\n cb_dir_change (cpp_reader * ARG_UNUSED (pfile), const char *dir)\n {\n-  if (! set_src_pwd (dir))\n+  if (!set_src_pwd (dir))\n     warning (\"too late for # directive to set debug directory\");\n }\n "}, {"sha": "b682700dc5417f9379d5d36bd8d805cd948a0127", "filename": "gcc/c-parse.in", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -386,7 +386,7 @@ extdefs:\n \tsave_obstack_position { $<dsptype>$ = NULL; } extdef\n \t\t{ obstack_free (&parser_obstack, $1); }\n \t| extdefs save_obstack_position\n-\t\t{ $<dsptype>$ = NULL; ggc_collect(); } extdef\n+\t\t{ $<dsptype>$ = NULL; ggc_collect (); } extdef\n \t\t{ obstack_free (&parser_obstack, $2); }\n \t;\n \n@@ -430,8 +430,8 @@ datadef:\n \f\n fndef:\n \t  declspecs_ts setspecs declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tall_prefix_attributes))\n+\t\t{ if (!start_function (current_declspecs, $3,\n+\t\t\t\t       all_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls save_location\n@@ -443,8 +443,8 @@ fndef:\n \t| declspecs_ts setspecs declarator error\n \t\t{ POP_DECLSPEC_STACK; }\n \t| declspecs_nots setspecs notype_declarator\n-\t\t{ if (! start_function (current_declspecs, $3,\n-\t\t\t\t\tall_prefix_attributes))\n+\t\t{ if (!start_function (current_declspecs, $3,\n+\t\t\t\t       all_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls save_location\n@@ -456,8 +456,8 @@ fndef:\n \t| declspecs_nots setspecs notype_declarator error\n \t\t{ POP_DECLSPEC_STACK; }\n \t| setspecs notype_declarator\n-\t\t{ if (! start_function (current_declspecs, $2,\n-\t\t\t\t\tall_prefix_attributes))\n+\t\t{ if (!start_function (current_declspecs, $2,\n+\t\t\t\t       all_prefix_attributes))\n \t\t    YYERROR1;\n \t\t}\n \t  old_style_parm_decls save_location\n@@ -690,7 +690,7 @@ primary:\n \t\t  finish_init ();\n \t\t  maybe_warn_string_init (type, init);\n \n-\t\t  if (pedantic && ! flag_isoc99)\n+\t\t  if (pedantic && !flag_isoc99)\n \t\t    pedwarn (\"ISO C90 forbids compound literals\");\n \t\t  $$.value = build_compound_literal (type, constructor);\n \t\t  $$.original_code = ERROR_MARK;\n@@ -1433,7 +1433,7 @@ initlist1:\n    It may use braces.  */\n initelt:\n \t  designator_list '=' initval\n-\t\t{ if (pedantic && ! flag_isoc99)\n+\t\t{ if (pedantic && !flag_isoc99)\n \t\t    pedwarn (\"ISO C90 forbids specifying subobject to initialize\"); }\n \t| designator initval\n \t\t{ if (pedantic)\n@@ -1479,8 +1479,8 @@ nested_function:\n \t\t    pedwarn (\"ISO C forbids nested functions\");\n \n \t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tall_prefix_attributes))\n+\t\t  if (!start_function (current_declspecs, $1,\n+\t\t\t\t       all_prefix_attributes))\n \t\t    {\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n@@ -1509,8 +1509,8 @@ notype_nested_function:\n \t\t    pedwarn (\"ISO C forbids nested functions\");\n \n \t\t  push_function_context ();\n-\t\t  if (! start_function (current_declspecs, $1,\n-\t\t\t\t\tall_prefix_attributes))\n+\t\t  if (!start_function (current_declspecs, $1,\n+\t\t\t\t       all_prefix_attributes))\n \t\t    {\n \t\t      pop_function_context ();\n \t\t      YYERROR1;\n@@ -1692,7 +1692,7 @@ maybecomma:\n maybecomma_warn:\n \t  /* empty */\n \t| ','\n-\t\t{ if (pedantic && ! flag_isoc99)\n+\t\t{ if (pedantic && !flag_isoc99)\n \t\t    pedwarn (\"comma at end of enumerator list\"); }\n \t;\n \n@@ -2568,7 +2568,7 @@ identifiers_or_typenames:\n \n extension:\n \tEXTENSION\n-\t\t{ $$ = SAVE_EXT_FLAGS();\n+\t\t{ $$ = SAVE_EXT_FLAGS ();\n \t\t  pedantic = 0;\n \t\t  warn_pointer_arith = 0;\n \t\t  warn_traditional = 0;"}, {"sha": "8b2123580874b50780fa7534f20e413bd5e1d212", "filename": "gcc/c-pch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-pch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-pch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pch.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -99,7 +99,7 @@ static const char *get_ident (void);\n    format.  */\n \n static const char *\n-get_ident(void)\n+get_ident (void)\n {\n   static char result[IDENT_LENGTH];\n   static const char template[IDENT_LENGTH] = \"gpch.012\";\n@@ -122,7 +122,7 @@ pch_init (void)\n   void *target_validity;\n   static const char partial_pch[IDENT_LENGTH] = \"gpcWrite\";\n   \n-  if (! pch_file)\n+  if (!pch_file)\n     return;\n   \n   f = fopen (pch_file, \"w+b\");\n@@ -484,7 +484,7 @@ c_common_pch_pragma (cpp_reader *pfile)\n       return;\n     }\n \n-  if (! cpp_get_options (pfile)->preprocessed)\n+  if (!cpp_get_options (pfile)->preprocessed)\n     {\n       error (\"pch_preprocess pragma should only be used with -fpreprocessed\");\n       inform (\"use #include instead\");"}, {"sha": "95563995e7c2547ec9839477f48d3a4fb5ad0f1a", "filename": "gcc/c-ppoutput.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-ppoutput.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-ppoutput.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-ppoutput.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -254,7 +254,7 @@ print_line (source_location src_loc, const char *special_flags)\n       /* cpp_quote_string does not nul-terminate, so we have to do it\n \t ourselves.  */\n       p = cpp_quote_string (to_file_quoted,\n-\t\t\t    (unsigned char *)map->to_file, to_file_len);\n+\t\t\t    (unsigned char *) map->to_file, to_file_len);\n       *p = '\\0';\n       fprintf (print.outf, \"# %u \\\"%s\\\"%s\", print.src_line,\n \t       to_file_quoted, special_flags);"}, {"sha": "f59bfc07023a36ac91fea037f149e48b82f003be", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -95,7 +95,7 @@ pop_alignment (tree id)\n   align_stack * entry;\n       \n   if (alignment_stack == NULL)\n-    GCC_BAD(\"#pragma pack (pop) encountered without matching #pragma pack (push)\");\n+    GCC_BAD (\"#pragma pack (pop) encountered without matching #pragma pack (push)\");\n \n   /* If we got an identifier, strip away everything above the target\n      entry so that the next step will restore the state just below it.  */\n@@ -122,9 +122,9 @@ pop_alignment (tree id)\n #else  /* not HANDLE_PRAGMA_PACK_PUSH_POP */\n #define SET_GLOBAL_ALIGNMENT(ALIGN) (maximum_field_alignment = (ALIGN))\n #define push_alignment(ID, N) \\\n-    GCC_BAD(\"#pragma pack(push[, id], <n>) is not supported on this target\")\n+    GCC_BAD (\"#pragma pack(push[, id], <n>) is not supported on this target\")\n #define pop_alignment(ID) \\\n-    GCC_BAD(\"#pragma pack(pop[, id], <n>) is not supported on this target\")\n+    GCC_BAD (\"#pragma pack(pop[, id], <n>) is not supported on this target\")\n #endif /* HANDLE_PRAGMA_PACK_PUSH_POP */\n \n /* #pragma pack ()"}, {"sha": "27c8cd47c83815f283edbccd5478092505f9a146", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f75a25471fd0a824043ee42e33b2197eeb903f0/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=3f75a25471fd0a824043ee42e33b2197eeb903f0", "patch": "@@ -310,9 +310,9 @@ composite_type (tree t1, tree t2)\n \tint i;\n \n \t/* Save space: see if the result is identical to one of the args.  */\n-\tif (valtype == TREE_TYPE (t1) && ! TYPE_ARG_TYPES (t2))\n+\tif (valtype == TREE_TYPE (t1) && !TYPE_ARG_TYPES (t2))\n \t  return build_type_attribute_variant (t1, attributes);\n-\tif (valtype == TREE_TYPE (t2) && ! TYPE_ARG_TYPES (t1))\n+\tif (valtype == TREE_TYPE (t2) && !TYPE_ARG_TYPES (t1))\n \t  return build_type_attribute_variant (t2, attributes);\n \n \t/* Simple way if one arg fails to specify argument types.  */\n@@ -637,7 +637,7 @@ comptypes (tree type1, tree type2)\n     return 1;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n-  if (! (attrval = targetm.comp_type_attributes (t1, t2)))\n+  if (!(attrval = targetm.comp_type_attributes (t1, t2)))\n      return 0;\n \n   /* 1 if no need for warning yet, 2 if warning cause has been seen.  */\n@@ -675,13 +675,13 @@ comptypes (tree type1, tree type2)\n \tif (d1 == 0 || d2 == 0 || d1 == d2)\n \t  break;\n \n-\td1_zero = ! TYPE_MAX_VALUE (d1);\n-\td2_zero = ! TYPE_MAX_VALUE (d2);\n+\td1_zero = !TYPE_MAX_VALUE (d1);\n+\td2_zero = !TYPE_MAX_VALUE (d2);\n \n-\td1_variable = (! d1_zero\n+\td1_variable = (!d1_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d1)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d1)) != INTEGER_CST));\n-\td2_variable = (! d2_zero\n+\td2_variable = (!d2_zero\n \t\t       && (TREE_CODE (TYPE_MIN_VALUE (d2)) != INTEGER_CST\n \t\t\t   || TREE_CODE (TYPE_MAX_VALUE (d2)) != INTEGER_CST));\n \n@@ -690,8 +690,8 @@ comptypes (tree type1, tree type2)\n \tif (d1_zero && d2_zero)\n \t  break;\n \tif (d1_zero || d2_zero\n-\t    || ! tree_int_cst_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2))\n-\t    || ! tree_int_cst_equal (TYPE_MAX_VALUE (d1), TYPE_MAX_VALUE (d2)))\n+\t    || !tree_int_cst_equal (TYPE_MIN_VALUE (d1), TYPE_MIN_VALUE (d2))\n+\t    || !tree_int_cst_equal (TYPE_MAX_VALUE (d1), TYPE_MAX_VALUE (d2)))\n \t  val = 0;\n \n         break;\n@@ -915,7 +915,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \t\t    break;\n \t\t  }\n \t    tagged_tu_seen_base = tts.next;\n-\t    if (! ok)\n+\t    if (!ok)\n \t      return 0;\n \t  }\n \treturn needs_warning ? 2 : 1;\n@@ -1063,8 +1063,8 @@ type_lists_compatible_p (tree args1, tree args2)\n       else if (TREE_CODE (TREE_VALUE (args1)) == ERROR_MARK\n \t       || TREE_CODE (TREE_VALUE (args2)) == ERROR_MARK)\n \t;\n-      else if (! (newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)),\n-\t\t\t\t      TYPE_MAIN_VARIANT (TREE_VALUE (args2)))))\n+      else if (!(newval = comptypes (TYPE_MAIN_VARIANT (TREE_VALUE (args1)),\n+\t\t\t\t     TYPE_MAIN_VARIANT (TREE_VALUE (args2)))))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n@@ -1143,7 +1143,7 @@ decl_constant_value (tree decl)\n \t isn't valid for a PARM_DECL.  */\n       current_function_decl != 0\n       && TREE_CODE (decl) != PARM_DECL\n-      && ! TREE_THIS_VOLATILE (decl)\n+      && !TREE_THIS_VOLATILE (decl)\n       && TREE_READONLY (decl)\n       && DECL_INITIAL (decl) != 0\n       && TREE_CODE (DECL_INITIAL (decl)) != ERROR_MARK\n@@ -1631,7 +1631,7 @@ build_array_ref (tree array, tree index)\n \t to access a non-existent part of the register.  */\n       if (TREE_CODE (index) == INTEGER_CST\n \t  && TYPE_DOMAIN (TREE_TYPE (array))\n-\t  && ! int_fits_type_p (index, TYPE_DOMAIN (TREE_TYPE (array))))\n+\t  && !int_fits_type_p (index, TYPE_DOMAIN (TREE_TYPE (array))))\n \t{\n \t  if (!c_mark_addressable (array))\n \t    return error_mark_node;\n@@ -1644,7 +1644,7 @@ build_array_ref (tree array, tree index)\n \t    foo = TREE_OPERAND (foo, 0);\n \t  if (TREE_CODE (foo) == VAR_DECL && C_DECL_REGISTER (foo))\n \t    pedwarn (\"ISO C forbids subscripting %<register%> array\");\n-\t  else if (! flag_isoc99 && ! lvalue_p (foo))\n+\t  else if (!flag_isoc99 && !lvalue_p (foo))\n \t    pedwarn (\"ISO C90 forbids subscripting non-lvalue array\");\n \t}\n \n@@ -1936,11 +1936,11 @@ build_function_call (tree function, tree params)\n      ??? This doesn't work for Objective-C because objc_comptypes\n      refuses to compare function prototypes, yet the compiler appears\n      to build calls that are flagged as invalid by C's comptypes.  */\n-  if (! c_dialect_objc ()\n+  if (!c_dialect_objc ()\n       && TREE_CODE (function) == NOP_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (function, 0)) == ADDR_EXPR\n       && TREE_CODE (tem = TREE_OPERAND (tem, 0)) == FUNCTION_DECL\n-      && ! comptypes (fntype, TREE_TYPE (tem)))\n+      && !comptypes (fntype, TREE_TYPE (tem)))\n     {\n       tree return_type = TREE_TYPE (fntype);\n       tree trap = build_function_call (built_in_decls[BUILT_IN_TRAP],\n@@ -2905,7 +2905,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t      /* Do not warn if the result type is signed, since the\n \t\t signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n-\t      if (! TYPE_UNSIGNED (result_type))\n+\t      if (!TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n \t      /* Do not warn if the signed quantity is an unsuffixed\n \t\t integer literal (or some static constant expression\n@@ -2958,7 +2958,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n     }\n   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)\n     {\n-      if (! integer_zerop (op2))\n+      if (!integer_zerop (op2))\n \tpedwarn (\"pointer/integer type mismatch in conditional expression\");\n       else\n \t{\n@@ -3018,13 +3018,13 @@ build_compound_expr (tree expr1, tree expr2)\n   if (integer_zerop (expr2))\n     expr2 = non_lvalue (expr2);\n \n-  if (! TREE_SIDE_EFFECTS (expr1))\n+  if (!TREE_SIDE_EFFECTS (expr1))\n     {\n       /* The left-hand operand of a comma expression is like an expression\n          statement: with -Wextra or -Wunused, we should warn if it doesn't have\n \t any side-effects, unless it was explicitly cast to (void).  */\n       if (warn_unused_value\n-           && ! (TREE_CODE (expr1) == CONVERT_EXPR\n+           && !(TREE_CODE (expr1) == CONVERT_EXPR\n                 && VOID_TYPE_P (TREE_TYPE (expr1))))\n         warning (\"left-hand operand of comma expression has no effect\");\n     }\n@@ -3479,7 +3479,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \n   /* Conversion to a transparent union from its member types.\n      This applies only to function arguments.  */\n-  else if (codel == UNION_TYPE && TYPE_TRANSPARENT_UNION (type) && ! errtype)\n+  else if (codel == UNION_TYPE && TYPE_TRANSPARENT_UNION (type) && !errtype)\n     {\n       tree memb_types;\n       tree marginal_memb_type = 0;\n@@ -3519,7 +3519,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t    break;\n \n \t\t  /* Keep looking for a better type, but remember this one.  */\n-\t\t  if (! marginal_memb_type)\n+\t\t  if (!marginal_memb_type)\n \t\t    marginal_memb_type = memb_type;\n \t\t}\n \t    }\n@@ -3536,7 +3536,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \n       if (memb_types || marginal_memb_type)\n \t{\n-\t  if (! memb_types)\n+\t  if (!memb_types)\n \t    {\n \t      /* We have only a marginally acceptable member type;\n \t\t it needs a warning.  */\n@@ -3563,7 +3563,7 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n \t\t\t\t     parmnum);\n \t    }\n \n-\t  if (pedantic && ! DECL_IN_SYSTEM_HEADER (fundecl))\n+\t  if (pedantic && !DECL_IN_SYSTEM_HEADER (fundecl))\n \t    pedwarn (\"ISO C prohibits argument conversion to union type\");\n \n \t  return build1 (NOP_EXPR, type, rhs);\n@@ -3650,12 +3650,12 @@ convert_for_assignment (tree type, tree rhs, const char *errtype,\n       /* An explicit constant 0 can convert to a pointer,\n \t or one that results from arithmetic, even including\n \t a cast to integer type.  */\n-      if (! (TREE_CODE (rhs) == INTEGER_CST && integer_zerop (rhs))\n+      if (!(TREE_CODE (rhs) == INTEGER_CST && integer_zerop (rhs))\n \t  &&\n-\t  ! (TREE_CODE (rhs) == NOP_EXPR\n-\t     && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n-\t     && TREE_CODE (TREE_OPERAND (rhs, 0)) == INTEGER_CST\n-\t     && integer_zerop (TREE_OPERAND (rhs, 0))))\n+\t  !(TREE_CODE (rhs) == NOP_EXPR\n+\t    && TREE_CODE (TREE_TYPE (rhs)) == INTEGER_TYPE\n+\t    && TREE_CODE (TREE_OPERAND (rhs, 0)) == INTEGER_CST\n+\t    && integer_zerop (TREE_OPERAND (rhs, 0))))\n \t  warn_for_assignment (\"%s makes pointer from integer without a cast\",\n \t\t\t       errtype, funname, parmnum);\n \n@@ -3704,7 +3704,7 @@ c_convert_parm_for_inlining (tree parm, tree value, tree fn, int argnum)\n \n   /* If FN was prototyped, the value has been converted already\n      in convert_arguments.  */\n-  if (! value || TYPE_ARG_TYPES (TREE_TYPE (fn)))\n+  if (!value || TYPE_ARG_TYPES (TREE_TYPE (fn)))\n     return value;\n \n   type = TREE_TYPE (parm);\n@@ -3806,7 +3806,7 @@ store_init_value (tree decl, tree init)\n   /* Store the expression if valid; else report error.  */\n \n   if (warn_traditional && !in_system_header\n-      && AGGREGATE_TYPE_P (TREE_TYPE (decl)) && ! TREE_STATIC (decl))\n+      && AGGREGATE_TYPE_P (TREE_TYPE (decl)) && !TREE_STATIC (decl))\n     warning (\"traditional C rejects automatic aggregate initialization\");\n \n   DECL_INITIAL (decl) = value;\n@@ -4232,7 +4232,7 @@ digest_init (tree type, tree init, bool strict_string, int require_constant)\n       /* Check to see if we have already given an error message.  */\n       if (inside_init == error_mark_node)\n \t;\n-      else if (require_constant && ! TREE_CONSTANT (inside_init))\n+      else if (require_constant && !TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element is not constant\");\n \t  inside_init = error_mark_node;\n@@ -4848,7 +4848,7 @@ pop_init_level (int implicit)\n   if (constructor_type && constructor_fields\n       && TREE_CODE (constructor_type) == ARRAY_TYPE\n       && TYPE_DOMAIN (constructor_type)\n-      && ! TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n+      && !TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)))\n     {\n       /* Silently discard empty initializations.  The parser will\n \t already have pedwarned for empty brackets.  */\n@@ -4879,7 +4879,7 @@ pop_init_level (int implicit)\n     {\n \t/* Do not warn for flexible array members or zero-length arrays.  */\n \twhile (constructor_unfilled_fields\n-\t       && (! DECL_SIZE (constructor_unfilled_fields)\n+\t       && (!DECL_SIZE (constructor_unfilled_fields)\n \t\t   || integer_zerop (DECL_SIZE (constructor_unfilled_fields))))\n \t  constructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n \n@@ -5854,7 +5854,7 @@ output_pending_init_elements (int all)\n \n   /* Ordinarily return, but not if we want to output all\n      and there are elements left.  */\n-  if (! (all && next != 0))\n+  if (!(all && next != 0))\n     return;\n \n   /* If it's not incremental, just skip over the gap, so that after\n@@ -6395,7 +6395,7 @@ c_finish_return (tree retval)\n \t      {\n \t\ttree op1 = TREE_OPERAND (inner, 1);\n \n-\t\twhile (! POINTER_TYPE_P (TREE_TYPE (op1))\n+\t\twhile (!POINTER_TYPE_P (TREE_TYPE (op1))\n \t\t       && (TREE_CODE (op1) == NOP_EXPR\n \t\t\t   || TREE_CODE (op1) == NON_LVALUE_EXPR\n \t\t\t   || TREE_CODE (op1) == CONVERT_EXPR))\n@@ -6416,8 +6416,8 @@ c_finish_return (tree retval)\n \t\tinner = TREE_OPERAND (inner, 0);\n \n \t      if (DECL_P (inner)\n-\t\t  && ! DECL_EXTERNAL (inner)\n-\t\t  && ! TREE_STATIC (inner)\n+\t\t  && !DECL_EXTERNAL (inner)\n+\t\t  && !TREE_STATIC (inner)\n \t\t  && DECL_CONTEXT (inner) == current_function_decl)\n \t\twarning (\"function returns address of local variable\");\n \t      break;\n@@ -6477,7 +6477,7 @@ c_start_case (tree exp)\n       code = TREE_CODE (TREE_TYPE (exp));\n       orig_type = TREE_TYPE (exp);\n \n-      if (! INTEGRAL_TYPE_P (orig_type)\n+      if (!INTEGRAL_TYPE_P (orig_type)\n \t  && code != ERROR_MARK)\n \t{\n \t  error (\"switch quantity not an integer\");\n@@ -7093,7 +7093,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t       dividing by something we know != -1.  */\n \t    shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n \t\t       || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t   && ! integer_all_onesp (op1)));\n+\t\t\t   && !integer_all_onesp (op1)));\n \t  common = 1;\n \t}\n       break;\n@@ -7120,7 +7120,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     only if unsigned or if dividing by something we know != -1.  */\n \t  shorten = (TYPE_UNSIGNED (TREE_TYPE (orig_op0))\n \t\t     || (TREE_CODE (op1) == INTEGER_CST\n-\t\t\t && ! integer_all_onesp (op1)));\n+\t\t\t && !integer_all_onesp (op1)));\n \t  common = 1;\n \t}\n       break;\n@@ -7158,7 +7158,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\twarning (\"right shift count is negative\");\n \t      else\n \t\t{\n-\t\t  if (! integer_zerop (op1))\n+\t\t  if (!integer_zerop (op1))\n \t\t    short_shift = 1;\n \n \t\t  if (compare_tree_int (op1, TYPE_PRECISION (type0)) >= 0)\n@@ -7523,8 +7523,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n \t  if (warn_sign_compare && skip_evaluation == 0)\n \t    {\n-\t      int op0_signed = ! TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n-\t      int op1_signed = ! TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n+\t      int op0_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op0));\n+\t      int op1_signed = !TYPE_UNSIGNED (TREE_TYPE (orig_op1));\n \t      int unsignedp0, unsignedp1;\n \t      tree primop0 = get_narrower (op0, &unsignedp0);\n \t      tree primop1 = get_narrower (op1, &unsignedp1);\n@@ -7543,7 +7543,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t Do not warn if the comparison is being done in a signed type,\n \t\t since the signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n-\t      if (! TYPE_UNSIGNED (result_type))\n+\t      if (!TYPE_UNSIGNED (result_type))\n \t\t/* OK */;\n               /* Do not warn if both operands are the same signedness.  */\n               else if (op0_signed == op1_signed)\n@@ -7578,7 +7578,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t  else if (TREE_CODE (uop) == INTEGER_CST\n \t\t\t   && TREE_CODE (TREE_TYPE (uop)) == ENUMERAL_TYPE\n \t\t\t   && int_fits_type_p\n-\t\t\t   (TYPE_MAX_VALUE (TREE_TYPE(uop)),\n+\t\t\t   (TYPE_MAX_VALUE (TREE_TYPE (uop)),\n \t\t\t    c_common_signed_type (result_type)))\n \t\t    /* OK */;\n \t\t  else\n@@ -7626,7 +7626,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t      if (bits < TYPE_PRECISION (result_type)\n \t\t\t  && bits < HOST_BITS_PER_WIDE_INT && unsignedp)\n \t\t\t{\n-\t\t\t  mask = (~ (HOST_WIDE_INT) 0) << bits;\n+\t\t\t  mask = (~(HOST_WIDE_INT) 0) << bits;\n \t\t\t  if ((mask & constant) != mask)\n \t\t\t    warning (\"comparison of promoted ~unsigned with constant\");\n \t\t\t}\n@@ -7654,7 +7654,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       return error_mark_node;\n     }\n \n-  if (! converted)\n+  if (!converted)\n     {\n       if (TREE_TYPE (op0) != result_type)\n \top0 = convert (result_type, op0);"}]}