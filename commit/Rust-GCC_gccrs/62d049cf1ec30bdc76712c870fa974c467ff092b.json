{"sha": "62d049cf1ec30bdc76712c870fa974c467ff092b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJkMDQ5Y2YxZWMzMGJkYzc2NzEyYzg3MGZhOTc0YzQ2N2ZmMDkyYg==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2009-02-25T18:12:29Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2009-02-25T18:12:29Z"}, "message": "regmove.c (regmove_optimize): Conform to struct rtl_opt_pass execute function prototype.\n\n2009-02-25  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* regmove.c (regmove_optimize): Conform to struct rtl_opt_pass\n\texecute function prototype.  Get f and nregs from max_reg_num\n\tand get_insns.  Remove the first backward pass as it's dead,\n\tguard the forward pass by flag_expensive_optimizations.\n\t(rest_of_handle_regmove): Delete.\n\t(pass_regmove): Replace it with regmove_optimize.\n\nFrom-SVN: r144429", "tree": {"sha": "c11ea245aed067520c5c29a56b9929cdd2cb3bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c11ea245aed067520c5c29a56b9929cdd2cb3bae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62d049cf1ec30bdc76712c870fa974c467ff092b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d049cf1ec30bdc76712c870fa974c467ff092b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62d049cf1ec30bdc76712c870fa974c467ff092b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62d049cf1ec30bdc76712c870fa974c467ff092b/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f618d33ef115544bb371c67ff937e9ce97969712", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f618d33ef115544bb371c67ff937e9ce97969712", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f618d33ef115544bb371c67ff937e9ce97969712"}], "stats": {"total": 60, "additions": 24, "deletions": 36}, "files": [{"sha": "2b02471d1bd66e89c921abc7ea322f1b8895a63a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d049cf1ec30bdc76712c870fa974c467ff092b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d049cf1ec30bdc76712c870fa974c467ff092b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=62d049cf1ec30bdc76712c870fa974c467ff092b", "patch": "@@ -1,3 +1,12 @@\n+2009-02-25  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* regmove.c (regmove_optimize): Conform to struct rtl_opt_pass\n+\texecute function prototype.  Get f and nregs from max_reg_num\n+\tand get_insns.  Remove the first backward pass as it's dead,\n+\tguard the forward pass by flag_expensive_optimizations.\n+\t(rest_of_handle_regmove): Delete.\n+\t(pass_regmove): Replace it with regmove_optimize.\n+\n 2009-02-25  Martin Jambor  <mjambor@suse.cz>\n \n \tPR tree-optimization/39259"}, {"sha": "8ce0ea00da71fb22b44ad1670b718de5fe8cfaac", "filename": "gcc/regmove.c", "status": "modified", "additions": 15, "deletions": 36, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62d049cf1ec30bdc76712c870fa974c467ff092b/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62d049cf1ec30bdc76712c870fa974c467ff092b/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=62d049cf1ec30bdc76712c870fa974c467ff092b", "patch": "@@ -882,25 +882,21 @@ fixup_match_2 (rtx insn, rtx dst, rtx src, rtx offset)\n   return 0;\n }\n \n-/* Main entry for the register move optimization.\n-   F is the first instruction.\n-   NREGS is one plus the highest pseudo-reg number used in the instruction.\n-   REGMOVE_DUMP_FILE is a stream for output of a trace of actions taken\n-   (or 0 if none should be output).  */\n+/* Main entry for the register move optimization.  */\n \n-static void\n-regmove_optimize (rtx f, int nregs)\n+static unsigned int\n+regmove_optimize (void)\n {\n   rtx insn;\n   struct match match;\n-  int pass;\n   int i;\n   rtx copy_src, copy_dst;\n+  int nregs = max_reg_num ();\n \n   /* ??? Hack.  Regmove doesn't examine the CFG, and gets mightily\n      confused by non-call exceptions ending blocks.  */\n   if (flag_non_call_exceptions)\n-    return;\n+    return 0;\n \n   df_note_add_problem ();\n   df_analyze ();\n@@ -912,35 +908,26 @@ regmove_optimize (rtx f, int nregs)\n   for (i = nregs; --i >= 0; )\n     regno_src_regno[i] = -1;\n \n-  /* A forward/backward pass.  Replace output operands with input operands.  */\n+  /* A forward pass.  Replace output operands with input operands.  */\n \n-  for (pass = 0; pass <= 2; pass++)\n+  if (flag_expensive_optimizations)\n     {\n-      if (! flag_regmove && pass >= flag_expensive_optimizations)\n-\tgoto done;\n-\n       if (dump_file)\n-\tfprintf (dump_file, \"Starting %s pass...\\n\",\n-\t\t pass ? \"backward\" : \"forward\");\n+\tfprintf (dump_file, \"Starting forward pass...\\n\");\n \n-      for (insn = pass ? get_last_insn () : f; insn;\n-\t   insn = pass ? PREV_INSN (insn) : NEXT_INSN (insn))\n+      for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n \t{\n-\t  rtx set;\n-\n-\t  set = single_set (insn);\n+\t  rtx set = single_set (insn);\n \t  if (! set)\n \t    continue;\n \n-\t  if (flag_expensive_optimizations && ! pass\n-\t      && (GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n-\t\t  || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n+\t  if ((GET_CODE (SET_SRC (set)) == SIGN_EXTEND\n+\t       || GET_CODE (SET_SRC (set)) == ZERO_EXTEND)\n \t      && REG_P (XEXP (SET_SRC (set), 0))\n \t      && REG_P (SET_DEST (set)))\n \t    optimize_reg_copy_3 (insn, SET_DEST (set), SET_SRC (set));\n \n-\t  if (flag_expensive_optimizations && ! pass\n-\t      && REG_P (SET_SRC (set))\n+\t  if (REG_P (SET_SRC (set))\n \t      && REG_P (SET_DEST (set)))\n \t    {\n \t      /* If this is a register-register copy where SRC is not dead,\n@@ -1245,7 +1232,6 @@ regmove_optimize (rtx f, int nregs)\n \t}\n     }\n \n- done:\n   /* Clean up.  */\n   free (regno_src_regno);\n   if (reg_set_in_bb)\n@@ -1255,6 +1241,7 @@ regmove_optimize (rtx f, int nregs)\n     }\n   regstat_free_n_sets_and_refs ();\n   regstat_free_ri ();\n+  return 0;\n }\n \n /* Returns nonzero if INSN's pattern has matching constraints for any operand.\n@@ -1356,22 +1343,14 @@ gate_handle_regmove (void)\n   return (optimize > 0 && flag_regmove);\n }\n \n-/* Register allocation pre-pass, to reduce number of moves necessary\n-   for two-address machines.  */\n-static unsigned int\n-rest_of_handle_regmove (void)\n-{\n-  regmove_optimize (get_insns (), max_reg_num ());\n-  return 0;\n-}\n \n struct rtl_opt_pass pass_regmove =\n {\n  {\n   RTL_PASS,\n   \"regmove\",                            /* name */\n   gate_handle_regmove,                  /* gate */\n-  rest_of_handle_regmove,               /* execute */\n+  regmove_optimize,\t\t\t/* execute */\n   NULL,                                 /* sub */\n   NULL,                                 /* next */\n   0,                                    /* static_pass_number */"}]}