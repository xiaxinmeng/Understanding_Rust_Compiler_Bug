{"sha": "71012d9720fc774abd9f586abf40bd5d5643a412", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEwMTJkOTcyMGZjNzc0YWJkOWY1ODZhYmY0MGJkNWQ1NjQzYTQxMg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@redhat.com", "date": "2002-08-19T18:18:12Z"}, "committer": {"name": "Steve Ellcey", "email": "sje@gcc.gnu.org", "date": "2002-08-19T18:18:12Z"}, "message": "machmode.h (SCALAR_INT_MODE_P): New macro to test for scaler integer mode (MODE_INT or MODE_PARTIAL_INT).\n\n\t* machmode.h (SCALAR_INT_MODE_P): New macro to test for\n\tscaler integer mode (MODE_INT or MODE_PARTIAL_INT).\n\t* explow.c (trunc_int_for_mode): Abort when the mode is not\n\ta scaler integer mode.\n\t* combine.c (expand_compound_operation): Don't expand Vector\n\tor Complex modes into shifts.\n\t(expand_field_assignment): Don't do bitwise arithmatic and\n\tshifts on Vector or Complex modes.\n\t(simplify_comparison): Don't call trunc_int_for_mode\n\tfor VOIDmode.\n\t* recog.c (general_operand): Likewise.\n\t(immediate_operand): Likewise.\n\t(nonmemory_operand): Likewise.\n\nCo-Authored-By: Steve Ellcey <sje@cup.hp.com>\n\nFrom-SVN: r56443", "tree": {"sha": "90d5a658b60ca93c1db59343c9ba71bdd464f467", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/90d5a658b60ca93c1db59343c9ba71bdd464f467"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71012d9720fc774abd9f586abf40bd5d5643a412", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71012d9720fc774abd9f586abf40bd5d5643a412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71012d9720fc774abd9f586abf40bd5d5643a412", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71012d9720fc774abd9f586abf40bd5d5643a412/comments", "author": null, "committer": null, "parents": [{"sha": "35fb4cf6116fa7b35673deccfde8b3eb099ea261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35fb4cf6116fa7b35673deccfde8b3eb099ea261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35fb4cf6116fa7b35673deccfde8b3eb099ea261"}], "stats": {"total": 51, "additions": 47, "deletions": 4}, "files": [{"sha": "de73f2549eee61078a7f5f0b41792300c4e8f211", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71012d9720fc774abd9f586abf40bd5d5643a412", "patch": "@@ -1,3 +1,20 @@\n+2002-08-19  Geoffrey Keating  <geoffk@redhat.com>\n+\t    Steve Ellcey  <sje@cup.hp.com>\n+\n+\t* machmode.h (SCALAR_INT_MODE_P): New macro to test for\n+\tscaler integer mode (MODE_INT or MODE_PARTIAL_INT).\n+\t* explow.c (trunc_int_for_mode): Abort when the mode is not\n+\ta scaler integer mode.\n+\t* combine.c (expand_compound_operation): Don't expand Vector\n+\tor Complex modes into shifts.\n+\t(expand_field_assignment): Don't do bitwise arithmatic and\n+\tshifts on Vector or Complex modes.\n+\t(simplify_comparison): Don't call trunc_int_for_mode\n+\tfor VOIDmode.\n+\t* recog.c (general_operand): Likewise.\n+\t(immediate_operand): Likewise.\n+\t(nonmemory_operand): Likewise.\n+\n 2002-08-19  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/rs6000.c (rs6000_emit_set_const): Inline"}, {"sha": "4a2ae3c9743ce6cf0e5e9970e15d7e157a16ae64", "filename": "gcc/combine.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=71012d9720fc774abd9f586abf40bd5d5643a412", "patch": "@@ -5634,6 +5634,12 @@ expand_compound_operation (x)\n       if (GET_MODE_SIZE (GET_MODE (XEXP (x, 0))) > UNITS_PER_WORD)\n \treturn x;\n \n+      /* Reject MODEs that aren't scalar integers because turning vector\n+\t or complex modes into shifts causes problems.  */\n+\n+      if (! SCALAR_INT_MODE_P (GET_MODE (XEXP (x, 0))))\n+\treturn x;\n+\n       len = GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0)));\n       /* If the inner object has VOIDmode (the only way this can happen\n \t is if it is an ASM_OPERANDS), we can't do anything since we don't\n@@ -5655,6 +5661,12 @@ expand_compound_operation (x)\n \t  || GET_MODE (XEXP (x, 0)) == VOIDmode)\n \treturn x;\n \n+      /* Reject MODEs that aren't scalar integers because turning vector\n+\t or complex modes into shifts causes problems.  */\n+\n+      if (! SCALAR_INT_MODE_P (GET_MODE (XEXP (x, 0))))\n+\treturn x;\n+\n       len = INTVAL (XEXP (x, 1));\n       pos = INTVAL (XEXP (x, 2));\n \n@@ -5862,12 +5874,12 @@ expand_field_assignment (x)\n \n       compute_mode = GET_MODE (inner);\n \n-      /* Don't attempt bitwise arithmetic on non-integral modes.  */\n-      if (! INTEGRAL_MODE_P (compute_mode))\n+      /* Don't attempt bitwise arithmetic on non scalar integer modes.  */\n+      if (! SCALAR_INT_MODE_P (compute_mode))\n \t{\n \t  enum machine_mode imode;\n \n-\t  /* Something is probably seriously wrong if this matches.  */\n+\t  /* Don't do anything for vector or complex integral types.  */\n \t  if (! FLOAT_MODE_P (compute_mode))\n \t    break;\n \n@@ -10177,7 +10189,9 @@ simplify_comparison (code, pop0, pop1)\n \n       /* Get the constant we are comparing against and turn off all bits\n \t not on in our mode.  */\n-      const_op = trunc_int_for_mode (INTVAL (op1), mode);\n+      const_op = INTVAL (op1);\n+      if (mode != VOIDmode)\n+\tconst_op = trunc_int_for_mode (const_op, mode);\n       op1 = GEN_INT (const_op);\n \n       /* If we are comparing against a constant power of two and the value"}, {"sha": "4cda36541058ccc64b3efa3e8297b7faa171790c", "filename": "gcc/explow.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=71012d9720fc774abd9f586abf40bd5d5643a412", "patch": "@@ -49,6 +49,10 @@ trunc_int_for_mode (c, mode)\n {\n   int width = GET_MODE_BITSIZE (mode);\n \n+  /* You want to truncate to a _what_?  */\n+  if (! SCALAR_INT_MODE_P (mode))\n+    abort ();\n+\n   /* Canonicalize BImode to 0 and STORE_FLAG_VALUE.  */\n   if (mode == BImode)\n     return c & 1 ? STORE_FLAG_VALUE : 0;"}, {"sha": "c0c8c35f8d43cca331e9d5c2a71dbf64b6c946a7", "filename": "gcc/machmode.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=71012d9720fc774abd9f586abf40bd5d5643a412", "patch": "@@ -75,6 +75,11 @@ extern const enum mode_class mode_class[NUM_MACHINE_MODES];\n   (GET_MODE_CLASS (MODE) == MODE_VECTOR_INT\t\\\n    || GET_MODE_CLASS (MODE) == MODE_VECTOR_FLOAT)\n \n+/* Nonzero if MODE is a scalar integral mode.  */\n+#define SCALAR_INT_MODE_P(MODE)\t\t\t\\\n+  (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n+   || GET_MODE_CLASS (MODE) == MODE_PARTIAL_INT)\n+\n /* Get the size in bytes of an object of mode MODE.  */\n \n extern const unsigned char mode_size[NUM_MACHINE_MODES];"}, {"sha": "a01abd5b79915df602d6b2284cf4ba85d610b8fc", "filename": "gcc/recog.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71012d9720fc774abd9f586abf40bd5d5643a412/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=71012d9720fc774abd9f586abf40bd5d5643a412", "patch": "@@ -954,6 +954,7 @@ general_operand (op, mode)\n     return 0;\n \n   if (GET_CODE (op) == CONST_INT\n+      && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n     return 0;\n \n@@ -1159,6 +1160,7 @@ immediate_operand (op, mode)\n     return 0;\n \n   if (GET_CODE (op) == CONST_INT\n+      && mode != VOIDmode\n       && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n     return 0;\n \n@@ -1241,6 +1243,7 @@ nonmemory_operand (op, mode)\n \treturn 0;\n \n       if (GET_CODE (op) == CONST_INT\n+\t  && mode != VOIDmode\n \t  && trunc_int_for_mode (INTVAL (op), mode) != INTVAL (op))\n \treturn 0;\n "}]}