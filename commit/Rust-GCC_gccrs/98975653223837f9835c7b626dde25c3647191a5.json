{"sha": "98975653223837f9835c7b626dde25c3647191a5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg5NzU2NTMyMjM4MzdmOTgzNWM3YjYyNmRkZTI1YzM2NDcxOTFhNQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-08-10T20:43:05Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-08-10T20:43:05Z"}, "message": "lambda.h: Add matrix type, and prototypes for remainder of matrix and vector functions.\n\n2004-08-10  Daniel Berlin <dberlin@dberlin.org>\n\n\t* lambda.h: Add matrix type, and prototypes for remainder of\n\tmatrix and vector functions.\n\t(lambda_vector_mult_const): New function.\n\t(lambda_vector_negate): Ditto.\n\t(lambda_vector_add): Ditto.\n\t(lambda_vector_add_mc): Ditto.\n\t(lambda_vector_copy): Ditto.\n\t(lambda_vector_zerop): Ditto.\n\t(lambda_vector_equal): Ditto.\n\t(lambda_vector_min_nz): Ditto.\n\t(lambda_vector_first_nz): Ditto.\n\t(lambda_vector_matrix_mult): Ditto.\n\t* lambda-mat.c: New file.\n\t* Makefile.in (lambda-mat.o): New.\n\nFrom-SVN: r85767", "tree": {"sha": "050c215ae322bc44bca579442aa95604e51d9518", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/050c215ae322bc44bca579442aa95604e51d9518"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98975653223837f9835c7b626dde25c3647191a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98975653223837f9835c7b626dde25c3647191a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98975653223837f9835c7b626dde25c3647191a5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98975653223837f9835c7b626dde25c3647191a5/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780"}], "stats": {"total": 857, "additions": 850, "deletions": 7}, "files": [{"sha": "fd7b7e348b540a44ac4c1bbe1e81d99e2180166d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98975653223837f9835c7b626dde25c3647191a5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98975653223837f9835c7b626dde25c3647191a5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98975653223837f9835c7b626dde25c3647191a5", "patch": "@@ -1,3 +1,20 @@\n+2004-08-10  Daniel Berlin <dberlin@dberlin.org>\n+\n+\t* lambda.h: Add matrix type, and prototypes for remainder of\n+\tmatrix and vector functions.\n+\t(lambda_vector_mult_const): New function.\n+\t(lambda_vector_negate): Ditto.\n+\t(lambda_vector_add): Ditto.\n+\t(lambda_vector_add_mc): Ditto.\n+\t(lambda_vector_copy): Ditto.\n+\t(lambda_vector_zerop): Ditto.\n+\t(lambda_vector_equal): Ditto.\n+\t(lambda_vector_min_nz): Ditto.\n+\t(lambda_vector_first_nz): Ditto.\n+\t(lambda_vector_matrix_mult): Ditto.\n+\t* lambda-mat.c: New file.\n+\t* Makefile.in (lambda-mat.o): New.\n+\n 2004-08-10  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* tree-cfg.c (bsi_insert_before, bsi_insert_after): Call modify_stmt"}, {"sha": "c51760a0697e6b261de33168bf913bd7fe4ec3dd", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98975653223837f9835c7b626dde25c3647191a5/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98975653223837f9835c7b626dde25c3647191a5/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=98975653223837f9835c7b626dde25c3647191a5", "patch": "@@ -140,7 +140,7 @@ XCFLAGS =\n TCFLAGS =\n CFLAGS = -g\n STAGE1_CFLAGS = -g @stage1_cflags@\n-BOOT_CFLAGS = -g -O2\n+BOOT_CFLAGS = -g -O2 -dU\n \n # Flags to determine code coverage. When coverage is disabled, this will\n # contain the optimization flags, as you normally want code coverage\n@@ -922,7 +922,7 @@ OBJS-common = \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n  varasm.o varray.o vec.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n  et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n- rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o\n+ rtl-profile.o tree-profile.o rtlhooks.o cfgexpand.o lambda-mat.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) tree-inline.o\t\t   \\\n@@ -2127,6 +2127,7 @@ ifcvt.o : ifcvt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) toplev.h $(FLAGS_H) insn-config.h function.h $(RECOG_H) $(TARGET_H) \\\n    $(BASIC_BLOCK_H) $(EXPR_H) output.h except.h $(TM_P_H) real.h $(OPTABS_H) \\\n    $(CFGLOOP_H)\n+lambda-mat.o : lambda-mat.c lambda.h $(GGC_H) $(SYSTEM_H) $(CONFIG_H) $(TM_H)\n params.o : params.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(PARAMS_H) toplev.h\n hooks.o: hooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(HOOKS_H)\n pretty-print.o: $(CONFIG_H) $(SYSTEM_H) pretty-print.c $(PRETTY_PRINT_H)"}, {"sha": "987fa5e1fd17c46b13c867ffc1d4c5522a6459df", "filename": "gcc/lambda-mat.c", "status": "added", "additions": 638, "deletions": 0, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98975653223837f9835c7b626dde25c3647191a5/gcc%2Flambda-mat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98975653223837f9835c7b626dde25c3647191a5/gcc%2Flambda-mat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-mat.c?ref=98975653223837f9835c7b626dde25c3647191a5", "patch": "@@ -0,0 +1,638 @@\n+/* Integer matrix math routines\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"ggc.h\"\n+#include \"varray.h\"\n+#include \"lambda.h\"\n+\n+static void lambda_matrix_get_column (lambda_matrix, int, int, \n+\t\t\t\t      lambda_vector);\n+\n+/* Allocate a matrix of M rows x  N cols.  */\n+\n+lambda_matrix\n+lambda_matrix_new (int m, int n)\n+{\n+  lambda_matrix mat;\n+  int i;\n+\n+  mat = ggc_alloc (m * sizeof (lambda_vector));\n+  \n+  for (i = 0; i < m; i++)\n+    mat[i] = lambda_vector_new (n);\n+\n+  return mat;\n+}\n+\n+/* Copy the elements of M x N matrix MAT1 to MAT2.  */\n+\n+void\n+lambda_matrix_copy (lambda_matrix mat1, lambda_matrix mat2,\n+\t\t    int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    lambda_vector_copy (mat1[i], mat2[i], n);\n+}\n+\n+/* Store the N x N identity matrix in MAT.  */\n+\n+void\n+lambda_matrix_id (lambda_matrix mat, int size)\n+{\n+  int i, j;\n+\n+  for (i = 0; i < size; i++)\n+    for (j = 0; j < size; j++)\n+      mat[i][j] = (i == j) ? 1 : 0;\n+}\n+\n+/* Negate the elements of the M x N matrix MAT1 and store it in MAT2.  */\n+\n+void\n+lambda_matrix_negate (lambda_matrix mat1, lambda_matrix mat2, int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    lambda_vector_negate (mat1[i], mat2[i], n);\n+}\n+\n+/* Take the transpose of matrix MAT1 and store it in MAT2.\n+   MAT1 is an M x N matrix, so MAT2 must be N x M.  */\n+\n+void\n+lambda_matrix_transpose (lambda_matrix mat1, lambda_matrix mat2, int m, int n)\n+{\n+  int i, j;\n+\n+  for (i = 0; i < n; i++)\n+    for (j = 0; j < m; j++)\n+      mat2[i][j] = mat1[j][i];\n+}\n+\n+\n+/* Add two M x N matrices together: MAT3 = MAT1+MAT2.  */\n+\n+void\n+lambda_matrix_add (lambda_matrix mat1, lambda_matrix mat2,\n+\t\t   lambda_matrix mat3, int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    lambda_vector_add (mat1[i], mat2[i], mat3[i], n);\n+}\n+\n+/* MAT3 = CONST1 * MAT1 + CONST2 * MAT2.  All matrices are M x N.  */\n+\n+void\n+lambda_matrix_add_mc (lambda_matrix mat1, int const1,\n+\t\t      lambda_matrix mat2, int const2,\n+\t\t      lambda_matrix mat3, int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    lambda_vector_add_mc (mat1[i], const1, mat2[i], const2, mat3[i], n);\n+}\n+\n+/* Multiply two matrices: MAT3 = MAT1 * MAT2.\n+   MAT1 is an M x R matrix, and MAT2 is R x N.  The resulting MAT2\n+   must therefore be M x N.  */\n+\n+void\n+lambda_matrix_mult (lambda_matrix mat1, lambda_matrix mat2,\n+\t\t    lambda_matrix mat3, int m, int r, int n)\n+{\n+\n+  int i, j, k;\n+\n+  for (i = 0; i < m; i++)\n+    {\n+      for (j = 0; j < n; j++)\n+\t{\n+\t  mat3[i][j] = 0;\n+\t  for (k = 0; k < r; k++)\n+\t    mat3[i][j] += mat1[i][k] * mat2[k][j];\n+\t}\n+    }\n+}\n+\n+/* Get column COL from the matrix MAT and store it in VEC.  MAT has\n+   N rows, so the length of VEC must be N.  */\n+\n+static void\n+lambda_matrix_get_column (lambda_matrix mat, int n, int col,\n+\t\t\t  lambda_vector vec)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    vec[i] = mat[i][col];\n+}\n+\n+/* Delete rows r1 to r2 (not including r2). */\n+\n+void\n+lambda_matrix_delete_rows (lambda_matrix mat, int rows, int from, int to)\n+{\n+  int i;\n+  int dist;\n+  dist = to - from;\n+\n+  for (i = to; i < rows; i++)\n+    mat[i - dist] = mat[i];\n+\n+  for (i = rows - dist; i < rows; i++)\n+    mat[i] = NULL;\n+}\n+\n+/* Swap rows R1 and R2 in matrix MAT.  */\n+\n+void\n+lambda_matrix_row_exchange (lambda_matrix mat, int r1, int r2)\n+{\n+  lambda_vector row;\n+\n+  row = mat[r1];\n+  mat[r1] = mat[r2];\n+  mat[r2] = row;\n+}\n+\n+/* Add a multiple of row R1 of matrix MAT with N columns to row R2:\n+   R2 = R2 + CONST1 * R1.  */\n+\n+void\n+lambda_matrix_row_add (lambda_matrix mat, int n, int r1, int r2, int const1)\n+{\n+  int i;\n+\n+  if (const1 == 0)\n+    return;\n+\n+  for (i = 0; i < n; i++)\n+    mat[r2][i] += const1 * mat[r1][i];\n+}\n+\n+/* Negate row R1 of matrix MAT which has N columns.  */\n+\n+void\n+lambda_matrix_row_negate (lambda_matrix mat, int n, int r1)\n+{\n+  lambda_vector_negate (mat[r1], mat[r1], n);\n+}\n+\n+/* Multiply row R1 of matrix MAT with N columns by CONST1.  */\n+\n+void\n+lambda_matrix_row_mc (lambda_matrix mat, int n, int r1, int const1)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    mat[r1][i] *= const1;\n+}\n+\n+/* Exchange COL1 and COL2 in matrix MAT. M is the number of rows.  */\n+\n+void\n+lambda_matrix_col_exchange (lambda_matrix mat, int m, int col1, int col2)\n+{\n+  int i;\n+  int tmp;\n+  for (i = 0; i < m; i++)\n+    {\n+      tmp = mat[i][col1];\n+      mat[i][col1] = mat[i][col2];\n+      mat[i][col2] = tmp;\n+    }\n+}\n+\n+/* Add a multiple of column C1 of matrix MAT with M rows to column C2:\n+   C2 = C2 + CONST1 * C1.  */\n+\n+void\n+lambda_matrix_col_add (lambda_matrix mat, int m, int c1, int c2, int const1)\n+{\n+  int i;\n+\n+  if (const1 == 0)\n+    return;\n+\n+  for (i = 0; i < m; i++)\n+    mat[i][c2] += const1 * mat[i][c1];\n+}\n+\n+/* Negate column C1 of matrix MAT which has M rows.  */\n+\n+void\n+lambda_matrix_col_negate (lambda_matrix mat, int m, int c1)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    mat[i][c1] *= -1;\n+}\n+\n+/* Multiply column C1 of matrix MAT with M rows by CONST1.  */\n+\n+void\n+lambda_matrix_col_mc (lambda_matrix mat, int m, int c1, int const1)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    mat[i][c1] *= const1;\n+}\n+\n+/* Compute the inverse of the N x N matrix MAT and store it in INV.\n+\n+   We don't _really_ compute the inverse of MAT.  Instead we compute\n+   det(MAT)*inv(MAT), and we return det(MAT) to the caller as the function\n+   result.  This is necessary to preserve accuracy, because we are dealing\n+   with integer matrices here.\n+\n+   The algorithm used here is a column based Gauss-Jordan elimination on MAT\n+   and the identity matrix in parallel.  The inverse is the result of applying\n+   the same operations on the identity matrix that reduce MAT to the identity\n+   matrix.\n+\n+   When MAT is a 2 x 2 matrix, we don't go through the whole process, because\n+   it is easily inverted by inspection and it is a very common case.  */\n+\n+static int lambda_matrix_inverse_hard (lambda_matrix, lambda_matrix, int);\n+\n+int\n+lambda_matrix_inverse (lambda_matrix mat, lambda_matrix inv, int n)\n+{\n+  if (n == 2)\n+    {\n+      int a, b, c, d, det;\n+      a = mat[0][0];\n+      b = mat[1][0];\n+      c = mat[0][1];\n+      d = mat[1][1];      \n+      inv[0][0] =  d;\n+      inv[0][1] = -c;\n+      inv[1][0] = -b;\n+      inv[1][1] =  a;\n+      det = (a * d - b * c);\n+      if (det < 0)\n+\t{\n+\t  det *= -1;\n+\t  inv[0][0] *= -1;\n+\t  inv[1][0] *= -1;\n+\t  inv[0][1] *= -1;\n+\t  inv[1][1] *= -1;\n+\t}\n+      return det;\n+    }\n+  else\n+    return lambda_matrix_inverse_hard (mat, inv, n);\n+}\n+\n+/* If MAT is not a special case, invert it the hard way.  */\n+\n+static int\n+lambda_matrix_inverse_hard (lambda_matrix mat, lambda_matrix inv, int n)\n+{\n+  lambda_vector row;\n+  lambda_matrix temp;\n+  int i, j;\n+  int determinant;\n+\n+  temp = lambda_matrix_new (n, n);\n+  lambda_matrix_copy (mat, temp, n, n);\n+  lambda_matrix_id (inv, n);\n+\n+  /* Reduce TEMP to a lower triangular form, applying the same operations on\n+     INV which starts as the identity matrix.  N is the number of rows and\n+     columns.  */\n+  for (j = 0; j < n; j++)\n+    {\n+      row = temp[j];\n+\n+      /* Make every element in the current row positive.  */\n+      for (i = j; i < n; i++)\n+\tif (row[i] < 0)\n+\t  {\n+\t    lambda_matrix_col_negate (temp, n, i);\n+\t    lambda_matrix_col_negate (inv, n, i);\n+\t  }\n+\n+      /* Sweep the upper triangle.  Stop when only the diagonal element in the\n+\t current row is nonzero.  */\n+      while (lambda_vector_first_nz (row, n, j + 1) < n)\n+\t{\n+\t  int min_col = lambda_vector_min_nz (row, n, j);\n+\t  lambda_matrix_col_exchange (temp, n, j, min_col);\n+\t  lambda_matrix_col_exchange (inv, n, j, min_col);\n+\n+\t  for (i = j + 1; i < n; i++)\n+\t    {\n+\t      int factor;\n+\n+\t      factor = -1 * row[i];\n+\t      if (row[j] != 1)\n+\t\tfactor /= row[j];\n+\n+\t      lambda_matrix_col_add (temp, n, j, i, factor);\n+\t      lambda_matrix_col_add (inv, n, j, i, factor);\n+\t    }\n+\t}\n+    }\n+\n+  /* Reduce TEMP from a lower triangular to the identity matrix.  Also compute\n+     the determinant, which now is simply the product of the elements on the\n+     diagonal of TEMP.  If one of these elements is 0, the matrix has 0 as an\n+     eigenvalue so it is singular and hence not invertible.  */\n+  determinant = 1;\n+  for (j = n - 1; j >= 0; j--)\n+    {\n+      int diagonal;\n+\n+      row = temp[j];\n+      diagonal = row[j];\n+\n+      /* If the matrix is singular, abort.  */\n+      if (diagonal == 0)\n+\tabort ();\n+\n+      determinant = determinant * diagonal;\n+\n+      /* If the diagonal is not 1, then multiply the each row by the\n+         diagonal so that the middle number is now 1, rather than a\n+         rational.  */\n+      if (diagonal != 1)\n+\t{\n+\t  for (i = 0; i < j; i++)\n+\t    lambda_matrix_col_mc (inv, n, i, diagonal);\n+\t  for (i = j + 1; i < n; i++)\n+\t    lambda_matrix_col_mc (inv, n, i, diagonal);\n+\n+\t  row[j] = diagonal = 1;\n+\t}\n+\n+      /* Sweep the lower triangle column wise.  */\n+      for (i = j - 1; i >= 0; i--)\n+\t{\n+\t  if (row[i])\n+\t    {\n+\t      int factor = -row[i];\n+\t      lambda_matrix_col_add (temp, n, j, i, factor);\n+\t      lambda_matrix_col_add (inv, n, j, i, factor);\n+\t    }\n+\n+\t}\n+    }\n+\n+  return determinant;\n+}\n+\n+/* Decompose a N x N matrix MAT to a product of a lower triangular H\n+   and a unimodular U matrix such that MAT = H.U.  N is the size of\n+   the rows of MAT.  */\n+\n+void\n+lambda_matrix_hermite (lambda_matrix mat, int n,\n+\t\t       lambda_matrix H, lambda_matrix U)\n+{\n+  lambda_vector row;\n+  int i, j, factor, minimum_col;\n+\n+  lambda_matrix_copy (mat, H, n, n);\n+  lambda_matrix_id (U, n);\n+\n+  for (j = 0; j < n; j++)\n+    {\n+      row = H[j];\n+\n+      /* Make every element of H[j][j..n] positive.  */\n+      for (i = j; i < n; i++)\n+\t{\n+\t  if (row[i] < 0)\n+\t    {\n+\t      lambda_matrix_col_negate (H, n, i);\n+\t      lambda_vector_negate (U[i], U[i], n);\n+\t    }\n+\t}\n+\n+      /* Stop when only the diagonal element is non-zero.  */\n+      while (lambda_vector_first_nz (row, n, j + 1) < n)\n+\t{\n+\t  minimum_col = lambda_vector_min_nz (row, n, j);\n+\t  lambda_matrix_col_exchange (H, n, j, minimum_col);\n+\t  lambda_matrix_row_exchange (U, j, minimum_col);\n+\n+\t  for (i = j + 1; i < n; i++)\n+\t    {\n+\t      factor = row[i] / row[j];\n+\t      lambda_matrix_col_add (H, n, j, i, -1 * factor);\n+\t      lambda_matrix_row_add (U, n, i, j, factor);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Given an M x N integer matrix A, this function determines an M x\n+   M unimodular matrix U, and an M x N echelon matrix S such that\n+   \"U.A = S\".  This decomposition is also known as \"right Hermite\".\n+   \n+   Ref: Algorithm 2.1 page 33 in \"Loop Transformations for\n+   Restructuring Compilers\" Utpal Banerjee. */\n+\n+void\n+lambda_matrix_right_hermite (lambda_matrix A, int m, int n,\n+\t\t\t     lambda_matrix S, lambda_matrix U)\n+{\n+  int i, j, i0 = 0;\n+\n+  lambda_matrix_copy (A, S, m, n);\n+  lambda_matrix_id (U, m);\n+\n+  for (j = 0; j < n; j++)\n+    {\n+      if (lambda_vector_first_nz (S[j], m, i0) < m)\n+\t{\n+\t  ++i0;\n+\t  for (i = m - 1; i >= i0; i--)\n+\t    {\n+\t      while (S[i][j] != 0)\n+\t\t{\n+\t\t  int sigma, factor, a, b;\n+\n+\t\t  a = S[i-1][j];\n+\t\t  b = S[i][j];\n+\t\t  sigma = (a * b < 0) ? -1: 1;\n+\t\t  a = abs (a);\n+\t\t  b = abs (b);\n+\t\t  factor = sigma * (a / b);\n+\n+\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n+\t\t  lambda_matrix_row_exchange (S, i, i-1);\n+\n+\t\t  lambda_matrix_row_add (U, m, i, i-1, -factor);\n+\t\t  lambda_matrix_row_exchange (U, i, i-1);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Given an M x N integer matrix A, this function determines an M x M\n+   unimodular matrix V, and an M x N echelon matrix S such that \"A =\n+   V.S\".  This decomposition is also known as \"left Hermite\".\n+   \n+   Ref: Algorithm 2.2 page 36 in \"Loop Transformations for\n+   Restructuring Compilers\" Utpal Banerjee. */\n+\n+void\n+lambda_matrix_left_hermite (lambda_matrix A, int m, int n,\n+\t\t\t     lambda_matrix S, lambda_matrix V)\n+{\n+  int i, j, i0 = 0;\n+\n+  lambda_matrix_copy (A, S, m, n);\n+  lambda_matrix_id (V, m);\n+\n+  for (j = 0; j < n; j++)\n+    {\n+      if (lambda_vector_first_nz (S[j], m, i0) < m)\n+\t{\n+\t  ++i0;\n+\t  for (i = m - 1; i >= i0; i--)\n+\t    {\n+\t      while (S[i][j] != 0)\n+\t\t{\n+\t\t  int sigma, factor, a, b;\n+\n+\t\t  a = S[i-1][j];\n+\t\t  b = S[i][j];\n+\t\t  sigma = (a * b < 0) ? -1: 1;\n+\t\t  a = abs (a);\n+      b = abs (b);\n+\t\t  factor = sigma * (a / b);\n+\n+\t\t  lambda_matrix_row_add (S, n, i, i-1, -factor);\n+\t\t  lambda_matrix_row_exchange (S, i, i-1);\n+\n+\t\t  lambda_matrix_col_add (V, m, i-1, i, factor);\n+\t\t  lambda_matrix_col_exchange (V, m, i, i-1);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* When it exists, return the first non-zero row in MAT after row\n+   STARTROW.  Otherwise return rowsize.  */\n+\n+int\n+lambda_matrix_first_nz_vec (lambda_matrix mat, int rowsize, int colsize,\n+\t\t\t    int startrow)\n+{\n+  int j;\n+  bool found = false;\n+\n+  for (j = startrow; (j < rowsize) && !found; j++)\n+    {\n+      if ((mat[j] != NULL)\n+\t  && (lambda_vector_first_nz (mat[j], colsize, startrow) < colsize))\n+\tfound = true;\n+    }\n+\n+  if (found)\n+    return j - 1;\n+  return rowsize;\n+}\n+\n+/* Calculate the projection of E sub k to the null space of B.  */\n+\n+void\n+lambda_matrix_project_to_null (lambda_matrix B, int rowsize,\n+\t\t\t       int colsize, int k, lambda_vector x)\n+{\n+  lambda_matrix M1, M2, M3, I;\n+  int determinant;\n+\n+  /* compute c(I-B^T inv(B B^T) B) e sub k   */\n+\n+  /* M1 is the transpose of B */\n+  M1 = lambda_matrix_new (colsize, colsize);\n+  lambda_matrix_transpose (B, M1, rowsize, colsize);\n+\n+  /* M2 = B * B^T */\n+  M2 = lambda_matrix_new (colsize, colsize);\n+  lambda_matrix_mult (B, M1, M2, rowsize, colsize, rowsize);\n+\n+  /* M3 = inv(M2) */\n+  M3 = lambda_matrix_new (colsize, colsize);\n+  determinant = lambda_matrix_inverse (M2, M3, rowsize);\n+\n+  /* M2 = B^T (inv(B B^T)) */\n+  lambda_matrix_mult (M1, M3, M2, colsize, rowsize, rowsize);\n+\n+  /* M1 = B^T (inv(B B^T)) B */\n+  lambda_matrix_mult (M2, B, M1, colsize, rowsize, colsize);\n+  lambda_matrix_negate (M1, M1, colsize, colsize);\n+\n+  I = lambda_matrix_new (colsize, colsize);\n+  lambda_matrix_id (I, colsize);\n+\n+  lambda_matrix_add_mc (I, determinant, M1, 1, M2, colsize, colsize);\n+\n+  lambda_matrix_get_column (M2, colsize, k - 1, x);\n+\n+}\n+\n+/* Multiply a vector VEC by a matrix MAT.\n+   MAT is an M*N matrix, and VEC is a vector with length N.  The result\n+   is stored in DEST which must be a vector of length M.  */\n+\n+void\n+lambda_matrix_vector_mult (lambda_matrix matrix, int m, int n,\n+\t\t\t   lambda_vector vec, lambda_vector dest)\n+{\n+  int i, j;\n+\n+  lambda_vector_clear (dest, m);\n+  for (i = 0; i < m; i++)\n+    for (j = 0; j < n; j++)\n+      dest[i] += matrix[i][j] * vec[j];\n+}\n+\n+/* Print out an M x N matrix MAT to OUTFILE.  */\n+\n+void\n+print_lambda_matrix (FILE * outfile, lambda_matrix matrix, int m, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < m; i++)\n+    print_lambda_vector (outfile, matrix[i], n);\n+  fprintf (outfile, \"\\n\");\n+}\n+"}, {"sha": "998e3f18c62c08b6c36aef96f1b024fb346c32c3", "filename": "gcc/lambda.h", "status": "modified", "additions": 192, "deletions": 5, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98975653223837f9835c7b626dde25c3647191a5/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98975653223837f9835c7b626dde25c3647191a5/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=98975653223837f9835c7b626dde25c3647191a5", "patch": "@@ -1,4 +1,4 @@\n-/* Lambda matrix interface.\n+/* Lambda matrix and vector interface.\n    Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n    Contributed by Daniel Berlin <dberlin@dberlin.org>\n \n@@ -18,11 +18,65 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to the Free\n Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n- \n+\n #ifndef LAMBDA_H\n #define LAMBDA_H\n \n+/* An integer vector.  A vector formally consists of an element of a vector\n+   space. A vector space is a set that is closed under vector addition\n+   and scalar multiplication.  In this vector space, an element is a list of\n+   integers.  */\n typedef int *lambda_vector;\n+/* An integer matrix.  A matrix consists of m vectors of length n (IE\n+   all vectors are the same length).  */\n+typedef lambda_vector *lambda_matrix;\n+\n+lambda_matrix lambda_matrix_new (int, int);\n+\n+void lambda_matrix_id (lambda_matrix, int);\n+void lambda_matrix_copy (lambda_matrix, lambda_matrix, int, int);\n+void lambda_matrix_negate (lambda_matrix, lambda_matrix, int, int);\n+void lambda_matrix_transpose (lambda_matrix, lambda_matrix, int, int);\n+void lambda_matrix_add (lambda_matrix, lambda_matrix, lambda_matrix, int,\n+\t\t\tint);\n+void lambda_matrix_add_mc (lambda_matrix, int, lambda_matrix, int,\n+\t\t\t   lambda_matrix, int, int);\n+void lambda_matrix_mult (lambda_matrix, lambda_matrix, lambda_matrix,\n+\t\t\t int, int, int);\n+void lambda_matrix_delete_rows (lambda_matrix, int, int, int);\n+void lambda_matrix_row_exchange (lambda_matrix, int, int);\n+void lambda_matrix_row_add (lambda_matrix, int, int, int, int);\n+void lambda_matrix_row_negate (lambda_matrix mat, int, int);\n+void lambda_matrix_row_mc (lambda_matrix, int, int, int);\n+void lambda_matrix_col_exchange (lambda_matrix, int, int, int);\n+void lambda_matrix_col_add (lambda_matrix, int, int, int, int);\n+void lambda_matrix_col_negate (lambda_matrix, int, int);\n+void lambda_matrix_col_mc (lambda_matrix, int, int, int);\n+int lambda_matrix_inverse (lambda_matrix, lambda_matrix, int);\n+void lambda_matrix_hermite (lambda_matrix, int, lambda_matrix, lambda_matrix);\n+void lambda_matrix_left_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n+void lambda_matrix_right_hermite (lambda_matrix, int, int, lambda_matrix, lambda_matrix);\n+int lambda_matrix_first_nz_vec (lambda_matrix, int, int, int);\n+void lambda_matrix_project_to_null (lambda_matrix, int, int, int, \n+\t\t\t\t    lambda_vector);\n+void print_lambda_matrix (FILE *, lambda_matrix, int, int);\n+\n+void lambda_matrix_vector_mult (lambda_matrix, int, int, lambda_vector, \n+\t\t\t\tlambda_vector);\n+\n+static inline void lambda_vector_negate (lambda_vector, lambda_vector, int);\n+static inline void lambda_vector_mult_const (lambda_vector, lambda_vector, int, int);\n+static inline void lambda_vector_add (lambda_vector, lambda_vector,\n+\t\t\t\t      lambda_vector, int);\n+static inline void lambda_vector_add_mc (lambda_vector, int, lambda_vector, int,\n+\t\t\t\t\t lambda_vector, int);\n+static inline void lambda_vector_copy (lambda_vector, lambda_vector, int);\n+static inline bool lambda_vector_zerop (lambda_vector, int);\n+static inline void lambda_vector_clear (lambda_vector, int);\n+static inline bool lambda_vector_equal (lambda_vector, lambda_vector, int);\n+static inline int lambda_vector_min_nz (lambda_vector, int, int);\n+static inline int lambda_vector_first_nz (lambda_vector, int, int);\n+static inline void print_lambda_vector (FILE *, lambda_vector, int);\n \n /* Allocate a new vector of given SIZE.  */\n \n@@ -32,14 +86,149 @@ lambda_vector_new (int size)\n   return ggc_alloc_cleared (size * sizeof(int));\n }\n \n+\n+\n+/* Multiply vector VEC1 of length SIZE by a constant CONST1,\n+   and store the result in VEC2.  */\n+\n+static inline void\n+lambda_vector_mult_const (lambda_vector vec1, lambda_vector vec2,\n+\t\t\t  int size, int const1)\n+{\n+  int i;\n+\n+  if (const1 == 0)\n+    lambda_vector_clear (vec2, size);\n+  else\n+    for (i = 0; i < size; i++)\n+      vec2[i] = const1 * vec1[i];\n+}\n+\n+/* Negate vector VEC1 with length SIZE and store it in VEC2.  */\n+\n+static inline void \n+lambda_vector_negate (lambda_vector vec1, lambda_vector vec2,\n+\t\t      int size)\n+{\n+  lambda_vector_mult_const (vec1, vec2, size, -1);\n+}\n+\n+/* VEC3 = VEC1+VEC2, where all three the vectors are of length SIZE.  */\n+\n+static inline void\n+lambda_vector_add (lambda_vector vec1, lambda_vector vec2,\n+\t\t   lambda_vector vec3, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    vec3[i] = vec1[i] + vec2[i];\n+}\n+\n+/* VEC3 = CONSTANT1*VEC1 + CONSTANT2*VEC2.  All vectors have length SIZE.  */\n+\n+static inline void\n+lambda_vector_add_mc (lambda_vector vec1, int const1,\n+\t\t      lambda_vector vec2, int const2,\n+\t\t      lambda_vector vec3, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    vec3[i] = const1 * vec1[i] + const2 * vec2[i];\n+}\n+\n+/* Copy the elements of vector VEC1 with length SIZE to VEC2.  */\n+\n+static inline void\n+lambda_vector_copy (lambda_vector vec1, lambda_vector vec2,\n+\t\t    int size)\n+{\n+  memcpy (vec2, vec1, size * sizeof (*vec1));\n+}\n+\n+/* Return true if vector VEC1 of length SIZE is the zero vector.  */\n+\n+static inline bool \n+lambda_vector_zerop (lambda_vector vec1, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    if (vec1[i] != 0)\n+      return false;\n+  return true;\n+}\n+\n /* Clear out vector VEC1 of length SIZE.  */\n \n static inline void\n lambda_vector_clear (lambda_vector vec1, int size)\n {\n-  memset (vec1, 0, size * sizeof (int));\n+  memset (vec1, 0, size * sizeof (*vec1));\n }\n \n+/* Return true if two vectors are equal.  */\n+ \n+static inline bool\n+lambda_vector_equal (lambda_vector vec1, lambda_vector vec2, int size)\n+{\n+  int i;\n+  for (i = 0; i < size; i++)\n+    if (vec1[i] != vec2[i])\n+      return false;\n+  return true;\n+}\n+\n+/* Return the minimum non-zero element in vector VEC1 between START and N.\n+   We must have START <= N.  */\n+\n+static inline int\n+lambda_vector_min_nz (lambda_vector vec1, int n, int start)\n+{\n+  int j;\n+  int min = -1;\n+#ifdef ENABLE_CHECKING \n+  if (start > n)\n+    abort ();\n+#endif\n+  for (j = start; j < n; j++)\n+    {\n+      if (vec1[j])\n+\tif (min < 0 || vec1[j] < vec1[min])\n+\t  min = j;\n+    }\n+\n+  if (min < 0)\n+    abort ();\n+\n+  return min;\n+}\n+\n+/* Return the first nonzero element of vector VEC1 between START and N.\n+   We must have START <= N.   Returns N if VEC1 is the zero vector.  */\n+\n+static inline int\n+lambda_vector_first_nz (lambda_vector vec1, int n, int start)\n+{\n+  int j = start;\n+  while (j < n && vec1[j] == 0)\n+    j++;\n+  return j;\n+}\n+\n+\n+/* Multiply a vector by a matrix.  */\n+\n+static inline void\n+lambda_vector_matrix_mult (lambda_vector vect, int m, lambda_matrix mat, \n+\t\t\t   int n, lambda_vector dest)\n+{\n+  int i, j;\n+  lambda_vector_clear (dest, n);\n+  for (i = 0; i < n; i++)\n+    for (j = 0; j < m; j++)\n+      dest[i] += mat[j][i] * vect[j];\n+}\n+\n+\n /* Print out a vector VEC of length N to OUTFILE.  */\n \n static inline void\n@@ -51,7 +240,5 @@ print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n     fprintf (outfile, \"%3d \", vector[i]);\n   fprintf (outfile, \"\\n\");\n }\n-\n-\n #endif /* LAMBDA_H  */\n "}]}