{"sha": "7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2Q3YTFmZTg1OTg5ZTRmMzk5ODA2MGVkOWYyZDRkNjk3M2UzOWVlZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-09T10:49:46Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-09T10:49:46Z"}, "message": "gigi.h (maybe_variable): Delete.\n\n\t* gcc-interface/gigi.h (maybe_variable): Delete.\n\t(protect_multiple_eval): Likewise.\n\t(maybe_stabilize_reference): Likewise.\n\t(gnat_save_expr): Declare.\n\t(gnat_protect_expr): Likewise.\n\t(gnat_stabilize_reference): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Use\n\tgnat_stabilize_reference.\n\t(maybe_variable): Delete.\n\t(elaborate_expression_1): Use gnat_save_expr.\n\t* gcc-interface/trans.c (Attribute_to_gnu): Use gnat_protect_expr.\n\t(call_to_gnu): Pass NULL to gnat_stabilize_reference.\n\t(gnat_to_gnu) <N_Object_Declaration>: Use gnat_save_expr.\n\t<N_Slice>: Use gnat_protect_exp.\n\t<N_Selected_Component>: Pass NULL to gnat_stabilize_reference.\n\t<N_In>: Use gnat_protect_expr.\n\tPass NULL to gnat_stabilize_reference.\n\t(build_unary_op_trapv): Use gnat_protect_expr.\n\t(build_binary_op_trapv): Likewise.\n\t(emit_range_check): Likewise.\n\t(emit_index_check): Likewise.\n\t(convert_with_check): Likewise.\n\t(protect_multiple_eval): Move to utils2.c file.\n\t(maybe_stabilize_reference): Merge into...\n\t(gnat_stabilize_reference): ...this.  Move to utils2.c file.\n\t(gnat_stabilize_reference_1): Likewise.\n\t* gcc-interface/utils.c (convert_to_fat_pointer): Use gnat_protect_expr\n\tinstead of protect_multiple_eval.\n\t* gcc-interface/utils2.c (compare_arrays): Likewise.\n\t(nonbinary_modular_operation): Likewise.\n\t(maybe_wrap_malloc): Likewise.\n\t(build_allocator): Likewise.\n\t(gnat_save_expr): New function.\n\t(gnat_protect_expr): Rename from protect_multiple_eval.  Early return\n\tin common cases.  Propagate TREE_READONLY onto dereferences.\n\t(gnat_stabilize_reference_1): Move from trans.c file.\n\t(gnat_stabilize_reference): Likewise.\n\nFrom-SVN: r158159", "tree": {"sha": "14bd037437f5ca3585e8edde0baa10576ffe4886", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14bd037437f5ca3585e8edde0baa10576ffe4886"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/comments", "author": null, "committer": null, "parents": [{"sha": "3f2060fd386c382197ec67f0c64eebdf44c79cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f2060fd386c382197ec67f0c64eebdf44c79cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f2060fd386c382197ec67f0c64eebdf44c79cf4"}], "stats": {"total": 700, "additions": 374, "deletions": 326}, "files": [{"sha": "2b8801feafddeed8a1cbe3deeb19051f28a84846", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -1,3 +1,43 @@\n+2010-04-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (maybe_variable): Delete.\n+\t(protect_multiple_eval): Likewise.\n+\t(maybe_stabilize_reference): Likewise.\n+\t(gnat_save_expr): Declare.\n+\t(gnat_protect_expr): Likewise.\n+\t(gnat_stabilize_reference): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Use\n+\tgnat_stabilize_reference.\n+\t(maybe_variable): Delete.\n+\t(elaborate_expression_1): Use gnat_save_expr.\n+\t* gcc-interface/trans.c (Attribute_to_gnu): Use gnat_protect_expr.\n+\t(call_to_gnu): Pass NULL to gnat_stabilize_reference.\n+\t(gnat_to_gnu) <N_Object_Declaration>: Use gnat_save_expr.\n+\t<N_Slice>: Use gnat_protect_exp.\n+\t<N_Selected_Component>: Pass NULL to gnat_stabilize_reference.\n+\t<N_In>: Use gnat_protect_expr.\n+\tPass NULL to gnat_stabilize_reference.\n+\t(build_unary_op_trapv): Use gnat_protect_expr.\n+\t(build_binary_op_trapv): Likewise.\n+\t(emit_range_check): Likewise.\n+\t(emit_index_check): Likewise.\n+\t(convert_with_check): Likewise.\n+\t(protect_multiple_eval): Move to utils2.c file.\n+\t(maybe_stabilize_reference): Merge into...\n+\t(gnat_stabilize_reference): ...this.  Move to utils2.c file.\n+\t(gnat_stabilize_reference_1): Likewise.\n+\t* gcc-interface/utils.c (convert_to_fat_pointer): Use gnat_protect_expr\n+\tinstead of protect_multiple_eval.\n+\t* gcc-interface/utils2.c (compare_arrays): Likewise.\n+\t(nonbinary_modular_operation): Likewise.\n+\t(maybe_wrap_malloc): Likewise.\n+\t(build_allocator): Likewise.\n+\t(gnat_save_expr): New function.\n+\t(gnat_protect_expr): Rename from protect_multiple_eval.  Early return\n+\tin common cases.  Propagate TREE_READONLY onto dereferences.\n+\t(gnat_stabilize_reference_1): Move from trans.c file.\n+\t(gnat_stabilize_reference): Likewise.\n+\n 2010-04-09  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (gnat_mark_addressable): Rename parameter."}, {"sha": "dd7689100225dcdf61fc12cc471b61de16b3012d", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 3, "deletions": 26, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -897,7 +897,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    && !TREE_SIDE_EFFECTS (gnu_expr))))\n \t\t  {\n \t\t    maybe_stable_expr\n-\t\t      = maybe_stabilize_reference (gnu_expr, true, &stable);\n+\t\t      = gnat_stabilize_reference (gnu_expr, true, &stable);\n \n \t\t    if (stable)\n \t\t      {\n@@ -973,7 +973,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    else\n \t \t     {\n \t\t\tmaybe_stable_expr\n-\t\t\t  = maybe_stabilize_reference (gnu_expr, true, &stable);\n+\t\t\t  = gnat_stabilize_reference (gnu_expr, true, &stable);\n \n \t\t\tif (stable)\n \t\t\t  renamed_obj = maybe_stable_expr;\n@@ -5727,29 +5727,6 @@ prepend_attributes (Entity_Id gnat_entity, struct attrib ** attr_list)\n       }\n }\n \f\n-/* Called when we need to protect a variable object using a SAVE_EXPR.  */\n-\n-tree\n-maybe_variable (tree gnu_operand)\n-{\n-  if (TREE_CONSTANT (gnu_operand)\n-      || TREE_READONLY (gnu_operand)\n-      || TREE_CODE (gnu_operand) == SAVE_EXPR\n-      || TREE_CODE (gnu_operand) == NULL_EXPR)\n-    return gnu_operand;\n-\n-  if (TREE_CODE (gnu_operand) == UNCONSTRAINED_ARRAY_REF)\n-    {\n-      tree gnu_result\n-\t= build1 (UNCONSTRAINED_ARRAY_REF, TREE_TYPE (gnu_operand),\n-\t\t  variable_size (TREE_OPERAND (gnu_operand, 0)));\n-      TREE_READONLY (gnu_result) = TYPE_READONLY (TREE_TYPE (gnu_operand));\n-      return gnu_result;\n-    }\n-\n-  return variable_size (gnu_operand);\n-}\n-\f\n /* Given a GNAT tree GNAT_EXPR, for an expression which is a value within a\n    type definition (either a bound or a discriminant value) for GNAT_ENTITY,\n    return the GCC tree to use for that expression.  GNU_NAME is the suffix\n@@ -5852,7 +5829,7 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n   if (expr_global && expr_variable)\n     return gnu_decl;\n \n-  return expr_variable ? maybe_variable (gnu_expr) : gnu_expr;\n+  return expr_variable ? gnat_save_expr (gnu_expr) : gnu_expr;\n }\n \f\n /* Create a record type that contains a SIZE bytes long field of TYPE with a"}, {"sha": "8ba0637bebf84fc11ddfa293d293d82156074afc", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -112,9 +112,6 @@ extern void mark_out_of_scope (Entity_Id gnat_entity);\n /* Get the unpadded version of a GNAT type.  */\n extern tree get_unpadded_type (Entity_Id gnat_entity);\n \n-/* Called when we need to protect a variable object using a save_expr.  */\n-extern tree maybe_variable (tree gnu_operand);\n-\n /* Create a record type that contains a SIZE bytes long field of TYPE with a\n     starting bit position so that it is aligned to ALIGN bits, and leaving at\n     least ROOM bytes free before the field.  BASE_ALIGN is the alignment the\n@@ -256,9 +253,6 @@ extern void post_error_ne_tree (const char *msg, Node_Id node, Entity_Id ent,\n extern void post_error_ne_tree_2 (const char *msg, Node_Id node, Entity_Id ent,\n                                   tree t, int num);\n \n-/* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n-extern tree protect_multiple_eval (tree exp);\n-\n /* Return a label to branch to for the exception type in KIND or NULL_TREE\n    if none.  */\n extern tree get_exception_label (char kind);\n@@ -267,12 +261,6 @@ extern tree get_exception_label (char kind);\n    called.  */\n extern Node_Id error_gnat_node;\n \n-/* This is equivalent to stabilize_reference in tree.c, but we know how to\n-   handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  We set SUCCESS to true unless we walk\n-   through something we don't know how to stabilize.  */\n-extern tree maybe_stabilize_reference (tree ref, bool force, bool *success);\n-\n /* Highest number in the front-end node table.  */\n extern int max_gnat_nodes;\n \n@@ -875,6 +863,21 @@ extern tree fill_vms_descriptor (tree expr, Entity_Id gnat_formal,\n    should not be allocated in a register.  Returns true if successful.  */\n extern bool gnat_mark_addressable (tree t);\n \n+/* Save EXP for later use or reuse.  This is equivalent to save_expr in tree.c\n+   but we know how to handle our own nodes.  */\n+extern tree gnat_save_expr (tree exp);\n+\n+/* Protect EXP for immediate reuse.  This is a variant of gnat_save_expr that\n+   is optimized under the assumption that EXP's value doesn't change before\n+   its subsequent reuse(s) except through its potential reevaluation.  */\n+extern tree gnat_protect_expr (tree exp);\n+\n+/* This is equivalent to stabilize_reference in tree.c but we know how to\n+   handle our own nodes and we take extra arguments.  FORCE says whether to\n+   force evaluation of everything.  We set SUCCESS to true unless we walk\n+   through something we don't know how to stabilize.  */\n+extern tree gnat_stabilize_reference (tree ref, bool force, bool *success);\n+\n /* Implementation of the builtin_function langhook.  */\n extern tree gnat_builtin_function (tree decl);\n "}, {"sha": "5fe94602c83d0935ef46439dbb88877d5794f480", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 18, "deletions": 280, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -214,8 +214,6 @@ static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n static tree extract_values (tree, tree);\n static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n static tree maybe_implicit_deref (tree);\n-static tree gnat_stabilize_reference (tree, bool);\n-static tree gnat_stabilize_reference_1 (tree, bool);\n static void set_expr_location_from_node (tree, Node_Id);\n static int lvalue_required_p (Node_Id, tree, bool, bool);\n \n@@ -1128,7 +1126,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n       if (Do_Range_Check (First (Expressions (gnat_node))))\n \t{\n-\t  gnu_expr = protect_multiple_eval (gnu_expr);\n+\t  gnu_expr = gnat_protect_expr (gnu_expr);\n \t  gnu_expr\n \t    = emit_check\n \t      (build_binary_op (EQ_EXPR, integer_type_node,\n@@ -2492,7 +2490,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t ??? This is more conservative than we need since we don't need to do\n \t this for pass-by-ref with no conversion.  */\n       if (Ekind (gnat_formal) != E_In_Parameter)\n-\tgnu_name = gnat_stabilize_reference (gnu_name, true);\n+\tgnu_name = gnat_stabilize_reference (gnu_name, true, NULL);\n \n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n@@ -2555,10 +2553,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t\t\t\t\t   gnu_name_type)))\n \t    gnu_name = convert (gnu_name_type, gnu_name);\n \n-\t  /* Make a SAVE_EXPR to both properly account for potential side\n-\t     effects and handle the creation of a temporary.  Special code\n-\t     in gnat_gimplify_expr ensures that the same temporary is used\n-\t     as the object and copied back after the call if needed.  */\n+\t  /* Make a SAVE_EXPR to force the creation of a temporary.  Special\n+\t     code in gnat_gimplify_expr ensures that the same temporary is\n+\t     used as the object and copied back after the call if needed.  */\n \t  gnu_name = build1 (SAVE_EXPR, TREE_TYPE (gnu_name), gnu_name);\n \t  TREE_SIDE_EFFECTS (gnu_name) = 1;\n \n@@ -3722,7 +3719,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t     gnu_expr, false, Is_Public (gnat_temp),\n \t\t\t\t     false, false, NULL, gnat_temp);\n \t      else\n-\t\tgnu_expr = maybe_variable (gnu_expr);\n+\t\tgnu_expr = gnat_save_expr (gnu_expr);\n \n \t      save_gnu_tree (gnat_node, gnu_expr, true);\n \t    }\n@@ -3886,8 +3883,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t      (TYPE_MAX_VALUE (gnu_base_index_type), gnu_result);\n \t    tree gnu_expr_l, gnu_expr_h, gnu_expr_type;\n \n-\t   gnu_min_expr = protect_multiple_eval (gnu_min_expr);\n-\t   gnu_max_expr = protect_multiple_eval (gnu_max_expr);\n+\t   gnu_min_expr = gnat_protect_expr (gnu_min_expr);\n+\t   gnu_max_expr = gnat_protect_expr (gnu_max_expr);\n \n \t    /* Derive a good type to convert everything to.  */\n \t    gnu_expr_type = get_base_type (gnu_index_type);\n@@ -3989,7 +3986,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t   ? Designated_Type (Etype\n \t\t\t\t\t\t      (Prefix (gnat_node)))\n \t\t\t\t   : Etype (Prefix (gnat_node))))\n-\t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, false);\n+\t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, false, NULL);\n \n \t    gnu_result\n \t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field,\n@@ -4177,7 +4174,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \telse\n \t  {\n \t    tree t1, t2;\n-\t    gnu_obj = protect_multiple_eval (gnu_obj);\n+\t    gnu_obj = gnat_protect_expr (gnu_obj);\n \t    t1 = build_binary_op (GE_EXPR, gnu_result_type, gnu_obj, gnu_low);\n \t    if (EXPR_P (t1))\n \t      set_expr_location_from_node (t1, gnat_node);\n@@ -5293,7 +5290,7 @@ gnat_to_gnu (Node_Id gnat_node)\n   if (TREE_SIDE_EFFECTS (gnu_result)\n       && (TREE_CODE (gnu_result_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))\n-    gnu_result = gnat_stabilize_reference (gnu_result, false);\n+    gnu_result = gnat_stabilize_reference (gnu_result, false, NULL);\n \n   /* Now convert the result to the result type, unless we are in one of the\n      following cases:\n@@ -6272,7 +6269,7 @@ build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand,\n {\n   gcc_assert (code == NEGATE_EXPR || code == ABS_EXPR);\n \n-  operand = protect_multiple_eval (operand);\n+  operand = gnat_protect_expr (operand);\n \n   return emit_check (build_binary_op (EQ_EXPR, integer_type_node,\n \t\t\t\t      operand, TYPE_MIN_VALUE (gnu_type)),\n@@ -6291,8 +6288,8 @@ static tree\n build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t\t       tree right, Node_Id gnat_node)\n {\n-  tree lhs = protect_multiple_eval (left);\n-  tree rhs = protect_multiple_eval (right);\n+  tree lhs = gnat_protect_expr (left);\n+  tree rhs = gnat_protect_expr (right);\n   tree type_max = TYPE_MAX_VALUE (gnu_type);\n   tree type_min = TYPE_MIN_VALUE (gnu_type);\n   tree gnu_expr;\n@@ -6488,7 +6485,7 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type, Node_Id gnat_node)\n     return gnu_expr;\n \n   /* Checked expressions must be evaluated only once.  */\n-  gnu_expr = protect_multiple_eval (gnu_expr);\n+  gnu_expr = gnat_protect_expr (gnu_expr);\n \n   /* There's no good type to use here, so we might as well use\n      integer_type_node. Note that the form of the check is\n@@ -6528,7 +6525,7 @@ emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n   tree gnu_expr_check;\n \n   /* Checked expressions must be evaluated only once.  */\n-  gnu_expr = protect_multiple_eval (gnu_expr);\n+  gnu_expr = gnat_protect_expr (gnu_expr);\n \n   /* Must do this computation in the base type in case the expression's\n      type is an unsigned subtypes.  */\n@@ -6619,7 +6616,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n       && !(FLOAT_TYPE_P (gnu_base_type) && INTEGRAL_TYPE_P (gnu_in_basetype)))\n     {\n       /* Ensure GNU_EXPR only gets evaluated once.  */\n-      tree gnu_input = protect_multiple_eval (gnu_result);\n+      tree gnu_input = gnat_protect_expr (gnu_result);\n       tree gnu_cond = integer_zero_node;\n       tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_basetype);\n       tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_basetype);\n@@ -6728,7 +6725,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t conversion of the input to the calc_type (if necessary).  */\n \n       gnu_zero = convert (gnu_in_basetype, integer_zero_node);\n-      gnu_result = protect_multiple_eval (gnu_result);\n+      gnu_result = gnat_protect_expr (gnu_result);\n       gnu_conv = convert (calc_type, gnu_result);\n       gnu_comp\n \t= fold_build2 (GE_EXPR, integer_type_node, gnu_result, gnu_zero);\n@@ -7191,265 +7188,6 @@ maybe_implicit_deref (tree exp)\n   return exp;\n }\n \f\n-/* Protect EXP from multiple evaluation.  This may make a SAVE_EXPR.  */\n-\n-tree\n-protect_multiple_eval (tree exp)\n-{\n-  tree type = TREE_TYPE (exp);\n-  enum tree_code code = TREE_CODE (exp);\n-\n-  /* If EXP has no side effects, we theoritically don't need to do anything.\n-     However, we may be recursively passed more and more complex expressions\n-     involving checks which will be reused multiple times and eventually be\n-     unshared for gimplification; in order to avoid a complexity explosion\n-     at that point, we protect any expressions more complex than a simple\n-     arithmetic expression.  */\n-  if (!TREE_SIDE_EFFECTS (exp)\n-      && (CONSTANT_CLASS_P (exp)\n-\t  || !EXPRESSION_CLASS_P (skip_simple_arithmetic (exp))))\n-    return exp;\n-\n-  /* If this is a conversion, protect what's inside the conversion.\n-     Similarly, if we're indirectly referencing something, we only\n-     need to protect the address since the data itself can't change\n-     in these situations.  */\n-  if (code == NON_LVALUE_EXPR\n-      || CONVERT_EXPR_CODE_P (code)\n-      || code == VIEW_CONVERT_EXPR\n-      || code == INDIRECT_REF\n-      || code == UNCONSTRAINED_ARRAY_REF)\n-  return build1 (code, type, protect_multiple_eval (TREE_OPERAND (exp, 0)));\n-\n-  /* If this is a COMPONENT_REF of a fat pointer, save the entire fat pointer.\n-     This may be more efficient, but will also allow us to more easily find\n-     the match for the PLACEHOLDER_EXPR.  */\n-  if (code == COMPONENT_REF\n-      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n-    return build3 (code, type, protect_multiple_eval (TREE_OPERAND (exp, 0)),\n-\t\t   TREE_OPERAND (exp, 1), TREE_OPERAND (exp, 2));\n-\n-  /* If this is a fat pointer or something that can be placed in a register,\n-     just make a SAVE_EXPR.  Likewise for a CALL_EXPR as large objects are\n-     returned via invisible reference in most ABIs so the temporary will\n-     directly be filled by the callee.  */\n-  if (TYPE_IS_FAT_POINTER_P (type)\n-      || TYPE_MODE (type) != BLKmode\n-      || code == CALL_EXPR)\n-    return save_expr (exp);\n-\n-  /* Otherwise reference, protect the address and dereference.  */\n-  return\n-    build_unary_op (INDIRECT_REF, type,\n-\t\t    save_expr (build_unary_op (ADDR_EXPR,\n-\t\t\t\t\t       build_reference_type (type),\n-\t\t\t\t\t       exp)));\n-}\n-\f\n-/* This is equivalent to stabilize_reference in tree.c, but we know how to\n-   handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  We set SUCCESS to true unless we walk\n-   through something we don't know how to stabilize.  */\n-\n-tree\n-maybe_stabilize_reference (tree ref, bool force, bool *success)\n-{\n-  tree type = TREE_TYPE (ref);\n-  enum tree_code code = TREE_CODE (ref);\n-  tree result;\n-\n-  /* Assume we'll success unless proven otherwise.  */\n-  *success = true;\n-\n-  switch (code)\n-    {\n-    case CONST_DECL:\n-    case VAR_DECL:\n-    case PARM_DECL:\n-    case RESULT_DECL:\n-      /* No action is needed in this case.  */\n-      return ref;\n-\n-    case ADDR_EXPR:\n-    CASE_CONVERT:\n-    case FLOAT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-    case VIEW_CONVERT_EXPR:\n-      result\n-\t= build1 (code, type,\n-\t\t  maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t     success));\n-      break;\n-\n-    case INDIRECT_REF:\n-    case UNCONSTRAINED_ARRAY_REF:\n-      result = build1 (code, type,\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n-\t\t\t\t\t\t   force));\n-      break;\n-\n-    case COMPONENT_REF:\n-     result = build3 (COMPONENT_REF, type,\n-\t\t      maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t success),\n-\t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n-      break;\n-\n-    case BIT_FIELD_REF:\n-      result = build3 (BIT_FIELD_REF, type,\n-\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t  success),\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t   force),\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n-\t\t\t\t\t\t   force));\n-      break;\n-\n-    case ARRAY_REF:\n-    case ARRAY_RANGE_REF:\n-      result = build4 (code, type,\n-\t\t       maybe_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t  success),\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t   force),\n-\t\t       NULL_TREE, NULL_TREE);\n-      break;\n-\n-    case CALL_EXPR:\n-    case COMPOUND_EXPR:\n-      result = gnat_stabilize_reference_1 (ref, force);\n-      break;\n-\n-    case CONSTRUCTOR:\n-      /* Constructors with 1 element are used extensively to formally\n-\t convert objects to special wrapping types.  */\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ref)) == 1)\n-\t{\n-\t  tree index\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->index;\n-\t  tree value\n-\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->value;\n-\t  result\n-\t    = build_constructor_single (type, index,\n-\t\t\t\t\tgnat_stabilize_reference_1 (value,\n-\t\t\t\t\t\t\t\t    force));\n-\t}\n-      else\n-\t{\n-\t  *success = false;\n-\t  return ref;\n-\t}\n-      break;\n-\n-    case ERROR_MARK:\n-      ref = error_mark_node;\n-\n-      /* ...  fall through to failure ... */\n-\n-      /* If arg isn't a kind of lvalue we recognize, make no change.\n-\t Caller should recognize the error for an invalid lvalue.  */\n-    default:\n-      *success = false;\n-      return ref;\n-    }\n-\n-  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS set on the initial expression\n-     may not be sustained across some paths, such as the way via build1 for\n-     INDIRECT_REF.  We reset those flags here in the general case, which is\n-     consistent with the GCC version of this routine.\n-\n-     Special care should be taken regarding TREE_SIDE_EFFECTS, because some\n-     paths introduce side-effects where there was none initially (e.g. if a\n-     SAVE_EXPR is built) and we also want to keep track of that.  */\n-  TREE_READONLY (result) = TREE_READONLY (ref);\n-  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n-  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n-\n-  return result;\n-}\n-\n-/* Wrapper around maybe_stabilize_reference, for common uses without lvalue\n-   restrictions and without the need to examine the success indication.  */\n-\n-static tree\n-gnat_stabilize_reference (tree ref, bool force)\n-{\n-  bool dummy;\n-  return maybe_stabilize_reference (ref, force, &dummy);\n-}\n-\n-/* Similar to stabilize_reference_1 in tree.c, but supports an extra\n-   arg to force a SAVE_EXPR for everything.  */\n-\n-static tree\n-gnat_stabilize_reference_1 (tree e, bool force)\n-{\n-  enum tree_code code = TREE_CODE (e);\n-  tree type = TREE_TYPE (e);\n-  tree result;\n-\n-  /* We cannot ignore const expressions because it might be a reference\n-     to a const array but whose index contains side-effects.  But we can\n-     ignore things that are actual constant or that already have been\n-     handled by this function.  */\n-  if (TREE_CONSTANT (e) || code == SAVE_EXPR)\n-    return e;\n-\n-  switch (TREE_CODE_CLASS (code))\n-    {\n-    case tcc_exceptional:\n-    case tcc_declaration:\n-    case tcc_comparison:\n-    case tcc_expression:\n-    case tcc_reference:\n-    case tcc_vl_exp:\n-      /* If this is a COMPONENT_REF of a fat pointer, save the entire\n-\t fat pointer.  This may be more efficient, but will also allow\n-\t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n-      if (code == COMPONENT_REF\n-\t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n-\tresult\n-\t  = build3 (code, type,\n-\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n-\t\t    TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n-      /* If the expression has side-effects, then encase it in a SAVE_EXPR\n-\t so that it will only be evaluated once.  */\n-      /* The tcc_reference and tcc_comparison classes could be handled as\n-\t below, but it is generally faster to only evaluate them once.  */\n-      else if (TREE_SIDE_EFFECTS (e) || force)\n-\treturn save_expr (e);\n-      else\n-\treturn e;\n-      break;\n-\n-    case tcc_binary:\n-      /* Recursively stabilize each operand.  */\n-      result\n-\t= build2 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), force));\n-      break;\n-\n-    case tcc_unary:\n-      /* Recursively stabilize each operand.  */\n-      result\n-\t= build1 (code, type,\n-\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* See similar handling in maybe_stabilize_reference.  */\n-  TREE_READONLY (result) = TREE_READONLY (e);\n-  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n-  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n-\n-  return result;\n-}\n-\f\n /* Convert SLOC into LOCUS.  Return true if SLOC corresponds to a source code\n    location and false if it doesn't.  In the former case, set the Gigi global\n    variable REF_FILENAME to the simple debug file name as given by sinput.  */"}, {"sha": "a59b565b77b033081da1ce4db9a9cf83e2b32fff", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -3587,7 +3587,7 @@ convert_to_fat_pointer (tree type, tree expr)\n     {\n       tree fields = TYPE_FIELDS (TREE_TYPE (etype));\n \n-      expr = protect_multiple_eval (expr);\n+      expr = gnat_protect_expr (expr);\n       if (TREE_CODE (expr) == ADDR_EXPR)\n \texpr = TREE_OPERAND (expr, 0);\n       else"}, {"sha": "a6ec65fd54d0f52457eee6b17c46a4d7e1cc1458", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 297, "deletions": 7, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7d7a1fe85989e4f3998060ed9f2d4d6973e39eed/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=7d7a1fe85989e4f3998060ed9f2d4d6973e39eed", "patch": "@@ -254,10 +254,10 @@ compare_arrays (tree result_type, tree a1, tree a2)\n   /* If either operand has side-effects, they have to be evaluated only once\n      in spite of the multiple references to the operand in the comparison.  */\n   if (a1_side_effects_p)\n-    a1 = protect_multiple_eval (a1);\n+    a1 = gnat_protect_expr (a1);\n \n   if (a2_side_effects_p)\n-    a2 = protect_multiple_eval (a2);\n+    a2 = gnat_protect_expr (a2);\n \n   /* Process each dimension separately and compare the lengths.  If any\n      dimension has a size known to be zero, set SIZE_ZERO_P to 1 to\n@@ -471,7 +471,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* For subtraction, add the modulus back if we are negative.  */\n   else if (op_code == MINUS_EXPR)\n     {\n-      result = protect_multiple_eval (result);\n+      result = gnat_protect_expr (result);\n       result = fold_build3 (COND_EXPR, op_type,\n \t\t\t    fold_build2 (LT_EXPR, integer_type_node, result,\n \t\t\t\t\t convert (op_type, integer_zero_node)),\n@@ -482,7 +482,7 @@ nonbinary_modular_operation (enum tree_code op_code, tree type, tree lhs,\n   /* For the other operations, subtract the modulus if we are >= it.  */\n   else\n     {\n-      result = protect_multiple_eval (result);\n+      result = gnat_protect_expr (result);\n       result = fold_build3 (COND_EXPR, op_type,\n \t\t\t    fold_build2 (GE_EXPR, integer_type_node,\n \t\t\t\t\t result, modulus),\n@@ -1800,7 +1800,7 @@ maybe_wrap_malloc (tree data_size, tree data_type, Node_Id gnat_node)\n     {\n       /* Latch malloc's return value and get a pointer to the aligning field\n \t first.  */\n-      tree storage_ptr = protect_multiple_eval (malloc_ptr);\n+      tree storage_ptr = gnat_protect_expr (malloc_ptr);\n \n       tree aligning_record_addr\n \t= convert (build_pointer_type (aligning_type), storage_ptr);\n@@ -1961,7 +1961,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n       storage = build_call_alloc_dealloc (NULL_TREE, size, storage_type,\n \t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n-      storage = convert (storage_ptr_type, protect_multiple_eval (storage));\n+      storage = convert (storage_ptr_type, gnat_protect_expr (storage));\n \n       if (TYPE_IS_PADDING_P (type))\n \t{\n@@ -2039,7 +2039,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n      and return the address with a COMPOUND_EXPR.  */\n   if (init)\n     {\n-      result = protect_multiple_eval (result);\n+      result = gnat_protect_expr (result);\n       result\n \t= build2 (COMPOUND_EXPR, TREE_TYPE (result),\n \t\t  build_binary_op\n@@ -2147,3 +2147,293 @@ gnat_mark_addressable (tree t)\n \treturn true;\n     }\n }\n+\f\n+/* Save EXP for later use or reuse.  This is equivalent to save_expr in tree.c\n+   but we know how to handle our own nodes.  */\n+\n+tree\n+gnat_save_expr (tree exp)\n+{\n+  tree type = TREE_TYPE (exp);\n+  enum tree_code code = TREE_CODE (exp);\n+\n+  if (TREE_CONSTANT (exp) || code == SAVE_EXPR || code == NULL_EXPR)\n+    return exp;\n+\n+  if (code == UNCONSTRAINED_ARRAY_REF)\n+    {\n+      tree t = build1 (code, type, gnat_save_expr (TREE_OPERAND (exp, 0)));\n+      TREE_READONLY (t) = TYPE_READONLY (type);\n+      return t;\n+    }\n+\n+  /* If this is a COMPONENT_REF of a fat pointer, save the entire fat pointer.\n+     This may be more efficient, but will also allow us to more easily find\n+     the match for the PLACEHOLDER_EXPR.  */\n+  if (code == COMPONENT_REF\n+      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+    return build3 (code, type, gnat_save_expr (TREE_OPERAND (exp, 0)),\n+\t\t   TREE_OPERAND (exp, 1), TREE_OPERAND (exp, 2));\n+\n+  return save_expr (exp);\n+}\n+\n+/* Protect EXP for immediate reuse.  This is a variant of gnat_save_expr that\n+   is optimized under the assumption that EXP's value doesn't change before\n+   its subsequent reuse(s) except through its potential reevaluation.  */\n+\n+tree\n+gnat_protect_expr (tree exp)\n+{\n+  tree type = TREE_TYPE (exp);\n+  enum tree_code code = TREE_CODE (exp);\n+\n+  if (TREE_CONSTANT (exp) || code == SAVE_EXPR || code == NULL_EXPR)\n+    return exp;\n+\n+  /* If EXP has no side effects, we theoritically don't need to do anything.\n+     However, we may be recursively passed more and more complex expressions\n+     involving checks which will be reused multiple times and eventually be\n+     unshared for gimplification; in order to avoid a complexity explosion\n+     at that point, we protect any expressions more complex than a simple\n+     arithmetic expression.  */\n+  if (!TREE_SIDE_EFFECTS (exp)\n+      && !EXPRESSION_CLASS_P (skip_simple_arithmetic (exp)))\n+    return exp;\n+\n+  /* If this is a conversion, protect what's inside the conversion.  */\n+  if (code == NON_LVALUE_EXPR\n+      || CONVERT_EXPR_CODE_P (code)\n+      || code == VIEW_CONVERT_EXPR)\n+  return build1 (code, type, gnat_protect_expr (TREE_OPERAND (exp, 0)));\n+\n+  /* If we're indirectly referencing something, we only need to protect the\n+     address since the data itself can't change in these situations.  */\n+  if (code == INDIRECT_REF || code == UNCONSTRAINED_ARRAY_REF)\n+    {\n+      tree t = build1 (code, type, gnat_protect_expr (TREE_OPERAND (exp, 0)));\n+      TREE_READONLY (t) = TYPE_READONLY (type);\n+      return t;\n+    }\n+\n+  /* If this is a COMPONENT_REF of a fat pointer, save the entire fat pointer.\n+     This may be more efficient, but will also allow us to more easily find\n+     the match for the PLACEHOLDER_EXPR.  */\n+  if (code == COMPONENT_REF\n+      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+    return build3 (code, type, gnat_protect_expr (TREE_OPERAND (exp, 0)),\n+\t\t   TREE_OPERAND (exp, 1), TREE_OPERAND (exp, 2));\n+\n+  /* If this is a fat pointer or something that can be placed in a register,\n+     just make a SAVE_EXPR.  Likewise for a CALL_EXPR as large objects are\n+     returned via invisible reference in most ABIs so the temporary will\n+     directly be filled by the callee.  */\n+  if (TYPE_IS_FAT_POINTER_P (type)\n+      || TYPE_MODE (type) != BLKmode\n+      || code == CALL_EXPR)\n+    return save_expr (exp);\n+\n+  /* Otherwise reference, protect the address and dereference.  */\n+  return\n+    build_unary_op (INDIRECT_REF, type,\n+\t\t    save_expr (build_unary_op (ADDR_EXPR,\n+\t\t\t\t\t       build_reference_type (type),\n+\t\t\t\t\t       exp)));\n+}\n+\n+/* This is equivalent to stabilize_reference_1 in tree.c but we take an extra\n+   argument to force evaluation of everything.  */\n+\n+static tree\n+gnat_stabilize_reference_1 (tree e, bool force)\n+{\n+  enum tree_code code = TREE_CODE (e);\n+  tree type = TREE_TYPE (e);\n+  tree result;\n+\n+  /* We cannot ignore const expressions because it might be a reference\n+     to a const array but whose index contains side-effects.  But we can\n+     ignore things that are actual constant or that already have been\n+     handled by this function.  */\n+  if (TREE_CONSTANT (e) || code == SAVE_EXPR)\n+    return e;\n+\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_exceptional:\n+    case tcc_declaration:\n+    case tcc_comparison:\n+    case tcc_expression:\n+    case tcc_reference:\n+    case tcc_vl_exp:\n+      /* If this is a COMPONENT_REF of a fat pointer, save the entire\n+\t fat pointer.  This may be more efficient, but will also allow\n+\t us to more easily find the match for the PLACEHOLDER_EXPR.  */\n+      if (code == COMPONENT_REF\n+\t  && TYPE_IS_FAT_POINTER_P (TREE_TYPE (TREE_OPERAND (e, 0))))\n+\tresult\n+\t  = build3 (code, type,\n+\t\t    gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t    TREE_OPERAND (e, 1), TREE_OPERAND (e, 2));\n+      /* If the expression has side-effects, then encase it in a SAVE_EXPR\n+\t so that it will only be evaluated once.  */\n+      /* The tcc_reference and tcc_comparison classes could be handled as\n+\t below, but it is generally faster to only evaluate them once.  */\n+      else if (TREE_SIDE_EFFECTS (e) || force)\n+\treturn save_expr (e);\n+      else\n+\treturn e;\n+      break;\n+\n+    case tcc_binary:\n+      /* Recursively stabilize each operand.  */\n+      result\n+\t= build2 (code, type,\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force),\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 1), force));\n+      break;\n+\n+    case tcc_unary:\n+      /* Recursively stabilize each operand.  */\n+      result\n+\t= build1 (code, type,\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (e, 0), force));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* See similar handling in gnat_stabilize_reference.  */\n+  TREE_READONLY (result) = TREE_READONLY (e);\n+  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n+\n+  return result;\n+}\n+\n+/* This is equivalent to stabilize_reference in tree.c but we know how to\n+   handle our own nodes and we take extra arguments.  FORCE says whether to\n+   force evaluation of everything.  We set SUCCESS to true unless we walk\n+   through something we don't know how to stabilize.  */\n+\n+tree\n+gnat_stabilize_reference (tree ref, bool force, bool *success)\n+{\n+  tree type = TREE_TYPE (ref);\n+  enum tree_code code = TREE_CODE (ref);\n+  tree result;\n+\n+  /* Assume we'll success unless proven otherwise.  */\n+  if (success)\n+    *success = true;\n+\n+  switch (code)\n+    {\n+    case CONST_DECL:\n+    case VAR_DECL:\n+    case PARM_DECL:\n+    case RESULT_DECL:\n+      /* No action is needed in this case.  */\n+      return ref;\n+\n+    case ADDR_EXPR:\n+    CASE_CONVERT:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+    case VIEW_CONVERT_EXPR:\n+      result\n+\t= build1 (code, type,\n+\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t    success));\n+      break;\n+\n+    case INDIRECT_REF:\n+    case UNCONSTRAINED_ARRAY_REF:\n+      result = build1 (code, type,\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 0),\n+\t\t\t\t\t\t   force));\n+      break;\n+\n+    case COMPONENT_REF:\n+     result = build3 (COMPONENT_REF, type,\n+\t\t      gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\tsuccess),\n+\t\t      TREE_OPERAND (ref, 1), NULL_TREE);\n+      break;\n+\n+    case BIT_FIELD_REF:\n+      result = build3 (BIT_FIELD_REF, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t success),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t   force),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 2),\n+\t\t\t\t\t\t   force));\n+      break;\n+\n+    case ARRAY_REF:\n+    case ARRAY_RANGE_REF:\n+      result = build4 (code, type,\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n+\t\t\t\t\t\t success),\n+\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n+\t\t\t\t\t\t   force),\n+\t\t       NULL_TREE, NULL_TREE);\n+      break;\n+\n+    case CALL_EXPR:\n+    case COMPOUND_EXPR:\n+      result = gnat_stabilize_reference_1 (ref, force);\n+      break;\n+\n+    case CONSTRUCTOR:\n+      /* Constructors with 1 element are used extensively to formally\n+\t convert objects to special wrapping types.  */\n+      if (TREE_CODE (type) == RECORD_TYPE\n+\t  && VEC_length (constructor_elt, CONSTRUCTOR_ELTS (ref)) == 1)\n+\t{\n+\t  tree index\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->index;\n+\t  tree value\n+\t    = VEC_index (constructor_elt, CONSTRUCTOR_ELTS (ref), 0)->value;\n+\t  result\n+\t    = build_constructor_single (type, index,\n+\t\t\t\t\tgnat_stabilize_reference_1 (value,\n+\t\t\t\t\t\t\t\t    force));\n+\t}\n+      else\n+\t{\n+\t  if (success)\n+\t    *success = false;\n+\t  return ref;\n+\t}\n+      break;\n+\n+    case ERROR_MARK:\n+      ref = error_mark_node;\n+\n+      /* ...  fall through to failure ... */\n+\n+      /* If arg isn't a kind of lvalue we recognize, make no change.\n+\t Caller should recognize the error for an invalid lvalue.  */\n+    default:\n+      if (success)\n+\t*success = false;\n+      return ref;\n+    }\n+\n+  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS set on the initial expression\n+     may not be sustained across some paths, such as the way via build1 for\n+     INDIRECT_REF.  We reset those flags here in the general case, which is\n+     consistent with the GCC version of this routine.\n+\n+     Special care should be taken regarding TREE_SIDE_EFFECTS, because some\n+     paths introduce side-effects where there was none initially (e.g. if a\n+     SAVE_EXPR is built) and we also want to keep track of that.  */\n+  TREE_READONLY (result) = TREE_READONLY (ref);\n+  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n+  TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n+\n+  return result;\n+}"}]}