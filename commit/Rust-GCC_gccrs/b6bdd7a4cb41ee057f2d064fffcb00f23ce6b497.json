{"sha": "b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjZiZGQ3YTRjYjQxZWUwNTdmMmQwNjRmZmZjYjAwZjIzY2U2YjQ5Nw==", "commit": {"author": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-05-16T20:07:06Z"}, "committer": {"name": "Andrew Pinski", "email": "apinski@marvell.com", "date": "2021-05-26T00:46:30Z"}, "message": "Add a couple of A?CST1:CST2 match and simplify optimizations\n\nInstead of some of the more manual optimizations inside phi-opt,\nit would be good idea to do a lot of the heavy lifting inside match\nand simplify instead. In the process, this moves the three simple\nA?CST1:CST2 (where CST1 or CST2 is zero) simplifications.\n\nOK? Boostrapped and tested on x86_64-linux-gnu with no regressions.\n\nDifferences from V1:\n* Use bit_xor 1 instead of bit_not to fix the problem with boolean types\nwhich are not 1 bit precision.\n\nThanks,\nAndrew Pinski\n\ngcc:\n\t* match.pd (A?CST1:CST2): Add simplifcations for A?0:+-1, A?+-1:0,\n\tA?POW2:0 and A?0:POW2.", "tree": {"sha": "68aac077c5e9aaae34cdd06dcdb882487eb705d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/68aac077c5e9aaae34cdd06dcdb882487eb705d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497/comments", "author": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "apinski-cavium", "id": 6335315, "node_id": "MDQ6VXNlcjYzMzUzMTU=", "avatar_url": "https://avatars.githubusercontent.com/u/6335315?v=4", "gravatar_id": "", "url": "https://api.github.com/users/apinski-cavium", "html_url": "https://github.com/apinski-cavium", "followers_url": "https://api.github.com/users/apinski-cavium/followers", "following_url": "https://api.github.com/users/apinski-cavium/following{/other_user}", "gists_url": "https://api.github.com/users/apinski-cavium/gists{/gist_id}", "starred_url": "https://api.github.com/users/apinski-cavium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/apinski-cavium/subscriptions", "organizations_url": "https://api.github.com/users/apinski-cavium/orgs", "repos_url": "https://api.github.com/users/apinski-cavium/repos", "events_url": "https://api.github.com/users/apinski-cavium/events{/privacy}", "received_events_url": "https://api.github.com/users/apinski-cavium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bc6dacecb2ba60f1f06f310c6887a26b09cdba8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc6dacecb2ba60f1f06f310c6887a26b09cdba8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc6dacecb2ba60f1f06f310c6887a26b09cdba8"}], "stats": {"total": 41, "additions": 41, "deletions": 0}, "files": [{"sha": "ad6b057c56d2bf122ddf7020e6cd7248557bb3c0", "filename": "gcc/match.pd", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=b6bdd7a4cb41ee057f2d064fffcb00f23ce6b497", "patch": "@@ -3711,6 +3711,47 @@ DEFINE_INT_AND_FLOAT_ROUND_FN (RINT)\n    (if (integer_all_onesp (@1) && integer_zerop (@2))\n     @0))))\n \n+/* A few simplifications of \"a ? CST1 : CST2\". */\n+/* NOTE: Only do this on gimple as the if-chain-to-switch\n+   optimization depends on the gimple to have if statements in it. */\n+#if GIMPLE\n+(simplify\n+ (cond @0 INTEGER_CST@1 INTEGER_CST@2)\n+ (switch\n+  (if (integer_zerop (@2))\n+   (switch\n+    /* a ? 1 : 0 -> a if 0 and 1 are integral types. */\n+    (if (integer_onep (@1))\n+     (convert (convert:boolean_type_node @0)))\n+    /* a ? -1 : 0 -> -a. */\n+    (if (integer_all_onesp (@1))\n+     (negate (convert (convert:boolean_type_node @0))))\n+    /* a ? powerof2cst : 0 -> a << (log2(powerof2cst)) */\n+    (if (!POINTER_TYPE_P (type) && integer_pow2p (@1))\n+     (with {\n+       tree shift = build_int_cst (integer_type_node, tree_log2 (@1));\n+      }\n+      (lshift (convert (convert:boolean_type_node @0)) { shift; })))))\n+  (if (integer_zerop (@1))\n+   (with {\n+      tree booltrue = constant_boolean_node (true, boolean_type_node);\n+    }\n+    (switch\n+     /* a ? 0 : 1 -> !a. */\n+     (if (integer_onep (@2))\n+      (convert (bit_xor (convert:boolean_type_node @0) { booltrue; } )))\n+     /* a ? -1 : 0 -> -(!a). */\n+     (if (integer_all_onesp (@2))\n+      (negate (convert (bit_xor (convert:boolean_type_node @0) { booltrue; } ))))\n+     /* a ? powerof2cst : 0 -> (!a) << (log2(powerof2cst)) */\n+     (if (!POINTER_TYPE_P (type) && integer_pow2p (@2))\n+      (with {\n+\ttree shift = build_int_cst (integer_type_node, tree_log2 (@2));\n+       }\n+       (lshift (convert (bit_xor (convert:boolean_type_node @0) { booltrue; } ))\n+        { shift; }))))))))\n+#endif\n+\n /* Simplification moved from fold_cond_expr_with_comparison.  It may also\n    be extended.  */\n /* This pattern implements two kinds simplification:"}]}