{"sha": "6004caaf4dd656f955034b444a38a3a886a035c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjAwNGNhYWY0ZGQ2NTZmOTU1MDM0YjQ0NGEzOGEzYTg4NmEwMzVjMQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2007-01-21T09:22:56Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2007-01-21T09:22:56Z"}, "message": "tree-vectorizer.h (struct _stmt_vec_info): Add new field read_write_dep and macros for its access.\n\n\t* tree-vectorizer.h (struct _stmt_vec_info): Add new field\n\tread_write_dep and macros for its access.\n\t* tree-vectorizer.c (new_stmt_vec_info): Initialize the new field.\n\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Remove\n\targument, call vect_check_interleaving for every independent pair of\n\tdata-refs. Mark loads that access the same memory location as a store\n\tin the loop.\n\t(vect_check_dependences): Remove.\n\t(vect_analyze_data_ref_dependences): Remove  vect_check_dependences\n\tcall, fix the call to vect_analyze_data_ref_dependence.\n\t(vect_analyze_data_ref_access): For statements that access the same\n\tdata-ref, check that they are not stores; for loads, check that there\n\tis no store that access the same location.\n\nFrom-SVN: r121026", "tree": {"sha": "05e8577ec4efe6bacd28333f67700b524ca9e2a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05e8577ec4efe6bacd28333f67700b524ca9e2a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6004caaf4dd656f955034b444a38a3a886a035c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6004caaf4dd656f955034b444a38a3a886a035c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6004caaf4dd656f955034b444a38a3a886a035c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6004caaf4dd656f955034b444a38a3a886a035c1/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "52b213f385400a4f4adfa2a167fe8ec6303e4ca7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52b213f385400a4f4adfa2a167fe8ec6303e4ca7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52b213f385400a4f4adfa2a167fe8ec6303e4ca7"}], "stats": {"total": 190, "additions": 138, "deletions": 52}, "files": [{"sha": "de0752707b2d05a2856605edf0f2fff8816b4935", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -1,3 +1,19 @@\n+2007-01-21  Ira Rosen  <irar@il.ibm.com>\n+\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add new field \n+\tread_write_dep and macros for its access.\n+\t* tree-vectorizer.c (new_stmt_vec_info): Initialize the new field.\n+\t* tree-vect-analyze.c (vect_analyze_data_ref_dependence): Remove \n+\targument, call vect_check_interleaving for every independent pair of\n+\tdata-refs. Mark loads that access the same memory location as a store\n+\tin the loop.\n+\t(vect_check_dependences): Remove.\n+\t(vect_analyze_data_ref_dependences): Remove  vect_check_dependences \n+\tcall, fix the call to vect_analyze_data_ref_dependence.\n+\t(vect_analyze_data_ref_access): For statements that access the same \n+\tdata-ref, check that they are not stores; for loads, check that there\n+\tis no store that access the same location.\n+\n 2007-01-20  Roger Sayle  <roger@eyesopen.com>\n \t    Joseph Myers  <joseph@codesourcery.com>\n "}, {"sha": "d248286770ee9dc6a567df31d53b70584f49b808", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -1,3 +1,7 @@\n+2007-01-21  Ira Rosen  <irar@il.ibm.com> \n+\n+\t* gcc.dg/vect/vect-strided-same-dr.c: New test. \n+\n 2007-01-20  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR objc/30479"}, {"sha": "f04658d1d074966fa77221978c5be27dcc77dfd2", "filename": "gcc/testsuite/gcc.dg/vect/vect-strided-same-dr.c", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-same-dr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-same-dr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-strided-same-dr.c?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -0,0 +1,77 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include <stdarg.h>\n+#include \"tree-vect.h\"\n+\n+#define N 128 \n+\n+typedef struct {\n+   unsigned short a;\n+   unsigned short b;\n+} s;\n+\n+s buffer1[N], buffer2[N];\n+\n+int\n+main1 (s * __restrict__  pIn, s* __restrict__ pOut)\n+{\n+  unsigned short i, x, y, d;\n+  s *p, *q;\n+\n+  p = pIn;\n+  q = pOut;\n+\n+  for (i = 0; i < N/2; i++)\n+    {\n+      x = pIn->a + 5;\n+      y = pIn->a + 2;\n+      pOut->a = x;\n+      pOut->b = pIn->b;\n+      pOut++;\n+      pOut->a = y;\n+      pOut->b = pIn->b;\n+      pOut++;\n+      pIn++;\n+    }\n+  \n+  /* check results:  */\n+  for (i = 0; i < N/2; i++)\n+    {\n+      if (q->a != p->a + 5\n+          || q->b != p->b)\n+         abort ();\n+      q++;\n+      if (q->a != p->a + 2\n+          || q->b != p->b)\n+        abort ();\n+      q++;\n+      p++;\n+    }\n+\n+  return 0;\n+}\n+\n+int main (void)\n+{\n+  short i;\n+\n+  for (i = 0; i < N*2; i++)\n+    { \n+      buffer1[i].a = i;\n+      buffer1[i].b = i + 8;\n+      buffer2[i].a = i * 3;\n+      buffer2[i].b = i * 2;\n+      if (buffer1[i].a == 500)\n+         abort();\n+    }\n+  \n+  check_vect ();\n+\n+  main1 (buffer1, buffer2);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\"  { target { vect_interleave && vect_extract_even_odd } } } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+  "}, {"sha": "c53c34e2c517f9389790f7fba67f7d98a40801f8", "filename": "gcc/tree-vect-analyze.c", "status": "modified", "additions": 35, "deletions": 52, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vect-analyze.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vect-analyze.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-analyze.c?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -57,7 +57,7 @@ static bool vect_determine_vectorization_factor (loop_vec_info);\n static bool exist_non_indexing_operands_for_use_p (tree, tree);\n static tree vect_get_loop_niters (struct loop *, tree *);\n static bool vect_analyze_data_ref_dependence\n-  (struct data_dependence_relation *, loop_vec_info, bool);\n+  (struct data_dependence_relation *, loop_vec_info);\n static bool vect_compute_data_ref_alignment (struct data_reference *); \n static bool vect_analyze_data_ref_access (struct data_reference *);\n static bool vect_can_advance_ivs_p (loop_vec_info);\n@@ -877,8 +877,7 @@ vect_check_interleaving (struct data_reference *dra,\n       \n static bool\n vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n-                                  loop_vec_info loop_vinfo,\n-\t\t\t\t  bool check_interleaving)\n+                                  loop_vec_info loop_vinfo)\n {\n   unsigned int i;\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -895,8 +894,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n   if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n     {\n       /* Independent data accesses.  */\n-      if (check_interleaving)\n-\tvect_check_interleaving (dra, drb);\n+      vect_check_interleaving (dra, drb);\n       return false;\n     }\n \n@@ -951,7 +949,18 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t      fprintf (vect_dump, \" and \");\n \t      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n \t    }\n-\t  continue;\n+\n+          /* For interleaving, mark that there is a read-write dependency if\n+             necessary. We check before that one of the data-refs is store.  */ \n+          if (DR_IS_READ (dra))\n+            DR_GROUP_READ_WRITE_DEPENDENCE (stmtinfo_a) = true;\n+\t  else\n+            {\n+              if (DR_IS_READ (drb))\n+                DR_GROUP_READ_WRITE_DEPENDENCE (stmtinfo_b) = true;\n+\t    }\n+\t  \n+          continue;\n \t}\n \n       if (abs (dist) >= vectorization_factor)\n@@ -979,36 +988,6 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n }\n \n \n-/* Function vect_check_dependences.\n-\n-    Return TRUE if there is a store-store or load-store dependence between\n-    data-refs in DDR, otherwise return FALSE.  */\n-\n-static bool\n-vect_check_dependences (struct data_dependence_relation *ddr)\n-{\n-  struct data_reference *dra = DDR_A (ddr);\n-  struct data_reference *drb = DDR_B (ddr);\n-\n-  if (DDR_ARE_DEPENDENT (ddr) == chrec_known || dra == drb)\n-    /* Independent or same data accesses.  */\n-    return false;\n-\n-  if (DR_IS_READ (dra) == DR_IS_READ (drb) && DR_IS_READ (dra))\n-    /* Two loads.  */\n-    return false;\n-\n-  if (vect_print_dump_info (REPORT_DR_DETAILS))\n-    {\n-      fprintf (vect_dump, \"possible store or store/load dependence between \");\n-      print_generic_expr (vect_dump, DR_REF (dra), TDF_SLIM);\n-      fprintf (vect_dump, \" and \");\n-      print_generic_expr (vect_dump, DR_REF (drb), TDF_SLIM);\n-    }\n-  return true;\n-}\n-\n-\n /* Function vect_analyze_data_ref_dependences.\n           \n    Examine all the data references in the loop, and make sure there do not\n@@ -1020,24 +999,12 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo)\n   unsigned int i;\n   VEC (ddr_p, heap) *ddrs = LOOP_VINFO_DDRS (loop_vinfo);\n   struct data_dependence_relation *ddr;\n-  bool check_interleaving = true;\n \n   if (vect_print_dump_info (REPORT_DETAILS)) \n     fprintf (vect_dump, \"=== vect_analyze_dependences ===\");\n      \n-  /* We allow interleaving only if there are no store-store and load-store\n-      dependencies in the loop.  */\n-  for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n-    {\n-      if (vect_check_dependences (ddr))\n-\t{\n-\t  check_interleaving = false;\n-\t  break;\n-\t}\n-    }\n-\n   for (i = 0; VEC_iterate (ddr_p, ddrs, i, ddr); i++)\n-    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo, check_interleaving))\n+    if (vect_analyze_data_ref_dependence (ddr, loop_vinfo))\n       return false;\n \n   return true;\n@@ -1778,9 +1745,25 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (\n \t\t\t\t\t\t      vinfo_for_stmt (next)))))\n \t    {\n-\t      /* For load use the same data-ref load. (We check in\n-\t\t vect_check_dependences() that there are no two stores to the\n-\t\t same location).  */\n+              if (!DR_IS_READ (data_ref))\n+                { \n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump, \"Two store stmts share the same dr.\");\n+                  return false; \n+                }\n+\n+              /* Check that there is no load-store dependecies for this loads \n+                 to prevent a case of load-store-load to the same location.  */\n+              if (DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (next))\n+                  || DR_GROUP_READ_WRITE_DEPENDENCE (vinfo_for_stmt (prev)))\n+                {\n+                  if (vect_print_dump_info (REPORT_DETAILS))\n+                    fprintf (vect_dump, \n+                             \"READ_WRITE dependence in interleaving.\");\n+                  return false;\n+                }\n+\n+\t      /* For load use the same data-ref load.  */\n \t      DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n \n \t      prev = next;"}, {"sha": "ee137314dd406922521f07214da7d7b19ba096fc", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -1373,6 +1373,7 @@ new_stmt_vec_info (tree stmt, loop_vec_info loop_vinfo)\n   DR_GROUP_STORE_COUNT (res) = 0;\n   DR_GROUP_GAP (res) = 0;\n   DR_GROUP_SAME_DR_STMT (res) = NULL_TREE;\n+  DR_GROUP_READ_WRITE_DEPENDENCE (res) = false;\n \n   return res;\n }"}, {"sha": "a13ee1e5c699a045eafdd08359eab48fff7381b7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6004caaf4dd656f955034b444a38a3a886a035c1/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=6004caaf4dd656f955034b444a38a3a886a035c1", "patch": "@@ -252,6 +252,9 @@ typedef struct _stmt_vec_info {\n   /* In case that two or more stmts share data-ref, this is the pointer to the\n      previously detected stmt with the same dr.  */\n   tree same_dr_stmt;\n+  /* For loads only, if there is a store with the same location, this field is\n+     TRUE.  */\n+  bool read_write_dep;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n@@ -273,13 +276,15 @@ typedef struct _stmt_vec_info {\n #define STMT_VINFO_DR_GROUP_STORE_COUNT(S) (S)->store_count\n #define STMT_VINFO_DR_GROUP_GAP(S)         (S)->gap\n #define STMT_VINFO_DR_GROUP_SAME_DR_STMT(S)(S)->same_dr_stmt\n+#define STMT_VINFO_DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n #define DR_GROUP_FIRST_DR(S)               (S)->first_dr\n #define DR_GROUP_NEXT_DR(S)                (S)->next_dr\n #define DR_GROUP_SIZE(S)                   (S)->size\n #define DR_GROUP_STORE_COUNT(S)            (S)->store_count\n #define DR_GROUP_GAP(S)                    (S)->gap\n #define DR_GROUP_SAME_DR_STMT(S)           (S)->same_dr_stmt\n+#define DR_GROUP_READ_WRITE_DEPENDENCE(S)  (S)->read_write_dep\n \n #define STMT_VINFO_RELEVANT_P(S)          ((S)->relevant != vect_unused_in_loop)\n "}]}