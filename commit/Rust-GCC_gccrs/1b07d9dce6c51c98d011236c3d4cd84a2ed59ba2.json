{"sha": "1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "node_id": "C_kwDOANBUbNoAKDFiMDdkOWRjZTZjNTFjOThkMDExMjM2YzNkNGNkODRhMmVkNTliYTI", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-23T16:47:45Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-09-23T16:48:48Z"}, "message": "Fortran: Handle allocated() with coindexed scalars [PR93834]\n\nWhile for an allocatable 'array', 'array(:)' and 'array(:)[1]' are\nnot allocatable, it is believed that not only 'scalar' but also\n'scalar[1]' is allocatable.  However, coarrays are collectively\nestablished/allocated; thus, 'allocated(scalar[i])' is equivalent\nto 'allocated(scalar)'. [At least when assuming that 'i' does not\nrefer to a failed image.]\n\n2021-09-23  Harald Anlauf  <anlauf@gmx.de>\n\t    Tobias Burnus  <tobias@codesourcery.com>\n\n\tPR fortran/93834\ngcc/fortran/ChangeLog:\n\n\t* trans-intrinsic.c (gfc_conv_allocated): Cleanup. Handle\n\tcoindexed scalar coarrays.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/coarray/coarray_allocated.f90: New test.", "tree": {"sha": "69692653253ae23ae0fdd16ca84dd8d1b834d6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/69692653253ae23ae0fdd16ca84dd8d1b834d6c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3585c0836e729bed56b9afd4292177673a25ca0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3585c0836e729bed56b9afd4292177673a25ca0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3585c0836e729bed56b9afd4292177673a25ca0"}], "stats": {"total": 110, "additions": 89, "deletions": 21}, "files": [{"sha": "612ca41a0169c6e62054b0226ad104ee589248e1", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "patch": "@@ -8887,50 +8887,63 @@ caf_this_image_ref (gfc_ref *ref)\n static void\n gfc_conv_allocated (gfc_se *se, gfc_expr *expr)\n {\n-  gfc_actual_arglist *arg1;\n   gfc_se arg1se;\n   tree tmp;\n-  symbol_attribute caf_attr;\n+  bool coindexed_caf_comp = false;\n+  gfc_expr *e = expr->value.function.actual->expr;\n \n   gfc_init_se (&arg1se, NULL);\n-  arg1 = expr->value.function.actual;\n-\n-  if (arg1->expr->ts.type == BT_CLASS)\n+  if (e->ts.type == BT_CLASS)\n     {\n       /* Make sure that class array expressions have both a _data\n \t component reference and an array reference....  */\n-      if (CLASS_DATA (arg1->expr)->attr.dimension)\n-\tgfc_add_class_array_ref (arg1->expr);\n+      if (CLASS_DATA (e)->attr.dimension)\n+\tgfc_add_class_array_ref (e);\n       /* .... whilst scalars only need the _data component.  */\n       else\n-\tgfc_add_data_component (arg1->expr);\n+\tgfc_add_data_component (e);\n     }\n \n-  /* When arg1 references an allocatable component in a coarray, then call\n+  /* When 'e' references an allocatable component in a coarray, then call\n      the caf-library function caf_is_present ().  */\n-  if (flag_coarray == GFC_FCOARRAY_LIB && arg1->expr->expr_type == EXPR_FUNCTION\n-      && arg1->expr->value.function.isym\n-      && arg1->expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n-    caf_attr = gfc_caf_attr (arg1->expr->value.function.actual->expr);\n-  else\n-    gfc_clear_attr (&caf_attr);\n-  if (flag_coarray == GFC_FCOARRAY_LIB && caf_attr.codimension\n-      && !caf_this_image_ref (arg1->expr->value.function.actual->expr->ref))\n-    tmp = trans_caf_is_present (se, arg1->expr->value.function.actual->expr);\n+  if (flag_coarray == GFC_FCOARRAY_LIB && e->expr_type == EXPR_FUNCTION\n+      && e->value.function.isym\n+      && e->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    {\n+      e = e->value.function.actual->expr;\n+      if (gfc_expr_attr (e).codimension)\n+\t{\n+\t  /* Last partref is the coindexed coarray. As coarrays are collectively\n+\t     (de)allocated, the allocation status must be the same as the one of\n+\t     the local allocation.  Convert to local access. */\n+\t  for (gfc_ref *ref = e->ref; ref; ref = ref->next)\n+\t    if (ref->type == REF_ARRAY && ref->u.ar.codimen)\n+\t      {\n+\t\tfor (int i = ref->u.ar.dimen;\n+\t\t     i < ref->u.ar.dimen + ref->u.ar.codimen; ++i)\n+\t\tref->u.ar.dimen_type[i] = DIMEN_THIS_IMAGE;\n+\t\tbreak;\n+\t      }\n+\t}\n+      else if (!caf_this_image_ref (e->ref))\n+\tcoindexed_caf_comp = true;\n+    }\n+  if (coindexed_caf_comp)\n+    tmp = trans_caf_is_present (se, e);\n   else\n     {\n-      if (arg1->expr->rank == 0)\n+      if (e->rank == 0)\n \t{\n \t  /* Allocatable scalar.  */\n \t  arg1se.want_pointer = 1;\n-\t  gfc_conv_expr (&arg1se, arg1->expr);\n+\t  gfc_conv_expr (&arg1se, e);\n \t  tmp = arg1se.expr;\n \t}\n       else\n \t{\n \t  /* Allocatable array.  */\n \t  arg1se.descriptor_only = 1;\n-\t  gfc_conv_expr_descriptor (&arg1se, arg1->expr);\n+\t  gfc_conv_expr_descriptor (&arg1se, e);\n \t  tmp = gfc_conv_descriptor_data_get (arg1se.expr);\n \t}\n "}, {"sha": "a423d1f126eaadae9f1cdc55430c989b637fbcde", "filename": "gcc/testsuite/gfortran.dg/coarray/coarray_allocated.f90", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoarray_allocated.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoarray_allocated.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcoarray_allocated.f90?ref=1b07d9dce6c51c98d011236c3d4cd84a2ed59ba2", "patch": "@@ -0,0 +1,55 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! PR fortran/93834 - ICE in trans_caf_is_present\n+\n+program p\n+  type t\n+    integer, allocatable :: x[:,:,:]\n+  end type t\n+  integer, allocatable :: a[:]\n+  type(t) :: c\n+  if (allocated (a)) stop 1\n+  if (allocated (c%x)) stop 2\n+\n+  ! The coindexed scalar (!) variable is regarded as allocatable but\n+  ! we can check the value on any image of the team as they are\n+  ! established collectively.  As tested by the dump, we do it on\n+  ! this_image ().\n+  !\n+  ! For this reason, -fcoarray=single and -fcoarray=lib give the\n+  ! same result\n+  if (allocated (a[1])) stop 3\n+  if (allocated (c%x[1,2,3])) stop 4\n+\n+  ! Allocate collectively\n+  allocate(a[*])\n+  allocate(c%x[4,10,*])\n+\n+  if (.not. allocated (a)) stop 5\n+  if (.not. allocated (c%x)) stop 6\n+  if (.not. allocated (a[1])) stop 7\n+  if (.not. allocated (c%x[1,2,3])) stop 8\n+\n+  ! Dellocate collectively\n+  deallocate(a)\n+  deallocate(c%x)\n+\n+  if (allocated (a)) stop 9\n+  if (allocated (c%x)) stop 10\n+  if (allocated (a[1])) stop 11\n+  if (allocated (c%x[1,2,3])) stop 12\n+end\n+\n+! twice == 0 for .not. allocated' (coindexed vs. not)\n+! four times != for allocated (before alloc after dealloc, coindexed and not)\n+\n+! There are also == 0 and != 0 for (de)allocate checks with -fcoarray=single but those\n+! aren't prefixed by '(integer(kind=4) *)'\n+\n+! { dg-final { scan-tree-dump-times \"\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) a.data != 0B\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) c.x.data != 0B\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) a.data == 0B\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"\\\\(integer\\\\(kind=4\\\\) \\\\*\\\\) c.x.data == 0B\" 2 \"original\" } }\n+\n+! Expected: always local access and never a call to _gfortran_caf_get\n+! { dg-final { scan-tree-dump-not \"caf_get\" \"original\" } }"}]}