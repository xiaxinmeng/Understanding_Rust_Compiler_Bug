{"sha": "e88ebf869e234bca2535b43fd80ab744e65a3560", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg4ZWJmODY5ZTIzNGJjYTI1MzViNDNmZDgwYWI3NDRlNjVhMzU2MA==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-12-15T10:25:15Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-12-15T10:25:15Z"}, "message": "re PR libmudflap/53952 (FAIL: libmudflap.c++/pass55-frag.cxx ( -O[123]) execution test)\n\nPR libmudflap/53952\n* expr.c (mem_ref_refers_to_non_mem_p): Factor out\nimplementation into...\n(addr_expr_of_non_mem_decl_p_1): ... this new function.\n(addr_expr_of_non_mem_decl_p): New.\n* tree.h (addr_expr_of_non_mem_decl_p): Declare.\n* tree-mudflap.c (mf_xform_derefs_1): Don't change MEM_REFs\nand TARGET_MEM_REFs that have an ADDR_EXPR of a non-mem DECL\nas base operand.\n\nFrom-SVN: r194519", "tree": {"sha": "020f9b5c8e9194f2a72826f846f18ab34c661b39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/020f9b5c8e9194f2a72826f846f18ab34c661b39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e88ebf869e234bca2535b43fd80ab744e65a3560", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e88ebf869e234bca2535b43fd80ab744e65a3560", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e88ebf869e234bca2535b43fd80ab744e65a3560", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e88ebf869e234bca2535b43fd80ab744e65a3560/comments", "author": null, "committer": null, "parents": [{"sha": "5a6fe81088b9a7e5242897892239b745d9273cf9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a6fe81088b9a7e5242897892239b745d9273cf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a6fe81088b9a7e5242897892239b745d9273cf9"}], "stats": {"total": 66, "additions": 57, "deletions": 9}, "files": [{"sha": "4b5d926561ff512683969eb74c86edba4d4c7475", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e88ebf869e234bca2535b43fd80ab744e65a3560", "patch": "@@ -1,3 +1,15 @@\n+2012-12-15  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR libmudflap/53952\n+\t* expr.c (mem_ref_refers_to_non_mem_p): Factor out\n+\timplementation into...\n+\t(addr_expr_of_non_mem_decl_p_1): ... this new function.\n+\t(addr_expr_of_non_mem_decl_p): New.\n+\t* tree.h (addr_expr_of_non_mem_decl_p): Declare.\n+\t* tree-mudflap.c (mf_xform_derefs_1): Don't change MEM_REFs\n+\tand TARGET_MEM_REFs that have an ADDR_EXPR of a non-mem DECL\n+\tas base operand.\n+\n 2012-12-14  Yvan Roux  <yvan.roux@linaro.org>\n \n \t* optabs.c (expand_atomic_store): Elide redundant model test."}, {"sha": "7e86983d7558525ae35cfb52037b603a6cff2fe3", "filename": "gcc/expr.c", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=e88ebf869e234bca2535b43fd80ab744e65a3560", "patch": "@@ -4557,21 +4557,48 @@ get_bit_range (unsigned HOST_WIDE_INT *bitstart,\n   *bitend = *bitstart + tree_low_cst (DECL_SIZE (repr), 1) - 1;\n }\n \n+/* Returns true if ADDR is an ADDR_EXPR of a DECL that does not reside\n+   in memory and has non-BLKmode.  DECL_RTL must not be a MEM; if\n+   DECL_RTL was not set yet, return NORTL.  */\n+\n+static inline bool\n+addr_expr_of_non_mem_decl_p_1 (tree addr, bool nortl)\n+{\n+  if (TREE_CODE (addr) != ADDR_EXPR)\n+    return false;\n+\n+  tree base = TREE_OPERAND (addr, 0);\n+\n+  if (!DECL_P (base)\n+      || TREE_ADDRESSABLE (base)\n+      || DECL_MODE (base) == BLKmode)\n+    return false;\n+\n+  if (!DECL_RTL_SET_P (base))\n+    return nortl;\n+\n+  return (!MEM_P (DECL_RTL (base)));\n+}\n+\n /* Returns true if the MEM_REF REF refers to an object that does not\n    reside in memory and has non-BLKmode.  */\n \n-static bool\n+static inline bool\n mem_ref_refers_to_non_mem_p (tree ref)\n {\n   tree base = TREE_OPERAND (ref, 0);\n-  if (TREE_CODE (base) != ADDR_EXPR)\n-    return false;\n-  base = TREE_OPERAND (base, 0);\n-  return (DECL_P (base)\n-\t  && !TREE_ADDRESSABLE (base)\n-\t  && DECL_MODE (base) != BLKmode\n-\t  && DECL_RTL_SET_P (base)\n-\t  && !MEM_P (DECL_RTL (base)));\n+  return addr_expr_of_non_mem_decl_p_1 (base, false);\n+}\n+\n+/* Return TRUE iff OP is an ADDR_EXPR of a DECL that's not\n+   addressable.  This is very much like mem_ref_refers_to_non_mem_p,\n+   but instead of the MEM_REF, it takes its base, and it doesn't\n+   assume a DECL is in memory just because its RTL is not set yet.  */\n+\n+bool\n+addr_expr_of_non_mem_decl_p (tree op)\n+{\n+  return addr_expr_of_non_mem_decl_p_1 (op, true);\n }\n \n /* Expand an assignment that stores the value of FROM into TO.  If NONTEMPORAL"}, {"sha": "90d044891889c7c7152364df488f26fe59bdf395", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=e88ebf869e234bca2535b43fd80ab744e65a3560", "patch": "@@ -877,6 +877,9 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n       break;\n \n     case MEM_REF:\n+      if (addr_expr_of_non_mem_decl_p (TREE_OPERAND (t, 0)))\n+\treturn;\n+\n       addr = fold_build_pointer_plus_loc (location, TREE_OPERAND (t, 0),\n \t\t\t\t\t  TREE_OPERAND (t, 1));\n       base = addr;\n@@ -886,6 +889,9 @@ mf_xform_derefs_1 (gimple_stmt_iterator *iter, tree *tp,\n       break;\n \n     case TARGET_MEM_REF:\n+      if (addr_expr_of_non_mem_decl_p (TMR_BASE (t)))\n+\treturn;\n+\n       addr = tree_mem_ref_addr (ptr_type_node, t);\n       base = addr;\n       limit = fold_build_pointer_plus_hwi_loc (location,"}, {"sha": "01e81b2ee1903d4bc683a70399c3a4648699281d", "filename": "gcc/tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e88ebf869e234bca2535b43fd80ab744e65a3560/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=e88ebf869e234bca2535b43fd80ab744e65a3560", "patch": "@@ -6304,6 +6304,9 @@ extern unsigned HOST_WIDE_INT compute_builtin_object_size (tree, int);\n    succeed.  */\n extern int can_move_by_pieces (unsigned HOST_WIDE_INT, unsigned int);\n \n+/* Is it an ADDR_EXPR of a DECL that's not in memory?  */\n+extern bool addr_expr_of_non_mem_decl_p (tree);\n+\n extern unsigned HOST_WIDE_INT highest_pow2_factor (const_tree);\n extern tree build_personality_function (const char *);\n "}]}