{"sha": "b344d949d25164341ca4532ce067af1b254198a0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjM0NGQ5NDlkMjUxNjQzNDFjYTQ1MzJjZTA2N2FmMWIyNTQxOThhMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2008-09-08T20:52:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2008-09-08T20:52:44Z"}, "message": "re PR c++/37302 (function parameters are declared too late)\n\n        PR c++/37302\n        * parser.c (cp_parser_parameter_declaration_list): Process the\n        PARM_DECLs as we go and push them.  Return a TREE_LIST.\n        (cp_parser_parameter_declaration_clause): Return a TREE_LIST.\n        (cp_parser_direct_declarator): Create a binding level and\n        suppress deprecated warnings in the parameter list.\n        (make_call_declarator): PARMS is now a tree.\n        * cp-tree.h (struct cp_declarator): Function parms are now a tree.\n        * decl.h (enum deprecated_states, deprecated_state): Move here.\n        * decl.c: From here.\n        (type_is_deprecated): New fn.\n        (grokparms): PARMLIST is a tree now.  Warn about parms that\n        use deprecated types.\n        * mangle.c (write_expression): Handle PARM_DECL, CALL_EXPR and\n        0-operand cast.\n        * pt.c (tsubst) [DECLTYPE_TYPE]: Set skip_evaluation.\n        (tsubst_copy) [PARM_DECL]: Handle a PARM_DECL used outside of a\n        function.\n        * name-lookup.c (pushtag): Look through function parameter scopes.\n        (pushdecl_maybe_friend): Don't set DECL_CONTEXT on a PARM_DECL\n        when we're parsing a function declarator.\n\nFrom-SVN: r140120", "tree": {"sha": "0142184b1cea337fc342e6818257e4f6cb77fa58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0142184b1cea337fc342e6818257e4f6cb77fa58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b344d949d25164341ca4532ce067af1b254198a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b344d949d25164341ca4532ce067af1b254198a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b344d949d25164341ca4532ce067af1b254198a0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b344d949d25164341ca4532ce067af1b254198a0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "37022b7c72c96135c90798684598f39fd1371b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37022b7c72c96135c90798684598f39fd1371b40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37022b7c72c96135c90798684598f39fd1371b40"}], "stats": {"total": 396, "additions": 263, "deletions": 133}, "files": [{"sha": "cd5b52cbb8abc093f2ed5576719ccbb3c83ddc83", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -1,3 +1,27 @@\n+2008-09-06  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/37302\n+\t* parser.c (cp_parser_parameter_declaration_list): Process the\n+\tPARM_DECLs as we go and push them.  Return a TREE_LIST.\n+\t(cp_parser_parameter_declaration_clause): Return a TREE_LIST.\n+\t(cp_parser_direct_declarator): Create a binding level and\n+\tsuppress deprecated warnings in the parameter list.\n+\t(make_call_declarator): PARMS is now a tree.\n+\t* cp-tree.h (struct cp_declarator): Function parms are now a tree.\n+\t* decl.h (enum deprecated_states, deprecated_state): Move here.\n+\t* decl.c: From here.\n+\t(type_is_deprecated): New fn.\n+\t(grokparms): PARMLIST is a tree now.  Warn about parms that\n+\tuse deprecated types.\n+\t* mangle.c (write_expression): Handle PARM_DECL, CALL_EXPR and\n+\t0-operand cast.\n+\t* pt.c (tsubst) [DECLTYPE_TYPE]: Set skip_evaluation.\n+\t(tsubst_copy) [PARM_DECL]: Handle a PARM_DECL used outside of a \n+\tfunction.\n+\t* name-lookup.c (pushtag): Look through function parameter scopes.\n+\t(pushdecl_maybe_friend): Don't set DECL_CONTEXT on a PARM_DECL \n+\twhen we're parsing a function declarator.\n+\n 2008-09-05  Douglas Gregor  <doug.gregor@gmail.com>\n \n        PR c++/37342"}, {"sha": "4f6716b4c5bee23d2623a0f297a07e9a21066f38", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -4108,8 +4108,8 @@ struct cp_declarator {\n     } id;\n     /* For functions.  */\n     struct {\n-      /* The parameters to the function.  */\n-      cp_parameter_declarator *parameters;\n+      /* The parameters to the function as a TREE_LIST of decl/default.  */\n+      tree parameters;\n       /* The cv-qualifiers for the function.  */\n       cp_cv_quals qualifiers;\n       /* The exception-specification for the function.  */"}, {"sha": "3348d28425c1253f07fd7580a0c0631b8e7388d1", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 45, "deletions": 36, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -54,7 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"pointer-set.h\"\n \n-static tree grokparms (cp_parameter_declarator *, tree *);\n+static tree grokparms (tree parmlist, tree *);\n static const char *redeclaration_error_message (tree, tree);\n \n static int decl_jump_unsafe (tree);\n@@ -236,13 +236,7 @@ VEC(tree, gc) *deferred_mark_used_calls;\n    with __attribute__((deprecated)).  An object declared as\n    __attribute__((deprecated)) suppresses warnings of uses of other\n    deprecated items.  */\n-\n-enum deprecated_states {\n-  DEPRECATED_NORMAL,\n-  DEPRECATED_SUPPRESS\n-};\n-\n-static enum deprecated_states deprecated_state = DEPRECATED_NORMAL;\n+enum deprecated_states deprecated_state = DEPRECATED_NORMAL;\n \n \f\n /* A TREE_LIST of VAR_DECLs.  The TREE_PURPOSE is a RECORD_TYPE or\n@@ -9494,6 +9488,32 @@ check_default_argument (tree decl, tree arg)\n   return arg;\n }\n \n+/* Returns a deprecated type used within TYPE, or NULL_TREE if none.  */\n+\n+static tree\n+type_is_deprecated (tree type)\n+{\n+  enum tree_code code;\n+  if (TREE_DEPRECATED (type))\n+    return type;\n+  if (TYPE_NAME (type)\n+      && TREE_DEPRECATED (TYPE_NAME (type)))\n+    return type;\n+\n+  code = TREE_CODE (type);\n+\n+  if (code == POINTER_TYPE || code == REFERENCE_TYPE\n+      || code == OFFSET_TYPE || code == FUNCTION_TYPE\n+      || code == METHOD_TYPE || code == ARRAY_TYPE)\n+    return type_is_deprecated (TREE_TYPE (type));\n+\n+  if (TYPE_PTRMEMFUNC_P (type))\n+    return type_is_deprecated\n+      (TREE_TYPE (TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (type))));\n+\n+  return NULL_TREE;\n+}\n+\n /* Decode the list of parameter types for a function type.\n    Given the list of things declared inside the parens,\n    return a list of types.\n@@ -9504,41 +9524,31 @@ check_default_argument (tree decl, tree arg)\n    *PARMS is set to the chain of PARM_DECLs created.  */\n \n static tree\n-grokparms (cp_parameter_declarator *first_parm, tree *parms)\n+grokparms (tree parmlist, tree *parms)\n {\n   tree result = NULL_TREE;\n   tree decls = NULL_TREE;\n-  int ellipsis = !first_parm || first_parm->ellipsis_p;\n-  cp_parameter_declarator *parm;\n+  tree parm;\n   int any_error = 0;\n-  struct pointer_set_t *unique_decls = pointer_set_create ();\n \n-  for (parm = first_parm; parm != NULL; parm = parm->next)\n+  for (parm = parmlist; parm != NULL_TREE; parm = TREE_CHAIN (parm))\n     {\n       tree type = NULL_TREE;\n-      tree init = parm->default_argument;\n-      tree attrs;\n-      tree decl;\n+      tree init = TREE_PURPOSE (parm);\n+      tree decl = TREE_VALUE (parm);\n \n-      if (parm == no_parameters)\n+      if (parm == void_list_node)\n \tbreak;\n \n-      attrs = parm->decl_specifiers.attributes;\n-      parm->decl_specifiers.attributes = NULL_TREE;\n-      decl = grokdeclarator (parm->declarator, &parm->decl_specifiers,\n-\t\t\t     PARM, init != NULL_TREE, &attrs);\n       if (! decl || TREE_TYPE (decl) == error_mark_node)\n \tcontinue;\n \n-      if (attrs)\n-\tcplus_decl_attributes (&decl, attrs, 0);\n-\n       type = TREE_TYPE (decl);\n       if (VOID_TYPE_P (type))\n \t{\n \t  if (same_type_p (type, void_type_node)\n \t      && DECL_SELF_REFERENCE_P (type)\n-\t      && !DECL_NAME (decl) && !result && !parm->next && !ellipsis)\n+\t      && !DECL_NAME (decl) && !result && TREE_CHAIN (parm) == void_list_node)\n \t    /* this is a parmlist of `(void)', which is ok.  */\n \t    break;\n \t  cxx_incomplete_type_error (decl, type);\n@@ -9561,6 +9571,13 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \n       if (type != error_mark_node)\n \t{\n+\t  if (deprecated_state != DEPRECATED_SUPPRESS)\n+\t    {\n+\t      tree deptype = type_is_deprecated (type);\n+\t      if (deptype)\n+\t\twarn_deprecated_use (deptype);\n+\t    }\n+\n \t  /* Top-level qualifiers on the parameters are\n \t     ignored for function types.  */\n \t  type = cp_build_qualified_type (type, 0);\n@@ -9603,28 +9620,20 @@ grokparms (cp_parameter_declarator *first_parm, tree *parms)\n \n       if (TREE_CODE (decl) == PARM_DECL\n           && FUNCTION_PARAMETER_PACK_P (decl)\n-          && parm->next)\n+          && TREE_CHAIN (parm)\n+          && TREE_CHAIN (parm) != void_list_node)\n         error (\"parameter packs must be at the end of the parameter list\");\n \n-      if (DECL_NAME (decl))\n-        {\n-          if (pointer_set_contains (unique_decls, DECL_NAME (decl)))\n-            error (\"multiple parameters named %qE\", DECL_NAME (decl));\n-          else\n-            pointer_set_insert (unique_decls, DECL_NAME (decl));\n-        }\n-\n       TREE_CHAIN (decl) = decls;\n       decls = decl;\n       result = tree_cons (init, type, result);\n     }\n   decls = nreverse (decls);\n   result = nreverse (result);\n-  if (!ellipsis)\n+  if (parm)\n     result = chainon (result, void_list_node);\n   *parms = decls;\n \n-  pointer_set_destroy (unique_decls);\n   return result;\n }\n "}, {"sha": "ed287149d87e55fb317a17981bc887f250eb8bdc", "filename": "gcc/cp/decl.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fdecl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fdecl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.h?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -34,3 +34,16 @@ enum decl_context\n extern tree grokdeclarator (const cp_declarator *,\n \t\t\t    const cp_decl_specifier_seq *,\n \t\t\t    enum decl_context, int, tree*);\n+\n+/* States indicating how grokdeclarator() should handle declspecs marked\n+   with __attribute__((deprecated)).  An object declared as\n+   __attribute__((deprecated)) suppresses warnings of uses of other\n+   deprecated items.  */\n+\n+enum deprecated_states {\n+  DEPRECATED_NORMAL,\n+  DEPRECATED_SUPPRESS\n+};\n+\n+extern enum deprecated_states deprecated_state;\n+"}, {"sha": "7b4c30344cce5e4ad1c69f3b8e086a712a105c52", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -2016,7 +2016,8 @@ write_template_args (tree args)\n    <expr-primary> ::= <template-param>\n \t\t  ::= L <type> <value number> E\t\t# literal\n \t\t  ::= L <mangled-name> E\t\t# external name\n-\t\t  ::= sr <type> <unqualified-name>\n+\t\t  ::= st <type>\t\t\t\t# sizeof\n+\t\t  ::= sr <type> <unqualified-name>\t# dependent name\n \t\t  ::= sr <type> <unqualified-name> <template-args> */\n \n static void\n@@ -2042,6 +2043,12 @@ write_expression (tree expr)\n       code = TREE_CODE (expr);\n     }\n \n+  if (code == OVERLOAD)\n+    {\n+      expr = OVL_FUNCTION (expr);\n+      code = TREE_CODE (expr);\n+    }\n+\n   /* Handle pointers-to-members by making them look like expression\n      nodes.  */\n   if (code == PTRMEM_CST)\n@@ -2064,6 +2071,13 @@ write_expression (tree expr)\n   else if (TREE_CODE_CLASS (code) == tcc_constant\n \t   || (abi_version_at_least (2) && code == CONST_DECL))\n     write_template_arg_literal (expr);\n+  else if (code == PARM_DECL)\n+    {\n+      /* A function parameter used under decltype in a late-specified\n+\t return type.  Represented with a type placeholder.  */\n+      write_string (\"sT\");\n+      write_type (non_reference (TREE_TYPE (expr)));\n+    }\n   else if (DECL_P (expr))\n     {\n       /* G++ 3.2 incorrectly mangled non-type template arguments of\n@@ -2175,16 +2189,17 @@ write_expression (tree expr)\n       switch (code)\n \t{\n \tcase CALL_EXPR:\n-\t  sorry (\"call_expr cannot be mangled due to a defect in the C++ ABI\");\n+\t  write_expression (CALL_EXPR_FN (expr));\n+\t  for (i = 0; i < call_expr_nargs (expr); ++i)\n+\t    write_expression (CALL_EXPR_ARG (expr, i));\n+\t  write_char ('E');\n \t  break;\n \n \tcase CAST_EXPR:\n \t  write_type (TREE_TYPE (expr));\n-\t  /* There is no way to mangle a zero-operand cast like\n-\t     \"T()\".  */\n \t  if (!TREE_OPERAND (expr, 0))\n-\t    sorry (\"zero-operand casts cannot be mangled due to a defect \"\n-\t\t   \"in the C++ ABI\");\n+\t  /* \"T()\" is mangled as \"T(void)\".  */\n+\t    write_char ('v');\n \t  else\n \t    write_expression (TREE_VALUE (TREE_OPERAND (expr, 0)));\n \t  break;\n@@ -2195,7 +2210,6 @@ write_expression (tree expr)\n \t  write_expression (TREE_OPERAND (expr, 0));\n \t  break;\n \n-\n \t/* Handle pointers-to-members specially.  */\n \tcase SCOPE_REF:\n \t  write_type (TREE_OPERAND (expr, 0));"}, {"sha": "743f02365ee91542d8d82dd02eee88f954f7facb", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -604,6 +604,13 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t     scope of the current namespace, not the current\n \t     function.  */\n \t  && !(TREE_CODE (x) == VAR_DECL && DECL_EXTERNAL (x))\n+\t  /* When parsing the parameter list of a function declarator,\n+\t     don't set DECL_CONTEXT to an enclosing function.  When we\n+\t     push the PARM_DECLs in order to process the function body,\n+\t     current_binding_level->this_entity will be set.  */\n+\t  && !(TREE_CODE (x) == PARM_DECL\n+\t       && current_binding_level->kind == sk_function_parms\n+\t       && current_binding_level->this_entity == NULL)\n \t  && !DECL_CONTEXT (x))\n \tDECL_CONTEXT (x) = current_function_decl;\n \n@@ -712,8 +719,6 @@ pushdecl_maybe_friend (tree x, bool is_friend)\n \t    }\n \t  else if (TREE_CODE (t) == PARM_DECL)\n \t    {\n-\t      gcc_assert (DECL_CONTEXT (t));\n-\n \t      /* Check for duplicate params.  */\n \t      if (duplicate_decls (x, t, is_friend))\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n@@ -4987,6 +4992,8 @@ pushtag (tree name, tree type, tag_scope scope)\n   while (/* Cleanup scopes are not scopes from the point of view of\n \t    the language.  */\n \t b->kind == sk_cleanup\n+\t /* Neither are function parameter scopes.  */\n+\t || b->kind == sk_function_parms\n \t /* Neither are the scopes used to hold template parameters\n \t    for an explicit specialization.  For an ordinary template\n \t    declaration, these scopes are not scopes from the point of"}, {"sha": "88f92e7ccc469a0d1efb00531adf7f251b7865eb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 57, "deletions": 23, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -853,7 +853,7 @@ clear_decl_specs (cp_decl_specifier_seq *decl_specs)\n    VAR_DECLs or FUNCTION_DECLs) should do that directly.  */\n \n static cp_declarator *make_call_declarator\n-  (cp_declarator *, cp_parameter_declarator *, cp_cv_quals, tree, tree);\n+  (cp_declarator *, tree, cp_cv_quals, tree, tree);\n static cp_declarator *make_array_declarator\n   (cp_declarator *, tree);\n static cp_declarator *make_pointer_declarator\n@@ -1013,7 +1013,7 @@ make_ptrmem_declarator (cp_cv_quals cv_qualifiers, tree class_type,\n \n cp_declarator *\n make_call_declarator (cp_declarator *target,\n-\t\t      cp_parameter_declarator *parms,\n+\t\t      tree parms,\n \t\t      cp_cv_quals cv_qualifiers,\n \t\t      tree exception_specification,\n \t\t      tree late_return_type)\n@@ -1736,9 +1736,9 @@ static tree cp_parser_type_id\n   (cp_parser *);\n static void cp_parser_type_specifier_seq\n   (cp_parser *, bool, cp_decl_specifier_seq *);\n-static cp_parameter_declarator *cp_parser_parameter_declaration_clause\n+static tree cp_parser_parameter_declaration_clause\n   (cp_parser *);\n-static cp_parameter_declarator *cp_parser_parameter_declaration_list\n+static tree cp_parser_parameter_declaration_list\n   (cp_parser *, bool *);\n static cp_parameter_declarator *cp_parser_parameter_declaration\n   (cp_parser *, bool, bool *);\n@@ -12986,8 +12986,10 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t  if (!first || dcl_kind != CP_PARSER_DECLARATOR_NAMED)\n \t    {\n-\t      cp_parameter_declarator *params;\n+\t      tree params;\n \t      unsigned saved_num_template_parameter_lists;\n+\t      bool is_declarator = false;\n+\t      tree t;\n \n \t      /* In a member-declarator, the only valid interpretation\n \t\t of a parenthesis is the start of a\n@@ -13014,6 +13016,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t= parser->num_template_parameter_lists;\n \t      parser->num_template_parameter_lists = 0;\n \n+\t      begin_scope (sk_function_parms, NULL_TREE);\n+\n \t      /* Parse the parameter-declaration-clause.  */\n \t      params = cp_parser_parameter_declaration_clause (parser);\n \n@@ -13028,6 +13032,8 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t  tree exception_specification;\n \t\t  tree late_return;\n \n+\t\t  is_declarator = true;\n+\n \t\t  if (ctor_dtor_or_conv_p)\n \t\t    *ctor_dtor_or_conv_p = *ctor_dtor_or_conv_p < 0;\n \t\t  first = false;\n@@ -13053,10 +13059,16 @@ cp_parser_direct_declarator (cp_parser* parser,\n \t\t     return type, so are not those of the declared\n \t\t     function.  */\n \t\t  parser->default_arg_ok_p = false;\n-\n-\t\t  /* Repeat the main loop.  */\n-\t\t  continue;\n \t\t}\n+\n+\t      /* Remove the function parms from scope.  */\n+\t      for (t = current_binding_level->names; t; t = TREE_CHAIN (t))\n+\t\tpop_binding (DECL_NAME (t), t);\n+\t      leave_scope();\n+\n+\t      if (is_declarator)\n+\t\t/* Repeat the main loop.  */\n+\t\tcontinue;\n \t    }\n \n \t  /* If this is the first, we can try a parenthesized\n@@ -13728,10 +13740,10 @@ cp_parser_type_specifier_seq (cp_parser* parser,\n    value of NULL indicates a parameter-declaration-clause consisting\n    only of an ellipsis.  */\n \n-static cp_parameter_declarator *\n+static tree\n cp_parser_parameter_declaration_clause (cp_parser* parser)\n {\n-  cp_parameter_declarator *parameters;\n+  tree parameters;\n   cp_token *token;\n   bool ellipsis_p;\n   bool is_error;\n@@ -13743,18 +13755,18 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n     {\n       /* Consume the `...' token.  */\n       cp_lexer_consume_token (parser->lexer);\n-      return NULL;\n+      return NULL_TREE;\n     }\n   else if (token->type == CPP_CLOSE_PAREN)\n     /* There are no parameters.  */\n     {\n #ifndef NO_IMPLICIT_EXTERN_C\n       if (in_system_header && current_class_type == NULL\n \t  && current_lang_name == lang_name_c)\n-\treturn NULL;\n+\treturn NULL_TREE;\n       else\n #endif\n-\treturn no_parameters;\n+\treturn void_list_node;\n     }\n   /* Check for `(void)', too, which is a special case.  */\n   else if (token->keyword == RID_VOID\n@@ -13764,7 +13776,7 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n       /* Consume the `void' token.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* There are no parameters.  */\n-      return no_parameters;\n+      return void_list_node;\n     }\n \n   /* Parse the parameter-declaration-list.  */\n@@ -13799,8 +13811,8 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n     ellipsis_p = false;\n \n   /* Finish the parameter list.  */\n-  if (parameters && ellipsis_p)\n-    parameters->ellipsis_p = true;\n+  if (!ellipsis_p)\n+    parameters = chainon (parameters, void_list_node);\n \n   return parameters;\n }\n@@ -13816,11 +13828,11 @@ cp_parser_parameter_declaration_clause (cp_parser* parser)\n    `void_list_node' is never appended to the list.  Upon return,\n    *IS_ERROR will be true iff an error occurred.  */\n \n-static cp_parameter_declarator *\n+static tree\n cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n {\n-  cp_parameter_declarator *parameters = NULL;\n-  cp_parameter_declarator **tail = &parameters;\n+  tree parameters = NULL_TREE;\n+  tree *tail = &parameters; \n   bool saved_in_unbraced_linkage_specification_p;\n \n   /* Assume all will go well.  */\n@@ -13836,24 +13848,46 @@ cp_parser_parameter_declaration_list (cp_parser* parser, bool *is_error)\n   while (true)\n     {\n       cp_parameter_declarator *parameter;\n+      tree decl = error_mark_node;\n       bool parenthesized_p;\n       /* Parse the parameter.  */\n       parameter\n \t= cp_parser_parameter_declaration (parser,\n \t\t\t\t\t   /*template_parm_p=*/false,\n \t\t\t\t\t   &parenthesized_p);\n \n+      /* We don't know yet if the enclosing context is deprecated, so wait\n+\t and warn in grokparms if appropriate.  */\n+      deprecated_state = DEPRECATED_SUPPRESS;\n+\n+      if (parameter)\n+\tdecl = grokdeclarator (parameter->declarator,\n+\t\t\t       &parameter->decl_specifiers,\n+\t\t\t       PARM,\n+\t\t\t       parameter->default_argument != NULL_TREE,\n+\t\t\t       &parameter->decl_specifiers.attributes);\n+\n+      deprecated_state = DEPRECATED_NORMAL;\n+\n       /* If a parse error occurred parsing the parameter declaration,\n \t then the entire parameter-declaration-list is erroneous.  */\n-      if (!parameter)\n+      if (decl == error_mark_node)\n \t{\n \t  *is_error = true;\n-\t  parameters = NULL;\n+\t  parameters = error_mark_node;\n \t  break;\n \t}\n+\n+      if (parameter->decl_specifiers.attributes)\n+\tcplus_decl_attributes (&decl,\n+\t\t\t       parameter->decl_specifiers.attributes,\n+\t\t\t       0);\n+      if (DECL_NAME (decl))\n+\tdecl = pushdecl (decl);\n+\n       /* Add the new parameter to the list.  */\n-      *tail = parameter;\n-      tail = &parameter->next;\n+      *tail = build_tree_list (parameter->default_argument, decl);\n+      tail = &TREE_CHAIN (*tail);\n \n       /* Peek at the next token.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_CLOSE_PAREN)"}, {"sha": "4aa7b1ad146c28de4d6a707064ce9cbd299eff4e", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -9556,11 +9556,16 @@ tsubst (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       {\n \ttree type;\n \n-\ttype = \n-          finish_decltype_type (tsubst_expr \n-                                (DECLTYPE_TYPE_EXPR (t), args,\n-                                 complain, in_decl,\n-                                 /*integral_constant_expression_p=*/false),\n+\t++skip_evaluation;\n+\n+\ttype = tsubst_expr (DECLTYPE_TYPE_EXPR (t), args,\n+\t\t\t    complain, in_decl,\n+\t\t\t    /*integral_constant_expression_p=*/false);\n+\n+\t--skip_evaluation;\n+\n+\ttype =\n+          finish_decltype_type (type,\n                                 DECLTYPE_TYPE_ID_EXPR_OR_MEMBER_ACCESS_P (t));\n \treturn cp_build_qualified_type_real (type,\n \t\t\t\t\t     cp_type_quals (t)\n@@ -9796,7 +9801,22 @@ tsubst_copy (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     {\n     case PARM_DECL:\n       r = retrieve_local_specialization (t);\n-      gcc_assert (r != NULL);\n+\n+      if (r == NULL)\n+\t{\n+\t  /* This can happen for a parameter name used later in a function\n+\t     declaration (such as in a late-specified return type).\n+\t     Replace it with an arbitrary expression with the same type\n+\t     (*(T*)0).  This should only occur in an unevaluated context\n+\t     (i.e. decltype).  */\n+\t  gcc_assert (skip_evaluation && DECL_CONTEXT (t) == NULL_TREE);\n+\t  r = non_reference (TREE_TYPE (t));\n+\t  r = tsubst (r, args, complain, in_decl);\n+\t  r = build_pointer_type (r);\n+\t  r = build_c_cast (r, null_node);\n+\t  return cp_build_indirect_ref (r, NULL, tf_warning_or_error);\n+\t}\n+      \n       if (TREE_CODE (r) == ARGUMENT_PACK_SELECT)\n \tr = ARGUMENT_PACK_SELECT_ARG (r);\n       mark_used (r);"}, {"sha": "626e9e245d4862ac6de64c5d8eb1975bb27c83f3", "filename": "gcc/testsuite/g++.dg/cpp0x/auto2.C", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto2.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -69,4 +69,6 @@ int main()\n     case 42:\n       break;\n     }\n+\n+  auto j = 42, k = 24;\n }"}, {"sha": "769d987c9610de11b417193e786f70cb6bc11ad3", "filename": "gcc/testsuite/g++.dg/cpp0x/auto3.C", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto3.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -5,6 +5,10 @@\n \n auto x;\t\t\t\t// { dg-error \"auto\" }\n \n+// If the type deduced for the template parameter U is not the same in each\n+// deduction, the program is ill-formed.\n+auto i = 42, j = 42.0;\t\t// { dg-error \"\" \"\" { xfail *-*-* } }\n+\n // New CWG issue\n auto a[2] = { 1, 2 };\t\t// { dg-error \"auto\" }\n "}, {"sha": "a574f54758f7efe2d4e58eafef56bfa2e066e69b", "filename": "gcc/testsuite/g++.dg/cpp0x/auto6.C", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fauto6.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -6,4 +6,20 @@ auto f() -> int\n }\n \n template<class T, class U>\n-auto add(T t, U u) -> decltype (t+u); // { dg-bogus \"not declared\" \"\" { xfail *-*-* } }\n+auto add(T t, U u) -> decltype (t+u);\n+\n+template<class T, class U>\n+decltype(T()+U()) add2(T t, U u);\n+\n+template <class T, class U>\n+U g (T, U);\n+\n+template<class T, class U>\n+auto add3(T t, U u) -> decltype (g(t,u));\n+\n+int main()\n+{\n+  auto i = add(1, 2.0);\n+  auto i2 = add2(1, 2.0);\n+  auto i3 = add3(1, 2.0);\n+}"}, {"sha": "3601852322a41c143725950137da67edbac9d4b2", "filename": "gcc/testsuite/g++.dg/other/error15.C", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror15.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -3,58 +3,54 @@\n extern void g0 (int a, int b);\n extern void g1 (int a, float b);\n \n-extern void f0 (int a,\n-                int a);  // { dg-error \"multiple parameters named 'a'\" }\n-extern void f1 (int a,\n-                float a);  // { dg-error \"multiple parameters named 'a'\" }\n-extern void f3 (int a, int b, int c,\n-                int a);  // { dg-error \"multiple parameters named 'a'\" }\n-extern void f4 (int a, int b, int c,\n-                int a,\n-                int a);  // { dg-error \"multiple parameters named 'a'\" }\n-extern void f5 (int a, int b, int c, int d, int e, int f, int g, int h,\n-                int a,\n+extern void f0 (int a,\t\t// { dg-error \"previous\" }\n+                int a);\t\t// { dg-error \"redefinition\" }\n+extern void f1 (int a,\t\t// { dg-error \"previous\" }\n+                float a);\t// { dg-error \"conflicting\" }\n+extern void f3 (int a, int b, int c, // { dg-error \"previous\" }\n+                int a);\t\t// { dg-error \"redefinition\" }\n+extern void f4 (int a, int b, int c, // { dg-error \"previous\" }\n+                int a,\t\t     // { dg-error \"redefinition\" }\n+                int a);\t\t     // { dg-error \"redefinition\" }\n+extern void f5 (int a, int b, int c, int d, int e, int f, int g, int h, // { dg-error \"previous\" }\n+                int a,\t\t\t\t\t\t\t// { dg-error \"redefinition\" }\n                 int i, int j, int k, int l, int m, int n, int o, int p,\n                 int q, int r, int s, int t, int u, int v, int w, int x, int y,\n-                int z);  // { dg-error \"multiple parameters named 'a'\" }\n+                int z);\n \n-extern void f6 (int a, int, int, int, int, int, int, int, int, int, int,\n-                int a,\n+extern void f6 (int a, int, int, int, int, int, int, int, int, int, int, // { dg-error \"previous\" }\n+                int a,\t\t// { dg-error \"redefinition\" }\n                 int, int, int, int, int, int, int, int, int, int, int,\n                 float, float, float, float, float, float, float, float,\n-                int);  // { dg-error \"multiple parameters named 'a'\" }\n-\n-extern void f7 (void (*a)(int),\n-                void (*a)(int));  // { dg-error \"multiple parameters named 'a'\" }\n-extern void f8 (float (*a)(int),\n-                int (*a)(float));  // { dg-error \"multiple parameters named 'a'\" }\n-\n-extern void f9 (int a,\n-                int a,\n-                int a);\n-// { dg-error \"multiple parameters named 'a'\" \"\" { target *-*-* } 34 }\n-\n-extern void f10 (int a,\n-                 int b,\n-                 int c,\n-                 int c,\n-                 int b,\n-                 int a);\n-// { dg-error \"multiple parameters named 'a'\" \"\" { target *-*-* } 42 }\n-// { dg-error \"multiple parameters named 'b'\" \"\" { target *-*-* } 42 }\n-// { dg-error \"multiple parameters named 'c'\" \"\" { target *-*-* } 42 }\n+                int);\n+\n+extern void f7 (void (*a)(int),\t  // { dg-error \"previous\" }\n+                void (*a)(int));  // { dg-error \"redefinition\" }\n+extern void f8 (float (*a)(int),  // { dg-error \"previous\" }\n+                int (*a)(float));  // { dg-error \"conflicting\" }\n+\n+extern void f9 (int a,\t\t// { dg-error \"previous\" }\n+                int a,\t\t// { dg-error \"redefinition\" }\n+                int a);\t\t// { dg-error \"redefinition\" }\n+\n+extern void f10 (int a,\t\t// { dg-error \"previous\" }\n+                 int b,\t\t// { dg-error \"previous\" }\n+                 int c,\t\t// { dg-error \"previous\" }\n+                 int c,\t\t// { dg-error \"redefinition\" }\n+                 int b,\t\t// { dg-error \"redefinition\" }\n+                 int a);\t// { dg-error \"redefinition\" }\n \n class C1 {\n  public:\n   void C1_g0 (int a, int b);\n-  void C1_f0 (int a,\n-              int a);  // { dg-error \"multiple parameters named 'a'\" }\n+  void C1_f0 (int a,\t\t// { dg-error \"previous\" }\n+              int a);\t\t// { dg-error \"redefinition\" }\n };\n \n template <class T>\n class C2 {\n  public:\n   void C2_g0 (T a, T b);\n-  void C2_f0 (T a,\n-              T a);  // { dg-error \"multiple parameters named 'a'\" }\n+  void C2_f0 (T a,\t\t// { dg-error \"previous\" }\n+              T a);\t\t// { dg-error \"redefinition\" }\n };"}, {"sha": "21180d765ab1bf4cc890b42df29e452e0b43cb22", "filename": "gcc/testsuite/g++.dg/other/error6.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Ferror6.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -1,6 +1,7 @@\n // { dg-do compile }\n // Make sure we emit a decent error message when trying to mangle an\n //  expression not supported by the C++ ABI due to a defect.\n+// Update: Better to make it supported, I think...\n \n template <int N>\n struct A {};\n@@ -15,5 +16,5 @@ A<sizeof(T::foo())> func(void);\n \n int main()\n {\n-  func<B>();  // { dg-error \"sorry, unimplemented\" }\n+  func<B>();\n }"}, {"sha": "e370f717c3a9e08b7ef80b22f272442cfffe4475", "filename": "gcc/testsuite/g++.dg/other/pr28114.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28114.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28114.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fother%2Fpr28114.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -5,5 +5,5 @@ template<int> void foo(struct {}*); // { dg-error \"\" }\n \n void bar()\n {\n-  foo<0>(0);\n+  foo<0>(0);\t\t\t// { dg-error \"\" }\n }"}, {"sha": "2856850fb76bb3545836c260313264257a9b087e", "filename": "gcc/testsuite/g++.dg/parse/error3.C", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Ferror3.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -6,14 +6,4 @@ static void InstantiateConstraint(const float&, unsigned,\n                                                      char*, char*,\n                                                      unsigned*));\n // { dg-error \"64: error: expected ',' or '...' before '&' token\" \"\" { target *-*-* }  { 5 } }\n-\n-/// in the coming test, the column information is broken as it points to\n-//  the end of the declaration instead of pointing to the begining of the\n-//  'TYPE' identifier. This is due to the warning being generated by the\n-//  declaration groking code (gcc/cp/decl.c) and not the parser. So in that\n-//  code, the exact token location information is lost as the declaration\n-//  groking code manipulates TREEs only. The token location used is then\n-//  the global one that is not accurate enough. Anyway, let's say it is\n-//  good enough for now, until we find a way to propagate token location to\n-//  code paths that manipulate TREEs only.\n-// { dg-error \"64: error: ISO C\\\\+\\\\+ forbids declaration of 'TYPE' with no type\" \"\" { target *-*-* } { 7 } }\n+// { dg-error \"60: error: ISO C\\\\+\\\\+ forbids declaration of 'TYPE' with no type\" \"\" { target *-*-* } { 5 } }"}, {"sha": "d42516d4fcfe826f86b773b3ab3a07e41e00e956", "filename": "gcc/testsuite/g++.old-deja/g++.jason/rfg16.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg16.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg16.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Frfg16.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -1,5 +1,5 @@\n // { dg-do assemble  }\n // Bug: g++ doesn't push parameter decls as they are parsed.\n \n-void (*ptr) (int foo, int array[sizeof(foo)]); // { dg-bogus \"\" \"\" { xfail *-*-* } }  \n-void test2 (int bar, int array[sizeof(bar)]) { } // { dg-bogus \"\" \"\" { xfail *-*-* } }  \n+void (*ptr) (int foo, int array[sizeof(foo)]);\n+void test2 (int bar, int array[sizeof(bar)]) { }"}, {"sha": "8ac05146866c864305c94f936fd7f5d612e6faae", "filename": "gcc/testsuite/g++.old-deja/g++.oliva/template1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.oliva%2Ftemplate1.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -11,5 +11,5 @@ template<int P = 0> struct foo {\n };\n \n void bar() {\n-  foo<>::bar(0); // { dg-error \"\" \"\" } instantiated from here\n+  foo<>::bar(0);\n }"}, {"sha": "808f233c648230d32c26f67673dab52351db1b4c", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp29.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b344d949d25164341ca4532ce067af1b254198a0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp29.C?ref=b344d949d25164341ca4532ce067af1b254198a0", "patch": "@@ -9,7 +9,7 @@ struct S\n   void f(U u);\n \n   template <class U>\n-  void g(U U);\n+  void g(U u);\n \n   int c[16];\n };"}]}