{"sha": "3c85c1188579bee9c6f8b8f5223daf49b772e594", "node_id": "C_kwDOANBUbNoAKDNjODVjMTE4ODU3OWJlZTljNmY4YjhmNTIyM2RhZjQ5Yjc3MmU1OTQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T06:11:54Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-09-14T15:06:48Z"}, "message": "frange: add both zeros to ranges when there's the possiblity of equality.\n\nEvery time there's equality at play, we must be careful that any\nequality with zero matches both -0.0 and +0.0 when honoring signed\nzeros.\n\nWe were doing this correctly for the == and != op1_range operators\n(albeit inefficiently), but aren't doing it at all when building >=\nand <=.  This fixes the oversight.\n\nThere is change in functionality here for the build_* functions.\n\nThis is the last \"simple\" patch I submit before overhauling NAN and\nsign tracking.  And that will likely be after Cauldron because it will need\nfurther testing (lapack, ppc64le, -ffinite-math-only, etc).\n\nRegstrapped on x86-64 Linux, plus I ran selftests for\n-ffinite-math-only.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (frange_add_zeros): New.\n\t(build_le): Call frange_add_zeros.\n\t(build_ge): Same.\n\t(foperator_equal::op1_range): Same.\n\t(foperator_not_equal::op1_range): Same.", "tree": {"sha": "0cda786460b00bb38e4e4591624152889059cdb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cda786460b00bb38e4e4591624152889059cdb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c85c1188579bee9c6f8b8f5223daf49b772e594", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c85c1188579bee9c6f8b8f5223daf49b772e594", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c85c1188579bee9c6f8b8f5223daf49b772e594", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c85c1188579bee9c6f8b8f5223daf49b772e594/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d647a8d49d49dfbb82061e6c66a19c142331169", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d647a8d49d49dfbb82061e6c66a19c142331169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d647a8d49d49dfbb82061e6c66a19c142331169"}], "stats": {"total": 31, "additions": 25, "deletions": 6}, "files": [{"sha": "fbc14a730adeec4833946e27180f4a8610ba0111", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c85c1188579bee9c6f8b8f5223daf49b772e594/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c85c1188579bee9c6f8b8f5223daf49b772e594/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=3c85c1188579bee9c6f8b8f5223daf49b772e594", "patch": "@@ -208,6 +208,19 @@ frange_drop_ninf (frange &r, tree type)\n   r.intersect (tmp);\n }\n \n+// If zero is in R, make sure both -0.0 and +0.0 are in the range.\n+\n+static inline void\n+frange_add_zeros (frange &r, tree type)\n+{\n+  if (r.undefined_p () || r.known_nan ())\n+    return;\n+\n+  if (HONOR_SIGNED_ZEROS (type)\n+      && (real_iszero (&r.lower_bound ()) || real_iszero (&r.upper_bound ())))\n+    r.set_signbit (fp_prop::VARYING);\n+}\n+\n // Build a range that is <= VAL and store it in R.\n \n static bool\n@@ -219,6 +232,10 @@ build_le (frange &r, tree type, const frange &val)\n       return false;\n     }\n   r.set (type, dconstninf, val.upper_bound ());\n+\n+  // Add both zeros if there's the possibility of zero equality.\n+  frange_add_zeros (r, type);\n+\n   return true;\n }\n \n@@ -257,6 +274,10 @@ build_ge (frange &r, tree type, const frange &val)\n       return false;\n     }\n   r.set (type, val.lower_bound (), dconstinf);\n+\n+  // Add both zeros if there's the possibility of zero equality.\n+  frange_add_zeros (r, type);\n+\n   return true;\n }\n \n@@ -376,9 +397,8 @@ foperator_equal::op1_range (frange &r, tree type,\n     case BRS_TRUE:\n       // If it's true, the result is the same as OP2.\n       r = op2;\n-      // Make sure we don't copy the sign bit if we may have a zero.\n-      if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n-\tr.set_signbit (fp_prop::VARYING);\n+      // Add both zeros if there's the possibility of zero equality.\n+      frange_add_zeros (r, type);\n       // The TRUE side of op1 == op2 implies op1 is !NAN.\n       r.clear_nan ();\n       break;\n@@ -480,9 +500,8 @@ foperator_not_equal::op1_range (frange &r, tree type,\n     case BRS_FALSE:\n       // If it's false, the result is the same as OP2.\n       r = op2;\n-      // Make sure we don't copy the sign bit if we may have a zero.\n-      if (HONOR_SIGNED_ZEROS (type) && r.contains_p (build_zero_cst (type)))\n-\tr.set_signbit (fp_prop::VARYING);\n+      // Add both zeros if there's the possibility of zero equality.\n+      frange_add_zeros (r, type);\n       // The FALSE side of op1 != op2 implies op1 is !NAN.\n       r.clear_nan ();\n       break;"}]}