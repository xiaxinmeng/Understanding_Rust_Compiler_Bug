{"sha": "825da0d20f71cd82fa58e16e92099879e9a8b8f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI1ZGEwZDIwZjcxY2Q4MmZhNThlMTZlOTIwOTk4NzllOWE4YjhmMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-01-20T09:01:34Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-01-20T09:01:34Z"}, "message": "exp_ch2.adb (Expand_Current_Value): Make an appropriate character literal if the entity is of a character type.\n\n\t* exp_ch2.adb (Expand_Current_Value): Make an appropriate character\n\tliteral if the entity is of a character type.\n\t* gcc-interface/lang.opt (fsigned-char): New option.\n\t* gcc-interface/misc.c (gnat_handle_option): Accept it.\n\t(gnat_init): Adjust comment.\n\t* gcc-interface/gigi.h (finish_character_type): New prototype.\n\t(maybe_character_type): New inline function.\n\t(maybe_character_value): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Enumeration_Type>: For\n\ta character of CHAR_TYPE_SIZE, make a signed type if flag_signed_char.\n\tSet TYPE_ARTIFICIAL early and call finish_character_type on the type.\n\t<E_Enumeration_Subtype>: For a subtype of character with RM_Size and\n\tEsize equal to CHAR_TYPE_SIZE, make a signed type if flag_signed_char.\n\tCopy TYPE_STRING_FLAG from type to subtype.\n\t<E_Array_Type>: Deal with character index types.\n\t<E_Array_Subtype>: Likewise.\n\t* gcc-interface/trans.c (gigi): Replace unsigned_char_type_node with\n\tchar_type_node throughout.\n\t(build_raise_check): Likewise.\n\t(get_type_length): Deal with character types.\n\t(Attribute_to_gnu) <Attr_Pos>: Likewise.  Remove obsolete range check\n\tcode.  Minor tweak.\n\t<Attr_Pred>: Likewise.\n\t(Loop_Statement_to_gnu): Likewise.\n\t(Raise_Error_to_gnu): Likewise.\n\t<N_Indexed_Component>: Deal with character index types.  Remove\n\tobsolete code.\n\t<N_Slice>: Likewise.\n\t<N_Type_Conversion>: Deal with character types.  Minor tweak.\n\t<N_Unchecked_Type_Conversion>: Likewise.\n\t<N_In>: Likewise.\n\t<N_Op_Eq>: Likewise.\n\t(emit_index_check): Delete.\n\t* gcc-interface/utils.c (finish_character_type): New function.\n\t(gnat_signed_or_unsigned_type_for): Deal with built-in character types.\n\t* gcc-interface/utils2.c (expand_sloc): Replace unsigned_char_type_node\n\twith char_type_node.\n\t(build_call_raise): Likewise.\n\t(build_call_raise_column): Likewise.\n\t(build_call_raise_range): Likewise.\n\nFrom-SVN: r232604", "tree": {"sha": "31f580aa64b5ca42d70c133e1b634e5d8fb6daeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/31f580aa64b5ca42d70c133e1b634e5d8fb6daeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/825da0d20f71cd82fa58e16e92099879e9a8b8f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825da0d20f71cd82fa58e16e92099879e9a8b8f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825da0d20f71cd82fa58e16e92099879e9a8b8f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825da0d20f71cd82fa58e16e92099879e9a8b8f2/comments", "author": null, "committer": null, "parents": [{"sha": "dd6f2cf98c132d493c9ba7c5602d2ade2efa97f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd6f2cf98c132d493c9ba7c5602d2ade2efa97f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd6f2cf98c132d493c9ba7c5602d2ade2efa97f4"}], "stats": {"total": 430, "additions": 238, "deletions": 192}, "files": [{"sha": "23780deb55796b054d6074246350a371bee8204a", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -1,3 +1,46 @@\n+2016-01-20  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* exp_ch2.adb (Expand_Current_Value): Make an appropriate character\n+\tliteral if the entity is of a character type.\n+\t* gcc-interface/lang.opt (fsigned-char): New option.\n+\t* gcc-interface/misc.c (gnat_handle_option): Accept it.\n+\t(gnat_init): Adjust comment.\n+\t* gcc-interface/gigi.h (finish_character_type): New prototype.\n+\t(maybe_character_type): New inline function.\n+\t(maybe_character_value): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Enumeration_Type>: For\n+\ta character of CHAR_TYPE_SIZE, make a signed type if flag_signed_char.\n+\tSet TYPE_ARTIFICIAL early and call finish_character_type on the type.\n+\t<E_Enumeration_Subtype>: For a subtype of character with RM_Size and\n+\tEsize equal to CHAR_TYPE_SIZE, make a signed type if flag_signed_char.\n+\tCopy TYPE_STRING_FLAG from type to subtype.\n+\t<E_Array_Type>: Deal with character index types.\n+\t<E_Array_Subtype>: Likewise.\n+\t* gcc-interface/trans.c (gigi): Replace unsigned_char_type_node with\n+\tchar_type_node throughout.\n+\t(build_raise_check): Likewise.\n+\t(get_type_length): Deal with character types.\n+\t(Attribute_to_gnu) <Attr_Pos>: Likewise.  Remove obsolete range check\n+\tcode.  Minor tweak.\n+\t<Attr_Pred>: Likewise.\n+\t(Loop_Statement_to_gnu): Likewise.\n+\t(Raise_Error_to_gnu): Likewise.\n+\t<N_Indexed_Component>: Deal with character index types.  Remove\n+\tobsolete code.\n+\t<N_Slice>: Likewise.\n+\t<N_Type_Conversion>: Deal with character types.  Minor tweak.\n+\t<N_Unchecked_Type_Conversion>: Likewise.\n+\t<N_In>: Likewise.\n+\t<N_Op_Eq>: Likewise.\n+\t(emit_index_check): Delete.\n+\t* gcc-interface/utils.c (finish_character_type): New function.\n+\t(gnat_signed_or_unsigned_type_for): Deal with built-in character types.\n+\t* gcc-interface/utils2.c (expand_sloc): Replace unsigned_char_type_node\n+\twith char_type_node.\n+\t(build_call_raise): Likewise.\n+\t(build_call_raise_column): Likewise.\n+\t(build_call_raise_range): Likewise.\n+\n 2016-01-18  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (build_call_raise_column): Adjust prototype."}, {"sha": "88dc82440af84d727d63e11710c0297ffa2a9868", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -193,7 +193,16 @@ package body Exp_Ch2 is\n               Unchecked_Convert_To (T,\n                 New_Occurrence_Of (Entity (Val), Loc)));\n \n-         --  If constant is of an integer type, just make an appropriately\n+         --  If constant is of a character type, just make an appropriate\n+         --  character literal, which will get the proper type.\n+\n+         elsif Is_Character_Type (T) then\n+            Rewrite (N,\n+              Make_Character_Literal (Loc,\n+                Chars => Chars (Val),\n+                Char_Literal_Value => Expr_Rep_Value (Val)));\n+\n+         --  If constant is of an integer type, just make an appropriate\n          --  integer literal, which will get the proper type.\n \n          elsif Is_Integer_Type (T) then"}, {"sha": "74bc95bf8643eee68f0c4b625910732dee940e60", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -1560,16 +1560,24 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n     case E_Enumeration_Type:\n       /* A special case: for the types Character and Wide_Character in\n \t Standard, we do not list all the literals.  So if the literals\n-\t are not specified, make this an unsigned integer type.  */\n+\t are not specified, make this an integer type.  */\n       if (No (First_Literal (gnat_entity)))\n \t{\n-\t  gnu_type = make_unsigned_type (esize);\n+\t  if (esize == CHAR_TYPE_SIZE && flag_signed_char)\n+\t    gnu_type = make_signed_type (CHAR_TYPE_SIZE);\n+\t  else\n+\t    gnu_type = make_unsigned_type (esize);\n \t  TYPE_NAME (gnu_type) = gnu_entity_name;\n \n \t  /* Set TYPE_STRING_FLAG for Character and Wide_Character types.\n \t     This is needed by the DWARF-2 back-end to distinguish between\n \t     unsigned integer types and character types.  */\n \t  TYPE_STRING_FLAG (gnu_type) = 1;\n+\n+\t  /* This flag is needed by the call just below.  */\n+\t  TYPE_ARTIFICIAL (gnu_type) = artificial_p;\n+\n+\t  finish_character_type (gnu_type);\n \t}\n       else\n \t{\n@@ -1765,12 +1773,19 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && Is_Bit_Packed_Array (Original_Array_Type (gnat_entity)))\n \tesize = UI_To_Int (RM_Size (gnat_entity));\n \n-      /* This should be an unsigned type if the base type is unsigned or\n+      /* First subtypes of Character are treated as Character; otherwise\n+\t this should be an unsigned type if the base type is unsigned or\n \t if the lower bound is constant and non-negative or if the type\n \t is biased.  */\n-      if (Is_Unsigned_Type (Etype (gnat_entity))\n-\t  || Is_Unsigned_Type (gnat_entity)\n-\t  || Has_Biased_Representation (gnat_entity))\n+      if (kind == E_Enumeration_Subtype\n+\t  && No (First_Literal (Etype (gnat_entity)))\n+\t  && Esize (gnat_entity) == RM_Size (gnat_entity)\n+\t  && esize == CHAR_TYPE_SIZE\n+\t  && flag_signed_char)\n+\tgnu_type = make_signed_type (CHAR_TYPE_SIZE);\n+      else if (Is_Unsigned_Type (Etype (gnat_entity))\n+\t       || Is_Unsigned_Type (gnat_entity)\n+\t       || Has_Biased_Representation (gnat_entity))\n \tgnu_type = make_unsigned_type (esize);\n       else\n \tgnu_type = make_signed_type (esize);\n@@ -1789,6 +1804,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n       TYPE_BIASED_REPRESENTATION_P (gnu_type)\n \t= Has_Biased_Representation (gnat_entity);\n \n+      /* Set TYPE_STRING_FLAG for Character and Wide_Character subtypes.  */\n+      TYPE_STRING_FLAG (gnu_type) = TYPE_STRING_FLAG (TREE_TYPE (gnu_type));\n+\n       /* Inherit our alias set from what we're a subtype of.  Subtypes\n \t are not different types and a pointer can designate any instance\n \t within a subtype hierarchy.  */\n@@ -2114,7 +2132,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  {\n \t    char field_name[16];\n \t    tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t    tree gnu_index_base_type = get_base_type (gnu_index_type);\n+\t    tree gnu_index_base_type\n+\t      = maybe_character_type (get_base_type (gnu_index_type));\n \t    tree gnu_lb_field, gnu_hb_field, gnu_orig_min, gnu_orig_max;\n \t    tree gnu_min, gnu_max, gnu_high;\n \n@@ -2363,7 +2382,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t      tree gnu_index_base_type = get_base_type (gnu_index_type);\n+\t      tree gnu_index_base_type\n+\t\t= maybe_character_type (get_base_type (gnu_index_type));\n \t      tree gnu_orig_min\n \t\t= convert (gnu_index_base_type,\n \t\t\t   TYPE_MIN_VALUE (gnu_index_type));\n@@ -2375,7 +2395,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      tree gnu_base_index_type\n \t\t= get_unpadded_type (Etype (gnat_base_index));\n \t      tree gnu_base_index_base_type\n-\t        = get_base_type (gnu_base_index_type);\n+\t        = maybe_character_type (get_base_type (gnu_base_index_type));\n \t      tree gnu_base_orig_min\n \t\t= convert (gnu_base_index_base_type,\n \t\t\t   TYPE_MIN_VALUE (gnu_base_index_type));"}, {"sha": "848cabf964ab55df3f65c04fae39d89fdc405141", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -604,6 +604,9 @@ extern void build_dummy_unc_pointer_types (Entity_Id gnat_desig_type,\n extern void record_builtin_type (const char *name, tree type,\n \t\t\t\t bool artificial_p);\n \n+/* Finish constructing the character type CHAR_TYPE.  */\n+extern void finish_character_type (tree char_type);\n+\n /* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record type as a fat pointer type.  */\n extern void finish_fat_pointer_type (tree record_type, tree field_list);\n@@ -1134,3 +1137,30 @@ gnat_signed_type_for (tree type_node)\n {\n   return gnat_signed_or_unsigned_type_for (0, type_node);\n }\n+\n+/* Adjust the character type TYPE if need be.  */\n+\n+static inline tree\n+maybe_character_type (tree type)\n+{\n+  if (TYPE_STRING_FLAG (type) && !TYPE_UNSIGNED (type))\n+    type = gnat_unsigned_type_for (type);\n+\n+  return type;\n+}\n+\n+/* Adjust the character value EXPR if need be.  */\n+\n+static inline tree\n+maybe_character_value (tree expr)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  if (TYPE_STRING_FLAG (type) && !TYPE_UNSIGNED (type))\n+    {\n+      type = gnat_unsigned_type_for (type);\n+      expr = convert (type, expr);\n+    }\n+\n+  return expr;\n+}"}, {"sha": "ccae6fa3619e9af75c200a816281888fa02a35a8", "filename": "gcc/ada/gcc-interface/lang.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Flang.opt?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -76,6 +76,10 @@ fshort-enums\n Ada AdaWhy AdaSCIL\n Use the narrowest integer type possible for enumeration types.\n \n+fsigned-char\n+Ada AdaWhy AdaSCIL\n+Make \\\"char\\\" signed by default.\n+\n gant\n Ada AdaWhy AdaSCIL Joined Undocumented\n Catch typos."}, {"sha": "992ac0a3aa2ea5f9df309ae39bbfb13835b343ab", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -169,7 +169,8 @@ gnat_handle_option (size_t scode, const char *arg, int value, int kind,\n       break;\n \n     case OPT_fshort_enums:\n-      /* This is handled by the middle-end.  */\n+    case OPT_fsigned_char:\n+      /* These are handled by the middle-end.  */\n       break;\n \n     case OPT_fbuiltin_printf:\n@@ -353,8 +354,7 @@ static bool\n gnat_init (void)\n {\n   /* Do little here, most of the standard declarations are set up after the\n-     front-end has been run.  Use the same `char' as C, this doesn't really\n-     matter since we'll use the explicit `unsigned char' for Character.  */\n+     front-end has been run.  Use the same `char' as C for Interfaces.C.  */\n   build_common_tree_nodes (flag_signed_char, false);\n \n   /* In Ada, we use an unsigned 8-bit type for the default boolean type.  */"}, {"sha": "0f626d4e07c732c4e20db50495b3fa78d2bc3510", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 69, "deletions": 174, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -231,7 +231,6 @@ static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n static tree emit_range_check (tree, Node_Id, Node_Id);\n-static tree emit_index_check (tree, tree, tree, tree, Node_Id);\n static tree emit_check (tree, tree, int, Node_Id);\n static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n@@ -354,7 +353,7 @@ gigi (Node_Id gnat_root,\n   /* Record the builtin types.  Define `integer' and `character' first so that\n      dbx will output them first.  */\n   record_builtin_type (\"integer\", integer_type_node, false);\n-  record_builtin_type (\"character\", unsigned_char_type_node, false);\n+  record_builtin_type (\"character\", char_type_node, false);\n   record_builtin_type (\"boolean\", boolean_type_node, false);\n   record_builtin_type (\"void\", void_type_node, false);\n \n@@ -364,8 +363,9 @@ gigi (Node_Id gnat_root,\n \t\t false);\n \n   /* Likewise for character as the type for Standard.Character.  */\n+  finish_character_type (char_type_node);\n   save_gnu_tree (Base_Type (standard_character),\n-\t\t TYPE_NAME (unsigned_char_type_node),\n+\t\t TYPE_NAME (char_type_node),\n \t\t false);\n \n   /* Likewise for boolean as the type for Standard.Boolean.  */\n@@ -544,21 +544,21 @@ gigi (Node_Id gnat_root,\n   others_decl\n     = create_var_decl (get_identifier (\"OTHERS\"),\n \t\t       get_identifier (\"__gnat_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       char_type_node, NULL_TREE,\n \t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n   all_others_decl\n     = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n \t\t       get_identifier (\"__gnat_all_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       char_type_node, NULL_TREE,\n \t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n   unhandled_others_decl\n     = create_var_decl (get_identifier (\"UNHANDLED_OTHERS\"),\n \t\t       get_identifier (\"__gnat_unhandled_others_value\"),\n-\t\t       unsigned_char_type_node, NULL_TREE,\n+\t\t       char_type_node, NULL_TREE,\n \t\t       true, false, true, false, false, true, false,\n \t\t       NULL, Empty);\n \n@@ -571,8 +571,7 @@ gigi (Node_Id gnat_root,\n \t= create_subprog_decl\n \t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE,\n \t   build_function_type_list (void_type_node,\n-\t\t\t\t     build_pointer_type\n-\t\t\t\t     (unsigned_char_type_node),\n+\t\t\t\t     build_pointer_type (char_type_node),\n \t\t\t\t     integer_type_node, NULL_TREE),\n \t   NULL_TREE, is_disabled, false, true, true, true, true, false,\n \t   NULL, Empty);\n@@ -720,8 +719,7 @@ build_raise_check (int check, enum exception_info_kind kind)\n       Name_Buffer[Name_Len] = 0;\n       ftype\n \t= build_function_type_list (void_type_node,\n-\t\t\t\t    build_pointer_type\n-\t\t\t\t    (unsigned_char_type_node),\n+\t\t\t\t    build_pointer_type (char_type_node),\n \t\t\t\t    integer_type_node, NULL_TREE);\n     }\n   else\n@@ -732,8 +730,7 @@ build_raise_check (int check, enum exception_info_kind kind)\n       Name_Buffer[Name_Len + 4] = 0;\n       ftype\n \t= build_function_type_list (void_type_node,\n-\t\t\t\t    build_pointer_type\n-\t\t\t\t    (unsigned_char_type_node),\n+\t\t\t\t    build_pointer_type (char_type_node),\n \t\t\t\t    integer_type_node, integer_type_node,\n \t\t\t\t    t, t, NULL_TREE);\n     }\n@@ -1547,7 +1544,7 @@ static tree\n get_type_length (tree type, tree result_type)\n {\n   tree comp_type = get_base_type (result_type);\n-  tree base_type = get_base_type (type);\n+  tree base_type = maybe_character_type (get_base_type (type));\n   tree lb = convert (base_type, TYPE_MIN_VALUE (type));\n   tree hb = convert (base_type, TYPE_MAX_VALUE (type));\n   tree length\n@@ -1605,13 +1602,11 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n     case Attr_Val:\n       /* These are just conversions since representation clauses for\n \t enumeration types are handled in the front-end.  */\n-      {\n-\tbool checkp = Do_Range_Check (First (Expressions (gnat_node)));\n-\tgnu_result = gnat_to_gnu (First (Expressions (gnat_node)));\n-\tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\tgnu_result = convert_with_check (Etype (gnat_node), gnu_result,\n-\t\t\t\t\t checkp, checkp, true, gnat_node);\n-      }\n+      gnu_expr = gnat_to_gnu (First (Expressions (gnat_node)));\n+      if (attribute == Attr_Pos)\n+\tgnu_expr = maybe_character_value (gnu_expr);\n+      gnu_result_type = get_unpadded_type (Etype (gnat_node));\n+      gnu_result = convert (gnu_result_type, gnu_expr);\n       break;\n \n     case Attr_Pred:\n@@ -1620,24 +1615,12 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t clauses for enumeration types are handled in the front-end.  */\n       gnu_expr = gnat_to_gnu (First (Expressions (gnat_node)));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n-\n-      if (Do_Range_Check (First (Expressions (gnat_node))))\n-\t{\n-\t  gnu_expr = gnat_protect_expr (gnu_expr);\n-\t  gnu_expr\n-\t    = emit_check\n-\t      (build_binary_op (EQ_EXPR, boolean_type_node,\n-\t\t\t\tgnu_expr,\n-\t\t\t\tattribute == Attr_Pred\n-\t\t\t\t? TYPE_MIN_VALUE (gnu_result_type)\n-\t\t\t\t: TYPE_MAX_VALUE (gnu_result_type)),\n-\t       gnu_expr, CE_Range_Check_Failed, gnat_node);\n-\t}\n-\n+      gnu_type = maybe_character_type (gnu_result_type);\n+      if (TREE_TYPE (gnu_expr) != gnu_type)\n+\tgnu_expr = convert (gnu_type, gnu_expr);\n       gnu_result\n \t= build_binary_op (attribute == Attr_Pred ? MINUS_EXPR : PLUS_EXPR,\n-\t\t\t   gnu_result_type, gnu_expr,\n-\t\t\t   build_int_cst (gnu_result_type, 1));\n+\t\t\t   gnu_type, gnu_expr, build_int_cst (gnu_type, 1));\n       break;\n \n     case Attr_Address:\n@@ -2877,7 +2860,7 @@ Loop_Statement_to_gnu (Node_Id gnat_node)\n       Entity_Id gnat_loop_var = Defining_Entity (gnat_loop_spec);\n       Entity_Id gnat_type = Etype (gnat_loop_var);\n       tree gnu_type = get_unpadded_type (gnat_type);\n-      tree gnu_base_type = get_base_type (gnu_type);\n+      tree gnu_base_type = maybe_character_type (get_base_type (gnu_type));\n       tree gnu_one_node = build_int_cst (gnu_base_type, 1);\n       tree gnu_loop_var, gnu_loop_iv, gnu_first, gnu_last, gnu_stmt;\n       enum tree_code update_code, test_code, shift_code;\n@@ -5514,7 +5497,7 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       if (Present (gnat_cond) && Nkind (gnat_cond) == N_Op_Not)\n \t{\n \t  Node_Id gnat_range, gnat_index, gnat_type;\n-\t  tree gnu_index, gnu_low_bound, gnu_high_bound, disp;\n+\t  tree gnu_type, gnu_index, gnu_low_bound, gnu_high_bound, disp;\n \t  bool neg_p;\n \t  struct loop_info_d *loop;\n \n@@ -5543,8 +5526,18 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \n \t  gnat_index = Left_Opnd (Right_Opnd (gnat_cond));\n \t  gnat_type = Etype (gnat_index);\n+\t  gnu_type = maybe_character_type (get_unpadded_type (gnat_type));\n \t  gnu_index = gnat_to_gnu (gnat_index);\n \n+\t  if (TREE_TYPE (gnu_index) != gnu_type)\n+\t    {\n+\t      if (gnu_low_bound)\n+\t\tgnu_low_bound = convert (gnu_type, gnu_low_bound);\n+\t      if (gnu_high_bound)\n+\t\tgnu_high_bound = convert (gnu_type, gnu_high_bound);\n+\t      gnu_index = convert (gnu_type, gnu_index);\n+\t    }\n+\n \t  if (with_extra_info\n \t      && gnu_low_bound\n \t      && gnu_high_bound\n@@ -5589,7 +5582,7 @@ Raise_Error_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t      rci->high_bound = gnu_high_bound;\n \t      rci->disp = disp;\n \t      rci->neg_p = neg_p;\n-\t      rci->type = get_unpadded_type (gnat_type);\n+\t      rci->type = gnu_type;\n \t      rci->inserted_cond\n \t\t= build1 (SAVE_EXPR, boolean_type_node, boolean_true_node);\n \t      vec_safe_push (loop->checks, rci);\n@@ -6156,8 +6149,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    = convert (TREE_TYPE (TYPE_FIELDS (TREE_TYPE (gnu_array_object))),\n \t\t       gnu_array_object);\n \n-\tgnu_result = gnu_array_object;\n-\n \t/* The failure of this assertion will very likely come from a missing\n \t   expansion for a packed array access.  */\n \tgcc_assert (TREE_CODE (TREE_TYPE (gnu_array_object)) == ARRAY_TYPE);\n@@ -6184,23 +6175,18 @@ gnat_to_gnu (Node_Id gnat_node)\n \t       i++, gnat_temp = Next (gnat_temp))\n \t    gnat_expr_array[i] = gnat_temp;\n \n+\t/* Start with the prefix and build the successive references.  */\n+\tgnu_result = gnu_array_object;\n+\n \tfor (i = 0, gnu_type = TREE_TYPE (gnu_array_object);\n \t     i < ndim;\n \t     i++, gnu_type = TREE_TYPE (gnu_type))\n \t  {\n \t    gcc_assert (TREE_CODE (gnu_type) == ARRAY_TYPE);\n \t    gnat_temp = gnat_expr_array[i];\n-\t    gnu_expr = gnat_to_gnu (gnat_temp);\n+\t    gnu_expr = maybe_character_value (gnat_to_gnu (gnat_temp));\n \t    struct loop_info_d *loop;\n \n-\t    if (Do_Range_Check (gnat_temp))\n-\t      gnu_expr\n-\t\t= emit_index_check\n-\t\t  (gnu_array_object, gnu_expr,\n-\t\t   TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n-\t\t   TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n-\t\t   gnat_temp);\n-\n \t    gnu_result\n \t      = build_binary_op (ARRAY_REF, NULL_TREE, gnu_result, gnu_expr);\n \n@@ -6251,88 +6237,25 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Slice:\n       {\n-\tNode_Id gnat_range_node = Discrete_Range (gnat_node);\n-\ttree gnu_type;\n+\ttree gnu_array_object = gnat_to_gnu (Prefix (gnat_node));\n \n-\tgnu_result = gnat_to_gnu (Prefix (gnat_node));\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n-\t/* Do any implicit dereferences of the prefix and do any needed\n-\t   range check.  */\n-\tgnu_result = maybe_implicit_deref (gnu_result);\n-\tgnu_result = maybe_unconstrained_array (gnu_result);\n-\tgnu_type = TREE_TYPE (gnu_result);\n-\tif (Do_Range_Check (gnat_range_node))\n-\t  {\n-\t    /* Get the bounds of the slice.  */\n-\t    tree gnu_index_type\n-\t      = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_result_type));\n-\t    tree gnu_min_expr = TYPE_MIN_VALUE (gnu_index_type);\n-\t    tree gnu_max_expr = TYPE_MAX_VALUE (gnu_index_type);\n-\t    /* Get the permitted bounds.  */\n-\t    tree gnu_base_index_type\n-\t      = TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type));\n-\t    tree gnu_base_min_expr = SUBSTITUTE_PLACEHOLDER_IN_EXPR\n-\t      (TYPE_MIN_VALUE (gnu_base_index_type), gnu_result);\n-\t    tree gnu_base_max_expr = SUBSTITUTE_PLACEHOLDER_IN_EXPR\n-\t      (TYPE_MAX_VALUE (gnu_base_index_type), gnu_result);\n-\t    tree gnu_expr_l, gnu_expr_h, gnu_expr_type;\n-\n-\t   gnu_min_expr = gnat_protect_expr (gnu_min_expr);\n-\t   gnu_max_expr = gnat_protect_expr (gnu_max_expr);\n-\n-\t    /* Derive a good type to convert everything to.  */\n-\t    gnu_expr_type = get_base_type (gnu_index_type);\n-\n-\t    /* Test whether the minimum slice value is too small.  */\n-\t    gnu_expr_l = build_binary_op (LT_EXPR, boolean_type_node,\n-\t\t\t\t\t  convert (gnu_expr_type,\n-\t\t\t\t\t\t   gnu_min_expr),\n-\t\t\t\t\t  convert (gnu_expr_type,\n-\t\t\t\t\t\t   gnu_base_min_expr));\n-\n-\t    /* Test whether the maximum slice value is too large.  */\n-\t    gnu_expr_h = build_binary_op (GT_EXPR, boolean_type_node,\n-\t\t\t\t\t  convert (gnu_expr_type,\n-\t\t\t\t\t\t   gnu_max_expr),\n-\t\t\t\t\t  convert (gnu_expr_type,\n-\t\t\t\t\t\t   gnu_base_max_expr));\n-\n-\t    /* Build a slice index check that returns the low bound,\n-\t       assuming the slice is not empty.  */\n-\t    gnu_expr = emit_check\n-\t      (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t\t\tgnu_expr_l, gnu_expr_h),\n-\t       gnu_min_expr, CE_Index_Check_Failed, gnat_node);\n-\n-\t   /* Build a conditional expression that does the index checks and\n-\t      returns the low bound if the slice is not empty (max >= min),\n-\t      and returns the naked low bound otherwise (max < min), unless\n-\t      it is non-constant and the high bound is; this prevents VRP\n-\t      from inferring bogus ranges on the unlikely path.  */\n-\t    gnu_expr = fold_build3 (COND_EXPR, gnu_expr_type,\n-\t\t\t\t    build_binary_op (GE_EXPR, gnu_expr_type,\n-\t\t\t\t\t\t     convert (gnu_expr_type,\n-\t\t\t\t\t\t\t      gnu_max_expr),\n-\t\t\t\t\t\t     convert (gnu_expr_type,\n-\t\t\t\t\t\t\t      gnu_min_expr)),\n-\t\t\t\t    gnu_expr,\n-\t\t\t\t    TREE_CODE (gnu_min_expr) != INTEGER_CST\n-\t\t\t\t    && TREE_CODE (gnu_max_expr) == INTEGER_CST\n-\t\t\t\t    ? gnu_max_expr : gnu_min_expr);\n-\t  }\n-\telse\n-\t  /* Simply return the naked low bound.  */\n-\t  gnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n+\tgnu_array_object = maybe_implicit_deref (gnu_array_object);\n+\tgnu_array_object = maybe_unconstrained_array (gnu_array_object);\n+\n+\tgnu_expr = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_result_type));\n+\tgnu_expr = maybe_character_value (gnu_expr);\n \n \t/* If this is a slice with non-constant size of an array with constant\n \t   size, set the maximum size for the allocation of temporaries.  */\n \tif (!TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_result_type))\n-\t    && TREE_CONSTANT (TYPE_SIZE_UNIT (gnu_type)))\n-\t  TYPE_ARRAY_MAX_SIZE (gnu_result_type) = TYPE_SIZE_UNIT (gnu_type);\n+\t    && TREE_CONSTANT (TYPE_SIZE_UNIT (TREE_TYPE (gnu_array_object))))\n+\t  TYPE_ARRAY_MAX_SIZE (gnu_result_type)\n+\t    = TYPE_SIZE_UNIT (TREE_TYPE (gnu_array_object));\n \n \tgnu_result = build_binary_op (ARRAY_RANGE_REF, gnu_result_type,\n-\t\t\t\t      gnu_result, gnu_expr);\n+\t\t\t\t      gnu_array_object, gnu_expr);\n       }\n       break;\n \n@@ -6472,8 +6395,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \n     case N_Type_Conversion:\n     case N_Qualified_Expression:\n-      /* Get the operand expression.  */\n-      gnu_result = gnat_to_gnu (Expression (gnat_node));\n+      gnu_expr = maybe_character_value (gnat_to_gnu (Expression (gnat_node)));\n       gnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n       /* If this is a qualified expression for a tagged type, we mark the type\n@@ -6484,19 +6406,20 @@ gnat_to_gnu (Node_Id gnat_node)\n \tused_types_insert (gnu_result_type);\n \n       gnu_result\n-\t= convert_with_check (Etype (gnat_node), gnu_result,\n+\t= convert_with_check (Etype (gnat_node), gnu_expr,\n \t\t\t      Do_Overflow_Check (gnat_node),\n \t\t\t      Do_Range_Check (Expression (gnat_node)),\n \t\t\t      kind == N_Type_Conversion\n \t\t\t      && Float_Truncate (gnat_node), gnat_node);\n       break;\n \n     case N_Unchecked_Type_Conversion:\n-      gnu_result = gnat_to_gnu (Expression (gnat_node));\n+      gnu_expr = maybe_character_value (gnat_to_gnu (Expression (gnat_node)));\n \n       /* Skip further processing if the conversion is deemed a no-op.  */\n       if (unchecked_conversion_nop (gnat_node))\n \t{\n+\t  gnu_result = gnu_expr;\n \t  gnu_result_type = TREE_TYPE (gnu_result);\n \t  break;\n \t}\n@@ -6508,7 +6431,7 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (STRICT_ALIGNMENT && POINTER_TYPE_P (gnu_result_type)\n \t  && IN (Ekind (Etype (gnat_node)), Access_Kind))\n \t{\n-\t  unsigned int align = known_alignment (gnu_result);\n+\t  unsigned int align = known_alignment (gnu_expr);\n \t  tree gnu_obj_type = TREE_TYPE (gnu_result_type);\n \t  unsigned int oalign = TYPE_ALIGN (gnu_obj_type);\n \n@@ -6522,11 +6445,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* If we are converting a descriptor to a function pointer, first\n \t build the pointer.  */\n       if (TARGET_VTABLE_USES_DESCRIPTORS\n-\t  && TREE_TYPE (gnu_result) == fdesc_type_node\n+\t  && TREE_TYPE (gnu_expr) == fdesc_type_node\n \t  && POINTER_TYPE_P (gnu_result_type))\n-\tgnu_result = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_result);\n+\tgnu_expr = build_unary_op (ADDR_EXPR, NULL_TREE, gnu_expr);\n \n-      gnu_result = unchecked_convert (gnu_result_type, gnu_result,\n+      gnu_result = unchecked_convert (gnu_result_type, gnu_expr,\n \t\t\t\t      No_Truncation (gnat_node));\n       break;\n \n@@ -6560,6 +6483,14 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \n+\ttree gnu_op_type = maybe_character_type (TREE_TYPE (gnu_obj));\n+\tif (TREE_TYPE (gnu_obj) != gnu_op_type)\n+\t  {\n+\t    gnu_obj = convert (gnu_op_type, gnu_obj);\n+\t    gnu_low = convert (gnu_op_type, gnu_low);\n+\t    gnu_high = convert (gnu_op_type, gnu_high);\n+\t  }\n+\n \t/* If LOW and HIGH are identical, perform an equality test.  Otherwise,\n \t   ensure that GNU_OBJ is evaluated only once and perform a full range\n \t   test.  */\n@@ -6660,6 +6591,13 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  {\n \t    gnu_lhs = maybe_unconstrained_array (gnu_lhs);\n \t    gnu_rhs = maybe_unconstrained_array (gnu_rhs);\n+\n+\t    tree gnu_op_type = maybe_character_type (TREE_TYPE (gnu_lhs));\n+\t    if (TREE_TYPE (gnu_lhs) != gnu_op_type)\n+\t      {\n+\t\tgnu_lhs = convert (gnu_op_type, gnu_lhs);\n+\t\tgnu_rhs = convert (gnu_op_type, gnu_rhs);\n+\t      }\n \t  }\n \n \t/* If this is a shift whose count is not guaranteed to be correct,\n@@ -9081,49 +9019,6 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type, Node_Id gnat_node)\n      gnu_expr, CE_Range_Check_Failed, gnat_node);\n }\n \f\n-/* Emit code for an index check.  GNU_ARRAY_OBJECT is the array object which\n-   we are about to index, GNU_EXPR is the index expression to be checked,\n-   GNU_LOW and GNU_HIGH are the lower and upper bounds against which GNU_EXPR\n-   has to be checked.  Note that for index checking we cannot simply use the\n-   emit_range_check function (although very similar code needs to be generated\n-   in both cases) since for index checking the array type against which we are\n-   checking the indices may be unconstrained and consequently we need to get\n-   the actual index bounds from the array object itself (GNU_ARRAY_OBJECT).\n-   The place where we need to do that is in subprograms having unconstrained\n-   array formal parameters.  GNAT_NODE is the GNAT node conveying the source\n-   location for which the error should be signaled.  */\n-\n-static tree\n-emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n-\t\t  tree gnu_high, Node_Id gnat_node)\n-{\n-  tree gnu_expr_check;\n-\n-  /* Checked expressions must be evaluated only once.  */\n-  gnu_expr = gnat_protect_expr (gnu_expr);\n-\n-  /* Must do this computation in the base type in case the expression's\n-     type is an unsigned subtypes.  */\n-  gnu_expr_check = convert (get_base_type (TREE_TYPE (gnu_expr)), gnu_expr);\n-\n-  /* If GNU_LOW or GNU_HIGH are a PLACEHOLDER_EXPR, qualify them by\n-     the object we are handling.  */\n-  gnu_low = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_low, gnu_array_object);\n-  gnu_high = SUBSTITUTE_PLACEHOLDER_IN_EXPR (gnu_high, gnu_array_object);\n-\n-  return emit_check\n-    (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t      build_binary_op (LT_EXPR, boolean_type_node,\n-\t\t\t\t       gnu_expr_check,\n-\t\t\t\t       convert (TREE_TYPE (gnu_expr_check),\n-\t\t\t\t\t\tgnu_low)),\n-\t\t      build_binary_op (GT_EXPR, boolean_type_node,\n-\t\t\t\t       gnu_expr_check,\n-\t\t\t\t       convert (TREE_TYPE (gnu_expr_check),\n-\t\t\t\t\t\tgnu_high))),\n-     gnu_expr, CE_Index_Check_Failed, gnat_node);\n-}\n-\f\n /* GNU_COND contains the condition corresponding to an index, overflow or\n    range check of value GNU_EXPR.  Build a COND_EXPR that returns GNU_EXPR\n    if GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true."}, {"sha": "0ce571a8d6a67bef4505b99ecaf52e0a50bc7627", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -1595,6 +1595,48 @@ record_builtin_type (const char *name, tree type, bool artificial_p)\n     debug_hooks->type_decl (type_decl, false);\n }\n \f\n+/* Finish constructing the character type CHAR_TYPE.\n+\n+  In Ada character types are enumeration types and, as a consequence, are\n+  represented in the front-end by integral types holding the positions of\n+  the enumeration values as defined by the language, which means that the\n+  integral types are unsigned.\n+\n+  Unfortunately the signedness of 'char' in C is implementation-defined\n+  and GCC even has the option -fsigned-char to toggle it at run time.\n+  Since GNAT's philosophy is to be compatible with C by default, to wit\n+  Interfaces.C.char is defined as a mere copy of Character, we may need\n+  to declare character types as signed types in GENERIC and generate the\n+  necessary adjustments to make them behave as unsigned types.\n+\n+  The overall strategy is as follows: if 'char' is unsigned, do nothing;\n+  if 'char' is signed, translate character types of CHAR_TYPE_SIZE and\n+  character subtypes with RM_Size = Esize = CHAR_TYPE_SIZE into signed\n+  types.  The idea is to ensure that the bit pattern contained in the\n+  Esize'd objects is not changed, even though the numerical value will\n+  be interpreted differently depending on the signedness.\n+\n+  For character types, the bounds are implicit and, therefore, need to\n+  be adjusted.  Morever, the debug info needs the unsigned version.  */\n+\n+void\n+finish_character_type (tree char_type)\n+{\n+  if (TYPE_UNSIGNED (char_type))\n+    return;\n+\n+  /* Make a copy of the unsigned version since we'll modify it below.  */\n+  tree unsigned_char_type = copy_type (gnat_unsigned_type_for (char_type));\n+\n+  TYPE_NAME (unsigned_char_type) = TYPE_NAME (char_type);\n+  TYPE_STRING_FLAG (unsigned_char_type) = TYPE_STRING_FLAG (char_type);\n+  TYPE_ARTIFICIAL (unsigned_char_type) = TYPE_ARTIFICIAL (char_type);\n+\n+  SET_TYPE_DEBUG_TYPE (char_type, unsigned_char_type);\n+  SET_TYPE_RM_MIN_VALUE (char_type, TYPE_MIN_VALUE (unsigned_char_type));\n+  SET_TYPE_RM_MAX_VALUE (char_type, TYPE_MAX_VALUE (unsigned_char_type));\n+}\n+\n /* Given a record type RECORD_TYPE and a list of FIELD_DECL nodes FIELD_LIST,\n    finish constructing the record type as a fat pointer type.  */\n \n@@ -3360,6 +3402,9 @@ gnat_type_for_mode (machine_mode mode, int unsignedp)\n tree\n gnat_signed_or_unsigned_type_for (int unsignedp, tree type_node)\n {\n+  if (type_node == char_type_node)\n+    return unsignedp ? unsigned_char_type_node : signed_char_type_node;\n+\n   tree type = gnat_type_for_size (TYPE_PRECISION (type_node), unsignedp);\n \n   if (TREE_CODE (type_node) == INTEGER_TYPE && TYPE_MODULAR_P (type_node))"}, {"sha": "ba4a5dca3e89c04321144fc8b05f63fea5f27bab", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/825da0d20f71cd82fa58e16e92099879e9a8b8f2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=825da0d20f71cd82fa58e16e92099879e9a8b8f2", "patch": "@@ -1804,7 +1804,7 @@ expand_sloc (Node_Id gnat_node, tree *filename, tree *line, tree *col)\n \n   const int len = strlen (str);\n   *filename = build_string (len, str);\n-  TREE_TYPE (*filename) = build_array_type (unsigned_char_type_node,\n+  TREE_TYPE (*filename) = build_array_type (char_type_node,\n \t\t\t\t\t    build_index_type (size_int (len)));\n   *line = build_int_cst (NULL_TREE, line_number);\n   if (col)\n@@ -1834,7 +1834,7 @@ build_call_raise (int msg, Node_Id gnat_node, char kind)\n   return\n     build_call_n_expr (fndecl, 2,\n \t\t       build1 (ADDR_EXPR,\n-\t\t\t       build_pointer_type (unsigned_char_type_node),\n+\t\t\t       build_pointer_type (char_type_node),\n \t\t\t       filename),\n \t\t       line);\n }\n@@ -1858,7 +1858,7 @@ build_call_raise_column (int msg, Node_Id gnat_node, char kind)\n   return\n     build_call_n_expr (fndecl, 3,\n \t\t       build1 (ADDR_EXPR,\n-\t\t\t       build_pointer_type (unsigned_char_type_node),\n+\t\t\t       build_pointer_type (char_type_node),\n \t\t\t       filename),\n \t\t       line, col);\n }\n@@ -1883,7 +1883,7 @@ build_call_raise_range (int msg, Node_Id gnat_node, char kind,\n   return\n     build_call_n_expr (fndecl, 6,\n \t\t       build1 (ADDR_EXPR,\n-\t\t\t       build_pointer_type (unsigned_char_type_node),\n+\t\t\t       build_pointer_type (char_type_node),\n \t\t\t       filename),\n \t\t       line, col,\n \t\t       convert (integer_type_node, index),"}]}