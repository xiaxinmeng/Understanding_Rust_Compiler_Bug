{"sha": "91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFlYjVmYThlMWZhZTU3ZjZkNjliMmI5NzNmZmRmMTk4OGQxOGNhMQ==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2019-11-06T01:25:09Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2019-11-06T01:25:09Z"}, "message": "PR tree-optimization/92373 - ICE in -Warray-bounds on access to member array in an initialized char buffer\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/92373\n\t* gcc.dg/Warray-bounds-55.c: New test.\n\t* gcc.dg/Wzero-length-array-bounds-2.c: New test.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/92373\n\t* tree.c (component_ref_size): Only consider initializers of objects\n\tof matching struct types.\n\tReturn null for instances of interior zero-length arrays.\n\nFrom-SVN: r277871", "tree": {"sha": "35311a912227df67c92d9e17b2e86ffc2784693a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35311a912227df67c92d9e17b2e86ffc2784693a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eebabc49a3f5385d33cab235ec42e1ee0b5ca3c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eebabc49a3f5385d33cab235ec42e1ee0b5ca3c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eebabc49a3f5385d33cab235ec42e1ee0b5ca3c2"}], "stats": {"total": 215, "additions": 193, "deletions": 22}, "files": [{"sha": "e666a0ccf27257b724a7693029316c9642333433", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "patch": "@@ -1,3 +1,10 @@\n+2019-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92373\n+\t* tree.c (component_ref_size): Only consider initializers of objects\n+\tof matching struct types.\n+\tReturn null for instances of interior zero-length arrays.\n+\n 2019-11-05  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* doc/md.texi (Insn Splitting): Fix combiner documentation."}, {"sha": "6b5a444ee8f6e7d957216b9b305566fa5b84040c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "patch": "@@ -1,3 +1,9 @@\n+2019-11-05  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/92373\n+\t* gcc.dg/Warray-bounds-55.c: New test.\n+\t* gcc.dg/Wzero-length-array-bounds-2.c: New test.\n+\n 2019-11-05  Jim Wilson  <jimw@sifive.com>\n \n \tPR middle-end/92263"}, {"sha": "b7dfe7068527e5df920398c6e5a16754d2b9ea7b", "filename": "gcc/testsuite/gcc.dg/Warray-bounds-55.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-55.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-55.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWarray-bounds-55.c?ref=91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "patch": "@@ -0,0 +1,28 @@\n+/* PR middle-end/92373 - ICE in -Warray-bounds on access to member array\n+   in an initialized char buffer\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void sink (void*);\n+\n+struct S\n+{\n+  char data[1];\n+};\n+\n+char a[6] = { };\n+\n+int f (void)\n+{\n+  struct S *p = (struct S*)a;\n+  return p->data[4];\n+\n+}\n+\n+void g (void)\n+{\n+  char b[6] = { };\n+  struct S *p = (struct S*)b;\n+  p->data[4] = 0;\n+  sink (p);\n+}"}, {"sha": "841b2bfa1229c47159265353d7ae0e98cae3b977", "filename": "gcc/testsuite/gcc.dg/Wzero-length-array-bounds-2.c", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWzero-length-array-bounds-2.c?ref=91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "patch": "@@ -0,0 +1,125 @@\n+/* Test to verify that -Wzero-length-bounds and not -Warray-bounds is\n+   issued for accesses to interior zero-length array members that are\n+   within the bounds of the enclosing struct.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+void sink (void*);\n+\n+struct A { int i; };\n+struct B { int j; struct A a[0]; };\n+\n+struct C\n+{\n+  struct B b1;\n+  struct B b2;\n+};\n+\n+\n+void test_B_ref (struct B *p)\n+{\n+  // References with negative indices are always diagnosed by -Warray-bounds\n+  // even though they could be considered the same as past the end accesses\n+  // to trailing zero-length arrays.\n+  p->a[-1].i = 0;       // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->a[ 0].i = 0;\n+  p->a[ 1].i = 0;\n+  sink (p);\n+\n+  p[1].a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p[1].a[ 0].i = 0;\n+  p[1].a[ 1].i = 0;\n+}\n+\n+\n+void test_C_ref (struct C *p)\n+{\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+\n+  // Accesses to trailing zero-length arrays are not diagnosed (should\n+  // they be?)\n+  p->b2.a[ 0].i = 0;\n+  p->b2.a[ 9].i = 0;\n+}\n+\n+\n+void test_C_decl (void)\n+{\n+  struct C c, *p = &c;\n+\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+\n+  // c.b1.a[0].i overlaps c.b2.j.\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+\n+  // c.b1.a[1].i is past the end of c...\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  // ...and so are references to all elements of c.b2.a\n+  p->b2.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}\n+\n+\n+char cbuf1[1 * sizeof (struct C)];\n+char cbuf2[2 * sizeof (struct C)] = { };\n+\n+void test_C_global_buf (void)\n+{\n+  struct C *p = (struct C*)&cbuf1;\n+\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p = (struct C*)&cbuf2;\n+  p->b1.a[-1].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 0;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 0;\n+  p->b2.a[ 1].i = 0;\n+  p->b2.a[ 2].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 3].i = 0;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}\n+\n+\n+void test_C_local_buf (void)\n+{\n+  char cbuf1[1 * sizeof (struct C)] = \"\";\n+  char cbuf2[2 * sizeof (struct C)] = { };\n+\n+  struct C *p = (struct C*)&cbuf1;\n+\n+  p->b1.a[-1].i = 1;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 2;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 3;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 4;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 1].i = 5;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+\n+  p = (struct C*)&cbuf2;\n+  p->b1.a[-1].i = 6;     // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b1.a[ 0].i = 7;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  p->b1.a[ 1].i = 8;     // { dg-warning \"\\\\\\[-Wzero-length-bounds\" }\n+  sink (p);\n+\n+  p->b2.a[ 0].i = 9;\n+  p->b2.a[ 1].i = 10;\n+  p->b2.a[ 2].i = 11;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  p->b2.a[ 3].i = 12;    // { dg-warning \"\\\\\\[-Warray-bounds\" }\n+  sink (p);\n+}"}, {"sha": "d08141bcfc2bdc467962a550b77d6a6dc713d3c8", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=91eb5fa8e1fae57f6d69b2b973ffdf1988d18ca1", "patch": "@@ -13635,6 +13635,8 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \treturn NULL_TREE;\n \n       base = TREE_OPERAND (ref, 0);\n+      while (TREE_CODE (base) == COMPONENT_REF)\n+\tbase = TREE_OPERAND (base, 0);\n       baseoff = tree_to_poly_int64 (byte_position (TREE_OPERAND (ref, 1)));\n     }\n \n@@ -13656,27 +13658,28 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \n   memsize = NULL_TREE;\n \n-  /* MEMBER is a true flexible array member.  Compute its size from\n-     the initializer of the BASE object if it has one.  */\n-  if (tree init = DECL_P (base) ? DECL_INITIAL (base) : NULL_TREE)\n-    {\n-      init = get_initializer_for (init, member);\n-      if (init)\n-\t{\n-\t  memsize = TYPE_SIZE_UNIT (TREE_TYPE (init));\n-\t  if (tree refsize = TYPE_SIZE_UNIT (reftype))\n-\t    {\n-\t      /* Use the larger of the initializer size and the tail\n-\t\t padding in the enclosing struct.  */\n-\t      poly_int64 rsz = tree_to_poly_int64 (refsize);\n-\t      rsz -= baseoff;\n-\t      if (known_lt (tree_to_poly_int64 (memsize), rsz))\n-\t\tmemsize = wide_int_to_tree (TREE_TYPE (memsize), rsz);\n-\t    }\n+  if (typematch)\n+    /* MEMBER is a true flexible array member.  Compute its size from\n+       the initializer of the BASE object if it has one.  */\n+    if (tree init = DECL_P (base) ? DECL_INITIAL (base) : NULL_TREE)\n+      {\n+\tinit = get_initializer_for (init, member);\n+\tif (init)\n+\t  {\n+\t    memsize = TYPE_SIZE_UNIT (TREE_TYPE (init));\n+\t    if (tree refsize = TYPE_SIZE_UNIT (reftype))\n+\t      {\n+\t\t/* Use the larger of the initializer size and the tail\n+\t\t   padding in the enclosing struct.  */\n+\t\tpoly_int64 rsz = tree_to_poly_int64 (refsize);\n+\t\trsz -= baseoff;\n+\t\tif (known_lt (tree_to_poly_int64 (memsize), rsz))\n+\t\t  memsize = wide_int_to_tree (TREE_TYPE (memsize), rsz);\n+\t      }\n \n-\t  baseoff = 0;\n-\t}\n-    }\n+\t    baseoff = 0;\n+\t  }\n+      }\n \n   if (!memsize)\n     {\n@@ -13689,17 +13692,19 @@ component_ref_size (tree ref, bool *interior_zero_length /* = NULL */)\n \t    /* The size of a flexible array member of an extern struct\n \t       with no initializer cannot be determined (it's defined\n \t       in another translation unit and can have an initializer\n-\t       witth an arbitrary number of elements).  */\n+\t       with an arbitrary number of elements).  */\n \t    return NULL_TREE;\n \n \t  /* Use the size of the base struct or, for interior zero-length\n \t     arrays, the size of the enclosing type.  */\n \t  memsize = TYPE_SIZE_UNIT (bt);\n \t}\n-      else\n+      else if (DECL_P (base))\n \t/* Use the size of the BASE object (possibly an array of some\n \t   other type such as char used to store the struct).  */\n \tmemsize = DECL_SIZE_UNIT (base);\n+      else\n+\treturn NULL_TREE;\n     }\n \n   /* If the flexible array member has a known size use the greater"}]}