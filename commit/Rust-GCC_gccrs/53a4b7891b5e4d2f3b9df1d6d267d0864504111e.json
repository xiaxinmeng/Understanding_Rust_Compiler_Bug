{"sha": "53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTNhNGI3ODkxYjVlNGQyZjNiOWRmMWQ2ZDI2N2QwODY0NTA0MTExZQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@albatross.co.nz", "date": "2000-11-28T04:50:51Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-11-28T04:50:51Z"}, "message": "DataInputStream.java: Merge classpath docs.\n\n2000-11-28  Bryce McKinlay  <bryce@abatross.co.nz>\n\n\t* java/io/DataInputStream.java: Merge classpath docs. Call in.read()\n\tdirectly rather than read() in all cases. Make primitive read\n\timplementations\tmore efficient, as defined in JDK online docs.\n\t(skipBytes): Behave like the JDK's implementation.\n\t* java/io/BufferedReader.java: Merge classpath docs. Check for a\n\tclosed stream with checkStatus() whenever an IOException can be\n\tthrown.\n\t(checkStatus): New private method.\n\nFrom-SVN: r37810", "tree": {"sha": "12950623690b5a53e120ee2a8ec3e7a3c4ef0274", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/12950623690b5a53e120ee2a8ec3e7a3c4ef0274"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/comments", "author": null, "committer": null, "parents": [{"sha": "102870fb8f6230375e4f4c1db944448797879672", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/102870fb8f6230375e4f4c1db944448797879672", "html_url": "https://github.com/Rust-GCC/gccrs/commit/102870fb8f6230375e4f4c1db944448797879672"}], "stats": {"total": 280, "additions": 222, "deletions": 58}, "files": [{"sha": "db3f1887f99c443068a6df1b3fcc414f3bfefa2d", "filename": "libjava/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "patch": "@@ -1,3 +1,14 @@\n+2000-11-28  Bryce McKinlay  <bryce@abatross.co.nz>\n+\n+\t* java/io/DataInputStream.java: Merge classpath docs. Call in.read()\n+\tdirectly rather than read() in all cases. Make primitive read \n+\timplementations\tmore efficient, as defined in JDK online docs.\n+\t(skipBytes): Behave like the JDK's implementation.\n+\t* java/io/BufferedReader.java: Merge classpath docs. Check for a \n+\tclosed stream with checkStatus() whenever an IOException can be \n+\tthrown.\n+\t(checkStatus): New private method.\n+\n 2000-11-27  Warren Levy  <warrenl@cygnus.com>\n \n \t* Makefile.am: Added natTimeZone.cc."}, {"sha": "9a293da5cd38c0e662a9e766775b40dcc9a14cef", "filename": "libjava/java/io/BufferedReader.java", "status": "modified", "additions": 138, "deletions": 6, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2Fjava%2Fio%2FBufferedReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2Fjava%2Fio%2FBufferedReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FBufferedReader.java?ref=53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "patch": "@@ -1,4 +1,4 @@\n-/* Copyright (C) 1998, 1999  Free Software Foundation\n+/* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n    This file is part of libgcj.\n \n@@ -8,15 +8,25 @@\n  \n package java.io;\n \n-/**\n- * @author Per Bothner <bothner@cygnus.com>\n- * @date April 22, 1998.  \n- */\n /* Written using \"Java Class Libraries\", 2nd edition, plus online\n  * API docs for JDK 1.2 beta from http://www.javasoft.com.\n  * Status:  Believed complete and correct.\n  */\n \n+/**\n+  * This subclass of <code>FilterReader</code> buffers input from an \n+  * underlying implementation to provide a possibly more efficient read\n+  * mechanism.  It maintains the buffer and buffer state in instance \n+  * variables that are available to subclasses.  The default buffer size\n+  * of 512 chars can be overridden by the creator of the stream.\n+  * <p>\n+  * This class also implements mark/reset functionality.  It is capable\n+  * of remembering any number of input chars, to the limits of\n+  * system memory or the size of <code>Integer.MAX_VALUE</code>\n+  *\n+  * @author Per Bothner <bothner@cygnus.com>\n+  * @author Aaron M. Renn <arenn@urbanophile.com>\n+  */\n public class BufferedReader extends Reader\n {\n   Reader in;\n@@ -43,18 +53,37 @@ public class BufferedReader extends Reader\n      guaranteed to be >= the read-limit requested in the call to mark. */\n   int markPos = -1;\n \n+  /**\n+    * Create a new <code>BufferedReader</code> that will read from the \n+    * specified subordinate stream with a default buffer size of 4096 chars.\n+    *\n+    * @param in The subordinate stream to read from\n+    */\n   public BufferedReader(Reader in)\n   {\n     this(in, 8192);\n   }\n \n+  /**\n+    * Create a new <code>BufferedReader</code> that will read from the \n+    * specified subordinate stream with a buffer size that is specified by the \n+    * caller.\n+    *\n+    * @param in The subordinate stream to read from\n+    * @param bufsize The buffer size to use\n+    */\n   public BufferedReader(Reader in, int size)\n   {\n     super(in.lock);\n     this.in = in;\n     buffer = new char[size];\n   }\n \n+  /**\n+    * This method closes the stream \n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public void close() throws IOException\n   {\n     synchronized (lock)\n@@ -66,13 +95,40 @@ public void close() throws IOException\n       }\n   }\n \n+  /**\n+    * Returns <code>true</code> to indicate that this class supports mark/reset \n+    * functionality.\n+    *\n+    * @return <code>true</code>\n+    */\n   public boolean markSupported()\n   {\n     return true;\n   }\n \n+  /**\n+    * Mark a position in the input to which the stream can be\n+    * \"reset\" by calling the <code>reset()</code> method.  The parameter\n+    * <code>readlimit</code> is the number of chars that can be read from the \n+    * stream after setting the mark before the mark becomes invalid.  For\n+    * example, if <code>mark()</code> is called with a read limit of 10, then \n+    * when 11 chars of data are read from the stream before the \n+    * <code>reset()</code> method is called, then the mark is invalid and the \n+    * stream object instance is not required to remember the mark.\n+    * <p>\n+    * Note that the number of chars that can be remembered by this method\n+    * can be greater than the size of the internal read buffer.  It is also\n+    * not dependent on the subordinate stream supporting mark/reset\n+    * functionality.\n+    *\n+    * @param readlimit The number of chars that can be read before the mark \n+    *        becomes invalid\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public void mark(int readLimit) throws IOException\n   {\n+    checkStatus();\n     synchronized (lock)\n       {\n \t// In this method we need to be aware of the special case where\n@@ -116,8 +172,20 @@ public void mark(int readLimit) throws IOException\n       }\n   }\n \n+  /**\n+    * Reset the stream to the point where the <code>mark()</code> method\n+    * was called.  Any chars that were read after the mark point was set will\n+    * be re-read during subsequent reads.\n+    * <p>\n+    * This method will throw an IOException if the number of chars read from\n+    * the stream since the call to <code>mark()</code> exceeds the mark limit\n+    * passed when establishing the mark.\n+    *\n+    * @exception IOException If an error occurs;\n+    */\n   public void reset() throws IOException\n   {\n+    checkStatus();\n     synchronized (lock)\n       {\n \tif (markPos < 0)\n@@ -136,16 +204,45 @@ public void reset() throws IOException\n       }\n   }\n \n+  /**\n+    * This method determines whether or not a stream is ready to be read.  If\n+    * This method returns <code>false</code> then this stream could (but is\n+    * not guaranteed to) block on the next read attempt.\n+    *\n+    * @return <code>true</code> if this stream is ready to be read, <code>false</code> otherwise\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public boolean ready() throws IOException\n   {\n+    checkStatus();\n     synchronized (lock)\n       {\n \treturn pos < limit || in.ready();\n       }\n   }\n \n+  /**\n+    * This method read chars from a stream and stores them into a caller\n+    * supplied buffer.  It starts storing the data at index <code>offset</code> into\n+    * the buffer and attempts to read <code>len</code> chars.  This method can\n+    * return before reading the number of chars requested.  The actual number\n+    * of chars read is returned as an int.  A -1 is returned to indicate the\n+    * end of the stream.\n+    * <p>\n+    * This method will block until some data can be read.\n+    *\n+    * @param buf The array into which the chars read should be stored\n+    * @param offset The offset into the array to start storing chars\n+    * @param count The requested number of chars to read\n+    *\n+    * @return The actual number of chars read, or -1 if end of stream.\n+    *\n+    * @exception IOException If an error occurs.\n+    */\n   public int read(char[] buf, int offset, int count) throws IOException\n   {\n+    checkStatus();\n     synchronized (lock)\n       {\n \t// Once again, we need to handle the special case of a readLine\n@@ -202,6 +299,7 @@ public int read(char[] buf, int offset, int count) throws IOException\n      Return number of chars read (never 0), or -1 on eof. */\n   private int fill() throws IOException\n   {\n+    checkStatus();\n     // Handle the special case of a readLine that has a '\\r' at the end of\n     // the buffer.  In this case, we'll need to skip a '\\n' if it is the\n     // next char to be read.  This special case is indicated by 'pos > limit'.\n@@ -228,9 +326,10 @@ private int fill() throws IOException\n \n     return count;\n   }\n-\n+  \n   public int read() throws IOException\n   {\n+    checkStatus();\n     synchronized (lock)\n       {\n \tif (pos >= limit && fill () <= 0)\n@@ -255,8 +354,20 @@ private int lineEnd(int limit)\n     return i;\n   }\n \n+  /**\n+    * This method reads a single line of text from the input stream, returning\n+    * it as a <code>String</code>.  A line is terminated by \"\\n\", a \"\\r\", or\n+    * an \"\\r\\n\" sequence.  The system dependent line separator is not used.\n+    * The line termination characters are not returned in the resulting\n+    * <code>String</code>.\n+    * \n+    * @return The line of text read, or <code>null</code> if end of stream.\n+    * \n+    * @exception IOException If an error occurs\n+    */\n   public String readLine() throws IOException\n   {\n+    checkStatus();\n     // Handle the special case where a previous readLine (with no intervening\n     // reads/skips) had a '\\r' at the end of the buffer.\n     // In this case, we'll need to skip a '\\n' if it's the next char to be read.\n@@ -317,8 +428,23 @@ public String readLine() throws IOException\n     return (sbuf.length() == 0 && eof) ? null : sbuf.toString();\n   }\n \n+  /**\n+    * This method skips the specified number of chars in the stream.  It\n+    * returns the actual number of chars skipped, which may be less than the\n+    * requested amount.\n+    * <p>\n+    * This method first discards chars in the buffer, then calls the\n+    * <code>skip</code> method on the underlying stream to skip the remaining chars.\n+    *\n+    * @param num_chars The requested number of chars to skip\n+    *\n+    * @return The actual number of chars skipped.\n+    *\n+    * @exception IOException If an error occurs\n+    */\n   public long skip(long count) throws IOException\n   {\n+    checkStatus();\n     if (count <= 0)\n       return 0;\n     synchronized (lock)\n@@ -370,4 +496,10 @@ public long skip(long count) throws IOException\n \treturn count - todo;\n       }\n   }\n+  \n+  private void checkStatus() throws IOException\n+  {\n+    if (in == null)\n+      throw new IOException(\"Stream closed\");\n+  }  \n }"}, {"sha": "2bcf88d9f8c97b65b3e16b7429da4540e4c35f4b", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 73, "deletions": 52, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/53a4b7891b5e4d2f3b9df1d6d267d0864504111e/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=53a4b7891b5e4d2f3b9df1d6d267d0864504111e", "patch": "@@ -27,7 +27,6 @@\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @date October 20, 1998.  \n  */\n-\n public class DataInputStream extends FilterInputStream implements DataInput\n {\n   // readLine() hack to ensure that an '\\r' not followed by an '\\n' is\n@@ -61,7 +60,7 @@ public DataInputStream(InputStream in)\n    */\n   public final int read(byte[] b) throws IOException\n   {\n-    return super.read(b, 0, b.length);\n+    return in.read(b, 0, b.length);\n   }\n \n   /**\n@@ -82,10 +81,7 @@ public final int read(byte[] b) throws IOException\n    */\n   public final int read(byte[] b, int off, int len) throws IOException\n   {\n-    if (off < 0 || len < 0 || off + len > b.length)\n-      throw new ArrayIndexOutOfBoundsException();\n-\n-    return super.read(b, off, len);\n+    return in.read(b, off, len);\n   }\n \n   /**\n@@ -106,7 +102,10 @@ public final int read(byte[] b, int off, int len) throws IOException\n    */\n   public final boolean readBoolean() throws IOException\n   {\n-    return (readByte() != 0);\n+    int b = in.read();\n+    if (b < 0)\n+      throw new EOFException();    \n+    return (b != 0);\n   }\n \n   /**\n@@ -126,7 +125,7 @@ public final boolean readBoolean() throws IOException\n    */\n   public final byte readByte() throws IOException\n   {\n-    int i = read();\n+    int i = in.read();\n     if (i < 0)\n       throw new EOFException();\n \n@@ -160,7 +159,11 @@ public final byte readByte() throws IOException\n    */\n   public final char readChar() throws IOException\n   {\n-    return (char) ((readByte() << 8) | readUnsignedByte());\n+    int a = in.read();\n+    int b = in.read();\n+    if (b < 0)\n+      throw new EOFException();\n+    return (char) ((a << 8) | (b & 0xff));\n   }\n \n   /**\n@@ -247,13 +250,10 @@ public final void readFully(byte[] b) throws IOException\n    */\n   public final void readFully(byte[] b, int off, int len) throws IOException\n   {\n-    if (off < 0 || len < 0 || off + len > b.length)\n-      throw new ArrayIndexOutOfBoundsException();\n-\n     while (len > 0)\n       {\n-\t// super.read will block until some data is available.\n-\tint numread = super.read(b, off, len);\n+\t// in.read will block until some data is available.\n+\tint numread = in.read(b, off, len);\n \tif (numread < 0)\n \t  throw new EOFException();\n \tlen -= numread;\n@@ -290,11 +290,15 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n    */\n   public final int readInt() throws IOException\n   {\n-    int retval = 0;\n-    for (int i = 0; i < 4; i++)\n-      retval |= readUnsignedByte() << (24 - i * 8);\n-\n-    return retval;\n+    int a = in.read();\n+    int b = in.read();\n+    int c = in.read();\n+    int d = in.read();\n+    if (d < 0)\n+      throw new EOFException();\n+    \n+    return (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n+\t    ((c & 0xff) << 8) | (d & 0xff));\n   }\n \n   /**\n@@ -335,7 +339,7 @@ public final String readLine() throws IOException\n         while (getnext)\n           {\n \t    getnext = false;\n-\t    c = read();\n+\t    c = in.read();\n \t    if (c < 0)\t// got an EOF\n \t      return strb.length() > 0 ? strb.toString() : null;\n \t    ch = (char) c;\n@@ -377,7 +381,7 @@ public final String readLine() throws IOException\n             char next_ch = ' ';\n \t    if (in instanceof BufferedInputStream)\n \t      {\n-\t        next_c = read();\n+\t        next_c = in.read();\n \t        next_ch = (char) (next_c & 0xFF);\n \t\tif ((next_ch != '\\n') && (next_c >= 0)) \n \t\t  {\n@@ -388,12 +392,12 @@ public final String readLine() throws IOException\n \t      }\n \t    else if (markSupported())\n \t      {\n-\t        next_c = read();\n+\t        next_c = in.read();\n \t        next_ch = (char) (next_c & 0xFF);\n \t\tif ((next_ch != '\\n') && (next_c >= 0)) \n \t\t  {\n \t\t    mark(1);\n-\t\t    if ((read() & 0xFF) != '\\n')\n+\t\t    if ((in.read() & 0xFF) != '\\n')\n \t\t      reset();\n \t\t  }\n \t      } \n@@ -441,11 +445,25 @@ else if (markSupported())\n    */\n   public final long readLong() throws IOException\n   {\n-    long retval = 0L;\n-    for (int i = 0; i < 8; i++)\n-      retval |= (long) readUnsignedByte() << (56 - i * 8);\n-\n-    return retval;\n+    int a = in.read();\n+    int b = in.read();\n+    int c = in.read();\n+    int d = in.read();\n+    int e = in.read();\n+    int f = in.read();\n+    int g = in.read();\n+    int h = in.read();\n+    if (h < 0)\n+      throw new EOFException();\n+    \n+    return (((long)(a & 0xff) << 56) |\n+\t    ((long)(b & 0xff) << 48) |\n+\t    ((long)(c & 0xff) << 40) |\n+\t    ((long)(d & 0xff) << 32) |\n+\t    ((long)(e & 0xff) << 24) |\n+\t    ((long)(f & 0xff) << 16) |\n+\t    ((long)(g & 0xff) <<  8) |\n+\t    ((long)(h & 0xff)));\n   }\n \n   /**\n@@ -477,7 +495,11 @@ public final long readLong() throws IOException\n    */\n   public final short readShort() throws IOException\n   {\n-    return (short) ((readByte() << 8) | readUnsignedByte());\n+    int a = in.read();\n+    int b = in.read();\n+    if (b < 0)\n+      throw new EOFException();\n+    return (short) ((a << 8) | (b & 0xff));\n   }\n \n   /**\n@@ -498,7 +520,7 @@ public final short readShort() throws IOException\n    */\n   public final int readUnsignedByte() throws IOException\n   {\n-    int i = read();\n+    int i = in.read();\n     if (i < 0)\n       throw new EOFException();\n \n@@ -532,7 +554,11 @@ public final int readUnsignedByte() throws IOException\n    */\n   public final int readUnsignedShort() throws IOException\n   {\n-    return (readUnsignedByte() << 8) | readUnsignedByte();\n+    int a = in.read();\n+    int b = in.read();\n+    if (b < 0)\n+      throw new EOFException();\n+    return (((a & 0xff) << 8) | (b & 0xff));\n   }\n \n   /**\n@@ -664,34 +690,29 @@ else if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n   /**\n    * This method attempts to skip and discard the specified number of bytes \n    * in the input stream.  It may actually skip fewer bytes than requested. \n-   * The actual number of bytes skipped is returned.  This method will not\n-   * skip any bytes if passed a negative number of bytes to skip.\n+   * This method will not skip any bytes if passed a negative number of bytes \n+   * to skip. \n    *\n    * @param n The requested number of bytes to skip.\n-   *\n-   * @return The number of bytes actually skipped.\n-   *\n+   * @return The requested number of bytes to skip.\n    * @exception IOException If an error occurs.\n+   * @specnote The JDK docs claim that this returns the number of bytes \n+   *  actually skipped. The JCL claims that this method can throw an \n+   *  EOFException. Neither of these appear to be true in the JDK 1.3's\n+   *  implementation. This tries to implement the actual JDK behaviour.\n    */\n   public final int skipBytes(int n) throws IOException\n   {\n-    // The contract in the Java Lang. Spec. says that this never\n-    // throws an EOFException and infers that it doesn't block (since\n-    // it may skip less than the requested number of bytes).\n-    // BUT, the JCL book specifically says that this method blocks\n-    // and can throw an EOFException.  Finally, the Java 1.2 online\n-    // doc simply refers to the general contract.  As such, we will\n-    // stick to the contract and assume for now that the JCL book\n-    // is incorrect.\n-\n-    // Since we're only skipping at most an int number of bytes, the cast\n-    // of return value to an int is fine.\n-    if (n > 0)\n+    if (n <= 0)\n+      return 0;    \n+    try\n       {\n-\tn = Math.min(n, available());\n-        return (int) super.skip((long) n);\n+        return (int) in.skip(n);\n       }\n-\n-    return 0;\n+    catch (EOFException x)\n+      {\n+        // do nothing.\n+      }         \n+    return n;\n   }\n }"}]}