{"sha": "ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "node_id": "C_kwDOANBUbNoAKGFlOGRlY2YxZDJiODMyOWFmNTk1OTJiNGZhNzhlZThkZmFiM2JhNWU", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2022-05-24T18:56:28Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2022-05-24T19:12:00Z"}, "message": "Add new parameter to vec_perm_const hook for specifying operand mode.\n\nThe rationale of the patch is to support vec_perm_expr of the form:\nlhs = vec_perm_expr<rhs, mask>\nwhere lhs and rhs are vector types with different lengths but have\nsame element type. For example, lhs is SVE vector and rhs\nis corresponding AdvSIMD vector.\n\nIt would also allow to express extract even/odd and interleave operations\nwith a VEC_PERM_EXPR.  The interleave currently has the issue that we have\nto artificially widen the inputs with \"dont-care\" elements.\n\ngcc/ChangeLog:\n\n\t* target.def (vec_perm_const): Define new parameter op_mode and\n\tupdate doc.\n\t* doc/tm.texi: Regenerate.\n\t* config/aarch64/aarch64.cc (aarch64_vectorize_vec_perm_const): Adjust\n\tvec_perm_const hook to add new parameter op_mode and return false\n\tif result and operand modes do not match.\n\t* config/arm/arm.cc (arm_vectorize_vec_perm_const): Likewise.\n\t* config/gcn/gcn.cc (gcn_vectorize_vec_perm_const): Likewise.\n\t* config/ia64/ia64.cc (ia64_vectorize_vec_perm_const): Likewise.\n\t* config/mips/mips.cc (mips_vectorize_vec_perm_const): Likewise.\n\t* config/rs6000/rs6000.cc (rs6000_vectorize_vec_perm_const): Likewise\n\t* config/s390/s390.cc (s390_vectorize_vec_perm_const): Likewise.\n\t* config/sparc/sparc.cc (sparc_vectorize_vec_perm_const): Likewise.\n\t* config/i386/i386-expand.cc (ix86_vectorize_vec_perm_const): Likewise.\n\t* config/i386/i386-expand.h (ix86_vectorize_vec_perm_const): Adjust\n\tprototype.\n\t* config/i386/sse.md (ashrv4di3): Adjust call to vec_perm_const hook.\n\t(ashrv2di3): Likewise.\n\t* optabs.cc (expand_vec_perm_const): Likewise.\n\t* optabs-query.h (can_vec_perm_const_p): Adjust prototype.\n\t* optabs-query.cc (can_vec_perm_const_p): Define new parameter\n\top_mode and pass it to vec_perm_const hook.\n\t(can_mult_highpart_p): Adjust call to can_vec_perm_const_p.\n\t* match.pd (vec_perm X Y CST): Likewise.\n\t* tree-ssa-forwprop.cc (simplify_vector_constructor): Likewise.\n\t* tree-vect-data-refs.cc (vect_grouped_store_supported): Likewise.\n\t(vect_grouped_load_supported): Likewise.\n\t(vect_shift_permute_load_chain): Likewise.\n\t* tree-vect-generic.cc (lower_vec_perm): Likewise.\n\t* tree-vect-loop-manip.cc (interleave_supported_p): Likewise.\n\t* tree-vect-loop.cc (have_whole_vector_shift): Likewise.\n\t* tree-vect-patterns.cc (vect_recog_rotate_pattern): Likewise.\n\t* tree-vect-slp.cc (can_duplicate_and_interleave_p): Likewise.\n\t(vect_transform_slp_perm_load): Likewise.\n\t(vectorizable_slp_permutation): Likewise.\n\t* tree-vect-stmts.cc (perm_mask_for_reverse): Likewise.\n\t(vectorizable_bswap): Likewise.\n\t(scan_store_can_perm_p): Likewise.\n\t(vect_gen_perm_mask_checked): Likewise.", "tree": {"sha": "276aaf3fc98f7ef3454430e574fc66affe4265b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/276aaf3fc98f7ef3454430e574fc66affe4265b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/comments", "author": null, "committer": null, "parents": [{"sha": "2f4f7de787e5844515d27b2269fc472f95a9916a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f4f7de787e5844515d27b2269fc472f95a9916a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f4f7de787e5844515d27b2269fc472f95a9916a"}], "stats": {"total": 235, "additions": 150, "deletions": 85}, "files": [{"sha": "d4c575ce976fa71ede54d09b90567803e6bc80c1", "filename": "gcc/config/aarch64/aarch64.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Faarch64%2Faarch64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -24115,9 +24115,13 @@ aarch64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-aarch64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t\t  rtx op1, const vec_perm_indices &sel)\n+aarch64_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t\t  rtx target, rtx op0, rtx op1,\n+\t\t\t\t  const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n \n   /* Check whether the mask can be applied to a single vector.  */"}, {"sha": "70c2d50f0ccde6dc111c551433ea53e1974eb4be", "filename": "gcc/config/arm/arm.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Farm%2Farm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Farm%2Farm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -31813,9 +31813,13 @@ arm_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-arm_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n+arm_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t      rtx target, rtx op0, rtx op1,\n \t\t\t      const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n   int i, nelt, which;\n "}, {"sha": "6fc20d3f65991b81592d3df15eba84ec1b2b4b95", "filename": "gcc/config/gcn/gcn.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fgcn%2Fgcn.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -4161,10 +4161,13 @@ gcn_make_vec_perm_address (unsigned int *perm)\n    permutations.  */\n \n static bool\n-gcn_vectorize_vec_perm_const (machine_mode vmode, rtx dst,\n-\t\t\t      rtx src0, rtx src1,\n+gcn_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t      rtx dst, rtx src0, rtx src1,\n \t\t\t      const vec_perm_indices & sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   unsigned int nelt = GET_MODE_NUNITS (vmode);\n \n   gcc_assert (VECTOR_MODE_P (vmode));"}, {"sha": "5cd7b994aad2056bad612b8b1886d913b16075d8", "filename": "gcc/config/i386/i386-expand.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fi386-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -22069,9 +22069,13 @@ canonicalize_perm (struct expand_vec_perm_d *d)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n bool\n-ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t       rtx op1, const vec_perm_indices &sel)\n+ix86_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t       rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n   unsigned char perm[MAX_VECT_LEN];\n   unsigned int i, nelt, which;"}, {"sha": "6c650196c9c3b83e498549b20db77ce9edf65a1f", "filename": "gcc/config/i386/i386-expand.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fi386-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fi386-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.h?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -48,8 +48,9 @@ rtx gen_push (rtx arg);\n rtx gen_pop (rtx arg);\n rtx ix86_expand_builtin (tree exp, rtx target, rtx subtarget,\n \t\t\t machine_mode mode, int ignore);\n-bool ix86_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t\t    rtx op1, const vec_perm_indices &sel);\n+bool ix86_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t\t    rtx target, rtx op0, rtx op1,\n+\t\t\t\t    const vec_perm_indices &sel);\n bool ix86_notrack_prefixed_insn_p (rtx_insn *);\n machine_mode ix86_split_reduction (machine_mode mode);\n void ix86_expand_divmod_libfunc (rtx libfunc, machine_mode mode, rtx op0,"}, {"sha": "8b2602bfa79941ad36760ee24065ba59d6f5cae3", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -15842,8 +15842,9 @@\n \t      sel[7] = 15;\n \t    }\n \t  vec_perm_indices indices (sel, 2, 8);\n-\t  bool ok = targetm.vectorize.vec_perm_const (V8SImode, target,\n-\t\t\t\t\t\t      arg0, arg1, indices);\n+\t  bool ok = targetm.vectorize.vec_perm_const (V8SImode, V8SImode,\n+\t\t\t\t\t\t      target, arg0, arg1,\n+\t\t\t\t\t\t      indices);\n \t  gcc_assert (ok);\n \t  emit_move_insn (operands[0],\n \t\t\t  lowpart_subreg (V4DImode, target, V8SImode));\n@@ -24629,8 +24630,9 @@\n \t      sel[3] = 7;\n \t    }\n \t  vec_perm_indices indices (sel, arg0 != arg1 ? 2 : 1, 4);\n-\t  bool ok = targetm.vectorize.vec_perm_const (V4SImode, target,\n-\t\t\t\t\t\t      arg0, arg1, indices);\n+\t  bool ok = targetm.vectorize.vec_perm_const (V4SImode, V4SImode,\n+\t\t\t\t\t\t      target, arg0, arg1,\n+\t\t\t\t\t\t      indices);\n \t  gcc_assert (ok);\n \t  emit_move_insn (operands[0],\n \t\t\t  lowpart_subreg (V2DImode, target, V4SImode));"}, {"sha": "25e4a47e363a775446dc51a52335f41ed6bd11ab", "filename": "gcc/config/ia64/ia64.cc", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fia64%2Fia64.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fia64%2Fia64.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -332,8 +332,8 @@ static fixed_size_mode ia64_get_reg_raw_mode (int regno);\n static section * ia64_hpux_function_section (tree, enum node_frequency,\n \t\t\t\t\t     bool, bool);\n \n-static bool ia64_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n-\t\t\t\t\t   const vec_perm_indices &);\n+static bool ia64_vectorize_vec_perm_const (machine_mode, machine_mode, rtx,\n+\t\t\t\t\t   rtx, rtx, const vec_perm_indices &);\n \n static unsigned int ia64_hard_regno_nregs (unsigned int, machine_mode);\n static bool ia64_hard_regno_mode_ok (unsigned int, machine_mode);\n@@ -11751,9 +11751,13 @@ ia64_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-ia64_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t       rtx op1, const vec_perm_indices &sel)\n+ia64_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t       rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n   unsigned char perm[MAX_VECT_LEN];\n   unsigned int i, nelt, which;"}, {"sha": "5eb845960e1e64d57b3fa5d0cc229a3031aae364", "filename": "gcc/config/mips/mips.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fmips%2Fmips.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fmips%2Fmips.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -21790,9 +21790,13 @@ mips_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-mips_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t       rtx op1, const vec_perm_indices &sel)\n+mips_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t       rtx target, rtx op0, rtx op1,\n+\t\t\t       const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n   int i, nelt, which;\n   unsigned char orig_perm[MAX_VECT_LEN];"}, {"sha": "0af2085adc0e486fd5bab6fd36358dccc9a94260", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -23294,9 +23294,13 @@ rs6000_expand_vec_perm_const_1 (rtx target, rtx op0, rtx op1,\n /* Implement TARGET_VECTORIZE_VEC_PERM_CONST.  */\n \n static bool\n-rs6000_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t\t rtx op1, const vec_perm_indices &sel)\n+rs6000_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t\t rtx target, rtx op0, rtx op1,\n+\t\t\t\t const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   bool testing_p = !target;\n \n   /* AltiVec (and thus VSX) can handle arbitrary permutations.  */"}, {"sha": "444b1ec20d768d829ab19a41f114a91119335e00", "filename": "gcc/config/s390/s390.cc", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fs390%2Fs390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fs390%2Fs390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -17175,9 +17175,13 @@ vectorize_vec_perm_const_1 (const struct expand_vec_perm_d &d)\n    hook is supposed to emit the required INSNs.  */\n \n bool\n-s390_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0, rtx op1,\n+s390_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t       rtx target, rtx op0, rtx op1,\n \t\t\t       const vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   struct expand_vec_perm_d d;\n   unsigned int i, nelt;\n "}, {"sha": "c72c38e19994bb196085e39f5fc12224918e8c0f", "filename": "gcc/config/sparc/sparc.cc", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fsparc%2Fsparc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fconfig%2Fsparc%2Fsparc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -712,7 +712,8 @@ static bool sparc_modes_tieable_p (machine_mode, machine_mode);\n static bool sparc_can_change_mode_class (machine_mode, machine_mode,\n \t\t\t\t\t reg_class_t);\n static HOST_WIDE_INT sparc_constant_alignment (const_tree, HOST_WIDE_INT);\n-static bool sparc_vectorize_vec_perm_const (machine_mode, rtx, rtx, rtx,\n+static bool sparc_vectorize_vec_perm_const (machine_mode, machine_mode,\n+\t\t\t\t\t    rtx, rtx, rtx,\n \t\t\t\t\t    const vec_perm_indices &);\n static bool sparc_can_follow_jump (const rtx_insn *, const rtx_insn *);\n static HARD_REG_SET sparc_zero_call_used_regs (HARD_REG_SET);\n@@ -13035,9 +13036,13 @@ sparc_expand_vec_perm_bmask (machine_mode vmode, rtx sel)\n /* Implement TARGET_VEC_PERM_CONST.  */\n \n static bool\n-sparc_vectorize_vec_perm_const (machine_mode vmode, rtx target, rtx op0,\n-\t\t\t\trtx op1, const vec_perm_indices &sel)\n+sparc_vectorize_vec_perm_const (machine_mode vmode, machine_mode op_mode,\n+\t\t\t\trtx target, rtx op0, rtx op1,\n+\t\t\t\tconst vec_perm_indices &sel)\n {\n+  if (vmode != op_mode)\n+    return false;\n+\n   if (!TARGET_VIS2)\n     return false;\n "}, {"sha": "b0ea39884aa3ced5c0ccc1e792088aa66997ec3b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -6088,14 +6088,18 @@ for the given scalar type @var{type}.  @var{is_packed} is false if the scalar\n access using @var{type} is known to be naturally aligned.\n @end deftypefn\n \n-@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST (machine_mode @var{mode}, rtx @var{output}, rtx @var{in0}, rtx @var{in1}, const vec_perm_indices @var{&sel})\n+@deftypefn {Target Hook} bool TARGET_VECTORIZE_VEC_PERM_CONST (machine_mode @var{mode}, machine_mode @var{op_mode}, rtx @var{output}, rtx @var{in0}, rtx @var{in1}, const vec_perm_indices @var{&sel})\n This hook is used to test whether the target can permute up to two\n-vectors of mode @var{mode} using the permutation vector @code{sel}, and\n-also to emit such a permutation.  In the former case @var{in0}, @var{in1}\n-and @var{out} are all null.  In the latter case @var{in0} and @var{in1} are\n-the source vectors and @var{out} is the destination vector; all three are\n-operands of mode @var{mode}.  @var{in1} is the same as @var{in0} if\n-@var{sel} describes a permutation on one vector instead of two.\n+vectors of mode @var{op_mode} using the permutation vector @code{sel},\n+producing a vector of mode @var{mode}.  The hook is also used to emit such\n+a permutation.\n+\n+When the hook is being used to test whether the target supports a permutation,\n+@var{in0}, @var{in1}, and @var{out} are all null.  When the hook is being used\n+to emit a permutation, @var{in0} and @var{in1} are the source vectors of mode\n+@var{op_mode} and @var{out} is the destination vector of mode @var{mode}.\n+@var{in1} is the same as @var{in0} if @var{sel} describes a permutation on one\n+vector instead of two.\n \n Return true if the operation is possible, emitting instructions for it\n if rtxes are provided."}, {"sha": "183a0d4123fe36543b48e768ebed6a39356f2d1c", "filename": "gcc/match.pd", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -7642,6 +7642,8 @@ and,\n  (with\n   {\n     tree op0 = @0, op1 = @1, op2 = @2;\n+    machine_mode result_mode = TYPE_MODE (type);\n+    machine_mode op_mode = TYPE_MODE (TREE_TYPE (op0));\n \n     /* Build a vector of integers from the tree mask.  */\n     vec_perm_builder builder;\n@@ -7703,7 +7705,7 @@ and,\n \t   insert from a CONSTRUCTOR or constant and use a BIT_INSERT_EXPR\n \t   in that case.  But only if the vector mode is supported,\n \t   otherwise this is invalid GIMPLE.  */\n-        if (TYPE_MODE (type) != BLKmode\n+        if (op_mode != BLKmode\n \t    && (TREE_CODE (cop0) == VECTOR_CST\n \t\t|| TREE_CODE (cop0) == CONSTRUCTOR\n \t\t|| TREE_CODE (cop1) == VECTOR_CST\n@@ -7749,12 +7751,12 @@ and,\n \t       2-argument version.  */\n \t    tree oldop2 = op2;\n \t    if (sel.ninputs () == 2\n-\t       || can_vec_perm_const_p (TYPE_MODE (type), sel, false))\n+\t       || can_vec_perm_const_p (result_mode, op_mode, sel, false))\n \t      op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel);\n \t    else\n \t      {\n \t        vec_perm_indices sel2 (builder, 2, nelts);\n-\t        if (can_vec_perm_const_p (TYPE_MODE (type), sel2, false))\n+\t\tif (can_vec_perm_const_p (result_mode, op_mode, sel2, false))\n \t          op2 = vec_perm_indices_to_tree (TREE_TYPE (op2), sel2);\n \t        else\n \t          /* Not directly supported with either encoding,"}, {"sha": "809482b8092c3772908dd00a3656f64cf4ebb61b", "filename": "gcc/optabs-query.cc", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -407,18 +407,18 @@ can_vec_perm_var_p (machine_mode mode)\n }\n \n /* Return true if the target directly supports VEC_PERM_EXPRs on vectors\n-   of mode MODE using the selector SEL.  ALLOW_VARIABLE_P is true if it\n-   is acceptable to force the selector into a register and use a variable\n-   permute (if the target supports that).\n+   of mode OP_MODE and result vector of mode MODE using the selector SEL.\n+   ALLOW_VARIABLE_P is true if it is acceptable to force the selector into a\n+   register and use a variable permute (if the target supports that).\n \n    Note that additional permutations representing whole-vector shifts may\n    also be handled via the vec_shr or vec_shl optab, but only where the\n    second input vector is entirely constant zeroes; this case is not dealt\n    with here.  */\n \n bool\n-can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,\n-\t\t      bool allow_variable_p)\n+can_vec_perm_const_p (machine_mode mode, machine_mode op_mode,\n+\t\t      const vec_perm_indices &sel, bool allow_variable_p)\n {\n   /* If the target doesn't implement a vector mode for the vector type,\n      then no operations are supported.  */\n@@ -448,7 +448,7 @@ can_vec_perm_const_p (machine_mode mode, const vec_perm_indices &sel,\n \n   if (targetm.vectorize.vec_perm_const != NULL)\n     {\n-      if (targetm.vectorize.vec_perm_const (mode, NULL_RTX, NULL_RTX,\n+      if (targetm.vectorize.vec_perm_const (mode, op_mode, NULL_RTX, NULL_RTX,\n \t\t\t\t\t    NULL_RTX, sel))\n \treturn true;\n \n@@ -534,7 +534,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t\t\t    + (i & ~1)\n \t\t\t    + ((i & 1) ? nunits : 0));\n \t  vec_perm_indices indices (sel, 2, nunits);\n-\t  if (can_vec_perm_const_p (mode, indices))\n+\t  if (can_vec_perm_const_p (mode, mode, indices))\n \t    return 2;\n \t}\n     }\n@@ -550,7 +550,7 @@ can_mult_highpart_p (machine_mode mode, bool uns_p)\n \t  for (unsigned int i = 0; i < 3; ++i)\n \t    sel.quick_push (2 * i + (BYTES_BIG_ENDIAN ? 0 : 1));\n \t  vec_perm_indices indices (sel, 2, nunits);\n-\t  if (can_vec_perm_const_p (mode, indices))\n+\t  if (can_vec_perm_const_p (mode, mode, indices))\n \t    return 3;\n \t}\n     }"}, {"sha": "945d2a803b6063f4f99e59d7b54915e7db588870", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -178,8 +178,8 @@ bool can_conditionally_move_p (machine_mode mode);\n opt_machine_mode qimode_for_vec_perm (machine_mode);\n bool selector_fits_mode_p (machine_mode, const vec_perm_indices &);\n bool can_vec_perm_var_p (machine_mode);\n-bool can_vec_perm_const_p (machine_mode, const vec_perm_indices &,\n-\t\t\t   bool = true);\n+bool can_vec_perm_const_p (machine_mode, machine_mode,\n+\t\t\t   const vec_perm_indices &, bool = true);\n /* Find a widening optab even if it doesn't widen as much as we want.  */\n #define find_widening_optab_handler(A, B, C) \\\n   find_widening_optab_handler_and_mode (A, B, C, NULL)"}, {"sha": "c0a68471d2ddf08bc0e6a3fd592ebb9f05e516c1", "filename": "gcc/optabs.cc", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Foptabs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -6250,7 +6250,10 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n       if (single_arg_p)\n \tv1 = v0;\n \n-      if (targetm.vectorize.vec_perm_const (mode, target, v0, v1, indices))\n+      gcc_checking_assert (GET_MODE (v0) == GET_MODE (v1));\n+      machine_mode op_mode = GET_MODE (v0);\n+      if (targetm.vectorize.vec_perm_const (mode, op_mode, target, v0, v1,\n+\t\t\t\t\t    indices))\n \treturn target;\n     }\n \n@@ -6264,7 +6267,7 @@ expand_vec_perm_const (machine_mode mode, rtx v0, rtx v1,\n       v0_qi = gen_lowpart (qimode, v0);\n       v1_qi = gen_lowpart (qimode, v1);\n       if (targetm.vectorize.vec_perm_const != NULL\n-\t  && targetm.vectorize.vec_perm_const (qimode, target_qi, v0_qi,\n+\t  && targetm.vectorize.vec_perm_const (qimode, qimode, target_qi, v0_qi,\n \t\t\t\t\t       v1_qi, qimode_indices))\n \treturn gen_lowpart (mode, target_qi);\n     }"}, {"sha": "2a7fa68f83dd15dcdd2c332e8431e6142ec7d305", "filename": "gcc/target.def", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -1878,12 +1878,16 @@ access using @var{type} is known to be naturally aligned.\",\n DEFHOOK\n (vec_perm_const,\n  \"This hook is used to test whether the target can permute up to two\\n\\\n-vectors of mode @var{mode} using the permutation vector @code{sel}, and\\n\\\n-also to emit such a permutation.  In the former case @var{in0}, @var{in1}\\n\\\n-and @var{out} are all null.  In the latter case @var{in0} and @var{in1} are\\n\\\n-the source vectors and @var{out} is the destination vector; all three are\\n\\\n-operands of mode @var{mode}.  @var{in1} is the same as @var{in0} if\\n\\\n-@var{sel} describes a permutation on one vector instead of two.\\n\\\n+vectors of mode @var{op_mode} using the permutation vector @code{sel},\\n\\\n+producing a vector of mode @var{mode}.  The hook is also used to emit such\\n\\\n+a permutation.\\n\\\n+\\n\\\n+When the hook is being used to test whether the target supports a permutation,\\n\\\n+@var{in0}, @var{in1}, and @var{out} are all null.  When the hook is being used\\n\\\n+to emit a permutation, @var{in0} and @var{in1} are the source vectors of mode\\n\\\n+@var{op_mode} and @var{out} is the destination vector of mode @var{mode}.\\n\\\n+@var{in1} is the same as @var{in0} if @var{sel} describes a permutation on one\\n\\\n+vector instead of two.\\n\\\n \\n\\\n Return true if the operation is possible, emitting instructions for it\\n\\\n if rtxes are provided.\\n\\\n@@ -1894,7 +1898,7 @@ try the equivalent byte operation.  If that also fails, it will try forcing\\n\\\n the selector into a register and using the @var{vec_perm@var{mode}}\\n\\\n instruction pattern.  There is no need for the hook to handle these two\\n\\\n implementation approaches itself.\",\n- bool, (machine_mode mode, rtx output, rtx in0, rtx in1,\n+ bool, (machine_mode mode, machine_mode op_mode, rtx output, rtx in0, rtx in1,\n \tconst vec_perm_indices &sel),\n  NULL)\n "}, {"sha": "c387e84ad5965bc9b56d569eba7926711604df16", "filename": "gcc/tree-ssa-forwprop.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-ssa-forwprop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-ssa-forwprop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -2953,7 +2953,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t\t\t: (elts[0].second == 0 && elts[0].first == 0\n \t\t\t   ? 0 : refnelts) + i);\n       vec_perm_indices indices (sel, orig[1] ? 2 : 1, refnelts);\n-      if (!can_vec_perm_const_p (TYPE_MODE (perm_type), indices))\n+      machine_mode vmode = TYPE_MODE (perm_type);\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \treturn false;\n       mask_type\n \t= build_vector_type (build_nonstandard_integer_type (elem_size, 1),\n@@ -3002,7 +3003,8 @@ simplify_vector_constructor (gimple_stmt_iterator *gsi)\n \t    sel.quick_push (elts[i].first\n \t\t\t    ? elts[i].second + nelts : i);\n \t  vec_perm_indices indices (sel, 2, nelts);\n-\t  if (!can_vec_perm_const_p (TYPE_MODE (type), indices))\n+\t  machine_mode vmode = TYPE_MODE (type);\n+\t  if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t    return false;\n \t  mask_type\n \t    = build_vector_type (build_nonstandard_integer_type (elem_size, 1),"}, {"sha": "d20a10a1524164eef788ab4b88ba57c7a09c3387", "filename": "gcc/tree-vect-data-refs.cc", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-data-refs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-data-refs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -5347,7 +5347,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t    sel[3 * i + nelt2] = 0;\n \t\t}\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (!can_vec_perm_const_p (mode, indices))\n+\t      if (!can_vec_perm_const_p (mode, mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -5365,7 +5365,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t\t    sel[3 * i + nelt2] = nelt + j2++;\n \t\t}\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (!can_vec_perm_const_p (mode, indices))\n+\t      if (!can_vec_perm_const_p (mode, mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf (MSG_MISSED_OPTIMIZATION,\n@@ -5390,12 +5390,12 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \t      sel[i * 2 + 1] = i + nelt;\n \t    }\n \t  vec_perm_indices indices (sel, 2, nelt);\n-\t  if (can_vec_perm_const_p (mode, indices))\n+\t  if (can_vec_perm_const_p (mode, mode, indices))\n \t    {\n \t      for (i = 0; i < 6; i++)\n \t\tsel[i] += exact_div (nelt, 2);\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (can_vec_perm_const_p (mode, indices))\n+\t      if (can_vec_perm_const_p (mode, mode, indices))\n \t\treturn true;\n \t    }\n \t}\n@@ -5963,7 +5963,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\telse\n \t\t  sel[i] = 0;\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (!can_vec_perm_const_p (mode, indices))\n+\t      if (!can_vec_perm_const_p (mode, mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -5977,7 +5977,7 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t\telse\n \t\t  sel[i] = nelt + ((nelt + k) % 3) + 3 * (j++);\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (!can_vec_perm_const_p (mode, indices))\n+\t      if (!can_vec_perm_const_p (mode, mode, indices))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6000,12 +6000,12 @@ vect_grouped_load_supported (tree vectype, bool single_element_p,\n \t  for (i = 0; i < 3; i++)\n \t    sel[i] = i * 2;\n \t  vec_perm_indices indices (sel, 2, nelt);\n-\t  if (can_vec_perm_const_p (mode, indices))\n+\t  if (can_vec_perm_const_p (mode, mode, indices))\n \t    {\n \t      for (i = 0; i < 3; i++)\n \t\tsel[i] = i * 2 + 1;\n \t      indices.new_vector (sel, 2, nelt);\n-\t      if (can_vec_perm_const_p (mode, indices))\n+\t      if (can_vec_perm_const_p (mode, mode, indices))\n \t\treturn true;\n \t    }\n         }\n@@ -6327,6 +6327,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n   gimple *perm_stmt;\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  machine_mode vmode = TYPE_MODE (vectype);\n   unsigned int i;\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n \n@@ -6351,7 +6352,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2 + 1;\n       vec_perm_indices indices (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6366,7 +6367,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt / 2; ++i)\n \tsel[nelt / 2 + i] = i * 2;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6381,7 +6382,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt; i++)\n \tsel[i] = nelt / 2 + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6397,7 +6398,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = nelt / 2; i < nelt; i++)\n \tsel[i] = nelt + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6461,7 +6462,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n \t  k++;\n \t}\n       vec_perm_indices indices (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6476,7 +6477,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6490,7 +6491,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + 1 + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6504,7 +6505,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt; i++)\n \tsel[i] = (nelt / 3) + (nelt % 3) / 2 + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n@@ -6518,7 +6519,7 @@ vect_shift_permute_load_chain (vec_info *vinfo, vec<tree> dr_chain,\n       for (i = 0; i < nelt; i++)\n \tsel[i] = 2 * (nelt / 3) + (nelt % 3) / 2 + i;\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+      if (!can_vec_perm_const_p (vmode, vmode, indices))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "92aba5d4af61dd478ec3f1b94854e4ad84166774", "filename": "gcc/tree-vect-generic.cc", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -1527,7 +1527,10 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n       && tree_to_vec_perm_builder (&sel_int, mask))\n     {\n       vec_perm_indices indices (sel_int, 2, elements);\n-      if (can_vec_perm_const_p (TYPE_MODE (vect_type), indices))\n+      machine_mode vmode = TYPE_MODE (vect_type);\n+      tree lhs_type = TREE_TYPE (gimple_assign_lhs (stmt));\n+      machine_mode lhs_mode = TYPE_MODE (lhs_type);\n+      if (can_vec_perm_const_p (lhs_mode, vmode, indices))\n \t{\n \t  gimple_assign_set_rhs3 (stmt, mask);\n \t  update_stmt (stmt);"}, {"sha": "11dc6cbf576a352ac484b904aabe6f4cefb54188", "filename": "gcc/tree-vect-loop-manip.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-loop-manip.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-loop-manip.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -312,7 +312,8 @@ interleave_supported_p (vec_perm_indices *indices, tree vectype,\n       sel.quick_push (base + i + nelts);\n     }\n   indices->new_vector (sel, 2, nelts);\n-  return can_vec_perm_const_p (TYPE_MODE (vectype), *indices);\n+  return can_vec_perm_const_p (TYPE_MODE (vectype), TYPE_MODE (vectype),\n+\t\t\t       *indices);\n }\n \n /* Try to use permutes to define the masks in DEST_RGM using the masks"}, {"sha": "246347b9b08dd1a0d40cd0611c5d8934ef3b8358", "filename": "gcc/tree-vect-loop.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-loop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-loop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -4527,7 +4527,7 @@ have_whole_vector_shift (machine_mode mode)\n     {\n       calc_vec_perm_mask_for_shift (i, nelt, &sel);\n       indices.new_vector (sel, 2, nelt);\n-      if (!can_vec_perm_const_p (mode, indices, false))\n+      if (!can_vec_perm_const_p (mode, mode, indices, false))\n \treturn false;\n     }\n   return true;"}, {"sha": "0fad4dbd0945c6c176f3457b751e812f17fcd148", "filename": "gcc/tree-vect-patterns.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -2649,7 +2649,8 @@ vect_recog_rotate_pattern (vec_info *vinfo,\n \n \t  vec_perm_indices indices (elts, 1,\n \t\t\t\t    TYPE_VECTOR_SUBPARTS (char_vectype));\n-\t  if (can_vec_perm_const_p (TYPE_MODE (char_vectype), indices))\n+\t  machine_mode vmode = TYPE_MODE (char_vectype);\n+\t  if (can_vec_perm_const_p (vmode, vmode, indices))\n \t    {\n \t      /* vectorizable_bswap can handle the __builtin_bswap16 if we\n \t\t undo the argument promotion.  */"}, {"sha": "fe9361c338ea391775f48177e42eb3f09976ee27", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -420,8 +420,9 @@ can_duplicate_and_interleave_p (vec_info *vinfo, unsigned int count,\n \t\t}\n \t      vec_perm_indices indices1 (sel1, 2, nelts);\n \t      vec_perm_indices indices2 (sel2, 2, nelts);\n-\t      if (can_vec_perm_const_p (TYPE_MODE (vector_type), indices1)\n-\t\t  && can_vec_perm_const_p (TYPE_MODE (vector_type), indices2))\n+\t      machine_mode vmode = TYPE_MODE (vector_type);\n+\t      if (can_vec_perm_const_p (vmode, vmode, indices1)\n+\t\t  && can_vec_perm_const_p (vmode, vmode, indices2))\n \t\t{\n \t\t  if (nvectors_out)\n \t\t    *nvectors_out = nvectors;\n@@ -6762,7 +6763,7 @@ vect_transform_slp_perm_load (vec_info *vinfo,\n       if (index == count && !noop_p)\n \t{\n \t  indices.new_vector (mask, second_vec_index == -1 ? 1 : 2, nunits);\n-\t  if (!can_vec_perm_const_p (mode, indices))\n+\t  if (!can_vec_perm_const_p (mode, mode, indices))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n@@ -7122,8 +7123,9 @@ vectorizable_slp_permutation (vec_info *vinfo, gimple_stmt_iterator *gsi,\n \t{\n \t  indices.new_vector (mask, second_vec.first == -1U ? 1 : 2, nunits);\n \t  bool identity_p = indices.series_p (0, 1, 0, 1);\n+\t  machine_mode vmode = TYPE_MODE (vectype);\n \t  if (!identity_p\n-\t      && !can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+\t      && !can_vec_perm_const_p (vmode, vmode, indices))\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{"}, {"sha": "346d8ce280437e00bfeb19a4b4adc59eb96207f9", "filename": "gcc/tree-vect-stmts.cc", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-stmts.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e/gcc%2Ftree-vect-stmts.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.cc?ref=ae8decf1d2b8329af59592b4fa78ee8dfab3ba5e", "patch": "@@ -2016,7 +2016,8 @@ perm_mask_for_reverse (tree vectype)\n     sel.quick_push (nunits - 1 - i);\n \n   vec_perm_indices indices (sel, 1, nunits);\n-  if (!can_vec_perm_const_p (TYPE_MODE (vectype), indices))\n+  if (!can_vec_perm_const_p (TYPE_MODE (vectype), TYPE_MODE (vectype),\n+\t\t\t     indices))\n     return NULL_TREE;\n   return vect_gen_perm_mask_checked (vectype, indices);\n }\n@@ -3168,7 +3169,8 @@ vectorizable_bswap (vec_info *vinfo,\n       elts.quick_push ((i + 1) * word_bytes - j - 1);\n \n   vec_perm_indices indices (elts, 1, num_bytes);\n-  if (!can_vec_perm_const_p (TYPE_MODE (char_vectype), indices))\n+  machine_mode vmode = TYPE_MODE (char_vectype);\n+  if (!can_vec_perm_const_p (vmode, vmode, indices))\n     return false;\n \n   if (! vec_stmt)\n@@ -6712,7 +6714,7 @@ scan_store_can_perm_p (tree vectype, tree init,\n \t    sel[j] = nunits + k;\n \t}\n       vec_perm_indices indices (sel, i == units_log2 ? 1 : 2, nunits);\n-      if (!can_vec_perm_const_p (vec_mode, indices))\n+      if (!can_vec_perm_const_p (vec_mode, vec_mode, indices))\n \t{\n \t  if (i == units_log2)\n \t    return -1;\n@@ -8582,7 +8584,8 @@ vect_gen_perm_mask_any (tree vectype, const vec_perm_indices &sel)\n tree\n vect_gen_perm_mask_checked (tree vectype, const vec_perm_indices &sel)\n {\n-  gcc_assert (can_vec_perm_const_p (TYPE_MODE (vectype), sel));\n+  machine_mode vmode = TYPE_MODE (vectype);\n+  gcc_assert (can_vec_perm_const_p (vmode, vmode, sel));\n   return vect_gen_perm_mask_any (vectype, sel);\n }\n "}]}