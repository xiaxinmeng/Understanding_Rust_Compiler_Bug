{"sha": "2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEyM2E5YTUwZmIzNTEwOWFmNmMyYmEzYmNmZDcxYTFkNTQzMjk1NA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:18:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:18:29Z"}, "message": "[58/77] Use scalar_int_mode in a try_combine optimisation\n\nThis patch uses scalar_int_modes for:\n\n  /* If I2 is setting a pseudo to a constant and I3 is setting some\n     sub-part of it to another constant, merge them by making a new\n     constant.  */\n\nThis was already implicit, but the danger with checking only\nCONST_SCALAR_INT_P is that it can include CC values too.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* combine.c (try_combine): Use is_a <scalar_int_mode> when\n\ttrying to combine a full-register integer set with a subreg\n\tinteger set.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251510", "tree": {"sha": "97a0311ec16d63c69c73d255611afe6da1970e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97a0311ec16d63c69c73d255611afe6da1970e0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2123a9a50fb35109af6c2ba3bcfd71a1d5432954/comments", "author": null, "committer": null, "parents": [{"sha": "d93d3864ca8a8b50de81e084136574021463d228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d93d3864ca8a8b50de81e084136574021463d228", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d93d3864ca8a8b50de81e084136574021463d228"}], "stats": {"total": 43, "additions": 29, "deletions": 14}, "files": [{"sha": "3fb54e6c82fba79e5d670d15e422f9fb2b7ef09b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2123a9a50fb35109af6c2ba3bcfd71a1d5432954/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2123a9a50fb35109af6c2ba3bcfd71a1d5432954/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "patch": "@@ -1,3 +1,11 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* combine.c (try_combine): Use is_a <scalar_int_mode> when\n+\ttrying to combine a full-register integer set with a subreg\n+\tinteger set.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "022a5b5f15c4c77949961bfbe880a6507c176c2f", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2123a9a50fb35109af6c2ba3bcfd71a1d5432954/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2123a9a50fb35109af6c2ba3bcfd71a1d5432954/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=2123a9a50fb35109af6c2ba3bcfd71a1d5432954", "patch": "@@ -2645,6 +2645,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   rtx other_pat = 0;\n   rtx new_other_notes;\n   int i;\n+  scalar_int_mode dest_mode, temp_mode;\n \n   /* Immediately return if any of I0,I1,I2 are the same insn (I3 can\n      never be).  */\n@@ -2847,33 +2848,40 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      constant.  */\n   if (i1 == 0\n       && (temp_expr = single_set (i2)) != 0\n+      && is_a <scalar_int_mode> (GET_MODE (SET_DEST (temp_expr)), &temp_mode)\n       && CONST_SCALAR_INT_P (SET_SRC (temp_expr))\n       && GET_CODE (PATTERN (i3)) == SET\n       && CONST_SCALAR_INT_P (SET_SRC (PATTERN (i3)))\n       && reg_subword_p (SET_DEST (PATTERN (i3)), SET_DEST (temp_expr)))\n     {\n       rtx dest = SET_DEST (PATTERN (i3));\n+      rtx temp_dest = SET_DEST (temp_expr);\n       int offset = -1;\n       int width = 0;\n-      \n+\n       if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n \t  if (CONST_INT_P (XEXP (dest, 1))\n-\t      && CONST_INT_P (XEXP (dest, 2)))\n+\t      && CONST_INT_P (XEXP (dest, 2))\n+\t      && is_a <scalar_int_mode> (GET_MODE (XEXP (dest, 0)),\n+\t\t\t\t\t &dest_mode))\n \t    {\n \t      width = INTVAL (XEXP (dest, 1));\n \t      offset = INTVAL (XEXP (dest, 2));\n \t      dest = XEXP (dest, 0);\n \t      if (BITS_BIG_ENDIAN)\n-\t\toffset = GET_MODE_PRECISION (GET_MODE (dest)) - width - offset;\n+\t\toffset = GET_MODE_PRECISION (dest_mode) - width - offset;\n \t    }\n \t}\n       else\n \t{\n \t  if (GET_CODE (dest) == STRICT_LOW_PART)\n \t    dest = XEXP (dest, 0);\n-\t  width = GET_MODE_PRECISION (GET_MODE (dest));\n-\t  offset = 0;\n+\t  if (is_a <scalar_int_mode> (GET_MODE (dest), &dest_mode))\n+\t    {\n+\t      width = GET_MODE_PRECISION (dest_mode);\n+\t      offset = 0;\n+\t    }\n \t}\n \n       if (offset >= 0)\n@@ -2882,9 +2890,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  if (subreg_lowpart_p (dest))\n \t    ;\n \t  /* Handle the case where inner is twice the size of outer.  */\n-\t  else if (GET_MODE_PRECISION (GET_MODE (SET_DEST (temp_expr)))\n-\t\t   == 2 * GET_MODE_PRECISION (GET_MODE (dest)))\n-\t    offset += GET_MODE_PRECISION (GET_MODE (dest));\n+\t  else if (GET_MODE_PRECISION (temp_mode)\n+\t\t   == 2 * GET_MODE_PRECISION (dest_mode))\n+\t    offset += GET_MODE_PRECISION (dest_mode);\n \t  /* Otherwise give up for now.  */\n \t  else\n \t    offset = -1;\n@@ -2895,23 +2903,22 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t  rtx inner = SET_SRC (PATTERN (i3));\n \t  rtx outer = SET_SRC (temp_expr);\n \n-\t  wide_int o\n-\t    = wi::insert (rtx_mode_t (outer, GET_MODE (SET_DEST (temp_expr))),\n-\t\t\t  rtx_mode_t (inner, GET_MODE (dest)),\n-\t\t\t  offset, width);\n+\t  wide_int o = wi::insert (rtx_mode_t (outer, temp_mode),\n+\t\t\t\t   rtx_mode_t (inner, dest_mode),\n+\t\t\t\t   offset, width);\n \n \t  combine_merges++;\n \t  subst_insn = i3;\n \t  subst_low_luid = DF_INSN_LUID (i2);\n \t  added_sets_2 = added_sets_1 = added_sets_0 = 0;\n-\t  i2dest = SET_DEST (temp_expr);\n+\t  i2dest = temp_dest;\n \t  i2dest_killed = dead_or_set_p (i2, i2dest);\n \n \t  /* Replace the source in I2 with the new constant and make the\n \t     resulting insn the new pattern for I3.  Then skip to where we\n \t     validate the pattern.  Everything was set up above.  */\n \t  SUBST (SET_SRC (temp_expr),\n-\t\t immed_wide_int_const (o, GET_MODE (SET_DEST (temp_expr))));\n+\t\t immed_wide_int_const (o, temp_mode));\n \n \t  newpat = PATTERN (i2);\n "}]}