{"sha": "5201931ea147af4f55fe47ed879fbef5b3461ef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTIwMTkzMWVhMTQ3YWY0ZjU1ZmU0N2VkODc5ZmJlZjViMzQ2MWVmMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2004-08-07T16:11:10Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2004-08-07T16:11:10Z"}, "message": "gimplify.c (gimplify_call_expr): Make return in memory explicit.\n\n        * gimplify.c (gimplify_call_expr): Make return in memory explicit.\n        (gimplify_modify_expr_rhs): Likewise.\n        * c-common.c (c_warn_unused_result): Check TREE_USED before\n        warning about a CALL_EXPR with an unused value.\n\nFrom-SVN: r85671", "tree": {"sha": "ed52c7e668a41a71abd14d2bc80216a67ea6d0f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed52c7e668a41a71abd14d2bc80216a67ea6d0f5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5201931ea147af4f55fe47ed879fbef5b3461ef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5201931ea147af4f55fe47ed879fbef5b3461ef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5201931ea147af4f55fe47ed879fbef5b3461ef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5201931ea147af4f55fe47ed879fbef5b3461ef0/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8844a2f541582d58075af46362d57a1f75fc6eff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8844a2f541582d58075af46362d57a1f75fc6eff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8844a2f541582d58075af46362d57a1f75fc6eff"}], "stats": {"total": 79, "additions": 77, "deletions": 2}, "files": [{"sha": "80dec91322456ea9522482a7972028b2780f4d92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5201931ea147af4f55fe47ed879fbef5b3461ef0", "patch": "@@ -1,3 +1,10 @@\n+2004-08-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* gimplify.c (gimplify_call_expr): Make return in memory explicit.\n+\t(gimplify_modify_expr_rhs): Likewise.\n+\t* c-common.c (c_warn_unused_result): Check TREE_USED before\n+\twarning about a CALL_EXPR with an unused value.\n+\n 2004-08-06  Mark Mitchell  <mark@codesourcery.com>\n \n \t* config/arm/symbian.h (CC1_SPEC): Avoid passing duplicate options"}, {"sha": "868088f0e1c3dce7f7e976e4989545578a223f06", "filename": "gcc/c-common.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=5201931ea147af4f55fe47ed879fbef5b3461ef0", "patch": "@@ -5378,6 +5378,9 @@ c_warn_unused_result (tree *top_p)\n       break;\n \n     case CALL_EXPR:\n+      if (TREE_USED (t))\n+\tbreak;\n+\n       /* This is a naked call, as opposed to a CALL_EXPR nested inside\n \t a MODIFY_EXPR.  All calls whose value is ignored should be\n \t represented like this.  Look for the attribute.  */"}, {"sha": "cd2a4a0beecc6dd346d5ee7dccbd0f904b864db5", "filename": "gcc/gimplify.c", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5201931ea147af4f55fe47ed879fbef5b3461ef0/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=5201931ea147af4f55fe47ed879fbef5b3461ef0", "patch": "@@ -1805,6 +1805,7 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   tree decl;\n   tree arglist;\n   enum gimplify_status ret;\n+  tree slot;\n \n #if defined ENABLE_CHECKING\n   if (TREE_CODE (*expr_p) != CALL_EXPR)\n@@ -1867,6 +1868,19 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n   ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, NULL,\n \t\t       is_gimple_call_addr, fb_rvalue);\n \n+  /* Make the return slot explicit if it isn't already.  */\n+  if (aggregate_value_p (*expr_p, decl)\n+      && !CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p))\n+    {\n+      slot = create_tmp_var (TREE_TYPE (*expr_p), NULL);\n+      arglist = build_fold_addr_expr (slot);\n+      arglist = tree_cons (NULL_TREE, arglist, TREE_OPERAND (*expr_p, 1));\n+      TREE_OPERAND (*expr_p, 1) = arglist;\n+      CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p) = 1;\n+    }\n+  else\n+    slot = NULL_TREE;\n+\n   if (PUSH_ARGS_REVERSED)\n     TREE_OPERAND (*expr_p, 1) = nreverse (TREE_OPERAND (*expr_p, 1));\n   for (arglist = TREE_OPERAND (*expr_p, 1); arglist;\n@@ -1904,6 +1918,22 @@ gimplify_call_expr (tree *expr_p, tree *pre_p, bool want_value)\n       && (call_expr_flags (*expr_p) & (ECF_CONST | ECF_PURE)))\n     TREE_SIDE_EFFECTS (*expr_p) = 0;\n \n+  /* If we have a return slot, use it in the containing expression.  */\n+  if (want_value && CALL_EXPR_HAS_RETURN_SLOT_ADDR (*expr_p))\n+    {\n+      /* Don't warn about an unused return value.  */\n+      TREE_USED (*expr_p) = 1;\n+\n+      if (slot == NULL_TREE)\n+\t{\n+\t  slot = TREE_OPERAND (*expr_p, 1);\n+\t  slot = TREE_VALUE (slot);\n+\t  slot = build_fold_indirect_ref (slot);\n+\t}\n+      append_to_statement_list (*expr_p, pre_p);\n+      *expr_p = slot;\n+    }\n+\n   return ret;\n }\n \n@@ -2706,6 +2736,39 @@ gimplify_modify_expr_rhs (tree *expr_p, tree *from_p, tree *to_p, tree *pre_p,\n \t  ret = GS_UNHANDLED;\n \tbreak;\n \n+      case CALL_EXPR:\n+\t/* Transform 'a = f();' to 'f(&a), a' if f returns in memory.  */\n+\tif (aggregate_value_p (*from_p, *from_p))\n+\t  {\n+\t    tree arg;\n+\t    if (CALL_EXPR_HAS_RETURN_SLOT_ADDR (*from_p))\n+\t      abort ();\n+\n+\t    ret = gimplify_expr (to_p, pre_p, post_p, is_gimple_lvalue,\n+\t\t\t\t fb_lvalue);\n+\t    if (ret == GS_ERROR)\n+\t      return ret;\n+\n+\t    arg = build_fold_addr_expr (*to_p);\n+\t    arg = tree_cons (NULL_TREE, arg, TREE_OPERAND (*from_p, 1));\n+\t    TREE_OPERAND (*from_p, 1) = arg;\n+\t    CALL_EXPR_HAS_RETURN_SLOT_ADDR (*from_p) = 1;\n+\t    /* Don't warn about an unused return value.  */\n+\t    TREE_USED (*from_p) = 1;\n+\n+\t    if (want_value)\n+\t      {\n+\t\tgimplify_and_add (*from_p, pre_p);\n+\t\t*expr_p = *to_p;\n+\t      }\n+\t    else\n+\t      *expr_p = *from_p;\n+\t    return GS_OK;\n+\t  }\n+\telse\n+\t  ret = GS_UNHANDLED;\n+\tbreak;\n+\n       default:\n \tret = GS_UNHANDLED;\n \tbreak;\n@@ -3021,12 +3084,14 @@ gimplify_addr_expr (tree *expr_p, tree *pre_p, tree *post_p)\n \n     default:\n       /* We use fb_either here because the C frontend sometimes takes\n-\t the address of a call that returns a struct.  */\n+\t the address of a call that returns a struct; see\n+\t gcc.dg/c99-array-lval-1.c.  The gimplifier will correctly make\n+\t the implied temporary explicit.  */\n       ret = gimplify_expr (&TREE_OPERAND (expr, 0), pre_p, post_p,\n \t\t\t   is_gimple_addressable, fb_either);\n       if (ret != GS_ERROR)\n \t{\n-\t  /* The above may have made an INDIRECT ref (e.g, Ada's NULL_EXPR),\n+\t  /* The above may have made an INDIRECT_REF (e.g, Ada's NULL_EXPR),\n \t     so check for it here.  It's not worth checking for the other\n \t     cases above.  */\n \t  if (TREE_CODE (TREE_OPERAND (expr, 0)) == INDIRECT_REF)"}]}