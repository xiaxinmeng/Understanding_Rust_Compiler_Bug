{"sha": "eb59b8de04973d3d08bf8df731bbd3da38af918c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI1OWI4ZGUwNDk3M2QzZDA4YmY4ZGY3MzFiYmQzZGEzOGFmOTE4Yw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-10-29T08:41:10Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-10-29T08:41:10Z"}, "message": "bitmap.h (bitmap_empty_p): New.\n\n\t* bitmap.h (bitmap_empty_p): New.\n\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into,\n\tbitmap_ior_compl, bitmap_xor, bitmap_xor_into): New bitmap\n\toperation macros.\n\t(bitmap_ior_and_compl): Rename to ...\n\t(bitmap_ior_and_compl_into): ... here.\n\t* bitmap.c (bitmap_equal_p): Use bitmap_xor.\n\t(bitmap_ior_and_compl): Rename to ...\n\t(bitmap_ior_and_compl_into): ... here. Adjust. Return changed\n\tflag.\n\t(bitmap_union_of_diff): Use renamed bitmap functions.\n\t* basic-block.h (AND_REG_SET, AND_COMPL_REG_SET, IOR_REG_SET,\n\tXOR_REG_SET, IOR_AND_COMPL_REG_SET): Likewise.\n\t* cfgrtl.c (safe_insert_insn_on_edge): Likewise.\n\t* df.c (df_bb_rd_local_compute)\n\t* flow.c (calculate_global_regs_live,\n\tinit_propagate_block_info): Likewise.\n\t* ifcvt.c (find_if_case_1, find_if_case_2,\n\tdead_or_predicable): Likewise.\n\t* ra-build.c (union_web_part_roots, livethrough_conflicts_bb,\n\treset_conflicts, conflicts_between_webs): Likewise.\n\t* ra-rewrite.c (reloads_to_loads, rewrite_program2,\n\tdetect_web_parts_to_rebuild): Likewise.\n\t* sched-ebb.c (compute_jump_reg_dependencies): Likewise.\n\t* tree-int-ssa.c (insert_phi_nodes_for, rewrite_into_ssa): Likewise.\n\t* tree-sra.c (decide_instantiations): Likewise.\n\t* tree-ssa-alias.c (create_name_tags,\n\tmerge_pointed_to_info): Likewise.\n\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Likewise.\n\t* tree-ssa-loop-im.c (move_computations): Likewise.\n\t* tree-ssa-operands.c (get_call_expr_operands): Likewise.\n\t* tree-ssa-pre.c (fini_pre): Likewise.\n\t* tree-ssa.c (verify_flow_sensitive_alias_info): Likewise.\n\t* tree-ssanames.c (any_marked_for_rewrite_p): Likewise.\n\t* tree-vectorizer.c (vectorize_loops): Likewise.\n\nFrom-SVN: r89827", "tree": {"sha": "5ae5a28c250887e5c6bbcd142331bef3dd27af7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ae5a28c250887e5c6bbcd142331bef3dd27af7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb59b8de04973d3d08bf8df731bbd3da38af918c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb59b8de04973d3d08bf8df731bbd3da38af918c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb59b8de04973d3d08bf8df731bbd3da38af918c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb59b8de04973d3d08bf8df731bbd3da38af918c/comments", "author": null, "committer": null, "parents": [{"sha": "ec7e5618bc8b9d720803a3857eb787983b089318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec7e5618bc8b9d720803a3857eb787983b089318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec7e5618bc8b9d720803a3857eb787983b089318"}], "stats": {"total": 219, "additions": 124, "deletions": 95}, "files": [{"sha": "c1e96f3bd571c8c04dc6ed601a96187dc000e7da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1,3 +1,42 @@\n+2004-10-28  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* bitmap.h (bitmap_empty_p): New.\n+\t(bitmap_and, bitmap_and_into, bitmap_and_compl,\n+\tbitmap_and_compl_into, bitmap_ior, bitmap_ior_into,\n+\tbitmap_ior_compl, bitmap_xor, bitmap_xor_into): New bitmap\n+\toperation macros.\n+\t(bitmap_ior_and_compl): Rename to ...\n+\t(bitmap_ior_and_compl_into): ... here.\n+\t* bitmap.c (bitmap_equal_p): Use bitmap_xor.\n+\t(bitmap_ior_and_compl): Rename to ...\n+\t(bitmap_ior_and_compl_into): ... here. Adjust. Return changed\n+\tflag.\n+\t(bitmap_union_of_diff): Use renamed bitmap functions.\n+\t* basic-block.h (AND_REG_SET, AND_COMPL_REG_SET, IOR_REG_SET,\n+\tXOR_REG_SET, IOR_AND_COMPL_REG_SET): Likewise.\n+\t* cfgrtl.c (safe_insert_insn_on_edge): Likewise.\n+\t* df.c (df_bb_rd_local_compute)\n+\t* flow.c (calculate_global_regs_live,\n+\tinit_propagate_block_info): Likewise.\n+\t* ifcvt.c (find_if_case_1, find_if_case_2,\n+\tdead_or_predicable): Likewise.\n+\t* ra-build.c (union_web_part_roots, livethrough_conflicts_bb,\n+\treset_conflicts, conflicts_between_webs): Likewise.\n+\t* ra-rewrite.c (reloads_to_loads, rewrite_program2,\n+\tdetect_web_parts_to_rebuild): Likewise.\n+\t* sched-ebb.c (compute_jump_reg_dependencies): Likewise.\n+\t* tree-int-ssa.c (insert_phi_nodes_for, rewrite_into_ssa): Likewise.\n+\t* tree-sra.c (decide_instantiations): Likewise.\n+\t* tree-ssa-alias.c (create_name_tags,\n+\tmerge_pointed_to_info): Likewise.\n+\t* tree-ssa-dom.c (tree_ssa_dominator_optimize): Likewise.\n+\t* tree-ssa-loop-im.c (move_computations): Likewise.\n+\t* tree-ssa-operands.c (get_call_expr_operands): Likewise.\n+\t* tree-ssa-pre.c (fini_pre): Likewise.\n+\t* tree-ssa.c (verify_flow_sensitive_alias_info): Likewise.\n+\t* tree-ssanames.c (any_marked_for_rewrite_p): Likewise.\n+\t* tree-vectorizer.c (vectorize_loops): Likewise.\n+\n 2004-10-29  Nick Clifton  <nickc@redhat.com>\n \n \tconfig/mn10300/mn10300.h (CONDITIONAL_REGISTER_USAGE): When"}, {"sha": "4775956b28875ade0b79b40930d6d5f638bf3193", "filename": "gcc/basic-block.h", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -50,21 +50,20 @@ typedef bitmap regset;\n #define REG_SET_EQUAL_P(A, B) bitmap_equal_p (A, B)\n \n /* `and' a register set with a second register set.  */\n-#define AND_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_AND)\n+#define AND_REG_SET(TO, FROM) bitmap_and_into (TO, FROM)\n \n /* `and' the complement of a register set with a register set.  */\n-#define AND_COMPL_REG_SET(TO, FROM) \\\n-  bitmap_operation (TO, TO, FROM, BITMAP_AND_COMPL)\n+#define AND_COMPL_REG_SET(TO, FROM) bitmap_and_compl_into (TO, FROM)\n \n /* Inclusive or a register set with a second register set.  */\n-#define IOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_IOR)\n+#define IOR_REG_SET(TO, FROM) bitmap_ior_into (TO, FROM)\n \n /* Exclusive or a register set with a second register set.  */\n-#define XOR_REG_SET(TO, FROM) bitmap_operation (TO, TO, FROM, BITMAP_XOR)\n+#define XOR_REG_SET(TO, FROM) bitmap_xor_into (TO, FROM)\n \n /* Or into TO the register set FROM1 `and'ed with the complement of FROM2.  */\n #define IOR_AND_COMPL_REG_SET(TO, FROM1, FROM2) \\\n-  bitmap_ior_and_compl (TO, FROM1, FROM2)\n+  bitmap_ior_and_compl_into (TO, FROM1, FROM2)\n \n /* Clear a single register in a register set.  */\n #define CLEAR_REGNO_REG_SET(HEAD, REG) bitmap_clear_bit (HEAD, REG)"}, {"sha": "0a50d419ca424c903b7a83aae76e178ac1f7b784", "filename": "gcc/bitmap.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -672,7 +672,7 @@ bitmap_equal_p (bitmap a, bitmap b)\n   int ret;\n \n   memset (&c, 0, sizeof (c));\n-  ret = ! bitmap_operation (&c, a, b, BITMAP_XOR);\n+  ret = ! bitmap_xor (&c, a, b);\n   bitmap_clear (&c);\n \n   return ret;\n@@ -681,17 +681,19 @@ bitmap_equal_p (bitmap a, bitmap b)\n /* Or into bitmap TO bitmap FROM1 and'ed with the complement of\n    bitmap FROM2.  */\n \n-void\n-bitmap_ior_and_compl (bitmap to, bitmap from1, bitmap from2)\n+int\n+bitmap_ior_and_compl_into (bitmap to, bitmap from1, bitmap from2)\n {\n   bitmap_head tmp;\n+  int changed;\n \n   tmp.first = tmp.current = 0;\n   tmp.using_obstack = 0;\n \n-  bitmap_operation (&tmp, from1, from2, BITMAP_AND_COMPL);\n-  bitmap_operation (to, to, &tmp, BITMAP_IOR);\n+  bitmap_and_compl (&tmp, from1, from2);\n+  changed = bitmap_ior_into (to, &tmp);\n   bitmap_clear (&tmp);\n+  return changed;\n }\n \n int\n@@ -703,8 +705,8 @@ bitmap_union_of_diff (bitmap dst, bitmap a, bitmap b, bitmap c)\n   tmp.first = tmp.current = 0;\n   tmp.using_obstack = 0;\n \n-  bitmap_operation (&tmp, b, c, BITMAP_AND_COMPL);\n-  changed = bitmap_operation (dst, &tmp, a, BITMAP_IOR);\n+  bitmap_and_compl (&tmp, b, c);\n+  changed = bitmap_ior (dst, &tmp, a);\n   bitmap_clear (&tmp);\n \n   return changed;"}, {"sha": "73d5a58fe3ec1279dc27121ec4f5768be59a6f21", "filename": "gcc/bitmap.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -87,12 +87,24 @@ extern void bitmap_copy (bitmap, bitmap);\n /* True if two bitmaps are identical.  */\n extern int bitmap_equal_p (bitmap, bitmap);\n \n+#define bitmap_empty_p(MAP) (!(MAP)->first)\n+\n /* Perform an operation on two bitmaps, yielding a third.  */\n extern int bitmap_operation (bitmap, bitmap, bitmap, enum bitmap_bits);\n \n+#define bitmap_and(DST,A,B) bitmap_operation (DST,A,B,BITMAP_AND)\n+#define bitmap_and_into(DST_SRC,B) bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_AND)\n+#define bitmap_and_compl(DST,A,B) bitmap_operation (DST,A,B,BITMAP_AND_COMPL)\n+#define bitmap_and_compl_into(DST_SRC,B) bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_AND_COMPL)\n+#define bitmap_ior(DST,A,B) bitmap_operation (DST,A,B,BITMAP_IOR)\n+#define bitmap_ior_into(DST_SRC,B) bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_IOR)\n+#define bitmap_ior_compl(DST,A,B) bitmap_operation (DST,A,B,BITMAP_IOR_COMPL)\n+#define bitmap_xor(DST,A,B) bitmap_operation (DST,A,B,BITMAP_XOR)\n+#define bitmap_xor_into(DST_SRC,B) bitmap_operation (DST_SRC,DST_SRC,B,BITMAP_XOR)\n+\n /* `or' into one bitmap the `and' of a second bitmap witih the complement\n-   of a third.  */\n-extern void bitmap_ior_and_compl (bitmap, bitmap, bitmap);\n+   of a third. Return nonzero if the bitmap changes. */\n+extern int bitmap_ior_and_compl_into (bitmap, bitmap, bitmap);\n \n /* Clear a single register in a register set.  */\n extern void bitmap_clear_bit (bitmap, int);"}, {"sha": "2db93a857437148065f30085d602249f3c819d81", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1476,8 +1476,7 @@ safe_insert_insn_on_edge (rtx insn, edge e)\n   for (x = insn; x; x = NEXT_INSN (x))\n     if (INSN_P (x))\n       note_stores (PATTERN (x), mark_killed_regs, killed);\n-  bitmap_operation (killed, killed, e->dest->global_live_at_start,\n-\t\t    BITMAP_AND);\n+  bitmap_and_into (killed, e->dest->global_live_at_start);\n \n   EXECUTE_IF_SET_IN_REG_SET (killed, 0, regno, rsi)\n     {"}, {"sha": "818d92e89a4773544375d3795039f8ebe6cfb5d0", "filename": "gcc/df.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1657,8 +1657,7 @@ df_bb_rd_local_compute (struct df *df, basic_block bb, bitmap call_killed_defs)\n \n       if (CALL_P (insn) && (df->flags & DF_HARD_REGS))\n \t{\n-\t  bitmap_operation (bb_info->rd_kill, bb_info->rd_kill,\n-\t\t\t    call_killed_defs, BITMAP_IOR);\n+\t  bitmap_ior_into (bb_info->rd_kill, call_killed_defs);\n \t  call_seen = 1;\n \t}\n     }"}, {"sha": "6e599c81524c3d1d4c0f7ddf70a155456a16f8aa", "filename": "gcc/flow.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1114,11 +1114,9 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t    /* ??? Abnormal call edges ignored for the moment, as this gets\n \t       confused by sibling call edges, which crashes reg-stack.  */\n \t    if (e->flags & EDGE_EH)\n-\t      {\n-\t\tbitmap_operation (tmp, sb->global_live_at_start,\n-\t\t\t\t  invalidated_by_call, BITMAP_AND_COMPL);\n-\t\tIOR_REG_SET (new_live_at_end, tmp);\n-\t      }\n+\t      bitmap_ior_and_compl_into (new_live_at_end,\n+\t\t\t\t\t sb->global_live_at_start,\n+\t\t\t\t\t invalidated_by_call);\n \t    else\n \t      IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n \n@@ -1188,8 +1186,8 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t     precalculated local_live, however with PROP_SCAN_DEAD_CODE\n \t     local_live is really dependent on live_at_end.  */\n \t  CLEAR_REG_SET (tmp);\n-\t  rescan = bitmap_operation (tmp, bb->global_live_at_end,\n-\t\t\t\t     new_live_at_end, BITMAP_AND_COMPL);\n+\t  rescan = bitmap_and_compl (tmp, bb->global_live_at_end,\n+\t\t\t\t     new_live_at_end);\n \n \t  if (! rescan)\n \t    {\n@@ -1201,25 +1199,24 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t\t block.  We can miss changes in those sets if we only\n \t\t compare the new live_at_end against the previous one.  */\n \t      CLEAR_REG_SET (tmp);\n-\t      rescan = bitmap_operation (tmp, new_live_at_end,\n-\t\t\t\t\t bb->cond_local_set, BITMAP_AND);\n+\t      rescan = bitmap_and (tmp, new_live_at_end,\n+\t\t\t\t   bb->cond_local_set);\n \t    }\n \n \t  if (! rescan)\n \t    {\n \t      /* Find the set of changed bits.  Take this opportunity\n \t\t to notice that this set is empty and early out.  */\n \t      CLEAR_REG_SET (tmp);\n-\t      changed = bitmap_operation (tmp, bb->global_live_at_end,\n-\t\t\t\t\t  new_live_at_end, BITMAP_XOR);\n+\t      changed = bitmap_xor (tmp, bb->global_live_at_end,\n+\t\t\t\t\t  new_live_at_end);\n \t      if (! changed)\n \t\tcontinue;\n \n \t      /* If any of the changed bits overlap with local_set,\n \t\t we'll have to rescan the block.  Detect overlap by\n \t\t the AND with ~local_set turning off bits.  */\n-\t      rescan = bitmap_operation (tmp, tmp, bb->local_set,\n-\t\t\t\t\t BITMAP_AND_COMPL);\n+\t      rescan = bitmap_and_compl_into (tmp, bb->local_set);\n \t    }\n \t}\n \n@@ -1232,14 +1229,11 @@ calculate_global_regs_live (sbitmap blocks_in, sbitmap blocks_out, int flags)\n \t{\n \t  /* Add to live_at_start the set of all registers in\n \t     new_live_at_end that aren't in the old live_at_end.  */\n-\n-\t  bitmap_operation (tmp, new_live_at_end, bb->global_live_at_end,\n-\t\t\t    BITMAP_AND_COMPL);\n+\t  \n+\t  changed = bitmap_ior_and_compl_into (bb->global_live_at_start,\n+\t\t\t\t\t       new_live_at_end,\n+\t\t\t\t\t       bb->global_live_at_end);\n \t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n-\n-\t  changed = bitmap_operation (bb->global_live_at_start,\n-\t\t\t\t      bb->global_live_at_start,\n-\t\t\t\t      tmp, BITMAP_IOR);\n \t  if (! changed)\n \t    continue;\n \t}\n@@ -1860,8 +1854,8 @@ init_propagate_block_info (basic_block bb, regset live, regset local_set,\n \t}\n \n       /* Compute which register lead different lives in the successors.  */\n-      if (bitmap_operation (diff, bb_true->global_live_at_start,\n-\t\t\t    bb_false->global_live_at_start, BITMAP_XOR))\n+      if (bitmap_xor (diff, bb_true->global_live_at_start,\n+\t\t      bb_false->global_live_at_start))\n \t{\n \t  /* Extract the condition from the branch.  */\n \t  rtx set_src = SET_SRC (pc_set (BB_END (bb)));"}, {"sha": "72bb3930062a592b45cd4037b9ede32dae612830", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -2914,9 +2914,9 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  bitmap_operation (test_bb->global_live_at_end,\n-\t\t    else_bb->global_live_at_start,\n-\t\t    then_bb->global_live_at_end, BITMAP_IOR);\n+  bitmap_ior (test_bb->global_live_at_end,\n+\t      else_bb->global_live_at_start,\n+\t      then_bb->global_live_at_end);\n \n   new_bb = redirect_edge_and_branch_force (FALLTHRU_EDGE (test_bb), else_bb);\n   then_bb_index = then_bb->index;\n@@ -3018,9 +3018,9 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n   /* Conversion went ok, including moving the insns and fixing up the\n      jump.  Adjust the CFG to match.  */\n \n-  bitmap_operation (test_bb->global_live_at_end,\n-\t\t    then_bb->global_live_at_start,\n-\t\t    else_bb->global_live_at_end, BITMAP_IOR);\n+  bitmap_ior (test_bb->global_live_at_end,\n+\t      then_bb->global_live_at_start,\n+\t      else_bb->global_live_at_end);\n \n   delete_basic_block (else_bb);\n \n@@ -3217,14 +3217,13 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \t   TEST_SET & merge_bb->global_live_at_start\n \t are empty.  */\n \n-      bitmap_operation (tmp, test_set, test_live, BITMAP_IOR);\n-      bitmap_operation (tmp, tmp, merge_set, BITMAP_AND);\n-      if (bitmap_first_set_bit (tmp) >= 0)\n+      bitmap_ior (tmp, test_set, test_live);\n+      bitmap_and_into (tmp, merge_set);\n+      if (!bitmap_empty_p (tmp))\n \tfail = 1;\n \n-      bitmap_operation (tmp, test_set, merge_bb->global_live_at_start,\n-\t\t\tBITMAP_AND);\n-      if (bitmap_first_set_bit (tmp) >= 0)\n+      bitmap_and (tmp, test_set, merge_bb->global_live_at_start);\n+      if (!bitmap_empty_p (tmp))\n \tfail = 1;\n \n       FREE_REG_SET (tmp);"}, {"sha": "09e6d68794503cf46ff4c359ce09d20f29f09788", "filename": "gcc/ra-build.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -503,8 +503,7 @@ union_web_part_roots (struct web_part *r1, struct web_part *r2)\n \t    for (cl2 = r2->sub_conflicts; cl2; cl2 = cl2->next)\n \t      if (cl1->size_word == cl2->size_word)\n \t\t{\n-\t\t  bitmap_operation (cl1->conflicts, cl1->conflicts,\n-\t\t\t\t    cl2->conflicts, BITMAP_IOR);\n+\t\t  bitmap_ior_into (cl1->conflicts, cl2->conflicts);\n \t\t  BITMAP_XFREE (cl2->conflicts);\n \t\t  cl2->conflicts = NULL;\n \t\t}\n@@ -1057,7 +1056,7 @@ livethrough_conflicts_bb (basic_block bb)\n      uses conflict with all defs, and update their other members.  */\n   if (deaths > 0\n       || contains_call\n-      || bitmap_first_set_bit (all_defs) >= 0)\n+      || !bitmap_empty_p (all_defs))\n     {\n       bitmap_iterator bi;\n \n@@ -1070,7 +1069,7 @@ livethrough_conflicts_bb (basic_block bb)\n \t  wp->spanned_deaths += deaths;\n \t  wp->crosses_call |= contains_call;\n \t  conflicts = get_sub_conflicts (wp, bl);\n-\t  bitmap_operation (conflicts, conflicts, all_defs, BITMAP_IOR);\n+\t  bitmap_ior_into (conflicts, all_defs);\n \t}\n     }\n \n@@ -2076,14 +2075,13 @@ reset_conflicts (void)\n \t  /* Useless conflicts will be rebuilt completely.  But check\n \t     for cleanliness, as the web might have come from the\n \t     free list.  */\n-\t  gcc_assert (bitmap_first_set_bit (web->useless_conflicts) < 0);\n+\t  gcc_assert (bitmap_empty_p (web->useless_conflicts));\n \t}\n       else\n \t{\n \t  /* Useless conflicts with new webs will be rebuilt if they\n \t     are still there.  */\n-\t  bitmap_operation (web->useless_conflicts, web->useless_conflicts,\n-\t\t\t    newwebs, BITMAP_AND_COMPL);\n+\t  bitmap_and_compl_into (web->useless_conflicts, newwebs);\n \t  /* Go through all conflicts, and retain those to old webs.  */\n \t  for (cl = web->conflict_list; cl; cl = cl->next)\n \t    {\n@@ -2172,7 +2170,7 @@ conflicts_between_webs (struct df *df)\n   for (i = 0; i < df->def_id; i++)\n     if (web_parts[i].ref == NULL)\n       bitmap_set_bit (ignore_defs, i);\n-  have_ignored = (bitmap_first_set_bit (ignore_defs) >= 0);\n+  have_ignored = !bitmap_empty_p (ignore_defs);\n \n   /* Now record all conflicts between webs.  Note that we only check\n      the conflict bitmaps of all defs.  Conflict bitmaps are only in\n@@ -2200,8 +2198,7 @@ conflicts_between_webs (struct df *df)\n \t    bitmap_iterator bi;\n \n \t    if (have_ignored)\n-\t      bitmap_operation (cl->conflicts, cl->conflicts, ignore_defs,\n-\t\t\t        BITMAP_AND_COMPL);\n+\t      bitmap_and_compl_into (cl->conflicts, ignore_defs);\n \t    /* We reduce the number of calls to record_conflict() with this\n \t       pass thing.  record_conflict() itself also has some early-out\n \t       optimizations, but here we can use the special properties of"}, {"sha": "6ebef4903d8610d2f1f7b8cd86ebcd11f2cbf4f2", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1034,8 +1034,7 @@ reloads_to_loads (struct rewrite_info *ri, struct ref **refs,\n \t\t}\n \t    }\n \t  if (num_reloads != old_num_r)\n-\t    bitmap_operation (ri->need_reload, ri->need_reload, ri->scratch,\n-\t\t\t      BITMAP_AND_COMPL);\n+\t    bitmap_and_compl_into (ri->need_reload, ri->scratch);\n \t}\n     }\n   ri->num_reloads = num_reloads;\n@@ -1163,8 +1162,7 @@ rewrite_program2 (bitmap new_deaths)\n \t\t      ri.num_reloads--;\n \t\t    }\n \t\t}\n-\t      bitmap_operation (ri.need_reload, ri.need_reload, ri.scratch,\n-\t\t\t\tBITMAP_AND_COMPL);\n+\t      bitmap_and_compl_into (ri.need_reload, ri.scratch);\n \t      last_bb = BLOCK_FOR_INSN (insn);\n \t      last_block_insn = insn;\n \t      if (!INSN_P (last_block_insn))\n@@ -1397,9 +1395,8 @@ rewrite_program2 (bitmap new_deaths)\n \t\t  bitmap_set_bit (ri.scratch, j);\n \t\t  ri.num_reloads--;\n \t\t}\n-\t  }\n-\t  bitmap_operation (ri.need_reload, ri.need_reload, ri.scratch,\n-\t\t\t    BITMAP_AND_COMPL);\n+\t    }\n+\t  bitmap_and_compl_into (ri.need_reload, ri.scratch);\n \t}\n \n       ri.need_load = 1;\n@@ -1541,8 +1538,7 @@ detect_web_parts_to_rebuild (void)\n      indeed not become member of it again).  */\n   live_at_end -= 2;\n   for (i = 0; i < (unsigned int) last_basic_block + 2; i++)\n-    bitmap_operation (live_at_end[i], live_at_end[i], uses_as_bitmap,\n-\t\t      BITMAP_AND_COMPL);\n+    bitmap_and_compl_into (live_at_end[i], uses_as_bitmap);\n   live_at_end += 2;\n \n   if (dump_file && (debug_new_regalloc & DUMP_REBUILD) != 0)"}, {"sha": "4f97b7c7c5431d263bb011d42b4cd18d83df2dac", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -184,11 +184,9 @@ compute_jump_reg_dependencies (rtx insn, regset cond_set, regset used,\n \t it may guard the fallthrough block from using a value that has\n \t conditionally overwritten that of the main codepath.  So we\n \t consider that it restores the value of the main codepath.  */\n-      bitmap_operation (set, e->dest->global_live_at_start, cond_set,\n-\t\t\tBITMAP_AND);\n+      bitmap_and (set, e->dest->global_live_at_start, cond_set);\n     else\n-      bitmap_operation (used, used, e->dest->global_live_at_start,\n-\t\t\tBITMAP_IOR);\n+      bitmap_ior_into (used, e->dest->global_live_at_start);\n }\n \n /* Used in schedule_insns to initialize current_sched_info for scheduling"}, {"sha": "1ef29ce7db72bf2ad67d7f2962b17bad35c852c5", "filename": "gcc/tree-into-ssa.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-into-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-into-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-into-ssa.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1056,8 +1056,7 @@ insert_phi_nodes_for (tree var, bitmap *dfs, varray_type *work_stack)\n     }\n \n   /* Remove the blocks where we already have the phis.  */\n-  bitmap_operation (phi_insertion_points, phi_insertion_points,\n-\t\t    def_map->phi_blocks, BITMAP_AND_COMPL);\n+  bitmap_and_compl_into (phi_insertion_points, def_map->phi_blocks);\n \n   /* Now compute global livein for this variable.  Note this modifies\n      def_map->livein_blocks.  */\n@@ -1562,7 +1561,7 @@ rewrite_into_ssa (bool all)\n       /* Initialize the array of variables to rename.  */\n       gcc_assert (vars_to_rename);\n \n-      if (bitmap_first_set_bit (vars_to_rename) < 0)\n+      if (bitmap_empty_p (vars_to_rename))\n \t{\n \t  timevar_pop (TV_TREE_SSA_OTHER);\n \t  return;"}, {"sha": "fb720960efd8bc6a8b3281afea852edb892334f4", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1388,10 +1388,8 @@ decide_instantiations (void)\n \n   if (cleared_any)\n     {\n-      bitmap_operation (sra_candidates, sra_candidates, &done_head,\n-\t\t\tBITMAP_AND_COMPL);\n-      bitmap_operation (needs_copy_in, needs_copy_in, &done_head,\n-\t\t\tBITMAP_AND_COMPL);\n+      bitmap_and_compl_into (sra_candidates, &done_head);\n+      bitmap_and_compl_into (needs_copy_in, &done_head);\n     }\n   bitmap_clear (&done_head);\n "}, {"sha": "c643f8b6b5564fd55d2a9a0ff2193de1828fa558", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -747,8 +747,7 @@ create_name_tags (struct alias_info *ai)\n \t  continue;\n \t}\n \n-      if (pi->pt_vars\n-\t  && bitmap_first_set_bit (pi->pt_vars) >= 0)\n+      if (pi->pt_vars && !bitmap_empty_p (pi->pt_vars))\n \t{\n \t  size_t j;\n \t  tree old_name_tag = pi->name_mem_tag;\n@@ -1733,7 +1732,7 @@ merge_pointed_to_info (struct alias_info *ai, tree dest, tree orig)\n \n       if (!dest_pi->pt_anything\n \t  && orig_pi->pt_vars\n-\t  && bitmap_first_set_bit (orig_pi->pt_vars) >= 0)\n+\t  && !bitmap_empty_p (orig_pi->pt_vars))\n \t{\n \t  if (dest_pi->pt_vars == NULL)\n \t    {"}, {"sha": "41102ea219dd077b0b1a572efb4cffffec45b1be", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -356,7 +356,7 @@ tree_ssa_dominator_optimize (void)\n \t interactions between rewriting of _DECL nodes into SSA form\n \t and rewriting SSA_NAME nodes into SSA form after block\n \t duplication and CFG manipulation.  */\n-      if (bitmap_first_set_bit (vars_to_rename) >= 0)\n+      if (!bitmap_empty_p (vars_to_rename))\n \t{\n \t  rewrite_into_ssa (false);\n \t  bitmap_clear (vars_to_rename);\n@@ -367,7 +367,7 @@ tree_ssa_dominator_optimize (void)\n \n       /* Removal of statements may make some EH edges dead.  Purge\n \t such edges from the CFG as needed.  */\n-      if (bitmap_first_set_bit (need_eh_cleanup) >= 0)\n+      if (!bitmap_empty_p (need_eh_cleanup))\n \t{\n \t  cfg_altered |= tree_purge_all_dead_eh_edges (need_eh_cleanup);\n \t  bitmap_zero (need_eh_cleanup);"}, {"sha": "93dc8a2b07ef6f0d5e120b5ef448f89dff47211e", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -679,7 +679,7 @@ move_computations (void)\n \n   loop_commit_inserts ();\n   rewrite_into_ssa (false);\n-  if (bitmap_first_set_bit (vars_to_rename) >= 0)\n+  if (!bitmap_empty_p (vars_to_rename))\n     {\n       /* The rewrite of ssa names may cause violation of loop closed ssa\n \t form invariants.  TODO -- avoid these rewrites completely."}, {"sha": "68acd7ceb187e8920f62ac3120453bcc9334a705", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1411,7 +1411,7 @@ get_call_expr_operands (tree stmt, tree expr)\n \n   get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n \n-  if (bitmap_first_set_bit (call_clobbered_vars) >= 0)\n+  if (!bitmap_empty_p (call_clobbered_vars))\n     {\n       /* A 'pure' or a 'const' functions never call clobber anything. \n \t A 'noreturn' function might, but since we don't return anyway "}, {"sha": "7f70c840cf55f1c3e20255f2ce120e9e8612c14f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -1983,7 +1983,7 @@ fini_pre (void)\n   free_dominance_info (CDI_POST_DOMINATORS);\n   vn_delete ();\n \n-  if (bitmap_first_set_bit (need_eh_cleanup) >= 0)\n+  if (!bitmap_empty_p (need_eh_cleanup))\n     {\n       tree_purge_all_dead_eh_edges (need_eh_cleanup);\n       cleanup_tree_cfg ();"}, {"sha": "14384296f8f481e638c03b5927832c722b97e3ff", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -470,8 +470,7 @@ verify_flow_sensitive_alias_info (void)\n \n       if (pi->name_mem_tag\n \t  && !pi->pt_malloc\n-\t  && (pi->pt_vars == NULL\n-\t      || bitmap_first_set_bit (pi->pt_vars) < 0))\n+\t  && (pi->pt_vars == NULL || bitmap_empty_p (pi->pt_vars)))\n \t{\n \t  error (\"Pointers with a memory tag, should have points-to sets or point to malloc\");\n \t  goto err;"}, {"sha": "c9215f3232fcb9f17bacbdefa5b3228bb00b9538", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -97,7 +97,7 @@ any_marked_for_rewrite_p (void)\n   if (!ssa_names_to_rewrite)\n     return false;\n \n-  return bitmap_first_set_bit (ssa_names_to_rewrite) != -1;\n+  return !bitmap_empty_p (ssa_names_to_rewrite);\n }\n \n /* Mark ssa name VAR for rewriting.  */"}, {"sha": "03dac2ddf38cda37bbb677ee8bb9747356d77d2e", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb59b8de04973d3d08bf8df731bbd3da38af918c/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=eb59b8de04973d3d08bf8df731bbd3da38af918c", "patch": "@@ -5664,7 +5664,7 @@ vectorize_loops (struct loops *loops)\n     }\n \n   rewrite_into_ssa (false);\n-  if (bitmap_first_set_bit (vars_to_rename) >= 0)\n+  if (!bitmap_empty_p (vars_to_rename))\n     {\n       /* The rewrite of ssa names may cause violation of loop closed ssa\n          form invariants.  TODO -- avoid these rewrites completely."}]}