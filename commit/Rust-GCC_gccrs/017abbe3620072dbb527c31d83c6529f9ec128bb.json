{"sha": "017abbe3620072dbb527c31d83c6529f9ec128bb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE3YWJiZTM2MjAwNzJkYmI1MjdjMzFkODNjNjUyOWY5ZWMxMjhiYg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-03-13T09:05:43Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-03-13T09:05:43Z"}, "message": "re PR sanitizer/80953 (Support libsanitizer on Solaris)\n\n\tPR sanitizer/80953\n\tMerge from LLVM revision 355965\n\t* sanitizer_common/sanitizer_linux.cc (GetWriteFlag): Implement for\n\tSPARC/Linux.\n\t(GetPcSpBp): Likewise.\n\t* sanitizer_common/sanitizer_stacktrace.cc (GetNextInstructionPc):\n\tAdjust for SPARC.\n\t* sanitizer_common/sanitizer_stacktrace.h (SANITIZER_CAN_FAST_UNWIND):\n\tDefine to 1 for SPARC.\n\t* sanitizer_common/sanitizer_stacktrace_sparc.cc: Rewrite.\n\t* sanitizer_common/sanitizer_unwind_linux_libcdep.cc (SlowUnwindStack):\n\tAdjust the PC address for SPARC with GCC.\n\nFrom-SVN: r269638", "tree": {"sha": "b1a7b997f30e713bf2d1b990271debf33e9e4c0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b1a7b997f30e713bf2d1b990271debf33e9e4c0e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/017abbe3620072dbb527c31d83c6529f9ec128bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017abbe3620072dbb527c31d83c6529f9ec128bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017abbe3620072dbb527c31d83c6529f9ec128bb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017abbe3620072dbb527c31d83c6529f9ec128bb/comments", "author": null, "committer": null, "parents": [{"sha": "6e089cc3f64dd9b5acce75914897b99ababcaaa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e089cc3f64dd9b5acce75914897b99ababcaaa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e089cc3f64dd9b5acce75914897b99ababcaaa5"}], "stats": {"total": 128, "additions": 93, "deletions": 35}, "files": [{"sha": "3293fe04d4aea586b1c13421f5066f8c49677b17", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -1,3 +1,18 @@\n+2019-03-13  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR sanitizer/80953\n+\tMerge from LLVM revision 355965\n+\t* sanitizer_common/sanitizer_linux.cc (GetWriteFlag): Implement for\n+\tSPARC/Linux.\n+\t(GetPcSpBp): Likewise.\n+\t* sanitizer_common/sanitizer_stacktrace.cc (GetNextInstructionPc):\n+\tAdjust for SPARC.\n+\t* sanitizer_common/sanitizer_stacktrace.h (SANITIZER_CAN_FAST_UNWIND):\n+\tDefine to 1 for SPARC.\n+\t* sanitizer_common/sanitizer_stacktrace_sparc.cc: Rewrite.\n+\t* sanitizer_common/sanitizer_unwind_linux_libcdep.cc (SlowUnwindStack):\n+\tAdjust the PC address for SPARC with GCC.\n+\n 2019-03-06  Martin Liska  <mliska@suse.cz>\n \n \tPR sanitizer/88684"}, {"sha": "84c81a4eea91bd45e397e30c31acdc46294efa69", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -1848,10 +1848,20 @@ SignalContext::WriteFlag SignalContext::GetWriteFlag() const {\n   u64 esr;\n   if (!Aarch64GetESR(ucontext, &esr)) return UNKNOWN;\n   return esr & ESR_ELx_WNR ? WRITE : READ;\n-#elif SANITIZER_SOLARIS && defined(__sparc__)\n+#elif defined(__sparc__)\n   // Decode the instruction to determine the access type.\n   // From OpenSolaris $SRC/uts/sun4/os/trap.c (get_accesstype).\n+# if SANITIZER_SOLARIS\n   uptr pc = ucontext->uc_mcontext.gregs[REG_PC];\n+# else\n+  // Historical BSDism here.\n+  struct sigcontext *scontext = (struct sigcontext *)context;\n+#  if defined(__arch64__)\n+  uptr pc = scontext->sigc_regs.tpc;\n+#  else\n+  uptr pc = scontext->si_regs.pc;\n+#  endif\n+# endif\n   u32 instr = *(u32 *)pc;\n   return (instr >> 21) & 1 ? WRITE: READ;\n #else\n@@ -1942,28 +1952,27 @@ static void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   // pointer, but GCC always uses r31 when we need a frame pointer.\n   *bp = ucontext->uc_mcontext.regs->gpr[PT_R31];\n #elif defined(__sparc__)\n-  ucontext_t *ucontext = (ucontext_t*)context;\n-  uptr *stk_ptr;\n-# if defined(__sparcv9) || defined (__arch64__)\n-# ifndef MC_PC\n-#  define MC_PC REG_PC\n-# endif\n-# ifndef MC_O6\n-#  define MC_O6 REG_O6\n+# if defined(__arch64__) || defined(__sparcv9)\n+#  define STACK_BIAS 2047\n+# else\n+#  define STACK_BIAS 0\n # endif\n # if SANITIZER_SOLARIS\n-#  define mc_gregs gregs\n-# endif\n-  *pc = ucontext->uc_mcontext.mc_gregs[MC_PC];\n-  *sp = ucontext->uc_mcontext.mc_gregs[MC_O6];\n-  stk_ptr = (uptr *) (*sp + 2047);\n-  *bp = stk_ptr[15];\n-# else\n+  ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.gregs[REG_PC];\n-  *sp = ucontext->uc_mcontext.gregs[REG_O6];\n-  stk_ptr = (uptr *) *sp;\n-  *bp = stk_ptr[15];\n+  *sp = ucontext->uc_mcontext.gregs[REG_O6] + STACK_BIAS;\n+# else\n+  // Historical BSDism here.\n+  struct sigcontext *scontext = (struct sigcontext *)context;\n+#  if defined(__arch64__)\n+  *pc = scontext->sigc_regs.tpc;\n+  *sp = scontext->sigc_regs.u_regs[14] + STACK_BIAS;\n+#  else\n+  *pc = scontext->si_regs.pc;\n+  *sp = scontext->si_regs.u_regs[14];\n+#  endif\n # endif\n+  *bp = (uptr) ((uhwptr *) *sp)[14] + STACK_BIAS;\n #elif defined(__mips__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n   *pc = ucontext->uc_mcontext.pc;"}, {"sha": "f1c514d49520c8f67cd06fd1be5171f0ed799f90", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -16,10 +16,9 @@\n namespace __sanitizer {\n \n uptr StackTrace::GetNextInstructionPc(uptr pc) {\n-#if defined(__mips__)\n+#if defined(__sparc__) || defined(__mips__)\n   return pc + 8;\n-#elif defined(__powerpc__) || defined(__sparc__) || defined(__arm__) || \\\n-    defined(__aarch64__)\n+#elif defined(__powerpc__) || defined(__arm__) || defined(__aarch64__)\n   return pc + 4;\n #else\n   return pc + 1;"}, {"sha": "039b5d96dc2021b7f228d3b534d0eb363f69ba6f", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -17,7 +17,7 @@ namespace __sanitizer {\n \n static const u32 kStackTraceMax = 256;\n \n-#if defined(__sparc__) || (SANITIZER_LINUX && defined(__mips__))\n+#if SANITIZER_LINUX && defined(__mips__)\n # define SANITIZER_CAN_FAST_UNWIND 0\n #elif SANITIZER_WINDOWS\n # define SANITIZER_CAN_FAST_UNWIND 0"}, {"sha": "bd04d0f715b9d49742dbffc761310e63e4ce4e33", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_sparc.cc", "status": "modified", "additions": 41, "deletions": 12, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_sparc.cc?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -11,9 +11,13 @@\n // Implemention of fast stack unwinding for Sparc.\n //===----------------------------------------------------------------------===//\n \n-// This file is ported to Sparc v8, but it should be easy to port to\n-// Sparc v9.\n-#if defined(__sparcv8__) || defined(__sparcv8) || defined(__sparc_v8__)\n+#if defined(__sparc__)\n+\n+#if defined(__arch64__) || defined(__sparcv9)\n+#define STACK_BIAS 2047\n+#else\n+#define STACK_BIAS 0\n+#endif\n \n #include \"sanitizer_common.h\"\n #include \"sanitizer_stacktrace.h\"\n@@ -24,34 +28,59 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n                                          uptr stack_bottom, u32 max_depth) {\n   const uptr kPageSize = GetPageSizeCached();\n   CHECK_GE(max_depth, 2);\n+#if defined(__GNUC__)\n+  // __builtin_return_address returns the address of the call instruction\n+  // on the SPARC and not the return address, so we need to compensate.\n+  trace_buffer[0] = GetNextInstructionPc(pc);\n+#else\n   trace_buffer[0] = pc;\n+#endif\n   size = 1;\n   if (stack_top < 4096) return;  // Sanity check for stack top.\n   // Flush register windows to memory\n+#if defined(__sparc_v9__) || defined(__sparcv9__) || defined(__sparcv9)\n+  asm volatile(\"flushw\" ::: \"memory\");\n+#else\n   asm volatile(\"ta 3\" ::: \"memory\");\n-  uhwptr *frame = (uhwptr*)bp;\n+#endif\n+  // On the SPARC, the return address is not in the frame, it is in a\n+  // register.  There is no way to access it off of the current frame\n+  // pointer, but it can be accessed off the previous frame pointer by\n+  // reading the value from the register window save area.\n+  uptr prev_bp = GET_CURRENT_FRAME();\n+  uptr next_bp = prev_bp;\n+  unsigned int i = 0;\n+  while (next_bp != bp &&\n+\t IsAligned(next_bp, sizeof(uhwptr)) &&\n+\t i++ < 8) {\n+    prev_bp = next_bp;\n+    next_bp = (uptr) ((uhwptr *) next_bp)[14] + STACK_BIAS;\n+  }\n+  if (next_bp == bp)\n+    bp = prev_bp;\n   // Lowest possible address that makes sense as the next frame pointer.\n   // Goes up as we walk the stack.\n   uptr bottom = stack_bottom;\n   // Avoid infinite loop when frame == frame[0] by using frame > prev_frame.\n-  while (IsValidFrame((uptr)frame, stack_top, bottom) &&\n-         IsAligned((uptr)frame, sizeof(*frame)) &&\n+  while (IsValidFrame(bp, stack_top, bottom) &&\n+         IsAligned(bp, sizeof(uhwptr)) &&\n          size < max_depth) {\n-    uhwptr pc1 = frame[15];\n+    uhwptr pc1 = ((uhwptr *)bp)[15];\n     // Let's assume that any pointer in the 0th page is invalid and\n     // stop unwinding here.  If we're adding support for a platform\n     // where this isn't true, we need to reconsider this check.\n     if (pc1 < kPageSize)\n       break;\n     if (pc1 != pc) {\n-      trace_buffer[size++] = (uptr) pc1;\n+      // %o7 contains the address of the call instruction and not the\n+      // return address, so we need to compensate.\n+      trace_buffer[size++] = GetNextInstructionPc((uptr) pc1);\n     }\n-    bottom = (uptr)frame;\n-    frame = (uhwptr*)frame[14];\n+    bottom = bp;\n+    bp = (uptr) ((uhwptr *) bp)[14] + STACK_BIAS;\n   }\n }\n \n }  // namespace __sanitizer\n \n-#endif  // !defined(__sparcv8__) && !defined(__sparcv8) &&\n-        // !defined(__sparc_v8__)\n+#endif  // !defined(__sparc__)"}, {"sha": "44f12c408b972e3882edb06f5f4900fb65117fb8", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/017abbe3620072dbb527c31d83c6529f9ec128bb/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc?ref=017abbe3620072dbb527c31d83c6529f9ec128bb", "patch": "@@ -134,7 +134,13 @@ void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n   if (to_pop == 0 && size > 1)\n     to_pop = 1;\n   PopStackFrames(to_pop);\n+#if defined(__GNUC__) && defined(__sparc__)\n+  // __builtin_return_address returns the address of the call instruction\n+  // on the SPARC and not the return address, so we need to compensate.\n+  trace_buffer[0] = GetNextInstructionPc(pc);\n+#else\n   trace_buffer[0] = pc;\n+#endif\n }\n \n void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,"}]}