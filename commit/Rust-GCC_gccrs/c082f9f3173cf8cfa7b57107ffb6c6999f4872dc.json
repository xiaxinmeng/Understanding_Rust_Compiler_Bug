{"sha": "c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzA4MmY5ZjMxNzNjZjhjZmE3YjU3MTA3ZmZiNmM2OTk5ZjQ4NzJkYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-05-07T21:37:43Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-05-07T21:37:43Z"}, "message": "configure.ac (--enable-lto): Add x86_64-apple-darwin* as a platform that supports LTO.\n\nChangeLog:\n\t* configure.ac (--enable-lto): Add x86_64-apple-darwin* as\n\ta platform that supports LTO.\n\t* configure: Regenerate.\n\ngcc/ChangeLog:\n\t* config.gcc (i[34567]86-*-darwin*, x86_64-*-darwin*): Add\n\tlto-macho as lto_binary_reader.\n\t* target.h (struct gcc_target): New hooks lto_start and\tlto_end.\n\t* target-def.h (TARGET_ASM_LTO_START, TARGET_ASM_LTO_END): Define.\n\t* cgraphunit.c (ipa_passes): Wrap LTO assembler output generation\n\tin lto_start and lto_end calls.\n\t(is_elf_or_coff): Rename to maybe_lto_object_file.  Add Mach-O\n\tmagic numbers.\n\t(scan_prog_file): Update is_elf_or_coff call.\n\t* doc/tm.text (TARGET_ASM_LTO_START, TARGET_ASM_LTO_END): Document.\n\n\t* collect2.c (main): Fix enum comparison.\n\n\t* config/darwin-protos.h (darwin_asm_lto_start, darwin_asm_lto_end):\n\tAdd prototypes.\n\t* darwin9.h (LINK_COMMAND_SPEC): Pass -flto and -fwhopr to the linker.\n\t* darwin.h (LINK_COMMAND_SPEC): Likewise.  Define TARGET_ASM_LTO_START\n\tand TARGET_ASM_LTO_END.\n\t* darwin.c: Include obstack.h and lto-streamer.h.\n\t(lto_section_names_offset, lto_section_names_obstack,\n\tlto_asm_out_file, lto_asm_out_name, saved_asm_out_file): New static\n\tglobal variables.\n\t(LTO_SEGMENT_NAME, LTO_NAMES_SECTION): New defines.\n\t(darwin_asm_lto_start): New function.  Redirect output to asm_out_file\n\tto a temporary file.\n\t(darwin_asm_lto_end): New function.  Restore asm_out_file.\n\t(darwin_asm_named_section): For LTO sections, replace the name with\n\tthe offset of the section name in a string table, and build this\n\ttable.\n\t(darwin_file_start): Initialize global vars for LTO support.\n\t(darwin_file_end): If output to asm_out_file was redirected, append it\n\tto the proper asm_out_file here.  Add the section names section.\n\nlto/ChangeLog:\n\t* lto.h (struct lto_file_struct): Document offset member.\n\t* lto-endian.h: New file.\n\t* lto-macho.h: New file.\n\t* lto-macho.c: New file.\n\t* Make-lang.in: Add rule for lto-macho.o.\n\nFrom-SVN: r159173", "tree": {"sha": "b036b0c810fc469ae0e5ec3f6d1436e32e0ef493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b036b0c810fc469ae0e5ec3f6d1436e32e0ef493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/comments", "author": null, "committer": null, "parents": [{"sha": "18bc5398c1526d6a852b2f18152ebcfe6b706dcf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18bc5398c1526d6a852b2f18152ebcfe6b706dcf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18bc5398c1526d6a852b2f18152ebcfe6b706dcf"}], "stats": {"total": 1718, "additions": 1704, "deletions": 14}, "files": [{"sha": "ee64b585573952e6ed10630baa2be4ed92d0be14", "filename": "ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1,3 +1,9 @@\n+2010-05-07  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* configure.ac (--enable-lto): Add x86_64-apple-darwin* as\n+\ta platform that supports LTO.\n+\t* configure: Regenerate.\n+\n 2010-05-05  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* configure.ac: Allow all the versions greater than 0.10 of PPL."}, {"sha": "6fc9b0f7a57ec23a89662f96b3c215c19d1edb2c", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -6686,6 +6686,7 @@ else\n   # -flto it won't be needed until after installation anyway.\n     case $target in\n       *-cygwin*|*-mingw*) ;;\n+      x86_64-apple-darwin*) ;;\n       *) if test x\"$enable_lto\" = x\"yes\"; then\n \tas_fn_error \"LTO support is not enabled for this target.\" \"$LINENO\" 5\n         fi"}, {"sha": "920457464e57319e637debde345bfb333b989f14", "filename": "configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/configure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/configure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.ac?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1803,6 +1803,7 @@ fi],[if test x\"$default_enable_lto\" = x\"yes\" ; then\n   # -flto it won't be needed until after installation anyway.\n     case $target in\n       *-cygwin*|*-mingw*) ;;\n+      x86_64-apple-darwin*) ;;\n       *) if test x\"$enable_lto\" = x\"yes\"; then\n \tAC_MSG_ERROR([LTO support is not enabled for this target.])\n         fi"}, {"sha": "d44a0209ede0eb6d61bc1d6f69281ac310e2a9d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1,3 +1,38 @@\n+2010-05-07  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* config.gcc (i[34567]86-*-darwin*, x86_64-*-darwin*): Add\n+\tlto-macho as lto_binary_reader.\n+\t* target.h (struct gcc_target): New hooks lto_start and\tlto_end.\n+\t* target-def.h (TARGET_ASM_LTO_START, TARGET_ASM_LTO_END): Define.\n+\t* cgraphunit.c (ipa_passes): Wrap LTO assembler output generation\n+\tin lto_start and lto_end calls.\n+\t(is_elf_or_coff): Rename to maybe_lto_object_file.  Add Mach-O\n+\tmagic numbers.\n+\t(scan_prog_file): Update is_elf_or_coff call.\n+\t* doc/tm.text (TARGET_ASM_LTO_START, TARGET_ASM_LTO_END): Document.\n+\n+\t* collect2.c (main): Fix enum comparison.\n+\n+\t* config/darwin-protos.h (darwin_asm_lto_start, darwin_asm_lto_end):\n+\tAdd prototypes.\n+\t* darwin9.h (LINK_COMMAND_SPEC): Pass -flto and -fwhopr to the linker.\n+\t* darwin.h (LINK_COMMAND_SPEC): Likewise.  Define TARGET_ASM_LTO_START\n+\tand TARGET_ASM_LTO_END.\n+\t* darwin.c: Include obstack.h and lto-streamer.h.\n+\t(lto_section_names_offset, lto_section_names_obstack,\n+\tlto_asm_out_file, lto_asm_out_name, saved_asm_out_file): New static\n+\tglobal variables.\n+\t(LTO_SEGMENT_NAME, LTO_NAMES_SECTION): New defines.\n+\t(darwin_asm_lto_start): New function.  Redirect output to asm_out_file\n+\tto a temporary file.\n+\t(darwin_asm_lto_end): New function.  Restore asm_out_file.\n+\t(darwin_asm_named_section): For LTO sections, replace the name with\n+\tthe offset of the section name in a string table, and build this\n+\ttable.\n+\t(darwin_file_start): Initialize global vars for LTO support.\n+\t(darwin_file_end): If output to asm_out_file was redirected, append it\n+\tto the proper asm_out_file here.  Add the section names section.\n+\n 2010-05-07  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* c-pragma.c (pending_weak_d, pending_weak): New."}, {"sha": "cacb90c615d78a6bae92f881fcebef58d09954f3", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1866,11 +1866,19 @@ ipa_passes (void)\n       execute_ipa_summary_passes\n \t((struct ipa_opt_pass_d *) all_regular_ipa_passes);\n     }\n+\n+  /* Some targets need to handle LTO assembler output specially.  */\n+  if (flag_generate_lto)\n+    targetm.asm_out.lto_start ();\n+\n   execute_ipa_summary_passes ((struct ipa_opt_pass_d *) all_lto_gen_passes);\n \n   if (!in_lto_p)\n     ipa_write_summaries ();\n \n+  if (flag_generate_lto)\n+    targetm.asm_out.lto_end ();\n+\n   if (!flag_ltrans)\n     execute_ipa_pass_list (all_regular_ipa_passes);\n   invoke_plugin_callbacks (PLUGIN_ALL_IPA_PASSES_END, NULL);"}, {"sha": "6582185cf094b0749a2704e77b1673c92643f5b8", "filename": "gcc/collect2.c", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1817,7 +1817,7 @@ main (int argc, char **argv)\n \tif (export_file != 0 && export_file[0])\n \t  maybe_unlink (export_file);\n #endif\n-\tif (lto_mode)\n+\tif (lto_mode != LTO_MODE_NONE)\n \t  maybe_run_lto_and_relink (ld1_argv, object_lst, object, false);\n \n \tmaybe_unlink (c_file);\n@@ -2563,25 +2563,39 @@ write_aix_file (FILE *stream, struct id *list)\n \f\n #ifdef OBJECT_FORMAT_NONE\n \n-/* Check to make sure the file is an ELF file.  LTO objects must\n-   be in ELF format.  */\n+/* Check to make sure the file is an LTO object file.  */\n \n static bool\n-is_elf_or_coff (const char *prog_name)\n+maybe_lto_object_file (const char *prog_name)\n {\n   FILE *f;\n-  char buf[4];\n-  static char magic[4] = { 0x7f, 'E', 'L', 'F' };\n-  static char coffmag[2] = { 0x4c, 0x01 };\n+  unsigned char buf[4];\n+  int i;\n+\n+  static unsigned char elfmagic[4] = { 0x7f, 'E', 'L', 'F' };\n+  static unsigned char coffmagic[2] = { 0x4c, 0x01 };\n+  static unsigned char machomagic[4][4] = {\n+    { 0xcf, 0xfa, 0xed, 0xfe },\n+    { 0xce, 0xfa, 0xed, 0xfe },\n+    { 0xfe, 0xed, 0xfa, 0xcf },\n+    { 0xfe, 0xed, 0xfa, 0xce }\n+  };\n \n   f = fopen (prog_name, \"rb\");\n   if (f == NULL)\n     return false;\n   if (fread (buf, sizeof (buf), 1, f) != 1)\n     buf[0] = 0;\n   fclose (f);\n-  return memcmp (buf, magic, sizeof (magic)) == 0\n-\t|| memcmp (buf, coffmag, sizeof (coffmag)) == 0;\n+\n+  if (memcmp (buf, elfmagic, sizeof (elfmagic)) == 0\n+      || memcmp (buf, coffmagic, sizeof (coffmagic)) == 0)\n+    return true;\n+  for (i = 0; i < 4; i++)\n+    if (memcmp (buf, machomagic[i], sizeof (machomagic[i])) == 0)\n+      return true;\n+\n+  return false;\n }\n \n /* Generic version to scan the name list of the loaded program for\n@@ -2611,7 +2625,7 @@ scan_prog_file (const char *prog_name, scanpass which_pass,\n   /* LTO objects must be in a known format.  This check prevents\n      us from accepting an archive containing LTO objects, which\n      gcc cannnot currently handle.  */\n-  if (which_pass == PASS_LTOINFO && !is_elf_or_coff (prog_name))\n+  if (which_pass == PASS_LTOINFO && !maybe_lto_object_file (prog_name))\n     return;\n \n   /* If we do not have an `nm', complain.  */"}, {"sha": "5ea1b4d580207b0723b337e2a72da87669d99b82", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1077,11 +1077,13 @@ i[34567]86-*-darwin*)\n \t# support.\n \twith_cpu=${with_cpu:-generic}\n \ttmake_file=\"${tmake_file} i386/t-crtpc i386/t-crtfm\"\n+\tlto_binary_reader=lto-macho\n \t;;\n x86_64-*-darwin*)\n \twith_cpu=${with_cpu:-generic}\n \ttmake_file=\"${tmake_file} t-darwin ${cpu_type}/t-darwin64 t-slibgcc-darwin i386/t-crtpc i386/t-crtfm\"\n \ttm_file=\"${tm_file} ${cpu_type}/darwin64.h\"\n+\tlto_binary_reader=lto-macho\n \t;;\n i[34567]86-*-elf*)\n \ttm_file=\"${tm_file} i386/unix.h i386/att.h dbxelf.h elfos.h newlib-stdint.h i386/i386elf.h\""}, {"sha": "5886f0158a6e2b38a12973575518b12221861820", "filename": "gcc/config/darwin-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin-protos.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -71,6 +71,9 @@ extern void darwin_pragma_ms_struct (struct cpp_reader *);\n extern void darwin_file_start (void);\n extern void darwin_file_end (void);\n \n+extern void darwin_asm_lto_start (void);\n+extern void darwin_asm_lto_end (void);\n+\n extern void darwin_mark_decl_preserved (const char *);\n \n extern tree darwin_handle_kext_attribute (tree *, tree, tree, int, bool *);"}, {"sha": "93f7babbd6fcf4dbc988774e6f5974df7c936b1b", "filename": "gcc/config/darwin.c", "status": "modified", "additions": 135, "deletions": 3, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.c?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -46,6 +46,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"df.h\"\n #include \"debug.h\"\n+#include \"obstack.h\"\n+#include \"lto-streamer.h\"\n \n /* Darwin supports a feature called fix-and-continue, which is used\n    for rapid turn around debugging.  When code is compiled with the\n@@ -1387,12 +1389,88 @@ darwin_label_is_anonymous_local_objc_name (const char *name)\n   return (!strncmp ((const char *)p, \"_OBJC_\", 6));\n }\n \n+/* LTO support for Mach-O.  */\n+\n+/* Section names for LTO sections.  */\n+static unsigned int lto_section_names_offset = 0;\n+\n+/* This is the obstack which we use to allocate the many strings.  */\n+static struct obstack lto_section_names_obstack;\n+\n+/* Segment name for LTO sections.  */\n+#define LTO_SEGMENT_NAME \"__GNU_LTO\"\n+\n+/* Section name for LTO section names section.  */\n+#define LTO_NAMES_SECTION \"__section_names\"\n+\n+/* File to temporarily store LTO data.  This is appended to asm_out_file\n+   in darwin_end_file.  */\n+static FILE *lto_asm_out_file, *saved_asm_out_file;\n+static char *lto_asm_out_name;\n+\n+/* Prepare asm_out_file for LTO output.  For darwin, this means hiding\n+   asm_out_file and switching to an alternative output file.  */\n+void\n+darwin_asm_lto_start (void)\n+{\n+  gcc_assert (! saved_asm_out_file);\n+  saved_asm_out_file = asm_out_file;\n+  if (! lto_asm_out_name)\n+    lto_asm_out_name = make_temp_file (\".lto.s\");\n+  lto_asm_out_file = fopen (lto_asm_out_name, \"a\");\n+  if (lto_asm_out_file == NULL)\n+    fatal_error (\"failed to open temporary file %s for LTO output\",\n+\t\t lto_asm_out_name);\n+  asm_out_file = lto_asm_out_file;\n+}\n+\n+/* Restore asm_out_file.  */\n+void\n+darwin_asm_lto_end (void)\n+{\n+  gcc_assert (saved_asm_out_file);\n+  fclose (lto_asm_out_file);\n+  asm_out_file = saved_asm_out_file;\n+  saved_asm_out_file = NULL;\n+}\n+\n void\n darwin_asm_named_section (const char *name,\n-\t\t\t  unsigned int flags ATTRIBUTE_UNUSED,\n+\t\t\t  unsigned int flags,\n \t\t\t  tree decl ATTRIBUTE_UNUSED)\n {\n-  fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n+  /* LTO sections go in a special segment __GNU_LTO.  We want to replace the\n+     section name with something we can use to represent arbitrary-length\n+     names (section names in Mach-O are at most 16 characters long).  */\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t       strlen (LTO_SECTION_NAME_PREFIX)) == 0)\n+    {\n+      /* We expect certain flags to be set...  */\n+      gcc_assert ((flags & (SECTION_DEBUG | SECTION_NAMED))\n+\t\t  == (SECTION_DEBUG | SECTION_NAMED));\n+\n+      /* Add the section name to the things to output when we end the\n+\t current assembler output file.\n+\t This is all not very efficient, but that doesn't matter -- this\n+\t shouldn't be a hot path in the compiler...  */\n+      obstack_1grow (&lto_section_names_obstack, '\\t');\n+      obstack_grow (&lto_section_names_obstack, \".ascii \", 7);\n+      obstack_1grow (&lto_section_names_obstack, '\"');\n+      obstack_grow (&lto_section_names_obstack, name, strlen (name));\n+      obstack_grow (&lto_section_names_obstack, \"\\\\0\\\"\\n\", 4);\n+\n+      /* Output the dummy section name.  */\n+      fprintf (asm_out_file, \"\\t.section %s,__%08X,regular,debug\\t# %s\\n\",\n+\t       LTO_SEGMENT_NAME, lto_section_names_offset, name);\n+\n+      /* Update the offset for the next section name.  Make sure we stay\n+\t within reasonable length.  */  \n+      lto_section_names_offset += strlen (name) + 1;\n+      gcc_assert (lto_section_names_offset > 0\n+\t\t  && lto_section_names_offset < ((unsigned) 1 << 31));\n+    }\n+  else\n+    fprintf (asm_out_file, \"\\t.section %s\\n\", name);\n }\n \n void\n@@ -1585,7 +1663,8 @@ darwin_asm_output_dwarf_delta (FILE *file, int size,\n     fprintf (file, \"\\n\\t%s L$set$%d\", directive, darwin_dwarf_label_counter++);\n }\n \n-/* Output labels for the start of the DWARF sections if necessary.  */\n+/* Output labels for the start of the DWARF sections if necessary.\n+   Initialize the stuff we need for LTO long section names support.  */\n void\n darwin_file_start (void)\n {\n@@ -1620,6 +1699,11 @@ darwin_file_start (void)\n \t  fprintf (asm_out_file, \"Lsection%.*s:\\n\", namelen, debugnames[i] + 8);\n \t}\n     }\n+\n+  /* We fill this obstack with the complete section text for the lto section\n+     names to write in darwin_file_end.  */\n+  obstack_init (&lto_section_names_obstack);\n+  lto_section_names_offset = 0;\n }\n \n /* Output an offset in a DWARF section on Darwin.  On Darwin, DWARF section\n@@ -1646,13 +1730,61 @@ darwin_asm_output_dwarf_offset (FILE *file, int size, const char * lab,\n void\n darwin_file_end (void)\n {\n+  const char *lto_section_names;\n+\n   machopic_finish (asm_out_file);\n   if (strcmp (lang_hooks.name, \"GNU C++\") == 0)\n     {\n       switch_to_section (darwin_sections[constructor_section]);\n       switch_to_section (darwin_sections[destructor_section]);\n       ASM_OUTPUT_ALIGN (asm_out_file, 1);\n     }\n+\n+  /* If there was LTO assembler output, append it to asm_out_file.  */\n+  if (lto_asm_out_name)\n+    {\n+      int n;\n+      char *buf, *lto_asm_txt;\n+\n+      /* Shouldn't be here if we failed to switch back.  */\n+      gcc_assert (! saved_asm_out_file);\n+\n+      lto_asm_out_file = fopen (lto_asm_out_name, \"r\");\n+      if (lto_asm_out_file == NULL)\n+\tfatal_error (\"failed to open temporary file %s with LTO output\",\n+\t\t     lto_asm_out_name);\n+      fseek (lto_asm_out_file, 0, SEEK_END);\n+      n = ftell (lto_asm_out_file);\n+      if (n > 0)\n+        {\n+\t  fseek (lto_asm_out_file, 0, SEEK_SET);\n+\t  lto_asm_txt = buf = (char *) xmalloc (n + 1);\n+\t  while (fgets (lto_asm_txt, n, lto_asm_out_file))\n+\t    fputs (lto_asm_txt, asm_out_file);\n+\t}\n+\n+      /* Remove the temporary file.  */\n+      fclose (lto_asm_out_file);\n+      unlink_if_ordinary (lto_asm_out_name);\n+      free (lto_asm_out_name);\n+    }\n+\n+  /* Finish the LTO section names obstack.  Don't output anything if\n+     there are no recorded section names.  */\n+  obstack_1grow (&lto_section_names_obstack, '\\0');\n+  lto_section_names = XOBFINISH (&lto_section_names_obstack, const char *);\n+  if (strlen (lto_section_names) > 0)\n+    {\n+      fprintf (asm_out_file,\n+\t       \"\\t.section %s,%s,regular,debug\\n\",\n+\t       LTO_SEGMENT_NAME, LTO_NAMES_SECTION);\n+      fprintf (asm_out_file,\n+\t       \"\\t# Section names in %s are offsets into this table\\n\",\n+\t       LTO_SEGMENT_NAME);\n+      fprintf (asm_out_file, \"%s\\n\", lto_section_names);\n+    }\n+  obstack_free (&lto_section_names_obstack, NULL);\n+\n   fprintf (asm_out_file, \"\\t.subsections_via_symbols\\n\");\n }\n "}, {"sha": "a0a4974c38a3c6eadf4caa8a7a01dc7c4b2bf550", "filename": "gcc/config/darwin.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -273,6 +273,7 @@ extern GTY(()) int darwin_ms_struct;\n     %{o*}%{!o:-o a.out} \\\n     %{!A:%{!nostdlib:%{!nostartfiles:%S}}} \\\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n+    %{flto} %{fwhopr} \\\n     %{fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n     %{!nostdlib:%{!nodefaultlibs: %(link_ssp) %G %L }} \\\n@@ -581,6 +582,16 @@ extern GTY(()) int darwin_ms_struct;\n #undef  TARGET_ASM_FILE_END\n #define TARGET_ASM_FILE_END darwin_file_end\n \n+/* Because Mach-O relocations have a counter from 1 to 255 for the\n+   section number they apply to, it is necessary to output all\n+   normal sections before the LTO sections, to make sure that the\n+   sections that may have relocations always have a section number\n+   smaller than 255.  */\n+#undef  TARGET_ASM_LTO_START\n+#define TARGET_ASM_LTO_START darwin_asm_lto_start\n+#undef  TARGET_ASM_LTO_END\n+#define TARGET_ASM_LTO_END darwin_asm_lto_end\n+\n #define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n   fprintf (FILE, \"\\t.space \"HOST_WIDE_INT_PRINT_UNSIGNED\"\\n\", SIZE)\n "}, {"sha": "a03e77271ebdd4c8a17111410e312ca407b7e132", "filename": "gcc/config/darwin9.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin9.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fconfig%2Fdarwin9.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fdarwin9.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -32,6 +32,7 @@ along with GCC; see the file COPYING3.  If not see\n     %{o*}%{!o:-o a.out} \\\n     %{!A:%{!nostdlib:%{!nostartfiles:%S}}} \\\n     %{L*} %(link_libgcc) %o %{fprofile-arcs|fprofile-generate*|coverage:-lgcov} \\\n+    %{flto} %{fwhopr} \\\n     %{fopenmp|ftree-parallelize-loops=*: \\\n       %{static|static-libgcc|static-libstdc++|static-libgfortran: libgomp.a%s; : -lgomp } } \\\n     %{!nostdlib:%{!nodefaultlibs:  %(link_ssp) %G %L }} \\"}, {"sha": "96fc62c2c51d0e96004c77d22c39694060bf3b3a", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -7184,6 +7184,18 @@ need to do other things in that hook, have your hook function call\n this function.\n @end deftypefun\n \n+@deftypefn {Target Hook} void TARGET_ASM_LTO_START (void)\n+Output to @code{asm_out_file} any text which the assembler expects\n+to find at the start of an LTO section.  The default is to output\n+nothing.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} void TARGET_ASM_LTO_END (void)\n+Output to @code{asm_out_file} any text which the assembler expects\n+to find at the end of an LTO section.  The default is to output\n+nothing.\n+@end deftypefn\n+\n @deftypefn {Target Hook} void TARGET_ASM_CODE_END (void)\n Output to @code{asm_out_file} any text which is needed before emitting\n unwind info and debug info at the end of a file.  Some targets emit"}, {"sha": "b7f0b7e61653470cbf1e526f9e9522bad4437ea1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1,3 +1,11 @@\n+2010-05-07  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* lto.h (struct lto_file_struct): Document offset member.\n+\t* lto-endian.h: New file.\n+\t* lto-macho.h: New file.\n+\t* lto-macho.c: New file.\n+\t* Make-lang.in: Add rule for lto-macho.o.\n+\n 2010-05-07  Richard Guenther <rguenther@suse.de>\n \n \tPR lto/43857"}, {"sha": "149644972af150c7dd0b8686a9c30d9506544d05", "filename": "gcc/lto/Make-lang.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FMake-lang.in?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -91,3 +91,6 @@ lto/lto-elf.o: lto/lto-elf.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n lto/lto-coff.o: lto/lto-coff.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n \ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \\\n \tlto/lto-coff.h\n+lto/lto-macho.o: lto/lto-macho.c $(CONFIG_H) coretypes.h $(SYSTEM_H) \\\n+\ttoplev.h $(LTO_H) $(TM_H) $(LIBIBERTY_H) $(GGC_H) $(LTO_STREAMER_H) \\\n+\tlto/lto-macho.h lto/lto-endian.h"}, {"sha": "1f51cee79e92e6f93f1d953a28f8e70757014305", "filename": "gcc/lto/lto-endian.h", "status": "added", "additions": 205, "deletions": 0, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-endian.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-endian.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-endian.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -0,0 +1,205 @@\n+/* Very simple endian-ness layer for LTO object file handling\n+   Copyright 2010 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This header file provides a simple way to handle object files in\n+   another endian-ness than the host machine.  This is necesarry to\n+   enable cross-compilation with LTO enabled.  Targets that use the\n+   ELF binary object format do not need this (libelf already handles\n+   endian-ness) but for COFF and Mach-O the functions in this header\n+   are used in the minimal binary object reader/writer.\n+   \n+   For all functions in this header, the user is responsible for\n+   making sure that the memory accesses are valid.  */\n+\n+#ifndef GCC_LTO_ENDIAN_H\n+#define GCC_LTO_ENDIAN_H\n+\n+#include <stdint.h>\n+#include <inttypes.h>\n+\n+static inline uint16_t\n+get_uint16_le (const unsigned char *ptr)\n+{\n+  return ptr[0] | (ptr[1] << 8);\n+}\n+\n+static inline uint32_t\n+get_uint32_le (const unsigned char *ptr)\n+{\n+  return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24);\n+}\n+\n+static inline uint64_t\n+get_uint64_le (const unsigned char *ptr_)\n+{\n+#define ptr (uint64_t) ptr_\n+  return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24)\n+         | (ptr[4] << 32) | (ptr[5] << 40) | (ptr[6] << 48) | (ptr[7] << 56);\n+#undef ptr\n+}\n+\n+static inline uint16_t\n+get_uint16_be (const unsigned char *ptr)\n+{\n+  return ptr[1] | (ptr[2] << 8);\n+}\n+\n+static inline uint32_t\n+get_uint32_be (const unsigned char *ptr)\n+{\n+  return ptr[3] | (ptr[2] << 8) | (ptr[1] << 16) | (ptr[0] << 24);\n+}\n+\n+static inline uint64_t\n+get_uint64_be (const unsigned char *ptr_)\n+{\n+#define ptr (uint64_t) ptr_\n+  return ptr[7] | (ptr[6] << 8) | (ptr[5] << 16) | (ptr[4] << 24)\n+         | (ptr[3] << 32) | (ptr[2] << 40) | (ptr[1] << 48) | (ptr[0] << 56);\n+#undef ptr\n+}\n+\n+static inline void\n+put_uint16_le (unsigned char *ptr, uint16_t data)\n+{\n+  ptr[0] = data & 0xff;\n+  ptr[1] = (data >> 8) & 0xff;\n+}\n+\n+static inline void\n+put_uint32_le (unsigned char *ptr, uint32_t data)\n+{\n+  ptr[0] = data & 0xff;\n+  ptr[1] = (data >> 8) & 0xff;\n+  ptr[2] = (data >> 16) & 0xff;\n+  ptr[3] = (data >> 24) & 0xff;\n+}\n+\n+static inline void\n+put_uint64_le (unsigned char *ptr, uint64_t data)\n+{\n+  ptr[0] = data & 0xff;\n+  ptr[1] = (data >> 8) & 0xff;\n+  ptr[2] = (data >> 16) & 0xff;\n+  ptr[3] = (data >> 24) & 0xff;\n+  ptr[4] = (data >> 32) & 0xff;\n+  ptr[5] = (data >> 40) & 0xff;\n+  ptr[6] = (data >> 48) & 0xff;\n+  ptr[7] = (data >> 56) & 0xff;\n+}\n+\n+static inline void\n+put_uint16_be (unsigned char *ptr, uint16_t data)\n+{\n+  ptr[1] = data & 0xff;\n+  ptr[0] = (data >> 8) & 0xff;\n+}\n+\n+static inline void\n+put_uint32_be (unsigned char *ptr, uint32_t data)\n+{\n+  ptr[3] = data & 0xff;\n+  ptr[2] = (data >> 8) & 0xff;\n+  ptr[1] = (data >> 16) & 0xff;\n+  ptr[0] = (data >> 24) & 0xff;\n+}\n+\n+static inline void\n+put_uint64_be (unsigned char *ptr, uint64_t data)\n+{\n+  ptr[7] = data & 0xff;\n+  ptr[6] = (data >> 8) & 0xff;\n+  ptr[5] = (data >> 16) & 0xff;\n+  ptr[4] = (data >> 24) & 0xff;\n+  ptr[3] = (data >> 32) & 0xff;\n+  ptr[2] = (data >> 40) & 0xff;\n+  ptr[1] = (data >> 48) & 0xff;\n+  ptr[0] = (data >> 56) & 0xff;\n+}\n+\n+static inline void\n+get_string (unsigned char *ptr, char *dest, size_t len)\n+{\n+  memcpy (dest, ptr, len);\n+}\n+\n+static inline void\n+put_string (unsigned char *ptr, char *src, size_t len)\n+{\n+  memcpy (ptr, src, len);\n+}\n+\n+/* Use the target macro BYTES_BIG_ENDIAN to choose.  */\n+\n+static inline uint16_t\n+get_uint16 (const unsigned char *ptr)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    return get_uint16_be (ptr);\n+  else\n+    return get_uint16_le (ptr);\n+}\n+\n+static inline uint32_t\n+get_uint32 (const unsigned char *ptr)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    return get_uint32_be (ptr);\n+  else\n+    return get_uint32_le (ptr);\n+}\n+\n+static inline uint64_t\n+get_uint64 (const unsigned char *ptr)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    return get_uint64_be (ptr);\n+  else\n+    return get_uint64_le (ptr);\n+}\n+\n+static inline void\n+put_uint16 (unsigned char *ptr, uint16_t data)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    put_uint16_be (ptr, data);\n+  else\n+    put_uint16_le (ptr, data);\n+}\n+\n+static inline void\n+put_uint32 (unsigned char *ptr, uint32_t data)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    put_uint32_be (ptr, data);\n+  else\n+    put_uint32_le (ptr, data);\n+}\n+\n+static inline void\n+put_uint64 (unsigned char *ptr, uint64_t data)\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    put_uint64_be (ptr, data);\n+  else\n+    put_uint64_le (ptr, data);\n+}\n+\n+#endif /* GCC_LTO_ENDIAN_H  */\n+"}, {"sha": "d5573a06a810de27754114534df4173efa909f4d", "filename": "gcc/lto/lto-macho.c", "status": "added", "additions": 978, "deletions": 0, "changes": 978, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-macho.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-macho.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-macho.c?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -0,0 +1,978 @@\n+/* LTO routines for Mach-O object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Steven Bosscher.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"toplev.h\"\n+#include \"lto.h\"\n+#include \"tm.h\"\n+#include \"libiberty.h\"\n+#include \"lto-streamer.h\"\n+#include \"lto/lto-endian.h\"\n+#include \"lto/lto-macho.h\"\n+\n+/* Rather than implementing a libmacho to match libelf, or attempting to\n+   integrate libbfd into GCC, this file is a self-contained (and very\n+   minimal) Mach-O format object file reader/writer.  The generated files\n+   will contain a Mach-O header, a number of Mach-O load commands an\n+   section headers, the  section data itself, and a trailing string table\n+   for section names.  */\n+\n+/* This needs to be kept in sync with darwin.c.  Better yet, lto-macho.c\n+   and lto-macho.h should be moved to config/, and likewise for lto-coff.*\n+   and lto-elf.*.  */\n+\n+/* Segment name for LTO sections.  */\n+#define LTO_SEGMENT_NAME \"__GNU_LTO\"\n+\n+/* Section name for LTO section names section.  */\n+#define LTO_NAMES_SECTION \"__section_names\"\n+\n+/* Handle opening elf files on hosts, such as Windows, that may use \n+   text file handling that will break binary access.  */\n+#ifndef O_BINARY\n+# define O_BINARY 0\n+#endif\n+\n+/* Cached object file header.  We use a header_64 for this, since all\n+   the fields we need are in there, in the same position as header_32.  */\n+mach_o_header_64 cached_mach_o_header;\n+uint32_t cached_mach_o_magic;\n+\n+/* The current output file.  */\n+static lto_file *current_out_file;\n+\n+\n+/* Is this a 32-bits or 64-bits Mach-O object file?  */\n+static int\n+mach_o_word_size (void)\n+{\n+  gcc_assert (cached_mach_o_magic != 0);\n+  return (cached_mach_o_magic == MACH_O_MH_MAGIC_64\n+\t  || cached_mach_o_magic == MACH_O_MH_CIGAM_64) ? 64 : 32;\n+}\n+\n+/* Sets the current output file to FILE.  Returns the old output file or\n+   NULL.  */\n+\n+lto_file *\n+lto_set_current_out_file (lto_file *file)\n+{\n+  lto_file *old_file = current_out_file;\n+  current_out_file = file;\n+  return old_file;\n+}\n+\n+\n+/* Returns the current output file.  */\n+\n+lto_file *\n+lto_get_current_out_file (void)\n+{\n+  return current_out_file;\n+}\n+\n+/* Mach-O section structure constructor.  */\n+\n+static lto_mach_o_section\n+mach_o_new_section (lto_mach_o_file *mach_o_file, const char *name)\n+{\n+  lto_mach_o_section ptr;\n+\n+  /* FIXME We could allocate these things on an obstack.  */\n+  ptr = XCNEW (struct lto_mach_o_section_d);\n+  if (name)\n+    {\n+      if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t\t   strlen(LTO_SECTION_NAME_PREFIX)) != 0)\n+\tsorry (\"not implemented: Mach-O writer for non-LTO sections\");\n+      ptr->name = xstrdup (name);\n+    }\n+\n+  VEC_safe_push (lto_mach_o_section, heap, mach_o_file->section_vec, ptr);\n+\n+  return ptr;\n+}\n+\n+/* Mach-O section data block structure constructor.  */\n+\n+static lto_mach_o_data\n+mach_o_new_data (lto_mach_o_section sec)\n+{\n+  lto_mach_o_data ptr, *chain_ptr_ptr;\n+\n+  /* FIXME We could allocate these things on an obstack.  */\n+  ptr = XCNEW (struct lto_mach_o_data_d);\n+\n+  chain_ptr_ptr = &sec->data_chain;\n+  while (*chain_ptr_ptr)\n+    chain_ptr_ptr = &(*chain_ptr_ptr)->next;\n+  *chain_ptr_ptr = ptr;\n+\n+  return ptr;\n+}\n+\n+/* Initialize FILE, an LTO file object for FILENAME.  Offset is the\n+   offset into FILE where the object is located (e.g. in an archive).  */\n+\n+static void\n+lto_file_init (lto_file *file, const char *filename, off_t offset)\n+{\n+  file->filename = filename;\n+  file->offset = offset;\n+}\n+\n+/* Return an error string after an error, or a predetermined one\n+   if ERRCODE is not -1.  */\n+\n+static const char *\n+mach_o_errmsg (int errcode)\n+{\n+  return strerror (errcode == -1 ? errno : errcode);\n+}\n+\n+/* Returns a hash code for P.  */\n+\n+static hashval_t\n+hash_name (const void *p)\n+{\n+  const struct lto_section_slot *s = (const struct lto_section_slot *) p;\n+  return (hashval_t) htab_hash_string (s->name);\n+}\n+\n+/* Returns nonzero if P1 and P2 are equal.  */\n+\n+static int\n+eq_name (const void *p1, const void *p2)\n+{\n+  const struct lto_section_slot *s1 =\n+    (const struct lto_section_slot *) p1;\n+  const struct lto_section_slot *s2 =\n+    (const struct lto_section_slot *) p2;\n+\n+  return strcmp (s1->name, s2->name) == 0;\n+}\n+\n+/* Build a hash table whose key is the section names and whose data is\n+   the start and size of each section in the .o file.  */\n+\n+htab_t\n+lto_obj_build_section_table (lto_file *lto_file) \n+{\n+  lto_mach_o_file *mach_o_file = (lto_mach_o_file *)lto_file;\n+  lto_mach_o_section sec;\n+  htab_t section_hash_table;\n+  off_t strtab_offs;\n+  ssize_t strtab_size;\n+  char *strtab = NULL;\n+  int i;\n+\n+  section_hash_table = htab_create (37, hash_name, eq_name, free);\n+\n+  /* Seek the string table.  */\n+  /* FIXME The segment name should be in darwin.h, but can we include it\n+     here in this file?  */\n+  for (i = 0;\n+       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    {\n+      if (strncmp (sec->u.section.segname, \"__GNU_LTO\", 16) != 0)\n+\tcontinue;\n+      if (strncmp (sec->u.section.sectname, \"__section_names\", 16) == 0)\n+        break;\n+    }\n+  if (! sec)\n+    {\n+      error (\"invalid Mach-O LTO object file: no __section_names section found\");\n+      goto done;\n+    }\n+  mach_o_file->section_names_section = sec;\n+\n+  if (mach_o_word_size () == 64)\n+    {\n+      strtab_offs = (off_t) get_uint32 (&sec->u.section_64.offset[0]);\n+      strtab_size = (size_t) get_uint64 (&sec->u.section_64.size[0]);\n+    }\n+  else\n+    {\n+      strtab_offs = (off_t) get_uint32 (&sec->u.section_32.offset[0]);\n+      strtab_size = (size_t) get_uint32 (&sec->u.section_32.size[0]);\n+    }\n+\n+  /* Seek to start of string table.  */\n+  if (strtab_offs != lseek (mach_o_file->fd,\n+\t\t\t    mach_o_file->base.offset + strtab_offs,\n+\t\t\t    SEEK_SET))\n+    {\n+      error (\"altered or invalid Mach-O object file\");\n+      goto done;\n+    }\n+\n+  strtab = XNEWVEC (char, strtab_size);\n+  if (read (mach_o_file->fd, strtab, strtab_size) != strtab_size)\n+    {\n+      error (\"invalid Mach-O LTO object file __section_names section\");\n+      goto done;\n+    }\n+\n+  /* Scan sections looking at names.  */\n+  for (i = 0;\n+       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    {\n+      struct lto_section_slot s_slot;\n+      void **slot;\n+      char *new_name;\n+      unsigned long stringoffset;\n+      char name[17];\n+\n+      /* Ignore non-LTO sections.  Also ignore the __section_names section\n+\t which does not need renaming.  */\n+      if (strncmp (sec->u.section.segname, \"__GNU_LTO\", 16) != 0)\n+\tcontinue;\n+      if (sec == mach_o_file->section_names_section)\n+        continue;\n+\n+      /* Try to extract the offset of the real name for this section from\n+\t __section_names.  */\n+      memcpy (&name[0], sec->u.section.sectname, 16);\n+      name[16] = '\\0';\n+      if (name[0] != '_' || name[1] != '_'\n+\t  || sscanf (&name[2], \"%08lX\", &stringoffset) != 1\n+\t  || strtab_size < (ssize_t) stringoffset)\n+\t{\n+\t  error (\"invalid Mach-O LTO section name string: %s\", name);\n+\t  continue;\n+\t}\n+\n+      new_name = XNEWVEC (char, strlen (strtab + stringoffset) + 1);\n+      strcpy (new_name, strtab + stringoffset);\n+      s_slot.name = new_name;\n+      slot = htab_find_slot (section_hash_table, &s_slot, INSERT);\n+      if (*slot == NULL)\n+\t{\n+\t  struct lto_section_slot *new_slot = XNEW (struct lto_section_slot);\n+\n+\t  new_slot->name = new_name;\n+\t  if (mach_o_word_size() == 64)\n+\t    {\n+\t      new_slot->start =\n+\t\t(intptr_t) get_uint32 (&sec->u.section_64.offset[0]);\n+\t      new_slot->len =\n+\t\t(size_t) get_uint64 (&sec->u.section_64.size[0]);\n+\t    }\n+\t  else\n+\t    {\n+\t      new_slot->start =\n+\t\t(intptr_t) get_uint32 (&sec->u.section_32.offset[0]);\n+\t      new_slot->len =\n+\t\t(size_t) get_uint32 (&sec->u.section_32.size[0]);\n+\t    }\n+\n+\t  *slot = new_slot;\n+\t}\n+      else\n+\t{\n+\t  error (\"two or more sections for %s:\", new_name);\n+\t  goto done;\n+\t}\n+    }\n+\n+ done:\n+  if (strtab)\n+    free (strtab);\n+  return section_hash_table;\n+}\n+\n+\n+/* Begin a new Mach-O section named NAME in the current output file.  */\n+\n+void\n+lto_obj_begin_section (const char *name)\n+{\n+  lto_mach_o_file *file;\n+\n+  if (strncmp (name, LTO_SECTION_NAME_PREFIX,\n+\t       strlen(LTO_SECTION_NAME_PREFIX)) != 0)\n+    sorry (\"not implemented: Mach-O writer for non-LTO sections\");\n+\n+  /* Grab the current output file and do some basic assertion checking.  */\n+  file = (lto_mach_o_file *) lto_get_current_out_file (),\n+  gcc_assert (file && file->writable && !file->scn);\n+\n+  /* Create a new section.  */\n+  file->scn = mach_o_new_section (file, name);\n+  if (!file->scn)\n+    fatal_error (\"could not create a new Mach-O section: %s\", mach_o_errmsg (-1));\n+}\n+\n+\n+/* Append DATA of length LEN to the current output section.  BASE is a pointer\n+   to the output page containing DATA.  It is freed once the output file has\n+   been written.  */\n+\n+void\n+lto_obj_append_data (const void *data, size_t len, void *block)\n+{\n+  lto_mach_o_file *file;\n+  lto_mach_o_data mach_o_data;\n+  struct lto_char_ptr_base *base = (struct lto_char_ptr_base *) block;\n+\n+  /* Grab the current output file and do some basic assertion checking.  */\n+  file = (lto_mach_o_file *) lto_get_current_out_file ();\n+  gcc_assert (file);\n+  gcc_assert (file->scn);\n+\n+  mach_o_data = mach_o_new_data (file->scn);\n+  if (!mach_o_data)\n+    fatal_error (\"could not append data to Mach-O section: %s\", mach_o_errmsg (-1));\n+\n+  mach_o_data->d_buf = CONST_CAST (void *, data);\n+  mach_o_data->d_size = len;\n+\n+  /* Chain all data blocks (from all sections) on one singly-linked\n+     list for freeing en masse after the file is closed.  */\n+  base->ptr = (char *)file->data;\n+  file->data = base;\n+}\n+\n+\n+/* End the current output section.  This just does some assertion checking\n+   and sets the current output file's scn member to NULL.  */\n+\n+void\n+lto_obj_end_section (void)\n+{\n+  lto_mach_o_file *file;\n+\n+  /* Grab the current output file and validate some basic assertions.  */\n+  file = (lto_mach_o_file *) lto_get_current_out_file ();\n+  gcc_assert (file);\n+  gcc_assert (file->scn);\n+\n+  file->scn = NULL;\n+}\n+\n+\n+/* Read a Mach-O header from MACH_O_FILE and validate it.\n+   The file descriptor in MACH_O_FILE points at the start of the file.\n+   If cached_mach_o_header is uninitialized, caches the results.\n+   On succes, returns true and moves file pointer to the start of the\n+   load commands.  On failure, returns false.  */\n+\n+static bool\n+validate_mach_o_header (lto_mach_o_file *mach_o_file)\n+{\n+  ssize_t i, n;\n+  unsigned char magic[4];\n+  uint32_t cputype;\n+  off_t startpos;\n+\n+  /* Known header magics for validation, as an array.  */\n+  static const unsigned int mach_o_known_formats[] = {\n+    MACH_O_MH_MAGIC,\n+    MACH_O_MH_CIGAM,\n+    MACH_O_MH_MAGIC_64,\n+    MACH_O_MH_CIGAM_64,\n+  };\n+#define MACH_O_NUM_KNOWN_FORMATS \\\n+  ((ssize_t) ARRAY_SIZE (mach_o_known_formats))\n+\n+  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n+  if (read (mach_o_file->fd, &magic, sizeof (magic)) != 4\n+      || lseek (mach_o_file->fd, -4, SEEK_CUR) != startpos)\n+    {\n+      error (\"cannot read file %s\", mach_o_file->base.filename);\n+      return false;\n+    }\n+\n+  for (i = 0; i < MACH_O_NUM_KNOWN_FORMATS; ++i)\n+    if (get_uint32 (&magic[0]) == mach_o_known_formats[i])\n+      break;\n+  if (i == MACH_O_NUM_KNOWN_FORMATS)\n+    goto not_for_target;\n+\n+  /* Check the endian-ness.  */\n+  if (BYTES_BIG_ENDIAN && magic[0] != 0xfe)\n+    goto not_for_target;\n+\n+  /* Set or check cached magic number.  */\n+  if (cached_mach_o_magic == 0)\n+    cached_mach_o_magic = get_uint32 (&magic[0]);\n+  else if (cached_mach_o_magic != get_uint32 (&magic[0]))\n+    goto not_for_target;\n+ \n+  n = mach_o_word_size () == 64\n+      ? sizeof (mach_o_header_64) : sizeof (mach_o_header_32);\n+  if (read (mach_o_file->fd, &mach_o_file->u.header, n) != n)\n+    goto not_for_target;\n+\n+  /* Is this a supported CPU?  */\n+  /* ??? Would be nice to validate the exact target architecture.  */\n+  cputype = get_uint32 (&mach_o_file->u.header.cputype[0]);\n+  if (cputype == MACH_O_CPU_TYPE_I386\n+      || cputype == MACH_O_CPU_TYPE_POWERPC)\n+    {\n+      if (mach_o_word_size () != 32)\n+        goto not_for_target;\n+    }\n+  else if (cputype == MACH_O_CPU_TYPE_X86_64\n+\t   || cputype == MACH_O_CPU_TYPE_POWERPC_64)\n+    {\n+      if (mach_o_word_size () != 64)\n+        goto not_for_target;\n+    }\n+\n+  /* Is this an MH_OBJECT file?  */\n+  if (get_uint32 (&mach_o_file->u.header.filetype[0]) != MACH_O_MH_OBJECT)\n+    error (\"Mach-O file %s is not an MH_OBJECT file\",\n+\t   mach_o_file->base.filename);\n+\n+  /* Save the header for future use.  */\n+  memcpy (&cached_mach_o_header, &mach_o_file->u.header,\n+\t  sizeof (cached_mach_o_header));\n+\n+  return true;\n+\n+ not_for_target:\n+  error (\"file %s is not a Mach-O object file for target\",\n+\t mach_o_file->base.filename);\n+  return false;\n+}\n+\n+\n+/* Read a Mach-O LC_SEGMENT command (32 bits) from MACH_O_FILE and\n+   validate it.\n+   The file descriptor in MACH_O_FILE points at the start of the load\n+   command.  On sucess, returns true and advances the file pointer\n+   past the end of the load command.  On failure, returns false.  */\n+\n+static bool\n+validate_mach_o_segment_command_32 (lto_mach_o_file *mach_o_file)\n+{\n+  mach_o_segment_command_32 seg_cmd_32;\n+  unsigned int i;\n+  ssize_t n;\n+  off_t startpos;\n+\n+  /* Fields we're interested in.  */\n+  uint32_t cmd;\n+  uint32_t cmdsize;\n+  uint32_t nsects;\n+\n+  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n+\n+  n = sizeof (mach_o_segment_command_32);\n+  if (read (mach_o_file->fd, (void *) &seg_cmd_32, n) != n)\n+    goto fail;\n+\n+  cmd = get_uint32 (&seg_cmd_32.cmd[0]);\n+  cmdsize = get_uint32 (&seg_cmd_32.cmdsize[0]);\n+  nsects = get_uint32 (&seg_cmd_32.nsects[0]);\n+  gcc_assert (cmd == MACH_O_LC_SEGMENT);\n+\n+  /* Validate section table entries.  */\n+  for (i = 0; i < nsects; i++)\n+    {\n+      mach_o_section_32 sec_32;\n+      lto_mach_o_section ltosec;\n+\n+      n = sizeof (mach_o_section_32);\n+      if (read (mach_o_file->fd, &sec_32, n) != n)\n+\tgoto fail;\n+\n+      /* ??? Perform some checks.  */\n+\n+      /* Looks ok, so record its details.  We don't read the \n+         string table or set up names yet; we'll do that when\n+\t we build the hash table.  */\n+      ltosec = mach_o_new_section (mach_o_file, NULL);\n+      memcpy (&ltosec->u.section_32, &sec_32, sizeof (sec_32));\n+    }\n+\n+  if (lseek (mach_o_file->fd, 0, SEEK_CUR) != startpos + cmdsize)\n+    goto fail;\n+\n+  return true;\n+\n+ fail:\n+  error (\"could not read LC_SEGMENT command in Mach-O file %s\",\n+\t mach_o_file->base.filename);\n+  return false;\n+}\n+\n+\n+/* Read a Mach-O LC_SEGMENT_64 command from MACH_O_FILE and validate it.\n+   The file descriptor in MACH_O_FILE points at the start of the load\n+   command.  On sucess, returns true and advances the file pointer\n+   past the end of the load command.  On failure, returns false.  */\n+\n+static bool\n+validate_mach_o_segment_command_64 (lto_mach_o_file *mach_o_file)\n+{\n+  mach_o_segment_command_64 seg_cmd_64;\n+  unsigned int i;\n+  ssize_t n;\n+  off_t startpos;\n+\n+  /* Fields we're interested in.  */\n+  uint32_t cmd;\n+  uint32_t cmdsize;\n+  uint32_t nsects;\n+\n+  startpos = lseek (mach_o_file->fd, 0, SEEK_CUR);\n+\n+  n = sizeof (mach_o_segment_command_64);\n+  if (read (mach_o_file->fd, (void *) &seg_cmd_64, n) != n)\n+    goto fail;\n+\n+  cmd = get_uint32 (&seg_cmd_64.cmd[0]);\n+  cmdsize = get_uint32 (&seg_cmd_64.cmdsize[0]);\n+  nsects = get_uint32 (&seg_cmd_64.nsects[0]);\n+  gcc_assert (cmd == MACH_O_LC_SEGMENT_64);\n+\n+  /* Validate section table entries.  */\n+  for (i = 0; i < nsects; i++)\n+    {\n+      mach_o_section_64 sec_64;\n+      lto_mach_o_section ltosec;\n+\n+      n = sizeof (mach_o_section_64);\n+      if (read (mach_o_file->fd, &sec_64, n) != n)\n+\tgoto fail;\n+\n+      /* ??? Perform some checks.  */\n+\n+      /* Looks ok, so record its details.  We don't read the \n+         string table or set up names yet; we'll do that when\n+\t we build the hash table.  */\n+      ltosec = mach_o_new_section (mach_o_file, NULL);\n+      memcpy (&ltosec->u.section_64, &sec_64, sizeof (sec_64));\n+    }\n+\n+  if (lseek (mach_o_file->fd, 0, SEEK_CUR) != startpos + cmdsize)\n+    goto fail;\n+\n+  return true;\n+\n+ fail:\n+  error (\"could not read LC_SEGMENT_64 command in Mach-O file %s\",\n+\t mach_o_file->base.filename);\n+  return false;\n+}\n+\n+/* Read a Mach-O load commands from MACH_O_FILE and validate it.\n+   The file descriptor in MACH_O_FILE points at the start of the load\n+   command.  On sucess, returns true and advances the file pointer\n+   past the end of the load command.  On failure, returns false.  */\n+\n+static bool\n+validate_mach_o_load_command (lto_mach_o_file *mach_o_file)\n+{\n+  mach_o_load_command load_command;\n+  uint32_t cmd;\n+  uint32_t cmdsize;\n+  ssize_t n;\n+\n+  n = sizeof (load_command);\n+  if (read (mach_o_file->fd, &load_command, n) != n)\n+    {\n+      error (\"could not read load commands in Mach-O file %s\",\n+\t     mach_o_file->base.filename);\n+      return false;\n+    }\n+  lseek (mach_o_file->fd, -1 * (off_t) sizeof (load_command), SEEK_CUR);\n+\n+  cmd = get_uint32 (&load_command.cmd[0]);\n+  cmdsize = get_uint32 (&load_command.cmdsize[0]);\n+  switch (cmd)\n+    {\n+    case MACH_O_LC_SEGMENT:\n+      return validate_mach_o_segment_command_32 (mach_o_file);\n+    case MACH_O_LC_SEGMENT_64:\n+      return validate_mach_o_segment_command_64 (mach_o_file);\n+\n+    default:\n+      /* Just skip over it.  */\n+      lseek (mach_o_file->fd, cmdsize, SEEK_CUR);\n+      return true;\n+    }\n+}\n+\n+/* Validate's MACH_O_FILE's executable header and, if cached_mach_o_header is\n+   uninitialized, caches the results.  Also records the section header string\n+   table's section index.  Returns true on success, false on failure.  */\n+\n+static bool\n+validate_file (lto_mach_o_file *mach_o_file)\n+{\n+  uint32_t i, ncmds;\n+\n+  /* Read and sanity check the raw header.  */\n+  if (! validate_mach_o_header (mach_o_file))\n+    return false;\n+\n+  ncmds = get_uint32 (&mach_o_file->u.header.ncmds[0]);\n+  for (i = 0; i < ncmds; ++i)\n+    if (! validate_mach_o_load_command (mach_o_file))\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Initialize MACH_O_FILE's executable header using cached data from previously\n+   read files.  */\n+\n+static void\n+init_mach_o_header (lto_mach_o_file *mach_o_file)\n+{\n+  gcc_assert (cached_mach_o_magic != 0);\n+  memcpy (&mach_o_file->u.header,\n+\t  &cached_mach_o_header,\n+\t  sizeof (mach_o_file->u.header));\n+  put_uint32 (&mach_o_file->u.header.ncmds[0], 0);\n+  put_uint32 (&mach_o_file->u.header.sizeofcmds[0], 0);\n+}\n+\n+/* Open Mach-O file FILENAME.  If WRITABLE is true, the file is opened for write\n+   and, if necessary, created.  Otherwise, the file is opened for reading.\n+   Returns the opened file.  */\n+\n+lto_file *\n+lto_obj_file_open (const char *filename, bool writable)\n+{\n+  lto_mach_o_file *mach_o_file;\n+  lto_file *result = NULL;\n+  off_t offset;\n+  const char *offset_p;\n+  char *fname;\n+  struct stat statbuf;\n+\n+  offset_p = strchr (filename, '@');\n+  if (!offset_p)\n+    {\n+      fname = xstrdup (filename);\n+      offset = 0;\n+    }\n+  else\n+    {\n+      /* The file started with '@' is a file containing command line\n+\t options.  Stop if it doesn't exist.  */\n+      if (offset_p == filename)\n+\tfatal_error (\"command line option file '%s' does not exist\",\n+\t\t     filename);\n+\n+      fname = (char *) xmalloc (offset_p - filename + 1);\n+      memcpy (fname, filename, offset_p - filename);\n+      fname[offset_p - filename] = '\\0';\n+      offset_p += 3; /* skip the @0x */\n+      offset = lto_parse_hex (offset_p);\n+    }\n+\n+  /* Set up.  */\n+  mach_o_file = XCNEW (lto_mach_o_file);\n+  result = (lto_file *) mach_o_file;\n+  lto_file_init (result, fname, offset);\n+  mach_o_file->fd = -1;\n+  mach_o_file->writable = writable;\n+\n+  /* Open the file.  */\n+  mach_o_file->fd = open (fname,\n+    O_BINARY | (writable ? O_WRONLY | O_CREAT | O_TRUNC : O_RDONLY), 0666);\n+\n+  if (mach_o_file->fd == -1)\n+    {\n+      error (\"could not open file %s\", fname);\n+      goto fail;\n+    }\n+\n+  if (stat (fname, &statbuf) < 0)\n+    {\n+      error (\"could not stat file %s\", fname);\n+      goto fail;\n+    }\n+\n+  mach_o_file->file_size = statbuf.st_size;\n+\n+  /* If the object is in an archive, get it out.  */\n+  if (offset != 0)\n+    {\n+      char ar_tail[12];\n+      int size;\n+\n+      /* Surely not?  */\n+      gcc_assert (!writable);\n+\n+      /* Seek to offset, or error.  */\n+      if (lseek (mach_o_file->fd, offset, SEEK_SET) != (ssize_t) offset)\n+\t{\n+\t  error (\"could not find archive member @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+\n+      /* Now seek back 12 chars and read the tail of the AR header to\n+         find the length of the member file.  */\n+      if (lseek (mach_o_file->fd, -12, SEEK_CUR) < 0\n+\t  || read (mach_o_file->fd, ar_tail, 12) != 12\n+\t  || lseek (mach_o_file->fd, 0, SEEK_CUR) != (ssize_t) offset\n+\t  || ar_tail[10] != '`' || ar_tail[11] != '\\n')\n+\t{\n+\t  error (\"could not find archive header @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+\n+      ar_tail[11] = 0;\n+      if (sscanf (ar_tail, \"%d\", &size) != 1)\n+\t{\n+\t  error (\"invalid archive header @0x%lx\", (long) offset);\n+\t  goto fail;\n+\t}\n+      mach_o_file->file_size = size;\n+    }\n+\n+  if (writable)\n+    {\n+      init_mach_o_header (mach_o_file);\n+    }\n+  else\n+    if (! validate_file (mach_o_file))\n+      goto fail;\n+\n+  return result;\n+\n+ fail:\n+  if (result)\n+    lto_obj_file_close (result);\n+  return NULL;\n+}\n+\n+\n+/* Write the data in MACH_O_FILE to a real Mach-O binary object.\n+   We write a header, a segment load command, and section data.  */\n+\n+static bool\n+mach_o_write_object_file (lto_mach_o_file *mach_o_file)\n+{\n+  lto_mach_o_section sec, snsec;\n+  lto_mach_o_data snsec_data;\n+  ssize_t hdrsize, cmdsize, secsize;\n+  size_t num_sections, snsec_size, total_sec_size;\n+  unsigned int sec_offs, strtab_offs;\n+  int i;\n+  bool write_err = false;\n+\n+  /* The number of sections we will write is the number of sections added by\n+     the streamer, plus 1 for the section names section.  */\n+  num_sections = VEC_length (lto_mach_o_section, mach_o_file->section_vec) + 1;\n+\n+  /* Calculate the size of the basic data structures on disk.  */\n+  if (mach_o_word_size () == 64)\n+    {\n+      hdrsize = sizeof (mach_o_header_64);\n+      secsize = sizeof (mach_o_section_64);\n+      cmdsize = sizeof (mach_o_segment_command_64) + num_sections * secsize;\n+    }\n+  else\n+    {\n+      hdrsize = sizeof (mach_o_header_32);\n+      secsize = sizeof (mach_o_section_32);\n+      cmdsize = sizeof (mach_o_segment_command_32) + num_sections * secsize;\n+    }\n+ \n+  /* Allocate the section names section.  */\n+  snsec_size = 0;\n+  for (i = 0;\n+       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    snsec_size += strlen (sec->name) + 1;\n+  snsec = mach_o_new_section (mach_o_file, NULL);\n+  snsec->name = LTO_NAMES_SECTION;\n+  snsec_data = mach_o_new_data (snsec);\n+  snsec_data->d_buf = XCNEWVEC (char, snsec_size);\n+  snsec_data->d_size = snsec_size;\n+\n+  /* Position all the sections, and fill out their headers.  */\n+  sec_offs = hdrsize + cmdsize;\n+  strtab_offs = 0;\n+  total_sec_size = 0;\n+  for (i = 0;\n+       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    {\n+      lto_mach_o_data data;\n+      size_t data_size;\n+      /* Put the section and segment names.  Add the section name to the\n+         section names section (unless, of course, this *is* the section\n+\t names section).  */\n+      if (sec == snsec)\n+\tsnprintf (sec->u.section.sectname, 16, \"%s\", LTO_NAMES_SECTION);\n+      else\n+\t{\n+\t  sprintf (sec->u.section.sectname, \"__%08X\", strtab_offs);\n+\t  memcpy ((char *) snsec_data->d_buf + strtab_offs, sec->name, strlen (sec->name));\n+\t}\n+      memcpy (&sec->u.section.segname[0],\n+\t      LTO_SEGMENT_NAME, strlen (LTO_SEGMENT_NAME));\n+\n+      /* Add layout and attributes.  */\n+      for (data = sec->data_chain, data_size = 0; data; data = data->next)\n+\tdata_size += data->d_size;\n+      if (mach_o_word_size () == 64)\n+\t{\n+\t  put_uint64 (&sec->u.section_64.addr[0], total_sec_size); \n+\t  put_uint64 (&sec->u.section_64.size[0], data_size); \n+\t  put_uint32 (&sec->u.section_64.offset[0], sec_offs); \n+\t  put_uint32 (&sec->u.section_64.flags[0], MACH_O_S_ATTR_DEBUG);\n+\t}\n+      else\n+\t{\n+\t  put_uint32 (&sec->u.section_64.addr[0], total_sec_size); \n+\t  put_uint32 (&sec->u.section_32.size[0], data_size); \n+\t  put_uint32 (&sec->u.section_32.offset[0], sec_offs); \n+\t  put_uint32 (&sec->u.section_32.flags[0], MACH_O_S_ATTR_DEBUG);\n+\t}\n+\n+      sec_offs += data_size;\n+      total_sec_size += data_size;\n+      strtab_offs += strlen (sec->name) + 1;\n+    }\n+\n+  /* We can write the data now.  As there's no way to indicate an error return\n+     from this hook, error handling is limited to not wasting our time doing\n+     any more writes in the event that any one fails.  */\n+\n+  /* Write the header.  */\n+  put_uint32 (&mach_o_file->u.header.ncmds[0], 1);\n+  put_uint32 (&mach_o_file->u.header.sizeofcmds[0], cmdsize);\n+  write_err = (write (mach_o_file->fd,\n+\t\t      &mach_o_file->u.header, hdrsize) != hdrsize);\n+  /* Write the segment load command.  */\n+  if (mach_o_word_size () == 64)\n+    {\n+      mach_o_segment_command_64 lc;\n+      ssize_t lc_size = sizeof (lc);\n+      memset (&lc, 0, lc_size);\n+      put_uint32 (&lc.cmd[0], MACH_O_LC_SEGMENT_64);\n+      put_uint32 (&lc.cmdsize[0], cmdsize);\n+      put_uint64 (&lc.fileoff[0], hdrsize + cmdsize);\n+      put_uint64 (&lc.filesize[0], total_sec_size);\n+      put_uint32 (&lc.nsects[0], num_sections);\n+      write_err = (write (mach_o_file->fd, &lc, lc_size) != lc_size);\n+    }\n+  else\n+    {\n+      mach_o_segment_command_32 lc;\n+      ssize_t lc_size = sizeof (lc);\n+      memset (&lc, 0, lc_size);\n+      put_uint32 (&lc.cmd[0], MACH_O_LC_SEGMENT);\n+      put_uint32 (&lc.cmdsize[0], cmdsize);\n+      put_uint32 (&lc.fileoff[0], hdrsize + cmdsize);\n+      put_uint32 (&lc.filesize[0], total_sec_size);\n+      put_uint32 (&lc.nsects[0], num_sections);\n+      write_err = (write (mach_o_file->fd, &lc, lc_size) != lc_size);\n+    }\n+  for (i = 0;\n+       !write_err\n+       && VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    write_err = (write (mach_o_file->fd,\n+\t\t\t&sec->u.section, secsize) != secsize);\n+\n+  gcc_assert (lseek (mach_o_file->fd, 0, SEEK_CUR) == hdrsize + cmdsize);\n+\n+  /* Write the section data.  */\n+  for (i = 0;\n+       !write_err\n+       && VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    {\n+      lto_mach_o_data data;\n+\n+      for (data = sec->data_chain; data; data = data->next)\n+\t{\n+\t  if (!write_err)\n+\t    write_err = (write (mach_o_file->fd, data->d_buf, data->d_size)\n+\t\t\t != data->d_size);\n+\t  else\n+\t    break;\n+\t}\n+    }\n+\n+  return !write_err;\n+}\n+\n+/* Close Mach-O file FILE and clean up any associated data structures.  If FILE\n+   was opened for writing, the file's Mach-O data is written at this time.  Any\n+   cached data buffers are freed.  */\n+\n+void\n+lto_obj_file_close (lto_file *file)\n+{\n+  lto_mach_o_file *mach_o_file = (lto_mach_o_file *) file;\n+  struct lto_char_ptr_base *cur, *tmp;\n+  lto_mach_o_section sec;\n+  bool write_err = false;\n+  int i;\n+\n+  /* If this file is open for writing, write a Mach-O object file.  */\n+  if (mach_o_file->writable)\n+    {\n+      if (! mach_o_write_object_file (mach_o_file))\n+        fatal_error (\"cannot write Mach-O object file\");\n+    }\n+\n+  /* Close the file, we're done.  */\n+  if (mach_o_file->fd != -1)\n+    close (mach_o_file->fd);\n+\n+  /* Free any data buffers.  */\n+  cur = mach_o_file->data;\n+  while (cur)\n+    {\n+      tmp = cur;\n+      cur = (struct lto_char_ptr_base *) cur->ptr;\n+      free (tmp);\n+    }\n+\n+  /* Free any sections and their data chains.  */\n+  for (i = 0;\n+       VEC_iterate (lto_mach_o_section, mach_o_file->section_vec, i, sec);\n+       i++)\n+    {\n+      lto_mach_o_data curdata, nextdata;\n+      curdata = sec->data_chain;\n+      while (curdata)\n+\t{\n+\t  nextdata = curdata->next;\n+\t  free (curdata);\n+\t  curdata = nextdata;\n+\t}\n+      free (sec);\n+    }\n+  VEC_free (lto_mach_o_section, heap, mach_o_file->section_vec);\n+\n+  free (file);\n+\n+  /* If there was an error, mention it.  */\n+  if (write_err)\n+    error (\"I/O error writing Mach-O output file\");\n+}\n+"}, {"sha": "dcd0de3ca3f2f08bc95d4bceb167b5a07f7f26cc", "filename": "gcc/lto/lto-macho.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-macho.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto-macho.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-macho.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -0,0 +1,251 @@\n+/* LTO routines for Mach-O object files.\n+   Copyright 2010 Free Software Foundation, Inc.\n+   Contributed by Steven Bosscher.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LTO_MACH_O_H\n+#define LTO_MACH_O_H\n+\n+/* On-disk file structures.  */\n+\n+/* Mach-O header (32 bits version).  */\n+struct mach_o_header_32\n+{\n+  unsigned char magic[4];\t/* Magic number.  */\n+  unsigned char cputype[4];\t/* CPU that this object is for.  */\n+  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n+  unsigned char filetype[4];\t/* Type of file.  */\n+  unsigned char ncmds[4];\t/* Number of load commands.  */\n+  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n+  unsigned char flags[4];\t/* Flags for special featues.  */\n+};\n+typedef struct mach_o_header_32 mach_o_header_32;\n+\n+/* Mach-O header (64 bits version).  */\n+struct mach_o_header_64\n+{\n+  unsigned char magic[4];\t/* Magic number.  */\n+  unsigned char cputype[4];\t/* CPU that this object is for.  */\n+  unsigned char cpusubtype[4];\t/* CPU subtype.  */\n+  unsigned char filetype[4];\t/* Type of file.  */\n+  unsigned char ncmds[4];\t/* Number of load commands.  */\n+  unsigned char sizeofcmds[4];\t/* Total size of load commands.  */\n+  unsigned char flags[4];\t/* Flags for special featues.  */\n+  unsigned char reserved[4];\t/* Reserved.  Duh.  */\n+};\n+typedef struct mach_o_header_64 mach_o_header_64;\n+\n+/* Magic number.  */\n+#define MACH_O_MH_MAGIC\t\t\t0xfeedface\n+#define MACH_O_MH_CIGAM\t\t\t0xcefaedfe\n+#define MACH_O_MH_MAGIC_64\t\t0xfeedfacf\n+#define MACH_O_MH_CIGAM_64\t\t0xcffaedfe\n+\n+/* Supported CPU types.  */\n+#define MACH_O_CPU_TYPE_I386\t\t7\n+#define MACH_O_CPU_TYPE_X86_64\t\t7 + 0x1000000\n+#define MACH_O_CPU_TYPE_POWERPC\t\t18\n+#define MACH_O_CPU_TYPE_POWERPC_64\t18 + 0x1000000\n+\n+/* Supported file types.  */\n+#define MACH_O_MH_OBJECT\t\t0x01\n+\n+/* Mach-O load command data structure.  */\n+struct mach_o_load_command\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command.  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n+};\n+typedef struct mach_o_load_command mach_o_load_command;\n+\n+/* Supported load commands.  We support only the segment load commands.  */\n+#define MACH_O_LC_SEGMENT\t\t0x01\n+#define MACH_O_LC_SEGMENT_64\t\t0x19\n+\n+/* LC_SEGMENT load command.  */\n+struct mach_o_segment_command_32\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT).  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n+  unsigned char segname[16];\t/* Name of this segment.  */\n+  unsigned char vmaddr[4];\t/* Virtual memory address of this segment.  */\n+  unsigned char vmsize[4];\t/* Size there, in bytes.  */\n+  unsigned char fileoff[4];\t/* Offset in bytes of the data to be mapped.  */\n+  unsigned char filesize[4];\t/* Size in bytes on disk.  */\n+  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n+  unsigned char initprot[4];\t/* Initial vmem protection.  */\n+  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n+  unsigned char flags[4];\t/* Flags that affect the loading.  */\n+};\n+typedef struct mach_o_segment_command_32 mach_o_segment_command_32;\n+\n+/* LC_SEGMENT_64 load command.  Only nsects matters for us, really.  */\n+struct mach_o_segment_command_64\n+{\n+  unsigned char cmd[4];\t\t/* The type of load command (LC_SEGMENT_64).  */\n+  unsigned char cmdsize[4];\t/* Size in bytes of load command data structure.  */\n+  unsigned char segname[16];\t/* Name of this segment.  */\n+  unsigned char vmaddr[8];\t/* Virtual memory address of this segment.  */\n+  unsigned char vmsize[8];\t/* Size there, in bytes.  */\n+  unsigned char fileoff[8];\t/* Offset in bytes of the data to be mapped.  */\n+  unsigned char filesize[8];\t/* Size in bytes on disk.  */\n+  unsigned char maxprot[4];\t/* Maximum permitted vmem protection.  */\n+  unsigned char initprot[4];\t/* Initial vmem protection.  */\n+  unsigned char nsects[4];\t/* Number of sections in this segment.  */\n+  unsigned char flags[4];\t/* Flags that affect the loading.  */\n+};\n+typedef struct mach_o_segment_command_64 mach_o_segment_command_64;\n+\n+/* A Mach-O 32-bits section.  */\n+struct mach_o_section_32\n+{\n+  unsigned char sectname[16];\t/* Section name.  */\n+  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n+  unsigned char addr[4];\t/* Address of this section in memory.  */\n+  unsigned char size[4];\t/* Size in bytes of this section.  */\n+  unsigned char offset[4];\t/* File offset of this section.  */\n+  unsigned char align[4];\t/* log2 of this section's alignment.  */\n+  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n+  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n+  unsigned char flags[4];\t/* Section flags/attributes.  */\n+  unsigned char reserved1[4];\n+  unsigned char reserved2[4];\n+};\n+typedef struct mach_o_section_32 mach_o_section_32;\n+\n+/* A Mach-O 64-bits section.  */\n+struct mach_o_section_64\n+{\n+  unsigned char sectname[16];\t/* Section name.  */\n+  unsigned char segname[16];\t/* Segment that the section belongs to.  */\n+  unsigned char addr[8];\t/* Address of this section in memory.  */\n+  unsigned char size[8];\t/* Size in bytes of this section.  */\n+  unsigned char offset[4];\t/* File offset of this section.  */\n+  unsigned char align[4];\t/* log2 of this section's alignment.  */\n+  unsigned char reloff[4];\t/* File offset of this section's relocs.  */\n+  unsigned char nreloc[4];\t/* Number of relocs for this section.  */\n+  unsigned char flags[4];\t/* Section flags/attributes.  */\n+  unsigned char reserved1[4];\n+  unsigned char reserved2[4];\n+  unsigned char reserved3[4];\n+};\n+typedef struct mach_o_section_64 mach_o_section_64;\n+\n+/* Flags for Mach-O sections.  LTO sections are marked with S_ATTR_DEBUG\n+   to instruct the linker to ignore the sections.  */\n+#define MACH_O_S_ATTR_DEBUG\t\t\t0x02000000\n+\n+/* In-memory file structures.  */\n+\n+/* Section data in output files is made of these.  */\n+struct lto_mach_o_data_d\n+{\n+  /* Pointer to data block.  */\n+  void *d_buf;\n+\n+  /* Size of data block.  */\n+  ssize_t d_size;\n+\n+  /* Next data block for this section.  */\n+  struct lto_mach_o_data_d *next;\n+};\n+typedef struct lto_mach_o_data_d *lto_mach_o_data;\n+\n+/* This struct tracks the data for a section.  */\n+struct lto_mach_o_section_d\n+{\n+  /* Singly-linked list of section's data blocks.  */\n+  lto_mach_o_data data_chain;\n+\n+  /* Offset in string table of the section name.  */\n+  size_t strtab_offs;\n+\n+  /* Section name.  */\n+  const char *name;\n+\n+  /* Number of trailing padding bytes needed.  */\n+  ssize_t pad_needed;\n+\n+  /* Raw section header data.  */\n+  size_t section_size;\n+  union {\n+    struct {\n+      char sectname[16];\n+      char segname[16];\n+    } section;\n+    mach_o_section_32 section_32;\n+    mach_o_section_64 section_64;\n+  } u;\n+\n+  /* Next section for this file.  */\n+  struct lto_mach_o_section_d *next;\n+};\n+typedef struct lto_mach_o_section_d *lto_mach_o_section;\n+DEF_VEC_P (lto_mach_o_section);\n+DEF_VEC_ALLOC_P (lto_mach_o_section, heap);\n+\n+/* A Mach-O file.  */\n+struct lto_mach_o_file_d\n+{\n+  /* The base information.  */\n+  lto_file base;\n+\n+  /* Common file members:  */\n+\n+  /* The system file descriptor for the file.  */\n+  int fd;\n+\n+  /* The file's overall header.  */\n+  union {\n+    /* We make use here of the fact that section_32 and section_64\n+       have the same layout (except for section_64.reserved3).  We\n+       read the struct of proper size, but only address the first\n+       member of this union.  */\n+    mach_o_header_64 header;\n+    mach_o_header_32 header_32;\n+    mach_o_header_64 header_64;\n+  } u;\n+\n+  /* All sections in a varray.  */\n+  VEC(lto_mach_o_section, heap) *section_vec;\n+\n+  /* Readable file members:  */\n+\n+  /* File total size.  */\n+  off_t file_size;\n+\n+  /* True if this file is open for writing.  */\n+  bool writable;\n+\n+  /* Section containing the __section_names section.  */\n+  lto_mach_o_section section_names_section;\n+\n+  /* Writable file members:  */\n+\n+  /* The currently active section.  */\n+  lto_mach_o_section scn;\n+\n+  /* Linked list of data which must be freed *after* the file has been\n+     closed.  This is an annoying limitation of libelf.  Which has been\n+     faithfully reproduced here.  */\n+  struct lto_char_ptr_base *data;\n+};\n+typedef struct lto_mach_o_file_d lto_mach_o_file;\n+\n+#endif /* LTO_MACH_O_H */\n+"}, {"sha": "7f8e108054d020751199bf6e80b8b8169310070a", "filename": "gcc/lto/lto.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Flto%2Flto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -1,5 +1,5 @@\n /* LTO declarations.\n-   Copyright 2009 Free Software Foundation, Inc.\n+   Copyright 2009, 2010 Free Software Foundation, Inc.\n    Contributed by CodeSourcery, Inc.\n \n This file is part of GCC.\n@@ -28,6 +28,7 @@ typedef struct lto_file_struct\n {\n   /* The name of the file.  */\n   const char *filename;\n+  /* The offset for the object inside an ar archive file (or zero).  */\n   off_t offset;\n } lto_file;\n "}, {"sha": "72cf9307679a3b3f7e77cf1475eed555e81a33b6", "filename": "gcc/target-def.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -204,6 +204,14 @@\n #define TARGET_ASM_FILE_END hook_void_void\n #endif\n \n+#ifndef TARGET_ASM_LTO_START\n+#define TARGET_ASM_LTO_START hook_void_void\n+#endif\n+\n+#ifndef TARGET_ASM_LTO_END\n+#define TARGET_ASM_LTO_END hook_void_void\n+#endif\n+\n #ifndef TARGET_ASM_CODE_END\n #define TARGET_ASM_CODE_END hook_void_void\n #endif\n@@ -296,6 +304,8 @@\n                         TARGET_ASM_CAN_OUTPUT_MI_THUNK,         \\\n                         TARGET_ASM_FILE_START,                  \\\n                         TARGET_ASM_FILE_END,\t\t\t\\\n+                        TARGET_ASM_LTO_START,\t\t\t\\\n+                        TARGET_ASM_LTO_END,\t\t\t\\\n                         TARGET_ASM_CODE_END,\t\t\t\\\n \t\t\tTARGET_ASM_EXTERNAL_LIBCALL,            \\\n                         TARGET_ASM_MARK_DECL_PRESERVED,\t\t\\"}, {"sha": "2c9ab8598fae31c058387b7fd2823c3a80d44485", "filename": "gcc/target.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c082f9f3173cf8cfa7b57107ffb6c6999f4872dc/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=c082f9f3173cf8cfa7b57107ffb6c6999f4872dc", "patch": "@@ -238,6 +238,14 @@ struct gcc_target\n        translation unit.  */\n     void (*file_end) (void);\n \n+    /* Output any boilerplate text needed at the beginning of an\n+       LTO output stream.  */\n+    void (*lto_start) (void);\n+\n+    /* Output any boilerplate text needed at the end of an\n+       LTO output stream.  */\n+    void (*lto_end) (void);\n+\n     /* Output any boilerplace text needed at the end of a\n        translation unit before debug and unwind info is emitted.  */\n     void (*code_end) (void);"}]}