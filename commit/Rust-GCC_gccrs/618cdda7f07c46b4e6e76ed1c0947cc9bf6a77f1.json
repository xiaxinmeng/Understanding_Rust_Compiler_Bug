{"sha": "618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE4Y2RkYTdmMDdjNDZiNGU2ZTc2ZWQxYzA5NDdjYzliZjZhNzdmMQ==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2001-02-25T09:43:03Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2001-02-25T09:43:03Z"}, "message": "cppinit.c (builtin_array): Update.\n\n        * cppinit.c (builtin_array): Update.\n        (init_builtins): Flag builtins to warn if redefined or\n        undefined.  Define __GXX_WEAK as a normal macro.\n        * cpplib.c (do_undef): Warn if flagged NODE_WARN.\n        * cpplib.h (NODE_WARN): New flag.\n        * cppmacro.c (builtin_macro): Remove handling of __GXX_WEAK__.\n        Handle __STDC__ as a builtin only on Solaris.\n        (warn_of_redefinition): Renamed from check_macro_definition.\n        Reverse sense of test.  Always warn if NODE_WARN.\n        (_cpp_create_definition): Use warn_of_redefinition.  Flag\n        any macro beginning with \"__STDC_\" to require a mandatory\n        warning if redefined or undefined.\n\nFrom-SVN: r40053", "tree": {"sha": "9b8fa1374187361bdd59562c00a312f85f75d707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b8fa1374187361bdd59562c00a312f85f75d707"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/comments", "author": null, "committer": null, "parents": [{"sha": "f5500e44c001be600e34e1191445a8e704b58c82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5500e44c001be600e34e1191445a8e704b58c82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5500e44c001be600e34e1191445a8e704b58c82"}], "stats": {"total": 92, "additions": 55, "deletions": 37}, "files": [{"sha": "8fdb823e930d0a5cc23c80b42cc39dc023dc4670", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "patch": "@@ -1,3 +1,18 @@\n+2001-02-25  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+        * cppinit.c (builtin_array): Update.\n+        (init_builtins): Flag builtins to warn if redefined or\n+        undefined.  Define __GXX_WEAK as a normal macro.\n+        * cpplib.c (do_undef): Warn if flagged NODE_WARN.\n+        * cpplib.h (NODE_WARN): New flag.\n+        * cppmacro.c (builtin_macro): Remove handling of __GXX_WEAK__.\n+        Handle __STDC__ as a builtin only on Solaris.\n+        (warn_of_redefinition): Renamed from check_macro_definition.\n+        Reverse sense of test.  Always warn if NODE_WARN.\n+        (_cpp_create_definition): Use warn_of_redefinition.  Flag\n+        any macro beginning with \"__STDC_\" to require a mandatory\n+        warning if redefined or undefined.\n+\n 2001-02-24  Zack Weinberg  <zackw@stanford.edu>\n \n \t* xm-interix.h, xm-lynx.h, alpha/xm-vms.h, convex/xm-convex.h,"}, {"sha": "d8efb4b559c3cc0487696d21c0c74d9798048955", "filename": "gcc/cppinit.c", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "patch": "@@ -607,7 +607,9 @@ cpp_destroy (pfile)\n /* This structure defines one built-in identifier.  A node will be\n    entered in the hash table under the name NAME, with value VALUE (if\n    any).  If flags has OPERATOR, the node's operator field is used; if\n-   flags has BUILTIN the node's builtin field is used.\n+   flags has BUILTIN the node's builtin field is used.  Macros that are\n+   known at build time should not be flagged BUILTIN, as then they do\n+   not appear in macro dumps with e.g. -dM or -dD.\n \n    Two values are not compile time constants, so we tag\n    them in the FLAGS field instead:\n@@ -632,7 +634,6 @@ struct builtin\n #define OPERATOR  \t0x10\n \n #define B(n, t)       { U n, 0, t, 0, BUILTIN, sizeof n - 1 }\n-#define BC(n, t)      { U n, 0, t, 0, BUILTIN | CPLUS, sizeof n - 1 }\n #define C(n, v)       { U n, v, 0, 0, 0, sizeof n - 1 }\n #define X(n, f)       { U n, 0, 0, 0, f, sizeof n - 1 }\n #define O(n, c, f)    { U n, 0, 0, c, OPERATOR | f, sizeof n - 1 }\n@@ -644,8 +645,6 @@ static const struct builtin builtin_array[] =\n   B(\"__BASE_FILE__\",\t BT_BASE_FILE),\n   B(\"__LINE__\",\t\t BT_SPECLINE),\n   B(\"__INCLUDE_LEVEL__\", BT_INCLUDE_LEVEL),\n-  B(\"__STDC__\",\t\t BT_STDC),\n-  BC(\"__GXX_WEAK__\",     BT_WEAK),\n \n   X(\"__VERSION__\",\t\tVERS),\n   X(\"__USER_LABEL_PREFIX__\",\tULP),\n@@ -663,6 +662,11 @@ static const struct builtin builtin_array[] =\n #ifndef NO_BUILTIN_WINT_TYPE\n   C(\"__WINT_TYPE__\",\t\tWINT_TYPE),\n #endif\n+#ifdef STDC_0_IN_SYSTEM_HEADERS\n+  B(\"__STDC__\",\t\t BT_STDC),\n+#else\n+  C(\"__STDC__\",\t\t \"1\"),\n+#endif\n \n   /* Named operators known to the preprocessor.  These cannot be #defined\n      and always have their stated meaning.  They are treated like normal\n@@ -714,7 +718,7 @@ init_builtins (pfile)\n \t  else\n \t    {\n \t      hp->type = NT_MACRO;\n-\t      hp->flags |= NODE_BUILTIN;\n+\t      hp->flags |= NODE_BUILTIN | NODE_WARN;\n \t      hp->value.builtin = b->builtin;\n \t    }\n \t}\n@@ -746,7 +750,13 @@ init_builtins (pfile)\n     }\n \n   if (CPP_OPTION (pfile, cplusplus))\n-    _cpp_define_builtin (pfile, \"__cplusplus 1\");\n+    {\n+      _cpp_define_builtin (pfile, \"__cplusplus 1\");\n+      if (SUPPORTS_ONE_ONLY)\n+\t_cpp_define_builtin (pfile, \"__GXX_WEAK__ 1\");\n+      else\n+\t_cpp_define_builtin (pfile, \"__GXX_WEAK__ 0\");\n+    }\n   if (CPP_OPTION (pfile, objc))\n     _cpp_define_builtin (pfile, \"__OBJC__ 1\");\n "}, {"sha": "0ebd093f6135bd615e2b4d2db04156d8365b2855", "filename": "gcc/cpplib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "patch": "@@ -477,7 +477,7 @@ do_undef (pfile)\n       if (pfile->cb.undef)\n \t(*pfile->cb.undef) (pfile, node);\n \n-      if (node->flags & NODE_BUILTIN)\n+      if (node->flags & NODE_WARN)\n \tcpp_warning (pfile, \"undefining \\\"%s\\\"\", node->name);\n \n       _cpp_free_definition (node);"}, {"sha": "099379285a756305840b3bae881c171506fe1f66", "filename": "gcc/cpplib.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "patch": "@@ -444,6 +444,7 @@ enum cpp_buffer_type {BUF_FAKE, BUF_FILE, BUF_BUILTIN,\n #define NODE_POISONED\t(1 << 1)\t/* Poisoned identifier.  */\n #define NODE_BUILTIN\t(1 << 2)\t/* Builtin macro.  */\n #define NODE_DIAGNOSTIC (1 << 3)\t/* Possible diagnostic when lexed.  */\n+#define NODE_WARN\t(1 << 4)\t/* Warn if redefined or undefined.  */\n \n /* Different flavors of hash node.  */\n enum node_type"}, {"sha": "4d4302dcbcace6e15d3396381e22ccea29eca38f", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 22, "deletions": 30, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=618cdda7f07c46b4e6e76ed1c0947cc9bf6a77f1", "patch": "@@ -29,10 +29,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n-#ifndef STDC_0_IN_SYSTEM_HEADERS\n-#define STDC_0_IN_SYSTEM_HEADERS 0 /* Boolean macro.  */\n-#endif\n-\n struct cpp_macro\n {\n   cpp_hashnode **params;\t/* Parameters, if any.  */\n@@ -92,9 +88,8 @@ static void free_lookahead PARAMS ((cpp_lookahead *));\n /* #define directive parsing and handling.  */\n \n static cpp_token *lex_expansion_token PARAMS ((cpp_reader *, cpp_macro *));\n-static int check_macro_redefinition PARAMS ((cpp_reader *,\n-\t\t\t\t\t     const cpp_hashnode *,\n-\t\t\t\t\t     const cpp_macro *));\n+static int warn_of_redefinition PARAMS ((cpp_reader *, const cpp_hashnode *,\n+\t\t\t\t\t const cpp_macro *));\n static int save_parameter PARAMS ((cpp_reader *, cpp_macro *, cpp_hashnode *));\n static int parse_params PARAMS ((cpp_reader *, cpp_macro *));\n static void check_trad_stringification PARAMS ((cpp_reader *,\n@@ -184,11 +179,8 @@ builtin_macro (pfile, token)\n \n     case BT_STDC:\n       {\n-\tint stdc = 1;\n-\n-\tif (STDC_0_IN_SYSTEM_HEADERS && CPP_IN_SYSTEM_HEADER (pfile)\n-\t    && pfile->spec_nodes.n__STRICT_ANSI__->type == NT_VOID)\n-\t  stdc = 0;\n+\tint stdc = (!CPP_IN_SYSTEM_HEADER (pfile)\n+\t\t    || pfile->spec_nodes.n__STRICT_ANSI__->type != NT_VOID);\n \tmake_number_token (pfile, token, stdc);\n       }\n       break;\n@@ -217,10 +209,6 @@ builtin_macro (pfile, token)\n       *token = node->value.builtin == BT_DATE ? pfile->date: pfile->time;\n       break;\n \n-    case BT_WEAK:\n-      make_number_token (pfile, token, SUPPORTS_ONE_ONLY);\n-      break;\n-\n     default:\n       cpp_ice (pfile, \"invalid builtin macro \\\"%s\\\"\", node->name);\n       break;\n@@ -1178,39 +1166,45 @@ _cpp_push_token (pfile, token, pos)\n \n /* #define directive parsing and handling.  */\n \n-/* Returns non-zero if a macro redefinition is trivial.  */\n+/* Returns non-zero if a macro redefinition warning is required.  */\n static int\n-check_macro_redefinition (pfile, node, macro2)\n+warn_of_redefinition (pfile, node, macro2)\n      cpp_reader *pfile;\n      const cpp_hashnode *node;\n      const cpp_macro *macro2;\n {\n   const cpp_macro *macro1;\n   unsigned int i;\n \n-  if (node->type != NT_MACRO || node->flags & NODE_BUILTIN)\n-    return ! pfile->done_initializing;\n+  /* Some redefinitions need to be warned about regardless.  */\n+  if (node->flags & NODE_WARN)\n+    return 1;\n \n+  if (! CPP_PEDANTIC (pfile))\n+    return 0;\n+\n+  /* Redefinition of a macro is allowed if and only if the old and new\n+     definitions are the same.  (6.10.3 paragraph 2). */\n   macro1 = node->value.macro;\n \n   /* The quick failures.  */\n   if (macro1->count != macro2->count\n       || macro1->paramc != macro2->paramc\n       || macro1->fun_like != macro2->fun_like\n       || macro1->variadic != macro2->variadic)\n-    return 0;\n+    return 1;\n \n   /* Check each token.  */\n   for (i = 0; i < macro1->count; i++)\n     if (! _cpp_equiv_tokens (&macro1->expansion[i], &macro2->expansion[i]))\n-      return 0;\n+      return 1;\n \n   /* Check parameter spellings.  */\n   for (i = 0; i < macro1->paramc; i++)\n     if (macro1->params[i] != macro2->params[i])\n-      return 0;\n+      return 1;\n \n-  return 1;\n+  return 0;\n }\n \n /* Free the definition of hashnode H.  */\n@@ -1472,19 +1466,15 @@ _cpp_create_definition (pfile, node)\n   /* Commit the memory.  */\n   POOL_COMMIT (&pfile->macro_pool, macro->count * sizeof (cpp_token));\n \n-  /* Redefinition of a macro is allowed if and only if the old and new\n-     definitions are the same.  (6.10.3 paragraph 2). */\n   if (node->type != NT_VOID)\n     {\n-      if (CPP_PEDANTIC (pfile)\n-\t  && !check_macro_redefinition (pfile, node, macro))\n+      if (warn_of_redefinition (pfile, node, macro))\n \t{\n \t  cpp_pedwarn_with_line (pfile, pfile->directive_pos.line,\n \t\t\t\t pfile->directive_pos.col,\n \t\t\t\t \"\\\"%s\\\" redefined\", node->name);\n \n-\t  if (pfile->done_initializing && node->type == NT_MACRO\n-\t      && !(node->flags & NODE_BUILTIN))\n+\t  if (node->type == NT_MACRO && !(node->flags & NODE_BUILTIN))\n \t    cpp_pedwarn_with_file_and_line (pfile,\n \t\t\t\t\t    node->value.macro->file,\n \t\t\t\t\t    node->value.macro->line, 1,\n@@ -1496,6 +1486,8 @@ _cpp_create_definition (pfile, node)\n   /* Enter definition in hash table.  */\n   node->type = NT_MACRO;\n   node->value.macro = macro;\n+  if (! ustrncmp (node->name, DSC (\"__STDC_\")))\n+    node->flags |= NODE_WARN;\n \n  cleanup:\n "}]}