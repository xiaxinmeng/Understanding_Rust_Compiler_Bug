{"sha": "06a964de822dfc498ee497e253e6ca360a318d8d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZhOTY0ZGU4MjJkZmM0OThlZTQ5N2UyNTNlNmNhMzYwYTMxOGQ4ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@freesoft.cz", "date": "1999-11-21T01:34:22Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "1999-11-21T01:34:22Z"}, "message": "i386.md (neg, [...]): Revmap to use ix86_expand_unary_operator and ix86_unary_operator_ok.\n\n        * i386.md (neg, not and abs patterns): Revmap to use\n        ix86_expand_unary_operator and ix86_unary_operator_ok.\n        (add?f and sub?f expanders): Force operand 1 to register.\n        * i386.c (ix86_expand_unary_operator): Rewrite.\n        (ix86_unary_operator_ok): Ensure that memory operands\n        match real opcode.\n        (ix86_binary_operator_ok): Do not allow operand 1 to\n        come into memory and operand 0 not.\n        (ix86_expand_binary_operator): Ensure that\n        src1 is not non-matching memory.\n\nFrom-SVN: r30597", "tree": {"sha": "728c66a8e34f1db456e377d1b75b916d474ec018", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/728c66a8e34f1db456e377d1b75b916d474ec018"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06a964de822dfc498ee497e253e6ca360a318d8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a964de822dfc498ee497e253e6ca360a318d8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06a964de822dfc498ee497e253e6ca360a318d8d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06a964de822dfc498ee497e253e6ca360a318d8d/comments", "author": null, "committer": null, "parents": [{"sha": "1ce485ec4316107f1e03d147471accd1ddf9a0d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce485ec4316107f1e03d147471accd1ddf9a0d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce485ec4316107f1e03d147471accd1ddf9a0d2"}], "stats": {"total": 271, "additions": 209, "deletions": 62}, "files": [{"sha": "65809bbf92185e2cba8b07aa362a78f2959831d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06a964de822dfc498ee497e253e6ca360a318d8d", "patch": "@@ -1,4 +1,16 @@\n Fri Nov 19 06:32:19 CET 1999  Jan Hubicka  <hubicka@freesoft.cz>\n+\n+\t* i386.md (neg, not and abs patterns): Revmap to use\n+\tix86_expand_unary_operator and ix86_unary_operator_ok.\n+\t(add?f and sub?f expanders): Force operand 1 to register.\n+\t* i386.c (ix86_expand_unary_operator): Rewrite.\n+\t(ix86_unary_operator_ok): Ensure that memory operands\n+\tmatch real opcode.\n+\t(ix86_binary_operator_ok): Do not allow operand 1 to\n+\tcome into memory and operand 0 not.\n+\t(ix86_expand_binary_operator): Ensure that\n+\tsrc1 is not non-matching memory.\n+\n \t* i386.md (negs?2): Rewrite to expanders, new patterns and splitters\n \tto support integer registers and memory.\n \t(abss?2_integer): Likewise."}, {"sha": "48b88455c9a52ed0bb89edddc316cd6071e42bd6", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 61, "deletions": 18, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=06a964de822dfc498ee497e253e6ca360a318d8d", "patch": "@@ -3726,8 +3726,11 @@ ix86_expand_binary_operator (code, mode, operands)\n \tsrc1 = force_reg (mode, src1);\n     }\n \n-  /* If the operation is not commutable, source 1 cannot be a constant.  */\n-  if (CONSTANT_P (src1) && GET_RTX_CLASS (code) != 'c')\n+  /* If the operation is not commutable, source 1 cannot be a constant\n+     or non-matching memory.  */\n+  if ((CONSTANT_P (src1) \n+       || (!matching_memory && GET_CODE (src1) == MEM))\n+      && GET_RTX_CLASS (code) != 'c')\n     src1 = force_reg (mode, src1);\n     \n   /* If optimizing, copy to regs to improve CSE */\n@@ -3784,6 +3787,12 @@ ix86_binary_operator_ok (code, mode, operands)\n \t    || (GET_RTX_CLASS (code) == 'c'\n \t\t&& rtx_equal_p (operands[0], operands[2]))))\n     return 0;\n+  /* If the operation is not commutable and the source 1 is memory, we must\n+     have a matching destionation.  */\n+  if (GET_CODE (operands[1]) == MEM\n+      && GET_RTX_CLASS (code) != 'c'\n+      && ! rtx_equal_p (operands[0], operands[1]))\n+    return 0;\n   return 1;\n }\n \n@@ -3798,27 +3807,56 @@ ix86_expand_unary_operator (code, mode, operands)\n      enum machine_mode mode;\n      rtx operands[];\n {\n-  /* If optimizing, copy to regs to improve CSE */\n-  if (optimize\n-      && ((reload_in_progress | reload_completed) == 0)\n-      && GET_CODE (operands[1]) == MEM)\n-    operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n+  int matching_memory;\n+  rtx src, dst, op, clob;\n+\n+  dst = operands[0];\n+  src = operands[1];\n \n-  if (! ix86_unary_operator_ok (code, mode, operands))\n+  /* If the destination is memory, and we do not have matching source\n+     operands, do things in registers.  */\n+  matching_memory = 0;\n+  if (GET_CODE (dst) == MEM)\n     {\n-      if (optimize == 0\n-\t  && ((reload_in_progress | reload_completed) == 0)\n-\t  && GET_CODE (operands[1]) == MEM)\n-\t{\n-\t  operands[1] = force_reg (GET_MODE (operands[1]), operands[1]);\n-\t  if (! ix86_unary_operator_ok (code, mode, operands))\n-\t    return FALSE;\n-\t}\n+      if (rtx_equal_p (dst, src))\n+\tmatching_memory = 1;\n       else\n-\treturn FALSE;\n+\tdst = gen_reg_rtx (mode);\n     }\n \n-  return TRUE;\n+  /* When source operand is memory, destination must match.  */\n+  if (!matching_memory && GET_CODE (src) == MEM)\n+    src = force_reg (mode, src);\n+  \n+  /* If optimizing, copy to regs to improve CSE */\n+  if (optimize && !reload_in_progress && !reload_completed)\n+    {\n+      if (GET_CODE (dst) == MEM)\n+\tdst = gen_reg_rtx (mode);\n+      if (GET_CODE (src) == MEM)\n+\tsrc = force_reg (mode, src);\n+    }\n+\n+  /* Emit the instruction.  */\n+\n+  op = gen_rtx_SET (VOIDmode, dst, gen_rtx_fmt_e (code, mode, src));\n+  if (reload_in_progress || code == NOT)\n+    {\n+      /* Reload doesn't know about the flags register, and doesn't know that\n+         it doesn't want to clobber it.  */\n+      if (code != NOT)\n+        abort ();\n+      emit_insn (op);\n+    }\n+  else\n+    {\n+      clob = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (CCmode, FLAGS_REG));\n+      emit_insn (gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, op, clob)));\n+    }\n+\n+  /* Fix up the destination if needed.  */\n+  if (dst != operands[0])\n+    emit_move_insn (operands[0], dst);\n }\n \n /* Return TRUE or FALSE depending on whether the unary operator meets the\n@@ -3830,6 +3868,11 @@ ix86_unary_operator_ok (code, mode, operands)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n      rtx operands[2] ATTRIBUTE_UNUSED;\n {\n+  /* If one of operands is memory, source and destination must match.  */\n+  if ((GET_CODE (operands[0]) == MEM\n+       || GET_CODE (operands[1]) == MEM)\n+      && ! rtx_equal_p (operands[0], operands[1]))\n+    return FALSE;\n   return TRUE;\n }\n "}, {"sha": "5f595e469e60d1e2dd214783e145ccdb68ad6168", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 136, "deletions": 44, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06a964de822dfc498ee497e253e6ca360a318d8d/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=06a964de822dfc498ee497e253e6ca360a318d8d", "patch": "@@ -3589,14 +3589,14 @@\n \n (define_expand \"adddf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(plus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n+\t(plus:DF (match_operand:DF 1 \"register_operand\" \"\")\n \t\t (match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\")\n \n (define_expand \"addsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(plus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")\n+\t(plus:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t (match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\")\n@@ -3786,14 +3786,14 @@\n \n (define_expand \"subdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"\")\n-\t(minus:DF (match_operand:DF 1 \"nonimmediate_operand\" \"\")\n+\t(minus:DF (match_operand:DF 1 \"register_operand\" \"\")\n \t\t  (match_operand:DF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\")\n \n (define_expand \"subsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n-\t(minus:SF (match_operand:SF 1 \"nonimmediate_operand\" \"\")\n+\t(minus:SF (match_operand:SF 1 \"register_operand\" \"\")\n \t\t  (match_operand:SF 2 \"nonimmediate_operand\" \"\")))]\n   \"TARGET_80387\"\n   \"\")\n@@ -4818,11 +4818,18 @@\n \n ;; %%% define_expand from the very first?\n \n-(define_insn \"negdi2\"\n+(define_expand \"negdi2\"\n+  [(parallel [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:DI (match_operand:DI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NEG, DImode, operands); DONE;\")\n+\n+(define_insn \"*negdi2_1\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=ro\")\n \t(neg:DI (match_operand:DI 1 \"general_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, DImode, operands)\"\n   \"#\")\n \n (define_split\n@@ -4847,11 +4854,18 @@\n   \"split_di (operands+1, 1, operands+2, operands+3);\n    split_di (operands+0, 1, operands+0, operands+1);\")\n \n-(define_insn \"negsi2\"\n+(define_expand \"negsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:SI (match_operand:SI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NEG, SImode, operands); DONE;\")\n+\n+(define_insn \"*negsi2_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, SImode, operands)\"\n   \"neg{l}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4861,7 +4875,7 @@\n \t\t (const_int 0)))\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:SI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, SImode, operands)\"\n   \"neg{l}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4871,15 +4885,22 @@\n \t\t (const_int 0)))\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:SI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, SImode, operands)\"\n   \"neg{l}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-(define_insn \"neghi2\"\n+(define_expand \"neghi2\"\n+  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:HI (match_operand:HI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NEG, HImode, operands); DONE;\")\n+\n+(define_insn \"*neghi2_1\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, HImode, operands)\"\n   \"neg{w}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4889,7 +4910,7 @@\n \t\t (const_int 0)))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:HI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, HImode, operands)\"\n   \"neg{w}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4899,15 +4920,22 @@\n \t\t (const_int 0)))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(neg:HI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, HImode, operands)\"\n   \"neg{w}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-(define_insn \"negqi2\"\n+(define_expand \"negqi2\"\n+  [(parallel [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:QI (match_operand:QI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NEG, QImode, operands); DONE;\")\n+\n+(define_insn \"*negqi2_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(neg:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"neg{b}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4917,7 +4945,7 @@\n \t\t (const_int 0)))\n    (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(neg:QI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"neg{b}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -4927,17 +4955,24 @@\n \t\t (const_int 0)))\n    (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(neg:QI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"neg{b}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-;; Changing of sign for FP values is duable using integer unit too.\n+;; Changing of sign for FP values is doable using integer unit too.\n \n-(define_insn \"negsf2\"\n+(define_expand \"negsf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:SF (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (NEG, SFmode, operands); DONE;\")\n+\n+(define_insn \"*negsf2_if\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=frm\")\n \t(neg:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ix86_unary_operator_ok (NEG, SFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -4978,11 +5013,18 @@\n   operands[1] = GEN_INT (0x80);\n }\")\n \n-(define_insn \"negdf2\"\n+(define_expand \"negdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:DF (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (NEG, DFmode, operands); DONE;\")\n+\n+(define_insn \"*negdf2_if\"\n   [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=frm\")\n \t(neg:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ix86_unary_operator_ok (NEG, DFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -5004,11 +5046,18 @@\n   \"operands[4] = GEN_INT (0x80000000);\n    split_di (operands+0, 1, operands+2, operands+3);\")\n \n-(define_insn \"negxf2\"\n+(define_expand \"negxf2\"\n+  [(parallel [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:XF (match_operand:XF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (NEG, XFmode, operands); DONE;\")\n+\n+(define_insn \"*negxf2_if\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=frm\")\n \t(neg:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ix86_unary_operator_ok (NEG, XFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -5086,11 +5135,18 @@\n \f\n ;; Absolute value instructions\n \n-(define_insn \"abssf2\"\n+(define_expand \"abssf2\"\n+  [(parallel [(set (match_operand:SF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:SF (match_operand:SF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (ABS, SFmode, operands); DONE;\")\n+\n+(define_insn \"*abssf2_if\"\n   [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=frm\")\n \t(abs:SF (match_operand:SF 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ix86_unary_operator_ok (ABS, SFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -5131,10 +5187,18 @@\n   operands[1] = GEN_INT (~0x80);\n }\")\n \n-(define_insn \"absdf2\"\n-  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=frm\")\n-\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0\")))]\n+(define_expand \"absdf2\"\n+  [(parallel [(set (match_operand:DF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:DF (match_operand:DF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n   \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (ABS, DFmode, operands); DONE;\")\n+\n+(define_insn \"*absdf2_if\"\n+  [(set (match_operand:DF 0 \"nonimmediate_operand\" \"=frm\")\n+\t(abs:DF (match_operand:DF 1 \"nonimmediate_operand\" \"0\")))\n+   (clobber (reg:CC 17))]\n+  \"TARGET_80387 && ix86_unary_operator_ok (ABS, DFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -5156,11 +5220,18 @@\n   \"operands[4] = GEN_INT (~0x80000000);\n    split_di (operands+0, 1, operands+2, operands+3);\")\n \n-(define_insn \"absxf2\"\n+(define_expand \"absxf2\"\n+  [(parallel [(set (match_operand:XF 0 \"nonimmediate_operand\" \"\")\n+\t\t   (neg:XF (match_operand:XF 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"TARGET_80387\"\n+  \"ix86_expand_unary_operator (ABS, XFmode, operands); DONE;\")\n+\n+(define_insn \"*absxf2_if\"\n   [(set (match_operand:XF 0 \"nonimmediate_operand\" \"=frm\")\n \t(abs:XF (match_operand:XF 1 \"nonimmediate_operand\" \"0\")))\n    (clobber (reg:CC 17))]\n-  \"TARGET_80387\"\n+  \"TARGET_80387 && ix86_unary_operator_ok (ABS, XFmode, operands)\"\n   \"#\")\n \n (define_split\n@@ -5229,20 +5300,27 @@\n \f\n ;; One complement instructions\n \n-(define_insn \"one_cmplsi2\"\n+(define_expand \"one_cmplsi2\"\n+  [(parallel [(set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (not:SI (match_operand:SI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NOT, SImode, operands); DONE;\")\n+\n+(define_insn \"*one_cmplsi2_1\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, SImode, operands)\"\n   \"not{l}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-(define_insn \"*one_cmplsi2_1\"\n+(define_insn \"*one_cmplsi2_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (not:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\"))\n \t\t    (const_int 0)))\n    (set (match_operand:SI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:SI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, SImode, operands)\"\n   \"#\"\n   [(set_attr \"type\" \"alu1\")])\n \n@@ -5260,10 +5338,17 @@\n \t\t   (xor:SI (match_dup 1) (const_int -1)))])]\n   \"\")\n \n-(define_insn \"one_cmplhi2\"\n+(define_expand \"one_cmplhi2\"\n+  [(parallel [(set (match_operand:HI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (not:HI (match_operand:HI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NOT, HImode, operands); DONE;\")\n+\n+(define_insn \"*one_cmplhi2_1\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\")))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, HImode, operands)\"\n   \"not{w}\\\\t%0\"\n   [(set_attr \"type\" \"negnot\")])\n \n@@ -5277,13 +5362,13 @@\n   \"operands[0] = gen_lowpart (SImode, operands[0]);\n    operands[1] = gen_lowpart (SImode, operands[1]);\")\n \n-(define_insn \"*one_cmplhi2_1\"\n+(define_insn \"*one_cmplhi2_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (not:HI (match_operand:HI 1 \"nonimmediate_operand\" \"0\"))\n \t\t      (const_int 0)))\n    (set (match_operand:HI 0 \"nonimmediate_operand\" \"=rm\")\n \t(not:HI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, HImode, operands)\"\n   \"#\"\n   [(set_attr \"type\" \"alu1\")])\n \n@@ -5302,22 +5387,29 @@\n   \"\")\n \n ;; %%% Potential partial reg stall on alternative 1.  What to do?\n-(define_insn \"one_cmplqi2\"\n+(define_expand \"one_cmplqi2\"\n+  [(parallel [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n+\t\t   (not:QI (match_operand:QI 1 \"general_operand\" \"\")))\n+\t      (clobber (reg:CC 17))])]\n+  \"\"\n+  \"ix86_expand_unary_operator (NOT, QImode, operands); DONE;\")\n+\n+(define_insn \"*one_cmplqi2_1\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm,*r\")\n \t(not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0,0\")))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"@\n    not{b}\\\\t%0\n    not{l}\\\\t%k0\"\n   [(set_attr \"type\" \"negnot\")])\n \n-(define_insn \"*one_cmplqi2_1\"\n+(define_insn \"*one_cmplqi2_2\"\n   [(set (reg:CCNO 17)\n \t(compare:CCNO (not:QI (match_operand:QI 1 \"nonimmediate_operand\" \"0\"))\n \t\t    (const_int 0)))\n    (set (match_operand:QI 0 \"nonimmediate_operand\" \"=qm\")\n \t(not:QI (match_dup 1)))]\n-  \"\"\n+  \"ix86_unary_operator_ok (NEG, QImode, operands)\"\n   \"#\"\n   [(set_attr \"type\" \"alu1\")])\n "}]}