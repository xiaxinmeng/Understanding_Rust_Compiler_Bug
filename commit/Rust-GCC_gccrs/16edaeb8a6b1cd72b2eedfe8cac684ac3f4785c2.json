{"sha": "16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZlZGFlYjhhNmIxY2Q3MmIyZWVkZmU4Y2FjNjg0YWMzZjQ3ODVjMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:22:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:22:17Z"}, "message": "[15/46] Make SLP_TREE_VEC_STMTS a vec<stmt_vec_info>\n\nThis patch changes SLP_TREE_VEC_STMTS from a vec<gimple *> to a\nvec<stmt_vec_info>.  This involved making the same change to the\nphis vector in vectorizable_reduction, since SLP_TREE_VEC_STMTS is\nspliced into it here:\n\n  phis.splice (SLP_TREE_VEC_STMTS (slp_node_instance->reduc_phis));\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_slp_tree::vec_stmts): Change from a\n\tvec<gimple *> to a vec<stmt_vec_info>.\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Change\n\tthe reduction_phis argument from a vec<gimple *> to a\n\tvec<stmt_vec_info>.\n\t(vectorizable_reduction): Likewise the phis local variable that\n\tis passed to vect_create_epilog_for_reduction.  Update for new type\n\tof SLP_TREE_VEC_STMTS.\n\t(vectorizable_induction): Update for new type of SLP_TREE_VEC_STMTS.\n\t(vectorizable_live_operation): Likewise.\n\t* tree-vect-slp.c (vect_get_slp_vect_defs): Likewise.\n\t(vect_transform_slp_perm_load, vect_schedule_slp_instance): Likewise.\n\nFrom-SVN: r263130", "tree": {"sha": "3d56b2b0003ad81f21d5403a79c08221865abe4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d56b2b0003ad81f21d5403a79c08221865abe4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1eede195fc02f5198b48d75b3fb7705c4c1493dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eede195fc02f5198b48d75b3fb7705c4c1493dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eede195fc02f5198b48d75b3fb7705c4c1493dd"}], "stats": {"total": 124, "additions": 73, "deletions": 51}, "files": [{"sha": "cff993ffa1e03e97cf1f5aca1a8e88778746d825", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "patch": "@@ -1,3 +1,18 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (_slp_tree::vec_stmts): Change from a\n+\tvec<gimple *> to a vec<stmt_vec_info>.\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Change\n+\tthe reduction_phis argument from a vec<gimple *> to a\n+\tvec<stmt_vec_info>.\n+\t(vectorizable_reduction): Likewise the phis local variable that\n+\tis passed to vect_create_epilog_for_reduction.  Update for new type\n+\tof SLP_TREE_VEC_STMTS.\n+\t(vectorizable_induction): Update for new type of SLP_TREE_VEC_STMTS.\n+\t(vectorizable_live_operation): Likewise.\n+\t* tree-vect-slp.c (vect_get_slp_vect_defs): Likewise.\n+\t(vect_transform_slp_perm_load, vect_schedule_slp_instance): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (_stmt_vec_info::vectorized_stmt): Change from"}, {"sha": "7f335cf6351b71a1aed8e6a715e007334e8819f1", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 33, "deletions": 30, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "patch": "@@ -4412,7 +4412,7 @@ static void\n vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  gimple *reduc_def_stmt,\n \t\t\t\t  int ncopies, internal_fn reduc_fn,\n-\t\t\t\t  vec<gimple *> reduction_phis,\n+\t\t\t\t  vec<stmt_vec_info> reduction_phis,\n                                   bool double_reduc, \n \t\t\t\t  slp_tree slp_node,\n \t\t\t\t  slp_instance slp_node_instance,\n@@ -4429,6 +4429,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   tree scalar_dest;\n   tree scalar_type;\n   gimple *new_phi = NULL, *phi;\n+  stmt_vec_info phi_info;\n   gimple_stmt_iterator exit_gsi;\n   tree vec_dest;\n   tree new_temp = NULL_TREE, new_dest, new_name, new_scalar_dest;\n@@ -4442,7 +4443,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   tree orig_name, scalar_result;\n   imm_use_iterator imm_iter, phi_imm_iter;\n   use_operand_p use_p, phi_use_p;\n-  gimple *use_stmt, *reduction_phi = NULL;\n+  gimple *use_stmt;\n+  stmt_vec_info reduction_phi_info = NULL;\n   bool nested_in_vect_loop = false;\n   auto_vec<gimple *> new_phis;\n   auto_vec<stmt_vec_info> inner_phis;\n@@ -4540,15 +4542,15 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     }\n \n   /* Set phi nodes arguments.  */\n-  FOR_EACH_VEC_ELT (reduction_phis, i, phi)\n+  FOR_EACH_VEC_ELT (reduction_phis, i, phi_info)\n     {\n       tree vec_init_def = vec_initial_defs[i];\n       tree def = vect_defs[i];\n       for (j = 0; j < ncopies; j++)\n         {\n \t  if (j != 0)\n \t    {\n-\t      phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n+\t      phi_info = STMT_VINFO_RELATED_STMT (phi_info);\n \t      if (nested_in_vect_loop)\n \t\tvec_init_def\n \t\t  = vect_get_vec_def_for_stmt_copy (initial_def_dt,\n@@ -4557,6 +4559,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n \t  /* Set the loop-entry arg of the reduction-phi.  */\n \n+\t  gphi *phi = as_a <gphi *> (phi_info->stmt);\n \t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n \t      == INTEGER_INDUC_COND_REDUCTION)\n \t    {\n@@ -4569,19 +4572,18 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t      tree induc_val_vec\n \t\t= build_vector_from_val (vec_init_def_type, induc_val);\n \n-\t      add_phi_arg (as_a <gphi *> (phi), induc_val_vec,\n-\t\t\t   loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\t      add_phi_arg (phi, induc_val_vec, loop_preheader_edge (loop),\n+\t\t\t   UNKNOWN_LOCATION);\n \t    }\n \t  else\n-\t    add_phi_arg (as_a <gphi *> (phi), vec_init_def,\n-\t\t\t loop_preheader_edge (loop), UNKNOWN_LOCATION);\n+\t    add_phi_arg (phi, vec_init_def, loop_preheader_edge (loop),\n+\t\t\t UNKNOWN_LOCATION);\n \n           /* Set the loop-latch arg for the reduction-phi.  */\n           if (j > 0)\n             def = vect_get_vec_def_for_stmt_copy (vect_unknown_def_type, def);\n \n-          add_phi_arg (as_a <gphi *> (phi), def, loop_latch_edge (loop),\n-\t\t       UNKNOWN_LOCATION);\n+\t  add_phi_arg (phi, def, loop_latch_edge (loop), UNKNOWN_LOCATION);\n \n           if (dump_enabled_p ())\n             {\n@@ -5599,7 +5601,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       if (k % ratio == 0)\n         {\n           epilog_stmt = new_phis[k / ratio];\n-          reduction_phi = reduction_phis[k / ratio];\n+\t  reduction_phi_info = reduction_phis[k / ratio];\n \t  if (double_reduc)\n \t    inner_phi = inner_phis[k / ratio];\n         }\n@@ -5672,7 +5674,6 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                   stmt_vec_info use_stmt_vinfo;\n                   tree vect_phi_init, preheader_arg, vect_phi_res;\n                   basic_block bb = gimple_bb (use_stmt);\n-\t\t  gimple *use;\n \n                   /* Check that USE_STMT is really double reduction phi\n                      node.  */\n@@ -5722,13 +5723,14 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n                   /* Replace the use, i.e., set the correct vs1 in the regular\n                      reduction phi node.  FORNOW, NCOPIES is always 1, so the\n                      loop is redundant.  */\n-                  use = reduction_phi;\n-                  for (j = 0; j < ncopies; j++)\n-                    {\n-                      edge pr_edge = loop_preheader_edge (loop);\n-                      SET_PHI_ARG_DEF (use, pr_edge->dest_idx, vect_phi_res);\n-                      use = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use));\n-                    }\n+\t\t  stmt_vec_info use_info = reduction_phi_info;\n+\t\t  for (j = 0; j < ncopies; j++)\n+\t\t    {\n+\t\t      edge pr_edge = loop_preheader_edge (loop);\n+\t\t      SET_PHI_ARG_DEF (as_a <gphi *> (use_info->stmt),\n+\t\t\t\t       pr_edge->dest_idx, vect_phi_res);\n+\t\t      use_info = STMT_VINFO_RELATED_STMT (use_info);\n+\t\t    }\n                 }\n             }\n         }\n@@ -6112,7 +6114,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   auto_vec<tree> vec_oprnds1;\n   auto_vec<tree> vec_oprnds2;\n   auto_vec<tree> vect_defs;\n-  auto_vec<gimple *> phis;\n+  auto_vec<stmt_vec_info> phis;\n   int vec_num;\n   tree def0, tem;\n   tree cr_index_scalar_type = NULL_TREE, cr_index_vector_type = NULL_TREE;\n@@ -6218,7 +6220,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t  stmt_vec_info new_phi_info = loop_vinfo->add_stmt (new_phi);\n \n \t\t  if (slp_node)\n-\t\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi);\n+\t\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_phi_info);\n \t\t  else\n \t\t    {\n \t\t      if (j == 0)\n@@ -7075,9 +7077,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       if (code == COND_EXPR)\n         {\n           gcc_assert (!slp_node);\n-          vectorizable_condition (stmt, gsi, vec_stmt, \n-                                  PHI_RESULT (phis[0]), \n-                                  reduc_index, NULL, NULL);\n+\t  vectorizable_condition (stmt, gsi, vec_stmt,\n+\t\t\t\t  PHI_RESULT (phis[0]->stmt),\n+\t\t\t\t  reduc_index, NULL, NULL);\n           /* Multiple types are not supported for condition.  */\n           break;\n         }\n@@ -7501,7 +7503,8 @@ vectorizable_induction (gimple *phi,\n \t  /* Create the induction-phi that defines the induction-operand.  */\n \t  vec_dest = vect_get_new_vect_var (vectype, vect_simple_var, \"vec_iv_\");\n \t  induction_phi = create_phi_node (vec_dest, iv_loop->header);\n-\t  loop_vinfo->add_stmt (induction_phi);\n+\t  stmt_vec_info induction_phi_info\n+\t    = loop_vinfo->add_stmt (induction_phi);\n \t  induc_def = PHI_RESULT (induction_phi);\n \n \t  /* Create the iv update inside the loop  */\n@@ -7515,7 +7518,7 @@ vectorizable_induction (gimple *phi,\n \t  add_phi_arg (induction_phi, vec_def, loop_latch_edge (iv_loop),\n \t\t       UNKNOWN_LOCATION);\n \n-\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi);\n+\t  SLP_TREE_VEC_STMTS (slp_node).quick_push (induction_phi_info);\n \t}\n \n       /* Re-use IVs when we can.  */\n@@ -7540,7 +7543,7 @@ vectorizable_induction (gimple *phi,\n \t  vec_step = vect_init_vector (phi, new_vec, vectype, NULL);\n \t  for (; ivn < nvects; ++ivn)\n \t    {\n-\t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs];\n+\t      gimple *iv = SLP_TREE_VEC_STMTS (slp_node)[ivn - nivs]->stmt;\n \t      tree def;\n \t      if (gimple_code (iv) == GIMPLE_PHI)\n \t\tdef = gimple_phi_result (iv);\n@@ -7556,8 +7559,8 @@ vectorizable_induction (gimple *phi,\n \t\t  gimple_stmt_iterator tgsi = gsi_for_stmt (iv);\n \t\t  gsi_insert_after (&tgsi, new_stmt, GSI_CONTINUE_LINKING);\n \t\t}\n-\t      loop_vinfo->add_stmt (new_stmt);\n-\t      SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t      SLP_TREE_VEC_STMTS (slp_node).quick_push\n+\t\t(loop_vinfo->add_stmt (new_stmt));\n \t    }\n \t}\n \n@@ -7943,7 +7946,7 @@ vectorizable_live_operation (gimple *stmt,\n       gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n \n       /* Get the correct slp vectorized stmt.  */\n-      gimple *vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry];\n+      gimple *vec_stmt = SLP_TREE_VEC_STMTS (slp_node)[vec_entry]->stmt;\n       if (gphi *phi = dyn_cast <gphi *> (vec_stmt))\n \tvec_lhs = gimple_phi_result (phi);\n       else"}, {"sha": "c3d72ecaab47697c4b90bfb44f2c29a43bcfc36e", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "patch": "@@ -3557,18 +3557,18 @@ static void\n vect_get_slp_vect_defs (slp_tree slp_node, vec<tree> *vec_oprnds)\n {\n   tree vec_oprnd;\n-  gimple *vec_def_stmt;\n+  stmt_vec_info vec_def_stmt_info;\n   unsigned int i;\n \n   gcc_assert (SLP_TREE_VEC_STMTS (slp_node).exists ());\n \n-  FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt)\n+  FOR_EACH_VEC_ELT (SLP_TREE_VEC_STMTS (slp_node), i, vec_def_stmt_info)\n     {\n-      gcc_assert (vec_def_stmt);\n-      if (gimple_code (vec_def_stmt) == GIMPLE_PHI)\n-\tvec_oprnd = gimple_phi_result (vec_def_stmt);\n+      gcc_assert (vec_def_stmt_info);\n+      if (gphi *vec_def_phi = dyn_cast <gphi *> (vec_def_stmt_info->stmt))\n+\tvec_oprnd = gimple_phi_result (vec_def_phi);\n       else\n-\tvec_oprnd = gimple_get_lhs (vec_def_stmt);\n+\tvec_oprnd = gimple_get_lhs (vec_def_stmt_info->stmt);\n       vec_oprnds->quick_push (vec_oprnd);\n     }\n }\n@@ -3687,6 +3687,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n {\n   gimple *stmt = SLP_TREE_SCALAR_STMTS (node)[0];\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  vec_info *vinfo = stmt_info->vinfo;\n   tree mask_element_type = NULL_TREE, mask_type;\n   int vec_index = 0;\n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n@@ -3827,26 +3828,28 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n \t\t  /* Generate the permute statement if necessary.  */\n \t\t  tree first_vec = dr_chain[first_vec_index];\n \t\t  tree second_vec = dr_chain[second_vec_index];\n-\t\t  gimple *perm_stmt;\n+\t\t  stmt_vec_info perm_stmt_info;\n \t\t  if (! noop_p)\n \t\t    {\n \t\t      tree perm_dest\n \t\t\t= vect_create_destination_var (gimple_assign_lhs (stmt),\n \t\t\t\t\t\t       vectype);\n \t\t      perm_dest = make_ssa_name (perm_dest);\n-\t\t      perm_stmt = gimple_build_assign (perm_dest,\n-\t\t\t\t\t\t       VEC_PERM_EXPR,\n-\t\t\t\t\t\t       first_vec, second_vec,\n-\t\t\t\t\t\t       mask_vec);\n-\t\t      vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n+\t\t      gassign *perm_stmt\n+\t\t\t= gimple_build_assign (perm_dest, VEC_PERM_EXPR,\n+\t\t\t\t\t       first_vec, second_vec,\n+\t\t\t\t\t       mask_vec);\n+\t\t      perm_stmt_info\n+\t\t\t= vect_finish_stmt_generation (stmt, perm_stmt, gsi);\n \t\t    }\n \t\t  else\n \t\t    /* If mask was NULL_TREE generate the requested\n \t\t       identity transform.  */\n-\t\t    perm_stmt = SSA_NAME_DEF_STMT (first_vec);\n+\t\t    perm_stmt_info = vinfo->lookup_def (first_vec);\n \n \t\t  /* Store the vector statement in NODE.  */\n-\t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++] = perm_stmt;\n+\t\t  SLP_TREE_VEC_STMTS (node)[vect_stmts_counter++]\n+\t\t    = perm_stmt_info;\n \t\t}\n \n \t      index = 0;\n@@ -3948,8 +3951,8 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t  mask.quick_push (0);\n       if (ocode != ERROR_MARK)\n \t{\n-\t  vec<gimple *> v0;\n-\t  vec<gimple *> v1;\n+\t  vec<stmt_vec_info> v0;\n+\t  vec<stmt_vec_info> v1;\n \t  unsigned j;\n \t  tree tmask = NULL_TREE;\n \t  vect_transform_stmt (stmt, &si, &grouped_store, node, instance);\n@@ -3990,10 +3993,11 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n \t      gimple *vstmt;\n \t      vstmt = gimple_build_assign (make_ssa_name (vectype),\n \t\t\t\t\t   VEC_PERM_EXPR,\n-\t\t\t\t\t   gimple_assign_lhs (v0[j]),\n-\t\t\t\t\t   gimple_assign_lhs (v1[j]), tmask);\n-\t      vect_finish_stmt_generation (stmt, vstmt, &si);\n-\t      SLP_TREE_VEC_STMTS (node).quick_push (vstmt);\n+\t\t\t\t\t   gimple_assign_lhs (v0[j]->stmt),\n+\t\t\t\t\t   gimple_assign_lhs (v1[j]->stmt),\n+\t\t\t\t\t   tmask);\n+\t      SLP_TREE_VEC_STMTS (node).quick_push\n+\t\t(vect_finish_stmt_generation (stmt, vstmt, &si));\n \t    }\n \t  v0.release ();\n \t  v1.release ();"}, {"sha": "f4c2672e97b758d6fed7394e9d94d1e2ab63c131", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=16edaeb8a6b1cd72b2eedfe8cac684ac3f4785c2", "patch": "@@ -143,7 +143,7 @@ struct _slp_tree {\n      permutation.  */\n   vec<unsigned> load_permutation;\n   /* Vectorized stmt/s.  */\n-  vec<gimple *> vec_stmts;\n+  vec<stmt_vec_info> vec_stmts;\n   /* Number of vector stmts that are created to replace the group of scalar\n      stmts. It is calculated during the transformation phase as the number of\n      scalar elements in one scalar iteration (GROUP_SIZE) multiplied by VF"}]}