{"sha": "2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZjOWIzN2RkMDIxZGY0ZjNlZGJkYTNiZTA5YmQ4OTFiNWJmNzFlMw==", "commit": {"author": {"name": "Jeffrey Yasskin", "email": "jyasskin@google.com", "date": "2012-04-12T20:59:09Z"}, "committer": {"name": "Jeffrey Yasskin", "email": "jyasskin@gcc.gnu.org", "date": "2012-04-12T20:59:09Z"}, "message": "Fix PR52822 (stable_partition move-assigns object to itself) by scanning for...\n\nFix PR52822 (stable_partition move-assigns object to itself) by\nscanning for the first value that doesn't match the predicate before\nstarting to rearrange values.\n\n2012-04-03   Jeffrey Yasskin  <jyasskin@google.com>\n\n\tPR libstdc++/52822\n\t* include/bits/stl_algo.h (__find_if_not): Expose in\n\tC++98 mode.\n\t(__find_if_not_n): Like __find_if_not, but works on and updates a\n\tcounted range instead of a bounded range.\n\t(stable_partition): Guarantee !__pred(*__first) in call to\n\t__stable_partition_adaptive() or __inplace_stable_partition().\n\t(__stable_partition_adaptive): Use new precondition to avoid\n\tmoving/copying objects onto themselves.  Guarantee new\n\tprecondition to recursive calls.\n\t(__inplace_stable_partition): Use new precondition to simplify\n\tbase case, remove __last parameter.  Guarantee new precondition to\n\trecursive calls.\n\t* testsuite/25_algorithms/stable_partition/moveable.cc (test02):\n\tTest a sequence that starts with a value matching the predicate.\n\t* testsuite/25_algorithms/stable_partition/pr52822.cc:\n\tTest vectors, which have a destructive self-move-assignment.\n\nFrom-SVN: r186391", "tree": {"sha": "da264b4ef9803a0d4515217be60b6052e22a7450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da264b4ef9803a0d4515217be60b6052e22a7450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/comments", "author": {"login": "jyasskin", "id": 83420, "node_id": "MDQ6VXNlcjgzNDIw", "avatar_url": "https://avatars.githubusercontent.com/u/83420?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyasskin", "html_url": "https://github.com/jyasskin", "followers_url": "https://api.github.com/users/jyasskin/followers", "following_url": "https://api.github.com/users/jyasskin/following{/other_user}", "gists_url": "https://api.github.com/users/jyasskin/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyasskin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyasskin/subscriptions", "organizations_url": "https://api.github.com/users/jyasskin/orgs", "repos_url": "https://api.github.com/users/jyasskin/repos", "events_url": "https://api.github.com/users/jyasskin/events{/privacy}", "received_events_url": "https://api.github.com/users/jyasskin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a2547fd0d6cd351ec7fe366d770aaea296d7f70d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2547fd0d6cd351ec7fe366d770aaea296d7f70d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2547fd0d6cd351ec7fe366d770aaea296d7f70d"}], "stats": {"total": 179, "additions": 152, "deletions": 27}, "files": [{"sha": "11f4b7c5c1d9e41a9d4fea1abd504485cd96adb7", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "patch": "@@ -1,3 +1,22 @@\n+2012-04-12   Jeffrey Yasskin  <jyasskin@google.com>\n+\n+\tPR libstdc++/52822\n+        * include/bits/stl_algo.h (__find_if_not): Expose in C++98 mode.\n+        (__find_if_not_n): Like __find_if_not, but works on and updates a\n+\tcounted range instead of a bounded range.\n+        (stable_partition): Guarantee !__pred(*__first) in call to\n+\t__stable_partition_adaptive() or __inplace_stable_partition().\n+        (__stable_partition_adaptive): Use new precondition to avoid\n+\tmoving/copying objects onto themselves.  Guarantee new\n+\tprecondition to recursive calls.\n+        (__inplace_stable_partition): Use new precondition to simplify\n+\tbase case, remove __last parameter.  Guarantee new precondition to\n+\trecursive calls.\n+        * testsuite/25_algorithms/stable_partition/moveable.cc (test02):\n+\tTest a sequence that starts with a value matching the predicate.\n+        * testsuite/25_algorithms/stable_partition/pr52822.cc: Test\n+\tvectors, which have a destructive self-move-assignment.\n+\n 2012-04-12  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* testsuite/Makefile.am (check_DEJAGNUnormal0): Run"}, {"sha": "f337e0c07a659fb4d379a0e7a25d9f2ca07b045c", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 69, "deletions": 26, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "patch": "@@ -244,7 +244,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n     }\n \n-#ifdef __GXX_EXPERIMENTAL_CXX0X__\n   /// This is an overload used by find_if_not() for the Input Iterator case.\n   template<typename _InputIterator, typename _Predicate>\n     inline _InputIterator\n@@ -303,7 +302,29 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return __last;\n \t}\n     }\n-#endif\n+\n+  /// Provided for stable_partition to use.\n+  template<typename _InputIterator, typename _Predicate>\n+    inline _InputIterator\n+    __find_if_not(_InputIterator __first, _InputIterator __last,\n+\t\t  _Predicate __pred)\n+    {\n+      return std::__find_if_not(__first, __last, __pred,\n+\t\t\t\tstd::__iterator_category(__first));\n+    }\n+\n+  /// Like find_if_not(), but uses and updates a count of the\n+  /// remaining range length instead of comparing against an end\n+  /// iterator.\n+  template<typename _InputIterator, typename _Predicate, typename _Distance>\n+    _InputIterator\n+    __find_if_not_n(_InputIterator __first, _Distance& __len, _Predicate __pred)\n+    {\n+      for (; __len; --__len, ++__first)\n+\tif (!bool(__pred(*__first)))\n+\t  break;\n+      return __first;\n+    }\n \n   // set_difference\n   // set_intersection\n@@ -789,8 +810,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t      typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n-      return std::__find_if_not(__first, __last, __pred,\n-\t\t\t\tstd::__iterator_category(__first));\n+      return std::__find_if_not(__first, __last, __pred);\n     }\n \n   /**\n@@ -1784,30 +1804,39 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   // partition\n \n   /// This is a helper function...\n+  /// Requires __len != 0 and !__pred(*__first),\n+  /// same as __stable_partition_adaptive.\n   template<typename _ForwardIterator, typename _Predicate, typename _Distance>\n     _ForwardIterator\n     __inplace_stable_partition(_ForwardIterator __first,\n-\t\t\t       _ForwardIterator __last,\n \t\t\t       _Predicate __pred, _Distance __len)\n     {\n       if (__len == 1)\n-\treturn __pred(*__first) ? __last : __first;\n+\treturn __first;\n       _ForwardIterator __middle = __first;\n       std::advance(__middle, __len / 2);\n-      _ForwardIterator __begin = std::__inplace_stable_partition(__first,\n-\t\t\t\t\t\t\t\t __middle,\n-\t\t\t\t\t\t\t\t __pred,\n-\t\t\t\t\t\t\t\t __len / 2);\n-      _ForwardIterator __end = std::__inplace_stable_partition(__middle, __last,\n-\t\t\t\t\t\t\t       __pred,\n-\t\t\t\t\t\t\t       __len\n-\t\t\t\t\t\t\t       - __len / 2);\n-      std::rotate(__begin, __middle, __end);\n-      std::advance(__begin, std::distance(__middle, __end));\n-      return __begin;\n+      _ForwardIterator __left_split =\n+\tstd::__inplace_stable_partition(__first, __pred, __len / 2);\n+      // Advance past true-predicate values to satisfy this\n+      // function's preconditions.\n+      _Distance __right_len = __len - __len / 2;\n+      _ForwardIterator __right_split =\n+\tstd::__find_if_not_n(__middle, __right_len, __pred);\n+      if (__right_len)\n+\t__right_split = std::__inplace_stable_partition(__middle,\n+\t\t\t\t\t\t\t__pred,\n+\t\t\t\t\t\t\t__right_len);\n+      std::rotate(__left_split, __middle, __right_split);\n+      std::advance(__left_split, std::distance(__middle, __right_split));\n+      return __left_split;\n     }\n \n   /// This is a helper function...\n+  /// Requires __first != __last and !__pred(*__first)\n+  /// and __len == distance(__first, __last).\n+  ///\n+  /// !__pred(*__first) allows us to guarantee that we don't\n+  /// move-assign an element onto itself.\n   template<typename _ForwardIterator, typename _Pointer, typename _Predicate,\n \t   typename _Distance>\n     _ForwardIterator\n@@ -1821,6 +1850,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _ForwardIterator __result1 = __first;\n \t  _Pointer __result2 = __buffer;\n+\t  // The precondition guarantees that !__pred(*__first), so\n+\t  // move that element to the buffer before starting the loop.\n+\t  // This ensures that we only call __pred once per element.\n+\t  *__result2 = _GLIBCXX_MOVE(*__first);\n+\t  ++__result2;\n+\t  ++__first;\n \t  for (; __first != __last; ++__first)\n \t    if (__pred(*__first))\n \t      {\n@@ -1839,17 +1874,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t{\n \t  _ForwardIterator __middle = __first;\n \t  std::advance(__middle, __len / 2);\n-\t  _ForwardIterator __begin =\n+\t  _ForwardIterator __left_split =\n \t    std::__stable_partition_adaptive(__first, __middle, __pred,\n \t\t\t\t\t     __len / 2, __buffer,\n \t\t\t\t\t     __buffer_size);\n-\t  _ForwardIterator __end =\n-\t    std::__stable_partition_adaptive(__middle, __last, __pred,\n-\t\t\t\t\t     __len - __len / 2,\n-\t\t\t\t\t     __buffer, __buffer_size);\n-\t  std::rotate(__begin, __middle, __end);\n-\t  std::advance(__begin, std::distance(__middle, __end));\n-\t  return __begin;\n+\t  // Advance past true-predicate values to satisfy this\n+\t  // function's preconditions.\n+\t  _Distance __right_len = __len - __len / 2;\n+\t  _ForwardIterator __right_split =\n+\t    std::__find_if_not_n(__middle, __right_len, __pred);\n+\t  if (__right_len)\n+\t    __right_split =\n+\t      std::__stable_partition_adaptive(__right_split, __last, __pred,\n+\t\t\t\t\t       __right_len,\n+\t\t\t\t\t       __buffer, __buffer_size);\n+\t  std::rotate(__left_split, __middle, __right_split);\n+\t  std::advance(__left_split, std::distance(__middle, __right_split));\n+\t  return __left_split;\n \t}\n     }\n \n@@ -1882,6 +1923,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n+      __first = std::__find_if_not(__first, __last, __pred);\n+\n       if (__first == __last)\n \treturn __first;\n       else\n@@ -1901,7 +1944,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t\t  _DistanceType(__buf.size()));\n \telse\n \t  return\n-\t    std::__inplace_stable_partition(__first, __last, __pred,\n+\t    std::__inplace_stable_partition(__first, __pred,\n \t\t\t\t\t _DistanceType(__buf.requested_size()));\n \t}\n     }"}, {"sha": "95d500618798c34c006d837f20a616b1b5d61ab3", "filename": "libstdc++-v3/testsuite/25_algorithms/stable_partition/moveable.cc", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fmoveable.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fmoveable.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fmoveable.cc?ref=2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "patch": "@@ -35,14 +35,19 @@ const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n const int B[] = {2, 4, 6, 8, 10, 12, 14, 16, 1, 3, 5, 7, 9, 11, 13, 15, 17};\n const int N = sizeof(A) / sizeof(int);\n \n+// Check that starting with a true predicate works too. (PR52822)\n+const int A2[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+const int B2[] = {2, 4, 6, 8, 10, 12, 14, 16, 3, 5, 7, 9, 11, 13, 15, 17};\n+const int N2 = sizeof(A2) / sizeof(int);\n+\n struct Pred\n {\n   bool\n   operator()(const rvalstruct& x) const\n   { return (x.val % 2) == 0; }\n };\n \n-// 25.2.12 stable_partition()\n+// 25.2.12 stable_partition(), starting with a false predicate.\n void\n test01()\n {\n@@ -56,9 +61,24 @@ test01()\n   VERIFY( std::equal(s1, s1 + N, B) );\n }\n \n+// 25.2.12 stable_partition(), starting with a true predicate.\n+void\n+test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  rvalstruct s1[N2];\n+  std::copy(A2, A2 + N2, s1);\n+  Container con(s1, s1 + N2);\n+\n+  std::stable_partition(con.begin(), con.end(), Pred());\n+  VERIFY( std::equal(s1, s1 + N2, B2) );\n+}\n+\n int\n main()\n {\n   test01();\n+  test02();\n   return 0;\n }"}, {"sha": "c5f95f367791be5dca51992e41596c91de7d5c8a", "filename": "libstdc++-v3/testsuite/25_algorithms/stable_partition/pr52822.cc", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fpr52822.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2fc9b37dd021df4f3edbda3be09bd891b5bf71e3/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fpr52822.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fstable_partition%2Fpr52822.cc?ref=2fc9b37dd021df4f3edbda3be09bd891b5bf71e3", "patch": "@@ -0,0 +1,43 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2012 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// 25.2.12 [lib.alg.partitions] Partitions.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+bool true_vector_pred(const std::vector<int>&) { return true; }\n+\n+void\n+test01()\n+{\n+  std::vector<std::vector<int> > v(1);\n+  v[0].push_back(7);\n+  VERIFY( v[0].size() == 1 );\n+  std::stable_partition(v.begin(), v.end(), &true_vector_pred);\n+  VERIFY( v[0].size() == 1 );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}