{"sha": "103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAzYzYzYWViOWI2YmI4NTZmZjhhMzRiN2UzNWQwZGM3YWI5YmY4Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-06-06T16:38:49Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-06-06T16:38:49Z"}, "message": "eh-common.h (EH_ALLOC_SIZE, [...]): New #defines.\n\ngcc:\n \t* eh-common.h (EH_ALLOC_SIZE, EH_ALLOC_ALIGN): New #defines.\n\t(eh_context): Add alloc_mask and alloc_buffer emergency fallback\n\tspace.\n\t* libgcc2.c (__eh_alloc): Moved from cp/exception.cc. Fallback on\n\temergency eh_context buffer, if malloc fails.\n\t(__eh_free): Moved from cp/exception.cc. Release to emergency\n\teh_context buffer, if appropriate.\ngcc/cp:\n\t* exception.cc: (__eh_alloc, __eh_free): Moved to libgcc2.c\n\nFrom-SVN: r34429", "tree": {"sha": "cd362ecde7373e378f1d9a95a1254c3695dd5541", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd362ecde7373e378f1d9a95a1254c3695dd5541"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/comments", "author": null, "committer": null, "parents": [{"sha": "051ffad528a782b867004c729a01a1db696ec82f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/051ffad528a782b867004c729a01a1db696ec82f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/051ffad528a782b867004c729a01a1db696ec82f"}], "stats": {"total": 128, "additions": 105, "deletions": 23}, "files": [{"sha": "3f24d77affd133aeca65ed84213bcbe3a561074f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "patch": "@@ -1,3 +1,13 @@\n+2000-06-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+ \t* eh-common.h (EH_ALLOC_SIZE, EH_ALLOC_ALIGN): New #defines.\n+\t(eh_context): Add alloc_mask and alloc_buffer emergency fallback\n+\tspace.\n+\t* libgcc2.c (__eh_alloc): Moved from cp/exception.cc. Fallback on\n+\temergency eh_context buffer, if malloc fails.\n+\t(__eh_free): Moved from cp/exception.cc. Release to emergency\n+\teh_context buffer, if appropriate.\n+\n 2000-06-06  Jason Merrill  <jason@casey.soma.redhat.com>\n \n \t* expr.c (store_expr): Fix typo."}, {"sha": "198ff67c02a0f3859d836aa09be49f8e0b1f21af", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "patch": "@@ -1,3 +1,7 @@\n+2000-06-06  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* exception.cc: (__eh_alloc, __eh_free): Moved to libgcc2.c\n+\n 2000-06-05  Jason Merrill  <jason@casey.soma.redhat.com>\n \n \t* search.c (maybe_suppress_debug_info): Don't check"}, {"sha": "1ffd7624a0980677677cdaf78d6a4c005fe10f63", "filename": "gcc/cp/exception.cc", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Fcp%2Fexception.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Fcp%2Fexception.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexception.cc?ref=103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "patch": "@@ -118,6 +118,10 @@ struct cp_eh_info\n \n extern \"C\" cp_eh_info **__get_eh_info (); \t// actually void **\n \n+/* Exception allocate and free, defined in libgcc2. */\n+extern \"C\" void *__eh_alloc(size_t);\n+extern \"C\" void __eh_free();\n+\n /* Is P the type_info node for a pointer of some kind?  */\n \n extern bool __is_pointer (void *);\n@@ -159,29 +163,6 @@ __start_cp_handler (void)\n   return p;\n }\n \n-/* Allocate a buffer for a cp_eh_info and an exception object of size SIZE,\n-   and return a pointer to the beginning of the object's space.  */\n-\n-extern \"C\" void * malloc (size_t);\n-extern \"C\" void *\n-__eh_alloc (size_t size)\n-{\n-  void *p = malloc (size);\n-  if (p == 0)\n-    terminate ();\n-  return p;\n-}\n-\n-/* Free the memory for an cp_eh_info and associated exception, given\n-   a pointer to the cp_eh_info.  */\n-\n-extern \"C\" void free (void *);\n-extern \"C\" void\n-__eh_free (void *p)\n-{\n-  free (p);\n-}\n-\n extern \"C\" int __throw_type_match_rtti_2 (const void *, const void *,\n \t\t\t\t\t void *, void **);\n "}, {"sha": "5303d6db47455f12560021ecebaa6d1ea55ea440", "filename": "gcc/eh-common.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Feh-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Feh-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Feh-common.h?ref=103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "patch": "@@ -39,6 +39,20 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    The routine get_dynamic_handler_chain() also has a dependancy on\n    the location of 'dynamic_handler_chain'. If its location is changed, \n    that routine must be modified as well. */\n+#ifndef EH_ALLOC_SIZE\n+/* 192 bytes means the entire eh_context plus malloc overhead fits in 256\n+   bytes (assuming 8 byte pointers). 192 bytes gives an eh_info and object\n+   size limit of 96 bytes. This should be sufficient for throwing bad_alloc. */\n+#define EH_ALLOC_SIZE 192\n+#endif\n+#ifndef EH_ALLOC_ALIGN\n+/* We can't use BIGGEST_ALIGNMENT, because on some systems, that expands to\n+   a check on a compile time switch like\n+   'target_flags & MASK_ALIGN_DOUBLE ? 64 : 32'. There's no macro for\n+   'largest alignment for any code this compiler can build for', which is\n+   really what is needed. */\n+#define EH_ALLOC_ALIGN 16\n+#endif\n \n struct eh_context\n {\n@@ -48,6 +62,10 @@ struct eh_context\n   void *info;\n   /* This is used to remember where we threw for re-throws */\n   void *table_index;  /* address of exception table entry to rethrow from */\n+  /* emergency fallback space, if malloc fails during handling */\n+  char alloc_buffer[EH_ALLOC_SIZE]\n+      __attribute__((__aligned__(EH_ALLOC_ALIGN)));\n+  unsigned alloc_mask;\n };\n \n #ifndef EH_TABLE_LOOKUP"}, {"sha": "305d7f085d512c7f0924ce3995390eb54317b8ba", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=103c63aeb9b6bb856ff8a34b7e35d0dc7ab9bf83", "patch": "@@ -3190,6 +3190,75 @@ eh_context_specific (void)\n }\n #endif /* __GTHREADS */\n \f\n+/* Support routines for alloc/free during exception handling */\n+\n+/* __eh_alloc and __eh_free attempt allocation using malloc, but fall back to\n+   the small arena in the eh_context. This is needed because throwing an\n+   out-of-memory exception would fail otherwise. The emergency space is\n+   allocated in blocks of size EH_ALLOC_ALIGN, the\n+   minimum allocation being two blocks. A bitmask indicates which blocks\n+   have been allocated. To indicate the size of an allocation, the bit for\n+   the final block is not set. Hence each allocation is a run of 1s followed\n+   by a zero. */\n+void *\n+__eh_alloc (size_t size)\n+{\n+  void *p;\n+  \n+  if (!size)\n+    abort();\n+  p = malloc (size);\n+  if (p == 0)\n+    {\n+      struct eh_context *eh = __get_eh_context ();\n+      unsigned blocks = (size + EH_ALLOC_ALIGN - 1) / EH_ALLOC_ALIGN;\n+      unsigned real_mask = eh->alloc_mask | (eh->alloc_mask << 1);\n+      unsigned our_mask;\n+      unsigned ix;\n+      \n+      if (blocks > EH_ALLOC_SIZE / EH_ALLOC_ALIGN)\n+        __terminate ();\n+      blocks += blocks == 1;\n+      our_mask = (1 << blocks) - 1;\n+      \n+      for (ix = EH_ALLOC_SIZE / EH_ALLOC_ALIGN - blocks; ix; ix--)\n+\tif (! ((real_mask >> ix) & our_mask))\n+\t  {\n+\t    /* found some space */\n+\t    p = &eh->alloc_buffer[ix * EH_ALLOC_ALIGN];\n+\t    eh->alloc_mask |= (our_mask >> 1) << ix;\n+\t    return p;\n+\t  }\n+      __terminate ();\n+    }\n+  return p;\n+}\n+\n+/* Free the memory for an cp_eh_info and associated exception, given\n+   a pointer to the cp_eh_info.  */\n+void\n+__eh_free (void *p)\n+{\n+  struct eh_context *eh = __get_eh_context ();\n+\n+  ptrdiff_t  diff = (char *)p - &eh->alloc_buffer[0];\n+  if (diff >= 0 && diff < EH_ALLOC_SIZE)\n+    {\n+      unsigned mask = eh->alloc_mask;\n+      unsigned bit = 1 << (diff / EH_ALLOC_ALIGN);\n+      \n+      do\n+\t{\n+\t  mask ^= bit;\n+\t  bit <<= 1;\n+\t}\n+      while (mask & bit);\n+      eh->alloc_mask = mask;\n+    }\n+  else\n+    free (p);\n+}\n+\f\n /* Support routines for setjmp/longjmp exception handling.  */\n \n /* Calls to __sjthrow are generated by the compiler when an exception"}]}