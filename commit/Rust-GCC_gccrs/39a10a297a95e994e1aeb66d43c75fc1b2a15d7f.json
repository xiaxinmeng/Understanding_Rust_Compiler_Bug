{"sha": "39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzlhMTBhMjk3YTk1ZTk5NGUxYWViNjZkNDNjNzVmYzFiMmExNWQ3Zg==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "2000-09-06T09:12:51Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2000-09-06T09:12:51Z"}, "message": "rs6000.c (validate_condition_mode): New function.\n\n* config/rs6000/rs6000.c (validate_condition_mode): New function.\n(branch_comparison_operator): Call validate_condition_mode to\nabort rather than returning 0.\n(branch_positive_comparison_operator): New function.\n(scc_comparison_operator): Call validate_condition_mode to abort\nrather than returning 0.\n(ccr_bit): Call validate_condition_mode.  Update for\nnew branch scheme.\n(print_operand): Delete %C modifier.  Update %E case\nto use EQ bit not SO bit.\n(rs6000_reverse_condition): New function.\n(rs6000_generate_compare): New function.\n(rs6000_emit_sCOND): New function.\n(rs6000_emit_cbranch): New function.\n(output_cbranch): The length of a long branch insn is\nnow only 8 bytes.  Add validate_condition_mode.  Use\nrs6000_reverse_condition.  Remove cror generation.\n* config/rs6000/rs6000.h: Update comments.\n(PREDICATE_CODES): Add new predicate.  Update codes used\nby branch_comparison_operator and scc_comparison_operator.\n* config/rs6000/rs6000-protos.h: Add prototypes for\nnew external functions.\n* config/rs6000/rs6000.md: Add new scheduling parameters\nfor cr_logical instructions.  Change length of branch\ninstructions.\n(bCOND patterns): Call rs6000_emit_cbranch.\n(sCOND patterns): Call rs6000_emit_sCOND.\n(branch patterns): Change lengths to 4.\n(cr logical patterns): New.\n\nFrom-SVN: r36191", "tree": {"sha": "b7cc73d2c5daab569be640d46abbcb472c5b15ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7cc73d2c5daab569be640d46abbcb472c5b15ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/comments", "author": null, "committer": null, "parents": [{"sha": "6e92b232be51d39eb147f167119a493785a2e98b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e92b232be51d39eb147f167119a493785a2e98b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e92b232be51d39eb147f167119a493785a2e98b"}], "stats": {"total": 1131, "additions": 514, "deletions": 617}, "files": [{"sha": "1795692a707b3f7ca81668f624db779878873ffc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "patch": "@@ -1,3 +1,35 @@\n+2000-09-06  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/rs6000/rs6000.c (validate_condition_mode): New function.\n+\t(branch_comparison_operator): Call validate_condition_mode to\n+\tabort rather than returning 0.\n+\t(branch_positive_comparison_operator): New function.\n+\t(scc_comparison_operator): Call validate_condition_mode to abort\n+\trather than returning 0.\n+\t(ccr_bit): Call validate_condition_mode.  Update for\n+\tnew branch scheme.\n+\t(print_operand): Delete %C modifier.  Update %E case\n+\tto use EQ bit not SO bit.\n+\t(rs6000_reverse_condition): New function.\n+\t(rs6000_generate_compare): New function.\n+\t(rs6000_emit_sCOND): New function.\n+\t(rs6000_emit_cbranch): New function.\n+\t(output_cbranch): The length of a long branch insn is\n+\tnow only 8 bytes.  Add validate_condition_mode.  Use\n+\trs6000_reverse_condition.  Remove cror generation.\n+\t* config/rs6000/rs6000.h: Update comments.\n+\t(PREDICATE_CODES): Add new predicate.  Update codes used\n+\tby branch_comparison_operator and scc_comparison_operator.\n+\t* config/rs6000/rs6000-protos.h: Add prototypes for\n+\tnew external functions.\n+\t* config/rs6000/rs6000.md: Add new scheduling parameters\n+\tfor cr_logical instructions.  Change length of branch\n+\tinstructions.\n+\t(bCOND patterns): Call rs6000_emit_cbranch.\n+\t(sCOND patterns): Call rs6000_emit_sCOND.\n+\t(branch patterns): Change lengths to 4.\n+\t(cr logical patterns): New.\n+\n 2000-09-06  Richard Henderson  <rth@cygnus.com>\n \n \t* config/i386/i386.md (call_pop): Fix test for setting"}, {"sha": "38b35deb469bc3dbf8288a70db6124d5d60445f2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "patch": "@@ -73,6 +73,8 @@ extern int expand_block_move PARAMS ((rtx[]));\n extern int load_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int store_multiple_operation PARAMS ((rtx, enum machine_mode));\n extern int branch_comparison_operator PARAMS ((rtx, enum machine_mode));\n+extern int branch_positive_comparison_operator \n+  PARAMS ((rtx, enum machine_mode));\n extern int scc_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int trap_comparison_operator PARAMS ((rtx, enum machine_mode));\n extern int boolean_operator PARAMS ((rtx, enum machine_mode));\n@@ -87,6 +89,10 @@ extern enum reg_class secondary_reload_class PARAMS ((enum reg_class,\n extern int ccr_bit PARAMS ((rtx, int));\n extern void print_operand PARAMS ((FILE *, rtx, int));\n extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern enum rtx_code rs6000_reverse_condition PARAMS ((enum machine_mode,\n+\t\t\t\t\t\t       enum rtx_code));\n+extern void rs6000_emit_sCOND PARAMS ((enum rtx_code, rtx));\n+extern void rs6000_emit_cbranch PARAMS ((enum rtx_code, rtx));\n extern char * output_cbranch PARAMS ((rtx, const char *, int, rtx));\n extern void output_toc PARAMS ((FILE *, rtx, int, enum machine_mode));\n extern int rs6000_adjust_cost PARAMS ((rtx, rtx, rtx, int));"}, {"sha": "c1771f5cae4e62fd670c133d870ba54d678b2ee4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 213, "deletions": 104, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "patch": "@@ -119,6 +119,9 @@ static int rs6000_sr_alias_set;\n static void rs6000_add_gc_roots PARAMS ((void));\n static int num_insns_constant_wide PARAMS ((HOST_WIDE_INT));\n static rtx expand_block_move_mem PARAMS ((enum machine_mode, rtx, rtx));\n+static void validate_condition_mode \n+  PARAMS ((enum rtx_code, enum machine_mode));\n+static rtx rs6000_generate_compare PARAMS ((enum rtx_code));\n static void rs6000_maybe_dead PARAMS ((rtx));\n static void rs6000_emit_stack_tie PARAMS ((void));\n static void rs6000_frame_related PARAMS ((rtx, rtx, HOST_WIDE_INT, rtx, rtx));\n@@ -3212,6 +3215,48 @@ stmw_operation (op, mode)\n   return 1;\n }\n \f\n+\n+/* A validation routine:  say whether CODE, a condition code,\n+   and MODE match.  The other alternatives either don't make\n+   sense or should never be generated.  */\n+static void\n+validate_condition_mode (code, mode)\n+     enum rtx_code code;\n+     enum machine_mode mode;\n+{\n+  if (GET_RTX_CLASS (code) != '<' \n+      || GET_MODE_CLASS (mode) != MODE_CC)\n+    abort ();\n+\n+  /* These don't make sense.  */\n+  if ((code == GT || code == LT || code == GE || code == LE)\n+      && mode == CCUNSmode)\n+    abort ();\n+\n+  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n+      && mode != CCUNSmode)\n+    abort ();\n+\n+  if (mode != CCFPmode\n+      && (code == ORDERED || code == UNORDERED\n+\t  || code == UNEQ || code == LTGT\n+\t  || code == UNGT || code == UNLT\n+\t  || code == UNGE || code == UNLE))\n+    abort();\n+  \n+  /* These should never be generated.  */\n+  if (mode == CCFPmode\n+      && (code == LE || code == GE\n+\t  || code == UNEQ || code == LTGT\n+\t  || code == UNGT || code == UNLT))\n+    abort ();\n+\n+  /* These are invalid; the information is not there.  */\n+  if (mode == CCEQmode \n+      && code != EQ && code != NE)\n+    abort ();\n+}\n+\n /* Return 1 if OP is a comparison operation that is valid for a branch insn.\n    We only check the opcode against the mode of the CC value here.  */\n \n@@ -3230,17 +3275,32 @@ branch_comparison_operator (op, mode)\n   if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n     return 0;\n \n-  if ((code == GT || code == LT || code == GE || code == LE)\n-      && cc_mode == CCUNSmode)\n-    return 0;\n+  validate_condition_mode (code, cc_mode);\n \n-  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n-      && (cc_mode != CCUNSmode))\n+  return 1;\n+}\n+\n+/* Return 1 if OP is a comparison operation that is valid for a branch\n+   insn and which is true if the corresponding bit in the CC register\n+   is set.  */\n+\n+int\n+branch_positive_comparison_operator (op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code;\n+\n+  if (! branch_comparison_operator (op, mode))\n     return 0;\n \n-  return 1;\n+  code = GET_CODE (op);\n+  return (code == EQ || code == LT || code == GT\n+\t  || code == LTU || code == GTU\n+\t  || code == UNORDERED);\n }\n \n+\n /* Return 1 if OP is a comparison operation that is valid for an scc insn.\n    We check the opcode against the mode of the CC value and disallow EQ or\n    NE comparisons for integers.  */\n@@ -3263,18 +3323,9 @@ scc_comparison_operator (op, mode)\n   if (GET_MODE_CLASS (cc_mode) != MODE_CC)\n     return 0;\n \n-  if (code == NE && cc_mode != CCFPmode)\n-    return 0;\n-\n-  if ((code == GT || code == LT || code == GE || code == LE)\n-      && cc_mode == CCUNSmode)\n-    return 0;\n+  validate_condition_mode (code, cc_mode);\n \n-  if ((code == GTU || code == LTU || code == GEU || code == LEU)\n-      && (cc_mode != CCUNSmode))\n-    return 0;\n-\n-  if (cc_mode == CCEQmode && code != EQ && code != NE)\n+  if (code == NE && cc_mode != CCFPmode)\n     return 0;\n \n   return 1;\n@@ -3287,8 +3338,7 @@ trap_comparison_operator (op, mode)\n {\n   if (mode != VOIDmode && mode != GET_MODE (op))\n     return 0;\n-  return (GET_RTX_CLASS (GET_CODE (op)) == '<'\n-          || GET_CODE (op) == EQ || GET_CODE (op) == NE);\n+  return GET_RTX_CLASS (GET_CODE (op)) == '<';\n }\n \n int\n@@ -3538,11 +3588,7 @@ ccr_bit (op, scc_p)\n   cc_regnum = REGNO (reg);\n   base_bit = 4 * (cc_regnum - CR0_REGNO);\n \n-  /* In CCEQmode cases we have made sure that the result is always in the\n-     third bit of the CR field.  */\n-\n-  if (cc_mode == CCEQmode)\n-    return base_bit + 3;\n+  validate_condition_mode (code, cc_mode);\n \n   switch (code)\n     {\n@@ -3558,16 +3604,13 @@ ccr_bit (op, scc_p)\n       return base_bit + 3;\n \n     case GE:  case GEU:\n-      /* If floating-point, we will have done a cror to put the bit in the\n+      /* If scc, we will have done a cror to put the bit in the\n \t unordered position.  So test that bit.  For integer, this is ! LT\n \t unless this is an scc insn.  */\n-      return cc_mode == CCFPmode || scc_p ? base_bit + 3 : base_bit;\n+      return scc_p ? base_bit + 3 : base_bit;\n \n     case LE:  case LEU:\n-      return cc_mode == CCFPmode || scc_p ? base_bit + 3 : base_bit + 1;\n-\n-    case UNEQ: case UNGT: case UNLT: case LTGT:\n-      return base_bit + 3;\n+      return scc_p ? base_bit + 3 : base_bit + 1;\n \n     default:\n       abort ();\n@@ -3710,40 +3753,11 @@ print_operand (file, x, code)\n       /* %c is output_addr_const if a CONSTANT_ADDRESS_P, otherwise\n \t output_operand.  */\n \n-    case 'C':\n-      {\n-\tenum rtx_code code = GET_CODE (x);\n-\t\n-\t/* This is an optional cror needed for certain floating-point\n-\t   comparisons.  Otherwise write nothing.  */\n-\tif ((code == LE || code == GE\n-\t     || code == UNEQ || code == LTGT\n-\t     || code == UNGT || code == UNLT)\n-\t    && GET_MODE (XEXP (x, 0)) == CCFPmode)\n-\t  {\n-\t    int base_bit = 4 * (REGNO (XEXP (x, 0)) - CR0_REGNO);\n-\t    int bit0, bit1;\n-\t    \n-\t    if (code == UNEQ)\n-\t      bit0 = 2;\n-\t    else if (code == UNGT || code == GE)\n-\t      bit0 = 1;\n-\t    else\n-\t      bit0 = 0;\n-\t    if (code == LTGT)\n-\t      bit1 = 1;\n-\t    else if (code == LE || code == GE)\n-\t      bit1 = 2;\n-\t    else\n-\t      bit1 = 3;\n-\t    \n-\t    fprintf (file, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t     base_bit + bit1, base_bit + bit0);\n-\t  }\n-      }\n-      return;\n-\n     case 'D':\n+      /* There used to be a comment for 'C' reading \"This is an\n+\t   optional cror needed for certain floating-point\n+\t   comparisons.  Otherwise write nothing.\"  */\n+\n       /* Similar, except that this is for an scc, so we must be able to\n \t encode the test in a single bit that is one.  We do the above\n \t for any LE, GE, GEU, or LEU and invert the bit for NE.  */\n@@ -3767,11 +3781,11 @@ print_operand (file, x, code)\n       return;\n \n     case 'E':\n-      /* X is a CR register.  Print the number of the third bit of the CR */\n+      /* X is a CR register.  Print the number of the EQ bit of the CR */\n       if (GET_CODE (x) != REG || ! CR_REGNO_P (REGNO (x)))\n \toutput_operand_lossage (\"invalid %%E value\");\n       else\n-\tfprintf (file, \"%d\", 4 * (REGNO (x) - CR0_REGNO) + 3);\n+\tfprintf (file, \"%d\", 4 * (REGNO (x) - CR0_REGNO) + 2);\n       return;\n \n     case 'f':\n@@ -4013,7 +4027,9 @@ print_operand (file, x, code)\n     case 'q':\n       /* This outputs the logical code corresponding to a boolean\n \t expression.  The expression may have one or both operands\n-\t negated (if one, only the first one).  */\n+\t negated (if one, only the first one).  For condition register\n+         logical operations, it will also treat the negated\n+         CR codes as NOTs, but not handle NOTs of them.  */\n       {\n \tconst char *const *t = 0;\n \tconst char *s;\n@@ -4420,6 +4436,129 @@ print_operand_address (file, x)\n     abort ();\n }\n \f\n+enum rtx_code\n+rs6000_reverse_condition (mode, code)\n+     enum machine_mode mode;\n+     enum rtx_code code;\n+{\n+  /* Reversal of FP compares takes care -- an ordered compare\n+     becomes an unordered compare and vice versa.  */\n+  if (mode == CCFPmode)\n+    code = reverse_condition_maybe_unordered (code);\n+  else\n+    code = reverse_condition (code);\n+}\n+\n+\n+/* Generate a compare for CODE.  Return a brand-new rtx that\n+   represents the result of the compare.  */\n+static rtx\n+rs6000_generate_compare (code)\n+     enum rtx_code code;\n+{\n+  enum machine_mode comp_mode;\n+  rtx compare_result;\n+\n+  if (rs6000_compare_fp_p)\n+    comp_mode = CCFPmode;\n+  else if (code == GTU || code == LTU\n+\t  || code == GEU || code == LEU)\n+    comp_mode = CCUNSmode;\n+  else\n+    comp_mode = CCmode;\n+\n+  /* First, the compare.  */\n+  compare_result = gen_reg_rtx (comp_mode);\n+  emit_insn (gen_rtx_SET (VOIDmode, compare_result,\n+\t\t\t  gen_rtx_COMPARE (comp_mode,\n+\t\t\t\t\t   rs6000_compare_op0, \n+\t\t\t\t\t   rs6000_compare_op1)));\n+  \n+  /* Some kinds of FP comparisons need an OR operation.  */\n+  if (rs6000_compare_fp_p\n+      && (code == LE || code == GE\n+\t  || code == UNEQ || code == LTGT\n+\t  || code == UNGT || code == UNLT))\n+    {\n+      enum rtx_code or1, or2;\n+      rtx or1_rtx, or2_rtx, compare2_rtx;\n+      rtx or_result = gen_reg_rtx (CCEQmode);\n+      \n+      switch (code)\n+\t{\n+\tcase LE: or1 = LT;  or2 = EQ;  break;\n+\tcase GE: or1 = GT;  or2 = EQ;  break;\n+\tcase UNEQ: or1 = UNORDERED;  or2 = EQ;  break;\n+\tcase LTGT: or1 = LT;  or2 = GT;  break;\n+\tcase UNGT: or1 = UNORDERED;  or2 = GT;  break;\n+\tcase UNLT: or1 = UNORDERED;  or2 = LT;  break;\n+\tdefault:  abort ();\n+\t}\n+      validate_condition_mode (or1, comp_mode);\n+      validate_condition_mode (or2, comp_mode);\n+      or1_rtx = gen_rtx (or1, SImode, compare_result, const0_rtx);\n+      or2_rtx = gen_rtx (or2, SImode, compare_result, const0_rtx);\n+      compare2_rtx = gen_rtx_COMPARE (CCEQmode,\n+\t\t\t\t      gen_rtx_IOR (SImode, or1_rtx, or2_rtx),\n+\t\t\t\t      const_true_rtx);\n+      emit_insn (gen_rtx_SET (VOIDmode, or_result, compare2_rtx));\n+\n+      compare_result = or_result;\n+      code = EQ;\n+    }\n+\n+  validate_condition_mode (code, GET_MODE (compare_result));\n+  \n+  return gen_rtx (code, VOIDmode, compare_result, const0_rtx);\n+}\n+\n+\n+/* Emit the RTL for an sCOND pattern.  */\n+\n+void\n+rs6000_emit_sCOND (code, result)\n+     enum rtx_code code;\n+     rtx result;\n+{\n+  rtx condition_rtx;\n+  enum machine_mode op_mode;\n+\n+  condition_rtx = rs6000_generate_compare (code);\n+\n+  op_mode = GET_MODE (rs6000_compare_op0);\n+  if (op_mode == VOIDmode)\n+    op_mode = GET_MODE (rs6000_compare_op1);\n+\n+  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n+    {\n+      PUT_MODE (condition_rtx, DImode);\n+      convert_move (result, condition_rtx, 0);\n+    }\n+  else\n+    {\n+      PUT_MODE (condition_rtx, SImode);\n+      emit_insn (gen_rtx_SET (VOIDmode, result, condition_rtx));\n+    }\n+}\n+\n+\n+/* Emit a branch of kind CODE to location LOC.  */\n+\n+void\n+rs6000_emit_cbranch (code, loc)\n+     enum rtx_code code;\n+     rtx loc;\n+{\n+  rtx condition_rtx, loc_ref;\n+\n+  condition_rtx = rs6000_generate_compare (code);\n+  loc_ref = gen_rtx_LABEL_REF (VOIDmode, loc);\n+  emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,\n+\t\t\t       gen_rtx_IF_THEN_ELSE (VOIDmode, condition_rtx,\n+\t\t\t\t\t\t     loc_ref, pc_rtx)));\n+}\n+\n+\n /* Return the string to output a conditional branch to LABEL, which is\n    the operand number of the label, or -1 if the branch is really a\n    conditional return.  \n@@ -4444,52 +4583,22 @@ output_cbranch (op, label, reversed, insn)\n   rtx cc_reg = XEXP (op, 0);\n   enum machine_mode mode = GET_MODE (cc_reg);\n   int cc_regno = REGNO (cc_reg) - CR0_REGNO;\n-  int need_longbranch = label != NULL && get_attr_length (insn) == 12;\n+  int need_longbranch = label != NULL && get_attr_length (insn) == 8;\n   int really_reversed = reversed ^ need_longbranch;\n   char *s = string;\n   const char *ccode;\n   const char *pred;\n   rtx note;\n \n-  /* Work out which way this really branches.  */\n+  validate_condition_mode (code, mode);\n+\n+  /* Work out which way this really branches.  We could use\n+     reverse_condition_maybe_unordered here always but this\n+     makes the resulting assembler clearer.  */\n   if (really_reversed)\n-    {\n-      /* Reversal of FP compares takes care -- an ordered compare\n-\t becomes an unordered compare and vice versa.  */\n-      if (mode == CCFPmode)\n-\tcode = reverse_condition_maybe_unordered (code);\n-      else\n-\tcode = reverse_condition (code);\n-    }\n+    code = rs6000_reverse_condition (mode, code);\n \n-  /* If needed, print the CROR required for various floating-point\n-     comparisons; and decide on the condition code to test.  */\n-  if ((code == LE || code == GE\n-       || code == UNEQ || code == LTGT\n-       || code == UNGT || code == UNLT)\n-      && mode == CCFPmode)\n-    {\n-      int base_bit = 4 * cc_regno;\n-      int bit0, bit1;\n-      \n-      if (code == UNEQ)\n-\tbit0 = 2;\n-      else if (code == UNGT || code == GE)\n-\tbit0 = 1;\n-      else\n-\tbit0 = 0;\n-      if (code == LTGT)\n-\tbit1 = 1;\n-      else if (code == LE || code == GE)\n-\tbit1 = 2;\n-      else\n-\tbit1 = 3;\n-      \n-      s += sprintf (s, \"cror %d,%d,%d\\n\\t\", base_bit + 3,\n-\t\t    base_bit + bit1, base_bit + bit0);\n-      ccode = \"so\";\n-    }\n-  else switch (code)\n+  switch (code)\n     {\n       /* Not all of these are actually distinct opcodes, but\n \t we distinguish them for clarity of the resulting assembler.  */"}, {"sha": "be10201de36c104e8b826526ed4045525b7515b7", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 57, "deletions": 53, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "patch": "@@ -2275,18 +2275,19 @@ do {\t\t\t\t\t\t\t\t\t     \\\n    For the RS/6000, we need separate modes when unsigned (logical) comparisons\n    are being done and we need a separate mode for floating-point.  We also\n    use a mode for the case when we are comparing the results of two\n-   comparisons.  */\n+   comparisons, as then only the EQ bit is valid in the register.  */\n \n #define EXTRA_CC_MODES\t\t\\\n     CC(CCUNSmode,  \"CCUNS\")\t\\\n     CC(CCFPmode,   \"CCFP\")\t\\\n     CC(CCEQmode,   \"CCEQ\")\n \n-/* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n-   return the mode to be used for the comparison.  For floating-point, CCFPmode\n-   should be used.  CCUNSmode should be used for unsigned comparisons.\n-   CCEQmode should be used when we are doing an inequality comparison on\n-   the result of a comparison. CCmode should be used in all other cases.  */\n+/* Given a comparison code (EQ, NE, etc.) and the first operand of a\n+   COMPARE, return the mode to be used for the comparison.  For\n+   floating-point, CCFPmode should be used.  CCUNSmode should be used\n+   for unsigned comparisons.  CCEQmode should be used when we are\n+   doing an inequality comparison on the result of a\n+   comparison.  CCmode should be used in all other cases.  */\n \n #define SELECT_CC_MODE(OP,X,Y) \\\n   (GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT ? CCFPmode\t\\\n@@ -2720,54 +2721,57 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Define the codes that are matched by predicates in rs6000.c.  */\n \n-#define PREDICATE_CODES\t\t\t\t\t\t\\\n-  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\\\n-  {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\\\n-  {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"cc_reg_not_cr0_operand\", {SUBREG, REG}},\t\t\t\\\n-  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-  {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\\\n-  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}}, \t\\\n-  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n-  {\"reg_or_arith_cint_operand\", {SUBREG, REG, CONST_INT}}, \t\\\n+#define PREDICATE_CODES\t\t\t\t\t\t\t   \\\n+  {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\t   \\\n+  {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n+  {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n+  {\"gpc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n+  {\"cc_reg_operand\", {SUBREG, REG}},\t\t\t\t\t   \\\n+  {\"cc_reg_not_cr0_operand\", {SUBREG, REG}},\t\t\t\t   \\\n+  {\"reg_or_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n+  {\"reg_or_neg_short_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n+  {\"reg_or_u_short_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n+  {\"reg_or_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t\t   \\\n+  {\"reg_or_arith_cint_operand\", {SUBREG, REG, CONST_INT}},\t\t   \\\n   {\"reg_or_logical_cint_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}}, \\\n-  {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\\\n-  {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\\\n-  {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\\\n-  {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\\\n-  {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\\\n-  {\"volatile_mem_operand\", {MEM}},\t\t\t\t\\\n-  {\"offsettable_mem_operand\", {MEM}},\t\t\t\t\\\n-  {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\\\n-  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\\\n-  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-  {\"logical_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\\\n-  {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\\\n-  {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\\\n-  {\"rldic_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n-  {\"count_register_operand\", {REG}},\t\t\t\t\\\n-  {\"xer_operand\", {REG}},\t\t\t\t\t\\\n-  {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n-  {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\\\n-  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, \t\t\\\n-\t\t     CONST_DOUBLE, SYMBOL_REF}}, \t\t\\\n-  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\\\n-  {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n-\t\t\t\t  GT, LEU, LTU, GEU, GTU,\t\\\n-\t\t\t\t  UNORDERED, ORDERED,\t\t\\\n-\t\t\t\t  UNEQ, LTGT,\t\t\t\\\n-\t\t\t\t  UNGE, UNGT, UNLE, UNLT}},\t\\\n-  {\"scc_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n-\t\t\t       GT, LEU, LTU, GEU, GTU}},\t\\\n-  {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\\\n-\t\t\t\tGT, LEU, LTU, GEU, GTU}},\t\\\n-  {\"boolean_operator\", {AND, IOR, XOR}},\t\t\t\\\n+  {\"got_operand\", {SYMBOL_REF, CONST, LABEL_REF}},\t\t\t   \\\n+  {\"got_no_const_operand\", {SYMBOL_REF, LABEL_REF}},\t\t\t   \\\n+  {\"easy_fp_constant\", {CONST_DOUBLE}},\t\t\t\t\t   \\\n+  {\"reg_or_mem_operand\", {SUBREG, MEM, REG}},\t\t\t\t   \\\n+  {\"lwa_operand\", {SUBREG, MEM, REG}},\t\t\t\t\t   \\\n+  {\"volatile_mem_operand\", {MEM}},\t\t\t\t\t   \\\n+  {\"offsettable_mem_operand\", {MEM}},\t\t\t\t\t   \\\n+  {\"mem_or_easy_const_operand\", {SUBREG, MEM, CONST_DOUBLE}},\t\t   \\\n+  {\"add_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t   \\\n+  {\"non_add_cint_operand\", {CONST_INT}},\t\t\t\t   \\\n+  {\"and_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t   \\\n+  {\"and64_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n+  {\"logical_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t   \\\n+  {\"non_logical_cint_operand\", {CONST_INT, CONST_DOUBLE}},\t\t   \\\n+  {\"mask_operand\", {CONST_INT}},\t\t\t\t\t   \\\n+  {\"mask64_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t   \\\n+  {\"rldic_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\t   \\\n+  {\"count_register_operand\", {REG}},\t\t\t\t\t   \\\n+  {\"xer_operand\", {REG}},\t\t\t\t\t\t   \\\n+  {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\t   \\\n+  {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\t   \\\n+  {\"input_operand\", {SUBREG, MEM, REG, CONST_INT,\t\t\t   \\\n+\t\t     CONST_DOUBLE, SYMBOL_REF}},\t\t\t   \\\n+  {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n+  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t   \\\n+  {\"branch_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n+\t\t\t\t  GT, LEU, LTU, GEU, GTU,\t\t   \\\n+\t\t\t\t  UNORDERED, ORDERED,\t\t\t   \\\n+\t\t\t\t  UNGE, UNLE }},\t\t\t   \\\n+  {\"branch_positive_comparison_operator\", {EQ, LT, GT, LTU, GTU,\t   \\\n+\t\t\t\t\t   UNORDERED }},\t\t   \\\n+  {\"scc_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n+\t\t\t       GT, LEU, LTU, GEU, GTU,\t\t\t   \\\n+\t\t\t       UNORDERED, ORDERED,\t\t\t   \\\n+\t\t\t       UNGE, UNLE }},\t\t\t\t   \\\n+  {\"trap_comparison_operator\", {EQ, NE, LE, LT, GE,\t\t\t   \\\n+\t\t\t\tGT, LEU, LTU, GEU, GTU}},\t\t   \\\n+  {\"boolean_operator\", {AND, IOR, XOR}},\t\t\t\t   \\\n   {\"boolean_or_operator\", {IOR, XOR}},\n \n /* uncomment for disabling the corresponding default options */"}, {"sha": "cabfd96f512669861cde668739d30ecd3a0b04d7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 206, "deletions": 460, "changes": 666, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39a10a297a95e994e1aeb66d43c75fc1b2a15d7f/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=39a10a297a95e994e1aeb66d43c75fc1b2a15d7f", "patch": "@@ -37,7 +37,7 @@\n \f\n ;; Define an insn type attribute.  This is used in function unit delay\n ;; computations.\n-(define_attr \"type\" \"integer,load,store,fpload,fpstore,imul,lmul,idiv,ldiv,branch,compare,delayed_compare,fpcompare,mtjmpr,fp,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg\"\n+(define_attr \"type\" \"integer,load,store,fpload,fpstore,imul,lmul,idiv,ldiv,branch,compare,cr_logical,delayed_compare,fpcompare,mtjmpr,fp,dmul,sdiv,ddiv,ssqrt,dsqrt,jmpreg\"\n   (const_string \"integer\"))\n \n ;; Length (in bytes).\n@@ -47,8 +47,8 @@\n \t\t\t\t       (const_int -32768))\n \t\t\t\t   (lt (minus (pc) (match_dup 0))\n \t\t\t\t       (const_int 32767)))\n-\t\t\t      (const_int 8)\n-\t\t\t      (const_int 12))\n+\t\t\t      (const_int 4)\n+\t\t\t      (const_int 8))\n \t\t(const_int 4)))\n \n ;; Processor type -- this attribute must exactly match the processor_type\n@@ -123,6 +123,11 @@\n        (eq_attr \"cpu\" \"rios1,rs64a,mpccore,ppc403,ppc601,ppc603\"))\n   1 1)\n \n+(define_function_unit \"iu\" 1 0\n+  (and (eq_attr \"type\" \"cr_logical\")\n+       (eq_attr \"cpu\" \"rios1,rs64a,mpccore,ppc403,ppc601\"))\n+  1 1)\n+\n (define_function_unit \"iu\" 1 0\n   (and (eq_attr \"type\" \"imul\")\n        (eq_attr \"cpu\" \"ppc403\"))\n@@ -288,6 +293,15 @@\n        (eq_attr \"cpu\" \"ppc750\"))\n   19 19)\n \n+; CR-logical operations are execute-serialized, that is they don't\n+; start (and block the function unit) until all preceding operations\n+; have finished.  They don't block dispatch of other insns, though.\n+; I've imitated this by giving them longer latency.\n+(define_function_unit \"sru\" 1 0 \n+  (and (eq_attr \"type\" \"cr_logical\")\n+       (eq_attr \"cpu\" \"ppc603,ppc750\"))\n+  3 2)\n+\n ; compare is done on integer unit, but feeds insns which\n ; execute on the branch unit.\n (define_function_unit \"iu\" 1 0   \n@@ -357,6 +371,17 @@\n        (eq_attr \"cpu\" \"rs64a,mpccore,ppc403,ppc601,ppc603,ppc604,ppc604e,ppc620,ppc750\"))\n   4 1)\n \n+(define_function_unit \"bpu\" 1 0\n+  (and (eq_attr \"type\" \"cr_logical\")\n+       (eq_attr \"cpu\" \"ppc604,ppc620\"))\n+  4 1)\n+  \n+(define_function_unit \"cru\" 1 0\n+  (and (eq_attr \"type\" \"cr_logical\")\n+       (eq_attr \"cpu\" \"ppc604e\"))\n+  4 1)\n+  \n+\n ; all jumps/branches are executing on the bpu, in 1 cycle, for all machines.\n (define_function_unit \"bpu\" 1 0\n   (eq_attr \"type\" \"jmpreg\")\n@@ -9847,532 +9872,180 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n }\")\n \n (define_expand \"beq\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (eq (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (EQ, operands[0]); DONE; }\")\n \n (define_expand \"bne\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ne (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (NE, operands[0]); DONE; }\")\n \n-(define_expand \"blt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (lt (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"bge\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (GE, operands[0]); DONE; }\")\n \n (define_expand \"bgt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (gt (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (GT, operands[0]); DONE; }\")\n \n (define_expand \"ble\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (le (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (LE, operands[0]); DONE; }\")\n \n-(define_expand \"bge\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ge (match_dup 2)\n-\t\t\t  (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"blt\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-}\")\n+  \"{ rs6000_emit_cbranch (LT, operands[0]); DONE; }\")\n \n-(define_expand \"bgtu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (gtu (match_dup 2)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"bgeu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (GEU, operands[0]); DONE; }\")\n \n-(define_expand \"bltu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ltu (match_dup 2)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"bgtu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (GTU, operands[0]); DONE; }\")\n \n-(define_expand \"bgeu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (geu (match_dup 2)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"bleu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (LEU, operands[0]); DONE; }\")\n \n-(define_expand \"bleu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (leu (match_dup 2)\n-\t\t\t   (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+(define_expand \"bltu\"\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (LTU, operands[0]); DONE; }\")\n \n (define_expand \"bunordered\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (unordered (match_dup 2)\n-\t\t\t         (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNORDERED, operands[0]); DONE; }\")\n \n (define_expand \"bordered\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ordered (match_dup 2)\n-\t\t\t       (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (ORDERED, operands[0]); DONE; }\")\n \n (define_expand \"buneq\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (uneq (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNEQ, operands[0]); DONE; }\")\n \n (define_expand \"bunge\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (unge (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNGE, operands[0]); DONE; }\")\n \n (define_expand \"bungt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ungt (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNGT, operands[0]); DONE; }\")\n \n (define_expand \"bunle\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (unle (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNLE, operands[0]); DONE; }\")\n \n (define_expand \"bunlt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (unlt (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (UNLT, operands[0]); DONE; }\")\n \n (define_expand \"bltgt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (pc)\n-\t(if_then_else (ltgt (match_dup 2)\n-\t\t\t    (const_int 0))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))]\n+  [(use (match_operand 0 \"\" \"\"))]\n   \"\"\n-  \"\n-{ if (!rs6000_compare_fp_p) FAIL;\n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-}\")\n+  \"{ rs6000_emit_cbranch (LTGT, operands[0]); DONE; }\")\n \n ;; For SNE, we would prefer that the xor/abs sequence be used for integers.\n ;; For SEQ, likewise, except that comparisons with zero should be done\n ;; with an scc insns.  However, due to the order that combine see the\n ;; resulting insns, we must, in fact, allow SEQ for integers.  Fail in\n ;; the cases we don't want to handle.\n (define_expand \"seq\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(eq:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode, mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_EQ (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (EQ, operands[0]); DONE; }\")\n \n (define_expand \"sne\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ne:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n-{ if (! rs6000_compare_fp_p)\n+{ \n+  if (! rs6000_compare_fp_p)\n     FAIL;\n \n-  operands[1] = gen_rtx_COMPARE (CCFPmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCFPmode);\n-\n-  if (TARGET_POWERPC64)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_NE (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n+  rs6000_emit_sCOND (NE, operands[0]); \n+  DONE;\n }\")\n \n ;; A > 0 is best done using the portable sequence, so fail in that case.\n (define_expand \"sgt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(gt:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n-{ enum machine_mode op_mode, mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-\n+{ \n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_GT (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n+  rs6000_emit_sCOND (GT, operands[0]); \n+  DONE;\n }\")\n \n ;; A < 0 is best done in the portable way for A an integer.\n (define_expand \"slt\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(lt:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n-{ enum machine_mode op_mode, mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-\n+{ \n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_LT (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n+  rs6000_emit_sCOND (LT, operands[0]); \n+  DONE;\n }\")\n \n (define_expand \"sge\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ge:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode, mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_GE (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (GE, operands[0]); DONE; }\")\n \n ;; A <= 0 is best done the portable way for A an integer.\n (define_expand \"sle\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(le:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n   \"\n-{ enum machine_mode op_mode, mode = rs6000_compare_fp_p ? CCFPmode : CCmode;\n-\n+{ \n   if (! rs6000_compare_fp_p && rs6000_compare_op1 == const0_rtx)\n     FAIL;\n \n-  operands[1] = gen_rtx_COMPARE (mode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (mode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && (op_mode == DImode || rs6000_compare_fp_p))\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_LE (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n+  rs6000_emit_sCOND (LE, operands[0]); \n+  DONE;\n }\")\n \n (define_expand \"sgtu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(gtu:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode;\n-\n-  operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && op_mode == DImode)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_GTU (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (GTU, operands[0]); DONE; }\")\n \n (define_expand \"sltu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(ltu:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode;\n-\n-  operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && op_mode == DImode)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_LTU (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (LTU, operands[0]); DONE; }\")\n \n (define_expand \"sgeu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(geu:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode;\n-\n-  operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && op_mode == DImode)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_GEU (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (GEU, operands[0]); DONE; }\")\n \n (define_expand \"sleu\"\n-  [(set (match_dup 2) (match_dup 1))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(leu:SI (match_dup 2) (const_int 0)))]\n+  [(clobber (match_operand:SI 0 \"gpc_reg_operand\" \"\"))]\n   \"\"\n-  \"\n-{ enum machine_mode op_mode;\n-\n-  operands[1] = gen_rtx_COMPARE (CCUNSmode,\n-\t\t\t\t rs6000_compare_op0, rs6000_compare_op1);\n-  operands[2] = gen_reg_rtx (CCUNSmode);\n-\n-  op_mode = GET_MODE (rs6000_compare_op0);\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (rs6000_compare_op1);\n-\n-  if (TARGET_POWERPC64 && op_mode == DImode)\n-    {\n-      emit_insn (gen_rtx_SET (VOIDmode, operands[2], operands[1]));\n-      convert_move (operands[0],\n-\t\t    gen_rtx_LEU (DImode, operands[2], const0_rtx), 0);\n-      DONE;\n-    }\n-}\")\n+  \"{ rs6000_emit_sCOND (LEU, operands[0]); DONE; }\")\n \f\n ;; Here are the actual compare insns.\n (define_insn \"*cmpsi_internal1\"\n@@ -10632,38 +10305,6 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n \t\t    (const_int 0)))]\n   \"\")\n \n-;; If we are comparing the result of two comparisons, this can be done\n-;; using creqv or crxor.\n-\n-(define_insn \"\"\n-  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CCEQ (match_operator 1 \"scc_comparison_operator\"\n-\t\t\t      [(match_operand 2 \"cc_reg_operand\" \"y\")\n-\t\t\t       (const_int 0)])\n-\t\t      (match_operator 3 \"scc_comparison_operator\"\n-\t\t\t      [(match_operand 4 \"cc_reg_operand\" \"y\")\n-\t\t\t       (const_int 0)])))]\n-  \"REGNO (operands[2]) != REGNO (operands[4])\"\n-  \"*\n-{\n-  enum rtx_code code1, code2;\n-\n-  code1 = GET_CODE (operands[1]);\n-  code2 = GET_CODE (operands[3]);\n-\n-  if ((code1 == EQ || code1 == LT || code1 == GT\n-       || code1 == LTU || code1 == GTU\n-       || (code1 != NE && GET_MODE (operands[2]) == CCFPmode))\n-      !=\n-      (code2 == EQ || code2 == LT || code2 == GT\n-       || code2 == LTU || code2 == GTU\n-       || (code2 != NE && GET_MODE (operands[4]) == CCFPmode)))\n-    return \\\"%C1%C3crxor %E0,%j1,%j3\\\";\n-  else\n-    return \\\"%C1%C3creqv %E0,%j1,%j3\\\";\n-}\"\n-  [(set_attr \"length\" \"12\")])\n-\n ;; There is a 3 cycle delay between consecutive mfcr instructions\n ;; so it is useful to combine 2 scc instructions to use only one mfcr.\n \n@@ -13153,7 +12794,7 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   return output_cbranch (operands[0], NULL, 0, insn);\n }\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"length\" \"4\")])\n \n (define_insn \"\"\n   [(set (pc)\n@@ -13184,7 +12825,112 @@ operands[2] = GEN_INT (INTVAL (operands[1]) >> 32);\n   return output_cbranch (operands[0], NULL, 1, insn);\n }\"\n   [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"8\")])\n+   (set_attr \"length\" \"4\")])\n+\n+;; Logic on condition register values.\n+\n+; This pattern matches things like\n+; (set (reg:CCEQ 68) (compare:CCEQ (ior:SI (gt:SI (reg:CCFP 68) (const_int 0))\n+;\t\t\t\t\t   (eq:SI (reg:CCFP 68) (const_int 0)))\n+;\t\t\t\t   (const_int 1)))\n+; which are generated by the branch logic.\n+\n+(define_insn \"\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n+        (compare:CCEQ (match_operator:SI 1 \"boolean_operator\"\n+\t                [(match_operator:SI 2 \n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 3\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n+\t\t\t\t       (const_int 0)])\n+\t                 (match_operator:SI 4 \n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 5\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n+\t\t\t\t       (const_int 0)])])\n+\t\t      (const_int 1)))]\n+  \"\"\n+  \"cr%q1 %E0,%j2,%j4\"\n+  [(set_attr \"type\" \"cr_logical\")])\n+\n+; Why is the constant -1 here, but 1 in the previous pattern?\n+; Because ~1 has all but the low bit set.\n+(define_insn \"\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n+        (compare:CCEQ (match_operator:SI 1 \"boolean_or_operator\"\n+\t                [(not:SI (match_operator:SI 2 \n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 3\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n+\t\t\t\t       (const_int 0)]))\n+\t                 (match_operator:SI 4\n+\t\t\t\t\"branch_positive_comparison_operator\"\n+\t\t\t\t[(match_operand 5\n+\t\t\t\t\t\t\"cc_reg_operand\" \"y\")\n+\t\t\t\t (const_int 0)])])\n+\t\t      (const_int -1)))]\n+  \"\"\n+  \"cr%q1 %E0,%j2,%j4\"\n+  [(set_attr \"type\" \"cr_logical\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCEQ (match_operator:SI 2 \n+\t\t\t\t      \"branch_positive_comparison_operator\"\n+\t\t\t\t      [(match_operand 3\n+\t\t\t\t\t\t      \"cc_reg_operand\" \"y\")\n+\t\t\t\t       (const_int 0)])\n+\t\t      (const_int 0)))]\n+  \"\"\n+  \"crnot %E0,%j2\"\n+  [(set_attr \"type\" \"cr_logical\")])\n+\n+;; If we are comparing the result of two comparisons, this can be done\n+;; using creqv or crxor.\n+\n+(define_insn_and_split \"\"\n+  [(set (match_operand:CCEQ 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCEQ (match_operator 1 \"branch_comparison_operator\"\n+\t\t\t      [(match_operand 2 \"cc_reg_operand\" \"y\")\n+\t\t\t       (const_int 0)])\n+\t\t      (match_operator 3 \"branch_comparison_operator\"\n+\t\t\t      [(match_operand 4 \"cc_reg_operand\" \"y\")\n+\t\t\t       (const_int 0)])))]\n+  \"\"\n+  \"#\"\n+  \"\"\n+  [(set (match_dup 0) (compare:CCEQ (xor:SI (match_dup 1) (match_dup 3))\n+\t\t\t\t    (match_dup 5)))]\n+  \"\n+{\n+  int positive_1, positive_2;\n+\n+  positive_1 = branch_positive_comparison_operator (operands[1], CCEQmode);\n+  positive_2 = branch_positive_comparison_operator (operands[3], CCEQmode);\n+\n+  if (! positive_1)\n+    operands[1] = gen_rtx (SImode,\n+\t\t\t   rs6000_reverse_condition (GET_MODE (operands[2]),\n+\t\t\t\t\t\t     GET_CODE (operands[1])),\n+\t\t\t   operands[2]);\n+  else if (GET_MODE (operands[1]) != SImode)\n+    operands[1] = gen_rtx (SImode,\n+\t\t\t   GET_CODE (operands[1]),\n+\t\t\t   operands[2]);\n+\n+  if (! positive_2)\n+    operands[3] = gen_rtx (SImode,\n+\t\t\t   rs6000_reverse_condition (GET_MODE (operands[4]),\n+\t\t\t\t\t\t     GET_CODE (operands[3])),\n+\t\t\t   operands[4]);\n+  else if (GET_MODE (operands[3]) != SImode)\n+    operands[3] = gen_rtx (SImode,\n+\t\t\t   GET_CODE (operands[3]),\n+\t\t\t   operands[4]);\n+\n+  if (positive_1 == positive_2)\n+    operands[1] = gen_rtx_NOT (SImode, operands[1]);\n+}\")\n \n ;; Unconditional branch and return.\n "}]}