{"sha": "f2d71db6232200171b271499f0eeace035ad82cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjJkNzFkYjYyMzIyMDAxNzFiMjcxNDk5ZjBlZWFjZTAzNWFkODJjZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2000-09-11T14:19:53Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2000-09-11T14:19:53Z"}, "message": "cp-tree.h (frob_opname): Declare.\n\n\t* cp-tree.h (frob_opname): Declare.\n\t* parse.y (saved_scopes): New static variable.\n\t(cp_parse_init): Adjust.\n\t(do_id): If lastiddecl is NULL, do do_identifier.\n\t(operator): Save scope information.\n\t(unoperator): new reduction. Restore scope information.\n\t(operator_name): Append unoperator. Call frob_opname.\n\t* spew.c (frob_opname): Define.\n\nFrom-SVN: r36315", "tree": {"sha": "d694dbd8f3fee17d98c37d0b5bd6a07b08dafac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d694dbd8f3fee17d98c37d0b5bd6a07b08dafac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2d71db6232200171b271499f0eeace035ad82cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d71db6232200171b271499f0eeace035ad82cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2d71db6232200171b271499f0eeace035ad82cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2d71db6232200171b271499f0eeace035ad82cf/comments", "author": null, "committer": null, "parents": [{"sha": "e695931e414bab5105d78004a68bb5a0c00975cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e695931e414bab5105d78004a68bb5a0c00975cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e695931e414bab5105d78004a68bb5a0c00975cc"}], "stats": {"total": 207, "additions": 133, "deletions": 74}, "files": [{"sha": "e7a6acb2f1bcabb0d871f0739a921b98bcea7973", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f2d71db6232200171b271499f0eeace035ad82cf", "patch": "@@ -1,3 +1,14 @@\n+2000-09-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cp-tree.h (frob_opname): Declare.\n+\t* parse.y (saved_scopes): New static variable.\n+\t(cp_parse_init): Adjust.\n+\t(do_id): If lastiddecl is NULL, do do_identifier.\n+\t(operator): Save scope information.\n+\t(unoperator): new reduction. Restore scope information.\n+\t(operator_name): Append unoperator. Call frob_opname.\n+\t* spew.c (frob_opname): Define.\n+\n 2000-09-10  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* decl.c, rtti.c: Include defaults.h if not already included."}, {"sha": "97e3298075e09b6df2b0c5732288dbeb35b2fe8c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f2d71db6232200171b271499f0eeace035ad82cf", "patch": "@@ -4384,6 +4384,7 @@ extern void init_spew\t\t\t\tPARAMS ((void));\n extern int peekyylex\t\t\t\tPARAMS ((void));\n extern int yylex\t\t\t\tPARAMS ((void));\n extern tree arbitrate_lookup\t\t\tPARAMS ((tree, tree, tree));\n+extern tree frob_opname                         PARAMS ((tree));\n \n /* in tree.c */\n extern void init_tree\t\t\t        PARAMS ((void));"}, {"sha": "bd3c9c55f6a13cff03ddd56d783c67577d470be9", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 85, "deletions": 74, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=f2d71db6232200171b271499f0eeace035ad82cf", "patch": "@@ -78,6 +78,10 @@ static tree prefix_attributes;\n /* When defining an enumeration, this is the type of the enumeration.  */\n static tree current_enum_type;\n \n+/* When parsing a conversion operator name, this is the scope of the\n+   operator itself.  */\n+static tree saved_scopes;\n+\n static tree empty_parms PARAMS ((void));\n static tree parse_decl0 PARAMS ((tree, tree, tree, tree, int));\n static tree parse_decl PARAMS ((tree, tree, int));\n@@ -208,6 +212,7 @@ cp_parse_init ()\n   ggc_add_tree_root (&current_declspecs, 1);\n   ggc_add_tree_root (&prefix_attributes, 1);\n   ggc_add_tree_root (&current_enum_type, 1);\n+  ggc_add_tree_root (&saved_scopes, 1);\n }\n %}\n \n@@ -1437,7 +1442,7 @@ do_id:\n \t\t     means that we're in an expression like S::f<int>, so\n \t\t     don't do_identifier; we only do that for unqualified\n \t\t     identifiers.  */\n-\t\t  if (lastiddecl && TREE_CODE (lastiddecl) != TREE_LIST)\n+\t          if (!lastiddecl || TREE_CODE (lastiddecl) != TREE_LIST)\n \t\t    $$ = do_identifier ($<ttype>-1, 1, NULL_TREE);\n \t\t  else\n \t\t    $$ = $<ttype>-1;\n@@ -3746,82 +3751,88 @@ conversion_declarator:\n \t;\n \n operator:\n-\t  OPERATOR\n-\t\t{ got_scope = NULL_TREE; }\n-\t;\n+        OPERATOR\n+        { saved_scopes = tree_cons (got_scope, got_object, saved_scopes); \n+          got_scope = NULL_TREE; got_object = NULL_TREE; }\n+        ;\n+unoperator:\n+        { got_scope = TREE_PURPOSE (saved_scopes);\n+          got_object = TREE_VALUE (saved_scopes);\n+          saved_scopes = TREE_CHAIN (saved_scopes); }\n+        ;\n \n operator_name:\n-\t  operator '*'\n-\t\t{ $$ = ansi_opname (MULT_EXPR); }\n-\t| operator '/'\n-\t\t{ $$ = ansi_opname (TRUNC_DIV_EXPR); }\n-\t| operator '%'\n-\t\t{ $$ = ansi_opname (TRUNC_MOD_EXPR); }\n-\t| operator '+'\n-\t\t{ $$ = ansi_opname (PLUS_EXPR); }\n-\t| operator '-'\n-\t\t{ $$ = ansi_opname (MINUS_EXPR); }\n-\t| operator '&'\n-\t\t{ $$ = ansi_opname (BIT_AND_EXPR); }\n-\t| operator '|'\n-\t\t{ $$ = ansi_opname (BIT_IOR_EXPR); }\n-\t| operator '^'\n-\t\t{ $$ = ansi_opname (BIT_XOR_EXPR); }\n-\t| operator '~'\n-\t\t{ $$ = ansi_opname (BIT_NOT_EXPR); }\n-\t| operator ','\n-\t\t{ $$ = ansi_opname (COMPOUND_EXPR); }\n-\t| operator ARITHCOMPARE\n-\t\t{ $$ = ansi_opname ($2); }\n-\t| operator '<'\n-\t\t{ $$ = ansi_opname (LT_EXPR); }\n-\t| operator '>'\n-\t\t{ $$ = ansi_opname (GT_EXPR); }\n-\t| operator EQCOMPARE\n-\t\t{ $$ = ansi_opname ($2); }\n-\t| operator ASSIGN\n-\t\t{ $$ = ansi_assopname ($2); }\n-\t| operator '='\n-\t\t{ $$ = ansi_assopname (NOP_EXPR); }\n-\t| operator LSHIFT\n-\t\t{ $$ = ansi_opname ($2); }\n-\t| operator RSHIFT\n-\t\t{ $$ = ansi_opname ($2); }\n-\t| operator PLUSPLUS\n-\t\t{ $$ = ansi_opname (POSTINCREMENT_EXPR); }\n-\t| operator MINUSMINUS\n-\t\t{ $$ = ansi_opname (PREDECREMENT_EXPR); }\n-\t| operator ANDAND\n-\t\t{ $$ = ansi_opname (TRUTH_ANDIF_EXPR); }\n-\t| operator OROR\n-\t\t{ $$ = ansi_opname (TRUTH_ORIF_EXPR); }\n-\t| operator '!'\n-\t\t{ $$ = ansi_opname (TRUTH_NOT_EXPR); }\n-\t| operator '?' ':'\n-\t\t{ $$ = ansi_opname (COND_EXPR); }\n-\t| operator MIN_MAX\n-\t\t{ $$ = ansi_opname ($2); }\n-\t| operator POINTSAT  %prec EMPTY\n-\t\t{ $$ = ansi_opname (COMPONENT_REF); }\n-\t| operator POINTSAT_STAR  %prec EMPTY\n-\t\t{ $$ = ansi_opname (MEMBER_REF); }\n-\t| operator LEFT_RIGHT\n-\t\t{ $$ = ansi_opname (CALL_EXPR); }\n-\t| operator '[' ']'\n-\t\t{ $$ = ansi_opname (ARRAY_REF); }\n-\t| operator NEW  %prec EMPTY\n-\t\t{ $$ = ansi_opname (NEW_EXPR); }\n-\t| operator DELETE  %prec EMPTY\n-\t\t{ $$ = ansi_opname (DELETE_EXPR); }\n-\t| operator NEW '[' ']'\n-\t\t{ $$ = ansi_opname (VEC_NEW_EXPR); }\n-\t| operator DELETE '[' ']'\n-\t\t{ $$ = ansi_opname (VEC_DELETE_EXPR); }\n+\t  operator '*' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (MULT_EXPR)); }\n+\t| operator '/' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (TRUNC_DIV_EXPR)); }\n+\t| operator '%' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (TRUNC_MOD_EXPR)); }\n+\t| operator '+' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (PLUS_EXPR)); }\n+\t| operator '-' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (MINUS_EXPR)); }\n+\t| operator '&' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (BIT_AND_EXPR)); }\n+\t| operator '|' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (BIT_IOR_EXPR)); }\n+\t| operator '^' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (BIT_XOR_EXPR)); }\n+\t| operator '~' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (BIT_NOT_EXPR)); }\n+\t| operator ',' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (COMPOUND_EXPR)); }\n+\t| operator ARITHCOMPARE unoperator\n+\t\t{ $$ = frob_opname (ansi_opname ($2)); }\n+\t| operator '<' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (LT_EXPR)); }\n+\t| operator '>' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (GT_EXPR)); }\n+\t| operator EQCOMPARE unoperator\n+\t\t{ $$ = frob_opname (ansi_opname ($2)); }\n+\t| operator ASSIGN unoperator\n+\t\t{ $$ = frob_opname (ansi_assopname ($2)); }\n+\t| operator '=' unoperator\n+\t\t{ $$ = frob_opname (ansi_assopname (NOP_EXPR)); }\n+\t| operator LSHIFT unoperator\n+\t\t{ $$ = frob_opname (ansi_opname ($2)); }\n+\t| operator RSHIFT unoperator\n+\t\t{ $$ = frob_opname (ansi_opname ($2)); }\n+\t| operator PLUSPLUS unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (POSTINCREMENT_EXPR)); }\n+\t| operator MINUSMINUS unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (PREDECREMENT_EXPR)); }\n+\t| operator ANDAND unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (TRUTH_ANDIF_EXPR)); }\n+\t| operator OROR unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (TRUTH_ORIF_EXPR)); }\n+\t| operator '!' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (TRUTH_NOT_EXPR)); }\n+\t| operator '?' ':' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (COND_EXPR)); }\n+\t| operator MIN_MAX unoperator\n+\t\t{ $$ = frob_opname (ansi_opname ($2)); }\n+\t| operator POINTSAT  unoperator %prec EMPTY\n+\t\t{ $$ = frob_opname (ansi_opname (COMPONENT_REF)); }\n+\t| operator POINTSAT_STAR  unoperator %prec EMPTY\n+\t\t{ $$ = frob_opname (ansi_opname (MEMBER_REF)); }\n+\t| operator LEFT_RIGHT unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (CALL_EXPR)); }\n+\t| operator '[' ']' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (ARRAY_REF)); }\n+\t| operator NEW  unoperator %prec EMPTY\n+\t\t{ $$ = frob_opname (ansi_opname (NEW_EXPR)); }\n+\t| operator DELETE  unoperator %prec EMPTY\n+\t\t{ $$ = frob_opname (ansi_opname (DELETE_EXPR)); }\n+\t| operator NEW '[' ']' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (VEC_NEW_EXPR)); }\n+\t| operator DELETE '[' ']' unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (VEC_DELETE_EXPR)); }\n \t/* Names here should be looked up in class scope ALSO.  */\n-\t| operator type_specifier_seq conversion_declarator\n-\t\t{ $$ = grokoptypename ($2.t, $3); }\n-\t| operator error\n-\t\t{ $$ = ansi_opname (ERROR_MARK); }\n+\t| operator type_specifier_seq conversion_declarator unoperator\n+\t\t{ $$ = frob_opname (grokoptypename ($2.t, $3)); }\n+\t| operator error unoperator\n+\t\t{ $$ = frob_opname (ansi_opname (ERROR_MARK)); }\n \t;\n \n %%"}, {"sha": "d6bf7bb45864e970532819c246c6aaa1e701ce1f", "filename": "gcc/cp/spew.c", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fspew.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2d71db6232200171b271499f0eeace035ad82cf/gcc%2Fcp%2Fspew.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fspew.c?ref=f2d71db6232200171b271499f0eeace035ad82cf", "patch": "@@ -938,6 +938,42 @@ yyungetc (ch, rescan)\n     }\n }\n \n+/* ID is an operator name. Duplicate the hackery in yylex to determine what\n+   it really is.  */\n+\n+tree frob_opname (id)\n+     tree id;\n+{\n+  tree trrr;\n+  \n+  if (yychar == '<')\n+    looking_for_template = 1;\n+  trrr = lookup_name (id, -2);\n+  if (trrr)\n+    {\n+      switch (identifier_type (trrr))\n+        {\n+          case TYPENAME:\n+          case SELFNAME:\n+          case NSNAME:\n+          case PTYPENAME:\n+            if (got_scope || got_object)\n+              id = trrr;\n+          case PFUNCNAME:\n+          case IDENTIFIER:\n+            lastiddecl = trrr;\n+            break;\n+          default:\n+            my_friendly_abort (20000907);\n+        }\n+    }\n+  else\n+    lastiddecl = NULL_TREE;\n+  got_scope = NULL_TREE;\n+  got_object = NULL_TREE;\n+  looking_for_template = 0;\n+  return id;\n+}\n \n /* Set up the state required to correctly handle the definition of the\n    inline function whose preparsed state has been saved in PI.  */"}]}