{"sha": "2eab96661b6c08679ffd4a084f59f3935cfcddb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmVhYjk2NjYxYjZjMDg2NzlmZmQ0YTA4NGY1OWYzOTM1Y2ZjZGRiOQ==", "commit": {"author": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-09-08T15:39:59Z"}, "committer": {"name": "Ilya Verbin", "email": "iverbin@gcc.gnu.org", "date": "2015-09-08T15:39:59Z"}, "message": "backport: Makefile.am (liboffloadmic_host_la_DEPENDENCIES): Remove libcoi_host and libmyo-client.\n\nMerge liboffloadmic from upstream, version 20150803.\n\nliboffloadmic/\n\t* Makefile.am (liboffloadmic_host_la_DEPENDENCIES): Remove libcoi_host\n\tand libmyo-client.  liboffloadmic_host loads them dynamically.\n\t* Makefile.in: Regenerate.\n\t* doc/doxygen/header.tex: Merge from upstream, version 20150803\n\t<https://openmprtl.org/sites/default/files/liboffload_oss_20150803.tgz>.\n\t* runtime/cean_util.cpp: Likewise.\n\t* runtime/cean_util.h: Likewise.\n\t* runtime/coi/coi_client.cpp: Likewise.\n\t* runtime/coi/coi_client.h: Likewise.\n\t* runtime/coi/coi_server.cpp: Likewise.\n\t* runtime/coi/coi_server.h: Likewise.\n\t* runtime/compiler_if_host.cpp: Likewise.\n\t* runtime/compiler_if_host.h: Likewise.\n\t* runtime/compiler_if_target.cpp: Likewise.\n\t* runtime/compiler_if_target.h: Likewise.\n\t* runtime/dv_util.cpp: Likewise.\n\t* runtime/dv_util.h: Likewise.\n\t* runtime/liboffload_error.c: Likewise.\n\t* runtime/liboffload_error_codes.h: Likewise.\n\t* runtime/liboffload_msg.c: Likewise.\n\t* runtime/liboffload_msg.h: Likewise.\n\t* runtime/mic_lib.f90: Likewise.\n\t* runtime/offload.h: Likewise.\n\t* runtime/offload_common.cpp: Likewise.\n\t* runtime/offload_common.h: Likewise.\n\t* runtime/offload_engine.cpp: Likewise.\n\t* runtime/offload_engine.h: Likewise.\n\t* runtime/offload_env.cpp: Likewise.\n\t* runtime/offload_env.h: Likewise.\n\t* runtime/offload_host.cpp: Likewise.\n\t* runtime/offload_host.h: Likewise.\n\t* runtime/offload_iterator.h: Likewise.\n\t* runtime/offload_myo_host.cpp: Likewise.\n\t* runtime/offload_myo_host.h: Likewise.\n\t* runtime/offload_myo_target.cpp: Likewise.\n\t* runtime/offload_myo_target.h: Likewise.\n\t* runtime/offload_omp_host.cpp: Likewise.\n\t* runtime/offload_omp_target.cpp: Likewise.\n\t* runtime/offload_orsl.cpp: Likewise.\n\t* runtime/offload_orsl.h: Likewise.\n\t* runtime/offload_table.cpp: Likewise.\n\t* runtime/offload_table.h: Likewise.\n\t* runtime/offload_target.cpp: Likewise.\n\t* runtime/offload_target.h: Likewise.\n\t* runtime/offload_target_main.cpp: Likewise.\n\t* runtime/offload_timer.h: Likewise.\n\t* runtime/offload_timer_host.cpp: Likewise.\n\t* runtime/offload_timer_target.cpp: Likewise.\n\t* runtime/offload_trace.cpp: Likewise.\n\t* runtime/offload_trace.h: Likewise.\n\t* runtime/offload_util.cpp: Likewise.\n\t* runtime/offload_util.h: Likewise.\n\t* runtime/ofldbegin.cpp: Likewise.\n\t* runtime/ofldend.cpp: Likewise.\n\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n\t* runtime/use_mpss2.txt: Likewise.\n\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n\tversion 3.5\n\t<http://registrationcenter.intel.com/irc_nas/7445/mpss-src-3.5.tar>.\n\t* include/coi/common/COIEvent_common.h: Likewise.\n\t* include/coi/common/COIMacros_common.h: Likewise.\n\t* include/coi/common/COIPerf_common.h: Likewise.\n\t* include/coi/common/COIResult_common.h: Likewise.\n\t* include/coi/common/COISysInfo_common.h: Likewise.\n\t* include/coi/common/COITypes_common.h: Likewise.\n\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n\t* include/coi/sink/COIProcess_sink.h: Likewise.\n\t* include/coi/source/COIBuffer_source.h: Likewise.\n\t* include/coi/source/COIEngine_source.h: Likewise.\n\t* include/coi/source/COIEvent_source.h: Likewise.\n\t* include/coi/source/COIPipeline_source.h: Likewise.\n\t* include/coi/source/COIProcess_source.h: Likewise.\n\t* include/myo/myo.h: Likewise.\n\t* include/myo/myoimpl.h: Likewise.\n\t* include/myo/myotypes.h: Likewise.\n\t* plugin/Makefile.am (myo_inc_dir): Remove.\n\t(libgomp_plugin_intelmic_la_CPPFLAGS): Do not define MYO_SUPPORT.\n\t(AM_CPPFLAGS): Likewise for offload_target_main.\n\t* plugin/Makefile.in: Regenerate.\n\t* runtime/emulator/coi_common.h: Update copyright years.\n\t(OFFLOAD_EMUL_KNC_NUM_ENV): Replace with ...\n\t(OFFLOAD_EMUL_NUM_ENV): ... this.\n\t(enum cmd_t): Add CMD_CLOSE_LIBRARY.\n\t* runtime/emulator/coi_device.cpp: Update copyright years.\n\t(COIProcessWaitForShutdown): Add space between string constants.\n\tReturn handle to host in CMD_OPEN_LIBRARY.\n\tSupport CMD_CLOSE_LIBRARY.\n\t* runtime/emulator/coi_device.h: Update copyright years.\n\t* runtime/emulator/coi_host.cpp: Update copyright years.\n\t(knc_engines_num): Replace with ...\n\t(num_engines): ... this.\n\t(init): Replace OFFLOAD_EMUL_KNC_NUM_ENV with OFFLOAD_EMUL_NUM_ENV.\n\t(COIEngineGetCount): Replace COI_ISA_KNC with COI_ISA_MIC, and\n\tknc_engines_num with num_engines.\n\t(COIEngineGetHandle): Likewise.\n\t(COIProcessCreateFromMemory): Add space between string constants.\n\t(COIProcessCreateFromFile): New function.\n\t(COIProcessLoadLibraryFromMemory): Rename arguments according to\n\tCOIProcess_source.h.  Return handle, received from target.\n\t(COIProcessUnloadLibrary): New function.\n\t(COIPipelineClearCPUMask): New function.\n\t(COIPipelineSetCPUMask): New function.\n\t(COIEngineGetInfo): New function.\n\t* runtime/emulator/coi_host.h: Update copyright years.\n\t* runtime/emulator/coi_version_asm.h: Regenerate.\n\t* runtime/emulator/coi_version_linker_script.map: Regenerate.\n\t* runtime/emulator/myo_client.cpp: Update copyright years.\n\t* runtime/emulator/myo_service.cpp: Update copyright years.\n\t(myoArenaRelease): New function.\n\t(myoArenaAcquire): New function.\n\t(myoArenaAlignedFree): New function.\n\t(myoArenaAlignedMalloc): New function.\n\t* runtime/emulator/myo_service.h: Update copyright years.\n\t* runtime/emulator/myo_version_asm.h: Regenerate.\n\t* runtime/emulator/myo_version_linker_script.map: Regenerate.\n\nFrom-SVN: r227532", "tree": {"sha": "c8f48559f50e5a137fcce6649e6afa8f5093251f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c8f48559f50e5a137fcce6649e6afa8f5093251f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2eab96661b6c08679ffd4a084f59f3935cfcddb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eab96661b6c08679ffd4a084f59f3935cfcddb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2eab96661b6c08679ffd4a084f59f3935cfcddb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2eab96661b6c08679ffd4a084f59f3935cfcddb9/comments", "author": null, "committer": null, "parents": [{"sha": "761f8e2f8add70caf57b07c37b84059117031451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/761f8e2f8add70caf57b07c37b84059117031451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/761f8e2f8add70caf57b07c37b84059117031451"}], "stats": {"total": 8791, "additions": 7249, "deletions": 1542}, "files": [{"sha": "4a726c8636d8dcb30f42af79805f22a511b71596", "filename": "liboffloadmic/ChangeLog", "status": "modified", "additions": 122, "deletions": 2, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FChangeLog?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,3 +1,123 @@\n+2015-09-08  Ilya Verbin  <ilya.verbin@intel.com>\n+\n+\t* Makefile.am (liboffloadmic_host_la_DEPENDENCIES): Remove libcoi_host\n+\tand libmyo-client.  liboffloadmic_host loads them dynamically.\n+\t* Makefile.in: Regenerate.\n+\t* doc/doxygen/header.tex: Merge from upstream, version 20150803\n+\t<https://openmprtl.org/sites/default/files/liboffload_oss_20150803.tgz>.\n+\t* runtime/cean_util.cpp: Likewise.\n+\t* runtime/cean_util.h: Likewise.\n+\t* runtime/coi/coi_client.cpp: Likewise.\n+\t* runtime/coi/coi_client.h: Likewise.\n+\t* runtime/coi/coi_server.cpp: Likewise.\n+\t* runtime/coi/coi_server.h: Likewise.\n+\t* runtime/compiler_if_host.cpp: Likewise.\n+\t* runtime/compiler_if_host.h: Likewise.\n+\t* runtime/compiler_if_target.cpp: Likewise.\n+\t* runtime/compiler_if_target.h: Likewise.\n+\t* runtime/dv_util.cpp: Likewise.\n+\t* runtime/dv_util.h: Likewise.\n+\t* runtime/liboffload_error.c: Likewise.\n+\t* runtime/liboffload_error_codes.h: Likewise.\n+\t* runtime/liboffload_msg.c: Likewise.\n+\t* runtime/liboffload_msg.h: Likewise.\n+\t* runtime/mic_lib.f90: Likewise.\n+\t* runtime/offload.h: Likewise.\n+\t* runtime/offload_common.cpp: Likewise.\n+\t* runtime/offload_common.h: Likewise.\n+\t* runtime/offload_engine.cpp: Likewise.\n+\t* runtime/offload_engine.h: Likewise.\n+\t* runtime/offload_env.cpp: Likewise.\n+\t* runtime/offload_env.h: Likewise.\n+\t* runtime/offload_host.cpp: Likewise.\n+\t* runtime/offload_host.h: Likewise.\n+\t* runtime/offload_iterator.h: Likewise.\n+\t* runtime/offload_myo_host.cpp: Likewise.\n+\t* runtime/offload_myo_host.h: Likewise.\n+\t* runtime/offload_myo_target.cpp: Likewise.\n+\t* runtime/offload_myo_target.h: Likewise.\n+\t* runtime/offload_omp_host.cpp: Likewise.\n+\t* runtime/offload_omp_target.cpp: Likewise.\n+\t* runtime/offload_orsl.cpp: Likewise.\n+\t* runtime/offload_orsl.h: Likewise.\n+\t* runtime/offload_table.cpp: Likewise.\n+\t* runtime/offload_table.h: Likewise.\n+\t* runtime/offload_target.cpp: Likewise.\n+\t* runtime/offload_target.h: Likewise.\n+\t* runtime/offload_target_main.cpp: Likewise.\n+\t* runtime/offload_timer.h: Likewise.\n+\t* runtime/offload_timer_host.cpp: Likewise.\n+\t* runtime/offload_timer_target.cpp: Likewise.\n+\t* runtime/offload_trace.cpp: Likewise.\n+\t* runtime/offload_trace.h: Likewise.\n+\t* runtime/offload_util.cpp: Likewise.\n+\t* runtime/offload_util.h: Likewise.\n+\t* runtime/ofldbegin.cpp: Likewise.\n+\t* runtime/ofldend.cpp: Likewise.\n+\t* runtime/orsl-lite/include/orsl-lite.h: Likewise.\n+\t* runtime/orsl-lite/lib/orsl-lite.c: Likewise.\n+\t* runtime/use_mpss2.txt: Likewise.\n+\t* include/coi/common/COIEngine_common.h: Merge from upstream, MPSS\n+\tversion 3.5\n+\t<http://registrationcenter.intel.com/irc_nas/7445/mpss-src-3.5.tar>.\n+\t* include/coi/common/COIEvent_common.h: Likewise.\n+\t* include/coi/common/COIMacros_common.h: Likewise.\n+\t* include/coi/common/COIPerf_common.h: Likewise.\n+\t* include/coi/common/COIResult_common.h: Likewise.\n+\t* include/coi/common/COISysInfo_common.h: Likewise.\n+\t* include/coi/common/COITypes_common.h: Likewise.\n+\t* include/coi/sink/COIBuffer_sink.h: Likewise.\n+\t* include/coi/sink/COIPipeline_sink.h: Likewise.\n+\t* include/coi/sink/COIProcess_sink.h: Likewise.\n+\t* include/coi/source/COIBuffer_source.h: Likewise.\n+\t* include/coi/source/COIEngine_source.h: Likewise.\n+\t* include/coi/source/COIEvent_source.h: Likewise.\n+\t* include/coi/source/COIPipeline_source.h: Likewise.\n+\t* include/coi/source/COIProcess_source.h: Likewise.\n+\t* include/myo/myo.h: Likewise.\n+\t* include/myo/myoimpl.h: Likewise.\n+\t* include/myo/myotypes.h: Likewise.\n+\t* plugin/Makefile.am (myo_inc_dir): Remove.\n+\t(libgomp_plugin_intelmic_la_CPPFLAGS): Do not define MYO_SUPPORT.\n+\t(AM_CPPFLAGS): Likewise for offload_target_main.\n+\t* plugin/Makefile.in: Regenerate.\n+\t* runtime/emulator/coi_common.h: Update copyright years.\n+\t(OFFLOAD_EMUL_KNC_NUM_ENV): Replace with ...\n+\t(OFFLOAD_EMUL_NUM_ENV): ... this.\n+\t(enum cmd_t): Add CMD_CLOSE_LIBRARY.\n+\t* runtime/emulator/coi_device.cpp: Update copyright years.\n+\t(COIProcessWaitForShutdown): Add space between string constants.\n+\tReturn handle to host in CMD_OPEN_LIBRARY.\n+\tSupport CMD_CLOSE_LIBRARY.\n+\t* runtime/emulator/coi_device.h: Update copyright years.\n+\t* runtime/emulator/coi_host.cpp: Update copyright years.\n+\t(knc_engines_num): Replace with ...\n+\t(num_engines): ... this.\n+\t(init): Replace OFFLOAD_EMUL_KNC_NUM_ENV with OFFLOAD_EMUL_NUM_ENV.\n+\t(COIEngineGetCount): Replace COI_ISA_KNC with COI_ISA_MIC, and\n+\tknc_engines_num with num_engines.\n+\t(COIEngineGetHandle): Likewise.\n+\t(COIProcessCreateFromMemory): Add space between string constants.\n+\t(COIProcessCreateFromFile): New function.\n+\t(COIProcessLoadLibraryFromMemory): Rename arguments according to\n+\tCOIProcess_source.h.  Return handle, received from target.\n+\t(COIProcessUnloadLibrary): New function.\n+\t(COIPipelineClearCPUMask): New function.\n+\t(COIPipelineSetCPUMask): New function.\n+\t(COIEngineGetInfo): New function.\n+\t* runtime/emulator/coi_host.h: Update copyright years.\n+\t* runtime/emulator/coi_version_asm.h: Regenerate.\n+\t* runtime/emulator/coi_version_linker_script.map: Regenerate.\n+\t* runtime/emulator/myo_client.cpp: Update copyright years.\n+\t* runtime/emulator/myo_service.cpp: Update copyright years.\n+\t(myoArenaRelease): New function.\n+\t(myoArenaAcquire): New function.\n+\t(myoArenaAlignedFree): New function.\n+\t(myoArenaAlignedMalloc): New function.\n+\t* runtime/emulator/myo_service.h: Update copyright years.\n+\t* runtime/emulator/myo_version_asm.h: Regenerate.\n+\t* runtime/emulator/myo_version_linker_script.map: Regenerate.\n+\n 2015-08-24  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_version): New.\n@@ -17,11 +137,11 @@\n \t* configure: Reflects renaming of configure.in to configure.ac\n \n 2015-07-17  Nathan Sidwell  <nathan@acm.org>\n-\tIlya Verbin <iverbin@gmail.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n \n \t* plugin/libgomp-plugin-intelmic.cpp (ImgDevAddrMap): Constify.\n \t(offload_image, GOMP_OFFLOAD_load_image,\n-\tOMP_OFFLOAD_unload_image): Constify target data.\n+\tGOMP_OFFLOAD_unload_image): Constify target data.\n \n 2015-07-08  Thomas Schwinge  <thomas@codesourcery.com>\n "}, {"sha": "b1454513a09869fde4968ff21f467d7aef4e3cf5", "filename": "liboffloadmic/Makefile.am", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.am?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -84,8 +84,6 @@ liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n \n liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_host_la_LIBADD = libcoi_host.la libmyo-client.la\n-liboffloadmic_host_la_DEPENDENCIES = $(liboffloadmic_host_la_LIBADD)\n \n liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\t  runtime/coi/coi_server.cpp \\"}, {"sha": "74fb3d27180a03ecb2914eab52a3d5613b6a88a8", "filename": "liboffloadmic/Makefile.in", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2FMakefile.in?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -165,6 +165,7 @@ libmyo_service_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(CXXFLAGS) $(libmyo_service_la_LDFLAGS) $(LDFLAGS) -o $@\n @LIBOFFLOADMIC_HOST_FALSE@am_libmyo_service_la_rpath = -rpath \\\n @LIBOFFLOADMIC_HOST_FALSE@\t$(toolexeclibdir)\n+liboffloadmic_host_la_LIBADD =\n am__objects_1 = liboffloadmic_host_la-dv_util.lo \\\n \tliboffloadmic_host_la-liboffload_error.lo \\\n \tliboffloadmic_host_la-liboffload_msg.lo \\\n@@ -445,8 +446,6 @@ liboffloadmic_host_la_SOURCES = $(liboffloadmic_sources) \\\n \n liboffloadmic_host_la_CPPFLAGS = $(liboffloadmic_cppflags) -DHOST_LIBRARY=1\n liboffloadmic_host_la_LDFLAGS = @lt_cv_dlopen_libs@ -version-info 5:0:0\n-liboffloadmic_host_la_LIBADD = libcoi_host.la libmyo-client.la\n-liboffloadmic_host_la_DEPENDENCIES = $(liboffloadmic_host_la_LIBADD)\n liboffloadmic_target_la_SOURCES = $(liboffloadmic_sources) \\\n \t\t\t\t  runtime/coi/coi_server.cpp \\\n \t\t\t\t  runtime/compiler_if_target.cpp \\"}, {"sha": "eaa563ca29be6e7be5e21dfd6fd2c4586f9d7aaa", "filename": "liboffloadmic/doc/doxygen/header.tex", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fdoc%2Fdoxygen%2Fheader.tex?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -82,7 +82,7 @@\n \n Intel, Xeon, and Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries.\n \n-This document is Copyright \\textcopyright 2014, Intel Corporation. All rights reserved. \n+This document is Copyright \\textcopyright 2014-2015, Intel Corporation. All rights reserved.\n \n \\pagenumbering{roman}\n \\tableofcontents"}, {"sha": "b8f31669b89f283eb0d3828069405af8af8a7ef1", "filename": "liboffloadmic/include/coi/common/COIEngine_common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEngine_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -64,7 +64,7 @@ extern \"C\" {\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-///  List of ISA types of supported engines.\n+/// List of ISA types of supported engines.\n ///\n typedef enum\n {\n@@ -89,7 +89,7 @@ typedef enum\n ///         [out] The zero-based index of this engine in the collection of\n ///         engines of the ISA returned in out_pType.\n ///\n-/// @return COI_INVALID_POINTER if the any of the parameters are NULL.\n+/// @return COI_INVALID_POINTER if any of the parameters are NULL.\n ///\n /// @return COI_SUCCESS\n ///"}, {"sha": "21c93138a0cb236b0a03679d727730f053f65a22", "filename": "liboffloadmic/include/coi/common/COIEvent_common.h", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIEvent_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2010-2015 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COIEVENT_COMMON_H\n+#define _COIEVENT_COMMON_H\n+\n+/** @ingroup COIEvent\n+ *  @addtogroup COIEventcommon\n+@{\n+* @file common/COIEvent_common.h\n+*/\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+\n+#include \"../common/COITypes_common.h\"\n+#include \"../common/COIResult_common.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// Signal one shot user event. User events created on source can be\n+/// signaled from both sink and source. This fires the event and wakes up\n+/// threads waiting on COIEventWait.\n+///\n+/// Note: For events that are not registered or already signaled this call\n+///       will behave as a NOP. Users need to make sure that they pass valid\n+///       events on the sink side.\n+///\n+/// @param  in_Event\n+///         Event Handle to be signaled.\n+///\n+/// @return COI_INVAILD_HANDLE if in_Event was not a User event.\n+///\n+/// @return COI_ERROR if the signal fails to be sent from the sink.\n+///\n+/// @return COI_SUCCESS if the event was successfully signaled or ignored.\n+///\n+COIACCESSAPI\n+COIRESULT COIEventSignalUserEvent(COIEVENT in_Event);\n+///\n+///\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+\n+#endif /* _COIEVENT_COMMON_H */\n+\n+/*! @} */"}, {"sha": "07c9b8cb356b7ed6e8cd98a11d1ab2154115de78", "filename": "liboffloadmic/include/coi/common/COIMacros_common.h", "status": "modified", "additions": 152, "deletions": 1, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIMacros_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -41,12 +41,17 @@\n #ifndef _COIMACROS_COMMON_H\n #define _COIMACROS_COMMON_H\n \n+#include <string.h>\n+#include \"../source/COIPipeline_source.h\"\n+#include \"../common/COITypes_common.h\"\n+\n /// @file common/COIMacros_common.h\n /// Commonly used macros\n \n // Note that UNUSUED_ATTR means that it is \"possibly\" unused, not \"definitely\".\n // This should compile out in release mode if indeed it is unused.\n     #define UNUSED_ATTR __attribute__((unused))\n+    #include <sched.h>\n #ifndef UNREFERENCED_CONST_PARAM\n #define UNREFERENCED_CONST_PARAM(P)     { void* x UNUSED_ATTR = \\\n                                                  (void*)(uint64_t)P; \\\n@@ -66,4 +71,150 @@\n \n #endif\n \n+/* The following are static inline definitions of functions used for manipulating\n+   COI_CPU_MASK info (The COI_CPU_MASK type is declared as an array of 16 uint64_t's\n+   in COITypes_common.h \"typedef uint64_t COI_CPU_MASK[16]\").\n+\n+   These static inlined functions are intended on being roughly the same as the Linux\n+   CPU_* macros defined in sched.h - with the important difference being a different\n+   fundamental type difference: cpu_set_t versus COI_CPU_MASK.\n+\n+   The motivation for writing this code was to ease portability on the host side of COI\n+   applications to both Windows and Linux.\n+*/\n+\n+/* Roughly equivalent to CPU_ISSET(). */\n+static inline uint64_t COI_CPU_MASK_ISSET(int bitNumber, const COI_CPU_MASK cpu_mask)\n+{\n+  if ((size_t)bitNumber < sizeof(COI_CPU_MASK)*8)\n+        return ((cpu_mask)[bitNumber/64] & (((uint64_t)1) << (bitNumber%64)));\n+    return 0;\n+}\n+\n+/* Roughly equivalent to CPU_SET(). */\n+static inline void COI_CPU_MASK_SET(int bitNumber, COI_CPU_MASK cpu_mask)\n+{\n+  if ((size_t)bitNumber < sizeof(COI_CPU_MASK)*8)\n+        ((cpu_mask)[bitNumber/64] |= (((uint64_t)1) << (bitNumber%64)));\n+}\n+\n+/* Roughly equivalent to CPU_ZERO(). */\n+static inline void COI_CPU_MASK_ZERO(COI_CPU_MASK cpu_mask)\n+{\n+    memset(cpu_mask,0,sizeof(COI_CPU_MASK));\n+}\n+\n+/* Roughly equivalent to CPU_AND(). */\n+static inline void COI_CPU_MASK_AND(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n+{\n+    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+\n+    for(unsigned int i=0;i<loopIterations;++i)\n+        dst[i] = src1[i] & src2[i];\n+}\n+\n+/* Roughly equivalent to CPU_XOR(). */\n+static inline void COI_CPU_MASK_XOR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n+{\n+    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+\n+    for(unsigned int i=0;i<loopIterations;++i)\n+        dst[i] = src1[i] ^ src2[i];\n+}\n+\n+/* Roughly equivalent to CPU_OR(). */\n+static inline void COI_CPU_MASK_OR(COI_CPU_MASK dst, const COI_CPU_MASK src1, const COI_CPU_MASK src2)\n+{\n+    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(dst[0]);\n+\n+    for(unsigned int i=0;i<loopIterations;++i)\n+        dst[i] = src1[i] | src2[i];\n+}\n+\n+/* Utility function for COI_CPU_MASK_COUNT() below. */\n+static inline int __COI_CountBits(uint64_t n)\n+{\n+    int cnt=0;\n+\n+    for (;n;cnt++)\n+        n &= (n-1);\n+    return cnt;\n+}\n+\n+/* Roughly equivalent to CPU_COUNT(). */\n+static inline int COI_CPU_MASK_COUNT(const COI_CPU_MASK cpu_mask)\n+{\n+    int cnt=0;\n+    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask[0]);\n+\n+    for(unsigned int i=0;i < loopIterations;++i)\n+    {\n+        cnt += __COI_CountBits(cpu_mask[i]);\n+    }\n+    return cnt;\n+}\n+\n+/* Roughly equivalent to CPU_EQUAL(). */\n+static inline int COI_CPU_MASK_EQUAL(const COI_CPU_MASK cpu_mask1,const COI_CPU_MASK cpu_mask2)\n+{\n+    const unsigned int loopIterations = sizeof(COI_CPU_MASK) / sizeof(cpu_mask1[0]);\n+\n+    for(unsigned int i=0;i < loopIterations;++i)\n+    {\n+        if (cpu_mask1[i] != cpu_mask2[i])\n+            return 0;\n+    }\n+    return 1;\n+}\n+\n+\n+/* Utility function to translate from cpu_set * to COI_CPU_MASK. */\n+static inline void COI_CPU_MASK_XLATE(COI_CPU_MASK dest,const cpu_set_t *src)\n+{\n+    COI_CPU_MASK_ZERO(dest);\n+#if 0\n+    /* Slightly slower version than the following #else/#endif block. Left here only to\n+         document the intent of the code. */\n+    for(unsigned int i=0;i < sizeof(cpu_set_t)*8;++i)\n+        if (CPU_ISSET(i,src))\n+            COI_CPU_MASK_SET(i,dest);\n+#else\n+    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)/sizeof(dest[0]);++i)\n+    {\n+        for(unsigned int j=0;j < 64;++j)\n+        {\n+            if (CPU_ISSET(i*64+j,src))\n+                dest[i] |= ((uint64_t)1) << j;\n+        }\n+    }\n+#endif\n+}\n+\n+/* Utility function to translate from COI_CPU_MASK to cpu_set *. */\n+static inline void COI_CPU_MASK_XLATE_EX(cpu_set_t *dest,const COI_CPU_MASK src)\n+{\n+    CPU_ZERO(dest);\n+#if 0\n+    /* Slightly slower version than the following #else/#endif block. Left here only to\n+         document the intent of the code. */\n+    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)*8;++i)\n+        if (COI_CPU_MASK_ISSET(i,src))\n+            CPU_SET(i,dest);\n+#else\n+    for(unsigned int i=0;i < sizeof(COI_CPU_MASK)/sizeof(src[0]);++i)\n+    {\n+        const uint64_t cpu_mask = src[i];\n+\n+        for(unsigned int j=0;j < 64;++j)\n+        {\n+            const uint64_t bit = ((uint64_t)1) << j;\n+\n+            if (bit & cpu_mask)\n+                CPU_SET(i*64+j,dest);\n+        }\n+    }\n+#endif\n+}\n+\n+\n #endif /* _COIMACROS_COMMON_H */"}, {"sha": "f542786452f04f5b510be8711425ee7e146a307b", "filename": "liboffloadmic/include/coi/common/COIPerf_common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIPerf_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "947e93cbdc29024b31466dbef7be5f8e616ef807", "filename": "liboffloadmic/include/coi/common/COIResult_common.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOIResult_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -110,12 +110,13 @@ typedef enum COIRESULT\n                                       ///< Offload Infrastructure on the host\n                                       ///< is not compatible with the version\n                                       ///< on the device.\n-    COI_BAD_PORT,                     ///< The port that the host is set to \n+    COI_BAD_PORT,                     ///< The port that the host is set to\n                                       ///< connect to is invalid.\n     COI_AUTHENTICATION_FAILURE,       ///< The daemon was unable to authenticate\n                                       ///< the user that requested an engine.\n                                       ///< Only reported if daemon is set up for\n-                                      ///< authorization.\n+                                      ///< authorization. Is also reported in\n+                                      ///< Windows if host can not find user.\n     COI_NUM_RESULTS                   ///< Reserved, do not use.\n }\n COIRESULT;"}, {"sha": "0fae2312f2d6cac46336a5f9edc3bbaa79e9e69e", "filename": "liboffloadmic/include/coi/common/COISysInfo_common.h", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOISysInfo_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2010-2015 Intel Corporation.\n+ *\n+ * This library is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU Lesser General Public License as published\n+ * by the Free Software Foundation, version 2.1.\n+ *\n+ * This library is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * Disclaimer: The codes contained in these modules may be specific\n+ * to the Intel Software Development Platform codenamed Knights Ferry,\n+ * and the Intel product codenamed Knights Corner, and are not backward\n+ * compatible with other Intel products. Additionally, Intel will NOT\n+ * support the codes or instruction set in future products.\n+ *\n+ * Intel offers no warranty of any kind regarding the code. This code is\n+ * licensed on an \"AS IS\" basis and Intel is not obligated to provide\n+ * any support, assistance, installation, training, or other services\n+ * of any kind. Intel is also not obligated to provide any updates,\n+ * enhancements or extensions. Intel specifically disclaims any warranty\n+ * of merchantability, non-infringement, fitness for any particular\n+ * purpose, and any other warranty.\n+ *\n+ * Further, Intel disclaims all liability of any kind, including but\n+ * not limited to liability for infringement of any proprietary rights,\n+ * relating to the use of the code, even if Intel is notified of the\n+ * possibility of such liability. Except as expressly stated in an Intel\n+ * license agreement provided with this code and agreed upon with Intel,\n+ * no license, express or implied, by estoppel or otherwise, to any\n+ * intellectual property rights is granted herein.\n+ */\n+\n+#ifndef _COISYSINFO_COMMON_H\n+#define _COISYSINFO_COMMON_H\n+\n+/** @ingroup COISysInfo\n+ *  @addtogroup COISysInfoCommon\n+@{\n+* @file common/COISysInfo_common.h\n+* This interface allows developers to query the platform for system level\n+* information. */\n+\n+#ifndef DOXYGEN_SHOULD_SKIP_THIS\n+#include \"../common/COITypes_common.h\"\n+#include <assert.h>\n+#include <string.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+#endif // DOXYGEN_SHOULD_SKIP_THIS\n+\n+#define INITIAL_APIC_ID_BITS 0xFF000000   // EBX[31:24] unique APIC ID\n+\n+///////////////////////////////////////////////////////////////////////////////\n+/// \\fn uint32_t COISysGetAPICID(void)\n+/// @return The Advanced Programmable Interrupt Controller (APIC) ID of\n+/// the hardware thread on which the caller is running.\n+///\n+/// @warning APIC IDs are unique to each hardware thread within a processor,\n+/// but may not be sequential.\n+COIACCESSAPI\n+uint32_t COISysGetAPICID(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The number of cores exposed by the processor on which the caller is\n+/// running. Returns 0 if there is an error loading the processor info.\n+COIACCESSAPI\n+uint32_t COISysGetCoreCount(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The number of hardware threads exposed by the processor on which\n+/// the caller is running. Returns 0 if there is an error loading processor\n+/// info.\n+COIACCESSAPI\n+uint32_t COISysGetHardwareThreadCount(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The index of the hardware thread on which the caller is running.\n+///\n+/// The indexes of neighboring hardware threads will differ by a value of one\n+/// and are within the range zero through COISysGetHardwareThreadCount()-1.\n+/// Returns ((uint32_t)-1) if there was an error loading processor info.\n+COIACCESSAPI\n+uint32_t COISysGetHardwareThreadIndex(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The index of the core on which the caller is running.\n+///\n+/// The indexes of neighboring cores will differ by a value of one and are\n+/// within the range zero through COISysGetCoreCount()-1. Returns ((uint32_t)-1)\n+/// if there was an error loading processor info.\n+COIACCESSAPI\n+uint32_t COISysGetCoreIndex(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The number of level 2 caches within the processor on which the\n+/// caller is running. Returns ((uint32_t)-1) if there was an error loading\n+/// processor info.\n+COIACCESSAPI\n+uint32_t COISysGetL2CacheCount(void);\n+\n+///////////////////////////////////////////////////////////////////////////////\n+///\n+/// @return The index of the level 2 cache on which the caller is running.\n+/// Returns ((uint32_t)-1) if there was an error loading processor info.\n+///\n+/// The indexes of neighboring cores will differ by a value of one and are\n+/// within the range zero through COISysGetL2CacheCount()-1.\n+COIACCESSAPI\n+uint32_t COISysGetL2CacheIndex(void);\n+\n+#ifdef __cplusplus\n+} /* extern \"C\" */\n+#endif\n+/*! @} */\n+\n+#endif /* _COISYSINFO_COMMON_H */"}, {"sha": "001ddc979c08698fe28eb89655eae08552a019c8", "filename": "liboffloadmic/include/coi/common/COITypes_common.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fcommon%2FCOITypes_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -73,8 +73,8 @@ typedef struct coimapinst  * COIMAPINSTANCE;\n \n typedef uint64_t COI_CPU_MASK[16];\n \n-/** \n- *  On Windows, coi_wchar_t is a uint32_t. On Windows, wchar_t is 16 bits wide, and on Linux it is 32 bits wide, so uint32_t is used for portability.\n+/**\n+ * On Windows, coi_wchar_t is a uint32_t. On Windows, wchar_t is 16 bits wide, and on Linux it is 32 bits wide, so uint32_t is used for portability.\n  */\n typedef wchar_t  coi_wchar_t;\n "}, {"sha": "2e51e92f920aa3c96a0f1f4e79caf7d06dee2ea9", "filename": "liboffloadmic/include/coi/sink/COIBuffer_sink.h", "status": "modified", "additions": 28, "deletions": 25, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIBuffer_sink.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -45,7 +45,7 @@\n  *  @addtogroup COIBufferSink\n @{\n \n-* @file sink\\COIBuffer_sink.h \n+* @file sink\\COIBuffer_sink.h\n */\n #ifndef DOXYGEN_SHOULD_SKIP_THIS\n #include \"../common/COITypes_common.h\"\n@@ -54,29 +54,29 @@\n \n #ifdef __cplusplus\n extern \"C\" {\n-#endif \n+#endif\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n-/// Adds a reference to the memory of a buffer.  The memory of the buffer\n-/// will remain on the device until both a corresponding COIBufferReleaseRef() \n+/// Adds a reference to the memory of a buffer. The memory of the buffer\n+/// will remain on the device until both a corresponding COIBufferReleaseRef()\n /// call is made and the run function that delivered the buffer returns.\n ///\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  streaming buffers should not be AddRef'd. Doing so may result in\n-/// unpredictable results or may cause the sink process to crash.\n+/// Running this API in a thread spawned within the run function is not\n+/// supported and will cause unpredictable results and may cause data corruption.\n ///\n-/// @warning 1.It is possible for enqueued run functions to be unable to \n-///            execute due to all card memory being occupied by addref'ed\n+/// @warning 1.It is possible for enqueued run functions to be unable to\n+///            execute due to all card memory being occupied by AddRef'd\n ///            buffers. As such, it is important that whenever a buffer is\n-///            addref'd that there be no dependencies on future run functions\n+///            AddRef'd that there be no dependencies on future run functions\n ///            for progress to be made towards releasing the buffer.\n-///          2.It is important that AddRef is called within the scope of \n-///            run function that carries the buffer to be addref'ed.\n+///          2.It is important that AddRef is called within the scope of\n+///            run function that carries the buffer to be AddRef'd.\n ///\n /// @param  in_pBuffer\n-///         [in] Pointer to the start of a buffer being addref'ed, that was\n+///         [in] Pointer to the start of a buffer being AddRef'd, that was\n ///         passed in at the start of the run function.\n-/// \n+///\n /// @return COI_SUCCESS if the buffer ref count was successfully incremented.\n ///\n /// @return COI_INVALID_POINTER if the buffer pointer is NULL.\n@@ -90,30 +90,33 @@ COIBufferAddRef(\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n-/// Removes a reference to the memory of a buffer.  The memory of the buffer\n+/// Removes a reference to the memory of a buffer. The memory of the buffer\n /// will be eligible for being freed on the device when the following\n /// conditions are met: the run function that delivered the buffer\n-/// returns, and the number of calls to COIBufferReleaseRef() matches the \n+/// returns, and the number of calls to COIBufferReleaseRef() matches the\n /// number of calls to COIBufferAddRef().\n+//\n+/// Running this API in a thread spawned within the run function is not\n+/// supported and will cause unpredictable results and may cause data corruption.\n ///\n-/// @warning When a buffer is addref'ed it is assumed that it is in use and all\n+/// @warning When a buffer is AddRef'd it is assumed that it is in use and all\n ///          other operations on that buffer waits for ReleaseRef() to happen.\n-///          So you cannot pass the addref'ed buffer's handle to RunFunction \n-///          that calls ReleaseRef(). This is a circular dependency and will \n-///          cause a deadlock. Buffer's pointer (buffer's sink side \n+///          So you cannot pass the AddRef'd buffer's handle to RunFunction\n+///          that calls ReleaseRef(). This is a circular dependency and will\n+///          cause a deadlock. Buffer's pointer (buffer's sink side\n ///          address/pointer which is different than source side BUFFER handle)\n-///          needs to be stored somewhere to retrieve it later to use in \n+///          needs to be stored somewhere to retrieve it later to use in\n ///          ReleaseRef.\n ///\n /// @param  in_pBuffer\n-///         [in] Pointer to the start of a buffer previously addref'ed, that\n+///         [in] Pointer to the start of a buffer previously AddRef'd, that\n ///         was passed in at the start of the run function.\n-/// \n+///\n /// @return COI_SUCCESS if the buffer refcount was successfully decremented.\n ///\n /// @return COI_INVALID_POINTER if the buffer pointer was invalid.\n ///\n-/// @return COI_INVALID_HANDLE if the buffer did not have COIBufferAddRef() \n+/// @return COI_INVALID_HANDLE if the buffer did not have COIBufferAddRef()\n ///         previously called on it.\n ///\n COIRESULT\n@@ -123,7 +126,7 @@ COIBufferReleaseRef(\n \n #ifdef __cplusplus\n } /* extern \"C\" */\n-#endif \n+#endif\n \n #endif /* _COIBUFFER_SINK_H */\n "}, {"sha": "c70872ad12c952615c047fff92bd8f2359113558", "filename": "liboffloadmic/include/coi/sink/COIPipeline_sink.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIPipeline_sink.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "6e2ef19df1870fab7943c53ff0aa72b4d1c3d200", "filename": "liboffloadmic/include/coi/sink/COIProcess_sink.h", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsink%2FCOIProcess_sink.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -63,10 +63,11 @@ extern \"C\" {\n /// main() function from exiting until it is directed to by the source. When\n /// the shutdown message is received this function will stop any future run\n /// functions from executing but will wait for any current run functions to\n-/// complete. All Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  resources will be cleaned up and no additional Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  APIs\n-/// should be called after this function returns.  This function does not\n-/// invoke exit() so the application can perform any of its own cleanup once\n-/// this call returns.\n+/// complete. All Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// resources will be cleaned up and no additional Intel\u00ae Coprocessor Offload\n+/// Infrastructure (Intel\u00ae COI) APIs should be called after this function\n+/// returns. This function does not invoke exit() so the application\n+/// can perform any of its own cleanup once this call returns.\n ///\n /// @return COI_SUCCESS once the process receives the shutdown message.\n ///\n@@ -86,8 +87,9 @@ COIProcessWaitForShutdown();\n /// from this call.\n ///\n /// @return COI_SUCCESS once the proxy output has been flushed to and written\n-///         written by the host. Note that Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  on the source writes to stdout\n-///         and stderr, but does not flush this output.\n+///         written by the host. Note that Intel\u00ae Coprocessor Offload\n+///         Infrastructure (Intel\u00ae COI) on the source writes to stdout and\n+///         stderr, but does not flush this output.\n /// @return COI_SUCCESS if the process was created without enabling\n ///         proxy IO this function.\n ///"}, {"sha": "bfd066ca916a3f6311df6c0f0facaae41843411a", "filename": "liboffloadmic/include/coi/source/COIBuffer_source.h", "status": "modified", "additions": 666, "deletions": 164, "changes": 830, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIBuffer_source.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -68,21 +68,16 @@ typedef enum COI_BUFFER_TYPE\n     /// Sink physical memory. Mapping the buffer may stall the pipelines.\n     COI_BUFFER_NORMAL = 1,\n \n-    /// A streaming buffer creates new versions each time it is passed to\n-    /// Runfunction. These new versions are consumed by run functions.\n-\n-    ///  To_SINK buffers are used to send data from SOURCE to SINK\n-    ///  These buffers are SOURCE write only buffers. If read, won't\n-    ///  get Data written by SINK\n-    COI_BUFFER_STREAMING_TO_SINK,\n-\n-    ///  To_SOURCE buffers are used to get data from SINK to SOURCE\n-    ///  These buffers are SOURCE Read only buffers. If written, data\n-    ///  won't get reflected on SINK side.\n-    COI_BUFFER_STREAMING_TO_SOURCE,\n+    // Reserved values, not used by COI any more\n+    COI_BUFFER_RESERVED_1,\n+    COI_BUFFER_RESERVED_2,\n \n     /// A pinned buffer exists in a shared memory region and is always\n     /// available for read or write operations.\n+    /// Note: Pinned Buffers larger than 4KB are not supported in\n+    /// Windows 7 kernels.\n+    /// The value of COI_BUFFER_PINNED is set to specific value\n+    /// to maintain compatibility with older versions of COI\n     COI_BUFFER_PINNED,\n \n     /// OpenCL buffers are similar to Normal buffers except they don't\n@@ -126,12 +121,15 @@ typedef enum COI_BUFFER_TYPE\n /// check to see if this memory is read only. Ordinarily this is checked\n /// and an error is thrown upon buffer creation. With this flag, the error\n /// might occur later, and cause undetermined behavior. Be sure to always\n-/// use writeable memory for COIBuffers.\n+/// use writable memory for COIBuffers.\n #define COI_OPTIMIZE_NO_DMA                0x00000040\n \n /// Hint to the runtime to try to use huge page sizes for backing store on the\n-/// sink.  Is currently not compatible with PINNED buffers or the SAME_ADDRESS\n-/// flags or the SINK_MEMORY flag.\n+/// sink. Is currently not compatible with PINNED buffers or the SAME_ADDRESS\n+/// flags or the SINK_MEMORY flag. It is important to note that this is a hint\n+/// and internally the runtime may not actually promote to huge pages.\n+/// Specifically if the buffer is too small (less than 4KiB for example) then\n+/// the runtime will not promote the buffer to use huge pages.\n #define COI_OPTIMIZE_HUGE_PAGE_SIZE        0x00000080\n \n /// Used to tell Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n@@ -167,12 +165,12 @@ COI_VALID_BUFFER_TYPES_AND_FLAGS[COI_BUFFER_OPENCL+1] = {\n              | ADDR  | SINK | SRC  | SRC   | SINK | SINK  | NO  | PAGE | SINK |\n              | SINKS | SRC  | READ | WRITE | READ | WRITE | DMA | SIZE | MEM  |\n              +-------+------+------+-------+------+-------+-----+------+-----*/\n-MTM(INVALID  ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n-MTM(NORMAL   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T  ),\n-MTM(TO_SINK  ,   F   ,   F  ,   F  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n-MTM(TO_SOURCE,   F   ,   F  ,   T  ,   F   ,   F  ,   T   ,  F  ,   F  ,  F  ),\n-MTM(PINNED   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n-MTM(OPENCL   ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F  ),\n+MTM(INVALID   ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n+MTM(NORMAL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  T  ),\n+MTM(RESERVED1 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n+MTM(RESERVED2 ,   F   ,   F  ,   F  ,   F   ,   F  ,   F   ,  F  ,   F  ,  F  ),\n+MTM(PINNED    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  F  ,   F  ,  F  ),\n+MTM(OPENCL    ,   T   ,   T  ,   T  ,   T   ,   T  ,   T   ,  T  ,   T  ,  F  ),\n };\n ///\\endcode\n #undef MTM\n@@ -223,8 +221,8 @@ COI_VALID_BUFFER_TYPES_AND_MAP\n                         +-------+-------+-------+*/\n MMM(INVALID             ,   F   ,   F   ,   F   ),\n MMM(NORMAL              ,   T   ,   T   ,   T   ),\n-MMM(STREAMING_TO_SINK   ,   F   ,   F   ,   T   ),\n-MMM(STREAMING_TO_SOURCE ,   F   ,   T   ,   F   ),\n+MMM(RESERVED1           ,   F   ,   F   ,   F   ),\n+MMM(RESERVED2           ,   F   ,   F   ,   F   ),\n MMM(PINNED              ,   T   ,   T   ,   T   ),\n MMM(OPENCL              ,   T   ,   T   ,   T   ),\n };\n@@ -250,7 +248,19 @@ typedef enum COI_COPY_TYPE\n     /// The runtime should use a CPU copy to copy the data.\n     /// CPU copy is a synchronous copy. So the resulting operations are always\n     /// blocking (even though a out_pCompletion event is specified).\n-    COI_COPY_USE_CPU\n+    COI_COPY_USE_CPU,\n+\n+    /// Same as above, but forces moving entire buffer to target process in Ex\n+    /// extended APIs, even if the full buffer is not written.\n+    COI_COPY_UNSPECIFIED_MOVE_ENTIRE,\n+\n+    /// Same as above, but forces moving entire buffer to target process in Ex\n+    /// extended APIs, even if the full buffer is not written.\n+    COI_COPY_USE_DMA_MOVE_ENTIRE,\n+\n+    /// Same as above, but forces moving entire buffer to target process in Ex\n+    /// extended APIs, even if the full buffer is not written.\n+    COI_COPY_USE_CPU_MOVE_ENTIRE\n \n } COI_COPY_TYPE;\n \n@@ -260,9 +270,7 @@ typedef enum COI_COPY_TYPE\n /// access in a COIPROCESS. This is used with COIBufferSetState.\n ///\n /// Buffer state holds only for NORMAL Buffers and OPENCL buffers. Pinned\n-/// buffers are always valid everywhere they get created. Streaming buffers\n-/// do not follow the state transition rules, as a new version of the\n-/// buffer is created every time it is Mapped or you issue a RunFunction.\n+/// buffers are always valid everywhere they get created.\n ///\n /// Rules on State Transition of the buffer:\n /// -. When a Buffer is created by default it is valid only on the source,\n@@ -296,53 +304,53 @@ typedef enum COI_COPY_TYPE\n ///\n ///    - COIBufferWrite makes the buffer exclusively valid where the write\n ///      happens. Write gives preference to Source over Sink. In other words\n-///      if a buffer is valid on the Source and multiple Sinks, Write will \n-///      happen on the Source and will Invalidate all other Sinks. If the \n-///      buffer is valid on multiple Sinks ( and not on the Source) then \n-///      Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n-///      selects process handle with the lowest numerical value to do the \n+///      if a buffer is valid on the Source and multiple Sinks, Write will\n+///      happen on the Source and will Invalidate all other Sinks. If the\n+///      buffer is valid on multiple Sinks ( and not on the Source) then\n+///      Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+///      selects process handle with the lowest numerical value to do the\n ///      exclusive write Again, OPENCL buffers are invalidated only if the\n ///      buffer is not in use on that SINK/SOURCE.\n ///\n ///      The preference rule mentioned above holds true even for SetState API,\n ///      when data needs to be moved from a valid location. The selection of\n ///      valid location happens as stated above.\n ///\n-/// - It is possible to alter only parts of the buffer and change it state \n-///   In other words it is possible for different parts of the buffer to have \n-///   different states on different devices. A byte is the minimum size at \n+/// - It is possible to alter only parts of the buffer and change it state\n+///   In other words it is possible for different parts of the buffer to have\n+///   different states on different devices. A byte is the minimum size at\n ///   which state can be maintained internally. Granularity level is completely\n ///   determined by how the buffer gets fragmented.\n ///\n-/// Note: Buffer is considered 'in use' if is \n+/// Note: Buffer is considered 'in use' if is\n ///         - Being used in RunFunction : In use on a Sink\n ///         - Mapped: In use on a Source\n ///         - AddRef'd: In use on Sink\n ///\n \n //////////////////////////////////////////////////////////////////////////////\n-/// The buffer states used with COIBufferSetState call to indicate the new \n+/// The buffer states used with COIBufferSetState call to indicate the new\n /// state of the buffer on a given process\n ///\n typedef enum {\n     COI_BUFFER_VALID = 0,      // Buffer is valid and up-to-date on the process\n     COI_BUFFER_INVALID ,       // Buffer is not valid, need valid data\n     COI_BUFFER_VALID_MAY_DROP, // Same as valid but will drop the content when\n-                               // evicted to avoid overwriting the shadow \n+                               // evicted to avoid overwriting the shadow\n                                // memory\n     COI_BUFFER_RESERVED        // Reserved for internal use\n } COI_BUFFER_STATE;\n ///\n /// Note: A VALID_MAY_DROP declares a buffer's copy as secondary on a given\n /// process. This means that there needs to be at least one primary copy of the\n-/// the buffer somewhere in order to mark the buffer as VALID_MAY_DROP on a \n+/// the buffer somewhere in order to mark the buffer as VALID_MAY_DROP on a\n /// process. In other words to make a buffer VALID_MAY_DROP on a given process\n /// it needs to be in COI_BUFFER_VALID state somewhere else. The operation gets\n /// ignored (or is a nop) if there is no primary copy of the buffer. The nature\n-/// of this state to \"drop the content\" when evicted is a side effect of \n-/// marking the buffer as secondary copy. So when a buffer marked \n-/// VALID_MAY_DROP is evicted Intel\u00ae Coprocessor Offload Infrastructure\n-/// (Intel\u00ae COI)  doesn't back it up as it is assumed that \n+/// of this state to \"drop the content\" when evicted is a side effect of\n+/// marking the buffer as secondary copy. So when a buffer marked\n+/// VALID_MAY_DROP is evicted Intel(R) Coprocessor Offload Infrastructure\n+/// (Intel(R) COI) doesn't back it up as it is assumed that\n /// there is a primary copy somewhere.\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -355,19 +363,37 @@ typedef enum {\n \n // A process handle for COIBufferSetState call to indicate all the sink\n // processes where the given buffer is valid\n-#define COI_SINK_OWNERS  ((COIPROCESS)-2)\n+#define COI_SINK_OWNERS ((COIPROCESS)-2)\n+\n+// Matrix descriptors used with MultiD Read/Write\n+typedef struct dim_desc {\n+    int64_t size;       // Size of data type\n+    int64_t lindex;     // Lower index, used in Fortran\n+    int64_t lower;      // Lower section bound\n+    int64_t upper;      // Upper section bound\n+    int64_t stride;     // Stride, or number of bytes between the start\n+                        // of one element and start of next one divided\n+                        // by size.\n+} dim_desc;\n+\n+typedef struct arr_desc {\n+    int64_t base;       // Base address\n+    int64_t rank;       // Rank of array, i.e. number of dimensions\n+    dim_desc dim[3];    // This array has as many elements as \ufffdrank\ufffd\n+                        // currently limited to 3.\n+} arr_desc;\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Creates a buffer that can be used in RunFunctions that are queued in\n /// pipelines. The address space for the buffer is reserved when it is\n /// created although the memory may not be committed until the buffer is\n-/// used for the first time. Please note that the Intel\u00ae Coprocessor Offload\n-/// Infrastructure (Intel\u00ae COI)  runtime may also\n-/// allocate space for the source process to use as shadow memory for\n-/// certain types of buffers. If Intel\u00ae Coprocessor Offload Infrastructure\n-/// (Intel\u00ae COI)  does allocate this memory it will not\n-/// be released or reallocated until the COIBuffer is destroyed.\n+/// used for the first time. Please note that the Intel(R) Coprocessor Offload\n+/// Infrastructure (Intel(R) COI) runtime may also allocate space for the\n+/// source process to use as shadow memory for certain types of buffers.\n+/// If Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+/// does allocate this memory it will not be released or reallocated\n+/// until the COIBuffer is destroyed.\n ///\n /// @param  in_Size\n ///         [in] The number of bytes to allocate for the buffer. If in_Size\n@@ -408,13 +434,13 @@ typedef enum {\n ///         which flags and types are compatible.\n ///\n /// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n-///         the in_Flags parameter are not recognized flags, or if\n-///         in_NumProcesses is zero.\n+///         the in_Flags parameter are not recognized flags, or if in_NumProcesses is zero.\n ///\n /// @return COI_INVALID_POINTER if the in_pProcesses or out_pBuffer parameter\n ///         is NULL.\n ///\n-/// @return COI_NOT_SUPPORTED if one of the in_Flags is COI_SINK_MEMORY.\n+/// @return COI_NOT_SUPPORTED if in_Type has invalid value or if\n+///        one of the in_Flags is COI_SINK_MEMORY.\n ///\n /// @return COI_NOT_SUPPORTED if the flags include either\n ///         COI_SAME_ADDRESS_SINKS or COI_SAME_ADDRESS_SINKS_AND_SOURCE and\n@@ -425,7 +451,10 @@ typedef enum {\n ///\n /// @return COI_OUT_OF_MEMORY if allocating the buffer fails.\n ///\n-/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory.\n+/// @return COI_RESOURCE_EXHAUSTED if the sink is out of buffer memory. This\n+///         error can also be thrown from Windows 7 operating systems if\n+///         COI_BUFFER_PINNED and a size larger than 4KB is requested.\n+///         This is due to a limitation of the Windows 7 memory management unit.\n ///\n COIACCESSAPI\n COIRESULT\n@@ -442,22 +471,22 @@ COIBufferCreate(\n ///\n /// Creates a buffer from some existing memory that can be used in\n /// RunFunctions that are queued in pipelines. If the flag COI_SINK_MEMORY\n-/// is specified then Intel\u00ae Coprocessor Offload I\n-/// nfrastructure (Intel\u00ae COI)  will use that memory for the buffer on the sink.\n-/// If that flag isn't set then the memory provided is used as backing store \n+/// is specified then Intel(R) Coprocessor Offload\n+/// Infrastructure (Intel(R) COI) will use that memory for the buffer on the sink.\n+/// If that flag isn't set then the memory provided is used as backing store\n /// for the buffer on the source. In either case the memory must not be freed\n /// before the buffer is destroyed.\n-/// While the user still owns the memory passed in they must use the \n+/// While the user still owns the memory passed in they must use the\n /// appropriate access flags when accessing the buffer in COIPipelinRunFunction\n /// or COIBufferMap calls so that the runtime knows when the\n /// memory has been modified. If the user just writes directly to the memory\n-/// location then those changes may not be visible when the corresponding \n+/// location then those changes may not be visible when the corresponding\n /// buffer is accessed.\n /// Whatever values are already present in the memory location when this call\n /// is made are preserved. The memory values are also preserved when\n /// COIBufferDestroy is called.\n ///\n-/// @warning: Use of this function is highly discouraged if the calling program\n+/// @warning: Use of this function is highly discouraged if the calling\n /// program forks at all (including calls to system(3), popen(3), or similar\n /// functions) during the life of this buffer. See the discussion around the\n /// in_Memory parameter below regarding this.\n@@ -467,8 +496,7 @@ COIBufferCreate(\n ///         is not page aligned, it will be rounded up.\n ///\n /// @param  in_Type\n-///         [in] The type of the buffer to create. Note that streaming buffers\n-///         can not be created from user memory. Only COI_BUFFER_NORMAL and\n+///         [in] The type of the buffer to create. Only COI_BUFFER_NORMAL and\n ///         COI_BUFFER_PINNED buffer types are supported.\n ///\n /// @param  in_Flags\n@@ -496,7 +524,7 @@ COIBufferCreate(\n ///         system(3), popen(3), among others).\n ///\n ///         For forked processes, Linux uses copy-on-write semantics for\n-///         performances reasons. Conseqeuently, if the parent forks and then\n+///         performance reasons. Consequently, if the parent forks and then\n ///         writes to this memory, the physical page mapping changes causing\n ///         the DMA to fail (and thus data corruption).\n ///\n@@ -522,8 +550,8 @@ COIBufferCreate(\n ///\n /// @return COI_SUCCESS if the buffer was created\n ///\n-/// @return COI_NOT_SUPPORTED if the in_Type value is not COI_BUFFER_NORMAL or\n-///         COI_BUFFER_PINNED.\n+/// @return COI_NOT_SUPPORTED if the in_Type value is not COI_BUFFER_NORMAL,\n+///         COI_BUFFER_PINNED, or COI_BUFFER_OPENCL.\n ///\n /// @return COI_NOT_SUPPORTED if in_Memory is read-only memory\n ///\n@@ -547,8 +575,7 @@ COIBufferCreate(\n ///         COI_OPTIMIZE_HUGE_PAGE_SIZE are both set.\n ///\n /// @return COI_OUT_OF_RANGE if in_Size is zero, if the bits set in\n-///         the in_Flags parameter are not recognized flags, or if\n-///         in_NumProcesses is zero.\n+///         the in_Flags parameter are not recognized flags,  or if in_NumProcesses is zero.\n ///\n /// @return COI_INVALID_POINTER if in_Memory, in_pProcesses or\n ///         out_pBuffer parameter is NULL.\n@@ -560,7 +587,7 @@ COIACCESSAPI\n COIRESULT\n COIBufferCreateFromMemory(\n             uint64_t            in_Size,\n-           COI_BUFFER_TYPE     in_Type,\n+            COI_BUFFER_TYPE     in_Type,\n             uint32_t            in_Flags,\n             void*               in_Memory,\n             uint32_t            in_NumProcesses,\n@@ -570,10 +597,10 @@ COIBufferCreateFromMemory(\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n-/// Destroys a buffer.  Will block on completion of any operations on the\n-/// buffer, such as COIPipelineRunFunction or COIBufferCopy.  Will block until\n+/// Destroys a buffer. Will block on completion of any operations on the\n+/// buffer, such as COIPipelineRunFunction or COIBufferCopy. Will block until\n /// all COIBufferAddRef calls have had a matching COIBufferReleaseRef call\n-/// made.  Will not block on an outstanding COIBufferUnmap but will instead\n+/// made. will not block on an outstanding COIBufferUnmap but will instead\n /// return COI_RETRY.\n ///\n /// @param  in_Buffer\n@@ -599,32 +626,30 @@ COIBufferDestroy(\n ///\n /// This call initiates a request to access a region of a buffer. Multiple\n /// overlapping (or non overlapping) regions can be mapped simultaneously for\n-/// any given buffer.  If a completion event is specified this call will\n+/// any given buffer. If a completion event is specified this call will\n /// queue a request for the data which will be satisfied when the buffer is\n-/// available.  Once all conditions are met the completion event will be\n-/// signaled and the user can access the data at out_ppData.  The user can call\n+/// available. Once all conditions are met the completion event will be\n+/// signaled and the user can access the data at out_ppData. The user can call\n /// COIEventWait with out_pCompletion to find out when the map operation has\n /// completed. If the user accesses the data before the map operation is\n-/// complete the results are undefined.  If out_pCompletion is NULL then this\n+/// complete the results are undefined. If out_pCompletion is NULL then this\n /// call blocks until the map operation completes and when this call returns\n-/// out_ppData can be safely accessed.  This call returns a map instance handle\n+/// out_ppData can be safely accessed. This call returns a map instance handle\n /// in an out parameter which must be passed into COIBufferUnmap when the user\n /// no longer needs access to that region of the buffer.\n ///\n /// The address returned from COIBufferMap may point to memory that\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// manages on behalf of the user. The user must not free or reallocate this\n-/// memory, Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// memory, Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// will perform any necessary cleanup when the buffer is\n /// destroyed.\n ///\n /// Note that different types of buffers behave differently when mapped.\n /// For instance, mapping a COI_BUFFER_NORMAL for write must stall if the\n-/// buffer is currently being written to by a run function. Mapping a\n-/// COI_BUFFER_STREAMING_TO_SINK will create a new physical copy of the buffer\n-/// and make it available immediately.  Mapping a COI_BUFFER_PINNED buffer will\n-/// not affect other functions that use that buffer since a COI_BUFFER_PINNED\n-/// buffer can be mapped at any time.\n+/// buffer is currently being written to by a run function. Mapping\n+/// a COI_BUFFER_PINNED buffer will not affect other functions that use\n+/// that buffer since a COI_BUFFER_PINNED buffer can be mapped at any time.\n /// The asynchronous operation of COIBufferMap will likely be most useful when\n /// paired with a COI_BUFFER_NORMAL.\n ///\n@@ -633,15 +658,15 @@ COIBufferDestroy(\n ///\n /// @param  in_Offset\n ///         [in] Offset into the buffer that a pointer should be returned\n-///         for.  The value 0 can be passed in to signify that the mapped\n+///         for. The value 0 can be passed in to signify that the mapped\n ///         region should start at the beginning of the buffer.\n ///\n /// @param  in_Length\n ///         [in] Length of the buffer area to map. This parameter, in\n ///         combination with in_Offset, allows the caller to specify\n-///         that only a subset of an entire buffer need be mapped.  A\n-///         value of 0 can be passed in only if in_Offset is 0, to signify \n-///         that the mapped region is the entire buffer.  \n+///         that only a subset of an entire buffer need be mapped. A\n+///         value of 0 can be passed in only if in_Offset is 0, to signify\n+///         that the mapped region is the entire buffer.\n ///\n /// @param  in_Type\n ///         [in] The access type that is needed by the application. This will\n@@ -700,11 +725,6 @@ COIBufferDestroy(\n /// @return COI_ARGUMENT_MISMATCH if the in_Type of map is not a valid type\n ///         for in_Buffer's type of buffer.\n ///\n-/// @return COI_RESOURCE_EXHAUSTED if could not create a version for TO_SINK\n-///         streaming buffer. It can fail if enough memory is not available to\n-///         register. This call will succeed eventually when the registered\n-///         memory becomes available.\n-///\n /// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n ///\n /// @return COI_INVALID_POINTER if out_pMapInstance or out_ppData is NULL.\n@@ -725,9 +745,9 @@ COIBufferMap(\n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Disables Source access to the region of the buffer that was provided\n-/// through the corresponding call to COIBufferMap.  The number of calls to\n+/// through the corresponding call to COIBufferMap. The number of calls to\n /// COIBufferUnmap() should always match the number of calls made to\n-/// COIBufferMap().  The data pointer returned from the COIBufferMap() call\n+/// COIBufferMap(). The data pointer returned from the COIBufferMap() call\n /// will be invalid after this call.\n ///\n /// @param  in_MapInstance\n@@ -750,7 +770,7 @@ COIBufferMap(\n ///\n /// @param  out_pCompletion\n ///         [out] An optional pointer to a COIEVENT object that will be\n-///         signaled when the unmap is complete.  The user may pass in NULL if\n+///         signaled when the unmap is complete. The user may pass in NULL if\n ///         the user wants COIBufferUnmap to perform a blocking unmap\n ///         operation.\n ///\n@@ -774,11 +794,12 @@ COIBufferUnmap(\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n-/// Gets the Sink's virtual address of the buffer.  This is the same\n-/// address that is passed to the run function on the Sink. The virtual\n+/// Gets the Sink's virtual address of the buffer for the first process\n+/// that is using the buffer. This is the same address\n+/// that is passed to the run function on the Sink. The virtual\n /// address assigned to the buffer for use on the sink is fixed;\n /// the buffer will always be present at that virtual address on the sink\n-/// and will not get a different virtual address across different \n+/// and will not get a different virtual address across different\n /// RunFunctions.\n /// This address is only valid on the Sink and should not be dereferenced on\n /// the Source (except for the special case of buffers created with the\n@@ -796,40 +817,78 @@ COIBufferUnmap(\n ///\n /// @return COI_INVALID_POINTER if the out_pAddress parameter was invalid.\n ///\n-/// @return COI_NOT_SUPPORTED if the buffer passed in is of type\n-///         COI_BUFFER_STREAMING_TO_SOURCE or COI_BUFFER_STREAMING_TO_SINK.\n-///\n COIACCESSAPI\n COIRESULT\n COIBufferGetSinkAddress(\n             COIBUFFER           in_Buffer,\n             uint64_t*           out_pAddress);\n \n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Gets the Sink's virtual address of the buffer. This is the same\n+/// address that is passed to the run function on the Sink. The virtual\n+/// address assigned to the buffer for use on the sink is fixed;\n+/// the buffer will always be present at that virtual address on the sink\n+/// and will not get a different virtual address across different\n+/// RunFunctions.\n+/// This address is only valid on the Sink and should not be dereferenced on\n+/// the Source (except for the special case of buffers created with the\n+/// COI_SAME_ADDRESS flag).\n+///\n+/// @param  in_Process\n+///         [in] The process for which the address should be returned.\n+///         Special handle value 0 can be passed to the function;\n+///         in this case, address for the first valid process will be returned\n+///\n+/// @param  in_Buffer\n+///         [in] Buffer handle\n+///\n+/// @param  out_pAddress\n+///         [out] pointer to a uint64_t* that will be filled with the address.\n+///\n+/// @return COI_SUCCESS upon successful return of the buffer's address.\n+///\n+/// @return COI_INVALID_HANDLE if the passed in buffer or process\n+///         handle was invalid.\n+///\n+/// @return COI_INVALID_POINTER if the out_pAddress parameter was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if the in_Process is not valid for in_Buffer at the\n+///         moment of calling the function.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferGetSinkAddressEx(\n+            COIPROCESS          in_Process,\n+            COIBUFFER           in_Buffer,\n+            uint64_t*           out_pAddress);\n+\n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Copy data from a normal virtual address into an existing COIBUFFER.\n-/// Note that it is not possible to use this API with any type of\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n /// Please note that COIBufferWrite does not follow implicit buffer\n /// dependencies. If a buffer is in use in a run function or has been added\n /// to a process using COIBufferAddRef the call to COIBufferWrite will not\n /// wait, it will still copy data immediately.\n /// This is to facilitate a usage model where a buffer is being used outside\n /// of a run function, for example in a spawned thread, but data still needs\n /// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n ///\n /// @param  in_DestBuffer\n ///         [in] Buffer to write into.\n ///\n-#ifdef COI_PROTOTYPE_TARGET_PROCESS\n /// @param  in_DestProcess\n-///         [in] A pointer to the processes which are used as hints\n-///         to to COI. Buffers are updated upon these processes first.\n+///         [in] A pointer to the process to which the data will be written.\n+///         Buffer is updated only in this process and invalidated in other\n+///         processes. Only a single process can be specified.\n ///         Can be left NULL and default behavior will be chosen, which\n-///         chooses the lowest SCIF node with an active regions first. Others\n-///         buffer regions are invalidated in both cases. Will only update a single\n-///         process at this time.\n-#endif\n+///         chooses the first valid process in which regions are found. Other\n+///         buffer regions are invalidated if not updated.\n ///\n /// @param  in_Offset\n ///         [in] Location in the buffer to start writing to.\n@@ -869,7 +928,7 @@ COIBufferGetSinkAddress(\n ///         synchronous and will block until the transfer is complete.\n ///\n ///\n-/// @return COI_SUCCESS if the buffer was copied successfully.\n+/// @return COI_SUCCESS if the buffer was written successfully.\n ///\n /// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n ///\n@@ -881,9 +940,6 @@ COIBufferGetSinkAddress(\n /// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n ///         in_NumDependencies is not 0.\n ///\n-/// @return COI_NOT_SUPPORTED if the source buffer is of type\n-///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n-///\n /// @return COI_INVALID_POINTER if the in_pSourceData pointer is NULL.\n ///\n /// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n@@ -894,10 +950,9 @@ COIBufferGetSinkAddress(\n /// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n ///         buffer or COI_BUFFER_OPENCL buffer.\n ///\n-#ifdef COI_PROTOTYPE_TARGET_PROCESS\n COIACCESSAPI\n COIRESULT\n-COIBufferWrite(\n+COIBufferWriteEx(\n             COIBUFFER           in_DestBuffer,\n     const   COIPROCESS          in_DestProcess,\n             uint64_t            in_Offset,\n@@ -907,8 +962,299 @@ COIBufferWrite(\n             uint32_t            in_NumDependencies,\n     const   COIEVENT*           in_pDependencies,\n             COIEVENT*           out_pCompletion);\n-__asm__(\".symver COIBufferWrite,COIBufferWrite@COI_2.0\");\n-#else\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data specified by multi-dimensional array data structure into another\n+/// multi-dimensional array in an existing COIBUFFER.\n+/// Arrays with more than 3 dimensions are not supported.\n+/// Different numbers of elements between src and destination is not supported.\n+/// Please note that COIBufferWriteMultiD does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferWriteMultiD will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n+///\n+///\n+/// @param  in_DestBuffer\n+///         [in] Buffer to write into.\n+///\n+/// @param  in_DestProcess\n+///         [in] A pointer to the process to which the data will be written.\n+///         Buffer is updated only in this process and invalidated in other\n+///         processes. Only a single process can be specified.\n+///         Can be left NULL and default behavior will be chosen, which\n+///         chooses the first valid process in which regions are found. Other\n+///         buffer regions are invalidated if not updated.\n+///\n+/// @param  in_Offset\n+///         [in] Start location of the destination array within the buffer.\n+///\n+/// @param  in_DestArray\n+///         [in] A pointer to a data structure describing the structure of\n+///         the data array in the buffer. Total size must not be larger than\n+///         the size of in_DestBuffer. The base field of this structure will\n+///         be ignored.\n+///\n+/// @param  in_SrcArray\n+///         [in] A pointer to a data structure describing the structure of\n+///         the data array in local memory that should be copied. in_SrcArray\n+///         and in_DestArry must have the same number of elements. The base\n+///         field of this structure should be the virtual pointer to the local\n+///         memory in which this array is located.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the write call to\n+///         wait for any additional events to be signaled before starting the\n+///         write operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this write operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer write\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the write.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the write has\n+///         completed. This event can be used as a dependency to order\n+///         the write with regard to future operations.\n+///         If no completion event is passed in then the write is\n+///         synchronous and will block until the transfer is complete.\n+///\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer or process handle was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_NOT_SUPPORTED or dimension of destination or source arrays\n+///         are greater than 3 or less than 1\n+///\n+/// @return COI_INVALID_POINTER if the pointer in_SrcArray->base is NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset + size of in_DestArray exceeds the\n+///         size of the buffer.\n+///\n+/// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n+///\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n+///         buffer or COI_BUFFER_OPENCL buffer.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferWriteMultiD(\n+            COIBUFFER          in_DestBuffer,\n+    const   COIPROCESS         in_DestProcess,\n+            uint64_t           in_Offset,\n+            struct arr_desc*   in_DestArray,\n+            struct arr_desc*   in_SrcArray,\n+            COI_COPY_TYPE      in_Type,\n+            uint32_t           in_NumDependencies,\n+    const   COIEVENT*          in_pDependencies,\n+            COIEVENT*          out_pCompletion);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data specified by multi-dimensional array data structure from an\n+/// existing COIBUFFER to another multi-dimensional array located in memory.\n+/// Arrays with more than 3 dimensions are not supported.\n+/// Different numbers of elements between source and destination are not supported.\n+/// Please note that COIBufferReadMultiD does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferReadMultiD will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n+///\n+///\n+/// @param  in_SourceBuffer\n+///         [in] Buffer to read from.\n+///\n+/// @param  in_Offset\n+///         [in] Start location of the source array within the buffer.\n+///\n+/// @param  in_DestArray\n+///         [in] A pointer to a data structure describing the structure of\n+///         the data array in the buffer. Total size must not be larger than\n+///         the size of in_DestBuffer. The base field of this structure will\n+///         be ignored.\n+///\n+/// @param  in_SrcArray\n+///         [in] A pointer to a data structure describing the structure of\n+///         the data array in local memory that should be copied. in_SrcArray\n+///         and in_DestArry must have the same number of elements. The base\n+///         field of this structure should be the virtual pointer to the local\n+///         memory in which this array is located.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the write call to\n+///         wait for any additional events to be signaled before starting the\n+///         write operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this write operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer write\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the write.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the write has\n+///         completed. This event can be used as a dependency to order\n+///         the write with regard to future operations.\n+///         If no completion event is passed in then the write is\n+///         synchronous and will block until the transfer is complete.\n+///\n+///\n+/// @return COI_SUCCESS if the buffer was written successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer or process handle was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_NOT_SUPPORTED or dimension of destination or source arrays\n+///         are greater than 3 or less than 1\n+///\n+/// @return COI_INVALID_POINTER if the pointer in_DestArray->base is NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset + size of in_SourceArray exceeds the\n+///         size of the buffer.\n+///\n+/// @return COI_OUT_OF_MEMORY if any allocation of memory fails\n+///\n+/// @return COI_RETRY if in_SourceBuffer is mapped and is not a COI_BUFFER_PINNED\n+///         buffer or COI_BUFFER_OPENCL buffer.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferReadMultiD(\n+            COIBUFFER          in_SourceBuffer,\n+            uint64_t           in_Offset,\n+            struct arr_desc*   in_DestArray,\n+            struct arr_desc*   in_SrcArray,\n+            COI_COPY_TYPE      in_Type,\n+            uint32_t           in_NumDependencies,\n+    const   COIEVENT*          in_pDependencies,\n+            COIEVENT*          out_pCompletion);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data from a normal virtual address into an existing COIBUFFER.\n+/// Please note that COIBufferWrite does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferWrite will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n+///\n+/// @param  in_DestBuffer\n+///         [in] Buffer to write into.\n+///\n+/// @param  in_Offset\n+///         [in] Location in the buffer to start writing to.\n+///\n+/// @param  in_pSourceData\n+///         [in] A pointer to local memory that should be copied into the\n+///         provided buffer.\n+///\n+/// @param  in_Length\n+///         [in] The number of bytes to write from in_pSourceData into\n+///         in_DestBuffer. Must not be larger than the size of in_DestBuffer\n+///         and must not over run in_DestBuffer if an in_Offset is provided.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the write call to\n+///         wait for any additional events to be signaled before starting the\n+///         write operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this write operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer write\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the write.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the write has\n+///         completed. This event can be used as a dependency to order\n+///         the write with regard to future operations.\n+///         If no completion event is passed in then the write is\n+///         synchronous and will block until the transfer is complete.\n+///\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if the buffer handle was invalid.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset is beyond the end of the buffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_INVALID_POINTER if the in_pSourceData pointer is NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n+///         the buffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_Length is 0.\n+///\n+/// @return COI_RETRY if in_DestBuffer is mapped and is not a COI_BUFFER_PINNED\n+///         buffer or COI_BUFFER_OPENCL buffer.\n+///\n COIACCESSAPI\n COIRESULT\n COIBufferWrite(\n@@ -920,21 +1266,22 @@ COIBufferWrite(\n             uint32_t            in_NumDependencies,\n     const   COIEVENT*           in_pDependencies,\n             COIEVENT*           out_pCompletion);\n-__asm__(\".symver COIBufferWrite,COIBufferWrite@COI_1.0\");\n-#endif\n \n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Copy data from a buffer into local memory.\n-/// Note that it is not possible to use this API with any type of\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n /// Please note that COIBufferRead does not follow implicit buffer\n /// dependencies. If a buffer is in use in a run function or has been added\n /// to a process using COIBufferAddRef the call to COIBufferRead will not\n /// wait, it will still copy data immediately.\n /// This is to facilitate a usage model where a buffer is being used outside\n /// of a run function, for example in a spawned thread, but data still needs\n /// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n ///\n ///\n /// @param  in_SourceBuffer\n@@ -989,9 +1336,6 @@ __asm__(\".symver COIBufferWrite,COIBufferWrite@COI_1.0\");\n /// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n ///         in_NumDependencies is not 0.\n ///\n-/// @return COI_NOT_SUPPORTED if the source buffer is of type\n-///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n-///\n /// @return COI_OUT_OF_RANGE if in_Offset + in_Length exceeds the size of\n ///         the buffer.\n ///\n@@ -1019,27 +1363,29 @@ COIBufferRead(\n /// Copy data between two buffers. It also allows copying within the same\n /// buffer. For copy within the same buffer, if source and destination regions\n /// overlap then this API returns error.\n-/// Note that it is not possible to use this API with any type of\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Streaming Buffers.\n /// Please note that COIBufferCopy does not follow implicit buffer\n /// dependencies. If a buffer is in use in a run function or has been added\n /// to a process using COIBufferAddRef the call to COIBufferCopy will not\n /// wait, it will still copy data immediately.\n /// This is to facilitate a usage model where a buffer is being used outside\n /// of a run function, for example in a spawned thread, but data still needs\n /// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n ///\n /// @param  in_DestBuffer\n ///         [in] Buffer to copy into.\n-#ifdef COI_PROTOTYPE_TARGET_PROCESS\n+///\n /// @param  in_DestProcess\n-///         [in] A pointer to the processes which are used as hints\n-///         to to COI. Buffers are updated upon these processes first.\n+///         [in] A pointer to the process to which the data will be written.\n+///         Buffer is updated only in this process and invalidated in other\n+///         processes. Only a single process can be specified.\n ///         Can be left NULL and default behavior will be chosen, which\n-///         chooses the lowest SCIF node with an active regions first. Others\n-///         buffer regions are invalidated in both cases. Will only update a single\n-///         process at this time.\n-#endif\n+///         chooses the first valid process in which regions are found. Other\n+///         buffer regions are invalidated if not updated.\n ///\n /// @param  in_SourceBuffer\n ///         [in] Buffer to copy from.\n@@ -1089,7 +1435,7 @@ COIBufferRead(\n /// @return COI_INVALID_HANDLE if either buffer handle was invalid.\n ///\n /// @return COI_MEMORY_OVERLAP if in_SourceBuffer and in_DestBuffer are the\n-///         same buffer(or have the same parent buffer) and the source and \n+///         same buffer(or have the same parent buffer) and the source and\n ///         destination regions overlap\n ///\n /// @return COI_OUT_OF_RANGE if in_DestOffset is is beyond the end of\n@@ -1110,19 +1456,12 @@ COIBufferRead(\n /// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n ///         in_NumDependencies is not 0.\n ///\n-/// @return COI_NOT_SUPPORTED if the source or destination buffers are of type\n-///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n-///\n-/// @return COI_NOT_SUPPORTED if either buffer is of type\n-///         COI_BUFFER_STREAMING_TO_SINK or COI_BUFFER_STREAMING_TO_SOURCE.\n-///\n /// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n ///         COI_BUFFER_PINNED buffers or COI_BUFFER_OPENCL buffers.\n ///\n-#ifdef COI_PROTOTYPE_TARGET_PROCESS\n COIACCESSAPI\n COIRESULT\n-COIBufferCopy(\n+COIBufferCopyEx(\n             COIBUFFER           in_DestBuffer,\n     const   COIPROCESS          in_DestProcess,\n             COIBUFFER           in_SourceBuffer,\n@@ -1133,8 +1472,100 @@ COIBufferCopy(\n             uint32_t            in_NumDependencies,\n     const   COIEVENT*           in_pDependencies,\n             COIEVENT*           out_pCompletion);\n-__asm__(\".symver COIBufferCopy,COIBufferCopy@COI_2.0\");\n-#else\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Copy data between two buffers. It also allows copying within the same\n+/// buffer. For copy within the same buffer, if source and destination regions\n+/// overlap then this API returns error.\n+/// Please note that COIBufferCopy does not follow implicit buffer\n+/// dependencies. If a buffer is in use in a run function or has been added\n+/// to a process using COIBufferAddRef the call to COIBufferCopy will not\n+/// wait, it will still copy data immediately.\n+/// This is to facilitate a usage model where a buffer is being used outside\n+/// of a run function, for example in a spawned thread, but data still needs\n+/// to be transferred to or from the buffer.\n+/// Additionally this means that if more than one DMA channel is enabled,\n+/// (See COIProcessConfigureDMA) operations to the same buffer may\n+/// happen in parallel if they can be assigned to different DMA hardware.\n+/// So it is highly recommended to use explicit event dependencies to\n+/// order operations where needed.\n+///\n+/// @param  in_DestBuffer\n+///         [in] Buffer to copy into.\n+///\n+/// @param  in_SourceBuffer\n+///         [in] Buffer to copy from.\n+///\n+/// @param  in_DestOffset\n+///         [in] Location in the destination buffer to start writing to.\n+///\n+/// @param  in_SourceOffset\n+///         [in] Location in the source buffer to start reading from.\n+///\n+/// @param  in_Length\n+///         [in] The number of bytes to copy from in_SourceBuffer into\n+///         in_DestinationBuffer.\n+///         If the length is specified as zero then length to be copied\n+///         is entire destination buffer's length.\n+///         Must not be larger than the size of in_SourceBuffer or\n+///         in_DestBuffer and must not over run in_SourceBuffer or\n+///         in_DestBuffer if offsets are specified.\n+///\n+/// @param  in_Type\n+///         [in] The type of copy operation to use, one of either\n+///         COI_COPY_UNSPECIFIED, COI_COPY_USE_DMA, COI_COPY_USE_CPU.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the copy call to\n+///         wait for any additional events to be signaled before starting the\n+///         copy operation.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this copy operation will wait for before starting.\n+///         This allows the user to create dependencies between buffer copy\n+///         calls and other operations such as run functions and map calls. The\n+///         user may pass in NULL if they do not wish to wait for any\n+///         additional dependencies to complete before doing the copy.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional event to be signaled when the copy has\n+///         completed. This event can be used as a dependency to order\n+///         the copy with regard to future operations.\n+///         If no completion event is passed in then the copy is\n+///         synchronous and will block until the transfer is complete.\n+///\n+/// @return COI_SUCCESS if the buffer was copied successfully.\n+///\n+/// @return COI_INVALID_HANDLE if either buffer handle was invalid.\n+///\n+/// @return COI_MEMORY_OVERLAP if in_SourceBuffer and in_DestBuffer are the\n+///         same buffer(or have the same parent buffer) and the source and\n+///         destination regions overlap\n+///\n+/// @return COI_OUT_OF_RANGE if in_DestOffset is is beyond the end of\n+///         in_DestBuffer\n+///\n+/// @return COI_OUT_OF_RANGE if in_SourceOffset is beyond the end of\n+///         in_SourceBuffer.\n+///\n+/// @return COI_OUT_OF_RANGE if in_DestOffset + in_Length exceeds the size of\n+///         the in_DestBuffer\n+///\n+/// @return COI_OUT_OF_RANGE if in_SourceOffset + in_Length exceeds\n+///         the size of in_SourceBuffer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_pDependencies is non NULL but\n+///         in_NumDependencies is 0.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_pDependencies is NULL but\n+///         in_NumDependencies is not 0.\n+///\n+/// @return COI_RETRY if in_DestBuffer or in_SourceBuffer are mapped and not\n+///         COI_BUFFER_PINNED buffers or COI_BUFFER_OPENCL buffers.\n+///\n COIACCESSAPI\n COIRESULT\n COIBufferCopy(\n@@ -1147,39 +1578,38 @@ COIBufferCopy(\n             uint32_t            in_NumDependencies,\n     const   COIEVENT*           in_pDependencies,\n             COIEVENT*           out_pCompletion);\n-__asm__(\".symver COIBufferCopy,COIBufferCopy@COI_1.0\");\n-#endif\n+\n //////////////////////////////////////////////////////////////////////////////\n ///\n-/// This API allows an experienced Intel\u00ae Coprocessor Offload Infrastructure\n-/// (Intel\u00ae COI)  developer to set where a COIBUFFER is\n+/// This API allows an experienced Intel(R) Coprocessor Offload Infrastructure\n+/// (Intel(R) COI) developer to set where a COIBUFFER is\n /// located and when the COIBUFFER's data is moved. This functionality is\n /// useful when the developer knows when and where a buffer is going to be\n /// accessed. It allows the data movement to happen sooner than if the\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// runtime tried to manage the buffer placement itself. The advantage of\n /// this API is that the developer knows much more about their own\n /// application's data access patterns and can therefore optimize the data\n-/// access to be much more efficient than the Intel\u00ae Coprocessor Offload\n-/// Infrastructure (Intel\u00ae COI) runtime. Using this API may yield better \n+/// access to be much more efficient than the Intel(R)Coprocessor Offload\n+/// Infrastructure (Intel(R) COI) runtime. Using this API may yield better\n /// memory utilization, lower latency and overall improved workload\n /// throughput.\n /// This API does respect implicit dependencies for buffer read/write hazards.\n /// For example, if the buffer is being written in one COIPROCESS and the user\n /// requests the buffer be placed in another COIPROCESS then this API will wait\n /// for the first access to complete before moving the buffer.\n /// This API is not required for program correctness. It is intended solely\n-/// for advanced Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)\n+/// for advanced Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// developers who wish to fine tune their application performance\n /// Cases where \"a change in state\" is an error condition the change just gets\n-/// ignored without any error. This is because the SetState can be a \n+/// ignored without any error. This is because the SetState can be a\n /// nonblocking call and in such cases we can't rely on the state of the buffer\n /// at the time of the call. We can do the transition checks only at the time\n /// when the actual state change happens (which is something in future).\n /// Currently there is no way to report an error from something that happens in\n /// future and that is why such state transitions are nop. One example is using\n-/// VALID_MAY_DROP with COI_SINK_OWNERS when buffer is not valid at source. \n-/// This operation will be a nop if at the time of actual state change the \n+/// VALID_MAY_DROP with COI_SINK_OWNERS when buffer is not valid at source.\n+/// This operation will be a nop if at the time of actual state change the\n /// buffer is not valid at source.\n ///\n /// @param  in_Buffer\n@@ -1188,7 +1618,7 @@ __asm__(\".symver COIBufferCopy,COIBufferCopy@COI_1.0\");\n /// @param  in_Process\n ///         [in] The process where the state is being modified for this\n ///         buffer. To modify buffer's state on source process use\n-///         COI_PROCESS_SOURCE as process handle. To modify buffer's \n+///         COI_PROCESS_SOURCE as process handle. To modify buffer's\n ///         state on all processes where buffer is valid use COI_SINK_OWNERS\n ///         as the process handle.\n ///\n@@ -1222,7 +1652,7 @@ __asm__(\".symver COIBufferCopy,COIBufferCopy@COI_1.0\");\n ///         [out] An optional event to be signaled when the SetState has\n ///         completed. This event can be used as a dependency to order\n ///         the SetState with regard to future operations.\n-///         If no completion event is passed in then the  is\n+///         If no completion event is passed in then the state changing is\n ///         synchronous and will block until the SetState and dma transfers\n ///         related to this operation are complete.\n ///\n@@ -1239,10 +1669,9 @@ __asm__(\".symver COIBufferCopy,COIBufferCopy@COI_1.0\");\n /// @return COI_ARGUMENT_MISMATCH if the in_Process is COI_SINK_OWNERS and the\n ///         COI_BUFFER_MOVE is passed as move flag.\n ///\n-/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process \n+/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process\n ///         handle that was passed in.\n ///\n-\n COIACCESSAPI\n COIRESULT\n COIBufferSetState(\n@@ -1257,9 +1686,9 @@ COIBufferSetState(\n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Creates a sub-buffer that is a reference to a portion of an existing\n-/// buffer.  The returned buffer handle can be used in all API calls that the\n+/// buffer. The returned buffer handle can be used in all API calls that the\n /// original buffer handle could be used in except COIBufferCreateSubBuffer.\n-/// Sub buffers out of Huge Page Buffer are also supported but the original \n+/// Sub buffers out of Huge Page Buffer are also supported but the original\n /// buffer needs to be a OPENCL buffer created with COI_OPTIMIZE_HUGE_PAGE_SIZE\n /// flag.\n ///\n@@ -1279,7 +1708,7 @@ COIBufferSetState(\n /// @param  out_pSubBuffer\n ///         [out] Pointer to a buffer handle that is filled in with the newly\n ///         created sub-buffer.\n-/// \n+///\n /// @return COI_SUCCESS if the sub-buffer was created\n ///\n /// @return COI_INVALID_HANDLE if in_Buffer is not a valid buffer handle.\n@@ -1302,6 +1731,79 @@ COIBufferCreateSubBuffer(\n             uint64_t    in_Offset,\n             COIBUFFER*  out_pSubBuffer);\n \n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Releases the reference count on the specified buffer and process by\n+/// in_ReleaseRefcnt. The returned result being COI_SUCCESS indicates that the\n+/// specified process contains a reference to the specified buffer that has a\n+/// refcnt that can be decremented. Otherwise, if the buffer or process\n+/// specified do not exist, then COI_INVALID_HANDLE will be returned. If the\n+/// process does not contain a reference to the specified buffer then\n+/// COI_OUT_OF_RANGE will be returned.\n+///\n+///\n+/// @param  in_Process\n+///         [in] The COI Process whose reference count for the specified buffer\n+///         the user wants to decrement.\n+///\n+/// @param  in_Buffer\n+///         [in] The buffer used in the specified coi process in which the user\n+///         wants to decrement the reference count.\n+///\n+/// @param  in_ReleaseRefcnt\n+///         [in] The value the reference count will be decremented by.\n+///\n+/// @return COI_SUCCESS if the reference count was successfully decremented.\n+///\n+/// @return COI_INVALID_HANDLE if in_Buffer or in_Process are invalid handles.\n+///\n+/// @return COI_OUT_OF_RANGE if the reference for the specified buffer or\n+///         process does not exist.\n+///\n+\n+COIACCESSAPI\n+COIRESULT\n+COIBufferReleaseRefcnt(\n+            COIPROCESS          in_Process,\n+            COIBUFFER           in_Buffer,\n+            uint64_t            in_ReleaseRefcnt);\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Increments the reference count on the specified buffer and process by\n+/// in_AddRefcnt. The returned result being COI_SUCCESS indicates that the\n+/// specified process contains a reference to the specified buffer or a new\n+/// reference has been created and that reference has a new refcnt. Otherwise,\n+/// if the buffer or process specified do not exist, then COI_INVALID_HANDLE\n+/// will be returned. If the input buffer is not valid on the target process\n+/// then COI_NOT_INITIALIZED will be returned since the buffer is not current\n+/// or allocated on the process.\n+///\n+/// @param  in_Process\n+///         [in] The COI Process whose reference count for the specified buffer\n+///         the user wants to increment.\n+///\n+/// @param  in_Buffer\n+///         [in] The buffer used in the specified coi process in which the user\n+///         wants to increment the reference count.\n+///\n+/// @param  in_AddRefcnt\n+///         [in] The value the reference count will be incremented by.\n+///\n+/// @return COI_SUCCESS if the reference count was successfully incremented.\n+///\n+/// @return COI_INVALID_HANDLE if in_Buffer or in_Process are invalid handles.\n+///\n+/// @return COI_NOT_INITIALIZED if in_Buffer does not have a buffer state of\n+///         COI_BUFFER_VALID on the in_Process.\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIBufferAddRefcnt(\n+            COIPROCESS          in_Process,\n+            COIBUFFER           in_Buffer,\n+            uint64_t            in_AddRefcnt);\n+\n #ifdef __cplusplus\n } /* extern \"C\" */\n #endif"}, {"sha": "a3b7799cfb56890c6c0b3a17a30bc946f68d7536", "filename": "liboffloadmic/include/coi/source/COIEngine_source.h", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEngine_source.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -75,7 +75,7 @@ typedef enum\n \n \n ///////////////////////////////////////////////////////////////////////////////\n-/// This structure returns information about an Intel(r) Xeon Phi(tm)\n+/// This structure returns information about an Intel(R) Xeon Phi(TM)\n /// coprocessor.\n /// A pointer to this structure is passed into the COIGetEngineInfo() function,\n /// which fills in the data before returning to the caller.\n@@ -101,6 +101,7 @@ typedef struct COI_ENGINE_INFO\n     uint32_t     CoreMaxFrequency;\n \n     /// The load percentage for each of the hardware threads on the engine.\n+    /// Currently this is limited to reporting out a maximum of 1024 HW threads\n     uint32_t     Load[COI_MAX_HW_THREADS];\n \n     /// The amount of physical memory managed by the OS.\n@@ -133,9 +134,9 @@ typedef struct COI_ENGINE_INFO\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-/// Returns information related to a specified engine. Note that if Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  is\n-/// unable to query a value it will be returned as zero but the call will\n-/// still succeed.\n+/// Returns information related to a specified engine. Note that if Intel(R)\n+/// Coprocessor Offload Infrastructure (Intel(R) COI) is unable to query\n+/// a value it will be returned as zero but the call will still succeed.\n ///\n ///\n /// @param  in_EngineHandle\n@@ -173,14 +174,15 @@ COIEngineGetInfo(\n ///\n /// Returns the number of engines in the system that match the provided ISA.\n ///\n-/// Note that while it is possible to enumerate different types of Intel(r)\n-/// Xeon Phi(tm) coprocessors on a single host this is not currently \n-/// supported. Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  makes an assumption that all Intel(r) Xeon Phi(tm) \n-/// coprocessors found in the system are the same architecture as the first \n-/// coprocessor device.\n+/// Note that while it is possible to enumerate different types of Intel(R)\n+/// Xeon Phi(TM) coprocessors on a single host this is not currently\n+/// supported. Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+/// makes an assumption that all Intel(R) Xeon Phi(TM) coprocessors found\n+/// in the system are the same architecture as the first coprocessor device.\n ///\n-/// Also, note that this function returns the number of engines that Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n-/// is able to detect. Not all of them may be online.\n+/// Also, note that this function returns the number of engines that Intel(R)\n+/// Coprocessor Offload Infrastructure (Intel(R) COI) is able to detect. Not\n+/// all of them may be online.\n ///\n /// @param  in_ISA\n ///         [in] Specifies the ISA type of the engine requested.\n@@ -211,7 +213,7 @@ COIEngineGetCount(\n ///\n /// @param  in_EngineIndex\n ///         [in] A unsigned integer which specifies the zero-based position of\n-///         the engine in a collection of engines.  The makeup of this\n+///         the engine in a collection of engines. The makeup of this\n ///         collection is defined by the in_ISA parameter.\n ///\n /// @param  out_pEngineHandle\n@@ -226,7 +228,8 @@ COIEngineGetCount(\n ///\n /// @return COI_INVALID_POINTER if the out_pEngineHandle parameter is NULL.\n ///\n-/// @return COI_VERSION_MISMATCH if the version of Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  on the host is not\n+/// @return COI_VERSION_MISMATCH if the version of Intel(R) Coprocessor Offload\n+///         Infrastructure (Intel(R) COI) on the host is not\n ///         compatible with the version on the device.\n ///\n /// @return COI_NOT_INITIALIZED if the engine requested exists but is offline."}, {"sha": "ecb00fafe2d88fe56842562efbe3a6999b79a519", "filename": "liboffloadmic/include/coi/source/COIEvent_source.h", "status": "modified", "additions": 118, "deletions": 9, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIEvent_source.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -59,19 +59,27 @@ extern \"C\" {\n ///\n /// Special case event values which can be passed in to APIs to specify\n /// how the API should behave. In COIBuffer APIs passing in NULL for the\n-/// completion event is the equivalent of passing COI_EVENT_SYNC. For\n-/// COIPipelineRunFunction passing in NULL is the equivalent of\n-/// COI_EVENT_ASYNC.\n+/// completion event is the equivalent of passing COI_EVENT_SYNC.\n /// Note that passing COI_EVENT_ASYNC can be used when the caller wishes the\n /// operation to be performed asynchronously but does not care when the\n-/// operation completes. This can be useful for opertions that by definition\n+/// operation completes. This can be useful for operations that by definition\n /// must complete in order (DMAs, run functions on a single pipeline). If\n /// the caller does care when the operation completes then they should pass\n /// in a valid completion event which they can later wait on.\n ///\n #define COI_EVENT_ASYNC ((COIEVENT*)1)\n #define COI_EVENT_SYNC  ((COIEVENT*)2)\n \n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// This can be used to initialize a COIEVENT to a known invalid state.\n+/// This is not required to use, but can be useful in some cases\n+/// if a program is unsure if the event will be initialized by the runtime.\n+/// Simply set the event to this value: COIEVENT event = COI_EVENT_INITIALIZER;\n+///\n+#define COI_EVENT_INITIALIZER   { { 0, -1 } }\n+\n+\n ///////////////////////////////////////////////////////////////////////////////\n ///\n /// Wait for an arbitrary number of COIEVENTs to be signaled as completed,\n@@ -94,17 +102,17 @@ extern \"C\" {\n ///         and returns immediately, -1 blocks indefinitely.\n ///\n /// @param  in_WaitForAll\n-///         [in] Boolean value specifying behavior.  If true, wait for all\n+///         [in] Boolean value specifying behavior. If true, wait for all\n ///         events to be signaled, or for timeout, whichever happens first.\n ///         If false, return when any event is signaled, or at timeout.\n ///\n /// @param  out_pNumSignaled\n-///         [out] The number of events that were signaled.  If in_NumEvents\n+///         [out] The number of events that were signaled. If in_NumEvents\n ///         is 1 or in_WaitForAll = True, this parameter is optional.\n ///\n /// @param  out_pSignaledIndices\n-///         [out] Pointer to an array of indicies into the original event\n-///         array.  Those denoted have been signaled.  The user must provide an\n+///         [out] Pointer to an array of indices into the original event\n+///         array. Those denoted have been signaled. The user must provide an\n ///         array that is no smaller than the in_Events array. If in_NumEvents\n ///         is 1 or in_WaitForAll = True, this parameter is optional.\n ///\n@@ -132,6 +140,10 @@ extern \"C\" {\n /// @return COI_PROCESS_DIED if the remote process died. See COIProcessDestroy\n ///         for more details.\n ///\n+/// @return COI_<REAL ERROR> if only a single event is passed in, and that event\n+///         failed, COI will attempt to return the real error code that caused\n+///         the original operation to fail, otherwise COI_PROCESS_DIED is reported.\n+///\n COIACCESSAPI\n COIRESULT\n COIEventWait(\n@@ -183,6 +195,103 @@ COIRESULT\n COIEventUnregisterUserEvent(\n             COIEVENT in_Event);\n \n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// A callback that will be invoked to notify the user of an internal\n+/// runtime event completion.\n+///\n+/// As with any callback mechanism it is up to the user to make sure that\n+/// there are no possible deadlocks due to reentrancy (ie the callback being\n+/// invoked in the same context that triggered the notification) and also\n+/// that the callback does not slow down overall processing. If the user\n+/// performs too much work within the callback it could delay further\n+/// processing. The callback will be invoked prior to the signaling of\n+/// the corresponding COIEvent. For example, if a user is waiting\n+/// for a COIEvent associated with a run function completing they will\n+/// receive the callback before the COIEvent is marked as signaled.\n+///\n+/// @param  in_Event\n+///         [in] The completion event that is associated with the\n+///         operation that is being notified.\n+///\n+/// @param  in_Result\n+///         [in] The COIRESULT of the operation.\n+///\n+/// @param  in_UserData\n+///         [in] Opaque data that was provided when the callback was\n+///         registered. Intel(R) Coprocessor Offload Infrastructure\n+///         (Intel(R) COI) simply passes this back to the user so that\n+///         they can interpret it as they choose.\n+///\n+typedef void (*COI_EVENT_CALLBACK)(\n+            COIEVENT            in_Event,\n+    const   COIRESULT           in_Result,\n+    const   void*               in_UserData);\n+\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Registers any COIEVENT to receive a one time callback, when the event\n+/// is marked complete in the offload runtime. If the event has completed\n+/// before the COIEventRegisterCallback() is called then the callback will\n+/// immediately be invoked by the calling thread. When the event is\n+/// registered before the event completes, the runtime gaurantees that\n+/// the callback will be invoked before COIEventWait() is notified of\n+/// the same event completing. In well written user code, this may provide\n+/// a slight performance advantage.\n+///\n+/// Users should treat the callback much like an interrupt routine, in regards\n+/// of performance. Specifically designing the callback to be as short and\n+/// non blocking as possible. Since the thread that runs the callback is\n+/// non deterministic blocking or stalling of the callback, may have severe\n+/// performance impacts on the offload runtime. Thus, it is important to not\n+/// create deadlocks between the callback and other signaling/waiting\n+/// mechanisms. It is recommended to never invoke COIEventWait() inside\n+/// a callback function, as this could lead to immediate deadlocks.\n+///\n+/// It is important to note that the runtime cannot distinguish between\n+/// already triggered events and invalid events. Thus the user needs to pass\n+/// in a valid event, or the callback will be invoked immediately.\n+/// Failed events will still receive a callback and the user can query\n+/// COIEventWait() after the callback for the failed return code.\n+///\n+/// If more than one callback is registered for the same event, only the\n+/// single most current callback will be used, i.e. the older one will\n+/// be replaced.\n+///\n+/// @param  in_Event\n+///         [in] A valid single event handle to be registered to receive a callback.\n+///\n+/// @param  in_Callback\n+///         [in] Pointer to a user function used to signal an\n+///         event completion.\n+///\n+/// @param  in_UserData\n+///         [in] Opaque data to pass to the callback when it is invoked.\n+///\n+/// @param  in_Flags\n+///         [in] Reserved parameter for future expansion, required to be zero for now.\n+///\n+/// @return COI_INVALID_HANDLE if in_Event is not a valid COIEVENT\n+///\n+/// @return COI_INVALID_HANDLE if in_Callback is not a valid pointer.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if the in_Flags is not zero.\n+///\n+/// @return COI_SUCCESS an event is successfully registered\n+///\n+COIACCESSAPI\n+COIRESULT\n+COIEventRegisterCallback(\n+      const COIEVENT                in_Event,\n+            COI_EVENT_CALLBACK      in_Callback,\n+      const void*                   in_UserData,\n+      const uint64_t                in_Flags);\n+\n+\n+\n #ifdef __cplusplus\n } /* extern \"C\" */\n #endif"}, {"sha": "78c49ec2e099ba5d34794268ad2c479c9d5b2bbb", "filename": "liboffloadmic/include/coi/source/COIPipeline_source.h", "status": "modified", "additions": 44, "deletions": 33, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIPipeline_source.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -59,12 +59,13 @@ extern \"C\" {\n \n \n //////////////////////////////////////////////////////////////////////////////\n-/// These flags specify how a buffer will be used within a run function.  They\n-/// allow Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  to make optimizations in how it moves data around the system.\n+/// These flags specify how a buffer will be used within a run function. They\n+/// allow the runtime to make optimizations in how it moves the data around.\n /// These flags can affect the correctness of an application, so they must be\n-/// set properly.  For example, if a buffer is used in a run function with the\n-/// COI_SINK_READ flag and then mapped on the source, Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  may use a previously\n-/// cached version of the buffer instead of retrieving data from the sink.\n+/// set properly. For example, if a buffer is used in a run function with the\n+/// COI_SINK_READ flag and then mapped on the source, the runtime may use a\n+/// previously cached version of the buffer instead of retrieving data from\n+/// the sink.\n typedef enum COI_ACCESS_FLAGS\n {\n     /// Specifies that the run function will only read the associated buffer.\n@@ -76,7 +77,23 @@ typedef enum COI_ACCESS_FLAGS\n     /// Specifies that the run function will overwrite the entire associated\n     /// buffer and therefore the buffer will not be synchronized with the\n     /// source before execution.\n-    COI_SINK_WRITE_ENTIRE\n+    COI_SINK_WRITE_ENTIRE,\n+\n+    /// Specifies that the run function will only read the associated buffer\n+    /// and will maintain the reference count on the buffer after\n+    /// run function exit.\n+    COI_SINK_READ_ADDREF,\n+\n+    /// Specifies that the run function will write to the associated buffer\n+    /// and will maintain the reference count on the buffer after\n+    /// run function exit.\n+    COI_SINK_WRITE_ADDREF,\n+\n+    /// Specifies that the run function will overwrite the entire associated\n+    /// buffer and therefore the buffer will not be synchronized with the\n+    /// source before execution and will maintain the reference count on the\n+    /// buffer after run function exit.\n+    COI_SINK_WRITE_ENTIRE_ADDREF\n } COI_ACCESS_FLAGS;\n \n #define COI_PIPELINE_MAX_PIPELINES 512\n@@ -86,7 +103,7 @@ typedef enum COI_ACCESS_FLAGS\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-/// Create a pipeline assoiated with a remote process. This pipeline can\n+/// Create a pipeline associated with a remote process. This pipeline can\n /// then be used to execute remote functions and to share data using\n /// COIBuffers.\n ///\n@@ -133,8 +150,8 @@ typedef enum COI_ACCESS_FLAGS\n /// @return COI_TIME_OUT_REACHED if establishing the communication channel with\n ///         the remote pipeline timed out.\n ///\n-/// @return COI_RETRY  if the pipeline cannot be created due to the number of\n-///         source-to-sink connections in use. A subsequent call to \n+/// @return COI_RETRY if the pipeline cannot be created due to the number of\n+///         source-to-sink connections in use. A subsequent call to\n ///         COIPipelineCreate may succeed if resources are freed up.\n ///\n /// @return COI_PROCESS_DIED if in_Process died.\n@@ -149,7 +166,7 @@ COIPipelineCreate(\n \n ///////////////////////////////////////////////////////////////////////////////\n ///\n-/// Destroys the inidicated pipeline, releasing its resources.\n+/// Destroys the indicated pipeline, releasing its resources.\n ///\n /// @param  in_Pipeline\n ///         [in] Pipeline to destroy.\n@@ -175,22 +192,21 @@ COIPipelineDestroy(\n ///\n /// 1. Proper care has to be taken while setting the input dependencies for\n ///    RunFunctions. Setting it incorrectly can lead to cyclic dependencies\n-///    and can cause the respective pipeline (as a result Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Runtime) to\n-///    stall.\n+///    and can cause the respective pipeline to stall.\n /// 2. RunFunctions can also segfault if enough memory space is not available\n ///    on the sink for the buffers passed in. Pinned buffers and buffers that\n ///    are AddRef'd need to be accounted for available memory space. In other\n ///    words, this memory is not available for use until it is freed up.\n-/// 3. Unexpected segmentation faults or erroneous behaviour can occur if \n-///    handles or data passed in to Runfunction gets destroyed before the \n+/// 3. Unexpected segmentation faults or erroneous behavior can occur if\n+///    handles or data passed in to Runfunction gets destroyed before the\n ///    RunFunction finishes.\n ///    For example, if a variable passed in as Misc data or the buffer gets\n-///    destroyed before the Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  runtime receives the completion notification \n-///    of the Runfunction, it can cause unexpected behaviour. So it is always\n+///    destroyed before the runtime receives the completion notification\n+///    of the Runfunction, it can cause unexpected behavior. So it is always\n ///    recommended to wait for RunFunction completion event before any related\n ///    destroy event occurs.\n ///\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  Runtime expects users to handle such scenarios. COIPipelineRunFunction\n+/// The runtime expects users to handle such scenarios. COIPipelineRunFunction\n /// returns COI_SUCCESS for above cases because it was queued up successfully.\n /// Also if you try to destroy a pipeline with a stalled function then the\n /// destroy call will hang. COIPipelineDestroy waits until all the functions\n@@ -240,7 +256,7 @@ COIPipelineDestroy(\n ///         [in] Pointer to user defined data, typically used to pass\n ///         parameters to Sink side functions. Should only be used for small\n ///         amounts data since the data will be placed directly in the\n-///         Driver's command buffer.  COIBuffers should be used to pass large\n+///         Driver's command buffer. COIBuffers should be used to pass large\n ///         amounts of data.\n ///\n /// @param  in_MiscDataLen\n@@ -250,20 +266,23 @@ COIPipelineDestroy(\n ///\n /// @param  out_pAsyncReturnValue\n ///         [out] Pointer to user-allocated memory where the return value from\n-///         the run function will be placed.  This memory should not be read\n-///         until out_pCompletion has been signalled.\n+///         the run function will be placed. This memory should not be read\n+///         until out_pCompletion has been signaled.\n ///\n /// @param  in_AsyncReturnValueLen\n ///         [in] Size of the out_pAsyncReturnValue in bytes.\n ///\n /// @param  out_pCompletion\n ///         [out] An optional pointer to a COIEVENT object\n ///         that will be signaled when this run function has completed\n-///         execution. The user may pass in NULL if they do not wish to signal\n-///         any COIEVENTs when this run function completes.\n+///         execution. The user may pass in NULL if they wish for this function\n+///         to be synchronous, otherwise if a COIEVENT object is passed in the\n+///         function is then asynchronous and closes after enqueuing the\n+///         RunFunction and passes back the COIEVENT that will be signaled\n+///         once the RunFunction has completed.\n ///\n /// @return COI_SUCCESS if the function was successfully placed in a\n-///         pipeline for future execution.  Note that the actual\n+///         pipeline for future execution. Note that the actual\n ///         execution of the function will occur in the future.\n ///\n /// @return COI_OUT_OF_RANGE if in_NumBuffers is greater than\n@@ -303,18 +322,10 @@ COIPipelineDestroy(\n /// @return COI_ARGUMENT_MISMATCH if in_pReturnValue is non-NULL but\n ///         in_ReturnValueLen is zero.\n ///\n-/// @return COI_ARGUMENT_MISMATCH if a COI_BUFFER_STREAMING_TO_SOURCE buffer\n-///         is not passed with COI_SINK_WRITE_ENTIRE access flag.\n-///\n-/// @return COI_RESOURCE_EXHAUSTED if could not create a version for TO_SOURCE\n-///         streaming buffer. It can fail if enough memory is not available to\n-///         register. This call will succeed eventually when the registered\n-///         memory becomes available.\n-///\n /// @return COI_RETRY if any input buffers, which are not pinned buffers,\n ///         are still mapped when passed to the run function.\n ///\n-/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process \n+/// @return COI_MISSING_DEPENDENCY if buffer was not created on the process\n ///         associated with the pipeline that was passed in.\n ///\n /// @return COI_OUT_OF_RANGE if any of the access flags in"}, {"sha": "8cc6ffc3bf83dae0bdd3b16e3b95f7bf51c38edb", "filename": "liboffloadmic/include/coi/source/COIProcess_source.h", "status": "modified", "additions": 303, "deletions": 39, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fcoi%2Fsource%2FCOIProcess_source.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -61,10 +61,16 @@ extern \"C\" {\n /// This is a special COIPROCESS handle that can be used to indicate that\n /// the source process should be used for an operation.\n ///\n-#define COI_PROCESS_SOURCE  ((COIPROCESS)-1)\n+#define COI_PROCESS_SOURCE ((COIPROCESS)-1)\n \n #define COI_MAX_FILE_NAME_LENGTH 256\n \n+///////////////////////////////////////////////////////////////////////////////\n+/// This is a flag for COIProcessCreateFromMemory that indicates the passed in\n+/// memory pointer is a fat binary file and should not have regular validation.\n+///\n+#define COI_FAT_BINARY ((uint64_t)-1)\n+\n ///////////////////////////////////////////////////////////////////////////////\n ///\n /// Create a remote process on the Sink and start executing its main()\n@@ -74,14 +80,14 @@ extern \"C\" {\n ///\n /// @param  in_Engine\n ///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n-///         indicates which device to create the process on.  This is\n+///         indicates which device to create the process on. This is\n ///         necessary because there can be more than one device\n ///         within the system.\n ///\n /// @param  in_pBinaryName\n ///         [in] Pointer to a null-terminated string that contains the\n ///         path to the program binary to be instantiated as a process on\n-///         the sink device.  The file name will be accessed via\n+///         the sink device. The file name will be accessed via\n ///         fopen and fread, as such, the passed in binary name must\n ///         be locatable via these commands. Also, the file name (without\n ///         directory information) will be used automatically by the system\n@@ -121,8 +127,8 @@ extern \"C\" {\n /// @param  in_InitialBufferSpace\n ///         [in] The initial memory (in bytes) that will be pre-allocated at\n ///         process creation for use by buffers associated with this remote\n-///         process. In addition to allocating, Intel\u00ae Coprocessor Offload\n-///         Infrastructure (Intel\u00ae COI)  will also fault in the\n+///         process. In addition to allocating, Intel(R) Coprocessor Offload\n+///         Infrastructure (Intel(R) COI) will also fault in the\n ///         memory during process creation. If the total size of the buffers\n ///         in use by this process exceed this initial size, memory on the\n ///         sink may continue to be allocated on demand, as needed, subject\n@@ -186,7 +192,7 @@ COIProcessCreateFromFile(\n ///\n /// @param  in_Engine\n ///         [in] A handle retrieved via a call to COIEngineGetHandle() that\n-///         indicates which device to create the process on.  This is\n+///         indicates which device to create the process on. This is\n ///         necessary because there can be more than one device\n ///         within the system.\n ///\n@@ -236,8 +242,8 @@ COIProcessCreateFromFile(\n /// @param  in_InitialBufferSpace\n ///         [in] The initial memory (in bytes) that will be pre-allocated at\n ///         process creation for use by buffers associated with this remote\n-///         process. In addition to allocating, Intel\u00ae Coprocessor\n-///         Offload Infrastructure (Intel\u00ae COI)  will also fault in the\n+///         process. In addition to allocating, Intel(R) Coprocessor\n+///         Offload Infrastructure (Intel(R) COI) will also fault in the\n ///         memory during process creation. If the total size of the buffers\n ///         in use by this process exceed this initial size, memory on the\n ///         sink may continue to be allocated on demand, as needed, subject\n@@ -314,8 +320,8 @@ COIProcessCreateFromFile(\n /// @return COI_PROCESS_DIED if at some point during the loading of the remote\n ///         process the remote process terminated abnormally.\n ///\n-/// @return COI_VERSION_MISMATCH if the version of Intel\u00ae Coprocessor\n-///         Offload Infrastructure (Intel\u00ae COI)  on the host is not\n+/// @return COI_VERSION_MISMATCH if the version of Intel(R) Coprocessor\n+///         Offload Infrastructure (Intel(R) COI) on the host is not\n ///         compatible with the version on the device.\n ///\n COIACCESSAPI\n@@ -354,7 +360,7 @@ COIProcessCreateFromMemory(\n ///         [in] If this flag is set to true, then the sink process will be\n ///         forcibly terminated after the timeout has been reached. A timeout\n ///         value of 0 will kill the process immediately, while a timeout of\n-///         -1 is invalid.  If the flag is set to false then a message will\n+///         -1 is invalid. If the flag is set to false then a message will\n ///         be sent to the sink process requesting a clean shutdown. A value\n ///         of false along with a timeout of 0 does not send a shutdown\n ///         message, instead simply polls the process to see if it is alive.\n@@ -374,8 +380,8 @@ COIProcessCreateFromMemory(\n ///         be 0 if the remote process exited cleanly. If the remote process\n ///         exited abnormally this will contain the termination code given\n ///         by the operating system of the remote process. This is an optional\n-///         parameter and the caller may pass in NULL if they are not \n-///         interested in the termination code. The output value of this \n+///         parameter and the caller may pass in NULL if they are not\n+///         interested in the termination code. The output value of this\n ///         pointer is only meaningful if COI_SUCCESS is returned.\n ///\n /// @return COI_SUCCESS if the process was destroyed.\n@@ -390,8 +396,8 @@ COIProcessCreateFromMemory(\n ///\n /// @return COI_TIME_OUT_REACHED if the sink process is still running after\n ///         waiting in_WaitForMainTimeout milliseconds and in_ForceDestroy\n-///         is false.  This is true even if in_WaitForMainTimeout was 0.\n-///         In this case, out_pProcessReturn and out_pTerminationCode \n+///         is false. This is true even if in_WaitForMainTimeout was 0.\n+///         In this case, out_pProcessReturn and out_pTerminationCode\n ///         are undefined.\n ///\n COIACCESSAPI\n@@ -410,10 +416,10 @@ COIProcessDestroy(\n ///\n /// Given a loaded native process, gets an array of function handles that can\n /// be used to schedule run functions on a pipeline associated with that\n-/// process.  See the documentation for COIPipelineRunFunction() for\n-/// additional information.  All functions that are to be retrieved in this\n-/// fashion must have the define COINATIVEPROCESSEXPORT preceeding their type\n-/// specification.  For functions that are written in C++, either the entries\n+/// process. See the documentation for COIPipelineRunFunction() for\n+/// additional information. All functions that are to be retrieved in this\n+/// fashion must have the define COINATIVEPROCESSEXPORT preceding their type\n+/// specification. For functions that are written in C++, either the entries\n /// in in_pFunctionNameArray in must be pre-mangled, or the functions must be\n /// declared as extern \"C\". It is also necessary to link the binary containing\n /// the exported functions with the -rdynamic linker flag.\n@@ -432,7 +438,7 @@ COIProcessDestroy(\n /// @param  in_ppFunctionNameArray\n ///         [in] Pointer to an array of null-terminated strings that match\n ///         the name of functions present in the code of the binary\n-///         previously loaded via COIProcessCreate().  Note that if a C++\n+///         previously loaded via COIProcessCreate(). Note that if a C++\n ///         function is used, then the string passed in must already be\n ///         properly name-mangled, or extern \"C\" must be used for where\n ///         the function is declared.\n@@ -462,7 +468,7 @@ COIProcessDestroy(\n ///         the null.\n ///\n /// @warning This operation can take several milliseconds so it is recommended\n-///          that it only be be done at load time.\n+///          that it only be done at load time.\n ///\n COIACCESSAPI\n COIRESULT\n@@ -486,7 +492,7 @@ COIProcessGetFunctionHandles(\n #define COI_LOADLIBRARY_DEEPBIND   0x00008\n #define COI_LOADLIBRARY_NODELETE   0x01000\n \n-/// Flags to replicate the behavior of the original version of\n+/// Flags to replicate the behaviour of the original version of\n /// COIProcessLoadLibrary* APIs.\n #define COI_LOADLIBRARY_V1_FLAGS   (COI_LOADLIBRARY_GLOBAL|COI_LOADLIBRARY_NOW)\n \n@@ -796,13 +802,13 @@ COIProcessRegisterLibraries(\n //////////////////////////////////////////////////////////////////////////////\n /// The user can choose to have notifications for these internal events\n /// so that they can build their own profiling and performance layer on\n-/// top of Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) . \n+/// top of Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI).\n ///\n typedef enum COI_NOTIFICATIONS\n {\n     /// This event occurs when all explicit and implicit dependencies are\n-    /// satisified and Intel\u00ae Coprocessor Offload Infrastructure\n-    /// (Intel\u00ae COI)  schedules the run function to begin execution.\n+    /// satisfied and Intel(R) Coprocessor Offload Infrastructure\n+    /// (Intel(R) COI) schedules the run function to begin execution.\n     RUN_FUNCTION_READY = 0,\n \n     /// This event occurs just before the run function actually starts\n@@ -835,20 +841,17 @@ typedef enum COI_NOTIFICATIONS\n //////////////////////////////////////////////////////////////////////////////\n ///\n /// A callback that will be invoked to notify the user of an internal\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n+/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// event. Note that the callback is registered per process so any of the\n /// above notifications that happen on the registered process will receive\n /// the callback.\n /// As with any callback mechanism it is up to the user to make sure that\n-/// there are no possible deadlocks due to reentrancy (ie the callback being\n+/// there are no possible deadlocks due to reentrancy (i.e. the callback being\n /// invoked in the same context that triggered the notification) and also\n /// that the callback does not slow down overall processing. If the user\n /// performs too much work within the callback it could delay further\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) \n-/// processing.\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  \n-/// promises to invoke the callback for an internal event prior to\n-/// signaling the corresponding COIEvent. For example, if a user is waiting\n+/// processing. The callback will be invoked prior to the signaling of\n+/// the corresponding COIEvent. For example, if a user is waiting\n /// for a COIEvent associated with a run function completing they will\n /// receive the callback before the COIEvent is marked as signaled.\n ///\n@@ -865,11 +868,12 @@ typedef enum COI_NOTIFICATIONS\n ///\n /// @param  in_UserData\n ///         [in] Opaque data that was provided when the callback was\n-///         registered. Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  simply passes this back to the user so that\n+///         registered. Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+///         simply passes this back to the user so that\n ///         they can interpret it as they choose.\n ///\n typedef void (*COI_NOTIFICATION_CALLBACK)(\n-            COI_NOTIFICATIONS   in_Type, \n+            COI_NOTIFICATIONS   in_Type,\n             COIPROCESS          in_Process,\n             COIEVENT            in_Event,\n     const   void*               in_UserData);\n@@ -878,7 +882,7 @@ typedef void (*COI_NOTIFICATION_CALLBACK)(\n //////////////////////////////////////////////////////////////////////////////\n ///\n /// Register a callback to be invoked to notify that an internal\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI)  event\n+/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI) event\n /// has occured on the process that is associated with the callback.\n /// Note that it is legal to have more than one callback registered with\n /// a given process but those must all be unique callback pointers.\n@@ -942,13 +946,13 @@ COIRESULT COIUnregisterNotificationCallback(\n ///\n /// Set the user data that will be returned in the notification callback.\n /// This data is sticky and per thread so must be set prior to the\n-/// Intel\u00ae Coprocessor Offload Infrastructure (Intel\u00ae COI) //\n+/// Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n /// operation being invoked. If you wish to set the context to be returned\n /// for a specific instance of a user event notification then the context\n /// must be set using this API prior to registering that user event with\n /// COIEventRegisterUserEvent.\n-/// The value may be set prior to each Intel\u00ae Coprocessor Offload\n-/// Infrastructure (Intel\u00ae COI)  operation being called to \n+/// The value may be set prior to each Intel(R) Coprocessor Offload\n+/// Infrastructure (Intel(R) COI) operation being called to\n /// effectively have a unique UserData per callback.\n /// Setting this value overrides any value that was set when the\n /// callback was registered and will also override any future registrations\n@@ -962,6 +966,266 @@ COIACCESSAPI\n void COINotificationCallbackSetContext(\n     const   void*                       in_UserData);\n \n+\n+/// @name COIProcessSetCacheSize flags.\n+/// Flags are divided into two categories: _MODE_ and _ACTION_\n+/// only one of each is valid with each call.\n+/// _ACTIONS_ and _MODES_ should be bitwised OR'ed together, i.e. |\n+//@{\n+\n+/// Current set of DEFINED bits for _MODE_, can be used\n+/// to clear or check fields, not useful to pass into APIs. Used internally.\n+#define COI_CACHE_MODE_MASK                 0x00000007\n+\n+/// Flag to indicate to keep the previous mode of operation. By default\n+/// this would be COI_CACHE_MODE_ONDEMAND_SYNC. As of this release\n+/// This is the only mode available. This mode is valid with _ACTION_\n+/// flags.\n+#define COI_CACHE_MODE_NOCHANGE             0x00000001\n+\n+/// Mode of operation that indicates that COI will allocate physical\n+/// cache memory exactly when it is is needed. COIPipeline execution in\n+/// the given process will momentarily block until the allocation request\n+/// is completed. This is and has been the default mode.\n+#define COI_CACHE_MODE_ONDEMAND_SYNC        0x00000002\n+\n+/// Not yet implemented. Future mode that will not stall a COIPipeline\n+/// but prefer eviction/paging if possible as to immediately execute pipeline.\n+/// At the same time, enqueue background requests to allocate extra cache\n+/// so as to provide optimze behavior on subsequent runs.\n+#define COI_CACHE_MODE_ONDEMAND_ASYNC       0x00000004\n+\n+\n+/// Current set of DEFINED bits for _ACTION_ can be used\n+/// to clear fields, but not useful to pass into API's. Used internally.\n+#define COI_CACHE_ACTION_MASK               0x00070000\n+\n+/// No action requested. With this flag specified\n+/// it is recommended to NOT provide a out_pCompletion event,\n+/// as with this flag, modes and values are immediately set.\n+/// This is valid with _MODE_ flags.\n+#define COI_CACHE_ACTION_NONE               0x00010000\n+\n+/// This _ACTION_ flag will immediately attempt to increase the cache\n+/// physical memory size to the current set pool size(s). Used to\n+/// pre-allocate memory on remote processes, so that runfunction will\n+/// enqueue faster. Also may prevent unused buffer eviction from process\n+/// reducing overhead in trade for memory allocation cost.\n+#define COI_CACHE_ACTION_GROW_NOW           0x00020000\n+\n+/// Not yet implemented. Future _ACTION_ that will attempt to find unused\n+/// allocated cache and free it, with the express goal of reducing the\n+/// footprint on the remote process down to the value of the currently set\n+/// pool size(s).\n+#define COI_CACHE_ACTION_FREE_UNUSED        0x00040000\n+\n+//@}\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Set the minimum preferred COIProcess cache size. By default these values\n+/// are set to 1GB. With the default size of 1GB, Intel(R) COI will only\n+/// grow the cache with each new buffer up until the set limit is consumed,\n+/// after which, only required to accommodate additional buffers.\n+/// This means that after the cache preference is met, a process will act\n+/// as conservative as possible for memory consumption.\n+/// This API will allow users to adjust memory consumption aggressiveness.\n+///\n+/// Additional performance may be gained if the user sets a value higher than\n+/// default. With high memory consumption user can choose to trade performance\n+/// between memory allocation cost and transfer speeds to and from the\n+/// remote process. A last consideration is that if buffers are used only\n+/// once, it may be best to keep a small cache size, or ensure buffers are\n+/// fully destroyed after their use.\n+///\n+/// Adjusting this value to high may result in out of resource conditions.\n+///\n+/// @param  in_pProcess\n+///         [in] Handle to uniquely identify the process for which the cache\n+///         is to be adjusted.\n+///\n+/// @param  in_HugePagePoolSize\n+///         [in] The suggested size of the remote huge page cache in bytes.\n+///         This value defaults to 1GB. A process will only allocate cache\n+///         memory if the current cache is smaller than this limit, or it is\n+///         absolutely necessary to fulfill a request, but preferring to\n+///         re-use existing memory and paging unused buffers back to the host\n+///         Increasing this value will cause a process to\n+///         aggressively allocate memory on demand up to this value, before\n+///         evicting/paging memory from the remote process back to the host\n+///         process.\n+///\n+///         The net result is that memory consumption is increased, but the\n+///         user can 'cache' more buffers on the remote process. More time\n+///         may be spent during first use of run functions as more memory\n+///         may be allocated, but subsequent run functions will likely\n+///         see an increase in queueing performance as the data is already\n+///         valid in the remote process.\n+///\n+///         Users should tune this value for optimum performance balanced\n+///         against memory consumption. This value does not affect 4K page\n+///         cache. Please use in_SmallPagePoolSize for 4K pages.\n+///\n+/// @param  in_HugeFlags\n+///         [in] Flags to select mode or action for huge page cache. One _MODE_\n+///         and one _ACTION_ flag are specified together. Default _MODE_ is\n+///         COI_CACHE_MODE_ONDEMAND_SYNC. See all COI_CACHE_MODE_* and\n+///         COI_CACHE_ACTION_* for other modes and actions. Default _ACTION_\n+///         is COI_CACHE_ACTION_NONE.\n+///\n+/// @param  in_SmallPagePoolSize\n+///         [in] The suggested size of the remote 4K cache in bytes. Same\n+///         function as in_HugePagePoolSize but affecting only 4K page cache.\n+///         Defaults to 1GB.\n+///\n+/// @param  in_SmallFlags\n+///         [in] Flags to select mode or action for 4K page cache. One _MODE_\n+///         and one _ACTION_ flag are be specified together. Default _MODE_ is\n+///         COI_CACHE_MODE_ONDEMAND_SYNC. See all COI_CACHE_MODE_* and\n+///         COI_CACHE_ACTION_* for other modes and actions.\n+///\n+/// @param  in_NumDependencies\n+///         [in] The number of dependencies specified in the in_pDependencies\n+///         array. This may be 0 if the caller does not want the call to\n+///         wait for any events to be signaled.\n+///\n+/// @param  in_pDependencies\n+///         [in] An optional array of handles to previously created COIEVENT\n+///         objects that this operation will wait for before starting.\n+///         This allows the user to create dependencies between asynchronous\n+///         calls and other operations such as run functions. The user may\n+///         pass in NULL if they do not wish to wait for any dependencies.\n+///         Only useful with _ACTION_ flags, otherwise there is no action\n+///         to wait on. All _MODE_ changes happen immediately.\n+///\n+/// @param  out_pCompletion\n+///         [out] An optional pointer to a COIEVENT object that will be\n+///         signaled when the operation is complete. The user may pass in\n+///         NULL if the user wants the operation to block until completed.\n+///         Note: This flag is not useful unless paired with a\n+///               valid _ACTION_ flag.\n+///\n+/// @return COI_SUCCESS if the cache was successfully adjusted. In case of\n+///         valid flags including _ACTION_, if out_pCompletion was specified,\n+///         this does not indicate the operation succeeded, but rather only\n+///         it was successfully queued. For further information see\n+///         that COIEventWait() for getting return values.\n+///\n+/// @return COI_INVALID_HANDLE if the in_Process handle passed in was invalid.\n+///\n+/// @return COI_RESOURCE_EXHAUSTED if no more cache can be created,\n+///         possibly, but not necessarily because a pool size was set to large\n+///         and COI_CACHE_ACTION_GROW_NOW was specified.\n+///\n+/// @return COI_NOT_SUPPORTED if more than one _MODE_ or _ACTION_ was\n+///         specified.\n+///\n+/// @return COI_NOT_SUPPORTED if an invalid _MODE_ or _ACTION_ was\n+///         specified.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if in_NumDependencies is non-zero while\n+///         in_pDependencies was passed in as NULL.\n+///\n+/// @return COI_OUT_OF_RANGE if one of the pool sizes was invalid.\n+///\n+/// @return COI_PROCESS_DIED if at some point during the mode or action the\n+///         remote process terminated abnormally. Possible due to an out of\n+///         memory condition.\n+///\n+COIACCESSAPI\n+COIRESULT COIProcessSetCacheSize(\n+    const   COIPROCESS          in_Process,\n+    const   uint64_t            in_HugePagePoolSize,\n+    const   uint32_t            in_HugeFlags,\n+    const   uint64_t            in_SmallPagePoolSize,\n+    const   uint32_t            in_SmallFlags,\n+            uint32_t            in_NumDependencies,\n+    const   COIEVENT*           in_pDependencies,\n+            COIEVENT*           out_pCompletion);\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+/// These are the different modes of operation that can be selected for\n+/// the COI_DMA_MODE by the API COIProcessConfigureDMA. They allow the user\n+/// to customize the DMA layer behaviour.\n+///\n+typedef enum COI_DMA_MODE\n+{\n+    /// This mode will use one common logical channel for all DMA operations.\n+    /// Using this mode requires a channel count of one.\n+    COI_DMA_MODE_SINGLE = 0,\n+\n+    /// This mode will dedicate on logical channel for write operations\n+    /// and one logical channel for read operations. Requires a minimum of\n+    /// two logical channels, if more than two are used they are ignored\n+    /// in the current implementation.\n+    COI_DMA_MODE_READ_WRITE,\n+\n+    /// This mode is not yet implemented and is a placeholder for future\n+    /// releases. Check here for updates when it is implemented.\n+    /// Will require a minimum of two logical channels and a maximum\n+    /// of four channels.\n+    COI_DMA_MODE_ROUND_ROBIN,\n+\n+    /// Reserved for internal use.\n+    COI_DMA_RESERVED\n+} COI_DMA_MODE;\n+\n+\n+//////////////////////////////////////////////////////////////////////////////\n+///\n+/// Set the number and mode of the physical DMA channels that each COIProcess\n+/// will establish during COIProcess creation.\n+///\n+/// By default the runtime will operate in COI_DMA_MODE_SINGLE mode.\n+/// This API is intended to be called before COIProcessCreateFromFile() or\n+/// COIProcessCreateFromMemory(). The values are stored globally and will\n+/// be used by the creation API's. It is possible to call this API once\n+/// before each new COIPROCESS is created and thus have each COIPROCESS\n+/// run in different modes. It is not possible to change the mode on an\n+/// existing COIPROCESS.\n+///\n+/// The larger number of logical connections requested will impose a\n+/// performance penalty on the COIBUFFER creation API's, but unlock better\n+/// parallelism for DMA transfers during runtime.\n+///\n+/// A maximum value of four (4) channels is available today, but current\n+/// implementation will only take advantage of two DMA channels. The option\n+/// is left available for programmers to use in case future implementations\n+/// provide performance advantages.\n+///\n+/// It is important to note that for some operations that enabling this\n+/// options may increase parallelism and require the user to enforce\n+/// explicit dependencies for operations on the same buffers. See documentation\n+/// for COIBufferRead/Write/Copy operations for more details.\n+///\n+/// @param  in_Channels\n+///         [in] Number of logical connections to the remote COIProcess that\n+///         the runtime will establish and use for DMA transfer requests.\n+///         Will be ignored if in_Mode is set to COI_DMA_MODE_SINGLE.\n+///\n+/// @param  in_Mode\n+///         [in] The mode of operation in which the runtime will use the\n+///         logical connections to the remote COIProcess.\n+///\n+/// @return COI_SUCCESS if the mode and number of DMA channels requested\n+///         is valid. The actual create creation of channels and modes is\n+///         done during COIProcessCreateFromFile() and\n+///         COIProcessCreateFromMemory().\n+///\n+/// @return COI_NOT_SUPPORTED if an invalid value for in_Channels or\n+///         in_Mode was requested.\n+///\n+/// @return COI_ARGUMENT_MISMATCH if an invalid combination of in_Channels and\n+///          in_Mode was requested. Example could be 2 channels with\n+///          COI_DMA_MODE_SINGLE, or 1 channel with COI_DMA_MODE_READ_WRITE.\n+///\n+COIACCESSAPI\n+COIRESULT COIProcessConfigureDMA(\n+    const   uint64_t            in_Channels,\n+    const   COI_DMA_MODE        in_Mode);\n+\n+\n #ifdef __cplusplus\n } /* extern \"C\" */\n #endif"}, {"sha": "f6f14015c258332d1c8950f519af70ec9e88f746", "filename": "liboffloadmic/include/myo/myo.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyo.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published"}, {"sha": "c5a1a41935ed34368279d7c8f1323d48d61874ec", "filename": "liboffloadmic/include/myo/myoimpl.h", "status": "modified", "additions": 95, "deletions": 14, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyoimpl.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -459,11 +459,37 @@ extern MyoError myoiTargetSharedMallocTableRegister(\n  *          return -1;\n  *      }\n  *      @endcode\n- *      This intialization is required only in the client/host side \n- *      of the application. The server/card side executable should be \n- *      executed only on the second card in this case.\n+ * This intialization is required only in the client/host side\n+ * of the application. The server/card side executable should be\n+ * executed only on the second card in this case.\n+ *\n+ * Another capability for the MyoiUserParams structure in MYO is specifying\n+ * a remote procedure call to be executed on the host or card, immediately after\n+ * myoiLibInit() completes. This capability is useful because some calls in\n+ * MYO return immediately, but do not actually complete until after the MYO\n+ * library is completely initialized on all peers.  An example follows,\n+ * showing how to cause MYO to execute the registered function named\n+ * \"PostMyoLibInitFunction\" on the first card only:\n+ *      @code\n+ *      MyoiUserParams UserParas[64];\n+ *      UserParas[0].type = MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n+ *      UserParas[0].nodeid = 1;\n+ *      SetPostLibInitFuncName(UserParas[1], \"PostMyoLibInitFunction\");\n+ *      UserParas[2].type = MYOI_USERPARAMS_LAST_MSG;\n+ *      if(MYO_SUCCESS != myoiLibInit(&UserParas, (void*)&myoiUserInit)) {\n+ *          printf(\"Failed to initialize MYO runtime\\n\");\n+ *          return -1;\n+ *      }\n+ *      @endcode\n+ *\n+ * Note, to cause PostMyoLibInitFunction to be executed on ALL cards,\n+ * specify: MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES for the nodeid.\n+ * That is:\n+ *      @code\n+ *      UserParas[0].nodeid = MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES;\n+ *      @endcode\n  *\n- * @param userInitFunc Shared variables and remote funtions are \n+ * @param userInitFunc Shared variables and remote functions are\n  * registered in this routine, which is called by the runtime during\n  * library initialization. \n  * @return\n@@ -473,6 +499,22 @@ extern MyoError myoiTargetSharedMallocTableRegister(\n MYOACCESSAPI\n MyoError myoiLibInit(void * in_args, void *userInitFunc /*userInitFunc must be: MyoError (*userInitFunc)(void) */);\n \n+/** @fn extern MyoError myoiSupportsFeature(MyoFeatureType myoFeature)\n+ * @brief Supports runtime query to determine whether a feature is supported\n+ * by the myo that is installed on the system. This function is intended to\n+ * support client code to query the myo library to determine whether its set\n+ * of capabilities are able to support the client's needs.\n+ *\n+ * @param myoFeature The feature that is to be inquired about.\n+ * @return\n+ *      MYO_SUCCESS; if the feature is supported.\n+ *      MYO_FEATURE_NOT_IMPLEMENTED if the feature is not supported.\n+ *\n+ * (For more information, please also see the declaration of the MyoFeatureType enum declaration.)\n+ **/\n+MYOACCESSAPI\n+MyoError myoiSupportsFeature(MyoFeatureType myoFeature);\n+\n /** @fn void myoiLibFini()\n  * @brief Finalize the MYO library, all resources held by the runtime are \n  * released by this routine.\n@@ -519,17 +561,56 @@ MyoError myoiSetMemConsistent(void *in_pAddr, size_t in_Size);\n EXTERN_C MYOACCESSAPI unsigned int myoiMyId; /* MYO_MYID if on accelerators */\n EXTERN_C MYOACCESSAPI volatile int myoiInitFlag;\n \n-\n- //! Structure of the array element that is passed to myoiLibInit() to initialize a subset of the available cards.\n-typedef struct{\n-    //!type = MYOI_USERPARAMS_DEVID for each element in the array except the last element ; type = MYOI_USERPARAMS_LAST_MSG for the last element in the array.\n+ //! Structure of the array element that is passed to myoiLibInit() to initialize a subset of the available cards, or\n+ //! to specify a remote call function to be called after successful myo library initialization:\n+typedef struct {\n+    //!type = MYOI_USERPARAMS_DEVID or  MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC for each element in the array except\n+    //!the last element, type should be: MYOI_USERPARAMS_LAST_MSG.\n     int type;\n-    //!nodeid refers to the card index.\n+    //! nodeid refers to the 'one-based' card index.  Specifying, 1 represents the first card, mic0, 2 represents the\n+    // second card, mic1, 3 represents the third card, mic2, ....).\n+    // NOTE: for type == MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC, specifying MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES\n+    // for nodeid, will execute the named function, on each card in the system, mic0, mic1, mic2, .... micn.\n     int nodeid;\n-}MyoiUserParams;\n-\n-#define MYOI_USERPARAMS_DEVID    1\n-#define MYOI_USERPARAMS_LAST_MSG  -1\n+} MyoiUserParams;\n+\n+//!The following two types are dealt with entirely with just one MyoiUserParams structure:\n+//!MYOI_USERPARAMS_DEVID maps node ids.\n+#define MYOI_USERPARAMS_DEVID                             1\n+//!MYOI_USERPARAMS_LAST_MSG terminates the array of MyoiUserParams.\n+#define MYOI_USERPARAMS_LAST_MSG                         -1\n+\n+//!The following type requires setting the node id in a MyoiUserParams structure, and then following the struct\n+//!with a MyoiUserParamsPostLibInit union:\n+#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC            2\n+//!nodeid can be one of the following macros, or a number >=1, corresponding to the card number (1 == mic0,\n+//!2 == mic1, 3 == mic2, ....)\n+//!Setting nodeid to MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES causes the function to be called on all\n+//!cards:\n+#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES  0\n+//!Setting nodeid to MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE causes the function to be called on the\n+//!host instead of the card:\n+#define MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE -1\n+\n+//!The postLibInit union contains two members that serves two different purposes:\n+//!1. It can be used to stipulate the name of the function to be remotely called from host to card, on successful\n+//!myo library initialization, (member postLibInitRemoveFuncName) using the type:\n+//!MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC.   OR\n+//!2. It can be an actual function pointer (member name: postLibInitHostFuncAddress) that will be called on the host,\n+//!on successful myo library initialization, using the type: MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC, with nodeid:\n+//!MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE\n+typedef union {\n+   const char *postLibInitRemoveFuncName;\n+   void (*postLibInitHostFuncAddress)(void);\n+} MyoiUserParamsPostLibInit;\n+\n+/* These are two macros to help get the information in a MyoiUserParamsPostLibInit union from a MyoiUserParams struct; */\n+#define GetPostLibInitFuncName(USERPARAMS) ((MyoiUserParamsPostLibInit *) (& (USERPARAMS)))->postLibInitRemoveFuncName\n+#define GetPostLibInitFuncAddr(USERPARAMS) ((MyoiUserParamsPostLibInit *) (& (USERPARAMS)))->postLibInitHostFuncAddress\n+\n+/* These are two macros to help set the information in a MyoiUserParamsPostLibInit union from a MyoiUserParams struct; */\n+#define SetPostLibInitFuncName(USERPARAMS,FUNC_NAME) GetPostLibInitFuncName(USERPARAMS) = FUNC_NAME\n+#define SetPostLibInitFuncAddr(USERPARAMS,FUNC_ADDR) GetPostLibInitFuncAddr(USERPARAMS) = FUNC_ADDR\n \n #ifdef __cplusplus\n }"}, {"sha": "596ad05280cbc6c20580491586ee7272ae4fd4de", "filename": "liboffloadmic/include/myo/myotypes.h", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Finclude%2Fmyo%2Fmyotypes.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -74,7 +74,8 @@ typedef enum {\n \n     MYO_ALREADY_EXISTS,   /*!< Already Exists */\n \n-    MYO_EOF,               /*!< EOF */\n+    MYO_EOF,              /*!< EOF */\n+    MYO_FEATURE_NOT_IMPLEMENTED = -1,  /*!< Feature not implemented (see myoiSupportsFeature(). */\n } MyoError;\n \n \n@@ -84,6 +85,40 @@ typedef enum {\n     MYO_ARENA_OURS,     /*!< Arena OURS Ownership */\n } MyoOwnershipType;\n \n+  /*! MYO Features */\n+typedef enum {\n+                                                         /*!< EVERY VALUE that is less than MYO_FEATURE_BEGIN is not implemented.       */\n+  MYO_FEATURE_BEGIN         = 1,                         /*!< The first feature that is supported.                                      */\n+  MYO_FEATURE_POST_LIB_INIT = MYO_FEATURE_BEGIN,         /*!< Allows specifying a function to be executed immediately                   */\n+                                                         /*   after myoiLibInit() completes. This feature was implemented in version    */\n+                                                         /*     3.3 of MPSS.                                                            */\n+  /* MYO_FEATURE_FUTURE_CAPABILITY     = 2,   at some time in the future, as new features are added to MYO, new enumeration constants   */\n+  /*                                 will be added to the MyoFeatureType, and the value of the new enumeration constant will be greater */\n+  /*                                 than the current value of MYO_FEATURE_LAST constant, and then the MYO_FEATURE_LAST constant too,   */\n+  /*                                 will be changed to be the value of the new enumeration constant.  For example, in April, 2014,     */\n+  /*                                 the POST_LIB_INIT feature was implemented in version 3.3 of MPSS, and the MYO_FEATURE_BEGIN        */\n+  /*                                 enumeration constant is the same as the MYO_FEATURE_LAST enumeration constant, and both are equal  */\n+  /*                                 to 1.                                                                                              */\n+  /*                                 Suppose in December, 2014, a new feature is added to the MYO library, for version 3.4 of MPSS.     */\n+  /*                                 Then, MYO_FEATURE_BEGIN enumeration constant will be still the value 1, but the MYO_FEATURE_LAST   */\n+  /*                                 enumeration constant will be set to 2.                                                             */\n+  /*                                 At runtime, one client binary can determine if the MYO that is installed is capable of any         */\n+  /*                                 capability.  For example, suppose a future client binary queries version 3.3 of MYO if it is       */\n+  /*                                 capable of some future feature.  Version 3.3 of MYO will indicate that the feature is not          */\n+  /*                                 implemented to the client.  But, conversely, suppose the future client queries version 3.4 of MYO  */\n+  /*                                 if it is capable of some future feature.  Version 3.4 of MYO will indicate that the feature isd    */\n+  /*                                 supported.                                                                                         */\n+  /*                                                                                                                                    */\n+  /*   Date:        |  MYO_FEATURE_BEGIN: |  MYO_FEATURE_LAST: | MPSS VERSION: | myoiSupportsFeature(MYO_FEATURE_FUTURE_CAPABILITY)     */\n+  /* ---------------+---------------------+--------------------+---------------+---------------------------------------------------     */\n+  /* April, 2014    |         1           |         1          |     3.3       | MYO_FEATURE_NOT_IMPLEMENTED                            */\n+  /* December, 2014 |         1           |         2          |     3.4       | MYO_SUCCESS                                            */\n+  /* ---------------+---------------------+--------------------+---------------+---------------------------------------------------     */\n+  MYO_FEATURE_LAST          = MYO_FEATURE_POST_LIB_INIT, /*!< The last feature that is supported.                                       */\n+                                                         /*!< EVERY VALUE that is greater than MYO_FEATURE_LAST is not implemented.     */\n+  /*!< EVERY VALUE that is greater than or equal to MYO_FEATURE_BEGIN AND less than or equal to MYO_FEATURE_LAST is implemented.        */\n+} MyoFeatureType;  /* (For more information, please also see myoiSupportsFeature() function declaration.)  */\n+\n /*************************************************************\n  *  define the property of MYO Arena \n  ***********************************************************/"}, {"sha": "9ff8c9a06bec13d0e28e7fd1be41e35256c211c2", "filename": "liboffloadmic/plugin/Makefile.am", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fplugin%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fplugin%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.am?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -35,7 +35,6 @@ ACLOCAL_AMFLAGS = -I ../.. -I ../../config\n build_dir = $(top_builddir)\n source_dir = $(top_srcdir)\n coi_inc_dir = $(top_srcdir)/../include/coi\n-myo_inc_dir = $(top_srcdir)/../include/myo\n include_src_dir = $(top_srcdir)/../../include\n libgomp_src_dir = $(top_srcdir)/../../libgomp\n libgomp_dir = $(build_dir)/../../libgomp\n@@ -53,12 +52,12 @@ target_install_dir = $(accel_search_dir)/lib/gcc/$(accel_target)/$(gcc_version)$\n if PLUGIN_HOST\n   toolexeclib_LTLIBRARIES = libgomp-plugin-intelmic.la\n   libgomp_plugin_intelmic_la_SOURCES = libgomp-plugin-intelmic.cpp\n-  libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n+  libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n   libgomp_plugin_intelmic_la_LDFLAGS = -L$(liboffload_dir)/.libs -loffloadmic_host -version-info 1:0:0\n else # PLUGIN_TARGET\n   plugin_includedir = $(libsubincludedir)\n   plugin_include_HEADERS = main_target_image.h\n-  AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n+  AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n   AM_CXXFLAGS = $(CXXFLAGS)\n   AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lmyo-service -lgomp -rdynamic\n endif"}, {"sha": "7d60476f70f96a812169d1b25a4e92514ff0eeec", "filename": "liboffloadmic/plugin/Makefile.in", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fplugin%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fplugin%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2FMakefile.in?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -305,7 +305,6 @@ ACLOCAL_AMFLAGS = -I ../.. -I ../../config\n build_dir = $(top_builddir)\n source_dir = $(top_srcdir)\n coi_inc_dir = $(top_srcdir)/../include/coi\n-myo_inc_dir = $(top_srcdir)/../include/myo\n include_src_dir = $(top_srcdir)/../../include\n libgomp_src_dir = $(top_srcdir)/../../libgomp\n libgomp_dir = $(build_dir)/../../libgomp\n@@ -321,11 +320,11 @@ target_build_dir = $(accel_search_dir)/$(accel_target)$(MULTISUBDIR)/liboffloadm\n target_install_dir = $(accel_search_dir)/lib/gcc/$(accel_target)/$(gcc_version)$(MULTISUBDIR)\n @PLUGIN_HOST_TRUE@toolexeclib_LTLIBRARIES = libgomp-plugin-intelmic.la\n @PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_SOURCES = libgomp-plugin-intelmic.cpp\n-@PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n+@PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=1 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_src_dir) -I$(libgomp_dir) -I$(include_src_dir) -I$(target_prefix_dir)/include -I$(target_build_dir) -I$(target_install_dir)/include\n @PLUGIN_HOST_TRUE@libgomp_plugin_intelmic_la_LDFLAGS = -L$(liboffload_dir)/.libs -loffloadmic_host -version-info 1:0:0\n @PLUGIN_HOST_FALSE@plugin_includedir = $(libsubincludedir)\n @PLUGIN_HOST_FALSE@plugin_include_HEADERS = main_target_image.h\n-@PLUGIN_HOST_FALSE@AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DMYO_SUPPORT -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(myo_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n+@PLUGIN_HOST_FALSE@AM_CPPFLAGS = $(CPPFLAGS) -DLINUX -DCOI_LIBRARY_VERSION=2 -DOFFLOAD_DEBUG=1 -DSEP_SUPPORT -DTIMING_SUPPORT -DHOST_LIBRARY=0 -I$(coi_inc_dir) -I$(liboffload_src_dir) -I$(libgomp_dir)\n @PLUGIN_HOST_FALSE@AM_CXXFLAGS = $(CXXFLAGS)\n @PLUGIN_HOST_FALSE@AM_LDFLAGS = -L$(liboffload_dir)/.libs -L$(libgomp_dir)/.libs -loffloadmic_target -lcoi_device -lmyo-service -lgomp -rdynamic\n "}, {"sha": "88bfa0d735f713d05510d0ea278bdd9e5f848190", "filename": "liboffloadmic/runtime/cean_util.cpp", "status": "modified", "additions": 65, "deletions": 33, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcean_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcean_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -34,7 +34,7 @@\n // 1. allocate element of CeanReadRanges type\n // 2. initialized it for reading consequently contiguous ranges\n //    described by \"ap\" argument\n-CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap)\n+CeanReadRanges * init_read_ranges_arr_desc(const Arr_Desc *ap)\n {\n     CeanReadRanges * res;\n \n@@ -57,6 +57,8 @@ CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap)\n                                   (ap->rank - rank) * sizeof(CeanReadDim));\n     if (res == NULL)\n       LIBOFFLOAD_ERROR(c_malloc);\n+\n+    res->arr_desc = const_cast<Arr_Desc*>(ap);\n     res->current_number = 0;\n     res->range_size = length;\n     res->last_noncont_ind = rank;\n@@ -82,7 +84,7 @@ CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap)\n     return res;\n }\n \n-// check if ranges described by 1 argument could be transfered into ranges\n+// check if ranges described by 1 argument could be transferred into ranges\n // described by 2-nd one\n bool cean_ranges_match(\n     CeanReadRanges * read_rng1,\n@@ -118,7 +120,7 @@ bool get_next_range(\n     return true;\n }\n \n-bool is_arr_desc_contiguous(const arr_desc *ap)\n+bool is_arr_desc_contiguous(const Arr_Desc *ap)\n {\n     int64_t rank = ap->rank - 1;\n     int64_t length = ap->dim[rank].size;\n@@ -146,14 +148,22 @@ int64_t cean_get_transf_size(CeanReadRanges * read_rng)\n }\n \n static uint64_t last_left, last_right;\n-typedef void (*fpp)(const char *spaces, uint64_t low, uint64_t high, int esize);\n+\n+typedef void (*fpp)(\n+    const char *spaces,\n+    uint64_t low,\n+    uint64_t high,\n+    int esize,\n+    bool print_values\n+);\n \n static void generate_one_range(\n     const char *spaces,\n     uint64_t lrange,\n     uint64_t rrange,\n     fpp fp,\n-    int esize\n+    int esize,\n+    bool print_values\n )\n {\n     OFFLOAD_TRACE(3,\n@@ -168,20 +178,35 @@ static void generate_one_range(\n             // Extend previous range, don't print\n         }\n         else {\n-            (*fp)(spaces, last_left, last_right, esize);\n+            (*fp)(spaces, last_left, last_right, esize, print_values);\n             last_left = lrange;\n         }\n     }\n     last_right = rrange;\n }\n \n+static bool element_is_contiguous(\n+    uint64_t rank,\n+    const struct Dim_Desc *ddp\n+)\n+{    \n+    if (rank == 1) {\n+        return (ddp[0].lower == ddp[0].upper || ddp[0].stride == 1);\n+    }\n+    else {\n+        return ((ddp[0].size == (ddp[1].upper-ddp[1].lower+1)*ddp[1].size) &&\n+                 element_is_contiguous(rank-1, ddp++));\n+    }\n+}\n+\n static void generate_mem_ranges_one_rank(\n     const char *spaces,\n     uint64_t base,\n     uint64_t rank,\n-    const struct dim_desc *ddp,\n+    const struct Dim_Desc *ddp,\n     fpp fp,\n-    int esize\n+    int esize,\n+    bool print_values\n )\n {\n     uint64_t lindex = ddp->lindex;\n@@ -194,35 +219,40 @@ static void generate_mem_ranges_one_rank(\n         \"generate_mem_ranges_one_rank(base=%p, rank=%lld, lindex=%lld, \"\n         \"lower=%lld, upper=%lld, stride=%lld, size=%lld, esize=%d)\\n\",\n         spaces, (void*)base, rank, lindex, lower, upper, stride, size, esize);\n-    if (rank == 1) {\n+\n+    if (element_is_contiguous(rank, ddp)) {\n         uint64_t lrange, rrange;\n-        if (stride == 1) {\n-            lrange = base + (lower-lindex)*size;\n-            rrange = lrange + (upper-lower+1)*size - 1;\n-            generate_one_range(spaces, lrange, rrange, fp, esize);\n-        }\n-        else {\n+        lrange = base + (lower-lindex)*size;\n+        rrange = lrange + (upper-lower+1)*size - 1;\n+        generate_one_range(spaces, lrange, rrange, fp, esize, print_values);\n+    }\n+    else {\n+        if (rank == 1) {\n             for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n+                uint64_t lrange, rrange;\n                 lrange = base + i*size;\n                 rrange = lrange + size - 1;\n-                generate_one_range(spaces, lrange, rrange, fp, esize);\n+                generate_one_range(spaces, lrange, rrange,\n+\t\t                   fp, esize, print_values);\n             }\n         }\n-    }\n-    else {\n-        for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n-            generate_mem_ranges_one_rank(\n-                spaces, base+i*size, rank-1, ddp+1, fp, esize);\n+        else {\n+            for (int i=lower-lindex; i<=upper-lindex; i+=stride) {\n+                generate_mem_ranges_one_rank(\n+                    spaces, base+i*size, rank-1, ddp+1,\n+                    fp, esize, print_values);\n \n+            }\n         }\n     }\n }\n \n static void generate_mem_ranges(\n     const char *spaces,\n-    const arr_desc *adp,\n+    const Arr_Desc *adp,\n     bool deref,\n-    fpp fp\n+    fpp fp,\n+    bool print_values\n )\n {\n     uint64_t esize;\n@@ -241,13 +271,13 @@ static void generate_mem_ranges(\n         // For c_cean_var the base addr is the address of the data\n         // For c_cean_var_ptr the base addr is dereferenced to get to the data\n         spaces, deref ? *((uint64_t*)(adp->base)) : adp->base,\n-        adp->rank, &adp->dim[0], fp, esize);\n-    (*fp)(spaces, last_left, last_right, esize);\n+        adp->rank, &adp->dim[0], fp, esize, print_values);\n+    (*fp)(spaces, last_left, last_right, esize, print_values);\n }\n \n // returns offset and length of the data to be transferred\n void __arr_data_offset_and_length(\n-    const arr_desc *adp,\n+    const Arr_Desc *adp,\n     int64_t &offset,\n     int64_t &length\n )\n@@ -284,11 +314,12 @@ void __arr_data_offset_and_length(\n \n #if OFFLOAD_DEBUG > 0\n \n-void print_range(\n+static void print_range(\n     const char *spaces,\n     uint64_t low,\n     uint64_t high,\n-    int esize\n+    int esize,\n+    bool print_values\n )\n {\n     char buffer[1024];\n@@ -297,7 +328,7 @@ void print_range(\n     OFFLOAD_TRACE(3, \"%s        print_range(low=%p, high=%p, esize=%d)\\n\",\n         spaces, (void*)low, (void*)high, esize);\n \n-    if (console_enabled < 4) {\n+    if (console_enabled < 4 || !print_values) {\n         return;\n     }\n     OFFLOAD_TRACE(4, \"%s            values:\\n\", spaces);\n@@ -340,8 +371,9 @@ void print_range(\n void __arr_desc_dump(\n     const char *spaces,\n     const char *name,\n-    const arr_desc *adp,\n-    bool deref\n+    const Arr_Desc *adp,\n+    bool deref,\n+    bool print_values\n )\n {\n     OFFLOAD_TRACE(2, \"%s%s CEAN expression %p\\n\", spaces, name, adp);\n@@ -360,7 +392,7 @@ void __arr_desc_dump(\n         }\n         // For c_cean_var the base addr is the address of the data\n         // For c_cean_var_ptr the base addr is dereferenced to get to the data\n-        generate_mem_ranges(spaces, adp, deref, &print_range);\n+        generate_mem_ranges(spaces, adp, deref, &print_range, print_values);\n     }\n }\n #endif // OFFLOAD_DEBUG"}, {"sha": "8b7c437673907f11a943ca9bae0bda69e9a0178b", "filename": "liboffloadmic/runtime/cean_util.h", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcean_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcean_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcean_util.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -32,20 +32,21 @@\n #define CEAN_UTIL_H_INCLUDED\n \n #include <stdint.h>\n+#include \"offload_util.h\"\n \n // CEAN expression representation\n-struct dim_desc {\n+struct Dim_Desc {\n     int64_t size;       // Length of data type\n     int64_t lindex;     // Lower index\n     int64_t lower;      // Lower section bound\n     int64_t upper;      // Upper section bound\n     int64_t stride;     // Stride\n };\n \n-struct arr_desc {\n+struct Arr_Desc {\n     int64_t base;       // Base address\n     int64_t rank;       // Rank of array\n-    dim_desc dim[1];\n+    Dim_Desc dim[1];\n };\n \n struct CeanReadDim {\n@@ -55,6 +56,7 @@ struct CeanReadDim {\n };\n \n struct CeanReadRanges {\n+    Arr_Desc* arr_desc;\n     void *  ptr;\n     int64_t current_number;   // the number of ranges read\n     int64_t range_max_number; // number of contiguous ranges\n@@ -66,51 +68,51 @@ struct CeanReadRanges {\n \n // array descriptor length\n #define __arr_desc_length(rank) \\\n-    (sizeof(int64_t) + sizeof(dim_desc) * (rank))\n+    (sizeof(int64_t) + sizeof(Dim_Desc) * (rank))\n \n // returns offset and length of the data to be transferred\n-void __arr_data_offset_and_length(const arr_desc *adp,\n+DLL_LOCAL void __arr_data_offset_and_length(const Arr_Desc *adp,\n                                   int64_t &offset,\n                                   int64_t &length);\n \n // define if data array described by argument is contiguous one\n-bool is_arr_desc_contiguous(const arr_desc *ap);\n+DLL_LOCAL bool is_arr_desc_contiguous(const Arr_Desc *ap);\n \n // allocate element of CeanReadRanges type initialized\n // to read consequently contiguous ranges described by \"ap\" argument\n-CeanReadRanges * init_read_ranges_arr_desc(const arr_desc *ap);\n+DLL_LOCAL CeanReadRanges * init_read_ranges_arr_desc(const Arr_Desc *ap);\n \n-// check if ranges described by 1 argument could be transfered into ranges\n+// check if ranges described by 1 argument could be transferred into ranges\n // described by 2-nd one\n-bool cean_ranges_match(\n+DLL_LOCAL bool cean_ranges_match(\n     CeanReadRanges * read_rng1,\n     CeanReadRanges * read_rng2\n );\n \n // first argument - returned value by call to init_read_ranges_arr_desc.\n // returns true if offset and length of next range is set successfuly.\n // returns false if the ranges is over.\n-bool get_next_range(\n+DLL_LOCAL bool get_next_range(\n     CeanReadRanges * read_rng,\n     int64_t *offset\n );\n \n-// returns number of transfered bytes\n-int64_t cean_get_transf_size(CeanReadRanges * read_rng);\n+// returns number of transferred bytes\n+DLL_LOCAL int64_t cean_get_transf_size(CeanReadRanges * read_rng);\n \n #if OFFLOAD_DEBUG > 0\n // prints array descriptor contents to stderr\n-void    __arr_desc_dump(\n+DLL_LOCAL void    __arr_desc_dump(\n     const char *spaces,\n     const char *name,\n-    const arr_desc *adp,\n-    bool dereference);\n+    const Arr_Desc *adp,\n+    bool dereference,\n+    bool print_values);\n+#define ARRAY_DESC_DUMP(spaces, name, adp, dereference, print_values) \\\n+    if (console_enabled >= 2) \\\n+        __arr_desc_dump(spaces, name, adp, dereference, print_values);\n #else\n-#define __arr_desc_dump(\n-    spaces,\n-    name,\n-    adp,\n-    dereference)\n+#define ARRAY_DESC_DUMP(spaces, name, adp, dereference, print_values)\n #endif // OFFLOAD_DEBUG\n \n #endif // CEAN_UTIL_H_INCLUDED"}, {"sha": "ca18e5f95250e9f44371f0a5df4e4f9dda4ee5e8", "filename": "liboffloadmic/runtime/coi/coi_client.cpp", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -50,13 +50,22 @@ COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*, const void*,\n                                      const char**, uint8_t, const char*,\n                                      uint64_t, const char*, const char*,\n                                      uint64_t, COIPROCESS*);\n+COIRESULT (*ProcessCreateFromFile)(COIENGINE, const char*,\n+                                     int, const char**, uint8_t,\n+                                     const char**, uint8_t, const char*,\n+                                     uint64_t, const char*,COIPROCESS*);\n+COIRESULT (*ProcessSetCacheSize)(COIPROCESS, uint64_t, uint32_t,\n+                                 uint64_t, uint32_t, uint32_t,\n+                                 const COIEVENT*, COIEVENT*);\n COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t, int8_t*, uint32_t*);\n COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t, const char**,\n                                        COIFUNCTION*);\n COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS, const void*, uint64_t,\n                                           const char*, const char*,\n                                           const char*, uint64_t, uint32_t,\n                                           COILIBRARY*);\n+COIRESULT (*ProcessUnloadLibrary)(COIPROCESS,\n+                                  COILIBRARY);\n COIRESULT (*ProcessRegisterLibraries)(uint32_t, const void**, const uint64_t*,\n                                       const char**, const uint64_t*);\n \n@@ -80,6 +89,13 @@ COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*, uint64_t,\n                          COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t, COI_COPY_TYPE,\n                         uint32_t, const COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferReadMultiD)(COIBUFFER, uint64_t,\n+                        void *, void *, COI_COPY_TYPE,\n+                        uint32_t, const   COIEVENT*, COIEVENT*);\n+COIRESULT (*BufferWriteMultiD)(COIBUFFER, const   COIPROCESS,\n+                       uint64_t, void *, void *,\n+                       COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*);\n+\n COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n                         COI_COPY_TYPE, uint32_t, const COIEVENT*, COIEVENT*);\n COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n@@ -92,6 +108,20 @@ COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t, uint8_t, uint32_t*,\n \n uint64_t  (*PerfGetCycleFrequency)(void);\n \n+COIRESULT (*PipelineClearCPUMask) (COI_CPU_MASK);\n+\n+COIRESULT (*PipelineSetCPUMask) (COIPROCESS, uint32_t,\n+                                        uint8_t, COI_CPU_MASK);\n+COIRESULT (*EngineGetInfo)(COIENGINE, uint32_t, COI_ENGINE_INFO*);\n+\n+COIRESULT (*EventRegisterCallback)(\n+    const COIEVENT,\n+    void (*)(COIEVENT, const COIRESULT, const void*),\n+    const void*,\n+    const uint64_t);\n+\n+COIRESULT (*ProcessConfigureDMA)(const uint64_t, const int);\n+\n bool init(void)\n {\n #ifndef TARGET_WINNT\n@@ -140,6 +170,32 @@ bool init(void)\n         return false;\n     }\n \n+    ProcessSetCacheSize =\n+           (COIRESULT (*)(COIPROCESS, uint64_t, uint32_t,\n+                                 uint64_t, uint32_t, uint32_t,\n+                                 const COIEVENT*, COIEVENT*))\n+               DL_sym(lib_handle, \"COIProcessSetCacheSize\", COI_VERSION1);\n+    if (ProcessSetCacheSize == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessSetCacheSize\");\n+#if 0  // for now disable as ProcessSetCacheSize is not available on < MPSS 3.4\n+        fini();\n+        return false;\n+#endif\n+    }\n+\n+    ProcessCreateFromFile =\n+           (COIRESULT (*)(COIENGINE, const char*, int, const char**, uint8_t,\n+                          const char**, uint8_t, const char*, uint64_t,\n+                          const char*, COIPROCESS*))\n+            DL_sym(lib_handle, \"COIProcessCreateFromFile\", COI_VERSION1);\n+    if (ProcessCreateFromFile == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessCreateFromFile\");\n+        fini();\n+        return false;\n+    }\n+\n     ProcessDestroy =\n         (COIRESULT (*)(COIPROCESS, int32_t, uint8_t, int8_t*,\n                        uint32_t*))\n@@ -173,6 +229,17 @@ bool init(void)\n         return false;\n     }\n \n+    ProcessUnloadLibrary =\n+        (COIRESULT (*)(COIPROCESS,\n+                       COILIBRARY))\n+            DL_sym(lib_handle, \"COIProcessUnloadLibrary\", COI_VERSION1);\n+    if (ProcessUnloadLibrary == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIProcessUnloadLibrary\");\n+        fini();\n+        return false;\n+    }\n+\n     ProcessRegisterLibraries =\n         (COIRESULT (*)(uint32_t, const void**, const uint64_t*, const char**,\n                        const uint64_t*))\n@@ -295,6 +362,22 @@ bool init(void)\n         return false;\n     }\n \n+    BufferReadMultiD =\n+        (COIRESULT (*)(COIBUFFER, uint64_t,\n+                       void *, void *, COI_COPY_TYPE,\n+                       uint32_t, const   COIEVENT*, COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferReadMultiD\", COI_VERSION1);\n+    // We  accept that coi library has no COIBufferReadMultiD routine.\n+    // So there is no check for zero value\n+\n+    BufferWriteMultiD =\n+        (COIRESULT (*)(COIBUFFER, const   COIPROCESS,\n+                       uint64_t, void *, void *,\n+                       COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*))\n+            DL_sym(lib_handle, \"COIBufferWriteMultiD\", COI_VERSION1);\n+    // We  accept that coi library has no COIBufferWriteMultiD routine.\n+    // So there is no check for zero value\n+\n     BufferCopy =\n         (COIRESULT (*)(COIBUFFER, COIBUFFER, uint64_t, uint64_t, uint64_t,\n                        COI_COPY_TYPE, uint32_t, const COIEVENT*,\n@@ -350,6 +433,47 @@ bool init(void)\n         return false;\n     }\n \n+    PipelineClearCPUMask =\n+        (COIRESULT (*)(COI_CPU_MASK))\n+            DL_sym(lib_handle, \"COIPipelineClearCPUMask\", COI_VERSION1);\n+    if (PipelineClearCPUMask == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPipelineClearCPUMask\");\n+        fini();\n+        return false;\n+    }\n+\n+    PipelineSetCPUMask =\n+        (COIRESULT (*)(COIPROCESS, uint32_t,uint8_t, COI_CPU_MASK))\n+            DL_sym(lib_handle, \"COIPipelineSetCPUMask\", COI_VERSION1);\n+    if (PipelineSetCPUMask == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIPipelineSetCPUMask\");\n+        fini();\n+        return false;\n+    }\n+\n+    EngineGetInfo =\n+        (COIRESULT (*)(COIENGINE, uint32_t, COI_ENGINE_INFO*))\n+            DL_sym(lib_handle, \"COIEngineGetInfo\", COI_VERSION1);\n+    if (COIEngineGetInfo == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in COI library\\n\",\n+                            \"COIEngineGetInfo\");\n+        fini();\n+        return false;\n+    }\n+    \n+    EventRegisterCallback =\n+        (COIRESULT (*)(COIEVENT,\n+         void (*)(COIEVENT, const COIRESULT, const void*),\n+         const void*,\n+         const uint64_t))\n+            DL_sym(lib_handle, \"COIEventRegisterCallback\", COI_VERSION1);\n+\n+    ProcessConfigureDMA =\n+        (COIRESULT (*)(const uint64_t, const int))\n+            DL_sym(lib_handle, \"COIProcessConfigureDMA\", COI_VERSION1);\n+    \n     is_available = true;\n \n     return true;"}, {"sha": "9c91077aac6fcc2c6c84c35726261ae2a8eec528", "filename": "liboffloadmic/runtime/coi/coi_client.h", "status": "modified", "additions": 64, "deletions": 27, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_client.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -28,7 +28,7 @@\n */\n \n \n-// The interface betwen offload library and the COI API on the host\n+// The interface between offload library and the COI API on the host\n \n #ifndef COI_CLIENT_H_INCLUDED\n #define COI_CLIENT_H_INCLUDED\n@@ -54,29 +54,40 @@\n // COI library interface\n namespace COI {\n \n-extern bool init(void);\n-extern void fini(void);\n+DLL_LOCAL extern bool init(void);\n+DLL_LOCAL extern void fini(void);\n \n-extern bool is_available;\n+DLL_LOCAL extern bool is_available;\n \n // pointers to functions from COI library\n-extern COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n-extern COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n+DLL_LOCAL extern COIRESULT (*EngineGetCount)(COI_ISA_TYPE, uint32_t*);\n+DLL_LOCAL extern COIRESULT (*EngineGetHandle)(COI_ISA_TYPE, uint32_t, COIENGINE*);\n \n-extern COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*,\n+DLL_LOCAL extern COIRESULT (*ProcessCreateFromMemory)(COIENGINE, const char*,\n                                            const void*, uint64_t, int,\n                                            const char**, uint8_t,\n                                            const char**, uint8_t,\n                                            const char*, uint64_t,\n                                            const char*,\n                                            const char*, uint64_t,\n                                            COIPROCESS*);\n-extern COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t,\n+DLL_LOCAL extern COIRESULT (*ProcessCreateFromFile)(COIENGINE, const char*, int,\n+                                          const char**, uint8_t,\n+                                          const char**,\n+                                          uint8_t,\n+                                          const char*,\n+                                          uint64_t,\n+                                          const char*,\n+                                          COIPROCESS*);\n+DLL_LOCAL extern COIRESULT (*ProcessSetCacheSize)(COIPROCESS, uint64_t, uint32_t,\n+                                                uint64_t, uint32_t, uint32_t,\n+                                                const COIEVENT*, COIEVENT*);\n+DLL_LOCAL extern COIRESULT (*ProcessDestroy)(COIPROCESS, int32_t, uint8_t,\n                                   int8_t*, uint32_t*);\n-extern COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t,\n+DLL_LOCAL extern COIRESULT (*ProcessGetFunctionHandles)(COIPROCESS, uint32_t,\n                                              const char**,\n                                              COIFUNCTION*);\n-extern COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS,\n+DLL_LOCAL extern COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS,\n                                                 const void*,\n                                                 uint64_t,\n                                                 const char*,\n@@ -85,54 +96,80 @@ extern COIRESULT (*ProcessLoadLibraryFromMemory)(COIPROCESS,\n                                                 uint64_t,\n                                                 uint32_t,\n                                                 COILIBRARY*);\n-extern COIRESULT (*ProcessRegisterLibraries)(uint32_t,\n+\n+DLL_LOCAL extern COIRESULT (*ProcessUnloadLibrary)(COIPROCESS,\n+                                                COILIBRARY);\n+\n+DLL_LOCAL extern COIRESULT (*ProcessRegisterLibraries)(uint32_t,\n                                             const void**,\n                                             const uint64_t*,\n                                             const char**,\n                                             const uint64_t*);\n \n-extern COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t,\n+DLL_LOCAL extern COIRESULT (*PipelineCreate)(COIPROCESS, COI_CPU_MASK, uint32_t,\n                                   COIPIPELINE*);\n-extern COIRESULT (*PipelineDestroy)(COIPIPELINE);\n-extern COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION,\n+DLL_LOCAL extern COIRESULT (*PipelineDestroy)(COIPIPELINE);\n+DLL_LOCAL extern COIRESULT (*PipelineRunFunction)(COIPIPELINE, COIFUNCTION,\n                                        uint32_t, const COIBUFFER*,\n                                        const COI_ACCESS_FLAGS*,\n                                        uint32_t, const COIEVENT*,\n                                        const void*, uint16_t, void*,\n                                        uint16_t, COIEVENT*);\n \n-extern COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n+DLL_LOCAL extern COIRESULT (*BufferCreate)(uint64_t, COI_BUFFER_TYPE, uint32_t,\n                                 const void*, uint32_t,\n                                 const COIPROCESS*, COIBUFFER*);\n-extern COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE,\n+DLL_LOCAL extern COIRESULT (*BufferCreateFromMemory)(uint64_t, COI_BUFFER_TYPE,\n                                           uint32_t, void*,\n                                           uint32_t, const COIPROCESS*,\n                                           COIBUFFER*);\n-extern COIRESULT (*BufferDestroy)(COIBUFFER);\n-extern COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t,\n+DLL_LOCAL extern COIRESULT (*BufferDestroy)(COIBUFFER);\n+DLL_LOCAL extern COIRESULT (*BufferMap)(COIBUFFER, uint64_t, uint64_t,\n                              COI_MAP_TYPE, uint32_t, const COIEVENT*,\n                              COIEVENT*, COIMAPINSTANCE*, void**);\n-extern COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t,\n+DLL_LOCAL extern COIRESULT (*BufferUnmap)(COIMAPINSTANCE, uint32_t,\n                                const COIEVENT*, COIEVENT*);\n-extern COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*,\n+DLL_LOCAL extern COIRESULT (*BufferWrite)(COIBUFFER, uint64_t, const void*,\n                                uint64_t, COI_COPY_TYPE, uint32_t,\n                                const COIEVENT*, COIEVENT*);\n-extern COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t,\n+DLL_LOCAL extern COIRESULT (*BufferRead)(COIBUFFER, uint64_t, void*, uint64_t,\n                               COI_COPY_TYPE, uint32_t,\n                               const COIEVENT*, COIEVENT*);\n-extern COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t,\n+DLL_LOCAL extern COIRESULT (*BufferReadMultiD)(COIBUFFER, uint64_t,\n+                            void *, void *, COI_COPY_TYPE,\n+                            uint32_t, const   COIEVENT*, COIEVENT*);\n+DLL_LOCAL extern COIRESULT (*BufferWriteMultiD)(COIBUFFER, const   COIPROCESS,\n+                            uint64_t, void *, void *,\n+                            COI_COPY_TYPE, uint32_t, const   COIEVENT*, COIEVENT*);\n+\n+DLL_LOCAL extern COIRESULT (*BufferCopy)(COIBUFFER, COIBUFFER, uint64_t, uint64_t,\n                               uint64_t, COI_COPY_TYPE, uint32_t,\n                               const COIEVENT*, COIEVENT*);\n-extern COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n-extern COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n+DLL_LOCAL extern COIRESULT (*BufferGetSinkAddress)(COIBUFFER, uint64_t*);\n+DLL_LOCAL extern COIRESULT (*BufferSetState)(COIBUFFER, COIPROCESS, COI_BUFFER_STATE,\n                                    COI_BUFFER_MOVE_FLAG, uint32_t,\n                                    const   COIEVENT*, COIEVENT*);\n \n-extern COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t,\n+DLL_LOCAL extern COIRESULT (*EventWait)(uint16_t, const COIEVENT*, int32_t,\n                            uint8_t, uint32_t*, uint32_t*);\n \n-extern uint64_t  (*PerfGetCycleFrequency)(void);\n+DLL_LOCAL extern uint64_t (*PerfGetCycleFrequency)(void);\n+\n+DLL_LOCAL extern COIRESULT (*ProcessConfigureDMA)(const uint64_t, const int);\n+\n+extern COIRESULT (*PipelineClearCPUMask)(COI_CPU_MASK);\n+\n+extern COIRESULT (*PipelineSetCPUMask)(COIPROCESS, uint32_t,\n+                                        uint8_t, COI_CPU_MASK);\n+extern COIRESULT (*EngineGetInfo)(COIENGINE, uint32_t, COI_ENGINE_INFO*);\n \n+extern COIRESULT (*EventRegisterCallback)(\n+    const COIEVENT,\n+    void (*)(COIEVENT, const COIRESULT, const void*),\n+    const void*,\n+    const uint64_t);\n+    \n+const int DMA_MODE_READ_WRITE = 1; \n } // namespace COI\n \n #endif // COI_CLIENT_H_INCLUDED"}, {"sha": "88dde9157dae9fd3e6d672e7edb32b02294c75c6", "filename": "liboffloadmic/runtime/coi/coi_server.cpp", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -38,6 +38,22 @@\n #include \"../offload_myo_target.h\"      // for __offload_myoLibInit/Fini\n #endif // MYO_SUPPORT\n \n+#if !defined(CPU_COUNT)\n+// if CPU_COUNT is not defined count number of CPUs manually \n+static\n+int my_cpu_count(cpu_set_t const *cpu_set) \n+{\n+    int res = 0;\n+    for (int i = 0; i < sizeof(cpu_set_t) / sizeof(__cpu_mask); ++i) {\n+        res += __builtin_popcountl(cpu_set->__bits[i]);\n+    }\n+    return res;\n+}\n+// Map CPU_COUNT to our function\n+#define CPU_COUNT(x) my_cpu_count(x)\n+\n+#endif\n+\n COINATIVELIBEXPORT\n void server_compute(\n     uint32_t  buffer_count,\n@@ -118,6 +134,20 @@ void server_var_table_copy(\n     __offload_vars.table_copy(buffers[0], *static_cast<int64_t*>(misc_data));\n }\n \n+COINATIVELIBEXPORT\n+void server_set_stream_affinity(\n+    uint32_t  buffer_count,\n+    void**    buffers,\n+    uint64_t* buffers_len,\n+    void*     misc_data,\n+    uint16_t  misc_data_len,\n+    void*     return_data,\n+    uint16_t  return_data_len\n+)\n+{\n+  /* kmp affinity is not supported by GCC.  */\n+}\n+\n #ifdef MYO_SUPPORT\n // temporary workaround for blocking behavior of myoiLibInit/Fini calls\n COINATIVELIBEXPORT"}, {"sha": "2ea67b7956259517190575b759922d74f0781982", "filename": "liboffloadmic/runtime/coi/coi_server.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcoi%2Fcoi_server.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -28,7 +28,7 @@\n */\n \n \n-//The interface betwen offload library and the COI API on the target.\n+// The interface between offload library and the COI API on the target\n \n #ifndef COI_SERVER_H_INCLUDED\n #define COI_SERVER_H_INCLUDED"}, {"sha": "7bac0e54de8135753e5ca68f304387fcc3392ddc", "filename": "liboffloadmic/runtime/compiler_if_host.cpp", "status": "modified", "additions": 161, "deletions": 9, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -35,7 +35,7 @@\n #include <alloca.h>\n #endif // TARGET_WINNT\n \n-// Global counter on host. \n+// Global counter on host.\n // This variable is used if P2OPT_offload_do_data_persistence == 2.\n // The variable used to identify offload constructs contained in one procedure.\n // Increment of OFFLOAD_CALL_COUNT is inserted at entries of HOST routines with\n@@ -72,7 +72,7 @@ extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE(\n \n     OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n \n-    // initalize all devices is init_type is on_offload_all\n+    // initialize all devices is init_type is on_offload_all\n     if (retval && __offload_init_type == c_init_on_offload_all) {\n         for (int i = 0; i < mic_engines_total; i++) {\n              mic_engines[i].init();\n@@ -241,7 +241,128 @@ extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n     return ofld;\n }\n \n-int offload_offload_wrap(\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE2(\n+    TARGET_TYPE      target_type,\n+    int              target_number,\n+    int              is_optional,\n+    _Offload_status* status,\n+    const char*      file,\n+    uint64_t         line,\n+    const void**     stream\n+)\n+{\n+    bool retval;\n+    OFFLOAD ofld;\n+\n+    // initialize status\n+    if (status != 0) {\n+        status->result = OFFLOAD_UNAVAILABLE;\n+        status->device_number = -1;\n+        status->data_sent = 0;\n+        status->data_received = 0;\n+    }\n+\n+    // make sure libray is initialized\n+    retval = __offload_init_library();\n+    // OFFLOAD_TIMER_INIT must follow call to __offload_init_library\n+    OffloadHostTimerData * timer_data = OFFLOAD_TIMER_INIT(file, line);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_total_offload);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+\n+    // initalize all devices if init_type is on_offload_all\n+    if (retval && __offload_init_type == c_init_on_offload_all) {\n+        for (int i = 0; i < mic_engines_total; i++) {\n+             mic_engines[i].init();\n+        }\n+    }\n+    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+\n+    OFFLOAD_TIMER_START(timer_data, c_offload_host_target_acquire);\n+\n+    if (target_type == TARGET_HOST) {\n+        // Host always available\n+        retval = true;\n+    }\n+    else if (target_type == TARGET_MIC) {\n+        _Offload_stream handle = *(reinterpret_cast<_Offload_stream*>(stream));\n+        Stream * stream = handle ? Stream::find_stream(handle, false) : NULL;\n+        if (target_number >= -1) {\n+            if (retval) {\n+                // device number is defined by stream\n+                if (stream) {\n+                    target_number = stream->get_device();\n+                    target_number = target_number % mic_engines_total;\n+                }\n+\n+                // reserve device in ORSL\n+                if (target_number != -1) {\n+                    if (is_optional) {\n+                        if (!ORSL::try_reserve(target_number)) {\n+                            target_number = -1;\n+                        }\n+                    }\n+                    else {\n+                        if (!ORSL::reserve(target_number)) {\n+                            target_number = -1;\n+                        }\n+                    }\n+                }\n+\n+                // initialize device\n+                if (target_number >= 0 &&\n+                    __offload_init_type == c_init_on_offload) {\n+                    OFFLOAD_TIMER_START(timer_data, c_offload_host_initialize);\n+                    mic_engines[target_number].init();\n+                    OFFLOAD_TIMER_STOP(timer_data, c_offload_host_initialize);\n+                }\n+            }\n+            else {\n+                // fallback to CPU\n+                target_number = -1;\n+            }\n+            if (!(target_number == -1 && handle == 0)) {\n+                if (target_number < 0 || !retval) {\n+                    if (!is_optional && status == 0) {\n+                        LIBOFFLOAD_ERROR(c_device_is_not_available);\n+                        exit(1);\n+                    }\n+\n+                    retval = false;\n+                }\n+            }\n+        }\n+        else {\n+            LIBOFFLOAD_ERROR(c_invalid_device_number);\n+            exit(1);\n+        }\n+    }\n+\n+    if (retval) {\n+        ofld = new OffloadDescriptor(target_number, status,\n+                                     !is_optional, false, timer_data);\n+        OFFLOAD_TIMER_HOST_MIC_NUM(timer_data, target_number);\n+        Offload_Report_Prolog(timer_data);\n+        OFFLOAD_DEBUG_TRACE_1(2, timer_data->offload_number, c_offload_start,\n+                              \"Starting offload: target_type = %d, \"\n+                              \"number = %d, is_optional = %d\\n\",\n+                              target_type, target_number, is_optional);\n+\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n+    }\n+    else {\n+        ofld = NULL;\n+\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_target_acquire);\n+        OFFLOAD_TIMER_STOP(timer_data, c_offload_host_total_offload);\n+        offload_report_free_data(timer_data);\n+    }\n+\n+    return ofld;\n+}\n+\n+static int offload_offload_wrap(\n     OFFLOAD ofld,\n     const char *name,\n     int is_empty,\n@@ -252,12 +373,15 @@ int offload_offload_wrap(\n     const void **waits,\n     const void **signal,\n     int entry_id,\n-    const void *stack_addr\n+    const void *stack_addr,\n+    OffloadFlags offload_flags\n )\n {\n     bool ret = ofld->offload(name, is_empty, vars, vars2, num_vars,\n-                             waits, num_waits, signal, entry_id, stack_addr);\n-    if (!ret || signal == 0) {\n+                             waits, num_waits, signal, entry_id,\n+                             stack_addr, offload_flags);\n+    if (!ret || (signal == 0 && ofld->get_stream() == 0 &&\n+                 !offload_flags.bits.omp_async)) {\n         delete ofld;\n     }\n     return ret;\n@@ -278,7 +402,7 @@ extern \"C\" int OFFLOAD_OFFLOAD1(\n     return offload_offload_wrap(ofld, name, is_empty,\n                             num_vars, vars, vars2,\n                             num_waits, waits,\n-                            signal, NULL, NULL);\n+                            signal, 0, NULL, {0});\n }\n \n extern \"C\" int OFFLOAD_OFFLOAD2(\n@@ -298,7 +422,35 @@ extern \"C\" int OFFLOAD_OFFLOAD2(\n     return offload_offload_wrap(ofld, name, is_empty,\n                             num_vars, vars, vars2,\n                             num_waits, waits,\n-                            signal, entry_id, stack_addr);\n+                            signal, entry_id, stack_addr, {0});\n+}\n+\n+extern \"C\" int OFFLOAD_OFFLOAD3(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void** signal,\n+    int entry_id,\n+    const void *stack_addr,\n+    OffloadFlags offload_flags,\n+    const void** stream\n+)\n+{\n+    // 1. if the source is compiled with -traceback then stream is 0\n+    // 2. if offload has a stream clause then stream is address of stream value\n+    if (stream) {\n+        ofld->set_stream(*(reinterpret_cast<_Offload_stream *>(stream)));\n+    }\n+\n+    return offload_offload_wrap(ofld, name, is_empty,\n+                            num_vars, vars, vars2,\n+                            num_waits, waits,\n+                            signal, entry_id, stack_addr, offload_flags);\n }\n \n extern \"C\" int OFFLOAD_OFFLOAD("}, {"sha": "b8f36db7de51eff1f4996eefc1552c7f516f3432", "filename": "liboffloadmic/runtime/compiler_if_host.h", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_host.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -39,9 +39,11 @@\n \n #define OFFLOAD_TARGET_ACQUIRE          OFFLOAD_PREFIX(target_acquire)\n #define OFFLOAD_TARGET_ACQUIRE1         OFFLOAD_PREFIX(target_acquire1)\n+#define OFFLOAD_TARGET_ACQUIRE2         OFFLOAD_PREFIX(target_acquire2)\n #define OFFLOAD_OFFLOAD                 OFFLOAD_PREFIX(offload)\n #define OFFLOAD_OFFLOAD1                OFFLOAD_PREFIX(offload1)\n #define OFFLOAD_OFFLOAD2                OFFLOAD_PREFIX(offload2)\n+#define OFFLOAD_OFFLOAD3                OFFLOAD_PREFIX(offload3)\n #define OFFLOAD_CALL_COUNT              OFFLOAD_PREFIX(offload_call_count)\n \n \n@@ -75,6 +77,26 @@ extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE1(\n     uint64_t        line\n );\n \n+/*! \\fn OFFLOAD_TARGET_ACQUIRE2\n+    \\brief Attempt to acquire the target.\n+    \\param target_type   The type of target.\n+    \\param target_number The device number.\n+    \\param is_optional   Whether CPU fall-back is allowed.\n+    \\param status        Address of variable to hold offload status.\n+    \\param file          Filename in which this offload occurred.\n+    \\param line          Line number in the file where this offload occurred.\n+    \\param stream        Pointer to stream value.\n+*/\n+extern \"C\" OFFLOAD OFFLOAD_TARGET_ACQUIRE2(\n+    TARGET_TYPE      target_type,\n+    int              target_number,\n+    int              is_optional,\n+    _Offload_status* status,\n+    const char*      file,\n+    uint64_t         line,\n+    const void**     stream\n+);\n+\n /*! \\fn OFFLOAD_OFFLOAD1\n     \\brief Run function on target using interface for old data persistence.\n     \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n@@ -127,6 +149,40 @@ extern \"C\" int OFFLOAD_OFFLOAD2(\n     const void *stack_addr\n );\n \n+\n+/*! \\fn OFFLOAD_OFFLOAD3\n+    \\brief Run function on target, API introduced in 15.0 Update 1\n+    \\brief when targetptr, preallocated feature was introduced.\n+    \\param o Offload descriptor created by OFFLOAD_TARGET_ACQUIRE.\n+    \\param name Name of offload entry point.\n+    \\param is_empty If no code to execute (e.g. offload_transfer)\n+    \\param num_vars Number of variable descriptors.\n+    \\param vars Pointer to VarDesc array.\n+    \\param vars2 Pointer to VarDesc2 array.\n+    \\param num_waits Number of \"wait\" values.\n+    \\param waits Pointer to array of wait values.\n+    \\param signal Pointer to signal value or NULL.\n+    \\param entry_id A signature for the function doing the offload.\n+    \\param stack_addr The stack frame address of the function doing offload.\n+    \\param offload_flags Flags to indicate Fortran traceback, OpenMP async.\n+    \\param stream Pointer to stream value or NULL.\n+*/\n+extern \"C\" int OFFLOAD_OFFLOAD3(\n+    OFFLOAD ofld,\n+    const char *name,\n+    int is_empty,\n+    int num_vars,\n+    VarDesc *vars,\n+    VarDesc2 *vars2,\n+    int num_waits,\n+    const void** waits,\n+    const void** signal,\n+    int entry_id,\n+    const void *stack_addr,\n+    OffloadFlags offload_flags,\n+    const void** stream\n+);\n+\n // Run function on target (obsolete).\n // @param o    OFFLOAD object\n // @param name function name"}, {"sha": "bc51d242ef078f90ec1115363a1c1f853d9b23e9", "filename": "liboffloadmic/runtime/compiler_if_target.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "9554238916c7a99e4686c7429f008b181fe64cb1", "filename": "liboffloadmic/runtime/compiler_if_target.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fcompiler_if_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fcompiler_if_target.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "e31714b8d41098f649ff6b55834158ad97d361a6", "filename": "liboffloadmic/runtime/dv_util.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fdv_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fdv_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -102,8 +102,8 @@ CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp)\n         }\n         res = (CeanReadRanges *)malloc(\n             sizeof(CeanReadRanges) + (rank - i) * sizeof(CeanReadDim));\n-\tif (res == NULL)\n-          LIBOFFLOAD_ERROR(c_malloc);\n+        if (res == NULL)\n+            LIBOFFLOAD_ERROR(c_malloc);\n         res -> last_noncont_ind = rank - i - 1;\n         count = 1;\n         for (; i < rank; i++) {"}, {"sha": "9095c32c5109d6352d8083fb61dc2a58416856f4", "filename": "liboffloadmic/runtime/dv_util.h", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fdv_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fdv_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fdv_util.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -32,6 +32,7 @@\n #define DV_UTIL_H_INCLUDED\n \n #include <stdint.h>\n+#include \"offload_util.h\"\n \n // Dope vector declarations\n #define ArrDescMaxArrayRank         31\n@@ -64,18 +65,18 @@ typedef struct ArrDesc {\n \n typedef ArrDesc* pArrDesc;\n \n-bool __dv_is_contiguous(const ArrDesc *dvp);\n+DLL_LOCAL bool __dv_is_contiguous(const ArrDesc *dvp);\n \n-bool __dv_is_allocated(const ArrDesc *dvp);\n+DLL_LOCAL bool __dv_is_allocated(const ArrDesc *dvp);\n \n-uint64_t __dv_data_length(const ArrDesc *dvp);\n+DLL_LOCAL uint64_t __dv_data_length(const ArrDesc *dvp);\n \n-uint64_t __dv_data_length(const ArrDesc *dvp, int64_t nelems);\n+DLL_LOCAL uint64_t __dv_data_length(const ArrDesc *dvp, int64_t nelems);\n \n-CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp);\n+DLL_LOCAL CeanReadRanges * init_read_ranges_dv(const ArrDesc *dvp);\n \n #if OFFLOAD_DEBUG > 0\n-void    __dv_desc_dump(const char *name, const ArrDesc *dvp);\n+DLL_LOCAL void    __dv_desc_dump(const char *name, const ArrDesc *dvp);\n #else // OFFLOAD_DEBUG\n #define __dv_desc_dump(name, dvp)\n #endif // OFFLOAD_DEBUG"}, {"sha": "7eae324ee74006f7f2eafbda32e8a073a099db9b", "filename": "liboffloadmic/runtime/emulator/coi_common.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -62,8 +62,8 @@\n /* Environment variable for target executable run command.  */\n #define OFFLOAD_EMUL_RUN_ENV      \"OFFLOAD_EMUL_RUN\"\n \n-/* Environment variable for number ok KNC devices.  */\n-#define OFFLOAD_EMUL_KNC_NUM_ENV  \"OFFLOAD_EMUL_KNC_NUM\"\n+/* Environment variable for number of emulated devices.  */\n+#define OFFLOAD_EMUL_NUM_ENV\t  \"OFFLOAD_EMUL_NUM\"\n \n \n /* Path to engine directory.  */\n@@ -133,6 +133,7 @@ typedef enum\n   CMD_BUFFER_UNMAP,\n   CMD_GET_FUNCTION_HANDLE,\n   CMD_OPEN_LIBRARY,\n+  CMD_CLOSE_LIBRARY,\n   CMD_RUN_FUNCTION,\n   CMD_SHUTDOWN\n } cmd_t;"}, {"sha": "8773a7910ce6e6fced68efd33ca7ed03820ac34d", "filename": "liboffloadmic/runtime/emulator/coi_device.cpp", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -109,8 +109,8 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t  strlen (PIPE_HOST_PATH) + strlen (mic_dir) + 1);\n   MALLOC (char *, pipe_target_path,\n \t  strlen (PIPE_TARGET_PATH) + strlen (mic_dir) + 1);\n-  sprintf (pipe_host_path, \"%s\"PIPE_HOST_PATH, mic_dir);\n-  sprintf (pipe_target_path, \"%s\"PIPE_TARGET_PATH, mic_dir);\n+  sprintf (pipe_host_path, \"%s\" PIPE_HOST_PATH, mic_dir);\n+  sprintf (pipe_target_path, \"%s\" PIPE_TARGET_PATH, mic_dir);\n   pipe_host = open (pipe_host_path, O_CLOEXEC | O_WRONLY);\n   if (pipe_host < 0)\n     COIERROR (\"Cannot open target-to-host pipe.\");\n@@ -237,19 +237,34 @@ SYMBOL_VERSION (COIProcessWaitForShutdown, 1) ()\n \t  {\n \t    char *lib_path;\n \t    size_t len;\n+\t    void *handle;\n \n \t    /* Receive data from host.  */\n \t    READ (pipe_target, &len, sizeof (size_t));\n \t    MALLOC (char *, lib_path, len);\n \t    READ (pipe_target, lib_path, len);\n \n \t    /* Open library.  */\n-\t    if (dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL) == 0)\n+\t    handle = dlopen (lib_path, RTLD_LAZY | RTLD_GLOBAL);\n+\t    if (handle == NULL)\n \t      COIERROR (\"Cannot load %s: %s\", lib_path, dlerror ());\n \n+\t    /* Send data to host.  */\n+\t    WRITE (pipe_host, &handle, sizeof (void *));\n+\n \t    /* Clean up.  */\n \t    free (lib_path);\n \n+\t    break;\n+\t  }\n+\tcase CMD_CLOSE_LIBRARY:\n+\t  {\n+\t    /* Receive data from host.  */\n+\t    void *handle;\n+\t    READ (pipe_target, &handle, sizeof (void *));\n+\n+\t    dlclose (handle);\n+\n \t    break;\n \t  }\n \tcase CMD_RUN_FUNCTION:"}, {"sha": "616c91849aceca126d1cfe7f6f2f769b33c3673d", "filename": "liboffloadmic/runtime/emulator/coi_device.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_device.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "cdc04c208e43a167e6f1211553121c07453e4f2e", "filename": "liboffloadmic/runtime/emulator/coi_host.cpp", "status": "modified", "additions": 125, "deletions": 26, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -40,8 +40,8 @@ extern char **environ;\n char **tmp_dirs;\n unsigned tmp_dirs_num = 0;\n \n-/* Number of KNC engines.  */\n-long knc_engines_num;\n+/* Number of emulated MIC engines.  */\n+long num_engines;\n \n /* Mutex to sync parallel execution.  */\n pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n@@ -116,8 +116,7 @@ __attribute__((constructor))\n static void\n init ()\n {\n-  if (read_long_env (OFFLOAD_EMUL_KNC_NUM_ENV, &knc_engines_num, 1)\n-      == COI_ERROR)\n+  if (read_long_env (OFFLOAD_EMUL_NUM_ENV, &num_engines, 1) == COI_ERROR)\n     exit (0);\n }\n \n@@ -665,10 +664,10 @@ SYMBOL_VERSION (COIEngineGetCount, 1) (COI_ISA_TYPE isa,\n   COITRACE (\"COIEngineGetCount\");\n \n   /* Features of liboffload.  */\n-  assert (isa == COI_ISA_KNC);\n+  assert (isa == COI_ISA_MIC);\n \n   /* Prepare output arguments.  */\n-  *count = knc_engines_num;\n+  *count = num_engines;\n \n   return COI_SUCCESS;\n }\n@@ -684,10 +683,10 @@ SYMBOL_VERSION (COIEngineGetHandle, 1) (COI_ISA_TYPE isa,\n   Engine *engine;\n \n   /* Features of liboffload.  */\n-  assert (isa == COI_ISA_KNC);\n+  assert (isa == COI_ISA_MIC);\n \n   /* Check engine index.  */\n-  if (index >= knc_engines_num)\n+  if (index >= num_engines)\n     COIERROR (\"Wrong engine index.\");\n \n   /* Create engine handle.  */\n@@ -889,7 +888,7 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n \n   /* Create directory for pipes to prevent names collision.  */\n   MALLOC (char *, pipes_path, strlen (PIPES_PATH) + strlen (eng->dir) + 1);\n-  sprintf (pipes_path, \"%s\"PIPES_PATH, eng->dir);\n+  sprintf (pipes_path, \"%s\" PIPES_PATH, eng->dir);\n   if (mkdir (pipes_path, S_IRWXU) < 0)\n     COIERROR (\"Cannot create folder %s.\", pipes_path);\n \n@@ -900,8 +899,8 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n \t  strlen (PIPE_TARGET_PATH) + strlen (eng->dir) + 1);\n   if (pipe_target_path == NULL)\n     COIERROR (\"Cannot allocate memory.\");\n-  sprintf (pipe_host_path, \"%s\"PIPE_HOST_PATH, eng->dir);\n-  sprintf (pipe_target_path, \"%s\"PIPE_TARGET_PATH, eng->dir);\n+  sprintf (pipe_host_path, \"%s\" PIPE_HOST_PATH, eng->dir);\n+  sprintf (pipe_target_path, \"%s\" PIPE_TARGET_PATH, eng->dir);\n   if (mkfifo (pipe_host_path, S_IRUSR | S_IWUSR) < 0)\n     COIERROR (\"Cannot create pipe %s.\", pipe_host_path);\n   if (mkfifo (pipe_target_path, S_IRUSR | S_IWUSR) < 0)\n@@ -1018,6 +1017,27 @@ SYMBOL_VERSION (COIProcessCreateFromMemory, 1) (COIENGINE engine,\n }\n \n \n+COIRESULT\n+SYMBOL_VERSION (COIProcessCreateFromFile, 1) (COIENGINE in_Engine,\n+\t\t\t\t\t      const char *in_pBinaryName,\n+\t\t\t\t\t      int in_Argc,\n+\t\t\t\t\t      const char **in_ppArgv,\n+\t\t\t\t\t      uint8_t in_DupEnv,\n+\t\t\t\t\t      const char **in_ppAdditionalEnv,\n+\t\t\t\t\t      uint8_t in_ProxyActive,\n+\t\t\t\t\t      const char *in_Reserved,\n+\t\t\t\t\t      uint64_t in_BufferSpace,\n+\t\t\t\t\t      const char *in_LibrarySearchPath,\n+\t\t\t\t\t      COIPROCESS *out_pProcess)\n+{\n+  COITRACE (\"COIProcessCreateFromFile\");\n+\n+  /* liboffloadmic with GCC compiled binaries should never go here.  */\n+  assert (false);\n+  return COI_ERROR;\n+}\n+\n+\n COIRESULT\n SYMBOL_VERSION (COIProcessDestroy, 1) (COIPROCESS process,\n \t\t\t\t       int32_t wait_timeout,      // Ignored\n@@ -1129,38 +1149,39 @@ SYMBOL_VERSION (COIProcessGetFunctionHandles, 1) (COIPROCESS process,\n \n \n COIRESULT\n-SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS process,\n-\t\t\t\t\t\t     const void *lib_buffer,\n-\t\t\t\t\t\t     uint64_t lib_buffer_len,\n-\t\t\t\t\t\t     const char *lib_name,\n-\t\t\t\t\t\t     const char *lib_search_path,\n-\t\t\t\t\t\t     const char *file_of_origin,\t// Ignored\n-\t\t\t\t\t\t     uint64_t file_from_origin_offset,  // Ignored\n-\t\t\t\t\t\t     uint32_t flags,\t\t\t// Ignored\n-\t\t\t\t\t\t     COILIBRARY *library)\t\t// Ignored\n+SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS in_Process,\n+\t\t\t\t\t\t     const void *in_pLibraryBuffer,\n+\t\t\t\t\t\t     uint64_t in_LibraryBufferLength,\n+\t\t\t\t\t\t     const char *in_pLibraryName,\n+\t\t\t\t\t\t     const char *in_LibrarySearchPath,\t// Ignored\n+\t\t\t\t\t\t     const char *in_FileOfOrigin,\t// Ignored\n+\t\t\t\t\t\t     uint64_t in_FileOfOriginOffset,\t// Ignored\n+\t\t\t\t\t\t     uint32_t in_Flags,\t\t\t// Ignored\n+\t\t\t\t\t\t     COILIBRARY *out_pLibrary)\n {\n   COITRACE (\"COIProcessLoadLibraryFromMemory\");\n \n+  const cmd_t cmd = CMD_OPEN_LIBRARY;\n   char *lib_path;\n-  cmd_t cmd = CMD_OPEN_LIBRARY;\n   int fd;\n   FILE *file;\n   size_t len;\n \n   /* Convert input arguments.  */\n-  Process *proc = (Process *) process;\n+  Process *proc = (Process *) in_Process;\n \n   /* Create target library file.  */\n   MALLOC (char *, lib_path,\n-\t  strlen (proc->engine->dir) + strlen (lib_name) + 2);\n-  sprintf (lib_path, \"%s/%s\", proc->engine->dir, lib_name);\n+\t  strlen (proc->engine->dir) + strlen (in_pLibraryName) + 2);\n+  sprintf (lib_path, \"%s/%s\", proc->engine->dir, in_pLibraryName);\n   fd = open (lib_path, O_CLOEXEC | O_CREAT | O_WRONLY, S_IRUSR | S_IWUSR);\n   if (fd < 0)\n     COIERROR (\"Cannot create file %s.\", lib_path);\n   file = fdopen (fd, \"wb\");\n   if (file == NULL)\n     COIERROR (\"Cannot associate stream with file descriptor.\");\n-  if (fwrite (lib_buffer, 1, lib_buffer_len, file) != lib_buffer_len)\n+  if (fwrite (in_pLibraryBuffer, 1, in_LibraryBufferLength, file)\n+      != in_LibraryBufferLength)\n     COIERROR (\"Cannot write in file %s.\", lib_path);\n   if (fclose (file) != 0)\n     COIERROR (\"Cannot close file %s.\", lib_path);\n@@ -1176,13 +1197,18 @@ SYMBOL_VERSION (COIProcessLoadLibraryFromMemory, 2) (COIPROCESS process,\n   WRITE (proc->pipeline->pipe_target, &len, sizeof (size_t));\n   WRITE (proc->pipeline->pipe_target, lib_path, len);\n \n+  /* Receive data from target.  */\n+  void *handle;\n+  READ (proc->pipeline->pipe_host, &handle, sizeof (void *));\n+\n   /* Finish critical section.  */\n   if (pthread_mutex_unlock (&mutex) != 0)\n     COIERROR (\"Cannot unlock mutex.\");\n \n   /* Clean up.  */\n   free (lib_path);\n \n+  *out_pLibrary = (COILIBRARY) handle;\n   return COI_SUCCESS;\n }\n \n@@ -1202,6 +1228,33 @@ SYMBOL_VERSION (COIProcessRegisterLibraries, 1) (uint32_t libraries_num,\n }\n \n \n+COIRESULT\n+SYMBOL_VERSION (COIProcessUnloadLibrary, 1) (COIPROCESS in_Process,\n+\t\t\t\t\t     COILIBRARY in_Library)\n+{\n+  COITRACE (\"COIProcessUnloadLibrary\");\n+\n+  const cmd_t cmd = CMD_CLOSE_LIBRARY;\n+\n+  /* Convert input arguments.  */\n+  Process *proc = (Process *) in_Process;\n+\n+  /* Start critical section.  */\n+  if (pthread_mutex_lock (&mutex) != 0)\n+    COIERROR (\"Cannot lock mutex.\");\n+\n+  /* Make target close library.  */\n+  WRITE (proc->pipeline->pipe_target, &cmd, sizeof (cmd_t));\n+  WRITE (proc->pipeline->pipe_target, &in_Library, sizeof (void *));\n+\n+  /* Finish critical section.  */\n+  if (pthread_mutex_unlock (&mutex) != 0)\n+    COIERROR (\"Cannot unlock mutex.\");\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n uint64_t\n SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n {\n@@ -1210,5 +1263,51 @@ SYMBOL_VERSION (COIPerfGetCycleFrequency, 1) ()\n   return (uint64_t) CYCLE_FREQUENCY;\n }\n \n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineClearCPUMask, 1) (COI_CPU_MASK *in_Mask)\n+{\n+  COITRACE (\"COIPipelineClearCPUMask\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIPipelineSetCPUMask, 1) (COIPROCESS in_Process,\n+\t\t\t\t\t   uint32_t in_CoreID,\n+\t\t\t\t\t   uint8_t in_ThreadID,\n+\t\t\t\t\t   COI_CPU_MASK *out_pMask)\n+{\n+  COITRACE (\"COIPipelineSetCPUMask\");\n+\n+  /* Looks like we have nothing to do here.  */\n+\n+  return COI_SUCCESS;\n+}\n+\n+\n+COIRESULT\n+SYMBOL_VERSION (COIEngineGetInfo, 1) (COIENGINE in_EngineHandle,\n+\t\t\t\t      uint32_t in_EngineInfoSize,\n+\t\t\t\t      COI_ENGINE_INFO *out_pEngineInfo)\n+{\n+  COITRACE (\"COIEngineGetInfo\");\n+\n+  out_pEngineInfo->ISA = COI_ISA_x86_64;\n+  out_pEngineInfo->NumCores = 1;\n+  out_pEngineInfo->NumThreads = 8;\n+  out_pEngineInfo->CoreMaxFrequency = SYMBOL_VERSION(COIPerfGetCycleFrequency,1)() / 1000000;\n+  out_pEngineInfo->PhysicalMemory = 1024;\n+  out_pEngineInfo->PhysicalMemoryFree = 1024;\n+  out_pEngineInfo->SwapMemory = 1024;\n+  out_pEngineInfo->SwapMemoryFree = 1024;\n+  out_pEngineInfo->MiscFlags = COI_ENG_ECC_DISABLED;\n+\n+  return COI_SUCCESS;\n+}\n+\n } // extern \"C\"\n "}, {"sha": "82260da9db98ad5f94a1620f76e0d5b494bc76b3", "filename": "liboffloadmic/runtime/emulator/coi_host.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_host.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "25806391b29a45e5aae25e5a5b3036884ee98137", "filename": "liboffloadmic/runtime/emulator/coi_version_asm.h", "status": "modified", "additions": 52, "deletions": 29, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_asm.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -38,31 +38,54 @@\n  * intellectual property rights is granted herein.\n  */\n \n-__asm__ (\".symver COIBufferAddRef1,COIBufferAddRef@@COI_1.0\");\n-__asm__ (\".symver COIBufferCopy1,COIBufferCopy@@COI_1.0\");\n-__asm__ (\".symver COIBufferCreate1,COIBufferCreate@@COI_1.0\");\n-__asm__ (\".symver COIBufferCreateFromMemory1,COIBufferCreateFromMemory@@COI_1.0\");\n-__asm__ (\".symver COIBufferDestroy1,COIBufferDestroy@@COI_1.0\");\n-__asm__ (\".symver COIBufferGetSinkAddress1,COIBufferGetSinkAddress@@COI_1.0\");\n-__asm__ (\".symver COIBufferMap1,COIBufferMap@@COI_1.0\");\n-__asm__ (\".symver COIBufferRead1,COIBufferRead@@COI_1.0\");\n-__asm__ (\".symver COIBufferReleaseRef1,COIBufferReleaseRef@@COI_1.0\");\n-__asm__ (\".symver COIBufferSetState1,COIBufferSetState@@COI_1.0\");\n-__asm__ (\".symver COIBufferUnmap1,COIBufferUnmap@@COI_1.0\");\n-__asm__ (\".symver COIBufferWrite1,COIBufferWrite@@COI_1.0\");\n-__asm__ (\".symver COIEngineGetCount1,COIEngineGetCount@@COI_1.0\");\n-__asm__ (\".symver COIEngineGetHandle1,COIEngineGetHandle@@COI_1.0\");\n-__asm__ (\".symver COIEngineGetIndex1,COIEngineGetIndex@@COI_1.0\");\n-__asm__ (\".symver COIEventWait1,COIEventWait@@COI_1.0\");\n-__asm__ (\".symver COIPerfGetCycleFrequency1,COIPerfGetCycleFrequency@@COI_1.0\");\n-__asm__ (\".symver COIPipelineCreate1,COIPipelineCreate@@COI_1.0\");\n-__asm__ (\".symver COIPipelineDestroy1,COIPipelineDestroy@@COI_1.0\");\n-__asm__ (\".symver COIPipelineRunFunction1,COIPipelineRunFunction@@COI_1.0\");\n-__asm__ (\".symver COIPipelineStartExecutingRunFunctions1,COIPipelineStartExecutingRunFunctions@@COI_1.0\");\n-__asm__ (\".symver COIProcessCreateFromMemory1,COIProcessCreateFromMemory@@COI_1.0\");\n-__asm__ (\".symver COIProcessDestroy1,COIProcessDestroy@@COI_1.0\");\n-__asm__ (\".symver COIProcessGetFunctionHandles1,COIProcessGetFunctionHandles@@COI_1.0\");\n-__asm__ (\".symver COIProcessLoadLibraryFromMemory2,COIProcessLoadLibraryFromMemory@COI_2.0\");\n-__asm__ (\".symver COIProcessRegisterLibraries1,COIProcessRegisterLibraries@@COI_1.0\");\n-__asm__ (\".symver COIProcessWaitForShutdown1,COIProcessWaitForShutdown@@COI_1.0\");\n-\n+// Originally generated via:\n+//   cd include;\n+//   ctags -x --c-kinds=fp -R sink/ source/ common/ | grep -v COIX | awk '{print \"__asm__(\\\".symver \"$1\"1,\"$1\"@@COI_1.0\\\");\"}'\n+//\n+// These directives must have an associated linker script with VERSION stuff.\n+// See coi_version_linker_script.map\n+// Passed in as\n+//    -Wl,--version-script coi_version_linker_script.map\n+// when building Intel(R) Coprocessor Offload Infrastructure (Intel(R) COI)\n+//\n+// See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info\n+//\n+// This is not strictly a .h file, so no need to #pragma once or anything.\n+// You must include these asm directives in the same translation unit as the\n+// one where the function body is.\n+// Otherwise we'd have add this file to the list of files needed to build\n+// libcoi*, instead of including it in each of the api/*/*cpp files.\n+//\n+__asm__(\".symver COIBufferAddRef1,COIBufferAddRef@@COI_1.0\");\n+__asm__(\".symver COIBufferCopy1,COIBufferCopy@@COI_1.0\");\n+__asm__(\".symver COIBufferCreate1,COIBufferCreate@@COI_1.0\");\n+__asm__(\".symver COIBufferCreateFromMemory1,COIBufferCreateFromMemory@@COI_1.0\");\n+__asm__(\".symver COIBufferDestroy1,COIBufferDestroy@@COI_1.0\");\n+__asm__(\".symver COIBufferGetSinkAddress1,COIBufferGetSinkAddress@@COI_1.0\");\n+__asm__(\".symver COIBufferMap1,COIBufferMap@@COI_1.0\");\n+__asm__(\".symver COIBufferRead1,COIBufferRead@@COI_1.0\");\n+__asm__(\".symver COIBufferReleaseRef1,COIBufferReleaseRef@@COI_1.0\");\n+__asm__(\".symver COIBufferSetState1,COIBufferSetState@@COI_1.0\");\n+__asm__(\".symver COIBufferUnmap1,COIBufferUnmap@@COI_1.0\");\n+__asm__(\".symver COIBufferWrite1,COIBufferWrite@@COI_1.0\");\n+__asm__(\".symver COIEngineGetCount1,COIEngineGetCount@@COI_1.0\");\n+__asm__(\".symver COIEngineGetHandle1,COIEngineGetHandle@@COI_1.0\");\n+__asm__(\".symver COIEngineGetIndex1,COIEngineGetIndex@@COI_1.0\");\n+__asm__(\".symver COIEngineGetInfo1,COIEngineGetInfo@@COI_1.0\");\n+__asm__(\".symver COIEventRegisterCallback1,COIEventRegisterCallback@@COI_1.0\");\n+__asm__(\".symver COIEventWait1,COIEventWait@@COI_1.0\");\n+__asm__(\".symver COIPerfGetCycleFrequency1,COIPerfGetCycleFrequency@@COI_1.0\");\n+__asm__(\".symver COIPipelineClearCPUMask1,COIPipelineClearCPUMask@@COI_1.0\");\n+__asm__(\".symver COIPipelineCreate1,COIPipelineCreate@@COI_1.0\");\n+__asm__(\".symver COIPipelineDestroy1,COIPipelineDestroy@@COI_1.0\");\n+__asm__(\".symver COIPipelineRunFunction1,COIPipelineRunFunction@@COI_1.0\");\n+__asm__(\".symver COIPipelineSetCPUMask1,COIPipelineSetCPUMask@@COI_1.0\");\n+__asm__(\".symver COIPipelineStartExecutingRunFunctions1,COIPipelineStartExecutingRunFunctions@@COI_1.0\");\n+__asm__(\".symver COIProcessCreateFromFile1,COIProcessCreateFromFile@@COI_1.0\");\n+__asm__(\".symver COIProcessCreateFromMemory1,COIProcessCreateFromMemory@@COI_1.0\");\n+__asm__(\".symver COIProcessDestroy1,COIProcessDestroy@@COI_1.0\");\n+__asm__(\".symver COIProcessGetFunctionHandles1,COIProcessGetFunctionHandles@@COI_1.0\");\n+__asm__(\".symver COIProcessLoadLibraryFromMemory2,COIProcessLoadLibraryFromMemory@COI_2.0\");\n+__asm__(\".symver COIProcessRegisterLibraries1,COIProcessRegisterLibraries@@COI_1.0\");\n+__asm__(\".symver COIProcessUnloadLibrary1,COIProcessUnloadLibrary@@COI_1.0\");\n+__asm__(\".symver COIProcessWaitForShutdown1,COIProcessWaitForShutdown@@COI_1.0\");"}, {"sha": "a98cbc6e7840b37525dbae46cb9a8f862068d249", "filename": "liboffloadmic/runtime/emulator/coi_version_linker_script.map", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fcoi_version_linker_script.map?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -38,6 +38,12 @@\n  * intellectual property rights is granted herein.\n  */\n \n+/***\n+* See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info.\n+* Use this in conjunction with coi_version_asm.h.\n+* // Comments don't work in this file.\n+***/\n+\n COI_1.0\n {\n   global:\n@@ -56,17 +62,23 @@ COI_1.0\n     COIEngineGetCount;\n     COIEngineGetHandle;\n     COIEngineGetIndex;\n+    COIEngineGetInfo;\n     COIEventWait;\n+    COIEventRegisterCallback;\n     COIPerfGetCycleFrequency;\n+    COIPipelineClearCPUMask;\n     COIPipelineCreate;\n     COIPipelineDestroy;\n     COIPipelineRunFunction;\n+    COIPipelineSetCPUMask;\n     COIPipelineStartExecutingRunFunctions;\n+    COIProcessCreateFromFile;\n     COIProcessCreateFromMemory;\n     COIProcessDestroy;\n     COIProcessGetFunctionHandles;\n     COIProcessLoadLibraryFromMemory;\n     COIProcessRegisterLibraries;\n+    COIProcessUnloadLibrary;\n     COIProcessWaitForShutdown;\n   local:\n     *;"}, {"sha": "d9d5f309ed18c5752d7c72940add2c1abca74bfc", "filename": "liboffloadmic/runtime/emulator/myo_client.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_client.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "0473253f731c09e486c43ee27ec0241b343903c3", "filename": "liboffloadmic/runtime/emulator/myo_service.cpp", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -155,5 +155,49 @@ SYMBOL_VERSION (myoiTargetFptrTableRegister, 1) (void *table,\n   return MYO_ERROR;\n }\n \n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoArenaRelease, 1) (MyoArena in_Arena)\n+{\n+  MYOTRACE (\"myoArenaRelease\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI MyoError\n+SYMBOL_VERSION (myoArenaAcquire, 1) (MyoArena in_Arena)\n+{\n+  MYOTRACE (\"myoArenaAcquire\");\n+\n+  assert (false);\n+\n+  return MYO_ERROR;\n+}\n+\n+\n+MYOACCESSAPI void\n+SYMBOL_VERSION (myoArenaAlignedFree, 1) (MyoArena in_Arena, void *in_pPtr)\n+{\n+  MYOTRACE (\"myoArenaAlignedFree\");\n+\n+  assert (false);\n+}\n+\n+\n+MYOACCESSAPI void *\n+SYMBOL_VERSION (myoArenaAlignedMalloc, 1) (MyoArena in_Arena, size_t in_Size,\n+\t\t\t\t\t   size_t in_Alignment)\n+{\n+  MYOTRACE (\"myoArenaAlignedMalloc\");\n+\n+  assert (false);\n+\n+  return 0;\n+}\n+\n+\n } // extern \"C\"\n "}, {"sha": "ffa4a5f8dcd83b34af34d9f522e2738eeddf2c90", "filename": "liboffloadmic/runtime/emulator/myo_service.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_service.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "f4db3ca4ab745713b8ee7877eb537c128c7b677e", "filename": "liboffloadmic/runtime/emulator/myo_version_asm.h", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_asm.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -38,16 +38,24 @@\n  * intellectual property rights is granted herein.\n  */\n \n-__asm__ (\".symver myoAcquire1,myoAcquire@@MYO_1.0\");\n-__asm__ (\".symver myoRelease1,myoRelease@@MYO_1.0\");\n-__asm__ (\".symver myoSharedAlignedFree1,myoSharedAlignedFree@@MYO_1.0\");\n-__asm__ (\".symver myoSharedAlignedMalloc1,myoSharedAlignedMalloc@@MYO_1.0\");\n-__asm__ (\".symver myoSharedFree1,myoSharedFree@@MYO_1.0\");\n-__asm__ (\".symver myoSharedMalloc1,myoSharedMalloc@@MYO_1.0\");\n+/*Version for Symbols( only Functions currently versioned)\n+Only that Linux Host Side code is versioned currently*/\n+#if (! defined MYO_MIC_CARD) && (! defined _WIN32)\n \n-__asm__ (\".symver myoiLibInit1,myoiLibInit@@MYO_1.0\");\n-__asm__ (\".symver myoiLibFini1,myoiLibFini@@MYO_1.0\");\n-__asm__ (\".symver myoiMicVarTableRegister1,myoiMicVarTableRegister@@MYO_1.0\");\n-__asm__ (\".symver myoiRemoteFuncRegister1,myoiRemoteFuncRegister@@MYO_1.0\");\n-__asm__ (\".symver myoiTargetFptrTableRegister1,myoiTargetFptrTableRegister@@MYO_1.0\");\n+   __asm__(\".symver myoArenaAlignedMalloc1,myoArenaAlignedMalloc@@MYO_1.0\");\n+   __asm__(\".symver myoArenaAlignedFree1,myoArenaAlignedFree@@MYO_1.0\");\n+   __asm__(\".symver myoArenaAcquire1,myoArenaAcquire@@MYO_1.0\");\n+   __asm__(\".symver myoArenaRelease1,myoArenaRelease@@MYO_1.0\");\n+   __asm__(\".symver myoAcquire1,myoAcquire@@MYO_1.0\");\n+   __asm__(\".symver myoRelease1,myoRelease@@MYO_1.0\");\n+   __asm__(\".symver myoSharedAlignedFree1,myoSharedAlignedFree@@MYO_1.0\");\n+   __asm__(\".symver myoSharedAlignedMalloc1,myoSharedAlignedMalloc@@MYO_1.0\");\n+   __asm__(\".symver myoSharedFree1,myoSharedFree@@MYO_1.0\");\n+   __asm__(\".symver myoSharedMalloc1,myoSharedMalloc@@MYO_1.0\");\n+   __asm__(\".symver myoiLibInit1,myoiLibInit@@MYO_1.0\");\n+   __asm__(\".symver myoiLibFini1,myoiLibFini@@MYO_1.0\");\n+   __asm__(\".symver myoiMicVarTableRegister1,myoiMicVarTableRegister@@MYO_1.0\");\n+   __asm__(\".symver myoiRemoteFuncRegister1,myoiRemoteFuncRegister@@MYO_1.0\");\n+   __asm__(\".symver myoiTargetFptrTableRegister1,myoiTargetFptrTableRegister@@MYO_1.0\");\n \n+#endif"}, {"sha": "8f065bbb4ac41283410aa72feea1b939fb7f8b0f", "filename": "liboffloadmic/runtime/emulator/myo_version_linker_script.map", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Femulator%2Fmyo_version_linker_script.map?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2010-2013 Intel Corporation.\n+ * Copyright 2010-2015 Intel Corporation.\n  *\n  * This library is free software; you can redistribute it and/or modify it\n  * under the terms of the GNU Lesser General Public License as published\n@@ -38,9 +38,17 @@\n  * intellectual property rights is granted herein.\n  */\n \n+/***\n+* See http://sourceware.org/binutils/docs/ld/VERSION.html#VERSION for more info.\n+***/\n+\n MYO_1.0\n {\n   global:\n+    myoArenaAlignedMalloc;\n+    myoArenaAlignedFree;\n+    myoArenaAcquire;\n+    myoArenaRelease;\n     myoAcquire;\n     myoRelease;\n     myoSharedAlignedFree;"}, {"sha": "29dcb6c8507c06260664a6515f1907da37174a4d", "filename": "liboffloadmic/runtime/liboffload_error.c", "status": "modified", "additions": 44, "deletions": 1, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error.c?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -144,6 +144,9 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_process_create:\n             write_message(stderr, msg_c_process_create, args);\n             break;\n+        case c_process_set_cache_size:\n+            write_message(stderr, msg_c_process_set_cache_size, args);\n+            break;\n         case c_process_wait_shutdown:\n             write_message(stderr, msg_c_process_wait_shutdown, args);\n             break;\n@@ -216,6 +219,9 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_zero_or_neg_transfer_size:\n             write_message(stderr, msg_c_zero_or_neg_transfer_size, args);\n             break;\n+        case c_bad_ptr_mem_alloc:\n+            write_message(stderr, msg_c_bad_ptr_mem_alloc, args);\n+            break;\n         case c_bad_ptr_mem_range:\n             write_message(stderr, msg_c_bad_ptr_mem_range, args);\n             break;\n@@ -258,6 +264,39 @@ void __liboffload_error_support(error_types input_tag, ...)\n         case c_report_unknown_trace_node:\n             write_message(stderr, msg_c_report_unknown_trace_node, args);\n             break;\n+        case c_incorrect_affinity:\n+            write_message(stderr, msg_c_incorrect_affinity, args);\n+            break;\n+        case c_cannot_set_affinity:\n+            write_message(stderr, msg_c_cannot_set_affinity, args);\n+            break;\n+        case c_in_with_preallocated:\n+            write_message(stderr, msg_c_in_with_preallocated, args);\n+            break;\n+        case c_report_no_host_exe:\n+            write_message(stderr, msg_c_report_no_host_exe, args);\n+            break;\n+        case c_report_path_buff_overflow:\n+            write_message(stderr, msg_c_report_path_buff_overflow, args);\n+            break;\n+        case c_create_pipeline_for_stream:\n+            write_message(stderr, msg_c_create_pipeline_for_stream, args);\n+            break;\n+        case c_offload_no_stream:\n+            write_message(stderr, msg_c_offload_no_stream, args);\n+            break;\n+        case c_get_engine_info:\n+            write_message(stderr, msg_c_get_engine_info, args);\n+            break;\n+        case c_clear_cpu_mask:\n+            write_message(stderr, msg_c_clear_cpu_mask, args);\n+            break;\n+        case c_set_cpu_mask:\n+            write_message(stderr, msg_c_set_cpu_mask, args);\n+            break;\n+        case c_unload_library:\n+            write_message(stderr, msg_c_unload_library, args);\n+            break;\n     }\n     va_end(args);\n }\n@@ -374,6 +413,10 @@ char const * report_get_message_str(error_types input_tag)\n             return (offload_get_message_str(msg_c_report_unregister));\n         case c_report_var:\n             return (offload_get_message_str(msg_c_report_var));\n+        case c_report_stream:\n+            return (offload_get_message_str(msg_c_report_stream));\n+        case c_report_state_stream:\n+            return (offload_get_message_str(msg_c_report_state_stream));\n \n         default:\n             LIBOFFLOAD_ERROR(c_report_unknown_trace_node);"}, {"sha": "d580851271a693b79351edef76699969ca1dd6c9", "filename": "liboffloadmic/runtime/liboffload_error_codes.h", "status": "modified", "additions": 36, "deletions": 9, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_error_codes.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -68,6 +68,7 @@ typedef enum\n     c_get_engine_handle,\n     c_get_engine_index,\n     c_process_create,\n+    c_process_set_cache_size,\n     c_process_get_func_handles,\n     c_process_wait_shutdown,\n     c_process_proxy_flush,\n@@ -91,6 +92,7 @@ typedef enum\n     c_event_wait,\n     c_zero_or_neg_ptr_len,\n     c_zero_or_neg_transfer_size,\n+    c_bad_ptr_mem_alloc,\n     c_bad_ptr_mem_range,\n     c_different_src_and_dstn_sizes,\n     c_ranges_dont_match,\n@@ -103,6 +105,8 @@ typedef enum\n     c_unknown_binary_type,\n     c_multiple_target_exes,\n     c_no_target_exe,\n+    c_incorrect_affinity,\n+    c_cannot_set_affinity,\n     c_report_host,\n     c_report_target,\n     c_report_title,\n@@ -159,7 +163,24 @@ typedef enum\n     c_report_myosharedalignedfree,\n     c_report_myoacquire,\n     c_report_myorelease,\n-    c_coipipe_max_number\n+    c_report_myosupportsfeature,\n+    c_report_myosharedarenacreate,\n+    c_report_myosharedalignedarenamalloc,\n+    c_report_myosharedalignedarenafree,\n+    c_report_myoarenaacquire,\n+    c_report_myoarenarelease,\n+    c_coipipe_max_number,\n+    c_in_with_preallocated,\n+    c_report_no_host_exe,\n+    c_report_path_buff_overflow,\n+    c_create_pipeline_for_stream,\n+    c_offload_no_stream,\n+    c_get_engine_info,\n+    c_clear_cpu_mask,\n+    c_set_cpu_mask,\n+    c_report_state_stream,\n+    c_report_stream,\n+    c_unload_library\n } error_types;\n \n enum OffloadHostPhase {\n@@ -260,15 +281,21 @@ enum OffloadTargetPhase {\n     c_offload_target_max_phase\n };\n \n+#ifdef TARGET_WINNT\n+    #define DLL_LOCAL\n+#else\n+    #define DLL_LOCAL  __attribute__((visibility(\"hidden\")))\n+#endif\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n-void __liboffload_error_support(error_types input_tag, ...);\n-void __liboffload_report_support(error_types input_tag, ...);\n-char const *offload_get_message_str(int msgCode);\n-char const * report_get_message_str(error_types input_tag);\n-char const * report_get_host_stage_str(int i);\n-char const * report_get_target_stage_str(int i);\n+DLL_LOCAL void __liboffload_error_support(error_types input_tag, ...);\n+DLL_LOCAL void __liboffload_report_support(error_types input_tag, ...);\n+DLL_LOCAL char const *offload_get_message_str(int msgCode);\n+DLL_LOCAL char const * report_get_message_str(error_types input_tag);\n+DLL_LOCAL char const * report_get_host_stage_str(int i);\n+DLL_LOCAL char const * report_get_target_stage_str(int i);\n #ifdef __cplusplus\n }\n #endif\n@@ -281,7 +308,7 @@ char const * report_get_target_stage_str(int i);\n     fprintf(stderr, \"\\t TEST for %s \\n \\t\", nm); \\\n     __liboffload_error_support(msg, __VA_ARGS__);\n \n-void write_message(FILE * file, int msgCode, va_list args_p);\n+DLL_LOCAL void write_message(FILE * file, int msgCode, va_list args_p);\n \n #define LIBOFFLOAD_ERROR __liboffload_error_support\n "}, {"sha": "3d3784c5eda7690d1ca07e2e7440b9ba90c8ca99", "filename": "liboffloadmic/runtime/liboffload_msg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_msg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.c?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -28,7 +28,6 @@\n */\n \n \n-\n #include <stdarg.h>\n #include <stdio.h>\n #include <stdlib.h>\n@@ -55,7 +54,7 @@\n         va_copy(args, args_p);\n         buf[0] = '\\n';\n         vsnprintf(buf + 1, sizeof(buf) - 2,\n-                  MESSAGE_TABLE_NAME[ msgCode ], args);\n+            MESSAGE_TABLE_NAME[ msgCode ], args);\n         strcat(buf, \"\\n\");\n         va_end(args);\n         fputs(buf, file);"}, {"sha": "f1bae7712e3de9b6330d3bb726e2062bb47a549e", "filename": "liboffloadmic/runtime/liboffload_msg.h", "status": "modified", "additions": 197, "deletions": 155, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fliboffload_msg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fliboffload_msg.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -62,6 +62,7 @@ enum {\n \tmsg_c_get_engine_handle,\n \tmsg_c_get_engine_index,\n \tmsg_c_process_create,\n+\tmsg_c_process_set_cache_size,\n \tmsg_c_process_get_func_handles,\n \tmsg_c_process_wait_shutdown,\n \tmsg_c_process_proxy_flush,\n@@ -85,6 +86,7 @@ enum {\n \tmsg_c_event_wait,\n \tmsg_c_zero_or_neg_ptr_len,\n \tmsg_c_zero_or_neg_transfer_size,\n+\tmsg_c_bad_ptr_mem_alloc,\n \tmsg_c_bad_ptr_mem_range,\n \tmsg_c_different_src_and_dstn_sizes,\n \tmsg_c_non_contiguous_dope_vector,\n@@ -95,6 +97,8 @@ enum {\n \tmsg_c_no_target_exe,\n \tmsg_c_report_unknown_timer_node,\n \tmsg_c_report_unknown_trace_node,\n+\tmsg_c_incorrect_affinity,\n+\tmsg_c_cannot_set_affinity,\n \tmsg_c_report_host,\n \tmsg_c_report_mic,\n \tmsg_c_report_title,\n@@ -148,6 +152,12 @@ enum {\n \tmsg_c_report_myosharedalignedfree,\n \tmsg_c_report_myoacquire,\n \tmsg_c_report_myorelease,\n+\tmsg_c_report_myosupportsfeature,\n+\tmsg_c_report_myosharedarenacreate,\n+\tmsg_c_report_myosharedalignedarenamalloc,\n+\tmsg_c_report_myosharedalignedarenafree,\n+\tmsg_c_report_myoarenaacquire,\n+\tmsg_c_report_myoarenarelease,\n \tmsg_c_report_host_total_offload_time,\n \tmsg_c_report_host_initialize,\n \tmsg_c_report_host_target_acquire,\n@@ -182,7 +192,18 @@ enum {\n \tmsg_c_destination_is_over,\n \tmsg_c_slice_of_noncont_array,\n \tmsg_c_pointer_array_mismatch,\n-\tlastMsg = 153,\n+\tmsg_c_in_with_preallocated,\n+\tmsg_c_report_no_host_exe,\n+\tmsg_c_report_path_buff_overflow,\n+\tmsg_c_create_pipeline_for_stream,\n+\tmsg_c_offload_no_stream,\n+\tmsg_c_get_engine_info,\n+\tmsg_c_clear_cpu_mask,\n+\tmsg_c_set_cpu_mask,\n+\tmsg_c_report_state_stream,\n+\tmsg_c_report_stream,\n+\tmsg_c_unload_library,\n+\tlastMsg = 174,\n \tfirstMsg = 1\n };\n \n@@ -192,157 +213,178 @@ enum {\n #endif\n \n static char const * MESSAGE_TABLE_NAME[] = {\n-\t/*   0 __dummy__                               */ \"Un-used message\",\n-\t/*   1 msg_c_device_is_not_available           */ \"offload error: cannot offload to MIC - device is not available\",\n-\t/*   2 msg_c_invalid_device_number             */ \"offload error: expected a number greater than or equal to -1\",\n-\t/*   3 msg_c_send_func_ptr                     */ \"offload error: cannot find function name for address %p\",\n-\t/*   4 msg_c_receive_func_ptr                  */ \"offload error: cannot find address of function %s\",\n-\t/*   5 msg_c_malloc                            */ \"offload error: memory allocation failed\",\n-\t/*   6 msg_c_offload_malloc                    */ \"offload error: memory allocation failed (requested=%lld bytes, align %lld)\",\n-\t/*   7 msg_c_offload1                          */ \"offload error: device %d does not have a pending signal for wait(%p)\",\n-\t/*   8 msg_c_unknown_var_type                  */ \"offload error: unknown variable type %d\",\n-\t/*   9 msg_c_invalid_env_var_value             */ \"offload warning: ignoring invalid value specified for %s\",\n-\t/*  10 msg_c_invalid_env_var_int_value         */ \"offload warning: specify an integer value for %s\",\n-\t/*  11 msg_c_invalid_env_report_value          */ \"offload warning: ignoring %s setting; use a value in range 1-3\",\n-\t/*  12 msg_c_offload_signaled1                 */ \"offload error: invalid device number %d specified in _Offload_signaled\",\n-\t/*  13 msg_c_offload_signaled2                 */ \"offload error: invalid signal %p specified for _Offload_signaled\",\n-\t/*  14 msg_c_myowrapper_checkresult            */ \"offload error: %s failed with error %d\",\n-\t/*  15 msg_c_myotarget_checkresult             */ \"offload error: %s failed with error %d\",\n-\t/*  16 msg_c_offload_descriptor_offload        */ \"offload error: cannot find offload entry %s\",\n-\t/*  17 msg_c_merge_var_descs1                  */ \"offload error: unexpected number of variable descriptors\",\n-\t/*  18 msg_c_merge_var_descs2                  */ \"offload error: unexpected variable type\",\n-\t/*  19 msg_c_mic_parse_env_var_list1           */ \"offload_error: MIC environment variable must begin with an alpabetic character\",\n-\t/*  20 msg_c_mic_parse_env_var_list2           */ \"offload_error: MIC environment variable value must be specified with \\'=\\'\",\n-\t/*  21 msg_c_mic_process_exit_ret              */ \"offload error: process on the device %d unexpectedly exited with code %d\",\n-\t/*  22 msg_c_mic_process_exit_sig              */ \"offload error: process on the device %d was terminated by signal %d (%s)\",\n-\t/*  23 msg_c_mic_process_exit                  */ \"offload error: process on the device %d was unexpectedly terminated\",\n-\t/*  24 msg_c_mic_init3                         */ \"offload warning: ignoring MIC_STACKSIZE setting; use a value >= 16K and a multiple of 4K\",\n-\t/*  25 msg_c_mic_init4                         */ \"offload error: thread key create failed with error %d\",\n-\t/*  26 msg_c_mic_init5                         */ \"offload warning: specify OFFLOAD_DEVICES as comma-separated physical device numbers or 'none'\",\n-\t/*  27 msg_c_mic_init6                         */ \"offload warning: OFFLOAD_DEVICES device number %d does not correspond to a physical device\",\n-\t/*  28 msg_c_no_static_var_data                */ \"offload error: cannot find data associated with statically allocated variable %p\",\n-\t/*  29 msg_c_no_ptr_data                       */ \"offload error: cannot find data associated with pointer variable %p\",\n-\t/*  30 msg_c_get_engine_handle                 */ \"offload error: cannot get device %d handle (error code %d)\",\n-\t/*  31 msg_c_get_engine_index                  */ \"offload error: cannot get physical index for logical device %d (error code %d)\",\n-\t/*  32 msg_c_process_create                    */ \"offload error: cannot start process on the device %d (error code %d)\",\n-\t/*  33 msg_c_process_get_func_handles          */ \"offload error: cannot get function handles on the device %d (error code %d)\",\n-\t/*  34 msg_c_process_wait_shutdown             */ \"offload error: wait for process shutdown failed on device %d (error code %d)\",\n-\t/*  35 msg_c_process_proxy_flush               */ \"offload error: cannot flush process output on device %d (error code %d)\",\n-\t/*  36 msg_c_load_library                      */ \"offload error: cannot load library to the device %d (error code %d)\",\n-\t/*  37 msg_c_pipeline_create                   */ \"offload error: cannot create pipeline on the device %d (error code %d)\",\n-\t/*  38 msg_c_pipeline_run_func                 */ \"offload error: cannot execute function on the device %d (error code %d)\",\n-\t/*  39 msg_c_pipeline_start_run_funcs          */ \"offload error: cannot start executing pipeline function on the device %d (error code %d)\",\n-\t/*  40 msg_c_buf_create                        */ \"offload error: cannot create buffer on device %d (error code %d)\",\n-\t/*  41 msg_c_buf_create_out_of_mem             */ \"offload error: cannot create buffer on device %d, out of memory\",\n-\t/*  42 msg_c_buf_create_from_mem               */ \"offload error: cannot create buffer from memory on device %d (error code %d)\",\n-\t/*  43 msg_c_buf_destroy                       */ \"offload error: buffer destroy failed (error code %d)\",\n-\t/*  44 msg_c_buf_map                           */ \"offload error: buffer map failed (error code %d)\",\n-\t/*  45 msg_c_buf_unmap                         */ \"offload error: buffer unmap failed (error code %d)\",\n-\t/*  46 msg_c_buf_read                          */ \"offload error: buffer read failed (error code %d)\",\n-\t/*  47 msg_c_buf_write                         */ \"offload error: buffer write failed (error code %d)\",\n-\t/*  48 msg_c_buf_copy                          */ \"offload error: buffer copy failed (error code %d)\",\n-\t/*  49 msg_c_buf_get_address                   */ \"offload error: cannot get buffer address on device %d (error code %d)\",\n-\t/*  50 msg_c_buf_add_ref                       */ \"offload error: cannot reuse buffer memory on device %d (error code %d)\",\n-\t/*  51 msg_c_buf_release_ref                   */ \"offload error: cannot release buffer memory on device %d (error code %d)\",\n-\t/*  52 msg_c_buf_set_state                     */ \"offload error: buffer set state failed (error code %d)\",\n-\t/*  53 msg_c_event_wait                        */ \"offload error: wait for event to become signaled failed (error code %d)\",\n-\t/*  54 msg_c_zero_or_neg_ptr_len               */ \"offload error: memory allocation of negative length is not supported\",\n-\t/*  55 msg_c_zero_or_neg_transfer_size         */ \"offload error: data transfer of zero or negative size is not supported\",\n-\t/*  56 msg_c_bad_ptr_mem_range                 */ \"offload error: address range partially overlaps with existing allocation\",\n-\t/*  57 msg_c_different_src_and_dstn_sizes      */ \"offload error: size of the source %d differs from size of the destination %d\",\n-\t/*  58 msg_c_non_contiguous_dope_vector        */ \"offload error: offload data transfer supports only a single contiguous memory range per variable\",\n-\t/*  59 msg_c_omp_invalid_device_num_env        */ \"offload warning: ignoring %s setting; use a non-negative integer value\",\n-\t/*  60 msg_c_omp_invalid_device_num            */ \"offload error: device number should be a non-negative integer value\",\n-\t/*  61 msg_c_unknown_binary_type               */ \"offload error: unexpected embedded target binary type, expected either an executable or shared library\",\n-\t/*  62 msg_c_multiple_target_exes              */ \"offload error: more that one target executable found\",\n-\t/*  63 msg_c_no_target_exe                     */ \"offload error: target executable is not available\",\n-\t/*  64 msg_c_report_unknown_timer_node         */ \"offload error: unknown timer node\",\n-\t/*  65 msg_c_report_unknown_trace_node         */ \"offload error: unknown trace node\",\n-\t/*  66 msg_c_report_host                       */ \"HOST\",\n-\t/*  67 msg_c_report_mic                        */ \"MIC\",\n-\t/*  68 msg_c_report_title                      */ \"timer data       (sec)\",\n-\t/*  69 msg_c_report_seconds                    */ \"(seconds)\",\n-\t/*  70 msg_c_report_bytes                      */ \"(bytes)\",\n-\t/*  71 msg_c_report_cpu_time                   */ \"CPU Time\",\n-\t/*  72 msg_c_report_mic_time                   */ \"MIC Time\",\n-\t/*  73 msg_c_report_tag                        */ \"Tag\",\n-\t/*  74 msg_c_report_from_file                  */ \"Offload from file\",\n-\t/*  75 msg_c_report_file                       */ \"File\",\n-\t/*  76 msg_c_report_line                       */ \"Line\",\n-\t/*  77 msg_c_report_cpu_to_mic_data            */ \"CPU->MIC Data\",\n-\t/*  78 msg_c_report_mic_to_cpu_data            */ \"MIC->CPU Data\",\n-\t/*  79 msg_c_report_offload                    */ \"Offload\",\n-\t/*  80 msg_c_report_w_tag                      */ \"Tag %d\",\n-\t/*  81 msg_c_report_state                      */ \"State\",\n-\t/*  82 msg_c_report_start                      */ \"Start target\",\n-\t/*  83 msg_c_report_init                       */ \"Initialize\",\n-\t/*  84 msg_c_report_logical_card               */ \"logical card\",\n-\t/*  85 msg_c_report_physical_card              */ \"physical card\",\n-\t/*  86 msg_c_report_register                   */ \"Register static data tables\",\n-\t/*  87 msg_c_report_init_func                  */ \"Setup target entry\",\n-\t/*  88 msg_c_report_create_buf_host            */ \"Create host buffer\",\n-\t/*  89 msg_c_report_create_buf_mic             */ \"Create target buffer\",\n-\t/*  90 msg_c_report_send_pointer_data          */ \"Send pointer data\",\n-\t/*  91 msg_c_report_sent_pointer_data          */ \"Host->target pointer data\",\n-\t/*  92 msg_c_report_gather_copyin_data         */ \"Gather copyin data\",\n-\t/*  93 msg_c_report_copyin_data                */ \"Host->target copyin data\",\n-\t/*  94 msg_c_report_state_signal               */ \"Signal\",\n-\t/*  95 msg_c_report_signal                     */ \"signal :\",\n-\t/*  96 msg_c_report_wait                       */ \"waits  :\",\n-\t/*  97 msg_c_report_compute                    */ \"Execute task on target\",\n-\t/*  98 msg_c_report_receive_pointer_data       */ \"Receive pointer data\",\n-\t/*  99 msg_c_report_received_pointer_data      */ \"Target->host pointer data\",\n-\t/* 100 msg_c_report_start_target_func          */ \"Start target entry\",\n-\t/* 101 msg_c_report_var                        */ \"Var\",\n-\t/* 102 msg_c_report_scatter_copyin_data        */ \"Scatter copyin data\",\n-\t/* 103 msg_c_report_gather_copyout_data        */ \"Gather copyout data\",\n-\t/* 104 msg_c_report_scatter_copyout_data       */ \"Scatter copyout data\",\n-\t/* 105 msg_c_report_copyout_data               */ \"Target->host copyout data\",\n-\t/* 106 msg_c_report_unregister                 */ \"Unregister data tables\",\n-\t/* 107 msg_c_report_destroy                    */ \"Destroy\",\n-\t/* 108 msg_c_report_myoinit                    */ \"Initialize MYO\",\n-\t/* 109 msg_c_report_myoregister                */ \"Register MYO tables\",\n-\t/* 110 msg_c_report_myofini                    */ \"Finalize MYO\",\n-\t/* 111 msg_c_report_mic_myo_shared             */ \"MIC MYO shared table register\",\n-\t/* 112 msg_c_report_mic_myo_fptr               */ \"MIC MYO fptr table register\",\n-\t/* 113 msg_c_report_myosharedmalloc            */ \"MYO shared malloc\",\n-\t/* 114 msg_c_report_myosharedfree              */ \"MYO shared free\",\n-\t/* 115 msg_c_report_myosharedalignedmalloc     */ \"MYO shared aligned malloc\",\n-\t/* 116 msg_c_report_myosharedalignedfree       */ \"MYO shared aligned free\",\n-\t/* 117 msg_c_report_myoacquire                 */ \"MYO acquire\",\n-\t/* 118 msg_c_report_myorelease                 */ \"MYO release\",\n-\t/* 119 msg_c_report_host_total_offload_time    */ \"host: total offload time\",\n-\t/* 120 msg_c_report_host_initialize            */ \"host: initialize target\",\n-\t/* 121 msg_c_report_host_target_acquire        */ \"host: acquire target\",\n-\t/* 122 msg_c_report_host_wait_deps             */ \"host: wait dependencies\",\n-\t/* 123 msg_c_report_host_setup_buffers         */ \"host: setup buffers\",\n-\t/* 124 msg_c_report_host_alloc_buffers         */ \"host: allocate buffers\",\n-\t/* 125 msg_c_report_host_setup_misc_data       */ \"host: setup misc_data\",\n-\t/* 126 msg_c_report_host_alloc_data_buffer     */ \"host: allocate buffer\",\n-\t/* 127 msg_c_report_host_send_pointers         */ \"host: send pointers\",\n-\t/* 128 msg_c_report_host_gather_inputs         */ \"host: gather inputs\",\n-\t/* 129 msg_c_report_host_map_in_data_buffer    */ \"host: map IN data buffer\",\n-\t/* 130 msg_c_report_host_unmap_in_data_buffer  */ \"host: unmap IN data buffer\",\n-\t/* 131 msg_c_report_host_start_compute         */ \"host: initiate compute\",\n-\t/* 132 msg_c_report_host_wait_compute          */ \"host: wait compute\",\n-\t/* 133 msg_c_report_host_start_buffers_reads   */ \"host: initiate pointer reads\",\n-\t/* 134 msg_c_report_host_scatter_outputs       */ \"host: scatter outputs\",\n-\t/* 135 msg_c_report_host_map_out_data_buffer   */ \"host: map OUT data buffer\",\n-\t/* 136 msg_c_report_host_unmap_out_data_buffer */ \"host: unmap OUT data buffer\",\n-\t/* 137 msg_c_report_host_wait_buffers_reads    */ \"host: wait pointer reads\",\n-\t/* 138 msg_c_report_host_destroy_buffers       */ \"host: destroy buffers\",\n-\t/* 139 msg_c_report_target_total_time          */ \"target: total time\",\n-\t/* 140 msg_c_report_target_descriptor_setup    */ \"target: setup offload descriptor\",\n-\t/* 141 msg_c_report_target_func_lookup         */ \"target: entry lookup\",\n-\t/* 142 msg_c_report_target_func_time           */ \"target: entry time\",\n-\t/* 143 msg_c_report_target_scatter_inputs      */ \"target: scatter inputs\",\n-\t/* 144 msg_c_report_target_add_buffer_refs     */ \"target: add buffer reference\",\n-\t/* 145 msg_c_report_target_compute             */ \"target: compute\",\n-\t/* 146 msg_c_report_target_gather_outputs      */ \"target: gather outputs\",\n-\t/* 147 msg_c_report_target_release_buffer_refs */ \"target: remove buffer reference\",\n-\t/* 148 msg_c_coi_pipeline_max_number           */ \"number of host threads doing offload exceeds maximum of %d\",\n-\t/* 149 msg_c_ranges_dont_match                 */ \"ranges of source and destination don't match together\",\n-\t/* 150 msg_c_destination_is_over               */ \"insufficient destination memory to transfer source\",\n-\t/* 151 msg_c_slice_of_noncont_array            */ \"a non-contiguous slice may be taken of contiguous arrays only\",\n-\t/* 152 msg_c_pointer_array_mismatch            */ \"number of %s elements is less than described by the source\",\n+\t/*   0 __dummy__                                */ \"Un-used message\",\n+\t/*   1 msg_c_device_is_not_available            */ \"offload error: cannot offload to MIC - device is not available\",\n+\t/*   2 msg_c_invalid_device_number              */ \"offload error: expected a number greater than or equal to -1\",\n+\t/*   3 msg_c_send_func_ptr                      */ \"offload error: cannot find function name for address %p\",\n+\t/*   4 msg_c_receive_func_ptr                   */ \"offload error: cannot find address of function %s\",\n+\t/*   5 msg_c_malloc                             */ \"offload error: memory allocation failed\",\n+\t/*   6 msg_c_offload_malloc                     */ \"offload error: memory allocation failed (requested=%lld bytes, align %lld)\",\n+\t/*   7 msg_c_offload1                           */ \"offload error: device %d does not have a pending signal for wait(%p)\",\n+\t/*   8 msg_c_unknown_var_type                   */ \"offload error: unknown variable type %d\",\n+\t/*   9 msg_c_invalid_env_var_value              */ \"offload warning: ignoring invalid value specified for %s\",\n+\t/*  10 msg_c_invalid_env_var_int_value          */ \"offload warning: specify an integer value for %s\",\n+\t/*  11 msg_c_invalid_env_report_value           */ \"offload warning: ignoring %s setting; use a value in range 1-3\",\n+\t/*  12 msg_c_offload_signaled1                  */ \"offload error: invalid device number %d specified in _Offload_signaled\",\n+\t/*  13 msg_c_offload_signaled2                  */ \"offload error: invalid signal %p specified for _Offload_signaled\",\n+\t/*  14 msg_c_myowrapper_checkresult             */ \"offload error: %s failed with error %d\",\n+\t/*  15 msg_c_myotarget_checkresult              */ \"offload error: %s failed with error %d\",\n+\t/*  16 msg_c_offload_descriptor_offload         */ \"offload error: cannot find offload entry %s\",\n+\t/*  17 msg_c_merge_var_descs1                   */ \"offload error: unexpected number of variable descriptors\",\n+\t/*  18 msg_c_merge_var_descs2                   */ \"offload error: unexpected variable type\",\n+\t/*  19 msg_c_mic_parse_env_var_list1            */ \"offload_error: MIC environment variable must begin with an alpabetic character\",\n+\t/*  20 msg_c_mic_parse_env_var_list2            */ \"offload_error: MIC environment variable value must be specified with '='\",\n+\t/*  21 msg_c_mic_process_exit_ret               */ \"offload error: process on the device %d unexpectedly exited with code %d\",\n+\t/*  22 msg_c_mic_process_exit_sig               */ \"offload error: process on the device %d was terminated by signal %d (%s)\",\n+\t/*  23 msg_c_mic_process_exit                   */ \"offload error: process on the device %d was unexpectedly terminated\",\n+\t/*  24 msg_c_mic_init3                          */ \"offload warning: ignoring MIC_STACKSIZE setting; use a value >= 16K and a multiple of 4K\",\n+\t/*  25 msg_c_mic_init4                          */ \"offload error: thread key create failed with error %d\",\n+\t/*  26 msg_c_mic_init5                          */ \"offload warning: specify OFFLOAD_DEVICES as comma-separated physical device numbers or 'none'\",\n+\t/*  27 msg_c_mic_init6                          */ \"offload warning: OFFLOAD_DEVICES device number %d does not correspond to a physical device\",\n+\t/*  28 msg_c_no_static_var_data                 */ \"offload error: cannot find data associated with statically allocated variable %p\",\n+\t/*  29 msg_c_no_ptr_data                        */ \"offload error: cannot find data associated with pointer variable %p\",\n+\t/*  30 msg_c_get_engine_handle                  */ \"offload error: cannot get device %d handle (error code %d)\",\n+\t/*  31 msg_c_get_engine_index                   */ \"offload error: cannot get physical index for logical device %d (error code %d)\",\n+\t/*  32 msg_c_process_create                     */ \"offload error: cannot start process on the device %d (error code %d)\",\n+\t/*  33 msg_c_process_set_cache_size             */ \"offload error: cannot reserve buffer on the device %d (error code %d)\",\n+\t/*  34 msg_c_process_get_func_handles           */ \"offload error: cannot get function handles on the device %d (error code %d)\",\n+\t/*  35 msg_c_process_wait_shutdown              */ \"offload error: wait for process shutdown failed on device %d (error code %d)\",\n+\t/*  36 msg_c_process_proxy_flush                */ \"offload error: cannot flush process output on device %d (error code %d)\",\n+\t/*  37 msg_c_load_library                       */ \"offload error: cannot load library to the device %d (error code %d)\",\n+\t/*  38 msg_c_pipeline_create                    */ \"offload error: cannot create pipeline on the device %d (error code %d)\",\n+\t/*  39 msg_c_pipeline_run_func                  */ \"offload error: cannot execute function on the device %d (error code %d)\",\n+\t/*  40 msg_c_pipeline_start_run_funcs           */ \"offload error: cannot start executing pipeline function on the device %d (error code %d)\",\n+\t/*  41 msg_c_buf_create                         */ \"offload error: cannot create buffer on device %d (error code %d)\",\n+\t/*  42 msg_c_buf_create_out_of_mem              */ \"offload error: cannot create buffer on device %d, out of memory\",\n+\t/*  43 msg_c_buf_create_from_mem                */ \"offload error: cannot create buffer from memory on device %d (error code %d)\",\n+\t/*  44 msg_c_buf_destroy                        */ \"offload error: buffer destroy failed (error code %d)\",\n+\t/*  45 msg_c_buf_map                            */ \"offload error: buffer map failed (error code %d)\",\n+\t/*  46 msg_c_buf_unmap                          */ \"offload error: buffer unmap failed (error code %d)\",\n+\t/*  47 msg_c_buf_read                           */ \"offload error: buffer read failed (error code %d)\",\n+\t/*  48 msg_c_buf_write                          */ \"offload error: buffer write failed (error code %d)\",\n+\t/*  49 msg_c_buf_copy                           */ \"offload error: buffer copy failed (error code %d)\",\n+\t/*  50 msg_c_buf_get_address                    */ \"offload error: cannot get buffer address on device %d (error code %d)\",\n+\t/*  51 msg_c_buf_add_ref                        */ \"offload error: cannot reuse buffer memory on device %d (error code %d)\",\n+\t/*  52 msg_c_buf_release_ref                    */ \"offload error: cannot release buffer memory on device %d (error code %d)\",\n+\t/*  53 msg_c_buf_set_state                      */ \"offload error: buffer set state failed (error code %d)\",\n+\t/*  54 msg_c_event_wait                         */ \"offload error: wait for event to become signaled failed (error code %d)\",\n+\t/*  55 msg_c_zero_or_neg_ptr_len                */ \"offload error: memory allocation of zero or negative length is not supported\",\n+\t/*  56 msg_c_zero_or_neg_transfer_size          */ \"offload error: data transfer of zero or negative size is not supported\",\n+\t/*  57 msg_c_bad_ptr_mem_alloc                  */ \"offload error: allocation (base=%p, size=%d) overlaps with existing allocation (base=%p, size=%d)\",\n+\t/*  58 msg_c_bad_ptr_mem_range                  */ \"offload error: data transfer (base=%p, size=%d) not subset of existing allocation (base=%p, size=%d)\",\n+\t/*  59 msg_c_different_src_and_dstn_sizes       */ \"offload error: size of the source %d differs from size of the destination %d\",\n+\t/*  60 msg_c_non_contiguous_dope_vector         */ \"offload error: offload data transfer supports only a single contiguous memory range per variable\",\n+\t/*  61 msg_c_omp_invalid_device_num_env         */ \"offload warning: ignoring %s setting; use a non-negative integer value\",\n+\t/*  62 msg_c_omp_invalid_device_num             */ \"offload error: device number should be a non-negative integer value\",\n+\t/*  63 msg_c_unknown_binary_type                */ \"offload error: unexpected embedded target binary type, expected either an executable or shared library\",\n+\t/*  64 msg_c_multiple_target_exes               */ \"offload error: more that one target executable found\",\n+\t/*  65 msg_c_no_target_exe                      */ \"offload error: target executable is not available\",\n+\t/*  66 msg_c_report_unknown_timer_node          */ \"offload error: unknown timer node\",\n+\t/*  67 msg_c_report_unknown_trace_node          */ \"offload error: unknown trace node\",\n+\t/*  68 msg_c_incorrect_affinity                 */ \"offload error: unknow affinity type %s, specify compact, scatter or balanced\",\n+\t/*  69 msg_c_cannot_set_affinity                */ \"offload_error: unable to set affinity\",\n+\t/*  70 msg_c_report_host                        */ \"HOST\",\n+\t/*  71 msg_c_report_mic                         */ \"MIC\",\n+\t/*  72 msg_c_report_title                       */ \"timer data       (sec)\",\n+\t/*  73 msg_c_report_seconds                     */ \"(seconds)\",\n+\t/*  74 msg_c_report_bytes                       */ \"(bytes)\",\n+\t/*  75 msg_c_report_cpu_time                    */ \"CPU Time\",\n+\t/*  76 msg_c_report_mic_time                    */ \"MIC Time\",\n+\t/*  77 msg_c_report_tag                         */ \"Tag\",\n+\t/*  78 msg_c_report_from_file                   */ \"Offload from file\",\n+\t/*  79 msg_c_report_file                        */ \"File\",\n+\t/*  80 msg_c_report_line                        */ \"Line\",\n+\t/*  81 msg_c_report_cpu_to_mic_data             */ \"CPU->MIC Data\",\n+\t/*  82 msg_c_report_mic_to_cpu_data             */ \"MIC->CPU Data\",\n+\t/*  83 msg_c_report_offload                     */ \"Offload\",\n+\t/*  84 msg_c_report_w_tag                       */ \"Tag %d\",\n+\t/*  85 msg_c_report_state                       */ \"State\",\n+\t/*  86 msg_c_report_start                       */ \"Start target\",\n+\t/*  87 msg_c_report_init                        */ \"Initialize\",\n+\t/*  88 msg_c_report_logical_card                */ \"logical card\",\n+\t/*  89 msg_c_report_physical_card               */ \"physical card\",\n+\t/*  90 msg_c_report_register                    */ \"Register static data tables\",\n+\t/*  91 msg_c_report_init_func                   */ \"Setup target entry\",\n+\t/*  92 msg_c_report_create_buf_host             */ \"Create host buffer\",\n+\t/*  93 msg_c_report_create_buf_mic              */ \"Create target buffer\",\n+\t/*  94 msg_c_report_send_pointer_data           */ \"Send pointer data\",\n+\t/*  95 msg_c_report_sent_pointer_data           */ \"Host->target pointer data\",\n+\t/*  96 msg_c_report_gather_copyin_data          */ \"Gather copyin data\",\n+\t/*  97 msg_c_report_copyin_data                 */ \"Host->target copyin data\",\n+\t/*  98 msg_c_report_state_signal                */ \"Signal\",\n+\t/*  99 msg_c_report_signal                      */ \"signal :\",\n+\t/* 100 msg_c_report_wait                        */ \"waits  :\",\n+\t/* 101 msg_c_report_compute                     */ \"Execute task on target\",\n+\t/* 102 msg_c_report_receive_pointer_data        */ \"Receive pointer data\",\n+\t/* 103 msg_c_report_received_pointer_data       */ \"Target->host pointer data\",\n+\t/* 104 msg_c_report_start_target_func           */ \"Start target entry\",\n+\t/* 105 msg_c_report_var                         */ \"Var\",\n+\t/* 106 msg_c_report_scatter_copyin_data         */ \"Scatter copyin data\",\n+\t/* 107 msg_c_report_gather_copyout_data         */ \"Gather copyout data\",\n+\t/* 108 msg_c_report_scatter_copyout_data        */ \"Scatter copyout data\",\n+\t/* 109 msg_c_report_copyout_data                */ \"Target->host copyout data\",\n+\t/* 110 msg_c_report_unregister                  */ \"Unregister data tables\",\n+\t/* 111 msg_c_report_destroy                     */ \"Destroy\",\n+\t/* 112 msg_c_report_myoinit                     */ \"Initialize MYO\",\n+\t/* 113 msg_c_report_myoregister                 */ \"Register MYO tables\",\n+\t/* 114 msg_c_report_myofini                     */ \"Finalize MYO\",\n+\t/* 115 msg_c_report_mic_myo_shared              */ \"MIC MYO shared table register\",\n+\t/* 116 msg_c_report_mic_myo_fptr                */ \"MIC MYO fptr table register\",\n+\t/* 117 msg_c_report_myosharedmalloc             */ \"MYO shared malloc\",\n+\t/* 118 msg_c_report_myosharedfree               */ \"MYO shared free\",\n+\t/* 119 msg_c_report_myosharedalignedmalloc      */ \"MYO shared aligned malloc\",\n+\t/* 120 msg_c_report_myosharedalignedfree        */ \"MYO shared aligned free\",\n+\t/* 121 msg_c_report_myoacquire                  */ \"MYO acquire\",\n+\t/* 122 msg_c_report_myorelease                  */ \"MYO release\",\n+\t/* 123 msg_c_report_myosupportsfeature          */ \"MYO supports feature\",\n+\t/* 124 msg_c_report_myosharedarenacreate        */ \"MYO shared arena create\",\n+\t/* 125 msg_c_report_myosharedalignedarenamalloc */ \"MYO shared aligned arena malloc\",\n+\t/* 126 msg_c_report_myosharedalignedarenafree   */ \"MYO shared aligned arena free\",\n+\t/* 127 msg_c_report_myoarenaacquire             */ \"MYO arena acquire\",\n+\t/* 128 msg_c_report_myoarenarelease             */ \"MYO arena release\",\n+\t/* 129 msg_c_report_host_total_offload_time     */ \"host: total offload time\",\n+\t/* 130 msg_c_report_host_initialize             */ \"host: initialize target\",\n+\t/* 131 msg_c_report_host_target_acquire         */ \"host: acquire target\",\n+\t/* 132 msg_c_report_host_wait_deps              */ \"host: wait dependencies\",\n+\t/* 133 msg_c_report_host_setup_buffers          */ \"host: setup buffers\",\n+\t/* 134 msg_c_report_host_alloc_buffers          */ \"host: allocate buffers\",\n+\t/* 135 msg_c_report_host_setup_misc_data        */ \"host: setup misc_data\",\n+\t/* 136 msg_c_report_host_alloc_data_buffer      */ \"host: allocate buffer\",\n+\t/* 137 msg_c_report_host_send_pointers          */ \"host: send pointers\",\n+\t/* 138 msg_c_report_host_gather_inputs          */ \"host: gather inputs\",\n+\t/* 139 msg_c_report_host_map_in_data_buffer     */ \"host: map IN data buffer\",\n+\t/* 140 msg_c_report_host_unmap_in_data_buffer   */ \"host: unmap IN data buffer\",\n+\t/* 141 msg_c_report_host_start_compute          */ \"host: initiate compute\",\n+\t/* 142 msg_c_report_host_wait_compute           */ \"host: wait compute\",\n+\t/* 143 msg_c_report_host_start_buffers_reads    */ \"host: initiate pointer reads\",\n+\t/* 144 msg_c_report_host_scatter_outputs        */ \"host: scatter outputs\",\n+\t/* 145 msg_c_report_host_map_out_data_buffer    */ \"host: map OUT data buffer\",\n+\t/* 146 msg_c_report_host_unmap_out_data_buffer  */ \"host: unmap OUT data buffer\",\n+\t/* 147 msg_c_report_host_wait_buffers_reads     */ \"host: wait pointer reads\",\n+\t/* 148 msg_c_report_host_destroy_buffers        */ \"host: destroy buffers\",\n+\t/* 149 msg_c_report_target_total_time           */ \"target: total time\",\n+\t/* 150 msg_c_report_target_descriptor_setup     */ \"target: setup offload descriptor\",\n+\t/* 151 msg_c_report_target_func_lookup          */ \"target: entry lookup\",\n+\t/* 152 msg_c_report_target_func_time            */ \"target: entry time\",\n+\t/* 153 msg_c_report_target_scatter_inputs       */ \"target: scatter inputs\",\n+\t/* 154 msg_c_report_target_add_buffer_refs      */ \"target: add buffer reference\",\n+\t/* 155 msg_c_report_target_compute              */ \"target: compute\",\n+\t/* 156 msg_c_report_target_gather_outputs       */ \"target: gather outputs\",\n+\t/* 157 msg_c_report_target_release_buffer_refs  */ \"target: remove buffer reference\",\n+\t/* 158 msg_c_coi_pipeline_max_number            */ \"number of host threads doing offload exceeds maximum of %d\",\n+\t/* 159 msg_c_ranges_dont_match                  */ \"ranges of source and destination don't match together\",\n+\t/* 160 msg_c_destination_is_over                */ \"insufficient destination memory to transfer source\",\n+\t/* 161 msg_c_slice_of_noncont_array             */ \"a non-contiguous slice may be taken of contiguous arrays only\",\n+\t/* 162 msg_c_pointer_array_mismatch             */ \"number of %s elements is less than described by the source\",\n+\t/* 163 msg_c_in_with_preallocated               */ \"offload error: preallocated targetptr alloc_if(1) may not be used with an in clause\",\n+\t/* 164 msg_c_report_no_host_exe                 */ \"offload error: Cannot find host executable\",\n+\t/* 165 msg_c_report_path_buff_overflow          */ \"offload error: Size of host executable path exceeded 4KB\",\n+\t/* 166 msg_c_create_pipeline_for_stream         */ \"offload error: number of cpus exceeds maximum of %d\",\n+\t/* 167 msg_c_offload_no_stream                  */ \"offload error: the stream isn't found on device %d\",\n+\t/* 168 msg_c_get_engine_info                    */ \"offload error: cannot get device %d info (error code %d)\",\n+\t/* 169 msg_c_clear_cpu_mask                     */ \"offload error: cannot clear cpu mask (error code %d)\",\n+\t/* 170 msg_c_set_cpu_mask                       */ \"offload error: cannot set cpu mask (error code %d)\",\n+\t/* 171 msg_c_report_state_stream                */ \"Stream\",\n+\t/* 172 msg_c_report_stream                      */ \"stream  :\",\n+\t/* 173 msg_c_unload_library                     */ \"offload error: cannot unload library from the device %d (error code %d)\",\n };"}, {"sha": "1431716777e6db819c2bb4ed967c833d7bcb727c", "filename": "liboffloadmic/runtime/mic_lib.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fmic_lib.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fmic_lib.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fmic_lib.f90?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n !\n-!    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+!    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n !\n !    Redistribution and use in source and binary forms, with or without\n !    modification, are permitted provided that the following conditions"}, {"sha": "5ee06fe24c071165760690a0218aa171a99d088b", "filename": "liboffloadmic/runtime/offload.h", "status": "modified", "additions": 61, "deletions": 5, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -42,6 +42,13 @@\n #include <stddef.h>\n #include <omp.h>\n \n+#ifdef TARGET_WINNT\n+// <stdint.h> is not compatible with Windows\n+typedef unsigned long long int  uint64_t;\n+#else\n+#include <stdint.h>\n+#endif  // TARGET_WINNT\n+\n #ifdef __cplusplus\n extern \"C\" {\n #endif\n@@ -86,6 +93,8 @@ typedef struct {\n     size_t          data_received;  /* number of bytes received by host */\n } _Offload_status;\n \n+typedef uint64_t _Offload_stream;\n+\n #define OFFLOAD_STATUS_INIT(x) \\\n     ((x).result = OFFLOAD_DISABLED)\n \n@@ -98,14 +107,57 @@ extern int _Offload_number_of_devices(void);\n extern int _Offload_get_device_number(void);\n extern int _Offload_get_physical_device_number(void);\n \n+/* Offload stream runtime interfaces */\n+\n+extern _Offload_stream _Offload_stream_create(\n+    int device,           // MIC device number\n+    int number_of_cpus    // Cores allocated to the stream\n+);\n+\n+extern int _Offload_stream_destroy(\n+    int device,             // MIC device number\n+    _Offload_stream stream  // stream handle\n+);\n+\n+extern int _Offload_stream_completed(\n+    int device,             // MIC device number\n+    _Offload_stream handle  // stream handle\n+);\n+\n+/*\n+ * _Offload_shared_malloc/free are only supported when offload is enabled\n+ * else they are defined to malloc and free\n+*/\n+#ifdef __INTEL_OFFLOAD\n extern void* _Offload_shared_malloc(size_t size);\n extern void  _Offload_shared_free(void *ptr);\n-\n extern void* _Offload_shared_aligned_malloc(size_t size, size_t align);\n extern void  _Offload_shared_aligned_free(void *ptr);\n+#else\n+#include <malloc.h>\n+#define _Offload_shared_malloc(size)                 malloc(size)\n+#define _Offload_shared_free(ptr)                    free(ptr);\n+#if defined(_WIN32)\n+#define _Offload_shared_aligned_malloc(size, align)  _aligned_malloc(size, align)\n+#define _Offload_shared_aligned_free(ptr)            _aligned_free(ptr);\n+#else\n+#define _Offload_shared_aligned_malloc(size, align)  memalign(align, size)\n+#define _Offload_shared_aligned_free(ptr)            free(ptr);\n+#endif\n+#endif\n+\n \n extern int _Offload_signaled(int index, void *signal);\n extern void _Offload_report(int val);\n+extern int _Offload_find_associated_mic_memory(\n+   int           target,\n+   const void*   cpu_addr,\n+   void**        cpu_base_addr,\n+   uint64_t*     buf_length,\n+   void**        mic_addr,\n+   uint64_t*     mic_buf_start_offset,\n+   int*          is_static\n+);\n \n /* OpenMP API */\n \n@@ -343,7 +395,11 @@ namespace __offload {\n                                 shared_allocator<void>::const_pointer) {\n     /* Allocate from shared memory. */\n     void *ptr = _Offload_shared_malloc(s*sizeof(T));\n-    if (ptr == 0) std::__throw_bad_alloc();\n+#if (defined(_WIN32) || defined(_WIN64))   /* Windows */\n+        if (ptr == 0) throw std::bad_alloc();\n+#else\n+        if (ptr == 0) std::__throw_bad_alloc();\n+#endif\n     return static_cast<pointer>(ptr);\n   } /* allocate */\n \n@@ -355,13 +411,13 @@ namespace __offload {\n   } /* deallocate */\n \n   template <typename _T1, typename _T2>\n-  inline bool operator==(const shared_allocator<_T1> &, \n+  inline bool operator==(const shared_allocator<_T1> &,\n                          const shared_allocator<_T2> &) throw() {\n     return true;\n   }  /* operator== */\n \n   template <typename _T1, typename _T2>\n-  inline bool operator!=(const shared_allocator<_T1> &, \n+  inline bool operator!=(const shared_allocator<_T1> &,\n                          const shared_allocator<_T2> &) throw() {\n     return false;\n   }  /* operator!= */"}, {"sha": "200def566c594db7cb23d0f6920832ccb1c21fb1", "filename": "liboffloadmic/runtime/offload_common.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_common.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_common.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "0fb66b553b73ab1cadfb024e3dba2a946451df58", "filename": "liboffloadmic/runtime/offload_common.h", "status": "modified", "additions": 76, "deletions": 37, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_common.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -40,10 +40,6 @@\n #include <string.h>\n #include <memory.h>\n \n-#if (defined(LINUX) || defined(FREEBSD)) && !defined(__INTEL_COMPILER)\n-#include <mm_malloc.h>\n-#endif\n-\n #include \"offload.h\"\n #include \"offload_table.h\"\n #include \"offload_trace.h\"\n@@ -65,22 +61,24 @@\n // The debug routines\n \n // Host console and file logging\n-extern int console_enabled;\n-extern int offload_report_level;\n+DLL_LOCAL extern int console_enabled;\n+DLL_LOCAL extern int offload_report_level;\n \n-#define OFFLOAD_DO_TRACE (offload_report_level == 3)\n \n-extern const char *prefix;\n-extern int offload_number;\n+DLL_LOCAL extern const char *prefix;\n+DLL_LOCAL extern int offload_number;\n #if !HOST_LIBRARY\n-extern int mic_index;\n+DLL_LOCAL extern int mic_index;\n+#define OFFLOAD_DO_TRACE (offload_report_level == 3)\n+#else\n+#define OFFLOAD_DO_TRACE (offload_report_enabled && (offload_report_level == 3))\n #endif\n \n #if HOST_LIBRARY\n-void Offload_Report_Prolog(OffloadHostTimerData* timer_data);\n-void Offload_Report_Epilog(OffloadHostTimerData* timer_data);\n-void offload_report_free_data(OffloadHostTimerData * timer_data);\n-void Offload_Timer_Print(void);\n+DLL_LOCAL void Offload_Report_Prolog(OffloadHostTimerData* timer_data);\n+DLL_LOCAL void Offload_Report_Epilog(OffloadHostTimerData* timer_data);\n+DLL_LOCAL void offload_report_free_data(OffloadHostTimerData * timer_data);\n+DLL_LOCAL void Offload_Timer_Print(void);\n \n #ifndef TARGET_WINNT\n #define OFFLOAD_DEBUG_INCR_OFLD_NUM() \\\n@@ -130,7 +128,7 @@ void Offload_Timer_Print(void);\n #define OFFLOAD_DEBUG_DUMP_BYTES(level, a, b) \\\n     __dump_bytes(level, a, b)\n \n-extern void __dump_bytes(\n+DLL_LOCAL extern void __dump_bytes(\n     int level,\n     const void *data,\n     int len\n@@ -156,6 +154,17 @@ extern void *OFFLOAD_MALLOC(size_t size, size_t align);\n \n // The Marshaller\n \n+// Flags describing an offload\n+\n+//! Flags describing an offload\n+union OffloadFlags{\n+    uint32_t flags;\n+    struct {\n+        uint32_t fortran_traceback : 1; //!< Fortran traceback requested\n+        uint32_t omp_async         : 1; //!< OpenMP asynchronous offload\n+    } bits;\n+};\n+\n //! \\enum Indicator for the type of entry on an offload item list.\n enum OffloadItemType {\n     c_data =   1,       //!< Plain data\n@@ -203,6 +212,44 @@ enum OffloadParameterType {\n     c_parameter_inout         //!< Variable listed in \"inout\" clause\n };\n \n+\n+//! Flags describing an offloaded variable\n+union varDescFlags {\n+    struct {\n+        //! source variable has persistent storage\n+        uint32_t is_static : 1;\n+        //! destination variable has persistent storage\n+        uint32_t is_static_dstn : 1;\n+        //! has length for c_dv && c_dv_ptr\n+        uint32_t has_length : 1;\n+        //! persisted local scalar is in stack buffer\n+        uint32_t is_stack_buf : 1;\n+        //! \"targetptr\" modifier used\n+        uint32_t targetptr : 1;\n+        //! \"preallocated\" modifier used\n+        uint32_t preallocated : 1;\n+        //! Needs documentation\n+        uint32_t is_pointer : 1;\n+\n+        //! buffer address is sent in data\n+        uint32_t sink_addr : 1;\n+        //! alloc displacement is sent in data\n+        uint32_t alloc_disp : 1;\n+        //! source data is noncontiguous\n+        uint32_t is_noncont_src : 1;\n+        //! destination data is noncontiguous\n+        uint32_t is_noncont_dst : 1;\n+\n+        //! \"OpenMP always\" modifier used\n+        uint32_t always_copy : 1;\n+        //! \"OpenMP delete\" modifier used\n+        uint32_t always_delete : 1;\n+        //! CPU memory pinning/unpinning operation\n+        uint32_t pin : 1;\n+    };\n+    uint32_t bits;\n+};\n+\n //! An Offload Variable descriptor\n struct VarDesc {\n     //! OffloadItemTypes of source and destination\n@@ -230,27 +277,7 @@ struct VarDesc {\n     /*! Used by runtime as offset to data from start of MIC buffer */\n     uint32_t mic_offset;\n     //! Flags describing this variable\n-    union {\n-        struct {\n-            //! source variable has persistent storage\n-            uint32_t is_static : 1;\n-            //! destination variable has persistent storage\n-            uint32_t is_static_dstn : 1;\n-            //! has length for c_dv && c_dv_ptr\n-            uint32_t has_length : 1;\n-            //! persisted local scalar is in stack buffer\n-            uint32_t is_stack_buf : 1;\n-            //! buffer address is sent in data\n-            uint32_t sink_addr : 1;\n-            //! alloc displacement is sent in data\n-            uint32_t alloc_disp : 1;\n-            //! source data is noncontiguous\n-            uint32_t is_noncont_src : 1;\n-            //! destination data is noncontiguous\n-            uint32_t is_noncont_dst : 1;\n-        };\n-        uint32_t bits;\n-    } flags;\n+    varDescFlags flags;\n     //! Not used by compiler; set to 0\n     /*! Used by runtime as offset to base from data stored in a buffer */\n     int64_t offset;\n@@ -472,4 +499,16 @@ struct FunctionDescriptor\n // Pointer to OffloadDescriptor.\n typedef struct OffloadDescriptor *OFFLOAD;\n \n+// Use for setting affinity of a stream\n+enum affinity_type {\n+    affinity_compact,\n+    affinity_scatter\n+};\n+struct affinity_spec {\n+    uint64_t sink_mask[16];\n+    int affinity_type;\n+    int num_cores;\n+    int num_threads;\n+};\n+\n #endif // OFFLOAD_COMMON_H_INCLUDED"}, {"sha": "16b440d7ab614073a6eaaf90d59bd80fce1e2ddb", "filename": "liboffloadmic/runtime/offload_engine.cpp", "status": "modified", "additions": 387, "deletions": 41, "changes": 428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_engine.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -37,6 +37,14 @@\n \n #include \"offload_host.h\"\n #include \"offload_table.h\"\n+#include \"offload_iterator.h\"\n+\n+// Static members of Stream class must be described somewhere.\n+// This members describe the list of all streams defined in programm\n+// via call to _Offload_stream_create.\n+uint64_t  Stream::m_streams_count = 0;\n+StreamMap Stream::all_streams;\n+mutex_t   Stream::m_stream_lock;\n \n const char* Engine::m_func_names[Engine::c_funcs_total] =\n {\n@@ -47,7 +55,8 @@ const char* Engine::m_func_names[Engine::c_funcs_total] =\n #endif // MYO_SUPPORT\n     \"server_init\",\n     \"server_var_table_size\",\n-    \"server_var_table_copy\"\n+    \"server_var_table_copy\",\n+    \"server_set_stream_affinity\"\n };\n \n // Symbolic representation of system signals. Fix for CQ233593\n@@ -115,6 +124,7 @@ void Engine::init_process(void)\n     COIENGINE engine;\n     COIRESULT res;\n     const char **environ;\n+    char buf[4096];  // For exe path name\n \n     // create environment for the target process\n     environ = (const char**) mic_env_vars.create_environ_for_card(m_index);\n@@ -127,39 +137,147 @@ void Engine::init_process(void)\n     // Create execution context in the specified device\n     OFFLOAD_DEBUG_TRACE(2, \"Getting device %d (engine %d) handle\\n\", m_index,\n                         m_physical_index);\n-    res = COI::EngineGetHandle(COI_ISA_KNC, m_physical_index, &engine);\n+    res = COI::EngineGetHandle(COI_ISA_MIC, m_physical_index, &engine);\n     check_result(res, c_get_engine_handle, m_index, res);\n \n-    // Target executable should be available by the time when we\n-    // attempt to initialize the device\n+    // Get engine info on threads and cores.\n+    // The values of core number and thread number will be used later at stream\n+    // creation by call to _Offload_stream_create(device,number_of_cpus).\n+\n+    COI_ENGINE_INFO engine_info;\n+\n+    res = COI::EngineGetInfo(engine, sizeof(COI_ENGINE_INFO), &engine_info);\n+    check_result(res, c_get_engine_info, m_index, res);\n+\n+    // m_cpus bitset has 1 for available thread. At the begining all threads\n+    // are available and m_cpus(i) is set to\n+    // 1 for i = [0...engine_info.NumThreads].\n+    m_cpus.reset();\n+    for (int i = 0; i < engine_info.NumThreads; i++) {\n+         m_cpus.set(i);\n+    }\n+\n+    // The following values will be used at pipeline creation for streams\n+    m_num_cores = engine_info.NumCores;\n+    m_num_threads = engine_info.NumThreads;\n+\n+    // Check if OFFLOAD_DMA_CHANNEL_COUNT is set to 2\n+    // Only the value 2 is supported in 16.0\n+    if (mic_dma_channel_count == 2) {\n+        if (COI::ProcessConfigureDMA) {\n+            // Set DMA channels using COI API\n+            COI::ProcessConfigureDMA(2, COI::DMA_MODE_READ_WRITE);\n+        }\n+        else {\n+            // Set environment variable COI_DMA_CHANNEL_COUNT\n+            // use putenv instead of setenv as Windows has no setenv.\n+            // Note: putenv requires its argument can't be freed or modified.\n+            // So no free after call to putenv or elsewhere.\n+            char * env_var = (char*) malloc(sizeof(\"COI_DMA_CHANNEL_COUNT=2\" + 1));\n+            sprintf(env_var, \"COI_DMA_CHANNEL_COUNT=2\");\n+            putenv(env_var);  \n+        }\n+    }\n+\n+    // Target executable is not available then use compiler provided offload_main\n     if (__target_exe == 0) {\n-        LIBOFFLOAD_ERROR(c_no_target_exe);\n-        exit(1);\n+       if (mic_device_main == 0)\n+          LIBOFFLOAD_ERROR(c_report_no_host_exe);\n+\n+       OFFLOAD_DEBUG_TRACE(2,\n+           \"Loading target executable %s\\n\",mic_device_main);\n+\n+       res = COI::ProcessCreateFromFile(\n+           engine,                 // in_Engine\n+           mic_device_main,        // in_pBinaryName\n+           0,                      // in_Argc\n+           0,                      // in_ppArgv\n+           environ == 0,           // in_DupEnv\n+           environ,                // in_ppAdditionalEnv\n+           mic_proxy_io,           // in_ProxyActive\n+           mic_proxy_fs_root,      // in_ProxyfsRoot\n+           mic_buffer_size,        // in_BufferSpace\n+           mic_library_path,       // in_LibrarySearchPath\n+           &m_process              // out_pProcess\n+       );\n     }\n+    else {\n+    // Target executable should be available by the time when we\n+    // attempt to initialize the device\n \n-    OFFLOAD_DEBUG_TRACE(2,\n-        \"Loading target executable \\\"%s\\\" from %p, size %lld\\n\",\n-        __target_exe->name, __target_exe->data, __target_exe->size);\n-\n-    res = COI::ProcessCreateFromMemory(\n-        engine,                 // in_Engine\n-        __target_exe->name,     // in_pBinaryName\n-        __target_exe->data,     // in_pBinaryBuffer\n-        __target_exe->size,     // in_BinaryBufferLength,\n-        0,                      // in_Argc\n-        0,                      // in_ppArgv\n-        environ == 0,           // in_DupEnv\n-        environ,                // in_ppAdditionalEnv\n-        mic_proxy_io,           // in_ProxyActive\n-        mic_proxy_fs_root,      // in_ProxyfsRoot\n-        mic_buffer_size,        // in_BufferSpace\n-        mic_library_path,       // in_LibrarySearchPath\n-        __target_exe->origin,   // in_FileOfOrigin\n-        __target_exe->offset,   // in_FileOfOriginOffset\n-        &m_process              // out_pProcess\n-    );\n+       //  Need the full path of the FAT exe for VTUNE\n+       {\n+#ifndef TARGET_WINNT\n+          ssize_t len = readlink(\"/proc/self/exe\", buf,1000);\n+#else\n+          int len = GetModuleFileName(NULL, buf,1000);\n+#endif // TARGET_WINNT\n+          if  (len == -1) {\n+             LIBOFFLOAD_ERROR(c_report_no_host_exe);\n+             exit(1);\n+          }\n+          else if (len > 999) {\n+             LIBOFFLOAD_ERROR(c_report_path_buff_overflow);\n+             exit(1);\n+          }\n+          buf[len] = '\\0';\n+       }\n+\n+       OFFLOAD_DEBUG_TRACE(2,\n+           \"Loading target executable \\\"%s\\\" from %p, size %lld, host file %s\\n\",\n+           __target_exe->name, __target_exe->data, __target_exe->size,\n+           buf);\n+\n+       res = COI::ProcessCreateFromMemory(\n+           engine,                 // in_Engine\n+           __target_exe->name,     // in_pBinaryName\n+           __target_exe->data,     // in_pBinaryBuffer\n+           __target_exe->size,     // in_BinaryBufferLength,\n+           0,                      // in_Argc\n+           0,                      // in_ppArgv\n+           environ == 0,           // in_DupEnv\n+           environ,                // in_ppAdditionalEnv\n+           mic_proxy_io,           // in_ProxyActive\n+           mic_proxy_fs_root,      // in_ProxyfsRoot\n+           mic_buffer_size,        // in_BufferSpace\n+           mic_library_path,       // in_LibrarySearchPath\n+           buf,                    // in_FileOfOrigin\n+           -1,                     // in_FileOfOriginOffset use -1 to indicate to\n+                                   // COI that is is a FAT binary\n+           &m_process              // out_pProcess\n+       );\n+    }\n     check_result(res, c_process_create, m_index, res);\n \n+    if ((mic_4k_buffer_size != 0) || (mic_2m_buffer_size !=0)) {\n+       // available only in MPSS 4.2 and greater\n+       if (COI::ProcessSetCacheSize != 0 ) { \n+          int flags;\n+          //  Need compiler to use MPSS 3.2 or greater to get these\n+          // definition so currently hardcoding it\n+          //  COI_CACHE_ACTION_GROW_NOW && COI_CACHE_MODE_ONDEMAND_SYNC;\n+          flags = 0x00020002; \n+          res = COI::ProcessSetCacheSize(\n+               m_process,             // in_Process\n+               mic_2m_buffer_size,    // in_HugePagePoolSize\n+               flags,                 // inHugeFlags\n+               mic_4k_buffer_size,    // in_SmallPagePoolSize\n+               flags,                 // inSmallFlags\n+               0,                     // in_NumDependencies\n+               0,                     // in_pDependencies\n+               0                      // out_PCompletion\n+          );\n+          OFFLOAD_DEBUG_TRACE(2,\n+              \"Reserve target buffers 4K pages = %d  2M pages = %d\\n\",\n+                  mic_4k_buffer_size, mic_2m_buffer_size);\n+           check_result(res, c_process_set_cache_size, m_index, res);\n+       }\n+       else {\n+             OFFLOAD_DEBUG_TRACE(2,\n+                 \"Reserve target buffers not supported in current MPSS\\n\");\n+       }\n+    }\n+\n     // get function handles\n     res = COI::ProcessGetFunctionHandles(m_process, c_funcs_total,\n                                          m_func_names, m_funcs);\n@@ -226,8 +344,9 @@ void Engine::load_libraries()\n     // load libraries collected so far\n     for (TargetImageList::iterator it = m_images.begin();\n          it != m_images.end(); it++) {\n-        OFFLOAD_DEBUG_TRACE(2, \"Loading library \\\"%s\\\" from %p, size %llu\\n\",\n-                            it->name, it->data, it->size);\n+        OFFLOAD_DEBUG_TRACE(2,\n+            \"Loading library \\\"%s\\\" from %p, size %llu, host file %s\\n\",\n+                                    it->name, it->data, it->size, it->origin);\n \n         // load library to the device\n         COILIBRARY lib;\n@@ -238,9 +357,10 @@ void Engine::load_libraries()\n                                                 it->name,\n                                                 mic_library_path,\n                                                 it->origin,\n-                                                it->offset,\n+                                                (it->origin) ? -1 : 0,\n                                                 COI_LOADLIBRARY_V1_FLAGS,\n                                                 &lib);\n+        m_dyn_libs.push_front(DynLib(it->name, it->data, lib));\n \n         if (res != COI_SUCCESS && res != COI_ALREADY_EXISTS) {\n             check_result(res, c_load_library, m_index, res);\n@@ -249,6 +369,27 @@ void Engine::load_libraries()\n     m_images.clear();\n }\n \n+void Engine::unload_library(const void *data, const char *name)\n+{\n+    if (m_process == 0) {\n+       return;\n+    }\n+    for (DynLibList::iterator it = m_dyn_libs.begin();\n+         it != m_dyn_libs.end(); it++) {\n+         if (it->data == data) {\n+            COIRESULT res;\n+            OFFLOAD_DEBUG_TRACE(2,\n+               \"Unloading library \\\"%s\\\"\\n\",name);\n+            res = COI::ProcessUnloadLibrary(m_process,it->lib);\n+            m_dyn_libs.erase(it);\n+            if (res != COI_SUCCESS) {\n+                check_result(res, c_unload_library, m_index, res);\n+            }\n+            return;\n+         }\n+    }\n+}\n+\n static bool target_entry_cmp(\n     const VarList::BufEntry &l,\n     const VarList::BufEntry &r\n@@ -273,8 +414,9 @@ void Engine::init_ptr_data(void)\n     COIEVENT event;\n \n     // Prepare table of host entries\n-    std::vector<const VarTable::Entry*> host_table(__offload_vars.begin(),\n-                                                   __offload_vars.end());\n+    std::vector<const VarTable::Entry*> host_table(\n+                                         Iterator(__offload_vars.get_head()),\n+                                         Iterator());\n \n     // no need to do anything further is host table is empty\n     if (host_table.size() <= 0) {\n@@ -348,17 +490,16 @@ void Engine::init_ptr_data(void)\n     while (hi != he && ti != te) {\n         int res = strcmp((*hi)->name, reinterpret_cast<const char*>(ti->name));\n         if (res == 0) {\n+            bool is_new;\n             // add matching entry to var map\n-            std::pair<PtrSet::iterator, bool> res =\n-                m_ptr_set.insert(PtrData((*hi)->addr, (*hi)->size));\n+            PtrData *ptr = insert_ptr_data((*hi)->addr, (*hi)->size, is_new);\n \n             // store address for new entries\n-            if (res.second) {\n-                PtrData *ptr = const_cast<PtrData*>(res.first.operator->());\n+            if (is_new) {\n                 ptr->mic_addr = ti->addr;\n                 ptr->is_static = true;\n             }\n-\n+            ptr->alloc_ptr_data_lock.unlock();\n             hi++;\n             ti++;\n         }\n@@ -379,6 +520,7 @@ void Engine::init_ptr_data(void)\n }\n \n COIRESULT Engine::compute(\n+    _Offload_stream stream,\n     const std::list<COIBUFFER> &buffers,\n     const void*         data,\n     uint16_t            data_size,\n@@ -413,9 +555,11 @@ COIRESULT Engine::compute(\n         bufs = 0;\n         flags = 0;\n     }\n-\n+    COIPIPELINE pipeline = (stream == no_stream) ?\n+                           get_pipeline() :\n+                           get_pipeline(stream);\n     // start computation\n-    res = COI::PipelineRunFunction(get_pipeline(),\n+    res = COI::PipelineRunFunction(pipeline,\n                                    m_funcs[c_func_compute],\n                                    num_bufs, bufs, flags,\n                                    num_deps, deps,\n@@ -528,12 +672,214 @@ COIPIPELINE Engine::get_pipeline(void)\n         // create pipeline for this thread\n         res = COI::PipelineCreate(m_process, 0, mic_stack_size, &pipeline);\n         check_result(res, c_pipeline_create, m_index, res);\n-\n         thread->set_pipeline(m_index, pipeline);\n     }\n     return pipeline;\n }\n \n+Stream* Stream::find_stream(uint64_t handle, bool remove)\n+{\n+    Stream *stream = 0;\n+\n+    m_stream_lock.lock();\n+    {\n+        StreamMap::iterator it = all_streams.find(handle);\n+        if (it != all_streams.end()) {\n+            stream = it->second;\n+            if (remove) {\n+                all_streams.erase(it);\n+            }\n+        }\n+    }\n+    m_stream_lock.unlock();\n+    return stream;\n+}\n+\n+COIPIPELINE Engine::get_pipeline(_Offload_stream handle)\n+{\n+    Stream * stream = Stream::find_stream(handle, false);\n+\n+    if (!stream) {\n+        LIBOFFLOAD_ERROR(c_offload_no_stream, m_index);\n+        LIBOFFLOAD_ABORT;\n+    }\n+\n+    COIPIPELINE pipeline = stream->get_pipeline();\n+\n+    if (pipeline == 0) {\n+        COIRESULT     res;\n+        int           proc_num;\n+        COI_CPU_MASK  in_Mask ;\n+\n+#ifndef TARGET_WINNT\n+        proc_num = __sync_fetch_and_add(&m_proc_number, 1);\n+#else // TARGET_WINNT\n+        proc_num = _InterlockedIncrement(&m_proc_number);\n+#endif // TARGET_WINNT\n+\n+        if (proc_num > COI_PIPELINE_MAX_PIPELINES) {\n+            LIBOFFLOAD_ERROR(c_coipipe_max_number, COI_PIPELINE_MAX_PIPELINES);\n+            LIBOFFLOAD_ABORT;\n+        }\n+\n+        m_stream_lock.lock();\n+\n+        // start process if not done yet\n+        if (m_process == 0) {\n+            init_process();\n+        }\n+\n+        // create CPUmask\n+        res = COI::PipelineClearCPUMask(in_Mask);\n+        check_result(res, c_clear_cpu_mask, m_index, res);\n+\n+        int stream_cpu_num = stream->get_cpu_number();\n+\n+        stream->m_stream_cpus.reset();\n+\n+        int threads_per_core = m_num_threads / m_num_cores;\n+\n+        // The \"stream_cpu_num\" available threads is set in mask.\n+        // Available threads are defined by examining of m_cpus bitset.\n+        // We skip thread 0 .\n+        for (int i = 1; i < m_num_threads; i++) {\n+            // for available thread i m_cpus[i] is equal to 1\n+            if (m_cpus[i]) {\n+                res = COI::PipelineSetCPUMask(m_process,\n+                    i / threads_per_core,\n+                    i % threads_per_core,\n+                    in_Mask);\n+\n+                check_result(res, c_set_cpu_mask, res);\n+                // mark thread i as nonavailable\n+                m_cpus.set(i,0);\n+                // Mark thread i as given for the stream.\n+                // In case of stream destroying by call to\n+                // _Offload_stream_destroy we can mark the thread i as\n+                // available.\n+                stream->m_stream_cpus.set(i);\n+                if (--stream_cpu_num <= 0) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // if stream_cpu_num is greater than 0 there are not enough\n+        // available threads\n+        if (stream_cpu_num > 0) {\n+            LIBOFFLOAD_ERROR(c_create_pipeline_for_stream, m_num_threads);\n+            LIBOFFLOAD_ABORT;\n+        }\n+        // create pipeline for this thread\n+        OFFLOAD_DEBUG_TRACE(2, \"COIPipelineCreate Mask\\n\"\n+                               \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\"\n+                               \"%016lx %016lx %016lx %016lx\\n%016lx %016lx %016lx %016lx\\n\",\n+                               in_Mask[0], in_Mask[1], in_Mask[2], in_Mask[3],\n+                               in_Mask[4], in_Mask[5], in_Mask[6], in_Mask[7],\n+                               in_Mask[8], in_Mask[9], in_Mask[10], in_Mask[11],\n+                               in_Mask[12], in_Mask[13], in_Mask[14], in_Mask[15]);\n+        res = COI::PipelineCreate(m_process, in_Mask,\n+                                  mic_stack_size, &pipeline);\n+        check_result(res, c_pipeline_create, m_index, res);\n+\n+        // Set stream's affinities\n+        {\n+            struct affinity_spec affinity_spec;\n+            char* affinity_type;\n+            int i;\n+\n+            // \"compact\" by default\n+            affinity_spec.affinity_type = affinity_compact;\n+\n+            // Check if user has specified type of affinity\n+            if ((affinity_type = getenv(\"OFFLOAD_STREAM_AFFINITY\")) !=\n+                                        NULL)\n+            {\n+                char affinity_str[16];\n+                int affinity_str_len;\n+\n+                OFFLOAD_DEBUG_TRACE(2,\n+                    \"User has specified OFFLOAD_STREAM_AFFINITY=%s\\n\",\n+                    affinity_type);\n+\n+                // Set type of affinity requested\n+                affinity_str_len = strlen(affinity_type);\n+                for (i=0; i<affinity_str_len && i<15; i++)\n+                {\n+                    affinity_str[i] = tolower(affinity_type[i]);\n+                }\n+                affinity_str[i] = '\\0';\n+                if (strcmp(affinity_str, \"compact\") == 0) {\n+                    affinity_spec.affinity_type = affinity_compact;\n+                    OFFLOAD_DEBUG_TRACE(2, \"Setting affinity=compact\\n\");\n+                } else if (strcmp(affinity_str, \"scatter\") == 0) {\n+                    affinity_spec.affinity_type = affinity_scatter;\n+                    OFFLOAD_DEBUG_TRACE(2, \"Setting affinity=scatter\\n\");\n+                } else {\n+                    LIBOFFLOAD_ERROR(c_incorrect_affinity, affinity_str);\n+                    affinity_spec.affinity_type = affinity_compact;\n+                    OFFLOAD_DEBUG_TRACE(2, \"Setting affinity=compact\\n\");\n+                }\n+            }\n+            // Make flat copy of sink mask because COI's mask is opaque\n+            for (i=0; i<16; i++) {\n+                affinity_spec.sink_mask[i] = in_Mask[i];\n+            }\n+            // Set number of cores and threads\n+            affinity_spec.num_cores = m_num_cores;\n+            affinity_spec.num_threads = m_num_threads;\n+\n+            COIEVENT event;\n+            res = COI::PipelineRunFunction(pipeline,\n+                                   m_funcs[c_func_set_stream_affinity],\n+                                   0, 0, 0,\n+                                   0, 0,\n+                                   &affinity_spec, sizeof(affinity_spec),\n+                                   0, 0,\n+                                   &event);\n+            check_result(res, c_pipeline_run_func, m_index, res);\n+    \n+            res = COI::EventWait(1, &event, -1, 1, 0, 0);\n+            check_result(res, c_event_wait, res);\n+        }\n+\n+        m_stream_lock.unlock();\n+        stream->set_pipeline(pipeline);\n+    }\n+    return pipeline;\n+}\n+\n+void Engine::stream_destroy(_Offload_stream handle)\n+{\n+    // get stream\n+    Stream * stream =  Stream::find_stream(handle, true);\n+\n+    if (stream) {\n+        // return cpus for future use\n+        for (int i = 0; i < m_num_threads; i++) {\n+            if (stream->m_stream_cpus.test(i)) {\n+                m_cpus.set(i);\n+            }\n+        }\n+        delete stream;\n+    }\n+    else {\n+        LIBOFFLOAD_ERROR(c_offload_no_stream, m_index);\n+        LIBOFFLOAD_ABORT;\n+    }\n+}\n+\n+uint64_t Engine::get_thread_id(void)\n+{\n+    Thread* thread = (Thread*) thread_getspecific(mic_thread_key);\n+    if (thread == 0) {\n+        thread = new Thread(&m_proc_number);\n+        thread_setspecific(mic_thread_key, thread);\n+    }\n+\n+    return reinterpret_cast<uint64_t>(thread);\n+}\n+\n AutoSet& Engine::get_auto_vars(void)\n {\n     Thread* thread = (Thread*) thread_getspecific(mic_thread_key);"}, {"sha": "abd5cc82f3058e1f7526a2854f6a5c4dd28b521f", "filename": "liboffloadmic/runtime/offload_engine.h", "status": "modified", "additions": 200, "deletions": 33, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_engine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_engine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_engine.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -32,13 +32,16 @@\n #define OFFLOAD_ENGINE_H_INCLUDED\n \n #include <limits.h>\n-\n+#include <bitset>\n #include <list>\n #include <set>\n #include <map>\n #include \"offload_common.h\"\n #include \"coi/coi_client.h\"\n \n+#define SIGNAL_IS_REMOVED ((OffloadDescriptor *)-1)\n+const int64_t no_stream = -1;\n+\n // Address range\n class MemRange {\n public:\n@@ -157,6 +160,50 @@ class PtrData {\n \n typedef std::list<PtrData*> PtrDataList;\n \n+class PtrDataTable {\n+public:\n+    typedef std::set<PtrData> PtrSet;\n+\n+    PtrData* find_ptr_data(const void *ptr) {\n+        m_ptr_lock.lock();\n+        PtrSet::iterator res = list.find(PtrData(ptr, 0));\n+\n+        m_ptr_lock.unlock();\n+        if (res == list.end()) {\n+            return 0;\n+        }\n+        return const_cast<PtrData*>(res.operator->());\n+    }\n+\n+    PtrData* insert_ptr_data(const void *ptr, uint64_t len, bool &is_new) {\n+        m_ptr_lock.lock();\n+        std::pair<PtrSet::iterator, bool> res =\n+            list.insert(PtrData(ptr, len));\n+\n+        PtrData* ptr_data = const_cast<PtrData*>(res.first.operator->());\n+        m_ptr_lock.unlock();\n+\n+        is_new = res.second;\n+        if (is_new) {\n+            // It's necessary to lock as soon as possible.\n+            // unlock must be done at call site of insert_ptr_data at\n+            // branch for is_new\n+            ptr_data->alloc_ptr_data_lock.lock();\n+        }\n+        return ptr_data;\n+    }\n+\n+    void remove_ptr_data(const void *ptr) {\n+        m_ptr_lock.lock();\n+        list.erase(PtrData(ptr, 0));\n+        m_ptr_lock.unlock();\n+    }\n+private:\n+\n+    PtrSet list;\n+    mutex_t     m_ptr_lock;\n+};\n+\n // Data associated with automatic variable\n class AutoData {\n public:\n@@ -186,7 +233,15 @@ class AutoData {\n         return _InterlockedDecrement(&ref_count);\n #endif // TARGET_WINNT\n     }\n-\n+    \n+    long nullify_reference() {\n+#ifndef TARGET_WINNT\n+        return __sync_lock_test_and_set(&ref_count, 0);\n+#else // TARGET_WINNT\n+        return _InterlockedExchange(&ref_count,0);\n+#endif // TARGET_WINNT\n+    }\n+    \n     long get_reference() const {\n         return ref_count;\n     }\n@@ -226,18 +281,39 @@ struct TargetImage\n \n typedef std::list<TargetImage> TargetImageList;\n \n+// dynamic library and Image associated with lib\n+struct DynLib\n+{\n+    DynLib(const char *_name, const void *_data,\n+           COILIBRARY _lib) :\n+        name(_name), data(_data), lib(_lib)\n+    {}\n+    // library name\n+    const char* name;\n+\n+    // contents\n+    const void* data;\n+ \n+    COILIBRARY lib;\n+};\n+typedef std::list<DynLib> DynLibList;\n+\n // Data associated with persistent auto objects\n struct PersistData\n {\n-    PersistData(const void *addr, uint64_t routine_num, uint64_t size) :\n-        stack_cpu_addr(addr), routine_id(routine_num)\n+    PersistData(const void *addr, uint64_t routine_num,\n+                uint64_t size, uint64_t thread) :\n+        stack_cpu_addr(addr), routine_id(routine_num), thread_id(thread)\n     {\n         stack_ptr_data = new PtrData(0, size);\n     }\n-    // 1-st key value - begining of the stack at CPU\n+    // 1-st key value - beginning of the stack at CPU\n     const void *   stack_cpu_addr;\n     // 2-nd key value - identifier of routine invocation at CPU\n     uint64_t   routine_id;\n+    // 3-rd key value - thread identifier\n+    uint64_t   thread_id;\n+\n     // corresponded PtrData; only stack_ptr_data->mic_buf is used\n     PtrData * stack_ptr_data;\n     // used to get offset of the variable in stack buffer\n@@ -246,6 +322,75 @@ struct PersistData\n \n typedef std::list<PersistData> PersistDataList;\n \n+// Data associated with stream\n+struct Stream\n+{\n+    Stream(int device, int num_of_cpus) :\n+       m_number_of_cpus(num_of_cpus), m_pipeline(0), m_last_offload(0),\n+       m_device(device)\n+    {}\n+    ~Stream() {\n+        if (m_pipeline) {\n+             COI::PipelineDestroy(m_pipeline);\n+        }\n+    }\n+\n+    COIPIPELINE get_pipeline(void) {\n+        return(m_pipeline);\n+    }\n+\n+    int get_device(void) {\n+        return(m_device);\n+    }\n+\n+    int get_cpu_number(void) {\n+        return(m_number_of_cpus);\n+    }\n+\n+    void set_pipeline(COIPIPELINE pipeline) {\n+        m_pipeline = pipeline;\n+    }\n+\n+    OffloadDescriptor* get_last_offload(void) {\n+        return(m_last_offload);\n+    }\n+\n+    void set_last_offload(OffloadDescriptor*   last_offload) {\n+        m_last_offload = last_offload;\n+    }\n+\n+    static Stream* find_stream(uint64_t handle, bool remove);\n+\n+    static _Offload_stream  add_stream(int device, int number_of_cpus) {\n+        m_stream_lock.lock();\n+        all_streams[++m_streams_count] = new Stream(device, number_of_cpus);\n+        m_stream_lock.unlock();\n+        return(m_streams_count);\n+    }\n+\n+    typedef std::map<uint64_t, Stream*> StreamMap;\n+\n+    static uint64_t  m_streams_count;\n+    static StreamMap all_streams;\n+    static mutex_t   m_stream_lock;\n+\n+    int m_device;\n+\n+    // number of cpus\n+    int m_number_of_cpus;\n+\n+    // The pipeline associated with the stream\n+    COIPIPELINE         m_pipeline;\n+\n+    // The last offload occured via the stream\n+    OffloadDescriptor*  m_last_offload;\n+\n+    // Cpus used by the stream\n+    std::bitset<COI_MAX_HW_THREADS> m_stream_cpus;\n+};\n+\n+typedef std::map<uint64_t, Stream*> StreamMap;\n+\n // class representing a single engine\n struct Engine {\n     friend void __offload_init_library_once(void);\n@@ -275,9 +420,14 @@ struct Engine {\n         return m_process;\n     }\n \n+    uint64_t get_thread_id(void);\n+\n     // initialize device\n     void init(void);\n \n+    // unload library\n+    void unload_library(const void *data, const char *name);\n+\n     // add new library\n     void add_lib(const TargetImage &lib)\n     {\n@@ -288,6 +438,7 @@ struct Engine {\n     }\n \n     COIRESULT compute(\n+        _Offload_stream     stream,\n         const std::list<COIBUFFER> &buffers,\n         const void*         data,\n         uint16_t            data_size,\n@@ -323,36 +474,28 @@ struct Engine {\n     // Memory association table\n     //\n     PtrData* find_ptr_data(const void *ptr) {\n-        m_ptr_lock.lock();\n-        PtrSet::iterator res = m_ptr_set.find(PtrData(ptr, 0));\n-        m_ptr_lock.unlock();\n-        if (res == m_ptr_set.end()) {\n-            return 0;\n-        }\n-        return const_cast<PtrData*>(res.operator->());\n+        return m_ptr_set.find_ptr_data(ptr);\n+    }\n+\n+    PtrData* find_targetptr_data(const void *ptr) {\n+        return m_targetptr_set.find_ptr_data(ptr);\n     }\n \n     PtrData* insert_ptr_data(const void *ptr, uint64_t len, bool &is_new) {\n-        m_ptr_lock.lock();\n-        std::pair<PtrSet::iterator, bool> res =\n-            m_ptr_set.insert(PtrData(ptr, len));\n-        PtrData* ptr_data = const_cast<PtrData*>(res.first.operator->());\n-        m_ptr_lock.unlock();\n+        return m_ptr_set.insert_ptr_data(ptr, len, is_new);\n+    }\n \n-        is_new = res.second;\n-        if (is_new) {\n-            // It's necessary to lock as soon as possible.\n-            // unlock must be done at call site of insert_ptr_data at\n-            // branch for is_new\n-            ptr_data->alloc_ptr_data_lock.lock();\n-        }\n-        return ptr_data;\n+    PtrData* insert_targetptr_data(const void *ptr, uint64_t len,\n+                                   bool &is_new) {\n+        return m_targetptr_set.insert_ptr_data(ptr, len, is_new);\n     }\n \n     void remove_ptr_data(const void *ptr) {\n-        m_ptr_lock.lock();\n-        m_ptr_set.erase(PtrData(ptr, 0));\n-        m_ptr_lock.unlock();\n+        m_ptr_set.remove_ptr_data(ptr);\n+    }\n+\n+    void remove_targetptr_data(const void *ptr) {\n+        m_targetptr_set.remove_ptr_data(ptr);\n     }\n \n     //\n@@ -396,7 +539,7 @@ struct Engine {\n             if (it != m_signal_map.end()) {\n                 desc = it->second;\n                 if (remove) {\n-                    m_signal_map.erase(it);\n+                    it->second = SIGNAL_IS_REMOVED;\n                 }\n             }\n         }\n@@ -405,6 +548,14 @@ struct Engine {\n         return desc;\n     }\n \n+    void stream_destroy(_Offload_stream handle);\n+\n+    COIPIPELINE get_pipeline(_Offload_stream stream);\n+\n+    StreamMap get_stream_map() {\n+        return m_stream_map;\n+    }\n+\n     // stop device process\n     void fini_process(bool verbose);\n \n@@ -417,6 +568,11 @@ struct Engine {\n     {}\n \n     ~Engine() {\n+        for (StreamMap::iterator it = m_stream_map.begin();\n+             it != m_stream_map.end(); it++) {\n+            Stream * stream = it->second;\n+            delete stream;\n+        }\n         if (m_process != 0) {\n             fini_process(false);\n         }\n@@ -469,14 +625,24 @@ struct Engine {\n     // List of libraries to be loaded\n     TargetImageList m_images;\n \n-    // var table\n-    PtrSet      m_ptr_set;\n-    mutex_t     m_ptr_lock;\n+    // var tables\n+    PtrDataTable m_ptr_set;\n+    PtrDataTable m_targetptr_set;\n \n     // signals\n     SignalMap m_signal_map;\n     mutex_t   m_signal_lock;\n \n+    // streams\n+    StreamMap m_stream_map;\n+    mutex_t   m_stream_lock;\n+    int       m_num_cores;\n+    int       m_num_threads;\n+    std::bitset<COI_MAX_HW_THREADS> m_cpus;\n+\n+    // List of dynamic libraries to be registred\n+    DynLibList m_dyn_libs;\n+\n     // constants for accessing device function handles\n     enum {\n         c_func_compute = 0,\n@@ -487,6 +653,7 @@ struct Engine {\n         c_func_init,\n         c_func_var_table_size,\n         c_func_var_table_copy,\n+        c_func_set_stream_affinity,\n         c_funcs_total\n     };\n     static const char* m_func_names[c_funcs_total];"}, {"sha": "79f5f3667547c2c77801e6b36e5e02b718a3840f", "filename": "liboffloadmic/runtime/offload_env.cpp", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_env.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_env.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -146,7 +146,7 @@ void MicEnvVar::add_env_var(\n     else {\n         card = get_card(card_number);\n         if (!card) {\n-            // definition for new card occured\n+            // definition for new card occurred\n             card = new CardEnvVars(card_number);\n             card_spec_list.push_back(card);\n         }\n@@ -321,7 +321,7 @@ void MicEnvVar::mic_parse_env_var_list(\n // Collect all definitions for the card with number \"card_num\".\n // The returned result is vector of string pointers defining one\n // environment variable. The vector is terminated by NULL pointer.\n-// In the begining of the vector there are env vars defined as\n+// In the beginning of the vector there are env vars defined as\n // <mic-prefix>_<card-number>_<var>=<value>\n // or\n // <mic-prefix>_<card-number>_ENV=<env-vars>"}, {"sha": "01138c2d4c39f3c3d3265e9c59d928f2f36cf51a", "filename": "liboffloadmic/runtime/offload_env.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_env.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_env.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_env.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -32,6 +32,7 @@\n #define OFFLOAD_ENV_H_INCLUDED\n \n #include <list>\n+#include \"offload_util.h\"\n \n // data structure and routines to parse MIC user environment and pass to MIC\n \n@@ -43,7 +44,7 @@ enum MicEnvVarKind\n     c_mic_card_env    // for <mic-prefix>_<card-number>_ENV\n };\n \n-struct MicEnvVar {\n+struct DLL_LOCAL MicEnvVar {\n public:\n     MicEnvVar() : prefix(0) {}\n     ~MicEnvVar();"}, {"sha": "08f626f457e5834b3b2cd02b4be5d7e7042618b5", "filename": "liboffloadmic/runtime/offload_host.cpp", "status": "modified", "additions": 1864, "deletions": 388, "changes": 2252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9"}, {"sha": "afd5c9936ca168e90b3656d221453936bc264166", "filename": "liboffloadmic/runtime/offload_host.h", "status": "modified", "additions": 128, "deletions": 33, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_host.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -46,8 +46,12 @@\n #include \"coi/coi_client.h\"\n \n // MIC engines.\n-extern Engine*  mic_engines;\n-extern uint32_t mic_engines_total;\n+DLL_LOCAL extern Engine*  mic_engines;\n+DLL_LOCAL extern uint32_t mic_engines_total;\n+\n+// DMA channel count used by COI and set via\n+// OFFLOAD_DMA_CHANNEL_COUNT environment variable\n+DLL_LOCAL extern uint32_t mic_dma_channel_count;\n \n //! The target image is packed as follows.\n /*!      1. 8 bytes containing the size of the target binary          */\n@@ -64,28 +68,44 @@ struct Image {\n class OffloadDescriptor\n {\n public:\n+    enum  OmpAsyncLastEventType {\n+        c_last_not,     // not last event\n+        c_last_write,   // the last event that is write\n+        c_last_read,    // the last event that is read\n+        c_last_runfunc  // the last event that is runfunction\n+    };\n+    \n     OffloadDescriptor(\n         int index,\n         _Offload_status *status,\n         bool is_mandatory,\n         bool is_openmp,\n         OffloadHostTimerData * timer_data\n     ) :\n-        m_device(mic_engines[index % mic_engines_total]),\n+        m_device(mic_engines[index == -1 ? 0 : index % mic_engines_total]),\n         m_is_mandatory(is_mandatory),\n         m_is_openmp(is_openmp),\n         m_inout_buf(0),\n         m_func_desc(0),\n         m_func_desc_size(0),\n         m_in_deps(0),\n         m_in_deps_total(0),\n+        m_in_deps_allocated(0),        \n         m_out_deps(0),\n         m_out_deps_total(0),\n+        m_out_deps_allocated(0),\n         m_vars(0),\n         m_vars_extra(0),\n         m_status(status),\n-        m_timer_data(timer_data)\n-    {}\n+        m_timer_data(timer_data),\n+        m_out_with_preallocated(false),\n+        m_preallocated_alloc(false),\n+        m_traceback_called(false),\n+        m_stream(-1),\n+        m_omp_async_last_event_type(c_last_not)\n+    {\n+        m_wait_all_devices = index == -1;\n+    }\n \n     ~OffloadDescriptor()\n     {\n@@ -107,45 +127,71 @@ class OffloadDescriptor\n     bool offload(const char *name, bool is_empty,\n                  VarDesc *vars, VarDesc2 *vars2, int vars_total,\n                  const void **waits, int num_waits, const void **signal,\n-                 int entry_id, const void *stack_addr);\n-    bool offload_finish();\n+                 int entry_id, const void *stack_addr,\n+                 OffloadFlags offload_flags);\n+\n+    bool offload_finish(bool is_traceback);\n \n     bool is_signaled();\n \n     OffloadHostTimerData* get_timer_data() const {\n         return m_timer_data;\n     }\n \n+    void set_stream(_Offload_stream stream) {\n+        m_stream = stream;\n+    }\n+\n+    _Offload_stream get_stream() {\n+        return(m_stream);\n+    }\n+\n private:\n-    bool wait_dependencies(const void **waits, int num_waits);\n+    bool offload_wrap(const char *name, bool is_empty,\n+                 VarDesc *vars, VarDesc2 *vars2, int vars_total,\n+                 const void **waits, int num_waits, const void **signal,\n+                 int entry_id, const void *stack_addr,\n+                 OffloadFlags offload_flags);\n+    bool wait_dependencies(const void **waits, int num_waits,\n+                           _Offload_stream stream);\n     bool setup_descriptors(VarDesc *vars, VarDesc2 *vars2, int vars_total,\n                            int entry_id, const void *stack_addr);\n     bool setup_misc_data(const char *name);\n-    bool send_pointer_data(bool is_async);\n+    bool send_pointer_data(bool is_async, void* info);\n     bool send_noncontiguous_pointer_data(\n         int i,\n         PtrData* src_buf,\n         PtrData* dst_buf,\n-        COIEVENT *event);\n-    bool recieve_noncontiguous_pointer_data(\n+        COIEVENT *event,\n+        uint64_t  &sent_data,\n+        uint32_t in_deps_amount,\n+        COIEVENT *in_deps\n+        );\n+    bool receive_noncontiguous_pointer_data(\n         int i,\n-        char* src_data,\n         COIBUFFER dst_buf,\n-        COIEVENT *event);\n+        COIEVENT *event,\n+        uint64_t  &received_data,\n+        uint32_t in_deps_amount,\n+        COIEVENT *in_deps\n+        );\n \n     bool gather_copyin_data();\n \n-    bool compute();\n+    bool compute(void *);\n \n-    bool receive_pointer_data(bool is_async);\n+    bool receive_pointer_data(bool is_async, bool first_run, void * info);\n     bool scatter_copyout_data();\n \n     void cleanup();\n \n     bool find_ptr_data(PtrData* &ptr_data, void *base, int64_t disp,\n-                       int64_t length, bool error_does_not_exist = true);\n+                       int64_t length, bool is_targptr,\n+                       bool error_does_not_exist = true);\n     bool alloc_ptr_data(PtrData* &ptr_data, void *base, int64_t disp,\n-                        int64_t length, int64_t alloc_disp, int align);\n+                        int64_t length, int64_t alloc_disp, int align,\n+                        bool is_targptr, bool is_prealloc, bool pin);\n+    bool create_preallocated_buffer(PtrData* ptr_data, void *base);\n     bool init_static_ptr_data(PtrData *ptr_data);\n     bool init_mic_address(PtrData *ptr_data);\n     bool offload_stack_memory_manager(const void * stack_begin, int routine_id,\n@@ -154,9 +200,15 @@ class OffloadDescriptor\n \n     bool gen_var_descs_for_pointer_array(int i);\n \n+    void get_stream_in_dependencies(uint32_t &in_deps_amount,\n+                                    COIEVENT* &in_deps);\n+\n     void report_coi_error(error_types msg, COIRESULT res);\n     _Offload_result translate_coi_error(COIRESULT res) const;\n-\n+    \n+    void setup_omp_async_info();\n+    void register_omp_event_call_back(const COIEVENT *event, const void *info);\n+    \n private:\n     typedef std::list<COIBUFFER> BufferList;\n \n@@ -167,10 +219,12 @@ class OffloadDescriptor\n         AutoData* auto_data;\n         int64_t cpu_disp;\n         int64_t cpu_offset;\n+        void *alloc;\n         CeanReadRanges *read_rng_src;\n         CeanReadRanges *read_rng_dst;\n         int64_t ptr_arr_offset;\n         bool is_arr_ptr_el;\n+        OmpAsyncLastEventType omp_last_event_type;\n     };\n \n     template<typename T> class ReadArrElements {\n@@ -230,6 +284,9 @@ class OffloadDescriptor\n     // Engine\n     Engine& m_device;\n \n+    // true for offload_wait target(mic) stream(0)\n+    bool m_wait_all_devices;\n+\n     // if true offload is mandatory\n     bool m_is_mandatory;\n \n@@ -266,8 +323,13 @@ class OffloadDescriptor\n     // Dependencies\n     COIEVENT *m_in_deps;\n     uint32_t  m_in_deps_total;\n+    uint32_t  m_in_deps_allocated;    \n     COIEVENT *m_out_deps;\n     uint32_t  m_out_deps_total;\n+    uint32_t  m_out_deps_allocated;     \n+\n+    // Stream\n+    _Offload_stream m_stream;\n \n     // Timer data\n     OffloadHostTimerData *m_timer_data;\n@@ -279,6 +341,25 @@ class OffloadDescriptor\n     // a boolean value calculated in setup_descriptors. If true we need to do\n     // a run function on the target. Otherwise it may be optimized away.\n     bool m_need_runfunction;\n+\n+    // initialized value of m_need_runfunction;\n+    // is used to recognize offload_transfer\n+    bool m_initial_need_runfunction;\n+\n+    // a Boolean value set to true when OUT clauses with preallocated targetptr\n+    // is encountered to indicate that call receive_pointer_data needs to be\n+    // invoked again after call to scatter_copyout_data.\n+    bool m_out_with_preallocated;\n+\n+    // a Boolean value set to true if an alloc_if(1) is used with preallocated\n+    // targetptr to indicate the need to scatter_copyout_data even for\n+    // async offload\n+    bool m_preallocated_alloc;\n+\n+    // a Boolean value set to true if traceback routine is called\n+    bool m_traceback_called;  \n+\n+    OmpAsyncLastEventType m_omp_async_last_event_type;\n };\n \n // Initialization types for MIC\n@@ -288,46 +369,60 @@ enum OffloadInitType {\n     c_init_on_offload_all    // all devices before starting the first offload\n };\n \n+// Determines if MIC code is an executable or a shared library\n+extern \"C\" bool __offload_target_image_is_executable(const void *target_image);\n+\n // Initializes library and registers specified offload image.\n-extern \"C\" void __offload_register_image(const void* image);\n+extern \"C\" bool __offload_register_image(const void* image);\n extern \"C\" void __offload_unregister_image(const void* image);\n \n // Initializes offload runtime library.\n-extern int __offload_init_library(void);\n+DLL_LOCAL extern int __offload_init_library(void);\n \n // thread data for associating pipelines with threads\n-extern pthread_key_t mic_thread_key;\n+DLL_LOCAL extern pthread_key_t mic_thread_key;\n+\n+// location of offload_main executable\n+// To be used if the main application has no offload and is not built\n+// with -offload but dynamic library linked in has offload pragma\n+DLL_LOCAL extern char* mic_device_main;\n \n // Environment variables for devices\n-extern MicEnvVar mic_env_vars;\n+DLL_LOCAL extern MicEnvVar mic_env_vars;\n \n // CPU frequency\n-extern uint64_t cpu_frequency;\n+DLL_LOCAL extern uint64_t cpu_frequency;\n \n // LD_LIBRARY_PATH for MIC libraries\n-extern char* mic_library_path;\n+DLL_LOCAL extern char* mic_library_path;\n \n // stack size for target\n-extern uint32_t mic_stack_size;\n+DLL_LOCAL extern uint32_t mic_stack_size;\n \n // Preallocated memory size for buffers on MIC\n-extern uint64_t mic_buffer_size;\n+DLL_LOCAL extern uint64_t mic_buffer_size;\n+\n+// Preallocated 4K page memory size for buffers on MIC\n+DLL_LOCAL extern uint64_t mic_4k_buffer_size;\n+\n+// Preallocated 2M page memory size for buffers on MIC\n+DLL_LOCAL extern uint64_t mic_2m_buffer_size;\n \n // Setting controlling inout proxy\n-extern bool  mic_proxy_io;\n-extern char* mic_proxy_fs_root;\n+DLL_LOCAL extern bool  mic_proxy_io;\n+DLL_LOCAL extern char* mic_proxy_fs_root;\n \n // Threshold for creating buffers with large pages\n-extern uint64_t __offload_use_2mb_buffers;\n+DLL_LOCAL extern uint64_t __offload_use_2mb_buffers;\n \n // offload initialization type\n-extern OffloadInitType __offload_init_type;\n+DLL_LOCAL extern OffloadInitType __offload_init_type;\n \n // Device number to offload to when device is not explicitly specified.\n-extern int __omp_device_num;\n+DLL_LOCAL extern int __omp_device_num;\n \n // target executable\n-extern TargetImage* __target_exe;\n+DLL_LOCAL extern TargetImage* __target_exe;\n \n // IDB support\n "}, {"sha": "f5922b4e808b109417a07db27c92377bad94d09a", "filename": "liboffloadmic/runtime/offload_iterator.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_iterator.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -0,0 +1,103 @@\n+/*\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+\n+      * Redistributions of source code must retain the above copyright\n+        notice, this list of conditions and the following disclaimer.\n+      * Redistributions in binary form must reproduce the above copyright\n+        notice, this list of conditions and the following disclaimer in the\n+        documentation and/or other materials provided with the distribution.\n+      * Neither the name of Intel Corporation nor the names of its\n+        contributors may be used to endorse or promote products derived\n+        from this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n+    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n+*/\n+\n+\n+/*! \\file\n+    \\brief Iterator of Variable tables list used by the runtime library\n+*/\n+\n+#ifndef OFFLOAD_ITERATOR_H_INCLUDED\n+#define OFFLOAD_ITERATOR_H_INCLUDED\n+\n+#include <iterator>\n+#include \"offload_table.h\"\n+\n+// The following class is for iteration over var table.\n+// It was extracted and moved to this offload_iterator.h file from offload_table.h\n+// to solve the problem with compiling with VS 2010. The problem was in incompatibility\n+// of STL objects in VS 2010 with ones in later VS versions.\n+\n+// var table list iterator\n+class Iterator : public std::iterator<std::input_iterator_tag,\n+                                          VarTable::Entry> {\n+    public:\n+        Iterator() : m_node(0), m_entry(0) {}\n+\n+        explicit Iterator(TableList<VarTable>::Node *node) {\n+            new_node(node);\n+        }\n+\n+        Iterator& operator++() {\n+            if (m_entry != 0) {\n+                m_entry++;\n+                while (m_entry->name == 0) {\n+                    m_entry++;\n+                }\n+                if (m_entry->name == reinterpret_cast<const char*>(-1)) {\n+                    new_node(m_node->next);\n+                }\n+            }\n+            return *this;\n+        }\n+\n+        bool operator==(const Iterator &other) const {\n+            return m_entry == other.m_entry;\n+        }\n+\n+        bool operator!=(const Iterator &other) const {\n+            return m_entry != other.m_entry;\n+        }\n+\n+        const VarTable::Entry* operator*() const {\n+            return m_entry;\n+        }\n+\n+    private:\n+        void new_node(TableList<VarTable>::Node *node) {\n+            m_node = node;\n+            m_entry = 0;\n+            while (m_node != 0) {\n+                m_entry = m_node->table.entries;\n+                while (m_entry->name == 0) {\n+                    m_entry++;\n+                }\n+                if (m_entry->name != reinterpret_cast<const char*>(-1)) {\n+                    break;\n+                }\n+                m_node = m_node->next;\n+                m_entry = 0;\n+            }\n+        }\n+\n+    private:\n+        TableList<VarTable>::Node                *m_node;\n+        const VarTable::Entry  *m_entry;\n+};\n+\n+#endif  // OFFLOAD_ITERATOR_H_INCLUDED"}, {"sha": "621494906413c247a677c8b64df2660da128d96d", "filename": "liboffloadmic/runtime/offload_myo_host.cpp", "status": "modified", "additions": 522, "deletions": 39, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -28,14 +28,15 @@\n */\n \n \n+#if defined(LINUX) || defined(FREEBSD)\n+#include <mm_malloc.h>\n+#endif\n+\n #include \"offload_myo_host.h\"\n #include <errno.h>\n #include <malloc.h>\n #include \"offload_host.h\"\n-\n-#if defined(LINUX) || defined(FREEBSD)\n-#include <mm_malloc.h>\n-#endif\n+//#include \"offload_util.h\"\n \n #define MYO_VERSION1    \"MYO_1.0\"\n \n@@ -47,11 +48,7 @@ extern \"C\" void __cilkrts_cilk_for_64(void*, void*, uint64_t, int32_t);\n #pragma weak __cilkrts_cilk_for_64\n #endif // TARGET_WINNT\n \n-#ifdef TARGET_WINNT\n-#define MYO_TABLE_END_MARKER() reinterpret_cast<const char*>(-1)\n-#else // TARGET_WINNT\n-#define MYO_TABLE_END_MARKER() reinterpret_cast<const char*>(0)\n-#endif // TARGET_WINNT\n+static void __offload_myoProcessDeferredTables();\n \n class MyoWrapper {\n public:\n@@ -140,7 +137,7 @@ class MyoWrapper {\n         CheckResult(__func__, m_remote_thunk_call(thunk, args, device));\n     }\n \n-    MyoiRFuncCallHandle RemoteCall(char *func, void *args, int device) const {\n+    MyoiRFuncCallHandle RemoteCall(const char *func, void *args, int device) const {\n         OFFLOAD_DEBUG_TRACE(4, \"%s(%s, %p, %d)\\n\", __func__, func, args,\n                             device);\n         return m_remote_call(func, args, device);\n@@ -151,6 +148,73 @@ class MyoWrapper {\n         CheckResult(__func__, m_get_result(handle));\n     }\n \n+    bool PostInitFuncSupported() const {\n+        OFFLOAD_DEBUG_TRACE(4, \"%s()\\n\", __func__);\n+        if (m_feature_available) {\n+            return m_feature_available(MYO_FEATURE_POST_LIB_INIT) ==\n+                       MYO_SUCCESS;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    void CreateVtableArena();\n+\n+    MyoArena GetVtableArena()const {\n+        return m_vtable_arena;\n+    }\n+\n+    void ArenaCreate(\n+        MyoOwnershipType ownership,\n+        int consistency,\n+        MyoArena* arena\n+    ) const\n+    {\n+        OFFLOAD_DEBUG_TRACE(4, \"%s(%d, %d, %p)\\n\",\n+            __func__, ownership, consistency, arena);\n+        CheckResult(__func__, m_arena_create(ownership, consistency, arena));\n+    }\n+\n+    void* SharedAlignedArenaMalloc(\n+        MyoArena arena,\n+        size_t size,\n+        size_t align\n+    ) const\n+    {\n+        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedarenamalloc,\n+                                 \"%s(%u, %lld, %lld)\\n\",\n+                                 __func__, arena, size, align);\n+        return m_arena_aligned_malloc(arena, size, align);\n+    }\n+\n+    void* SharedAlignedArenaFree(\n+        MyoArena arena,\n+        void* ptr\n+    ) const\n+    {\n+        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myosharedalignedarenafree,\n+                                 \"%s(%u, %p)\\n\", __func__, arena, ptr);\n+        return m_arena_aligned_free(arena, ptr);\n+    }\n+\n+    void ArenaAcquire(\n+        MyoArena arena\n+    ) const\n+    {\n+        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoarenaacquire,\n+                              \"%s()\\n\", __func__);\n+        CheckResult(__func__, m_arena_acquire(arena));\n+    }\n+\n+    void ArenaRelease(\n+        MyoArena arena\n+    ) const\n+    {\n+        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_myoarenarelease,\n+                            \"%s()\\n\", __func__);\n+        CheckResult(__func__, m_arena_release(arena));\n+    }\n+\n private:\n     void CheckResult(const char *func, MyoError error) const {\n         if (error != MYO_SUCCESS) {\n@@ -160,8 +224,10 @@ class MyoWrapper {\n     }\n \n private:\n-    void* m_lib_handle;\n-    bool  m_is_available;\n+    void*    m_lib_handle;\n+    bool     m_is_available;\n+    int      m_post_init_func;\n+    MyoArena m_vtable_arena;\n \n     // pointers to functions from myo library\n     MyoError (*m_lib_init)(void*, void*);\n@@ -175,11 +241,18 @@ class MyoWrapper {\n     MyoError (*m_host_var_table_propagate)(void*, int);\n     MyoError (*m_host_fptr_table_register)(void*, int, int);\n     MyoError (*m_remote_thunk_call)(void*, void*, int);\n-    MyoiRFuncCallHandle (*m_remote_call)(char*, void*, int);\n+    MyoiRFuncCallHandle (*m_remote_call)(const char*, void*, int);\n     MyoError (*m_get_result)(MyoiRFuncCallHandle);\n+    MyoError (*m_arena_create)(MyoOwnershipType, int, MyoArena*);\n+    void*    (*m_arena_aligned_malloc)(MyoArena, size_t, size_t);\n+    void*    (*m_arena_aligned_free)(MyoArena, void*);\n+    MyoError (*m_arena_acquire)(MyoArena);\n+    MyoError (*m_arena_release)(MyoArena);\n+    // Placeholder until MYO headers support enum type for feature\n+    MyoError (*m_feature_available)(int feature);\n };\n \n-bool MyoWrapper::LoadLibrary(void)\n+DLL_LOCAL bool MyoWrapper::LoadLibrary(void)\n {\n #ifndef TARGET_WINNT\n     const char *lib_name = \"libmyo-client.so\";\n@@ -295,7 +368,7 @@ bool MyoWrapper::LoadLibrary(void)\n         return false;\n     }\n \n-    m_remote_call = (MyoiRFuncCallHandle (*)(char*, void*, int))\n+    m_remote_call = (MyoiRFuncCallHandle (*)(const char*, void*, int))\n         DL_sym(m_lib_handle, \"myoiRemoteCall\", MYO_VERSION1);\n     if (m_remote_call == 0) {\n         OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n@@ -313,8 +386,66 @@ bool MyoWrapper::LoadLibrary(void)\n         return false;\n     }\n \n+    m_arena_create = (MyoError (*)(MyoOwnershipType, int, MyoArena*))\n+        DL_sym(m_lib_handle, \"myoArenaCreate\", MYO_VERSION1);\n+    if (m_arena_create == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoArenaCreate\");\n+        UnloadLibrary();\n+        return false;\n+    }\n+\n+    m_arena_aligned_malloc = (void* (*)(MyoArena, size_t, size_t))\n+        DL_sym(m_lib_handle, \"myoArenaAlignedMalloc\", MYO_VERSION1);\n+    if (m_arena_aligned_malloc == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoArenaAlignedMalloc\");\n+        UnloadLibrary();\n+        return false;\n+    }\n+\n+    m_arena_aligned_free = (void* (*)(MyoArena, void*))\n+        DL_sym(m_lib_handle, \"myoArenaAlignedFree\", MYO_VERSION1);\n+    if (m_arena_aligned_free == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoArenaAlignedFree\");\n+        UnloadLibrary();\n+        return false;\n+    }\n+\n+    m_arena_acquire = (MyoError (*)(MyoArena))\n+        DL_sym(m_lib_handle, \"myoArenaAcquire\", MYO_VERSION1);\n+    if (m_acquire == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoArenaAcquire\");\n+        UnloadLibrary();\n+        return false;\n+    }\n+\n+    m_arena_release = (MyoError (*)(MyoArena))\n+        DL_sym(m_lib_handle, \"myoArenaRelease\", MYO_VERSION1);\n+    if (m_release == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoArenaRelease\");\n+        UnloadLibrary();\n+        return false;\n+    }\n+\n+    // Check for \"feature-available\" API added in MPSS 3.3.\n+    // Not finding it is not an error.\n+    m_feature_available = (MyoError (*)(int))\n+        DL_sym(m_lib_handle, \"myoiSupportsFeature\", MYO_VERSION1);\n+    if (m_feature_available == 0) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Failed to find %s in MYO library\\n\",\n+                            \"myoiSupportsFeature\");\n+    }    \n+\n     OFFLOAD_DEBUG_TRACE(2, \"The library was successfully loaded\\n\");\n \n+    // Create arena if supported\n+    CreateVtableArena();\n+    OFFLOAD_DEBUG_TRACE(3, \"Vtable arena created\\n\");\n+\n     m_is_available = true;\n \n     return true;\n@@ -323,6 +454,23 @@ bool MyoWrapper::LoadLibrary(void)\n static bool myo_is_available;\n static MyoWrapper myo_wrapper;\n \n+void MyoWrapper::CreateVtableArena()\n+{\n+    MyoArena* vtable_arena;\n+\n+    // Check if this MYO supports arenas for vtables\n+    if (myo_wrapper.PostInitFuncSupported()) {\n+        // Create arena for vtables\n+\t    vtable_arena = (MyoArena *)myo_wrapper.SharedMalloc(sizeof(MyoArena));\n+        myo_wrapper.ArenaCreate(\n+            MYO_ARENA_OURS, MYO_NO_CONSISTENCY, vtable_arena);\n+        m_vtable_arena = *vtable_arena;\n+        OFFLOAD_DEBUG_TRACE(4, \"created arena = %d\\n\", m_vtable_arena);\n+    } else {\n+        m_vtable_arena = 0;\n+    }\n+}\n+\n struct MyoTable\n {\n     MyoTable(SharedTableEntry *tab, int len) : var_tab(tab), var_tab_len(len)\n@@ -337,9 +485,11 @@ static MyoTableList __myo_table_list;\n static mutex_t      __myo_table_lock;\n static bool         __myo_tables = false;\n \n-static void __offload_myo_shared_table_register(SharedTableEntry *entry);\n-static void __offload_myo_shared_init_table_register(InitTableEntry* entry);\n-static void __offload_myo_fptr_table_register(FptrTableEntry *entry);\n+static void __offload_myo_shared_vtable_process(SharedTableEntry *entry);\n+static void __offload_myo_shared_table_process(SharedTableEntry *entry);\n+static void __offload_myo_shared_init_table_process(InitTableEntry* entry);\n+static void __offload_myo_fptr_table_process(FptrTableEntry *entry);\n+static void __offload_propagate_shared_vars();\n \n static void __offload_myoLoadLibrary_once(void)\n {\n@@ -350,6 +500,7 @@ static void __offload_myoLoadLibrary_once(void)\n \n static bool __offload_myoLoadLibrary(void)\n {\n+    OFFLOAD_DEBUG_TRACE(4, \"__offload_myoLoadLibrary\\n\");\n     static OffloadOnceControl ctrl = OFFLOAD_ONCE_CONTROL_INIT;\n     __offload_run_once(&ctrl, __offload_myoLoadLibrary_once);\n \n@@ -371,17 +522,71 @@ static void __offload_myoInit_once(void)\n     OFFLOAD_DEBUG_TRACE(2, \"Initializing MYO library ...\\n\");\n \n     COIEVENT events[MIC_ENGINES_MAX];\n-    MyoiUserParams params[MIC_ENGINES_MAX+1];\n \n-    // load target library to all devices\n+    // One entry per device + \n+    // A pair of entries for the Host postInit func +\n+    // A pair of entries for the MIC postInit func +\n+    // end marker\n+    MyoiUserParams params[MIC_ENGINES_MAX+5];\n+\n+    // Load target library to all devices and\n+    // create libinit parameters for all devices\n     for (int i = 0; i < mic_engines_total; i++) {\n         mic_engines[i].init_myo(&events[i]);\n \n         params[i].type = MYOI_USERPARAMS_DEVID;\n         params[i].nodeid = mic_engines[i].get_physical_index() + 1;\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n+            i, params[i].type, params[i].nodeid);\n     }\n \n-    params[mic_engines_total].type = MYOI_USERPARAMS_LAST_MSG;\n+    // Check if V2 myoLibInit is available\n+    if (myo_wrapper.PostInitFuncSupported()) {\n+        // Set the host post libInit function indicator\n+        params[mic_engines_total].type =\n+            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n+        params[mic_engines_total].nodeid =\n+            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_HOST_NODE;\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n+            mic_engines_total,\n+            params[mic_engines_total].type, params[mic_engines_total].nodeid);\n+    \n+        // Set the host post libInit host function address\n+        ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n+            postLibInitHostFuncAddress =\n+                (void (*)())&__offload_propagate_shared_vars;\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %p }\\n\",\n+            mic_engines_total+1,\n+            ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n+                postLibInitHostFuncAddress);\n+    \n+        // Set the target post libInit function indicator\n+        params[mic_engines_total+2].type =\n+            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC;\n+        params[mic_engines_total+2].nodeid =\n+            MYOI_USERPARAMS_POST_MYO_LIB_INIT_FUNC_ALL_NODES;\n+    \n+        // Set the target post libInit target function name\n+        ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+3]))->\n+            postLibInitRemoveFuncName = \"--vtable_initializer--\";\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %s }\\n\",\n+            mic_engines_total+3,\n+            ((MyoiUserParamsPostLibInit*)(&params[mic_engines_total+1]))->\n+                postLibInitRemoveFuncName);\n+    \n+        params[mic_engines_total+4].type = MYOI_USERPARAMS_LAST_MSG;\n+        params[mic_engines_total+4].nodeid = 0;\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n+            mic_engines_total+4,\n+            params[mic_engines_total+4].type,\n+            params[mic_engines_total+4].nodeid);\n+    } else {\n+        params[mic_engines_total].type = MYOI_USERPARAMS_LAST_MSG;\n+        params[mic_engines_total].nodeid = 0;\n+        OFFLOAD_DEBUG_TRACE(2, \"params[%d] = { %d, %d }\\n\",\n+            mic_engines_total,\n+            params[mic_engines_total].type, params[mic_engines_total].nodeid);\n+    }\n \n     // initialize myo runtime on host\n     myo_wrapper.LibInit(params, 0);\n@@ -395,6 +600,7 @@ static void __offload_myoInit_once(void)\n     }\n \n     myo_is_available = true;\n+    OFFLOAD_DEBUG_TRACE(2, \"setting myo_is_available=%d\\n\", myo_is_available);\n \n     OFFLOAD_DEBUG_TRACE(2, \"Initializing MYO library ... done\\n\");\n }\n@@ -404,12 +610,22 @@ static bool __offload_myoInit(void)\n     static OffloadOnceControl ctrl = OFFLOAD_ONCE_CONTROL_INIT;\n     __offload_run_once(&ctrl, __offload_myoInit_once);\n \n-    // register pending shared var tables\n-    if (myo_is_available && __myo_tables) {\n+    // Check if using V1 myoLibInit\n+    if (!myo_wrapper.PostInitFuncSupported()) {\n+        __offload_propagate_shared_vars();\n+    }\n+\n+    return myo_is_available;\n+}\n+\n+static void __offload_propagate_shared_vars()\n+{\n+    // Propagate pending shared var tables\n+    if (__myo_tables) {\n         mutex_locker_t locker(__myo_table_lock);\n \n         if (__myo_tables) {\n-            //  Register tables with MYO so it can propagate to target.\n+            //  Give tables with MYO so it can propagate to target\n             for(MyoTableList::const_iterator it = __myo_table_list.begin();\n                 it != __myo_table_list.end(); ++it) {\n #ifdef TARGET_WINNT\n@@ -419,6 +635,8 @@ static bool __offload_myoInit(void)\n                         continue;\n                     }\n                     myo_wrapper.HostVarTablePropagate(entry, 1);\n+                    OFFLOAD_DEBUG_TRACE(2, \"HostVarTablePropagate(%s, 1)\\n\",\n+                        entry->varName);\n                 }\n #else // TARGET_WINNT\n                 myo_wrapper.HostVarTablePropagate(it->var_tab,\n@@ -430,8 +648,6 @@ static bool __offload_myoInit(void)\n             __myo_tables = false;\n         }\n     }\n-\n-    return myo_is_available;\n }\n \n static bool shared_table_entries(\n@@ -485,13 +701,164 @@ extern \"C\" void __offload_myoRegisterTables(\n         __offload_myoLoadLibrary();\n \n         // register tables\n-        __offload_myo_shared_table_register(shared_table);\n-        __offload_myo_fptr_table_register(fptr_table);\n-        __offload_myo_shared_init_table_register(init_table);\n+        __offload_myo_shared_table_process(shared_table);\n+        __offload_myo_fptr_table_process(fptr_table);\n+        __offload_myo_shared_init_table_process(init_table);\n     }\n }\n \n-void __offload_myoFini(void)\n+extern \"C\" bool __offload_myoProcessTables(\n+    const void* image,\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n+\n+    // Collect the tables in this .dll/.so\n+    __offload_myoRegisterTables1(\n+        init_table, shared_table, shared_vtable, fptr_table);\n+\n+    // Now check what type of module we are dealing with\n+    if (__offload_target_image_is_executable(image)) {\n+        OFFLOAD_DEBUG_TRACE(2, \"Main encountered\\n\");\n+        OFFLOAD_DEBUG_TRACE(2, \"MYO initialization not deferred\\n\");\n+        // MYO tables across dlls have been collected\n+        // Now init MYO and process the tables\n+        __offload_myoProcessDeferredTables();\n+        // Return true to indicate that atexit needs to be calld by ofldbegin\n+        return true;\n+    } else {\n+        // This is a shared library, either auto-loaded or dynamically loaded\n+        // If __target_exe is set, then main has started running\n+        if (__target_exe != 0) {\n+            // Main is running: this is a dynamic load of a shared library\n+            // Finish processing the tables in this library\n+            OFFLOAD_DEBUG_TRACE(2,\n+                \"Dynamically loaded shared library encountered\\n\");\n+            OFFLOAD_DEBUG_TRACE(2,\n+                \"MYO initialization not deferred\\n\");\n+            __offload_myoProcessDeferredTables();\n+        } else {\n+            // Main is not running: this is an auto-loaded shared library\n+            // Tables have been collected, nothing else to do\n+            OFFLOAD_DEBUG_TRACE(2,\n+                \"Auto-loaded shared library encountered\\n\");\n+            OFFLOAD_DEBUG_TRACE(2, \"Deferring initialization of MYO\\n\");\n+        }\n+        return false;\n+    }\n+}\n+\n+// Process contents of all Var tables\n+void MYOVarTableList::process()\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Var tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        __offload_myo_shared_table_process(\n+            (SharedTableEntry*)n->table.entries);\n+    }\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        remove_table(n);\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// Process contents of all Var tables\n+void MYOVarTableList::process_vtable()\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Vtable tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        __offload_myo_shared_vtable_process(\n+            (SharedTableEntry*)n->table.entries);\n+    }\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        remove_table(n);\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// Process contents of all Func tables\n+void MYOFuncTableList::process()\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Func tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        __offload_myo_fptr_table_process(\n+            (FptrTableEntry*)n->table.entries);\n+    }\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        remove_table(n);\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// Process contents of all Init tables\n+void MYOInitTableList::process()\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"Process MYO Init tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        __offload_myo_shared_init_table_process(\n+            (InitTableEntry*)n->table.entries);\n+    }\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        remove_table(n);\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+static void __offload_myoProcessDeferredTables()\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s()\\n\", __func__);\n+\n+    // Debug dumps of MYO tables\n+    if (console_enabled >= 2) {\n+        __offload_myo_var_tables.dump();\n+        __offload_myo_vtable_tables.dump();\n+        __offload_myo_func_tables.dump();\n+        __offload_myo_init_tables.dump();\n+    }\n+\n+    if (!__offload_myo_var_tables.is_empty() ||\n+        !__offload_myo_vtable_tables.is_empty() ||\n+        !__offload_myo_func_tables.is_empty() ||\n+        !__offload_myo_init_tables.is_empty())\n+    {\n+        OFFLOAD_DEBUG_TRACE(3, \"MYO usage detected in program\\n\");\n+\n+        // Make sure myo library is loaded\n+        __offload_myoLoadLibrary();\n+        OFFLOAD_DEBUG_TRACE(3, \"Initialized MYO\\n\");\n+\n+        __offload_myo_var_tables.process();\n+        __offload_myo_vtable_tables.process_vtable();\n+        __offload_myo_func_tables.process();\n+        __offload_myo_init_tables.process();\n+        OFFLOAD_DEBUG_TRACE(3, \"Finished processing MYO tables\\n\");\n+    } else {\n+        OFFLOAD_DEBUG_TRACE(3,\n+            \"MYO tables are empty; Will not initialize MYO\\n\");\n+    }\n+}\n+\n+DLL_LOCAL void __offload_myoFini(void)\n {\n     if (myo_is_available) {\n         OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n@@ -516,7 +883,7 @@ void __offload_myoFini(void)\n     }\n }\n \n-static void __offload_myo_shared_table_register(\n+static void __offload_myo_shared_table_process(\n     SharedTableEntry *entry\n )\n {\n@@ -529,7 +896,8 @@ static void __offload_myo_shared_table_register(\n     for (; entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n #ifdef TARGET_WINNT\n         if (entry->varName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4, \"skip registering a NULL MyoSharedTable entry\\n\");\n+            OFFLOAD_DEBUG_TRACE(4,\n+                \"skip registering a NULL MyoSharedTable entry\\n\");\n             continue;\n         }\n #endif // TARGET_WINNT\n@@ -550,29 +918,69 @@ static void __offload_myo_shared_table_register(\n     }\n }\n \n-static void __offload_myo_shared_init_table_register(InitTableEntry* entry)\n+static void __offload_myo_shared_vtable_process(\n+    SharedTableEntry *entry\n+)\n+{\n+    SharedTableEntry *start = entry;\n+    int entries = 0;\n+\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n+\n+    // allocate shared memory for vtables\n+    for (; entry->varName != MYO_TABLE_END_MARKER(); entry++) {\n+#ifdef TARGET_WINNT\n+        if (entry->varName == 0) {\n+            OFFLOAD_DEBUG_TRACE(4,\n+                \"skip registering a NULL MyoSharedVTable entry\\n\");\n+            continue;\n+        }\n+#endif // TARGET_WINNT\n+\n+        OFFLOAD_DEBUG_TRACE(4,\n+            \"registering MyoSharedVTable entry for %s @%p\\n\",\n+                            entry->varName, entry);\n+\n+        // Invoke the function to create shared memory\n+        reinterpret_cast<void(*)(MyoArena)>(entry->sharedAddr)(\n+                                                myo_wrapper.GetVtableArena());\n+        entries++;\n+    }\n+\n+    // add table to the list if it is not empty\n+    if (entries > 0) {\n+        mutex_locker_t locker(__myo_table_lock);\n+        __myo_table_list.push_back(MyoTable(start, entries));\n+        __myo_tables = true;\n+    }\n+}\n+\n+void __offload_myo_shared_init_table_process(InitTableEntry* entry)\n {\n     OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n \n #ifdef TARGET_WINNT\n     for (; entry->funcName != MYO_TABLE_END_MARKER(); entry++) {\n         if (entry->funcName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4, \"skip registering a NULL MyoSharedInit entry\\n\");\n+            OFFLOAD_DEBUG_TRACE(4,\n+                \"skip registering a NULL MyoSharedInit entry\\n\");\n             continue;\n         }\n \n         //  Invoke the function to init the shared memory\n-        entry->func();\n+        OFFLOAD_DEBUG_TRACE(4, \"execute MyoSharedInit routine for %s\\n\",\n+            entry->funcName);\n+        entry->func(myo_wrapper.GetVtableArena());\n     }\n #else // TARGET_WINNT\n     for (; entry->func != 0; entry++) {\n         // Invoke the function to init the shared memory\n-        entry->func();\n+        entry->func(myo_wrapper.GetVtableArena());\n     }\n #endif // TARGET_WINNT\n }\n \n-static void __offload_myo_fptr_table_register(\n+static void __offload_myo_fptr_table_process(\n     FptrTableEntry *entry\n )\n {\n@@ -584,7 +992,8 @@ static void __offload_myo_fptr_table_register(\n     for (; entry->funcName != MYO_TABLE_END_MARKER(); entry++) {\n #ifdef TARGET_WINNT\n         if (entry->funcName == 0) {\n-            OFFLOAD_DEBUG_TRACE(4, \"skip registering a NULL MyoFptrTable entry\\n\");\n+            OFFLOAD_DEBUG_TRACE(4,\n+                \"skip registering a NULL MyoFptrTable entry\\n\");\n             continue;\n         }\n #endif // TARGET_WINNT\n@@ -722,6 +1131,80 @@ extern \"C\" void _Offload_shared_aligned_free(void *ptr)\n     }\n }\n \n+extern \"C\" void _Offload_shared_arena_create(\n+    MyoOwnershipType ownership,\n+    int consistency,\n+    MyoArena* arena\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%d, %d, %p)\\n\",\n+        __func__, ownership, consistency, arena);\n+\n+    if (__offload_myoLoadLibrary()) {\n+        myo_wrapper.ArenaCreate(ownership, consistency, arena);\n+    }\n+}\n+\n+extern \"C\" void* _Offload_shared_aligned_arena_malloc(\n+    MyoArena arena,\n+    size_t size,\n+    size_t align\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %lld, %lld)\\n\",\n+        __func__, arena, size, align);\n+\n+    if (__offload_myoLoadLibrary()) {\n+        void *p = myo_wrapper.SharedAlignedArenaMalloc(arena, size, align);\n+        OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %lld, %lld)->%p\\n\",\n+            __func__, arena, size, align, p);\n+        return p;\n+    }\n+    else {\n+        if (align < sizeof(void*)) {\n+            align = sizeof(void*);\n+        }\n+        return _mm_malloc(size, align);\n+    }\n+}\n+\n+extern \"C\" void _Offload_shared_aligned_arena_free(\n+    MyoArena arena,\n+    void *ptr\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %p)\\n\", __func__, arena, ptr);\n+\n+    if (__offload_myoLoadLibrary()) {\n+        myo_wrapper.SharedAlignedArenaFree(arena, ptr);\n+    }\n+    else {\n+        _mm_free(ptr);\n+    }\n+}\n+\n+extern \"C\" void _Offload_shared_arena_acquire(\n+    MyoArena arena\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n+\n+    if (__offload_myoLoadLibrary()) {\n+        myo_wrapper.ArenaAcquire(arena);\n+    }\n+}\n+\n+extern \"C\" void _Offload_shared_arena_release(\n+    MyoArena arena\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n+\n+    if (__offload_myoLoadLibrary()) {\n+        myo_wrapper.ArenaRelease(arena);\n+    }\n+}\n+\n extern \"C\" void __intel_cilk_for_32_offload(\n     int size,\n     void (*copy_constructor)(void*, void*),"}, {"sha": "5b9f160f1beef2ebb5c65f7730c4705d373dfaa4", "filename": "liboffloadmic/runtime/offload_myo_host.h", "status": "modified", "additions": 23, "deletions": 55, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_host.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_host.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -34,67 +34,35 @@\n #include <myotypes.h>\n #include <myoimpl.h>\n #include <myo.h>\n-#include \"offload.h\"\n-\n-typedef MyoiSharedVarEntry      SharedTableEntry;\n-//typedef MyoiHostSharedFptrEntry FptrTableEntry;\n-typedef struct {\n-    //! Function Name\n-    const char *funcName;\n-    //! Function Address\n-    void *funcAddr;\n-    //! Local Thunk Address\n-    void *localThunkAddr;\n-#ifdef TARGET_WINNT\n-    // Dummy to pad up to 32 bytes\n-    void *dummy;\n-#endif // TARGET_WINNT\n-} FptrTableEntry;\n-\n-struct InitTableEntry {\n-#ifdef TARGET_WINNT\n-    // Dummy to pad up to 16 bytes\n-    // Function Name\n-    const char *funcName;\n-#endif // TARGET_WINNT\n-    void (*func)(void);\n-};\n-\n-#ifdef TARGET_WINNT\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable$a\"\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable$z\"\n-\n-#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START     \".MyoSharedInitTable$a\"\n-#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END       \".MyoSharedInitTable$z\"\n-\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable$a\"\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable$z\"\n-#else  // TARGET_WINNT\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable.\"\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable.\"\n-\n-#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START     \".MyoSharedInitTable.\"\n-#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END       \".MyoSharedInitTable.\"\n-\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable.\"\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable.\"\n-#endif // TARGET_WINNT\n-\n-#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_START, read, write)\n-#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_END, read, write)\n-\n-#pragma section(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START, read, write)\n-#pragma section(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END, read, write)\n-\n-#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_START, read, write)\n-#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_END, read, write)\n \n+#include \"offload.h\"\n+// undefine the following since offload.h defines them to malloc and free if __INTEL_OFFLOAD \n+// is not defined which is the case when building the offload library\n+#undef _Offload_shared_malloc\n+#undef _Offload_shared_free\n+#undef _Offload_shared_aligned_malloc\n+#undef _Offload_shared_aligned_free\n+#include \"offload_table.h\"\n+\n+// This function retained for compatibility with 15.0\n extern \"C\" void __offload_myoRegisterTables(\n     InitTableEntry *init_table,\n     SharedTableEntry *shared_table,\n     FptrTableEntry *fptr_table\n );\n \n+// Process shared variable, shared vtable and function and init routine tables.\n+// In .dlls/.sos these will be collected together.\n+// In the main program, all collected tables will be processed.\n+extern \"C\" bool __offload_myoProcessTables(\n+    const void* image,\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+);\n+\n extern void __offload_myoFini(void);\n+extern bool __offload_myo_init_is_deferred(const void *image);\n \n #endif // OFFLOAD_MYO_HOST_H_INCLUDED"}, {"sha": "5160ca951ac36524715585a18887e55e411ea90c", "filename": "liboffloadmic/runtime/offload_myo_target.cpp", "status": "modified", "additions": 110, "deletions": 5, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -44,7 +44,7 @@ static void CheckResult(const char *func, MyoError error) {\n     }\n }\n \n-static void __offload_myo_shared_table_register(SharedTableEntry *entry)\n+static void __offload_myo_shared_table_process(SharedTableEntry *entry)\n {\n     int entries = 0;\n     SharedTableEntry *t_start;\n@@ -68,7 +68,32 @@ static void __offload_myo_shared_table_register(SharedTableEntry *entry)\n     }\n }\n \n-static void __offload_myo_fptr_table_register(\n+static void __offload_myo_shared_vtable_process(SharedTableEntry *entry)\n+{\n+    int entries = 0;\n+    SharedTableEntry *t_start;\n+\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n+\n+    t_start = entry;\n+    while (t_start->varName != 0) {\n+        OFFLOAD_DEBUG_TRACE_1(4, 0, c_offload_mic_myo_shared,\n+                              \"myo shared vtable entry name\"\n+                              \" = \\\"%s\\\" addr = %p\\n\",\n+                              t_start->varName, t_start->sharedAddr);\n+        t_start++;\n+        entries++;\n+    }\n+\n+    if (entries > 0) {\n+        OFFLOAD_DEBUG_TRACE(3, \"myoiMicVarTableRegister(%p, %d)\\n\", entry,\n+                            entries);\n+        CheckResult(\"myoiMicVarTableRegister\",\n+                    myoiMicVarTableRegister(entry, entries));\n+    }\n+}\n+\n+static void __offload_myo_fptr_table_process(\n     FptrTableEntry *entry\n )\n {\n@@ -94,9 +119,22 @@ static void __offload_myo_fptr_table_register(\n     }\n }\n \n+void __offload_myo_shared_init_table_process(InitTableEntry* entry)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, entry);\n+\n+    for (; entry->func != 0; entry++) {\n+        // Invoke the function to init the shared memory\n+        OFFLOAD_DEBUG_TRACE(3, \"Invoked a shared init function @%p\\n\",\n+            (void *)(entry->func));\n+        entry->func();\n+    }\n+}\n+\n extern \"C\" void __offload_myoAcquire(void)\n {\n     OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n+\n     CheckResult(\"myoAcquire\", myoAcquire());\n }\n \n@@ -162,8 +200,35 @@ extern \"C\" void __offload_myoRegisterTables(\n         return;\n     }\n \n-    __offload_myo_shared_table_register(shared_table);\n-    __offload_myo_fptr_table_register(fptr_table);\n+    __offload_myo_shared_table_process(shared_table);\n+    __offload_myo_fptr_table_process(fptr_table);\n+}\n+\n+extern \"C\" void __offload_myoProcessTables(\n+    InitTableEntry* init_table,\n+    SharedTableEntry *shared_table,\n+    SharedTableEntry *shared_vtable,\n+    FptrTableEntry *fptr_table\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n+\n+    // one time registration of Intel(R) Cilk(TM) language entries\n+    static pthread_once_t once_control = PTHREAD_ONCE_INIT;\n+    pthread_once(&once_control, __offload_myo_once_init);\n+\n+    // register module's tables\n+    // check slot-1 of the function table because \n+    // slot-0 is predefined with --vtable_initializer--\n+    if (shared_table->varName == 0 &&\n+        shared_vtable->varName == 0 &&\n+        fptr_table[1].funcName == 0) {\n+        return;\n+    }\n+\n+    __offload_myo_shared_table_process(shared_table);\n+    __offload_myo_shared_vtable_process(shared_vtable);\n+    __offload_myo_fptr_table_process(fptr_table);\n }\n \n extern \"C\" void* _Offload_shared_malloc(size_t size)\n@@ -190,6 +255,46 @@ extern \"C\" void _Offload_shared_aligned_free(void *ptr)\n     myoSharedAlignedFree(ptr);\n }\n \n+extern \"C\" void* _Offload_shared_aligned_arena_malloc(\n+    MyoArena arena,\n+    size_t size,\n+    size_t align\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(\n+        3, \"%s(%u, %lld, %lld)\\n\", __func__, arena, size, align);\n+\n+    return myoArenaAlignedMalloc(arena, size, align);\n+}\n+\n+extern \"C\" void _Offload_shared_aligned_arena_free(\n+    MyoArena arena,\n+    void *ptr\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u, %p)\\n\", __func__, arena, ptr);\n+\n+    myoArenaAlignedFree(arena, ptr);\n+}\n+\n+extern \"C\" void _Offload_shared_arena_acquire(\n+    MyoArena arena\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n+\n+    myoArenaAcquire(arena);\n+}\n+\n+extern \"C\" void _Offload_shared_arena_release(\n+    MyoArena arena\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s(%u)\\n\", __func__, arena);\n+\n+    myoArenaRelease(arena);\n+}\n+\n // temporary workaround for blocking behavior of myoiLibInit/Fini calls\n extern \"C\" void __offload_myoLibInit()\n {"}, {"sha": "4383aae0b5e65331f74c9a6bf403d7b79d6ac340", "filename": "liboffloadmic/runtime/offload_myo_target.h", "status": "modified", "additions": 24, "deletions": 28, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_myo_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_myo_target.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -31,42 +31,38 @@\n #ifndef OFFLOAD_MYO_TARGET_H_INCLUDED\n #define OFFLOAD_MYO_TARGET_H_INCLUDED\n \n-#include <myotypes.h>\n-#include <myoimpl.h>\n-#include <myo.h>\n-#include \"offload.h\"\n-\n-typedef MyoiSharedVarEntry          SharedTableEntry;\n-typedef MyoiTargetSharedFptrEntry   FptrTableEntry;\n-\n-#ifdef TARGET_WINNT\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable$a\"\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable$z\"\n-\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable$a\"\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable$z\"\n-#else  // TARGET_WINNT\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable.\"\n-#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable.\"\n-\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable.\"\n-#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable.\"\n-#endif // TARGET_WINNT\n-\n-#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_START, read, write)\n-#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_END, read, write)\n-\n-#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_START, read, write)\n-#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_END, read, write)\n \n+#include \"offload.h\"\n+// undefine the following since offload.h defines them to malloc and free if __INTEL_OFFLOAD\n+// is not defined which is the case when building the offload library\n+#undef _Offload_shared_malloc\n+#undef _Offload_shared_free\n+#undef _Offload_shared_aligned_malloc\n+#undef _Offload_shared_aligned_free\n+#include \"offload_table.h\"\n+\n+// This function retained for compatibility with 15.0\n extern \"C\" void __offload_myoRegisterTables(\n     SharedTableEntry *shared_table,\n     FptrTableEntry *fptr_table\n );\n \n+// Process shared variable, shared vtable and function and init routine tables.\n+// On the target side the contents of the tables are registered with MYO.\n+extern \"C\" void __offload_myoProcessTables(\n+    InitTableEntry* init_table,\n+    SharedTableEntry *shared_table,\n+    SharedTableEntry *shared_vtable,\n+    FptrTableEntry *fptr_table\n+);\n+\n extern \"C\" void __offload_myoAcquire(void);\n extern \"C\" void __offload_myoRelease(void);\n \n+// Call the compiler-generated routines for initializing shared variables.\n+// This can only be done after shared memory allocation has been done.\n+extern void __offload_myo_shared_init_table_process(InitTableEntry* entry);\n+\n // temporary workaround for blocking behavior for myoiLibInit/Fini calls\n extern \"C\" void __offload_myoLibInit();\n extern \"C\" void __offload_myoLibFini();"}, {"sha": "14498470e3abd03ebefe0e0803c1410f36dc9b56", "filename": "liboffloadmic/runtime/offload_omp_host.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "91baef5da87d90148d551c9a4ae8a1eb0f056cfc", "filename": "liboffloadmic/runtime/offload_omp_target.cpp", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_omp_target.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -86,7 +86,7 @@ static int omp_get_int_from_host(\n     return setting;\n }\n \n-void omp_set_num_threads_lrb(\n+DLL_LOCAL void omp_set_num_threads_lrb(\n     void *ofld\n )\n {\n@@ -96,7 +96,7 @@ void omp_set_num_threads_lrb(\n     omp_set_num_threads(num_threads);\n }\n \n-void omp_get_max_threads_lrb(\n+DLL_LOCAL void omp_get_max_threads_lrb(\n     void *ofld\n )\n {\n@@ -106,7 +106,7 @@ void omp_get_max_threads_lrb(\n     omp_send_int_to_host(ofld, num_threads);\n }\n \n-void omp_get_num_procs_lrb(\n+DLL_LOCAL void omp_get_num_procs_lrb(\n     void *ofld\n )\n {\n@@ -116,7 +116,7 @@ void omp_get_num_procs_lrb(\n     omp_send_int_to_host(ofld, num_procs);\n }\n \n-void omp_set_dynamic_lrb(\n+DLL_LOCAL void omp_set_dynamic_lrb(\n     void *ofld\n )\n {\n@@ -126,7 +126,7 @@ void omp_set_dynamic_lrb(\n     omp_set_dynamic(dynamic);\n }\n \n-void omp_get_dynamic_lrb(\n+DLL_LOCAL void omp_get_dynamic_lrb(\n     void *ofld\n )\n {\n@@ -136,7 +136,7 @@ void omp_get_dynamic_lrb(\n     omp_send_int_to_host(ofld, dynamic);\n }\n \n-void omp_set_nested_lrb(\n+DLL_LOCAL void omp_set_nested_lrb(\n     void *ofld\n )\n {\n@@ -146,7 +146,7 @@ void omp_set_nested_lrb(\n     omp_set_nested(nested);\n }\n \n-void omp_get_nested_lrb(\n+DLL_LOCAL void omp_get_nested_lrb(\n     void *ofld\n )\n {\n@@ -156,7 +156,7 @@ void omp_get_nested_lrb(\n     omp_send_int_to_host(ofld, nested);\n }\n \n-void omp_set_schedule_lrb(\n+DLL_LOCAL void omp_set_schedule_lrb(\n     void *ofld_\n )\n {\n@@ -180,7 +180,7 @@ void omp_set_schedule_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_get_schedule_lrb(\n+DLL_LOCAL void omp_get_schedule_lrb(\n     void *ofld_\n )\n {\n@@ -206,7 +206,7 @@ void omp_get_schedule_lrb(\n \n // lock API functions\n \n-void omp_init_lock_lrb(\n+DLL_LOCAL void omp_init_lock_lrb(\n     void *ofld_\n )\n {\n@@ -224,7 +224,7 @@ void omp_init_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_destroy_lock_lrb(\n+DLL_LOCAL void omp_destroy_lock_lrb(\n     void *ofld_\n )\n {\n@@ -242,7 +242,7 @@ void omp_destroy_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_set_lock_lrb(\n+DLL_LOCAL void omp_set_lock_lrb(\n     void *ofld_\n )\n {\n@@ -260,7 +260,7 @@ void omp_set_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_unset_lock_lrb(\n+DLL_LOCAL void omp_unset_lock_lrb(\n     void *ofld_\n )\n {\n@@ -278,7 +278,7 @@ void omp_unset_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_test_lock_lrb(\n+DLL_LOCAL void omp_test_lock_lrb(\n     void *ofld_\n )\n {\n@@ -304,7 +304,7 @@ void omp_test_lock_lrb(\n \n // nested lock API functions\n \n-void omp_init_nest_lock_lrb(\n+DLL_LOCAL void omp_init_nest_lock_lrb(\n     void *ofld_\n )\n {\n@@ -322,7 +322,7 @@ void omp_init_nest_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_destroy_nest_lock_lrb(\n+DLL_LOCAL void omp_destroy_nest_lock_lrb(\n     void *ofld_\n )\n {\n@@ -340,7 +340,7 @@ void omp_destroy_nest_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_set_nest_lock_lrb(\n+DLL_LOCAL void omp_set_nest_lock_lrb(\n     void *ofld_\n )\n {\n@@ -358,7 +358,7 @@ void omp_set_nest_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_unset_nest_lock_lrb(\n+DLL_LOCAL void omp_unset_nest_lock_lrb(\n     void *ofld_\n )\n {\n@@ -376,7 +376,7 @@ void omp_unset_nest_lock_lrb(\n     OFFLOAD_TARGET_LEAVE(ofld);\n }\n \n-void omp_test_nest_lock_lrb(\n+DLL_LOCAL void omp_test_nest_lock_lrb(\n     void *ofld_\n )\n {"}, {"sha": "9a7ac3b6f63fc34f19ae41fd7148b5b62c0485f4", "filename": "liboffloadmic/runtime/offload_orsl.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_orsl.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -36,7 +36,7 @@\n namespace ORSL {\n \n static bool            is_enabled = false;\n-static const ORSLTag   my_tag = \"Offload\";\n+static const ORSLTag   my_tag = (const ORSLTag) \"Offload\";\n \n void init()\n {"}, {"sha": "df3f5fc36ea0f40aeffda83ecaaa8171a689cfc2", "filename": "liboffloadmic/runtime/offload_orsl.h", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_orsl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_orsl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_orsl.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -28,17 +28,19 @@\n */\n \n \n+#include \"offload_util.h\"\n+\n #ifndef OFFLOAD_ORSL_H_INCLUDED\n #define OFFLOAD_ORSL_H_INCLUDED\n \n // ORSL interface\n namespace ORSL {\n \n-extern void init();\n+DLL_LOCAL extern void init();\n \n-extern bool reserve(int device);\n-extern bool try_reserve(int device);\n-extern void release(int device);\n+DLL_LOCAL extern bool reserve(int device);\n+DLL_LOCAL extern bool try_reserve(int device);\n+DLL_LOCAL extern void release(int device);\n \n } // namespace ORSL\n "}, {"sha": "f3c5100cacd922fe2693023c60119d20586ee312", "filename": "liboffloadmic/runtime/offload_table.cpp", "status": "modified", "additions": 219, "deletions": 1, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_table.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_table.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -321,6 +321,8 @@ extern \"C\" void __offload_unregister_tables(\n     VarList::Node *var_table\n )\n {\n+    OFFLOAD_DEBUG_TRACE(2, \"Unregistering offload function entry table %p\\n\",\n+                           entry_table);\n     __offload_entries.remove_table(entry_table);\n \n     OFFLOAD_DEBUG_TRACE(2, \"Unregistering function table %p\\n\", func_table);\n@@ -329,3 +331,219 @@ extern \"C\" void __offload_unregister_tables(\n     OFFLOAD_DEBUG_TRACE(2, \"Unregistering var table %p\\n\", var_table);\n     __offload_vars.remove_table(var_table);\n }\n+\n+#ifdef MYO_SUPPORT\n+\n+MYOVarTableList  __offload_myo_var_tables;\n+MYOVarTableList  __offload_myo_vtable_tables;\n+MYOFuncTableList __offload_myo_func_tables;\n+MYOInitTableList __offload_myo_init_tables;\n+\n+// Debugging dump\n+void MYOVarTableList::dump(void)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"MYO Var tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        OFFLOAD_DEBUG_TRACE(2, \"    MYO Var table:\\n\");\n+        for (const Table::Entry *e = n->table.entries;\n+             e->varName != MYO_TABLE_END_MARKER(); e++) {\n+#ifdef TARGET_WINNT\n+            if (e->varName == 0) {\n+                continue;\n+            }\n+#endif // TARGET_WINNT\n+            OFFLOAD_DEBUG_TRACE(2, \"        %s %p\\n\",\n+                e->varName, e->sharedAddr);\n+        }\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// check if any shared variables\n+bool MYOVarTableList::is_empty()\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"Are MYO Var tables empty?\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        for (const Table::Entry *e = n->table.entries;\n+             e->varName != MYO_TABLE_END_MARKER(); e++) {\n+#ifdef TARGET_WINNT\n+            if (e->varName == 0) {\n+                continue;\n+            }\n+#endif // TARGET_WINNT\n+            m_lock.unlock();\n+            OFFLOAD_DEBUG_TRACE(3, \"No\\n\");\n+            return false;\n+        }\n+    }\n+\n+    m_lock.unlock();\n+    OFFLOAD_DEBUG_TRACE(3, \"Yes\\n\");\n+    return true;\n+}\n+\n+void MYOFuncTableList::dump(void)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"MYO Func tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        OFFLOAD_DEBUG_TRACE(2, \"    MYO Func table:\\n\");\n+        for (const Table::Entry *e = n->table.entries;\n+             e->funcName != MYO_TABLE_END_MARKER(); e++) {\n+#ifdef TARGET_WINNT\n+            if (e->funcName == 0) {\n+                continue;\n+            }\n+#endif // TARGET_WINNT\n+#if HOST_LIBRARY\n+            OFFLOAD_DEBUG_TRACE(2, \"        %s %p %p\\n\",\n+                e->funcName, e->funcAddr, e->localThunkAddr);\n+#else // HOST_LIBRARY\n+            OFFLOAD_DEBUG_TRACE(2, \"        %s %p %p %p\\n\",\n+                e->funcName, e->funcAddr, e->wrapFuncAddr, e->localThunkAddr);\n+#endif // HOST_LIBRARY\n+        }\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// check if any shared functions\n+bool MYOFuncTableList::is_empty()\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"Are MYO Func tables empty?\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        int count = 0;\n+        for (const Table::Entry *e = n->table.entries;\n+             e->funcName != MYO_TABLE_END_MARKER(); e++) {\n+#ifdef TARGET_WINNT\n+            if (e->funcName == 0) {\n+                continue;\n+            }\n+#endif // TARGET_WINNT\n+            count++;\n+            if (count > 1) {\n+                m_lock.unlock();\n+                OFFLOAD_DEBUG_TRACE(3, \"No\\n\");\n+                return false;\n+            }\n+        }\n+    }\n+\n+    m_lock.unlock();\n+    OFFLOAD_DEBUG_TRACE(3, \"Yes\\n\");\n+    return true;\n+}\n+\n+void MYOInitTableList::dump(void)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"MYO Init tables:\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        OFFLOAD_DEBUG_TRACE(2, \"    MYO Init table:\\n\");\n+        for (const Table::Entry *e = n->table.entries;\n+#ifdef TARGET_WINNT\n+             e->funcName != MYO_TABLE_END_MARKER(); e++) {\n+            if (e->funcName == 0) {\n+                continue;\n+            }\n+            OFFLOAD_DEBUG_TRACE(2, \"        %s %p\\n\", e->funcName, e->func);\n+#else // TARGET_WINNT\n+             e->func != 0; e++) {\n+            OFFLOAD_DEBUG_TRACE(2, \"        %p\\n\", e->func);\n+#endif // TARGET_WINNT\n+        }\n+    }\n+\n+    m_lock.unlock();\n+}\n+\n+// check if any shared functions\n+bool MYOInitTableList::is_empty()\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"Are MYO Init tables empty?\\n\");\n+\n+    m_lock.lock();\n+\n+    for (Node *n = m_head; n != 0; n = n->next) {\n+        for (const Table::Entry *e = n->table.entries;\n+#ifdef TARGET_WINNT\n+             e->funcName != MYO_TABLE_END_MARKER(); e++) {\n+            if (e->funcName == 0) {\n+                continue;\n+            }\n+            m_lock.unlock();\n+            OFFLOAD_DEBUG_TRACE(3, \"No\\n\");\n+            return false;\n+#else // TARGET_WINNT\n+             e->func != 0; e++) {\n+#endif // TARGET_WINNT\n+        }\n+    }\n+\n+    m_lock.unlock();\n+    OFFLOAD_DEBUG_TRACE(3, \"Yes\\n\");\n+    return true;\n+}\n+\n+extern \"C\" void __offload_myoRegisterTables1(\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(2, \"Registering MYO shared var table %p\\n\",\n+                        shared_table);\n+    __offload_myo_var_tables.add_table(shared_table);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Registering MYO shared vtable table %p\\n\",\n+                        shared_vtable);\n+    __offload_myo_vtable_tables.add_table(shared_vtable);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Registering MYO function table %p\\n\", fptr_table);\n+    __offload_myo_func_tables.add_table(fptr_table);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Registering MYO init table %p\\n\", init_table);\n+    __offload_myo_init_tables.add_table(init_table);\n+}\n+\n+extern \"C\" void __offload_myoRemoveTables(\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+)\n+{\n+    OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Removing MYO shared var table %p\\n\",\n+                        shared_table);\n+    __offload_myo_var_tables.remove_table(shared_table);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Removing MYO shared vtable table %p\\n\",\n+                        shared_vtable);\n+    __offload_myo_vtable_tables.remove_table(shared_vtable);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Removing MYO function table %p\\n\", fptr_table);\n+    __offload_myo_func_tables.remove_table(fptr_table);\n+\n+    OFFLOAD_DEBUG_TRACE(2, \"Removing MYO init table %p\\n\", init_table);\n+    __offload_myo_init_tables.remove_table(init_table);\n+}\n+\n+#endif // MYO_SUPPORT"}, {"sha": "5602f2bfc42f3123d93beea496c3b0ceaf1132b2", "filename": "liboffloadmic/runtime/offload_table.h", "status": "modified", "additions": 210, "deletions": 74, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_table.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -35,7 +35,6 @@\n #ifndef OFFLOAD_TABLE_H_INCLUDED\n #define OFFLOAD_TABLE_H_INCLUDED\n \n-#include <iterator>\n #include \"offload_util.h\"\n \n // Template representing double linked list of tables\n@@ -56,7 +55,6 @@ template <typename T> class TableList {\n \n     void add_table(Node *node) {\n         m_lock.lock();\n-\n         if (m_head != 0) {\n             node->next = m_head;\n             m_head->prev = node;\n@@ -67,8 +65,6 @@ template <typename T> class TableList {\n     }\n \n     void remove_table(Node *node) {\n-        m_lock.lock();\n-\n         if (node->next != 0) {\n             node->next->prev = node->prev;\n         }\n@@ -78,8 +74,6 @@ template <typename T> class TableList {\n         if (m_head == node) {\n             m_head = node->next;\n         }\n-\n-        m_lock.unlock();\n     }\n \n protected:\n@@ -109,7 +103,7 @@ struct FuncTable {\n };\n \n // Function table\n-class FuncList : public TableList<FuncTable> {\n+class DLL_LOCAL FuncList : public TableList<FuncTable> {\n public:\n     explicit FuncList(Node *node = 0) : TableList<Table>(node),\n                                         m_max_name_len(-1)\n@@ -172,7 +166,7 @@ struct VarTable {\n };\n \n // List of var tables\n-class VarList : public TableList<VarTable> {\n+class DLL_LOCAL VarList : public TableList<VarTable> {\n public:\n     VarList() : TableList<Table>()\n     {}\n@@ -181,69 +175,9 @@ class VarList : public TableList<VarTable> {\n     void dump();\n \n public:\n-    // var table list iterator\n-    class Iterator : public std::iterator<std::input_iterator_tag,\n-                                          Table::Entry> {\n-    public:\n-        Iterator() : m_node(0), m_entry(0) {}\n-\n-        explicit Iterator(Node *node) {\n-            new_node(node);\n-        }\n-\n-        Iterator& operator++() {\n-            if (m_entry != 0) {\n-                m_entry++;\n-                while (m_entry->name == 0) {\n-                    m_entry++;\n-                }\n-                if (m_entry->name == reinterpret_cast<const char*>(-1)) {\n-                    new_node(m_node->next);\n-                }\n-            }\n-            return *this;\n-        }\n-\n-        bool operator==(const Iterator &other) const {\n-            return m_entry == other.m_entry;\n-        }\n-\n-        bool operator!=(const Iterator &other) const {\n-            return m_entry != other.m_entry;\n-        }\n-\n-        const Table::Entry* operator*() const {\n-            return m_entry;\n-        }\n-\n-    private:\n-        void new_node(Node *node) {\n-            m_node = node;\n-            m_entry = 0;\n-            while (m_node != 0) {\n-                m_entry = m_node->table.entries;\n-                while (m_entry->name == 0) {\n-                    m_entry++;\n-                }\n-                if (m_entry->name != reinterpret_cast<const char*>(-1)) {\n-                    break;\n-                }\n-                m_node = m_node->next;\n-                m_entry = 0;\n-            }\n-        }\n-\n-    private:\n-        Node                *m_node;\n-        const Table::Entry  *m_entry;\n-    };\n-\n-    Iterator begin() const {\n-        return Iterator(m_head);\n-    }\n \n-    Iterator end() const {\n-        return Iterator();\n+    Node * get_head() {\n+        return m_head;\n     }\n \n public:\n@@ -265,9 +199,9 @@ class VarList : public TableList<VarTable> {\n     static void table_patch_names(void *buf, int64_t nelems);\n };\n \n-extern FuncList __offload_entries;\n-extern FuncList __offload_funcs;\n-extern VarList  __offload_vars;\n+DLL_LOCAL extern FuncList __offload_entries;\n+DLL_LOCAL extern FuncList __offload_funcs;\n+DLL_LOCAL extern VarList  __offload_vars;\n \n // Section names where the lookup tables are stored\n #ifdef TARGET_WINNT\n@@ -318,4 +252,206 @@ extern \"C\" void __offload_unregister_tables(\n     FuncList::Node *func_table,\n     VarList::Node *var_table\n );\n+\n+\n+#ifdef MYO_SUPPORT\n+\n+#include <myotypes.h>\n+#include <myoimpl.h>\n+#include <myo.h>\n+\n+#ifdef TARGET_WINNT\n+#define MYO_TABLE_END_MARKER() reinterpret_cast<const char*>(-1)\n+#else // TARGET_WINNT\n+#define MYO_TABLE_END_MARKER() reinterpret_cast<const char*>(0)\n+#endif // TARGET_WINNT\n+\n+// Host and Target-side MYO shared variable table entry layout\n+typedef MyoiSharedVarEntry SharedTableEntry;\n+\n+#if HOST_LIBRARY\n+\n+// Host-side MYO function table entry layout\n+typedef struct {\n+    //! Function Name\n+    const char *funcName;\n+    //! Function Address\n+    void *funcAddr;\n+    //! Local Thunk Address\n+    void *localThunkAddr;\n+#ifdef TARGET_WINNT\n+    // Dummy to pad up to 32 bytes\n+    void *dummy;\n+#endif // TARGET_WINNT\n+} FptrTableEntry;\n+\n+// Host-side MYO init routine table entry layout\n+typedef struct {\n+#ifdef TARGET_WINNT\n+    // Dummy to pad up to 16 bytes\n+    // Function Name\n+    const char *funcName;\n+#endif // TARGET_WINNT\n+    void (*func)(MyoArena);\n+} InitTableEntry;\n+\n+#else // HOST_LIBRARY\n+\n+// Target-side MYO function table entry layout\n+typedef MyoiTargetSharedFptrEntry   FptrTableEntry;\n+\n+// Target-side MYO init routine table entry layout\n+struct InitTableEntry {\n+    void (*func)(void);\n+};\n+\n+#endif // HOST_LIBRARY\n+\n+#ifdef TARGET_WINNT\n+\n+#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable$a\"\n+#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable$z\"\n+\n+#define OFFLOAD_MYO_SHARED_VTABLE_SECTION_START         \".MyoSharedVTable$a\"\n+#define OFFLOAD_MYO_SHARED_VTABLE_SECTION_END           \".MyoSharedVTable$z\"\n+\n+#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START     \".MyoSharedInitTable$a\"\n+#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END       \".MyoSharedInitTable$z\"\n+\n+#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable$a\"\n+#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable$z\"\n+\n+#else  // TARGET_WINNT\n+\n+#define OFFLOAD_MYO_SHARED_TABLE_SECTION_START          \".MyoSharedTable.\"\n+#define OFFLOAD_MYO_SHARED_TABLE_SECTION_END            \".MyoSharedTable.\"\n+\n+#define OFFLOAD_MYO_SHARED_VTABLE_SECTION_START         \".MyoSharedVTable.\"\n+#define OFFLOAD_MYO_SHARED_VTABLE_SECTION_END           \".MyoSharedVTable.\"\n+\n+#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START     \".MyoSharedInitTable.\"\n+#define OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END       \".MyoSharedInitTable.\"\n+\n+#define OFFLOAD_MYO_FPTR_TABLE_SECTION_START            \".MyoFptrTable.\"\n+#define OFFLOAD_MYO_FPTR_TABLE_SECTION_END              \".MyoFptrTable.\"\n+\n+#endif // TARGET_WINNT\n+\n+#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_START, read, write)\n+#pragma section(OFFLOAD_MYO_SHARED_TABLE_SECTION_END, read, write)\n+\n+#pragma section(OFFLOAD_MYO_SHARED_VTABLE_SECTION_START, read, write)\n+#pragma section(OFFLOAD_MYO_SHARED_VTABLE_SECTION_END, read, write)\n+\n+#pragma section(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START, read, write)\n+#pragma section(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END, read, write)\n+\n+#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_START, read, write)\n+#pragma section(OFFLOAD_MYO_FPTR_TABLE_SECTION_END, read, write)\n+\n+// List of MYO shared variable tables\n+struct MYOVarTable {\n+    typedef SharedTableEntry Entry;\n+    const Entry *entries;\n+};\n+\n+class MYOVarTableList : public TableList<MYOVarTable> {\n+public:\n+    MYOVarTableList() : TableList<Table>()\n+    {}\n+\n+    // add table to the list\n+    void add_table(Node *node) {\n+        // add table\n+        TableList<Table>::add_table(node);\n+    }\n+\n+    // debug dump\n+    void dump(void);\n+\n+    // check if any shared variables\n+    bool is_empty();\n+\n+    // process the table contents for ordinary variables\n+    void process();\n+\n+    // process the table contents for vtable objects\n+    void process_vtable();\n+};\n+\n+// List of MYO shared function tables\n+struct MYOFuncTable {\n+    typedef FptrTableEntry Entry;\n+    const Entry *entries;\n+};\n+\n+class MYOFuncTableList : public TableList<MYOFuncTable> {\n+public:\n+    MYOFuncTableList() : TableList<Table>()\n+    {}\n+\n+    // add table to the list\n+    void add_table(Node *node) {\n+        // add table\n+        TableList<Table>::add_table(node);\n+    }\n+\n+    // debug dump\n+    void dump(void);\n+\n+    // check if any shared functions\n+    bool is_empty();\n+\n+    // process the table contents\n+    void process();\n+};\n+\n+// List of MYO shared variable initialization routine tables\n+struct MYOInitTable {\n+    typedef InitTableEntry Entry;\n+    const Entry *entries;\n+};\n+\n+class MYOInitTableList : public TableList<MYOInitTable> {\n+public:\n+    MYOInitTableList() : TableList<Table>()\n+    {}\n+\n+    // add table to the list\n+    void add_table(Node *node) {\n+        // add table\n+        TableList<Table>::add_table(node);\n+    }\n+\n+    // debug dump\n+    void dump(void);\n+\n+    // check if any init routines\n+    bool is_empty();\n+\n+    // process the table contents\n+    void process();\n+};\n+\n+extern MYOVarTableList  __offload_myo_var_tables;\n+extern MYOVarTableList  __offload_myo_vtable_tables;\n+extern MYOFuncTableList __offload_myo_func_tables;\n+extern MYOInitTableList __offload_myo_init_tables;\n+\n+extern \"C\" void __offload_myoRegisterTables1(\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+); \n+\n+extern \"C\" void __offload_myoRemoveTables(\n+    MYOInitTableList::Node *init_table,\n+    MYOVarTableList::Node  *shared_table,\n+    MYOVarTableList::Node  *shared_vtable,\n+    MYOFuncTableList::Node *fptr_table\n+);\n+\n+#endif // MYO_SUPPORT\n+\n #endif  // OFFLOAD_TABLE_H_INCLUDED"}, {"sha": "e3c13746cefe7ea186af00512aae77830ce36031", "filename": "liboffloadmic/runtime/offload_target.cpp", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -114,6 +114,8 @@ static void BufReleaseRef(void * buf)\n     if (info) {\n         --info->count;\n         if (info->count == 0 && info->is_added) {\n+            OFFLOAD_TRACE(1, \"Calling COIBufferReleaseRef AddRef count = %d\\n\",\n+                                              ((RefInfo *) ref_data[buf])->count);\n             BufferReleaseRef(buf);\n             info->is_added = 0;\n         }\n@@ -360,7 +362,6 @@ void OffloadDescriptor::scatter_copyin_data()\n         if (m_vars[i].flags.alloc_disp) {\n             int64_t offset = 0;\n             m_in.receive_data(&offset, sizeof(offset));\n-            m_vars[i].offset = -offset;\n         }\n         if (VAR_TYPE_IS_DV_DATA_SLICE(type) ||\n             VAR_TYPE_IS_DV_DATA(type)) {\n@@ -369,7 +370,6 @@ void OffloadDescriptor::scatter_copyin_data()\n                   *reinterpret_cast<ArrDesc**>(ptr_addr);\n             ptr_addr = reinterpret_cast<void**>(&dvp->Base);\n         }\n-\n         // Set pointer values\n         switch (type) {\n             case c_data_ptr_array:\n@@ -380,6 +380,9 @@ void OffloadDescriptor::scatter_copyin_data()\n                         *(reinterpret_cast<char**>(m_vars[i].ptr)) :\n                         reinterpret_cast<char*>(m_vars[i].into);\n \n+                    if (m_vars[i].flags.is_pointer) {\n+                        dst_arr_ptr = *((char**)dst_arr_ptr);\n+                    }\n                     for (; j < max_el; j++) {\n                         if (src_is_for_mic) {\n                             m_vars[j].ptr =\n@@ -402,8 +405,8 @@ void OffloadDescriptor::scatter_copyin_data()\n             case c_data_ptr:\n             case c_cean_var_ptr:\n             case c_dv_ptr:\n-                if (m_vars[i].alloc_if) {\n-                    void *buf;\n+                if (m_vars[i].alloc_if && !m_vars[i].flags.preallocated) {\n+                    void *buf = NULL;\n                     if (m_vars[i].flags.sink_addr) {\n                         m_in.receive_data(&buf, sizeof(buf));\n                     }\n@@ -417,9 +420,12 @@ void OffloadDescriptor::scatter_copyin_data()\n                                 // increment buffer reference\n                                 OFFLOAD_TIMER_START(c_offload_target_add_buffer_refs);\n                                 BufferAddRef(buf);\n+                                OFFLOAD_TRACE(1, \"Calling COIBufferAddRef %p\\n\", buf);\n                                 OFFLOAD_TIMER_STOP(c_offload_target_add_buffer_refs);\n                             }\n                             add_ref_count(buf, 0 == m_vars[i].flags.sink_addr);\n+                            OFFLOAD_TRACE(1, \"    AddRef count = %d\\n\",\n+                                              ((RefInfo *) ref_data[buf])->count);\n                         }\n                         ptr = static_cast<char*>(buf) +\n                                   m_vars[i].mic_offset +\n@@ -597,6 +603,7 @@ void OffloadDescriptor::gather_copyout_data()\n             case c_dv_ptr:\n                 if (m_vars[i].free_if &&\n                     src_is_for_mic &&\n+                    !m_vars[i].flags.preallocated &&\n                     !m_vars[i].flags.is_static) {\n                     void *buf = *static_cast<char**>(m_vars[i].ptr) -\n                                     m_vars[i].mic_offset -\n@@ -610,6 +617,9 @@ void OffloadDescriptor::gather_copyout_data()\n                     BufReleaseRef(buf);\n                     OFFLOAD_TIMER_STOP(c_offload_target_release_buffer_refs);\n                 }\n+                if (m_vars[i].flags.preallocated && m_vars[i].alloc_if) {\n+                    m_out.send_data((void*) m_vars[i].ptr, sizeof(void*));\n+                }\n                 break;\n \n             case c_func_ptr:"}, {"sha": "5638796f2d1d623ca76a7ae860a26d08e328568b", "filename": "liboffloadmic/runtime/offload_target.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -99,16 +99,16 @@ class OffloadDescriptor\n };\n \n // one time target initialization in main\n-extern void __offload_target_init(void);\n+DLL_LOCAL extern void __offload_target_init(void);\n \n // logical device index\n-extern int mic_index;\n+DLL_LOCAL extern int mic_index;\n \n // total number of available logical devices\n-extern int mic_engines_total;\n+DLL_LOCAL extern int mic_engines_total;\n \n // device frequency (from COI)\n-extern uint64_t mic_frequency;\n+DLL_LOCAL extern uint64_t mic_frequency;\n \n struct RefInfo {\n     RefInfo(bool is_add, long amount):is_added(is_add),count(amount)"}, {"sha": "b95271c10d5b633d69e273b3e74c55ff79b11ded", "filename": "liboffloadmic/runtime/offload_target_main.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_target_main.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_target_main.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "8da1391c24c204322ffe3f98d904d5132a028680", "filename": "liboffloadmic/runtime/offload_timer.h", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -36,7 +36,7 @@\n #include <stdint.h>\n #include \"liboffload_error_codes.h\"\n \n-extern int timer_enabled;\n+DLL_LOCAL extern int timer_enabled;\n \n #ifdef TIMING_SUPPORT\n \n@@ -73,8 +73,8 @@ struct OffloadHostTimerData {\n \n #if HOST_LIBRARY\n \n-extern int offload_report_level;\n-extern int offload_report_enabled;\n+DLL_LOCAL extern int offload_report_level;\n+DLL_LOCAL extern int offload_report_enabled;\n #define OFFLOAD_REPORT_1 1\n #define OFFLOAD_REPORT_2 2\n #define OFFLOAD_REPORT_3 3\n@@ -121,18 +121,18 @@ extern int offload_report_enabled;\n         offload_timer_fill_host_mic_num(timer_data, data); \\\n     }\n \n-extern void offload_timer_start(OffloadHostTimerData *,\n+extern DLL_LOCAL void offload_timer_start(OffloadHostTimerData *,\n                                 OffloadHostPhase t_node);\n-extern void offload_timer_stop(OffloadHostTimerData *,\n+extern DLL_LOCAL void offload_timer_stop(OffloadHostTimerData *,\n                                OffloadHostPhase t_node);\n-extern OffloadHostTimerData * offload_timer_init(const char *file, int line);\n-extern void offload_timer_fill_target_data(OffloadHostTimerData *,\n+extern DLL_LOCAL OffloadHostTimerData * offload_timer_init(const char *file, int line);\n+extern DLL_LOCAL void offload_timer_fill_target_data(OffloadHostTimerData *,\n                                            void *data);\n-extern void offload_timer_fill_host_sdata(OffloadHostTimerData *,\n+extern DLL_LOCAL void offload_timer_fill_host_sdata(OffloadHostTimerData *,\n                                           uint64_t sent_bytes);\n-extern void offload_timer_fill_host_rdata(OffloadHostTimerData *,\n+extern DLL_LOCAL void offload_timer_fill_host_rdata(OffloadHostTimerData *,\n                                           uint64_t sent_bytes);\n-extern void offload_timer_fill_host_mic_num(OffloadHostTimerData *,\n+extern DLL_LOCAL void offload_timer_fill_host_mic_num(OffloadHostTimerData *,\n                                             int card_number);\n \n // Utility structure for starting/stopping timer\n@@ -172,10 +172,10 @@ struct OffloadTimer {\n #define OFFLOAD_TIMER_TARGET_DATA(data) \\\n     if (timer_enabled) offload_timer_fill_target_data(data);\n \n-extern void offload_timer_start(OffloadTargetPhase t_node);\n-extern void offload_timer_stop(OffloadTargetPhase t_node);\n-extern void offload_timer_init(void);\n-extern void offload_timer_fill_target_data(void *data);\n+extern DLL_LOCAL void offload_timer_start(OffloadTargetPhase t_node);\n+extern DLL_LOCAL void offload_timer_stop(OffloadTargetPhase t_node);\n+extern DLL_LOCAL void offload_timer_init(void);\n+extern DLL_LOCAL void offload_timer_fill_target_data(void *data);\n \n #endif // HOST_LIBRARY\n "}, {"sha": "2152e1e8f2094b7f3c6c839d7741b47050e32348", "filename": "liboffloadmic/runtime/offload_timer_host.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_host.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "9e2b6d1f156e8258be8a7f62217c4ed6298bb567", "filename": "liboffloadmic/runtime/offload_timer_target.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_timer_target.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "2609360d5f3d06f92af6dc8a0b952675f390dd7a", "filename": "liboffloadmic/runtime/offload_trace.cpp", "status": "modified", "additions": 92, "deletions": 12, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_trace.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -73,7 +73,7 @@ static const char * offload_stage(std::stringstream &ss,\n     return 0;\n }\n \n-static const char * offload_signal(std::stringstream &ss,\n+static const char * offload_message_2str(std::stringstream &ss,\n                                   int offload_number,\n                                   const char *tag,\n                                   const char *text)\n@@ -216,27 +216,57 @@ void offload_stage_print(int stage, int offload_number, ...)\n                 uint64_t  *signal;\n                 str1 = report_get_message_str(c_report_state_signal);\n                 str2 = report_get_message_str(c_report_signal);\n-                offload_signal(ss, offload_number, str1, str2);\n-\t        signal = va_arg(va_args, uint64_t*);\n-\t        if (signal)\n-                   ss << \" 0x\" << std::hex << *signal;\n+                offload_message_2str(ss, offload_number, str1, str2);\n+                signal = va_arg(va_args, uint64_t*);\n+                if (signal)\n+                    ss << \" 0x\" << std::hex << *signal;\n                 else\n-                   ss << \" none\";\n+                    ss << \" none\";\n+            }\n+            break;\n+        case c_offload_stream:\n+            {\n+                int64_t  stream;\n+                str1 = report_get_message_str(c_report_state_stream);\n+                str2 = report_get_message_str(c_report_stream);\n+                offload_message_2str(ss, offload_number, str1, str2);\n+                stream = va_arg(va_args, int64_t);\n+                if (stream)\n+                    ss << \" 0x\" << std::hex << stream;\n+                else\n+                    ss << \" none\";\n             }\n             break;\n         case c_offload_wait:\n             {\n                 int count;\n+                OffloadWaitKind kind;\n                 uint64_t  **signal;\n-                str1 = report_get_message_str(c_report_state_signal);\n+                kind = (enum OffloadWaitKind) va_arg(va_args, int);\n+                // kind ==  c_offload_wait_signal for signal;\n+                // other kinds are for stream\n+                if (kind == c_offload_wait_signal) {\n+                    str1 = report_get_message_str(c_report_state_signal);\n+                }\n+                else {\n+                    str1 = report_get_message_str(c_report_state_stream);\n+                }\n                 str2 = report_get_message_str(c_report_wait);\n-                offload_signal(ss, offload_number, str1, str2);\n+                offload_message_2str(ss, offload_number, str1, str2);\n                 count = va_arg(va_args, int);\n                 signal = va_arg(va_args, uint64_t**);\n                 if (count) {\n-                    while (count) {\n-                        ss << \" \" << std::hex << signal[count-1];\n-                        count--;\n+                    if (kind == c_offload_wait_signal) {\n+                        while (count) {\n+                            ss << \" \" << std::hex << signal[count-1];\n+                            count--;\n+                        }\n+                    }\n+                    else if (kind == c_offload_wait_stream) {\n+                        ss << signal;\n+                    }\n+                    else {\n+                        ss << \" all\";\n                     }\n                 }\n                 else\n@@ -304,6 +334,7 @@ void offload_stage_print(int stage, int offload_number, ...)\n             str1 = report_get_message_str(c_report_state);\n             str2 = report_get_message_str(c_report_myosharedalignedfree);\n             offload_stage(ss, offload_number, str1, str2, false);\n+            ss << \" \" << va_arg(va_args, size_t);\n             break;\n         case c_offload_myoacquire:\n             str1 = report_get_message_str(c_report_state);\n@@ -315,6 +346,55 @@ void offload_stage_print(int stage, int offload_number, ...)\n             str2 = report_get_message_str(c_report_myorelease);\n             offload_stage(ss, offload_number, str1, str2, false);\n             break;\n+        case c_offload_myosupportsfeature:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myosupportsfeature);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, int);\n+            break;\n+        case c_offload_myosharedarenacreate:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myosharedarenacreate);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, char*);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, unsigned int);\n+            break;\n+        case c_offload_myosharedalignedarenamalloc:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myosharedalignedarenamalloc);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, char*);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, size_t);\n+            ss << \" \" << va_arg(va_args, size_t);\n+            break;\n+        case c_offload_myosharedalignedarenafree:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myosharedalignedarenafree);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, char*);\n+            ss << \" \" << va_arg(va_args, int);\n+            ss << \" \" << va_arg(va_args, size_t);\n+            break;\n+        case c_offload_myoarenaacquire:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myoarenaacquire);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, char*);\n+            ss << \" \" << va_arg(va_args, int);\n+            break;\n+        case c_offload_myoarenarelease:\n+            str1 = report_get_message_str(c_report_state);\n+            str2 = report_get_message_str(c_report_myoarenarelease);\n+            offload_stage(ss, offload_number, str1, str2, false);\n+            va_arg(va_args, char*);\n+            ss << \" \" << va_arg(va_args, int);\n+            break;\n         default:\n             LIBOFFLOAD_ERROR(c_report_unknown_trace_node);\n             abort();"}, {"sha": "1c2a6f4c050e7dcb64cc8dececfa8af64241f1e1", "filename": "liboffloadmic/runtime/offload_trace.h", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_trace.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -29,8 +29,9 @@\n \n \n // The parts of the offload library common to host and target\n+#include \"offload_util.h\"\n \n-void offload_stage_print(int stage, int offload_number, ...);\n+DLL_LOCAL void offload_stage_print(int stage, int offload_number, ...);\n \n enum OffloadTraceStage {\n     // Total time spent on the target\n@@ -68,5 +69,18 @@ enum OffloadTraceStage {\n     c_offload_myosharedalignedfree,\n     c_offload_myoacquire,\n     c_offload_myorelease,\n-    c_offload_myofini\n+    c_offload_myofini,\n+    c_offload_myosupportsfeature,\n+    c_offload_myosharedarenacreate,\n+    c_offload_myosharedalignedarenamalloc,\n+    c_offload_myosharedalignedarenafree,\n+    c_offload_myoarenaacquire,\n+    c_offload_myoarenarelease,\n+    c_offload_stream\n+};\n+\n+enum OffloadWaitKind {\n+    c_offload_wait_signal = 0,\n+    c_offload_wait_stream,\n+    c_offload_wait_all_streams\n };"}, {"sha": "5217e91c20545e5b7a4f01c2a2c21a0ef3b267ae", "filename": "liboffloadmic/runtime/offload_util.cpp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_util.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_util.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "894355aca7a8d52f9186218963d1ca69a6a7531e", "filename": "liboffloadmic/runtime/offload_util.h", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Foffload_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Foffload_util.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -31,14 +31,23 @@\n #ifndef OFFLOAD_UTIL_H_INCLUDED\n #define OFFLOAD_UTIL_H_INCLUDED\n \n-#include <stdio.h>\n #include <stdlib.h>\n-#include <stdint.h>\n \n #ifdef TARGET_WINNT\n+    #define DLL_LOCAL\n+#else\n+    #define DLL_LOCAL  __attribute__((visibility(\"hidden\")))\n+#endif\n+\n+#ifdef TARGET_WINNT\n+// Don't use <stdint.h> as compiling with VS2010 makes ofldbegin.obj\n+// incompatible with STL library of versions older than VS2010.\n+typedef unsigned long long int  uint64_t;\n+typedef signed long long int    int64_t;\n #include <windows.h>\n #include <process.h>\n #else // TARGET_WINNT\n+#include <stdint.h>\n #include <dlfcn.h>\n #include <pthread.h>\n #endif // TARGET_WINNT\n@@ -143,7 +152,7 @@ int     DL_addr(const void *addr, Dl_info *info);\n #define DL_addr(addr, info)     dladdr((addr), (info))\n #endif // TARGET_WINNT\n \n-extern void* DL_sym(void *handle, const char *name, const char *version);\n+DLL_LOCAL extern void* DL_sym(void *handle, const char *name, const char *version);\n \n // One-time initialization API\n #ifdef TARGET_WINNT\n@@ -159,13 +168,13 @@ typedef pthread_once_t              OffloadOnceControl;\n #endif // TARGET_WINNT\n \n // Parses size specification string.\n-extern bool __offload_parse_size_string(const char *str, uint64_t &new_size);\n+DLL_LOCAL extern bool __offload_parse_size_string(const char *str, uint64_t &new_size);\n \n // Parses string with integer value\n-extern bool __offload_parse_int_string(const char *str, int64_t &value);\n+DLL_LOCAL extern bool __offload_parse_int_string(const char *str, int64_t &value);\n \n // get value by its base, offset and size\n-int64_t get_el_value(\n+DLL_LOCAL int64_t get_el_value(\n     char   *base,\n     int64_t offset,\n     int64_t size"}, {"sha": "236500d011a7396c1fb8c98211444032db850dcd", "filename": "liboffloadmic/runtime/ofldbegin.cpp", "status": "modified", "additions": 163, "deletions": 15, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fofldbegin.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldbegin.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -29,14 +29,22 @@\n \n \n #if HOST_LIBRARY\n-#include \"offload_host.h\"\n+#include \"offload_table.h\"\n #include \"offload_myo_host.h\"\n #else\n #include \"compiler_if_target.h\"\n #include \"offload_target.h\"\n #include \"offload_myo_target.h\"\n #endif\n \n+// Initializes library and registers specified offload image.\n+// Don't use this declarations from offload_host.h as offload_table.h\n+// is used instead of it. Using offload_host.h contradicts with\n+// STL library compiled with VS2010.\n+extern \"C\" bool __offload_register_image(const void* image);\n+extern \"C\" void __offload_unregister_image(const void* image);\n+extern \"C\" bool __offload_target_image_is_executable(const void *image);\n+\n #ifdef TARGET_WINNT\n #define ALLOCATE(name) __declspec(allocate(name))\n #define DLL_LOCAL\n@@ -110,33 +118,127 @@ static VarList::Node __offload_var_node = {\n #ifdef MYO_SUPPORT\n \n // offload myo shared var section prolog\n+// first element is empty\n ALLOCATE(OFFLOAD_MYO_SHARED_TABLE_SECTION_START)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(SharedTableEntry)))\n #endif // TARGET_WINNT\n-static SharedTableEntry __offload_myo_shared_table_start = { 0 };\n+static MYOVarTable::Entry __offload_myo_shared_var_start = { 0 };\n+\n+// list element for the current module\n+// table entry pointer skips the empty first entry\n+static MYOVarTableList::Node __offload_myo_shared_var_node = {\n+    { &__offload_myo_shared_var_start + 1 },\n+    0, 0\n+};\n+\n+// offload myo shared vtable section prolog\n+// first element is empty\n+ALLOCATE(OFFLOAD_MYO_SHARED_VTABLE_SECTION_START)\n+#ifdef TARGET_WINNT\n+__declspec(align(sizeof(SharedTableEntry)))\n+#endif // TARGET_WINNT\n+static MYOVarTable::Entry __offload_myo_shared_vtable_start = { 0 };\n+\n+// list element for the current module\n+// table entry pointer skips the empty first entry\n+static MYOVarTableList::Node __offload_myo_shared_vtable_node = {\n+    { &__offload_myo_shared_vtable_start + 1 },\n+    0, 0\n+};\n \n-#if HOST_LIBRARY\n // offload myo shared var init section prolog\n+// first element is empty\n ALLOCATE(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_START)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(InitTableEntry)))\n #endif // TARGET_WINNT\n-static InitTableEntry __offload_myo_shared_init_table_start = { 0 };\n+static MYOInitTable::Entry __offload_myo_init_table_start = { 0 };\n+\n+// list element for the current module\n+// table entry pointer skips the empty first entry\n+static MYOInitTableList::Node __offload_myo_init_table_node = {\n+    { &__offload_myo_init_table_start + 1 },\n+    0, 0\n+};\n+\n+// The functions and variables needed for a built-in\n+// remote function entry for vtable initialization on MIC\n+\n+#if !HOST_LIBRARY\n+MyoError __offload_init_vtables(void)\n+{\n+    SharedTableEntry *t_start;\n+\n+    //OFFLOAD_DEBUG_TRACE(3, \"%s\\n\", __func__);\n+    t_start = &__offload_myo_shared_vtable_start + 1;\n+    //OFFLOAD_DEBUG_TRACE(3, \"%s(%p)\\n\", __func__, t_start);\n+    while (t_start->varName != 0) {\n+        //OFFLOAD_DEBUG_TRACE(4,\n+        //    \"myo shared vtable \\\"%s\\\" &myo_ptr = %p myo_ptr = %p\\n\",\n+        //    t_start->varName,\n+        //    (void *)(t_start->sharedAddr),\n+        //    ((void **)(t_start->sharedAddr))[0]);\n+        t_start++;\n+    }\n+\n+    __offload_myo_shared_init_table_process(\n+        &__offload_myo_init_table_start + 1);\n+    return MYO_SUCCESS;\n+}\n+#endif  // !HOST_LIBRARY\n+\n+static void vtable_initializer()\n+{\n+}\n+\n+#if !HOST_LIBRARY\n+static MyoError vtable_initializer_wrapper()\n+{\n+    __offload_myoAcquire();\n+    __offload_init_vtables();\n+    __offload_myoRelease();\n+    return MYO_SUCCESS;\n+}\n #endif\n \n+static void* __offload_vtable_initializer_thunk_ptr = 0;\n+\n // offload myo fptr section prolog\n+// first element is pre-initialized to the MIC vtable initializer\n ALLOCATE(OFFLOAD_MYO_FPTR_TABLE_SECTION_START)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(FptrTableEntry)))\n #endif // TARGET_WINNT\n-static FptrTableEntry __offload_myo_fptr_table_start = { 0 };\n+static MYOFuncTable::Entry __offload_myo_fptr_table_start = {\n+#if HOST_LIBRARY\n+    \"--vtable_initializer--\",\n+    (void*)&vtable_initializer,\n+    (void*)&__offload_vtable_initializer_thunk_ptr,\n+#ifdef TARGET_WINNT\n+    // Dummy to pad up to 32 bytes\n+    0\n+#endif // TARGET_WINNT\n+#else  // HOST_LIBRARY\n+    \"--vtable_initializer--\",\n+    (void*)&vtable_initializer,\n+    (void*)&vtable_initializer_wrapper,\n+    &__offload_vtable_initializer_thunk_ptr,\n+#endif // HOST_LIBRARY\n+};\n+\n+// list element for the current module\n+static MYOFuncTableList::Node __offload_myo_fptr_table_node = {\n+    { &__offload_myo_fptr_table_start },\n+    0, 0\n+};\n \n #endif // MYO_SUPPORT\n \n // init/fini code which adds/removes local lookup data to/from the global list\n \n static void offload_fini();\n+static void offload_fini_so();\n \n #ifndef TARGET_WINNT\n static void offload_init() __attribute__((constructor(101)));\n@@ -150,35 +252,81 @@ static void (*addressof_offload_init)() = offload_init;\n \n static void offload_init()\n {\n+    bool success;\n+\n     // register offload tables\n     __offload_register_tables(&__offload_entry_node,\n                               &__offload_func_node,\n                               &__offload_var_node);\n \n #if HOST_LIBRARY\n-    __offload_register_image(&__offload_target_image);\n-    atexit(offload_fini);\n+    success = __offload_register_image(&__offload_target_image);\n+    if (!success)\n+    {\n+        return;\n+    }\n #endif // HOST_LIBRARY\n-\n #ifdef MYO_SUPPORT\n-    __offload_myoRegisterTables(\n #if HOST_LIBRARY\n-        &__offload_myo_shared_init_table_start + 1,\n-#endif // HOST_LIBRARY\n-        &__offload_myo_shared_table_start + 1,\n-        &__offload_myo_fptr_table_start + 1\n+    // If this was the main program register main atexit routine\n+    if (__offload_myoProcessTables(\n+            &__offload_target_image,\n+            &__offload_myo_init_table_node,\n+            &__offload_myo_shared_var_node,\n+            &__offload_myo_shared_vtable_node,\n+            &__offload_myo_fptr_table_node))\n+    {\n+        atexit(offload_fini);\n+#ifdef TARGET_WINNT\n+    } else {\n+        atexit(offload_fini_so);\n+#endif\n+    }\n+#else // HOST_LIBRARY\n+    __offload_myoProcessTables(\n+        &__offload_myo_init_table_start + 1,\n+        &__offload_myo_shared_var_start + 1,\n+        &__offload_myo_shared_vtable_start + 1,\n+        &__offload_myo_fptr_table_start\n     );\n+#endif // HOST_LIBRARY\n #endif // MYO_SUPPORT\n }\n \n+#ifndef TARGET_WINNT\n+static void offload_fini_so() __attribute__((destructor(101)));\n+#else // TARGET_WINNT\n+static void offload_init_so();\n+#endif // TARGET_WINNT\n+\n static void offload_fini()\n {\n #if HOST_LIBRARY\n     __offload_unregister_image(&__offload_target_image);\n #endif // HOST_LIBRARY\n+}\n \n-    // unregister offload tables\n+static void offload_fini_so()\n+{\n+    // Offload and MYO tables need to be removed from list\n+    // to prevent invalid accesses after dlclose\n+    // Remove offload tables\n     __offload_unregister_tables(&__offload_entry_node,\n                                 &__offload_func_node,\n                                 &__offload_var_node);\n+#if HOST_LIBRARY\n+   if(!__offload_target_image_is_executable(&__offload_target_image)) {\n+      __offload_unregister_image(&__offload_target_image);\n+   }\n+#endif\n+#ifdef MYO_SUPPORT\n+#if HOST_LIBRARY\n+    // Remove MYO tables\n+    __offload_myoRemoveTables(\n+        &__offload_myo_init_table_node,\n+        &__offload_myo_shared_var_node,\n+        &__offload_myo_shared_vtable_node,\n+        &__offload_myo_fptr_table_node);\n+#endif // HOST_LIBRARY\n+#endif // MYO_SUPPORT\n }"}, {"sha": "1e522b7f2fa01136ed75b3173634d7043a21876a", "filename": "liboffloadmic/runtime/ofldend.cpp", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fofldend.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fofldend.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fofldend.cpp?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions\n@@ -29,7 +29,7 @@\n \n \n #if HOST_LIBRARY\n-#include \"offload_host.h\"\n+#include \"offload_table.h\"\n #include \"offload_myo_host.h\"\n #else\n #include \"offload_target.h\"\n@@ -69,29 +69,42 @@ static VarTable::Entry __offload_var_table_end = { (const char*)-1 };\n ALLOCATE(OFFLOAD_MYO_SHARED_TABLE_SECTION_END)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(SharedTableEntry)))\n-static SharedTableEntry __offload_myo_shared_table_end = { (const char*)-1, 0 };\n+static MYOVarTable::Entry __offload_myo_shared_var_end =\n+    { (const char*)-1, 0 };\n #else // TARGET_WINNT\n-static SharedTableEntry __offload_myo_shared_table_end = { 0 };\n+static MYOVarTable::Entry __offload_myo_shared_var_end = { 0 };\n #endif // TARGET_WINNT\n \n-#if HOST_LIBRARY\n+// offload myo shared vtable section epilog\n+ALLOCATE(OFFLOAD_MYO_SHARED_VTABLE_SECTION_END)\n+#ifdef TARGET_WINNT\n+__declspec(align(sizeof(SharedTableEntry)))\n+static MYOVarTable::Entry __offload_myo_shared_vtable_end =\n+    { (const char*)-1, 0 };\n+#else // TARGET_WINNT\n+static MYOVarTable::Entry __offload_myo_shared_vtable_end = { 0 };\n+#endif // TARGET_WINNT\n+\n+//#if HOST_LIBRARY\n // offload myo shared var init section epilog\n ALLOCATE(OFFLOAD_MYO_SHARED_INIT_TABLE_SECTION_END)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(InitTableEntry)))\n-static InitTableEntry __offload_myo_shared_init_table_end = { (const char*)-1, 0 };\n+static MYOInitTable::Entry __offload_myo_init_table_end =\n+    { (const char*)-1, 0 };\n #else // TARGET_WINNT\n-static InitTableEntry __offload_myo_shared_init_table_end = { 0 };\n+static MYOInitTable::Entry __offload_myo_init_table_end = { 0 };\n #endif // TARGET_WINNT\n-#endif // HOST_LIBRARY\n+//#endif // HOST_LIBRARY\n \n // offload myo fptr section epilog\n ALLOCATE(OFFLOAD_MYO_FPTR_TABLE_SECTION_END)\n #ifdef TARGET_WINNT\n __declspec(align(sizeof(FptrTableEntry)))\n-static FptrTableEntry __offload_myo_fptr_table_end = { (const char*)-1, 0, 0 };\n+static MYOFuncTable::Entry __offload_myo_fptr_table_end =\n+    { (const char*)-1, 0, 0 };\n #else // TARGET_WINNT\n-static FptrTableEntry __offload_myo_fptr_table_end = { 0 };\n+static MYOFuncTable::Entry __offload_myo_fptr_table_end = { 0 };\n #endif // TARGET_WINNT\n \n #endif // MYO_SUPPORT"}, {"sha": "53acea154de4df96966ed8013fa0cf369fc83b12", "filename": "liboffloadmic/runtime/orsl-lite/include/orsl-lite.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Finclude%2Forsl-lite.h?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "add67a0b0ca0bc62103326c3a59e37fa76c99f9f", "filename": "liboffloadmic/runtime/orsl-lite/lib/orsl-lite.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Forsl-lite%2Flib%2Forsl-lite.c?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1,5 +1,5 @@\n /*\n-    Copyright (c) 2014 Intel Corporation.  All Rights Reserved.\n+    Copyright (c) 2014-2015 Intel Corporation.  All Rights Reserved.\n \n     Redistribution and use in source and binary forms, with or without\n     modification, are permitted provided that the following conditions"}, {"sha": "47b322c971c3ce34b223693982d647bf2e352923", "filename": "liboffloadmic/runtime/use_mpss2.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2eab96661b6c08679ffd4a084f59f3935cfcddb9/liboffloadmic%2Fruntime%2Fuse_mpss2.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fruntime%2Fuse_mpss2.txt?ref=2eab96661b6c08679ffd4a084f59f3935cfcddb9", "patch": "@@ -1 +1 @@\n-2.1.6720-13\n+3.4.1"}]}