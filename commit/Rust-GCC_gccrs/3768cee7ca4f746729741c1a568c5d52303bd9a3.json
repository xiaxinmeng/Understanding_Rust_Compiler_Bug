{"sha": "3768cee7ca4f746729741c1a568c5d52303bd9a3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc2OGNlZTdjYTRmNzQ2NzI5NzQxYzFhNTY4YzVkNTIzMDNiZDlhMw==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-06-19T01:51:33Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-06-19T01:51:33Z"}, "message": "stl_raw_storage_iter.h: Format.\n\n\n2001-06-18  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* include/bits/stl_raw_storage_iter.h: Format. Correct derivation.\n\t* testsuite/20_util/raw_storage_iterator.cc: Same.\n\n        * include/bits/stl_alloc.h (_S_chunk_alloc): Change malloc to\n        operator new.\n        (__mem_interface): New typedef for switching between malloc and new.\n\t* testsuite/20_util/allocator_members.cc: New file.\n\n\t* testsuite/20_util/comparisons.cc: New file.\n\t* testsuite/20_util/pairs.cc: New file.\n\nFrom-SVN: r43451", "tree": {"sha": "87a287ac521ababd10f74a452eecb9ca5d10e0b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/87a287ac521ababd10f74a452eecb9ca5d10e0b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3768cee7ca4f746729741c1a568c5d52303bd9a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3768cee7ca4f746729741c1a568c5d52303bd9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3768cee7ca4f746729741c1a568c5d52303bd9a3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3768cee7ca4f746729741c1a568c5d52303bd9a3/comments", "author": null, "committer": null, "parents": [{"sha": "afbc5d8693b2f82cf772e417f6d4e2358cde5865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afbc5d8693b2f82cf772e417f6d4e2358cde5865", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afbc5d8693b2f82cf772e417f6d4e2358cde5865"}], "stats": {"total": 666, "additions": 507, "deletions": 159}, "files": [{"sha": "1bbe7bc313043963f491b620986fda9293add74a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -1,3 +1,16 @@\n+2001-06-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* include/bits/stl_raw_storage_iter.h: Format. Correct derivation.\n+\t* testsuite/20_util/raw_storage_iterator.cc: Same.\n+\t\n+        * include/bits/stl_alloc.h (_S_chunk_alloc): Change malloc to\n+        operator new.\n+        (__mem_interface): New typedef for switching between malloc and new.\n+\t* testsuite/20_util/allocator_members.cc: New file.\t\n+\n+\t* testsuite/20_util/comparisons.cc: New file.\n+\t* testsuite/20_util/pairs.cc: New file.\t\n+\n 2001-06-15  Phil Edwards  <pme@sources.redhat.com>\n \n \t* docs/html/documentation.html:  Point to new doxygen'ed collection."}, {"sha": "f8fa732fb4fc9e9f817024af56a43a9913c09f37", "filename": "libstdc++-v3/include/bits/stl_alloc.h", "status": "modified", "additions": 161, "deletions": 132, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_alloc.h?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -67,85 +67,106 @@\n \n namespace std\n {\n-\n-// Malloc-based allocator.  Typically slower than default alloc below.\n-// Typically thread-safe and more storage efficient.\n-template <int __inst>\n-class __malloc_alloc_template {\n-\n-private:\n-\n-  static void* _S_oom_malloc(size_t);\n-  static void* _S_oom_realloc(void*, size_t);\n-  static void (* __malloc_alloc_oom_handler)();\n-\n-public:\n-\n-  static void* allocate(size_t __n)\n-  {\n-    void* __result = malloc(__n);\n-    if (0 == __result) __result = _S_oom_malloc(__n);\n-    return __result;\n-  }\n-\n-  static void deallocate(void* __p, size_t /* __n */)\n-  {\n-    free(__p);\n-  }\n-\n-  static void* reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)\n+  // A new-based allocator, as required by the standard.\n+  class __new_alloc \n   {\n-    void* __result = realloc(__p, __new_sz);\n-    if (0 == __result) __result = _S_oom_realloc(__p, __new_sz);\n-    return __result;\n-  }\n-\n-  static void (* __set_malloc_handler(void (*__f)()))()\n-  {\n-    void (* __old)() = __malloc_alloc_oom_handler;\n-    __malloc_alloc_oom_handler = __f;\n-    return(__old);\n-  }\n-\n-};\n-\n-// malloc_alloc out-of-memory handling\n+  public:\n+    static void* \n+    allocate(size_t __n)\n+    { return ::operator new(__n); }\n+    \n+    static void \n+    deallocate(void* __p, size_t)\n+    { ::operator delete(__p); }\n+  };\n+  \n+  // Malloc-based allocator.  Typically slower than default alloc below.\n+  // Typically thread-safe and more storage efficient.\n+  template <int __inst>\n+    class __malloc_alloc_template \n+    {\n+    private:\n+      static void* _S_oom_malloc(size_t);\n+      static void* _S_oom_realloc(void*, size_t);\n+      static void (* __malloc_alloc_oom_handler)();\n+      \n+    public:\n+      static void* \n+      allocate(size_t __n)\n+      {\n+\tvoid* __result = malloc(__n);\n+\tif (0 == __result) __result = _S_oom_malloc(__n);\n+\treturn __result;\n+      }\n \n-template <int __inst>\n-void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;\n+      static void \n+      deallocate(void* __p, size_t /* __n */)\n+      { free(__p); }\n \n-template <int __inst>\n-void*\n-__malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n-{\n-    void (* __my_malloc_handler)();\n-    void* __result;\n+      static void* \n+      reallocate(void* __p, size_t /* old_sz */, size_t __new_sz)\n+      {\n+\tvoid* __result = realloc(__p, __new_sz);\n+\tif (0 == __result) __result = _S_oom_realloc(__p, __new_sz);\n+\treturn __result;\n+      }\n+      \n+      static void (* __set_malloc_handler(void (*__f)()))()\n+      {\n+\tvoid (* __old)() = __malloc_alloc_oom_handler;\n+\t__malloc_alloc_oom_handler = __f;\n+\treturn(__old);\n+      }\n+    };\n \n-    for (;;) {\n-        __my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == __my_malloc_handler) { std::__throw_bad_alloc(); }\n-        (*__my_malloc_handler)();\n-        __result = malloc(__n);\n-        if (__result) return(__result);\n+  // malloc_alloc out-of-memory handling\n+  template <int __inst>\n+    void (* __malloc_alloc_template<__inst>::__malloc_alloc_oom_handler)() = 0;\n+\n+  template <int __inst>\n+    void*\n+    __malloc_alloc_template<__inst>::_S_oom_malloc(size_t __n)\n+    {\n+      void (* __my_malloc_handler)();\n+      void* __result;\n+      \n+      for (;;) \n+\t{\n+\t  __my_malloc_handler = __malloc_alloc_oom_handler;\n+\t  if (0 == __my_malloc_handler) \n+\t    std::__throw_bad_alloc();\n+\t  (*__my_malloc_handler)();\n+\t  __result = malloc(__n);\n+\t  if (__result) \n+\t    return(__result);\n+\t}\n     }\n-}\n-\n-template <int __inst>\n-void* __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)\n-{\n-    void (* __my_malloc_handler)();\n-    void* __result;\n-\n-    for (;;) {\n-        __my_malloc_handler = __malloc_alloc_oom_handler;\n-        if (0 == __my_malloc_handler) { std::__throw_bad_alloc(); }\n-        (*__my_malloc_handler)();\n-        __result = realloc(__p, __n);\n-        if (__result) return(__result);\n+  \n+  template <int __inst>\n+    void* \n+    __malloc_alloc_template<__inst>::_S_oom_realloc(void* __p, size_t __n)\n+    { \n+      void (* __my_malloc_handler)();\n+      void* __result;\n+      \n+      for (;;) \n+\t{\n+\t  __my_malloc_handler = __malloc_alloc_oom_handler;\n+\t  if (0 == __my_malloc_handler) \n+\t    std::__throw_bad_alloc();\n+\t  (*__my_malloc_handler)();\n+\t  __result = realloc(__p, __n);\n+\t  if (__result) \n+\t    return(__result);\n+\t}\n     }\n-}\n \n-typedef __malloc_alloc_template<0> malloc_alloc;\n+  // Determines the underlying allocator choice.\n+# ifdef __USE_MALLOC\n+  typedef __malloc_alloc_template<0> __mem_interface;\n+#else\n+  typedef __new_alloc __mem_interface;\n+#endif\n \n template<class _Tp, class _Alloc>\n class simple_alloc {\n@@ -295,55 +316,55 @@ class __default_alloc_template {\n   {\n     void* __ret = 0;\n \n-    if (__n > (size_t) _MAX_BYTES) {\n-      __ret = malloc_alloc::allocate(__n);\n-    }\n-    else {\n-      _Obj* __STL_VOLATILE* __my_free_list\n-          = _S_free_list + _S_freelist_index(__n);\n-      // Acquire the lock here with a constructor call.\n-      // This ensures that it is released in exit or during stack\n-      // unwinding.\n+    if (__n > (size_t) _MAX_BYTES) \n+      __ret = __mem_interface::allocate(__n);\n+    else \n+      {\n+\t_Obj* __STL_VOLATILE* __my_free_list = _S_free_list + _S_freelist_index(__n);\n+\t// Acquire the lock here with a constructor call.\n+\t// This ensures that it is released in exit or during stack\n+\t// unwinding.\n #     ifndef _NOTHREADS\n-      /*REFERENCED*/\n-      _Lock __lock_instance;\n+\t/*REFERENCED*/\n+\t_Lock __lock_instance;\n #     endif\n-      _Obj* __RESTRICT __result = *__my_free_list;\n-      if (__result == 0)\n-        __ret = _S_refill(_S_round_up(__n));\n-      else {\n-        *__my_free_list = __result -> _M_free_list_link;\n-        __ret = __result;\n+\t_Obj* __RESTRICT __result = *__my_free_list;\n+\tif (__result == 0)\n+\t  __ret = _S_refill(_S_round_up(__n));\n+\telse \n+\t  {\n+\t    *__my_free_list = __result -> _M_free_list_link;\n+\t    __ret = __result;\n+\t  }\n       }\n-    }\n-\n+    \n     return __ret;\n   };\n \n   /* __p may not be 0 */\n   static void deallocate(void* __p, size_t __n)\n   {\n     if (__n > (size_t) _MAX_BYTES)\n-      malloc_alloc::deallocate(__p, __n);\n-    else {\n-      _Obj* __STL_VOLATILE*  __my_free_list\n+      __mem_interface::deallocate(__p, __n);\n+    else \n+      {\n+\t_Obj* __STL_VOLATILE*  __my_free_list\n           = _S_free_list + _S_freelist_index(__n);\n-      _Obj* __q = (_Obj*)__p;\n-\n-      // acquire lock\n+\t_Obj* __q = (_Obj*)__p;\n+\t\n+\t// acquire lock\n #       ifndef _NOTHREADS\n-      /*REFERENCED*/\n-      _Lock __lock_instance;\n+\t/*REFERENCED*/\n+\t_Lock __lock_instance;\n #       endif /* _NOTHREADS */\n-      __q -> _M_free_list_link = *__my_free_list;\n-      *__my_free_list = __q;\n-      // lock is released here\n-    }\n+\t__q -> _M_free_list_link = *__my_free_list;\n+\t*__my_free_list = __q;\n+\t// lock is released here\n+      }\n   }\n-\n+  \n   static void* reallocate(void* __p, size_t __old_sz, size_t __new_sz);\n-\n-} ;\n+};\n \n typedef __default_alloc_template<__NODE_ALLOCATOR_THREADS, 0> alloc;\n typedef __default_alloc_template<false, 0> single_client_alloc;\n@@ -377,59 +398,67 @@ __default_alloc_template<__threads, __inst>::_S_chunk_alloc(size_t __size,\n     size_t __total_bytes = __size * __nobjs;\n     size_t __bytes_left = _S_end_free - _S_start_free;\n \n-    if (__bytes_left >= __total_bytes) {\n+    if (__bytes_left >= __total_bytes) \n+      {\n         __result = _S_start_free;\n         _S_start_free += __total_bytes;\n         return(__result);\n-    } else if (__bytes_left >= __size) {\n+      } \n+    else if (__bytes_left >= __size) \n+      {\n         __nobjs = (int)(__bytes_left/__size);\n         __total_bytes = __size * __nobjs;\n         __result = _S_start_free;\n         _S_start_free += __total_bytes;\n         return(__result);\n-    } else {\n+    } \n+    else \n+      {\n         size_t __bytes_to_get = \n \t  2 * __total_bytes + _S_round_up(_S_heap_size >> 4);\n         // Try to make use of the left-over piece.\n-        if (__bytes_left > 0) {\n-            _Obj* __STL_VOLATILE* __my_free_list =\n-                        _S_free_list + _S_freelist_index(__bytes_left);\n-\n-            ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n-            *__my_free_list = (_Obj*)_S_start_free;\n-        }\n-        _S_start_free = (char*)malloc(__bytes_to_get);\n-        if (0 == _S_start_free) {\n+        if (__bytes_left > 0) \n+\t  {\n+\t    _Obj* __STL_VOLATILE* __my_free_list =\n+\t      _S_free_list + _S_freelist_index(__bytes_left);\n+\t    \n+\t    ((_Obj*)_S_start_free) -> _M_free_list_link = *__my_free_list;\n+\t    *__my_free_list = (_Obj*)_S_start_free;\n+\t  }\n+        _S_start_free = (char*) __mem_interface::allocate(__bytes_to_get);\n+        if (0 == _S_start_free) \n+\t  {\n             size_t __i;\n             _Obj* __STL_VOLATILE* __my_free_list;\n \t    _Obj* __p;\n-            // Try to make do with what we have.  That can't\n-            // hurt.  We do not try smaller requests, since that tends\n-            // to result in disaster on multi-process machines.\n-            for (__i = __size;\n-                 __i <= (size_t) _MAX_BYTES;\n-                 __i += (size_t) _ALIGN) {\n+            // Try to make do with what we have.  That can't hurt.  We\n+            // do not try smaller requests, since that tends to result\n+            // in disaster on multi-process machines.\n+\t    __i = __size;\n+            for (; __i <= (size_t) _MAX_BYTES; __i += (size_t) _ALIGN) \n+\t      {\n                 __my_free_list = _S_free_list + _S_freelist_index(__i);\n                 __p = *__my_free_list;\n-                if (0 != __p) {\n-                    *__my_free_list = __p -> _M_free_list_link;\n-                    _S_start_free = (char*)__p;\n+                if (0 != __p) \n+\t\t  {\n+\t\t    *__my_free_list = __p -> _M_free_list_link;\n+\t\t    _S_start_free = (char*)__p;\n                     _S_end_free = _S_start_free + __i;\n                     return(_S_chunk_alloc(__size, __nobjs));\n                     // Any leftover piece will eventually make it to the\n                     // right free list.\n-                }\n-            }\n+\t\t  }\n+\t      }\n \t    _S_end_free = 0;\t// In case of exception.\n-            _S_start_free = (char*)malloc_alloc::allocate(__bytes_to_get);\n+            _S_start_free = (char*)__mem_interface::allocate(__bytes_to_get);\n             // This should either throw an\n             // exception or remedy the situation.  Thus we assume it\n             // succeeded.\n-        }\n+\t  }\n         _S_heap_size += __bytes_to_get;\n         _S_end_free = _S_start_free + __bytes_to_get;\n         return(_S_chunk_alloc(__size, __nobjs));\n-    }\n+      }\n }\n \n "}, {"sha": "db810c2a787f247ba3668de06ab16740b4295595", "filename": "libstdc++-v3/include/bits/stl_raw_storage_iter.h", "status": "modified", "additions": 33, "deletions": 27, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_raw_storage_iter.h?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -33,39 +33,45 @@\n \n namespace std\n {\n+  template <class _ForwardIterator, class _Tp>\n+  class raw_storage_iterator \n+    : public iterator<output_iterator_tag, void, void, void, void>\n+    {\n+    protected:\n+      _ForwardIterator _M_iter;\n \n-template <class _ForwardIterator, class _Tp>\n-class raw_storage_iterator {\n-protected:\n-  _ForwardIterator _M_iter;\n-public:\n-  typedef output_iterator_tag iterator_category;\n-  typedef void                value_type;\n-  typedef void                difference_type;\n-  typedef void                pointer;\n-  typedef void                reference;\n+    public:\n+      explicit \n+      raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}\n \n-  explicit raw_storage_iterator(_ForwardIterator __x) : _M_iter(__x) {}\n-  raw_storage_iterator& operator*() { return *this; }\n-  raw_storage_iterator& operator=(const _Tp& __element) {\n-    construct(&*_M_iter, __element);\n-    return *this;\n-  }        \n-  raw_storage_iterator<_ForwardIterator, _Tp>& operator++() {\n-    ++_M_iter;\n-    return *this;\n-  }\n-  raw_storage_iterator<_ForwardIterator, _Tp> operator++(int) {\n-    raw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;\n-    ++_M_iter;\n-    return __tmp;\n-  }\n-};\n+      raw_storage_iterator& \n+      operator*() { return *this; }\n \n+      raw_storage_iterator& \n+      operator=(const _Tp& __element) \n+      {\n+\tconstruct(&*_M_iter, __element);\n+\treturn *this;\n+      }        \n \n+      raw_storage_iterator<_ForwardIterator, _Tp>& \n+      operator++() \n+      {\n+\t++_M_iter;\n+\treturn *this;\n+      }\n+\n+      raw_storage_iterator<_ForwardIterator, _Tp> \n+      operator++(int) \n+      {\n+\traw_storage_iterator<_ForwardIterator, _Tp> __tmp = *this;\n+\t++_M_iter;\n+\treturn __tmp;\n+      }\n+    };\n } // namespace std\n \n-#endif /* _CPP_BITS_STL_RAW_STORAGE_ITERATOR_H */\n+#endif\n \n // Local Variables:\n // mode:C++"}, {"sha": "1ee1d97385e8286b50db29ed471e30b5c2d57788", "filename": "libstdc++-v3/testsuite/20_util/allocator_members.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fallocator_members.cc?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -0,0 +1,60 @@\n+// 2001-06-14  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.1.1 allocator members\n+\n+#include <memory>\n+#include <cstdlib>\n+#include <debug_assert.h>\n+\n+struct gnu { };\n+\n+bool check_new = false;\n+bool check_delete = false;\n+\n+void* \n+operator new(std::size_t n) throw(std::bad_alloc)\n+{\n+  check_new = true;\n+  return std::malloc(n);\n+}\n+\n+void operator delete(void *v) throw()\n+{\n+  check_delete = true;\n+  return std::free(v);\n+}\n+\n+int main(void)\n+{\n+  bool test = true;\n+  std::allocator<gnu> obj;\n+\n+  // XXX These should work for various size allocation and\n+  // deallocations.  Currently, they only work as expected for sizes >\n+  // _MAX_BYTES as defined in stl_alloc.h, which happes to be 128. \n+  gnu* pobj = obj.allocate(256);\n+  VERIFY( check_new );\n+\n+  obj.deallocate(pobj, 256);\n+  VERIFY( check_delete );\n+\n+  return 0;\n+}"}, {"sha": "fda0332fa07ce4c2b35848b9e91e737f46e77cd4", "filename": "libstdc++-v3/testsuite/20_util/comparisons.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcomparisons.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcomparisons.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fcomparisons.cc?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -0,0 +1,53 @@\n+// 2001-06-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.3.3 Comparisons\n+\n+#include <functional>\n+\n+class gnu_obj\n+{\n+  int i;\n+public:\n+  gnu_obj(int arg = 0): i(arg) { }\n+  bool operator==(const gnu_obj& rhs) const { return i == rhs.i; }\n+  bool operator!=(const gnu_obj& rhs) const { return i != rhs.i; }\n+  bool operator<(const gnu_obj& rhs) const { return i < rhs.i; }\n+};\n+\n+template<typename T>\n+  struct gnu_t\n+  {\n+    bool b;\n+  public:\n+    gnu_t(bool arg = 0): b(arg) { }\n+    bool operator==(const gnu_t& rhs) const { return b == rhs.b; }\n+    bool operator!=(const gnu_t& rhs) const { return b != rhs.b; }\n+    bool operator<(const gnu_t& rhs) const { return b == rhs.b; }\n+  };\n+\n+template struct std::not_equal_to<void*>;\n+template struct std::not_equal_to<gnu_obj>;\n+template struct std::not_equal_to<gnu_t<long> >;\n+\n+int main() \n+{ \n+  return 0;\n+}"}, {"sha": "7b4b62f96b979281027f08fa8298de7f4bb6c500", "filename": "libstdc++-v3/testsuite/20_util/pairs.cc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpairs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpairs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fpairs.cc?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -0,0 +1,140 @@\n+// 2001-06-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.2.2 Pairs\n+\n+#include <utility>\n+#include <debug_assert.h>\n+\n+class gnu_obj\n+{\n+  int i;\n+public:\n+  gnu_obj(int arg = 0): i(arg) { }\n+  bool operator==(const gnu_obj& rhs) const { return i == rhs.i; }\n+  bool operator<(const gnu_obj& rhs) const { return i < rhs.i; }\n+};\n+\n+template<typename T>\n+  struct gnu_t\n+  {\n+    bool b;\n+  public:\n+    gnu_t(bool arg = 0): b(arg) { }\n+    bool operator==(const gnu_t& rhs) const { return b == rhs.b; }\n+    bool operator<(const gnu_t& rhs) const { return int(b) < int(rhs.b); }\n+  };\n+\n+\n+// heterogeneous\n+void test01()\n+{\n+  bool test = true;\n+\n+  std::pair<bool, long> p_bl_1(true, 433);\n+  std::pair<bool, long> p_bl_2 = std::make_pair(true, 433);\n+  VERIFY( p_bl_1 == p_bl_2 );\n+  VERIFY( !(p_bl_1 < p_bl_2) );\n+\n+  std::pair<const char*, float> p_sf_1(\"total enlightenment\", 433.00);\n+  std::pair<const char*, float> p_sf_2 = std::make_pair(\"total enlightenment\", \n+\t\t\t\t\t\t\t433.00);\n+  VERIFY( p_sf_1 == p_sf_2 );\n+  VERIFY( !(p_sf_1 < p_sf_2) );\n+\n+  std::pair<const char*, gnu_obj> p_sg_1(\"enlightenment\", gnu_obj(5));\n+  std::pair<const char*, gnu_obj> p_sg_2 = std::make_pair(\"enlightenment\", \n+\t\t\t\t\t\t\t  gnu_obj(5));\n+  VERIFY( p_sg_1 == p_sg_2 );\n+  VERIFY( !(p_sg_1 < p_sg_2) );\n+\n+  std::pair<gnu_t<long>, gnu_obj> p_st_1(gnu_t<long>(false), gnu_obj(5));\n+  std::pair<gnu_t<long>, gnu_obj> p_st_2 = std::make_pair(gnu_t<long>(false),\n+\t\t\t\t\t\t\t  gnu_obj(5));\n+  VERIFY( p_st_1 == p_st_2 );\n+  VERIFY( !(p_st_1 < p_st_2) );\n+}\n+\n+// homogeneous\n+void test02()\n+{\n+  bool test = true;\n+\n+  std::pair<bool, bool> p_bb_1(true, false);\n+  std::pair<bool, bool> p_bb_2 = std::make_pair(true, false);\n+  VERIFY( p_bb_1 == p_bb_2 );\n+  VERIFY( !(p_bb_1 < p_bb_2) );\n+}\n+\n+\n+// const\n+void test03()\n+{\n+  bool test = true;\n+\n+  const std::pair<bool, long> p_bl_1(true, 433);\n+  const std::pair<bool, long> p_bl_2 = std::make_pair(true, 433);\n+  VERIFY( p_bl_1 == p_bl_2 );\n+  VERIFY( !(p_bl_1 < p_bl_2) );\n+\n+  const std::pair<const char*, float> p_sf_1(\"total enlightenment\", 433.00);\n+  const std::pair<const char*, float> p_sf_2 = \n+    std::make_pair(\"total enlightenment\", 433.00);\n+  VERIFY( p_sf_1 == p_sf_2 );\n+  VERIFY( !(p_sf_1 < p_sf_2) );\n+\n+  const std::pair<const char*, gnu_obj> p_sg_1(\"enlightenment\", gnu_obj(5));\n+  const std::pair<const char*, gnu_obj> p_sg_2 = \n+    std::make_pair(\"enlightenment\", gnu_obj(5));\n+  VERIFY( p_sg_1 == p_sg_2 );\n+  VERIFY( !(p_sg_1 < p_sg_2) );\n+\n+  const std::pair<gnu_t<long>, gnu_obj> p_st_1(gnu_t<long>(false), gnu_obj(5));\n+  const std::pair<gnu_t<long>, gnu_obj> p_st_2 = \n+    std::make_pair(gnu_t<long>(false), gnu_obj(5));\n+  VERIFY( p_st_1 == p_st_2 );\n+  VERIFY( !(p_st_1 < p_st_2) );\n+}\n+\n+// const&\n+void test04()\n+{\n+  bool test = true;\n+  const gnu_obj& obj1 = gnu_obj(5);\n+  const std::pair<const char*, gnu_obj> p_sg_1(\"enlightenment\", obj1);\n+  const std::pair<const char*, gnu_obj> p_sg_2 = \n+    std::make_pair(\"enlightenment\", obj1);\n+  VERIFY( p_sg_1 == p_sg_2 );\n+  VERIFY( !(p_sg_1 < p_sg_2) );\n+\n+  const gnu_t<long>& tmpl1 = gnu_t<long>(false);\n+  const std::pair<gnu_t<long>, gnu_obj> p_st_1(tmpl1, obj1);\n+  const std::pair<gnu_t<long>, gnu_obj> p_st_2 = std::make_pair(tmpl1, obj1);\n+  VERIFY( p_st_1 == p_st_2 );\n+  VERIFY( !(p_st_1 < p_st_2) );\n+}\n+\n+int main() \n+{ \n+  test01(); \n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "de1fe691e14ec1b6a8940d06379e1b50e30b6a6e", "filename": "libstdc++-v3/testsuite/20_util/raw_storage_iterator.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fraw_storage_iterator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3768cee7ca4f746729741c1a568c5d52303bd9a3/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fraw_storage_iterator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fraw_storage_iterator.cc?ref=3768cee7ca4f746729741c1a568c5d52303bd9a3", "patch": "@@ -0,0 +1,47 @@\n+// 2001-06-18  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 20.4.2 raw storage iterator\n+\n+#include <memory>\n+\n+void test01()\n+{\n+  using namespace std;\n+\n+  // Check for required base class.\n+  long l;\n+  raw_storage_iterator<long*, long> rs_it(&l);\n+  iterator<output_iterator_tag, void, void, void, void>* base = &rs_it;\n+\n+  // Check for required typedefs\n+  typedef raw_storage_iterator<long*, long>::value_type value_type;\n+  typedef raw_storage_iterator<long*, long>::difference_type difference_type;\n+  typedef raw_storage_iterator<long*, long>::pointer pointer;\n+  typedef raw_storage_iterator<long*, long>::reference reference;\n+  typedef raw_storage_iterator<long*, long>::iterator_category iteratory_category;\n+\n+}\n+\n+int main() \n+{ \n+  test01();\n+  return 0;\n+}"}]}