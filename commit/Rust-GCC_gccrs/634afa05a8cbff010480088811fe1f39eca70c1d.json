{"sha": "634afa05a8cbff010480088811fe1f39eca70c1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjM0YWZhMDVhOGNiZmYwMTA0ODAwODg4MTFmZTFmMzllY2E3MGMxZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-08-20T08:53:52Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-08-20T08:53:52Z"}, "message": "Make function.c use function_arg_info internally\n\nThis patch adds a function_arg_info field to assign_parm_data_one,\nso that:\n\n  - passed_type -> arg.type\n  - promoted_mode -> arg.mode\n  - named_arg -> arg.named\n\nWe can then pass this function_arg_info directly to the converted\nhooks.\n\nBetween the initialisation of the assign_parm_data_one and the\napplication of promotion rules (which is a state internal to\nassign_parm_find_data_types), arg.mode is equivalent to passed_mode\n(i.e. to TYPE_MODE).\n\n2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* function.c (assign_parm_data_one): Replace passed_type,\n\tpromoted_mode and named_arg with a function_arg_info field.\n\t(assign_parm_find_data_types): Remove local variables and\n\tassign directly to \"data\".  Make data->passed_mode shadow\n\tdata->arg.mode until promotion, then assign the promoted\n\tmode to data->arg.mode.\n\t(assign_parms_setup_varargs, assign_parm_find_entry_rtl)\n\t(assign_parm_find_stack_rtl, assign_parm_adjust_entry_rtl)\n\t(assign_parm_remove_parallels, assign_parm_setup_block_p)\n\t(assign_parm_setup_block, assign_parm_setup_reg)\n\t(assign_parm_setup_stack, assign_parms, gimplify_parameters): Use\n\targ.mode instead of promoted_mode, arg.type instead of passed_type\n\tand arg.named instead of named_arg.  Use data->arg for\n\tfunction_arg_info structures that had the field values passed_type,\n\tpromoted_mode and named_arg.  Base other function_arg_infos on\n\tdata->arg, changing the necessary properties.\n\nFrom-SVN: r274705", "tree": {"sha": "a12190ad0a55be907c0ba654c17e6cfcdf399343", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a12190ad0a55be907c0ba654c17e6cfcdf399343"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/634afa05a8cbff010480088811fe1f39eca70c1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634afa05a8cbff010480088811fe1f39eca70c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/634afa05a8cbff010480088811fe1f39eca70c1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/634afa05a8cbff010480088811fe1f39eca70c1d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b12cdd6e8e8dd1f39a941b731ba1056d656a094f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b12cdd6e8e8dd1f39a941b731ba1056d656a094f"}], "stats": {"total": 187, "additions": 92, "deletions": 95}, "files": [{"sha": "71f41d8604b5ac569334ba8feb69bfdcf63da9f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634afa05a8cbff010480088811fe1f39eca70c1d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634afa05a8cbff010480088811fe1f39eca70c1d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=634afa05a8cbff010480088811fe1f39eca70c1d", "patch": "@@ -1,3 +1,22 @@\n+2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* function.c (assign_parm_data_one): Replace passed_type,\n+\tpromoted_mode and named_arg with a function_arg_info field.\n+\t(assign_parm_find_data_types): Remove local variables and\n+\tassign directly to \"data\".  Make data->passed_mode shadow\n+\tdata->arg.mode until promotion, then assign the promoted\n+\tmode to data->arg.mode.\n+\t(assign_parms_setup_varargs, assign_parm_find_entry_rtl)\n+\t(assign_parm_find_stack_rtl, assign_parm_adjust_entry_rtl)\n+\t(assign_parm_remove_parallels, assign_parm_setup_block_p)\n+\t(assign_parm_setup_block, assign_parm_setup_reg)\n+\t(assign_parm_setup_stack, assign_parms, gimplify_parameters): Use\n+\targ.mode instead of promoted_mode, arg.type instead of passed_type\n+\tand arg.named instead of named_arg.  Use data->arg for\n+\tfunction_arg_info structures that had the field values passed_type,\n+\tpromoted_mode and named_arg.  Base other function_arg_infos on\n+\tdata->arg, changing the necessary properties.\n+\n 2019-08-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* calls.h (apply_pass_by_reference_rules): Declare."}, {"sha": "d6d38b92a756915e9127ff82d349dcbbacf1f559", "filename": "gcc/function.c", "status": "modified", "additions": 73, "deletions": 95, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/634afa05a8cbff010480088811fe1f39eca70c1d/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/634afa05a8cbff010480088811fe1f39eca70c1d/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=634afa05a8cbff010480088811fe1f39eca70c1d", "patch": "@@ -2264,15 +2264,13 @@ struct assign_parm_data_all\n struct assign_parm_data_one\n {\n   tree nominal_type;\n-  tree passed_type;\n+  function_arg_info arg;\n   rtx entry_parm;\n   rtx stack_parm;\n   machine_mode nominal_mode;\n   machine_mode passed_mode;\n-  machine_mode promoted_mode;\n   struct locate_and_pad_arg_data locate;\n   int partial;\n-  BOOL_BITFIELD named_arg : 1;\n   BOOL_BITFIELD passed_pointer : 1;\n };\n \n@@ -2407,74 +2405,63 @@ static void\n assign_parm_find_data_types (struct assign_parm_data_all *all, tree parm,\n \t\t\t     struct assign_parm_data_one *data)\n {\n-  tree nominal_type, passed_type;\n-  machine_mode nominal_mode, passed_mode, promoted_mode;\n   int unsignedp;\n \n-  memset (data, 0, sizeof (*data));\n+  *data = assign_parm_data_one ();\n \n   /* NAMED_ARG is a misnomer.  We really mean 'non-variadic'. */\n   if (!cfun->stdarg)\n-    data->named_arg = 1;  /* No variadic parms.  */\n+    data->arg.named = 1;  /* No variadic parms.  */\n   else if (DECL_CHAIN (parm))\n-    data->named_arg = 1;  /* Not the last non-variadic parm. */\n+    data->arg.named = 1;  /* Not the last non-variadic parm. */\n   else if (targetm.calls.strict_argument_naming (all->args_so_far))\n-    data->named_arg = 1;  /* Only variadic ones are unnamed.  */\n+    data->arg.named = 1;  /* Only variadic ones are unnamed.  */\n   else\n-    data->named_arg = 0;  /* Treat as variadic.  */\n+    data->arg.named = 0;  /* Treat as variadic.  */\n \n-  nominal_type = TREE_TYPE (parm);\n-  passed_type = DECL_ARG_TYPE (parm);\n+  data->nominal_type = TREE_TYPE (parm);\n+  data->arg.type = DECL_ARG_TYPE (parm);\n \n   /* Look out for errors propagating this far.  Also, if the parameter's\n      type is void then its value doesn't matter.  */\n   if (TREE_TYPE (parm) == error_mark_node\n       /* This can happen after weird syntax errors\n \t or if an enum type is defined among the parms.  */\n       || TREE_CODE (parm) != PARM_DECL\n-      || passed_type == NULL\n-      || VOID_TYPE_P (nominal_type))\n+      || data->arg.type == NULL\n+      || VOID_TYPE_P (data->nominal_type))\n     {\n-      nominal_type = passed_type = void_type_node;\n-      nominal_mode = passed_mode = promoted_mode = VOIDmode;\n-      goto egress;\n+      data->nominal_type = data->arg.type = void_type_node;\n+      data->nominal_mode = data->passed_mode = data->arg.mode = VOIDmode;\n+      return;\n     }\n \n   /* Find mode of arg as it is passed, and mode of arg as it should be\n      during execution of this function.  */\n-  passed_mode = TYPE_MODE (passed_type);\n-  nominal_mode = TYPE_MODE (nominal_type);\n+  data->passed_mode = data->arg.mode = TYPE_MODE (data->arg.type);\n+  data->nominal_mode = TYPE_MODE (data->nominal_type);\n \n   /* If the parm is to be passed as a transparent union or record, use the\n      type of the first field for the tests below.  We have already verified\n      that the modes are the same.  */\n-  if ((TREE_CODE (passed_type) == UNION_TYPE\n-       || TREE_CODE (passed_type) == RECORD_TYPE)\n-      && TYPE_TRANSPARENT_AGGR (passed_type))\n-    passed_type = TREE_TYPE (first_field (passed_type));\n+  if ((TREE_CODE (data->arg.type) == UNION_TYPE\n+       || TREE_CODE (data->arg.type) == RECORD_TYPE)\n+      && TYPE_TRANSPARENT_AGGR (data->arg.type))\n+    data->arg.type = TREE_TYPE (first_field (data->arg.type));\n \n   /* See if this arg was passed by invisible reference.  */\n-  {\n-    function_arg_info arg (passed_type, passed_mode, data->named_arg);\n-    if (apply_pass_by_reference_rules (&all->args_so_far_v, arg))\n-      {\n-\tpassed_type = nominal_type = arg.type;\n-\tdata->passed_pointer = true;\n-\tpassed_mode = nominal_mode = arg.mode;\n-      }\n-  }\n+  if (apply_pass_by_reference_rules (&all->args_so_far_v, data->arg))\n+    {\n+      data->nominal_type = data->arg.type;\n+      data->passed_pointer = true;\n+      data->passed_mode = data->nominal_mode = data->arg.mode;\n+    }\n \n   /* Find mode as it is passed by the ABI.  */\n-  unsignedp = TYPE_UNSIGNED (passed_type);\n-  promoted_mode = promote_function_mode (passed_type, passed_mode, &unsignedp,\n-\t\t\t\t         TREE_TYPE (current_function_decl), 0);\n-\n- egress:\n-  data->nominal_type = nominal_type;\n-  data->passed_type = passed_type;\n-  data->nominal_mode = nominal_mode;\n-  data->passed_mode = passed_mode;\n-  data->promoted_mode = promoted_mode;\n+  unsignedp = TYPE_UNSIGNED (data->arg.type);\n+  data->arg.mode\n+    = promote_function_mode (data->arg.type, data->arg.mode, &unsignedp,\n+\t\t\t     TREE_TYPE (current_function_decl), 0);\n }\n \n /* A subroutine of assign_parms.  Invoke setup_incoming_varargs.  */\n@@ -2485,8 +2472,8 @@ assign_parms_setup_varargs (struct assign_parm_data_all *all,\n {\n   int varargs_pretend_bytes = 0;\n \n-  function_arg_info last_named_arg (data->passed_type, data->promoted_mode,\n-\t\t\t\t    /*named=*/true);\n+  function_arg_info last_named_arg = data->arg;\n+  last_named_arg.named = true;\n   targetm.calls.setup_incoming_varargs (all->args_so_far, last_named_arg,\n \t\t\t\t\t&varargs_pretend_bytes, no_rtl);\n \n@@ -2508,20 +2495,19 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n   rtx entry_parm;\n   bool in_regs;\n \n-  if (data->promoted_mode == VOIDmode)\n+  if (data->arg.mode == VOIDmode)\n     {\n       data->entry_parm = data->stack_parm = const0_rtx;\n       return;\n     }\n \n   targetm.calls.warn_parameter_passing_abi (all->args_so_far,\n-\t\t\t\t\t    data->passed_type);\n+\t\t\t\t\t    data->arg.type);\n \n-  function_arg_info arg (data->passed_type, data->promoted_mode,\n-\t\t\t data->named_arg);\n-  entry_parm = targetm.calls.function_incoming_arg (all->args_so_far, arg);\n+  entry_parm = targetm.calls.function_incoming_arg (all->args_so_far,\n+\t\t\t\t\t\t    data->arg);\n   if (entry_parm == 0)\n-    data->promoted_mode = data->passed_mode;\n+    data->arg.mode = data->passed_mode;\n \n   /* Determine parm's home in the stack, in case it arrives in the stack\n      or we should pretend it did.  Compute the stack position and rtx where\n@@ -2537,13 +2523,13 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n #ifdef STACK_PARMS_IN_REG_PARM_AREA\n   in_regs = true;\n #endif\n-  if (!in_regs && !data->named_arg)\n+  if (!in_regs && !data->arg.named)\n     {\n       if (targetm.calls.pretend_outgoing_varargs_named (all->args_so_far))\n \t{\n \t  rtx tem;\n-\t  function_arg_info named_arg (data->passed_type, data->promoted_mode,\n-\t\t\t\t       /*named=*/true);\n+\t  function_arg_info named_arg = data->arg;\n+\t  named_arg.named = true;\n \t  tem = targetm.calls.function_incoming_arg (all->args_so_far,\n \t\t\t\t\t\t     named_arg);\n \t  in_regs = tem != NULL;\n@@ -2552,16 +2538,14 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \n   /* If this parameter was passed both in registers and in the stack, use\n      the copy on the stack.  */\n-  if (targetm.calls.must_pass_in_stack (arg))\n+  if (targetm.calls.must_pass_in_stack (data->arg))\n     entry_parm = 0;\n \n   if (entry_parm)\n     {\n       int partial;\n \n-      function_arg_info arg (data->passed_type, data->promoted_mode,\n-\t\t\t     data->named_arg);\n-      partial = targetm.calls.arg_partial_bytes (all->args_so_far, arg);\n+      partial = targetm.calls.arg_partial_bytes (all->args_so_far, data->arg);\n       data->partial = partial;\n \n       /* The caller might already have allocated stack space for the\n@@ -2596,7 +2580,7 @@ assign_parm_find_entry_rtl (struct assign_parm_data_all *all,\n \t}\n     }\n \n-  locate_and_pad_parm (data->promoted_mode, data->passed_type, in_regs,\n+  locate_and_pad_parm (data->arg.mode, data->arg.type, in_regs,\n \t\t       all->reg_parm_stack_space,\n \t\t       entry_parm ? data->partial : 0, current_function_decl,\n \t\t       &all->stack_args_size, &data->locate);\n@@ -2667,21 +2651,21 @@ assign_parm_find_stack_rtl (tree parm, struct assign_parm_data_one *data)\n   stack_parm = crtl->args.internal_arg_pointer;\n   if (offset_rtx != const0_rtx)\n     stack_parm = gen_rtx_PLUS (Pmode, stack_parm, offset_rtx);\n-  stack_parm = gen_rtx_MEM (data->promoted_mode, stack_parm);\n+  stack_parm = gen_rtx_MEM (data->arg.mode, stack_parm);\n \n   if (!data->passed_pointer)\n     {\n       set_mem_attributes (stack_parm, parm, 1);\n       /* set_mem_attributes could set MEM_SIZE to the passed mode's size,\n \t while promoted mode's size is needed.  */\n-      if (data->promoted_mode != BLKmode\n-\t  && data->promoted_mode != DECL_MODE (parm))\n+      if (data->arg.mode != BLKmode\n+\t  && data->arg.mode != DECL_MODE (parm))\n \t{\n-\t  set_mem_size (stack_parm, GET_MODE_SIZE (data->promoted_mode));\n+\t  set_mem_size (stack_parm, GET_MODE_SIZE (data->arg.mode));\n \t  if (MEM_EXPR (stack_parm) && MEM_OFFSET_KNOWN_P (stack_parm))\n \t    {\n \t      poly_int64 offset = subreg_lowpart_offset (DECL_MODE (parm),\n-\t\t\t\t\t\t\t data->promoted_mode);\n+\t\t\t\t\t\t\t data->arg.mode);\n \t      if (maybe_ne (offset, 0))\n \t\tset_mem_offset (stack_parm, MEM_OFFSET (stack_parm) - offset);\n \t    }\n@@ -2748,8 +2732,7 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n \t locations.  The Irix 6 ABI has examples of this.  */\n       if (GET_CODE (entry_parm) == PARALLEL)\n \temit_group_store (validize_mem (copy_rtx (stack_parm)), entry_parm,\n-\t\t\t  data->passed_type,\n-\t\t\t  int_size_in_bytes (data->passed_type));\n+\t\t\t  data->arg.type, int_size_in_bytes (data->arg.type));\n       else\n \t{\n \t  gcc_assert (data->partial % UNITS_PER_WORD == 0);\n@@ -2805,7 +2788,7 @@ assign_parm_remove_parallels (struct assign_parm_data_one *data)\n   if (GET_CODE (entry_parm) == PARALLEL && GET_MODE (entry_parm) != BLKmode)\n     {\n       rtx parmreg = gen_reg_rtx (GET_MODE (entry_parm));\n-      emit_group_store (parmreg, entry_parm, data->passed_type,\n+      emit_group_store (parmreg, entry_parm, data->arg.type,\n \t\t\tGET_MODE_SIZE (GET_MODE (entry_parm)));\n       entry_parm = parmreg;\n     }\n@@ -2866,8 +2849,8 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n   /* Only assign_parm_setup_block knows how to deal with register arguments\n      that are padded at the least significant end.  */\n   if (REG_P (data->entry_parm)\n-      && known_lt (GET_MODE_SIZE (data->promoted_mode), UNITS_PER_WORD)\n-      && (BLOCK_REG_PADDING (data->passed_mode, data->passed_type, 1)\n+      && known_lt (GET_MODE_SIZE (data->arg.mode), UNITS_PER_WORD)\n+      && (BLOCK_REG_PADDING (data->passed_mode, data->arg.type, 1)\n \t  == (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n     return true;\n #endif\n@@ -2922,7 +2905,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n       data->stack_parm = NULL;\n     }\n \n-  size = int_size_in_bytes (data->passed_type);\n+  size = int_size_in_bytes (data->arg.type);\n   size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n   if (stack_parm == 0)\n     {\n@@ -2977,12 +2960,12 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \n       /* Handle values in multiple non-contiguous locations.  */\n       if (GET_CODE (entry_parm) == PARALLEL && !MEM_P (mem))\n-\temit_group_store (mem, entry_parm, data->passed_type, size);\n+\temit_group_store (mem, entry_parm, data->arg.type, size);\n       else if (GET_CODE (entry_parm) == PARALLEL)\n \t{\n \t  push_to_sequence2 (all->first_conversion_insn,\n \t\t\t     all->last_conversion_insn);\n-\t  emit_group_store (mem, entry_parm, data->passed_type, size);\n+\t  emit_group_store (mem, entry_parm, data->arg.type, size);\n \t  all->first_conversion_insn = get_insns ();\n \t  all->last_conversion_insn = get_last_insn ();\n \t  end_sequence ();\n@@ -3002,7 +2985,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t  if (mode != BLKmode\n #ifdef BLOCK_REG_PADDING\n \t      && (size == UNITS_PER_WORD\n-\t\t  || (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n+\t\t  || (BLOCK_REG_PADDING (mode, data->arg.type, 1)\n \t\t      != (BYTES_BIG_ENDIAN ? PAD_UPWARD : PAD_DOWNWARD)))\n #endif\n \t      )\n@@ -3043,7 +3026,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t\t additional changes to work correctly.  */\n \t      gcc_checking_assert (BYTES_BIG_ENDIAN\n \t\t\t\t   && (BLOCK_REG_PADDING (mode,\n-\t\t\t\t\t\t\t  data->passed_type, 1)\n+\t\t\t\t\t\t\t  data->arg.type, 1)\n \t\t\t\t       == PAD_UPWARD));\n \n \t      int by = (UNITS_PER_WORD - size) * BITS_PER_UNIT;\n@@ -3064,7 +3047,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t     handle all cases (e.g. SIZE == 3).  */\n \t  else if (size != UNITS_PER_WORD\n #ifdef BLOCK_REG_PADDING\n-\t\t   && (BLOCK_REG_PADDING (mode, data->passed_type, 1)\n+\t\t   && (BLOCK_REG_PADDING (mode, data->arg.type, 1)\n \t\t       == PAD_DOWNWARD)\n #else\n \t\t   && BYTES_BIG_ENDIAN\n@@ -3088,7 +3071,7 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n \t  gcc_checking_assert (size > UNITS_PER_WORD);\n #ifdef BLOCK_REG_PADDING\n \t  gcc_checking_assert (BLOCK_REG_PADDING (GET_MODE (mem),\n-\t\t\t\t\t\t  data->passed_type, 0)\n+\t\t\t\t\t\t  data->arg.type, 0)\n \t\t\t       == PAD_UPWARD);\n #endif\n \t  emit_move_insn (mem, entry_parm);\n@@ -3159,7 +3142,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n      set rtl appropriately.  */\n   if (data->passed_pointer)\n     {\n-      rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->passed_type)), parmreg);\n+      rtl = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data->arg.type)), parmreg);\n       set_mem_attributes (rtl, parm, 1);\n     }\n   else\n@@ -3174,7 +3157,7 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n   validated_mem = validize_mem (copy_rtx (data->entry_parm));\n \n   need_conversion = (data->nominal_mode != data->passed_mode\n-\t\t     || promoted_nominal_mode != data->promoted_mode);\n+\t\t     || promoted_nominal_mode != data->arg.mode);\n   moved = false;\n \n   if (need_conversion\n@@ -3444,7 +3427,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \n   assign_parm_remove_parallels (data);\n \n-  if (data->promoted_mode != data->nominal_mode)\n+  if (data->arg.mode != data->nominal_mode)\n     {\n       /* Conversion is required.  */\n       rtx tempreg = gen_reg_rtx (GET_MODE (data->entry_parm));\n@@ -3477,9 +3460,9 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \n       if (data->stack_parm == 0)\n \t{\n-\t  int align = STACK_SLOT_ALIGNMENT (data->passed_type,\n+\t  int align = STACK_SLOT_ALIGNMENT (data->arg.type,\n \t\t\t\t\t    GET_MODE (data->entry_parm),\n-\t\t\t\t\t    TYPE_ALIGN (data->passed_type));\n+\t\t\t\t\t    TYPE_ALIGN (data->arg.type));\n \t  data->stack_parm\n \t    = assign_stack_local (GET_MODE (data->entry_parm),\n \t\t\t\t  GET_MODE_SIZE (GET_MODE (data->entry_parm)),\n@@ -3499,7 +3482,7 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n \t  to_conversion = true;\n \n \t  emit_block_move (dest, src,\n-\t\t\t   GEN_INT (int_size_in_bytes (data->passed_type)),\n+\t\t\t   GEN_INT (int_size_in_bytes (data->arg.type)),\n \t\t\t   BLOCK_OP_NORMAL);\n \t}\n       else\n@@ -3623,10 +3606,9 @@ assign_parms (tree fndecl)\n       if (SUPPORTS_STACK_ALIGNMENT)\n         {\n           unsigned int align\n-\t    = targetm.calls.function_arg_boundary (data.promoted_mode,\n-\t\t\t\t\t\t   data.passed_type);\n-\t  align = MINIMUM_ALIGNMENT (data.passed_type, data.promoted_mode,\n-\t\t\t\t     align);\n+\t    = targetm.calls.function_arg_boundary (data.arg.mode,\n+\t\t\t\t\t\t   data.arg.type);\n+\t  align = MINIMUM_ALIGNMENT (data.arg.type, data.arg.mode, align);\n \t  if (TYPE_ALIGN (data.nominal_type) > align)\n \t    align = MINIMUM_ALIGNMENT (data.nominal_type,\n \t\t\t\t       TYPE_MODE (data.nominal_type),\n@@ -3651,7 +3633,7 @@ assign_parms (tree fndecl)\n       if (data.passed_pointer)\n \t{\n \t  rtx incoming_rtl\n-\t    = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data.passed_type)),\n+\t    = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (data.arg.type)),\n \t\t\t   data.entry_parm);\n \t  set_decl_incoming_rtl (parm, incoming_rtl, true);\n \t}\n@@ -3671,9 +3653,7 @@ assign_parms (tree fndecl)\n \tassign_parms_setup_varargs (&all, &data, false);\n \n       /* Update info on where next arg arrives in registers.  */\n-      function_arg_info arg (data.passed_type, data.promoted_mode,\n-\t\t\t     data.named_arg);\n-      targetm.calls.function_arg_advance (all.args_so_far, arg);\n+      targetm.calls.function_arg_advance (all.args_so_far, data.arg);\n     }\n \n   if (targetm.calls.split_complex_arg)\n@@ -3860,15 +3840,13 @@ gimplify_parameters (gimple_seq *cleanup)\n \tcontinue;\n \n       /* Update info on where next arg arrives in registers.  */\n-      function_arg_info arg (data.passed_type, data.promoted_mode,\n-\t\t\t     data.named_arg);\n-      targetm.calls.function_arg_advance (all.args_so_far, arg);\n+      targetm.calls.function_arg_advance (all.args_so_far, data.arg);\n \n       /* ??? Once upon a time variable_size stuffed parameter list\n \t SAVE_EXPRs (amongst others) onto a pending sizes list.  This\n \t turned out to be less than manageable in the gimple world.\n \t Now we have to hunt them down ourselves.  */\n-      walk_tree_without_duplicates (&data.passed_type,\n+      walk_tree_without_duplicates (&data.arg.type,\n \t\t\t\t    gimplify_parm_type, &stmts);\n \n       if (TREE_CODE (DECL_SIZE_UNIT (parm)) != INTEGER_CST)\n@@ -3879,8 +3857,8 @@ gimplify_parameters (gimple_seq *cleanup)\n \n       if (data.passed_pointer)\n \t{\n-          tree type = TREE_TYPE (data.passed_type);\n-\t  function_arg_info orig_arg (type, data.named_arg);\n+\t  tree type = TREE_TYPE (data.arg.type);\n+\t  function_arg_info orig_arg (type, data.arg.named);\n \t  if (reference_callee_copied (&all.args_so_far_v, orig_arg))\n \t    {\n \t      tree local, t;"}]}