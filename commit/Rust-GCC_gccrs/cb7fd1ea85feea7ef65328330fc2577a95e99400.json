{"sha": "cb7fd1ea85feea7ef65328330fc2577a95e99400", "node_id": "C_kwDOANBUbNoAKGNiN2ZkMWVhODVmZWVhN2VmNjUzMjgzMzBmYzI1NzdhOTVlOTk0MDA", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-10T20:09:48Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-06-10T20:09:48Z"}, "message": "c++: optimize specialization of nested templated classes\n\nWhen substituting a class template specialization, tsubst_aggr_type\nsubstitutes the TYPE_CONTEXT before passing it to lookup_template_class.\nThis appears to be unnecessary, however, because the the initial value\nof lookup_template_class's context parameter is unused outside of the\nIDENTIFIER_NODE case, and l_t_c performs its own substitution of the\ncontext, anyway.  So this patch removes the redundant substitution in\ntsubst_aggr_type.  Doing so causes us to ICE on template/nested5.C\nbecause during lookup_template_class for A<T>::C::D<S> with T=E and S=S,\nwe substitute and complete the context A<T>::C with T=E, which in turn\nregisters the desired dependent specialization of D for us which we end\nup trying to register twice.  This patch fixes this by checking the\nspecializations table again after completion of the context.\n\nThis patch also implements a couple of other optimizations:\n\n  * In lookup_template_class, if the context of the partially\n    instantiated template is already non-dependent, then we could\n    reuse that instead of substituting the context of the most\n    general template.\n  * During tsubst_decl for the TYPE_DECL for an injected-class-name,\n    we can avoid substituting its TREE_TYPE.  We can also avoid\n    template argument substitution/coercion for this TYPE_DECL, and\n    for class-scope non-template VAR_/TYPE_DECLs more generally.\n\nTogether these optimizations improve memory usage for the range-v3\nfile test/view/zip.cc by about 5%.\n\ngcc/cp/ChangeLog:\n\n\t* pt.cc (lookup_template_class): Remove dead stores to\n\tcontext parameter.  Don't substitute the context of the\n\tmost general template if that of the partially instantiated\n\ttemplate is already non-dependent.  Check the specializations\n\ttable again after completing the context of a nested dependent\n\tspecialization.\n\t(tsubst_aggr_type) <case RECORD_TYPE>: Don't substitute\n\tTYPE_CONTEXT or pass it to lookup_template_class.\n\t(tsubst_decl) <case TYPE_DECL, case TYPE_DECL>: Avoid substituting\n\tthe TREE_TYPE for DECL_SELF_REFERENCE_P.  Avoid template argument\n\tsubstitution or coercion in some cases.", "tree": {"sha": "24a8ec0e9d7d7b6ab46e4f2211841a66ae4be44a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/24a8ec0e9d7d7b6ab46e4f2211841a66ae4be44a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb7fd1ea85feea7ef65328330fc2577a95e99400", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7fd1ea85feea7ef65328330fc2577a95e99400", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb7fd1ea85feea7ef65328330fc2577a95e99400", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb7fd1ea85feea7ef65328330fc2577a95e99400/comments", "author": null, "committer": null, "parents": [{"sha": "e6d369bbdb4eb5f03eec233ef9905013a735fd71", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6d369bbdb4eb5f03eec233ef9905013a735fd71", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6d369bbdb4eb5f03eec233ef9905013a735fd71"}], "stats": {"total": 78, "additions": 50, "deletions": 28}, "files": [{"sha": "079cadff37c625399403fdb4753b35482210d371", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 50, "deletions": 28, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb7fd1ea85feea7ef65328330fc2577a95e99400/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb7fd1ea85feea7ef65328330fc2577a95e99400/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=cb7fd1ea85feea7ef65328330fc2577a95e99400", "patch": "@@ -9840,8 +9840,6 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n \t  if (context)\n \t    pop_decl_namespace ();\n \t}\n-      if (templ)\n-\tcontext = DECL_CONTEXT (templ);\n     }\n   else if (TREE_CODE (d1) == TYPE_DECL && MAYBE_CLASS_TYPE_P (TREE_TYPE (d1)))\n     {\n@@ -9868,7 +9866,6 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n     {\n       templ = d1;\n       d1 = DECL_NAME (templ);\n-      context = DECL_CONTEXT (templ);\n     }\n   else if (DECL_TEMPLATE_TEMPLATE_PARM_P (d1))\n     {\n@@ -10059,8 +10056,26 @@ lookup_template_class (tree d1, tree arglist, tree in_decl, tree context,\n       context = DECL_CONTEXT (gen_tmpl);\n       if (context && TYPE_P (context))\n \t{\n-\t  context = tsubst_aggr_type (context, arglist, complain, in_decl, true);\n-\t  context = complete_type (context);\n+\t  if (!uses_template_parms (DECL_CONTEXT (templ)))\n+\t    /* If the context of the partially instantiated template is\n+\t       already non-dependent, then we might as well use it.  */\n+\t    context = DECL_CONTEXT (templ);\n+\t  else\n+\t    {\n+\t      context = tsubst_aggr_type (context, arglist,\n+\t\t\t\t\t  complain, in_decl, true);\n+\t      context = complete_type (context);\n+\t      if (is_dependent_type && arg_depth > 1)\n+\t\t{\n+\t\t  /* If this is a dependent nested specialization such as\n+\t\t     A<T>::B<U> [with T=int, U=U], then completion of A<int>\n+\t\t     could have caused to register the desired specialization\n+\t\t     of B already, so check the table again (33959).  */\n+\t\t  entry = type_specializations->find_with_hash (&elt, hash);\n+\t\t  if (entry)\n+\t\t    return entry->spec;\n+\t\t}\n+\t    }\n \t}\n       else\n \tcontext = tsubst (context, arglist, complain, in_decl);\n@@ -13739,25 +13754,12 @@ tsubst_aggr_type (tree t,\n       if (TYPE_TEMPLATE_INFO (t) && uses_template_parms (t))\n \t{\n \t  tree argvec;\n-\t  tree context;\n \t  tree r;\n \n \t  /* In \"sizeof(X<I>)\" we need to evaluate \"I\".  */\n \t  cp_evaluated ev;\n \n-\t  /* First, determine the context for the type we are looking\n-\t     up.  */\n-\t  context = TYPE_CONTEXT (t);\n-\t  if (context && TYPE_P (context))\n-\t    {\n-\t      context = tsubst_aggr_type (context, args, complain,\n-\t\t\t\t\t  in_decl, /*entering_scope=*/1);\n-\t      /* If context is a nested class inside a class template,\n-\t         it may still need to be instantiated (c++/33959).  */\n-\t      context = complete_type (context);\n-\t    }\n-\n-\t  /* Then, figure out what arguments are appropriate for the\n+\t  /* Figure out what arguments are appropriate for the\n \t     type we are trying to find.  For example, given:\n \n \t       template <class T> struct S;\n@@ -13772,7 +13774,7 @@ tsubst_aggr_type (tree t,\n \t    r = error_mark_node;\n \t  else\n \t    {\n-\t      r = lookup_template_class (t, argvec, in_decl, context,\n+\t      r = lookup_template_class (t, argvec, in_decl, NULL_TREE,\n \t\t\t\t\t entering_scope, complain);\n \t      r = cp_build_qualified_type (r, cp_type_quals (t), complain);\n \t    }\n@@ -14913,6 +14915,10 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t\tctx = tsubst_aggr_type (ctx, args,\n \t\t\t\t\tcomplain,\n \t\t\t\t\tin_decl, /*entering_scope=*/1);\n+\t\tif (DECL_SELF_REFERENCE_P (t))\n+\t\t  /* The context and type of an injected-class-name are\n+\t\t     the same, so we don't need to substitute both.  */\n+\t\t  type = ctx;\n \t\t/* If CTX is unchanged, then T is in fact the\n \t\t   specialization we want.  That situation occurs when\n \t\t   referencing a static data member within in its own\n@@ -14931,16 +14937,32 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \n \t    if (!spec)\n \t      {\n+\t\tint args_depth = TMPL_ARGS_DEPTH (args);\n+\t\tint parms_depth = TMPL_ARGS_DEPTH (DECL_TI_ARGS (t));\n \t\ttmpl = DECL_TI_TEMPLATE (t);\n \t\tgen_tmpl = most_general_template (tmpl);\n-\t\targvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n-\t\tif (argvec != error_mark_node)\n-\t\t  argvec = (coerce_innermost_template_parms\n-\t\t\t    (DECL_TEMPLATE_PARMS (gen_tmpl),\n-\t\t\t     argvec, t, complain,\n-\t\t\t     /*all*/true, /*defarg*/true));\n-\t\tif (argvec == error_mark_node)\n-\t\t  RETURN (error_mark_node);\n+\t\tif (args_depth == parms_depth\n+\t\t    && !PRIMARY_TEMPLATE_P (gen_tmpl))\n+\t\t  /* The DECL_TI_ARGS in this case are the generic template\n+\t\t     arguments for the enclosing class template, so we can\n+\t\t     shortcut substitution (which would just be the identity\n+\t\t     mapping).  */\n+\t\t  argvec = args;\n+\t\telse\n+\t\t  {\n+\t\t    argvec = tsubst (DECL_TI_ARGS (t), args, complain, in_decl);\n+\t\t    /* Coerce the innermost arguments again if necessary.  If\n+\t\t       there's fewer levels of args than of parms, then the\n+\t\t       substitution could not have changed the innermost args\n+\t\t       (modulo level lowering).  */\n+\t\t    if (args_depth >= parms_depth && argvec != error_mark_node)\n+\t\t      argvec = (coerce_innermost_template_parms\n+\t\t\t\t(DECL_TEMPLATE_PARMS (gen_tmpl),\n+\t\t\t\t argvec, t, complain,\n+\t\t\t\t /*all*/true, /*defarg*/true));\n+\t\t    if (argvec == error_mark_node)\n+\t\t      RETURN (error_mark_node);\n+\t\t  }\n \t\thash = hash_tmpl_and_args (gen_tmpl, argvec);\n \t\tspec = retrieve_specialization (gen_tmpl, argvec, hash);\n \t      }"}]}