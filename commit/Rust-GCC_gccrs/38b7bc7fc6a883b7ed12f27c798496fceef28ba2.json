{"sha": "38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhiN2JjN2ZjNmE4ODNiN2VkMTJmMjdjNzk4NDk2ZmNlZWYyOGJhMg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2013-11-13T00:38:49Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-13T00:38:49Z"}, "message": "extend.texi (Statement Exprs, Typeof): Discuss __auto_type.\n\n\t* doc/extend.texi (Statement Exprs, Typeof): Discuss __auto_type.\n\t* ginclude/stdatomic.h (kill_dependency, atomic_store_explicit)\n\t(atomic_load_explicit, atomic_exchange_explicit)\n\t(atomic_compare_exchange_strong_explicit)\n\t(atomic_compare_exchange_weak_explicit): Use __auto_type to\n\tdeclare variable initialized with PTR argument.\n\nc-family:\n\t* c-common.h (enum rid): Add RID_AUTO_TYPE.\n\t* c-common.c (c_common_reswords): Add __auto_type.\n\t(keyword_begins_type_specifier): Handle RID_AUTO_TYPE.\n\nc:\n\t* c-tree.h (c_typespec_keyword): Add cts_auto_type.\n\t* c-decl.c (declspecs_add_type, finish_declspecs): Handle\n\t__auto_type.\n\t* c-parser.c (c_token_starts_typename, c_token_starts_declspecs)\n\t(c_parser_attribute_any_word, c_parser_objc_selector): Handle\n\tRID_AUTO_TYPE.\n\t(c_parser_declspecs): Take argument AUTO_TYPE_OK.\n\t(c_parser_declaration_or_fndef, c_parser_struct_declaration)\n\t(c_parser_declarator, c_parser_direct_declarator_inner)\n\t(c_parser_parameter_declaration, c_parser_type_name): All callers\n\tchanged.\n\t(c_parser_declaration_or_fndef): Handle declarations with type\n\tdetermined from the initializer.\n\ntestsuite:\n\t* gcc.dg/atomic/stdatomic-vm.c, gcc.dg/auto-type-1.c,\n\tgcc.dg/auto-type-2.c: New tests.\n\nFrom-SVN: r204731", "tree": {"sha": "e843a9dc913b73d2b8924f2993e8aaeee0c8be4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e843a9dc913b73d2b8924f2993e8aaeee0c8be4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6d3f03341138d3918c71ce9fc6f05b81ebe004e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6d3f03341138d3918c71ce9fc6f05b81ebe004e"}], "stats": {"total": 457, "additions": 410, "deletions": 47}, "files": [{"sha": "95e51ed554cd8abf1876f92cd0421384154bfde1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -1,3 +1,12 @@\n+2013-11-13  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* doc/extend.texi (Statement Exprs, Typeof): Discuss __auto_type.\n+\t* ginclude/stdatomic.h (kill_dependency, atomic_store_explicit)\n+\t(atomic_load_explicit, atomic_exchange_explicit)\n+\t(atomic_compare_exchange_strong_explicit)\n+\t(atomic_compare_exchange_weak_explicit): Use __auto_type to\n+\tdeclare variable initialized with PTR argument.\n+\n 2013-11-12  Jeff Law  <law@redhat.com>\n \n \t* tree-ssa-threadedge.c (thread_around_empty_blocks): New"}, {"sha": "e4e6163e0916cebf64cb9aacf433a99cc3fc8760", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -1,3 +1,9 @@\n+2013-11-13  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-common.h (enum rid): Add RID_AUTO_TYPE.\n+\t* c-common.c (c_common_reswords): Add __auto_type.\n+\t(keyword_begins_type_specifier): Handle RID_AUTO_TYPE.\n+\n 2013-11-12  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c-family/c-common.c: Include gimplify.h."}, {"sha": "1f5e4ededa170c026c7632b77a4a9ad5480ac7ff", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -434,6 +434,7 @@ const struct c_common_resword c_common_reswords[] =\n   { \"__asm__\",\t\tRID_ASM,\t0 },\n   { \"__attribute\",\tRID_ATTRIBUTE,\t0 },\n   { \"__attribute__\",\tRID_ATTRIBUTE,\t0 },\n+  { \"__auto_type\",\tRID_AUTO_TYPE,\tD_CONLY },\n   { \"__bases\",          RID_BASES, D_CXXONLY },\n   { \"__builtin_choose_expr\", RID_CHOOSE_EXPR, D_CONLY },\n   { \"__builtin_complex\", RID_BUILTIN_COMPLEX, D_CONLY },\n@@ -11551,6 +11552,7 @@ keyword_begins_type_specifier (enum rid keyword)\n {\n   switch (keyword)\n     {\n+    case RID_AUTO_TYPE:\n     case RID_INT:\n     case RID_CHAR:\n     case RID_FLOAT:"}, {"sha": "d9d2c44097aa1f004e43639f6c88924093bcd116", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -102,7 +102,7 @@ enum rid\n   RID_EXTENSION, RID_IMAGPART, RID_REALPART, RID_LABEL,      RID_CHOOSE_EXPR,\n   RID_TYPES_COMPATIBLE_P,      RID_BUILTIN_COMPLEX,\t     RID_BUILTIN_SHUFFLE,\n   RID_DFLOAT32, RID_DFLOAT64, RID_DFLOAT128,\n-  RID_FRACT, RID_ACCUM,\n+  RID_FRACT, RID_ACCUM, RID_AUTO_TYPE,\n \n   /* C11 */\n   RID_ALIGNAS, RID_GENERIC,"}, {"sha": "b9b9dc9cacc61e0f78686ce5119f68f118bf852b", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -1,3 +1,19 @@\n+2013-11-13  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* c-tree.h (c_typespec_keyword): Add cts_auto_type.\n+\t* c-decl.c (declspecs_add_type, finish_declspecs): Handle\n+\t__auto_type.\n+\t* c-parser.c (c_token_starts_typename, c_token_starts_declspecs)\n+\t(c_parser_attribute_any_word, c_parser_objc_selector): Handle\n+\tRID_AUTO_TYPE.\n+\t(c_parser_declspecs): Take argument AUTO_TYPE_OK.\n+\t(c_parser_declaration_or_fndef, c_parser_struct_declaration)\n+\t(c_parser_declarator, c_parser_direct_declarator_inner)\n+\t(c_parser_parameter_declaration, c_parser_type_name): All callers\n+\tchanged.\n+\t(c_parser_declaration_or_fndef): Handle declarations with type\n+\tdetermined from the initializer.\n+\n 2013-11-12  Andrew MacLeod  <amacleod@redhat.com>\n \n \t* c/c-typeck.c: Include gimplify.h."}, {"sha": "92fc68f2017e5035d45e5dc6a7facbf6d47843c0", "filename": "gcc/c/c-decl.c", "status": "modified", "additions": 64, "deletions": 2, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -9115,6 +9115,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<short%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<void%> in \"\n@@ -9159,6 +9163,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<long%> and %<short%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<short%> and %<void%> in \"\n@@ -9207,6 +9215,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<signed%> and %<unsigned%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<signed%> and %<void%> in \"\n@@ -9247,6 +9259,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\terror_at (loc,\n \t\t\t  (\"both %<signed%> and %<unsigned%> in \"\n \t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<unsigned%> and %<void%> in \"\n@@ -9286,7 +9302,11 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t      if (!flag_isoc99 && !in_system_header_at (loc))\n \t\tpedwarn (loc, OPT_Wpedantic,\n \t\t\t \"ISO C90 does not support complex types\");\n-\t      if (specs->typespec_word == cts_void)\n+\t      if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<complex%> and %<void%> in \"\n \t\t\t   \"declaration specifiers\"));\n@@ -9334,6 +9354,10 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t\t\t    (\"both %<_Sat%> and %<__int128%> in \"\n \t\t\t     \"declaration specifiers\"));\n \t        }\n+\t      else if (specs->typespec_word == cts_auto_type)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n \t      else if (specs->typespec_word == cts_void)\n \t\terror_at (loc,\n \t\t\t  (\"both %<_Sat%> and %<void%> in \"\n@@ -9392,7 +9416,8 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n       else\n \t{\n \t  /* \"void\", \"_Bool\", \"char\", \"int\", \"float\", \"double\", \"_Decimal32\",\n-\t     \"__int128\", \"_Decimal64\", \"_Decimal128\", \"_Fract\" or \"_Accum\".  */\n+\t     \"__int128\", \"_Decimal64\", \"_Decimal128\", \"_Fract\", \"_Accum\" or\n+\t     \"__auto_type\".  */\n \t  if (specs->typespec_word != cts_none)\n \t    {\n \t      error_at (loc,\n@@ -9401,6 +9426,37 @@ declspecs_add_type (location_t loc, struct c_declspecs *specs,\n \t    }\n \t  switch (i)\n \t    {\n+\t    case RID_AUTO_TYPE:\n+\t      if (specs->long_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<long%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->short_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<short%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->signed_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<signed%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->unsigned_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<unsigned%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->complex_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<complex%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else if (specs->saturating_p)\n+\t\terror_at (loc,\n+\t\t\t  (\"both %<_Sat%> and %<__auto_type%> in \"\n+\t\t\t   \"declaration specifiers\"));\n+\t      else\n+\t\t{\n+\t\t  specs->typespec_word = cts_auto_type;\n+\t\t  specs->locations[cdw_typespec] = loc;\n+\t\t}\n+\t      return specs;\n \t    case RID_INT128:\n \t      if (int128_integer_type_node == NULL_TREE)\n \t\t{\n@@ -9956,6 +10012,12 @@ finish_declspecs (struct c_declspecs *specs)\n   /* Now compute the actual type.  */\n   switch (specs->typespec_word)\n     {\n+    case cts_auto_type:\n+      gcc_assert (!specs->long_p && !specs->short_p\n+\t\t  && !specs->signed_p && !specs->unsigned_p\n+\t\t  && !specs->complex_p);\n+      /* Type to be filled in later.  */\n+      break;\n     case cts_void:\n       gcc_assert (!specs->long_p && !specs->short_p\n \t\t  && !specs->signed_p && !specs->unsigned_p"}, {"sha": "ffbf3c41f93d4d2125bdebbfc4ea8f0a2169b512", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 122, "deletions": 25, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -501,6 +501,7 @@ c_token_starts_typename (c_token *token)\n \tcase RID_FRACT:\n \tcase RID_ACCUM:\n \tcase RID_SAT:\n+\tcase RID_AUTO_TYPE:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -659,6 +660,7 @@ c_token_starts_declspecs (c_token *token)\n \tcase RID_SAT:\n \tcase RID_ALIGNAS:\n \tcase RID_ATOMIC:\n+\tcase RID_AUTO_TYPE:\n \t  return true;\n \tdefault:\n \t  return false;\n@@ -1128,7 +1130,7 @@ static void c_parser_declaration_or_fndef (c_parser *, bool, bool, bool,\n static void c_parser_static_assert_declaration_no_semi (c_parser *);\n static void c_parser_static_assert_declaration (c_parser *);\n static void c_parser_declspecs (c_parser *, struct c_declspecs *, bool, bool,\n-\t\t\t\tbool, bool, enum c_lookahead_kind);\n+\t\t\t\tbool, bool, bool, enum c_lookahead_kind);\n static struct c_typespec c_parser_enum_specifier (c_parser *);\n static struct c_typespec c_parser_struct_or_union_specifier (c_parser *);\n static tree c_parser_struct_declaration (c_parser *);\n@@ -1499,7 +1501,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n     }\n \n   c_parser_declspecs (parser, specs, true, true, start_attr_ok,\n-\t\t      true, cla_nonabstract_decl);\n+\t\t      true, true, cla_nonabstract_decl);\n   if (parser->error)\n     {\n       c_parser_skip_to_end_of_block_or_statement (parser);\n@@ -1512,9 +1514,12 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       return;\n     }\n   finish_declspecs (specs);\n+  bool auto_type_p = specs->typespec_word == cts_auto_type;\n   if (c_parser_next_token_is (parser, CPP_SEMICOLON))\n     {\n-      if (empty_ok)\n+      if (auto_type_p)\n+\terror_at (here, \"%<__auto_type%> in empty declaration\");\n+      else if (empty_ok)\n \tshadow_tag (specs);\n       else\n \t{\n@@ -1537,7 +1542,7 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n       shadow_tag_warned (specs, 1);\n       return;\n     }\n-  else if (c_dialect_objc ())\n+  else if (c_dialect_objc () && !auto_type_p)\n     {\n       /* Prefix attributes are an error on method decls.  */\n       switch (c_parser_peek_token (parser)->type)\n@@ -1640,6 +1645,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  c_parser_skip_to_end_of_block_or_statement (parser);\n \t  return;\n \t}\n+      if (auto_type_p && declarator->kind != cdk_id)\n+\t{\n+\t  error_at (here,\n+\t\t    \"%<__auto_type%> requires a plain identifier\"\n+\t\t    \" as declarator\");\n+\t  c_parser_skip_to_end_of_block_or_statement (parser);\n+\t  return;\n+\t}\n       if (c_parser_next_token_is (parser, CPP_EQ)\n \t  || c_parser_next_token_is (parser, CPP_COMMA)\n \t  || c_parser_next_token_is (parser, CPP_SEMICOLON)\n@@ -1667,19 +1680,72 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      struct c_expr init;\n \t      location_t init_loc;\n \t      c_parser_consume_token (parser);\n-\t      /* The declaration of the variable is in effect while\n-\t\t its initializer is parsed.  */\n-\t      d = start_decl (declarator, specs, true,\n-\t\t\t      chainon (postfix_attrs, all_prefix_attrs));\n-\t      if (!d)\n-\t\td = error_mark_node;\n-\t      if (omp_declare_simd_clauses.exists ())\n-\t\tc_finish_omp_declare_simd (parser, d, NULL_TREE,\n-\t\t\t\t\t   omp_declare_simd_clauses);\n-\t      start_init (d, asm_name, global_bindings_p ());\n-\t      init_loc = c_parser_peek_token (parser)->location;\n-\t      init = c_parser_initializer (parser);\n-\t      finish_init ();\n+\t      if (auto_type_p)\n+\t\t{\n+\t\t  start_init (NULL_TREE, asm_name, global_bindings_p ());\n+\t\t  init_loc = c_parser_peek_token (parser)->location;\n+\t\t  init = c_parser_expr_no_commas (parser, NULL);\n+\t\t  if (TREE_CODE (init.value) == COMPONENT_REF\n+\t\t      && DECL_C_BIT_FIELD (TREE_OPERAND (init.value, 1)))\n+\t\t    error_at (here,\n+\t\t\t      \"%<__auto_type%> used with a bit-field\"\n+\t\t\t      \" initializer\");\n+\t\t  init = convert_lvalue_to_rvalue (init_loc, init, true, true);\n+\t\t  tree init_type = TREE_TYPE (init.value);\n+\t\t  /* As with typeof, remove _Atomic and const\n+\t\t     qualifiers from atomic types.  */\n+\t\t  if (init_type != error_mark_node && TYPE_ATOMIC (init_type))\n+\t\t    init_type\n+\t\t      = c_build_qualified_type (init_type,\n+\t\t\t\t\t\t(TYPE_QUALS (init_type)\n+\t\t\t\t\t\t & ~(TYPE_QUAL_ATOMIC\n+\t\t\t\t\t\t     | TYPE_QUAL_CONST)));\n+\t\t  bool vm_type = variably_modified_type_p (init_type,\n+\t\t\t\t\t\t\t   NULL_TREE);\n+\t\t  if (vm_type)\n+\t\t    init.value = c_save_expr (init.value);\n+\t\t  finish_init ();\n+\t\t  specs->typespec_kind = ctsk_typeof;\n+\t\t  specs->locations[cdw_typedef] = init_loc;\n+\t\t  specs->typedef_p = true;\n+\t\t  specs->type = init_type;\n+\t\t  if (vm_type)\n+\t\t    {\n+\t\t      bool maybe_const = true;\n+\t\t      tree type_expr = c_fully_fold (init.value, false,\n+\t\t\t\t\t\t     &maybe_const);\n+\t\t      specs->expr_const_operands &= maybe_const;\n+\t\t      if (specs->expr)\n+\t\t\tspecs->expr = build2 (COMPOUND_EXPR,\n+\t\t\t\t\t      TREE_TYPE (type_expr),\n+\t\t\t\t\t      specs->expr, type_expr);\n+\t\t      else\n+\t\t\tspecs->expr = type_expr;\n+\t\t    }\n+\t\t  d = start_decl (declarator, specs, true,\n+\t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n+\t\t  if (!d)\n+\t\t    d = error_mark_node;\n+\t\t  if (omp_declare_simd_clauses.exists ())\n+\t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n+\t\t\t\t\t       omp_declare_simd_clauses);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* The declaration of the variable is in effect while\n+\t\t     its initializer is parsed.  */\n+\t\t  d = start_decl (declarator, specs, true,\n+\t\t\t\t  chainon (postfix_attrs, all_prefix_attrs));\n+\t\t  if (!d)\n+\t\t    d = error_mark_node;\n+\t\t  if (omp_declare_simd_clauses.exists ())\n+\t\t    c_finish_omp_declare_simd (parser, d, NULL_TREE,\n+\t\t\t\t\t       omp_declare_simd_clauses);\n+\t\t  start_init (d, asm_name, global_bindings_p ());\n+\t\t  init_loc = c_parser_peek_token (parser)->location;\n+\t\t  init = c_parser_initializer (parser);\n+\t\t  finish_init ();\n+\t\t}\n \t      if (d != error_mark_node)\n \t\t{\n \t\t  maybe_warn_string_init (TREE_TYPE (d), init);\n@@ -1689,6 +1755,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  else\n \t    {\n+\t      if (auto_type_p)\n+\t\t{\n+\t\t  error_at (here,\n+\t\t\t    \"%<__auto_type%> requires an initialized \"\n+\t\t\t    \"data declaration\");\n+\t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n+\t\t  return;\n+\t\t}\n \t      tree d = start_decl (declarator, specs, false,\n \t\t\t\t   chainon (postfix_attrs,\n \t\t\t\t\t    all_prefix_attrs));\n@@ -1728,6 +1802,14 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t    }\n \t  if (c_parser_next_token_is (parser, CPP_COMMA))\n \t    {\n+\t      if (auto_type_p)\n+\t\t{\n+\t\t  error_at (here,\n+\t\t\t    \"%<__auto_type%> may only be used with\"\n+\t\t\t    \" a single declarator\");\n+\t\t  c_parser_skip_to_end_of_block_or_statement (parser);\n+\t\t  return;\n+\t\t}\n \t      c_parser_consume_token (parser);\n \t      if (c_parser_next_token_is_keyword (parser, RID_ATTRIBUTE))\n \t\tall_prefix_attrs = chainon (c_parser_attributes (parser),\n@@ -1757,6 +1839,13 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t      return;\n \t    }\n \t}\n+      else if (auto_type_p)\n+\t{\n+\t  error_at (here,\n+\t\t    \"%<__auto_type%> requires an initialized data declaration\");\n+\t  c_parser_skip_to_end_of_block_or_statement (parser);\n+\t  return;\n+\t}\n       else if (!fndef_ok)\n \t{\n \t  c_parser_error (parser, \"expected %<=%>, %<,%>, %<;%>, \"\n@@ -1949,7 +2038,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n    Storage class specifiers are accepted iff SCSPEC_OK; type\n    specifiers are accepted iff TYPESPEC_OK; alignment specifiers are\n    accepted iff ALIGNSPEC_OK; attributes are accepted at the start\n-   iff START_ATTR_OK.\n+   iff START_ATTR_OK; __auto_type is accepted iff AUTO_TYPE_OK.\n \n    declaration-specifiers:\n      storage-class-specifier declaration-specifiers[opt]\n@@ -2030,6 +2119,7 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n \n    type-specifier:\n      typeof-specifier\n+     __auto_type\n      __int128\n      _Decimal32\n      _Decimal64\n@@ -2055,7 +2145,8 @@ c_parser_static_assert_declaration_no_semi (c_parser *parser)\n static void\n c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t\t    bool scspec_ok, bool typespec_ok, bool start_attr_ok,\n-\t\t    bool alignspec_ok, enum c_lookahead_kind la)\n+\t\t    bool alignspec_ok, bool auto_type_ok,\n+\t\t    enum c_lookahead_kind la)\n {\n   bool attrs_ok = start_attr_ok;\n   bool seen_type = specs->typespec_kind != ctsk_none;\n@@ -2177,6 +2268,10 @@ c_parser_declspecs (c_parser *parser, struct c_declspecs *specs,\n \t\t\t\tc_parser_peek_token (parser)->value);\n \t  c_parser_consume_token (parser);\n \t  break;\n+\tcase RID_AUTO_TYPE:\n+\t  if (!auto_type_ok)\n+\t    goto out;\n+\t  /* Fall through.  */\n \tcase RID_UNSIGNED:\n \tcase RID_LONG:\n \tcase RID_INT128:\n@@ -2722,7 +2817,7 @@ c_parser_struct_declaration (c_parser *parser)\n      of N1731.\n      <http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1731.pdf>  */\n   c_parser_declspecs (parser, specs, false, true, true,\n-\t\t      true, cla_nonabstract_decl);\n+\t\t      true, false, cla_nonabstract_decl);\n   if (parser->error)\n     return NULL_TREE;\n   if (!specs->declspecs_seen_p)\n@@ -3045,7 +3140,7 @@ c_parser_declarator (c_parser *parser, bool type_seen_p, c_dtr_syn kind,\n       struct c_declarator *inner;\n       c_parser_consume_token (parser);\n       c_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t  false, cla_prefer_id);\n+\t\t\t  false, false, cla_prefer_id);\n       inner = c_parser_declarator (parser, type_seen_p, kind, seen_id);\n       if (inner == NULL)\n \treturn NULL;\n@@ -3201,13 +3296,13 @@ c_parser_direct_declarator_inner (c_parser *parser, bool id_present,\n       dimen.original_type = NULL_TREE;\n       c_parser_consume_token (parser);\n       c_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t  false, cla_prefer_id);\n+\t\t\t  false, false, cla_prefer_id);\n       static_seen = c_parser_next_token_is_keyword (parser, RID_STATIC);\n       if (static_seen)\n \tc_parser_consume_token (parser);\n       if (static_seen && !quals_attrs->declspecs_seen_p)\n \tc_parser_declspecs (parser, quals_attrs, false, false, true,\n-\t\t\t    false, cla_prefer_id);\n+\t\t\t    false, false, cla_prefer_id);\n       if (!quals_attrs->declspecs_seen_p)\n \tquals_attrs = NULL;\n       /* If \"static\" is present, there must be an array dimension.\n@@ -3510,7 +3605,7 @@ c_parser_parameter_declaration (c_parser *parser, tree attrs)\n       declspecs_add_attrs (input_location, specs, attrs);\n       attrs = NULL_TREE;\n     }\n-  c_parser_declspecs (parser, specs, true, true, true, true,\n+  c_parser_declspecs (parser, specs, true, true, true, true, false,\n \t\t      cla_nonabstract_decl);\n   finish_declspecs (specs);\n   pending_xref_error ();\n@@ -3643,6 +3738,7 @@ c_parser_attribute_any_word (c_parser *parser)\n \tcase RID_TRANSACTION_ATOMIC:\n \tcase RID_TRANSACTION_CANCEL:\n \tcase RID_ATOMIC:\n+\tcase RID_AUTO_TYPE:\n \t  ok = true;\n \t  break;\n \tdefault:\n@@ -3821,7 +3917,7 @@ c_parser_type_name (c_parser *parser)\n   struct c_declarator *declarator;\n   struct c_type_name *ret;\n   bool dummy = false;\n-  c_parser_declspecs (parser, specs, false, true, true, false,\n+  c_parser_declspecs (parser, specs, false, true, true, false, false,\n \t\t      cla_prefer_type);\n   if (!specs->declspecs_seen_p)\n     {\n@@ -8702,6 +8798,7 @@ c_parser_objc_selector (c_parser *parser)\n     case RID_VOID:\n     case RID_BOOL:\n     case RID_ATOMIC:\n+    case RID_AUTO_TYPE:\n       c_parser_consume_token (parser);\n       return value;\n     default:"}, {"sha": "c4dfc3baf3651d8eba495bdd2531f3d688200a70", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -214,7 +214,8 @@ enum c_typespec_keyword {\n   cts_dfloat64,\n   cts_dfloat128,\n   cts_fract,\n-  cts_accum\n+  cts_accum,\n+  cts_auto_type\n };\n \n /* This enum lists all the possible declarator specifiers, storage"}, {"sha": "599dee3c3bf204eb3e6e1deaa19e559e56ca925d", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -153,7 +153,7 @@ the value of an enumeration constant, the width of a bit-field, or\n the initial value of a static variable.\n \n If you don't know the type of the operand, you can still do this, but you\n-must use @code{typeof} (@pxref{Typeof}).\n+must use @code{typeof} or @code{__auto_type} (@pxref{Typeof}).\n \n In G++, the result value of a statement expression undergoes array and\n function pointer decay, and is returned by value to the enclosing\n@@ -755,6 +755,35 @@ Thus, @code{array (pointer (char), 4)} is the type of arrays of 4\n pointers to @code{char}.\n @end itemize\n \n+In GNU C, but not GNU C++, you may also declare the type of a variable\n+as @code{__auto_type}.  In that case, the declaration must declare\n+only one variable, whose declarator must just be an identifier, the\n+declaration must be initialized, and the type of the variable is\n+determined by the initializer; the name of the variable is not in\n+scope until after the initializer.  (In C++, you should use C++11\n+@code{auto} for this purpose.)  Using @code{__auto_type}, the\n+``maximum'' macro above could be written as:\n+\n+@smallexample\n+#define max(a,b) \\\n+  (@{ __auto_type _a = (a); \\\n+      __auto_type _b = (b); \\\n+    _a > _b ? _a : _b; @})\n+@end smallexample\n+\n+Using @code{__auto_type} instead of @code{typeof} has two advantages:\n+\n+@itemize @bullet\n+@item Each argument to the macro appears only once in the expansion of\n+the macro.  This prevents the size of the macro expansion growing\n+exponentially when calls to such macros are nested inside arguments of\n+such macros.\n+\n+@item If the argument to the macro has variably modified type, it is\n+evaluated only once when using @code{__auto_type}, but twice if\n+@code{typeof} is used.\n+@end itemize\n+\n @emph{Compatibility Note:} In addition to @code{typeof}, GCC 2 supported\n a more limited extension that permitted one to write\n "}, {"sha": "b558bf10f1964529879eee5184b760e2425467f6", "filename": "gcc/ginclude/stdatomic.h", "status": "modified", "additions": 25, "deletions": 17, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fginclude%2Fstdatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Fginclude%2Fstdatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdatomic.h?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -87,7 +87,7 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n #define kill_dependency(Y)\t\t\t\\\n   __extension__\t\t\t\t\t\\\n   ({\t\t\t\t\t\t\\\n-    __typeof__ (Y) __kill_dependency_tmp = (Y);\t\\\n+    __auto_type __kill_dependency_tmp = (Y);\t\\\n     __kill_dependency_tmp;\t\t\t\\\n   })\n \n@@ -121,9 +121,9 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n   __atomic_type_lock_free (void * _Atomic)\n \n \n-/* Note that these macros require __typeof__ to remove _Atomic\n-   qualifiers (and const qualifiers, if those are valid on macro\n-   operands).\n+/* Note that these macros require __typeof__ and __auto_type to remove\n+   _Atomic qualifiers (and const qualifiers, if those are valid on\n+   macro operands).\n    \n    Also note that the header file uses the generic form of __atomic\n    builtins, which requires the address to be taken of the value\n@@ -132,11 +132,12 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n    these to lock-free _N variants if possible, and throw away the\n    temps.  */\n \n-#define atomic_store_explicit(PTR, VAL, MO)\t\t\\\n-  __extension__\t\t\t\t\t\t\\\n-  ({\t\t\t\t\t\t\t\\\n-    __typeof__ (*(PTR)) __atomic_store_tmp = (VAL);\t\\\n-    __atomic_store ((PTR), &__atomic_store_tmp, (MO));\t\\\n+#define atomic_store_explicit(PTR, VAL, MO)\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\t\t\\\n+    __auto_type __atomic_store_ptr = (PTR);\t\t\t\t\\\n+    __typeof__ (*__atomic_store_ptr) __atomic_store_tmp = (VAL);\t\\\n+    __atomic_store (__atomic_store_ptr, &__atomic_store_tmp, (MO));\t\\\n   })\n \n #define atomic_store(PTR, VAL)\t\t\t\t\\\n@@ -146,8 +147,9 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n #define atomic_load_explicit(PTR, MO)\t\t\t\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({\t\t\t\t\t\t\t\t\t\\\n-    __typeof__ (*(PTR)) __atomic_load_tmp; \t\t\t\t\\\n-    __atomic_load ((PTR), &__atomic_load_tmp, (MO));\t\t\t\\\n+    __auto_type __atomic_load_ptr = (PTR);\t\t\t\t\\\n+    __typeof__ (*__atomic_load_ptr) __atomic_load_tmp;\t\t\t\\\n+    __atomic_load (__atomic_load_ptr, &__atomic_load_tmp, (MO));\t\\\n     __atomic_load_tmp;\t\t\t\t\t\t\t\\\n   })\n \n@@ -157,8 +159,10 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n #define atomic_exchange_explicit(PTR, VAL, MO)\t\t\t\t\\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({\t\t\t\t\t\t\t\t\t\\\n-    __typeof__ (*(PTR)) __atomic_exchange_val = (VAL), __atomic_exchange_tmp; \\\n-    __atomic_exchange ((PTR), &__atomic_exchange_val,\t\t\t\\\n+    __auto_type __atomic_exchange_ptr = (PTR);\t\t\t\t\\\n+    __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_val = (VAL);\t\\\n+    __typeof__ (*__atomic_exchange_ptr) __atomic_exchange_tmp;\t\t\\\n+    __atomic_exchange (__atomic_exchange_ptr, &__atomic_exchange_val,\t\\\n \t\t       &__atomic_exchange_tmp, (MO));\t\t\t\\\n     __atomic_exchange_tmp;\t\t\t\t\t\t\\\n   })\n@@ -170,8 +174,10 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n #define atomic_compare_exchange_strong_explicit(PTR, VAL, DES, SUC, FAIL) \\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({\t\t\t\t\t\t\t\t\t\\\n-    __typeof__ (*(PTR)) __atomic_compare_exchange_tmp = (DES);\t\t\\\n-    __atomic_compare_exchange ((PTR), (VAL),\t\t\t\t\\\n+    __auto_type __atomic_compare_exchange_ptr = (PTR);\t\t\t\\\n+    __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp \\\n+      = (DES);\t\t\t\t\t\t\t\t\\\n+    __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL),\t\\\n \t\t\t       &__atomic_compare_exchange_tmp, 0,\t\\\n \t\t\t       (SUC), (FAIL));\t\t\t\t\\\n   })\n@@ -183,8 +189,10 @@ typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;\n #define atomic_compare_exchange_weak_explicit(PTR, VAL, DES, SUC, FAIL) \\\n   __extension__\t\t\t\t\t\t\t\t\\\n   ({\t\t\t\t\t\t\t\t\t\\\n-    __typeof__ (*(PTR)) __atomic_compare_exchange_tmp = (DES);\t\t\\\n-    __atomic_compare_exchange ((PTR), (VAL),\t\t\t\t\\\n+    __auto_type __atomic_compare_exchange_ptr = (PTR);\t\t\t\\\n+    __typeof__ (*__atomic_compare_exchange_ptr) __atomic_compare_exchange_tmp \\\n+      = (DES);\t\t\t\t\t\t\t\t\\\n+    __atomic_compare_exchange (__atomic_compare_exchange_ptr, (VAL),\t\\\n \t\t\t       &__atomic_compare_exchange_tmp, 1,\t\\\n \t\t\t       (SUC), (FAIL));\t\t\t\t\\\n   })"}, {"sha": "2d724f73207f62828cdc3dc25e0794eb6b84b0d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -1,3 +1,8 @@\n+2013-11-13  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/atomic/stdatomic-vm.c, gcc.dg/auto-type-1.c,\n+\tgcc.dg/auto-type-2.c: New tests.\n+\n 2013-11-12  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n \n \t* gcc.dg/cilk-plus/cilk-plus.exp: Added a check for LTO before running"}, {"sha": "f43fa49ef12eca233d2478f8ad25e7047cf4b2eb", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-vm.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-vm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-vm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-vm.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -0,0 +1,68 @@\n+/* Test atomic operations on expressions of variably modified type\n+   with side effects.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+int s = 5;\n+\n+int count = 0;\n+\n+int\n+func (void)\n+{\n+  count++;\n+  return 0;\n+}\n+\n+int\n+main (void)\n+{\n+  int vla[s][s];\n+  int (*_Atomic p)[s] = &vla[0];\n+  int (*b)[s] = kill_dependency (++p);\n+  if (b != &vla[1] || p != &vla[1])\n+    abort ();\n+  int (*_Atomic *q)[s] = &p;\n+  atomic_store_explicit (q + func (), &vla[0], memory_order_seq_cst);\n+  if (count != 1)\n+    abort ();\n+  atomic_store (q + func (), &vla[0]);\n+  if (count != 2)\n+    abort ();\n+  (void) atomic_load_explicit (q + func (), memory_order_seq_cst);\n+  if (count != 3)\n+    abort ();\n+  (void) atomic_load (q + func ());\n+  if (count != 4)\n+    abort ();\n+  (void) atomic_exchange_explicit (q + func (), &vla[0], memory_order_seq_cst);\n+  if (count != 5)\n+    abort ();\n+  (void) atomic_exchange (q + func (), &vla[0]);\n+  if (count != 6)\n+    abort ();\n+  int vla2[s][s];\n+  int (*p2)[s] = &vla2[0];\n+  int (**qna)[s] = &p2;\n+  (void) atomic_compare_exchange_strong_explicit (q + func (), qna, &vla[0],\n+\t\t\t\t\t\t  memory_order_seq_cst,\n+\t\t\t\t\t\t  memory_order_seq_cst);\n+  if (count != 7)\n+    abort ();\n+  (void) atomic_compare_exchange_strong (q + func (), qna, &vla[0]);\n+  if (count != 8)\n+    abort ();\n+  (void) atomic_compare_exchange_weak_explicit (q + func (), qna, &vla[0],\n+\t\t\t\t\t\tmemory_order_seq_cst,\n+\t\t\t\t\t\tmemory_order_seq_cst);\n+  if (count != 9)\n+    abort ();\n+  (void) atomic_compare_exchange_weak (q + func (), qna, &vla[0]);\n+  if (count != 10)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "f47693abbf3b3fa4108d222d635f5dc97f1b1c4d", "filename": "gcc/testsuite/gcc.dg/auto-type-1.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-1.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -0,0 +1,37 @@\n+/* Test __auto_type.  Test correct uses.  */\n+/* { dg-do run } */\n+/* { dg-options \"\" } */\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+__auto_type i = 1;\n+extern int i;\n+__auto_type c = (char) 1;\n+extern char c;\n+static __auto_type u = 10U;\n+extern unsigned int u;\n+const __auto_type ll = 1LL;\n+extern const long long ll;\n+\n+int\n+main (void)\n+{\n+  if (i != 1 || c != 1 || u != 10U)\n+    abort ();\n+  __auto_type ai = i;\n+  int *aip = &ai;\n+  if (ai != 1)\n+    abort ();\n+  __auto_type p = (int (*) [++i]) 0;\n+  if (i != 2)\n+    abort ();\n+  if (sizeof (*p) != 2 * sizeof (int))\n+    abort ();\n+  int vla[u][u];\n+  int (*vp)[u] = &vla[0];\n+  __auto_type vpp = ++vp;\n+  if (vp != &vla[1])\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "761671b3c5a46ea419555db882f30cb1a78f13f6", "filename": "gcc/testsuite/gcc.dg/auto-type-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38b7bc7fc6a883b7ed12f27c798496fceef28ba2/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fauto-type-2.c?ref=38b7bc7fc6a883b7ed12f27c798496fceef28ba2", "patch": "@@ -0,0 +1,23 @@\n+/* Test __auto_type.  Test invalid uses.  */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+__auto_type; /* { dg-error \"empty declaration\" } */\n+__auto_type *p = (int *) 0; /* { dg-error \"plain identifier\" } */\n+struct s0 { int i : 1; } x;\n+void f (void) { __auto_type v = x.i; } /* { dg-error \"bit-field initializer\" } */\n+__auto_type i; /* { dg-error \"initialized data declaration\" } */\n+__auto_type g { } /* { dg-error \"initialized data declaration\" } */\n+__auto_type a = 1, b = 2; /* { dg-error \"single declarator\" } */\n+__auto_type long e0 = 0; /* { dg-error \"__auto_type\" } */\n+__auto_type short e1 = 0; /* { dg-error \"__auto_type\" } */\n+__auto_type signed e2 = 0; /* { dg-error \"__auto_type\" } */\n+__auto_type unsigned e3 = 0; /* { dg-error \"__auto_type\" } */\n+__auto_type _Complex e4 = 0; /* { dg-error \"__auto_type\" } */\n+long __auto_type e5 = 0; /* { dg-error \"__auto_type\" } */\n+short __auto_type e6 = 0; /* { dg-error \"__auto_type\" } */\n+signed __auto_type e7 = 0; /* { dg-error \"__auto_type\" } */\n+unsigned __auto_type e8 = 0; /* { dg-error \"__auto_type\" } */\n+_Complex __auto_type e9 = 0; /* { dg-error \"__auto_type\" } */\n+int __auto_type e10 = 0; /* { dg-error \"two or more data types\" } */\n+__auto_type _Bool e11 = 0; /* { dg-error \"two or more data types\" } */"}]}