{"sha": "f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "node_id": "C_kwDOANBUbNoAKGY2Y2UxZTc3YmJmNWQzYTA5NmY1MmU2NzRiZmQ3MzU0YzY1MzdkMTA", "commit": {"author": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-10-28T13:06:45Z"}, "committer": {"name": "Thomas Schwinge", "email": "thomas@codesourcery.com", "date": "2022-11-02T19:51:41Z"}, "message": "Support OpenACC 'declare create' with Fortran allocatable arrays, part II [PR106643, PR96668]\n\n\tPR libgomp/106643\n\tPR fortran/96668\n\tlibgomp/\n\t* oacc-mem.c (goacc_enter_data_internal): Support\n\tOpenACC 'declare create' with Fortran allocatable arrays, part II.\n\t* testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-directive.f90:\n\tAdjust.\n\t* testsuite/libgomp.oacc-fortran/pr106643-1.f90: New.", "tree": {"sha": "0a96485301ff432fc7643279ba3b3844b4faf450", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a96485301ff432fc7643279ba3b3844b4faf450"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/comments", "author": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tschwinge", "id": 21753, "node_id": "MDQ6VXNlcjIxNzUz", "avatar_url": "https://avatars.githubusercontent.com/u/21753?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tschwinge", "html_url": "https://github.com/tschwinge", "followers_url": "https://api.github.com/users/tschwinge/followers", "following_url": "https://api.github.com/users/tschwinge/following{/other_user}", "gists_url": "https://api.github.com/users/tschwinge/gists{/gist_id}", "starred_url": "https://api.github.com/users/tschwinge/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tschwinge/subscriptions", "organizations_url": "https://api.github.com/users/tschwinge/orgs", "repos_url": "https://api.github.com/users/tschwinge/repos", "events_url": "https://api.github.com/users/tschwinge/events{/privacy}", "received_events_url": "https://api.github.com/users/tschwinge/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da8e0e1191c5512244a752b30dea0eba83e3d10c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da8e0e1191c5512244a752b30dea0eba83e3d10c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da8e0e1191c5512244a752b30dea0eba83e3d10c"}], "stats": {"total": 188, "additions": 160, "deletions": 28}, "files": [{"sha": "233fe0e4c1d929339ff0761149c44f98d8242d20", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "patch": "@@ -1166,7 +1166,10 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \n \t  struct target_mem_desc *tgt = n->tgt;\n \n-\t  /* Arrange so that OpenACC 'declare' code \u00e0 la PR106643\n+\t  /* Minimal OpenACC variant corresponding to PR96668\n+\t     \"[OpenMP] Re-mapping allocated but previously unallocated\n+\t     allocatable does not work\" 'libgomp/target.c' changes, so that\n+\t     OpenACC 'declare' code \u00e0 la PR106643\n \t     \"[gfortran + OpenACC] Allocate in module causes refcount error\"\n \t     has a chance to work.  */\n \t  if ((kinds[i] & 0xff) == GOMP_MAP_TO_PSET\n@@ -1181,6 +1184,16 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\t  assert ((kinds[i + k] & 0xff) == GOMP_MAP_POINTER);\n \t\t}\n \n+\t      /* Let 'goacc_map_vars' -> 'gomp_map_vars_internal' handle\n+\t\t this.  */\n+\t      gomp_mutex_unlock (&acc_dev->lock);\n+\t      struct target_mem_desc *tgt_\n+\t\t= goacc_map_vars (acc_dev, aq, groupnum, &hostaddrs[i], NULL,\n+\t\t\t\t  &sizes[i], &kinds[i], true,\n+\t\t\t\t  GOMP_MAP_VARS_ENTER_DATA);\n+\t      assert (tgt_ == NULL);\n+\t      gomp_mutex_lock (&acc_dev->lock);\n+\n \t      /* Given that 'goacc_exit_data_internal'/'goacc_exit_datum_1'\n \t\t will always see 'n->refcount == REFCOUNT_INFINITY',\n \t\t there's no need to adjust 'n->dynamic_refcount' here.  */"}, {"sha": "6604f72c5c180048a229d0165995145cb555f4c7", "filename": "libgomp/testsuite/libgomp.oacc-fortran/declare-allocatable-array_descriptor-1-directive.f90", "status": "modified", "additions": 63, "deletions": 27, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeclare-allocatable-array_descriptor-1-directive.f90?ref=f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "patch": "@@ -105,27 +105,50 @@ end subroutine verify_n2_deallocated\n   !$acc enter data create (b)\n   ! This is now OpenACC \"present\":\n   if (.not.acc_is_present (b)) error stop\n-  ! This still has the initial array descriptor:\n+  ! ..., and got the actual array descriptor installed:\n   !$acc serial\n-  call verify_initial\n+  call verify_n1_allocated\n   !$acc end serial\n \n   do i = n1_lb, n1_ub\n      b(i) = i - 1\n   end do\n \n-  ! Verify that host-to-device copy doesn't touch the device-side (still\n-  ! initial) array descriptor (but it does copy the array data).\n+  ! In 'declare-allocatable-array_descriptor-1-runtime.f90', this does \"verify\n+  ! that host-to-device copy doesn't touch the device-side (still initial)\n+  ! array descriptor (but it does copy the array data\").  This is here not\n+  ! applicable anymore, as we've already gotten the actual array descriptor\n+  ! installed.  Thus now verify that it does copy the array data.\n   call acc_update_device (b)\n   !$acc serial\n-  call verify_initial\n+  call verify_n1_allocated\n   !$acc end serial\n \n   b = 40\n \n-  ! Verify that device-to-host copy doesn't touch the host-side array\n-  ! descriptor, doesn't copy out the device-side (still initial) array\n-  ! descriptor (but it does copy the array data).\n+  !$acc parallel copyout (id1_1) ! No data clause for 'b' (explicit or implicit): no 'GOMP_MAP_TO_PSET'.\n+  call verify_n1_values (-1)\n+  id1_1 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(from:id1_1\\)$} 1 original } }\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(from:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  !$acc parallel copy (b) copyout (id1_2)\n+  ! As already present, 'copy (b)' doesn't copy; addend is still '-1'.\n+  call verify_n1_values (-1)\n+  id1_2 = 0\n+  !$acc end parallel\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc parallel map\\(tofrom:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2\\)$} 1 original } }\n+  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n+  !TODO 'GOMP_MAP_TO_PSET':\n+  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_parallel map\\(tofrom:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(from:id1_2 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+\n+  ! In 'declare-allocatable-array_descriptor-1-runtime.f90', this does \"verify\n+  ! that device-to-host copy doesn't touch the host-side array descriptor,\n+  ! doesn't copy out the device-side (still initial) array descriptor (but it\n+  ! does copy the array data)\".  This is here not applicable anymore, as we've\n+  ! already gotten the actual array descriptor installed.  Thus now verify that\n+  ! it does copy the array data.\n   call acc_update_self (b)\n   call verify_n1_allocated\n \n@@ -142,11 +165,19 @@ end subroutine verify_n2_deallocated\n   ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_update map\\(force_to:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n   ! ..., but it's silently skipped in 'GOACC_update'.\n   !$acc serial\n-  call verify_initial\n+  call verify_n1_allocated\n   !$acc end serial\n \n   b = 41\n \n+  !$acc parallel\n+  call verify_n1_values (1)\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b)\n+  call verify_n1_values (1)\n+  !$acc end parallel\n+\n   !$acc update self (b) self (id1_2)\n   ! We do have 'GOMP_MAP_TO_PSET' here:\n   ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc update map\\(force_from:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(force_from:id1_2\\);$} 1 original } }\n@@ -159,20 +190,9 @@ end subroutine verify_n2_deallocated\n      b(i) = b(i) + 2\n   end do\n \n-  ! Now install the actual array descriptor, via a data clause for 'b'\n-  ! (explicit or implicit): must get a 'GOMP_MAP_TO_PSET', which then in\n-  ! 'gomp_map_vars_internal' is handled as 'declare target', and because of\n-  ! '*(void **) hostaddrs[i] != NULL', we've got 'has_always_ptrset == true',\n-  ! 'always_to_cnt == 1', and therefore 'gomp_map_vars_existing' does update\n-  ! the 'GOMP_MAP_TO_PSET'.\n-  !$acc serial present (b) copyin (id1_1)\n-  call verify_initial\n-  id1_1 = 0\n-  !$acc end serial\n-  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma acc serial map\\(force_present:\\*\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[len: [^\\]]+\\]\\) map\\(to:b \\[pointer set, len: [0-9]+\\]\\) map\\(alloc:\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\* restrict\\) b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1\\)$} 1 original } }\n-  !TODO ..., but without an actual use of 'b', the gimplifier removes the\n-  !TODO 'GOMP_MAP_TO_PSET':\n-  ! { dg-final { scan-tree-dump-times {(?n)^ *#pragma omp target oacc_serial map\\(force_present:MEM <integer\\(kind=[0-9]+\\)\\[0:\\]> \\[\\(integer\\(kind=[0-9]+\\)\\[0:\\] \\*\\)[^\\]]+\\] \\[len: [^\\]]+\\]\\) map\\(alloc:b\\.data \\[pointer assign, bias: 0\\]\\) map\\(to:id1_1 \\[len: [0-9]+\\]\\)$} 1 gimple } }\n+  ! Now test that (potentially re-)installing the actual array descriptor is a\n+  ! no-op, via a data clause for 'b' (explicit or implicit): must get a\n+  ! 'GOMP_MAP_TO_PSET'.\n   !$acc serial present (b) copyin (id1_2)\n   call verify_n1_allocated\n   !TODO Use of 'b':\n@@ -243,9 +263,9 @@ end subroutine verify_n2_deallocated\n   if (acc_is_present (b)) error stop\n   !$acc enter data create (b)\n   if (.not.acc_is_present (b)) error stop\n-  ! This still has the previous (n1) array descriptor:\n+  ! ..., and got the actual array descriptor installed:\n   !$acc serial\n-  call verify_n1_deallocated (.true.)\n+  call verify_n2_allocated\n   !$acc end serial\n \n   do i = n2_lb, n2_ub\n@@ -254,11 +274,19 @@ end subroutine verify_n2_deallocated\n \n   call acc_update_device (b)\n   !$acc serial\n-  call verify_n1_deallocated (.true.)\n+  call verify_n2_allocated\n   !$acc end serial\n \n   b = -40\n \n+  !$acc parallel\n+  call verify_n2_values (20)\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b)\n+  call verify_n2_values (20)\n+  !$acc end parallel\n+\n   call acc_update_self (b)\n   call verify_n2_allocated\n \n@@ -269,11 +297,19 @@ end subroutine verify_n2_deallocated\n \n   !$acc update device (b)\n   !$acc serial\n-  call verify_n1_deallocated (.true.)\n+  call verify_n2_allocated\n   !$acc end serial\n \n   b = -41\n \n+  !$acc parallel\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n+  !$acc parallel copy (b)\n+  call verify_n2_values (-20)\n+  !$acc end parallel\n+\n   !$acc update self (b)\n   call verify_n2_allocated\n "}, {"sha": "a9c969e336124bff65bca8b450ac2102127c1b48", "filename": "libgomp/testsuite/libgomp.oacc-fortran/pr106643-1.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr106643-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce1e77bbf5d3a096f52e674bfd7354c6537d10/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr106643-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fpr106643-1.f90?ref=f6ce1e77bbf5d3a096f52e674bfd7354c6537d10", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do run }\n+! { dg-additional-options -cpp }\n+\n+\n+!TODO OpenACC 'serial' vs. GCC/nvptx:\n+!TODO { dg-prune-output {using 'vector_length \\(32\\)', ignoring 1} }\n+\n+\n+module m_macron\n+\n+    implicit none\n+\n+    real(kind(0d0)), allocatable, dimension(:) :: valls\n+    !$acc declare create(valls)\n+\n+contains\n+\n+    subroutine s_macron_compute(size)\n+\n+        integer :: size\n+\n+        !$acc routine seq\n+\n+#if ACC_MEM_SHARED\n+        if (valls(size) /= 1) error stop\n+#else\n+        if (valls(size) /= size - 2) error stop\n+#endif\n+\n+        valls(size) = size + 2\n+\n+    end subroutine s_macron_compute\n+\n+    subroutine s_macron_init(size)\n+\n+        integer :: size\n+\n+        print*, \"size=\", size\n+\n+        print*, \"allocate(valls(1:size))\"\n+        allocate(valls(1:size))\n+\n+        print*, \"acc enter data create(valls(1:size))\"\n+        !$acc enter data create(valls(1:size))\n+\n+        print*, \"!$acc update device(valls(1:size))\"\n+        valls(size) = size - 2\n+        !$acc update device(valls(1:size))\n+\n+        valls(size) = 1\n+\n+        !$acc serial\n+        call s_macron_compute(size)\n+        !$acc end serial\n+\n+        valls(size) = -1\n+\n+        !$acc update host(valls(1:size))\n+#if ACC_MEM_SHARED\n+        if (valls(size) /= -1) error stop\n+#else\n+        if (valls(size) /= size + 2) error stop\n+#endif\n+\n+        print*, valls(1:size)\n+\n+        print*, \"acc exit data delete(valls)\"\n+        !$acc exit data delete(valls)\n+\n+    end subroutine s_macron_init\n+\n+end module m_macron\n+\n+\n+program p_main\n+\n+    use m_macron\n+\n+    implicit none\n+\n+    call s_macron_init(10)\n+\n+end program p_main"}]}