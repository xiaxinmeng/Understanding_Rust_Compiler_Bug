{"sha": "4524009c09ac5148643c1226f6868ef38cc44e6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDUyNDAwOWMwOWFjNTE0ODY0M2MxMjI2ZjY4NjhlZjM4Y2M0NGU2Yw==", "commit": {"author": {"name": "Wilco Dijkstra", "email": "wdijkstr@arm.com", "date": "2017-06-14T14:51:46Z"}, "committer": {"name": "Wilco Dijkstra", "email": "wilco@gcc.gnu.org", "date": "2017-06-14T14:51:46Z"}, "message": "Improve Cortex-A53 FP scheduler\n\nThe Cortex-A53 scheduler model of FMAC bypass is not quite right\nfor FMAC to FMAC forwarding.  Experiments also show the latencies of\nFP operations are too high as well.  Rather than adding more bypasses,\nadjust the latencies of FP instructions to get a better schedule on\naverage.  As a result SPECFP2006 is 1.1% faster.\n\n    gcc/\n\t* config/arm/cortex-a53.md (cortex_a53_fpalu) Adjust latency.\n\t(cortex_a53_fconst): Likewise.\n\t(cortex_a53_fpmul): Likewise.\n\t(cortex_a53_f_load_64): Likewise.\n\t(cortex_a53_f_load_many): Likewise.\n\t(cortex_a53_advsimd_alu): Likewise.\n\t(cortex_a53_advsimd_alu_q): Likewise.\n\t(cortex_a53_advsimd_mul): Likewise.\n\t(cortex_a53_advsimd_mul_q): Likewise.\n\t(fpmac bypass): Add new bypass for fpmac-fpmac case.\n\tAdd missing fmul, r2f_cvt and fconst cases.\n\nFrom-SVN: r249200", "tree": {"sha": "536bd4a183e5012b4b57c4eaa923a6d29d94654b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/536bd4a183e5012b4b57c4eaa923a6d29d94654b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4524009c09ac5148643c1226f6868ef38cc44e6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4524009c09ac5148643c1226f6868ef38cc44e6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4524009c09ac5148643c1226f6868ef38cc44e6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4524009c09ac5148643c1226f6868ef38cc44e6c/comments", "author": null, "committer": null, "parents": [{"sha": "ea9a08f5dfbab28de2eabfeb684b42c0615cd99d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea9a08f5dfbab28de2eabfeb684b42c0615cd99d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea9a08f5dfbab28de2eabfeb684b42c0615cd99d"}], "stats": {"total": 48, "additions": 30, "deletions": 18}, "files": [{"sha": "59ca50606dedee3b72b42bb044637375219607ca", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4524009c09ac5148643c1226f6868ef38cc44e6c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4524009c09ac5148643c1226f6868ef38cc44e6c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4524009c09ac5148643c1226f6868ef38cc44e6c", "patch": "@@ -1,3 +1,17 @@\n+2017-06-14  Wilco Dijkstra  <wdijkstr@arm.com>\n+\n+\t* config/arm/cortex-a53.md (cortex_a53_fpalu) Adjust latency.\n+\t(cortex_a53_fconst): Likewise.\n+\t(cortex_a53_fpmul): Likewise.\n+\t(cortex_a53_f_load_64): Likewise.\n+\t(cortex_a53_f_load_many): Likewise.\n+\t(cortex_a53_advsimd_alu): Likewise.\n+\t(cortex_a53_advsimd_alu_q): Likewise.\n+\t(cortex_a53_advsimd_mul): Likewise.\n+\t(cortex_a53_advsimd_mul_q): Likewise.\n+\t(fpmac bypass): Add new bypass for fpmac-fpmac case.\n+\tAdd missing fmul, r2f_cvt and fconst cases.\n+\n 2017-06-14  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/81088"}, {"sha": "ff16e360a66a0cc4393cd74c6c69a37ee2af9654", "filename": "gcc/config/arm/cortex-a53.md", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4524009c09ac5148643c1226f6868ef38cc44e6c/gcc%2Fconfig%2Farm%2Fcortex-a53.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4524009c09ac5148643c1226f6868ef38cc44e6c/gcc%2Fconfig%2Farm%2Fcortex-a53.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fcortex-a53.md?ref=4524009c09ac5148643c1226f6868ef38cc44e6c", "patch": "@@ -511,19 +511,19 @@\n ;; Floating-point arithmetic.\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-(define_insn_reservation \"cortex_a53_fpalu\" 5\n+(define_insn_reservation \"cortex_a53_fpalu\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n \t(eq_attr \"type\" \"ffariths, fadds, ffarithd, faddd, fmov,\n \t\t\tf_cvt, fcmps, fcmpd, fccmps, fccmpd, fcsel,\n \t\t\tf_rints, f_rintd, f_minmaxs, f_minmaxd\"))\n   \"cortex_a53_slot_any,cortex_a53_fp_alu\")\n \n-(define_insn_reservation \"cortex_a53_fconst\" 3\n+(define_insn_reservation \"cortex_a53_fconst\" 2\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"type\" \"fconsts,fconstd\"))\n   \"cortex_a53_slot_any,cortex_a53_fp_alu\")\n \n-(define_insn_reservation \"cortex_a53_fpmul\" 5\n+(define_insn_reservation \"cortex_a53_fpmul\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"type\" \"fmuls,fmuld\"))\n   \"cortex_a53_slot_any,cortex_a53_fp_mul\")\n@@ -574,15 +574,15 @@\n ;; Floating-point load/store.\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n-(define_insn_reservation \"cortex_a53_f_load_64\" 4\n+(define_insn_reservation \"cortex_a53_f_load_64\" 3\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (ior (eq_attr \"type\" \"f_loads,f_loadd\")\n \t    (eq_attr \"cortex_a53_advsimd_type\"\n \t\t     \"advsimd_load_64\")))\n   \"cortex_a53_slot_any+cortex_a53_ls_agen,\n    cortex_a53_load\")\n \n-(define_insn_reservation \"cortex_a53_f_load_many\" 5\n+(define_insn_reservation \"cortex_a53_f_load_many\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"cortex_a53_advsimd_type\"\n \t\t\"advsimd_load_128,advsimd_load_lots\"))\n@@ -616,22 +616,22 @@\n ;; or a 128-bit operation in which case we require in our model that we\n ;; issue from slot 0.\n \n-(define_insn_reservation \"cortex_a53_advsimd_alu\" 5\n+(define_insn_reservation \"cortex_a53_advsimd_alu\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"cortex_a53_advsimd_type\" \"advsimd_alu\"))\n   \"cortex_a53_slot_any,cortex_a53_fp_alu\")\n \n-(define_insn_reservation \"cortex_a53_advsimd_alu_q\" 5\n+(define_insn_reservation \"cortex_a53_advsimd_alu_q\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"cortex_a53_advsimd_type\" \"advsimd_alu_q\"))\n   \"cortex_a53_slot0,cortex_a53_fp_alu_q\")\n \n-(define_insn_reservation \"cortex_a53_advsimd_mul\" 5\n+(define_insn_reservation \"cortex_a53_advsimd_mul\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"cortex_a53_advsimd_type\" \"advsimd_mul\"))\n   \"cortex_a53_slot_any,cortex_a53_fp_mul\")\n \n-(define_insn_reservation \"cortex_a53_advsimd_mul_q\" 5\n+(define_insn_reservation \"cortex_a53_advsimd_mul_q\" 4\n   (and (eq_attr \"tune\" \"cortexa53\")\n        (eq_attr \"cortex_a53_advsimd_type\" \"advsimd_mul_q\"))\n   \"cortex_a53_slot0,cortex_a53_fp_mul_q\")\n@@ -710,20 +710,18 @@\n ;; multiply-accumulate operations as a bypass reducing the latency\n ;; of producing instructions to near zero.\n \n-(define_bypass 1 \"cortex_a53_fp*,\n+(define_bypass 1 \"cortex_a53_fpalu,\n+\t\t  cortex_a53_fpmul,\n \t\t  cortex_a53_r2f,\n+\t\t  cortex_a53_r2f_cvt,\n+\t\t  cortex_a53_fconst,\n \t\t  cortex_a53_f_load*\"\n \t\t \"cortex_a53_fpmac\"\n \t\t \"aarch_accumulator_forwarding\")\n \n-;; Model a bypass from the result of an FP operation to a use.\n-\n-(define_bypass 4 \"cortex_a53_fpalu,\n-\t\t  cortex_a53_fpmul\"\n-\t\t \"cortex_a53_fpalu,\n-\t\t  cortex_a53_fpmul,\n-\t\t  cortex_a53_fpmac,\n-\t\t  cortex_a53_advsimd_div*\")\n+(define_bypass 4 \"cortex_a53_fpmac\"\n+\t\t \"cortex_a53_fpmac\"\n+\t\t \"aarch_accumulator_forwarding\")\n \n ;; We want AESE and AESMC to end up consecutive to one another.\n "}]}