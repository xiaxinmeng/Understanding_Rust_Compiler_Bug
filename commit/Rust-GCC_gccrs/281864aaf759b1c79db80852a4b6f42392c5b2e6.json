{"sha": "281864aaf759b1c79db80852a4b6f42392c5b2e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgxODY0YWFmNzU5YjFjNzlkYjgwODUyYTRiNmY0MjM5MmM1YjJlNg==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-06-06T17:37:33Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-06-06T17:37:33Z"}, "message": "random: Trivial uglification fixes.\n\n2006-06-06  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/random: Trivial uglification fixes.\n\t* include/tr1/random.tcc: Likewise.\n\n\t* include/tr1/random (subtract_with_carry<>::\n\tsubtract_with_carry(_IntType)): Fix parameter type to unsigned long.\n\t(subtract_with_carry<>::seed(_IntType)): Likewise.\n\t* include/tr1/random.tcc (subtract_with_carry<>::seed(_IntType)):\n\tAdjust.\n\nFrom-SVN: r114440", "tree": {"sha": "829c4c8ad09f048d65c423a6aa1a37dc3abeb422", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/829c4c8ad09f048d65c423a6aa1a37dc3abeb422"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/281864aaf759b1c79db80852a4b6f42392c5b2e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281864aaf759b1c79db80852a4b6f42392c5b2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281864aaf759b1c79db80852a4b6f42392c5b2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281864aaf759b1c79db80852a4b6f42392c5b2e6/comments", "author": null, "committer": null, "parents": [{"sha": "8cf0db2bcd9ed44aebb664815717294b4c9affc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf0db2bcd9ed44aebb664815717294b4c9affc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf0db2bcd9ed44aebb664815717294b4c9affc5"}], "stats": {"total": 727, "additions": 378, "deletions": 349}, "files": [{"sha": "637f4bdeea0d6fb2ce2e7f85fdc533bdb15fccfd", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=281864aaf759b1c79db80852a4b6f42392c5b2e6", "patch": "@@ -1,3 +1,14 @@\n+2006-06-06  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/random: Trivial uglification fixes.\n+\t* include/tr1/random.tcc: Likewise.\n+\n+\t* include/tr1/random (subtract_with_carry<>::\n+\tsubtract_with_carry(_IntType)): Fix parameter type to unsigned long.\n+\t(subtract_with_carry<>::seed(_IntType)): Likewise.\n+\t* include/tr1/random.tcc (subtract_with_carry<>::seed(_IntType)):\n+\tAdjust.\n+\n 2006-06-05  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/random (mersenne_twister<>::seed()): Fix per"}, {"sha": "a018a837064e375990ef96ede01c14a428f69070", "filename": "libstdc++-v3/include/tr1/random", "status": "modified", "additions": 187, "deletions": 182, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom?ref=281864aaf759b1c79db80852a4b6f42392c5b2e6", "patch": "@@ -62,17 +62,17 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    */\n   namespace _Private\n   {\n-    // Type selectors -- are these already implemeted elsewhere?\n+    // Type selectors -- are these already implemented elsewhere?\n     template<bool, typename _TpTrue, typename _TpFalse>\n       struct _Select\n       {\n-\ttypedef _TpTrue Type;\n+\ttypedef _TpTrue _Type;\n       };\n \n     template<typename _TpTrue, typename _TpFalse>\n       struct _Select<false, _TpTrue, _TpFalse>\n       {\n-\ttypedef _TpFalse Type;\n+\ttypedef _TpFalse _Type;\n       };\n \n     /*\n@@ -97,7 +97,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       };\n \n     /*\n-     * Converts a value generated by the adapted random number genereator into a\n+     * Converts a value generated by the adapted random number generator into a\n      * value in the input domain for the dependent random number distribution.\n      *\n      * Because the type traits are compile time constants only the appropriate\n@@ -154,10 +154,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     public:\n       /**\n        * Constructs a variate generator with the uniform random number\n-       * generator @p eng for the random distribution @p d.\n+       * generator @p __eng for the random distribution @p __dist.\n        *\n-       * @throws Any exceptions which may thrown by the copy constructors of the\n-       * @p _Generator or @p _Dist objects.\n+       * @throws Any exceptions which may thrown by the copy constructors of\n+       * the @p _Generator or @p _Dist objects.\n        */\n       variate_generator(engine_type __eng, distribution_type __dist)\n       : _M_engine(__eng), _M_dist(__dist) { }\n@@ -269,66 +269,67 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    * A random number generator that produces pseudorandom numbers using the\n    * linear function @f$x_{i+1}\\leftarrow(ax_{i} + c) \\bmod m @f$.\n    *\n-   * The template parameter @p UIntType must be an unsigned integral type large\n-   * enough to store values up to (m-1). If the template parameter @p m is 0,\n-   * the modulus @p m used is std::numeric_limits<UIntType>::max() plus 1.\n-   * Otherwise, the template parameters @p a and @p c must be less than @p m.\n+   * The template parameter @p _UIntType must be an unsigned integral type\n+   * large enough to store values up to (__m-1). If the template parameter\n+   * @p __m is 0, the modulus @p __m used is\n+   * std::numeric_limits<_UIntType>::max() plus 1. Otherwise, the template\n+   * parameters @p __a and @p __c must be less than @p __m.\n    *\n    * The size of the state is @f$ 1 @f$.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n     class linear_congruential\n     {\n-      __glibcxx_class_requires(UIntType, _UnsignedIntegerConcept)\n-      //  __glibcpp_class_requires(a < m && c < m)\n+      __glibcxx_class_requires(_UIntType, _UnsignedIntegerConcept)\n+      //  __glibcpp_class_requires(__a < __m && __c < __m)\n \n     public:\n       /** The type of the generated random value. */\n-      typedef UIntType result_type;\n+      typedef _UIntType result_type;\n \n       /** The multiplier. */\n-      static const UIntType multiplier = a;\n+      static const _UIntType multiplier = __a;\n       /** An increment. */\n-      static const UIntType increment = c;\n+      static const _UIntType increment = __c;\n       /** The modulus. */\n-      static const UIntType modulus = m;\n+      static const _UIntType modulus = __m;\n \n       /**\n        * Constructs a %linear_congruential random number generator engine with\n-       * seed @p s.  The default seed value is 1.\n+       * seed @p __s.  The default seed value is 1.\n        *\n-       * @param s The initial seed value.\n+       * @param __s The initial seed value.\n        */\n-      explicit linear_congruential(unsigned long s = 1);\n+      explicit linear_congruential(unsigned long __s = 1);\n \n       /**\n        * Constructs a %linear_congruential random number generator engine\n-       * seeded from the generator function @g.\n+       * seeded from the generator function @p __g.\n        *\n-       * @param g The seed generator function.\n+       * @param __g The seed generator function.\n        */\n-      template<class Gen>\n-        linear_congruential(Gen& g);\n+      template<class _Gen>\n+        linear_congruential(_Gen& __g);\n \n       /**\n-       * Resets the %linear_congruential random number generator engine sequence\n-       * to @p.\n+       * Reseeds the %linear_congruential random number generator engine\n+       * sequence to the seed @g __s.\n        *\n-       * @param s The new seed.\n+       * @param __s The new seed.\n        */\n       void\n-      seed(unsigned long s = 1);\n+      seed(unsigned long __s = 1);\n \n       /**\n-       * Resets the %linear_congruential random number generator engine sequence\n-       * using a vlaue from the generator function @g.\n+       * Reseeds the %linear_congruential random number generator engine\n+       * sequence using values from the generator function @p __g.\n        *\n-       * @param g the seed generator function.\n+       * @param __g the seed generator function.\n        */\n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g)\n-        { seed(g, typename is_fundamental<Gen>::type()); }\n+        seed(_Gen& __g)\n+        { seed(__g, typename is_fundamental<_Gen>::type()); }\n \n       /**\n        * Gets the smallest possible value in the output range.\n@@ -352,72 +353,74 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n        * Compares two linear congruential random number generator objects of the\n        * same type for equality.\n        *  \n-       * @param lhs A linear congruential random number generator object.\n-       * @param rhs Another linear congruential random number generator object.\n+       * @param __lhs A linear congruential random number generator object.\n+       * @param __rhs Another linear congruential random number generator obj.\n        *\n        * @returns true if the two objects are equal, false otherwise.\n        */\n       friend bool\n-      operator==(const linear_congruential& lhs, const linear_congruential& rhs)\n-      { return lhs.m_x == rhs.m_x; }\n+      operator==(const linear_congruential& __lhs,\n+\t\t const linear_congruential& __rhs)\n+      { return __lhs._M_x == __rhs._M_x; }\n \n       /**\n        * Compares two linear congruential random number generator objects of the\n        * same type for inequality.\n        *\n-       * @param lhs A linear congruential random number generator object.\n-       * @param rhs Another linear congruential random number generator object.\n+       * @param __lhs A linear congruential random number generator object.\n+       * @param __rhs Another linear congruential random number generator obj.\n        *\n        * @returns true if the two objects are not equal, false otherwise.\n        */\n       friend bool\n-      operator!=(const linear_congruential& lhs, const linear_congruential& rhs)\n-      { return !(lhs == rhs); }\n+      operator!=(const linear_congruential& __lhs,\n+\t\t const linear_congruential& __rhs)\n+      { return !(__lhs == __rhs); }\n \n       /**\n-       * Writes the textual representation of the state x(i) of x to @p os.\n+       * Writes the textual representation of the state x(i) of x to @p __os.\n        *\n-       * @param os  The output stream.\n-       * @param lcr A linear_congruential random number generator.\n-       * @returns os.\n+       * @param __os  The output stream.\n+       * @param __lcr A linear_congruential random number generator.\n+       * @returns __os.\n        */\n-      template<typename CharT, typename Traits>\n-        friend std::basic_ostream<CharT, Traits>&\n-        operator<<(std::basic_ostream<CharT, Traits>& os,\n-\t\t   const linear_congruential& lcr)\n-        { return os << lcr.m_x; }\n+      template<typename _CharT, typename _Traits>\n+        friend std::basic_ostream<_CharT, _Traits>&\n+        operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t\t   const linear_congruential& __lcr)\n+        { return __os << __lcr._M_x; }\n \n       /**\n        * Sets the state of the engine by reading its textual\n-       * representation from @p is.\n+       * representation from @p __is.\n        *\n        * The textual representation must have been previously written using an\n        * output stream whose imbued locale and whose type's template\n-       * specialization arguments CharT and Traits were the same as those of\n-       * @p is.\n+       * specialization arguments _CharT and _Traits were the same as those of\n+       * @p __is.\n        *\n-       * @param is  The input stream.\n-       * @param lcr A linear_congruential random number generator.\n-       * @returns os.\n+       * @param __is  The input stream.\n+       * @param __lcr A linear_congruential random number generator.\n+       * @returns __is.\n        */\n-      template<typename CharT, typename Traits>\n-        friend std::basic_istream<CharT, Traits>&\n-        operator>>(std::basic_istream<CharT, Traits>& is,\n-\t\t   linear_congruential& lcr)\n-        { return is >> lcr.m_x; }\n+      template<typename _CharT, typename _Traits>\n+        friend std::basic_istream<_CharT, _Traits>&\n+        operator>>(std::basic_istream<_CharT, _Traits>& __is,\n+\t\t   linear_congruential& __lcr)\n+        { return __is >> __lcr._M_x; }\n \n     private:\n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, true_type)\n-        { return seed(static_cast<unsigned long>(g)); }\n+        seed(_Gen& __g, true_type)\n+        { return seed(static_cast<unsigned long>(__g)); }\n \n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, false_type);\n+        seed(_Gen& __g, false_type);\n \n     private:\n-      UIntType m_x;\n+      _UIntType _M_x;\n     };\n \n   /**\n@@ -456,52 +459,53 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    * @var output_c    The second left-shift tempering matrix mask.\n    * @var output_l    The second right-shift tempering matrix parameter.\n    */\n-  template<class UIntType, int w, int n, int m, int r,\n-\t   UIntType a, int u, int s, UIntType b, int t, UIntType c, int l>\n+  template<class _UIntType, int __w, int __n, int __m, int __r,\n+\t   _UIntType __a, int __u, int __s, _UIntType __b, int __t,\n+\t   _UIntType __c, int __l>\n     class mersenne_twister\n     {\n-      __glibcxx_class_requires(UIntType, _UnsignedIntegerConcept)\n+      __glibcxx_class_requires(_UIntType, _UnsignedIntegerConcept)\n \n     public:\n       // types\n-      typedef UIntType result_type ;\n+      typedef _UIntType result_type ;\n \n       // parameter values\n-      static const int      word_size   = w;\n-      static const int      state_size  = n;\n-      static const int      shift_size  = m;\n-      static const int      mask_bits   = r;\n-      static const UIntType parameter_a = a;\n-      static const int      output_u    = u;\n-      static const int      output_s    = s;\n-      static const UIntType output_b    = b;\n-      static const int      output_t    = t;\n-      static const UIntType output_c    = c;\n-      static const int      output_l    = l;\n+      static const int       word_size   = __w;\n+      static const int       state_size  = __n;\n+      static const int       shift_size  = __m;\n+      static const int       mask_bits   = __r;\n+      static const _UIntType parameter_a = __a;\n+      static const int       output_u    = __u;\n+      static const int       output_s    = __s;\n+      static const _UIntType output_b    = __b;\n+      static const int       output_t    = __t;\n+      static const _UIntType output_c    = __c;\n+      static const int       output_l    = __l;\n \n       // constructors and member function\n       mersenne_twister()\n       { seed(); }\n \n       explicit\n-      mersenne_twister(unsigned long value)\n-      { seed(value); }\n+      mersenne_twister(unsigned long __value)\n+      { seed(__value); }\n \n-      template<class Gen>\n-        mersenne_twister(Gen& g)\n-        { seed(g); }\n+      template<class _Gen>\n+        mersenne_twister(_Gen& __g)\n+        { seed(__g); }\n \n       void\n       seed()\n       { seed(5489UL); }\n \n       void\n-      seed(unsigned long value);\n+      seed(unsigned long __value);\n \n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g)\n-        { seed(g, typename is_fundamental<Gen>::type()); }\n+        seed(_Gen& __g)\n+        { seed(__g, typename is_fundamental<_Gen>::type()); }\n \n       result_type\n       min() const\n@@ -514,18 +518,18 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       operator()();\n \n     private:\n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, true_type)\n-        { return seed(static_cast<unsigned long>(g)); }\n+        seed(_Gen& __g, true_type)\n+        { return seed(static_cast<unsigned long>(__g)); }\n \n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, false_type);\n+        seed(_Gen& __g, false_type);\n \n     private:\n-      UIntType _M_x[state_size];\n-      int      _M_p;\n+      _UIntType _M_x[state_size];\n+      int       _M_p;\n     };\n \n   /**\n@@ -565,7 +569,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    * @var _M_p     Current index of x(i - r).\n    * @endif\n    */\n-  template<typename _IntType, _IntType m, int s, int r>\n+  template<typename _IntType, _IntType __m, int __s, int __r>\n     class subtract_with_carry\n     {\n       __glibcxx_class_requires(_IntType, _IntegerConcept)\n@@ -575,9 +579,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typedef _IntType result_type;\n       \n       // parameter values\n-      static const _IntType modulus   = m;\n-      static const int      long_lag  = r;\n-      static const int      short_lag = s;\n+      static const _IntType modulus   = __m;\n+      static const int      long_lag  = __r;\n+      static const int      short_lag = __s;\n \n     public:\n       /**\n@@ -592,16 +596,16 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n        * generator.\n        */\n       explicit\n-      subtract_with_carry(_IntType __value)\n+      subtract_with_carry(unsigned long __value)\n       { this->seed(__value); }\n \n       /**\n        * Constructs a % subtract_with_carry random number generator seeded from\n        * the PAD iterated by [__first, last).\n        */\n-      template<class Gen>\n-        subtract_with_carry(Gen& g)\n-        { this->seed(g); }\n+      template<class _Gen>\n+        subtract_with_carry(_Gen& __g)\n+        { this->seed(__g); }\n \n       /**\n        * Seeds the initial state @f$ x_0 @f$ of the random number generator.\n@@ -619,16 +623,16 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n        * If @f$ x_{-1} = 0 @f$ set carry to 1, otherwise sets carry to 0.\n        */\n       void\n-      seed(_IntType __value = 19780503);\n+      seed(unsigned long __value = 19780503);\n \n       /**\n        * Seeds the initial state @f$ x_0 @f$ of the % subtract_with_carry\n        * random number generator.\n        */\n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g)\n-        { seed(g, typename is_fundamental<Gen>::type()); }\n+        seed(_Gen& __g)\n+        { seed(__g, typename is_fundamental<_Gen>::type()); }\n \n       /**\n        * Gets the inclusive minimum value of the range of random integers\n@@ -667,7 +671,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t const subtract_with_carry& __rhs)\n       { \n \treturn ((__lhs._M_x[0] == __rhs._M_x[0])\n-\t\t&& (__lhs._M_x[r-1] == __rhs._M_x[r-1]));\n+\t\t&& (__lhs._M_x[__r - 1] == __rhs._M_x[__r - 1]));\n       }\n \n       /**\n@@ -687,7 +691,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts the current state of a % subtract_with_carry random number\n-       * genator engine @p x into the output stream @p os.\n+       * genator engine @p x into the output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A % subtract_with_carry random number generator engine.\n@@ -700,14 +704,14 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n         operator<<(basic_ostream<_CharT, _Traits>& __os,\n \t\t   const subtract_with_carry& __x)\n         {\n-\t  std::copy(__x._M_x, __x._M_x + r,\n+\t  std::copy(__x._M_x, __x._M_x + __r,\n \t\t    std::ostream_iterator<_IntType>(__os, \" \"));\n \t  return __os << __x._M_carry;\n \t}\n \n       /**\n        * Extracts the current state of a % subtract_with_carry random number\n-       * gerator engine @p x from the input stream @p is.\n+       * gerator engine @p x from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __x  A % subtract_with_carry random number generator engine.\n@@ -720,21 +724,21 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n         operator>>(basic_istream<_CharT, _Traits>& __is,\n \t\t   subtract_with_carry& __x)\n         {\n-\t  for (int __i = 0; __i < r; ++__i)\n+\t  for (int __i = 0; __i < __r; ++__i)\n \t    __is >> __x._M_x[__i];\n \t  __is >> __x._M_carry;\n \t  return __is;\n \t}\n \n     private:\n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, true_type)\n-        { return seed(static_cast<unsigned long>(g)); }\n+        seed(_Gen& __g, true_type)\n+        { return seed(static_cast<unsigned long>(__g)); }\n \n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g, false_type);\n+        seed(_Gen& __g, false_type);\n \n     private:\n       int         _M_p;\n@@ -747,23 +751,23 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    * Produces random numbers from some base engine by discarding blocks of\n    * data.\n    *\n-   * 0 <= @p r <= @p p\n+   * 0 <= @p __r <= @p __p\n    */\n-  template<class UniformRandomNumberGenerator, int p, int r>\n+  template<class _UniformRandomNumberGenerator, int __p, int __r>\n     class discard_block\n     {\n       // __glibcxx_class_requires(typename base_type::result_type,\n       //                          ArithmeticTypeConcept);\n \n     public:\n       /** The type of the underlying generator engine. */\n-      typedef UniformRandomNumberGenerator    base_type;\n+      typedef _UniformRandomNumberGenerator   base_type;\n       /** The type of the generated random value. */\n       typedef typename base_type::result_type result_type;\n \n       // parameter values\n-      static const int block_size = p;\n-      static const int used_block = r;\n+      static const int block_size = __p;\n+      static const int used_block = __r;\n \n       /**\n        * Constructs a default %discard_block engine.\n@@ -779,26 +783,26 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n        * Copies an existing base class random number geenerator.\n        * @param rng An existing (base class) engine object.\n        */\n-      explicit discard_block(const base_type& rng)\n-      : _M_b(rng) , _M_n(0) { }\n+      explicit discard_block(const base_type& __rng)\n+      : _M_b(__rng) , _M_n(0) { }\n \n       /**\n        * Seed constructs a %discard_block engine.\n        *\n-       * Constructs the underlying generator engine seeded with @p s.\n-       * @param s A seed value for the base class engine.\n+       * Constructs the underlying generator engine seeded with @p __s.\n+       * @param __s A seed value for the base class engine.\n        */\n-      explicit discard_block(unsigned long s)\n-      : _M_b(s), _M_n(0) { }\n+      explicit discard_block(unsigned long __s)\n+      : _M_b(__s), _M_n(0) { }\n \n       /**\n        * Generator constructs a %discard_block engine.\n        *\n-       * @param g A seed generator function.\n+       * @param __g A seed generator function.\n        */\n-      template<class Gen>\n-        discard_block(Gen& g)\n-\t: _M_b(g), _M_n(0) { }\n+      template<class _Gen>\n+        discard_block(_Gen& __g)\n+\t: _M_b(__g), _M_n(0) { }\n \n       /**\n        * Reseeds the %discard_block object with the default seed for the\n@@ -813,12 +817,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       /**\n        * Reseeds the %discard_block object with the given seed generator\n        * function.\n-       * @param g A seed generator function.\n+       * @param __g A seed generator function.\n        */\n-      template<class Gen>\n-        void seed(Gen& g)\n+      template<class _Gen>\n+        void seed(_Gen& __g)\n         {\n-\t  _M_b.seed(g);\n+\t  _M_b.seed(__g);\n \t  _M_n = 0;\n \t}\n \n@@ -882,7 +886,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts the current state of a %discard_block random number\n-       * genator engine @p x into the output stream @p os.\n+       * genator engine @p x into the output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A %discard_block random number generator engine.\n@@ -898,7 +902,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts the current state of a % subtract_with_carry random number\n-       * gerator engine @p x from the input stream @p is.\n+       * gerator engine @p x from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __x  A %discard_block random number generator engine.\n@@ -941,43 +945,43 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n    * A random number generator adaptor class that combines two random number\n    * generator engines into a single output sequence.\n    */\n-  template<class UniformRandomNumberGenerator1, int s1,\n-\t   class UniformRandomNumberGenerator2, int s2>\n+  template<class _UniformRandomNumberGenerator1, int __s1,\n+\t   class _UniformRandomNumberGenerator2, int __s2>\n     class xor_combine\n     {\n-      // __glibcxx_class_requires(typename UniformRandomNumberGenerator1::\n+      // __glibcxx_class_requires(typename _UniformRandomNumberGenerator1::\n       //                          result_type, ArithmeticTypeConcept);\n-      // __glibcxx_class_requires(typename UniformRandomNumberGenerator2::\n+      // __glibcxx_class_requires(typename _UniformRandomNumberGenerator2::\n       //                          result_type, ArithmeticTypeConcept);\n \n     public:\n       /** The type of the the first underlying generator engine. */\n-      typedef UniformRandomNumberGenerator1 base1_type;\n+      typedef _UniformRandomNumberGenerator1 base1_type;\n       /** The type of the the second underlying generator engine. */\n-      typedef UniformRandomNumberGenerator2 base2_type;\n+      typedef _UniformRandomNumberGenerator2 base2_type;\n       /** The type of the generated random value. */\n       typedef typename _Private::_Select<\n \t(sizeof(base1_type) > sizeof(base2_type)),\n \tbase1_type,\n \tbase2_type\n-\t>::Type result_type;\n+\t>::_Type result_type;\n \n       // parameter values\n-      static const int shift1 = s1;\n-      static const int shift2 = s2;\n+      static const int shift1 = __s1;\n+      static const int shift2 = __s2;\n \n       // constructors and member function\n       xor_combine() { }\n \n-      xor_combine(const base1_type& rng1, const base2_type& rng2)\n-      : _M_b1(rng1), _M_b2(rng2) { }\n+      xor_combine(const base1_type& __rng1, const base2_type& __rng2)\n+      : _M_b1(__rng1), _M_b2(__rng2) { }\n \n-      xor_combine(unsigned long s)\n-      : _M_b1(s), _M_b2(s + 1) { }\n+      xor_combine(unsigned long __s)\n+      : _M_b1(__s), _M_b2(__s + 1) { }\n \n-      template<class Gen>\n-        xor_combine(Gen& g)\n-\t: _M_b1(g), _M_b2(g) { }\n+      template<class _Gen>\n+        xor_combine(_Gen& __g)\n+\t: _M_b1(__g), _M_b2(__g) { }\n \n       void\n       seed()\n@@ -986,12 +990,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t_M_b2.seed();\n       }\n \n-      template<class Gen>\n+      template<class _Gen>\n         void\n-        seed(Gen& g)\n+        seed(_Gen& __g)\n         {\n-\t  _M_b1.seed(g);\n-\t  _M_b2.seed(g);\n+\t  _M_b1.seed(__g);\n+\t  _M_b2.seed(__g);\n \t}\n \n       const base1_type&\n@@ -1050,7 +1054,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts the current state of a %xor_combine random number\n-       * genator engine @p x into the output stream @p os.\n+       * genator engine @p x into the output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A %xor_combine random number generator engine.\n@@ -1066,7 +1070,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts the current state of a %xor_combine random number\n-       * gerator engine @p x from the input stream @p is.\n+       * gerator engine @p x from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __x  A %xor_combine random number generator engine.\n@@ -1101,15 +1105,15 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     typedef unsigned int result_type;\n     \n     // constructors, destructors and member functions\n-    explicit random_device(const std::string& token = \"unimplemented\");\n+    explicit random_device(const std::string& __token = \"unimplemented\");\n     result_type min() const;\n     result_type max() const;\n     double entropy() const;\n     result_type operator()();\n \n   private:\n-    random_device(const random_device &);\n-    void operator=(const random_device &);\n+    random_device(const random_device&);\n+    void operator=(const random_device&);\n   };\n \n   /* @} */ // group tr1_random_generators\n@@ -1212,7 +1216,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts a %unform_int random number distribution\n-       * @p u from the input stream @p is.\n+       * @p u from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __u  A %uniform_int random number generator engine.\n@@ -1246,7 +1250,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     /**\n      * Constructs a Bernoulli distribution with likelihood @p p.\n      *\n-     * @param p  [IN]  The likelihood of a true result being returned.  Must\n+     * @param __p  [IN]  The likelihood of a true result being returned.  Must\n      * be in the interval @f$ [0, 1] @f$.\n      */\n     explicit\n@@ -1299,7 +1303,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     /**\n      * Inserts a %bernoulli_distribution random number distribution\n-     * @p x into the output stream @p os.\n+     * @p x into the output stream @p __os.\n      *\n      * @param __os An output stream.\n      * @param __x  A %bernoulli_distribution random number distribution.\n@@ -1315,7 +1319,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n     /**\n      * Extracts a %bernoulli_distribution random number distribution\n-     * @p u from the input stream @p is.\n+     * @p u from the input stream @p __is.\n      *\n      * @param __is An input stream.\n      * @param __u  A %bernoulli_distribution random number generator engine.\n@@ -1358,7 +1362,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       }\n \n       /**\n-       * Gets the distribution parameter @p.\n+       * Gets the distribution parameter @p p.\n        */\n       _RealType\n       p() const\n@@ -1389,7 +1393,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts a %geometric_distribution random number distribution\n-       * @p x into the output stream @p os.\n+       * @p x into the output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A %geometric_distribution random number distribution.\n@@ -1405,7 +1409,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts a %geometric_distribution random number distribution\n-       * @p u from the input stream @p is.\n+       * @p u from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __u  A %geometric_distribution random number generator engine.\n@@ -1454,11 +1458,12 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       /**\n        * Constructs a uniform_real object.\n        *\n-       * @param min [IN]  The lower bound of the distribution.\n-       * @param max [IN]  The upper bound of the distribution.\n+       * @param __min [IN]  The lower bound of the distribution.\n+       * @param __max [IN]  The upper bound of the distribution.\n        */\n       explicit\n-      uniform_real(_RealType min = _RealType(0), _RealType max = _RealType(1));\n+      uniform_real(_RealType __min = _RealType(0),\n+\t\t   _RealType __max = _RealType(1));\n \n       result_type\n       min() const;\n@@ -1475,7 +1480,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts a %uniform_real random number distribution @p x into the\n-       * output stream @p os.\n+       * output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A %uniform_real random number distribution.\n@@ -1491,7 +1496,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts a %unform_real random number distribution\n-       * @p u from the input stream @p is.\n+       * @p u from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __u  A %uniform_real random number generator engine.\n@@ -1564,7 +1569,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Inserts a %exponential_distribution random number distribution\n-       * @p x into the output stream @p os.\n+       * @p x into the output stream @p __os.\n        *\n        * @param __os An output stream.\n        * @param __x  A %exponential_distribution random number distribution.\n@@ -1580,7 +1585,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       /**\n        * Extracts a %exponential_distribution random number distribution\n-       * @p u from the input stream @p is.\n+       * @p u from the input stream @p __is.\n        *\n        * @param __is An input stream.\n        * @param __u  A %exponential_distribution random number generator engine."}, {"sha": "57b071a585a6a66586715a2b11434b2b0c491952", "filename": "libstdc++-v3/include/tr1/random.tcc", "status": "modified", "additions": 180, "deletions": 167, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/281864aaf759b1c79db80852a4b6f42392c5b2e6/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Frandom.tcc?ref=281864aaf759b1c79db80852a4b6f42392c5b2e6", "patch": "@@ -46,283 +46,295 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     //\n     // Preconditions:  a > 0, m > 0.\n     //\n-    template<typename _Tp, _Tp a, _Tp c, _Tp m, bool _m_is_zero>\n-      struct Mod\n+    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m, bool>\n+      struct _Mod\n       {\n \tstatic _Tp\n-\tcalc(_Tp x)\n+\t__calc(_Tp __x)\n \t{\n-\t  if (a == 1)\n-\t    x %= m;\n+\t  if (__a == 1)\n+\t    __x %= __m;\n \t  else\n \t    {\n-\t      static const _Tp q = m / a;\n-\t      static const _Tp r = m % a;\n+\t      static const _Tp __q = __m / __a;\n+\t      static const _Tp __r = __m % __a;\n \t      \n-\t      _Tp t1 = a * (x % q);\n-\t      _Tp t2 = r * (x / q);\n-\t      if (t1 >= t2)\n-\t\tx = t1 - t2;\n+\t      _Tp __t1 = __a * (__x % __q);\n+\t      _Tp __t2 = __r * (__x / __q);\n+\t      if (__t1 >= __t2)\n+\t\t__x = __t1 - __t2;\n \t      else\n-\t\tx = m - t2 + t1;\n+\t\t__x = __m - __t2 + __t1;\n \t    }\n \n-\t  if (c != 0)\n+\t  if (__c != 0)\n \t    {\n-\t      const _Tp d = m - x;\n-\t      if (d > c)\n-\t\tx += c;\n+\t      const _Tp __d = __m - __x;\n+\t      if (__d > __c)\n+\t\t__x += __c;\n \t      else\n-\t\tx = c - d;\n+\t\t__x = __c - __d;\n \t    }\n-\t  return x;\n+\t  return __x;\n \t}\n       };\n \n-    // Special case for m==0 -- use unsigned integer overflow as modulo\n+    // Special case for m == 0 -- use unsigned integer overflow as modulo\n     // operator.\n-    template<typename _Tp, _Tp a, _Tp c, _Tp m>\n-      struct Mod<_Tp, a, c, m, true>\n+    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m>\n+      struct _Mod<_Tp, __a, __c, __m, true>\n       {\n \tstatic _Tp\n-\tcalc(_Tp x)\n-\t{ return a * x + c; }\n+\t__calc(_Tp __x)\n+\t{ return __a * __x + __c; }\n       };\n \n     // Dispatch based on modulus value to prevent divide-by-zero compile-time\n     // errors when m == 0.\n-    template<typename _Tp, _Tp a, _Tp c, _Tp m>\n+    template<typename _Tp, _Tp __a, _Tp __c, _Tp __m>\n       inline _Tp\n-      mod(_Tp x)\n-      { return Mod<_Tp, a, c, m, m == 0>::calc(x); }\n+      __mod(_Tp __x)\n+      { return _Mod<_Tp, __a, __c, __m, __m == 0>::__calc(__x); }\n \n-    // Like the above, for a==1, c==0, in terms of w.\n-    template<typename _Tp, _Tp w, bool>\n-      struct Mod_w\n+    // Like the above, for a == 1, c == 0, in terms of w.\n+    template<typename _Tp, _Tp __w, bool>\n+      struct _Mod_w\n       {\n \tstatic _Tp\n-\tcalc(_Tp x)\n-\t{ return x % (_Tp(1) << w); }\n+\t__calc(_Tp __x)\n+\t{ return __x % (_Tp(1) << __w); }\n       };\n \n-    template<typename _Tp, _Tp w>\n-      struct Mod_w<_Tp, w, true>\n+    template<typename _Tp, _Tp __w>\n+      struct _Mod_w<_Tp, __w, true>\n       {\n \tstatic _Tp\n-\tcalc(_Tp x)\n-\t{ return x; }\n+\t__calc(_Tp __x)\n+\t{ return __x; }\n       };\n \n-    template<typename _Tp, _Tp w>\n+    template<typename _Tp, _Tp __w>\n       inline _Tp\n-      mod_w(_Tp x)\n-      { return Mod_w<_Tp, w, w == std::numeric_limits<_Tp>::digits>::calc(x); }\n+      __mod_w(_Tp __x)\n+      { return _Mod_w<_Tp, __w,\n+\t              __w == std::numeric_limits<_Tp>::digits>::__calc(__x); }\n \n     // Selector to return the maximum value possible that will fit in \n-    // @p w bits of @p _Tp.\n-    template<typename _Tp, _Tp w, bool>\n-      struct Max_w\n+    // @p __w bits of @p _Tp.\n+    template<typename _Tp, _Tp __w, bool>\n+      struct _Max_w\n       {\n \tstatic _Tp\n-\tvalue()\n-\t{ return (_Tp(1) << w) - 1; }\n+\t__value()\n+\t{ return (_Tp(1) << __w) - 1; }\n       };\n \n-    template<typename _Tp, _Tp w>\n-      struct Max_w<_Tp, w, true>\n+    template<typename _Tp, _Tp __w>\n+      struct _Max_w<_Tp, __w, true>\n       {\n \tstatic _Tp\n-\tvalue()\n+\t__value()\n \t{ return std::numeric_limits<_Tp>::max(); }\n       };\n \n   } // namespace _Private\n \n \n   /**\n-   * Constructs the LCR engine with integral seed @p x0.\n+   * Constructs the LCR engine with integral seed @p __x0.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    linear_congruential<UIntType, a, c, m>::\n-    linear_congruential(unsigned long x0)\n-    { this->seed(x0); }\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    linear_congruential<_UIntType, __a, __c, __m>::\n+    linear_congruential(unsigned long __x0)\n+    { this->seed(__x0); }\n \n   /**\n-   * Constructs the LCR engine with seed generated from @p g.\n+   * Constructs the LCR engine with seed generated from @p __g.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    template<class Gen>\n-      linear_congruential<UIntType, a, c, m>::\n-      linear_congruential(Gen& g)\n-      { this->seed(g); }\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    template<class _Gen>\n+      linear_congruential<_UIntType, __a, __c, __m>::\n+      linear_congruential(_Gen& __g)\n+      { this->seed(__g); }\n \n   /**\n-   * Seeds the LCR with integral value @p x0, adjusted so that the \n+   * Seeds the LCR with integral value @p __x0, adjusted so that the \n    * ring identity is never a member of the convergence set.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n     void\n-    linear_congruential<UIntType, a, c, m>::\n-    seed(unsigned long x0)\n+    linear_congruential<_UIntType, __a, __c, __m>::\n+    seed(unsigned long __x0)\n     {\n-      if ((_Private::mod<UIntType, 1, 0, m>(c) == 0)\n-\t  && (_Private::mod<UIntType, 1, 0, m>(x0) == 0))\n-\tm_x = _Private::mod<UIntType, 1, 0, m>(1);\n+      if ((_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0)\n+\t  && (_Private::__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n+\t_M_x = _Private::__mod<_UIntType, 1, 0, __m>(1);\n       else\n-\tm_x = _Private::mod<UIntType, 1, 0, m>(x0);\n+\t_M_x = _Private::__mod<_UIntType, 1, 0, __m>(__x0);\n     }\n \n   /**\n-   * Seeds the LCR engine with a value generated by @p g.\n+   * Seeds the LCR engine with a value generated by @p __g.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    template<class Gen>\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    template<class _Gen>\n       void\n-      linear_congruential<UIntType, a, c, m>::\n-      seed(Gen& g, false_type)\n+      linear_congruential<_UIntType, __a, __c, __m>::\n+      seed(_Gen& __g, false_type)\n       {\n-\tUIntType x0 = g();\n-\tif ((_Private::mod<UIntType, 1, 0, m>(c) == 0)\n-\t    && (_Private::mod<UIntType, 1, 0, m>(x0) == 0))\n-\t  m_x = _Private::mod<UIntType, 1, 0, m>(1);\n+\t_UIntType __x0 = __g();\n+\tif ((_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0)\n+\t    && (_Private::__mod<_UIntType, 1, 0, __m>(__x0) == 0))\n+\t  _M_x = _Private::__mod<_UIntType, 1, 0, __m>(1);\n \telse\n-\t  m_x = _Private::mod<UIntType, 1, 0, m>(x0);\n+\t  _M_x = _Private::__mod<_UIntType, 1, 0, __m>(__x0);\n       }\n \n   /**\n    * Returns a value that is less than or equal to all values potentially\n    * returned by operator(). The return value of this function does not\n    * change during the lifetime of the object..\n    *\n-   * The minumum depends on the @p c parameter: if it is zero, the\n+   * The minumum depends on the @p __c parameter: if it is zero, the\n    * minimum generated must be > 0, otherwise 0 is allowed.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    typename linear_congruential<UIntType, a, c, m>::result_type\n-    linear_congruential<UIntType, a, c, m>::\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n+    linear_congruential<_UIntType, __a, __c, __m>::\n     min() const\n-    { return (_Private::mod<UIntType, 1, 0, m>(c) == 0) ? 1 : 0; }\n+    { return (_Private::__mod<_UIntType, 1, 0, __m>(__c) == 0) ? 1 : 0; }\n \n   /**\n    * Gets the maximum possible value of the generated range.\n    *\n-   * For a linear congruential generator, the maximum is always @p m - 1.\n+   * For a linear congruential generator, the maximum is always @p __m - 1.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    typename linear_congruential<UIntType, a, c, m>::result_type\n-    linear_congruential<UIntType, a, c, m>::\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n+    linear_congruential<_UIntType, __a, __c, __m>::\n     max() const\n-    { return (m == 0) ? std::numeric_limits<UIntType>::max() : (m - 1); }\n+    { return (__m == 0) ? std::numeric_limits<_UIntType>::max() : (__m - 1); }\n \n   /**\n    * Gets the next generated value in sequence.\n    */\n-  template<class UIntType, UIntType a, UIntType c, UIntType m>\n-    typename linear_congruential<UIntType, a, c, m>::result_type\n-    linear_congruential<UIntType, a, c, m>::\n+  template<class _UIntType, _UIntType __a, _UIntType __c, _UIntType __m>\n+    typename linear_congruential<_UIntType, __a, __c, __m>::result_type\n+    linear_congruential<_UIntType, __a, __c, __m>::\n     operator()()\n     {\n-      m_x = _Private::mod<UIntType, a, c, m>(m_x);\n-      return m_x;\n+      _M_x = _Private::__mod<_UIntType, __a, __c, __m>(_M_x);\n+      return _M_x;\n     }\n \n \n-  template<class _UInt, int w, int n, int m, int r,\n-\t   _UInt a, int u, int s,\n-\t   _UInt b, int t, _UInt c, int l>\n+  template<class _UIntType, int __w, int __n, int __m, int __r,\n+\t   _UIntType __a, int __u, int __s,\n+\t   _UIntType __b, int __t, _UIntType __c, int __l>\n     void\n-    mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::\n-    seed(unsigned long value)\n+    mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t     __b, __t, __c, __l>::\n+    seed(unsigned long __value)\n     {\n-      _M_x[0] = _Private::mod_w<_UInt, w>(value);\n+      _M_x[0] = _Private::__mod_w<_UIntType, __w>(__value);\n \n-      for (int i = 1; i < n; ++i)\n+      for (int __i = 1; __i < state_size; ++__i)\n \t{\n-\t  _UInt x = _M_x[i - 1];\n-\t  x ^= x >> (w - 2);\n-\t  x *= 1812433253ul;\n-\t  x += i;\n-\t  _M_x[i] = _Private::mod_w<_UInt, w>(x);\t  \n+\t  _UIntType __x = _M_x[__i - 1];\n+\t  __x ^= __x >> (__w - 2);\n+\t  __x *= 1812433253ul;\n+\t  __x += __i;\n+\t  _M_x[__i] = _Private::__mod_w<_UIntType, __w>(__x);\t  \n \t}\n-      _M_p = n;\n+      _M_p = state_size;\n     }\n \n-  template<class _UInt, int w, int n, int m, int r,\n-\t   _UInt a, int u, int s,\n-\t   _UInt b, int t, _UInt c, int l>\n-    template<class Gen>\n+  template<class _UIntType, int __w, int __n, int __m, int __r,\n+\t   _UIntType __a, int __u, int __s,\n+\t   _UIntType __b, int __t, _UIntType __c, int __l>\n+    template<class _Gen>\n       void\n-      mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::\n-      seed(Gen& gen, false_type)\n+      mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t       __b, __t, __c, __l>::\n+      seed(_Gen& __gen, false_type)\n       {\n-\tfor (int i = 0; i < n; ++i)\n-\t  _M_x[i] = _Private::mod_w<_UInt, w>(gen());\n-\t_M_p = n;\n+\tfor (int __i = 0; __i < state_size; ++__i)\n+\t  _M_x[__i] = _Private::__mod_w<_UIntType, __w>(__gen());\n+\t_M_p = state_size;\n       }\n \n-  template<class _UInt, int w, int n, int m, int r,\n-\t   _UInt a, int u, int s,\n-\t   _UInt b, int t, _UInt c, int l>\n+  template<class _UIntType, int __w, int __n, int __m, int __r,\n+\t   _UIntType __a, int __u, int __s,\n+\t   _UIntType __b, int __t, _UIntType __c, int __l>\n     typename\n-    mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::result_type\n-    mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::\n+    mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t     __b, __t, __c, __l>::result_type\n+    mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t     __b, __t, __c, __l>::\n     max() const\n     {\n-      using _Private::Max_w;\n+      using _Private::_Max_w;\n       using std::numeric_limits;\n-      return Max_w<_UInt, w, w == numeric_limits<_UInt>::digits>::value();\n+      return _Max_w<_UIntType, __w,\n+\t            __w == numeric_limits<_UIntType>::digits>::__value();\n     }\n \n-  template<class _UInt, int w, int n, int m, int r,\n-\t   _UInt a, int u, int s,\n-\t   _UInt b, int t, _UInt c, int l>\n+  template<class _UIntType, int __w, int __n, int __m, int __r,\n+\t   _UIntType __a, int __u, int __s,\n+\t   _UIntType __b, int __t, _UIntType __c, int __l>\n     typename\n-    mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::result_type\n-    mersenne_twister<_UInt, w, n, m, r, a, u, s, b, t, c, l>::\n+    mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t     __b, __t, __c, __l>::result_type\n+    mersenne_twister<_UIntType, __w, __n, __m, __r, __a, __u, __s,\n+\t\t     __b, __t, __c, __l>::\n     operator()()\n     {\n       // Reload the vector - cost is O(n) amortized over n calls.\n-      if (_M_p >= n)\n+      if (_M_p >= state_size)\n \t{\n-\t  const _UInt upper_mask = (~_UInt()) << r;\n-\t  const _UInt lower_mask = ~upper_mask;\n+\t  const _UIntType __upper_mask = (~_UIntType()) << __r;\n+\t  const _UIntType __lower_mask = ~__upper_mask;\n \n-\t  for (int k = 0; k < (n - m); ++k)\n+\t  for (int __k = 0; __k < (__n - __m); ++__k)\n \t    {\n-\t      _UInt y = (_M_x[k] & upper_mask) | (_M_x[k + 1] & lower_mask);\n-\t      _M_x[k] = _M_x[k + m] ^ (y >> 1) ^ ((y & 0x01) ? a : 0);\n+\t      _UIntType __y = ((_M_x[__k] & __upper_mask)\n+\t\t\t       |(_M_x[__k + 1] & __lower_mask));\n+\t      _M_x[__k] = (_M_x[__k + __m] ^ (__y >> 1)\n+\t\t\t   ^ ((__y & 0x01) ? __a : 0));\n \t    }\n \n-\t  for (int k = (n - m); k < (n - 1); ++k)\n+\t  for (int __k = (__n - __m); __k < (__n - 1); ++__k)\n \t    {\n-\t      _UInt y = (_M_x[k] & upper_mask) | (_M_x[k + 1] & lower_mask);\n-\t      _M_x[k] = _M_x[k + (m - n)] ^ (y >> 1) ^ ((y & 0x01) ? a : 0);\n+\t      _UIntType __y = ((_M_x[__k] & __upper_mask)\n+\t\t\t       | (_M_x[__k + 1] & __lower_mask));\n+\t      _M_x[__k] = (_M_x[__k + (__m - __n)] ^ (__y >> 1)\n+\t\t\t   ^ ((__y & 0x01) ? __a : 0));\n \t    }\n \n \t  _M_p = 0;\n \t}\n \n       // Calculate o(x(i)).\n-      result_type z = _M_x[_M_p++];\n-      z ^= (z >> u);\n-      z ^= (z << s) & b;\n-      z ^= (z << t) & c;\n-      z ^= (z >> l);\n+      result_type __z = _M_x[_M_p++];\n+      __z ^= (__z >> __u);\n+      __z ^= (__z << __s) & __b;\n+      __z ^= (__z << __t) & __c;\n+      __z ^= (__z >> __l);\n \n-      return z;\n+      return __z;\n     }\n \n \n-  template<typename _IntType, _IntType m, int s, int r>\n+  template<typename _IntType, _IntType __m, int __s, int __r>\n     void\n-    subtract_with_carry<_IntType, m, s, r>::\n-    seed(_IntType __value)\n+    subtract_with_carry<_IntType, __m, __s, __r>::\n+    seed(unsigned long __value)\n     {\n       std::tr1::linear_congruential<unsigned long, 40014, 0, 2147483563>\n-\tlcg(__value);\n+\t__lcg(__value);\n \n-      for (int i = 0; i < long_lag; ++i)\n-\t_M_x[i] = _Private::mod<_IntType, 1, 0, modulus>(lcg());\n+      for (int __i = 0; __i < long_lag; ++__i)\n+\t_M_x[__i] = _Private::__mod<_IntType, 1, 0, modulus>(__lcg());\n \n       _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;\n       _M_p = 0;\n@@ -337,22 +349,22 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n   // center.\n   //\n   template<typename _IntType, _IntType __m, int __s, int __r>\n-    template<class Gen>\n+    template<class _Gen>\n     void\n     subtract_with_carry<_IntType, __m, __s, __r>::\n-    seed(Gen& gen, false_type)\n+    seed(_Gen& __gen, false_type)\n     {\n-      const int n = (std::numeric_limits<_IntType>::digits + 31) / 32;\n-      for (int i = 0; i < long_lag; ++i)\n+      const int __n = (std::numeric_limits<_IntType>::digits + 31) / 32;\n+      for (int __i = 0; __i < long_lag; ++__i)\n \t{\n-\t  _M_x[i] = 0;\n-\t  unsigned long factor = 1;\n-\t  for (int j = 0; j < n; ++j)\n+\t  _M_x[__i] = 0;\n+\t  unsigned long __factor = 1;\n+\t  for (int __j = 0; __j < __n; ++__j)\n \t    {\n-\t      _M_x[i] += gen() * factor;\n-\t      factor *= 0x80000000;\n+\t      _M_x[__i] += __gen() * __factor;\n+\t      __factor *= 0x80000000;\n \t    }\n-\t  _M_x[i] = _Private::mod<_IntType, 1, 0, modulus>(_M_x[i]);\n+\t  _M_x[__i] = _Private::__mod<_IntType, 1, 0, modulus>(_M_x[__i]);\n \t}\n       _M_carry = (_M_x[long_lag - 1] == 0) ? 1 : 0;\n       _M_p = 0;\n@@ -364,35 +376,36 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     operator()()\n     {\n       // Derive short lag index from current index.\n-      int ps = _M_p - short_lag;\n-      if (ps < 0)\n-\tps += long_lag;\n+      int __ps = _M_p - short_lag;\n+      if (__ps < 0)\n+\t__ps += long_lag;\n \n       // Calculate new x(i) without overflow or division.\n-      _IntType xi;\n-      if (_M_x[ps] >= _M_x[_M_p] + _M_carry)\n+      _IntType __xi;\n+      if (_M_x[__ps] >= _M_x[_M_p] + _M_carry)\n \t{\n-\t  xi = _M_x[ps] - _M_x[_M_p] - _M_carry;\n+\t  __xi = _M_x[__ps] - _M_x[_M_p] - _M_carry;\n \t  _M_carry = 0;\n \t}\n       else\n \t{\n-\t  xi = modulus - _M_x[_M_p] - _M_carry + _M_x[ps];\n+\t  __xi = modulus - _M_x[_M_p] - _M_carry + _M_x[__ps];\n \t  _M_carry = 1;\n \t}\n-      _M_x[_M_p++] = xi;\n+      _M_x[_M_p++] = __xi;\n \n       // Adjust current index to loop around in ring buffer.\n       if (_M_p >= long_lag)\n \t_M_p = 0;\n \n-      return xi;\n+      return __xi;\n     }\n \n \n-  template<class _E, int __p, int __r>\n-    typename discard_block<_E, __p, __r>::result_type\n-    discard_block<_E, __p, __r>::\n+  template<class _UniformRandomNumberGenerator, int __p, int __r>\n+    typename discard_block<_UniformRandomNumberGenerator,\n+\t\t\t   __p, __r>::result_type\n+    discard_block<_UniformRandomNumberGenerator, __p, __r>::\n     operator()()\n     {\n       if (_M_n >= used_block)"}]}