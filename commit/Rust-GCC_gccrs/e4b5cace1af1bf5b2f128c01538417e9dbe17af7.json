{"sha": "e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTRiNWNhY2UxYWYxYmY1YjJmMTI4YzAxNTM4NDE3ZTlkYmUxN2FmNw==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-09-14T14:09:38Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-09-14T14:09:38Z"}, "message": "tree-sra.c (build_ref_for_offset): Loc made a parameter.\n\n2010-09-14  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (build_ref_for_offset): Loc made a parameter.  Set the\n\tlocation of generated statement.  Changed all callers.\n\t(build_ref_for_model): New parameter loc which used to set location of\n\tall generated expressions.  Changed all callers.\n\t(generate_subtree_copies): Likewise.\n\t(init_subtree_with_zero): Likewise.\n\t(sra_modify_expr): Set locations of all generated statements and\n\texpressions to the location the original statement.\n\t(handle_unscalarized_data_in_subtree): Likewise.\n\t(load_assign_lhs_subreplacements): Likewise.\n\t(sra_modify_constructor_assign): Likewise.\n\t(sra_modify_assign): Likewise.\n\nFrom-SVN: r164280", "tree": {"sha": "6dae070c669f4127992ae14aa04df8833a505da6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6dae070c669f4127992ae14aa04df8833a505da6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a5d39cb4a73d1e62a766da04f729f39b195faf60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5d39cb4a73d1e62a766da04f729f39b195faf60", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5d39cb4a73d1e62a766da04f729f39b195faf60"}], "stats": {"total": 111, "additions": 72, "deletions": 39}, "files": [{"sha": "3bc4bceb5f4f80d236bb2af36f5b649013855913", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "patch": "@@ -1,3 +1,18 @@\n+2010-09-14  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (build_ref_for_offset): Loc made a parameter.  Set the\n+\tlocation of generated statement.  Changed all callers.\n+\t(build_ref_for_model): New parameter loc which used to set location of\n+\tall generated expressions.  Changed all callers.\n+\t(generate_subtree_copies): Likewise.\n+\t(init_subtree_with_zero): Likewise.\n+\t(sra_modify_expr): Set locations of all generated statements and\n+\texpressions to the location the original statement.\n+\t(handle_unscalarized_data_in_subtree): Likewise.\n+\t(load_assign_lhs_subreplacements): Likewise.\n+\t(sra_modify_constructor_assign): Likewise.\n+\t(sra_modify_assign): Likewise.\n+\n 2010-09-14  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR target/45277"}, {"sha": "140dfc017537827bac3376cd62bd95d119476d20", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "patch": "@@ -339,7 +339,8 @@ ipcp_lattice_from_jfunc (struct ipa_node_params *info, struct ipcp_lattice *lat,\n \t  return;\n \t}\n       t = TREE_OPERAND (caller_lat->constant, 0);\n-      t = build_ref_for_offset (t, jfunc->value.ancestor.offset,\n+      t = build_ref_for_offset (EXPR_LOCATION (t), t,\n+\t\t\t\tjfunc->value.ancestor.offset,\n \t\t\t\tjfunc->value.ancestor.type, NULL, false);\n       lat->constant = build_fold_addr_expr (t);\n     }"}, {"sha": "40f7ef950c4fab3b5f527b19c43c2ca17bbbf8ff", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "patch": "@@ -512,7 +512,7 @@ void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n \n /* From tree-sra.c:  */\n-tree build_ref_for_offset (tree, HOST_WIDE_INT, tree, gimple_stmt_iterator *,\n-\t\t\t   bool);\n+tree build_ref_for_offset (location_t, tree, HOST_WIDE_INT, tree,\n+\t\t\t   gimple_stmt_iterator *, bool);\n \n #endif /* IPA_PROP_H */"}, {"sha": "e97970c3c4af6be964b7511d9aed2b6f9eb3ee0f", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 53, "deletions": 36, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e4b5cace1af1bf5b2f128c01538417e9dbe17af7/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=e4b5cace1af1bf5b2f128c01538417e9dbe17af7", "patch": "@@ -1328,13 +1328,12 @@ make_fancy_name (tree expr)\n    by INSERT_AFTER.  This function is not capable of handling bitfields.  */\n \n tree\n-build_ref_for_offset (tree base, HOST_WIDE_INT offset,\n+build_ref_for_offset (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t      tree exp_type, gimple_stmt_iterator *gsi,\n \t\t      bool insert_after)\n {\n   tree prev_base = base;\n   tree off;\n-  location_t loc = EXPR_LOCATION (base);\n   HOST_WIDE_INT base_offset;\n \n   gcc_checking_assert (offset % BITS_PER_UNIT == 0);\n@@ -1354,6 +1353,7 @@ build_ref_for_offset (tree base, HOST_WIDE_INT offset,\n       tmp = make_ssa_name (tmp, NULL);\n       addr = build_fold_addr_expr (unshare_expr (prev_base));\n       stmt = gimple_build_assign (tmp, addr);\n+      gimple_set_location (stmt, loc);\n       SSA_NAME_DEF_STMT (tmp) = stmt;\n       if (insert_after)\n \tgsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n@@ -1389,7 +1389,7 @@ build_ref_for_offset (tree base, HOST_WIDE_INT offset,\n    build_ref_for_offset.  */\n \n static tree\n-build_ref_for_model (tree base, HOST_WIDE_INT offset,\n+build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t     struct access *model, gimple_stmt_iterator *gsi,\n \t\t     bool insert_after)\n {\n@@ -1401,13 +1401,13 @@ build_ref_for_model (tree base, HOST_WIDE_INT offset,\n \n       offset -= int_bit_position (TREE_OPERAND (model->expr, 1));\n       exp_type = TREE_TYPE (TREE_OPERAND (model->expr, 0));\n-      t = build_ref_for_offset (base, offset, exp_type, gsi, insert_after);\n-      return fold_build3_loc (EXPR_LOCATION (base), COMPONENT_REF,\n-\t\t\t      model->type, t, TREE_OPERAND (model->expr, 1),\n-\t\t\t      NULL_TREE);\n+      t = build_ref_for_offset (loc, base, offset, exp_type, gsi, insert_after);\n+      return fold_build3_loc (loc, COMPONENT_REF, model->type, t,\n+\t\t\t      TREE_OPERAND (model->expr, 1), NULL_TREE);\n     }\n   else\n-    return build_ref_for_offset (base, offset, model->type, gsi, insert_after);\n+    return build_ref_for_offset (loc, base, offset, model->type,\n+\t\t\t\t gsi, insert_after);\n }\n \n /* Construct a memory reference consisting of component_refs and array_refs to\n@@ -2187,7 +2187,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t\t\t HOST_WIDE_INT top_offset,\n \t\t\t HOST_WIDE_INT start_offset, HOST_WIDE_INT chunk_size,\n \t\t\t gimple_stmt_iterator *gsi, bool write,\n-\t\t\t bool insert_after)\n+\t\t\t bool insert_after, location_t loc)\n {\n   do\n     {\n@@ -2201,7 +2201,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t  tree expr, repl = get_access_replacement (access);\n \t  gimple stmt;\n \n-\t  expr = build_ref_for_model (agg, access->offset - top_offset,\n+\t  expr = build_ref_for_model (loc, agg, access->offset - top_offset,\n \t\t\t\t      access, gsi, insert_after);\n \n \t  if (write)\n@@ -2223,6 +2223,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \t\t\t\t\t\t : GSI_SAME_STMT);\n \t      stmt = gimple_build_assign (expr, repl);\n \t    }\n+\t  gimple_set_location (stmt, loc);\n \n \t  if (insert_after)\n \t    gsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n@@ -2235,7 +2236,7 @@ generate_subtree_copies (struct access *access, tree agg,\n       if (access->first_child)\n \tgenerate_subtree_copies (access->first_child, agg, top_offset,\n \t\t\t\t start_offset, chunk_size, gsi,\n-\t\t\t\t write, insert_after);\n+\t\t\t\t write, insert_after, loc);\n \n       access = access->next_sibling;\n     }\n@@ -2249,7 +2250,7 @@ generate_subtree_copies (struct access *access, tree agg,\n \n static void\n init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n-\t\t\tbool insert_after)\n+\t\t\tbool insert_after, location_t loc)\n \n {\n   struct access *child;\n@@ -2266,10 +2267,11 @@ init_subtree_with_zero (struct access *access, gimple_stmt_iterator *gsi,\n       else\n \tgsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n       update_stmt (stmt);\n+      gimple_set_location (stmt, loc);\n     }\n \n   for (child = access->first_child; child; child = child->next_sibling)\n-    init_subtree_with_zero (child, gsi, insert_after);\n+    init_subtree_with_zero (child, gsi, insert_after, loc);\n }\n \n /* Search for an access representative for the given expression EXPR and\n@@ -2306,6 +2308,7 @@ get_access_for_expr (tree expr)\n static bool\n sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n {\n+  location_t loc;\n   struct access *access;\n   tree type, bfr;\n \n@@ -2324,6 +2327,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n     return false;\n   type = TREE_TYPE (*expr);\n \n+  loc = gimple_location (gsi_stmt (*gsi));\n   if (access->grp_to_be_replaced)\n     {\n       tree repl = get_access_replacement (access);\n@@ -2341,7 +2345,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t{\n \t  tree ref;\n \n-\t  ref = build_ref_for_model (access->base, access->offset, access,\n+\t  ref = build_ref_for_model (loc, access->base, access->offset, access,\n \t\t\t\t     NULL, false);\n \n \t  if (write)\n@@ -2352,6 +2356,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t\tref = force_gimple_operand_gsi (gsi, ref, true, NULL_TREE,\n \t\t\t\t\t\t false, GSI_NEW_STMT);\n \t      stmt = gimple_build_assign (repl, ref);\n+\t      gimple_set_location (stmt, loc);\n \t      gsi_insert_after (gsi, stmt, GSI_NEW_STMT);\n \t    }\n \t  else\n@@ -2362,6 +2367,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \t\trepl = force_gimple_operand_gsi (gsi, repl, true, NULL_TREE,\n \t\t\t\t\t\t true, GSI_SAME_STMT);\n \t      stmt = gimple_build_assign (ref, repl);\n+\t      gimple_set_location (stmt, loc);\n \t      gsi_insert_before (gsi, stmt, GSI_SAME_STMT);\n \t    }\n \t}\n@@ -2385,7 +2391,8 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n \tstart_offset = chunk_size = 0;\n \n       generate_subtree_copies (access->first_child, access->base, 0,\n-\t\t\t       start_offset, chunk_size, gsi, write, write);\n+\t\t\t       start_offset, chunk_size, gsi, write, write,\n+\t\t\t       loc);\n     }\n   return true;\n }\n@@ -2408,13 +2415,15 @@ handle_unscalarized_data_in_subtree (struct access *top_racc, tree lhs,\n   if (top_racc->grp_unscalarized_data)\n     {\n       generate_subtree_copies (top_racc->first_child, top_racc->base, 0, 0, 0,\n-\t\t\t       gsi, false, false);\n+\t\t\t       gsi, false, false,\n+\t\t\t       gimple_location (gsi_stmt (*gsi)));\n       return SRA_UDH_RIGHT;\n     }\n   else\n     {\n       generate_subtree_copies (top_racc->first_child, lhs, top_racc->offset,\n-\t\t\t       0, 0, gsi, false, false);\n+\t\t\t       0, 0, gsi, false, false,\n+\t\t\t       gimple_location (gsi_stmt (*gsi)));\n       return SRA_UDH_LEFT;\n     }\n }\n@@ -2440,7 +2449,7 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t\t\t\t enum unscalarized_data_handling *refreshed,\n \t\t\t\t tree lhs)\n {\n-  location_t loc = EXPR_LOCATION (lacc->expr);\n+  location_t loc = gimple_location (gsi_stmt (*old_gsi));\n   do\n     {\n       if (lacc->grp_to_be_replaced)\n@@ -2462,19 +2471,20 @@ load_assign_lhs_subreplacements (struct access *lacc, struct access *top_racc,\n \t      /* No suitable access on the right hand side, need to load from\n \t\t the aggregate.  See if we have to update it first... */\n \t      if (*refreshed == SRA_UDH_NONE)\n-\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc,\n-\t\t\t\t\t\t\t\t  lhs, old_gsi);\n+\t\t*refreshed = handle_unscalarized_data_in_subtree (top_racc, lhs,\n+\t\t\t\t\t\t\t\t  old_gsi);\n \n \t      if (*refreshed == SRA_UDH_LEFT)\n-\t\trhs = build_ref_for_model (lacc->base, lacc->offset, lacc,\n+\t\trhs = build_ref_for_model (loc, lacc->base, lacc->offset, lacc,\n \t\t\t\t\t    new_gsi, true);\n \t      else\n-\t\trhs = build_ref_for_model (top_racc->base, offset, lacc,\n+\t\trhs = build_ref_for_model (loc, top_racc->base, offset, lacc,\n \t\t\t\t\t    new_gsi, true);\n \t    }\n \n \t  stmt = gimple_build_assign (get_access_replacement (lacc), rhs);\n \t  gsi_insert_after (new_gsi, stmt, GSI_NEW_STMT);\n+\t  gimple_set_location (stmt, loc);\n \t  update_stmt (stmt);\n \t  sra_stats.subreplacements++;\n \t}\n@@ -2507,32 +2517,34 @@ sra_modify_constructor_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n {\n   tree lhs = gimple_assign_lhs (*stmt);\n   struct access *acc;\n+  location_t loc;\n \n   acc = get_access_for_expr (lhs);\n   if (!acc)\n     return SRA_AM_NONE;\n \n+  loc = gimple_location (*stmt);\n   if (VEC_length (constructor_elt,\n \t\t  CONSTRUCTOR_ELTS (gimple_assign_rhs1 (*stmt))) > 0)\n     {\n       /* I have never seen this code path trigger but if it can happen the\n \t following should handle it gracefully.  */\n       if (access_has_children_p (acc))\n \tgenerate_subtree_copies (acc->first_child, acc->base, 0, 0, 0, gsi,\n-\t\t\t\t true, true);\n+\t\t\t\t true, true, loc);\n       return SRA_AM_MODIFIED;\n     }\n \n   if (acc->grp_covered)\n     {\n-      init_subtree_with_zero (acc, gsi, false);\n+      init_subtree_with_zero (acc, gsi, false, loc);\n       unlink_stmt_vdef (*stmt);\n       gsi_remove (gsi, true);\n       return SRA_AM_REMOVED;\n     }\n   else\n     {\n-      init_subtree_with_zero (acc, gsi, true);\n+      init_subtree_with_zero (acc, gsi, true, loc);\n       return SRA_AM_MODIFIED;\n     }\n }\n@@ -2571,7 +2583,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n   tree lhs, rhs;\n   bool modify_this_stmt = false;\n   bool force_gimple_rhs = false;\n-  location_t loc = gimple_location (*stmt);\n+  location_t loc;\n   gimple_stmt_iterator orig_gsi = *gsi;\n \n   if (!gimple_assign_single_p (*stmt))\n@@ -2598,6 +2610,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n   if (!lacc && !racc)\n     return SRA_AM_NONE;\n \n+  loc = gimple_location (*stmt);\n   if (lacc && lacc->grp_to_be_replaced)\n     {\n       lhs = get_access_replacement (lacc);\n@@ -2627,13 +2640,15 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t  if (AGGREGATE_TYPE_P (TREE_TYPE (lhs))\n \t      && !access_has_children_p (lacc))\n \t    {\n-\t      lhs = build_ref_for_offset (lhs, 0, TREE_TYPE (rhs), gsi, false);\n+\t      lhs = build_ref_for_offset (loc, lhs, 0, TREE_TYPE (rhs),\n+\t\t\t\t\t  gsi, false);\n \t      gimple_assign_set_lhs (*stmt, lhs);\n \t    }\n \t  else if (AGGREGATE_TYPE_P (TREE_TYPE (rhs))\n \t\t   && !contains_view_convert_expr_p (rhs)\n \t\t   && !access_has_children_p (racc))\n-\t    rhs = build_ref_for_offset (rhs, 0, TREE_TYPE (lhs), gsi, false);\n+\t    rhs = build_ref_for_offset (loc, rhs, 0, TREE_TYPE (lhs),\n+\t\t\t\t\tgsi, false);\n \n \t  if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t    {\n@@ -2685,10 +2700,10 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n     {\n       if (access_has_children_p (racc))\n \tgenerate_subtree_copies (racc->first_child, racc->base, 0, 0, 0,\n-\t\t\t\t gsi, false, false);\n+\t\t\t\t gsi, false, false, loc);\n       if (access_has_children_p (lacc))\n \tgenerate_subtree_copies (lacc->first_child, lacc->base, 0, 0, 0,\n-\t\t\t\t gsi, true, true);\n+\t\t\t\t gsi, true, true, loc);\n       sra_stats.separate_lhs_rhs_handling++;\n     }\n   else\n@@ -2705,7 +2720,8 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \n \t  load_assign_lhs_subreplacements (lacc->first_child, racc,\n \t\t\t\t\t   lacc->offset, racc->offset,\n-\t\t\t\t\t   &orig_gsi, gsi, &refreshed, lhs);\n+\t\t\t\t\t   &orig_gsi, gsi, &refreshed,\n+\t\t\t\t\t   lhs);\n \t  if (refreshed != SRA_UDH_RIGHT)\n \t    {\n \t      gsi_next (gsi);\n@@ -2740,7 +2756,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t\t      if (racc->first_child)\n \t\t\tgenerate_subtree_copies (racc->first_child, lhs,\n \t\t\t\t\t\t racc->offset, 0, 0, gsi,\n-\t\t\t\t\t\t false, false);\n+\t\t\t\t\t\t false, false, loc);\n \n \t\t      gcc_assert (*stmt == gsi_stmt (*gsi));\n \t\t      unlink_stmt_vdef (*stmt);\n@@ -2750,12 +2766,12 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t\t    }\n \t\t}\n \t      else if (racc->first_child)\n-\t\tgenerate_subtree_copies (racc->first_child, lhs,\n-\t\t\t\t\t racc->offset, 0, 0, gsi, false, true);\n+\t\tgenerate_subtree_copies (racc->first_child, lhs, racc->offset,\n+\t\t\t\t\t 0, 0, gsi, false, true, loc);\n \t    }\n \t  if (access_has_children_p (lacc))\n \t    generate_subtree_copies (lacc->first_child, rhs, lacc->offset,\n-\t\t\t\t     0, 0, gsi, true, true);\n+\t\t\t\t     0, 0, gsi, true, true, loc);\n \t}\n     }\n \n@@ -2888,7 +2904,8 @@ initialize_parameter_reductions (void)\n       for (access = VEC_index (access_p, access_vec, 0);\n \t   access;\n \t   access = access->next_grp)\n-\tgenerate_subtree_copies (access, parm, 0, 0, 0, &gsi, true, true);\n+\tgenerate_subtree_copies (access, parm, 0, 0, 0, &gsi, true, true,\n+\t\t\t\t EXPR_LOCATION (parm));\n     }\n \n   if (seq)"}]}