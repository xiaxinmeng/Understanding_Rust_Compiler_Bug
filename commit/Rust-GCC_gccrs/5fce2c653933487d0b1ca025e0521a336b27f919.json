{"sha": "5fce2c653933487d0b1ca025e0521a336b27f919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZjZTJjNjUzOTMzNDg3ZDBiMWNhMDI1ZTA1MjFhMzM2YjI3ZjkxOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-04-08T23:28:28Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-04-08T23:28:28Z"}, "message": "fold-const.c (fold): Use \"fold\" following build in more places.\n\n\n\t* fold-const.c (fold):  Use \"fold\" following build in more places.\n\tOptimize sqrt(x)*sqrt(x) as x, pow(x,y)*pow(z,y) as pow(x*z,y),\n\tpow(x,y)*pow(x,z) as pow(x,y+z) and x/pow(y,z) as x*pow(y,-z).\n\n\t* gcc.dg/builtins-11.c: New test case.\n\nFrom-SVN: r65387", "tree": {"sha": "e73eca0237b6173f9395a521bdd81f8c89529b46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e73eca0237b6173f9395a521bdd81f8c89529b46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fce2c653933487d0b1ca025e0521a336b27f919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fce2c653933487d0b1ca025e0521a336b27f919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fce2c653933487d0b1ca025e0521a336b27f919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fce2c653933487d0b1ca025e0521a336b27f919/comments", "author": null, "committer": null, "parents": [{"sha": "531878a68e636392d594f22d0fc6e1444e82d940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/531878a68e636392d594f22d0fc6e1444e82d940", "html_url": "https://github.com/Rust-GCC/gccrs/commit/531878a68e636392d594f22d0fc6e1444e82d940"}], "stats": {"total": 138, "additions": 126, "deletions": 12}, "files": [{"sha": "58700fba6503c072aaf26c6cdda681991930b423", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fce2c653933487d0b1ca025e0521a336b27f919", "patch": "@@ -1,3 +1,9 @@\n+2003-04-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (fold):  Use \"fold\" following build in more places.\n+\tOptimize sqrt(x)*sqrt(x) as x, pow(x,y)*pow(z,y) as pow(x*z,y),\n+\tpow(x,y)*pow(x,z) as pow(x,y+z) and x/pow(y,z) as x*pow(y,-z).\n+\n 2003-04-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (fold_builtin):  Constant fold expressions as x*0.5"}, {"sha": "ebb87e27a5ea5533a08dec77770c8a222b65b8a4", "filename": "gcc/fold-const.c", "status": "modified", "additions": 70, "deletions": 12, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=5fce2c653933487d0b1ca025e0521a336b27f919", "patch": "@@ -5849,25 +5849,33 @@ fold (expr)\n \t      && ! contains_placeholder_p (arg0))\n \t    {\n \t      tree arg = save_expr (arg0);\n-\t      return build (PLUS_EXPR, type, arg, arg);\n+\t      return fold (build (PLUS_EXPR, type, arg, arg));\n \t    }\n \n \t  if (flag_unsafe_math_optimizations)\n \t    {\n \t      enum built_in_function fcode0 = builtin_mathfn_code (arg0);\n \t      enum built_in_function fcode1 = builtin_mathfn_code (arg1);\n \n-\t      /* Optimize sqrt(x)*sqrt(y) as sqrt(x*y).  */\n+\t      /* Optimizations of sqrt(...)*sqrt(...).  */\n \t      if ((fcode0 == BUILT_IN_SQRT && fcode1 == BUILT_IN_SQRT)\n \t\t  || (fcode0 == BUILT_IN_SQRTF && fcode1 == BUILT_IN_SQRTF)\n \t\t  || (fcode0 == BUILT_IN_SQRTL && fcode1 == BUILT_IN_SQRTL))\n \t\t{\n-\t\t  tree sqrtfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n-\t\t  tree arg = build (MULT_EXPR, type,\n-\t\t\t\t    TREE_VALUE (TREE_OPERAND (arg0, 1)),\n-\t\t\t\t    TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t\t  tree arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return fold (build_function_call_expr (sqrtfn, arglist));\n+\t\t  tree sqrtfn, arg, arglist;\n+\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\n+\t\t  /* Optimize sqrt(x)*sqrt(x) as x.  */\n+\t\t  if (operand_equal_p (arg00, arg10, 0)\n+\t\t      && ! HONOR_SNANS (TYPE_MODE (type)))\n+\t\t    return arg00;\n+\n+\t          /* Optimize sqrt(x)*sqrt(y) as sqrt(x*y).  */\n+\t\t  sqrtfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t  arg = fold (build (MULT_EXPR, type, arg00, arg10));\n+\t\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t\t  return build_function_call_expr (sqrtfn, arglist);\n \t\t}\n \n \t      /* Optimize exp(x)*exp(y) as exp(x+y).  */\n@@ -5879,8 +5887,43 @@ fold (expr)\n \t\t  tree arg = build (PLUS_EXPR, type,\n \t\t\t\t    TREE_VALUE (TREE_OPERAND (arg0, 1)),\n \t\t\t\t    TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t\t  tree arglist = build_tree_list (NULL_TREE, arg);\n-\t\t  return fold (build_function_call_expr (expfn, arglist));\n+\t\t  tree arglist = build_tree_list (NULL_TREE, fold (arg));\n+\t\t  return build_function_call_expr (expfn, arglist);\n+\t\t}\n+\n+\t      /* Optimizations of pow(...)*pow(...).  */\n+\t      if ((fcode0 == BUILT_IN_POW && fcode1 == BUILT_IN_POW)\n+\t\t  || (fcode0 == BUILT_IN_POWF && fcode1 == BUILT_IN_POWF)\n+\t\t  || (fcode0 == BUILT_IN_POWL && fcode1 == BUILT_IN_POWL))\n+\t\t{\n+\t\t  tree arg00 = TREE_VALUE (TREE_OPERAND (arg0, 1));\n+\t\t  tree arg01 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg0,\n+\t\t\t\t\t\t\t\t     1)));\n+\t\t  tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t\t  tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1,\n+\t\t\t\t\t\t\t\t     1)));\n+\n+\t\t  /* Optimize pow(x,y)*pow(z,y) as pow(x*z,y).  */\n+\t\t  if (operand_equal_p (arg01, arg11, 0))\n+\t\t    {\n+\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      tree arg = build (MULT_EXPR, type, arg00, arg10);\n+\t\t      tree arglist = tree_cons (NULL_TREE, fold (arg),\n+\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t\t arg01));\n+\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t    }\n+\n+\t\t  /* Optimize pow(x,y)*pow(x,z) as pow(x,y+z).  */\n+\t\t  if (operand_equal_p (arg00, arg10, 0))\n+\t\t    {\n+\t\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg0, 0), 0);\n+\t\t      tree arg = fold (build (PLUS_EXPR, type, arg01, arg11));\n+\t\t      tree arglist = tree_cons (NULL_TREE, arg00,\n+\t\t\t\t\t\tbuild_tree_list (NULL_TREE,\n+\t\t\t\t\t\t\t\t arg));\n+\t\t      return build_function_call_expr (powfn, arglist);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -6052,21 +6095,36 @@ fold (expr)\n \t \t\t      TREE_OPERAND (arg1, 1)));\n \t}\n \n-      /* Optimize x/exp(y) into x*exp(-y).  */\n       if (flag_unsafe_math_optimizations)\n \t{\n \t  enum built_in_function fcode = builtin_mathfn_code (arg1);\n+\t  /* Optimize x/exp(y) into x*exp(-y).  */\n \t  if (fcode == BUILT_IN_EXP\n \t      || fcode == BUILT_IN_EXPF\n \t      || fcode == BUILT_IN_EXPL)\n \t    {\n \t      tree expfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n \t      tree arg = build1 (NEGATE_EXPR, type,\n \t\t\t\t TREE_VALUE (TREE_OPERAND (arg1, 1)));\n-\t      tree arglist = build_tree_list (NULL_TREE, arg);\n+\t      tree arglist = build_tree_list (NULL_TREE, fold (arg));\n \t      arg1 = build_function_call_expr (expfn, arglist);\n \t      return fold (build (MULT_EXPR, type, arg0, arg1));\n \t    }\n+\n+\t  /* Optimize x/pow(y,z) into x*pow(y,-z).  */\n+\t  if (fcode == BUILT_IN_POW\n+\t      || fcode == BUILT_IN_POWF\n+\t      || fcode == BUILT_IN_POWL)\n+\t    {\n+\t      tree powfn = TREE_OPERAND (TREE_OPERAND (arg1, 0), 0);\n+\t      tree arg10 = TREE_VALUE (TREE_OPERAND (arg1, 1));\n+\t      tree arg11 = TREE_VALUE (TREE_CHAIN (TREE_OPERAND (arg1, 1)));\n+\t      tree neg11 = fold (build1 (NEGATE_EXPR, type, arg11));\n+\t      tree arglist = tree_cons(NULL_TREE, arg10,\n+\t\t\t\t       build_tree_list (NULL_TREE, neg11));\n+\t      arg1 = build_function_call_expr (powfn, arglist);\n+\t      return fold (build (MULT_EXPR, type, arg0, arg1));\n+\t    }\n \t}\n       goto binary;\n "}, {"sha": "857d1e54638df0c9c336297f15caa01a32ec7ef1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5fce2c653933487d0b1ca025e0521a336b27f919", "patch": "@@ -1,3 +1,7 @@\n+2003-04-08  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* gcc.dg/builtins-11.c: New test case.\n+\n 2003-04-08  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/builtins-9.c: New test case."}, {"sha": "a2ff257b9ee46dd031c3381be74d071d5dd260b2", "filename": "gcc/testsuite/gcc.dg/builtins-11.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fce2c653933487d0b1ca025e0521a336b27f919/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-11.c?ref=5fce2c653933487d0b1ca025e0521a336b27f919", "patch": "@@ -0,0 +1,46 @@\n+/* Copyright (C) 2003 Free Software Foundation.\n+\n+   Check that constant folding of built-in math functions doesn't\n+   break anything and produces the expected results.\n+\n+   Written by Roger Sayle, 5th April 2003.  */\n+\n+/* { dg-do link } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern void link_error(void);\n+\n+extern double exp(double);\n+extern double sqrt(double);\n+extern double pow(double,double);\n+\n+void test(double x, double y, double z)\n+{\n+  if (sqrt(x)*sqrt(x) != x)\n+    link_error ();\n+\n+  if (sqrt(x)*sqrt(y) != sqrt(x*y))\n+    link_error ();\n+\n+  if (exp(x)*exp(y) != exp(x+y))\n+    link_error ();\n+\n+  if (pow(x,y)*pow(z,y) != pow(z*x,y))\n+    link_error ();\n+\n+  if (pow(x,y)*pow(x,z) != pow(x,y+z))\n+    link_error ();\n+\n+  if (x/exp(y) != x*exp(-y))\n+    link_error ();\n+\n+  if (x/pow(y,z) != x*pow(y,-z))\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  test (2.0, 3.0, 4.0);\n+  return 0;\n+}\n+"}]}