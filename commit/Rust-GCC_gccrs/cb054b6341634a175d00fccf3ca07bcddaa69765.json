{"sha": "cb054b6341634a175d00fccf3ca07bcddaa69765", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IwNTRiNjM0MTYzNGExNzVkMDBmY2NmM2NhMDdiY2RkYWE2OTc2NQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-16T02:54:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2015-01-16T02:54:13Z"}, "message": "runtime: Use a struct, not void, for an empty struct for libffi.\n\nA recent libffi upgrade caused the reflect test to fail on\n386.  The problem case is a function that returns an empty\nstruct--a struct with no fields.  The libffi library does not\nrecognize the existence of empty structs, presumably since\nthey can't happen in C.  To work around this, the Go interface\nto the libffi library changes an empty struct to void.  This\nnormally works fine, but with the new libffi upgrade it fails\nfor a function that returns an empty struct.  On 386 a\nfunction that returns a struct is expected to pop the hidden\npointer when it returns.  So when we convert an empty struct\nto void, libffi is calling a function that pops the hidden\npointer but does not expect that to happen.\n\nIn the older version of libffi, this didn't matter, because\nthe libffi code for 386 used a frame pointer, so the fact that\nthe stack pointer was wonky when the function returned was\nignored as the stack pointer was immediately replaced by the\nsaved frame pointer.  In the newer version of libffi, the 386\ncode is more efficient and does not use a frame pointer, and\ntherefore it matters whether libffi expects the function to\npop the hidden pointer or not.\n\nThis patch changes libgo to convert an empty to a struct with\na single field of type void.  This seems to be enough to get\nthe test cases working again.\n\nOf course the real fix would be to change libffi to handle\nempty types, but as libffi uses size == 0 as a marker for an\nuninitialized type, that would be a non-trivial change.\n\nFrom-SVN: r219701", "tree": {"sha": "da5fdc2fe05b13b5665eb574ae14986f1e4f9292", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da5fdc2fe05b13b5665eb574ae14986f1e4f9292"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb054b6341634a175d00fccf3ca07bcddaa69765", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb054b6341634a175d00fccf3ca07bcddaa69765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb054b6341634a175d00fccf3ca07bcddaa69765", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb054b6341634a175d00fccf3ca07bcddaa69765/comments", "author": null, "committer": null, "parents": [{"sha": "56314783c33b58a03f7eee9d48b4a2628ee6e1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56314783c33b58a03f7eee9d48b4a2628ee6e1f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56314783c33b58a03f7eee9d48b4a2628ee6e1f0"}], "stats": {"total": 19, "additions": 16, "deletions": 3}, "files": [{"sha": "175c583bf45691c77a6025daccff94fd5d428be1", "filename": "libgo/runtime/go-ffi.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb054b6341634a175d00fccf3ca07bcddaa69765/libgo%2Fruntime%2Fgo-ffi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb054b6341634a175d00fccf3ca07bcddaa69765/libgo%2Fruntime%2Fgo-ffi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-ffi.c?ref=cb054b6341634a175d00fccf3ca07bcddaa69765", "patch": "@@ -52,6 +52,14 @@ go_array_to_ffi (const struct __go_array_type *descriptor)\n   ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n   ret->type = FFI_TYPE_STRUCT;\n   len = descriptor->__len;\n+  if (len == 0)\n+    {\n+      /* The libffi library won't accept an empty struct.  */\n+      ret->elements = (ffi_type **) __go_alloc (2 * sizeof (ffi_type *));\n+      ret->elements[0] = &ffi_type_void;\n+      ret->elements[1] = NULL;\n+      return ret;\n+    }\n   ret->elements = (ffi_type **) __go_alloc ((len + 1) * sizeof (ffi_type *));\n   element = go_type_to_ffi (descriptor->__element_type);\n   for (i = 0; i < len; ++i)\n@@ -92,11 +100,16 @@ go_struct_to_ffi (const struct __go_struct_type *descriptor)\n   int i;\n \n   field_count = descriptor->__fields.__count;\n-  if (field_count == 0) {\n-    return &ffi_type_void;\n-  }\n   ret = (ffi_type *) __go_alloc (sizeof (ffi_type));\n   ret->type = FFI_TYPE_STRUCT;\n+  if (field_count == 0)\n+    {\n+      /* The libffi library won't accept an empty struct.  */\n+      ret->elements = (ffi_type **) __go_alloc (2 * sizeof (ffi_type *));\n+      ret->elements[0] = &ffi_type_void;\n+      ret->elements[1] = NULL;\n+      return ret;\n+    }\n   fields = (const struct __go_struct_field *) descriptor->__fields.__values;\n   ret->elements = (ffi_type **) __go_alloc ((field_count + 1)\n \t\t\t\t\t    * sizeof (ffi_type *));"}]}