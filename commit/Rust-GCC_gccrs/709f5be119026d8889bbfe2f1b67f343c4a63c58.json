{"sha": "709f5be119026d8889bbfe2f1b67f343c4a63c58", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA5ZjViZTExOTAyNmQ4ODg5YmJmZTJmMWI2N2YzNDNjNGE2M2M1OA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-08T18:54:00Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-08-08T18:54:00Z"}, "message": "(expand_assignment): If WANT_VALUE is 0, return NULL.\n\n(store_expr): Likewise.\nRename arg SUGGEST_REG to WANT_VALUE.\nNever return TARGET if WANT_VALUE unless BLKmode.\nInstead, return TEMP or a value copied from TARGET.\nPass 0 for WANT_VALUE in recursive calls that ignore value.\n\n(expand_expr, case PLUS_EXPR): Goto binop2 not\nboth_summands if we should not be returning a plus.\n\n(do_tablejump) [PIC_CASE_VECTOR_ADDRESS]: If pic,\ncopy INDEX to a register early, to avoid invalid address later.\n\nFrom-SVN: r5108", "tree": {"sha": "0f0b7fb6c8c1da4b06b98212b755b44f00acc5e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f0b7fb6c8c1da4b06b98212b755b44f00acc5e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/709f5be119026d8889bbfe2f1b67f343c4a63c58", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/709f5be119026d8889bbfe2f1b67f343c4a63c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/709f5be119026d8889bbfe2f1b67f343c4a63c58", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/709f5be119026d8889bbfe2f1b67f343c4a63c58/comments", "author": null, "committer": null, "parents": [{"sha": "5b272d50fa6c2262ed339dce9bf778697a8b60a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b272d50fa6c2262ed339dce9bf778697a8b60a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b272d50fa6c2262ed339dce9bf778697a8b60a5"}], "stats": {"total": 118, "additions": 77, "deletions": 41}, "files": [{"sha": "bb31906f8c11380c7b1fd92816ea7012a87f414c", "filename": "gcc/expr.c", "status": "modified", "additions": 77, "deletions": 41, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/709f5be119026d8889bbfe2f1b67f343c4a63c58/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/709f5be119026d8889bbfe2f1b67f343c4a63c58/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=709f5be119026d8889bbfe2f1b67f343c4a63c58", "patch": "@@ -2150,15 +2150,14 @@ emit_push_insn (x, mode, type, size, align, partial, reg, extra,\n \f\n /* Expand an assignment that stores the value of FROM into TO.\n    If WANT_VALUE is nonzero, return an rtx for the value of TO.\n-   (This may contain a QUEUED rtx.)\n-   Otherwise, the returned value is not meaningful.\n+   (This may contain a QUEUED rtx;\n+   if the value is constant, this rtx is a constant.)\n+   Otherwise, the returned value is NULL_RTX.\n \n    SUGGEST_REG is no longer actually used.\n    It used to mean, copy the value through a register\n    and return that register, if that is possible.\n-   But now we do this if WANT_VALUE.\n-\n-   If the value stored is a constant, we return the constant.  */\n+   We now use WANT_VALUE to decide whether to do this.  */\n \n rtx\n expand_assignment (to, from, want_value, suggest_reg)\n@@ -2172,7 +2171,10 @@ expand_assignment (to, from, want_value, suggest_reg)\n   /* Don't crash if the lhs of the assignment was erroneous.  */\n \n   if (TREE_CODE (to) == ERROR_MARK)\n-    return expand_expr (from, NULL_RTX, VOIDmode, 0);\n+    {\n+      result = expand_expr (from, NULL_RTX, VOIDmode, 0);\n+      return want_value ? result : NULL_RTX;\n+    }\n \n   /* Assignment of a structure component needs special treatment\n      if the structure component's rtx is not simply a MEM.\n@@ -2235,12 +2237,11 @@ expand_assignment (to, from, want_value, suggest_reg)\n       preserve_temp_slots (result);\n       free_temp_slots ();\n \n-      /* If we aren't returning a result, just pass on what expand_expr\n-\t returned; it was probably const0_rtx.  Otherwise, convert RESULT\n-\t to the proper mode.  */\n+      /* If the value is meaningful, convert RESULT to the proper mode.\n+\t Otherwise, return nothing.  */\n       return (want_value ? convert_to_mode (TYPE_MODE (TREE_TYPE (to)), result,\n \t\t\t\t\t    TREE_UNSIGNED (TREE_TYPE (to)))\n-\t      : result);\n+\t      : NULL_RTX);\n     }\n \n   /* If the rhs is a function call and its value is not an aggregate,\n@@ -2256,7 +2257,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       emit_move_insn (to_rtx, value);\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n-      return to_rtx;\n+      return want_value ? to_rtx : NULL_RTX;\n     }\n \n   /* Ordinary treatment.  Expand TO to get a REG or MEM rtx.\n@@ -2272,7 +2273,7 @@ expand_assignment (to, from, want_value, suggest_reg)\n       emit_move_insn (to_rtx, temp);\n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n-      return to_rtx;\n+      return want_value ? to_rtx : NULL_RTX;\n     }\n \n   /* In case we are returning the contents of an object which overlaps\n@@ -2303,32 +2304,45 @@ expand_assignment (to, from, want_value, suggest_reg)\n \n       preserve_temp_slots (to_rtx);\n       free_temp_slots ();\n-      return to_rtx;\n+      return want_value ? to_rtx : NULL_RTX;\n     }\n \n   /* Compute FROM and store the value in the rtx we got.  */\n \n   result = store_expr (from, to_rtx, want_value);\n   preserve_temp_slots (result);\n   free_temp_slots ();\n-  return result;\n+  return want_value ? result : NULL_RTX;\n }\n \n /* Generate code for computing expression EXP,\n    and storing the value into TARGET.\n-   Returns TARGET or an equivalent value.\n    TARGET may contain a QUEUED rtx.\n \n-   If SUGGEST_REG is nonzero, copy the value through a register\n-   and return that register, if that is possible.\n-\n-   If the value stored is a constant, we return the constant.  */\n+   If WANT_VALUE is nonzero, return a copy of the value\n+   not in TARGET, so that we can be sure to use the proper\n+   value in a containing expression even if TARGET has something\n+   else stored in it.  If possible, we copy the value through a pseudo\n+   and return that pseudo.  Or, if the value is constant, we try to\n+   return the constant.  In some cases, we return a pseudo\n+   copied *from* TARGET.\n+\n+   If the mode is BLKmode then we may return TARGET itself.\n+   It turns out that in BLKmode it doesn't cause a problem.\n+   because C has no operators that could combine two different\n+   assignments into the same BLKmode object with different values\n+   with no sequence point.  Will other languages need this to\n+   be more thorough?\n+\n+   If WANT_VALUE is 0, we return NULL, to make sure\n+   to catch quickly any cases where the caller uses the value\n+   and fails to set WANT_VALUE.  */\n \n rtx\n-store_expr (exp, target, suggest_reg)\n+store_expr (exp, target, want_value)\n      register tree exp;\n      register rtx target;\n-     int suggest_reg;\n+     int want_value;\n {\n   register rtx temp;\n   int dont_return_target = 0;\n@@ -2339,7 +2353,7 @@ store_expr (exp, target, suggest_reg)\n \t part.  */\n       expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n       emit_queue ();\n-      return store_expr (TREE_OPERAND (exp, 1), target, suggest_reg);\n+      return store_expr (TREE_OPERAND (exp, 1), target, want_value);\n     }\n   else if (TREE_CODE (exp) == COND_EXPR && GET_MODE (target) == BLKmode)\n     {\n@@ -2355,22 +2369,22 @@ store_expr (exp, target, suggest_reg)\n \n       NO_DEFER_POP;\n       jumpifnot (TREE_OPERAND (exp, 0), lab1);\n-      store_expr (TREE_OPERAND (exp, 1), target, suggest_reg);\n+      store_expr (TREE_OPERAND (exp, 1), target, 0);\n       emit_queue ();\n       emit_jump_insn (gen_jump (lab2));\n       emit_barrier ();\n       emit_label (lab1);\n-      store_expr (TREE_OPERAND (exp, 2), target, suggest_reg);\n+      store_expr (TREE_OPERAND (exp, 2), target, 0);\n       emit_queue ();\n       emit_label (lab2);\n       OK_DEFER_POP;\n-      return target;\n+      return want_value ? target : NULL_RTX;\n     }\n-  else if (suggest_reg && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n+  else if (want_value && GET_CODE (target) == MEM && ! MEM_VOLATILE_P (target)\n \t   && GET_MODE (target) != BLKmode)\n     /* If target is in memory and caller wants value in a register instead,\n        arrange that.  Pass TARGET as target for expand_expr so that,\n-       if EXP is another assignment, SUGGEST_REG will be nonzero for it.\n+       if EXP is another assignment, WANT_VALUE will be nonzero for it.\n        We know expand_expr will not use the target in that case.\n        Don't do this if TARGET is volatile because we are supposed\n        to write it and then read it.  */\n@@ -2382,15 +2396,9 @@ store_expr (exp, target, suggest_reg)\n       dont_return_target = 1;\n     }\n   else if (queued_subexp_p (target))\n-    /* If target contains a postincrement, it is not safe\n-       to use as the returned value.  It would access the wrong\n-       place by the time the queued increment gets output.\n-       So copy the value through a temporary and use that temp\n-       as the result.  */\n+    /* If target contains a postincrement, let's not risk\n+       using it as the place to generate the rhs.  */\n     {\n-      /* ??? There may be a bug here in the case of a target\n-\t that is volatile, but I' too sleepy today to write anything\n-\t to handle it.  */\n       if (GET_MODE (target) != BLKmode && GET_MODE (target) != VOIDmode)\n \t{\n \t  /* Expand EXP into a new pseudo.  */\n@@ -2399,7 +2407,12 @@ store_expr (exp, target, suggest_reg)\n \t}\n       else\n \ttemp = expand_expr (exp, NULL_RTX, GET_MODE (target), 0);\n-      dont_return_target = 1;\n+\n+      /* If target is volatile, ANSI requires accessing the value\n+\t *from* the target, if it is accessed.  So make that happen.\n+\t In no case return the target itself.  */\n+      if (! MEM_VOLATILE_P (target) && want_value)\n+\tdont_return_target = 1;\n     }\n   else if (GET_CODE (target) == SUBREG && SUBREG_PROMOTED_VAR_P (target))\n     /* If this is an scalar in a register that is stored in a wider mode\n@@ -2410,18 +2423,24 @@ store_expr (exp, target, suggest_reg)\n       temp = expand_expr (exp, NULL_RTX, VOIDmode, 0);\n       convert_move (SUBREG_REG (target), temp,\n \t\t    SUBREG_PROMOTED_UNSIGNED_P (target));\n-      return temp;\n+      return want_value ? temp : NULL_RTX;\n     }\n   else\n     {\n       temp = expand_expr (exp, target, GET_MODE (target), 0);\n       /* DO return TARGET if it's a specified hardware register.\n \t expand_return relies on this.\n-\t DO return TARGET if it's a volatile mem ref; ANSI requires this.  */\n+\t If TARGET is a volatile mem ref, either return TARGET\n+\t or return a reg copied *from* TARGET; ANSI requires this.\n+\n+\t Otherwise, if TEMP is not TARGET, return TEMP\n+\t if it is constant (for efficiency),\n+\t or if we really want the correct value.  */\n       if (!(target && GET_CODE (target) == REG\n \t    && REGNO (target) < FIRST_PSEUDO_REGISTER)\n-\t  && CONSTANT_P (temp)\n-\t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target)))\n+\t  && !(GET_CODE (target) == MEM && MEM_VOLATILE_P (target))\n+\t  && temp != target\n+\t  && (CONSTANT_P (temp) || want_value))\n \tdont_return_target = 1;\n     }\n \n@@ -2527,9 +2546,14 @@ store_expr (exp, target, suggest_reg)\n       else\n \temit_move_insn (target, temp);\n     }\n+\n   if (dont_return_target)\n     return temp;\n-  return target;\n+  if (want_value && GET_MODE (target) != BLKmode)\n+    return copy_to_reg (target);\n+  if (want_value)\n+    return target;\n+  return NULL_RTX;\n }\n \f\n /* Store the value of constructor EXP into the rtx TARGET.\n@@ -4380,6 +4404,10 @@ expand_expr (exp, target, tmode, modifier)\n \t\t{\n \t\t  op1 = expand_expr (TREE_OPERAND (exp, 1), NULL_RTX,\n \t\t\t\t     VOIDmode, modifier);\n+\t\t  /* Don't go to both_summands if modifier\n+\t\t     says it's not right to return a PLUS.  */\n+\t\t  if (modifier != EXPAND_SUM && modifier != EXPAND_INITIALIZER)\n+\t\t    goto binop2;\n \t\t  goto both_summands;\n \t\t}\n \t      op0 = plus_constant (op0, TREE_INT_CST_LOW (TREE_OPERAND (exp, 1)));\n@@ -8137,6 +8165,14 @@ do_tablejump (index, mode, range, table_label, default_label)\n   if (mode != Pmode)\n     index = convert_to_mode (Pmode, index, 1);\n \n+  /* Don't let a MEM slip thru, because then INDEX that comes\n+     out of PIC_CASE_VECTOR_ADDRESS won't be a valid address,\n+     and break_out_memory_refs will go to work on it and mess it up.  */\n+#ifdef PIC_CASE_VECTOR_ADDRESS\n+  if (flag_pic && GET_CODE (index) != REG)\n+    index = copy_to_mode_reg (Pmode, index);\n+#endif\n+\n   /* If flag_force_addr were to affect this address\n      it could interfere with the tricky assumptions made\n      about addresses that contain label-refs,"}]}