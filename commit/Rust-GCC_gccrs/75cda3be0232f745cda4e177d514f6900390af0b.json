{"sha": "75cda3be0232f745cda4e177d514f6900390af0b", "node_id": "C_kwDOANBUbNoAKDc1Y2RhM2JlMDIzMmY3NDVjZGE0ZTE3N2Q1MTRmNjkwMDM5MGFmMGI", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-28T10:42:14Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2023-03-28T11:30:31Z"}, "message": "bootstrap/84402 - improve (match ...) code generation\n\nThe following avoids duplicating matching code for (match ...)\nin match.pd when possible.  That's more easily possible for\n(match ...) than simplify because we do not need to handle\ncommon matches (those would be diagnosed only during compiling)\nnor is the result able to inspect the active operator.\n\nSpecifically this reduces the size of the generated matches for\nthe atomic ops as noted in PR108129.\n\ngimple-match.cc shrinks from 245k lines to 209k lines with this patch.\n\n\tPR bootstrap/84402\n\tPR tree-optimization/108129\n\t* genmatch.cc (lower_for): For (match ...) delay\n\tsubstituting into the match operator if possible.\n\t(dt_operand::gen_gimple_expr): For user_id look at the\n\tfirst substitute for determining how to access operands.\n\t(dt_operand::gen_generic_expr): Likewise.\n\t(dt_node::gen_kids): Properly sort user_ids according\n\tto their substitutes.\n\t(dt_node::gen_kids_1): Code-generate user_id matching.", "tree": {"sha": "9c87fdaa90980e7768308094c35d1a85142d8dd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c87fdaa90980e7768308094c35d1a85142d8dd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75cda3be0232f745cda4e177d514f6900390af0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cda3be0232f745cda4e177d514f6900390af0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cda3be0232f745cda4e177d514f6900390af0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cda3be0232f745cda4e177d514f6900390af0b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a62008123694b2ac07f28e25fc6e5ff371925f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a62008123694b2ac07f28e25fc6e5ff371925f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a62008123694b2ac07f28e25fc6e5ff371925f5"}], "stats": {"total": 65, "additions": 53, "deletions": 12}, "files": [{"sha": "4fab4135347c43d95546a7df0bb1c4d074937288", "filename": "gcc/genmatch.cc", "status": "modified", "additions": 53, "deletions": 12, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75cda3be0232f745cda4e177d514f6900390af0b/gcc%2Fgenmatch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75cda3be0232f745cda4e177d514f6900390af0b/gcc%2Fgenmatch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.cc?ref=75cda3be0232f745cda4e177d514f6900390af0b", "patch": "@@ -1464,7 +1464,7 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n       vec<user_id *>& ids = for_vec[fi];\n       unsigned n_ids = ids.length ();\n       unsigned max_n_opers = 0;\n-      bool can_delay_subst = (sin->kind == simplify::SIMPLIFY);\n+      bool can_delay_subst = true;\n       for (unsigned i = 0; i < n_ids; ++i)\n \t{\n \t  if (ids[i]->substitutes.length () > max_n_opers)\n@@ -1504,6 +1504,9 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t    else\n \t      can_delay_subst = false;\n \t}\n+      if (sin->kind == simplify::MATCH\n+\t  && can_delay_subst)\n+\tcontinue;\n \n       unsigned worklist_end = worklist.length ();\n       for (unsigned si = worklist_start; si < worklist_end; ++si)\n@@ -1527,7 +1530,9 @@ lower_for (simplify *sin, vec<simplify *>& simplifiers)\n \t\t      break;\n \t\t    }\n \t\t  subst.quick_push (std::make_pair (id, oper));\n-\t\t  match_op = replace_id (match_op, id, oper);\n+\t\t  if (sin->kind == simplify::SIMPLIFY\n+\t\t      || !can_delay_subst)\n+\t\t    match_op = replace_id (match_op, id, oper);\n \t\t  if (result_op\n \t\t      && !can_delay_subst)\n \t\t    result_op = replace_id (result_op, id, oper);\n@@ -2824,6 +2829,9 @@ dt_operand::gen_gimple_expr (FILE *f, int indent, int depth)\n   unsigned n_ops = e->ops.length ();\n   unsigned n_braces = 0;\n \n+  if (user_id *u = dyn_cast <user_id *> (id))\n+    id = u->substitutes[0];\n+\n   for (unsigned i = 0; i < n_ops; ++i)\n     {\n       char child_opname[20];\n@@ -2905,14 +2913,18 @@ unsigned\n dt_operand::gen_generic_expr (FILE *f, int indent, const char *opname)\n {\n   expr *e = static_cast<expr *> (op);\n+  id_base *id = e->operation;\n   unsigned n_ops = e->ops.length ();\n \n+  if (user_id *u = dyn_cast <user_id *> (id))\n+    id = u->substitutes[0];\n+\n   for (unsigned i = 0; i < n_ops; ++i)\n     {\n       char child_opname[20];\n       gen_opname (child_opname, i);\n \n-      if (e->operation->kind == id_base::CODE)\n+      if (id->kind == id_base::CODE)\n \tfprintf_indent (f, indent, \"tree %s = TREE_OPERAND (%s, %u);\\n\",\n \t\t\tchild_opname, opname, i);\n       else\n@@ -2964,10 +2976,21 @@ dt_node::gen_kids (FILE *f, int indent, bool gimple, int depth)\n \t\tpreds.safe_push (op);\n \t      else\n \t\t{\n-\t\t  if (gimple && !e->is_generic)\n-\t\t    gimple_exprs.safe_push (op);\n+\t\t  user_id *u = dyn_cast <user_id *> (e->operation);\n+\t\t  if (u && u->substitutes[0]->kind == id_base::FN)\n+\t\t    {\n+\t\t      if (gimple)\n+\t\t\tfns.safe_push (op);\n+\t\t      else\n+\t\t\tgeneric_fns.safe_push (op);\n+\t\t    }\n \t\t  else\n-\t\t    generic_exprs.safe_push (op);\n+\t\t    {\n+\t\t      if (gimple && !e->is_generic)\n+\t\t\tgimple_exprs.safe_push (op);\n+\t\t      else\n+\t\t\tgeneric_exprs.safe_push (op);\n+\t\t    }\n \t\t}\n \t    }\n \t  else if (op->op->type == operand::OP_PREDICATE)\n@@ -3064,11 +3087,19 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple, int depth,\n \t  for (unsigned i = 0; i < exprs_len; ++i)\n \t    {\n \t      expr *e = as_a <expr *> (gimple_exprs[i]->op);\n-\t      id_base *op = e->operation;\n-\t      if (*op == CONVERT_EXPR || *op == NOP_EXPR)\n-\t\tfprintf_indent (f, indent, \"CASE_CONVERT:\\n\");\n+\t      if (user_id *u = dyn_cast <user_id *> (e->operation))\n+\t\t{\n+\t\t  for (auto id : u->substitutes)\n+\t\t    fprintf_indent (f, indent, \"case %s:\\n\", id->id);\n+\t\t}\n \t      else\n-\t\tfprintf_indent (f, indent, \"case %s:\\n\", op->id);\n+\t\t{\n+\t\t  id_base *op = e->operation;\n+\t\t  if (*op == CONVERT_EXPR || *op == NOP_EXPR)\n+\t\t    fprintf_indent (f, indent, \"CASE_CONVERT:\\n\");\n+\t\t  else\n+\t\t    fprintf_indent (f, indent, \"case %s:\\n\", op->id);\n+\t\t}\n \t      fprintf_indent (f, indent, \"  {\\n\");\n \t      gimple_exprs[i]->gen (f, indent + 4, true, depth);\n \t      fprintf_indent (f, indent, \"    break;\\n\");\n@@ -3093,7 +3124,11 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple, int depth,\n \t  for (unsigned i = 0; i < fns_len; ++i)\n \t    {\n \t      expr *e = as_a <expr *>(fns[i]->op);\n-\t      fprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n+\t      if (user_id *u = dyn_cast <user_id *> (e->operation))\n+\t\tfor (auto id : u->substitutes)\n+\t\t  fprintf_indent (f, indent, \"case %s:\\n\", id->id);\n+\t      else\n+\t\tfprintf_indent (f, indent, \"case %s:\\n\", e->operation->id);\n \t      /* We need to be defensive against bogus prototypes allowing\n \t\t calls with not enough arguments.  */\n \t      fprintf_indent (f, indent,\n@@ -3140,7 +3175,13 @@ dt_node::gen_kids_1 (FILE *f, int indent, bool gimple, int depth,\n \t/* Already handled above.  */\n \tcontinue;\n       else\n-\tfprintf_indent (f, indent, \"case %s:\\n\", op->id);\n+\t{\n+\t  if (user_id *u = dyn_cast <user_id *> (op))\n+\t    for (auto id : u->substitutes)\n+\t      fprintf_indent (f, indent, \"case %s:\\n\", id->id);\n+\t  else\n+\t    fprintf_indent (f, indent, \"case %s:\\n\", op->id);\n+\t}\n       fprintf_indent (f, indent, \"  {\\n\");\n       generic_exprs[i]->gen (f, indent + 4, gimple, depth);\n       fprintf_indent (f, indent, \"    break;\\n\");"}]}