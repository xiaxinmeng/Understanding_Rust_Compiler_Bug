{"sha": "67a8d7199fe4e474f7bd565161fa2f27d59969fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdhOGQ3MTk5ZmU0ZTQ3NGY3YmQ1NjUxNjFmYTJmMjdkNTk5NjlmYw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-12-20T14:48:34Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-12-20T14:48:34Z"}, "message": "[SFN] debug markers before labels no more\n\nMake sure that gimple and RTL IRs don't have debug markers before\nlabels.  When we build the CFG, we move labels before any markers\nappearing before them.  Then, make sure we don't mistakenly\nreintroduce them.\n\nThis reverts some of the complexity that had been brought about by the\ninitial SFN patches.\n\nfor  gcc/ChangeLog\n\n\tPR bootstrap/83396\n\t* cfgexpand.c (label_rtx_for_bb): Revert SFN changes that\n\tallowed debug stmts before labels.\n\t(expand_gimple_basic_block): Likewise.\n\t* gimple-iterator.c (gimple_find_edge_insert_loc): Likewise.\n\t* gimple-iterator.h (gsi_after_labels): Likewise.\n\t* tree-cfgcleanup (remove_forwarder_block): Likewise, but\n\trename reused variable, and simplify using gsi_move_before.\n\t* tree-ssa-tail-merge.c (find_duplicate): Likewise.\n\t* tree-cfg.c (make_edges, cleanup_dead_labels): Likewise.\n\t(gimple_can_merge_blocks_p, verify_gimple_in_cfg): Likewise.\n\t(gimple_verify_flow_info, gimple_block_label): Likewise.\n\t(make_blocks): Move debug markers after adjacent labels.\n\t* cfgrtl.c (skip_insns_after_block): Revert SFN changes that\n\tallowed debug insns outside blocks.\n\t* df-scan.c (df_insn_delete): Likewise.\n\t* lra-constraints.c (update_ebb_live_info): Likewise.\n\t* var-tracking.c (get_first_insn, vt_emit_notes): Likewise.\n\t(vt_initialize, delete_vta_debug_insns): Likewise.\n\t(reemit_marker_as_note): Drop BB parm.  Adjust callers.\n\nFrom-SVN: r255895", "tree": {"sha": "6093bd1b061517b897df00a25e329bbff6c51b48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6093bd1b061517b897df00a25e329bbff6c51b48"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67a8d7199fe4e474f7bd565161fa2f27d59969fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a8d7199fe4e474f7bd565161fa2f27d59969fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67a8d7199fe4e474f7bd565161fa2f27d59969fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67a8d7199fe4e474f7bd565161fa2f27d59969fc/comments", "author": null, "committer": null, "parents": [{"sha": "8a91d5455313fb3c4fc07935d848921012cb297f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a91d5455313fb3c4fc07935d848921012cb297f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a91d5455313fb3c4fc07935d848921012cb297f"}], "stats": {"total": 290, "additions": 124, "deletions": 166}, "files": [{"sha": "6e98187f0161aaa05603d41411cbd66fbc0cbf3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -1,3 +1,26 @@\n+2017-12-20  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tPR bootstrap/83396\n+\t* cfgexpand.c (label_rtx_for_bb): Revert SFN changes that\n+\tallowed debug stmts before labels.\n+\t(expand_gimple_basic_block): Likewise.\n+\t* gimple-iterator.c (gimple_find_edge_insert_loc): Likewise.\n+\t* gimple-iterator.h (gsi_after_labels): Likewise.\n+\t* tree-cfgcleanup (remove_forwarder_block): Likewise, but\n+\trename reused variable, and simplify using gsi_move_before.\n+\t* tree-ssa-tail-merge.c (find_duplicate): Likewise.\n+\t* tree-cfg.c (make_edges, cleanup_dead_labels): Likewise.\n+\t(gimple_can_merge_blocks_p, verify_gimple_in_cfg): Likewise.\n+\t(gimple_verify_flow_info, gimple_block_label): Likewise.\n+\t(make_blocks): Move debug markers after adjacent labels.\n+\t* cfgrtl.c (skip_insns_after_block): Revert SFN changes that\n+\tallowed debug insns outside blocks.\n+\t* df-scan.c (df_insn_delete): Likewise.\n+\t* lra-constraints.c (update_ebb_live_info): Likewise.\n+\t* var-tracking.c (get_first_insn, vt_emit_notes): Likewise.\n+\t(vt_initialize, delete_vta_debug_insns): Likewise.\n+\t(reemit_marker_as_note): Drop BB parm.  Adjust callers.\n+\n 2017-12-20  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "e616ec17127d92d3a38a3f93f49441167893454c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -2327,9 +2327,6 @@ label_rtx_for_bb (basic_block bb ATTRIBUTE_UNUSED)\n     {\n       glabel *lab_stmt;\n \n-      if (is_gimple_debug (gsi_stmt (gsi)))\n-\tcontinue;\n-\n       lab_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       if (!lab_stmt)\n \tbreak;\n@@ -5502,16 +5499,14 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \t}\n     }\n \n-  gsi = gsi_start_nondebug (stmts);\n+  gsi = gsi_start (stmts);\n   if (!gsi_end_p (gsi))\n     {\n       stmt = gsi_stmt (gsi);\n       if (gimple_code (stmt) != GIMPLE_LABEL)\n \tstmt = NULL;\n     }\n-  gsi = gsi_start (stmts);\n \n-  gimple *label_stmt = stmt;\n   rtx_code_label **elt = lab_rtx_for_bb->get (bb);\n \n   if (stmt || elt)\n@@ -5522,8 +5517,7 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n       if (stmt)\n \t{\n \t  expand_gimple_stmt (stmt);\n-\t  if (gsi_stmt (gsi) == stmt)\n-\t    gsi_next (&gsi);\n+\t  gsi_next (&gsi);\n \t}\n \n       if (elt)\n@@ -5549,9 +5543,6 @@ expand_gimple_basic_block (basic_block bb, bool disable_tail_calls)\n \n       stmt = gsi_stmt (gsi);\n \n-      if (stmt == label_stmt)\n-\tcontinue;\n-\n       /* If this statement is a non-debug one, and we generate debug\n \t insns, then this one might be the last real use of a TERed\n \t SSA_NAME, but where there are still some debug uses further"}, {"sha": "e2da7608a91bd936fb00f5a3c23232b2fbe5b59b", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -3390,9 +3390,6 @@ skip_insns_after_block (basic_block bb)\n \t  last_insn = insn;\n \t  continue;\n \n-\tcase DEBUG_INSN:\n-\t  continue;\n-\n \tcase NOTE:\n \t  switch (NOTE_KIND (insn))\n \t    {"}, {"sha": "7f1bad087247d05ff8a0db72df4abf8b9e9a94a3", "filename": "gcc/df-scan.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -946,7 +946,7 @@ df_insn_delete (rtx_insn *insn)\n      In any case, we expect BB to be non-NULL at least up to register\n      allocation, so disallow a non-NULL BB up to there.  Not perfect\n      but better than nothing...  */\n-  gcc_checking_assert (bb != NULL || DEBUG_INSN_P (insn) || reload_completed);\n+  gcc_checking_assert (bb != NULL || reload_completed);\n \n   df_grow_bb_info (df_scan);\n   df_grow_reg_info ();"}, {"sha": "258bbee7ffceb909c9882feadf4d27caf16cc5ad", "filename": "gcc/gimple-iterator.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fgimple-iterator.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fgimple-iterator.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -743,13 +743,9 @@ gimple_find_edge_insert_loc (edge e, gimple_stmt_iterator *gsi,\n       if (gsi_end_p (*gsi))\n \treturn true;\n \n-      /* Make sure we insert after any leading labels.  We have to\n-\t skip debug stmts before or among them, though.  We didn't\n-\t have to skip debug stmts after the last label, but it\n-\t shouldn't hurt if we do.  */\n+      /* Make sure we insert after any leading labels.  */\n       tmp = gsi_stmt (*gsi);\n-      while (gimple_code (tmp) == GIMPLE_LABEL\n-\t     || is_gimple_debug (tmp))\n+      while (gimple_code (tmp) == GIMPLE_LABEL)\n \t{\n \t  gsi_next (gsi);\n \t  if (gsi_end_p (*gsi))"}, {"sha": "e655ef857fa881b72866866a500b3c97f94eb3b4", "filename": "gcc/gimple-iterator.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fgimple-iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fgimple-iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-iterator.h?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -213,24 +213,17 @@ gsi_stmt (gimple_stmt_iterator i)\n }\n \n /* Return a block statement iterator that points to the first\n-   non-label statement in block BB.  Skip debug stmts only if they\n-   precede labels.  */\n+   non-label statement in block BB.  */\n \n static inline gimple_stmt_iterator\n gsi_after_labels (basic_block bb)\n {\n   gimple_stmt_iterator gsi = gsi_start_bb (bb);\n \n-  for (gimple_stmt_iterator gskip = gsi;\n-       !gsi_end_p (gskip); )\n+  for (; !gsi_end_p (gsi); )\n     {\n-      if (is_gimple_debug (gsi_stmt (gskip)))\n-\tgsi_next (&gskip);\n-      else if (gimple_code (gsi_stmt (gskip)) == GIMPLE_LABEL)\n-\t{\n-\t  gsi_next (&gskip);\n-\t  gsi = gskip;\n-\t}\n+      if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+\tgsi_next (&gsi);\n       else\n \tbreak;\n     }"}, {"sha": "de45d2c0252f3cf00f64790684e35224179452bc", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -5820,13 +5820,6 @@ update_ebb_live_info (rtx_insn *head, rtx_insn *tail)\n       if (NOTE_P (curr_insn) && NOTE_KIND (curr_insn) != NOTE_INSN_BASIC_BLOCK)\n \tcontinue;\n       curr_bb = BLOCK_FOR_INSN (curr_insn);\n-      if (!curr_bb)\n-\t{\n-\t  gcc_assert (DEBUG_INSN_P (curr_insn));\n-\t  if (DEBUG_MARKER_INSN_P (curr_insn))\n-\t    continue;\n-\t  curr_bb = prev_bb;\n-\t}\n       if (curr_bb != prev_bb)\n \t{\n \t  if (prev_bb != NULL)"}, {"sha": "ae5335bc33699afde4ea2b69db7554894610ef5c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -636,6 +636,67 @@ make_blocks_1 (gimple_seq seq, basic_block bb)\n static void\n make_blocks (gimple_seq seq)\n {\n+  /* Look for debug markers right before labels, and move the debug\n+     stmts after the labels.  Accepting labels among debug markers\n+     adds no value, just complexity; if we wanted to annotate labels\n+     with view numbers (so sequencing among markers would matter) or\n+     somesuch, we're probably better off still moving the labels, but\n+     adding other debug annotations in their original positions or\n+     emitting nonbind or bind markers associated with the labels in\n+     the original position of the labels.\n+\n+     Moving labels would probably be simpler, but we can't do that:\n+     moving labels assigns label ids to them, and doing so because of\n+     debug markers makes for -fcompare-debug and possibly even codegen\n+     differences.  So, we have to move the debug stmts instead.  To\n+     that end, we scan SEQ backwards, marking the position of the\n+     latest (earliest we find) label, and moving debug stmts that are\n+     not separated from it by nondebug nonlabel stmts after the\n+     label.  */\n+  if (MAY_HAVE_DEBUG_MARKER_STMTS)\n+    {\n+      gimple_stmt_iterator label = gsi_none ();\n+\n+      for (gimple_stmt_iterator i = gsi_last (seq); !gsi_end_p (i); gsi_prev (&i))\n+\t{\n+\t  gimple *stmt = gsi_stmt (i);\n+\n+\t  /* If this is the first label we encounter (latest in SEQ)\n+\t     before nondebug stmts, record its position.  */\n+\t  if (is_a <glabel *> (stmt))\n+\t    {\n+\t      if (gsi_end_p (label))\n+\t\tlabel = i;\n+\t      continue;\n+\t    }\n+\n+\t  /* Without a recorded label position to move debug stmts to,\n+\t     there's nothing to do.  */\n+\t  if (gsi_end_p (label))\n+\t    continue;\n+\n+\t  /* Move the debug stmt at I after LABEL.  */\n+\t  if (is_gimple_debug (stmt))\n+\t    {\n+\t      gcc_assert (gimple_debug_nonbind_marker_p (stmt));\n+\t      /* As STMT is removed, I advances to the stmt after\n+\t\t STMT, so the gsi_prev in the for \"increment\"\n+\t\t expression gets us to the stmt we're to visit after\n+\t\t STMT.  LABEL, however, would advance to the moved\n+\t\t stmt if we passed it to gsi_move_after, so pass it a\n+\t\t copy instead, so as to keep LABEL pointing to the\n+\t\t LABEL.  */\n+\t      gimple_stmt_iterator copy = label;\n+\t      gsi_move_after (&i, &copy);\n+\t      continue;\n+\t    }\n+\n+\t  /* There aren't any (more?) debug stmts before label, so\n+\t     there isn't anything else to move after it.  */\n+\t  label = gsi_none ();\n+\t}\n+    }\n+\n   make_blocks_1 (seq, ENTRY_BLOCK_PTR_FOR_FN (cfun));\n }\n \n@@ -1005,11 +1066,7 @@ make_edges (void)\n \t      tree target;\n \n \t      if (!label_stmt)\n-\t\t{\n-\t\t  if (is_gimple_debug (gsi_stmt (gsi)))\n-\t\t    continue;\n-\t\t  break;\n-\t\t}\n+\t\tbreak;\n \n \t      target = gimple_label_label (label_stmt);\n \n@@ -1519,9 +1576,6 @@ cleanup_dead_labels (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); gsi_next (&i))\n \t{\n-\t  if (is_gimple_debug (gsi_stmt (i)))\n-\t    continue;\n-\n \t  tree label;\n \t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n@@ -1682,12 +1736,6 @@ cleanup_dead_labels (void)\n \n       for (i = gsi_start_bb (bb); !gsi_end_p (i); )\n \t{\n-\t  if (is_gimple_debug (gsi_stmt (i)))\n-\t    {\n-\t      gsi_next (&i);\n-\t      continue;\n-\t    }\n-\n \t  tree label;\n \t  glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (i));\n \n@@ -1863,8 +1911,6 @@ gimple_can_merge_blocks_p (basic_block a, basic_block b)\n        gsi_next (&gsi))\n     {\n       tree lab;\n-      if (is_gimple_debug (gsi_stmt (gsi)))\n-\tcontinue;\n       glabel *label_stmt = dyn_cast <glabel *> (gsi_stmt (gsi));\n       if (!label_stmt)\n \tbreak;\n@@ -5431,7 +5477,6 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t  err |= err2;\n \t}\n \n-      bool label_allowed = true;\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  gimple *stmt = gsi_stmt (gsi);\n@@ -5448,19 +5493,6 @@ verify_gimple_in_cfg (struct function *fn, bool verify_nothrow)\n \t      err2 = true;\n \t    }\n \n-\t  /* Labels may be preceded only by debug markers, not debug bind\n-\t     or source bind or any other statements.  */\n-\t  if (gimple_code (stmt) == GIMPLE_LABEL)\n-\t    {\n-\t      if (!label_allowed)\n-\t\t{\n-\t\t  error (\"gimple label in the middle of a basic block\");\n-\t\t  err2 = true;\n-\t\t}\n-\t    }\n-\t  else if (!gimple_debug_begin_stmt_p (stmt))\n-\t    label_allowed = false;\n-\n \t  err2 |= verify_gimple_stmt (stmt);\n \t  err2 |= verify_location (&blocks, gimple_location (stmt));\n \n@@ -5584,10 +5616,6 @@ gimple_verify_flow_info (void)\n       for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n \t{\n \t  tree label;\n-\n-\t  if (is_gimple_debug (gsi_stmt (gsi)))\n-\t    continue;\n-\n \t  gimple *prev_stmt = stmt;\n \n \t  stmt = gsi_stmt (gsi);\n@@ -5912,10 +5940,8 @@ gimple_block_label (basic_block bb)\n   tree label;\n   glabel *stmt;\n \n-  for (i = s; !gsi_end_p (i); gsi_next (&i))\n+  for (i = s; !gsi_end_p (i); first = false, gsi_next (&i))\n     {\n-      if (is_gimple_debug (gsi_stmt (i)))\n-\tcontinue;\n       stmt = dyn_cast <glabel *> (gsi_stmt (i));\n       if (!stmt)\n \tbreak;\n@@ -5926,7 +5952,6 @@ gimple_block_label (basic_block bb)\n \t    gsi_move_before (&i, &s);\n \t  return label;\n \t}\n-      first = false;\n     }\n \n   label = create_artificial_label (UNKNOWN_LOCATION);"}, {"sha": "bfcca03257d34008c8f1ebc052eebdd097d20759", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 21, "deletions": 28, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -444,7 +444,7 @@ remove_forwarder_block (basic_block bb)\n {\n   edge succ = single_succ_edge (bb), e, s;\n   basic_block dest = succ->dest;\n-  gimple *label;\n+  gimple *stmt;\n   edge_iterator ei;\n   gimple_stmt_iterator gsi, gsi_to;\n   bool can_move_debug_stmts;\n@@ -457,9 +457,9 @@ remove_forwarder_block (basic_block bb)\n \n   /* If the destination block consists of a nonlocal label or is a\n      EH landing pad, do not merge it.  */\n-  label = first_stmt (dest);\n-  if (label)\n-    if (glabel *label_stmt = dyn_cast <glabel *> (label))\n+  stmt = first_stmt (dest);\n+  if (stmt)\n+    if (glabel *label_stmt = dyn_cast <glabel *> (stmt))\n       if (DECL_NONLOCAL (gimple_label_label (label_stmt))\n \t  || EH_LANDING_PAD_NR (gimple_label_label (label_stmt)) != 0)\n \treturn false;\n@@ -536,43 +536,36 @@ remove_forwarder_block (basic_block bb)\n      defined labels and labels with an EH landing pad number to the\n      new block, so that the redirection of the abnormal edges works,\n      jump targets end up in a sane place and debug information for\n-     labels is retained.\n-\n-     While at that, move any debug stmts that appear before or in between\n-     labels, but not those that can only appear after labels.  */\n+     labels is retained.  */\n   gsi_to = gsi_start_bb (dest);\n-  gsi = gsi_start_bb (bb);\n-  gimple_stmt_iterator gsie = gsi_after_labels (bb);\n-  while (gsi_stmt (gsi) != gsi_stmt (gsie))\n+  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n     {\n-      tree decl;\n-      label = gsi_stmt (gsi);\n-      if (is_gimple_debug (label)\n-\t  ? can_move_debug_stmts\n-\t  : ((decl = gimple_label_label (as_a <glabel *> (label))),\n-\t     EH_LANDING_PAD_NR (decl) != 0\n-\t     || DECL_NONLOCAL (decl)\n-\t     || FORCED_LABEL (decl)\n-\t     || !DECL_ARTIFICIAL (decl)))\n-\t{\n-\t  gsi_remove (&gsi, false);\n-\t  gsi_insert_before (&gsi_to, label, GSI_SAME_STMT);\n-\t}\n+      stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tbreak;\n+\n+      /* Forwarder blocks can only contain labels and debug stmts, and\n+\t labels must come first, so if we get to this point, we know\n+\t we're looking at a label.  */\n+      tree decl = gimple_label_label (as_a <glabel *> (stmt));\n+      if (EH_LANDING_PAD_NR (decl) != 0\n+\t  || DECL_NONLOCAL (decl)\n+\t  || FORCED_LABEL (decl)\n+\t  || !DECL_ARTIFICIAL (decl))\n+\tgsi_move_before (&gsi, &gsi_to);\n       else\n \tgsi_next (&gsi);\n     }\n \n   /* Move debug statements if the destination has a single predecessor.  */\n   if (can_move_debug_stmts && !gsi_end_p (gsi))\n     {\n-      gcc_assert (gsi_stmt (gsi) == gsi_stmt (gsie));\n-      gimple_stmt_iterator gsie_to = gsi_after_labels (dest);\n+      gsi_to = gsi_after_labels (dest);\n       do\n \t{\n \t  gimple *debug = gsi_stmt (gsi);\n \t  gcc_assert (is_gimple_debug (debug));\n-\t  gsi_remove (&gsi, false);\n-\t  gsi_insert_before (&gsie_to, debug, GSI_SAME_STMT);\n+\t  gsi_move_before (&gsi, &gsi_to);\n \t}\n       while (!gsi_end_p (gsi));\n     }"}, {"sha": "fc94f5d83d2c926cd5186f81602618e15c78c25f", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -1295,14 +1295,14 @@ find_duplicate (same_succ *same_succ, basic_block bb1, basic_block bb2)\n       tree label = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi1)));\n       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n \treturn;\n-      gsi_prev_nondebug (&gsi1);\n+      gsi_prev (&gsi1);\n     }\n   while (!gsi_end_p (gsi2) && gimple_code (gsi_stmt (gsi2)) == GIMPLE_LABEL)\n     {\n       tree label = gimple_label_label (as_a <glabel *> (gsi_stmt (gsi2)));\n       if (DECL_NONLOCAL (label) || FORCED_LABEL (label))\n \treturn;\n-      gsi_prev_nondebug (&gsi2);\n+      gsi_prev (&gsi2);\n     }\n   if (!(gsi_end_p (gsi1) && gsi_end_p (gsi2)))\n     return;"}, {"sha": "77281fb45ee228e8cb802bcf61aff989c9b2c580", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 6, "deletions": 59, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67a8d7199fe4e474f7bd565161fa2f27d59969fc/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=67a8d7199fe4e474f7bd565161fa2f27d59969fc", "patch": "@@ -9511,24 +9511,6 @@ emit_notes_in_bb (basic_block bb, dataflow_set *set)\n     }\n }\n \n-/* Return BB's head, unless BB is the block that succeeds ENTRY_BLOCK,\n-   in which case it searches back from BB's head for the very first\n-   insn.  Use [get_first_insn (bb), BB_HEAD (bb->next_bb)[ as a range\n-   to iterate over all insns of a function while iterating over its\n-   BBs.  */\n-\n-static rtx_insn *\n-get_first_insn (basic_block bb)\n-{\n-  rtx_insn *insn = BB_HEAD (bb);\n-\n-  if (bb->prev_bb == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-    while (rtx_insn *prev = PREV_INSN (insn))\n-      insn = prev;\n-\n-  return insn;\n-}\n-\n /* Emit notes for the whole function.  */\n \n static void\n@@ -9557,8 +9539,7 @@ vt_emit_notes (void)\n     {\n       /* Emit the notes for changes of variable locations between two\n \t subsequent basic blocks.  */\n-      emit_notes_for_differences (get_first_insn (bb),\n-\t\t\t\t  &cur, &VTI (bb)->in);\n+      emit_notes_for_differences (BB_HEAD (bb), &cur, &VTI (bb)->in);\n \n       if (MAY_HAVE_DEBUG_BIND_INSNS)\n \tlocal_get_addr_cache = new hash_map<rtx, rtx>;\n@@ -9966,7 +9947,7 @@ vt_init_cfa_base (void)\n /* Reemit INSN, a MARKER_DEBUG_INSN, as a note.  */\n \n static rtx_insn *\n-reemit_marker_as_note (rtx_insn *insn, basic_block *bb)\n+reemit_marker_as_note (rtx_insn *insn)\n {\n   gcc_checking_assert (DEBUG_MARKER_INSN_P (insn));\n \n@@ -9981,8 +9962,6 @@ reemit_marker_as_note (rtx_insn *insn, basic_block *bb)\n \t  {\n \t    note = emit_note_before (kind, insn);\n \t    NOTE_MARKER_LOCATION (note) = INSN_LOCATION (insn);\n-\t    if (bb)\n-\t      BLOCK_FOR_INSN (note) = *bb;\n \t  }\n \tdelete_insn (insn);\n \treturn note;\n@@ -10190,39 +10169,11 @@ vt_initialize (void)\n \t  HOST_WIDE_INT offset = VTI (bb)->out.stack_adjust;\n \t  VTI (bb)->out.stack_adjust = VTI (bb)->in.stack_adjust;\n \n-\t  /* If we are walking the first basic block, walk any HEADER\n-\t     insns that might be before it too.  Unfortunately,\n-\t     BB_HEADER and BB_FOOTER are not set while we run this\n-\t     pass.  */\n \t  rtx_insn *next;\n-\t  bool outside_bb = true;\n-\t  for (insn = get_first_insn (bb); insn != BB_HEAD (bb->next_bb);\n-\t       insn = next)\n+\t  FOR_BB_INSNS_SAFE (bb, insn, next)\n \t    {\n-\t      if (insn == BB_HEAD (bb))\n-\t\toutside_bb = false;\n-\t      else if (insn == NEXT_INSN (BB_END (bb)))\n-\t\toutside_bb = true;\n-\t      next = NEXT_INSN (insn);\n \t      if (INSN_P (insn))\n \t\t{\n-\t\t  if (outside_bb)\n-\t\t    {\n-\t\t      /* Ignore non-debug insns outside of basic blocks.  */\n-\t\t      if (!DEBUG_INSN_P (insn))\n-\t\t\tcontinue;\n-\t\t      /* Debug binds shouldn't appear outside of bbs.  */\n-\t\t      gcc_assert (!DEBUG_BIND_INSN_P (insn));\n-\t\t    }\n-\t\t  basic_block save_bb = BLOCK_FOR_INSN (insn);\n-\t\t  if (!BLOCK_FOR_INSN (insn))\n-\t\t    {\n-\t\t      gcc_assert (outside_bb);\n-\t\t      BLOCK_FOR_INSN (insn) = bb;\n-\t\t    }\n-\t\t  else\n-\t\t    gcc_assert (BLOCK_FOR_INSN (insn) == bb);\n-\n \t\t  if (!frame_pointer_needed)\n \t\t    {\n \t\t      insn_stack_adjust_offset_pre_post (insn, &pre, &post);\n@@ -10244,7 +10195,7 @@ vt_initialize (void)\n \t\t  adjust_insn (bb, insn);\n \t\t  if (DEBUG_MARKER_INSN_P (insn))\n \t\t    {\n-\t\t      insn = reemit_marker_as_note (insn, &save_bb);\n+\t\t      reemit_marker_as_note (insn);\n \t\t      continue;\n \t\t    }\n \n@@ -10296,7 +10247,6 @@ vt_initialize (void)\n \t\t\t    }\n \t\t\t}\n \t\t    }\n-\t\t  BLOCK_FOR_INSN (insn) = save_bb;\n \t\t}\n \t    }\n \t  gcc_assert (offset == VTI (bb)->out.stack_adjust);\n@@ -10338,15 +10288,12 @@ delete_vta_debug_insns (void)\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n-      for (insn = get_first_insn (bb);\n-\t   insn != BB_HEAD (bb->next_bb)\n-\t     ? next = NEXT_INSN (insn), true : false;\n-\t   insn = next)\n+      FOR_BB_INSNS_SAFE (bb, insn, next)\n \tif (DEBUG_INSN_P (insn))\n \t  {\n \t    if (DEBUG_MARKER_INSN_P (insn))\n \t      {\n-\t\tinsn = reemit_marker_as_note (insn, NULL);\n+\t\treemit_marker_as_note (insn);\n \t\tcontinue;\n \t      }\n "}]}