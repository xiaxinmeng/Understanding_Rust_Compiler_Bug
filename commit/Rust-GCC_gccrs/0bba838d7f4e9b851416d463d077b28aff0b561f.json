{"sha": "0bba838d7f4e9b851416d463d077b28aff0b561f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiYTgzOGQ3ZjRlOWI4NTE0MTZkNDYzZDA3N2IyOGFmZjBiNTYxZg==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2019-12-16T10:34:22Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-12-16T10:34:22Z"}, "message": "[Ada] Syntax error on improperly indented imported subprogram\n\n2019-12-16  Bob Duff  <duff@adacore.com>\n\ngcc/ada/\n\n\t* par.adb: Add Scopes function to do range checking on the scope\n\tstack.  Call Scopes all over the parser.  Add\n\tSIS_Aspect_Import_Seen flag.\n\t* par-ch6.adb (P_Subprogram): Initialize SIS_Aspect_Import_Seen\n\tto False at the start, and check it at the end.\n\t* par-ch13.adb (Get_Aspect_Specifications): Set\n\tSIS_Aspect_Import_Seen to True when appropriate.\n\t* par-ch10.adb, par-ch12.adb, par-ch2.adb, par-ch3.adb,\n\tpar-ch5.adb, par-ch7.adb, par-ch9.adb, par-endh.adb,\n\tpar-util.adb: Call Scopes.\n\nFrom-SVN: r279428", "tree": {"sha": "0cf75e351f183df935e1cfbea6da0358164e9618", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cf75e351f183df935e1cfbea6da0358164e9618"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bba838d7f4e9b851416d463d077b28aff0b561f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bba838d7f4e9b851416d463d077b28aff0b561f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bba838d7f4e9b851416d463d077b28aff0b561f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bba838d7f4e9b851416d463d077b28aff0b561f/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17a98a3dbb7f4c0d9d734bbc8890d94daa2aa4c9"}], "stats": {"total": 419, "additions": 232, "deletions": 187}, "files": [{"sha": "a4ab24a5d6f3616b6c67ec0718f63f99b276443d", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -1,3 +1,16 @@\n+2019-12-16  Bob Duff  <duff@adacore.com>\n+\n+\t* par.adb: Add Scopes function to do range checking on the scope\n+\tstack.  Call Scopes all over the parser.  Add\n+\tSIS_Aspect_Import_Seen flag.\n+\t* par-ch6.adb (P_Subprogram): Initialize SIS_Aspect_Import_Seen\n+\tto False at the start, and check it at the end.\n+\t* par-ch13.adb (Get_Aspect_Specifications): Set\n+\tSIS_Aspect_Import_Seen to True when appropriate.\n+\t* par-ch10.adb, par-ch12.adb, par-ch2.adb, par-ch3.adb,\n+\tpar-ch5.adb, par-ch7.adb, par-ch9.adb, par-endh.adb,\n+\tpar-util.adb: Call Scopes.\n+\n 2019-12-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* sem_prag.adb (Atomic_Components): Remove local variable and"}, {"sha": "34323b8229c2d2c1e1754cf3cf19e06f7e83397a", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -397,10 +397,10 @@ package body Ch10 is\n                or else Token in Token_Class_Deckn\n             then\n                Push_Scope_Stack;\n-               Scope.Table (Scope.Last).Etyp := E_Name;\n-               Scope.Table (Scope.Last).Sloc := SIS_Sloc;\n-               Scope.Table (Scope.Last).Ecol := SIS_Ecol;\n-               Scope.Table (Scope.Last).Lreq := False;\n+               Scopes (Scope.Last).Etyp := E_Name;\n+               Scopes (Scope.Last).Sloc := SIS_Sloc;\n+               Scopes (Scope.Last).Ecol := SIS_Ecol;\n+               Scopes (Scope.Last).Lreq := False;\n                SIS_Entry_Active := False;\n \n                --  If we had a missing semicolon in the declaration, then"}, {"sha": "3216927a9e6b1b6231ba7d4aaa00217e9e897b3b", "filename": "gcc/ada/par-ch12.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch12.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -302,7 +302,7 @@ package body Ch12 is\n \n       elsif Token /= Tok_Left_Paren\n         and then Token_Is_At_Start_Of_Line\n-        and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+        and then Start_Column <= Scopes (Scope.Last).Ecol\n       then\n          return No_List;\n "}, {"sha": "25a0df998fc1a2d37aab68035d6046def494f0da", "filename": "gcc/ada/par-ch13.adb", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch13.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -528,7 +528,15 @@ package body Ch13 is\n                   Inside_Depends := True;\n                end if;\n \n-               --  Parse the aspect definition depening on the expected\n+               --  Note that we have seen an Import aspect specification.\n+               --  This matters only while parsing a subprogram.\n+\n+               if A_Id = Aspect_Import then\n+                  SIS_Aspect_Import_Seen := True;\n+                  --  Should do it only for subprograms\n+               end if;\n+\n+               --  Parse the aspect definition depending on the expected\n                --  argument kind.\n \n                if Aspect_Argument (A_Id) = Name\n@@ -826,9 +834,9 @@ package body Ch13 is\n             Set_Identifier (Rep_Clause_Node, Identifier_Node);\n \n             Push_Scope_Stack;\n-            Scope.Table (Scope.Last).Etyp := E_Record;\n-            Scope.Table (Scope.Last).Ecol := Start_Column;\n-            Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+            Scopes (Scope.Last).Etyp := E_Record;\n+            Scopes (Scope.Last).Ecol := Start_Column;\n+            Scopes (Scope.Last).Sloc := Token_Ptr;\n             Scan; -- past RECORD\n             Record_Items := P_Pragmas_Opt;\n "}, {"sha": "ae055aff01f4e59734ed49214762307a573a8dcd", "filename": "gcc/ada/par-ch2.adb", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch2.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -247,11 +247,8 @@ package body Ch2 is\n \n       --  Local variables\n \n-      Interface_Check_Required : Boolean := False;\n-      --  Set True if check of pragma INTERFACE is required\n-\n       Import_Check_Required : Boolean := False;\n-      --  Set True if check of pragma IMPORT is required\n+      --  Set True if check of pragma IMPORT or INTERFACE is required\n \n       Arg_Count : Nat := 0;\n       --  Number of argument associations processed\n@@ -295,11 +292,10 @@ package body Ch2 is\n       --  See if special INTERFACE/IMPORT check is required\n \n       if SIS_Entry_Active then\n-         Interface_Check_Required := (Prag_Name = Name_Interface);\n-         Import_Check_Required    := (Prag_Name = Name_Import);\n+         Import_Check_Required :=\n+           (Prag_Name = Name_Import) or else (Prag_Name = Name_Interface);\n       else\n-         Interface_Check_Required := False;\n-         Import_Check_Required    := False;\n+         Import_Check_Required := False;\n       end if;\n \n       --  Set global to indicate if we are within a Depends pragma\n@@ -331,9 +327,7 @@ package body Ch2 is\n                  Nam_In (Prag_Name, Name_Restriction_Warnings,\n                                     Name_Restrictions));\n \n-            if Arg_Count = 2\n-              and then (Interface_Check_Required or else Import_Check_Required)\n-            then\n+            if Arg_Count = 2 and then Import_Check_Required then\n                --  Here is where we cancel the SIS active status if this pragma\n                --  supplies a body for the currently active subprogram spec.\n "}, {"sha": "2b054b215600e8c0346570b4c2c9efb9af3919ca", "filename": "gcc/ada/par-ch3.adb", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch3.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -3338,11 +3338,11 @@ package body Ch3 is\n \n       else\n          Push_Scope_Stack;\n-         Scope.Table (Scope.Last).Etyp := E_Record;\n-         Scope.Table (Scope.Last).Ecol := Start_Column;\n-         Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-         Scope.Table (Scope.Last).Labl := Error;\n-         Scope.Table (Scope.Last).Junk := (Token /= Tok_Record);\n+         Scopes (Scope.Last).Etyp := E_Record;\n+         Scopes (Scope.Last).Ecol := Start_Column;\n+         Scopes (Scope.Last).Sloc := Token_Ptr;\n+         Scopes (Scope.Last).Labl := Error;\n+         Scopes (Scope.Last).Junk := (Token /= Tok_Record);\n \n          T_Record;\n \n@@ -3419,7 +3419,7 @@ package body Ch3 is\n             --  additional clue that confirms the incorrect spelling.\n \n             if Token /= Tok_Identifier then\n-               if Start_Column > Scope.Table (Scope.Last).Ecol\n+               if Start_Column > Scopes (Scope.Last).Ecol\n                  and then Is_Reserved_Identifier\n                then\n                   Save_Scan_State (Scan_State); -- at reserved id\n@@ -3661,9 +3661,9 @@ package body Ch3 is\n    begin\n       Variant_Part_Node := New_Node (N_Variant_Part, Token_Ptr);\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Case;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Etyp := E_Case;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n \n       Scan; -- past CASE\n       Case_Node := P_Expression;\n@@ -4514,11 +4514,11 @@ package body Ch3 is\n                   --  scan it out\n \n                   Push_Scope_Stack;\n-                  Scope.Table (Scope.Last).Sloc := SIS_Sloc;\n-                  Scope.Table (Scope.Last).Etyp := E_Name;\n-                  Scope.Table (Scope.Last).Ecol := SIS_Ecol;\n-                  Scope.Table (Scope.Last).Labl := SIS_Labl;\n-                  Scope.Table (Scope.Last).Lreq := False;\n+                  Scopes (Scope.Last).Sloc := SIS_Sloc;\n+                  Scopes (Scope.Last).Etyp := E_Name;\n+                  Scopes (Scope.Last).Ecol := SIS_Ecol;\n+                  Scopes (Scope.Last).Labl := SIS_Labl;\n+                  Scopes (Scope.Last).Lreq := False;\n                   SIS_Entry_Active := False;\n                   Scan; -- past BEGIN\n                   Set_Handled_Statement_Sequence (Body_Node,"}, {"sha": "426bbd57292035043174e69740321ef7dcf00b2e", "filename": "gcc/ada/par-ch5.adb", "status": "modified", "additions": 60, "deletions": 59, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch5.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -358,7 +358,7 @@ package body Ch5 is\n                   --  of the expected column of the end for this sequence\n \n                   if SS_Flags.Eftm\n-                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                     or else Start_Column < Scopes (Scope.Last).Ecol\n                   then\n                      Test_Statement_Required;\n                      exit;\n@@ -381,7 +381,7 @@ package body Ch5 is\n                   --  of the expected column of the end for this sequence\n \n                   if SS_Flags.Eltm\n-                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                     or else Start_Column < Scopes (Scope.Last).Ecol\n                   then\n                      Test_Statement_Required;\n                      exit;\n@@ -405,7 +405,7 @@ package body Ch5 is\n                   --  is not permitted.\n \n                   if not SS_Flags.Extm and then\n-                     Start_Column >= Scope.Table (Scope.Last).Ecol\n+                     Start_Column >= Scopes (Scope.Last).Ecol\n \n                   then\n                      Error_Msg_SC (\"exception handler not permitted here\");\n@@ -427,7 +427,7 @@ package body Ch5 is\n                   --  expected column of the end for this sequence.\n \n                   if SS_Flags.Ortm\n-                     or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                     or else Start_Column < Scopes (Scope.Last).Ecol\n                   then\n                      Test_Statement_Required;\n                      exit;\n@@ -467,7 +467,7 @@ package body Ch5 is\n                   --  the expected column of the end for this sequence.\n \n                   if SS_Flags.Whtm\n-                    or else Start_Column < Scope.Table (Scope.Last).Ecol\n+                    or else Start_Column < Scopes (Scope.Last).Ecol\n                   then\n                      Test_Statement_Required;\n                      exit;\n@@ -1142,9 +1142,9 @@ package body Ch5 is\n       procedure Check_If_Column is\n       begin\n          if RM_Column_Check and then Token_Is_At_Start_Of_Line\n-           and then Start_Column /= Scope.Table (Scope.Last).Ecol\n+           and then Start_Column /= Scopes (Scope.Last).Ecol\n          then\n-            Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+            Error_Msg_Col := Scopes (Scope.Last).Ecol;\n             Error_Msg_SC (\"(style) this token should be@\");\n          end if;\n       end Check_If_Column;\n@@ -1192,11 +1192,11 @@ package body Ch5 is\n       If_Node := New_Node (N_If_Statement, Token_Ptr);\n \n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_If;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Labl := Error;\n-      Scope.Table (Scope.Last).Node := If_Node;\n+      Scopes (Scope.Last).Etyp := E_If;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Labl := Error;\n+      Scopes (Scope.Last).Node := If_Node;\n \n       if Token = Tok_If then\n          Loc := Token_Ptr;\n@@ -1350,11 +1350,11 @@ package body Ch5 is\n       Case_Node := New_Node (N_Case_Statement, Token_Ptr);\n \n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Case;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Labl := Error;\n-      Scope.Table (Scope.Last).Node := Case_Node;\n+      Scopes (Scope.Last).Etyp := E_Case;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Labl := Error;\n+      Scopes (Scope.Last).Node := Case_Node;\n \n       Scan; -- past CASE\n       Set_Expression (Case_Node, P_Expression_No_Right_Paren);\n@@ -1392,7 +1392,7 @@ package body Ch5 is\n          --  complain about the missing WHEN, and discard the junk statements.\n \n          elsif not Token_Is_At_Start_Of_Line\n-           or else Start_Column > Scope.Table (Scope.Last).Ecol\n+           or else Start_Column > Scopes (Scope.Last).Ecol\n          then\n             Error_Msg_BC (\"WHEN (case statement alternative) expected\");\n \n@@ -1490,10 +1490,10 @@ package body Ch5 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Labl := Loop_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Etyp := E_Loop;\n+      Scopes (Scope.Last).Labl := Loop_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Loop;\n \n       Loop_Node := New_Node (N_Loop_Statement, Token_Ptr);\n       TF_Loop;\n@@ -1504,7 +1504,7 @@ package body Ch5 is\n          Set_Comes_From_Source (Created_Name, False);\n          Set_Has_Created_Identifier (Loop_Node, True);\n          Set_Identifier (Loop_Node, Created_Name);\n-         Scope.Table (Scope.Last).Labl := Created_Name;\n+         Scopes (Scope.Last).Labl := Created_Name;\n       else\n          Set_Identifier (Loop_Node, Loop_Name);\n       end if;\n@@ -1536,10 +1536,10 @@ package body Ch5 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Labl := Loop_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Etyp := E_Loop;\n+      Scopes (Scope.Last).Labl := Loop_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Loop;\n \n       Loop_For_Flag := (Prev_Token = Tok_Loop);\n       Scan; -- past FOR\n@@ -1575,7 +1575,7 @@ package body Ch5 is\n             Set_Comes_From_Source (Created_Name, False);\n             Set_Has_Created_Identifier (Loop_Node, True);\n             Set_Identifier (Loop_Node, Created_Name);\n-            Scope.Table (Scope.Last).Labl := Created_Name;\n+            Scopes (Scope.Last).Labl := Created_Name;\n          else\n             Set_Identifier (Loop_Node, Loop_Name);\n          end if;\n@@ -1607,10 +1607,10 @@ package body Ch5 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Labl := Loop_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Etyp := E_Loop;\n+      Scopes (Scope.Last).Labl := Loop_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Loop;\n \n       Loop_While_Flag := (Prev_Token = Tok_Loop);\n       Iter_Scheme_Node := New_Node (N_Iteration_Scheme, Token_Ptr);\n@@ -1641,7 +1641,7 @@ package body Ch5 is\n             Set_Comes_From_Source (Created_Name, False);\n             Set_Has_Created_Identifier (Loop_Node, True);\n             Set_Identifier (Loop_Node, Created_Name);\n-            Scope.Table (Scope.Last).Labl := Created_Name;\n+            Scopes (Scope.Last).Labl := Created_Name;\n          else\n             Set_Identifier (Loop_Node, Loop_Name);\n          end if;\n@@ -1805,11 +1805,11 @@ package body Ch5 is\n       Block_Node := New_Node (N_Block_Statement, Token_Ptr);\n \n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Lreq := Present (Block_Name);\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Labl := Block_Name;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Lreq := Present (Block_Name);\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Labl := Block_Name;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n \n       Scan; -- past DECLARE\n \n@@ -1819,7 +1819,7 @@ package body Ch5 is\n          Set_Comes_From_Source (Created_Name, False);\n          Set_Has_Created_Identifier (Block_Node, True);\n          Set_Identifier (Block_Node, Created_Name);\n-         Scope.Table (Scope.Last).Labl := Created_Name;\n+         Scopes (Scope.Last).Labl := Created_Name;\n       else\n          Set_Identifier (Block_Node, Block_Name);\n       end if;\n@@ -1848,27 +1848,27 @@ package body Ch5 is\n       Block_Node := New_Node (N_Block_Statement, Token_Ptr);\n \n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Lreq := Present (Block_Name);\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Labl := Block_Name;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Lreq := Present (Block_Name);\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Labl := Block_Name;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n \n       if No (Block_Name) then\n          Created_Name :=\n            Make_Identifier (Sloc (Block_Node), Set_Loop_Block_Name ('B'));\n          Set_Comes_From_Source (Created_Name, False);\n          Set_Has_Created_Identifier (Block_Node, True);\n          Set_Identifier (Block_Node, Created_Name);\n-         Scope.Table (Scope.Last).Labl := Created_Name;\n+         Scopes (Scope.Last).Labl := Created_Name;\n       else\n          Set_Identifier (Block_Node, Block_Name);\n       end if;\n \n       Append_Elmt (Block_Node, Label_List);\n \n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n       Scan; -- past BEGIN\n       Set_Handled_Statement_Sequence\n         (Block_Node, P_Handled_Sequence_Of_Statements);\n@@ -1913,7 +1913,7 @@ package body Ch5 is\n          if not Token_Is_At_Start_Of_Line then\n             return False;\n \n-         elsif Scope.Table (Scope.Last).Etyp /= E_Case then\n+         elsif Scopes (Scope.Last).Etyp /= E_Case then\n             return False;\n \n          else\n@@ -1946,13 +1946,13 @@ package body Ch5 is\n \n          Check_No_Exit_Name :\n          for J in reverse 1 .. Scope.Last loop\n-            if Scope.Table (J).Etyp = E_Loop then\n-               if Present (Scope.Table (J).Labl)\n-                 and then Comes_From_Source (Scope.Table (J).Labl)\n+            if Scopes (J).Etyp = E_Loop then\n+               if Present (Scopes (J).Labl)\n+                 and then Comes_From_Source (Scopes (J).Labl)\n                then\n                   --  Innermost loop in fact had a name, style check fails\n \n-                  Style.No_Exit_Name (Scope.Table (J).Labl);\n+                  Style.No_Exit_Name (Scopes (J).Labl);\n                end if;\n \n                exit Check_No_Exit_Name;\n@@ -2154,7 +2154,7 @@ package body Ch5 is\n                Style.Check_Indentation;\n             end if;\n \n-            Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+            Error_Msg_Col := Scopes (Scope.Last).Ecol;\n \n             if RM_Column_Check\n               and then Token_Is_At_Start_Of_Line\n@@ -2163,10 +2163,10 @@ package body Ch5 is\n                Error_Msg_SC (\"(style) BEGIN in wrong column, should be@\");\n \n             else\n-               Scope.Table (Scope.Last).Ecol := Start_Column;\n+               Scopes (Scope.Last).Ecol := Start_Column;\n             end if;\n \n-            Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+            Scopes (Scope.Last).Sloc := Token_Ptr;\n             Scan; -- past BEGIN\n             Set_Handled_Statement_Sequence (Parent,\n               P_Handled_Sequence_Of_Statements);\n@@ -2183,9 +2183,9 @@ package body Ch5 is\n \n             if Parent_Nkind = N_Subprogram_Body\n               and then Token  = Tok_End\n-              and then Scope.Table (Scope.Last).Etyp = E_Suspicious_Is\n+              and then Scopes (Scope.Last).Etyp = E_Suspicious_Is\n             then\n-               Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+               Scopes (Scope.Last).Etyp := E_Bad_Is;\n \n             --  Otherwise BEGIN is not required for a package body, so we\n             --  don't mind if it is missing, but we do construct a dummy\n@@ -2211,8 +2211,8 @@ package body Ch5 is\n \n                --  Prepare to issue error message\n \n-               Error_Msg_Sloc := Scope.Table (Scope.Last).Sloc;\n-               Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+               Error_Msg_Sloc := Scopes (Scope.Last).Sloc;\n+               Error_Msg_Node_1 := Scopes (Scope.Last).Labl;\n \n                --  Now issue appropriate message\n \n@@ -2272,6 +2272,7 @@ package body Ch5 is\n       --  (because it is required to do so under all circumstances). We can\n       --  therefore reference the entry it removed one past the stack top.\n       --  What we are interested in is whether it was a case of a bad IS.\n+      --  We can't call Scopes here.\n \n       if Scope.Table (Scope.Last + 1).Etyp = E_Bad_Is then\n          Error_Msg -- CODEFIX"}, {"sha": "bf7f9719b656eb7ad457b047117d8af7d0d01473", "filename": "gcc/ada/par-ch6.adb", "status": "modified", "additions": 25, "deletions": 19, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch6.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -229,12 +229,13 @@ package body Ch6 is\n       --  Set up scope stack entry. Note that the Labl field will be set later\n \n       SIS_Entry_Active := False;\n+      SIS_Aspect_Import_Seen := False;\n       SIS_Missing_Semicolon_Message := No_Error_Msg;\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Lreq := False;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Lreq := False;\n \n       Aspects := Empty_List;\n \n@@ -335,7 +336,7 @@ package body Ch6 is\n          Name_Node := P_Defining_Program_Unit_Name;\n       end if;\n \n-      Scope.Table (Scope.Last).Labl := Name_Node;\n+      Scopes (Scope.Last).Labl := Name_Node;\n       Current_Node := Name_Node;\n       Ignore (Tok_Colon);\n \n@@ -533,7 +534,7 @@ package body Ch6 is\n          --  i.e. that the terminating semicolon should have been IS.\n \n          elsif Token = Tok_Begin\n-            and then Start_Column >= Scope.Table (Scope.Last).Ecol\n+            and then Start_Column >= Scopes (Scope.Last).Ecol\n          then\n             Error_Msg_SP -- CODEFIX\n               (\"|\"\";\"\" should be IS!\");\n@@ -764,7 +765,7 @@ package body Ch6 is\n \n                            Spec_Node : constant Node_Id :=\n                                          Parent\n-                                           (Scope.Table (Scope.Last).Labl);\n+                                           (Scopes (Scope.Last).Labl);\n                            Lib_Node : Node_Id := Spec_Node;\n \n                         begin\n@@ -773,7 +774,7 @@ package body Ch6 is\n \n                            if Scope.Last > 1 then\n                               Lib_Node  :=\n-                                Parent (Scope.Table (Scope.Last - 1).Labl);\n+                                Parent (Scopes (Scope.Last - 1).Labl);\n                            end if;\n \n                            if Ada_Version >= Ada_2012\n@@ -917,11 +918,11 @@ package body Ch6 is\n                   if (Token in Token_Class_Declk\n                         or else\n                       Token = Tok_Identifier)\n-                    and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+                    and then Start_Column <= Scopes (Scope.Last).Ecol\n                     and then Scope.Last /= 1\n                   then\n-                     Scope.Table (Scope.Last).Etyp := E_Suspicious_Is;\n-                     Scope.Table (Scope.Last).S_Is := Prev_Token_Ptr;\n+                     Scopes (Scope.Last).Etyp := E_Suspicious_Is;\n+                     Scopes (Scope.Last).S_Is := Prev_Token_Ptr;\n                   end if;\n \n                   --  Build and return subprogram body, parsing declarations\n@@ -1004,12 +1005,17 @@ package body Ch6 is\n            and then (Nkind (Specification_Node) /= N_Procedure_Specification\n                       or else not Null_Present (Specification_Node))\n          then\n-            SIS_Labl := Scope.Table (Scope.Last).Labl;\n-            SIS_Sloc := Scope.Table (Scope.Last).Sloc;\n-            SIS_Ecol := Scope.Table (Scope.Last).Ecol;\n+            SIS_Labl := Scopes (Scope.Last).Labl;\n+            SIS_Sloc := Scopes (Scope.Last).Sloc;\n+            SIS_Ecol := Scopes (Scope.Last).Ecol;\n             SIS_Declaration_Node := Decl_Node;\n             SIS_Semicolon_Sloc := Prev_Token_Ptr;\n-            SIS_Entry_Active := True;\n+\n+            --  Do not activate the entry if we have \"with Import\"\n+\n+            if not SIS_Aspect_Import_Seen then\n+               SIS_Entry_Active := True;\n+            end if;\n          end if;\n \n          Pop_Scope_Stack;\n@@ -1946,10 +1952,10 @@ package body Ch6 is\n \n             if Token = Tok_Do then\n                Push_Scope_Stack;\n-               Scope.Table (Scope.Last).Ecol := Ret_Strt;\n-               Scope.Table (Scope.Last).Etyp := E_Return;\n-               Scope.Table (Scope.Last).Labl := Error;\n-               Scope.Table (Scope.Last).Sloc := Ret_Sloc;\n+               Scopes (Scope.Last).Ecol := Ret_Strt;\n+               Scopes (Scope.Last).Etyp := E_Return;\n+               Scopes (Scope.Last).Labl := Error;\n+               Scopes (Scope.Last).Sloc := Ret_Sloc;\n \n                Scan; -- past DO\n                Set_Handled_Statement_Sequence"}, {"sha": "c8150a4912399d8e34f586e1bd969647f1a8b9eb", "filename": "gcc/ada/par-ch7.adb", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch7.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -121,9 +121,9 @@ package body Ch7 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Lreq := False;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Lreq := False;\n \n       Package_Sloc := Token_Ptr;\n       Scan; -- past PACKAGE\n@@ -143,9 +143,9 @@ package body Ch7 is\n          end if;\n \n          T_Body;\n-         Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+         Scopes (Scope.Last).Sloc := Token_Ptr;\n          Name_Node := P_Defining_Program_Unit_Name;\n-         Scope.Table (Scope.Last).Labl := Name_Node;\n+         Scopes (Scope.Last).Labl := Name_Node;\n          Current_Node := Name_Node;\n \n          if Aspect_Specifications_Present then\n@@ -209,9 +209,9 @@ package body Ch7 is\n       --  Cases other than Package_Body\n \n       else\n-         Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+         Scopes (Scope.Last).Sloc := Token_Ptr;\n          Name_Node := P_Defining_Program_Unit_Name;\n-         Scope.Table (Scope.Last).Labl := Name_Node;\n+         Scopes (Scope.Last).Labl := Name_Node;\n          Current_Node := Name_Node;\n \n          --  Case of renaming declaration\n@@ -290,7 +290,7 @@ package body Ch7 is\n                  (Specification_Node, P_Basic_Declarative_Items);\n \n                if Token = Tok_Private then\n-                  Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+                  Error_Msg_Col := Scopes (Scope.Last).Ecol;\n \n                   if RM_Column_Check then\n                      if Token_Is_At_Start_Of_Line"}, {"sha": "d6c6dfc45e58f95241f7a5a2eadb35a6a8441cb4", "filename": "gcc/ada/par-ch9.adb", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch9.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -91,16 +91,16 @@ package body Ch9 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Lreq := False;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Lreq := False;\n       Task_Sloc := Prev_Token_Ptr;\n \n       if Token = Tok_Body then\n          Scan; -- past BODY\n          Name_Node := P_Defining_Identifier (C_Is);\n-         Scope.Table (Scope.Last).Labl := Name_Node;\n+         Scopes (Scope.Last).Labl := Name_Node;\n          Current_Node := Name_Node;\n \n          if Token = Tok_Left_Paren then\n@@ -168,7 +168,7 @@ package body Ch9 is\n             Task_Node := New_Node (N_Task_Type_Declaration, Task_Sloc);\n             Name_Node := P_Defining_Identifier;\n             Set_Defining_Identifier (Task_Node, Name_Node);\n-            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Scopes (Scope.Last).Labl := Name_Node;\n             Current_Node := Name_Node;\n             Set_Discriminant_Specifications\n               (Task_Node, P_Known_Discriminant_Part_Opt);\n@@ -177,7 +177,7 @@ package body Ch9 is\n             Task_Node := New_Node (N_Single_Task_Declaration, Task_Sloc);\n             Name_Node := P_Defining_Identifier (C_Is);\n             Set_Defining_Identifier (Task_Node, Name_Node);\n-            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Scopes (Scope.Last).Labl := Name_Node;\n             Current_Node := Name_Node;\n \n             if Token = Tok_Left_Paren then\n@@ -441,15 +441,15 @@ package body Ch9 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Lreq := False;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Lreq := False;\n       Protected_Sloc := Prev_Token_Ptr;\n \n       if Token = Tok_Body then\n          Scan; -- past BODY\n          Name_Node := P_Defining_Identifier (C_Is);\n-         Scope.Table (Scope.Last).Labl := Name_Node;\n+         Scopes (Scope.Last).Labl := Name_Node;\n          Current_Node := Name_Node;\n \n          if Token = Tok_Left_Paren then\n@@ -504,7 +504,7 @@ package body Ch9 is\n               New_Node (N_Protected_Type_Declaration, Protected_Sloc);\n             Name_Node := P_Defining_Identifier (C_Is);\n             Set_Defining_Identifier (Protected_Node, Name_Node);\n-            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Scopes (Scope.Last).Labl := Name_Node;\n             Current_Node := Name_Node;\n             Set_Discriminant_Specifications\n               (Protected_Node, P_Known_Discriminant_Part_Opt);\n@@ -521,7 +521,7 @@ package body Ch9 is\n                Discard_Junk_List (P_Known_Discriminant_Part_Opt);\n             end if;\n \n-            Scope.Table (Scope.Last).Labl := Name_Node;\n+            Scopes (Scope.Last).Labl := Name_Node;\n             Current_Node := Name_Node;\n          end if;\n \n@@ -1074,12 +1074,12 @@ package body Ch9 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n \n       Accept_Node := New_Node (N_Accept_Statement, Token_Ptr);\n       Scan; -- past ACCEPT\n-      Scope.Table (Scope.Last).Labl := Token_Node;\n+      Scopes (Scope.Last).Labl := Token_Node;\n       Current_Node := Token_Node;\n \n       Set_Entry_Direct_Name (Accept_Node, P_Identifier (C_Do));\n@@ -1123,8 +1123,8 @@ package body Ch9 is\n       --  Scan out DO if present\n \n       if Token = Tok_Do then\n-         Scope.Table (Scope.Last).Etyp := E_Name;\n-         Scope.Table (Scope.Last).Lreq := False;\n+         Scopes (Scope.Last).Etyp := E_Name;\n+         Scopes (Scope.Last).Lreq := False;\n          Scan; -- past DO\n          Hand_Seq := P_Handled_Sequence_Of_Statements;\n          Set_Handled_Statement_Sequence (Accept_Node, Hand_Seq);\n@@ -1221,14 +1221,14 @@ package body Ch9 is\n       Entry_Node := New_Node (N_Entry_Body, Token_Ptr);\n       Scan; -- past ENTRY\n \n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Lreq := False;\n-      Scope.Table (Scope.Last).Etyp := E_Name;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Lreq := False;\n+      Scopes (Scope.Last).Etyp := E_Name;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n \n       Name_Node := P_Defining_Identifier;\n       Set_Defining_Identifier (Entry_Node, Name_Node);\n-      Scope.Table (Scope.Last).Labl := Name_Node;\n+      Scopes (Scope.Last).Labl := Name_Node;\n       Current_Node := Name_Node;\n \n       Formal_Part_Node := P_Entry_Body_Formal_Part;\n@@ -1521,10 +1521,10 @@ package body Ch9 is\n \n    begin\n       Push_Scope_Stack;\n-      Scope.Table (Scope.Last).Etyp := E_Select;\n-      Scope.Table (Scope.Last).Ecol := Start_Column;\n-      Scope.Table (Scope.Last).Sloc := Token_Ptr;\n-      Scope.Table (Scope.Last).Labl := Error;\n+      Scopes (Scope.Last).Etyp := E_Select;\n+      Scopes (Scope.Last).Ecol := Start_Column;\n+      Scopes (Scope.Last).Sloc := Token_Ptr;\n+      Scopes (Scope.Last).Labl := Error;\n \n       Select_Sloc := Token_Ptr;\n       Scan; -- past SELECT"}, {"sha": "705b7fbc9d047c345363be40eb7a1c8391b3e011", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -180,7 +180,7 @@ package body Endh is\n       Name_Scan_State : Saved_Scan_State;\n       --  Save state at start of name if Name_On_Separate_Line is TRUE\n \n-      Span_Node : constant Node_Id := Scope.Table (Scope.Last).Node;\n+      Span_Node : constant Node_Id := Scopes (Scope.Last).Node;\n \n    begin\n       End_Labl_Present := False;\n@@ -284,7 +284,7 @@ package body Endh is\n \n                if Name_On_Separate_Line then\n                   if Token /= Tok_Semicolon or else\n-                    not Same_Label (End_Labl, Scope.Table (Scope.Last).Labl)\n+                    not Same_Label (End_Labl, Scopes (Scope.Last).Labl)\n                   then\n                      Restore_Scan_State (Name_Scan_State);\n                      End_Labl := Empty;\n@@ -297,7 +297,7 @@ package body Endh is\n             --  to the scan location past the END token.\n \n             else\n-               End_Labl := Scope.Table (Scope.Last).Labl;\n+               End_Labl := Scopes (Scope.Last).Labl;\n \n                if End_Labl > Empty_Or_Error then\n \n@@ -382,10 +382,10 @@ package body Endh is\n                   if Style_Check\n                     and then End_Type = E_Name\n                     and then Explicit_Start_Label (Scope.Last)\n-                    and then Nkind (Parent (Scope.Table (Scope.Last).Labl))\n+                    and then Nkind (Parent (Scopes (Scope.Last).Labl))\n                                /= N_Block_Statement\n                   then\n-                     Style.No_End_Name (Scope.Table (Scope.Last).Labl);\n+                     Style.No_End_Name (Scopes (Scope.Last).Labl);\n                   end if;\n                end if;\n             end if;\n@@ -710,7 +710,7 @@ package body Endh is\n    ------------------------\n \n    procedure Evaluate_End_Entry (SS_Index : Nat) is\n-      STE : Scope_Table_Entry renames Scope.Table (SS_Index);\n+      STE : Scope_Table_Entry renames Scopes (SS_Index).all;\n \n    begin\n       Column_OK := (End_Column = STE.Ecol);\n@@ -741,7 +741,7 @@ package body Endh is\n \n       if not Label_OK\n         and then End_Labl_Present\n-        and then not Comes_From_Source (Scope.Table (SS_Index).Labl)\n+        and then not Comes_From_Source (Scopes (SS_Index).Labl)\n       then\n          --  Here is where we will search the suspicious labels table\n \n@@ -792,7 +792,7 @@ package body Endh is\n          --  If probably misspelling, then complain, and pretend it is OK\n \n          declare\n-            Nam : constant Node_Or_Entity_Id := Scope.Table (SS_Index).Labl;\n+            Nam : constant Node_Or_Entity_Id := Scopes (SS_Index).Labl;\n \n          begin\n             if Nkind (End_Labl) in N_Has_Chars\n@@ -828,7 +828,7 @@ package body Endh is\n       elsif End_Type = E_Name then\n          Syntax_OK := (not Explicit_Start_Label (SS_Index))\n                          or else\n-                      (not Scope.Table (SS_Index).Lreq);\n+                      (not Scopes (SS_Index).Lreq);\n \n       --  Otherwise we have cases which don't allow labels anyway, so we\n       --  certainly accept an END which does not have a label.\n@@ -843,8 +843,8 @@ package body Endh is\n    --------------------------\n \n    function Explicit_Start_Label (SS_Index : Nat) return Boolean is\n-      L    : constant Node_Id := Scope.Table (SS_Index).Labl;\n-      Etyp : constant SS_End_Type := Scope.Table (SS_Index).Etyp;\n+      L    : constant Node_Id := Scopes (SS_Index).Labl;\n+      Etyp : constant SS_End_Type := Scopes (SS_Index).Etyp;\n \n    begin\n       if No (L) then\n@@ -906,16 +906,16 @@ package body Endh is\n       --  Suppress message if this was a potentially junk entry (e.g. a record\n       --  entry where no record keyword was present).\n \n-      if Scope.Table (Scope.Last).Junk then\n+      if Scopes (Scope.Last).Junk then\n          return;\n       end if;\n \n-      End_Type := Scope.Table (Scope.Last).Etyp;\n-      Error_Msg_Col  := Scope.Table (Scope.Last).Ecol;\n-      Error_Msg_Sloc := Scope.Table (Scope.Last).Sloc;\n+      End_Type := Scopes (Scope.Last).Etyp;\n+      Error_Msg_Col  := Scopes (Scope.Last).Ecol;\n+      Error_Msg_Sloc := Scopes (Scope.Last).Sloc;\n \n       if Explicit_Start_Label (Scope.Last) then\n-         Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+         Error_Msg_Node_1 := Scopes (Scope.Last).Labl;\n       else\n          Error_Msg_Node_1 := Empty;\n       end if;\n@@ -975,7 +975,7 @@ package body Endh is\n       --  missing IS confirms the suspicion.\n \n       else -- End_Type = E_Suspicious_Is or E_Bad_Is\n-         Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+         Scopes (Scope.Last).Etyp := E_Bad_Is;\n       end if;\n    end Output_End_Expected;\n \n@@ -990,15 +990,15 @@ package body Endh is\n       --  Suppress message if this was a potentially junk entry (e.g. a record\n       --  entry where no record keyword was present).\n \n-      if Scope.Table (Scope.Last).Junk then\n+      if Scopes (Scope.Last).Junk then\n          return;\n       end if;\n \n-      End_Type := Scope.Table (Scope.Last).Etyp;\n-      Error_Msg_Sloc   := Scope.Table (Scope.Last).Sloc;\n+      End_Type := Scopes (Scope.Last).Etyp;\n+      Error_Msg_Sloc   := Scopes (Scope.Last).Sloc;\n \n       if Explicit_Start_Label (Scope.Last) then\n-         Error_Msg_Node_1 := Scope.Table (Scope.Last).Labl;\n+         Error_Msg_Node_1 := Scopes (Scope.Last).Labl;\n       else\n          Error_Msg_Node_1 := Empty;\n       end if;\n@@ -1036,7 +1036,7 @@ package body Endh is\n          end if;\n \n       else -- End_Type = E_Suspicious_Is or E_Bad_Is\n-         Scope.Table (Scope.Last).Etyp := E_Bad_Is;\n+         Scopes (Scope.Last).Etyp := E_Bad_Is;\n       end if;\n    end Output_End_Missing;\n \n@@ -1100,7 +1100,7 @@ package body Endh is\n              Token = Tok_Separate)\n            and then End_Type >= E_Name\n            and then (not End_Labl_Present\n-                      or else Same_Label (End_Labl, Scope.Table (1).Labl))\n+                      or else Same_Label (End_Labl, Scopes (1).Labl))\n            and then Scope.Last > 1\n          then\n             Restore_Scan_State (Scan_State); -- to END\n@@ -1125,17 +1125,17 @@ package body Endh is\n             --  line as the opener.\n \n             if RM_Column_Check then\n-               if End_Column /= Scope.Table (Scope.Last).Ecol\n-                 and then Current_Line_Start > Scope.Table (Scope.Last).Sloc\n+               if End_Column /= Scopes (Scope.Last).Ecol\n+                 and then Current_Line_Start > Scopes (Scope.Last).Sloc\n \n                --  A special case, for END RECORD, we are also allowed to\n                --  line up with the TYPE keyword opening the declaration.\n \n-                 and then (Scope.Table (Scope.Last).Etyp /= E_Record\n+                 and then (Scopes (Scope.Last).Etyp /= E_Record\n                             or else Get_Column_Number (End_Sloc) /=\n                                     Get_Column_Number (Type_Token_Location))\n                then\n-                  Error_Msg_Col := Scope.Table (Scope.Last).Ecol;\n+                  Error_Msg_Col := Scopes (Scope.Last).Ecol;\n                   Error_Msg\n                     (\"(style) END in wrong column, should be@\", End_Sloc);\n                end if;\n@@ -1176,7 +1176,7 @@ package body Endh is\n                                  or else\n                               (not Same_Label\n                                      (End_Labl,\n-                                      Scope.Table (Scope.Last - 1).Labl)))\n+                                      Scopes (Scope.Last - 1).Labl)))\n                      then\n                         T_Semicolon;\n                         Error_Msg (\"duplicate end line ignored\", End_Loc);\n@@ -1229,7 +1229,7 @@ package body Endh is\n          --  also it is unlikely that such nesting could occur by accident.\n \n          Pretty_Good := (Token_OK and (Column_OK or Label_OK))\n-                          or else Scope.Table (Scope.Last).Etyp = E_Record;\n+                          or else Scopes (Scope.Last).Etyp = E_Record;\n \n          --  Next check, if there is a deeper entry in the stack which\n          --  has a very high probability of being acceptable, then insert\n@@ -1289,8 +1289,8 @@ package body Endh is\n          --  practices vary substantially in practice.\n \n          if Pretty_Good\n-            or else End_Column <= Scope.Table (Scope.Last).Ecol\n-            or else (End_Type = Scope.Table (Scope.Last).Etyp\n+            or else End_Column <= Scopes (Scope.Last).Ecol\n+            or else (End_Type = Scopes (Scope.Last).Etyp\n                         and then End_Type = E_Loop)\n          then\n             Output_End_Expected (Ins => False);"}, {"sha": "1c32a42e08fb03c37fe45634d9e389b210030d1d", "filename": "gcc/ada/par-util.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-util.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -162,7 +162,7 @@ package body Util is\n    procedure Check_Bad_Layout is\n    begin\n       if RM_Column_Check and then Token_Is_At_Start_Of_Line\n-        and then Start_Column <= Scope.Table (Scope.Last).Ecol\n+        and then Start_Column <= Scopes (Scope.Last).Ecol\n       then\n          Error_Msg_BC -- CODEFIX\n            (\"(style) incorrect layout\");\n@@ -668,9 +668,9 @@ package body Util is\n       Scope.Decrement_Last;\n \n       if Include_Subprogram_In_Messages\n-        and then Scope.Table (Scope.Last).Labl /= Error\n+        and then Scopes (Scope.Last).Labl /= Error\n       then\n-         Current_Node := Scope.Table (Scope.Last).Labl;\n+         Current_Node := Scopes (Scope.Last).Labl;\n       end if;\n \n       if Debug_Flag_P then\n@@ -695,8 +695,8 @@ package body Util is\n             First_Non_Blank_Location);\n       end if;\n \n-      Scope.Table (Scope.Last).Junk := False;\n-      Scope.Table (Scope.Last).Node := Empty;\n+      Scopes (Scope.Last).Junk := False;\n+      Scopes (Scope.Last).Node := Empty;\n \n       if Debug_Flag_P then\n          Error_Msg_Uint_1 := UI_From_Int (Scope.Last);"}, {"sha": "0e3fa401a773871071a2e995dc43d96e44f0a32e", "filename": "gcc/ada/par.adb", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bba838d7f4e9b851416d463d077b28aff0b561f/gcc%2Fada%2Fpar.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar.adb?ref=0bba838d7f4e9b851416d463d077b28aff0b561f", "patch": "@@ -151,8 +151,17 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n \n    SIS_Entry_Active : Boolean := False;\n    --  Set True to indicate that an entry is active (i.e. that a subprogram\n-   --  declaration has been encountered, and no body for this subprogram has\n-   --  been encountered). The remaining fields are valid only if this is True.\n+   --  declaration has been encountered, and no body for this subprogram\n+   --  has been encountered). The remaining variables other than\n+   --  SIS_Aspect_Import_Seen are valid only if this is True.\n+\n+   SIS_Aspect_Import_Seen : Boolean := False;\n+   --  If this is True when a subprogram declaration has been encountered, we\n+   --  do not set SIS_Entry_Active, because the Import means there is no body.\n+   --  Set False at the start of P_Subprogram, set True when an Import aspect\n+   --  specification is seen, and used when P_Subprogram finds a subprogram\n+   --  declaration.  This is necessary because the aspects are parsed before\n+   --  we know we have a subprogram declaration.\n \n    SIS_Labl : Node_Id;\n    --  Subprogram designator\n@@ -535,6 +544,20 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n      Table_Increment      => 100,\n      Table_Name           => \"Scope\");\n \n+   type Scope_Table_Entry_Ptr is access all Scope_Table_Entry;\n+\n+   function Scopes (Index : Int) return Scope_Table_Entry_Ptr;\n+   --  Return the indicated Scope_Table_Entry. We use a pointer for\n+   --  efficiency. Callers should not save the pointer, but should do things\n+   --  like Scopes (Scope.Last).Something. Note that there is one place in\n+   --  Par.Ch5 that indexes the stack out of bounds, and can't call this.\n+\n+   function Scopes (Index : Int) return Scope_Table_Entry_Ptr is\n+   begin\n+      pragma Assert (Index in Scope.First .. Scope.Last);\n+      return Scope.Table (Index)'Unrestricted_Access;\n+   end Scopes;\n+\n    ------------------------------------------\n    -- Table for Handling Suspicious Labels --\n    ------------------------------------------\n@@ -1332,7 +1355,7 @@ function Par (Configuration_Pragmas : Boolean) return List_Id is\n       --  Push a new entry onto the scope stack. Scope.Last (the stack pointer)\n       --  is incremented. The Junk field is preinitialized to False. The caller\n       --  is expected to fill in all remaining entries of the new top stack\n-      --  entry at Scope.Table (Scope.Last).\n+      --  entry at Scopes (Scope.Last).\n \n       procedure Pop_Scope_Stack;\n       --  Pop an entry off the top of the scope stack. Scope_Last (the scope\n@@ -1534,7 +1557,7 @@ begin\n          Compiler_State := Parsing;\n          Scope.Init;\n          Scope.Increment_Last;\n-         Scope.Table (0).Etyp := E_Dummy;\n+         Scopes (0).Etyp := E_Dummy;\n          SIS_Entry_Active := False;\n          Last_Resync_Point := No_Location;\n "}]}