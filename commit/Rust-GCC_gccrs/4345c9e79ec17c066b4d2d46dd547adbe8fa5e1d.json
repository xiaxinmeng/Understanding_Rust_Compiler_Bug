{"sha": "4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDM0NWM5ZTc5ZWMxN2MwNjZiNGQyZDQ2ZGQ1NDdhZGJlOGZhNWUxZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-12-13T22:32:29Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:44Z"}, "message": "[Ada] Reimplement Pred and Succ atttributes for floating-point types\n\ngcc/ada/\n\n\t* libgnat/s-fatgen.adb: Remove with clause for Interfaces and\n\tuse type clauses for Interfaces.Unsigned_{16,32,64}.\n\t(Small16): Remove.\n\t(Small32): Likewise\n\t(Small64): Likewise.\n\t(Small80): Likewise.\n\t(Tiny16): Likewise.\n\t(Tiny32): Likewise.\n\t(Tiny64): Likewise.\n\t(Tiny80): Likewise.\n\t(Siz): Always use 16.\n\t(NR): New constant.\n\t(Rep_Last): Use it in the computation.\n\t(Exp_Factor): Remove special case for 80-bit.\n\t(Sign_Mask): Likewise.\n\t(Finite_Succ): New function implementing the Succ attribute for\n\tfinite numbers.\n\t(Pred): Rewrite in terms of Finite_Succ.\n\t(Succ): Likewise.", "tree": {"sha": "ed9ba605187cb558c1d49a6a4c3d66544340d1b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed9ba605187cb558c1d49a6a4c3d66544340d1b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "db3be1483913399077878b763e732f2c5c7e749d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3be1483913399077878b763e732f2c5c7e749d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3be1483913399077878b763e732f2c5c7e749d"}], "stats": {"total": 375, "additions": 213, "deletions": 162}, "files": [{"sha": "41af37bed9ea08a742a7a9f44e64cbb9b83f5c9c", "filename": "gcc/ada/libgnat/s-fatgen.adb", "status": "modified", "additions": 213, "deletions": 162, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fatgen.adb?ref=4345c9e79ec17c066b4d2d46dd547adbe8fa5e1d", "patch": "@@ -35,17 +35,12 @@\n --  floating-point implementations.\n \n with Ada.Unchecked_Conversion;\n-with Interfaces;\n with System.Unsigned_Types;\n \n pragma Warnings (Off, \"non-static constant in preelaborated unit\");\n --  Every constant is static given our instantiation model\n \n package body System.Fat_Gen is\n-   use type Interfaces.Unsigned_16;\n-   use type Interfaces.Unsigned_32;\n-   use type Interfaces.Unsigned_64;\n-\n    pragma Assert (T'Machine_Radix = 2);\n    --  This version does not handle radix 16\n \n@@ -61,33 +56,9 @@ package body System.Fat_Gen is\n    --  Small : constant T := Rad ** (T'Machine_Emin - 1);\n    --  Smallest positive normalized number\n \n-   Small16 : constant Interfaces.Unsigned_16 := 2**(Mantissa - 1);\n-   Small32 : constant Interfaces.Unsigned_32 := 2**(Mantissa - 1);\n-   Small64 : constant Interfaces.Unsigned_64 := 2**(Mantissa - 1);\n-   Small80 : constant array (1 .. 2) of Interfaces.Unsigned_64 :=\n-               (2**48 * (1 - Standard'Default_Bit_Order),\n-                1 * Standard'Default_Bit_Order);\n-   for Small80'Alignment use Standard'Maximum_Alignment;\n-   --  We cannot use the direct declaration because it cannot be translated\n-   --  into C90, as the hexadecimal floating constants were introduced in C99.\n-   --  So we work around this by using an overlay of the integer constant.\n-   --  ??? Revisit this when the new CCG technoloy is in production\n-\n    --  Tiny : constant T := Rad ** (T'Machine_Emin - Mantissa);\n    --  Smallest positive denormalized number\n \n-   Tiny16 : constant Interfaces.Unsigned_16 := 1;\n-   Tiny32 : constant Interfaces.Unsigned_32 := 1;\n-   Tiny64 : constant Interfaces.Unsigned_64 := 1;\n-   Tiny80 : constant array (1 .. 2) of Interfaces.Unsigned_64 :=\n-              (1 * Standard'Default_Bit_Order,\n-               2**48 * (1 - Standard'Default_Bit_Order));\n-   for Tiny80'Alignment use Standard'Maximum_Alignment;\n-   --  We cannot use the direct declaration because it cannot be translated\n-   --  into C90, as the hexadecimal floating constants were introduced in C99.\n-   --  So we work around this by using an overlay of the integer constant.\n-   --  ??? Revisit this when the new CCG technoloy is in production\n-\n    RM1 : constant T := Rad ** (Mantissa - 1);\n    --  Smallest positive member of the large consecutive integers. It is equal\n    --  to the ratio Small / Tiny, which means that multiplying by it normalizes\n@@ -125,22 +96,23 @@ package body System.Fat_Gen is\n    --      component of Float_Rep, named Most Significant Word (MSW).\n \n    --    - The sign occupies the most significant bit of the MSW and the\n-   --      exponent is in the following bits. The exception is 80-bit\n-   --      double extended, where they occupy the low 16-bit halfword.\n-\n-   --  The low-level primitives Copy_Sign, Decompose, Scaling and Valid are\n-   --  implemented by accessing the bit pattern of the floating-point number.\n-   --  Only the normalization of denormalized numbers, if any, and the gradual\n-   --  underflow are left to the hardware, mainly because there is some leeway\n-   --  for the hardware implementation in this area: for example, the MSB of\n-   --  the mantissa, which is 1 for normalized numbers and 0 for denormalized\n+   --      exponent is in the following bits.\n+\n+   --  The low-level primitives Copy_Sign, Decompose, Finite_Succ, Scaling and\n+   --  Valid are implemented by accessing the bit pattern of the floating-point\n+   --  number. Only the normalization of denormalized numbers, if any, and the\n+   --  gradual underflow are left to the hardware, mainly because there is some\n+   --  leeway for the hardware implementation in this area: for example the MSB\n+   --  of the mantissa, that is 1 for normalized numbers and 0 for denormalized\n    --  numbers, may or may not be stored by the hardware.\n \n-   Siz : constant := (if System.Word_Size > 32 then 32 else System.Word_Size);\n+   Siz : constant := 16;\n    type Float_Word is mod 2**Siz;\n+   --  We use the GCD of the size of all the supported floating-point formats\n \n-   N : constant Natural := (T'Size + Siz - 1) / Siz;\n-   Rep_Last : constant Natural := Natural'Min (N - 1, (Mantissa + 16) / Siz);\n+   N  : constant Natural := (T'Size + Siz - 1) / Siz;\n+   NR : constant Natural := (Mantissa + 16 + Siz - 1) / Siz;\n+   Rep_Last : constant Natural := Natural'Min (N, NR) - 1;\n    --  Determine the number of Float_Words needed for representing the\n    --  entire floating-point value. Do not take into account excessive\n    --  padding, as occurs on IA-64 where 80 bits floats get padded to 128\n@@ -158,23 +130,18 @@ package body System.Fat_Gen is\n    --  we assume Word_Order = Bit_Order.\n \n    Exp_Factor : constant Float_Word :=\n-                  (if Mantissa = 64\n-                   then 1\n-                   else 2**(Siz - 1) / Float_Word (IEEE_Emax - IEEE_Emin + 3));\n+                  2**(Siz - 1) / Float_Word (IEEE_Emax - IEEE_Emin + 3);\n    --  Factor that the extracted exponent needs to be divided by to be in\n-   --  range 0 .. IEEE_Emax - IEEE_Emin + 2. The special case is 80-bit\n-   --  double extended, where the exponent starts the 3rd float word.\n+   --  range 0 .. IEEE_Emax - IEEE_Emin + 2\n \n    Exp_Mask : constant Float_Word :=\n                 Float_Word (IEEE_Emax - IEEE_Emin + 2) * Exp_Factor;\n    --  Value needed to mask out the exponent field. This assumes that the\n    --  range 0 .. IEEE_Emax - IEEE_Emin + 2 contains 2**N values, for some\n    --  N in Natural.\n \n-   Sign_Mask : constant Float_Word :=\n-                 (if Mantissa = 64 then 2**15 else 2**(Siz - 1));\n-   --  Value needed to mask out the sign field. The special case is 80-bit\n-   --  double extended, where the exponent starts the 3rd float word.\n+   Sign_Mask : constant Float_Word := 2**(Siz - 1);\n+   --  Value needed to mask out the sign field\n \n    -----------------------\n    -- Local Subprograms --\n@@ -186,6 +153,9 @@ package body System.Fat_Gen is\n    --  the sign of the exponent. The absolute value of Frac is in the range\n    --  0.0 <= Frac < 1.0. If Frac = 0.0 or -0.0, then Expo is always zero.\n \n+   function Finite_Succ (X : T) return T;\n+   --  Return the successor of X, a finite number not equal to T'Last\n+\n    --------------\n    -- Adjacent --\n    --------------\n@@ -321,6 +291,179 @@ package body System.Fat_Gen is\n       return X_Exp;\n    end Exponent;\n \n+   -----------------\n+   -- Finite_Succ --\n+   -----------------\n+\n+   function Finite_Succ (X : T) return T is\n+      XX : T := T'Machine (X);\n+\n+      Rep : Float_Rep;\n+      for Rep'Address use XX'Address;\n+      --  Rep is a view of the input floating-point parameter\n+\n+   begin\n+      --  If the floating-point type does not support denormalized numbers,\n+      --  there is a couple of problematic values, namely -Small and Zero,\n+      --  because the increment is equal to Small in these cases.\n+\n+      if not T'Denorm then\n+         declare\n+            Small : constant T := Rad ** (T'Machine_Emin - 1);\n+            --  Smallest positive normalized number declared here and not at\n+            --  library level for the sake of the CCG compiler, which cannot\n+            --  currently compile the constant because the target is C90.\n+\n+         begin\n+            if X = -Small then\n+               XX := 0.0;\n+               return -XX;\n+            elsif X = 0.0 then\n+               return Small;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  In all the other cases, the increment is equal to 1 in the binary\n+      --  integer representation of the number if X is nonnegative and equal\n+      --  to -1 if X is negative.\n+\n+      if XX >= 0.0 then\n+         --  First clear the sign of negative Zero\n+\n+         Rep (MSW) := Rep (MSW) and not Sign_Mask;\n+\n+         --  Deal with big endian\n+\n+         if MSW = 0 then\n+            for J in reverse 0 .. Rep_Last loop\n+               Rep (J) := Rep (J) + 1;\n+\n+               --  For 80-bit IEEE Extended, the MSB of the mantissa is stored\n+               --  so, when it has been flipped, its status must be reanalyzed.\n+\n+               if Mantissa = 64 and then J = 1 then\n+\n+                  --  If the MSB changed from denormalized to normalized, then\n+                  --  keep it normalized since the exponent will be bumped.\n+\n+                  if Rep (J) = 2**(Siz - 1) then\n+                     null;\n+\n+                  --  If the MSB changed from normalized, restore it since we\n+                  --  cannot denormalize in this context.\n+\n+                  elsif Rep (J) = 0 then\n+                     Rep (J) := 2**(Siz - 1);\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+               --  In other cases, stop if there is no carry\n+\n+               else\n+                  exit when Rep (J) > 0;\n+               end if;\n+            end loop;\n+\n+         --  Deal with little endian\n+\n+         else\n+            for J in 0 .. Rep_Last loop\n+               Rep (J) := Rep (J) + 1;\n+\n+               --  For 80-bit IEEE Extended, the MSB of the mantissa is stored\n+               --  so, when it has been flipped, its status must be reanalyzed.\n+\n+               if Mantissa = 64 and then J = Rep_Last - 1 then\n+\n+                  --  If the MSB changed from denormalized to normalized, then\n+                  --  keep it normalized since the exponent will be bumped.\n+\n+                  if Rep (J) = 2**(Siz - 1) then\n+                     null;\n+\n+                  --  If the MSB changed from normalized, restore it since we\n+                  --  cannot denormalize in this context.\n+\n+                  elsif Rep (J) = 0 then\n+                     Rep (J) := 2**(Siz - 1);\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+               --  In other cases, stop if there is no carry\n+\n+               else\n+                  exit when Rep (J) > 0;\n+               end if;\n+            end loop;\n+         end if;\n+\n+      else\n+         if MSW = 0 then\n+            for J in reverse 0 .. Rep_Last loop\n+               Rep (J) := Rep (J) - 1;\n+\n+               --  For 80-bit IEEE Extended, the MSB of the mantissa is stored\n+               --  so, when it has been flipped, its status must be reanalyzed.\n+\n+               if Mantissa = 64 and then J = 1 then\n+\n+                  --  If the MSB changed from normalized to denormalized, then\n+                  --  keep it normalized if the exponent is not 1.\n+\n+                  if Rep (J) = 2**(Siz - 1) - 1 then\n+                     if Rep (0) /= 2**(Siz - 1) + 1 then\n+                        Rep (J) := 2**Siz - 1;\n+                     end if;\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+               --  In other cases, stop if there is no borrow\n+\n+               else\n+                  exit when Rep (J) < 2**Siz - 1;\n+               end if;\n+            end loop;\n+\n+         else\n+            for J in 0 .. Rep_Last loop\n+               Rep (J) := Rep (J) - 1;\n+\n+               --  For 80-bit IEEE Extended, the MSB of the mantissa is stored\n+               --  so, when it has been flipped, its status must be reanalyzed.\n+\n+               if Mantissa = 64 and then J = Rep_Last - 1 then\n+\n+                  --  If the MSB changed from normalized to denormalized, then\n+                  --  keep it normalized if the exponent is not 1.\n+\n+                  if Rep (J) = 2**(Siz - 1) - 1 then\n+                     if Rep (Rep_Last) /= 2**(Siz - 1) + 1 then\n+                        Rep (J) := 2**Siz - 1;\n+                     end if;\n+\n+                  else\n+                     exit;\n+                  end if;\n+\n+               --  In other cases, stop if there is no borrow\n+\n+               else\n+                  exit when Rep (J) < 2**Siz - 1;\n+               end if;\n+            end loop;\n+         end if;\n+      end if;\n+\n+      return XX;\n+   end Finite_Succ;\n+\n    -----------\n    -- Floor --\n    -----------\n@@ -439,73 +582,27 @@ package body System.Fat_Gen is\n    ----------\n \n    function Pred (X : T) return T is\n-      Small : constant T;\n-      pragma Import (Ada, Small);\n-      for Small'Address use (if     T'Size   = 16 then Small16'Address\n-                              elsif T'Size   = 32 then Small32'Address\n-                              elsif T'Size   = 64 then Small64'Address\n-                              elsif Mantissa = 64 then Small80'Address\n-                              else raise Program_Error);\n-      Tiny : constant T;\n-      pragma Import (Ada, Tiny);\n-      for Tiny'Address use (if     T'Size   = 16 then Tiny16'Address\n-                             elsif T'Size   = 32 then Tiny32'Address\n-                             elsif T'Size   = 64 then Tiny64'Address\n-                             elsif Mantissa = 64 then Tiny80'Address\n-                             else raise Program_Error);\n-      X_Frac : T;\n-      X_Exp  : UI;\n-\n    begin\n-      --  Zero has to be treated specially, since its exponent is zero\n-\n-      if X = 0.0 then\n-         return -(if T'Denorm then Tiny else Small);\n-\n       --  Special treatment for largest negative number: raise Constraint_Error\n \n-      elsif X = T'First then\n+      if X = T'First then\n          raise Constraint_Error with \"Pred of largest negative number\";\n \n-      --  For infinities, return unchanged\n+      --  For finite numbers, use the symmetry around zero of floating point\n \n-      elsif X < T'First or else X > T'Last then\n+      elsif X > T'First and then X <= T'Last then\n+         pragma Annotate (CodePeer, Intentional, \"test always true\",\n+                          \"Check for invalid float\");\n          pragma Annotate (CodePeer, Intentional, \"condition predetermined\",\n                           \"Check for invalid float\");\n-         return X;\n-         pragma Annotate (CodePeer, Intentional, \"dead code\",\n-                          \"Check float range.\");\n+         return -Finite_Succ (-X);\n \n-      --  Subtract from the given number a number equivalent to the value\n-      --  of its least significant bit. Given that the most significant bit\n-      --  represents a value of 1.0 * Radix ** (Exp - 1), the value we want\n-      --  is obtained by shifting this by (Mantissa-1) bits to the right,\n-      --  i.e. decreasing the exponent by that amount.\n+      --  For infinities and NaNs, return unchanged\n \n       else\n-         Decompose (X, X_Frac, X_Exp);\n-\n-         --  For a denormalized number or a normalized number with the lowest\n-         --  exponent, just subtract the Tiny.\n-\n-         if X_Exp <= T'Machine_Emin then\n-            return X - Tiny;\n-\n-         --  A special case, if the number we had was a power of two on the\n-         --  positive side of zero, then we want to subtract half of what we\n-         --  would have subtracted, since the exponent is going to be reduced.\n-\n-         --  Note that X_Frac has the same sign as X so, if X_Frac is Invrad,\n-         --  then we know that we had a power of two on the positive side.\n-\n-         elsif X_Frac = Invrad then\n-            return X - Scaling (1.0, X_Exp - Mantissa - 1);\n-\n-         --  Otherwise the adjustment is unchanged\n-\n-         else\n-            return X - Scaling (1.0, X_Exp - Mantissa);\n-         end if;\n+         return X;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n       end if;\n    end Pred;\n \n@@ -722,73 +819,27 @@ package body System.Fat_Gen is\n    ----------\n \n    function Succ (X : T) return T is\n-      Small : constant T;\n-      pragma Import (Ada, Small);\n-      for Small'Address use (if     T'Size   = 16 then Small16'Address\n-                              elsif T'Size   = 32 then Small32'Address\n-                              elsif T'Size   = 64 then Small64'Address\n-                              elsif Mantissa = 64 then Small80'Address\n-                              else raise Program_Error);\n-      Tiny : constant T;\n-      pragma Import (Ada, Tiny);\n-      for Tiny'Address use (if     T'Size   = 16 then Tiny16'Address\n-                             elsif T'Size   = 32 then Tiny32'Address\n-                             elsif T'Size   = 64 then Tiny64'Address\n-                             elsif Mantissa = 64 then Tiny80'Address\n-                             else raise Program_Error);\n-      X_Frac : T;\n-      X_Exp  : UI;\n-\n    begin\n-      --  Treat zero specially since it has a zero exponent\n-\n-      if X = 0.0 then\n-         return (if T'Denorm then Tiny else Small);\n-\n       --  Special treatment for largest positive number: raise Constraint_Error\n \n-      elsif X = T'Last then\n+      if X = T'Last then\n          raise Constraint_Error with \"Succ of largest positive number\";\n \n-      --  For infinities, return unchanged\n+      --  For finite numbers, call the specific routine\n \n-      elsif X < T'First or else X > T'Last then\n+      elsif X >= T'First and then X < T'Last then\n+         pragma Annotate (CodePeer, Intentional, \"test always true\",\n+                          \"Check for invalid float\");\n          pragma Annotate (CodePeer, Intentional, \"condition predetermined\",\n                           \"Check for invalid float\");\n-         return X;\n-         pragma Annotate (CodePeer, Intentional, \"dead code\",\n-                          \"Check float range.\");\n+         return Finite_Succ (X);\n \n-      --  Add to the given number a number equivalent to the value of its\n-      --  least significant bit. Given that the most significant bit\n-      --  represents a value of 1.0 * Radix ** (Exp - 1), the value we want\n-      --  is obtained by shifting this by (Mantissa-1) bits to the right,\n-      --  i.e. decreasing the exponent by that amount.\n+      --  For infinities and NaNs, return unchanged\n \n       else\n-         Decompose (X, X_Frac, X_Exp);\n-\n-         --  For a denormalized number or a normalized number with the lowest\n-         --  exponent, just add the Tiny.\n-\n-         if X_Exp <= T'Machine_Emin then\n-            return X + Tiny;\n-\n-         --  A special case, if the number we had was a power of two on the\n-         --  negative side of zero, then we want to add half of what we would\n-         --  have added, since the exponent is going to be reduced.\n-\n-         --  Note that X_Frac has the same sign as X, so if X_Frac is -Invrad,\n-         --  then we know that we had a power of two on the negative side.\n-\n-         elsif X_Frac = -Invrad then\n-            return X + Scaling (1.0, X_Exp - Mantissa - 1);\n-\n-         --  Otherwise the adjustment is unchanged\n-\n-         else\n-            return X + Scaling (1.0, X_Exp - Mantissa);\n-         end if;\n+         return X;\n+         pragma Annotate (CodePeer, Intentional, \"dead code\",\n+                          \"Check float range.\");\n       end if;\n    end Succ;\n "}]}