{"sha": "5ac2fd0d6edd8198ed10b66f48402678471c044c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWFjMmZkMGQ2ZWRkODE5OGVkMTBiNjZmNDg0MDI2Nzg0NzFjMDQ0Yw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-27T18:43:34Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-07-27T18:43:34Z"}, "message": "libgo: prune sighandler frames in runtime.sigprof\n    \n    When writing stack frames to the pprof CPU profile machinery, it is\n    very important to insure that the frames emitted do not contain any\n    frames corresponding to artifacts of the profiling process itself\n    (signal handlers, sigprof, etc). This patch changes runtime.sigprof to\n    strip out those frames from the raw stack generated by\n    \"runtime.callers\".\n    \n    Fixes golang/go#26595.\n    \n    Reviewed-on: https://go-review.googlesource.com/126175\n\nFrom-SVN: r263035", "tree": {"sha": "c774cea3b87cb75ea927518c69a4dd358cf23888", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c774cea3b87cb75ea927518c69a4dd358cf23888"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ac2fd0d6edd8198ed10b66f48402678471c044c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ac2fd0d6edd8198ed10b66f48402678471c044c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ac2fd0d6edd8198ed10b66f48402678471c044c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ac2fd0d6edd8198ed10b66f48402678471c044c/comments", "author": null, "committer": null, "parents": [{"sha": "58f51e5ca290160e67dcbf3b89654e025c9d3136", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58f51e5ca290160e67dcbf3b89654e025c9d3136", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58f51e5ca290160e67dcbf3b89654e025c9d3136"}], "stats": {"total": 83, "additions": 71, "deletions": 12}, "files": [{"sha": "95b6bcc771383e21d835161fd1695bc1e833791b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ac2fd0d6edd8198ed10b66f48402678471c044c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ac2fd0d6edd8198ed10b66f48402678471c044c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5ac2fd0d6edd8198ed10b66f48402678471c044c", "patch": "@@ -1,4 +1,4 @@\n-39d4d755db7d71b5e770ca435a8b1d1f08f53185\n+a2e0ad16555b2698df8e71f4c0fe02e185715bc1\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "02d99f58e6d8411191a710add2300a4fe0d08fd7", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ac2fd0d6edd8198ed10b66f48402678471c044c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ac2fd0d6edd8198ed10b66f48402678471c044c/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=5ac2fd0d6edd8198ed10b66f48402678471c044c", "patch": "@@ -72,15 +72,24 @@ func cpuHog2(x int) int {\n \treturn foo\n }\n \n+// Return a list of functions that we don't want to ever appear in CPU\n+// profiles. For gccgo, that list includes the sigprof handler itself.\n+func avoidFunctions() []string {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\treturn []string{\"runtime.sigprof\"}\n+\t}\n+\treturn nil\n+}\n+\n func TestCPUProfile(t *testing.T) {\n-\ttestCPUProfile(t, []string{\"pprof.cpuHog1\"}, func(dur time.Duration) {\n+\ttestCPUProfile(t, []string{\"pprof.cpuHog1\"}, avoidFunctions(), func(dur time.Duration) {\n \t\tcpuHogger(cpuHog1, &salt1, dur)\n \t})\n }\n \n func TestCPUProfileMultithreaded(t *testing.T) {\n \tdefer runtime.GOMAXPROCS(runtime.GOMAXPROCS(2))\n-\ttestCPUProfile(t, []string{\"pprof.cpuHog1\", \"pprof.cpuHog2\"}, func(dur time.Duration) {\n+\ttestCPUProfile(t, []string{\"pprof.cpuHog1\", \"pprof.cpuHog2\"}, avoidFunctions(), func(dur time.Duration) {\n \t\tc := make(chan int)\n \t\tgo func() {\n \t\t\tcpuHogger(cpuHog1, &salt1, dur)\n@@ -92,7 +101,7 @@ func TestCPUProfileMultithreaded(t *testing.T) {\n }\n \n func TestCPUProfileInlining(t *testing.T) {\n-\ttestCPUProfile(t, []string{\"pprof.inlinedCallee\", \"pprof.inlinedCaller\"}, func(dur time.Duration) {\n+\ttestCPUProfile(t, []string{\"pprof.inlinedCallee\", \"pprof.inlinedCaller\"}, avoidFunctions(), func(dur time.Duration) {\n \t\tcpuHogger(inlinedCaller, &salt1, dur)\n \t})\n }\n@@ -130,7 +139,7 @@ func parseProfile(t *testing.T, valBytes []byte, f func(uintptr, []*profile.Loca\n \t}\n }\n \n-func testCPUProfile(t *testing.T, need []string, f func(dur time.Duration)) {\n+func testCPUProfile(t *testing.T, need []string, avoid []string, f func(dur time.Duration)) {\n \tswitch runtime.GOOS {\n \tcase \"darwin\":\n \t\tswitch runtime.GOARCH {\n@@ -169,7 +178,7 @@ func testCPUProfile(t *testing.T, need []string, f func(dur time.Duration)) {\n \t\tf(duration)\n \t\tStopCPUProfile()\n \n-\t\tif profileOk(t, need, prof, duration) {\n+\t\tif profileOk(t, need, avoid, prof, duration) {\n \t\t\treturn\n \t\t}\n \n@@ -202,11 +211,13 @@ func contains(slice []string, s string) bool {\n \treturn false\n }\n \n-func profileOk(t *testing.T, need []string, prof bytes.Buffer, duration time.Duration) (ok bool) {\n+func profileOk(t *testing.T, need []string, avoid []string, prof bytes.Buffer, duration time.Duration) (ok bool) {\n \tok = true\n \n-\t// Check that profile is well formed and contains need.\n+\t// Check that profile is well formed, contains 'need', and does not contain\n+\t// anything from 'avoid'.\n \thave := make([]uintptr, len(need))\n+\tavoidSamples := make([]uintptr, len(avoid))\n \tvar samples uintptr\n \tvar buf bytes.Buffer\n \tparseProfile(t, prof.Bytes(), func(count uintptr, stk []*profile.Location, labels map[string][]string) {\n@@ -229,6 +240,15 @@ func profileOk(t *testing.T, need []string, prof bytes.Buffer, duration time.Dur\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\tfor i, name := range avoid {\n+\t\t\tfor _, loc := range stk {\n+\t\t\t\tfor _, line := range loc.Line {\n+\t\t\t\t\tif strings.Contains(line.Function.Name, name) {\n+\t\t\t\t\t\tavoidSamples[i] += count\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tfmt.Fprintf(&buf, \"\\n\")\n \t})\n \tt.Logf(\"total %d CPU profile samples collected:\\n%s\", samples, buf.String())\n@@ -251,6 +271,14 @@ func profileOk(t *testing.T, need []string, prof bytes.Buffer, duration time.Dur\n \t\tok = false\n \t}\n \n+\tfor i, name := range avoid {\n+\t\tbad := avoidSamples[i]\n+\t\tif bad != 0 {\n+\t\t\tt.Logf(\"found %d samples in avoid-function %s\\n\", bad, name)\n+\t\t\tok = false\n+\t\t}\n+\t}\n+\n \tif len(need) == 0 {\n \t\treturn ok\n \t}\n@@ -318,6 +346,9 @@ func TestCPUProfileWithFork(t *testing.T) {\n // If it did, it would see inconsistent state and would either record an incorrect stack\n // or crash because the stack was malformed.\n func TestGoroutineSwitch(t *testing.T) {\n+\tif runtime.Compiler == \"gccgo\" {\n+\t\tt.Skip(\"not applicable for gccgo\")\n+\t}\n \t// How much to try. These defaults take about 1 seconds\n \t// on a 2012 MacBook Pro. The ones in short mode take\n \t// about 0.1 seconds.\n@@ -377,7 +408,7 @@ func fprintStack(w io.Writer, stk []*profile.Location) {\n \n // Test that profiling of division operations is okay, especially on ARM. See issue 6681.\n func TestMathBigDivide(t *testing.T) {\n-\ttestCPUProfile(t, nil, func(duration time.Duration) {\n+\ttestCPUProfile(t, nil, nil, func(duration time.Duration) {\n \t\tt := time.After(duration)\n \t\tpi := new(big.Int)\n \t\tfor {\n@@ -851,7 +882,7 @@ func TestEmptyCallStack(t *testing.T) {\n }\n \n func TestCPUProfileLabel(t *testing.T) {\n-\ttestCPUProfile(t, []string{\"pprof.cpuHogger;key=value\"}, func(dur time.Duration) {\n+\ttestCPUProfile(t, []string{\"pprof.cpuHogger;key=value\"}, avoidFunctions(), func(dur time.Duration) {\n \t\tDo(context.Background(), Labels(\"key\", \"value\"), func(context.Context) {\n \t\t\tcpuHogger(cpuHog1, &salt1, dur)\n \t\t})\n@@ -862,7 +893,7 @@ func TestLabelRace(t *testing.T) {\n \t// Test the race detector annotations for synchronization\n \t// between settings labels and consuming them from the\n \t// profile.\n-\ttestCPUProfile(t, []string{\"pprof.cpuHogger;key=value\"}, func(dur time.Duration) {\n+\ttestCPUProfile(t, []string{\"pprof.cpuHogger;key=value\"}, avoidFunctions(), func(dur time.Duration) {\n \t\tstart := time.Now()\n \t\tvar wg sync.WaitGroup\n \t\tfor time.Since(start) < dur {"}, {"sha": "5826958dfd362389d73b3412777206e658769e5a", "filename": "libgo/go/runtime/proc.go", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ac2fd0d6edd8198ed10b66f48402678471c044c/libgo%2Fgo%2Fruntime%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ac2fd0d6edd8198ed10b66f48402678471c044c/libgo%2Fgo%2Fruntime%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fproc.go?ref=5ac2fd0d6edd8198ed10b66f48402678471c044c", "patch": "@@ -3418,8 +3418,36 @@ func sigprof(pc uintptr, gp *g, mp *m) {\n \t\tvar stklocs [maxCPUProfStack]location\n \t\tn = callers(0, stklocs[:])\n \n+\t\t// Issue 26595: the stack trace we've just collected is going\n+\t\t// to include frames that we don't want to report in the CPU\n+\t\t// profile, including signal handler frames. Here is what we\n+\t\t// might typically see at the point of \"callers\" above for a\n+\t\t// signal delivered to the application routine \"interesting\"\n+\t\t// called by \"main\".\n+\t\t//\n+\t\t//  0: runtime.sigprof\n+\t\t//  1: runtime.sighandler\n+\t\t//  2: runtime.sigtrampgo\n+\t\t//  3: runtime.sigtramp\n+\t\t//  4: <signal handler called>\n+\t\t//  5: main.interesting_routine\n+\t\t//  6: main.main\n+\t\t//\n+\t\t// To ensure a sane profile, walk through the frames in\n+\t\t// \"stklocs\" until we find the \"runtime.sigtramp\" frame, then\n+\t\t// report only those frames below the frame one down from\n+\t\t// that. If for some reason \"runtime.sigtramp\" is not present,\n+\t\t// don't make any changes.\n+\t\tframesToDiscard := 0\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tif stklocs[i].function == \"runtime.sigtramp\" && i+2 < n {\n+\t\t\t\tframesToDiscard = i + 2\n+\t\t\t\tn -= framesToDiscard\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n \t\tfor i := 0; i < n; i++ {\n-\t\t\tstk[i] = stklocs[i].pc\n+\t\t\tstk[i] = stklocs[i+framesToDiscard].pc\n \t\t}\n \t}\n "}]}