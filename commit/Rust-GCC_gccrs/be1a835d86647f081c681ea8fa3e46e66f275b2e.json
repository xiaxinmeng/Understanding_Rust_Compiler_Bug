{"sha": "be1a835d86647f081c681ea8fa3e46e66f275b2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmUxYTgzNWQ4NjY0N2YwODFjNjgxZWE4ZmEzZTQ2ZTY2ZjI3NWIyZQ==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2015-07-09T02:49:57Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2015-07-09T02:49:57Z"}, "message": "remove #if for HAVE_cc0 in combine.c\n\ngcc/ChangeLog:\n\n2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* combine.c (do_SUBST_MODE): Don't check the value of HAVE_cc0\n\twith the preprocessor.\n\t(combine_instructions): Likewise.\n\t(try_combine): Likewise.\n\t(subst): Likewise.\n\t(distribute_notes): Likewise.\n\nFrom-SVN: r225592", "tree": {"sha": "ca86450a0961d6ea4621114c54cee66c46da0b7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca86450a0961d6ea4621114c54cee66c46da0b7d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be1a835d86647f081c681ea8fa3e46e66f275b2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1a835d86647f081c681ea8fa3e46e66f275b2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be1a835d86647f081c681ea8fa3e46e66f275b2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be1a835d86647f081c681ea8fa3e46e66f275b2e/comments", "author": null, "committer": null, "parents": [{"sha": "f1657f05ef0fbc5183051de277141159f15a9472", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1657f05ef0fbc5183051de277141159f15a9472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1657f05ef0fbc5183051de277141159f15a9472"}], "stats": {"total": 71, "additions": 36, "deletions": 35}, "files": [{"sha": "59afe38ffef94cdb35e26c90da22f8942570c0ac", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1a835d86647f081c681ea8fa3e46e66f275b2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1a835d86647f081c681ea8fa3e46e66f275b2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=be1a835d86647f081c681ea8fa3e46e66f275b2e", "patch": "@@ -1,3 +1,12 @@\n+2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* combine.c (do_SUBST_MODE): Don't check the value of HAVE_cc0\n+\twith the preprocessor.\n+\t(combine_instructions): Likewise.\n+\t(try_combine): Likewise.\n+\t(subst): Likewise.\n+\t(distribute_notes): Likewise.\n+\n 2015-07-08  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* combine.c (try_combine): Don't check if LOAD_EXTEND_OP is"}, {"sha": "19aa0e1e6b5de4f4d8debd7ebb8e9a970186fe9b", "filename": "gcc/combine.c", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be1a835d86647f081c681ea8fa3e46e66f275b2e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be1a835d86647f081c681ea8fa3e46e66f275b2e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=be1a835d86647f081c681ea8fa3e46e66f275b2e", "patch": "@@ -818,7 +818,6 @@ do_SUBST_MODE (rtx *into, machine_mode newval)\n \n #define SUBST_MODE(INTO, NEWVAL)  do_SUBST_MODE (&(INTO), (NEWVAL))\n \n-#if !HAVE_cc0\n /* Similar to SUBST, but NEWVAL is a LOG_LINKS expression.  */\n \n static void\n@@ -844,7 +843,6 @@ do_SUBST_LINK (struct insn_link **into, struct insn_link *newval)\n }\n \n #define SUBST_LINK(oldval, newval) do_SUBST_LINK (&oldval, newval)\n-#endif\n \f\n /* Subroutine of try_combine.  Determine whether the replacement patterns\n    NEWPAT, NEWI2PAT and NEWOTHERPAT are cheaper according to insn_rtx_cost\n@@ -1135,9 +1133,7 @@ static int\n combine_instructions (rtx_insn *f, unsigned int nregs)\n {\n   rtx_insn *insn, *next;\n-#if HAVE_cc0\n   rtx_insn *prev;\n-#endif\n   struct insn_link *links, *nextlinks;\n   rtx_insn *first;\n   basic_block last_bb;\n@@ -1312,15 +1308,15 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t\t    }\n \t      }\n \n-#if HAVE_cc0\n \t  /* Try to combine a jump insn that uses CC0\n \t     with a preceding insn that sets CC0, and maybe with its\n \t     logical predecessor as well.\n \t     This is how we make decrement-and-branch insns.\n \t     We need this special code because data flow connections\n \t     via CC0 do not get entered in LOG_LINKS.  */\n \n-\t  if (JUMP_P (insn)\n+\t  if (HAVE_cc0\n+\t      && JUMP_P (insn)\n \t      && (prev = prev_nonnote_insn (insn)) != 0\n \t      && NONJUMP_INSN_P (prev)\n \t      && sets_cc0_p (PATTERN (prev)))\n@@ -1338,7 +1334,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t    }\n \n \t  /* Do the same for an insn that explicitly references CC0.  */\n-\t  if (NONJUMP_INSN_P (insn)\n+\t  if (HAVE_cc0 && NONJUMP_INSN_P (insn)\n \t      && (prev = prev_nonnote_insn (insn)) != 0\n \t      && NONJUMP_INSN_P (prev)\n \t      && sets_cc0_p (PATTERN (prev))\n@@ -1360,18 +1356,20 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n \t  /* Finally, see if any of the insns that this insn links to\n \t     explicitly references CC0.  If so, try this insn, that insn,\n \t     and its predecessor if it sets CC0.  */\n-\t  FOR_EACH_LOG_LINK (links, insn)\n-\t      if (NONJUMP_INSN_P (links->insn)\n-\t\t  && GET_CODE (PATTERN (links->insn)) == SET\n-\t\t  && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n-\t\t  && (prev = prev_nonnote_insn (links->insn)) != 0\n-\t\t  && NONJUMP_INSN_P (prev)\n-\t\t  && sets_cc0_p (PATTERN (prev))\n-\t\t  && (next = try_combine (insn, links->insn,\n-\t\t\t\t\t  prev, NULL, &new_direct_jump_p,\n-\t\t\t\t\t  last_combined_insn)) != 0)\n-\t\tgoto retry;\n-#endif\n+\t  if (HAVE_cc0)\n+\t    {\n+\t      FOR_EACH_LOG_LINK (links, insn)\n+\t\tif (NONJUMP_INSN_P (links->insn)\n+\t\t    && GET_CODE (PATTERN (links->insn)) == SET\n+\t\t    && reg_mentioned_p (cc0_rtx, SET_SRC (PATTERN (links->insn)))\n+\t\t    && (prev = prev_nonnote_insn (links->insn)) != 0\n+\t\t    && NONJUMP_INSN_P (prev)\n+\t\t    && sets_cc0_p (PATTERN (prev))\n+\t\t    && (next = try_combine (insn, links->insn,\n+\t\t\t\t\t    prev, NULL, &new_direct_jump_p,\n+\t\t\t\t\t    last_combined_insn)) != 0)\n+\t\t  goto retry;\n+\t    }\n \n \t  /* Try combining an insn with two different insns whose results it\n \t     uses.  */\n@@ -2539,7 +2537,6 @@ is_parallel_of_n_reg_sets (rtx pat, int n)\n   return true;\n }\n \n-#if !HAVE_cc0\n /* Return whether INSN, a PARALLEL of N register SETs (and maybe some\n    CLOBBERs), can be split into individual SETs in that order, without\n    changing semantics.  */\n@@ -2566,7 +2563,6 @@ can_split_parallel_of_n_reg_sets (rtx_insn *insn, int n)\n \n   return true;\n }\n-#endif\n \n /* Try to combine the insns I0, I1 and I2 into I3.\n    Here I0, I1 and I2 appear earlier than I3.\n@@ -2913,7 +2909,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t}\n     }\n \n-#if !HAVE_cc0\n   /* If we have no I1 and I2 looks like:\n \t(parallel [(set (reg:CC X) (compare:CC OP (const_int 0)))\n \t\t   (set Y OP)])\n@@ -2927,7 +2922,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n      This undoes a previous combination and allows us to match a branch-and-\n      decrement insn.  */\n \n-  if (i1 == 0\n+  if (!HAVE_cc0 && i1 == 0\n       && is_parallel_of_n_reg_sets (PATTERN (i2), 2)\n       && (GET_MODE_CLASS (GET_MODE (SET_DEST (XVECEXP (PATTERN (i2), 0, 0))))\n \t  == MODE_CC)\n@@ -2959,7 +2954,7 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n   /* If I2 is a PARALLEL of two SETs of REGs (and perhaps some CLOBBERs),\n      make those two SETs separate I1 and I2 insns, and make an I0 that is\n      the original I1.  */\n-  if (i0 == 0\n+  if (!HAVE_cc0 && i0 == 0\n       && is_parallel_of_n_reg_sets (PATTERN (i2), 2)\n       && can_split_parallel_of_n_reg_sets (i2, 2)\n       && !reg_used_between_p (SET_DEST (XVECEXP (PATTERN (i2), 0, 0)), i2, i3)\n@@ -2980,7 +2975,6 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n       SUBST (PATTERN (i2), XVECEXP (PATTERN (i2), 0, 1));\n     }\n-#endif\n \n   /* Verify that I2 and I1 are valid for combining.  */\n   if (! can_combine_p (i2, i3, i0, i1, NULL, NULL, &i2dest, &i2src)\n@@ -5375,10 +5369,10 @@ subst (rtx x, rtx from, rtx to, int in_dest, int in_cond, int unique_copy)\n \t\t      && ! (code == SUBREG\n \t\t\t    && MODES_TIEABLE_P (GET_MODE (x),\n \t\t\t\t\t\tGET_MODE (SUBREG_REG (to))))\n-#if HAVE_cc0\n-\t\t      && ! (code == SET && i == 1 && XEXP (x, 0) == cc0_rtx)\n-#endif\n-\t\t      )\n+\t\t      && (!HAVE_cc0\n+\t\t\t  || (! (code == SET\n+\t\t\t\t && i == 1\n+\t\t\t\t && XEXP (x, 0) == cc0_rtx))))\n \t\t    return gen_rtx_CLOBBER (VOIDmode, const0_rtx);\n \n \t\t  if (code == SUBREG\n@@ -13941,12 +13935,10 @@ distribute_notes (rtx notes, rtx_insn *from_insn, rtx_insn *i3, rtx_insn *i2,\n \n \t\t      if (set != 0 && ! side_effects_p (SET_SRC (set))\n \t\t\t  && rtx_equal_p (XEXP (note, 0), inner_dest)\n-#if HAVE_cc0\n-\t\t\t  && (! reg_mentioned_p (cc0_rtx, SET_SRC (set))\n-\t\t\t      || ((cc0_setter = prev_cc0_setter (tem_insn)) != NULL\n-\t\t\t\t  && sets_cc0_p (PATTERN (cc0_setter)) > 0))\n-#endif\n-\t\t\t  )\n+\t\t\t  && (!HAVE_cc0\n+\t\t\t      || (! reg_mentioned_p (cc0_rtx, SET_SRC (set))\n+\t\t\t\t  || ((cc0_setter = prev_cc0_setter (tem_insn)) != NULL\n+\t\t\t\t      && sets_cc0_p (PATTERN (cc0_setter)) > 0))))\n \t\t\t{\n \t\t\t  /* Move the notes and links of TEM_INSN elsewhere.\n \t\t\t     This might delete other dead insns recursively."}]}