{"sha": "f667741c42d3bc8082877638726e4d3a22285431", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY2Nzc0MWM0MmQzYmM4MDgyODc3NjM4NzI2ZTRkM2EyMjI4NTQzMQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-05-26T22:36:49Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-05-26T22:36:49Z"}, "message": "gimplify.c (compare_case_labels): New function.\n\n\t* gimplify.c (compare_case_labels): New function.\n\t(gimplify_switch_expr): Sort case labels, and make sure the\n\tlast label in the label vector is the default case.\n\t* tree-cfg.c (group_case_labels): New function.\n\t(build_tree_cfg): Cleanup redundant labels and group case labels\n\tbefore creating edges.\n\t(cleanup_dead_labels): Handle GOTO_EXPRs.\n\t(find_case_label_for_value): Use a binary search to find the\n\tcase label for the given value.\n\t* tree-gimple.c: Mention that labels are sorted, and that the\n\tlast label must be the default.\n\nFrom-SVN: r82297", "tree": {"sha": "9a721edcedc47294d0570c2ba52be9541243aeec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a721edcedc47294d0570c2ba52be9541243aeec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f667741c42d3bc8082877638726e4d3a22285431", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f667741c42d3bc8082877638726e4d3a22285431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f667741c42d3bc8082877638726e4d3a22285431", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f667741c42d3bc8082877638726e4d3a22285431/comments", "author": null, "committer": null, "parents": [{"sha": "e4efa9715632519e202f57250b3d8954b17ac9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4efa9715632519e202f57250b3d8954b17ac9c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4efa9715632519e202f57250b3d8954b17ac9c9"}], "stats": {"total": 201, "additions": 165, "deletions": 36}, "files": [{"sha": "5e7738ed12a96dea162118edd386df72193d61d9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f667741c42d3bc8082877638726e4d3a22285431/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f667741c42d3bc8082877638726e4d3a22285431/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f667741c42d3bc8082877638726e4d3a22285431", "patch": "@@ -1,3 +1,17 @@\n+2004-05-27  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* gimplify.c (compare_case_labels): New function.\n+\t(gimplify_switch_expr): Sort case labels, and make sure the\n+\tlast label in the label vector is the default case.\n+\t* tree-cfg.c (group_case_labels): New function.\n+\t(build_tree_cfg): Cleanup redundant labels and group case labels\n+\tbefore creating edges.\n+\t(cleanup_dead_labels): Handle GOTO_EXPRs.\n+\t(find_case_label_for_value): Use a binary search to find the\n+\tcase label for the given value.\n+\t* tree-gimple.c: Mention that labels are sorted, and that the\n+\tlast label must be the default.\n+\n 2004-05-27  Jan Hubicka  <jh@suse.cz>\n \n \t* cfgcleanup.c (try_optimize_cfg): Do not merge across jumptables."}, {"sha": "621569bf5934ba0de6423c4264933c8e41a037dd", "filename": "gcc/gimplify.c", "status": "modified", "additions": 33, "deletions": 17, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=f667741c42d3bc8082877638726e4d3a22285431", "patch": "@@ -981,6 +981,19 @@ gimplify_loop_expr (tree *expr_p, tree *pre_p)\n   return GS_ALL_DONE;\n }\n \n+/* Compare two case labels.  Because the front end should already have\n+   made sure that case ranges do not overlap, it is enough to only compare\n+   the CASE_LOW values of each case label.  */\n+\n+static int\n+compare_case_labels (const void *p1, const void *p2)\n+{\n+  tree case1 = *(tree *)p1;\n+  tree case2 = *(tree *)p2;\n+\n+  return tree_int_cst_compare (CASE_LOW (case1), CASE_LOW (case2));\n+}\n+\n /* Gimplify a SWITCH_EXPR, and collect a TREE_VEC of the labels it can\n    branch to.  */\n \n@@ -996,8 +1009,7 @@ gimplify_switch_expr (tree *expr_p, tree *pre_p)\n   if (SWITCH_BODY (switch_expr))\n     {\n       varray_type labels, saved_labels;\n-      bool saw_default;\n-      tree label_vec, t;\n+      tree label_vec, default_case = NULL_TREE;\n       size_t i, len;\n \n       /* If someone can be bothered to fill in the labels, they can\n@@ -1014,39 +1026,43 @@ gimplify_switch_expr (tree *expr_p, tree *pre_p)\n       gimplify_ctxp->case_labels = saved_labels;\n \n       len = VARRAY_ACTIVE_SIZE (labels);\n-      saw_default = false;\n \n       for (i = 0; i < len; ++i)\n \t{\n-\t  t = VARRAY_TREE (labels, i);\n+\t  tree t = VARRAY_TREE (labels, i);\n \t  if (!CASE_LOW (t))\n \t    {\n-\t      saw_default = true;\n+\t      /* The default case must be the last label in the list.  */\n+\t      default_case = t;\n+\t      VARRAY_TREE (labels, i) = VARRAY_TREE (labels, len - 1);\n+\t      len--;\n \t      break;\n \t    }\n \t}\n \n-      label_vec = make_tree_vec (len + !saw_default);\n+      label_vec = make_tree_vec (len + 1);\n       SWITCH_LABELS (*expr_p) = label_vec;\n-\n-      for (i = 0; i < len; ++i)\n-\tTREE_VEC_ELT (label_vec, i) = VARRAY_TREE (labels, i);\n-\n       append_to_statement_list (switch_expr, pre_p);\n \n-      /* If the switch has no default label, add one, so that we jump\n-\t around the switch body.  */\n-      if (!saw_default)\n+      if (! default_case)\n \t{\n-\t  t = build (CASE_LABEL_EXPR, void_type_node, NULL_TREE,\n-\t\t     NULL_TREE, create_artificial_label ());\n-\t  TREE_VEC_ELT (label_vec, len) = t;\n+\t  /* If the switch has no default label, add one, so that we jump\n+\t     around the switch body.  */\n+\t  default_case = build (CASE_LABEL_EXPR, void_type_node, NULL_TREE,\n+\t\t\t\tNULL_TREE, create_artificial_label ());\n \t  append_to_statement_list (SWITCH_BODY (switch_expr), pre_p);\n-\t  *expr_p = build (LABEL_EXPR, void_type_node, CASE_LABEL (t));\n+\t  *expr_p = build (LABEL_EXPR, void_type_node,\n+\t\t\t   CASE_LABEL (default_case));\n \t}\n       else\n \t*expr_p = SWITCH_BODY (switch_expr);\n \n+      qsort (&VARRAY_TREE (labels, 0), len, sizeof (tree),\n+\t     compare_case_labels);\n+      for (i = 0; i < len; ++i)\n+\tTREE_VEC_ELT (label_vec, i) = VARRAY_TREE (labels, i);\n+      TREE_VEC_ELT (label_vec, len) = default_case;\n+\n       SWITCH_BODY (switch_expr) = NULL;\n     }\n   else if (!SWITCH_LABELS (switch_expr))"}, {"sha": "7c4c67b3bd7aea56fa8873158a34f382ff9b2478", "filename": "gcc/stmt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=f667741c42d3bc8082877638726e4d3a22285431", "patch": "@@ -4434,8 +4434,8 @@ bool lshift_cheap_p (void)\n    number of case nodes, i.e. the node with the most cases gets\n    tested first.  */\n \n-static\n-int case_bit_test_cmp (const void *p1, const void *p2)\n+static int\n+case_bit_test_cmp (const void *p1, const void *p2)\n {\n   const struct case_bit_test *d1 = p1;\n   const struct case_bit_test *d2 = p2;"}, {"sha": "5385686ecdd1ac879987d4c578d6ad936733984d", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 114, "deletions": 17, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=f667741c42d3bc8082877638726e4d3a22285431", "patch": "@@ -100,6 +100,7 @@ static void tree_cfg2vcg (FILE *);\n static void tree_merge_blocks (basic_block, basic_block);\n static bool tree_can_merge_blocks_p (basic_block, basic_block);\n static void remove_bb (basic_block);\n+static void group_case_labels (void);\n static void cleanup_dead_labels (void);\n static bool cleanup_control_flow (void);\n static bool cleanup_control_expr_graph (basic_block, block_stmt_iterator);\n@@ -160,6 +161,14 @@ build_tree_cfg (tree *tp)\n   /* Adjust the size of the array.  */\n   VARRAY_GROW (basic_block_info, n_basic_blocks);\n \n+  /* To speed up statement iterator walks, we first purge dead labels.  */\n+  cleanup_dead_labels ();\n+\n+  /* Group case nodes to reduce the number of edges.\n+     We do this after cleaning up dead labels because otherwise we miss\n+     a lot of obvious case merging opportunities.  */\n+  group_case_labels ();\n+\n   /* Create the edges of the flowgraph.  */\n   make_edges ();\n \n@@ -470,9 +479,6 @@ make_edges (void)\n      builder inserted for completeness.  */\n   remove_fake_edges ();\n \n-  /* To speed up statement iterator walks, we first purge dead labels.  */\n-  cleanup_dead_labels ();\n-\n   /* Clean up the graph and warn for unreachable code.  */\n   cleanup_tree_cfg ();\n }\n@@ -842,6 +848,17 @@ cleanup_dead_labels (void)\n \t    break;\n \t  }\n \n+\t/* We have to handle GOTO_EXPRs until they're removed, and we don't\n+\t   remove them until after we've created the CFG edges.  */\n+\tcase GOTO_EXPR:\n+\t  {\n+\t    tree label = GOTO_DESTINATION (stmt);\n+\t    if (! computed_goto_p (stmt))\n+\t      GOTO_DESTINATION (stmt) =\n+\t\tlabel_for_bb[label_to_block (label)->index];\n+\t    break;\n+\t  }\n+\n \tdefault:\n \t  break;\n       }\n@@ -878,6 +895,80 @@ cleanup_dead_labels (void)\n   free (label_for_bb);\n }\n \n+/* Look for blocks ending in a multiway branch (a SWITCH_EXPR in GIMPLE),\n+   and scan the sorted vector of cases.  Combine the ones jumping to the\n+   same label.\n+   Eg. three separate entries 1: 2: 3: become one entry 1..3:  */\n+\n+static void\n+group_case_labels (void)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      tree stmt = last_stmt (bb);\n+      if (stmt && TREE_CODE (stmt) == SWITCH_EXPR)\n+\t{\n+\t  tree labels = SWITCH_LABELS (stmt);\n+\t  int old_size = TREE_VEC_LENGTH (labels);\n+\t  int i, j, new_size = old_size;\n+\n+\t  /* Look for possible opportunities to merge cases.\n+\t     Ignore the last element of the label vector because it\n+\t     must be the default case.  */\n+          i = 0;\n+\t  while (i < old_size - 2)\n+\t    {\n+\t      tree base_case, base_label, base_high, type;\n+\t      base_case = TREE_VEC_ELT (labels, i);\n+\n+\t      if (! base_case)\n+\t\tabort ();\n+\n+\t      type = TREE_TYPE (CASE_LOW (base_case));\n+\t      base_label = CASE_LABEL (base_case);\n+\t      base_high = CASE_HIGH (base_case) ?\n+\t\tCASE_HIGH (base_case) : CASE_LOW (base_case);\n+\n+\t      /* Try to merge case labels.  Break out when we reach the end\n+\t\t of the label vector or when we cannot merge the next case\n+\t\t label with the current one.  */\n+\t      while (i < old_size - 2)\n+\t\t{\n+\t\t  tree merge_case = TREE_VEC_ELT (labels, ++i);\n+\t          tree merge_label = CASE_LABEL (merge_case);\n+\t\t  tree t = int_const_binop (PLUS_EXPR, base_high,\n+\t\t\t\t\t    integer_one_node, 1);\n+\n+\t\t  /* Merge the cases if they jump to the same place,\n+\t\t     and their ranges are consecutive.  */\n+\t\t  if (merge_label == base_label\n+\t\t      && tree_int_cst_equal (CASE_LOW (merge_case), t))\n+\t\t    {\n+\t\t      base_high = CASE_HIGH (merge_case) ?\n+\t\t\tCASE_HIGH (merge_case) : CASE_LOW (merge_case);\n+\t\t      CASE_HIGH (base_case) = base_high;\n+\t\t      TREE_VEC_ELT (labels, i) = NULL_TREE;\n+\t\t      new_size--;\n+\t\t    }\n+\t\t  else\n+\t\t    break;\n+\t\t}\n+\t    }\n+\n+\t  /* Compress the case labels in the label vector, and adjust the\n+\t     length of the vector.  */\n+\t  for (i = 0, j = 0; i < new_size; i++)\n+\t    {\n+\t      while (! TREE_VEC_ELT (labels, j))\n+\t\tj++;\n+\t      TREE_VEC_ELT (labels, i) = TREE_VEC_ELT (labels, j++);\n+\t    }\n+\t  TREE_VEC_LENGTH (labels) = new_size;\n+\t}\n+    }\n+}\n \n /* Checks whether we can merge block B into block A.  */\n \n@@ -1940,39 +2031,45 @@ find_taken_edge_switch_expr (basic_block bb, tree val)\n }\n \n \n-/* Return the CASE_LABEL_EXPR that SWITCH_EXPR will take for VAL.  */\n+/* Return the CASE_LABEL_EXPR that SWITCH_EXPR will take for VAL.\n+   We can make optimal use here of the fact that the case labels are\n+   sorted: We can do a binary search for a case matching VAL.  */\n \n static tree\n find_case_label_for_value (tree switch_expr, tree val)\n {\n   tree vec = SWITCH_LABELS (switch_expr);\n-  size_t i, n = TREE_VEC_LENGTH (vec);\n-  tree default_case = NULL;\n+  size_t low, high, n = TREE_VEC_LENGTH (vec);\n+  tree default_case = TREE_VEC_ELT (vec, n - 1);\n \n-  for (i = 0; i < n; ++i)\n+  for (low = -1, high = n - 1; high - low > 1; )\n     {\n+      size_t i = (high + low) / 2;\n       tree t = TREE_VEC_ELT (vec, i);\n+      int cmp;\n \n-      if (CASE_LOW (t) == NULL)\n-\tdefault_case = t;\n-      else if (CASE_HIGH (t) == NULL)\n+      /* Cache the result of comparing CASE_LOW and val.  */\n+      cmp = tree_int_cst_compare (CASE_LOW (t), val);\n+\n+      if (cmp > 0)\n+\thigh = i;\n+      else\n+\tlow = i;\n+\n+      if (CASE_HIGH (t) == NULL)\n \t{\n-\t  /* A `normal' case label.  */\n-\t  if (tree_int_cst_equal (CASE_LOW (t), val))\n+\t  /* A singe-valued case label.  */\n+\t  if (cmp == 0)\n \t    return t;\n \t}\n       else\n \t{\n \t  /* A case range.  We can only handle integer ranges.  */\n-\t  if (tree_int_cst_compare (CASE_LOW (t), val) <= 0\n-\t      && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n+\t  if (cmp <= 0 && tree_int_cst_compare (CASE_HIGH (t), val) >= 0)\n \t    return t;\n \t}\n     }\n \n-  if (!default_case)\n-    abort ();\n-\n   return default_case;\n }\n "}, {"sha": "e749ec80097948216e9f0d8e903b97b4f3264340", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f667741c42d3bc8082877638726e4d3a22285431/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=f667741c42d3bc8082877638726e4d3a22285431", "patch": "@@ -73,6 +73,8 @@ Boston, MA 02111-1307, USA.  */\n        op1 -> stmt\n        op2 -> array of case labels (as LABEL_DECLs?)\n          FIXME: add case value info\n+\tThe SWITCH_LABELS (op2) are sorted in ascending order, and the\n+\tlast label in the vector is always the default case.\n    jump-stmt:\n        GOTO_EXPR\n          op0 -> LABEL_DECL | '*' ID"}]}