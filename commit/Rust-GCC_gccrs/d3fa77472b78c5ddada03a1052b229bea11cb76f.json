{"sha": "d3fa77472b78c5ddada03a1052b229bea11cb76f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNmYTc3NDcyYjc4YzVkZGFkYTAzYTEwNTJiMjI5YmVhMTFjYjc2Zg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-19T19:54:57Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-07-22T12:51:59Z"}, "message": "Allow non-symmetrical equivalences.\n\nDon't trap if equivalences are processed out of DOM order, and aren't\ncompletely symmetrical.  We will eventually resolve this, but its OK for now.\n\n\tgcc/\n\tPR tree-optimization/101511\n\t* value-relation.cc (relation_oracle::query_relation): Check if ssa1\n\tis in ssa2's equiv set, and don't trap if so.\n\n\tgcc/testsuite/\n\t* g++.dg/pr101511.C: New.", "tree": {"sha": "5d54b55a6f19824d72aecc50a54623b1260bef5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d54b55a6f19824d72aecc50a54623b1260bef5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3fa77472b78c5ddada03a1052b229bea11cb76f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3fa77472b78c5ddada03a1052b229bea11cb76f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3fa77472b78c5ddada03a1052b229bea11cb76f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3fa77472b78c5ddada03a1052b229bea11cb76f/comments", "author": null, "committer": null, "parents": [{"sha": "ea789238b2c24eedf70b56257235adf3d33c5a0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea789238b2c24eedf70b56257235adf3d33c5a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea789238b2c24eedf70b56257235adf3d33c5a0a"}], "stats": {"total": 30, "additions": 28, "deletions": 2}, "files": [{"sha": "ee2c7fdbc02e93bc5bae54fe4ccd6454e6181ad9", "filename": "gcc/testsuite/g++.dg/pr101511.C", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3fa77472b78c5ddada03a1052b229bea11cb76f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr101511.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3fa77472b78c5ddada03a1052b229bea11cb76f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr101511.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fpr101511.C?ref=d3fa77472b78c5ddada03a1052b229bea11cb76f", "patch": "@@ -0,0 +1,22 @@\n+// { dg-do compile }\n+// { dg-options \"-O2 -Wno-div-by-zero\" }\n+\n+void __assert_fail(const char *, const char *, int, const char *)\n+    __attribute__((__noreturn__));\n+template <typename T> void test_uint() {\n+  long __trans_tmp_3, __trans_tmp_1;\n+  int Error;\n+  for (;;) {\n+    {\n+      unsigned long Tmp = -1;\n+      __trans_tmp_3 = Tmp - Tmp % 0;\n+    }\n+    Error += 0 == __trans_tmp_3 ? 0 : 1;\n+    !Error ? void() : __assert_fail(\"\", \"\", 3, __PRETTY_FUNCTION__);\n+    T Tmp = -1;\n+    __trans_tmp_1 = Tmp - Tmp % 0;\n+    Error += 0 == __trans_tmp_1 ? 0 : 1;\n+    !Error ? void() : __assert_fail(\"\", \"\", 7, __PRETTY_FUNCTION__);\n+  }\n+}\n+void test() { test_uint<unsigned long>(); }"}, {"sha": "bcfe388acf13b0ca7e2a3da5d771694d6e739999", "filename": "gcc/value-relation.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3fa77472b78c5ddada03a1052b229bea11cb76f/gcc%2Fvalue-relation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3fa77472b78c5ddada03a1052b229bea11cb76f/gcc%2Fvalue-relation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-relation.cc?ref=d3fa77472b78c5ddada03a1052b229bea11cb76f", "patch": "@@ -873,11 +873,15 @@ relation_oracle::query_relation (basic_block bb, tree ssa1, tree ssa2)\n   if (kind != VREL_NONE)\n     return kind;\n \n-  // If one is not found, see if there is a relationship between equivalences.\n   // If v2 isn't in v1s equiv set, then v1 shouldn't be in v2's set either.\n+  // It is possible for out-of-order dominator processing to have an out of\n+  // sync set of equivalences..  Down the road, when we do full updates,\n+  // change this to an assert to ensure everything is in sync.\n   const_bitmap equiv2 = equiv_set (ssa2, bb);\n-  gcc_checking_assert (!equiv2 || !bitmap_bit_p (equiv2, v1));\n+  if (equiv2 && bitmap_bit_p (equiv2, v1))\n+    return EQ_EXPR;\n \n+  // If not equal, see if there is a relationship between equivalences.\n   if (!equiv1 && !equiv2)\n     kind = VREL_NONE;\n   else if (!equiv1)"}]}