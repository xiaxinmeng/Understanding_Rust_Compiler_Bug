{"sha": "76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmMGFhNmM1YWI3ZDE3ZjA2ZTY5N2VlYmUwNjRlZWRmMmU2ZjRmNg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-02-03T09:39:19Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-02-03T09:39:19Z"}, "message": "re PR other/63504 (Issues found by --enable-checking=valgrind)\n\n\tPR other/63504\n\t* combine.c (reg_n_sets_max): New variable.\n\t(can_change_dest_mode, reg_nonzero_bits_for_combine,\n\treg_num_sign_bit_copies_for_combine, get_last_value_validate,\n\tget_last_value): Use REG_N_SETS only on pseudos < reg_n_sets_max.\n\t(try_combine): Use INC_REG_N_SETS only on pseudos < reg_n_sets_max.\n\t(rest_of_handle_combine): Initialize reg_n_sets_max.\n\nFrom-SVN: r220368", "tree": {"sha": "890b1a63a0d1cbb4c44bd202844d23c65550637a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/890b1a63a0d1cbb4c44bd202844d23c65550637a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8abc9ba2d15ac7ee06ce9c135732276203ece1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8abc9ba2d15ac7ee06ce9c135732276203ece1d"}], "stats": {"total": 43, "additions": 38, "deletions": 5}, "files": [{"sha": "8764b12f47c13db6600f2ddf6ab4bb5fe306843d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "patch": "@@ -1,3 +1,13 @@\n+2015-02-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR other/63504\n+\t* combine.c (reg_n_sets_max): New variable.\n+\t(can_change_dest_mode, reg_nonzero_bits_for_combine,\n+\treg_num_sign_bit_copies_for_combine, get_last_value_validate,\n+\tget_last_value): Use REG_N_SETS only on pseudos < reg_n_sets_max.\n+\t(try_combine): Use INC_REG_N_SETS only on pseudos < reg_n_sets_max.\n+\t(rest_of_handle_combine): Initialize reg_n_sets_max.\n+\n 2015-02-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-inline.c (early_inliner): Skip inlining only in always_inlined;"}, {"sha": "f779117cd7174f463c4eccd88fdb0a9f14a1f311", "filename": "gcc/combine.c", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=76f0aa6c5ab7d17f06e697eebe064eedf2e6f4f6", "patch": "@@ -284,6 +284,16 @@ typedef struct reg_stat_struct {\n \n static vec<reg_stat_type> reg_stat;\n \n+/* One plus the highest pseudo for which we track REG_N_SETS.\n+   regstat_init_n_sets_and_refs allocates the array for REG_N_SETS just once,\n+   but during combine_split_insns new pseudos can be created.  As we don't have\n+   updated DF information in that case, it is hard to initialize the array\n+   after growing.  The combiner only cares about REG_N_SETS (regno) == 1,\n+   so instead of growing the arrays, just assume all newly created pseudos\n+   during combine might be set multiple times.  */\n+\n+static unsigned int reg_n_sets_max;\n+\n /* Record the luid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n \n@@ -2420,7 +2430,9 @@ can_change_dest_mode (rtx x, int added_sets, machine_mode mode)\n \t\t>= hard_regno_nregs[regno][mode]));\n \n   /* Or a pseudo that is only used once.  */\n-  return (REG_N_SETS (regno) == 1 && !added_sets\n+  return (regno < reg_n_sets_max\n+\t  && REG_N_SETS (regno) == 1\n+\t  && !added_sets\n \t  && !REG_USERVAR_P (x));\n }\n \n@@ -3630,7 +3642,8 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n \t      if (REG_P (new_i3_dest)\n \t\t  && REG_P (new_i2_dest)\n-\t\t  && REGNO (new_i3_dest) == REGNO (new_i2_dest))\n+\t\t  && REGNO (new_i3_dest) == REGNO (new_i2_dest)\n+\t\t  && REGNO (new_i2_dest) < reg_n_sets_max)\n \t\tINC_REG_N_SETS (REGNO (new_i2_dest), 1);\n \t    }\n \t}\n@@ -4480,7 +4493,8 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \t   zero its use count so it won't make `reload' do any work.  */\n \tif (! added_sets_2\n \t    && (newi2pat == 0 || ! reg_mentioned_p (i2dest, newi2pat))\n-\t    && ! i2dest_in_i2src)\n+\t    && ! i2dest_in_i2src\n+\t    && REGNO (i2dest) < reg_n_sets_max)\n \t  INC_REG_N_SETS (REGNO (i2dest), -1);\n       }\n \n@@ -4497,7 +4511,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n \trecord_value_for_reg (i1dest, i1_insn, i1_val);\n \n-\tif (! added_sets_1 && ! i1dest_in_i1src)\n+\tif (! added_sets_1\n+\t    && ! i1dest_in_i1src\n+\t    && REGNO (i1dest) < reg_n_sets_max)\n \t  INC_REG_N_SETS (REGNO (i1dest), -1);\n       }\n \n@@ -4514,7 +4530,9 @@ try_combine (rtx_insn *i3, rtx_insn *i2, rtx_insn *i1, rtx_insn *i0,\n \n \trecord_value_for_reg (i0dest, i0_insn, i0_val);\n \n-\tif (! added_sets_0 && ! i0dest_in_i0src)\n+\tif (! added_sets_0\n+\t    && ! i0dest_in_i0src\n+\t    && REGNO (i0dest) < reg_n_sets_max)\n \t  INC_REG_N_SETS (REGNO (i0dest), -1);\n       }\n \n@@ -9750,6 +9768,7 @@ reg_nonzero_bits_for_combine (const_rtx x, machine_mode mode,\n \t  || (rsp->last_set_label == label_tick\n               && DF_INSN_LUID (rsp->last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t      && REGNO (x) < reg_n_sets_max\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n \t\t  (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n@@ -9825,6 +9844,7 @@ reg_num_sign_bit_copies_for_combine (const_rtx x, machine_mode mode,\n \t  || (rsp->last_set_label == label_tick\n               && DF_INSN_LUID (rsp->last_set) < subst_low_luid)\n \t  || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n+\t      && REGNO (x) < reg_n_sets_max\n \t      && REG_N_SETS (REGNO (x)) == 1\n \t      && !REGNO_REG_SET_P\n \t\t  (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n@@ -12863,6 +12883,7 @@ get_last_value_validate (rtx *loc, rtx_insn *insn, int tick, int replace)\n \t      /* If this is a pseudo-register that was only set once and not\n \t\t live at the beginning of the function, it is always valid.  */\n \t      || (! (regno >= FIRST_PSEUDO_REGISTER\n+\t\t     && regno < reg_n_sets_max\n \t\t     && REG_N_SETS (regno) == 1\n \t\t     && (!REGNO_REG_SET_P\n \t\t\t (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb),\n@@ -12979,6 +13000,7 @@ get_last_value (const_rtx x)\n   if (value == 0\n       || (rsp->last_set_label < label_tick_ebb_start\n \t  && (regno < FIRST_PSEUDO_REGISTER\n+\t      || regno >= reg_n_sets_max\n \t      || REG_N_SETS (regno) != 1\n \t      || REGNO_REG_SET_P\n \t\t (DF_LR_IN (ENTRY_BLOCK_PTR_FOR_FN (cfun)->next_bb), regno))))\n@@ -14166,6 +14188,7 @@ rest_of_handle_combine (void)\n   df_analyze ();\n \n   regstat_init_n_sets_and_refs ();\n+  reg_n_sets_max = max_reg_num ();\n \n   rebuild_jump_labels_after_combine\n     = combine_instructions (get_insns (), max_reg_num ());"}]}