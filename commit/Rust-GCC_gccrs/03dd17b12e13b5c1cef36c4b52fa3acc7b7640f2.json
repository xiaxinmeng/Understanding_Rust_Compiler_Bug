{"sha": "03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkZDE3YjEyZTEzYjVjMWNlZjM2YzRiNTJmYTNhY2M3Yjc2NDBmMg==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-08-22T02:23:19Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2012-08-22T02:23:19Z"}, "message": "constraints.md: New file.\n\n\t* config/m32c/constraints.md: New file.\n\t* config/m32c/t-m32c (MD_FILES): Add constraints.\n\t* config/m32c/m32c-protos.h (m32c_const_ok_for_constraint_p): Delete.\n\t(m32c_extra_address_constraint, m32c_extra_memory_constraint): Delete.\n\t(m32c_reg_class_from_constraint): Delete.\n\t(m32c_extra_constraint_p, m32c_extra_constraint_p2): Delete.\n\t(m32c_matches_constraint_p): Declare.\n\t* config/m32c/m32c.h (CONSTRAINT_LEN): Delete.\n\t(REG_CLASS_FROM_CONSTRAINT): Delete.\n\t(CONST_OK_FOR_CONSTRAINT_P): Delete.\n\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P): Delete.\n\t(EXTRA_CONSTRAINT_STR): Delete.\n\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Delete.\n\t* config/m32c/m32c.c: Include tm-constrs.h\n\t(m32c_reg_class_from_constraint): Delete.\n\t(m32c_const_ok_for_constraint_p): Delete.\n\t(m32c_extra_constraint_p2): Rename to...\n\t(m32c_matches_constraint_p): ...this.  Make it return bool.  Tweak\n\tformatting.\n\t(m32c_extra_constraint_p): Delete.\n\t(m32c_extra_address_constraint, m32c_extra_memory_constraint): Delete.\n\t(m32c_split_move): Use satisfies_constraint_Ss.\n\t* config/m32c/predicates.md (memsym_operand): Use \n\tsatisfies_constraint_Si.\n\t(memimmed_operand): Use satisfies_constraint_Sp.\n\t(m32c_psi_scale, m32c_1bit8_operand): Use satisfies_constraint_Ilb.\n\t(m32c_1bit16_operand): Use satisfies_constraint_Ilw.\n\t(m32c_1mask8_operand): Use satisfies_constraint_ImB.\n\t(m32c_1mask16_operand): Use satisfies_constraint_Imw.\n\nFrom-SVN: r190585", "tree": {"sha": "be7b56fe9dfc21819a3533ac4334a4007af10c31", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be7b56fe9dfc21819a3533ac4334a4007af10c31"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/comments", "author": null, "committer": null, "parents": [{"sha": "c42df5efd30bd44603c52935c963baa412854895", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c42df5efd30bd44603c52935c963baa412854895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c42df5efd30bd44603c52935c963baa412854895"}], "stats": {"total": 621, "additions": 318, "deletions": 303}, "files": [{"sha": "2c8b5becff38c947fd8d676fc607f3b5ce0dbb55", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -1,3 +1,35 @@\n+2012-08-21  Nathan Froyd  <froydnj@gcc.gnu.org>\n+\n+\t* config/m32c/constraints.md: New file.\n+\t* config/m32c/t-m32c (MD_FILES): Add constraints.\n+\t* config/m32c/m32c-protos.h (m32c_const_ok_for_constraint_p): Delete.\n+\t(m32c_extra_address_constraint, m32c_extra_memory_constraint): Delete.\n+\t(m32c_reg_class_from_constraint): Delete.\n+\t(m32c_extra_constraint_p, m32c_extra_constraint_p2): Delete.\n+\t(m32c_matches_constraint_p): Declare.\n+\t* config/m32c/m32c.h (CONSTRAINT_LEN): Delete.\n+\t(REG_CLASS_FROM_CONSTRAINT): Delete.\n+\t(CONST_OK_FOR_CONSTRAINT_P): Delete.\n+\t(CONST_DOUBLE_OK_FOR_CONSTRAINT_P): Delete.\n+\t(EXTRA_CONSTRAINT_STR): Delete.\n+\t(EXTRA_MEMORY_CONSTRAINT, EXTRA_ADDRESS_CONSTRAINT): Delete.\n+\t* config/m32c/m32c.c: Include tm-constrs.h\n+\t(m32c_reg_class_from_constraint): Delete.\n+\t(m32c_const_ok_for_constraint_p): Delete.\n+\t(m32c_extra_constraint_p2): Rename to...\n+\t(m32c_matches_constraint_p): ...this.  Make it return bool.  Tweak\n+\tformatting.\n+\t(m32c_extra_constraint_p): Delete.\n+\t(m32c_extra_address_constraint, m32c_extra_memory_constraint): Delete.\n+\t(m32c_split_move): Use satisfies_constraint_Ss.\n+\t* config/m32c/predicates.md (memsym_operand): Use \n+\tsatisfies_constraint_Si.\n+\t(memimmed_operand): Use satisfies_constraint_Sp.\n+\t(m32c_psi_scale, m32c_1bit8_operand): Use satisfies_constraint_Ilb.\n+\t(m32c_1bit16_operand): Use satisfies_constraint_Ilw.\n+\t(m32c_1mask8_operand): Use satisfies_constraint_ImB.\n+\t(m32c_1mask16_operand): Use satisfies_constraint_Imw.\n+\n 2012-08-21  Nathan Froyd  <froydnj@gcc.gnu.org>\n \n \t* config/mep/mep.h (REG_CLASS_FROM_CONSTRAINT): Delete."}, {"sha": "da7dda42e16463f5957ac46c4d8b861a35e5e7f1", "filename": "gcc/config/m32c/constraints.md", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fconstraints.md?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -0,0 +1,225 @@\n+;; m32c constraints\n+;; Copyright (C) 2012 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_register_constraint \"Rsp\" \"SP_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rfb\" \"FB_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rsb\" \"SB_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rcr\" \"TARGET_A16 ? CR_REGS : NO_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rcl\" \"TARGET_A24 ? CR_REGS : NO_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R0w\" \"R0_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R1w\" \"R1_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R2w\" \"R2_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R3w\" \"R3_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R02\" \"R02_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R13\" \"R13_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R03\" \"R03_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rdi\" \"DI_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rhl\" \"HL_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"R23\" \"R23_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Ra0\" \"A0_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Ra1\" \"A1_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Raa\" \"A_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Raw\" \"TARGET_A16 ? A_REGS : NO_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Ral\" \"TARGET_A24 ? A_REGS : NO_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rqi\" \"QI_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rad\" \"AD_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rsi\" \"SI_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rhi\" \"HI_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rhc\" \"HC_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rra\" \"RA_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rfl\" \"FLG_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rmm\" \"fixed_regs[MEM0_REGNO] ? NO_REGS : MEM_REGS\"\n+  \"@internal\")\n+\n+(define_register_constraint \"Rpi\" \"TARGET_A16 ? HI_REGS : RA_REGS\"\n+  \"@internal\")\n+\n+;;; For integer constant constraints:\n+;;; s=signed u=unsigned n=nonzero m=minus l=log2able,\n+;;; [sun] bits [SUN] bytes, p=pointer size\n+;;; I[-0-9][0-9] matches that number\n+\n+(define_constraint \"Is3\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -8, 7)\")))\n+\n+(define_constraint \"IS1\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -128, 127)\")))\n+\n+(define_constraint \"IS2\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -32768, 32767)\")))\n+\n+(define_constraint \"IU2\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 65535)\")))\n+\n+(define_constraint \"IU3\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, 0, 0x00ffffff)\")))\n+\n+(define_constraint \"In4\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -8, 8) && ival\")))\n+\n+(define_constraint \"In5\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -16, 16) && ival\")))\n+\n+(define_constraint \"In6\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -32, 32) && ival\")))\n+\n+(define_constraint \"IM2\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -65536, -1)\")))\n+\n+(define_constraint \"Ilb\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (ival), 0, 7)\")))\n+\n+(define_constraint \"Imb\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 ((ival ^ 0xff) & 0xff), 0, 7)\")))\n+\n+(define_constraint \"ImB\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 ((ival ^ 0xffff) & 0xffff), 0, 7)\")))\n+\n+(define_constraint \"Ilw\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 (ival), 0, 15)\")))\n+\n+(define_constraint \"Imw\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (exact_log2 ((ival ^ 0xffff) & 0xffff), 0, 15)\")))\n+\n+(define_constraint \"I00\"\n+  \"@internal\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 0\")))\n+\n+(define_memory_constraint \"SF\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_SF)\"))\n+\n+(define_memory_constraint \"Sd\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Sd)\"))\n+\n+(define_memory_constraint \"Sa\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Sa)\"))\n+\n+(define_memory_constraint \"Si\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Si)\"))\n+\n+(define_memory_constraint \"Ss\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Ss)\"))\n+\n+(define_memory_constraint \"Sf\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Sf)\"))\n+\n+(define_memory_constraint \"Sb\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Sb)\"))\n+\n+(define_memory_constraint \"Sp\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Sp)\"))\n+\n+(define_memory_constraint \"S1\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_S1)\"))\n+\n+(define_constraint \"Rpa\"\n+  \"@internal\"\n+  (match_test \"m32c_matches_constraint_p (op, CONSTRAINT_Rpa)\"))"}, {"sha": "1f70da1df22407242bf78234a6c17db69a933352", "filename": "gcc/config/m32c/m32c-protos.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c-protos.h?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -20,21 +20,17 @@\n    <http://www.gnu.org/licenses/>.  */\n \n void m32c_conditional_register_usage (void);\n-int  m32c_const_ok_for_constraint_p (HOST_WIDE_INT, char, const char *);\n unsigned int m32c_dwarf_frame_regnum (int);\n int  m32c_eh_return_data_regno (int);\n void m32c_emit_epilogue (void);\n void m32c_emit_prologue (void);\n int  m32c_epilogue_uses (int);\n-int  m32c_extra_address_constraint (char, const char *);\n-int  m32c_extra_memory_constraint (char, const char *);\n int  m32c_function_arg_regno_p (int);\n void m32c_init_expanders (void);\n int  m32c_initial_elimination_offset (int, int);\n void m32c_output_reg_pop (FILE *, int);\n void m32c_output_reg_push (FILE *, int);\n unsigned int  m32c_push_rounding (int);\n-int  m32c_reg_class_from_constraint (char, const char *);\n void m32c_register_pragmas (void);\n void m32c_note_pragma_address (const char *, unsigned);\n int  m32c_regno_ok_for_base_p (int);\n@@ -53,8 +49,7 @@ int  m32c_expand_movmemhi (rtx *);\n int  m32c_expand_movstr (rtx *);\n void m32c_expand_neg_mulpsi3 (rtx *);\n int  m32c_expand_setmemhi (rtx *);\n-int  m32c_extra_constraint_p (rtx, char, const char *);\n-int  m32c_extra_constraint_p2 (rtx, char, const char *);\n+bool m32c_matches_constraint_p (rtx, int);\n int  m32c_hard_regno_nregs (int, enum machine_mode);\n int  m32c_hard_regno_ok (int, enum machine_mode);\n bool m32c_illegal_subreg_p (rtx);"}, {"sha": "237917885226a64c27919e283366eb5685f6c27c", "filename": "gcc/config/m32c/m32c.c", "status": "modified", "additions": 52, "deletions": 270, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.c?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -48,6 +48,7 @@\n #include \"langhooks.h\"\n #include \"gimple.h\"\n #include \"df.h\"\n+#include \"tm-constrs.h\"\n \n /* Prototypes */\n \n@@ -629,94 +630,6 @@ m32c_regno_reg_class (int regno)\n     }\n }\n \n-/* Implements REG_CLASS_FROM_CONSTRAINT.  Note that some constraints only match\n-   for certain chip families.  */\n-int\n-m32c_reg_class_from_constraint (char c ATTRIBUTE_UNUSED, const char *s)\n-{\n-  if (memcmp (s, \"Rsp\", 3) == 0)\n-    return SP_REGS;\n-  if (memcmp (s, \"Rfb\", 3) == 0)\n-    return FB_REGS;\n-  if (memcmp (s, \"Rsb\", 3) == 0)\n-    return SB_REGS;\n-  if (memcmp (s, \"Rcr\", 3) == 0)\n-    return TARGET_A16 ? CR_REGS : NO_REGS;\n-  if (memcmp (s, \"Rcl\", 3) == 0)\n-    return TARGET_A24 ? CR_REGS : NO_REGS;\n-  if (memcmp (s, \"R0w\", 3) == 0)\n-    return R0_REGS;\n-  if (memcmp (s, \"R1w\", 3) == 0)\n-    return R1_REGS;\n-  if (memcmp (s, \"R2w\", 3) == 0)\n-    return R2_REGS;\n-  if (memcmp (s, \"R3w\", 3) == 0)\n-    return R3_REGS;\n-  if (memcmp (s, \"R02\", 3) == 0)\n-    return R02_REGS;\n-  if (memcmp (s, \"R13\", 3) == 0)\n-    return R13_REGS;\n-  if (memcmp (s, \"R03\", 3) == 0)\n-    return R03_REGS;\n-  if (memcmp (s, \"Rdi\", 3) == 0)\n-    return DI_REGS;\n-  if (memcmp (s, \"Rhl\", 3) == 0)\n-    return HL_REGS;\n-  if (memcmp (s, \"R23\", 3) == 0)\n-    return R23_REGS;\n-  if (memcmp (s, \"Ra0\", 3) == 0)\n-    return A0_REGS;\n-  if (memcmp (s, \"Ra1\", 3) == 0)\n-    return A1_REGS;\n-  if (memcmp (s, \"Raa\", 3) == 0)\n-    return A_REGS;\n-  if (memcmp (s, \"Raw\", 3) == 0)\n-    return TARGET_A16 ? A_REGS : NO_REGS;\n-  if (memcmp (s, \"Ral\", 3) == 0)\n-    return TARGET_A24 ? A_REGS : NO_REGS;\n-  if (memcmp (s, \"Rqi\", 3) == 0)\n-    return QI_REGS;\n-  if (memcmp (s, \"Rad\", 3) == 0)\n-    return AD_REGS;\n-  if (memcmp (s, \"Rsi\", 3) == 0)\n-    return SI_REGS;\n-  if (memcmp (s, \"Rhi\", 3) == 0)\n-    return HI_REGS;\n-  if (memcmp (s, \"Rhc\", 3) == 0)\n-    return HC_REGS;\n-  if (memcmp (s, \"Rra\", 3) == 0)\n-    return RA_REGS;\n-  if (memcmp (s, \"Rfl\", 3) == 0)\n-    return FLG_REGS;\n-  if (memcmp (s, \"Rmm\", 3) == 0)\n-    {\n-      if (fixed_regs[MEM0_REGNO])\n-\treturn NO_REGS;\n-      return MEM_REGS;\n-    }\n-\n-  /* PSImode registers - i.e. whatever can hold a pointer.  */\n-  if (memcmp (s, \"Rpi\", 3) == 0)\n-    {\n-      if (TARGET_A16)\n-\treturn HI_REGS;\n-      else\n-\treturn RA_REGS; /* r2r0 and r3r1 can hold pointers.  */\n-    }\n-\n-  /* We handle this one as an EXTRA_CONSTRAINT.  */\n-  if (memcmp (s, \"Rpa\", 3) == 0)\n-    return NO_REGS;\n-\n-  if (*s == 'R')\n-    {\n-      fprintf(stderr, \"unrecognized R constraint: %.3s\\n\", s);\n-      gcc_unreachable();\n-    }\n-\n-  return NO_REGS;\n-}\n-\n /* Implements REGNO_OK_FOR_BASE_P.  */\n int\n m32c_regno_ok_for_base_p (int regno)\n@@ -926,223 +839,92 @@ m32c_cannot_change_mode_class (enum machine_mode from,\n \t\t\t       && (REGNO (rtx) == AP_REGNO \\\n \t\t\t\t   || REGNO (rtx) >= FIRST_PSEUDO_REGISTER))\n \n-/* Implements CONST_OK_FOR_CONSTRAINT_P.  Currently, all constant\n-   constraints start with 'I', with the next two characters indicating\n-   the type and size of the range allowed.  */\n-int\n-m32c_const_ok_for_constraint_p (HOST_WIDE_INT value,\n-\t\t\t\tchar c ATTRIBUTE_UNUSED, const char *str)\n-{\n-  /* s=signed u=unsigned n=nonzero m=minus l=log2able,\n-     [sun] bits [SUN] bytes, p=pointer size\n-     I[-0-9][0-9] matches that number */\n-  if (memcmp (str, \"Is3\", 3) == 0)\n-    {\n-      return (-8 <= value && value <= 7);\n-    }\n-  if (memcmp (str, \"IS1\", 3) == 0)\n-    {\n-      return (-128 <= value && value <= 127);\n-    }\n-  if (memcmp (str, \"IS2\", 3) == 0)\n-    {\n-      return (-32768 <= value && value <= 32767);\n-    }\n-  if (memcmp (str, \"IU2\", 3) == 0)\n-    {\n-      return (0 <= value && value <= 65535);\n-    }\n-  if (memcmp (str, \"IU3\", 3) == 0)\n-    {\n-      return (0 <= value && value <= 0x00ffffff);\n-    }\n-  if (memcmp (str, \"In4\", 3) == 0)\n-    {\n-      return (-8 <= value && value && value <= 8);\n-    }\n-  if (memcmp (str, \"In5\", 3) == 0)\n-    {\n-      return (-16 <= value && value && value <= 16);\n-    }\n-  if (memcmp (str, \"In6\", 3) == 0)\n-    {\n-      return (-32 <= value && value && value <= 32);\n-    }\n-  if (memcmp (str, \"IM2\", 3) == 0)\n-    {\n-      return (-65536 <= value && value && value <= -1);\n-    }\n-  if (memcmp (str, \"Ilb\", 3) == 0)\n-    {\n-      int b = exact_log2 (value);\n-      return (b >= 0 && b <= 7);\n-    }\n-  if (memcmp (str, \"Imb\", 3) == 0)\n-    {\n-      int b = exact_log2 ((value ^ 0xff) & 0xff);\n-      return (b >= 0 && b <= 7);\n-    }\n-  if (memcmp (str, \"ImB\", 3) == 0)\n-    {\n-      int b = exact_log2 ((value ^ 0xffff) & 0xffff);\n-      return (b >= 0 && b <= 7);\n-    }\n-  if (memcmp (str, \"Ilw\", 3) == 0)\n-    {\n-      int b = exact_log2 (value);\n-      return (b >= 0 && b <= 15);\n-    }\n-  if (memcmp (str, \"Imw\", 3) == 0)\n-    {\n-      int b = exact_log2 ((value ^ 0xffff) & 0xffff);\n-      return (b >= 0 && b <= 15);\n-    }\n-  if (memcmp (str, \"I00\", 3) == 0)\n-    {\n-      return (value == 0);\n-    }\n-  return 0;\n-}\n-\n #define A0_OR_PSEUDO(x) (IS_REG(x, A0_REGNO) || REGNO (x) >= FIRST_PSEUDO_REGISTER)\n \n /* Implements EXTRA_CONSTRAINT_STR (see next function too).  'S' is\n    for memory constraints, plus \"Rpa\" for PARALLEL rtx's we use for\n    call return values.  */\n-int\n-m32c_extra_constraint_p2 (rtx value, char c ATTRIBUTE_UNUSED, const char *str)\n+bool\n+m32c_matches_constraint_p (rtx value, int constraint)\n {\n   encode_pattern (value);\n \n-  if (far_addr_space_p (value))\n-    {\n-      if (memcmp (str, \"SF\", 2) == 0)\n-\t{\n-\t  return (   (RTX_IS (\"mr\")\n-\t\t      && A0_OR_PSEUDO (patternr[1])\n-\t\t      && GET_MODE (patternr[1]) == SImode)\n-\t\t     || (RTX_IS (\"m+^Sri\")\n-\t\t\t && A0_OR_PSEUDO (patternr[4])\n-\t\t\t && GET_MODE (patternr[4]) == HImode)\n-\t\t     || (RTX_IS (\"m+^Srs\")\n-\t\t\t && A0_OR_PSEUDO (patternr[4])\n-\t\t\t && GET_MODE (patternr[4]) == HImode)\n-\t\t     || (RTX_IS (\"m+^S+ris\")\n-\t\t\t && A0_OR_PSEUDO (patternr[5])\n-\t\t\t && GET_MODE (patternr[5]) == HImode)\n-\t\t     || RTX_IS (\"ms\")\n-\t\t     );\n-\t}\n-      return 0;\n-    }\n-\n-  if (memcmp (str, \"Sd\", 2) == 0)\n+  switch (constraint) {\n+  case CONSTRAINT_SF:\n+    return (far_addr_space_p (value)\n+\t    && ((RTX_IS (\"mr\")\n+\t\t && A0_OR_PSEUDO (patternr[1])\n+\t\t && GET_MODE (patternr[1]) == SImode)\n+\t\t|| (RTX_IS (\"m+^Sri\")\n+\t\t    && A0_OR_PSEUDO (patternr[4])\n+\t\t    && GET_MODE (patternr[4]) == HImode)\n+\t\t|| (RTX_IS (\"m+^Srs\")\n+\t\t    && A0_OR_PSEUDO (patternr[4])\n+\t\t    && GET_MODE (patternr[4]) == HImode)\n+\t\t|| (RTX_IS (\"m+^S+ris\")\n+\t\t    && A0_OR_PSEUDO (patternr[5])\n+\t\t    && GET_MODE (patternr[5]) == HImode)\n+\t\t|| RTX_IS (\"ms\")));\n+  case CONSTRAINT_Sd:    \n     {\n       /* This is the common \"src/dest\" address */\n       rtx r;\n       if (GET_CODE (value) == MEM && CONSTANT_P (XEXP (value, 0)))\n-\treturn 1;\n+\treturn true;\n       if (RTX_IS (\"ms\") || RTX_IS (\"m+si\"))\n-\treturn 1;\n+\treturn true;\n       if (RTX_IS (\"m++rii\"))\n \t{\n \t  if (REGNO (patternr[3]) == FB_REGNO\n \t      && INTVAL (patternr[4]) == 0)\n-\t    return 1;\n+\t    return true;\n \t}\n       if (RTX_IS (\"mr\"))\n \tr = patternr[1];\n       else if (RTX_IS (\"m+ri\") || RTX_IS (\"m+rs\") || RTX_IS (\"m+r+si\"))\n \tr = patternr[2];\n       else\n-\treturn 0;\n+\treturn false;\n       if (REGNO (r) == SP_REGNO)\n-\treturn 0;\n+\treturn false;\n       return m32c_legitimate_address_p (GET_MODE (value), XEXP (value, 0), 1);\n     }\n-  else if (memcmp (str, \"Sa\", 2) == 0)\n+  case CONSTRAINT_Sa:\n     {\n       rtx r;\n       if (RTX_IS (\"mr\"))\n \tr = patternr[1];\n       else if (RTX_IS (\"m+ri\"))\n \tr = patternr[2];\n       else\n-\treturn 0;\n+\treturn false;\n       return (IS_REG (r, A0_REGNO) || IS_REG (r, A1_REGNO));\n     }\n-  else if (memcmp (str, \"Si\", 2) == 0)\n-    {\n-      return (RTX_IS (\"mi\") || RTX_IS (\"ms\") || RTX_IS (\"m+si\"));\n-    }\n-  else if (memcmp (str, \"Ss\", 2) == 0)\n-    {\n-      return ((RTX_IS (\"mr\")\n-\t       && (IS_REG (patternr[1], SP_REGNO)))\n-\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SP_REGNO))));\n-    }\n-  else if (memcmp (str, \"Sf\", 2) == 0)\n-    {\n-      return ((RTX_IS (\"mr\")\n-\t       && (IS_REG (patternr[1], FB_REGNO)))\n-\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], FB_REGNO))));\n-    }\n-  else if (memcmp (str, \"Sb\", 2) == 0)\n-    {\n-      return ((RTX_IS (\"mr\")\n-\t       && (IS_REG (patternr[1], SB_REGNO)))\n-\t      || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SB_REGNO))));\n-    }\n-  else if (memcmp (str, \"Sp\", 2) == 0)\n-    {\n-      /* Absolute addresses 0..0x1fff used for bit addressing (I/O ports) */\n-      return (RTX_IS (\"mi\")\n-\t      && !(INTVAL (patternr[1]) & ~0x1fff));\n-    }\n-  else if (memcmp (str, \"S1\", 2) == 0)\n-    {\n-      return r1h_operand (value, QImode);\n-    }\n-  else if (memcmp (str, \"SF\", 2) == 0)\n-    {\n-      return 0;\n-    }\n-\n-  gcc_assert (str[0] != 'S');\n-\n-  if (memcmp (str, \"Rpa\", 2) == 0)\n+  case CONSTRAINT_Si:\n+    return (RTX_IS (\"mi\") || RTX_IS (\"ms\") || RTX_IS (\"m+si\"));\n+  case CONSTRAINT_Ss:\n+    return ((RTX_IS (\"mr\")\n+\t     && (IS_REG (patternr[1], SP_REGNO)))\n+\t    || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SP_REGNO))));\n+  case CONSTRAINT_Sf:\n+    return ((RTX_IS (\"mr\")\n+\t     && (IS_REG (patternr[1], FB_REGNO)))\n+\t    || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], FB_REGNO))));\n+  case CONSTRAINT_Sb:\n+    return ((RTX_IS (\"mr\")\n+\t     && (IS_REG (patternr[1], SB_REGNO)))\n+\t    || (RTX_IS (\"m+ri\") && (IS_REG (patternr[2], SB_REGNO))));\n+  case CONSTRAINT_Sp:\n+    /* Absolute addresses 0..0x1fff used for bit addressing (I/O ports) */\n+    return (RTX_IS (\"mi\")\n+\t    && !(INTVAL (patternr[1]) & ~0x1fff));\n+  case CONSTRAINT_S1:\n+    return r1h_operand (value, QImode);\n+  case CONSTRAINT_Rpa:\n     return GET_CODE (value) == PARALLEL;\n-\n-  return 0;\n-}\n-\n-/* This is for when we're debugging the above.  */\n-int\n-m32c_extra_constraint_p (rtx value, char c, const char *str)\n-{\n-  int rv = m32c_extra_constraint_p2 (value, c, str);\n-#if DEBUG0\n-  fprintf (stderr, \"\\nconstraint %.*s: %d\\n\", CONSTRAINT_LEN (c, str), str,\n-\t   rv);\n-  debug_rtx (value);\n-#endif\n-  return rv;\n-}\n-\n-/* Implements EXTRA_MEMORY_CONSTRAINT.  Currently, we only use strings\n-   starting with 'S'.  */\n-int\n-m32c_extra_memory_constraint (char c, const char *str ATTRIBUTE_UNUSED)\n-{\n-  return c == 'S';\n-}\n-\n-/* Implements EXTRA_ADDRESS_CONSTRAINT.  We reserve 'A' strings for these,\n-   but don't currently define any.  */\n-int\n-m32c_extra_address_constraint (char c, const char *str ATTRIBUTE_UNUSED)\n-{\n-  return c == 'A';\n+  default:\n+    return false;\n+  }\n }\n \n /* STACK AND CALLING */\n@@ -3667,7 +3449,7 @@ m32c_split_move (rtx * operands, enum machine_mode mode, int split_all)\n      point, so it's safe to set it to 3 even with define_insn.  */\n   /* None of the chips can move SI operands to sp-relative addresses,\n      so we always split those.  */\n-  if (m32c_extra_constraint_p (operands[0], 'S', \"Ss\"))\n+  if (satisfies_constraint_Ss (operands[0]))\n     split_all = 3;\n \n   if (TARGET_A16"}, {"sha": "1efbd36bbdd38d03a38caf71cc6043f50bd38b71", "filename": "gcc/config/m32c/m32c.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fm32c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fm32c.h?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -405,15 +405,6 @@ enum reg_class\n    A - addresses (currently unused)\n */\n \n-#define CONSTRAINT_LEN(CHAR,STR) \\\n-\t((CHAR) == 'I' ? 3 \\\n-\t : (CHAR) == 'R' ? 3 \\\n-\t : (CHAR) == 'S' ? 2 \\\n-\t : (CHAR) == 'A' ? 2 \\\n-\t : DEFAULT_CONSTRAINT_LEN(CHAR,STR))\n-#define REG_CLASS_FROM_CONSTRAINT(CHAR,STR) \\\n-\t(enum reg_class) m32c_reg_class_from_constraint (CHAR, STR)\n-\n #define REGNO_OK_FOR_BASE_P(NUM) m32c_regno_ok_for_base_p (NUM)\n #define REGNO_OK_FOR_INDEX_P(NUM) 0\n \n@@ -427,16 +418,6 @@ enum reg_class\n \n #define CANNOT_CHANGE_MODE_CLASS(F,T,C) m32c_cannot_change_mode_class(F,T,C)\n \n-#define CONST_OK_FOR_CONSTRAINT_P(VALUE,C,STR) \\\n-\tm32c_const_ok_for_constraint_p (VALUE, C, STR)\n-#define CONST_DOUBLE_OK_FOR_CONSTRAINT_P(VALUE,C,STR) 0\n-#define EXTRA_CONSTRAINT_STR(VALUE,C,STR) \\\n-\tm32c_extra_constraint_p (VALUE, C, STR)\n-#define EXTRA_MEMORY_CONSTRAINT(C,STR) \\\n-\tm32c_extra_memory_constraint (C, STR)\n-#define EXTRA_ADDRESS_CONSTRAINT(C,STR) \\\n-\tm32c_extra_address_constraint (C, STR)\n-\n /* STACK AND CALLING */\n \n /* Frame Layout */"}, {"sha": "9045cb5f1c8190004bcc74563d3865e8d3755505", "filename": "gcc/config/m32c/predicates.md", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Fpredicates.md?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -183,12 +183,12 @@\n ; TRUE for memory operands that are not indexed\n (define_predicate \"memsym_operand\"\n   (and (match_operand 0 \"memory_operand\" \"\")\n-       (match_test \"m32c_extra_constraint_p (op, 'S', \\\"Si\\\")\")))\n+       (match_test \"satisfies_constraint_Si (op)\")))\n \n ; TRUE for memory operands with small integer addresses\n (define_predicate \"memimmed_operand\"\n   (and (match_operand 0 \"memory_operand\" \"\")\n-       (match_test \"m32c_extra_constraint_p (op, 'S', \\\"Sp\\\")\")))\n+       (match_test \"satisfies_constraint_Sp (op)\")))\n \n ; TRUE for r1h.  This is complicated since r1h isn't a register GCC\n ; normally knows about.\n@@ -274,22 +274,22 @@\n ; TRUE for constants we can multiply pointers by\n (define_predicate \"m32c_psi_scale\"\n   (and (match_operand 0 \"const_int_operand\")\n-       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilb\\\")\")))\n+       (match_test \"satisfies_constraint_Ilb (op)\")))\n \n ; TRUE for one bit set (bit) or clear (mask) out of N bits.\n \n (define_predicate \"m32c_1bit8_operand\"\n   (and (match_operand 0 \"const_int_operand\")\n-       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilb\\\")\")))\n+       (match_test \"satisfies_constraint_Ilb (op)\")))\n \n (define_predicate \"m32c_1bit16_operand\"\n   (and (match_operand 0 \"const_int_operand\")\n-       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Ilw\\\")\")))\n+       (match_test \"satisfies_constraint_Ilw (op)\")))\n \n (define_predicate \"m32c_1mask8_operand\"\n   (and (match_operand 0 \"const_int_operand\")\n-       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"ImB\\\")\")))\n+       (match_test \"satisfies_constraint_ImB (op)\")))\n \n (define_predicate \"m32c_1mask16_operand\"\n   (and (match_operand 0 \"const_int_operand\")\n-       (match_test \"m32c_const_ok_for_constraint_p(INTVAL(op), 'I', \\\"Imw\\\")\")))\n+       (match_test \"satisfies_constraint_Imw (op)\")))"}, {"sha": "d5f1bf41b8e470a97c7841409d97db48585f9509", "filename": "gcc/config/m32c/t-m32c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Ft-m32c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2/gcc%2Fconfig%2Fm32c%2Ft-m32c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32c%2Ft-m32c?ref=03dd17b12e13b5c1cef36c4b52fa3acc7b7640f2", "patch": "@@ -23,7 +23,7 @@\n \n md_file = md\n \n-MD_FILES = m32c predicates addsub bitops blkmov cond jump minmax mov muldiv prologue shift\n+MD_FILES = m32c constraints predicates addsub bitops blkmov cond jump minmax mov muldiv prologue shift\n \n # Doing it this way lets the gen* programs report the right line numbers.\n "}]}