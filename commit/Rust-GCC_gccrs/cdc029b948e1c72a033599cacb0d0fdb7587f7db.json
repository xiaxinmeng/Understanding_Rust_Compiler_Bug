{"sha": "cdc029b948e1c72a033599cacb0d0fdb7587f7db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2RjMDI5Yjk0OGUxYzcyYTAzMzU5OWNhY2IwZDBmZGI3NTg3ZjdkYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-27T17:07:21Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-27T17:07:21Z"}, "message": "ipa-inline.c (cgraph_estimate_size_after_inlining): Make inline.\n\n\t* ipa-inline.c (cgraph_estimate_size_after_inlining): Make inline.\n\t(update_caller_keys): Return early if there are no callers;\n\tonly update fibheap when decresing the key.\n\t(update_callee_keys): Avoid recursion.\n\t(decide_inlining_of_small_functions): When badness does not match;\n\tre-insert into fibheap.\n\nFrom-SVN: r159931", "tree": {"sha": "d264701938fd6efbbd3dbd0a2bab5b56c4d8f1c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d264701938fd6efbbd3dbd0a2bab5b56c4d8f1c0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cdc029b948e1c72a033599cacb0d0fdb7587f7db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc029b948e1c72a033599cacb0d0fdb7587f7db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cdc029b948e1c72a033599cacb0d0fdb7587f7db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cdc029b948e1c72a033599cacb0d0fdb7587f7db/comments", "author": null, "committer": null, "parents": [{"sha": "8da24d7bc72a64c7e3f02110bb08c43ed90aed12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da24d7bc72a64c7e3f02110bb08c43ed90aed12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da24d7bc72a64c7e3f02110bb08c43ed90aed12"}], "stats": {"total": 86, "additions": 67, "deletions": 19}, "files": [{"sha": "61b043228310f6a9cc021d2793be1546b4c3969a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc029b948e1c72a033599cacb0d0fdb7587f7db/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc029b948e1c72a033599cacb0d0fdb7587f7db/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cdc029b948e1c72a033599cacb0d0fdb7587f7db", "patch": "@@ -1,3 +1,12 @@\n+2010-05-27  Jan Hubicka  <jh@suse.cz>\n+\n+\t* ipa-inline.c (cgraph_estimate_size_after_inlining): Make inline.\n+\t(update_caller_keys): Return early if there are no callers;\n+\tonly update fibheap when decresing the key.\n+\t(update_callee_keys): Avoid recursion.\n+\t(decide_inlining_of_small_functions): When badness does not match;\n+\tre-insert into fibheap.\n+\n 2010-05-27  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* Makefile.in (ALL_CFLAGS): Add file-specific CFLAGS."}, {"sha": "aaae6393e15d1e6e2ca8f6c725944ac4eed8aa21", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 58, "deletions": 19, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cdc029b948e1c72a033599cacb0d0fdb7587f7db/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cdc029b948e1c72a033599cacb0d0fdb7587f7db/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=cdc029b948e1c72a033599cacb0d0fdb7587f7db", "patch": "@@ -201,11 +201,12 @@ cgraph_estimate_time_after_inlining (int frequency, struct cgraph_node *to,\n \n /* Estimate self time of the function after inlining WHAT into TO.  */\n \n-static int\n+static inline int\n cgraph_estimate_size_after_inlining (int times, struct cgraph_node *to,\n \t\t\t\t     struct cgraph_node *what)\n {\n-  int size = (what->global.size - inline_summary (what)->size_inlining_benefit) * times + to->global.size;\n+  int size = ((what->global.size - inline_summary (what)->size_inlining_benefit)\n+\t      * times + to->global.size);\n   gcc_assert (size >= 0);\n   return size;\n }\n@@ -511,7 +512,7 @@ cgraph_default_inline_p (struct cgraph_node *n, cgraph_inline_failed_t *reason)\n    We call recursive inlining all cases where same function appears more than\n    once in the single recursion nest path in the inline graph.  */\n \n-static bool\n+static inline bool\n cgraph_recursive_inlining_p (struct cgraph_node *to,\n \t\t\t     struct cgraph_node *what,\n \t\t\t     cgraph_inline_failed_t *reason)\n@@ -679,10 +680,16 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \n   if (!node->local.inlinable)\n     return;\n+  /* See if there is something to do.  */\n+  for (edge = node->callers; edge; edge = edge->next_caller)\n+    if (edge->inline_failed)\n+      break;\n+  if (!edge)\n+    return;\n   /* Prune out edges we won't inline into anymore.  */\n   if (!cgraph_default_inline_p (node, &failed_reason))\n     {\n-      for (edge = node->callers; edge; edge = edge->next_caller)\n+      for (; edge; edge = edge->next_caller)\n \tif (edge->aux)\n \t  {\n \t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n@@ -693,7 +700,7 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n       return;\n     }\n \n-  for (edge = node->callers; edge; edge = edge->next_caller)\n+  for (; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       {\n \tint badness = cgraph_edge_badness (edge, false);\n@@ -704,33 +711,55 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n \t    if (n->key == badness)\n \t      continue;\n \n-\t    /* fibheap_replace_key only increase the keys.  */\n+\t    /* fibheap_replace_key only decrease the keys.\n+\t       When we increase the key we do not update heap\n+\t       and instead re-insert the element once it becomes\n+\t       a minium of heap.  */\n \t    if (badness < n->key)\n \t      {\n \t\tfibheap_replace_key (heap, n, badness);\n \t\tgcc_assert (n->key == badness);\n \t        continue;\n \t      }\n-\t    fibheap_delete_node (heap, (fibnode_t) edge->aux);\n \t  }\n-\tedge->aux = fibheap_insert (heap, badness, edge);\n+\telse\n+\t  edge->aux = fibheap_insert (heap, badness, edge);\n       }\n }\n \n-/* Recompute heap nodes for each of caller edges of each of callees.  */\n+/* Recompute heap nodes for each of caller edges of each of callees.\n+   Walk recursively into all inline clones.  */\n \n static void\n update_callee_keys (fibheap_t heap, struct cgraph_node *node,\n \t\t    bitmap updated_nodes)\n {\n-  struct cgraph_edge *e;\n+  struct cgraph_edge *e = node->callees;\n   node->global.estimated_growth = INT_MIN;\n \n-  for (e = node->callees; e; e = e->next_callee)\n-    if (e->inline_failed)\n-      update_caller_keys (heap, e->callee, updated_nodes);\n-    else if (!e->inline_failed)\n-      update_callee_keys (heap, e->callee, updated_nodes);\n+  if (!e)\n+    return;\n+  while (true)\n+    if (!e->inline_failed && e->callee->callees)\n+      e = e->callee->callees;\n+    else\n+      {\n+\tif (e->inline_failed)\n+\t  update_caller_keys (heap, e->callee, updated_nodes);\n+\tif (e->next_callee)\n+\t  e = e->next_callee;\n+\telse\n+\t  {\n+\t    do\n+\t      {\n+\t\tif (e->caller == node)\n+\t\t  return;\n+\t\te = e->caller->callers;\n+\t      }\n+\t    while (!e->next_callee);\n+\t    e = e->next_callee;\n+\t  }\n+      }\n }\n \n /* Enqueue all recursive calls from NODE into priority queue depending on\n@@ -1001,6 +1030,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       int old_size = overall_size;\n       struct cgraph_node *where, *callee;\n       int badness = fibheap_min_key (heap);\n+      int current_badness;\n       int growth;\n       cgraph_inline_failed_t not_good = CIF_OK;\n \n@@ -1009,9 +1039,18 @@ cgraph_decide_inlining_of_small_functions (void)\n       edge->aux = NULL;\n       if (!edge->inline_failed)\n \tcontinue;\n-#ifdef ENABLE_CHECKING\n-      gcc_assert (cgraph_edge_badness (edge, false) == badness);\n-#endif\n+\n+      /* When updating the edge costs, we only decrease badness in the keys.\n+\t When the badness increase, we keep the heap as it is and re-insert\n+\t key now.  */\n+      current_badness = cgraph_edge_badness (edge, false);\n+      gcc_assert (current_badness >= badness);\n+      if (current_badness != badness)\n+\t{\n+\t  edge->aux = fibheap_insert (heap, current_badness, edge);\n+\t  continue;\n+\t}\n+      \n       callee = edge->callee;\n \n       growth = (cgraph_estimate_size_after_inlining (1, edge->caller, edge->callee)\n@@ -1194,7 +1233,7 @@ cgraph_decide_inlining_of_small_functions (void)\n       if (!edge->inline_failed)\n \tcontinue;\n #ifdef ENABLE_CHECKING\n-      gcc_assert (cgraph_edge_badness (edge, false) == badness);\n+      gcc_assert (cgraph_edge_badness (edge, false) >= badness);\n #endif\n       if (dump_file)\n \t{"}]}