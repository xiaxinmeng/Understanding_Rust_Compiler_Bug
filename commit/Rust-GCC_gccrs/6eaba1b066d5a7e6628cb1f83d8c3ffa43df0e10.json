{"sha": "6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVhYmExYjA2NmQ1YTdlNjYyOGNiMWY4M2Q4YzNmZmE0M2RmMGUxMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-05-13T20:42:36Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-05-13T20:42:36Z"}, "message": "escape: Implement the discovery phase.\n\n    \n    Implements the discovery phase according the SCC algorithm used in\n    gc/esc.go.  Traverse all functions to find components that are either\n    trivial or recursive.  The discovered function groups will be analyzed\n    from the bottom-up to allow for an inter-procedural analysis.\n    \n    Reviewed-on: https://go-review.googlesource.com/18221\n\nFrom-SVN: r236224", "tree": {"sha": "9aec78d6e37218a1173e2a7bbba1e7c9d3554477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aec78d6e37218a1173e2a7bbba1e7c9d3554477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10/comments", "author": null, "committer": null, "parents": [{"sha": "54ece5e2954831a12f2ad6fe82c320add6dc870a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ece5e2954831a12f2ad6fe82c320add6dc870a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ece5e2954831a12f2ad6fe82c320add6dc870a"}], "stats": {"total": 187, "additions": 183, "deletions": 4}, "files": [{"sha": "8e0fd0fb63e46a546fc853a1fbf5bdf35d09930f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "patch": "@@ -1,4 +1,4 @@\n-7f5a9fde801eb755a5252fd4ff588b0a47475bd3\n+a87af72757d9a2e4479062a459a41d4540398005\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "01f3da7242162a8b1a8cf47157e0d91c9e4590b0", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 182, "deletions": 3, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=6eaba1b066d5a7e6628cb1f83d8c3ffa43df0e10", "patch": "@@ -304,14 +304,193 @@ Gogo::analyze_escape()\n     }\n }\n \n+// Traverse the program, discovering the functions that are roots of strongly\n+// connected components.  The goal of this phase to produce a set of functions\n+// that must be analyzed in order.\n+\n+class Escape_analysis_discover : public Traverse\n+{\n+ public:\n+  Escape_analysis_discover(Gogo* gogo)\n+    : Traverse(traverse_functions),\n+      gogo_(gogo), component_ids_()\n+  { }\n+\n+  int\n+  function(Named_object*);\n+\n+  int\n+  visit(Named_object*);\n+\n+  int\n+  visit_code(Named_object*, int);\n+\n+ private:\n+  // A counter used to generate the ID for the function node in the graph.\n+  static int id;\n+\n+  // Type used to map functions to an ID in a graph of connected components.\n+  typedef Unordered_map(Named_object*, int) Component_ids;\n+\n+  // The Go IR.\n+  Gogo* gogo_;\n+  // The list of functions encountered during connected component discovery.\n+  Component_ids component_ids_;\n+  // The stack of functions that this component consists of.\n+  std::stack<Named_object*> stack_;\n+};\n+\n+int Escape_analysis_discover::id = 0;\n+\n+// Visit each function.\n+\n+int\n+Escape_analysis_discover::function(Named_object* fn)\n+{\n+  this->visit(fn);\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Visit a function FN, adding it to the current stack of functions\n+// in this connected component.  If this is the root of the component,\n+// create a set of functions to be analyzed later.\n+//\n+// Finding these sets is finding strongly connected components\n+// in the static call graph.  The algorithm for doing that is taken\n+// from Sedgewick, Algorithms, Second Edition, p. 482, with two\n+// adaptations.\n+//\n+// First, a closure (fn->func_value()->enclosing() == NULL) cannot be the\n+// root of a connected component.  Refusing to use it as a root\n+// forces it into the component of the function in which it appears.\n+// This is more convenient for escape analysis.\n+//\n+// Second, each function becomes two virtual nodes in the graph,\n+// with numbers n and n+1. We record the function's node number as n\n+// but search from node n+1. If the search tells us that the component\n+// number (min) is n+1, we know that this is a trivial component: one function\n+// plus its closures. If the search tells us that the component number is\n+// n, then there was a path from node n+1 back to node n, meaning that\n+// the function set is mutually recursive. The escape analysis can be\n+// more precise when analyzing a single non-recursive function than\n+// when analyzing a set of mutually recursive functions.\n+\n+int\n+Escape_analysis_discover::visit(Named_object* fn)\n+{\n+  Component_ids::const_iterator p = this->component_ids_.find(fn);\n+  if (p != this->component_ids_.end())\n+    // Already visited.\n+    return p->second;\n+\n+  this->id++;\n+  int id = this->id;\n+  this->component_ids_[fn] = id;\n+  this->id++;\n+  int min = this->id;\n+\n+  this->stack_.push(fn);\n+  min = this->visit_code(fn, min);\n+  if ((min == id || min == id + 1)\n+      && fn->is_function()\n+      && fn->func_value()->enclosing() == NULL)\n+    {\n+      bool recursive = min == id;\n+      std::vector<Named_object*> group;\n+\n+      for (; !this->stack_.empty(); this->stack_.pop())\n+\t{\n+\t  Named_object* n = this->stack_.top();\n+\t  if (n == fn)\n+\t    {\n+\t      this->stack_.pop();\n+\t      break;\n+\t    }\n+\n+\t  group.push_back(n);\n+\t  this->component_ids_[n] = std::numeric_limits<int>::max();\n+\t}\n+      group.push_back(fn);\n+      this->component_ids_[fn] = std::numeric_limits<int>::max();\n+\n+      std::reverse(group.begin(), group.end());\n+      this->gogo_->add_analysis_set(group, recursive);\n+    }\n+\n+  return min;\n+}\n+\n+// Helper class for discovery step.  Traverse expressions looking for\n+// function calls and closures to visit during the discovery step.\n+\n+class Escape_discover_expr : public Traverse\n+{\n+ public:\n+  Escape_discover_expr(Escape_analysis_discover* ead, int min)\n+    : Traverse(traverse_expressions),\n+      ead_(ead), min_(min)\n+  { }\n+\n+  int\n+  min()\n+  { return this->min_; }\n+\n+  int\n+  expression(Expression** pexpr);\n+\n+ private:\n+  // The original discovery analysis.\n+  Escape_analysis_discover* ead_;\n+  // The minimum component ID in this group.\n+  int min_;\n+};\n+\n+// Visit any calls or closures found when discovering expressions.\n+\n+int\n+Escape_discover_expr::expression(Expression** pexpr)\n+{\n+  Expression* e = *pexpr;\n+  Named_object* fn = NULL;\n+  if (e->call_expression() != NULL\n+      && e->call_expression()->fn()->func_expression() != NULL)\n+    {\n+      // Method call or function call.\n+      fn = e->call_expression()->fn()->func_expression()->named_object();\n+    }\n+  else if (e->func_expression() != NULL\n+           && e->func_expression()->closure() != NULL)\n+    {\n+      // Closure.\n+      fn = e->func_expression()->named_object();\n+    }\n+\n+  if (fn != NULL)\n+    this->min_ = std::min(this->min_, this->ead_->visit(fn));\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Visit the body of each function, returns ID of the minimum connected\n+// component found in the body.\n+\n+int\n+Escape_analysis_discover::visit_code(Named_object* fn, int min)\n+{\n+  if (!fn->is_function())\n+    return min;\n+\n+  Escape_discover_expr ede(this, min);\n+  fn->func_value()->traverse(&ede);\n+  return ede.min();\n+}\n+\n // Discover strongly connected groups of functions to analyze.\n \n void\n Gogo::discover_analysis_sets()\n {\n-  // TODO(cmang): Implement Analysis_set discovery traversal.\n-  // Escape_analysis_discover(this);\n-  // this->traverse(&ead);\n+  Escape_analysis_discover ead(this);\n+  this->traverse(&ead);\n }\n \n // Build a connectivity graph between nodes in the function being analyzed."}]}