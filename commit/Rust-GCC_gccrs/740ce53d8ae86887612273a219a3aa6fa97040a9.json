{"sha": "740ce53d8ae86887612273a219a3aa6fa97040a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQwY2U1M2Q4YWU4Njg4NzYxMjI3M2EyMTlhM2FhNmZhOTcwNDBhOQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-01-17T22:02:28Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-01-17T22:02:28Z"}, "message": "basic-block.h: Document BB_* flags.\n\n        * basic-block.h: Document BB_* flags.\n        * regrename.c (copyprop_hardreg_forward): Don't use BB_VISITED,\n        use an sbitmap instead.\n        * sched-rgn.c (compute_trg_info): Likewise.\n\nFrom-SVN: r93779", "tree": {"sha": "9482053a02baa634992e1645e25ff362d2445b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9482053a02baa634992e1645e25ff362d2445b74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/740ce53d8ae86887612273a219a3aa6fa97040a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740ce53d8ae86887612273a219a3aa6fa97040a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/740ce53d8ae86887612273a219a3aa6fa97040a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/740ce53d8ae86887612273a219a3aa6fa97040a9/comments", "author": null, "committer": null, "parents": [{"sha": "2184a1201e63dbd4798c041370f7fcbb711813fb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2184a1201e63dbd4798c041370f7fcbb711813fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2184a1201e63dbd4798c041370f7fcbb711813fb"}], "stats": {"total": 77, "additions": 56, "deletions": 21}, "files": [{"sha": "94d0dee20ff7406a4d99865b11f56fb9b9caf8da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=740ce53d8ae86887612273a219a3aa6fa97040a9", "patch": "@@ -1,3 +1,10 @@\n+2005-01-17  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* basic-block.h: Document BB_* flags.\n+\t* regrename.c (copyprop_hardreg_forward): Don't use BB_VISITED,\n+\tuse an sbitmap instead.\n+\t* sched-rgn.c (compute_trg_info): Likewise.\n+\n 2005-01-17  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config.gcc (mips64*-*-linux*): Set the default abi to n32.  Remove"}, {"sha": "d377fb6362bc5b955388078c50052907f872bd33", "filename": "gcc/basic-block.h", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=740ce53d8ae86887612273a219a3aa6fa97040a9", "patch": "@@ -285,17 +285,47 @@ typedef struct reorder_block_def\n \n #define BB_FREQ_MAX 10000\n \n-/* Masks for basic_block.flags.  */\n+/* Masks for basic_block.flags.\n+\n+   BB_VISITED should not be used by passes, it is used internally by\n+   dfs_enumerate_from.\n+\n+   BB_HOT_PARTITION and BB_COLD_PARTITION should be preserved throughout\n+   the compilation, so they are never cleared.\n+\n+   All other flags may be cleared by clear_bb_flags().  It is generally\n+   a bad idea to rely on any flags being up-to-date.  */\n+\n+/* Set if insns in BB have are modified.  Used for updating liveness info.  */\n #define BB_DIRTY\t\t1\n+\n+/* Only set on blocks that have just been created by create_bb.  */\n #define BB_NEW\t\t\t2\n+\n+/* Set by find_unreachable_blocks.  Do not rely on this being set in any\n+   pass.  */\n #define BB_REACHABLE\t\t4\n+\n+/* Used by dfs_enumerate_from to keep track of visited basic blocks.  */\n #define BB_VISITED\t\t8\n+\n+/* Set for blocks in an irreducible loop by loop analysis.  */\n #define BB_IRREDUCIBLE_LOOP\t16\n+\n+/* Set on blocks that may actually not be single-entry single-exit block.  */\n #define BB_SUPERBLOCK\t\t32\n-#define BB_DISABLE_SCHEDULE     64\n \n+/* Set on basic blocks that the scheduler should not touch.  This is used\n+   by SMS to prevent other schedulers from messing with the loop schedule.  */\n+#define BB_DISABLE_SCHEDULE\t64\n+\n+/* Set on blocks that should be put in a hot section.  */\n #define BB_HOT_PARTITION\t128\n+\n+/* Set on blocks that should be put in a cold section.  */\n #define BB_COLD_PARTITION\t256\n+\n+/* Dummy flag for convenience in the hot/cold partitioning code.  */\n #define BB_UNPARTITIONED\t0\n \n /* Partitions, to be used when partitioning hot and cold basic blocks into"}, {"sha": "f2ab1f10338307dcb3495d2966e0fe48e19a974e", "filename": "gcc/regrename.c", "status": "modified", "additions": 7, "deletions": 14, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=740ce53d8ae86887612273a219a3aa6fa97040a9", "patch": "@@ -1746,29 +1746,26 @@ copyprop_hardreg_forward (void)\n   struct value_data *all_vd;\n   bool need_refresh;\n   basic_block bb;\n+  sbitmap visited;\n \n   need_refresh = false;\n \n   all_vd = xmalloc (sizeof (struct value_data) * last_basic_block);\n \n-  /* Clear all BB_VISITED flags.  We use BB_VISITED flags to indicate\n-     whether we have processed a given basic block or not.  Note that\n-     we never put BB_VISITED flag on ENTRY_BLOCK_PTR throughout this\n-     function because we want to call init_value_data for all\n-     successors of ENTRY_BLOCK_PTR.  */\n-  FOR_ALL_BB (bb)\n-    bb->flags &= ~BB_VISITED;\n+  visited = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n+  sbitmap_zero (visited);\n \n   FOR_EACH_BB (bb)\n     {\n-      bb->flags |= BB_VISITED;\n+      SET_BIT (visited, bb->index - (INVALID_BLOCK + 1));\n \n       /* If a block has a single predecessor, that we've already\n \t processed, begin with the value data that was live at\n \t the end of the predecessor block.  */\n       /* ??? Ought to use more intelligent queuing of blocks.  */\n       if (EDGE_COUNT (bb->preds) == 1\n-\t  && ((EDGE_PRED (bb, 0)->src->flags & BB_VISITED) != 0)\n+\t  && TEST_BIT (visited,\n+\t\t       EDGE_PRED (bb, 0)->src->index - (INVALID_BLOCK + 1))\n \t  && ! (EDGE_PRED (bb, 0)->flags & (EDGE_ABNORMAL_CALL | EDGE_EH)))\n \tall_vd[bb->index] = all_vd[EDGE_PRED (bb, 0)->src->index];\n       else\n@@ -1778,11 +1775,7 @@ copyprop_hardreg_forward (void)\n \tneed_refresh = true;\n     }\n \n-  /* Clear BB_VISITED flag on each basic block.  We do not need to\n-     clear the one on ENTRY_BLOCK_PTR because it's already cleared\n-     above.  */\n-  FOR_EACH_BB (bb)\n-    bb->flags &= ~BB_VISITED;\n+  sbitmap_free (visited);  \n \n   if (need_refresh)\n     {"}, {"sha": "3fae7904fc0e662542ab042d1cc293643f6a8bc8", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/740ce53d8ae86887612273a219a3aa6fa97040a9/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=740ce53d8ae86887612273a219a3aa6fa97040a9", "patch": "@@ -997,6 +997,7 @@ compute_trg_info (int trg)\n   edgelst el;\n   int i, j, k, update_idx;\n   basic_block block;\n+  sbitmap visited;\n   edge_iterator ei;\n   edge e;\n \n@@ -1006,6 +1007,8 @@ compute_trg_info (int trg)\n   sp->is_speculative = 0;\n   sp->src_prob = 100;\n \n+  visited = sbitmap_alloc (last_basic_block - (INVALID_BLOCK + 1));\n+\n   for (i = trg + 1; i < current_nr_blocks; i++)\n     {\n       sp = candidate_table + i;\n@@ -1043,12 +1046,14 @@ compute_trg_info (int trg)\n \t     overrunning the end of the bblst_table.  */\n \n \t  update_idx = 0;\n+\t  sbitmap_zero (visited);\n \t  for (j = 0; j < el.nr_members; j++)\n \t    {\n \t      block = el.first_member[j]->src;\n \t      FOR_EACH_EDGE (e, ei, block->succs)\n \t\t{\n-\t\t  if (!(e->dest->flags & BB_VISITED))\n+\t\t  if (!TEST_BIT (visited,\n+\t\t\t\t e->dest->index - (INVALID_BLOCK + 1)))\n \t\t    {\n \t\t      for (k = 0; k < el.nr_members; k++)\n \t\t\tif (e == el.first_member[k])\n@@ -1057,17 +1062,15 @@ compute_trg_info (int trg)\n \t\t      if (k >= el.nr_members)\n \t\t\t{\n \t\t\t  bblst_table[bblst_last++] = e->dest;\n-\t\t\t  e->dest->flags |= BB_VISITED;\n+\t\t\t  SET_BIT (visited,\n+\t\t\t\t   e->dest->index - (INVALID_BLOCK + 1));\n \t\t\t  update_idx++;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t  sp->update_bbs.nr_members = update_idx;\n \n-\t  FOR_ALL_BB (block)\n-\t    block->flags &= ~BB_VISITED;\n-\n \t  /* Make sure we didn't overrun the end of bblst_table.  */\n \t  gcc_assert (bblst_last <= bblst_size);\n \t}\n@@ -1079,6 +1082,8 @@ compute_trg_info (int trg)\n \t  sp->src_prob = 0;\n \t}\n     }\n+\n+  sbitmap_free (visited);\n }\n \n /* Print candidates info, for debugging purposes.  Callable from debugger.  */"}]}