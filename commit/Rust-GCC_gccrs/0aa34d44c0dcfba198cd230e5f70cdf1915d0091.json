{"sha": "0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFhMzRkNDRjMGRjZmJhMTk4Y2QyMzBlNWY3MGNkZjE5MTVkMDA5MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-06-01T19:49:57Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-06-01T19:49:57Z"}, "message": "i386.c (queued_cfa_restores): New static variable.\n\n\t* config/i386/i386.c (queued_cfa_restores): New static variable.\n\t(ix86_add_cfa_restore_note, ix86_add_queued_cfa_restore_notes): New\n\tfunctions.\n\t(pro_epilogue_adjust_stack): Call ix86_add_queued_cfa_restore_notes.\n\t(ix86_emit_restore_reg_using_pop): Add RED_OFFSET argument.\n\tSet RTX_FRAME_RELATED_P immediately after adding a REG_CFA_* note.\n\tCall ix86_add_cfa_restore_note instead of adding REG_CFA_OFFSET\n\tnote unconditionally.\n\t(ix86_emit_restore_regs_using_mov): Likewise.\n\t(ix86_emit_restore_sse_regs_using_mov): Likewise.\n\t(ix86_emit_restore_regs_using_pop): Add RED_OFFSET argument, pass\n\tit through to ix86_emit_restore_reg_using_pop.\n\t(ix86_emit_leave): Add RED_OFFSET argument.  Call\n\tix86_add_queued_cfa_restore_notes.  Call ix86_add_cfa_restore_note\n\tinstead of adding REG_CFA_OFFSET note unconditionally.\n\t(ix86_expand_epilogue): Compute RED_OFFSET, pass it down to\n\tthe above functions.  Call ix86_add_queued_cfa_restore_notes when\n\tneeded.\n\nFrom-SVN: r148067", "tree": {"sha": "188a0bf74c9d1ad419b666260514eb386570799f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/188a0bf74c9d1ad419b666260514eb386570799f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0aa34d44c0dcfba198cd230e5f70cdf1915d0091/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d342c045c5b3b2e3a47814d5bd5894513bda12f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d342c045c5b3b2e3a47814d5bd5894513bda12f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d342c045c5b3b2e3a47814d5bd5894513bda12f1"}], "stats": {"total": 168, "additions": 144, "deletions": 24}, "files": [{"sha": "2fc45e310ffe5db501b6c6048f2164e5ff08aa90", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa34d44c0dcfba198cd230e5f70cdf1915d0091/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa34d44c0dcfba198cd230e5f70cdf1915d0091/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "patch": "@@ -1,5 +1,38 @@\n 2009-06-01  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* config/i386/i386.c (queued_cfa_restores): New static variable.\n+\t(ix86_add_cfa_restore_note, ix86_add_queued_cfa_restore_notes): New\n+\tfunctions.\n+\t(pro_epilogue_adjust_stack): Call ix86_add_queued_cfa_restore_notes.\n+\t(ix86_emit_restore_reg_using_pop): Add RED_OFFSET argument.\n+\tSet RTX_FRAME_RELATED_P immediately after adding a REG_CFA_* note.\n+\tCall ix86_add_cfa_restore_note instead of adding REG_CFA_OFFSET\n+\tnote unconditionally.\n+\t(ix86_emit_restore_regs_using_mov): Likewise.\n+\t(ix86_emit_restore_sse_regs_using_mov): Likewise.\n+\t(ix86_emit_restore_regs_using_pop): Add RED_OFFSET argument, pass\n+\tit through to ix86_emit_restore_reg_using_pop.\n+\t(ix86_emit_leave): Add RED_OFFSET argument.  Call\n+\tix86_add_queued_cfa_restore_notes.  Call ix86_add_cfa_restore_note\n+\tinstead of adding REG_CFA_OFFSET note unconditionally.\n+\t(ix86_expand_epilogue): Compute RED_OFFSET, pass it down to\n+\tthe above functions.  Call ix86_add_queued_cfa_restore_notes when\n+\tneeded.\n+\n+\t* dwarf2out.c (dwarf2out_cfi_label): Add FORCE argument, if true,\n+\tforce output of the label even for dwarf2out_do_cfi_asm.\n+\t(add_fde_cfi): If -g2 and above and cfi might change CFA,\n+\tforce creation of CFI label and chain DW_CFA_set_loc jumping to it\n+\tfor convert_cfa_to_fb_loc_list.  Adjust other dwarf2out_cfi_label\n+\tcaller.\n+\t(dwarf2out_stack_adjust, dwarf2out_frame_debug,\n+\tdwarf2out_begin_epilogue, dwarf2out_frame_debug_restore_state): Adjust\n+\tdwarf2out_cfi_label callers.\n+\t* tree.h (dwarf2out_cfi_label): Adjust prototype.\n+\t* config/arm/arm.c (thumb_pushpop, thumb1_output_function_prologue):\n+\tAdjust dwarf2out_cfi_label callers.\n+\t* config/vax/vax.c (vax_output_function_prologue): Likewise.\n+\n \t* config/i386/i386.h (struct machine_cfa_state,\n \tstruct machine_function): Guard with ifndef USED_FOR_TARGET\n \tinstead of not IN_LIBGCC2 and not in IN_TARGET_LIBS."}, {"sha": "be9c7ad325ca78d2dc38acf817702f49e3498081", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 111, "deletions": 24, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0aa34d44c0dcfba198cd230e5f70cdf1915d0091/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0aa34d44c0dcfba198cd230e5f70cdf1915d0091/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=0aa34d44c0dcfba198cd230e5f70cdf1915d0091", "patch": "@@ -8000,6 +8000,49 @@ ix86_emit_save_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset)\n       }\n }\n \n+static GTY(()) rtx queued_cfa_restores;\n+\n+/* Add a REG_CFA_RESTORE REG note to INSN or queue them until next stack\n+   manipulation insn.  Don't add it if the previously\n+   saved value will be left untouched within stack red-zone till return,\n+   as unwinders can find the same value in the register and\n+   on the stack.  */\n+\n+static void\n+ix86_add_cfa_restore_note (rtx insn, rtx reg, HOST_WIDE_INT red_offset)\n+{\n+  if (TARGET_RED_ZONE\n+      && !TARGET_64BIT_MS_ABI\n+      && red_offset + RED_ZONE_SIZE >= 0\n+      && crtl->args.pops_args < 65536)\n+    return;\n+\n+  if (insn)\n+    {\n+      add_reg_note (insn, REG_CFA_RESTORE, reg);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+    }\n+  else\n+    queued_cfa_restores\n+      = alloc_reg_note (REG_CFA_RESTORE, reg, queued_cfa_restores);\n+}\n+\n+/* Add queued REG_CFA_RESTORE notes if any to INSN.  */\n+\n+static void\n+ix86_add_queued_cfa_restore_notes (rtx insn)\n+{\n+  rtx last;\n+  if (!queued_cfa_restores)\n+    return;\n+  for (last = queued_cfa_restores; XEXP (last, 1); last = XEXP (last, 1))\n+    ;\n+  XEXP (last, 1) = REG_NOTES (insn);\n+  REG_NOTES (insn) = queued_cfa_restores;\n+  queued_cfa_restores = NULL_RTX;\n+  RTX_FRAME_RELATED_P (insn) = 1;\n+}\n+\n /* Expand prologue or epilogue stack adjustment.\n    The pattern exist to put a dependency on all ebp-based memory accesses.\n    STYLE should be negative if instructions should be marked as frame related,\n@@ -8032,6 +8075,9 @@ pro_epilogue_adjust_stack (rtx dest, rtx src, rtx offset,\n \t\t\t\t\t\t\t       offset));\n     }\n \n+  if (style >= 0)\n+    ix86_add_queued_cfa_restore_notes (insn);\n+\n   if (set_cfa)\n     {\n       rtx r;\n@@ -8474,7 +8520,7 @@ ix86_expand_prologue (void)\n /* Emit code to restore REG using a POP insn.  */\n \n static void\n-ix86_emit_restore_reg_using_pop (rtx reg)\n+ix86_emit_restore_reg_using_pop (rtx reg, HOST_WIDE_INT red_offset)\n {\n   rtx insn = emit_insn (ix86_gen_pop1 (reg));\n \n@@ -8496,6 +8542,7 @@ ix86_emit_restore_reg_using_pop (rtx reg)\n       ix86_cfa_state->offset -= UNITS_PER_WORD;\n       add_reg_note (insn, REG_CFA_ADJUST_CFA,\n \t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 1)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n   /* When the frame pointer is the CFA, and we pop it, we are\n@@ -8512,44 +8559,51 @@ ix86_emit_restore_reg_using_pop (rtx reg)\n       add_reg_note (insn, REG_CFA_DEF_CFA,\n \t\t    gen_rtx_PLUS (Pmode, stack_pointer_rtx,\n \t\t\t\t  GEN_INT (UNITS_PER_WORD)));\n+      RTX_FRAME_RELATED_P (insn) = 1;\n     }\n \n-  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-  RTX_FRAME_RELATED_P (insn) = 1;\n+  ix86_add_cfa_restore_note (insn, reg, red_offset);\n }\n \n /* Emit code to restore saved registers using POP insns.  */\n \n static void\n-ix86_emit_restore_regs_using_pop (void)\n+ix86_emit_restore_regs_using_pop (HOST_WIDE_INT red_offset)\n {\n   int regno;\n \n   for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n     if (!SSE_REGNO_P (regno) && ix86_save_reg (regno, false))\n-      ix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno));\n+      {\n+\tix86_emit_restore_reg_using_pop (gen_rtx_REG (Pmode, regno),\n+\t\t\t\t\t red_offset);\n+\tred_offset += UNITS_PER_WORD;\n+      }\n }\n \n /* Emit code and notes for the LEAVE instruction.  */\n \n static void\n-ix86_emit_leave (void)\n+ix86_emit_leave (HOST_WIDE_INT red_offset)\n {\n   rtx insn = emit_insn (ix86_gen_leave ());\n \n+  ix86_add_queued_cfa_restore_notes (insn);\n+\n   if (ix86_cfa_state->reg == hard_frame_pointer_rtx)\n     {\n       add_reg_note (insn, REG_CFA_ADJUST_CFA, \n \t\t    copy_rtx (XVECEXP (PATTERN (insn), 0, 0)));\n-      add_reg_note (insn, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n       RTX_FRAME_RELATED_P (insn) = 1;\n+      ix86_add_cfa_restore_note (insn, hard_frame_pointer_rtx, red_offset);\n     }\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register\n    is restored from POINTER + OFFSET.  */\n static void\n ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n+\t\t\t\t  HOST_WIDE_INT red_offset,\n \t\t\t\t  int maybe_eh_return)\n {\n   unsigned int regno;\n@@ -8586,17 +8640,20 @@ ix86_emit_restore_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \t       the drap register.  This will remain until we restore\n \t       the stack pointer.  */\n \t    add_reg_note (insn, REG_CFA_DEF_CFA, reg);\n+\t    RTX_FRAME_RELATED_P (insn) = 1;\n \t  }\n \telse\n-\t  add_reg_note (insn, REG_CFA_RESTORE, reg);\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n+\t  ix86_add_cfa_restore_note (NULL_RTX, reg, red_offset);\n+\n+\tred_offset += UNITS_PER_WORD;\n       }\n }\n \n /* Emit code to restore saved registers using MOV insns.  First register\n    is restored from POINTER + OFFSET.  */\n static void\n ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n+\t\t\t\t      HOST_WIDE_INT red_offset,\n \t\t\t\t      int maybe_eh_return)\n {\n   int regno;\n@@ -8625,8 +8682,9 @@ ix86_emit_restore_sse_regs_using_mov (rtx pointer, HOST_WIDE_INT offset,\n \tinsn = emit_move_insn (reg, mem);\n \toffset += 16;\n \n-\tadd_reg_note (insn, REG_CFA_RESTORE, reg);\n-\tRTX_FRAME_RELATED_P (insn) = 1;\n+\tix86_add_cfa_restore_note (NULL_RTX, reg, red_offset);\n+\n+\tred_offset += 16;\n       }\n }\n \n@@ -8637,7 +8695,7 @@ ix86_expand_epilogue (int style)\n {\n   int sp_valid;\n   struct ix86_frame frame;\n-  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT offset, red_offset;\n   struct machine_cfa_state cfa_state_save = *ix86_cfa_state;\n   bool using_drap;\n \n@@ -8655,6 +8713,9 @@ ix86_expand_epilogue (int style)\n   if (frame_pointer_needed && frame.red_zone_size)\n     emit_insn (gen_memory_blockage ()); \n \n+  using_drap = crtl->drap_reg && crtl->stack_realign_needed;\n+  gcc_assert (!using_drap || ix86_cfa_state->reg == crtl->drap_reg);\n+\n   /* Calculate start of saved registers relative to ebp.  Special care\n      must be taken for the normal return case of a function using\n      eh_return: the eax and edx registers are marked as saved, but not\n@@ -8665,8 +8726,18 @@ ix86_expand_epilogue (int style)\n   offset *= -UNITS_PER_WORD;\n   offset -= frame.nsseregs * 16 + frame.padding0;\n \n-  using_drap = crtl->drap_reg && crtl->stack_realign_needed;\n-  gcc_assert (!using_drap || ix86_cfa_state->reg == crtl->drap_reg);\n+  /* Calculate start of saved registers relative to esp on entry of the\n+     function.  When realigning stack, this needs to be the most negative\n+     value possible at runtime.  */\n+  red_offset = offset;\n+  if (using_drap)\n+    red_offset -= crtl->stack_alignment_needed / BITS_PER_UNIT\n+\t\t  + UNITS_PER_WORD;\n+  else if (stack_realign_fp)\n+    red_offset -= crtl->stack_alignment_needed / BITS_PER_UNIT\n+\t\t  - UNITS_PER_WORD;\n+  if (frame_pointer_needed)\n+    red_offset -= UNITS_PER_WORD;\n \n   /* If we're only restoring one register and sp is not valid then\n      using a move instruction to restore the register since it's\n@@ -8703,22 +8774,32 @@ ix86_expand_epilogue (int style)\n \t  || stack_realign_fp)\n \t{\n \t  ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t        frame.to_allocate, style == 2);\n+\t\t\t\t\t\tframe.to_allocate, red_offset,\n+\t\t\t\t\t\tstyle == 2);\n \t  ix86_emit_restore_regs_using_mov (stack_pointer_rtx,\n \t\t\t\t\t    frame.to_allocate\n \t\t\t\t\t    + frame.nsseregs * 16\n+\t\t\t\t\t    + frame.padding0,\n+\t\t\t\t\t    red_offset\n+\t\t\t\t\t    + frame.nsseregs * 16\n \t\t\t\t\t    + frame.padding0, style == 2);\n \t}\n       else\n         {\n \t  ix86_emit_restore_sse_regs_using_mov (hard_frame_pointer_rtx,\n-\t\t\t\t\t        offset, style == 2);\n+\t\t\t\t\t\toffset, red_offset,\n+\t\t\t\t\t\tstyle == 2);\n \t  ix86_emit_restore_regs_using_mov (hard_frame_pointer_rtx,\n \t\t\t\t\t    offset\n \t\t\t\t\t    + frame.nsseregs * 16\n+\t\t\t\t\t    + frame.padding0,\n+\t\t\t\t\t    red_offset\n+\t\t\t\t\t    + frame.nsseregs * 16\n \t\t\t\t\t    + frame.padding0, style == 2);\n         }\n \n+      red_offset -= offset;\n+\n       /* eh_return epilogues need %ecx added to the stack pointer.  */\n       if (style == 2)\n \t{\n@@ -8746,6 +8827,7 @@ ix86_expand_epilogue (int style)\n \t\t the return insn.  */\n \t      add_reg_note (tmp, REG_CFA_DEF_CFA,\n \t\t\t    plus_constant (sa, UNITS_PER_WORD));\n+\t      ix86_add_queued_cfa_restore_notes (tmp);\n \t      add_reg_note (tmp, REG_CFA_RESTORE, hard_frame_pointer_rtx);\n \t      RTX_FRAME_RELATED_P (tmp) = 1;\n \t      ix86_cfa_state->reg = sa;\n@@ -8762,6 +8844,7 @@ ix86_expand_epilogue (int style)\n \t\t\t\t\t + frame.nsseregs * 16\n \t\t\t\t\t + frame.padding0));\n \t      tmp = emit_insn (gen_rtx_SET (VOIDmode, stack_pointer_rtx, tmp));\n+\t      ix86_add_queued_cfa_restore_notes (tmp);\n \n \t      gcc_assert (ix86_cfa_state->reg == stack_pointer_rtx);\n \t      if (ix86_cfa_state->offset != UNITS_PER_WORD)\n@@ -8784,14 +8867,14 @@ ix86_expand_epilogue (int style)\n       /* If not an i386, mov & pop is faster than \"leave\".  */\n       else if (TARGET_USE_LEAVE || optimize_function_for_size_p (cfun)\n \t       || !cfun->machine->use_fast_prologue_epilogue)\n-\tix86_emit_leave ();\n+\tix86_emit_leave (red_offset);\n       else\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t     hard_frame_pointer_rtx,\n \t\t\t\t     const0_rtx, style, !using_drap);\n \n-\t  ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n+\t  ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx, red_offset);\n \t}\n     }\n   else\n@@ -8811,15 +8894,16 @@ ix86_expand_epilogue (int style)\n \t\t\t\t     hard_frame_pointer_rtx,\n \t\t\t\t     GEN_INT (offset), style, false);\n           ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t        frame.to_allocate, style == 2);\n+\t\t\t\t\t\tframe.to_allocate, red_offset,\n+\t\t\t\t\t\tstyle == 2);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     GEN_INT (frame.nsseregs * 16),\n \t\t\t\t     style, false);\n \t}\n       else if (frame.to_allocate || frame.nsseregs)\n \t{\n           ix86_emit_restore_sse_regs_using_mov (stack_pointer_rtx,\n-\t\t\t\t\t        frame.to_allocate,\n+\t\t\t\t\t\tframe.to_allocate, red_offset,\n \t\t\t\t\t\tstyle == 2);\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t\t     GEN_INT (frame.to_allocate\n@@ -8828,14 +8912,16 @@ ix86_expand_epilogue (int style)\n \t\t\t\t     !using_drap && !frame_pointer_needed);\n \t}\n \n-      ix86_emit_restore_regs_using_pop ();\n+      ix86_emit_restore_regs_using_pop (red_offset + frame.nsseregs * 16\n+\t\t\t\t\t+ frame.padding0);\n+      red_offset -= offset;\n \n       if (frame_pointer_needed)\n \t{\n \t  /* Leave results in shorter dependency chains on CPUs that are\n \t     able to grok it fast.  */\n \t  if (TARGET_USE_LEAVE)\n-\t    ix86_emit_leave ();\n+\t    ix86_emit_leave (red_offset);\n \t  else\n             {\n               /* For stack realigned really happens, recover stack \n@@ -8845,7 +8931,8 @@ ix86_expand_epilogue (int style)\n \t\tpro_epilogue_adjust_stack (stack_pointer_rtx,\n \t\t\t\t\t   hard_frame_pointer_rtx,\n \t\t\t\t\t   const0_rtx, style, !using_drap);\n-\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx);\n+\t      ix86_emit_restore_reg_using_pop (hard_frame_pointer_rtx,\n+\t\t\t\t\t       red_offset);\n             }\n \t}\n     }\n@@ -8872,7 +8959,7 @@ ix86_expand_epilogue (int style)\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n       if (param_ptr_offset)\n-\tix86_emit_restore_reg_using_pop (crtl->drap_reg);\n+\tix86_emit_restore_reg_using_pop (crtl->drap_reg, -UNITS_PER_WORD);\n     }\n \n   /* Sibcall epilogues don't want a return instruction.  */"}]}