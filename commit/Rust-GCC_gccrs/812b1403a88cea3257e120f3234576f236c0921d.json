{"sha": "812b1403a88cea3257e120f3234576f236c0921d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODEyYjE0MDNhODhjZWEzMjU3ZTEyMGYzMjM0NTc2ZjIzNmMwOTIxZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2016-09-21T20:55:06Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2016-09-21T20:55:06Z"}, "message": "Introduce class rtx_reader\n\nBundle up various global variables within gensupport.c into a\nclass rtx_reader, with a view towards making it easier to run the\ncode more than once in-process.\n\ngcc/ChangeLog:\n\t* genconstants.c (main): Introduce noop_reader and convert call\n\tto read_md_files to a method call.\n\t* genenums.c (main): Likewise.\n\t* genmddeps.c (main): Likewise.\n\t* genpreds.c (write_tm_constrs_h): Replace use of \"in_fname\" with\n\trtx_reader_ptr->get_top_level_filename ().\n\t(write_tm_preds_h): Likewise.\n\t(write_insn_preds_c): Likewise.\n\t* gensupport.c (class gen_reader): New subclass of rtx_reader.\n\t(rtx_handle_directive): Convert to...\n\t(gen_reader::handle_unknown_directive): ...this.\n\t(init_rtx_reader_args_cb): Convert return type from bool to\n\trtx_reader *.  Create a gen_reader instance, using it for the\n\tcall to read_md_files.  Return it if no errors occur.\n\t(init_rtx_reader_args): Convert return type from bool to\n\trtx_reader *.\n\t* gensupport.h (init_rtx_reader_args_cb): Likewise.\n\t(init_rtx_reader_args_cb): Likewise.\n\t* read-md.c (struct file_name_list): Move to class rtx_reader.\n\t(read_md_file): Delete in favor of rtx_reader::m_read_md_file.\n\t(read_md_filename): Delete in favor of\n\trtx_reader::m_read_md_filename.\n\t(read_md_lineno): Delete in favor of rtx_reader::m_read_md_lineno.\n\t(in_fname): Delete in favor of rtx_reader::m_toplevel_fname.\n\t(base_dir): Delete in favor of rtx_reader::m_base_dir.\n\t(first_dir_md_include): Delete in favor of\n\trtx_reader::m_first_dir_md_include.\n\t(last_dir_md_include_ptr): Delete in favor of\n\trtx_reader::m_last_dir_md_include_ptr.\n\t(max_include_len): Delete.\n\t(rtx_reader_ptr): New.\n\t(fatal_with_file_and_line): Use get_filename and get_lineno\n\taccessors of rtx_reader_ptr.\n\t(require_char_ws): Likewise.\n\t(rtx_reader::read_char): New method, based on ::read_char.\n\t(rtx_reader::unread_char): New method, based on ::unread_char.\n\t(read_escape): Use get_filename and get_lineno accessors of\n\trtx_reader_ptr.\n\t(read_braced_string): Use get_lineno accessor of rtx_reader_ptr.\n\t(read_string): Use get_filename and get_lineno accessors of\n\trtx_reader_ptr.\n\t(rtx_reader::rtx_reader): New ctor.\n\t(rtx_reader::~rtx_reader): New dtor.\n\t(handle_include): Convert from a function to...\n\t(rtx_reader::handle_include): ...this method, converting\n\thandle_directive from a callback to a virtual function.\n\t(handle_file): Likewise, converting to...\n\t(rtx_reader::handle_file): ...this method.\n\t(handle_toplevel_file): Likewise, converting to...\n\t(rtx_reader::handle_toplevel_file): ...this method.\n\t(rtx_reader::get_current_location): New method.\n\t(parse_include): Convert from a function to...\n\t(rtx_reader::add_include_path): ...this method, dropping redundant\n\tupdate to unused max_include_len.\n\t(read_md_files): Convert from a function to...\n\t(rtx_reader::read_md_files): ...this method, converting\n\thandle_directive from a callback to a virtual function.\n\t(noop_reader::handle_unknown_directive): New method.\n\t* read-md.h (directive_handler_t): Delete this typedef.\n\t(in_fname): Delete.\n\t(read_md_file): Delete.\n\t(read_md_lineno): Delete.\n\t(read_md_filename): Delete.\n\t(class rtx_reader): New class.\n\t(rtx_reader_ptr): New decl.\n\t(class noop_reader): New subclass of rtx_reader.\n\t(read_char): Reimplement in terms of rtx_reader::read_char.\n\t(unread_char): Reimplement in terms of rtx_reader::unread_char.\n\t(read_md_files): Delete.\n\t* read-rtl.c (read_rtx_code): Update for deletion of globals\n\tread_md_filename and read_md_lineno.\n\nFrom-SVN: r240333", "tree": {"sha": "2e57869b3abfc8194d9331d7999474e37d891fa7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e57869b3abfc8194d9331d7999474e37d891fa7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/812b1403a88cea3257e120f3234576f236c0921d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812b1403a88cea3257e120f3234576f236c0921d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812b1403a88cea3257e120f3234576f236c0921d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812b1403a88cea3257e120f3234576f236c0921d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0d7154371d710268285a0a474286da4f5eb7c936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d7154371d710268285a0a474286da4f5eb7c936", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d7154371d710268285a0a474286da4f5eb7c936"}], "stats": {"total": 455, "additions": 318, "deletions": 137}, "files": [{"sha": "cd4052595ae9bf17550dd42c5dd7c1b9bb221a17", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,3 +1,77 @@\n+2016-09-21  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* genconstants.c (main): Introduce noop_reader and convert call\n+\tto read_md_files to a method call.\n+\t* genenums.c (main): Likewise.\n+\t* genmddeps.c (main): Likewise.\n+\t* genpreds.c (write_tm_constrs_h): Replace use of \"in_fname\" with\n+\trtx_reader_ptr->get_top_level_filename ().\n+\t(write_tm_preds_h): Likewise.\n+\t(write_insn_preds_c): Likewise.\n+\t* gensupport.c (class gen_reader): New subclass of rtx_reader.\n+\t(rtx_handle_directive): Convert to...\n+\t(gen_reader::handle_unknown_directive): ...this.\n+\t(init_rtx_reader_args_cb): Convert return type from bool to\n+\trtx_reader *.  Create a gen_reader instance, using it for the\n+\tcall to read_md_files.  Return it if no errors occur.\n+\t(init_rtx_reader_args): Convert return type from bool to\n+\trtx_reader *.\n+\t* gensupport.h (init_rtx_reader_args_cb): Likewise.\n+\t(init_rtx_reader_args_cb): Likewise.\n+\t* read-md.c (struct file_name_list): Move to class rtx_reader.\n+\t(read_md_file): Delete in favor of rtx_reader::m_read_md_file.\n+\t(read_md_filename): Delete in favor of\n+\trtx_reader::m_read_md_filename.\n+\t(read_md_lineno): Delete in favor of rtx_reader::m_read_md_lineno.\n+\t(in_fname): Delete in favor of rtx_reader::m_toplevel_fname.\n+\t(base_dir): Delete in favor of rtx_reader::m_base_dir.\n+\t(first_dir_md_include): Delete in favor of\n+\trtx_reader::m_first_dir_md_include.\n+\t(last_dir_md_include_ptr): Delete in favor of\n+\trtx_reader::m_last_dir_md_include_ptr.\n+\t(max_include_len): Delete.\n+\t(rtx_reader_ptr): New.\n+\t(fatal_with_file_and_line): Use get_filename and get_lineno\n+\taccessors of rtx_reader_ptr.\n+\t(require_char_ws): Likewise.\n+\t(rtx_reader::read_char): New method, based on ::read_char.\n+\t(rtx_reader::unread_char): New method, based on ::unread_char.\n+\t(read_escape): Use get_filename and get_lineno accessors of\n+\trtx_reader_ptr.\n+\t(read_braced_string): Use get_lineno accessor of rtx_reader_ptr.\n+\t(read_string): Use get_filename and get_lineno accessors of\n+\trtx_reader_ptr.\n+\t(rtx_reader::rtx_reader): New ctor.\n+\t(rtx_reader::~rtx_reader): New dtor.\n+\t(handle_include): Convert from a function to...\n+\t(rtx_reader::handle_include): ...this method, converting\n+\thandle_directive from a callback to a virtual function.\n+\t(handle_file): Likewise, converting to...\n+\t(rtx_reader::handle_file): ...this method.\n+\t(handle_toplevel_file): Likewise, converting to...\n+\t(rtx_reader::handle_toplevel_file): ...this method.\n+\t(rtx_reader::get_current_location): New method.\n+\t(parse_include): Convert from a function to...\n+\t(rtx_reader::add_include_path): ...this method, dropping redundant\n+\tupdate to unused max_include_len.\n+\t(read_md_files): Convert from a function to...\n+\t(rtx_reader::read_md_files): ...this method, converting\n+\thandle_directive from a callback to a virtual function.\n+\t(noop_reader::handle_unknown_directive): New method.\n+\t* read-md.h (directive_handler_t): Delete this typedef.\n+\t(in_fname): Delete.\n+\t(read_md_file): Delete.\n+\t(read_md_lineno): Delete.\n+\t(read_md_filename): Delete.\n+\t(class rtx_reader): New class.\n+\t(rtx_reader_ptr): New decl.\n+\t(class noop_reader): New subclass of rtx_reader.\n+\t(read_char): Reimplement in terms of rtx_reader::read_char.\n+\t(unread_char): Reimplement in terms of rtx_reader::unread_char.\n+\t(read_md_files): Delete.\n+\t* read-rtl.c (read_rtx_code): Update for deletion of globals\n+\tread_md_filename and read_md_lineno.\n+\n 2016-09-21  Jason Merrill  <jason@redhat.com>\n \n \t* input.h (from_macro_definition_at): New."}, {"sha": "e8be5b6d6736253773d4ff49239e3078f494afa1", "filename": "gcc/genconstants.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenconstants.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -79,7 +79,8 @@ main (int argc, const char **argv)\n {\n   progname = \"genconstants\";\n \n-  if (!read_md_files (argc, argv, NULL, NULL))\n+  noop_reader reader;\n+  if (!reader.read_md_files (argc, argv, NULL))\n     return (FATAL_EXIT_CODE);\n \n   /* Initializing the MD reader has the side effect of loading up"}, {"sha": "8af8d9a41d4ab4d7c9fc5b50bd85dbd863c5a37a", "filename": "gcc/genenums.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenenums.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenenums.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenenums.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -49,7 +49,8 @@ main (int argc, const char **argv)\n {\n   progname = \"genenums\";\n \n-  if (!read_md_files (argc, argv, NULL, NULL))\n+  noop_reader reader;\n+  if (!reader.read_md_files (argc, argv, NULL))\n     return (FATAL_EXIT_CODE);\n \n   puts (\"/* Generated automatically by the program `genenums'\");"}, {"sha": "e3d229d496d753395ec7abf8fe5897e3e9fd8109", "filename": "gcc/genmddeps.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenmddeps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenmddeps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmddeps.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -47,7 +47,8 @@ main (int argc, const char **argv)\n   progname = \"genmddeps\";\n   include_callback = add_filedep;\n \n-  if (!read_md_files (argc, argv, NULL, NULL))\n+  noop_reader reader;\n+  if (!reader.read_md_files (argc, argv, NULL))\n     return FATAL_EXIT_CODE;\n \n   *last = NULL;"}, {"sha": "96f75bd49f26a7e9cf6d6417655b5cc1064271cc", "filename": "gcc/genpreds.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1204,7 +1204,8 @@ write_tm_constrs_h (void)\n \n   printf (\"\\\n /* Generated automatically by the program '%s'\\n\\\n-   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+   from the machine description file '%s'.  */\\n\\n\", progname,\n+\t  rtx_reader_ptr->get_top_level_filename ());\n \n   puts (\"\\\n #ifndef GCC_TM_CONSTRS_H\\n\\\n@@ -1403,7 +1404,8 @@ write_tm_preds_h (void)\n \n   printf (\"\\\n /* Generated automatically by the program '%s'\\n\\\n-   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+   from the machine description file '%s'.  */\\n\\n\", progname,\n+\t  rtx_reader_ptr->get_top_level_filename ());\n \n   puts (\"\\\n #ifndef GCC_TM_PREDS_H\\n\\\n@@ -1552,7 +1554,8 @@ write_insn_preds_c (void)\n \n   printf (\"\\\n /* Generated automatically by the program '%s'\\n\\\n-   from the machine description file '%s'.  */\\n\\n\", progname, in_fname);\n+   from the machine description file '%s'.  */\\n\\n\", progname,\n+\t  rtx_reader_ptr->get_top_level_filename ());\n \n   puts (\"\\\n #include \\\"config.h\\\"\\n\\"}, {"sha": "1648c9cc6493680b8dc95739bb6fdb099aecf7e0", "filename": "gcc/gensupport.c", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgensupport.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgensupport.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -2225,10 +2225,18 @@ process_define_subst (void)\n     }\n }\n \f\n-/* A read_md_files callback for reading an rtx.  */\n+/* A subclass of rtx_reader which reads .md files and calls process_rtx on\n+   the top-level elements.  */\n \n-static void\n-rtx_handle_directive (file_location loc, const char *rtx_name)\n+class gen_reader : public rtx_reader\n+{\n+ public:\n+  gen_reader () : rtx_reader () {}\n+  void handle_unknown_directive (file_location, const char *);\n+};\n+\n+void\n+gen_reader::handle_unknown_directive (file_location loc, const char *rtx_name)\n {\n   auto_vec<rtx, 32> subrtxs;\n   if (!read_rtx (rtx_name, &subrtxs))\n@@ -2499,7 +2507,7 @@ check_define_attr_duplicates ()\n \n /* The entry point for initializing the reader.  */\n \n-bool\n+rtx_reader *\n init_rtx_reader_args_cb (int argc, const char **argv,\n \t\t\t bool (*parse_opt) (const char *))\n {\n@@ -2515,7 +2523,8 @@ init_rtx_reader_args_cb (int argc, const char **argv,\n   split_sequence_num = 1;\n   peephole2_sequence_num = 1;\n \n-  read_md_files (argc, argv, parse_opt, rtx_handle_directive);\n+  gen_reader *reader = new gen_reader ();\n+  reader->read_md_files (argc, argv, parse_opt);\n \n   if (define_attr_queue != NULL)\n     check_define_attr_duplicates ();\n@@ -2531,12 +2540,18 @@ init_rtx_reader_args_cb (int argc, const char **argv,\n   if (define_attr_queue != NULL)\n     gen_mnemonic_attr ();\n \n-  return !have_error;\n+  if (have_error)\n+    {\n+      delete reader;\n+      return NULL;\n+    }\n+\n+  return reader;\n }\n \n /* Programs that don't have their own options can use this entry point\n    instead.  */\n-bool\n+rtx_reader *\n init_rtx_reader_args (int argc, const char **argv)\n {\n   return init_rtx_reader_args_cb (argc, argv, 0);"}, {"sha": "618359dac942a8fd80e1de89136460345586c6c9", "filename": "gcc/gensupport.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgensupport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fgensupport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgensupport.h?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -125,9 +125,9 @@ struct optab_pattern\n };\n \n extern rtx add_implicit_parallel (rtvec);\n-extern bool init_rtx_reader_args_cb (int, const char **,\n-\t\t\t\t     bool (*)(const char *));\n-extern bool init_rtx_reader_args (int, const char **);\n+extern rtx_reader *init_rtx_reader_args_cb (int, const char **,\n+\t\t\t\t\t    bool (*)(const char *));\n+extern rtx_reader *init_rtx_reader_args (int, const char **);\n extern bool read_md_rtx (md_rtx_info *);\n extern unsigned int get_num_insn_codes ();\n "}, {"sha": "f069ba5a88d4a07419be7c45939f19d192bf19e6", "filename": "gcc/read-md.c", "status": "modified", "additions": 128, "deletions": 99, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-md.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-md.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -31,12 +31,6 @@ struct ptr_loc {\n   int lineno;\n };\n \n-/* A singly-linked list of filenames.  */\n-struct file_name_list {\n-  struct file_name_list *next;\n-  const char *fname;\n-};\n-\n /* Obstack used for allocating MD strings.  */\n struct obstack string_obstack;\n \n@@ -56,34 +50,13 @@ static htab_t joined_conditions;\n /* An obstack for allocating joined_conditions entries.  */\n static struct obstack joined_conditions_obstack;\n \n-/* The file we are reading.  */\n-FILE *read_md_file;\n-\n-/* The filename of READ_MD_FILE.  */\n-const char *read_md_filename;\n-\n-/* The current line number in READ_MD_FILE.  */\n-int read_md_lineno;\n-\n-/* The name of the toplevel file that indirectly included READ_MD_FILE.  */\n-const char *in_fname;\n-\n-/* The directory part of IN_FNAME.  NULL if IN_FNAME is a bare filename.  */\n-static char *base_dir;\n-\n-/* The first directory to search.  */\n-static struct file_name_list *first_dir_md_include;\n-\n-/* A pointer to the null terminator of the md include chain.  */\n-static struct file_name_list **last_dir_md_include_ptr = &first_dir_md_include;\n-\n /* This callback will be invoked whenever an md include directive is\n    processed.  To be used for creation of the dependency file.  */\n void (*include_callback) (const char *);\n \n-/* The current maximum length of directory names in the search path\n-   for include files.  (Altered as we get more of them.)  */\n-static size_t max_include_len;\n+/* Global singleton.  */\n+\n+rtx_reader *rtx_reader_ptr;\n \n /* A table of md_constant structures, hashed by name.  Null if no\n    constant expansion should occur.  */\n@@ -92,8 +65,6 @@ static htab_t md_constants;\n /* A table of enum_type structures, hashed by name.  */\n static htab_t enum_types;\n \n-static void handle_file (directive_handler_t);\n-\n /* Given an object that starts with a char * name field, return a hash\n    code for its name.  */\n \n@@ -303,7 +274,8 @@ fatal_with_file_and_line (const char *msg, ...)\n \n   va_start (ap, msg);\n \n-  fprintf (stderr, \"%s:%d: \", read_md_filename, read_md_lineno);\n+  fprintf (stderr, \"%s:%d: error: \", rtx_reader_ptr->get_filename (),\n+\t   rtx_reader_ptr->get_lineno ());\n   vfprintf (stderr, msg, ap);\n   putc ('\\n', stderr);\n \n@@ -322,8 +294,9 @@ fatal_with_file_and_line (const char *msg, ...)\n     }\n   context[i] = '\\0';\n \n-  fprintf (stderr, \"%s:%d: following context is `%s'\\n\",\n-\t   read_md_filename, read_md_lineno, context);\n+  fprintf (stderr, \"%s:%d: note: following context is `%s'\\n\",\n+\t   rtx_reader_ptr->get_filename (), rtx_reader_ptr->get_lineno (),\n+\t   context);\n \n   va_end (ap);\n   exit (1);\n@@ -402,6 +375,30 @@ require_char_ws (char expected)\n     fatal_expected_char (expected, ch);\n }\n \n+/* Read the next character from the file.  */\n+\n+int\n+rtx_reader::read_char (void)\n+{\n+  int ch;\n+\n+  ch = getc (m_read_md_file);\n+  if (ch == '\\n')\n+    m_read_md_lineno++;\n+\n+  return ch;\n+}\n+\n+/* Put back CH, which was the last character read from the file.  */\n+\n+void\n+rtx_reader::unread_char (int ch)\n+{\n+  if (ch == '\\n')\n+    m_read_md_lineno--;\n+  ungetc (ch, m_read_md_file);\n+}\n+\n /* Read an rtx code name into NAME.  It is terminated by any of the\n    punctuation chars of rtx printed syntax.  */\n \n@@ -512,7 +509,8 @@ read_escape (void)\n       /* pass anything else through, but issue a warning.  */\n     default:\n       fprintf (stderr, \"%s:%d: warning: unrecognized escape \\\\%c\\n\",\n-\t       read_md_filename, read_md_lineno, c);\n+\t       rtx_reader_ptr->get_filename (), rtx_reader_ptr->get_lineno (),\n+\t       c);\n       obstack_1grow (&string_obstack, '\\\\');\n       break;\n     }\n@@ -555,7 +553,7 @@ read_braced_string (void)\n {\n   int c;\n   int brace_depth = 1;  /* caller-processed */\n-  unsigned long starting_read_md_lineno = read_md_lineno;\n+  unsigned long starting_read_md_lineno = rtx_reader_ptr->get_lineno ();\n \n   obstack_1grow (&string_obstack, '{');\n   while (brace_depth)\n@@ -601,7 +599,7 @@ read_string (int star_if_braced)\n       c = read_skip_spaces ();\n     }\n \n-  old_lineno = read_md_lineno;\n+  old_lineno = rtx_reader_ptr->get_lineno ();\n   if (c == '\"')\n     stringbuf = read_quoted_string ();\n   else if (c == '{')\n@@ -616,7 +614,7 @@ read_string (int star_if_braced)\n   if (saw_paren)\n     require_char_ws (')');\n \n-  set_md_ptr_loc (stringbuf, read_md_filename, old_lineno);\n+  set_md_ptr_loc (stringbuf, rtx_reader_ptr->get_filename (), old_lineno);\n   return stringbuf;\n }\n \n@@ -901,13 +899,37 @@ traverse_enum_types (htab_trav callback, void *info)\n   htab_traverse (enum_types, callback, info);\n }\n \n+\n+/* Constructor for rtx_reader.  */\n+\n+rtx_reader::rtx_reader ()\n+: m_toplevel_fname (NULL),\n+  m_base_dir (NULL),\n+  m_read_md_file (NULL),\n+  m_read_md_filename (NULL),\n+  m_read_md_lineno (0),\n+  m_first_dir_md_include (NULL),\n+  m_last_dir_md_include_ptr (&m_first_dir_md_include)\n+{\n+  /* Set the global singleton pointer.  */\n+  rtx_reader_ptr = this;\n+}\n+\n+/* rtx_reader's destructor.  */\n+\n+rtx_reader::~rtx_reader ()\n+{\n+  /* Clear the global singleton pointer.  */\n+  rtx_reader_ptr = NULL;\n+}\n+\n /* Process an \"include\" directive, starting with the optional space\n    after the \"include\".  Read in the file and use HANDLE_DIRECTIVE\n    to process each unknown directive.  LINENO is the line number on\n    which the \"include\" occurred.  */\n \n-static void\n-handle_include (file_location loc, directive_handler_t handle_directive)\n+void\n+rtx_reader::handle_include (file_location loc)\n {\n   const char *filename;\n   const char *old_filename;\n@@ -924,7 +946,7 @@ handle_include (file_location loc, directive_handler_t handle_directive)\n       struct file_name_list *stackp;\n \n       /* Search the directory path, trying to open the file.  */\n-      for (stackp = first_dir_md_include; stackp; stackp = stackp->next)\n+      for (stackp = m_first_dir_md_include; stackp; stackp = stackp->next)\n \t{\n \t  static const char sep[2] = { DIR_SEPARATOR, '\\0' };\n \n@@ -940,8 +962,8 @@ handle_include (file_location loc, directive_handler_t handle_directive)\n      filename with BASE_DIR.  */\n   if (input_file == NULL)\n     {\n-      if (base_dir)\n-\tpathname = concat (base_dir, filename, NULL);\n+      if (m_base_dir)\n+\tpathname = concat (m_base_dir, filename, NULL);\n       else\n \tpathname = xstrdup (filename);\n       input_file = fopen (pathname, \"r\");\n@@ -957,21 +979,22 @@ handle_include (file_location loc, directive_handler_t handle_directive)\n   /* Save the old cursor.  Note that the LINENO argument to this\n      function is the beginning of the include statement, while\n      read_md_lineno has already been advanced.  */\n-  old_file = read_md_file;\n-  old_filename = read_md_filename;\n-  old_lineno = read_md_lineno;\n+  old_file = m_read_md_file;\n+  old_filename = m_read_md_filename;\n+  old_lineno = m_read_md_lineno;\n \n   if (include_callback)\n     include_callback (pathname);\n \n-  read_md_file = input_file;\n-  read_md_filename = pathname;\n-  handle_file (handle_directive);\n+  m_read_md_file = input_file;\n+  m_read_md_filename = pathname;\n+\n+  handle_file ();\n \n   /* Restore the old cursor.  */\n-  read_md_file = old_file;\n-  read_md_filename = old_filename;\n-  read_md_lineno = old_lineno;\n+  m_read_md_file = old_file;\n+  m_read_md_filename = old_filename;\n+  m_read_md_lineno = old_lineno;\n \n   /* Do not free the pathname.  It is attached to the various rtx\n      queue elements.  */\n@@ -981,16 +1004,16 @@ handle_include (file_location loc, directive_handler_t handle_directive)\n    read_md_filename are valid.  Use HANDLE_DIRECTIVE to handle\n    unknown directives.  */\n \n-static void\n-handle_file (directive_handler_t handle_directive)\n+void\n+rtx_reader::handle_file ()\n {\n   struct md_name directive;\n   int c;\n \n-  read_md_lineno = 1;\n+  m_read_md_lineno = 1;\n   while ((c = read_skip_spaces ()) != EOF)\n     {\n-      file_location loc (read_md_filename, read_md_lineno);\n+      file_location loc = get_current_location ();\n       if (c != '(')\n \tfatal_expected_char ('(', c);\n \n@@ -1002,49 +1025,51 @@ handle_file (directive_handler_t handle_directive)\n       else if (strcmp (directive.string, \"define_c_enum\") == 0)\n \thandle_enum (loc, false);\n       else if (strcmp (directive.string, \"include\") == 0)\n-\thandle_include (loc, handle_directive);\n-      else if (handle_directive)\n-\thandle_directive (loc, directive.string);\n+\thandle_include (loc);\n       else\n-\tread_skip_construct (1, loc);\n+\thandle_unknown_directive (loc, directive.string);\n \n       require_char_ws (')');\n     }\n-  fclose (read_md_file);\n+  fclose (m_read_md_file);\n }\n \n-/* Like handle_file, but for top-level files.  Set up in_fname and\n-   base_dir accordingly.  */\n+/* Like handle_file, but for top-level files.  Set up m_toplevel_fname\n+   and m_base_dir accordingly.  */\n \n-static void\n-handle_toplevel_file (directive_handler_t handle_directive)\n+void\n+rtx_reader::handle_toplevel_file ()\n {\n   const char *base;\n \n-  in_fname = read_md_filename;\n-  base = lbasename (in_fname);\n-  if (base == in_fname)\n-    base_dir = NULL;\n+  m_toplevel_fname = m_read_md_filename;\n+  base = lbasename (m_toplevel_fname);\n+  if (base == m_toplevel_fname)\n+    m_base_dir = NULL;\n   else\n-    base_dir = xstrndup (in_fname, base - in_fname);\n+    m_base_dir = xstrndup (m_toplevel_fname, base - m_toplevel_fname);\n+\n+  handle_file ();\n+}\n \n-  handle_file (handle_directive);\n+file_location\n+rtx_reader::get_current_location () const\n+{\n+  return file_location (m_read_md_filename, m_read_md_lineno);\n }\n \n /* Parse a -I option with argument ARG.  */\n \n-static void\n-parse_include (const char *arg)\n+void\n+rtx_reader::add_include_path (const char *arg)\n {\n   struct file_name_list *dirtmp;\n \n   dirtmp = XNEW (struct file_name_list);\n   dirtmp->next = 0;\n   dirtmp->fname = arg;\n-  *last_dir_md_include_ptr = dirtmp;\n-  last_dir_md_include_ptr = &dirtmp->next;\n-  if (strlen (dirtmp->fname) > max_include_len)\n-    max_include_len = strlen (dirtmp->fname);\n+  *m_last_dir_md_include_ptr = dirtmp;\n+  m_last_dir_md_include_ptr = &dirtmp->next;\n }\n \n /* The main routine for reading .md files.  Try to process all the .md\n@@ -1054,16 +1079,11 @@ parse_include (const char *arg)\n \n    PARSE_OPT, if nonnull, is passed all unknown command-line arguments.\n    It should return true if it recognizes the argument or false if a\n-   generic error should be reported.\n-\n-   If HANDLE_DIRECTIVE is nonnull, the parser calls it for each\n-   unknown directive, otherwise it just skips such directives.\n-   See the comment above the directive_handler_t definition for\n-   details about the callback's interface.  */\n+   generic error should be reported.  */\n \n bool\n-read_md_files (int argc, const char **argv, bool (*parse_opt) (const char *),\n-\t       directive_handler_t handle_directive)\n+rtx_reader::read_md_files (int argc, const char **argv,\n+\t\t\t   bool (*parse_opt) (const char *))\n {\n   int i;\n   bool no_more_options;\n@@ -1101,9 +1121,9 @@ read_md_files (int argc, const char **argv, bool (*parse_opt) (const char *),\n \tif (argv[i][1] == 'I')\n \t  {\n \t    if (argv[i][2] != '\\0')\n-\t      parse_include (argv[i] + 2);\n+\t      add_include_path (argv[i] + 2);\n \t    else if (++i < argc)\n-\t      parse_include (argv[i]);\n+\t      add_include_path (argv[i]);\n \t    else\n \t      fatal (\"directory name missing after -I option\");\n \t    continue;\n@@ -1131,9 +1151,9 @@ read_md_files (int argc, const char **argv, bool (*parse_opt) (const char *),\n \t      if (already_read_stdin)\n \t\tfatal (\"cannot read standard input twice\");\n \n-\t      read_md_file = stdin;\n-\t      read_md_filename = \"<stdin>\";\n-\t      handle_toplevel_file (handle_directive);\n+\t      m_read_md_file = stdin;\n+\t      m_read_md_filename = \"<stdin>\";\n+\t      handle_toplevel_file ();\n \t      already_read_stdin = true;\n \t      continue;\n \t    }\n@@ -1149,25 +1169,34 @@ read_md_files (int argc, const char **argv, bool (*parse_opt) (const char *),\n \n       /* If we get here we are looking at a non-option argument, i.e.\n \t a file to be processed.  */\n-      read_md_filename = argv[i];\n-      read_md_file = fopen (read_md_filename, \"r\");\n-      if (read_md_file == 0)\n+      m_read_md_filename = argv[i];\n+      m_read_md_file = fopen (m_read_md_filename, \"r\");\n+      if (m_read_md_file == 0)\n \t{\n-\t  perror (read_md_filename);\n+\t  perror (m_read_md_filename);\n \t  return false;\n \t}\n-      handle_toplevel_file (handle_directive);\n+      handle_toplevel_file ();\n       num_files++;\n     }\n \n   /* If we get to this point without having seen any files to process,\n      read the standard input now.  */\n   if (num_files == 0 && !already_read_stdin)\n     {\n-      read_md_file = stdin;\n-      read_md_filename = \"<stdin>\";\n-      handle_toplevel_file (handle_directive);\n+      m_read_md_file = stdin;\n+      m_read_md_filename = \"<stdin>\";\n+      handle_toplevel_file ();\n     }\n \n   return !have_error;\n }\n+\n+/* class noop_reader : public rtx_reader */\n+\n+/* A dummy implementation which skips unknown directives.  */\n+void\n+noop_reader::handle_unknown_directive (file_location loc, const char *)\n+{\n+  read_skip_construct (1, loc);\n+}"}, {"sha": "82a628bedfa2830a4e3e94dba3306b862ac9f5c9", "filename": "gcc/read-md.h", "status": "modified", "additions": 77, "deletions": 21, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-md.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-md.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-md.h?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -90,16 +90,81 @@ struct enum_type {\n   unsigned int num_values;\n };\n \n-/* A callback that handles a single .md-file directive, up to but not\n-   including the closing ')'.  It takes two arguments: the file position\n-   at which the directive started, and the name of the directive.  The next\n-   unread character is the optional space after the directive name.  */\n-typedef void (*directive_handler_t) (file_location, const char *);\n-\n-extern const char *in_fname;\n-extern FILE *read_md_file;\n-extern int read_md_lineno;\n-extern const char *read_md_filename;\n+class rtx_reader\n+{\n+ public:\n+  rtx_reader ();\n+  virtual ~rtx_reader ();\n+\n+  bool read_md_files (int, const char **, bool (*) (const char *));\n+\n+  /* A hook that handles a single .md-file directive, up to but not\n+     including the closing ')'.  It takes two arguments: the file position\n+     at which the directive started, and the name of the directive.  The next\n+     unread character is the optional space after the directive name.  */\n+  virtual void handle_unknown_directive (file_location, const char *) = 0;\n+\n+  file_location get_current_location () const;\n+\n+  int read_char (void);\n+  void unread_char (int ch);\n+\n+  const char *get_top_level_filename () const { return m_toplevel_fname; }\n+  const char *get_filename () const { return m_read_md_filename; }\n+  int get_lineno () const { return m_read_md_lineno; }\n+\n+ private:\n+  /* A singly-linked list of filenames.  */\n+  struct file_name_list {\n+    struct file_name_list *next;\n+    const char *fname;\n+  };\n+\n+ private:\n+  void handle_file ();\n+  void handle_toplevel_file ();\n+  void handle_include (file_location loc);\n+  void add_include_path (const char *arg);\n+\n+ private:\n+  /* The name of the toplevel file that indirectly included\n+     m_read_md_file.  */\n+  const char *m_toplevel_fname;\n+\n+  /* The directory part of m_toplevel_fname\n+     NULL if m_toplevel_fname is a bare filename.  */\n+  char *m_base_dir;\n+\n+  /* The file we are reading.  */\n+  FILE *m_read_md_file;\n+\n+  /* The filename of m_read_md_file.  */\n+  const char *m_read_md_filename;\n+\n+  /* The current line number in m_read_md_file.  */\n+  int m_read_md_lineno;\n+\n+  /* The first directory to search.  */\n+  file_name_list *m_first_dir_md_include;\n+\n+  /* A pointer to the null terminator of the md include chain.  */\n+  file_name_list **m_last_dir_md_include_ptr;\n+};\n+\n+/* Global singleton.  */\n+extern rtx_reader *rtx_reader_ptr;\n+\n+/* An rtx_reader subclass which skips unknown directives.  */\n+\n+class noop_reader : public rtx_reader\n+{\n+ public:\n+  noop_reader () : rtx_reader () {}\n+\n+  /* A dummy implementation which skips unknown directives.  */\n+  void handle_unknown_directive (file_location, const char *);\n+};\n+\n extern struct obstack string_obstack;\n extern void (*include_callback) (const char *);\n \n@@ -108,22 +173,15 @@ extern void (*include_callback) (const char *);\n static inline int\n read_char (void)\n {\n-  int ch;\n-\n-  ch = getc (read_md_file);\n-  if (ch == '\\n')\n-    read_md_lineno++;\n-  return ch;\n+  return rtx_reader_ptr->read_char ();\n }\n \n /* Put back CH, which was the last character read from the MD file.  */\n \n static inline void\n unread_char (int ch)\n {\n-  if (ch == '\\n')\n-    read_md_lineno--;\n-  ungetc (ch, read_md_file);\n+  rtx_reader_ptr->unread_char (ch);\n }\n \n extern hashval_t leading_string_hash (const void *);\n@@ -151,7 +209,5 @@ extern void upcase_string (char *);\n extern void traverse_md_constants (htab_trav, void *);\n extern void traverse_enum_types (htab_trav, void *);\n extern struct enum_type *lookup_enum_type (const char *);\n-extern bool read_md_files (int, const char **, bool (*) (const char *),\n-\t\t\t   directive_handler_t);\n \n #endif /* GCC_READ_MD_H */"}, {"sha": "eda938265c588a253e7baa1b93f5165bc2295c3e", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1234,14 +1234,15 @@ read_rtx_code (const char *code_name)\n \t\t  || GET_CODE (return_rtx) == DEFINE_INSN_AND_SPLIT))\n \t    {\n \t      char line_name[20];\n+\t      const char *read_md_filename = rtx_reader_ptr->get_filename ();\n \t      const char *fn = (read_md_filename ? read_md_filename : \"rtx\");\n \t      const char *slash;\n \t      for (slash = fn; *slash; slash ++)\n \t\tif (*slash == '/' || *slash == '\\\\' || *slash == ':')\n \t\t  fn = slash + 1;\n \t      obstack_1grow (&string_obstack, '*');\n \t      obstack_grow (&string_obstack, fn, strlen (fn));\n-\t      sprintf (line_name, \":%d\", read_md_lineno);\n+\t      sprintf (line_name, \":%d\", rtx_reader_ptr->get_lineno ());\n \t      obstack_grow (&string_obstack, line_name, strlen (line_name)+1);\n \t      stringbuf = XOBFINISH (&string_obstack, char *);\n \t    }"}]}