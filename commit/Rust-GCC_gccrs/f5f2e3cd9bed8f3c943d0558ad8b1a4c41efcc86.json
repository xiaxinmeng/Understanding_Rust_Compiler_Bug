{"sha": "f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjVmMmUzY2Q5YmVkOGYzYzk0M2QwNTU4YWQ4YjFhNGM0MWVmY2M4Ng==", "commit": {"author": {"name": "Mostafa Hagog", "email": "mustafa@il.ibm.com", "date": "2003-10-17T16:16:45Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-17T16:16:45Z"}, "message": "common.opt: Add description of the new -fgcse-las flag.\n\n2003-10-17  Mostafa Hagog  <mustafa@il.ibm.com>\n\n\t* common.opt: Add description of the new -fgcse-las flag.\n\t* flags.h (flag_gcse_las): Declaration of global flag_gcse_las.\n\t* gcse.c (hash_scan_set): Handle the case of store expression and\n\tinsert the memory expression to the hash table, this way we make it\n\tpossible to discover redundant loads after stores and remove them.\n\t(pre_insert_copy_insn): moved the call to update_ld_motion_stores,\n\tto pre_insert_copies, it is not the correct place to call it after\n\tadding stores to be in the available expression hash table.\n\t(pre_insert_copies): Added the call to update_ld_motion_stores when\n\tone or more copies were inserted.\n\t* opts.c (common_handle_option): Handle the -fgcse-las flag.\n\t* toplev.c (flag_gcse_las): Initialization of flag_gcse_las.\n\n\t* doc/invoke.tex: Document new -fgcse-las flag.\n\nFrom-SVN: r72612", "tree": {"sha": "a29aa6dd07abdea8e834684eb42d8d5349352a34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a29aa6dd07abdea8e834684eb42d8d5349352a34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/comments", "author": null, "committer": null, "parents": [{"sha": "9579624e7258fc1c5cf8e79a63bbe950deae7c17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9579624e7258fc1c5cf8e79a63bbe950deae7c17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9579624e7258fc1c5cf8e79a63bbe950deae7c17"}], "stats": {"total": 161, "additions": 139, "deletions": 22}, "files": [{"sha": "6cb9af49ec0e723f234c80b01d4c31a40b55dd1a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -1,3 +1,20 @@\n+2003-10-17  Mostafa Hagog  <mustafa@il.ibm.com>\n+\n+\t* common.opt: Add description of the new -fgcse-las flag.\n+\t* flags.h (flag_gcse_las): Declaration of global flag_gcse_las.\n+\t* gcse.c (hash_scan_set): Handle the case of store expression and\n+\tinsert the memory expression to the hash table, this way we make it\n+\tpossible to discover redundant loads after stores and remove them.\n+\t(pre_insert_copy_insn): moved the call to update_ld_motion_stores,\n+\tto pre_insert_copies, it is not the correct place to call it after\n+\tadding stores to be in the available expression hash table.\n+\t(pre_insert_copies): Added the call to update_ld_motion_stores when\n+\tone or more copies were inserted.\n+\t* opts.c (common_handle_option): Handle the -fgcse-las flag.\n+\t* toplev.c (flag_gcse_las): Initialization of flag_gcse_las.\n+\n+\t* doc/invoke.tex: Document new -fgcse-las flag.\n+\n 2003-10-18  Alan Modra  <amodra@bigpond.net.au>\n \n \t* config/rs6000/crtsavres.asm: Correct alignment of powerpc64 code"}, {"sha": "fdf28b214259a1841b498249d4af37e526fbb73b", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -362,6 +362,10 @@ fgcse-sm\n Common\n Perform store motion after global common subexpression elimination\n \n+fgcse-las\n+Common\n+Perform redundant load after store elimination in global common subexpression elimination\n+\n fgnu-linker\n Common\n Output GNU ld formatted global initializers"}, {"sha": "fd2040034a89d61372c844b2a671f2b89d0d79ae", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 17, "deletions": 8, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -270,8 +270,8 @@ in the following sections.\n -fdelayed-branch  -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations  -ffast-math  -ffloat-store @gol\n -fforce-addr  -fforce-mem  -ffunction-sections @gol\n--fgcse  -fgcse-lm  -fgcse-sm  -floop-optimize  -fcrossjumping @gol\n--fif-conversion  -fif-conversion2 @gol\n+-fgcse  -fgcse-lm  -fgcse-sm  -fgcse-las  -floop-optimize @gol\n+-fcrossjumping  -fif-conversion  -fif-conversion2 @gol\n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions @gol\n -fkeep-static-consts  -fmerge-constants  -fmerge-all-constants @gol\n -fmove-all-movables  -fnew-ra  -fno-branch-count-reg @gol\n@@ -3677,10 +3677,10 @@ also turns on the following optimization flags:\n -fstrength-reduce @gol\n -fcse-follow-jumps  -fcse-skip-blocks @gol\n -frerun-cse-after-loop  -frerun-loop-opt @gol\n--fgcse   -fgcse-lm   -fgcse-sm @gol\n+-fgcse  -fgcse-lm  -fgcse-sm  -fgcse-las @gol\n -fdelete-null-pointer-checks @gol\n -fexpensive-optimizations @gol\n--fregmove -@gol\n+-fregmove @gol\n -fschedule-insns  -fschedule-insns2 @gol\n -fsched-interblock  -fsched-spec @gol\n -fcaller-saves @gol\n@@ -3996,10 +3996,19 @@ Enabled by default when gcse is enabled.\n \n @item -fgcse-sm\n @opindex fgcse-sm\n-When @option{-fgcse-sm} is enabled, A store motion pass is run after global common\n-subexpression elimination.  This pass will attempt to move stores out of loops.\n-When used in conjunction with @option{-fgcse-lm}, loops containing a load/store sequence\n-can be changed to a load before the loop and a store after the loop.\n+When @option{-fgcse-sm} is enabled, a store motion pass is run after\n+global common subexpression elimination.  This pass will attempt to move\n+stores out of loops.  When used in conjunction with @option{-fgcse-lm},\n+loops containing a load/store sequence can be changed to a load before\n+the loop and a store after the loop.\n+\n+Enabled by default when gcse is enabled.\n+\n+@item -fgcse-las\n+@opindex fgcse-las\n+When @option{-fgcse-las} is enabled, the global common subexpression\n+elimination pass eliminates redundant loads that come after stores to the\n+same memory location (both partial and full redundacies).\n \n Enabled by default when gcse is enabled.\n "}, {"sha": "2a1a10ff679df803232f9b2e336d7c649e8fa9ff", "filename": "gcc/flags.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -675,6 +675,11 @@ extern int flag_gcse_lm;\n \n extern int flag_gcse_sm;\n \n+/* Nonzero if we want to perform redundant load-after-store elimination\n+   in gcse.  */\n+\n+extern int flag_gcse_las;\n+\n /* Perform branch target register optimization before prologue / epilogue\n    threading.  */\n "}, {"sha": "3e09f02252bb9bb7168219f14186fea4f228a5cb", "filename": "gcc/gcse.c", "status": "modified", "additions": 86, "deletions": 14, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -2205,6 +2205,49 @@ hash_scan_set (rtx pat, rtx insn, struct hash_table *table)\n \t\t       && oprs_available_p (pat, tmp))))\n \tinsert_set_in_table (pat, insn, table);\n     }\n+  /* In case of store we want to consider the memory value as avaiable in\n+     the REG stored in that memory. This makes it possible to remove\n+     redundant loads from due to stores to the same location.  */\n+  else if (flag_gcse_las && GET_CODE (src) == REG && GET_CODE (dest) == MEM)\n+      {\n+        unsigned int regno = REGNO (src);\n+\n+        /* Do not do this for constant/copy propagation.  */\n+        if (! table->set_p\n+            /* Only record sets of pseudo-regs in the hash table.  */\n+\t    && regno >= FIRST_PSEUDO_REGISTER\n+\t   /* Don't GCSE something if we can't do a reg/reg copy.  */\n+\t   && can_copy_p (GET_MODE (src))\n+\t   /* GCSE commonly inserts instruction after the insn.  We can't\n+\t      do that easily for EH_REGION notes so disable GCSE on these\n+\t      for now.  */\n+\t   && ! find_reg_note (insn, REG_EH_REGION, NULL_RTX)\n+\t   /* Is SET_DEST something we want to gcse?  */\n+\t   && want_to_gcse_p (dest)\n+\t   /* Don't CSE a nop.  */\n+\t   && ! set_noop_p (pat)\n+\t   /* Don't GCSE if it has attached REG_EQUIV note.\n+\t      At this point this only function parameters should have\n+\t      REG_EQUIV notes and if the argument slot is used somewhere\n+\t      explicitly, it means address of parameter has been taken,\n+\t      so we should not extend the lifetime of the pseudo.  */\n+\t   && ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)) == 0\n+\t       || GET_CODE (XEXP (note, 0)) != MEM))\n+             {\n+               /* Stores are never anticipatable.  */\n+               int antic_p = 0;\n+\t       /* An expression is not available if its operands are\n+\t          subsequently modified, including this insn.  It's also not\n+\t          available if this is a branch, because we can't insert\n+\t          a set after the branch.  */\n+               int avail_p = oprs_available_p (dest, insn)\n+\t\t\t     && ! JUMP_P (insn);\n+\n+\t       /* Record the memory expression (DEST) in the hash table.  */\n+\t       insert_expr_in_table (dest, GET_MODE (dest), insn,\n+\t\t\t\t     antic_p, avail_p, table);\n+             }\n+      }\n }\n \n static void\n@@ -5360,7 +5403,13 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n      reaching_reg <- expr\n      old_reg      <- reaching_reg\n    because this way copy propagation can discover additional PRE\n-   opportunities.  But if this fails, we try the old way.  */\n+   opportunities.  But if this fails, we try the old way.\n+   When \"expr\" is a store, i.e.\n+   given \"MEM <- old_reg\", instead of adding after it\n+     reaching_reg <- old_reg\n+   it's better to add it before as follows:\n+     reaching_reg <- old_reg\n+     MEM          <- reaching_reg.  */\n \n static void\n pre_insert_copy_insn (struct expr *expr, rtx insn)\n@@ -5395,22 +5444,38 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n   else\n     abort ();\n \n-  old_reg = SET_DEST (set);\n-\n-  /* Check if we can modify the set destination in the original insn.  */\n-  if (validate_change (insn, &SET_DEST (set), reg, 0))\n+  if (GET_CODE (SET_DEST (set)) == REG)\n     {\n-      new_insn = gen_move_insn (old_reg, reg);\n-      new_insn = emit_insn_after (new_insn, insn);\n+      old_reg = SET_DEST (set);\n+      /* Check if we can modify the set destination in the original insn.  */\n+      if (validate_change (insn, &SET_DEST (set), reg, 0))\n+        {\n+          new_insn = gen_move_insn (old_reg, reg);\n+          new_insn = emit_insn_after (new_insn, insn);\n \n-      /* Keep register set table up to date.  */\n-      replace_one_set (REGNO (old_reg), insn, new_insn);\n-      record_one_set (regno, insn);\n+          /* Keep register set table up to date.  */\n+          replace_one_set (REGNO (old_reg), insn, new_insn);\n+          record_one_set (regno, insn);\n+        }\n+      else\n+        {\n+          new_insn = gen_move_insn (reg, old_reg);\n+          new_insn = emit_insn_after (new_insn, insn);\n+\n+          /* Keep register set table up to date.  */\n+          record_one_set (regno, new_insn);\n+        }\n     }\n-  else\n+  else /* This is possible only in case of a store to memory.  */\n     {\n+      old_reg = SET_SRC (set);\n       new_insn = gen_move_insn (reg, old_reg);\n-      new_insn = emit_insn_after (new_insn, insn);\n+\n+      /* Check if we can modify the set source in the original insn.  */\n+      if (validate_change (insn, &SET_SRC (set), reg, 0))\n+        new_insn = emit_insn_before (new_insn, insn);\n+      else\n+        new_insn = emit_insn_after (new_insn, insn);\n \n       /* Keep register set table up to date.  */\n       record_one_set (regno, new_insn);\n@@ -5423,7 +5488,6 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n \t     \"PRE: bb %d, insn %d, copy expression %d in insn %d to reg %d\\n\",\n \t      BLOCK_NUM (insn), INSN_UID (new_insn), indx,\n \t      INSN_UID (insn), regno);\n-  update_ld_motion_stores (expr);\n }\n \n /* Copy available expressions that reach the redundant expression\n@@ -5432,7 +5496,7 @@ pre_insert_copy_insn (struct expr *expr, rtx insn)\n static void\n pre_insert_copies (void)\n {\n-  unsigned int i;\n+  unsigned int i, added_copy;\n   struct expr *expr;\n   struct occr *occr;\n   struct occr *avail;\n@@ -5453,6 +5517,9 @@ pre_insert_copies (void)\n \t   expression wasn't deleted anywhere.  */\n \tif (expr->reaching_reg == NULL)\n \t  continue;\n+\t\n+\t/* Set when we add a copy for that expression.  */\n+\tadded_copy = 0; \n \n \tfor (occr = expr->antic_occr; occr != NULL; occr = occr->next)\n \t  {\n@@ -5477,11 +5544,16 @@ pre_insert_copies (void)\n \t\t\t\t\t       BLOCK_FOR_INSN (occr->insn)))\n \t\t  continue;\n \n+                added_copy = 1;\n+\n \t\t/* Copy the result of avail to reaching_reg.  */\n \t\tpre_insert_copy_insn (expr, insn);\n \t\tavail->copied_p = 1;\n \t      }\n \t  }\n+\n+ \t  if (added_copy)\n+            update_ld_motion_stores (expr);\n       }\n }\n "}, {"sha": "8418d1a96c2e3936923537fa5ab5b68d86588696", "filename": "gcc/opts.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -1019,6 +1019,10 @@ common_handle_option (size_t scode, const char *arg,\n       flag_gcse_sm = value;\n       break;\n \n+    case OPT_fgcse_las:\n+      flag_gcse_las = value;\n+      break;\n+\n     case OPT_fgnu_linker:\n       flag_gnu_linker = value;\n       break;"}, {"sha": "c1a05f6e26ded1862f21e599ed4db3ec525741e7", "filename": "gcc/toplev.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f5f2e3cd9bed8f3c943d0558ad8b1a4c41efcc86", "patch": "@@ -697,6 +697,11 @@ int flag_gcse_lm = 1;\n \n int flag_gcse_sm = 1;\n \n+/* Nonzero if we want to perfrom redundant load after store elimination\n+   in gcse.  */\n+\n+int flag_gcse_las = 1;\n+\n /* Perform target register optimization before prologue / epilogue\n    threading.  */\n \n@@ -1075,6 +1080,7 @@ static const lang_independent_options f_options[] =\n   {\"gcse\", &flag_gcse, 1 },\n   {\"gcse-lm\", &flag_gcse_lm, 1 },\n   {\"gcse-sm\", &flag_gcse_sm, 1 },\n+  {\"gcse-las\", &flag_gcse_las, 1 },\n   {\"branch-target-load-optimize\", &flag_branch_target_load_optimize, 1 },\n   {\"branch-target-load-optimize2\", &flag_branch_target_load_optimize2, 1 },\n   {\"loop-optimize\", &flag_loop_optimize, 1 },"}]}