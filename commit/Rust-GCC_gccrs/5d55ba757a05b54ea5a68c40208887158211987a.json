{"sha": "5d55ba757a05b54ea5a68c40208887158211987a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQ1NWJhNzU3YTA1YjU0ZWE1YTY4YzQwMjA4ODg3MTU4MjExOTg3YQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-02T10:31:14Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-02T10:31:14Z"}, "message": "(null_prologue): Renamed from null_epilogue.\n\n(condition_value): New function.\n\nFrom-SVN: r1385", "tree": {"sha": "117177f25821e4f84629e4fb5906a12cd1143442", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/117177f25821e4f84629e4fb5906a12cd1143442"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d55ba757a05b54ea5a68c40208887158211987a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d55ba757a05b54ea5a68c40208887158211987a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d55ba757a05b54ea5a68c40208887158211987a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d55ba757a05b54ea5a68c40208887158211987a/comments", "author": null, "committer": null, "parents": [{"sha": "b6ecac2145d64a4b75d34ee3157a1f95449f3221", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6ecac2145d64a4b75d34ee3157a1f95449f3221", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6ecac2145d64a4b75d34ee3157a1f95449f3221"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "454ebc76c0b8f88a8c2cfe19d97f26feb5084e67", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d55ba757a05b54ea5a68c40208887158211987a/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d55ba757a05b54ea5a68c40208887158211987a/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=5d55ba757a05b54ea5a68c40208887158211987a", "patch": "@@ -46,7 +46,7 @@ extern char *ctime ();\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-static char out_sccs_id[] = \"@(#)m88k.c\t2.2.3.6 29 Jun 1992 16:06:14\";\n+static char out_sccs_id[] = \"@(#)m88k.c\t2.2.6.6 02 Jul 1992 06:06:08\";\n static char tm_sccs_id [] = TM_SCCS_ID;\n \n char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n@@ -93,6 +93,28 @@ classify_integer (mode, value)\n     return m88k_oru_or;\n }\n \n+/* Return the bit number in a compare word corresponding to CONDITION.  */\n+\n+int\n+condition_value (condition)\n+     rtx condition;\n+{\n+  switch (GET_CODE (condition))\n+    {\n+    case EQ: return 2;\n+    case NE: return 3;\n+    case GT: return 4;\n+    case LE: return 5;\n+    case LT: return 6;\n+    case GE: return 7;\n+    case GTU: return 8;\n+    case LEU: return 9;\n+    case LTU: return 10;\n+    case GEU: return 11;\n+    default: abort ();\n+    }\n+}\n+\n int\n integer_ok_for_set (value)\n      register unsigned value;\n@@ -1664,10 +1686,10 @@ m88k_layout_frame ()\n   }\n }\n \n-/* Return true if this function is known to have a null epilogue.  */\n+/* Return true if this function is known to have a null prologue.  */\n \n int\n-null_epilogue ()\n+null_prologue ()\n {\n   if (! reload_completed)\n     return 0;\n@@ -1786,7 +1808,7 @@ m88k_expand_prologue ()\n \temit_move_insn (return_reg, temp_reg);\n     }\n   if (profile_flag || profile_block_flag)\n-    emit_insn (gen_profiler ());\n+    emit_insn (gen_blockage ());\n }\n \f\n /* This function generates the assembly code for function exit,\n@@ -1811,9 +1833,18 @@ m88k_end_epilogue (stream, size)\n      FILE *stream;\n      int size;\n {\n+  rtx insn = get_last_insn ();\n+\n   if (TARGET_OCS_DEBUG_INFO && !epilogue_marked)\n     PUT_OCS_FUNCTION_END (stream);\n \n+  /* If the last insn isn't a BARRIER, we must write a return insn.  This\n+     should only happen if the function has no prologe and no body.  */\n+  if (GET_CODE (insn) == NOTE)\n+    insn = prev_nonnote_insn (insn);\n+  if (insn == 0 || GET_CODE (insn) != BARRIER)\n+    fprintf (stream, \"\\tjmp\\t %s\\n\", reg_names[1]);\n+\n   output_short_branch_defs (stream);\n \n   fprintf (stream, \"\\n\");"}]}