{"sha": "a8ebd27d0ab69b08fd6e335bbb48a73a50202586", "node_id": "C_kwDOANBUbNoAKGE4ZWJkMjdkMGFiNjliMDhmZDZlMzM1YmJiNDhhNzNhNTAyMDI1ODY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-31T13:25:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-08-31T14:26:05Z"}, "message": "Avoid fatal fails in predicate::init_from_control_deps\n\nWhen processing USE predicates we can drop from the AND chain,\nwhen procsssing DEF predicates we can drop from the OR chain.  Do\nthat instead of giving up completely.  This also removes cases\nthat should never trigger.\n\n\t* gimple-predicate-analysis.cc (predicate::init_from_control_deps):\n\tAssert the guard_bb isn't empty and has more than one successor.\n\tDrop appropriate parts of the predicate when an edge fails to\n\tregister a predicate.\n\t(predicate::dump): Dump empty predicate as TRUE.", "tree": {"sha": "086082da28854ae07bca908e2bb16100b6a64ed1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/086082da28854ae07bca908e2bb16100b6a64ed1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8ebd27d0ab69b08fd6e335bbb48a73a50202586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ebd27d0ab69b08fd6e335bbb48a73a50202586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8ebd27d0ab69b08fd6e335bbb48a73a50202586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8ebd27d0ab69b08fd6e335bbb48a73a50202586/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "caaf9e66c498d9d6dc8be665d820ab45afa406ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/caaf9e66c498d9d6dc8be665d820ab45afa406ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/caaf9e66c498d9d6dc8be665d820ab45afa406ae"}], "stats": {"total": 119, "additions": 55, "deletions": 64}, "files": [{"sha": "eb1e11cead89546ca86ea61fd92c7bf0f1629179", "filename": "gcc/gimple-predicate-analysis.cc", "status": "modified", "additions": 55, "deletions": 64, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8ebd27d0ab69b08fd6e335bbb48a73a50202586/gcc%2Fgimple-predicate-analysis.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8ebd27d0ab69b08fd6e335bbb48a73a50202586/gcc%2Fgimple-predicate-analysis.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-predicate-analysis.cc?ref=a8ebd27d0ab69b08fd6e335bbb48a73a50202586", "patch": "@@ -1671,7 +1671,6 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n {\n   gcc_assert (is_empty ());\n \n-  bool has_valid_pred = false;\n   if (num_chains == 0)\n     return;\n \n@@ -1689,27 +1688,16 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n \t of the predicates.  */\n       const vec<edge> &path = dep_chains[i];\n \n-      has_valid_pred = false;\n+      bool has_valid_pred = false;\n       /* The chain of predicates guarding the definition along this path.  */\n       pred_chain t_chain{ };\n       for (unsigned j = 0; j < path.length (); j++)\n \t{\n \t  edge e = path[j];\n \t  basic_block guard_bb = e->src;\n-\t  /* Ignore empty forwarder blocks.  */\n-\t  if (empty_block_p (guard_bb) && single_succ_p (guard_bb))\n-\t    continue;\n \n-\t  /* An empty basic block here is likely a PHI, and is not one\n-\t     of the cases we handle below.  */\n-\t  gimple_stmt_iterator gsi = gsi_last_bb (guard_bb);\n-\t  if (gsi_end_p (gsi))\n-\t    {\n-\t      has_valid_pred = false;\n-\t      break;\n-\t    }\n-\t  /* Get the conditional controlling the bb exit edge.  */\n-\t  gimple *cond_stmt = gsi_stmt (gsi);\n+\t  gcc_assert (!empty_block_p (guard_bb) && !single_succ_p (guard_bb));\n+\n \t  /* Skip this edge if it is bypassing an abort - when the\n \t     condition is not satisfied we are neither reaching the\n \t     definition nor the use so it isn't meaningful.  Note if\n@@ -1730,8 +1718,13 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n \t\t    }\n \t\t}\n \t      if (skip)\n-\t\tcontinue;\n+\t\t{\n+\t\t  has_valid_pred = true;\n+\t\t  continue;\n+\t\t}\n \t    }\n+\t  /* Get the conditional controlling the bb exit edge.  */\n+\t  gimple *cond_stmt = last_stmt (guard_bb);\n \t  if (gimple_code (cond_stmt) == GIMPLE_COND)\n \t    {\n \t      /* The true edge corresponds to the uninteresting condition.\n@@ -1757,37 +1750,29 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n \t    }\n \t  else if (gswitch *gs = dyn_cast<gswitch *> (cond_stmt))\n \t    {\n-\t      /* Avoid quadratic behavior.  */\n-\t      if (gimple_switch_num_labels (gs) > MAX_SWITCH_CASES)\n-\t\t{\n-\t\t  has_valid_pred = false;\n-\t\t  break;\n-\t\t}\n-\t      /* Find the case label.  */\n \t      tree l = NULL_TREE;\n-\t      unsigned idx;\n-\t      for (idx = 0; idx < gimple_switch_num_labels (gs); ++idx)\n-\t\t{\n-\t\t  tree tl = gimple_switch_label (gs, idx);\n-\t\t  if (e->dest == label_to_block (cfun, CASE_LABEL (tl)))\n-\t\t    {\n-\t\t      if (!l)\n-\t\t\tl = tl;\n-\t\t      else\n-\t\t\t{\n-\t\t\t  l = NULL_TREE;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n+\t      /* Find the case label, but avoid quadratic behavior.  */\n+\t      if (gimple_switch_num_labels (gs) <= MAX_SWITCH_CASES)\n+\t\tfor (unsigned idx = 0;\n+\t\t     idx < gimple_switch_num_labels (gs); ++idx)\n+\t\t  {\n+\t\t    tree tl = gimple_switch_label (gs, idx);\n+\t\t    if (e->dest == label_to_block (cfun, CASE_LABEL (tl)))\n+\t\t      {\n+\t\t\tif (!l)\n+\t\t\t  l = tl;\n+\t\t\telse\n+\t\t\t  {\n+\t\t\t    l = NULL_TREE;\n+\t\t\t    break;\n+\t\t\t  }\n+\t\t      }\n+\t\t  }\n \t      /* If more than one label reaches this block or the case\n \t\t label doesn't have a contiguous range of values (like the\n \t\t default one) fail.  */\n \t      if (!l || !CASE_LOW (l))\n-\t\t{\n-\t\t  has_valid_pred = false;\n-\t\t  break;\n-\t\t}\n+\t\thas_valid_pred = false;\n \t      else if (!CASE_HIGH (l)\n \t\t      || operand_equal_p (CASE_LOW (l), CASE_HIGH (l)))\n \t\t{\n@@ -1824,31 +1809,37 @@ predicate::init_from_control_deps (const vec<edge> *dep_chains,\n \t       both the USE (valid) and DEF (questionable) case.  */\n \t    has_valid_pred = true;\n \t  else\n-\t    {\n-\t      has_valid_pred = false;\n-\t      break;\n-\t    }\n+\t    has_valid_pred = false;\n+\n+\t  /* For USE predicates we can drop components of the\n+\t     AND chain.  */\n+\t  if (!has_valid_pred && !is_use)\n+\t    break;\n \t}\n \n-      if (!has_valid_pred)\n-\tbreak;\n-      else\n-\tm_preds.quick_push (t_chain);\n-    }\n+      /* For DEF predicates we have to drop components of the OR chain\n+\t on failure.  */\n+      if (!has_valid_pred && !is_use)\n+\t{\n+\t  t_chain.release ();\n+\t  continue;\n+\t}\n \n-  if (has_valid_pred)\n-    {\n-      gcc_assert (m_preds.length () != 0);\n-      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n-\tdump (NULL, \"\");\n-    }\n-  else\n-    {\n-      if (DEBUG_PREDICATE_ANALYZER && dump_file)\n-\tfprintf (dump_file, \"\\tFAILED\\n\");\n-      /* Clear M_PREDS to indicate failure.  */\n-      m_preds.release ();\n+      /* When we add || 1 simply prune the chain and return.  */\n+      if (t_chain.is_empty ())\n+\t{\n+\t  t_chain.release ();\n+\t  for (auto chain : m_preds)\n+\t    chain.release ();\n+\t  m_preds.truncate (0);\n+\t  break;\n+\t}\n+\n+      m_preds.quick_push (t_chain);\n     }\n+\n+  if (DEBUG_PREDICATE_ANALYZER && dump_file)\n+    dump (NULL, \"\");\n }\n \n /* Store a PRED in *THIS.  */\n@@ -1877,7 +1868,7 @@ predicate::dump (gimple *stmt, const char *msg) const\n   unsigned np = m_preds.length ();\n   if (np == 0)\n     {\n-      fprintf (dump_file, \"\\t(empty)\\n\");\n+      fprintf (dump_file, \"\\tTRUE (empty)\\n\");\n       return;\n     }\n "}]}