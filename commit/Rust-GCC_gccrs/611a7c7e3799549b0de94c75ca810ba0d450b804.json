{"sha": "611a7c7e3799549b0de94c75ca810ba0d450b804", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjExYTdjN2UzNzk5NTQ5YjBkZTk0Yzc1Y2E4MTBiYTBkNDUwYjgwNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-11-15T03:45:03Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-11-15T03:45:03Z"}, "message": "tree-ssa-threadupdate.c (thread_through_all_blocks): Thread blocks is post order.\n\n\t* tree-ssa-threadupdate.c (thread_through_all_blocks): Thread\n\tblocks is post order.\n\nFrom-SVN: r254752", "tree": {"sha": "91d1ec4ccb094150301946d4308954ce6a286f69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/91d1ec4ccb094150301946d4308954ce6a286f69"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/611a7c7e3799549b0de94c75ca810ba0d450b804", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a7c7e3799549b0de94c75ca810ba0d450b804", "html_url": "https://github.com/Rust-GCC/gccrs/commit/611a7c7e3799549b0de94c75ca810ba0d450b804", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/611a7c7e3799549b0de94c75ca810ba0d450b804/comments", "author": null, "committer": null, "parents": [{"sha": "171a55e7f52c1e51a85ce0e4dad550c310d1030e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/171a55e7f52c1e51a85ce0e4dad550c310d1030e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/171a55e7f52c1e51a85ce0e4dad550c310d1030e"}], "stats": {"total": 39, "additions": 31, "deletions": 8}, "files": [{"sha": "c404eb8e5a7de82abdc5386fa7affc5f2c2dcd3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611a7c7e3799549b0de94c75ca810ba0d450b804/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611a7c7e3799549b0de94c75ca810ba0d450b804/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=611a7c7e3799549b0de94c75ca810ba0d450b804", "patch": "@@ -1,3 +1,8 @@\n+2017-11-14  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (thread_through_all_blocks): Thread\n+\tblocks is post order.\n+\n 2017-11-15  Alexandre Oliva <aoliva@redhat.com>\n \n \t* dumpfile.h (TDF_COMPARE_DEBUG): New."}, {"sha": "045905eceb7290c3ebf25d6b621f501222eaeabf", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 26, "deletions": 8, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/611a7c7e3799549b0de94c75ca810ba0d450b804/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/611a7c7e3799549b0de94c75ca810ba0d450b804/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=611a7c7e3799549b0de94c75ca810ba0d450b804", "patch": "@@ -2174,7 +2174,6 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n {\n   bool retval = false;\n   unsigned int i;\n-  bitmap_iterator bi;\n   struct loop *loop;\n   auto_bitmap threaded_blocks;\n \n@@ -2278,14 +2277,33 @@ thread_through_all_blocks (bool may_peel_loop_headers)\n \n   initialize_original_copy_tables ();\n \n-  /* First perform the threading requests that do not affect\n-     loop structure.  */\n-  EXECUTE_IF_SET_IN_BITMAP (threaded_blocks, 0, i, bi)\n-    {\n-      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+  /* The order in which we process jump threads can be important.\n+\n+     Consider if we have two jump threading paths A and B.  If the\n+     target edge of A is the starting edge of B and we thread path A\n+     first, then we create an additional incoming edge into B->dest that\n+     we can not discover as a jump threading path on this iteration.\n+\n+     If we instead thread B first, then the edge into B->dest will have\n+     already been redirected before we process path A and path A will\n+     natually, with no further work, target the redirected path for B.\n \n-      if (EDGE_COUNT (bb->preds) > 0)\n-\tretval |= thread_block (bb, true);\n+     An post-order is sufficient here.  Compute the ordering first, then\n+     process the blocks.  */\n+  if (!bitmap_empty_p (threaded_blocks))\n+    {\n+      int *postorder = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+      unsigned int postorder_num = post_order_compute (postorder, false, false);\n+      for (unsigned int i = 0; i < postorder_num; i++)\n+\t{\n+\t  unsigned int indx = postorder[i];\n+\t  if (bitmap_bit_p (threaded_blocks, indx))\n+\t    {\n+\t      basic_block bb = BASIC_BLOCK_FOR_FN (cfun, indx);\n+\t      retval |= thread_block (bb, true);\n+\t    }\n+\t}\n+      free (postorder);\n     }\n \n   /* Then perform the threading through loop headers.  We start with the"}]}