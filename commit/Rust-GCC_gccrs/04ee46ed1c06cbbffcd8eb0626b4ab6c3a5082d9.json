{"sha": "04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDRlZTQ2ZWQxYzA2Y2JiZmZjZDhlYjA2MjZiNGFiNmMzYTUwODJkOQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:09Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-12-17T00:15:09Z"}, "message": "rtlanal: Add some new helper classes\n\nThis patch adds some classes for gathering the list of registers\nand memory that are read and written by an instruction, along\nwith various properties about the accesses.  In some ways it's\nsimilar to the information that DF collects for registers,\nbut extended to memory.  The main reason for using it instead\nof DF is that it can analyse tentative changes to instructions\nbefore they've been committed.\n\nThe classes also collect general information about the instruction,\nsince it's cheap to do and helps to avoid multiple walks of the same\nRTL pattern.\n\nI've tried to optimise the code quite a bit, since with later patches\nit becomes relatively performance-sensitive.  See the discussion in\nthe comments for the trade-offs involved.\n\nI put the declarations in a new rtlanal.h header file since it\nseemed a bit excessive to put so much new inline stuff in rtl.h.\n\ngcc/\n\t* rtlanal.h: New file.\n\t(MEM_REGNO): New constant.\n\t(rtx_obj_flags): New namespace.\n\t(rtx_obj_reference, rtx_properties): New classes.\n\t(growing_rtx_properties, vec_rtx_properties_base): Likewise.\n\t(vec_rtx_properties): New alias.\n\t* rtlanal.c: Include it.\n\t(rtx_properties::try_to_add_reg): New function.\n\t(rtx_properties::try_to_add_dest): Likewise.\n\t(rtx_properties::try_to_add_src): Likewise.\n\t(rtx_properties::try_to_add_pattern): Likewise.\n\t(rtx_properties::try_to_add_insn): Likewise.\n\t(vec_rtx_properties_base::grow): Likewise.", "tree": {"sha": "e013d7869c88e489c212f733856b114a91375a97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e013d7869c88e489c212f733856b114a91375a97"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a240ea024dd8533d898c8cd779dedd0747bbbf2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a240ea024dd8533d898c8cd779dedd0747bbbf2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a240ea024dd8533d898c8cd779dedd0747bbbf2e"}], "stats": {"total": 616, "additions": 616, "deletions": 0}, "files": [{"sha": "404813b76680c02e18632242c2bf93752fe18274", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"backend.h\"\n #include \"target.h\"\n #include \"rtl.h\"\n+#include \"rtlanal.h\"\n #include \"tree.h\"\n #include \"predict.h\"\n #include \"df.h\"\n@@ -2049,6 +2050,287 @@ note_uses (rtx *pbody, void (*fun) (rtx *, void *), void *data)\n       return;\n     }\n }\n+\n+/* Try to add a description of REG X to this object, stopping once\n+   the REF_END limit has been reached.  FLAGS is a bitmask of\n+   rtx_obj_reference flags that describe the context.  */\n+\n+void\n+rtx_properties::try_to_add_reg (const_rtx x, unsigned int flags)\n+{\n+  if (REG_NREGS (x) != 1)\n+    flags |= rtx_obj_flags::IS_MULTIREG;\n+  machine_mode mode = GET_MODE (x);\n+  unsigned int start_regno = REGNO (x);\n+  unsigned int end_regno = END_REGNO (x);\n+  for (unsigned int regno = start_regno; regno < end_regno; ++regno)\n+    if (ref_iter != ref_end)\n+      *ref_iter++ = rtx_obj_reference (regno, flags, mode,\n+\t\t\t\t       regno - start_regno);\n+}\n+\n+/* Add a description of destination X to this object.  FLAGS is a bitmask\n+   of rtx_obj_reference flags that describe the context.\n+\n+   This routine accepts all rtxes that can legitimately appear in a\n+   SET_DEST.  */\n+\n+void\n+rtx_properties::try_to_add_dest (const_rtx x, unsigned int flags)\n+{\n+  /* If we have a PARALLEL, SET_DEST is a list of EXPR_LIST expressions,\n+     each of whose first operand is a register.  */\n+  if (__builtin_expect (GET_CODE (x) == PARALLEL, 0))\n+    {\n+      for (int i = XVECLEN (x, 0) - 1; i >= 0; --i)\n+\tif (rtx dest = XEXP (XVECEXP (x, 0, i), 0))\n+\t  try_to_add_dest (dest, flags);\n+      return;\n+    }\n+\n+  unsigned int base_flags = flags & rtx_obj_flags::STICKY_FLAGS;\n+  flags |= rtx_obj_flags::IS_WRITE;\n+  for (;;)\n+    if (GET_CODE (x) == ZERO_EXTRACT)\n+      {\n+\ttry_to_add_src (XEXP (x, 1), base_flags);\n+\ttry_to_add_src (XEXP (x, 2), base_flags);\n+\tflags |= rtx_obj_flags::IS_READ;\n+\tx = XEXP (x, 0);\n+      }\n+    else if (GET_CODE (x) == STRICT_LOW_PART)\n+      {\n+\tflags |= rtx_obj_flags::IS_READ;\n+\tx = XEXP (x, 0);\n+      }\n+    else if (GET_CODE (x) == SUBREG)\n+      {\n+\tflags |= rtx_obj_flags::IN_SUBREG;\n+\tif (read_modify_subreg_p (x))\n+\t  flags |= rtx_obj_flags::IS_READ;\n+\tx = SUBREG_REG (x);\n+      }\n+    else\n+      break;\n+\n+  if (MEM_P (x))\n+    {\n+      if (ref_iter != ref_end)\n+\t*ref_iter++ = rtx_obj_reference (MEM_REGNO, flags, GET_MODE (x));\n+\n+      unsigned int addr_flags = base_flags | rtx_obj_flags::IN_MEM_STORE;\n+      if (flags & rtx_obj_flags::IS_READ)\n+\taddr_flags |= rtx_obj_flags::IN_MEM_LOAD;\n+      try_to_add_src (XEXP (x, 0), addr_flags);\n+      return;\n+    }\n+\n+  if (__builtin_expect (REG_P (x), 1))\n+    {\n+      /* We want to keep sp alive everywhere -  by making all\n+\t writes to sp also use sp. */\n+      if (REGNO (x) == STACK_POINTER_REGNUM)\n+\tflags |= rtx_obj_flags::IS_READ;\n+      try_to_add_reg (x, flags);\n+      return;\n+    }\n+}\n+\n+/* Try to add a description of source X to this object, stopping once\n+   the REF_END limit has been reached.  FLAGS is a bitmask of\n+   rtx_obj_reference flags that describe the context.\n+\n+   This routine accepts all rtxes that can legitimately appear in a SET_SRC.  */\n+\n+void\n+rtx_properties::try_to_add_src (const_rtx x, unsigned int flags)\n+{\n+  unsigned int base_flags = flags & rtx_obj_flags::STICKY_FLAGS;\n+  subrtx_iterator::array_type array;\n+  FOR_EACH_SUBRTX (iter, array, x, NONCONST)\n+    {\n+      const_rtx x = *iter;\n+      rtx_code code = GET_CODE (x);\n+      if (code == REG)\n+\ttry_to_add_reg (x, flags | rtx_obj_flags::IS_READ);\n+      else if (code == MEM)\n+\t{\n+\t  if (MEM_VOLATILE_P (x))\n+\t    has_volatile_refs = true;\n+\n+\t  if (!MEM_READONLY_P (x) && ref_iter != ref_end)\n+\t    {\n+\t      auto mem_flags = flags | rtx_obj_flags::IS_READ;\n+\t      *ref_iter++ = rtx_obj_reference (MEM_REGNO, mem_flags,\n+\t\t\t\t\t       GET_MODE (x));\n+\t    }\n+\n+\t  try_to_add_src (XEXP (x, 0),\n+\t\t\t  base_flags | rtx_obj_flags::IN_MEM_LOAD);\n+\t  iter.skip_subrtxes ();\n+\t}\n+      else if (code == SUBREG)\n+\t{\n+\t  try_to_add_src (SUBREG_REG (x), flags | rtx_obj_flags::IN_SUBREG);\n+\t  iter.skip_subrtxes ();\n+\t}\n+      else if (code == UNSPEC_VOLATILE)\n+\thas_volatile_refs = true;\n+      else if (code == ASM_INPUT || code == ASM_OPERANDS)\n+\t{\n+\t  has_asm = true;\n+\t  if (MEM_VOLATILE_P (x))\n+\t    has_volatile_refs = true;\n+\t}\n+      else if (code == PRE_INC\n+\t       || code == PRE_DEC\n+\t       || code == POST_INC\n+\t       || code == POST_DEC\n+\t       || code == PRE_MODIFY\n+\t       || code == POST_MODIFY)\n+\t{\n+\t  has_pre_post_modify = true;\n+\n+\t  unsigned int addr_flags = (base_flags\n+\t\t\t\t     | rtx_obj_flags::IS_PRE_POST_MODIFY\n+\t\t\t\t     | rtx_obj_flags::IS_READ);\n+\t  try_to_add_dest (XEXP (x, 0), addr_flags);\n+\t  if (code == PRE_MODIFY || code == POST_MODIFY)\n+\t    iter.substitute (XEXP (XEXP (x, 1), 1));\n+\t  else\n+\t    iter.skip_subrtxes ();\n+\t}\n+      else if (code == CALL)\n+\thas_call = true;\n+    }\n+}\n+\n+/* Try to add a description of instruction pattern PAT to this object,\n+   stopping once the REF_END limit has been reached.  */\n+\n+void\n+rtx_properties::try_to_add_pattern (const_rtx pat)\n+{\n+  switch (GET_CODE (pat))\n+    {\n+    case COND_EXEC:\n+      try_to_add_src (COND_EXEC_TEST (pat));\n+      try_to_add_pattern (COND_EXEC_CODE (pat));\n+      break;\n+\n+    case PARALLEL:\n+      {\n+\tint last = XVECLEN (pat, 0) - 1;\n+\tfor (int i = 0; i < last; ++i)\n+\t  try_to_add_pattern (XVECEXP (pat, 0, i));\n+\ttry_to_add_pattern (XVECEXP (pat, 0, last));\n+\tbreak;\n+      }\n+\n+    case ASM_OPERANDS:\n+      for (int i = 0, len = ASM_OPERANDS_INPUT_LENGTH (pat); i < len; ++i)\n+\ttry_to_add_src (ASM_OPERANDS_INPUT (pat, i));\n+      break;\n+\n+    case CLOBBER:\n+      try_to_add_dest (XEXP (pat, 0), rtx_obj_flags::IS_CLOBBER);\n+      break;\n+\n+    case SET:\n+      try_to_add_dest (SET_DEST (pat));\n+      try_to_add_src (SET_SRC (pat));\n+      break;\n+\n+    default:\n+      /* All the other possibilities never store and can use a normal\n+\t rtx walk.  This includes:\n+\n+\t - USE\n+\t - TRAP_IF\n+\t - PREFETCH\n+\t - UNSPEC\n+\t - UNSPEC_VOLATILE.  */\n+      try_to_add_src (pat);\n+      break;\n+    }\n+}\n+\n+/* Try to add a description of INSN to this object, stopping once\n+   the REF_END limit has been reached.  INCLUDE_NOTES is true if the\n+   description should include REG_EQUAL and REG_EQUIV notes; all such\n+   references will then be marked with rtx_obj_flags::IN_NOTE.\n+\n+   For calls, this description includes all accesses in\n+   CALL_INSN_FUNCTION_USAGE.  It also include all implicit accesses\n+   to global registers by the target function.  However, it does not\n+   include clobbers performed by the target function; callers that want\n+   this information should instead use the function_abi interface.  */\n+\n+void\n+rtx_properties::try_to_add_insn (const rtx_insn *insn, bool include_notes)\n+{\n+  if (CALL_P (insn))\n+    {\n+      /* Adding the global registers first removes a situation in which\n+\t a fixed-form clobber of register R could come before a real set\n+\t of register R.  */\n+      if (!hard_reg_set_empty_p (global_reg_set))\n+\t{\n+\t  unsigned int flags = (rtx_obj_flags::IS_READ\n+\t\t\t\t| rtx_obj_flags::IS_WRITE);\n+\t  for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n+\t    if (global_regs[regno] && ref_iter != ref_end)\n+\t      *ref_iter++ = rtx_obj_reference (regno, flags,\n+\t\t\t\t\t       reg_raw_mode[regno], 0);\n+\t}\n+      if (ref_iter != ref_end && !RTL_CONST_CALL_P (insn))\n+\t{\n+\t  auto mem_flags = rtx_obj_flags::IS_READ;\n+\t  if (!RTL_PURE_CALL_P (insn))\n+\t    mem_flags |= rtx_obj_flags::IS_WRITE;\n+\t  *ref_iter++ = rtx_obj_reference (MEM_REGNO, mem_flags, BLKmode);\n+\t}\n+      try_to_add_pattern (PATTERN (insn));\n+      for (rtx link = CALL_INSN_FUNCTION_USAGE (insn); link;\n+\t   link = XEXP (link, 1))\n+\t{\n+\t  rtx x = XEXP (link, 0);\n+\t  if (GET_CODE (x) == CLOBBER)\n+\t    try_to_add_dest (XEXP (x, 0), rtx_obj_flags::IS_CLOBBER);\n+\t  else if (GET_CODE (x) == USE)\n+\t    try_to_add_src (XEXP (x, 0));\n+\t}\n+    }\n+  else\n+    try_to_add_pattern (PATTERN (insn));\n+\n+  if (include_notes)\n+    for (rtx note = REG_NOTES (insn); note; note = XEXP (note, 1))\n+      if (REG_NOTE_KIND (note) == REG_EQUAL\n+\t  || REG_NOTE_KIND (note) == REG_EQUIV)\n+\ttry_to_add_note (XEXP (note, 0));\n+}\n+\n+/* Grow the storage by a bit while keeping the contents of the first\n+   START elements.  */\n+\n+void\n+vec_rtx_properties_base::grow (ptrdiff_t start)\n+{\n+  /* The same heuristic that vec uses.  */\n+  ptrdiff_t new_elems = (ref_end - ref_begin) * 3 / 2;\n+  if (ref_begin == m_storage)\n+    {\n+      ref_begin = XNEWVEC (rtx_obj_reference, new_elems);\n+      if (start)\n+\tmemcpy (ref_begin, m_storage, start * sizeof (rtx_obj_reference));\n+    }\n+  else\n+    ref_begin = reinterpret_cast<rtx_obj_reference *>\n+      (xrealloc (ref_begin, new_elems * sizeof (rtx_obj_reference)));\n+  ref_iter = ref_begin + start;\n+  ref_end = ref_begin + new_elems;\n+}\n \f\n /* Return nonzero if X's old contents don't survive after INSN.\n    This will be true if X is (cc0) or if X is a register and"}, {"sha": "322761b8cc04db7f9cae37813f0222e64a50b049", "filename": "gcc/rtlanal.h", "status": "added", "additions": 334, "deletions": 0, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9/gcc%2Frtlanal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9/gcc%2Frtlanal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.h?ref=04ee46ed1c06cbbffcd8eb0626b4ab6c3a5082d9", "patch": "@@ -0,0 +1,334 @@\n+/* Analyze RTL for GNU compiler.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* Note that for historical reasons, many rtlanal.c functions are\n+   declared in rtl.h rather than here.  */\n+\n+#ifndef GCC_RTLANAL_H\n+#define GCC_RTLANAL_H\n+\n+/* A dummy register value that represents the whole of variable memory.\n+   Using ~0U means that arrays that track both registers and memory can\n+   be indexed by regno + 1.  */\n+const unsigned int MEM_REGNO = ~0U;\n+\n+/* Bitmasks of flags describing an rtx_obj_reference.  See the accessors\n+   in the class for details.  */\n+namespace rtx_obj_flags\n+{\n+  const uint16_t IS_READ = 1U << 0;\n+  const uint16_t IS_WRITE = 1U << 1;\n+  const uint16_t IS_CLOBBER = 1U << 2;\n+  const uint16_t IS_PRE_POST_MODIFY = 1U << 3;\n+  const uint16_t IS_MULTIREG = 1U << 4;\n+  const uint16_t IN_MEM_LOAD = 1U << 5;\n+  const uint16_t IN_MEM_STORE = 1U << 6;\n+  const uint16_t IN_SUBREG = 1U << 7;\n+  const uint16_t IN_NOTE = 1U << 8;\n+\n+  /* Flags that apply to all subrtxes of the rtx they were originally\n+     added for.  */\n+  static const uint16_t STICKY_FLAGS = IN_NOTE;\n+}\n+\n+/* Contains information about a reference to a register or variable memory.  */\n+class rtx_obj_reference\n+{\n+public:\n+  rtx_obj_reference () = default;\n+  rtx_obj_reference (unsigned int regno, uint16_t flags,\n+\t\t     machine_mode mode, unsigned int multireg_offset = 0);\n+\n+  bool is_reg () const { return regno != MEM_REGNO; }\n+  bool is_mem () const { return regno == MEM_REGNO; }\n+\n+  /* True if the reference is a read or a write respectively.\n+     Both flags are set in a read-modify-write context, such as\n+     for read_modify_subreg_p.  */\n+  bool is_read () const { return flags & rtx_obj_flags::IS_READ; }\n+  bool is_write () const { return flags & rtx_obj_flags::IS_WRITE; }\n+\n+  /* True if IS_WRITE and if the write is a clobber rather than a set.  */\n+  bool is_clobber () const { return flags & rtx_obj_flags::IS_CLOBBER; }\n+\n+  /* True if the reference is updated by an RTX_AUTOINC.  Both IS_READ\n+     and IS_WRITE are also true if so.  */\n+  bool is_pre_post_modify () const\n+  {\n+    return flags & rtx_obj_flags::IS_PRE_POST_MODIFY;\n+  }\n+\n+  /* True if the register is part of a multi-register hard REG.  */\n+  bool is_multireg () const { return flags & rtx_obj_flags::IS_MULTIREG; }\n+\n+  /* True if the reference occurs in the address of a load MEM.  */\n+  bool in_mem_load () const { return flags & rtx_obj_flags::IN_MEM_LOAD; }\n+\n+  /* True if the reference occurs in the address of a store MEM.  */\n+  bool in_mem_store () const { return flags & rtx_obj_flags::IN_MEM_STORE; }\n+\n+  /* True if the reference occurs in any kind of MEM address.  */\n+  bool in_address () const { return in_mem_load () || in_mem_store (); }\n+\n+  /* True if the reference occurs in a SUBREG.  */\n+  bool in_subreg () const { return flags & rtx_obj_flags::IN_SUBREG; }\n+\n+  /* True if the reference occurs in a REG_EQUAL or REG_EQUIV note.  */\n+  bool in_note () const { return flags & rtx_obj_flags::IN_NOTE; }\n+\n+  /* The referenced register, or MEM_REGNO for variable memory.  */\n+  unsigned int regno;\n+\n+  /* A bitmask of rtx_obj_flags.  */\n+  unsigned int flags : 16;\n+\n+  /* The mode of the reference.  If IS_MULTIREG, this is the mode of\n+     REGNO - MULTIREG_OFFSET.  */\n+  machine_mode mode : 8;\n+\n+  /* If IS_MULTIREG, the offset of REGNO from the start of the register.  */\n+  unsigned int multireg_offset : 8;\n+};\n+\n+/* Construct a reference with the given fields.  */\n+\n+inline rtx_obj_reference::rtx_obj_reference (unsigned int regno, uint16_t flags,\n+\t\t\t\t\t     machine_mode mode,\n+\t\t\t\t\t     unsigned int multireg_offset)\n+  : regno (regno),\n+    flags (flags),\n+    mode (mode),\n+    multireg_offset (multireg_offset)\n+{\n+}\n+\n+/* Contains information about an rtx or an instruction, including a\n+   list of rtx_obj_references.  The storage backing the list needs\n+   to be filled in by assigning to REF_BEGIN and REF_END.  */\n+\n+class rtx_properties\n+{\n+public:\n+  rtx_properties ();\n+\n+  void try_to_add_reg (const_rtx x, unsigned int flags = 0);\n+  void try_to_add_dest (const_rtx x, unsigned int flags = 0);\n+  void try_to_add_src (const_rtx x, unsigned int flags = 0);\n+  void try_to_add_pattern (const_rtx pat);\n+  void try_to_add_note (const_rtx x);\n+  void try_to_add_insn (const rtx_insn *insn, bool include_notes);\n+\n+  iterator_range<rtx_obj_reference *> refs () const;\n+\n+  /* Return the number of rtx_obj_references that have been recorded.  */\n+  size_t num_refs () const { return ref_iter - ref_begin; }\n+\n+  bool has_side_effects () const;\n+\n+  /* [REF_BEGIN, REF_END) is the maximum extent of the memory available\n+     for recording references.  REG_ITER is the first unused entry.  */\n+  rtx_obj_reference *ref_begin;\n+  rtx_obj_reference *ref_iter;\n+  rtx_obj_reference *ref_end;\n+\n+  /* True if the rtx includes an asm.  */\n+  unsigned int has_asm : 1;\n+\n+  /* True if the rtx includes a call.  */\n+  unsigned int has_call : 1;\n+\n+  /* True if the rtx includes an RTX_AUTOINC expression.  */\n+  unsigned int has_pre_post_modify : 1;\n+\n+  /* True if the rtx contains volatile references, in the sense of\n+     volatile_refs_p.  */\n+  unsigned int has_volatile_refs : 1;\n+\n+  /* For future expansion.  */\n+  unsigned int spare : 28;\n+};\n+\n+inline rtx_properties::rtx_properties ()\n+  : ref_begin (nullptr),\n+    ref_iter (nullptr),\n+    ref_end (nullptr),\n+    has_asm (false),\n+    has_call (false),\n+    has_pre_post_modify (false),\n+    has_volatile_refs (false),\n+    spare (0)\n+{\n+}\n+\n+/* Like add_src, but treat X has being part of a REG_EQUAL or\n+   REG_EQUIV note.  */\n+\n+inline void\n+rtx_properties::try_to_add_note (const_rtx x)\n+{\n+  try_to_add_src (x, rtx_obj_flags::IN_NOTE);\n+}\n+\n+/* Return true if the rtx has side effects, in the sense of\n+   side_effects_p (except for side_effects_p's special handling\n+   of combine.c clobbers).  */\n+\n+inline bool\n+rtx_properties::has_side_effects () const\n+{\n+  return has_volatile_refs || has_pre_post_modify || has_call;\n+}\n+\n+/* Return an iterator range for all the references, suitable for\n+   range-based for loops.  */\n+\n+inline iterator_range<rtx_obj_reference *>\n+rtx_properties::refs () const\n+{\n+  return { ref_begin, ref_iter };\n+}\n+\n+/* BASE is derived from rtx_properties and provides backing storage\n+   for REF_BEGIN.  It has a grow () method that increases the amount\n+   of memory available if the initial allocation was too small.  */\n+\n+template<typename Base>\n+class growing_rtx_properties : public Base\n+{\n+public:\n+  template<typename... Args>\n+  growing_rtx_properties (Args...);\n+\n+  template<typename AddFn>\n+  void repeat (AddFn add);\n+\n+  /* Wrappers around the try_to_* functions that always succeed.  */\n+  void add_dest (const_rtx x, unsigned int flags = 0);\n+  void add_src (const_rtx x, unsigned int flags = 0);\n+  void add_pattern (const_rtx pat);\n+  void add_note (const_rtx x);\n+  void add_insn (const rtx_insn *insn, bool include_notes);\n+};\n+\n+template<typename Base>\n+template<typename... Args>\n+growing_rtx_properties<Base>::growing_rtx_properties (Args... args)\n+  : Base (std::forward<Args> (args)...)\n+{\n+}\n+\n+/* Perform ADD until there is enough room to hold the result.  */\n+\n+template<typename Base>\n+template<typename AddFn>\n+inline void\n+growing_rtx_properties<Base>::repeat (AddFn add)\n+{\n+  ptrdiff_t count = this->num_refs ();\n+  for (;;)\n+    {\n+      add ();\n+      /* This retries if the storage happened to be exactly the right size,\n+\t but that's expected to be a rare case and so isn't worth\n+\t optimizing for.  */\n+      if (__builtin_expect (this->ref_iter != this->ref_end, 1))\n+\tbreak;\n+      this->grow (count);\n+    }\n+}\n+\n+template<typename Base>\n+inline void\n+growing_rtx_properties<Base>::add_dest (const_rtx x, unsigned int flags)\n+{\n+  repeat ([&]() { this->try_to_add_dest (x, flags); });\n+}\n+\n+template<typename Base>\n+inline void\n+growing_rtx_properties<Base>::add_src (const_rtx x, unsigned int flags)\n+{\n+  repeat ([&]() { this->try_to_add_src (x, flags); });\n+}\n+\n+template<typename Base>\n+inline void\n+growing_rtx_properties<Base>::add_pattern (const_rtx pat)\n+{\n+  repeat ([&]() { this->try_to_add_pattern (pat); });\n+}\n+\n+template<typename Base>\n+inline void\n+growing_rtx_properties<Base>::add_note (const_rtx x)\n+{\n+  repeat ([&]() { this->try_to_add_note (x); });\n+}\n+\n+template<typename Base>\n+inline void\n+growing_rtx_properties<Base>::add_insn (const rtx_insn *insn, bool include_notes)\n+{\n+  repeat ([&]() { this->try_to_add_insn (insn, include_notes); });\n+}\n+\n+/* A base class for vec_rtx_properties; see there for details.  */\n+\n+class vec_rtx_properties_base : public rtx_properties\n+{\n+  static const size_t SIZE = 32;\n+\n+public:\n+  vec_rtx_properties_base ();\n+  ~vec_rtx_properties_base ();\n+\n+protected:\n+  void grow (ptrdiff_t);\n+\n+private:\n+  rtx_obj_reference m_storage[SIZE];\n+};\n+\n+inline vec_rtx_properties_base::vec_rtx_properties_base ()\n+{\n+  ref_begin = ref_iter = m_storage;\n+  ref_end = m_storage + SIZE;\n+}\n+\n+inline vec_rtx_properties_base::~vec_rtx_properties_base ()\n+{\n+  if (__builtin_expect (ref_begin != m_storage, 0))\n+    free (ref_begin);\n+}\n+\n+/* A rtx_properties that stores its references in a temporary array.\n+   Like auto_vec, the array is initially on the stack, but can switch\n+   to the heap if necessary.\n+\n+   The reason for implementing this as a derived class is that the\n+   default on-stack size should be enough for the vast majority of\n+   expressions and instructions.  It's therefore not worth paying\n+   the cost of conditionally calling grow code at every site that\n+   records a new reference.  Instead, the rtx_properties code can use\n+   trivial iterator updates for the common case, and in the rare case\n+   that the vector needs to be resized, we can pay the cost of\n+   collecting the references a second time.  */\n+using vec_rtx_properties = growing_rtx_properties<vec_rtx_properties_base>;\n+\n+#endif"}]}