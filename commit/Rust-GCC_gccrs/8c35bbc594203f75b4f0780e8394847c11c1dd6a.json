{"sha": "8c35bbc594203f75b4f0780e8394847c11c1dd6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMzNWJiYzU5NDIwM2Y3NWI0ZjA3ODBlODM5NDg0N2MxMWMxZGQ2YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T12:05:12Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-02-22T12:05:12Z"}, "message": "(REAL_WORDS_BIG_ENDIAN): New macro.\n\n(REAL_WORDS_BIG_ENDIAN): New macro.  Define as either\nFLOAT_WORDS_BIG_ENDIAN or HOST_FLOAT_WORDS_BIG_ENDIAN.  Use it instead\nof FLOAT_WORDS_BIG_ENDIAN.\n(m16m, edivm, emulm): Change `short' to `EMUSHORT', and `long' to `EMULONG'.\nClean up comments.\n\nFrom-SVN: r9027", "tree": {"sha": "6c2933d7f975e1ab3ccd11e929cb5000deb17ac4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c2933d7f975e1ab3ccd11e929cb5000deb17ac4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c35bbc594203f75b4f0780e8394847c11c1dd6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c35bbc594203f75b4f0780e8394847c11c1dd6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c35bbc594203f75b4f0780e8394847c11c1dd6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c35bbc594203f75b4f0780e8394847c11c1dd6a/comments", "author": null, "committer": null, "parents": [{"sha": "0ed5f250a191a06248db5bd198e4d74f59a024ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ed5f250a191a06248db5bd198e4d74f59a024ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ed5f250a191a06248db5bd198e4d74f59a024ed"}], "stats": {"total": 504, "additions": 254, "deletions": 250}, "files": [{"sha": "29deee338e73ec31e1d10d889d23dbabc59ac894", "filename": "gcc/real.c", "status": "modified", "additions": 254, "deletions": 250, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c35bbc594203f75b4f0780e8394847c11c1dd6a/gcc%2Freal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c35bbc594203f75b4f0780e8394847c11c1dd6a/gcc%2Freal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.c?ref=8c35bbc594203f75b4f0780e8394847c11c1dd6a", "patch": "@@ -44,31 +44,27 @@ The emulator defaults to the host's floating point format so that\n its decimal conversion functions can be used if desired (see\n real.h).\n \n-The first part of this file interfaces gcc to ieee.c, which is a\n-floating point arithmetic suite that was not written with gcc in\n-mind.  The interface is followed by ieee.c itself and related\n-items. Avoid changing ieee.c unless you have suitable test\n-programs available.  A special version of the PARANOIA floating\n-point arithmetic tester, modified for this purpose, can be found\n-on usc.edu : /pub/C-numanal/ieeetest.zoo.  Some tutorial\n-information on ieee.c is given in my book: S. L. Moshier,\n-_Methods and Programs for Mathematical Functions_, Prentice-Hall\n-or Simon & Schuster Int'l, 1989.  A library of XFmode elementary\n-transcendental functions can be obtained by ftp from\n-research.att.com: netlib/cephes/ldouble.shar.Z  */\n+The first part of this file interfaces gcc to a floating point\n+arithmetic suite that was not written with gcc in mind.  Avoid\n+changing the low-level arithmetic routines unless you have suitable\n+test programs available.  A special version of the PARANOIA floating\n+point arithmetic tester, modified for this purpose, can be found on\n+usc.edu: /pub/C-numanal/ieeetest.zoo.  Other tests, and libraries of\n+XFmode and TFmode transcendental functions, can be obtained by ftp from\n+netlib.att.com: netlib/cephes.   */\n \f\n /* Type of computer arithmetic.\n    Only one of DEC, IBM, IEEE, or UNK should get defined.\n \n-   `IEEE', when FLOAT_WORDS_BIG_ENDIAN is non-zero, refers generically\n+   `IEEE', when REAL_WORDS_BIG_ENDIAN is non-zero, refers generically\n    to big-endian IEEE floating-point data structure.  This definition\n    should work in SFmode `float' type and DFmode `double' type on\n    virtually all big-endian IEEE machines.  If LONG_DOUBLE_TYPE_SIZE\n    has been defined to be 96, then IEEE also invokes the particular\n    XFmode (`long double' type) data structure used by the Motorola\n    680x0 series processors.\n \n-   `IEEE', when FLOAT_WORDS_BIG_ENDIAN is zero, refers generally to\n+   `IEEE', when REAL_WORDS_BIG_ENDIAN is zero, refers generally to\n    little-endian IEEE machines. In this case, if LONG_DOUBLE_TYPE_SIZE\n    has been defined to be 96, then IEEE also invokes the particular\n    XFmode `long double' data structure used by the Intel 80x86 series\n@@ -130,6 +126,8 @@ unknown arithmetic type\n #endif /* not IBM */\n #endif /* not VAX */\n \n+#define REAL_WORDS_BIG_ENDIAN FLOAT_WORDS_BIG_ENDIAN\n+\n #else\n /* REAL_ARITHMETIC not defined means that the *host's* data\n    structure will be used.  It may differ by endian-ness from the\n@@ -153,6 +151,8 @@ unknown arithmetic type\n #endif /* not IBM */\n #endif /* not VAX */\n \n+#define REAL_WORDS_BIG_ENDIAN HOST_FLOAT_WORDS_BIG_ENDIAN\n+\n #endif /* REAL_ARITHMETIC not defined */\n \n /* Define INFINITY for support of infinity.\n@@ -256,7 +256,7 @@ unknown arithmetic type\n \n #define GET_REAL(r,e)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n-     if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\\\n+     if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)\t\\\n        e53toe ((unsigned EMUSHORT*) (r), (e));\t\t\t\\\n      else\t\t\t\t\t\t\t\\\n        {\t\t\t\t\t\t\t\\\n@@ -271,7 +271,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n #define PUT_REAL(e,r)\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\\\n-     if (HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN)\t\\\n+     if (HOST_FLOAT_WORDS_BIG_ENDIAN == REAL_WORDS_BIG_ENDIAN)\t\\\n        etoe53 ((e), (unsigned EMUSHORT *) (r));\t\t\t\\\n      else\t\t\t\t\t\t\t\\\n        {\t\t\t\t\t\t\t\\\n@@ -433,7 +433,7 @@ endian (e, x, mode)\n {\n   unsigned long th, t;\n \n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       switch (mode)\n \t{\n@@ -894,7 +894,6 @@ target_isinf (x)\n #endif\n }\n \n-\n /* Check whether a REAL_VALUE_TYPE item is a NaN. */\n \n int\n@@ -993,10 +992,19 @@ debug_real (r)\n }  \n \n \f\n-/* Target values are arrays of host longs. A long is guaranteed\n-   to be at least 32 bits wide. */\n+/* The following routines convert REAL_VALUE_TYPE to the various floating\n+   point formats that are meaningful to supported computers.\n+\n+   The results are returned in 32-bit pieces, each piece stored in a `long'.  \n+   This is so they can be printed by statements like\n+ \n+      fprintf (file, \"%lx, %lx\", L[0],  L[1]);\n+\n+   that will work on both narrow- and wide-word host computers.  */\n \n-/* 128-bit long double */\n+/* Convert R to a 128-bit long double precision value.  The output array L\n+   contains four 32-bit pieces of the result, in the order they would appear\n+   in memory.  */\n \n void \n etartdouble (r, l)\n@@ -1010,7 +1018,9 @@ etartdouble (r, l)\n   endian (e, l, TFmode);\n }\n \n-/* 80-bit long double */\n+/* Convert R to a double extended precision value.  The output array L\n+   contains three 32-bit pieces of the result, in the order they would\n+   appear in memory.  */\n \n void \n etarldouble (r, l)\n@@ -1024,6 +1034,9 @@ etarldouble (r, l)\n   endian (e, l, XFmode);\n }\n \n+/* Convert R to a double precision value.  The output array L contains two\n+   32-bit pieces of the result, in the order they would appear in memory.  */\n+\n void \n etardouble (r, l)\n      REAL_VALUE_TYPE r;\n@@ -1036,6 +1049,9 @@ etardouble (r, l)\n   endian (e, l, DFmode);\n }\n \n+/* Convert R to a single precision float value stored in the least-significant\n+   bits of a `long'.  */\n+\n long\n etarsingle (r)\n      REAL_VALUE_TYPE r;\n@@ -1049,6 +1065,11 @@ etarsingle (r)\n   return ((long) l);\n }\n \n+/* Convert X to a decimal ASCII string S for output to an assembly\n+   language file.  Note, there is no standard way to spell infinity or\n+   a NaN, so these values may require special treatment in the tm.h\n+   macros.  */\n+\n void\n ereal_to_decimal (x, s)\n      REAL_VALUE_TYPE x;\n@@ -1060,6 +1081,9 @@ ereal_to_decimal (x, s)\n   etoasc (e, s, 20);\n }\n \n+/* Compare X and Y.  Return 1 if X > Y, 0 if X == Y, -1 if X < Y,\n+   or -2 if either is a NaN.   */\n+\n int\n ereal_cmp (x, y)\n      REAL_VALUE_TYPE x, y;\n@@ -1071,6 +1095,8 @@ ereal_cmp (x, y)\n   return (ecmp (ex, ey));\n }\n \n+/*  Return 1 if the sign bit of X is set, else return 0.  */\n+\n int\n ereal_isneg (x)\n      REAL_VALUE_TYPE x;\n@@ -1090,7 +1116,7 @@ ereal_isneg (x)\n   short integers.  The arguments of the routines are pointers to\n   the arrays.\n \n-  External e type data structure, simulates Intel 8087 chip\n+  External e type data structure, similar to Intel 8087 chip\n   temporary real format but possibly with a larger significand:\n \n \tNE-1 significand words\t(least significant word first,\n@@ -1099,7 +1125,7 @@ ereal_isneg (x)\n \t\t\t\ttop bit is the sign)\n \n \n-  Internal data structure of a number (a \"word\" is 16 bits):\n+  Internal exploded e-type data structure of a number (a \"word\" is 16 bits):\n \n   ei[0]\tsign word\t(0 for positive, 0xffff for negative)\n   ei[1]\tbiased exponent\t(value = EXONE for the number 1.0)\n@@ -1112,7 +1138,7 @@ ereal_isneg (x)\n  \n  \n  \n- \t\tRoutines for external format numbers\n+ \t\tRoutines for external format e-type numbers\n  \n  \tasctoe (string, e)\tASCII string to extended double e type\n  \tasctoe64 (string, &d)\tASCII string to long double\n@@ -1156,7 +1182,7 @@ ereal_isneg (x)\n         eisnan (e)              1 if e is a NaN\n  \n \n- \t\tRoutines for internal format numbers\n+ \t\tRoutines for internal format exploded e-type numbers\n  \n  \teaddm (ai, bi)\t\tadd significands, bi = bi + ai\n  \tecleaz (ei)\t\tei = 0\n@@ -1217,11 +1243,11 @@ ereal_isneg (x)\n  \n   For computers, such as IBM PC, that follow the IEEE\n   Standard for Binary Floating Point Arithmetic (ANSI/IEEE\n-  Std 754-1985), the symbol IBMPC or MIEEE should be defined.\n+  Std 754-1985), the symbol IEEE should be defined.\n   These numbers have 53-bit significands.  In this mode, constants\n   are provided as arrays of hexadecimal 16 bit integers.\n-  [This has been changed to instead check the preprocessor macros IEEE\n-  and FLOAT_WORDS_BIG_ENDIAN].\n+  The endian-ness of generated values is controlled by\n+  REAL_WORDS_BIG_ENDIAN.\n  \n   To accommodate other types of computer arithmetic, all\n   constants are also provided in a normal decimal radix\n@@ -1320,15 +1346,13 @@ unsigned EMUSHORT epi[NE] =\n  {0xc4c6, 0xc234, 0020550, 0155242, 0144417, 0040000,};\n #endif\n \n-\n-\n /* Control register for rounding precision.\n    This can be set to 113 (if NE=10), 80 (if NE=6), 64, 56, 53, or 24 bits.  */\n \n int rndprc = NBITS;\n extern int rndprc;\n \n-/*  Clear out entire external format number.  */\n+/*  Clear out entire e-type number X.  */\n \n static void \n eclear (x)\n@@ -1340,9 +1364,7 @@ eclear (x)\n     *x++ = 0;\n }\n \n-\n-\n-/* Move external format number from a to b.  */\n+/* Move e-type number from A to B.  */\n \n static void \n emov (a, b)\n@@ -1355,7 +1377,7 @@ emov (a, b)\n }\n \n \n-/* Absolute value of external format number.  */\n+/* Absolute value of e-type X.  */\n \n static void \n eabs (x)\n@@ -1365,7 +1387,7 @@ eabs (x)\n   x[NE - 1] &= 0x7fff;\t\t\n }\n \n-/* Negate external format number.  */\n+/* Negate the e-type number X.  */\n \n static void \n eneg (x)\n@@ -1375,9 +1397,7 @@ eneg (x)\n   x[NE - 1] ^= 0x8000;\t\t/* Toggle the sign bit */\n }\n \n-\n-\n-/* Return 1 if sign bit of external format number is nonzero, else zero.  */\n+/* Return 1 if sign bit of e-type number X is nonzero, else zero.  */\n \n static int \n eisneg (x)\n@@ -1390,8 +1410,7 @@ eisneg (x)\n     return (0);\n }\n \n-\n-/* Return 1 if external format number is infinity, else return zero.  */\n+/* Return 1 if e-type number X is infinity, else return zero.  */\n \n static int \n eisinf (x)\n@@ -1408,7 +1427,6 @@ eisinf (x)\n     return (0);\n }\n \n-\n /* Check if e-type number is not a number.  The bit pattern is one that we\n    defined, so we know for sure how to detect it.  */\n \n@@ -1433,7 +1451,7 @@ eisnan (x)\n   return (0);\n }\n \n-/*  Fill external format number with infinity pattern (IEEE)\n+/*  Fill e-type number X with infinity pattern (IEEE)\n     or largest possible number (non-IEEE). */\n \n static void \n@@ -1475,7 +1493,6 @@ einfin (x)\n #endif\n }\n \n-\n /* Output an e-type NaN.\n    This generates Intel's quiet NaN pattern for extended real.\n    The exponent is 7fff, the leading mantissa word is c000.  */\n@@ -1493,8 +1510,7 @@ enan (x, sign)\n   *x = (sign << 15) | 0x7fff;\n }\n \n-\n-/* Move in external format number, converting it to internal format.  */\n+/* Move in an e-type number A, converting it to exploded e-type B.  */\n \n static void \n emovi (a, b)\n@@ -1541,8 +1557,7 @@ emovi (a, b)\n   *q = 0;\n }\n \n-\n-/* Move internal format number out, converting it to external format.  */\n+/* Move out exploded e-type number A, converting it to e type B.  */\n \n static void \n emovo (a, b)\n@@ -1581,7 +1596,7 @@ emovo (a, b)\n     *q-- = *p++;\n }\n \n-/* Clear out internal format number.  */\n+/* Clear out exploded e-type number XI.  */\n \n static void \n ecleaz (xi)\n@@ -1593,8 +1608,7 @@ ecleaz (xi)\n     *xi++ = 0;\n }\n \n-\n-/* Same, but don't touch the sign. */\n+/* Clear out exploded e-type XI, but don't touch the sign. */\n \n static void \n ecleazs (xi)\n@@ -1607,9 +1621,7 @@ ecleazs (xi)\n     *xi++ = 0;\n }\n \n-\n-\n-/* Move internal format number from a to b.  */\n+/* Move exploded e-type number from A to B.  */\n \n static void \n emovz (a, b)\n@@ -1623,7 +1635,7 @@ emovz (a, b)\n   *b = 0;\n }\n \n-/* Generate internal format NaN.\n+/* Generate exploded e-type NaN.\n    The explicit pattern for this is maximum exponent and\n    top two significant bits set.  */\n \n@@ -1637,7 +1649,7 @@ einan (x)\n   x[M + 1] = 0xc000;\n }\n \n-/* Return nonzero if internal format number is a NaN. */\n+/* Return nonzero if exploded e-type X is a NaN. */\n \n static int \n eiisnan (x)\n@@ -1656,7 +1668,7 @@ eiisnan (x)\n   return (0);\n }\n \n-/* Return nonzero if sign of internal format number is nonzero.  */\n+/* Return nonzero if sign of exploded e-type X is nonzero.  */\n \n static int \n eiisneg (x)\n@@ -1666,7 +1678,7 @@ eiisneg (x)\n   return x[0] != 0;\n }\n \n-/* Fill internal format number with infinity pattern.\n+/* Fill exploded e-type X with infinity pattern.\n    This has maximum exponent and significand all zeros.  */\n \n static void\n@@ -1678,7 +1690,7 @@ eiinfin (x)\n   x[E] = 0x7fff;\n }\n \n-/* Return nonzero if internal format number is infinite. */\n+/* Return nonzero if exploded e-type X is infinite. */\n \n static int \n eiisinf (x)\n@@ -1695,7 +1707,7 @@ eiisinf (x)\n }\n \n \n-/* Compare significands of numbers in internal format.\n+/* Compare significands of numbers in internal exploded e-type format.\n    Guard words are included in the comparison.\n \n    Returns\t+1 if a > b\n@@ -1724,8 +1736,7 @@ ecmpm (a, b)\n     return (-1);\n }\n \n-\n-/* Shift significand down by 1 bit.  */\n+/* Shift significand of exploded e-type X down by 1 bit.  */\n \n static void \n eshdn1 (x)\n@@ -1749,9 +1760,7 @@ eshdn1 (x)\n     }\n }\n \n-\n-\n-/* Shift significand up by 1 bit.  */\n+/* Shift significand of exploded e-type X up by 1 bit.  */\n \n static void \n eshup1 (x)\n@@ -1776,7 +1785,7 @@ eshup1 (x)\n }\n \n \n-/* Shift significand down by 8 bits.  */\n+/* Shift significand of exploded e-type X down by 8 bits.  */\n \n static void \n eshdn8 (x)\n@@ -1797,7 +1806,7 @@ eshdn8 (x)\n     }\n }\n \n-/* Shift significand up by 8 bits.  */\n+/* Shift significand of exploded e-type X up by 8 bits.  */\n \n static void \n eshup8 (x)\n@@ -1819,7 +1828,7 @@ eshup8 (x)\n     }\n }\n \n-/* Shift significand up by 16 bits.  */\n+/* Shift significand of exploded e-type X up by 16 bits.  */\n \n static void \n eshup6 (x)\n@@ -1837,7 +1846,7 @@ eshup6 (x)\n   *p = 0;\n }\n \n-/* Shift significand down by 16 bits.  */\n+/* Shift significand of exploded e-type X down by 16 bits.  */\n \n static void \n eshdn6 (x)\n@@ -1854,8 +1863,8 @@ eshdn6 (x)\n \n   *(--p) = 0;\n }\n-\f\n-/* Add significands.  x + y replaces y.  */\n+\n+/* Add significands of exploded e-type X and Y.  X + Y replaces Y.  */\n \n static void \n eaddm (x, y)\n@@ -1881,7 +1890,7 @@ eaddm (x, y)\n     }\n }\n \n-/* Subtract significands.  y - x replaces y.  */\n+/* Subtract significands of exploded e-type X and Y.  Y - X replaces Y.  */\n \n static void \n esubm (x, y)\n@@ -2061,22 +2070,21 @@ emulm (a, b)\n \n #else\n \n-/* Radix 65536 versions of multiply and divide  */\n-\n+/* Radix 65536 versions of multiply and divide.  */\n \n-/* Multiply significand of e-type number b\n-   by 16-bit quantity a, e-type result to c. */\n+/* Multiply significand of e-type number B\n+   by 16-bit quantity A, return e-type result to C. */\n \n static void\n m16m (a, b, c)\n      unsigned int a;\n-     unsigned short b[], c[];\n+     unsigned EMUSHORT b[], c[];\n {\n-  register unsigned short *pp;\n-  register unsigned long carry;\n-  unsigned short *ps;\n-  unsigned short p[NI];\n-  unsigned long aa, m;\n+  register unsigned EMUSHORT *pp;\n+  register unsigned EMULONG carry;\n+  unsigned EMUSHORT *ps;\n+  unsigned EMUSHORT p[NI];\n+  unsigned EMULONG aa, m;\n   int i;\n \n   aa = a;\n@@ -2095,31 +2103,31 @@ m16m (a, b, c)\n \t}\n       else\n \t{\n-\t  m = (unsigned long) aa * *ps--;\n+\t  m = (unsigned EMULONG) aa * *ps--;\n \t  carry = (m & 0xffff) + *pp;\n-\t  *pp-- = (unsigned short)carry;\n+\t  *pp-- = (unsigned EMUSHORT)carry;\n \t  carry = (carry >> 16) + (m >> 16) + *pp;\n-\t  *pp = (unsigned short)carry;\n+\t  *pp = (unsigned EMUSHORT)carry;\n \t  *(pp-1) = carry >> 16;\n \t}\n     }\n   for (i=M; i<NI; i++)\n     c[i] = p[i];\n }\n \n-\n-/* Divide significands. Neither the numerator nor the denominator\n-   is permitted to have its high guard word nonzero.  */\n+/* Divide significands of exploded e-types NUM / DEN.  Neither the\n+   numerator NUM nor the denominator DEN is permitted to have its high guard\n+   word nonzero.  */\n \n static int\n edivm (den, num)\n-     unsigned short den[], num[];\n+     unsigned EMUSHORT den[], num[];\n {\n   int i;\n-  register unsigned short *p;\n-  unsigned long tnum;\n-  unsigned short j, tdenm, tquot;\n-  unsigned short tprod[NI+1];\n+  register unsigned EMUSHORT *p;\n+  unsigned EMULONG tnum;\n+  unsigned EMUSHORT j, tdenm, tquot;\n+  unsigned EMUSHORT tprod[NI+1];\n \n   p = &equot[0];\n   *p++ = num[0];\n@@ -2134,7 +2142,7 @@ edivm (den, num)\n   for (i=M; i<NI; i++)\n     {\n       /* Find trial quotient digit (the radix is 65536). */\n-      tnum = (((unsigned long) num[M]) << 16) + num[M+1];\n+      tnum = (((unsigned EMULONG) num[M]) << 16) + num[M+1];\n \n       /* Do not execute the divide instruction if it will overflow. */\n       if ((tdenm * 0xffffL) < tnum)\n@@ -2174,16 +2182,15 @@ edivm (den, num)\n   return ((int)j);\n }\n \n+/* Multiply significands of exploded e-type A and B, result in B.  */\n \n-\n-/* Multiply significands */\n static int\n emulm (a, b)\n-     unsigned short a[], b[];\n+     unsigned EMUSHORT a[], b[];\n {\n-  unsigned short *p, *q;\n-  unsigned short pprod[NI];\n-  unsigned short j;\n+  unsigned EMUSHORT *p, *q;\n+  unsigned EMUSHORT pprod[NI];\n+  unsigned EMUSHORT j;\n   int i;\n \n   equot[0] = b[0];\n@@ -2220,19 +2227,19 @@ emulm (a, b)\n \n /* Normalize and round off.\n \n-  The internal format number to be rounded is \"s\".\n-  Input \"lost\" indicates whether or not the number is exact.\n-  This is the so-called sticky bit.\n+  The internal format number to be rounded is S.\n+  Input LOST is 0 if the value is exact.  This is the so-called sticky bit.\n  \n-  Input \"subflg\" indicates whether the number was obtained\n-  by a subtraction operation.  In that case if lost is nonzero\n+  Input SUBFLG indicates whether the number was obtained\n+  by a subtraction operation.  In that case if LOST is nonzero\n   then the number is slightly smaller than indicated.\n  \n-  Input \"exp\" is the biased exponent, which may be negative.\n-  the exponent field of \"s\" is ignored but is replaced by\n-  \"exp\" as adjusted by normalization and rounding.\n+  Input EXP is the biased exponent, which may be negative.\n+  the exponent field of S is ignored but is replaced by\n+  EXP as adjusted by normalization and rounding.\n  \n-  Input \"rcntrl\" is the rounding control.\n+  Input RCNTRL is the rounding control.  If it is nonzero, the\n+  returned value will be rounded to RNDPRC bits.\n \n   For future reference:  In order for emdnorm to round off denormal\n    significands at the right point, the input exponent must be\n@@ -2445,9 +2452,7 @@ emdnorm (s, lost, subflg, exp, rcntrl)\n     s[1] = (unsigned EMUSHORT) exp;\n }\n \n-\n-\n-/*  Subtract external format numbers.  */\n+/*  Subtract.  C = B - A, all e type numbers.  */\n \n static int subflg = 0;\n \n@@ -2481,8 +2486,7 @@ esub (a, b, c)\n   eadd1 (a, b, c);\n }\n \n-\n-/* Add.  */\n+/* Add.  C = A + B, all e type. */\n \n static void \n eadd (a, b, c)\n@@ -2515,6 +2519,8 @@ eadd (a, b, c)\n   eadd1 (a, b, c);\n }\n \n+/* Arithmetic common to both addition and subtraction.  */\n+\n static void \n eadd1 (a, b, c)\n      unsigned EMUSHORT *a, *b, *c;\n@@ -2617,9 +2623,7 @@ eadd1 (a, b, c)\n   emovo (bi, c);\n }\n \n-\n-\n-/* Divide.  */\n+/* Divide: C = B/A, all e type.  */\n \n static void \n ediv (a, b, c)\n@@ -2721,9 +2725,7 @@ ediv (a, b, c)\n   emovo (bi, c);\n }\n \n-\n-\n-/* Multiply.  */\n+/* Multiply e-types A and B, return e-type product C.   */\n \n static void \n emul (a, b, c)\n@@ -2813,18 +2815,15 @@ emul (a, b, c)\n   emovo (bi, c);\n }\n \n-\n-\n-\n-/* Convert IEEE double precision to e type.  */\n+/* Convert double precision PE to e-type Y.  */\n \n static void\n e53toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n {\n #ifdef DEC\n \n-  dectoe (pe, y);\t\t/* see etodec.c */\n+  dectoe (pe, y);\n \n #else\n #ifdef IBM\n@@ -2840,7 +2839,7 @@ e53toe (pe, y)\n   e = pe;\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     e += 3;\n   r = *e;\n   yy[0] = 0;\n@@ -2852,7 +2851,7 @@ e53toe (pe, y)\n   if (r == 0x7ff0)\n     {\n #ifdef NANS\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  if (((pe[3] & 0xf) != 0) || (pe[2] != 0)\n \t      || (pe[1] != 0) || (pe[0] != 0))\n@@ -2891,7 +2890,7 @@ e53toe (pe, y)\n   yy[E] = r;\n   p = &yy[M + 1];\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     {\n       *p++ = *(--e);\n       *p++ = *(--e);\n@@ -2918,6 +2917,8 @@ e53toe (pe, y)\n #endif /* not DEC */\n }\n \n+/* Convert double extended precision float PE to e type Y.  */\n+\n static void \n e64toe (pe, y)\n      unsigned EMUSHORT *pe, *y;\n@@ -2943,7 +2944,7 @@ e64toe (pe, y)\n     *p-- = *e++;\n #endif\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     {\n       for (i = 0; i < 5; i++)\n \t*p++ = *e++;\n@@ -2963,7 +2964,7 @@ e64toe (pe, y)\n   if (*p == 0x7fff)\n     {\n #ifdef NANS\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  for (i = 0; i < 4; i++)\n \t    {\n@@ -3001,6 +3002,7 @@ e64toe (pe, y)\n     *q++ = *p++;\n }\n \n+/* Convert 128-bit long double precision float PE to e type Y.  */\n \n static void \n e113toe (pe, y)\n@@ -3015,7 +3017,7 @@ e113toe (pe, y)\n   denorm = 0;\n   ecleaz (yy);\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     e += 7;\n #endif\n   r = *e;\n@@ -3027,7 +3029,7 @@ e113toe (pe, y)\n   if (r == 0x7fff)\n     {\n #ifdef NANS\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  for (i = 0; i < 7; i++)\n \t    {\n@@ -3060,7 +3062,7 @@ e113toe (pe, y)\n   yy[E] = r;\n   p = &yy[M + 1];\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     {\n       for (i = 0; i < 7; i++)\n \t*p++ = *(--e);\n@@ -3085,8 +3087,7 @@ e113toe (pe, y)\n   emovo (yy, y);\n }\n \n-\n-/* Convert IEEE single precision to e type.  */\n+/* Convert single precision float PE to e type Y.  */\n \n static void \n e24toe (pe, y)\n@@ -3106,7 +3107,7 @@ e24toe (pe, y)\n   denorm = 0;\t\t\t/* flag if denormalized number */\n   ecleaz (yy);\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     e += 1;\n #endif\n #ifdef DEC\n@@ -3122,7 +3123,7 @@ e24toe (pe, y)\n   if (r == 0x7f80)\n     {\n #ifdef NANS\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n+      if (REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  if (((pe[0] & 0x7f) != 0) || (pe[1] != 0))\n \t    {\n@@ -3161,7 +3162,7 @@ e24toe (pe, y)\n   *p++ = *(--e);\n #endif\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     *p++ = *(--e);\n   else\n     {\n@@ -3181,6 +3182,7 @@ e24toe (pe, y)\n #endif /* not IBM */\n }\n \n+/* Convert e-type X to IEEE 128-bit long double format E.  */\n \n static void \n etoe113 (x, e)\n@@ -3212,7 +3214,8 @@ etoe113 (x, e)\n   toe113 (xi, e);\n }\n \n-/* Move out internal format to ieee long double */\n+/* Convert exploded e-type X, that has already been rounded to\n+   113-bit precision, to IEEE 128-bit long double format Y.  */\n \n static void \n toe113 (a, b)\n@@ -3229,7 +3232,7 @@ toe113 (a, b)\n     }\n #endif\n   p = a;\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     q = b;\n   else\n     q = b + 7;\t\t\t/* point to output exponent */\n@@ -3241,7 +3244,7 @@ toe113 (a, b)\n     }\n   /* combine sign and exponent */\n   i = *p++;\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       if (i)\n \t*q++ = *p++ | 0x8000;\n@@ -3258,7 +3261,7 @@ toe113 (a, b)\n   /* skip over guard word */\n   ++p;\n   /* move the significand */\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       for (i = 0; i < 7; i++)\n \t*q++ = *p++;\n@@ -3270,6 +3273,8 @@ toe113 (a, b)\n     }\n }\n \n+/* Convert e-type X to IEEE double extended format E.  */\n+\n static void \n etoe64 (x, e)\n      unsigned EMUSHORT *x, *e;\n@@ -3301,8 +3306,8 @@ etoe64 (x, e)\n   toe64 (xi, e);\n }\n \n-\n-/* Move out internal format to ieee long double. */\n+/* Convert exploded e-type X, that has already been rounded to\n+   64-bit precision, to IEEE double extended format Y.  */\n \n static void \n toe64 (a, b)\n@@ -3326,7 +3331,7 @@ toe64 (a, b)\n   q = b + 4;\n #endif\n #ifdef IEEE\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     q = b;\n   else\n     {\n@@ -3354,7 +3359,7 @@ toe64 (a, b)\n     *q-- = *p++;\n #endif\n #ifdef IEEE\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       if (i)\n \t*q++ = *p++ | 0x8000;\n@@ -3382,7 +3387,7 @@ toe64 (a, b)\n     *q-- = *p++;\n #endif\n #ifdef IEEE\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       for (i = 0; i < 4; i++)\n \t*q++ = *p++;\n@@ -3406,10 +3411,10 @@ toe64 (a, b)\n #endif\n }\n \n-\n-/* e type to IEEE double precision.  */\n+/* e type to double precision.  */\n \n #ifdef DEC\n+/* Convert e-type X to DEC-format double E.  */\n \n static void \n etoe53 (x, e)\n@@ -3418,6 +3423,9 @@ etoe53 (x, e)\n   etodec (x, e);\t\t/* see etodec.c */\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   56-bit double precision, to DEC double Y.  */\n+\n static void \n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n@@ -3427,6 +3435,7 @@ toe53 (x, y)\n \n #else\n #ifdef IBM\n+/* Convert e-type X to IBM 370-format double E.  */\n \n static void \n etoe53 (x, e)\n@@ -3435,6 +3444,9 @@ etoe53 (x, e)\n   etoibm (x, e, DFmode);\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   56-bit precision, to IBM 370 double Y.  */\n+\n static void \n toe53 (x, y)\n      unsigned EMUSHORT *x, *y;\n@@ -3444,6 +3456,8 @@ toe53 (x, y)\n \n #else  /* it's neither DEC nor IBM */\n \n+/* Convert e-type X to IEEE double E.  */\n+\n static void \n etoe53 (x, e)\n      unsigned EMUSHORT *x, *e;\n@@ -3475,6 +3489,8 @@ etoe53 (x, e)\n   toe53 (xi, e);\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   53-bit precision, to IEEE double Y.  */\n \n static void \n toe53 (x, y)\n@@ -3492,7 +3508,7 @@ toe53 (x, y)\n #endif\n   p = &x[0];\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     y += 3;\n #endif\n   *y = 0;\t\t\t/* output high order */\n@@ -3504,7 +3520,7 @@ toe53 (x, y)\n     {\t\t\t\t/* Saturate at largest number less than infinity. */\n #ifdef INFINITY\n       *y |= 0x7ff0;\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  *(--y) = 0;\n \t  *(--y) = 0;\n@@ -3519,7 +3535,7 @@ toe53 (x, y)\n \t}\n #else\n       *y |= (unsigned EMUSHORT) 0x7fef;\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t{\n \t  *(--y) = 0xffff;\n \t  *(--y) = 0xffff;\n@@ -3546,7 +3562,7 @@ toe53 (x, y)\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x0f;\t/* *p = xi[M] */\n   *y |= (unsigned EMUSHORT) i;\t/* high order output already has sign bit set */\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     {\n       *(--y) = *p++;\n       *(--y) = *p++;\n@@ -3566,9 +3582,10 @@ toe53 (x, y)\n \n \n \n-/* e type to IEEE single precision.  */\n+/* e type to single precision.  */\n \n #ifdef IBM\n+/* Convert e-type X to IBM 370 float E.  */\n \n static void \n etoe24 (x, e)\n@@ -3577,6 +3594,9 @@ etoe24 (x, e)\n   etoibm (x, e, SFmode);\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   float precision, to IBM 370 float Y.  */\n+\n static void \n toe24 (x, y)\n      unsigned EMUSHORT *x, *y;\n@@ -3585,6 +3605,7 @@ toe24 (x, y)\n }\n \n #else\n+/* Convert e-type X to IEEE float E.  DEC float is the same as IEEE float.  */\n \n static void \n etoe24 (x, e)\n@@ -3617,6 +3638,9 @@ etoe24 (x, e)\n   toe24 (xi, e);\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   float precision, to IEEE float Y.  */\n+\n static void \n toe24 (x, y)\n      unsigned EMUSHORT *x, *y;\n@@ -3633,7 +3657,7 @@ toe24 (x, y)\n #endif\n   p = &x[0];\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     y += 1;\n #endif\n #ifdef DEC\n@@ -3653,7 +3677,7 @@ toe24 (x, y)\n       *(--y) = 0;\n #endif\n #ifdef IEEE\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t*(--y) = 0;\n       else\n \t{\n@@ -3667,7 +3691,7 @@ toe24 (x, y)\n       *(--y) = 0xffff;\n #endif\n #ifdef IEEE\n-      if (! FLOAT_WORDS_BIG_ENDIAN)\n+      if (! REAL_WORDS_BIG_ENDIAN)\n \t*(--y) = 0xffff;\n       else\n \t{\n@@ -3691,12 +3715,13 @@ toe24 (x, y)\n       eshift (x, 8);\n     }\n   i |= *p++ & (unsigned EMUSHORT) 0x7f;\t/* *p = xi[M] */\n-  *y |= i;\t\t\t/* high order output already has sign bit set */\n+  /* High order output already has sign bit set.  */\n+  *y |= i;\n #ifdef DEC\n   *(--y) = *p;\n #endif\n #ifdef IEEE\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     *(--y) = *p;\n   else\n     {\n@@ -3765,8 +3790,6 @@ ecmp (a, b)\n \n   return (0);\t\t\t/* equality */\n \n-\n-\n  diff:\n \n   if (*(--p) > *(--q))\n@@ -3775,10 +3798,7 @@ ecmp (a, b)\n     return (-msign);\t\t/* p is littler */\n }\n \n-\n-\n-\n-/* Find nearest integer to x = floor (x + 0.5).  */\n+/* Find e-type nearest integer to X, as floor (X + 0.5).  */\n \n static void \n eround (x, y)\n@@ -3788,10 +3808,7 @@ eround (x, y)\n   efloor (y, y);\n }\n \n-\n-\n-\n-/* Convert HOST_WIDE_INT to e type.  */\n+/* Convert HOST_WIDE_INT LP to e type Y.  */\n \n static void \n ltoe (lp, y)\n@@ -3833,7 +3850,7 @@ ltoe (lp, y)\n   emovo (yi, y);\t\t/* output the answer */\n }\n \n-/* Convert unsigned HOST_WIDE_INT to e type.  */\n+/* Convert unsigned HOST_WIDE_INT LP to e type Y.  */\n \n static void \n ultoe (lp, y)\n@@ -3868,8 +3885,8 @@ ultoe (lp, y)\n }\n \n \n-/* Find signed HOST_WIDE_INT integer and floating point fractional\n-   parts of e-type (packed internal format) floating point input X.\n+/* Find signed HOST_WIDE_INT integer I and floating point fractional\n+   part FRAC of e-type (packed internal format) floating point input X.\n    The integer output I has the sign of the input, except that\n    positive overflow is permitted if FIXUNS_TRUNC_LIKE_FIX_TRUNC.\n    The output e-type fraction FRAC is the positive fractional\n@@ -3954,9 +3971,9 @@ eifrac (x, i, frac)\n }\n \n \n-/* Find unsigned HOST_WIDE_INT integer and floating point fractional parts.\n-   A negative e type input yields integer output = 0\n-   but correct fraction.  */\n+/* Find unsigned HOST_WIDE_INT integer I and floating point fractional part\n+   FRAC of e-type X.  A negative input yields integer output = 0 but\n+   correct fraction.  */\n \n static void \n euifrac (x, i, frac)\n@@ -4025,9 +4042,7 @@ euifrac (x, i, frac)\n   emovo (xi, frac);\n }\n \n-\n-\n-/* Shift significand area up or down by the number of bits given by SC.  */\n+/* Shift the significand of exploded e-type X up or down by SC bits.  */\n \n static int \n eshift (x, sc)\n@@ -4092,10 +4107,8 @@ eshift (x, sc)\n   return ((int) lost);\n }\n \n-\n-\n-/* Shift normalize the significand area pointed to by argument.\n-   Shift count (up = positive) is returned.  */\n+/* Shift normalize the significand area of exploded e-type X.\n+   Return the shift count (up = positive).  */\n \n static int \n enormlz (x)\n@@ -4163,11 +4176,7 @@ enormlz (x)\n   return (sc);\n }\n \n-\n-\n-\n-/* Convert e type number to decimal format ASCII string.\n-   The constants are for 64 bit precision.  */\n+/* Powers of ten used in decimal <-> binary conversions.  */\n \n #define NTEN 12\n #define MAXP 4096\n@@ -4269,6 +4278,9 @@ static unsigned EMUSHORT emtens[NTEN + 1][NE] =\n };\n #endif\n \n+/* Convert float value X to ASCII string STRING with NDIG digits after\n+   the decimal point.  */\n+\n static void \n e24toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n@@ -4281,6 +4293,8 @@ e24toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n+/* Convert double value X to ASCII string STRING with NDIG digits after\n+   the decimal point.  */\n \n static void \n e53toasc (x, string, ndigs)\n@@ -4294,6 +4308,8 @@ e53toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n+/* Convert double extended value X to ASCII string STRING with NDIG digits\n+   after the decimal point.  */\n \n static void \n e64toasc (x, string, ndigs)\n@@ -4307,6 +4323,9 @@ e64toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n+/* Convert 128-bit long double value X to ASCII string STRING with NDIG digits\n+   after the decimal point.  */\n+\n static void \n e113toasc (x, string, ndigs)\n      unsigned EMUSHORT x[];\n@@ -4319,6 +4338,8 @@ e113toasc (x, string, ndigs)\n   etoasc (w, string, ndigs);\n }\n \n+/* Convert e-type X to ASCII string STRING with NDIGS digits after\n+   the decimal point.  */\n \n static char wstring[80];\t/* working storage for ASCII output */\n \n@@ -4629,15 +4650,14 @@ etoasc (x, string, ndigs)\n }\n \n \n-/* Convert ASCII string to quadruple precision floating point\n+/* Convert ASCII string to floating point.\n \n-   Numeric input is free field decimal number with max of 15 digits with or\n-   without decimal point entered as ASCII from teletype.  Entering E after\n-   the number followed by a second number causes the second number to be\n-   interpreted as a power of 10 to be multiplied by the first number\n-   (i.e., \"scientific\" notation).  */\n+   Numeric input is a free format decimal number of any length, with\n+   or without decimal point.  Entering E after the number followed by an\n+   integer number causes the second number to be interpreted as a power of\n+   10 to be multiplied by the first number (i.e., \"scientific\" notation).  */\n \n-/* ASCII to single */\n+/* Convert ASCII string S to single precision float value Y.  */\n \n static void \n asctoe24 (s, y)\n@@ -4648,7 +4668,7 @@ asctoe24 (s, y)\n }\n \n \n-/* ASCII to double */\n+/* Convert ASCII string S to double precision value Y.  */\n \n static void \n asctoe53 (s, y)\n@@ -4663,7 +4683,7 @@ asctoe53 (s, y)\n }\n \n \n-/* ASCII to long double */\n+/* Convert ASCII string S to double extended value Y.  */\n \n static void \n asctoe64 (s, y)\n@@ -4673,7 +4693,7 @@ asctoe64 (s, y)\n   asctoeg (s, y, 64);\n }\n \n-/* ASCII to 128-bit long double */\n+/* Convert ASCII string S to 128-bit long double Y.  */\n \n static void \n asctoe113 (s, y)\n@@ -4683,7 +4703,7 @@ asctoe113 (s, y)\n   asctoeg (s, y, 113);\n }\n \n-/* ASCII to super double */\n+/* Convert ASCII string S to e type Y.  */\n \n static void \n asctoe (s, y)\n@@ -4693,8 +4713,8 @@ asctoe (s, y)\n   asctoeg (s, y, NBITS);\n }\n \n-\n-/* ASCII to e type, with specified rounding precision = oprec. */\n+/* Convert ASCII string SS to e type Y, with a specified rounding precision\n+   of OPREC bits. */\n \n static void \n asctoeg (ss, y, oprec)\n@@ -5009,7 +5029,8 @@ asctoeg (ss, y, oprec)\n \n \n \n-/* y = largest integer not greater than x (truncated toward minus infinity)  */\n+/* Return Y = largest integer not greater than X (truncated toward minus\n+   infinity).  */\n \n static unsigned EMUSHORT bmask[] =\n {\n@@ -5079,9 +5100,8 @@ efloor (x, y)\n }\n \n \n-/* Returns s and exp such that  s * 2**exp = x and .5 <= s < 1.\n-   For example, 1.1 = 0.55 * 2**1\n-   Handles denormalized numbers properly using long integer exp.  */\n+/* Return S and EXP such that  S * 2^EXP = X and .5 <= S < 1.\n+   For example, 1.1 = 0.55 * 2^1.  */\n \n static void \n efrexp (x, exp, s)\n@@ -5093,6 +5113,7 @@ efrexp (x, exp, s)\n   EMULONG li;\n \n   emovi (x, xi);\n+  /*  Handle denormalized numbers properly using long integer exponent.  */\n   li = (EMULONG) ((EMUSHORT) xi[1]);\n \n   if (li == 0)\n@@ -5104,9 +5125,7 @@ efrexp (x, exp, s)\n   *exp = (int) (li - 0x3ffe);\n }\n \n-\n-\n-/* Return y = x * 2**pwr2.  */\n+/* Return e type Y = X * 2^PWR2.  */\n \n static void \n eldexp (x, pwr2, y)\n@@ -5127,8 +5146,8 @@ eldexp (x, pwr2, y)\n }\n \n \n-/* c = remainder after dividing b by a\n-   Least significant integer quotient bits left in equot[].  */\n+/* C = remainder after dividing B by A, all e type values.\n+   Least significant integer quotient bits left in EQUOT.  */\n \n static void \n eremain (a, b, c)\n@@ -5163,6 +5182,9 @@ eremain (a, b, c)\n   emovo (num, c);\n }\n \n+/*  Return quotient of exploded e-types NUM / DEN in EQUOT,\n+    remainder in NUM.  */\n+\n static void \n eiremain (den, num)\n      unsigned EMUSHORT den[], num[];\n@@ -5183,9 +5205,7 @@ eiremain (den, num)\n \t  j = 1;\n \t}\n       else\n-\t{\n \t  j = 0;\n-\t}\n       eshup1 (equot);\n       equot[NI - 1] |= j;\n       eshup1 (num);\n@@ -5194,8 +5214,8 @@ eiremain (den, num)\n   emdnorm (num, 0, 0, ln, 0);\n }\n \n-/* This routine may be called to report one of the following\n-   error conditions (in the include file mconf.h).\n+/* Report an error condition CODE encountered in function NAME.\n+   CODE is one of the following:\n \n     Mnemonic        Value          Significance\n  \n@@ -5209,19 +5229,7 @@ eiremain (den, num)\n      EDOM             33       Unix domain error code\n      ERANGE           34       Unix range error code\n  \n-  The default version of the file prints the function name,\n-  passed to it by the pointer fctnam, followed by the\n-  error condition.  The display is directed to the standard\n-  output device.  The routine then returns to the calling\n-  program.  Users may wish to modify the program to abort by\n-  calling exit under severe error conditions such as domain\n-  errors.\n- \n-  Since all error conditions pass control to this function,\n-  the display may be easily changed, eliminated, or directed\n-  to an error logging device. */\n-\n-/* Note: the order of appearance of the following messages is bound to the\n+   The order of appearance of the following messages is bound to the\n    error codes defined above.  */\n \n #define NMSGS 8\n@@ -5247,10 +5255,9 @@ mtherr (name, code)\n {\n   char errstr[80];\n \n-  /* Display string passed by calling program, which is supposed to be the\n+  /* The string passed by the calling program is supposed to be the\n      name of the function in which the error occurred.\n-\n-     Display error message defined by the code argument.  */\n+     The code argument selects which error message string will be printed.  */\n \n   if ((code <= 0) || (code >= NMSGS))\n     code = 0;\n@@ -5262,7 +5269,7 @@ mtherr (name, code)\n }\n \n #ifdef DEC\n-/* Convert DEC double precision to e type.  */\n+/* Convert DEC double precision D to e type E.  */\n \n static void \n dectoe (d, e)\n@@ -5302,14 +5309,7 @@ dectoe (d, e)\n   emovo (y, e);\n }\n \n-\n-\n-/*\n-;\tconvert e type to DEC double precision\n-;\tdouble d;\n-;\tEMUSHORT e[NE];\n-;\tetodec (e, &d);\n-*/\n+/* Convert e type X to DEC double precision D.  */\n \n static void \n etodec (x, d)\n@@ -5320,15 +5320,19 @@ etodec (x, d)\n   int rndsav;\n \n   emovi (x, xi);\n-  exp = (EMULONG) xi[E] - (EXONE - 0201);\t/* adjust exponent for offsets */\n-/* round off to nearest or even */\n+  /* Adjust exponent for offsets.  */\n+  exp = (EMULONG) xi[E] - (EXONE - 0201);\n+  /* Round off to nearest or even.  */\n   rndsav = rndprc;\n   rndprc = 56;\n   emdnorm (xi, 0, 0, exp, 64);\n   rndprc = rndsav;\n   todec (xi, d);\n }\n \n+/* Convert exploded e-type X, that has already been rounded to\n+   56-bit precision, to DEC format double Y.  */\n+\n static void \n todec (x, y)\n      unsigned EMUSHORT *x, *y;\n@@ -5552,29 +5556,29 @@ make_nan (nan, sign, mode)\n #if !defined(DEC) && !defined(IBM)\n     case TFmode:\n       n = 8;\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n+      if (REAL_WORDS_BIG_ENDIAN)\n \tp = TFbignan;\n       else\n \tp = TFlittlenan;\n       break;\n     case XFmode:\n       n = 6;\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n+      if (REAL_WORDS_BIG_ENDIAN)\n \tp = XFbignan;\n       else\n \tp = XFlittlenan;\n       break;\n     case DFmode:\n       n = 4;\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n+      if (REAL_WORDS_BIG_ENDIAN)\n \tp = DFbignan;\n       else\n \tp = DFlittlenan;\n       break;\n     case HFmode:\n     case SFmode:\n       n = 2;\n-      if (FLOAT_WORDS_BIG_ENDIAN)\n+      if (REAL_WORDS_BIG_ENDIAN)\n \tp = SFbignan;\n       else\n \tp = SFlittlenan;\n@@ -5583,11 +5587,11 @@ make_nan (nan, sign, mode)\n     default:\n       abort ();\n     }\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     *nan++ = (sign << 15) | *p++;\n   while (--n != 0)\n     *nan++ = *p++;\n-  if (! FLOAT_WORDS_BIG_ENDIAN)\n+  if (! REAL_WORDS_BIG_ENDIAN)\n     *nan = (sign << 15) | *p;\n }\n \n@@ -5605,7 +5609,7 @@ ereal_from_float (f)\n \n   /* Convert 32 bit integer to array of 16 bit pieces in target machine order.\n    This is the inverse operation to what the function `endian' does.  */\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       s[0] = (unsigned EMUSHORT) (f >> 16);\n       s[1] = (unsigned EMUSHORT) f;\n@@ -5641,7 +5645,7 @@ ereal_from_double (d)\n   unsigned EMUSHORT e[NE];\n \n   /* Convert array of HOST_WIDE_INT to equivalent array of 16-bit pieces.  */\n-  if (FLOAT_WORDS_BIG_ENDIAN)\n+  if (REAL_WORDS_BIG_ENDIAN)\n     {\n       s[0] = (unsigned EMUSHORT) (d[0] >> 16);\n       s[1] = (unsigned EMUSHORT) d[0];\n@@ -5679,7 +5683,7 @@ ereal_from_double (d)\n \n /* Convert target computer unsigned 64-bit integer to e-type.\n    The endian-ness of DImode follows the convention for integers,\n-   so we use WORDS_BIG_ENDIAN here, not FLOAT_WORDS_BIG_ENDIAN.  */\n+   so we use WORDS_BIG_ENDIAN here, not REAL_WORDS_BIG_ENDIAN.  */\n \n static void\n uditoe (di, e)"}]}