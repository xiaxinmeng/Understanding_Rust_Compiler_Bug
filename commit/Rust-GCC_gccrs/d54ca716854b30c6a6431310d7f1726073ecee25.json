{"sha": "d54ca716854b30c6a6431310d7f1726073ecee25", "node_id": "C_kwDOANBUbNoAKGQ1NGNhNzE2ODU0YjMwYzZhNjQzMTMxMGQ3ZjE3MjYwNzNlY2VlMjU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-25T10:36:08Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-25T10:36:08Z"}, "message": "Merge #1160\n\n1160: Refactor name resolver r=CohenArthur a=CohenArthur\n\nThis PR splits up the `rust-name-resolver.h` file into source and header. It also removes a bunch of `iterate_*` functions: Some were not used anymore, and some were refactored.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "f544810a9ef95704b724dff03ddb4308283a79ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f544810a9ef95704b724dff03ddb4308283a79ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d54ca716854b30c6a6431310d7f1726073ecee25", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiZnmYCRBK7hj4Ov3rIwAAvlcIAGvY2sCBvHNqG4vch33FDIP2\n8OI/9PGuqWYokP2DFLI5xLZiAIvrFYnw9iGFQ7O5yk99lSHs+gINXLOyZqpbxYht\nuReoScidn5IrrtYip/yxmy6LKVJeT6yHTtg81DlSrNg8jAi2/XNWaNRyWYM/62b2\ntc11z6PrGOdDv6cpF9J3cNWT2Hb1UDmGTTxyocvWG/wWJfq1ZMiOlp/qJPuuUIA+\n7mPF5ofH0B4k4o4m62t4onTTcRpuw9sZcjWPE+gGRSXsEMjC9VJ6TTtgQckW0mQx\nAKJsRAHrJW39wM1DiSKKFTA+FyqE7Vym6OTpPpKZZ2hVfmowHHgdseBhACx/wEI=\n=HR2R\n-----END PGP SIGNATURE-----\n", "payload": "tree f544810a9ef95704b724dff03ddb4308283a79ed\nparent bbbd15a4a137ac096edfbe5bfe7885b91037f128\nparent 23db789ecb574e702ca3f3aea6b7d6f9ddbe99cd\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1650882968 +0000\ncommitter GitHub <noreply@github.com> 1650882968 +0000\n\nMerge #1160\n\n1160: Refactor name resolver r=CohenArthur a=CohenArthur\n\nThis PR splits up the `rust-name-resolver.h` file into source and header. It also removes a bunch of `iterate_*` functions: Some were not used anymore, and some were refactored.\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54ca716854b30c6a6431310d7f1726073ecee25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d54ca716854b30c6a6431310d7f1726073ecee25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d54ca716854b30c6a6431310d7f1726073ecee25/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bbbd15a4a137ac096edfbe5bfe7885b91037f128", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbd15a4a137ac096edfbe5bfe7885b91037f128", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbbd15a4a137ac096edfbe5bfe7885b91037f128"}, {"sha": "23db789ecb574e702ca3f3aea6b7d6f9ddbe99cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23db789ecb574e702ca3f3aea6b7d6f9ddbe99cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23db789ecb574e702ca3f3aea6b7d6f9ddbe99cd"}], "stats": {"total": 1104, "additions": 563, "deletions": 541}, "files": [{"sha": "436d9c3d6c4eb32c6bf7da29ff7a4fdea270fb51", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=d54ca716854b30c6a6431310d7f1726073ecee25", "patch": "@@ -85,6 +85,7 @@ GRS_OBJS = \\\n     rust/rust-ast-lower.o \\\n     rust/rust-ast-lower-base.o \\\n     rust/rust-ast-lower-pattern.o \\\n+    rust/rust-name-resolver.o \\\n     rust/rust-ast-resolve.o \\\n     rust/rust-ast-resolve-pattern.o \\\n     rust/rust-ast-resolve-expr.o \\"}, {"sha": "b969b7a6efc8d1d539d5ddbd0b7063af2380e3c4", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=d54ca716854b30c6a6431310d7f1726073ecee25", "patch": "@@ -333,33 +333,33 @@ HIRCompileBase::compile_locals_for_block (Context *ctx, Resolver::Rib &rib,\n \t\t\t\t\t  tree fndecl)\n {\n   std::vector<Bvariable *> locals;\n-  rib.iterate_decls ([&] (NodeId n, Location) mutable -> bool {\n-    Resolver::Definition d;\n-    bool ok = ctx->get_resolver ()->lookup_definition (n, &d);\n-    rust_assert (ok);\n-\n-    HIR::Stmt *decl = nullptr;\n-    ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n-    rust_assert (ok);\n-\n-    // if its a function we extract this out side of this fn context\n-    // and it is not a local to this function\n-    bool is_item = ctx->get_mappings ()->lookup_hir_item (\n-\t\t     decl->get_mappings ().get_crate_num (),\n-\t\t     decl->get_mappings ().get_hirid ())\n-\t\t   != nullptr;\n-    if (is_item)\n-      {\n-\tHIR::Item *item = static_cast<HIR::Item *> (decl);\n-\tCompileItem::compile (item, ctx);\n-\treturn true;\n-      }\n-\n-    Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n-    locals.push_back (compiled);\n+  for (auto it : rib.get_declarations ())\n+    {\n+      auto node_id = it.first;\n+\n+      Resolver::Definition d;\n+      bool ok = ctx->get_resolver ()->lookup_definition (node_id, &d);\n+      rust_assert (ok);\n+\n+      HIR::Stmt *decl = nullptr;\n+      ok = ctx->get_mappings ()->resolve_nodeid_to_stmt (d.parent, &decl);\n+      rust_assert (ok);\n+\n+      // if its a function we extract this out side of this fn context\n+      // and it is not a local to this function\n+      bool is_item = ctx->get_mappings ()->lookup_hir_item (\n+\t\t       decl->get_mappings ().get_crate_num (),\n+\t\t       decl->get_mappings ().get_hirid ())\n+\t\t     != nullptr;\n+      if (is_item)\n+\t{\n+\t  HIR::Item *item = static_cast<HIR::Item *> (decl);\n+\t  CompileItem::compile (item, ctx);\n+\t}\n \n-    return true;\n-  });\n+      Bvariable *compiled = CompileVarDecl::compile (fndecl, decl, ctx);\n+      locals.push_back (compiled);\n+    };\n \n   return locals;\n }"}, {"sha": "723c460a97468cb676435740dc8f3a29d71611c5", "filename": "gcc/rust/resolve/rust-ast-resolve.cc", "status": "modified", "additions": 0, "deletions": 294, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve.cc?ref=d54ca716854b30c6a6431310d7f1726073ecee25", "patch": "@@ -24,306 +24,12 @@\n #include \"rust-ast-resolve-expr.h\"\n #include \"rust-ast-resolve-struct-expr-field.h\"\n \n-#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n-  do                                                                           \\\n-    {                                                                          \\\n-      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n-      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n-\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n-\t\t\t\t  Linemap::predeclared_location ()));          \\\n-      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n-      segs.push_back (::std::move (typePath));                                 \\\n-      auto builtin_type                                                        \\\n-\t= new AST::TypePath (::std::move (segs),                               \\\n-\t\t\t     Linemap::predeclared_location (), false);         \\\n-      _R.push_back (builtin_type);                                             \\\n-      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n-\t\t\t     _TY);                                             \\\n-    }                                                                          \\\n-  while (0)\n-\n extern bool\n saw_errors (void);\n \n namespace Rust {\n namespace Resolver {\n \n-// Resolver\n-\n-Resolver::Resolver ()\n-  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n-    name_scope (Scope (mappings->get_current_crate ())),\n-    type_scope (Scope (mappings->get_current_crate ())),\n-    label_scope (Scope (mappings->get_current_crate ())),\n-    macro_scope (Scope (mappings->get_current_crate ())),\n-    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n-{\n-  generate_builtins ();\n-}\n-\n-Resolver *\n-Resolver::get ()\n-{\n-  static Resolver *instance;\n-  if (instance == nullptr)\n-    instance = new Resolver ();\n-\n-  return instance;\n-}\n-\n-void\n-Resolver::push_new_name_rib (Rib *r)\n-{\n-  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n-  name_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_type_rib (Rib *r)\n-{\n-  if (type_ribs.size () == 0)\n-    global_type_node_id = r->get_node_id ();\n-\n-  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n-  type_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_label_rib (Rib *r)\n-{\n-  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n-  label_ribs[r->get_node_id ()] = r;\n-}\n-\n-void\n-Resolver::push_new_macro_rib (Rib *r)\n-{\n-  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n-  macro_ribs[r->get_node_id ()] = r;\n-}\n-\n-bool\n-Resolver::find_name_rib (NodeId id, Rib **rib)\n-{\n-  auto it = name_ribs.find (id);\n-  if (it == name_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-bool\n-Resolver::find_type_rib (NodeId id, Rib **rib)\n-{\n-  auto it = type_ribs.find (id);\n-  if (it == type_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-bool\n-Resolver::find_macro_rib (NodeId id, Rib **rib)\n-{\n-  auto it = macro_ribs.find (id);\n-  if (it == macro_ribs.end ())\n-    return false;\n-\n-  *rib = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_builtin_types (Rib *r)\n-{\n-  auto builtins = get_builtin_types ();\n-  for (auto &builtin : builtins)\n-    {\n-      CanonicalPath builtin_path\n-\t= CanonicalPath::new_seg (builtin->get_node_id (),\n-\t\t\t\t  builtin->as_string ());\n-      r->insert_name (builtin_path, builtin->get_node_id (),\n-\t\t      Linemap::predeclared_location (), false,\n-\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n-    }\n-}\n-\n-std::vector<AST::Type *> &\n-Resolver::get_builtin_types ()\n-{\n-  return builtins;\n-}\n-\n-void\n-Resolver::generate_builtins ()\n-{\n-  auto u8\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n-  auto u16\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n-  auto u32\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n-  auto u64\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n-  auto u128\n-    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n-  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n-  auto i16\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n-  auto i32\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n-  auto i64\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n-  auto i128\n-    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n-  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n-  auto f32\n-    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n-  auto f64\n-    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n-  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n-  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n-  auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n-  auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n-  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n-\n-  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n-  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n-  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n-  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n-  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n-  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n-  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n-  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n-  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n-  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n-  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n-  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n-  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n-  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n-  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n-  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n-  MKBUILTIN_TYPE (\"str\", builtins, str);\n-  MKBUILTIN_TYPE (\"!\", builtins, never);\n-\n-  // unit type ()\n-  TyTy::TupleType *unit_tyty\n-    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n-  std::vector<std::unique_ptr<AST::Type> > elems;\n-  AST::TupleType *unit_type\n-    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n-  builtins.push_back (unit_type);\n-  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n-\t\t\t unit_tyty);\n-  set_unit_type_node_id (unit_type->get_node_id ());\n-}\n-\n-void\n-Resolver::insert_new_definition (NodeId id, Definition def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it != name_definitions.end ())\n-    {\n-      rust_assert (it->second.is_equal (def));\n-      return;\n-    }\n-  name_definitions[id] = def;\n-}\n-\n-bool\n-Resolver::lookup_definition (NodeId id, Definition *def)\n-{\n-  auto it = name_definitions.find (id);\n-  if (it == name_definitions.end ())\n-    return false;\n-\n-  *def = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n-{\n-  resolved_names[refId] = defId;\n-  get_name_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_names.find (refId);\n-  if (it == resolved_names.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n-{\n-  // auto it = resolved_types.find (refId);\n-  // rust_assert (it == resolved_types.end ());\n-\n-  resolved_types[refId] = defId;\n-  get_type_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_types.find (refId);\n-  if (it == resolved_types.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n-{\n-  auto it = resolved_labels.find (refId);\n-  rust_assert (it == resolved_labels.end ());\n-\n-  resolved_labels[refId] = defId;\n-  get_label_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_labels.find (refId);\n-  if (it == resolved_labels.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n-void\n-Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n-{\n-  auto it = resolved_macros.find (refId);\n-  rust_assert (it == resolved_macros.end ());\n-\n-  resolved_labels[refId] = defId;\n-  get_label_scope ().append_reference_for_def (refId, defId);\n-}\n-\n-bool\n-Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n-{\n-  auto it = resolved_macros.find (refId);\n-  if (it == resolved_macros.end ())\n-    return false;\n-\n-  *defId = it->second;\n-  return true;\n-}\n-\n // NameResolution\n \n NameResolution *"}, {"sha": "fc1f36154dd5102f1caee6fb5c6ffb9eb44331e7", "filename": "gcc/rust/resolve/rust-name-resolver.cc", "status": "added", "additions": 513, "deletions": 0, "changes": 513, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.cc?ref=d54ca716854b30c6a6431310d7f1726073ecee25", "patch": "@@ -0,0 +1,513 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-name-resolver.h\"\n+#include \"rust-ast-full.h\"\n+\n+#define MKBUILTIN_TYPE(_X, _R, _TY)                                            \\\n+  do                                                                           \\\n+    {                                                                          \\\n+      AST::PathIdentSegment seg (_X, Linemap::predeclared_location ());        \\\n+      auto typePath = ::std::unique_ptr<AST::TypePathSegment> (                \\\n+\tnew AST::TypePathSegment (::std::move (seg), false,                    \\\n+\t\t\t\t  Linemap::predeclared_location ()));          \\\n+      ::std::vector< ::std::unique_ptr<AST::TypePathSegment> > segs;           \\\n+      segs.push_back (::std::move (typePath));                                 \\\n+      auto builtin_type                                                        \\\n+\t= new AST::TypePath (::std::move (segs),                               \\\n+\t\t\t     Linemap::predeclared_location (), false);         \\\n+      _R.push_back (builtin_type);                                             \\\n+      tyctx->insert_builtin (_TY->get_ref (), builtin_type->get_node_id (),    \\\n+\t\t\t     _TY);                                             \\\n+    }                                                                          \\\n+  while (0)\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+Rib::Rib (CrateNum crateNum, NodeId node_id)\n+  : crate_num (crateNum), node_id (node_id),\n+    mappings (Analysis::Mappings::get ())\n+{}\n+\n+void\n+Rib::insert_name (\n+  const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n+  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n+{\n+  auto it = path_mappings.find (path);\n+  bool path_already_exists = it != path_mappings.end ();\n+  if (path_already_exists && !shadow)\n+    {\n+      const auto &decl = decls_within_rib.find (it->second);\n+      if (decl != decls_within_rib.end ())\n+\tdup_cb (path, it->second, decl->second);\n+      else\n+\tdup_cb (path, it->second, locus);\n+\n+      return;\n+    }\n+\n+  path_mappings[path] = id;\n+  reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n+  decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n+  references[id] = {};\n+}\n+\n+bool\n+Rib::lookup_name (const CanonicalPath &ident, NodeId *id)\n+{\n+  auto it = path_mappings.find (ident);\n+  if (it == path_mappings.end ())\n+    return false;\n+\n+  *id = it->second;\n+  return true;\n+}\n+\n+void\n+Rib::clear_name (const CanonicalPath &ident, NodeId id)\n+{\n+  auto ii = path_mappings.find (ident);\n+  if (ii != path_mappings.end ())\n+    path_mappings.erase (ii);\n+\n+  auto ij = reverse_path_mappings.find (id);\n+  if (ij != reverse_path_mappings.end ())\n+    reverse_path_mappings.erase (ij);\n+\n+  auto ik = decls_within_rib.find (id);\n+  if (ik != decls_within_rib.end ())\n+    decls_within_rib.erase (ik);\n+}\n+\n+void\n+Rib::append_reference_for_def (NodeId def, NodeId ref)\n+{\n+  references[def].insert (ref);\n+}\n+\n+bool\n+Rib::have_references_for_node (NodeId def) const\n+{\n+  auto it = references.find (def);\n+  if (it == references.end ())\n+    return false;\n+\n+  return !it->second.empty ();\n+}\n+\n+bool\n+Rib::decl_was_declared_here (NodeId def) const\n+{\n+  for (auto &it : decls_within_rib)\n+    {\n+      if (it.first == def)\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n+Scope::Scope (CrateNum crate_num) : crate_num (crate_num) {}\n+\n+void\n+Scope::insert (\n+  const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n+  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n+{\n+  peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n+}\n+\n+void\n+Scope::insert (const CanonicalPath &ident, NodeId id, Location locus)\n+{\n+  peek ()->insert_name (ident, id, locus, true,\n+\t\t\t[] (const CanonicalPath &, NodeId, Location) -> void {\n+\t\t\t});\n+}\n+\n+bool\n+Scope::lookup (const CanonicalPath &ident, NodeId *id)\n+{\n+  NodeId lookup = UNKNOWN_NODEID;\n+  iterate ([&] (Rib *r) mutable -> bool {\n+    if (r->lookup_name (ident, &lookup))\n+      return false;\n+    return true;\n+  });\n+\n+  *id = lookup;\n+  return lookup != UNKNOWN_NODEID;\n+}\n+\n+void\n+Scope::iterate (std::function<bool (Rib *)> cb)\n+{\n+  for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n+    {\n+      if (!cb (*it))\n+\treturn;\n+    }\n+}\n+\n+Rib *\n+Scope::peek ()\n+{\n+  return stack.back ();\n+}\n+\n+void\n+Scope::push (NodeId id)\n+{\n+  stack.push_back (new Rib (get_crate_num (), id));\n+}\n+\n+Rib *\n+Scope::pop ()\n+{\n+  Rib *r = peek ();\n+  stack.pop_back ();\n+  return r;\n+}\n+\n+void\n+Scope::append_reference_for_def (NodeId refId, NodeId defId)\n+{\n+  bool ok = false;\n+  iterate ([&] (Rib *r) mutable -> bool {\n+    if (r->decl_was_declared_here (defId))\n+      {\n+\tok = true;\n+\tr->append_reference_for_def (defId, refId);\n+      }\n+    return true;\n+  });\n+  rust_assert (ok);\n+}\n+\n+Resolver::Resolver ()\n+  : mappings (Analysis::Mappings::get ()), tyctx (TypeCheckContext::get ()),\n+    name_scope (Scope (mappings->get_current_crate ())),\n+    type_scope (Scope (mappings->get_current_crate ())),\n+    label_scope (Scope (mappings->get_current_crate ())),\n+    macro_scope (Scope (mappings->get_current_crate ())),\n+    global_type_node_id (UNKNOWN_NODEID), unit_ty_node_id (UNKNOWN_NODEID)\n+{\n+  generate_builtins ();\n+}\n+\n+Resolver *\n+Resolver::get ()\n+{\n+  static Resolver *instance;\n+  if (instance == nullptr)\n+    instance = new Resolver ();\n+\n+  return instance;\n+}\n+\n+void\n+Resolver::push_new_name_rib (Rib *r)\n+{\n+  rust_assert (name_ribs.find (r->get_node_id ()) == name_ribs.end ());\n+  name_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_type_rib (Rib *r)\n+{\n+  if (type_ribs.size () == 0)\n+    global_type_node_id = r->get_node_id ();\n+\n+  rust_assert (type_ribs.find (r->get_node_id ()) == type_ribs.end ());\n+  type_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_label_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  label_ribs[r->get_node_id ()] = r;\n+}\n+\n+void\n+Resolver::push_new_macro_rib (Rib *r)\n+{\n+  rust_assert (label_ribs.find (r->get_node_id ()) == label_ribs.end ());\n+  macro_ribs[r->get_node_id ()] = r;\n+}\n+\n+bool\n+Resolver::find_name_rib (NodeId id, Rib **rib)\n+{\n+  auto it = name_ribs.find (id);\n+  if (it == name_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_type_rib (NodeId id, Rib **rib)\n+{\n+  auto it = type_ribs.find (id);\n+  if (it == type_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+bool\n+Resolver::find_macro_rib (NodeId id, Rib **rib)\n+{\n+  auto it = macro_ribs.find (id);\n+  if (it == macro_ribs.end ())\n+    return false;\n+\n+  *rib = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_builtin_types (Rib *r)\n+{\n+  auto builtins = get_builtin_types ();\n+  for (auto &builtin : builtins)\n+    {\n+      CanonicalPath builtin_path\n+\t= CanonicalPath::new_seg (builtin->get_node_id (),\n+\t\t\t\t  builtin->as_string ());\n+      r->insert_name (builtin_path, builtin->get_node_id (),\n+\t\t      Linemap::predeclared_location (), false,\n+\t\t      [] (const CanonicalPath &, NodeId, Location) -> void {});\n+    }\n+}\n+\n+std::vector<AST::Type *> &\n+Resolver::get_builtin_types ()\n+{\n+  return builtins;\n+}\n+\n+void\n+Resolver::generate_builtins ()\n+{\n+  auto u8\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U8);\n+  auto u16\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U16);\n+  auto u32\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U32);\n+  auto u64\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U64);\n+  auto u128\n+    = new TyTy::UintType (mappings->get_next_hir_id (), TyTy::UintType::U128);\n+  auto i8 = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I8);\n+  auto i16\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I16);\n+  auto i32\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I32);\n+  auto i64\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I64);\n+  auto i128\n+    = new TyTy::IntType (mappings->get_next_hir_id (), TyTy::IntType::I128);\n+  auto rbool = new TyTy::BoolType (mappings->get_next_hir_id ());\n+  auto f32\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F32);\n+  auto f64\n+    = new TyTy::FloatType (mappings->get_next_hir_id (), TyTy::FloatType::F64);\n+  auto usize = new TyTy::USizeType (mappings->get_next_hir_id ());\n+  auto isize = new TyTy::ISizeType (mappings->get_next_hir_id ());\n+  auto char_tyty = new TyTy::CharType (mappings->get_next_hir_id ());\n+  auto str = new TyTy::StrType (mappings->get_next_hir_id ());\n+  auto never = new TyTy::NeverType (mappings->get_next_hir_id ());\n+\n+  MKBUILTIN_TYPE (\"u8\", builtins, u8);\n+  MKBUILTIN_TYPE (\"u16\", builtins, u16);\n+  MKBUILTIN_TYPE (\"u32\", builtins, u32);\n+  MKBUILTIN_TYPE (\"u64\", builtins, u64);\n+  MKBUILTIN_TYPE (\"u128\", builtins, u128);\n+  MKBUILTIN_TYPE (\"i8\", builtins, i8);\n+  MKBUILTIN_TYPE (\"i16\", builtins, i16);\n+  MKBUILTIN_TYPE (\"i32\", builtins, i32);\n+  MKBUILTIN_TYPE (\"i64\", builtins, i64);\n+  MKBUILTIN_TYPE (\"i128\", builtins, i128);\n+  MKBUILTIN_TYPE (\"bool\", builtins, rbool);\n+  MKBUILTIN_TYPE (\"f32\", builtins, f32);\n+  MKBUILTIN_TYPE (\"f64\", builtins, f64);\n+  MKBUILTIN_TYPE (\"usize\", builtins, usize);\n+  MKBUILTIN_TYPE (\"isize\", builtins, isize);\n+  MKBUILTIN_TYPE (\"char\", builtins, char_tyty);\n+  MKBUILTIN_TYPE (\"str\", builtins, str);\n+  MKBUILTIN_TYPE (\"!\", builtins, never);\n+\n+  // unit type ()\n+  TyTy::TupleType *unit_tyty\n+    = TyTy::TupleType::get_unit_type (mappings->get_next_hir_id ());\n+  std::vector<std::unique_ptr<AST::Type> > elems;\n+  AST::TupleType *unit_type\n+    = new AST::TupleType (std::move (elems), Linemap::predeclared_location ());\n+  builtins.push_back (unit_type);\n+  tyctx->insert_builtin (unit_tyty->get_ref (), unit_type->get_node_id (),\n+\t\t\t unit_tyty);\n+  set_unit_type_node_id (unit_type->get_node_id ());\n+}\n+\n+void\n+Resolver::insert_new_definition (NodeId id, Definition def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it != name_definitions.end ())\n+    {\n+      rust_assert (it->second.is_equal (def));\n+      return;\n+    }\n+  name_definitions[id] = def;\n+}\n+\n+bool\n+Resolver::lookup_definition (NodeId id, Definition *def)\n+{\n+  auto it = name_definitions.find (id);\n+  if (it == name_definitions.end ())\n+    return false;\n+\n+  *def = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_name (NodeId refId, NodeId defId)\n+{\n+  resolved_names[refId] = defId;\n+  get_name_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_name (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_names.find (refId);\n+  if (it == resolved_names.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_type (NodeId refId, NodeId defId)\n+{\n+  // auto it = resolved_types.find (refId);\n+  // rust_assert (it == resolved_types.end ());\n+\n+  resolved_types[refId] = defId;\n+  get_type_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_type (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_types.find (refId);\n+  if (it == resolved_types.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_label (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  rust_assert (it == resolved_labels.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_label (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_labels.find (refId);\n+  if (it == resolved_labels.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::insert_resolved_macro (NodeId refId, NodeId defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  rust_assert (it == resolved_macros.end ());\n+\n+  resolved_labels[refId] = defId;\n+  get_label_scope ().append_reference_for_def (refId, defId);\n+}\n+\n+bool\n+Resolver::lookup_resolved_macro (NodeId refId, NodeId *defId)\n+{\n+  auto it = resolved_macros.find (refId);\n+  if (it == resolved_macros.end ())\n+    return false;\n+\n+  *defId = it->second;\n+  return true;\n+}\n+\n+void\n+Resolver::mark_decl_mutability (NodeId id, bool mut)\n+{\n+  rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n+  decl_mutability[id] = mut;\n+}\n+\n+bool\n+Resolver::decl_is_mutable (NodeId id) const\n+{\n+  auto it = decl_mutability.find (id);\n+  rust_assert (it != decl_mutability.end ());\n+  return it->second;\n+}\n+\n+void\n+Resolver::mark_assignment_to_decl (NodeId id, NodeId assignment)\n+{\n+  auto it = assignment_to_decl.find (id);\n+  if (it == assignment_to_decl.end ())\n+    assignment_to_decl[id] = {};\n+\n+  assignment_to_decl[id].insert (assignment);\n+}\n+\n+size_t\n+Resolver::get_num_assignments_to_decl (NodeId id) const\n+{\n+  auto it = assignment_to_decl.find (id);\n+  if (it == assignment_to_decl.end ())\n+    return 0;\n+\n+  return it->second.size ();\n+}\n+\n+} // namespace Resolver\n+} // namespace Rust"}, {"sha": "ab7cb5567e12e9f24492a204883eee0fb81254ec", "filename": "gcc/rust/resolve/rust-name-resolver.h", "status": "modified", "additions": 23, "deletions": 221, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d54ca716854b30c6a6431310d7f1726073ecee25/gcc%2Frust%2Fresolve%2Frust-name-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-name-resolver.h?ref=d54ca716854b30c6a6431310d7f1726073ecee25", "patch": "@@ -32,120 +32,23 @@ class Rib\n public:\n   // Rust uses local_def_ids assigned by def_collector on the AST\n   // lets use NodeId instead\n-  Rib (CrateNum crateNum, NodeId node_id)\n-    : crate_num (crateNum), node_id (node_id),\n-      mappings (Analysis::Mappings::get ())\n-  {}\n-\n-  ~Rib () {}\n+  Rib (CrateNum crateNum, NodeId node_id);\n \n   // this takes the relative paths of items within a compilation unit for lookup\n   void insert_name (\n     const CanonicalPath &path, NodeId id, Location locus, bool shadow,\n-    std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n-  {\n-    auto it = path_mappings.find (path);\n-    bool path_already_exists = it != path_mappings.end ();\n-    if (path_already_exists && !shadow)\n-      {\n-\tconst auto &decl = decls_within_rib.find (it->second);\n-\tif (decl != decls_within_rib.end ())\n-\t  dup_cb (path, it->second, decl->second);\n-\telse\n-\t  dup_cb (path, it->second, locus);\n-\n-\treturn;\n-      }\n-\n-    path_mappings[path] = id;\n-    reverse_path_mappings.insert (std::pair<NodeId, CanonicalPath> (id, path));\n-    decls_within_rib.insert (std::pair<NodeId, Location> (id, locus));\n-    references[id] = {};\n-  }\n-\n-  bool lookup_name (const CanonicalPath &ident, NodeId *id)\n-  {\n-    auto it = path_mappings.find (ident);\n-    if (it == path_mappings.end ())\n-      return false;\n-\n-    *id = it->second;\n-    return true;\n-  }\n-\n-  bool lookup_canonical_path (const NodeId &id, CanonicalPath *ident)\n-  {\n-    auto it = reverse_path_mappings.find (id);\n-    if (it == reverse_path_mappings.end ())\n-      return false;\n+    std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n \n-    *ident = it->second;\n-    return true;\n-  }\n-\n-  void clear_name (const CanonicalPath &ident, NodeId id)\n-  {\n-    auto ii = path_mappings.find (ident);\n-    if (ii != path_mappings.end ())\n-      path_mappings.erase (ii);\n-\n-    auto ij = reverse_path_mappings.find (id);\n-    if (ij != reverse_path_mappings.end ())\n-      reverse_path_mappings.erase (ij);\n-\n-    auto ik = decls_within_rib.find (id);\n-    if (ik != decls_within_rib.end ())\n-      decls_within_rib.erase (ik);\n-  }\n+  bool lookup_canonical_path (const NodeId &id, CanonicalPath *ident);\n+  bool lookup_name (const CanonicalPath &ident, NodeId *id);\n+  void clear_name (const CanonicalPath &ident, NodeId id);\n+  void append_reference_for_def (NodeId def, NodeId ref);\n+  bool have_references_for_node (NodeId def) const;\n+  bool decl_was_declared_here (NodeId def) const;\n \n   CrateNum get_crate_num () const { return crate_num; }\n   NodeId get_node_id () const { return node_id; }\n-\n-  void iterate_decls (std::function<bool (NodeId, Location)> cb)\n-  {\n-    for (auto it : decls_within_rib)\n-      {\n-\tif (!cb (it.first, it.second))\n-\t  return;\n-      }\n-  }\n-\n-  void iterate_references_for_def (NodeId def, std::function<bool (NodeId)> cb)\n-  {\n-    auto it = references.find (def);\n-    if (it == references.end ())\n-      return;\n-\n-    for (auto ref : it->second)\n-      {\n-\tif (!cb (ref))\n-\t  return;\n-      }\n-  }\n-\n-  void append_reference_for_def (NodeId def, NodeId ref)\n-  {\n-    references[def].insert (ref);\n-  }\n-\n-  bool have_references_for_node (NodeId def) const\n-  {\n-    auto it = references.find (def);\n-    if (it == references.end ())\n-      return false;\n-\n-    return !it->second.empty ();\n-  }\n-\n-  bool decl_was_declared_here (NodeId def) const\n-  {\n-    for (auto &it : decls_within_rib)\n-      {\n-\tif (it.first == def)\n-\t  return true;\n-      }\n-    return false;\n-  }\n+  std::map<NodeId, Location> &get_declarations () { return decls_within_rib; }\n \n private:\n   CrateNum crate_num;\n@@ -160,73 +63,25 @@ class Rib\n class Scope\n {\n public:\n-  Scope (CrateNum crate_num) : crate_num (crate_num) {}\n-\n-  ~Scope () {}\n+  Scope (CrateNum crate_num);\n \n   void\n   insert (const CanonicalPath &ident, NodeId id, Location locus, bool shadow,\n-\t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb)\n-  {\n-    peek ()->insert_name (ident, id, locus, shadow, dup_cb);\n-  }\n-\n-  void insert (const CanonicalPath &ident, NodeId id, Location locus)\n-  {\n-    peek ()->insert_name (ident, id, locus, true,\n-\t\t\t  [] (const CanonicalPath &, NodeId, Location) -> void {\n-\t\t\t  });\n-  }\n+\t  std::function<void (const CanonicalPath &, NodeId, Location)> dup_cb);\n \n-  bool lookup (const CanonicalPath &ident, NodeId *id)\n-  {\n-    NodeId lookup = UNKNOWN_NODEID;\n-    iterate ([&] (Rib *r) mutable -> bool {\n-      if (r->lookup_name (ident, &lookup))\n-\treturn false;\n-      return true;\n-    });\n-\n-    *id = lookup;\n-    return lookup != UNKNOWN_NODEID;\n-  }\n+  void insert (const CanonicalPath &ident, NodeId id, Location locus);\n+  bool lookup (const CanonicalPath &ident, NodeId *id);\n \n-  void iterate (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = stack.rbegin (); it != stack.rend (); ++it)\n-      {\n-\tif (!cb (*it))\n-\t  return;\n-      }\n-  }\n+  void iterate (std::function<bool (Rib *)> cb);\n \n-  Rib *peek () { return stack.back (); }\n+  Rib *peek ();\n+  void push (NodeId id);\n+  Rib *pop ();\n \n-  void push (NodeId id) { stack.push_back (new Rib (get_crate_num (), id)); }\n-\n-  Rib *pop ()\n-  {\n-    Rib *r = peek ();\n-    stack.pop_back ();\n-    return r;\n-  }\n+  void append_reference_for_def (NodeId refId, NodeId defId);\n \n   CrateNum get_crate_num () const { return crate_num; }\n \n-  void append_reference_for_def (NodeId refId, NodeId defId)\n-  {\n-    bool ok = false;\n-    iterate ([&] (Rib *r) mutable -> bool {\n-      if (r->decl_was_declared_here (defId))\n-\t{\n-\t  ok = true;\n-\t  r->append_reference_for_def (defId, refId);\n-\t}\n-      return true;\n-    });\n-    rust_assert (ok);\n-  }\n-\n private:\n   CrateNum crate_num;\n   std::vector<Rib *> stack;\n@@ -296,74 +151,21 @@ class Resolver\n   void insert_resolved_macro (NodeId refId, NodeId defId);\n   bool lookup_resolved_macro (NodeId refId, NodeId *defId);\n \n+  void mark_decl_mutability (NodeId id, bool mut);\n+  bool decl_is_mutable (NodeId id) const;\n+  void mark_assignment_to_decl (NodeId id, NodeId assignment);\n+  size_t get_num_assignments_to_decl (NodeId id) const;\n+\n   // proxy for scoping\n   Scope &get_name_scope () { return name_scope; }\n   Scope &get_type_scope () { return type_scope; }\n   Scope &get_label_scope () { return label_scope; }\n   Scope &get_macro_scope () { return macro_scope; }\n \n   NodeId get_global_type_node_id () { return global_type_node_id; }\n-\n   void set_unit_type_node_id (NodeId id) { unit_ty_node_id = id; }\n   NodeId get_unit_type_node_id () { return unit_ty_node_id; }\n \n-  void mark_decl_mutability (NodeId id, bool mut)\n-  {\n-    rust_assert (decl_mutability.find (id) == decl_mutability.end ());\n-    decl_mutability[id] = mut;\n-  }\n-\n-  bool decl_is_mutable (NodeId id) const\n-  {\n-    auto it = decl_mutability.find (id);\n-    rust_assert (it != decl_mutability.end ());\n-    return it->second;\n-  }\n-\n-  void mark_assignment_to_decl (NodeId id, NodeId assignment)\n-  {\n-    auto it = assignment_to_decl.find (id);\n-    if (it == assignment_to_decl.end ())\n-      assignment_to_decl[id] = {};\n-\n-    assignment_to_decl[id].insert (assignment);\n-  }\n-\n-  size_t get_num_assignments_to_decl (NodeId id) const\n-  {\n-    auto it = assignment_to_decl.find (id);\n-    if (it == assignment_to_decl.end ())\n-      return 0;\n-\n-    return it->second.size ();\n-  }\n-\n-  void iterate_name_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = name_ribs.begin (); it != name_ribs.end (); it++)\n-      if (!cb (it->second))\n-\tbreak;\n-  }\n-\n-  void iterate_type_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = type_ribs.begin (); it != type_ribs.end (); it++)\n-      {\n-\tif (it->first == global_type_node_id)\n-\t  continue;\n-\n-\tif (!cb (it->second))\n-\t  break;\n-      }\n-  }\n-\n-  void iterate_label_ribs (std::function<bool (Rib *)> cb)\n-  {\n-    for (auto it = label_ribs.begin (); it != label_ribs.end (); it++)\n-      if (!cb (it->second))\n-\tbreak;\n-  }\n-\n private:\n   Resolver ();\n "}]}