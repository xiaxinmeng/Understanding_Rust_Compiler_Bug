{"sha": "195da47bbbf6402e3147dc1e6be6cacde140f7f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTk1ZGE0N2JiYmY2NDAyZTMxNDdkYzFlNmJlNmNhY2RlMTQwZjdmMw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2004-09-22T04:07:23Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2004-09-22T04:07:23Z"}, "message": "tree-ssa-ccp.c (get_default_value): If we have a constant value recorded for an SSA_NAME...\n\n\n\t* tree-ssa-ccp.c (get_default_value): If we have a constant\n\tvalue recorded for an SSA_NAME, then use that constant as\n\tthe initial lattice value.\n\t(substitute_and_fold): Transfer equivalences discovered into\n\tSSA_NAME_EQUIV.\n\n\t* tree.h (SSA_NAME_EQUIV): Add comments.\n\t(SET_SSA_NAME_EQUIV): Similarly.\n\nFrom-SVN: r87844", "tree": {"sha": "ba1ee7d893d35a339821c16a830d1a3c262c07e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba1ee7d893d35a339821c16a830d1a3c262c07e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/195da47bbbf6402e3147dc1e6be6cacde140f7f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195da47bbbf6402e3147dc1e6be6cacde140f7f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/195da47bbbf6402e3147dc1e6be6cacde140f7f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/195da47bbbf6402e3147dc1e6be6cacde140f7f3/comments", "author": null, "committer": null, "parents": [{"sha": "0a4f0294304e28e3a5012ac4e1eaf966314de0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a4f0294304e28e3a5012ac4e1eaf966314de0c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a4f0294304e28e3a5012ac4e1eaf966314de0c2"}], "stats": {"total": 45, "additions": 43, "deletions": 2}, "files": [{"sha": "b6ae90ac78218d063a1596d5137c4b3cdbd1a3de", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=195da47bbbf6402e3147dc1e6be6cacde140f7f3", "patch": "@@ -1,3 +1,14 @@\n+2004-09-21 Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-ccp.c (get_default_value): If we have a constant\n+\tvalue recorded for an SSA_NAME, then use that constant as\n+\tthe initial lattice value.\n+\t(substitute_and_fold): Transfer equivalences discovered into\n+\tSSA_NAME_EQUIV.\n+ \n+\t* tree.h (SSA_NAME_EQUIV): Add comments.\n+\t(SET_SSA_NAME_EQUIV): Similarly.\n+\n 2004-09-21  David Edelsohn  <edelsohn@gnu.org>\n \n \t* config/rs6000/linux64.h (PROCESSOR_DEFAULT64): Default to POWER4."}, {"sha": "5fe1e1de66ff04c0197b7c658444042d2a45c44e", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=195da47bbbf6402e3147dc1e6be6cacde140f7f3", "patch": "@@ -135,7 +135,14 @@ get_default_value (tree var)\n   val.lattice_val = UNDEFINED;\n   val.const_val = NULL_TREE;\n \n-  if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n+  if (TREE_CODE (var) == SSA_NAME\n+      && SSA_NAME_EQUIV (var)\n+      && is_gimple_min_invariant (SSA_NAME_EQUIV (var)))\n+    {\n+      val.lattice_val = CONSTANT;\n+      val.const_val = SSA_NAME_EQUIV (var);\n+    }\n+  else if (TREE_CODE (sym) == PARM_DECL || TREE_THIS_VOLATILE (sym))\n     {\n       /* Function arguments and volatile variables are considered VARYING.  */\n       val.lattice_val = VARYING;\n@@ -512,6 +519,7 @@ static void\n substitute_and_fold (void)\n {\n   basic_block bb;\n+  unsigned int i;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file,\n@@ -586,6 +594,25 @@ substitute_and_fold (void)\n \t    }\n \t}\n     }\n+\n+  /* And transfer what we learned from VALUE_VECTOR into the\n+     SSA_NAMEs themselves.  This probably isn't terribly important\n+     since we probably constant propagated the values to their\n+     use sites above.  */\n+  for (i = 0; i < num_ssa_names; i++)\n+    {\n+      tree name = ssa_name (i);\n+      value *value;\n+\n+      if (!name)\n+\tcontinue;\n+\n+      value = get_value (name);\n+      if (value->lattice_val == CONSTANT\n+          && is_gimple_reg (name)\n+\t  && is_gimple_min_invariant (value->const_val))\n+\tSET_SSA_NAME_EQUIV (name, value->const_val)\n+    }\n }\n \n "}, {"sha": "e2742bc5c6849111965f342226fbf66c3e84fd5f", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/195da47bbbf6402e3147dc1e6be6cacde140f7f3/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=195da47bbbf6402e3147dc1e6be6cacde140f7f3", "patch": "@@ -1304,20 +1304,23 @@ struct tree_exp GTY(())\n #define SSA_NAME_OCCURS_IN_ABNORMAL_PHI(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.asm_written_flag\n \n-\n /* Nonzero if this SSA_NAME expression is currently on the free list of\n    SSA_NAMES.  Using NOTHROW_FLAG seems reasonably safe since throwing\n    has no meaning for an SSA_NAME.  */\n #define SSA_NAME_IN_FREE_LIST(NODE) \\\n     SSA_NAME_CHECK (NODE)->common.nothrow_flag\n \n+/* If NAME is equivalent to some other SSA_NAME or an invariant, then\n+   return the equivalent SSA_NAME or invariant, else return NULL.  */\n #define SSA_NAME_EQUIV(NAME) __extension__ \\\n   ({  tree equiv = SSA_NAME_CHECK (NAME)->ssa_name.equiv; \\\n       if (equiv && TREE_CODE (equiv) == SSA_NAME) \\\n \tequiv = ssa_name (SSA_NAME_VERSION (equiv)); \\\n       equiv; \\\n    })\n \n+/* Record that NAME (an SSA_NAME) is equivalent to EQUIV.  */\n+\n #define SET_SSA_NAME_EQUIV(NAME, EQUIV)\\\n    SSA_NAME_CHECK (NAME)->ssa_name.equiv = (EQUIV);\n "}]}