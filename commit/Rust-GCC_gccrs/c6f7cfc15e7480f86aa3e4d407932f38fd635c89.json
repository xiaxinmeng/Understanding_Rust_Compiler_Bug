{"sha": "c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzZmN2NmYzE1ZTc0ODBmODZhYTNlNGQ0MDc5MzJmMzhmZDYzNWM4OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2008-08-29T11:31:40Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2008-08-29T11:31:40Z"}, "message": "tree.c (build_function_type_skip_args, [...]): New functions.\n\n\t* tree.c (build_function_type_skip_args, build_function_decl_skip_args):\n\tNew functions.\n\t* tree.h (build_function_type_skip_args, build_function_decl_skip_args):\n\tDeclare.\n\t* gimple.c (giple_copy_call_skip_args): New function.\n\t(giple_copy_call_skip_args): Declare.\n\n\t* cgraph.h (cgraph_function_versioning): Add skip_args arugmnet\n\t* ipa-cp.c (ipcp_node_not_modifiable_p): Rename to ...\n\t(ipcp_node_modifiable_p): ... this one; use tree_versionable_function_p.\n\t(ipcp_create_replace_map): Improve debug output.\n\t(ipcp_need_redirect_p): Return false when not clonning.\n\t(ipcp_update_callgraph): Skip args.\n\t(ipcp_insert_stage): UPdate call of !ipcp_node_modifiable_p;\n\tskip args.\n\t* cgraphunit.c (cgraph_function_versioning): Add skip_args argument.\n\t(save_inline_function_body): Update call of tree_function_versioning.\n\t* ipa-prop.c (ipa_edge_removal_hook): Do not ICE on unanalyzed nodes.\n\t* tree-inline.c (copy_arguments_for_versioning): Add skip_args argument.\n\t(tree_function_versioning): Likewise.\n\t* tree-inline.h (tree_function_versioning): Update prototype.\n\nFrom-SVN: r139761", "tree": {"sha": "d057c22936747f4672fd349b48d59df2628ab832", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d057c22936747f4672fd349b48d59df2628ab832"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/comments", "author": null, "committer": null, "parents": [{"sha": "efd8f7507b3ce6e4cc00c7eac4f011736ca4f14d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efd8f7507b3ce6e4cc00c7eac4f011736ca4f14d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efd8f7507b3ce6e4cc00c7eac4f011736ca4f14d"}], "stats": {"total": 318, "additions": 267, "deletions": 51}, "files": [{"sha": "c85ac793914274645718533ff34557e7df864460", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -1,3 +1,27 @@\n+2008-08-29  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c (build_function_type_skip_args, build_function_decl_skip_args):\n+\tNew functions.\n+\t* tree.h (build_function_type_skip_args, build_function_decl_skip_args):\n+\tDeclare.\n+\t* gimple.c (giple_copy_call_skip_args): New function.\n+\t(giple_copy_call_skip_args): Declare.\n+\n+\t* cgraph.h (cgraph_function_versioning): Add skip_args arugmnet\n+\t* ipa-cp.c (ipcp_node_not_modifiable_p): Rename to ...\n+\t(ipcp_node_modifiable_p): ... this one; use tree_versionable_function_p.\n+\t(ipcp_create_replace_map): Improve debug output.\n+\t(ipcp_need_redirect_p): Return false when not clonning.\n+\t(ipcp_update_callgraph): Skip args.\n+\t(ipcp_insert_stage): UPdate call of !ipcp_node_modifiable_p;\n+\tskip args.\n+\t* cgraphunit.c (cgraph_function_versioning): Add skip_args argument.\n+\t(save_inline_function_body): Update call of tree_function_versioning.\n+\t* ipa-prop.c (ipa_edge_removal_hook): Do not ICE on unanalyzed nodes.\n+\t* tree-inline.c (copy_arguments_for_versioning): Add skip_args argument.\n+\t(tree_function_versioning): Likewise.\n+\t* tree-inline.h (tree_function_versioning): Update prototype.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* loop-unswitch.c (unswitch_single_loop): Use optimize_loop_for_speed_p."}, {"sha": "5fe0eea21f2d1e438181f81f47045234d4ce8cda", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -351,7 +351,8 @@ void cgraph_reset_static_var_maps (void);\n void init_cgraph (void);\n struct cgraph_node *cgraph_function_versioning (struct cgraph_node *,\n \t\t\t\t\t\tVEC(cgraph_edge_p,heap)*,\n-\t\t\t\t\t\tvarray_type);\n+\t\t\t\t\t\tvarray_type,\n+\t\t\t\t\t\tbitmap);\n void cgraph_analyze_function (struct cgraph_node *);\n struct cgraph_node *save_inline_function_body (struct cgraph_node *);\n void record_references_in_initializer (tree);"}, {"sha": "43cdfda3aa39508c9f9ca35617603d997ba5e23d", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -1496,12 +1496,15 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n     TREE_MAP is a mapping of tree nodes we want to replace with\n     new ones (according to results of prior analysis).\n     OLD_VERSION_NODE is the node that is versioned.\n-    It returns the new version's cgraph node.  */\n+    It returns the new version's cgraph node. \n+    ARGS_TO_SKIP lists arguments to be omitted from functions\n+    */\n \n struct cgraph_node *\n cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t    VEC(cgraph_edge_p,heap) *redirect_callers,\n-\t\t\t    varray_type tree_map)\n+\t\t\t    varray_type tree_map,\n+\t\t\t    bitmap args_to_skip)\n {\n   tree old_decl = old_version_node->decl;\n   struct cgraph_node *new_version_node = NULL;\n@@ -1512,7 +1515,10 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \n   /* Make a new FUNCTION_DECL tree node for the\n      new version. */\n-  new_decl = copy_node (old_decl);\n+  if (!args_to_skip)\n+    new_decl = copy_node (old_decl);\n+  else\n+    new_decl = build_function_decl_skip_args (old_decl, args_to_skip);\n \n   /* Create the new version's call-graph node.\n      and update the edges of the new node. */\n@@ -1521,7 +1527,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t\t     redirect_callers);\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (old_decl, new_decl, tree_map, false);\n+  tree_function_versioning (old_decl, new_decl, tree_map, false, args_to_skip);\n   /* Update the call_expr on the edges to call the new version node. */\n   update_call_expr (new_version_node);\n \n@@ -1560,7 +1566,7 @@ save_inline_function_body (struct cgraph_node *node)\n   gcc_assert (first_clone == cgraph_node (first_clone->decl));\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->decl, first_clone->decl, NULL, true);\n+  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL);\n \n   DECL_EXTERNAL (first_clone->decl) = 0;\n   DECL_ONE_ONLY (first_clone->decl) = 0;"}, {"sha": "6e203b7f6f9c9434bd1f8557860c75120f971edf", "filename": "gcc/gimple.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -3180,4 +3180,37 @@ canonicalize_cond_expr_cond (tree t)\n   return NULL_TREE;\n }\n \n+/* Build call same as STMT but skipping arguments ARGS_TO_SKIP.  */\n+gimple\n+giple_copy_call_skip_args (gimple stmt, bitmap args_to_skip)\n+{\n+  int i;\n+  tree fn = gimple_call_fn (stmt);\n+  int nargs = gimple_call_num_args (stmt);\n+  VEC(tree, heap) *vargs = VEC_alloc (tree, heap, nargs);\n+  gimple new_stmt;\n+\n+  for (i = 0; i < nargs; i++)\n+    if (!bitmap_bit_p (args_to_skip, i))\n+      VEC_quick_push (tree, vargs, gimple_call_arg (stmt, i));\n+\n+  new_stmt = gimple_build_call_vec (fn, vargs);\n+  VEC_free (tree, heap, vargs);\n+  if (gimple_call_lhs (stmt))\n+    gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n+\n+  gimple_set_block (new_stmt, gimple_block (stmt));\n+  if (gimple_has_location (stmt))\n+    gimple_set_location (new_stmt, gimple_location (stmt));\n+\n+  /* Carry all the flags to the new GIMPLE_CALL.  */\n+  gimple_call_set_chain (new_stmt, gimple_call_chain (stmt));\n+  gimple_call_set_tail (new_stmt, gimple_call_tail_p (stmt));\n+  gimple_call_set_cannot_inline (new_stmt, gimple_call_cannot_inline_p (stmt));\n+  gimple_call_set_return_slot_opt (new_stmt, gimple_call_return_slot_opt_p (stmt));\n+  gimple_call_set_from_thunk (new_stmt, gimple_call_from_thunk_p (stmt));\n+  gimple_call_set_va_arg_pack (new_stmt, gimple_call_va_arg_pack_p (stmt));\n+  return new_stmt;\n+}\n+\n #include \"gt-gimple.h\""}, {"sha": "e8c0ad61616fe61cf65ab489380d9baf62c5479e", "filename": "gcc/gimple.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -4471,6 +4471,7 @@ basic_block gsi_insert_on_edge_immediate (edge, gimple);\n basic_block gsi_insert_seq_on_edge_immediate (edge, gimple_seq);\n void gsi_commit_one_edge_insert (edge, basic_block *);\n void gsi_commit_edge_inserts (void);\n+gimple giple_copy_call_skip_args (gimple, bitmap);\n \n \n /* Convenience routines to walk all statements of a gimple function."}, {"sha": "4b0a5f2c2db178ccb64c1cf0b3cd34ab1896dcd9", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 79, "deletions": 28, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -560,12 +560,11 @@ ipcp_iterate_stage (void)\n /* Check conditions to forbid constant insertion to function described by\n    NODE.  */\n static inline bool\n-ipcp_node_not_modifiable_p (struct cgraph_node *node)\n+ipcp_node_modifiable_p (struct cgraph_node *node)\n {\n-  /* ??? Handle pending sizes case.  */\n-  if (DECL_UNINLINABLE (node->decl))\n-    return true;\n-  return false;\n+  /* Once we will be able to do in-place replacement, we can be more\n+     lax here.  */\n+  return tree_versionable_function_p (node->decl);\n }\n \n /* Print count scale data structures.  */\n@@ -745,9 +744,15 @@ ipcp_create_replace_map (tree parm_tree, struct ipcp_lattice *lat)\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n-  if (dump_file)\n-    fprintf (dump_file, \"replacing param with const\\n\");\n   const_val = build_const_val (lat, TREE_TYPE (parm_tree));\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"  replacing param \");\n+      print_generic_expr (dump_file, parm_tree, 0);\n+      fprintf (dump_file, \" with const \");\n+      print_generic_expr (dump_file, const_val, 0);\n+      fprintf (dump_file, \"\\n\");\n+    }\n   replace_map->old_tree = parm_tree;\n   replace_map->new_tree = const_val;\n   replace_map->replace_p = true;\n@@ -766,6 +771,9 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n   struct ipa_jump_func *jump_func;\n   struct cgraph_node *node = cs->callee, *orig;\n \n+  if (!flag_ipa_cp_clone)\n+    return false;\n+\n   if ((orig = ipcp_get_orig_node (node)) != NULL)\n     node = orig;\n   if (ipcp_get_orig_node (cs->caller))\n@@ -791,26 +799,59 @@ ipcp_need_redirect_p (struct cgraph_edge *cs)\n static void\n ipcp_update_callgraph (void)\n {\n-  struct cgraph_node *node, *orig_callee;\n-  struct cgraph_edge *cs;\n+  struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      /* want to fix only original nodes  */\n-      if (!node->analyzed || ipcp_node_is_clone (node))\n-\tcontinue;\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\tif (ipcp_node_is_clone (cs->callee))\n+    if (node->analyzed && ipcp_node_is_clone (node))\n+      {\n+\tbitmap args_to_skip = BITMAP_ALLOC (NULL);\n+\tstruct cgraph_node *orig_node = ipcp_get_orig_node (node);\n+        struct ipa_node_params *info = IPA_NODE_REF (orig_node);\n+        int i, count = ipa_get_param_count (info);\n+        struct cgraph_edge *cs, *next;\n+\n+\tfor (i = 0; i < count; i++)\n \t  {\n-\t    /* Callee is a cloned node  */\n-\t    orig_callee = ipcp_get_orig_node (cs->callee);\n-\t    if (ipcp_need_redirect_p (cs))\n+\t    struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n+\t    tree parm_tree = ipa_get_ith_param (info, i);\n+\n+\t    /* We can proactively remove obviously unused arguments.  */\n+\t    if (is_gimple_reg (parm_tree)\n+\t\t&& !gimple_default_def (DECL_STRUCT_FUNCTION (orig_node->decl),\n+\t\t\t\t\tparm_tree))\n \t      {\n-\t\tcgraph_redirect_edge_callee (cs, orig_callee);\n-\t\tgimple_call_set_fndecl (cs->call_stmt, orig_callee->decl);\n+\t\tbitmap_set_bit (args_to_skip, i);\n+\t\tcontinue;\n \t      }\n+\n+\t    if (lat->type == IPA_CONST_VALUE)\n+\t      bitmap_set_bit (args_to_skip, i);\n \t  }\n-    }\n+\tfor (cs = node->callers; cs; cs = next)\n+\t  {\n+\t    next = cs->next_caller;\n+\t    if (ipcp_node_is_clone (cs->caller) || !ipcp_need_redirect_p (cs))\n+\t      {\n+\t\tgimple new_stmt;\n+\t\tgimple_stmt_iterator gsi;\n+\n+\t\tcurrent_function_decl = cs->caller->decl;\n+\t        push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n+\t\t\n+\t\tnew_stmt = giple_copy_call_skip_args (cs->call_stmt, args_to_skip);\n+\t\tgsi = gsi_for_stmt (cs->call_stmt);\n+\t\tgsi_replace (&gsi, new_stmt, true);\n+\t\tcgraph_set_call_stmt (cs, new_stmt);\n+\t        pop_cfun ();\n+\t\tcurrent_function_decl = NULL;\n+\t      }\n+\t    else\n+\t      {\n+\t\tcgraph_redirect_edge_callee (cs, orig_node);\n+\t\tgimple_call_set_fndecl (cs->call_stmt, orig_node->decl);\n+\t      }\n+\t  }\n+      }\n }\n \n /* Update all cfg basic blocks in NODE according to SCALE.  */\n@@ -989,7 +1030,7 @@ ipcp_insert_stage (void)\n     {\n       struct ipa_node_params *info;\n       /* Propagation of the constant is forbidden in certain conditions.  */\n-      if (!node->analyzed || ipcp_node_not_modifiable_p (node))\n+      if (!node->analyzed || !ipcp_node_modifiable_p (node))\n \t  continue;\n       info = IPA_NODE_REF (node);\n       if (ipa_is_called_with_var_arguments (info))\n@@ -1004,6 +1045,7 @@ ipcp_insert_stage (void)\n     {\n       struct ipa_node_params *info;\n       int growth = 0;\n+      bitmap args_to_skip;\n \n       node = (struct cgraph_node *)fibheap_extract_min (heap);\n       node->aux = NULL;\n@@ -1033,20 +1075,27 @@ ipcp_insert_stage (void)\n \n       VARRAY_GENERIC_PTR_INIT (replace_trees, ipcp_const_param_count (node),\n \t\t\t\t\"replace_trees\");\n+      args_to_skip = BITMAP_ALLOC (NULL);\n       for (i = 0; i < count; i++)\n \t{\n \t  struct ipcp_lattice *lat = ipcp_get_ith_lattice (info, i);\n \t  parm_tree = ipa_get_ith_param (info, i);\n \n-\t  if (lat->type == IPA_CONST_VALUE\n-\t      /* Do not count obviously unused arguments.  */\n-\t      && (!is_gimple_reg (parm_tree)\n-\t\t  || gimple_default_def (DECL_STRUCT_FUNCTION (node->decl),\n-\t\t\t\t\t parm_tree)))\n+\t  /* We can proactively remove obviously unused arguments.  */\n+\t  if (is_gimple_reg (parm_tree)\n+\t      && !gimple_default_def (DECL_STRUCT_FUNCTION (node->decl),\n+\t\t\t\t      parm_tree))\n+\t    {\n+\t      bitmap_set_bit (args_to_skip, i);\n+\t      continue;\n+\t    }\n+\n+\t  if (lat->type == IPA_CONST_VALUE)\n \t    {\n \t      replace_param =\n \t\tipcp_create_replace_map (parm_tree, lat);\n \t      VARRAY_PUSH_GENERIC_PTR (replace_trees, replace_param);\n+\t      bitmap_set_bit (args_to_skip, i);\n \t    }\n \t}\n \n@@ -1061,7 +1110,9 @@ ipcp_insert_stage (void)\n       /* Redirecting all the callers of the node to the\n          new versioned node.  */\n       node1 =\n-\tcgraph_function_versioning (node, redirect_callers, replace_trees);\n+\tcgraph_function_versioning (node, redirect_callers, replace_trees,\n+\t\t\t\t    args_to_skip);\n+      BITMAP_FREE (args_to_skip);\n       VEC_free (cgraph_edge_p, heap, redirect_callers);\n       VARRAY_CLEAR (replace_trees);\n       if (node1 == NULL)"}, {"sha": "9a31b0241131cf20a908704a8a50c5d31370ea8b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -1057,6 +1057,10 @@ static void\n ipa_edge_removal_hook (struct cgraph_edge *cs,\n \t\t       void *data __attribute__ ((unused)))\n {\n+  /* During IPA-CP updating we can be called on not-yet analyze clones.  */\n+  if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n+      <= (unsigned)cs->uid)\n+    return;\n   ipa_free_edge_args_substructures (IPA_EDGE_REF (cs));\n }\n "}, {"sha": "eb95cc6624a090a78ed2bf31fc8efb33cfa484d3", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -4089,19 +4089,37 @@ copy_decl_maybe_to_var (tree decl, copy_body_data *id)\n \n /* Return a copy of the function's argument tree.  */\n static tree\n-copy_arguments_for_versioning (tree orig_parm, copy_body_data * id)\n+copy_arguments_for_versioning (tree orig_parm, copy_body_data * id,\n+\t\t\t       bitmap args_to_skip, tree *vars)\n {\n-  tree *arg_copy, *parg;\n+  tree arg, *parg;\n+  tree new_parm = NULL;\n+  int i = 0;\n \n-  arg_copy = &orig_parm;\n-  for (parg = arg_copy; *parg; parg = &TREE_CHAIN (*parg))\n-    {\n-      tree new_tree = remap_decl (*parg, id);\n-      lang_hooks.dup_lang_specific_decl (new_tree);\n-      TREE_CHAIN (new_tree) = TREE_CHAIN (*parg);\n-      *parg = new_tree;\n-    }\n-  return orig_parm;\n+  parg = &new_parm;\n+\n+  for (arg = orig_parm; arg; arg = TREE_CHAIN (arg), i++)\n+    if (!args_to_skip || !bitmap_bit_p (args_to_skip, i))\n+      {\n+        tree new_tree = remap_decl (arg, id);\n+        lang_hooks.dup_lang_specific_decl (new_tree);\n+        *parg = new_tree;\n+\tparg = &TREE_CHAIN (new_tree);\n+      }\n+    else\n+      {\n+\t/* Make an equivalent VAR_DECL.  If the argument was used\n+\t   as temporary variable later in function, the uses will be\n+\t   replaced by local variable.  */\n+\ttree var = copy_decl_to_var (arg, id);\n+\tget_var_ann (var);\n+\tadd_referenced_var (var);\n+\tinsert_decl_map (id, arg, var);\n+        /* Declare this new variable.  */\n+        TREE_CHAIN (var) = *vars;\n+        *vars = var;\n+      }\n+  return new_parm;\n }\n \n /* Return a copy of the function's static chain.  */\n@@ -4146,7 +4164,7 @@ tree_versionable_function_p (tree fndecl)\n    of edges of clones of the function will be updated.  */\n void\n tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n-\t\t\t  bool update_clones)\n+\t\t\t  bool update_clones, bitmap args_to_skip)\n {\n   struct cgraph_node *old_version_node;\n   struct cgraph_node *new_version_node;\n@@ -4214,7 +4232,8 @@ tree_function_versioning (tree old_decl, tree new_decl, varray_type tree_map,\n   /* Copy the function's arguments.  */\n   if (DECL_ARGUMENTS (old_decl) != NULL_TREE)\n     DECL_ARGUMENTS (new_decl) =\n-      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id);\n+      copy_arguments_for_versioning (DECL_ARGUMENTS (old_decl), &id,\n+      \t\t\t\t     args_to_skip, &vars);\n   \n   DECL_INITIAL (new_decl) = remap_blocks (DECL_INITIAL (id.src_fn), &id);\n   "}, {"sha": "5fb4f638c1d508976095c282475d90de47f821c1", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -156,7 +156,7 @@ int estimate_num_insns (gimple, eni_weights *);\n int estimate_num_insns_fn (tree, eni_weights *);\n int count_insns_seq (gimple_seq, eni_weights *);\n bool tree_versionable_function_p (tree);\n-void tree_function_versioning (tree, tree, varray_type, bool);\n+void tree_function_versioning (tree, tree, varray_type, bool, bitmap);\n bool tree_can_inline_p (tree, tree);\n \n extern gimple_seq remap_gimple_seq (gimple_seq, copy_body_data *);"}, {"sha": "5b9245958e105231daed960d96e1571c0354dc19", "filename": "gcc/tree.c", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -5878,6 +5878,81 @@ build_function_type (tree value_type, tree arg_types)\n   return t;\n }\n \n+/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP.  */\n+\n+tree\n+build_function_type_skip_args (tree orig_type, bitmap args_to_skip)\n+{\n+  tree new_type = NULL;\n+  tree args, new_args = NULL, t;\n+  tree new_reversed;\n+  int i = 0;\n+\n+  for (args = TYPE_ARG_TYPES (orig_type); args && args != void_list_node;\n+       args = TREE_CHAIN (args), i++)\n+    if (!bitmap_bit_p (args_to_skip, i))\n+      new_args = tree_cons (NULL_TREE, TREE_VALUE (args), new_args);\n+\n+  new_reversed = nreverse (new_args);\n+  if (args)\n+    {\n+      if (new_reversed)\n+        TREE_CHAIN (new_args) = void_list_node;\n+      else\n+\tnew_reversed = void_list_node;\n+    }\n+    gcc_assert (new_reversed);\n+\n+  /* Use copy_node to preserve as much as possible from original type\n+     (debug info, attribute lists etc.)\n+     Exception is METHOD_TYPEs must have THIS argument.\n+     When we are asked to remove it, we need to build new FUNCTION_TYPE\n+     instead.  */\n+  if (TREE_CODE (orig_type) != METHOD_TYPE\n+      || !bitmap_bit_p (args_to_skip, 0))\n+    {\n+      new_type = copy_node (orig_type);\n+      TYPE_ARG_TYPES (new_type) = new_reversed;\n+    }\n+  else\n+    new_type = build_function_type (TREE_TYPE (orig_type), new_reversed);\n+\n+  /* This is a new type, not a copy of an old type.  Need to reassociate\n+     variants.  We can handle everything except the main variant lazily.  */\n+  t = TYPE_MAIN_VARIANT (orig_type);\n+  if (orig_type != t)\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = t;\n+      TYPE_NEXT_VARIANT (new_type) = TYPE_NEXT_VARIANT (t);\n+      TYPE_NEXT_VARIANT (t) = new_type;\n+    }\n+  else\n+    {\n+      TYPE_MAIN_VARIANT (new_type) = new_type;\n+      TYPE_NEXT_VARIANT (new_type) = NULL;\n+    }\n+  return new_type;\n+}\n+\n+/* Build variant of function type ORIG_TYPE skipping ARGS_TO_SKIP.  \n+  \n+   Arguments from DECL_ARGUMENTS list can't be removed now, since they are\n+   linked by TREE_CHAIN directly.  It is caller responsibility to eliminate\n+   them when they are being duplicated (i.e. copy_arguments_for_versioning).  */\n+\n+tree\n+build_function_decl_skip_args (tree orig_decl, bitmap args_to_skip)\n+{\n+  tree new_decl = copy_node (orig_decl);\n+  tree new_type;\n+\n+  new_type = TREE_TYPE (orig_decl);\n+  if (prototype_p (new_type))\n+    new_type = build_function_type_skip_args (new_type, args_to_skip);\n+  TREE_TYPE (orig_decl) = new_type;\n+  return new_decl;\n+}\n+\n /* Build a function type.  The RETURN_TYPE is the type returned by the\n    function. If VAARGS is set, no void_type_node is appended to the\n    the list. ARGP muse be alway be terminated be a NULL_TREE.  */\n@@ -5893,9 +5968,9 @@ build_function_type_list_1 (bool vaargs, tree return_type, va_list argp)\n \n   if (vaargs)\n     {\n-\t  last = args;\n-\t  if (args != NULL_TREE)\n-\t    args = nreverse (args);\n+      last = args;\n+      if (args != NULL_TREE)\n+\targs = nreverse (args);\n       gcc_assert (args != NULL_TREE && last != void_list_node);\n     }\n   else if (args == NULL_TREE)"}, {"sha": "775d28162d95f17866587f2ae8470dfc20a3f471", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6f7cfc15e7480f86aa3e4d407932f38fd635c89/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c6f7cfc15e7480f86aa3e4d407932f38fd635c89", "patch": "@@ -3994,6 +3994,8 @@ extern tree build_index_2_type (tree, tree);\n extern tree build_array_type (tree, tree);\n extern tree build_function_type (tree, tree);\n extern tree build_function_type_list (tree, ...);\n+extern tree build_function_type_skip_args (tree, bitmap);\n+extern tree build_function_decl_skip_args (tree, bitmap);\n extern tree build_varargs_function_type_list (tree, ...);\n extern tree build_method_type_directly (tree, tree, tree);\n extern tree build_method_type (tree, tree);"}]}