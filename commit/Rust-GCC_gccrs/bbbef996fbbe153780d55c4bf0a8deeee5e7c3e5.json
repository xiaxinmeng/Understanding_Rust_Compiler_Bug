{"sha": "bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmJiZWY5OTZmYmJlMTUzNzgwZDU1YzRiZjBhOGRlZWVlNWU3YzNlNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2018-11-22T23:10:57Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-11-22T23:10:57Z"}, "message": "re PR lto/88142 (ICE in lto_warn at ipa-devirt.c:1020 since r265519)\n\n\n\tPR lto/88142\n\t* ipa-devirt.c (type_variants_equivalent_p): Drop warn and warned\n\tparameters; do not warn here.\n\t(odr_subtypes_equivalent_p): Likewise.\n\t(warn_odr): Fix typo.\n\t(warn_types_mismatch): Do not output confused warnings on integer types.\n\t(odr_types_equivalent_p): Update.\n\n\t* g++.dg/lto/odr-5_0.C: New testcase.\n\t* g++.dg/lto/odr-5_1.C: New testcase.\n\nFrom-SVN: r266396", "tree": {"sha": "b888de064a3861f4602fabf1e6ad29106fb95261", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b888de064a3861f4602fabf1e6ad29106fb95261"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/comments", "author": null, "committer": null, "parents": [{"sha": "d7dce787ebe0df76e9811d3565ad3ce113bfee78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7dce787ebe0df76e9811d3565ad3ce113bfee78", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7dce787ebe0df76e9811d3565ad3ce113bfee78"}], "stats": {"total": 94, "additions": 60, "deletions": 34}, "files": [{"sha": "fe222bad9e0fd43d26048a4b380d0bb8ff390153", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -1,3 +1,13 @@\n+2018-11-22  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/88142\n+\t* ipa-devirt.c (type_variants_equivalent_p): Drop warn and warned\n+\tparameters; do not warn here.\n+\t(odr_subtypes_equivalent_p): Likewise.\n+\t(warn_odr): Fix typo.\n+\t(warn_types_mismatch): Do not output confused warnings on integer types.\n+\t(odr_types_equivalent_p): Update.\n+\n 2018-11-22  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/i386/i386.c (ix86_option_override_internal,"}, {"sha": "9c6e2718353e4d475e33c06f6359a09350d36079", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -636,40 +636,25 @@ set_type_binfo (tree type, tree binfo)\n    same type.  */\n \n static bool\n-type_variants_equivalent_p (tree t1, tree t2, bool warn, bool *warned)\n+type_variants_equivalent_p (tree t1, tree t2)\n {\n   if (TYPE_QUALS (t1) != TYPE_QUALS (t2))\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t        G_(\"a type with different qualifiers is defined in another \"\n-\t\t   \"translation unit\"));\n-      return false;\n-    }\n+    return false;\n \n   if (comp_type_attributes (t1, t2) != 1)\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t        G_(\"a type with different attributes \"\n-\t\t   \"is defined in another translation unit\"));\n-      return false;\n-    }\n+    return false;\n \n   if (COMPLETE_TYPE_P (t1) && COMPLETE_TYPE_P (t2)\n       && TYPE_ALIGN (t1) != TYPE_ALIGN (t2))\n-    {\n-      warn_odr (t1, t2, NULL, NULL, warn, warned,\n-\t\tG_(\"a type with different alignment \"\n-\t\t   \"is defined in another translation unit\"));\n-      return false;\n-    }\n+    return false;\n \n   return true;\n }\n \n /* Compare T1 and T2 based on name or structure.  */\n \n static bool\n-odr_subtypes_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n+odr_subtypes_equivalent_p (tree t1, tree t2,\n \t\t\t   hash_set<type_pair> *visited,\n \t\t\t   location_t loc1, location_t loc2)\n {\n@@ -698,7 +683,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \treturn false;\n       if (!types_same_for_odr (t1, t2))\n         return false;\n-      if (!type_variants_equivalent_p (t1, t2, warn, warned))\n+      if (!type_variants_equivalent_p (t1, t2))\n \treturn false;\n       /* Limit recursion: If subtypes are ODR types and we know\n \t that they are same, be happy.  */\n@@ -725,7 +710,7 @@ odr_subtypes_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   if (!odr_types_equivalent_p (TYPE_MAIN_VARIANT (t1), TYPE_MAIN_VARIANT (t2),\n \t\t\t      false, NULL, visited, loc1, loc2))\n     return false;\n-  if (!type_variants_equivalent_p (t1, t2, warn, warned))\n+  if (!type_variants_equivalent_p (t1, t2))\n     return false;\n   return true;\n }\n@@ -1017,7 +1002,7 @@ warn_odr (tree t1, tree t2, tree st1, tree st2,\n \n   auto_diagnostic_group d;\n   if (t1 != TYPE_MAIN_VARIANT (t1)\n-      && TYPE_NAME (t1) != DECL_NAME (TYPE_MAIN_VARIANT (t1)))\n+      && TYPE_NAME (t1) != TYPE_NAME (TYPE_MAIN_VARIANT (t1)))\n     {\n       if (!warning_at (DECL_SOURCE_LOCATION (TYPE_NAME (TYPE_MAIN_VARIANT (t1))),\n \t\t       OPT_Wodr, \"type %qT (typedef of %qT) violates the \"\n@@ -1279,6 +1264,11 @@ warn_types_mismatch (tree t1, tree t2, location_t loc1, location_t loc2)\n     }\n \n   if (types_odr_comparable (t1, t2)\n+      /* We make assign integers mangled names to be able to handle\n+\t signed/unsigned chars.  Accepting them here would however lead to\n+\t confussing message like\n+\t \"type \u2018const int\u2019 itself violates the C++ One Definition Rule\"  */\n+      && TREE_CODE (t1) != INTEGER_TYPE\n       && types_same_for_odr (t1, t2))\n     inform (loc_t1,\n \t    \"type %qT itself violates the C++ One Definition Rule\", t1);\n@@ -1410,7 +1400,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t    }\n \n \t  if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t  warn, warned, visited, loc1, loc2))\n+\t\t\t\t\t  visited, loc1, loc2))\n \t    {\n \t      warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t\tG_(\"it is defined as a pointer to different type \"\n@@ -1424,7 +1414,6 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \n       if ((TREE_CODE (t1) == VECTOR_TYPE || TREE_CODE (t1) == COMPLEX_TYPE)\n \t  && !odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\t warn, warned,\n \t\t\t\t\t visited, loc1, loc2))\n \t{\n \t  /* Probably specific enough.  */\n@@ -1444,7 +1433,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t/* Array types are the same if the element types are the same and\n \t   the number of elements are the same.  */\n \tif (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t\twarn, warned, visited, loc1, loc2))\n+\t\t\t\t\tvisited, loc1, loc2))\n \t  {\n \t    warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t      G_(\"a different type is defined in another \"\n@@ -1462,7 +1451,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t/* For an incomplete external array, the type domain can be\n \t   NULL_TREE.  Check this condition also.  */\n \tif (i1 == NULL_TREE || i2 == NULL_TREE)\n-          return type_variants_equivalent_p (t1, t2, warn, warned);\n+          return type_variants_equivalent_p (t1, t2);\n \n \ttree min1 = TYPE_MIN_VALUE (i1);\n \ttree min2 = TYPE_MIN_VALUE (i2);\n@@ -1486,7 +1475,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n       if (!odr_subtypes_equivalent_p (TREE_TYPE (t1), TREE_TYPE (t2),\n-\t\t\t\t      warn, warned, visited, loc1, loc2))\n+\t\t\t\t      visited, loc1, loc2))\n \t{\n \t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n \t\t    G_(\"has different return value \"\n@@ -1498,7 +1487,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \n       if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2)\n \t  || !prototype_p (t1) || !prototype_p (t2))\n-        return type_variants_equivalent_p (t1, t2, warn, warned);\n+        return type_variants_equivalent_p (t1, t2);\n       else\n \t{\n \t  tree parms1, parms2;\n@@ -1508,7 +1497,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n \t      if (!odr_subtypes_equivalent_p\n-\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2), warn, warned,\n+\t\t     (TREE_VALUE (parms1), TREE_VALUE (parms2),\n \t\t      visited, loc1, loc2))\n \t\t{\n \t\t  warn_odr (t1, t2, NULL, NULL, warn, warned,\n@@ -1529,7 +1518,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t      return false;\n \t    }\n \n-          return type_variants_equivalent_p (t1, t2, warn, warned);\n+          return type_variants_equivalent_p (t1, t2);\n \t}\n \n     case RECORD_TYPE:\n@@ -1589,7 +1578,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n \t\t    return false;\n \t\t  }\n \t\tif (!odr_subtypes_equivalent_p (TREE_TYPE (f1),\n-\t\t\t\t\t\tTREE_TYPE (f2), warn, warned,\n+\t\t\t\t\t\tTREE_TYPE (f2),\n \t\t\t\t\t\tvisited, loc1, loc2))\n \t\t  {\n \t\t    /* Do not warn about artificial fields and just go into\n@@ -1671,7 +1660,7 @@ odr_types_equivalent_p (tree t1, tree t2, bool warn, bool *warned,\n   gcc_assert (!TYPE_SIZE_UNIT (t1) || !TYPE_SIZE_UNIT (t2)\n \t      || operand_equal_p (TYPE_SIZE_UNIT (t1),\n \t\t\t\t  TYPE_SIZE_UNIT (t2), 0));\n-  return type_variants_equivalent_p (t1, t2, warn, warned);\n+  return type_variants_equivalent_p (t1, t2);\n }\n \n /* Return true if TYPE1 and TYPE2 are equivalent for One Definition Rule.  */"}, {"sha": "de9e415ab3c2f93360bfbe4ffa9057ec1c01e019", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -1,3 +1,9 @@\n+2018-11-22  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR lto/88142\n+\t* g++.dg/lto/odr-5_0.C: New testcase.\n+\t* g++.dg/lto/odr-5_1.C: New testcase.\n+\n 2018-11-22  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* g++.dg/lto/odr-2_0.C: Drop dg-lto-options."}, {"sha": "f0a92ba48b855154c506abc27cc4a083847bd4b6", "filename": "gcc/testsuite/g++.dg/lto/odr-4_0.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-4_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-4_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-4_0.C?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -1,5 +1,5 @@\n // { dg-lto-do link }\n-// { dg-lto-options { -O2 -flto }  } \n+// { dg-lto-options { \"-O2 -flto\" }  } \n struct B {\n   enum class E { V0, V1 };\n   virtual ~B();"}, {"sha": "42819490da3c4f50913320a089671bdded957384", "filename": "gcc/testsuite/g++.dg/lto/odr-5_0.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_0.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_0.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_0.C?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -0,0 +1,12 @@\n+// { dg-lto-do link }\n+struct wiimote_t { // { dg-lto-message \"type\" 2 }\n+  // Here we get two warnings:\n+  // warning: type 'struct wiimote_t' violates the C++ One Definition Rule\n+  // note: type 'const int' should match type 'int'\n+  const int unid; // { dg-lto-message \"the first difference of corresponding definitions is field 'unid'\" 1 }\n+} * a; \n+\n+int\n+main()\n+{\n+}"}, {"sha": "f7f69379085ef9db3c986bd6af49e770e5ff6b81", "filename": "gcc/testsuite/g++.dg/lto/odr-5_1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flto%2Fodr-5_1.C?ref=bbbef996fbbe153780d55c4bf0a8deeee5e7c3e5", "patch": "@@ -0,0 +1,9 @@\n+struct wiimote_t;\n+class a {\n+  wiimote_t *b;\n+  a();\n+};\n+struct wiimote_t { // { dg-lto-message \"a different type is defined in another translation unit\" }\n+  int unid; // { dg-lto-message \"a field of same name but different type is defined in another translation unit\" }\n+};\n+a::a() { b = __null; }"}]}