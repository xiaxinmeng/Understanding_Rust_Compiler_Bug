{"sha": "61abc2ca7a92093b27890da2e062193287453c6c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhYmMyY2E3YTkyMDkzYjI3ODkwZGEyZTA2MjE5MzI4NzQ1M2M2Yw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T03:06:39Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-05-05T03:06:39Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r895", "tree": {"sha": "c55358c9062c68bef71a83b0bb7319c867a63423", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c55358c9062c68bef71a83b0bb7319c867a63423"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61abc2ca7a92093b27890da2e062193287453c6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61abc2ca7a92093b27890da2e062193287453c6c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61abc2ca7a92093b27890da2e062193287453c6c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61abc2ca7a92093b27890da2e062193287453c6c/comments", "author": null, "committer": null, "parents": [{"sha": "eaed71194c7fdd8fce9b06a6609440403bd7d349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eaed71194c7fdd8fce9b06a6609440403bd7d349", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eaed71194c7fdd8fce9b06a6609440403bd7d349"}], "stats": {"total": 494, "additions": 180, "deletions": 314}, "files": [{"sha": "24d2d44631699f0f3bbbbc7592d75f9ad6b07e68", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 180, "deletions": 314, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61abc2ca7a92093b27890da2e062193287453c6c/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61abc2ca7a92093b27890da2e062193287453c6c/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=61abc2ca7a92093b27890da2e062193287453c6c", "patch": "@@ -90,10 +90,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #include \"obstack.h\"\n #include \"insn-config.h\"\t/* For REGISTER_CONSTRAINTS */\n \n-static struct obstack obstack, obstack1, obstack2;\n+static struct obstack obstack, obstack1;\n struct obstack *rtl_obstack = &obstack;\n struct obstack *hash_obstack = &obstack1;\n-struct obstack *accum_obstack = &obstack2;\n \n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n@@ -276,8 +275,8 @@ static rtx insert_right_side ();\n static rtx make_alternative_compare ();\n static int compute_alternative_mask ();\n static rtx evaluate_eq_attr ();\n-/* static rtx simplify_and_tree ();\n-static rtx simplify_or_tree (); */\n+static rtx simplify_and_tree ();\n+static rtx simplify_or_tree ();\n static rtx simplify_test_exp ();\n static void optimize_attrs ();\n static void gen_attr ();\n@@ -2066,288 +2065,6 @@ evaluate_eq_attr (exp, value, insn_code, insn_index)\n     return newexp;\n }\n \f\n-/* These are used by simplify_boolean to accumulate and sort terms.  */\n-\n-struct term\n-{\n-  rtx exp;\n-  int hash;\n-  int ignore;\n-  struct term *next;\n-};\n-\n-struct term *termlist;\n-\n-void\n-extract_terms (code, exp, pnterms, insn_code, insn_index)\n-     enum rtx_code code;\n-     rtx exp;\n-     int *pnterms;\n-     int insn_code, insn_index;\n-{\n-  if (GET_CODE (exp) == code)\n-    {\n-      extract_terms (code, XEXP (exp, 0), pnterms, insn_code, insn_index);\n-      extract_terms (code, XEXP (exp, 1), pnterms, insn_code, insn_index);\n-    }\n-  else\n-    {\n-      struct term *save = termlist;\n-      exp = SIMPLIFY_TEST_EXP (exp, insn_code, insn_index);\n-      termlist = save;\n-\n-      if (GET_CODE (exp) == code)\n-\t{\n-\t  extract_terms (code, XEXP (exp, 0), pnterms, insn_code, insn_index);\n-\t  extract_terms (code, XEXP (exp, 1), pnterms, insn_code, insn_index);\n-\t}\n-      else\n-\t{\n-\t  struct term t;\n-\t  t.exp = exp;\n-\t  t.hash = hash_term (exp);\n-\t  t.ignore = 0;\n-\t  t.next = termlist;\n-\t  termlist = (struct term *) obstack_copy (accum_obstack,\n-\t\t\t\t\t\t   &t, sizeof t);\n-\n-\t  (*pnterms)++;\n-\t}\n-    }\n-}\n-\n-/* Compare two terms for sorting.\n-   This particular sort function treats any term and its negation as \"equal\"\n-   so that they sort together.  */\n-\n-int\n-compare_terms (pt1, pt2)\n-     struct term *pt1, *pt2;\n-{\n-  return pt1->hash - pt2->hash;\n-}\n-\n-int\n-hash_term (term)\n-     rtx term;\n-{\n-  while (GET_CODE (term) == NOT)\n-    term = XEXP (term, 0);\n-\n-  if (RTX_UNCHANGING_P (term))\n-    return (int) term;\n-\n-  switch (GET_CODE (term))\n-    {\n-    case AND:\n-      return (hash_term (XEXP (term, 0))\n-\t      + (hash_term (XEXP (term, 1)) << 3)\n-\t      + (int) AND);\n-\n-    case IOR:\n-      return (hash_term (XEXP (term, 0))\n-\t      + (hash_term (XEXP (term, 1)) << 4)\n-\t      + (int) IOR);\n-\n-    default:\n-      return (int) term;\n-    }\n-}\n-\f\n-/* Simplify a boolean expression made from applying CODE (which is AND or IOR)\n-   to the two expressions EXP1 and EXP2.\n-\n-   EXP3 is another expression we can assume is true (if CODE is AND)\n-   or assume is false (if CODE is IOR).\n-\n-   STABLE is either true or false.\n-   It is the truth value which, when input to CODE, makes itself the output.\n-   UNSTABLE is the other truth value: the one which is CODE of no operands.  */\n-\n-rtx\n-simplify_boolean (code, exp1, exp2, exp3, stable, unstable,\n-\t\t  insn_code, insn_index)\n-     enum rtx_code code;\n-     rtx exp1, exp2, exp3;\n-     rtx stable, unstable;\n-     int insn_code, insn_index;\n-{\n-  struct term *vector;\n-  int nterms = 0;\n-  int nignores = 0;\n-  int i, j;\n-  char *spacer = (char *) obstack_finish (accum_obstack);\n-  rtx combined;\n-  rtx common_term;\n-  enum rtx_code other_code = (code == AND ? IOR : AND);\n-  static struct term dummy = {0, 0, 0, 0};\n-\n-  termlist = 0;\n-\n-  nterms = 1; /* Count one dummy element.  */\n-  extract_terms (code, exp1, &nterms, insn_code, insn_index);\n-  if (exp2)\n-    extract_terms (code, exp2, &nterms, insn_code, insn_index);\n-\n-  if (exp3)\n-    extract_terms (code, exp3, &nignores, insn_code, insn_index);\n-  nterms += nignores;\n-\n-  vector = (struct term *) alloca (nterms * sizeof (struct term));\n-\n-  /* Copy the terms from the list into the vector.\n-     Set the ignore flag in those which came from EXP3.\n-     That way, we won't include them in the final result.  */\n-\n-  vector[0] = dummy;\n-  for (i = 1; i < nterms; i++)\n-    {\n-      vector[i] = *termlist;\n-      if (i < nignores)\n-\tvector[i].ignore = 1;\n-      termlist = termlist->next;\n-    }\n-  \n-  /* Free what we used in the obstack.  */\n-  obstack_free (accum_obstack, spacer);\n-\n-  qsort (vector, nterms, sizeof (struct term), compare_terms);\n-\n-  if (insn_code >= 0)\n-    {\n-      i = (compute_alternative_mask (exp1, code)\n-\t   & compute_alternative_mask (exp2, code));\n-      if (i & ~insn_alternatives[insn_code])\n-\tfatal (\"invalid alternative specified for pattern number %d\",\n-\t       insn_index);\n-\n-      /* If all alternatives are excluded for AND (included for IOR),\n-\t this is false (true). */\n-      i ^= insn_alternatives[insn_code];\n-      if (i == 0)\n-\t{\n-\t  return stable;\n-\t}\n-      else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n-\t{\n-\t  /* If just one included for AND (excluded for IOR),\n-\t     add one term which tests for that alternative.\n-\t     We do not want to do this if the insn has one\n-\t     alternative and we have tested none of them!  */\n-\t  vector[0].exp = make_alternative_compare (i);\n-\t  if (code == IOR)\n-\t    vector[0].exp = attr_rtx (NOT, vector[0].exp);\n-\t}\n-    }\n-\n-  /* Try distributive law in one simple way.  */\n-  common_term = 0;\n-  for (i = 0; i < nterms; i++)\n-    if (vector[i].exp != 0)\n-      {\n-\tif (GET_CODE (vector[i].exp) != other_code)\n-\t  break;\n-\tif (common_term == 0)\n-\t  common_term = XEXP (vector[i].exp, 0);\n-\telse if (!rtx_equal_p (XEXP (vector[i].exp, 0), common_term))\n-\t  break;\n-      }\n-  if (i != nterms)\n-    common_term = 0;\n-\n-  /* If we found a subterm in common, remove it from each term.  */\n-  if (common_term)\n-    for (i = 0; i < nterms; i++)\n-      if (vector[i].exp != 0)\n-\tvector[i].exp = XEXP (vector[i].exp, 1);\n-\n-  /* See if any two adjacent terms are equivalent or contrary.\n-     Equivalent or contrary terms should be adjacent because of sorting.  */\n-  for (i = 0; i < nterms - 1; i++)\n-    {\n-      rtx base0 = vector[i].exp;\n-      rtx base1 = vector[i + 1].exp;\n-      if (base0 != 0 && base1 != 0)\n-\t{\n-\t  if (GET_CODE (base0) == NOT)\n-\t    base0 = XEXP (base0, 0);\n-\t  if (GET_CODE (base1) == NOT)\n-\t    base1 = XEXP (base1, 0);\n-\t  if (rtx_equal_p (base0, base1))\n-\t    {\n-\t      if (! rtx_equal_p (vector[i].exp, vector[i + 1].exp))\n-\t\t{\n-\t\t  /* There are two contrary terms:\n-\t\t     The value is true for IOR, false for AND.  */\n-\t\t  return common_term ? common_term : stable;\n-\t\t}\n-\t      /* Delete one of a pair of equivalent terms.  */\n-\t      vector[i].exp = 0;\n-\t      vector[i].ignore |= vector[i + 1].ignore;\n-\t    }\n-\t}\n-    }\n-\n-  /* Take advantage of the fact that two different values for the same\n-     attribute are contradictory.  */\n-  if (code == AND)\n-    {\n-      for (i = 0; i < nterms; i++)\n-\tif (vector[i].exp != 0 && GET_CODE (vector[i].exp) == EQ_ATTR)\n-\t  {\n-\t    char *aname = XSTR (vector[i].exp, 0);\n-\n-\t    for (j = i + 1; j < nterms; j++)\n-\t      {\n-\t\tif (vector[j].exp != 0 && GET_CODE (vector[j].exp) == EQ_ATTR\n-\t\t    && XSTR (vector[i].exp, 0) == aname)\n-\t\t  {\n-\t\t    return common_term ? common_term : stable;\n-\t\t  }\n-\n-\t\tif (vector[i].exp != 0 && GET_CODE (vector[i].exp) == NOT\n-\t\t    && GET_CODE (XEXP (vector[i].exp, 0)) == EQ_ATTR\n-\t\t    && XSTR (XEXP (vector[i].exp, 0), 0) == aname)\n-\t\t  vector[i].exp = 0;\n-\t      }\n-\t  }\n-    }\n-\n-  /* Now build up rtl from the terms we didn't get rid of.  */\n-  combined = unstable;\n-  for (i = 0; i < nterms; i++)\n-    if (vector[i].exp != 0 && ! vector[i].ignore)\n-      {\n-\tif (combined == unstable)\n-\t  combined = vector[i].exp;\n-\telse\n-\t  combined = attr_rtx (code, vector[i].exp, combined);\n-      }\n-  if (common_term)\n-    return attr_rtx (other_code, common_term, combined);\n-  return combined;\n-}\n-\n-rtx\n-simplify_ands (exp1, exp2, exp3, insn_code, insn_index)\n-     rtx exp1, exp2, exp3;\n-     int insn_code, insn_index;\n-{\n-  return simplify_boolean (AND, exp1, exp2, exp3, false_rtx, true_rtx, \n-\t\t\t   insn_code, insn_index);\n-}\n-\n-rtx\n-simplify_iors (exp1, exp2, exp3, insn_code, insn_index)\n-     rtx exp1, exp2, exp3;\n-     int insn_code, insn_index;\n-{\n-  return simplify_boolean (IOR, exp1, exp2, exp3, true_rtx, false_rtx,\n-\t\t\t   insn_code, insn_index);\n-}\n-\f\n-#if 0\n-\n /* This routine is called when an AND of a term with a tree of AND's is\n    encountered.  If the term or its complement is present in the tree, it\n    can be replaced with TRUE or FALSE, respectively.\n@@ -2548,8 +2265,6 @@ simplify_or_tree (exp, pterm, insn_code, insn_index)\n \n   return exp;\n }\n-\n-#endif\n \f\n /* Given an expression, see if it can be simplified for a particular insn\n    code based on the values of other attributes being tested.  This can\n@@ -2590,39 +2305,176 @@ simplify_test_exp (exp, insn_code, insn_index)\n   switch (GET_CODE (exp))\n     {\n     case AND:\n-      exp = simplify_ands (XEXP (exp, 0), XEXP (exp, 1), 0,\n-\t\t\t   insn_code, insn_index);\n-      if (GET_CODE (exp) == AND)\n+      left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+      right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\n+      /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n+\t present on both sides, apply the distributive law since this will\n+\t yield simplifications.  */\n+      if ((GET_CODE (left) == IOR || GET_CODE (right) == IOR)\n+\t  && compute_alternative_mask (left, IOR)\n+\t  && compute_alternative_mask (right, IOR))\n \t{\n-\t  left = XEXP (exp, 0);\n-\t  right = XEXP (exp, 1);\n-\n-\t  /* If either side is an IOR and we have (eq_attr \"alternative\" ..\")\n-\t     present on both sides, apply the distributive law since this will\n-\t     yield simplifications.  */\n-\t  if ((GET_CODE (left) == IOR || GET_CODE (right) == IOR)\n-\t      && compute_alternative_mask (left, IOR)\n-\t      && compute_alternative_mask (right, IOR))\n+\t  if (GET_CODE (left) == IOR)\n \t    {\n-\t      if (GET_CODE (left) == IOR)\n-\t\t{\n-\t\t  rtx tem = left;\n-\t\t  left = right;\n-\t\t  right = tem;\n-\t\t}\n+\t      rtx tem = left;\n+\t      left = right;\n+\t      right = tem;\n+\t    }\n+\n+\t  newexp = attr_rtx (IOR,\n+\t\t\t     attr_rtx (AND, left, XEXP (right, 0)),\n+\t\t\t     attr_rtx (AND, left, XEXP (right, 1)));\n+\n+\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t}\n+\n+      /* Try with the term on both sides.  */\n+      right = simplify_and_tree (right, &left, insn_code, insn_index);\n+      if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n+\tleft = simplify_and_tree (left, &right, insn_code, insn_index);\n+\n+      if (left == false_rtx || right == false_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return false_rtx;\n+\t}\n+      else if (left == true_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t}\n+      else if (right == true_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t}\n \n-\t      newexp = attr_rtx (IOR,\n-\t\t\t\t attr_rtx (AND, left, XEXP (right, 0)),\n-\t\t\t\t attr_rtx (AND, left, XEXP (right, 1)));\n+      /* See if all or all but one of the insn's alternatives are specified\n+\t in this tree.  Optimize if so.  */\n+\n+      else if (insn_code >= 0\n+\t       && (GET_CODE (left) == AND\n+\t\t   || (GET_CODE (left) == NOT\n+\t\t       && GET_CODE (XEXP (left, 0)) == EQ_ATTR\n+\t\t       && XSTR (XEXP (left, 0), 0) == alternative_name)\n+\t\t   || GET_CODE (right) == AND\n+\t\t   || (GET_CODE (right) == NOT\n+\t\t       && GET_CODE (XEXP (right, 0)) == EQ_ATTR\n+\t\t       && XSTR (XEXP (right, 0), 0) == alternative_name)))\n+\t{\n+\t  i = compute_alternative_mask (exp, AND);\n+\t  if (i & ~insn_alternatives[insn_code])\n+\t    fatal (\"Illegal alternative specified for pattern number %d\",\n+\t\t   insn_index);\n+\n+\t  /* If all alternatives are excluded, this is false. */\n+\t  i ^= insn_alternatives[insn_code];\n+\t  if (i == 0)\n+\t    return false_rtx;\n+\t  else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n+\t    {\n+\t      /* If just one excluded, AND a comparison with that one to the\n+\t\t front of the tree.  The others will be eliminated by\n+\t\t optimization.  We do not want to do this if the insn has one\n+\t\t alternative and we have tested none of them!  */\n+\t      left = make_alternative_compare (i);\n+\t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n+\t      newexp = attr_rtx (AND, left, right);\n \n \t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n \t    }\n \t}\n-      return exp;\n+\n+      if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n+\t{\n+\t  newexp = attr_rtx (AND, left, right);\n+\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t}\n+      break;\n \n     case IOR:\n-      return simplify_iors (XEXP (exp, 0), XEXP (exp, 1), 0,\n-\t\t\t    insn_code, insn_index);\n+      left = SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+      right = SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\n+      right = simplify_or_tree (right, &left, insn_code, insn_index);\n+      if (left == XEXP (exp, 0) && right == XEXP (exp, 1))\n+\tleft = simplify_or_tree (left, &right, insn_code, insn_index);\n+\n+      if (right == true_rtx || left == true_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return true_rtx;\n+\t}\n+      else if (left == false_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 1), insn_code, insn_index);\n+\t}\n+      else if (right == false_rtx)\n+\t{\n+\t  obstack_free (rtl_obstack, spacer);\n+\t  return SIMPLIFY_TEST_EXP (XEXP (exp, 0), insn_code, insn_index);\n+\t}\n+\n+      /* Test for simple cases where the distributive law is useful.  I.e.,\n+\t    convert (ior (and (x) (y))\n+\t\t\t (and (x) (z)))\n+\t    to      (and (x)\n+\t\t\t (ior (y) (z)))\n+       */\n+\n+      else if (GET_CODE (left) == AND && GET_CODE (right) == AND\n+\t  && rtx_equal_p (XEXP (left, 0), XEXP (right, 0)))\n+\t{\n+\t  newexp = attr_rtx (IOR, XEXP (left, 1), XEXP (right, 1));\n+\n+\t  left = XEXP (left, 0);\n+\t  right = newexp;\n+\t  newexp = attr_rtx (AND, left, right);\n+\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t}\n+\n+      /* See if all or all but one of the insn's alternatives are specified\n+\t in this tree.  Optimize if so.  */\n+\n+      else if (insn_code >= 0\n+\t  && (GET_CODE (left) == IOR\n+\t      || (GET_CODE (left) == EQ_ATTR\n+\t\t  && XSTR (left, 0) == alternative_name)\n+\t      || GET_CODE (right) == IOR\n+\t      || (GET_CODE (right) == EQ_ATTR\n+\t\t  && XSTR (right, 0) == alternative_name)))\n+\t{\n+\t  i = compute_alternative_mask (exp, IOR);\n+\t  if (i & ~insn_alternatives[insn_code])\n+\t    fatal (\"Illegal alternative specified for pattern number %d\",\n+\t\t   insn_index);\n+\n+\t  /* If all alternatives are included, this is true. */\n+\t  i ^= insn_alternatives[insn_code];\n+\t  if (i == 0)\n+\t    return true_rtx;\n+\t  else if ((i & (i - 1)) == 0 && insn_alternatives[insn_code] > 1)\n+\t    {\n+\t      /* If just one excluded, IOR a comparison with that one to the\n+\t\t front of the tree.  The others will be eliminated by\n+\t\t optimization.  We do not want to do this if the insn has one\n+\t\t alternative and we have tested none of them!  */\n+\t      left = make_alternative_compare (i);\n+\t      right = simplify_and_tree (exp, &left, insn_code, insn_index);\n+\t      newexp = attr_rtx (IOR, attr_rtx (NOT, left), right);\n+\n+\t      return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t    }\n+\t}\n+\n+      if (left != XEXP (exp, 0) || right != XEXP (exp, 1))\n+\t{\n+\t  newexp = attr_rtx (IOR, left, right);\n+\t  return SIMPLIFY_TEST_EXP (newexp, insn_code, insn_index);\n+\t}\n+      break;\n \n     case NOT:\n       if (GET_CODE (XEXP (exp, 0)) == NOT)\n@@ -3394,7 +3246,22 @@ eliminate_known_true (known_true, exp, insn_code, insn_index)\n {\n   rtx term;\n \n-  return simplify_ands (exp, 0, known_true, insn_code, insn_index);\n+  known_true = SIMPLIFY_TEST_EXP (known_true, insn_code, insn_index);\n+\n+  if (GET_CODE (known_true) == AND)\n+    {\n+      exp = eliminate_known_true (XEXP (known_true, 0), exp,\n+\t\t\t\t  insn_code, insn_index);\n+      exp = eliminate_known_true (XEXP (known_true, 1), exp,\n+\t\t\t\t  insn_code, insn_index);\n+    }\n+  else\n+    {\n+      term = known_true;\n+      exp = simplify_and_tree (exp, &term, insn_code, insn_index);\n+    }\n+\n+  return exp;\n }\n \f\n /* Write out a series of tests and assignment statements to perform tests and\n@@ -4149,7 +4016,6 @@ main (argc, argv)\n \n   obstack_init (rtl_obstack);\n   obstack_init (hash_obstack);\n-  obstack_init (accum_obstack);\n \n   if (argc <= 1)\n     fatal (\"No input file name.\");"}]}