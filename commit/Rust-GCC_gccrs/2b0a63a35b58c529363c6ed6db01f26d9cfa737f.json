{"sha": "2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmIwYTYzYTM1YjU4YzUyOTM2M2M2ZWQ2ZGIwMWYyNmQ5Y2ZhNzM3Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1999-02-26T12:11:43Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-02-26T12:11:43Z"}, "message": "decl.c (duplicate_decls): Copy DECL_TEMPLATE_INSTANTIATED when merging decls.\n\n\t* decl.c (duplicate_decls): Copy DECL_TEMPLATE_INSTANTIATED when\n\tmerging decls.\n\t* pt.c (regenerate_decl_from_template): Tweak for clarity.\n\t(instantiate_decl): Mark a decl instantiated before regenerating\n\tit to avoid recursion.\n\t* tree.c (mapcar): Don't call decl_constant_value unless we know\n\tsomething is TREE_READONLY_DECL_P.\n\nFrom-SVN: r25458", "tree": {"sha": "88245a986d08f50e02468d5be72d94987f8133ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88245a986d08f50e02468d5be72d94987f8133ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/comments", "author": null, "committer": null, "parents": [{"sha": "ed70c42623729d86d2dc610a5279a5f394be68ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed70c42623729d86d2dc610a5279a5f394be68ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed70c42623729d86d2dc610a5279a5f394be68ee"}], "stats": {"total": 102, "additions": 94, "deletions": 8}, "files": [{"sha": "4424a3230f21ccd4048a1285196c5a67eb12e009", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "patch": "@@ -1,5 +1,13 @@\n 1999-02-26  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* decl.c (duplicate_decls): Copy DECL_TEMPLATE_INSTANTIATED when\n+\tmerging decls.\n+\t* pt.c (regenerate_decl_from_template): Tweak for clarity.\n+\t(instantiate_decl): Mark a decl instantiated before regenerating\n+\tit to avoid recursion.\n+\t* tree.c (mapcar): Don't call decl_constant_value unless we know\n+\tsomething is TREE_READONLY_DECL_P.\n+\n \t* class.c (check_for_override): Don't stop checking when we find\n \tthe first overridden function.  Delete #if 0'd code.\n \t* search.c (get_matching_virtual): Likewise."}, {"sha": "c18eab7fc3b9e35a37e8072c43537ef91d7daeae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "patch": "@@ -3319,6 +3319,8 @@ duplicate_decls (newdecl, olddecl)\n       DECL_INTERFACE_KNOWN (newdecl) |= DECL_INTERFACE_KNOWN (olddecl);\n       DECL_NOT_REALLY_EXTERN (newdecl) |= DECL_NOT_REALLY_EXTERN (olddecl);\n       DECL_COMDAT (newdecl) |= DECL_COMDAT (olddecl);\n+      DECL_TEMPLATE_INSTANTIATED (newdecl) \n+\t|= DECL_TEMPLATE_INSTANTIATED (olddecl);\n       /* Don't really know how much of the language-specific\n \t values we should copy from old to new.  */\n       DECL_IN_AGGR_P (newdecl) = DECL_IN_AGGR_P (olddecl);"}, {"sha": "0f6d228a92a99d490a70acc1355955f3cc2b91e8", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "patch": "@@ -9053,8 +9053,7 @@ regenerate_decl_from_template (decl, tmpl)\n       /* Pop the class context we pushed above.  */\n       popclass (1);\n     }\n-\n-  if (TREE_CODE (decl) == FUNCTION_DECL)\n+  else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       /* Convince duplicate_decls to use the DECL_ARGUMENTS from the\n \t new decl.  */ \n@@ -9249,9 +9248,15 @@ instantiate_decl (d)\n       goto out;\n     }\n \n-  regenerate_decl_from_template (d, td);\n+  /* We're now committed to instantiating this template.  Mark it as\n+     instantiated so that recursive calls to instantiate_decl do not\n+     try to instantiate it again.  */\n   DECL_TEMPLATE_INSTANTIATED (d) = 1;\n \n+  /* Regenerate the declaration in case the template has been modified\n+     by a subsequent redeclaration.  */\n+  regenerate_decl_from_template (d, td);\n+\n   /* We already set the file and line above.  Reset them now in case\n      they changed as a result of calling regenerate_decl_from_template.  */\n   lineno = DECL_SOURCE_LINE (d);"}, {"sha": "6d6fc43cccfe35fb567fc53d671c977ebb52c6a2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "patch": "@@ -1846,11 +1846,13 @@ mapcar (t, func)\n            void g() { const int i = 7; f<i>(7); }\n \n \t however, we must actually return the constant initializer.  */\n-      tmp = decl_constant_value (t);\n-      if (tmp != t)\n-\treturn mapcar (tmp, func);\n-      else\n-\treturn error_mark_node;\n+      if (TREE_READONLY_DECL_P (t))\n+\t{\n+\t  tmp = decl_constant_value (t);\n+\t  if (tmp != t)\n+\t    return mapcar (tmp, func);\n+\t}\n+      return error_mark_node;\n \n     case PARM_DECL:\n       {"}, {"sha": "59100649cb835136e8880002fbd51cfe86fceeb1", "filename": "gcc/testsuite/g++.old-deja/g++.pt/crash29.C", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash29.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b0a63a35b58c529363c6ed6db01f26d9cfa737f/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash29.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fcrash29.C?ref=2b0a63a35b58c529363c6ed6db01f26d9cfa737f", "patch": "@@ -0,0 +1,69 @@\n+// Build don't link:\n+// Origin: Steven Parkes <parkes@sierravista.com>\n+\n+typedef unsigned int size_t;\n+\n+class UUId {};\n+\n+template <class T> class MetaClass;\n+\n+class TypeInfo;\n+\n+struct MetaClassGeneric \n+{\n+                                MetaClassGeneric( TypeInfo& );\n+};\n+\n+struct TypeInfo \n+{\n+                        void    (*constructor)( void* );\n+                        void    initialize( void* );\n+};\n+\n+template <class T>\n+class TypeIDInit {\n+public:\n+                                TypeIDInit();\n+                 static void    initialize();\n+             static TypeInfo    info;\n+                  static int    storage[];\n+                 static void    metaclassConstructor( void* );\n+};\n+\n+template <class T>\n+TypeInfo TypeIDInit<T>::info = \n+{\n+  TypeIDInit<T>::metaclassConstructor\n+};\n+\n+template <class T>\n+inline\n+TypeIDInit<T>::TypeIDInit()\n+{\n+  info.initialize(storage);\n+}\n+\n+template <class T>\n+class NameInfo : public MetaClassGeneric {\n+public:\n+                                NameInfo() \n+\t\t\t\t: MetaClassGeneric( TypeIDInit<T>::info ) {}\n+};\n+\n+class MetaClass<UUId>\n+: public NameInfo<UUId>\n+{\n+};\n+\n+extern \"C++\"\n+inline void *operator new(size_t, void *place) throw() { return place; }\n+\n+template <class T>\n+void\n+TypeIDInit<T>::metaclassConstructor( void* place )\n+{\n+  new ( place ) MetaClass<T>;\n+}\n+\n+template class   TypeIDInit<UUId>   ;\n+"}]}