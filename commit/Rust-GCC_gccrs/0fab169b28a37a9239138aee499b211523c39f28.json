{"sha": "0fab169b28a37a9239138aee499b211523c39f28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZhYjE2OWIyOGEzN2E5MjM5MTM4YWVlNDk5YjIxMTUyM2MzOWYyOA==", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2017-10-27T10:48:49Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh3492@gcc.gnu.org", "date": "2017-10-27T10:48:49Z"}, "message": "Extend ipa-pure-const pass to propagate malloc attribute.\n\n2017-10-27  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n\n\t* cgraph.h (set_malloc_flag): Declare.\n\t* cgraph.c (set_malloc_flag_1): New function.\n\t(set_malloc_flag): Likewise.\n\t* ipa-fnsummary.h (ipa_call_summary): Add new field is_return_callee.\n\t* ipa-fnsummary.c (ipa_call_summary::reset): Set is_return_callee to\n\tfalse.\n\t(read_ipa_call_summary): Add support for reading is_return_callee.\n\t(write_ipa_call_summary): Stream is_return_callee.\n\t* ipa-inline.c (ipa_inline): Remove call to ipa_free_fn_summary.\n\t* ipa-pure-const.c: Add headers ssa.h, alloc-pool.h, symbol-summary.h,\n\tipa-prop.h, ipa-fnsummary.h.\n\t(pure_const_names): Change to static.\n\t(malloc_state_e): Define.\n\t(malloc_state_names): Define.\n\t(funct_state_d): Add field malloc_state.\n\t(varying_state): Set malloc_state to STATE_MALLOC_BOTTOM.\n\t(check_retval_uses): New function.\n\t(malloc_candidate_p): Likewise.\n\t(analyze_function): Add support for malloc attribute.\n\t(pure_const_write_summary): Stream malloc_state.\n\t(pure_const_read_summary): Add support for reading malloc_state.\n\t(dump_malloc_lattice): New function.\n\t(propagate_malloc): New function.\n\t(warn_function_malloc): New function.\n\t(ipa_pure_const::execute): Call propagate_malloc and\n\tipa_free_fn_summary.\n\t(pass_local_pure_const::execute): Add support for malloc attribute.\n\t* ssa-iterators.h (RETURN_FROM_IMM_USE_STMT): New macro.\n\t* doc/invoke.texi: Document Wsuggest-attribute=malloc.\n\ntestsuite/\n\t* gcc.dg/ipa/propmalloc-1.c: New test-case.\n\t* gcc.dg/ipa/propmalloc-2.c: Likewise.\n\t* gcc.dg/ipa/propmalloc-3.c: Likewise.\n\nFrom-SVN: r254140", "tree": {"sha": "1433564004d27e19c8c00ff03d4817e57f99cab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1433564004d27e19c8c00ff03d4817e57f99cab7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fab169b28a37a9239138aee499b211523c39f28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fab169b28a37a9239138aee499b211523c39f28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fab169b28a37a9239138aee499b211523c39f28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fab169b28a37a9239138aee499b211523c39f28/comments", "author": null, "committer": null, "parents": [{"sha": "e89b556bafe224a4017bc4513d88b3e52253ce74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e89b556bafe224a4017bc4513d88b3e52253ce74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e89b556bafe224a4017bc4513d88b3e52253ce74"}], "stats": {"total": 541, "additions": 526, "deletions": 15}, "files": [{"sha": "159cae7f3540e05504f53e62332d395a9375468a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -1,3 +1,35 @@\n+2017-10-27  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* cgraph.h (set_malloc_flag): Declare.\n+\t* cgraph.c (set_malloc_flag_1): New function.\n+\t(set_malloc_flag): Likewise.\n+\t* ipa-fnsummary.h (ipa_call_summary): Add new field is_return_callee.\n+\t* ipa-fnsummary.c (ipa_call_summary::reset): Set is_return_callee to\n+\tfalse.\n+\t(read_ipa_call_summary): Add support for reading is_return_callee.\n+\t(write_ipa_call_summary): Stream is_return_callee.\n+\t* ipa-inline.c (ipa_inline): Remove call to ipa_free_fn_summary.\n+\t* ipa-pure-const.c: Add headers ssa.h, alloc-pool.h, symbol-summary.h,\n+\tipa-prop.h, ipa-fnsummary.h.\n+\t(pure_const_names): Change to static.\n+\t(malloc_state_e): Define.\n+\t(malloc_state_names): Define.\n+\t(funct_state_d): Add field malloc_state.\n+\t(varying_state): Set malloc_state to STATE_MALLOC_BOTTOM.\n+\t(check_retval_uses): New function.\n+\t(malloc_candidate_p): Likewise.\n+\t(analyze_function): Add support for malloc attribute.\n+\t(pure_const_write_summary): Stream malloc_state.\n+\t(pure_const_read_summary): Add support for reading malloc_state.\n+\t(dump_malloc_lattice): New function.\n+\t(propagate_malloc): New function.\n+\t(warn_function_malloc): New function.\n+\t(ipa_pure_const::execute): Call propagate_malloc and\n+\tipa_free_fn_summary.\n+\t(pass_local_pure_const::execute): Add support for malloc attribute.\n+\t* ssa-iterators.h (RETURN_FROM_IMM_USE_STMT): New macro.\n+\t* doc/invoke.texi: Document Wsuggest-attribute=malloc.\n+\n 2017-10-27  Martin Liska  <mliska@suse.cz>\n \n \tPR gcov-profile/82457"}, {"sha": "b79f9e837ed27bbac40f46fa72d1602ef9a3c101", "filename": "gcc/cgraph.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -2530,6 +2530,53 @@ cgraph_node::set_nothrow_flag (bool nothrow)\n   return changed;\n }\n \n+/* Worker to set malloc flag.  */\n+static void\n+set_malloc_flag_1 (cgraph_node *node, bool malloc_p, bool *changed)\n+{\n+  if (malloc_p && !DECL_IS_MALLOC (node->decl))\n+    {\n+      DECL_IS_MALLOC (node->decl) = true;\n+      *changed = true;\n+    }\n+\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (node, ref)\n+    {\n+      cgraph_node *alias = dyn_cast<cgraph_node *> (ref->referring);\n+      if (!malloc_p || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tset_malloc_flag_1 (alias, malloc_p, changed);\n+    }\n+\n+  for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n+    if (e->caller->thunk.thunk_p\n+\t&& (!malloc_p || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n+      set_malloc_flag_1 (e->caller, malloc_p, changed);\n+}\n+\n+/* Set DECL_IS_MALLOC on NODE's decl and on NODE's aliases if any.  */\n+\n+bool\n+cgraph_node::set_malloc_flag (bool malloc_p)\n+{\n+  bool changed = false;\n+\n+  if (!malloc_p || get_availability () > AVAIL_INTERPOSABLE)\n+    set_malloc_flag_1 (this, malloc_p, &changed);\n+  else\n+    {\n+      ipa_ref *ref;\n+\n+      FOR_EACH_ALIAS (this, ref)\n+\t{\n+\t  cgraph_node *alias = dyn_cast<cgraph_node *> (ref->referring);\n+\t  if (!malloc_p || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\t    set_malloc_flag_1 (alias, malloc_p, &changed);\n+\t}\n+    }\n+  return changed;\n+}\n+\n /* Worker to set_const_flag.  */\n \n static void"}, {"sha": "84824e9f814c5bf5c9ad5de393fe6a079d959bb8", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -1151,6 +1151,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      if any to NOTHROW.  */\n   bool set_nothrow_flag (bool nothrow);\n \n+  /* SET DECL_IS_MALLOC on cgraph_node's decl and on aliases of the node\n+     if any.  */\n+  bool set_malloc_flag (bool malloc_p);\n+\n   /* If SET_CONST is true, mark function, aliases and thunks to be ECF_CONST.\n     If SET_CONST if false, clear the flag.\n "}, {"sha": "d5e831d6b4c560c24bcf03ed29cfa0acb874b5cb", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -741,6 +741,10 @@ Wsuggest-attribute=noreturn\n Common Var(warn_suggest_attribute_noreturn) Warning\n Warn about functions which might be candidates for __attribute__((noreturn)).\n \n+Wsuggest-attribute=malloc\n+Common Var(warn_suggest_attribute_malloc) Warning\n+Warn about functions which might be candidates for __attribute__((malloc)).\n+\n Wsuggest-final-types\n Common Var(warn_suggest_final_types) Warning\n Warn about C++ polymorphic types where adding final keyword would improve code quality."}, {"sha": "91b05402ecc347131d2e17b0c182ffe09ccc0861", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -315,7 +315,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wstack-protector  -Wstack-usage=@var{len}  -Wstrict-aliasing @gol\n -Wstrict-aliasing=n  -Wstrict-overflow  -Wstrict-overflow=@var{n} @gol\n -Wstringop-overflow=@var{n} @gol\n--Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{]} @gol\n+-Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}malloc@r{]} @gol\n -Wsuggest-final-types @gol  -Wsuggest-final-methods  -Wsuggest-override @gol\n -Wmissing-format-attribute  -Wsubobject-linkage @gol\n -Wswitch  -Wswitch-bool  -Wswitch-default  -Wswitch-enum @gol\n@@ -5204,7 +5204,7 @@ whether to issue a warning.  Similarly to @option{-Wstringop-overflow=3} this\n setting of the option may result in warnings for benign code.\n @end table\n \n-@item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{]}\n+@item -Wsuggest-attribute=@r{[}pure@r{|}const@r{|}noreturn@r{|}format@r{|}cold@r{|}malloc@r{]}\n @opindex Wsuggest-attribute=\n @opindex Wno-suggest-attribute=\n Warn for cases where adding an attribute may be beneficial. The\n@@ -5214,21 +5214,25 @@ attributes currently supported are listed below.\n @item -Wsuggest-attribute=pure\n @itemx -Wsuggest-attribute=const\n @itemx -Wsuggest-attribute=noreturn\n+@itemx -Wsuggest-attribute=malloc\n @opindex Wsuggest-attribute=pure\n @opindex Wno-suggest-attribute=pure\n @opindex Wsuggest-attribute=const\n @opindex Wno-suggest-attribute=const\n @opindex Wsuggest-attribute=noreturn\n @opindex Wno-suggest-attribute=noreturn\n+@opindex Wsuggest-attribute=malloc\n+@opindex Wno-suggest-attribute=malloc\n \n Warn about functions that might be candidates for attributes\n-@code{pure}, @code{const} or @code{noreturn}.  The compiler only warns for\n-functions visible in other compilation units or (in the case of @code{pure} and\n-@code{const}) if it cannot prove that the function returns normally. A function\n-returns normally if it doesn't contain an infinite loop or return abnormally\n-by throwing, calling @code{abort} or trapping.  This analysis requires option\n-@option{-fipa-pure-const}, which is enabled by default at @option{-O} and\n-higher.  Higher optimization levels improve the accuracy of the analysis.\n+@code{pure}, @code{const} or @code{noreturn} or @code{malloc}. The compiler\n+only warns for functions visible in other compilation units or (in the case of\n+@code{pure} and @code{const}) if it cannot prove that the function returns\n+normally. A function returns normally if it doesn't contain an infinite loop or\n+return abnormally by throwing, calling @code{abort} or trapping.  This analysis\n+requires option @option{-fipa-pure-const}, which is enabled by default at\n+@option{-O} and higher.  Higher optimization levels improve the accuracy\n+of the analysis.\n \n @item -Wsuggest-attribute=format\n @itemx -Wmissing-format-attribute"}, {"sha": "f71338e424e3213e18a61937ea01b1705c4e3b71", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -542,6 +542,7 @@ void\n ipa_call_summary::reset ()\n {\n   call_stmt_size = call_stmt_time = 0;\n+  is_return_callee_uncaptured = false;\n   if (predicate)\n     edge_predicate_pool.remove (predicate);\n   predicate = NULL;\n@@ -3204,6 +3205,10 @@ read_ipa_call_summary (struct lto_input_block *ib, struct cgraph_edge *e)\n   es->call_stmt_size = streamer_read_uhwi (ib);\n   es->call_stmt_time = streamer_read_uhwi (ib);\n   es->loop_depth = streamer_read_uhwi (ib);\n+\n+  bitpack_d bp = streamer_read_bitpack (ib);\n+  es->is_return_callee_uncaptured = bp_unpack_value (&bp, 1);\n+\n   p.stream_in (ib);\n   edge_set_predicate (e, &p);\n   length = streamer_read_uhwi (ib);\n@@ -3360,6 +3365,11 @@ write_ipa_call_summary (struct output_block *ob, struct cgraph_edge *e)\n   streamer_write_uhwi (ob, es->call_stmt_size);\n   streamer_write_uhwi (ob, es->call_stmt_time);\n   streamer_write_uhwi (ob, es->loop_depth);\n+\n+  bitpack_d bp = bitpack_create (ob->main_stream);\n+  bp_pack_value (&bp, es->is_return_callee_uncaptured, 1);\n+  streamer_write_bitpack (&bp);\n+\n   if (es->predicate)\n     es->predicate->stream_out (ob);\n   else"}, {"sha": "a794bd09318f136a76507fccd3161a8712c1c703", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -197,7 +197,9 @@ struct ipa_call_summary\n   int call_stmt_time;\n   /* Depth of loop nest, 0 means no nesting.  */\n   unsigned int loop_depth;\n-  \n+  /* Indicates whether the caller returns the value of it's callee.  */\n+  bool is_return_callee_uncaptured;\n+\n   /* Keep all field empty so summary dumping works during its computation.\n      This is useful for debugging.  */\n   ipa_call_summary ()"}, {"sha": "b8e65e2fa7ec982b19b9dbd750f3b9035df542ee", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -2526,9 +2526,6 @@ ipa_inline (void)\n \n   if (dump_file)\n     ipa_dump_fn_summaries (dump_file);\n-  /* In WPA we use inline summaries for partitioning process.  */\n-  if (!flag_wpa)\n-    ipa_free_fn_summary ();\n   return remove_functions ? TODO_remove_functions : 0;\n }\n "}, {"sha": "bdc752207b13de347f1be89d35d973084b84d91d", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 333, "deletions": 2, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -56,6 +56,11 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"intl.h\"\n #include \"opts.h\"\n+#include \"ssa.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"ipa-prop.h\"\n+#include \"ipa-fnsummary.h\"\n \n /* Lattice values for const and pure functions.  Everything starts out\n    being const, then may drop to pure and then neither depending on\n@@ -67,7 +72,16 @@ enum pure_const_state_e\n   IPA_NEITHER\n };\n \n-const char *pure_const_names[3] = {\"const\", \"pure\", \"neither\"};\n+static const char *pure_const_names[3] = {\"const\", \"pure\", \"neither\"};\n+\n+enum malloc_state_e\n+{\n+  STATE_MALLOC_TOP,\n+  STATE_MALLOC,\n+  STATE_MALLOC_BOTTOM\n+};\n+\n+static const char *malloc_state_names[] = {\"malloc_top\", \"malloc\", \"malloc_bottom\"};\n \n /* Holder for the const_state.  There is one of these per function\n    decl.  */\n@@ -92,11 +106,13 @@ struct funct_state_d\n   /* If function can call free, munmap or otherwise make previously\n      non-trapping memory accesses trapping.  */\n   bool can_free;\n+\n+  enum malloc_state_e malloc_state;\n };\n \n /* State used when we know nothing about function.  */\n static struct funct_state_d varying_state\n-   = { IPA_NEITHER, IPA_NEITHER, true, true, true, true };\n+   = { IPA_NEITHER, IPA_NEITHER, true, true, true, true, STATE_MALLOC_BOTTOM };\n \n \n typedef struct funct_state_d * funct_state;\n@@ -216,6 +232,19 @@ warn_function_const (tree decl, bool known_finite)\n \t\t\t known_finite, warned_about, \"const\");\n }\n \n+/* Emit suggestion about __attribute__((malloc)) for DECL.  */\n+\n+static void\n+warn_function_malloc (tree decl)\n+{\n+  static hash_set<tree> *warned_about;\n+  warned_about\n+    = suggest_attribute (OPT_Wsuggest_attribute_malloc, decl,\n+\t\t\t false, warned_about, \"malloc\");\n+}\n+\n+/* Emit suggestion about __attribute__((noreturn)) for DECL.  */\n+\n static void\n warn_function_noreturn (tree decl)\n {\n@@ -827,6 +856,149 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n     }\n }\n \n+/* Check that RETVAL is used only in STMT and in comparisons against 0.\n+   RETVAL is return value of the function and STMT is return stmt.  */\n+\n+static bool\n+check_retval_uses (tree retval, gimple *stmt)\n+{\n+  imm_use_iterator use_iter;\n+  gimple *use_stmt;\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, use_iter, retval)\n+    if (gcond *cond = dyn_cast<gcond *> (use_stmt))\n+      {\n+\ttree op2 = gimple_cond_rhs (cond);\n+\tif (!integer_zerop (op2))\n+\t  RETURN_FROM_IMM_USE_STMT (use_iter, false);\n+      }\n+    else if (gassign *ga = dyn_cast<gassign *> (use_stmt))\n+      {\n+\tenum tree_code code = gimple_assign_rhs_code (ga);\n+\tif (TREE_CODE_CLASS (code) != tcc_comparison)\n+\t  RETURN_FROM_IMM_USE_STMT (use_iter, false);\n+\tif (!integer_zerop (gimple_assign_rhs2 (ga)))\n+\t  RETURN_FROM_IMM_USE_STMT (use_iter, false);\n+      }\n+    else if (is_gimple_debug (use_stmt))\n+      ;\n+    else if (use_stmt != stmt)\n+      RETURN_FROM_IMM_USE_STMT (use_iter, false);\n+\n+  return true;\n+}\n+\n+/* malloc_candidate_p() checks if FUN can possibly be annotated with malloc\n+   attribute. Currently this function does a very conservative analysis.\n+   FUN is considered to be a candidate if\n+   1) It returns a value of pointer type.\n+   2) SSA_NAME_DEF_STMT (return_value) is either a function call or\n+      a phi, and element of phi is either NULL or\n+      SSA_NAME_DEF_STMT(element) is function call.\n+   3) The return-value has immediate uses only within comparisons (gcond or gassign)\n+      and return_stmt (and likewise a phi arg has immediate use only within comparison\n+      or the phi stmt).  */\n+\n+static bool\n+malloc_candidate_p (function *fun, bool ipa)\n+{\n+  basic_block exit_block = EXIT_BLOCK_PTR_FOR_FN (fun);\n+  edge e;\n+  edge_iterator ei;\n+  cgraph_node *node = cgraph_node::get_create (fun->decl);\n+\n+#define DUMP_AND_RETURN(reason)  \\\n+{  \\\n+  if (dump_file && (dump_flags & TDF_DETAILS))  \\\n+    fprintf (dump_file, \"%s\", (reason));  \\\n+  return false;  \\\n+}\n+\n+  if (EDGE_COUNT (exit_block->preds) == 0)\n+    return false;\n+\n+  FOR_EACH_EDGE (e, ei, exit_block->preds)\n+    {\n+      gimple_stmt_iterator gsi = gsi_last_bb (e->src);\n+      greturn *ret_stmt = dyn_cast<greturn *> (gsi_stmt (gsi));\n+\n+      if (!ret_stmt)\n+\treturn false;\n+\n+      tree retval = gimple_return_retval (ret_stmt);\n+      if (!retval)\n+\tDUMP_AND_RETURN(\"No return value.\")\n+\n+      if (TREE_CODE (retval) != SSA_NAME\n+\t  || TREE_CODE (TREE_TYPE (retval)) != POINTER_TYPE)\n+\tDUMP_AND_RETURN(\"Return value is not SSA_NAME or not a pointer type.\")\n+\n+      if (!check_retval_uses (retval, ret_stmt))\n+\tDUMP_AND_RETURN(\"Return value has uses outside return stmt\"\n+\t\t\t\" and comparisons against 0.\")\n+\n+      gimple *def = SSA_NAME_DEF_STMT (retval);\n+      if (gcall *call_stmt = dyn_cast<gcall *> (def))\n+\t{\n+\t  tree callee_decl = gimple_call_fndecl (call_stmt);\n+\t  if (!callee_decl)\n+\t    return false;\n+\n+\t  if (!ipa && !DECL_IS_MALLOC (callee_decl))\n+\t    DUMP_AND_RETURN(\"callee_decl does not have malloc attribute for\"\n+\t\t\t    \" non-ipa mode.\")\n+\n+\t  cgraph_edge *cs = node->get_edge (call_stmt);\n+\t  if (cs)\n+\t    {\n+\t      ipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t      gcc_assert (es);\n+\t      es->is_return_callee_uncaptured = true;\n+\t    }\n+\t}\n+\n+      else if (gphi *phi = dyn_cast<gphi *> (def))\n+\tfor (unsigned i = 0; i < gimple_phi_num_args (phi); ++i)\n+\t  {\n+\t    tree arg = gimple_phi_arg_def (phi, i);\n+\t    if (TREE_CODE (arg) != SSA_NAME)\n+\t      DUMP_AND_RETURN(\"phi arg is not SSA_NAME.\")\n+\t    if (!(arg == null_pointer_node || check_retval_uses (arg, phi)))\n+\t      DUMP_AND_RETURN(\"phi arg has uses outside phi\"\n+\t\t\t      \" and comparisons against 0.\")\n+\n+\t    gimple *arg_def = SSA_NAME_DEF_STMT (arg);\n+\t    gcall *call_stmt = dyn_cast<gcall *> (arg_def);\n+\t    if (!call_stmt)\n+\t      return false;\n+\t    tree callee_decl = gimple_call_fndecl (call_stmt);\n+\t    if (!callee_decl)\n+\t      return false;\n+\t    if (!ipa && !DECL_IS_MALLOC (callee_decl))\n+\t      DUMP_AND_RETURN(\"callee_decl does not have malloc attribute for\"\n+\t\t\t      \" non-ipa mode.\")\n+\n+\t    cgraph_edge *cs = node->get_edge (call_stmt);\n+\t    if (cs)\n+\t      {\n+\t\tipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t\tgcc_assert (es);\n+\t\tes->is_return_callee_uncaptured = true;\n+\t      }\n+\t  }\n+\n+      else\n+\tDUMP_AND_RETURN(\"def_stmt of return value is not a call or phi-stmt.\")\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nFound %s to be candidate for malloc attribute\\n\",\n+\t     IDENTIFIER_POINTER (DECL_NAME (fun->decl)));\n+  return true;\n+\n+#undef DUMP_AND_RETURN\n+}\n+\n \n /* This is the main routine for finding the reference patterns for\n    global variables within a function FN.  */\n@@ -936,6 +1108,14 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   if (TREE_NOTHROW (decl))\n     l->can_throw = false;\n \n+  l->malloc_state = STATE_MALLOC_BOTTOM;\n+  if (DECL_IS_MALLOC (decl))\n+    l->malloc_state = STATE_MALLOC;\n+  else if (ipa && malloc_candidate_p (DECL_STRUCT_FUNCTION (decl), true))\n+    l->malloc_state = STATE_MALLOC_TOP;\n+  else if (malloc_candidate_p (DECL_STRUCT_FUNCTION (decl), false))\n+    l->malloc_state = STATE_MALLOC;\n+\n   pop_cfun ();\n   if (dump_file)\n     {\n@@ -949,6 +1129,8 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n         fprintf (dump_file, \"Function is locally pure.\\n\");\n       if (l->can_free)\n \tfprintf (dump_file, \"Function can locally free.\\n\");\n+      if (l->malloc_state == STATE_MALLOC)\n+\tfprintf (dump_file, \"Function is locally malloc.\\n\");\n     }\n   return l;\n }\n@@ -1082,6 +1264,7 @@ pure_const_write_summary (void)\n \t  bp_pack_value (&bp, fs->looping, 1);\n \t  bp_pack_value (&bp, fs->can_throw, 1);\n \t  bp_pack_value (&bp, fs->can_free, 1);\n+\t  bp_pack_value (&bp, fs->malloc_state, 2);\n \t  streamer_write_bitpack (&bp);\n \t}\n     }\n@@ -1142,6 +1325,9 @@ pure_const_read_summary (void)\n \t      fs->looping = bp_unpack_value (&bp, 1);\n \t      fs->can_throw = bp_unpack_value (&bp, 1);\n \t      fs->can_free = bp_unpack_value (&bp, 1);\n+\t      fs->malloc_state\n+\t\t\t= (enum malloc_state_e) bp_unpack_value (&bp, 2);\n+\n \t      if (dump_file)\n \t\t{\n \t\t  int flags = flags_from_decl_or_type (node->decl);\n@@ -1164,6 +1350,8 @@ pure_const_read_summary (void)\n \t\t    fprintf (dump_file,\"  function is locally throwing\\n\");\n \t\t  if (fs->can_free)\n \t\t    fprintf (dump_file,\"  function can locally free\\n\");\n+\t\t  fprintf (dump_file, \"\\n malloc state: %s\\n\",\n+\t\t\t   malloc_state_names[fs->malloc_state]);\n \t\t}\n \t    }\n \n@@ -1674,6 +1862,131 @@ propagate_nothrow (void)\n   free (order);\n }\n \n+/* Debugging function to dump state of malloc lattice.  */\n+\n+DEBUG_FUNCTION\n+static void\n+dump_malloc_lattice (FILE *dump_file, const char *s)\n+{\n+  if (!dump_file)\n+    return;\n+\n+  fprintf (dump_file, \"\\n\\nMALLOC LATTICE %s:\\n\", s);\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION (node)\n+    {\n+      funct_state fs = get_function_state (node);\n+      malloc_state_e state = fs->malloc_state;\n+      fprintf (dump_file, \"%s: %s\\n\", node->name (), malloc_state_names[state]);\n+    }\n+}\n+\n+/* Propagate malloc attribute across the callgraph.  */\n+\n+static void\n+propagate_malloc (void)\n+{\n+  cgraph_node *node;\n+  FOR_EACH_FUNCTION (node)\n+    {\n+      if (DECL_IS_MALLOC (node->decl))\n+\tif (!has_function_state (node))\n+\t  {\n+\t    funct_state l = XCNEW (struct funct_state_d);\n+\t    *l = varying_state;\n+\t    l->malloc_state = STATE_MALLOC;\n+\t    set_function_state (node, l);\n+\t  }\n+    }\n+\n+  dump_malloc_lattice (dump_file, \"Initial\");\n+  struct cgraph_node **order\n+    = XNEWVEC (struct cgraph_node *, symtab->cgraph_count);\n+  int order_pos = ipa_reverse_postorder (order);\n+  bool changed = true;\n+\n+  while (changed)\n+    {\n+      changed = false;\n+      /* Walk in postorder.  */\n+      for (int i = order_pos - 1; i >= 0; --i)\n+\t{\n+\t  cgraph_node *node = order[i];\n+\t  if (node->alias\n+\t      || !node->definition\n+\t      || !has_function_state (node))\n+\t    continue;\n+\n+\t  funct_state l = get_function_state (node);\n+\n+\t  /* FIXME: add support for indirect-calls.  */\n+\t  if (node->indirect_calls)\n+\t    {\n+\t      l->malloc_state = STATE_MALLOC_BOTTOM;\n+\t      continue;\n+\t    }\n+\n+\t  if (node->get_availability () <= AVAIL_INTERPOSABLE)\n+\t    {\n+\t      l->malloc_state = STATE_MALLOC_BOTTOM;\n+\t      continue;\n+\t    }\n+\n+\t  if (l->malloc_state == STATE_MALLOC_BOTTOM)\n+\t    continue;\n+\n+\t  vec<cgraph_node *> callees = vNULL;\n+\t  for (cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n+\t    {\n+\t      ipa_call_summary *es = ipa_call_summaries->get (cs);\n+\t      if (es && es->is_return_callee_uncaptured)\n+\t\tcallees.safe_push (cs->callee);\n+\t    }\n+\n+\t  malloc_state_e new_state = l->malloc_state;\n+\t  for (unsigned j = 0; j < callees.length (); j++)\n+\t    {\n+\t      cgraph_node *callee = callees[j];\n+\t      if (!has_function_state (callee))\n+\t\t{\n+\t\t  new_state = STATE_MALLOC_BOTTOM;\n+\t\t  break;\n+\t\t}\n+\t      malloc_state_e callee_state = get_function_state (callee)->malloc_state;\n+\t      if (new_state < callee_state)\n+\t\tnew_state = callee_state;\n+\t    }\n+\t  if (new_state != l->malloc_state)\n+\t    {\n+\t      changed = true;\n+\t      l->malloc_state = new_state;\n+\t    }\n+\t}\n+    }\n+\n+  FOR_EACH_DEFINED_FUNCTION (node)\n+    if (has_function_state (node))\n+      {\n+\tfunct_state l = get_function_state (node);\n+\tif (!node->alias\n+\t    && l->malloc_state == STATE_MALLOC\n+\t    && !node->global.inlined_to)\n+\t  {\n+\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t      fprintf (dump_file, \"Function %s found to be malloc\\n\",\n+\t\t       node->name ());\n+\n+\t    bool malloc_decl_p = DECL_IS_MALLOC (node->decl);\n+\t    node->set_malloc_flag (true);\n+\t    if (!malloc_decl_p && warn_suggest_attribute_malloc)\n+\t\twarn_function_malloc (node->decl);\n+\t  }\n+      }\n+\n+  dump_malloc_lattice (dump_file, \"after propagation\");\n+  ipa_free_postorder_info ();\n+  free (order);\n+}\n \n /* Produce the global information by preforming a transitive closure\n    on the local information that was produced by generate_summary.  */\n@@ -1692,13 +2005,18 @@ execute (function *)\n   /* Nothrow makes more function to not lead to return and improve\n      later analysis.  */\n   propagate_nothrow ();\n+  propagate_malloc ();\n   remove_p = propagate_pure_const ();\n \n   /* Cleanup. */\n   FOR_EACH_FUNCTION (node)\n     if (has_function_state (node))\n       free (get_function_state (node));\n   funct_state_vec.release ();\n+\n+  /* In WPA we use inline summaries for partitioning process.  */\n+  if (!flag_wpa)\n+    ipa_free_fn_summary ();\n   return remove_p ? TODO_remove_functions : 0;\n }\n \n@@ -1893,6 +2211,19 @@ pass_local_pure_const::execute (function *fun)\n \tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n \t\t current_function_name ());\n     }\n+\n+  if (l->malloc_state == STATE_MALLOC\n+      && !DECL_IS_MALLOC (current_function_decl))\n+    {\n+      node->set_malloc_flag (true);\n+      if (warn_suggest_attribute_malloc)\n+\twarn_function_malloc (node->decl);\n+      changed = true;\n+      if (dump_file)\n+\tfprintf (dump_file, \"Function found to be malloc: %s\\n\",\n+\t\t node->name ());\n+    }\n+\n   free (l);\n   if (changed)\n     return execute_fixup_cfg ();"}, {"sha": "740cbf13cb2b5d626af308bfa11830bd9386f7a2", "filename": "gcc/ssa-iterators.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fssa-iterators.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Fssa-iterators.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa-iterators.h?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -93,6 +93,12 @@ struct imm_use_iterator\n      break;\t\t\t\t\t\t\t\\\n    }\n \n+/* Similarly for return.  */\n+#define RETURN_FROM_IMM_USE_STMT(ITER, VAL)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    end_imm_use_stmt_traverse (&(ITER));\t\t\t\\\n+    return (VAL);\t\t\t\t\t\t\\\n+  }\n \n /* Use this iterator in combination with FOR_EACH_IMM_USE_STMT to\n    get access to each occurrence of ssavar on the stmt returned by"}, {"sha": "bdbe863dd9c4763c41e645849e10fc8bcaefd615", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -1,3 +1,9 @@\n+2017-10-27  Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n+\n+\t* gcc.dg/ipa/propmalloc-1.c: New test-case.\n+\t* gcc.dg/ipa/propmalloc-2.c: Likewise.\n+\t* gcc.dg/ipa/propmalloc-3.c: Likewise.\n+\n 2017-10-27  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/71385"}, {"sha": "9a95f8170792d871ee1ad366c71eb00afad7e984", "filename": "gcc/testsuite/gcc.dg/ipa/propmalloc-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-1.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-pure-const-details\" } */\n+\n+__attribute__((noinline, no_icf, used))\n+static void *f(__SIZE_TYPE__ n)\n+{\n+  void *p = __builtin_malloc (n);\n+  if (p == 0)\n+    __builtin_abort ();\n+  return p;\n+}\n+\n+__attribute__((noinline, no_icf, used))\n+static void *bar(__SIZE_TYPE__ n)\n+{\n+  void *p = f (n);\n+  return p;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Function f found to be malloc\" \"pure-const\" } } */\n+/* { dg-final { scan-ipa-dump \"Function bar found to be malloc\" \"pure-const\" } } */"}, {"sha": "95b2fd74a7a2c473c2c18612777ab4b371f6c888", "filename": "gcc/testsuite/gcc.dg/ipa/propmalloc-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-2.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-pure-const-details\" } */\n+\n+__attribute__((noinline, used, no_icf))\n+static void *foo (__SIZE_TYPE__ n)\n+{\n+  return __builtin_malloc (n * 10);\n+}\n+\n+__attribute__((noinline, used, no_icf))\n+static void *bar(__SIZE_TYPE__ n, int cond)\n+{\n+  void *p;\n+  if (cond)\n+    p = foo (n);\n+  else\n+    p = __builtin_malloc (n);\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Function foo found to be malloc\" \"pure-const\" } } */\n+/* { dg-final { scan-ipa-dump \"Function bar found to be malloc\" \"pure-const\" } } */"}, {"sha": "13558ddd07df55a20f13487d94308b1645974c0f", "filename": "gcc/testsuite/gcc.dg/ipa/propmalloc-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fab169b28a37a9239138aee499b211523c39f28/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpropmalloc-3.c?ref=0fab169b28a37a9239138aee499b211523c39f28", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-ipa-pure-const-details\" } */\n+\n+static void *foo(__SIZE_TYPE__, int) __attribute__((noinline, no_icf, used));\n+\n+__attribute__((noinline, used, no_icf))\n+static void *bar(__SIZE_TYPE__ n, int m)\n+{\n+  return foo (n, m);\n+}\n+\n+static void *foo(__SIZE_TYPE__ n, int m)\n+{\n+  void *p;\n+  if (m > 0)\n+    p = bar (n, --m);\n+  else\n+    p = __builtin_malloc (n);\n+\n+  return p;\n+}\n+\n+/* { dg-final { scan-ipa-dump \"Function foo found to be malloc\" \"pure-const\" } } */\n+/* { dg-final { scan-ipa-dump \"Function bar found to be malloc\" \"pure-const\" } } */"}]}