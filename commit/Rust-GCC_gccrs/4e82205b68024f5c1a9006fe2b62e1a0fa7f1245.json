{"sha": "4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "node_id": "C_kwDOANBUbNoAKDRlODIyMDViNjgwMjRmNWMxYTkwMDZmZTJiNjJlMWEwZmE3ZjEyNDU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-01T11:20:42Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-07-04T09:34:20Z"}, "message": "Integrate nonzero bits with irange.\n\nThe nonzero bits and integer ranges compliment each other quite well,\nand it only makes sense to make the mask a first class citizen in the\nirange.  We do a half assed job of keeping ranges and nonzero bits\nsomewhat in sync in SSA_NAME_RANGE_INFO, and the goal has always\nbeen to integrate them properly.  This patch does that, in preparation\nfor streaming out full-resolution iranges between passes (think\nSSA_NAME_RANGE_INFO).\n\nHaving nonzero bits in the irange allows us to get better results from\nthings like irange::contains_p() and keeping them in the irange allows\nus to propagate the bits throughout with the ranger.  This patch\nprovides the bare infrastructure, without any optimizations to\nrange-ops, etc.  Those will come as follow-ups.\n\nA few notes:\n\nLegacy SSA_NAME_RANGE_INFO updates the nonzero bits every time a range\nis set.  Here instead, we don't update the nonzero bits on a new\nrange, but calculate it on the fly when irange::get_nonzero_bits() is\ncalled.  The goal is to only store nonzero bits that provide\nmeaningful information that can't be gleaned from the range itself.\nBut you can always call get_nonzero_bits() and get the full\ninformation.\n\nNonzero bits are not supported in legacy mode.  The mask may be set\nas a consequence of propagation or reading global ranges, but no\none from legacy land should be querying irange::get_nonzero_bits.  There\nis an assert enforcing this.  However, legacy/global set_nonzero_bits()\ncontinue to work as before.  There is no change to legacy behavior.\n\nThere is virtually no performance change with this patch, as there are\nno consumers.  The next patch I post will be the SSA_NAME_RANGE_INFO\nconversion to the new world, in which I will discuss performance\nproper.  Hint: I'll be chewing up the time budget we gained with the\nvrange conversion.\n\nTested and benchmarked on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* value-range-storage.cc (irange_storage_slot::set_irange): Set\n\tnonzero bits in irange.\n\t(irange_storage_slot::get_irange): Get nonzero bits from irange.\n\t* value-range.cc (irange::operator=): Set nonzero bits.\n\t(irange::irange_set): Same.\n\t(irange::irange_set_anti_range): Same.\n\t(irange::set): Same.\n\t(irange::verify_range): Same.\n\t(irange::legacy_equal_p): Check nonzero bits.\n\t(irange::equal_p): Same.\n\t(irange::contains_p): Handle nonzero bits.\n\t(irange::irange_union): Same.\n\t(irange::irange_intersect): Same.\n\t(irange::dump): Same.\n\t(irange::set_nonzero_bits): New.\n\t(irange::get_nonzero_bits): New.\n\t(irange::intersect_nonzero_bits): New.\n\t(irange::union_nonzero_bits): New.\n\t(irange::dump_bitmasks): New.\n\t* value-range.h (class irange): Add m_nonzero_mask.\n\t(gt_ggc_mx): Handle nonzero bits.\n\t(gt_pch_nx): Same.\n\t(irange::set_undefined): Set nonzero bits.\n\t(irange::set_varying): Same.\n\t(irange::normalize_kind): Call set_undefined.", "tree": {"sha": "77cebaa3afd64005e885a7660996b11fa753eda8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77cebaa3afd64005e885a7660996b11fa753eda8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d2a898666609452ef79a14feae1cadc3538e4b45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2a898666609452ef79a14feae1cadc3538e4b45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2a898666609452ef79a14feae1cadc3538e4b45"}], "stats": {"total": 206, "additions": 193, "deletions": 13}, "files": [{"sha": "ac62bfaa638db601011b3cac646d41d43535a5dd", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "patch": "@@ -131,7 +131,12 @@ irange_storage_slot::set_irange (const irange &r)\n {\n   gcc_checking_assert (fits_p (r));\n \n-  //m_ints[0] = r.get_nonzero_bits ();\n+  // Avoid calling unsupported get_nonzero_bits on legacy.\n+  if (r.legacy_mode_p ())\n+    m_ints[0] = -1;\n+  else\n+    m_ints[0] = r.get_nonzero_bits ();\n+\n   unsigned pairs = r.num_pairs ();\n   for (unsigned i = 0; i < pairs; ++i)\n     {\n@@ -154,7 +159,7 @@ irange_storage_slot::get_irange (irange &r, tree type) const\n       int_range<2> tmp (type, m_ints[i], m_ints[i + 1]);\n       r.union_ (tmp);\n     }\n-  //r.set_nonzero_bits (get_nonzero_bits ());\n+  r.set_nonzero_bits (get_nonzero_bits ());\n }\n \n // Return the size in bytes to allocate a slot that can hold R."}, {"sha": "25f1acff4a319ec2f2bc6fa883a0314726605863", "filename": "gcc/value-range.cc", "status": "modified", "additions": 167, "deletions": 10, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "patch": "@@ -274,6 +274,7 @@ irange::operator= (const irange &src)\n \n   m_num_ranges = lim;\n   m_kind = src.m_kind;\n+  m_nonzero_mask = src.m_nonzero_mask;\n   return *this;\n }\n \n@@ -393,6 +394,7 @@ irange::irange_set (tree min, tree max)\n   m_num_ranges = 1;\n   m_kind = VR_RANGE;\n   normalize_kind ();\n+  m_nonzero_mask = NULL;\n \n   if (flag_checking)\n     verify_range ();\n@@ -466,6 +468,7 @@ irange::irange_set_anti_range (tree min, tree max)\n \n   m_kind = VR_RANGE;\n   normalize_kind ();\n+  m_nonzero_mask = NULL;\n \n   if (flag_checking)\n     verify_range ();\n@@ -524,6 +527,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n       m_base[0] = min;\n       m_base[1] = max;\n       m_num_ranges = 1;\n+      m_nonzero_mask = NULL;\n       return;\n     }\n \n@@ -574,6 +578,7 @@ irange::set (tree min, tree max, value_range_kind kind)\n   m_base[1] = max;\n   m_num_ranges = 1;\n   normalize_kind ();\n+  m_nonzero_mask = NULL;\n   if (flag_checking)\n     verify_range ();\n }\n@@ -587,8 +592,11 @@ irange::verify_range ()\n   if (m_kind == VR_UNDEFINED)\n     {\n       gcc_checking_assert (m_num_ranges == 0);\n+      gcc_checking_assert (!m_nonzero_mask);\n       return;\n     }\n+  if (m_nonzero_mask)\n+    gcc_checking_assert (wi::to_wide (m_nonzero_mask) != -1);\n   if (m_kind == VR_VARYING)\n     {\n       gcc_checking_assert (m_num_ranges == 1);\n@@ -680,11 +688,15 @@ irange::legacy_equal_p (const irange &other) const\n   if (m_kind == VR_UNDEFINED)\n     return true;\n   if (m_kind == VR_VARYING)\n-    return range_compatible_p (type (), other.type ());\n+    {\n+      return (range_compatible_p (type (), other.type ())\n+\t      && vrp_operand_equal_p (m_nonzero_mask, other.m_nonzero_mask));\n+    }\n   return (vrp_operand_equal_p (tree_lower_bound (0),\n \t\t\t       other.tree_lower_bound (0))\n \t  && vrp_operand_equal_p (tree_upper_bound (0),\n-\t\t\t\t  other.tree_upper_bound (0)));\n+\t\t\t\t  other.tree_upper_bound (0))\n+\t  && vrp_operand_equal_p (m_nonzero_mask, other.m_nonzero_mask));\n }\n \n bool\n@@ -716,7 +728,7 @@ irange::operator== (const irange &other) const\n \t  || !operand_equal_p (ub, ub_other, 0))\n \treturn false;\n     }\n-  return true;\n+  return vrp_operand_equal_p (m_nonzero_mask, other.m_nonzero_mask);\n }\n \n /* Return TRUE if this is a symbolic range.  */\n@@ -858,6 +870,14 @@ irange::contains_p (tree cst) const\n     }\n \n   gcc_checking_assert (TREE_CODE (cst) == INTEGER_CST);\n+\n+  if (m_nonzero_mask)\n+    {\n+      wide_int cstw = wi::to_wide (cst);\n+      if (cstw != 0 && wi::bit_and (wi::to_wide (m_nonzero_mask), cstw) == 0)\n+\treturn false;\n+    }\n+\n   signop sign = TYPE_SIGN (TREE_TYPE (cst));\n   wide_int v = wi::to_wide (cst);\n   for (unsigned r = 0; r < m_num_ranges; ++r)\n@@ -1809,22 +1829,40 @@ irange::irange_union (const irange &r)\n {\n   gcc_checking_assert (!legacy_mode_p () && !r.legacy_mode_p ());\n \n-  if (r.undefined_p () || varying_p ())\n+  if (r.undefined_p ())\n     return false;\n \n-  if (undefined_p () || r.varying_p ())\n+  if (undefined_p ())\n     {\n       operator= (r);\n       return true;\n     }\n \n+  // Save the nonzero mask in case the set operations below clobber it.\n+  bool ret_nz = union_nonzero_bits (r);\n+  tree saved_nz = m_nonzero_mask;\n+\n+  if (varying_p ())\n+    return ret_nz;\n+\n+  if (r.varying_p ())\n+    {\n+      set_varying (r.type ());\n+      set_nonzero_bits (saved_nz);\n+      return true;\n+    }\n+\n   // Special case one range union one range.\n   if (m_num_ranges == 1 && r.m_num_ranges == 1)\n-    return irange_single_pair_union (r);\n+    {\n+      bool ret = irange_single_pair_union (r);\n+      set_nonzero_bits (saved_nz);\n+      return ret || ret_nz;\n+    }\n \n   // If this ranges fully contains R, then we need do nothing.\n   if (irange_contains_p (r))\n-    return false;\n+    return ret_nz;\n \n   // Do not worry about merging and such by reserving twice as many\n   // pairs as needed, and then simply sort the 2 ranges into this\n@@ -1913,6 +1951,7 @@ irange::irange_union (const irange &r)\n \n   m_kind = VR_RANGE;\n   normalize_kind ();\n+  set_nonzero_bits (saved_nz);\n \n   if (flag_checking)\n     verify_range ();\n@@ -1974,25 +2013,38 @@ irange::irange_intersect (const irange &r)\n   gcc_checking_assert (undefined_p () || r.undefined_p ()\n \t\t       || range_compatible_p (type (), r.type ()));\n \n-  if (undefined_p () || r.varying_p ())\n+  if (undefined_p ())\n     return false;\n   if (r.undefined_p ())\n     {\n       set_undefined ();\n       return true;\n     }\n+\n+  // Save the nonzero mask in case the set operations below clobber it.\n+  bool ret_nz = intersect_nonzero_bits (r);\n+  tree saved_nz = m_nonzero_mask;\n+\n+  if (r.varying_p ())\n+    return ret_nz;\n+\n   if (varying_p ())\n     {\n       operator= (r);\n+      set_nonzero_bits (saved_nz);\n       return true;\n     }\n \n   if (r.num_pairs () == 1)\n-    return intersect (r.lower_bound (), r.upper_bound ());\n+    {\n+      bool res = intersect (r.lower_bound (), r.upper_bound ());\n+      set_nonzero_bits (saved_nz);\n+      return res || saved_nz;\n+    }\n \n   // If R fully contains this, then intersection will change nothing.\n   if (r.irange_contains_p (*this))\n-    return false;\n+    return ret_nz;\n \n   signop sign = TYPE_SIGN (TREE_TYPE(m_base[0]));\n   unsigned bld_pair = 0;\n@@ -2064,6 +2116,8 @@ irange::irange_intersect (const irange &r)\n \n   m_kind = VR_RANGE;\n   normalize_kind ();\n+  if (!undefined_p ())\n+    set_nonzero_bits (saved_nz);\n \n   if (flag_checking)\n     verify_range ();\n@@ -2074,6 +2128,8 @@ irange::irange_intersect (const irange &r)\n \n // Multirange intersect for a specified wide_int [lb, ub] range.\n // Return TRUE if intersect changed anything.\n+//\n+// NOTE: It is the caller's responsibility to intersect the nonzero masks.\n \n bool\n irange::intersect (const wide_int& lb, const wide_int& ub)\n@@ -2277,6 +2333,90 @@ irange::invert ()\n     verify_range ();\n }\n \n+void\n+irange::set_nonzero_bits (const wide_int_ref &bits)\n+{\n+  gcc_checking_assert (!undefined_p ());\n+\n+  if (bits == -1)\n+    {\n+      m_nonzero_mask = NULL;\n+      return;\n+    }\n+  m_nonzero_mask = wide_int_to_tree (type (), bits);\n+}\n+\n+wide_int\n+irange::get_nonzero_bits () const\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  // Nonzero bits are unsupported in legacy mode.  The mask may be set\n+  // as a consequence of propagation or reading global ranges, but no\n+  // one from legacy land should be querying this.\n+  gcc_checking_assert (!legacy_mode_p ());\n+\n+  // Calculate the nonzero bits inherent in the range.\n+  wide_int min = lower_bound ();\n+  wide_int max = upper_bound ();\n+  wide_int xorv = min ^ max;\n+  if (xorv != 0)\n+    {\n+      unsigned prec = TYPE_PRECISION (type ());\n+      xorv = wi::mask (prec - wi::clz (xorv), false, prec);\n+    }\n+  wide_int mask = min | xorv;\n+\n+  // Return the nonzero bits augmented by the range.\n+  if (m_nonzero_mask)\n+    return mask & wi::to_wide (m_nonzero_mask);\n+\n+  return mask;\n+}\n+\n+// Intersect the nonzero bits in R into THIS.\n+\n+bool\n+irange::intersect_nonzero_bits (const irange &r)\n+{\n+  gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n+\n+  if (!r.m_nonzero_mask)\n+    return false;\n+  if (!m_nonzero_mask)\n+    {\n+      m_nonzero_mask = r.m_nonzero_mask;\n+      return true;\n+    }\n+  wide_int i = wi::bit_and (wi::to_wide (m_nonzero_mask),\n+\t\t\t    wi::to_wide (r.m_nonzero_mask));\n+  set_nonzero_bits (i);\n+  return true;\n+}\n+\n+// Union the nonzero bits in R into THIS.\n+\n+bool\n+irange::union_nonzero_bits (const irange &r)\n+{\n+  gcc_checking_assert (!undefined_p () && !r.undefined_p ());\n+\n+  if (!m_nonzero_mask)\n+    return false;\n+  if (!r.m_nonzero_mask)\n+    {\n+      if (m_nonzero_mask)\n+\t{\n+\t  m_nonzero_mask = NULL;\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  wide_int i = wi::bit_or (wi::to_wide (m_nonzero_mask),\n+\t\t\t   wi::to_wide (r.m_nonzero_mask));\n+  set_nonzero_bits (i);\n+  return true;\n+}\n+\n static void\n dump_bound_with_infinite_markers (FILE *file, tree bound)\n {\n@@ -2312,6 +2452,7 @@ irange::dump (FILE *file) const\n   if (varying_p ())\n     {\n       fprintf (file, \"VARYING\");\n+      dump_bitmasks (file);\n       return;\n     }\n  if (legacy_mode_p ())\n@@ -2321,6 +2462,7 @@ irange::dump (FILE *file) const\n       fprintf (file, \", \");\n       dump_bound_with_infinite_markers (file, max ());\n       fprintf (file, \"]\");\n+      dump_bitmasks (file);\n       return;\n     }\n   for (unsigned i = 0; i < m_num_ranges; ++i)\n@@ -2333,6 +2475,21 @@ irange::dump (FILE *file) const\n       dump_bound_with_infinite_markers (file, ub);\n       fprintf (file, \"]\");\n     }\n+  dump_bitmasks (file);\n+}\n+\n+void\n+irange::dump_bitmasks (FILE *file) const\n+{\n+  if (m_nonzero_mask && !legacy_mode_p ())\n+    {\n+      wide_int nz = get_nonzero_bits ();\n+      if (nz != -1)\n+\t{\n+\t  fprintf (file, \" NONZERO \");\n+\t  print_hex (nz, file);\n+\t}\n+    }\n }\n \n void"}, {"sha": "2e48d92d1898a754abc9d06444a1b47cbc5a5aa3", "filename": "gcc/value-range.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e82205b68024f5c1a9006fe2b62e1a0fa7f1245/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=4e82205b68024f5c1a9006fe2b62e1a0fa7f1245", "patch": "@@ -109,6 +109,7 @@ class vrange\n class GTY((user)) irange : public vrange\n {\n   friend class vrange_allocator;\n+  friend class irange_storage_slot; // For legacy_mode_p checks.\n public:\n   // In-place setters.\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n@@ -149,6 +150,10 @@ class GTY((user)) irange : public vrange\n   virtual bool fits_p (const vrange &r) const override;\n   virtual void dump (FILE * = stderr) const override;\n \n+  // Nonzero masks.\n+  wide_int get_nonzero_bits () const;\n+  void set_nonzero_bits (const wide_int_ref &bits);\n+\n   // Deprecated legacy public methods.\n   tree min () const;\t\t\t\t// DEPRECATED\n   tree max () const;\t\t\t\t// DEPRECATED\n@@ -196,10 +201,15 @@ class GTY((user)) irange : public vrange\n \n   void irange_set_1bit_anti_range (tree, tree);\n   bool varying_compatible_p () const;\n+  void set_nonzero_bits (tree bits) { m_nonzero_mask = bits; }\n+  bool intersect_nonzero_bits (const irange &r);\n+  bool union_nonzero_bits (const irange &r);\n+  void dump_bitmasks (FILE *) const;\n \n   bool intersect (const wide_int& lb, const wide_int& ub);\n   unsigned char m_num_ranges;\n   unsigned char m_max_ranges;\n+  tree m_nonzero_mask;\n   tree *m_base;\n };\n \n@@ -608,6 +618,8 @@ gt_ggc_mx (irange *x)\n       gt_ggc_mx (x->m_base[i * 2]);\n       gt_ggc_mx (x->m_base[i * 2 + 1]);\n     }\n+  if (x->m_nonzero_mask)\n+    gt_ggc_mx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -618,6 +630,8 @@ gt_pch_nx (irange *x)\n       gt_pch_nx (x->m_base[i * 2]);\n       gt_pch_nx (x->m_base[i * 2 + 1]);\n     }\n+  if (x->m_nonzero_mask)\n+    gt_pch_nx (x->m_nonzero_mask);\n }\n \n inline void\n@@ -628,6 +642,8 @@ gt_pch_nx (irange *x, gt_pointer_operator op, void *cookie)\n       op (&x->m_base[i * 2], NULL, cookie);\n       op (&x->m_base[i * 2 + 1], NULL, cookie);\n     }\n+  if (x->m_nonzero_mask)\n+    op (&x->m_nonzero_mask, NULL, cookie);\n }\n \n template<unsigned N>\n@@ -722,13 +738,15 @@ irange::set_undefined ()\n {\n   m_kind = VR_UNDEFINED;\n   m_num_ranges = 0;\n+  m_nonzero_mask = NULL;\n }\n \n inline void\n irange::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   m_num_ranges = 1;\n+  m_nonzero_mask = NULL;\n \n   if (INTEGRAL_TYPE_P (type))\n     {\n@@ -843,7 +861,7 @@ inline void\n irange::normalize_kind ()\n {\n   if (m_num_ranges == 0)\n-    m_kind = VR_UNDEFINED;\n+    set_undefined ();\n   else if (varying_compatible_p ())\n     {\n       if (m_kind == VR_RANGE)"}]}