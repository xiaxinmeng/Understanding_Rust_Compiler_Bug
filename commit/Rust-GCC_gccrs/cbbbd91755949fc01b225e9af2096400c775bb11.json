{"sha": "cbbbd91755949fc01b225e9af2096400c775bb11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JiYmQ5MTc1NTk0OWZjMDFiMjI1ZTlhZjIwOTY0MDBjNzc1YmIxMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-05-09T10:21:13Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-05-09T10:21:13Z"}, "message": "AIX shared libraries\n\nFrom-SVN: r9595", "tree": {"sha": "d31a22918fc70569a99074fe7d84d032092ea90e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d31a22918fc70569a99074fe7d84d032092ea90e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cbbbd91755949fc01b225e9af2096400c775bb11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbbd91755949fc01b225e9af2096400c775bb11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cbbbd91755949fc01b225e9af2096400c775bb11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cbbbd91755949fc01b225e9af2096400c775bb11/comments", "author": null, "committer": null, "parents": [{"sha": "d2eb08764ba3781d6ce6811d8a93a4a430951d3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2eb08764ba3781d6ce6811d8a93a4a430951d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2eb08764ba3781d6ce6811d8a93a4a430951d3c"}], "stats": {"total": 155, "additions": 113, "deletions": 42}, "files": [{"sha": "717d11dee24045c34dfe8216aff3e2af4c44e99d", "filename": "gcc/collect2.c", "status": "modified", "additions": 113, "deletions": 42, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cbbbd91755949fc01b225e9af2096400c775bb11/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cbbbd91755949fc01b225e9af2096400c775bb11/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=cbbbd91755949fc01b225e9af2096400c775bb11", "patch": "@@ -226,6 +226,7 @@ struct head\n \n enum pass {\n   PASS_FIRST,\t\t\t\t/* without constructors */\n+  PASS_OBJ,\t\t\t\t/* individual objects */\n   PASS_LIB,\t\t\t        /* looking for shared libraries */\n   PASS_SECOND\t\t\t\t/* with constructors linked in */\n };\n@@ -249,15 +250,19 @@ static int   temp_filename_length;\t/* Length of temp_filename */\n static char *temp_filename;\t\t/* Base of temp filenames */\n static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list. */\n static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list. */\n+static char *export_file;\t        /* <xxx>.x for AIX export list. */\n+static int  auto_export = 1;\t        /* true if exporting everything. */\n char *ldout;\t\t\t\t/* File for ld errors.  */\n static char *output_file;\t\t/* Output file for ld.  */\n static char *nm_file_name;\t\t/* pathname of nm */\n static char *ldd_file_name;\t\t/* pathname of ldd (or equivalent) */\n static char *strip_file_name;\t\t/* pathname of strip */\n char *c_file_name;\t\t        /* pathname of gcc */\n+static char *initname, *fininame;\t/* names of init and fini funcs */\n \n static struct head constructors;\t/* list of constructors found */\n static struct head destructors;\t\t/* list of destructors found */\n+static struct head exports;\t\t/* list of exported symbols */\n \n struct obstack temporary_obstack;\n struct obstack permanent_obstack;\n@@ -296,13 +301,15 @@ static int is_in_prefix_list\tPROTO((struct path_prefix *, char *, int));\n static char *find_a_file\tPROTO((struct path_prefix *, char *));\n static void add_prefix\t\tPROTO((struct path_prefix *, char *));\n static void prefix_from_env\tPROTO((char *, struct path_prefix *));\n+static void prefix_from_string\tPROTO((char *, struct path_prefix *));\n static void do_wait\t\tPROTO((char *));\n static void fork_execute\tPROTO((char *, char **));\n static void maybe_unlink\tPROTO((char *));\n static void add_to_list\t\tPROTO((struct head *, char *));\n static void write_list\t\tPROTO((FILE *, char *, struct id *));\n static void write_list_with_asm PROTO((FILE *, char *, struct id *));\n static void write_c_file\tPROTO((FILE *, char *));\n+static void write_export_file\tPROTO((FILE *));\n static void scan_prog_file\tPROTO((char *, enum pass));\n static void scan_libraries\tPROTO((char *));\n \n@@ -369,6 +376,9 @@ collect_exit (status)\n   if (o_file != 0 && o_file[0])\n     maybe_unlink (o_file);\n \n+  if (export_file != 0 && export_file[0])\n+    maybe_unlink (export_file);\n+\n   if (ldout != 0 && ldout[0])\n     {\n       dump_file (ldout);\n@@ -860,36 +870,42 @@ prefix_from_env (env, pprefix)\n   char *p = getenv (env);\n \n   if (p)\n-    {\n-      char *startp, *endp;\n-      char *nstore = (char *) xmalloc (strlen (p) + 3);\n+    prefix_from_string (p, pprefix);\n+}\n+\n+static void\n+prefix_from_string (p, pprefix)\n+     char *p;\n+     struct path_prefix *pprefix;\n+{\n+  char *startp, *endp;\n+  char *nstore = (char *) xmalloc (strlen (p) + 3);\n \n-      startp = endp = p;\n-      while (1)\n+  startp = endp = p;\n+  while (1)\n+    {\n+      if (*endp == PATH_SEPARATOR || *endp == 0)\n \t{\n-\t  if (*endp == PATH_SEPARATOR || *endp == 0)\n+\t  strncpy (nstore, startp, endp-startp);\n+\t  if (endp == startp)\n \t    {\n-\t      strncpy (nstore, startp, endp-startp);\n-\t      if (endp == startp)\n-\t\t{\n-\t\t  strcpy (nstore, \"./\");\n-\t\t}\n-\t      else if (endp[-1] != '/')\n-\t\t{\n-\t\t  nstore[endp-startp] = '/';\n-\t\t  nstore[endp-startp+1] = 0;\n-\t\t}\n-\t      else\n-\t\tnstore[endp-startp] = 0;\n-\n-\t      add_prefix (pprefix, nstore);\n-\t      if (*endp == 0)\n-\t\tbreak;\n-\t      endp = startp = endp + 1;\n+\t      strcpy (nstore, \"./\");\n+\t    }\n+\t  else if (endp[-1] != '/')\n+\t    {\n+\t      nstore[endp-startp] = '/';\n+\t      nstore[endp-startp+1] = 0;\n \t    }\n \t  else\n-\t    endp++;\n+\t    nstore[endp-startp] = 0;\n+\n+\t  add_prefix (pprefix, nstore);\n+\t  if (*endp == 0)\n+\t    break;\n+\t  endp = startp = endp + 1;\n \t}\n+      else\n+\tendp++;\n     }\n }\n \f\n@@ -918,16 +934,16 @@ main (argc, argv)\n   char *gstrip_suffix\t= \"gstrip\";\n   char *full_gstrip_suffix = gstrip_suffix;\n   char *arg;\n-  FILE *outf;\n+  FILE *outf, *exportf;\n   char *ld_file_name;\n   char *collect_name;\n   char *collect_names;\n   char *p;\n   char **c_argv;\n   char **c_ptr;\n-  char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+2);\n+  char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+3);\n   char **ld1\t\t= ld1_argv;\n-  char **ld2_argv\t= (char **) xcalloc (sizeof (char *), argc+5);\n+  char **ld2_argv\t= (char **) xcalloc (sizeof (char *), argc+6);\n   char **ld2\t\t= ld2_argv;\n   char **object_lst\t= (char **) xcalloc (sizeof (char *), argc);\n   char **object\t\t= object_lst;\n@@ -1183,10 +1199,12 @@ main (argc, argv)\n   choose_temp_base ();\n   c_file = xcalloc (temp_filename_length + sizeof (\".c\"), 1);\n   o_file = xcalloc (temp_filename_length + sizeof (\".o\"), 1);\n+  export_file = xmalloc (temp_filename_length + sizeof (\".x\"));\n   ldout = xmalloc (temp_filename_length + sizeof (\".ld\"));\n   sprintf (ldout, \"%s.ld\", temp_filename);\n   sprintf (c_file, \"%s.c\", temp_filename);\n   sprintf (o_file, \"%s.o\", temp_filename);\n+  sprintf (export_file, \"%s.x\", temp_filename);\n   *c_ptr++ = c_file_name;\n   *c_ptr++ = \"-c\";\n   *c_ptr++ = \"-o\";\n@@ -1221,6 +1239,14 @@ main (argc, argv)\n \t\t}\n \t      break;\n \n+#ifdef COLLECT_EXPORT_LIST\n+\t    case 'b':\n+\t      if (!strncmp (arg, \"-bE:\", 4)\n+\t\t  || !strncmp (arg, \"-bexport:\", 9))\n+\t\tauto_export = 0;\n+\t      break;\n+#endif\n+\n \t    case 'l':\n \t      if (first_file)\n \t\t{\n@@ -1303,6 +1329,26 @@ main (argc, argv)\n #endif\n     }\n \n+#ifdef COLLECT_EXPORT_LIST\n+  /* The AIX linker will discard static constructors in object files if\n+     nothing else in the file is referenced, so look at them first.  */\n+  while (object_lst < object)\n+    scan_prog_file (*object_lst++, PASS_OBJ);\n+\n+  {\n+    char *buf = alloca (strlen (export_file) + 5);\n+    sprintf (buf, \"-bE:%s\", export_file);\n+    *ld1++ = buf;\n+    *ld2++ = buf;\n+    exportf = fopen (export_file, \"w\");\n+    if (exportf == (FILE *)0)\n+      fatal_perror (\"%s\", export_file);\n+    write_export_file (exportf);\n+    if (fclose (exportf))\n+      fatal_perror (\"closing %s\", export_file);\n+  }\n+#endif\n+\n   *c_ptr++ = c_file;\n   *object = *c_ptr = *ld1 = *ld2 = (char *)0;\n \n@@ -1374,13 +1420,6 @@ main (argc, argv)\n      and destructors to call.\n      Write the constructor and destructor tables to a .s file and reload. */\n \n-#ifdef COLLECT_SCAN_OBJECTS\n-  /* The AIX linker will discard static constructors in object files if\n-     nothing else in the file is referenced, so look at them first.  */\n-  while (object_lst < object)\n-    scan_prog_file (*object_lst++, PASS_FIRST);\n-#endif\n-\n   scan_prog_file (output_file, PASS_FIRST);\n \n #ifdef SCAN_LIBRARIES\n@@ -1424,12 +1463,31 @@ main (argc, argv)\n   if (fclose (outf))\n     fatal_perror (\"closing %s\", c_file);\n \n+#ifdef COLLECT_EXPORT_LIST\n+  if (shared_obj)\n+    {\n+      add_to_list (&exports, initname);\n+      add_to_list (&exports, fininame);\n+      exportf = fopen (export_file, \"w\");\n+      if (exportf == (FILE *)0)\n+\tfatal_perror (\"%s\", export_file);\n+      write_export_file (exportf);\n+      if (fclose (exportf))\n+\tfatal_perror (\"closing %s\", export_file);\n+    }\n+#endif\n+\n   if (debug)\n     {\n       fprintf (stderr, \"\\n========== output_file = %s, c_file = %s\\n\",\n \t       output_file, c_file);\n       write_c_file (stderr, \"stderr\");\n       fprintf (stderr, \"========== end of c_file\\n\\n\");\n+#ifdef COLLECT_EXPORT_LIST\n+      fprintf (stderr, \"\\n========== export_file = %s\\n\", export_file);\n+      write_export_file (stderr);\n+      fprintf (stderr, \"========== end of export_file\\n\\n\");\n+#endif\n     }\n \n   /* Assemble the constructor and destructor tables.\n@@ -1444,6 +1502,7 @@ main (argc, argv)\n \n   maybe_unlink (c_file);\n   maybe_unlink (o_file);\n+  maybe_unlink (export_file);\n   return 0;\n }\n \n@@ -1653,7 +1712,6 @@ write_c_file_stat (stream, name)\n      char *name;\n {\n   char *prefix, *p, *q;\n-  char *initname, *fininame;\n \n   /* Figure out name of output_file, stripping off .so version.  */\n   p = rindex (output_file, '/');\n@@ -1736,9 +1794,6 @@ write_c_file_stat (stream, name)\n \n   fprintf (stream, \"void _GLOBAL__DI() {\\n\\t%s();\\n}\\n\", initname);\n   fprintf (stream, \"void _GLOBAL__DD() {\\n\\t%s();\\n}\\n\", fininame);\n-\n-  free (initname);\n-  free (fininame);\n }\n \n /* Write the constructor/destructor tables. */\n@@ -1780,6 +1835,15 @@ write_c_file (stream, name)\n   else\n     write_c_file_glob (stream, name);\n }\n+\n+static void\n+write_export_file (stream)\n+     FILE *stream;\n+{\n+  struct id *list = exports.first;\n+  for (; list; list = list->next)\n+    fprintf (stream, \"%s\\n\", list->name);\n+}\n \f\n #ifdef OBJECT_FORMAT_NONE\n \n@@ -2395,7 +2459,7 @@ scan_prog_file (prog_name, which_pass)\n   LDFILE *ldptr = NULL;\n   int sym_index, sym_count;\n \n-  if (which_pass != PASS_FIRST)\n+  if (which_pass != PASS_FIRST && which_pass != PASS_OBJ)\n     return;\n \n   if ((ldptr = ldopen (prog_name, ldptr)) == NULL)\n@@ -2423,23 +2487,30 @@ scan_prog_file (prog_name, which_pass)\n \t      if ((name = ldgetname (ldptr, &symbol)) == NULL)\n \t\tcontinue;\t\t/* should never happen */\n \n-#ifdef _AIX\n-\t      /* All AIX function names begin with a dot. */\n-\t      if (*name++ != '.')\n+#ifdef XCOFF_DEBUGGING_INFO\n+\t      /* All AIX function names have a duplicate entry beginning\n+\t\t with a dot. */\n+\t      if (*name == '.')\n \t\tcontinue;\n #endif\n \n \t      switch (is_ctor_dtor (name))\n \t\t{\n \t\tcase 1:\n \t\t  add_to_list (&constructors, name);\n+\t\t  if (which_pass == PASS_OBJ)\n+\t\t    add_to_list (&exports, name);\n \t\t  break;\n \n \t\tcase 2:\n \t\t  add_to_list (&destructors, name);\n+\t\t  if (which_pass == PASS_OBJ)\n+\t\t    add_to_list (&exports, name);\n \t\t  break;\n \n \t\tdefault:\t\t/* not a constructor or destructor */\n+\t\t  if (which_pass == PASS_OBJ && auto_export)\n+\t\t    add_to_list (&exports, name);\n \t\t  continue;\n \t\t}\n "}]}