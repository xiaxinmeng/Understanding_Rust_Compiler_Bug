{"sha": "8a912a6e1046ad6137c0792522787d66ed24bb0d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGE5MTJhNmUxMDQ2YWQ2MTM3YzA3OTI1MjI3ODdkNjZlZDI0YmIwZA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T12:57:34Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-15T12:57:34Z"}, "message": "[multiple changes]\n\n2009-04-15  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch9.adb: Comment improvements.\n\t(Build_Entry_Family_Name): Add parentheses around the index of a entry\n\tfamily member.\n\n2009-04-15  Bob Duff  <duff@adacore.com>\n\n\t* sem_warn.adb (Check_Infinite_Loop_Warning): Catch cases like\n\t\"while X /= null loop\" where X is unchanged inside the loop. We were\n\tnot warning in this case, because of the pointers -- we feared that the\n\tloop variable could be updated via a pointer, if there are any pointers\n\taround the place. But that is impossible in this case.\n\n\t* sem_util.adb (May_Be_Lvalue): This routine was overly pessimistic in\n\tthe case of dereferences. In X.all, X cannot be an l-value. We now\n\tcatch that case (and implicit dereferences, too).\n\n2009-04-15  Vincent Celier  <celier@adacore.com>\n\n\t* sinput-p.ads, sinput-p.adb (Clear_Source_File_Table): New procedure\n\n2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Is_Actual_Of_Previous_Formal): Make fully recursive.\n\tFrom code reading.\n\t(Analyze_Package_Instantiation): If generic unit in child instance is\n\tthe same as generic unit in parent instance, look for an outer homonym\n\tto locate the desired generic.\n\nFrom-SVN: r146112", "tree": {"sha": "3489ca9074d53f4ef4b6e41caf8e4ddb5ef09213", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3489ca9074d53f4ef4b6e41caf8e4ddb5ef09213"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8a912a6e1046ad6137c0792522787d66ed24bb0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a912a6e1046ad6137c0792522787d66ed24bb0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a912a6e1046ad6137c0792522787d66ed24bb0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a912a6e1046ad6137c0792522787d66ed24bb0d/comments", "author": null, "committer": null, "parents": [{"sha": "4a13695ca1f5a81aa054ff52e15705b88016bd17", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a13695ca1f5a81aa054ff52e15705b88016bd17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a13695ca1f5a81aa054ff52e15705b88016bd17"}], "stats": {"total": 192, "additions": 167, "deletions": 25}, "files": [{"sha": "b02eed282e563013b7a52e5d6d3b267e164fdfda", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -1,3 +1,33 @@\n+2009-04-15  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch9.adb: Comment improvements.\n+\t(Build_Entry_Family_Name): Add parentheses around the index of a entry\n+\tfamily member.\n+\n+2009-04-15  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_warn.adb (Check_Infinite_Loop_Warning): Catch cases like\n+\t\"while X /= null loop\" where X is unchanged inside the loop. We were\n+\tnot warning in this case, because of the pointers -- we feared that the\n+\tloop variable could be updated via a pointer, if there are any pointers\n+\taround the place. But that is impossible in this case.\n+\n+\t* sem_util.adb (May_Be_Lvalue): This routine was overly pessimistic in\n+\tthe case of dereferences. In X.all, X cannot be an l-value. We now\n+\tcatch that case (and implicit dereferences, too).\n+\n+2009-04-15  Vincent Celier  <celier@adacore.com>\n+\n+\t* sinput-p.ads, sinput-p.adb (Clear_Source_File_Table): New procedure\n+\n+2009-04-15  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Is_Actual_Of_Previous_Formal): Make fully recursive.\n+\tFrom code reading.\n+\t(Analyze_Package_Instantiation): If generic unit in child instance is\n+\tthe same as generic unit in parent instance, look for an outer homonym\n+\tto locate the desired generic.\n+\n 2009-04-15  Bob Duff  <duff@adacore.com>\n \n \t* sem_ch5.adb (Analyze_Loop_Statement): Don't check for infinite loop"}, {"sha": "e4afe673cecb79df8aa03c2330a4a18b68460417", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -1132,17 +1132,20 @@ package body Exp_Ch9 is\n       --    for Lnn in Family_Low .. Family_High loop\n       --       Inn := Inn + 1;\n       --       Set_Entry_Name\n-      --         (_init._object, Inn, new String (\"<Entry name> \" & Lnn'Img));\n-      --          _init._task_id\n+      --         (_init._object <or> _init._task_id,\n+      --          Inn,\n+      --          new String (\"<Entry name>(\" & Lnn'Img & \")\"));\n       --    end loop;\n       --  Note that the bounds of the range may reference discriminants. The\n       --  above construct is added directly to the statements of the block.\n \n       procedure Build_Entry_Name (Id : Entity_Id);\n       --  Generate:\n       --    Inn := Inn + 1;\n-      --    Set_Entry_Name (_init._task_id, Inn, new String (\"<Entry name>\");\n-      --                    _init._object\n+      --    Set_Entry_Name\n+      --      (_init._object <or>_init._task_id,\n+      --       Inn,\n+      --       new String (\"<Entry name>\");\n       --  The above construct is added directly to the statements of the block.\n \n       function Build_Set_Entry_Name_Call (Arg3 : Node_Id) return Node_Id;\n@@ -1213,13 +1216,13 @@ package body Exp_Ch9 is\n       begin\n          Get_Name_String (Chars (Id));\n \n-         if Is_Enumeration_Type (Etype (Def)) then\n-            Name_Len := Name_Len + 1;\n-            Name_Buffer (Name_Len) := ' ';\n-         end if;\n+         --  Add a leading '('\n+\n+         Name_Len := Name_Len + 1;\n+         Name_Buffer (Name_Len) := '(';\n \n          --  Generate:\n-         --    new String'(\"<Entry name>\" & Lnn'Img);\n+         --    new String'(\"<Entry name>(\" & Lnn'Img & \")\");\n \n          --  This is an implicit heap allocation, and Comes_From_Source is\n          --  False, which ensures that it will get flagged as a violation of\n@@ -1233,21 +1236,27 @@ package body Exp_Ch9 is\n                Expression =>\n                  Make_Op_Concat (Loc,\n                    Left_Opnd =>\n-                     Make_String_Literal (Loc,\n-                       String_From_Name_Buffer),\n+                     Make_Op_Concat (Loc,\n+                       Left_Opnd =>\n+                         Make_String_Literal (Loc,\n+                           Strval => String_From_Name_Buffer),\n+                       Right_Opnd =>\n+                         Make_Attribute_Reference (Loc,\n+                           Prefix =>\n+                             New_Reference_To (L_Id, Loc),\n+                               Attribute_Name => Name_Img)),\n                    Right_Opnd =>\n-                     Make_Attribute_Reference (Loc,\n-                       Prefix =>\n-                         New_Reference_To (L_Id, Loc),\n-                           Attribute_Name => Name_Img))));\n+                     Make_String_Literal (Loc,\n+                       Strval => \")\"))));\n \n          Increment_Index (L_Stmts);\n          Append_To (L_Stmts, Build_Set_Entry_Name_Call (Val));\n \n          --  Generate:\n          --    for Lnn in Family_Low .. Family_High loop\n          --       Inn := Inn + 1;\n-         --       Set_Entry_Name (_init._task_id, Inn, <Val>);\n+         --       Set_Entry_Name\n+         --         (_init._object <or> _init._task_id, Inn, <Val>);\n          --    end loop;\n \n          Append_To (B_Stmts,"}, {"sha": "6f0828790058986c066c427546ac9e90e6b84819", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -2957,6 +2957,23 @@ package body Sem_Ch12 is\n \n       --  Verify that it is the name of a generic package\n \n+      --  A visibility glitch: if the instance is a child unit and the generic\n+      --  is the generic unit of a parent instance (i.e. both the parent and\n+      --  the child units are instances of the same package) the name now\n+      --  denotes the renaming within the parent, not the intended generic\n+      --  unit. See if there is a homonym that is the desired generic. The\n+      --  renaming declaration must be visible inside the instance of the\n+      --  child, but not when analyzing the name in the instantiation itself.\n+\n+      if Ekind (Gen_Unit) = E_Package\n+        and then Present (Renamed_Entity (Gen_Unit))\n+        and then In_Open_Scopes (Renamed_Entity (Gen_Unit))\n+        and then Is_Generic_Instance (Renamed_Entity (Gen_Unit))\n+        and then Present (Homonym (Gen_Unit))\n+      then\n+         Gen_Unit := Homonym (Gen_Unit);\n+      end if;\n+\n       if Etype (Gen_Unit) = Any_Type then\n          Restore_Env;\n          return;\n@@ -6145,6 +6162,7 @@ package body Sem_Ch12 is\n       function Is_Actual_Of_Previous_Formal (P : Entity_Id) return Boolean;\n       --  The package in question may be an actual for a previous formal\n       --  package P of the current instance, so examine its actuals as well.\n+      --  This must be recursive over other formal packages.\n \n       ----------------------------------\n       -- Is_Actual_Of_Previous_Formal --\n@@ -6154,16 +6172,22 @@ package body Sem_Ch12 is\n          E1 : Entity_Id;\n \n       begin\n-         E1 := First_Entity (E);\n+         E1 := First_Entity (P);\n+\n          while Present (E1) and then  E1 /= Instance loop\n             if Ekind (E1) = E_Package\n               and then Nkind (Parent (E1)) = N_Package_Renaming_Declaration\n             then\n                if Renamed_Object (E1) = Pack then\n                   return True;\n \n-               elsif Renamed_Object (E1) = P then\n+               elsif E1 = P\n+                 or else  Renamed_Object (E1) = P\n+               then\n                   return False;\n+\n+               elsif Is_Actual_Of_Previous_Formal (E1) then\n+                  return True;\n                end if;\n             end if;\n "}, {"sha": "9642ea7b0bf5843ab197c4b37e3b007216b653e0", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -7224,19 +7224,28 @@ package body Sem_Util is\n          when N_Assignment_Statement =>\n             return N = Name (P);\n \n-         --  Test prefix of component or attribute\n+         --  Test prefix of component or attribute. Note that the prefix of an\n+         --  explicit or implicit dereference cannot be an l-value.\n \n          when N_Attribute_Reference =>\n             return N = Prefix (P)\n               and then Name_Implies_Lvalue_Prefix (Attribute_Name (P));\n \n          when N_Expanded_Name        |\n-              N_Explicit_Dereference |\n               N_Indexed_Component    |\n-              N_Reference            |\n               N_Selected_Component   |\n               N_Slice                =>\n-            return N = Prefix (P);\n+            if Is_Access_Type (Etype (N)) then\n+               return False;  --  P is an implicit dereference\n+            else\n+               return N = Prefix (P);\n+            end if;\n+\n+         when N_Reference            =>\n+               return N = Prefix (P);\n+\n+         when N_Explicit_Dereference =>\n+            return False;\n \n          --  Function call arguments are never lvalues\n "}, {"sha": "b8ff44a72a12e7226ca7fb388a0d34aa4874d571", "filename": "gcc/ada/sem_warn.adb", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_warn.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsem_warn.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_warn.adb?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -236,12 +236,15 @@ package body Sem_Warn is\n       Iter : constant Node_Id := Iteration_Scheme (Loop_Statement);\n \n       Ref : Node_Id := Empty;\n-      --  Reference in iteration scheme to variable that may not be modified in\n-      --  loop, indicating a possible infinite loop.\n+      --  Reference in iteration scheme to variable that might not be modified\n+      --  in loop, indicating a possible infinite loop.\n \n       Var : Entity_Id := Empty;\n       --  Corresponding entity (entity of Ref)\n \n+      Function_Call_Found : Boolean := False;\n+      --  True if Find_Var found a function call in the condition\n+\n       procedure Find_Var (N : Node_Id);\n       --  Inspect condition to see if it depends on a single entity reference.\n       --  If so, Ref is set to point to the reference node, and Var is set to\n@@ -305,6 +308,8 @@ package body Sem_Warn is\n \n          elsif Nkind (N) = N_Function_Call then\n \n+            Function_Call_Found := True;\n+\n             --  Forget it if function name is not entity, who knows what\n             --  we might be calling?\n \n@@ -570,8 +575,11 @@ package body Sem_Warn is\n \n       --  Nothing to do if there is some indirection involved (assume that the\n       --  designated variable might be modified in some way we don't see).\n+      --  However, if no function call was found, then we don't care about\n+      --  indirections, because the condition must be something like \"while X\n+      --  /= null loop\", so we don't care if X.all is modified in the loop.\n \n-      elsif Has_Indirection (Etype (Var)) then\n+      elsif Function_Call_Found and then Has_Indirection (Etype (Var)) then\n          return;\n \n       --  Same sort of thing for volatile variable, might be modified by"}, {"sha": "7bf1be29e7c342d16be60c773faf66f66525d7ba", "filename": "gcc/ada/sinput-p.adb", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsinput-p.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsinput-p.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.adb?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -23,9 +23,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Unchecked_Conversion;\n+with Ada.Unchecked_Deallocation;\n+\n with Prj.Err;\n with Sinput.C;\n \n+with System;\n+\n package body Sinput.P is\n \n    First : Boolean := True;\n@@ -34,6 +39,56 @@ package body Sinput.P is\n    --  The flag is reset to False at the first call to Load_Project_File.\n    --  Calling Reset_First sets it back to True.\n \n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Lines_Table_Type, Lines_Table_Ptr);\n+\n+   procedure Free is new Ada.Unchecked_Deallocation\n+     (Logical_Lines_Table_Type, Logical_Lines_Table_Ptr);\n+\n+   -----------------------------\n+   -- Clear_Source_File_Table --\n+   -----------------------------\n+\n+   procedure Clear_Source_File_Table is\n+      use System;\n+   begin\n+      for X in 1 .. Source_File.Last loop\n+         declare\n+            S : Source_File_Record renames Source_File.Table (X);\n+            Lo : constant Source_Ptr := S.Source_First;\n+            Hi : constant Source_Ptr := S.Source_Last;\n+            subtype Actual_Source_Buffer is Source_Buffer (Lo .. Hi);\n+            --  Physical buffer allocated\n+\n+            type Actual_Source_Ptr is access Actual_Source_Buffer;\n+            --  This is the pointer type for the physical buffer allocated\n+\n+            procedure Free is new Ada.Unchecked_Deallocation\n+              (Actual_Source_Buffer, Actual_Source_Ptr);\n+\n+            pragma Suppress (All_Checks);\n+\n+            pragma Warnings (Off);\n+            --  The following unchecked conversion is aliased safe, since it\n+            --  is not used to create improperly aliased pointer values.\n+\n+            function To_Actual_Source_Ptr is new\n+              Ada.Unchecked_Conversion (Address, Actual_Source_Ptr);\n+\n+            Actual_Ptr : Actual_Source_Ptr :=\n+                           To_Actual_Source_Ptr (S.Source_Text (Lo)'Address);\n+\n+         begin\n+            Free (Actual_Ptr);\n+            Free (S.Lines_Table);\n+            Free (S.Logical_Lines_Table);\n+         end;\n+      end loop;\n+\n+      Source_File.Free;\n+      Source_File.Init;\n+   end Clear_Source_File_Table;\n+\n    -----------------------\n    -- Load_Project_File --\n    -----------------------"}, {"sha": "8f925bbc9a0e6c98d8c0afb55eaa8bc250044eb8", "filename": "gcc/ada/sinput-p.ads", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsinput-p.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8a912a6e1046ad6137c0792522787d66ed24bb0d/gcc%2Fada%2Fsinput-p.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinput-p.ads?ref=8a912a6e1046ad6137c0792522787d66ed24bb0d", "patch": "@@ -31,6 +31,13 @@ with Scans; use Scans;\n \n package Sinput.P is\n \n+   procedure Clear_Source_File_Table;\n+   --  This procedure frees memory allocated in the Source_File table (in the\n+   --  private part of package Sinput). It should only be used when it is\n+   --  guaranteed that all source files that have been loaded so far will not\n+   --  be accessed before being reloaded. It is intended for tools that parse\n+   --  several times sources, to avoid memory leaks.\n+\n    function Load_Project_File (Path : String) return Source_File_Index;\n    --  Load the source of a project source file into memory and initialize the\n    --  Scans state."}]}