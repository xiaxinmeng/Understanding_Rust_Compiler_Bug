{"sha": "f54ee9801da8ab98c156f16770984b8eaebf1b42", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjU0ZWU5ODAxZGE4YWI5OGMxNTZmMTY3NzA5ODRiOGVhZWJmMWI0Mg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2012-06-11T09:14:20Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2012-06-11T09:14:20Z"}, "message": "decl.c (gnat_to_gnu_entity): Convert GNU_SIZE to units before invoking allocatable_size_p on it.\n\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Convert GNU_SIZE\n\tto units before invoking allocatable_size_p on it.\n\tRemove orphaned comment.  Do not use ssize_int.\n\t<E_Record_Subtype>: Traverse list in original order.  Minor tweak.\n\t(allocatable_size_p): Adjust and simplify.\n\t(build_subst_list): Use consistent terminology throughout.\n\t(build_variant_list): Likewise.  Traverse list in original order.\n\t(create_field_decl_from): Likewise.\n\t(copy_and_substitute_in_size): Likewise.\n\t(create_variant_part_from): Add comment about field list order.\n\t* gcc-interface/utils.c (build_vms_descriptor): Do not use ssize_int.\n\t* gcc-interface/utils2.c (build_allocator): Likewise.\n\nFrom-SVN: r188382", "tree": {"sha": "bb4fc549e5f2f30af7295a85daa051b8ad650188", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb4fc549e5f2f30af7295a85daa051b8ad650188"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f54ee9801da8ab98c156f16770984b8eaebf1b42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54ee9801da8ab98c156f16770984b8eaebf1b42", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f54ee9801da8ab98c156f16770984b8eaebf1b42", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f54ee9801da8ab98c156f16770984b8eaebf1b42/comments", "author": null, "committer": null, "parents": [{"sha": "e4270465dd9aecb856b05a67ed5653b9e0f57c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4270465dd9aecb856b05a67ed5653b9e0f57c27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4270465dd9aecb856b05a67ed5653b9e0f57c27"}], "stats": {"total": 186, "additions": 121, "deletions": 65}, "files": [{"sha": "0b6ab7bf92c66f61c09aebba8acf6801887e3719", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -1,3 +1,18 @@\n+2012-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <object>: Convert GNU_SIZE\n+\tto units before invoking allocatable_size_p on it.\n+\tRemove orphaned comment.  Do not use ssize_int.\n+\t<E_Record_Subtype>: Traverse list in original order.  Minor tweak.\n+\t(allocatable_size_p): Adjust and simplify.\n+\t(build_subst_list): Use consistent terminology throughout.\n+\t(build_variant_list): Likewise.  Traverse list in original order.\n+\t(create_field_decl_from): Likewise.\n+\t(copy_and_substitute_in_size): Likewise.\n+\t(create_variant_part_from): Add comment about field list order.\n+\t* gcc-interface/utils.c (build_vms_descriptor): Do not use ssize_int.\n+\t* gcc-interface/utils2.c (build_allocator): Likewise.\n+\n 2012-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/trans.c (Identifier_to_gnu): Test Is_Elementary_Type"}, {"sha": "b27707c55935844e60644e24c0e0427763adf8ab", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 54, "deletions": 62, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -1283,10 +1283,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t global_bindings_p ()\n \t\t\t\t || !definition\n \t\t\t\t || static_p)\n-\t    || (gnu_size && !allocatable_size_p (gnu_size,\n-\t\t\t\t\t\t global_bindings_p ()\n-\t\t\t\t\t\t || !definition\n-\t\t\t\t\t\t || static_p)))\n+\t    || (gnu_size\n+\t\t&& !allocatable_size_p (convert (sizetype,\n+\t\t\t\t\t\t size_binop\n+\t\t\t\t\t\t (CEIL_DIV_EXPR, gnu_size,\n+\t\t\t\t\t\t  bitsize_unit_node)),\n+\t\t\t\t\tglobal_bindings_p ()\n+\t\t\t\t\t|| !definition\n+\t\t\t\t\t|| static_p)))\n \t  {\n \t    gnu_type = build_reference_type (gnu_type);\n \t    gnu_size = NULL_TREE;\n@@ -2204,8 +2208,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t    debug_info_p);\n \tTYPE_READONLY (gnu_template_type) = 1;\n \n-\t/* Now build the array type.  */\n-\n \t/* If Component_Size is not already specified, annotate it with the\n \t   size of the component.  */\n \tif (Unknown_Component_Size (gnat_entity))\n@@ -2810,12 +2812,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttree gnu_lower_bound\n \t  = convert (gnu_string_index_type,\n \t\t     gnat_to_gnu (String_Literal_Low_Bound (gnat_entity)));\n-\tint length = UI_To_Int (String_Literal_Length (gnat_entity));\n-\ttree gnu_length = ssize_int (length - 1);\n+\ttree gnu_length\n+\t  = UI_To_gnu (String_Literal_Length (gnat_entity),\n+\t\t       gnu_string_index_type);\n \ttree gnu_upper_bound\n \t  = build_binary_op (PLUS_EXPR, gnu_string_index_type,\n \t\t\t     gnu_lower_bound,\n-\t\t\t     convert (gnu_string_index_type, gnu_length));\n+\t\t\t     int_const_binop (MINUS_EXPR, gnu_length,\n+\t\t\t\t\t      integer_one_node));\n \ttree gnu_index_type\n \t  = create_index_type (convert (sizetype, gnu_lower_bound),\n \t\t\t       convert (sizetype, gnu_upper_bound),\n@@ -3298,7 +3302,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      if (gnu_variant_part)\n \t\t{\n \t\t  variant_desc *v;\n-\t\t  unsigned ix;\n+\t\t  unsigned int i;\n \n \t\t  gnu_variant_list\n \t\t    = build_variant_list (TREE_TYPE (gnu_variant_part),\n@@ -3307,8 +3311,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  /* If all the qualifiers are unconditionally true, the\n \t\t     innermost variant is statically selected.  */\n \t\t  selected_variant = true;\n-\t\t  FOR_EACH_VEC_ELT_REVERSE (variant_desc, gnu_variant_list,\n-\t\t\t\t\t    ix, v)\n+\t\t  FOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n \t\t    if (!integer_onep (v->qual))\n \t\t      {\n \t\t\tselected_variant = false;\n@@ -3317,8 +3320,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t\t  /* Otherwise, create the new variants.  */\n \t\t  if (!selected_variant)\n-\t\t    FOR_EACH_VEC_ELT_REVERSE (variant_desc, gnu_variant_list,\n-\t\t\t\t\t      ix, v)\n+\t\t    FOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n \t\t      {\n \t\t\ttree old_variant = v->type;\n \t\t\ttree new_variant = make_node (RECORD_TYPE);\n@@ -3420,11 +3422,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    else\n \t\t      {\n \t\t\tvariant_desc *v;\n-\t\t\tunsigned ix;\n+\t\t\tunsigned int i;\n \n \t\t\tt = NULL_TREE;\n-\t\t\tFOR_EACH_VEC_ELT_REVERSE (variant_desc,\n-\t\t\t\t\t\t  gnu_variant_list, ix, v)\n+\t\t\tFOR_EACH_VEC_ELT (variant_desc, gnu_variant_list, i, v)\n \t\t\t  if (v->type == gnu_context)\n \t\t\t    {\n \t\t\t      t = v->type;\n@@ -3510,8 +3511,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Do not emit debug info for the type yet since we're going to\n \t\t modify it below.  */\n-\t      gnu_field_list = nreverse (gnu_field_list);\n-\t      finish_record_type (gnu_type, gnu_field_list, 2, false);\n+\t      finish_record_type (gnu_type, nreverse (gnu_field_list), 2,\n+\t\t\t\t  false);\n \n \t      /* See the E_Record_Type case for the rationale.  */\n \t      if (Is_By_Reference_Type (gnat_entity))\n@@ -5933,30 +5934,21 @@ elaborate_entity (Entity_Id gnat_entity)\n     }\n }\n \f\n-/* Return true if the size represented by GNU_SIZE can be handled by an\n-   allocation.  If STATIC_P is true, consider only what can be done with a\n+/* Return true if the size in units represented by GNU_SIZE can be handled by\n+   an allocation.  If STATIC_P is true, consider only what can be done with a\n    static allocation.  */\n \n static bool\n allocatable_size_p (tree gnu_size, bool static_p)\n {\n-  HOST_WIDE_INT our_size;\n-\n-  /* If this is not a static allocation, the only case we want to forbid\n-     is an overflowing size.  That will be converted into a raise a\n-     Storage_Error.  */\n-  if (!static_p)\n-    return !(TREE_CODE (gnu_size) == INTEGER_CST\n-\t     && TREE_OVERFLOW (gnu_size));\n-\n-  /* Otherwise, we need to deal with both variable sizes and constant\n-     sizes that won't fit in a host int.  We use int instead of HOST_WIDE_INT\n-     since assemblers may not like very large sizes.  */\n-  if (!host_integerp (gnu_size, 1))\n-    return false;\n+  /* We can allocate a fixed size if it hasn't overflowed and can be handled\n+     (efficiently) on the host.  */\n+  if (TREE_CODE (gnu_size) == INTEGER_CST)\n+    return !TREE_OVERFLOW (gnu_size) && host_integerp (gnu_size, 1);\n \n-  our_size = tree_low_cst (gnu_size, 1);\n-  return (int) our_size == our_size;\n+  /* We can allocate a variable size if this isn't a static allocation.  */\n+  else\n+    return !static_p;\n }\n \f\n /* Prepend to ATTR_LIST an entry for an attribute with provided TYPE,\n@@ -7502,16 +7494,16 @@ build_position_list (tree gnu_type, bool do_not_flatten_variant, tree gnu_pos,\n   return gnu_list;\n }\n \n-/* Return a VEC describing the substitutions needed to reflect the\n+/* Return a list describing the substitutions needed to reflect the\n    discriminant substitutions from GNAT_TYPE to GNAT_SUBTYPE.  They can\n-   be in any order.  The values in an element of the VEC are in the form\n+   be in any order.  The values in an element of the list are in the form\n    of operands to SUBSTITUTE_IN_EXPR.  DEFINITION is true if this is for\n    a definition of GNAT_SUBTYPE.  */\n \n static VEC(subst_pair,heap) *\n build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n {\n-  VEC(subst_pair,heap) *gnu_vec = NULL;\n+  VEC(subst_pair,heap) *gnu_list = NULL;\n   Entity_Id gnat_discrim;\n   Node_Id gnat_value;\n \n@@ -7529,23 +7521,22 @@ build_subst_list (Entity_Id gnat_subtype, Entity_Id gnat_type, bool definition)\n \t\t\t\t    (Node (gnat_value), gnat_subtype,\n \t\t\t\t     get_entity_name (gnat_discrim),\n \t\t\t\t     definition, true, false));\n-\tsubst_pair *s = VEC_safe_push (subst_pair, heap, gnu_vec, NULL);\n+\tsubst_pair *s = VEC_safe_push (subst_pair, heap, gnu_list, NULL);\n \ts->discriminant = gnu_field;\n \ts->replacement = replacement;\n       }\n \n-  return gnu_vec;\n+  return gnu_list;\n }\n \n-/* Scan all fields in QUAL_UNION_TYPE and return a VEC describing the\n+/* Scan all fields in QUAL_UNION_TYPE and return a list describing the\n    variants of QUAL_UNION_TYPE that are still relevant after applying\n-   the substitutions described in SUBST_LIST.  VARIANT_LIST is a\n-   pre-existing VEC onto which newly created entries should be\n-   pushed.  */\n+   the substitutions described in SUBST_LIST.  GNU_LIST is a pre-existing\n+   list to be prepended to the newly created entries.  */\n \n static VEC(variant_desc,heap) *\n build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n-\t\t    VEC(variant_desc,heap) *variant_list)\n+\t\t    VEC(variant_desc,heap) *gnu_list)\n {\n   tree gnu_field;\n \n@@ -7554,10 +7545,10 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n        gnu_field = DECL_CHAIN (gnu_field))\n     {\n       tree qual = DECL_QUALIFIER (gnu_field);\n-      unsigned ix;\n+      unsigned int i;\n       subst_pair *s;\n \n-      FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+      FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n \tqual = SUBSTITUTE_IN_EXPR (qual, s->discriminant, s->replacement);\n \n       /* If the new qualifier is not unconditionally false, its variant may\n@@ -7567,7 +7558,7 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t  variant_desc *v;\n \t  tree variant_type = TREE_TYPE (gnu_field), variant_subpart;\n \n-\t  v = VEC_safe_push (variant_desc, heap, variant_list, NULL);\n+\t  v = VEC_safe_push (variant_desc, heap, gnu_list, NULL);\n \t  v->type = variant_type;\n \t  v->field = gnu_field;\n \t  v->qual = qual;\n@@ -7576,8 +7567,8 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t  /* Recurse on the variant subpart of the variant, if any.  */\n \t  variant_subpart = get_variant_part (variant_type);\n \t  if (variant_subpart)\n-\t    variant_list = build_variant_list (TREE_TYPE (variant_subpart),\n-\t\t\t\t\t       subst_list, variant_list);\n+\t    gnu_list = build_variant_list (TREE_TYPE (variant_subpart),\n+\t\t\t\t\t   subst_list, gnu_list);\n \n \t  /* If the new qualifier is unconditionally true, the subsequent\n \t     variants cannot be accessed.  */\n@@ -7586,7 +7577,7 @@ build_variant_list (tree qual_union_type, VEC(subst_pair,heap) *subst_list,\n \t}\n     }\n \n-  return variant_list;\n+  return gnu_list;\n }\n \f\n /* UINT_SIZE is a Uint giving the specified size for an object of GNU_TYPE\n@@ -8135,11 +8126,11 @@ create_field_decl_from (tree old_field, tree field_type, tree record_type,\n   tree pos = TREE_VEC_ELT (t, 0), bitpos = TREE_VEC_ELT (t, 2);\n   unsigned int offset_align = tree_low_cst (TREE_VEC_ELT (t, 1), 1);\n   tree new_pos, new_field;\n-  unsigned ix;\n+  unsigned int i;\n   subst_pair *s;\n \n   if (CONTAINS_PLACEHOLDER_P (pos))\n-    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n       pos = SUBSTITUTE_IN_EXPR (pos, s->discriminant, s->replacement);\n \n   /* If the position is now a constant, we can set it as the position of the\n@@ -8243,7 +8234,7 @@ create_variant_part_from (tree old_variant_part,\n   tree new_union_type, new_variant_part;\n   tree union_field_list = NULL_TREE;\n   variant_desc *v;\n-  unsigned ix;\n+  unsigned int i;\n \n   /* First create the type of the variant part from that of the old one.  */\n   new_union_type = make_node (QUAL_UNION_TYPE);\n@@ -8273,7 +8264,7 @@ create_variant_part_from (tree old_variant_part,\n     copy_and_substitute_in_size (new_union_type, old_union_type, subst_list);\n \n   /* Now finish up the new variants and populate the union type.  */\n-  FOR_EACH_VEC_ELT_REVERSE (variant_desc, variant_list, ix, v)\n+  FOR_EACH_VEC_ELT_REVERSE (variant_desc, variant_list, i, v)\n     {\n       tree old_field = v->field, new_field;\n       tree old_variant, old_variant_subpart, new_variant, field_list;\n@@ -8317,7 +8308,8 @@ create_variant_part_from (tree old_variant_part,\n     }\n \n   /* Finish up the union type and create the variant part.  No need for debug\n-     info thanks to the XVS type.  */\n+     info thanks to the XVS type.  Note that we don't reverse the field list\n+     because VARIANT_LIST has been traversed in reverse order.  */\n   finish_record_type (new_union_type, union_field_list, 2, false);\n   compute_record_mode (new_union_type);\n   create_type_decl (TYPE_NAME (new_union_type), new_union_type, NULL,\n@@ -8356,7 +8348,7 @@ static void\n copy_and_substitute_in_size (tree new_type, tree old_type,\n \t\t\t     VEC(subst_pair,heap) *subst_list)\n {\n-  unsigned ix;\n+  unsigned int i;\n   subst_pair *s;\n \n   TYPE_SIZE (new_type) = TYPE_SIZE (old_type);\n@@ -8366,19 +8358,19 @@ copy_and_substitute_in_size (tree new_type, tree old_type,\n   relate_alias_sets (new_type, old_type, ALIAS_SET_COPY);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE (new_type)))\n-    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n       TYPE_SIZE (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE (new_type),\n \t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_SIZE_UNIT (new_type)))\n-    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n       TYPE_SIZE_UNIT (new_type)\n \t= SUBSTITUTE_IN_EXPR (TYPE_SIZE_UNIT (new_type),\n \t\t\t      s->discriminant, s->replacement);\n \n   if (CONTAINS_PLACEHOLDER_P (TYPE_ADA_SIZE (new_type)))\n-    FOR_EACH_VEC_ELT_REVERSE (subst_pair, subst_list, ix, s)\n+    FOR_EACH_VEC_ELT (subst_pair, subst_list, i, s)\n       SET_TYPE_ADA_SIZE\n \t(new_type, SUBSTITUTE_IN_EXPR (TYPE_ADA_SIZE (new_type),\n \t\t\t\t       s->discriminant, s->replacement));"}, {"sha": "62a4b319dfbe7ced2aafcb59e3bfb83f82ad4c03", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -3601,7 +3601,7 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \t\t\t     record_type, size_int (klass), field_list);\n   field_list\n     = make_descriptor_field (\"MBMO\", gnat_type_for_size (32, 1),\n-\t\t\t     record_type, ssize_int (-1), field_list);\n+\t\t\t     record_type, size_int (-1), field_list);\n   field_list\n     = make_descriptor_field (\"LENGTH\", gnat_type_for_size (64, 1),\n \t\t\t     record_type,"}, {"sha": "c7dfe98fce26e540772c061db1608d41d50562e4", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -2287,7 +2287,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n       /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n       if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-\tsize = ssize_int (-1);\n+\tsize = size_int (-1);\n \n       storage = build_call_alloc_dealloc (NULL_TREE, size, storage_type,\n \t\t\t\t\t  gnat_proc, gnat_pool, gnat_node);\n@@ -2345,7 +2345,7 @@ build_allocator (tree type, tree init, tree result_type, Entity_Id gnat_proc,\n \n   /* If the size overflows, pass -1 so Storage_Error will be raised.  */\n   if (TREE_CODE (size) == INTEGER_CST && TREE_OVERFLOW (size))\n-    size = ssize_int (-1);\n+    size = size_int (-1);\n \n   storage = convert (result_type,\n \t\t     build_call_alloc_dealloc (NULL_TREE, size, type,"}, {"sha": "bab237880702831bf1cbe37ef958103fbae87246", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -1,3 +1,9 @@\n+2012-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/specs/array1.ads: New test.\n+\t* gnat.dg/specs/array2.ads: Likewise.\n+\t* gnat.dg/array22.adb: Likewise.\n+\n 2012-06-11  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gnat.dg/constant4.adb: New test."}, {"sha": "c1725934a2454a82aa15b5e2df57cc33f2ce6b55", "filename": "gcc/testsuite/gnat.dg/array22.adb", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Farray22.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Farray22.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Farray22.adb?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -0,0 +1,21 @@\n+-- { dg-do compile }\n+\n+with System; use System;\n+\n+procedure Array22 is\n+\n+   type Integer_Address is mod Memory_Size;\n+\n+   type Memory is array (Integer_Address range <>) of Character;\n+\n+   type Chunk (First, Last : Integer_Address) is record\n+      Mem : Memory (First .. Last);\n+   end record;\n+\n+   C : Chunk (1, 8);\n+   for C'Alignment use 8;\n+   pragma Unreferenced (C);\n+\n+begin\n+   null;\n+end;"}, {"sha": "1964f742ec0b693686d8c261932a520b1fc5569a", "filename": "gcc/testsuite/gnat.dg/specs/array1.ads", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray1.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray1.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray1.ads?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -0,0 +1,10 @@\n+-- { dg-do compile }\n+\n+pragma Restrictions (No_Elaboration_Code);\n+\n+package Array1 is\n+\n+  type Arr is array (Positive range <>) of Boolean;\n+  A : Arr (1 .. 2 ** 29);\n+\n+end Array1;"}, {"sha": "73d4ea5b9bc38494e01a62a90004bf95c00e89da", "filename": "gcc/testsuite/gnat.dg/specs/array2.ads", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f54ee9801da8ab98c156f16770984b8eaebf1b42/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fspecs%2Farray2.ads?ref=f54ee9801da8ab98c156f16770984b8eaebf1b42", "patch": "@@ -0,0 +1,12 @@\n+-- { dg-do compile }\n+-- { dg-options \"-gnatws\" }\n+\n+pragma Restrictions (No_Elaboration_Code);\n+\n+package Array2 is\n+\n+  type Arr is array (Positive range <>) of Boolean;\n+  A : Arr (1 .. 2 ** 2);\n+  for A'Size use 16#1000_0000_0#;\n+\n+end Array2;"}]}