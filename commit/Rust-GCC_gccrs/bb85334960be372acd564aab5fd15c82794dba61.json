{"sha": "bb85334960be372acd564aab5fd15c82794dba61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI4NTMzNDk2MGJlMzcyYWNkNTY0YWFiNWZkMTVjODI3OTRkYmE2MQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-10-16T23:47:08Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-10-16T23:47:08Z"}, "message": "re PR middle-end/44206 (ICE: Inline clone with address taken)\n\n\tPR middle-end/44206\n\t* g++.dg/torture/pr44206.C: New.\n\t* ipa.c (cgraph_remove_unreachable_nodes): Cleanup; check\n\texistence of refrences before removing the function.\n\nFrom-SVN: r165569", "tree": {"sha": "ffa391cf9b24280a9b420916c1900577ff6fd326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffa391cf9b24280a9b420916c1900577ff6fd326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb85334960be372acd564aab5fd15c82794dba61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb85334960be372acd564aab5fd15c82794dba61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb85334960be372acd564aab5fd15c82794dba61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb85334960be372acd564aab5fd15c82794dba61/comments", "author": null, "committer": null, "parents": [{"sha": "ad6209273872a99d8dd1ec21d55c408a6bb9e572", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad6209273872a99d8dd1ec21d55c408a6bb9e572", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad6209273872a99d8dd1ec21d55c408a6bb9e572"}], "stats": {"total": 185, "additions": 144, "deletions": 41}, "files": [{"sha": "e65867d080938caaaf1e3990764f3100bd9b9839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb85334960be372acd564aab5fd15c82794dba61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb85334960be372acd564aab5fd15c82794dba61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb85334960be372acd564aab5fd15c82794dba61", "patch": "@@ -1,3 +1,9 @@\n+2010-10-16  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/44206\n+\t* ipa.c (cgraph_remove_unreachable_nodes): Cleanup; check\n+\texistence of refrences before removing the function.\n+\n 2010-10-16  Jan Hubicka  <jh@suse.cz>\n \n \t* cgraph.c (dump_cgraph_node): Dump same_comdat_group,"}, {"sha": "af71330765f07e8cb04648ef4434d7d0b7dc980b", "filename": "gcc/ipa.c", "status": "modified", "additions": 112, "deletions": 41, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=bb85334960be372acd564aab5fd15c82794dba61", "patch": "@@ -384,22 +384,31 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t}\n       if (!node->aux)\n \t{\n+\t  struct cgraph_edge *e;\n+\t  bool found = false;\n+\t  int i;\n+\t  struct ipa_ref *ref;\n+\n           node->global.inlined_to = NULL;\n \t  if (file)\n \t    fprintf (file, \" %s\", cgraph_node_name (node));\n-\t  if (!node->analyzed || !DECL_EXTERNAL (node->decl) || before_inlining_p)\n-\t    cgraph_remove_node (node);\n-\t  else\n+\t  /* See if there is reachable caller.  */\n+\t  for (e = node->callers; e && !found; e = e->next_caller)\n+\t    if (e->caller->reachable)\n+\t      found = true;\n+\t  for (i = 0; (ipa_ref_list_refering_iterate (&node->ref_list, i, ref)\n+\t\t       && !found); i++)\n+\t    if (ref->refering_type == IPA_REF_CGRAPH\n+\t\t&& ipa_ref_refering_node (ref)->reachable)\n+\t      found = true;\n+\t    else if (ref->refering_type == IPA_REF_VARPOOL\n+\t\t     && ipa_ref_refering_varpool_node (ref)->needed)\n+\t      found = true;\n+\n+\t  /* If so, we need to keep node in the callgraph.  */\n+\t  if (found || node->needed)\n \t    {\n-\t      struct cgraph_edge *e;\n-\n-\t      /* See if there is reachable caller.  */\n-\t      for (e = node->callers; e; e = e->next_caller)\n-\t\tif (e->caller->reachable)\n-\t\t  break;\n-\n-\t      /* If so, we need to keep node in the callgraph.  */\n-\t      if (e || node->needed)\n+\t      if (node->analyzed)\n \t\t{\n \t\t  struct cgraph_node *clone;\n \n@@ -419,24 +428,27 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t\tnode->clone_of->clones = node->next_sibling_clone;\n \t\t      if (node->next_sibling_clone)\n \t\t\tnode->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n-#ifdef ENABLE_CHECKING\n+    #ifdef ENABLE_CHECKING\n \t\t      if (node->clone_of)\n \t\t\tnode->former_clone_of = node->clone_of->decl;\n-#endif\n+    #endif\n \t\t      node->clone_of = NULL;\n \t\t      node->next_sibling_clone = NULL;\n \t\t      node->prev_sibling_clone = NULL;\n \t\t    }\n \t\t  else\n \t\t    gcc_assert (!clone->in_other_partition);\n \t\t  node->analyzed = false;\n+\t\t  changed = true;\n \t\t  cgraph_node_remove_callees (node);\n \t\t  ipa_remove_all_references (&node->ref_list);\n \t\t}\n-\t      else\n-\t\tcgraph_remove_node (node);\n \t    }\n-\t  changed = true;\n+\t  else\n+\t    {\n+\t      cgraph_remove_node (node);\n+\t      changed = true;\n+\t    }\n \t}\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -581,6 +593,7 @@ ipa_discover_readonly_nonaddressable_vars (void)\n static bool\n cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool aliased)\n {\n+  struct cgraph_node *alias;\n   if (!node->local.finalized)\n     return false;\n   if (!DECL_COMDAT (node->decl)\n@@ -595,6 +608,23 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n   /* If linker counts on us, we must preserve the function.  */\n   if (cgraph_used_from_object_file_p (node))\n     return true;\n+  if (DECL_PRESERVE_P (node->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+    return true;\n+\n+  /* See if we have linker information about symbol not being used or\n+     if we need to make guess based on the declaration.\n+\n+     Even if the linker clams the symbol is unused, never bring internal\n+     symbols that are declared by user as used or externally visible.\n+     This is needed for i.e. references from asm statements.   */\n+  for (alias = node->same_body; alias; alias = alias->next)\n+    if (alias->resolution != LDPR_PREVAILING_DEF_IRONLY)\n+      break;\n+  if (!alias && node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    return false;\n+\n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n       && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n@@ -626,11 +656,70 @@ cgraph_externally_visible_p (struct cgraph_node *node, bool whole_program, bool\n \t      return true;\n \t}\n     }\n-  if (DECL_PRESERVE_P (node->decl))\n-    return true;\n+\n   if (MAIN_NAME_P (DECL_NAME (node->decl)))\n     return true;\n-  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+\n+  return false;\n+}\n+\n+/* Return true when variable VNODE should be considered externally visible.  */\n+\n+static bool\n+varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n+{\n+  struct varpool_node *alias;\n+  if (!DECL_COMDAT (vnode->decl) && !TREE_PUBLIC (vnode->decl))\n+    return false;\n+\n+  /* Do not even try to be smart about aliased nodes.  Until we properly\n+     represent everything by same body alias, these are just evil.  */\n+  if (aliased)\n+    return true;\n+\n+  /* If linker counts on us, we must preserve the function.  */\n+  if (varpool_used_from_object_file_p (vnode))\n+    return true;\n+\n+  if (DECL_PRESERVE_P (vnode->decl))\n+    return true;\n+  if (lookup_attribute (\"externally_visible\",\n+\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n+    return true;\n+\n+  /* See if we have linker information about symbol not being used or\n+     if we need to make guess based on the declaration.\n+\n+     Even if the linker clams the symbol is unused, never bring internal\n+     symbols that are declared by user as used or externally visible.\n+     This is needed for i.e. references from asm statements.   */\n+  if (varpool_used_from_object_file_p (vnode))\n+    return true;\n+  for (alias = vnode->extra_name; alias; alias = alias->next)\n+    if (alias->resolution != LDPR_PREVAILING_DEF_IRONLY)\n+      break;\n+  if (!alias && vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+    return false;\n+\n+  /* When doing link time optimizations, hidden symbols become local.  */\n+  if (in_lto_p\n+      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n+      /* Be sure that node is defined in IR file, not in other object\n+\t file.  In that case we don't set used_from_other_object_file.  */\n+      && vnode->finalized)\n+    ;\n+  else if (!flag_whole_program)\n+    return true;\n+\n+  /* Do not attempt to privatize COMDATS by default.\n+     This would break linking with C++ libraries sharing\n+     inline definitions.\n+\n+     FIXME: We can do so for readonly vars with no address taken and\n+     possibly also for vtables since no direct pointer comparsion is done.\n+     It might be interesting to do so to reduce linking overhead.  */\n+  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n     return true;\n   return false;\n }\n@@ -786,27 +875,9 @@ function_and_variable_visibility (bool whole_program)\n       if (!vnode->finalized)\n         continue;\n       if (vnode->needed\n-\t  && (DECL_COMDAT (vnode->decl) || TREE_PUBLIC (vnode->decl))\n-\t  && (((!whole_program\n-\t        /* We can privatize comdat readonly variables whose address is\n-\t\t   not taken, but doing so is not going to bring us\n-\t\t   optimization oppurtunities until we start reordering\n-\t\t   datastructures.  */\n-\t\t|| DECL_COMDAT (vnode->decl)\n-\t\t|| DECL_WEAK (vnode->decl))\n-\t       /* When doing linktime optimizations, all hidden symbols will\n-\t\t  become local.  */\n-\t       && (!in_lto_p\n-\t\t   || (DECL_VISIBILITY (vnode->decl) != VISIBILITY_HIDDEN\n-\t\t       && DECL_VISIBILITY (vnode->decl) != VISIBILITY_INTERNAL)\n-\t\t   /* We can get prevailing decision in other object file.\n-\t\t      In this case we do not sed used_from_object_file.  */\n-\t\t   || !vnode->finalized))\n-\t      || DECL_PRESERVE_P (vnode->decl)\n-              || varpool_used_from_object_file_p (vnode)\n-\t      || pointer_set_contains (aliased_vnodes, vnode)\n-\t      || lookup_attribute (\"externally_visible\",\n-\t\t\t\t   DECL_ATTRIBUTES (vnode->decl))))\n+\t  && varpool_externally_visible_p\n+\t      (vnode, \n+\t       pointer_set_contains (aliased_vnodes, vnode)))\n \tvnode->externally_visible = true;\n       else\n         vnode->externally_visible = false;"}, {"sha": "c6460fd3513be7c010c53b22d775b9dcb0aba952", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bb85334960be372acd564aab5fd15c82794dba61", "patch": "@@ -1,3 +1,8 @@\n+2010-10-16  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR middle-end/44206\n+\t* g++.dg/torture/pr44206.C: New.\n+\n 2010-10-16  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc.dg/gnu-api-2-class.m: New."}, {"sha": "a1dedb450ad3c6cfca32407d2bf4b2cd07df6ac3", "filename": "gcc/testsuite/g++.dg/torture/pr44206.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44206.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb85334960be372acd564aab5fd15c82794dba61/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44206.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr44206.C?ref=bb85334960be372acd564aab5fd15c82794dba61", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+template<int> struct A\n+{\n+  void foo(void(*)(A));\n+  void bar(void(*f)(A)) { foo(f); foo(f); }\n+};\n+\n+template<int N> inline void FOO(A<N> a)\n+{\n+  a.foo(0);\n+}\n+\n+extern template void FOO(A<0>);\n+\n+void BAR()\n+{\n+  A<0> a;\n+  FOO(a);\n+  a.bar(FOO);\n+}"}]}