{"sha": "504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA0ZWQ2M2ExYTRmM2YzNWE1ZmM3NzRmNTQ3ZTQ4NDlmNTNkYzJiNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2009-07-25T19:39:07Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2009-07-25T19:39:07Z"}, "message": "re PR fortran/33197 (Fortran 2008: math functions)\n\n2009-07-25  Tobias Burnus  <burnus@net-b.de>\n            Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n\n        PR fortran/33197\n        * intrinsic.c (add_functions): Support complex arguments for\n        acos,acosh,asin,asinh,atan,atanh.\n        * invoke.texi (ACOS,ACOSH,ASIN,ASINH,ATAN,ATANH): Support\n        complex arguments.\n        * simplify.c (gfc_simplify_acos,gfc_simplify_acosh,\n        gfc_simplify_asin,gfc_simplify_asinh,gfc_simplify_atan,\n        gfc_simplify_atanh,gfc_simplify_atan,gfc_simplify_asinh,\n        gfc_simplify_acosh,gfc_simplify_atanh): Support\n        complex arguments.\n\n2009-07-25  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/33197\n        * intrinsics/c99_functions.c (cacosf,cacos,cacosl,casinf,\n        casin,casind,catanf,catan,catanl,cacoshf,cacosh,cacoshl,\n        casinhf,casinh,casinhf,catanhf,catanh,catanhl): New functions.\n        * c99_protos.h: Add prototypes for those.\n\n2009-07-25  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/33197\n        * gfortran.dg/complex_intrinsic_5.f90: New test.\n        * gfortran.dg/complex_intrinsic_7.f90: New test.\n\n\nCo-Authored-By: Francois-Xavier Coudert <fxcoudert@gcc.gnu.org>\n\nFrom-SVN: r150087", "tree": {"sha": "5341f696cb6bb6fec17a250253324c998d5734db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5341f696cb6bb6fec17a250253324c998d5734db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "86631ea3dd78a0077a6f96061affe89d5e38220f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86631ea3dd78a0077a6f96061affe89d5e38220f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86631ea3dd78a0077a6f96061affe89d5e38220f"}], "stats": {"total": 886, "additions": 814, "deletions": 72}, "files": [{"sha": "363889f7195cc661afc91c177b43aaba2c60536d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -1,3 +1,17 @@\n+2009-07-25  Tobias Burnus  <burnus@net-b.de>\n+\t    Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/33197\n+\t* intrinsic.c (add_functions): Support complex arguments for\n+\tacos,acosh,asin,asinh,atan,atanh.\n+\t* invoke.texi (ACOS,ACOSH,ASIN,ASINH,ATAN,ATANH): Support\n+\tcomplex arguments.\n+\t* simplify.c (gfc_simplify_acos,gfc_simplify_acosh,\n+\tgfc_simplify_asin,gfc_simplify_asinh,gfc_simplify_atan,\n+\tgfc_simplify_atanh,gfc_simplify_atan,gfc_simplify_asinh,\n+\tgfc_simplify_acosh,gfc_simplify_atanh): Support\n+\tcomplex arguments.\n+\n 2009-07-25  Richard Guenther  <rguenther@suse.de>\n \n \tPR fortran/40005"}, {"sha": "0b2d1b8c8dbe12e87ff27530de24bf504773c447", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -1134,7 +1134,7 @@ add_functions (void)\n   make_generic (\"achar\", GFC_ISYM_ACHAR, GFC_STD_F95);\n \n   add_sym_1 (\"acos\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, GFC_STD_F77,\n-\t     gfc_check_fn_r, gfc_simplify_acos, gfc_resolve_acos,\n+\t     gfc_check_fn_rc2008, gfc_simplify_acos, gfc_resolve_acos,\n \t     x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"dacos\", GFC_ISYM_ACOS, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_F77,\n@@ -1144,7 +1144,7 @@ add_functions (void)\n   make_generic (\"acos\", GFC_ISYM_ACOS, GFC_STD_F77);\n \n   add_sym_1 (\"acosh\", GFC_ISYM_ACOSH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,\n-\t     GFC_STD_F2008, gfc_check_fn_r, gfc_simplify_acosh,\n+\t     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_acosh,\n \t     gfc_resolve_acosh, x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"dacosh\", GFC_ISYM_ACOSH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU,\n@@ -1217,7 +1217,7 @@ add_functions (void)\n   make_generic (\"any\", GFC_ISYM_ANY, GFC_STD_F95);\n \n   add_sym_1 (\"asin\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, GFC_STD_F77,\n-\t     gfc_check_fn_r, gfc_simplify_asin, gfc_resolve_asin,\n+\t     gfc_check_fn_rc2008, gfc_simplify_asin, gfc_resolve_asin,\n \t     x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"dasin\", GFC_ISYM_ASIN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_F77,\n@@ -1227,7 +1227,7 @@ add_functions (void)\n   make_generic (\"asin\", GFC_ISYM_ASIN, GFC_STD_F77);\n   \n   add_sym_1 (\"asinh\", GFC_ISYM_ASINH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,\n-\t     GFC_STD_F2008, gfc_check_fn_r, gfc_simplify_asinh,\n+\t     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_asinh,\n \t     gfc_resolve_asinh, x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"dasinh\", GFC_ISYM_ASINH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU,\n@@ -1243,7 +1243,7 @@ add_functions (void)\n   make_generic (\"associated\", GFC_ISYM_ASSOCIATED, GFC_STD_F95);\n \n   add_sym_1 (\"atan\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr, GFC_STD_F77,\n-\t     gfc_check_fn_r, gfc_simplify_atan, gfc_resolve_atan,\n+\t     gfc_check_fn_rc2008, gfc_simplify_atan, gfc_resolve_atan,\n \t     x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"datan\", GFC_ISYM_ATAN, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_F77,\n@@ -1253,7 +1253,7 @@ add_functions (void)\n   make_generic (\"atan\", GFC_ISYM_ATAN, GFC_STD_F77);\n   \n   add_sym_1 (\"atanh\", GFC_ISYM_ATANH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dr,\n-\t     GFC_STD_F2008, gfc_check_fn_r, gfc_simplify_atanh,\n+\t     GFC_STD_F2008, gfc_check_fn_rc2008, gfc_simplify_atanh,\n \t     gfc_resolve_atanh, x, BT_REAL, dr, REQUIRED);\n \n   add_sym_1 (\"datanh\", GFC_ISYM_ATANH, CLASS_ELEMENTAL, ACTUAL_YES, BT_REAL, dd, GFC_STD_GNU,"}, {"sha": "2e6908f705bdc3fbbba7d012956cfcb00f71874d", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -531,7 +531,7 @@ and formatted string representations.\n @code{ACOS(X)} computes the arccosine of @var{X} (inverse of @code{COS(X)}).\n \n @item @emph{Standard}:\n-Fortran 77 and later\n+Fortran 77 and later, for a complex argument Fortran 2008 or later\n \n @item @emph{Class}:\n Elemental function\n@@ -541,14 +541,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL} with a magnitude that is\n-less than or equal to one.\n+@item @var{X} @tab The type shall either be @code{REAL} with a magnitude that is\n+less than or equal to one - or the type shall be @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL} and it lies in the\n-range @math{ 0 \\leq \\acos(x) \\leq \\pi}. The return value if of the same\n-kind as @var{X}.\n+The return value is of the same type and kind as @var{X}.\n+The real part of the result is in radians and lies in the range\n+@math{0 \\leq \\Re \\acos(x) \\leq \\pi}.\n \n @item @emph{Example}:\n @smallexample\n@@ -600,7 +600,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value has the same type and kind as @var{X}\n+The return value has the same type and kind as @var{X}. If @var{X} is\n+complex, the imaginary part of the result is in radians and lies between\n+@math{ 0 \\leq \\Im \\acosh(x) \\leq \\pi}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1170,7 +1172,7 @@ end program test_any\n @code{ASIN(X)} computes the arcsine of its @var{X} (inverse of @code{SIN(X)}).\n \n @item @emph{Standard}:\n-Fortran 77 and later\n+Fortran 77 and later, for a complex argument Fortran 2008 or later\n \n @item @emph{Class}:\n Elemental function\n@@ -1180,14 +1182,14 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL}, and a magnitude that is\n-less than or equal to one.\n+@item @var{X} @tab The type shall be either @code{REAL} and a magnitude that is\n+less than or equal to one - or be @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL} and it lies in the\n-range @math{-\\pi / 2 \\leq \\asin (x) \\leq \\pi / 2}.  The kind type\n-parameter is the same as @var{X}.\n+The return value is of the same type and kind as @var{X}.\n+The real part of the result is in radians and lies in the range\n+@math{-\\pi/2 \\leq \\Re \\asin(x) \\leq \\pi/2}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1238,7 +1240,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of the same type and kind as  @var{X}.\n+The return value is of the same type and kind as  @var{X}. If @var{X} is\n+complex, the imaginary part of the result is in radians and lies between\n+@math{-\\pi/2 \\leq \\Im \\asinh(x) \\leq \\pi/2}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1349,7 +1353,7 @@ end program test_associated\n @code{ATAN(X)} computes the arctangent of @var{X}.\n \n @item @emph{Standard}:\n-Fortran 77 and later\n+Fortran 77 and later, for a complex argument Fortran 2008 or later\n \n @item @emph{Class}:\n Elemental function\n@@ -1359,12 +1363,13 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{X} @tab The type shall be @code{REAL}.\n+@item @var{X} @tab The type shall be @code{REAL} or @code{COMPLEX}.\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL} and it lies in the\n-range @math{ - \\pi / 2 \\leq \\atan (x) \\leq \\pi / 2}.\n+The return value is of the same type and kind as @var{X}.\n+The real part of the result is in radians and lies in the range\n+@math{-\\pi/2 \\leq \\Re \\atan(x) \\leq \\pi/2}.\n \n @item @emph{Example}:\n @smallexample\n@@ -1470,7 +1475,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value has same type and kind as @var{X}.\n+The return value has same type and kind as @var{X}. If @var{X} is\n+complex, the imaginary part of the result is in radians and lies between\n+@math{-\\pi/2 \\leq \\Im \\atanh(x) \\leq \\pi/2}.\n \n @item @emph{Example}:\n @smallexample\n@@ -2635,9 +2642,9 @@ Elemental function\n @end multitable\n \n @item @emph{Return value}:\n-The return value is of type @code{REAL} and it lies in the\n-range @math{ -1 \\leq \\cos (x) \\leq 1}.  The kind type\n-parameter is the same as @var{X}.\n+The return value is of the same type and kind as @var{X}. The real part\n+of the result is in radians. If @var{X} is of the type @code{REAL},\n+the return value lies in the range @math{ -1 \\leq \\cos (x) \\leq 1}.\n \n @item @emph{Example}:\n @smallexample"}, {"sha": "fa8a32a2431602b844afeec288ba7815bb089b45", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 138, "deletions": 44, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -735,12 +735,21 @@ gfc_simplify_acos (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) > 0\n-      || mpfr_cmp_si (x->value.real, -1) < 0)\n+  switch (x->ts.type)\n     {\n-      gfc_error (\"Argument of ACOS at %L must be between -1 and 1\",\n-\t\t &x->where);\n-      return &gfc_bad_expr;\n+      case BT_REAL:\n+\tif (mpfr_cmp_si (x->value.real, 1) > 0\n+\t    || mpfr_cmp_si (x->value.real, -1) < 0)\n+\t  {\n+\t    gfc_error (\"Argument of ACOS at %L must be between -1 and 1\",\n+\t\t       &x->where);\n+\t    return &gfc_bad_expr;\n+\t  }\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n     }\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n@@ -758,16 +767,24 @@ gfc_simplify_acosh (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) < 0)\n+  switch (x->ts.type)\n     {\n-      gfc_error (\"Argument of ACOSH at %L must not be less than 1\",\n-\t\t &x->where);\n-      return &gfc_bad_expr;\n-    }\n-\n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+      case BT_REAL:\n+\tif (mpfr_cmp_si (x->value.real, 1) < 0)\n+\t  {\n+\t    gfc_error (\"Argument of ACOSH at %L must not be less than 1\",\n+\t\t       &x->where);\n+\t    return &gfc_bad_expr;\n+\t  }\n \n-  mpfr_acosh (result->value.real, x->value.real, GFC_RND_MODE);\n+\tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\tmpfr_acosh (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n+    }\n \n   return range_check (result, \"ACOSH\");\n }\n@@ -1012,18 +1029,25 @@ gfc_simplify_asin (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) > 0\n-      || mpfr_cmp_si (x->value.real, -1) < 0)\n+  switch (x->ts.type)\n     {\n-      gfc_error (\"Argument of ASIN at %L must be between -1 and 1\",\n-\t\t &x->where);\n-      return &gfc_bad_expr;\n+      case BT_REAL:\n+\tif (mpfr_cmp_si (x->value.real, 1) > 0\n+\t    || mpfr_cmp_si (x->value.real, -1) < 0)\n+\t  {\n+\t    gfc_error (\"Argument of ASIN at %L must be between -1 and 1\",\n+\t\t       &x->where);\n+\t    return &gfc_bad_expr;\n+\t  }\n+\tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\tmpfr_asin (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n     }\n \n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-\n-  mpfr_asin (result->value.real, x->value.real, GFC_RND_MODE);\n-\n   return range_check (result, \"ASIN\");\n }\n \n@@ -1036,9 +1060,17 @@ gfc_simplify_asinh (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-\n-  mpfr_asinh (result->value.real, x->value.real, GFC_RND_MODE);\n+  switch (x->ts.type)\n+    {\n+      case BT_REAL:\n+\tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\tmpfr_asinh (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n+    }\n \n   return range_check (result, \"ASINH\");\n }\n@@ -1052,9 +1084,17 @@ gfc_simplify_atan (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n     \n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n-\n-  mpfr_atan (result->value.real, x->value.real, GFC_RND_MODE);\n+  switch (x->ts.type)\n+    {\n+      case BT_REAL:\n+\tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\tmpfr_atan (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n+    }\n \n   return range_check (result, \"ATAN\");\n }\n@@ -1068,17 +1108,25 @@ gfc_simplify_atanh (gfc_expr *x)\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (mpfr_cmp_si (x->value.real, 1) >= 0\n-      || mpfr_cmp_si (x->value.real, -1) <= 0)\n+  switch (x->ts.type)\n     {\n-      gfc_error (\"Argument of ATANH at %L must be inside the range -1 to 1\",\n-\t\t &x->where);\n-      return &gfc_bad_expr;\n-    }\n-\n-  result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+      case BT_REAL:\n+\tif (mpfr_cmp_si (x->value.real, 1) >= 0\n+\t    || mpfr_cmp_si (x->value.real, -1) <= 0)\n+\t  {\n+\t    gfc_error (\"Argument of ATANH at %L must be inside the range -1 \"\n+\t\t       \"to 1\", &x->where);\n+\t    return &gfc_bad_expr;\n+\t  }\n \n-  mpfr_atanh (result->value.real, x->value.real, GFC_RND_MODE);\n+\tresult = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n+\tmpfr_atanh (result->value.real, x->value.real, GFC_RND_MODE);\n+\tbreak;\n+      case BT_COMPLEX:\n+\treturn NULL;\n+      default:\n+\tgfc_internal_error (\"in gfc_simplify_cos(): Bad type\");\n+    }\n \n   return range_check (result, \"ATANH\");\n }\n@@ -1501,7 +1549,19 @@ gfc_simplify_cosh (gfc_expr *x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_cosh (result->value.real, x->value.real, GFC_RND_MODE);\n+  if (x->ts.type == BT_REAL)\n+    mpfr_cosh (result->value.real, x->value.real, GFC_RND_MODE);\n+  else if (x->ts.type == BT_COMPLEX)\n+    {\n+#if HAVE_mpc\n+      mpc_cosh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+#else\n+      gfc_free_expr (result);\n+      return NULL;\n+#endif\n+    }\n+  else\n+    gcc_unreachable ();\n \n   return range_check (result, \"COSH\");\n }\n@@ -5033,7 +5093,20 @@ gfc_simplify_sinh (gfc_expr *x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_sinh (result->value.real, x->value.real, GFC_RND_MODE);\n+  if (x->ts.type == BT_REAL)\n+    mpfr_sinh (result->value.real, x->value.real, GFC_RND_MODE);\n+  else if (x->ts.type == BT_COMPLEX)\n+    {\n+#if HAVE_mpc\n+      mpc_sinh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+#else\n+      gfc_free_expr (result);\n+      return NULL;\n+#endif\n+    }\n+  else\n+    gcc_unreachable ();\n+\n \n   return range_check (result, \"SINH\");\n }\n@@ -5344,17 +5417,26 @@ gfc_simplify_sum (gfc_expr *array, gfc_expr *dim, gfc_expr *mask)\n gfc_expr *\n gfc_simplify_tan (gfc_expr *x)\n {\n-  int i;\n   gfc_expr *result;\n \n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  i = gfc_validate_kind (BT_REAL, x->ts.kind, false);\n-\n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_tan (result->value.real, x->value.real, GFC_RND_MODE);\n+  if (x->ts.type == BT_REAL)\n+    mpfr_tan (result->value.real, x->value.real, GFC_RND_MODE);\n+  else if (x->ts.type == BT_COMPLEX)\n+    {\n+#if HAVE_mpc\n+      mpc_tan (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+#else\n+      gfc_free_expr (result);\n+      return NULL;\n+#endif\n+    }\n+  else\n+    gcc_unreachable ();\n \n   return range_check (result, \"TAN\");\n }\n@@ -5370,7 +5452,19 @@ gfc_simplify_tanh (gfc_expr *x)\n \n   result = gfc_constant_result (x->ts.type, x->ts.kind, &x->where);\n \n-  mpfr_tanh (result->value.real, x->value.real, GFC_RND_MODE);\n+  if (x->ts.type == BT_REAL)\n+    mpfr_tanh (result->value.real, x->value.real, GFC_RND_MODE);\n+  else if (x->ts.type == BT_COMPLEX)\n+    {\n+#if HAVE_mpc\n+      mpc_tanh (result->value.complex, x->value.complex, GFC_MPC_RND_MODE);\n+#else\n+      gfc_free_expr (result);\n+      return NULL;\n+#endif\n+    }\n+  else\n+    gcc_unreachable ();\n \n   return range_check (result, \"TANH\");\n "}, {"sha": "c0136282661bd4c0d9902c25d20cfe485372d044", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -1,3 +1,9 @@\n+2009-07-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33197\n+\t* gfortran.dg/complex_intrinsic_5.f90: New test.\n+\t* gfortran.dg/complex_intrinsic_7.f90: New test.\n+\n 2009-07-25  Martin Jambor  <mjambor@suse.cz>\n \n \t* gcc.c-torture/execute/pr17377.c: Add noclone attribute to function y."}, {"sha": "15706b9b3976e732b9c222d893c1fbaafa96b2a5", "filename": "gcc/testsuite/gfortran.dg/complex_intrinsic_5.f90", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_5.f90?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -0,0 +1,221 @@\n+! { dg-do run }\n+!\n+! PR fortran/33197\n+!\n+! Complex inverse trigonometric functions\n+! and complex inverse hyperbolic functions\n+!\n+! Run-time evaluation check\n+!\n+module test\n+  implicit none\n+  real(4), parameter :: eps4 = epsilon(0.0_4)*2.0_4\n+  real(8), parameter :: eps8 = epsilon(0.0_8)*2.0_8\n+  interface check\n+    procedure check4, check8\n+  end interface check\n+contains\n+  SUBROUTINE check4(z, zref)\n+    complex(4), intent(in) :: z, zref\n+    if (    abs (real(z)-real(zref)) > eps4 &\n+        .or.abs (aimag(z)-aimag(zref)) > eps4) then\n+      print '(a,/,2((2g0,\" + I \",g0),/))', \"check4:\",\"   z=\",z,'zref=',zref\n+      print '(a,g0,\" + I*\",g0,\"  eps=\",g0)', 'Diff: ', &\n+                                 real(z)-real(zref), &\n+                                 aimag(z)-aimag(zref), eps4\n+      call abort()\n+    end if\n+  END SUBROUTINE check4\n+  SUBROUTINE check8(z, zref)\n+    complex(8), intent(in) :: z, zref\n+    if (    abs (real(z)-real(zref)) > eps8 &\n+        .or.abs (aimag(z)-aimag(zref)) > eps8) then\n+      print '(a,/,2((2g0,\" + I \",g0),/))', \"check8:\",\"   z=\",z,'zref=',zref\n+      print '(a,g0,\" + I*\",g0,\"  eps=\",g0)', 'Diff: ', &\n+                                 real(z)-real(zref), &\n+                                 aimag(z)-aimag(zref), eps8\n+      call abort()\n+    end if\n+  END SUBROUTINE check8\n+end module test\n+\n+PROGRAM ArcTrigHyp\n+  use test\n+  IMPLICIT NONE\n+  complex(4), volatile :: z4\n+  complex(8), volatile :: z8\n+\n+!!!!! ZERO !!!!!!\n+\n+  ! z = 0\n+  z4 = cmplx(0.0_4, 0.0_4, kind=4)\n+  z8 = cmplx(0.0_8, 0.0_8, kind=8)\n+\n+  ! Exact: 0\n+  call check(asin(z4), cmplx(0.0_4, 0.0_4, kind=4))\n+  call check(asin(z8), cmplx(0.0_8, 0.0_8, kind=8))\n+  ! Exact: Pi/2 = 1.5707963267948966192313216916397514\n+  call check(acos(z4), cmplx(1.57079632679489661920_4, 0.0_4, kind=4))\n+  call check(acos(z8), cmplx(1.57079632679489661920_8, 0.0_8, kind=8))\n+  ! Exact: 0\n+  call check(atan(z4), cmplx(0.0_4, 0.0_4, kind=4))\n+  call check(atan(z8), cmplx(0.0_8, 0.0_8, kind=8))\n+  ! Exact: 0\n+  call check(asinh(z4), cmplx(0.0_4, 0.0_4, kind=4))\n+  call check(asinh(z8), cmplx(0.0_8, 0.0_8, kind=8))\n+  ! Exact: I*Pi/2 = I*1.5707963267948966192313216916397514\n+  call check(acosh(z4), cmplx(0.0_4, 1.57079632679489661920_4, kind=4))\n+  call check(acosh(z8), cmplx(0.0_8, 1.57079632679489661920_8, kind=8))\n+  ! Exact: 0\n+  call check(atanh(z4), cmplx(0.0_4, 0.0_4, kind=4))\n+  call check(atanh(z8), cmplx(0.0_8, 0.0_8, kind=8))\n+\n+\n+!!!!! POSITIVE NUMBERS !!!!!!\n+\n+  ! z = tanh(1.0)\n+  z4 = cmplx(0.76159415595576488811945828260479359_4, 0.0_4, kind=4)\n+  z8 = cmplx(0.76159415595576488811945828260479359_8, 0.0_8, kind=8)\n+\n+  ! Numerically: 0.86576948323965862428960184619184444\n+  call check(asin(z4), cmplx(0.86576948323965862428960184619184444_4, 0.0_4, kind=4))\n+  call check(asin(z8), cmplx(0.86576948323965862428960184619184444_8, 0.0_8, kind=8))\n+  ! Numerically: 0.70502684355523799494171984544790700\n+  call check(acos(z4), cmplx(0.70502684355523799494171984544790700_4, 0.0_4, kind=4))\n+  call check(acos(z8), cmplx(0.70502684355523799494171984544790700_8, 0.0_8, kind=8))\n+  ! Numerically: 0.65088016802300754993807813168285564\n+  call check(atan(z4), cmplx(0.65088016802300754993807813168285564_4, 0.0_4, kind=4))\n+  call check(atan(z8), cmplx(0.65088016802300754993807813168285564_8, 0.0_8, kind=8))\n+  ! Numerically: 0.70239670712987482778422106260749699\n+  call check(asinh(z4), cmplx(0.70239670712987482778422106260749699_4, 0.0_4, kind=4))\n+  call check(asinh(z8), cmplx(0.70239670712987482778422106260749699_8, 0.0_8, kind=8))\n+  ! Numerically: 0.70502684355523799494171984544790700*I\n+  call check(acosh(z4), cmplx(0.0_4, 0.70502684355523799494171984544790700_4, kind=4))\n+  call check(acosh(z8), cmplx(0.0_8, 0.70502684355523799494171984544790700_8, kind=8))\n+  ! Exact: 1\n+  call check(atanh(z4), cmplx(1.0_4, 0.0_4, kind=4))\n+  call check(atanh(z8), cmplx(1.0_8, 0.0_8, kind=8))\n+\n+\n+  ! z = I*tanh(1.0)\n+  z4 = cmplx(0.0_4, 0.76159415595576488811945828260479359_4, kind=4)\n+  z8 = cmplx(0.0_8, 0.76159415595576488811945828260479359_8, kind=8)\n+\n+  ! Numerically: I*0.70239670712987482778422106260749699\n+  call check(asin(z4), cmplx(0.0_4, 0.70239670712987482778422106260749699_4, kind=4))\n+  call check(asin(z8), cmplx(0.0_8, 0.70239670712987482778422106260749699_8, kind=8))\n+  ! Numerically: 1.5707963267948966192313216916397514 - I*0.7023967071298748277842210626074970\n+  call check(acos(z4), cmplx(1.5707963267948966192313216916397514_4, -0.7023967071298748277842210626074970_4, kind=4))\n+  call check(acos(z8), cmplx(1.5707963267948966192313216916397514_8, -0.7023967071298748277842210626074970_8, kind=8))\n+  ! Exact: I*1\n+  call check(atan(z4), cmplx(0.0_4, 1.0_4, kind=4))\n+  call check(atan(z8), cmplx(0.0_8, 1.0_8, kind=8))\n+  ! Numerically: I*0.86576948323965862428960184619184444\n+  call check(asinh(z4), cmplx(0.0_4, 0.86576948323965862428960184619184444_4, kind=4))\n+  call check(asinh(z8), cmplx(0.0_8, 0.86576948323965862428960184619184444_8, kind=8))\n+  ! Numerically: 0.7023967071298748277842210626074970 + I*1.5707963267948966192313216916397514\n+  call check(acosh(z4), cmplx(0.7023967071298748277842210626074970_4, 1.5707963267948966192313216916397514_4, kind=4))\n+  call check(acosh(z8), cmplx(0.7023967071298748277842210626074970_8, 1.5707963267948966192313216916397514_8, kind=8))\n+  ! Numerically: I*0.65088016802300754993807813168285564\n+  call check(atanh(z4), cmplx(0.0_4, 0.65088016802300754993807813168285564_4, kind=4))\n+  call check(atanh(z8), cmplx(0.0_8, 0.65088016802300754993807813168285564_8, kind=8))\n+\n+\n+  ! z = (1+I)*tanh(1.0)\n+  z4 = cmplx(0.76159415595576488811945828260479359_4, 0.76159415595576488811945828260479359_4, kind=4)\n+  z8 = cmplx(0.76159415595576488811945828260479359_8, 0.76159415595576488811945828260479359_8, kind=8)\n+\n+  ! Numerically: 0.59507386031622633330574869409179139 + I*0.82342412550090412964986631390412834\n+  call check(asin(z4), cmplx(0.59507386031622633330574869409179139_4, 0.82342412550090412964986631390412834_4, kind=4))\n+  call check(asin(z8), cmplx(0.59507386031622633330574869409179139_8, 0.82342412550090412964986631390412834_8, kind=8))\n+  ! Numerically: 0.97572246647867028592557299754796005 - I*0.82342412550090412964986631390412834\n+  call check(acos(z4), cmplx(0.97572246647867028592557299754796005_4, -0.82342412550090412964986631390412834_4, kind=4))\n+  call check(acos(z8), cmplx(0.97572246647867028592557299754796005_8, -0.82342412550090412964986631390412834_8, kind=8))\n+  ! Numerically: 0.83774433133636226305479129936568267 + I*0.43874835208710654149508159123595167\n+  call check(atan(z4), cmplx(0.83774433133636226305479129936568267_4, 0.43874835208710654149508159123595167_4, kind=4))\n+  call check(atan(z8), cmplx(0.83774433133636226305479129936568267_8, 0.43874835208710654149508159123595167_8, kind=8))\n+  ! Numerically: 0.82342412550090412964986631390412834 + I*0.59507386031622633330574869409179139\n+  call check(asinh(z4), cmplx(0.82342412550090412964986631390412834_4, 0.59507386031622633330574869409179139_4, kind=4))\n+  call check(asinh(z8), cmplx(0.82342412550090412964986631390412834_8, 0.59507386031622633330574869409179139_8, kind=8))\n+  ! Numerically: 0.82342412550090412964986631390412834 + I*0.97572246647867028592557299754796005\n+  call check(acosh(z4), cmplx(0.82342412550090412964986631390412834_4, 0.97572246647867028592557299754796005_4, kind=4))\n+  call check(acosh(z8), cmplx(0.82342412550090412964986631390412834_8, 0.97572246647867028592557299754796005_8, kind=8))\n+  ! Numerically: 0.43874835208710654149508159123595167 + I*0.83774433133636226305479129936568267\n+  call check(atanh(z4), cmplx(0.43874835208710654149508159123595167_4, 0.83774433133636226305479129936568267_4, kind=4))\n+  call check(atanh(z8), cmplx(0.43874835208710654149508159123595167_8, 0.83774433133636226305479129936568267_8, kind=8))\n+\n+\n+  ! z = 1+I\n+  z4 = cmplx(1.0_4, 1.0_4, kind=4)\n+  z8 = cmplx(1.0_8, 1.0_8, kind=8)\n+\n+  ! Numerically: 0.66623943249251525510400489597779272 + I*1.06127506190503565203301891621357349\n+  call check(asin(z4), cmplx(0.66623943249251525510400489597779272_4, 1.06127506190503565203301891621357349_4, kind=4))\n+  call check(asin(z8), cmplx(0.66623943249251525510400489597779272_8, 1.06127506190503565203301891621357349_8, kind=8))\n+  ! Numerically: 0.90455689430238136412731679566195872 - I*1.06127506190503565203301891621357349\n+  call check(acos(z4), cmplx(0.90455689430238136412731679566195872_4, -1.06127506190503565203301891621357349_4, kind=4))\n+  call check(acos(z8), cmplx(0.90455689430238136412731679566195872_8, -1.06127506190503565203301891621357349_8, kind=8))\n+  ! Numerically: 1.01722196789785136772278896155048292 + I*0.40235947810852509365018983330654691\n+  call check(atan(z4), cmplx(1.01722196789785136772278896155048292_4, 0.40235947810852509365018983330654691_4, kind=4))\n+  call check(atan(z8), cmplx(1.01722196789785136772278896155048292_8, 0.40235947810852509365018983330654691_8, kind=8))\n+  ! Numerically: 1.06127506190503565203301891621357349 + I*0.66623943249251525510400489597779272\n+  call check(asinh(z4), cmplx(1.06127506190503565203301891621357349_4, 0.66623943249251525510400489597779272_4, kind=4))\n+  call check(asinh(z8), cmplx(1.06127506190503565203301891621357349_8, 0.66623943249251525510400489597779272_8, kind=8))\n+  ! Numerically: 1.06127506190503565203301891621357349 + I*0.90455689430238136412731679566195872\n+  call check(acosh(z4), cmplx(1.06127506190503565203301891621357349_4, 0.90455689430238136412731679566195872_4, kind=4))\n+  call check(acosh(z8), cmplx(1.06127506190503565203301891621357349_8, 0.90455689430238136412731679566195872_8, kind=8))\n+  ! Numerically: 0.40235947810852509365018983330654691 + I*1.01722196789785136772278896155048292\n+  call check(atanh(z4), cmplx(0.40235947810852509365018983330654691_4, 1.01722196789785136772278896155048292_4, kind=4))\n+  call check(atanh(z8), cmplx(0.40235947810852509365018983330654691_8, 1.01722196789785136772278896155048292_8, kind=8))\n+\n+\n+  ! z = (1+I)*1.1\n+  z4 = cmplx(1.1_4, 1.1_4, kind=4)\n+  z8 = cmplx(1.1_8, 1.1_8, kind=8)\n+\n+  ! Numerically: 0.68549840630267734494444454677951503 + I*1.15012680127435581678415521738176733\n+  call check(asin(z4), cmplx(0.68549840630267734494444454677951503_4, 1.15012680127435581678415521738176733_4, kind=4))\n+  call check(asin(z8), cmplx(0.68549840630267734494444454677951503_8, 1.15012680127435581678415521738176733_8, kind=8))\n+  ! Numerically: 0.8852979204922192742868771448602364 - I*1.1501268012743558167841552173817673\n+  call check(acos(z4), cmplx(0.8852979204922192742868771448602364_4, -1.1501268012743558167841552173817673_4, kind=4))\n+  call check(acos(z8), cmplx(0.8852979204922192742868771448602364_8, -1.1501268012743558167841552173817673_8, kind=8))\n+  ! Numerically: 1.07198475450905931839240655913126728 + I*0.38187020129010862908881230531688930\n+  call check(atan(z4), cmplx(1.07198475450905931839240655913126728_4, 0.38187020129010862908881230531688930_4, kind=4))\n+  call check(atan(z8), cmplx(1.07198475450905931839240655913126728_8, 0.38187020129010862908881230531688930_8, kind=8))\n+  ! Numerically: 1.15012680127435581678415521738176733 + I*0.68549840630267734494444454677951503\n+  call check(asinh(z4), cmplx(1.15012680127435581678415521738176733_4, 0.68549840630267734494444454677951503_4, kind=4))\n+  call check(asinh(z8), cmplx(1.15012680127435581678415521738176733_8, 0.68549840630267734494444454677951503_8, kind=8))\n+  ! Numerically: 1.1501268012743558167841552173817673 + I*0.8852979204922192742868771448602364\n+  call check(acosh(z4), cmplx(1.1501268012743558167841552173817673_4, 0.8852979204922192742868771448602364_4, kind=4))\n+  call check(acosh(z8), cmplx(1.1501268012743558167841552173817673_8, 0.8852979204922192742868771448602364_8, kind=8))\n+  ! Numerically: 0.38187020129010862908881230531688930 + I*1.07198475450905931839240655913126728\n+  call check(atanh(z4), cmplx(0.38187020129010862908881230531688930_4, 1.07198475450905931839240655913126728_4, kind=4))\n+  call check(atanh(z8), cmplx(0.38187020129010862908881230531688930_8, 1.07198475450905931839240655913126728_8, kind=8))\n+\n+\n+!!!!! Negative NUMBERS !!!!!!\n+  ! z = -(1+I)*1.1\n+  z4 = cmplx(-1.1_4, -1.1_4, kind=4)\n+  z8 = cmplx(-1.1_8, -1.1_8, kind=8)\n+\n+  ! Numerically: -0.68549840630267734494444454677951503 - I*1.15012680127435581678415521738176733\n+  call check(asin(z4), cmplx(-0.68549840630267734494444454677951503_4, -1.15012680127435581678415521738176733_4, kind=4))\n+  call check(asin(z8), cmplx(-0.68549840630267734494444454677951503_8, -1.15012680127435581678415521738176733_8, kind=8))\n+  ! Numerically: 2.2562947330975739641757662384192665 + I*1.1501268012743558167841552173817673\n+  call check(acos(z4), cmplx(2.2562947330975739641757662384192665_4, 1.1501268012743558167841552173817673_4, kind=4))\n+  call check(acos(z8), cmplx(2.2562947330975739641757662384192665_8, 1.1501268012743558167841552173817673_8, kind=8))\n+  ! Numerically: -1.07198475450905931839240655913126728 - I*0.38187020129010862908881230531688930\n+  call check(atan(z4), cmplx(-1.07198475450905931839240655913126728_4, -0.38187020129010862908881230531688930_4, kind=4))\n+  call check(atan(z8), cmplx(-1.07198475450905931839240655913126728_8, -0.38187020129010862908881230531688930_8, kind=8))\n+  ! Numerically: -1.15012680127435581678415521738176733 - I*0.68549840630267734494444454677951503\n+  call check(asinh(z4), cmplx(-1.15012680127435581678415521738176733_4, -0.68549840630267734494444454677951503_4, kind=4))\n+  call check(asinh(z8), cmplx(-1.15012680127435581678415521738176733_8, -0.68549840630267734494444454677951503_8, kind=8))\n+  ! Numerically: 1.1501268012743558167841552173817673 - I*2.2562947330975739641757662384192665\n+  call check(acosh(z4), cmplx(1.1501268012743558167841552173817673_4, -2.2562947330975739641757662384192665_4, kind=4))\n+  call check(acosh(z8), cmplx(1.1501268012743558167841552173817673_8, -2.2562947330975739641757662384192665_8, kind=8))\n+  ! Numerically: 0.38187020129010862908881230531688930 + I*1.07198475450905931839240655913126728\n+  call check(atanh(z4), cmplx(-0.38187020129010862908881230531688930_4, -1.07198475450905931839240655913126728_4, kind=4))\n+  call check(atanh(z8), cmplx(-0.38187020129010862908881230531688930_8, -1.07198475450905931839240655913126728_8, kind=8))\n+END PROGRAM ArcTrigHyp\n+\n+! { dg-final { cleanup-modules \"test\" } }"}, {"sha": "5cde928baad73a414dc11196f67e09bdc120ef6d", "filename": "gcc/testsuite/gfortran.dg/complex_intrinsic_6.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_6.f90?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR fortran/33197\n+! PR fortran/40728\n+!\n+! Complex inverse trigonometric functions\n+! and complex inverse hyperbolic functions\n+!\n+! Argument type check\n+!\n+\n+PROGRAM ArcTrigHyp\n+  IMPLICIT NONE\n+  real(4), volatile :: r4\n+  real(8), volatile :: r8\n+  complex(4), volatile :: z4\n+  complex(8), volatile :: z8\n+\n+  r4 = 0.0_4\n+  r8 = 0.0_8\n+  z4 = cmplx(0.0_4, 0.0_4, kind=4)\n+  z8 = cmplx(0.0_8, 0.0_8, kind=8)\n+\n+  r4 = asin(r4)\n+  r8 = asin(r8)\n+  r4 = acos(r4)\n+  r8 = acos(r8)\n+  r4 = atan(r4)\n+  r8 = atan(r8)\n+\n+! a(sin,cos,tan)h cannot be checked as they are not part of\n+! Fortran 2003 - not even for real arguments\n+\n+  z4 = asin(z4) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+  z8 = asin(z8) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+  z4 = acos(z4) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+  z8 = acos(z8) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+  z4 = atan(z4) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+  z8 = atan(z8) ! { dg-error \"Fortran 2008: COMPLEX argument\" }\n+END PROGRAM ArcTrigHyp"}, {"sha": "7e6bfbebaff6995be5cf606dd675e0dd9a9f59e8", "filename": "gcc/testsuite/gfortran.dg/complex_intrinsic_7.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcomplex_intrinsic_7.f90?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do compile }\n+! { dg-require-effective-target mpc }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/33197\n+!\n+! Fortran 2008 complex trigonometric functions: tan, cosh, sinh, tanh\n+!\n+! Compile-time simplificiations\n+!\n+implicit none\n+real(4), parameter :: pi  = 2*acos(0.0_4)\n+real(8), parameter :: pi8 = 2*acos(0.0_8)\n+real(4), parameter :: eps  = 10*epsilon(0.0_4)\n+real(8), parameter :: eps8 = 10*epsilon(0.0_8)\n+complex(4), parameter :: z0_0  = cmplx(0.0_4, 0.0_4, kind=4)\n+complex(4), parameter :: z1_1  = cmplx(1.0_4, 1.0_4, kind=4)\n+complex(4), parameter :: zp_p  = cmplx(pi,    pi,    kind=4)\n+complex(8), parameter :: z80_0 = cmplx(0.0_8, 0.0_8, kind=8)\n+complex(8), parameter :: z81_1 = cmplx(1.0_8, 1.0_8, kind=8)\n+complex(8), parameter :: z8p_p = cmplx(pi8,   pi8,   kind=8)\n+\n+if (abs(tan(z0_0)  - cmplx(0.0,0.0,4)) > eps) call abort()\n+if (abs(tan(z1_1)  - cmplx(0.27175257,1.0839232,4)) > eps) call abort()\n+if (abs(tan(z80_0) - cmplx(0.0_8,0.0_8,8)) > eps8) call abort()\n+if (abs(tan(z81_1) - cmplx(0.27175258531951174_8,1.0839233273386946_8,8)) > eps8) call abort()\n+\n+if (abs(cosh(z0_0)  - cmplx(1.0,0.0,4)) > eps) call abort()\n+if (abs(cosh(z1_1)  - cmplx(0.83372992,0.98889768,4)) > eps) call abort()\n+if (abs(cosh(z80_0) - cmplx(1.0_8,0.0_8,8)) > eps8) call abort()\n+if (abs(cosh(z81_1) - cmplx(0.83373002513114913_8,0.98889770576286506_8,8)) > eps8) call abort()\n+\n+if (abs(sinh(z0_0)  - cmplx(0.0,0.0,4)) > eps) call abort()\n+if (abs(sinh(z1_1)  - cmplx(0.63496387,1.2984575,4)) > eps) call abort()\n+if (abs(sinh(z80_0) - cmplx(0.0_8,0.0_8,8)) > eps8) call abort()\n+if (abs(sinh(z81_1) - cmplx(0.63496391478473613_8,1.2984575814159773_8,8)) > eps8) call abort()\n+\n+if (abs(tanh(z0_0)  - cmplx(0.0,0.0,4)) > eps) call abort()\n+if (abs(tanh(z1_1)  - cmplx(1.0839232,0.27175257,4)) > eps) call abort()\n+if (abs(tanh(z80_0) - cmplx(0.0_8,0.0_8,8)) > eps8) call abort()\n+if (abs(tanh(z81_1) - cmplx(1.0839233273386946_8,0.27175258531951174_8,8)) > eps8) call abort()\n+\n+end\n+! { dg-final { scan-tree-dump-times \"abort\" 0 \"original\" } }\n+! { dg-final { cleanup-tree-dump \"original\" } }"}, {"sha": "7ba9023932fd1c97491b845ce9e503a9a1d2c0e3", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -1,3 +1,11 @@\n+2009-07-25  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/33197\n+\t* intrinsics/c99_functions.c (cacosf,cacos,cacosl,casinf,\n+\tcasin,casind,catanf,catan,catanl,cacoshf,cacosh,cacoshl,\n+\tcasinhf,casinh,casinhf,catanhf,catanh,catanhl): New functions.\n+\t* c99_protos.h: Add prototypes for those.\n+\n 2009-07-24  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/40643"}, {"sha": "73a22c3da122bbe668ba68d37059c21111f4000e", "filename": "libgfortran/c99_protos.h", "status": "modified", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2Fc99_protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2Fc99_protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fc99_protos.h?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -498,6 +498,115 @@ extern long double complex ctanl (long double complex);\n #endif\n \n \n+/* Complex ACOS.  */\n+\n+#if !defined(HAVE_CACOSF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CACOSF 1\n+extern complex float cacosf (complex float z);\n+#endif\n+\n+#if !defined(HAVE_CACOS) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CACOS 1\n+extern complex double cacos (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CACOSL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CACOSL 1\n+extern complex long double cacosl (complex long double z);\n+#endif\n+\n+\n+/* Complex ASIN.  */\n+\n+#if !defined(HAVE_CASINF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CASINF 1\n+extern complex float casinf (complex float z);\n+#endif\n+\n+#if !defined(HAVE_CASIN) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CASIN 1\n+extern complex double casin (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CASINL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CASINL 1\n+extern complex long double casinl (complex long double z);\n+#endif\n+\n+\n+/* Complex ATAN.  */\n+\n+#if !defined(HAVE_CATANF) && defined(HAVE_CLOGF)\n+#define HAVE_CATANF 1\n+extern complex float catanf (complex float z);\n+#endif\n+\n+#if !defined(HAVE_CATAN) && defined(HAVE_CLOG)\n+#define HAVE_CATAN 1\n+extern complex double catan (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CATANL) && defined(HAVE_CLOGL)\n+#define HAVE_CATANL 1\n+extern complex long double catanl (complex long double z);\n+#endif\n+\n+\n+/* Complex ASINH.  */\n+\n+#if !defined(HAVE_CASINHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CASINHF 1\n+extern complex float casinhf (complex float z);\n+#endif\n+\n+\n+#if !defined(HAVE_CASINH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CASINH 1\n+extern complex double casinh (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CASINHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CASINHL 1\n+extern complex long double casinhl (complex long double z);\n+#endif\n+\n+\n+/* Complex ACOSH.  */\n+\n+#if !defined(HAVE_CACOSHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CACOSHF 1\n+extern complex float cacoshf (complex float z);\n+#endif\n+\n+#if !defined(HAVE_CACOSH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CACOSH 1\n+extern complex double cacosh (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CACOSHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CACOSHL 1\n+extern complex long double cacoshl (complex long double z);\n+#endif\n+\n+\n+/* Complex ATANH.  */\n+\n+#if !defined(HAVE_CATANHF) && defined(HAVE_CLOGF)\n+#define HAVE_CATANHF 1\n+extern complex float catanhf (complex float z);\n+#endif\n+\n+#if !defined(HAVE_CATANH) && defined(HAVE_CLOG)\n+#define HAVE_CATANH 1\n+extern complex double catanh (complex double z);\n+#endif\n+\n+#if !defined(HAVE_CATANHL) && defined(HAVE_CLOGL)\n+#define HAVE_CATANHL 1\n+extern complex long double catanhl (complex long double z);\n+#endif\n+\n+\n /* Gamma-related prototypes.  */\n #if !defined(HAVE_TGAMMA)\n #define HAVE_TGAMMA 1"}, {"sha": "3c40c1fad3d7d9ac1451fbfcb5dc13d25595addf", "filename": "libgfortran/intrinsics/c99_functions.c", "status": "modified", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2Fintrinsics%2Fc99_functions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/504ed63a1a4f3f35a5fc774f547e4849f53dc2b4/libgfortran%2Fintrinsics%2Fc99_functions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fc99_functions.c?ref=504ed63a1a4f3f35a5fc774f547e4849f53dc2b4", "patch": "@@ -1412,6 +1412,203 @@ ctanl (long double complex a)\n #endif\n \n \n+/* Complex ASIN.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CASINF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CASINF 1\n+complex float\n+casinf (complex float z)\n+{\n+  return -I*clogf (I*z + csqrtf (1.0f-z*z));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CASIN) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CASIN 1\n+complex double\n+casin (complex double z)\n+{\n+  return -I*clog (I*z + csqrt (1.0-z*z));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CASINL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CASINL 1\n+complex long double\n+casinl (complex long double z)\n+{\n+  return -I*clogl (I*z + csqrtl (1.0L-z*z));\n+}\n+#endif\n+\n+\n+/* Complex ACOS.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CACOSF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CACOSF 1\n+complex float\n+cacosf (complex float z)\n+{\n+  return -I*clogf (z + I*csqrtf(1.0f-z*z));\n+}\n+#endif\n+\n+\n+complex double\n+#if !defined(HAVE_CACOS) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CACOS 1\n+cacos (complex double z)\n+{\n+  return -I*clog (z + I*csqrt (1.0-z*z));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CACOSL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CACOSL 1\n+complex long double\n+cacosl (complex long double z)\n+{\n+  return -I*clogl (z + I*csqrtl (1.0L-z*z));\n+}\n+#endif\n+\n+\n+/* Complex ATAN.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CATANF) && defined(HAVE_CLOGF)\n+#define HAVE_CACOSF 1\n+complex float\n+catanf (complex float z)\n+{\n+  return I*clogf ((I+z)/(I-z))/2.0f;\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CATAN) && defined(HAVE_CLOG)\n+#define HAVE_CACOS 1\n+complex double\n+catan (complex double z)\n+{\n+  return I*clog ((I+z)/(I-z))/2.0;\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CATANL) && defined(HAVE_CLOGL)\n+#define HAVE_CACOSL 1\n+complex long double\n+catanl (complex long double z)\n+{\n+  return I*clogl ((I+z)/(I-z))/2.0L;\n+}\n+#endif\n+\n+\n+/* Complex ASINH.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CASINHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CASINHF 1\n+complex float\n+casinhf (complex float z)\n+{\n+  return clogf (z + csqrtf (z*z+1.0f));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CASINH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CASINH 1\n+complex double\n+casinh (complex double z)\n+{\n+  return clog (z + csqrt (z*z+1.0));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CASINHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CASINHL 1\n+complex long double\n+casinhl (complex long double z)\n+{\n+  return clogl (z + csqrtl (z*z+1.0L));\n+}\n+#endif\n+\n+\n+/* Complex ACOSH.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CACOSHF) && defined(HAVE_CLOGF) && defined(HAVE_CSQRTF)\n+#define HAVE_CACOSHF 1\n+complex float\n+cacoshf (complex float z)\n+{\n+  return clogf (z + csqrtf (z-1.0f) * csqrtf (z+1.0f));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CACOSH) && defined(HAVE_CLOG) && defined(HAVE_CSQRT)\n+#define HAVE_CACOSH 1\n+complex double\n+cacosh (complex double z)\n+{\n+  return clog (z + csqrt (z-1.0) * csqrt (z+1.0));\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CACOSHL) && defined(HAVE_CLOGL) && defined(HAVE_CSQRTL)\n+#define HAVE_CACOSHL 1\n+complex long double\n+cacoshl (complex long double z)\n+{\n+  return clogl (z + csqrtl (z-1.0L) * csqrtl (z+1.0L));\n+}\n+#endif\n+\n+\n+/* Complex ATANH.  Returns wrongly NaN for infinite arguments.\n+   Algorithm taken from Abramowitz & Stegun.  */\n+\n+#if !defined(HAVE_CATANHF) && defined(HAVE_CLOGF)\n+#define HAVE_CATANHF 1\n+complex float\n+catanhf (complex float z)\n+{\n+  return clogf ((1.0f+z)/(1.0f-z))/2.0f;\n+}\n+#endif\n+\n+\n+#if !defined(HAVE_CATANH) && defined(HAVE_CLOG)\n+#define HAVE_CATANH 1\n+complex double\n+catanh (complex double z)\n+{\n+  return clog ((1.0+z)/(1.0-z))/2.0;\n+}\n+#endif\n+\n+#if !defined(HAVE_CATANHL) && defined(HAVE_CLOGL)\n+#define HAVE_CATANHL 1\n+complex long double\n+catanhl (complex long double z)\n+{\n+  return clogl ((1.0L+z)/(1.0L-z))/2.0L;\n+}\n+#endif\n+\n+\n #if !defined(HAVE_TGAMMA)\n #define HAVE_TGAMMA 1\n "}]}