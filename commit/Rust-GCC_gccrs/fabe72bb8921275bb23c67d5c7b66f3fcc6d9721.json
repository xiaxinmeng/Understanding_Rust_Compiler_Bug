{"sha": "fabe72bb8921275bb23c67d5c7b66f3fcc6d9721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFiZTcyYmI4OTIxMjc1YmIyM2M2N2Q1YzdiNjZmM2ZjYzZkOTcyMQ==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-07T03:13:53Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1996-06-07T03:13:53Z"}, "message": "h8300.c (h8300_monitor_function_p): New function.\n\n        * h8300/h8300.c (h8300_monitor_function_p): New function.\n        (h8300_os_task_function_p): Likewise.\n        (os_task, monitor): Variables to note if the current\n        function is an os_task or monitor.\n        (function_prologue): Set monitor and/or os_task as needed.  Handle\n        os_task and monitor functions.\n        (function_epilogue): Clear monitor and os_task.  Handle os_task and\n        monitor functions.\n        (h8300_valid_machine_decl_attribute): Accept \"OS_Task\" and\n        \"monitor\".\n\nFrom-SVN: r12205", "tree": {"sha": "e8784b33a47f72a014d0acd148b9c53511356145", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8784b33a47f72a014d0acd148b9c53511356145"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721/comments", "author": null, "committer": null, "parents": [{"sha": "c57a4b7c02ae67f4aa7cc5f636e7dd95d51e247a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c57a4b7c02ae67f4aa7cc5f636e7dd95d51e247a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c57a4b7c02ae67f4aa7cc5f636e7dd95d51e247a"}], "stats": {"total": 80, "additions": 80, "deletions": 0}, "files": [{"sha": "6e6967c0d7eede7424b5cf2c96c9808e78524095", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fabe72bb8921275bb23c67d5c7b66f3fcc6d9721/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=fabe72bb8921275bb23c67d5c7b66f3fcc6d9721", "patch": "@@ -42,6 +42,8 @@ void print_operand_address ();\n char *index ();\n \n static int h8300_interrupt_function_p PROTO ((tree));\n+static int h8300_monitor_function_p PROTO ((tree));\n+static int h8300_os_task_function_p PROTO ((tree));\n \n /* CPU_TYPE, says what cpu we're compiling for.  */\n int cpu_type;\n@@ -50,6 +52,13 @@ int cpu_type;\n    (either via #pragma or an attribute specification).  */\n int interrupt_handler;\n \n+/* True if the current fucntion is an OS Task\n+   (via an attribute specification).  */\n+int os_task;\n+\n+/* True if the current function is a monitor\n+   (via an attribute specification).  */\n+int monitor;\n \n /* True if a #pragma saveall has been seen for the current function.  */\n int pragma_saveall;\n@@ -206,6 +215,26 @@ function_prologue (file, size)\n   if (h8300_interrupt_function_p (current_function_decl))\n     interrupt_handler = 1;\n \n+  /* If the current function has the OS_Task attribute set, then\n+     we have a naked prologue.  */\n+  if (h8300_os_task_function_p (current_function_decl))\n+    {\n+      fprintf (file, \";OS_Task prologue\\n\");\n+      os_task = 1;\n+      return;\n+    }\n+\n+  if (h8300_monitor_function_p (current_function_decl))\n+    {\n+      /* My understanding of monitor functions is they act just\n+\t like interrupt functions, except the prologue must\n+\t mask interrupts.  */\n+      fprintf (file, \";monitor prologue\\n\");\n+      interrupt_handler = 1;\n+      monitor = 1;\n+      fprintf (file, \"\\torc\\t#128,ccr\\n\");\n+    }\n+\n   if (frame_pointer_needed)\n     {\n       /* Push fp */\n@@ -255,6 +284,20 @@ function_epilogue (file, size)\n   int idx;\n   rtx insn = get_last_insn ();\n \n+  if (os_task)\n+    {\n+      /* OS_Task epilogues are nearly naked -- they just have an\n+\t rts instruction.  */\n+      fprintf (file, \";OS_task epilogue\\n\");\n+      fprintf (file, \"\\trts\\n\");\n+      goto out;\n+    }\n+\n+  /* monitor epilogues are the same as interrupt function epilogues.\n+     Just make a note that we're in an monitor epilogue.  */\n+  if (monitor)\n+    fprintf(file, \";monitor epilogue\\n\");\n+\n   /* If the last insn was a BARRIER, we don't have to write any code.  */\n   if (GET_CODE (insn) == NOTE)\n     insn = prev_nonnote_insn (insn);\n@@ -295,7 +338,10 @@ function_epilogue (file, size)\n   else\n     fprintf (file, \"\\trts\\n\");\n \n+out:\n   interrupt_handler = 0;\n+  os_task = 0;\n+  monitor = 0;\n   pragma_saveall = 0;\n }\n \n@@ -2185,6 +2231,38 @@ h8300_interrupt_function_p (func)\n   return a != NULL_TREE;\n }\n \n+/* Return nonzero if FUNC is an OS_Task function as specified\n+   by the \"OS_Task\" attribute.  */\n+\n+static int\n+h8300_os_task_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"OS_Task\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+\n+/* Return nonzero if FUNC is a monitor function as specified\n+   by the \"monitor\" attribute.  */\n+\n+static int\n+h8300_monitor_function_p (func)\n+     tree func;\n+{\n+  tree a;\n+\n+  if (TREE_CODE (func) != FUNCTION_DECL)\n+    return 0;\n+\n+  a = lookup_attribute (\"monitor\", DECL_MACHINE_ATTRIBUTES (func));\n+  return a != NULL_TREE;\n+}\n+\n /* Return nonzero if FUNC is a function that should be called\n    through the function vector.  */\n \n@@ -2262,6 +2340,8 @@ h8300_valid_machine_decl_attribute (decl, attributes, attr, args)\n     return 0;\n \n   if (is_attribute_p (\"interrupt_handler\", attr)\n+      || is_attribute_p (\"OS_Task\", attr)\n+      || is_attribute_p (\"monitor\", attr)\n       || is_attribute_p (\"function_vector\", attr))\n     return TREE_CODE (decl) == FUNCTION_DECL;\n "}]}