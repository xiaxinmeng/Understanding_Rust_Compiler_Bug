{"sha": "60813a463b1e1398cd9786b8c4761283efefb831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA4MTNhNDYzYjFlMTM5OGNkOTc4NmI4YzQ3NjEyODNlZmVmYjgzMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-17T18:16:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-17T18:16:14Z"}, "message": "C++14 constexpr support (minus loops and multiple returns)\n\n\tC++14 constexpr support (minus loops and multiple returns)\ngcc/\n\t* tree-inline.c (copy_fn): New.\n\t* tree-inline.h: Declare it.\ngcc/cp/\n\t* constexpr.c (use_new_call): New macro.\n\t(build_data_member_initialization): Ignore non-mem-inits.\n\t(check_constexpr_bind_expr_vars): Remove C++14 checks.\n\t(constexpr_fn_retval): Likewise.\n\t(check_constexpr_ctor_body): Do nothing in C++14.\n\t(massage_constexpr_body): In C++14 only collect mem-inits.\n\t(get_function_named_in_call): Handle null CALL_EXPR_FN.\n\t(cxx_bind_parameters_in_call): Build bindings in same order as\n\tparameters.  Don't treat iniviref parms specially in new call mode.\n\t(cxx_eval_call_expression): If use_new_call, do constexpr expansion\n\tbased on DECL_SAVED_TREE rather than the massaged constexpr body.\n\tSet up ctx->object from AGGR_INIT_EXPR_SLOT if we don't have one.\n\t(is_sub_constant_expr): Don't mess with ctx.ctor here.\n\t(cxx_eval_component_reference): A null element means we're mid-\n\tinitialization.\n\t(cxx_eval_store_expression, cxx_eval_increment_expression): New.\n\t(cxx_eval_constant_expression): Handle RESULT_DECL, DECL_EXPR,\n\tMODIFY_EXPR, STATEMENT_LIST, BIND_EXPR, USING_STMT,\n\tPREINCREMENT_EXPR, POSTINCREMENT_EXPR, PREDECREMENT_EXPR,\n\tPOSTDECREMENT_EXPR.  Don't look into DECL_INITIAL of variables in\n\tconstexpr functions.  In new-call mode find parms in the values table.\n\t(potential_constant_expression_1): Handle null CALL_EXPR_FN.\n\tHandle STATEMENT_LIST, MODIFY_EXPR, MODOP_EXPR, IF_STMT,\n\tPREINCREMENT_EXPR, POSTINCREMENT_EXPR, PREDECREMENT_EXPR,\n\tPOSTDECREMENT_EXPR, BIND_EXPR, WITH_CLEANUP_EXPR,\n\tCLEANUP_POINT_EXPR, MUST_NOT_THROW_EXPR, TRY_CATCH_EXPR,\n\tEH_SPEC_BLOCK, EXPR_STMT, DECL_EXPR, CASE_LABEL_EXPR, BREAK_STMT,\n\tCONTINUE_STMT, USING_STMT, IF_STMT, DO_STMT, FOR_STMT, WHILE_STMT,\n\tSWITCH_STMT, ASM_EXPR.\n\t(cxx_eval_vec_init_1): Call build_aggr_init_expr.\n\t(cxx_eval_indirect_ref): Don't return a CONSTRUCTOR when the\n\tcaller wants an lvalue.\n\t(cxx_eval_outermost_constant_expr): Pull object out of AGGR_INIT_EXPR.\n\t(maybe_constant_init): Look through INIT_EXPR.\n\t(ensure_literal_type_for_constexpr_object): Set\n\tcp_function_chain->invalid_constexpr.\n\t* cp-tree.h (struct language_function): Add invalid_constexpr bitfield.\n\t* decl.c (start_decl): Set cp_function_chain->invalid_constexpr.\n\t(check_for_uninitialized_const_var): Likewise.\n\t(maybe_save_function_definition): Check it.\n\t* parser.c (cp_parser_jump_statement): Set\n\tcp_function_chain->invalid_constexpr.\n\t(cp_parser_asm_definition): Likewise.\n\nFrom-SVN: r217663", "tree": {"sha": "ed78ea66194e7a5833092975ccb8f03c0921da3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ed78ea66194e7a5833092975ccb8f03c0921da3a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60813a463b1e1398cd9786b8c4761283efefb831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60813a463b1e1398cd9786b8c4761283efefb831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60813a463b1e1398cd9786b8c4761283efefb831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60813a463b1e1398cd9786b8c4761283efefb831/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "544009d369ebcdc8208b76ca4f7e3372f5985f5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/544009d369ebcdc8208b76ca4f7e3372f5985f5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/544009d369ebcdc8208b76ca4f7e3372f5985f5d"}], "stats": {"total": 746, "additions": 653, "deletions": 93}, "files": [{"sha": "1b5d8a0be4e2bb3770333fd4b219ef050c207329", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -1,3 +1,8 @@\n+2014-11-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* tree-inline.c (copy_fn): New.\n+\t* tree-inline.h: Declare it.\n+\n 2014-11-17  Alan Lawrence  <alan.lawrence@arm.com>\n \n \t* config/aarch64/aarch64-builtins.c (TYPES_CREATE): Remove."}, {"sha": "ae347d8b7301d452052d291b48e64326a13b6719", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -1,5 +1,50 @@\n 2014-11-17  Jason Merrill  <jason@redhat.com>\n \n+\tC++14 constexpr support (minus loops and multiple returns)\n+\t* constexpr.c (use_new_call): New macro.\n+\t(build_data_member_initialization): Ignore non-mem-inits.\n+\t(check_constexpr_bind_expr_vars): Remove C++14 checks.\n+\t(constexpr_fn_retval): Likewise.\n+\t(check_constexpr_ctor_body): Do nothing in C++14.\n+\t(massage_constexpr_body): In C++14 only collect mem-inits.\n+\t(get_function_named_in_call): Handle null CALL_EXPR_FN.\n+\t(cxx_bind_parameters_in_call): Build bindings in same order as\n+\tparameters.  Don't treat iniviref parms specially in new call mode.\n+\t(cxx_eval_call_expression): If use_new_call, do constexpr expansion\n+\tbased on DECL_SAVED_TREE rather than the massaged constexpr body.\n+\tSet up ctx->object from AGGR_INIT_EXPR_SLOT if we don't have one.\n+\t(is_sub_constant_expr): Don't mess with ctx.ctor here.\n+\t(cxx_eval_component_reference): A null element means we're mid-\n+\tinitialization.\n+\t(cxx_eval_store_expression, cxx_eval_increment_expression): New.\n+\t(cxx_eval_constant_expression): Handle RESULT_DECL, DECL_EXPR,\n+\tMODIFY_EXPR, STATEMENT_LIST, BIND_EXPR, USING_STMT,\n+\tPREINCREMENT_EXPR, POSTINCREMENT_EXPR, PREDECREMENT_EXPR,\n+\tPOSTDECREMENT_EXPR.  Don't look into DECL_INITIAL of variables in\n+\tconstexpr functions.  In new-call mode find parms in the values table.\n+\t(potential_constant_expression_1): Handle null CALL_EXPR_FN.\n+\tHandle STATEMENT_LIST, MODIFY_EXPR, MODOP_EXPR, IF_STMT,\n+\tPREINCREMENT_EXPR, POSTINCREMENT_EXPR, PREDECREMENT_EXPR,\n+\tPOSTDECREMENT_EXPR, BIND_EXPR, WITH_CLEANUP_EXPR,\n+\tCLEANUP_POINT_EXPR, MUST_NOT_THROW_EXPR, TRY_CATCH_EXPR,\n+\tEH_SPEC_BLOCK, EXPR_STMT, DECL_EXPR, CASE_LABEL_EXPR, BREAK_STMT,\n+\tCONTINUE_STMT, USING_STMT, IF_STMT, DO_STMT, FOR_STMT, WHILE_STMT,\n+\tSWITCH_STMT, ASM_EXPR.\n+\t(cxx_eval_vec_init_1): Call build_aggr_init_expr.\n+\t(cxx_eval_indirect_ref): Don't return a CONSTRUCTOR when the\n+\tcaller wants an lvalue.\n+\t(cxx_eval_outermost_constant_expr): Pull object out of AGGR_INIT_EXPR.\n+\t(maybe_constant_init): Look through INIT_EXPR.\n+\t(ensure_literal_type_for_constexpr_object): Set\n+\tcp_function_chain->invalid_constexpr.\n+\t* cp-tree.h (struct language_function): Add invalid_constexpr bitfield.\n+\t* decl.c (start_decl): Set cp_function_chain->invalid_constexpr.\n+\t(check_for_uninitialized_const_var): Likewise.\n+\t(maybe_save_function_definition): Check it.\n+\t* parser.c (cp_parser_jump_statement): Set\n+\tcp_function_chain->invalid_constexpr.\n+\t(cp_parser_asm_definition): Likewise.\n+\n \tPR c++/52282\n \t* decl.c (build_ptrmemfunc_type): Don't build a different\n \tRECORD_TYPE for a qualified PMF."}, {"sha": "57d0c465d5f20338b5e69d71507621e505683b34", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 501, "deletions": 76, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"gimplify.h\"\n #include \"builtins.h\"\n+#include \"tree-inline.h\"\n \n static bool verify_constant (tree, bool, bool *, bool *);\n #define VERIFY_CONSTANT(X)\t\t\t\t\t\t\\\n@@ -93,8 +94,11 @@ ensure_literal_type_for_constexpr_object (tree decl)\n \t    error (\"the type %qT of constexpr variable %qD is not literal\",\n \t\t   type, decl);\n \t  else\n-\t    error (\"variable %qD of non-literal type %qT in %<constexpr%> \"\n-\t\t   \"function\", decl, type);\n+\t    {\n+\t      error (\"variable %qD of non-literal type %qT in %<constexpr%> \"\n+\t\t     \"function\", decl, type);\n+\t      cp_function_chain->invalid_constexpr = true;\n+\t    }\n \t  explain_non_literal_class (type);\n \t  return NULL;\n \t}\n@@ -310,13 +314,20 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n   if (TREE_CODE (t) == CONVERT_EXPR)\n     t = TREE_OPERAND (t, 0);\n   if (TREE_CODE (t) == INIT_EXPR\n-      || TREE_CODE (t) == MODIFY_EXPR)\n+      /* vptr initialization shows up as a MODIFY_EXPR.  In C++14 we only\n+\t use what this function builds for cx_check_missing_mem_inits, and\n+\t assignment in the ctor body doesn't count.  */\n+      || (cxx_dialect < cxx14 && TREE_CODE (t) == MODIFY_EXPR))\n     {\n       member = TREE_OPERAND (t, 0);\n       init = break_out_target_exprs (TREE_OPERAND (t, 1));\n     }\n   else if (TREE_CODE (t) == CALL_EXPR)\n     {\n+      tree fn = get_callee_fndecl (t);\n+      if (!fn || !DECL_CONSTRUCTOR_P (fn))\n+\t/* We're only interested in calls to subobject constructors.  */\n+\treturn true;\n       member = CALL_EXPR_ARG (t, 0);\n       /* We don't use build_cplus_new here because it complains about\n \t abstract bases.  Leaving the call unwrapped means that it has the\n@@ -325,13 +336,9 @@ build_data_member_initialization (tree t, vec<constructor_elt, va_gc> **vec)\n     }\n   else if (TREE_CODE (t) == BIND_EXPR)\n     return build_data_member_initialization (BIND_EXPR_BODY (t), vec);\n-  else if (TREE_CODE (t) == DECL_EXPR\n-\t   || TREE_CODE (t) == USING_STMT)\n-    /* Declaring a temporary, don't add it to the CONSTRUCTOR.\n-       Likewise for using directives.  */\n-    return true;\n   else\n-    gcc_unreachable ();\n+    /* Don't add anything else to the CONSTRUCTOR.  */\n+    return true;\n   if (INDIRECT_REF_P (member))\n     member = TREE_OPERAND (member, 0);\n   if (TREE_CODE (member) == NOP_EXPR)\n@@ -390,9 +397,6 @@ check_constexpr_bind_expr_vars (tree t)\n {\n   gcc_assert (TREE_CODE (t) == BIND_EXPR);\n \n-  if (cxx_dialect >= cxx14)\n-    return true;\n-\n   for (tree var = BIND_EXPR_VARS (t); var; var = DECL_CHAIN (var))\n     if (TREE_CODE (var) == TYPE_DECL\n \t&& DECL_IMPLICIT_TYPEDEF_P (var))\n@@ -410,8 +414,6 @@ check_constexpr_ctor_body_1 (tree last, tree list)\n     case DECL_EXPR:\n       if (TREE_CODE (DECL_EXPR_DECL (list)) == USING_DECL)\n \treturn true;\n-      if (cxx_dialect >= cxx14)\n-\treturn true;\n       return false;\n \n     case CLEANUP_POINT_EXPR:\n@@ -440,6 +442,10 @@ check_constexpr_ctor_body_1 (tree last, tree list)\n bool\n check_constexpr_ctor_body (tree last, tree list, bool complain)\n {\n+  /* C++14 doesn't require a constexpr ctor to have an empty body.  */\n+  if (cxx_dialect >= cxx14)\n+    return true;\n+\n   bool ok = true;\n   if (TREE_CODE (list) == STATEMENT_LIST)\n     {\n@@ -612,8 +618,6 @@ constexpr_fn_retval (tree body)\n     case DECL_EXPR:\n       if (TREE_CODE (DECL_EXPR_DECL (body)) == USING_DECL)\n \treturn NULL_TREE;\n-      if (cxx_dialect >= cxx14)\n-\treturn NULL_TREE;\n       return error_mark_node;\n \n     case CLEANUP_POINT_EXPR:\n@@ -642,7 +646,7 @@ massage_constexpr_body (tree fun, tree body)\n   if (DECL_CONSTRUCTOR_P (fun))\n     body = build_constexpr_constructor_member_initializers\n       (DECL_CONTEXT (fun), body);\n-  else\n+  else if (cxx_dialect < cxx14)\n     {\n       if (TREE_CODE (body) == EH_SPEC_BLOCK)\n         body = EH_SPEC_STMTS (body);\n@@ -936,7 +940,7 @@ get_function_named_in_call (tree t)\n       gcc_unreachable();\n       break;\n     }\n-  if (TREE_CODE (fun) == ADDR_EXPR\n+  if (fun && TREE_CODE (fun) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (fun, 0)) == FUNCTION_DECL)\n     fun = TREE_OPERAND (fun, 0);\n   return fun;\n@@ -1016,6 +1020,10 @@ adjust_temp_type (tree type, tree temp)\n   return cp_fold_convert (type, temp);\n }\n \n+/* True if we want to use the new handling of constexpr calls based on\n+   DECL_SAVED_TREE.  Currently only active for C++14 mode.  */\n+#define use_new_call (cxx_dialect >= cxx14)\n+\n /* Subroutine of cxx_eval_call_expression.\n    We are processing a call expression (either CALL_EXPR or\n    AGGR_INIT_EXPR) in the context of CTX.  Evaluate\n@@ -1032,26 +1040,27 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n   tree fun = new_call->fundef->decl;\n   tree parms = DECL_ARGUMENTS (fun);\n   int i;\n+  tree *p = &new_call->bindings;\n   for (i = 0; i < nargs; ++i)\n     {\n       tree x, arg;\n       tree type = parms ? TREE_TYPE (parms) : void_type_node;\n       x = get_nth_callarg (t, i);\n       /* For member function, the first argument is a pointer to the implied\n          object.  For a constructor, it might still be a dummy object, in\n-         which case we get the real argument from ctx or the AGGR_INIT_EXPR. */\n+         which case we get the real argument from ctx. */\n       if (i == 0 && DECL_CONSTRUCTOR_P (fun)\n \t  && is_dummy_object (x))\n \t{\n \t  x = ctx->object;\n-\t  if (!x)\n-\t    x = AGGR_INIT_EXPR_SLOT (t);\n \t  x = cp_build_addr_expr (x, tf_warning_or_error);\n \t}\n-      if (parms && DECL_BY_REFERENCE (parms))\n+      if (parms && DECL_BY_REFERENCE (parms) && !use_new_call)\n \t{\n \t  /* cp_genericize made this a reference for argument passing, but\n-\t     we don't want to treat it like one for constexpr evaluation.  */\n+\t     we don't want to treat it like one for C++11 constexpr\n+\t     evaluation.  C++14 constexpr evaluation uses the genericized\n+\t     DECL_SAVED_TREE.  */\n \t  gcc_assert (TREE_CODE (type) == REFERENCE_TYPE);\n \t  gcc_assert (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE);\n \t  type = TREE_TYPE (type);\n@@ -1073,7 +1082,8 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n       /* Make sure the binding has the same type as the parm.  */\n       if (TREE_CODE (type) != REFERENCE_TYPE)\n \targ = adjust_temp_type (type, arg);\n-      new_call->bindings = tree_cons (parms, arg, new_call->bindings);\n+      *p = build_tree_list (parms, arg);\n+      p = &TREE_CHAIN (*p);\n     next:\n       parms = TREE_CHAIN (parms);\n     }\n@@ -1205,6 +1215,20 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n           return t;\n         }\n     }\n+\n+  constexpr_ctx new_ctx = *ctx;\n+  if (DECL_CONSTRUCTOR_P (fun) && !ctx->object\n+      && TREE_CODE (t) == AGGR_INIT_EXPR)\n+    {\n+      /* We want to have an initialization target for an AGGR_INIT_EXPR.\n+\t If we don't already have one in CTX, use the AGGR_INIT_EXPR_SLOT.  */\n+      new_ctx.object = AGGR_INIT_EXPR_SLOT (t);\n+      tree ctor = new_ctx.ctor = build_constructor (DECL_CONTEXT (fun), NULL);\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctor) = true;\n+      ctx->values->put (new_ctx.object, ctor);\n+      ctx = &new_ctx;\n+    }\n+\n   cxx_bind_parameters_in_call (ctx, t, &new_call,\n \t\t\t       allow_non_constant, non_constant_p, overflow_p);\n   if (*non_constant_p)\n@@ -1251,18 +1275,91 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n       result = entry->result;\n       if (!result || result == error_mark_node)\n \t{\n-\t  constexpr_ctx new_ctx = *ctx;\n-\t  new_ctx.call = &new_call;\n-\t  result = (cxx_eval_constant_expression\n-\t\t    (&new_ctx, new_call.fundef->body,\n-\t\t     allow_non_constant, addr,\n-\t\t     non_constant_p, overflow_p));\n+\t  if (!use_new_call)\n+\t    {\n+\t      new_ctx.call = &new_call;\n+\t      result = (cxx_eval_constant_expression\n+\t\t\t(&new_ctx, new_call.fundef->body,\n+\t\t\t allow_non_constant, addr,\n+\t\t\t non_constant_p, overflow_p));\n+\t    }\n+\t  else\n+\t    {\n+\t      if (DECL_SAVED_TREE (fun) == NULL_TREE\n+\t\t  && (DECL_CONSTRUCTOR_P (fun) || DECL_DESTRUCTOR_P (fun)))\n+\t\t/* The maybe-in-charge 'tor had its DECL_SAVED_TREE\n+\t\t   cleared, try the first clone.  */\n+\t\tfun = DECL_CHAIN (fun);\n+\t      gcc_assert (DECL_SAVED_TREE (fun));\n+\t      tree parms, res;\n+\n+\t      /* Unshare the whole function body.  */\n+\t      tree body = copy_fn (fun, parms, res);\n+\n+\t      /* Associate the bindings with the remapped parms.  */\n+\t      tree bound = new_call.bindings;\n+\t      tree remapped = parms;\n+\t      while (bound)\n+\t\t{\n+\t\t  tree oparm = TREE_PURPOSE (bound);\n+\t\t  tree arg = TREE_VALUE (bound);\n+\t\t  gcc_assert (DECL_NAME (remapped) == DECL_NAME (oparm));\n+\t\t  ctx->values->put (remapped, arg);\n+\t\t  bound = TREE_CHAIN (bound);\n+\t\t  remapped = DECL_CHAIN (remapped);\n+\t\t}\n+\t      /* Add the RESULT_DECL to the values map, too.  */\n+\t      tree slot = NULL_TREE;\n+\t      if (DECL_BY_REFERENCE (res))\n+\t\t{\n+\t\t  slot = AGGR_INIT_EXPR_SLOT (t);\n+\t\t  tree addr = build_address (slot);\n+\t\t  addr = build_nop (TREE_TYPE (res), addr);\n+\t\t  ctx->values->put (res, addr);\n+\t\t  ctx->values->put (slot, NULL_TREE);\n+\t\t}\n+\t      else\n+\t\tctx->values->put (res, NULL_TREE);\n+\n+\t      cxx_eval_constant_expression (ctx, body, allow_non_constant,\n+\t\t\t\t\t    addr, non_constant_p, overflow_p);\n+\n+\t      if (VOID_TYPE_P (TREE_TYPE (res)))\n+\t\t/* This can be null for a subobject constructor call, in\n+\t\t   which case what we care about is the initialization\n+\t\t   side-effects rather than the value.  We could get at the\n+\t\t   value by evaluating *this, but we don't bother; there's\n+\t\t   no need to put such a call in the hash table.  */\n+\t\tresult = addr ? ctx->object : ctx->ctor;\n+\t      else\n+\t\t{\n+\t\t  result = *ctx->values->get (slot ? slot : res);\n+\t\t  if (result == NULL_TREE)\n+\t\t    {\n+\t\t      if (!allow_non_constant)\n+\t\t\terror (\"constexpr call flows off the end \"\n+\t\t\t       \"of the function\");\n+\t\t      *non_constant_p = true;\n+\t\t    }\n+\t\t}\n+\n+\t      /* Remove the parms/result from the values map.  Is it worth\n+\t\t bothering to do this when the map itself is only live for\n+\t\t one constexpr evaluation?  If so, maybe also clear out\n+\t\t other vars from call, maybe in BIND_EXPR handling?  */\n+\t      ctx->values->remove (res);\n+\t      if (slot)\n+\t\tctx->values->remove (slot);\n+\t      for (tree parm = parms; parm; parm = TREE_CHAIN (parm))\n+\t\tctx->values->remove (parm);\n+\t    }\n \t}\n+\n       if (result == error_mark_node)\n \t*non_constant_p = true;\n       if (*non_constant_p)\n \tentry->result = result = error_mark_node;\n-      else\n+      else if (result)\n \t{\n \t  /* If this was a call to initialize an object, set the type of\n \t     the CONSTRUCTOR to the type of that object.  */\n@@ -1277,6 +1374,8 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t    }\n \t  entry->result = result;\n \t}\n+      else\n+\tresult = void_node;\n     }\n \n   pop_cx_call_context ();\n@@ -1537,7 +1636,13 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (whole), i, field, value)\n     {\n       if (field == part)\n-        return value;\n+\t{\n+\t  if (value)\n+\t    return value;\n+\t  else\n+\t    /* We're in the middle of initializing it.  */\n+\t    break;\n+\t}\n     }\n   if (TREE_CODE (TREE_TYPE (whole)) == UNION_TYPE\n       && CONSTRUCTOR_NELTS (whole) > 0)\n@@ -1903,6 +2008,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t\t\t\t\t&argvec, elttype, LOOKUP_NORMAL,\n \t\t\t\t\ttf_warning_or_error);\n       release_tree_vector (argvec);\n+      init = build_aggr_init_expr (TREE_TYPE (init), init);\n       pre_init = true;\n     }\n \n@@ -2219,7 +2325,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n   /* If we're pulling out the value of an empty base, make sure\n      that the whole object is constant and then return an empty\n      CONSTRUCTOR.  */\n-  if (empty_base)\n+  if (empty_base && !addr)\n     {\n       VERIFY_CONSTANT (r);\n       r = build_constructor (TREE_TYPE (t), NULL);\n@@ -2317,9 +2423,163 @@ var_in_constexpr_fn (tree t)\n \t  && DECL_DECLARED_CONSTEXPR_P (ctx));\n }\n \n+/* Evaluate an INIT_EXPR or MODIFY_EXPR.  */\n+\n+static tree\n+cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n+\t\t\t   bool allow_non_constant, bool addr,\n+\t\t\t   bool *non_constant_p, bool *overflow_p)\n+{\n+  constexpr_ctx new_ctx = *ctx;\n+\n+  /* First we figure out where we're storing to.  */\n+  tree target = TREE_OPERAND (t, 0);\n+  target = cxx_eval_constant_expression (ctx, target,\n+\t\t\t\t\t allow_non_constant, true,\n+\t\t\t\t\t non_constant_p, overflow_p);\n+  if (*non_constant_p)\n+    return t;\n+\n+  /* And then find the underlying variable.  */\n+  vec<tree,va_gc> *refs = make_tree_vector();\n+  tree object = NULL_TREE;\n+  for (tree probe = target; object == NULL_TREE; )\n+    {\n+      switch (TREE_CODE (probe))\n+\t{\n+\tcase BIT_FIELD_REF:\n+\tcase COMPONENT_REF:\n+\tcase ARRAY_REF:\n+\t  vec_safe_push (refs, TREE_OPERAND (probe, 1));\n+\t  vec_safe_push (refs, TREE_TYPE (probe));\n+\t  probe = TREE_OPERAND (probe, 0);\n+\t  break;\n+\n+\tdefault:\n+\t  object = probe;\n+\t  gcc_assert (DECL_P (object));\n+\t}\n+    }\n+\n+  /* And then find/build up our initializer for the path to the subobject\n+     we're initializing.  */\n+  tree *valp = ctx->values->get (object);\n+  if (!valp)\n+    {\n+      /* A constant-expression cannot modify objects from outside the\n+\t constant-expression.  */\n+      if (!allow_non_constant)\n+\terror (\"modification of %qD is not a constant-expression\", object);\n+      *non_constant_p = true;\n+      return t;\n+    }\n+  tree type = TREE_TYPE (object);\n+  while (!refs->is_empty())\n+    {\n+      if (*valp == NULL_TREE)\n+\t{\n+\t  *valp = build_constructor (type, NULL);\n+\t  CONSTRUCTOR_NO_IMPLICIT_ZERO (*valp) = true;\n+\t}\n+\n+      constructor_elt ce;\n+      type = refs->pop();\n+      ce.index = refs->pop();\n+      ce.value = NULL_TREE;\n+\n+      unsigned HOST_WIDE_INT idx = 0;\n+      constructor_elt *cep = NULL;\n+      for (idx = 0;\n+\t   vec_safe_iterate (CONSTRUCTOR_ELTS (*valp), idx, &cep);\n+\t   idx++)\n+\t/* ??? slow */\n+\tif (cp_tree_equal (ce.index, cep->index))\n+\t  break;\n+      if (!cep)\n+\tcep = vec_safe_push (CONSTRUCTOR_ELTS (*valp), ce);\n+      valp = &cep->value;\n+    }\n+  release_tree_vector (refs);\n+\n+  if ((AGGREGATE_TYPE_P (TREE_TYPE (t)) || VECTOR_TYPE_P (TREE_TYPE (t))))\n+    {\n+      /* Create a new CONSTRUCTOR in case evaluation of the initializer\n+\t wants to modify it.  */\n+      *valp = new_ctx.ctor = build_constructor (TREE_TYPE (t), NULL);\n+      CONSTRUCTOR_NO_IMPLICIT_ZERO (new_ctx.ctor) = true;\n+      new_ctx.object = target;\n+    }\n+\n+  tree init = cxx_eval_constant_expression (&new_ctx, TREE_OPERAND (t, 1),\n+\t\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t\t    non_constant_p, overflow_p);\n+  if (target == object)\n+    /* The hash table might have moved since the get earlier.  */\n+    ctx->values->put (object, init);\n+  else\n+    *valp = init;\n+\n+  if (*non_constant_p)\n+    return t;\n+  else if (addr)\n+    return target;\n+  else\n+    return *valp;\n+}\n+\n+/* Evaluate a ++ or -- expression.  */\n+\n+static tree\n+cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n+\t\t\t      bool allow_non_constant, bool addr,\n+\t\t\t      bool *non_constant_p, bool *overflow_p)\n+{\n+  enum tree_code code = TREE_CODE (t);\n+  tree type = TREE_TYPE (t);\n+  tree op = TREE_OPERAND (t, 0);\n+  tree offset = TREE_OPERAND (t, 1);\n+  gcc_assert (TREE_CONSTANT (offset));\n+\n+  /* The operand as an lvalue.  */\n+  op = cxx_eval_constant_expression (ctx, op, allow_non_constant, true,\n+\t\t\t\t     non_constant_p, overflow_p);\n+\n+  /* The operand as an rvalue.  */\n+  tree val = rvalue (op);\n+  val = cxx_eval_constant_expression (ctx, val, allow_non_constant, false,\n+\t\t\t\t      non_constant_p, overflow_p);\n+  VERIFY_CONSTANT (val);\n+\n+  /* The modified value.  */\n+  bool inc = (code == PREINCREMENT_EXPR || code == POSTINCREMENT_EXPR);\n+  tree mod = fold_build2 (inc ? PLUS_EXPR : MINUS_EXPR,\n+\t\t\t  type, val, offset);\n+  VERIFY_CONSTANT (mod);\n+\n+  /* Storing the modified value.  */\n+  tree store = build2 (MODIFY_EXPR, type, op, mod);\n+  cxx_eval_constant_expression (ctx, store, allow_non_constant,\n+\t\t\t\ttrue, non_constant_p, overflow_p);\n+\n+  /* And the value of the expression.  */\n+  if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n+    {\n+      /* Prefix ops are lvalues.  */\n+      if (addr)\n+\treturn op;\n+      else\n+\t/* But we optimize when the caller wants an rvalue.  */\n+\treturn mod;\n+    }\n+  else\n+    /* Postfix ops are rvalues.  */\n+    return val;\n+}\n+\n /* Attempt to reduce the expression T to a constant value.\n    On failure, issue diagnostic and return error_mark_node.  */\n /* FIXME unify with c_fully_fold */\n+/* FIXME overflow_p is too global */\n \n static tree\n cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n@@ -2348,6 +2608,14 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n   switch (TREE_CODE (t))\n     {\n+    case RESULT_DECL:\n+      if (addr)\n+\treturn t;\n+      /* We ask for an rvalue for the RESULT_DECL when indirecting\n+\t through an invisible reference.  */\n+      gcc_assert (DECL_BY_REFERENCE (t));\n+      return (*ctx->values->get (t));\n+\n     case VAR_DECL:\n       if (addr)\n \treturn t;\n@@ -2357,11 +2625,6 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (TREE_CODE (r) == TARGET_EXPR\n \t  && TREE_CODE (TARGET_EXPR_INITIAL (r)) == CONSTRUCTOR)\n \tr = TARGET_EXPR_INITIAL (r);\n-      if (TREE_CODE (r) == VAR_DECL && var_in_constexpr_fn (r)\n-\t  && DECL_INITIAL (r))\n-\tr = cxx_eval_constant_expression (ctx, DECL_INITIAL (r),\n-\t\t\t\t\t  allow_non_constant, false,\n-\t\t\t\t\t  non_constant_p, overflow_p);\n       if (TREE_CODE (r) == VAR_DECL)\n \tif (tree *p = ctx->values->get (r))\n \t  r = *p;\n@@ -2379,8 +2642,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       return t;\n \n     case PARM_DECL:\n-      if (ctx && ctx->call && DECL_CONTEXT (t) == ctx->call->fundef->decl)\n+      if (!use_new_call && ctx\n+\t  && ctx->call && DECL_CONTEXT (t) == ctx->call->fundef->decl)\n \tr = lookup_parameter_binding (ctx->call, t);\n+      else if (addr && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+\t/* glvalue use.  */;\n+      else if (tree *p = ctx->values->get (r))\n+\tr = *p;\n       else if (addr)\n \t/* Defer in case this is only used for its type.  */;\n       else\n@@ -2397,6 +2665,34 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n+    case DECL_EXPR:\n+      {\n+\tr = DECL_EXPR_DECL (t);\n+\tif (AGGREGATE_TYPE_P (TREE_TYPE (r))\n+\t    || VECTOR_TYPE_P (TREE_TYPE (r)))\n+\t  {\n+\t    new_ctx = *ctx;\n+\t    new_ctx.object = r;\n+\t    new_ctx.ctor = build_constructor (TREE_TYPE (r), NULL);\n+\t    CONSTRUCTOR_NO_IMPLICIT_ZERO (new_ctx.ctor) = true;\n+\t    new_ctx.values->put (r, new_ctx.ctor);\n+\t    ctx = &new_ctx;\n+\t  }\n+\n+\tif (tree init = DECL_INITIAL (r))\n+\t  {\n+\t    init = cxx_eval_constant_expression (ctx, init,\n+\t\t\t\t\t\t allow_non_constant, false,\n+\t\t\t\t\t\t non_constant_p, overflow_p);\n+\t    ctx->values->put (r, init);\n+\t  }\n+\telse if (ctx == &new_ctx)\n+\t  /* We gave it a CONSTRUCTOR above.  */;\n+\telse\n+\t  ctx->values->put (r, NULL_TREE);\n+      }\n+      break;\n+\n     case TARGET_EXPR:\n       if (!literal_type_p (TREE_TYPE (t)))\n \t{\n@@ -2421,9 +2717,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  ctx->values->put (new_ctx.object, new_ctx.ctor);\n \t  ctx = &new_ctx;\n \t}\n-      /* else fall through.  */\n-    case INIT_EXPR:\n-      /* Pass false for 'addr' because these codes indicate\n+      /* Pass false for 'addr' because this indicates\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, false,\n@@ -2433,6 +2727,22 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tr = adjust_temp_type (TREE_TYPE (t), r);\n       break;\n \n+    case INIT_EXPR:\n+      if (!use_new_call)\n+\t{\n+\t  /* In C++11 constexpr evaluation we are looking for the value,\n+\t     not the side-effect of the initialization.  */\n+\t  r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n+\t\t\t\t\t    allow_non_constant, false,\n+\t\t\t\t\t    non_constant_p, overflow_p);\n+\t  break;\n+\t}\n+      /* else fall through */\n+    case MODIFY_EXPR:\n+      r = cxx_eval_store_expression (ctx, t, allow_non_constant, addr,\n+\t\t\t\t     non_constant_p, overflow_p);\n+      break;\n+\n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tallow_non_constant, addr,\n@@ -2445,6 +2755,8 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case CLEANUP_POINT_EXPR:\n     case MUST_NOT_THROW_EXPR:\n     case SAVE_EXPR:\n+    case EXPR_STMT:\n+    case EH_SPEC_BLOCK:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n \t\t\t\t\tallow_non_constant, addr,\n \t\t\t\t\tnon_constant_p, overflow_p);\n@@ -2679,27 +2991,47 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t used, and they can't do anything with it, so just return it.  */\n       return t;\n \n-    case LAMBDA_EXPR:\n+    case STATEMENT_LIST:\n+      {\n+\tnew_ctx = *ctx;\n+\tnew_ctx.ctor = new_ctx.object = NULL_TREE;\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  {\n+\t    cxx_eval_constant_expression (&new_ctx, tsi_stmt (i),\n+\t\t\t\t\t  allow_non_constant, false,\n+\t\t\t\t\t  non_constant_p, overflow_p);\n+\t    if (*non_constant_p)\n+\t      break;\n+\t  }\n+      }\n+      break;\n+\n+    case BIND_EXPR:\n+      return cxx_eval_constant_expression (ctx, BIND_EXPR_BODY (t),\n+\t\t\t\t\t   allow_non_constant, addr,\n+\t\t\t\t\t   non_constant_p, overflow_p);\n+\n     case PREINCREMENT_EXPR:\n     case POSTINCREMENT_EXPR:\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n+      return cxx_eval_increment_expression (ctx, t, allow_non_constant,\n+\t\t\t\t\t    addr, non_constant_p, overflow_p);\n+\n+    case LAMBDA_EXPR:\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n     case THROW_EXPR:\n-    case MODIFY_EXPR:\n     case MODOP_EXPR:\n       /* GCC internal stuff.  */\n     case VA_ARG_EXPR:\n     case OBJ_TYPE_REF:\n     case WITH_CLEANUP_EXPR:\n-    case STATEMENT_LIST:\n-    case BIND_EXPR:\n     case NON_DEPENDENT_EXPR:\n     case BASELINK:\n-    case EXPR_STMT:\n     case OFFSET_REF:\n       if (!allow_non_constant)\n         error_at (EXPR_LOC_OR_LOC (t, input_location),\n@@ -2730,6 +3062,14 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t}\n       break;\n \n+    case GOTO_EXPR:\n+    case LOOP_EXPR:\n+    case SWITCH_EXPR:\n+      if (!allow_non_constant)\n+\tsorry (\"%qs in constant expression\", get_tree_code_name (TREE_CODE (t)));\n+      *non_constant_p = true;\n+      break;\n+\n     default:\n       internal_error (\"unexpected expression %qE of kind %s\", t,\n \t\t      get_tree_code_name (TREE_CODE (t)));\n@@ -2768,8 +3108,13 @@ cxx_eval_outermost_constant_expr (tree t, bool allow_non_constant,\n \t initialized.  */\n       ctx.ctor = build_constructor (type, NULL);\n       CONSTRUCTOR_NO_IMPLICIT_ZERO (ctx.ctor) = true;\n-      if (!object && TREE_CODE (t) == TARGET_EXPR)\n-\tobject = TARGET_EXPR_SLOT (t);\n+      if (!object)\n+\t{\n+\t  if (TREE_CODE (t) == TARGET_EXPR)\n+\t    object = TARGET_EXPR_SLOT (t);\n+\t  else if (TREE_CODE (t) == AGGR_INIT_EXPR)\n+\t    object = AGGR_INIT_EXPR_SLOT (t);\n+\t}\n       ctx.object = object;\n       if (object)\n \tgcc_assert (same_type_ignoring_top_level_qualifiers_p\n@@ -2859,13 +3204,6 @@ is_sub_constant_expr (tree t)\n   constexpr_ctx ctx = { NULL, NULL, NULL, NULL };\n   hash_map <tree, tree> map;\n   ctx.values = &map;\n-  tree type = initialized_type (t);\n-  if ((AGGREGATE_TYPE_P (type) || VECTOR_TYPE_P (type))\n-      && TREE_CODE (t) != TARGET_EXPR)\n-    {\n-      ctx.ctor = build_constructor (type, NULL);\n-      CONSTRUCTOR_NO_IMPLICIT_ZERO (ctx.ctor) = true;\n-    }\n   cxx_eval_constant_expression (&ctx, t, true, false, &non_constant_p,\n \t\t\t\t&overflow_p);\n   return !non_constant_p && !overflow_p;\n@@ -2996,6 +3334,8 @@ maybe_constant_init (tree t, tree decl)\n   if (TREE_CODE (t) == CONVERT_EXPR\n       && VOID_TYPE_P (TREE_TYPE (t)))\n     t = TREE_OPERAND (t, 0);\n+  if (TREE_CODE (t) == INIT_EXPR)\n+    t = TREE_OPERAND (t, 1);\n   t = maybe_constant_value (t, decl);\n   if (TREE_CODE (t) == TARGET_EXPR)\n     {\n@@ -3078,6 +3418,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case TEMPLATE_ID_EXPR:\n     case LABEL_DECL:\n     case LABEL_EXPR:\n+    case CASE_LABEL_EXPR:\n     case CONST_DECL:\n     case SIZEOF_EXPR:\n     case ALIGNOF_EXPR:\n@@ -3091,7 +3432,10 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case FIELD_DECL:\n     case PARM_DECL:\n     case USING_DECL:\n+    case USING_STMT:\n     case PLACEHOLDER_EXPR:\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n       return true;\n \n     case AGGR_INIT_EXPR:\n@@ -3103,6 +3447,14 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n         const int nargs = call_expr_nargs (t);\n \ti = 0;\n \n+\tif (fun == NULL_TREE)\n+\t  {\n+\t    /* fold_call_expr can't do anything with IFN calls.  */\n+\t    if (flags & tf_error)\n+\t      error_at (EXPR_LOC_OR_LOC (t, input_location),\n+\t\t\t\"call to internal function\");\n+\t    return false;\n+\t  }\n \tif (is_overloaded_fn (fun))\n \t  {\n \t    if (TREE_CODE (fun) == FUNCTION_DECL)\n@@ -3266,43 +3618,96 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \treturn potential_constant_expression_1 (x, rval, flags);\n       }\n \n+    case STATEMENT_LIST:\n+      {\n+\ttree_stmt_iterator i;\n+\tfor (i = tsi_start (t); !tsi_end_p (i); tsi_next (&i))\n+\t  {\n+\t    if (!potential_constant_expression_1 (tsi_stmt (i), any, flags))\n+\t      return false;\n+\t  }\n+\treturn true;\n+      }\n+      break;\n+\n+    case MODIFY_EXPR:\n+      if (cxx_dialect < cxx14)\n+\tgoto fail;\n+      if (!potential_constant_expression_1 (TREE_OPERAND (t, 0), any, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (TREE_OPERAND (t, 1), rval, flags))\n+\treturn false;\n+      return true;\n+\n+    case MODOP_EXPR:\n+      if (cxx_dialect < cxx14)\n+\tgoto fail;\n+      if (!potential_constant_expression_1 (TREE_OPERAND (t, 0), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (TREE_OPERAND (t, 2), rval, flags))\n+\treturn false;\n+      return true;\n+\n+    case IF_STMT:\n+      if (!potential_constant_expression_1 (IF_COND (t), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (THEN_CLAUSE (t), any, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (ELSE_CLAUSE (t), any, flags))\n+\treturn false;\n+      return true;\n+\n+    case DO_STMT:\n+      if (!potential_constant_expression_1 (DO_COND (t), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (DO_BODY (t), any, flags))\n+\treturn false;\n+      return true;\n+\n+    case FOR_STMT:\n+      if (!potential_constant_expression_1 (FOR_INIT_STMT (t), any, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (FOR_COND (t), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (FOR_EXPR (t), any, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (FOR_BODY (t), any, flags))\n+\treturn false;\n+      return true;\n+\n+    case WHILE_STMT:\n+      if (!potential_constant_expression_1 (WHILE_COND (t), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (WHILE_BODY (t), any, flags))\n+\treturn false;\n+      return true;\n+\n+    case SWITCH_STMT:\n+      if (!potential_constant_expression_1 (SWITCH_STMT_COND (t), rval, flags))\n+\treturn false;\n+      if (!potential_constant_expression_1 (SWITCH_STMT_BODY (t), any, flags))\n+\treturn false;\n+      return true;\n+\n     case LAMBDA_EXPR:\n     case DYNAMIC_CAST_EXPR:\n     case PSEUDO_DTOR_EXPR:\n-    case PREINCREMENT_EXPR:\n-    case POSTINCREMENT_EXPR:\n-    case PREDECREMENT_EXPR:\n-    case POSTDECREMENT_EXPR:\n     case NEW_EXPR:\n     case VEC_NEW_EXPR:\n     case DELETE_EXPR:\n     case VEC_DELETE_EXPR:\n     case THROW_EXPR:\n-    case MODIFY_EXPR:\n-    case MODOP_EXPR:\n     case OMP_ATOMIC:\n     case OMP_ATOMIC_READ:\n     case OMP_ATOMIC_CAPTURE_OLD:\n     case OMP_ATOMIC_CAPTURE_NEW:\n       /* GCC internal stuff.  */\n     case VA_ARG_EXPR:\n     case OBJ_TYPE_REF:\n-    case WITH_CLEANUP_EXPR:\n-    case CLEANUP_POINT_EXPR:\n-    case MUST_NOT_THROW_EXPR:\n-    case TRY_CATCH_EXPR:\n-    case STATEMENT_LIST:\n-      /* Don't bother trying to define a subset of statement-expressions to\n-\t be constant-expressions, at least for now.  */\n     case STMT_EXPR:\n-    case EXPR_STMT:\n-    case BIND_EXPR:\n     case TRANSACTION_EXPR:\n-    case IF_STMT:\n-    case DO_STMT:\n-    case FOR_STMT:\n-    case WHILE_STMT:\n-    case DECL_EXPR:\n+    case ASM_EXPR:\n+    fail:\n       if (flags & tf_error)\n         error (\"expression %qE is not a constant-expression\", t);\n       return false;\n@@ -3355,6 +3760,14 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n       want_rval = true;\n       goto binary;\n \n+    case PREINCREMENT_EXPR:\n+    case POSTINCREMENT_EXPR:\n+    case PREDECREMENT_EXPR:\n+    case POSTDECREMENT_EXPR:\n+      if (cxx_dialect < cxx14)\n+\tgoto fail;\n+      goto unary;\n+\n     case BIT_NOT_EXPR:\n       /* A destructor.  */\n       if (TYPE_P (TREE_OPERAND (t, 0)))\n@@ -3372,6 +3785,7 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n     case TRUTH_NOT_EXPR:\n     case FIXED_CONVERT_EXPR:\n     case UNARY_PLUS_EXPR:\n+    unary:\n       return potential_constant_expression_1 (TREE_OPERAND (t, 0), rval,\n \t\t\t\t\t      flags);\n \n@@ -3396,7 +3810,18 @@ potential_constant_expression_1 (tree t, bool want_rval, tsubst_flags_t flags)\n \t      (TREE_OPERAND (t, 0),\n \t       TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE, flags));\n \n+    case BIND_EXPR:\n+      return potential_constant_expression_1 (BIND_EXPR_BODY (t),\n+\t\t\t\t\t      want_rval, flags);\n+\n+    case WITH_CLEANUP_EXPR:\n+    case CLEANUP_POINT_EXPR:\n+    case MUST_NOT_THROW_EXPR:\n+    case TRY_CATCH_EXPR:\n+    case EH_SPEC_BLOCK:\n+    case EXPR_STMT:\n     case PAREN_EXPR:\n+    case DECL_EXPR:\n     case NON_DEPENDENT_EXPR:\n       /* For convenience.  */\n     case RETURN_EXPR:"}, {"sha": "adc8aa72d973b4c1582f715d79008c18a6e80dfa", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -1182,6 +1182,8 @@ struct GTY(()) language_function {\n   /* True if this function can throw an exception.  */\n   BOOL_BITFIELD can_throw : 1;\n \n+  BOOL_BITFIELD invalid_constexpr : 1;\n+\n   hash_table<named_label_hasher> *x_named_labels;\n   cp_binding_level *bindings;\n   vec<tree, va_gc> *x_local_names;"}, {"sha": "47da0ca4eccb424249ef03b1b17336ec05b06042", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -4779,11 +4779,16 @@ start_decl (const cp_declarator *declarator,\n   if (current_function_decl && VAR_P (decl)\n       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n     {\n+      bool ok = false;\n       if (DECL_THREAD_LOCAL_P (decl))\n \terror (\"%qD declared %<thread_local%> in %<constexpr%> function\",\n \t       decl);\n       else if (TREE_STATIC (decl))\n \terror (\"%qD declared %<static%> in %<constexpr%> function\", decl);\n+      else\n+\tok = true;\n+      if (!ok)\n+\tcp_function_chain->invalid_constexpr = true;\n     }\n \n   if (!processing_template_decl && VAR_P (decl))\n@@ -5165,9 +5170,12 @@ check_for_uninitialized_const_var (tree decl)\n \tpermerror (DECL_SOURCE_LOCATION (decl),\n \t\t   \"uninitialized const %qD\", decl);\n       else\n-\terror_at (DECL_SOURCE_LOCATION (decl),\n-\t\t  \"uninitialized variable %qD in %<constexpr%> function\",\n-\t\t  decl);\n+\t{\n+\t  error_at (DECL_SOURCE_LOCATION (decl),\n+\t\t    \"uninitialized variable %qD in %<constexpr%> function\",\n+\t\t    decl);\n+\t  cp_function_chain->invalid_constexpr = true;\n+\t}\n \n       if (CLASS_TYPE_P (type))\n \t{\n@@ -13995,6 +14003,7 @@ maybe_save_function_definition (tree fun)\n {\n   if (!processing_template_decl\n       && DECL_DECLARED_CONSTEXPR_P (fun)\n+      && !cp_function_chain->invalid_constexpr\n       && !DECL_CLONED_FUNCTION_P (fun))\n     register_constexpr_fundef (fun, DECL_SAVED_TREE (fun));\n }"}, {"sha": "3eff5fad862159b7d57cf62bf6f4e1700c496290", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -11004,7 +11004,10 @@ cp_parser_jump_statement (cp_parser* parser)\n     case RID_GOTO:\n       if (parser->in_function_body\n \t  && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n-\terror (\"%<goto%> in %<constexpr%> function\");\n+\t{\n+\t  error (\"%<goto%> in %<constexpr%> function\");\n+\t  cp_function_chain->invalid_constexpr = true;\n+\t}\n \n       /* Create the goto-statement.  */\n       if (cp_lexer_next_token_is (parser->lexer, CPP_MULT))\n@@ -16588,7 +16591,10 @@ cp_parser_asm_definition (cp_parser* parser)\n \n   if (parser->in_function_body\n       && DECL_DECLARED_CONSTEXPR_P (current_function_decl))\n-    error (\"%<asm%> in %<constexpr%> function\");\n+    {\n+      error (\"%<asm%> in %<constexpr%> function\");\n+      cp_function_chain->invalid_constexpr = true;\n+    }\n \n   /* See if the next token is `volatile'.  */\n   if (cp_parser_allow_gnu_extensions_p (parser)"}, {"sha": "708f5f2b3f82abff55c45ae0e3892b09150d3e07", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-diag5.C", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-diag5.C?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -23,26 +23,26 @@ struct C\n \n struct D\n {\n-    constexpr D() { return;} // { dg-error \"does not have empty body\" }\n+    constexpr D() { return;} // { dg-error \"does not have empty body\" \"\" { target c++11_only } }\n };\n \n struct D1\n {\n     A a;\n-    constexpr D1() { return;} // { dg-error \"does not have empty body\" }\n+    constexpr D1() { return;} // { dg-error \"does not have empty body\" \"\" { target c++11_only } }\n };\n \n struct D2\n {\n     A a;\n     A b;\n-    constexpr D2() { return;} // { dg-error \"does not have empty body\" }\n+    constexpr D2() { return;} // { dg-error \"does not have empty body\" \"\" { target c++11_only } }\n };\n \n struct D3\n {\n     A a;\n     A b;\n     A c;\n-    constexpr D3() { return;} // { dg-error \"does not have empty body\" }\n+    constexpr D3() { return;} // { dg-error \"does not have empty body\" \"\" { target c++11_only } }\n };"}, {"sha": "85dfca4ff1db266b1285c0f28fa293bdf05fa928", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-friend.C", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-friend.C?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -12,12 +12,14 @@ template <class T>\n struct C\n {\n   friend constexpr int f(C) { return 0; }\n-  friend constexpr int g(C, A) { return 0; } // { dg-error \"double\" }\n+  friend constexpr int g(C, A) { return 0; }\n   constexpr int m(C) { return 0; }\n-  constexpr int m(A) { return 0; } // { dg-error \"double\" }\n+  constexpr int m(A) { return 0; }\n };\n \n constexpr int i = f(C<int>());\n constexpr int j = C<int>().m(C<int>());\n-constexpr int k = C<double>().m(A()); // { dg-error \"constexpr\" }\n-constexpr int l = g(C<double>(),A()); // { dg-error \"constexpr\" }\n+constexpr int k = C<double>().m(A()); // { dg-error \"\" }\n+constexpr int l = g(C<double>(),A()); // { dg-error \"\" }\n+\n+// { dg-prune-output \"parameter\" }"}, {"sha": "8c51c9ddd257931688389213cb77f0003607adff", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-function2.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-function2.C?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -27,14 +27,14 @@ constexpr void f(int x)       // { dg-error \"return type .void\" }\n { /* ... */ }\n \n constexpr int prev(int x)\n-{ return --x; }               // { dg-error \"--\" }\n+{ return --x; }               // { dg-error \"--\" \"\" { target c++11_only } }\n \n constexpr int g(int x, int n) // error: body not just \u2018\u2018return expr\u2019\u2019\n {\n    int r = 1;\n    while (--n > 0) r *= x;\n    return r;\n-} // { dg-error \"not a return-statement\" }\n+} // { dg-error \"not a return-statement\" \"\" { target c++11_only } }\n \n constexpr int\n bar(int x, int y) { return x + y + x * y; } // { dg-message \"previously\" }"}, {"sha": "35f5e8e94f44e4c6858bf86f47d2156041ba63ff", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-neg1.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-neg1.C?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -33,14 +33,14 @@ constexpr void f(int x)\t\t// { dg-error \"void\" }\n { /* ... */ }\n // error: use of decrement\n constexpr int prev(int x)\n-{ return --x; }\t\t\t// { dg-error \"-- x\" }\n+{ return --x; }\t\t\t// { dg-error \"-- x\" \"\" { target c++11_only } }\n \n // error: body not just return expr\n constexpr int g(int x, int n) {\n   int r = 1;\n   while (--n > 0) r *= x;\n   return r;\n-} // { dg-error \"body of constexpr function\" }\n+} // { dg-error \"body of constexpr function\" \"\" { target c++11_only } }\n \n class debug_flag {\n public:"}, {"sha": "2b099c821e0bb4fc027c2eb6d608c903d1edf72c", "filename": "gcc/testsuite/g++.dg/cpp1y/constexpr-incr1.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-incr1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-incr1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fconstexpr-incr1.C?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++14 } }\n+\n+constexpr int f (int i)\n+{\n+  ++i;\n+  int x = i;\n+  ++x;\n+  return x;\n+}\n+\n+constexpr int i = f(42);\n+#define SA(X) static_assert((X),#X)\n+SA(i==44);"}, {"sha": "4b937ca8daa2ee13ecb6ed054ab4e677b655d027", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -5817,3 +5817,55 @@ build_duplicate_type (tree type)\n \n   return type;\n }\n+\n+/* Unshare the entire DECL_SAVED_TREE of FN and return the remapped\n+   parameters and RESULT_DECL in PARMS and RESULT.  Used by C++ constexpr\n+   evaluation.  */\n+\n+tree\n+copy_fn (tree fn, tree& parms, tree& result)\n+{\n+  copy_body_data id;\n+  tree param;\n+  hash_map<tree, tree> decl_map;\n+\n+  tree *p = &parms;\n+  *p = NULL_TREE;\n+\n+  memset (&id, 0, sizeof (id));\n+  id.src_fn = fn;\n+  id.dst_fn = current_function_decl;\n+  id.src_cfun = DECL_STRUCT_FUNCTION (fn);\n+  id.decl_map = &decl_map;\n+\n+  id.copy_decl = copy_decl_no_change;\n+  id.transform_call_graph_edges = CB_CGE_DUPLICATE;\n+  id.transform_new_cfg = false;\n+  id.transform_return_to_modify = false;\n+  id.transform_parameter = true;\n+  id.transform_lang_insert_block = NULL;\n+\n+  /* Make sure not to unshare trees behind the front-end's back\n+     since front-end specific mechanisms may rely on sharing.  */\n+  id.regimplify = false;\n+  id.do_not_unshare = true;\n+\n+  /* We're not inside any EH region.  */\n+  id.eh_lp_nr = 0;\n+\n+  /* Remap the parameters and result and return them to the caller.  */\n+  for (param = DECL_ARGUMENTS (fn);\n+       param;\n+       param = DECL_CHAIN (param))\n+    {\n+      *p = remap_decl (param, &id);\n+      p = &DECL_CHAIN (*p);\n+    }\n+\n+  if (DECL_RESULT (fn))\n+    result = remap_decl (DECL_RESULT (fn), &id);\n+  else\n+    result = NULL_TREE;\n+\n+  return copy_tree_body (&id);\n+}"}, {"sha": "9d70e3efce91db66ef5787f08a6e1f318b36ce4a", "filename": "gcc/tree-inline.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftree-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60813a463b1e1398cd9786b8c4761283efefb831/gcc%2Ftree-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.h?ref=60813a463b1e1398cd9786b8c4761283efefb831", "patch": "@@ -209,6 +209,7 @@ extern tree remap_decl (tree decl, copy_body_data *id);\n extern tree remap_type (tree type, copy_body_data *id);\n extern gimple_seq copy_gimple_seq_and_replace_locals (gimple_seq seq);\n extern bool debug_find_tree (tree, tree);\n+extern tree copy_fn (tree, tree&, tree&);\n \n /* This is in tree-inline.c since the routine uses\n    data structures from the inliner.  */"}]}