{"sha": "d103f336bdc3144e756c7634b8914830c867896d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDEwM2YzMzZiZGMzMTQ0ZTc1NmM3NjM0Yjg5MTQ4MzBjODY3ODk2ZA==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-23T14:42:54Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2020-06-25T15:02:46Z"}, "message": "d: Merge upstream dmd 5fc1806cd.\n\nBackports the OutBuffer interface from upstream dmd master, removing\nanother difference this and the self-hosted D branch that is purely\nrefactoring, and doesn't introduce any mechanical changes.\n\nReviewed-on: https://github.com/dlang/dmd/pull/11302\n\ngcc/d/ChangeLog:\n\n\t* dmd/MERGE: Merge upstream dmd 5fc1806cd.\n\t* d-lang.cc (d_parse_file): Use peekChars to get string representation\n\tof OutBuffer data.", "tree": {"sha": "af8108e72597172e7029a39bd853598cdf2f490a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af8108e72597172e7029a39bd853598cdf2f490a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d103f336bdc3144e756c7634b8914830c867896d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d103f336bdc3144e756c7634b8914830c867896d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d103f336bdc3144e756c7634b8914830c867896d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d103f336bdc3144e756c7634b8914830c867896d/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62e02c8729a75c4a859edc18e0bcafb87d717f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e02c8729a75c4a859edc18e0bcafb87d717f46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e02c8729a75c4a859edc18e0bcafb87d717f46"}], "stats": {"total": 451, "additions": 224, "deletions": 227}, "files": [{"sha": "e4d0a24c65c9584d6b41da9c979eeea959b4f0a3", "filename": "gcc/d/d-lang.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fd-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fd-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-lang.cc?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -1043,7 +1043,7 @@ d_parse_file (void)\n \t      buf.writestring (s);\n \t    }\n \n-\t  message (\"%.*s\", (int) buf.offset, (char *) buf.data);\n+\t  message (\"%s\", buf.peekChars ());\n \t}\n     }\n \n@@ -1361,7 +1361,7 @@ d_parse_file (void)\n \t  buf.doindent = 1;\n \n \t  moduleToBuffer (&buf, m);\n-\t  message (\"%.*s\", (int) buf.offset, (char *) buf.data);\n+\t  message (\"%s\", buf.peekChars ());\n \t}\n     }\n "}, {"sha": "0e48f42a0e2f3771057c7512e44a853570100fe6", "filename": "gcc/d/dmd/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2FMERGE?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -1,4 +1,4 @@\n-4f1046222f3a15a746ad2455e1099ed31e39b554\n+5fc1806cd7dd281e944022df2e11ef6b04ee4339\n \n The first line of this file holds the git revision number of the last\n merge done from the dlang/dmd repository."}, {"sha": "1fc9d936bbda23e4ad15180be9ebe7bafb95bfaf", "filename": "gcc/d/dmd/dcast.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdcast.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdcast.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdcast.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -1758,7 +1758,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                         else\n                             buffer.writeUTF16(c);\n                     }\n-                    newlen = buffer.offset / 2;\n+                    newlen = buffer.length() / 2;\n                     buffer.writeUTF16(0);\n                     goto L1;\n \n@@ -1785,7 +1785,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                         else\n                             buffer.writeUTF8(c);\n                     }\n-                    newlen = buffer.offset;\n+                    newlen = buffer.length();\n                     buffer.writeUTF8(0);\n                     goto L1;\n \n@@ -1812,7 +1812,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                             buffer.writeUTF8(c);\n                         newlen++;\n                     }\n-                    newlen = buffer.offset;\n+                    newlen = buffer.length();\n                     buffer.writeUTF8(0);\n                     goto L1;\n \n@@ -1826,7 +1826,7 @@ Expression *castTo(Expression *e, Scope *sc, Type *t)\n                             buffer.writeUTF16(c);\n                         newlen++;\n                     }\n-                    newlen = buffer.offset / 2;\n+                    newlen = buffer.length() / 2;\n                     buffer.writeUTF16(0);\n                     goto L1;\n "}, {"sha": "07187612616dfcdb51b1639d294eab63480232bb", "filename": "gcc/d/dmd/dmacro.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmacro.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -237,14 +237,14 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n \n     size_t end = *pend;\n     assert(start <= end);\n-    assert(end <= buf->offset);\n+    assert(end <= buf->length());\n \n     /* First pass - replace $0\n      */\n     arg = memdup(arg, arglen);\n     for (size_t u = start; u + 1 < end; )\n     {\n-        utf8_t *p = (utf8_t *)buf->data;   // buf->data is not loop invariant\n+        utf8_t *p = (utf8_t *)buf->slice().ptr;   // buf->slice().ptr is not loop invariant\n \n         /* Look for $0, but not $$0, and replace it with arg.\n          */\n@@ -294,8 +294,8 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n             {\n                 // Replace '$1' with '\\xFF{arg\\xFF}'\n                 //printf(\"Replacing '$%c' with '\\xFF{%.*s\\xFF}'\\n\", p[u + 1], marglen, marg);\n-                buf->data[u] = 0xFF;\n-                buf->data[u + 1] = '{';\n+                buf->slice().ptr[u] = 0xFF;\n+                buf->slice().ptr[u + 1] = '{';\n                 buf->insert(u + 2, marg, marglen);\n                 buf->insert(u + 2 + marglen, (const char *)\"\\xFF}\", 2);\n                 end += -2 + 2 + marglen + 2;\n@@ -307,7 +307,7 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n                 u = mend;\n             }\n             //printf(\"u = %d, end = %d\\n\", u, end);\n-            //printf(\"#%.*s#\\n\", end, &buf->data[0]);\n+            //printf(\"#%.*s#\\n\", end, &buf->slice().ptr[0]);\n             continue;\n         }\n \n@@ -318,7 +318,7 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n      */\n     for (size_t u = start; u + 4 < end; )\n     {\n-        utf8_t *p = (utf8_t *)buf->data;   // buf->data is not loop invariant\n+        utf8_t *p = (utf8_t *)buf->slice().ptr;   // buf->slice().ptr is not loop invariant\n \n         /* A valid start of macro expansion is $(c, where c is\n          * an id start character, and not $$(c.\n@@ -418,11 +418,11 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n                         marg = memdup(marg, marglen);\n                         // Insert replacement text\n                         buf->spread(v + 1, 2 + m->textlen + 2);\n-                        buf->data[v + 1] = 0xFF;\n-                        buf->data[v + 2] = '{';\n-                        memcpy(buf->data + v + 3, m->text, m->textlen);\n-                        buf->data[v + 3 + m->textlen] = 0xFF;\n-                        buf->data[v + 3 + m->textlen + 1] = '}';\n+                        buf->slice().ptr[v + 1] = 0xFF;\n+                        buf->slice().ptr[v + 2] = '{';\n+                        memcpy(buf->slice().ptr + v + 3, m->text, m->textlen);\n+                        buf->slice().ptr[v + 3 + m->textlen] = 0xFF;\n+                        buf->slice().ptr[v + 3 + m->textlen + 1] = '}';\n \n                         end += 2 + m->textlen + 2;\n \n@@ -438,7 +438,7 @@ void Macro::expand(OutBuffer *buf, size_t start, size_t *pend,\n                         u += mend - (v + 1);\n                         mem.xfree(const_cast<utf8_t *>(marg));\n                         //printf(\"u = %d, end = %d\\n\", u, end);\n-                        //printf(\"#%.*s#\\n\", end - u, &buf->data[u]);\n+                        //printf(\"#%.*s#\\n\", end - u, &buf->slice().ptr[u]);\n                         continue;\n                     }\n                 }"}, {"sha": "ea63bf3acf02f1fe899f77e3db56acfb2d58881c", "filename": "gcc/d/dmd/dmangle.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmangle.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -262,7 +262,7 @@ class Mangler : public Visitor\n \n         // Write argument types\n         paramsToDecoBuffer(t->parameterList.parameters);\n-        //if (buf->data[buf->offset - 1] == '@') halt();\n+        //if (buf->slice().ptr[buf->length() - 1] == '@') halt();\n         buf->writeByte('Z' - t->parameterList.varargs);   // mark end of arg list\n         if (tret != NULL)\n             visitWithMask(tret, 0);\n@@ -308,7 +308,7 @@ class Mangler : public Visitor\n         Mangler v(&buf2);\n         v.paramsToDecoBuffer(t->arguments);\n         const char *s = buf2.peekChars();\n-        int len = (int)buf2.offset;\n+        int len = (int)buf2.length();\n         buf->printf(\"%d%.*s\", len, len, s);\n     }\n \n@@ -716,8 +716,8 @@ class Mangler : public Visitor\n                     else\n                         tmp.writeUTF8(c);\n                 }\n-                q = (utf8_t *)tmp.data;\n-                qlen = tmp.offset;\n+                q = (utf8_t *)tmp.slice().ptr;\n+                qlen = tmp.length();\n                 break;\n \n             case 4:\n@@ -730,8 +730,8 @@ class Mangler : public Visitor\n                     else\n                         tmp.writeUTF8(c);\n                 }\n-                q = (utf8_t *)tmp.data;\n-                qlen = tmp.offset;\n+                q = (utf8_t *)tmp.slice().ptr;\n+                qlen = tmp.length();\n                 break;\n \n             default:\n@@ -741,15 +741,15 @@ class Mangler : public Visitor\n         buf->writeByte(m);\n         buf->printf(\"%d_\", (int)qlen); // nbytes <= 11\n \n-        for (utf8_t *p = (utf8_t *)buf->data + buf->offset, *pend = p + 2 * qlen;\n+        for (utf8_t *p = (utf8_t *)buf->slice().ptr + buf->length(), *pend = p + 2 * qlen;\n              p < pend; p += 2, ++q)\n         {\n             utf8_t hi = *q >> 4 & 0xF;\n             p[0] = (utf8_t)(hi < 10 ? hi + '0' : hi - 10 + 'a');\n             utf8_t lo = *q & 0xF;\n             p[1] = (utf8_t)(lo < 10 ? lo + '0' : lo - 10 + 'a');\n         }\n-        buf->offset += 2 * qlen;\n+        buf->setsize(buf->length() + 2 * qlen);\n     }\n \n     void visit(ArrayLiteralExp *e)"}, {"sha": "8f09f2db8561dbc66562b0e2cd934aff69dd0374", "filename": "gcc/d/dmd/dmodule.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdmodule.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -202,7 +202,7 @@ static void checkModFileAlias(OutBuffer *buf, OutBuffer *dotmods,\n         const char *m = (*ms)[j];\n         const char *q = strchr(m, '=');\n         assert(q);\n-        if (dotmods->offset <= (size_t)(q - m) && memcmp(dotmods->peekChars(), m, q - m) == 0)\n+        if (dotmods->length() <= (size_t)(q - m) && memcmp(dotmods->peekChars(), m, q - m) == 0)\n         {\n             buf->reset();\n             size_t qlen = strlen(q + 1);\n@@ -398,7 +398,7 @@ Module *Module::parse()\n                         dbuf.writeByte(u);\n                 }\n                 dbuf.writeByte(0);              // add 0 as sentinel for scanner\n-                buflen = dbuf.offset - 1;       // don't include sentinel in count\n+                buflen = dbuf.length() - 1;     // don't include sentinel in count\n                 buf = (utf8_t *) dbuf.extractData();\n             }\n             else\n@@ -451,7 +451,7 @@ Module *Module::parse()\n                         dbuf.writeByte(u);\n                 }\n                 dbuf.writeByte(0);              // add 0 as sentinel for scanner\n-                buflen = dbuf.offset - 1;       // don't include sentinel in count\n+                buflen = dbuf.length() - 1;     // don't include sentinel in count\n                 buf = (utf8_t *) dbuf.extractData();\n             }\n         }"}, {"sha": "92783b89ab36aacf2d7bceb023f4081765598c51", "filename": "gcc/d/dmd/doc.c", "status": "modified", "additions": 72, "deletions": 72, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdoc.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -365,7 +365,7 @@ void gendocfile(Module *m)\n             mbuf.write(file.buffer, file.len);\n         }\n     }\n-    DocComment::parseMacros(&m->escapetable, &m->macrotable, (utf8_t *)mbuf.data, mbuf.offset);\n+    DocComment::parseMacros(&m->escapetable, &m->macrotable, (utf8_t *)mbuf.slice().ptr, mbuf.length());\n \n     Scope *sc = Scope::createGlobal(m);      // create root scope\n \n@@ -427,25 +427,25 @@ void gendocfile(Module *m)\n         emitMemberComments(m, &buf, sc);\n     }\n \n-    //printf(\"BODY= '%.*s'\\n\", buf.offset, buf.data);\n-    Macro::define(&m->macrotable, (const utf8_t *)\"BODY\", 4, (const utf8_t *)buf.data, buf.offset);\n+    //printf(\"BODY= '%.*s'\\n\", buf.length(), buf.slice().ptr);\n+    Macro::define(&m->macrotable, (const utf8_t *)\"BODY\", 4, (const utf8_t *)buf.slice().ptr, buf.length());\n \n     OutBuffer buf2;\n     buf2.writestring(\"$(DDOC)\\n\");\n-    size_t end = buf2.offset;\n+    size_t end = buf2.length();\n     m->macrotable->expand(&buf2, 0, &end, NULL, 0);\n \n     /* Remove all the escape sequences from buf2,\n      * and make CR-LF the newline.\n      */\n     {\n         buf.setsize(0);\n-        buf.reserve(buf2.offset);\n-        utf8_t *p = (utf8_t *)buf2.data;\n-        for (size_t j = 0; j < buf2.offset; j++)\n+        buf.reserve(buf2.length());\n+        utf8_t *p = (utf8_t *)buf2.slice().ptr;\n+        for (size_t j = 0; j < buf2.length(); j++)\n         {\n             utf8_t c = p[j];\n-            if (c == 0xFF && j + 1 < buf2.offset)\n+            if (c == 0xFF && j + 1 < buf2.length())\n             {\n                 j++;\n                 continue;\n@@ -455,7 +455,7 @@ void gendocfile(Module *m)\n             else if (c == '\\r')\n             {\n                 buf.writestring(\"\\r\\n\");\n-                if (j + 1 < buf2.offset && p[j + 1] == '\\n')\n+                if (j + 1 < buf2.length() && p[j + 1] == '\\n')\n                 {\n                     j++;\n                 }\n@@ -467,7 +467,7 @@ void gendocfile(Module *m)\n \n     // Transfer image to file\n     assert(m->docfile);\n-    m->docfile->setbuffer(buf.data, buf.offset);\n+    m->docfile->setbuffer(buf.slice().ptr, buf.length());\n     m->docfile->ref = 1;\n     ensurePathToNameExists(Loc(), m->docfile->toChars());\n     writeFile(m->loc, m->docfile);\n@@ -482,9 +482,9 @@ void gendocfile(Module *m)\n  */\n void escapeDdocString(OutBuffer *buf, size_t start)\n {\n-    for (size_t u = start; u < buf->offset; u++)\n+    for (size_t u = start; u < buf->length(); u++)\n     {\n-        utf8_t c = buf->data[u];\n+        utf8_t c = buf->slice().ptr[u];\n         switch(c)\n         {\n             case '$':\n@@ -518,9 +518,9 @@ void escapeStrayParenthesis(Loc loc, OutBuffer *buf, size_t start)\n {\n     unsigned par_open = 0;\n \n-    for (size_t u = start; u < buf->offset; u++)\n+    for (size_t u = start; u < buf->length(); u++)\n     {\n-        utf8_t c = buf->data[u];\n+        utf8_t c = buf->slice().ptr[u];\n         switch(c)\n         {\n             case '(':\n@@ -546,10 +546,10 @@ void escapeStrayParenthesis(Loc loc, OutBuffer *buf, size_t start)\n     if (par_open)                       // if any unmatched lparens\n     {\n         par_open = 0;\n-        for (size_t u = buf->offset; u > start;)\n+        for (size_t u = buf->length(); u > start;)\n         {\n             u--;\n-            utf8_t c = buf->data[u];\n+            utf8_t c = buf->slice().ptr[u];\n             switch(c)\n             {\n                 case ')':\n@@ -699,9 +699,9 @@ void emitMemberComments(ScopeDsymbol *sds, OutBuffer *buf, Scope *sc)\n     else if (sds->isModule())\n         m = \"$(DDOC_MODULE_MEMBERS \";\n \n-    size_t offset1 = buf->offset;         // save starting offset\n+    size_t offset1 = buf->length();         // save starting offset\n     buf->writestring(m);\n-    size_t offset2 = buf->offset;         // to see if we write anything\n+    size_t offset2 = buf->length();         // to see if we write anything\n \n     sc = sc->push(sds);\n \n@@ -720,11 +720,11 @@ void emitMemberComments(ScopeDsymbol *sds, OutBuffer *buf, Scope *sc)\n \n     sc->pop();\n \n-    if (buf->offset == offset2)\n+    if (buf->length() == offset2)\n     {\n         /* Didn't write out any members, so back out last write\n          */\n-        buf->offset = offset1;\n+        buf->setsize(offset1);\n     }\n     else\n         buf->writestring(\")\\n\");\n@@ -780,15 +780,15 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n \n                     if (i == 0)\n                     {\n-                        size_t o = buf->offset;\n+                        size_t o = buf->length();\n                         toDocBuffer(sx, buf, sc);\n                         highlightCode(sc, sx, buf, o);\n                         continue;\n                     }\n \n                     buf->writestring(\"$(DDOC_DITTO \");\n                     {\n-                        size_t o = buf->offset;\n+                        size_t o = buf->length();\n                         toDocBuffer(sx, buf, sc);\n                         highlightCode(sc, sx, buf, o);\n                     }\n@@ -804,7 +804,7 @@ void emitComment(Dsymbol *s, OutBuffer *buf, Scope *sc)\n                         emitMemberComments(sds, buf, sc);\n                 }\n                 buf->writestring(ddoc_decl_dd_e);\n-                //printf(\"buf.2 = [[%.*s]]\\n\", buf->offset - o0, buf->data + o0);\n+                //printf(\"buf.2 = [[%.*s]]\\n\", buf->length() - o0, buf->slice().ptr + o0);\n             }\n \n             if (s)\n@@ -1454,9 +1454,9 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n             loc = m->md->loc;\n     }\n \n-    size_t offset1 = buf->offset;\n+    size_t offset1 = buf->length();\n     buf->writestring(\"$(DDOC_SECTIONS \");\n-    size_t offset2 = buf->offset;\n+    size_t offset2 = buf->length();\n \n     for (size_t i = 0; i < sections.length; i++)\n     {\n@@ -1468,7 +1468,7 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n         if (!sec->namelen && i == 0)\n         {\n             buf->writestring(\"$(DDOC_SUMMARY \");\n-            size_t o = buf->offset;\n+            size_t o = buf->length();\n             buf->write(sec->body, sec->bodylen);\n             escapeStrayParenthesis(loc, buf, o);\n             highlightText(sc, a, buf, o);\n@@ -1495,7 +1495,7 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n \n             buf->writestring(\"$(DDOC_EXAMPLES \");\n \n-            size_t o = buf->offset;\n+            size_t o = buf->length();\n             buf->writestring((const char *)c);\n \n             if (utd->codedoc)\n@@ -1512,11 +1512,11 @@ void DocComment::writeSections(Scope *sc, Dsymbols *a, OutBuffer *buf)\n         }\n     }\n \n-    if (buf->offset == offset2)\n+    if (buf->length() == offset2)\n     {\n         /* Didn't write out any sections, so back out last write\n          */\n-        buf->offset = offset1;\n+        buf->setsize(offset1);\n         buf->writestring(\"$(DDOC_BLANKLINE)\\n\");\n     }\n     else\n@@ -1553,7 +1553,7 @@ void Section::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffer *bu\n \n             // Replace _ characters with spaces\n             buf->writestring(\"$(DDOC_SECTION_H \");\n-            size_t o = buf->offset;\n+            size_t o = buf->length();\n             for (size_t u = 0; u < namelen; u++)\n             {\n                 utf8_t c = name[u];\n@@ -1567,7 +1567,7 @@ void Section::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffer *bu\n         buf->writestring(\"$(DDOC_DESCRIPTION \");\n     }\n   L1:\n-    size_t o = buf->offset;\n+    size_t o = buf->length();\n     buf->write(body, bodylen);\n     escapeStrayParenthesis(loc, buf, o);\n     highlightText(sc, a, buf, o);\n@@ -1655,7 +1655,7 @@ void ParamSection::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffe\n             {\n                 buf->writestring(\"$(DDOC_PARAM_ID \");\n                 {\n-                    size_t o = buf->offset;\n+                    size_t o = buf->length();\n                     Parameter *fparam = isFunctionParameter(a, namestart, namelen);\n                     if (!fparam)\n                     {\n@@ -1692,7 +1692,7 @@ void ParamSection::write(Loc loc, DocComment *, Scope *sc, Dsymbols *a, OutBuffe\n \n                 buf->writestring(\"$(DDOC_PARAM_DESC \");\n                 {\n-                    size_t o = buf->offset;\n+                    size_t o = buf->length();\n                     buf->write(textstart, textlen);\n                     escapeStrayParenthesis(loc, buf, o);\n                     highlightText(sc, a, buf, o);\n@@ -1999,12 +1999,12 @@ const utf8_t *skipwhitespace(const utf8_t *p)\n \n size_t skiptoident(OutBuffer *buf, size_t i)\n {\n-    while (i < buf->offset)\n+    while (i < buf->length())\n     {\n         dchar_t c;\n \n         size_t oi = i;\n-        if (utf_decodeChar((utf8_t *)buf->data, buf->offset, &i, &c))\n+        if (utf_decodeChar((utf8_t *)buf->slice().ptr, buf->length(), &i, &c))\n         {\n             /* Ignore UTF errors, but still consume input\n              */\n@@ -2029,12 +2029,12 @@ size_t skiptoident(OutBuffer *buf, size_t i)\n \n size_t skippastident(OutBuffer *buf, size_t i)\n {\n-    while (i < buf->offset)\n+    while (i < buf->length())\n     {\n         dchar_t c;\n \n         size_t oi = i;\n-        if (utf_decodeChar((utf8_t *)buf->data, buf->offset, &i, &c))\n+        if (utf_decodeChar((utf8_t *)buf->slice().ptr, buf->length(), &i, &c))\n         {\n             /* Ignore UTF errors, but still consume input\n              */\n@@ -2064,8 +2064,8 @@ size_t skippastident(OutBuffer *buf, size_t i)\n \n size_t skippastURL(OutBuffer *buf, size_t i)\n {\n-    size_t length = buf->offset - i;\n-    utf8_t *p = (utf8_t *)&buf->data[i];\n+    size_t length = buf->length() - i;\n+    utf8_t *p = (utf8_t *)&buf->slice().ptr[i];\n     size_t j;\n     unsigned sawdot = 0;\n \n@@ -2236,9 +2236,9 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n \n     size_t iLineStart = offset;\n \n-    for (size_t i = offset; i < buf->offset; i++)\n+    for (size_t i = offset; i < buf->length(); i++)\n     {\n-        utf8_t c = buf->data[i];\n+        utf8_t c = buf->slice().ptr[i];\n \n      Lcont:\n         switch (c)\n@@ -2265,7 +2265,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                 }\n \n                 if (!sc->_module->isDocFile &&\n-                    !inCode && i == iLineStart && i + 1 < buf->offset)    // if \"\\n\\n\"\n+                    !inCode && i == iLineStart && i + 1 < buf->length())    // if \"\\n\\n\"\n                 {\n                     static const char blankline[] = \"$(DDOC_BLANKLINE)\\n\";\n \n@@ -2280,7 +2280,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                 leadingBlank = 0;\n                 if (inCode)\n                     break;\n-                utf8_t *p = (utf8_t *)&buf->data[i];\n+                utf8_t *p = (utf8_t *)&buf->slice().ptr[i];\n                 const char *se = sc->_module->escapetable->escapeChar('<');\n                 if (se && strcmp(se, \"&lt;\") == 0)\n                 {\n@@ -2292,7 +2292,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                         p += 4;\n                         while (1)\n                         {\n-                            if (j == buf->offset)\n+                            if (j == buf->length())\n                                 goto L1;\n                             if (p[0] == '-' && p[1] == '-' && p[2] == '>')\n                             {\n@@ -2312,7 +2312,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                         p += 2;\n                         while (1)\n                         {\n-                            if (j == buf->offset)\n+                            if (j == buf->length())\n                                 break;\n                             if (p[0] == '>')\n                             {\n@@ -2357,7 +2357,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                 leadingBlank = 0;\n                 if (inCode)\n                     break;\n-                utf8_t *p = (utf8_t *)&buf->data[i];\n+                utf8_t *p = (utf8_t *)&buf->slice().ptr[i];\n                 if (p[1] == '#' || isalpha(p[1]))\n                     break;                      // already a character entity\n                 // Replace '&' with '&amp;' character entity\n@@ -2380,7 +2380,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n \n                     OutBuffer codebuf;\n \n-                    codebuf.write(buf->data + iCodeStart + 1, i - (iCodeStart + 1));\n+                    codebuf.write(buf->slice().ptr + iCodeStart + 1, i - (iCodeStart + 1));\n \n                     // escape the contents, but do not perform highlighting except for DDOC_PSYMBOL\n                     highlightCode(sc, a, &codebuf, 0);\n@@ -2389,7 +2389,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n \n                     static const char pre[] = \"$(DDOC_BACKQUOTED \";\n                     i = buf->insert(iCodeStart, pre, strlen(pre));\n-                    i = buf->insert(i, (char *)codebuf.data, codebuf.offset);\n+                    i = buf->insert(i, (char *)codebuf.slice().ptr, codebuf.length());\n                     i = buf->insert(i, \")\", 1);\n \n                     i--; // point to the ending ) so when the for loop does i++, it will see the next character\n@@ -2425,9 +2425,9 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                     while (1)\n                     {\n                         ++i;\n-                        if (i >= buf->offset)\n+                        if (i >= buf->length())\n                             break;\n-                        c = buf->data[i];\n+                        c = buf->slice().ptr[i];\n                         if (c == '\\n')\n                         {\n                             eollen = 1;\n@@ -2436,9 +2436,9 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                         if (c == '\\r')\n                         {\n                             eollen = 1;\n-                            if (i + 1 >= buf->offset)\n+                            if (i + 1 >= buf->length())\n                                 break;\n-                            if (buf->data[i + 1] == '\\n')\n+                            if (buf->slice().ptr[i + 1] == '\\n')\n                             {\n                                 eollen = 2;\n                                 break;\n@@ -2470,25 +2470,25 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                         // The code section is from iCodeStart to i\n                         OutBuffer codebuf;\n \n-                        codebuf.write(buf->data + iCodeStart, i - iCodeStart);\n+                        codebuf.write(buf->slice().ptr + iCodeStart, i - iCodeStart);\n                         codebuf.writeByte(0);\n \n                         // Remove leading indentations from all lines\n                         bool lineStart = true;\n-                        utf8_t *endp = (utf8_t *)codebuf.data + codebuf.offset;\n-                        for (utf8_t *p = (utf8_t *)codebuf.data; p < endp; )\n+                        utf8_t *endp = (utf8_t *)codebuf.slice().ptr + codebuf.length();\n+                        for (utf8_t *p = (utf8_t *)codebuf.slice().ptr; p < endp; )\n                         {\n                             if (lineStart)\n                             {\n                                 size_t j = codeIndent;\n                                 utf8_t *q = p;\n                                 while (j-- > 0 && q < endp && isIndentWS(q))\n                                     ++q;\n-                                codebuf.remove(p - (utf8_t *)codebuf.data, q - p);\n-                                assert((utf8_t *)codebuf.data <= p);\n-                                assert(p < (utf8_t *)codebuf.data + codebuf.offset);\n+                                codebuf.remove(p - (utf8_t *)codebuf.slice().ptr, q - p);\n+                                assert((utf8_t *)codebuf.slice().ptr <= p);\n+                                assert(p < (utf8_t *)codebuf.slice().ptr + codebuf.length());\n                                 lineStart = false;\n-                                endp = (utf8_t *)codebuf.data + codebuf.offset; // update\n+                                endp = (utf8_t *)codebuf.slice().ptr + codebuf.length(); // update\n                                 continue;\n                             }\n                             if (*p == '\\n')\n@@ -2498,7 +2498,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n \n                         highlightCode2(sc, a, &codebuf, 0);\n                         buf->remove(iCodeStart, i - iCodeStart);\n-                        i = buf->insert(iCodeStart, codebuf.data, codebuf.offset);\n+                        i = buf->insert(iCodeStart, codebuf.slice().ptr, codebuf.length());\n                         i = buf->insert(i, (const char *)\")\\n\", 2);\n                         i -= 2; // in next loop, c should be '\\n'\n                     }\n@@ -2521,7 +2521,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                 if (sc->_module->isDocFile || inCode)\n                     break;\n \n-                utf8_t *start = (utf8_t *)buf->data + i;\n+                utf8_t *start = (utf8_t *)buf->slice().ptr + i;\n                 if (isIdStart(start))\n                 {\n                     size_t j = skippastident(buf, i);\n@@ -2541,7 +2541,7 @@ void highlightText(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n                     // leading '_' means no highlight unless it's a reserved symbol name\n                     if (c == '_' &&\n                         (i == 0 || !isdigit(*(start - 1))) &&\n-                        (i == buf->offset - 1 || !isReservedName(start, len)))\n+                        (i == buf->length() - 1 || !isReservedName(start, len)))\n                     {\n                         buf->remove(i, 1);\n                         i = j - 1;\n@@ -2582,8 +2582,8 @@ void highlightCode(Scope *sc, Dsymbol *s, OutBuffer *buf, size_t offset)\n     //printf(\"highlightCode(s = %s '%s')\\n\", s->kind(), s->toChars());\n     OutBuffer ancbuf;\n     emitAnchor(&ancbuf, s, sc);\n-    buf->insert(offset, (char *)ancbuf.data, ancbuf.offset);\n-    offset += ancbuf.offset;\n+    buf->insert(offset, (char *)ancbuf.slice().ptr, ancbuf.length());\n+    offset += ancbuf.length();\n \n     Dsymbols a;\n     a.push(s);\n@@ -2597,9 +2597,9 @@ void highlightCode(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n {\n     //printf(\"highlightCode(a = '%s')\\n\", a->toChars());\n \n-    for (size_t i = offset; i < buf->offset; i++)\n+    for (size_t i = offset; i < buf->length(); i++)\n     {\n-        utf8_t c = buf->data[i];\n+        utf8_t c = buf->slice().ptr[i];\n         const char *se = sc->_module->escapetable->escapeChar(c);\n         if (se)\n         {\n@@ -2610,7 +2610,7 @@ void highlightCode(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n             continue;\n         }\n \n-        utf8_t *start = (utf8_t *)buf->data + i;\n+        utf8_t *start = (utf8_t *)buf->slice().ptr + i;\n         if (isIdStart(start))\n         {\n             size_t j = skippastident(buf, i);\n@@ -2656,12 +2656,12 @@ void highlightCode3(Scope *sc, OutBuffer *buf, const utf8_t *p, const utf8_t *pe\n void highlightCode2(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n {\n     unsigned errorsave = global.errors;\n-    Lexer lex(NULL, (utf8_t *)buf->data, 0, buf->offset - 1, 0, 1);\n+    Lexer lex(NULL, (utf8_t *)buf->slice().ptr, 0, buf->length() - 1, 0, 1);\n     OutBuffer res;\n-    const utf8_t *lastp = (utf8_t *)buf->data;\n+    const utf8_t *lastp = (utf8_t *)buf->slice().ptr;\n \n-    //printf(\"highlightCode2('%.*s')\\n\", buf->offset - 1, buf->data);\n-    res.reserve(buf->offset);\n+    //printf(\"highlightCode2('%.*s')\\n\", buf->length() - 1, buf->slice().ptr);\n+    res.reserve(buf->length());\n     while (1)\n     {\n         Token tok;\n@@ -2705,7 +2705,7 @@ void highlightCode2(Scope *sc, Dsymbols *a, OutBuffer *buf, size_t offset)\n         if (highlight)\n         {\n             res.writestring(highlight);\n-            size_t o = res.offset;\n+            size_t o = res.length();\n             highlightCode3(sc, &res, tok.ptr, lex.p);\n             if (tok.value == TOKcomment || tok.value == TOKstring)\n                 escapeDdocString(&res, o);  // Bugzilla 7656, 7715, and 10519"}, {"sha": "5fa509be9ca5e3df0e0d13719b3c8bf54408a592", "filename": "gcc/d/dmd/dsymbol.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdsymbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fdsymbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fdsymbol.h?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -10,7 +10,7 @@\n \n #pragma once\n \n-#include \"root/root.h\"\n+#include \"root/port.h\"\n #include \"root/stringtable.h\"\n #include \"ast_node.h\"\n #include \"globals.h\""}, {"sha": "2ad75edb27ce2b960691ad4ced6c5f5ddfafc81c", "filename": "gcc/d/dmd/expression.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fexpression.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fexpression.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fexpression.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -4430,7 +4430,7 @@ StringExp *ArrayLiteralExp::toStringExp()\n         else if (sz == 2) { prefix = 'w'; buf.writeword(0); }\n         else              { prefix = 'd'; buf.write4(0); }\n \n-        const size_t len = buf.offset / sz - 1;\n+        const size_t len = buf.length() / sz - 1;\n         StringExp *se = new StringExp(loc, buf.extractData(), len, prefix);\n         se->sz = sz;\n         se->type = type;"}, {"sha": "22ae9c8253e7b587525d1b2b75a1f9e9155394d0", "filename": "gcc/d/dmd/hdrgen.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fhdrgen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fhdrgen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fhdrgen.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -58,7 +58,7 @@ void genhdrfile(Module *m)\n     toCBuffer(m, &buf, &hgs);\n \n     // Transfer image to file\n-    m->hdrfile->setbuffer(buf.data, buf.offset);\n+    m->hdrfile->setbuffer(buf.slice().ptr, buf.length());\n     buf.extractData();\n \n     ensurePathToNameExists(Loc(), m->hdrfile->toChars());\n@@ -2303,7 +2303,7 @@ class PrettyPrintVisitor : public Visitor\n                     /* fall through */\n                 case Tchar:\n                 {\n-                    size_t o = buf->offset;\n+                    size_t o = buf->length();\n                     if (v == '\\'')\n                         buf->writestring(\"'\\\\''\");\n                     else if (isprint((int)v) && v != '\\\\')\n@@ -2478,7 +2478,7 @@ class PrettyPrintVisitor : public Visitor\n     void visit(StringExp *e)\n     {\n         buf->writeByte('\"');\n-        size_t o = buf->offset;\n+        size_t o = buf->length();\n         for (size_t i = 0; i < e->len; i++)\n         {\n             unsigned c = e->charAt(i);"}, {"sha": "7da127eab5450119f8d65f6669f8526bbf1ddf28", "filename": "gcc/d/dmd/json.c", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fjson.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fjson.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fjson.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -43,18 +43,18 @@ class ToJsonVisitor : public Visitor\n \n     void indent()\n     {\n-        if (buf->offset >= 1 &&\n-            buf->data[buf->offset - 1] == '\\n')\n+        if (buf->length() >= 1 &&\n+            buf->slice().ptr[buf->length() - 1] == '\\n')\n             for (int i = 0; i < indentLevel; i++)\n                 buf->writeByte(' ');\n     }\n \n     void removeComma()\n     {\n-        if (buf->offset >= 2 &&\n-            buf->data[buf->offset - 2] == ',' &&\n-            (buf->data[buf->offset - 1] == '\\n' || buf->data[buf->offset - 1] == ' '))\n-            buf->offset -= 2;\n+        if (buf->length() >= 2 &&\n+            buf->slice().ptr[buf->length() - 2] == ',' &&\n+            (buf->slice().ptr[buf->length() - 1] == '\\n' || buf->slice().ptr[buf->length() - 1] == ' '))\n+            buf->setsize(buf->length() - 2);\n     }\n \n     void comma()\n@@ -181,12 +181,12 @@ class ToJsonVisitor : public Visitor\n     {\n         indentLevel--;\n         removeComma();\n-        if (buf->offset >= 2 &&\n-            buf->data[buf->offset - 2] == '[' &&\n-            buf->data[buf->offset - 1] == '\\n')\n-            buf->offset -= 1;\n-        else if (!(buf->offset >= 1 &&\n-            buf->data[buf->offset - 1] == '['))\n+        if (buf->length() >= 2 &&\n+            buf->slice().ptr[buf->length() - 2] == '[' &&\n+            buf->slice().ptr[buf->length() - 1] == '\\n')\n+            buf->setsize(buf->length() - 1);\n+        else if (!(buf->length() >= 1 &&\n+            buf->slice().ptr[buf->length() - 1] == '['))\n         {\n             buf->writestring(\"\\n\");\n             indent();\n@@ -209,10 +209,10 @@ class ToJsonVisitor : public Visitor\n     {\n         indentLevel--;\n         removeComma();\n-        if (buf->offset >= 2 &&\n-            buf->data[buf->offset - 2] == '{' &&\n-            buf->data[buf->offset - 1] == '\\n')\n-            buf->offset -= 1;\n+        if (buf->length() >= 2 &&\n+            buf->slice().ptr[buf->length() - 2] == '{' &&\n+            buf->slice().ptr[buf->length() - 1] == '\\n')\n+            buf->setsize(buf->length() - 1);\n         else\n         {\n             buf->writestring(\"\\n\");"}, {"sha": "db989b0b528f8fbe81184b83e38ea0a11ef24518", "filename": "gcc/d/dmd/lexer.c", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Flexer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Flexer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Flexer.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -1111,10 +1111,10 @@ TOK Lexer::wysiwygStringConstant(Token *t, int tc)\n             case '`':\n                 if (c == tc)\n                 {\n-                    t->len = (unsigned)stringbuffer.offset;\n+                    t->len = (unsigned)stringbuffer.length();\n                     stringbuffer.writeByte(0);\n-                    t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.offset);\n-                    memcpy(t->ustring, stringbuffer.data, stringbuffer.offset);\n+                    t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.length());\n+                    memcpy(t->ustring, stringbuffer.slice().ptr, stringbuffer.length());\n                     stringPostfix(t);\n                     return TOKstring;\n                 }\n@@ -1183,10 +1183,10 @@ TOK Lexer::hexStringConstant(Token *t)\n                 {   error(\"odd number (%d) of hex characters in hex string\", n);\n                     stringbuffer.writeByte(v);\n                 }\n-                t->len = (unsigned)stringbuffer.offset;\n+                t->len = (unsigned)stringbuffer.length();\n                 stringbuffer.writeByte(0);\n-                t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.offset);\n-                memcpy(t->ustring, stringbuffer.data, stringbuffer.offset);\n+                t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.length());\n+                memcpy(t->ustring, stringbuffer.slice().ptr, stringbuffer.length());\n                 stringPostfix(t);\n                 return TOKxstring;\n \n@@ -1371,10 +1371,10 @@ TOK Lexer::delimitedStringConstant(Token *t)\n         error(\"delimited string must end in %s\\\"\", hereid->toChars());\n     else\n         error(\"delimited string must end in %c\\\"\", delimright);\n-    t->len = (unsigned)stringbuffer.offset;\n+    t->len = (unsigned)stringbuffer.length();\n     stringbuffer.writeByte(0);\n-    t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.offset);\n-    memcpy(t->ustring, stringbuffer.data, stringbuffer.offset);\n+    t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.length());\n+    memcpy(t->ustring, stringbuffer.slice().ptr, stringbuffer.length());\n     stringPostfix(t);\n     return TOKstring;\n }\n@@ -1473,10 +1473,10 @@ TOK Lexer::escapeStringConstant(Token *t)\n                 break;\n \n             case '\"':\n-                t->len = (unsigned)stringbuffer.offset;\n+                t->len = (unsigned)stringbuffer.length();\n                 stringbuffer.writeByte(0);\n-                t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.offset);\n-                memcpy(t->ustring, stringbuffer.data, stringbuffer.offset);\n+                t->ustring = (utf8_t *)mem.xmalloc(stringbuffer.length());\n+                memcpy(t->ustring, stringbuffer.slice().ptr, stringbuffer.length());\n                 stringPostfix(t);\n                 return TOKstring;\n \n@@ -1997,7 +1997,7 @@ TOK Lexer::inreal(Token *t)\n     }\n \n     stringbuffer.writeByte(0);\n-    const char *sbufptr = (char *)stringbuffer.data;\n+    const char *sbufptr = (char *)stringbuffer.slice().ptr;\n     TOK result;\n     bool isOutOfRange = false;\n     t->floatvalue = (isWellformedString ? CTFloat::parse(sbufptr, &isOutOfRange) : CTFloat::zero);\n@@ -2049,7 +2049,7 @@ TOK Lexer::inreal(Token *t)\n     if (isOutOfRange && !isLong)\n     {\n         const char *suffix = (result == TOKfloat32v || result == TOKimaginary32v) ? \"f\" : \"\";\n-        error(scanloc, \"number '%s%s' is not representable\", (char *)stringbuffer.data, suffix);\n+        error(scanloc, \"number '%s%s' is not representable\", (char *)stringbuffer.slice().ptr, suffix);\n     }\n     return result;\n }\n@@ -2138,7 +2138,7 @@ void Lexer::poundLine()\n \n                         case '\"':\n                             stringbuffer.writeByte(0);\n-                            filespec = mem.xstrdup((char *)stringbuffer.data);\n+                            filespec = mem.xstrdup((char *)stringbuffer.slice().ptr);\n                             p++;\n                             break;\n \n@@ -2203,6 +2203,14 @@ unsigned Lexer::decodeUTF()\n     return u;\n }\n \n+static void trimTrailingWhitespace(OutBuffer &buf)\n+{\n+    const unsigned char *s = buf.slice().ptr;\n+    size_t len = buf.length();\n+    while (len && (s[len - 1] == ' ' || s[len - 1] == '\\t'))\n+        --len;\n+    buf.setsize(len);\n+}\n \n /***************************************************\n  * Parse doc comment embedded between t->ptr and p.\n@@ -2287,8 +2295,7 @@ void Lexer::getDocComment(Token *t, unsigned lineComment)\n                 {   linestart = 0;\n                     /* Trim preceding whitespace up to preceding \\n\n                      */\n-                    while (buf.offset && (buf.data[buf.offset - 1] == ' ' || buf.data[buf.offset - 1] == '\\t'))\n-                        buf.offset--;\n+                    trimTrailingWhitespace(buf);\n                     continue;\n                 }\n                 break;\n@@ -2324,24 +2331,21 @@ void Lexer::getDocComment(Token *t, unsigned lineComment)\n \n                 /* Trim trailing whitespace\n                  */\n-                while (buf.offset && (buf.data[buf.offset - 1] == ' ' || buf.data[buf.offset - 1] == '\\t'))\n-                    buf.offset--;\n-\n+                trimTrailingWhitespace(buf);\n                 break;\n         }\n         buf.writeByte(c);\n     }\n \n     /* Trim trailing whitespace (if the last line does not have newline)\n      */\n-    if (buf.offset && (buf.data[buf.offset - 1] == ' ' || buf.data[buf.offset - 1] == '\\t'))\n+    if (buf.length() && (buf.slice().ptr[buf.length() - 1] == ' ' || buf.slice().ptr[buf.length() - 1] == '\\t'))\n     {\n-        while (buf.offset && (buf.data[buf.offset - 1] == ' ' || buf.data[buf.offset - 1] == '\\t'))\n-            buf.offset--;\n+        trimTrailingWhitespace(buf);\n     }\n \n     // Always end with a newline\n-    if (!buf.offset || buf.data[buf.offset - 1] != '\\n')\n+    if (!buf.length() || buf.slice().ptr[buf.length() - 1] != '\\n')\n         buf.writeByte('\\n');\n \n     buf.writeByte(0);\n@@ -2354,7 +2358,7 @@ void Lexer::getDocComment(Token *t, unsigned lineComment)\n \n     // Combine with previous doc comment, if any\n     if (*dc)\n-        *dc = combineComments(*dc, (utf8_t *)buf.data);\n+        *dc = combineComments(*dc, (utf8_t *)buf.slice().ptr);\n     else\n         *dc = (utf8_t *)buf.extractData();\n }"}, {"sha": "26710b4771b5bb374b30c56671fce16590ba1d08", "filename": "gcc/d/dmd/macro.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fmacro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fmacro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmacro.h?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -11,7 +11,7 @@\n #pragma once\n \n #include \"root/dsystem.h\"\n-#include \"root/root.h\"\n+#include \"root/port.h\"\n \n \n struct Macro"}, {"sha": "de39ecb02b282a512a21bd2735f5e859b81cd2e3", "filename": "gcc/d/dmd/mtype.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fmtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Fmtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Fmtype.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -1628,7 +1628,7 @@ Type *Type::merge()\n \n         mangleToBuffer(this, &buf);\n \n-        StringValue *sv = stringtable.update((char *)buf.data, buf.offset);\n+        StringValue *sv = stringtable.update((char *)buf.slice().ptr, buf.length());\n         if (sv->ptrvalue)\n         {\n             t = (Type *) sv->ptrvalue;\n@@ -2304,15 +2304,15 @@ Identifier *Type::getTypeInfoIdent()\n     buf.reserve(32);\n     mangleToBuffer(this, &buf);\n \n-    size_t len = buf.offset;\n+    size_t len = buf.length();\n     buf.writeByte(0);\n \n     // Allocate buffer on stack, fail over to using malloc()\n     char namebuf[128];\n     size_t namelen = 19 + sizeof(len) * 3 + len + 1;\n     char *name = namelen <= sizeof(namebuf) ? namebuf : (char *)mem.xmalloc(namelen);\n \n-    int length = sprintf(name, \"_D%lluTypeInfo_%s6__initZ\", (unsigned long long) 9 + len, buf.data);\n+    int length = sprintf(name, \"_D%lluTypeInfo_%s6__initZ\", (unsigned long long) 9 + len, buf.slice().ptr);\n     //printf(\"%p, deco = %s, name = %s\\n\", this, deco, name);\n     assert(0 < length && (size_t)length < namelen);     // don't overflow the buffer\n "}, {"sha": "50b67404062dc1e171b89e5e06b49beea2d304dc", "filename": "gcc/d/dmd/root/filename.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Ffilename.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -8,7 +8,7 @@\n \n #include \"dsystem.h\"\n #include \"filename.h\"\n-\n+#include \"port.h\"\n #include \"outbuffer.h\"\n #include \"array.h\"\n #include \"file.h\"\n@@ -111,7 +111,7 @@ Strings *FileName::splitPath(const char *path)\n                     {\n                         char *home = getenv(\"HOME\");\n                         // Expand ~ only if it is prefixing the rest of the path.\n-                        if (!buf.offset && p[1] == '/' && home)\n+                        if (!buf.length() && p[1] == '/' && home)\n                             buf.writestring(home);\n                         else\n                             buf.writestring(\"~\");\n@@ -125,7 +125,7 @@ Strings *FileName::splitPath(const char *path)\n                 }\n                 break;\n             }\n-            if (buf.offset)             // if path is not empty\n+            if (buf.length())             // if path is not empty\n             {\n                 array->push(buf.extractChars());\n             }"}, {"sha": "8544697a3d5ff192238241c5d56633c5ba293f96", "filename": "gcc/d/dmd/root/outbuffer.c", "status": "modified", "additions": 56, "deletions": 62, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.c?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -14,21 +14,20 @@ char *OutBuffer::extractData()\n {\n     char *p;\n \n-    p = (char *)data;\n-    data = NULL;\n+    p = (char *)data.ptr;\n+    data = DArray<unsigned char>();\n     offset = 0;\n-    size = 0;\n     return p;\n }\n \n void OutBuffer::reserve(size_t nbytes)\n {\n-    //printf(\"OutBuffer::reserve: size = %d, offset = %d, nbytes = %d\\n\", size, offset, nbytes);\n-    if (size - offset < nbytes)\n+    //printf(\"OutBuffer::reserve: size = %d, offset = %d, nbytes = %d\\n\", data.length, offset, nbytes);\n+    if (data.length - offset < nbytes)\n     {\n-        size = (offset + nbytes) * 2;\n-        size = (size + 15) & ~15;\n-        data = (unsigned char *)mem.xrealloc(data, size);\n+        data.length = (offset + nbytes) * 2;\n+        data.length = (data.length + 15) & ~15;\n+        data.ptr = (unsigned char *)mem.xrealloc(data.ptr, data.length);\n     }\n }\n \n@@ -51,22 +50,17 @@ void OutBuffer::write(const void *data, size_t nbytes)\n             reserve(level);\n             for (int i = 0; i < level; i++)\n             {\n-                this->data[offset] = '\\t';\n+                this->data.ptr[offset] = '\\t';\n                 offset++;\n             }\n         }\n         notlinehead = 1;\n     }\n     reserve(nbytes);\n-    memcpy(this->data + offset, data, nbytes);\n+    memcpy(this->data.ptr + offset, data, nbytes);\n     offset += nbytes;\n }\n \n-void OutBuffer::writebstring(utf8_t *string)\n-{\n-    write(string,*string + 1);\n-}\n-\n void OutBuffer::writestring(const char *string)\n {\n     write(string,strlen(string));\n@@ -76,8 +70,8 @@ void OutBuffer::prependstring(const char *string)\n {\n     size_t len = strlen(string);\n     reserve(len);\n-    memmove(data + len, data, offset);\n-    memcpy(data, string, len);\n+    memmove(data.ptr + len, data.ptr, offset);\n+    memcpy(data.ptr, string, len);\n     offset += len;\n }\n \n@@ -102,14 +96,14 @@ void OutBuffer::writeByte(unsigned b)\n             reserve(level);\n             for (int i = 0; i < level; i++)\n             {\n-                this->data[offset] = '\\t';\n+                this->data.ptr[offset] = '\\t';\n                 offset++;\n             }\n         }\n         notlinehead = 1;\n     }\n     reserve(1);\n-    this->data[offset] = (unsigned char)b;\n+    this->data.ptr[offset] = (unsigned char)b;\n     offset++;\n }\n \n@@ -118,47 +112,47 @@ void OutBuffer::writeUTF8(unsigned b)\n     reserve(6);\n     if (b <= 0x7F)\n     {\n-        this->data[offset] = (unsigned char)b;\n+        this->data.ptr[offset] = (unsigned char)b;\n         offset++;\n     }\n     else if (b <= 0x7FF)\n     {\n-        this->data[offset + 0] = (unsigned char)((b >> 6) | 0xC0);\n-        this->data[offset + 1] = (unsigned char)((b & 0x3F) | 0x80);\n+        this->data.ptr[offset + 0] = (unsigned char)((b >> 6) | 0xC0);\n+        this->data.ptr[offset + 1] = (unsigned char)((b & 0x3F) | 0x80);\n         offset += 2;\n     }\n     else if (b <= 0xFFFF)\n     {\n-        this->data[offset + 0] = (unsigned char)((b >> 12) | 0xE0);\n-        this->data[offset + 1] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n-        this->data[offset + 2] = (unsigned char)((b & 0x3F) | 0x80);\n+        this->data.ptr[offset + 0] = (unsigned char)((b >> 12) | 0xE0);\n+        this->data.ptr[offset + 1] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 2] = (unsigned char)((b & 0x3F) | 0x80);\n         offset += 3;\n     }\n     else if (b <= 0x1FFFFF)\n     {\n-        this->data[offset + 0] = (unsigned char)((b >> 18) | 0xF0);\n-        this->data[offset + 1] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n-        this->data[offset + 2] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n-        this->data[offset + 3] = (unsigned char)((b & 0x3F) | 0x80);\n+        this->data.ptr[offset + 0] = (unsigned char)((b >> 18) | 0xF0);\n+        this->data.ptr[offset + 1] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 2] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 3] = (unsigned char)((b & 0x3F) | 0x80);\n         offset += 4;\n     }\n     else if (b <= 0x3FFFFFF)\n     {\n-        this->data[offset + 0] = (unsigned char)((b >> 24) | 0xF8);\n-        this->data[offset + 1] = (unsigned char)(((b >> 18) & 0x3F) | 0x80);\n-        this->data[offset + 2] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n-        this->data[offset + 3] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n-        this->data[offset + 4] = (unsigned char)((b & 0x3F) | 0x80);\n+        this->data.ptr[offset + 0] = (unsigned char)((b >> 24) | 0xF8);\n+        this->data.ptr[offset + 1] = (unsigned char)(((b >> 18) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 2] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 3] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 4] = (unsigned char)((b & 0x3F) | 0x80);\n         offset += 5;\n     }\n     else if (b <= 0x7FFFFFFF)\n     {\n-        this->data[offset + 0] = (unsigned char)((b >> 30) | 0xFC);\n-        this->data[offset + 1] = (unsigned char)(((b >> 24) & 0x3F) | 0x80);\n-        this->data[offset + 2] = (unsigned char)(((b >> 18) & 0x3F) | 0x80);\n-        this->data[offset + 3] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n-        this->data[offset + 4] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n-        this->data[offset + 5] = (unsigned char)((b & 0x3F) | 0x80);\n+        this->data.ptr[offset + 0] = (unsigned char)((b >> 30) | 0xFC);\n+        this->data.ptr[offset + 1] = (unsigned char)(((b >> 24) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 2] = (unsigned char)(((b >> 18) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 3] = (unsigned char)(((b >> 12) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 4] = (unsigned char)(((b >> 6) & 0x3F) | 0x80);\n+        this->data.ptr[offset + 5] = (unsigned char)((b & 0x3F) | 0x80);\n         offset += 6;\n     }\n     else\n@@ -168,8 +162,8 @@ void OutBuffer::writeUTF8(unsigned b)\n void OutBuffer::prependbyte(unsigned b)\n {\n     reserve(1);\n-    memmove(data + 1, data, offset);\n-    data[0] = (unsigned char)b;\n+    memmove(data.ptr + 1, data.ptr, offset);\n+    data.ptr[0] = (unsigned char)b;\n     offset++;\n }\n \n@@ -197,14 +191,14 @@ void OutBuffer::writeword(unsigned w)\n             reserve(level);\n             for (int i = 0; i < level; i++)\n             {\n-                this->data[offset] = '\\t';\n+                this->data.ptr[offset] = '\\t';\n                 offset++;\n             }\n         }\n         notlinehead = 1;\n     }\n     reserve(2);\n-    *(unsigned short *)(this->data + offset) = (unsigned short)w;\n+    *(unsigned short *)(this->data.ptr + offset) = (unsigned short)w;\n     offset += 2;\n }\n \n@@ -213,13 +207,13 @@ void OutBuffer::writeUTF16(unsigned w)\n     reserve(4);\n     if (w <= 0xFFFF)\n     {\n-        *(unsigned short *)(this->data + offset) = (unsigned short)w;\n+        *(unsigned short *)(this->data.ptr + offset) = (unsigned short)w;\n         offset += 2;\n     }\n     else if (w <= 0x10FFFF)\n     {\n-        *(unsigned short *)(this->data + offset) = (unsigned short)((w >> 10) + 0xD7C0);\n-        *(unsigned short *)(this->data + offset + 2) = (unsigned short)((w & 0x3FF) | 0xDC00);\n+        *(unsigned short *)(this->data.ptr + offset) = (unsigned short)((w >> 10) + 0xD7C0);\n+        *(unsigned short *)(this->data.ptr + offset + 2) = (unsigned short)((w & 0x3FF) | 0xDC00);\n         offset += 4;\n     }\n     else\n@@ -240,22 +234,22 @@ void OutBuffer::write4(unsigned w)\n             reserve(level);\n             for (int i = 0; i < level; i++)\n             {\n-                this->data[offset] = '\\t';\n+                this->data.ptr[offset] = '\\t';\n                 offset++;\n             }\n         }\n         notlinehead = 1;\n     }\n     reserve(4);\n-    *(unsigned *)(this->data + offset) = w;\n+    *(unsigned *)(this->data.ptr + offset) = w;\n     offset += 4;\n }\n \n void OutBuffer::write(OutBuffer *buf)\n {\n     if (buf)\n     {   reserve(buf->offset);\n-        memcpy(data + offset, buf->data, buf->offset);\n+        memcpy(data.ptr + offset, buf->data.ptr, buf->offset);\n         offset += buf->offset;\n     }\n }\n@@ -271,7 +265,7 @@ void OutBuffer::write(RootObject *obj)\n void OutBuffer::fill0(size_t nbytes)\n {\n     reserve(nbytes);\n-    memset(data + offset,0,nbytes);\n+    memset(data.ptr + offset,0,nbytes);\n     offset += nbytes;\n }\n \n@@ -286,7 +280,7 @@ void OutBuffer::vprintf(const char *format, va_list args)\n     {\n         reserve(psize);\n #if _WIN32\n-        count = _vsnprintf((char *)data + offset,psize,format,args);\n+        count = _vsnprintf((char *)data.ptr + offset,psize,format,args);\n         if (count != -1)\n             break;\n         psize *= 2;\n@@ -302,7 +296,7 @@ void OutBuffer::vprintf(const char *format, va_list args)\n   of ap is undefined after the call. The application should call\n   va_end(ap) itself afterwards.\n  */\n-        count = vsnprintf((char *)data + offset,psize,format,va);\n+        count = vsnprintf((char *)data.ptr + offset,psize,format,va);\n         va_end(va);\n         if (count == -1)\n             psize *= 2;\n@@ -328,9 +322,9 @@ void OutBuffer::printf(const char *format, ...)\n void OutBuffer::bracket(char left, char right)\n {\n     reserve(2);\n-    memmove(data + 1, data, offset);\n-    data[0] = left;\n-    data[offset + 1] = right;\n+    memmove(data.ptr + 1, data.ptr, offset);\n+    data.ptr[0] = left;\n+    data.ptr[offset + 1] = right;\n     offset += 2;\n }\n \n@@ -352,7 +346,7 @@ size_t OutBuffer::bracket(size_t i, const char *left, size_t j, const char *righ\n void OutBuffer::spread(size_t offset, size_t nbytes)\n {\n     reserve(nbytes);\n-    memmove(data + offset + nbytes, data + offset,\n+    memmove(data.ptr + offset + nbytes, data.ptr + offset,\n         this->offset - offset);\n     this->offset += nbytes;\n }\n@@ -364,29 +358,29 @@ void OutBuffer::spread(size_t offset, size_t nbytes)\n size_t OutBuffer::insert(size_t offset, const void *p, size_t nbytes)\n {\n     spread(offset, nbytes);\n-    memmove(data + offset, p, nbytes);\n+    memmove(data.ptr + offset, p, nbytes);\n     return offset + nbytes;\n }\n \n void OutBuffer::remove(size_t offset, size_t nbytes)\n {\n-    memmove(data + offset, data + offset + nbytes, this->offset - (offset + nbytes));\n+    memmove(data.ptr + offset, data.ptr + offset + nbytes, this->offset - (offset + nbytes));\n     this->offset -= nbytes;\n }\n \n char *OutBuffer::peekChars()\n {\n-    if (!offset || data[offset-1] != '\\0')\n+    if (!offset || data.ptr[offset-1] != '\\0')\n     {\n         writeByte(0);\n         offset--; // allow appending more\n     }\n-    return (char *)data;\n+    return (char *)data.ptr;\n }\n \n char *OutBuffer::extractChars()\n {\n-    if (!offset || data[offset-1] != '\\0')\n+    if (!offset || data.ptr[offset-1] != '\\0')\n         writeByte(0);\n     return extractData();\n }"}, {"sha": "49b1c3e5bcfc4d9e668305b64233f7389cf6d8d3", "filename": "gcc/d/dmd/root/outbuffer.h", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d103f336bdc3144e756c7634b8914830c867896d/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fdmd%2Froot%2Foutbuffer.h?ref=d103f336bdc3144e756c7634b8914830c867896d", "patch": "@@ -9,44 +9,43 @@\n #pragma once\n \n #include \"dsystem.h\"\n-#include \"port.h\"\n+#include \"dcompat.h\"\n #include \"rmem.h\"\n \n class RootObject;\n \n struct OutBuffer\n {\n-    unsigned char *data;\n+private:\n+    DArray<unsigned char> data;\n     size_t offset;\n-    size_t size;\n+    bool notlinehead;\n+public:\n \n     int level;\n     bool doindent;\n-private:\n-    bool notlinehead;\n-public:\n \n     OutBuffer()\n     {\n-        data = NULL;\n+        data = DArray<unsigned char>();\n         offset = 0;\n-        size = 0;\n \n         doindent = 0;\n         level = 0;\n         notlinehead = 0;\n     }\n     ~OutBuffer()\n     {\n-        mem.xfree(data);\n+        mem.xfree(data.ptr);\n     }\n+    const DArray<unsigned char> slice() const { return data; }\n+    d_size_t length() const { return offset; }\n     char *extractData();\n \n     void reserve(size_t nbytes);\n     void setsize(size_t size);\n     void reset();\n     void write(const void *data, d_size_t nbytes);\n-    void writebstring(utf8_t *string);\n     void writestring(const char *string);\n     void prependstring(const char *string);\n     void writenl();                     // write newline"}]}