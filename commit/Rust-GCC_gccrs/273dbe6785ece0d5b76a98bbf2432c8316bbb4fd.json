{"sha": "273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjczZGJlNjc4NWVjZTBkNWI3NmE5OGJiZjI0MzJjODMxNmJiYjRmZA==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-01T02:07:00Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1996-11-01T02:07:00Z"}, "message": "x\n\nFrom-SVN: r13088", "tree": {"sha": "b8da0c8e75d7ca4c1f426fdc5e6efe1d8e817538", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b8da0c8e75d7ca4c1f426fdc5e6efe1d8e817538"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd/comments", "author": null, "committer": null, "parents": [{"sha": "27a2c2b5a1255f4df4b5316bdb2d642f5f2e256b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27a2c2b5a1255f4df4b5316bdb2d642f5f2e256b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27a2c2b5a1255f4df4b5316bdb2d642f5f2e256b"}], "stats": {"total": 161, "additions": 65, "deletions": 96}, "files": [{"sha": "e8314592245c2f4641097c48ccfaa62dacbba513", "filename": "gcc/config/mips/t-iris6", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd/gcc%2Fconfig%2Fmips%2Ft-iris6", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd/gcc%2Fconfig%2Fmips%2Ft-iris6", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Ft-iris6?ref=273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "patch": "@@ -16,4 +16,4 @@ INSTALL_LIBGCC = install-multilib\n # For svr4 we build crtbegin.o and crtend.o which serve to add begin and\n # end labels to the .ctors and .dtors section when we link using gcc.\n \n-EXTRA_PARTS=crtbegin.o crtend.o\n+EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o"}, {"sha": "f0e2ae4964cc23214142a69ab91b303df27e491b", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 64, "deletions": 95, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/273dbe6785ece0d5b76a98bbf2432c8316bbb4fd/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=273dbe6785ece0d5b76a98bbf2432c8316bbb4fd", "patch": "@@ -413,11 +413,6 @@ static char *primary_filename;\n    assigns numbers to the blocks in the same way.  */\n static unsigned next_block_number = 2;\n \n-/* Non-zero if we are performing the file-scope finalization pass and if we\n-   should force out Dwarf descriptions of any and all file-scope tagged types\n-   which are still incomplete types.  */\n-static int finalizing = 0;\n-\n /* A pointer to the base of a list of references to DIE's that describe\n    types.  The table is indexed by TYPE_UID() which is a unique number,\n    indentifying each type.  */\n@@ -6062,7 +6057,7 @@ add_name_and_src_coords_attributes (die, decl)\n {\n   register tree decl_name;\n   register unsigned file_index;\n-  if (decl_function_context (decl) == NULL_TREE)\n+  if (TREE_CODE (decl) == FUNCTION_DECL || TREE_CODE (decl) == VAR_DECL)\n     decl_name = DECL_ASSEMBLER_NAME (decl);\n   else\n     decl_name = DECL_NAME (decl); \n@@ -6366,43 +6361,46 @@ gen_inlined_union_type_die (type, context_die)\n \n /* Generate a DIE to represent an enumeration type.  Note that these DIEs\n    include all of the information about the enumeration values also. Each\n-   enumerated type name/value is listed as a child of the enumerated type DIE */\n+   enumerated type name/value is listed as a child of the enumerated type\n+   DIE.  */\n static void\n-gen_enumeration_type_die (type, is_complete, context_die)\n+gen_enumeration_type_die (type, context_die)\n      register tree type;\n-     register unsigned is_complete;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die;\n-  register dw_die_ref enum_die;\n-  register tree link;\n-  type_die = lookup_type_die (type);\n+  register dw_die_ref type_die = lookup_type_die (type);\n+\n   if (type_die == NULL)\n     {\n       type_die = new_die (DW_TAG_enumeration_type,\n \t\t\t  scope_die_for (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n     }\n-  if (is_complete)\n+  else if (! TYPE_SIZE (type))\n+    return;\n+  else\n+    remove_AT (type_die, DW_AT_declaration);\n+\n+  /* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the\n+     given enum type is incomplete, do not generate the DW_AT_byte_size\n+     attribute or the DW_AT_element_list attribute.  */\n+  if (TYPE_SIZE (type))\n     {\n-      /* Handle a GNU C/C++ extension, i.e. incomplete enum types.  If the\n-         given enum type is incomplete, do not generate the DW_AT_byte_size\n-         attribute or the DW_AT_element_list attribute.  */\n-      if (TYPE_SIZE (type))\n+      register tree link;\n+      add_byte_size_attribute (type_die, type);\n+      for (link = TYPE_FIELDS (type);\n+\t   link != NULL; link = TREE_CHAIN (link))\n \t{\n-\t  add_byte_size_attribute (type_die, type);\n-\t  for (link = TYPE_FIELDS (type);\n-\t       link != NULL; link = TREE_CHAIN (link))\n-\t    {\n-\t      enum_die = new_die (DW_TAG_enumerator, type_die);\n-\t      add_name_attribute (enum_die,\n-\t\t\t\t  IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n-\t      add_AT_unsigned (enum_die, DW_AT_const_value,\n+\t  register dw_die_ref enum_die = new_die (DW_TAG_enumerator, type_die);\n+\t  add_name_attribute (enum_die,\n+\t\t\t      IDENTIFIER_POINTER (TREE_PURPOSE (link)));\n+\t  add_AT_unsigned (enum_die, DW_AT_const_value,\n \t\t\t   (unsigned) TREE_INT_CST_LOW (TREE_VALUE (link)));\n-\t    }\n \t}\n     }\n+  else\n+    add_AT_flag (type_die, DW_AT_declaration, 1);\n }\n \n \n@@ -6610,15 +6608,15 @@ gen_subprogram_die (decl, context_die)\n     {\n       subr_die = new_die (DW_TAG_subprogram,\n \t\t\t  scope_die_for (decl, context_die));\n-      if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n-\t{\n-\t  add_AT_flag (subr_die, DW_AT_external, 1);\n-\t}\n+      if (TREE_PUBLIC (decl))\n+\tadd_AT_flag (subr_die, DW_AT_external, 1);\n       add_name_and_src_coords_attributes (subr_die, decl);\n       type = TREE_TYPE (decl);\n       add_prototyped_attribute (subr_die, type);\n       add_type_attribute (subr_die, TREE_TYPE (type), 0, 0, context_die);\n       add_pure_or_virtual_attribute (subr_die, decl);\n+      if (DECL_ARTIFICIAL (decl))\n+\tadd_AT_flag (subr_die, DW_AT_artificial, 1);\n \n       /* The first time we see a member function, it is in the context of\n          the class to which it belongs.  We make sure of this by emitting\n@@ -6822,10 +6820,10 @@ gen_variable_die (decl, context_die)\n       add_type_attribute (var_die, TREE_TYPE (decl),\n \t\t\t  TREE_READONLY (decl),\n \t\t\t  TREE_THIS_VOLATILE (decl), context_die);\n-      if (TREE_PUBLIC (decl) || DECL_EXTERNAL (decl))\n-\t{\n-\t  add_AT_flag (var_die, DW_AT_external, 1);\n-\t}\n+      if (TREE_PUBLIC (decl))\n+\tadd_AT_flag (var_die, DW_AT_external, 1);\n+      if (DECL_ARTIFICIAL (decl))\n+\tadd_AT_flag (var_die, DW_AT_artificial, 1);\n     }\n   if (DECL_ABSTRACT (decl))\n     {\n@@ -6953,6 +6951,8 @@ gen_field_die (decl, context_die)\n       add_bit_offset_attribute (decl_die, decl);\n     }\n   add_data_member_location_attribute (decl_die, decl);\n+  if (DECL_ARTIFICIAL (decl))\n+    add_AT_flag (decl_die, DW_AT_artificial, 1);\n }\n \n #if 0\n@@ -6965,7 +6965,8 @@ gen_pointer_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ptr_die = new_die (DW_TAG_pointer_type, context_die);\n+  register dw_die_ref ptr_die = new_die\n+    (DW_TAG_pointer_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, ptr_die);\n   add_type_attribute (ptr_die, TREE_TYPE (type), 0, 0, context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n@@ -6980,7 +6981,8 @@ gen_reference_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref ref_die = new_die (DW_TAG_reference_type, context_die);\n+  register dw_die_ref ref_die = new_die\n+    (DW_TAG_reference_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, ref_die);\n   add_type_attribute (ref_die, TREE_TYPE (type), 0, 0, context_die);\n   add_AT_unsigned (mod_type_die, DW_AT_byte_size, PTR_SIZE);\n@@ -6994,7 +6996,7 @@ gen_ptr_to_mbr_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register dw_die_ref ptr_die = new_die\n-    (DW_TAG_ptr_to_member_type, context_die);\n+    (DW_TAG_ptr_to_member_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, ptr_die);\n   add_AT_die_ref (ptr_die, DW_AT_containing_type,\n \t\t  lookup_type_die (TYPE_OFFSET_BASETYPE (type)));\n@@ -7133,40 +7135,42 @@ gen_member_die (type, context_die)\n \n /* Generate a DIE for a structure or union type.  */\n static void\n-gen_struct_or_union_type_die (type, is_complete, context_die)\n+gen_struct_or_union_type_die (type, context_die)\n      register tree type;\n-     register unsigned is_complete;\n      register dw_die_ref context_die;\n {\n-  register dw_die_ref type_die;\n-  type_die = lookup_type_die (type);\n-  if (type_die == NULL)\n+  register dw_die_ref type_die = lookup_type_die (type);\n+\n+  if (type_die && ! TYPE_SIZE (type))\n+    return;\n+  else if (! type_die\n+\t   || (TYPE_CONTEXT (type)\n+\t       && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) == 't'))\n+    /* First occurrence of type or toplevel definition of nested class.  */\n     {\n+      register dw_die_ref old_die = type_die;\n       type_die = new_die (TREE_CODE (type) == RECORD_TYPE\n \t\t\t  ? DW_TAG_structure_type : DW_TAG_union_type,\n \t\t\t  scope_die_for (type, context_die));\n       equate_type_number_to_die (type, type_die);\n       add_name_attribute (type_die, type_tag (type));\n+      if (old_die)\n+\tadd_AT_die_ref (type_die, DW_AT_specification, old_die);\n     }\n-  else if (is_complete)\n-    remove_AT (type_die, DW_AT_declaration);\n   else\n-    return;\n+    remove_AT (type_die, DW_AT_declaration);\n \n   /* If this type has been completed, then give it a byte_size attribute and\n      then give a list of members.  */\n-  if (is_complete)\n+  if (TYPE_SIZE (type))\n     {\n       /* Prevent infinite recursion in cases where the type of some member of \n          this type is expressed in terms of this type itself.  */\n       TREE_ASM_WRITTEN (type) = 1;\n-      if (TYPE_SIZE (type))\n-\t{\n-\t  add_byte_size_attribute (type_die, type);\n-\t  push_decl_scope (type);\n-\t  gen_member_die (type, type_die);\n-\t  pop_decl_scope ();\n-\t}\n+      add_byte_size_attribute (type_die, type);\n+      push_decl_scope (type);\n+      gen_member_die (type, type_die);\n+      pop_decl_scope ();\n     }\n   else\n     add_AT_flag (type_die, DW_AT_declaration, 1);\n@@ -7179,7 +7183,8 @@ gen_subroutine_type_die (type, context_die)\n      register dw_die_ref context_die;\n {\n   register tree return_type = TREE_TYPE (type);\n-  register dw_die_ref subr_die = new_die (DW_TAG_subroutine_type, context_die);\n+  register dw_die_ref subr_die = new_die\n+    (DW_TAG_subroutine_type, scope_die_for (type, context_die));\n   equate_type_number_to_die (type, subr_die);\n   add_prototyped_attribute (subr_die, type);\n   add_type_attribute (subr_die, return_type, 0, 0, context_die);\n@@ -7219,7 +7224,6 @@ gen_type_die (type, context_die)\n      register tree type;\n      register dw_die_ref context_die;\n {\n-  register unsigned is_complete;\n   if (type == 0 || type == error_mark_node)\n     {\n       return;\n@@ -7296,48 +7300,14 @@ gen_type_die (type, context_die)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n     case QUAL_UNION_TYPE:\n-      /* For a function-scope tagged type, we can always go ahead and output\n-         a Dwarf description of this type right now, even if the type in\n-         question is still incomplete, because if this local type *was* ever\n-         completed anywhere within its scope, that complete definition would\n-         already have been attached to this RECORD_TYPE, UNION_TYPE,\n-         QUAL_UNION_TYPE or ENUMERAL_TYPE node by the time we reach this\n-         point.  That's true because of the way the front-end does its\n-         processing of file-scope declarations (of functions and class types) \n-         within which other types might be nested.  The C and C++ front-ends\n-         always gobble up such \"local scope\" things en-mass before they try\n-         to output *any* debugging information for any of the stuff contained \n-         inside them and thus, we get the benefit here of what is (in effect) \n-         a pre-resolution of forward references to tagged types in local\n-         scopes. Note however that for file-scope tagged types we cannot\n-         assume that such pre-resolution of forward references has taken\n-         place. A given file-scope tagged type may appear to be incomplete\n-         when we reach this point, but it may yet be given a full definition\n-         (at file-scope) later on during compilation.  In order to avoid\n-         generating a premature (and possibly incorrect) set of Dwarf DIEs\n-         for such (as yet incomplete) file-scope tagged types, we generate\n-         nothing at all for as-yet incomplete file-scope tagged types here\n-         unless we are making our special \"finalization\" pass for file-scope\n-         things at the very end of compilation.  At that time, we will\n-         certainly know as much about each file-scope tagged type as we are\n-         ever going to know, so at that point in time, we can safely generate \n-         correct Dwarf descriptions for these file-scope tagged types.  */\n-      is_complete = TYPE_SIZE (type) != 0\n-\t|| (TYPE_CONTEXT (type) != NULL\n-\t    && TREE_CODE_CLASS (TREE_CODE (TYPE_CONTEXT (type))) != 't')\n-\t|| finalizing;\n       if (TREE_CODE (type) == ENUMERAL_TYPE)\n-\t{\n-\t  gen_enumeration_type_die (type, is_complete, context_die);\n-\t}\n+\tgen_enumeration_type_die (type, context_die);\n       else\n-\t{\n-\t  gen_struct_or_union_type_die (type, is_complete, context_die);\n-\t}\n+\tgen_struct_or_union_type_die (type, context_die);\n \n       /* Don't set TREE_ASM_WRITTEN on an incomplete struct; we want to fix\n \t it up if it is ever completed.  */\n-      if (! is_complete)\n+      if (TYPE_SIZE (type) == NULL_TREE)\n \treturn;\n       break;\n \n@@ -7743,7 +7713,7 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n          out-of-lines instances of such things (despite the fact that they\n          *are* definitions).  The important point is that the C front-end\n          marks these \"extern inline\" functions as DECL_EXTERNAL, but we need\n-         to generate DWARf for them anyway. Note that the C++ front-end also\n+         to generate DWARF for them anyway. Note that the C++ front-end also\n          plays some similar games for inline function definitions appearing\n          within include files which also contain \n \t `#pragma interface' pragmas.  */\n@@ -7811,7 +7781,6 @@ dwarfout_file_scope_decl (decl, set_finalizing)\n       return;\n     }\n \n-  finalizing = set_finalizing;\n   gen_decl_die (decl, comp_unit_die);\n \n   if (TREE_CODE (decl) == FUNCTION_DECL"}]}