{"sha": "4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4NzIwMzZlOGE2MmUxYjdjM2RiZmE1NGNjNzU4NGZkNjE4MzFiMg==", "commit": {"author": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-04-06T21:22:49Z"}, "committer": {"name": "Alex Samuel", "email": "samuel@gcc.gnu.org", "date": "2000-04-06T21:22:49Z"}, "message": "rtl.h (INSN_P): New macro.\n\n\t* rtl.h (INSN_P): New macro.\n\t(successor_phi_fn): New typedef.\n\t(for_each_successor_phi): New prototype.\n\t(in_ssa_form): New variable.\n\t(PHI_NODE_P): Likewise.\n\t* flow.c (calculate_global_regs_live): Add to new_live_at_end from\n\tphi nodes in successors.\n\t(mark_used_regs): Add PHI case.\n\t(set_phi_alternative_reg): New function.\n\t(life_analysis): Assert that dead code elimination is not selected\n\twhen in SSA form.\n\t* toplev.c (to_ssa_time): New variable.\n\t(from_ssa_time): Likewise.\n\t(compile_file): Zero to_ssa_time and from_ssa_time.\n\tPrint time to convert to and from SSA.\n\t(rest_of_compilation): Time convert_to_ssa and convert_from_ssa.\n\t(print_time): Compute percent fraction as integer.\n\t* ssa.c (PHI_NODE_P): Moved to rtl.h.\n\t(convert_to_ssa): Check if we're already in SSA.\n\tDon't eliminate dead code in life_analysis.\n\tRerun flow and life analysis at bottom.\n\t(eliminate_phi): Use canonical regnos when adding nodes.\n\t(mark_reg_in_phi): New function.\n\t(mark_phi_and_copy_regs): Likewise.\n\t(convert_from_ssa): Rerun life analysis at top.\n\tUse coalesced partition.\n\tCheck for removing a phi node at the end of the block.\n\t(compute_coalesced_reg_partition): New function.\n\t(coalesce_regs_in_copies): Likewise.\n\t(coalesce_reg_in_phi): Likewise.\n\t(coalesce_regs_in_sucessor_phi_nodes): Likewise.\n\t(for_each_successor_phi): Likewise.\n\t(rename_context): New struct.\n\t(rename_block): Use a rename_context with rename_insn_1.  When\n\trenaming sets of a subreg, emit a copy of the entire reg first.\n\t(rename_insn_1): Treat data as a rename_context *.  Save current\n\tinsn in set_data.\n\t(rename_set_data): Add field set_insn.\n\t* Makefile.in (HASHTAB_H): Move up in file.\n\t(OBSTACK_H): New macro.\n\t(collect2.o): Use OBSTACK_H in dependencies.\n\t(sdbout.o): Likewise.\n\t(emit-rtl.o): Likewise.\n\t(simplify-rtx.o): Likewise.\n\t(fix-header.o): Likewise.\n\t(OBJS):\tAdd conflict.o.\n\t(conflict.o): New rule.\n\t* basic-block.h: Include partition.h.\n\t(conflict_graph): New typedef.\n\t(conflict_graph_enum_fn): Likewise.\n\t(conflict_graph_new): New prototype.\n\t(conflict_graph_delete): Likewise.\n\t(conflict_graph_add): Likewise.\n\t(conflict_graph_conflict_p): Likewise.\n\t(conflict_graph_enum): Likewise.\n\t(conflict_graph_merge_regs): Likewise.\n\t(conflict_graph_print): Likewise.\n\t(conflict_graph_compute): Likewise.\n\t* conflict.c: New file.\n\nFrom-SVN: r32979", "tree": {"sha": "03b76aa3f87cb424bd3389a8c22d97e1312c57ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03b76aa3f87cb424bd3389a8c22d97e1312c57ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/comments", "author": null, "committer": null, "parents": [{"sha": "2c561874133f1756d49d993d7561a802bd8448eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c561874133f1756d49d993d7561a802bd8448eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c561874133f1756d49d993d7561a802bd8448eb"}], "stats": {"total": 1232, "additions": 1163, "deletions": 69}, "files": [{"sha": "e1d23d6437abda259879716acde7bcbcd4bc18fb", "filename": "gcc/Makefile.in", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -218,6 +218,10 @@ RANLIB_TEST_FOR_TARGET = \\\n # Dir to search for system headers.  Overridden by cross-make.\n SYSTEM_HEADER_DIR = /usr/include\n \n+# Where to find some libiberty headers.\n+HASHTAB_H   = $(srcdir)/../include/hashtab.h\n+OBSTACK_H   = $(srcdir)/../include/obstack.h\n+\n # Default cross SYSTEM_HEADER_DIR, to be overridden by targets.\n CROSS_SYSTEM_HEADER_DIR = $(tooldir)/sys-include\n \n@@ -680,7 +684,7 @@ OBJS = diagnostic.o \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o \\\n  mbchar.o dyn-string.o splay-tree.o graph.o sbitmap.o resource.o hash.o \\\n  predict.o lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o \\\n- sibcall.o\n+ sibcall.o conflict.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1387,7 +1391,7 @@ collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(COLLECT2_OBJS) $(LIBS)\n \n collect2.o : collect2.c $(CONFIG_H) system.h gstab.h intl.h \\\n-\t$(srcdir)/../include/obstack.h $(DEMANGLE_H) collect2.h version.h\n+\t$(OBSTACK_H) $(DEMANGLE_H) collect2.h version.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES)  \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" $(MAYBE_USE_COLLECT2) \\\n \t-c `echo $(srcdir)/collect2.c | sed 's,^\\./,,'`\n@@ -1548,7 +1552,7 @@ dbxout.o : dbxout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h $(REGS_H) \\\n    toplev.h\n sdbout.o : sdbout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) flags.h except.h \\\n    function.h $(EXPR_H) output.h hard-reg-set.h $(REGS_H) defaults.h real.h \\\n-   insn-config.h $(srcdir)/../include/obstack.h xcoffout.h c-pragma.h \\\n+   insn-config.h $(OBSTACK_H) xcoffout.h c-pragma.h \\\n    sdbout.h toplev.h\n dwarfout.o : dwarfout.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) dwarf.h \\\n    flags.h insn-config.h reload.h output.h defaults.h toplev.h dwarfout.h\n@@ -1572,7 +1576,7 @@ jump.o : jump.c $(CONFIG_H) system.h $(RTL_H) flags.h hard-reg-set.h $(REGS_H) \\\n \n simplify-rtx.o : simplify-rtx.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n-   output.h function.h cselib.h $(GGC_H) $(srcdir)/../include/obstack.h\n+   output.h function.h cselib.h ggc.h $(OBSTACK_H)\n cse.o : cse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h output.h function.h $(GGC_H)\n gcse.o : gcse.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h \\\n@@ -1587,6 +1591,8 @@ lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h insn-attr.h $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) $(BASIC_BLOCK_H) \\\n    output.h insn-config.h\n+conflict.o : conflict.c $(CONFIG_H) $(OBSTACK_H) $(HASHTAB_H) \\\n+   rtl.h basic-block.h\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) flags.h insn-flags.h \\\n    gcov-io.h $(TREE_H) output.h $(REGS_H) toplev.h function.h insn-config.h \\\n    $(GGC_H)\n@@ -2056,7 +2062,6 @@ LIBCPP_OBJS =\tcpplib.o cpphash.o cpperror.o cppexp.o cppfiles.o \\\n \t\tprefix.o version.o mbchar.o @extra_cpp_objs@\n \n LIBCPP_DEPS = cpplib.h cpphash.h intl.h system.h\n-HASHTAB_H   = $(srcdir)/../include/hashtab.h\n \n # All the other archives built/used by this makefile are for targets.  This\n # one is strictly for the host.\n@@ -2287,7 +2292,7 @@ fix-header: fix-header.o scan-decls.o scan.o xsys-protos.h $(HOST_LIBDEPS) \\\n \t$(HOST_CC) $(HOST_CFLAGS) $(HOST_LDFLAGS) -o $@ fix-header.o \\\n \t   scan-decls.o scan.o libcpp.a $(HOST_LIBS) ../libiberty/libiberty.a\n \n-fix-header.o: fix-header.c $(srcdir)/../include/obstack.h scan.h \\\n+fix-header.o: fix-header.c $(OBSTACK_H) scan.h \\\n \txsys-protos.h $(build_xm_file) system.h cpplib.h\n \t$(HOST_CC) -c $(HOST_CFLAGS) $(HOST_CPPFLAGS) $(INCLUDES) $(srcdir)/fix-header.c\n "}, {"sha": "5fa62268b01678765a54ef377453473627760475", "filename": "gcc/basic-block.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -24,6 +24,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"bitmap.h\"\n #include \"sbitmap.h\"\n #include \"varray.h\"\n+#include \"partition.h\"\n \n /* Head of register set linked list.  */\n typedef bitmap_head regset_head;\n@@ -146,7 +147,9 @@ typedef struct basic_block_def {\n   /* The edges into and out of the block.  */\n   edge pred, succ;\n \n-  /* Liveness info.  */\n+  /* Liveness info.  Note that in SSA form, global_live_at_start does\n+     not reflect the use of regs in phi functions, since the liveness\n+     of these regs may depend on which edge was taken into the block.  */\n   regset local_set;\n   regset global_live_at_start;\n   regset global_live_at_end;\n@@ -459,5 +462,31 @@ extern void debug_regset\t\tPARAMS ((regset));\n extern void verify_flow_info\t\tPARAMS ((void));\n extern int flow_loop_outside_edge_p\tPARAMS ((const struct loop *, edge));\n \n+typedef struct conflict_graph_def *conflict_graph;\n+\n+/* Callback function when enumerating conflicts.  The arguments are\n+   the smaller and larger regno in the conflict.  Returns zero if\n+   enumeration is to continue, non-zero to halt enumeration.  */\n+typedef int (*conflict_graph_enum_fn) (int, int, void *);\n+\n+\n+/* Prototypes of operations on conflict graphs.  */\n+\n+extern conflict_graph conflict_graph_new \n+                                        PARAMS ((int));\n+extern void conflict_graph_delete       PARAMS ((conflict_graph));\n+extern int conflict_graph_add           PARAMS ((conflict_graph, \n+\t\t\t\t\t\t int, int));\n+extern int conflict_graph_conflict_p    PARAMS ((conflict_graph, \n+\t\t\t\t\t\t int, int));\n+extern void conflict_graph_enum         PARAMS ((conflict_graph, int, \n+\t\t\t\t\t\t conflict_graph_enum_fn, \n+\t\t\t\t\t\t void *));\n+extern void conflict_graph_merge_regs   PARAMS ((conflict_graph, int,\n+\t\t\t\t\t\t int));\n+extern void conflict_graph_print        PARAMS ((conflict_graph, FILE*));\n+extern conflict_graph conflict_graph_compute \n+                                        PARAMS ((regset,\n+\t\t\t\t\t\t partition));\n \n #endif /* _BASIC_BLOCK_H */"}, {"sha": "51851a2b1b504d6198fd528d01424324b6d6b502", "filename": "gcc/conflict.c", "status": "added", "additions": 535, "deletions": 0, "changes": 535, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fconflict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fconflict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconflict.c?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -0,0 +1,535 @@\n+/* Register conflict graph computation routines.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by CodeSourcery, LLC\n+\n+   This file is part of GNU CC.\n+\n+   GNU CC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 2, or (at your option)\n+   any later version.\n+\n+   GNU CC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GNU CC; see the file COPYING.  If not, write to\n+   the Free Software Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.  */\n+\n+/* References:\n+\n+   Building an Optimizing Compiler\n+   Robert Morgan\n+   Butterworth-Heinemann, 1998 */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"obstack.h\"\n+#include \"hashtab.h\"\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+\n+/* Use malloc to allocate obstack chunks.  */\n+#define obstack_chunk_alloc xmalloc\n+#define obstack_chunk_free free\n+\n+/* A register conflict graph is an undirected graph containing nodes\n+   for some or all of the regs used in a function.  Arcs represent\n+   conflicts, i.e. two nodes are connected by an arc if there is a\n+   point in the function at which the regs corresponding to the two\n+   nodes are both live.\n+\n+   The conflict graph is represented by the data structures described\n+   in Morgan section 11.3.1.  Nodes are not stored explicitly; only\n+   arcs are.  An arc stores the numbers of the regs it connects.\n+\n+   Arcs can be located by two methods:\n+\n+     - The two reg numbers for each arc are hashed into a single\n+       value, and the arc is placed in a hash table according to this\n+       value.  This permits quick determination of whether a specific\n+       conflict is present in the graph.  \n+\n+     - Additionally, the arc data structures are threaded by a set of\n+       linked lists by single reg number.  Since each arc references\n+       two regs, there are two next pointers, one for the\n+       smaller-numbered reg and one for the larger-numbered reg.  This\n+       permits the quick enumeration of conflicts for a single\n+       register.\n+\n+   Arcs are allocated from an obstack.  */\n+\n+/* An arc in a conflict graph.  */\n+\n+struct conflict_graph_arc_def\n+{\n+  /* The next element of the list of conflicts involving the\n+     smaller-numbered reg, as an index in the table of arcs of this\n+     graph.   Contains NULL if this is the tail.  */\n+  struct conflict_graph_arc_def *smaller_next;\n+\n+  /* The next element of the list of conflicts involving the\n+     larger-numbered reg, as an index in the table of arcs of this\n+     graph.  Contains NULL if this is the tail.  */\n+  struct conflict_graph_arc_def *larger_next;\n+\n+  /* The smaller-numbered reg involved in this conflict.  */\n+  int smaller;\n+\n+  /* The larger-numbered reg involved in this conflict.  */\n+  int larger;\n+};\n+\n+typedef struct conflict_graph_arc_def *conflict_graph_arc;\n+\n+\n+/* A conflict graph.  */\n+\n+struct conflict_graph_def\n+{\n+  /* A hash table of arcs.  Used to search for a specific conflict.  */\n+  htab_t arc_hash_table;\n+\n+  /* The number of regs this conflict graph handles.  */\n+  int num_regs;\n+\n+  /* For each reg, the arc at the head of a list that threads through\n+     all the arcs involving that reg.  An entry is NULL if no\n+     conflicts exist involving that reg.  */\n+  conflict_graph_arc *neighbor_heads;\n+\n+  /* Arcs are allocated from here. */\n+  struct obstack arc_obstack;\n+};\n+\n+/* The initial capacity (number of conflict arcs) for newly-created\n+   conflict graphs.  */\n+#define INITIAL_ARC_CAPACITY (64)\n+\n+\n+/* Computes the hash value of the conflict graph arc connecting regs\n+   R1__ and R2__.  R1__ is assumed to be smaller or equal to R2__.  */\n+#define CONFLICT_HASH_FN(r1__, r2__) ((r2__) * ((r2__) - 1) / 2 + (r1__))\n+\n+static unsigned arc_hash\n+  PARAMS ((const void *arcp));\n+static int arc_eq \n+  PARAMS ((const void *arcp1, const void *arcp2));\n+static int print_conflict\n+  PARAMS ((int reg1, int reg2, void *contextp));\n+static void mark_reg \n+  PARAMS ((rtx reg, rtx setter, void *data));\n+\n+\n+/* Callback function to compute the hash value of an arc.  Uses\n+   current_graph to locate the graph to which the arc belongs. */\n+\n+static unsigned\n+arc_hash (arcp)\n+     const void *arcp;\n+{\n+  conflict_graph_arc arc = (conflict_graph_arc) arcp;\n+  return CONFLICT_HASH_FN (arc->smaller, arc->larger);\n+}\n+\n+/* Callback function to determine the equality of two arcs in the hash\n+   table.  */\n+\n+static int\n+arc_eq (arcp1, arcp2)\n+     const void *arcp1;\n+     const void *arcp2;\n+{\n+  conflict_graph_arc arc1 = (conflict_graph_arc) arcp1;\n+  conflict_graph_arc arc2 = (conflict_graph_arc) arcp2;\n+  return arc1->smaller == arc2->smaller && arc1->larger == arc2->larger;\n+}\n+\n+/* Creates an empty conflict graph to hold conflicts among NUM_REGS\n+   registers.  */\n+\n+conflict_graph\n+conflict_graph_new (num_regs)\n+     int num_regs;\n+{\n+  conflict_graph graph = \n+    (conflict_graph) xmalloc (sizeof (struct conflict_graph_def));\n+  graph->num_regs = num_regs;\n+\n+  /* Set up the hash table.  No delete action is specified; memory\n+     management of arcs is through the obstack.  */\n+  graph->arc_hash_table = \n+    htab_create (INITIAL_ARC_CAPACITY, &arc_hash, &arc_eq, NULL);\n+\n+  /* Create an obstack for allocating arcs.  */\n+  obstack_init (&(graph->arc_obstack));\n+\t     \n+  /* Create and zero the lookup table by register number.  */\n+  graph->neighbor_heads = (conflict_graph_arc *) \n+    xmalloc (num_regs * sizeof (conflict_graph_arc));\n+  memset (graph->neighbor_heads, 0, \n+\t  num_regs * sizeof (conflict_graph_arc));\n+\n+  return graph;\n+}\n+\n+/* Deletes a conflict graph.  */\n+\n+void\n+conflict_graph_delete (graph)\n+     conflict_graph graph;\n+{\n+  obstack_free (&(graph->arc_obstack), NULL);\n+  htab_delete (graph->arc_hash_table);\n+  free (graph->neighbor_heads);\n+  free (graph);\n+}\n+\n+/* Adds a conflict to GRAPH between regs REG1 and REG2, which must be\n+   distinct.  Returns non-zero, unless the conflict is already present\n+   in GRAPH, in which case it does nothing and returns zero.  */\n+\n+int\n+conflict_graph_add (graph, reg1, reg2)\n+     conflict_graph graph;\n+     int reg1;\n+     int reg2;\n+{\n+  int smaller = MIN (reg1, reg2);\n+  int larger = MAX (reg1, reg2);\n+  conflict_graph_arc arc;\n+  void **hash_table_slot;\n+\n+  /* A reg cannot conflict with itself.  */\n+  if (reg1 == reg2)\n+    abort ();\n+\n+  /* If the conflict is already there, do nothing. \n+\n+     FIXME: This is a little wastful; it would be faster to look up the\n+     conflict in the hash table, returning it if it exists and\n+     inserting a new entry if it doesn't, all in one operation.  This\n+     would save an extra hash lookup.  However, the hashtab interface\n+     doesn't really allow this right now.  */\n+  if (conflict_graph_conflict_p (graph, reg1, reg2))\n+    return 0;\n+\n+  /* Allocate an arc.  */\n+  arc = (conflict_graph_arc) \n+    obstack_alloc (&(graph->arc_obstack),\n+\t\t   sizeof (struct conflict_graph_arc_def));\n+\n+  /* Record the reg numbers.  */\n+  arc->smaller = smaller;\n+  arc->larger = larger;\n+\n+  /* Link the conflict into into two lists, one for each reg.  */\n+  arc->smaller_next = graph->neighbor_heads[smaller];\n+  graph->neighbor_heads[smaller] = arc;\n+  arc->larger_next = graph->neighbor_heads[larger];\n+  graph->neighbor_heads[larger] = arc;\n+\n+  /* Put it in the hash table.  */\n+  hash_table_slot = htab_find_slot (graph->arc_hash_table, \n+\t\t\t\t    (void *) arc, 1);\n+  *hash_table_slot = (void *) arc;\n+\n+  return 1;\n+}\n+\n+/* Returns non-zero if a conflict exists in GRAPH between regs REG1\n+   and REG2.  */\n+\n+int\n+conflict_graph_conflict_p (graph, reg1, reg2)\n+     conflict_graph graph;\n+     int reg1;\n+     int reg2;\n+{\n+  /* Build an arc to search for.  */\n+  struct conflict_graph_arc_def arc;\n+  arc.smaller = MIN (reg1, reg2);\n+  arc.larger = MAX (reg1, reg2);\n+\n+  return htab_find (graph->arc_hash_table, (void *) &arc) != NULL;\n+}\n+\n+/* Calls ENUM_FN for each conflict in GRAPH involving REG.  EXTRA is\n+   passed back to ENUM_FN.  */\n+\n+void\n+conflict_graph_enum (graph, reg, enum_fn, extra)\n+     conflict_graph graph;\n+     int reg;\n+     conflict_graph_enum_fn enum_fn;\n+     void *extra;\n+{\n+  conflict_graph_arc arc = graph->neighbor_heads[reg];\n+  while (arc != NULL)\n+    {\n+      /* Invoke the callback.  */\n+      if ((*enum_fn) (arc->smaller, arc->larger, extra))\n+\t/* Stop if requested.  */\n+\tbreak;\n+      \n+      /* Which next pointer to follow depends on whether REG is the\n+\t smaller or larger reg in this conflict.  */\n+      if (reg < arc->larger)\n+\tarc = arc->smaller_next;\n+      else\n+\tarc = arc->larger_next;\n+    }\n+}\n+\n+/* For each conflict between a register x and SRC in GRAPH, adds a\n+   conflict to GRAPH between x and TARGET.  */\n+\n+void\n+conflict_graph_merge_regs (graph, target, src)\n+     conflict_graph graph;\n+     int target;\n+     int src;\n+{\n+  conflict_graph_arc arc = graph->neighbor_heads[src];\n+\n+  if (target == src)\n+    return;\n+\n+  while (arc != NULL)\n+    {\n+      int other = arc->smaller;\n+      if (other == src)\n+\tother = arc->larger;\n+\n+      conflict_graph_add (graph, target, other);\n+\n+      /* Which next pointer to follow depends on whether REG is the\n+\t smaller or larger reg in this conflict.  */\n+      if (src < arc->larger)\n+\tarc = arc->smaller_next;\n+      else\n+\tarc = arc->larger_next;\n+    }\n+}\n+\n+/* Holds context information while a conflict graph is being traversed\n+   for printing.  */\n+\n+struct print_context\n+{\n+  /* The file pointer to which we're printing.  */\n+  FILE *fp;\n+\n+  /* The reg whose conflicts we're printing.  */\n+  int reg;\n+\n+  /* Whether a conflict has already been printed for this reg.  */\n+  int started;\n+};\n+\n+/* Callback function when enumerating conflicts during printing.  */\n+\n+static int\n+print_conflict (reg1, reg2, contextp)\n+     int reg1;\n+     int reg2;\n+     void *contextp;\n+{\n+  struct print_context *context = (struct print_context *) contextp;\n+  int reg;\n+\n+  /* If this is the first conflict printed for this reg, start a new\n+     line.  */\n+  if (! context->started)\n+    {\n+      fprintf (context->fp, \" %d:\", context->reg);\n+      context->started = 1;\n+    }\n+\n+  /* Figure out the reg whose conflicts we're printing.  The other reg\n+     is the interesting one.  */\n+  if (reg1 == context->reg)\n+    reg = reg2;\n+  else if (reg2 == context->reg)\n+    reg = reg1;\n+  else\n+    abort ();\n+\n+  /* Print the conflict.  */\n+  fprintf (context->fp, \" %d\", reg);\n+\n+  /* Continue enumerating.  */\n+  return 0;\n+}\n+\n+/* Prints the conflicts in GRAPH to FP.  */\n+\n+void\n+conflict_graph_print (graph, fp)\n+     conflict_graph graph;\n+     FILE *fp;\n+{\n+  int reg;\n+  struct print_context context;\n+  context.fp = fp;\n+\n+  fprintf (fp, \"Conflicts:\\n\");\n+  /* Loop over registers supported in this graph.  */\n+  for (reg = 0; reg < graph->num_regs; ++reg)\n+    {\n+      context.reg = reg;\n+      context.started = 0;\n+      /* Scan the conflicts for reg, printing as we go.  A label for\n+\t this line will be printed the first time a conflict is\n+\t printed for the reg; we won't start a new line if this reg\n+\t has no conflicts.  */\n+      conflict_graph_enum (graph, reg, &print_conflict, &context);\n+      /* If this reg does have conflicts, end the line.  */\n+      if (context.started)\n+\tfputc ('\\n', fp);\n+    }\n+}\n+\n+/* Callback function for note_stores.  */\n+\n+static void\n+mark_reg (reg, setter, data)\n+     rtx reg;\n+     rtx setter ATTRIBUTE_UNUSED;\n+     void *data;\n+{\n+  regset set = (regset) data;\n+\n+  if (GET_CODE (reg) == SUBREG)\n+    reg = SUBREG_REG (reg);\n+\n+  /* We're only interested in regs.  */\n+  if (GET_CODE (reg) != REG)\n+    return;\n+\n+  SET_REGNO_REG_SET (set, REGNO (reg));\n+}\n+\n+/* Allocates a conflict graph and computes conflicts over the current\n+   function for the registers set in REGS.  The caller is responsible\n+   for deallocating the return value.  \n+\n+   Preconditions: the flow graph must be in SSA form, and life\n+   analysis (specifically, regs live at exit from each block) must be\n+   up-to-date.  \n+\n+   This algorithm determines conflicts by walking the insns in each\n+   block backwards.  We maintain the set of live regs at each insn,\n+   starting with the regs live on exit from the block.  For each insn:\n+ \n+     1. If a reg is set in this insns, it must be born here, since\n+        we're in SSA.  Therefore, it was not live before this insns,\n+\tso remove it from the set of live regs.  \n+\n+     2. For each reg born in this insn, record a conflict between it\n+\tand every other reg live coming into this insn.  For each\n+\texisting conflict, one of the two regs must be born while the\n+\tother is alive.  See Morgan or elsewhere for a proof of this.\n+\n+     3. Regs clobbered by this insn must have been live coming into\n+        it, so record them as such.  \n+\n+   The resulting conflict graph is not built for regs in REGS\n+   themselves; rather, partition P is used to obtain the canonical reg\n+   for each of these.  The nodes of the conflict graph are these\n+   canonical regs instead.  */\n+\n+conflict_graph\n+conflict_graph_compute (regs, p)\n+     regset regs;\n+     partition p;\n+{\n+  int b;\n+  conflict_graph graph = conflict_graph_new (max_reg_num ());\n+\n+  for (b = n_basic_blocks; --b >= 0; )\n+    {\n+      basic_block bb = BASIC_BLOCK (b);\n+      regset_head live_head;\n+      regset live = &live_head;\n+      regset_head born_head;\n+      regset born = &born_head;\n+      rtx insn;\n+      rtx head;\n+\n+      INIT_REG_SET (live);\n+      INIT_REG_SET (born);\n+\n+      /* Start with the regs that are live on exit, limited to those\n+\t we're interested in.  */\n+      COPY_REG_SET (live, bb->global_live_at_end);\n+      AND_REG_SET (live, regs);\n+\n+      /* Walk the instruction stream backwards.  */\n+      head = bb->head;\n+      insn = bb->end;\n+      for (insn = bb->end; \n+\t   insn != head; \n+\t   insn = PREV_INSN (insn))\n+\t{\n+\t  int born_reg;\n+\t  int live_reg;\n+\t  rtx link;\n+\n+\t  /* Are we interested in this insn? */\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      /* Determine which regs are set in this insn.  Since\n+  \t         we're in SSA form, if a reg is set here it isn't set\n+  \t         anywhere elso, so this insn is where the reg is born.  */\n+\t      CLEAR_REG_SET (born);\n+\t      note_stores (PATTERN (insn), mark_reg, (void *) born);\n+#ifdef AUTO_INC_DEC\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_INC)\n+\t\t  mark_reg (XEXP (link, 0), NULL_RTX, NULL);\n+#endif\n+\t      AND_REG_SET (born, regs);\n+\t  \n+\t      /* Regs born here were not live before this insn.  */\n+\t      AND_COMPL_REG_SET (live, born);\n+\n+\t      /* For every reg born here, add a conflict with every other\n+  \t         reg live coming into this insn.  */\n+\t      EXECUTE_IF_SET_IN_REG_SET (born, \n+\t\t\t\t\t FIRST_PSEUDO_REGISTER, \n+\t\t\t\t\t born_reg, {\n+\t\tEXECUTE_IF_SET_IN_REG_SET (live,\n+\t\t\t\t\t   FIRST_PSEUDO_REGISTER,\n+\t\t\t\t\t   live_reg, {\n+\t\t  /* Build the conflict graph in terms of canonical\n+\t\t     regnos.  */\n+\t\t  int b = partition_find (p, born_reg);\n+\t\t  int l = partition_find (p, live_reg);\n+\t\t  if (b != l)\n+\t\t    conflict_graph_add (graph, b, l);\n+\t\t});\n+\t      });\n+\n+\t      /* Morgan's algorithm checks the operands of the insn\n+\t         and adds them to the set of live regs.  Instead, we\n+\t         use death information added by life analysis.  Regs\n+\t         dead after this instruction were live before it.  */\n+\t      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) == REG_DEAD)\n+\t\t  {\n+\t\t    int regno = REGNO (XEXP (link, 0));\n+\t\t    if (REGNO_REG_SET_P (regs, regno))\n+\t\t      SET_REGNO_REG_SET (live, regno);\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+\n+  return graph;\n+}\n+"}, {"sha": "4fd65dca569195340ccdabec15106100f40b8793", "filename": "gcc/flow.c", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -317,6 +317,7 @@ static void notice_stack_pointer_modification_1 PARAMS ((rtx, rtx, void *));\n static void notice_stack_pointer_modification PARAMS ((rtx));\n static void mark_reg\t\t\tPARAMS ((rtx, void *));\n static void mark_regs_live_at_end\tPARAMS ((regset));\n+static int set_phi_alternative_reg      PARAMS ((rtx, int, int, void *));\n static void calculate_global_regs_live\tPARAMS ((sbitmap, sbitmap, int));\n static void propagate_block\t\tPARAMS ((basic_block, regset,\n \t\t\t\t\t\t regset, int));\n@@ -2486,6 +2487,15 @@ life_analysis (f, nregs, file, remove_dead_code)\n #endif\n   int flags;\n   sbitmap all_blocks;\n+\n+  /* Dead code elimination changes basic block structure and therefore\n+     breaks the SSA phi representation.  Particularly, a phi node\n+     can have an alternative value for each incoming block, referenced\n+     by the block number.  Removing dead code can bump entire blocks\n+     and therefore cause blocks to be renumbered, invalidating the\n+     numbering of phi alternatives.  */\n+  if (remove_dead_code && in_ssa_form)\n+    abort ();\n  \n   /* Record which registers will be eliminated.  We use this in\n      mark_used_regs.  */\n@@ -2960,6 +2970,22 @@ mark_regs_live_at_end (set)\n   diddle_return_value (mark_reg, set);\n }\n \n+/* Callback function for for_each_successor_phi.  DATA is a regset.\n+   Sets the SRC_REGNO, the regno of the phi alternative for phi node\n+   INSN, in the regset.  */\n+\n+static int\n+set_phi_alternative_reg (insn, dest_regno, src_regno, data)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     int dest_regno ATTRIBUTE_UNUSED;\n+     int src_regno;\n+     void *data;\n+{\n+  regset live = (regset) data;\n+  SET_REGNO_REG_SET (live, src_regno);\n+  return 0;\n+}\n+\n /* Propagate global life info around the graph of basic blocks.  Begin\n    considering blocks with their corresponding bit set in BLOCKS_IN. \n    BLOCKS_OUT is set for every block that was changed.  */\n@@ -3020,6 +3046,13 @@ calculate_global_regs_live (blocks_in, blocks_out, flags)\n \t  IOR_REG_SET (new_live_at_end, sb->global_live_at_start);\n \t}\n \n+      /* Regs used in phi nodes are not included in\n+\t global_live_at_start, since they are live only along a\n+\t particular edge.  Set those regs that are live because of a\n+\t phi node alternative corresponding to this particular block.  */\n+      for_each_successor_phi (bb->index, &set_phi_alternative_reg, \n+\t\t\t      new_live_at_end);\n+\n       if (bb == ENTRY_BLOCK_PTR)\n \t{\n \t  COPY_REG_SET (bb->global_live_at_end, new_live_at_end);\n@@ -4688,6 +4721,13 @@ mark_used_regs (needed, live, x, flags, insn)\n \tbreak;\n       }\n \n+    case PHI:\n+      /* We _do_not_ want to scan operands of phi nodes.  Operands of\n+\t a phi function are evaluated only when control reaches this\n+\t block along a particular edge.  Therefore, regs that appear\n+\t as arguments to phi should not be added to the global live at\n+\t start.  */\n+      return;\n \n     default:\n       break;"}, {"sha": "f07407c1972c3ca80f0a733e1dca326b1529b2a7", "filename": "gcc/rtl.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -357,6 +357,9 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n \f\n /* ACCESS MACROS for particular fields of insns.  */\n \n+/* Determines whether X is an insn.  */\n+#define INSN_P(X)       (GET_RTX_CLASS (GET_CODE(X)) == 'i')\n+\n /* Holds a unique number for each insn.\n    These are not necessarily sequentially increasing.  */\n #define INSN_UID(INSN)  XINT(INSN, 0)\n@@ -981,6 +984,12 @@ extern const char * const note_insn_name[];\n \n /* For a NOTE_INSN_LIVE note, the original basic block number.  */\n #define RANGE_LIVE_ORIG_BLOCK(INSN) (XINT (INSN, 1))\n+\n+/* Determine if the insn is a PHI node.  */\n+#define PHI_NODE_P(X)\t\t\t\t\\\n+  (X && GET_CODE (X) == INSN\t\t\t\\\n+   && GET_CODE (PATTERN (X)) == SET\t\t\\\n+   && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n \f\n /* Nonzero if we need to distinguish between the return value of this function\n    and the return value of a function called by this function.  This helps\n@@ -1793,6 +1802,11 @@ extern int stack_regs_mentioned\t\tPARAMS ((rtx insn));\n /* In ssa.c */\n extern void convert_to_ssa\t\tPARAMS ((void));\n extern void convert_from_ssa\t\tPARAMS ((void));\n+typedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\n+extern int for_each_successor_phi       PARAMS ((int bb,\n+\t\t\t\t\t\t successor_phi_fn,\n+\t\t\t\t\t\t void *));\n+extern int in_ssa_form;\n \n /* In toplev.c */\n "}, {"sha": "1bf23c08a4f380b79b9d1d6d120af0771295f361", "filename": "gcc/ssa.c", "status": "modified", "additions": 503, "deletions": 58, "changes": 561, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -48,16 +48,32 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* TODO: \n \n+   Handle subregs better, maybe.  For now, if a reg that's set in a\n+   subreg expression is duplicated going into SSA form, an extra copy\n+   is inserted first that copies the entire reg into the duplicate, so\n+   that the other bits are preserved.  This isn't strictly SSA, since\n+   at least part of the reg is assigned in more than one place (though\n+   they are adjacent).\n+\n    ??? What to do about strict_low_part.  Probably I'll have to split\n    them out of their current instructions first thing.\n \n    Actually the best solution may be to have a kind of \"mid-level rtl\"\n    in which the RTL encodes exactly what we want, without exposing a\n    lot of niggling processor details.  At some later point we lower\n    the representation, calling back into optabs to finish any necessary\n-   expansion.\n-*/\n+   expansion.  */\n+\n+\n+/* If conservative_reg_partition is non-zero, use a conservative\n+   register partitioning algorithm (which leaves more regs after\n+   emerging from SSA) instead of the coalescing one.  This is being\n+   left in for a limited time only, as a debugging tool until the\n+   coalescing algorithm is validated.  */\n+static int conservative_reg_partition;\n \n+/* This flag is set when the CFG is in SSA form.  */\n+int in_ssa_form = 0;\n \n /* Element I is the single instruction that sets register I+PSEUDO.  */\n varray_type ssa_definition;\n@@ -115,25 +131,40 @@ static void ephi_create\n   PARAMS ((int t, sbitmap visited, sbitmap *pred, sbitmap *succ, rtx *nodes));\n static void eliminate_phi\n   PARAMS ((edge e, partition reg_partition));\n-\n static int make_regs_equivalent_over_bad_edges \n   PARAMS ((int bb, partition reg_partition));\n+\n+/* These are used only in the conservative register partitioning\n+   algorithms.  */\n static int make_equivalent_phi_alternatives_equivalent \n   PARAMS ((int bb, partition reg_partition));\n static partition compute_conservative_reg_partition \n-  PARAMS ((void));\n+  PARAMS (());\n+static int rename_equivalent_regs_in_insn \n+  PARAMS ((rtx *ptr, void *data));\n+\n+/* These are used in the register coalescing algorithm.  */\n+static int coalesce_if_unconflicting\n+  PARAMS ((partition p, conflict_graph conflicts, int reg1, int reg2));\n+static int coalesce_regs_in_copies\n+  PARAMS ((int bb, partition p, conflict_graph conflicts));\n+static int coalesce_reg_in_phi\n+  PARAMS ((rtx, int dest_regno, int src_regno, void *data));\n+static int coalesce_regs_in_successor_phi_nodes\n+  PARAMS ((int bb, partition p, conflict_graph conflicts));\n+static partition compute_coalesced_reg_partition\n+  PARAMS (());\n+static int mark_reg_in_phi \n+  PARAMS ((rtx *ptr, void *data));\n+static void mark_phi_and_copy_regs\n+  PARAMS ((regset phi_set));\n+\n static int rename_equivalent_regs_in_insn \n   PARAMS ((rtx *ptr, void *data));\n static void rename_equivalent_regs \n   PARAMS ((partition reg_partition));\n \n \n-/* Determine if the insn is a PHI node.  */\n-#define PHI_NODE_P(X)\t\t\t\t\\\n-  (X && GET_CODE (X) == INSN\t\t\t\\\n-   && GET_CODE (PATTERN (X)) == SET\t\t\\\n-   && GET_CODE (SET_SRC (PATTERN (X))) == PHI)\n-\n /* Given the SET of a PHI node, return the address of the alternative\n    for predecessor block C.  */\n \n@@ -494,6 +525,15 @@ struct rename_set_data\n   rtx set_dest;\n   rtx new_reg;\n   rtx prev_reg;\n+  rtx set_insn;\n+};\n+\n+/* This struct is used to pass information to callback functions while\n+   renaming registers.  */\n+struct rename_context\n+{\n+  struct rename_set_data *set_data;\n+  rtx current_insn;\n };\n \n static void new_registers_for_updates \n@@ -518,7 +558,8 @@ rename_insn_1 (ptr, data)\n      void *data;\n {\n   rtx x = *ptr;\n-  struct rename_set_data **set_datap = data;\n+  struct rename_context *context = data;\n+  struct rename_set_data **set_datap = &(context->set_data);\n \n   if (x == NULL_RTX)\n     return 0;\n@@ -551,6 +592,7 @@ rename_insn_1 (ptr, data)\n \n \t    r->reg_loc = destp;\n \t    r->set_dest = SET_DEST (x);\n+\t    r->set_insn = context->current_insn;\n \t    r->next = *set_datap;\n \t    *set_datap = r;\n \n@@ -577,7 +619,6 @@ rename_insn_1 (ptr, data)\n \t      if (GET_MODE (x) != GET_MODE (new_reg))\n \t\tabort ();\n \t      *ptr = new_reg;\n-\t      /* ??? Mark for a new ssa_uses entry.  */\n \t    }\n \t  /* Else this is a use before a set.  Warn?  */\n \t}\n@@ -663,12 +704,15 @@ rename_block (bb, idom)\n       insn = next;\n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n-\t  struct rename_set_data *old_set_data = set_data;\n+\t  struct rename_context context;\n+\t  context.set_data = set_data;\n+\t  context.current_insn = insn;\n \n-\t  for_each_rtx (&PATTERN (insn), rename_insn_1, &set_data);\n-\t  for_each_rtx (&REG_NOTES (insn), rename_insn_1, &set_data);\n+\t  for_each_rtx (&PATTERN (insn), rename_insn_1, &context);\n+\t  for_each_rtx (&REG_NOTES (insn), rename_insn_1, &context);\n \t  \n-\t  new_registers_for_updates (set_data, old_set_data, insn);\n+\t  new_registers_for_updates (context.set_data, set_data, insn);\n+\t  set_data = context.set_data;\n \t}\n \n       next = NEXT_INSN (insn);\n@@ -741,9 +785,23 @@ rename_block (bb, idom)\n   while (set_data)\n     {\n       struct rename_set_data *next;\n-      rtx old_reg;\n+      rtx old_reg = *set_data->reg_loc;\n+\n+      /* If the set is of a subreg only, copy the entire reg first so\n+\t that unmodified bits are preserved.  Of course, we don't\n+\t strictly have SSA any more, but that's the best we can do\n+\t without a lot of hard work.  */\n+\n+      if (GET_CODE (set_data->set_dest) == SUBREG) \n+\t{\n+\t  if (old_reg != set_data->new_reg)\n+\t    {\n+\t      rtx copy = gen_rtx_SET (GET_MODE (old_reg), \n+\t\t\t\t      set_data->new_reg, old_reg);\n+\t      emit_insn_before (copy, set_data->set_insn);\n+\t    }\n+\t}\n \n-      old_reg = *set_data->reg_loc;\n       *set_data->reg_loc = set_data->new_reg;\n       ssa_rename_to[REGNO (old_reg)-FIRST_PSEUDO_REGISTER]\n \t= set_data->prev_reg;\n@@ -793,11 +851,18 @@ convert_to_ssa()\n \n   int nregs;\n \n+  /* Don't do it twice.  */\n+  if (in_ssa_form)\n+    abort ();\n+\n   find_basic_blocks (get_insns (), max_reg_num(), NULL);\n-  /* The dominator algorithms assume all blocks are reachable, clean\n+  /* The dominator algorithms assume all blocks are reachable; clean\n      up first.  */\n   cleanup_cfg (get_insns ());\n-  life_analysis (get_insns (), max_reg_num (), NULL, 1);\n+  /* Don't eliminate dead code here.  The CFG we computed above must\n+     remain unchanged until we are finished emerging from SSA form --\n+     the phi node representation depends on it.  */\n+  life_analysis (get_insns (), max_reg_num (), NULL, 0);\n \n   /* Compute dominators.  */\n   dominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n@@ -862,38 +927,13 @@ convert_to_ssa()\n   sbitmap_vector_free (dfs);\n   sbitmap_vector_free (evals);\n   sbitmap_vector_free (idfs);\n-}\n-\n-\n-/* This is intended to be the FIND of a UNION/FIND algorithm managing\n-   the partitioning of the pseudos.  Glancing through the rest of the\n-   global optimizations, it seems things will work out best if the\n-   partition is set up just before convert_from_ssa is called.  See\n-   section 11.4 of Morgan.\n-\n-   ??? Morgan's algorithm, perhaps with some care, may allow copy\n-   propagation to happen concurrently with the conversion from SSA.\n-\n-   However, it presents potential problems with critical edges -- to\n-   split or not to split.  He mentions beginning the partitioning by\n-   unioning registers associated by a PHI across abnormal critical\n-   edges.  This is the approache taken here.  It is unclear to me how\n-   we are able to do that arbitrarily, though.\n-\n-   Alternately, Briggs presents an algorithm in which critical edges\n-   need not be split, at the expense of the creation of new pseudos,\n-   and the need for some concurrent register renaming.  Moreover, it\n-   is ameanable for modification such that the instructions can be\n-   placed anywhere in the target block, which solves the before-call\n-   placement problem.  However, I don't immediately see how we could\n-   do that concurrently with copy propoagation.\n-\n-   More study is required.  */\n+  in_ssa_form = 1;\n \n+  reg_scan (get_insns (), max_reg_num (), 1);\n+  find_basic_blocks (get_insns (), max_reg_num (), NULL);\n+  life_analysis (get_insns (), max_reg_num (), NULL, 0);\n+}\n \n-/*\n- * Eliminate the PHI across the edge from C to B.\n- */\n \n /* REG is the representative temporary of its partition.  Add it to the\n    set of nodes to be processed, if it hasn't been already.  Return the\n@@ -1086,10 +1126,11 @@ eliminate_phi (e, reg_partition)\n       if (GET_CODE (reg) != REG || GET_CODE (tgt) != REG)\n \tabort();\n \n+      reg = regno_reg_rtx[partition_find (reg_partition, REGNO (reg))];\n+      tgt = regno_reg_rtx[partition_find (reg_partition, REGNO (tgt))];\n       /* If the two registers are already in the same partition, \n \t nothing will need to be done.  */\n-      if (partition_find (reg_partition, REGNO (reg)) \n-\t  != partition_find (reg_partition, REGNO (tgt)))\n+      if (reg != tgt)\n \t{\n \t  int ireg, itgt;\n \n@@ -1305,7 +1346,6 @@ make_equivalent_phi_alternatives_equivalent (bb, reg_partition)\n   return changed;\n }\n \n-\n /* Compute a conservative partition of outstanding pseudo registers.\n    See Morgan 7.3.1.  */\n \n@@ -1341,6 +1381,322 @@ compute_conservative_reg_partition ()\n   return p;\n }\n \n+/* The following functions compute a register partition that attempts\n+   to eliminate as many reg copies and phi node copies as possible by\n+   coalescing registers.   This is the strategy:\n+\n+    1. As in the conservative case, the top priority is to coalesce\n+       registers that otherwise would cause copies to be placed on\n+       abnormal critical edges (which isn't possible).\n+\n+    2. Figure out which regs are involved (in the LHS or RHS) of\n+       copies and phi nodes.  Compute conflicts among these regs.  \n+\n+    3. Walk around the instruction stream, placing two regs in the\n+       same class of the partition if one appears on the LHS and the\n+       other on the RHS of a copy or phi node and the two regs don't\n+       conflict.  The conflict information of course needs to be\n+       updated.  \n+\n+    4. If anything has changed, there may be new opportunities to\n+       coalesce regs, so go back to 2.\n+*/\n+\n+/* If REG1 and REG2 don't conflict in CONFLICTS, place them in the\n+   same class of partition P, if they aren't already.  Update\n+   CONFLICTS appropriately.  \n+\n+   Returns one if REG1 and REG2 were placed in the same class but were\n+   not previously; zero otherwise.  \n+\n+   See Morgan figure 11.15.  */\n+\n+static int \n+coalesce_if_unconflicting (p, conflicts, reg1, reg2)\n+     partition p;\n+     conflict_graph conflicts;\n+     int reg1;\n+     int reg2;\n+{\n+  int reg;\n+\n+  /* Don't mess with hard regs.  */\n+  if (reg1 < FIRST_PSEUDO_REGISTER || reg2 < FIRST_PSEUDO_REGISTER)\n+    return 0;\n+\n+  /* Find the canonical regs for the classes containing REG1 and\n+     REG2.  */\n+  reg1 = partition_find (p, reg1);\n+  reg2 = partition_find (p, reg2);\n+  \n+  /* If they're already in the same class, there's nothing to do.  */\n+  if (reg1 == reg2)\n+    return 0;\n+\n+  /* If the regs conflict, our hands are tied.  */\n+  if (conflict_graph_conflict_p (conflicts, reg1, reg2))\n+    return 0;\n+\n+  /* We're good to go.  Put the regs in the same partition.  */\n+  partition_union (p, reg1, reg2);\n+\n+  /* Find the new canonical reg for the merged class.  */\n+  reg = partition_find (p, reg1);\n+  \n+  /* Merge conflicts from the two previous classes.  */\n+  conflict_graph_merge_regs (conflicts, reg, reg1);\n+  conflict_graph_merge_regs (conflicts, reg, reg2);\n+\n+  return 1;\n+}\n+\n+/* For each register copy insn in basic block BB, place the LHS and\n+   RHS regs in the same class in partition P if they do not conflict\n+   according to CONFLICTS.\n+\n+   Returns the number of changes that were made to P.\n+\n+   See Morgan figure 11.14.  */\n+\n+static int\n+coalesce_regs_in_copies (bb, p, conflicts)\n+     int bb;\n+     partition p;\n+     conflict_graph conflicts;\n+{\n+  int changed = 0;\n+  rtx insn;\n+  rtx end = BLOCK_END (bb);\n+\n+  /* Scan the instruction stream of the block.  */\n+  for (insn = BLOCK_HEAD (bb); insn != end; insn = NEXT_INSN (insn))\n+    {\n+      rtx pattern;\n+      rtx src;\n+      rtx dest;\n+\n+      /* If this isn't a set insn, go to the next insn.  */\n+      if (GET_CODE (insn) != INSN)\n+\tcontinue;\n+      pattern = PATTERN (insn);\n+      if (GET_CODE (pattern) != SET)\n+\tcontinue;\n+\n+      src = SET_SRC (pattern);\n+      dest = SET_DEST (pattern);\n+\n+      /* If src or dest are subregs, find the underlying reg.  */\n+      while (GET_CODE (src) == SUBREG\n+\t     && SUBREG_WORD (src) != 0)\n+\tsrc = SUBREG_REG (src);\n+      while (GET_CODE (dest) == SUBREG\n+\t     && SUBREG_WORD (dest) != 0)\n+\tdest = SUBREG_REG (dest);\n+\n+      /* We're only looking for copies.  */\n+      if (GET_CODE (src) != REG || GET_CODE (dest) != REG)\n+\tcontinue;\n+\n+      /* Coalesce only if the reg modes are the same.  As long as\n+\t each reg's rtx is unique, it can have only one mode, so two\n+\t pseudos of different modes can't be coalesced into one.  \n+\n+         FIXME: We can probably get around this by inserting SUBREGs\n+         where appropriate, but for now we don't bother.  */\n+      if (GET_MODE (src) != GET_MODE (dest))\n+\tcontinue;\n+\n+      /* Found a copy; see if we can use the same reg for both the\n+\t source and destination (and thus eliminate the copy,\n+\t ultimately).  */\n+      changed += coalesce_if_unconflicting (p, conflicts, \n+\t\t\t\t\t    REGNO (src), REGNO (dest));\n+    }\n+\n+  return changed;\n+}\n+\n+\n+struct phi_coalesce_context\n+{\n+  partition p;\n+  conflict_graph conflicts;\n+  int changed;\n+};\n+\n+/* Callback function for for_each_successor_phi.  If the set\n+   destination and the phi alternative regs do not conflict, place\n+   them in the same paritition class.  DATA is a pointer to a\n+   phi_coalesce_context struct.  */\n+\n+static int\n+coalesce_reg_in_phi (insn, dest_regno, src_regno, data)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     int dest_regno;\n+     int src_regno;\n+     void *data;\n+{\n+  struct phi_coalesce_context *context = \n+    (struct phi_coalesce_context *) data;\n+  \n+  /* Attempt to use the same reg, if they don't conflict.  */\n+  context->changed \n+    += coalesce_if_unconflicting (context->p, context->conflicts, \n+\t\t\t\t  dest_regno, src_regno);\n+  return 0;\n+}\n+\n+/* For each alternative in a phi function corresponding to basic block\n+   BB (in phi nodes in successor block to BB), place the reg in the\n+   phi alternative and the reg to which the phi value is set into the\n+   same class in partition P, if allowed by CONFLICTS.  \n+\n+   Return the number of changes that were made to P.\n+   \n+   See Morgan figure 11.14.  */\n+\n+static int\n+coalesce_regs_in_successor_phi_nodes (bb, p, conflicts)\n+     int bb;\n+     partition p;\n+     conflict_graph conflicts;\n+{\n+  struct phi_coalesce_context context;\n+  context.p = p;\n+  context.conflicts = conflicts;\n+  context.changed = 0;\n+\n+  for_each_successor_phi (bb, &coalesce_reg_in_phi, &context);\n+\n+  return context.changed;\n+}\n+\n+/* Compute and return a partition of pseudos.  Where possible,\n+   non-conflicting pseudos are placed in the same class.  \n+\n+   The caller is responsible for deallocating the returned partition.  */\n+\n+static partition\n+compute_coalesced_reg_partition ()\n+{\n+  int bb;\n+  int changed = 0;\n+\n+  /* We don't actually work with hard registers, but it's easier to\n+     carry them around anyway rather than constantly doing register\n+     number arithmetic.  */\n+  partition p = \n+    partition_new (ssa_definition->num_elements + FIRST_PSEUDO_REGISTER);\n+\n+  /* The first priority is to make sure registers that might have to\n+     be copied on abnormal critical edges are placed in the same\n+     partition.  This saves us from having to split abnormal critical\n+     edges (which can't be done).  */\n+  for (bb = n_basic_blocks; --bb >= 0; )\n+    make_regs_equivalent_over_bad_edges (bb, p);\n+\n+  do\n+    {\n+      regset_head phi_set;\n+      conflict_graph conflicts;\n+\n+      changed = 0;\n+\n+      /* Build the set of registers involved in phi nodes, either as\n+\t arguments to the phi function or as the target of a set.  */\n+      INITIALIZE_REG_SET (phi_set);\n+      mark_phi_and_copy_regs (&phi_set);\n+\n+      /* Compute conflicts.  */\n+      conflicts = conflict_graph_compute (&phi_set, p);\n+\n+      /* FIXME: Better would be to process most frequently executed\n+\t blocks first, so that most frequently executed copies would\n+\t be more likely to be removed by register coalescing.  But any\n+\t order will generate correct, if non-optimal, results.  */\n+      for (bb = n_basic_blocks; --bb >= 0; )\n+\t{\n+\t  changed += coalesce_regs_in_copies (bb, p, conflicts);\n+\t  changed += coalesce_regs_in_successor_phi_nodes (bb, p, conflicts);\n+\t}\n+\n+      conflict_graph_delete (conflicts);\n+    }\n+  while (changed > 0);\n+\n+  return p;\n+}\n+\n+/* Mark the regs in a phi node.  PTR is a phi expression or one of its\n+   components (a REG or a CONST_INT).  DATA is a reg set in which to\n+   set all regs.  Called from for_each_rtx.  */\n+\n+static int\n+mark_reg_in_phi (ptr, data)\n+     rtx *ptr;\n+     void *data;\n+{\n+  rtx expr = *ptr;\n+  regset set = (regset) data;\n+\n+  switch (GET_CODE (expr))\n+    {\n+    case REG:\n+      SET_REGNO_REG_SET (set, REGNO (expr));\n+      /* Fall through.  */\n+    case CONST_INT:\n+    case PHI:\n+      return 0;\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* Mark in PHI_SET all pseudos that are used in a phi node -- either\n+   set from a phi expression, or used as an argument in one.  Also\n+   mark regs that are the source or target of a reg copy.  Uses\n+   ssa_definition.  */\n+\n+static void\n+mark_phi_and_copy_regs (phi_set)\n+     regset phi_set;\n+{\n+  int reg;\n+\n+  /* Scan the definitions of all regs.  */\n+  for (reg = VARRAY_SIZE (ssa_definition); \n+       --reg >= FIRST_PSEUDO_REGISTER; \n+       ) \n+    {\n+      rtx insn = VARRAY_RTX (ssa_definition, reg);\n+      rtx pattern;\n+      rtx src;\n+\n+      if (insn == NULL)\n+\tcontinue;\n+      pattern = PATTERN (insn);\n+      /* Sometimes we get PARALLEL insns.  These aren't phi nodes or\n+\t copies.  */\n+      if (GET_CODE (pattern) != SET)\n+\tcontinue;\n+      src = SET_SRC (pattern);\n+\n+      if (GET_CODE (src) == REG)\n+\t{\n+\t  /* It's a reg copy.  */\n+\t  SET_REGNO_REG_SET (phi_set, reg);\n+\t  SET_REGNO_REG_SET (phi_set, REGNO (src));\n+\t}\n+      else if (GET_CODE (src) == PHI)\n+\t{\n+\t  /* It's a phi node.  Mark the reg being set.  */\n+\t  SET_REGNO_REG_SET (phi_set, reg);\n+\t  /* Mark the regs used in the phi function.  */\n+\t  for_each_rtx (&src, mark_reg_in_phi, phi_set);\n+\t}\n+      /* ... else nothing to do.  */\n+    }\n+}\n \n /* Rename regs in insn PTR that are equivalent.  DATA is the register\n    partition which specifies equivalences.  */\n@@ -1379,7 +1735,7 @@ rename_equivalent_regs_in_insn (ptr, data)\n \t    int regno = REGNO (dest);\n \t    int new_regno = partition_find (reg_partition, regno);\n \t    if (regno != new_regno)\n-\t      *destp = regno_reg_rtx [new_regno];\n+\t      *destp = regno_reg_rtx[new_regno];\n \n \t    for_each_rtx (&SET_SRC (x), \n \t\t\t  rename_equivalent_regs_in_insn, \n@@ -1418,7 +1774,6 @@ rename_equivalent_regs_in_insn (ptr, data)\n     }\n }\n \n-\n /* Rename regs that are equivalent in REG_PARTITION.  */\n \n static void\n@@ -1453,16 +1808,26 @@ rename_equivalent_regs (reg_partition)\n     }\n }\n \n-\n /* The main entry point for moving from SSA.  */\n \n void\n convert_from_ssa()\n {\n   int bb;\n   partition reg_partition;\n-  \n-  reg_partition = compute_conservative_reg_partition ();\n+  rtx insns = get_insns ();\n+    \n+  /* We need up-to-date life information.  */\n+  find_basic_blocks (insns, max_reg_num (), NULL);\n+  life_analysis (insns, max_reg_num (), NULL, 0);\n+\n+  /* Figure out which regs in copies and phi nodes don't conflict and\n+     therefore can be coalesced.  */\n+  if (conservative_reg_partition)\n+    reg_partition = compute_conservative_reg_partition ();\n+  else\n+    reg_partition = compute_coalesced_reg_partition ();\n+\n   rename_equivalent_regs (reg_partition);\n \n   /* Eliminate the PHI nodes.  */\n@@ -1488,6 +1853,11 @@ convert_from_ssa()\n \tinsn = next_nonnote_insn (insn);\n       while (PHI_NODE_P (insn))\n \t{\n+\t  /* If a phi node is the last insn in the block, there must\n+\t     have been nothing else.  Set the block end to the block\n+\t     head.  */\n+\t  if (insn == BLOCK_END (bb))\n+\t    BLOCK_END (bb) = BLOCK_HEAD (bb);\n \t  insn = delete_insn (insn);\n \t  if (GET_CODE (insn) == NOTE)\n \t    insn = next_nonnote_insn (insn);\n@@ -1499,5 +1869,80 @@ convert_from_ssa()\n   /* Commit all the copy nodes needed to convert out of SSA form.  */\n   commit_edge_insertions ();\n \n+  in_ssa_form = 0;\n+\n   count_or_remove_death_notes (NULL, 1);\n }\n+\n+/* Scan phi nodes in successors to BB.  For each such phi node that\n+   has a phi alternative value corresponding to BB, invoke FN.  FN\n+   is passed the entire phi node insn, the regno of the set\n+   destination, the regno of the phi argument corresponding to BB,\n+   and DATA.\n+\n+   If FN ever returns non-zero, stops immediately and returns this\n+   value.  Otherwise, returns zero.  */\n+\n+int\n+for_each_successor_phi (bb, fn, data)\n+     int bb;\n+     successor_phi_fn fn;\n+     void *data;\n+{\n+  basic_block block;\n+  edge e;\n+  \n+  if (bb == EXIT_BLOCK)\n+    return 0;\n+  else if (bb == ENTRY_BLOCK)\n+    block = ENTRY_BLOCK_PTR;\n+  else\n+    block = BASIC_BLOCK (bb);\n+\n+  /* Scan outgoing edges.  */\n+  for (e = block->succ; e != NULL; e = e->succ_next)\n+    {\n+      rtx insn;\n+\n+      basic_block successor = e->dest;\n+      if (successor->index == ENTRY_BLOCK \n+\t  || successor->index == EXIT_BLOCK)\n+\tcontinue;\n+\n+      /* Advance to the first non-label insn of the successor block.  */\n+      insn = successor->head;\n+      while (insn != NULL \n+\t     && (GET_CODE (insn) == CODE_LABEL\n+\t\t || GET_CODE (insn) == NOTE))\n+\tinsn = NEXT_INSN (insn);\n+\n+      if (insn == NULL)\n+\tcontinue;\n+\n+      /* Scan phi nodes in the successor.  */\n+      for ( ; PHI_NODE_P (insn); insn = NEXT_INSN (insn))\n+\t{\n+\t  int result;\n+\t  rtx phi_set = PATTERN (insn);\n+\t  rtx *alternative = phi_alternative (phi_set, block->index);\n+\t  rtx phi_src;\n+\t  \n+\t  /* This phi function may not have an alternative\n+\t     corresponding to the incoming edge, indicating the\n+\t     assigned variable is not defined along the edge.  */\n+\t  if (alternative == NULL)\n+\t    continue;\n+\t  phi_src = *alternative;\n+\n+\t  /* Invoke the callback.  */\n+\t  result = (*fn) (insn, REGNO (SET_DEST (phi_set)), \n+\t\t\t  REGNO (phi_src), data);\n+\n+\t  /* Terminate if requested.  */\n+\t  if (result != 0)\n+\t    return result;\n+\t}\n+    }\n+\n+  return 0;\n+}"}, {"sha": "df5a764da149e39a9da9c2fce2a2713ed164cada", "filename": "gcc/toplev.c", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e872036e8a62e1b7c3dbfa54cc7584fd61831b2/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4e872036e8a62e1b7c3dbfa54cc7584fd61831b2", "patch": "@@ -1426,6 +1426,8 @@ int reorder_blocks_time;\n int rename_registers_time;\n int shorten_branch_time;\n int stack_reg_time;\n+int to_ssa_time;\n+int from_ssa_time;\n int final_time;\n int symout_time;\n int dump_time;\n@@ -1510,9 +1512,9 @@ print_time (str, total)\n      int total;\n {\n   fprintf (stderr,\n-\t   \"time in %s: %d.%06d (%.0f%%)\\n\",\n+\t   \"time in %s: %d.%06d (%d%%)\\n\",\n \t   str, total / 1000000, total % 1000000,\n-\t   all_time == 0 ? 0.00 : (double) total / (double) all_time * 100.0);\n+\t   all_time == 0 ? 0 : (100 * total) / all_time);\n }\n \n /* This is the default decl_printable_name function.  */\n@@ -1890,6 +1892,26 @@ close_dump_file (index, func, insns)\n      });\n }\n \n+/* Routine to empty a dump file.  */\n+static void\n+clean_dump_file (suffix)\n+  const char *suffix;\n+{\n+  char * const dumpname = concat (dump_base_name, suffix, NULL);\n+\n+  rtl_dump_file = fopen (dumpname, \"w\");\n+\n+  if (rtl_dump_file == NULL)\n+    pfatal_with_name (dumpname);       \n+\n+  free (dumpname);\n+\n+  fclose (rtl_dump_file);\n+  rtl_dump_file = NULL;\n+  \n+  return;\n+}\n+\n /* Do any final processing required for the declarations in VEC, of\n    which there are LEN.  We write out inline functions and variables\n    that have been deferred until this point, but which are required.\n@@ -2176,6 +2198,8 @@ compile_file (name)\n   rename_registers_time = 0;\n   shorten_branch_time = 0;\n   stack_reg_time = 0;\n+  to_ssa_time = 0;\n+  from_ssa_time = 0;\n   final_time = 0;\n   symout_time = 0;\n   dump_time = 0;\n@@ -2559,6 +2583,8 @@ compile_file (name)\n       print_time (\"integration\", integration_time);\n       print_time (\"jump\", jump_time);\n       print_time (\"cse\", cse_time);\n+      print_time (\"to ssa\", to_ssa_time);\n+      print_time (\"from ssa\", from_ssa_time);\n       print_time (\"gcse\", gcse_time);\n       print_time (\"loop\", loop_time);\n       print_time (\"cse2\", cse2_time);\n@@ -3032,11 +3058,11 @@ rest_of_compilation (decl)\n   if (flag_ssa)\n     {\n       open_dump_file (DFI_ssa, decl);\n-      convert_to_ssa ();\n+      TIMEVAR (to_ssa_time, convert_to_ssa ());\n       close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n \n       open_dump_file (DFI_ussa, decl);\n-      convert_from_ssa ();\n+      TIMEVAR (from_ssa_time, convert_from_ssa ());\n       /* New registers have been created.  Rescan their usage.  */\n       reg_scan (insns, max_reg_num (), 1);\n       close_dump_file (DFI_ussa, print_rtl_with_bb, insns);"}]}