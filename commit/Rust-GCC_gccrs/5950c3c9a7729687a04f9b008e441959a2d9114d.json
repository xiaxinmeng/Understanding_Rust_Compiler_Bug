{"sha": "5950c3c9a7729687a04f9b008e441959a2d9114d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTk1MGMzYzlhNzcyOTY4N2EwNGY5YjAwOGU0NDE5NTlhMmQ5MTE0ZA==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2008-07-14T05:09:48Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2008-07-14T05:09:48Z"}, "message": "cpplib.h (NODE_CONDITIONAL): New.\n\nlibcpp/\n\t* include/cpplib.h (NODE_CONDITIONAL): New.\n\t(struct cpp_callbacks): New macro_to_expand field.\n\t(struct cpp_hashnode): Adjust size of flags and type fields.\n\t(cpp_peek_token): Prototype.\n\t* lex.c (cpp_peek_token): New function.\n\t(_cpp_temp_token): Protect pre-existing lookaheads.\n\t* macro.c (cpp_get_token): Expand any conditional macros.\n\t(_cpp_backup_tokens_direct): New.\n\t(_cpp_backup_tokens): Call _cpp_backup_tokens_direct.\n\t(warn_of_redefinition): Silently allow redefined conditional\n\tmacros.\n\t(_cpp_create_definition): Remove the conditional flag when a user\n\tdefines one of the conditional macros.\n\t* internal.h (_cpp_backup_tokens_direct): New prototype.\n\ngcc/\n\t* c-common.h (C_CPP_HASHNODE): New macro.\n\t* coretypes.h (struct cpp_token): Forward declare.\n\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document\n\tthe context-sensitive keyword method.\n\t* config/rs6000/rs6000-c.c (__vector_keyword, vector_keyword,\n\t__pixel_keyword, pixel_keyword, __bool_keyword, bool_keyword,\n\texpand_bool_pixel): New.\n\t(altivec_categorize_keyword): New function.\n\t(init_vector_keywords): New function.\n\t(rs6000_macro_to_expand): Likewise.\n\t(rs6000_cpu_cpp_builtins): Enable context-sensitive macros if not\n\tcompiling an ISO C dialect.\n\ngcc/testsuite/\n\t* gcc.target/powerpc/altivec-macros.c: New test.\n\t* gcc.target/powerpc/altviec-26.c: Likewise.\n\t* gcc.dg/vmx/1b-06.c: Remove bool variable.\n\t* gcc.dg/vmx/1b-07.c: Likewise.\n\t* gcc.dg/vmx/1b-06-ansi.c: New test for the pre-define method.\n\t* gcc.dg/vmx/1b-07-ansi.c: Likewise.\n\nFrom-SVN: r137775", "tree": {"sha": "5549f4ccea5a3b85211df500d0617fd3866b139f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5549f4ccea5a3b85211df500d0617fd3866b139f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5950c3c9a7729687a04f9b008e441959a2d9114d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5950c3c9a7729687a04f9b008e441959a2d9114d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5950c3c9a7729687a04f9b008e441959a2d9114d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5950c3c9a7729687a04f9b008e441959a2d9114d/comments", "author": null, "committer": null, "parents": [{"sha": "b463e8de6c7e9c7fe8ad2f4f4be126f58b23c07a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b463e8de6c7e9c7fe8ad2f4f4be126f58b23c07a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b463e8de6c7e9c7fe8ad2f4f4be126f58b23c07a"}], "stats": {"total": 502, "additions": 475, "deletions": 27}, "files": [{"sha": "c946bb08659074c2303c083c051fcfbe1aae47d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -1,3 +1,18 @@\n+2008-07-14  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* c-common.h (C_CPP_HASHNODE): New macro.\n+\t* coretypes.h (struct cpp_token): Forward declare.\n+\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document\n+\tthe context-sensitive keyword method.\n+\t* config/rs6000/rs6000-c.c (__vector_keyword, vector_keyword,\n+\t__pixel_keyword, pixel_keyword, __bool_keyword, bool_keyword,\n+\texpand_bool_pixel): New.\n+\t(altivec_categorize_keyword): New function.\n+\t(init_vector_keywords): New function.\n+\t(rs6000_macro_to_expand): Likewise.\n+\t(rs6000_cpu_cpp_builtins): Enable context-sensitive macros if not\n+\tcompiling an ISO C dialect.\n+\n 2008-07-13  Daniel Berlin  <dberlin@dberlin.org>\n \n \t* tree-ssa-pre.c (fully_constant_expression): Add fold_convert"}, {"sha": "486fdeb8811683702e68531ab125caf06022fec7", "filename": "gcc/c-common.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -188,6 +188,8 @@ enum c_tree_index\n     CTI_MAX\n };\n \n+#define C_CPP_HASHNODE(id) \\\n+  (&(((struct c_common_identifier *) (id))->node))\n #define C_RID_CODE(id) \\\n   ((enum rid) (((struct c_common_identifier *) (id))->node.rid_code))\n #define C_SET_RID_CODE(id, code) \\"}, {"sha": "ce1ec4b9665c564ddcbf60b221c375eae97a870e", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 157, "deletions": 0, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -84,6 +84,149 @@ rs6000_pragma_longcall (cpp_reader *pfile ATTRIBUTE_UNUSED)\n #define builtin_define(TXT) cpp_define (pfile, TXT)\n #define builtin_assert(TXT) cpp_assert (pfile, TXT)\n \n+/* Keep the AltiVec keywords handy for fast comparisons.  */\n+static tree __vector_keyword;\n+static tree vector_keyword;\n+static tree __pixel_keyword;\n+static tree pixel_keyword;\n+static tree __bool_keyword;\n+static tree bool_keyword;\n+\n+/* Preserved across calls.  */\n+static tree expand_bool_pixel;\n+\n+static cpp_hashnode *\n+altivec_categorize_keyword (const cpp_token *tok)\n+{\n+  if (tok->type == CPP_NAME)\n+    {\n+      cpp_hashnode *ident = tok->val.node;\n+\n+      if (ident == C_CPP_HASHNODE (vector_keyword)\n+\t  || ident == C_CPP_HASHNODE (__vector_keyword))\n+\treturn C_CPP_HASHNODE (__vector_keyword);\n+\n+      if (ident == C_CPP_HASHNODE (pixel_keyword)\n+\t  || ident ==  C_CPP_HASHNODE (__pixel_keyword))\n+\treturn C_CPP_HASHNODE (__pixel_keyword);\n+\n+      if (ident == C_CPP_HASHNODE (bool_keyword)\n+\t  || ident == C_CPP_HASHNODE (__bool_keyword))\n+\treturn C_CPP_HASHNODE (__bool_keyword);\n+\n+      return ident;\n+    }\n+\n+  return 0;\n+}\n+\n+static void\n+init_vector_keywords (void)\n+{\n+  /* Keywords without two leading underscores are context-sensitive,\n+     and hence implemented as conditional macros, controlled by the\n+     rs6000_macro_to_expand() function below.  */\n+\n+  __vector_keyword = get_identifier (\"__vector\");\n+  C_CPP_HASHNODE (__vector_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  __pixel_keyword = get_identifier (\"__pixel\");\n+  C_CPP_HASHNODE (__pixel_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  __bool_keyword = get_identifier (\"__bool\");\n+  C_CPP_HASHNODE (__bool_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  vector_keyword = get_identifier (\"vector\");\n+  C_CPP_HASHNODE (vector_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  pixel_keyword = get_identifier (\"pixel\");\n+  C_CPP_HASHNODE (pixel_keyword)->flags |= NODE_CONDITIONAL;\n+\n+  bool_keyword = get_identifier (\"bool\");\n+  C_CPP_HASHNODE (bool_keyword)->flags |= NODE_CONDITIONAL;\n+}\n+\n+/* Called to decide whether a conditional macro should be expanded.\n+   Since we have exactly one such macro (i.e, 'vector'), we do not\n+   need to examine the 'tok' parameter.  */\n+\n+static cpp_hashnode *\n+rs6000_macro_to_expand (cpp_reader *pfile, const cpp_token *tok)\n+{\n+  cpp_hashnode *expand_this = tok->val.node;\n+  cpp_hashnode *ident;\n+\n+  ident = altivec_categorize_keyword (tok);\n+\n+  if (ident == C_CPP_HASHNODE (__vector_keyword))\n+    {\n+      tok = cpp_peek_token (pfile, 0);\n+      ident = altivec_categorize_keyword (tok);\n+\n+      if (ident ==  C_CPP_HASHNODE (__pixel_keyword))\n+\t{\n+\t  expand_this = C_CPP_HASHNODE (__vector_keyword);\n+\t  expand_bool_pixel = __pixel_keyword;\n+\t}\n+      else if (ident == C_CPP_HASHNODE (__bool_keyword))\n+\t{\n+\t  expand_this = C_CPP_HASHNODE (__vector_keyword);\n+\t  expand_bool_pixel = __bool_keyword;\n+\t}\n+      else if (ident)\n+\t{\n+\t  enum rid rid_code = (enum rid)(ident->rid_code);\n+\t  if (ident->type == NT_MACRO)\n+\t    {\n+\t      (void)cpp_get_token (pfile);\n+\t      tok = cpp_peek_token (pfile, 0);\n+\t      ident = altivec_categorize_keyword (tok);\n+\t      if (ident)\n+\t\trid_code = (enum rid)(ident->rid_code);\n+\t    }\n+\n+\t  if (rid_code == RID_UNSIGNED || rid_code == RID_LONG\n+\t      || rid_code == RID_SHORT || rid_code == RID_SIGNED\n+\t      || rid_code == RID_INT || rid_code == RID_CHAR\n+\t      || rid_code == RID_FLOAT)\n+\t    {\n+\t      expand_this = C_CPP_HASHNODE (__vector_keyword);\n+\t      /* If the next keyword is bool or pixel, it\n+\t\t will need to be expanded as well.  */\n+\t      tok = cpp_peek_token (pfile, 1);\n+\t      ident = altivec_categorize_keyword (tok);\n+\n+\t      if (ident ==  C_CPP_HASHNODE (__pixel_keyword))\n+\t\texpand_bool_pixel = __pixel_keyword;\n+\t      else if (ident == C_CPP_HASHNODE (__bool_keyword))\n+\t\texpand_bool_pixel = __bool_keyword;\n+\t      else\n+\t\t{\n+\t\t  /* Try two tokens down, too.  */\n+\t\t  tok = cpp_peek_token (pfile, 2);\n+\t\t  ident = altivec_categorize_keyword (tok);\n+\t\t  if (ident ==  C_CPP_HASHNODE (__pixel_keyword))\n+\t\t    expand_bool_pixel = __pixel_keyword;\n+\t\t  else if (ident == C_CPP_HASHNODE (__bool_keyword))\n+\t\t    expand_bool_pixel = __bool_keyword;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  else if (expand_bool_pixel && ident == C_CPP_HASHNODE (__pixel_keyword))\n+    {\n+      expand_this = C_CPP_HASHNODE (__pixel_keyword);\n+      expand_bool_pixel = 0;\n+    }\n+  else if (expand_bool_pixel && ident == C_CPP_HASHNODE (__bool_keyword))\n+    {\n+      expand_this = C_CPP_HASHNODE (__bool_keyword);\n+      expand_bool_pixel = 0;\n+    }\n+\n+  return expand_this;\n+}\n+\n void\n rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n {\n@@ -120,6 +263,20 @@ rs6000_cpu_cpp_builtins (cpp_reader *pfile)\n       builtin_define (\"__vector=__attribute__((altivec(vector__)))\");\n       builtin_define (\"__pixel=__attribute__((altivec(pixel__))) unsigned short\");\n       builtin_define (\"__bool=__attribute__((altivec(bool__))) unsigned\");\n+\n+      if (!flag_iso)\n+\t{\n+\t  /* Define this when supporting context-sensitive keywords.  */\n+\t  builtin_define (\"__APPLE_ALTIVEC__\");\n+\t  \n+\t  builtin_define (\"vector=vector\");\n+\t  builtin_define (\"pixel=pixel\");\n+\t  builtin_define (\"bool=bool\");\n+\t  init_vector_keywords ();\n+\n+\t  /* Enable context-sensitive macros.  */\n+\t  cpp_get_callbacks (pfile)->macro_to_expand = rs6000_macro_to_expand;\n+\t}\n     }\n   if (TARGET_SPE)\n     builtin_define (\"__SPE__\");"}, {"sha": "f585eb411c6b4f31df21fc85c94b9132a2515ede", "filename": "gcc/coretypes.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -60,9 +60,11 @@ enum ir_type {\n \n /* Provide forward struct declaration so that we don't have to include\n    all of cpplib.h whenever a random prototype includes a pointer.\n-   Note that the cpp_reader typedef remains part of cpplib.h.  */\n+   Note that the cpp_reader and cpp_token typedefs remain part of\n+   cpplib.h.  */\n \n struct cpp_reader;\n+struct cpp_token;\n \n /* The thread-local storage model associated with a given VAR_DECL\n    or SYMBOL_REF.  This isn't used much, but both trees and RTL refer"}, {"sha": "eecb4ca5bf4ea4a094cd49eb9fd6526fc0cb44f9", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -9120,9 +9120,10 @@ always specify the signedness.\n \n @item\n Compiling with @option{-maltivec} adds keywords @code{__vector},\n-@code{__pixel}, and @code{__bool}.  Macros @option{vector},\n-@code{pixel}, and @code{bool} are defined in @code{<altivec.h>} and can\n-be undefined.\n+@code{vector}, @code{__pixel}, @code{pixel}, @code{__bool} and\n+@code{bool}.  When compiling ISO C, the context-sensitive substitution\n+of the keywords @code{vector}, @code{pixel} and @code{bool} is\n+disabled.  To use them, you must include @code{<altivec.h>} instead.\n \n @item\n GCC allows using a @code{typedef} name as the type specifier for a"}, {"sha": "0bf9bd31d3b919d14bf171f2042a62228de38b03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -1,3 +1,12 @@\n+2008-07-14  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* gcc.target/powerpc/altivec-macros.c: New test.\n+\t* gcc.target/powerpc/altviec-26.c: Likewise.\n+\t* gcc.dg/vmx/1b-06.c: Remove bool variable.\n+\t* gcc.dg/vmx/1b-07.c: Likewise.\n+\t* gcc.dg/vmx/1b-06-ansi.c: New test for the pre-define method.\n+\t* gcc.dg/vmx/1b-07-ansi.c: Likewise.\n+\n 2008-07-14  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR fortran/36725"}, {"sha": "780a4e6bc68487c1b4c7793fd52a1199623bead7", "filename": "gcc/testsuite/gcc.dg/vmx/1b-06-ansi.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06-ansi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06-ansi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06-ansi.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ansi -maltivec\" } */\n+\n+#include <altivec.h>\n+vector char bool _4 ;\n+vector char unsigned _31 ;\n+vector char signed _59 ;\n+/* bool is permitted in the predefine method, as it is expanded\n+   unconditionally to int.  */\n+bool _84 ;\n+vector pixel _89 ;\n+vector int bool _95 ;\n+vector short bool _102 ;\n+vector unsigned int _122 ;\n+vector unsigned short _129 ;\n+vector signed int _150 ;\n+vector signed short _157 ;\n+vector int bool _179 ;\n+vector int short bool _186 ;\n+vector unsigned int _206 ;\n+vector int unsigned short _213 ;\n+vector signed int _234 ;\n+vector int signed short _241 ;\n+vector float _339 ;"}, {"sha": "d25164c3151ecfe4d36daa93f85dbf3ee44af17e", "filename": "gcc/testsuite/gcc.dg/vmx/1b-06.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-06.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -3,7 +3,6 @@\n vector char bool _4 ;\n vector char unsigned _31 ;\n vector char signed _59 ;\n-bool _84 ;\n vector pixel _89 ;\n vector int bool _95 ;\n vector short bool _102 ;"}, {"sha": "cfc98639b55c5f076ce9cb08e48e5da612cf1afc", "filename": "gcc/testsuite/gcc.dg/vmx/1b-07-ansi.c", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07-ansi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07-ansi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07-ansi.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -0,0 +1,59 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-ansi -maltivec\" } */\n+\n+#include <altivec.h>\n+vector char bool _0 ;\n+vector bool char _8 ;\n+vector char unsigned _56 ;\n+vector unsigned char _64 ;\n+vector char signed _112 ;\n+vector signed char _120 ;\n+/* bool is permitted in the predefine method, as it is expanded\n+   unconditionally to int.  */\n+bool _168 ;\n+vector pixel _170 ;\n+vector int bool _178 ;\n+vector bool int _186 ;\n+vector short bool _234 ;\n+vector bool short _242 ;\n+vector unsigned int _290 ;\n+vector int unsigned _298 ;\n+vector unsigned short _346 ;\n+vector short unsigned _354 ;\n+vector signed int _402 ;\n+vector int signed _410 ;\n+vector signed short _458 ;\n+vector short signed _466 ;\n+vector int bool _514 ;\n+vector int bool _544 ;\n+vector int bool _559 ;\n+vector bool int _589 ;\n+vector int short bool _874 ;\n+vector int bool short _889 ;\n+vector short int bool _904 ;\n+vector short bool int _919 ;\n+vector bool int short _934 ;\n+vector bool short int _949 ;\n+vector unsigned int _1234 ;\n+vector int unsigned _1249 ;\n+vector unsigned int _1279 ;\n+vector int unsigned _1294 ;\n+vector unsigned int _1309 ;\n+vector int unsigned short _1594 ;\n+vector int short unsigned _1609 ;\n+vector unsigned int short _1624 ;\n+vector unsigned short int _1639 ;\n+vector short int unsigned _1654 ;\n+vector short unsigned int _1669 ;\n+vector signed int _1954 ;\n+vector int signed _1969 ;\n+vector signed int _1999 ;\n+vector int signed _2014 ;\n+vector signed int _2029 ;\n+vector int signed short _2314 ;\n+vector int short signed _2329 ;\n+vector signed int short _2344 ;\n+vector signed short int _2359 ;\n+vector short int signed _2374 ;\n+vector short signed int _2389 ;\n+vector float _2674 ;"}, {"sha": "44bf4029f0853f076e15b10406c08db41637b5fd", "filename": "gcc/testsuite/gcc.dg/vmx/1b-07.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvmx%2F1b-07.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -6,7 +6,6 @@ vector char unsigned _56 ;\n vector unsigned char _64 ;\n vector char signed _112 ;\n vector signed char _120 ;\n-bool _168 ;\n vector pixel _170 ;\n vector int bool _178 ;\n vector bool int _186 ;"}, {"sha": "689d13a514f0ec6e208424d4308f256788bf1b7b", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-26.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-26.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile { target powerpc*-*-* } } */\n+/* { dg-require-effective-target powerpc_altivec_ok } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* A compiler implementing context-sensitive keywords must define this\n+   preprocessor macro so that altivec.h does not provide the vector,\n+   pixel, etc. macros.  */\n+\n+#ifndef __APPLE_ALTIVEC__\n+#error __APPLE_ALTIVEC__ not pre-defined\n+#endif"}, {"sha": "d95a68dd966e85aab5700cedcbdf7e6f8dddcefe", "filename": "gcc/testsuite/gcc.target/powerpc/altivec-macros.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-macros.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-macros.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Faltivec-macros.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -0,0 +1,63 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+/* { dg-options \"-maltivec\" } */\n+\n+/* Conditional macros should not be expanded by pragmas.  */\n+#pragma __vector\n+_Pragma (\"__vector\")\n+\n+/* Redefinition of conditional macros.  */\n+/* No warning should be generated.  */\n+\n+#define __vector __new_vector\n+#define __pixel __new_pixel\n+#define __bool __new_bool\n+#define vector new_vector\n+#define pixel new_pixel\n+#define bool new_bool\n+\n+/* Definition of conditional macros.  */\n+/* No warning should be generated.  */\n+\n+#undef __vector\n+#define __vector __new_vector\n+\n+#undef __pixel\n+#define __pixel __new_pixel\n+\n+#undef __bool\n+#define __bool __new_bool\n+\n+#undef vector\n+#define vector new_vector\n+\n+#undef pixel\n+#define pixel new_pixel\n+\n+#undef bool\n+#define bool new_bool\n+\n+/* Re-definition of \"unconditional\" macros.  */\n+/* Warnings should be generated as usual.  */\n+\n+#define __vector\t__newer_vector\n+#define __pixel\t\t__newer_pixel\n+#define __bool\t\t__newer_bool\n+#define vector\t\tnewer_vector\n+#define pixel\t\tnewer_pixel\n+#define bool\t\tnewer_bool\n+\n+/* { dg-warning \"redefined\" \"__vector redefined\"  { target *-*-* } 44 } */\n+/* { dg-warning \"redefined\" \"__pixel redefined\"   { target *-*-* } 45 } */\n+/* { dg-warning \"redefined\" \"__bool redefined\"    { target *-*-* } 46 } */\n+/* { dg-warning \"redefined\" \"vector redefined\"    { target *-*-* } 47 } */\n+/* { dg-warning \"redefined\" \"pixel redefined\"     { target *-*-* } 48 } */\n+/* { dg-warning \"redefined\" \"bool redefined\"      { target *-*-* } 49 } */\n+\n+/* { dg-warning \"previous\"  \"prev __vector defn\"  { target *-*-* } 24 } */\n+/* { dg-warning \"previous\"  \"prev __pixel defn\"   { target *-*-* } 27 } */\n+/* { dg-warning \"previous\"  \"prev __bool defn\"    { target *-*-* } 30 } */\n+/* { dg-warning \"previous\"  \"prev vector defn\"    { target *-*-* } 33 } */\n+/* { dg-warning \"previous\"  \"prev pixel defn\"     { target *-*-* } 36 } */\n+/* { dg-warning \"previous\"  \"prev bool defn\"      { target *-*-* } 39 } */"}, {"sha": "9b3b53e25de5a52f7ad857c513f04f213cc0dfee", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -1,3 +1,20 @@\n+2008-07-14  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* include/cpplib.h (NODE_CONDITIONAL): New.\n+\t(struct cpp_callbacks): New macro_to_expand field.\n+\t(struct cpp_hashnode): Adjust size of flags and type fields.\n+\t(cpp_peek_token): Prototype.\n+\t* lex.c (cpp_peek_token): New function.\n+\t(_cpp_temp_token): Protect pre-existing lookaheads.\n+\t* macro.c (cpp_get_token): Expand any conditional macros.\n+\t(_cpp_backup_tokens_direct): New.\n+\t(_cpp_backup_tokens): Call _cpp_backup_tokens_direct.\n+\t(warn_of_redefinition): Silently allow redefined conditional\n+\tmacros.\n+\t(_cpp_create_definition): Remove the conditional flag when a user\n+\tdefines one of the conditional macros.\n+\t* internal.h (_cpp_backup_tokens_direct): New prototype.\n+\n 2008-06-13  Andrew Haley  <aph@redhat.com>\n \n \tPR preprocessor/33305"}, {"sha": "a79c26dd6b8e0c0ebda3682a52fc454254fa8bb5", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -484,6 +484,10 @@ struct cpp_callbacks\n   void (*read_pch) (cpp_reader *, const char *, int, const char *);\n   missing_header_cb missing_header;\n \n+  /* Context-sensitive macro support.  Returns macro (if any) that should\n+     be expanded.  */\n+  cpp_hashnode * (*macro_to_expand) (cpp_reader *, const cpp_token *);\n+\n   /* Called to emit a diagnostic if client_diagnostic option is true.\n      This callback receives the translated message.  */\n   void (*error) (cpp_reader *, int, const char *, va_list *)\n@@ -558,6 +562,7 @@ extern const char *progname;\n #define NODE_DISABLED\t(1 << 5)\t/* A disabled macro.  */\n #define NODE_MACRO_ARG\t(1 << 6)\t/* Used during #define processing.  */\n #define NODE_USED\t(1 << 7)\t/* Dumped with -dU.  */\n+#define NODE_CONDITIONAL (1 << 8)\t/* Conditional macro */\n \n /* Different flavors of hash node.  */\n enum node_type\n@@ -629,8 +634,8 @@ struct cpp_hashnode GTY(())\n \t\t\t\t\t   then index into directive table.\n \t\t\t\t\t   Otherwise, a NODE_OPERATOR.  */\n   unsigned char rid_code;\t\t/* Rid code - for front ends.  */\n-  ENUM_BITFIELD(node_type) type : 8;\t/* CPP node type.  */\n-  unsigned char flags;\t\t\t/* CPP flags.  */\n+  ENUM_BITFIELD(node_type) type : 7;\t/* CPP node type.  */\n+  unsigned int flags : 9;\t\t/* CPP flags.  */\n \n   union _cpp_hashnode_value GTY ((desc (\"CPP_HASHNODE_VALUE_IDX (%1)\"))) value;\n };\n@@ -717,6 +722,7 @@ extern const cpp_token *cpp_get_token_with_location (cpp_reader *,\n extern const unsigned char *cpp_macro_definition (cpp_reader *,\n \t\t\t\t\t\t  const cpp_hashnode *);\n extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n+extern const cpp_token *cpp_peek_token (cpp_reader *, int);\n \n /* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,"}, {"sha": "4fb4e431b810e65e6d2e7cc70265fe55ea728fc6", "filename": "libcpp/internal.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -532,6 +532,7 @@ extern const unsigned char *_cpp_builtin_macro_text (cpp_reader *,\n extern int _cpp_warn_if_unused_macro (cpp_reader *, cpp_hashnode *, void *);\n extern void _cpp_push_token_context (cpp_reader *, cpp_hashnode *,\n \t\t\t\t     const cpp_token *, unsigned int);\n+extern void _cpp_backup_tokens_direct (cpp_reader *, unsigned int);\n \n /* In identifiers.c */\n extern void _cpp_init_hashtable (cpp_reader *, hash_table *);"}, {"sha": "c1e009da06b30bd63f40cac653b3a9bdbc040bcf", "filename": "libcpp/lex.c", "status": "modified", "additions": 65, "deletions": 1, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -734,6 +734,49 @@ next_tokenrun (tokenrun *run)\n   return run->next;\n }\n \n+/* Look ahead in the input stream.  */\n+const cpp_token *\n+cpp_peek_token (cpp_reader *pfile, int index)\n+{\n+  cpp_context *context = pfile->context;\n+  const cpp_token *peektok;\n+  int count;\n+\n+  /* First, scan through any pending cpp_context objects.  */\n+  while (context->prev)\n+    {\n+      ptrdiff_t sz = (context->direct_p\n+                      ? LAST (context).token - FIRST (context).token\n+                      : LAST (context).ptoken - FIRST (context).ptoken);\n+\n+      if (index < (int) sz)\n+        return (context->direct_p\n+                ? FIRST (context).token + index\n+                : *(FIRST (context).ptoken + index));\n+\n+      index -= (int) sz;\n+      context = context->prev;\n+    }\n+\n+  /* We will have to read some new tokens after all (and do so\n+     without invalidating preceding tokens).  */\n+  count = index;\n+  pfile->keep_tokens++;\n+\n+  do\n+    {\n+      peektok = _cpp_lex_token (pfile);\n+      if (peektok->type == CPP_EOF)\n+\treturn peektok;\n+    }\n+  while (index--);\n+\n+  _cpp_backup_tokens_direct (pfile, count + 1);\n+  pfile->keep_tokens--;\n+\n+  return peektok;\n+}\n+\n /* Allocate a single token that is invalidated at the same time as the\n    rest of the tokens on the line.  Has its line and col set to the\n    same as the last lexed token, so that diagnostics appear in the\n@@ -742,9 +785,30 @@ cpp_token *\n _cpp_temp_token (cpp_reader *pfile)\n {\n   cpp_token *old, *result;\n+  ptrdiff_t sz = pfile->cur_run->limit - pfile->cur_token;\n+  ptrdiff_t la = (ptrdiff_t) pfile->lookaheads;\n \n   old = pfile->cur_token - 1;\n-  if (pfile->cur_token == pfile->cur_run->limit)\n+  /* Any pre-existing lookaheads must not be clobbered.  */\n+  if (la)\n+    {\n+      if (sz <= la)\n+        {\n+          tokenrun *next = next_tokenrun (pfile->cur_run);\n+\n+          if (sz < la)\n+            memmove (next->base + 1, next->base,\n+                     (la - sz) * sizeof (cpp_token));\n+\n+          next->base[0] = pfile->cur_run->limit[-1];\n+        }\n+\n+      if (sz > 1)\n+        memmove (pfile->cur_token + 1, pfile->cur_token,\n+                 MIN (la, sz - 1) * sizeof (cpp_token));\n+    }\n+\n+  if (!sz && pfile->cur_token == pfile->cur_run->limit)\n     {\n       pfile->cur_run = next_tokenrun (pfile->cur_run);\n       pfile->cur_token = pfile->cur_run->base;"}, {"sha": "1563d780d6f9b4c5a573493bdc45da6d681af952", "filename": "libcpp/macro.c", "status": "modified", "additions": 37, "deletions": 18, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5950c3c9a7729687a04f9b008e441959a2d9114d/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=5950c3c9a7729687a04f9b008e441959a2d9114d", "patch": "@@ -1251,16 +1251,21 @@ cpp_get_token (cpp_reader *pfile)\n \n       if (!(node->flags & NODE_DISABLED))\n \t{\n-\t  int ret;\n+\t  int ret = 0;\n \t  /* If not in a macro context, and we're going to start an\n \t     expansion, record the location.  */\n \t  if (can_set && !context->macro)\n \t    pfile->invocation_location = result->src_loc;\n \t  if (pfile->state.prevent_expansion)\n \t    break;\n-\t  ret = enter_macro_context (pfile, node, result);\n-\t  if (ret)\n-\t    {\n+\n+\t  /* Conditional macros require that a predicate be evaluated\n+\t     first.  */\n+\t  if (((!(node->flags & NODE_CONDITIONAL))\n+\t       || (pfile->cb.macro_to_expand\n+\t\t   && (node = pfile->cb.macro_to_expand (pfile, result))))\n+\t      && (ret = enter_macro_context (pfile, node, result)))\n+ \t    {\n \t      if (pfile->state.in_directive || ret == 2)\n \t\tcontinue;\n \t      return padding_token (pfile, result);\n@@ -1338,26 +1343,31 @@ cpp_scan_nooutput (cpp_reader *pfile)\n   pfile->state.prevent_expansion--;\n }\n \n+/* Step back one or more tokens obtained from the lexer.  */\n+void\n+_cpp_backup_tokens_direct (cpp_reader *pfile, unsigned int count)\n+{\n+  pfile->lookaheads += count;\n+  while (count--)\n+    {\n+      pfile->cur_token--;\n+      if (pfile->cur_token == pfile->cur_run->base\n+          /* Possible with -fpreprocessed and no leading #line.  */\n+          && pfile->cur_run->prev != NULL)\n+        {\n+          pfile->cur_run = pfile->cur_run->prev;\n+          pfile->cur_token = pfile->cur_run->limit;\n+        }\n+    }\n+}\n+\n /* Step back one (or more) tokens.  Can only step back more than 1 if\n    they are from the lexer, and not from macro expansion.  */\n void\n _cpp_backup_tokens (cpp_reader *pfile, unsigned int count)\n {\n   if (pfile->context->prev == NULL)\n-    {\n-      pfile->lookaheads += count;\n-      while (count--)\n-\t{\n-\t  pfile->cur_token--;\n-\t  if (pfile->cur_token == pfile->cur_run->base\n-\t      /* Possible with -fpreprocessed and no leading #line.  */\n-\t      && pfile->cur_run->prev != NULL)\n-\t    {\n-\t      pfile->cur_run = pfile->cur_run->prev;\n-\t      pfile->cur_token = pfile->cur_run->limit;\n-\t    }\n-\t}\n-    }\n+    _cpp_backup_tokens_direct (pfile, count);\n   else\n     {\n       if (count != 1)\n@@ -1383,6 +1393,11 @@ warn_of_redefinition (cpp_reader *pfile, const cpp_hashnode *node,\n   if (node->flags & NODE_WARN)\n     return true;\n \n+  /* Redefinitions of conditional (context-sensitive) macros, on\n+     the other hand, must be allowed silently.  */\n+  if (node->flags & NODE_CONDITIONAL)\n+    return false;\n+\n   /* Redefinition of a macro is allowed if and only if the old and new\n      definitions are the same.  (6.10.3 paragraph 2).  */\n   macro1 = node->value.macro;\n@@ -1815,6 +1830,10 @@ _cpp_create_definition (cpp_reader *pfile, cpp_hashnode *node)\n       && ustrcmp (NODE_NAME (node), (const uchar *) \"__STDC_CONSTANT_MACROS\"))\n     node->flags |= NODE_WARN;\n \n+  /* If user defines one of the conditional macros, remove the\n+     conditional flag */\n+  node->flags &= ~NODE_CONDITIONAL;\n+\n   return ok;\n }\n "}]}