{"sha": "d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiN2YyZWU0YmI2OWQ1ZDM1OTQ0MTNkNjNkMDc3ZDJmMzYxMDE0MQ==", "commit": {"author": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "pekka.jaaskelainen@parmance.com", "date": "2017-09-27T15:40:24Z"}, "committer": {"name": "Pekka J\u00e4\u00e4skel\u00e4inen", "email": "visit0r@gcc.gnu.org", "date": "2017-09-27T15:40:24Z"}, "message": "[BRIGFE] Improved support for function and module scope group\nsegment variables.\n    \nPRM specs defines function and module scope group segment variables\nas an experimental feature. However, PRM test suite uses and\nhcc relies on them. In addition, hcc assumes certain group variable\nlayout in its dynamic group segment allocation code.\n    \nWe cannot have global group memory offsets if we want to\nboth have kernel-specific group segment size and multiple kernels\ncalling the same functions that use function scope group memory\nvariables.\n    \nNow group segment is handled by separate book keeping of module\nscope and function (kernel) offsets. Each function has a \"frame\"\nin the group segment offset to which is given as an argument.\n\nFrom-SVN: r253233", "tree": {"sha": "b54b8393b78c2654d94510cf03949efa006d39da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b54b8393b78c2654d94510cf03949efa006d39da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/comments", "author": {"login": "pjaaskel", "id": 1652632, "node_id": "MDQ6VXNlcjE2NTI2MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1652632?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pjaaskel", "html_url": "https://github.com/pjaaskel", "followers_url": "https://api.github.com/users/pjaaskel/followers", "following_url": "https://api.github.com/users/pjaaskel/following{/other_user}", "gists_url": "https://api.github.com/users/pjaaskel/gists{/gist_id}", "starred_url": "https://api.github.com/users/pjaaskel/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pjaaskel/subscriptions", "organizations_url": "https://api.github.com/users/pjaaskel/orgs", "repos_url": "https://api.github.com/users/pjaaskel/repos", "events_url": "https://api.github.com/users/pjaaskel/events{/privacy}", "received_events_url": "https://api.github.com/users/pjaaskel/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6f0e6f0868f02f79a2ee561419393839d974c1f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0e6f0868f02f79a2ee561419393839d974c1f7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0e6f0868f02f79a2ee561419393839d974c1f7"}], "stats": {"total": 577, "additions": 428, "deletions": 149}, "files": [{"sha": "0225929c2ef5d4a2a43c761c5872af3dd72d8a46", "filename": "gcc/brig/ChangeLog", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2FChangeLog?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -1,4 +1,29 @@\n-2017-05-13  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+2017-09-27  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* brig-lang.c: Improved support for function and module scope\n+\tgroup segment variables.  PRM specs defines function and module\n+\tscope group segment variables as an experimental feature. However,\n+\tPRM test suite uses and hcc relies on them. In addition, hcc\n+\tassumes certain group variable layout in its dynamic group segment\n+\tallocation code.  We cannot have global group memory offsets if we\n+\twant to both have kernel-specific group segment size and multiple\n+\tkernels calling the same functions that use function scope group memory\n+\tvariables.  Now group segment is handled by separate book keeping of\n+\tmodule scope and function (kernel) offsets. Each function has a \"frame\"\n+\tin the group segment offset to which is given as an argument.\n+\t* brigfrontend/brig-branch-inst-handler.cc: See above.\n+\t* brigfrontend/brig-code-entry-handler.cc: See above.\n+\t* brigfrontend/brig-fbarrier-handler.cc: See above.\n+\t* brigfrontend/brig-function-handler.cc: See above.\n+\t* brigfrontend/brig-function.cc: See above.\n+\t* brigfrontend/brig-function.h: See above.\n+\t* brigfrontend/brig-to-generic.cc: See above.\n+\t* brigfrontend/brig-to-generic.h: See above.\n+\t* brigfrontend/brig-util.cc: See above.\n+\t* brigfrontend/brig-util.h: See above.\n+\t* brigfrontend/brig-variable-handler.cc: See above.\n+\n+2017-09-25  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* brigfrontend/brig-to-generic.cc: Ensure per WI copies of\n \tprivate variables are aligned too."}, {"sha": "a587c8b60917c4cc40832a71fd37d49cf4c0acfb", "filename": "gcc/brig/brig-lang.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrig-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrig-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrig-lang.c?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -160,7 +160,7 @@ brig_langhook_post_options (const char **pfilename ATTRIBUTE_UNUSED)\n     flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n \n   /* gccbrig casts pointers around like crazy, TBAA produces\n-\t   broken code if not force disabling it.  */\n+     broken code if not force disabling it.  */\n   flag_strict_aliasing = 0;\n \n   /* Returning false means that the backend should be used.  */\n@@ -182,6 +182,8 @@ brig_langhook_parse_file (void)\n {\n   brig_to_generic brig_to_gen;\n \n+  std::vector <char*> brig_blobs;\n+\n   for (unsigned int i = 0; i < num_in_fnames; ++i)\n     {\n \n@@ -194,11 +196,22 @@ brig_langhook_parse_file (void)\n \t  error (\"could not read the BRIG file\");\n \t  exit (1);\n \t}\n-      brig_to_gen.parse (brig_blob);\n       fclose (f);\n+\n+      brig_to_gen.analyze (brig_blob);\n+      brig_blobs.push_back (brig_blob);\n+    }\n+\n+  for (size_t i = 0; i < brig_blobs.size(); ++i)\n+    {\n+      char *brig_blob = brig_blobs.at(i);\n+      brig_to_gen.parse (brig_blob);\n     }\n \n   brig_to_gen.write_globals ();\n+\n+  for (size_t i = 0; i < brig_blobs.size (); ++i)\n+    delete brig_blobs[i];\n }\n \n static tree"}, {"sha": "c8912dbccd7a309ddbdb807010d53efe17ad337a", "filename": "gcc/brig/brigfrontend/brig-branch-inst-handler.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-branch-inst-handler.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -117,8 +117,17 @@ brig_branch_inst_handler::operator () (const BrigBase *base)\n \t they might call builtins that need them or access group/private\n \t memory.  */\n \n+      tree group_local_offset\n+\t= add_temp_var (\"group_local_offset\",\n+\t\t\tbuild_int_cst\n+\t\t\t(uint32_type_node,\n+\t\t\t m_parent.m_cf->m_local_group_variables.size()));\n+\n+      /* TODO: ensure the callee's frame is aligned!  */\n+\n       vec_safe_push (in_args, m_parent.m_cf->m_context_arg);\n       vec_safe_push (in_args, m_parent.m_cf->m_group_base_arg);\n+      vec_safe_push (in_args, group_local_offset);\n       vec_safe_push (in_args, m_parent.m_cf->m_private_base_arg);\n \n       tree call = build_call_vec (ret_val_type, build_fold_addr_expr (func_ref),"}, {"sha": "a660739807e5cf6feb58877f1b8d2aee7f7ce8af", "filename": "gcc/brig/brigfrontend/brig-code-entry-handler.cc", "status": "modified", "additions": 22, "deletions": 6, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-code-entry-handler.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -88,10 +88,17 @@ brig_code_entry_handler::build_code_ref (const BrigBase &ref)\n     {\n       const BrigDirectiveFbarrier* fbar = (const BrigDirectiveFbarrier*)&ref;\n \n-      uint64_t offset = m_parent.group_variable_segment_offset\n-\t(m_parent.get_mangled_name (fbar));\n-\n-      return build_int_cst (uint32_type_node, offset);\n+      std::string var_name = m_parent.get_mangled_name (fbar);\n+      uint64_t offset\n+\t= m_parent.m_cf->group_variable_segment_offset (var_name);\n+\n+      tree local_offset = build_int_cst (uint32_type_node, offset);\n+      if (m_parent.m_cf->m_local_group_variables.has_variable (var_name))\n+\tlocal_offset\n+\t  = build2 (PLUS_EXPR, uint64_type_node, local_offset,\n+\t\t    convert (uint64_type_node,\n+\t\t\t     m_parent.m_cf->m_group_local_offset_arg));\n+      return local_offset;\n     }\n   else\n     gcc_unreachable ();\n@@ -264,9 +271,18 @@ brig_code_entry_handler::build_address_operand\n \t}\n       else if (segment == BRIG_SEGMENT_GROUP)\n \t{\n-\n-\t  uint64_t offset = m_parent.group_variable_segment_offset (var_name);\n+\t  uint64_t offset\n+\t    = m_parent.m_cf->group_variable_segment_offset (var_name);\n \t  const_offset = build_int_cst (size_type_node, offset);\n+\n+\t  /* If it's a local group variable reference, substract the local\n+\t     group segment offset to get the group base ptr offset.  */\n+\t  if (m_parent.m_cf->m_local_group_variables.has_variable (var_name))\n+\t    const_offset\n+\t      = build2 (PLUS_EXPR, uint64_type_node, const_offset,\n+\t\t\tconvert (uint64_type_node,\n+\t\t\t\t m_parent.m_cf->m_group_local_offset_arg));\n+\n \t}\n       else if (segment == BRIG_SEGMENT_PRIVATE || segment == BRIG_SEGMENT_SPILL)\n \t{"}, {"sha": "a033db6fc6d644af3920e9b97b743d54f1d8ad1e", "filename": "gcc/brig/brigfrontend/brig-fbarrier-handler.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-fbarrier-handler.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -39,6 +39,7 @@ brig_directive_fbarrier_handler::operator () (const BrigBase *base)\n   if (m_parent.m_cf != NULL)\n     m_parent.m_cf->m_function_scope_vars.insert (base);\n   std::string var_name = m_parent.get_mangled_name (fbar);\n-  m_parent.append_group_variable (var_name, FBARRIER_STRUCT_SIZE, 1);\n+  m_parent.add_group_variable (var_name, FBARRIER_STRUCT_SIZE, 1,\n+\t\t\t       m_parent.m_cf != NULL);\n   return base->byteCount;\n }"}, {"sha": "7896c4ac935a1911735399a422ecd48cdf796d6c", "filename": "gcc/brig/brigfrontend/brig-function-handler.cc", "status": "modified", "additions": 31, "deletions": 9, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function-handler.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -39,7 +39,8 @@ extern int gccbrig_verbose;\n size_t\n brig_directive_function_handler::operator () (const BrigBase *base)\n {\n-  m_parent.finish_function ();\n+  if (!m_parent.m_analyzing)\n+    m_parent.finish_function ();\n \n   size_t bytes_consumed = base->byteCount;\n \n@@ -64,9 +65,20 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n   if (is_kernel && !is_definition)\n     return bytes_consumed;\n \n+  std::string func_name = m_parent.get_mangled_name (exec);\n+  if (is_kernel)\n+    /* The generated kernel function is not the one that should be\n+       called by the host.  */\n+    func_name = std::string (\"_\") + func_name;\n+\n   m_parent.m_cf = new brig_function (exec, &m_parent);\n+  m_parent.m_cf->m_name = func_name;\n+  m_parent.m_cf->m_is_kernel = is_kernel;\n \n-  std::string func_name = m_parent.get_mangled_name (exec);\n+  /* During the analyze step, the above information is all we need per\n+     function.  */\n+  if (m_parent.m_analyzing)\n+    return bytes_consumed;\n \n   tree fndecl;\n   tree ret_value = NULL_TREE;\n@@ -79,10 +91,6 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \n   if (is_kernel)\n     {\n-      /* The generated kernel function is not the one that should be\n-\t called by the host.  */\n-      func_name = std::string (\"_\") + func_name;\n-\n       tree name_identifier\n \t= get_identifier_with_length (func_name.c_str (), func_name.size ());\n \n@@ -256,6 +264,23 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n   DECL_ARTIFICIAL (group_base_arg) = 1;\n   TREE_READONLY (group_base_arg) = 1;\n   TREE_USED (group_base_arg) = 1;\n+  m_parent.m_cf->m_group_base_arg = group_base_arg;\n+\n+  /* To implement call stack and (non-kernel) function scope group variables,\n+     we need to pass an offset which describes how far are we from\n+     group_base_ptr.\n+     That must be substracted from any function local group variable offsets to\n+     get the address related to the bottom of the group memory chunk.  */\n+  tree group_local_offset_arg\n+    = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n+\t\t  get_identifier (\"__group_local_offset\"), uint32_type_node);\n+  chainon (DECL_ARGUMENTS (fndecl), group_local_offset_arg);\n+  DECL_ARG_TYPE (group_local_offset_arg) = uint32_type_node;\n+  DECL_CONTEXT (group_local_offset_arg) = fndecl;\n+  DECL_ARTIFICIAL (group_local_offset_arg) = 1;\n+  TREE_READONLY (group_local_offset_arg) = 1;\n+  TREE_USED (group_local_offset_arg) = 1;\n+  m_parent.m_cf->m_group_local_offset_arg = group_local_offset_arg;\n \n   /* Same for private.  */\n   tree private_base_arg\n@@ -329,12 +354,9 @@ brig_directive_function_handler::operator () (const BrigBase *base)\n \n   m_parent.start_function (fndecl);\n \n-  m_parent.m_cf->m_name = func_name;\n   m_parent.m_cf->m_func_decl = fndecl;\n   m_parent.m_cf->m_current_bind_expr = bind_expr;\n-  m_parent.m_cf->m_is_kernel = is_kernel;\n   m_parent.m_cf->m_context_arg = context_arg;\n-  m_parent.m_cf->m_group_base_arg = group_base_arg;\n   m_parent.m_cf->m_private_base_arg = private_base_arg;\n \n   if (ret_value != NULL_TREE && TREE_TYPE (ret_value) != void_type_node)"}, {"sha": "f3c3895078ada2c8beafba41620614202f3ca0a1", "filename": "gcc/brig/brigfrontend/brig-function.cc", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -52,11 +52,10 @@ brig_function::brig_function (const BrigDirectiveExecutable *exec,\n     m_context_arg (NULL_TREE), m_group_base_arg (NULL_TREE),\n     m_private_base_arg (NULL_TREE), m_ret_value (NULL_TREE),\n     m_next_kernarg_offset (0), m_kernarg_max_align (0),\n-    m_ret_value_brig_var (NULL), m_has_barriers (false),\n-    m_has_allocas (false), m_has_function_calls_with_barriers (false),\n-    m_calls_analyzed (false), m_is_wg_function (false),\n-    m_has_unexpanded_dp_builtins (false), m_generating_arg_block (false),\n-    m_parent (parent)\n+    m_ret_value_brig_var (NULL), m_has_barriers (false), m_has_allocas (false),\n+    m_has_function_calls_with_barriers (false), m_calls_analyzed (false),\n+    m_is_wg_function (false), m_has_unexpanded_dp_builtins (false),\n+    m_generating_arg_block (false), m_parent (parent)\n {\n   memset (m_regs, 0,\n \t  BRIG_2_TREE_HSAIL_TOTAL_REG_COUNT * sizeof (BrigOperandRegister *));\n@@ -577,20 +576,31 @@ brig_function::emit_launcher_and_metadata ()\n \n   tree phsail_launch_kernel_call;\n \n+  /* Compute the local group segment frame start pointer.  */\n+  tree group_local_offset_temp\n+    = create_tmp_var (uint32_type_node, \"group_local_offset\");\n+  tree group_local_offset_arg\n+    = build2 (MODIFY_EXPR, uint32_type_node,\n+\t      group_local_offset_temp,\n+\t      build_int_cst (uint32_type_node,\n+\t\t\t     m_parent->m_module_group_variables.size()));\n+\n   /* Emit a launcher depending whether we converted the kernel function to\n      a work group function or not.  */\n   if (m_is_wg_function)\n     phsail_launch_kernel_call\n       = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_WG_FUNC),\n-\t\t      3, void_type_node,\n+\t\t      4, void_type_node,\n \t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n-\t\t      context_arg, ptr_type_node, group_base_addr_arg);\n+\t\t      context_arg, ptr_type_node, group_base_addr_arg,\n+\t\t      uint32_type_node, group_local_offset_arg);\n   else\n     phsail_launch_kernel_call\n       = call_builtin (builtin_decl_explicit (BUILT_IN_HSAIL_LAUNCH_KERNEL),\n-\t\t      3, void_type_node,\n+\t\t      4, void_type_node,\n \t\t      ptr_type_node, kernel_func_ptr, ptr_type_node,\n-\t\t      context_arg, ptr_type_node, group_base_addr_arg);\n+\t\t      context_arg, ptr_type_node, group_base_addr_arg,\n+\t\t      uint32_type_node, group_local_offset_arg);\n \n   append_to_statement_list_force (phsail_launch_kernel_call, &stmt_list);\n \n@@ -722,3 +732,13 @@ brig_function::has_function_scope_var (const BrigBase* var) const\n {\n   return m_function_scope_vars.find (var) != m_function_scope_vars.end ();\n }\n+\n+size_t\n+brig_function::group_variable_segment_offset (const std::string &name) const\n+{\n+  if (m_local_group_variables.has_variable (name))\n+    return m_local_group_variables.segment_offset (name);\n+\n+  gcc_assert (m_parent->m_module_group_variables.has_variable (name));\n+  return m_parent->m_module_group_variables.segment_offset (name);\n+}"}, {"sha": "2a85f5e69fe760b1b95946633f32ef6d5f4129fe", "filename": "gcc/brig/brigfrontend/brig-function.h", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-function.h?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -30,8 +30,7 @@\n #include \"tree.h\"\n #include \"tree-iterator.h\"\n #include \"hsa-brig-format.h\"\n-\n-class brig_to_generic;\n+#include \"brig-util.h\"\n \n #include <map>\n #include <string>\n@@ -40,6 +39,8 @@ class brig_to_generic;\n \n #include \"phsa.h\"\n \n+class brig_to_generic;\n+\n typedef std::map<std::string, tree> label_index;\n typedef std::map<const BrigDirectiveVariable *, tree> variable_index;\n typedef std::vector<tree> tree_stl_vec;\n@@ -84,6 +85,12 @@ class brig_function\n \n   tree add_local_variable (std::string name, tree type);\n \n+  size_t group_variable_segment_offset (const std::string &name) const;\n+\n+  bool has_group_variable (const std::string &name) const;\n+\n+  size_t group_segment_size () const;\n+\n   tree get_m_var_declfor_reg (const BrigOperandRegister *reg);\n \n   bool convert_to_wg_function ();\n@@ -119,10 +126,16 @@ class brig_function\n \n   /* The __context function argument.  */\n   tree m_context_arg;\n+\n   /* The __group_base_ptr argument in the current function.\n-     Points to the start of the group segment for the kernel\n-     instance.  */\n+     Points to the start of the group segment for the work-group.  */\n   tree m_group_base_arg;\n+\n+   /* The __group_local_offset_ptr argument in the current function.  It\n+      contains the offset related to the group_base_ptr where the function's\n+      local area for group variables resides.  */\n+  tree m_group_local_offset_arg;\n+\n   /* The __private_base_ptr argument in the current function.\n      Points to the start of the private segment.  */\n   tree m_private_base_arg;\n@@ -159,7 +172,7 @@ class brig_function\n   /* True if the function has at least one alloca instruction.  */\n   bool m_has_allocas;\n \n-  /* If the kernel containts at least one function call that _may_\n+  /* If the kernel contains at least one function call that _may_\n      contain a barrier call, this is set to true.  */\n   bool m_has_function_calls_with_barriers;\n \n@@ -199,6 +212,10 @@ class brig_function\n   /* The functions called by this function.  */\n   std::vector<tree> m_called_functions;\n \n+  /* Stores the kernel scope group variable offsets if the function is\n+     a kernel.  */\n+  group_variable_offset_index m_local_group_variables;\n+\n   brig_to_generic *m_parent;\n   /* The metadata of the function that should be stored with the binary and\n      passed to the HSA runtime:  */"}, {"sha": "6459f9e1076e77098d44a6d570d495b5f633e2cc", "filename": "gcc/brig/brigfrontend/brig-to-generic.cc", "status": "modified", "additions": 135, "deletions": 62, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -60,8 +60,8 @@ tree brig_to_generic::s_fp32_type;\n tree brig_to_generic::s_fp64_type;\n \n brig_to_generic::brig_to_generic ()\n-  : m_cf (NULL), m_brig (NULL), m_next_group_offset (0),\n-    m_next_private_offset (0)\n+  : m_cf (NULL), m_analyzing (true), m_total_group_segment_usage (0),\n+    m_brig (NULL), m_next_private_offset (0)\n {\n   m_globals = NULL_TREE;\n \n@@ -124,33 +124,32 @@ class skipped_entry_handler : public brig_code_entry_handler\n   }\n };\n \n-/* Parses the given BRIG blob.  */\n+/* Helper struct for pairing a BrigKind and a BrigCodeEntryHandler that\n+   should handle its data.  */\n \n-void\n-brig_to_generic::parse (const char *brig_blob)\n+struct code_entry_handler_info\n {\n-  m_brig = brig_blob;\n-  m_brig_blobs.push_back (brig_blob);\n+  BrigKind kind;\n+  brig_code_entry_handler *handler;\n+};\n \n-  const BrigModuleHeader *mheader = (const BrigModuleHeader *) brig_blob;\n \n-  if (strncmp (mheader->identification, \"HSA BRIG\", 8) != 0)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"Unrecognized file format.\");\n-  if (mheader->brigMajor != 1 || mheader->brigMinor != 0)\n-    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n-\t\t \"BRIG version not supported. BRIG 1.0 required.\");\n+/* Finds the BRIG file sections in the currently processed file.  */\n \n+void\n+brig_to_generic::find_brig_sections ()\n+{\n   m_data = m_code = m_operand = NULL;\n+  const BrigModuleHeader *mheader = (const BrigModuleHeader *) m_brig;\n \n   /* Find the positions of the different sections.  */\n   for (uint32_t sec = 0; sec < mheader->sectionCount; ++sec)\n     {\n       uint64_t offset\n-\t= ((const uint64_t *) (brig_blob + mheader->sectionIndex))[sec];\n+\t= ((const uint64_t *) (m_brig + mheader->sectionIndex))[sec];\n \n       const BrigSectionHeader *section_header\n-\t= (const BrigSectionHeader *) (brig_blob + offset);\n+\t= (const BrigSectionHeader *) (m_brig + offset);\n \n       std::string name ((const char *) (&section_header->name),\n \t\t\tsection_header->nameLength);\n@@ -183,6 +182,94 @@ brig_to_generic::parse (const char *brig_blob)\n   if (m_operand == NULL)\n     gcc_unreachable ();\n \n+}\n+\n+/* Does a first pass over the given BRIG to collect data needed for the\n+   actual parsing.  Currently this includes only collecting the\n+   group segment variable usage to support the experimental HSA PRM feature\n+   where group variables can be declared also in module and function scope\n+   (in addition to kernel scope).\n+*/\n+\n+void\n+brig_to_generic::analyze (const char *brig_blob)\n+{\n+  const BrigModuleHeader *mheader = (const BrigModuleHeader *) brig_blob;\n+\n+  if (strncmp (mheader->identification, \"HSA BRIG\", 8) != 0)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n+\t\t \"Unrecognized file format.\");\n+  if (mheader->brigMajor != 1 || mheader->brigMinor != 0)\n+    fatal_error (UNKNOWN_LOCATION, PHSA_ERROR_PREFIX_INCOMPATIBLE_MODULE\n+\t\t \"BRIG version not supported. BRIG 1.0 required.\");\n+\n+  m_brig = brig_blob;\n+\n+  find_brig_sections ();\n+\n+  brig_directive_variable_handler var_handler (*this);\n+  brig_directive_fbarrier_handler fbar_handler (*this);\n+  brig_directive_function_handler func_handler (*this);\n+\n+  /* Need this for grabbing the module names for mangling the\n+     group variable names.  */\n+  brig_directive_module_handler module_handler (*this);\n+  skipped_entry_handler skipped_handler (*this);\n+\n+  const BrigSectionHeader *csection_header = (const BrigSectionHeader *) m_code;\n+\n+  code_entry_handler_info handlers[]\n+    = {{BRIG_KIND_DIRECTIVE_VARIABLE, &var_handler},\n+       {BRIG_KIND_DIRECTIVE_FBARRIER, &fbar_handler},\n+       {BRIG_KIND_DIRECTIVE_KERNEL, &func_handler},\n+       {BRIG_KIND_DIRECTIVE_MODULE, &module_handler},\n+       {BRIG_KIND_DIRECTIVE_FUNCTION, &func_handler}};\n+\n+  m_analyzing = true;\n+  for (size_t b = csection_header->headerByteCount; b < m_code_size;)\n+    {\n+      const BrigBase *entry = (const BrigBase *) (m_code + b);\n+\n+      brig_code_entry_handler *handler = &skipped_handler;\n+\n+      if (m_cf != NULL && b >= m_cf->m_brig_def->nextModuleEntry)\n+\t{\n+\t  /* The function definition ended.  We can just discard the place\n+\t     holder function. */\n+\t  m_total_group_segment_usage += m_cf->m_local_group_variables.size ();\n+\t  delete m_cf;\n+\t  m_cf = NULL;\n+\t}\n+\n+      /* Find a handler.  */\n+      for (size_t i = 0;\n+\t   i < sizeof (handlers) / sizeof (code_entry_handler_info); ++i)\n+\t{\n+\t  if (handlers[i].kind == entry->kind)\n+\t    handler = handlers[i].handler;\n+\t}\n+      b += (*handler) (entry);\n+    }\n+\n+  if (m_cf != NULL)\n+    {\n+      m_total_group_segment_usage += m_cf->m_local_group_variables.size ();\n+      delete m_cf;\n+      m_cf = NULL;\n+    }\n+\n+  m_total_group_segment_usage += m_module_group_variables.size ();\n+  m_analyzing = false;\n+}\n+\n+/* Parses the given BRIG blob.  */\n+\n+void\n+brig_to_generic::parse (const char *brig_blob)\n+{\n+  m_brig = brig_blob;\n+  find_brig_sections ();\n+\n   brig_basic_inst_handler inst_handler (*this);\n   brig_branch_inst_handler branch_inst_handler (*this);\n   brig_cvt_inst_handler cvt_inst_handler (*this);\n@@ -269,7 +356,6 @@ brig_to_generic::parse (const char *brig_blob)\n \t    handler = handlers[i].handler;\n \t}\n       b += (*handler) (entry);\n-      continue;\n     }\n \n   finish_function ();\n@@ -519,6 +605,29 @@ brig_to_generic::get_finished_function (tree func_decl)\n     return NULL;\n }\n \n+/* Adds a group variable to a correct book keeping structure depending\n+   on its segment.  */\n+\n+void\n+brig_to_generic::add_group_variable (const std::string &name, size_t size,\n+\t\t\t\t     size_t alignment, bool function_scope)\n+{\n+  /* Module and function scope group region variables are an experimental\n+     feature.  We implement module scope group variables with a separate\n+     book keeping inside brig_to_generic which is populated in the 'analyze()'\n+     prepass.  This is to ensure we know the group segment offsets when\n+     processing the functions that might refer to them.  */\n+  if (!function_scope)\n+    {\n+      if (!m_module_group_variables.has_variable (name))\n+\tm_module_group_variables.add (name, size, alignment);\n+      return;\n+    }\n+\n+  if (!m_cf->m_local_group_variables.has_variable (name))\n+    m_cf->m_local_group_variables.add (name, size, alignment);\n+}\n+\n /* Finalizes the currently handled function.  Should be called before\n    setting a new function.  */\n \n@@ -567,38 +676,6 @@ brig_to_generic::start_function (tree f)\n   m_cf->m_func_decl = f;\n }\n \n-/* Appends a new group variable (or an fbarrier) to the current kernel's\n-   group segment.  */\n-\n-void\n-brig_to_generic::append_group_variable (const std::string &name, size_t size,\n-\t\t\t\t\tsize_t alignment)\n-{\n-  size_t align_padding = m_next_group_offset % alignment == 0 ?\n-    0 : (alignment - m_next_group_offset % alignment);\n-  m_next_group_offset += align_padding;\n-  m_group_offsets[name] = m_next_group_offset;\n-  m_next_group_offset += size;\n-}\n-\n-size_t\n-brig_to_generic::group_variable_segment_offset (const std::string &name) const\n-{\n-  var_offset_table::const_iterator i = m_group_offsets.find (name);\n-  gcc_assert (i != m_group_offsets.end ());\n-  return (*i).second;\n-}\n-\n-/* The size of the group and private segments required by the currently\n-   processed kernel.  Private segment size must be multiplied by the\n-   number of work-items in the launch, in case of a work-group function.  */\n-\n-size_t\n-brig_to_generic::group_segment_size () const\n-{\n-  return m_next_group_offset;\n-}\n-\n /* Appends a new variable to the current kernel's private segment.  */\n \n void\n@@ -646,13 +723,6 @@ brig_to_generic::has_private_variable (const std::string &name) const\n   return i != m_private_data_sizes.end ();\n }\n \n-bool\n-brig_to_generic::has_group_variable (const std::string &name) const\n-{\n-  var_offset_table::const_iterator i = m_group_offsets.find (name);\n-  return i != m_group_offsets.end ();\n-}\n-\n size_t\n brig_to_generic::private_variable_size (const std::string &name) const\n {\n@@ -662,6 +732,10 @@ brig_to_generic::private_variable_size (const std::string &name) const\n   return (*i).second;\n }\n \n+\n+/* The size of private segment required by a single work-item executing\n+   the currently processed kernel.  */\n+\n size_t\n brig_to_generic::private_segment_size () const\n {\n@@ -735,10 +809,11 @@ brig_to_generic::write_globals ()\n       cgraph_node::finalize_function (f->m_func_decl, true);\n \n       f->m_descriptor.is_kernel = 1;\n-      /* TODO: analyze the kernel's actual group and private segment usage\n-\t using a call graph.  Now the private and group mem sizes are overly\n-\t pessimistic in case of multiple kernels in the same module.  */\n-      f->m_descriptor.group_segment_size = group_segment_size ();\n+      /* TODO: analyze the kernel's actual private and group segment usage\n+\t using call graph.  Now the mem size is overly\n+\t pessimistic in case of multiple kernels in the same module.\n+      */\n+      f->m_descriptor.group_segment_size = m_total_group_segment_usage;\n       f->m_descriptor.private_segment_size = private_segment_size ();\n \n       /* The kernarg size is rounded up to a multiple of 16 according to\n@@ -774,8 +849,6 @@ brig_to_generic::write_globals ()\n \n   delete[] vec;\n \n-  for (size_t i = 0; i < m_brig_blobs.size (); ++i)\n-    delete m_brig_blobs[i];\n }\n \n /* Returns an type with unsigned int elements corresponding to the"}, {"sha": "0070894dd26c15bd58347588e7782e6fc560674b", "filename": "gcc/brig/brigfrontend/brig-to-generic.h", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-to-generic.h?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -36,7 +36,6 @@\n #include \"hsa-brig-format.h\"\n #include \"brig-function.h\"\n \n-\n struct reg_decl_index_entry;\n \n /* Converts an HSAIL BRIG input to GENERIC.  This class holds global state\n@@ -56,6 +55,7 @@ class brig_to_generic\n public:\n   brig_to_generic ();\n \n+  void analyze (const char *brig_blob);\n   void parse (const char *brig_blob);\n \n   void write_globals ();\n@@ -78,17 +78,9 @@ class brig_to_generic\n   void start_function (tree f);\n   void finish_function ();\n \n-  void append_group_variable (const std::string &name, size_t size,\n-\t\t\t      size_t alignment);\n-\n   void append_private_variable (const std::string &name, size_t size,\n \t\t\t\tsize_t alignment);\n \n-  size_t group_variable_segment_offset (const std::string &name) const;\n-\n-  bool\n-  has_group_variable (const std::string &name) const;\n-\n   size_t\n   private_variable_segment_offset (const std::string &name) const;\n \n@@ -107,11 +99,13 @@ class brig_to_generic\n     { return get_mangled_name_tmpl (var); }\n   std::string get_mangled_name (const BrigDirectiveExecutable *func) const;\n \n-  size_t group_segment_size () const;\n   size_t private_segment_size () const;\n \n   brig_function *get_finished_function (tree func_decl);\n \n+  void add_group_variable (const std::string &name, size_t size,\n+\t\t\t   size_t alignment, bool function_scope);\n+\n   static tree s_fp16_type;\n   static tree s_fp32_type;\n   static tree s_fp64_type;\n@@ -123,10 +117,21 @@ class brig_to_generic\n   /* The currently built function.  */\n   brig_function *m_cf;\n \n+  /* Stores the module and function scope group variable offsets.  */\n+  group_variable_offset_index m_module_group_variables;\n+\n   /* The name of the currently handled BRIG module.  */\n   std::string m_module_name;\n \n+  /* Set to true if the compilation is in 'analyze' phase.  */\n+  bool m_analyzing;\n+\n+  /* Accumulates the total group segment usage.  */\n+  size_t m_total_group_segment_usage;\n+\n private:\n+\n+  void find_brig_sections ();\n   /* The BRIG blob and its different sections of the file currently being\n      parsed.  */\n   const char *m_brig;\n@@ -144,10 +149,6 @@ class brig_to_generic\n   /* The size of each private variable, including the alignment padding.  */\n   std::map<std::string, size_t> m_private_data_sizes;\n \n-  /* The same for group variables.  */\n-  size_t m_next_group_offset;\n-  var_offset_table m_group_offsets;\n-\n   /* And private.  */\n   size_t m_next_private_offset;\n   var_offset_table m_private_offsets;\n@@ -162,9 +163,6 @@ class brig_to_generic\n      for some interprocedural analysis.  */\n   std::map<std::string, brig_function *> m_finished_functions;\n \n-  /* The parsed BRIG blobs.  Owned and will be deleted after use.  */\n-  std::vector<const char *> m_brig_blobs;\n-\n   /* The original dump file.  */\n   FILE *m_dump_file;\n "}, {"sha": "a8684de91314d726cd6953459498829da36077c6", "filename": "gcc/brig/brigfrontend/brig-util.cc", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -27,6 +27,34 @@ along with GCC; see the file COPYING3.  If not see\n #include \"errors.h\"\n #include \"diagnostic-core.h\"\n \n+bool\n+group_variable_offset_index::has_variable (const std::string &name) const\n+{\n+  varname_offset_table::const_iterator i = m_group_offsets.find (name);\n+  return i != m_group_offsets.end ();\n+}\n+\n+/* Adds a new group segment variable.  */\n+\n+void\n+group_variable_offset_index::add (const std::string &name, size_t size,\n+\t\t\t\t  size_t alignment)\n+{\n+  size_t align_padding = m_next_group_offset % alignment == 0 ?\n+    0 : (alignment - m_next_group_offset % alignment);\n+  m_next_group_offset += align_padding;\n+  m_group_offsets[name] = m_next_group_offset;\n+  m_next_group_offset += size;\n+}\n+\n+size_t\n+group_variable_offset_index::segment_offset (const std::string &name) const\n+{\n+  varname_offset_table::const_iterator i = m_group_offsets.find (name);\n+  gcc_assert (i != m_group_offsets.end ());\n+  return (*i).second;\n+}\n+\n /* Return true if operand number OPNUM of instruction with OPCODE is an output.\n    False if it is an input.  Some code reused from Martin Jambor's gcc-hsa\n    tree.  */"}, {"sha": "c90ff29d0fd0b6180f175321184e0a71b3894174", "filename": "gcc/brig/brigfrontend/brig-util.h", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-util.h?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -22,7 +22,33 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_BRIG_UTIL_H\n #define GCC_BRIG_UTIL_H\n \n-#include \"brig-to-generic.h\"\n+#include <map>\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"ansidecl.h\"\n+#include \"coretypes.h\"\n+#include \"opts.h\"\n+#include \"tree.h\"\n+\n+/* Helper class for keeping book of group variable offsets.  */\n+\n+class group_variable_offset_index\n+{\n+public:\n+  group_variable_offset_index () : m_next_group_offset (0) {}\n+\n+  typedef std::map<std::string, size_t> varname_offset_table;\n+\n+  bool has_variable (const std::string &name) const;\n+  void add (const std::string &name, size_t size, size_t alignment);\n+  size_t segment_offset (const std::string &name) const;\n+  size_t size () const { return m_next_group_offset; }\n+\n+private:\n+  size_t m_next_group_offset;\n+  varname_offset_table m_group_offsets;\n+};\n \n bool gccbrig_hsa_opcode_op_output_p (BrigOpcode16_t opcode, int opnum);\n "}, {"sha": "cd0e98107f5b8b44a5e980b4cbaef5cc82732599", "filename": "gcc/brig/brigfrontend/brig-variable-handler.cc", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbrig%2Fbrigfrontend%2Fbrig-variable-handler.cc?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -144,10 +144,25 @@ brig_directive_variable_handler::operator () (const BrigBase *base)\n \n   size_t alignment = get_brig_var_alignment (brigVar);\n \n-  if (m_parent.m_cf != NULL)\n+  bool function_scope = m_parent.m_cf != NULL;\n+\n+  if (function_scope)\n     m_parent.m_cf->m_function_scope_vars.insert (base);\n \n   std::string var_name = m_parent.get_mangled_name (brigVar);\n+  if (brigVar->segment == BRIG_SEGMENT_GROUP)\n+    {\n+      /* Non-kernel scope group variables have been added at the\n+\t 'analyze' stage.  */\n+      m_parent.add_group_variable (var_name, var_size, alignment,\n+\t\t\t\t   function_scope);\n+      return base->byteCount;\n+    }\n+\n+  /* During analyze, handle only (module scope) group variables.  */\n+  if (m_parent.m_analyzing)\n+    return base->byteCount;\n+\n   if (brigVar->segment == BRIG_SEGMENT_KERNARG)\n     {\n       /* Do not create a real variable, but only a table of\n@@ -158,18 +173,6 @@ brig_directive_variable_handler::operator () (const BrigBase *base)\n \tm_parent.m_cf->append_kernel_arg (brigVar, var_size, alignment);\n       return base->byteCount;\n     }\n-  else if (brigVar->segment == BRIG_SEGMENT_GROUP)\n-    {\n-      /* Handle group region variables similarly as kernargs:\n-\t assign offsets to the group region on the fly when\n-\t a new module scope or function scope group variable is\n-\t introduced.  These offsets will be then added to the\n-\t group_base hidden pointer passed to the kernel in order to\n-\t get the flat address.  */\n-      if (!m_parent.has_group_variable (var_name))\n-\tm_parent.append_group_variable (var_name, var_size, alignment);\n-      return base->byteCount;\n-    }\n   else if (brigVar->segment == BRIG_SEGMENT_PRIVATE\n \t   || brigVar->segment == BRIG_SEGMENT_SPILL)\n     {"}, {"sha": "9e67ac34e586c47296b2f5e7fd314d93152fd8de", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -1,3 +1,11 @@\n+2017-09-27  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* brig.dg/test/gimple/fbarrier.hsail: Fixed tests to match the new\n+\tnew group memory offsetting code in the BRIG frontend.\n+\t* brig.dg/test/gimple/function_calls.hsail: Likewise.\n+\t* brig.dg/test/gimple/smoke_test.hsail: Likewise.\n+\t* brig.dg/test/gimple/variables.hsail: Likewise.\n+\n 2017-09-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/82159"}, {"sha": "9efe027157155e07700041a461a0326eae826aac", "filename": "gcc/testsuite/brig.dg/test/gimple/fbarrier.hsail", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffbarrier.hsail?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -65,10 +65,10 @@ prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n \n /* { dg-final { scan-tree-dump \"__hsail_waitfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n /* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_initfbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n /* { dg-final { scan-tree-dump \"__hsail_joinfbar \\\\\\(0, __context\\\\\\);\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"@skip_init:\\[\\n ]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n ]+__builtin___hsail_joinfbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"@skip_init:\\[\\n ]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n ]+__builtin___hsail_joinfbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n \n-/* { dg-final { scan-tree-dump \"__hsail_arrivefbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_arrivefbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */\n \n-/* { dg-final { scan-tree-dump \"__hsail_releasefbar \\\\\\(0, __context\\\\\\);\\[\\n ]+__builtin___hsail_releasefbar \\\\\\(32, __context\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"__hsail_releasefbar \\\\\\(0, __context\\\\\\);\\[\\n ]+__builtin___hsail_releasefbar \\\\\\(__group_local_offset, __context\\\\\\);\" \"gimple\"} } */"}, {"sha": "50f79060b592a8fb84a1c7de537dd9be51b69472", "filename": "gcc/testsuite/brig.dg/test/gimple/function_calls.hsail", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Ffunction_calls.hsail?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -46,7 +46,7 @@ prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n \n /* The generated function call should have the incoming arguments and three hidden arguments. */\n \n-/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = subfunction \\\\\\(_kernel.float_arg.\\[_0-9\\]+, _kernel.double_arg.\\[_0-9\\]+, _kernel.half_arg.\\[_0-9\\]+, __context, __group_base_addr, __private_base_addr\\\\\\);\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"_\\[0-9\\]+ = subfunction \\\\\\(_kernel.float_arg.\\[_0-9\\]+, _kernel.double_arg.\\[_0-9\\]+, _kernel.half_arg.\\[_0-9\\]+, __context, __group_base_addr, group_local_offset.*, __private_base_addr\\\\\\);\" \"gimple\"} } */\n \n /* The callee should refer directly to the scalar arguments when it reads them. */\n /* { dg-final { scan-tree-dump \"= float_arg;\" \"gimple\"} } */"}, {"sha": "1f36ddc41811ea66ecc6e457ae3ea46e388ef4ec", "filename": "gcc/testsuite/brig.dg/test/gimple/smoke_test.hsail", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fsmoke_test.hsail?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -42,7 +42,7 @@ prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n \n /* The kernel function itself should have a fingerprint as follows */\n /* _Kernel (unsigned char * __args, void * __context, void * __group_base_addr, void * __private_base_addr) */\n-/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(unsigned char \\\\\\* __args, void \\\\\\* __context, void \\\\\\* __group_base_addr, void \\\\\\* __private_base_addr\\\\\\)\" \"gimple\"} } */\n+/* { dg-final { scan-tree-dump \"_Kernel \\\\\\(unsigned char \\\\\\* __args, void \\\\\\* __context, void \\\\\\* __group_base_addr, unsigned int __group_local_offset, void \\\\\\* __private_base_addr\\\\\\)\" \"gimple\"} } */\n \n /* ld_kernarg: mem_read.0 = MEM[(unsigned long *)__args]; */\n /* { dg-final { scan-tree-dump \"mem_read.\\[0-9\\] = MEM\\\\\\[\\\\\\(unsigned long \\\\\\*\\\\\\)__args\\\\\\];\" \"gimple\"} } */\n@@ -73,7 +73,7 @@ prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n /* The launcher should call __hsail_launch_wg_function in this case: */\n /* Kernel (void * __context, void * __group_base_addr) */\n /* { dg-final { scan-tree-dump \"Kernel \\\\\\(void \\\\\\* __context, void \\\\\\* __group_base_addr\\\\\\)\" \"gimple\"} } */\n-/* { dg-final { scan-tree-dump \"__hsail_launch_wg_function \\\\\\(_Kernel, __context, __group_base_addr\\\\\\);\" \"gimple\"} }*/\n+/* { dg-final { scan-tree-dump \"__hsail_launch_wg_function \\\\\\(_Kernel, __context, __group_base_addr, group_local_offset.*\\\\\\);\" \"gimple\"} }*/\n \n /* The kernel should have the magic metadata section injected to the ELF. */\n /* TODO: this should be disabled in case not outputting to an ELF. */\n@@ -85,7 +85,7 @@ prog kernel &KernelWithBarrier(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n /* { dg-final { scan-tree-dump \"s2 = s0 \\\\\\+ s1;\\[\\n \\]+__builtin___hsail_barrier \\\\\\(__context\\\\\\);\\[\\n \\]+s3 = s0 \\\\\\+ 4294967295;\" \"gimple\"} } */\n \n /* The kernel with the barrier call's launcher function should call the thread-spawning function. */\n-/* { dg-final { scan-tree-dump \"__hsail_launch_kernel \\\\\\(_KernelWithBarrier, __context, __group_base_addr\\\\\\);\" \"gimple\" } } */\n+/* { dg-final { scan-tree-dump \"__hsail_launch_kernel \\\\\\(_KernelWithBarrier, __context, __group_base_addr, group_local_offset.*\\\\\\);\" \"gimple\" } } */\n \n \n "}, {"sha": "5fd96c1c7bd51c7e1f6e83f06db5bdd31af54b20", "filename": "gcc/testsuite/brig.dg/test/gimple/variables.hsail", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fbrig.dg%2Ftest%2Fgimple%2Fvariables.hsail?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -3,7 +3,7 @@ module &module:1:0:$full:$large:$default;\n /* Tests for different variable scopes and address spaces. */\n \n /* { dg-do compile } */\n-/* { dg-options \"-fdump-tree-gimple\" } */\n+/* { dg-options \"-fdump-tree-gimple -fdump-tree-original\" } */\n \n prog align(256) private_u32 &prog_private;\n private_u32 &mod_private;\n@@ -29,7 +29,10 @@ prog function &subfunction(arg_u32 %return_value)(arg_u32 %arg) {\n      ld_private_u32 $s200, [%func_private];\n      st_private_u32 $s200, [&prog_private];\n \n+/* { dg-final { scan-tree-dump \"__group_base_addr \\\\\\+ \\\\\\(0 \\\\\\+\" \"original\" } } */\n      ld_group_u32 $s203, [%func_group];\n+\n+/* { dg-final { scan-tree-dump \"__group_base_addr \\\\\\+ 0\" \"original\" } } */\n      st_group_u32 $s203, [&prog_group];\n \n      ld_global_u32 $s204, [%func_global];\n@@ -104,8 +107,6 @@ prog kernel &kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)\n  kern_group @12\t\t(3)\n */\n \n-/* { dg-final { scan-tree-dump \"\\\\\\+ 8;.*\\\\\\+ 12;.*\\\\\\+ 4;\" \"gimple\" } } */\n-\n /* The \"mangling\" of the global and readonly vars. */\n /* { dg-final { scan-tree-dump \"\\[ \\]*prog_global = s204;\" \"gimple\" } } */\n "}, {"sha": "53d3634a640444169f5f88f5978647638b0851e3", "filename": "libhsail-rt/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2FChangeLog?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -1,7 +1,15 @@\n+2017-09-27  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n+\n+\t* include/internal/phsa-rt.h: Support for improved group segment\n+\thandling with a stack-like allocation scheme.\n+\t* include/internal/workitems.h: Likewise.\n+\t* rt/workitems.c: Likewise.\n+\n 2017-09-25  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* rt/workitems.c: Assume the host runtime allocates the work group\n \tmemory.\n+\n 2017-05-03  Pekka J\u00e4\u00e4skel\u00e4inen  <pekka.jaaskelainen@parmance.com>\n \n \t* rt/workitems.c: Removed a leftover comment."}, {"sha": "13349e7fdbc590cfa922e7cb1fa63c7db5be4d2d", "filename": "libhsail-rt/include/internal/phsa-rt.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fphsa-rt.h?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -42,7 +42,8 @@ typedef void (*gccbrigKernelLauncherFunc) (void *context, void *);\n /* Pointer type for kernel functions produced by gccbrig from the HSAIL.\n    This is private from outside the device binary and only called by\n    the launcher.  */\n-typedef void (*gccbrigKernelFunc) (unsigned char *, void *, void *, void *);\n+typedef void (*gccbrigKernelFunc) (unsigned char *, void *, void *, uint32_t,\n+\t\t\t\t   void *);\n \n /* Context data that is passed to the kernel function, initialized\n    by the runtime to the current launch information.  The data is"}, {"sha": "2abfc61d8678df4d03726f9419706a78458577cd", "filename": "libhsail-rt/include/internal/workitems.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Finclude%2Finternal%2Fworkitems.h?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -63,6 +63,11 @@ typedef struct\n      to the work-group.  */\n   void *group_base_ptr;\n \n+  /* The offset in the group memory for the kernel local group variables.\n+     To support module scope group variables, there might be need to preseve\n+     room for them in the beginning of the group segment.  */\n+  uint32_t initial_group_offset;\n+\n   /* Similarly to the private segment that gets space allocated for all\n      WIs in the work-group.  */\n   void *private_base_ptr;"}, {"sha": "b24fc10835715cba3fcec87ce1092cb709b57cd6", "filename": "libhsail-rt/rt/workitems.c", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Frt%2Fworkitems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b7f2ee4bb69d5d3594413d63d077d2f3610141/libhsail-rt%2Frt%2Fworkitems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libhsail-rt%2Frt%2Fworkitems.c?ref=d4b7f2ee4bb69d5d3594413d63d077d2f3610141", "patch": "@@ -113,7 +113,7 @@ phsa_work_item_thread (int arg0, int arg1)\n \t  && wi->z < __hsail_currentworkgroupsize (2, wi))\n \t{\n \t  l_data->kernel (l_data->kernarg_addr, wi, wg->group_base_ptr,\n-\t\t\t  wg->private_base_ptr);\n+\t\t\t  wg->initial_group_offset, wg->private_base_ptr);\n #ifdef DEBUG_PHSA_RT\n \t  printf (\"done.\\n\");\n #endif\n@@ -221,7 +221,8 @@ phsa_work_item_thread (int arg0, int arg1)\n \n static void\n phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n-\t\t      size_t wg_size_x, size_t wg_size_y, size_t wg_size_z)\n+\t\t      uint32_t group_local_offset, size_t wg_size_x,\n+\t\t      size_t wg_size_y, size_t wg_size_z)\n {\n   PHSAWorkItem *wi_threads = NULL;\n   PHSAWorkGroup wg;\n@@ -247,6 +248,7 @@ phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n \n   wg.alloca_stack_p = wg.private_segment_total_size;\n   wg.alloca_frame_p = wg.alloca_stack_p;\n+  wg.initial_group_offset = group_local_offset;\n \n #ifdef EXECUTE_WGS_BACKWARDS\n   wg.x = context->wg_max_x - 1;\n@@ -313,7 +315,8 @@ phsa_execute_wi_gang (PHSAKernelLaunchData *context, void *group_base_ptr,\n    them execute all the WGs, including a potential partial WG.  */\n \n static void\n-phsa_spawn_work_items (PHSAKernelLaunchData *context, void *group_base_ptr)\n+phsa_spawn_work_items (PHSAKernelLaunchData *context, void *group_base_ptr,\n+\t\t       uint32_t group_local_offset)\n {\n   hsa_kernel_dispatch_packet_t *dp = context->dp;\n   size_t x, y, z;\n@@ -361,8 +364,8 @@ phsa_spawn_work_items (PHSAKernelLaunchData *context, void *group_base_ptr)\n \t  dp->grid_size_y, dp->grid_size_z);\n #endif\n \n-  phsa_execute_wi_gang (context, group_base_ptr, sat_wg_size_x, sat_wg_size_y,\n-\t\t\tsat_wg_size_z);\n+  phsa_execute_wi_gang (context, group_base_ptr, group_local_offset,\n+\t\t\tsat_wg_size_x, sat_wg_size_y, sat_wg_size_z);\n }\n #endif\n \n@@ -374,7 +377,8 @@ phsa_spawn_work_items (PHSAKernelLaunchData *context, void *group_base_ptr)\n    execute massive numbers of work-items in a non-SPMD machine than fibers\n    (easily 100x faster).  */\n static void\n-phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr)\n+phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr,\n+\t\t\t  uint32_t group_local_offset)\n {\n   hsa_kernel_dispatch_packet_t *dp = context->dp;\n   size_t x, y, z, wg_x, wg_y, wg_z;\n@@ -462,7 +466,7 @@ phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr)\n \t  wi.wg->z = wg_z;\n \n \t  context->kernel (context->kernarg_addr, &wi, group_base_ptr,\n-\t\t\t   private_base_ptr);\n+\t\t\t   group_local_offset, private_base_ptr);\n \n #if defined (BENCHMARK_PHSA_RT)\n \t  wg_count++;\n@@ -527,19 +531,20 @@ phsa_execute_work_groups (PHSAKernelLaunchData *context, void *group_base_ptr)\n \n void\n __hsail_launch_kernel (gccbrigKernelFunc kernel, PHSAKernelLaunchData *context,\n-\t\t       void *group_base_ptr)\n+\t\t       void *group_base_ptr, uint32_t group_local_offset)\n {\n   context->kernel = kernel;\n-  phsa_spawn_work_items (context, group_base_ptr);\n+  phsa_spawn_work_items (context, group_base_ptr, group_local_offset);\n }\n #endif\n \n void\n __hsail_launch_wg_function (gccbrigKernelFunc kernel,\n-\t\t\t    PHSAKernelLaunchData *context, void *group_base_ptr)\n+\t\t\t    PHSAKernelLaunchData *context, void *group_base_ptr,\n+\t\t\t    uint32_t group_local_offset)\n {\n   context->kernel = kernel;\n-  phsa_execute_work_groups (context, group_base_ptr);\n+  phsa_execute_work_groups (context, group_base_ptr, group_local_offset);\n }\n \n uint32_t"}]}