{"sha": "e2d79607346564139f9c2ba3e5a42ece5aab6149", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTJkNzk2MDczNDY1NjQxMzlmOWMyYmEzZTVhNDJlY2U1YWFiNjE0OQ==", "commit": {"author": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-29T04:46:45Z"}, "committer": {"name": "Bryce McKinlay", "email": "bryce@gcc.gnu.org", "date": "2000-10-29T04:46:45Z"}, "message": "Re-indent in preparation for diff.\n\nFrom-SVN: r37115", "tree": {"sha": "2f512489e78de1349508d1ed47156bf31e98473f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f512489e78de1349508d1ed47156bf31e98473f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e2d79607346564139f9c2ba3e5a42ece5aab6149", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d79607346564139f9c2ba3e5a42ece5aab6149", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2d79607346564139f9c2ba3e5a42ece5aab6149", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2d79607346564139f9c2ba3e5a42ece5aab6149/comments", "author": null, "committer": null, "parents": [{"sha": "db50e427f61a4ddb4007635d529a2fe06324cbfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db50e427f61a4ddb4007635d529a2fe06324cbfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db50e427f61a4ddb4007635d529a2fe06324cbfa"}], "stats": {"total": 72, "additions": 36, "deletions": 36}, "files": [{"sha": "c382bea1ec179dc422a016ab93564f77a3f4b42e", "filename": "libjava/java/util/BitSet.java", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e2d79607346564139f9c2ba3e5a42ece5aab6149/libjava%2Fjava%2Futil%2FBitSet.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e2d79607346564139f9c2ba3e5a42ece5aab6149/libjava%2Fjava%2Futil%2FBitSet.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2FBitSet.java?ref=e2d79607346564139f9c2ba3e5a42ece5aab6149", "patch": "@@ -2,11 +2,11 @@\n \n /* Copyright (C) 1998, 1999, 2000  Free Software Foundation\n \n-   This file is part of libgcj.\n+This file is part of libgcj.\n \n-   This software is copyrighted work licensed under the terms of the\n-   Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n-   details.  */\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n \n package java.util;\n import java.io.Serializable;\n@@ -22,54 +22,54 @@\n \n public final class BitSet implements Cloneable, Serializable\n {\n-  public void and (BitSet bs)\n+  public void and(BitSet bs)\n   {\n-    int max = Math.min (bits.length, bs.bits.length);\n+    int max = Math.min(bits.length, bs.bits.length);\n     int i;\n     for (i = 0; i < max; ++i)\n       bits[i] &= bs.bits[i];\n     for (; i < bits.length; ++i)\n       bits[i] = 0;\n   }\n \n-  public BitSet ()\n+  public BitSet()\n   {\n-    this (64);\n+    this(64);\n   }\n \n-  public BitSet (int nbits)\n+  public BitSet(int nbits)\n   {\n     if (nbits < 0)\n-      throw new NegativeArraySizeException ();\n+      throw new NegativeArraySizeException();\n     int length = nbits / 64;\n     if (nbits % 64 != 0)\n       ++length;\n     bits = new long[length];\n   }\n \n-  public void clear (int pos)\n+  public void clear(int pos)\n   {\n     if (pos < 0)\n-      throw new IndexOutOfBoundsException ();\n+      throw new IndexOutOfBoundsException();\n     int bit = pos % 64;\n     int offset = pos / 64;\n-    ensure (offset);\n+    ensure(offset);\n     bits[offset] &= ~(1L << bit);\n   }\n \n-  public Object clone ()\n+  public Object clone()\n   {\n-    BitSet bs = new BitSet (bits.length * 64);\n-    System.arraycopy (bits, 0, bs.bits, 0, bits.length);\n+    BitSet bs = new BitSet(bits.length * 64);\n+    System.arraycopy(bits, 0, bs.bits, 0, bits.length);\n     return bs;\n   }\n \n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n     if (!(obj instanceof BitSet))\n       return false;\n     BitSet bs = (BitSet) obj;\n-    int max = Math.min (bits.length, bs.bits.length);\n+    int max = Math.min(bits.length, bs.bits.length);\n     int i;\n     for (i = 0; i < max; ++i)\n       if (bits[i] != bs.bits[i])\n@@ -84,10 +84,10 @@ public boolean equals (Object obj)\n     return true;\n   }\n \n-  public boolean get (int pos)\n+  public boolean get(int pos)\n   {\n     if (pos < 0)\n-      throw new IndexOutOfBoundsException ();\n+      throw new IndexOutOfBoundsException();\n \n     int bit = pos % 64;\n     int offset = pos / 64;\n@@ -98,40 +98,40 @@ public boolean get (int pos)\n     return (bits[offset] & (1L << bit)) == 0 ? false : true;\n   }\n \n-  public int hashCode ()\n+  public int hashCode()\n   {\n     long h = 1234;\n     for (int i = bits.length - 1; i >= 0; --i)\n       h ^= bits[i] * (i + 1);\n     return (int) ((h >> 32) ^ h);\n   }\n \n-  public void or (BitSet bs)\n+  public void or(BitSet bs)\n   {\n-    ensure (bs.bits.length - 1);\n+    ensure(bs.bits.length - 1);\n     int i;\n     for (i = 0; i < bs.bits.length; ++i)\n       bits[i] |= bs.bits[i];\n   }\n \n-  public void set (int pos)\n+  public void set(int pos)\n   {\n     if (pos < 0)\n-      throw new IndexOutOfBoundsException ();\n+      throw new IndexOutOfBoundsException();\n     int bit = pos % 64;\n     int offset = pos / 64;\n-    ensure (offset);\n+    ensure(offset);\n     bits[offset] |= 1L << bit;\n   }\n \n-  public int size ()\n+  public int size()\n   {\n     return bits.length * 64;\n   }\n \n-  public String toString ()\n+  public String toString()\n   {\n-    StringBuffer result = new StringBuffer (\"{\");\n+    StringBuffer result = new StringBuffer(\"{\");\n     boolean first = true;\n     for (int i = 0; i < bits.length; ++i)\n       {\n@@ -142,32 +142,32 @@ public String toString ()\n \t    if ((word & bit) != 0)\n \t      {\n \t\tif (!first)\n-\t\t  result.append (\", \");\n-\t\tresult.append (64 * i + j);\n+\t\t  result.append(\", \");\n+\t\tresult.append(64 * i + j);\n \t\tfirst = false;\n \t      }\n \t    bit <<= 1;\n \t  }\n       }\n \n-    return result.append (\"}\").toString ();\n+    return result.append(\"}\").toString();\n   }\n \n-  public void xor (BitSet bs)\n+  public void xor(BitSet bs)\n   {\n-    ensure (bs.bits.length - 1);\n+    ensure(bs.bits.length - 1);\n     int i;\n     for (i = 0; i < bs.bits.length; ++i)\n       bits[i] ^= bs.bits[i];\n   }\n \n   // Make sure the vector is big enough.\n-  private final void ensure (int lastElt)\n+  private final void ensure(int lastElt)\n   {\n     if (lastElt + 1 > bits.length)\n       {\n \tlong[] nd = new long[lastElt + 1];\n-\tSystem.arraycopy (bits, 0, nd, 0, bits.length);\n+\tSystem.arraycopy(bits, 0, nd, 0, bits.length);\n \tbits = nd;\n       }\n   }"}]}