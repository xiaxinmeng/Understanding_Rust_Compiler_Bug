{"sha": "5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcxOTg2N2RjNTZjYzk4NTRiM2EzZTZhZDY2ODJmOWM2ZTRmYmIxYw==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2013-10-01T21:18:26Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2013-10-01T21:18:26Z"}, "message": "arc.c (stdio.h): Don't include directly.\n\n        * config/arc/arc.c (stdio.h): Don't include directly.\n        (arc_frame_info): Remove GTY marker.\n        (arc_expand_epilogue): Remove [0]: Remove fp_restored_p.\n        Remove if (1) condition.\n        (arc_encode_section_info): Fix comment.\n\nCo-Authored-By: Diego Novillo <dnovillo@google.com>\n\nFrom-SVN: r203089", "tree": {"sha": "e7369fd1c5f80751494c0c83e0aaeb430d245c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e7369fd1c5f80751494c0c83e0aaeb430d245c02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2df0e3c9cfdac71e2e8a06975aa8e7837ae6f58f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2df0e3c9cfdac71e2e8a06975aa8e7837ae6f58f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2df0e3c9cfdac71e2e8a06975aa8e7837ae6f58f"}], "stats": {"total": 270, "additions": 131, "deletions": 139}, "files": [{"sha": "58299d231c0c86a392e78f027881023f6ed9c715", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "patch": "@@ -14,6 +14,12 @@\n \tReplace commented out call_value_via_label_mixed with a\n \tplain comment about bl_s.\n \n+\t* config/arc/arc.c (stdio.h): Don't include directly.\n+\t(arc_frame_info): Remove GTY marker.\n+\t(arc_expand_epilogue): Remove [0]: Remove fp_restored_p.\n+\tRemove if (1) condition.\n+\t(arc_encode_section_info): Fix comment.\n+\n 2013-10-01  Joern Rennecke  <joern.rennecke@embecosm.com>\n \n \t* config/arc/arc.c (arc_conditional_register_usage):"}, {"sha": "3359415bfeaa9c1003e853beeeb01a4d03f04011", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 125, "deletions": 139, "changes": 264, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=5719867dc56cc9854b3a3e6ad6682f9c6e4fbb1c", "patch": "@@ -30,7 +30,6 @@ along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n #include \"config.h\"\n-#include <stdio.h>\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"tm.h\"\n@@ -1809,7 +1808,7 @@ frame_stack_add (HOST_WIDE_INT offset)\n \n /* Structure to be filled in by arc_compute_frame_size with register\n    save masks, and offsets for the current function.  */\n-struct GTY (()) arc_frame_info\n+struct arc_frame_info\n {\n   unsigned int total_size;\t/* # bytes that the entire frame takes up.  */\n   unsigned int extra_size;\t/* # bytes of extra stuff.  */\n@@ -2259,158 +2258,149 @@ arc_expand_epilogue (int sibcall_p)\n \t   ? arc_compute_frame_size (size)\n \t   : cfun->machine->frame_info.total_size);\n \n-  if (1)\n-    {\n-      unsigned int pretend_size = cfun->machine->frame_info.pretend_size;\n-      unsigned int frame_size;\n-      unsigned int size_to_deallocate;\n-      int restored;\n-#if 0\n-      bool fp_restored_p;\n-#endif\n-      int can_trust_sp_p = !cfun->calls_alloca;\n-      int first_offset = 0;\n-      int millicode_p = cfun->machine->frame_info.millicode_end_reg > 0;\n-\n-      size_to_deallocate = size;\n-\n-      frame_size = size - (pretend_size +\n-\t\t\t   cfun->machine->frame_info.reg_size +\n-\t\t\t   cfun->machine->frame_info.extra_size);\n+  unsigned int pretend_size = cfun->machine->frame_info.pretend_size;\n+  unsigned int frame_size;\n+  unsigned int size_to_deallocate;\n+  int restored;\n+  int can_trust_sp_p = !cfun->calls_alloca;\n+  int first_offset = 0;\n+  int millicode_p = cfun->machine->frame_info.millicode_end_reg > 0;\n \n-      /* ??? There are lots of optimizations that can be done here.\n-\t EG: Use fp to restore regs if it's closer.\n-\t Maybe in time we'll do them all.  For now, always restore regs from\n-\t sp, but don't restore sp if we don't have to.  */\n+  size_to_deallocate = size;\n \n-      if (!can_trust_sp_p)\n-\tgcc_assert (frame_pointer_needed);\n+  frame_size = size - (pretend_size +\n+\t\t       cfun->machine->frame_info.reg_size +\n+\t\t       cfun->machine->frame_info.extra_size);\n \n-      /* Restore stack pointer to the beginning of saved register area for\n-\t ARCompact ISA.  */\n-      if (frame_size)\n-\t{\n-\t  if (frame_pointer_needed)\n-\t    frame_move (stack_pointer_rtx, frame_pointer_rtx);\n-\t  else\n-\t    first_offset = frame_size;\n-\t  size_to_deallocate -= frame_size;\n-\t}\n-      else if (!can_trust_sp_p)\n-\tframe_stack_add (-frame_size);\n+  /* ??? There are lots of optimizations that can be done here.\n+     EG: Use fp to restore regs if it's closer.\n+     Maybe in time we'll do them all.  For now, always restore regs from\n+     sp, but don't restore sp if we don't have to.  */\n \n+  if (!can_trust_sp_p)\n+    gcc_assert (frame_pointer_needed);\n \n-      /* Restore any saved registers.  */\n+  /* Restore stack pointer to the beginning of saved register area for\n+     ARCompact ISA.  */\n+  if (frame_size)\n+    {\n       if (frame_pointer_needed)\n-\t{\n-\t      rtx addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\tframe_move (stack_pointer_rtx, frame_pointer_rtx);\n+      else\n+\tfirst_offset = frame_size;\n+      size_to_deallocate -= frame_size;\n+    }\n+  else if (!can_trust_sp_p)\n+    frame_stack_add (-frame_size);\n \n-\t      frame_move_inc (frame_pointer_rtx, gen_frame_mem (Pmode, addr),\n-\t\t\t      stack_pointer_rtx, 0);\n-\t      size_to_deallocate -= UNITS_PER_WORD;\n-\t}\n \n-      /* Load blink after the calls to thunk calls in case of optimize size.  */\n-      if (millicode_p)\n+  /* Restore any saved registers.  */\n+  if (frame_pointer_needed)\n+    {\n+\t  rtx addr = gen_rtx_POST_INC (Pmode, stack_pointer_rtx);\n+\n+\t  frame_move_inc (frame_pointer_rtx, gen_frame_mem (Pmode, addr),\n+\t\t\t  stack_pointer_rtx, 0);\n+\t  size_to_deallocate -= UNITS_PER_WORD;\n+    }\n+\n+  /* Load blink after the calls to thunk calls in case of optimize size.  */\n+  if (millicode_p)\n+    {\n+\t  int sibthunk_p = (!sibcall_p\n+\t\t\t    && fn_type == ARC_FUNCTION_NORMAL\n+\t\t\t    && !cfun->machine->frame_info.pretend_size);\n+\n+\t  gcc_assert (!(cfun->machine->frame_info.gmask\n+\t\t\t& (FRAME_POINTER_MASK | RETURN_ADDR_MASK)));\n+\t  arc_save_restore (stack_pointer_rtx,\n+\t\t\t    cfun->machine->frame_info.gmask,\n+\t\t\t    1 + sibthunk_p, &first_offset);\n+\t  if (sibthunk_p)\n+\t    goto epilogue_done;\n+    }\n+  /* If we are to restore registers, and first_offset would require\n+     a limm to be encoded in a PRE_MODIFY, yet we can add it with a\n+     fast add to the stack pointer, do this now.  */\n+  if ((!SMALL_INT (first_offset)\n+       && cfun->machine->frame_info.gmask\n+       && ((TARGET_ARC700 && !optimize_size)\n+\t    ? first_offset <= 0x800\n+\t    : satisfies_constraint_C2a (GEN_INT (first_offset))))\n+       /* Also do this if we have both gprs and return\n+\t  address to restore, and they both would need a LIMM.  */\n+       || (MUST_SAVE_RETURN_ADDR\n+\t   && !SMALL_INT ((cfun->machine->frame_info.reg_size + first_offset) >> 2)\n+\t   && cfun->machine->frame_info.gmask))\n+    {\n+      frame_stack_add (first_offset);\n+      first_offset = 0;\n+    }\n+  if (MUST_SAVE_RETURN_ADDR)\n+    {\n+      rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n+      int ra_offs = cfun->machine->frame_info.reg_size + first_offset;\n+      rtx addr = plus_constant (Pmode, stack_pointer_rtx, ra_offs);\n+\n+      /* If the load of blink would need a LIMM, but we can add\n+\t the offset quickly to sp, do the latter.  */\n+      if (!SMALL_INT (ra_offs >> 2)\n+\t  && !cfun->machine->frame_info.gmask\n+\t  && ((TARGET_ARC700 && !optimize_size)\n+\t       ? ra_offs <= 0x800\n+\t       : satisfies_constraint_C2a (GEN_INT (ra_offs))))\n \t{\n-\t      int sibthunk_p = (!sibcall_p\n-\t\t\t\t&& fn_type == ARC_FUNCTION_NORMAL\n-\t\t\t\t&& !cfun->machine->frame_info.pretend_size);\n-\n-\t      gcc_assert (!(cfun->machine->frame_info.gmask\n-\t\t\t    & (FRAME_POINTER_MASK | RETURN_ADDR_MASK)));\n-\t      arc_save_restore (stack_pointer_rtx,\n-\t\t\t\tcfun->machine->frame_info.gmask,\n-\t\t\t\t1 + sibthunk_p, &first_offset);\n-\t      if (sibthunk_p)\n-\t\tgoto epilogue_done;\n+\t   size_to_deallocate -= ra_offs - first_offset;\n+\t   first_offset = 0;\n+\t   frame_stack_add (ra_offs);\n+\t   ra_offs = 0;\n+\t   addr = stack_pointer_rtx;\n \t}\n-      /* If we are to restore registers, and first_offset would require\n-\t a limm to be encoded in a PRE_MODIFY, yet we can add it with a\n-\t fast add to the stack pointer, do this now.  */\n-      if ((!SMALL_INT (first_offset)\n-\t   && cfun->machine->frame_info.gmask\n-\t   && ((TARGET_ARC700 && !optimize_size)\n-\t\t? first_offset <= 0x800\n-\t\t: satisfies_constraint_C2a (GEN_INT (first_offset))))\n-\t   /* Also do this if we have both gprs and return\n-\t      address to restore, and they both would need a LIMM.  */\n-\t   || (MUST_SAVE_RETURN_ADDR\n-\t       && !SMALL_INT ((cfun->machine->frame_info.reg_size + first_offset) >> 2)\n-\t       && cfun->machine->frame_info.gmask))\n+      /* See if we can combine the load of the return address with the\n+\t final stack adjustment.\n+\t We need a separate load if there are still registers to\n+\t restore.  We also want a separate load if the combined insn\n+\t would need a limm, but a separate load doesn't.  */\n+      if (ra_offs\n+\t  && !cfun->machine->frame_info.gmask\n+\t  && (SMALL_INT (ra_offs) || !SMALL_INT (ra_offs >> 2)))\n \t{\n-\t  frame_stack_add (first_offset);\n+\t  addr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, addr);\n \t  first_offset = 0;\n+\t  size_to_deallocate -= cfun->machine->frame_info.reg_size;\n \t}\n-      if (MUST_SAVE_RETURN_ADDR)\n+      else if (!ra_offs && size_to_deallocate == UNITS_PER_WORD)\n \t{\n-\t  rtx ra = gen_rtx_REG (Pmode, RETURN_ADDR_REGNUM);\n-\t  int ra_offs = cfun->machine->frame_info.reg_size + first_offset;\n-\t  rtx addr = plus_constant (Pmode, stack_pointer_rtx, ra_offs);\n-\n-\t  /* If the load of blink would need a LIMM, but we can add\n-\t     the offset quickly to sp, do the latter.  */\n-\t  if (!SMALL_INT (ra_offs >> 2)\n-\t      && !cfun->machine->frame_info.gmask\n-\t      && ((TARGET_ARC700 && !optimize_size)\n-\t\t   ? ra_offs <= 0x800\n-\t\t   : satisfies_constraint_C2a (GEN_INT (ra_offs))))\n-\t    {\n-\t       size_to_deallocate -= ra_offs - first_offset;\n-\t       first_offset = 0;\n-\t       frame_stack_add (ra_offs);\n-\t       ra_offs = 0;\n-\t       addr = stack_pointer_rtx;\n-\t    }\n-\t  /* See if we can combine the load of the return address with the\n-\t     final stack adjustment.\n-\t     We need a separate load if there are still registers to\n-\t     restore.  We also want a separate load if the combined insn\n-\t     would need a limm, but a separate load doesn't.  */\n-\t  if (ra_offs\n-\t      && !cfun->machine->frame_info.gmask\n-\t      && (SMALL_INT (ra_offs) || !SMALL_INT (ra_offs >> 2)))\n-\t    {\n-\t      addr = gen_rtx_PRE_MODIFY (Pmode, stack_pointer_rtx, addr);\n-\t      first_offset = 0;\n-\t      size_to_deallocate -= cfun->machine->frame_info.reg_size;\n-\t    }\n-\t  else if (!ra_offs && size_to_deallocate == UNITS_PER_WORD)\n-\t    {\n-\t      addr = gen_rtx_POST_INC (Pmode, addr);\n-\t      size_to_deallocate = 0;\n-\t    }\n-\t  frame_move_inc (ra, gen_frame_mem (Pmode, addr), stack_pointer_rtx, addr);\n+\t  addr = gen_rtx_POST_INC (Pmode, addr);\n+\t  size_to_deallocate = 0;\n \t}\n+      frame_move_inc (ra, gen_frame_mem (Pmode, addr), stack_pointer_rtx, addr);\n+    }\n \n-      if (!millicode_p)\n-\t{\n-\t   if (cfun->machine->frame_info.reg_size)\n-\t     arc_save_restore (stack_pointer_rtx,\n-\t       /* The zeroing of these two bits is unnecessary, but leave this in for clarity.  */\n-\t\t\t       cfun->machine->frame_info.gmask\n-\t\t\t       & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK), 1, &first_offset);\n-\t}\n+  if (!millicode_p)\n+    {\n+       if (cfun->machine->frame_info.reg_size)\n+\t arc_save_restore (stack_pointer_rtx,\n+\t   /* The zeroing of these two bits is unnecessary, but leave this in for clarity.  */\n+\t\t\t   cfun->machine->frame_info.gmask\n+\t\t\t   & ~(FRAME_POINTER_MASK | RETURN_ADDR_MASK), 1, &first_offset);\n+    }\n \n \n-      /* The rest of this function does the following:\n-\t ARCompact    : handle epilogue_delay, restore sp (phase-2), return\n-      */\n+  /* The rest of this function does the following:\n+     ARCompact    : handle epilogue_delay, restore sp (phase-2), return\n+  */\n \n-      /* Keep track of how much of the stack pointer we've restored.\n-\t It makes the following a lot more readable.  */\n-      size_to_deallocate += first_offset;\n-      restored = size - size_to_deallocate;\n-#if 0\n-      fp_restored_p = 1;\n-#endif\n+  /* Keep track of how much of the stack pointer we've restored.\n+     It makes the following a lot more readable.  */\n+  size_to_deallocate += first_offset;\n+  restored = size - size_to_deallocate;\n \n-      if (size > restored)\n-\tframe_stack_add (size - restored);\n-      /* Emit the return instruction.  */\n-      if (sibcall_p == FALSE)\n-\temit_jump_insn (gen_simple_return ());\n-    }\n+  if (size > restored)\n+    frame_stack_add (size - restored);\n+  /* Emit the return instruction.  */\n+  if (sibcall_p == FALSE)\n+    emit_jump_insn (gen_simple_return ());\n  epilogue_done:\n   if (!TARGET_EPILOGUE_CFI)\n     {\n@@ -3975,11 +3965,7 @@ branch_dest (rtx branch)\n }\n \n \n-/* Symbols in the text segment can be accessed without indirecting via the\n-   constant pool; it may take an extra binary operation, but this is still\n-   faster than indirecting via memory.  Don't do this when not optimizing,\n-   since we won't be calculating al of the offsets necessary to do this\n-   simplification.  */\n+/* Implement TARGET_ENCODE_SECTION_INFO hook.  */\n \n static void\n arc_encode_section_info (tree decl, rtx rtl, int first)"}]}