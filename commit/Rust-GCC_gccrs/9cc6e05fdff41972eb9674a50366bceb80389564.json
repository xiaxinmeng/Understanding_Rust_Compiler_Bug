{"sha": "9cc6e05fdff41972eb9674a50366bceb80389564", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWNjNmUwNWZkZmY0MTk3MmViOTY3NGE1MDM2NmJjZWI4MDM4OTU2NA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-04-18T06:43:41Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-04-18T06:43:41Z"}, "message": "cppexp.c (lex): Don't assume tokens are NUL terminated.\n\n\t* cppexp.c (lex): Don't assume tokens are NUL terminated.\n\t* cpplib.c (do_include, do_import, do_include_next,\n\tread_line_number, detect_if_not_defined): Likewise.\n\t* cpphash.c (collect_expansion): Likewise.\n\t(special_symbol, _cpp_macroexpand): Check return from\n\tcpp_file_buffer.\n\t* cpphash.h (CPP_NUL_TERMINATE, CPP_NUL_TERMINATE_Q): Delete\n\tmacros.  Delete all uses.\n\n\t* gcc.dg/cpp-mi.c: Add two more test cases.\n\t* gcc.dg/cpp-mind.h, gcc.dg/cpp-mindp.h: New files.\n\nFrom-SVN: r33223", "tree": {"sha": "ad222e07bcfa7712f2e45413bd925ca19d2ee513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad222e07bcfa7712f2e45413bd925ca19d2ee513"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9cc6e05fdff41972eb9674a50366bceb80389564", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc6e05fdff41972eb9674a50366bceb80389564", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9cc6e05fdff41972eb9674a50366bceb80389564", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9cc6e05fdff41972eb9674a50366bceb80389564/comments", "author": null, "committer": null, "parents": [{"sha": "d1bfc5ad4635db1d58d8233f7803b26ba2378647", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1bfc5ad4635db1d58d8233f7803b26ba2378647", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1bfc5ad4635db1d58d8233f7803b26ba2378647"}], "stats": {"total": 242, "additions": 139, "deletions": 103}, "files": [{"sha": "0f629e914b68f4828d4796ac8e329dbb14a60858", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -1,3 +1,17 @@\n+2000-04-17  Zack Weinberg  <zack@wolery.cumb.org>\n+\n+\t* cppexp.c (lex): Don't assume tokens are NUL terminated.\n+\t* cpplib.c (do_include, do_import, do_include_next,\n+\tread_line_number, detect_if_not_defined): Likewise.\n+\t* cpphash.c (collect_expansion): Likewise.\n+\t(special_symbol, _cpp_macroexpand): Check return from\n+\tcpp_file_buffer.\n+\t* cpphash.h (CPP_NUL_TERMINATE, CPP_NUL_TERMINATE_Q): Delete\n+\tmacros.  Delete all uses.\n+\n+\t* gcc.dg/cpp-mi.c: Add two more test cases.\n+\t* gcc.dg/cpp-mind.h, gcc.dg/cpp-mindp.h: New files.\n+\n 2000-04-17  Richard Henderson  <rth@cygnus.com>\n \n \t* bb-reorder.c (fixup_reorder_chain): Don't look up new block again."}, {"sha": "237b8e686a0ab9fa6dae7048f03f96b36b582771", "filename": "gcc/cppexp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -444,7 +444,7 @@ lex (pfile, skip_evaluation)\n       return parse_charconst (pfile, tok_start, tok_end);\n \n     case CPP_NAME:\n-      if (!strcmp (tok_start, \"defined\"))\n+      if (!strncmp (tok_start, \"defined\", 7))\n \treturn parse_defined (pfile);\n \n       op.op = INT;"}, {"sha": "bb13dda4132ebe22f3563323462736dca8ca29b2", "filename": "gcc/cpphash.c", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -401,7 +401,7 @@ collect_expansion (pfile, arglist)\n \tcase CPP_NAME:\n \t  for (i = 0; i < argc; i++)\n \t    if (!strncmp (tok, argv[i].name, argv[i].len)\n-\t\t&& ! is_idchar (tok[argv[i].len]))\n+\t\t&& tok + argv[i].len == CPP_PWRITTEN (pfile))\n \t      goto addref;\n \n \t  /* fall through */\n@@ -517,7 +517,6 @@ collect_expansion (pfile, arglist)\n       while (here > last && is_hspace (pfile->token_buffer [here-1]))\n \there--;\n       CPP_SET_WRITTEN (pfile, here);\n-      CPP_NUL_TERMINATE (pfile);\n       len = CPP_WRITTEN (pfile) - start + 1;\n       /* space for no-concat markers at either end */\n       exp = (U_CHAR *) xmalloc (len + 4);\n@@ -834,7 +833,6 @@ _cpp_quote_string (pfile, src)\n       \n       case '\\0':\n \tCPP_PUTC_Q (pfile, '\\\"');\n-\tCPP_NUL_TERMINATE_Q (pfile);\n \treturn;\n       }\n }\n@@ -851,14 +849,18 @@ special_symbol (hp, pfile)\n      cpp_reader *pfile;\n {\n   const char *buf;\n-  int len;\n   cpp_buffer *ip;\n \n   switch (hp->type)\n     {\n     case T_FILE:\n     case T_BASE_FILE:\n       ip = cpp_file_buffer (pfile);\n+      if (ip == NULL)\n+\t{\n+\t  CPP_PUTS (pfile, \"\\\"\\\"\", 2);\n+\t  return;\n+\t}\n       if (hp->type == T_BASE_FILE)\n \twhile (CPP_PREV_BUFFER (ip) != NULL)\n \t  ip = CPP_PREV_BUFFER (ip);\n@@ -870,10 +872,13 @@ special_symbol (hp, pfile)\n \n     case T_INCLUDE_LEVEL:\n       {\n-\tint true_indepth = 1;\n+\tint true_indepth = 0;\n \tip = cpp_file_buffer (pfile);\n-\twhile ((ip = CPP_PREV_BUFFER (ip)) != NULL)\n-\t  true_indepth++;\n+\twhile (ip)\n+\t  {\n+\t    true_indepth++;\n+\t    ip = CPP_PREV_BUFFER (ip);\n+\t  }\n \n \tCPP_RESERVE (pfile, 10);\n \tsprintf (CPP_PWRITTEN (pfile), \"%d\", true_indepth);\n@@ -884,11 +889,10 @@ special_symbol (hp, pfile)\n     case T_STDC:\n #ifdef STDC_0_IN_SYSTEM_HEADERS\n       ip = cpp_file_buffer (pfile);\n-      if (ip->system_header_p && !cpp_defined (pfile, DSC(\"__STRICT_ANSI__\")))\n+      if (ip && ip->system_header_p\n+\t  && !cpp_defined (pfile, DSC(\"__STRICT_ANSI__\")))\n \t{\n-\t  CPP_RESERVE (pfile, 2);\n-\t  CPP_PUTC_Q (pfile, '0');\n-\t  CPP_NUL_TERMINATE_Q (pfile);\n+\t  CPP_PUTC (pfile, '0');\n \t  return;\n \t}\n #endif\n@@ -902,14 +906,16 @@ special_symbol (hp, pfile)\n       if (*buf == '\\0')\n \tbuf = \"\\r \";\n \n-      len = strlen (buf);\n-      CPP_RESERVE (pfile, len + 1);\n-      CPP_PUTS_Q (pfile, buf, len);\n-      CPP_NUL_TERMINATE_Q (pfile);\n+      CPP_PUTS (pfile, buf, strlen (buf));\n       return;\n \n     case T_SPECLINE:\n       ip = cpp_file_buffer (pfile);\n+      if (ip == NULL)\n+\t{\n+\t  CPP_PUTC (pfile, '0');\n+\t  return;\n+\t}\n       CPP_RESERVE (pfile, 10);\n       sprintf (CPP_PWRITTEN (pfile), \"%u\", CPP_BUF_LINE (ip));\n       CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n@@ -946,9 +952,7 @@ special_symbol (hp, pfile)\n \n     case T_POISON:\n       cpp_error (pfile, \"attempt to use poisoned `%s'.\", hp->name);\n-      CPP_RESERVE (pfile, 1);\n-      CPP_PUTC_Q (pfile, '0');\n-      CPP_NUL_TERMINATE_Q (pfile);\n+      CPP_PUTC (pfile, '0');\n       break;\n \n     default:\n@@ -983,8 +987,13 @@ _cpp_macroexpand (pfile, hp)\n   register int i;\n \n   ip = cpp_file_buffer (pfile);\n-  start_line = CPP_BUF_LINE (ip);\n-  start_column = CPP_BUF_COL (ip);\n+  if (ip)\n+    {\n+      start_line = CPP_BUF_LINE (ip);\n+      start_column = CPP_BUF_COL (ip);\n+    }\n+  else\n+    start_line = start_column = 0;\n \n   /* Check for and handle special symbols. */\n   if (hp->type != T_MACRO)\n@@ -1688,7 +1697,6 @@ _cpp_dump_definition (pfile, sym, len, defn)\n     }\n   if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n     CPP_PUTC (pfile, '\\n');\n-  CPP_NUL_TERMINATE (pfile);\n }\n \n /* Dump out the hash table.  */"}, {"sha": "90fff6496ce51d8c572fb84ff0a1a31a3be1b875", "filename": "gcc/cpphash.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -219,9 +219,6 @@ extern unsigned char _cpp_IStable[256];\n #define CPP_PUTC_Q(PFILE, CH) (*(PFILE)->limit++ = (CH))\n /* Append character CH to PFILE's output buffer.  Make space if need be. */\n #define CPP_PUTC(PFILE, CH) (CPP_RESERVE (PFILE, 1), CPP_PUTC_Q (PFILE, CH))\n-/* Make sure PFILE->limit is followed by '\\0'. */\n-#define CPP_NUL_TERMINATE_Q(PFILE) (*(PFILE)->limit = 0)\n-#define CPP_NUL_TERMINATE(PFILE) (CPP_RESERVE(PFILE, 1), *(PFILE)->limit = 0)\n \n /* Advance the current line by one. */\n #define CPP_BUMP_BUFFER_LINE(PBUF) ((PBUF)->lineno++,\\"}, {"sha": "1340b9c0b2197bde1f1dec95c759784c2233a920", "filename": "gcc/cpplex.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -277,7 +277,6 @@ _cpp_expand_to_buffer (pfile, buf, length)\n \t  break;\n \t}\n     }\n-  CPP_NUL_TERMINATE (pfile);\n }\n \n /* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.\n@@ -630,7 +629,6 @@ _cpp_parse_name (pfile, c)\n       if (c == EOF)\n \tbreak;\n   }\n-  CPP_NUL_TERMINATE_Q (pfile);\n   return;\n }\n \n@@ -1124,7 +1122,6 @@ _cpp_lex_token (pfile)\n \tFORWARD(1);\n \tc2= c;\n       }\n-    CPP_NUL_TERMINATE_Q (pfile);\n     return CPP_NUMBER;\n     case 'b': case 'c': case 'd': case 'h': case 'o':\n     case 'B': case 'C': case 'D': case 'H': case 'O':\n@@ -1147,14 +1144,12 @@ _cpp_lex_token (pfile)\n \t    {\n \t      CPP_RESERVE (pfile, 2);\n \t      CPP_PUTC_Q (pfile, c);\n-\t      CPP_NUL_TERMINATE_Q (pfile);\n \t      return CPP_STRING;\n \t    }\n \t  else\n \t    {\n \t      FORWARD(-1);\n \t    chill_number_eof:\n-\t      CPP_NUL_TERMINATE (pfile);\n \t      return CPP_NUMBER;\n \t    }\n \t}"}, {"sha": "44cc18942c5dcb58c2cdd0b263cf8857673ba1e7", "filename": "gcc/cpplib.c", "status": "modified", "additions": 67, "deletions": 64, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -505,9 +505,6 @@ parse_include (pfile, name)\n       return 0;\n     }\n \n-  CPP_NUL_TERMINATE (pfile);\n-  CPP_ADJUST_WRITTEN (pfile, 1);\n-\n   if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n     {\n       cpp_error (pfile, \"junk at end of `#%s'\", name);\n@@ -533,7 +530,8 @@ do_include (pfile)\n   if (len == 0)\n     return 0;\n   token = alloca (len + 1);\n-  strcpy (token, CPP_PWRITTEN (pfile));\n+  memcpy (token, CPP_PWRITTEN (pfile), len);\n+  token[len] = '\\0';\n   \n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (token, len, pfile, T_INCLUDE);\n@@ -561,7 +559,8 @@ do_import (pfile)\n   if (len == 0)\n     return 0;\n   token = alloca (len + 1);\n-  strcpy (token, CPP_PWRITTEN (pfile));\n+  memcpy (token, CPP_PWRITTEN (pfile), len);\n+  token[len] = '\\0';\n   \n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (token, len, pfile, T_IMPORT);\n@@ -582,7 +581,8 @@ do_include_next (pfile)\n   if (len == 0)\n     return 0;\n   token = alloca (len + 1);\n-  strcpy (token, CPP_PWRITTEN (pfile));\n+  memcpy (token, CPP_PWRITTEN (pfile), len);\n+  token[len] = '\\0';\n   \n   if (CPP_OPTION (pfile, dump_includes))\n     pass_thru_directive (token, len, pfile, T_INCLUDE_NEXT);\n@@ -616,18 +616,20 @@ read_line_number (pfile, num)\n   long save_written = CPP_WRITTEN (pfile);\n   U_CHAR *p;\n   enum cpp_ttype token = _cpp_get_directive_token (pfile);\n-  CPP_SET_WRITTEN (pfile, save_written);\n   p = pfile->token_buffer + save_written;\n \n-  if (token == CPP_NUMBER && *p >= '1' && *p <= '4' && p[1] == '\\0')\n+  if (token == CPP_NUMBER && p + 1 == CPP_PWRITTEN (pfile)\n+      && p[0] >= '1' && p[0] <= '4')\n     {\n       *num = p[0] - '0';\n+      CPP_SET_WRITTEN (pfile, save_written);\n       return 1;\n     }\n   else\n     {\n       if (token != CPP_VSPACE && token != CPP_EOF)\n \tcpp_error (pfile, \"invalid format `#line' command\");\n+      CPP_SET_WRITTEN (pfile, save_written);\n       return 0;\n     }\n }\n@@ -654,6 +656,7 @@ do_line (pfile)\n       goto bad_line_directive;\n     }\n \n+  CPP_PUTC (pfile, '\\0');  /* not terminated for us */\n   new_lineno = strtoul (pfile->token_buffer + old_written, &x, 10);\n   if (x[0] != '\\0')\n     {\n@@ -1066,71 +1069,72 @@ do_sccs (pfile)\n    `#if ! defined SYMBOL', then SYMBOL is a possible controlling macro\n    for inclusion of this file.  (See redundant_include_p in cppfiles.c\n    for an explanation of controlling macros.)  If so, return a\n-   malloc'd copy of SYMBOL.  Otherwise, return NULL.  */\n+   malloced copy of SYMBOL.  Otherwise, return NULL.  */\n \n static U_CHAR *\n detect_if_not_defined (pfile)\n      cpp_reader *pfile;\n {\n   U_CHAR *control_macro = 0;\n+  enum cpp_ttype token;\n+  unsigned int base_offset;\n+  unsigned int token_offset;\n+  unsigned int need_rparen = 0;\n+  unsigned int token_len;\n \n-  if (pfile->only_seen_white == 2)\n-    {\n-      U_CHAR *ident;\n-      enum cpp_ttype token;\n-      int base_offset;\n-      int token_offset;\n-      int need_rparen = 0;\n-\n-      /* Save state required for restore.  */\n-      pfile->no_macro_expand++;\n-      CPP_SET_MARK (pfile);\n-      base_offset = CPP_WRITTEN (pfile);\n-\n-      /* Look for `!', */\n-      if (_cpp_get_directive_token (pfile) != CPP_OTHER\n-\t  || CPP_WRITTEN (pfile) != (size_t) base_offset + 1\n-\t  || CPP_PWRITTEN (pfile)[-1] != '!')\n-\tgoto restore;\n-\n-      /* ...then `defined', */\n-      token_offset = CPP_WRITTEN (pfile);\n-      token = _cpp_get_directive_token (pfile);\n-      if (token != CPP_NAME)\n-\tgoto restore;\n-      ident = pfile->token_buffer + token_offset;\n-      CPP_NUL_TERMINATE (pfile);\n-      if (strcmp (ident, \"defined\"))\n-\tgoto restore;\n+  if (pfile->only_seen_white != 2)\n+    return NULL;\n+\n+  /* Save state required for restore.  */\n+  pfile->no_macro_expand++;\n+  CPP_SET_MARK (pfile);\n+  base_offset = CPP_WRITTEN (pfile);\n+\n+  /* Look for `!', */\n+  if (_cpp_get_directive_token (pfile) != CPP_OTHER\n+      || CPP_WRITTEN (pfile) != (size_t) base_offset + 1\n+      || CPP_PWRITTEN (pfile)[-1] != '!')\n+    goto restore;\n+\n+  /* ...then `defined', */\n+  token_offset = CPP_WRITTEN (pfile);\n+  token = _cpp_get_directive_token (pfile);\n+  if (token != CPP_NAME)\n+    goto restore;\n+  if (strncmp (pfile->token_buffer + token_offset, \"defined\", 7))\n+    goto restore;\n \n-      /* ...then an optional '(' and the name, */\n+  /* ...then an optional '(' and the name, */\n+  token_offset = CPP_WRITTEN (pfile);\n+  token = _cpp_get_directive_token (pfile);\n+  if (token == CPP_LPAREN)\n+    {\n       token_offset = CPP_WRITTEN (pfile);\n+      need_rparen = 1;\n       token = _cpp_get_directive_token (pfile);\n-      if (token == CPP_LPAREN)\n-\t{\n-\t  token_offset = CPP_WRITTEN (pfile);\n-\t  token = _cpp_get_directive_token (pfile);\n-\t  if (token != CPP_NAME)\n-\t    goto restore;\n-\t  need_rparen = 1;\n-\t}\n-      else if (token != CPP_NAME)\n-\tgoto restore;\n-\n-      ident = pfile->token_buffer + token_offset;\n-      CPP_NUL_TERMINATE (pfile);\n-\n-      /* ...then the ')', if necessary, */\n-      if ((!need_rparen || _cpp_get_directive_token (pfile) == CPP_RPAREN)\n-\t  /* ...and make sure there's nothing else on the line.  */\n-\t  && _cpp_get_directive_token (pfile) == CPP_VSPACE)\n-\tcontrol_macro = (U_CHAR *) xstrdup (ident);\n-\n-    restore:\n-      CPP_SET_WRITTEN (pfile, base_offset);\n-      pfile->no_macro_expand--;\n-      CPP_GOTO_MARK (pfile);\n     }\n+  if (token != CPP_NAME)\n+    goto restore;\n+\n+  token_len = CPP_WRITTEN (pfile) - token_offset;\n+\n+  /* ...then the ')', if necessary, */\n+  if (need_rparen && _cpp_get_directive_token (pfile) != CPP_RPAREN)\n+    goto restore;\n+\n+  /* ...and make sure there's nothing else on the line.  */\n+  if (_cpp_get_directive_token (pfile) != CPP_VSPACE)\n+    goto restore;\n+\n+  /* We have a legitimate controlling macro for this header.  */\n+  control_macro = (U_CHAR *) xmalloc (token_len + 1);\n+  memcpy (control_macro, pfile->token_buffer + token_offset, token_len);\n+  control_macro[token_len] = '\\0';\n+\n+ restore:\n+  CPP_SET_WRITTEN (pfile, base_offset);\n+  pfile->no_macro_expand--;\n+  CPP_GOTO_MARK (pfile);\n \n   return control_macro;\n }\n@@ -1218,8 +1222,7 @@ parse_ifdef (pfile, name)\n   else if (token == CPP_NAME)\n     {\n       defined = cpp_defined (pfile, ident, len);\n-      CPP_NUL_TERMINATE (pfile);\n-      CPP_ADJUST_WRITTEN (pfile, 1);\n+      CPP_PUTC (pfile, '\\0');  /* so it can be copied with xstrdup */\n     }\n   else\n     {"}, {"sha": "a05b279558b55f45cf4db0fe52323e338d7e654b", "filename": "gcc/testsuite/gcc.dg/cpp-mi.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mi.c?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -1,10 +1,6 @@\n /* Test \"ignore redundant include\" facility.\n-   This doesn't test for the case where the file is opened, and then ignored\n-   (the file shouldn't have even been opened).  That would require tracing\n-   system calls.  It could be done on some systems however.  */\n-\n-/* We have to test two cases: C comments at the top and C++ comments\n-   at the top.  */\n+   We must test with C and C++ comments outside the guard conditional;\n+   also, we test guarding with #ifndef and #if !defined.  */\n \n /* { dg-do preprocess }\n    { dg-options \"\" } */\n@@ -15,16 +11,24 @@\n #include \"cpp-micc.h\"\n #include \"cpp-micc.h\"\n \n-main ()\n+#include \"cpp-mind.h\"\n+#include \"cpp-mind.h\"\n+\n+#include \"cpp-mindp.h\"\n+#include \"cpp-mindp.h\"\n+\n+int\n+main (void)\n {\n+  return a + b + c + d;\n }\n \n /*\n    { dg-final { if ![file exists cpp-mi.i] { return }\t\t} }\n \n-   { dg-final { set tmp [grep cpp-mi.i cpp-micc? line]\t\t} }\n+   { dg-final { set tmp [grep cpp-mi.i {cpp-mi.*\\.h} line]\t} }\n    { dg-final { # send_user \"$tmp\\n\" } }\n-   { dg-final { if [regexp \"^{\\[0-9\\]+ cpp-mic} {\\[0-9\\]+ cpp-micc}$\" $tmp] \\{ } }\n+   { dg-final { if [regexp \"^{\\[0-9\\]+ cpp-mic\\.h} {\\[0-9\\]+ cpp-micc\\.h} {\\[0-9\\]+ cpp-mind\\.h} {\\[0-9\\]+ cpp-mindp\\.h}$\" $tmp] \\{ } }\n    { dg-final {     pass \"cpp-mi.c: redundant include check\"\t} }\n    { dg-final { \\} else \\{\t\t\t\t\t} }\n    { dg-final {     fail \"cpp-mi.c: redundant include check\"\t} }"}, {"sha": "c14c1a3c6610023d7084b9bff79b0961d37b68ea", "filename": "gcc/testsuite/gcc.dg/cpp-mind.h", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mind.h?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -0,0 +1,8 @@\n+/* Redundant include check with #if !defined.  */\n+\n+#if !defined CPP_MIND_H\n+#define CPP_MIND_H\n+\n+int c;\n+\n+#endif"}, {"sha": "b84202c6d33ea3b0e1e1879c2f3bb16e89936875", "filename": "gcc/testsuite/gcc.dg/cpp-mindp.h", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mindp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9cc6e05fdff41972eb9674a50366bceb80389564/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mindp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp-mindp.h?ref=9cc6e05fdff41972eb9674a50366bceb80389564", "patch": "@@ -0,0 +1,7 @@\n+#if !defined ( CPP_MINDP_H)\n+#define CPP_MINDP_H\n+\n+/* Redundant include check with #if !defined and parentheses.  */\n+int d;\n+\n+#endif"}]}