{"sha": "0dd5327a4608ea3db17ed4af83d6b31d792c2768", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRkNTMyN2E0NjA4ZWEzZGIxN2VkNGFmODNkNmIzMWQ3OTJjMjc2OA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-05-26T09:31:30Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-05-26T09:31:30Z"}, "message": "In libobjc/: 2011-05-26 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2011-05-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n\t* sendmsg.c: Reindented part of the file.  No non-trivial changes\n\tin code.\n\nFrom-SVN: r174269", "tree": {"sha": "0dd7d63c7d5a79de119932c895e3a514e9037de9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0dd7d63c7d5a79de119932c895e3a514e9037de9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0dd5327a4608ea3db17ed4af83d6b31d792c2768", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd5327a4608ea3db17ed4af83d6b31d792c2768", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0dd5327a4608ea3db17ed4af83d6b31d792c2768", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0dd5327a4608ea3db17ed4af83d6b31d792c2768/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1e49849c9f9774b13a33fa6f7973021da7d7315a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e49849c9f9774b13a33fa6f7973021da7d7315a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e49849c9f9774b13a33fa6f7973021da7d7315a"}], "stats": {"total": 248, "additions": 116, "deletions": 132}, "files": [{"sha": "481f001ba61753464b321538b07a5628039a8990", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd5327a4608ea3db17ed4af83d6b31d792c2768/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd5327a4608ea3db17ed4af83d6b31d792c2768/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=0dd5327a4608ea3db17ed4af83d6b31d792c2768", "patch": "@@ -1,3 +1,8 @@\n+2011-05-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* sendmsg.c: Reindented part of the file.  No non-trivial changes\n+\tin code.\n+\n 2011-05-26  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* sendmsg.c (__objc_install_dtable_for_class): Use objc_getClass,"}, {"sha": "c84e90f5b6e35111ff82ad59ea0e18daa3101a9c", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 111, "deletions": 132, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0dd5327a4608ea3db17ed4af83d6b31d792c2768/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0dd5327a4608ea3db17ed4af83d6b31d792c2768/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=0dd5327a4608ea3db17ed4af83d6b31d792c2768", "patch": "@@ -263,29 +263,26 @@ get_implementation (id receiver, Class class, SEL sel)\n \n       /* Double-checked locking pattern: Check\n \t __objc_uninstalled_dtable again in case another thread\n-\t installed the dtable while we were waiting for the lock\n-\t to be released.  */\n+\t installed the dtable while we were waiting for the lock to be\n+\t released.  */\n       if (class->dtable == __objc_uninstalled_dtable)\n-\t{\n-\t  __objc_install_dtable_for_class (class);\n-\t}\n+\t__objc_install_dtable_for_class (class);\n \n-      /* If the dispatch table is not yet installed,\n-\twe are still in the process of executing +initialize.\n-\tBut the implementation pointer should be available\n-\tin the prepared ispatch table if it exists at all.  */\n+      /* If the dispatch table is not yet installed, we are still in\n+\t the process of executing +initialize.  But the implementation\n+\t pointer should be available in the prepared ispatch table if\n+\t it exists at all.  */\n       if (class->dtable == __objc_uninstalled_dtable)\n \t{\n \t  assert (__objc_prepared_dtable_for_class (class) != 0);\n \t  res = __objc_get_prepared_imp (class, sel);\n \t}\n       else\n-\t{\n-\t  res = 0;\n-\t}\n+\tres = 0;\n+\n       objc_mutex_unlock (__objc_runtime_mutex);\n-      /* Call ourselves with the installed dispatch table and get\n-\t the real method.  */\n+      /* Call ourselves with the installed dispatch table and get the\n+\t real method.  */\n       if (!res)\n \tres = get_implementation (receiver, class, sel);\n     }\n@@ -295,19 +292,19 @@ get_implementation (id receiver, Class class, SEL sel)\n       res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n       if (res == 0)\n \t{\n-\t  /* The dispatch table has been installed, and the method\n-\t     is not in the dispatch table.  So the method just\n-\t     doesn't exist for the class.  */\n+\t  /* The dispatch table has been installed, and the method is\n+\t     not in the dispatch table.  So the method just doesn't\n+\t     exist for the class.  */\n \n \t  /* Try going through the +resolveClassMethod: or\n \t     +resolveInstanceMethod: process.  */\n \t  if (CLS_ISMETA (class))\n \t    {\n \t      /* We have the meta class, but we need to invoke the\n \t\t +resolveClassMethod: method on the class.  So, we\n-\t\t need to obtain the class from the meta class,\n-\t\t which we do using the fact that both the class\n-\t\t and the meta-class have the same name.  */\n+\t\t need to obtain the class from the meta class, which\n+\t\t we do using the fact that both the class and the\n+\t\t meta-class have the same name.  */\n \t      Class realClass = objc_lookUpClass (class->name);\n \t      if (realClass)\n \t\tres = __objc_resolve_class_method (realClass, sel);\n@@ -316,9 +313,7 @@ get_implementation (id receiver, Class class, SEL sel)\n \t    res = __objc_resolve_instance_method (class, sel);\n \n \t  if (res == 0)\n-\t    {\n-\t      res = __objc_get_forward_imp (receiver, sel);\n-\t    }\n+\t    res = __objc_get_forward_imp (receiver, sel);\n \t}\n     }\n   return res;\n@@ -365,10 +360,9 @@ method_get_imp (struct objc_method * method)\n \n /* Query if an object can respond to a selector, returns YES if the\n    object implements the selector otherwise NO.  Does not check if the\n-   method can be forwarded.\n-   Since this requires the dispatch table to installed, this function\n-   will implicitly invoke +initialize for the class of OBJECT if it\n-   hasn't been invoked yet.  */\n+   method can be forwarded.  Since this requires the dispatch table to\n+   installed, this function will implicitly invoke +initialize for the\n+   class of OBJECT if it hasn't been invoked yet.  */\n inline\n BOOL\n __objc_responds_to (id object, SEL sel)\n@@ -384,9 +378,9 @@ __objc_responds_to (id object, SEL sel)\n       if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n         __objc_install_dtable_for_class (object->class_pointer);\n \n-      /* If the dispatch table is not yet installed,\n-         we are still in the process of executing +initialize.\n-         Yet the dispatch table should be available.  */\n+      /* If the dispatch table is not yet installed, we are still in\n+         the process of executing +initialize.  Yet the dispatch table\n+         should be available.  */\n       if (object->class_pointer->dtable == __objc_uninstalled_dtable)\n         {\n           dtable = __objc_prepared_dtable_for_class (object->class_pointer);\n@@ -418,9 +412,8 @@ class_respondsToSelector (Class class_, SEL selector)\n     {\n       objc_mutex_lock (__objc_runtime_mutex);\n       if (class_->dtable == __objc_uninstalled_dtable)\n-\t{\n-\t  __objc_install_dtable_for_class (class_);\n-\t}\n+\t__objc_install_dtable_for_class (class_);\n+\n       /* If the dispatch table is not yet installed,\n          we are still in the process of executing +initialize.\n          Yet the dispatch table should be available.  */\n@@ -431,6 +424,7 @@ class_respondsToSelector (Class class_, SEL selector)\n         }\n       else\n         dtable = class_->dtable;\n+\n       objc_mutex_unlock (__objc_runtime_mutex);\n     }\n \n@@ -454,9 +448,10 @@ objc_msg_lookup (id receiver, SEL op)\n \t\t\t\t(sidx)op->sel_id);\n       if (result == 0)\n \t{\n-\t  /* Not found ... call get_implementation () to install the dispatch\n-             table and call +initialize as required, providing the method\n-\t     implementation or a forwarding function */\n+\t  /* Not found ... call get_implementation () to install the\n+             dispatch table and call +initialize as required,\n+             providing the method implementation or a forwarding\n+             function.  */\n \t  result = get_implementation (receiver, receiver->class_pointer, op);\n \t}\n       return result;\n@@ -504,7 +499,7 @@ __objc_init_dispatch_tables ()\n \n   /* TODO: It would be cool to register typed selectors here.  */\n   selector_resolveClassMethod = sel_registerName (\"resolveClassMethod:\");\n-  selector_resolveInstanceMethod  =sel_registerName (\"resolveInstanceMethod:\");\n+  selector_resolveInstanceMethod = sel_registerName (\"resolveInstanceMethod:\");\n }\n \n \n@@ -525,9 +520,9 @@ __objc_send_initialize (Class class)\n   assert (CLS_ISCLASS (class));\n   assert (! CLS_ISMETA (class));\n \n-  /* class_add_method_list/__objc_update_dispatch_table_for_class\n-     may have reset the dispatch table.  The canonical way to insure\n-     that we send +initialize just once, is this flag.  */\n+  /* class_add_method_list/__objc_update_dispatch_table_for_class may\n+     have reset the dispatch table.  The canonical way to insure that\n+     we send +initialize just once, is this flag.  */\n   if (! CLS_ISINITIALIZED (class))\n     {\n       DEBUG_PRINTF (\"+initialize: need to initialize class '%s'\\n\", class->name);\n@@ -619,13 +614,13 @@ __objc_update_dispatch_table_for_class (Class class)\n \n   objc_mutex_lock (__objc_runtime_mutex);\n \n-  /* not yet installed -- skip it unless in +initialize */\n+  /* Not yet installed -- skip it unless in +initialize.  */\n   if (class->dtable == __objc_uninstalled_dtable) \n     {\n       if (__objc_prepared_dtable_for_class (class))\n \t{\n \t  /* There is a prepared table so we must be initialising this\n-\t     class ... we must re-do the table preparation. */\n+\t     class ... we must re-do the table preparation.  */\n \t  __objc_prepare_dtable_for_class (class);\n \t}\n       objc_mutex_unlock (__objc_runtime_mutex);\n@@ -1039,10 +1034,9 @@ objc_get_uninstalled_dtable (void)\n \n static cache_ptr prepared_dtable_table = 0;\n \n-/* This function is called by:\n-   objc_msg_lookup, get_imp and __objc_responds_to\n-   (and the dispatch table installation functions themselves)\n-   to install a dispatch table for a class.\n+/* This function is called by: objc_msg_lookup, get_imp and\n+   __objc_responds_to (and the dispatch table installation functions\n+   themselves) to install a dispatch table for a class.\n \n    If CLS is a class, it installs instance methods.\n    If CLS is a meta class, it installs class methods.\n@@ -1051,66 +1045,57 @@ static cache_ptr prepared_dtable_table = 0;\n \n    The implementation must insure that the dispatch table is not\n    installed until +initialize completes.  Otherwise it opens a\n-   potential race since the installation of the dispatch table is\n-   used as gate in regular method dispatch and we need to guarantee\n-   that +initialize is the first method invoked an that no other\n-   thread my dispatch messages to the class before +initialize\n-   completes.\n- */\n+   potential race since the installation of the dispatch table is used\n+   as gate in regular method dispatch and we need to guarantee that\n+   +initialize is the first method invoked an that no other thread my\n+   dispatch messages to the class before +initialize completes.  */\n static void\n __objc_install_dtable_for_class (Class cls)\n {\n-  /* If the class has not yet had its class links resolved, we must \n-     re-compute all class links */\n+  /* If the class has not yet had its class links resolved, we must\n+     re-compute all class links.  */\n   if (! CLS_ISRESOLV (cls))\n     __objc_resolve_class_links ();\n \n-  /* Make sure the super class has its dispatch table installed\n-     or is at least preparing.\n-     We do not need to send initialize for the super class since\n-     __objc_send_initialize will insure that.\n-   */\n+  /* Make sure the super class has its dispatch table installed or is\n+     at least preparing.  We do not need to send initialize for the\n+     super class since __objc_send_initialize will insure that.  */\n   if (cls->super_class\n-    && cls->super_class->dtable == __objc_uninstalled_dtable\n-    && !__objc_prepared_dtable_for_class (cls->super_class))\n+      && cls->super_class->dtable == __objc_uninstalled_dtable\n+      && !__objc_prepared_dtable_for_class (cls->super_class))\n     {\n       __objc_install_dtable_for_class (cls->super_class);\n       /* The superclass initialisation may have also initialised the\n-         current class, in which case there is no more to do. */\n+         current class, in which case there is no more to do.  */\n       if (cls->dtable != __objc_uninstalled_dtable)\n-\t{\n-\t  return;\n-\t}\n+\treturn;\n     }\n \n   /* We have already been prepared but +initialize hasn't completed.\n-     The +initialize implementation is probably sending 'self' messages.\n-     We rely on _objc_get_prepared_imp to retrieve the implementation\n-     pointers.  */\n+     The +initialize implementation is probably sending 'self'\n+     messages.  We rely on _objc_get_prepared_imp to retrieve the\n+     implementation pointers.  */\n   if (__objc_prepared_dtable_for_class (cls))\n-    {\n-      return;\n-    }\n+    return;\n \n-  /* We have this function cache the implementation pointers\n-     for _objc_get_prepared_imp but the dispatch table won't\n-     be initilized until __objc_send_initialize completes.  */\n+  /* We have this function cache the implementation pointers for\n+     _objc_get_prepared_imp but the dispatch table won't be initilized\n+     until __objc_send_initialize completes.  */\n   __objc_prepare_dtable_for_class (cls);\n \n-  /* We may have already invoked +initialize but \n-     __objc_update_dispatch_table_for_class  invoked by\n+  /* We may have already invoked +initialize but\n+     __objc_update_dispatch_table_for_class invoked by\n      class_add_method_list may have reset dispatch table.  */\n \n-  /* Call +initialize.\n-     If we are a real class, we are installing instance methods.\n-     If we are a meta class, we are installing class methods.\n-     The __objc_send_initialize itself will insure that the message\n-     is called only once per class.  */\n+  /* Call +initialize.  If we are a real class, we are installing\n+     instance methods.  If we are a meta class, we are installing\n+     class methods.  The __objc_send_initialize itself will insure\n+     that the message is called only once per class.  */\n   if (CLS_ISCLASS (cls))\n     __objc_send_initialize (cls);\n   else\n     {\n-      /* Retreive the class from the meta class.  */\n+      /* Retrieve the class from the meta class.  */\n       Class c = objc_getClass (cls->name);\n       assert (CLS_ISMETA (cls));\n       assert (c);\n@@ -1121,44 +1106,41 @@ __objc_install_dtable_for_class (Class cls)\n   __objc_install_prepared_dtable_for_class (cls);\n }\n \n-/* Builds the dispatch table for the class CLS and stores\n-   it in a place where it can be retrieved by\n-   __objc_get_prepared_imp until __objc_install_prepared_dtable_for_class\n-   installs it into the class.\n-   The dispatch table should not be installed into the class until\n-   +initialize has completed.  */\n+/* Builds the dispatch table for the class CLS and stores it in a\n+   place where it can be retrieved by __objc_get_prepared_imp until\n+   __objc_install_prepared_dtable_for_class installs it into the\n+   class.  The dispatch table should not be installed into the class\n+   until +initialize has completed.  */\n static void\n __objc_prepare_dtable_for_class (Class cls)\n {\n   struct sarray *dtable;\n   struct sarray *super_dtable;\n \n-  /* This table could be initialized in init.c. \n-     We can not use the class name since\n-     the class maintains the instance methods and\n-     the meta class maintains the the class methods yet\n-     both share the same name.  \n-     Classes should be unique in any program.  */\n+  /* This table could be initialized in init.c.  We can not use the\n+     class name since the class maintains the instance methods and the\n+     meta class maintains the the class methods yet both share the\n+     same name.  Classes should be unique in any program.  */\n   if (! prepared_dtable_table)\n     prepared_dtable_table \n-      = objc_hash_new(32,\n-\t\t      (hash_func_type) objc_hash_ptr,\n-\t\t      (compare_func_type) objc_compare_ptrs);\n-\n-  /* If the class has not yet had its class links resolved, we must \n-     re-compute all class links */\n+      = objc_hash_new (32,\n+\t\t       (hash_func_type) objc_hash_ptr,\n+\t\t       (compare_func_type) objc_compare_ptrs);\n+  \n+  /* If the class has not yet had its class links resolved, we must\n+     re-compute all class links.  */\n   if (! CLS_ISRESOLV (cls))\n     __objc_resolve_class_links ();\n \n   assert (cls);\n   assert (cls->dtable == __objc_uninstalled_dtable);\n \n-  /* If there is already a prepared dtable for this class, we must replace\n-     it with a new version (since there must have been methods added to or\n-     otherwise modified in the class while executing +initialize, and the\n-     table needs to be recomputed.  */\n+  /* If there is already a prepared dtable for this class, we must\n+     replace it with a new version (since there must have been methods\n+     added to or otherwise modified in the class while executing\n+     +initialize, and the table needs to be recomputed.  */\n   dtable = __objc_prepared_dtable_for_class (cls);\n-  if (0 != dtable)\n+  if (dtable != 0)\n     {\n       objc_hash_remove (prepared_dtable_table, cls);\n       sarray_free (dtable);\n@@ -1168,17 +1150,16 @@ __objc_prepare_dtable_for_class (Class cls)\n   assert (cls != cls->super_class);\n   if (cls->super_class)\n     {\n-      /* Inherit the method list from the super class.\n-         Yet the super class may still be initializing\n-\t in the case when a class cluster sub class initializes\n-\t its super classes.  */\n+      /* Inherit the method list from the super class.  Yet the super\n+         class may still be initializing in the case when a class\n+         cluster sub class initializes its super classes.  */\n       if (cls->super_class->dtable == __objc_uninstalled_dtable)\n \t__objc_install_dtable_for_class (cls->super_class);\n \n       super_dtable = cls->super_class->dtable;\n-      /* If the dispatch table is not yet installed,\n-\t we are still in the process of executing +initialize.\n-\t Yet the dispatch table should be available.  */\n+      /* If the dispatch table is not yet installed, we are still in\n+\t the process of executing +initialize.  Yet the dispatch table\n+\t should be available.  */\n       if (super_dtable == __objc_uninstalled_dtable)\n \tsuper_dtable = __objc_prepared_dtable_for_class (cls->super_class);\n \n@@ -1195,30 +1176,29 @@ __objc_prepare_dtable_for_class (Class cls)\n \t\t dtable);\n }\n \n-/* This wrapper only exists to allow an easy replacement of\n-   the lookup implementation and it is expected that the compiler\n-   will optimize it away.  */\n+/* This wrapper only exists to allow an easy replacement of the lookup\n+   implementation and it is expected that the compiler will optimize\n+   it away.  */\n static struct sarray *\n __objc_prepared_dtable_for_class (Class cls)\n {\n   struct sarray *dtable = 0;\n   assert (cls);\n   if (prepared_dtable_table)\n     dtable = objc_hash_value_for_key (prepared_dtable_table, cls);\n-  /* dtable my be nil, \n-     since we call this to check whether we are currently preparing\n-     before we start preparing.  */\n+  /* dtable my be nil, since we call this to check whether we are\n+     currently preparing before we start preparing.  */\n   return dtable;\n }\n \n /* Helper function for messages sent to CLS or implementation pointers\n-   retrieved from CLS during +initialize before the dtable is installed.\n-   When a class implicitly initializes another class which in turn\n-   implicitly invokes methods in this class, before the implementation of\n-   +initialize of CLS completes, this returns the expected implementation.\n-   Forwarding remains the responsibility of objc_msg_lookup.\n-   This function should only be called under the global lock.\n- */\n+   retrieved from CLS during +initialize before the dtable is\n+   installed.  When a class implicitly initializes another class which\n+   in turn implicitly invokes methods in this class, before the\n+   implementation of +initialize of CLS completes, this returns the\n+   expected implementation.  Forwarding remains the responsibility of\n+   objc_msg_lookup.  This function should only be called under the\n+   global lock.  */\n static IMP\n __objc_get_prepared_imp (Class cls,SEL sel)\n {\n@@ -1234,16 +1214,15 @@ __objc_get_prepared_imp (Class cls,SEL sel)\n   assert (dtable != __objc_uninstalled_dtable);\n   imp = sarray_get_safe (dtable, (size_t) sel->sel_id);\n \n-  /* imp may be Nil if the method does not exist and we\n-     may fallback to the forwarding implementation later.  */\n+  /* imp may be Nil if the method does not exist and we may fallback\n+     to the forwarding implementation later.  */\n   return imp;  \n }\n \n-/* When this function is called +initialize should be completed.\n-   So now we are safe to install the dispatch table for the\n-   class so that they become available for other threads\n-   that may be waiting in the lock.\n- */\n+/* When this function is called +initialize should be completed.  So\n+   now we are safe to install the dispatch table for the class so that\n+   they become available for other threads that may be waiting in the\n+   lock.  */\n static void\n __objc_install_prepared_dtable_for_class (Class cls)\n {"}]}