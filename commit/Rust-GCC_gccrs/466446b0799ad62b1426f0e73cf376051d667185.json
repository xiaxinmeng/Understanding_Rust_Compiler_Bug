{"sha": "466446b0799ad62b1426f0e73cf376051d667185", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDY2NDQ2YjA3OTlhZDYyYjE0MjZmMGU3M2NmMzc2MDUxZDY2NzE4NQ==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-20T10:25:49Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1997-04-20T10:25:49Z"}, "message": "x\n\nFrom-SVN: r13934", "tree": {"sha": "987e659c9ee04599e1184428607689fcff4db694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/987e659c9ee04599e1184428607689fcff4db694"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/466446b0799ad62b1426f0e73cf376051d667185", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/466446b0799ad62b1426f0e73cf376051d667185", "html_url": "https://github.com/Rust-GCC/gccrs/commit/466446b0799ad62b1426f0e73cf376051d667185", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/466446b0799ad62b1426f0e73cf376051d667185/comments", "author": null, "committer": null, "parents": [{"sha": "ce717ce4d3e484d2c50ec5b73f2627b31597fefb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce717ce4d3e484d2c50ec5b73f2627b31597fefb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce717ce4d3e484d2c50ec5b73f2627b31597fefb"}], "stats": {"total": 71, "additions": 30, "deletions": 41}, "files": [{"sha": "96fdec4ba610bdf681279df06db2080030fd0edf", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 30, "deletions": 41, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/466446b0799ad62b1426f0e73cf376051d667185/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/466446b0799ad62b1426f0e73cf376051d667185/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=466446b0799ad62b1426f0e73cf376051d667185", "patch": "@@ -838,7 +838,7 @@ char text_end_label[MAX_ARTIFICIAL_LABEL_BYTES];\n #ifdef PC_REGNUM\n #define DWARF_FRAME_RETURN_COLUMN \tDWARF_FRAME_REGNUM (PC_REGNUM)\n #else\n-#define DWARF_FRAME_RETURN_COLUMN \tFIRST_PSEUDO_REGISTER + 1\n+#define DWARF_FRAME_RETURN_COLUMN \tFIRST_PSEUDO_REGISTER\n #endif\n #endif\n \n@@ -6042,17 +6042,13 @@ add_name_attribute (die, name_string)\n }\n \n /* Given a tree node describing an array bound (either lower or upper) output\n-   a representation for that bound.\n-\n-   FIXME: This uses location descriptions for variable bounds, whereas the\n-   DWARF-2 spec only allowes for constants or DIE references.  */\n+   a representation for that bound.  */\n static void\n add_bound_info (subrange_die, bound_attr, bound)\n      register dw_die_ref subrange_die;\n      register enum dwarf_attribute bound_attr;\n      register tree bound;\n {\n-  register dw_loc_descr_ref bound_loc = NULL;\n   register unsigned bound_value = 0;\n   switch (TREE_CODE (bound))\n     {\n@@ -6077,43 +6073,36 @@ add_bound_info (subrange_die, bound_attr, bound)\n       /* ... fall thru...  */\n \n     case SAVE_EXPR:\n-      /* Handle the simple case of `int ar[i];'.  */\n-      if (bound_attr == DW_AT_upper_bound && is_c_family ()\n-\t  && TREE_CODE (TREE_OPERAND (bound, 0)) == MINUS_EXPR)\n-\t{\n-\t  tree t = TREE_OPERAND (bound, 0);\n-\t  if (integer_onep (TREE_OPERAND (bound, 1)))\n-\t    t = TREE_OPERAND (t, 0);\n-\t  if (TREE_CODE (t) == VAR_DECL || TREE_CODE (t) == PARM_DECL)\n-\t    {\n-\t      add_AT_die_ref (subrange_die, DW_AT_count, lookup_decl_die (t));\n-\t      return;\n-\t    }\n-\t}\n-\n       /* If optimization is turned on, the SAVE_EXPRs that describe how to\n-         access the upper bound values are essentially bogus. They only\n-         describe (at best) how to get at these values at the points in the\n-         generated code right after they have just been computed.  Worse\n-         yet, in the typical case, the upper bound values will not even\n-         *be* computed in the optimized code, so these SAVE_EXPRs are\n-         entirely bogus. In order to compensate for this fact, we check\n-         here to see if optimization is enabled, and if so, we don't add an\n-         attribute for the (unknown and unknowable) upper bound.  This\n-         should not cause too much trouble for existing (stupid?)\n-         debuggers because they have to deal with empty upper bounds\n-         location descriptions anyway in order to be able to deal with\n-         incomplete array types.  Of course an intelligent debugger (GDB?)\n-         should be able to comprehend that a missing upper bound\n-         specification in a array type used for a storage class `auto'\n-         local array variable indicates that the upper bound is both\n-         unknown (at compile- time) and unknowable (at run-time) due to\n-         optimization.  */\n-      if (!optimize)\n+         access the upper bound values may be bogus.  If they refer to a\n+         register, they may only describe how to get at these values at the\n+         points in the generated code right after they have just been\n+         computed.  Worse yet, in the typical case, the upper bound values\n+         will not even *be* computed in the optimized code (though the\n+         number of elements will), so these SAVE_EXPRs are entirely\n+         bogus. In order to compensate for this fact, we check here to see\n+         if optimization is enabled, and if so, we don't add an attribute\n+         for the (unknown and unknowable) upper bound.  This should not\n+         cause too much trouble for existing (stupid?)  debuggers because\n+         they have to deal with empty upper bounds location descriptions\n+         anyway in order to be able to deal with incomplete array types.\n+         Of course an intelligent debugger (GDB?)  should be able to\n+         comprehend that a missing upper bound specification in a array\n+         type used for a storage class `auto' local array variable\n+         indicates that the upper bound is both unknown (at compile- time)\n+         and unknowable (at run-time) due to optimization.\n+\n+\t We assume that a MEM rtx is safe because gcc wouldn't put the\n+\t value there unless it was going to be used repeatedly in the\n+\t function, i.e. for cleanups.  */\n+      if (! optimize || GET_CODE (SAVE_EXPR_RTL (bound)) == MEM)\n \t{\n-\t  bound_loc = mem_loc_descriptor\n-\t    (eliminate_regs (SAVE_EXPR_RTL (bound), 0, NULL_RTX, 0));\n-\t  add_AT_loc (subrange_die, bound_attr, bound_loc);\n+\t  register dw_die_ref ctx = lookup_decl_die (current_function_decl);\n+\t  register dw_die_ref decl_die = new_die (DW_TAG_variable, ctx);\n+\t  add_AT_flag (decl_die, DW_AT_artificial, 1);\n+\t  add_type_attribute (decl_die, TREE_TYPE (bound), 1, 0, ctx);\n+\t  add_location_attribute (decl_die, SAVE_EXPR_RTL (bound));\n+\t  add_AT_die_ref (subrange_die, bound_attr, decl_die);\n \t}\n       /* else leave out the attribute.  */\n       break;"}]}