{"sha": "dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiYmJmM2I4ZDU4NTMzYWE4OTUzMjNmMGRlMWJkNzdjODE2YmY0MA==", "commit": {"author": {"name": "John David Anglin", "email": "dave@hiauly1.hia.nrc.ca", "date": "2001-03-02T21:41:37Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2001-03-02T21:41:37Z"}, "message": "print-rtl.c (print_rtx): Cast enums to int for comparison.\n\n\t* print-rtl.c (print_rtx): Cast enums to int for comparison.\n\t* c-decl.c (grokdeclarator): Cast enums to int for comparison and\n\tshifts.\n\t* c-format.c (C_STD_VER): Cast to int for comparisons.\n\t(check_function_format): Cast various enums to int for &.\n\t(maybe_read_dollar_number): Likewise.\n\t(check_format_info): Likewise.\n\t(check_format_info_main): Likewise.\n\t* expr.c (emit_move_insn_1): Cast enums to unsigned int for comparison.\n\t(safe_from_p): Likewise.\n\t* varasm.c (const_hash): Cast enum to int for %.\n\t* emit-rtl.c (init_emit_once): Use int loop variable to work around\n\tpcc enum problems with < and ++ operators.\n\t* regclass.c (init_reg_sets_1): Cast enums for comparison.\n\t(choose_hard_reg_mode): Use unsigned int to iterate over CCmodes.\n\t(regclass_init): Change enum class to int to iterate over reg_classes.\n\t* genrecog.c (merge_trees): Cast enums for comparison.\n\t* rtl.h (GET_CODE): Cast to enum rtx_code.\n\t(PUT_CODE): Cast to ENUM_BITFIELD(rtx_code).\n\t(GET_MODE): Cast to enum machine_mode.\n\t(PUT_MODE): Cast to ENUM_BITFIELD(machine_mode).\n\t(GET_NOTE_INSN_NAME): Cast enum to int.\n\t* tree.h (TREE_CODE): Cast to enum tree_code.\n\t(TREE_SET_CODE): Cast VALUE to ENUM_BITFIELD(tree_code).\n        * timevar.c (timevar_print): Change loop variable id from enum to\n\tunsigned int.\n\t* fixinc/fixincl.c (VLEVEL): Cast enums in comparison to unsigned int.\n\t* config/i386/i386.md: Use PUT_MODE for mode assignment.\n\t* toplev.c (compile_file): Cast enum DFI to int.\n\t(decode_d_option): Likewise.\n\nFrom-SVN: r40193", "tree": {"sha": "8a00f5b43c598532f161eef6222794b0969e1a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8a00f5b43c598532f161eef6222794b0969e1a8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/comments", "author": null, "committer": null, "parents": [{"sha": "4cacbdf21f15a046165c16d75a329f7f52d96883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cacbdf21f15a046165c16d75a329f7f52d96883", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cacbdf21f15a046165c16d75a329f7f52d96883"}], "stats": {"total": 148, "additions": 95, "deletions": 53}, "files": [{"sha": "f64188df294204d983d3548218370088f72dc05d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -1,3 +1,36 @@\n+2001-03-02  John David Anglin  <dave@hiauly1.hia.nrc.ca>\n+\n+\t* print-rtl.c (print_rtx): Cast enums to int for comparison.\n+\t* c-decl.c (grokdeclarator): Cast enums to int for comparison and\n+\tshifts.\n+\t* c-format.c (C_STD_VER): Cast to int for comparisons.\n+\t(check_function_format): Cast various enums to int for &.\n+\t(maybe_read_dollar_number): Likewise.\n+\t(check_format_info): Likewise.\n+\t(check_format_info_main): Likewise.\n+\t* expr.c (emit_move_insn_1): Cast enums to unsigned int for comparison.\n+\t(safe_from_p): Likewise.\n+\t* varasm.c (const_hash): Cast enum to int for %.\n+\t* emit-rtl.c (init_emit_once): Use int loop variable to work around\n+\tpcc enum problems with < and ++ operators.\n+\t* regclass.c (init_reg_sets_1): Cast enums for comparison.\n+\t(choose_hard_reg_mode): Use unsigned int to iterate over CCmodes.\n+\t(regclass_init): Change enum class to int to iterate over reg_classes.\n+\t* genrecog.c (merge_trees): Cast enums for comparison.\n+\t* rtl.h (GET_CODE): Cast to enum rtx_code.\n+\t(PUT_CODE): Cast to ENUM_BITFIELD(rtx_code).\n+\t(GET_MODE): Cast to enum machine_mode.\n+\t(PUT_MODE): Cast to ENUM_BITFIELD(machine_mode).\n+\t(GET_NOTE_INSN_NAME): Cast enum to int.\n+\t* tree.h (TREE_CODE): Cast to enum tree_code.\n+\t(TREE_SET_CODE): Cast VALUE to ENUM_BITFIELD(tree_code).\n+        * timevar.c (timevar_print): Change loop variable id from enum to\n+\tunsigned int.\n+\t* fixinc/fixincl.c (VLEVEL): Cast enums in comparison to unsigned int.\n+\t* config/i386/i386.md: Use PUT_MODE for mode assignment.\n+\t* toplev.c (compile_file): Cast enum DFI to int.\n+\t(decode_d_option): Likewise.\n+\n Fri Mar  2 12:18:13 2001  Christopher Faylor <cgf@cygnus.com>\n \n \t* cppinit.c (append_include_chain): Mark \"after\" include file name list"}, {"sha": "f114ab50f2803351542f88903981aa9eb4fc58f0", "filename": "gcc/c-decl.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -3929,9 +3929,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n       if (TREE_CODE (id) == IDENTIFIER_NODE && C_IS_RESERVED_WORD (id))\n \t{\n \t  enum rid i = C_RID_CODE (id);\n-\t  if (i <= RID_LAST_MODIFIER)\n+\t  if ((int) i <= (int) RID_LAST_MODIFIER)\n \t    {\n-\t      if (i == RID_LONG && specbits & (1<<i))\n+\t      if (i == RID_LONG && (specbits & (1 << (int) i)))\n \t\t{\n \t\t  if (longlong)\n \t\t    error (\"`long long long' is too long for GCC\");\n@@ -3943,9 +3943,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized)\n \t\t      longlong = 1;\n \t\t    }\n \t\t}\n-\t      else if (specbits & (1 << i))\n+\t      else if (specbits & (1 << (int) i))\n \t\tpedwarn (\"duplicate `%s'\", IDENTIFIER_POINTER (id));\n-\t      specbits |= 1 << i;\n+\t      specbits |= 1 << (int) i;\n \t      goto found;\n \t    }\n \t}"}, {"sha": "b6270e2ae2769dea25f2252c40acc78110831091", "filename": "gcc/c-format.c", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -476,11 +476,11 @@ enum format_std_version\n    or inheriting from, for the purpose of format features supported.  */\n #define CPLUSPLUS_STD_VER\tSTD_C89\n /* The C standard version we are checking formats against when pedantic.  */\n-#define C_STD_VER\t\t(c_language == clk_cplusplus\t\t  \\\n+#define C_STD_VER\t\t((int)(c_language == clk_cplusplus\t  \\\n \t\t\t\t ? CPLUSPLUS_STD_VER\t\t\t  \\\n \t\t\t\t : (flag_isoc99\t\t\t\t  \\\n \t\t\t\t    ? STD_C99\t\t\t\t  \\\n-\t\t\t\t    : (flag_isoc94 ? STD_C94 : STD_C89)))\n+\t\t\t\t    : (flag_isoc94 ? STD_C94 : STD_C89))))\n /* The name to give to the standard version we are warning about when\n    pedantic.  FEATURE_VER is the version in which the feature warned out\n    appeared, which is higher than C_STD_VER.  */\n@@ -1105,7 +1105,8 @@ check_function_format (status, name, assembler_name, params)\n \t  /* Yup; check it.  */\n \t  check_format_info (status, info, params);\n \t  if (warn_missing_format_attribute && info->first_arg_num == 0\n-\t      && (format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n+\t      && (format_types[info->format_type].flags\n+\t\t  & (int) FMT_FLAG_ARG_CONVERT))\n \t    {\n \t      function_format_info *info2;\n \t      for (info2 = function_format_list; info2; info2 = info2->next)\n@@ -1298,7 +1299,7 @@ maybe_read_dollar_number (status, format, dollar_needed, params, param_ptr,\n \t      nalloc - dollar_arguments_alloc);\n       dollar_arguments_alloc = nalloc;\n     }\n-  if (!(fki->flags & FMT_FLAG_DOLLAR_MULTIPLE)\n+  if (!(fki->flags & (int) FMT_FLAG_DOLLAR_MULTIPLE)\n       && dollar_arguments_used[argnum - 1] == 1)\n     {\n       dollar_arguments_used[argnum - 1] = 2;\n@@ -1434,7 +1435,7 @@ check_format_info (status, info, params)\n       /* Functions taking a va_list normally pass a non-literal format\n \t string.  These functions typically are declared with\n \t first_arg_num == 0, so avoid warning in those cases.  */\n-      if (!(format_types[info->format_type].flags & FMT_FLAG_ARG_CONVERT))\n+      if (!(format_types[info->format_type].flags & (int) FMT_FLAG_ARG_CONVERT))\n \t{\n \t  /* For strftime-like formats, warn for not checking the format\n \t     string; but there are no arguments to check.  */\n@@ -1746,7 +1747,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \t}\n       flag_chars[0] = 0;\n \n-      if ((fki->flags & FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n+      if ((fki->flags & (int) FMT_FLAG_USE_DOLLAR) && has_operand_number != 0)\n \t{\n \t  /* Possibly read a $ operand number at the start of the format.\n \t     If one was previously used, one is required here.  If one\n@@ -1867,7 +1868,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \t\t  ++format_chars;\n \t\t}\n \t      if (found_width && !non_zero_width_char &&\n-\t\t  (fki->flags & FMT_FLAG_ZERO_WIDTH_BAD))\n+\t\t  (fki->flags & (int) FMT_FLAG_ZERO_WIDTH_BAD))\n \t\tstatus_warning (status, \"zero width in %s format\",\n \t\t\t\tfki->name);\n \t      if (found_width)\n@@ -1954,7 +1955,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \t    }\n \t  else\n \t    {\n-\t      if (!(fki->flags & FMT_FLAG_EMPTY_PREC_OK)\n+\t      if (!(fki->flags & (int) FMT_FLAG_EMPTY_PREC_OK)\n \t\t  && !ISDIGIT (*format_chars))\n \t\tstatus_warning (status, \"empty precision in %s format\",\n \t\t\t\tfki->name);\n@@ -2025,7 +2026,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \t}\n \n       /* Handle the scanf allocation kludge.  */\n-      if (fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+      if (fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n \t{\n \t  if (*format_chars == 'a' && !flag_isoc99)\n \t    {\n@@ -2043,7 +2044,8 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \n       format_char = *format_chars;\n       if (format_char == 0\n-\t  || (!(fki->flags & FMT_FLAG_FANCY_PERCENT_OK) && format_char == '%'))\n+\t  || (!(fki->flags & (int) FMT_FLAG_FANCY_PERCENT_OK)\n+\t      && format_char == '%'))\n \t{\n \t  status_warning (status, \"conversion lacks type at end of format\");\n \t  continue;\n@@ -2109,7 +2111,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \tflag_chars[i - d] = 0;\n       }\n \n-      if ((fki->flags & FMT_FLAG_SCANF_A_KLUDGE)\n+      if ((fki->flags & (int) FMT_FLAG_SCANF_A_KLUDGE)\n \t  && strchr (flag_chars, 'a') != 0)\n \taflag = 1;\n \n@@ -2190,7 +2192,7 @@ check_format_info_main (status, res, info, format_chars, format_length,\n \n       wanted_type = 0;\n       wanted_type_name = 0;\n-      if (fki->flags & FMT_FLAG_ARG_CONVERT)\n+      if (fki->flags & (int) FMT_FLAG_ARG_CONVERT)\n \t{\n \t  wanted_type = (fci->types[length_chars_val].type\n \t\t\t ? *fci->types[length_chars_val].type : 0);"}, {"sha": "51e0e70ce76c204d1083f05a91c44fb63ad8fac1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -12759,7 +12759,7 @@\n    operands[1] = gen_lowpart (SImode, operands[1]);\n    if (GET_CODE (operands[3]) != ASHIFT)\n      operands[2] = gen_lowpart (SImode, operands[2]);\n-   GET_MODE (operands[3]) = SImode;\")\n+   PUT_MODE (operands[3], SImode);\")\n \n (define_split\n   [(set (reg 17)"}, {"sha": "2d4e7c283891acb31fb3d47763be963b0c6270b1", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -4140,9 +4140,9 @@ init_emit_once (line_numbers)\n \tconst_tiny_rtx[i][(int) mode] = GEN_INT (i);\n     }\n \n-  for (mode = CCmode; mode < MAX_MACHINE_MODE; ++mode)\n-    if (GET_MODE_CLASS (mode) == MODE_CC)\n-      const_tiny_rtx[0][(int) mode] = const0_rtx;\n+  for (i = (int) CCmode; i < (int) MAX_MACHINE_MODE; ++i)\n+    if (GET_MODE_CLASS ((enum machine_mode) i) == MODE_CC)\n+      const_tiny_rtx[0][i] = const0_rtx;\n \n   const_tiny_rtx[0][(int) BImode] = const0_rtx;\n   if (STORE_FLAG_VALUE == 1)"}, {"sha": "ff3f5bf354d7ad489527290bf7db1d828d48b0a3", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -2766,7 +2766,7 @@ emit_move_insn_1 (x, y)\n   enum mode_class class = GET_MODE_CLASS (mode);\n   unsigned int i;\n \n-  if (mode >= MAX_MACHINE_MODE)\n+  if ((unsigned int) mode >= (unsigned int) MAX_MACHINE_MODE)\n     abort ();\n \n   if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n@@ -5766,7 +5766,8 @@ safe_from_p (x, exp, top_p)\n \n       /* If this is a language-specific tree code, it may require\n \t special handling.  */\n-      if (TREE_CODE (exp) >= LAST_AND_UNUSED_TREE_CODE\n+      if ((unsigned int) TREE_CODE (exp)\n+\t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE\n \t  && lang_safe_from_p\n \t  && !(*lang_safe_from_p) (x, exp))\n \treturn 0;"}, {"sha": "88fffbd2bd69224c6feddd66a47d8fded07c6d3c", "filename": "gcc/fixinc/fixincl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ffixinc%2Ffixincl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ffixinc%2Ffixincl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffixinc%2Ffixincl.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -67,7 +67,7 @@ typedef enum {\n te_verbose  verbose_level = VERB_PROGRESS;\n int have_tty = 0;\n \n-#define VLEVEL(l)  (verbose_level >= l)\n+#define VLEVEL(l)  ((unsigned int) verbose_level >= (unsigned int) l)\n #define NOT_SILENT VLEVEL(VERB_FIXES)\n \n pid_t process_chain_head = (pid_t) -1;"}, {"sha": "2856fe67d8abbf646ecb8acd508bcde2d3bee0bf", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -1432,7 +1432,7 @@ merge_trees (oldh, addh)\n \t     how expensive/important the test is.  Given that the tests\n \t     are also ordered within the list, examining the first is\n \t     sufficient.  */\n-\t  if (add->tests->type < old->tests->type)\n+\t  if ((int) add->tests->type < (int) old->tests->type)\n \t    insert_before = old;\n \t}\n "}, {"sha": "aeae71e89b651cc7b459b94fa8f2d6ed5d7f3458", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -373,8 +373,8 @@ print_rtx (in_rtx)\n       /* Print NOTE_INSN names rather than integer codes.  */\n \n       case 'n':\n-\tif (XINT (in_rtx, i) >= NOTE_INSN_BIAS\n-\t    && XINT (in_rtx, i) < NOTE_INSN_MAX)\n+\tif (XINT (in_rtx, i) >= (int) NOTE_INSN_BIAS\n+\t    && XINT (in_rtx, i) < (int) NOTE_INSN_MAX)\n \t  fprintf (outfile, \" %s\", GET_NOTE_INSN_NAME (XINT (in_rtx, i)));\n \telse\n \t  fprintf (outfile, \" %d\", XINT (in_rtx, i));"}, {"sha": "f65b2e9dd917ed0d3004e0de1c4bbdaa78a06fca", "filename": "gcc/regclass.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -430,7 +430,7 @@ init_reg_sets_1 ()\n     }\n   memset (contains_reg_of_mode, 0, sizeof (contains_reg_of_mode));\n   memset (allocatable_regs_of_mode, 0, sizeof (allocatable_regs_of_mode));\n-  for (m = 0; m < MAX_MACHINE_MODE; m++)\n+  for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n     for (i = 0; i < N_REG_CLASSES; i++)\n       if (CLASS_MAX_NREGS (i, m) <= reg_class_size[i])\n \tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n@@ -445,7 +445,7 @@ init_reg_sets_1 ()\n   /* Initialize the move cost table.  Find every subset of each class\n      and take the maximum cost of moving any subset to any other.  */\n \n-  for (m = 0; m < MAX_MACHINE_MODE; m++)\n+  for (m = 0; m < (unsigned int) MAX_MACHINE_MODE; m++)\n     if (allocatable_regs_of_mode [m])\n       {\n \tfor (i = 0; i < N_REG_CLASSES; i++)\n@@ -631,6 +631,7 @@ choose_hard_reg_mode (regno, nregs)\n      unsigned int regno ATTRIBUTE_UNUSED;\n      unsigned int nregs;\n {\n+  unsigned int /* enum machine_mode */ m;\n   enum machine_mode found_mode = VOIDmode, mode;\n \n   /* We first look for the largest integer mode that can be validly\n@@ -658,10 +659,13 @@ choose_hard_reg_mode (regno, nregs)\n     return found_mode;\n \n   /* Iterate over all of the CCmodes.  */\n-  for (mode = CCmode; mode < NUM_MACHINE_MODES; ++mode)\n-    if (HARD_REGNO_NREGS (regno, mode) == nregs\n-        && HARD_REGNO_MODE_OK (regno, mode))\n-    return mode;\n+  for (m = (unsigned int) CCmode; m < (unsigned int) NUM_MACHINE_MODES; ++m)\n+    {\n+      mode = (enum machine_mode) m;\n+      if (HARD_REGNO_NREGS (regno, mode) == nregs\n+\t  && HARD_REGNO_MODE_OK (regno, mode))\n+\treturn mode;\n+    }\n \n   /* We can't find a mode valid for this register.  */\n   return VOIDmode;\n@@ -859,22 +863,23 @@ dump_regclass (dump)\n   int i;\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n-      enum reg_class class;\n+      int /* enum reg_class */ class;\n       if (REG_N_REFS (i))\n \t{\n \t  fprintf (dump, \"  Register %i costs:\", i);\n-\t  for (class = 0; class < N_REG_CLASSES; class++)\n-\t    if (contains_reg_of_mode [class][PSEUDO_REGNO_MODE (i)]\n+\t  for (class = 0; class < (int) N_REG_CLASSES; class++)\n+\t    if (contains_reg_of_mode [(enum reg_class) class][PSEUDO_REGNO_MODE (i)]\n #ifdef FORBIDDEN_INC_DEC_CLASSES\n-\t\t&& (!in_inc_dec[i] || !forbidden_inc_dec_class[class])\n+\t\t&& (!in_inc_dec[i]\n+\t\t    || !forbidden_inc_dec_class[(enum reg_class) class])\n #endif\n #ifdef CLASS_CANNOT_CHANGE_MODE\n \t\t&& (!REGNO_REG_SET_P (reg_changes_mode, i)\n-\t\t     || class_can_change_mode [class])\n+\t\t     || class_can_change_mode [(enum reg_class) class])\n #endif\n \t\t)\n-\t    fprintf (dump, \" %s:%i\", reg_class_names[(int) class],\n-\t\t     costs[i].cost[class]);\n+\t    fprintf (dump, \" %s:%i\", reg_class_names[class],\n+\t\t     costs[i].cost[(enum reg_class) class]);\n \t  fprintf (dump, \" MEM:%i\\n\", costs[i].mem_cost);\n \t}\n     }"}, {"sha": "58f74282767dafd3a50d88747ffa76969ae628b4", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -184,11 +184,11 @@ typedef struct rtx_def\n \n /* Define macros to access the `code' field of the rtx.  */\n \n-#define GET_CODE(RTX)\t\t((RTX)->code)\n-#define PUT_CODE(RTX, CODE)\t((RTX)->code = (CODE))\n+#define GET_CODE(RTX)\t    ((enum rtx_code) (RTX)->code)\n+#define PUT_CODE(RTX, CODE) ((RTX)->code = (ENUM_BITFIELD(rtx_code)) (CODE))\n \n-#define GET_MODE(RTX)\t\t((RTX)->mode)\n-#define PUT_MODE(RTX, MODE)\t((RTX)->mode = (MODE))\n+#define GET_MODE(RTX)\t    ((enum machine_mode) (RTX)->mode)\n+#define PUT_MODE(RTX, MODE) ((RTX)->mode = (ENUM_BITFIELD(machine_mode)) (MODE))\n \n #define RTX_INTEGRATED_P(RTX) ((RTX)->integrated)\n #define RTX_UNCHANGING_P(RTX) ((RTX)->unchanging)\n@@ -702,7 +702,7 @@ enum insn_note\n \n extern const char * const note_insn_name[NOTE_INSN_MAX - NOTE_INSN_BIAS];\n #define GET_NOTE_INSN_NAME(NOTE_CODE) \\\n-  (note_insn_name[(NOTE_CODE) - NOTE_INSN_BIAS])\n+  (note_insn_name[(NOTE_CODE) - (int) NOTE_INSN_BIAS])\n \n /* The name of a label, in case it corresponds to an explicit label\n    in the input source code.  */"}, {"sha": "fd0f76cf2b90b510049d20f0d7940478e47be8a7", "filename": "gcc/timevar.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -401,7 +401,7 @@ timevar_print (fp)\n {\n   /* Only print stuff if we have some sort of time information.  */\n #if defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) || defined (HAVE_WALL_TIME)\n-  timevar_id_t id;\n+  unsigned int /* timevar_id_t */ id;\n   struct timevar_time_def *total = &timevars[TV_TOTAL].elapsed;\n   struct timevar_time_def now;\n \n@@ -426,13 +426,13 @@ timevar_print (fp)\n   start_time = now;\n \n   fprintf (fp, _(\"\\nExecution times (seconds)\\n\"));\n-  for (id = 0; id < TIMEVAR_LAST; ++id)\n+  for (id = 0; id < (unsigned int) TIMEVAR_LAST; ++id)\n     {\n-      struct timevar_def *tv = &timevars[id];\n+      struct timevar_def *tv = &timevars[(timevar_id_t) id];\n \n       /* Don't print the total execution time here; that goes at the\n \t end.  */\n-      if (id == TV_TOTAL)\n+      if ((timevar_id_t) id == TV_TOTAL)\n \tcontinue;\n \n       /* Don't print timing variables that were never used.  */"}, {"sha": "73f1b8fc517dc00770ea8ad5631747a2ad767e0d", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -2500,7 +2500,7 @@ compile_file (name)\n     {\n       int i;\n \n-      for (i = 0; i < DFI_MAX; ++i)\n+      for (i = 0; i < (int) DFI_MAX; ++i)\n \tif (dump_file[i].initialized && dump_file[i].graph_dump_p)\n \t  {\n \t    char seq[16];\n@@ -4021,7 +4021,7 @@ decode_d_option (arg)\n     switch (c = *arg++)\n       {\n       case 'a':\n-\tfor (i = 0; i < DFI_MAX; ++i)\n+\tfor (i = 0; i < (int) DFI_MAX; ++i)\n \t  dump_file[i].enabled = 1;\n \tbreak;\n       case 'A':\n@@ -4052,7 +4052,7 @@ decode_d_option (arg)\n \n       default:\n \tmatched = 0;\n-\tfor (i = 0; i < DFI_MAX; ++i)\n+\tfor (i = 0; i < (int) DFI_MAX; ++i)\n \t  if (c == dump_file[i].debug_switch)\n \t    {\n \t      dump_file[i].enabled = 1;"}, {"sha": "d6dde70b56315c49ab04a06be17a48f812015376", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -272,7 +272,8 @@ struct tree_common\n /* The tree-code says what kind of node it is.\n    Codes are defined in tree.def.  */\n #define TREE_CODE(NODE) ((enum tree_code) (NODE)->common.code)\n-#define TREE_SET_CODE(NODE, VALUE) ((NODE)->common.code = (int) (VALUE))\n+#define TREE_SET_CODE(NODE, VALUE) \\\n+((NODE)->common.code = (ENUM_BITFIELD(tree_code)) (VALUE))\n \n /* When checking is enabled, errors will be generated if a tree node\n    is accessed incorrectly. The macros abort with a fatal error.  */"}, {"sha": "55c72d1ad0a8a34f043e5c4c1a60763dc2aa8f15", "filename": "gcc/varasm.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbbbbf3b8d58533aa895323f0de1bd77c816bf40/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=dbbbbf3b8d58533aa895323f0de1bd77c816bf40", "patch": "@@ -2431,7 +2431,7 @@ const_hash (exp)\n       \n     default:\n       /* A language specific constant. Just hash the code. */\n-      return code % MAX_HASH_TABLE;\n+      return (int) code % MAX_HASH_TABLE;\n     }\n \n   /* Compute hashing function */"}]}