{"sha": "cfef4c324ac300c0ad120f0fcee376159de84a0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2ZlZjRjMzI0YWMzMDBjMGFkMTIwZjBmY2VlMzc2MTU5ZGU4NGEwYw==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-10-11T16:37:23Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-10-11T16:37:23Z"}, "message": "PR libstdc++/80538 Only call sleep for non-zero values\n\nAvoid a system call when no sleep is required. Sleep in a loop (actually\ntwo loops) to handle interruption by signals.\n\n\tPR libstdc++/80538\n\t* src/c++11/thread.cc (this_thread::__sleep_for)\n\t[_GLIBCXX_HAVE_SLEEP]: Only call sleep for non-zero values.\n\tLoop while sleep call is interrupted and until steady_clock\n\tshows requested duration has elapsed.\n\t(!_GLIBCXX_HAVE_USLEEP]: Use the _GLIBCXX_HAVE_SLEEP code path, but\n\tavoiding the usleep call.\n\t* testsuite/30_threads/this_thread/60421.cc: Test repeated\n\tsignal interruptions.\n\nFrom-SVN: r265044", "tree": {"sha": "9b0e03e36a75417b591a69a6f9f7405dbbc6f053", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b0e03e36a75417b591a69a6f9f7405dbbc6f053"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cfef4c324ac300c0ad120f0fcee376159de84a0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfef4c324ac300c0ad120f0fcee376159de84a0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfef4c324ac300c0ad120f0fcee376159de84a0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfef4c324ac300c0ad120f0fcee376159de84a0c/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2045ae1d3f511717c2a1223148ce63f71800e1dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2045ae1d3f511717c2a1223148ce63f71800e1dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2045ae1d3f511717c2a1223148ce63f71800e1dd"}], "stats": {"total": 60, "additions": 48, "deletions": 12}, "files": [{"sha": "b92fdf14cacc59dd31f6532079ccca8c009583ee", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cfef4c324ac300c0ad120f0fcee376159de84a0c", "patch": "@@ -1,5 +1,15 @@\n 2018-10-11  Jonathan Wakely  <jwakely@redhat.com>\n \n+\tPR libstdc++/80538\n+\t* src/c++11/thread.cc (this_thread::__sleep_for)\n+\t[_GLIBCXX_HAVE_SLEEP]: Only call sleep for non-zero values.\n+\tLoop while sleep call is interrupted and until steady_clock\n+\tshows requested duration has elapsed.\n+\t(!_GLIBCXX_HAVE_USLEEP]: Use the _GLIBCXX_HAVE_SLEEP code path, but\n+\tavoiding the usleep call.\n+\t* testsuite/30_threads/this_thread/60421.cc: Test repeated\n+\tsignal interruptions.\n+\n \t* include/bits/allocator.h\n \t(operator==(const allocator<_Tp>&, const allocator<_Tp>))\n \t(operator!=(const allocator<_Tp>&, const allocator<_Tp>)): Replace"}, {"sha": "564eae6f1663fa0ef88289d435889e0ac302d148", "filename": "libstdc++-v3/src/c++11/thread.cc", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fthread.cc?ref=cfef4c324ac300c0ad120f0fcee376159de84a0c", "patch": "@@ -194,18 +194,35 @@ namespace this_thread\n     while (::nanosleep(&__ts, &__ts) == -1 && errno == EINTR)\n       { }\n #elif defined(_GLIBCXX_HAVE_SLEEP)\n-# ifdef _GLIBCXX_HAVE_USLEEP\n-    ::sleep(__s.count());\n-    if (__ns.count() > 0)\n+    const auto target = chrono::steady_clock::now() + __s + __ns;\n+    while (true)\n       {\n-        long __us = __ns.count() / 1000;\n-        if (__us == 0)\n-          __us = 1;\n-        ::usleep(__us);\n-      }\n+\tunsigned secs = __s.count();\n+\tif (__ns.count() > 0)\n+\t  {\n+# ifdef _GLIBCXX_HAVE_USLEEP\n+\t    long us = __ns.count() / 1000;\n+\t    if (us == 0)\n+\t      us = 1;\n+\t    ::usleep(us);\n # else\n-    ::sleep(__s.count() + (__ns.count() >= 1000000));\n+\t    if (__ns.count() > 1000000 || secs == 0)\n+\t      ++secs; // No sub-second sleep function, so round up.\n # endif\n+\t  }\n+\n+\tif (secs > 0)\n+\t  {\n+\t    // Sleep in a loop to handle interruption by signals:\n+\t    while ((secs = ::sleep(secs)))\n+\t      { }\n+\t  }\n+\tconst auto now = chrono::steady_clock::now();\n+\tif (now >= target)\n+\t  break;\n+\t__s = chrono::duration_cast<chrono::seconds>(target - now);\n+\t__ns = chrono::duration_cast<chrono::nanoseconds>(target - (now + __s));\n+    }\n #elif defined(_GLIBCXX_HAVE_WIN32_SLEEP)\n     unsigned long ms = __ns.count() / 1000000;\n     if (__ns.count() > 0 && ms == 0)"}, {"sha": "cd8d2fdd6f387d4f4d1ffca0a727522f376b87d8", "filename": "libstdc++-v3/testsuite/30_threads/this_thread/60421.cc", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F60421.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cfef4c324ac300c0ad120f0fcee376159de84a0c/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F60421.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F60421.cc?ref=cfef4c324ac300c0ad120f0fcee376159de84a0c", "patch": "@@ -53,10 +53,19 @@ test02()\n     sleeping = true;\n     std::this_thread::sleep_for(time);\n     result = std::chrono::system_clock::now() >= (start + time);\n+    sleeping = false;\n   });\n-  while (!sleeping) { }\n-  std::this_thread::sleep_for(std::chrono::milliseconds(500));\n-  pthread_kill(t.native_handle(), SIGUSR1);\n+  while (!sleeping)\n+  {\n+    // Wait for the thread to start sleeping.\n+  }\n+  while (sleeping)\n+  {\n+    // The sleeping thread should finish eventually,\n+    // even if continually interrupted after less than a second:\n+    std::this_thread::sleep_for(std::chrono::milliseconds(500));\n+    pthread_kill(t.native_handle(), SIGUSR1);\n+  }\n   t.join();\n   VERIFY( result );\n }"}]}