{"sha": "1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNiZmVjY2M4ZDVkZGFkZTNhMTcyN2UxOGZlMzFjMWU4M2U4MTcwMQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-06-20T08:16:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-06-20T08:16:08Z"}, "message": "[8/n] PR85694: Make patterns check for target support\n\nThis patch makes pattern recognisers do their own checking for vector\ntypes and target support.  Previously some recognisers did this\nthemselves and some left it to vect_pattern_recog_1.\n\nDoing this means we can get rid of the type_in argument, which was\nignored if the recogniser did its own checking.  It also means\nwe create fewer junk statements.\n\n2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (NUM_PATTERNS, vect_recog_func_ptr): Move to\n\ttree-vect-patterns.c.\n\t* tree-vect-patterns.c (vect_supportable_direct_optab_p): New function.\n\t(vect_recog_dot_prod_pattern): Use it.  Remove the type_in argument.\n\t(vect_recog_sad_pattern): Likewise.\n\t(vect_recog_widen_sum_pattern): Likewise.\n\t(vect_recog_pow_pattern): Likewise.  Check for a null vectype.\n\t(vect_recog_widen_shift_pattern): Remove the type_in argument.\n\t(vect_recog_rotate_pattern): Likewise.\n\t(vect_recog_mult_pattern): Likewise.\n\t(vect_recog_vector_vector_shift_pattern): Likewise.\n\t(vect_recog_divmod_pattern): Likewise.\n\t(vect_recog_mixed_size_cond_pattern): Likewise.\n\t(vect_recog_bool_pattern): Likewise.\n\t(vect_recog_mask_conversion_pattern): Likewise.\n\t(vect_try_gather_scatter_pattern): Likewise.\n\t(vect_recog_widen_mult_pattern): Likewise.  Check for a null vectype.\n\t(vect_recog_over_widening_pattern): Likewise.\n\t(vect_recog_gather_scatter_pattern): Likewise.\n\t(vect_recog_func_ptr): Move from tree-vectorizer.h\n\t(vect_vect_recog_func_ptrs): Move further down the file.\n\t(vect_recog_func): Likewise.  Remove the third argument.\n\t(NUM_PATTERNS): Define based on vect_vect_recog_func_ptrs.\n\t(vect_pattern_recog_1): Expect the pattern function to do any\n\tnecessary target tests.  Also expect it to provide a vector type.\n\tRemove the type_in handling.\n\nFrom-SVN: r261791", "tree": {"sha": "03fd5c3746c40e31c997a0d2ed3516cc65726482", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/03fd5c3746c40e31c997a0d2ed3516cc65726482"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "49d8df1b95ac68fee5420a4ad7a0cab006302e0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d8df1b95ac68fee5420a4ad7a0cab006302e0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d8df1b95ac68fee5420a4ad7a0cab006302e0e"}], "stats": {"total": 368, "additions": 161, "deletions": 207}, "files": [{"sha": "ff47deb5e5b2f2f0a524e7d65213bdb5a735a6cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "patch": "@@ -1,3 +1,32 @@\n+2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (NUM_PATTERNS, vect_recog_func_ptr): Move to\n+\ttree-vect-patterns.c.\n+\t* tree-vect-patterns.c (vect_supportable_direct_optab_p): New function.\n+\t(vect_recog_dot_prod_pattern): Use it.  Remove the type_in argument.\n+\t(vect_recog_sad_pattern): Likewise.\n+\t(vect_recog_widen_sum_pattern): Likewise.\n+\t(vect_recog_pow_pattern): Likewise.  Check for a null vectype.\n+\t(vect_recog_widen_shift_pattern): Remove the type_in argument.\n+\t(vect_recog_rotate_pattern): Likewise.\n+\t(vect_recog_mult_pattern): Likewise.\n+\t(vect_recog_vector_vector_shift_pattern): Likewise.\n+\t(vect_recog_divmod_pattern): Likewise.\n+\t(vect_recog_mixed_size_cond_pattern): Likewise.\n+\t(vect_recog_bool_pattern): Likewise.\n+\t(vect_recog_mask_conversion_pattern): Likewise.\n+\t(vect_try_gather_scatter_pattern): Likewise.\n+\t(vect_recog_widen_mult_pattern): Likewise.  Check for a null vectype.\n+\t(vect_recog_over_widening_pattern): Likewise.\n+\t(vect_recog_gather_scatter_pattern): Likewise.\n+\t(vect_recog_func_ptr): Move from tree-vectorizer.h\n+\t(vect_vect_recog_func_ptrs): Move further down the file.\n+\t(vect_recog_func): Likewise.  Remove the third argument.\n+\t(NUM_PATTERNS): Define based on vect_vect_recog_func_ptrs.\n+\t(vect_pattern_recog_1): Expect the pattern function to do any\n+\tnecessary target tests.  Also expect it to provide a vector type.\n+\tRemove the type_in handling.\n+\n 2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_pattern_detected): New function."}, {"sha": "a07b1a991591fd4b8dd9ee635512115ad38bc05f", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 132, "deletions": 205, "changes": 337, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "patch": "@@ -47,66 +47,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-simd-clone.h\"\n #include \"predict.h\"\n \n-/* Pattern recognition functions  */\n-static gimple *vect_recog_widen_sum_pattern (vec<gimple *> *, tree *,\n-\t\t\t\t\t    tree *);\n-static gimple *vect_recog_widen_mult_pattern (vec<gimple *> *, tree *,\n-\t\t\t\t\t     tree *);\n-static gimple *vect_recog_dot_prod_pattern (vec<gimple *> *, tree *,\n-\t\t\t\t\t   tree *);\n-static gimple *vect_recog_sad_pattern (vec<gimple *> *, tree *,\n-\t\t\t\t      tree *);\n-static gimple *vect_recog_pow_pattern (vec<gimple *> *, tree *, tree *);\n-static gimple *vect_recog_over_widening_pattern (vec<gimple *> *, tree *,\n-                                                 tree *);\n-static gimple *vect_recog_widen_shift_pattern (vec<gimple *> *,\n-\t                                tree *, tree *);\n-static gimple *vect_recog_rotate_pattern (vec<gimple *> *, tree *, tree *);\n-static gimple *vect_recog_vector_vector_shift_pattern (vec<gimple *> *,\n-\t\t\t\t\t\t      tree *, tree *);\n-static gimple *vect_recog_divmod_pattern (vec<gimple *> *,\n-\t\t\t\t\t tree *, tree *);\n-\n-static gimple *vect_recog_mult_pattern (vec<gimple *> *,\n-\t\t\t\t       tree *, tree *);\n-\n-static gimple *vect_recog_mixed_size_cond_pattern (vec<gimple *> *,\n-\t\t\t\t\t\t  tree *, tree *);\n-static gimple *vect_recog_bool_pattern (vec<gimple *> *, tree *, tree *);\n-static gimple *vect_recog_mask_conversion_pattern (vec<gimple *> *, tree *, tree *);\n-static gimple *vect_recog_gather_scatter_pattern (vec<gimple *> *, tree *,\n-\t\t\t\t\t\t  tree *);\n-\n-struct vect_recog_func\n-{\n-  vect_recog_func_ptr fn;\n-  const char *name;\n-};\n-\n-/* Note that ordering matters - the first pattern matching on a stmt\n-   is taken which means usually the more complex one needs to preceed\n-   the less comples onex (widen_sum only after dot_prod or sad for example).  */\n-static vect_recog_func vect_vect_recog_func_ptrs[NUM_PATTERNS] = {\n-      { vect_recog_widen_mult_pattern, \"widen_mult\" },\n-      { vect_recog_dot_prod_pattern, \"dot_prod\" },\n-      { vect_recog_sad_pattern, \"sad\" },\n-      { vect_recog_widen_sum_pattern, \"widen_sum\" },\n-      { vect_recog_pow_pattern, \"pow\" },\n-      { vect_recog_widen_shift_pattern, \"widen_shift\" },\n-      { vect_recog_over_widening_pattern, \"over_widening\" },\n-      { vect_recog_rotate_pattern, \"rotate\" },\n-      { vect_recog_vector_vector_shift_pattern, \"vector_vector_shift\" },\n-      {\tvect_recog_divmod_pattern, \"divmod\" },\n-      {\tvect_recog_mult_pattern, \"mult\" },\n-      {\tvect_recog_mixed_size_cond_pattern, \"mixed_size_cond\" },\n-      {\tvect_recog_bool_pattern, \"bool\" },\n-      /* This must come before mask conversion, and includes the parts\n-\t of mask conversion that are needed for gather and scatter\n-\t internal functions.  */\n-      { vect_recog_gather_scatter_pattern, \"gather_scatter\" },\n-      {\tvect_recog_mask_conversion_pattern, \"mask_conversion\" }\n-};\n-\n /* Report that we've found an instance of pattern PATTERN in\n    statement STMT.  */\n \n@@ -134,6 +74,49 @@ new_pattern_def_seq (stmt_vec_info stmt_info, gimple *stmt)\n   append_pattern_def_seq (stmt_info, stmt);\n }\n \n+/* Return true if the target supports a vector version of CODE,\n+   where CODE is known to map to a direct optab.  ITYPE specifies\n+   the type of (some of) the scalar inputs and OTYPE specifies the\n+   type of the scalar result.\n+\n+   If CODE allows the inputs and outputs to have different type\n+   (such as for WIDEN_SUM_EXPR), it is the input mode rather\n+   than the output mode that determines the appropriate target pattern.\n+   Operand 0 of the target pattern then specifies the mode that the output\n+   must have.\n+\n+   When returning true, set *VECOTYPE_OUT to the vector version of OTYPE.\n+   Also set *VECITYPE_OUT to the vector version of ITYPE if VECITYPE_OUT\n+   is nonnull.  */\n+\n+static bool\n+vect_supportable_direct_optab_p (tree otype, tree_code code,\n+\t\t\t\t tree itype, tree *vecotype_out,\n+\t\t\t\t tree *vecitype_out = NULL)\n+{\n+  tree vecitype = get_vectype_for_scalar_type (itype);\n+  if (!vecitype)\n+    return false;\n+\n+  tree vecotype = get_vectype_for_scalar_type (otype);\n+  if (!vecotype)\n+    return false;\n+\n+  optab optab = optab_for_tree_code (code, vecitype, optab_default);\n+  if (!optab)\n+    return false;\n+\n+  insn_code icode = optab_handler (optab, TYPE_MODE (vecitype));\n+  if (icode == CODE_FOR_nothing\n+      || insn_data[icode].operand[0].mode != TYPE_MODE (vecotype))\n+    return false;\n+\n+  *vecotype_out = vecotype;\n+  if (vecitype_out)\n+    *vecitype_out = vecitype;\n+  return true;\n+}\n+\n /* Check whether STMT2 is in the same loop or basic block as STMT1.\n    Which of the two applies depends on whether we're currently doing\n    loop-based or basic-block-based vectorization, as determined by\n@@ -293,8 +276,6 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output  of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n@@ -310,8 +291,7 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n          inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple *\n-vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t     tree *type_out)\n+vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *stmt, *last_stmt = (*stmts)[0];\n   tree oprnd0, oprnd1;\n@@ -448,8 +428,9 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n   vect_pattern_detected (\"vect_recog_dot_prod_pattern\", last_stmt);\n \n   half_type = TREE_TYPE (oprnd00);\n-  *type_in = half_type;\n-  *type_out = type;\n+  if (!vect_supportable_direct_optab_p (type, DOT_PROD_EXPR, half_type,\n+\t\t\t\t\ttype_out))\n+    return NULL;\n \n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt = gimple_build_assign (var, DOT_PROD_EXPR,\n@@ -489,8 +470,6 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n@@ -499,8 +478,7 @@ vect_recog_dot_prod_pattern (vec<gimple *> *stmts, tree *type_in,\n   */\n \n static gimple *\n-vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t     tree *type_out)\n+vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = (*stmts)[0];\n   tree sad_oprnd0, sad_oprnd1;\n@@ -641,8 +619,9 @@ vect_recog_sad_pattern (vec<gimple *> *stmts, tree *type_in,\n \n   vect_pattern_detected (\"vect_recog_sad_pattern\", last_stmt);\n \n-  *type_in = TREE_TYPE (sad_oprnd0);\n-  *type_out = sum_type;\n+  if (!vect_supportable_direct_optab_p (sum_type, SAD_EXPR,\n+\t\t\t\t\tTREE_TYPE (sad_oprnd0), type_out))\n+    return NULL;\n \n   tree var = vect_recog_temp_ssa_var (sum_type, NULL);\n   gimple *pattern_stmt = gimple_build_assign (var, SAD_EXPR, sad_oprnd0,\n@@ -778,8 +757,6 @@ vect_handle_widen_op_by_const (gimple *stmt, enum tree_code code,\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n@@ -790,8 +767,7 @@ vect_handle_widen_op_by_const (gimple *stmt, enum tree_code code,\n */\n \n static gimple *\n-vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n-                               tree *type_in, tree *type_out)\n+vect_recog_widen_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   gimple *def_stmt0, *def_stmt1;\n@@ -933,8 +909,9 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n \t\t\t\t\t  &dummy_int, &dummy_vec))\n     return NULL;\n \n-  *type_in = vectype;\n   *type_out = get_vectype_for_scalar_type (type);\n+  if (!*type_out)\n+    return NULL;\n \n   /* Pattern supported. Create a stmt to be used to replace the pattern: */\n   var = vect_recog_temp_ssa_var (itype, NULL);\n@@ -989,8 +966,6 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n@@ -1001,8 +976,7 @@ vect_recog_widen_mult_pattern (vec<gimple *> *stmts,\n */\n \n static gimple *\n-vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\ttree *type_out)\n+vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = (*stmts)[0];\n   tree base, exp;\n@@ -1072,12 +1046,13 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t  if (node->simd_clones == NULL)\n \t\t    return NULL;\n \t\t}\n+\t      *type_out = get_vectype_for_scalar_type (TREE_TYPE (base));\n+\t      if (!*type_out)\n+\t\treturn NULL;\n \t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n \t      tree def = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n \t      gimple *g = gimple_build_assign (def, MULT_EXPR, exp, logc);\n \t      new_pattern_def_seq (stmt_vinfo, g);\n-\t      *type_in = TREE_TYPE (base);\n-\t      *type_out = NULL_TREE;\n \t      tree res = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n \t      g = gimple_build_call (exp_decl, 1, def);\n \t      gimple_call_set_lhs (g, res);\n@@ -1091,15 +1066,15 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n   /* We now have a pow or powi builtin function call with a constant\n      exponent.  */\n \n-  *type_out = NULL_TREE;\n-\n   /* Catch squaring.  */\n   if ((tree_fits_shwi_p (exp)\n        && tree_to_shwi (exp) == 2)\n       || (TREE_CODE (exp) == REAL_CST\n           && real_equal (&TREE_REAL_CST (exp), &dconst2)))\n     {\n-      *type_in = TREE_TYPE (base);\n+      if (!vect_supportable_direct_optab_p (TREE_TYPE (base), MULT_EXPR,\n+\t\t\t\t\t    TREE_TYPE (base), type_out))\n+\treturn NULL;\n \n       var = vect_recog_temp_ssa_var (TREE_TYPE (base), NULL);\n       stmt = gimple_build_assign (var, MULT_EXPR, base, base);\n@@ -1110,9 +1085,9 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (TREE_CODE (exp) == REAL_CST\n       && real_equal (&TREE_REAL_CST (exp), &dconsthalf))\n     {\n-      *type_in = get_vectype_for_scalar_type (TREE_TYPE (base));\n-      if (*type_in\n-\t  && direct_internal_fn_supported_p (IFN_SQRT, *type_in,\n+      *type_out = get_vectype_for_scalar_type (TREE_TYPE (base));\n+      if (*type_out\n+\t  && direct_internal_fn_supported_p (IFN_SQRT, *type_out,\n \t\t\t\t\t     OPTIMIZE_FOR_SPEED))\n \t{\n \t  gcall *stmt = gimple_build_call_internal (IFN_SQRT, 1, base);\n@@ -1150,8 +1125,6 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the sequence of\n@@ -1167,8 +1140,7 @@ vect_recog_pow_pattern (vec<gimple *> *stmts, tree *type_in,\n \t inner-loop nested in an outer-loop that us being vectorized).  */\n \n static gimple *\n-vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t      tree *type_out)\n+vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *stmt, *last_stmt = (*stmts)[0];\n   tree oprnd0, oprnd1;\n@@ -1223,14 +1195,15 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_in,\n   if (!type_conversion_p (oprnd0, last_stmt, true, &half_type, &stmt,\n                           &promotion)\n       || !promotion)\n-     return NULL;\n+    return NULL;\n \n   oprnd0 = gimple_assign_rhs1 (stmt);\n \n   vect_pattern_detected (\"vect_recog_widen_sum_pattern\", last_stmt);\n \n-  *type_in = half_type;\n-  *type_out = type;\n+  if (!vect_supportable_direct_optab_p (type, WIDEN_SUM_EXPR, half_type,\n+\t\t\t\t\ttype_out))\n+    return NULL;\n \n   var = vect_recog_temp_ssa_var (type, NULL);\n   pattern_stmt = gimple_build_assign (var, WIDEN_SUM_EXPR, oprnd0, oprnd1);\n@@ -1473,8 +1446,7 @@ vect_operation_fits_smaller_type (gimple *stmt, tree def, tree *new_type,\n    demotion operation.  We also check that S3 and S4 have only one use.  */\n \n static gimple *\n-vect_recog_over_widening_pattern (vec<gimple *> *stmts,\n-                                  tree *type_in, tree *type_out)\n+vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *stmt = stmts->pop ();\n   gimple *pattern_stmt = NULL, *new_def_stmt, *prev_stmt = NULL,\n@@ -1562,14 +1534,15 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts,\n       if (TYPE_UNSIGNED (new_type) != TYPE_UNSIGNED (use_type)\n           || TYPE_PRECISION (new_type) != TYPE_PRECISION (use_type))\n         {\n+\t  *type_out = get_vectype_for_scalar_type (use_type);\n+\t  if (!*type_out)\n+\t    return NULL;\n+\n           /* Create NEW_TYPE->USE_TYPE conversion.  */\n \t  new_oprnd = make_ssa_name (use_type);\n \t  pattern_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, var);\n           STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;\n \n-          *type_in = get_vectype_for_scalar_type (new_type);\n-          *type_out = get_vectype_for_scalar_type (use_type);\n-\n           /* We created a pattern statement for the last statement in the\n              sequence, so we don't need to associate it with the pattern\n              statement created for PREV_STMT.  Therefore, we add PREV_STMT\n@@ -1583,8 +1556,7 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts,\n \t    STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (use_stmt))\n \t       = STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (prev_stmt));\n \n-          *type_in = vectype;\n-          *type_out = NULL_TREE;\n+\t  *type_out = vectype;\n         }\n \n       stmts->safe_push (use_stmt);\n@@ -1648,17 +1620,14 @@ vect_recog_over_widening_pattern (vec<gimple *> *stmts,\n \n   Output:\n \n-  * TYPE_IN: The type of the input arguments to the pattern.\n-\n   * TYPE_OUT: The type of the output of this pattern.\n \n   * Return value: A new stmt that will be used to replace the sequence of\n     stmts that constitute the pattern.  In this case it will be:\n     WIDEN_LSHIFT_EXPR <a_t, CONST>.  */\n \n static gimple *\n-vect_recog_widen_shift_pattern (vec<gimple *> *stmts,\n-\t\t\t\ttree *type_in, tree *type_out)\n+vect_recog_widen_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   gimple *def_stmt0;\n@@ -1740,7 +1709,6 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts,\n \t\t\t\t\t  &dummy_int, &dummy_vec))\n     return NULL;\n \n-  *type_in = vectype;\n   *type_out = vectype_out;\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n@@ -1783,15 +1751,13 @@ vect_recog_widen_shift_pattern (vec<gimple *> *stmts,\n \n   Output:\n \n-  * TYPE_IN: The type of the input arguments to the pattern.\n-\n   * TYPE_OUT: The type of the output of this pattern.\n \n   * Return value: A new stmt that will be used to replace the rotate\n     S0 stmt.  */\n \n static gimple *\n-vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n+vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   tree oprnd0, oprnd1, lhs, var, var1, var2, vectype, type, stype, def, def2;\n@@ -1876,10 +1842,7 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \treturn NULL;\n     }\n \n-  *type_in = vectype;\n   *type_out = vectype;\n-  if (*type_in == NULL_TREE)\n-    return NULL;\n \n   if (dt == vect_external_def\n       && TREE_CODE (oprnd1) == SSA_NAME\n@@ -2034,16 +1997,13 @@ vect_recog_rotate_pattern (vec<gimple *> *stmts, tree *type_in, tree *type_out)\n \n   Output:\n \n-  * TYPE_IN: The type of the input arguments to the pattern.\n-\n   * TYPE_OUT: The type of the output of this pattern.\n \n   * Return value: A new stmt that will be used to replace the shift/rotate\n     S3 stmt.  */\n \n static gimple *\n-vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n-\t\t\t\t\ttree *type_in, tree *type_out)\n+vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   tree oprnd0, oprnd1, lhs, var;\n@@ -2085,9 +2045,8 @@ vect_recog_vector_vector_shift_pattern (vec<gimple *> *stmts,\n   if (!def_vinfo)\n     return NULL;\n \n-  *type_in = get_vectype_for_scalar_type (TREE_TYPE (oprnd0));\n-  *type_out = *type_in;\n-  if (*type_in == NULL_TREE)\n+  *type_out = get_vectype_for_scalar_type (TREE_TYPE (oprnd0));\n+  if (*type_out == NULL_TREE)\n     return NULL;\n \n   tree def = NULL_TREE;\n@@ -2449,16 +2408,13 @@ vect_synth_mult_by_constant (tree op, tree val,\n \n  Output:\n \n-  * TYPE_IN: The type of the input arguments to the pattern.\n-\n   * TYPE_OUT: The type of the output of this pattern.\n \n   * Return value: A new stmt that will be used to replace\n     the multiplication.  */\n \n static gimple *\n-vect_recog_mult_pattern (vec<gimple *> *stmts,\n-\t\t\t tree *type_in, tree *type_out)\n+vect_recog_mult_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   tree oprnd0, oprnd1, vectype, itype;\n@@ -2504,7 +2460,6 @@ vect_recog_mult_pattern (vec<gimple *> *stmts,\n   vect_pattern_detected (\"vect_recog_mult_pattern\", last_stmt);\n \n   stmts->safe_push (last_stmt);\n-  *type_in = vectype;\n   *type_out = vectype;\n \n   return pattern_stmt;\n@@ -2543,16 +2498,13 @@ vect_recog_mult_pattern (vec<gimple *> *stmts,\n \n   Output:\n \n-  * TYPE_IN: The type of the input arguments to the pattern.\n-\n   * TYPE_OUT: The type of the output of this pattern.\n \n   * Return value: A new stmt that will be used to replace the division\n     S1 or modulo S4 stmt.  */\n \n static gimple *\n-vect_recog_divmod_pattern (vec<gimple *> *stmts,\n-\t\t\t   tree *type_in, tree *type_out)\n+vect_recog_divmod_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   tree oprnd0, oprnd1, vectype, itype, cond;\n@@ -2703,7 +2655,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \n       stmts->safe_push (last_stmt);\n \n-      *type_in = vectype;\n       *type_out = vectype;\n       return pattern_stmt;\n     }\n@@ -2955,7 +2906,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \n   stmts->safe_push (last_stmt);\n \n-  *type_in = vectype;\n   *type_out = vectype;\n   return pattern_stmt;\n }\n@@ -2980,8 +2930,6 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the pattern.\n@@ -2991,8 +2939,7 @@ vect_recog_divmod_pattern (vec<gimple *> *stmts,\n \ta_T = (TYPE) a_it;  */\n \n static gimple *\n-vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t\t    tree *type_out)\n+vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = (*stmts)[0];\n   tree cond_expr, then_clause, else_clause;\n@@ -3108,7 +3055,6 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n   def_stmt_info = new_stmt_vec_info (def_stmt, vinfo);\n   set_vinfo_for_stmt (def_stmt, def_stmt_info);\n   STMT_VINFO_VECTYPE (def_stmt_info) = vecitype;\n-  *type_in = vecitype;\n   *type_out = vectype;\n \n   vect_pattern_detected (\"vect_recog_mixed_size_cond_pattern\", last_stmt);\n@@ -3581,8 +3527,6 @@ search_type_for_mask (tree var, vec_info *vinfo)\n \n    Output:\n \n-   * TYPE_IN: The type of the input arguments to the pattern.\n-\n    * TYPE_OUT: The type of the output of this pattern.\n \n    * Return value: A new stmt that will be used to replace the pattern.\n@@ -3602,8 +3546,7 @@ search_type_for_mask (tree var, vec_info *vinfo)\n \tbut the above is more efficient.  */\n \n static gimple *\n-vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t tree *type_out)\n+vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   enum tree_code rhs_code;\n@@ -3679,7 +3622,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t}\n \n       *type_out = vectype;\n-      *type_in = vectype;\n       stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n@@ -3718,7 +3660,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t\t\t gimple_assign_rhs2 (last_stmt),\n \t\t\t\t gimple_assign_rhs3 (last_stmt));\n       *type_out = vectype;\n-      *type_in = vectype;\n       stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n@@ -3775,7 +3716,6 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       STMT_VINFO_DR_WRT_VEC_LOOP (pattern_stmt_info)\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n       *type_out = vectype;\n-      *type_in = vectype;\n       stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_bool_pattern\", last_stmt);\n \n@@ -3839,8 +3779,7 @@ build_mask_conversion (tree mask, tree vectype, stmt_vec_info stmt_vinfo,\n    S4'  c_1' = m_3'' ? c_2 : c_3;  */\n \n static gimple *\n-vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t\t    tree *type_out)\n+vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   enum tree_code rhs_code;\n@@ -3911,7 +3850,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t= STMT_VINFO_DR_WRT_VEC_LOOP (stmt_vinfo);\n \n       *type_out = vectype1;\n-      *type_in = vectype1;\n       stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n@@ -4035,7 +3973,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n \t\t\t\t\t  gimple_assign_rhs3 (last_stmt));\n \n       *type_out = vectype1;\n-      *type_in = vectype1;\n       stmts->safe_push (last_stmt);\n       vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n@@ -4081,7 +4018,6 @@ vect_recog_mask_conversion_pattern (vec<gimple *> *stmts, tree *type_in,\n   pattern_stmt = gimple_build_assign (lhs, rhs_code, rhs1, rhs2);\n \n   *type_out = vectype1;\n-  *type_in = vectype1;\n   stmts->safe_push (last_stmt);\n   vect_pattern_detected (\"vect_recog_mask_conversion_pattern\", last_stmt);\n \n@@ -4180,14 +4116,14 @@ vect_add_conversion_to_patterm (tree type, tree value,\n \n /* Try to convert STMT into a call to a gather load or scatter store\n    internal function.  Return the final statement on success and set\n-   *TYPE_IN and *TYPE_OUT to the vector type being loaded or stored.\n+   *TYPE_OUT to the vector type being loaded or stored.\n \n    This function only handles gathers and scatters that were recognized\n    as such from the outset (indicated by STMT_VINFO_GATHER_SCATTER_P).  */\n \n static gimple *\n vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n-\t\t\t\t tree *type_in, tree *type_out)\n+\t\t\t\t tree *type_out)\n {\n   /* Currently we only support this for loop vectorization.  */\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n@@ -4264,7 +4200,6 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n \n   tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n   *type_out = vectype;\n-  *type_in = vectype;\n   vect_pattern_detected (\"gather/scatter pattern\", stmt);\n \n   return pattern_stmt;\n@@ -4273,19 +4208,52 @@ vect_try_gather_scatter_pattern (gimple *stmt, stmt_vec_info last_stmt_info,\n /* Pattern wrapper around vect_try_gather_scatter_pattern.  */\n \n static gimple *\n-vect_recog_gather_scatter_pattern (vec<gimple *> *stmts, tree *type_in,\n-\t\t\t\t   tree *type_out)\n+vect_recog_gather_scatter_pattern (vec<gimple *> *stmts, tree *type_out)\n {\n   gimple *last_stmt = stmts->pop ();\n   stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n   gimple *pattern_stmt = vect_try_gather_scatter_pattern (last_stmt,\n \t\t\t\t\t\t\t  last_stmt_info,\n-\t\t\t\t\t\t\t  type_in, type_out);\n+\t\t\t\t\t\t\t  type_out);\n   if (pattern_stmt)\n     stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n+typedef gimple *(*vect_recog_func_ptr) (vec<gimple *> *, tree *);\n+\n+struct vect_recog_func\n+{\n+  vect_recog_func_ptr fn;\n+  const char *name;\n+};\n+\n+/* Note that ordering matters - the first pattern matching on a stmt is\n+   taken which means usually the more complex one needs to preceed the\n+   less comples onex (widen_sum only after dot_prod or sad for example).  */\n+static vect_recog_func vect_vect_recog_func_ptrs[] = {\n+  { vect_recog_widen_mult_pattern, \"widen_mult\" },\n+  { vect_recog_dot_prod_pattern, \"dot_prod\" },\n+  { vect_recog_sad_pattern, \"sad\" },\n+  { vect_recog_widen_sum_pattern, \"widen_sum\" },\n+  { vect_recog_pow_pattern, \"pow\" },\n+  { vect_recog_widen_shift_pattern, \"widen_shift\" },\n+  { vect_recog_over_widening_pattern, \"over_widening\" },\n+  { vect_recog_rotate_pattern, \"rotate\" },\n+  { vect_recog_vector_vector_shift_pattern, \"vector_vector_shift\" },\n+  { vect_recog_divmod_pattern, \"divmod\" },\n+  { vect_recog_mult_pattern, \"mult\" },\n+  { vect_recog_mixed_size_cond_pattern, \"mixed_size_cond\" },\n+  { vect_recog_bool_pattern, \"bool\" },\n+  /* This must come before mask conversion, and includes the parts\n+     of mask conversion that are needed for gather and scatter\n+     internal functions.  */\n+  { vect_recog_gather_scatter_pattern, \"gather_scatter\" },\n+  { vect_recog_mask_conversion_pattern, \"mask_conversion\" }\n+};\n+\n+const unsigned int NUM_PATTERNS = ARRAY_SIZE (vect_vect_recog_func_ptrs);\n+\n /* Mark statements that are involved in a pattern.  */\n \n static inline void\n@@ -4337,17 +4305,13 @@ vect_mark_pattern_stmts (gimple *orig_stmt, gimple *pattern_stmt,\n         computation pattern.\n    STMT: A stmt from which the pattern search should start.\n \n-   If PATTERN_RECOG_FUNC successfully detected the pattern, it creates an\n-   expression that computes the same functionality and can be used to\n-   replace the sequence of stmts that are involved in the pattern.\n-\n-   Output:\n-   This function checks if the expression returned by PATTERN_RECOG_FUNC is\n-   supported in vector form by the target.  We use 'TYPE_IN' to obtain the\n-   relevant vector type. If 'TYPE_IN' is already a vector type, then this\n-   indicates that target support had already been checked by PATTERN_RECOG_FUNC.\n-   If 'TYPE_OUT' is also returned by PATTERN_RECOG_FUNC, we check that it fits\n-   to the available target pattern.\n+   If PATTERN_RECOG_FUNC successfully detected the pattern, it creates\n+   a sequence of statements that has the same functionality and can be\n+   used to replace STMT.  It returns the last statement in the sequence\n+   and adds any earlier statements to STMT's STMT_VINFO_PATTERN_DEF_SEQ.\n+   PATTERN_RECOG_FUNC also sets *TYPE_OUT to the vector type of the final\n+   statement, having first checked that the target supports the new operation\n+   in that type.\n \n    This function also does some bookkeeping, as explained in the documentation\n    for vect_recog_pattern.  */\n@@ -4361,13 +4325,11 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n   stmt_vec_info stmt_info;\n   loop_vec_info loop_vinfo;\n   tree pattern_vectype;\n-  tree type_in, type_out;\n-  enum tree_code code;\n   int i;\n \n   stmts_to_replace->truncate (0);\n   stmts_to_replace->quick_push (stmt);\n-  pattern_stmt = recog_func->fn (stmts_to_replace, &type_in, &type_out);\n+  pattern_stmt = recog_func->fn (stmts_to_replace, &pattern_vectype);\n   if (!pattern_stmt)\n     {\n       /* Clear related stmt info that analysis might have noted for\n@@ -4385,43 +4347,8 @@ vect_pattern_recog_1 (vect_recog_func *recog_func,\n   stmt = stmts_to_replace->last ();\n   stmt_info = vinfo_for_stmt (stmt);\n   loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  gcc_assert (pattern_vectype);\n  \n-  if (VECTOR_BOOLEAN_TYPE_P (type_in)\n-      || VECTOR_TYPE_P (type_in))\n-    {\n-      /* No need to check target support (already checked by the pattern\n-         recognition function).  */\n-      pattern_vectype = type_out ? type_out : type_in;\n-    }\n-  else\n-    {\n-      /* Check target support  */\n-      type_in = get_vectype_for_scalar_type (type_in);\n-      if (!type_in)\n-\treturn false;\n-      if (type_out)\n-\ttype_out = get_vectype_for_scalar_type (type_out);\n-      else\n-\ttype_out = type_in;\n-      if (!type_out)\n-\treturn false;\n-      pattern_vectype = type_out;\n-\n-      if (is_gimple_assign (pattern_stmt))\n-\t{\n-\t  enum insn_code icode;\n-\t  code = gimple_assign_rhs_code (pattern_stmt);\n-\t  optab optab = optab_for_tree_code (code, type_in, optab_default);\n-\t  machine_mode vec_mode = TYPE_MODE (type_in);\n-\t  if (!optab\n-\t      || (icode = optab_handler (optab, vec_mode)) == CODE_FOR_nothing\n-\t      || (insn_data[icode].operand[0].mode != TYPE_MODE (type_out)))\n-\t    return false;\n-\t}\n-      else\n-\tgcc_assert (is_gimple_call (pattern_stmt));\n-    }\n-\n   /* Found a vectorizable pattern.  */\n   if (dump_enabled_p ())\n     {"}, {"sha": "0d4657b1b4209064e728e9551b58f5e0e62d82fa", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1cbfeccc8d5ddade3a1727e18fe31c1e83e81701/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1cbfeccc8d5ddade3a1727e18fe31c1e83e81701", "patch": "@@ -1628,8 +1628,6 @@ extern int vect_get_place_in_interleaving_chain (gimple *, gimple *);\n /* Pattern recognition functions.\n    Additional pattern recognition functions can (and will) be added\n    in the future.  */\n-typedef gimple *(* vect_recog_func_ptr) (vec<gimple *> *, tree *, tree *);\n-#define NUM_PATTERNS 15\n void vect_pattern_recog (vec_info *);\n \n /* In tree-vectorizer.c.  */"}]}