{"sha": "6ad7c37da561071652f37cf4cfa8edb6347dd43f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFkN2MzN2RhNTYxMDcxNjUyZjM3Y2Y0Y2ZhOGVkYjYzNDdkZDQzZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:27Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-04-07T08:01:27Z"}, "message": "Initial revision\n\nFrom-SVN: r26244", "tree": {"sha": "112d6a93a837bbb9f9c751f37aaa625d462d3980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/112d6a93a837bbb9f9c751f37aaa625d462d3980"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ad7c37da561071652f37cf4cfa8edb6347dd43f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad7c37da561071652f37cf4cfa8edb6347dd43f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ad7c37da561071652f37cf4cfa8edb6347dd43f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ad7c37da561071652f37cf4cfa8edb6347dd43f/comments", "author": null, "committer": null, "parents": [{"sha": "62218b2827346ee5fe7bd4433fe9dec85e5475a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62218b2827346ee5fe7bd4433fe9dec85e5475a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62218b2827346ee5fe7bd4433fe9dec85e5475a4"}], "stats": {"total": 400, "additions": 400, "deletions": 0}, "files": [{"sha": "056df2f66f7c9f32b609840963704cc07a114420", "filename": "boehm-gc/Makefile", "status": "added", "additions": 400, "deletions": 0, "changes": 400, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ad7c37da561071652f37cf4cfa8edb6347dd43f/boehm-gc%2FMakefile", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ad7c37da561071652f37cf4cfa8edb6347dd43f/boehm-gc%2FMakefile", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/boehm-gc%2FMakefile?ref=6ad7c37da561071652f37cf4cfa8edb6347dd43f", "patch": "@@ -0,0 +1,400 @@\n+# Primary targets:\n+# gc.a - builds basic library\n+# libgc.a - builds library for use with g++ \"-fgc-keyword\" extension\n+# c++ - adds C++ interface to library\n+# cords - adds cords (heavyweight strings) to library\n+# test - prints porting information, then builds basic version of gc.a,\n+#      \t and runs some tests of collector and cords.  Does not add cords or\n+#\t c++ interface to gc.a\n+# cord/de - builds dumb editor based on cords.\n+ABI_FLAG=\n+CC=cc $(ABI_FLAG)\n+CXX=CC $(ABI_FLAG)\n+AS=as $(ABI_FLAG)\n+#  The above doesn't work with gas, which doesn't run cpp.\n+#  Define AS as `gcc -c -x assembler-with-cpp' instead.\n+#  Under Irix 6, you will have to specify the ABI for as if you specify\n+#  it for the C compiler.\n+\n+CFLAGS= -O -DATOMIC_UNCOLLECTABLE -DNO_SIGNALS -DALL_INTERIOR_POINTERS -DNO_EXECUTE_PERMISSION -DSILENT\n+\n+# Setjmp_test may yield overly optimistic results when compiled\n+# without optimization.\n+# -DSILENT disables statistics printing, and improves performance.\n+# -DCHECKSUMS reports on erroneously clear dirty bits, and unexpectedly\n+#   altered stubborn objects, at substantial performance cost.\n+#   Use only for incremental collector debugging.\n+# -DFIND_LEAK causes the collector to assume that all inaccessible\n+#   objects should have been explicitly deallocated, and reports exceptions.\n+#   Finalization and the test program are not usable in this mode.\n+# -DSOLARIS_THREADS enables support for Solaris (thr_) threads.\n+#   (Clients should also define SOLARIS_THREADS and then include\n+#   gc.h before performing thr_ or dl* or GC_ operations.)\n+#   Must also define -D_REENTRANT\n+# -D_SOLARIS_PTHREADS enables support for Solaris pthreads.\n+#   Define SOLARIS_THREADS as well.\n+# -DIRIX_THREADS enables support for Irix pthreads.  See README.irix.\n+# -DALL_INTERIOR_POINTERS allows all pointers to the interior\n+#   of objects to be recognized.  (See gc_priv.h for consequences.)\n+# -DSMALL_CONFIG tries to tune the collector for small heap sizes,\n+#   usually causing it to use less space in such situations.\n+#   Incremental collection no longer works in this case.\n+# -DLARGE_CONFIG tunes the collector for unusually large heaps.\n+#   Necessary for heaps larger than about 500 MB on most machines.\n+#   Recommended for heaps larger than about 64 MB.\n+# -DDONT_ADD_BYTE_AT_END is meaningful only with\n+#   -DALL_INTERIOR_POINTERS.  Normally -DALL_INTERIOR_POINTERS\n+#   causes all objects to be padded so that pointers just past the end of\n+#   an object can be recognized.  This can be expensive.  (The padding\n+#   is normally more than one byte due to alignment constraints.)\n+#   -DDONT_ADD_BYTE_AT_END disables the padding.\n+# -DNO_SIGNALS does not disable signals during critical parts of\n+#   the GC process.  This is no less correct than many malloc \n+#   implementations, and it sometimes has a significant performance\n+#   impact.  However, it is dangerous for many not-quite-ANSI C\n+#   programs that call things like printf in asynchronous signal handlers.\n+# -DNO_EXECUTE_PERMISSION may cause some or all of the heap to not\n+#   have execute permission, i.e. it may be impossible to execute\n+#   code from the heap.  Currently this only affects the incremental\n+#   collector on UNIX machines.  It may greatly improve its performance,\n+#   since this may avoid some expensive cache synchronization.\n+# -DOPERATOR_NEW_ARRAY declares that the C++ compiler supports the\n+#   new syntax \"operator new[]\" for allocating and deleting arrays.\n+#   See gc_cpp.h for details.  No effect on the C part of the collector.\n+#   This is defined implicitly in a few environments.\n+# -DREDIRECT_MALLOC=X causes malloc, realloc, and free to be defined\n+#   as aliases for X, GC_realloc, and GC_free, respectively.\n+#   Calloc is redefined in terms of the new malloc.  X should\n+#   be either GC_malloc or GC_malloc_uncollectable.\n+#   The former is occasionally useful for working around leaks in code\n+#   you don't want to (or can't) look at.  It may not work for\n+#   existing code, but it often does.  Neither works on all platforms,\n+#   since some ports use malloc or calloc to obtain system memory.\n+#   (Probably works for UNIX, and win32.)\n+# -DIGNORE_FREE turns calls to free into a noop.  Only useful with\n+#   -DREDIRECT_MALLOC.\n+# -DNO_DEBUGGING removes GC_dump and the debugging routines it calls.\n+#   Reduces code size slightly at the expense of debuggability.\n+# -DJAVA_FINALIZATION makes it somewhat safer to finalize objects out of\n+#   order by specifying a nonstandard finalization mark procedure  (see\n+#   finalize.c).  Objects reachable from finalizable objects will be marked\n+#   in a sepearte postpass, and hence their memory won't be reclaimed.\n+#   Not recommended unless you are implementing a language that specifies\n+#   these semantics.\n+# -DFINALIZE_ON_DEMAND causes finalizers to be run only in response\n+#   to explicit GC_invoke_finalizers() calls.\n+# -DATOMIC_UNCOLLECTABLE includes code for GC_malloc_atomic_uncollectable.\n+#   This is useful if either the vendor malloc implementation is poor,\n+#   or if REDIRECT_MALLOC is used.\n+# -DHBLKSIZE=ddd, where ddd is a power of 2 between 512 and 16384, explicitly\n+#   sets the heap block size.  Each heap block is devoted to a single size and\n+#   kind of object.  For the incremental collector it makes sense to match\n+#   the most likely page size.  Otherwise large values result in more\n+#   fragmentation, but generally better performance for large heaps.\n+# -DUSE_MMAP use MMAP instead of sbrk to get new memory.\n+#   Works for Solaris and Irix.\n+# -DMMAP_STACKS (for Solaris threads) Use mmap from /dev/zero rather than\n+#   GC_scratch_alloc() to get stack memory.\n+# -DPRINT_BLACK_LIST Whenever a black list entry is added, i.e. whenever\n+#   the garbage collector detects a value that looks almost, but not quite,\n+#   like a pointer, print both the address containing the value, and the\n+#   value of the near-bogus-pointer.  Can be used to identifiy regions of\n+#   memory that are likely to contribute misidentified pointers.\n+# -DOLD_BLOCK_ALLOC Use the old, possibly faster, large block\n+#   allocation strategy.  The new strategy tries harder to minimize\n+#   fragmentation, sometimes at the expense of spending more time in the\n+#   large block allocator and/or collecting more frequently.\n+#\n+\n+\n+\n+LIBGC_CFLAGS= -O -DNO_SIGNALS -DSILENT \\\n+    -DREDIRECT_MALLOC=GC_malloc_uncollectable \\\n+    -DDONT_ADD_BYTE_AT_END -DALL_INTERIOR_POINTERS\n+#   Flags for building libgc.a -- the last two are required.\n+\n+CXXFLAGS= $(CFLAGS) \n+AR= ar\n+RANLIB= ranlib\n+\n+\n+# Redefining srcdir allows object code for the nonPCR version of the collector\n+# to be generated in different directories.  In this case, the destination directory\n+# should contain a copy of the original include directory.\n+srcdir = .\n+VPATH = $(srcdir)\n+\n+OBJS= alloc.o reclaim.o allchblk.o misc.o mach_dep.o os_dep.o mark_rts.o headers.o mark.o obj_map.o blacklst.o finalize.o new_hblk.o dbg_mlc.o malloc.o stubborn.o checksums.o solaris_threads.o irix_threads.o linux_threads.o typd_mlc.o ptr_chck.o mallocx.o solaris_pthreads.o\n+\n+CSRCS= reclaim.c allchblk.c misc.c alloc.c mach_dep.c os_dep.c mark_rts.c headers.c mark.c obj_map.c pcr_interface.c blacklst.c finalize.c new_hblk.c real_malloc.c dyn_load.c dbg_mlc.c malloc.c stubborn.c checksums.c solaris_threads.c irix_threads.c linux_threads.c typd_mlc.c ptr_chck.c mallocx.c solaris_pthreads.c\n+\n+CORD_SRCS=  cord/cordbscs.c cord/cordxtra.c cord/cordprnt.c cord/de.c cord/cordtest.c cord/cord.h cord/ec.h cord/private/cord_pos.h cord/de_win.c cord/de_win.h cord/de_cmds.h cord/de_win.ICO cord/de_win.RC cord/SCOPTIONS.amiga cord/SMakefile.amiga\n+\n+CORD_OBJS=  cord/cordbscs.o cord/cordxtra.o cord/cordprnt.o\n+\n+SRCS= $(CSRCS) mips_sgi_mach_dep.s rs6000_mach_dep.s alpha_mach_dep.s \\\n+    sparc_mach_dep.s gc.h gc_typed.h gc_hdrs.h gc_priv.h gc_private.h \\\n+    config.h gc_mark.h include/gc_inl.h include/gc_inline.h gc.man \\\n+    threadlibs.c if_mach.c if_not_there.c gc_cpp.cc gc_cpp.h weakpointer.h \\\n+    gcc_support.c mips_ultrix_mach_dep.s include/gc_alloc.h gc_alloc.h \\\n+    sparc_sunos4_mach_dep.s solaris_threads.h $(CORD_SRCS)\n+\n+OTHER_FILES= Makefile PCR-Makefile OS2_MAKEFILE NT_MAKEFILE BCC_MAKEFILE \\\n+           README test.c test_cpp.cc setjmp_t.c SMakefile.amiga \\\n+           SCoptions.amiga README.amiga README.win32 cord/README \\\n+           cord/gc.h include/gc.h include/gc_typed.h include/cord.h \\\n+           include/ec.h include/private/cord_pos.h include/private/config.h \\\n+           include/private/gc_hdrs.h include/private/gc_priv.h \\\n+\t   include/gc_cpp.h README.rs6000 \\\n+           include/weakpointer.h README.QUICK callprocs pc_excludes \\\n+           barrett_diagram README.OS2 README.Mac MacProjects.sit.hqx \\\n+           MacOS.c EMX_MAKEFILE makefile.depend README.debugging \\\n+           include/gc_cpp.h Mac_files/datastart.c Mac_files/dataend.c \\\n+           Mac_files/MacOS_config.h Mac_files/MacOS_Test_config.h \\\n+           add_gc_prefix.c README.solaris2 README.sgi README.hp README.uts \\\n+\t   win32_threads.c NT_THREADS_MAKEFILE gc.mak README.dj Makefile.dj \\\n+\t   README.alpha README.linux version.h Makefile.DLLs gc_watcom.asm \\\n+\t   WCC_MAKEFILE\n+\n+CORD_INCLUDE_FILES= $(srcdir)/gc.h $(srcdir)/cord/cord.h $(srcdir)/cord/ec.h \\\n+           $(srcdir)/cord/private/cord_pos.h\n+\n+UTILS= if_mach if_not_there threadlibs\n+\n+# Libraries needed for curses applications.  Only needed for de.\n+CURSES= -lcurses -ltermlib\n+\n+# The following is irrelevant on most systems.  But a few\n+# versions of make otherwise fork the shell specified in\n+# the SHELL environment variable.\n+SHELL= /bin/sh\n+\n+SPECIALCFLAGS = \n+# Alternative flags to the C compiler for mach_dep.c.\n+# Mach_dep.c often doesn't like optimization, and it's\n+# not time-critical anyway.\n+# Set SPECIALCFLAGS to -q nodirect_code on Encore.\n+\n+all: gc.a gctest\n+\n+pcr: PCR-Makefile gc_private.h gc_hdrs.h gc.h config.h mach_dep.o $(SRCS)\n+\tmake -f PCR-Makefile depend\n+\tmake -f PCR-Makefile\n+\n+$(OBJS) test.o dyn_load.o dyn_load_sunos53.o: $(srcdir)/gc_priv.h $(srcdir)/gc_hdrs.h $(srcdir)/gc.h \\\n+    $(srcdir)/config.h $(srcdir)/gc_typed.h Makefile\n+# The dependency on Makefile is needed.  Changing\n+# options such as -DSILENT affects the size of GC_arrays,\n+# invalidating all .o files that rely on gc_priv.h\n+\n+mark.o typd_mlc.o finalize.o: $(srcdir)/gc_mark.h\n+\n+base_lib gc.a: $(OBJS) dyn_load.o $(UTILS)\n+\techo > base_lib\n+\trm -f on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(OBJS) dyn_load.o\n+\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(OBJS) dyn_load.o\n+\t./if_not_there on_sparc_sunos5 $(RANLIB) gc.a || cat /dev/null\n+#\tignore ranlib failure; that usually means it doesn't exist, and isn't needed\n+\n+libgc.a: \n+\tmake CFLAGS=\"$(LIBGC_CFLAGS)\" clean gc.a gcc_support.o\n+\tmv gc.a libgc.a\n+\trm -f on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus libgc.a gcc_support.o\n+\t./if_not_there on_sparc_sunos5 $(AR) ru libgc.a gcc_support.o\n+\t./if_not_there on_sparc_sunos5 $(RANLIB) libgc.a || cat /dev/null\n+\n+cords: $(CORD_OBJS) cord/cordtest $(UTILS)\n+\trm -f on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a $(CORD_OBJS)\n+\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a $(CORD_OBJS)\n+\t./if_not_there on_sparc_sunos5 $(RANLIB) gc.a || cat /dev/null\n+\n+gc_cpp.o: $(srcdir)/gc_cpp.cc $(srcdir)/gc_cpp.h $(srcdir)/gc.h Makefile\n+\t$(CXX) -c $(CXXFLAGS) $(srcdir)/gc_cpp.cc\n+\n+test_cpp: $(srcdir)/test_cpp.cc $(srcdir)/gc_cpp.h gc_cpp.o $(srcdir)/gc.h \\\n+base_lib $(UTILS)\n+\trm -f test_cpp\n+\t./if_mach HP_PA \"\" $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a -ldld\n+\t./if_not_there test_cpp $(CXX) $(CXXFLAGS) -o test_cpp $(srcdir)/test_cpp.cc gc_cpp.o gc.a `./threadlibs`\n+\n+c++: gc_cpp.o $(srcdir)/gc_cpp.h test_cpp\n+\trm -f on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 touch on_sparc_sunos5\n+\t./if_mach SPARC SUNOS5 $(AR) rus gc.a gc_cpp.o\n+\t./if_not_there on_sparc_sunos5 $(AR) ru gc.a gc_cpp.o\n+\t./if_not_there on_sparc_sunos5 $(RANLIB) gc.a || cat /dev/null\n+\t./test_cpp 1\n+\techo > c++\n+\n+dyn_load_sunos53.o: dyn_load.c\n+\t$(CC) $(CFLAGS) -DSUNOS53_SHARED_LIB -c $(srcdir)/dyn_load.c -o $@\n+\n+# SunOS5 shared library version of the collector\n+libgc.so: $(OBJS) dyn_load_sunos53.o\n+\t$(CC) -G -o libgc.so $(OBJS) dyn_load_sunos53.o -ldl\n+\n+# Alpha/OSF shared library version of the collector\n+libalphagc.so: $(OBJS)\n+\tld -shared -o libalphagc.so $(OBJS) dyn_load.o -lc\n+\tln libalphagc.so libgc.so\n+\n+# IRIX shared library version of the collector\n+libirixgc.so: $(OBJS) dyn_load.o\n+\tld -shared $(ABI_FLAG) -o libirixgc.so $(OBJS) dyn_load.o -lc\n+\tln libirixgc.so libgc.so\n+\n+mach_dep.o: $(srcdir)/mach_dep.c $(srcdir)/mips_sgi_mach_dep.s $(srcdir)/mips_ultrix_mach_dep.s $(srcdir)/rs6000_mach_dep.s $(UTILS)\n+\trm -f mach_dep.o\n+\t./if_mach MIPS IRIX5 $(AS) -o mach_dep.o $(srcdir)/mips_sgi_mach_dep.s\n+\t./if_mach MIPS RISCOS $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach MIPS ULTRIX $(AS) -o mach_dep.o $(srcdir)/mips_ultrix_mach_dep.s\n+\t./if_mach RS6000 \"\" $(AS) -o mach_dep.o $(srcdir)/rs6000_mach_dep.s\n+\t./if_mach ALPHA \"\" $(AS) -o mach_dep.o $(srcdir)/alpha_mach_dep.s\n+\t./if_mach SPARC SUNOS5 $(AS) -o mach_dep.o $(srcdir)/sparc_mach_dep.s\n+\t./if_mach SPARC SUNOS4 $(AS) -o mach_dep.o $(srcdir)/sparc_sunos4_mach_dep.s\n+\t./if_not_there mach_dep.o $(CC) -c $(SPECIALCFLAGS) $(srcdir)/mach_dep.c\n+\n+mark_rts.o: $(srcdir)/mark_rts.c if_mach if_not_there $(UTILS)\n+\trm -f mark_rts.o\n+\t-./if_mach ALPHA OSF1 $(CC) -c $(CFLAGS) -Wo,-notail $(srcdir)/mark_rts.c\n+\t./if_not_there mark_rts.o $(CC) -c $(CFLAGS) $(srcdir)/mark_rts.c\n+#\tWork-around for DEC optimizer tail recursion elimination bug.\n+#  The ALPHA-specific line should be removed if gcc is used.\n+\n+alloc.o: version.h\n+\n+cord/cordbscs.o: $(srcdir)/cord/cordbscs.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordbscs.c\n+\tmv cordbscs.o cord/cordbscs.o\n+#  not all compilers understand -o filename\n+\n+cord/cordxtra.o: $(srcdir)/cord/cordxtra.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordxtra.c\n+\tmv cordxtra.o cord/cordxtra.o\n+\n+cord/cordprnt.o: $(srcdir)/cord/cordprnt.c $(CORD_INCLUDE_FILES)\n+\t$(CC) $(CFLAGS) -c $(srcdir)/cord/cordprnt.c\n+\tmv cordprnt.o cord/cordprnt.o\n+\n+cord/cordtest: $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a $(UTILS)\n+\trm -f cord/cordtest\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a -ldld\n+\t./if_not_there cord/cordtest $(CC) $(CFLAGS) -o cord/cordtest $(srcdir)/cord/cordtest.c $(CORD_OBJS) gc.a `./threadlibs`\n+\n+cord/de: $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(UTILS)\n+\trm -f cord/de\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) -ldld\n+\t./if_mach RS6000 \"\" $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach I386 LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_mach ALPHA LINUX $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a -lcurses\n+\t./if_not_there cord/de $(CC) $(CFLAGS) -o cord/de $(srcdir)/cord/de.c cord/cordbscs.o cord/cordxtra.o gc.a $(CURSES) `./threadlibs`\n+\n+if_mach: $(srcdir)/if_mach.c $(srcdir)/config.h\n+\t$(CC) $(CFLAGS) -o if_mach $(srcdir)/if_mach.c\n+\n+threadlibs: $(srcdir)/threadlibs.c $(srcdir)/config.h Makefile\n+\t$(CC) $(CFLAGS) -o threadlibs $(srcdir)/threadlibs.c\n+\n+if_not_there: $(srcdir)/if_not_there.c\n+\t$(CC) $(CFLAGS) -o if_not_there $(srcdir)/if_not_there.c\n+\n+clean: \n+\trm -f gc.a *.o gctest gctest_dyn_link test_cpp \\\n+\t      setjmp_test  mon.out gmon.out a.out core if_not_there if_mach \\\n+\t      threadlibs $(CORD_OBJS) cord/cordtest cord/de\n+\t-rm -f *~\n+\n+gctest: test.o gc.a if_mach if_not_there\n+\trm -f gctest\n+\t./if_mach SPARC DRSNX $(CC) $(CFLAGS) -o gctest  test.o gc.a -lucb\n+\t./if_mach HP_PA \"\" $(CC) $(CFLAGS) -o gctest  test.o gc.a -ldld\n+\t./if_not_there gctest $(CC) $(CFLAGS) -o gctest test.o gc.a `./threadlibs`\n+\n+# If an optimized setjmp_test generates a segmentation fault,\n+# odds are your compiler is broken.  Gctest may still work.\n+# Try compiling setjmp_t.c unoptimized.\n+setjmp_test: $(srcdir)/setjmp_t.c $(srcdir)/gc.h if_mach if_not_there\n+\t$(CC) $(CFLAGS) -o setjmp_test $(srcdir)/setjmp_t.c\n+\n+test:  KandRtest cord/cordtest\n+\tcord/cordtest\n+\n+# Those tests that work even with a K&R C compiler:\n+KandRtest: setjmp_test gctest\n+\t./setjmp_test\n+\t./gctest\n+\n+add_gc_prefix: add_gc_prefix.c\n+\t$(CC) -o add_gc_prefix $(srcdir)/add_gc_prefix.c\n+\n+gc.tar: $(SRCS) $(OTHER_FILES) add_gc_prefix\n+\t./add_gc_prefix $(SRCS) $(OTHER_FILES) > /tmp/gc.tar-files\n+\t(cd $(srcdir)/.. ; tar cvfh - `cat /tmp/gc.tar-files`) > gc.tar\n+\n+pc_gc.tar: $(SRCS) $(OTHER_FILES)\n+\ttar cvfX pc_gc.tar pc_excludes $(SRCS) $(OTHER_FILES)\n+\n+floppy: pc_gc.tar\n+\t-mmd a:/cord\n+\t-mmd a:/cord/private\n+\t-mmd a:/include\n+\t-mmd a:/include/private\n+\tmkdir /tmp/pc_gc\n+\tcat pc_gc.tar | (cd /tmp/pc_gc; tar xvf -)\n+\t-mcopy -tmn /tmp/pc_gc/* a:\n+\t-mcopy -tmn /tmp/pc_gc/cord/* a:/cord\n+\t-mcopy -mn /tmp/pc_gc/cord/de_win.ICO a:/cord\n+\t-mcopy -tmn /tmp/pc_gc/cord/private/* a:/cord/private\n+\t-mcopy -tmn /tmp/pc_gc/include/* a:/include\n+\t-mcopy -tmn /tmp/pc_gc/include/private/* a:/include/private\n+\trm -r /tmp/pc_gc\n+\n+gc.tar.Z: gc.tar\n+\tcompress gc.tar\n+\n+gc.tar.gz: gc.tar\n+\tgzip gc.tar\n+\n+lint: $(CSRCS) test.c\n+\tlint -DLINT $(CSRCS) test.c | egrep -v \"possible pointer alignment problem|abort|exit|sbrk|mprotect|syscall\"\n+\n+# BTL: added to test shared library version of collector.\n+# Currently works only under SunOS5.  Requires GC_INIT call from statically\n+# loaded client code.\n+ABSDIR = `pwd`\n+gctest_dyn_link: test.o libgc.so\n+\t$(CC) -L$(ABSDIR) -R$(ABSDIR) -o gctest_dyn_link test.o -lgc -ldl -lthread\n+\n+gctest_irix_dyn_link: test.o libirixgc.so\n+\t$(CC) -L$(ABSDIR) -o gctest_irix_dyn_link test.o -lirixgc\n+\n+test_dll.o: test.c libgc_globals.h\n+\t$(CC) $(CFLAGS) -DGC_USE_DLL -c test.c -o test_dll.o\n+\n+test_dll: test_dll.o libgc_dll.a libgc.dll\n+\t$(CC) test_dll.o -L$(ABSDIR) -lgc_dll -o test_dll\n+\n+SYM_PREFIX-libgc=GC\n+\n+# Uncomment the following line to build a GNU win32 DLL\n+# include Makefile.DLLs\n+\n+reserved_namespace: $(SRCS)\n+\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\t\tsed s/GC_/_GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone\n+\n+user_namespace: $(SRCS)\n+\tfor file in $(SRCS) test.c test_cpp.cc; do \\\n+\t\tsed s/_GC_/GC_/g < $$file > tmp; \\\n+\t\tcp tmp $$file; \\\n+\t\tdone"}]}