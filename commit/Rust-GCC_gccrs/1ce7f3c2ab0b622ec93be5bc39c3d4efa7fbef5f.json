{"sha": "1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWNlN2YzYzJhYjBiNjIyZWM5M2JlNWJjMzljM2Q0ZWZhN2ZiZWY1Zg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2002-04-09T13:41:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2002-04-09T13:41:58Z"}, "message": "expr.c (is_aligning_offset): New function.\n\n\t* expr.c (is_aligning_offset): New function.\n\t(expand_expr, case COMPONENT_EXPR): Call it.\n\nFrom-SVN: r52077", "tree": {"sha": "14d76b2c26294fb26b13f27cfd4812966dd80bf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14d76b2c26294fb26b13f27cfd4812966dd80bf0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f/comments", "author": null, "committer": null, "parents": [{"sha": "dcf5a5dec81e8afe74a41dea213c0fccceb80cd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcf5a5dec81e8afe74a41dea213c0fccceb80cd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcf5a5dec81e8afe74a41dea213c0fccceb80cd7"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "b38c09a8e45e5f2925068dc8314c7fbae45d05b3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "patch": "@@ -1,3 +1,8 @@\n+Tue Apr  9 09:35:45 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* expr.c (is_aligning_offset): New function.\n+\t(expand_expr, case COMPONENT_EXPR): Call it.\n+\n 2002-04-08  David S. Miller  <davem@redhat.com>\n \n \tPR target/6082"}, {"sha": "11f1a53bc270f34398ee0d9da4cfad9169288a49", "filename": "gcc/expr.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1ce7f3c2ab0b622ec93be5bc39c3d4efa7fbef5f", "patch": "@@ -147,6 +147,7 @@ static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n \t\t\t\t\t int));\n static rtx var_rtx\t\tPARAMS ((tree));\n static HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n+static int is_aligning_offset\tPARAMS ((tree, tree));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n static void do_jump_by_parts_equality PARAMS ((tree, rtx, rtx));\n@@ -6927,6 +6928,12 @@ expand_expr (exp, target, tmode, modifier)\n \t\t\t\t  highest_pow2_factor (offset));\n \t  }\n \n+\t/* If OFFSET is making OP0 more aligned than BIGGEST_ALIGNMENT,\n+\t   record its alignment as BIGGEST_ALIGNMENT.  */\n+\tif (GET_CODE (op0) == MEM && bitpos == 0 && offset != 0\n+\t    && is_aligning_offset (offset, tem))\n+\t  set_mem_align (op0, BIGGEST_ALIGNMENT);\n+\n \t/* Don't forget about volatility even if this is a bitfield.  */\n \tif (GET_CODE (op0) == MEM && volatilep && ! MEM_VOLATILE_P (op0))\n \t  {\n@@ -8823,6 +8830,56 @@ expand_expr (exp, target, tmode, modifier)\n   return temp;\n }\n \f\n+/* Subroutine of above: returns 1 if OFFSET corresponds to an offset that\n+   when applied to the address of EXP produces an address known to be\n+   aligned more than BIGGEST_ALIGNMENT.  */\n+\n+static int\n+is_aligning_offset (offset, exp)\n+     tree offset;\n+     tree exp;\n+{\n+  /* Strip off any conversions and WITH_RECORD_EXPR nodes.  */\n+  while (TREE_CODE (offset) == NON_LVALUE_EXPR\n+\t || TREE_CODE (offset) == NOP_EXPR\n+\t || TREE_CODE (offset) == CONVERT_EXPR\n+\t || TREE_CODE (offset) == WITH_RECORD_EXPR)\n+    offset = TREE_OPERAND (offset, 0);\n+\n+  /* We must now have a BIT_AND_EXPR with a constant that is one less than\n+     power of 2 and which is larger than BIGGEST_ALIGNMENT.  */\n+  if (TREE_CODE (offset) != BIT_AND_EXPR\n+      || !host_integerp (TREE_OPERAND (offset, 1), 1)\n+      || compare_tree_int (TREE_OPERAND (offset, 1), BIGGEST_ALIGNMENT) <= 0\n+      || !exact_log2 (tree_low_cst (TREE_OPERAND (offset, 1), 1) + 1) < 0)\n+    return 0;\n+\n+  /* Look at the first operand of BIT_AND_EXPR and strip any conversion.\n+     It must be NEGATE_EXPR.  Then strip any more conversions.  */\n+  offset = TREE_OPERAND (offset, 0);\n+  while (TREE_CODE (offset) == NON_LVALUE_EXPR\n+\t || TREE_CODE (offset) == NOP_EXPR\n+\t || TREE_CODE (offset) == CONVERT_EXPR)\n+    offset = TREE_OPERAND (offset, 0);\n+\n+  if (TREE_CODE (offset) != NEGATE_EXPR)\n+    return 0;\n+\n+  offset = TREE_OPERAND (offset, 0);\n+  while (TREE_CODE (offset) == NON_LVALUE_EXPR\n+\t || TREE_CODE (offset) == NOP_EXPR\n+\t || TREE_CODE (offset) == CONVERT_EXPR)\n+    offset = TREE_OPERAND (offset, 0);\n+\n+  /* This must now be the address either of EXP or of a PLACEHOLDER_EXPR\n+     whose type is the same as EXP.  */\n+  return (TREE_CODE (offset) == ADDR_EXPR\n+\t  && (TREE_OPERAND (offset, 0) == exp\n+\t      || (TREE_CODE (TREE_OPERAND (offset, 0)) == PLACEHOLDER_EXPR\n+\t\t  && (TREE_TYPE (TREE_OPERAND (offset, 0))\n+\t\t      == TREE_TYPE (exp)))));\n+}\n+\f\n /* Return the tree node if a ARG corresponds to a string constant or zero\n    if it doesn't.  If we return non-zero, set *PTR_OFFSET to the offset\n    in bytes within the string that ARG is accessing.  The type of the"}]}