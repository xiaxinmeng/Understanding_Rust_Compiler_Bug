{"sha": "5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJmNWZhNTYzYWVhM2Y4NzYzZDJjNDlkNTNiZjhhMGQ4YzFiYzdjMg==", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-03-04T21:50:08Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2012-03-04T21:50:08Z"}, "message": "re PR fortran/50981 ([OOP] Wrong-code for scalarizing ELEMENTAL call with absent OPTIONAL argument)\n\nfortran/\n\tPR fortran/50981\n\t* gfortran.h (gfc_is_class_container_ref): New prototype.\n\t* class.c (gfc_is_class_container_ref): New function.\n\t* trans-expr.c (gfc_conv_procedure_call): Add a \"_data\" component\n\treference to polymorphic actual arguments.\n\ntestsuite/\n\tPR fortran/50981\n\t* gfortran.dg/elemental_optional_args_5.f03: Add subcomponent actual\n\targument checks.\n\nFrom-SVN: r184904", "tree": {"sha": "7065977b6c71f54588660cd5fd71f801483a0a0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7065977b6c71f54588660cd5fd71f801483a0a0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/comments", "author": null, "committer": null, "parents": [{"sha": "f0050a4b2a8ac6d61eeffcac8ad484be9ed462a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0050a4b2a8ac6d61eeffcac8ad484be9ed462a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0050a4b2a8ac6d61eeffcac8ad484be9ed462a3"}], "stats": {"total": 157, "additions": 157, "deletions": 0}, "files": [{"sha": "8e345264ba1574d1ff4f23bdc1a7228932825112", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -1,3 +1,11 @@\n+2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* gfortran.h (gfc_is_class_container_ref): New prototype.\n+\t* class.c (gfc_is_class_container_ref): New function.\n+\t* trans-expr.c (gfc_conv_procedure_call): Add a \"_data\" component\n+\treference to polymorphic actual arguments.\n+\n 2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/50981"}, {"sha": "a27513646c96f6d0569f02e0c7b3f1f8dc823f53", "filename": "gcc/fortran/class.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fclass.c?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -361,6 +361,39 @@ gfc_is_class_scalar_expr (gfc_expr *e)\n }\n \n \n+/* Tells whether the expression E is a reference to a (scalar) class container.\n+   Scalar because array class containers usually have an array reference after\n+   them, and gfc_fix_class_refs will add the missing \"_data\" component reference\n+   in that case.  */\n+\n+bool\n+gfc_is_class_container_ref (gfc_expr *e)\n+{\n+  gfc_ref *ref;\n+  bool result;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return e->ts.type == BT_CLASS;\n+\n+  if (e->symtree->n.sym->ts.type == BT_CLASS)\n+    result = true;\n+  else\n+    result = false;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    {\n+      if (ref->type != REF_COMPONENT)\n+\tresult = false;\n+      else if (ref->u.c.component->ts.type == BT_CLASS)\n+\tresult = true; \n+      else\n+\tresult = false;\n+    }\n+\n+  return result;\n+}\n+\n+\n /* Build a NULL initializer for CLASS pointers,\n    initializing the _data component to NULL and\n    the _vptr component to the declared type.  */"}, {"sha": "d764b62b7294330d21df95972634e78a3f2b5428", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -2930,6 +2930,7 @@ void gfc_add_class_array_ref (gfc_expr *);\n #define gfc_add_def_init_component(e) gfc_add_component_ref(e,\"_def_init\")\n bool gfc_is_class_array_ref (gfc_expr *, bool *);\n bool gfc_is_class_scalar_expr (gfc_expr *);\n+bool gfc_is_class_container_ref (gfc_expr *e);\n gfc_expr *gfc_class_null_initializer (gfc_typespec *);\n unsigned int gfc_hash_value (gfc_symbol *);\n gfc_try gfc_build_class_symbol (gfc_typespec *, symbol_attribute *,"}, {"sha": "036b55bdf9673148a2a6ed62469809bedb0b75ad", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -3542,6 +3542,10 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);\n \n+\t  if (fsym && fsym->ts.type == BT_DERIVED\n+\t      && gfc_is_class_container_ref (e))\n+\t    parmse.expr = gfc_class_data_get (parmse.expr);\n+\n \t  /* If we are passing an absent array as optional dummy to an\n \t     elemental procedure, make sure that we pass NULL when the data\n \t     pointer is NULL.  We need this extra conditional because of"}, {"sha": "fc4158423c4cc3211d179b36dd1fceacc9de4a14", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -1,3 +1,9 @@\n+2012-03-04  Mikael Morin  <mikael@gcc.gnu.org>\n+\n+\tPR fortran/50981\n+\t* gfortran.dg/elemental_optional_args_5.f03: Add subcomponent actual\n+\targument checks.\n+\n 2012-03-04  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/52146"}, {"sha": "e0ed0c20d5e841d0a75c2301e9477580202e9e1c", "filename": "gcc/testsuite/gfortran.dg/elemental_optional_args_5.f03", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Felemental_optional_args_5.f03?ref=5bf5fa563aea3f8763d2c49d53bf8a0d8c1bc7c2", "patch": "@@ -115,6 +115,111 @@\n if (s /= 3) call abort()\n if (any (v /= [9, 33])) call abort()\n \n+call sub_t (s, ca, .false.)\n+call sub_t (v, ca, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub_t (s, cp, .false.)\n+call sub_t (v, cp, .false.)\n+!print *, s, v\n+if (s /= 3) call abort()\n+if (any (v /= [9, 33])) call abort()\n+\n+! SCALAR COMPONENTS: alloc/assoc\n+\n+allocate (ta, tp, ca, cp)\n+ta%a = 4\n+tp%a = 5\n+ca%a = 6\n+cp%a = 7\n+\n+call sub_t (s, ta, .true.)\n+call sub_t (v, ta, .true.)\n+!print *, s, v\n+if (s /= 4*2) call abort()\n+if (any (v /= [4*2, 4*2])) call abort()\n+\n+call sub_t (s, tp, .true.)\n+call sub_t (v, tp, .true.)\n+!print *, s, v\n+if (s /= 5*2) call abort()\n+if (any (v /= [5*2, 5*2])) call abort()\n+\n+call sub_t (s, ca, .true.)\n+call sub_t (v, ca, .true.)\n+!print *, s, v\n+if (s /= 6*2) call abort()\n+if (any (v /= [6*2, 6*2])) call abort()\n+\n+call sub_t (s, cp, .true.)\n+call sub_t (v, cp, .true.)\n+!print *, s, v\n+if (s /= 7*2) call abort()\n+if (any (v /= [7*2, 7*2])) call abort()\n+\n+! ARRAY COMPONENTS: Non alloc/assoc\n+\n+v = [9, 33]\n+\n+call sub_t (v, taa, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub_t (v, tpa, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub_t (v, caa, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+call sub_t (v, cpa, .false.)\n+!print *, v\n+if (any (v /= [9, 33])) call abort()\n+\n+deallocate(ta, tp, ca, cp)\n+\n+\n+! ARRAY COMPONENTS: alloc/assoc\n+\n+allocate (taa(2), tpa(2))\n+taa(1:2)%a = [44, 444]\n+tpa(1:2)%a = [55, 555]\n+allocate (caa(2), source=[t(66), t(666)])\n+allocate (cpa(2), source=[t(77), t(777)])\n+\n+select type (caa)\n+type is (t)\n+  if (any (caa(:)%a /= [66, 666])) call abort()\n+end select\n+\n+select type (cpa)\n+type is (t)\n+  if (any (cpa(:)%a /= [77, 777])) call abort()\n+end select\n+\n+call sub_t (v, taa, .true.)\n+!print *, v\n+if (any (v /= [44*2, 444*2])) call abort()\n+\n+call sub_t (v, tpa, .true.)\n+!print *, v\n+if (any (v /= [55*2, 555*2])) call abort()\n+\n+\n+call sub_t (v, caa, .true.)\n+!print *, v\n+if (any (v /= [66*2, 666*2])) call abort()\n+\n+call sub_t (v, cpa, .true.)\n+!print *, v\n+if (any (v /= [77*2, 777*2])) call abort()\n+\n+deallocate (taa, tpa, caa, cpa)\n+\n+\n contains\n \n   elemental subroutine sub1 (x, y, alloc)"}]}