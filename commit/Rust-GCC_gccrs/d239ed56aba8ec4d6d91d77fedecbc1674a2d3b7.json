{"sha": "d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDIzOWVkNTZhYmE4ZWM0ZDZkOTFkNzdmZWRlY2JjMTY3NGEyZDNiNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb.gcc@gmail.com", "date": "2006-01-23T09:47:01Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2006-01-23T09:47:01Z"}, "message": "re PR rtl-optimization/25654 (RTL alias analysis unprepared to handle stack slot sharing)\n\n2006-01-23  Steven Bosscher  <stevenb.gcc@gmail.com>\n\tJan Hubicka  <jh@suse.cz>\n\tRichard Guenther  <rguenther@suse.de>\n\n\tPR rtl-optimization/25654\n\t* cfgexpand.c (aggregate_contains_union_type): New function.\n\t(add_alias_set_conflicts): Call it.  Make sure to add conflicts\n\tfor structure variables that contain a union type.\n\n\t* gcc.dg/torture/pr25654.c: New testcase.\n\t* gcc.target/i386/pr25654.c: Likewise.\n\nCo-Authored-By: Jan Hubicka <jh@suse.cz>\nCo-Authored-By: Richard Guenther <rguenther@suse.de>\n\nFrom-SVN: r110109", "tree": {"sha": "6cabb48df9b8cfad2881998e1a67ab45201463ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cabb48df9b8cfad2881998e1a67ab45201463ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/comments", "author": null, "committer": null, "parents": [{"sha": "0f01f026dc4f3f265545bd112583c4756933e31a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f01f026dc4f3f265545bd112583c4756933e31a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f01f026dc4f3f265545bd112583c4756933e31a"}], "stats": {"total": 142, "additions": 138, "deletions": 4}, "files": [{"sha": "d1b92c8489f45b68c7a36fcde4f695072b271b65", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "patch": "@@ -1,3 +1,12 @@\n+2006-01-23  Steven Bosscher  <stevenb.gcc@gmail.com>\n+\tJan Hubicka  <jh@suse.cz>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/25654\n+\t* cfgexpand.c (aggregate_contains_union_type): New function.\n+\t(add_alias_set_conflicts): Call it.  Make sure to add conflicts\n+\tfor structure variables that contain a union type.\n+\n 2006-01-23  Richard Sandiford  <richard@codesourcery.com>\n \n \t* gengtype.c (new_structure): Return the structure."}, {"sha": "2408e8af147db539a28db3923846bd0e3e4cf81c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 43, "deletions": 4, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "patch": "@@ -272,11 +272,39 @@ stack_var_conflict_p (size_t x, size_t y)\n   gcc_assert (index < stack_vars_conflict_alloc);\n   return stack_vars_conflict[index];\n }\n-  \n+ \n+/* Returns true if TYPE is or contains a union type.  */\n+\n+static bool\n+aggregate_contains_union_type (tree type)\n+{\n+  tree field;\n+\n+  if (TREE_CODE (type) == UNION_TYPE\n+      || TREE_CODE (type) == QUAL_UNION_TYPE)\n+    return true;\n+  if (TREE_CODE (type) == ARRAY_TYPE)\n+    return aggregate_contains_union_type (TREE_TYPE (type));\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    return false;\n+\n+  for (field = TYPE_FIELDS (type); field; field = TREE_CHAIN (field))\n+    if (TREE_CODE (field) == FIELD_DECL)\n+      if (aggregate_contains_union_type (TREE_TYPE (field)))\n+\treturn true;\n+\n+  return false;\n+}\n+\n /* A subroutine of expand_used_vars.  If two variables X and Y have alias\n    sets that do not conflict, then do add a conflict for these variables\n-   in the interference graph.  We also have to mind MEM_IN_STRUCT_P and\n-   MEM_SCALAR_P.  */\n+   in the interference graph.  We also need to make sure to add conflicts\n+   for union containing structures.  Else RTL alias analysis comes along\n+   and due to type based aliasing rules decides that for two overlapping\n+   union temporaries { short s; int i; } accesses to the same mem through\n+   different types may not alias and happily reorders stores across\n+   life-time boundaries of the temporaries (See PR25654).\n+   We also have to mind MEM_IN_STRUCT_P and MEM_SCALAR_P.  */\n \n static void\n add_alias_set_conflicts (void)\n@@ -287,12 +315,23 @@ add_alias_set_conflicts (void)\n     {\n       tree type_i = TREE_TYPE (stack_vars[i].decl);\n       bool aggr_i = AGGREGATE_TYPE_P (type_i);\n+      bool contains_union;\n \n+      contains_union = aggregate_contains_union_type (type_i);\n       for (j = 0; j < i; ++j)\n \t{\n \t  tree type_j = TREE_TYPE (stack_vars[j].decl);\n \t  bool aggr_j = AGGREGATE_TYPE_P (type_j);\n-\t  if (aggr_i != aggr_j || !objects_must_conflict_p (type_i, type_j))\n+\t  if (aggr_i != aggr_j\n+\t      /* Either the objects conflict by means of type based\n+\t\t aliasing rules, or we need to add a conflict.  */\n+\t      || !objects_must_conflict_p (type_i, type_j)\n+\t      /* In case the types do not conflict ensure that access\n+\t\t to elements will conflict.  In case of unions we have\n+\t\t to be careful as type based aliasing rules may say\n+\t\t access to the same memory does not conflict.  So play\n+\t\t safe and add a conflict in this case.  */\n+\t      || contains_union)\n \t    add_stack_var_conflict (i, j);\n \t}\n     }"}, {"sha": "eb289c61b23e71008b8a73c3b2f7e1586bec274c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "patch": "@@ -1,3 +1,11 @@\n+2006-01-23  Steven Bosscher  <stevenb.gcc@gmail.com>\n+\tJan Hubicka  <jh@suse.cz>\n+\tRichard Guenther  <rguenther@suse.de>\n+\n+\tPR rtl-optimization/25654\n+\t* gcc.dg/torture/pr25654.c: New testcase.\n+\t* gcc.target/i386/pr25654.c: Likewise.\n+\n 2005-01-23  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/25901"}, {"sha": "03761e93c39683d9a1fbf92a5a2cc66f673064b1", "filename": "gcc/testsuite/gcc.dg/torture/pr25654.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25654.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25654.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr25654.c?ref=d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+\n+extern void abort (void) __attribute__((noreturn));\n+\n+union setconflict\n+{\n+  short a[20];\n+  int b[10];\n+};\n+\n+int\n+main ()\n+{\n+  int sum = 0;\n+  {\n+    union setconflict a;\n+    short *c;\n+    c = a.a;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    *c = 0;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    sum += *c;\n+  }\n+  {\n+    union setconflict a;\n+    int *c;\n+    c = a.b;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    *c = 1;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    sum += *c;\n+  }\n+\n+  if (sum != 1)\n+    abort();\n+  return 0;\n+}"}, {"sha": "afb2ff6d2a4491ac22e300fe5b080f73e23a03cd", "filename": "gcc/testsuite/gcc.target/i386/pr25654.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr25654.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr25654.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr25654.c?ref=d239ed56aba8ec4d6d91d77fedecbc1674a2d3b7", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run { target ilp32 } } */\n+/* { dg-options \"-O2 -mpreferred-stack-boundary=2 -march=i686 -frename-registers\" } */\n+\n+extern void abort (void) __attribute__((noreturn));\n+\n+struct wrapper {\n+union setconflict\n+{\n+  short a[20];\n+  int b[10];\n+} a;\n+};\n+\n+int\n+main ()\n+{\n+  int sum = 0;\n+  {\n+    struct wrapper a;\n+    short *c;\n+    c = a.a.a;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    *c = 0;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    sum += *c;\n+  }\n+  {\n+    struct wrapper a;\n+    int *c;\n+    c = a.a.b;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    *c = 1;\n+    asm (\"\": \"=r\" (c):\"0\" (c));\n+    sum += *c;\n+  }\n+\n+  if (sum != 1)\n+    abort();\n+  return 0;\n+}\n+"}]}