{"sha": "3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I0N2RhNDJkZTYyMWM2YzNiZjdkMmY5MjQ1ZGY5ODlhYTdlYjVhMQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2019-06-06T16:31:20Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2019-06-06T16:31:20Z"}, "message": "Make SRA re-construct orginal memory accesses when easy\n\n2019-06-06  Martin Jambor  <mjambor@suse.cz>\n\n\t* tree-sra.c (struct access): New field grp_same_access_path.\n\t(dump_access): Dump it.\n\t(build_reconstructed_reference): New function.\n\t(build_ref_for_model): Use it if possible.\n\t(path_comparable_for_same_access): New function.\n\t(same_access_path_p): Likewise.\n\t(sort_and_splice_var_accesses): Set the new flag.\n\t(analyze_access_subtree): Likewise.\n\t(propagate_subaccesses_across_link): Propagate zero value of the new\n\tflag down the access tree.\n\n\ttestsuite/\n\t* gcc.dg/tree-ssa/alias-access-path-1.c: Remove -fno-tree-sra option.\n\t* gcc.dg/tree-ssa/ssa-dse-26.c: Disable FRE.\n\t* testsuite/gnat.dg/opt39.adb: Adjust scan dump.\n\nFrom-SVN: r272012", "tree": {"sha": "4c37321fcafb5e38a43aea877ba8703f2d1540a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c37321fcafb5e38a43aea877ba8703f2d1540a7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "beb0086f592563ddd2b14444d4e2495b17b1d4bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/beb0086f592563ddd2b14444d4e2495b17b1d4bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/beb0086f592563ddd2b14444d4e2495b17b1d4bf"}], "stats": {"total": 161, "additions": 150, "deletions": 11}, "files": [{"sha": "da16cea3389081084cf09bdf7dc6b2b4879e2966", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -1,3 +1,16 @@\n+2019-06-06  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* tree-sra.c (struct access): New field grp_same_access_path.\n+\t(dump_access): Dump it.\n+\t(build_reconstructed_reference): New function.\n+\t(build_ref_for_model): Use it if possible.\n+\t(path_comparable_for_same_access): New function.\n+\t(same_access_path_p): Likewise.\n+\t(sort_and_splice_var_accesses): Set the new flag.\n+\t(analyze_access_subtree): Likewise.\n+\t(propagate_subaccesses_across_link): Propagate zero value of the new\n+\tflag down the access tree.\n+\n 2019-06-06  Andrew Stubbs  <ams@codesourcery.com>\n \n \t* config.gcc (amdgcn-*-*): Allow --with-arch=gfx906."}, {"sha": "d2f25fc4df328e4f88c444fa843d02973c0ac8ad", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -1,3 +1,9 @@\n+2019-06-06  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-1.c: Remove -fno-tree-sra option.\n+\t* gcc.dg/tree-ssa/ssa-dse-26.c: Disable FRE.\n+\t* gnat.dg/opt39.adb: Adjust scan dump.\n+\n 2019-06-06  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* gcc.target/msp430/size-optimized-shifts.c: New test."}, {"sha": "ba90b56fe5c7af7727ded59facb66c460ab4c66e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-1.c?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-fre3 -fno-tree-sra\" } */\n+/* { dg-options \"-O2 -fdump-tree-fre3\" } */\n struct foo\n {\n   int val;"}, {"sha": "836a8092ab902fde5ce0dd0c6d1352c6065d9223", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-dse-26.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-dse-26.c?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-dse1-details -fno-short-enums\" } */\n+/* { dg-options \"-O2 -fdump-tree-dse1-details -fno-short-enums -fno-tree-fre\" } */\n /* { dg-skip-if \"temporary variable for constraint_expr is never used\" { msp430-*-* } } */\n \n enum constraint_expr_type"}, {"sha": "0a5ef67a2edcf08b607489cebdf0bcb0bd073760", "filename": "gcc/testsuite/gnat.dg/opt39.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgnat.dg%2Fopt39.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftestsuite%2Fgnat.dg%2Fopt39.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fopt39.adb?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -27,4 +27,5 @@ begin\n   end if;\n end;\n \n--- { dg-final { scan-tree-dump-times \"MEM\" 1 \"optimized\" } }\n+-- { dg-final { scan-tree-dump-not \"MEM\" \"optimized\" } }\n+-- { dg-final { scan-tree-dump-not \"tmp\" \"optimized\" } }"}, {"sha": "a246a93a48dac94af20479f5002355ecddc2778b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 127, "deletions": 8, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b47da42de621c6c3bf7d2f9245df989aa7eb5a1/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=3b47da42de621c6c3bf7d2f9245df989aa7eb5a1", "patch": "@@ -106,6 +106,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"builtins.h\"\n \n+\n /* Enumeration of all aggregate reductions we can do.  */\n enum sra_mode { SRA_MODE_EARLY_IPA,   /* early call regularization */\n \t\tSRA_MODE_EARLY_INTRA, /* early intraprocedural SRA */\n@@ -242,6 +243,10 @@ struct access\n      access tree.  */\n   unsigned grp_unscalarized_data : 1;\n \n+  /* Set if all accesses in the group consist of the same chain of\n+     COMPONENT_REFs and ARRAY_REFs.  */\n+  unsigned grp_same_access_path : 1;\n+\n   /* Does this access and/or group contain a write access through a\n      BIT_FIELD_REF?  */\n   unsigned grp_partial_lhs : 1;\n@@ -443,16 +448,18 @@ dump_access (FILE *f, struct access *access, bool grp)\n \t     \"grp_scalar_write = %d, grp_total_scalarization = %d, \"\n \t     \"grp_hint = %d, grp_covered = %d, \"\n \t     \"grp_unscalarizable_region = %d, grp_unscalarized_data = %d, \"\n-\t     \"grp_partial_lhs = %d, grp_to_be_replaced = %d, \"\n-\t     \"grp_to_be_debug_replaced = %d, grp_maybe_modified = %d, \"\n+\t     \"grp_same_access_path = %d, grp_partial_lhs = %d, \"\n+\t     \"grp_to_be_replaced = %d, grp_to_be_debug_replaced = %d, \"\n+\t     \"grp_maybe_modified = %d, \"\n \t     \"grp_not_necessarilly_dereferenced = %d\\n\",\n \t     access->grp_read, access->grp_write, access->grp_assignment_read,\n \t     access->grp_assignment_write, access->grp_scalar_read,\n \t     access->grp_scalar_write, access->grp_total_scalarization,\n \t     access->grp_hint, access->grp_covered,\n \t     access->grp_unscalarizable_region, access->grp_unscalarized_data,\n-\t     access->grp_partial_lhs, access->grp_to_be_replaced,\n-\t     access->grp_to_be_debug_replaced, access->grp_maybe_modified,\n+\t     access->grp_same_access_path, access->grp_partial_lhs,\n+\t     access->grp_to_be_replaced, access->grp_to_be_debug_replaced,\n+\t     access->grp_maybe_modified,\n \t     access->grp_not_necessarilly_dereferenced);\n   else\n     fprintf (f, \", write = %d, grp_total_scalarization = %d, \"\n@@ -1795,6 +1802,30 @@ build_ref_for_offset (location_t loc, tree base, poly_int64 offset,\n   return mem_ref;\n }\n \n+/* Construct and return a memory reference that is equal to a portion of\n+   MODEL->expr but is based on BASE.  If this cannot be done, return NULL.  */\n+\n+static tree\n+build_reconstructed_reference (location_t, tree base, struct access *model)\n+{\n+  tree expr = model->expr, prev_expr = NULL;\n+  while (!types_compatible_p (TREE_TYPE (expr), TREE_TYPE (base)))\n+    {\n+      if (!handled_component_p (expr))\n+\treturn NULL;\n+      prev_expr = expr;\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n+\n+  if (get_object_alignment (base) < get_object_alignment (expr))\n+    return NULL;\n+\n+  TREE_OPERAND (prev_expr, 0) = base;\n+  tree ref = unshare_expr (model->expr);\n+  TREE_OPERAND (prev_expr, 0) = expr;\n+  return ref;\n+}\n+\n /* Construct a memory reference to a part of an aggregate BASE at the given\n    OFFSET and of the same type as MODEL.  In case this is a reference to a\n    bit-field, the function will replicate the last component_ref of model's\n@@ -1822,9 +1853,19 @@ build_ref_for_model (location_t loc, tree base, HOST_WIDE_INT offset,\n \t\t\t      NULL_TREE);\n     }\n   else\n-    return\n-      build_ref_for_offset (loc, base, offset, model->reverse, model->type,\n-\t\t\t    gsi, insert_after);\n+    {\n+      tree res;\n+      if (model->grp_same_access_path\n+\t  && !TREE_THIS_VOLATILE (base)\n+\t  && offset <= model->offset\n+\t  /* build_reconstructed_reference can still fail if we have already\n+\t     massaged BASE because of another type incompatibility.  */\n+\t  && (res = build_reconstructed_reference (loc, base, model)))\n+\treturn res;\n+      else\n+\treturn build_ref_for_offset (loc, base, offset, model->reverse,\n+\t\t\t\t     model->type, gsi, insert_after);\n+    }\n }\n \n /* Attempt to build a memory reference that we could but into a gimple\n@@ -2076,6 +2117,69 @@ find_var_candidates (void)\n   return ret;\n }\n \n+/* Return true if EXP is a reference chain of COMPONENT_REFs and AREAY_REFs\n+   ending either with a DECL or a MEM_REF with zero offset.  */\n+\n+static bool\n+path_comparable_for_same_access (tree expr)\n+{\n+  while (handled_component_p (expr))\n+    {\n+      if (TREE_CODE (expr) == ARRAY_REF)\n+\t{\n+\t  /* SSA name indices can occur here too when the array is of sie one.\n+\t     But we cannot just re-use array_refs with SSA names elsewhere in\n+\t     the function, so disallow non-constant indices.  TODO: Remove this\n+\t     limitation after teaching build_reconstructed_reference to replace\n+\t     the index with the index type lower bound.  */\n+\t  if (TREE_CODE (TREE_OPERAND (expr, 1)) != INTEGER_CST)\n+\t    return false;\n+\t}\n+      expr = TREE_OPERAND (expr, 0);\n+    }\n+\n+  if (TREE_CODE (expr) == MEM_REF)\n+    {\n+      if (!zerop (TREE_OPERAND (expr, 1)))\n+\treturn false;\n+    }\n+  else\n+    gcc_assert (DECL_P (expr));\n+\n+  return true;\n+}\n+\n+/* Assuming that EXP1 consists of only COMPONENT_REFs and ARRAY_REFs, return\n+   true if the chain of these handled components are exactly the same as EXP2\n+   and the expression under them is the same DECL or an equivalent MEM_REF.\n+   The reference picked by compare_access_positions must go to EXP1.  */\n+\n+static bool\n+same_access_path_p (tree exp1, tree exp2)\n+{\n+  if (TREE_CODE (exp1) != TREE_CODE (exp2))\n+    {\n+      /* Special case single-field structures loaded sometimes as the field\n+\t and sometimes as the structure.  If the field is of a scalar type,\n+\t compare_access_positions will put it into exp1.\n+\n+\t TODO: The gimple register type condition can be removed if teach\n+\t compare_access_positions to put inner types first.  */\n+      if (is_gimple_reg_type (TREE_TYPE (exp1))\n+\t  && TREE_CODE (exp1) == COMPONENT_REF\n+\t  && (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_OPERAND (exp1, 0)))\n+\t      == TYPE_MAIN_VARIANT (TREE_TYPE (exp2))))\n+\texp1 = TREE_OPERAND (exp1, 0);\n+      else\n+\treturn false;\n+    }\n+\n+  if (!operand_equal_p (exp1, exp2, OEP_ADDRESS_OF))\n+    return false;\n+\n+  return true;\n+}\n+\n /* Sort all accesses for the given variable, check for partial overlaps and\n    return NULL if there are any.  If there are none, pick a representative for\n    each combination of offset and size and create a linked list out of them.\n@@ -2116,6 +2220,7 @@ sort_and_splice_var_accesses (tree var)\n       bool grp_partial_lhs = access->grp_partial_lhs;\n       bool first_scalar = is_gimple_reg_type (access->type);\n       bool unscalarizable_region = access->grp_unscalarizable_region;\n+      bool grp_same_access_path = true;\n       bool bf_non_full_precision\n \t= (INTEGRAL_TYPE_P (access->type)\n \t   && TYPE_PRECISION (access->type) != access->size\n@@ -2134,6 +2239,8 @@ sort_and_splice_var_accesses (tree var)\n \tgcc_assert (access->offset >= low\n \t\t    && access->offset + access->size <= high);\n \n+      grp_same_access_path = path_comparable_for_same_access (access->expr);\n+\n       j = i + 1;\n       while (j < access_count)\n \t{\n@@ -2184,6 +2291,11 @@ sort_and_splice_var_accesses (tree var)\n \t\t}\n \t      unscalarizable_region = true;\n \t    }\n+\n+\t  if (grp_same_access_path\n+\t      && !same_access_path_p (access->expr, ac2->expr))\n+\t    grp_same_access_path = false;\n+\n \t  ac2->group_representative = access;\n \t  j++;\n \t}\n@@ -2202,6 +2314,7 @@ sort_and_splice_var_accesses (tree var)\n       access->grp_total_scalarization = total_scalarization;\n       access->grp_partial_lhs = grp_partial_lhs;\n       access->grp_unscalarizable_region = unscalarizable_region;\n+      access->grp_same_access_path = grp_same_access_path;\n \n       *prev_acc_ptr = access;\n       prev_acc_ptr = &access->next_grp;\n@@ -2471,6 +2584,8 @@ analyze_access_subtree (struct access *root, struct access *parent,\n \troot->grp_assignment_write = 1;\n       if (parent->grp_total_scalarization)\n \troot->grp_total_scalarization = 1;\n+      if (!parent->grp_same_access_path)\n+\troot->grp_same_access_path = 0;\n     }\n \n   if (root->grp_unscalarizable_region)\n@@ -2721,13 +2836,17 @@ propagate_subaccesses_across_link (struct access *lacc, struct access *racc)\n \t  lacc->type = racc->type;\n \t  if (build_user_friendly_ref_for_offset (&t, TREE_TYPE (t),\n \t\t\t\t\t\t  lacc->offset, racc->type))\n-\t    lacc->expr = t;\n+\t    {\n+\t      lacc->expr = t;\n+\t      lacc->grp_same_access_path = true;\n+\t    }\n \t  else\n \t    {\n \t      lacc->expr = build_ref_for_model (EXPR_LOCATION (lacc->base),\n \t\t\t\t\t\tlacc->base, lacc->offset,\n \t\t\t\t\t\tracc, NULL, false);\n \t      lacc->grp_no_warning = true;\n+\t      lacc->grp_same_access_path = false;\n \t    }\n \t}\n       return ret;"}]}