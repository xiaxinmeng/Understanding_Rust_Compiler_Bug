{"sha": "e9ebb86799fd77cdd5351078230c114a90e66066", "node_id": "C_kwDOANBUbNoAKGU5ZWJiODY3OTlmZDc3Y2RkNTM1MTA3ODIzMGMxMTRhOTBlNjYwNjY", "commit": {"author": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2019-11-27T12:53:40Z"}, "committer": {"name": "Robin Dapp", "email": "rdapp@linux.ibm.com", "date": "2022-01-19T17:36:04Z"}, "message": "ifcvt/optabs: Allow using a CC comparison for emit_conditional_move.\n\nCurrently we only ever call emit_conditional_move with the comparison\n(as well as its comparands) we got from the jump.  Thus, backends are\ngoing to emit a CC comparison for every conditional move that is being\ngenerated instead of re-using the existing CC.\nThis, combined with emitting temporaries for each conditional move,\ncauses sky-high costs for conditional moves.\n\nThis patch allows to re-use a CC so the costing situation is improved a\nbit.\n\ngcc/ChangeLog:\n\n\t* rtl.h (struct rtx_comparison): New struct that holds an rtx\n\tcomparison.\n\t* config/rs6000/rs6000.cc (rs6000_emit_minmax): Use struct instead of\n\tsingle parameters.\n\t(rs6000_emit_swsqrt): Likewise.\n\t* expmed.cc (expand_sdiv_pow2): Likewise.\n\t(emit_store_flag): Likewise.\n\t* expr.cc (expand_cond_expr_using_cmove): Likewise.\n\t(expand_expr_real_2): Likewise.\n\t* ifcvt.cc (noce_emit_cmove): Add compare and reversed compare\n\tparameters.\n\t* optabs.cc (emit_conditional_move_1): New function.\n\t(expand_doubleword_shift_condmove): Use struct.\n\t(emit_conditional_move): Use struct and allow to call directly\n\twithout going through preparation steps.\n\t* optabs.h (emit_conditional_move): Use struct.", "tree": {"sha": "b4059397fb9dbe62eb1ae824af3b22f13c7ab400", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b4059397fb9dbe62eb1ae824af3b22f13c7ab400"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9ebb86799fd77cdd5351078230c114a90e66066", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ebb86799fd77cdd5351078230c114a90e66066", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9ebb86799fd77cdd5351078230c114a90e66066", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9ebb86799fd77cdd5351078230c114a90e66066/comments", "author": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rdapp-ibm", "id": 80318053, "node_id": "MDQ6VXNlcjgwMzE4MDUz", "avatar_url": "https://avatars.githubusercontent.com/u/80318053?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rdapp-ibm", "html_url": "https://github.com/rdapp-ibm", "followers_url": "https://api.github.com/users/rdapp-ibm/followers", "following_url": "https://api.github.com/users/rdapp-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/rdapp-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rdapp-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rdapp-ibm/subscriptions", "organizations_url": "https://api.github.com/users/rdapp-ibm/orgs", "repos_url": "https://api.github.com/users/rdapp-ibm/repos", "events_url": "https://api.github.com/users/rdapp-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/rdapp-ibm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46346d8d76c24bd07a30cb2c367e34601efabfef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46346d8d76c24bd07a30cb2c367e34601efabfef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46346d8d76c24bd07a30cb2c367e34601efabfef"}], "stats": {"total": 224, "additions": 157, "deletions": 67}, "files": [{"sha": "0882ecbaebfa6e26eb6a2942a2b644be66aa4c25", "filename": "gcc/config/rs6000/rs6000.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fconfig%2Frs6000%2Frs6000.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.cc?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -16373,10 +16373,10 @@ rs6000_emit_minmax (rtx dest, enum rtx_code code, rtx op0, rtx op1)\n     c = GEU;\n \n   if (code == SMAX || code == UMAX)\n-    target = emit_conditional_move (dest, c, op0, op1, mode,\n+    target = emit_conditional_move (dest, { c, op0, op1, mode },\n \t\t\t\t    op0, op1, mode, 0);\n   else\n-    target = emit_conditional_move (dest, c, op0, op1, mode,\n+    target = emit_conditional_move (dest, { c, op0, op1, mode },\n \t\t\t\t    op1, op0, mode, 0);\n   gcc_assert (target);\n   if (target != dest)\n@@ -22769,7 +22769,7 @@ rs6000_emit_swsqrt (rtx dst, rtx src, bool recip)\n \n       if (mode == SFmode)\n \t{\n-\t  rtx target = emit_conditional_move (e, GT, src, zero, mode,\n+\t  rtx target = emit_conditional_move (e, { GT, src, zero, mode },\n \t\t\t\t\t      e, zero, mode, 0);\n \t  if (target != e)\n \t    emit_move_insn (e, target);"}, {"sha": "80a16cedfd5b032b7008bb8591aa26f784be8fe7", "filename": "gcc/expmed.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fexpmed.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fexpmed.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.cc?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -4124,8 +4124,8 @@ expand_sdiv_pow2 (scalar_int_mode mode, rtx op0, HOST_WIDE_INT d)\n       temp = force_reg (mode, temp);\n \n       /* Construct \"temp2 = (temp2 < 0) ? temp : temp2\".  */\n-      temp2 = emit_conditional_move (temp2, LT, temp2, const0_rtx,\n-\t\t\t\t     mode, temp, temp2, mode, 0);\n+      temp2 = emit_conditional_move (temp2, { LT, temp2, const0_rtx, mode },\n+\t\t\t\t     temp, temp2, mode, 0);\n       if (temp2)\n \t{\n \t  rtx_insn *seq = get_insns ();\n@@ -6127,10 +6127,10 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \treturn 0;\n \n       if (and_them)\n-\ttem = emit_conditional_move (target, code, op0, op1, mode,\n+\ttem = emit_conditional_move (target, { code, op0, op1, mode },\n \t\t\t\t     tem, const0_rtx, GET_MODE (tem), 0);\n       else\n-\ttem = emit_conditional_move (target, code, op0, op1, mode,\n+\ttem = emit_conditional_move (target, { code, op0, op1, mode },\n \t\t\t\t     trueval, tem, GET_MODE (tem), 0);\n \n       if (tem == 0)"}, {"sha": "35e40299753bbceaaa6205001cdcb8f5fbfafdc7", "filename": "gcc/expr.cc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.cc?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -8824,8 +8824,9 @@ expand_cond_expr_using_cmove (tree treeop0 ATTRIBUTE_UNUSED,\n     op2 = gen_lowpart (mode, op2);\n \n   /* Try to emit the conditional move.  */\n-  insn = emit_conditional_move (temp, comparison_code,\n-\t\t\t\top00, op01, comparison_mode,\n+  insn = emit_conditional_move (temp,\n+\t\t\t\t{ comparison_code, op00, op01,\n+\t\t\t\t  comparison_mode },\n \t\t\t\top1, op2, mode,\n \t\t\t\tunsignedp);\n \n@@ -9716,8 +9717,9 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n \t    start_sequence ();\n \n \t    /* Try to emit the conditional move.  */\n-\t    insn = emit_conditional_move (target, comparison_code,\n-\t\t\t\t\t  op0, cmpop1, mode,\n+\t    insn = emit_conditional_move (target,\n+\t\t\t\t\t  { comparison_code,\n+\t\t\t\t\t    op0, cmpop1, mode },\n \t\t\t\t\t  op0, op1, mode,\n \t\t\t\t\t  unsignedp);\n "}, {"sha": "7c81738e5377ffb3bc51152faf2e66b265307a62", "filename": "gcc/ifcvt.cc", "status": "modified", "additions": 27, "deletions": 18, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fifcvt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Fifcvt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.cc?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -772,7 +772,7 @@ static int noce_try_addcc (struct noce_if_info *);\n static int noce_try_store_flag_constants (struct noce_if_info *);\n static int noce_try_store_flag_mask (struct noce_if_info *);\n static rtx noce_emit_cmove (struct noce_if_info *, rtx, enum rtx_code, rtx,\n-\t\t\t    rtx, rtx, rtx);\n+\t\t\t    rtx, rtx, rtx, rtx = NULL, rtx = NULL);\n static int noce_try_cmove (struct noce_if_info *);\n static int noce_try_cmove_arith (struct noce_if_info *);\n static rtx noce_get_alt_condition (struct noce_if_info *, rtx, rtx_insn **);\n@@ -1711,7 +1711,8 @@ noce_try_store_flag_mask (struct noce_if_info *if_info)\n \n static rtx\n noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n-\t\t rtx cmp_a, rtx cmp_b, rtx vfalse, rtx vtrue)\n+\t\t rtx cmp_a, rtx cmp_b, rtx vfalse, rtx vtrue, rtx cc_cmp,\n+\t\t rtx rev_cc_cmp)\n {\n   rtx target ATTRIBUTE_UNUSED;\n   int unsignedp ATTRIBUTE_UNUSED;\n@@ -1743,23 +1744,30 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n       end_sequence ();\n     }\n \n-  /* Don't even try if the comparison operands are weird\n-     except that the target supports cbranchcc4.  */\n-  if (! general_operand (cmp_a, GET_MODE (cmp_a))\n-      || ! general_operand (cmp_b, GET_MODE (cmp_b)))\n-    {\n-      if (!have_cbranchcc4\n-\t  || GET_MODE_CLASS (GET_MODE (cmp_a)) != MODE_CC\n-\t  || cmp_b != const0_rtx)\n-\treturn NULL_RTX;\n-    }\n-\n   unsignedp = (code == LTU || code == GEU\n \t       || code == LEU || code == GTU);\n \n-  target = emit_conditional_move (x, code, cmp_a, cmp_b, VOIDmode,\n-\t\t\t\t  vtrue, vfalse, GET_MODE (x),\n-\t\t\t\t  unsignedp);\n+  if (cc_cmp != NULL_RTX && rev_cc_cmp != NULL_RTX)\n+    target = emit_conditional_move (x, cc_cmp, rev_cc_cmp,\n+\t\t\t\t    vtrue, vfalse, GET_MODE (x));\n+  else\n+    {\n+      /* Don't even try if the comparison operands are weird\n+\t except that the target supports cbranchcc4.  */\n+      if (! general_operand (cmp_a, GET_MODE (cmp_a))\n+\t  || ! general_operand (cmp_b, GET_MODE (cmp_b)))\n+\t{\n+\t  if (!have_cbranchcc4\n+\t      || GET_MODE_CLASS (GET_MODE (cmp_a)) != MODE_CC\n+\t      || cmp_b != const0_rtx)\n+\t    return NULL_RTX;\n+\t}\n+\n+      target = emit_conditional_move (x, { code, cmp_a, cmp_b, VOIDmode },\n+\t\t\t\t      vtrue, vfalse, GET_MODE (x),\n+\t\t\t\t      unsignedp);\n+    }\n+\n   if (target)\n     return target;\n \n@@ -1795,8 +1803,9 @@ noce_emit_cmove (struct noce_if_info *if_info, rtx x, enum rtx_code code,\n \n       promoted_target = gen_reg_rtx (GET_MODE (reg_vtrue));\n \n-      target = emit_conditional_move (promoted_target, code, cmp_a, cmp_b,\n-\t\t\t\t      VOIDmode, reg_vtrue, reg_vfalse,\n+      target = emit_conditional_move (promoted_target,\n+\t\t\t\t      { code, cmp_a, cmp_b, VOIDmode },\n+\t\t\t\t      reg_vtrue, reg_vfalse,\n \t\t\t\t      GET_MODE (reg_vtrue), unsignedp);\n       /* Nope, couldn't do it in that mode either.  */\n       if (!target)"}, {"sha": "2486e1489609c1af5185f1452ef988ffe372336f", "filename": "gcc/optabs.cc", "status": "modified", "additions": 105, "deletions": 35, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Foptabs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Foptabs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.cc?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -52,6 +52,8 @@ static void prepare_float_lib_cmp (rtx, rtx, enum rtx_code, rtx *,\n static rtx expand_unop_direct (machine_mode, optab, rtx, rtx, int);\n static void emit_libcall_block_1 (rtx_insn *, rtx, rtx, rtx, bool);\n \n+static rtx emit_conditional_move_1 (rtx, rtx, rtx, rtx, machine_mode);\n+\n /* Debug facility for use in GDB.  */\n void debug_optab_libfuncs (void);\n \f\n@@ -624,12 +626,13 @@ expand_doubleword_shift_condmove (scalar_int_mode op1_mode, optab binoptab,\n \n   /* Select between them.  Do the INTO half first because INTO_SUPERWORD\n      might be the current value of OUTOF_TARGET.  */\n-  if (!emit_conditional_move (into_target, cmp_code, cmp1, cmp2, op1_mode,\n+  if (!emit_conditional_move (into_target, { cmp_code, cmp1, cmp2, op1_mode },\n \t\t\t      into_target, into_superword, word_mode, false))\n     return false;\n \n   if (outof_target != 0)\n-    if (!emit_conditional_move (outof_target, cmp_code, cmp1, cmp2, op1_mode,\n+    if (!emit_conditional_move (outof_target,\n+\t\t\t\t{ cmp_code, cmp1, cmp2, op1_mode },\n \t\t\t\toutof_target, outof_superword,\n \t\t\t\tword_mode, false))\n       return false;\n@@ -4851,8 +4854,8 @@ emit_indirect_jump (rtx loc)\n    is not supported.  */\n \n rtx\n-emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n-\t\t       machine_mode cmode, rtx op2, rtx op3,\n+emit_conditional_move (rtx target, struct rtx_comparison comp,\n+\t\t       rtx op2, rtx op3,\n \t\t       machine_mode mode, int unsignedp)\n {\n   rtx comparison;\n@@ -4874,31 +4877,33 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   /* If one operand is constant, make it the second one.  Only do this\n      if the other operand is not constant as well.  */\n \n-  if (swap_commutative_operands_p (op0, op1))\n+  if (swap_commutative_operands_p (comp.op0, comp.op1))\n     {\n-      std::swap (op0, op1);\n-      code = swap_condition (code);\n+      std::swap (comp.op0, comp.op1);\n+      comp.code = swap_condition (comp.code);\n     }\n \n   /* get_condition will prefer to generate LT and GT even if the old\n      comparison was against zero, so undo that canonicalization here since\n      comparisons against zero are cheaper.  */\n-  if (code == LT && op1 == const1_rtx)\n-    code = LE, op1 = const0_rtx;\n-  else if (code == GT && op1 == constm1_rtx)\n-    code = GE, op1 = const0_rtx;\n \n-  if (cmode == VOIDmode)\n-    cmode = GET_MODE (op0);\n+  if (comp.code == LT && comp.op1 == const1_rtx)\n+    comp.code = LE, comp.op1 = const0_rtx;\n+  else if (comp.code == GT && comp.op1 == constm1_rtx)\n+    comp.code = GE, comp.op1 = const0_rtx;\n \n-  enum rtx_code orig_code = code;\n+  if (comp.mode == VOIDmode)\n+    comp.mode = GET_MODE (comp.op0);\n+\n+  enum rtx_code orig_code = comp.code;\n   bool swapped = false;\n   if (swap_commutative_operands_p (op2, op3)\n-      && ((reversed = reversed_comparison_code_parts (code, op0, op1, NULL))\n-          != UNKNOWN))\n+      && ((reversed =\n+\t   reversed_comparison_code_parts (comp.code, comp.op0, comp.op1, NULL))\n+\t  != UNKNOWN))\n     {\n       std::swap (op2, op3);\n-      code = reversed;\n+      comp.code = reversed;\n       swapped = true;\n     }\n \n@@ -4915,8 +4920,10 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \n   for (int pass = 0; ; pass++)\n     {\n-      code = unsignedp ? unsigned_condition (code) : code;\n-      comparison = simplify_gen_relational (code, VOIDmode, cmode, op0, op1);\n+      comp.code = unsignedp ? unsigned_condition (comp.code) : comp.code;\n+      comparison =\n+\tsimplify_gen_relational (comp.code, VOIDmode,\n+\t\t\t\t comp.mode, comp.op0, comp.op1);\n \n       /* We can get const0_rtx or const_true_rtx in some circumstances.  Just\n \t punt and let the caller figure out how best to deal with this\n@@ -4927,24 +4934,16 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t  save_pending_stack_adjust (&save);\n \t  last = get_last_insn ();\n \t  do_pending_stack_adjust ();\n-\t  machine_mode cmpmode = cmode;\n+\t  machine_mode cmpmode = comp.mode;\n \t  prepare_cmp_insn (XEXP (comparison, 0), XEXP (comparison, 1),\n \t\t\t    GET_CODE (comparison), NULL_RTX, unsignedp,\n \t\t\t    OPTAB_WIDEN, &comparison, &cmpmode);\n \t  if (comparison)\n \t    {\n-\t      class expand_operand ops[4];\n-\n-\t      create_output_operand (&ops[0], target, mode);\n-\t      create_fixed_operand (&ops[1], comparison);\n-\t      create_input_operand (&ops[2], op2, mode);\n-\t      create_input_operand (&ops[3], op3, mode);\n-\t      if (maybe_expand_insn (icode, 4, ops))\n-\t\t{\n-\t\t  if (ops[0].value != target)\n-\t\t    convert_move (target, ops[0].value, false);\n-\t\t  return target;\n-\t\t}\n+\t       rtx res = emit_conditional_move_1 (target, comparison,\n+\t\t\t\t\t\t  op2, op3, mode);\n+\t       if (res != NULL_RTX)\n+\t\t return res;\n \t    }\n \t  delete_insns_since (last);\n \t  restore_pending_stack_adjust (&save);\n@@ -4956,17 +4955,88 @@ emit_conditional_move (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       /* If the preferred op2/op3 order is not usable, retry with other\n \t operand order, perhaps it will expand successfully.  */\n       if (swapped)\n-\tcode = orig_code;\n-      else if ((reversed = reversed_comparison_code_parts (orig_code, op0, op1,\n+\tcomp.code = orig_code;\n+      else if ((reversed =\n+\t\treversed_comparison_code_parts (orig_code, comp.op0, comp.op1,\n \t\t\t\t\t\t\t   NULL))\n \t       != UNKNOWN)\n-\tcode = reversed;\n+\tcomp.code = reversed;\n       else\n \treturn NULL_RTX;\n       std::swap (op2, op3);\n     }\n }\n \n+/* Helper function that, in addition to COMPARISON, also tries\n+   the reversed REV_COMPARISON with swapped OP2 and OP3.  As opposed\n+   to when we pass the specific constituents of a comparison, no\n+   additional insns are emitted for it.  It might still be necessary\n+   to emit more than one insn for the final conditional move, though.  */\n+\n+rtx\n+emit_conditional_move (rtx target, rtx comparison, rtx rev_comparison,\n+\t\t       rtx op2, rtx op3, machine_mode mode)\n+{\n+  rtx res = emit_conditional_move_1 (target, comparison, op2, op3, mode);\n+\n+  if (res != NULL_RTX)\n+    return res;\n+\n+  return emit_conditional_move_1 (target, rev_comparison, op3, op2, mode);\n+}\n+\n+/* Helper for emitting a conditional move.  */\n+\n+static rtx\n+emit_conditional_move_1 (rtx target, rtx comparison,\n+\t\t\t rtx op2, rtx op3, machine_mode mode)\n+{\n+  enum insn_code icode;\n+\n+  if (comparison == NULL_RTX || !COMPARISON_P (comparison))\n+    return NULL_RTX;\n+\n+  /* If the two source operands are identical, that's just a move.\n+     As the comparison comes in non-canonicalized, we must make\n+     sure not to discard any possible side effects.  If there are\n+     side effects, just let the target handle it.  */\n+  if (!side_effects_p (comparison) && rtx_equal_p (op2, op3))\n+    {\n+      if (!target)\n+\ttarget = gen_reg_rtx (mode);\n+\n+      emit_move_insn (target, op3);\n+      return target;\n+    }\n+\n+  if (mode == VOIDmode)\n+    mode = GET_MODE (op2);\n+\n+  icode = direct_optab_handler (movcc_optab, mode);\n+\n+  if (icode == CODE_FOR_nothing)\n+    return NULL_RTX;\n+\n+  if (!target)\n+    target = gen_reg_rtx (mode);\n+\n+  class expand_operand ops[4];\n+\n+  create_output_operand (&ops[0], target, mode);\n+  create_fixed_operand (&ops[1], comparison);\n+  create_input_operand (&ops[2], op2, mode);\n+  create_input_operand (&ops[3], op3, mode);\n+\n+  if (maybe_expand_insn (icode, 4, ops))\n+    {\n+      if (ops[0].value != target)\n+\tconvert_move (target, ops[0].value, false);\n+      return target;\n+    }\n+\n+  return NULL_RTX;\n+}\n+\n \n /* Emit a conditional negate or bitwise complement using the\n    negcc or notcc optabs if available.  Return NULL_RTX if such operations"}, {"sha": "cfd7c742d2d21b0539f5227c22a94f32c793d6f7", "filename": "gcc/optabs.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -279,8 +279,8 @@ extern void emit_indirect_jump (rtx);\n #endif\n \n /* Emit a conditional move operation.  */\n-rtx emit_conditional_move (rtx, enum rtx_code, rtx, rtx, machine_mode,\n-\t\t\t   rtx, rtx, machine_mode, int);\n+rtx emit_conditional_move (rtx, rtx_comparison, rtx, rtx, machine_mode, int);\n+rtx emit_conditional_move (rtx, rtx, rtx, rtx, rtx, machine_mode);\n \n /* Emit a conditional negate or bitwise complement operation.  */\n rtx emit_conditional_neg_or_complement (rtx, rtx_code, machine_mode, rtx,"}, {"sha": "9df2fab622e76ff5869eefcc7044f1f3b2f36b63", "filename": "gcc/rtl.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9ebb86799fd77cdd5351078230c114a90e66066/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=e9ebb86799fd77cdd5351078230c114a90e66066", "patch": "@@ -4604,7 +4604,16 @@ word_register_operation_p (const_rtx x)\n       return true;\n     }\n }\n-    \n+\n+/* Holds an rtx comparison to simplify passing many parameters pertaining to a\n+   single comparison.  */\n+\n+struct rtx_comparison {\n+  rtx_code code;\n+  rtx op0, op1;\n+  machine_mode mode;\n+};\n+\n /* gtype-desc.cc.  */\n extern void gt_ggc_mx (rtx &);\n extern void gt_pch_nx (rtx &);"}]}