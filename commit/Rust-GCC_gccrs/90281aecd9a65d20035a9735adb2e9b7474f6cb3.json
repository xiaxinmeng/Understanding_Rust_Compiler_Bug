{"sha": "90281aecd9a65d20035a9735adb2e9b7474f6cb3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTAyODFhZWNkOWE2NWQyMDAzNWE5NzM1YWRiMmU5Yjc0NzRmNmNiMw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2003-08-05T18:47:22Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2003-08-05T18:47:22Z"}, "message": "re PR java/11600 (CloneNotSupportedException not checked on super.clone())\n\n\tFix for PR java/11600:\n\t* parse.y (java_complete_lhs): See whether we're calling a method\n\ton an array.\n\t(check_thrown_exceptions): Added `is_array_call' argument;\n\tfixed `clone' checking; updated all callers.\n\nFrom-SVN: r70180", "tree": {"sha": "df2638959614126fd76b4f355a2b9c653fb6cfc6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df2638959614126fd76b4f355a2b9c653fb6cfc6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90281aecd9a65d20035a9735adb2e9b7474f6cb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90281aecd9a65d20035a9735adb2e9b7474f6cb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90281aecd9a65d20035a9735adb2e9b7474f6cb3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90281aecd9a65d20035a9735adb2e9b7474f6cb3/comments", "author": null, "committer": null, "parents": [{"sha": "8c98b17033b30e7cef3d91dea44f85b52140d06c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c98b17033b30e7cef3d91dea44f85b52140d06c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c98b17033b30e7cef3d91dea44f85b52140d06c"}], "stats": {"total": 49, "additions": 38, "deletions": 11}, "files": [{"sha": "0d6578ceaed006679b0f882e54203e5d8ea883e7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90281aecd9a65d20035a9735adb2e9b7474f6cb3/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90281aecd9a65d20035a9735adb2e9b7474f6cb3/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=90281aecd9a65d20035a9735adb2e9b7474f6cb3", "patch": "@@ -1,3 +1,11 @@\n+2003-08-05  Tom Tromey  <tromey@redhat.com>\n+\n+\tFix for PR java/11600:\n+\t* parse.y (java_complete_lhs): See whether we're calling a method\n+\ton an array.\n+\t(check_thrown_exceptions): Added `is_array_call' argument;\n+\tfixed `clone' checking; updated all callers.\n+\n 2003-08-05  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* java-tree.h (DECL_ESTIMATED_INSNS): Remove (moved to tree.h)."}, {"sha": "6ca734aa68465da3206726e144d884f527e05e71", "filename": "gcc/java/parse.y", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90281aecd9a65d20035a9735adb2e9b7474f6cb3/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90281aecd9a65d20035a9735adb2e9b7474f6cb3/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=90281aecd9a65d20035a9735adb2e9b7474f6cb3", "patch": "@@ -220,7 +220,7 @@ static tree build_try_finally_statement (int, tree, tree);\n static tree patch_try_statement (tree);\n static tree patch_synchronized_statement (tree, tree);\n static tree patch_throw_statement (tree, tree);\n-static void check_thrown_exceptions (int, tree);\n+static void check_thrown_exceptions (int, tree, tree);\n static int check_thrown_exceptions_do (tree);\n static void purge_unchecked_exceptions (tree);\n static bool ctors_unchecked_throws_clause_p (tree);\n@@ -9454,7 +9454,13 @@ resolve_qualified_expression_name (tree wfl, tree *found_decl,\n \t  if (location\n \t      && !OUTER_FIELD_ACCESS_IDENTIFIER_P\n \t            (DECL_NAME (current_function_decl)))\n-\t    check_thrown_exceptions (location, ret_decl);\n+\t    {\n+\t      tree arguments = NULL_TREE;\n+\t      if (TREE_CODE (qual_wfl) == CALL_EXPR\n+\t\t  && TREE_OPERAND (qual_wfl, 1) != NULL_TREE)\n+\t\targuments = TREE_VALUE (TREE_OPERAND (qual_wfl, 1));\n+\t      check_thrown_exceptions (location, ret_decl, arguments);\n+\t    }\n \n \t  /* If the previous call was static and this one is too,\n \t     build a compound expression to hold the two (because in\n@@ -11897,13 +11903,20 @@ java_complete_lhs (tree node)\n \t  int in_this = CALL_THIS_CONSTRUCTOR_P (node);\n \t  int from_super = (EXPR_WFL_NODE (TREE_OPERAND (node, 0)) ==\n                            super_identifier_node);\n+\t  tree arguments;\n \n \t  node = patch_method_invocation (node, NULL_TREE, NULL_TREE,\n \t\t\t\t\t  from_super, 0, &decl);\n \t  if (node == error_mark_node)\n \t    return error_mark_node;\n \n-\t  check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl);\n+\t  if (TREE_CODE (node) == CALL_EXPR\n+\t      && TREE_OPERAND (node, 1) != NULL_TREE)\n+\t    arguments = TREE_VALUE (TREE_OPERAND (node, 1));\n+\t  else\n+\t    arguments = NULL_TREE;\n+\t  check_thrown_exceptions (EXPR_WFL_LINECOL (node), decl,\n+\t\t\t\t   arguments);\n \t  /* If we call this(...), register signature and positions */\n \t  if (in_this)\n \t    DECL_CONSTRUCTOR_CALLS (current_function_decl) =\n@@ -15621,22 +15634,28 @@ patch_throw_statement (tree node, tree wfl_op1)\n }\n \n /* Check that exception said to be thrown by method DECL can be\n-   effectively caught from where DECL is invoked.  */\n-\n+   effectively caught from where DECL is invoked.  THIS_EXPR is the\n+   expression that computes `this' for the method call.  */\n static void\n-check_thrown_exceptions (int location, tree decl)\n+check_thrown_exceptions (int location, tree decl, tree this_expr)\n {\n   tree throws;\n-  /* For all the unchecked exceptions thrown by DECL */\n+  int is_array_call = 0;\n+\n+  if (this_expr != NULL_TREE\n+      && TREE_CODE (TREE_TYPE (this_expr)) == POINTER_TYPE\n+      && TYPE_ARRAY_P (TREE_TYPE (TREE_TYPE (this_expr))))\n+    is_array_call = 1;\n+\n+  /* For all the unchecked exceptions thrown by DECL.  */\n   for (throws = DECL_FUNCTION_THROWS (decl); throws;\n        throws = TREE_CHAIN (throws))\n     if (!check_thrown_exceptions_do (TREE_VALUE (throws)))\n       {\n-#if 1\n-\t/* Temporary hack to suppresses errors about cloning arrays. FIXME */\n-\tif (DECL_NAME (decl) == get_identifier (\"clone\"))\n+\t/* Suppress errors about cloning arrays.  */\n+\tif (is_array_call && DECL_NAME (decl) == get_identifier (\"clone\"))\n \t  continue;\n-#endif\n+\n \tEXPR_WFL_LINECOL (wfl_operator) = location;\n \tif (DECL_FINIT_P (current_function_decl))\n \t  parse_error_context"}]}