{"sha": "9d85d30c20219b6ae3657c1ede69d7634aaad96f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ4NWQzMGMyMDIxOWI2YWUzNjU3YzFlZGU2OWQ3NjM0YWFhZDk2Zg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-14T00:50:07Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-14T00:50:07Z"}, "message": "cp-tree.h (build_target_expr): New function.\n\n\t* cp-tree.h (build_target_expr): New function.\n\t* call.c (build_conditional_expr): Use build_target_expr.\n\t(convert_like): Likewise.\n\t(build_over_call): Likewise.\n\t* cvt.c (build_up_reference): Likewise.\n\t* decl.c (build_cleanup_on_safe_obstack): Fold into ...\n\t(destroy_local_var): Here.\n\t(build_target_expr): New function.\n\t* tree.c (build_cplus_new): Use it.\n\t(get_target_expr): Likewise.\n\nFrom-SVN: r29387", "tree": {"sha": "97bd8c075857082bc219cc0d37fcbe7355d0e004", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97bd8c075857082bc219cc0d37fcbe7355d0e004"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d85d30c20219b6ae3657c1ede69d7634aaad96f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d85d30c20219b6ae3657c1ede69d7634aaad96f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d85d30c20219b6ae3657c1ede69d7634aaad96f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d85d30c20219b6ae3657c1ede69d7634aaad96f/comments", "author": null, "committer": null, "parents": [{"sha": "88731f16b0cbe3c5c4cc151a39c5f4fcc8523c77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88731f16b0cbe3c5c4cc151a39c5f4fcc8523c77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88731f16b0cbe3c5c4cc151a39c5f4fcc8523c77"}], "stats": {"total": 103, "additions": 51, "deletions": 52}, "files": [{"sha": "4a33e63c447c310748094f4cc80a38ec2953ed92", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -1,3 +1,16 @@\n+1999-09-13  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (build_target_expr): New function.\n+\t* call.c (build_conditional_expr): Use build_target_expr.\n+\t(convert_like): Likewise.\n+\t(build_over_call): Likewise.\n+\t* cvt.c (build_up_reference): Likewise.\n+\t* decl.c (build_cleanup_on_safe_obstack): Fold into ...\n+\t(destroy_local_var): Here.\n+\t(build_target_expr): New function.\n+\t* tree.c (build_cplus_new): Use it.\n+\t(get_target_expr): Likewise.\n+\n 1999-09-13  Nathan Sidwell  <nathan@acm.org>\n \n \t* typeck.c (expr_sizeof): Don't decay arrays and functions."}, {"sha": "bce17412eab0681985c117b0e70c8fe7bbf1fd75", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -3080,8 +3080,7 @@ build_conditional_expr (arg1, arg2, arg3)\n     {\n       tree slot = build (VAR_DECL, result_type);\n       layout_decl (slot, 0);\n-      result = build (TARGET_EXPR, result_type,\n-\t\t      slot, result, NULL_TREE, NULL_TREE);\n+      result = build_target_expr (slot, result);\n     }\n   \n   /* If this expression is an rvalue, but might be mistaken for an\n@@ -3749,8 +3748,7 @@ convert_like (convs, expr)\n \t    tree type = TREE_TYPE (TREE_OPERAND (convs, 0));\n \t    tree slot = build_decl (VAR_DECL, NULL_TREE, type);\n \t    DECL_ARTIFICIAL (slot) = 1;\n-\t    expr = build (TARGET_EXPR, type, slot, expr,\n-\t\t\t  NULL_TREE, NULL_TREE);\n+\t    expr = build_target_expr (slot, expr);\n \t    TREE_SIDE_EFFECTS (expr) = 1;\n \t  }\n \n@@ -4039,7 +4037,7 @@ build_over_call (cand, args, flags)\n \t  else if (TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t    {\n \t      val = build_decl (VAR_DECL, NULL_TREE, DECL_CONTEXT (fn));\n-\t      val = build (TARGET_EXPR, DECL_CONTEXT (fn), val, arg, 0, 0);\n+\t      val = build_target_expr (val, arg);\n \t      TREE_SIDE_EFFECTS (val) = 1;\n \t      return val;\n \t    }"}, {"sha": "8c587cb01407bc3fdf9eb66fefabb69c1e564c57", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -3247,6 +3247,7 @@ extern tree cp_namespace_decls                  PROTO((tree));\n extern tree create_implicit_typedef             PROTO((tree, tree));\n extern tree maybe_push_decl                     PROTO((tree));\n extern void emit_local_var                      PROTO((tree));\n+extern tree build_target_expr                   PROTO((tree, tree));\n \n /* in decl2.c */\n extern void init_decl2\t\t\t\tPROTO((void));"}, {"sha": "d1bdb2e83f8aaf43a2cf0eb8e211568a5b70386d", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -364,7 +364,7 @@ build_up_reference (type, arg, flags)\n     {\n       tree slot = build_decl (VAR_DECL, NULL_TREE, argtype);\n       DECL_ARTIFICIAL (slot) = 1;\n-      arg = build (TARGET_EXPR, argtype, slot, arg, NULL_TREE, NULL_TREE);\n+      arg = build_target_expr (slot, arg);\n       TREE_SIDE_EFFECTS (arg) = 1;\n     }\n "}, {"sha": "af4bf137aa8875a3dc3ad74e5cbdf3c0490757c8", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 31, "deletions": 43, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -169,7 +169,6 @@ static void pop_labels PROTO((tree));\n static void maybe_deduce_size_from_array_init PROTO((tree, tree));\n static tree layout_var_decl PROTO((tree, tree));\n static void maybe_commonize_var PROTO((tree));\n-static tree build_cleanup_on_safe_obstack PROTO((tree));\n static tree check_initializer PROTO((tree, tree));\n static void make_rtl_for_nonlocal_decl PROTO((tree, tree, const char *));\n static void push_cp_function_context PROTO((struct function *));\n@@ -7121,47 +7120,6 @@ layout_var_decl (decl, init)\n   return init;\n }\n \n-/* Return a cleanup for DECL, created on whatever obstack is\n-   appropriate.  */\n-\n-static tree\n-build_cleanup_on_safe_obstack (decl)\n-     tree decl;\n-{\n-  tree cleanup;\n-  tree type;\n-  int need_pop;\n-\n-  type = TREE_TYPE (decl);\n-\n-  /* Only variables get cleaned up.  */\n-  if (TREE_CODE (decl) != VAR_DECL)\n-    return NULL_TREE;\n-  \n-  /* And only things with destructors need cleaning up.  */\n-  if (!TYPE_NEEDS_DESTRUCTOR (type))\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (decl) == VAR_DECL &&\n-      (DECL_EXTERNAL (decl) || TREE_STATIC (decl)))\n-    /* We don't clean up things that aren't defined in this\n-       translation unit, or that need a static cleanup.  The latter\n-       are handled by finish_file.  */\n-    return NULL_TREE;\n-  \n-  /* Switch to an obstack that will live until the point where the\n-     cleanup code is actually expanded.  */\n-  need_pop = suspend_momentary ();\n-\n-  /* Compute the cleanup.  */\n-  cleanup = maybe_build_cleanup (decl);\n-\n-  /* Pop back to the obstack we were on before.  */\n-  resume_momentary (need_pop);\n-  \n-  return cleanup;\n-}\n-\n /* If a local static variable is declared in an inline function, or if\n    we have a weak definition, we must endeavor to create only one\n    instance of the variable at link-time.  */\n@@ -7557,7 +7515,26 @@ void\n destroy_local_var (decl)\n      tree decl;\n {\n-  tree cleanup = build_cleanup_on_safe_obstack (decl);\n+  tree type = TREE_TYPE (decl);\n+  tree cleanup;\n+\n+  /* Only variables get cleaned up.  */\n+  if (TREE_CODE (decl) != VAR_DECL)\n+    return;\n+  \n+  /* And only things with destructors need cleaning up.  */\n+  if (!TYPE_NEEDS_DESTRUCTOR (type))\n+    return;\n+\n+  if (TREE_CODE (decl) == VAR_DECL &&\n+      (DECL_EXTERNAL (decl) || TREE_STATIC (decl)))\n+    /* We don't clean up things that aren't defined in this\n+       translation unit, or that need a static cleanup.  The latter\n+       are handled by finish_file.  */\n+    return;\n+  \n+  /* Compute the cleanup.  */\n+  cleanup = maybe_build_cleanup (decl);\n \n   /* Record the cleanup required for this declaration.  */\n   if (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node\n@@ -14143,6 +14120,17 @@ maybe_build_cleanup_1 (decl, auto_delete)\n   return 0;\n }\n \n+/* Build a TARGET_EXPR, initializing the DECL with the VALUE.  */\n+\n+tree\n+build_target_expr (decl, value)\n+     tree decl;\n+     tree value;\n+{\n+  return build (TARGET_EXPR, TREE_TYPE (decl), decl, value, \n+\t\tmaybe_build_cleanup (decl), NULL_TREE);\n+}\n+\n /* If DECL is of a type which needs a cleanup, build that cleanup\n    here.  The cleanup does free the storage with a call to delete.  */\n "}, {"sha": "f0f014119d1eaf44a9263b166db7ef7582b04d2c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d85d30c20219b6ae3657c1ede69d7634aaad96f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=9d85d30c20219b6ae3657c1ede69d7634aaad96f", "patch": "@@ -251,7 +251,7 @@ build_cplus_new (type, init)\n     = (TREE_CODE (fn) == ADDR_EXPR\n        && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n        && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0)));\n-  rval = build (TARGET_EXPR, type, slot, rval, NULL_TREE, NULL_TREE);\n+  rval = build_target_expr (slot, rval);\n   TREE_SIDE_EFFECTS (rval) = 1;\n \n   return rval;\n@@ -269,8 +269,7 @@ get_target_expr (init)\n   slot = build (VAR_DECL, TREE_TYPE (init));\n   DECL_ARTIFICIAL (slot) = 1;\n   layout_decl (slot, 0);\n-  rval = build (TARGET_EXPR, TREE_TYPE (init), slot, init,\n-\t\tNULL_TREE, NULL_TREE);\n+  rval = build_target_expr (slot, init);\n   TREE_SIDE_EFFECTS (rval) = 1;\n \n   return rval;"}]}