{"sha": "4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE5MGFlZWI1MTQzOGFmOWYzMWNmNTdjY2JiYTZmZGQ3YzMzMTM5OA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-15T15:45:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-08-15T15:45:33Z"}, "message": "tree.h (build_int_cst): New.\n\n.:\t* tree.h (build_int_cst): New.\n\t(build_int_2): Remove.\n\t* tree.c (build_int_2): Remove.\n\t(build_int_cst): New.\n\t(make_vector_type, build_common_tree_nodes,\n\tbuild_common_tree_nodes_2): Use build_int_cst.\n\t* builtins.c (expand_builtin_prefetch, expand_builtin_strstr,\n\texpand_builtin_strpbrk, expand_builtin_fputs,\n\tbuild_string_literal, expand_builtin_printf,\n\texpand_builtin_sprintf, fold_builtin_lround, fold_builtin_bitop,\n\tfold_builtin_bitop, fold_builtin_isascii, fold_builtin_toascii,\n\tfold_builtin_isdigit, simplify_builtin_strstr,\n\tsimplify_builtin_strpbrk, fold_builtin_fputs,\n\tsimplify_builtin_sprintf): Use build_int_cst.\n\t* c-common.c (start_fname_decls, fix_string_type,\n\tc_common_nodes_and_builtins, c_init_attributes,\n\tshorten_compare): Likewise.\n\t* c-decl.c (complete_array_type,\n\tcheck_bitfield_type_and_width): Likewise.\n\t* c-lex.c (interpret_integer, lex_charconst): Likewise.\n\t* c-parse.in (primary): <TYPES_COMPATIBLE_P> Likewise.\n\t* c-pretty-print.c (pp_c_integer_constant): Likewise.\n\t* c-typeck.c (really_start_incremental_init, push_init_level,\n\tset_nonincremental_init_from_string): Likewise.\n\t* calls.c (load_register_parameters): Likewise.\n\t* convert.c (convert_to_pointer): Likewise.\n\t* coverage.c (coverage_counter_alloc, tree_coverage_counter_ref,\n\tbuild_fn_info_type, build_ctr_info_value, build_gcov_info):\n\tLikewise.\n\t* except.c (init_eh, assign_filter_values, assign_filter_values):\n\tLikewise.\n\t* expmed.c (store_fixed_bit_field, extract_bit_field,\n\textract_fixed_bit_field, extract_split_bit_field, expand_shift,\n\texpand_mult_const, expand_mult_highpart_adjust, extract_high_half,\n\texpand_sdiv_pow2, expand_divmod, make_tree): Likewise.\n\t* expr.c (convert_move, emit_group_load, emit_group_store,\n\texpand_assignment, store_constructor, store_field,\n\texpand_expr_real_1, reduce_to_bit_field_precision): Likewise.\n\t* fold-const.c (force_fit_type, int_const_binop, fold_convert_const,\n\tinvert_truthvalue, optimize_bit_field_compare,\n\tdecode_field_reference, all_ones_mask_p, constant_boolean_node,\n\tfold_div_compare, fold, fold_read_from_constant_string,\n\tfold_negate_const, fold_abs_const, fold_not_const): Likewise.\n\t* function.c (assign_parm_setup_block): Likewise.\n\t* stmt.c (shift_return_value, expand_end_case_type,\n\testimate_case_costs): Likewise.\n\t* stor-layout.c (layout_type, initialize_sizetypes,\n\tset_min_and_max_values_for_integral_type): Likewise.\n\t* tree-chrec.c (chrec_fold_multiply_poly_poly,\n\treset_evolution_in_loop): Likewise.\n\t* tree-chrec.h (build_polynomial_chrec): Likewise.\n\t* tree-complex.c (build_replicated_const): Likewise.\n\t* tree-eh.c (honor_protect_cleanup_actions,\n\tlower_try_finally_onedest, lower_try_finally_copy,\n\tlower_try_finally_switch): Likewise.\n\t* tree-mudflap.c (mf_build_string, mx_register_decls,\n\tmudflap_register_call, mudflap_enqueue_constant): Likewise.\n\t* tree-nested.c (get_trampoline_type, get_nl_goto_field): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t* tree-ssa-ccp.c (widen_bitfield, maybe_fold_offset_to_array_ref):\n\tLikewise.\n\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Likewise.\n\t* tree-ssa-loop-niter.c (number_of_iterations_cond,\n\tloop_niter_by_eval, upper_bound_in_type, lower_bound_in_type):\n\tLikewise.\n\n\t* config/alpha/alpha.c (alpha_initialize_trampoline,\n\talpha_va_start, alpha_gimplify_va_arg_1): Use build_int_cst.\n\t* config/arm/arm.c (arm_get_cookie_size): Likewise.\n\t* config/c4x/c4x.c (c4x_gimplify_va_arg_expr): Likewise.\n\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n\t* config/i860/i860.c (i860_va_start): Likewise.\n\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Likewise.\n\t* config/mips/mips.c (mips_build_builtin_va_list, mips_va_start,\n\tmips_gimplify_va_arg_expr): Likewise.\n\t* config/pa/pa.c (hppa_gimplify_va_arg_expr): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg,\n\tadd_compiler_branch_island): Likewise.\n\t* config/s390/s390.c (s390_va_start): Likewise.\n\t* config/sh/sh.c (sh_va_start): Likewise.\n\t* config/stormy16/stormy16.c (xstormy16_expand_builtin_va_start):\n\tLikewise.\n\t* config/xtensa/xtensa.c (xtensa_va_start,\n\txtensa_gimplify_va_arg_expr): Likewise.\n\n\t* objc/objc-act.c (build_objc_string_object,\n\tbuild_objc_symtab_template, init_def_list, init_objc_symtab,\n\tinit_module_descriptor, generate_static_references,\n\tbuild_selector_translation_table, get_proto_encoding,\n\tbuild_typed_selector_reference, build_selector_reference,\n\tbuild_next_objc_exception_stuff,\n\tbuild_method_prototype_list_template, generate_descriptor_table,\n\tgenerate_protocols, build_protocol_initializer,\n\tbuild_ivar_list_template, build_method_list_template,\n\tbuild_ivar_list_initializer, generate_ivars_list,\n\tgenerate_dispatch_table, generate_protocol_list,\n\tbuild_category_initializer, build_shared_structure_initializer,\n\tgenerate_shared_structures, handle_impent,\n\tgenerate_objc_image_info): Use build_int_cst.\nada:\n\t* cuintp.c (UI_To_gnu): Use build_int_cst..\n\t* trans.c (Exception_Handler_to_gnu_sjlj, gnat_to_gnu): Likewise.\n\t* utils.c (init_gigi_decls): Likewise.\n\t* utils2.c (build_call_raise): Likewise.\ncp:\n\t* call.c (convert_class_to_reference,\n\tbuild_user_type_conversion_1, convert_like_real,\n\tbuild_java_interface_fn_ref, build_special_member_call): Use\n\tbuild_int_cst.\n\t* class.c (build_vtbl_initializer): Likewise.\n\t* cp-gimplify.c (cp_gimplify_expr): Likewise.\n\t* cvt.c (cp_convert_to_pointer): Likewise.\n\t* decl.c (cxx_init_decl_processing, complete_array_type): Likewise.\n\t* decl2.c (start_static_initialization_or_destruction,\n\tgenerate_ctor_or_dtor_function): Likewise.\n\t* except.c (build_throw): Likewise.\n\t* lex.c (cxx_init): Likewise.\n\t* mangle.c (write_integer_cst): Likewise.\n\t* rtti.c (build_headof, get_tinfo_decl_dynamic,\n\tbuild_dynamic_cast_1, ptr_initializer, ptm_initializer,\n\tget_pseudo_ti_init): Likewise.\n\t* search.c (get_dynamic_cast_base_type): Likewise.\n\t* tree.c (build_shared_int_cst): Likewise.\nfortran:\n\t* trans-array.c (gfc_trans_array_constructor_value): Use\n\tbuild_int_cst.\n\t* trans-const.c (gfc_build_string_const,\n\tgfc_init_constants, gfc_conv_mpz_to_tree,\n\tgfc_conv_constant_to_tree): Likewise.\n\t* trans-decl.c (gfc_get_symbol_decl): Likewise.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_ibits,\n\tgfc_conv_intrinsic_len, prepare_arg_info): Likewise.\n\t* trans-io.c (add_case, set_error_locus, build_dt,\n\ttransfer_expr): Likewise.\n\t* trans-stmt.c (gfc_trans_label_assign, gfc_trans_pause,\n\tgfc_trans_stop, gfc_trans_character_select): Likewise.\n\t* trans-types.c (gfc_init_types, gfc_get_dtype): Likewise.\n\t* trans.c (gfc_trans_runtime_check): Likewise.\njava:\n\t* boehm.c (get_boehm_type_descriptor): Use build_int_cst.\n\t* class.c (build_utf8_ref, build_static_field_ref,\n\tmake_field_value, make_method_value, get_dispatch_table,\n\tmake_class_data, emit_symbol_table, emit_catch_table): Likewise.\n\t* constants.c (get_tag_node,  build_ref_from_constant_pool,\n\tbuild_constants_constructor): Likewise.\n\t* decl.c (java_init_decl_processing): Likewise.\n\t* expr.c (build_java_array_length_access, build_newarray,\n\texpand_java_multianewarray, expand_java_pushc, expand_iinc,\n\tbuild_java_binop, build_field_ref, expand_java_add_case,\n\texpand_java_call, build_known_method_ref, build_invokevirtual,\n\tbuild_invokeinterface, build_jni_stub): Likewise.\n\t* java-gimplify.c (java_gimplify_new_array_init): Likewise.\n\t* jcf-parse.c (get_constant): Likewise.\n\t* lex.c (do_java_lex): Likewise.\n\t* parse.y (patch_binop, patch_unaryop, patch_cast,\n\tbuild_null_of_type, patch_newarray): Likewise.\n\t* resource.c (compile_resource_data): Likewise.\n\t* typeck.c (build_prim_array_type): Likewise.\n\nFrom-SVN: r86022", "tree": {"sha": "40077b7dd50d472ee732b6ecf6d2b305f7b6da58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40077b7dd50d472ee732b6ecf6d2b305f7b6da58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/comments", "author": null, "committer": null, "parents": [{"sha": "2a68a7deaea5b282ebc2a505a6c7af912e3387a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a68a7deaea5b282ebc2a505a6c7af912e3387a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a68a7deaea5b282ebc2a505a6c7af912e3387a5"}], "stats": {"total": 1631, "additions": 922, "deletions": 709}, "files": [{"sha": "9f86e71688ddf0449fe40810bc3fa6c9ea88cd1c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,105 @@\n+2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* tree.h (build_int_cst): New.\n+\t(build_int_2): Remove.\n+\t* tree.c (build_int_2): Remove.\n+\t(build_int_cst): New.\n+\t(make_vector_type, build_common_tree_nodes,\n+\tbuild_common_tree_nodes_2): Use build_int_cst.\n+\t* builtins.c (expand_builtin_prefetch, expand_builtin_strstr,\n+\texpand_builtin_strpbrk, expand_builtin_fputs,\n+\tbuild_string_literal, expand_builtin_printf,\n+\texpand_builtin_sprintf, fold_builtin_lround, fold_builtin_bitop,\n+\tfold_builtin_bitop, fold_builtin_isascii, fold_builtin_toascii,\n+\tfold_builtin_isdigit, simplify_builtin_strstr,\n+\tsimplify_builtin_strpbrk, fold_builtin_fputs,\n+\tsimplify_builtin_sprintf): Use build_int_cst.\n+\t* c-common.c (start_fname_decls, fix_string_type,\n+\tc_common_nodes_and_builtins, c_init_attributes,\n+\tshorten_compare): Likewise.\n+\t* c-decl.c (complete_array_type,\n+\tcheck_bitfield_type_and_width): Likewise.\n+\t* c-lex.c (interpret_integer, lex_charconst): Likewise.\n+\t* c-parse.in (primary): <TYPES_COMPATIBLE_P> Likewise.\n+\t* c-pretty-print.c (pp_c_integer_constant): Likewise.\n+\t* c-typeck.c (really_start_incremental_init, push_init_level,\n+\tset_nonincremental_init_from_string): Likewise.\n+\t* calls.c (load_register_parameters): Likewise.\n+\t* convert.c (convert_to_pointer): Likewise.\n+\t* coverage.c (coverage_counter_alloc, tree_coverage_counter_ref,\n+\tbuild_fn_info_type, build_ctr_info_value, build_gcov_info):\n+\tLikewise.\n+\t* except.c (init_eh, assign_filter_values, assign_filter_values):\n+\tLikewise.\n+\t* expmed.c (store_fixed_bit_field, extract_bit_field,\n+\textract_fixed_bit_field, extract_split_bit_field, expand_shift,\n+\texpand_mult_const, expand_mult_highpart_adjust, extract_high_half,\n+\texpand_sdiv_pow2, expand_divmod, make_tree): Likewise.\n+\t* expr.c (convert_move, emit_group_load, emit_group_store,\n+\texpand_assignment, store_constructor, store_field,\n+\texpand_expr_real_1, reduce_to_bit_field_precision): Likewise.\n+\t* fold-const.c (force_fit_type, int_const_binop, fold_convert_const,\n+\tinvert_truthvalue, optimize_bit_field_compare,\n+\tdecode_field_reference, all_ones_mask_p, constant_boolean_node,\n+\tfold_div_compare, fold, fold_read_from_constant_string,\n+\tfold_negate_const, fold_abs_const, fold_not_const): Likewise.\n+\t* function.c (assign_parm_setup_block): Likewise.\n+\t* stmt.c (shift_return_value, expand_end_case_type,\n+\testimate_case_costs): Likewise.\n+\t* stor-layout.c (layout_type, initialize_sizetypes,\n+\tset_min_and_max_values_for_integral_type): Likewise.\n+\t* tree-chrec.c (chrec_fold_multiply_poly_poly,\n+\treset_evolution_in_loop): Likewise.\n+\t* tree-chrec.h (build_polynomial_chrec): Likewise.\n+\t* tree-complex.c (build_replicated_const): Likewise.\n+\t* tree-eh.c (honor_protect_cleanup_actions,\n+\tlower_try_finally_onedest, lower_try_finally_copy,\n+\tlower_try_finally_switch): Likewise.\n+\t* tree-mudflap.c (mf_build_string, mx_register_decls,\n+\tmudflap_register_call, mudflap_enqueue_constant): Likewise.\n+\t* tree-nested.c (get_trampoline_type, get_nl_goto_field): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t* tree-ssa-ccp.c (widen_bitfield, maybe_fold_offset_to_array_ref):\n+\tLikewise.\n+\t* tree-ssa-dom.c (simplify_rhs_and_lookup_avail_expr): Likewise.\n+\t* tree-ssa-loop-niter.c (number_of_iterations_cond,\n+\tloop_niter_by_eval, upper_bound_in_type, lower_bound_in_type):\n+\tLikewise.\n+\t\n+\t* config/alpha/alpha.c (alpha_initialize_trampoline,\n+\talpha_va_start, alpha_gimplify_va_arg_1): Use build_int_cst.\n+\t* config/arm/arm.c (arm_get_cookie_size): Likewise.\n+\t* config/c4x/c4x.c (c4x_gimplify_va_arg_expr): Likewise.\n+\t* config/i386/i386.c (ix86_va_start, ix86_gimplify_va_arg): Likewise.\n+\t* config/i860/i860.c (i860_va_start): Likewise.\n+\t* config/ia64/ia64.c (ia64_gimplify_va_arg): Likewise.\n+\t* config/mips/mips.c (mips_build_builtin_va_list, mips_va_start,\n+\tmips_gimplify_va_arg_expr): Likewise.\n+\t* config/pa/pa.c (hppa_gimplify_va_arg_expr): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_va_start, rs6000_gimplify_va_arg,\n+\tadd_compiler_branch_island): Likewise.\n+\t* config/s390/s390.c (s390_va_start): Likewise.\n+\t* config/sh/sh.c (sh_va_start): Likewise.\n+\t* config/stormy16/stormy16.c (xstormy16_expand_builtin_va_start):\n+\tLikewise.\n+\t* config/xtensa/xtensa.c (xtensa_va_start,\n+\txtensa_gimplify_va_arg_expr): Likewise.\n+\t\n+\t* objc/objc-act.c (build_objc_string_object,\n+\tbuild_objc_symtab_template, init_def_list, init_objc_symtab,\n+\tinit_module_descriptor, generate_static_references,\n+\tbuild_selector_translation_table, get_proto_encoding,\n+\tbuild_typed_selector_reference, build_selector_reference,\n+\tbuild_next_objc_exception_stuff,\n+\tbuild_method_prototype_list_template, generate_descriptor_table,\n+\tgenerate_protocols, build_protocol_initializer,\n+\tbuild_ivar_list_template, build_method_list_template,\n+\tbuild_ivar_list_initializer, generate_ivars_list,\n+\tgenerate_dispatch_table, generate_protocol_list,\n+\tbuild_category_initializer, build_shared_structure_initializer,\n+\tgenerate_shared_structures, handle_impent,\n+\tgenerate_objc_image_info): Use build_int_cst.\n+\n 2004-08-15  Ben Elliston  <bje@au.ibm.com>\n \n \t* vec.h: Comment improvements."}, {"sha": "63168471400c530c11e5197046f6d03d9cdf125c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,10 @@\n+2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* cuintp.c (UI_To_gnu): Use build_int_cst..\n+\t* trans.c (Exception_Handler_to_gnu_sjlj, gnat_to_gnu): Likewise.\n+\t* utils.c (init_gigi_decls): Likewise.\n+\t* utils2.c (build_call_raise): Likewise.\n+\n 2004-08-13  Olivier Hainque  <hainque@act-europe.fr>\n \n \t* decl.c (gnat_to_gnu_entity) <E_Variable>: When building an allocator"}, {"sha": "c0338afb5d9abe5fe8fba00cd08a88fc657e830d", "filename": "gcc/ada/cuintp.c", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcuintp.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -62,8 +62,10 @@ UI_To_gnu (Uint Input, tree type)\n   tree gnu_ret;\n \n   if (Input <= Uint_Direct_Last)\n-    gnu_ret = convert (type, build_int_2 (Input - Uint_Direct_Bias,\n-\t\t\t\t\t  Input < Uint_Direct_Bias ? -1 : 0));\n+    gnu_ret = convert (type, build_int_cst (NULL_TREE,\n+\t\t\t\t\t    Input - Uint_Direct_Bias,\n+\t\t\t\t\t    Input < Uint_Direct_Bias\n+\t\t\t\t\t    ? -1 : 0));\n   else\n     {\n       Int Idx =    Uints_Ptr[Input].Loc;\n@@ -74,26 +76,26 @@ UI_To_gnu (Uint Input, tree type)\n       tree comp_type\n \t= (TYPE_PRECISION (type) >= TYPE_PRECISION (integer_type_node)\n \t   ? type : integer_type_node);\n-      tree gnu_base = convert (comp_type, build_int_2 (Base, 0));\n+      tree gnu_base = build_int_cst (comp_type, Base, 0);\n \n       if (Length <= 0)\n \tabort ();\n \n-      gnu_ret = convert (comp_type, build_int_2 (First, First < 0 ? -1 : 0));\n+      gnu_ret = build_int_cst (comp_type, First, First < 0 ? -1 : 0);\n       if (First < 0)\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n \t  gnu_ret = fold (build (MINUS_EXPR, comp_type,\n \t\t\t\t fold (build (MULT_EXPR, comp_type,\n \t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t convert (comp_type,\n-\t\t\t\t\t  build_int_2 (Udigits_Ptr[Idx], 0))));\n+\t\t\t\t build_int_cst (comp_type,\n+\t\t\t\t\t\tUdigits_Ptr[Idx], 0)));\n       else\n \tfor (Idx++, Length--; Length; Idx++, Length--)\n \t  gnu_ret = fold (build (PLUS_EXPR, comp_type,\n \t\t\t\t fold (build (MULT_EXPR, comp_type,\n \t\t\t\t\t      gnu_ret, gnu_base)),\n-\t\t\t\t convert (comp_type,\n-\t\t\t\t\t  build_int_2 (Udigits_Ptr[Idx], 0))));\n+\t\t\t\t build_int_cst (comp_type,\n+\t\t\t\t\t\tUdigits_Ptr[Idx], 0)));\n     }\n \n   gnu_ret = convert (type, gnu_ret);"}, {"sha": "e00400223f57b167e38f4389a0d01d43fbb075ab", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2217,8 +2217,8 @@ Exception_Handler_to_gnu_sjlj (Node_Id gnat_node)\n \t\t= build_binary_op\n \t\t  (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t   build_binary_op (EQ_EXPR, integer_type_node, gnu_comp,\n-\t\t\t\t    convert (TREE_TYPE (gnu_comp),\n-\t\t\t\t\t     build_int_2 ('V', 0))),\n+\t\t\t\t    build_int_cst (TREE_TYPE (gnu_comp),\n+\t\t\t\t\t\t   'V', 0)),\n \t\t   this_choice);\n \t    }\n \t}\n@@ -2504,8 +2504,8 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (Present (Entity (gnat_node)))\n \tgnu_result = DECL_INITIAL (get_gnu_tree (Entity (gnat_node)));\n       else\n-\tgnu_result = convert (gnu_result_type,\n-\t\t\t      build_int_2 (Char_Literal_Value (gnat_node), 0));\n+\tgnu_result = build_int_cst (gnu_result_type,\n+\t\t\t\t    Char_Literal_Value (gnat_node), 0);\n       break;\n \n     case N_Real_Literal:\n@@ -2617,12 +2617,10 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  for (i = 0; i < length; i++)\n \t    {\n \t      gnu_list\n-\t\t= tree_cons (gnu_idx,\n-\t\t\t     convert (TREE_TYPE (gnu_result_type),\n-\t\t\t\t      build_int_2\n-\t\t\t\t      (Get_String_Char (gnat_string, i + 1),\n-\t\t\t\t       0)),\n-\t\t\t   gnu_list);\n+\t\t= tree_cons (gnu_idx, build_int_cst\n+\t\t\t     (TREE_TYPE (gnu_result_type),\n+\t\t\t      Get_String_Char (gnat_string, i + 1), 0),\n+\t\t\t     gnu_list);\n \n \t      gnu_idx = int_const_binop (PLUS_EXPR, gnu_idx, integer_one_node,\n \t\t\t\t\t 0);"}, {"sha": "ff57b9adee20841122f501ffb527549be5c18fb7", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -580,7 +580,7 @@ init_gigi_decls (tree long_long_float_type, tree exception_type)\n   /* Make the types and functions used for exception processing.    */\n   jmpbuf_type\n     = build_array_type (gnat_type_for_mode (Pmode, 0),\n-\t\t\tbuild_index_type (build_int_2 (5, 0)));\n+\t\t\tbuild_index_type (build_int_cst (NULL_TREE, 5, 0)));\n   create_type_decl (get_identifier (\"JMPBUF_T\"), jmpbuf_type, NULL,\n \t\t    false, true, Empty);\n   jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);"}, {"sha": "726c9f2ac84559d0a5bd13847b3e64d1bc08a5e5", "filename": "gcc/ada/utils2.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fada%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils2.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1444,13 +1444,13 @@ build_call_raise (int msg)\n \n   TREE_TYPE (filename)\n     = build_array_type (char_type_node,\n-\t\t\tbuild_index_type (build_int_2 (len, 0)));\n+\t\t\tbuild_index_type (build_int_cst (NULL_TREE, len, 0)));\n \n   return\n     build_call_2_expr (fndecl,\n \t\t       build1 (ADDR_EXPR, build_pointer_type (char_type_node),\n \t\t\t       filename),\n-\t\t       build_int_2 (input_line, 0));\n+\t\t       build_int_cst (NULL_TREE, input_line, 0));\n }\n \f\n /* Return a CONSTRUCTOR of TYPE whose list is LIST.  */"}, {"sha": "65028cf51d96fa08a354e76f24db9ade83209e1c", "filename": "gcc/builtins.c", "status": "modified", "additions": 38, "deletions": 36, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -903,12 +903,12 @@ expand_builtin_prefetch (tree arglist)\n       if (TREE_CHAIN (TREE_CHAIN (arglist)))\n \targ2 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n       else\n-\targ2 = build_int_2 (3, 0);\n+\targ2 = build_int_cst (NULL_TREE, 3, 0);\n     }\n   else\n     {\n       arg1 = integer_zero_node;\n-      arg2 = build_int_2 (3, 0);\n+      arg2 = build_int_cst (NULL_TREE, 3, 0);\n     }\n \n   /* Argument 0 is an address.  */\n@@ -2490,8 +2490,8 @@ expand_builtin_strstr (tree arglist, rtx target, enum machine_mode mode)\n \n       /* New argument list transforming strstr(s1, s2) to\n \t strchr(s1, s2[0]).  */\n-      arglist =\n-\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p2[0], 0));\n       arglist = tree_cons (NULL_TREE, s1, arglist);\n       return expand_expr (build_function_call_expr (fn, arglist),\n \t\t\t  target, mode, EXPAND_NORMAL);\n@@ -2647,8 +2647,8 @@ expand_builtin_strpbrk (tree arglist, rtx target, enum machine_mode mode)\n \n       /* New argument list transforming strpbrk(s1, s2) to\n \t strchr(s1, s2[0]).  */\n-      arglist =\n-\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p2[0], 0));\n       arglist = tree_cons (NULL_TREE, s1, arglist);\n       return expand_expr (build_function_call_expr (fn, arglist),\n \t\t\t  target, mode, EXPAND_NORMAL);\n@@ -4676,10 +4676,11 @@ expand_builtin_fputs (tree arglist, rtx target, bool unlocked)\n \t  {\n \t    /* New argument list transforming fputs(string, stream) to\n \t       fputc(string[0], stream).  */\n-\t    arglist =\n-\t      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n-\t    arglist =\n-\t      tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n+\t    arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t       TREE_VALUE (TREE_CHAIN (arglist)));\n+\t    arglist = tree_cons (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p[0], 0),\n+\t\t\t\t arglist);\n \t    fn = fn_fputc;\n \t    break;\n \t  }\n@@ -4936,7 +4937,7 @@ build_string_literal (int len, const char *str)\n \n   t = build_string (len, str);\n   elem = build_type_variant (char_type_node, 1, 0);\n-  index = build_index_type (build_int_2 (len - 1, 0));\n+  index = build_index_type (build_int_cst (NULL_TREE, len - 1, 0));\n   type = build_array_type (elem, index);\n   TREE_TYPE (t) = type;\n   TREE_CONSTANT (t) = 1;\n@@ -5022,7 +5023,7 @@ expand_builtin_printf (tree arglist, rtx target, enum machine_mode mode,\n \t  /* Given printf(\"c\"), (where c is any one character,)\n \t     convert \"c\"[0] to an int and pass that to the replacement\n \t     function.  */\n-\t  arg = build_int_2 (fmt_str[0], 0);\n+\t  arg = build_int_cst (NULL_TREE, fmt_str[0], 0);\n \t  arglist = build_tree_list (NULL_TREE, arg);\n \t  fn = fn_putchar;\n \t}\n@@ -5193,8 +5194,7 @@ expand_builtin_sprintf (tree arglist, rtx target, enum machine_mode mode)\n \t\t   const0_rtx, VOIDmode, EXPAND_NORMAL);\n       if (target == const0_rtx)\n \treturn const0_rtx;\n-      exp = build_int_2 (strlen (fmt_str), 0);\n-      exp = fold_convert (integer_type_node, exp);\n+      exp = build_int_cst (NULL_TREE, strlen (fmt_str), 0);\n       return expand_expr (exp, target, mode, EXPAND_NORMAL);\n     }\n   /* If the format is \"%s\", use strcpy if the result isn't used.  */\n@@ -6271,9 +6271,10 @@ static tree\n fold_builtin_classify_type (tree arglist)\n {\n   if (arglist == 0)\n-    return build_int_2 (no_type_class, 0);\n+    return build_int_cst (NULL_TREE, no_type_class, 0);\n \n-  return build_int_2 (type_to_class (TREE_TYPE (TREE_VALUE (arglist))), 0);\n+  return build_int_cst (NULL_TREE,\n+\t\t\ttype_to_class (TREE_TYPE (TREE_VALUE (arglist))), 0);\n }\n \n /* Fold a call to __builtin_inf or __builtin_huge_val.  */\n@@ -6706,7 +6707,7 @@ fold_builtin_lround (tree exp)\n \n \t  real_round (&r, TYPE_MODE (ftype), &x);\n \t  REAL_VALUE_TO_INT (&lo, &hi, r);\n-\t  result = build_int_2 (lo, hi);\n+\t  result = build_int_cst (NULL_TREE, lo, hi);\n \t  if (int_fits_type_p (result, itype))\n \t    return fold_convert (itype, result);\n \t}\n@@ -6735,7 +6736,7 @@ fold_builtin_bitop (tree exp)\n     {\n       HOST_WIDE_INT hi, width, result;\n       unsigned HOST_WIDE_INT lo;\n-      tree type, t;\n+      tree type;\n \n       type = TREE_TYPE (arg);\n       width = TYPE_PRECISION (type);\n@@ -6815,9 +6816,7 @@ fold_builtin_bitop (tree exp)\n \t  abort();\n \t}\n \n-      t = build_int_2 (result, 0);\n-      TREE_TYPE (t) = TREE_TYPE (exp);\n-      return t;\n+      return build_int_cst (TREE_TYPE (exp), result, 0);\n     }\n \n   return NULL_TREE;\n@@ -7572,11 +7571,12 @@ fold_builtin_isascii (tree arglist)\n       /* Transform isascii(c) -> ((c & ~0x7f) == 0).  */\n       tree arg = TREE_VALUE (arglist);\n \n+      arg = build2 (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t    build_int_cst (NULL_TREE,\n+\t\t\t\t   ~ (unsigned HOST_WIDE_INT) 0x7f,\n+\t\t\t\t   ~ (HOST_WIDE_INT) 0));\n       arg = fold (build2 (EQ_EXPR, integer_type_node,\n-\t\t\t  build2 (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t\t  build_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n-\t\t\t\t\t       ~ (HOST_WIDE_INT) 0)),\n-\t\t\t  integer_zero_node));\n+\t\t\t  arg, integer_zero_node));\n \n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n@@ -7598,7 +7598,7 @@ fold_builtin_toascii (tree arglist)\n       tree arg = TREE_VALUE (arglist);\n \n       return fold (build2 (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t   build_int_2 (0x7f, 0)));\n+\t\t\t   build_int_cst (NULL_TREE, 0x7f, 0)));\n     }\n }\n \n@@ -7616,10 +7616,9 @@ fold_builtin_isdigit (tree arglist)\n       tree arg = TREE_VALUE (arglist);\n       arg = fold_convert (unsigned_type_node, arg);\n       arg = build2 (MINUS_EXPR, unsigned_type_node, arg,\n-\t\t    fold_convert (unsigned_type_node,\n-\t\t\t\t  build_int_2 (TARGET_DIGIT0, 0)));\n+\t\t    build_int_cst (unsigned_type_node, TARGET_DIGIT0, 0));\n       arg = build2 (LE_EXPR, integer_type_node, arg,\n-\t\t    fold_convert (unsigned_type_node, build_int_2 (9, 0)));\n+\t\t    build_int_cst (unsigned_type_node, 9, 0));\n       arg = fold (arg);\n       if (in_gimple_form && !TREE_CONSTANT (arg))\n         return NULL_TREE;\n@@ -8696,7 +8695,8 @@ simplify_builtin_strstr (tree arglist)\n \n       /* New argument list transforming strstr(s1, s2) to\n \t strchr(s1, s2[0]).  */\n-      arglist = build_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p2[0], 0));\n       arglist = tree_cons (NULL_TREE, s1, arglist);\n       return build_function_call_expr (fn, arglist);\n     }\n@@ -8881,8 +8881,8 @@ simplify_builtin_strpbrk (tree arglist)\n \n       /* New argument list transforming strpbrk(s1, s2) to\n \t strchr(s1, s2[0]).  */\n-      arglist =\n-\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p2[0], 0));\n       arglist = tree_cons (NULL_TREE, s1, arglist);\n       return build_function_call_expr (fn, arglist);\n     }\n@@ -9130,9 +9130,11 @@ fold_builtin_fputs (tree arglist, bool ignore, bool unlocked, tree len)\n \t  {\n \t    /* New argument list transforming fputs(string, stream) to\n \t       fputc(string[0], stream).  */\n-\t    arglist =\n-\t      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n-\t    arglist = tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n+\t    arglist = build_tree_list (NULL_TREE,\n+\t\t\t\t       TREE_VALUE (TREE_CHAIN (arglist)));\n+\t    arglist = tree_cons (NULL_TREE,\n+\t\t\t\t build_int_cst (NULL_TREE, p[0], 0),\n+\t\t\t\t arglist);\n \t    fn = fn_fputc;\n \t    break;\n \t  }\n@@ -9256,7 +9258,7 @@ simplify_builtin_sprintf (tree arglist, int ignored)\n       arglist = tree_cons (NULL_TREE, dest, arglist);\n       call = build_function_call_expr (fn, arglist);\n       if (!ignored)\n-\tretval = build_int_2 (strlen (fmt_str), 0);\n+\tretval = build_int_cst (NULL_TREE, strlen (fmt_str), 0);\n     }\n \n   /* If the format is \"%s\", use strcpy if the result isn't used.  */"}, {"sha": "f66341d883a41c6e81eec6099dd2b9207d6922e2", "filename": "gcc/c-common.c", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -660,7 +660,7 @@ start_fname_decls (void)\n \n       if (decl)\n \t{\n-\t  saved = tree_cons (decl, build_int_2 (ix, 0), saved);\n+\t  saved = tree_cons (decl, build_int_cst (NULL_TREE, ix, 0), saved);\n \t  *fname_vars[ix].decl = NULL_TREE;\n \t}\n     }\n@@ -835,31 +835,24 @@ fix_string_type (tree value)\n   const int nchars_max = flag_isoc99 ? 4095 : 509;\n   int length = TREE_STRING_LENGTH (value);\n   int nchars;\n-\n+  tree e_type, i_type;\n+  \n   /* Compute the number of elements, for the array type.  */\n   nchars = wide_flag ? length / wchar_bytes : length;\n \n   if (pedantic && nchars - 1 > nchars_max && !c_dialect_cxx ())\n     pedwarn (\"string length `%d' is greater than the length `%d' ISO C%d compilers are required to support\",\n \t     nchars - 1, nchars_max, flag_isoc99 ? 99 : 89);\n \n+  e_type = wide_flag ? wchar_type_node : char_type_node;\n   /* Create the array type for the string constant.\n      -Wwrite-strings says make the string constant an array of const char\n      so that copying it to a non-const pointer will get a warning.\n      For C++, this is the standard behavior.  */\n   if (flag_const_strings)\n-    {\n-      tree elements\n-\t= build_type_variant (wide_flag ? wchar_type_node : char_type_node,\n-\t\t\t      1, 0);\n-      TREE_TYPE (value)\n-\t= build_array_type (elements,\n-\t\t\t    build_index_type (build_int_2 (nchars - 1, 0)));\n-    }\n-  else\n-    TREE_TYPE (value)\n-      = build_array_type (wide_flag ? wchar_type_node : char_type_node,\n-\t\t\t  build_index_type (build_int_2 (nchars - 1, 0)));\n+    e_type = build_type_variant (e_type, 1, 0);\n+  i_type = build_index_type (build_int_cst (NULL_TREE, nchars - 1, 0));\n+  TREE_TYPE (value) = build_array_type (e_type, i_type);\n \n   TREE_CONSTANT (value) = 1;\n   TREE_INVARIANT (value) = 1;\n@@ -1999,10 +1992,10 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t{\n \t  /* Convert primop1 to target type, but do not introduce\n \t     additional overflow.  We know primop1 is an int_cst.  */\n-\t  tree tmp = build_int_2 (TREE_INT_CST_LOW (primop1),\n-\t\t\t\t  TREE_INT_CST_HIGH (primop1));\n+\t  tree tmp = build_int_cst (*restype_ptr,\n+\t\t\t\t    TREE_INT_CST_LOW (primop1),\n+\t\t\t\t    TREE_INT_CST_HIGH (primop1));\n \n-\t  TREE_TYPE (tmp) = *restype_ptr;\n \t  primop1 = force_fit_type (tmp, 0, TREE_OVERFLOW (primop1),\n \t\t\t\t    TREE_CONSTANT_OVERFLOW (primop1));\n \t}\n@@ -3008,7 +3001,9 @@ c_common_nodes_and_builtins (void)\n \n   record_builtin_type (RID_VOID, NULL, void_type_node);\n \n-  void_zero_node = build_int_2 (0, 0);\n+  void_zero_node = make_node (INTEGER_CST);\n+  TREE_INT_CST_LOW (void_zero_node) = 0;\n+  TREE_INT_CST_HIGH (void_zero_node) = 0;\n   TREE_TYPE (void_zero_node) = void_type_node;\n \n   void_list_node = build_void_list_node ();\n@@ -3900,10 +3895,11 @@ static void\n c_init_attributes (void)\n {\n   /* Fill in the built_in_attributes array.  */\n-#define DEF_ATTR_NULL_TREE(ENUM)\t\t\\\n+#define DEF_ATTR_NULL_TREE(ENUM)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = NULL_TREE;\n-#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\t     \\\n-  built_in_attributes[(int) ENUM] = build_int_2 (VALUE, VALUE < 0 ? -1 : 0);\n+#define DEF_ATTR_INT(ENUM, VALUE)\t\t\t\t\\\n+  built_in_attributes[(int) ENUM] = build_int_cst\t\t\\\n+\t(NULL_TREE, VALUE, VALUE < 0 ? -1 : 0);\n #define DEF_ATTR_IDENT(ENUM, STRING)\t\t\t\t\\\n   built_in_attributes[(int) ENUM] = get_identifier (STRING);\n #define DEF_ATTR_TREE_LIST(ENUM, PURPOSE, VALUE, CHAIN)\t\\"}, {"sha": "c7ba8d20268e9830b9f78a116d75ec3c979388d1", "filename": "gcc/c-decl.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -3269,13 +3269,14 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t{\n \t  int eltsize\n \t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n-\t  maxindex = build_int_2 ((TREE_STRING_LENGTH (initial_value)\n-\t\t\t\t   / eltsize) - 1, 0);\n+\t  maxindex = build_int_cst (NULL_TREE,\n+\t\t\t\t    (TREE_STRING_LENGTH (initial_value)\n+\t\t\t\t     / eltsize) - 1, 0);\n \t}\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n \t  tree elts = CONSTRUCTOR_ELTS (initial_value);\n-\t  maxindex = build_int_2 (-1, -1);\n+\t  maxindex = build_int_cst (NULL_TREE, -1, -1);\n \t  for (; elts; elts = TREE_CHAIN (elts))\n \t    {\n \t      if (TREE_PURPOSE (elts))\n@@ -3292,14 +3293,14 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t    value = 1;\n \n \t  /* Prevent further error messages.  */\n-\t  maxindex = build_int_2 (0, 0);\n+\t  maxindex = build_int_cst (NULL_TREE, 0, 0);\n \t}\n     }\n \n   if (!maxindex)\n     {\n       if (do_default)\n-\tmaxindex = build_int_2 (0, 0);\n+\tmaxindex = build_int_cst (NULL_TREE, 0, 0);\n       value = 2;\n     }\n \n@@ -3410,7 +3411,7 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n     {\n       error (\"width of `%s' exceeds its type\", name);\n       w = max_width;\n-      *width = build_int_2 (w, 0);\n+      *width = build_int_cst (NULL_TREE, w, 0);\n     }\n   else\n     w = tree_low_cst (*width, 1);"}, {"sha": "7fc47ba8db3d03c1aed44d71107a6869451e0f12", "filename": "gcc/c-lex.c", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -588,13 +588,11 @@ interpret_integer (const cpp_token *token, unsigned int flags)\n     pedwarn (\"integer constant is too large for \\\"%s\\\" type\",\n \t     (flags & CPP_N_UNSIGNED) ? \"unsigned long\" : \"long\");\n \n-  value = build_int_2 (integer.low, integer.high);\n-  TREE_TYPE (value) = type;\n+  value = build_int_cst (type, integer.low, integer.high);\n \n   /* Convert imaginary to a complex type.  */\n   if (flags & CPP_N_IMAGINARY)\n-    value = build_complex (NULL_TREE,\n-\t\t\t   convert (type, integer_zero_node), value);\n+    value = build_complex (NULL_TREE, build_int_cst (type, 0, 0), value);\n \n   return value;\n }\n@@ -795,13 +793,6 @@ lex_charconst (const cpp_token *token)\n   result = cpp_interpret_charconst (parse_in, token,\n \t\t\t\t    &chars_seen, &unsignedp);\n \n-  /* Cast to cppchar_signed_t to get correct sign-extension of RESULT\n-     before possibly widening to HOST_WIDE_INT for build_int_2.  */\n-  if (unsignedp || (cppchar_signed_t) result >= 0)\n-    value = build_int_2 (result, 0);\n-  else\n-    value = build_int_2 ((cppchar_signed_t) result, -1);\n-\n   if (token->type == CPP_WCHAR)\n     type = wchar_type_node;\n   /* In C, a character constant has type 'int'.\n@@ -811,6 +802,12 @@ lex_charconst (const cpp_token *token)\n   else\n     type = char_type_node;\n \n-  TREE_TYPE (value) = type;\n+  /* Cast to cppchar_signed_t to get correct sign-extension of RESULT\n+     before possibly widening to HOST_WIDE_INT for build_int_cst.  */\n+  if (unsignedp || (cppchar_signed_t) result >= 0)\n+    value = build_int_cst (type, result, 0);\n+  else\n+    value = build_int_cst (type, (cppchar_signed_t) result, -1);\n+\n   return value;\n }"}, {"sha": "f1597302627da27fa89209a0e851d36dee6e0e6b", "filename": "gcc/c-parse.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -704,7 +704,8 @@ primary:\n \t\t  e2 = TYPE_MAIN_VARIANT (groktypename ($5));\n \n \t\t  $$.value = comptypes (e1, e2)\n-\t\t    ? build_int_2 (1, 0) : build_int_2 (0, 0);\n+\t\t    ? build_int_cst (NULL_TREE, 1, 0)\n+\t\t    : build_int_cst (NULL_TREE, 0, 0);\n \t\t  $$.original_code = ERROR_MARK;\n \t\t}\n \t| TYPES_COMPATIBLE_P '(' error ')'"}, {"sha": "dbb56ed4503ce3107ada9412486cc0849d897865", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -786,8 +786,9 @@ pp_c_integer_constant (c_pretty_printer *pp, tree i)\n       if (tree_int_cst_sgn (i) < 0)\n         {\n           pp_c_char (pp, '-');\n-          i = build_int_2 (-TREE_INT_CST_LOW (i),\n-                           ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n+          i = build_int_cst (NULL_TREE,\n+\t\t\t     -TREE_INT_CST_LOW (i),\n+\t\t\t     ~TREE_INT_CST_HIGH (i) + !TREE_INT_CST_LOW (i));\n         }\n       sprintf (pp_buffer (pp)->digit_buffer,\n                HOST_WIDE_INT_PRINT_DOUBLE_HEX,"}, {"sha": "2c89c73b449ce076f684d21f0b702f196eb848d9", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -4472,14 +4472,14 @@ really_start_incremental_init (tree type)\n \t  /* Detect non-empty initializations of zero-length arrays.  */\n \t  if (constructor_max_index == NULL_TREE\n \t      && TYPE_SIZE (constructor_type))\n-\t    constructor_max_index = build_int_2 (-1, -1);\n+\t    constructor_max_index = build_int_cst (NULL_TREE, -1, -1);\n \n \t  /* constructor_max_index needs to be an INTEGER_CST.  Attempts\n \t     to initialize VLAs will cause a proper error; avoid tree\n \t     checking errors as well by setting a safe value.  */\n \t  if (constructor_max_index\n \t      && TREE_CODE (constructor_max_index) != INTEGER_CST)\n-\t    constructor_max_index = build_int_2 (-1, -1);\n+\t    constructor_max_index = build_int_cst (NULL_TREE, -1, -1);\n \n \t  constructor_index\n \t    = convert (bitsizetype,\n@@ -4494,7 +4494,8 @@ really_start_incremental_init (tree type)\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n-\tbuild_int_2 (TYPE_VECTOR_SUBPARTS (constructor_type) - 1, 0);\n+\tbuild_int_cst (NULL_TREE,\n+\t\t       TYPE_VECTOR_SUBPARTS (constructor_type) - 1, 0);\n       constructor_index = convert (bitsizetype, bitsize_zero_node);\n       constructor_unfilled_index = constructor_index;\n     }\n@@ -4649,7 +4650,8 @@ push_init_level (int implicit)\n     {\n       /* Vectors are like simple fixed-size arrays.  */\n       constructor_max_index =\n-\tbuild_int_2 (TYPE_VECTOR_SUBPARTS (constructor_type) - 1, 0);\n+\tbuild_int_cst (NULL_TREE,\n+\t\t       TYPE_VECTOR_SUBPARTS (constructor_type) - 1, 0);\n       constructor_index = convert (bitsizetype, integer_zero_node);\n       constructor_unfilled_index = constructor_index;\n     }\n@@ -4663,14 +4665,14 @@ push_init_level (int implicit)\n \t  /* Detect non-empty initializations of zero-length arrays.  */\n \t  if (constructor_max_index == NULL_TREE\n \t      && TYPE_SIZE (constructor_type))\n-\t    constructor_max_index = build_int_2 (-1, -1);\n+\t    constructor_max_index = build_int_cst (NULL_TREE, -1, -1);\n \n \t  /* constructor_max_index needs to be an INTEGER_CST.  Attempts\n \t     to initialize VLAs will cause a proper error; avoid tree\n \t     checking errors as well by setting a safe value.  */\n \t  if (constructor_max_index\n \t      && TREE_CODE (constructor_max_index) != INTEGER_CST)\n-\t    constructor_max_index = build_int_2 (-1, -1);\n+\t    constructor_max_index = build_int_cst (NULL_TREE, -1, -1);\n \n \t  constructor_index\n \t    = convert (bitsizetype,\n@@ -5394,8 +5396,7 @@ set_nonincremental_init_from_string (tree str)\n \t\t      << (bitpos - HOST_BITS_PER_WIDE_INT);\n \t}\n \n-      value = build_int_2 (val[1], val[0]);\n-      TREE_TYPE (value) = type;\n+      value = build_int_cst (type, val[1], val[0]);\n       add_pending_init (purpose, value);\n     }\n "}, {"sha": "8b28c46f6498fecfc7396521a5099d47387dd0a9", "filename": "gcc/calls.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1505,7 +1505,9 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \t\t     seem worth generating rtl to say that.  */\n \t\t  reg = gen_rtx_REG (word_mode, REGNO (reg));\n \t\t  x = expand_shift (LSHIFT_EXPR, word_mode, reg,\n-\t\t\t\t    build_int_2 (shift, 0), reg, 1);\n+\t\t\t\t    build_int_cst (NULL_TREE, FIXMEFORMAT\n+\t\t\t\t\t\t   shift, 0),\n+\t\t\t\t    reg, 1);\n \t\t  if (x != reg)\n \t\t    emit_move_insn (reg, x);\n \t\t}\n@@ -1542,7 +1544,8 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n \n \t\t  emit_move_insn (x, tem);\n \t\t  x = expand_shift (dir, word_mode, x,\n-\t\t\t\t    build_int_2 (shift, 0), ri, 1);\n+\t\t\t\t    build_int_cst (NULL_TREE, shift, 0),\n+\t\t\t\t    ri, 1);\n \t\t  if (x != ri)\n \t\t    emit_move_insn (ri, x);\n \t\t}"}, {"sha": "87d2cf52e084e091336e74375ae87258cd57a4d0", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -4929,7 +4929,7 @@ alpha_initialize_trampoline (rtx tramp, rtx fnaddr, rtx cxt,\n       temp = expand_binop (DImode, sub_optab, fnaddr, temp, temp, 1,\n \t\t\t   OPTAB_WIDEN);\n       temp = expand_shift (RSHIFT_EXPR, Pmode, temp,\n-\t\t           build_int_2 (2, 0), NULL_RTX, 1);\n+\t\t           build_int_cst (NULL_TREE, 2, 0), NULL_RTX, 1);\n       temp = expand_and (SImode, gen_lowpart (SImode, temp),\n \t\t\t GEN_INT (0x3fff), 0);\n \n@@ -5382,12 +5382,13 @@ alpha_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \t\t\t    valist, offset_field, NULL_TREE);\n \n       t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n-      t = build (PLUS_EXPR, ptr_type_node, t, build_int_2 (offset, 0));\n+      t = build (PLUS_EXPR, ptr_type_node, t,\n+\t\t build_int_cst (NULL_TREE, offset, 0));\n       t = build (MODIFY_EXPR, TREE_TYPE (base_field), base_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-      t = build_int_2 (NUM_ARGS * UNITS_PER_WORD, 0);\n+      t = build_int_cst (NULL_TREE, NUM_ARGS * UNITS_PER_WORD, 0);\n       t = build (MODIFY_EXPR, TREE_TYPE (offset_field), offset_field, t);\n       TREE_SIDE_EFFECTS (t) = 1;\n       expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -5403,7 +5404,7 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n      reserved for the registers.  */\n   if (targetm.calls.must_pass_in_stack (TYPE_MODE (type), type))\n     {\n-      t = fold_convert (TREE_TYPE (offset), build_int_2 (6*8, 0));\n+      t = build_int_cst (TREE_TYPE (offset), 6*8, 0);\n       t = build (MODIFY_EXPR, TREE_TYPE (offset), offset,\n \t\t build (MAX_EXPR, TREE_TYPE (offset), offset, t));\n       gimplify_and_add (t, pre_p);\n@@ -5432,7 +5433,7 @@ alpha_gimplify_va_arg_1 (tree type, tree base, tree offset, tree *pre_p)\n     {\n       tree fpaddend, cond, fourtyeight;\n \n-      fourtyeight = fold_convert (TREE_TYPE (addend), build_int_2 (6*8, 0));\n+      fourtyeight = build_int_cst (TREE_TYPE (addend), 6*8, 0);\n       fpaddend = fold (build (MINUS_EXPR, TREE_TYPE (addend),\n \t\t\t      addend, fourtyeight));\n       cond = fold (build (LT_EXPR, boolean_type_node, addend, fourtyeight));"}, {"sha": "c4d9ffd1b7ffe9606a64903c508e5154b55da6da", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -14691,8 +14691,7 @@ arm_get_cookie_size (tree type)\n   if (!TARGET_AAPCS_BASED)\n     return default_cxx_get_cookie_size (type);\n \n-  size = build_int_2 (8, 0);\n-  TREE_TYPE (size) = sizetype;\n+  size = build_int_cst (sizetype, 8, 0);\n   return size;\n }\n "}, {"sha": "ead3631f47238e819a0388f49cee303fac97203f", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -738,7 +738,7 @@ c4x_gimplify_va_arg_expr (tree valist, tree type,\n     type = build_pointer_type (type);\n \n   t = build (PREDECREMENT_EXPR, TREE_TYPE (valist), valist,\n-\t     build_int_2 (int_size_in_bytes (type), 0));\n+\t     build_int_cst (NULL_TREE, int_size_in_bytes (type), 0));\n   t = fold_convert (build_pointer_type (type), t);\n   t = build_fold_indirect_ref (t);\n "}, {"sha": "0328df50d3d87dcc87a85053c911b5aa7523c32c", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -3231,20 +3231,20 @@ ix86_va_start (tree valist, rtx nextarg)\n \t     (int) words, (int) n_gpr, (int) n_fpr);\n \n   t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n-\t     build_int_2 (n_gpr * 8, 0));\n+\t     build_int_cst (NULL_TREE, n_gpr * 8, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n-\t     build_int_2 (n_fpr * 16 + 8*REGPARM_MAX, 0));\n+\t     build_int_cst (NULL_TREE, n_fpr * 16 + 8*REGPARM_MAX, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n   if (words != 0)\n     t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n-\t       build_int_2 (words * UNITS_PER_WORD, 0));\n+\t       build_int_cst (NULL_TREE, words * UNITS_PER_WORD, 0));\n   t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -3363,18 +3363,18 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       /* First ensure that we fit completely in registers.  */\n       if (needed_intregs)\n \t{\n-\t  t = build_int_2 ((REGPARM_MAX - needed_intregs + 1) * 8, 0);\n-\t  TREE_TYPE (t) = TREE_TYPE (gpr);\n+\t  t = build_int_cst (TREE_TYPE (gpr),\n+\t\t\t     (REGPARM_MAX - needed_intregs + 1) * 8, 0);\n \t  t = build2 (GE_EXPR, boolean_type_node, gpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n \t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n-\t  t = build_int_2 ((SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n-\t\t\t   + REGPARM_MAX * 8, 0);\n-\t  TREE_TYPE (t) = TREE_TYPE (fpr);\n+\t  t = build_int_cst (TREE_TYPE (fpr),\n+\t\t\t     (SSE_REGPARM_MAX - needed_sseregs + 1) * 16\n+\t\t\t     + REGPARM_MAX * 8, 0);\n \t  t = build2 (GE_EXPR, boolean_type_node, fpr, t);\n \t  t2 = build1 (GOTO_EXPR, void_type_node, lab_false);\n \t  t = build (COND_EXPR, void_type_node, t, t2, NULL_TREE);\n@@ -3445,15 +3445,14 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       if (needed_intregs)\n \t{\n \t  t = build2 (PLUS_EXPR, TREE_TYPE (gpr), gpr,\n-\t\t      build_int_2 (needed_intregs * 8, 0));\n+\t\t      build_int_cst (NULL_TREE, needed_intregs * 8, 0));\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n       if (needed_sseregs)\n \t{\n-\t  t =\n-\t    build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n-\t\t   build_int_2 (needed_sseregs * 16, 0));\n+\t  t = build2 (PLUS_EXPR, TREE_TYPE (fpr), fpr,\n+\t\t      build_int_cst (NULL_TREE, needed_sseregs * 16, 0));\n \t  t = build2 (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n \t  gimplify_and_add (t, pre_p);\n \t}\n@@ -3473,16 +3472,18 @@ ix86_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   else\n     {\n       HOST_WIDE_INT align = FUNCTION_ARG_BOUNDARY (VOIDmode, type) / 8;\n-      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf, build_int_2 (align - 1, 0));\n-      t = build (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+      t = build (PLUS_EXPR, TREE_TYPE (ovf), ovf,\n+\t\t build_int_cst (NULL_TREE, align - 1, 0));\n+      t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n+\t\t build_int_cst (NULL_TREE, -align, -1));\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n   t2 = build2 (MODIFY_EXPR, void_type_node, addr, t);\n   gimplify_and_add (t2, pre_p);\n \n   t = build2 (PLUS_EXPR, TREE_TYPE (t), t,\n-\t      build_int_2 (rsize * UNITS_PER_WORD, 0));\n+\t      build_int_cst (NULL_TREE, rsize * UNITS_PER_WORD, 0));\n   t = build2 (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   gimplify_and_add (t, pre_p);\n "}, {"sha": "0723bac8ca9a58a52320611a19b28e8f18637818", "filename": "gcc/config/i860/i860.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fi860%2Fi860.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fi860%2Fi860.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi860%2Fi860.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1888,19 +1888,21 @@ i860_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   t = make_tree (TREE_TYPE (mem), virtual_incoming_args_rtx);\n   off = INTVAL (current_function_arg_offset_rtx);\n   off = off < 0 ? 0 : off;\n-  t = build (PLUS_EXPR, TREE_TYPE (mem), t, build_int_2 (off, 0));\n+  t = build (PLUS_EXPR, TREE_TYPE (mem), t, build_int_cst (NULL_TREE, off, 0));\n   t = build (MODIFY_EXPR, TREE_TYPE (mem), mem, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Initialize the `ireg_used' field.  */\n-  t = build_int_2 (current_function_args_info.ints / UNITS_PER_WORD, 0);\n+  t = build_int_cst (NULL_TREE,\n+\t\t     current_function_args_info.ints / UNITS_PER_WORD, 0);\n   t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n      \n   /* Initialize the `freg_used' field.  */\n-  t = build_int_2 (current_function_args_info.floats / UNITS_PER_WORD, 0);\n+  t = build_int_cst (NULL_TREE,\n+\t\t     current_function_args_info.floats / UNITS_PER_WORD, 0);\n   t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);"}, {"sha": "f4b45d3c9a5b7b3bbd66fd0e5ce1cabe27c78ea8", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -3407,9 +3407,9 @@ ia64_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n       ? int_size_in_bytes (type) > 8 : TYPE_ALIGN (type) > 8 * BITS_PER_UNIT)\n     {\n       tree t = build (PLUS_EXPR, TREE_TYPE (valist), valist,\n-\t\t      build_int_2 (2 * UNITS_PER_WORD - 1, 0));\n+\t\t      build_int_cst (NULL_TREE, 2 * UNITS_PER_WORD - 1, 0));\n       t = build (BIT_AND_EXPR, TREE_TYPE (t), t,\n-\t\t build_int_2 (-2 * UNITS_PER_WORD, -1));\n+\t\t build_int_cst (NULL_TREE, -2 * UNITS_PER_WORD, -1));\n       t = build (MODIFY_EXPR, TREE_TYPE (valist), valist, t);\n       gimplify_and_add (t, pre_p);\n     }"}, {"sha": "066df115fea1c42774028e1a29d337b1f230a0e2", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -3351,7 +3351,7 @@ mips_build_builtin_va_list (void)\n \t\t\t  unsigned_char_type_node);\n       /* Explicitly pad to the size of a pointer, so that -Wpadded won't\n \t warn on every user file.  */\n-      index = build_int_2 (GET_MODE_SIZE (ptr_mode) - 2 - 1, 0);\n+      index = build_int_cst (NULL_TREE, GET_MODE_SIZE (ptr_mode) - 2 - 1, 0);\n       array = build_array_type (unsigned_char_type_node,\n \t\t\t        build_index_type (index));\n       f_res = build_decl (FIELD_DECL, get_identifier (\"__reserved\"), array);\n@@ -3435,7 +3435,8 @@ mips_va_start (tree valist, rtx nextarg)\n \t  t = make_tree (TREE_TYPE (ovfl), virtual_incoming_args_rtx);\n \t  if (cum->stack_words > 0)\n \t    t = build (PLUS_EXPR, TREE_TYPE (ovfl), t,\n-\t\t       build_int_2 (cum->stack_words * UNITS_PER_WORD, 0));\n+\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t      cum->stack_words * UNITS_PER_WORD, 0));\n \t  t = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n  \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -3452,22 +3453,22 @@ mips_va_start (tree valist, rtx nextarg)\n \t  fpr_offset &= ~(UNITS_PER_FPVALUE - 1);\n \t  if (fpr_offset)\n \t    t = build (PLUS_EXPR, TREE_TYPE (ftop), t,\n-\t\t       build_int_2 (-fpr_offset, -1));\n+\t\t       build_int_cst (NULL_TREE, -fpr_offset, -1));\n \t  t = build (MODIFY_EXPR, TREE_TYPE (ftop), ftop, t);\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n \t  /* Emit code to initialize GOFF, the offset from GTOP of the\n \t     next GPR argument.  */\n \t  t = build (MODIFY_EXPR, TREE_TYPE (goff), goff,\n-\t\t     build_int_2 (gpr_save_area_size, 0));\n+\t\t     build_int_cst (NULL_TREE, gpr_save_area_size, 0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n \t  /* Likewise emit code to initialize FOFF, the offset from FTOP\n \t     of the next FPR argument.  */\n \t  fpr_save_area_size\n \t    = (MAX_ARGS_IN_REGISTERS - cum->num_fprs) * UNITS_PER_FPREG;\n \t  t = build (MODIFY_EXPR, TREE_TYPE (foff), foff,\n-\t\t     build_int_2 (fpr_save_area_size, 0));\n+\t\t     build_int_cst (NULL_TREE, fpr_save_area_size, 0));\n \t  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \t}\n       else\n@@ -3591,7 +3592,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \t    {\n \t      /* [1] Emit code for: off &= -rsize.\t*/\n \t      t = build (BIT_AND_EXPR, TREE_TYPE (off), off,\n-\t\t\t build_int_2 (-rsize, -1));\n+\t\t\t build_int_cst (NULL_TREE, -rsize, -1));\n \t      t = build (MODIFY_EXPR, TREE_TYPE (off), off, t);\n \t      gimplify_and_add (t, pre_p);\n \t    }\n@@ -3605,7 +3606,7 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       /* [5] Emit code for: off -= rsize.  We do this as a form of\n \t post-increment not available to C.  Also widen for the\n \t coming pointer arithmetic.  */\n-      t = fold_convert (TREE_TYPE (off), build_int_2 (rsize, 0));\n+      t = fold_convert (TREE_TYPE (off), build_int_cst (NULL_TREE, rsize, 0));\n       t = build (POSTDECREMENT_EXPR, TREE_TYPE (off), off, t);\n       t = fold_convert (sizetype, t);\n       t = fold_convert (TREE_TYPE (top), t);\n@@ -3615,17 +3616,20 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       t = build (MINUS_EXPR, TREE_TYPE (top), top, t);\n       if (BYTES_BIG_ENDIAN && rsize > size)\n \t{\n-\t  u = fold_convert (TREE_TYPE (t), build_int_2 (rsize - size, 0));\n+\t  u = fold_convert (TREE_TYPE (t), build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t\t  rsize - size, 0));\n \t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n       COND_EXPR_THEN (addr) = t;\n \n       if (osize > UNITS_PER_WORD)\n \t{\n \t  /* [9] Emit: ovfl += ((intptr_t) ovfl + osize - 1) & -osize.  */\n-\t  u = fold_convert (TREE_TYPE (ovfl), build_int_2 (osize - 1, 0));\n+\t  u = fold_convert (TREE_TYPE (ovfl),\n+\t\t\t    build_int_cst (NULL_TREE, osize - 1, 0));\n \t  t = build (PLUS_EXPR, TREE_TYPE (ovfl), ovfl, u);\n-\t  u = fold_convert (TREE_TYPE (ovfl), build_int_2 (-osize, -1));\n+\t  u = fold_convert (TREE_TYPE (ovfl),\n+\t\t\t    build_int_cst (NULL_TREE, -osize, -1));\n \t  t = build (BIT_AND_EXPR, TREE_TYPE (ovfl), t, u);\n \t  align = build (MODIFY_EXPR, TREE_TYPE (ovfl), ovfl, t);\n \t}\n@@ -3635,11 +3639,13 @@ mips_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n       /* [10, 11].\tEmit code to store ovfl in addr_rtx, then\n \t post-increment ovfl by osize.  On big-endian machines,\n \t the argument has OSIZE - SIZE bytes of leading padding.  */\n-      u = fold_convert (TREE_TYPE (ovfl), build_int_2 (osize, 0));\n+      u = fold_convert (TREE_TYPE (ovfl),\n+\t\t\tbuild_int_cst (NULL_TREE, osize, 0));\n       t = build (POSTINCREMENT_EXPR, TREE_TYPE (ovfl), ovfl, u);\n       if (BYTES_BIG_ENDIAN && osize > size)\n \t{\n-\t  u = fold_convert (TREE_TYPE (t), build_int_2 (osize - size, 0));\n+\t  u = fold_convert (TREE_TYPE (t),\n+\t\t\t    build_int_cst (NULL_TREE, osize - size, 0));\n \t  t = build (PLUS_EXPR, TREE_TYPE (t), t, u);\n \t}\n "}, {"sha": "314c5f8b757b83a39144f2dce839c3ef3a378b7d", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -6119,8 +6119,7 @@ hppa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p, tree *post_p)\n \n       /* Copied from va-pa.h, but we probably don't need to align to\n \t word size, since we generate and preserve that invariant.  */\n-      u = build_int_2 ((size > 4 ? -8 : -4), -1);\n-      u = fold_convert (valist_type, u);\n+      u = build_int_cst (valist_type, (size > 4 ? -8 : -4), -1);\n       t = build (BIT_AND_EXPR, valist_type, t, u);\n \n       t = build (MODIFY_EXPR, valist_type, valist, t);"}, {"sha": "3331af07083b5ec0f5c52aa76fff27b82bfd2214", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -5428,27 +5428,29 @@ rs6000_va_start (tree valist, rtx nextarg)\n \t     HOST_WIDE_INT_PRINT_DEC\", n_fpr = \"HOST_WIDE_INT_PRINT_DEC\"\\n\",\n \t     words, n_gpr, n_fpr);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, build_int_2 (n_gpr, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t     build_int_cst (NULL_TREE, n_gpr, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, build_int_2 (n_fpr, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t     build_int_cst (NULL_TREE, n_fpr, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the overflow area.  */\n   t = make_tree (TREE_TYPE (ovf), virtual_incoming_args_rtx);\n   if (words != 0)\n     t = build (PLUS_EXPR, TREE_TYPE (ovf), t,\n-\t       build_int_2 (words * UNITS_PER_WORD, 0));\n+\t       build_int_cst (NULL_TREE, words * UNITS_PER_WORD, 0));\n   t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   /* Find the register save area.  */\n   t = make_tree (TREE_TYPE (sav), virtual_stack_vars_rtx);\n   t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t     build_int_2 (-RS6000_VARARGS_SIZE, -1));\n+\t     build_int_cst (NULL_TREE, -RS6000_VARARGS_SIZE, -1));\n   t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -5605,7 +5607,8 @@ rs6000_gimplify_va_arg (tree valist, tree type, tree *pre_p, tree *post_p)\n   if (align != 1)\n     {\n       t = build2 (PLUS_EXPR, TREE_TYPE (t), t, size_int (align - 1));\n-      t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t, build_int_2 (-align, -1));\n+      t = build2 (BIT_AND_EXPR, TREE_TYPE (t), t,\n+\t\t  build_int_cst (NULL_TREE, -align, -1));\n     }\n   gimplify_expr (&t, pre_p, NULL, is_gimple_val, fb_rvalue);\n \n@@ -15975,7 +15978,7 @@ static void\n add_compiler_branch_island (tree label_name, tree function_name, int line_number)\n {\n   tree branch_island = build_tree_list (function_name, label_name);\n-  TREE_TYPE (branch_island) = build_int_2 (line_number, 0);\n+  TREE_TYPE (branch_island) = build_int_cst (NULL_TREE, line_number, 0);\n   TREE_CHAIN (branch_island) = branch_island_list;\n   branch_island_list = branch_island;\n }"}, {"sha": "627940ca656d9ae7af9ab967dfe04bc95a461a40", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -6928,11 +6928,13 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   n_gpr = current_function_args_info.gprs;\n   n_fpr = current_function_args_info.fprs;\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr, build_int_2 (n_gpr, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (gpr), gpr,\n+\t     build_int_cst (NULL_TREE, n_gpr, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n-  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr, build_int_2 (n_fpr, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (fpr), fpr,\n+\t     build_int_cst (NULL_TREE, n_fpr, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n@@ -6945,7 +6947,7 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n     fprintf (stderr, \"va_start: n_gpr = %d, n_fpr = %d off %d\\n\",\n \t     (int)n_gpr, (int)n_fpr, off);\n \n-  t = build (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_2 (off, 0));\n+  t = build (PLUS_EXPR, TREE_TYPE (ovf), t, build_int_cst (NULL_TREE, off, 0));\n \n   t = build (MODIFY_EXPR, TREE_TYPE (ovf), ovf, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n@@ -6955,11 +6957,12 @@ s390_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n   t = make_tree (TREE_TYPE (sav), return_address_pointer_rtx);\n   if (TARGET_KERNEL_BACKCHAIN)\n     t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t       build_int_2 (-(RETURN_REGNUM - 2) * UNITS_PER_WORD\n-\t\t\t    - (TARGET_64BIT ? 4 : 2) * 8, -1));\n+\t       build_int_cst (NULL_TREE,\n+\t\t\t      -(RETURN_REGNUM - 2) * UNITS_PER_WORD\n+\t\t\t      - (TARGET_64BIT ? 4 : 2) * 8, -1));\n   else\n     t = build (PLUS_EXPR, TREE_TYPE (sav), t,\n-\t       build_int_2 (-RETURN_REGNUM * UNITS_PER_WORD, -1));\n+\t       build_int_cst (NULL_TREE, -RETURN_REGNUM * UNITS_PER_WORD, -1));\n \n   t = build (MODIFY_EXPR, TREE_TYPE (sav), sav, t);\n   TREE_SIDE_EFFECTS (t) = 1;"}, {"sha": "4a59f5c64e73dc5208ebda48e1e9d02be5efb522", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -6339,7 +6339,7 @@ sh_va_start (tree valist, rtx nextarg)\n   else\n     nfp = 0;\n   u = fold (build (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_2 (UNITS_PER_WORD * nfp, 0)));\n+\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nfp, 0)));\n   t = build (MODIFY_EXPR, ptr_type_node, next_fp_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -6354,7 +6354,7 @@ sh_va_start (tree valist, rtx nextarg)\n   else\n     nint = 0;\n   u = fold (build (PLUS_EXPR, ptr_type_node, u,\n-\t\t   build_int_2 (UNITS_PER_WORD * nint, 0)));\n+\t\t   build_int_cst (NULL_TREE, UNITS_PER_WORD * nint, 0)));\n   t = build (MODIFY_EXPR, ptr_type_node, next_o_limit, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);"}, {"sha": "7297fa6636c923380be416e056ea609f78e8a129", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1292,13 +1292,14 @@ xstormy16_expand_builtin_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   t = make_tree (TREE_TYPE (base), virtual_incoming_args_rtx);\n   t = build (PLUS_EXPR, TREE_TYPE (base), t, \n-\t     build_int_2 (INCOMING_FRAME_SP_OFFSET, 0));\n+\t     build_int_cst (NULL_TREE, INCOMING_FRAME_SP_OFFSET, 0));\n   t = build (MODIFY_EXPR, TREE_TYPE (base), base, t);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n   t = build (MODIFY_EXPR, TREE_TYPE (count), count, \n-\t     build_int_2 (current_function_args_info * UNITS_PER_WORD, 0));\n+\t     build_int_cst (NULL_TREE,\n+\t\t\t    current_function_args_info * UNITS_PER_WORD, 0));\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n }"}, {"sha": "e91e943f57db8178f340b41c4ad56bb083afcda7", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2448,7 +2448,8 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n \n   /* Set the __va_stk member to ($arg_ptr - 32).  */\n   u = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n-  u = fold (build (PLUS_EXPR, ptr_type_node, u, build_int_2 (-32, -1)));\n+  u = fold (build (PLUS_EXPR, ptr_type_node, u,\n+\t\t   build_int_cst (NULL_TREE, -32, -1)));\n   t = build (MODIFY_EXPR, ptr_type_node, stk, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2458,7 +2459,7 @@ xtensa_va_start (tree valist, rtx nextarg ATTRIBUTE_UNUSED)\n      alignment offset for __va_stk.  */\n   if (arg_words >= MAX_ARGS_IN_REGISTERS)\n     arg_words += 2;\n-  u = build_int_2 (arg_words * UNITS_PER_WORD, 0);\n+  u = build_int_cst (NULL_TREE, arg_words * UNITS_PER_WORD, 0);\n   t = build (MODIFY_EXPR, integer_type_node, ndx, u);\n   TREE_SIDE_EFFECTS (t) = 1;\n   expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n@@ -2525,9 +2526,9 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       int align = TYPE_ALIGN (type) / BITS_PER_UNIT;\n \n       t = build (PLUS_EXPR, integer_type_node, orig_ndx,\n-\t\t build_int_2 (align - 1, 0));\n+\t\t build_int_cst (NULL_TREE, align - 1, 0));\n       t = build (BIT_AND_EXPR, integer_type_node, t,\n-\t\t build_int_2 (-align, -1));\n+\t\t build_int_cst (NULL_TREE, -align, -1));\n       t = build (MODIFY_EXPR, integer_type_node, orig_ndx, t);\n       gimplify_and_add (t, pre_p);\n     }\n@@ -2557,7 +2558,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n       lab_false = create_artificial_label ();\n       lab_over = create_artificial_label ();\n \n-      t = build_int_2 (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n+      t = build_int_cst (NULL_TREE, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n       t = build (GT_EXPR, boolean_type_node, ndx, t);\n       t = build (COND_EXPR, void_type_node, t,\n \t\t build (GOTO_EXPR, void_type_node, lab_false),\n@@ -2587,7 +2588,7 @@ xtensa_gimplify_va_arg_expr (tree valist, tree type, tree *pre_p,\n \n   lab_false2 = create_artificial_label ();\n \n-  t = build_int_2 (MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n+  t = build_int_cst (NULL_TREE, MAX_ARGS_IN_REGISTERS * UNITS_PER_WORD, 0);\n   t = build (GT_EXPR, boolean_type_node, orig_ndx, t);\n   t = build (COND_EXPR, void_type_node, t,\n \t     build (GOTO_EXPR, void_type_node, lab_false2),"}, {"sha": "9517c50bf3a975f7845ef1f9943a518e69c7ff53", "filename": "gcc/convert.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -43,8 +43,7 @@ convert_to_pointer (tree type, tree expr)\n {\n   if (integer_zerop (expr))\n     {\n-      expr = build_int_2 (0, 0);\n-      TREE_TYPE (expr) = type;\n+      expr = build_int_cst (type, 0, 0);\n       return expr;\n     }\n "}, {"sha": "9f6e13b5c565ec36e6da4c2329e22941f69d6666", "filename": "gcc/coverage.c", "status": "modified", "additions": 29, "deletions": 30, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -378,7 +378,7 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n \t will make any clever transformation on it.  */\n       char buf[20];\n       tree domain_tree\n-        = build_index_type (build_int_2 (1000, 0)); /* replaced later */\n+        = build_index_type (build_int_cst (NULL_TREE, 1000, 0)); /* replaced later */\n       tree gcov_type_array_type\n         = build_array_type (GCOV_TYPE_NODE, domain_tree);\n       tree_ctr_tables[counter]\n@@ -434,7 +434,8 @@ tree_coverage_counter_ref (unsigned counter, unsigned no)\n \n   /* \"no\" here is an array index, scaled to bytes later.  */\n   return build4 (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n-\t\t fold_convert (domain_type, build_int_2 (no, 0)),\n+\t\t fold_convert (domain_type,\n+\t\t\t       build_int_cst (NULL_TREE, no, 0)),\n \t\t TYPE_MIN_VALUE (domain_type),\n \t\t size_binop (EXACT_DIV_EXPR, TYPE_SIZE_UNIT (GCOV_TYPE_NODE),\n \t\t\t     size_int (TYPE_ALIGN_UNIT (GCOV_TYPE_NODE))));\n@@ -609,7 +610,8 @@ build_fn_info_type (unsigned int counters)\n   TREE_CHAIN (field) = fields;\n   fields = field;\n \n-  array_type = build_index_type (build_int_2 (counters - 1, 0));\n+  array_type = build_int_cst (NULL_TREE, counters - 1, 0);\n+  array_type = build_index_type (array_type);\n   array_type = build_array_type (unsigned_type_node, array_type);\n \n   /* counters */\n@@ -635,25 +637,21 @@ build_fn_info_value (const struct function_list *function, tree type)\n   tree array_value = NULL_TREE;\n \n   /* ident */\n-  value = tree_cons (fields,\n-\t\t     convert (unsigned_intSI_type_node,\n-\t\t\t      build_int_2 (function->ident, 0)),\n-\t\t     value);\n+  value = tree_cons (fields, build_int_cst (unsigned_intSI_type_node,\n+\t\t\t\t\t    function->ident, 0), value);\n   fields = TREE_CHAIN (fields);\n \n   /* checksum */\n-  value = tree_cons (fields,\n-\t\t     convert (unsigned_intSI_type_node,\n-\t\t\t      build_int_2 (function->checksum, 0)),\n-\t\t     value);\n+  value = tree_cons (fields, build_int_cst (unsigned_intSI_type_node,\n+\t\t\t\t\t    function->checksum, 0), value);\n   fields = TREE_CHAIN (fields);\n \n   /* counters */\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))\n       {\n-\ttree counters = convert (unsigned_type_node,\n-\t\t\t\t build_int_2 (function->n_ctrs[ix], 0));\n+\ttree counters = build_int_cst (unsigned_type_node,\n+\t\t\t\t       function->n_ctrs[ix], 0);\n \n \tarray_value = tree_cons (NULL_TREE, counters, array_value);\n       }\n@@ -714,16 +712,18 @@ build_ctr_info_value (unsigned int counter, tree type)\n \n   /* counters */\n   value = tree_cons (fields,\n-\t\t     convert (unsigned_intSI_type_node,\n-\t\t\t      build_int_2 (prg_n_ctrs[counter], 0)),\n+\t\t     build_int_cst (unsigned_intSI_type_node,\n+\t\t\t\t    prg_n_ctrs[counter], 0),\n \t\t     value);\n   fields = TREE_CHAIN (fields);\n \n   if (prg_n_ctrs[counter])\n     {\n       tree array_type;\n \n-      array_type = build_index_type (build_int_2 (prg_n_ctrs[counter] - 1, 0));\n+      array_type = build_int_cst (unsigned_type_node,\n+\t\t\t\t  prg_n_ctrs[counter] - 1, 0);\n+      array_type = build_index_type (array_type);\n       array_type = build_array_type (TREE_TYPE (TREE_TYPE (fields)),\n \t\t\t\t     array_type);\n \n@@ -789,9 +789,8 @@ build_gcov_info (void)\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, convert (unsigned_intSI_type_node,\n-\t\t\t\t     build_int_2 (GCOV_VERSION, 0)),\n-\t\t     value);\n+  value = tree_cons (field, build_int_cst (unsigned_intSI_type_node,\n+\t\t\t\t\t   GCOV_VERSION, 0), value);\n \n   /* next -- NULL */\n   field = build_decl (FIELD_DECL, NULL_TREE, build_pointer_type (const_type));\n@@ -803,9 +802,8 @@ build_gcov_info (void)\n   field = build_decl (FIELD_DECL, NULL_TREE, unsigned_intSI_type_node);\n   TREE_CHAIN (field) = fields;\n   fields = field;\n-  value = tree_cons (field, convert (unsigned_intSI_type_node,\n-\t\t\t\t     build_int_2 (local_tick, 0)),\n-\t\t     value);\n+  value = tree_cons (field, build_int_cst (unsigned_intSI_type_node,\n+\t\t\t\t\t   local_tick, 0), value);\n \n   /* Filename */\n   string_type = build_pointer_type (build_qualified_type (char_type_node,\n@@ -821,9 +819,9 @@ build_gcov_info (void)\n   filename_string = build_string (filename_len + 1, filename);\n   if (filename != da_file_name)\n     free (filename);\n-  TREE_TYPE (filename_string) =\n-\t  build_array_type (char_type_node,\n-\t\t\t    build_index_type (build_int_2 (filename_len, 0)));\n+  TREE_TYPE (filename_string) = build_array_type\n+    (char_type_node, build_index_type\n+     (build_int_cst (NULL_TREE, filename_len, 0)));\n   value = tree_cons (field, build1 (ADDR_EXPR, string_type, filename_string),\n \t\t     value);\n \n@@ -839,7 +837,8 @@ build_gcov_info (void)\n     {\n       tree array_type;\n \n-      array_type = build_index_type (build_int_2 (n_fns - 1, 0));\n+      array_type = build_index_type (build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t    n_fns - 1, 0));\n       array_type = build_array_type (fn_info_type, array_type);\n \n       fn_info_value = build_constructor (array_type, nreverse (fn_info_value));\n@@ -853,7 +852,7 @@ build_gcov_info (void)\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field,\n-\t\t     convert (unsigned_type_node, build_int_2 (n_fns, 0)),\n+\t\t     build_int_cst (unsigned_type_node, n_fns, 0),\n \t\t     value);\n \n   /* fn_info table */\n@@ -867,13 +866,13 @@ build_gcov_info (void)\n   TREE_CHAIN (field) = fields;\n   fields = field;\n   value = tree_cons (field,\n-\t\t     convert (unsigned_type_node,\n-\t\t\t      build_int_2 (prg_ctr_mask, 0)),\n+\t\t     build_int_cst (unsigned_type_node, prg_ctr_mask, 0),\n \t\t     value);\n \n   /* counters */\n   ctr_info_type = build_ctr_info_type ();\n-  ctr_info_ary_type = build_index_type (build_int_2 (n_ctr_types, 0));\n+  ctr_info_ary_type = build_index_type (build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t       n_ctr_types, 0));\n   ctr_info_ary_type = build_array_type (ctr_info_type, ctr_info_ary_type);\n   for (ix = 0; ix != GCOV_COUNTERS; ix++)\n     if (prg_ctr_mask & (1 << ix))"}, {"sha": "b5b773983a182701b5bdcefde14e943179b0e5da", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,24 @@\n+2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* call.c (convert_class_to_reference,\n+\tbuild_user_type_conversion_1, convert_like_real,\n+\tbuild_java_interface_fn_ref, build_special_member_call): Use\n+\tbuild_int_cst.\n+\t* class.c (build_vtbl_initializer): Likewise.\n+\t* cp-gimplify.c (cp_gimplify_expr): Likewise.\n+\t* cvt.c (cp_convert_to_pointer): Likewise.\n+\t* decl.c (cxx_init_decl_processing, complete_array_type): Likewise.\n+\t* decl2.c (start_static_initialization_or_destruction,\n+\tgenerate_ctor_or_dtor_function): Likewise.\n+\t* except.c (build_throw): Likewise.\n+\t* lex.c (cxx_init): Likewise.\n+\t* mangle.c (write_integer_cst): Likewise.\n+\t* rtti.c (build_headof, get_tinfo_decl_dynamic,\n+\tbuild_dynamic_cast_1, ptr_initializer, ptm_initializer,\n+\tget_pseudo_ti_init): Likewise.\n+\t* search.c (get_dynamic_cast_base_type): Likewise.\n+\t* tree.c (build_shared_int_cst): Likewise.\n+\n 2004-08-12  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/16273"}, {"sha": "ca6b0d886ceeeddeec06662ddafb6894a0f19e2a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -919,8 +919,7 @@ convert_class_to_reference (tree t, tree s, tree expr)\n      error messages, which we should not issue now because we are just\n      trying to find a conversion operator.  Therefore, we use NULL,\n      cast to the appropriate type.  */\n-  arglist = build_int_2 (0, 0);\n-  TREE_TYPE (arglist) = build_pointer_type (s);\n+  arglist = build_int_cst (build_pointer_type (s), 0, 0);\n   arglist = build_tree_list (NULL_TREE, arglist);\n \n   reference_type = build_reference_type (t);\n@@ -2520,8 +2519,7 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags)\n \n       ctors = BASELINK_FUNCTIONS (ctors);\n \n-      t = build_int_2 (0, 0);\n-      TREE_TYPE (t) = build_pointer_type (totype);\n+      t = build_int_cst (build_pointer_type (totype), 0, 0);\n       args = build_tree_list (NULL_TREE, expr);\n       /* We should never try to call the abstract or base constructor\n \t from here.  */\n@@ -4182,8 +4180,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \n \tif (DECL_CONSTRUCTOR_P (convfn))\n \t  {\n-\t    tree t = build_int_2 (0, 0);\n-\t    TREE_TYPE (t) = build_pointer_type (DECL_CONTEXT (convfn));\n+\t    tree t = build_int_cst (build_pointer_type (DECL_CONTEXT (convfn)),\n+\t\t\t\t    0, 0);\n \n \t    args = build_tree_list (NULL_TREE, expr);\n \t    if (DECL_HAS_IN_CHARGE_PARM_P (convfn)\n@@ -4961,7 +4959,7 @@ build_java_interface_fn_ref (tree fn, tree instance)\n         break;\n       i++;\n     }\n-  idx = build_int_2 (i, 0);\n+  idx = build_int_cst (NULL_TREE, i, 0);\n \n   lookup_args = tree_cons (NULL_TREE, klass_ref, \n \t\t\t   tree_cons (NULL_TREE, iface_ref,\n@@ -5037,8 +5035,7 @@ build_special_member_call (tree instance, tree name, tree args,\n   /* Handle the special case where INSTANCE is NULL_TREE.  */\n   if (name == complete_ctor_identifier && !instance)\n     {\n-      instance = build_int_2 (0, 0);\n-      TREE_TYPE (instance) = build_pointer_type (class_type);\n+      instance = build_int_cst (build_pointer_type (class_type), 0, 0);\n       instance = build1 (INDIRECT_REF, class_type, instance);\n     }\n   else"}, {"sha": "418659e19f6e14117300d9c8b3d089b51281649b", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -7404,7 +7404,7 @@ build_vtbl_initializer (tree binfo,\n \t      {\n \t\ttree fdesc = build (FDESC_EXPR, vfunc_ptr_type_node,\n \t\t\t\t    TREE_OPERAND (init, 0),\n-\t\t\t\t    build_int_2 (i, 0));\n+\t\t\t\t    build_int_cst (NULL_TREE, i, 0));\n \t\tTREE_CONSTANT (fdesc) = 1;\n \t\tTREE_INVARIANT (fdesc) = 1;\n "}, {"sha": "5568a952b5b8be7ad760a40f216024712a4212ea", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -210,12 +210,8 @@ cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n       break;\n \n     case EMPTY_CLASS_EXPR:\n-      {\n-\t/* Yes, an INTEGER_CST with RECORD_TYPE.  */\n-\ttree i = build_int_2 (0, 0);\n-\tTREE_TYPE (i) = TREE_TYPE (*expr_p);\n-\t*expr_p = i;\n-      }\n+      /* We create an INTEGER_CST with RECORD_TYPE and value zero.  */\n+      *expr_p = build_int_cst (TREE_TYPE (*expr_p), 0, 0);\n       ret = GS_OK;\n       break;\n "}, {"sha": "70aba6ead78dc884d3057913c14d83b7d6e82fcd", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -261,15 +261,15 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \treturn build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n \n       if (TYPE_PTRMEM_P (type))\n-\t/* A NULL pointer-to-member is represented by -1, not by\n-\t   zero.  */\n-\texpr = build_int_2 (-1, -1);\n+\t{\n+\t  /* A NULL pointer-to-member is represented by -1, not by\n+\t     zero.  */\n+\t  expr = build_int_cst (type, -1, -1);\n+\t  /* Fix up the representation of -1 if appropriate.  */\n+\t  expr = force_fit_type (expr, 0, false, false);\n+\t}\n       else\n-\texpr = build_int_2 (0, 0);\n-      TREE_TYPE (expr) = type;\n-      \n-      /* Fix up the representation of -1 if appropriate.  */\n-      expr = force_fit_type (expr, 0, false, false);\n+\texpr = build_int_cst (type, 0, 0);\n       \n       return expr;\n     }"}, {"sha": "2be55d6ee973be53f99ab307cc9ac3905f3b2443", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2963,10 +2963,8 @@ cxx_init_decl_processing (void)\n   java_char_type_node = record_builtin_java_type (\"__java_char\", -16);\n   java_boolean_type_node = record_builtin_java_type (\"__java_boolean\", -1);\n \n-  integer_two_node = build_int_2 (2, 0);\n-  TREE_TYPE (integer_two_node) = integer_type_node;\n-  integer_three_node = build_int_2 (3, 0);\n-  TREE_TYPE (integer_three_node) = integer_type_node;\n+  integer_two_node = build_int_cst (NULL_TREE, 2, 0);\n+  integer_three_node = build_int_cst (NULL_TREE, 3, 0);\n \n   record_builtin_type (RID_BOOL, \"bool\", boolean_type_node);\n   truthvalue_type_node = boolean_type_node;\n@@ -5254,8 +5252,9 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t{\n \t  int eltsize\n \t    = int_size_in_bytes (TREE_TYPE (TREE_TYPE (initial_value)));\n-\t  maxindex = build_int_2 ((TREE_STRING_LENGTH (initial_value)\n-\t\t\t\t   / eltsize) - 1, 0);\n+\t  maxindex = build_int_cst (NULL_TREE,\n+\t\t\t\t    (TREE_STRING_LENGTH (initial_value)\n+\t\t\t\t     / eltsize) - 1, 0);\n \t}\n       else if (TREE_CODE (initial_value) == CONSTRUCTOR)\n \t{\n@@ -5279,14 +5278,14 @@ complete_array_type (tree type, tree initial_value, int do_default)\n \t    initial_value = NULL_TREE;\n \n \t  /* Prevent further error messages.  */\n-\t  maxindex = build_int_2 (0, 0);\n+\t  maxindex = build_int_cst (NULL_TREE, 0, 0);\n \t}\n     }\n \n   if (!maxindex)\n     {\n       if (do_default)\n-\tmaxindex = build_int_2 (0, 0);\n+\tmaxindex = build_int_cst (NULL_TREE, 0, 0);\n       value = 2;\n     }\n "}, {"sha": "ab83b9822101c68c864107b0c3394be139689254", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2351,7 +2351,7 @@ start_static_initialization_or_destruction (tree decl, int initp)\n   guard_if_stmt = begin_if_stmt ();\n   cond = cp_build_binary_op (EQ_EXPR,\n \t\t\t     priority_decl,\n-\t\t\t     build_int_2 (priority, 0));\n+\t\t\t     build_int_cst (NULL_TREE, priority, 0));\n   init_cond = initp ? integer_one_node : integer_zero_node;\n   init_cond = cp_build_binary_op (EQ_EXPR,\n \t\t\t\t  initialize_p_decl,\n@@ -2601,9 +2601,11 @@ generate_ctor_or_dtor_function (bool constructor_p, int priority,\n \t    if (! body)\n \t      body = start_objects (function_key, priority);\n \n-\t    arguments = tree_cons (NULL_TREE, build_int_2 (priority, 0), \n+\t    arguments = tree_cons (NULL_TREE,\n+\t\t\t\t   build_int_cst (NULL_TREE, priority, 0), \n \t\t\t\t   NULL_TREE);\n-\t    arguments = tree_cons (NULL_TREE, build_int_2 (constructor_p, 0),\n+\t    arguments = tree_cons (NULL_TREE,\n+\t\t\t\t   build_int_cst (NULL_TREE, constructor_p, 0),\n \t\t\t\t   arguments);\n \t    finish_expr_stmt (build_function_call (fndecl, arguments));\n \t  }"}, {"sha": "fd8b054edd5c57d11017ee704c99cd7974c42e5a", "filename": "gcc/cp/except.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -721,11 +721,8 @@ build_throw (tree exp)\n \t  cleanup = build1 (ADDR_EXPR, cleanup_type, cleanup);\n \t}\n       else\n-\t{\n-\t  cleanup = build_int_2 (0, 0);\n-\t  TREE_TYPE (cleanup) = cleanup_type;\n-\t}\n-\n+\tcleanup = build_int_cst (cleanup_type, 0, 0);\n+\t\n       tmp = tree_cons (NULL_TREE, cleanup, NULL_TREE);\n       tmp = tree_cons (NULL_TREE, throw_type, tmp);\n       tmp = tree_cons (NULL_TREE, ptr, tmp);"}, {"sha": "c44e7c0863b9c67153354136d5cd3fe3ec81a768", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -355,8 +355,7 @@ cxx_init (void)\n   cxx_init_decl_processing ();\n \n   /* Create the built-in __null node.  */\n-  null_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_node) = c_common_type_for_size (POINTER_SIZE, 0);\n+  null_node = build_int_cst (c_common_type_for_size (POINTER_SIZE, 0), 0, 0);\n   ridpointers[RID_NULL] = null_node;\n \n   interface_unknown = 1;"}, {"sha": "4235e35d5ffcba39f6e3c3e5e2c7e5736858a302", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1183,9 +1183,9 @@ write_integer_cst (const tree cst)\n \t}\n       \n       type = c_common_signed_or_unsigned_type (1, TREE_TYPE (cst));\n-      base = build_int_2 (chunk, 0);\n-      n = build_int_2 (TREE_INT_CST_LOW (cst), TREE_INT_CST_HIGH (cst));\n-      TREE_TYPE (n) = TREE_TYPE (base) = type;\n+      base = build_int_cst (type, chunk, 0);\n+      n = build_int_cst (type,\n+\t\t\t TREE_INT_CST_LOW (cst), TREE_INT_CST_HIGH (cst));\n \n       if (sign < 0)\n \t{"}, {"sha": "38ac41878f150d11a4a45bea6ab92a723e150d25", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -150,7 +150,8 @@ build_headof (tree exp)\n   exp = save_expr (exp);\n \n   /* The offset-to-top field is at index -2 from the vptr.  */\n-  index = build_int_2 (-2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n+  index = build_int_cst (NULL_TREE,\n+\t\t\t -2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n \n   offset = build_vtbl_ref (build_indirect_ref (exp, NULL), index);\n \n@@ -225,7 +226,8 @@ get_tinfo_decl_dynamic (tree exp)\n       tree index;\n \n       /* The RTTI information is at index -1.  */\n-      index = build_int_2 (-1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n+      index = build_int_cst (NULL_TREE,\n+\t\t\t     -1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n       t = build_vtbl_ref (exp, index);\n       t = convert (type_info_ptr_type, t);\n     }\n@@ -588,8 +590,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \t\t{\n \t\t  warning (\"dynamic_cast of `%#D' to `%#T' can never succeed\",\n \t\t\t      op, type);\n-\t\t  retval = build_int_2 (0, 0); \n-\t\t  TREE_TYPE (retval) = type; \n+\t\t  retval = build_int_cst (type, 0, 0); \n \t\t  return retval;\n \t\t}\n \t    }\n@@ -878,7 +879,7 @@ ptr_initializer (tree desc, tree target)\n   \n   if (incomplete)\n     flags |= 8;\n-  init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n+  init = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags, 0), init);\n   init = tree_cons (NULL_TREE,\n                     get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n                     init);\n@@ -908,7 +909,7 @@ ptm_initializer (tree desc, tree target)\n     flags |= 0x8;\n   if (!COMPLETE_TYPE_P (klass))\n     flags |= 0x10;\n-  init = tree_cons (NULL_TREE, build_int_2 (flags, 0), init);\n+  init = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, flags, 0), init);\n   init = tree_cons (NULL_TREE,\n \t\t    get_tinfo_ptr (TYPE_MAIN_VARIANT (to)),\n                     init);\n@@ -1089,9 +1090,10 @@ get_pseudo_ti_init (tree type, tree var_desc)\n               \n               /* Combine offset and flags into one field.  */\n               offset = cp_build_binary_op (LSHIFT_EXPR, offset,\n-\t\t\t\t\t   build_int_2 (8, 0));\n+\t\t\t\t\t   build_int_cst (NULL_TREE, 8, 0));\n               offset = cp_build_binary_op (BIT_IOR_EXPR, offset,\n-\t\t\t\t\t   build_int_2 (flags, 0));\n+\t\t\t\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t\t  flags, 0));\n               base_init = tree_cons (NULL_TREE, offset, base_init);\n               base_init = tree_cons (NULL_TREE, tinfo, base_init);\n               base_init = build_constructor (NULL_TREE, base_init);\n@@ -1101,10 +1103,12 @@ get_pseudo_ti_init (tree type, tree var_desc)\n \t  base_inits = tree_cons (NULL_TREE, base_inits, NULL_TREE);\n \t  /* Prepend the number of bases.  */\n \t  base_inits = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_2 (nbases, 0), base_inits);\n+\t\t\t\t  build_int_cst (NULL_TREE, nbases, 0),\n+\t\t\t\t  base_inits);\n \t  /* Prepend the hint flags.  */\n \t  base_inits = tree_cons (NULL_TREE,\n-\t\t\t\t  build_int_2 (hint, 0), base_inits);\n+\t\t\t\t  build_int_cst (NULL_TREE, hint, 0),\n+\t\t\t\t  base_inits);\n \n           return class_initializer (var_desc, type, base_inits);\n         }"}, {"sha": "459c174270519aa5acfdeb15be473791a5016dff", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -346,8 +346,7 @@ get_dynamic_cast_base_type (tree subtype, tree target)\n   \n   if (!boff)\n     return offset;\n-  offset = build_int_2 (boff, -1);\n-  TREE_TYPE (offset) = ssizetype;\n+  offset = build_int_cst (ssizetype, boff, -1);\n   return offset;\n }\n "}, {"sha": "39f655779fd2b8241ba3c1573dbf82289240badb", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1377,10 +1377,10 @@ tree\n build_shared_int_cst (int i)\n {\n   if (i >= 256)\n-    return build_int_2 (i, 0);\n+    return build_int_cst (NULL_TREE, i, 0);\n \n   if (!shared_int_cache[i])\n-    shared_int_cache[i] = build_int_2 (i, 0);\n+    shared_int_cache[i] = build_int_cst (NULL_TREE, i, 0);\n \n   return shared_int_cache[i];\n }"}, {"sha": "d45f1b2dcda69ee8a895fab3b76efb01ea1cfe4b", "filename": "gcc/except.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -376,7 +376,7 @@ init_eh (void)\n \t\t\t integer_type_node);\n       DECL_FIELD_CONTEXT (f_cs) = sjlj_fc_type_node;\n \n-      tmp = build_index_type (build_int_2 (4 - 1, 0));\n+      tmp = build_index_type (build_int_cst (NULL_TREE, 4 - 1, 0));\n       tmp = build_array_type (lang_hooks.types.type_for_mode (word_mode, 1),\n \t\t\t      tmp);\n       f_data = build_decl (FIELD_DECL, get_identifier (\"__data\"), tmp);\n@@ -392,17 +392,19 @@ init_eh (void)\n \n #ifdef DONT_USE_BUILTIN_SETJMP\n #ifdef JMP_BUF_SIZE\n-      tmp = build_int_2 (JMP_BUF_SIZE - 1, 0);\n+      tmp = build_int_cst (NULL_TREE, JMP_BUF_SIZE - 1, 0);\n #else\n       /* Should be large enough for most systems, if it is not,\n \t JMP_BUF_SIZE should be defined with the proper value.  It will\n \t also tend to be larger than necessary for most systems, a more\n \t optimal port will define JMP_BUF_SIZE.  */\n-      tmp = build_int_2 (FIRST_PSEUDO_REGISTER + 2 - 1, 0);\n+      tmp = build_int_cst (NULL_TREE,\n+\t\t\t   FIRST_PSEUDO_REGISTER + 2 - 1, 0);\n #endif\n #else\n       /* builtin_setjmp takes a pointer to 5 words.  */\n-      tmp = build_int_2 (5 * BITS_PER_WORD / POINTER_SIZE - 1, 0);\n+      tmp = build_int_cst (NULL_TREE,\n+\t\t\t   5 * BITS_PER_WORD / POINTER_SIZE - 1, 0);\n #endif\n       tmp = build_index_type (tmp);\n       tmp = build_array_type (ptr_type_node, tmp);\n@@ -1414,7 +1416,7 @@ assign_filter_values (void)\n \t      for (;tp_node; tp_node = TREE_CHAIN (tp_node))\n \t\t{\n \t\t  int flt = add_ttypes_entry (ttypes, TREE_VALUE (tp_node));\n-\t\t  tree flt_node = build_int_2 (flt, 0);\n+\t\t  tree flt_node = build_int_cst (NULL_TREE, flt, 0);\n \n \t\t  r->u.catch.filter_list\n \t\t    = tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);\n@@ -1425,7 +1427,7 @@ assign_filter_values (void)\n \t      /* Get a filter value for the NULL list also since it will need\n \t\t an action record anyway.  */\n \t      int flt = add_ttypes_entry (ttypes, NULL);\n-\t      tree flt_node = build_int_2 (flt, 0);\n+\t      tree flt_node = build_int_cst (NULL_TREE, flt, 0);\n \n \t      r->u.catch.filter_list\n \t\t= tree_cons (NULL_TREE, flt_node, r->u.catch.filter_list);"}, {"sha": "75427e10a6e40dc355511faa00dbbe279dfed5fe", "filename": "gcc/expmed.c", "status": "modified", "additions": 126, "deletions": 79, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -899,7 +899,8 @@ store_fixed_bit_field (rtx op0, unsigned HOST_WIDE_INT offset,\n \t\t\t      NULL_RTX, 1, OPTAB_LIB_WIDEN);\n       if (bitpos > 0)\n \tvalue = expand_shift (LSHIFT_EXPR, mode, value,\n-\t\t\t      build_int_2 (bitpos, 0), NULL_RTX, 1);\n+\t\t\t      build_int_cst (NULL_TREE,\n+\t\t\t\t\t     bitpos, 0), NULL_RTX, 1);\n     }\n \n   /* Now clear the chosen bits in OP0,\n@@ -1327,10 +1328,14 @@ extract_bit_field (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \n       /* Signed bit field: sign-extend with two arithmetic shifts.  */\n       target = expand_shift (LSHIFT_EXPR, mode, target,\n-\t\t\t     build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n+\t\t\t     build_int_cst (NULL_TREE,\n+\t\t\t\t\t    GET_MODE_BITSIZE (mode) - bitsize,\n+\t\t\t\t\t    0),\n \t\t\t     NULL_RTX, 0);\n       return expand_shift (RSHIFT_EXPR, mode, target,\n-\t\t\t   build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n+\t\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t\t  GET_MODE_BITSIZE (mode) - bitsize,\n+\t\t\t\t\t  0),\n \t\t\t   NULL_RTX, 0);\n     }\n \n@@ -1735,7 +1740,7 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n \t{\n \t  /* If the field does not already start at the lsb,\n \t     shift it so it does.  */\n-\t  tree amount = build_int_2 (bitpos, 0);\n+\t  tree amount = build_int_cst (NULL_TREE, bitpos, 0);\n \t  /* Maybe propagate the target for the shift.  */\n \t  /* But not if we will return it--could confuse integrate.c.  */\n \t  rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n@@ -1775,14 +1780,16 @@ extract_fixed_bit_field (enum machine_mode tmode, rtx op0,\n   if (GET_MODE_BITSIZE (mode) != (bitsize + bitpos))\n     {\n       tree amount\n-\t= build_int_2 (GET_MODE_BITSIZE (mode) - (bitsize + bitpos), 0);\n+\t= build_int_cst (NULL_TREE,\n+\t\t\t GET_MODE_BITSIZE (mode) - (bitsize + bitpos), 0);\n       /* Maybe propagate the target for the shift.  */\n       rtx subtarget = (target != 0 && REG_P (target) ? target : 0);\n       op0 = expand_shift (LSHIFT_EXPR, mode, op0, amount, subtarget, 1);\n     }\n \n   return expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t       build_int_2 (GET_MODE_BITSIZE (mode) - bitsize, 0),\n+\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t      GET_MODE_BITSIZE (mode) - bitsize, 0),\n \t\t       target, 0);\n }\n \f\n@@ -1930,13 +1937,15 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  if (bitsize != bitsdone)\n \t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t\t build_int_2 (bitsize - bitsdone, 0), 0, 1);\n+\t\t\t\t build_int_cst (NULL_TREE,\n+\t\t\t\t\t\tbitsize - bitsdone, 0), 0, 1);\n \t}\n       else\n \t{\n \t  if (bitsdone != thissize)\n \t    part = expand_shift (LSHIFT_EXPR, word_mode, part,\n-\t\t\t\t build_int_2 (bitsdone - thissize, 0), 0, 1);\n+\t\t\t\t build_int_cst (NULL_TREE,\n+\t\t\t\t\t\tbitsdone - thissize, 0), 0, 1);\n \t}\n \n       if (first)\n@@ -1955,10 +1964,12 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n     return result;\n   /* Signed bit field: sign-extend with two arithmetic shifts.  */\n   result = expand_shift (LSHIFT_EXPR, word_mode, result,\n-\t\t\t build_int_2 (BITS_PER_WORD - bitsize, 0),\n+\t\t\t build_int_cst (NULL_TREE,\n+\t\t\t\t\tBITS_PER_WORD - bitsize, 0),\n \t\t\t NULL_RTX, 0);\n   return expand_shift (RSHIFT_EXPR, word_mode, result,\n-\t\t       build_int_2 (BITS_PER_WORD - bitsize, 0), NULL_RTX, 0);\n+\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t      BITS_PER_WORD - bitsize, 0), NULL_RTX, 0);\n }\n \f\n /* Add INC into TARGET.  */\n@@ -2075,10 +2086,9 @@ expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t      tree type = TREE_TYPE (amount);\n \t      tree new_amount = make_tree (type, op1);\n \t      tree other_amount\n-\t\t= fold (build2 (MINUS_EXPR, type,\n-\t\t\t\tconvert (type,\n-\t\t\t\t\t build_int_2 (GET_MODE_BITSIZE (mode),\n-\t\t\t\t\t\t      0)),\n+\t\t= fold (build2 (MINUS_EXPR, type, convert\n+\t\t\t\t(type, build_int_cst\n+\t\t\t\t (NULL_TREE, GET_MODE_BITSIZE (mode), 0)),\n \t\t\t\tamount));\n \n \t      shifted = force_reg (mode, shifted);\n@@ -2549,29 +2559,33 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \t{\n \tcase alg_shift:\n \t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\tbuild_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t\tbuild_int_cst (NULL_TREE, log, 0),\n+\t\t\t\tNULL_RTX, 0);\n \t  val_so_far <<= log;\n \t  break;\n \n \tcase alg_add_t_m2:\n \t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t      build_int_cst (NULL_TREE, log, 0),\n+\t\t\t      NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far += (HOST_WIDE_INT) 1 << log;\n \t  break;\n \n \tcase alg_sub_t_m2:\n \t  tem = expand_shift (LSHIFT_EXPR, mode, op0,\n-\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t      build_int_cst (NULL_TREE, log, 0),\n+\t\t\t      NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far -= (HOST_WIDE_INT) 1 << log;\n \t  break;\n \n \tcase alg_add_t2_m:\n \t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\tbuild_int_2 (log, 0), shift_subtarget,\n+\t\t\t\tbuild_int_cst (NULL_TREE, log, 0),\n+\t\t\t\tshift_subtarget,\n \t\t\t\t0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, op0),\n \t\t\t\t add_target ? add_target : accum_target);\n@@ -2580,23 +2594,26 @@ expand_mult_const (enum machine_mode mode, rtx op0, HOST_WIDE_INT val,\n \n \tcase alg_sub_t2_m:\n \t  accum = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t\tbuild_int_2 (log, 0), shift_subtarget, 0);\n+\t\t\t\tbuild_int_cst (NULL_TREE, log, 0),\n+\t\t\t\tshift_subtarget, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, accum, op0),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far = (val_so_far << log) - 1;\n \t  break;\n \n \tcase alg_add_factor:\n \t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t      build_int_cst (NULL_TREE, log, 0),\n+\t\t\t      NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_PLUS (mode, accum, tem),\n \t\t\t\t add_target ? add_target : accum_target);\n \t  val_so_far += val_so_far << log;\n \t  break;\n \n \tcase alg_sub_factor:\n \t  tem = expand_shift (LSHIFT_EXPR, mode, accum,\n-\t\t\t      build_int_2 (log, 0), NULL_RTX, 0);\n+\t\t\t      build_int_cst (NULL_TREE, log, 0),\n+\t\t\t      NULL_RTX, 0);\n \t  accum = force_operand (gen_rtx_MINUS (mode, tem, accum),\n \t\t\t\t (add_target ? add_target\n \t\t\t\t  : preserve ? 0 : tem));\n@@ -2891,15 +2908,17 @@ expand_mult_highpart_adjust (enum machine_mode mode, rtx adj_operand, rtx op0,\n   enum rtx_code adj_code = unsignedp ? PLUS : MINUS;\n \n   tem = expand_shift (RSHIFT_EXPR, mode, op0,\n-\t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n+\t\t      build_int_cst (NULL_TREE,\n+\t\t\t\t     GET_MODE_BITSIZE (mode) - 1, 0),\n \t\t      NULL_RTX, 0);\n   tem = expand_and (mode, tem, op1, NULL_RTX);\n   adj_operand\n     = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n \t\t     adj_operand);\n \n   tem = expand_shift (RSHIFT_EXPR, mode, op1,\n-\t\t      build_int_2 (GET_MODE_BITSIZE (mode) - 1, 0),\n+\t\t      build_int_cst (NULL_TREE,\n+\t\t\t\t     GET_MODE_BITSIZE (mode) - 1, 0),\n \t\t      NULL_RTX, 0);\n   tem = expand_and (mode, tem, op0, NULL_RTX);\n   target = force_operand (gen_rtx_fmt_ee (adj_code, mode, adj_operand, tem),\n@@ -2920,7 +2939,8 @@ extract_high_half (enum machine_mode mode, rtx op)\n \n   wider_mode = GET_MODE_WIDER_MODE (mode);\n   op = expand_shift (RSHIFT_EXPR, wider_mode, op,\n-\t\t     build_int_2 (GET_MODE_BITSIZE (mode), 0), 0, 1);\n+\t\t     build_int_cst (NULL_TREE,\n+\t\t\t\t    GET_MODE_BITSIZE (mode), 0), 0, 1);\n   return convert_modes (mode, wider_mode, op, 0);\n }\n \n@@ -3183,7 +3203,7 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n   int logd;\n \n   logd = floor_log2 (d);\n-  shift = build_int_2 (logd, 0);\n+  shift = build_int_cst (NULL_TREE, logd, 0);\n \n   if (d == 2 && BRANCH_COST >= 1)\n     {\n@@ -3230,7 +3250,8 @@ expand_sdiv_pow2 (enum machine_mode mode, rtx op0, HOST_WIDE_INT d)\n \t\t\t     NULL_RTX, 0, OPTAB_LIB_WIDEN);\n       else\n \ttemp = expand_shift (RSHIFT_EXPR, mode, temp,\n-\t\t\t     build_int_2 (ushift, 0), NULL_RTX, 1);\n+\t\t\t     build_int_cst (NULL_TREE, ushift, 0),\n+\t\t\t     NULL_RTX, 1);\n       temp = expand_binop (mode, add_optab, temp, op0, NULL_RTX,\n \t\t\t   0, OPTAB_LIB_WIDEN);\n       return expand_shift (RSHIFT_EXPR, mode, temp, shift, NULL_RTX, 0);\n@@ -3506,7 +3527,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n \t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t     build_int_2 (pre_shift, 0),\n+\t\t\t\t\t     build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t\t    pre_shift, 0),\n \t\t\t\t\t     tquotient, 1);\n \t\t  }\n \t\telse if (size <= HOST_BITS_PER_WIDE_INT)\n@@ -3562,15 +3584,18 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t    t2 = force_operand (gen_rtx_MINUS (compute_mode,\n \t\t\t\t\t\t\t       op0, t1),\n \t\t\t\t\t\tNULL_RTX);\n-\t\t\t    t3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t       build_int_2 (1, 0), NULL_RTX,1);\n+\t\t\t    t3 = expand_shift\n+\t\t\t      (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t       build_int_cst (NULL_TREE, 1, 0),\n+\t\t\t       NULL_RTX,1);\n \t\t\t    t4 = force_operand (gen_rtx_PLUS (compute_mode,\n \t\t\t\t\t\t\t      t1, t3),\n \t\t\t\t\t\tNULL_RTX);\n-\t\t\t    quotient\n-\t\t\t      = expand_shift (RSHIFT_EXPR, compute_mode, t4,\n-\t\t\t\t\t      build_int_2 (post_shift - 1, 0),\n-\t\t\t\t\t      tquotient, 1);\n+\t\t\t    quotient = expand_shift\n+\t\t\t      (RSHIFT_EXPR, compute_mode, t4,\n+\t\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t\t      post_shift - 1, 0),\n+\t\t\t       tquotient, 1);\n \t\t\t  }\n \t\t\telse\n \t\t\t  {\n@@ -3580,9 +3605,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t|| post_shift >= BITS_PER_WORD)\n \t\t\t      goto fail1;\n \n-\t\t\t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t       build_int_2 (pre_shift, 0),\n-\t\t\t\t\t       NULL_RTX, 1);\n+\t\t\t    t1 = expand_shift\n+\t\t\t      (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t       build_int_cst (NULL_TREE, pre_shift, 0),\n+\t\t\t       NULL_RTX, 1);\n \t\t\t    extra_cost\n \t\t\t      = (shift_cost[compute_mode][pre_shift]\n \t\t\t\t + shift_cost[compute_mode][post_shift]);\n@@ -3591,10 +3617,11 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t\t       max_cost - extra_cost);\n \t\t\t    if (t2 == 0)\n \t\t\t      goto fail1;\n-\t\t\t    quotient\n-\t\t\t      = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t      build_int_2 (post_shift, 0),\n-\t\t\t\t\t      tquotient, 1);\n+\t\t\t    quotient = expand_shift\n+\t\t\t      (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t\t      post_shift, 0),\n+\t\t\t       tquotient, 1);\n \t\t\t  }\n \t\t      }\n \t\t  }\n@@ -3700,10 +3727,14 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t1 == 0)\n \t\t\t  goto fail1;\n-\t\t\tt2 = expand_shift (RSHIFT_EXPR, compute_mode, t1,\n-\t\t\t\t\t   build_int_2 (post_shift, 0), NULL_RTX, 0);\n-\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t\tt2 = expand_shift\n+\t\t\t  (RSHIFT_EXPR, compute_mode, t1,\n+\t\t\t   build_int_cst (NULL_TREE, post_shift, 0),\n+\t\t\t   NULL_RTX, 0);\n+\t\t\tt3 = expand_shift\n+\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t   build_int_cst (NULL_TREE, size - 1, 0),\n+\t\t\t   NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n \t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n@@ -3735,12 +3766,14 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\tt2 = force_operand (gen_rtx_PLUS (compute_mode,\n \t\t\t\t\t\t\t  t1, op0),\n \t\t\t\t\t    NULL_RTX);\n-\t\t\tt3 = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t\t   build_int_2 (post_shift, 0),\n-\t\t\t\t\t   NULL_RTX, 0);\n-\t\t\tt4 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0),\n-\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tt3 = expand_shift\n+\t\t\t  (RSHIFT_EXPR, compute_mode, t2,\n+\t\t\t   build_int_cst (NULL_TREE, post_shift, 0),\n+\t\t\t   NULL_RTX, 0);\n+\t\t\tt4 = expand_shift\n+\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t   build_int_cst (NULL_TREE, size - 1, 0),\n+\t\t\t   NULL_RTX, 0);\n \t\t\tif (d < 0)\n \t\t\t  quotient\n \t\t\t    = force_operand (gen_rtx_MINUS (compute_mode,\n@@ -3794,9 +3827,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\tif (remainder)\n \t\t\t  return gen_lowpart (mode, remainder);\n \t\t      }\n-\t\t    quotient = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t     build_int_2 (pre_shift, 0),\n-\t\t\t\t\t     tquotient, 0);\n+\t\t    quotient = expand_shift\n+\t\t      (RSHIFT_EXPR, compute_mode, op0,\n+\t\t       build_int_cst (NULL_TREE, pre_shift, 0),\n+\t\t       tquotient, 0);\n \t\t  }\n \t\telse\n \t\t  {\n@@ -3810,9 +3844,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t    if (post_shift < BITS_PER_WORD\n \t\t\t&& size - 1 < BITS_PER_WORD)\n \t\t      {\n-\t\t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t\t   build_int_2 (size - 1, 0),\n-\t\t\t\t\t   NULL_RTX, 0);\n+\t\t\tt1 = expand_shift\n+\t\t\t  (RSHIFT_EXPR, compute_mode, op0,\n+\t\t\t   build_int_cst (NULL_TREE, size - 1, 0),\n+\t\t\t   NULL_RTX, 0);\n \t\t\tt2 = expand_binop (compute_mode, xor_optab, op0, t1,\n \t\t\t\t\t   NULL_RTX, 0, OPTAB_WIDEN);\n \t\t\textra_cost = (shift_cost[compute_mode][post_shift]\n@@ -3823,9 +3858,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t\t   max_cost - extra_cost);\n \t\t\tif (t3 != 0)\n \t\t\t  {\n-\t\t\t    t4 = expand_shift (RSHIFT_EXPR, compute_mode, t3,\n-\t\t\t\t\t       build_int_2 (post_shift, 0),\n-\t\t\t\t\t       NULL_RTX, 1);\n+\t\t\t    t4 = expand_shift\n+\t\t\t      (RSHIFT_EXPR, compute_mode, t3,\n+\t\t\t       build_int_cst (NULL_TREE, post_shift, 0),\n+\t\t\t       NULL_RTX, 1);\n \t\t\t    quotient = expand_binop (compute_mode, xor_optab,\n \t\t\t\t\t\t     t4, t1, tquotient, 0,\n \t\t\t\t\t\t     OPTAB_WIDEN);\n@@ -3840,8 +3876,10 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\t\t\t\t\t  op0, constm1_rtx), NULL_RTX);\n \t\tt2 = expand_binop (compute_mode, ior_optab, op0, t1, NULL_RTX,\n \t\t\t\t   0, OPTAB_WIDEN);\n-\t\tnsign = expand_shift (RSHIFT_EXPR, compute_mode, t2,\n-\t\t\t\t      build_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\tnsign = expand_shift\n+\t\t  (RSHIFT_EXPR, compute_mode, t2,\n+\t\t   build_int_cst (NULL_TREE, size - 1, 0),\n+\t\t   NULL_RTX, 0);\n \t\tt3 = force_operand (gen_rtx_MINUS (compute_mode, t1, nsign),\n \t\t\t\t    NULL_RTX);\n \t\tt4 = expand_divmod (0, TRUNC_DIV_EXPR, compute_mode, t3, op1,\n@@ -3955,7 +3993,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t   build_int_2 (floor_log2 (d), 0),\n+\t\t\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t  floor_log2 (d), 0),\n \t\t\t\t   tquotient, 1);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t   GEN_INT (d - 1),\n@@ -4053,7 +4092,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t\trtx t1, t2, t3;\n \t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n \t\tt1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t\t   build_int_2 (floor_log2 (d), 0),\n+\t\t\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t  floor_log2 (d), 0),\n \t\t\t\t   tquotient, 0);\n \t\tt2 = expand_binop (compute_mode, and_optab, op0,\n \t\t\t\t   GEN_INT (d - 1),\n@@ -4175,7 +4215,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    pre_shift = floor_log2 (d & -d);\n \t    ml = invert_mod2n (d >> pre_shift, size);\n \t    t1 = expand_shift (RSHIFT_EXPR, compute_mode, op0,\n-\t\t\t       build_int_2 (pre_shift, 0), NULL_RTX, unsignedp);\n+\t\t\t       build_int_cst (NULL_TREE, pre_shift, 0),\n+\t\t\t       NULL_RTX, unsignedp);\n \t    quotient = expand_mult (compute_mode, t1,\n \t\t\t\t    gen_int_mode (ml, compute_mode),\n \t\t\t\t    NULL_RTX, 1);\n@@ -4209,7 +4250,8 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t      }\n \t    tem = plus_constant (op1, -1);\n \t    tem = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n-\t\t\t\tbuild_int_2 (1, 0), NULL_RTX, 1);\n+\t\t\t\tbuild_int_cst (NULL_TREE, 1, 0),\n+\t\t\t\tNULL_RTX, 1);\n \t    do_cmp_and_jump (remainder, tem, LEU, compute_mode, label);\n \t    expand_inc (quotient, const1_rtx);\n \t    expand_dec (remainder, op1);\n@@ -4234,12 +4276,14 @@ expand_divmod (int rem_flag, enum tree_code code, enum machine_mode mode,\n \t    abs_rem = expand_abs (compute_mode, remainder, NULL_RTX, 1, 0);\n \t    abs_op1 = expand_abs (compute_mode, op1, NULL_RTX, 1, 0);\n \t    tem = expand_shift (LSHIFT_EXPR, compute_mode, abs_rem,\n-\t\t\t\tbuild_int_2 (1, 0), NULL_RTX, 1);\n+\t\t\t\tbuild_int_cst (NULL_TREE, 1, 0),\n+\t\t\t\tNULL_RTX, 1);\n \t    do_cmp_and_jump (tem, abs_op1, LTU, compute_mode, label);\n \t    tem = expand_binop (compute_mode, xor_optab, op0, op1,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    mask = expand_shift (RSHIFT_EXPR, compute_mode, tem,\n-\t\t\t\tbuild_int_2 (size - 1, 0), NULL_RTX, 0);\n+\t\t\t\t build_int_cst (NULL_TREE, size - 1, 0),\n+\t\t\t\t NULL_RTX, 0);\n \t    tem = expand_binop (compute_mode, xor_optab, mask, const1_rtx,\n \t\t\t\tNULL_RTX, 0, OPTAB_WIDEN);\n \t    tem = expand_binop (compute_mode, sub_optab, tem, mask,\n@@ -4382,20 +4426,23 @@ make_tree (tree type, rtx x)\n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n-      t = build_int_2 (INTVAL (x),\n-\t\t       (TYPE_UNSIGNED (type)\n-\t\t\t&& (GET_MODE_BITSIZE (TYPE_MODE (type))\n-\t\t\t    < HOST_BITS_PER_WIDE_INT))\n-\t\t       || INTVAL (x) >= 0 ? 0 : -1);\n-      TREE_TYPE (t) = type;\n-      return t;\n-\n+      {\n+\tHOST_WIDE_INT hi = 0;\n+\n+\tif (INTVAL (x) < 0\n+\t    && !(TYPE_UNSIGNED (type)\n+\t\t && (GET_MODE_BITSIZE (TYPE_MODE (type))\n+\t\t     < HOST_BITS_PER_WIDE_INT)))\n+\t  hi = -1;\n+      \n+\tt = build_int_cst (type, INTVAL (x), hi);\n+\t\n+\treturn t;\n+      }\n+      \n     case CONST_DOUBLE:\n       if (GET_MODE (x) == VOIDmode)\n-\t{\n-\t  t = build_int_2 (CONST_DOUBLE_LOW (x), CONST_DOUBLE_HIGH (x));\n-\t  TREE_TYPE (t) = type;\n-\t}\n+\tt = build_int_cst (type, CONST_DOUBLE_LOW (x), CONST_DOUBLE_HIGH (x));\n       else\n \t{\n \t  REAL_VALUE_TYPE d;"}, {"sha": "e6052633d34eb982bbc118bb223e1440ea1a4adc", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -646,8 +646,9 @@ convert_move (rtx to, rtx from, int unsignedp)\n \n \t  /* No suitable intermediate mode.\n \t     Generate what we need with\tshifts.  */\n-\t  shift_amount = build_int_2 (GET_MODE_BITSIZE (to_mode)\n-\t\t\t\t      - GET_MODE_BITSIZE (from_mode), 0);\n+\t  shift_amount = build_int_cst (NULL_TREE,\n+\t\t\t\t\tGET_MODE_BITSIZE (to_mode)\n+\t\t\t\t\t- GET_MODE_BITSIZE (from_mode), 0);\n \t  from = gen_lowpart (to_mode, force_reg (from_mode, from));\n \t  tmp = expand_shift (LSHIFT_EXPR, to_mode, from, shift_amount,\n \t\t\t      to, unsignedp);\n@@ -1712,7 +1713,8 @@ emit_group_load (rtx dst, rtx orig_src, tree type ATTRIBUTE_UNUSED, int ssize)\n \n       if (shift)\n \ttmps[i] = expand_shift (LSHIFT_EXPR, mode, tmps[i],\n-\t\t\t\tbuild_int_2 (shift, 0), tmps[i], 0);\n+\t\t\t\tbuild_int_cst (NULL_TREE,\n+\t\t\t\t\t       shift, 0), tmps[i], 0);\n     }\n \n   /* Copy the extracted pieces into the proper (probable) hard regs.  */\n@@ -1823,7 +1825,8 @@ emit_group_store (rtx orig_dst, rtx src, tree type ATTRIBUTE_UNUSED, int ssize)\n \t    {\n \t      int shift = (bytelen - (ssize - bytepos)) * BITS_PER_UNIT;\n \t      tmps[i] = expand_shift (RSHIFT_EXPR, mode, tmps[i],\n-\t\t\t\t      build_int_2 (shift, 0), tmps[i], 0);\n+\t\t\t\t      build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t     shift, 0), tmps[i], 0);\n \t    }\n \t  bytelen = ssize - bytepos;\n \t}\n@@ -3670,8 +3673,8 @@ expand_assignment (tree to, tree from, int want_value)\n \t\t\t\t      NULL_RTX);\n \t\t  binop = xor_optab;\n \t\t}\n-\t      value = expand_shift (LSHIFT_EXPR, GET_MODE (str_rtx),\n-\t\t\t\t    value, build_int_2 (bitpos1, 0),\n+\t      value = expand_shift (LSHIFT_EXPR, GET_MODE (str_rtx), value,\n+\t\t\t\t    build_int_cst (NULL_TREE,bitpos1, 0),\n \t\t\t\t    NULL_RTX, 1);\n \t      result = expand_binop (GET_MODE (str_rtx), binop, str_rtx,\n \t\t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n@@ -4582,7 +4585,8 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t      if (BYTES_BIG_ENDIAN)\n \t\tvalue\n \t\t  = fold (build2 (LSHIFT_EXPR, type, value,\n-\t\t\t\t  build_int_2 (BITS_PER_WORD - bitsize, 0)));\n+\t\t\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t BITS_PER_WORD - bitsize, 0)));\n \t      bitsize = BITS_PER_WORD;\n \t      mode = word_mode;\n \t    }\n@@ -5317,7 +5321,8 @@ store_field (rtx target, HOST_WIDE_INT bitsize, HOST_WIDE_INT bitpos,\n \t\t\t\t   gen_int_mode (width_mask, tmode),\n \t\t\t\t   NULL_RTX);\n \n-\t      count = build_int_2 (GET_MODE_BITSIZE (tmode) - bitsize, 0);\n+\t      count = build_int_cst (NULL_TREE,\n+\t\t\t\t     GET_MODE_BITSIZE (tmode) - bitsize, 0);\n \t      temp = expand_shift (LSHIFT_EXPR, tmode, temp, count, 0, 0);\n \t      return expand_shift (RSHIFT_EXPR, tmode, temp, count, 0, 0);\n \t    }\n@@ -6813,8 +6818,9 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t    else\n \t\t      {\n \t\t\ttree count\n-\t\t\t  = build_int_2 (GET_MODE_BITSIZE (imode) - bitsize,\n-\t\t\t\t\t 0);\n+\t\t\t  = build_int_cst (NULL_TREE,\n+\t\t\t\t\t   GET_MODE_BITSIZE (imode) - bitsize,\n+\t\t\t\t\t   0);\n \n \t\t\top0 = expand_shift (LSHIFT_EXPR, imode, op0, count,\n \t\t\t\t\t    target, 0);\n@@ -8279,7 +8285,8 @@ reduce_to_bit_field_precision (rtx exp, rtx target, tree type)\n     }\n   else\n     {\n-      tree count = build_int_2 (GET_MODE_BITSIZE (GET_MODE (exp)) - prec, 0);\n+      tree count = build_int_cst (NULL_TREE,\n+\t\t\t\t  GET_MODE_BITSIZE (GET_MODE (exp)) - prec, 0);\n       exp = expand_shift (LSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n       return expand_shift (RSHIFT_EXPR, GET_MODE (exp), exp, count, target, 0);\n     }"}, {"sha": "c404613f842b1e3ac914fb1c3e1b3cbc651e2c09", "filename": "gcc/fold-const.c", "status": "modified", "additions": 34, "deletions": 50, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -201,7 +201,8 @@ decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n   We return either the original T, or a copy.  */\n \n tree\n-force_fit_type (tree t, int overflowable, bool overflowed, bool overflowed_const)\n+force_fit_type (tree t, int overflowable,\n+\t\tbool overflowed, bool overflowed_const)\n {\n   unsigned HOST_WIDE_INT low;\n   HOST_WIDE_INT high;\n@@ -1417,10 +1418,7 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       && overflow == 0 && ! TREE_OVERFLOW (arg1) && ! TREE_OVERFLOW (arg2))\n     return size_int_type (low, type);\n   else\n-    {\n-      t = build_int_2 (low, hi);\n-      TREE_TYPE (t) = TREE_TYPE (arg1);\n-    }\n+    t = build_int_cst (TREE_TYPE (arg1), low, hi);\n \n   if (notrunc)\n     {\n@@ -1786,9 +1784,8 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \n \t  /* Given an integer constant, make new constant with new type,\n \t     appropriately sign-extended or truncated.  */\n-\t  t = build_int_2 (TREE_INT_CST_LOW (arg1),\n-\t\t\t   TREE_INT_CST_HIGH (arg1));\n-\t  TREE_TYPE (t) = type;\n+\t  t = build_int_cst (type, TREE_INT_CST_LOW (arg1),\n+\t\t\t     TREE_INT_CST_HIGH (arg1));\n \n \t  t = force_fit_type (t,\n \t\t\t      /* Don't set the overflow when\n@@ -1879,8 +1876,7 @@ fold_convert_const (enum tree_code code, tree type, tree arg1)\n \t  if (! overflow)\n \t    REAL_VALUE_TO_INT (&low, &high, r);\n \n-\t  t = build_int_2 (low, high);\n-\t  TREE_TYPE (t) = type;\n+\t  t = build_int_cst (type, low, high);\n \n \t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg1),\n \t\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n@@ -2954,7 +2950,8 @@ invert_truthvalue (tree arg)\n   switch (code)\n     {\n     case INTEGER_CST:\n-      return fold_convert (type, build_int_2 (integer_zerop (arg), 0));\n+      return fold_convert (type,\n+\t\t\t   build_int_cst (NULL_TREE, integer_zerop (arg), 0));\n \n     case TRUTH_AND_EXPR:\n       return build2 (TRUTH_OR_EXPR, type,\n@@ -3189,8 +3186,7 @@ optimize_bit_field_compare (enum tree_code code, tree compare_type,\n     lbitpos = nbitsize - lbitsize - lbitpos;\n \n   /* Make the mask to be used against the extracted field.  */\n-  mask = build_int_2 (~0, ~0);\n-  TREE_TYPE (mask) = unsigned_type;\n+  mask = build_int_cst (unsigned_type, ~0, ~0);\n   mask = force_fit_type (mask, 0, false, false);\n   mask = fold_convert (unsigned_type, mask);\n   mask = const_binop (LSHIFT_EXPR, mask, size_int (nbitsize - lbitsize), 0);\n@@ -3346,8 +3342,7 @@ decode_field_reference (tree exp, HOST_WIDE_INT *pbitsize,\n   unsigned_type = lang_hooks.types.type_for_size (*pbitsize, 1);\n   precision = TYPE_PRECISION (unsigned_type);\n \n-  mask = build_int_2 (~0, ~0);\n-  TREE_TYPE (mask) = unsigned_type;\n+  mask = build_int_cst (unsigned_type, ~0, ~0);\n   mask = force_fit_type (mask, 0, false, false);\n   \n   mask = const_binop (LSHIFT_EXPR, mask, size_int (precision - *pbitsize), 0);\n@@ -3373,8 +3368,7 @@ all_ones_mask_p (tree mask, int size)\n   unsigned int precision = TYPE_PRECISION (type);\n   tree tmask;\n \n-  tmask = build_int_2 (~0, ~0);\n-  TREE_TYPE (tmask) = lang_hooks.types.signed_type (type);\n+  tmask = build_int_cst (lang_hooks.types.signed_type (type), ~0, ~0);\n   tmask = force_fit_type (tmask, 0, false, false);\n   \n   return\n@@ -5362,12 +5356,7 @@ constant_boolean_node (int value, tree type)\n     return lang_hooks.truthvalue_conversion (value ? integer_one_node\n \t\t\t\t\t\t   : integer_zero_node);\n   else\n-    {\n-      tree t = build_int_2 (value, 0);\n-\n-      TREE_TYPE (t) = type;\n-      return t;\n-    }\n+    return build_int_cst (type, value, 0);\n }\n \n /* Transform `a + (b ? x : y)' into `b ? (a + x) : (a + y)'.\n@@ -5700,8 +5689,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t TREE_INT_CST_HIGH (arg01),\n \t\t\t TREE_INT_CST_LOW (arg1),\n \t\t\t TREE_INT_CST_HIGH (arg1), &lpart, &hpart);\n-  prod = build_int_2 (lpart, hpart);\n-  TREE_TYPE (prod) = TREE_TYPE (arg00);\n+  prod = build_int_cst (TREE_TYPE (arg00), lpart, hpart);\n   prod = force_fit_type (prod, -1, overflow, false);\n \n   if (TYPE_UNSIGNED (TREE_TYPE (arg0)))\n@@ -5715,8 +5703,7 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t     TREE_INT_CST_LOW (tmp),\n \t\t\t     TREE_INT_CST_HIGH (tmp),\n \t\t\t     &lpart, &hpart);\n-      hi = build_int_2 (lpart, hpart);\n-      TREE_TYPE (hi) = TREE_TYPE (arg00);\n+      hi = build_int_cst (TREE_TYPE (arg00), lpart, hpart);\n       hi = force_fit_type (hi, -1, overflow | TREE_OVERFLOW (prod),\n \t\t\t   TREE_CONSTANT_OVERFLOW (prod));\n     }\n@@ -6623,7 +6610,8 @@ fold (tree expr)\n \t\t  if (exact_log2 (int11) > 0 && int01 % int11 == 0)\n \t\t    {\n \t\t      alt0 = fold (build2 (MULT_EXPR, type, arg00,\n-\t\t\t\t\t   build_int_2 (int01 / int11, 0)));\n+\t\t\t\t\t   build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t\t  int01 / int11, 0)));\n \t\t      alt1 = arg10;\n \t\t      same = arg11;\n \t\t    }\n@@ -7257,8 +7245,7 @@ fold (tree expr)\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n \t{\n-\t  t1 = build_int_2 (-1, -1);\n-\t  TREE_TYPE (t1) = type;\n+\t  t1 = build_int_cst (type, -1, -1);\n \t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg1);\n \t}\n@@ -7267,8 +7254,7 @@ fold (tree expr)\n       if (TREE_CODE (arg1) == BIT_NOT_EXPR\n \t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n \t{\n-\t  t1 = build_int_2 (-1, -1);\n-\t  TREE_TYPE (t1) = type;\n+\t  t1 = build_int_cst (type, -1, -1);\n \t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg0);\n \t}\n@@ -7308,8 +7294,7 @@ fold (tree expr)\n       if (TREE_CODE (arg0) == BIT_NOT_EXPR\n \t  && operand_equal_p (TREE_OPERAND (arg0, 0), arg1, 0))\n \t{\n-\t  t1 = build_int_2 (-1, -1);\n-\t  TREE_TYPE (t1) = type;\n+\t  t1 = build_int_cst (type, -1, -1);\n \t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg1);\n \t}\n@@ -7318,8 +7303,7 @@ fold (tree expr)\n       if (TREE_CODE (arg1) == BIT_NOT_EXPR\n \t  && operand_equal_p (arg0, TREE_OPERAND (arg1, 0), 0))\n \t{\n-\t  t1 = build_int_2 (-1, -1);\n-\t  TREE_TYPE (t1) = type;\n+\t  t1 = build_int_cst (type, -1, -1);\n \t  t1 = force_fit_type (t1, 0, false, false);\n \t  return omit_one_operand (type, t1, arg0);\n \t}\n@@ -7639,8 +7623,7 @@ fold (tree expr)\n \t      low = ((unsigned HOST_WIDE_INT) 1 << l) - 1;\n \t    }\n \n-\t  mask = build_int_2 (low, high);\n-\t  TREE_TYPE (mask) = type;\n+\t  mask = build_int_cst (type, low, high);\n \t  return fold (build2 (BIT_AND_EXPR, type,\n \t\t\t       fold_convert (type, arg0), mask));\n \t}\n@@ -7698,7 +7681,8 @@ fold (tree expr)\n \t RROTATE_EXPR by a new constant.  */\n       if (code == LROTATE_EXPR && TREE_CODE (arg1) == INTEGER_CST)\n \t{\n-\t  tree tem = build_int_2 (GET_MODE_BITSIZE (TYPE_MODE (type)), 0);\n+\t  tree tem = build_int_cst (NULL_TREE,\n+\t\t\t\t    GET_MODE_BITSIZE (TYPE_MODE (type)), 0);\n \t  tem = fold_convert (TREE_TYPE (arg1), tem);\n \t  tem = const_binop (MINUS_EXPR, tem, arg1, 0);\n \t  return fold (build2 (RROTATE_EXPR, type, arg0, tem));\n@@ -8115,8 +8099,9 @@ fold (tree expr)\n \t\t  || integer_onep (folded_compare))\n \t\treturn omit_one_operand (type, folded_compare, varop);\n \n-\t      shift = build_int_2 (TYPE_PRECISION (TREE_TYPE (varop)) - size,\n-\t\t\t\t   0);\n+\t      shift = build_int_cst (NULL_TREE,\n+\t\t\t\t     TYPE_PRECISION (TREE_TYPE (varop)) - size,\n+\t\t\t\t     0);\n \t      shift = fold_convert (TREE_TYPE (varop), shift);\n \t      newconst = fold (build2 (LSHIFT_EXPR, TREE_TYPE (varop),\n \t\t\t\t       newconst, shift));\n@@ -10336,8 +10321,9 @@ fold_read_from_constant_string (tree exp)\n \t      == MODE_INT)\n \t  && (GET_MODE_SIZE (TYPE_MODE (TREE_TYPE (TREE_TYPE (string)))) == 1))\n \treturn fold_convert (TREE_TYPE (exp),\n-\t\t\t     build_int_2 ((TREE_STRING_POINTER (string)\n-\t\t\t\t\t  [TREE_INT_CST_LOW (index)]), 0));\n+\t\t\t     build_int_cst (NULL_TREE,\n+\t\t\t\t\t    (TREE_STRING_POINTER (string)\n+\t\t\t\t\t     [TREE_INT_CST_LOW (index)]), 0));\n     }\n   return NULL;\n }\n@@ -10359,8 +10345,7 @@ fold_negate_const (tree arg0, tree type)\n       int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n \t\t\t\t TREE_INT_CST_HIGH (arg0),\n \t\t\t\t &low, &high);\n-      t = build_int_2 (low, high);\n-      TREE_TYPE (t) = type;\n+      t = build_int_cst (type, low, high);\n       t = force_fit_type (t, 1,\n \t\t\t  (overflow | TREE_OVERFLOW (arg0))\n \t\t\t  && !TYPE_UNSIGNED (type),\n@@ -10404,8 +10389,7 @@ fold_abs_const (tree arg0, tree type)\n \t  int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n \t\t\t\t     TREE_INT_CST_HIGH (arg0),\n \t\t\t\t     &low, &high);\n-\t  t = build_int_2 (low, high);\n-\t  TREE_TYPE (t) = type;\n+\t  t = build_int_cst (type, low, high);\n \t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg0),\n \t\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n \t  return t;\n@@ -10436,9 +10420,9 @@ fold_not_const (tree arg0, tree type)\n \n   if (TREE_CODE (arg0) == INTEGER_CST)\n     {\n-      t = build_int_2 (~ TREE_INT_CST_LOW (arg0),\n-\t\t       ~ TREE_INT_CST_HIGH (arg0));\n-      TREE_TYPE (t) = type;\n+      t = build_int_cst (type,\n+\t\t\t ~ TREE_INT_CST_LOW (arg0),\n+\t\t\t ~ TREE_INT_CST_HIGH (arg0));\n       t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n \t\t\t  TREE_CONSTANT_OVERFLOW (arg0));\n     }"}, {"sha": "460263611f3ce0c81d66c99d1931c41b5c58edff", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,20 @@\n+2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* trans-array.c (gfc_trans_array_constructor_value): Use\n+\tbuild_int_cst. \n+\t* trans-const.c (gfc_build_string_const,\n+\tgfc_init_constants, gfc_conv_mpz_to_tree,\n+\tgfc_conv_constant_to_tree): Likewise. \n+\t* trans-decl.c (gfc_get_symbol_decl): Likewise.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_ibits,\n+\tgfc_conv_intrinsic_len, prepare_arg_info): Likewise.\n+\t* trans-io.c (add_case, set_error_locus, build_dt,\n+\ttransfer_expr): Likewise.\n+\t* trans-stmt.c (gfc_trans_label_assign, gfc_trans_pause,\n+\tgfc_trans_stop, gfc_trans_character_select): Likewise.\n+\t* trans-types.c (gfc_init_types, gfc_get_dtype): Likewise.\n+\t* trans.c (gfc_trans_runtime_check): Likewise.\n+\n 2004-08-14  Paul Brook  <paul@codesourcery.com>\n \n \t* trans-decl.c (gfc_build_function_decl): Remove dead code.\n@@ -957,7 +974,7 @@\n \t* symbol.c (gfc_add_common): Disable checks to work around other more\n \tfundamental inadequacies.\n \n-2004-05-22  Tobias Schl\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n+2004-05-22  Tobias Schl\u00fcter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-decl.c (gfc_get_extern_function_decl): Set DECL_IS_PURE\n \tonly for functions.\n@@ -1165,7 +1182,7 @@\n \n \t* decl.c (variable_decl): Always apply default initializer.\n \n-2004-05-08  Tobias Schl\ufffdter <tobias.schlueter@physik.uni-muenchen.de>\n+2004-05-08  Tobias Schl\u00fcter <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/15206\n \t* trans-intrinsic.c (gfc_conv_intrinsic_rrspacing): Fixed to\n@@ -1239,7 +1256,7 @@\n \tRemove \"set DEVELOPMENT\".\n \t(Compiling GFORTRAN): Remove.\n \n-2004-05-09  Tobias Schl\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n+2004-05-09  Tobias Schl\u00fcter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* array.c (match_subscript, match_array_ref): Add comments\n \texplaining argument 'init'.\n@@ -1249,20 +1266,20 @@\n \t* primary.c (match_digits, match_integer_constant): Add comment\n \texplaining signflag.\n \n-2004-05-01  Tobias Schl\ufffdter <tobias.schlueter@physik.uni-muenchen.de>\n+2004-05-01  Tobias Schl\u00fcter <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/13940\n \t* primary.c: Include system.h and flags.h, needed for pedantic.\n \t(match_boz_constant): Allow \"x\" for hexadecimal constants, warn if\n \tpedantic is set.\n \n-2004-05-01  Tobias Schl\ufffdter <tobias.schlueter@physik.uni-muenchen.de>\n+2004-05-01  Tobias Schl\u00fcter <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/13940\n \t* match.c (match_data_constant): Handle case where\n \tgfc_find_symbol\tsets sym to NULL\n \n-2004-04-28  Tobias Schl\ufffdter <tobias.schlueter@physik.uni-muenchen.de>\n+2004-04-28  Tobias Schl\u00fcter <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* Make-lang.in (f95-lang.o, trans-intrinsic.o): Add missing\n \tdependency on mathbuiltins.def\n@@ -1276,7 +1293,7 @@\n \n \t* gfortranspec.c: Do not include multilib.h.\n \n-2004-04-24  Tobias Schl\ufffdter  <tobias.schlueter@physik.uni-muenchen.de>\n+2004-04-24  Tobias Schl\u00fcter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-intrinsic.c: Fix comment, this is not trans-expr.c. Add\n \t2004 to copyright years."}, {"sha": "a6dea46b9c0d6afa72bb2963e646b83069726712", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -796,7 +796,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t\t  p = p->next;\n \t\t}\n \n-\t      bound = build_int_2 (n - 1, 0);\n+\t      bound = build_int_cst (NULL_TREE, n - 1, 0);\n               /* Create an array type to hold them.  */\n \t      tmptype = build_range_type (gfc_array_index_type,\n \t\t\t\t\t  gfc_index_zero_node, bound);\n@@ -821,7 +821,7 @@ gfc_trans_array_constructor_value (stmtblock_t * pblock, tree type,\n \t      init = gfc_build_addr_expr (NULL, init);\n \n \t      size = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (type));\n-\t      bound = build_int_2 (n * size, 0);\n+\t      bound = build_int_cst (NULL_TREE, n * size, 0);\n \t      tmp = gfc_chainon_list (NULL_TREE, tmp);\n \t      tmp = gfc_chainon_list (tmp, init);\n \t      tmp = gfc_chainon_list (tmp, bound);"}, {"sha": "68b8d59ffd99b670cd25937ca9d354931ba7c6fc", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -81,7 +81,7 @@ gfc_build_string_const (int length, const char *s)\n   tree len;\n \n   str = build_string (length, s);\n-  len = build_int_2 (length, 0);\n+  len = build_int_cst (NULL_TREE, length, 0);\n   TREE_TYPE (str) =\n     build_array_type (gfc_character1_type_node,\n \t\t      build_range_type (gfc_strlen_type_node,\n@@ -145,10 +145,7 @@ gfc_init_constants (void)\n   int n;\n \n   for (n = 0; n <= GFC_MAX_DIMENSIONS; n++)\n-    {\n-      gfc_rank_cst[n] = build_int_2 (n, 0);\n-      TREE_TYPE (gfc_rank_cst[n]) = gfc_array_index_type;\n-    }\n+    gfc_rank_cst[n] = build_int_cst (gfc_array_index_type, n, 0);\n \n   gfc_strconst_bounds = gfc_build_string_const (21, \"Array bound mismatch\");\n \n@@ -182,8 +179,8 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n   if (mpz_fits_slong_p (i))\n     {\n       val = mpz_get_si (i);\n-      res = build_int_2 (val, (val < 0) ? (HOST_WIDE_INT)-1 : 0);\n-      TREE_TYPE (res) = gfc_get_int_type (kind);\n+      res = build_int_cst (gfc_get_int_type (kind),\n+\t\t\t   val, (val < 0) ? (HOST_WIDE_INT)-1 : 0);\n       return (res);\n     }\n \n@@ -220,8 +217,7 @@ gfc_conv_mpz_to_tree (mpz_t i, int kind)\n       high = (high << 4) + (low >> (BITS_PER_HOST_WIDE_INT - 4));\n       low = (low << 4) + n;\n     }\n-  res = build_int_2 (low, high);\n-  TREE_TYPE (res) = gfc_get_int_type (kind);\n+  res = build_int_cst (gfc_get_int_type (kind), low, high);\n   if (negate)\n     res = fold (build1 (NEGATE_EXPR, TREE_TYPE (res), res));\n \n@@ -324,7 +320,7 @@ gfc_conv_constant_to_tree (gfc_expr * expr)\n       return gfc_conv_mpfr_to_tree (expr->value.real, expr->ts.kind);\n \n     case BT_LOGICAL:\n-      return build_int_2 (expr->value.logical, 0);\n+      return build_int_cst (NULL_TREE, expr->value.logical, 0);\n \n     case BT_COMPLEX:\n       {"}, {"sha": "ef802ecee7fc28d441820105fed86eb12967ee22", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -798,7 +798,7 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n           ASSIGN_ADDR can not be used. Equal -1 means that ASSIGN_ADDR is the\n           target label's address. Other value is the length of format string\n           and ASSIGN_ADDR is the address of format string.  */\n-      DECL_INITIAL (length) = build_int_2 (-2, -1);\n+      DECL_INITIAL (length) = build_int_cst (NULL_TREE, -2, -1);\n     }\n \n   if (sym->ts.type == BT_CHARACTER)"}, {"sha": "c580cd4a42b7af380eba2d68f1ce3d892c58be5c", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1760,7 +1760,7 @@ gfc_conv_intrinsic_ibits (gfc_se * se, gfc_expr * expr)\n   arg2 = TREE_VALUE (arg2);\n   type = TREE_TYPE (arg);\n \n-  mask = build_int_2 (-1, ~(unsigned HOST_WIDE_INT) 0);\n+  mask = build_int_cst (NULL_TREE, -1, ~(unsigned HOST_WIDE_INT) 0);\n   mask = build (LSHIFT_EXPR, type, mask, arg3);\n   mask = build1 (BIT_NOT_EXPR, type, mask);\n \n@@ -1884,7 +1884,7 @@ gfc_conv_intrinsic_len (gfc_se * se, gfc_expr * expr)\n   switch (arg->expr_type)\n     {\n     case EXPR_CONSTANT:\n-      len = build_int_2 (arg->value.character.length, 0);\n+      len = build_int_cst (NULL_TREE, arg->value.character.length, 0);\n       break;\n \n     default:\n@@ -2329,9 +2329,9 @@ void prepare_arg_info (gfc_se * se, gfc_expr * expr,\n \n    /* Caculate the numbers of bits of exponent, fraction and word  */\n    n = gfc_validate_kind (a1->ts.type, a1->ts.kind);\n-   tmp = build_int_2 (gfc_real_kinds[n].digits - 1, 0);\n+   tmp = build_int_cst (NULL_TREE, gfc_real_kinds[n].digits - 1, 0);\n    rcs->fdigits = convert (masktype, tmp);\n-   wbits = build_int_2 (TYPE_PRECISION (rcs->type) - 1, 0);\n+   wbits = build_int_cst (NULL_TREE, TYPE_PRECISION (rcs->type) - 1, 0);\n    wbits = convert (masktype, wbits);\n    rcs->edigits = fold (build (MINUS_EXPR, masktype, wbits, tmp));\n "}, {"sha": "8df23edabca142cd7ccd7ee1c122319c0717d10e", "filename": "gcc/fortran/trans-io.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -450,7 +450,7 @@ add_case (int label_value, gfc_st_label * label, stmtblock_t * body)\n   if (label == NULL)\n     return;\t\t\t/* No label, no case */\n \n-  value = build_int_2 (label_value, 0);\n+  value = build_int_cst (NULL_TREE, label_value, 0);\n \n   /* Make a backend label for this case.  */\n   tmp = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n@@ -523,7 +523,7 @@ set_error_locus (stmtblock_t * block, locus * where)\n   gfc_add_modify_expr (block, locus_file, tmp);\n \n   line = where->lb->linenum;\n-  gfc_add_modify_expr (block, locus_line, build_int_2 (line, 0));\n+  gfc_add_modify_expr (block, locus_line, build_int_cst (NULL_TREE, line, 0));\n }\n \n \n@@ -943,7 +943,7 @@ build_dt (tree * function, gfc_code * code)\n           args = gfc_chainon_list (NULL_TREE, se.expr);\n           args = gfc_chainon_list (args, se2.expr);\n           args = gfc_chainon_list (args, se2.string_length);\n-          arg2 = build_int_2 (ts_kind, 0);\n+          arg2 = build_int_cst (NULL_TREE, ts_kind, 0);\n           args = gfc_chainon_list (args,arg2);\n           switch (ts_type)\n             {\n@@ -1096,22 +1096,22 @@ transfer_expr (gfc_se * se, gfc_typespec * ts, tree addr_expr)\n   switch (ts->type)\n     {\n     case BT_INTEGER:\n-      arg2 = build_int_2 (kind, 0);\n+      arg2 = build_int_cst (NULL_TREE, kind, 0);\n       function = iocall_x_integer;\n       break;\n \n     case BT_REAL:\n-      arg2 = build_int_2 (kind, 0);\n+      arg2 = build_int_cst (NULL_TREE, kind, 0);\n       function = iocall_x_real;\n       break;\n \n     case BT_COMPLEX:\n-      arg2 = build_int_2 (kind, 0);\n+      arg2 = build_int_cst (NULL_TREE, kind, 0);\n       function = iocall_x_complex;\n       break;\n \n     case BT_LOGICAL:\n-      arg2 = build_int_2 (kind, 0);\n+      arg2 = build_int_cst (NULL_TREE, kind, 0);\n       function = iocall_x_logical;\n       break;\n "}, {"sha": "261bf77d1d4da65405f555325c153ce1395df51c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -113,7 +113,7 @@ gfc_trans_label_assign (gfc_code * code)\n     {\n       label_str = code->label->format->value.character.string;\n       label_len = code->label->format->value.character.length;\n-      len_tree = build_int_2 (label_len, 0);\n+      len_tree = build_int_cst (NULL_TREE, label_len, 0);\n       label_tree = gfc_build_string_const (label_len + 1, label_str);\n       label_tree = gfc_build_addr_expr (pchar_type_node, label_tree);\n     }\n@@ -279,8 +279,7 @@ gfc_trans_pause (gfc_code * code)\n \n   if (code->expr == NULL)\n     {\n-      tmp = build_int_2 (code->ext.stop_code, 0);\n-      TREE_TYPE (tmp) = gfc_int4_type_node;\n+      tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code, 0);\n       args = gfc_chainon_list (NULL_TREE, tmp);\n       fndecl = gfor_fndecl_pause_numeric;\n     }\n@@ -319,8 +318,7 @@ gfc_trans_stop (gfc_code * code)\n \n   if (code->expr == NULL)\n     {\n-      tmp = build_int_2 (code->ext.stop_code, 0);\n-      TREE_TYPE (tmp) = gfc_int4_type_node;\n+      tmp = build_int_cst (gfc_int4_type_node, code->ext.stop_code, 0);\n       args = gfc_chainon_list (NULL_TREE, tmp);\n       fndecl = gfor_fndecl_stop_numeric;\n     }\n@@ -1093,8 +1091,8 @@ gfc_trans_character_select (gfc_code *code)\n       init = tree_cons (NULL_TREE, tmp, init);\n     }\n \n-  type = build_array_type (select_struct,\n-                           build_index_type (build_int_2(n - 1, 0)));\n+  type = build_array_type (select_struct, build_index_type\n+\t\t\t   (build_int_cst (NULL_TREE, n - 1, 0)));\n \n   init = build1 (CONSTRUCTOR, type, nreverse(init));\n   TREE_CONSTANT (init) = 1;\n@@ -1112,7 +1110,7 @@ gfc_trans_character_select (gfc_code *code)\n   init = gfc_build_addr_expr (pvoid_type_node, init);\n   args = gfc_chainon_list (NULL_TREE, init);\n \n-  tmp = build_int_2 (n, 0);\n+  tmp = build_int_cst (NULL_TREE, n, 0);\n   args = gfc_chainon_list (args, tmp);\n \n   tmp = gfc_build_addr_expr (pvoid_type_node, end_label);"}, {"sha": "b01298deb93f0dd07618bf8f80a081d09bbebbd4", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -168,16 +168,13 @@ gfc_init_types (void)\n       hi = 0;\n       lo = (~(unsigned HOST_WIDE_INT) 0) >> (sizeof (HOST_WIDE_INT) * 8 - n);\n     }\n-  gfc_max_array_element_size = build_int_2 (lo, hi);\n-  TREE_TYPE (gfc_max_array_element_size) = long_unsigned_type_node;\n+  gfc_max_array_element_size = build_int_cst (long_unsigned_type_node, lo, hi);\n \n   size_type_node = gfc_array_index_type;\n   boolean_type_node = gfc_get_logical_type (gfc_default_logical_kind ());\n \n-  boolean_true_node = build_int_2 (1, 0);\n-  TREE_TYPE (boolean_true_node) = boolean_type_node;\n-  boolean_false_node = build_int_2 (0, 0);\n-  TREE_TYPE (boolean_false_node) = boolean_type_node;\n+  boolean_true_node = build_int_cst (boolean_type_node, 1, 0);\n+  boolean_false_node = build_int_cst (boolean_type_node, 0, 0);\n }\n \n /* Get a type node for an integer kind */\n@@ -600,13 +597,11 @@ gfc_get_dtype (tree type, int rank)\n \n       i += TREE_INT_CST_LOW (size) << GFC_DTYPE_SIZE_SHIFT;\n     }\n-  dtype = build_int_2 (i, 0);\n-  TREE_TYPE (dtype) = gfc_array_index_type;\n+  dtype = build_int_cst (gfc_array_index_type, i, 0);\n \n   if (size && !INTEGER_CST_P (size))\n     {\n-      tmp = build_int_2 (GFC_DTYPE_SIZE_SHIFT, 0);\n-      TREE_TYPE (tmp) = gfc_array_index_type;\n+      tmp = build_int_cst (gfc_array_index_type, GFC_DTYPE_SIZE_SHIFT, 0);\n       tmp  = fold (build (LSHIFT_EXPR, gfc_array_index_type, size, tmp));\n       dtype = fold (build (PLUS_EXPR, gfc_array_index_type, tmp, dtype));\n     }"}, {"sha": "052da5525a401028b4295a87e23376f3a704f0d2", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -365,7 +365,7 @@ gfc_trans_runtime_check (tree cond, tree msg, stmtblock_t * pblock)\n   tmp = gfc_build_addr_expr (pchar_type_node, gfc_strconst_current_filename);\n   args = gfc_chainon_list (args, tmp);\n \n-  tmp = build_int_2 (input_line, 0);\n+  tmp = build_int_cst (NULL_TREE, input_line, 0);\n   args = gfc_chainon_list (args, tmp);\n \n   tmp = gfc_build_function_call (gfor_fndecl_runtime_error, args);"}, {"sha": "de40361410fccdaab117bf87a229c677348e02a9", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2618,7 +2618,8 @@ assign_parm_setup_block (tree parm, struct assign_parm_data_one *data)\n \t      rtx reg = gen_rtx_REG (word_mode, REGNO (data->entry_parm));\n \n \t      x = expand_shift (LSHIFT_EXPR, word_mode, reg,\n-\t\t\t\tbuild_int_2 (by, 0), NULL_RTX, 1);\n+\t\t\t\tbuild_int_cst (NULL_TREE, by, 0),\n+\t\t\t\tNULL_RTX, 1);\n \t      tem = change_address (mem, word_mode, 0);\n \t      emit_move_insn (tem, x);\n \t    }"}, {"sha": "493a5f3c2f777b24ca1a526fbd394f6cf919edae", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,25 @@\n+2004-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* boehm.c (get_boehm_type_descriptor): Use build_int_cst.\n+\t* class.c (build_utf8_ref, build_static_field_ref,\n+\tmake_field_value, make_method_value, get_dispatch_table,\n+\tmake_class_data, emit_symbol_table, emit_catch_table): Likewise.\n+\t* constants.c (get_tag_node,  build_ref_from_constant_pool, \n+\tbuild_constants_constructor): Likewise.\n+\t* decl.c (java_init_decl_processing): Likewise.\n+\t* expr.c (build_java_array_length_access, build_newarray,\n+\texpand_java_multianewarray, expand_java_pushc, expand_iinc,\n+\tbuild_java_binop, build_field_ref, expand_java_add_case,\n+\texpand_java_call, build_known_method_ref, build_invokevirtual,\n+\tbuild_invokeinterface, build_jni_stub): Likewise.\n+\t* java-gimplify.c (java_gimplify_new_array_init): Likewise.\n+\t* jcf-parse.c (get_constant): Likewise.\n+\t* lex.c (do_java_lex): Likewise.\n+\t* parse.y (patch_binop, patch_unaryop, patch_cast,\n+\tbuild_null_of_type, patch_newarray): Likewise.\n+\t* resource.c (compile_resource_data): Likewise.\n+\t* typeck.c (build_prim_array_type): Likewise.\n+\n 2004-08-10  Bryce McKinlay  <mckinlay@redhat.com>\n \n \t* java-gimplify.c (java_gimplify_new_array_init): Use create_tmp_var."}, {"sha": "ae2fbfa342800c5524082de46b31abe36001d15e", "filename": "gcc/java/boehm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fboehm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fboehm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fboehm.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -146,12 +146,13 @@ get_boehm_type_descriptor (tree type)\n   HOST_WIDE_INT last_view_index = -1;\n   int pointer_after_end = 0;\n   unsigned HOST_WIDE_INT low = 0, high = 0;\n-  tree field, value;\n+  tree field, value, value_type;\n \n   /* If the GC wasn't requested, just use a null pointer.  */\n   if (! flag_use_boehm_gc)\n     return null_pointer_node;\n \n+  value_type = java_type_for_mode (ptr_mode, 1);\n   /* If we have a type of unknown size, use a proc.  */\n   if (int_size_in_bytes (type) == -1)\n     goto procedure_object_descriptor;\n@@ -205,13 +206,13 @@ get_boehm_type_descriptor (tree type)\n \t  last_set_index >>= 1;\n \t  ++count;\n \t}\n-      value = build_int_2 (low, high);\n+      value = build_int_cst (value_type, low, high);\n     }\n   else if (! pointer_after_end)\n     {\n       /* Bottom two bits for bitmap mark type are 01.  */\n       set_bit (&low, &high, 0);\n-      value = build_int_2 (low, high);\n+      value = build_int_cst (value_type, low, high);\n     }\n   else\n     {\n@@ -222,9 +223,8 @@ get_boehm_type_descriptor (tree type)\n \t    | DS_PROC)\n \t Here DS_PROC == 2.  */\n     procedure_object_descriptor:\n-      value = build_int_2 (2, 0);\n+      value = build_int_cst (value_type, 2, 0);\n     }\n \n-  TREE_TYPE (value) = java_type_for_mode (ptr_mode, 1);\n   return value;\n }"}, {"sha": "b8b4c9035833f1886951641f55ec16e68f048917", "filename": "gcc/java/class.c", "status": "modified", "additions": 28, "deletions": 23, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -880,8 +880,8 @@ build_utf8_ref (tree name)\n   FINISH_RECORD (ctype);\n   START_RECORD_CONSTRUCTOR (cinit, ctype);\n   name_hash = hashUtf8String (name_ptr, name_len) & 0xFFFF;\n-  PUSH_FIELD_VALUE (cinit, \"hash\", build_int_2 (name_hash, 0));\n-  PUSH_FIELD_VALUE (cinit, \"length\", build_int_2 (name_len, 0));\n+  PUSH_FIELD_VALUE (cinit, \"hash\", build_int_cst (NULL_TREE, name_hash, 0));\n+  PUSH_FIELD_VALUE (cinit, \"length\", build_int_cst (NULL_TREE, name_len, 0));\n   string = build_string (name_len, name_ptr);\n   TREE_TYPE (string) = str_type;\n   PUSH_FIELD_VALUE (cinit, \"data\", string);\n@@ -1081,8 +1081,8 @@ build_static_field_ref (tree fdecl)\n   if (flag_indirect_dispatch)\n     {\n       tree table_index \n-\t= build_int_2 (get_symbol_table_index \n-\t\t       (fdecl, &TYPE_ATABLE_METHODS (output_class)), 0);\n+\t= build_int_cst (NULL_TREE, get_symbol_table_index \n+\t\t\t (fdecl, &TYPE_ATABLE_METHODS (output_class)), 0);\n       tree field_address\n \t= build4 (ARRAY_REF, build_pointer_type (TREE_TYPE (fdecl)), \n \t\t  TYPE_ATABLE_DECL (output_class), table_index,\n@@ -1114,7 +1114,7 @@ build_static_field_ref (tree fdecl)\n \t}\n       field_index *= int_size_in_bytes (field_type_node);\n       ref = fold (build2 (PLUS_EXPR, field_ptr_type_node,\n-\t\t\t  ref, build_int_2 (field_index, 0)));\n+\t\t\t  ref, build_int_cst (NULL_TREE, field_index, 0)));\n       ref = build1 (INDIRECT_REF, field_type_node, ref);\n       ref = build3 (COMPONENT_REF, field_info_union_node,\n \t\t    ref, lookup_field (&field_type_node, info_ident),\n@@ -1224,7 +1224,7 @@ make_field_value (tree fdecl)\n   if (! resolved)\n     flags |= 0x8000 /* FIELD_UNRESOLVED_FLAG */;\n \n-  PUSH_FIELD_VALUE (finit, \"accflags\", build_int_2 (flags, 0));\n+  PUSH_FIELD_VALUE (finit, \"accflags\", build_int_cst (NULL_TREE, flags, 0));\n   PUSH_FIELD_VALUE (finit, \"bsize\", TYPE_SIZE_UNIT (TREE_TYPE (fdecl)));\n \n   PUSH_FIELD_VALUE\n@@ -1256,7 +1256,8 @@ make_method_value (tree mdecl)\n   class_decl = DECL_CONTEXT (mdecl);\n   /* For interfaces, the index field contains the dispatch index. */\n   if (CLASS_INTERFACE (TYPE_NAME (class_decl)))\n-    index = build_int_2 (get_interface_method_index (mdecl, class_decl), 0);\n+    index = build_int_cst (NULL_TREE,\n+\t\t\t   get_interface_method_index (mdecl, class_decl), 0);\n   else if (!flag_indirect_dispatch && get_method_index (mdecl) != NULL_TREE)\n     index = get_method_index (mdecl);\n   else\n@@ -1278,7 +1279,7 @@ make_method_value (tree mdecl)\n \t\t\t(IDENTIFIER_POINTER(signature),\n \t\t\t IDENTIFIER_LENGTH(signature)))));\n   }\n-  PUSH_FIELD_VALUE (minit, \"accflags\", build_int_2 (accflags, 0));\n+  PUSH_FIELD_VALUE (minit, \"accflags\", build_int_cst (NULL_TREE, accflags, 0));\n   PUSH_FIELD_VALUE (minit, \"index\", index);\n   PUSH_FIELD_VALUE (minit, \"ncode\", code);\n \n@@ -1391,7 +1392,7 @@ get_dispatch_table (tree type, tree this_class_addr)\n \t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n \t      {\n \t\ttree fdesc = build2 (FDESC_EXPR, nativecode_ptr_type_node, \n-\t\t\t\t     method, build_int_2 (j, 0));\n+\t\t\t\t     method, build_int_cst (NULL_TREE, j, 0));\n \t\tTREE_CONSTANT (fdesc) = 1;\n \t\tTREE_INVARIANT (fdesc) = 1;\n \t        list = tree_cons (NULL_TREE, fdesc, list);\n@@ -1504,7 +1505,9 @@ make_class_data (tree type)\n   tree type_decl = TYPE_NAME (type);\n   /** Offset from start of virtual function table declaration\n       to where objects actually point at, following new g++ ABI. */\n-  tree dtable_start_offset = build_int_2 (2 * POINTER_SIZE / BITS_PER_UNIT, 0);\n+  tree dtable_start_offset = build_int_cst (NULL_TREE,\n+\t\t\t\t\t    2 * POINTER_SIZE / BITS_PER_UNIT,\n+\t\t\t\t\t    0);\n \n   this_class_addr = build_class_ref (type);\n   decl = TREE_OPERAND (this_class_addr, 0);\n@@ -1618,8 +1621,7 @@ make_class_data (tree type)\n   else\n     {\n       int super_index = alloc_class_constant (super);\n-      super = build_int_2 (super_index, 0);\n-      TREE_TYPE (super) = ptr_type_node;\n+      super = build_int_cst (ptr_type_node, super_index, 0);\n     }\n \n   /* Build and emit the array of implemented interfaces. */\n@@ -1648,8 +1650,7 @@ make_class_data (tree type)\n \t  else\n \t    {\n \t      int int_index = alloc_class_constant (iclass);\n-\t      index = build_int_2 (int_index, 0);\n-\t      TREE_TYPE (index) = ptr_type_node;\n+\t      index = build_int_cst (ptr_type_node, int_index, 0);\n \t    }\n \t  init = tree_cons (NULL_TREE, index, init); \n \t}\n@@ -1694,14 +1695,16 @@ make_class_data (tree type)\n   PUSH_FIELD_VALUE (cons, \"next\", null_pointer_node);\n   PUSH_FIELD_VALUE (cons, \"name\", build_utf8_ref (DECL_NAME (type_decl)));\n   PUSH_FIELD_VALUE (cons, \"accflags\",\n-\t\t    build_int_2 (get_access_flags_from_decl (type_decl), 0));\n+\t\t    build_int_cst (NULL_TREE,\n+\t\t\t\t   get_access_flags_from_decl (type_decl), 0));\n \n   PUSH_FIELD_VALUE (cons, \"superclass\", \n \t\t    CLASS_INTERFACE (type_decl) ? null_pointer_node : super);\n   PUSH_FIELD_VALUE (cons, \"constants\", constant_pool_constructor);\n   PUSH_FIELD_VALUE (cons, \"methods\",\n \t\t    build1 (ADDR_EXPR, method_ptr_type_node, methods_decl));\n-  PUSH_FIELD_VALUE (cons, \"method_count\",  build_int_2 (method_count, 0));\n+  PUSH_FIELD_VALUE (cons, \"method_count\",\n+\t\t    build_int_cst (NULL_TREE, method_count, 0));\n \n   if (flag_indirect_dispatch)\n     PUSH_FIELD_VALUE (cons, \"vtable_method_count\", integer_minus_one_node);\n@@ -1712,9 +1715,10 @@ make_class_data (tree type)\n \t\t    fields_decl == NULL_TREE ? null_pointer_node\n \t\t    : build1 (ADDR_EXPR, field_ptr_type_node, fields_decl));\n   PUSH_FIELD_VALUE (cons, \"size_in_bytes\", size_in_bytes (type));\n-  PUSH_FIELD_VALUE (cons, \"field_count\", build_int_2 (field_count, 0));\n+  PUSH_FIELD_VALUE (cons, \"field_count\",\n+\t\t    build_int_cst (NULL_TREE, field_count, 0));\n   PUSH_FIELD_VALUE (cons, \"static_field_count\",\n-\t\t    build_int_2 (static_field_count, 0));\n+\t\t    build_int_cst (NULL_TREE, static_field_count, 0));\n \n   if (flag_indirect_dispatch)\n     PUSH_FIELD_VALUE (cons, \"vtable\", null_pointer_node);\n@@ -1760,7 +1764,8 @@ make_class_data (tree type)\n \t\t    build1 (ADDR_EXPR, ptr_type_node, TYPE_CTABLE_DECL (type))); \n   PUSH_FIELD_VALUE (cons, \"interfaces\", interfaces);\n   PUSH_FIELD_VALUE (cons, \"loader\", null_pointer_node);\n-  PUSH_FIELD_VALUE (cons, \"interface_count\", build_int_2 (interface_len, 0));\n+  PUSH_FIELD_VALUE (cons, \"interface_count\",\n+\t\t    build_int_cst (NULL_TREE, interface_len, 0));\n   PUSH_FIELD_VALUE (cons, \"state\", integer_zero_node);\n \n   PUSH_FIELD_VALUE (cons, \"thread\", null_pointer_node);\n@@ -2394,7 +2399,7 @@ emit_symbol_table (tree name, tree the_table, tree decl_list,\n      uninitialized static array of INDEX + 1 elements. The extra entry\n      is used by the runtime to track whether the table has been\n      initialized. */\n-  table_size = build_index_type (build_int_2 (index, 0));\n+  table_size = build_index_type (build_int_cst (NULL_TREE, index, 0));\n   the_array_type = build_array_type (the_array_element_type, table_size);\n   the_table = build_decl (VAR_DECL, name, the_array_type);\n   TREE_STATIC (the_table) = 1;\n@@ -2433,9 +2438,9 @@ emit_catch_table (tree this_class)\n     tree_cons (NULL,\n \t       make_catch_class_record (null_pointer_node, null_pointer_node),\n \t       TYPE_CATCH_CLASSES (this_class));\n-  table_size = \n-    build_index_type (build_int_2 \n-\t\t      (list_length (TYPE_CATCH_CLASSES (this_class)), 0));\n+  table_size = build_index_type\n+    (build_int_cst (NULL_TREE,\n+\t\t    list_length (TYPE_CATCH_CLASSES (this_class)), 0));\n   array_type \n     = build_array_type (TREE_TYPE (TREE_TYPE (TYPE_CTABLE_DECL (this_class))),\n \t\t\ttable_size);"}, {"sha": "d6a35136ad72c4d0b5911c723c5d33bb53b84b0a", "filename": "gcc/java/constants.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -321,10 +321,10 @@ static GTY(()) tree tag_nodes[13];\n static tree\n get_tag_node (int tag)\n {\n-  /* A Cache for build_int_2 (CONSTANT_XXX, 0). */\n+  /* A Cache for build_int_cst (CONSTANT_XXX, 0). */\n \n   if (tag_nodes[tag] == NULL_TREE)\n-    tag_nodes[tag] = build_int_2 (tag, 0);\n+    tag_nodes[tag] = build_int_cst (NULL_TREE, tag, 0);\n   return tag_nodes[tag];\n }\n \n@@ -424,7 +424,7 @@ tree\n build_ref_from_constant_pool (int index)\n {\n   tree d = build_constant_data_ref ();\n-  tree i = build_int_2 (index, 0);\n+  tree i = build_int_cst (NULL_TREE, index, 0);\n   return build4 (ARRAY_REF, TREE_TYPE (TREE_TYPE (d)), d, i,\n \t\t NULL_TREE, NULL_TREE);\n }\n@@ -452,11 +452,9 @@ build_constants_constructor (void)\n     }\n   if (outgoing_cpool->count > 0)\n     {\n-      tree index_type;\n       tree data_decl, tags_decl, tags_type;\n-      tree max_index = build_int_2 (outgoing_cpool->count - 1, 0);\n-      TREE_TYPE (max_index) = sizetype;\n-      index_type = build_index_type (max_index);\n+      tree max_index = build_int_cst (sizetype, outgoing_cpool->count - 1, 0);\n+      tree index_type = build_index_type (max_index);\n \n       /* Add dummy 0'th element of constant pool. */\n       tags_list = tree_cons (NULL_TREE, get_tag_node (0), tags_list);\n@@ -486,7 +484,8 @@ build_constants_constructor (void)\n       tags_value = null_pointer_node;\n     }\n   START_RECORD_CONSTRUCTOR (cons, constants_type_node);\n-  PUSH_FIELD_VALUE (cons, \"size\", build_int_2 (outgoing_cpool->count, 0));\n+  PUSH_FIELD_VALUE (cons, \"size\",\n+\t\t    build_int_cst (NULL_TREE, outgoing_cpool->count, 0));\n   PUSH_FIELD_VALUE (cons, \"tags\", tags_value);\n   PUSH_FIELD_VALUE (cons, \"data\", data_value);\n   FINISH_RECORD_CONSTRUCTOR (cons);"}, {"sha": "d6bce487f05a8ab143ae1b00ab6c870c63f7c235", "filename": "gcc/java/decl.c", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -585,34 +585,32 @@ java_init_decl_processing (void)\n \n   /* Define these next since types below may used them.  */\n   integer_type_node = java_type_for_size (INT_TYPE_SIZE, 0);\n-  integer_zero_node = build_int_2 (0, 0);\n-  integer_one_node = build_int_2 (1, 0);\n-  integer_two_node = build_int_2 (2, 0);\n-  integer_four_node = build_int_2 (4, 0);\n-  integer_minus_one_node = build_int_2 (-1, -1);\n+  integer_zero_node = build_int_cst (NULL_TREE, 0, 0);\n+  integer_one_node = build_int_cst (NULL_TREE, 1, 0);\n+  integer_two_node = build_int_cst (NULL_TREE, 2, 0);\n+  integer_four_node = build_int_cst (NULL_TREE, 4, 0);\n+  integer_minus_one_node = build_int_cst (NULL_TREE, -1, -1);\n \n   /* A few values used for range checking in the lexer.  */\n-  decimal_int_max = build_int_2 (0x80000000, 0);\n-  TREE_TYPE (decimal_int_max) = unsigned_int_type_node;\n+  decimal_int_max = build_int_cst (unsigned_int_type_node, 0x80000000, 0);\n #if HOST_BITS_PER_WIDE_INT == 64\n-  decimal_long_max = build_int_2 (0x8000000000000000LL, 0);\n+  decimal_long_max = build_int_cst (unsigned_long_type_node,\n+\t\t\t\t    0x8000000000000000LL, 0);\n #else\n #if HOST_BITS_PER_WIDE_INT == 32\n-  decimal_long_max = build_int_2 (0, 0x80000000);\n+  decimal_long_max = build_int_cst (unsigned_long_type_node, 0, 0x80000000);\n #else\n  #error \"unsupported size\"\n #endif\n #endif\n-  TREE_TYPE (decimal_long_max) = unsigned_long_type_node;\n \n   size_zero_node = size_int (0);\n   size_one_node = size_int (1);\n   bitsize_zero_node = bitsize_int (0);\n   bitsize_one_node = bitsize_int (1);\n   bitsize_unit_node = bitsize_int (BITS_PER_UNIT);\n \n-  long_zero_node = build_int_2 (0, 0);\n-  TREE_TYPE (long_zero_node) = long_type_node;\n+  long_zero_node = build_int_cst (long_type_node, 0, 0);\n \n   void_type_node = make_node (VOID_TYPE);\n   pushdecl (build_decl (TYPE_DECL, get_identifier (\"void\"), void_type_node));\n@@ -622,8 +620,7 @@ java_init_decl_processing (void)\n   layout_type (t); /* Uses size_zero_node */\n   return_address_type_node = build_pointer_type (t);\n \n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = ptr_type_node;\n+  null_pointer_node = build_int_cst (ptr_type_node, 0, 0);\n \n #if 0\n   /* Make a type to be the domain of a few array types"}, {"sha": "9472794dfee0aee97c334b37b1525f555551d232", "filename": "gcc/java/expr.c", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -698,7 +698,7 @@ build_java_array_length_access (tree node)\n \n   length = java_array_type_length (type);\n   if (length >= 0)\n-    return build_int_2 (length, 0);\n+    return build_int_cst (NULL_TREE, length, 0);\n \n   node = build3 (COMPONENT_REF, int_type_node,\n \t\t build_java_indirect_ref (array_type, node,\n@@ -910,7 +910,7 @@ build_newarray (int atype_value, tree length)\n      and save the runtime some work. However, the bytecode generator\n      expects to find the type_code int here. */\n   if (flag_emit_class_files)\n-    type_arg = build_int_2 (atype_value, 0);\n+    type_arg = build_int_cst (NULL_TREE, atype_value, 0);\n   else\n     type_arg = build_class_ref (prim_type);\n \n@@ -971,7 +971,8 @@ expand_java_multianewarray (tree class_type, int ndim)\n \t\t      build_address_of (soft_multianewarray_node),\n \t\t      tree_cons (NULL_TREE, build_class_ref (class_type),\n \t\t\t\t tree_cons (NULL_TREE, \n-\t\t\t\t\t    build_int_2 (ndim, 0), args)),\n+\t\t\t\t\t    build_int_cst (NULL_TREE, ndim, 0),\n+\t\t\t\t\t    args)),\n \t\t      NULL_TREE));\n }\n \n@@ -1081,10 +1082,7 @@ expand_java_pushc (int ival, tree type)\n   if (type == ptr_type_node && ival == 0)\n     value = null_pointer_node;\n   else if (type == int_type_node || type == long_type_node)\n-    {\n-      value = build_int_2 (ival, ival < 0 ? -1 : 0);\n-      TREE_TYPE (value) = type;\n-    }\n+    value = build_int_cst (type, ival, ival < 0 ? -1 : 0);\n   else if (type == float_type_node || type == double_type_node)\n     {\n       REAL_VALUE_TYPE x;\n@@ -1289,7 +1287,7 @@ expand_iinc (unsigned int local_var_index, int ival, int pc)\n \n   flush_quick_stack ();\n   local_var = find_local_variable (local_var_index, int_type_node, pc);\n-  constant_value = build_int_2 (ival, ival < 0 ? -1 : 0);\n+  constant_value = build_int_cst (NULL_TREE, ival, ival < 0 ? -1 : 0);\n   res = fold (build2 (PLUS_EXPR, int_type_node, local_var, constant_value));\n   java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (local_var), local_var, res));\n   update_aliases (local_var, local_var_index, pc);\n@@ -1359,7 +1357,8 @@ build_java_binop (enum tree_code op, tree type, tree arg1, tree arg2)\n       }\n     case LSHIFT_EXPR:\n     case RSHIFT_EXPR:\n-      mask = build_int_2 (TYPE_PRECISION (TREE_TYPE (arg1)) - 1, 0);\n+      mask = build_int_cst (NULL_TREE,\n+\t\t\t    TYPE_PRECISION (TREE_TYPE (arg1)) - 1, 0);\n       arg2 = fold (build2 (BIT_AND_EXPR, int_type_node, arg2, mask));\n       break;\n \n@@ -1539,9 +1538,9 @@ build_field_ref (tree self_value, tree self_class, tree name)\n \t   we can make a direct reference.  */\n \t{\n \t  tree otable_index\n-\t    = build_int_2 (get_symbol_table_index \n-\t\t\t   (field_decl, &TYPE_OTABLE_METHODS (output_class)),\n-\t\t\t   0);\n+\t    = build_int_cst (NULL_TREE, get_symbol_table_index \n+\t\t\t     (field_decl, &TYPE_OTABLE_METHODS (output_class)),\n+\t\t\t     0);\n \t  tree field_offset\n \t    = build4 (ARRAY_REF, integer_type_node,\n \t\t      TYPE_OTABLE_DECL (output_class), otable_index,\n@@ -1689,8 +1688,7 @@ expand_java_add_case (tree switch_expr, int match, int target_pc)\n {\n   tree value, x;\n \n-  value = build_int_2 (match, match < 0 ? -1 : 0);\n-  TREE_TYPE (value) = TREE_TYPE (switch_expr);\n+  value = build_int_cst (TREE_TYPE (switch_expr), match, match < 0 ? -1 : 0);\n   \n   x = build3 (CASE_LABEL_EXPR, void_type_node, value, NULL_TREE,\n \t      create_artificial_label ());\n@@ -1705,7 +1703,8 @@ static void\n expand_java_call (int target_pc, int return_address)\n {\n   tree target_label = lookup_label (target_pc);\n-  tree value = build_int_2 (return_address, return_address < 0 ? -1 : 0);\n+  tree value = build_int_cst (NULL_TREE,\n+\t\t\t      return_address, return_address < 0 ? -1 : 0);\n   push_value (value);\n   flush_quick_stack ();\n   expand_goto (target_label);\n@@ -1836,8 +1835,8 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n       else\n \t{\n \t  tree table_index\n-\t    = build_int_2 (get_symbol_table_index \n-\t\t\t   (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n+\t    = build_int_cst (NULL_TREE, get_symbol_table_index \n+\t\t\t     (method, &TYPE_ATABLE_METHODS (output_class)), 0);\n \t  func = build4 (ARRAY_REF,  method_ptr_type_node, \n \t\t\t TYPE_ATABLE_DECL (output_class), table_index,\n \t\t\t NULL_TREE, NULL_TREE);\n@@ -1881,7 +1880,7 @@ build_known_method_ref (tree method, tree method_type ATTRIBUTE_UNUSED,\n \t}\n       method_index *= int_size_in_bytes (method_type_node);\n       ref = fold (build2 (PLUS_EXPR, method_ptr_type_node,\n-\t\t\t  ref, build_int_2 (method_index, 0)));\n+\t\t\t  ref, build_int_cst (NULL_TREE, method_index, 0)));\n       ref = build1 (INDIRECT_REF, method_type_node, ref);\n       func = build3 (COMPONENT_REF, nativecode_ptr_type_node,\n \t\t     ref, lookup_field (&method_type_node, ncode_ident),\n@@ -1961,8 +1960,8 @@ build_invokevirtual (tree dtable, tree method)\n   if (flag_indirect_dispatch)\n     {\n       otable_index \n-\t= build_int_2 (get_symbol_table_index \n-\t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n+\t= build_int_cst (NULL_TREE, get_symbol_table_index \n+\t\t\t (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n       method_index = build4 (ARRAY_REF, integer_type_node, \n \t\t\t     TYPE_OTABLE_DECL (output_class), \n \t\t\t     otable_index, NULL_TREE, NULL_TREE);\n@@ -2021,14 +2020,15 @@ build_invokeinterface (tree dtable, tree method)\n   if (flag_indirect_dispatch)\n     {\n       otable_index\n-\t= build_int_2 (get_symbol_table_index \n-\t\t       (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n+\t= build_int_cst (NULL_TREE, get_symbol_table_index \n+\t\t\t (method, &TYPE_OTABLE_METHODS (output_class)), 0);\n       idx = build4 (ARRAY_REF, integer_type_node,\n \t\t    TYPE_OTABLE_DECL (output_class), otable_index,\n \t\t    NULL_TREE, NULL_TREE);\n     }\n   else\n-    idx = build_int_2 (get_interface_method_index (method, interface), 0);\n+    idx = build_int_cst (NULL_TREE,\n+\t\t\t get_interface_method_index (method, interface), 0);\n \n   lookup_arg = tree_cons (NULL_TREE, dtable,\n                           tree_cons (NULL_TREE, build_class_ref (interface),\n@@ -2282,7 +2282,7 @@ build_jni_stub (tree method)\n   /* We call _Jv_LookupJNIMethod to find the actual underlying\n      function pointer.  _Jv_LookupJNIMethod will throw the appropriate\n      exception if this function is not found at runtime.  */\n-  tem = build_tree_list (NULL_TREE, build_int_2 (args_size, 0));\n+  tem = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, args_size, 0));\n   method_sig = build_java_signature (TREE_TYPE (method));\n   lookup_arg = tree_cons (NULL_TREE,\n                           build_utf8_ref (unmangle_classname"}, {"sha": "094555938d9fd33eac482cd06aab8897f5f23f90", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -242,7 +242,7 @@ java_gimplify_new_array_init (tree exp)\n   tree data_field = lookup_field (&array_type, get_identifier (\"data\"));\n   tree element_type = TYPE_ARRAY_ELEMENT (array_type);\n   HOST_WIDE_INT ilength = java_array_type_length (array_type);\n-  tree length = build_int_2 (ilength, 0);\n+  tree length = build_int_cst (NULL_TREE, ilength, 0);\n   tree init = TREE_OPERAND (exp, 0);\n   tree values = CONSTRUCTOR_ELTS (init);\n \n@@ -263,7 +263,7 @@ java_gimplify_new_array_init (tree exp)\n \t\t\t data_field, NULL_TREE);\n       tree assignment = build2 (MODIFY_EXPR, element_type,\n \t\t\t\tbuild4 (ARRAY_REF, element_type, lhs,\n-\t\t\t\t\tbuild_int_2 (index++, 0),\n+\t\t\t\t\tbuild_int_cst (NULL_TREE, index++, 0),\n \t\t\t\t\tNULL_TREE, NULL_TREE),\n \t\t\t\tTREE_VALUE (values));\n       body = build2 (COMPOUND_EXPR, element_type, body, assignment);"}, {"sha": "d62b1b8f32557cee058b3e895ac78d993cf073d1", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -266,8 +266,7 @@ get_constant (JCF *jcf, int index)\n     case CONSTANT_Integer:\n       {\n \tjint num = JPOOL_INT(jcf, index);\n-\tvalue = build_int_2 (num, num < 0 ? -1 : 0);\n-\tTREE_TYPE (value) = int_type_node;\n+\tvalue = build_int_cst (int_type_node, num, num < 0 ? -1 : 0);\n \tbreak;\n       }\n     case CONSTANT_Long:\n@@ -279,8 +278,7 @@ get_constant (JCF *jcf, int index)\n \tlshift_double (num, 0, 32, 64, &lo, &hi, 0);\n \tnum = JPOOL_UINT (jcf, index+1);\n \tadd_double (lo, hi, num, 0, &lo, &hi);\n-\tvalue = build_int_2 (lo, hi);\n-\tTREE_TYPE (value) = long_type_node;\n+\tvalue = build_int_cst (long_type_node, lo, hi);\n \tvalue = force_fit_type (value, 0, false, false);\n \tbreak;\n       }"}, {"sha": "5467d60b9d6ce7daf4918e02ce4c525547f85784", "filename": "gcc/java/lex.c", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1276,11 +1276,10 @@ do_java_lex (YYSTYPE *java_lval)\n \n #ifndef JC1_LITE\n       /* Range checking.  */\n-      value = build_int_2 (low, high);\n       /* Temporarily set type to unsigned.  */\n-      TREE_TYPE (value) =  (long_suffix\n-\t\t\t    ? unsigned_long_type_node\n-\t\t\t    : unsigned_int_type_node);\n+      value = build_int_cst (long_suffix\n+\t\t\t     ? unsigned_long_type_node\n+\t\t\t     : unsigned_int_type_node, low, high);\n       SET_LVAL_NODE (value);\n \n       /* For base 10 numbers, only values up to the highest value\n@@ -1301,7 +1300,8 @@ do_java_lex (YYSTYPE *java_lval)\n \t}\n \n       /* Sign extend the value.  */\n-      TREE_TYPE (value) = long_suffix ? long_type_node : int_type_node;\n+      value = build_int_cst (long_suffix ? long_type_node : int_type_node,\n+\t\t\t     low, high);\n       value = force_fit_type (value, 0, false, false);\n       SET_LVAL_NODE (value);\n       \n@@ -1335,13 +1335,7 @@ do_java_lex (YYSTYPE *java_lval)\n         char_lit = 0;\t\t/* We silently convert it to zero.  */\n \n       JAVA_LEX_CHAR_LIT (char_lit);\n-#ifndef JC1_LITE\n-      {\n-\ttree value = build_int_2 (char_lit, 0);\n-\tTREE_TYPE (value) = char_type_node;\n-\tSET_LVAL_NODE (value);\n-      }\n-#endif\n+      SET_LVAL_NODE (build_int_cst (char_type_node, char_lit, 0));\n       return CHAR_LIT_TK;\n     }\n "}, {"sha": "8e0d3197840d2b9b9b42bfc3948e30caf018157b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -13322,10 +13322,10 @@ patch_binop (tree node, tree wfl_op1, tree wfl_op2)\n       /* Shift int only up to 0x1f and long up to 0x3f */\n       if (prom_type == int_type_node)\n \top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t    build_int_2 (0x1f, 0)));\n+\t\t\t    build_int_cst (NULL_TREE, 0x1f, 0)));\n       else\n \top2 = fold (build2 (BIT_AND_EXPR, int_type_node, op2,\n-\t\t\t    build_int_2 (0x3f, 0)));\n+\t\t\t    build_int_cst (NULL_TREE, 0x3f, 0)));\n \n       /* The >>> operator is a >> operating on unsigned quantities */\n       if (code == URSHIFT_EXPR && ! flag_emit_class_files)\n@@ -14020,12 +14020,12 @@ patch_unaryop (tree node, tree wfl_op)\n \t     both operands, if really necessary */\n \t  if (JINTEGRAL_TYPE_P (op_type))\n \t    {\n-\t      value = build_int_2 (1, 0);\n-\t      TREE_TYPE (value) = TREE_TYPE (node) = op_type;\n+\t      value = build_int_cst (op_type, 1, 0);\n+\t      TREE_TYPE (node) = op_type;\n \t    }\n \t  else\n \t    {\n-\t      value = build_int_2 (1, 0);\n+\t      value = build_int_cst (NULL_TREE, 1, 0);\n \t      TREE_TYPE (node) =\n \t\tbinary_numeric_promotion (op_type,\n \t\t\t\t\t  TREE_TYPE (value), &op, &value);\n@@ -14251,8 +14251,7 @@ patch_cast (tree node, tree wfl_op)\n static tree\n build_null_of_type (tree type)\n {\n-  tree node = build_int_2 (0, 0);\n-  TREE_TYPE (node) = promote_type (type);\n+  tree node = build_int_cst (promote_type (type), 0, 0);\n   return node;\n }\n \n@@ -14333,7 +14332,8 @@ static tree\n build_newarray_node (tree type, tree dims, int extra_dims)\n {\n   tree node = build3 (NEW_ARRAY_EXPR, NULL_TREE, type,\n-\t\t      nreverse (dims), build_int_2 (extra_dims, 0));\n+\t\t      nreverse (dims),\n+\t\t      build_int_cst (NULL_TREE, extra_dims, 0));\n   return node;\n }\n \n@@ -14432,7 +14432,8 @@ patch_newarray (tree node)\n \t\t tree_cons (NULL_TREE,\n \t\t\t    build_class_ref (TREE_TYPE (array_type)),\n \t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t       build_int_2 (ndims, 0), dims )),\n+\t\t\t\t       build_int_cst (NULL_TREE,\n+\t\t\t\t\t\t      ndims, 0), dims )),\n \t\t NULL_TREE);\n }\n "}, {"sha": "362aab49624c51d74809189b41dd510fd8dedda4", "filename": "gcc/java/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -69,9 +69,9 @@ compile_resource_data (const char *name, const char *buffer, int length)\n   FINISH_RECORD (rtype);\n   START_RECORD_CONSTRUCTOR (rinit, rtype);\n   PUSH_FIELD_VALUE (rinit, \"name_length\", \n-\t\t    build_int_2 (strlen (name), 0));\n+\t\t    build_int_cst (NULL_TREE, strlen (name), 0));\n   PUSH_FIELD_VALUE (rinit, \"resource_length\", \n-\t\t    build_int_2 (length, 0));\n+\t\t    build_int_cst (NULL_TREE, length, 0));\n   data = build_string (strlen(name) + length, buffer);\n   TREE_TYPE (data) = data_type;\n   PUSH_FIELD_VALUE (rinit, \"data\", data);"}, {"sha": "830b95c5c624e0fd4831b562d57fbd6677ad97b3", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -357,8 +357,8 @@ build_prim_array_type (tree element_type, HOST_WIDE_INT length)\n \n   if (length != -1)\n     {\n-      tree max_index = build_int_2 (length - 1, (0 == length ? -1 : 0));\n-      TREE_TYPE (max_index) = sizetype;\n+      tree max_index = build_int_cst (sizetype,\n+\t\t\t\t      length - 1, (0 == length ? -1 : 0));\n       index = build_index_type (max_index);\n     }\n   return build_array_type (element_type, index);"}, {"sha": "b718714c9964ae87dd949c29f39c19a78c3ad60c", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1432,7 +1432,7 @@ build_objc_string_object (tree string)\n     }\n   else\n     {\n-      initlist = build_tree_list (fields, build_int_2 (0, 0));\n+      initlist = build_tree_list (fields, build_int_cst (NULL_TREE, 0, 0));\n     }\n \n   fields = TREE_CHAIN (fields);\n@@ -1443,7 +1443,7 @@ build_objc_string_object (tree string)\n                  \n   fields = TREE_CHAIN (fields);\n   \n-  initlist = tree_cons (fields, build_int_2 (length, 0), initlist);\n+  initlist = tree_cons (fields, build_int_cst (NULL_TREE, length, 0), initlist);\n   constructor = objc_build_constructor (constant_string_type,\n \t\t\t\t\tnreverse (initlist));\n \n@@ -1596,7 +1596,7 @@ build_objc_symtab_template (void)\n \t\t   (FIELD_DECL,\n \t\t    build_array_type\n \t\t    (ptr_type_node,\n-\t\t     build_index_type (build_int_2 (index, 0))),\n+\t\t     build_index_type (build_int_cst (NULL_TREE, index, 0))),\n \t\t    \"defs\");\n       chainon (field_decl_chain, field_decl);\n     }\n@@ -1641,7 +1641,7 @@ init_def_list (tree type)\n       if (static_instances_decl)\n \texpr = build_unary_op (ADDR_EXPR, static_instances_decl, 0);\n       else\n-\texpr = build_int_2 (0, 0);\n+\texpr = build_int_cst (NULL_TREE, 0, 0);\n \n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n@@ -1658,12 +1658,12 @@ init_objc_symtab (tree type)\n \n   /* sel_ref_cnt = { ..., 5, ... } */\n \n-  initlist = build_tree_list (NULL_TREE, build_int_2 (0, 0));\n+  initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, 0, 0));\n \n   /* refs = { ..., _OBJC_SELECTOR_TABLE, ... } */\n \n   if (flag_next_runtime || ! sel_ref_chain)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     initlist = tree_cons (NULL_TREE,\n \t\t\t  build_unary_op (ADDR_EXPR,\n@@ -1672,11 +1672,11 @@ init_objc_symtab (tree type)\n \n   /* cls_def_cnt = { ..., 5, ... } */\n \n-  initlist = tree_cons (NULL_TREE, build_int_2 (imp_count, 0), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, imp_count, 0), initlist);\n \n   /* cat_def_cnt = { ..., 5, ... } */\n \n-  initlist = tree_cons (NULL_TREE, build_int_2 (cat_count, 0), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, cat_count, 0), initlist);\n \n   /* cls_def = { ..., { &Foo, &Bar, ...}, ... } */\n \n@@ -1777,7 +1777,7 @@ init_module_descriptor (tree type)\n \n   /* version = { 1, ... } */\n \n-  expr = build_int_2 (OBJC_VERSION, 0);\n+  expr = build_int_cst (NULL_TREE, OBJC_VERSION, 0);\n   initlist = build_tree_list (NULL_TREE, expr);\n \n   /* size = { ..., sizeof (struct objc_module), ... } */\n@@ -1795,7 +1795,7 @@ init_module_descriptor (tree type)\n   if (UOBJC_SYMBOLS_decl)\n     expr = build_unary_op (ADDR_EXPR, UOBJC_SYMBOLS_decl, 0);\n   else\n-    expr = build_int_2 (0, 0);\n+    expr = build_int_cst (NULL_TREE, 0, 0);\n   initlist = tree_cons (NULL_TREE, expr, initlist);\n \n   return objc_build_constructor (type, nreverse (initlist));\n@@ -2002,15 +2002,15 @@ generate_static_references (void)\n \t}\n \n       /* Output {..., NULL}.  */\n-      initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+      initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n       expr = objc_build_constructor (TREE_TYPE (decl), nreverse (initlist));\n       finish_decl (decl, expr, NULL_TREE);\n       decls\n \t= tree_cons (NULL_TREE, build_unary_op (ADDR_EXPR, decl, 1), decls);\n     }\n \n-  decls = tree_cons (NULL_TREE, build_int_2 (0, 0), decls);\n+  decls = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), decls);\n   ident = get_identifier (\"_OBJC_STATIC_INSTANCES\");\n   expr_decl = build_nt (ARRAY_REF, ident, NULL_TREE, NULL_TREE, NULL_TREE);\n   decl_spec = tree_cons (NULL_TREE, build_pointer_type (void_type_node),\n@@ -2205,7 +2205,7 @@ build_selector_translation_table (void)\n       DECL_EXTERNAL (UOBJC_SELECTOR_TABLE_decl) = 0;\n       TREE_STATIC (UOBJC_SELECTOR_TABLE_decl) = 1;\n       /* NULL terminate the list and fix the decl for output.  */\n-      initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+      initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n       DECL_INITIAL (UOBJC_SELECTOR_TABLE_decl) = objc_ellipsis_node;\n       initlist = objc_build_constructor (TREE_TYPE (UOBJC_SELECTOR_TABLE_decl),\n \t\t\t\t\t nreverse (initlist));\n@@ -2231,7 +2231,7 @@ get_proto_encoding (tree proto)\n       return add_objc_string (encoding, meth_var_types);\n     }\n   else\n-    return build_int_2 (0, 0);\n+    return build_int_cst (NULL_TREE, 0, 0);\n }\n \n /* sel_ref_chain is a list whose \"value\" fields will be instances of\n@@ -2258,7 +2258,7 @@ build_typed_selector_reference (tree ident, tree prototype)\n  return_at_index:\n   expr = build_unary_op (ADDR_EXPR,\n \t\t\t build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t\t\t  build_int_2 (index, 0)),\n+\t\t\t\t\t  build_int_cst (NULL_TREE, index, 0)),\n \t\t\t 1);\n   return build_c_cast (objc_selector_type, expr);\n }\n@@ -2276,7 +2276,7 @@ build_selector_reference (tree ident)\n \treturn (flag_next_runtime\n \t\t? TREE_PURPOSE (*chain)\n \t\t: build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t\t   build_int_2 (index, 0)));\n+\t\t\t\t   build_int_cst (NULL_TREE, index, 0)));\n \n       index++;\n       chain = &TREE_CHAIN (*chain);\n@@ -2289,7 +2289,7 @@ build_selector_reference (tree ident)\n   return (flag_next_runtime\n \t  ? expr\n \t  : build_array_ref (UOBJC_SELECTOR_TABLE_decl,\n-\t\t\t     build_int_2 (index, 0)));\n+\t\t\t     build_int_cst (NULL_TREE, index, 0)));\n }\n \n static GTY(()) int class_reference_idx;\n@@ -3277,15 +3277,15 @@ build_next_objc_exception_stuff (void)\n \n   /* int buf[_JBLEN]; */\n \n-  index = build_index_type (build_int_2 (_JBLEN - 1, 0));\n+  index = build_index_type (build_int_cst (NULL_TREE, _JBLEN - 1, 0));\n   field_decl = create_builtin_decl (FIELD_DECL,\n \t\t\t\t    build_array_type (integer_type_node, index),\n \t\t\t\t    \"buf\");\n   field_decl_chain = field_decl;\n \n   /* void *pointers[4]; */\n \n-  index = build_index_type (build_int_2 (4 - 1, 0));\n+  index = build_index_type (build_int_cst (NULL_TREE, 4 - 1, 0));\n   field_decl = create_builtin_decl (FIELD_DECL,\n \t\t\t\t    build_array_type (ptr_type_node, index),\n \t\t\t\t    \"pointers\");\n@@ -3523,7 +3523,7 @@ build_method_prototype_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n-\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n+\t\t\t build_int_cst (NULL_TREE, size, 0), NULL_TREE, NULL_TREE);\n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n \n@@ -3669,7 +3669,7 @@ generate_descriptor_table (tree type, const char *name, int size, tree list,\n \t\t     decl_specs, 1, NULL_TREE);\n   DECL_CONTEXT (decl) = NULL_TREE;\n \n-  initlist = build_tree_list (NULL_TREE, build_int_2 (size, 0));\n+  initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, size, 0));\n   initlist = tree_cons (NULL_TREE, list, initlist);\n \n   finish_decl (decl, objc_build_constructor (type, nreverse (initlist)),\n@@ -3879,7 +3879,7 @@ generate_protocols (void)\n \t  TREE_TYPE (refs_expr) = cast_type2;\n \t}\n       else\n-\trefs_expr = build_int_2 (0, 0);\n+\trefs_expr = build_int_cst (NULL_TREE, 0, 0);\n \n       /* UOBJC_INSTANCE_METHODS_decl/UOBJC_CLASS_METHODS_decl are set\n \t by generate_method_descriptors, which is called above.  */\n@@ -3912,22 +3912,22 @@ build_protocol_initializer (tree type, tree protocol_name,\n   /* Filling the \"isa\" in with one allows the runtime system to\n      detect that the version change...should remove before final release.  */\n \n-  expr = build_int_2 (PROTOCOL_VERSION, 0);\n+  expr = build_int_cst (NULL_TREE, PROTOCOL_VERSION, 0);\n   TREE_TYPE (expr) = cast_type;\n   initlist = tree_cons (NULL_TREE, expr, initlist);\n   initlist = tree_cons (NULL_TREE, protocol_name, initlist);\n   initlist = tree_cons (NULL_TREE, protocol_list, initlist);\n \n   if (!instance_methods)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, instance_methods, 0);\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n \n   if (!class_methods)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, class_methods, 0);\n@@ -4420,7 +4420,7 @@ build_ivar_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"ivar_list\"),\n-\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n+\t\t\t build_int_cst (NULL_TREE, size, 0), NULL_TREE, NULL_TREE);\n \n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n@@ -4468,7 +4468,7 @@ build_method_list_template (tree list_type, int size)\n \n   decl_specs = build_tree_list (NULL_TREE, list_type);\n   field_decl = build_nt (ARRAY_REF, get_identifier (\"method_list\"),\n-\t\t\t build_int_2 (size, 0), NULL_TREE, NULL_TREE);\n+\t\t\t build_int_cst (NULL_TREE, size, 0), NULL_TREE, NULL_TREE);\n \n   field_decl = grokfield (field_decl, decl_specs, NULL_TREE);\n   chainon (field_decl_chain, field_decl);\n@@ -4495,7 +4495,7 @@ build_ivar_list_initializer (tree type, tree field_decl)\n \t\t\t  ivar);\n       else\n \t/* Unnamed bit-field ivar (yuck).  */\n-\tivar = tree_cons (NULL_TREE, build_int_2 (0, 0), ivar);\n+\tivar = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), ivar);\n \n       /* Set type.  */\n       encode_field_decl (field_decl,\n@@ -4538,7 +4538,7 @@ generate_ivars_list (tree type, const char *name, int size, tree list)\n   decl = start_decl (synth_id_with_class_suffix (name, objc_implementation_context),\n \t\t     decl_specs, 1, NULL_TREE);\n \n-  initlist = build_tree_list (NULL_TREE, build_int_2 (size, 0));\n+  initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, size, 0));\n   initlist = tree_cons (NULL_TREE, list, initlist);\n \n   finish_decl (decl,\n@@ -4713,8 +4713,8 @@ generate_dispatch_table (tree type, const char *name, int size, tree list)\n   decl = start_decl (synth_id_with_class_suffix (name, objc_implementation_context),\n \t\t     decl_specs, 1, NULL_TREE);\n \n-  initlist = build_tree_list (NULL_TREE, build_int_2 (0, 0));\n-  initlist = tree_cons (NULL_TREE, build_int_2 (size, 0), initlist);\n+  initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, 0, 0));\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, size, 0), initlist);\n   initlist = tree_cons (NULL_TREE, list, initlist);\n \n   finish_decl (decl,\n@@ -4846,9 +4846,9 @@ generate_protocol_list (tree i_or_p)\n       size++;\n \n   /* Build initializer.  */\n-  initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), NULL_TREE);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), NULL_TREE);\n \n-  e = build_int_2 (size, 0);\n+  e = build_int_cst (NULL_TREE, size, 0);\n   TREE_TYPE (e) = cast_type;\n   initlist = tree_cons (NULL_TREE, e, initlist);\n \n@@ -4875,18 +4875,18 @@ generate_protocol_list (tree i_or_p)\n     expr_decl = build_nt (ARRAY_REF,\n \t\t\t  synth_id_with_class_suffix (\"_OBJC_PROTOCOL_REFS\",\n \t\t\t\t\t\t      i_or_p),\n-\t\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n+\t\t\t  build_int_cst (NULL_TREE, size + 2, 0), NULL_TREE, NULL_TREE);\n   else if (TREE_CODE (i_or_p) == CLASS_INTERFACE_TYPE)\n     expr_decl = build_nt (ARRAY_REF,\n \t\t\t  synth_id_with_class_suffix (\"_OBJC_CLASS_PROTOCOLS\",\n \t\t\t\t\t\t      i_or_p),\n-\t\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n+\t\t\t  build_int_cst (NULL_TREE, size + 2, 0), NULL_TREE, NULL_TREE);\n   else if (TREE_CODE (i_or_p) == CATEGORY_INTERFACE_TYPE)\n     expr_decl\n       = build_nt (ARRAY_REF,\n \t\t  synth_id_with_class_suffix (\"_OBJC_CATEGORY_PROTOCOLS\",\n \t\t\t\t\t      i_or_p),\n-\t\t  build_int_2 (size + 2, 0), NULL_TREE, NULL_TREE);\n+\t\t  build_int_cst (NULL_TREE, size + 2, 0), NULL_TREE, NULL_TREE);\n   else\n     abort ();\n \n@@ -4913,14 +4913,14 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n   initlist = tree_cons (NULL_TREE, class_name, initlist);\n \n   if (!instance_methods)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, instance_methods, 0);\n       initlist = tree_cons (NULL_TREE, expr, initlist);\n     }\n   if (!class_methods)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, class_methods, 0);\n@@ -4929,7 +4929,7 @@ build_category_initializer (tree type, tree cat_name, tree class_name,\n \n   /* protocol_list = */\n   if (!protocol_list)\n-     initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+     initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n      {\n        tree cast_type2 = groktypename\n@@ -4988,17 +4988,17 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n   initlist = tree_cons (NULL_TREE, default_conversion (name), initlist);\n \n   /* version = */\n-  initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n   /* info = */\n-  initlist = tree_cons (NULL_TREE, build_int_2 (status, 0), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, status, 0), initlist);\n \n   /* instance_size = */\n   initlist = tree_cons (NULL_TREE, size, initlist);\n \n   /* objc_ivar_list = */\n   if (!ivar_list)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, ivar_list, 0);\n@@ -5007,7 +5007,7 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n \n   /* objc_method_list = */\n   if (!dispatch_table)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       expr = build_unary_op (ADDR_EXPR, dispatch_table, 0);\n@@ -5016,22 +5016,22 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n \n   if (flag_next_runtime)\n     /* method_cache = */\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n     {\n       /* dtable = */\n-      initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+      initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n       /* subclass_list = */\n-      initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+      initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n       /* sibling_class = */\n-      initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+      initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n     }\n \n   /* protocol_list = */\n   if (! protocol_list)\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n   else\n      {\n        tree cast_type2\n@@ -5050,10 +5050,10 @@ build_shared_structure_initializer (tree type, tree isa, tree super,\n \n   if (flag_next_runtime)\n     /* sel_id = NULL */\n-    initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+    initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n   /* gc_object_type = NULL */\n-  initlist = tree_cons (NULL_TREE, build_int_2 (0, 0), initlist);\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 0, 0), initlist);\n \n   return objc_build_constructor (type, nreverse (initlist));\n }\n@@ -5162,7 +5162,7 @@ generate_shared_structures (void)\n       super_expr = build_c_cast (cast_type, super_expr); /* cast! */\n     }\n   else\n-    super_expr = build_int_2 (0, 0);\n+    super_expr = build_int_cst (NULL_TREE, 0, 0);\n \n   root_expr = add_objc_string (my_root_id, class_names);\n   root_expr = build_c_cast (cast_type, root_expr); /* cast! */\n@@ -9019,7 +9019,7 @@ handle_impent (struct imp_entry *impent)\n     {\n       tree decl, init;\n \n-      init = build_int_2 (0, 0);\n+      init = build_int_cst (NULL_TREE, 0, 0);\n       TREE_TYPE (init) = c_common_type_for_size (BITS_PER_WORD, 1);\n       decl = build_decl (VAR_DECL, get_identifier (string), TREE_TYPE (init));\n       TREE_PUBLIC (decl) = 1;\n@@ -9050,13 +9050,13 @@ generate_objc_image_info (void)\n \t\t tree_cons (NULL_TREE,\n \t\t\t    build_array_type\n \t\t\t    (integer_type_node,\n-\t\t\t     build_index_type (build_int_2 (1, 0))),\n+\t\t\t     build_index_type (build_int_cst (NULL_TREE, 1, 0))),\n \t\t\t    sc_spec),\n \t\t 1,\n \t\t NULL_TREE);\n \n-  initlist = build_tree_list (NULL_TREE, build_int_2 (0, 0));\n-  initlist = tree_cons (NULL_TREE, build_int_2 (1, 0), initlist);\n+  initlist = build_tree_list (NULL_TREE, build_int_cst (NULL_TREE, 0, 0));\n+  initlist = tree_cons (NULL_TREE, build_int_cst (NULL_TREE, 1, 0), initlist);\n   initlist = build_constructor (TREE_TYPE (decl), nreverse (initlist));\n \n   TREE_USED (decl) = DECL_IGNORED_P (decl) = DECL_ARTIFICIAL (decl) = 1;"}, {"sha": "b939a9e57751ba06d6d6c62f6ee6da7fac364d02", "filename": "gcc/stmt.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1556,7 +1556,7 @@ shift_return_value (rtx val)\n       if (shift > 0)\n \tval = expand_shift (LSHIFT_EXPR, GET_MODE (target),\n \t\t\t    gen_lowpart (GET_MODE (target), val),\n-\t\t\t    build_int_2 (shift, 0), target, 1);\n+\t\t\t    build_int_cst (NULL_TREE, shift, 0), target, 1);\n     }\n   return val;\n }\n@@ -2566,7 +2566,7 @@ expand_case (tree exp)\n \t      if (TREE_CODE (index_expr) != INTEGER_CST)\n \t\t{\n \t\t  index_expr\n-\t\t    = build_int_2 (INTVAL (index),\n+\t\t    = build_int_cst (NULL_TREE, INTVAL (index),\n \t\t\t\t   unsignedp || INTVAL (index) >= 0 ? 0 : -1);\n \t\t  index_expr = convert (index_type, index_expr);\n \t\t}\n@@ -2738,7 +2738,8 @@ static int\n estimate_case_costs (case_node_ptr node)\n {\n   tree min_ascii = integer_minus_one_node;\n-  tree max_ascii = convert (TREE_TYPE (node->high), build_int_2 (127, 0));\n+  tree max_ascii = convert (TREE_TYPE (node->high),\n+\t\t\t    build_int_cst (NULL_TREE, 127, 0));\n   case_node_ptr n;\n   int i;\n "}, {"sha": "eca60877c8aa2547c01b0ba2acc4d7e09aa7d8db", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 27, "deletions": 32, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1537,7 +1537,7 @@ layout_type (tree type)\n     case VECTOR_TYPE:\n       {\n \tint nunits = TYPE_VECTOR_SUBPARTS (type);\n-\ttree nunits_tree = build_int_2 (nunits, 0);\n+\ttree nunits_tree = build_int_cst (NULL_TREE, nunits, 0);\n \ttree innertype = TREE_TYPE (type);\n \n \tif (nunits & (nunits - 1))\n@@ -1859,29 +1859,24 @@ initialize_sizetypes (void)\n {\n   tree t = make_node (INTEGER_TYPE);\n \n-  /* Set this so we do something reasonable for the build_int_2 calls\n-     below.  */\n-  integer_type_node = t;\n-\n   TYPE_MODE (t) = SImode;\n   TYPE_ALIGN (t) = GET_MODE_ALIGNMENT (SImode);\n   TYPE_USER_ALIGN (t) = 0;\n-  TYPE_SIZE (t) = build_int_2 (GET_MODE_BITSIZE (SImode), 0);\n-  TYPE_SIZE_UNIT (t) = build_int_2 (GET_MODE_SIZE (SImode), 0);\n+  TYPE_SIZE (t) = build_int_cst (t, GET_MODE_BITSIZE (SImode), 0);\n+  TYPE_SIZE_UNIT (t) = build_int_cst (t, GET_MODE_SIZE (SImode), 0);\n   TYPE_UNSIGNED (t) = 1;\n   TYPE_PRECISION (t) = GET_MODE_BITSIZE (SImode);\n-  TYPE_MIN_VALUE (t) = build_int_2 (0, 0);\n+  TYPE_MIN_VALUE (t) = build_int_cst (t, 0, 0);\n   TYPE_IS_SIZETYPE (t) = 1;\n \n   /* 1000 avoids problems with possible overflow and is certainly\n      larger than any size value we'd want to be storing.  */\n-  TYPE_MAX_VALUE (t) = build_int_2 (1000, 0);\n+  TYPE_MAX_VALUE (t) = build_int_cst (t, 1000, 0);\n \n   /* These two must be different nodes because of the caching done in\n      size_int_wide.  */\n   sizetype = t;\n   bitsizetype = copy_node (t);\n-  integer_type_node = 0;\n }\n \n /* Set sizetype to TYPE, and initialize *sizetype accordingly.\n@@ -1980,36 +1975,36 @@ set_min_and_max_values_for_integral_type (tree type,\n \n   if (is_unsigned)\n     {\n-      min_value = build_int_2 (0, 0);\n+      min_value = build_int_cst (type, 0, 0);\n       max_value \n-\t= build_int_2 (precision - HOST_BITS_PER_WIDE_INT >= 0\n-\t\t       ? -1 : ((HOST_WIDE_INT) 1 << precision) - 1,\n-\t\t       precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t       ? ((unsigned HOST_WIDE_INT) ~0\n-\t\t\t  >> (HOST_BITS_PER_WIDE_INT\n-\t\t\t      - (precision - HOST_BITS_PER_WIDE_INT)))\n-\t\t       : 0);\n+\t= build_int_cst (type, precision - HOST_BITS_PER_WIDE_INT >= 0\n+\t\t\t ? -1 : ((HOST_WIDE_INT) 1 << precision) - 1,\n+\t\t\t precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t\t ? ((unsigned HOST_WIDE_INT) ~0\n+\t\t\t    >> (HOST_BITS_PER_WIDE_INT\n+\t\t\t\t- (precision - HOST_BITS_PER_WIDE_INT)))\n+\t\t\t : 0);\n     }\n   else\n     {\n       min_value \n-\t= build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t\t? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n-\t\t       (((HOST_WIDE_INT) (-1)\n-\t\t\t << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t\t     ? precision - HOST_BITS_PER_WIDE_INT - 1\n-\t\t\t     : 0))));    \n+\t= build_int_cst (type,\n+\t\t\t (precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t\t  ? 0 : (HOST_WIDE_INT) (-1) << (precision - 1)),\n+\t\t\t (((HOST_WIDE_INT) (-1)\n+\t\t\t   << (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t\t       ? precision - HOST_BITS_PER_WIDE_INT - 1\n+\t\t\t       : 0))));    \n       max_value\n-\t= build_int_2 ((precision - HOST_BITS_PER_WIDE_INT > 0\n-\t\t\t? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n-\t\t       (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n-\t\t\t? (((HOST_WIDE_INT) 1\n-\t\t\t    << (precision - HOST_BITS_PER_WIDE_INT - 1))) - 1\n-\t\t\t: 0));\n+\t= build_int_cst (type,\n+\t\t\t (precision - HOST_BITS_PER_WIDE_INT > 0\n+\t\t\t  ? -1 : ((HOST_WIDE_INT) 1 << (precision - 1)) - 1),\n+\t\t\t (precision - HOST_BITS_PER_WIDE_INT - 1 > 0\n+\t\t\t  ? (((HOST_WIDE_INT) 1\n+\t\t\t      << (precision - HOST_BITS_PER_WIDE_INT - 1))) - 1\n+\t\t\t  : 0));\n     }\n \n-  TREE_TYPE (min_value) = type;\n-  TREE_TYPE (max_value) = type;\n   TYPE_MIN_VALUE (type) = min_value;\n   TYPE_MAX_VALUE (type) = max_value;\n }"}, {"sha": "957f55daf6776175022b9058e81d7e36ae4a04b0", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -218,7 +218,7 @@ chrec_fold_multiply_poly_poly (tree type,\n      \n      /* \"2*b*d\".  */\n      chrec_fold_multiply\n-     (type, build_int_2 (2, 0),\n+     (type, build_int_cst (NULL_TREE, 2, 0),\n       chrec_fold_multiply (type, CHREC_RIGHT (poly0), CHREC_RIGHT (poly1))));\n }\n \n@@ -645,7 +645,7 @@ reset_evolution_in_loop (unsigned loop_num,\n       && CHREC_VARIABLE (chrec) > loop_num)\n     return build \n       (TREE_CODE (chrec), \n-       build_int_2 (CHREC_VARIABLE (chrec), 0), \n+       build_int_cst (NULL_TREE, CHREC_VARIABLE (chrec), 0), \n        reset_evolution_in_loop (loop_num, CHREC_LEFT (chrec), new_evol), \n        reset_evolution_in_loop (loop_num, CHREC_RIGHT (chrec), new_evol));\n   "}, {"sha": "d2027b229be84eaaab7f30127a9261f15e2092c3", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -105,7 +105,7 @@ build_polynomial_chrec (unsigned loop_num,\n     return chrec_dont_know;\n \n   return build (POLYNOMIAL_CHREC, TREE_TYPE (left), \n-\t\tbuild_int_2 (loop_num, 0), left, right);\n+\t\tbuild_int_cst (NULL_TREE, loop_num, 0), left, right);\n }\n \n \f"}, {"sha": "5c14e41ce51532edaed67ea9c4143943f5601d41", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -506,8 +506,7 @@ build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n   else\n     abort ();\n \n-  ret = build_int_2 (low, high);\n-  TREE_TYPE (ret) = type;\n+  ret = build_int_cst (type, low, high);\n   return ret;\n }\n "}, {"sha": "a231f29b0a2d48d16d2948b73ff7bd7e9c78fad5", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -832,7 +832,8 @@ honor_protect_cleanup_actions (struct leh_state *outer_state,\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n \n       x = build1 (RESX_EXPR, void_type_node,\n-\t\t  build_int_2 (get_eh_region_number (tf->region), 0));\n+\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t get_eh_region_number (tf->region), 0));\n       tsi_link_after (&i, x, TSI_CONTINUE_LINKING);\n     }\n \n@@ -938,7 +939,8 @@ lower_try_finally_onedest (struct leh_state *state, struct leh_tf_state *tf)\n       append_to_statement_list (finally, tf->top_p);\n       \n       x = build1 (RESX_EXPR, void_type_node,\n-\t\t  build_int_2 (get_eh_region_number (tf->region), 0));\n+\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t get_eh_region_number (tf->region), 0));\n       append_to_statement_list (x, tf->top_p);\n \n       return;\n@@ -1026,7 +1028,8 @@ lower_try_finally_copy (struct leh_state *state, struct leh_tf_state *tf)\n       append_to_statement_list (x, &new_stmt);\n \n       x = build1 (RESX_EXPR, void_type_node,\n-\t\t  build_int_2 (get_eh_region_number (tf->region), 0));\n+\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t get_eh_region_number (tf->region), 0));\n       append_to_statement_list (x, &new_stmt);\n     }\n \n@@ -1134,7 +1137,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n   if (tf->may_fallthru)\n     {\n       x = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t build_int_2 (fallthru_index, 0));\n+\t\t build_int_cst (NULL_TREE, fallthru_index, 0));\n       append_to_statement_list (x, tf->top_p);\n \n       if (tf->may_throw)\n@@ -1145,7 +1148,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n \n \n       last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t build_int_2 (fallthru_index, 0), NULL,\n+\t\t\t build_int_cst (NULL_TREE, fallthru_index, 0), NULL,\n \t\t\t create_artificial_label ());\n       TREE_VEC_ELT (case_label_vec, last_case_index) = last_case;\n       last_case_index++;\n@@ -1164,19 +1167,20 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       append_to_statement_list (x, tf->top_p);\n \n       x = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t build_int_2 (eh_index, 0));\n+\t\t build_int_cst (NULL_TREE, eh_index, 0));\n       append_to_statement_list (x, tf->top_p);\n \n       last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t build_int_2 (eh_index, 0), NULL,\n+\t\t\t build_int_cst (NULL_TREE, eh_index, 0), NULL,\n \t\t\t create_artificial_label ());\n       TREE_VEC_ELT (case_label_vec, last_case_index) = last_case;\n       last_case_index++;\n \n       x = build (LABEL_EXPR, void_type_node, CASE_LABEL (last_case));\n       append_to_statement_list (x, &switch_body);\n       x = build1 (RESX_EXPR, void_type_node,\n-\t\t  build_int_2 (get_eh_region_number (tf->region), 0));\n+\t\t  build_int_cst (NULL_TREE,\n+\t\t\t\t get_eh_region_number (tf->region), 0));\n       append_to_statement_list (x, &switch_body);\n     }\n \n@@ -1198,14 +1202,14 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       if (q->index < 0)\n \t{\n \t  mod = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t       build_int_2 (return_index, 0));\n+\t\t       build_int_cst (NULL_TREE, return_index, 0));\n \t  do_return_redirection (q, finally_label, mod, &return_val);\n \t  switch_id = return_index;\n \t}\n       else\n \t{\n \t  mod = build (MODIFY_EXPR, void_type_node, finally_tmp,\n-\t\t       build_int_2 (q->index, 0));\n+\t\t       build_int_cst (NULL_TREE, q->index, 0));\n \t  do_goto_redirection (q, finally_label, mod);\n \t  switch_id = q->index;\n \t}\n@@ -1214,7 +1218,7 @@ lower_try_finally_switch (struct leh_state *state, struct leh_tf_state *tf)\n       if (!TREE_VEC_ELT (case_label_vec, case_index))\n \t{\n \t  last_case = build (CASE_LABEL_EXPR, void_type_node,\n-\t\t\t     build_int_2 (switch_id, 0), NULL,\n+\t\t\t     build_int_cst (NULL_TREE, switch_id, 0), NULL,\n \t\t\t     create_artificial_label ());\n \t  TREE_VEC_ELT (case_label_vec, case_index) = last_case;\n "}, {"sha": "a10b5d78b231ad1920394b9b198767ec28c3cf2b", "filename": "gcc/tree-mudflap.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-mudflap.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -76,9 +76,8 @@ mf_build_string (const char *string)\n   size_t len = strlen (string);\n   tree result = mf_mark (build_string (len + 1, string));\n \n-  TREE_TYPE (result)\n-      = build_array_type (char_type_node,\n-                          build_index_type (build_int_2 (len, 0)));\n+  TREE_TYPE (result) = build_array_type\n+    (char_type_node, build_index_type (build_int_cst (NULL_TREE, len, 0)));\n   TREE_CONSTANT (result) = 1;\n   TREE_INVARIANT (result) = 1;\n   TREE_READONLY (result) = 1;\n@@ -917,8 +916,9 @@ mx_register_decls (tree decl, tree *stmt_list)\n                                                  decl))),\n                        tree_cons (NULL_TREE, \n                                   size,\n-                                  tree_cons (NULL_TREE, \n-                                             build_int_2 (3, 0), /* __MF_TYPE_STACK */\n+                                  tree_cons (NULL_TREE,\n+\t\t\t\t\t     /* __MF_TYPE_STACK */\n+                                             build_int_cst (NULL_TREE, 3, 0),\n                                              NULL_TREE)));\n           /* __mf_unregister (...) */\n           unregister_fncall = build_function_call_expr (mf_unregister_fndecl,\n@@ -935,7 +935,8 @@ mx_register_decls (tree decl, tree *stmt_list)\n                        tree_cons (NULL_TREE,\n                                   size,\n                                   tree_cons (NULL_TREE,\n-                                             build_int_2 (3, 0), /* __MF_TYPE_STACK */\n+\t\t\t\t\t     /* __MF_TYPE_STACK */\n+                                             build_int_cst (NULL_TREE, 3, 0),\n                                              tree_cons (NULL_TREE,\n                                                         variable_name,\n                                                         NULL_TREE))));\n@@ -1078,7 +1079,7 @@ mudflap_register_call (tree obj, tree object_size, tree varname)\n \n   args = tree_cons (NULL_TREE, varname, NULL_TREE);\n \n-  arg = build_int_2 (4, 0); /* __MF_TYPE_STATIC */\n+  arg = build_int_cst (NULL_TREE, 4, 0); /* __MF_TYPE_STATIC */\n   args = tree_cons (NULL_TREE, arg, args);\n \n   arg = convert (size_type_node, object_size);\n@@ -1160,7 +1161,7 @@ mudflap_enqueue_constant (tree obj)\n     return;\n \n   if (TREE_CODE (obj) == STRING_CST)\n-    object_size = build_int_2 (TREE_STRING_LENGTH (obj), 0);\n+    object_size = build_int_cst (NULL_TREE, TREE_STRING_LENGTH (obj), 0);\n   else\n     object_size = size_in_bytes (TREE_TYPE (obj));\n "}, {"sha": "00dbee988cda75399b2ab8d2ada5e442fe6c73d0", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -405,7 +405,7 @@ get_trampoline_type (void)\n       align = STACK_BOUNDARY;\n     }\n \n-  t = build_index_type (build_int_2 (size - 1, 0));\n+  t = build_index_type (build_int_cst (NULL_TREE, size - 1, 0));\n   t = build_array_type (char_type_node, t);\n   t = build_decl (FIELD_DECL, get_identifier (\"__data\"), t);\n   DECL_ALIGN (t) = align;\n@@ -488,7 +488,8 @@ get_nl_goto_field (struct nesting_info *info)\n       size = size / GET_MODE_SIZE (Pmode);\n       size = size + 1;\n \n-      type = build_array_type (type, build_index_type (build_int_2 (size, 0)));\n+      type = build_array_type\n+\t(type, build_index_type (build_int_cst (NULL_TREE, size, 0)));\n \n       field = make_node (FIELD_DECL);\n       DECL_NAME (field) = get_identifier (\"__nl_goto_buf\");"}, {"sha": "064c2b00d1286e8d78ac421c58934b74937dea10", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -473,9 +473,10 @@ dump_generic_node (pretty_printer *buffer, tree node, int spc, int flags,\n \t  if (tree_int_cst_sgn (val) < 0)\n \t    {\n \t      pp_character (buffer, '-');\n-\t      val = build_int_2 (-TREE_INT_CST_LOW (val),\n-\t\t\t\t ~TREE_INT_CST_HIGH (val)\n-\t\t\t\t + !TREE_INT_CST_LOW (val));\n+\t      val = build_int_cst (NULL_TREE,\n+\t\t\t\t   -TREE_INT_CST_LOW (val),\n+\t\t\t\t   ~TREE_INT_CST_HIGH (val)\n+\t\t\t\t   + !TREE_INT_CST_LOW (val));\n \t    }\n \t  /* Would \"%x%0*x\" or \"%x%*0x\" get zero-padding on all\n \t     systems?  */"}, {"sha": "9149aa64c2f326bed6062c9414aa7d2ee80898f3", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1149,7 +1149,8 @@ widen_bitfield (tree val, tree field, tree var)\n \tmask |= ((HOST_WIDE_INT) 1) << i;\n \n       wide_val = build (BIT_AND_EXPR, TREE_TYPE (var), val, \n-\t\t\tfold_convert (TREE_TYPE (var), build_int_2 (mask, 0)));\n+\t\t\tfold_convert (TREE_TYPE (var),\n+\t\t\t\t      build_int_cst (NULL_TREE, mask, 0)));\n     }\n   else\n     {\n@@ -1160,7 +1161,8 @@ widen_bitfield (tree val, tree field, tree var)\n \tmask |= ((HOST_WIDE_INT) 1) << (var_size - i - 1);\n \n       wide_val = build (BIT_IOR_EXPR, TREE_TYPE (var), val,\n-\t\t\tfold_convert (TREE_TYPE (var), build_int_2 (mask, 0)));\n+\t\t\tfold_convert (TREE_TYPE (var),\n+\t\t\t\t      build_int_cst (NULL_TREE, mask, 0)));\n     }\n \n   return fold (wide_val);\n@@ -1691,7 +1693,7 @@ maybe_fold_offset_to_array_ref (tree base, tree offset, tree orig_type)\n \t  || lrem || hrem)\n \treturn NULL_TREE;\n \n-      idx = build_int_2 (lquo, hquo);\n+      idx = build_int_cst (NULL_TREE, lquo, hquo);\n     }\n \n   /* Assume the low bound is zero.  If there is a domain type, get the"}, {"sha": "5fd5363043297564a66e226deec2c902963250a9", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1795,7 +1795,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \n \t  if (rhs_code == TRUNC_DIV_EXPR)\n \t    t = build (RSHIFT_EXPR, TREE_TYPE (op0), op0,\n-\t\t       build_int_2 (tree_log2 (op1), 0));\n+\t\t       build_int_cst (NULL_TREE, tree_log2 (op1), 0));\n \t  else\n \t    t = build (BIT_AND_EXPR, TREE_TYPE (op0), op0,\n \t\t       local_fold (build (MINUS_EXPR, TREE_TYPE (op1),"}, {"sha": "03244b08f1e81f35294df103f0c15f0b5edbe921", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -351,7 +351,7 @@ number_of_iterations_cond (tree type, tree base0, tree step0,\n \t (inverse(s/d) * (c/d)) mod (size of mode/d).  */\n       s = step0;\n       d = integer_one_node;\n-      bound = convert (niter_type, build_int_2 (~0, ~0));\n+      bound = convert (niter_type, build_int_cst (NULL_TREE, ~0, ~0));\n       while (1)\n \t{\n \t  tmp = EXEC_BINARY (BIT_AND_EXPR, niter_type, s,\n@@ -877,7 +877,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \t    fprintf (dump_file,\n \t\t     \"Proved that loop %d iterates %d times using brute force.\\n\",\n \t\t     loop->num, i);\n-\t  return build_int_2 (i, 0);\n+\t  return build_int_cst (NULL_TREE, i, 0);\n \t}\n \n       for (j = 0; j < 2; j++)\n@@ -1091,7 +1091,7 @@ upper_bound_in_type (tree outer, tree inner)\n \n   return convert (outer,\n \t\t  convert (inner,\n-\t\t\t   build_int_2 (lo, hi)));\n+\t\t\t   build_int_cst (NULL_TREE, lo, hi)));\n }\n \n /* Returns the smallest value obtainable by casting something in INNER type to\n@@ -1118,7 +1118,7 @@ lower_bound_in_type (tree outer, tree inner)\n \n   return convert (outer,\n \t\t  convert (inner,\n-\t\t\t   build_int_2 (lo, hi)));\n+\t\t\t   build_int_cst (NULL_TREE, lo, hi)));\n }\n \n /* Returns true if statement S1 dominates statement S2.  */"}, {"sha": "1582d7b595fd0fde8668f8d02ebd10e4d1493260", "filename": "gcc/tree.c", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -420,18 +420,22 @@ copy_list (tree list)\n }\n \n \f\n-/* Return a newly constructed INTEGER_CST node whose constant value\n-   is specified by the two ints LOW and HI.\n-   The TREE_TYPE is set to `int'.  */\n+/* Create an INT_CST node of TYPE and value HI:LOW.  If TYPE is NULL,\n+   integer_type_node is used.  */\n \n tree\n-build_int_2 (unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n+build_int_cst (tree type, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n {\n-  tree t = make_node (INTEGER_CST);\n+  tree t;\n+\n+  if (!type)\n+    type = integer_type_node;\n+\n+  t = make_node (INTEGER_CST);\n \n   TREE_INT_CST_LOW (t) = low;\n   TREE_INT_CST_HIGH (t) = hi;\n-  TREE_TYPE (t) = integer_type_node;\n+  TREE_TYPE (t) = type;\n   return t;\n }\n \n@@ -5256,7 +5260,7 @@ make_vector_type (tree innertype, int nunits, enum machine_mode mode)\n   layout_type (t);\n \n   {\n-    tree index = build_int_2 (nunits - 1, 0);\n+    tree index = build_int_cst (NULL_TREE, nunits - 1, 0);\n     tree array = build_array_type (innertype, build_index_type (index));\n     tree rt = make_node (RECORD_TYPE);\n \n@@ -5333,8 +5337,7 @@ build_common_tree_nodes (int signed_char)\n      boolean_type_node before calling build_common_tree_nodes_2.  */\n   boolean_type_node = make_unsigned_type (BOOL_TYPE_SIZE);\n   TREE_SET_CODE (boolean_type_node, BOOLEAN_TYPE);\n-  TYPE_MAX_VALUE (boolean_type_node) = build_int_2 (1, 0);\n-  TREE_TYPE (TYPE_MAX_VALUE (boolean_type_node)) = boolean_type_node;\n+  TYPE_MAX_VALUE (boolean_type_node) = build_int_cst (boolean_type_node, 1, 0);\n   TYPE_PRECISION (boolean_type_node) = 1;\n \n   /* Fill in the rest of the sized types.  Reuse existing type nodes\n@@ -5363,9 +5366,9 @@ void\n build_common_tree_nodes_2 (int short_double)\n {\n   /* Define these next since types below may used them.  */\n-  integer_zero_node = build_int_2 (0, 0);\n-  integer_one_node = build_int_2 (1, 0);\n-  integer_minus_one_node = build_int_2 (-1, -1);\n+  integer_zero_node = build_int_cst (NULL_TREE, 0, 0);\n+  integer_one_node = build_int_cst (NULL_TREE, 1, 0);\n+  integer_minus_one_node = build_int_cst (NULL_TREE, -1, -1);\n \n   size_zero_node = size_int (0);\n   size_one_node = size_int (1);\n@@ -5384,8 +5387,8 @@ build_common_tree_nodes_2 (int short_double)\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;\n   TYPE_USER_ALIGN (void_type_node) = 0;\n \n-  null_pointer_node = build_int_2 (0, 0);\n-  TREE_TYPE (null_pointer_node) = build_pointer_type (void_type_node);\n+  null_pointer_node = build_int_cst (build_pointer_type (void_type_node),\n+\t\t\t\t     0, 0);\n   layout_type (TREE_TYPE (null_pointer_node));\n \n   ptr_type_node = build_pointer_type (void_type_node);"}, {"sha": "1df73ca87cd939c7d55b56682dfff433a5bd6499", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -2716,7 +2716,7 @@ extern tree build4_stat (enum tree_code, tree, tree, tree, tree,\n \t\t\t tree MEM_STAT_DECL);\n #define build4(c,t1,t2,t3,t4,t5) build4_stat (c,t1,t2,t3,t4,t5 MEM_STAT_INFO)\n \n-extern tree build_int_2 (unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n+extern tree build_int_cst (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n extern tree build_vector (tree, tree);\n extern tree build_constructor (tree, tree);\n extern tree build_real_from_int_cst (tree, tree);"}, {"sha": "950a33524e86d2bcab6c82a1693ee11168052e38", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -1,3 +1,7 @@\n+2004-08-14  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* treetree.c (tree_code_get_integer_value): Use build_int_cst.\n+\n 2004-07-31  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* Make-lang.in (TREE_BE_LIBS): Remove."}, {"sha": "a2bdc0070a89e2e43f4c0f77ff3c95f702fca533", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a90aeeb51438af9f31cf57ccbba6fdd7c331398/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=4a90aeeb51438af9f31cf57ccbba6fdd7c331398", "patch": "@@ -680,7 +680,7 @@ tree_code_get_integer_value (unsigned char* chars, unsigned int length)\n   for (ix = start; ix < length; ix++)\n     val = val * 10 + chars[ix] - (unsigned char)'0';\n   val = val*negative;\n-  return build_int_2 (val & 0xffffffff, (val >> 32) & 0xffffffff);\n+  return build_int_cst (NULL_TREE, val & 0xffffffff, (val >> 32) & 0xffffffff);\n }\n \n /* Return the tree for an expresssion, type EXP_TYPE (see treetree.h)"}]}