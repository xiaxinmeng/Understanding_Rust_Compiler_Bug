{"sha": "802a0058bd44c4163743b682926faacaf14d7b81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAyYTAwNThiZDQ0YzQxNjM3NDNiNjgyOTI2ZmFhY2FmMTRkN2I4MQ==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-05-28T19:58:24Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1996-05-28T19:58:24Z"}, "message": "Fix problems in float/int conversion in inline functions\n\nFrom-SVN: r12122", "tree": {"sha": "627990e3a3942dae74f4cecab49c150bac528480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/627990e3a3942dae74f4cecab49c150bac528480"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/802a0058bd44c4163743b682926faacaf14d7b81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802a0058bd44c4163743b682926faacaf14d7b81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/802a0058bd44c4163743b682926faacaf14d7b81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802a0058bd44c4163743b682926faacaf14d7b81/comments", "author": null, "committer": null, "parents": [{"sha": "184962039c7025fbb748337f4dae07269116d9ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/184962039c7025fbb748337f4dae07269116d9ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/184962039c7025fbb748337f4dae07269116d9ff"}], "stats": {"total": 654, "additions": 478, "deletions": 176}, "files": [{"sha": "276008b4b517106059b4f9c1e9664185fcb77b32", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 133, "deletions": 46, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=802a0058bd44c4163743b682926faacaf14d7b81", "patch": "@@ -99,35 +99,42 @@ int rs6000_save_toc_p;\n /* ABI enumeration available for subtarget to use.  */\n enum rs6000_abi rs6000_current_abi;\n \n+/* Offset & size for fpmem stack locations used for converting between\n+   float and integral types.  */\n+int rs6000_fpmem_offset;\n+int rs6000_fpmem_size;\n+\n \f\n /* Default register names.  */\n char rs6000_reg_names[][8] =\n {\n-   \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\n-   \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n-  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n-  \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n-   \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\n-   \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n-  \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n-  \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n-  \"mq\", \"lr\", \"ctr\",\"ap\",\n-   \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\"\n+      \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\n+      \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+     \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+     \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+      \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\n+      \"8\",  \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+     \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+     \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+     \"mq\", \"lr\", \"ctr\",\"ap\",\n+      \"0\",  \"1\",  \"2\",  \"3\",  \"4\",  \"5\",  \"6\",  \"7\",\n+  \"fpmem\"\n };\n \n #ifdef TARGET_REGNAMES\n static char alt_reg_names[][8] =\n {\n-   \"%r0\",  \"%r1\",  \"%r2\",  \"%r3\",  \"%r4\",  \"%r5\",  \"%r6\",  \"%r7\",\n-   \"%r8\",  \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\n-  \"%r16\", \"%r17\", \"%r18\", \"%r19\", \"%r20\", \"%r21\", \"%r22\", \"%r23\",\n-  \"%r24\", \"%r25\", \"%r26\", \"%r27\", \"%r28\", \"%r29\", \"%r30\", \"%r31\",\n-   \"%f0\",  \"%f1\",  \"%f2\",  \"%f3\",  \"%f4\",  \"%f5\",  \"%f6\",  \"%f7\",\n-   \"%f8\",  \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\n-  \"%f16\", \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\n-  \"%f24\", \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\",\n-    \"mq\",   \"lr\",  \"ctr\",   \"ap\",\n-  \"%cr0\", \"%cr1\", \"%cr2\", \"%cr3\", \"%cr4\", \"%cr5\", \"%cr6\", \"%cr7\"\n+   \"%r0\",   \"%r1\",  \"%r2\",  \"%r3\",  \"%r4\",  \"%r5\",  \"%r6\",  \"%r7\",\n+   \"%r8\",   \"%r9\", \"%r10\", \"%r11\", \"%r12\", \"%r13\", \"%r14\", \"%r15\",\n+  \"%r16\",  \"%r17\", \"%r18\", \"%r19\", \"%r20\", \"%r21\", \"%r22\", \"%r23\",\n+  \"%r24\",  \"%r25\", \"%r26\", \"%r27\", \"%r28\", \"%r29\", \"%r30\", \"%r31\",\n+   \"%f0\",   \"%f1\",  \"%f2\",  \"%f3\",  \"%f4\",  \"%f5\",  \"%f6\",  \"%f7\",\n+   \"%f8\",   \"%f9\", \"%f10\", \"%f11\", \"%f12\", \"%f13\", \"%f14\", \"%f15\",\n+  \"%f16\",  \"%f17\", \"%f18\", \"%f19\", \"%f20\", \"%f21\", \"%f22\", \"%f23\",\n+  \"%f24\",  \"%f25\", \"%f26\", \"%f27\", \"%f28\", \"%f29\", \"%f30\", \"%f31\",\n+    \"mq\",    \"lr\",  \"ctr\",   \"ap\",\n+  \"%cr0\",  \"%cr1\", \"%cr2\", \"%cr3\", \"%cr4\", \"%cr5\", \"%cr6\", \"%cr7\",\n+ \"fpmem\"\n };\n #endif\n \f\n@@ -363,6 +370,26 @@ int count_register_operand(op, mode)\n   return 0;\n }\n \n+/* Returns 1 if op is memory location for float/int conversions that masquerades\n+   as a register.  */\n+int fpmem_operand(op, mode)\n+     register rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) != REG)\n+    return 0;\n+\n+  if (FPMEM_REGNO_P (REGNO (op)))\n+    return 1;\n+\n+#if 0\n+  if (REGNO (op) > FIRST_PSEUDO_REGISTER)\n+    return 1;\n+#endif\n+\n+  return 0;\n+}\n+\n /* Return 1 if OP is a constant that can fit in a D field.  */\n \n int\n@@ -404,7 +431,9 @@ gpc_reg_operand (op, mode)\n      enum machine_mode mode;\n {\n   return (register_operand (op, mode)\n-\t  && (GET_CODE (op) != REG || REGNO (op) >= 67 || REGNO (op) < 64));\n+\t  && (GET_CODE (op) != REG\n+\t      || (REGNO (op) >= 67 && !FPMEM_REGNO_P (REGNO (op)))\n+\t      || REGNO (op) < 64));\n }\n \n /* Returns 1 if OP is either a pseudo-register or a register denoting a\n@@ -1785,7 +1814,7 @@ includes_rshift_p (shiftop, andop)\n      register rtx shiftop;\n      register rtx andop;\n {\n-  unsigned shift_mask = ~0;\n+  unsigned shift_mask = ~(unsigned)0;\n \n   shift_mask >>= INTVAL (shiftop);\n \n@@ -2319,13 +2348,29 @@ print_operand (file, x, code)\n       return;\n       \n     case 'u':\n-      /* High-order 16 bits of constant.  */\n+      /* High-order 16 bits of constant for use in unsigned operand.  */\n       if (! INT_P (x))\n \toutput_operand_lossage (\"invalid %%u value\");\n \n       fprintf (file, \"0x%x\", (INT_LOWPART (x) >> 16) & 0xffff);\n       return;\n \n+    case 'v':\n+      /* High-order 16 bits of constant for use in signed operand.  */\n+      if (! INT_P (x))\n+\toutput_operand_lossage (\"invalid %%v value\");\n+\n+      {\n+\tint value = (INT_LOWPART (x) >> 16) & 0xffff;\n+\n+\t/* Solaris assembler doesn't like lis 0,0x80000 */\n+\tif (DEFAULT_ABI == ABI_SOLARIS && (value & 0x8000) != 0)\n+\t  fprintf (file, \"%d\", value | (~0 << 16));\n+\telse\n+\t  fprintf (file, \"0x%x\", value);\n+\treturn;\n+      }\n+\n     case 'U':\n       /* Print `u' if this has an auto-increment or auto-decrement.  */\n       if (GET_CODE (x) == MEM\n@@ -2575,13 +2620,15 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 24\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t| Float/int conversion temporary (X)\t| 24+P\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t| 24+P+X\n \t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 24+P+A\n+\t\t| Local variable space (L)\t\t| 24+P+X+A\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 24+P+A+L\n+\t\t| Save area for GP registers (G)\t| 24+P+X+A+L\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 24+P+A+L+G\n+\t\t| Save area for FP registers (F)\t| 24+P+X+A+L+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2595,17 +2642,19 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 8\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 8+P\n+\t\t| Float/int conversion temporary (X)\t| 8+P\n \t\t+---------------------------------------+\n-\t\t| Varargs save area (V)\t\t\t| 8+P+A\n+\t\t| Alloca space (A)\t\t\t| 8+P+X\n \t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 8+P+A+V\n+\t\t| Varargs save area (V)\t\t\t| 8+P+X+A\n \t\t+---------------------------------------+\n-\t\t| saved CR (C)\t\t\t\t| 8+P+A+V+L\n+\t\t| Local variable space (L)\t\t| 8+P+X+A+V\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 8+P+A+V+L+C\n+\t\t| saved CR (C)\t\t\t\t| 8+P+X+A+V+L\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 8+P+A+V+L+C+G\n+\t\t| Save area for GP registers (G)\t| 8+P+X+A+V+L+C\n+\t\t+---------------------------------------+\n+\t\t| Save area for FP registers (F)\t| 8+P+X+A+V+L+C+G\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2628,21 +2677,23 @@ rs6000_makes_calls ()\n \t\t+---------------------------------------+\n \t\t| Parameter save area (P)\t\t| 24\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t| 24+P\n+\t\t| Float/int conversion temporary (X)\t| 24+P\n+\t\t+---------------------------------------+\n+\t\t| Alloca space (A)\t\t\t| 24+P+X\n \t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t| 24+P+A\n+\t\t| Local variable space (L)\t\t| 24+P+X+A\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t| 24+P+A+L\n+\t\t| Save area for FP registers (F)\t| 24+P+X+A+L\n \t\t+---------------------------------------+\n-\t\t| Possible alignment area (X)\t\t| 24+P+A+L+F\n+\t\t| Possible alignment area (X)\t\t| 24+P+X+A+L+F\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t| 24+P+A+L+F+X\n+\t\t| Save area for GP registers (G)\t| 24+P+X+A+L+F+X\n \t\t+---------------------------------------+\n-\t\t| Save area for CR (C)\t\t\t| 24+P+A+L+F+X+G\n+\t\t| Save area for CR (C)\t\t\t| 24+P+X+A+L+F+X+G\n \t\t+---------------------------------------+\n-\t\t| Save area for TOC (T)\t\t\t| 24+P+A+L+F+X+G+C\n+\t\t| Save area for TOC (T)\t\t\t| 24+P+X+A+L+F+X+G+C\n \t\t+---------------------------------------+\n-\t\t| Save area for LR (R)\t\t\t| 24+P+A+L+F+X+G+C+T\n+\t\t| Save area for LR (R)\t\t\t| 24+P+X+A+L+F+X+G+C+T\n \t\t+---------------------------------------+\n \told SP->| back chain to caller's caller\t\t|\n \t\t+---------------------------------------+\n@@ -2685,6 +2736,9 @@ rs6000_stack_info ()\n       info_ptr->toc_size = reg_size;\n     }\n \n+  /* Does this machine need the float/int conversion area? */\n+  info_ptr->fpmem_p = regs_ever_live[FPMEM_REGNUM];\n+\n   /* If this is main and we need to call a function to set things up,\n      save main's arguments around the call.  */\n #ifdef TARGET_EABI\n@@ -2749,6 +2803,7 @@ rs6000_stack_info ()\n   info_ptr->varargs_size = RS6000_VARARGS_AREA;\n   info_ptr->vars_size    = ALIGN (get_frame_size (), 8);\n   info_ptr->parm_size    = ALIGN (current_function_outgoing_args_size, 8);\n+  info_ptr->fpmem_size\t = (info_ptr->fpmem_p) ? 8 : 0;\n   info_ptr->save_size    = ALIGN (info_ptr->fp_size\n \t\t\t\t  + info_ptr->gp_size\n \t\t\t\t  + info_ptr->cr_size\n@@ -2758,6 +2813,7 @@ rs6000_stack_info ()\n \n   total_raw_size\t = (info_ptr->vars_size\n \t\t\t    + info_ptr->parm_size\n+\t\t\t    + info_ptr->fpmem_size\n \t\t\t    + info_ptr->save_size\n \t\t\t    + info_ptr->varargs_size\n \t\t\t    + info_ptr->fixed_size);\n@@ -2785,6 +2841,7 @@ rs6000_stack_info ()\n \t\t\t|| info_ptr->total_size > 220);\n \n   /* Calculate the offsets */\n+  info_ptr->fpmem_offset = info_ptr->total_size - info_ptr->parm_size;\n   switch (abi)\n     {\n     case ABI_NONE:\n@@ -2842,6 +2899,16 @@ rs6000_stack_info ()\n   if (!info_ptr->main_save_p)\n     info_ptr->main_save_offset = 0;\n \n+  if (!info_ptr->fpmem_p)\n+    info_ptr->fpmem_offset = 0;\n+  else\n+    {\n+      rs6000_fpmem_size   = info_ptr->fpmem_size;\n+      rs6000_fpmem_offset = STACK_DYNAMIC_OFFSET (current_function_decl) - info_ptr->fpmem_size;\n+      if (rs6000_fpmem_offset > 32767)\n+\tabort ();\n+    }\n+\n   return info_ptr;\n }\n \n@@ -2899,6 +2966,9 @@ debug_stack_info (info)\n   if (info->main_save_p)\n     fprintf (stderr, \"\\tmain_save_p         = %5d\\n\", info->main_save_p);\n \n+  if (info->fpmem_p)\n+    fprintf (stderr, \"\\tfpmem_p             = %5d\\n\", info->fpmem_p);\n+\n   if (info->gp_save_offset)\n     fprintf (stderr, \"\\tgp_save_offset      = %5d\\n\", info->gp_save_offset);\n \n@@ -2920,6 +2990,9 @@ debug_stack_info (info)\n   if (info->main_save_offset)\n     fprintf (stderr, \"\\tmain_save_offset    = %5d\\n\", info->main_save_offset);\n \n+  if (info->fpmem_offset)\n+    fprintf (stderr, \"\\tfpmem_offset        = %5d\\n\", info->fpmem_offset);\n+\n   if (info->total_size)\n     fprintf (stderr, \"\\ttotal_size          = %5d\\n\", info->total_size);\n \n@@ -2932,6 +3005,9 @@ debug_stack_info (info)\n   if (info->parm_size)\n     fprintf (stderr, \"\\tparm_size           = %5d\\n\", info->parm_size);\n \n+  if (info->fpmem_size)\n+    fprintf (stderr, \"\\tfpmem_size          = %5d\\n\", info->fpmem_size);\n+\n   if (info->fixed_size)\n     fprintf (stderr, \"\\tfixed_size          = %5d\\n\", info->fixed_size);\n \n@@ -3619,6 +3695,8 @@ output_epilog (file, size)\n   /* Reset varargs and save TOC indicator */\n   rs6000_sysv_varargs_p = 0;\n   rs6000_save_toc_p = 0;\n+  rs6000_fpmem_size = 0;\n+  rs6000_fpmem_offset = 0;\n   pic_offset_table_rtx = (rtx)0;\n \n   if (DEFAULT_ABI == ABI_NT)\n@@ -4601,7 +4679,6 @@ handle_mac_pragma (finput, t)\n   pname = IDENTIFIER_POINTER (t);\n   if (strcmp (pname, \"segment\") == 0)\n     {\n-      retval = 1;\n       /* (should collect pbuf + 8 into a segment name) */\n     }\n   else if (strcmp (pname, \"options\") == 0)\n@@ -4613,7 +4690,10 @@ handle_mac_pragma (finput, t)\n \n       /* Return without doing anything if no content.  */\n       if (c == '\\n' || c == EOF)\n-\treturn 0;\n+\t{\n+\t  ungetc (c, finput);\n+\t  return 0;\n+\t}\n \n       /* Collect the rest of the line.  */\n       while (psize < sizeof (pbuf) - 1 && c != '\\n')\n@@ -4624,14 +4704,21 @@ handle_mac_pragma (finput, t)\n \n       if (strncmp (pbuf, \"align=mac68k\", 12) == 0)\n \t{\n-\t  mac68k_aligned = retval = 1;\n+\t  mac68k_aligned = 1;\n+\t  retval = 1;\n+\t}\n+      else if (strncmp (pbuf, \"align=power\", 11) == 0)\n+\t{\n+\t  mac68k_aligned = 0;\n+\t  retval = 1;\n \t}\n       else if (strncmp (pbuf, \"align=reset\", 11) == 0)\n \t{\n-\t  mac68k_aligned = 0, retval = 1;\n+\t  mac68k_aligned = 0;\n+\t  retval = 1;\n \t}\n     }\n \n-  return c;\n+  return retval;\n }\n /* END CYGNUS LOCAL mac */"}, {"sha": "5f0d7b922e4e9afb524d6aeb856c48443cbbf870", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 106, "deletions": 48, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=802a0058bd44c4163743b682926faacaf14d7b81", "patch": "@@ -618,9 +618,14 @@ extern struct rs6000_cpu_select rs6000_select[];\n    In addition, the difference between the frame and argument pointers is\n    a function of the number of registers saved, so we need to have a\n    register for AP that will later be eliminated in favor of SP or FP.\n-   This is a normal register, but it is fixed.  */\n+   This is a normal register, but it is fixed.\n \n-#define FIRST_PSEUDO_REGISTER 76\n+   We also create a pseudo register for float/int conversions, that will\n+   really represent the memory location used.  It is represented here as\n+   a register, in order to work around problems in allocating stack storage\n+   in inline functions.  */\n+\n+#define FIRST_PSEUDO_REGISTER 77\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -640,7 +645,7 @@ extern struct rs6000_cpu_select rs6000_select[];\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-   0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0}\n+   0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -654,7 +659,7 @@ extern struct rs6000_cpu_select rs6000_select[];\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, \\\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n-   1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1}\n+   1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1}\n \n /* List the order in which to allocate registers.  Each register must be\n    listed once, even those in FIXED_REGISTERS.\n@@ -691,7 +696,7 @@ extern struct rs6000_cpu_select rs6000_select[];\n    31, 30, 29, 28, 27, 26, 25, 24, 23, 22, 21, 20, 19,\t\\\n    18, 17, 16, 15, 14, 13, 12,\t\t\t\t\\\n    64, 66, 65, \t\t\t\t\t\t\\\n-   73, 1, 2, 67}\n+   73, 1, 2, 67, 76}\n \n /* True if register is floating-point.  */\n #define FP_REGNO_P(N) ((N) >= 32 && (N) <= 63)\n@@ -702,6 +707,10 @@ extern struct rs6000_cpu_select rs6000_select[];\n /* True if register is an integer register.  */\n #define INT_REGNO_P(N) ((N) <= 31 || (N) == 67)\n \n+/* True if register is the temporary memory location used for int/float\n+   conversion.  */\n+#define FPMEM_REGNO_P(N) ((N) == FPMEM_REGNUM)\n+\n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n@@ -710,8 +719,8 @@ extern struct rs6000_cpu_select rs6000_select[];\n    On RS/6000, ordinary registers hold 32 bits worth;\n    a single floating point register holds 64 bits worth.  */\n \n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-  (FP_REGNO_P (REGNO)\t\t\t\\\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\t\\\n+  (FP_REGNO_P (REGNO) || FPMEM_REGNO_P (REGNO)\t\t\t\t\\\n    ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n@@ -721,13 +730,14 @@ extern struct rs6000_cpu_select rs6000_select[];\n    can hold CC modes.  We cannot put TImode anywhere except general\n    register and it must be able to fit within the register set. */\n \n-#define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n-  (FP_REGNO_P (REGNO) ?\t\t\t\t\t\t\\\n-   (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-    || (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\\\n-\t&& GET_MODE_SIZE (MODE) == UNITS_PER_FP_WORD))\t\t\\\n-   : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\\\n-   : ! INT_REGNO_P (REGNO) ? (GET_MODE_CLASS (MODE) == MODE_INT\t\\\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n+  (FP_REGNO_P (REGNO) ?\t\t\t\t\t\t\t\\\n+   (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\t\\\n+    || (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n+\t&& GET_MODE_SIZE (MODE) == UNITS_PER_FP_WORD))\t\t\t\\\n+   : CR_REGNO_P (REGNO) ? GET_MODE_CLASS (MODE) == MODE_CC\t\t\\\n+   : FPMEM_REGNO_P (REGNO) ? ((MODE) == DImode || (MODE) == DFmode)\t\\\n+   : ! INT_REGNO_P (REGNO) ? (GET_MODE_CLASS (MODE) == MODE_INT\t\t\\\n \t\t\t      && GET_MODE_SIZE (MODE) <= UNITS_PER_WORD) \\\n    : 1)\n \n@@ -761,7 +771,7 @@ extern struct rs6000_cpu_select rs6000_select[];\n        || (CLASS1) == LINK_OR_CTR_REGS)\t\t\t\t\\\n       && ((CLASS2) == SPECIAL_REGS || (CLASS2) == MQ_REGS\t\\\n \t  || (CLASS2) == LINK_REGS || (CLASS2) == CTR_REGS\t\\\n-\t  || (CLASS2) == LINK_OR_CTR_REGS)) ? 10 \\\n+\t  || (CLASS2) == LINK_OR_CTR_REGS)) ? 10\t\t\\\n    : 2)\n \n /* A C expressions returning the cost of moving data of MODE from a register to\n@@ -834,6 +844,9 @@ extern struct rs6000_cpu_select rs6000_select[];\n /* count register number for special purposes */\n #define COUNT_REGISTER_REGNUM 66\n \n+/* Special register that represents memory, used for float/int conversions.  */\n+#define FPMEM_REGNUM 76\n+\n /* Place that structure value return address is placed.\n \n    On the RS/6000, it is passed as an extra parameter.  */\n@@ -867,7 +880,14 @@ extern struct rs6000_cpu_select rs6000_select[];\n    So make a class for registers valid as base registers.\n \n    Also, cr0 is the only condition code register that can be used in\n-   arithmetic insns, so make a separate class for it. */\n+   arithmetic insns, so make a separate class for it.\n+\n+   There is a special 'registrer' (76), which is not a register, but a\n+   placeholder for memory allocated to convert between floating point and\n+   integral types.  This works around a problem where if we allocate memory\n+   with allocate_stack_{local,temp} and the function is an inline function, the\n+   memory allocated will clobber memory in the caller.  So we use a special\n+   register, and if that is used, we allocate stack space for it.  */\n \n enum reg_class\n {\n@@ -885,6 +905,8 @@ enum reg_class\n   CR0_REGS,\n   CR_REGS,\n   NON_FLOAT_REGS,\n+  FPMEM_REGS,\n+  FLOAT_OR_FPMEM_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n };\n@@ -909,6 +931,8 @@ enum reg_class\n   \"CR0_REGS\",\t\t\t\t\t\t\t\t\\\n   \"CR_REGS\",\t\t\t\t\t\t\t\t\\\n   \"NON_FLOAT_REGS\",\t\t\t\t\t\t\t\\\n+  \"FPMEM_REGS\",\t\t\t\t\t\t\t\t\\\n+  \"FLOAT_OR_FPMEM_REGS\",\t\t\t\t\t\t\\\n   \"ALL_REGS\"\t\t\t\t\t\t\t\t\\\n }\n \n@@ -932,24 +956,27 @@ enum reg_class\n   { 0x00000000, 0x00000000, 0x00000010 },\t/* CR0_REGS */\t\t\\\n   { 0x00000000, 0x00000000, 0x00000ff0 },\t/* CR_REGS */\t\t\\\n   { 0xffffffff, 0x00000000, 0x0000ffff },\t/* NON_FLOAT_REGS */\t\\\n-  { 0xffffffff, 0xffffffff, 0x0000ffff }\t/* ALL_REGS */\t\t\\\n+  { 0x00000000, 0x00000000, 0x00010000 },\t/* FPMEM_REGS */\t\\\n+  { 0x00000000, 0xffffffff, 0x00010000 },\t/* FLOAT_OR_FPMEM_REGS */ \\\n+  { 0xffffffff, 0xffffffff, 0x0001ffff }\t/* ALL_REGS */\t\t\\\n }\n \n /* The same information, inverted:\n    Return the class number of the smallest class containing\n    reg number REGNO.  This could be a conditional expression\n    or could index an array.  */\n \n-#define REGNO_REG_CLASS(REGNO)\t\\\n- ((REGNO) == 0 ? GENERAL_REGS\t\\\n-  : (REGNO) < 32 ? BASE_REGS\t\\\n-  : FP_REGNO_P (REGNO) ? FLOAT_REGS \\\n-  : (REGNO) == 68 ? CR0_REGS\t\\\n-  : CR_REGNO_P (REGNO) ? CR_REGS \\\n-  : (REGNO) == 64 ? MQ_REGS\t\\\n-  : (REGNO) == 65 ? LINK_REGS\t\\\n-  : (REGNO) == 66 ? CTR_REGS\t\\\n-  : (REGNO) == 67 ? BASE_REGS\t\\\n+#define REGNO_REG_CLASS(REGNO)\t\t\\\n+ ((REGNO) == 0 ? GENERAL_REGS\t\t\\\n+  : (REGNO) < 32 ? BASE_REGS\t\t\\\n+  : FP_REGNO_P (REGNO) ? FLOAT_REGS\t\\\n+  : (REGNO) == 68 ? CR0_REGS\t\t\\\n+  : CR_REGNO_P (REGNO) ? CR_REGS\t\\\n+  : (REGNO) == 64 ? MQ_REGS\t\t\\\n+  : (REGNO) == 65 ? LINK_REGS\t\t\\\n+  : (REGNO) == 66 ? CTR_REGS\t\t\\\n+  : (REGNO) == 67 ? BASE_REGS\t\t\\\n+  : (REGNO) == 76 ? FPMEM_REGS\t\t\\\n   : NO_REGS)\n \n /* The class value for index registers, and the one for base regs.  */\n@@ -967,6 +994,7 @@ enum reg_class\n    : (C) == 'l' ? LINK_REGS\t\\\n    : (C) == 'x' ? CR0_REGS\t\\\n    : (C) == 'y' ? CR_REGS\t\\\n+   : (C) == 'z' ? FPMEM_REGS\t\\\n    : NO_REGS)\n \n /* The letters I, J, K, L, M, N, and P in a register constraint string\n@@ -1033,7 +1061,7 @@ enum reg_class\n    On the RS/6000, we have to return NO_REGS when we want to reload a\n    floating-point CONST_DOUBLE to force it to be copied to memory.  */\n \n-#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\\\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)\t\t\t\\\n   ((GET_CODE (X) == CONST_DOUBLE\t\t\t\\\n     && GET_MODE_CLASS (GET_MODE (X)) == MODE_FLOAT)\t\\\n    ? NO_REGS : (CLASS))\n@@ -1056,15 +1084,16 @@ enum reg_class\n \n    On RS/6000, this is the size of MODE in words,\n    except in the FP regs, where a single reg is enough for two words.  */\n-#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n- ((CLASS) == FLOAT_REGS\t\t\t\\\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+ (((CLASS) == FLOAT_REGS || (CLASS) == FPMEM_REGS\t\t\t\\\n+   || (CLASS) == FLOAT_OR_FPMEM_REGS)\t\t\t\t\t\\\n   ? ((GET_MODE_SIZE (MODE) + UNITS_PER_FP_WORD - 1) / UNITS_PER_FP_WORD) \\\n   : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n /* If defined, gives a class of registers that cannot be used as the\n    operand of a SUBREG that changes the size of the object.  */\n \n-#define CLASS_CANNOT_CHANGE_SIZE\tFLOAT_REGS\n+#define CLASS_CANNOT_CHANGE_SIZE\tFLOAT_OR_FPMEM_REGS\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -1096,6 +1125,7 @@ typedef struct rs6000_stack {\n   int calls_p;\t\t\t/* true if the function makes any calls */\n   int main_p;\t\t\t/* true if this is main */\n   int main_save_p;\t\t/* true if this is main and we need to save args */\n+  int fpmem_p;\t\t\t/* true if float/int conversion temp needed */\n   enum rs6000_abi abi;\t\t/* which ABI to use */\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n   int fp_save_offset;\t\t/* offset to save FP regs from initial SP */\n@@ -1104,6 +1134,7 @@ typedef struct rs6000_stack {\n   int toc_save_offset;\t\t/* offset to save the TOC pointer */\n   int varargs_save_offset;\t/* offset to save the varargs registers */\n   int main_save_offset;\t\t/* offset to save main's args */\n+  int fpmem_offset;\t\t/* offset for float/int conversion temp */\n   int reg_size;\t\t\t/* register size (4 or 8) */\n   int varargs_size;\t\t/* size to hold V.4 args passed in regs */\n   int vars_size;\t\t/* variable save area size */\n@@ -1115,6 +1146,7 @@ typedef struct rs6000_stack {\n   int fp_size;\t\t\t/* size of saved FP registers */\n   int cr_size;\t\t\t/* size to hold CR if not in save_size */\n   int lr_size;\t\t\t/* size to hold LR if not in save_size */\n+  int fpmem_size;\t\t/* size to hold float/int conversion */\n   int toc_size;\t\t\t/* size to hold TOC if not in save_size */\n   int total_size;\t\t/* total bytes allocated for stack */\n } rs6000_stack_t;\n@@ -1144,6 +1176,11 @@ typedef struct rs6000_stack {\n /* Whether a separate TOC save area is needed */\n extern int rs6000_save_toc_p;\n \n+/* Offset & size for fpmem stack locations used for converting between\n+   float and integral types.  */\n+extern int rs6000_fpmem_offset;\n+extern int rs6000_fpmem_size;\n+\n /* Size of the V.4 varargs area if needed */\n #define RS6000_VARARGS_AREA 0\n \n@@ -1158,8 +1195,10 @@ extern int rs6000_sysv_varargs_p;\n   ((GP_ARG_NUM_REG * (TARGET_32BIT ? 4 : 8)) + (FP_ARG_NUM_REG * 8) + 8)\n \n /* Offset of V.4 varargs area */\n-#define RS6000_VARARGS_OFFSET \\\n-  (ALIGN (current_function_outgoing_args_size, 8) + RS6000_SAVE_AREA)\n+#define RS6000_VARARGS_OFFSET\t\t\t\t\t\t\\\n+  (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n+   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n+   + RS6000_SAVE_AREA)\n \n /* Offset within stack frame to start allocating local variables at.\n    If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n@@ -1170,9 +1209,22 @@ extern int rs6000_sysv_varargs_p;\n    except for dynamic allocations.  So we start after the fixed area and\n    outgoing parameter area.  */\n \n-#define STARTING_FRAME_OFFSET (ALIGN (current_function_outgoing_args_size, 8) \\\n-\t\t\t       + RS6000_VARARGS_AREA \\\n-\t\t\t       + RS6000_SAVE_AREA)\n+#define STARTING_FRAME_OFFSET\t\t\t\t\t\t\\\n+  (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n+   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n+   + RS6000_VARARGS_AREA\t\t\t\t\t\t\\\n+   + RS6000_SAVE_AREA)\n+\n+/* Offset from the stack pointer register to an item dynamically\n+   allocated on the stack, e.g., by `alloca'.\n+\n+   The default value for this macro is `STACK_POINTER_OFFSET' plus the\n+   length of the outgoing arguments.  The default is correct for most\n+   machines.  See `function.c' for details.  */\n+#define STACK_DYNAMIC_OFFSET(FUNDECL)\t\t\t\t\t\\\n+  (ALIGN (current_function_outgoing_args_size, 8)\t\t\t\\\n+   + ALIGN (rs6000_fpmem_size, 8)\t\t\t\t\t\\\n+   + (STACK_POINTER_OFFSET))\n \n /* If we generate an insn to push BYTES bytes,\n    this says how many the stack pointer really advances by.\n@@ -2516,7 +2568,7 @@ toc_section ()\t\t\t\t\t\t\\\n /* How to refer to registers in assembler output.\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n-extern char rs6000_reg_names[][8];\t/* register names (a0 vs. $4). */\n+extern char rs6000_reg_names[][8];\t/* register names (0 vs. %r0). */\n \n #define REGISTER_NAMES\t\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -2599,6 +2651,8 @@ extern char rs6000_reg_names[][8];\t/* register names (a0 vs. $4). */\n   &rs6000_reg_names[73][0],\t/* cr5  */\t\t\t\t\\\n   &rs6000_reg_names[74][0],\t/* cr6  */\t\t\t\t\\\n   &rs6000_reg_names[75][0],\t/* cr7  */\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  &rs6000_reg_names[76][0],\t/* fpmem */\t\t\t\t\\\n }\n \n /* print-rtl can't handle the above REGISTER_NAMES, so define the\n@@ -2607,16 +2661,17 @@ extern char rs6000_reg_names[][8];\t/* register names (a0 vs. $4). */\n \n #define DEBUG_REGISTER_NAMES\t\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n-   \"r0\", \"r1\",   \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n-   \"r8\", \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n-  \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n-  \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\t\\\n-   \"f0\",  \"f1\",  \"f2\",  \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\t\\\n-   \"f8\",  \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\t\t\\\n-  \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\t\t\\\n-  \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\t\t\\\n-  \"mq\",   \"lr\", \"ctr\",  \"ap\",\t\t\t\t\t\t\\\n-  \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\"\t\t\\\n+     \"r0\", \"r1\",   \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\",\t\t\\\n+     \"r8\", \"r9\",  \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\t\\\n+    \"r16\", \"r17\", \"r18\", \"r19\", \"r20\", \"r21\", \"r22\", \"r23\",\t\t\\\n+    \"r24\", \"r25\", \"r26\", \"r27\", \"r28\", \"r29\", \"r30\", \"r31\",\t\t\\\n+     \"f0\",  \"f1\",  \"f2\",  \"f3\",  \"f4\",  \"f5\",  \"f6\",  \"f7\",\t\t\\\n+     \"f8\",  \"f9\", \"f10\", \"f11\", \"f12\", \"f13\", \"f14\", \"f15\",\t\t\\\n+    \"f16\", \"f17\", \"f18\", \"f19\", \"f20\", \"f21\", \"f22\", \"f23\",\t\t\\\n+    \"f24\", \"f25\", \"f26\", \"f27\", \"f28\", \"f29\", \"f30\", \"f31\",\t\t\\\n+     \"mq\",  \"lr\", \"ctr\",  \"ap\",\t\t\t\t\t\t\\\n+    \"cr0\", \"cr1\", \"cr2\", \"cr3\", \"cr4\", \"cr5\", \"cr6\", \"cr7\",\t\t\\\n+  \"fpmem\"\t\t\t\t\t\t\t\t\\\n }\n \n /* Table of additional register names to use in user input.  */\n@@ -2902,7 +2957,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Define the codes that are matched by predicates in rs6000.c.  */\n \n-#define PREDICATE_CODES \\\n+#define PREDICATE_CODES\t\t\t\t\t\t\\\n   {\"short_cint_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"u_short_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"non_short_cint_operand\", {CONST_INT}},\t\t\t\\\n@@ -2928,6 +2983,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   {\"non_logical_cint_operand\", {CONST_INT}},\t\t\t\\\n   {\"mask_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"count_register_operand\", {REG}},\t\t\t\t\\\n+  {\"fpmem_operand\", {REG}},\t\t\t\t\t\\\n   {\"call_operand\", {SYMBOL_REF, REG}},\t\t\t\t\\\n   {\"current_file_function_operand\", {SYMBOL_REF}},\t\t\\\n   {\"input_operand\", {SUBREG, MEM, REG, CONST_INT, SYMBOL_REF}},\t\\\n@@ -2983,6 +3039,8 @@ extern int non_logical_operand ();\n extern int mask_constant ();\n extern int mask_operand ();\n extern int and_operand ();\n+extern int count_register_operand ();\n+extern int fpmem_operand ();\n extern int non_and_cint_operand ();\n extern int reg_or_mem_operand ();\n extern int lwa_operand ();"}, {"sha": "0dc5f4cb572997995a20dd34003026de6edb1ca3", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 205, "deletions": 67, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=802a0058bd44c4163743b682926faacaf14d7b81", "patch": "@@ -867,7 +867,7 @@\n    {cax|add} %0,%1,%2\n    {cal %0,%2(%1)|addi %0,%1,%2}\n    {ai|addic} %0,%1,%2\n-   {cau|addis} %0,%1,%u2\")\n+   {cau|addis} %0,%1,%v2\")\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n@@ -3543,100 +3543,238 @@\n   [(set_attr \"type\" \"fp\")])\n \f\n ;; Conversions to and from floating-point.\n+\n (define_expand \"floatsidf2\"\n-  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+  [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t\t   (float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))\n+\t      (clobber (reg:DF 76))])]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (operands[0])\n-    {\t\t\t\t/* prevent unused warning messages */\n-      rtx high   = force_reg (SImode, GEN_INT (0x43300000));\n-      rtx low    = gen_reg_rtx (SImode);\n-      rtx df     = gen_reg_rtx (DFmode);\n-      rtx adjust = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n-\n-      emit_insn (gen_xorsi3 (low, operands[1], GEN_INT (0x80000000)));\n-      emit_insn (gen_move_to_float (df, low, high));\n-      emit_insn (gen_subdf3 (operands[0], df, adjust));\n-      DONE;\n-    }\n+  rtx low = gen_reg_rtx (SImode);\n+  operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n+  operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503601774854144\\\", DFmode));\n+\n+  emit_insn (gen_xorsi3 (low, operands[1], GEN_INT (0x80000000)));\n+  operands[1] = low;\n }\")\n \n-(define_expand \"floatunssidf2\"\n+(define_insn \"*floatsidf2_internal\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=&f\")\n+\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n+   (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n+   (clobber (reg:DF 76))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"#\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_split\n   [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))]\n+\t(float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+   (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (reg:DF 76))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  [(set (match_dup 4)\n+\t(unspec [(match_dup 1)\t\t;; low word\n+\t\t (reg:SI 1)] 11))\n+   (set (match_dup 4)\n+\t(unspec [(match_dup 2)\t\t;; high word\n+\t\t (reg:SI 1)\n+\t\t (match_dup 4)] 12))\n+   (set (match_dup 0)\n+\t(unspec [(match_dup 4)\n+\t\t (reg:SI 1)] 13))\n+   (set (match_dup 0)\n+\t(minus:DF (match_dup 0)\n+\t\t  (match_dup 3)))]\n+  \"operands[4] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\")\n+\n+(define_expand \"floatunssidf2\"\n+  [(parallel [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t\t   (unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+\t      (use (match_dup 2))\n+\t      (use (match_dup 3))\n+\t      (clobber (reg:DF 76))])]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (operands[0])\n-    {\t\t\t\t/* prevent unused warning messages */\n-      rtx high   = force_reg (SImode, GEN_INT (0x43300000));\n-      rtx df     = gen_reg_rtx (DFmode);\n-      rtx adjust = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n-\n-      emit_insn (gen_move_to_float (df, operands[1], high));\n-      emit_insn (gen_subdf3 (operands[0], df, adjust));\n-      DONE;\n-    }\n+  operands[2] = force_reg (SImode, GEN_INT (0x43300000));\n+  operands[3] = force_reg (DFmode, rs6000_float_const (\\\"4503599627370496\\\", DFmode));\n }\")\n \n-(define_expand \"move_to_float\"\n-  [(set (match_dup 4)\t\t\t\t\t;; low word\n-\t(match_operand:SI 1 \"register_operand\" \"\"))\n-   (set (match_dup 5)\t\t\t\t\t;; high word\n-\t(match_operand:SI 2 \"register_operand\" \"\"))\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\t;; float value\n-\t(match_dup 3))]\n+(define_insn \"*floatunssidf2_internal\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=&f\")\n+\t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"r\")))\n+   (use (match_operand:SI 2 \"gpc_reg_operand\" \"r\"))\n+   (use (match_operand:DF 3 \"gpc_reg_operand\" \"f\"))\n+   (clobber (reg:DF 76))]\n   \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n-  \"\n+  \"#\"\n+  [(set_attr \"length\" \"16\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n+\t(unsigned_float:DF (match_operand:SI 1 \"gpc_reg_operand\" \"\")))\n+   (use (match_operand:SI 2 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:DF 3 \"gpc_reg_operand\" \"\"))\n+   (clobber (reg:DF 76))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  [(set (match_dup 4)\n+\t(unspec [(match_dup 1)\t\t;; low word\n+\t\t (reg:SI 1)] 11))\n+   (set (match_dup 4)\n+\t(unspec [(match_dup 2)\t\t;; high word\n+\t\t (reg:SI 1)\n+\t\t (reg:DF 76)] 12))\n+   (set (match_dup 0)\n+\t(unspec [(match_dup 4)\n+\t\t (reg:SI 1)] 13))\n+   (set (match_dup 0)\n+\t(minus:DF (match_dup 0)\n+\t\t  (match_dup 3)))]\n+  \"operands[4] = gen_rtx (REG, DFmode, FPMEM_REGNUM);\")\n+\n+;; Note, we list r1 in the unspec, so that the optimizer is not tempted to optimize\n+;; around an alloca call (the memory address is constructed directly from r1).\n+\n+(define_insn \"*floatsidf2_store1\"\n+  [(set (reg:DF 76)\n+\t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n+\t\t (reg:SI 1)] 11))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"*\n {\n-  operands[3] = gen_reg_rtx (DFmode);\n+  operands[1] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (rs6000_fpmem_offset\n+\t\t\t\t\t   + ((WORDS_BIG_ENDIAN != 0) * 4))));\n \n-  if (WORDS_BIG_ENDIAN)\n-    {\n-      operands[4] = gen_rtx (SUBREG, SImode, operands[3], 1);\n-      operands[5] = gen_rtx (SUBREG, SImode, operands[3], 0);\n-    }\n-  else\n-    {\n-      operands[4] = gen_rtx (SUBREG, SImode, operands[3], 0);\n-      operands[5] = gen_rtx (SUBREG, SImode, operands[3], 1);\n-    }\n-}\")\n+  return \\\"{st|stw} %0,%1\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*floatsidf2_store2\"\n+  [(set (reg:DF 76)\n+\t(unspec [(match_operand:SI 0 \"gpc_reg_operand\" \"r\")\n+\t\t (reg:SI 1)\n+\t\t (reg:DF 76)] 12))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (rs6000_fpmem_offset\n+\t\t\t\t\t   + ((WORDS_BIG_ENDIAN == 0) * 4))));\n+\n+  return \\\"{st|stw} %0,%1\\\";\n+}\"\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"*floatsidf2_load\"\n+  [(set (match_operand:DF 0 \"gpc_reg_operand\" \"=f\")\n+\t(unspec [(reg:DF 76)\n+\t\t (reg:SI 1)] 13))]\n+  \"! TARGET_POWERPC64 && TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (MEM, SImode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (rs6000_fpmem_offset)));\n+\n+  return \\\"lfd %0,%1\\\";\n+}\"\n+  [(set_attr \"type\" \"fpload\")])\n \n (define_expand \"fix_truncdfsi2\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n+  [(parallel [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t\t   (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))\n+\t      (clobber (match_dup 2))\n+\t      (clobber (match_dup 3))])]\n   \"TARGET_HARD_FLOAT\"\n   \"\n {\n-  if (TARGET_POWER2 || TARGET_POWERPC)\n-    {\n-      rtx temp1 = gen_reg_rtx (DImode);\n-      rtx temp2 = gen_reg_rtx (SImode);\n-\n-      emit_insn (gen_fpcvtsi (temp1, operands[1]));\n-      emit_move_insn (temp2, gen_rtx (SUBREG, SImode, temp1, WORDS_BIG_ENDIAN));\n-      emit_move_insn (operands[0], temp2);\n-      DONE;\n-    }\n-  else\n+  if (!TARGET_POWER2 && !TARGET_POWERPC)\n     {\n       emit_insn (gen_trunc_call (operands[0], operands[1],\n \t\t\t\t gen_rtx (SYMBOL_REF, Pmode, RS6000_ITRUNC)));\n       DONE;\n     }\n+\n+  operands[2] = gen_reg_rtx (DImode);\n+  operands[3] = gen_rtx (REG, DImode, FPMEM_REGNUM);\n }\")\n \n-(define_insn \"fpcvtsi\"\n+(define_insn \"*fix_truncdfsi2_internal\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"=f\"))\n+   (clobber (reg:DI 76))]\n+  \"TARGET_HARD_FLOAT\"\n+  \"#\"\n+  [(set_attr \"length\" \"12\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\")))\n+   (clobber (match_operand:DI 2 \"gpc_reg_operand\" \"\"))\n+   (clobber (reg:DI 76))]\n+  \"TARGET_HARD_FLOAT\"\n+  [(set (match_dup 2)\n+\t(sign_extend:DI (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\"))))\n+   (set (match_dup 3)\n+\t(unspec [(match_dup 2)\n+\t\t (reg:SI 1)] 14))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n+\t(unspec [(match_dup 3)\n+\t\t (reg:SI 1)] 15))]\n+  \"operands[3] = gen_rtx (REG, DImode, FPMEM_REGNUM);\")\n+\n+(define_insn \"*fctiwz\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=f\")\n-\t(sign_extend:DI\n-\t (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\"))))]\n+\t(sign_extend:DI (fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"f\"))))]\n   \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n   \"{fcirz|fctiwz} %0,%1\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"*fix_truncdfsi2_store\"\n+  [(set (reg:DI 76)\n+\t(unspec [(match_operand:DI 0 \"gpc_reg_operand\" \"f\")\n+\t\t (reg:SI 1)] 14))]\n+  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (MEM, DFmode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (rs6000_fpmem_offset)));\n+\n+  return \\\"stfd %0,%1\\\";\n+}\"\n+  [(set_attr \"type\" \"fpstore\")])\n+\n+(define_insn \"*fix_truncdfsi2_load\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n+\t(unspec [(reg:DI 76)\n+\t\t (reg:SI 1)] 15))]\n+  \"(TARGET_POWER2 || TARGET_POWERPC) && TARGET_HARD_FLOAT\"\n+  \"*\n+{\n+  operands[1] = gen_rtx (MEM, DFmode,\n+\t\t\t gen_rtx (PLUS, Pmode,\n+\t\t\t\t  stack_pointer_rtx,\n+\t\t\t\t  GEN_INT (rs6000_fpmem_offset + ((WORDS_BIG_ENDIAN) ? 4 : 0))));\n+\n+  return \\\"{l|lwz} %0,%1\\\";\n+}\"\n+  [(set_attr \"type\" \"load\")])\n+\n (define_expand \"fixuns_truncdfsi2\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n \t(unsigned_fix:SI (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n@@ -3988,7 +4126,7 @@\n    add %0,%1,%2\n    addi %0,%1,%2\n    addic %0,%1,%2\n-   addis %0,%1,%u2\")\n+   addis %0,%1,%v2\")\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,x\")\n@@ -5011,7 +5149,7 @@\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n-   {liu|lis} %0,%u1\n+   {liu|lis} %0,%v1\n    #\n    {cal|la} %0,%1(%*)\n    mf%1 %0\n@@ -5288,7 +5426,7 @@\n    {l%U1%X1|lwz%U1%X1} %0,%1\n    {st%U0%X0|stw%U0%X0} %1,%0\n    {lil|li} %0,%1\n-   {liu|lis} %0,%u1\n+   {liu|lis} %0,%v1\n    {cal|la} %0,%1(%*)\"\n   [(set_attr \"type\" \"*,load,store,*,*,*\")])\n \n@@ -5691,7 +5829,7 @@\n    ld%U1%X1 %0,%1\n    std%U0%X0 %1,%0\n    li %0,%1\n-   lis %0,%u1\n+   lis %0,%v1\n    #\n    {cal|la} %0,%1(%*)\n    fmr %0,%1"}, {"sha": "357e21cbc334d53efc171d27a8981ffd59237355", "filename": "gcc/config/rs6000/sol2.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Fsol2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Fsol2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsol2.h?ref=802a0058bd44c4163743b682926faacaf14d7b81", "patch": "@@ -21,6 +21,10 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #include \"rs6000/sysv4le.h\"\n \n+/* Default ABI to use */\n+#undef\tRS6000_ABI_NAME\n+#define RS6000_ABI_NAME \"solaris\"\n+\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \\\n  \"-Dsun=1 -Dunix -D__svr4__ -DSVR4 -DPPC \\\n@@ -82,14 +86,15 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define\tPREFERRED_DEBUGGING_TYPE DBX_DEBUG\n \n \n+#if 0\n #undef\tASM_OUTPUT_ALIGNED_LOCAL\n #define ASM_OUTPUT_ALIGNED_LOCAL(FILE, NAME, SIZE, ALIGN)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\t%s\\t\", \".lcomm\");\t\t\t\t\t\\\n   assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n   fprintf ((FILE), \",%u,%u\\n\", (SIZE), (ALIGN) / BITS_PER_UNIT);\t\\\n } while (0)\n-\n+#endif\n \n /* Like block addresses, stabs line numbers are relative to the\n    current function.  */"}, {"sha": "aa556b67b081dd9b3b6639f7ad7a6f23c67f0546", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/802a0058bd44c4163743b682926faacaf14d7b81/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=802a0058bd44c4163743b682926faacaf14d7b81", "patch": "@@ -795,30 +795,43 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fputs (_name, FILE);\t\t\t\t\t\t\t\\\n } while (0)\n \n-#if 0\n-/* The Solaris 2.51 linker has a bug in that it doesn't properly\n-   resolve references from the .init and .fini sections.  So fall\n-   back to the old way of handling constructors and destructors.  */\n #undef ASM_OUTPUT_CONSTRUCTOR\n #define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    init_section ();\t\t\t\t\t\t\t\\\n-    fputs (\"\\tbl \", FILE);\t\t\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    fputs ((flag_pic) ? \"@plt\\n\" : \"\\n\", FILE);\t\t\t\t\\\n+    if (DEFAULT_ABI != ABI_SOLARIS)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tctors_section ();\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tinit_section ();\t\t\t\t\t\t\\\n+\tfputs (\"\\tbl \", FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n   } while (0)\n \n /* A C statement (sans semicolon) to output an element in the table of\n    global destructors.  */\n #undef ASM_OUTPUT_DESTRUCTOR\n #define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)       \t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n-    fini_section ();\t\t\t\t\t\t\t\\\n-    fputs (\"\\tbl \", FILE);\t\t\t\t\t\t\\\n-    assemble_name (FILE, NAME);\t\t\t\t\t\t\\\n-    fputs ((flag_pic) ? \"@plt\\n\" : \"\\n\", FILE);\t\t\t\t\\\n+    if (DEFAULT_ABI != ABI_SOLARIS)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tdtors_section ();\t\t\t\t\t\t\\\n+\tfprintf (FILE, \"\\t%s\\t \", INT_ASM_OP);\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tfini_section ();\t\t\t\t\t\t\\\n+\tfputs (\"\\tbl \", FILE);\t\t\t\t\t\t\\\n+\tassemble_name (FILE, NAME);\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    fputs (\"\\n\", FILE);\t\t\t\t\t\t\t\\\n   } while (0)\n-#endif\n \n /* But, to make this work, we have to output the stabs for the function\n    name *first*...  */\n@@ -836,7 +849,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \n /* Pass various options to the assembler */\n #undef ASM_SPEC\n-#define ASM_SPEC \"-u %(asm_cpu) %{mregnames} \\\n+#define ASM_SPEC \"%(asm_cpu) %{mregnames} \\\n %{v:-V} %{Qy:} %{!Qn:-Qy} %{n} %{T} %{Ym,*} %{Yd,*} %{Wa,*:%*} \\\n %{mrelocatable} %{mrelocatable-lib} \\\n %{memb} %{!memb: %{msdata: -memb} %{msdata=eabi: -memb}} \\\n@@ -856,6 +869,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n %{mno-sdata: -msdata=none } \\\n %{meabi: %{!mcall-*: -mcall-sysv }} \\\n %{!meabi: %{!mno-eabi: \\\n+    %{mrelocatable: -meabi } \\\n     %{mcall-solaris: -mno-eabi } \\\n     %{mcall-linux: -mno-eabi }}}\"\n "}]}