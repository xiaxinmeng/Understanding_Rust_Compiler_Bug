{"sha": "20a65dcba9a95dd40a8794324e833d5ff9f07544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjBhNjVkY2JhOWE5NWRkNDBhODc5NDMyNGU4MzNkNWZmOWYwNzU0NA==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2013-04-23T09:56:06Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-23T09:56:06Z"}, "message": "exp_prag.adb (Expand_Pragma_Check): Check for Assert rather than Assertion.\n\n2013-04-23  Robert Dewar  <dewar@adacore.com>\n\n\t* exp_prag.adb (Expand_Pragma_Check): Check for Assert rather\n\tthan Assertion.\n\t* sem_prag.adb (Is_Valid_Assertion_Kind): Moved to spec\n\t(Effective_Name): New function (Analyze_Pragma, case Check):\n\tDisallow [Statement_]Assertions (Check_Kind): Implement\n\tStatement_Assertions (Check_Applicable_Policy): Use Effective_Name\n\t(Is_Valid_Assertion_Kind): Allow Statement_Assertions.\n\t* sem_prag.ads (Is_Valid_Assertion_Kind): Moved here from body\n\t(Effective_Name): New function.\n\t* sem_res.adb: Minor reformatting.\n\t* snames.ads-tmpl (Name_Statement_Assertions): New entry.\n\t* gnat_rm.texi: Add documentation of new assertion kind\n\tStatement_Assertions.\n\nFrom-SVN: r198187", "tree": {"sha": "52f36a03473183940fba9d55f750c77e3fe696b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52f36a03473183940fba9d55f750c77e3fe696b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20a65dcba9a95dd40a8794324e833d5ff9f07544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a65dcba9a95dd40a8794324e833d5ff9f07544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20a65dcba9a95dd40a8794324e833d5ff9f07544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20a65dcba9a95dd40a8794324e833d5ff9f07544/comments", "author": null, "committer": null, "parents": [{"sha": "2e86f67917967e048d40e25579bf49414a85d8d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e86f67917967e048d40e25579bf49414a85d8d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e86f67917967e048d40e25579bf49414a85d8d9"}], "stats": {"total": 305, "additions": 205, "deletions": 100}, "files": [{"sha": "4bdf9e6d747156589b70a1034195f3bb434189db", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -1,3 +1,19 @@\n+2013-04-23  Robert Dewar  <dewar@adacore.com>\n+\n+\t* exp_prag.adb (Expand_Pragma_Check): Check for Assert rather\n+\tthan Assertion.\n+\t* sem_prag.adb (Is_Valid_Assertion_Kind): Moved to spec\n+\t(Effective_Name): New function (Analyze_Pragma, case Check):\n+\tDisallow [Statement_]Assertions (Check_Kind): Implement\n+\tStatement_Assertions (Check_Applicable_Policy): Use Effective_Name\n+\t(Is_Valid_Assertion_Kind): Allow Statement_Assertions.\n+\t* sem_prag.ads (Is_Valid_Assertion_Kind): Moved here from body\n+\t(Effective_Name): New function.\n+\t* sem_res.adb: Minor reformatting.\n+\t* snames.ads-tmpl (Name_Statement_Assertions): New entry.\n+\t* gnat_rm.texi: Add documentation of new assertion kind\n+\tStatement_Assertions.\n+\n 2013-04-23  Robert Dewar  <dewar@adacore.com>\n \n \t* sinfo.ads, einfo.adb, sem_res.adb, exp_ch6.adb, aspects.adb: Minor"}, {"sha": "36191fb656e27eb32783a69d24cb5b0ee1f33d17", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -377,7 +377,7 @@ package body Exp_Prag is\n \n                --  For Assert, we just use the location\n \n-               if Nam = Name_Assertion then\n+               if Nam = Name_Assert then\n                   null;\n \n                --  For predicate, we generate the string \"predicate failed\n@@ -446,7 +446,7 @@ package body Exp_Prag is\n          then\n             return;\n \n-         elsif Nam = Name_Assertion then\n+         elsif Nam = Name_Assert then\n             Error_Msg_N (\"?A?assertion will fail at run time\", N);\n          else\n "}, {"sha": "a7c1514eaff8c1a1ce8e34f4058a86df58b6cfac", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -1251,7 +1251,8 @@ RM_ASSERTION_KIND ::= Assert               |\n                       Type_Invariant       |\n                       Type_Invariant'Class\n \n-ID_ASSERTION_KIND ::= Assert_And_Cut       |\n+ID_ASSERTION_KIND ::= Assertions           |\n+                      Assert_And_Cut       |\n                       Assume               |\n                       Contract_Cases       |\n                       Debug                |\n@@ -1262,6 +1263,7 @@ ID_ASSERTION_KIND ::= Assert_And_Cut       |\n                       Postcondition        |\n                       Precondition         |\n                       Predicate\n+                      Statement_Assertions\n \n POLICY_IDENTIFIER ::= Check | Disable | Ignore\n @end smallexample\n@@ -1292,6 +1294,15 @@ useful when the pragma or aspect argument references subprograms\n in a with'ed package which is replaced by a dummy package\n for the final build.\n \n+The implementation defined policy @code{Assertions} applies to all\n+assertion kinds. The form with no assertion kind given implies this\n+choice, so it applies to all assertion kinds (RM defined, and\n+implementation defined).\n+\n+The implementation defined policy @code{Statement_Assertions}\n+applies to @code{Assert}, @code{Assert_And_Cut},\n+@code{Assume}, and @code{Loop_Invariant}.\n+\n @node Pragma Assume_No_Invalid_Values\n @unnumberedsec Pragma Assume_No_Invalid_Values\n @findex Assume_No_Invalid_Values\n@@ -1460,6 +1471,11 @@ Checks introduced by this pragma are normally deactivated by default. They can\n be activated either by the command line option @option{-gnata}, which turns on\n all checks, or individually controlled using pragma @code{Check_Policy}.\n \n+The identifiers @code{Assertions} and @code{Statement_Assertions} are not\n+permitted as check kinds, since this would cause confusion with the use\n+of these identifiers in @code{Assertion_Policy} and @code{Check_Policy}\n+pragmas, where they are used to refer to sets of assertions.\n+\n @node Pragma Check_Float_Overflow\n @unnumberedsec Pragma Check_Float_Overflow\n @cindex Floating-point overflow\n@@ -2860,7 +2876,18 @@ the standard runtime libraries be recompiled.\n The two argument form specifies the representation to be used for\n the specified floating-point type. On all systems other than OpenVMS,\n the argument must\n-be @code{IEEE_Float} and the pragma has no effect. On OpenVMS, the\n+be @code{IEEE_Float} to specify the use of IEEE format, as follows:\n+\n+@itemize @bullet\n+@item\n+For a digits value of 6, 32-bit IEEE short format will be used.\n+@item\n+For a digits value of 15, 64-bit IEEE long format will be used.\n+@item\n+No other value of digits is permitted.\n+@end itemize\n+\n+On OpenVMS, the\n argument may be @code{VAX_Float} to specify the use of the VAX float\n format, as follows:\n "}, {"sha": "f0045a37c17f41e3faa0d1cb331086232df965ff", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 119, "deletions": 80, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -181,13 +181,6 @@ package body Sem_Prag is\n    --  original one, following the renaming chain) is returned. Otherwise the\n    --  entity is returned unchanged. Should be in Einfo???\n \n-   function Is_Valid_Assertion_Kind (Nam : Name_Id) return Boolean;\n-   --  Returns True if Nam is one of the names recognized as a valid assertion\n-   --  kind by the Assertion_Policy pragma. Note that the 'Class cases are\n-   --  represented by the corresponding special names Name_uPre, Name_uPost,\n-   --  Name_uInviarnat, and Name_uType_Invariant (_Pre, _Post, _Invariant,\n-   --  and _Type_Invariant).\n-\n    procedure Preanalyze_CTC_Args (N, Arg_Req, Arg_Ens : Node_Id);\n    --  Preanalyze the boolean expressions in the Requires and Ensures arguments\n    --  of a Test_Case pragma if present (possibly Empty). We treat these as\n@@ -352,9 +345,7 @@ package body Sem_Prag is\n       --  In ASIS mode, for a pragma generated from a source aspect, also\n       --  analyze the original aspect expression.\n \n-      if ASIS_Mode\n-        and then Present (Corresponding_Aspect (N))\n-      then\n+      if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n          Preanalyze_Assert_Expression\n            (Expression (Corresponding_Aspect (N)), Standard_Boolean);\n       end if;\n@@ -2222,9 +2213,7 @@ package body Sem_Prag is\n                --  In ASIS mode, for a pragma generated from a source aspect,\n                --  also analyze the original aspect expression.\n \n-               if ASIS_Mode\n-                 and then Present (Corresponding_Aspect (N))\n-               then\n+               if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n                   Preanalyze_Assert_Expression\n                     (Expression (Corresponding_Aspect (N)), Standard_Boolean);\n                end if;\n@@ -2411,9 +2400,7 @@ package body Sem_Prag is\n          --  In ASIS mode, for a pragma generated from a source aspect, also\n          --  analyze the original aspect expression.\n \n-         if ASIS_Mode\n-           and then Present (Corresponding_Aspect (N))\n-         then\n+         if ASIS_Mode and then Present (Corresponding_Aspect (N)) then\n             Check_Expr_Is_Static_Expression\n               (Original_Node (Get_Pragma_Arg (Arg1)), Standard_String);\n          end if;\n@@ -2882,10 +2869,7 @@ package body Sem_Prag is\n \n             --  Get name from corresponding aspect\n \n-            if Present (Corresponding_Aspect (N)) then\n-               Error_Msg_Name_1 :=\n-                 Chars (Identifier (Corresponding_Aspect (N)));\n-            end if;\n+            Error_Msg_Name_1 := Effective_Name (N);\n          end if;\n       end Fix_Error;\n \n@@ -6765,10 +6749,7 @@ package body Sem_Prag is\n       --  Here to start processing for recognized pragma\n \n       Prag_Id := Get_Pragma_Id (Pname);\n-\n-      if Present (Corresponding_Aspect (N)) then\n-         Pname := Chars (Identifier (Corresponding_Aspect (N)));\n-      end if;\n+      Pname := Effective_Name (N);\n \n       --  Check applicable policy. We skip this for a pragma that came from\n       --  an aspect, since we already dealt with the Disable case, and we set\n@@ -7426,9 +7407,9 @@ package body Sem_Prag is\n             Check_Arg_Order ((Name_Check, Name_Message));\n             Check_Optional_Identifier (Arg1, Name_Check);\n \n-            --  We treat pragma Assert as equivalent to:\n+            --  We treat pragma Assert[_And_Cut] as equivalent to:\n \n-            --    pragma Check (Assertion, condition [, msg]);\n+            --    pragma Check (Assert[_And_Cut], condition [, msg]);\n \n             --  So rewrite pragma in this manner, transfer the message\n             --  argument if present, and analyze the result\n@@ -7443,8 +7424,7 @@ package body Sem_Prag is\n             Expr := Get_Pragma_Arg (Arg1);\n             Newa := New_List (\n               Make_Pragma_Argument_Association (Loc,\n-                Expression => Make_Identifier (Loc, Name_Assertion)),\n-\n+                Expression => Make_Identifier (Loc, Pname)),\n               Make_Pragma_Argument_Association (Sloc (Expr),\n                 Expression => Expr));\n \n@@ -8083,6 +8063,9 @@ package body Sem_Prag is\n          --                 Invariant'Class      |\n          --                 Type_Invariant'Class\n \n+         --  The identifiers Assertions and Statement_Assertions are not\n+         --  allowed, since they have special meaning for Check_Policy.\n+\n          when Pragma_Check => Check : declare\n             Expr  : Node_Id;\n             Eloc  : Source_Ptr;\n@@ -8108,6 +8091,23 @@ package body Sem_Prag is\n             Check_Arg_Is_Identifier (Arg1);\n             Cname := Chars (Get_Pragma_Arg (Arg1));\n \n+            --  Check forbidden name Assertions or Statement_Assertions\n+\n+            case Cname is\n+               when Name_Assertions =>\n+                  Error_Pragma_Arg\n+                    (\"\"\"Assertions\"\" is not allowed as a check kind \"\n+                     & \"for pragma%\", Arg1);\n+\n+               when Name_Statement_Assertions =>\n+                  Error_Pragma_Arg\n+                    (\"\"\"Statement_Assertions\"\" is not allowed as a check kind \"\n+                     & \"for pragma%\", Arg1);\n+\n+               when others =>\n+                  null;\n+            end case;\n+\n             --  Set Check_On to indicate check status\n \n             --  If this comes from an aspect, we have already taken care of\n@@ -17945,8 +17945,13 @@ package body Sem_Prag is\n \n          begin\n             if Nam = Pnm\n-              or else (Is_Valid_Assertion_Kind (Nam)\n-                        and then Pnm = Name_Assertion)\n+              or else (Pnm = Name_Assertion\n+                        and then Is_Valid_Assertion_Kind (Nam))\n+              or else (Pnm = Name_Statement_Assertions\n+                        and then Nam_In (Nam, Name_Assert,\n+                                              Name_Assert_And_Cut,\n+                                              Name_Assume,\n+                                              Name_Loop_Invariant))\n             then\n                case (Chars (Get_Pragma_Arg (Last (PPA)))) is\n                   when Name_On | Name_Check =>\n@@ -17985,36 +17990,9 @@ package body Sem_Prag is\n       PP     : Node_Id;\n       Policy : Name_Id;\n \n-      Ename : Name_Id;\n-      --  Effective name of aspect or pragma, this is simply the name of\n-      --  the aspect or pragma, except in the case of a pragma derived from\n-      --  an aspect, in which case it is the name of the aspect (which may be\n-      --  different, e.g. Pre aspect generating Precondition pragma). It also\n-      --  deals with the 'Class cases for an aspect.\n+      Ename : constant Name_Id := Effective_Name (N);\n \n    begin\n-      if Nkind (N) = N_Pragma then\n-         if Present (Corresponding_Aspect (N)) then\n-            Ename := Chars (Identifier (Corresponding_Aspect (N)));\n-         else\n-            Ename := Chars (Pragma_Identifier (N));\n-         end if;\n-\n-      else\n-         pragma Assert (Nkind (N) = N_Aspect_Specification);\n-         Ename := Chars (Identifier (N));\n-\n-         if Class_Present (N) then\n-            case Ename is\n-               when Name_Invariant      => Ename := Name_uInvariant;\n-               when Name_Pre            => Ename := Name_uPre;\n-               when Name_Post           => Ename := Name_uPost;\n-               when Name_Type_Invariant => Ename := Name_uType_Invariant;\n-               when others              => raise Program_Error;\n-            end case;\n-         end if;\n-      end if;\n-\n       --  No effect if not valid assertion kind name\n \n       if not Is_Valid_Assertion_Kind (Ename) then\n@@ -18072,6 +18050,66 @@ package body Sem_Prag is\n                                       Name_Priority_Specific_Dispatching);\n    end Delay_Config_Pragma_Analyze;\n \n+   --------------------\n+   -- Effective_Name --\n+   --------------------\n+\n+   function Effective_Name (N : Node_Id) return Name_Id is\n+      Pras : Node_Id;\n+      Name : Name_Id;\n+\n+   begin\n+      pragma Assert (Nkind_In (N, N_Aspect_Specification, N_Pragma));\n+      Pras := N;\n+\n+      if Is_Rewrite_Substitution (Pras)\n+        and then Nkind (Original_Node (Pras)) = N_Pragma\n+      then\n+         Pras := Original_Node (Pras);\n+      end if;\n+\n+      --  Case where we came from aspect specication\n+\n+      if Nkind (Pras) = N_Pragma and then From_Aspect_Specification (Pras) then\n+         Pras := Corresponding_Aspect (Pras);\n+      end if;\n+\n+      --  Get name from aspect or pragma\n+\n+      if Nkind (Pras) = N_Pragma then\n+         Name := Pragma_Name (Pras);\n+      else\n+         Name := Chars (Identifier (Pras));\n+      end if;\n+\n+      --  Deal with 'Class\n+\n+      if Class_Present (Pras) then\n+         case Name is\n+\n+         --  Names that need converting to special _xxx form\n+\n+            when Name_Pre             => Name := Name_uPre;\n+            when Name_Post            => Name := Name_uPost;\n+            when Name_Invariant       => Name := Name_uInvariant;\n+            when Name_Type_Invariant  => Name := Name_uType_Invariant;\n+\n+               --  Names already in special _xxx form (leave them alone)\n+\n+            when Name_uPre            => null;\n+            when Name_uPost           => null;\n+            when Name_uInvariant      => null;\n+            when Name_uType_Invariant => null;\n+\n+               --  Anything else is impossible with Class_Present set True\n+\n+            when others               => raise Program_Error;\n+         end case;\n+      end if;\n+\n+      return Name;\n+   end Effective_Name;\n+\n    -------------------------\n    -- Get_Base_Subprogram --\n    -------------------------\n@@ -18521,31 +18559,32 @@ package body Sem_Prag is\n          when\n             --  RM defined\n \n-            Name_Assert            |\n-            Name_Static_Predicate  |\n-            Name_Dynamic_Predicate |\n-            Name_Pre               |\n-            Name_uPre              |\n-            Name_Post              |\n-            Name_uPost             |\n-            Name_Type_Invariant    |\n-            Name_uType_Invariant   |\n+            Name_Assert               |\n+            Name_Static_Predicate     |\n+            Name_Dynamic_Predicate    |\n+            Name_Pre                  |\n+            Name_uPre                 |\n+            Name_Post                 |\n+            Name_uPost                |\n+            Name_Type_Invariant       |\n+            Name_uType_Invariant      |\n \n             --  Impl defined\n \n-            Name_Assert_And_Cut    |\n-            Name_Assume            |\n-            Name_Contract_Cases    |\n-            Name_Debug             |\n-            Name_Invariant         |\n-            Name_uInvariant        |\n-            Name_Loop_Invariant    |\n-            Name_Loop_Variant      |\n-            Name_Postcondition     |\n-            Name_Precondition      |\n-            Name_Predicate         => return True;\n-\n-         when others               => return False;\n+            Name_Assert_And_Cut       |\n+            Name_Assume               |\n+            Name_Contract_Cases       |\n+            Name_Debug                |\n+            Name_Invariant            |\n+            Name_uInvariant           |\n+            Name_Loop_Invariant       |\n+            Name_Loop_Variant         |\n+            Name_Postcondition        |\n+            Name_Precondition         |\n+            Name_Predicate            |\n+            Name_Statement_Assertions => return True;\n+\n+         when others                  => return False;\n       end case;\n    end Is_Valid_Assertion_Kind;\n "}, {"sha": "54ddc43f827b935c5587b39441e492d5b9554e6b", "filename": "gcc/ada/sem_prag.ads", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_prag.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_prag.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.ads?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -104,10 +104,30 @@ package Sem_Prag is\n    --  True have their analysis delayed until after the main program is parsed\n    --  and analyzed.\n \n+   function Effective_Name (N : Node_Id) return Name_Id;\n+   --  N is a pragma node or aspect specification node. This function returns\n+   --  the name of the pragma or aspect, taking into account possible rewrites,\n+   --  and also cases where a pragma comes from an attribute (in such cases,\n+   --  the name can be different from the pragma name, e.g. Pre generates\n+   --  a Precondition pragma. This also deals with the presence of 'Class\n+   --  which results in one of the special names Name_uPre, Name_uPost,\n+   --  Name_uInvariant, or Name_uType_Invariant being returned to represent\n+   --  the corresponding aspects with x'Class names.\n+\n    procedure Initialize;\n    --  Initializes data structures used for pragma processing. Must be called\n    --  before analyzing each new main source program.\n \n+   function Is_Config_Static_String (Arg : Node_Id) return Boolean;\n+   --  This is called for a configuration pragma that requires either string\n+   --  literal or a concatenation of string literals. We cannot use normal\n+   --  static string processing because it is too early in the case of the\n+   --  pragma appearing in a configuration pragmas file. If Arg is of an\n+   --  appropriate form, then this call obtains the string (doing any necessary\n+   --  concatenations) and places it in Name_Buffer, setting Name_Len to its\n+   --  length, and then returns True. If it is not of the correct form, then an\n+   --  appropriate error message is posted, and False is returned.\n+\n    function Is_Non_Significant_Pragma_Reference (N : Node_Id) return Boolean;\n    --  The node N is a node for an entity and the issue is whether the\n    --  occurrence is a reference for the purposes of giving warnings about\n@@ -124,15 +144,12 @@ package Sem_Prag is\n    --  False is returned, then the argument is treated as an entity reference\n    --  to the operator.\n \n-   function Is_Config_Static_String (Arg : Node_Id) return Boolean;\n-   --  This is called for a configuration pragma that requires either string\n-   --  literal or a concatenation of string literals. We cannot use normal\n-   --  static string processing because it is too early in the case of the\n-   --  pragma appearing in a configuration pragmas file. If Arg is of an\n-   --  appropriate form, then this call obtains the string (doing any necessary\n-   --  concatenations) and places it in Name_Buffer, setting Name_Len to its\n-   --  length, and then returns True. If it is not of the correct form, then an\n-   --  appropriate error message is posted, and False is returned.\n+   function Is_Valid_Assertion_Kind (Nam : Name_Id) return Boolean;\n+   --  Returns True if Nam is one of the names recognized as a valid assertion\n+   --  kind by the Assertion_Policy pragma. Note that the 'Class cases are\n+   --  represented by the corresponding special names Name_uPre, Name_uPost,\n+   --  Name_uInviarnat, and Name_uType_Invariant (_Pre, _Post, _Invariant,\n+   --  and _Type_Invariant).\n \n    procedure Make_Aspect_For_PPC_In_Gen_Sub_Decl (Decl : Node_Id);\n    --  This routine makes aspects from precondition or postcondition pragmas"}, {"sha": "6a0f666e2802849515e6075bdee61161bd8f4aa1", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -8908,27 +8908,32 @@ package body Sem_Res is\n             Orig : constant Node_Id := Original_Node (Parent (N));\n \n          begin\n+            --  Special handling of Asssert pragma\n+\n             if Nkind (Orig) = N_Pragma\n               and then Pragma_Name (Orig) = Name_Assert\n             then\n-               --  Don't want to warn if original condition is explicit False\n-\n                declare\n                   Expr : constant Node_Id :=\n                            Original_Node\n                              (Expression\n                                (First (Pragma_Argument_Associations (Orig))));\n+\n                begin\n+                  --  Don't warn if original condition is explicit False,\n+                  --  since obviously the failure is expected in this case.\n+\n                   if Is_Entity_Name (Expr)\n                     and then Entity (Expr) = Standard_False\n                   then\n                      null;\n-                  else\n-                     --  Issue warning. We do not want the deletion of the\n-                     --  IF/AND-THEN to take this message with it. We achieve\n-                     --  this by making sure that the expanded code points to\n-                     --  the Sloc of the expression, not the original pragma.\n \n+                  --  Issue warning. We do not want the deletion of the\n+                  --  IF/AND-THEN to take this message with it. We achieve this\n+                  --  by making sure that the expanded code points to the Sloc\n+                  --  of the expression, not the original pragma.\n+\n+                  else\n                      --  Note: Use Error_Msg_F here rather than Error_Msg_N.\n                      --  The source location of the expression is not usually\n                      --  the best choice here. For example, it gets located on"}, {"sha": "ad98f5564827015263abf6abfab565a1aa066b67", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20a65dcba9a95dd40a8794324e833d5ff9f07544/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=20a65dcba9a95dd40a8794324e833d5ff9f07544", "patch": "@@ -761,6 +761,7 @@ package Snames is\n    Name_Simple_Barriers                : constant Name_Id := N + $;\n    Name_Spec_File_Name                 : constant Name_Id := N + $;\n    Name_State                          : constant Name_Id := N + $;\n+   Name_Statement_Assertions           : constant Name_Id := N + $;\n    Name_Static                         : constant Name_Id := N + $;\n    Name_Stack_Size                     : constant Name_Id := N + $;\n    Name_Strict                         : constant Name_Id := N + $;"}]}