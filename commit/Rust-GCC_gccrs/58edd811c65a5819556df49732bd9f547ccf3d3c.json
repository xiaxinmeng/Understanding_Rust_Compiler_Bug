{"sha": "58edd811c65a5819556df49732bd9f547ccf3d3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThlZGQ4MTFjNjVhNTgxOTU1NmRmNDk3MzJiZDlmNTQ3Y2NmM2QzYw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-02-21T09:23:31Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-02-21T09:23:31Z"}, "message": "re PR fortran/56416 (texinfo 5: Many warnings for gfortran's *.texi)\n\n2012-02-21  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/56416\n        * gfortran.texi (Part II: Language Reference, Extensions,\n        Non-Fortran Main Program): Sort @menu to match actual section order.\n        * intrinsic.texi (Intrinsic Procedures): Ditto.\n        (C_F_POINTER, PRECISION): Move to the alphabetically correct place.\n\nFrom-SVN: r196194", "tree": {"sha": "cd2fc5a95c76614c6df2a2fd9c82395efdc4b069", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd2fc5a95c76614c6df2a2fd9c82395efdc4b069"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58edd811c65a5819556df49732bd9f547ccf3d3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58edd811c65a5819556df49732bd9f547ccf3d3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58edd811c65a5819556df49732bd9f547ccf3d3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58edd811c65a5819556df49732bd9f547ccf3d3c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8aadb791f2fb13e3b5e67b33e6b2c34a5d373782", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8aadb791f2fb13e3b5e67b33e6b2c34a5d373782", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8aadb791f2fb13e3b5e67b33e6b2c34a5d373782"}], "stats": {"total": 210, "additions": 109, "deletions": 101}, "files": [{"sha": "a8ac81a53e733b36e9a71815f4af5dc65448f2f4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=58edd811c65a5819556df49732bd9f547ccf3d3c", "patch": "@@ -1,3 +1,11 @@\n+2012-02-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/56416\n+\t* gfortran.texi (Part II: Language Reference, Extensions,\n+\tNon-Fortran Main Program): Sort @menu to match actual section order.\n+\t* intrinsic.texi (Intrinsic Procedures): Ditto.\n+\t(C_F_POINTER, PRECISION): Move to the alphabetically correct place.\n+\n 2013-02-15  Tobias Burnus  <burnus@net-b.de>\n \t    Mikael Morin  <mikael@gcc.gnu.org>\n "}, {"sha": "462b44366157711b183d3ff25547c5a571e20163", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=58edd811c65a5819556df49732bd9f547ccf3d3c", "patch": "@@ -182,8 +182,8 @@ Part I: Invoking GNU Fortran\n Part II: Language Reference\n * Fortran 2003 and 2008 status::  Fortran 2003 and 2008 features supported by GNU Fortran.\n * Compiler Characteristics::      User-visible implementation details.\n+* Extensions::                    Language extensions implemented by GNU Fortran.\n * Mixed-Language Programming::    Interoperability with C\n-* Extensions::           Language extensions implemented by GNU Fortran.\n * Intrinsic Procedures:: Intrinsic procedures supported by GNU Fortran.\n * Intrinsic Modules::    Intrinsic modules supported by GNU Fortran.\n \n@@ -1348,8 +1348,8 @@ without warning.\n * Commas in FORMAT specifications::\n * Missing period in FORMAT specifications::\n * I/O item lists::\n-* BOZ literal constants::\n * @code{Q} exponent-letter::\n+* BOZ literal constants::\n * Real array indices::\n * Unary operators::\n * Implicitly convert LOGICAL and INTEGER values::\n@@ -2698,8 +2698,8 @@ the same declaration part as the variable or procedure pointer.\n * _gfortran_set_options:: Set library option flags\n * _gfortran_set_convert:: Set endian conversion\n * _gfortran_set_record_marker:: Set length of record markers\n-* _gfortran_set_max_subrecord_length:: Set subrecord length\n * _gfortran_set_fpe:: Set when a Floating Point Exception should be raised\n+* _gfortran_set_max_subrecord_length:: Set subrecord length\n @end menu\n \n Even if you are doing mixed-language programming, it is very"}, {"sha": "4a48425cd8312fde914fb6211581ead633c80be6", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 98, "deletions": 98, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58edd811c65a5819556df49732bd9f547ccf3d3c/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=58edd811c65a5819556df49732bd9f547ccf3d3c", "patch": "@@ -87,9 +87,9 @@ Some basic guidelines for editing this document:\n * @code{CHMOD}:         CHMOD,     Change access permissions of files\n * @code{CMPLX}:         CMPLX,     Complex conversion function\n * @code{COMMAND_ARGUMENT_COUNT}: COMMAND_ARGUMENT_COUNT, Get number of command line arguments\n-* @code{COMPLEX}:       COMPLEX,   Complex conversion function\n-* @code{COMPILER_VERSION}: COMPILER_VERSION, Compiler version string\n * @code{COMPILER_OPTIONS}: COMPILER_OPTIONS, Options passed to the compiler\n+* @code{COMPILER_VERSION}: COMPILER_VERSION, Compiler version string\n+* @code{COMPLEX}:       COMPLEX,   Complex conversion function\n * @code{CONJG}:         CONJG,     Complex conjugate function\n * @code{COS}:           COS,       Cosine function\n * @code{COSH}:          COSH,      Hyperbolic cosine function\n@@ -234,12 +234,12 @@ Some basic guidelines for editing this document:\n * @code{PRESENT}:       PRESENT,   Determine whether an optional dummy argument is specified\n * @code{PRODUCT}:       PRODUCT,   Product of array elements\n * @code{RADIX}:         RADIX,     Base of a data model\n+* @code{RAN}:           RAN,       Real pseudo-random number\n+* @code{RAND}:          RAND,      Real pseudo-random number\n * @code{RANDOM_NUMBER}: RANDOM_NUMBER, Pseudo-random number\n * @code{RANDOM_SEED}:   RANDOM_SEED, Initialize a pseudo-random number sequence\n-* @code{RAND}:          RAND,      Real pseudo-random number\n * @code{RANGE}:         RANGE,     Decimal exponent range\n * @code{RANK} :         RANK,      Rank of a data object\n-* @code{RAN}:           RAN,       Real pseudo-random number\n * @code{REAL}:          REAL,      Convert to real type \n * @code{RENAME}:        RENAME,    Rename a file\n * @code{REPEAT}:        REPEAT,    Repeated string concatenation\n@@ -2271,60 +2271,57 @@ end subroutine association_test\n @end table\n \n \n-@node C_FUNLOC\n-@section @code{C_FUNLOC} --- Obtain the C address of a procedure\n-@fnindex C_FUNLOC\n-@cindex pointer, C address of procedures\n+@node C_F_POINTER\n+@section @code{C_F_POINTER} --- Convert C into Fortran pointer\n+@fnindex C_F_POINTER\n+@cindex pointer, convert C to Fortran\n \n @table @asis\n @item @emph{Description}:\n-@code{C_FUNLOC(x)} determines the C address of the argument.\n+@code{C_F_POINTER(CPTR, FPTR[, SHAPE])} assigns the target of the C pointer\n+@var{CPTR} to the Fortran pointer @var{FPTR} and specifies its shape.\n \n @item @emph{Standard}:\n Fortran 2003 and later\n \n @item @emph{Class}:\n-Inquiry function\n+Subroutine\n \n @item @emph{Syntax}:\n-@code{RESULT = C_FUNLOC(x)}\n+@code{CALL C_F_POINTER(CPTR, FPTR[, SHAPE])}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{x} @tab Interoperable function or pointer to such function.\n+@item @var{CPTR}  @tab scalar of the type @code{C_PTR}. It is\n+@code{INTENT(IN)}.\n+@item @var{FPTR}  @tab pointer interoperable with @var{cptr}. It is\n+@code{INTENT(OUT)}.\n+@item @var{SHAPE} @tab (Optional) Rank-one array of type @code{INTEGER}\n+with @code{INTENT(IN)}. It shall be present\n+if and only if @var{fptr} is an array. The size\n+must be equal to the rank of @var{fptr}.\n @end multitable\n \n-@item @emph{Return value}:\n-The return value is of type @code{C_FUNPTR} and contains the C address\n-of the argument.\n-\n @item @emph{Example}:\n @smallexample\n-module x\n-  use iso_c_binding\n-  implicit none\n-contains\n-  subroutine sub(a) bind(c)\n-    real(c_float) :: a\n-    a = sqrt(a)+5.0\n-  end subroutine sub\n-end module x\n program main\n   use iso_c_binding\n-  use x\n   implicit none\n   interface\n     subroutine my_routine(p) bind(c,name='myC_func')\n-      import :: c_funptr\n-      type(c_funptr), intent(in) :: p\n+      import :: c_ptr\n+      type(c_ptr), intent(out) :: p\n     end subroutine\n   end interface\n-  call my_routine(c_funloc(sub))\n+  type(c_ptr) :: cptr\n+  real,pointer :: a(:)\n+  call my_routine(cptr)\n+  call c_f_pointer(cptr, a, [12])\n end program main\n @end smallexample\n \n @item @emph{See also}:\n-@ref{C_ASSOCIATED}, @ref{C_LOC}, @ref{C_F_POINTER}, @ref{C_F_PROCPOINTER}\n+@ref{C_LOC}, @ref{C_F_PROCPOINTER}\n @end table\n \n \n@@ -2385,57 +2382,60 @@ end program main\n @end table\n \n \n-@node C_F_POINTER\n-@section @code{C_F_POINTER} --- Convert C into Fortran pointer\n-@fnindex C_F_POINTER\n-@cindex pointer, convert C to Fortran\n+@node C_FUNLOC\n+@section @code{C_FUNLOC} --- Obtain the C address of a procedure\n+@fnindex C_FUNLOC\n+@cindex pointer, C address of procedures\n \n @table @asis\n @item @emph{Description}:\n-@code{C_F_POINTER(CPTR, FPTR[, SHAPE])} assigns the target of the C pointer\n-@var{CPTR} to the Fortran pointer @var{FPTR} and specifies its shape.\n+@code{C_FUNLOC(x)} determines the C address of the argument.\n \n @item @emph{Standard}:\n Fortran 2003 and later\n \n @item @emph{Class}:\n-Subroutine\n+Inquiry function\n \n @item @emph{Syntax}:\n-@code{CALL C_F_POINTER(CPTR, FPTR[, SHAPE])}\n+@code{RESULT = C_FUNLOC(x)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{CPTR}  @tab scalar of the type @code{C_PTR}. It is\n-@code{INTENT(IN)}.\n-@item @var{FPTR}  @tab pointer interoperable with @var{cptr}. It is\n-@code{INTENT(OUT)}.\n-@item @var{SHAPE} @tab (Optional) Rank-one array of type @code{INTEGER}\n-with @code{INTENT(IN)}. It shall be present\n-if and only if @var{fptr} is an array. The size\n-must be equal to the rank of @var{fptr}.\n+@item @var{x} @tab Interoperable function or pointer to such function.\n @end multitable\n \n+@item @emph{Return value}:\n+The return value is of type @code{C_FUNPTR} and contains the C address\n+of the argument.\n+\n @item @emph{Example}:\n @smallexample\n+module x\n+  use iso_c_binding\n+  implicit none\n+contains\n+  subroutine sub(a) bind(c)\n+    real(c_float) :: a\n+    a = sqrt(a)+5.0\n+  end subroutine sub\n+end module x\n program main\n   use iso_c_binding\n+  use x\n   implicit none\n   interface\n     subroutine my_routine(p) bind(c,name='myC_func')\n-      import :: c_ptr\n-      type(c_ptr), intent(out) :: p\n+      import :: c_funptr\n+      type(c_funptr), intent(in) :: p\n     end subroutine\n   end interface\n-  type(c_ptr) :: cptr\n-  real,pointer :: a(:)\n-  call my_routine(cptr)\n-  call c_f_pointer(cptr, a, [12])\n+  call my_routine(c_funloc(sub))\n end program main\n @end smallexample\n \n @item @emph{See also}:\n-@ref{C_LOC}, @ref{C_F_PROCPOINTER}\n+@ref{C_ASSOCIATED}, @ref{C_LOC}, @ref{C_F_POINTER}, @ref{C_F_PROCPOINTER}\n @end table\n \n \n@@ -9749,51 +9749,6 @@ default kind.\n \n \n \n-@node PRECISION\n-@section @code{PRECISION} --- Decimal precision of a real kind\n-@fnindex PRECISION\n-@cindex model representation, precision\n-\n-@table @asis\n-@item @emph{Description}:\n-@code{PRECISION(X)} returns the decimal precision in the model of the\n-type of @code{X}.\n-\n-@item @emph{Standard}:\n-Fortran 95 and later\n-\n-@item @emph{Class}:\n-Inquiry function\n-\n-@item @emph{Syntax}:\n-@code{RESULT = PRECISION(X)}\n-\n-@item @emph{Arguments}:\n-@multitable @columnfractions .15 .70\n-@item @var{X} @tab Shall be of type @code{REAL} or @code{COMPLEX}.\n-@end multitable\n-\n-@item @emph{Return value}:\n-The return value is of type @code{INTEGER} and of the default integer\n-kind.\n-\n-@item @emph{See also}:\n-@ref{SELECTED_REAL_KIND}, @ref{RANGE}\n-\n-@item @emph{Example}:\n-@smallexample\n-program prec_and_range\n-  real(kind=4) :: x(2)\n-  complex(kind=8) :: y\n-\n-  print *, precision(x), range(x)\n-  print *, precision(y), range(y)\n-end program prec_and_range\n-@end smallexample\n-@end table\n-\n-\n-\n @node POPCNT\n @section @code{POPCNT} --- Number of bits set\n @fnindex POPCNT\n@@ -9883,6 +9838,51 @@ end program test_population\n \n \n \n+@node PRECISION\n+@section @code{PRECISION} --- Decimal precision of a real kind\n+@fnindex PRECISION\n+@cindex model representation, precision\n+\n+@table @asis\n+@item @emph{Description}:\n+@code{PRECISION(X)} returns the decimal precision in the model of the\n+type of @code{X}.\n+\n+@item @emph{Standard}:\n+Fortran 95 and later\n+\n+@item @emph{Class}:\n+Inquiry function\n+\n+@item @emph{Syntax}:\n+@code{RESULT = PRECISION(X)}\n+\n+@item @emph{Arguments}:\n+@multitable @columnfractions .15 .70\n+@item @var{X} @tab Shall be of type @code{REAL} or @code{COMPLEX}.\n+@end multitable\n+\n+@item @emph{Return value}:\n+The return value is of type @code{INTEGER} and of the default integer\n+kind.\n+\n+@item @emph{See also}:\n+@ref{SELECTED_REAL_KIND}, @ref{RANGE}\n+\n+@item @emph{Example}:\n+@smallexample\n+program prec_and_range\n+  real(kind=4) :: x(2)\n+  complex(kind=8) :: y\n+\n+  print *, precision(x), range(x)\n+  print *, precision(y), range(y)\n+end program prec_and_range\n+@end smallexample\n+@end table\n+\n+\n+\n @node PRESENT\n @section @code{PRESENT} --- Determine whether an optional dummy argument is specified\n @fnindex PRESENT"}]}