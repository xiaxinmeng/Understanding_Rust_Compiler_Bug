{"sha": "72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJjNGEyYTZmYmFiOTQyNTcwMTRmNWYyY2I3ZGY5YThkMGJiM2QxMA==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1998-10-29T20:46:55Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-10-29T20:46:55Z"}, "message": "cp-tree.h (IDENTIFIER_MARKED): New macro.\n\n\t* cp-tree.h (IDENTIFIER_MARKED): New macro.\n\t* search.c (lookup_conversions): Use breadth_first_search.\n\t(add_conversions): Avoid adding two conversions to the same type.\n\t(breadth_first_search): Work with base binfos, rather\n\tthan binfos and base indices.\n\t(get_virtual_destructor): Adjust.\n\t(tree_has_any_destructor_p): Adjust.\n\t(get_matching_virtual): Adjust.\nFixes g++.other/conv4.C\n\nFrom-SVN: r23433", "tree": {"sha": "5c42483518ada75c2327e7fb30ff94f88a2cd184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c42483518ada75c2327e7fb30ff94f88a2cd184"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/comments", "author": null, "committer": null, "parents": [{"sha": "ba4f4e5d1cc4bf5dc19167c5fd2179e100cdf5f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba4f4e5d1cc4bf5dc19167c5fd2179e100cdf5f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba4f4e5d1cc4bf5dc19167c5fd2179e100cdf5f0"}], "stats": {"total": 102, "additions": 56, "deletions": 46}, "files": [{"sha": "d90e22de01964db077c65357f5b53001269f64e8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "patch": "@@ -1,7 +1,17 @@\n 1998-10-29  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* cp-tree.h (IDENTIFIER_MARKED): New macro.\n+\t* search.c (lookup_conversions): Use breadth_first_search.\n+\t(add_conversions): Avoid adding two conversions to the same type.\n+\t(breadth_first_search): Work with base binfos, rather\n+\tthan binfos and base indices.\n+\t(get_virtual_destructor): Adjust.\n+\t(tree_has_any_destructor_p): Adjust.\n+\t(get_matching_virtual): Adjust.\n+\n \t* pt.c (push_template_decl_real): Generalize check for incorrect\n \tnumber of template parms.\n+\t(is_member_template_class): #if 0.\n \n 1998-10-29  Richard Henderson  <rth@cygnus.com>\n "}, {"sha": "7c4127341968d9c795717b12b12a7948ef94e37f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "patch": "@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n       DELETE_EXPR_USE_GLOBAL (in DELETE_EXPR).\n       LOOKUP_EXPR_GLOBAL (in LOOKUP_EXPR).\n       TREE_NEGATED_INT (in INTEGER_CST).\n-      (TREE_MANGLED) (in IDENTIFIER_NODE) (commented-out).\n+      IDENTIFIER_MARKED (used by search routines).\n    1:  IDENTIFIER_VIRTUAL_P.\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -1036,6 +1036,9 @@ struct lang_type\n #define BINFO_PUSHDECLS_MARKED(NODE) BINFO_VTABLE_PATH_MARKED (NODE)\n #define SET_BINFO_PUSHDECLS_MARKED(NODE) SET_BINFO_VTABLE_PATH_MARKED (NODE)\n #define CLEAR_BINFO_PUSHDECLS_MARKED(NODE) CLEAR_BINFO_VTABLE_PATH_MARKED (NODE)\n+\n+/* Used by various search routines.  */\n+#define IDENTIFIER_MARKED(NODE) TREE_LANG_FLAG_0 (NODE)\n \f\n /* Accessor macros for the vfield slots in structures.  */\n \n@@ -1398,7 +1401,7 @@ struct lang_decl\n /* Nonzero in IDENTIFIER_NODE means that this name is not the name the user\n    gave; it's a DECL_NESTED_TYPENAME.  Someone may want to set this on\n    mangled function names, too, but it isn't currently.  */\n-#define TREE_MANGLED(NODE) (TREE_LANG_FLAG_0 (NODE))\n+#define TREE_MANGLED(NODE) (FOO)\n #endif\n \n #if 0\t\t\t\t/* UNUSED */"}, {"sha": "71298edea15b8dd472127ec8c9f0da74339341bb", "filename": "gcc/cp/search.c", "status": "modified", "additions": 41, "deletions": 44, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=72c4a2a6fbab94257014f5f2cb7df9a8d0bb3d10", "patch": "@@ -116,17 +116,17 @@ static void dfs_get_vbase_types PROTO((tree));\n static void dfs_pushdecls PROTO((tree));\n static void dfs_compress_decls PROTO((tree));\n static void dfs_unuse_fields PROTO((tree));\n-static void add_conversions PROTO((tree));\n+static tree add_conversions PROTO((tree));\n static tree get_virtuals_named_this PROTO((tree));\n-static tree get_virtual_destructor PROTO((tree, int));\n-static int tree_has_any_destructor_p PROTO((tree, int));\n+static tree get_virtual_destructor PROTO((tree));\n+static int tree_has_any_destructor_p PROTO((tree));\n static int covariant_return_p PROTO((tree, tree));\n static struct search_level *push_search_level\n \tPROTO((struct stack_level *, struct obstack *));\n static struct search_level *pop_search_level\n \tPROTO((struct stack_level *));\n-static HOST_WIDE_INT breadth_first_search\n-\tPROTO((tree, int (*) (tree, int), int (*) (tree, int)));\n+static tree breadth_first_search\n+\tPROTO((tree, tree (*) (tree), int (*) (tree)));\n \n static tree vbase_types;\n static tree vbase_decl_ptr_intermediate, vbase_decl_ptr;\n@@ -1605,17 +1605,21 @@ lookup_member (xbasetype, name, protect, want_type)\n    QFN, if non-NULL, is a predicate dictating whether the type should\n    even be queued.  */\n \n-static HOST_WIDE_INT\n+static tree\n breadth_first_search (binfo, testfn, qfn)\n      tree binfo;\n-     int (*testfn) PROTO((tree, int));\n-     int (*qfn) PROTO((tree, int));\n+     tree (*testfn) PROTO((tree));\n+     int (*qfn) PROTO((tree));\n {\n   int head = 0, tail = 0;\n-  int rval = 0;\n+  tree rval = NULL_TREE;\n \n   search_stack = push_search_level (search_stack, &search_obstack);\n \n+  SET_BINFO_MARKED (binfo);\n+  obstack_ptr_grow (&search_obstack, binfo);\n+  ++tail;\n+\n   while (1)\n     {\n       tree binfos = BINFO_BASETYPES (binfo);\n@@ -1628,12 +1632,11 @@ breadth_first_search (binfo, testfn, qfn)\n \t  tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n \t  if (BINFO_MARKED (base_binfo) == 0\n-\t      && (qfn == 0 || (*qfn) (binfo, i)))\n+\t      && (qfn == 0 || (*qfn) (base_binfo)))\n \t    {\n \t      SET_BINFO_MARKED (base_binfo);\n-\t      obstack_ptr_grow (&search_obstack, binfo);\n-\t      obstack_ptr_grow (&search_obstack, (HOST_WIDE_INT) i);\n-\t      tail += 2;\n+\t      obstack_ptr_grow (&search_obstack, base_binfo);\n+\t      ++tail;\n \t      if (tail >= search_stack->limit)\n \t\tmy_friendly_abort (100);\n \t    }\n@@ -1646,19 +1649,16 @@ breadth_first_search (binfo, testfn, qfn)\n \t}\n \n       binfo = search_stack->first[head++];\n-      i = (HOST_WIDE_INT) search_stack->first[head++];\n-      if ((rval = (*testfn) (binfo, i)))\n+      if ((rval = (*testfn) (binfo)))\n \tbreak;\n-      binfo = BINFO_BASETYPE (binfo, i);\n     }\n   {\n     tree *tp = search_stack->first;\n     tree *search_tail = tp + tail;\n     while (tp < search_tail)\n       {\n \ttree binfo = *tp++;\n-\tint i = (HOST_WIDE_INT)(*tp++);\n-\tCLEAR_BINFO_MARKED (BINFO_BASETYPE (binfo, i));\n+\tCLEAR_BINFO_MARKED (binfo);\n       }\n   }\n \n@@ -1667,7 +1667,7 @@ breadth_first_search (binfo, testfn, qfn)\n }\n \n /* Functions to use in breadth first searches.  */\n-typedef int (*pfi) PROTO((tree, int));\n+typedef tree (*pfi) PROTO((tree));\n \n static tree declarator;\n \n@@ -1698,27 +1698,21 @@ get_virtuals_named_this (binfo)\n }\n \n static tree\n-get_virtual_destructor (binfo, i)\n+get_virtual_destructor (binfo)\n      tree binfo;\n-     int i;\n {\n   tree type = BINFO_TYPE (binfo);\n-  if (i >= 0)\n-    type = BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo), i));\n   if (TYPE_HAS_DESTRUCTOR (type)\n       && DECL_VINDEX (TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1)))\n     return TREE_VEC_ELT (CLASSTYPE_METHOD_VEC (type), 1);\n   return 0;\n }\n \n static int\n-tree_has_any_destructor_p (binfo, i)\n+tree_has_any_destructor_p (binfo)\n      tree binfo;\n-     int i;\n {\n   tree type = BINFO_TYPE (binfo);\n-  if (i >= 0)\n-    type = BINFO_TYPE (TREE_VEC_ELT (BINFO_BASETYPES (binfo), i));\n   return TYPE_NEEDS_DESTRUCTOR (type);\n }\n \n@@ -1803,16 +1797,9 @@ get_matching_virtual (binfo, fndecl, dtorp)\n      of TYPE, so we must perform first ply of search here.  */\n   if (dtorp)\n     {\n-      if (tree_has_any_destructor_p (binfo, -1))\n-\ttmp = get_virtual_destructor (binfo, -1);\n-\n-      if (tmp)\n-\treturn tmp;\n-\n-      tmp = (tree) breadth_first_search (binfo,\n-\t\t\t\t\t (pfi) get_virtual_destructor,\n-\t\t\t\t\t tree_has_any_destructor_p);\n-      return tmp;\n+      return breadth_first_search (binfo,\n+\t\t\t\t   get_virtual_destructor,\n+\t\t\t\t   tree_has_any_destructor_p);\n     }\n   else\n     {\n@@ -3284,7 +3271,7 @@ reinit_search_statistics ()\n #define scratch_tree_cons expr_tree_cons\n \n static tree conversions;\n-static void\n+static tree\n add_conversions (binfo)\n      tree binfo;\n {\n@@ -3297,21 +3284,31 @@ add_conversions (binfo)\n \n       if (!tmp || ! DECL_CONV_FN_P (OVL_CURRENT (tmp)))\n \tbreak;\n-      conversions = scratch_tree_cons (binfo, tmp, conversions);\n+\n+      /* Make sure we don't already have this conversion.  */\n+      if (! IDENTIFIER_MARKED (DECL_NAME (tmp)))\n+\t{\n+\t  conversions = scratch_tree_cons (binfo, tmp, conversions);\n+\t  IDENTIFIER_MARKED (DECL_NAME (tmp)) = 1;\n+\t}\n     }\n-  SET_BINFO_MARKED (binfo);\n+  return NULL_TREE;\n }\n \n tree\n lookup_conversions (type)\n      tree type;\n {\n+  tree t;\n+\n   conversions = NULL_TREE;\n+\n   if (TYPE_SIZE (type))\n-    {\n-      dfs_walk (TYPE_BINFO (type), add_conversions, unmarkedp);\n-      dfs_walk (TYPE_BINFO (type), dfs_unmark, markedp);\n-    }\n+    breadth_first_search (TYPE_BINFO (type), add_conversions, 0);\n+\n+  for (t = conversions; t; t = TREE_CHAIN (t))\n+    IDENTIFIER_MARKED (DECL_NAME (TREE_VALUE (t))) = 0;\n+\n   return conversions;\n }\n "}]}