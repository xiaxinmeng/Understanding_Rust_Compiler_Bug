{"sha": "689407ef916503b2f5a3c8c07fe7d5ab1913f956", "node_id": "C_kwDOANBUbNoAKDY4OTQwN2VmOTE2NTAzYjJmNWEzYzhjMDdmZTdkNWFiMTkxM2Y5NTY", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-12-04T18:39:43Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-12-04T18:43:46Z"}, "message": "Fortran/OpenMP: Support most of 5.1 atomic extensions\n\nImplements moste of OpenMP 5.1 atomic extensions,\nexcept that 'compare' is parsed but rejected during\nresolution. (As the trans-openmp.c handling is missing.)\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_omp_clauses): Handle\n\tweak/compare/fail clause.\n\t* gfortran.h (gfc_omp_clauses): Add weak, compare, fail.\n\t* openmp.c (enum omp_mask1, gfc_match_omp_clauses,\n\tOMP_ATOMIC_CLAUSES): Update for new clauses.\n\t(gfc_match_omp_atomic): Update for 5.1 atomic changes.\n\t(is_conversion): Support widening in one go.\n\t(is_scalar_intrinsic_expr): New.\n\t(resolve_omp_atomic): Update for 5.1 atomic changes.\n\t* parse.c (parse_omp_oacc_atomic): Update for compare.\n\t* resolve.c (gfc_resolve_blocks): Update asserts.\n\t* trans-openmp.c (gfc_trans_omp_atomic): Handle new clauses.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/atomic-2.f90: Move now supported code to ...\n\t* gfortran.dg/gomp/atomic.f90: here.\n\t* gfortran.dg/gomp/atomic-10.f90: New test.\n\t* gfortran.dg/gomp/atomic-12.f90: New test.\n\t* gfortran.dg/gomp/atomic-15.f90: New test.\n\t* gfortran.dg/gomp/atomic-16.f90: New test.\n\t* gfortran.dg/gomp/atomic-17.f90: New test.\n\t* gfortran.dg/gomp/atomic-18.f90: New test.\n\t* gfortran.dg/gomp/atomic-19.f90: New test.\n\t* gfortran.dg/gomp/atomic-20.f90: New test.\n\t* gfortran.dg/gomp/atomic-22.f90: New test.\n\t* gfortran.dg/gomp/atomic-24.f90: New test.\n\t* gfortran.dg/gomp/atomic-25.f90: New test.\n\t* gfortran.dg/gomp/atomic-26.f90: New test.\n\nlibgomp/ChangeLog\n\n\t* libgomp.texi (OpenMP 5.1): Update status.", "tree": {"sha": "704f036b6cc7c2435778aa2396470df399b60aa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/704f036b6cc7c2435778aa2396470df399b60aa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/689407ef916503b2f5a3c8c07fe7d5ab1913f956", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689407ef916503b2f5a3c8c07fe7d5ab1913f956", "html_url": "https://github.com/Rust-GCC/gccrs/commit/689407ef916503b2f5a3c8c07fe7d5ab1913f956", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/689407ef916503b2f5a3c8c07fe7d5ab1913f956/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87710ec7b213245ecb194b778e97ae3a6790394f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87710ec7b213245ecb194b778e97ae3a6790394f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87710ec7b213245ecb194b778e97ae3a6790394f"}], "stats": {"total": 1512, "additions": 1250, "deletions": 262}, "files": [{"sha": "2aa44ff864c04407a7bb78c8234687e5d6c14f02", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -1810,6 +1810,10 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n \t}\n       fputc (')', dumpfile);\n     }\n+  if (omp_clauses->weak)\n+    fputs (\" WEAK\", dumpfile);\n+  if (omp_clauses->compare)\n+    fputs (\" COMPARE\", dumpfile);\n   if (omp_clauses->nogroup)\n     fputs (\" NOGROUP\", dumpfile);\n   if (omp_clauses->simd)\n@@ -1926,6 +1930,20 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       fputc (' ', dumpfile);\n       fputs (memorder, dumpfile);\n     }\n+  if (omp_clauses->fail != OMP_MEMORDER_UNSET)\n+    {\n+      const char *memorder;\n+      switch (omp_clauses->fail)\n+\t{\n+\tcase OMP_MEMORDER_ACQUIRE: memorder = \"AQUIRE\"; break;\n+\tcase OMP_MEMORDER_RELAXED: memorder = \"RELAXED\"; break;\n+\tcase OMP_MEMORDER_SEQ_CST: memorder = \"SEQ_CST\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      fputs (\" FAIL(\", dumpfile);\n+      fputs (memorder, dumpfile);\n+      putc (')', dumpfile);\n+    }\n   if (omp_clauses->at != OMP_AT_UNSET)\n     {\n       if (omp_clauses->at != OMP_AT_COMPILATION)"}, {"sha": "e5d2dd7971efe4d21e42b2361d655a5391fc7dce", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -1529,10 +1529,11 @@ typedef struct gfc_omp_clauses\n   unsigned sched_simd:1, sched_monotonic:1, sched_nonmonotonic:1;\n   unsigned simd:1, threads:1, depend_source:1, destroy:1, order_concurrent:1;\n   unsigned order_unconstrained:1, order_reproducible:1, capture:1;\n-  unsigned grainsize_strict:1, num_tasks_strict:1;\n+  unsigned grainsize_strict:1, num_tasks_strict:1, compare:1, weak:1;\n   ENUM_BITFIELD (gfc_omp_sched_kind) sched_kind:3;\n   ENUM_BITFIELD (gfc_omp_device_type) device_type:2;\n   ENUM_BITFIELD (gfc_omp_memorder) memorder:3;\n+  ENUM_BITFIELD (gfc_omp_memorder) fail:3;\n   ENUM_BITFIELD (gfc_omp_cancel_kind) cancel:3;\n   ENUM_BITFIELD (gfc_omp_proc_bind_kind) proc_bind:3;\n   ENUM_BITFIELD (gfc_omp_depend_op) depobj_update:3;"}, {"sha": "846fd7b5c5a24e14af9c7add4b9aae0bf7f07b44", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 371, "deletions": 207, "changes": 578, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -917,6 +917,9 @@ enum omp_mask1\n   OMP_CLAUSE_AT,  /* OpenMP 5.1.  */\n   OMP_CLAUSE_MESSAGE,  /* OpenMP 5.1.  */\n   OMP_CLAUSE_SEVERITY,  /* OpenMP 5.1.  */\n+  OMP_CLAUSE_COMPARE,  /* OpenMP 5.1.  */\n+  OMP_CLAUSE_FAIL,  /* OpenMP 5.1.  */\n+  OMP_CLAUSE_WEAK,  /* OpenMP 5.1.  */\n   OMP_CLAUSE_NOWAIT,\n   /* This must come last.  */\n   OMP_MASK1_LAST\n@@ -1450,7 +1453,8 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n   *cp = NULL;\n   while (1)\n     {\n-      if ((first || gfc_match_char (',') != MATCH_YES)\n+      match m = MATCH_NO;\n+      if ((first || (m = gfc_match_char (',')) != MATCH_YES)\n \t  && (needs_space && gfc_match_space () != MATCH_YES))\n \tbreak;\n       needs_space = false;\n@@ -1460,7 +1464,11 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n       gfc_omp_namelist **head;\n       old_loc = gfc_current_locus;\n       char pc = gfc_peek_ascii_char ();\n-      match m;\n+      if (pc == '\\n' && m == MATCH_YES)\n+\t{\n+\t  gfc_error (\"Clause expected at %C after trailing comma\");\n+\t  goto error;\n+\t}\n       switch (pc)\n \t{\n \tcase 'a':\n@@ -1654,6 +1662,16 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tcontinue;\n \t      }\n \t    }\n+\t  if ((mask & OMP_CLAUSE_COMPARE)\n+\t      && (m = gfc_match_dupl_check (!c->compare, \"compare\"))\n+\t\t != MATCH_NO)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      c->compare = true;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_COPY)\n \t      && gfc_match (\"copy ( \") == MATCH_YES\n \t      && gfc_match_omp_map_clause (&c->lists[OMP_LIST_MAP],\n@@ -2009,6 +2027,27 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t    }\n \t  break;\n \tcase 'f':\n+\t  if ((mask & OMP_CLAUSE_FAIL)\n+\t      && (m = gfc_match_dupl_check (c->fail == OMP_MEMORDER_UNSET,\n+\t\t\t\t\t    \"fail\", true)) != MATCH_NO)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (gfc_match (\"seq_cst\") == MATCH_YES)\n+\t\tc->fail = OMP_MEMORDER_SEQ_CST;\n+\t      else if (gfc_match (\"acquire\") == MATCH_YES)\n+\t\tc->fail = OMP_MEMORDER_ACQUIRE;\n+\t      else if (gfc_match (\"relaxed\") == MATCH_YES)\n+\t\tc->fail = OMP_MEMORDER_RELAXED;\n+\t      else\n+\t\t{\n+\t\t  gfc_error (\"Expected SEQ_CST, ACQUIRE or RELAXED at %C\");\n+\t\t  break;\n+\t\t}\n+\t      if (gfc_match (\" )\") != MATCH_YES)\n+\t\tgoto error;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_FILTER)\n \t      && (m = gfc_match_dupl_check (!c->filter, \"filter\", true,\n \t\t\t\t\t    &c->filter)) != MATCH_NO)\n@@ -2903,6 +2942,16 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\t}\n \t      continue;\n \t    }\n+\t  if ((mask & OMP_CLAUSE_WEAK)\n+\t      && (m = gfc_match_dupl_check (!c->weak, \"weak\"))\n+\t\t != MATCH_NO)\n+\t    {\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      c->weak = true;\n+\t      needs_space = true;\n+\t      continue;\n+\t    }\n \t  if ((mask & OMP_CLAUSE_WORKER)\n \t      && (m = gfc_match_dupl_check (!c->worker, \"worker\")) != MATCH_NO)\n \t    {\n@@ -3593,7 +3642,8 @@ gfc_match_oacc_routine (void)\n   (omp_mask (OMP_CLAUSE_TO) | OMP_CLAUSE_LINK | OMP_CLAUSE_DEVICE_TYPE)\n #define OMP_ATOMIC_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_ATOMIC) | OMP_CLAUSE_CAPTURE | OMP_CLAUSE_HINT\t\\\n-   | OMP_CLAUSE_MEMORDER)\n+   | OMP_CLAUSE_MEMORDER | OMP_CLAUSE_COMPARE | OMP_CLAUSE_FAIL \t\\\n+   | OMP_CLAUSE_WEAK)\n #define OMP_MASKED_CLAUSES \\\n   (omp_mask (OMP_CLAUSE_FILTER))\n #define OMP_ERROR_CLAUSES \\\n@@ -5718,6 +5768,7 @@ gfc_match_omp_ordered_depend (void)\n    - capture\n    - memory-order-clause: seq_cst | acq_rel | release | acquire | relaxed\n    - hint(hint-expr)\n+   - OpenMP 5.1: compare | fail (seq_cst | acquire | relaxed ) | weak\n */\n \n match\n@@ -5729,12 +5780,25 @@ gfc_match_omp_atomic (void)\n   if (gfc_match_omp_clauses (&c, OMP_ATOMIC_CLAUSES, true, true) != MATCH_YES)\n     return MATCH_ERROR;\n \n-  if (c->capture && c->atomic_op != GFC_OMP_ATOMIC_UNSET)\n-    gfc_error (\"OMP ATOMIC at %L with multiple atomic clauses\", &loc);\n-\n   if (c->atomic_op == GFC_OMP_ATOMIC_UNSET)\n     c->atomic_op = GFC_OMP_ATOMIC_UPDATE;\n \n+  if (c->capture && c->atomic_op != GFC_OMP_ATOMIC_UPDATE)\n+    gfc_error (\"!$OMP ATOMIC at %L with %s clause is incompatible with \"\n+\t       \"READ or WRITE\", &loc, \"CAPTURE\");\n+  if (c->compare && c->atomic_op != GFC_OMP_ATOMIC_UPDATE)\n+    gfc_error (\"!$OMP ATOMIC at %L with %s clause is incompatible with \"\n+\t       \"READ or WRITE\", &loc, \"COMPARE\");\n+  if (c->fail != OMP_MEMORDER_UNSET && c->atomic_op != GFC_OMP_ATOMIC_UPDATE)\n+    gfc_error (\"!$OMP ATOMIC at %L with %s clause is incompatible with \"\n+\t       \"READ or WRITE\", &loc, \"FAIL\");\n+  if (c->weak && !c->compare)\n+    {\n+      gfc_error (\"!$OMP ATOMIC at %L with %s clause requires %s clause\", &loc,\n+\t\t \"WEAK\", \"COMPARE\");\n+      c->weak = false;\n+    }\n+\n   if (c->memorder == OMP_MEMORDER_UNSET)\n     {\n       gfc_namespace *prog_unit = gfc_current_ns;\n@@ -5765,32 +5829,24 @@ gfc_match_omp_atomic (void)\n     switch (c->atomic_op)\n       {\n       case GFC_OMP_ATOMIC_READ:\n-\tif (c->memorder == OMP_MEMORDER_ACQ_REL\n-\t    || c->memorder == OMP_MEMORDER_RELEASE)\n+\tif (c->memorder == OMP_MEMORDER_RELEASE)\n \t  {\n \t    gfc_error (\"!$OMP ATOMIC READ at %L incompatible with \"\n-\t\t       \"ACQ_REL or RELEASE clauses\", &loc);\n+\t\t       \"RELEASE clause\", &loc);\n \t    c->memorder = OMP_MEMORDER_SEQ_CST;\n \t  }\n+\telse if (c->memorder == OMP_MEMORDER_ACQ_REL)\n+\t  c->memorder = OMP_MEMORDER_ACQUIRE;\n \tbreak;\n       case GFC_OMP_ATOMIC_WRITE:\n-\tif (c->memorder == OMP_MEMORDER_ACQ_REL\n-\t    || c->memorder == OMP_MEMORDER_ACQUIRE)\n+\tif (c->memorder == OMP_MEMORDER_ACQUIRE)\n \t  {\n \t    gfc_error (\"!$OMP ATOMIC WRITE at %L incompatible with \"\n-\t\t       \"ACQ_REL or ACQUIRE clauses\", &loc);\n-\t    c->memorder = OMP_MEMORDER_SEQ_CST;\n-\t  }\n-\tbreak;\n-      case GFC_OMP_ATOMIC_UPDATE:\n-\tif ((c->memorder == OMP_MEMORDER_ACQ_REL\n-\t     || c->memorder == OMP_MEMORDER_ACQUIRE)\n-\t    && !c->capture)\n-\t  {\n-\t    gfc_error (\"!$OMP ATOMIC UPDATE at %L incompatible with \"\n-\t\t       \"ACQ_REL or ACQUIRE clauses\", &loc);\n+\t\t       \"ACQUIRE clause\", &loc);\n \t    c->memorder = OMP_MEMORDER_SEQ_CST;\n \t  }\n+\telse if (c->memorder == OMP_MEMORDER_ACQ_REL)\n+\t  c->memorder = OMP_MEMORDER_RELEASE;\n \tbreak;\n       default:\n \tbreak;\n@@ -7451,20 +7507,24 @@ expr_references_sym (gfc_expr *e, gfc_symbol *s, gfc_expr *se)\n \n \n /* If EXPR is a conversion function that widens the type\n-   if WIDENING is true or narrows the type if WIDENING is false,\n+   if WIDENING is true or narrows the type if NARROW is true,\n    return the inner expression, otherwise return NULL.  */\n \n static gfc_expr *\n-is_conversion (gfc_expr *expr, bool widening)\n+is_conversion (gfc_expr *expr, bool narrowing, bool widening)\n {\n   gfc_typespec *ts1, *ts2;\n \n   if (expr->expr_type != EXPR_FUNCTION\n       || expr->value.function.isym == NULL\n       || expr->value.function.esym != NULL\n-      || expr->value.function.isym->id != GFC_ISYM_CONVERSION)\n+      || expr->value.function.isym->id != GFC_ISYM_CONVERSION\n+      || (!narrowing && !widening))\n     return NULL;\n \n+  if (narrowing && widening)\n+    return expr->value.function.actual->expr;\n+\n   if (widening)\n     {\n       ts1 = &expr->ts;\n@@ -7483,163 +7543,297 @@ is_conversion (gfc_expr *expr, bool widening)\n   return NULL;\n }\n \n+static bool\n+is_scalar_intrinsic_expr (gfc_expr *expr, bool must_be_var, bool conv_ok)\n+{\n+  if (must_be_var\n+      && (expr->expr_type != EXPR_VARIABLE || !expr->symtree)\n+      && (!conv_ok || !is_conversion (expr, true, true)))\n+    return false;\n+  return (expr->rank == 0\n+\t  && !gfc_is_coindexed (expr)\n+\t  && (expr->ts.type != BT_INTEGER\n+\t      || expr->ts.type != BT_REAL\n+\t      || expr->ts.type != BT_COMPLEX\n+\t      || expr->ts.type != BT_LOGICAL));\n+}\n \n static void\n resolve_omp_atomic (gfc_code *code)\n {\n   gfc_code *atomic_code = code->block;\n   gfc_symbol *var;\n-  gfc_expr *expr2, *expr2_tmp;\n+  gfc_expr *stmt_expr2, *capt_expr2;\n   gfc_omp_atomic_op aop\n     = (gfc_omp_atomic_op) (atomic_code->ext.omp_clauses->atomic_op\n \t\t\t   & GFC_OMP_ATOMIC_MASK);\n+  gfc_code *stmt = NULL, *capture_stmt = NULL;\n+  gfc_expr *comp_cond = NULL;\n+  locus *loc = NULL;\n \n   code = code->block->next;\n-  /* resolve_blocks asserts this is initially EXEC_ASSIGN.\n+  /* resolve_blocks asserts this is initially EXEC_ASSIGN or EXEC_IF\n      If it changed to EXEC_NOP, assume an error has been emitted already.  */\n-  if (code->op == EXEC_NOP)\n+  if (code->op == EXEC_NOP /* FIXME: || (code->next && code->next->op == EXEC_NOP)*/)\n     return;\n-  if (code->op != EXEC_ASSIGN)\n+\n+  if (code->op == EXEC_IF && code->block->op == EXEC_IF)\n+    comp_cond = code->block->expr1;\n+\n+  if (atomic_code->ext.omp_clauses->compare\n+      && atomic_code->ext.omp_clauses->capture)\n     {\n-    unexpected:\n-      gfc_error (\"unexpected !$OMP ATOMIC expression at %L\", &code->loc);\n-      return;\n+      /* Must be either \"if (x == e) then; x = d; else; v = x; end if\"\n+\t or \"v = expr\" followed/preceded by\n+\t \"if (x == e) then; x = d; end if\" or \"if (x == e) x = d\".  */\n+      gfc_code *next = code;\n+      if (code->op == EXEC_ASSIGN)\n+\t{\n+\t  capture_stmt = code;\n+\t  next = code->next;\n+\t}\n+      if (next->op == EXEC_IF\n+\t  && next->block\n+\t  && next->block->op == EXEC_IF\n+\t  && next->block->next->op == EXEC_ASSIGN)\n+\t{\n+\t  stmt = next->block->next;\n+\t  if (stmt->next)\n+\t    {\n+\t      loc = &stmt->loc;\n+\t      goto unexpected;\n+\t    }\n+\t}\n+      if (stmt && !capture_stmt && next->block->block)\n+\t{\n+\t  if (next->block->block->expr1)\n+\t    gfc_error (\"Expected ELSE at %L in atomic compare capture\",\n+\t\t       &next->block->block->expr1->where);\n+\t  if (!code->block->block->next\n+\t      || code->block->block->next->op != EXEC_ASSIGN)\n+\t    {\n+\t      loc = (code->block->block->next ? &code->block->block->next->loc\n+\t\t\t\t\t      : &code->block->block->loc);\n+\t      goto unexpected;\n+\t    }\n+\t  capture_stmt = code->block->block->next;\n+\t  if (capture_stmt->next)\n+\t    {\n+\t      loc = &capture_stmt->next->loc;\n+\t      goto unexpected;\n+\t    }\n+\t}\n+      if (stmt && !capture_stmt && code->op == EXEC_ASSIGN)\n+\t{\n+\t  capture_stmt = code;\n+\t}\n+      else if (!capture_stmt)\n+\t{\n+\t  loc = &code->loc;\n+\t  goto unexpected;\n+\t}\n     }\n-  if (!atomic_code->ext.omp_clauses->capture)\n+  else if (atomic_code->ext.omp_clauses->compare)\n     {\n-      if (code->next != NULL)\n+      /* Must be: \"if (x == e) then; x = d; end if\" or \"if (x == e) x = d\".  */\n+      if (code->op == EXEC_IF\n+\t  && code->block\n+\t  && code->block->op == EXEC_IF\n+\t  && code->block->next->op == EXEC_ASSIGN)\n+\t{\n+\t  stmt = code->block->next;\n+\t  if (stmt->next || code->block->block)\n+\t    {\n+\t      loc = stmt->next ? &stmt->next->loc : &code->block->block->loc;\n+\t      goto unexpected;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  loc = &code->loc;\n+\t  goto unexpected;\n+\t}\n+    }\n+  else if (atomic_code->ext.omp_clauses->capture)\n+    {\n+      /* Must be: \"v = x\" followed/preceded by \"x = ...\". */\n+      if (code->op != EXEC_ASSIGN)\n \tgoto unexpected;\n+      if (code->next->op != EXEC_ASSIGN)\n+\t{\n+\t  loc = &code->next->loc;\n+\t  goto unexpected;\n+\t}\n+      gfc_expr *expr2, *expr2_next;\n+      expr2 = is_conversion (code->expr2, true, true);\n+      if (expr2 == NULL)\n+\texpr2 = code->expr2;\n+      expr2_next = is_conversion (code->next->expr2, true, true);\n+      if (expr2_next == NULL)\n+\texpr2_next = code->next->expr2;\n+      if (code->expr1->expr_type == EXPR_VARIABLE\n+\t  && code->next->expr1->expr_type == EXPR_VARIABLE\n+\t  && expr2->expr_type == EXPR_VARIABLE\n+\t  && expr2_next->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  if (code->expr1->symtree->n.sym == expr2_next->symtree->n.sym)\n+\t    {\n+\t      stmt = code;\n+\t      capture_stmt = code->next;\n+\t    }\n+\t  else\n+\t    {\n+\t      capture_stmt = code;\n+\t      stmt = code->next;\n+\t    }\n+\t}\n+      else if (expr2->expr_type == EXPR_VARIABLE)\n+\t{\n+\t  capture_stmt = code;\n+\t  stmt = code->next;\n+\t}\n+      else\n+\t{\n+\t  stmt = code;\n+\t  capture_stmt = code->next;\n+\t}\n+      gcc_assert (!code->next->next);\n     }\n   else\n     {\n-      if (code->next == NULL)\n+      /* x = ... */\n+      stmt = code;\n+      if ((!atomic_code->ext.omp_clauses->compare && stmt->op != EXEC_ASSIGN)\n+\t  || (atomic_code->ext.omp_clauses->compare && stmt->op != EXEC_IF))\n \tgoto unexpected;\n-      if (code->next->op == EXEC_NOP)\n+      gcc_assert (!code->next);\n+    }\n+\n+  if (comp_cond)\n+    {\n+      if (comp_cond->expr_type != EXPR_OP\n+\t  || (comp_cond->value.op.op != INTRINSIC_EQ\n+\t      && comp_cond->value.op.op != INTRINSIC_EQ_OS\n+\t      && comp_cond->value.op.op != INTRINSIC_EQV))\n+\t{\n+\t  gfc_error (\"Expected %<==%>, %<.EQ.%> or %<.EQV.%> atomic comparison \"\n+\t\t     \"expression at %L\", &comp_cond->where);\n+\t  return;\n+\t}\n+      if (!is_scalar_intrinsic_expr (comp_cond->value.op.op1, true, false))\n+\t{\n+\t  gfc_error (\"Expected scalar intrinsic variable at %L in atomic \"\n+\t\t     \"comparison\", &comp_cond->value.op.op1->where);\n+\t  return;\n+\t}\n+      if (!gfc_resolve_expr (comp_cond->value.op.op2))\n \treturn;\n-      if (code->next->op != EXEC_ASSIGN || code->next->next)\n+      if (!is_scalar_intrinsic_expr (comp_cond->value.op.op2, false, false))\n \t{\n-\t  code = code->next;\n-\t  goto unexpected;\n+\t  gfc_error (\"Expected scalar intrinsic expression at %L in atomic \"\n+\t\t     \"comparison\", &comp_cond->value.op.op1->where);\n+\t  return;\n \t}\n     }\n \n-  if (code->expr1->expr_type != EXPR_VARIABLE\n-      || code->expr1->symtree == NULL\n-      || code->expr1->rank != 0\n-      || (code->expr1->ts.type != BT_INTEGER\n-\t  && code->expr1->ts.type != BT_REAL\n-\t  && code->expr1->ts.type != BT_COMPLEX\n-\t  && code->expr1->ts.type != BT_LOGICAL))\n+  if (!is_scalar_intrinsic_expr (stmt->expr1, true, false))\n     {\n       gfc_error (\"!$OMP ATOMIC statement must set a scalar variable of \"\n-\t\t \"intrinsic type at %L\", &code->loc);\n+\t\t \"intrinsic type at %L\", &stmt->expr1->where);\n       return;\n     }\n \n-  var = code->expr1->symtree->n.sym;\n-  expr2 = is_conversion (code->expr2, false);\n-  if (expr2 == NULL)\n+  if (!gfc_resolve_expr (stmt->expr2))\n+    return;\n+  if (!is_scalar_intrinsic_expr (stmt->expr2, false, false))\n     {\n-      if (aop == GFC_OMP_ATOMIC_READ || aop == GFC_OMP_ATOMIC_WRITE)\n-\texpr2 = is_conversion (code->expr2, true);\n-      if (expr2 == NULL)\n-\texpr2 = code->expr2;\n+      gfc_error (\"!$OMP ATOMIC statement must assign an expression of \"\n+\t\t \"intrinsic type at %L\", &stmt->expr2->where);\n+      return;\n     }\n \n+  if (gfc_expr_attr (stmt->expr1).allocatable)\n+    {\n+      gfc_error (\"!$OMP ATOMIC with ALLOCATABLE variable at %L\",\n+\t\t &stmt->expr1->where);\n+      return;\n+    }\n+\n+  var = stmt->expr1->symtree->n.sym;\n+  stmt_expr2 = is_conversion (stmt->expr2, true, true);\n+  if (stmt_expr2 == NULL)\n+    stmt_expr2 = stmt->expr2;\n+\n   switch (aop)\n     {\n     case GFC_OMP_ATOMIC_READ:\n-      if (expr2->expr_type != EXPR_VARIABLE\n-\t  || expr2->symtree == NULL\n-\t  || expr2->rank != 0\n-\t  || (expr2->ts.type != BT_INTEGER\n-\t      && expr2->ts.type != BT_REAL\n-\t      && expr2->ts.type != BT_COMPLEX\n-\t      && expr2->ts.type != BT_LOGICAL))\n+      if (stmt_expr2->expr_type != EXPR_VARIABLE)\n \tgfc_error (\"!$OMP ATOMIC READ statement must read from a scalar \"\n-\t\t   \"variable of intrinsic type at %L\", &expr2->where);\n+\t\t   \"variable of intrinsic type at %L\", &stmt_expr2->where);\n       return;\n     case GFC_OMP_ATOMIC_WRITE:\n-      if (expr2->rank != 0 || expr_references_sym (code->expr2, var, NULL))\n+      if (expr_references_sym (stmt_expr2, var, NULL))\n \tgfc_error (\"expr in !$OMP ATOMIC WRITE assignment var = expr \"\n \t\t   \"must be scalar and cannot reference var at %L\",\n-\t\t   &expr2->where);\n+\t\t   &stmt_expr2->where);\n       return;\n     default:\n       break;\n     }\n+\n+  if (atomic_code->ext.omp_clauses->compare\n+      && !atomic_code->ext.omp_clauses->capture)\n+    {\n+      gfc_error (\"Sorry, COMPARE clause in ATOMIC at %L is not yet \"\n+\t\t \"supported\", &atomic_code->loc);\n+      return;\n+    }\n+\n   if (atomic_code->ext.omp_clauses->capture)\n     {\n-      expr2_tmp = expr2;\n-      if (expr2 == code->expr2)\n+      if (!is_scalar_intrinsic_expr (capture_stmt->expr1, true, false))\n \t{\n-\t  expr2_tmp = is_conversion (code->expr2, true);\n-\t  if (expr2_tmp == NULL)\n-\t    expr2_tmp = expr2;\n+\t  gfc_error (\"!$OMP ATOMIC capture-statement must set a scalar \"\n+\t\t     \"variable of intrinsic type at %L\",\n+\t\t     &capture_stmt->expr1->where);\n+\t  return;\n \t}\n-      if (expr2_tmp->expr_type == EXPR_VARIABLE)\n+\n+      if (!is_scalar_intrinsic_expr (capture_stmt->expr2, true, true))\n \t{\n-\t  if (expr2_tmp->symtree == NULL\n-\t      || expr2_tmp->rank != 0\n-\t      || (expr2_tmp->ts.type != BT_INTEGER\n-\t\t  && expr2_tmp->ts.type != BT_REAL\n-\t\t  && expr2_tmp->ts.type != BT_COMPLEX\n-\t\t  && expr2_tmp->ts.type != BT_LOGICAL)\n-\t      || expr2_tmp->symtree->n.sym == var)\n-\t    {\n-\t      gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must read from \"\n-\t\t\t \"a scalar variable of intrinsic type at %L\",\n-\t\t\t &expr2_tmp->where);\n-\t      return;\n-\t    }\n-\t  var = expr2_tmp->symtree->n.sym;\n-\t  code = code->next;\n-\t  if (code->expr1->expr_type != EXPR_VARIABLE\n-\t      || code->expr1->symtree == NULL\n-\t      || code->expr1->rank != 0\n-\t      || (code->expr1->ts.type != BT_INTEGER\n-\t\t  && code->expr1->ts.type != BT_REAL\n-\t\t  && code->expr1->ts.type != BT_COMPLEX\n-\t\t  && code->expr1->ts.type != BT_LOGICAL))\n-\t    {\n-\t      gfc_error (\"!$OMP ATOMIC CAPTURE update statement must set \"\n-\t\t\t \"a scalar variable of intrinsic type at %L\",\n-\t\t\t &code->expr1->where);\n-\t      return;\n-\t    }\n-\t  if (code->expr1->symtree->n.sym != var)\n-\t    {\n-\t      gfc_error (\"!$OMP ATOMIC CAPTURE capture statement reads from \"\n-\t\t\t \"different variable than update statement writes \"\n-\t\t\t \"into at %L\", &code->expr1->where);\n-\t      return;\n-\t    }\n-\t  expr2 = is_conversion (code->expr2, false);\n-\t  if (expr2 == NULL)\n-\t    expr2 = code->expr2;\n+\t  gfc_error (\"!$OMP ATOMIC capture-statement requires a scalar variable\"\n+\t\t     \" of intrinsic type at %L\", &capture_stmt->expr2->where);\n+\t  return;\n \t}\n-    }\n+      capt_expr2 = is_conversion (capture_stmt->expr2, true, true);\n+      if (capt_expr2 == NULL)\n+\tcapt_expr2 = capture_stmt->expr2;\n \n-  if (gfc_expr_attr (code->expr1).allocatable)\n-    {\n-      gfc_error (\"!$OMP ATOMIC with ALLOCATABLE variable at %L\",\n-\t\t &code->loc);\n-      return;\n+      if (capt_expr2->symtree->n.sym != var)\n+\t{\n+\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement reads from \"\n+\t\t     \"different variable than update statement writes \"\n+\t\t     \"into at %L\", &capture_stmt->expr2->where);\n+\t      return;\n+\t}\n     }\n \n   if (atomic_code->ext.omp_clauses->capture\n-      && code->next == NULL\n-      && code->expr2->rank == 0\n-      && !expr_references_sym (code->expr2, var, NULL))\n+      && !expr_references_sym (stmt_expr2, var, NULL))\n     atomic_code->ext.omp_clauses->atomic_op\n       = (gfc_omp_atomic_op) (atomic_code->ext.omp_clauses->atomic_op\n \t\t\t     | GFC_OMP_ATOMIC_SWAP);\n-  else if (expr2->expr_type == EXPR_OP)\n+  else if (stmt_expr2->expr_type == EXPR_OP)\n     {\n       gfc_expr *v = NULL, *e, *c;\n-      gfc_intrinsic_op op = expr2->value.op.op;\n+      gfc_intrinsic_op op = stmt_expr2->value.op.op;\n       gfc_intrinsic_op alt_op = INTRINSIC_NONE;\n \n+      if (atomic_code->ext.omp_clauses->fail != OMP_MEMORDER_UNSET\n+\t  && !atomic_code->ext.omp_clauses->compare)\n+\tgfc_error (\"!$OMP ATOMIC UPDATE at %L with FAIL clause requiries either\"\n+\t\t   \" the COMPARE clause or using the intrinsic MIN/MAX \"\n+\t\t   \"procedure\", &atomic_code->loc);\n       switch (op)\n \t{\n \tcase INTRINSIC_PLUS:\n@@ -7666,7 +7860,7 @@ resolve_omp_atomic (gfc_code *code)\n \tdefault:\n \t  gfc_error (\"!$OMP ATOMIC assignment operator must be binary \"\n \t\t     \"+, *, -, /, .AND., .OR., .EQV. or .NEQV. at %L\",\n-\t\t     &expr2->where);\n+\t\t     &stmt_expr2->where);\n \t  return;\n \t}\n \n@@ -7676,28 +7870,28 @@ resolve_omp_atomic (gfc_code *code)\n \t (expr) op var.  We rely here on the fact that the matcher\n \t for x op1 y op2 z where op1 and op2 have equal precedence\n \t returns (x op1 y) op2 z.  */\n-      e = expr2->value.op.op2;\n+      e = stmt_expr2->value.op.op2;\n       if (e->expr_type == EXPR_VARIABLE\n \t  && e->symtree != NULL\n \t  && e->symtree->n.sym == var)\n \tv = e;\n-      else if ((c = is_conversion (e, true)) != NULL\n+      else if ((c = is_conversion (e, false, true)) != NULL\n \t       && c->expr_type == EXPR_VARIABLE\n \t       && c->symtree != NULL\n \t       && c->symtree->n.sym == var)\n \tv = c;\n       else\n \t{\n \t  gfc_expr **p = NULL, **q;\n-\t  for (q = &expr2->value.op.op1; (e = *q) != NULL; )\n+\t  for (q = &stmt_expr2->value.op.op1; (e = *q) != NULL; )\n \t    if (e->expr_type == EXPR_VARIABLE\n \t\t&& e->symtree != NULL\n \t\t&& e->symtree->n.sym == var)\n \t      {\n \t\tv = e;\n \t\tbreak;\n \t      }\n-\t    else if ((c = is_conversion (e, true)) != NULL)\n+\t    else if ((c = is_conversion (e, false, true)) != NULL)\n \t      q = &e->value.function.actual->expr;\n \t    else if (e->expr_type != EXPR_OP\n \t\t     || (e->value.op.op != op\n@@ -7713,7 +7907,7 @@ resolve_omp_atomic (gfc_code *code)\n \t  if (v == NULL)\n \t    {\n \t      gfc_error (\"!$OMP ATOMIC assignment must be var = var op expr \"\n-\t\t\t \"or var = expr op var at %L\", &expr2->where);\n+\t\t\t \"or var = expr op var at %L\", &stmt_expr2->where);\n \t      return;\n \t    }\n \n@@ -7728,83 +7922,90 @@ resolve_omp_atomic (gfc_code *code)\n \t\tcase INTRINSIC_NEQV:\n \t\t  gfc_error (\"!$OMP ATOMIC var = var op expr not \"\n \t\t\t     \"mathematically equivalent to var = var op \"\n-\t\t\t     \"(expr) at %L\", &expr2->where);\n+\t\t\t     \"(expr) at %L\", &stmt_expr2->where);\n \t\t  break;\n \t\tdefault:\n \t\t  break;\n \t\t}\n \n \t      /* Canonicalize into var = var op (expr).  */\n \t      *p = e->value.op.op2;\n-\t      e->value.op.op2 = expr2;\n-\t      e->ts = expr2->ts;\n-\t      if (code->expr2 == expr2)\n-\t\tcode->expr2 = expr2 = e;\n+\t      e->value.op.op2 = stmt_expr2;\n+\t      e->ts = stmt_expr2->ts;\n+\t      if (stmt->expr2 == stmt_expr2)\n+\t\tstmt->expr2 = stmt_expr2 = e;\n \t      else\n-\t\tcode->expr2->value.function.actual->expr = expr2 = e;\n+\t\tstmt->expr2->value.function.actual->expr = stmt_expr2 = e;\n \n-\t      if (!gfc_compare_types (&expr2->value.op.op1->ts, &expr2->ts))\n+\t      if (!gfc_compare_types (&stmt_expr2->value.op.op1->ts,\n+\t\t\t\t      &stmt_expr2->ts))\n \t\t{\n-\t\t  for (p = &expr2->value.op.op1; *p != v;\n+\t\t  for (p = &stmt_expr2->value.op.op1; *p != v;\n \t\t       p = &(*p)->value.function.actual->expr)\n \t\t    ;\n \t\t  *p = NULL;\n-\t\t  gfc_free_expr (expr2->value.op.op1);\n-\t\t  expr2->value.op.op1 = v;\n-\t\t  gfc_convert_type (v, &expr2->ts, 2);\n+\t\t  gfc_free_expr (stmt_expr2->value.op.op1);\n+\t\t  stmt_expr2->value.op.op1 = v;\n+\t\t  gfc_convert_type (v, &stmt_expr2->ts, 2);\n \t\t}\n \t    }\n \t}\n \n-      if (e->rank != 0 || expr_references_sym (code->expr2, var, v))\n+      if (e->rank != 0 || expr_references_sym (stmt->expr2, var, v))\n \t{\n \t  gfc_error (\"expr in !$OMP ATOMIC assignment var = var op expr \"\n \t\t     \"must be scalar and cannot reference var at %L\",\n-\t\t     &expr2->where);\n+\t\t     &stmt_expr2->where);\n \t  return;\n \t}\n     }\n-  else if (expr2->expr_type == EXPR_FUNCTION\n-\t   && expr2->value.function.isym != NULL\n-\t   && expr2->value.function.esym == NULL\n-\t   && expr2->value.function.actual != NULL\n-\t   && expr2->value.function.actual->next != NULL)\n+  else if (stmt_expr2->expr_type == EXPR_FUNCTION\n+\t   && stmt_expr2->value.function.isym != NULL\n+\t   && stmt_expr2->value.function.esym == NULL\n+\t   && stmt_expr2->value.function.actual != NULL\n+\t   && stmt_expr2->value.function.actual->next != NULL)\n     {\n       gfc_actual_arglist *arg, *var_arg;\n \n-      switch (expr2->value.function.isym->id)\n+      switch (stmt_expr2->value.function.isym->id)\n \t{\n \tcase GFC_ISYM_MIN:\n \tcase GFC_ISYM_MAX:\n \t  break;\n \tcase GFC_ISYM_IAND:\n \tcase GFC_ISYM_IOR:\n \tcase GFC_ISYM_IEOR:\n-\t  if (expr2->value.function.actual->next->next != NULL)\n+\t  if (stmt_expr2->value.function.actual->next->next != NULL)\n \t    {\n \t      gfc_error (\"!$OMP ATOMIC assignment intrinsic IAND, IOR \"\n \t\t\t \"or IEOR must have two arguments at %L\",\n-\t\t\t &expr2->where);\n+\t\t\t &stmt_expr2->where);\n \t      return;\n \t    }\n \t  break;\n \tdefault:\n \t  gfc_error (\"!$OMP ATOMIC assignment intrinsic must be \"\n \t\t     \"MIN, MAX, IAND, IOR or IEOR at %L\",\n-\t\t     &expr2->where);\n+\t\t     &stmt_expr2->where);\n \t  return;\n \t}\n \n       var_arg = NULL;\n-      for (arg = expr2->value.function.actual; arg; arg = arg->next)\n-\t{\n-\t  if ((arg == expr2->value.function.actual\n-\t       || (var_arg == NULL && arg->next == NULL))\n-\t      && arg->expr->expr_type == EXPR_VARIABLE\n-\t      && arg->expr->symtree != NULL\n-\t      && arg->expr->symtree->n.sym == var)\n-\t    var_arg = arg;\n-\t  else if (expr_references_sym (arg->expr, var, NULL))\n+      for (arg = stmt_expr2->value.function.actual; arg; arg = arg->next)\n+\t{\n+\t  gfc_expr *e = NULL;\n+\t  if (arg == stmt_expr2->value.function.actual\n+\t      || (var_arg == NULL && arg->next == NULL))\n+\t    {\n+\t      e = is_conversion (arg->expr, false, true);\n+\t      if (!e)\n+\t\te = arg->expr;\n+\t      if (e->expr_type == EXPR_VARIABLE\n+\t\t  && e->symtree != NULL\n+\t\t  && e->symtree->n.sym == var)\n+\t\tvar_arg = arg;\n+\t    }\n+\t  if ((!var_arg || !e) && expr_references_sym (arg->expr, var, NULL))\n \t    {\n \t      gfc_error (\"!$OMP ATOMIC intrinsic arguments except one must \"\n \t\t\t \"not reference %qs at %L\",\n@@ -7822,72 +8023,35 @@ resolve_omp_atomic (gfc_code *code)\n       if (var_arg == NULL)\n \t{\n \t  gfc_error (\"First or last !$OMP ATOMIC intrinsic argument must \"\n-\t\t     \"be %qs at %L\", var->name, &expr2->where);\n+\t\t     \"be %qs at %L\", var->name, &stmt_expr2->where);\n \t  return;\n \t}\n \n-      if (var_arg != expr2->value.function.actual)\n+      if (var_arg != stmt_expr2->value.function.actual)\n \t{\n \t  /* Canonicalize, so that var comes first.  */\n \t  gcc_assert (var_arg->next == NULL);\n-\t  for (arg = expr2->value.function.actual;\n+\t  for (arg = stmt_expr2->value.function.actual;\n \t       arg->next != var_arg; arg = arg->next)\n \t    ;\n-\t  var_arg->next = expr2->value.function.actual;\n-\t  expr2->value.function.actual = var_arg;\n+\t  var_arg->next = stmt_expr2->value.function.actual;\n+\t  stmt_expr2->value.function.actual = var_arg;\n \t  arg->next = NULL;\n \t}\n     }\n   else\n     gfc_error (\"!$OMP ATOMIC assignment must have an operator or \"\n-\t       \"intrinsic on right hand side at %L\", &expr2->where);\n-\n-  if (atomic_code->ext.omp_clauses->capture && code->next)\n-    {\n-      code = code->next;\n-      if (code->expr1->expr_type != EXPR_VARIABLE\n-\t  || code->expr1->symtree == NULL\n-\t  || code->expr1->rank != 0\n-\t  || (code->expr1->ts.type != BT_INTEGER\n-\t      && code->expr1->ts.type != BT_REAL\n-\t      && code->expr1->ts.type != BT_COMPLEX\n-\t      && code->expr1->ts.type != BT_LOGICAL))\n-\t{\n-\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must set \"\n-\t\t     \"a scalar variable of intrinsic type at %L\",\n-\t\t     &code->expr1->where);\n-\t  return;\n-\t}\n+\t       \"intrinsic on right hand side at %L\", &stmt_expr2->where);\n \n-      expr2 = is_conversion (code->expr2, false);\n-      if (expr2 == NULL)\n-\t{\n-\t  expr2 = is_conversion (code->expr2, true);\n-\t  if (expr2 == NULL)\n-\t    expr2 = code->expr2;\n-\t}\n+  if (atomic_code->ext.omp_clauses->compare)\n+    gfc_error (\"Sorry, COMPARE clause in ATOMIC at %L is not yet \"\n+\t       \"supported\", &atomic_code->loc);\n+  return;\n \n-      if (expr2->expr_type != EXPR_VARIABLE\n-\t  || expr2->symtree == NULL\n-\t  || expr2->rank != 0\n-\t  || (expr2->ts.type != BT_INTEGER\n-\t      && expr2->ts.type != BT_REAL\n-\t      && expr2->ts.type != BT_COMPLEX\n-\t      && expr2->ts.type != BT_LOGICAL))\n-\t{\n-\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement must read \"\n-\t\t     \"from a scalar variable of intrinsic type at %L\",\n-\t\t     &expr2->where);\n-\t  return;\n-\t}\n-      if (expr2->symtree->n.sym != var)\n-\t{\n-\t  gfc_error (\"!$OMP ATOMIC CAPTURE capture statement reads from \"\n-\t\t     \"different variable than update statement writes \"\n-\t\t     \"into at %L\", &expr2->where);\n-\t  return;\n-\t}\n-    }\n+unexpected:\n+  gfc_error (\"unexpected !$OMP ATOMIC expression at %L\",\n+\t     loc ? loc : &code->loc);\n+  return;\n }\n \n "}, {"sha": "1f111091b0a37694343e00d40e220059980a7b06", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -5313,7 +5313,22 @@ parse_omp_oacc_atomic (bool omp_p)\n       st = next_statement ();\n       if (st == ST_NONE)\n \tunexpected_eof ();\n-      else if (st == ST_ASSIGNMENT)\n+      else if (np->ext.omp_clauses->compare\n+\t       && (st == ST_SIMPLE_IF || st == ST_IF_BLOCK))\n+\t{\n+\t  count--;\n+\t  if (st == ST_IF_BLOCK)\n+\t    {\n+\t      parse_if_block ();\n+\t      /* With else (or elseif).  */\n+\t      if (gfc_state_stack->tail->block->block)\n+\t\tcount--;\n+\t    }\n+\t  accept_statement (st);\n+\t}\n+      else if (st == ST_ASSIGNMENT\n+\t       && (!np->ext.omp_clauses->compare\n+\t\t   || np->ext.omp_clauses->capture))\n \t{\n \t  accept_statement (st);\n \t  count--;\n@@ -5332,8 +5347,6 @@ parse_omp_oacc_atomic (bool omp_p)\n       gfc_warning_check ();\n       st = next_statement ();\n     }\n-  else if (np->ext.omp_clauses->capture)\n-    gfc_error (\"Missing !$OMP END ATOMIC after !$OMP ATOMIC CAPTURE at %C\");\n   return st;\n }\n "}, {"sha": "0ed31970f8beee422decad26ad370120c4472949", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -10849,13 +10849,8 @@ gfc_resolve_blocks (gfc_code *b, gfc_namespace *ns)\n \t  {\n \t    /* Verify this before calling gfc_resolve_code, which might\n \t       change it.  */\n-\t    gcc_assert (b->next && b->next->op == EXEC_ASSIGN);\n-\t    gcc_assert ((!b->ext.omp_clauses->capture\n-\t\t\t && b->next->next == NULL)\n-\t\t\t|| (b->ext.omp_clauses->capture\n-\t\t\t    && b->next->next != NULL\n-\t\t\t    && b->next->next->op == EXEC_ASSIGN\n-\t\t\t    && b->next->next->next == NULL));\n+\t    gcc_assert (b->op == EXEC_OMP_ATOMIC\n+\t\t\t|| (b->next && b->next->op == EXEC_ASSIGN));\n \t  }\n \t  break;\n "}, {"sha": "201550691bd9bfd70396618d110eb5eebc687633", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -4492,7 +4492,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n   enum tree_code op = ERROR_MARK;\n   enum tree_code aop = OMP_ATOMIC;\n   bool var_on_left = false;\n-  enum omp_memory_order mo;\n+  enum omp_memory_order mo, fail_mo;\n   switch (atomic_code->ext.omp_clauses->memorder)\n     {\n     case OMP_MEMORDER_UNSET: mo = OMP_MEMORY_ORDER_UNSPECIFIED; break;\n@@ -4503,6 +4503,15 @@ gfc_trans_omp_atomic (gfc_code *code)\n     case OMP_MEMORDER_SEQ_CST: mo = OMP_MEMORY_ORDER_SEQ_CST; break;\n     default: gcc_unreachable ();\n     }\n+  switch (atomic_code->ext.omp_clauses->fail)\n+    {\n+    case OMP_MEMORDER_UNSET: fail_mo = OMP_FAIL_MEMORY_ORDER_UNSPECIFIED; break;\n+    case OMP_MEMORDER_ACQUIRE: fail_mo = OMP_FAIL_MEMORY_ORDER_ACQUIRE; break;\n+    case OMP_MEMORDER_RELAXED: fail_mo = OMP_FAIL_MEMORY_ORDER_RELAXED; break;\n+    case OMP_MEMORDER_SEQ_CST: fail_mo = OMP_FAIL_MEMORY_ORDER_SEQ_CST; break;\n+    default: gcc_unreachable ();\n+    }\n+   mo = (omp_memory_order) (mo | fail_mo);\n \n   code = code->block->next;\n   gcc_assert (code->op == EXEC_ASSIGN);\n@@ -4733,6 +4742,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n     {\n       x = build2_v (OMP_ATOMIC, lhsaddr, convert (type, x));\n       OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n+      OMP_ATOMIC_WEAK (x) = atomic_code->ext.omp_clauses->weak;\n       gfc_add_expr_to_block (&block, x);\n     }\n   else\n@@ -4756,6 +4766,7 @@ gfc_trans_omp_atomic (gfc_code *code)\n \t}\n       x = build2 (aop, type, lhsaddr, convert (type, x));\n       OMP_ATOMIC_MEMORY_ORDER (x) = mo;\n+      OMP_ATOMIC_WEAK (x) = atomic_code->ext.omp_clauses->weak;\n       x = convert (TREE_TYPE (vse.expr), x);\n       gfc_add_modify (&block, vse.expr, x);\n     }"}, {"sha": "bafc88b0d8474b465bf9d3c7b121852024170bb8", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-10.f90", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-10.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,32 @@\n+! PR middle-end/28046  for the original C tet.\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fdump-tree-ompexp\" }\n+! { dg-require-effective-target cas_int }\n+\n+module m\n+  implicit none\n+  integer a(3), b\n+  type t_C\n+     integer :: x, y\n+  end type\n+  type(t_C) :: c\n+\n+  interface\n+    integer function bar(); end\n+    integer function baz(); end\n+  end interface\n+  pointer :: baz\n+contains\n+subroutine foo\n+!$omp atomic\n+  a(2) = a(2) + bar ()\n+!$omp atomic\n+  b = b + bar ()\n+!$omp atomic\n+  c%y = c%y + bar ()\n+!$omp atomic\n+  b = b + baz ()\n+end\n+end module\n+\n+! { dg-final { scan-tree-dump-times \"__atomic_fetch_add\" 4 \"ompexp\" } }"}, {"sha": "a0970767ff571d068232f01f9096ae0a1e950c76", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-12.f90", "status": "added", "additions": 364, "deletions": 0, "changes": 364, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-12.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-12.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-12.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,364 @@\n+! PR middle-end/45423 - for the original C/C++ testcase\n+! { dg-do compile }\n+! { dg-options \"-fopenmp -fdump-tree-gimple -g0 -Wno-deprecated\" }\n+! atomicvar should never be referenced in between the barrier and\n+! following #pragma omp atomic_load.\n+! { dg-final { scan-tree-dump-not \"barrier\\[^#\\]*atomicvar\" \"gimple\" } }\n+\n+module m\n+  implicit none\n+  logical :: atomicvar, c\n+  integer :: i, atomicvar2, c2\n+contains\n+integer function foo ()\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .or. .true.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .or. .false.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .or. c\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .and. .true.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .and. .false.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .and. c\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .neqv. .true.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .neqv. .false.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .neqv. c\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .eqv. .true.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .eqv. .false.\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = atomicvar .eqv. c\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .true. .or. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .false. .or. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = c .or. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .true. .and. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .false. .and. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = c .and. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .true. .neqv. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .false. .neqv. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = c .neqv. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .true. .eqv. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = .false. .eqv. atomicvar\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar = c .eqv. atomicvar\n+  !$omp barrier\n+  foo = 0\n+end\n+\n+integer function bar ()\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (atomicvar2, -1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (atomicvar2, 0)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (atomicvar2, 1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (atomicvar2, 2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (atomicvar2, c2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (-1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (0, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (c2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (atomicvar2, -1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (atomicvar2, 0)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (atomicvar2, 1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (atomicvar2, 2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (atomicvar2, c2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (-1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (0, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ieor (1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = ior (c2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (atomicvar2, -1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (atomicvar2, 0)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (atomicvar2, 1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (atomicvar2, 2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (atomicvar2, c2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (-1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (0, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = iand (c2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (atomicvar2, -1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (atomicvar2, 0)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (atomicvar2, 1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (atomicvar2, 2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (atomicvar2, c2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (-1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (0, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = min (c2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (atomicvar2, -1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (atomicvar2, 0)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (atomicvar2, 1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (atomicvar2, 2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (atomicvar2, c2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (-1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (0, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (1, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = max (c2, atomicvar2)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 + (-1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 + 0\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 + 1\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 + 2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 + c2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = -1 + atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 0 + atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 1 + atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 2 + atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = c2 + atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 - (-1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 - 0\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 - 1\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 - 2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 - c2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = -1 - atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 0 - atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 1 - atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 2 - atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = c2 - atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 * (-1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 * 0\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 * 1\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 * 2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 * c2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = (-1) * atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 0 * atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 1 * atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 2 * atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = c2 * atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 / (-1)\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 / 0\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 / 1\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 / 2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = atomicvar2 / c2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = (-1) / atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 0 / atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 1 / atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = 2 / atomicvar2\n+  !$omp barrier\n+  !$omp atomic\n+    atomicvar2 = c2 / atomicvar2\n+  !$omp barrier\n+  bar = 0\n+end\n+end module"}, {"sha": "4c81791e5ddccfe9a647d40288829a405ea92598", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-15.f90", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-15.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,44 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+module m\n+  implicit none\n+  integer :: x = 6\n+end module m\n+\n+program main\n+  use m\n+  implicit none\n+  integer v\n+  !$omp atomic\n+    x = x * 7 + 6       ! { dg-error \"assignment must be var = var op expr or var = expr op var\" }\n+  !$omp atomic\n+    x = ieor (x * 7, 6)       ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+  !$omp atomic update\n+    x = x - 8 + 6       ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic\n+    x = ior (ieor (x, 7), 2)       ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+  !$omp atomic\n+    x = x / 7 * 2       ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic\n+    x = x / 7 / 2       ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic capture\n+    v = x; x = x * 7 + 6   ! { dg-error \"assignment must be var = var op expr or var = expr op var\" }\n+  !$omp atomic capture\n+    v = x; x = ieor(x * 7, 6)   ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+  !$omp atomic capture\n+    v = x; x = x - 8 + 6   ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic capture\n+    v = x; x = ior (ieor(x, 7), 2)   ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+  !$omp atomic capture\n+    v = x; x = x / 7 * 2   ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic capture\n+    v = x; x = x / 7 / 2   ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic capture\n+    x = x * 7 + 6; v = x   ! { dg-error \"assignment must be var = var op expr or var = expr op var\" }\n+  !$omp atomic capture\n+    x = ieor(x * 7, 6); v = x   ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+  !$omp atomic capture\n+    x = x - 8 + 6; v = x   ! { dg-error \"var = var op expr not mathematically equivalent to var = var op \\\\(expr\\\\)\" }\n+  !$omp atomic capture\n+    x = ior(ieor(x, 7), 2); v = x   ! { dg-error \"intrinsic arguments except one must not reference 'x'\" }\n+end"}, {"sha": "766085855e11ba29d9b1e6e29ca7b3d95e9ca88a", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-16.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-16.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-16.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-16.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do compile }\n+! { dg-options \"-fopenmp\" }\n+\n+module m\n+  implicit none\n+  integer :: x = 6\n+contains\n+\n+subroutine foo ()\n+  integer v\n+  !$omp atomic seq_cst read\n+  v = x\n+  !$omp atomic seq_cst, read\n+  v = x\n+  !$omp atomic seq_cst write\n+  x = v\n+  !$omp atomic seq_cst ,write\n+  x = v\n+  !$omp atomic seq_cst update\n+  x = x + v;\n+  !$omp atomic seq_cst , update\n+  x = v + x;\n+  !$omp atomic seq_cst capture\n+  v = x; x = x + 2;\n+  !$omp atomic seq_cst, capture\n+  v = x; x = 2 + x;\n+  !$omp atomic read , seq_cst\n+  v = x\n+  !$omp atomic write ,seq_cst\n+  x = v\n+  !$omp atomic update, seq_cst\n+  x = x + v\n+  !$omp atomic capture, seq_cst\n+  x = x + 2; v = x\n+end\n+end module m"}, {"sha": "d6864f5a1788e8d106b30d6f4067fde137b25e1a", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-17.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-17.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-17.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-17.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,41 @@\n+module m\n+implicit none\n+integer i, v\n+real f\n+contains\n+\n+subroutine foo ()\n+  !$omp atomic release, hint (0), update\n+  i = i + 1\n+  !$omp atomic hint(0)seq_cst\n+  i = i + 1\n+  !$omp atomic relaxed,update,hint (0)\n+  i = i + 1\n+  !$omp atomic release\n+  i = i + 1\n+  !$omp atomic relaxed\n+  i = i + 1\n+  !$omp atomic acq_rel capture\n+  i = i + 1; v = i\n+  !$omp atomic capture,acq_rel , hint (1)\n+  i = i + 1; v = i\n+  !$omp atomic hint(0),acquire capture\n+  i = i + 1; v = i\n+  !$omp atomic read acquire\n+  v = i\n+  !$omp atomic acq_rel read\n+  v = i\n+  !$omp atomic release,write\n+  i = v\n+  !$omp atomic write,acq_rel\n+  i = v\n+  !$omp atomic hint(1),update,release\n+  f = f + 2.0\n+  !$omp atomic update ,acquire\n+  i = i + 1\n+  !$omp atomic acq_rel update\n+  i = i + 1\n+  !$omp atomic acq_rel,hint(0)\n+  i = i + 1\n+end\n+end module"}, {"sha": "9bc6f637aca0af9dda3bbf708cdf5f337c3322e2", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-18.f90", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-18.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-18.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-18.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,27 @@\n+module m\n+implicit none\n+integer i, v\n+real f\n+contains\n+subroutine foo (j)\n+integer, value :: j\n+  !$omp atomic update,update        ! { dg-error \"Duplicated atomic clause: unexpected update clause\" }\n+  i = i + 1\n+  !$omp atomic seq_cst release      ! { dg-error \"Duplicated memory-order clause: unexpected release clause\" }\n+  i = i + 1\n+  !$omp atomic read,release         ! { dg-error \"ATOMIC READ at .1. incompatible with RELEASE clause\" }\n+  v = i\n+  !$omp atomic acquire , write      ! { dg-error \"ATOMIC WRITE at .1. incompatible with ACQUIRE clause\" }\n+  i = v\n+  !$omp atomic capture hint (0) capture  ! { dg-error \"Duplicated 'capture' clause\" }\n+  v = i = i + 1\n+  !$omp atomic hint(j + 2)      ! { dg-error \"Value of HINT clause at .1. shall be a valid constant hint expression\" }\n+  i = i + 1\n+  !$omp atomic hint(f)\n+    ! { dg-error \"HINT clause at .1. requires a scalar INTEGER expression\" \"\" { target *-*-* } .-1 }\n+    ! { dg-error \"Value of HINT clause at .1. shall be a valid constant hint expression\" \"\" { target *-*-* } .-2 }\n+  i = i + 1\n+  !$omp atomic foobar           ! { dg-error \"Failed to match clause\" }\n+  i = i + 1\n+end\n+end module"}, {"sha": "ade4c940469b295ac22f387cf142548cf1444d62", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-19.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-19.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-19.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-19.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-final { scan-tree-dump-times \"omp atomic release\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic relaxed\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic read relaxed\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic capture relaxed\" 1 \"original\" } }\n+\n+module mod\n+  implicit none\n+  integer i, j, k, l, m, n\n+\n+contains\n+\n+subroutine foo ()\n+  !$omp atomic release\n+  i = i + 1;\n+end\n+end\n+\n+module m2\n+use mod\n+implicit none\n+!$omp requires atomic_default_mem_order (relaxed)\n+\n+contains\n+subroutine bar ()\n+  integer v;\n+  !$omp atomic\n+  j = j + 1\n+  !$omp atomic update\n+  k = k + 1\n+  !$omp atomic read\n+  v = l\n+  !$omp atomic write\n+  m = v\n+  !$omp atomic capture\n+  n = n + 1; v = n\n+end\n+end module m2"}, {"sha": "b6c1b6a519e42ac85afced1f71e52df2446bf9d5", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-2.f90", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-2.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -3,13 +3,13 @@\n subroutine bar\n   integer :: i, v\n   real :: f\n-  !$omp atomic update acq_rel hint(\"abc\") ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  !$omp atomic update acq_rel hint(\"abc\")\n     ! { dg-error \"HINT clause at .1. requires a scalar INTEGER expression\" \"\" { target *-*-* } .-1 }\n     ! { dg-error \"Value of HINT clause at .1. shall be a valid constant hint expression\" \"\" { target *-*-* } .-2 }\n     i = i + 1\n   !$omp end atomic\n \n-  !$omp atomic acq_rel ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  !$omp atomic acq_rel\n   i = i + 1\n   !$omp end atomic\n \n@@ -18,7 +18,7 @@ subroutine bar\n   v = i\n   !$omp end atomic\n \n-  !$omp atomic acq_rel , hint (1), update ! { dg-error \"OMP ATOMIC UPDATE at .1. incompatible with ACQ_REL or ACQUIRE clauses\" }\n+  !$omp atomic acq_rel , hint (1), update\n   i = i + 1\n   !$omp end atomic\n \n@@ -27,44 +27,10 @@ subroutine bar\n   v = i\n   !$omp end atomic\n \n-  !$omp atomic write capture ! { dg-error \"multiple atomic clauses\" }\n+  !$omp atomic write capture ! { dg-error \"with CAPTURE clause is incompatible with READ or WRITE\" }\n   i = 2\n   v = i\n   !$omp end atomic\n \n   !$omp atomic foobar ! { dg-error \"Failed to match clause\" }\n end\n-\n-! moved here from atomic.f90\n-subroutine openmp51_foo\n-  integer :: x, v\n-  !$omp atomic update seq_cst capture  ! { dg-error \"multiple atomic clauses\" }\n-  x = x + 2\n-  v = x\n-  !$omp end atomic\n-  !$omp atomic seq_cst, capture, update  ! { dg-error \"multiple atomic clauses\" }\n-  x = x + 2\n-  v = x\n-  !$omp end atomic\n-  !$omp atomic capture, seq_cst ,update  ! { dg-error \"multiple atomic clauses\" }\n-  x = x + 2\n-  v = x\n-  !$omp end atomic\n-end\n-\n-subroutine openmp51_bar\n-  integer :: i, v\n-  real :: f\n-  !$omp atomic relaxed capture update  ! { dg-error \"multiple atomic clauses\" }\n-  i = i + 1\n-  v = i\n-  !$omp end atomic\n-  !$omp atomic update capture,release , hint (1)  ! { dg-error \"multiple atomic clauses\" }\n-  i = i + 1\n-  v = i\n-  !$omp end atomic\n-  !$omp atomic hint(0),update relaxed capture  ! { dg-error \"multiple atomic clauses\" }\n-  i = i + 1\n-  v = i\n-  !$omp end atomic\n-end"}, {"sha": "29193e17dddaa98ea124989daa30bb40e00e4bce", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-20.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-20.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-20.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-20.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\n+! { dg-additional-options \"-fdump-tree-original\" }\n+! { dg-final { scan-tree-dump-times \"omp atomic release\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic seq_cst\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic read seq_cst\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"omp atomic capture seq_cst\" 1 \"original\" } }\n+\n+module mod\n+implicit none\n+integer i, j, k, l, m, n\n+\n+contains \n+subroutine foo ()\n+  !$omp atomic release\n+  i = i + 1\n+end\n+end module\n+\n+module m2\n+use mod\n+implicit none\n+!$omp requires atomic_default_mem_order (seq_cst)\n+\n+contains\n+\n+subroutine bar ()\n+  integer v\n+  !$omp atomic\n+  j = j + 1\n+  !$omp atomic update\n+  k = k + 1\n+  !$omp atomic read\n+  v = l\n+  !$omp atomic write\n+  m = v\n+  !$omp atomic capture\n+  n = n + 1; v = n\n+end\n+end module"}, {"sha": "584c0d397236e735b511e1bfc97c68ccb0125dd7", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-22.f90", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-22.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-22.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-22.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,24 @@\n+module mod\n+integer i, j\n+\n+contains\n+subroutine foo ()\n+  integer v\n+  !$omp atomic release\n+  i = i + 1\n+  !$omp atomic read\n+  v = j\n+end\n+end module\n+\n+module m2\n+!$omp requires atomic_default_mem_order (acq_rel)\t! OK\n+contains\n+subroutine bar\n+  !$omp atomic release\n+  i = i + 1\n+!$omp requires atomic_default_mem_order (acq_rel)\t! { dg-error \"must appear in the specification part of a program unit\" }\n+  !$omp atomic read\n+  v = j\n+end subroutine\n+end module m2"}, {"sha": "235826ee7bfbb75884a8756bf0eae68ad1678c0b", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-24.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-24.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-24.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-24.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,13 @@\n+! PR c/101297\n+\n+module m\n+implicit none\n+integer :: i\n+contains\n+subroutine foo ()\n+  !$omp atomic update,\t! { dg-error \"Clause expected at .1. after trailing comma\" }\n+  i = i + 1\n+  !$omp atomic update,,\t! { dg-error \"Failed to match clause\" }\n+  i = i + 1\n+end\n+end module"}, {"sha": "598ff4e54db9311ab03deb6962260daa7a5822d0", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-25.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-25.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+\n+module m\n+use iso_fortran_env\n+implicit none\n+integer, parameter :: mrk = maxval(real_kinds)\n+integer x, r, z\n+real(kind(4.0d0)) d, v\n+real(mrk) ld\n+\n+contains\n+subroutine foo (y, e, f)\n+  integer :: y\n+  real(kind(4.0d0)) :: e\n+  real(mrk) :: f\n+  !$omp atomic update seq_cst fail(acquire)\n+  x = min(x, y)\n+  !$omp atomic relaxed fail(relaxed)\n+  d = max (e, d)\n+  !$omp atomic fail(SEQ_CST)\n+  d = min (d, f)\n+  !$omp atomic seq_cst compare fail(relaxed)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 7) x = 24\n+  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 7) x = 24\n+  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 123) x = 256\n+  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (ld == f)  ld = f + 5.0_mrk\n+  !$omp atomic compare  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 9) then\n+    x = 5\n+  endif\n+  !$omp atomic compare update capture seq_cst fail(acquire)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 42) then\n+    x = f\n+  else\n+    v = x\n+  endif\n+  !$omp atomic capture compare weak  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (x == 42) then\n+    x = f\n+  else\n+    v = x\n+  endif\n+  !$omp atomic capture compare fail(seq_cst)  ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" }\n+  if (d == 8.0) then\n+    d = 16.0\n+  else\n+    v = d\n+  end if\n+end\n+end module"}, {"sha": "5f21d3b6f920a12838299c55a2325b9d23adfc39", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic-26.f90", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic-26.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -0,0 +1,75 @@\n+! { dg-do compile }\n+\n+module m\n+implicit none\n+integer x\n+real d\n+\n+contains\n+\n+real function foo (y, e, f)\n+  integer :: y\n+  real v, e\n+  real(8) :: f\n+  !$omp atomic compare compare\t! { dg-error \"Duplicated 'compare' clause\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(seq_cst) fail(seq_cst)\t! { dg-error \"Duplicated 'fail' clause\" }\n+  if (x == y) x = d\n+  !$omp atomic compare,fail(seq_cst),fail(relaxed)\t! { dg-error \"Duplicated 'fail' clause\" }\n+  if (x == y) x = d\n+  !$omp atomic compare weak weak\t! { dg-error \"Duplicated 'weak' clause\" }\n+  if (x == y) x = d\n+  !$omp atomic read capture\t! { dg-error \"CAPTURE clause is incompatible with READ or WRITE\" }\n+  v = d\n+  !$omp atomic capture, write\t! { dg-error \"CAPTURE clause is incompatible with READ or WRITE\" }\n+  d = v; v = v + 1              ! { dg-error \"Unexpected ..OMP ATOMIC statement\" \"\" { target *-*-* } .-1 }\n+  foo = v\n+end\n+\n+real function bar (y, e, f)\n+  integer :: y\n+  real v, e\n+  real(8) :: f\n+  !$omp atomic read compare\t! { dg-error \"COMPARE clause is incompatible with READ or WRITE\" }\n+  if (x == y) x = d\n+  !$omp atomic compare, write\t! { dg-error \"COMPARE clause is incompatible with READ or WRITE\" }\n+  if (x == y) x = d\n+  !$omp atomic read fail(seq_cst)\t! { dg-error \"FAIL clause is incompatible with READ or WRITE\" }\n+  v = d\n+  !$omp atomic fail(relaxed), write\t! { dg-error \"FAIL clause is incompatible with READ or WRITE\" }\n+  d = v\n+  !$omp atomic fail(relaxed) update\t! { dg-error \"FAIL clause requiries either the COMPARE clause or using the intrinsic MIN/MAX procedure\" }\n+  d = d + 3.0\n+  !$omp atomic fail(relaxed)\t! { dg-error \"FAIL clause requiries either the COMPARE clause or using the intrinsic MIN/MAX procedure\" }\n+  d = d + 3.0\n+  !$omp atomic capture fail(relaxed)\t! { dg-error \"FAIL clause requiries either the COMPARE clause or using the intrinsic MIN/MAX procedure\" }\n+  v = d; d = d + 3.0\n+  !$omp atomic read weak\t\t! { dg-error \"WEAK clause requires COMPARE clause\" }\n+  v = d\n+  !$omp atomic weak, write\t! { dg-error \"WEAK clause requires COMPARE clause\" }\n+  d = v\n+  !$omp atomic weak update\t! { dg-error \"WEAK clause requires COMPARE clause\" }\n+  d = d + 3.0\n+  !$omp atomic weak\t\t! { dg-error \"WEAK clause requires COMPARE clause\" }\n+  d = d + 3.0\n+  !$omp atomic capture weak\t! { dg-error \"WEAK clause requires COMPARE clause\" }\n+  d = d + 3.0; v = d\n+  !$omp atomic capture\n+  d = d + 3.0; v = x            ! { dg-error \"capture statement reads from different variable than update statement writes\" }\n+  !$omp atomic compare fail\t! { dg-error \"Expected '\\\\\\(' after 'fail'\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n+  if (x == y) x = d             ! { dg-error \"Sorry, COMPARE clause in ATOMIC at .1. is not yet supported\" \"\" { target *-*-* } .-1 }\n+  !$omp atomic compare fail()\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(foobar)\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(acq_rel)\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(release)\t! { dg-error \"Expected SEQ_CST, ACQUIRE or RELAXED\" }\n+  if (x == y) x = d\n+  !$omp atomic compare fail(seq_cst\t! { dg-error \"Failed to match clause\" }\n+  if (x == y) x = d\n+  bar = v\n+end\n+end module"}, {"sha": "ca1279655700c37724bdb1f8ad90d490817d04f6", "filename": "gcc/testsuite/gfortran.dg/gomp/atomic.f90", "status": "modified", "additions": 36, "deletions": 4, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fatomic.f90?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -3,14 +3,13 @@\n \n ! { dg-final { scan-tree-dump-times \"#pragma omp atomic relaxed\" 4 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"#pragma omp atomic release\" 4 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture relaxed\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture release\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture relaxed\" 4 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture release\" 2 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic read acquire\" 1 \"original\" } }\n \n ! { dg-final { scan-tree-dump-times \"#pragma omp atomic seq_cst\" 7 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic read seq_cst\" 3 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture seq_cst\" 3 \"original\" } }\n-\n+! { dg-final { scan-tree-dump-times \"v = #pragma omp atomic capture seq_cst\" 6 \"original\" } }\n \n subroutine foo ()\n   integer :: x, v\n@@ -85,3 +84,36 @@ subroutine bar\n   !$omp atomic hint(1),update,release\n   f = f + 2.0\n end\n+\n+subroutine openmp51_foo\n+  integer :: x, v\n+  !$omp atomic update seq_cst capture\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic seq_cst, capture, update\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+  !$omp atomic capture, seq_cst ,update\n+  x = x + 2\n+  v = x\n+  !$omp end atomic\n+end\n+\n+subroutine openmp51_bar\n+  integer :: i, v\n+  real :: f\n+  !$omp atomic relaxed capture update\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic update capture,release , hint (1)\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+  !$omp atomic hint(0),update relaxed capture\n+  i = i + 1\n+  v = i\n+  !$omp end atomic\n+end"}, {"sha": "33ca2bf4f1c0eba26107d5d8cf6b672c36c6188b", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/689407ef916503b2f5a3c8c07fe7d5ab1913f956/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/689407ef916503b2f5a3c8c07fe7d5ab1913f956/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=689407ef916503b2f5a3c8c07fe7d5ab1913f956", "patch": "@@ -301,7 +301,8 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{interop} directive @tab N @tab\n @item @code{omp_interop_t} object support in runtime routines @tab N @tab\n @item @code{nowait} clause in @code{taskwait} directive @tab N @tab\n-@item Extensions to the @code{atomic} directive @tab P @tab C/C++ only\n+@item Extensions to the @code{atomic} directive @tab P\n+      @tab @code{compare} unsupported in Fortran\n @item @code{seq_cst} clause on a @code{flush} construct @tab Y @tab\n @item @code{inoutset} argument to the @code{depend} clause @tab N @tab\n @item @code{private} and @code{firstprivate} argument to @code{default}"}]}