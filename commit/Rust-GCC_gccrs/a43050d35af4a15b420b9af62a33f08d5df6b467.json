{"sha": "a43050d35af4a15b420b9af62a33f08d5df6b467", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTQzMDUwZDM1YWY0YTE1YjQyMGI5YWY2MmEzM2YwOGQ1ZGY2YjQ2Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:58:31Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:58:31Z"}, "message": "(lvalue_required_p): Handle N_Parameter_Association like N_Function_Call and N_Procedure_Call_Statement.\n\n\t(lvalue_required_p): Handle N_Parameter_Association like N_Function_Call\n\tand N_Procedure_Call_Statement.\n\t(takes_address): Rename to lvalue_required_p, add third parameter\n\t'aliased'\n\tand adjust recursive calls.\n\t<N_Indexed_Component>: Update 'aliased' from the array type.\n\t<N_Selected_Component>: New case.\n\t<N_Object_Renaming_Declaration>: New Likewise.\n\t(Identifier_to_gnu): Adjust for above changes.\n\t(maybe_stabilize_reference) <CONST_DECL>: New case.\n\nFrom-SVN: r127470", "tree": {"sha": "51c86076226cad90f01bdb90b6ca5509b68c51dc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51c86076226cad90f01bdb90b6ca5509b68c51dc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a43050d35af4a15b420b9af62a33f08d5df6b467", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43050d35af4a15b420b9af62a33f08d5df6b467", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a43050d35af4a15b420b9af62a33f08d5df6b467", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a43050d35af4a15b420b9af62a33f08d5df6b467/comments", "author": null, "committer": null, "parents": [{"sha": "be6aaf7f3d34989e7b5edfac198b3244cb1c9acc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be6aaf7f3d34989e7b5edfac198b3244cb1c9acc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be6aaf7f3d34989e7b5edfac198b3244cb1c9acc"}], "stats": {"total": 143, "additions": 57, "deletions": 86}, "files": [{"sha": "7a9b7f2289d8486fa3eee1a7caf6c298cce99911", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 57, "deletions": 86, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a43050d35af4a15b420b9af62a33f08d5df6b467/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a43050d35af4a15b420b9af62a33f08d5df6b467/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=a43050d35af4a15b420b9af62a33f08d5df6b467", "patch": "@@ -201,7 +201,7 @@ static tree maybe_implicit_deref (tree);\n static tree gnat_stabilize_reference (tree, bool);\n static tree gnat_stabilize_reference_1 (tree, bool);\n static void annotate_with_node (tree, Node_Id);\n-static int takes_address (Node_Id, tree);\n+static int lvalue_required_p (Node_Id, tree, int);\n \f\n /* This is the main program of the back-end.  It sets up all the table\n    structures and then generates code.  */\n@@ -320,6 +320,9 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n \t  end_subprog_body (gnu_body);\n \t}\n     }\n+\n+  /* We cannot track the location of errors past this point.  */\n+  error_gnat_node = Empty;\n }\n \f\n /* Perform initializations for this module.  */\n@@ -336,12 +339,13 @@ gnat_init_stmt_group (void)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n }\n \f\n-/* Returns a positive value if GNAT_NODE denotes an address construction\n-   for an operand of OPERAND_TYPE, zero otherwise.  This is int instead\n-   of bool to facilitate usage in non purely binary logic contexts.  */\n+/* Returns a positive value if GNAT_NODE requires an lvalue for an\n+   operand of OPERAND_TYPE, whose aliasing is specified by ALIASED,\n+   zero otherwise.  This is int instead of bool to facilitate usage\n+   in non purely binary logic contexts.  */\n \n static int\n-takes_address (Node_Id gnat_node, tree operand_type)\n+lvalue_required_p (Node_Id gnat_node, tree operand_type, int aliased)\n {\n   switch (Nkind (gnat_node))\n     {\n@@ -357,6 +361,7 @@ takes_address (Node_Id gnat_node, tree operand_type)\n \t       || id == Attr_Unrestricted_Access;\n       }\n \n+    case N_Parameter_Association:\n     case N_Function_Call:\n     case N_Procedure_Call_Statement:\n       return must_pass_by_ref (operand_type)\n@@ -374,9 +379,21 @@ takes_address (Node_Id gnat_node, tree operand_type)\n \t     gnat_temp = Next (gnat_temp))\n \t  if (Nkind (gnat_temp) != N_Integer_Literal)\n \t    return 1;\n-\treturn takes_address (Parent (gnat_node), operand_type);\n+\taliased |= Has_Aliased_Components (Etype (Prefix (gnat_node)));\n+\treturn lvalue_required_p (Parent (gnat_node), operand_type, aliased);\n       }\n \n+    case N_Selected_Component:\n+      aliased |= Is_Aliased (Entity (Selector_Name (gnat_node)));\n+      return lvalue_required_p (Parent (gnat_node), operand_type, aliased);\n+\n+    case N_Object_Renaming_Declaration:\n+      /* We need to make a real renaming only if the constant object is\n+\t aliased; otherwise we can optimize and return the rvalue.  We\n+\t make an exception if the object is an identifier since in this\n+\t case the rvalue can be propagated attached to the CONST_DECL.  */\n+      return aliased || Nkind (Name (gnat_node)) == N_Identifier;\n+\n     default:\n       return 0;\n     }\n@@ -395,14 +412,14 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   tree gnu_result;\n   Node_Id gnat_temp, gnat_temp_type;\n \n-  /* Whether the parent of gnat_node is taking its address.  Needed in\n-     specific circumstances only, so evaluated lazily. < 0 means unknown,\n+  /* Whether the parent of gnat_node requires an lvalue.  Needed in\n+     specific circumstances only, so evaluated lazily.  < 0 means unknown,\n      > 0 means known true, 0 means known false.  */\n-  int parent_takes_address = -1;\n+  int parent_requires_lvalue = -1;\n \n   /* If GNAT_NODE is a constant, whether we should use the initialization\n      value instead of the constant entity, typically for scalars with an\n-     address clause when the parent is not taking the address.  */\n+     address clause when the parent doesn't require an lvalue.  */\n   bool use_constant_initializer = false;\n \n   /* If the Etype of this node does not equal the Etype of the Entity,\n@@ -474,8 +491,8 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n   gnu_result_type = get_unpadded_type (gnat_temp_type);\n \n   /* If this is a non-imported scalar constant with an address clause,\n-     retrieve the value instead of a pointer to be dereferenced, unless the\n-     parent is taking the address.  This is generally more efficient and\n+     retrieve the value instead of a pointer to be dereferenced unless the\n+     parent requires an lvalue.  This is generally more efficient and\n      actually required if this is a static expression because it might be used\n      in a context where a dereference is inappropriate, such as a case\n      statement alternative or a record discriminant.  There is no possible\n@@ -485,9 +502,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n       && !Is_Imported (gnat_temp)\n       && Present (Address_Clause (gnat_temp)))\n     {\n-      parent_takes_address\n-\t= takes_address (Parent (gnat_node), gnu_result_type);\n-      use_constant_initializer = !parent_takes_address;\n+      parent_requires_lvalue\n+\t= lvalue_required_p (Parent (gnat_node), gnu_result_type,\n+\t\t\t     Is_Aliased (gnat_temp));\n+      use_constant_initializer = !parent_requires_lvalue;\n     }\n \n   if (use_constant_initializer)\n@@ -575,11 +593,10 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \tgnu_result_type = TREE_TYPE (TYPE_FIELDS (gnu_result_type));\n     }\n \n-  /* If we have a constant declaration and it's initializer at hand, return\n-     the latter to avoid the need to call fold in lots of places and the need\n-     of elaboration code if this Id is used as an initializer itself.  Don't\n-     do this if the parent will be taking the address of this object and\n-     there is a corresponding variable to take the address of.  */\n+  /* If we have a constant declaration and its initializer at hand,\n+     try to return the latter to avoid the need to call fold in lots\n+     of places and the need of elaboration code if this Id is used as\n+     an initializer itself.  */\n   if (TREE_CONSTANT (gnu_result)\n       && DECL_P (gnu_result) && DECL_INITIAL (gnu_result))\n     {\n@@ -588,13 +605,14 @@ Identifier_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p)\n \t   ? DECL_CONST_CORRESPONDING_VAR (gnu_result) : gnu_result);\n \n       /* If there is a corresponding variable, we only want to return the CST\n-\t value if the parent is not taking the address.  Evaluate this now if\n+\t value if the parent doesn't require an lvalue.  Evaluate this now if\n \t we have not already done so.  */\n-      if (object && parent_takes_address < 0)\n-\tparent_takes_address\n-\t  = takes_address (Parent (gnat_node), gnu_result_type);\n+      if (object && parent_requires_lvalue < 0)\n+\tparent_requires_lvalue\n+\t  = lvalue_required_p (Parent (gnat_node), gnu_result_type,\n+\t\t\t       Is_Aliased (gnat_temp));\n \n-      if (!object || !parent_takes_address)\n+      if (!object || !parent_requires_lvalue)\n \tgnu_result = DECL_INITIAL (gnu_result);\n     }\n \n@@ -3473,19 +3491,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t   NULL_TREE, void_ftype, NULL_TREE, false, true, true, NULL,\n \t\t   gnat_node));\n \n-\t/* Check for 'Address of a subprogram or function that has\n-\t   a Freeze_Node and whose saved tree is an ADDR_EXPR.  If we have\n-\t   such, return that ADDR_EXPR.  */\n-\tif (attribute == Attr_Address\n-\t    && Nkind (Prefix (gnat_node)) == N_Identifier\n-\t    && (Ekind (Entity (Prefix (gnat_node))) == E_Function\n-\t\t|| Ekind (Entity (Prefix (gnat_node))) == E_Procedure)\n-\t    && Present (Freeze_Node (Entity (Prefix (gnat_node))))\n-\t    && present_gnu_tree (Entity (Prefix (gnat_node)))\n-\t    && (TREE_CODE (get_gnu_tree (Entity (Prefix (gnat_node))))\n-\t\t== TREE_LIST))\n-\t  return TREE_PURPOSE (get_gnu_tree (Entity (Prefix (gnat_node))));\n-\n \tgnu_result = Attribute_to_gnu (gnat_node, &gnu_result_type, attribute);\n       }\n       break;\n@@ -4131,23 +4136,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       /* Unless there is a freeze node, declare the subprogram.  We consider\n \t this a \"definition\" even though we're not generating code for\n \t the subprogram because we will be making the corresponding GCC\n-\t node here.  If there is a freeze node, make a dummy ADDR_EXPR\n-\t so we can take the address of this subprogram before its freeze\n-\t point; we'll fill in the ADDR_EXPR later.  Put that ADDR_EXPR\n-\t into a TREE_LIST that contains space for the value specified\n-\t in an Address clause.  */\n-      if (Freeze_Node (Defining_Entity (Specification (gnat_node))))\n-\tsave_gnu_tree (Defining_Entity (Specification (gnat_node)),\n-\t\t       tree_cons (build1 (ADDR_EXPR,\n-\t\t\t\t\t  build_pointer_type\n-\t\t\t\t\t  (make_node (FUNCTION_TYPE)),\n-\t\t\t\t\t  NULL_TREE),\n-\t\t\t\t  NULL_TREE, NULL_TREE),\n-\t\t       true);\n-      else\n+\t node here. */\n+\n+      if (No (Freeze_Node (Defining_Entity (Specification (gnat_node)))))\n \tgnat_to_gnu_entity (Defining_Entity (Specification (gnat_node)),\n \t\t\t    NULL_TREE, 1);\n-\n       gnu_result = alloc_stmt_list ();\n       break;\n \n@@ -4374,15 +4367,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n       /* Get the value to use as the address and save it as the\n \t equivalent for GNAT_TEMP.  When the object is frozen,\n-\t gnat_to_gnu_entity will do the right thing. We have to handle\n-\t subprograms differently here.  */\n-      if (Ekind (Entity (Name (gnat_node))) == E_Procedure\n-\t  || Ekind (Entity (Name (gnat_node))) == E_Function)\n-\tTREE_VALUE (get_gnu_tree (Entity (Name (gnat_node))))\n-\t  = gnat_to_gnu (Expression (gnat_node));\n-      else\n-\tsave_gnu_tree (Entity (Name (gnat_node)),\n-\t\t       gnat_to_gnu (Expression (gnat_node)), true);\n+\t gnat_to_gnu_entity will do the right thing. */\n+      save_gnu_tree (Entity (Name (gnat_node)),\n+                     gnat_to_gnu (Expression (gnat_node)), true);\n       break;\n \n     case N_Enumeration_Representation_Clause:\n@@ -5383,11 +5370,8 @@ process_freeze_entity (Node_Id gnat_node)\n     = present_gnu_tree (gnat_entity) ? get_gnu_tree (gnat_entity) : 0;\n \n   /* If this entity has an Address representation clause, GNU_OLD is the\n-     address, so discard it here.  The exception is if this is a subprogram.\n-     In that case, GNU_OLD is a TREE_LIST that contains both an address and\n-     the ADDR_EXPR needed to take the address of the subprogram.  */\n-  if (Present (Address_Clause (gnat_entity))\n-      && TREE_CODE (gnu_old) != TREE_LIST)\n+     address, so discard it here. */\n+  if (Present (Address_Clause (gnat_entity)))\n     gnu_old = 0;\n \n   /* Don't do anything for class-wide types they are always\n@@ -5400,12 +5384,12 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Don't do anything for subprograms that may have been elaborated before\n      their freeze nodes.  This can happen, for example because of an inner call\n      in an instance body, or a previous compilation of a spec for inlining\n-     purposes.  ??? Does this still occur?  */\n+     purposes. */\n   if (gnu_old\n       && ((TREE_CODE (gnu_old) == FUNCTION_DECL\n \t   && (Ekind (gnat_entity) == E_Function\n \t       || Ekind (gnat_entity) == E_Procedure))\n-\t  || (TREE_CODE (gnu_old) != TREE_LIST\n+\t  || (gnu_old\n \t      && TREE_CODE (TREE_TYPE (gnu_old)) == FUNCTION_TYPE\n \t      && Ekind (gnat_entity) == E_Subprogram_Type)))\n     return;\n@@ -5418,8 +5402,7 @@ process_freeze_entity (Node_Id gnat_node)\n      freeze node, e.g. while processing the other.  */\n   if (gnu_old\n       && !(TREE_CODE (gnu_old) == TYPE_DECL\n-\t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old)))\n-      && TREE_CODE (gnu_old) != TREE_LIST)\n+\t   && TYPE_IS_DUMMY_P (TREE_TYPE (gnu_old))))\n     {\n       gcc_assert ((IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t\t   && Present (Full_View (gnat_entity))\n@@ -5433,14 +5416,10 @@ process_freeze_entity (Node_Id gnat_node)\n   /* Reset the saved tree, if any, and elaborate the object or type for real.\n      If there is a full declaration, elaborate it and copy the type to\n      GNAT_ENTITY.  Likewise if this is the record subtype corresponding to\n-     a class wide type or subtype.  First handle the subprogram case: there,\n-     we have to set the GNU tree to be the address clause, if any.  */\n-  else if (gnu_old)\n+     a class wide type or subtype. */\n+  if (gnu_old)\n     {\n       save_gnu_tree (gnat_entity, NULL_TREE, false);\n-      if (TREE_CODE (gnu_old) == TREE_LIST && TREE_VALUE (gnu_old))\n-\tsave_gnu_tree (gnat_entity, TREE_VALUE (gnu_old), true);\n-\n       if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n   \t  && Present (Full_View (gnat_entity))\n   \t  && present_gnu_tree (Full_View (gnat_entity)))\n@@ -5477,15 +5456,6 @@ process_freeze_entity (Node_Id gnat_node)\n   else\n     gnu_new = gnat_to_gnu_entity (gnat_entity, gnu_init, 1);\n \n-  /* If this was a subprogram being frozen, we have to update the ADDR_EXPR\n-     we previously made.  Update the operand, then set up to update the\n-     pointers.  */\n-  if (gnu_old && TREE_CODE (gnu_old) == TREE_LIST)\n-    {\n-      TREE_OPERAND (TREE_PURPOSE (gnu_old), 0) = gnu_new;\n-      gnu_old = TREE_TYPE (TREE_PURPOSE (gnu_old));\n-    }\n-\n   /* If we've made any pointers to the old version of this type, we\n      have to update them.  */\n   if (gnu_old)\n@@ -6347,6 +6317,7 @@ maybe_stabilize_reference (tree ref, bool force, bool *success)\n \n   switch (code)\n     {\n+    case CONST_DECL:\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:"}]}