{"sha": "7a87c39c565d48bdf978027c77672de58eeff6fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4N2MzOWM1NjVkNDhiZGY5NzgwMjdjNzc2NzJkZTU4ZWVmZjZmYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-03-01T14:20:17Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-03-01T14:20:17Z"}, "message": "Emit NOPs in the assembly output.\n\nFrom-SVN: r40156", "tree": {"sha": "2384e38fa40b32ba6e07e3f4721b903d5f7d71ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2384e38fa40b32ba6e07e3f4721b903d5f7d71ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a87c39c565d48bdf978027c77672de58eeff6fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a87c39c565d48bdf978027c77672de58eeff6fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a87c39c565d48bdf978027c77672de58eeff6fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a87c39c565d48bdf978027c77672de58eeff6fc/comments", "author": null, "committer": null, "parents": [{"sha": "8cb714352c0a6d8ad639a4f72837434295d03bfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cb714352c0a6d8ad639a4f72837434295d03bfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cb714352c0a6d8ad639a4f72837434295d03bfa"}], "stats": {"total": 99, "additions": 99, "deletions": 0}, "files": [{"sha": "c72d69ed0fac1d3e8f359debff82f1246ada2865", "filename": "gcc/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a87c39c565d48bdf978027c77672de58eeff6fc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a87c39c565d48bdf978027c77672de58eeff6fc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a87c39c565d48bdf978027c77672de58eeff6fc", "patch": "@@ -2,6 +2,9 @@\n \n \t* config/ia64/ia64.c (ia64_hard_regno_rename_ok): Disallow renaming\n \tfrom reg 4 if current_function_calls_setjmp.\n+\t(gen_nop_type): New function.\n+\t(ia64_emit_nops): New function.\n+\t(ia64_reorg): Call it.\n \n \t* reload1.c (eliminate_regs_in_insn): Restrict the special case\n \tcode not to try to optimize adds with anything but a REG destination."}, {"sha": "1b49a5cd60bef3e84131d3b3eca0cdffd246823b", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a87c39c565d48bdf978027c77672de58eeff6fc/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a87c39c565d48bdf978027c77672de58eeff6fc/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=7a87c39c565d48bdf978027c77672de58eeff6fc", "patch": "@@ -4788,6 +4788,8 @@ static void find_best_packet PARAMS ((int *, const struct ia64_packet **,\n static int itanium_reorder PARAMS ((FILE *, rtx *, rtx *, int));\n static void dump_current_packet PARAMS ((FILE *));\n static void schedule_stop PARAMS ((FILE *));\n+static rtx gen_nop_type PARAMS ((enum attr_type));\n+static void ia64_emit_nops PARAMS ((void));\n \n /* Map a bundle number to its pseudo-op.  */\n \n@@ -5998,6 +6000,99 @@ emit_predicate_relation_info ()\n     }\n }\n \n+/* Generate a NOP instruction of type T.  We will never generate L type\n+   nops.  */\n+\n+static rtx\n+gen_nop_type (t)\n+     enum attr_type t;\n+{\n+  switch (t)\n+    {\n+    case TYPE_M:\n+      return gen_nop_m ();\n+    case TYPE_I:\n+      return gen_nop_i ();\n+    case TYPE_B:\n+      return gen_nop_b ();\n+    case TYPE_F:\n+      return gen_nop_f ();\n+    case TYPE_X:\n+      return gen_nop_x ();\n+    default:\n+      abort ();\n+    }\n+}\n+\n+/* After the last scheduling pass, fill in NOPs.  It's easier to do this\n+   here than while scheduling.  */\n+\n+static void\n+ia64_emit_nops ()\n+{\n+  rtx insn;\n+  const struct bundle *b = 0;\n+  int bundle_pos = 0;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      rtx pat;\n+      enum attr_type t;\n+      pat = INSN_P (insn) ? PATTERN (insn) : const0_rtx;\n+      if (GET_CODE (pat) == USE || GET_CODE (pat) == CLOBBER)\n+\tcontinue;\n+      if ((GET_CODE (pat) == UNSPEC && XINT (pat, 1) == 22)\n+\t  || GET_CODE (insn) == CODE_LABEL)\n+\t{\n+\t  if (b)\n+\t    while (bundle_pos < 3)\n+\t      {\n+\t\temit_insn_before (gen_nop_type (b->t[bundle_pos]), insn);\n+\t\tbundle_pos++;\n+\t      }\n+\t  if (GET_CODE (insn) != CODE_LABEL)\n+\t    b = bundle + INTVAL (XVECEXP (pat, 0, 0));\n+\t  else\n+\t    b = 0;\n+\t  bundle_pos = 0;\n+\t  continue;\n+\t}\n+      else if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == 2)\n+\t{\n+\t  int t = INTVAL (XVECEXP (pat, 0, 0));\n+\t  if (b)\n+\t    while (bundle_pos < t)\n+\t      {\n+\t\temit_insn_before (gen_nop_type (b->t[bundle_pos]), insn);\n+\t\tbundle_pos++;\n+\t      }\n+\t  continue;\n+\t}\n+\n+      if (bundle_pos == 3)\n+\tb = 0;\n+\n+      if (b && INSN_P (insn))\n+\t{\n+\t  t = ia64_safe_type (insn);\n+\t  if (t == TYPE_UNKNOWN)\n+\t    continue;\n+\t  while (bundle_pos < 3)\n+\t    {\n+\t      if (t == b->t[bundle_pos]\n+\t\t  || (t == TYPE_A && (b->t[bundle_pos] == TYPE_M\n+\t\t\t\t      || b->t[bundle_pos] == TYPE_I)))\n+\t\tbreak;\n+\n+\t      emit_insn_before (gen_nop_type (b->t[bundle_pos]), insn);\n+\t      bundle_pos++;\n+\t    }\n+\t  if (bundle_pos < 3)\n+\t    bundle_pos++;\n+\t}\n+    }\n+}\n+\n /* Perform machine dependent operations on the rtl chain INSNS.  */\n \n void\n@@ -6022,6 +6117,7 @@ ia64_reorg (insns)\n       /* This relies on the NOTE_INSN_BASIC_BLOCK notes to be in the same\n \t place as they were during scheduling.  */\n       emit_insn_group_barriers (rtl_dump_file, insns);\n+      ia64_emit_nops ();\n     }\n   else\n     emit_all_insn_group_barriers (rtl_dump_file, insns);"}]}