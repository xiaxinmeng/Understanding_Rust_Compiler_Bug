{"sha": "1580fc764423bf89e9b853aaa8c65999e37ccb8b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4MGZjNzY0NDIzYmY4OWU5Yjg1M2FhYThjNjU5OTllMzdjY2I4Yg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-04T11:38:03Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-05-04T12:42:26Z"}, "message": "OpenMP: Support complex/float in && and || reduction\n\nC/C++ permit logical AND and logical OR also with floating-point or complex\narguments by doing an unequal zero comparison; the result is an 'int' with\nvalue one or zero.  Hence, those are also permitted as reduction variable,\neven though it is not the most sensible thing to do.\n\ngcc/c/ChangeLog:\n\n\t* c-typeck.c (c_finish_omp_clauses): Accept float + complex\n\tfor || and && reductions.\n\ngcc/cp/ChangeLog:\n\n\t* semantics.c (finish_omp_reduction_clause): Accept float + complex\n\tfor || and && reductions.\n\ngcc/ChangeLog:\n\n\t* omp-low.c (lower_rec_input_clauses, lower_reduction_clauses): Handle\n\t&& and || with floating-point and complex arguments.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/gomp/clause-1.c: Use 'reduction(&:..)' instead of '...(&&:..)'.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.c-c++-common/reduction-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/reduction-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/reduction-3.c: New test.", "tree": {"sha": "36f6858bdddd10b59525a1dca23df6bd03bb93d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36f6858bdddd10b59525a1dca23df6bd03bb93d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1580fc764423bf89e9b853aaa8c65999e37ccb8b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1580fc764423bf89e9b853aaa8c65999e37ccb8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1580fc764423bf89e9b853aaa8c65999e37ccb8b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1580fc764423bf89e9b853aaa8c65999e37ccb8b/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9174343256c06f7879f480c59203c1615601055c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9174343256c06f7879f480c59203c1615601055c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9174343256c06f7879f480c59203c1615601055c"}], "stats": {"total": 877, "additions": 856, "deletions": 21}, "files": [{"sha": "fdc7bb6125c24c914285b02535cd2337a07e3269", "filename": "gcc/c/c-typeck.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -14097,6 +14097,8 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tcase PLUS_EXPR:\n \t\tcase MULT_EXPR:\n \t\tcase MINUS_EXPR:\n+\t\tcase TRUTH_ANDIF_EXPR:\n+\t\tcase TRUTH_ORIF_EXPR:\n \t\t  break;\n \t\tcase MIN_EXPR:\n \t\t  if (TREE_CODE (type) == COMPLEX_TYPE)\n@@ -14115,14 +14117,6 @@ c_finish_omp_clauses (tree clauses, enum c_omp_region_type ort)\n \t\tcase BIT_IOR_EXPR:\n \t\t  r_name = \"|\";\n \t\t  break;\n-\t\tcase TRUTH_ANDIF_EXPR:\n-\t\t  if (FLOAT_TYPE_P (type))\n-\t\t    r_name = \"&&\";\n-\t\t  break;\n-\t\tcase TRUTH_ORIF_EXPR:\n-\t\t  if (FLOAT_TYPE_P (type))\n-\t\t    r_name = \"||\";\n-\t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}"}, {"sha": "0d590c318fb0d3a5832959eae85c289a53a2b80d", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -6032,6 +6032,8 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n       case PLUS_EXPR:\n       case MULT_EXPR:\n       case MINUS_EXPR:\n+      case TRUTH_ANDIF_EXPR:\n+      case TRUTH_ORIF_EXPR:\n \tpredefined = true;\n \tbreak;\n       case MIN_EXPR:\n@@ -6047,12 +6049,6 @@ finish_omp_reduction_clause (tree c, bool *need_default_ctor, bool *need_dtor)\n \t  break;\n \tpredefined = true;\n \tbreak;\n-      case TRUTH_ANDIF_EXPR:\n-      case TRUTH_ORIF_EXPR:\n-\tif (FLOAT_TYPE_P (type))\n-\t  break;\n-\tpredefined = true;\n-\tbreak;\n       default:\n \tbreak;\n       }"}, {"sha": "26ceaf74b2daa24ce7776a631bcc52464d3e9a18", "filename": "gcc/omp-low.c", "status": "modified", "additions": 81, "deletions": 6, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -6389,6 +6389,11 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t  if (code == MINUS_EXPR)\n \t\t    code = PLUS_EXPR;\n \n+\t\t  /* C/C++ permits FP/complex with || and &&.  */\n+\t\t  bool is_fp_and_or\n+\t\t    = ((code == TRUTH_ANDIF_EXPR || code == TRUTH_ORIF_EXPR)\n+\t\t       && (FLOAT_TYPE_P (TREE_TYPE (new_var))\n+\t\t\t   || TREE_CODE (TREE_TYPE (new_var)) == COMPLEX_TYPE));\n \t\t  tree new_vard = new_var;\n \t\t  if (is_simd && omp_is_reference (var))\n \t\t    {\n@@ -6437,7 +6442,20 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t\t  x = build2 (code, TREE_TYPE (ivar), ivar, x);\n \t\t\t  gimplify_assign (ivar, x, &llist[2]);\n \t\t\t}\n-\t\t      x = build2 (code, TREE_TYPE (ref), ref, ivar);\n+\t\t      tree ivar2 = ivar;\n+\t\t      tree ref2 = ref;\n+\t\t      if (is_fp_and_or)\n+\t\t\t{\n+\t\t\t  tree zero = build_zero_cst (TREE_TYPE (ivar));\n+\t\t\t  ivar2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t\t   integer_type_node, ivar,\n+\t\t\t\t\t\t   zero);\n+\t\t\t  ref2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t\t  integer_type_node, ref, zero);\n+\t\t\t}\n+\t\t      x = build2 (code, TREE_TYPE (ref), ref2, ivar2);\n+\t\t      if (is_fp_and_or)\n+\t\t\tx = fold_convert (TREE_TYPE (ref), x);\n \t\t      ref = build_outer_var_ref (var, ctx);\n \t\t      gimplify_assign (ref, x, &llist[1]);\n \n@@ -6456,8 +6474,22 @@ lower_rec_input_clauses (tree clauses, gimple_seq *ilist, gimple_seq *dlist,\n \t\t      if (is_simd)\n \t\t\t{\n \t\t\t  tree ref = build_outer_var_ref (var, ctx);\n-\n-\t\t\t  x = build2 (code, TREE_TYPE (ref), ref, new_var);\n+\t\t\t  tree new_var2 = new_var;\n+\t\t\t  tree ref2 = ref;\n+\t\t\t  if (is_fp_and_or)\n+\t\t\t    {\n+\t\t\t      tree zero = build_zero_cst (TREE_TYPE (new_var));\n+\t\t\t      new_var2\n+\t\t\t\t= fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t\t   integer_type_node, new_var,\n+\t\t\t\t\t\t   zero);\n+\t\t\t      ref2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t\t      integer_type_node, ref,\n+\t\t\t\t\t\t      zero);\n+\t\t\t    }\n+\t\t\t  x = build2 (code, TREE_TYPE (ref2), ref2, new_var2);\n+\t\t\t  if (is_fp_and_or)\n+\t\t\t    x = fold_convert (TREE_TYPE (new_var), x);\n \t\t\t  ref = build_outer_var_ref (var, ctx);\n \t\t\t  gimplify_assign (ref, x, dlist);\n \t\t\t}\n@@ -7397,13 +7429,32 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp,\n       if (code == MINUS_EXPR)\n         code = PLUS_EXPR;\n \n+      /* C/C++ permits FP/complex with || and &&.  */\n+      bool is_fp_and_or = ((code == TRUTH_ANDIF_EXPR\n+\t\t\t    || code == TRUTH_ORIF_EXPR)\n+\t\t\t   && (FLOAT_TYPE_P (TREE_TYPE (new_var))\n+\t\t\t       || (TREE_CODE (TREE_TYPE (new_var))\n+\t\t\t\t   == COMPLEX_TYPE)));\n       if (count == 1)\n \t{\n \t  tree addr = build_fold_addr_expr_loc (clause_loc, ref);\n \n \t  addr = save_expr (addr);\n \t  ref = build1 (INDIRECT_REF, TREE_TYPE (TREE_TYPE (addr)), addr);\n-\t  x = fold_build2_loc (clause_loc, code, TREE_TYPE (ref), ref, new_var);\n+\t  tree new_var2 = new_var;\n+\t  tree ref2 = ref;\n+\t  if (is_fp_and_or)\n+\t    {\n+\t      tree zero = build_zero_cst (TREE_TYPE (new_var));\n+\t      new_var2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t  integer_type_node, new_var, zero);\n+\t      ref2 = fold_build2_loc (clause_loc, NE_EXPR, integer_type_node,\n+\t\t\t\t      ref, zero);\n+\t    }\n+\t  x = fold_build2_loc (clause_loc, code, TREE_TYPE (new_var2), ref2,\n+\t\t\t       new_var2);\n+\t  if (is_fp_and_or)\n+\t    x = fold_convert (TREE_TYPE (new_var), x);\n \t  x = build2 (OMP_ATOMIC, void_type_node, addr, x);\n \t  OMP_ATOMIC_MEMORY_ORDER (x) = OMP_MEMORY_ORDER_RELAXED;\n \t  gimplify_and_add (x, stmt_seqp);\n@@ -7508,7 +7559,19 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp,\n \t    }\n \t  else\n \t    {\n-\t      x = build2 (code, TREE_TYPE (out), out, priv);\n+\t      tree out2 = out;\n+\t      tree priv2 = priv;\n+\t      if (is_fp_and_or)\n+\t\t{\n+\t\t  tree zero = build_zero_cst (TREE_TYPE (out));\n+\t\t  out2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t  integer_type_node, out, zero);\n+\t\t  priv2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t   integer_type_node, priv, zero);\n+\t\t}\n+\t      x = build2 (code, TREE_TYPE (out2), out2, priv2);\n+\t      if (is_fp_and_or)\n+\t\tx = fold_convert (TREE_TYPE (out), x);\n \t      out = unshare_expr (out);\n \t      gimplify_assign (out, x, &sub_seq);\n \t    }\n@@ -7542,7 +7605,19 @@ lower_reduction_clauses (tree clauses, gimple_seq *stmt_seqp,\n \t}\n       else\n \t{\n-\t  x = build2 (code, TREE_TYPE (ref), ref, new_var);\n+\t  tree new_var2 = new_var;\n+\t  tree ref2 = ref;\n+\t  if (is_fp_and_or)\n+\t    {\n+\t      tree zero = build_zero_cst (TREE_TYPE (new_var));\n+\t      new_var2 = fold_build2_loc (clause_loc, NE_EXPR,\n+\t\t\t\t\t  integer_type_node, new_var, zero);\n+\t      ref2 = fold_build2_loc (clause_loc, NE_EXPR, integer_type_node,\n+\t\t\t\t      ref, zero);\n+\t    }\n+\t  x = build2 (code, TREE_TYPE (ref), ref2, new_var2);\n+\t  if (is_fp_and_or)\n+\t    x = fold_convert (TREE_TYPE (new_var), x);\n \t  ref = build_outer_var_ref (var, ctx);\n \t  gimplify_assign (ref, x, &sub_seq);\n \t}"}, {"sha": "8e7cc950d22a939407c03db3c404914fdeacd242", "filename": "gcc/testsuite/gcc.dg/gomp/clause-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgomp%2Fclause-1.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -56,7 +56,7 @@ foo (int x)\n     ;\n #pragma omp p reduction (|:d) /* { dg-error \"has invalid type for\" } */\n     ;\n-#pragma omp p reduction (&&:d) /* { dg-error \"has invalid type for\" } */\n+#pragma omp p reduction (&:d) /* { dg-error \"has invalid type for\" } */\n     ;\n #pragma omp p copyin (d) /* { dg-error \"must be 'threadprivate'\" } */\n     ;"}, {"sha": "89a4153b0784c65e3b64af2f0354387e48089e6e", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-1.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-1.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -0,0 +1,192 @@\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to a floating-poing\n+   or complex type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a non-integer/non-bool reduction variable is odd but valid.\n+\n+   Test: FP reduction variable + FP array.  */\n+\n+#define N 1024\n+_Complex float rcf[N];\n+_Complex double rcd[N];\n+float rf[N];\n+double rd[N];\n+\n+int\n+reduction_or ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp parallel reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp parallel for reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp parallel for simd reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp parallel loop reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp teams distribute parallel for reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_and ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp parallel reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp parallel for reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp parallel for simd reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp parallel loop reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 0;\n+      rd[i] = 0;\n+      rcf[i] = 0;\n+      rcd[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rf[10] = 1.0;\n+  rd[15] = 1.0;\n+  rcf[10] = 1.0;\n+  rcd[15] = 1.0i;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 1;\n+      rd[i] = 1;\n+      rcf[i] = 1;\n+      rcd[i] = 1;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rf[10] = 0.0;\n+  rd[15] = 0.0;\n+  rcf[10] = 0.0;\n+  rcd[15] = 0.0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "bdcba863767158e465c6317ba09ed3d3ce0347d6", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-2.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-2.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -0,0 +1,192 @@\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to a floating-poing\n+   or complex type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a non-integer/non-bool reduction variable is odd but valid.\n+\n+   Test: FP reduction variable + integer array.  */\n+\n+#define N 1024\n+char rcf[N];\n+short rcd[N];\n+int rf[N];\n+long rd[N];\n+\n+int\n+reduction_or ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp parallel reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp parallel for reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp parallel for simd reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp parallel loop reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  float orf = 0;\n+  double ord = 0;\n+  _Complex float orfc = 0;\n+  _Complex double ordc = 0;\n+\n+  #pragma omp teams distribute parallel for reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_and ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp parallel reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp parallel for reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp parallel for simd reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp parallel loop reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  float andf = 1;\n+  double andd = 1;\n+  _Complex float andfc = 1;\n+  _Complex double anddc = 1;\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 0;\n+      rd[i] = 0;\n+      rcf[i] = 0;\n+      rcd[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rf[10] = 1;\n+  rd[15] = 1;\n+  rcf[10] = 1;\n+  rcd[15] = 1;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 1;\n+      rd[i] = 1;\n+      rcf[i] = 1;\n+      rcd[i] = 1;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rf[10] = 0;\n+  rd[15] = 0;\n+  rcf[10] = 0;\n+  rcd[15] = 0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "0f09aab40eca42acf2e43f0c807f61f925d371c5", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-3.c", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-3.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -0,0 +1,192 @@\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to a floating-poing\n+   or complex type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a non-integer/non-bool reduction variable is odd but valid.\n+\n+   Test: integer reduction variable + FP array.  */\n+\n+#define N 1024\n+_Complex float rcf[N];\n+_Complex double rcd[N];\n+float rf[N];\n+double rd[N];\n+\n+int\n+reduction_or ()\n+{\n+  char orf = 0;\n+  short ord = 0;\n+  int orfc = 0;\n+  long ordc = 0;\n+\n+  #pragma omp parallel reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp parallel for reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp parallel for simd reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp parallel loop reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  char orf = 0;\n+  short ord = 0;\n+  int orfc = 0;\n+  long ordc = 0;\n+\n+  #pragma omp teams distribute parallel for reduction(||: orf)\n+  for (int i=0; i < N; ++i)\n+    orf = orf || rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ord)\n+  for (int i=0; i < N; ++i)\n+    ord = ord || rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(||: orfc)\n+  for (int i=0; i < N; ++i)\n+    orfc = orfc || rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ordc)\n+  for (int i=0; i < N; ++i)\n+    ordc = ordc || rcd[i];\n+\n+  return orf + ord + __real__ orfc + __real__ ordc;\n+}\n+\n+int\n+reduction_and ()\n+{\n+  unsigned char andf = 1;\n+  unsigned short andd = 1;\n+  unsigned int andfc = 1;\n+  unsigned long anddc = 1;\n+\n+  #pragma omp parallel reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp parallel for reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp parallel for simd reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp parallel loop reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  unsigned char andf = 1;\n+  unsigned short andd = 1;\n+  unsigned int andfc = 1;\n+  unsigned long anddc = 1;\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andf)\n+  for (int i=0; i < N; ++i)\n+    andf = andf && rf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: andd)\n+  for (int i=0; i < N; ++i)\n+    andd = andd && rcd[i];\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andfc)\n+  for (int i=0; i < N; ++i)\n+    andfc = andfc && rcf[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: anddc)\n+  for (int i=0; i < N; ++i)\n+    anddc = anddc && rcd[i];\n+\n+  return andf + andd + __real__ andfc + __real__ anddc;\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 0;\n+      rd[i] = 0;\n+      rcf[i] = 0;\n+      rcd[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rf[10] = 1.0;\n+  rd[15] = 1.0;\n+  rcf[10] = 1.0;\n+  rcd[15] = 1.0i;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rf[i] = 1;\n+      rd[i] = 1;\n+      rcf[i] = 1;\n+      rcd[i] = 1;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rf[10] = 0.0;\n+  rd[15] = 0.0;\n+  rcf[10] = 0.0;\n+  rcd[15] = 0.0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}, {"sha": "a465e10ff4f47ef660a5e9a05c677438b5d61c4d", "filename": "libgomp/testsuite/libgomp.c-c++-common/reduction-4.c", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1580fc764423bf89e9b853aaa8c65999e37ccb8b/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Freduction-4.c?ref=1580fc764423bf89e9b853aaa8c65999e37ccb8b", "patch": "@@ -0,0 +1,194 @@\n+/* C / C++'s logical AND and OR operators take any scalar argument\n+   which compares (un)equal to 0 - the result 1 or 0 and of type int.\n+\n+   In this testcase, the int result is again converted to an integer complex\n+   type.\n+\n+   While having a floating-point/complex array element with || and && can make\n+   sense, having a complex reduction variable is odd but valid.\n+\n+   Test: int complex reduction variable + int complex array.  */\n+\n+#define N 1024\n+_Complex char rcc[N];\n+_Complex short rcs[N];\n+_Complex int rci[N];\n+_Complex long long rcl[N];\n+\n+int\n+reduction_or ()\n+{\n+  _Complex char orc = 0;\n+  _Complex short ors = 0;\n+  _Complex int ori = 0;\n+  _Complex long orl = 0;\n+\n+  #pragma omp parallel reduction(||: orc)\n+  for (int i=0; i < N; ++i)\n+    orc = orc || rcl[i];\n+\n+  #pragma omp parallel for reduction(||: ors)\n+  for (int i=0; i < N; ++i)\n+    ors = ors || rci[i];\n+\n+  #pragma omp parallel for simd reduction(||: ori)\n+  for (int i=0; i < N; ++i)\n+    ori = ori || rcs[i];\n+\n+  #pragma omp parallel loop reduction(||: orl)\n+  for (int i=0; i < N; ++i)\n+    orl = orl || rcc[i];\n+\n+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);\n+}\n+\n+int\n+reduction_or_teams ()\n+{\n+  _Complex char orc = 0;\n+  _Complex short ors = 0;\n+  _Complex int ori = 0;\n+  _Complex long orl = 0;\n+\n+  #pragma omp teams distribute parallel for reduction(||: orc)\n+  for (int i=0; i < N; ++i)\n+    orc = orc || rcc[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: ors)\n+  for (int i=0; i < N; ++i)\n+    ors = ors || rcs[i];\n+\n+  #pragma omp teams distribute parallel for reduction(||: ori)\n+  for (int i=0; i < N; ++i)\n+    ori = ori || rci[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(||: orl)\n+  for (int i=0; i < N; ++i)\n+    orl = orl || rcl[i];\n+\n+  return __real__ (orc + ors + ori + orl) + __imag__ (orc + ors + ori + orl);\n+}\n+\n+int\n+reduction_and ()\n+{\n+  _Complex char andc = 1;\n+  _Complex short ands = 1;\n+  _Complex int andi = 1;\n+  _Complex long andl = 1;\n+\n+  #pragma omp parallel reduction(&&: andc)\n+  for (int i=0; i < N; ++i)\n+    andc = andc && rcc[i];\n+\n+  #pragma omp parallel for reduction(&&: ands)\n+  for (int i=0; i < N; ++i)\n+    ands = ands && rcs[i];\n+\n+  #pragma omp parallel for simd reduction(&&: andi)\n+  for (int i=0; i < N; ++i)\n+    andi = andi && rci[i];\n+\n+  #pragma omp parallel loop reduction(&&: andl)\n+  for (int i=0; i < N; ++i)\n+    andl = andl && rcl[i];\n+\n+  return __real__ (andc + ands + andi + andl)\n+\t + __imag__ (andc + ands + andi + andl);\n+}\n+\n+int\n+reduction_and_teams ()\n+{\n+  _Complex char andc = 1;\n+  _Complex short ands = 1;\n+  _Complex int andi = 1;\n+  _Complex long andl = 1;\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andc)\n+  for (int i=0; i < N; ++i)\n+    andc = andc && rcl[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: ands)\n+  for (int i=0; i < N; ++i)\n+    ands = ands && rci[i];\n+\n+  #pragma omp teams distribute parallel for reduction(&&: andi)\n+  for (int i=0; i < N; ++i)\n+    andi = andi && rcs[i];\n+\n+  #pragma omp teams distribute parallel for simd reduction(&&: andl)\n+  for (int i=0; i < N; ++i)\n+    andl = andl && rcc[i];\n+\n+  return __real__ (andc + ands + andi + andl)\n+\t + __imag__ (andc + ands + andi + andl);\n+}\n+\n+int\n+main ()\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rcc[i] = 0;\n+      rcs[i] = 0;\n+      rci[i] = 0;\n+      rcl[i] = 0;\n+    }\n+\n+  if (reduction_or () != 0)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 0)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  rcc[10] = 1.0;\n+  rcs[15] = 1.0i;\n+  rci[10] = 1.0;\n+  rcl[15] = 1.0i;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  for (int i = 0; i < N; ++i)\n+    {\n+      rcc[i] = 1;\n+      rcs[i] = 1i;\n+      rci[i] = 1;\n+      rcl[i] = 1 + 1i;\n+    }\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 4)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 4)\n+    __builtin_abort ();\n+\n+  rcc[10] = 0.0;\n+  rcs[15] = 0.0;\n+  rci[10] = 0.0;\n+  rcl[15] = 0.0;\n+\n+  if (reduction_or () != 4)\n+    __builtin_abort ();\n+  if (reduction_or_teams () != 4)\n+    __builtin_abort ();\n+  if (reduction_and () != 0)\n+    __builtin_abort ();\n+  if (reduction_and_teams () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}"}]}