{"sha": "75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVlMmQxOWJjNzUzMjExMjJjYmU4N2JjNTdhNWQ4MjVkZDJmYzZkZg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2017-07-05T15:32:47Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2017-07-05T15:32:47Z"}, "message": "[ARM] Implement TARGET_FIXED_CONDITION_CODE_REGS\n\nThis patch implements TARGET_FIXED_CONDITION_CODE_REGS on ARM.\n\nWe have two main cases to consider: in Thumb1 code there are no\ncondition code registers, so we simply return false.  For other\ncases we set the the first pointer to CC_REGNUM and the second to\nVFPCC_REGNUM iff generating hard-float code.\n\nRunning the CSiBE benchmark I see a couple of cases (both in the same\nfile) where this feature kicks in, so it's not a major change.\n\n\t* config/arm/arm.c (arm_fixed_condition_code_regs): New function.\n\t(TARGET_FIXED_CONDITION_CODE_REGS): Redefine.\n\nFrom-SVN: r250005", "tree": {"sha": "3dcc7b5ab4cd84f2be1827f4f5bed72e9822c389", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3dcc7b5ab4cd84f2be1827f4f5bed72e9822c389"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75e2d19bc75321122cbe87bc57a5d825dd2fc6df/comments", "author": null, "committer": null, "parents": [{"sha": "d8448c583ef6ce71f2ee46749ee24d0218df6907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d8448c583ef6ce71f2ee46749ee24d0218df6907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d8448c583ef6ce71f2ee46749ee24d0218df6907"}], "stats": {"total": 23, "additions": 23, "deletions": 0}, "files": [{"sha": "41ee99c4af403282adf615f496b778269d64df26", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75e2d19bc75321122cbe87bc57a5d825dd2fc6df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75e2d19bc75321122cbe87bc57a5d825dd2fc6df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "patch": "@@ -1,3 +1,8 @@\n+2017-07-05  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* config/arm/arm.c (arm_fixed_condition_code_regs): New function.\n+\t(TARGET_FIXED_CONDITION_CODE_REGS): Redefine.\n+\n 2017-07-05  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "c6101efd555996a4c6db5eaea0130b0940c4cff8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75e2d19bc75321122cbe87bc57a5d825dd2fc6df/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75e2d19bc75321122cbe87bc57a5d825dd2fc6df/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=75e2d19bc75321122cbe87bc57a5d825dd2fc6df", "patch": "@@ -110,6 +110,7 @@ static void arm_print_operand_address (FILE *, machine_mode, rtx);\n static bool arm_print_operand_punct_valid_p (unsigned char code);\n static const char *fp_const_from_val (REAL_VALUE_TYPE *);\n static arm_cc get_arm_condition_code (rtx);\n+static bool arm_fixed_condition_code_regs (unsigned int *, unsigned int *);\n static const char *output_multi_immediate (rtx *, const char *, const char *,\n \t\t\t\t\t   int, HOST_WIDE_INT);\n static const char *shift_op (rtx, HOST_WIDE_INT *);\n@@ -775,6 +776,9 @@ static const struct attribute_spec arm_attribute_table[] =\n #undef TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n #define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 2\n \n+#undef TARGET_FIXED_CONDITION_CODE_REGS\n+#define TARGET_FIXED_CONDITION_CODE_REGS arm_fixed_condition_code_regs\n+\n \f\n /* Obstack for minipool constant handling.  */\n static struct obstack minipool_obstack;\n@@ -22928,6 +22932,20 @@ get_arm_condition_code (rtx comparison)\n   return code;\n }\n \n+/* Implement TARGET_FIXED_CONDITION_CODE_REGS.  We only have condition\n+   code registers when not targetting Thumb1.  The VFP condition register\n+   only exists when generating hard-float code.  */\n+static bool\n+arm_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n+{\n+  if (!TARGET_32BIT)\n+    return false;\n+\n+  *p1 = CC_REGNUM;\n+  *p2 = TARGET_HARD_FLOAT ? VFPCC_REGNUM : INVALID_REGNUM;\n+  return true;\n+}\n+\n /* Tell arm_asm_output_opcode to output IT blocks for conditionally executed\n    instructions.  */\n void"}]}