{"sha": "4d65a07d54bd9371475648f7de9d4b6a01238813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQ2NWEwN2Q1NGJkOTM3MTQ3NTY0OGY3ZGU5ZDRiNmEwMTIzODgxMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-05T21:56:44Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2021-01-07T21:05:09Z"}, "message": "c++: Add some conversion sanity checking.\n\nAnother change I was working on revealed that for complex numbers we were\nbuilding a ck_identity with build_conv, leading to the wrong active member\nin the union being set.  Rather than add another enumeration of the\nappropriate conversion codes, I factored that out.\n\ngcc/cp/ChangeLog:\n\n\t* call.c (has_next): Factor out from...\n\t(next_conversion): ...here.\n\t(strip_standard_conversion): And here.\n\t(is_subseq): And here.\n\t(build_conv): Check it.\n\t(standard_conversion): Don't call build_conv\n\tfor ck_identity.", "tree": {"sha": "46ff8c9f26c4e7c33581fe5095f936d891205cfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46ff8c9f26c4e7c33581fe5095f936d891205cfe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d65a07d54bd9371475648f7de9d4b6a01238813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d65a07d54bd9371475648f7de9d4b6a01238813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d65a07d54bd9371475648f7de9d4b6a01238813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d65a07d54bd9371475648f7de9d4b6a01238813/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7c3f201be582553f9e3506536aa406bbd7ee71c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7c3f201be582553f9e3506536aa406bbd7ee71c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7c3f201be582553f9e3506536aa406bbd7ee71c"}], "stats": {"total": 37, "additions": 22, "deletions": 15}, "files": [{"sha": "218157088ef2b5befddcfddb45cb28139a689af6", "filename": "gcc/cp/call.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d65a07d54bd9371475648f7de9d4b6a01238813/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d65a07d54bd9371475648f7de9d4b6a01238813/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4d65a07d54bd9371475648f7de9d4b6a01238813", "patch": "@@ -761,12 +761,26 @@ alloc_conversions (size_t n)\n   return (conversion **) conversion_obstack_alloc (n * sizeof (conversion *));\n }\n \n+/* True iff the active member of conversion::u for code CODE is NEXT.  */\n+\n+static inline bool\n+has_next (conversion_kind code)\n+{\n+  return !(code == ck_identity\n+\t   || code == ck_ambig\n+\t   || code == ck_list\n+\t   || code == ck_aggr);\n+}\n+\n static conversion *\n build_conv (conversion_kind code, tree type, conversion *from)\n {\n   conversion *t;\n   conversion_rank rank = CONVERSION_RANK (from);\n \n+  /* Only call this function for conversions that use u.next.  */\n+  gcc_assert (from == NULL || has_next (code));\n+\n   /* Note that the caller is responsible for filling in t->cand for\n      user-defined conversions.  */\n   t = alloc_conversion (code);\n@@ -863,10 +877,7 @@ static conversion *\n next_conversion (conversion *conv)\n {\n   if (conv == NULL\n-      || conv->kind == ck_identity\n-      || conv->kind == ck_ambig\n-      || conv->kind == ck_list\n-      || conv->kind == ck_aggr)\n+      || !has_next (conv->kind))\n     return NULL;\n   return conv->u.next;\n }\n@@ -879,10 +890,7 @@ strip_standard_conversion (conversion *conv)\n {\n   while (conv\n \t && conv->kind != ck_user\n-\t && conv->kind != ck_ambig\n-\t && conv->kind != ck_list\n-\t && conv->kind != ck_aggr\n-\t && conv->kind != ck_identity)\n+\t && has_next (conv->kind))\n     conv = next_conversion (conv);\n   return conv;\n }\n@@ -1266,13 +1274,15 @@ standard_conversion (tree to, tree from, tree expr, bool c_cast_p,\n \t(TREE_TYPE (to), TREE_TYPE (from), NULL_TREE, c_cast_p, flags,\n \t complain);\n \n-      if (part_conv)\n+      if (!part_conv)\n+\tconv = NULL;\n+      else if (part_conv->kind == ck_identity)\n+\t/* Leave conv alone.  */;\n+      else\n \t{\n \t  conv = build_conv (part_conv->kind, to, conv);\n \t  conv->rank = part_conv->rank;\n \t}\n-      else\n-\tconv = NULL;\n \n       return conv;\n     }\n@@ -10619,10 +10629,7 @@ is_subseq (conversion *ics1, conversion *ics2)\n \tics2 = next_conversion (ics2);\n \n       if (ics2->kind == ck_user\n-\t  || ics2->kind == ck_ambig\n-\t  || ics2->kind == ck_aggr\n-\t  || ics2->kind == ck_list\n-\t  || ics2->kind == ck_identity)\n+\t  || !has_next (ics2->kind))\n \t/* At this point, ICS1 cannot be a proper subsequence of\n \t   ICS2.  We can get a USER_CONV when we are comparing the\n \t   second standard conversion sequence of two user conversion"}]}