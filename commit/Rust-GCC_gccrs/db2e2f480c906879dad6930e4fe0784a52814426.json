{"sha": "db2e2f480c906879dad6930e4fe0784a52814426", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIyZTJmNDgwYzkwNjg3OWRhZDY5MzBlNGZlMDc4NGE1MjgxNDQyNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-08-08T09:08:55Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-08-08T09:08:55Z"}, "message": "frame.h (ia64_frame_state): Add my_psp.\n\n        * frame.h (ia64_frame_state): Add my_psp.\n        * libgcc2.c (ia64_throw_helper): Add throw_sp argument.\n        (__throw): Pass it in.  Don't clobber r7.\n        * config/ia64/frame-ia64.c (init_ia64_reg_loc): Mark inline.\n        (execute_one_ia64_descriptor) [mem_stack_v]: Sets psp.when\n        and nothing to do with sp.\n        (normalize_reg_loc): Use frame->my_psp.\n        (frame_translate): Handle frame-pointer-less functions.  Set\n        spill_base correctly, in absence of being told.\n        (__build_ia64_frame_state): New sp argument.  Fill in frame->my_sp.\n        (__ia64_backtrace_helper): New sp argument.  Use\n        builtin_return_address instead of label addresses.\n        (print_record) [mem_stack_v]: No size member.\n\nFrom-SVN: r35565", "tree": {"sha": "a56e49b5ea637aa6a95652c40bb2747a9110ca5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a56e49b5ea637aa6a95652c40bb2747a9110ca5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db2e2f480c906879dad6930e4fe0784a52814426", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2e2f480c906879dad6930e4fe0784a52814426", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db2e2f480c906879dad6930e4fe0784a52814426", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db2e2f480c906879dad6930e4fe0784a52814426/comments", "author": null, "committer": null, "parents": [{"sha": "2a3e384f15e6f10fc62b27c6671d899b083fed97", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a3e384f15e6f10fc62b27c6671d899b083fed97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a3e384f15e6f10fc62b27c6671d899b083fed97"}], "stats": {"total": 170, "additions": 113, "deletions": 57}, "files": [{"sha": "52dbb268080163cf7696ba896410865e3bb7c48b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db2e2f480c906879dad6930e4fe0784a52814426", "patch": "@@ -1,3 +1,23 @@\n+2000-08-08  Richard Henderson  <rth@cygnus.com>\n+\n+\t* frame.h (ia64_frame_state): Add my_psp.\n+\t* libgcc2.c (ia64_throw_helper): Add throw_sp argument.\n+\t(__throw): Pass it in.  Don't clobber r7.\n+\t* config/ia64/frame-ia64.c (init_ia64_reg_loc): Mark inline.\n+\t(execute_one_ia64_descriptor) [mem_stack_v]: Sets psp.when\n+\tand nothing to do with sp.\n+\t(normalize_reg_loc): Use frame->my_psp.\n+\t(frame_translate): Handle frame-pointer-less functions.  Set\n+\tspill_base correctly, in absence of being told.\n+\t(__build_ia64_frame_state): New sp argument.  Fill in frame->my_sp.\n+\t(__ia64_backtrace_helper): New sp argument.  Use\n+\tbuiltin_return_address instead of label addresses.\n+\t(print_record) [mem_stack_v]: No size member.\n+\n+2000-08-08  Richard Henderson  <rth@cygnus.com>\n+\n+\t* regclass.c (choose_hard_reg_mode): Iterate over all CC modes.\n+\n 2000-08-08  Richard Henderson  <rth@cygnus.com>\n \n \t* tm.texi (LOCAL_REGNO): Document."}, {"sha": "efddd9f08bb7957706e87b33af867c1622b635c8", "filename": "gcc/config/ia64/frame-ia64.c", "status": "modified", "additions": 74, "deletions": 39, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Fconfig%2Fia64%2Fframe-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fframe-ia64.c?ref=db2e2f480c906879dad6930e4fe0784a52814426", "patch": "@@ -678,7 +678,7 @@ read_P_record (data, val, ptr, header)\n /* Frame processing routines.  */\n \n /* Initialize a single register structure.  */\n-static void \n+static inline void \n init_ia64_reg_loc (reg, size)\n      ia64_reg_loc *reg;\n      short size;\n@@ -692,7 +692,7 @@ init_ia64_reg_loc (reg, size)\n /* Iniitialize an entire frame to the default of nothing.  */\n static void\n init_ia64_unwind_frame (frame) \n-     ia64_frame_state *frame ;\n+     ia64_frame_state *frame;\n {\n   int x;\n   \n@@ -741,7 +741,7 @@ execute_one_ia64_descriptor (addr, frame, len)\n   *len = -1;\n   addr = get_unwind_record (&region_header, &r, addr);\n \n-  /* process it in 2 phases, the first phase will either do the work,\n+  /* Process it in 2 phases, the first phase will either do the work,\n      or set up a pointer to the records we care about \n      (ie a special purpose ar perhaps, and the second will actually \n      fill in the record.  */\n@@ -787,10 +787,12 @@ execute_one_ia64_descriptor (addr, frame, len)\n \t  break;\n \t}\n       case mem_stack_f:\n-      case mem_stack_v:\n-        frame->sp.when = r.record.p.t; \n \tframe->sp.l.offset = r.record.p.size;\n \tframe->sp.loc_type = IA64_UNW_LOC_TYPE_OFFSET;\n+        frame->sp.when = r.record.p.t; \n+\tbreak;\n+      case mem_stack_v:\n+\tframe->psp.when = r.record.p.t;\n \tbreak;\n       case psp_gr:\n       case psp_sprel:\n@@ -1091,7 +1093,7 @@ normalize_reg_loc (frame, reg)\n       case IA64_UNW_LOC_TYPE_BR:\n         break;\n       case IA64_UNW_LOC_TYPE_SPOFF:\n-        /* offset from the stack pointer, calculate the memory address\n+        /* Offset from the stack pointer, calculate the memory address\n \t   now.  */\n \ttmp = (unsigned char *)frame->my_sp + reg->l.offset * 4;\n \treg->l.mem = tmp;\n@@ -1100,7 +1102,7 @@ normalize_reg_loc (frame, reg)\n       case IA64_UNW_LOC_TYPE_PSPOFF:\n         /* Actualy go get the value of the PSP add the offset, and thats \n \t   the mem location we can find this value at. */\n-\ttmp = (*(unsigned char **)(frame->psp.l.mem)) + 16 - reg->l.offset * 4;\n+\ttmp = (unsigned char *)frame->my_psp + 16 - reg->l.offset * 4;\n \treg->l.mem = tmp;\n \treg->loc_type = IA64_UNW_LOC_TYPE_MEM;\n         break;\n@@ -1114,7 +1116,8 @@ normalize_reg_loc (frame, reg)\n     }\n \n }\n-/* this function looks at a reg_loc and determines if its going\n+\n+/* This function looks at a reg_loc and determines if its going\n    to be an executed record or not between time start and end.  \n    It is executed if it is exectued at START time. It is NOT\n    executed if it happens at END time. */\n@@ -1173,7 +1176,7 @@ copy_reg_value (src, dest)\n   else\n     {\n       void **d;\n-      if (src->reg_size> 16)\n+      if (src->reg_size > 16)\n         abort ();\n       if (dest->loc_type != IA64_UNW_LOC_TYPE_MEM)\n         abort ();\n@@ -1218,7 +1221,9 @@ process_state_between (frame, start, end)\n   /* PSP, RP, SP, and PFS are handled seperately from here. */\n \n   /* GR's, FR's and BR's are saved at an arbitrary point, so we\n-      should handle them at teh very beginning.  */\n+     should handle them at the very beginning.  */\n+  /* ??? Err, no they aren't.  There's the spill_mask record that\n+     tells us when each is processed.  */\n   if (start == 0)\n     {\n       for (x = 0; x < 4 ; x++)\n@@ -1252,25 +1257,52 @@ frame_translate (frame, unwind_time)\n      ia64_frame_state *frame;\n      long unwind_time;\n {\n-  /* First, establish values of PFS and PSP and RP, if needed.  */\n-\n-  normalize_reg_loc (frame, &frame->pfs);\n-  normalize_reg_loc (frame, &frame->psp);\n-  normalize_reg_loc (frame, &frame->rp);\n- \n+  /* ??? Is this supposed to mark the end of the stack?  */\n   if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE)\n     return;\n \n-  /* The stack pointer at the function start is the PSP value\n-     saved away.  */\n-  frame->my_sp = __get_real_reg_value (&frame->psp);\n+  /* At function entry, SP == PSP.  */\n+  frame->my_psp = frame->my_sp;\n+  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_NONE)\n+    {\n+      /* We've saved a frame pointer somewhere.  This will be the\n+\t canonical PSP for the function.  */\n+      normalize_reg_loc (frame, &frame->psp);\n+      if (frame->psp.when < unwind_time)\n+\tframe->my_psp = __get_real_reg_value (&frame->psp);\n+    }\n+  else if (frame->sp.loc_type == IA64_UNW_LOC_TYPE_OFFSET)\n+    {\n+      /* We've a fixed sized stack frame.  The PSP is at a known offset.  */\n+\t\n+      if (frame->sp.when < unwind_time)\n+        frame->my_psp = frame->my_sp + frame->sp.l.offset;\n+    }\n+  /* Otherwise the stack frame size was zero and no adjustment needed.  */\n \n-  if (frame->psp.loc_type != IA64_UNW_LOC_TYPE_MEM)\n-    abort ();\n+  /* Find PFS, RP and the spill base.  All of which might have\n+     addresses based off the PSP computed above.  */\n+  normalize_reg_loc (frame, &frame->pfs);\n+  normalize_reg_loc (frame, &frame->rp);\n \n-  /* spill base is set up off the PSP register, which should now \n-     have its value. */\n-  normalize_reg_loc (frame, &frame->spill_base);\n+  if (frame->spill_base.loc_type != IA64_UNW_LOC_TYPE_NONE)\n+    normalize_reg_loc (frame, &frame->spill_base);\n+  else\n+    {\n+      /* Otherwise we're supposed to infer it from the size of the\n+\t saved GR/BR/FR registers, putting the top at psp+16.  */\n+      long size = 0, i;\n+      for (i = 0; i < 4; ++i)\n+\tif (frame->gr[i].when >= 0)\n+\t  size += 8;\n+      for (i = 0; i < 5; ++i)\n+\tif (frame->br[i].when >= 0)\n+\t  size += 8;\n+      for (i = 0; i < 20; ++i)\n+\tif (frame->fr[i].when >= 0)\n+\t  size += 16;\n+      frame->spill_base.l.mem = frame->my_psp + 16 - size;\n+    }\n \n   /* If the SP is adjusted, process records up to where it\n      is adjusted, then adjust it, then process the rest.  */\n@@ -1279,24 +1311,23 @@ frame_translate (frame, unwind_time)\n       process_state_between (frame, 0, frame->sp.when);\n       if (frame->sp.loc_type != IA64_UNW_LOC_TYPE_OFFSET)\n \tabort ();\n-      frame->my_sp = \n-\t      (unsigned char *)frame->my_sp - frame->sp.l.offset;\n+      frame->my_sp = frame->my_psp - frame->sp.l.offset;\n       process_state_between (frame, frame->sp.when, unwind_time);\n     }\n   else\n     process_state_between (frame, 0, unwind_time);\n }\n \n-/* this function will set a frame_state with all the required fields\n+/* This function will set a frame_state with all the required fields\n    from a functions unwind descriptors.\n    pc is the location we need info up until (ie, the unwind point)\n    frame is the frame_state structure to be set up.\n    Returns a pointer to the unwind info pointer for the frame.  */\n unwind_info_ptr *\n-__build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)\n+__build_ia64_frame_state (pc, frame, bsp, sp, pc_base_ptr)\n      unsigned char *pc;\n      ia64_frame_state *frame;\n-     void *bsp;\n+     void *bsp, *sp;\n      void **pc_base_ptr;\n {\n   long len;\n@@ -1321,8 +1352,9 @@ __build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)\n \n   init_ia64_unwind_frame (frame);\n   frame->my_bsp = bsp;\n+  frame->my_sp = sp;\n \n-  /* stop when we get to the end of the descriptor list, or if we\n+  /* Stop when we get to the end of the descriptor list, or if we\n      encounter a region whose initial offset is already past the\n      PC we are unwinding too.  */\n \n@@ -1336,6 +1368,7 @@ __build_ia64_frame_state (pc, frame, bsp, pc_base_ptr)\n \t  last_region_size = len;\n \t}\n     }\n+\n   /* Now we go get the actual values.  */\n   frame_translate (frame, pc_offset);\n   if (pc_base_ptr)\n@@ -1385,18 +1418,18 @@ __calc_caller_bsp (pfs, bsp)\n }\n \n static int \n-ia64_backtrace_helper (void **array, void *throw_pc, \n-\t\t       ia64_frame_state *throw_frame,\n-\t\t       ia64_frame_state *frame, void *bsp, int size)\n+ia64_backtrace_helper (void **array, ia64_frame_state *throw_frame,\n+\t\t       ia64_frame_state *frame, void *bsp, void *sp, int size)\n {\n+  void *throw_pc = __builtin_return_address (0);\n   void *pc = NULL;\n   int frame_count = 0;\n   unwind_info_ptr *info;\n \n   __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n \n   /* Start at our stack frame, get our state.  */\n-  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, NULL);\n+  info = __build_ia64_frame_state (throw_pc, throw_frame, bsp, sp, NULL);\n \n   *frame = *throw_frame;\n \n@@ -1406,7 +1439,7 @@ ia64_backtrace_helper (void **array, void *throw_pc,\n       --pc;\n       bsp = __calc_caller_bsp \n \t((long)__get_real_reg_value (&frame->pfs), frame->my_bsp);\n-      info = __build_ia64_frame_state (pc, frame, bsp, NULL);\n+      info = __build_ia64_frame_state (pc, frame, bsp, frame->my_psp, NULL);\n       if (frame->rp.loc_type == IA64_UNW_LOC_TYPE_NONE) /* We've finished. */\n \tbreak;\n     }\n@@ -1419,6 +1452,7 @@ ia64_backtrace_helper (void **array, void *throw_pc,\n int\n __ia64_backtrace (void **array, int size)\n {\n+  register void *stack_pointer __asm__(\"r12\");\n   ia64_frame_state my_frame;\n   ia64_frame_state originator;\t/* For the context handler is in.  */\n   void *bsp;\n@@ -1428,11 +1462,10 @@ __ia64_backtrace (void **array, int size)\n      registers. */\n   __builtin_unwind_init ();\n \n-label_ia64:\n   bsp = __builtin_ia64_bsp ();\n   \n-  return ia64_backtrace_helper (array, &&label_ia64, &my_frame, \n-\t\t\t\t&originator, bsp, size);\n+  return ia64_backtrace_helper (array, &my_frame, &originator, bsp,\n+\t\t\t\tstack_pointer, size);\n }\n \n \f\n@@ -1482,10 +1515,12 @@ print_record (f, ptr)\n \t\t\t\t\t\t ptr->record.r.grsave);\n \tbreak;\n       case mem_stack_f:\n-      case mem_stack_v:\n \tfprintf (f, \"(P7) t = %d, size = %d\", ptr->record.p.t, \n \t\t\t\t\t ptr->record.p.size);\n \tbreak;\n+      case mem_stack_v:\n+\tfprintf (f, \"(P7) t = %d\", ptr->record.p.t);\n+\tbreak;\n       case psp_gr:\n       case rp_gr:\n       case pfs_gr:"}, {"sha": "472d358327c6baf465b92f3207b2a72dccfb1342", "filename": "gcc/frame.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Fframe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Fframe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fframe.h?ref=db2e2f480c906879dad6930e4fe0784a52814426", "patch": "@@ -248,6 +248,7 @@ typedef struct ia64_frame_state\n   ia64_reg_loc sp;\n   ia64_reg_loc psp;\n   ia64_reg_loc spill_base;\n+  void *my_psp;\n   void *my_sp;\n   void *my_bsp;\n } ia64_frame_state;\n@@ -267,7 +268,8 @@ typedef struct unwind_info_ptr\n #define IA64_UNW_HDR_VERSION(x)\t(((x) >> 48) & 0xffffUL)\n \n extern unwind_info_ptr *__build_ia64_frame_state (unsigned char *, \n-\t\t\t\t\t\t  ia64_frame_state *, void *,\n+\t\t\t\t\t\t  ia64_frame_state *,\n+\t\t\t\t\t\t  void *, void *,\n \t\t\t\t\t\t  void **);\n extern void *__get_real_reg_value (ia64_reg_loc *);\n extern void *__get_personality (unwind_info_ptr *);"}, {"sha": "616338613811190095d86a5aaceec022f000dd1c", "filename": "gcc/libgcc2.c", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Flibgcc2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db2e2f480c906879dad6930e4fe0784a52814426/gcc%2Flibgcc2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flibgcc2.c?ref=db2e2f480c906879dad6930e4fe0784a52814426", "patch": "@@ -4046,10 +4046,8 @@ __ia64_personality_v1 (void *pc, old_exception_table *table)\n }\n \n static void\n-ia64_throw_helper (throw_frame, caller, throw_bsp)\n-     ia64_frame_state *throw_frame;\n-     ia64_frame_state *caller;\n-     void *throw_bsp;\n+ia64_throw_helper (ia64_frame_state *throw_frame, ia64_frame_state *caller,\n+\t\t   void *throw_bsp, void *throw_sp)\n {\n   void *throw_pc = __builtin_return_address (0);\n   unwind_info_ptr *info;\n@@ -4061,7 +4059,8 @@ ia64_throw_helper (throw_frame, caller, throw_bsp)\n   __builtin_ia64_flushrs ();      /*  Make the local register stacks available.  */\n \n   /* Start at our stack frame, get our state.  */\n-  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, &pc_base);\n+  __build_ia64_frame_state (throw_pc, throw_frame, throw_bsp, throw_sp,\n+\t\t\t    &pc_base);\n \n   /* Now we have to find the proper frame for pc, and see if there\n      is a handler for it. if not, we keep going back frames until\n@@ -4078,8 +4077,10 @@ ia64_throw_helper (throw_frame, caller, throw_bsp)\n       /* We only care about the RP right now, so we dont need to keep\n          any other information about a call frame right now.  */\n       pc = __get_real_reg_value (&caller->rp) - 1;\n-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);\n-      info = __build_ia64_frame_state (pc, caller, bsp, &pc_base);\n+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),\n+\t\t\t       caller->my_bsp);\n+      info = __build_ia64_frame_state (pc, caller, bsp, caller->my_psp,\n+\t\t\t\t       &pc_base);\n \n       /* If we couldn't find the next frame, we lose.  */\n       if (! info)\n@@ -4099,7 +4100,7 @@ ia64_throw_helper (throw_frame, caller, throw_bsp)\n     }\n   \n   if (!handler)\n-   __terminate ();\n+    __terminate ();\n \n   /* Handler is a segment relative address, so we must adjust it here.  */\n   handler += (long) pc_base;\n@@ -4116,8 +4117,9 @@ ia64_throw_helper (throw_frame, caller, throw_bsp)\n   for ( ; frame_count > 0; frame_count--)\n     {\n       pc = __get_real_reg_value (&caller->rp) - 1;\n-      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs), caller->my_bsp);\n-      __build_ia64_frame_state (pc, caller, bsp, &pc_base);\n+      bsp = __calc_caller_bsp ((long)__get_real_reg_value (&caller->pfs),\n+\t\t\t       caller->my_bsp);\n+      __build_ia64_frame_state (pc, caller, bsp, caller->my_psp, &pc_base);\n       /* Any regs that were saved can be put in the throw frame now.  */\n       /* We don't want to copy any saved register from the \n          target destination, but we do want to load up it's frame.  */\n@@ -4130,12 +4132,13 @@ ia64_throw_helper (throw_frame, caller, throw_bsp)\n \n   /* TODO, do we need to do anything to make the values we wrote 'stick'? */\n   /* DO we need to go through the whole loadrs seqeunce?  */\n-\n }\n \n+\n void\n __throw ()\n {\n+  register void *stack_pointer __asm__(\"r12\");\n   struct eh_context *eh = (*get_eh_context) ();\n   ia64_frame_state my_frame;\n   ia64_frame_state originator;\t/* For the context handler is in.  */\n@@ -4149,14 +4152,15 @@ __throw ()\n     __terminate ();\n \n   __builtin_unwind_init ();\n+\n   /* We have to call another routine to actually process the frame \n      information, which will force all of __throw's local registers into\n      backing store.  */\n \n   /* Get the value of ar.bsp while we're here.  */\n \n   bsp = __builtin_ia64_bsp ();\n-  ia64_throw_helper (&my_frame, &originator, bsp);\n+  ia64_throw_helper (&my_frame, &originator, bsp, stack_pointer);\n \n   /* Now we have to fudge the bsp by the amount in our (__throw)\n      frame marker, since the return is going to adjust it by that much. */\n@@ -4166,11 +4170,6 @@ __throw ()\n   offset = (char *)my_frame.my_bsp - (char *)tmp_bsp;\n   tmp_bsp = (char *)originator.my_bsp + offset;\n \n-  /* A throw handler is trated like a  non-local goto, which is architeched\n-     to set the FP (or PSP) in r7 before branching.  gr[0-3] map to \n-     r4-r7, so we want gr[3].  */\n-  __set_real_reg_value (&my_frame.gr[3], __get_real_reg_value (&originator.psp));\n-\n   __builtin_eh_return (tmp_bsp, offset, originator.my_sp);\n \n   /* The return address was already set by throw_helper.  */"}]}