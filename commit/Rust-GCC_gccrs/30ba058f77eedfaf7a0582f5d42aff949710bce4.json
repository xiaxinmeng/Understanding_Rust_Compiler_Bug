{"sha": "30ba058f77eedfaf7a0582f5d42aff949710bce4", "node_id": "C_kwDOANBUbNoAKDMwYmEwNThmNzdlZWRmYWY3YTA1ODJmNWQ0MmFmZjk0OTcxMGJjZTQ", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-23T22:30:29Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2021-11-23T22:36:03Z"}, "message": "Implement -Winfinite-recursion [PR88232].\n\nResolves:\nPR middle-end/88232 - Please implement -Winfinite-recursion\n\ngcc/ChangeLog:\n\n\tPR middle-end/88232\n\t* Makefile.in (OBJS): Add gimple-warn-recursion.o.\n\t* common.opt: Add -Winfinite-recursion.\n\t* doc/invoke.texi (-Winfinite-recursion): Document.\n\t* passes.def (pass_warn_recursion): Schedule a new pass.\n\t* tree-pass.h (make_pass_warn_recursion): Declare.\n\t* gimple-warn-recursion.c: New file.\n\ngcc/c-family/ChangeLog:\n\n\tPR middle-end/88232\n\t* c.opt: Add -Winfinite-recursion.\n\ngcc/testsuite/ChangeLog:\n\n\tPR middle-end/88232\n\t* c-c++-common/attr-used-5.c: Suppress valid warning.\n\t* c-c++-common/attr-used-6.c: Same.\n\t* c-c++-common/attr-used-9.c: Same.\n\t* g++.dg/warn/Winfinite-recursion-2.C: New test.\n\t* g++.dg/warn/Winfinite-recursion-3.C: New test.\n\t* g++.dg/warn/Winfinite-recursion.C: New test.\n\t* gcc.dg/Winfinite-recursion-2.c: New test.\n\t* gcc.dg/Winfinite-recursion.c: New test.", "tree": {"sha": "a2501014a7faf3b5a4dd6a64f1d8ee7a01733904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2501014a7faf3b5a4dd6a64f1d8ee7a01733904"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30ba058f77eedfaf7a0582f5d42aff949710bce4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ba058f77eedfaf7a0582f5d42aff949710bce4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ba058f77eedfaf7a0582f5d42aff949710bce4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ba058f77eedfaf7a0582f5d42aff949710bce4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c59ec55c3459fba619e05ee7f59480b71e85ffd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59ec55c3459fba619e05ee7f59480b71e85ffd7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59ec55c3459fba619e05ee7f59480b71e85ffd7"}], "stats": {"total": 893, "additions": 890, "deletions": 3}, "files": [{"sha": "a4344d67f4448c8c023f77d3e747844e4cb4bda8", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -1420,6 +1420,7 @@ OBJS = \\\n \tgimple-streamer-in.o \\\n \tgimple-streamer-out.o \\\n \tgimple-walk.o \\\n+\tgimple-warn-recursion.o \\\n \tgimplify.o \\\n \tgimplify-me.o \\\n \tgodump.o \\"}, {"sha": "4b8a094b20697b469b9f8e799d85af1cacf4e808", "filename": "gcc/c-family/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fc-family%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fc-family%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc.opt?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -738,6 +738,10 @@ Wincompatible-pointer-types\n C ObjC Var(warn_incompatible_pointer_types) Init(1) Warning\n Warn when there is a conversion between pointers that have incompatible types.\n \n+Winfinite-recursion\n+C ObjC C++ LTO ObjC++ Var(warn_infinite_recursion) Warning LangEnabledBy(C ObjC C++ LTO ObjC++, Wall)\n+Warn for infinitely recursive calls.\n+\n Waddress-of-packed-member\n C ObjC C++ ObjC++ Var(warn_address_of_packed_member) Init(1) Warning\n Warn when the address of packed member of struct or union is taken."}, {"sha": "755e1a233b7ac51f071e3648bc0761deef877f06", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -636,6 +636,10 @@ Wimplicit-fallthrough=\n Common Var(warn_implicit_fallthrough) RejectNegative Joined UInteger Warning IntegerRange(0, 5)\n Warn when a switch case falls through.\n \n+Winfinite-recursion\n+Var(warn_infinite_recursion) Warning\n+Warn for infinitely recursive calls.\n+\n Winline\n Common Var(warn_inline) Warning Optimization\n Warn when an inlined function cannot be inlined."}, {"sha": "36fe96b441b3eb5e17e07b1e78404ed58ee017d0", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -359,6 +359,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wignored-qualifiers  -Wno-incompatible-pointer-types @gol\n -Wimplicit  -Wimplicit-fallthrough  -Wimplicit-fallthrough=@var{n} @gol\n -Wno-implicit-function-declaration  -Wno-implicit-int @gol\n+-Winfinite-recursion @gol\n -Winit-self  -Winline  -Wno-int-conversion  -Wint-in-bool-context @gol\n -Wno-int-to-pointer-cast  -Wno-invalid-memory-model @gol\n -Winvalid-pch  -Wjump-misses-init  -Wlarger-than=@var{byte-size} @gol\n@@ -6194,6 +6195,14 @@ is only active when @option{-fdelete-null-pointer-checks} is active,\n which is enabled by optimizations in most targets.  The precision of\n the warnings depends on the optimization options used.\n \n+@item -Winfinite-recursion\n+@opindex Winfinite-recursion\n+@opindex Wno-infinite-recursion\n+Warn about infinitely recursive calls.  The warning is effective at all\n+optimization levels but requires optimization in order to detect infinite\n+recursion in calls between two or more functions.\n+@option{-Winfinite-recursion} is included in @option{-Wall}.\n+\n @item -Winit-self @r{(C, C++, Objective-C and Objective-C++ only)}\n @opindex Winit-self\n @opindex Wno-init-self"}, {"sha": "4dc61b08c50c6571249c596324b0070ca5dddd77", "filename": "gcc/gimple-warn-recursion.c", "status": "added", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fgimple-warn-recursion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fgimple-warn-recursion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-warn-recursion.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,202 @@\n+/* -Winfinite-recursion support.\n+   Copyright (C) 2021 Free Software Foundation, Inc.\n+   Contributed by Martin Sebor <msebor@redhat.com>\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"ssa.h\"\n+#include \"diagnostic-core.h\"\n+// #include \"tree-dfa.h\"\n+#include \"attribs.h\"\n+#include \"gimple-iterator.h\"\n+\n+namespace {\n+\n+const pass_data warn_recursion_data =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"*infinite-recursion\", /* name */\n+  OPTGROUP_NONE, /* optinfo_flags */\n+  TV_NONE, /* tv_id */\n+  PROP_ssa, /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_warn_recursion : public gimple_opt_pass\n+{\n+public:\n+  pass_warn_recursion (gcc::context *);\n+\n+private:\n+  virtual bool gate (function *) { return warn_infinite_recursion; }\n+\n+  virtual unsigned int execute (function *);\n+\n+  bool find_function_exit (basic_block);\n+\n+  /* Recursive calls found in M_FUNC.  */\n+  vec<gimple *> *m_calls;\n+  /* Basic blocks already visited in the current function.  */\n+  bitmap m_visited;\n+  /* The current function.  */\n+  function *m_func;\n+  /* The current function code if it's (also) a built-in.  */\n+  built_in_function m_built_in;\n+  /* True if M_FUNC is a noreturn function.  */\n+  bool noreturn_p;\n+};\n+\n+/* Initialize the pass and its members.  */\n+\n+pass_warn_recursion::pass_warn_recursion (gcc::context *ctxt)\n+  : gimple_opt_pass (warn_recursion_data, ctxt),\n+    m_calls (), m_visited (), m_func (), m_built_in (), noreturn_p ()\n+{\n+}\n+\n+/* Return true if there is path from BB to M_FUNC exit point along which\n+   there is no (recursive) call to M_FUNC.  */\n+\n+bool\n+pass_warn_recursion::find_function_exit (basic_block bb)\n+{\n+  if (!bitmap_set_bit (m_visited, bb->index))\n+    return false;\n+\n+  if (bb == EXIT_BLOCK_PTR_FOR_FN (m_func))\n+    return true;\n+\n+  /* Iterate over statements in BB, looking for a call to FNDECL.  */\n+  for (auto si = gsi_start_bb (bb); !gsi_end_p (si); gsi_next_nondebug (&si))\n+    {\n+      gimple *stmt = gsi_stmt (si);\n+      if (!is_gimple_call (stmt))\n+\tcontinue;\n+\n+      if (gimple_call_builtin_p (stmt, BUILT_IN_LONGJMP))\n+\t/* A longjmp breaks infinite recursion.  */\n+\treturn true;\n+\n+      if (tree fndecl = gimple_call_fndecl (stmt))\n+\t{\n+\t  /* A throw statement breaks infinite recursion.  */\n+\t  tree id = DECL_NAME (fndecl);\n+\t  const char *name = IDENTIFIER_POINTER (id);\n+\t  if (startswith (name, \"__cxa_throw\"))\n+\t    return true;\n+\t  /* As does a call to POSIX siglongjmp.  */\n+\t  if (!strcmp (name, \"siglongjmp\"))\n+\t    return true;\n+\n+\t  if (m_built_in && gimple_call_builtin_p (stmt, BUILT_IN_NORMAL)\n+\t      && m_built_in == DECL_FUNCTION_CODE (fndecl))\n+\t    {\n+\t      /* The call is being made from the definition of a built-in\n+\t\t (e.g., in a replacement of one) to itself.  */\n+\t      m_calls->safe_push (stmt);\n+\t      return false;\n+\t    }\n+\t}\n+\n+      if (noreturn_p)\n+\t{\n+\t  /* A noreturn call breaks infinite recursion.  */\n+\t  int flags = gimple_call_flags (stmt);\n+\t  if (flags & ECF_NORETURN)\n+\t    return true;\n+\t}\n+\n+      tree callee = gimple_call_fndecl (stmt);\n+      if (!callee || m_func->decl != callee)\n+\tcontinue;\n+\n+      /* Add the recursive call to the vector and return false.  */\n+      m_calls->safe_push (stmt);\n+      return false;\n+    }\n+\n+  /* If no call to FNDECL has been found search all BB's successors.  */\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if (find_function_exit (e->dest))\n+      return true;\n+\n+  return false;\n+}\n+\n+\n+/* Search FUNC for unconditionally infinitely recursive calls to self\n+   and issue a warning if it is such a function.  */\n+\n+unsigned int\n+pass_warn_recursion::execute (function *func)\n+{\n+  auto_bitmap visited;\n+  auto_vec<gimple *> calls;\n+\n+  m_visited = visited;\n+  m_calls = &calls;\n+  m_func = func;\n+\n+  /* Avoid diagnosing an apparently infinitely recursive function that\n+     doesn't return where the infinite recursion might be avoided by\n+     a call to another noreturn function.  */\n+  noreturn_p = lookup_attribute (\"noreturn\", DECL_ATTRIBUTES (m_func->decl));\n+\n+  if (fndecl_built_in_p (m_func->decl, BUILT_IN_NORMAL))\n+    m_built_in = DECL_FUNCTION_CODE (m_func->decl);\n+  else\n+    m_built_in = BUILT_IN_NONE;\n+\n+  basic_block entry_bb = ENTRY_BLOCK_PTR_FOR_FN (func);\n+\n+  if (find_function_exit (entry_bb) || m_calls->length () == 0)\n+    return 0;\n+\n+  if (warning_at (DECL_SOURCE_LOCATION (func->decl),\n+\t\t  OPT_Winfinite_recursion,\n+\t\t  \"infinite recursion detected\"))\n+    for (auto stmt: *m_calls)\n+      {\n+\tlocation_t loc = gimple_location (stmt);\n+\tif (loc == UNKNOWN_LOCATION)\n+\t  continue;\n+\n+\tinform (loc, \"recursive call\");\n+      }\n+\n+  return 0;\n+}\n+\n+} // namespace\n+\n+gimple_opt_pass *\n+make_pass_warn_recursion (gcc::context *ctxt)\n+{\n+  return new pass_warn_recursion (ctxt);\n+}"}, {"sha": "37ea0d318d11eb8e2d201cf23c5764a4ba7693e7", "filename": "gcc/passes.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -71,6 +71,7 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_rebuild_cgraph_edges);\n       NEXT_PASS (pass_local_fn_summary);\n       NEXT_PASS (pass_early_inline);\n+      NEXT_PASS (pass_warn_recursion);\n       NEXT_PASS (pass_all_early_optimizations);\n       PUSH_INSERT_PASSES_WITHIN (pass_all_early_optimizations)\n \t  NEXT_PASS (pass_remove_cgraph_callee_edges);"}, {"sha": "7ba5a455706fcbfe30ff72bd14e7b1e3844b5662", "filename": "gcc/testsuite/c-c++-common/attr-used-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-5.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"non-ELF target\" { *-*-darwin* } } */\n-/* { dg-options \"-Wall -O2\" } */\n+/* { dg-options \"-Wall -Wno-infinite-recursion -O2\" } */\n \n struct dtv_slotinfo_list\n {"}, {"sha": "00b128205b6364db075664252e484574223e25e4", "filename": "gcc/testsuite/c-c++-common/attr-used-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-6.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"non-ELF target\" { *-*-darwin* } } */\n-/* { dg-options \"-Wall -O2\" } */\n+/* { dg-options \"-Wall  -Wno-infinite-recursion -O2\" } */\n \n struct dtv_slotinfo_list\n {"}, {"sha": "c4d86c19bc506b08861aa9b80987ec15a065bdc6", "filename": "gcc/testsuite/c-c++-common/attr-used-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattr-used-9.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -1,6 +1,6 @@\n /* { dg-do compile } */\n /* { dg-skip-if \"non-ELF target\" { *-*-darwin* } } */\n-/* { dg-options \"-Wall -O2\" } */\n+/* { dg-options \"-Wall -Wno-infinite-recursion -O2\" } */\n \n struct dtv_slotinfo_list\n {"}, {"sha": "b310283666496ff3e9393764b9ccbdea9e340732", "filename": "gcc/testsuite/g++.dg/warn/Winfinite-recursion-2.C", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-2.C?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,75 @@\n+/* PR middle-end/88232 - Please implement -Winfinite-recursion\n+   Test case from PR 87742 (see PR 88232, comment 2.\n+   { dg-do compile { target c++11 } }\n+   { dg-options \"-Wall -Winfinite-recursion\" } */\n+\n+namespace std\n+{\n+class type_info {\n+public:\n+  void k() const;\n+};\n+\n+} // namespace std\n+\n+using std::type_info;\n+\n+template <int a> struct f { static constexpr int c = a; };\n+struct h {\n+  typedef int e;\n+};\n+\n+template <unsigned long, typename...> struct m;\n+template <unsigned long ab, typename i, typename j, typename... ac>\n+struct m<ab, i, j, ac...> : m<ab + 1, i, ac...> {};\n+template <unsigned long ab, typename j, typename... ac>\n+struct m<ab, j, j, ac...> : f<ab> {};\n+template <unsigned long, typename...> struct n;\n+template <unsigned long ab, typename j, typename... ac>\n+struct n<ab, j, ac...> : n<ab - 1, ac...> {};\n+template <typename j, typename... ac> struct n<0, j, ac...> : h {};\n+template <typename... l> class F {\n+  template <typename i> struct I : m<0, i, l...> {};\n+  template <int ab> struct s : n<ab, l...> {};\n+  static const type_info *const b[];\n+  struct G {\n+    template <typename ag>\n+    operator ag() const       // { dg-warning \"-Winfinite-recursion\" }\n+    {\n+      return *this;\n+    }\n+  };\n+  unsigned o;\n+  G ah;\n+\n+public:\n+  F();\n+  long t() const { return o; }\n+  const type_info &m_fn3() const { return *b[o]; }\n+  template <int ab> typename s<ab>::e *m_fn4() const {\n+    if (o != ab)\n+      return nullptr;\n+    return ah;\n+  }\n+  template <int ab> void m_fn5() const {\n+    m_fn4<ab>();\n+    const type_info &r = m_fn3();\n+    r.k();\n+  }\n+  template <typename i> void u() const { m_fn5<I<i>::c>(); }\n+};\n+template <typename... l> const type_info *const F<l...>::b[] {&typeid(l)...};\n+using am = unsigned char;\n+class H {\n+  enum bd : am { be = 2 };\n+  using bf = F<int, int, H>;\n+  bf ah;\n+  template <typename bg> void v() const { ah.u<bg>(); }\n+  void w() const;\n+};\n+void H::w() const {\n+  bd d = bd(ah.t());\n+  switch (d)\n+  case be:\n+    v<H>();\n+}"}, {"sha": "166e6d5790d0dbab7b12fca6119d2bb1c52ffb78", "filename": "gcc/testsuite/g++.dg/warn/Winfinite-recursion-3.C", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion-3.C?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,77 @@\n+/* PR middle-end/88232 - Please implement -Winfinite-recursion\n+   { dg-do compile }\n+   { dg-options \"-Wall -Winfinite-recursion\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+/* Might throw.  */\n+void f ();\n+\n+/* Verify a warning is issued even though a call to f() might throw,\n+   breaking the infinite recursion.  */\n+\n+void warn_f_call_r (int  n)   // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  if (n > 7)\n+    f ();\n+  warn_f_call_r (n - 1);      // { dg-message \"recursive call\" }\n+}\n+\n+void warn_f_do_while_call_r (int n)    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  f ();\n+  do\n+    {\n+      f ();\n+      warn_f_do_while_call_r (n - 1);  // { dg-message \"recursive call\" }\n+    }\n+  while (1);\n+}\n+\n+\n+struct X\n+{\n+  X (int);\n+  ~X ();\n+};\n+\n+/* Verify a warning even though the X ctor might throw, breaking\n+   the recursion.  Using possible throwing to suppress the warning\n+   would make it pretty much useless in C++.  */\n+\n+int warn_class_with_ctor (int n)    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  X x (n);\n+  return n + warn_class_with_ctor (n - 1);\n+}\n+\n+\n+int nowarn_throw (int n)\n+{\n+  if (n > 7)\n+    throw \"argument too big\";\n+\n+  return n + nowarn_throw (n - 1);\n+}\n+\n+\n+/* Verify call operator new doesn't suppress the warning even though\n+   it might throw.  */\n+\n+extern int* eipa[];\n+\n+void warn_call_new (int i)          // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  eipa[i] = new int;\n+\n+  warn_call_new (i - 1);\n+}\n+\n+/* Verify a recursive call to operator new.  */\n+\n+void* operator new[] (size_t n)     // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  char *p = new char[n + sizeof (n)];   // { dg-message \"recursive call\" }\n+  *(size_t*)p = n;\n+  return p + sizeof n;\n+}"}, {"sha": "faf0984eeb4b7d538c6d84514265d69cec0dd6f0", "filename": "gcc/testsuite/g++.dg/warn/Winfinite-recursion.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWinfinite-recursion.C?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,34 @@\n+/* PR middle-end/88232 - Please implement -Winfinite-recursion\n+   { dg-do compile }\n+   { dg-options \"-Wall -Winfinite-recursion\" } */\n+\n+template <typename D>\n+struct C\n+{\n+  void foo ()                       // { dg-warning \"-Winfinite-recursion\" }\n+  {\n+    static_cast<D *>(this)->foo ();\n+  }\n+};\n+\n+struct D : C<D>\n+{\n+  // this is missing:\n+  // void foo() {}\n+};\n+\n+void f (D *d)\n+{\n+  d->foo ();\n+}\n+\n+\n+struct E : C<D>\n+{\n+  void foo() {}\n+};\n+\n+void g (E *e)\n+{\n+  e->foo ();\n+}"}, {"sha": "23483122a6b053a42cddeb18ab6da6b147925f5b", "filename": "gcc/testsuite/gcc.dg/Winfinite-recursion-2.c", "status": "added", "additions": 252, "deletions": 0, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion-2.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,252 @@\n+/* PR middle-end/88232 - Please implement -Winfinite-recursion\n+   Exercise warning with optimization.  Same as -Winfinite-recursion.c\n+   plus mutually recursive calls that depend on inlining.\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Winfinite-recursion\" } */\n+\n+#define NORETURN __attribute__ ((noreturn))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+extern int ei;\n+int (*pfi_v)(void);\n+\n+\n+/* Make sure the warning doesn't assume every call has a DECL.  */\n+\n+int nowarn_pfi_v (void)\n+{\n+  return pfi_v ();\n+}\n+\n+\n+int warn_fi_v (void)                // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  return warn_fi_v ();              // { dg-message \"recursive call\" }\n+}\n+\n+/* Verify #pragma suppression works.  */\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Winfinite-recursion\"\n+\n+int suppress_warn_fi_v (void)\n+{\n+  return warn_fi_v ();\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+int nowarn_fi_v (void)\n+{\n+  if (ei++ == 0)\n+    return nowarn_fi_v ();\n+  return 0;\n+}\n+\n+\n+int warn_if_i (int i)               // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  if (i > 0)\n+    return warn_if_i (--i);         // { dg-message \"recursive call\" }\n+  else if (i < 0)\n+    return warn_if_i (-i);          // { dg-message \"recursive call\" }\n+  else\n+    return warn_if_i (7);           // { dg-message \"recursive call\" }\n+}\n+\n+\n+int nowarn_if_i (int i)\n+{\n+  if (i > 0)\n+    return nowarn_if_i (--i);\n+  else if (i < 0)\n+    return nowarn_if_i (-i);\n+  else\n+    return -1;\n+}\n+\n+int nowarn_switch (int i, int a[])\n+{\n+  switch (i)\n+    {\n+    case 0: return nowarn_switch (a[3], a + 1);\n+    case 1: return nowarn_switch (a[5], a + 2);\n+    case 2: return nowarn_switch (a[7], a + 3);\n+    case 3: return nowarn_switch (a[9], a + 4);\n+    }\n+  return 77;\n+}\n+\n+int warn_switch (int i, int a[])    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  switch (i)\n+    {\n+    case 0: return warn_switch (a[3], a + 1);\n+    case 1: return warn_switch (a[5], a + 2);\n+    case 2: return warn_switch (a[7], a + 3);\n+    case 3: return warn_switch (a[9], a + 4);\n+    default: return warn_switch (a[1], a + 5);\n+    }\n+}\n+\n+NORETURN void fnoreturn (void);\n+\n+/* Verify there's no warning for a function that doesn't return.  */\n+int nowarn_call_noret (void)\n+{\n+  fnoreturn ();\n+}\n+\n+int warn_call_noret_r (void)        // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  warn_call_noret_r ();             // { dg-message \"recursive call\" }\n+  fnoreturn ();\n+}\n+\n+/* Verify a warning even though the abort() call would prevent the infinite\n+   recursion.  There's no good way to tell the two cases apart and letting\n+   a simple abort prevent the warning would make it ineffective in cases\n+   where it's the result of assert() expansion and not meant to actually\n+   prevent recursion.  */\n+\n+int\n+warn_noret_call_abort_r (char *s, int n)  // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  if (!s)\n+    abort ();\n+\n+  if (n > 7)\n+    abort ();\n+\n+  return n + warn_noret_call_abort_r (s, n - 1);  // { dg-message \"recursive call\" }\n+}\n+\n+/* Verify that a warning is not issued for an apparently infinitely\n+   recursive function like the one above where the recursion would be\n+   prevented by a call to a noreturn function if the recursive function\n+   is itself declared noreturn.  */\n+\n+NORETURN void nowarn_noret_call_abort_r (int n)\n+{\n+  if (n > 7)\n+    abort ();\n+\n+  nowarn_noret_call_abort_r (n - 1);\n+}\n+\n+int warn_call_abort_r (int n)       // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_abort_r (n - 1);   // { dg-message \"recursive call\" }\n+  if (n > 7)   // unreachable\n+    abort ();\n+  return n;\n+}\n+\n+\n+/* And again with exit() for good measure.  */\n+\n+int warn_call_exit_r (int n)        // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_exit_r (n - 1);    // { dg-message \"recursive call\" }\n+  if (n > 7)\n+    exit (0);\n+  return n;\n+}\n+\n+struct __jmp_buf_tag { };\n+typedef struct __jmp_buf_tag jmp_buf[1];\n+\n+extern jmp_buf jmpbuf;\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_longjmp_r (int n)\n+{\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n + nowarn_call_longjmp_r (n - 1);\n+}\n+\n+int warn_call_longjmp_r (int n)     // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_longjmp_r (n - 1); // { dg-message \"recursive call\" }\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n;\n+}\n+\n+\n+struct __sigjmp_buf_tag { };\n+typedef struct __sigjmp_buf_tag sigjmp_buf[1];\n+\n+extern sigjmp_buf sigjmpbuf;\n+\n+/* GCC has no __builtin_siglongjmp().  */\n+extern void siglongjmp (sigjmp_buf, int);\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_siglongjmp_r (int n)\n+{\n+  if (n > 7)\n+    siglongjmp (sigjmpbuf, 1);\n+  return n + nowarn_call_siglongjmp_r (n - 1);\n+}\n+\n+\n+int nowarn_while_do_call_r (int n)\n+{\n+  int z = 0;\n+  while (n)\n+    z += nowarn_while_do_call_r (n--);\n+  return z;\n+}\n+\n+int warn_do_while_call_r (int n)    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  int z = 0;\n+  do\n+    z += warn_do_while_call_r (n);  // { dg-message \"recursive call\" }\n+  while (--n);\n+  return z;\n+}\n+\n+\n+/* Verify warnings for a naive replacement of a built-in fucntion.  */\n+\n+void* malloc (size_t n)             // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  size_t *p =\n+    (size_t*)__builtin_malloc (n + sizeof n);   // { dg-message \"recursive call\" }\n+  *p = n;\n+  return p + 1;\n+}\n+\n+\n+int nowarn_fact (int n)\n+{\n+  return n ? n * nowarn_fact (n - 1) : 1;\n+}\n+\n+\n+static int fi_v (void);\n+\n+/* It would seem preferable to issue the warning for the extern function\n+   but as it happens it's the static function that's inlined into a recursive\n+   call to itself and warn_call_fi_v() expands to a call to it.  */\n+\n+int warn_call_fi_v (void)     // { dg-warning \"-Winfinite-recursion\" \"\" { xfail *-*-* } }\n+{\n+  return fi_v ();             // { dg-message \"recursive call\" }\n+}\n+\n+static int fi_v (void)        // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  return warn_call_fi_v ();\n+}"}, {"sha": "e3253567d34533bab486fdddbd8c9cbdc91456f7", "filename": "gcc/testsuite/gcc.dg/Winfinite-recursion.c", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWinfinite-recursion.c?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -0,0 +1,227 @@\n+/* PR middle-end/88232 - Please implement -Winfinite-recursion\n+   Verify simple cases without optimization.\n+   { dg-do compile }\n+   { dg-options \"-Wall -Winfinite-recursion\" } */\n+\n+#define NORETURN __attribute__ ((noreturn))\n+\n+typedef __SIZE_TYPE__ size_t;\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+extern int ei;\n+int (*pfi_v)(void);\n+\n+\n+/* Make sure the warning doesn't assume every call has a DECL.  */\n+\n+int nowarn_pfi_v (void)\n+{\n+  return pfi_v ();\n+}\n+\n+\n+int warn_fi_v (void)                // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  return warn_fi_v ();              // { dg-message \"recursive call\" }\n+}\n+\n+/* Verify #pragma suppression works.  */\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Winfinite-recursion\"\n+\n+int suppress_warn_fi_v (void)\n+{\n+  return warn_fi_v ();\n+}\n+\n+#pragma GCC diagnostic pop\n+\n+\n+int nowarn_fi_v (void)\n+{\n+  if (ei++ == 0)\n+    return nowarn_fi_v ();\n+  return 0;\n+}\n+\n+int warn_if_i (int i)               // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  if (i > 0)\n+    return warn_if_i (--i);         // { dg-message \"recursive call\" }\n+  else if (i < 0)\n+    return warn_if_i (-i);          // { dg-message \"recursive call\" }\n+  else\n+    return warn_if_i (7);           // { dg-message \"recursive call\" }\n+}\n+\n+\n+int nowarn_if_i (int i)\n+{\n+  if (i > 0)\n+    return nowarn_if_i (--i);\n+  else if (i < 0)\n+    return nowarn_if_i (-i);\n+  else\n+    return -1;\n+}\n+\n+int nowarn_switch (int i, int a[])\n+{\n+  switch (i)\n+    {\n+    case 0: return nowarn_switch (a[3], a + 1);\n+    case 1: return nowarn_switch (a[5], a + 2);\n+    case 2: return nowarn_switch (a[7], a + 3);\n+    case 3: return nowarn_switch (a[9], a + 4);\n+    }\n+  return 77;\n+}\n+\n+int warn_switch (int i, int a[])    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  switch (i)\n+    {\n+    case 0: return warn_switch (a[3], a + 1);\n+    case 1: return warn_switch (a[5], a + 2);\n+    case 2: return warn_switch (a[7], a + 3);\n+    case 3: return warn_switch (a[9], a + 4);\n+    default: return warn_switch (a[1], a + 5);\n+    }\n+}\n+\n+NORETURN void fnoreturn (void);\n+\n+/* Verify there's no warning for a function that doesn't return.  */\n+int nowarn_call_noret (void)\n+{\n+  fnoreturn ();\n+}\n+\n+int warn_call_noret_r (void)        // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  warn_call_noret_r ();             // { dg-message \"recursive call\" }\n+  fnoreturn ();\n+}\n+\n+/* Verify a warning even though the abort() call would prevent the infinite\n+   recursion.  There's no good way to tell the two cases apart and letting\n+   a simple abort prevent the warning would make it ineffective in cases\n+   where it's the result of assert() expansion and not meant to actually\n+   prevent recursion.  */\n+\n+int\n+warn_noret_call_abort_r (char *s, int n)  // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  if (!s)\n+    abort ();\n+\n+  if (n > 7)\n+    abort ();\n+\n+  return n + warn_noret_call_abort_r (s, n - 1);  // { dg-message \"recursive call\" }\n+}\n+\n+/* Verify that a warning is not issued for an apparently infinitely\n+   recursive function like the one above where the recursion would be\n+   prevented by a call to a noreturn function if the recursive function\n+   is itself declared noreturn.  */\n+\n+NORETURN void nowarn_noret_call_abort_r (int n)\n+{\n+  if (n > 7)\n+    abort ();\n+\n+  nowarn_noret_call_abort_r (n - 1);\n+}\n+\n+int warn_call_abort_r (int n)       // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_abort_r (n - 1);   // { dg-message \"recursive call\" }\n+  if (n > 7)   // unreachable\n+    abort ();\n+  return n;\n+}\n+\n+\n+/* And again with exit() for good measure.  */\n+\n+int warn_call_exit_r (int n)        // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_exit_r (n - 1);    // { dg-message \"recursive call\" }\n+  if (n > 7)\n+    exit (0);\n+  return n;\n+}\n+\n+struct __jmp_buf_tag { };\n+typedef struct __jmp_buf_tag jmp_buf[1];\n+\n+extern jmp_buf jmpbuf;\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_longjmp_r (int n)\n+{\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n + nowarn_call_longjmp_r (n - 1);\n+}\n+\n+int warn_call_longjmp_r (int n)     // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  n += warn_call_longjmp_r (n - 1); // { dg-message \"recursive call\" }\n+  if (n > 7)\n+    __builtin_longjmp (jmpbuf, 1);\n+  return n;\n+}\n+\n+\n+struct __sigjmp_buf_tag { };\n+typedef struct __sigjmp_buf_tag sigjmp_buf[1];\n+\n+extern sigjmp_buf sigjmpbuf;\n+\n+/* GCC has no __builtin_siglongjmp().  */\n+extern void siglongjmp (sigjmp_buf, int);\n+\n+/* A call to longjmp() breaks infinite recursion.  Verify it suppresses\n+   the warning.  */\n+\n+int nowarn_call_siglongjmp_r (int n)\n+{\n+  if (n > 7)\n+    siglongjmp (sigjmpbuf, 1);\n+  return n + nowarn_call_siglongjmp_r (n - 1);\n+}\n+\n+\n+int nowarn_while_do_call_r (int n)\n+{\n+  int z = 0;\n+  while (n)\n+    z += nowarn_while_do_call_r (n--);\n+  return z;\n+}\n+\n+int warn_do_while_call_r (int n)    // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  int z = 0;\n+  do\n+    z += warn_do_while_call_r (n);  // { dg-message \"recursive call\" }\n+  while (--n);\n+  return z;\n+}\n+\n+/* Verify warnings for a naive replacement of a built-in fucntion.  */\n+\n+void* malloc (size_t n)             // { dg-warning \"-Winfinite-recursion\" }\n+{\n+  size_t *p =\n+    (size_t*)__builtin_malloc (n + sizeof n);   // { dg-message \"recursive call\" }\n+  *p = n;\n+  return p + 1;\n+}"}, {"sha": "3559c3c9f1b78fbb2f8652e2d354c54bb569d200", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30ba058f77eedfaf7a0582f5d42aff949710bce4/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=30ba058f77eedfaf7a0582f5d42aff949710bce4", "patch": "@@ -435,6 +435,7 @@ extern gimple_opt_pass *make_pass_object_sizes (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_early_object_sizes (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_access (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_warn_printf (gcc::context *ctxt);\n+extern gimple_opt_pass *make_pass_warn_recursion (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_strlen (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_fold_builtins (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_post_ipa_warn (gcc::context *ctxt);"}]}