{"sha": "4a5e9d0089cc59523a3830b35be5e9849e634130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGE1ZTlkMDA4OWNjNTk1MjNhMzgzMGIzNWJlNWU5ODQ5ZTYzNDEzMA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-05-17T12:55:51Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2020-06-01T07:48:43Z"}, "message": "Move value_range_equiv code to its own file.\n\ngcc/\n\t* Makefile.in (OBJS): Add value-range-equiv.o.\n\t* tree-vrp.c (*value_range_equiv*): Move to...\n\t* value-range-equiv.cc: ...here.\n\t* tree-vrp.h (class value_range_equiv): Move to...\n\t* value-range-equiv.h: ...here.\n\t* vr-values.h: Include value-range-equiv.h.", "tree": {"sha": "39174921d2fbbb1198c5479d0a89d24d90661c46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39174921d2fbbb1198c5479d0a89d24d90661c46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a5e9d0089cc59523a3830b35be5e9849e634130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5e9d0089cc59523a3830b35be5e9849e634130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a5e9d0089cc59523a3830b35be5e9849e634130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a5e9d0089cc59523a3830b35be5e9849e634130/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "32633ec815b4d741a9a4b1b75de235844f6d691c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32633ec815b4d741a9a4b1b75de235844f6d691c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32633ec815b4d741a9a4b1b75de235844f6d691c"}], "stats": {"total": 777, "additions": 408, "deletions": 369}, "files": [{"sha": "a5d0e79ac4dd0082474d82dbb7551ddc6d43f56d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -1644,6 +1644,7 @@ OBJS = \\\n \tunique-ptr-tests.o \\\n \tvaltrack.o \\\n \tvalue-range.o \\\n+\tvalue-range-equiv.o \\\n \tvalue-prof.o \\\n \tvar-tracking.o \\\n \tvarasm.o \\"}, {"sha": "e529a7184e8885660a8b4ba814a0f0a7f59822ab", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 1, "deletions": 299, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vr-values.h\"\n #include \"builtins.h\"\n #include \"range-op.h\"\n+#include \"value-range-equiv.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -309,210 +310,6 @@ class vrp_insert\n \t\t\t\t\t\t\tconst void *);\n };\n \n-void\n-value_range_equiv::set_equiv (bitmap equiv)\n-{\n-  if (undefined_p () || varying_p ())\n-    equiv = NULL;\n-  /* Since updating the equivalence set involves deep copying the\n-     bitmaps, only do it if absolutely necessary.\n-\n-     All equivalence bitmaps are allocated from the same obstack.  So\n-     we can use the obstack associated with EQUIV to allocate vr->equiv.  */\n-  if (m_equiv == NULL\n-      && equiv != NULL)\n-    m_equiv = BITMAP_ALLOC (equiv->obstack);\n-\n-  if (equiv != m_equiv)\n-    {\n-      if (equiv && !bitmap_empty_p (equiv))\n-\tbitmap_copy (m_equiv, equiv);\n-      else\n-\tbitmap_clear (m_equiv);\n-    }\n-}\n-\n-/* Initialize value_range.  */\n-\n-void\n-value_range_equiv::set (tree min, tree max, bitmap equiv,\n-\t\t\tvalue_range_kind kind)\n-{\n-  value_range::set (min, max, kind);\n-  set_equiv (equiv);\n-  if (flag_checking)\n-    check ();\n-}\n-\n-value_range_equiv::value_range_equiv (tree min, tree max, bitmap equiv,\n-\t\t\t\t      value_range_kind kind)\n-{\n-  m_equiv = NULL;\n-  set (min, max, equiv, kind);\n-}\n-\n-value_range_equiv::value_range_equiv (const value_range &other)\n-{\n-  m_equiv = NULL;\n-  set (other.min(), other.max (), NULL, other.kind ());\n-}\n-\n-/* Like set, but keep the equivalences in place.  */\n-\n-void\n-value_range_equiv::update (tree min, tree max, value_range_kind kind)\n-{\n-  set (min, max,\n-       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL, kind);\n-}\n-\n-/* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n-\n-   Note: The code that avoids the bitmap sharing looks at the existing\n-   this->m_equiv, so this function cannot be used to initalize an\n-   object.  Use the constructors for initialization.  */\n-\n-void\n-value_range_equiv::deep_copy (const value_range_equiv *from)\n-{\n-  set (from->min (), from->max (), from->m_equiv, from->m_kind);\n-}\n-\n-void\n-value_range_equiv::move (value_range_equiv *from)\n-{\n-  set (from->min (), from->max (), NULL, from->m_kind);\n-  m_equiv = from->m_equiv;\n-  from->m_equiv = NULL;\n-}\n-\n-void\n-value_range_equiv::check ()\n-{\n-  value_range::check ();\n-  switch (m_kind)\n-    {\n-    case VR_UNDEFINED:\n-    case VR_VARYING:\n-      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n-    default:;\n-    }\n-}\n-\n-/* Return true if the bitmaps B1 and B2 are equal.  */\n-\n-static bool\n-vrp_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n-{\n-  return (b1 == b2\n-\t  || ((!b1 || bitmap_empty_p (b1))\n-\t      && (!b2 || bitmap_empty_p (b2)))\n-\t  || (b1 && b2\n-\t      && bitmap_equal_p (b1, b2)));\n-}\n-\n-/* Returns TRUE if THIS == OTHER.  Ignores the equivalence bitmap if\n-   IGNORE_EQUIVS is TRUE.  */\n-\n-bool\n-value_range_equiv::equal_p (const value_range_equiv &other,\n-\t\t\t    bool ignore_equivs) const\n-{\n-  return (value_range::equal_p (other)\n-\t  && (ignore_equivs\n-\t      || vrp_bitmap_equal_p (m_equiv, other.m_equiv)));\n-}\n-\n-void\n-value_range_equiv::set_undefined ()\n-{\n-  set (NULL, NULL, NULL, VR_UNDEFINED);\n-}\n-\n-void\n-value_range_equiv::set_varying (tree type)\n-{\n-  value_range::set_varying (type);\n-  equiv_clear ();\n-}\n-\n-void\n-value_range_equiv::equiv_clear ()\n-{\n-  if (m_equiv)\n-    bitmap_clear (m_equiv);\n-}\n-\n-/* Add VAR and VAR's equivalence set (VAR_VR) to the equivalence\n-   bitmap.  If no equivalence table has been created, OBSTACK is the\n-   obstack to use (NULL for the default obstack).\n-\n-   This is the central point where equivalence processing can be\n-   turned on/off.  */\n-\n-void\n-value_range_equiv::equiv_add (const_tree var,\n-\t\t\t      const value_range_equiv *var_vr,\n-\t\t\t      bitmap_obstack *obstack)\n-{\n-  if (!m_equiv)\n-    m_equiv = BITMAP_ALLOC (obstack);\n-  unsigned ver = SSA_NAME_VERSION (var);\n-  bitmap_set_bit (m_equiv, ver);\n-  if (var_vr && var_vr->m_equiv)\n-    bitmap_ior_into (m_equiv, var_vr->m_equiv);\n-}\n-\n-void\n-value_range_equiv::dump (FILE *file) const\n-{\n-  value_range::dump (file);\n-  if ((m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n-      && m_equiv)\n-    {\n-      bitmap_iterator bi;\n-      unsigned i, c = 0;\n-\n-      fprintf (file, \"  EQUIVALENCES: { \");\n-\n-      EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n-\t{\n-\t  print_generic_expr (file, ssa_name (i));\n-\t  fprintf (file, \" \");\n-\t  c++;\n-\t}\n-\n-      fprintf (file, \"} (%u elements)\", c);\n-    }\n-}\n-\n-void\n-value_range_equiv::dump () const\n-{\n-  dump (stderr);\n-}\n-\n-void\n-dump_value_range (FILE *file, const value_range_equiv *vr)\n-{\n-  if (!vr)\n-    fprintf (file, \"[]\");\n-  else\n-    vr->dump (file);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range_equiv *vr)\n-{\n-  dump_value_range (stderr, vr);\n-}\n-\n-DEBUG_FUNCTION void\n-debug (const value_range_equiv &vr)\n-{\n-  dump_value_range (stderr, &vr);\n-}\n-\n /* Return true if the SSA name NAME is live on the edge E.  */\n \n bool\n@@ -594,15 +391,6 @@ intersect_range_with_nonzero_bits (enum value_range_kind vr_type,\n   return vr_type;\n }\n \n-void\n-value_range_equiv::set (tree val)\n-{\n-  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n-  if (TREE_OVERFLOW_P (val))\n-    val = drop_tree_overflow (val);\n-  set (val, val);\n-}\n-\n /* Return true if max and min of VR are INTEGER_CST.  It's not necessary\n    a singleton.  */\n \n@@ -4797,92 +4585,6 @@ vrp_prop::visit_stmt (gimple *stmt, edge *taken_edge_p, tree *output_p)\n   return (*taken_edge_p) ? SSA_PROP_INTERESTING : SSA_PROP_VARYING;\n }\n \n-void\n-value_range_equiv::intersect (const value_range_equiv *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Intersecting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* If THIS is varying we want to pick up equivalences from OTHER.\n-     Just special-case this here rather than trying to fixup after the\n-     fact.  */\n-  if (this->varying_p ())\n-    this->deep_copy (other);\n-  else\n-    {\n-      value_range tem = intersect_helper (this, other);\n-      this->update (tem.min (), tem.max (), tem.kind ());\n-\n-      /* If the result is VR_UNDEFINED there is no need to mess with\n-\t equivalencies.  */\n-      if (!undefined_p ())\n-\t{\n-\t  /* The resulting set of equivalences for range intersection\n-\t     is the union of the two sets.  */\n-\t  if (m_equiv && other->m_equiv && m_equiv != other->m_equiv)\n-\t    bitmap_ior_into (m_equiv, other->m_equiv);\n-\t  else if (other->m_equiv && !m_equiv)\n-\t    {\n-\t      /* All equivalence bitmaps are allocated from the same\n-\t\t obstack.  So we can use the obstack associated with\n-\t\t VR to allocate this->m_equiv.  */\n-\t      m_equiv = BITMAP_ALLOC (other->m_equiv->obstack);\n-\t      bitmap_copy (m_equiv, other->m_equiv);\n-\t    }\n-\t}\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n-void\n-value_range_equiv::union_ (const value_range_equiv *other)\n-{\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"Meeting\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\nand\\n  \");\n-      dump_value_range (dump_file, other);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-\n-  /* If THIS is undefined we want to pick up equivalences from OTHER.\n-     Just special-case this here rather than trying to fixup after the fact.  */\n-  if (this->undefined_p ())\n-    this->deep_copy (other);\n-  else\n-    {\n-      value_range tem = union_helper (this, other);\n-      this->update (tem.min (), tem.max (), tem.kind ());\n-\n-      /* The resulting set of equivalences is always the intersection of\n-\t the two sets.  */\n-      if (this->m_equiv && other->m_equiv && this->m_equiv != other->m_equiv)\n-\tbitmap_and_into (this->m_equiv, other->m_equiv);\n-      else if (this->m_equiv && !other->m_equiv)\n-\tbitmap_clear (this->m_equiv);\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    {\n-      fprintf (dump_file, \"to\\n  \");\n-      dump_value_range (dump_file, this);\n-      fprintf (dump_file, \"\\n\");\n-    }\n-}\n-\n /* Visit all arguments for PHI node PHI that flow through executable\n    edges.  If a valid value range can be derived from all the incoming\n    value ranges, set a new range for the LHS of PHI.  */"}, {"sha": "b3d187ffdf12b4cea565eef911bc1e091f87e491", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 0, "deletions": 70, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -22,76 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #include \"value-range.h\"\n \n-/* Note value_range_equiv cannot currently be used with GC memory,\n-   only value_range is fully set up for this.  */\n-class GTY((user)) value_range_equiv : public value_range\n-{\n- public:\n-  value_range_equiv ();\n-  value_range_equiv (const value_range &);\n-  /* Deep-copies equiv bitmap argument.  */\n-  value_range_equiv (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n-\n-  /* Shallow-copies equiv bitmap.  */\n-  value_range_equiv (const value_range_equiv &) /* = delete */;\n-  /* Shallow-copies equiv bitmap.  */\n-  value_range_equiv& operator=(const value_range_equiv &) /* = delete */;\n-\n-  /* Move equiv bitmap from source range.  */\n-  void move (value_range_equiv *);\n-\n-  /* Leaves equiv bitmap alone.  */\n-  void update (tree, tree, value_range_kind = VR_RANGE);\n-  /* Deep-copies equiv bitmap argument.  */\n-  void set (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n-  void set (tree);\n-\n-  bool operator== (const value_range_equiv &) const /* = delete */;\n-  bool operator!= (const value_range_equiv &) const /* = delete */;\n-  void intersect (const value_range_equiv *);\n-  void union_ (const value_range_equiv *);\n-  bool equal_p (const value_range_equiv &, bool ignore_equivs) const;\n-\n-  /* Types of value ranges.  */\n-  void set_undefined ();\n-  void set_varying (tree);\n-\n-  /* Equivalence bitmap methods.  */\n-  bitmap equiv () const;\n-  void equiv_clear ();\n-  void equiv_add (const_tree, const value_range_equiv *,\n-\t\t  bitmap_obstack * = NULL);\n-\n-  /* Misc methods.  */\n-  void deep_copy (const value_range_equiv *);\n-  void dump (FILE *) const;\n-  void dump () const;\n-\n- private:\n-  /* Deep-copies bitmap argument.  */\n-  void set_equiv (bitmap);\n-  void check ();\n-\n-  /* Set of SSA names whose value ranges are equivalent to this one.\n-     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n-  bitmap m_equiv;\n-};\n-\n-inline\n-value_range_equiv::value_range_equiv ()\n-  : value_range ()\n-{\n-  m_equiv = NULL;\n-}\n-\n-inline bitmap\n-value_range_equiv::equiv () const\n-{\n-  return m_equiv;\n-}\n-\n-extern void dump_value_range (FILE *, const value_range_equiv *);\n-\n struct assert_info\n {\n   /* Predicate code for the ASSERT_EXPR.  Must be COMPARISON_CLASS_P.  */"}, {"sha": "24132e3546e729beddb28d125683a74d1d4c0b28", "filename": "gcc/value-range-equiv.cc", "status": "added", "additions": 322, "deletions": 0, "changes": 322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvalue-range-equiv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvalue-range-equiv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.cc?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -0,0 +1,322 @@\n+/* Support routines for value ranges with equivalences.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"ssa.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"value-range-equiv.h\"\n+\n+value_range_equiv::value_range_equiv (tree min, tree max, bitmap equiv,\n+\t\t\t\t      value_range_kind kind)\n+{\n+  m_equiv = NULL;\n+  set (min, max, equiv, kind);\n+}\n+\n+value_range_equiv::value_range_equiv (const value_range &other)\n+{\n+  m_equiv = NULL;\n+  set (other.min(), other.max (), NULL, other.kind ());\n+}\n+\n+void\n+value_range_equiv::set (tree min, tree max, bitmap equiv,\n+\t\t\tvalue_range_kind kind)\n+{\n+  value_range::set (min, max, kind);\n+  set_equiv (equiv);\n+  if (flag_checking)\n+    check ();\n+}\n+\n+void\n+value_range_equiv::set (tree val)\n+{\n+  gcc_assert (TREE_CODE (val) == SSA_NAME || is_gimple_min_invariant (val));\n+  if (TREE_OVERFLOW_P (val))\n+    val = drop_tree_overflow (val);\n+  set (val, val);\n+}\n+\n+void\n+value_range_equiv::set_undefined ()\n+{\n+  set (NULL, NULL, NULL, VR_UNDEFINED);\n+}\n+\n+void\n+value_range_equiv::set_varying (tree type)\n+{\n+  value_range::set_varying (type);\n+  equiv_clear ();\n+}\n+\n+/* Like set, but keep the equivalences in place.  */\n+\n+void\n+value_range_equiv::update (tree min, tree max, value_range_kind kind)\n+{\n+  set (min, max,\n+       (kind != VR_UNDEFINED && kind != VR_VARYING) ? m_equiv : NULL, kind);\n+}\n+\n+/* Copy value_range in FROM into THIS while avoiding bitmap sharing.\n+\n+   Note: The code that avoids the bitmap sharing looks at the existing\n+   this->m_equiv, so this function cannot be used to initalize an\n+   object.  Use the constructors for initialization.  */\n+\n+void\n+value_range_equiv::deep_copy (const value_range_equiv *from)\n+{\n+  set (from->min (), from->max (), from->m_equiv, from->m_kind);\n+}\n+\n+void\n+value_range_equiv::move (value_range_equiv *from)\n+{\n+  set (from->min (), from->max (), NULL, from->m_kind);\n+  m_equiv = from->m_equiv;\n+  from->m_equiv = NULL;\n+}\n+\n+void\n+value_range_equiv::set_equiv (bitmap equiv)\n+{\n+  if (undefined_p () || varying_p ())\n+    equiv = NULL;\n+  /* Since updating the equivalence set involves deep copying the\n+     bitmaps, only do it if absolutely necessary.\n+\n+     All equivalence bitmaps are allocated from the same obstack.  So\n+     we can use the obstack associated with EQUIV to allocate vr->equiv.  */\n+  if (m_equiv == NULL\n+      && equiv != NULL)\n+    m_equiv = BITMAP_ALLOC (equiv->obstack);\n+\n+  if (equiv != m_equiv)\n+    {\n+      if (equiv && !bitmap_empty_p (equiv))\n+\tbitmap_copy (m_equiv, equiv);\n+      else\n+\tbitmap_clear (m_equiv);\n+    }\n+}\n+\n+void\n+value_range_equiv::check ()\n+{\n+  value_range::check ();\n+  switch (m_kind)\n+    {\n+    case VR_UNDEFINED:\n+    case VR_VARYING:\n+      gcc_assert (!m_equiv || bitmap_empty_p (m_equiv));\n+    default:;\n+    }\n+}\n+\n+/* Return true if the bitmaps B1 and B2 are equal.  */\n+\n+static bool\n+vr_bitmap_equal_p (const_bitmap b1, const_bitmap b2)\n+{\n+  return (b1 == b2\n+\t  || ((!b1 || bitmap_empty_p (b1))\n+\t      && (!b2 || bitmap_empty_p (b2)))\n+\t  || (b1 && b2\n+\t      && bitmap_equal_p (b1, b2)));\n+}\n+\n+/* Returns TRUE if THIS == OTHER.  Ignores the equivalence bitmap if\n+   IGNORE_EQUIVS is TRUE.  */\n+\n+bool\n+value_range_equiv::equal_p (const value_range_equiv &other,\n+\t\t\t    bool ignore_equivs) const\n+{\n+  return (value_range::equal_p (other)\n+\t  && (ignore_equivs || vr_bitmap_equal_p (m_equiv, other.m_equiv)));\n+}\n+\n+void\n+value_range_equiv::equiv_clear ()\n+{\n+  if (m_equiv)\n+    bitmap_clear (m_equiv);\n+}\n+\n+/* Add VAR and VAR's equivalence set (VAR_VR) to the equivalence\n+   bitmap.  If no equivalence table has been created, OBSTACK is the\n+   obstack to use (NULL for the default obstack).\n+\n+   This is the central point where equivalence processing can be\n+   turned on/off.  */\n+\n+void\n+value_range_equiv::equiv_add (const_tree var,\n+\t\t\t      const value_range_equiv *var_vr,\n+\t\t\t      bitmap_obstack *obstack)\n+{\n+  if (!m_equiv)\n+    m_equiv = BITMAP_ALLOC (obstack);\n+  unsigned ver = SSA_NAME_VERSION (var);\n+  bitmap_set_bit (m_equiv, ver);\n+  if (var_vr && var_vr->m_equiv)\n+    bitmap_ior_into (m_equiv, var_vr->m_equiv);\n+}\n+\n+void\n+value_range_equiv::intersect (const value_range_equiv *other)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Intersecting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* If THIS is varying we want to pick up equivalences from OTHER.\n+     Just special-case this here rather than trying to fixup after the\n+     fact.  */\n+  if (this->varying_p ())\n+    this->deep_copy (other);\n+  else\n+    {\n+      value_range tem = intersect_helper (this, other);\n+      this->update (tem.min (), tem.max (), tem.kind ());\n+\n+      /* If the result is VR_UNDEFINED there is no need to mess with\n+\t equivalencies.  */\n+      if (!undefined_p ())\n+\t{\n+\t  /* The resulting set of equivalences for range intersection\n+\t     is the union of the two sets.  */\n+\t  if (m_equiv && other->m_equiv && m_equiv != other->m_equiv)\n+\t    bitmap_ior_into (m_equiv, other->m_equiv);\n+\t  else if (other->m_equiv && !m_equiv)\n+\t    {\n+\t      /* All equivalence bitmaps are allocated from the same\n+\t\t obstack.  So we can use the obstack associated with\n+\t\t VR to allocate this->m_equiv.  */\n+\t      m_equiv = BITMAP_ALLOC (other->m_equiv->obstack);\n+\t      bitmap_copy (m_equiv, other->m_equiv);\n+\t    }\n+\t}\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+void\n+value_range_equiv::union_ (const value_range_equiv *other)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"Meeting\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\nand\\n  \");\n+      dump_value_range (dump_file, other);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  /* If THIS is undefined we want to pick up equivalences from OTHER.\n+     Just special-case this here rather than trying to fixup after the fact.  */\n+  if (this->undefined_p ())\n+    this->deep_copy (other);\n+  else\n+    {\n+      value_range tem = union_helper (this, other);\n+      this->update (tem.min (), tem.max (), tem.kind ());\n+\n+      /* The resulting set of equivalences is always the intersection of\n+\t the two sets.  */\n+      if (this->m_equiv && other->m_equiv && this->m_equiv != other->m_equiv)\n+\tbitmap_and_into (this->m_equiv, other->m_equiv);\n+      else if (this->m_equiv && !other->m_equiv)\n+\tbitmap_clear (this->m_equiv);\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"to\\n  \");\n+      dump_value_range (dump_file, this);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+}\n+\n+void\n+value_range_equiv::dump (FILE *file) const\n+{\n+  value_range::dump (file);\n+  if ((m_kind == VR_RANGE || m_kind == VR_ANTI_RANGE)\n+      && m_equiv)\n+    {\n+      bitmap_iterator bi;\n+      unsigned i, c = 0;\n+\n+      fprintf (file, \"  EQUIVALENCES: { \");\n+      EXECUTE_IF_SET_IN_BITMAP (m_equiv, 0, i, bi)\n+\t{\n+\t  print_generic_expr (file, ssa_name (i));\n+\t  fprintf (file, \" \");\n+\t  c++;\n+\t}\n+      fprintf (file, \"} (%u elements)\", c);\n+    }\n+}\n+\n+void\n+value_range_equiv::dump () const\n+{\n+  dump (stderr);\n+}\n+\n+void\n+dump_value_range (FILE *file, const value_range_equiv *vr)\n+{\n+  if (!vr)\n+    fprintf (file, \"[]\");\n+  else\n+    vr->dump (file);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const value_range_equiv *vr)\n+{\n+  dump_value_range (stderr, vr);\n+}\n+\n+DEBUG_FUNCTION void\n+debug (const value_range_equiv &vr)\n+{\n+  dump_value_range (stderr, &vr);\n+}"}, {"sha": "274221226e61cc2c5556d79befb36e9347e87d81", "filename": "gcc/value-range-equiv.h", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvalue-range-equiv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvalue-range-equiv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-equiv.h?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -0,0 +1,82 @@\n+/* Support routines for value ranges with equivalences.\n+   Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_VALUE_RANGE_EQUIV_H\n+#define GCC_VALUE_RANGE_EQUIV_H\n+\n+#include \"value-range.h\"\n+\n+/* Note value_range_equiv cannot currently be used with GC memory,\n+   only value_range is fully set up for this.  */\n+class GTY((user)) value_range_equiv : public value_range\n+{\n+ public:\n+  value_range_equiv () : value_range () { m_equiv = NULL; }\n+  value_range_equiv (const value_range &);\n+  /* Deep-copies equiv bitmap argument.  */\n+  value_range_equiv (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n+\n+  /* Shallow-copies equiv bitmap.  */\n+  value_range_equiv (const value_range_equiv &) /* = delete */;\n+  /* Shallow-copies equiv bitmap.  */\n+  value_range_equiv& operator=(const value_range_equiv &) /* = delete */;\n+\n+  /* Move equiv bitmap from source range.  */\n+  void move (value_range_equiv *);\n+\n+  /* Leaves equiv bitmap alone.  */\n+  void update (tree, tree, value_range_kind = VR_RANGE);\n+  /* Deep-copies equiv bitmap argument.  */\n+  void set (tree, tree, bitmap = NULL, value_range_kind = VR_RANGE);\n+  void set (tree);\n+\n+  bool operator== (const value_range_equiv &) const /* = delete */;\n+  bool operator!= (const value_range_equiv &) const /* = delete */;\n+  void intersect (const value_range_equiv *);\n+  void union_ (const value_range_equiv *);\n+  bool equal_p (const value_range_equiv &, bool ignore_equivs) const;\n+\n+  /* Types of value ranges.  */\n+  void set_undefined ();\n+  void set_varying (tree);\n+\n+  /* Equivalence bitmap methods.  */\n+  bitmap equiv () const { return m_equiv; }\n+  void equiv_clear ();\n+  void equiv_add (const_tree, const value_range_equiv *,\n+\t\t  bitmap_obstack * = NULL);\n+\n+  /* Misc methods.  */\n+  void deep_copy (const value_range_equiv *);\n+  void dump (FILE *) const;\n+  void dump () const;\n+\n+ private:\n+  /* Deep-copies bitmap argument.  */\n+  void set_equiv (bitmap);\n+  void check ();\n+\n+  /* Set of SSA names whose value ranges are equivalent to this one.\n+     This set is only valid when TYPE is VR_RANGE or VR_ANTI_RANGE.  */\n+  bitmap m_equiv;\n+};\n+\n+extern void dump_value_range (FILE *, const value_range_equiv *);\n+\n+#endif // GCC_VALUE_RANGE_EQUIV_H"}, {"sha": "cfe4f64809e5de285d6d9adfec506cb41881aa05", "filename": "gcc/vr-values.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvr-values.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a5e9d0089cc59523a3830b35be5e9849e634130/gcc%2Fvr-values.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvr-values.h?ref=4a5e9d0089cc59523a3830b35be5e9849e634130", "patch": "@@ -20,6 +20,8 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_VR_VALUES_H\n #define GCC_VR_VALUES_H\n \n+#include \"value-range-equiv.h\"\n+\n /* The VR_VALUES class holds the current view of range information\n    for all the SSA_NAMEs in the IL.\n "}]}