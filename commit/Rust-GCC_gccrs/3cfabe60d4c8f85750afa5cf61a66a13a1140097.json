{"sha": "3cfabe60d4c8f85750afa5cf61a66a13a1140097", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2NmYWJlNjBkNGM4Zjg1NzUwYWZhNWNmNjFhNjZhMTNhMTE0MDA5Nw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2002-12-31T19:43:16Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2002-12-31T19:43:16Z"}, "message": "class.c (modify_vtable_entry): Remove unused variable.\n\ncp:\n\t* class.c (modify_vtable_entry): Remove unused variable.\n\t(get_vcall_index): Always expect a non-thunk.\n\t(update_vtable_entry_for_fn): Combine covariant adjustments, when\n\toverriding a thunk. Pass get_vcall_index a non-thunk.\n\n\t* decl2.c (finish_file): Mark undefined inlines as extern.\ntestsuite:\n\t* g++.dg/inherit/covariant8.C: New test.\n\nFrom-SVN: r60710", "tree": {"sha": "fcffe3f938dfc8c7c725a5aa63895202f9d645b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcffe3f938dfc8c7c725a5aa63895202f9d645b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3cfabe60d4c8f85750afa5cf61a66a13a1140097", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfabe60d4c8f85750afa5cf61a66a13a1140097", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3cfabe60d4c8f85750afa5cf61a66a13a1140097", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3cfabe60d4c8f85750afa5cf61a66a13a1140097/comments", "author": null, "committer": null, "parents": [{"sha": "3b41afd944b8413290a47b776d638abfe7321969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b41afd944b8413290a47b776d638abfe7321969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b41afd944b8413290a47b776d638abfe7321969"}], "stats": {"total": 210, "additions": 142, "deletions": 68}, "files": [{"sha": "987e42bac40e83ac2135521301d045c2a8d9e2d1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -1,3 +1,12 @@\n+2002-12-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* class.c (modify_vtable_entry): Remove unused variable.\n+\t(get_vcall_index): Always expect a non-thunk.\n+\t(update_vtable_entry_for_fn): Combine covariant adjustments, when\n+\toverriding a thunk. Pass get_vcall_index a non-thunk.\n+\n+\t* decl2.c (finish_file): Mark undefined inlines as extern.\n+\n 2002-12-31  Mark Mitchell  <mark@codesourcery.com>\n \n \t* cp-tree.def (RETURN_INIT): Remove."}, {"sha": "b54c1f658d33149d6e1fd2c9cee5aa38db141fdd", "filename": "gcc/cp/class.c", "status": "modified", "additions": 80, "deletions": 64, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -716,8 +716,6 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n   if (fndecl != BV_FN (v)\n       || !tree_int_cst_equal (delta, BV_DELTA (v)))\n     {\n-      tree base_fndecl;\n-\n       /* We need a new vtable for BINFO.  */\n       if (make_new_vtable (t, binfo))\n \t{\n@@ -730,7 +728,6 @@ modify_vtable_entry (t, binfo, fndecl, delta, virtuals)\n \t  v = *virtuals;\n \t}\n \n-      base_fndecl = BV_FN (v);\n       BV_DELTA (v) = delta;\n       BV_VCALL_INDEX (v) = NULL_TREE;\n       BV_FN (v) = fndecl;\n@@ -2331,9 +2328,6 @@ get_vcall_index (tree fn, tree type)\n {\n   tree v;\n \n-  if (DECL_THUNK_P (fn))\n-    fn = THUNK_TARGET (fn);\n-\n   for (v = CLASSTYPE_VCALL_INDICES (type); v; v = TREE_CHAIN (v))\n     if ((DECL_DESTRUCTOR_P (fn) && DECL_DESTRUCTOR_P (TREE_PURPOSE (v)))\n \t|| same_signature_p (fn, TREE_PURPOSE (v)))\n@@ -2361,18 +2355,18 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   tree delta;\n   tree virtual_base;\n   tree first_defn;\n+  tree overrider_fn, overrider_target;\n+  tree target_fn = DECL_THUNK_P (fn) ? THUNK_TARGET (fn) : fn;\n+  tree over_return, base_return;\n   bool lost = false;\n \n-  if (DECL_THUNK_P (fn))\n-    fn = THUNK_TARGET (fn);\n-  \n   /* Find the nearest primary base (possibly binfo itself) which defines\n      this function; this is the class the caller will convert to when\n      calling FN through BINFO.  */\n   for (b = binfo; ; b = get_primary_binfo (b))\n     {\n       my_friendly_assert (b, 20021227);\n-      if (look_for_overrides_here (BINFO_TYPE (b), fn))\n+      if (look_for_overrides_here (BINFO_TYPE (b), target_fn))\n \tbreak;\n \n       /* The nearest definition is from a lost primary.  */\n@@ -2382,58 +2376,85 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n   first_defn = b;\n \n   /* Find the final overrider.  */\n-  overrider = find_final_overrider (TYPE_BINFO (t), b, fn);\n+  overrider = find_final_overrider (TYPE_BINFO (t), b, target_fn);\n   if (overrider == error_mark_node)\n     return;\n-  {\n-    /* Check for adjusting covariant return types. */\n-    tree over_return = TREE_TYPE (TREE_TYPE (TREE_PURPOSE (overrider)));\n-    tree base_return = TREE_TYPE (TREE_TYPE (fn));\n-\n-    if (POINTER_TYPE_P (over_return)\n-\t&& TREE_CODE (over_return) == TREE_CODE (base_return)\n-\t&& CLASS_TYPE_P (TREE_TYPE (over_return))\n-\t&& CLASS_TYPE_P (TREE_TYPE (base_return)))\n-      {\n-\ttree binfo;\n-\tbase_kind kind;\n+  overrider_target = overrider_fn = TREE_PURPOSE (overrider);\n+  \n+  /* Check for adjusting covariant return types. */\n+  over_return = TREE_TYPE (TREE_TYPE (overrider_target));\n+  base_return = TREE_TYPE (TREE_TYPE (target_fn));\n+  \n+  if (POINTER_TYPE_P (over_return)\n+      && TREE_CODE (over_return) == TREE_CODE (base_return)\n+      && CLASS_TYPE_P (TREE_TYPE (over_return))\n+      && CLASS_TYPE_P (TREE_TYPE (base_return)))\n+    {\n+      /* If FN is a covariant thunk, we must figure out the adjustment\n+         to the final base FN was converting to. As OVERRIDER_TARGET might\n+         also be converting to the return type of FN, we have to\n+         combine the two conversions here.  */\n+      tree fixed_offset, virtual_offset;\n+      \n+      if (DECL_THUNK_P (fn))\n+\t{\n+\t  fixed_offset = ssize_int (THUNK_FIXED_OFFSET (fn));\n+\t  virtual_offset = THUNK_VIRTUAL_OFFSET (fn);\n+\t  if (virtual_offset)\n+\t    virtual_offset = binfo_for_vbase (BINFO_TYPE (virtual_offset),\n+\t\t\t\t\t      TREE_TYPE (over_return));\n+\t}\n+      else\n+\tfixed_offset = virtual_offset = NULL_TREE;\n \n-\tbinfo = lookup_base (TREE_TYPE (over_return), TREE_TYPE (base_return),\n-\t\t\t     ba_check | ba_quiet, &kind);\n+      if (!virtual_offset)\n+\t{\n+\t  /* There was no existing virtual thunk (which takes\n+\t     precidence). */\n+\t  tree thunk_binfo;\n+\t  base_kind kind;\n+\t  \n+\t  thunk_binfo = lookup_base (TREE_TYPE (over_return),\n+\t\t\t\t     TREE_TYPE (base_return),\n+\t\t\t\t     ba_check | ba_quiet, &kind);\n \n-\tif (binfo && (kind == bk_via_virtual || !BINFO_OFFSET_ZEROP (binfo)))\n-\t  {\n-\t    tree fixed_offset = BINFO_OFFSET (binfo);\n-\t    tree virtual_offset = NULL_TREE;\n-\t    tree thunk;\n-\t    \n-\t    if (kind == bk_via_virtual)\n-\t      {\n-\t\twhile (!TREE_VIA_VIRTUAL (binfo))\n-\t\t  binfo = BINFO_INHERITANCE_CHAIN (binfo);\n-\t\t\n-\t\t/* If the covariant type is within the class hierarchy\n-\t\t   we are currently laying out, the vbase index is not\n-\t\t   yet known, so we have to remember the virtual base\n-\t\t   binfo. */\n-\t\tvirtual_offset = binfo_for_vbase (BINFO_TYPE (binfo),\n-\t\t\t\t\t\t  TREE_TYPE (over_return));\n-\t\tfixed_offset = size_diffop (fixed_offset,\n-\t\t\t\t\t    BINFO_OFFSET (virtual_offset));\n-\t      }\n-\t    \n-\t    /* Replace the overriding function with a covariant thunk.\n-\t       We will emit the overriding function in its own slot\n-\t       as well. */\n-\t    thunk = make_thunk (TREE_PURPOSE (overrider), /*this_adjusting=*/0,\n-\t\t\t\tfixed_offset, virtual_offset);\n-\t    TREE_PURPOSE (overrider) = thunk;\n-\t    if (!virtual_offset && !DECL_NAME (thunk))\n-\t      finish_thunk (thunk);\n-\t  }\n-      }\n-  }\n+\t  if (thunk_binfo && (kind == bk_via_virtual\n+\t\t\t      || !BINFO_OFFSET_ZEROP (thunk_binfo)))\n+\t    {\n+\t      tree offset = BINFO_OFFSET (thunk_binfo);\n \n+\t      if (kind == bk_via_virtual)\n+\t\t{\n+\t\t  /* We convert via virtual base. Find the virtual\n+\t\t     base and adjust the fixed offset to be from there.  */\n+\t\t  while (!TREE_VIA_VIRTUAL (thunk_binfo))\n+\t\t    thunk_binfo = BINFO_INHERITANCE_CHAIN (thunk_binfo);\n+\t      \n+\t\t  virtual_offset = binfo_for_vbase (BINFO_TYPE (thunk_binfo),\n+\t\t\t\t\t\t    TREE_TYPE (over_return));\n+\t\t  offset = size_diffop (offset,\n+\t\t\t\t\tBINFO_OFFSET (virtual_offset));\n+\t\t}\n+\t      if (fixed_offset)\n+\t\t/* There was an existing fixed offset, this must be\n+\t\t   from the base just converted to, and the base the\n+\t\t   FN was thunking to.  */\n+\t\tfixed_offset = size_binop (PLUS_EXPR, fixed_offset, offset);\n+\t      else\n+\t\tfixed_offset = offset;\n+\t    }\n+\t}\n+      \n+      if (fixed_offset || virtual_offset)\n+\t/* Replace the overriding function with a covariant thunk.  We\n+\t   will emit the overriding function in its own slot as\n+\t   well. */\n+\toverrider_fn = make_thunk (overrider_target, /*this_adjusting=*/0,\n+\t\t\t\t   fixed_offset, virtual_offset);\n+    }\n+  else\n+    my_friendly_assert (!DECL_THUNK_P (fn), 20021231);\n+  \n   /* Assume that we will produce a thunk that convert all the way to\n      the final overrider, and not to an intermediate virtual base.  */\n   virtual_base = NULL_TREE;\n@@ -2476,16 +2497,11 @@ update_vtable_entry_for_fn (t, binfo, fn, virtuals)\n     delta = size_diffop (BINFO_OFFSET (TREE_VALUE (overrider)),\n \t\t\t BINFO_OFFSET (binfo));\n \n-  modify_vtable_entry (t, \n-\t\t       binfo, \n-\t\t       TREE_PURPOSE (overrider),\n-\t\t       delta,\n-\t\t       virtuals);\n+  modify_vtable_entry (t, binfo, overrider_fn, delta, virtuals);\n \n   if (virtual_base)\n     BV_VCALL_INDEX (*virtuals) \n-      = get_vcall_index (TREE_PURPOSE (overrider),\n-\t\t\t BINFO_TYPE (virtual_base));\n+      = get_vcall_index (overrider_target, BINFO_TYPE (virtual_base));\n }\n \n /* Called from modify_all_vtables via dfs_walk.  */"}, {"sha": "e27c66832ea9d2195e8c45ab2d10f69c73973426", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -2977,9 +2977,13 @@ struct lang_decl GTY(())\n /* A tree indicating how to perform the virtual adjustment. For a this\n    adjusting thunk it is the number of bytes to be added to the vtable\n    to find the vcall offset. For a result adjusting thunk, it is the\n-   binfo of the relevant virtual base.  The vptr is always located at\n-   offset zero from the this or result pointer.  If NULL, then there\n-   is no virtual adjust.  */\n+   binfo of the relevant virtual base.  If NULL, then there is no\n+   virtual adjust.  (The vptr is always located at offset zero from\n+   the this or result pointer.)  (If the covariant type is within the\n+   class hierarchy being layed out, the vbase index is not yet known\n+   at the point we need to create the thunks, hence the need to use\n+   binfos.)  */\n+\n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n   (LANG_DECL_U2_CHECK (VAR_OR_FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n "}, {"sha": "8e440e92e97dab4b86948d07f2200703e8b5ea1f", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -2802,7 +2802,14 @@ finish_file ()\n \n       if (TREE_USED (decl) && DECL_DECLARED_INLINE_P (decl)\n \t  && !(TREE_ASM_WRITTEN (decl) || DECL_SAVED_TREE (decl)))\n-\tcp_warning_at (\"inline function `%D' used but never defined\", decl);\n+\t{\n+\t  cp_warning_at (\"inline function `%D' used but never defined\", decl);\n+\t  /* This symbol is effectively an \"extern\" declaration now.\n+\t     This is not strictly necessary, but removes a duplicate\n+\t     warning.  */\n+\t  TREE_PUBLIC (decl) = 1;\n+\t}\n+      \n     }\n   \n   /* We give C linkage to static constructors and destructors.  */"}, {"sha": "b63e008806825b4a112e04091218e5b166bcc065", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -1,3 +1,7 @@\n+2002-12-31  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/inherit/covariant8.C: New test.\n+\n 2002-12-31  Mark Mitchell  <mark@codesourcery.com>\n \n \t* g++.dg/init/array9.C: New test."}, {"sha": "33dc431065e8bc274e068d4eda7f0b80fa63eea4", "filename": "gcc/testsuite/g++.dg/inherit/covariant8.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3cfabe60d4c8f85750afa5cf61a66a13a1140097/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finherit%2Fcovariant8.C?ref=3cfabe60d4c8f85750afa5cf61a66a13a1140097", "patch": "@@ -0,0 +1,34 @@\n+// { dg-do compile }\n+\n+// Copyright (C) 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 31 Dec 2002 <nathan@codesourcery.com>\n+\n+// ICE with covariant thunks.\n+\n+struct c0 {};\n+\n+struct c1 : virtual c0\n+{\n+  virtual c0 &f2 ();\n+};\n+\n+struct c2 \n+{\n+  int m;\n+};\n+\n+struct c3 : virtual c0, virtual c1, c2\n+{\n+  virtual c1 &f2 ();\n+};\n+\n+c1 &c3::f2 ()\n+{\n+  throw 0;\n+}\n+\n+struct c4 : virtual c3, virtual c0, virtual c1 {};\n+\n+struct c8 : virtual c2, virtual c0 {};\n+\n+struct c12 : virtual c4, virtual c3, virtual c8 {};"}]}