{"sha": "31dbaab57fef485412a0369a222b9c252ad2713b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFkYmFhYjU3ZmVmNDg1NDEyYTAzNjlhMjIyYjljMjUyYWQyNzEzYg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-14T12:57:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-07-14T13:27:07Z"}, "message": "c++:  Comments & formatting\n\nI found some bad formatting and misleading or incomplete comments\nduring my spelunking around the c++FE.  May as well clean up trunk and\nrecord what I noted.\n\n\tgcc/cp/\n\t* cp-tree.h: Correct some tree lang flag comments,\n\treformat some structure definitions.  Note some structure\n\tsizes.  Clarify some comments.\n\t(yyungetc): Delete.  Not been a thing for some time.\n\t* class.c (copy_fndecl_with_name): Comment.\n\t(check_bases_and_members): Unnecessary {}.\n\t(layout_class_type): Comment.\n\t* cp-tree.def (UNBOUND_CLASS_TEMPLATE): Adjust comment.\n\t* decl.c:  Fix some formatting & whitespace issues.\n\t(function_requirements_equivalent_p): Note why\n\tsubstitutions are needed.\n\t* decl2.c (no_linkage_error): Note that heroics about\n\t'typedef struct { ... };' are no longer needed.\n\t* method.c: Whitespace.\n\t* name-lookup.c: Whitespace.\n\t(add_decl_to_level): Reformat a line.\n\t(print_binding_stack): Mark as DEBUG_FUNCTION.\n\t(has_using_namespace_std_directive_p): Delete comment.\n\t* pt.c: Whitespace\n\t* ptree.c: Whitespace.\n\t* rtti.c: Whitespace & comment.\n\t* tree.c: Comment.\n\t* typeck.c (structural_comptypes): Add comment.", "tree": {"sha": "1cdd29a5079b04f3f34dabc3495732ba43312851", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cdd29a5079b04f3f34dabc3495732ba43312851"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31dbaab57fef485412a0369a222b9c252ad2713b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31dbaab57fef485412a0369a222b9c252ad2713b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31dbaab57fef485412a0369a222b9c252ad2713b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31dbaab57fef485412a0369a222b9c252ad2713b/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6039cb96d1014373470a27f02e24c2c5e821a06c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6039cb96d1014373470a27f02e24c2c5e821a06c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6039cb96d1014373470a27f02e24c2c5e821a06c"}], "stats": {"total": 149, "additions": 81, "deletions": 68}, "files": [{"sha": "c49055d384ed7d49468f70a3aef3bbc250914adb", "filename": "gcc/cp/class.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -4708,6 +4708,10 @@ check_methods (tree t)\n     }\n }\n \n+/* FN is constructor, destructor or operator function.  Clone the\n+   declaration to create a NAME'd variant.  NEED_VTT_PARM_P and\n+   OMIT_INHERITED_PARMS_P are relevant if it's a cdtor.  */\n+\n static tree\n copy_fndecl_with_name (tree fn, tree name, tree_code code,\n \t\t       bool need_vtt_parm_p, bool omit_inherited_parms_p)\n@@ -6091,10 +6095,8 @@ check_bases_and_members (tree t)\n       }\n \n   if (LAMBDA_TYPE_P (t))\n-    {\n-      /* \"This class type is not an aggregate.\"  */\n-      CLASSTYPE_NON_AGGREGATE (t) = 1;\n-    }\n+    /* \"This class type is not an aggregate.\"  */\n+    CLASSTYPE_NON_AGGREGATE (t) = 1;\n \n   /* Compute the 'literal type' property before we\n      do anything with non-static member functions.  */\n@@ -6717,6 +6719,8 @@ layout_class_type (tree t, tree *virtuals_p)\n \t indicates the total number of bits used.  Therefore,\n \t rli_size_so_far, rather than rli_size_unit_so_far, is\n \t used to compute TYPE_SIZE_UNIT.  */\n+\n+      /* Set the size and alignment for the new type.  */\n       tree eoc = end_of_class (t, /*include_virtuals_p=*/0);\n       TYPE_SIZE_UNIT (base_t)\n \t= size_binop (MAX_EXPR,"}, {"sha": "31be2cf41a34ce768ea3eef8f55cccd34085344b", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -194,7 +194,9 @@ DEFTREECODE (BOUND_TEMPLATE_TEMPLATE_PARM, \"bound_template_template_parm\",\n \n /* For template template argument of the form `T::template C'.\n    TYPE_CONTEXT is `T', the template parameter dependent object.\n-   TYPE_NAME is an IDENTIFIER_NODE for `C', the member class template.  */\n+   TYPE_NAME is a TEMPLATE_DECL, whose DECL_TEMPLATE_PARMS are any\n+   template parms of the instantiation.  That decl's DECL_NAME is the\n+   IDENTIFIER_NODE for `C', the member class template.  */\n DEFTREECODE (UNBOUND_CLASS_TEMPLATE, \"unbound_class_template\", tcc_type, 0)\n \n /* A using declaration.  USING_DECL_SCOPE contains the specified"}, {"sha": "a599f3bad1cb82e8e9d0fd6cbdf3af06dd5e050b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 39, "deletions": 42, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions for C++ parsing and type checking.\n+/* Definitions for -*- C++ -*- parsing and type checking.\n    Copyright (C) 1987-2020 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com)\n \n@@ -391,7 +391,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       CLEANUP_P (in TRY_BLOCK)\n       AGGR_INIT_VIA_CTOR_P (in AGGR_INIT_EXPR)\n       PTRMEM_OK_P (in ADDR_EXPR, OFFSET_REF, SCOPE_REF)\n-      PAREN_STRING_LITERAL (in STRING_CST)\n+      PAREN_STRING_LITERAL_P (in STRING_CST)\n       CP_DECL_THREAD_LOCAL_P (in VAR_DECL)\n       KOENIG_LOOKUP_P (in CALL_EXPR)\n       STATEMENT_LIST_NO_SCOPE (in STATEMENT_LIST).\n@@ -486,7 +486,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       CALL_EXPR_REVERSE_ARGS (in CALL_EXPR, AGGR_INIT_EXPR)\n       CONSTRUCTOR_PLACEHOLDER_BOUNDARY (in CONSTRUCTOR)\n    6: TYPE_MARKED_P (in _TYPE)\n-      DECL_NON_TRIVIALLY_INITIALIZED_P (in VAR_DECL)\n+      DECL_NONTRIVIALLY_INITIALIZED_P (in VAR_DECL)\n       RANGE_FOR_IVDEP (in RANGE_FOR_STMT)\n       CALL_EXPR_OPERATOR_SYNTAX (in CALL_EXPR, AGGR_INIT_EXPR)\n       CONSTRUCTOR_IS_DESIGNATED_INIT (in CONSTRUCTOR)\n@@ -515,7 +515,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_VLA_CAPTURE_P (in FIELD_DECL)\n       DECL_ARRAY_PARAMETER_P (in PARM_DECL)\n       LABEL_DECL_CONTINUE (in LABEL_DECL)\n-   2: DECL_THIS_EXTERN (in VAR_DECL or FUNCTION_DECL).\n+   2: DECL_THIS_EXTERN (in VAR_DECL, FUNCTION_DECL or PARM_DECL)\n       DECL_IMPLICIT_TYPEDEF_P (in a TYPE_DECL)\n       DECL_CONSTRAINT_VAR_P (in a PARM_DECL)\n       TEMPLATE_DECL_COMPLEX_ALIAS_P (in TEMPLATE_DECL)\n@@ -527,7 +527,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       DECL_SELF_REFERENCE_P (in a TYPE_DECL)\n       DECL_INVALID_OVERRIDER_P (in a FUNCTION_DECL)\n    5: DECL_INTERFACE_KNOWN.\n-   6: DECL_THIS_STATIC (in VAR_DECL or FUNCTION_DECL).\n+   6: DECL_THIS_STATIC (in VAR_DECL, FUNCTION_DECL or PARM_DECL)\n       DECL_FIELD_IS_BASE (in FIELD_DECL)\n       TYPE_DECL_ALIAS_P (in TYPE_DECL)\n    7: DECL_THUNK_P (in a member FUNCTION_DECL)\n@@ -783,8 +783,7 @@ struct GTY(()) tree_overload {\n /* Iterator for a 1 dimensional overload.  Permits iterating over the\n    outer level of a 2-d overload when explicitly enabled.  */\n \n-class ovl_iterator\n-{\n+class ovl_iterator {\n   tree ovl;\n   const bool allow_inner; /* Only used when checking.  */\n \n@@ -872,8 +871,7 @@ class ovl_iterator\n /* Iterator over a (potentially) 2 dimensional overload, which is\n    produced by name lookup.  */\n \n-class lkp_iterator : public ovl_iterator\n-{\n+class lkp_iterator : public ovl_iterator {\n   typedef ovl_iterator parent;\n \n   tree outer;\n@@ -905,8 +903,7 @@ class lkp_iterator : public ovl_iterator\n /* hash traits for declarations.  Hashes potential overload sets via\n    DECL_NAME.  */\n \n-struct named_decl_hash : ggc_remove <tree>\n-{\n+struct named_decl_hash : ggc_remove <tree> {\n   typedef tree value_type; /* A DECL or OVERLOAD  */\n   typedef tree compare_type; /* An identifier.  */\n \n@@ -1356,8 +1353,8 @@ struct GTY (()) tree_trait_expr {\n   (IDENTIFIER_NODE_CHECK(NODE)->base.protected_flag)\n \n /* Based off of TYPE_UNNAMED_P.  */\n-#define LAMBDA_TYPE_P(NODE)\t\t\t\\\n-  (TREE_CODE (NODE) == RECORD_TYPE\t\t\\\n+#define LAMBDA_TYPE_P(NODE)\t\t\t\t\t\\\n+  (TREE_CODE (NODE) == RECORD_TYPE\t\t\t\t\\\n    && TYPE_LINKAGE_IDENTIFIER (NODE)\t\t\t\t\\\n    && IDENTIFIER_LAMBDA_P (TYPE_LINKAGE_IDENTIFIER (NODE)))\n \n@@ -2674,7 +2671,7 @@ struct GTY(()) lang_decl_base {\n /* DECL_LANG_SPECIFIC for the above codes.  */\n \n struct GTY(()) lang_decl_min {\n-  struct lang_decl_base base;\n+  struct lang_decl_base base; /* 32-bits.  */\n \n   /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n      THUNK_ALIAS.\n@@ -2737,8 +2734,7 @@ struct GTY(()) lang_decl_fn {\n \n   union lang_decl_u5\n   {\n-    /* In a non-thunk FUNCTION_DECL or TEMPLATE_DECL, this is\n-       DECL_CLONED_FUNCTION.  */\n+    /* In a non-thunk FUNCTION_DECL, this is DECL_CLONED_FUNCTION.  */\n     tree GTY ((tag (\"0\"))) cloned_function;\n \n     /* In a FUNCTION_DECL for which THUNK_P holds this is the\n@@ -2757,10 +2753,10 @@ struct GTY(()) lang_decl_fn {\n /* DECL_LANG_SPECIFIC for namespaces.  */\n \n struct GTY(()) lang_decl_ns {\n-  struct lang_decl_base base;\n+  struct lang_decl_base base; /* 32 bits.  */\n   cp_binding_level *level;\n \n-  /* Inline children.  These need to be va_gc, because of PCH.  */\n+  /* Inline children.  Needs to be va_gc, because of PCH.  */\n   vec<tree, va_gc> *inlinees;\n \n   /* Hash table of bound decls. It'd be nice to have this inline, but\n@@ -2772,7 +2768,7 @@ struct GTY(()) lang_decl_ns {\n /* DECL_LANG_SPECIFIC for parameters.  */\n \n struct GTY(()) lang_decl_parm {\n-  struct lang_decl_base base;\n+  struct lang_decl_base base; /* 32 bits.  */\n   int level;\n   int index;\n };\n@@ -3436,7 +3432,10 @@ struct GTY(()) lang_decl {\n    an instantiation of a template -- but, from the point of view of\n    the language, each instantiation of S results in a wholly unrelated\n    global function f.  In this case, DECL_TEMPLATE_INFO for S<int>::f\n-   will be non-NULL, but DECL_USE_TEMPLATE will be zero.  */\n+   will be non-NULL, but DECL_USE_TEMPLATE will be zero.\n+\n+   In a friend declaration, TI_TEMPLATE can be an overload set, or\n+   identifier.  */\n #define DECL_TEMPLATE_INFO(NODE) \\\n   (DECL_LANG_SPECIFIC (TEMPLATE_INFO_DECL_CHECK (NODE)) \\\n    ->u.min.template_info)\n@@ -4669,6 +4668,7 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    template parameters at each level.  Each element in the vector is a\n    TREE_LIST, whose TREE_VALUE is a PARM_DECL (if the parameter is a\n    non-type parameter), or a TYPE_DECL (if the parameter is a type\n+   parameter) or a TEMPLATE_DECL (if the parameter is a template\n    parameter).  The TREE_PURPOSE is the default value, if any.  The\n    TEMPLATE_PARM_INDEX for the parameter is available as the\n    DECL_INITIAL (for a PARM_DECL) or as the TREE_TYPE (for a\n@@ -5356,8 +5356,9 @@ extern GTY(()) tree integer_two_node;\n    function, two inside the body of a function in a local class, etc.)  */\n extern int function_depth;\n \n-/* Nonzero if we are inside eq_specializations, which affects comparison of\n-   PARM_DECLs in cp_tree_equal.  */\n+/* Nonzero if we are inside eq_specializations, which affects\n+   comparison of PARM_DECLs in cp_tree_equal and alias specializations\n+   in structrual_comptypes.  */\n extern int comparing_specializations;\n \n /* In parser.c.  */\n@@ -5812,28 +5813,26 @@ const unsigned int STF_STRIP_DEPENDENT = 1U << 1;\n extern void init_reswords (void);\n \n /* Various flags for the overloaded operator information.  */\n-enum ovl_op_flags\n-  {\n-    OVL_OP_FLAG_NONE = 0,\t/* Don't care.  */\n-    OVL_OP_FLAG_UNARY = 1,\t/* Is unary.  */\n-    OVL_OP_FLAG_BINARY = 2,\t/* Is binary.  */\n-    OVL_OP_FLAG_AMBIARY = 3,\t/* May be unary or binary.  */\n-    OVL_OP_FLAG_ALLOC = 4,  \t/* operator new or delete.  */\n-    OVL_OP_FLAG_DELETE = 1,\t/* operator delete.  */\n-    OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete.  */\n-  };\n+enum ovl_op_flags {\n+  OVL_OP_FLAG_NONE = 0,\t/* Don't care.  */\n+  OVL_OP_FLAG_UNARY = 1,\t/* Is unary.  */\n+  OVL_OP_FLAG_BINARY = 2,\t/* Is binary.  */\n+  OVL_OP_FLAG_AMBIARY = 3,\t/* May be unary or binary.  */\n+  OVL_OP_FLAG_ALLOC = 4,  \t/* operator new or delete.  */\n+  OVL_OP_FLAG_DELETE = 1,\t/* operator delete.  */\n+  OVL_OP_FLAG_VEC = 2\t\t/* vector new or delete.  */\n+};\n \n /* Compressed operator codes.  Order is determined by operators.def\n    and does not match that of tree_codes.  */\n-enum ovl_op_code\n-  {\n-    OVL_OP_ERROR_MARK,\n-    OVL_OP_NOP_EXPR,\n+enum ovl_op_code {\n+  OVL_OP_ERROR_MARK,\n+  OVL_OP_NOP_EXPR,\n #define DEF_OPERATOR(NAME, CODE, MANGLING, FLAGS) OVL_OP_##CODE,\n #define DEF_ASSN_OPERATOR(NAME, CODE, MANGLING) /* NOTHING */\n #include \"operators.def\"\n-    OVL_OP_MAX\n-  };\n+  OVL_OP_MAX\n+};\n \n struct GTY(()) ovl_op_info_t {\n   /* The IDENTIFIER_NODE for the operator.  */\n@@ -6771,8 +6770,6 @@ extern bool maybe_reject_flexarray_init\t\t(tree, tree);\n \n /* in lex.c */\n extern void cxx_dup_lang_specific_decl\t\t(tree);\n-extern void yyungetc\t\t\t\t(int, int);\n-\n extern tree unqualified_name_lookup_error\t(tree,\n \t\t\t\t\t\t location_t = UNKNOWN_LOCATION);\n extern tree unqualified_fn_lookup_error\t\t(cp_expr);\n@@ -7729,7 +7726,7 @@ extern tree mangle_tls_wrapper_fn\t\t(tree);\n extern bool decl_tls_wrapper_p\t\t\t(tree);\n extern tree mangle_ref_init_variable\t\t(tree);\n extern tree mangle_template_parm_object\t\t(tree);\n-extern char * get_mangled_vtable_map_var_name   (tree);\n+extern char *get_mangled_vtable_map_var_name    (tree);\n extern bool mangle_return_type_p\t\t(tree);\n extern tree mangle_decomp\t\t\t(tree, vec<tree> &);\n \n@@ -7983,7 +7980,7 @@ extern tree coro_validate_builtin_call\t\t(tree,\n extern bool morph_fn_to_coro\t\t\t(tree, tree *, tree *);\n \n /* Inline bodies.  */\n-\n+  \n inline tree\n ovl_first (tree node)\n {"}, {"sha": "5a262436cd39a96ce625b2d2c0aba0eb74358bc7", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -942,8 +942,11 @@ function_requirements_equivalent_p (tree newfn, tree oldfn)\n   tree reqs2 = get_trailing_function_requirements (oldfn);\n   if ((reqs1 != NULL_TREE) != (reqs2 != NULL_TREE))\n     return false;\n+\n+  /* Substitution is needed when friends are involved.  */\n   reqs1 = maybe_substitute_reqs_for (reqs1, newfn);\n   reqs2 = maybe_substitute_reqs_for (reqs2, oldfn);\n+\n   return cp_tree_equal (reqs1, reqs2);\n }\n \n@@ -2527,7 +2530,7 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n \n       /* Merge parameter attributes. */\n       tree oldarg, newarg;\n-      for (oldarg = DECL_ARGUMENTS(olddecl),  newarg = DECL_ARGUMENTS(newdecl);\n+      for (oldarg = DECL_ARGUMENTS(olddecl), newarg = DECL_ARGUMENTS(newdecl);\n            oldarg && newarg;\n            oldarg = DECL_CHAIN(oldarg), newarg = DECL_CHAIN(newarg))\n \t{\n@@ -2737,13 +2740,15 @@ duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n     TREE_USED (newdecl) = 1;\n   else if (TREE_USED (newdecl))\n     TREE_USED (olddecl) = 1;\n+\n   if (VAR_P (newdecl))\n     {\n       if (DECL_READ_P (olddecl))\n \tDECL_READ_P (newdecl) = 1;\n       else if (DECL_READ_P (newdecl))\n \tDECL_READ_P (olddecl) = 1;\n     }\n+\n   if (DECL_PRESERVE_P (olddecl))\n     DECL_PRESERVE_P (newdecl) = 1;\n   else if (DECL_PRESERVE_P (newdecl))\n@@ -4683,9 +4688,9 @@ cp_make_fname_decl (location_t loc, tree id, int type_dep)\n   return decl;\n }\n \n-/* Install DECL as a builtin function at current (global) scope.\n-   Return the new decl (if we found an existing version).  Also\n-   installs it into ::std, if it's not '_*'.  */\n+/* Install DECL as a builtin function at current global scope.  Return\n+   the new decl (if we found an existing version).  Also installs it\n+   into ::std, if it's not '_*'.  */\n \n tree\n cxx_builtin_function (tree decl)\n@@ -13423,6 +13428,7 @@ grokdeclarator (const cp_declarator *declarator,\n \t\t     in-class defaulted functions, but that breaks grokfndecl.\n \t\t     So set it here.  */\n \t\t  funcdef_flag = true;\n+\n \t\tif (template_class_depth (current_class_type) == 0)\n \t\t  {\n \t\t    decl = check_explicit_specialization"}, {"sha": "5bada506a2ded0bf8370a205d545544c0d7121a0", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -2215,6 +2215,7 @@ decl_needed_p (tree decl)\n      emitted; they may be referred to from other object files.  */\n   if (TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_REALLY_EXTERN (decl))\n     return true;\n+\n   /* Functions marked \"dllexport\" must be emitted so that they are\n      visible to other DLLs.  */\n   if (flag_keep_inline_dllexport\n@@ -2725,8 +2726,7 @@ determine_visibility (tree decl)\n     determine_visibility_from_class (decl, class_type);\n \n   if (decl_anon_ns_mem_p (decl))\n-    /* Names in an anonymous namespace get internal linkage.\n-       This might change once we implement export.  */\n+    /* Names in an anonymous namespace get internal linkage.  */\n     constrain_visibility (decl, VISIBILITY_ANON, false);\n   else if (TREE_CODE (decl) != TYPE_DECL)\n     {\n@@ -4492,11 +4492,13 @@ no_linkage_error (tree decl)\n \t      && TREE_NO_WARNING (decl))))\n     /* In C++11 it's ok if the decl is defined.  */\n     return;\n+\n   tree t = no_linkage_check (TREE_TYPE (decl), /*relaxed_p=*/false);\n   if (t == NULL_TREE)\n     /* The type that got us on no_linkage_decls must have gotten a name for\n        linkage purposes.  */;\n   else if (CLASS_TYPE_P (t) && TYPE_BEING_DEFINED (t))\n+    // FIXME: This is now invalid, as a DR to c++98\n     /* The type might end up having a typedef name for linkage purposes.  */\n     vec_safe_push (no_linkage_decls, decl);\n   else if (TYPE_UNNAMED_P (t))"}, {"sha": "1058fd05a7d20481d977309a28f366c70e30d529", "filename": "gcc/cp/method.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -563,13 +563,16 @@ ctor_omit_inherited_parms (tree fn)\n   if (!DECL_BASE_CONSTRUCTOR_P (fn)\n       || !CLASSTYPE_VBASECLASSES (DECL_CONTEXT (fn)))\n     return false;\n+\n   if (FUNCTION_FIRST_USER_PARMTYPE (DECL_ORIGIN (fn)) == void_list_node)\n     /* No user-declared parameters to omit.  */\n     return false;\n+\n   tree binfo = inherited_ctor_binfo (fn);\n   for (; binfo; binfo = BINFO_INHERITANCE_CHAIN (binfo))\n     if (BINFO_VIRTUAL_P (binfo))\n       return true;\n+\n   return false;\n }\n "}, {"sha": "9f30d907a0909764fe118f1ca00b4984cb7ccaf6", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -124,13 +124,11 @@ add_decl_to_level (cp_binding_level *b, tree decl)\n   TREE_CHAIN (decl) = b->names;\n   b->names = decl;\n \n-  /* If appropriate, add decl to separate list of statics.  We\n-     include extern variables because they might turn out to be\n-     static later.  It's OK for this list to contain a few false\n-     positives.  */\n+  /* If appropriate, add decl to separate list of statics.  We include\n+     extern variables because they might turn out to be static later.\n+     It's OK for this list to contain a few false positives.  */\n   if (b->kind == sk_namespace\n-      && ((VAR_P (decl)\n-\t   && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n+      && ((VAR_P (decl) && (TREE_STATIC (decl) || DECL_EXTERNAL (decl)))\n \t  || (TREE_CODE (decl) == FUNCTION_DECL\n \t      && (!TREE_PUBLIC (decl)\n \t\t  || decl_anon_ns_mem_p (decl)\n@@ -727,6 +725,7 @@ name_lookup::search_unqualified (tree scope, cp_binding_level *level)\n \tbreak;\n     }\n \n+  /* Restore to incoming length.  */\n   vec_safe_truncate (queue, length);\n \n   return found;\n@@ -1670,7 +1669,7 @@ member_vec_dedup (vec<tree, va_gc> *member_vec)\n    no existing MEMBER_VEC and fewer than 8 fields, do nothing.  We\n    know there must be at least 1 field -- the self-reference\n    TYPE_DECL, except for anon aggregates, which will have at least\n-   one field.  */\n+   one field anyway.  */\n \n void \n set_class_bindings (tree klass, unsigned extra)\n@@ -3692,7 +3691,6 @@ debug (cp_binding_level *ptr)\n     fprintf (stderr, \"<nil>\\n\");\n }\n \n-\n static void\n print_other_binding_stack (cp_binding_level *stack)\n {\n@@ -3704,7 +3702,7 @@ print_other_binding_stack (cp_binding_level *stack)\n     }\n }\n \n-void\n+DEBUG_FUNCTION void\n print_binding_stack (void)\n {\n   cp_binding_level *b;\n@@ -5273,7 +5271,6 @@ using_directives_contain_std_p (vec<tree, va_gc> *usings)\n static bool\n has_using_namespace_std_directive_p ()\n {\n-  /* Look at local using-directives.  */\n   for (cp_binding_level *level = current_binding_level;\n        level;\n        level = level->level_chain)"}, {"sha": "4e1c77a6bd73b3fcee9785a1ed38655f178ab297", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -5986,7 +5986,6 @@ push_template_decl_real (tree decl, bool is_friend)\n \n   gcc_checking_assert (DECL_TEMPLATE_RESULT (tmpl) == decl);\n \n-\n   if (new_template_p)\n     {\n       /* Push template declarations for global functions and types."}, {"sha": "7d32904954949b6f9d9ceea36258a31323511b97", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -41,6 +41,7 @@ cxx_print_decl (FILE *file, tree node, int indent)\n   if (!CODE_CONTAINS_STRUCT (TREE_CODE (node), TS_DECL_COMMON)\n       || !DECL_LANG_SPECIFIC (node))\n     return;\n+\n   if (TREE_CODE (node) == FUNCTION_DECL)\n     {\n       int flags = TFF_DECL_SPECIFIERS|TFF_RETURN_TYPE\n@@ -218,8 +219,8 @@ cxx_print_xnode (FILE *file, tree node, int indent)\n       print_node (file, \"optype\", BASELINK_OPTYPE (node), indent + 4);\n       break;\n     case OVERLOAD:\n-      print_node (file, \"function\", OVL_FUNCTION (node), indent+4);\n-      print_node (file, \"next\", OVL_CHAIN (node), indent+4);\n+      print_node (file, \"function\", OVL_FUNCTION (node), indent + 4);\n+      print_node (file, \"next\", OVL_CHAIN (node), indent + 4);\n       break;\n     case TEMPLATE_PARM_INDEX:\n       print_node (file, \"decl\", TEMPLATE_PARM_DECL (node), indent+4);"}, {"sha": "d43248cba7cd90aeb0f1f2166dc242978aa5b824", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -62,7 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Auxiliary data we hold for each type_info derived object we need.  */\n struct GTY (()) tinfo_s {\n-  tree type;  /* The RECORD_TYPE for this type_info object */\n+  tree type;  /* The (const-qualified) RECORD_TYPE for this type_info object */\n \n   tree vtable; /* The VAR_DECL of the vtable.  Only filled at end of\n \t\t  translation.  */\n@@ -458,6 +458,7 @@ get_tinfo_decl (tree type)\n       DECL_IGNORED_P (d) = 1;\n       TREE_READONLY (d) = 1;\n       TREE_STATIC (d) = 1;\n+\n       /* Mark the variable as undefined -- but remember that we can\n \t define it later if we need to do so.  */\n       DECL_EXTERNAL (d) = 1;"}, {"sha": "a830c90a78f0d2dfa8c36ed5787035e404ca2812", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -2296,7 +2296,7 @@ ovl_skip_hidden (tree ovl)\n   return ovl;\n }\n \n-/* NODE is an OVL_HIDDEN_P node which is now revealed.  */\n+/* NODE is an OVL_HIDDEN_P node that is now revealed.  */\n \n tree\n ovl_iterator::reveal_node (tree overload, tree node)"}, {"sha": "589e014f8552df6946a9335a77f399b1e9ed3efd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31dbaab57fef485412a0369a222b9c252ad2713b/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=31dbaab57fef485412a0369a222b9c252ad2713b", "patch": "@@ -1384,6 +1384,7 @@ structural_comptypes (tree t1, tree t2, int strict)\n \n     case METHOD_TYPE:\n     case FUNCTION_TYPE:\n+      /* Exception specs and memfn_rquals were checked above.  */\n       if (!same_type_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n \treturn false;\n       if (!compparms (TYPE_ARG_TYPES (t1), TYPE_ARG_TYPES (t2)))"}]}