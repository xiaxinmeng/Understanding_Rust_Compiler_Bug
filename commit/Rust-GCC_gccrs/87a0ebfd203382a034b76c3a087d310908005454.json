{"sha": "87a0ebfd203382a034b76c3a087d310908005454", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODdhMGViZmQyMDMzODJhMDM0Yjc2YzNhMDg3ZDMxMDkwODAwNTQ1NA==", "commit": {"author": {"name": "Sriraman Tallam", "email": "tmsriram@google.com", "date": "2010-05-12T21:15:19Z"}, "committer": {"name": "Sriraman Tallam", "email": "tmsriram@gcc.gnu.org", "date": "2010-05-12T21:15:19Z"}, "message": "implicit-zee.c: New file.\n\n\t* implicit-zee.c: New file.\n\t* tree-pass.h (pass_implicit_zee): Declare.\n\t* passes.c (init_optimization_passes): Add zee pass.\n\t* common.opt (fzee): New flag.\n\t* timevar.def (TV_ZEE): Define.\n\t* config/i386/i386.c (optimization_options): Turn on ZEE for level 2\n\tand beyond.\n\t* Makefile.in (implicit-zee.o): Add new build file.\n\t* gcc.target/i386/zee.c: New file.\n\nFrom-SVN: r159342", "tree": {"sha": "837e3d3fd54b1faaeb2e9d27366cb2d163dda50b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/837e3d3fd54b1faaeb2e9d27366cb2d163dda50b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/87a0ebfd203382a034b76c3a087d310908005454", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a0ebfd203382a034b76c3a087d310908005454", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87a0ebfd203382a034b76c3a087d310908005454", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a0ebfd203382a034b76c3a087d310908005454/comments", "author": {"login": "tmsri", "id": 38991943, "node_id": "MDQ6VXNlcjM4OTkxOTQz", "avatar_url": "https://avatars.githubusercontent.com/u/38991943?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tmsri", "html_url": "https://github.com/tmsri", "followers_url": "https://api.github.com/users/tmsri/followers", "following_url": "https://api.github.com/users/tmsri/following{/other_user}", "gists_url": "https://api.github.com/users/tmsri/gists{/gist_id}", "starred_url": "https://api.github.com/users/tmsri/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tmsri/subscriptions", "organizations_url": "https://api.github.com/users/tmsri/orgs", "repos_url": "https://api.github.com/users/tmsri/repos", "events_url": "https://api.github.com/users/tmsri/events{/privacy}", "received_events_url": "https://api.github.com/users/tmsri/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "01f0a9dcccaf952ac7b4fe9ce45fef92bc3ea362", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01f0a9dcccaf952ac7b4fe9ce45fef92bc3ea362", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01f0a9dcccaf952ac7b4fe9ce45fef92bc3ea362"}], "stats": {"total": 1050, "additions": 1049, "deletions": 1}, "files": [{"sha": "2e9daf4db98bf4c4ba7099b5c35db75c66dc1764", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1,3 +1,14 @@\n+2010-05-12  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* implicit-zee.c: New file.\n+\t* tree-pass.h (pass_implicit_zee): Declare.\n+\t* passes.c (init_optimization_passes): Add zee pass.\n+\t* common.opt (fzee): New flag.\n+\t* timevar.def (TV_ZEE): Define.\n+\t* config/i386/i386.c (optimization_options): Turn on ZEE for level 2\n+\tand beyond.\n+\t* Makefile.in (implicit-zee.o): Add new build file.\n+\n 2010-05-12  Kazu Hirata  <kazu@codesourcery.com>\n \t    Nathan Froyd  <froydnj@codesourcery.com>\n "}, {"sha": "9fef0cee2be2b13846b38a7e095ff8e84f057c0d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1229,6 +1229,7 @@ OBJS-common = \\\n \thaifa-sched.o \\\n \thooks.o \\\n \tifcvt.o \\\n+\timplicit-zee.o \\\n \tinit-regs.o \\\n \tintegrate.o \\\n \tintl.o \\\n@@ -2977,6 +2978,11 @@ fwprop.o : fwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n web.o : web.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \\\n    insn-config.h $(RECOG_H) $(DF_H) $(OBSTACK_H) $(TIMEVAR_H) $(TREE_PASS_H)\n+implicit-zee.o : implicit-zee.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n+   hard-reg-set.h $(FLAGS_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h \\\n+   $(DF_H) $(TIMEVAR_H) tree-pass.h $(RECOG_H) $(EXPR_H) \\\n+   $(REGS_H) $(TREE_H) $(TM_P_H) insn-config.h $(INSN_ATTR_H) $(REAL_H) $(TOPLEV_H) \\\n+   $(TARGET_H) $(OPTABS_H) insn-codes.h rtlhooks-def.h $(PARAMS_H) $(CGRAPH_H)\n gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(REGS_H) hard-reg-set.h $(FLAGS_H) $(REAL_H) insn-config.h $(GGC_H) \\\n    $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) $(FUNCTION_H) output.h $(TOPLEV_H) \\"}, {"sha": "e9a0695f20b59eef79ddcf0964c860e0dcac4d24", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1147,6 +1147,10 @@ fsee\n Common\n Does nothing.  Preserved for backward compatibility.\n \n+fzee\n+Common Report Var(flag_zee) Init(0)\n+Eliminate redundant zero extensions on targets that support implicit extensions.\n+\n fshow-column\n Common C ObjC C++ ObjC++ Report Var(flag_show_column) Init(1)\n Show column numbers in diagnostics, when available.  Default on"}, {"sha": "ee5e931f3aa4a74c2f7568295bcf4638381a56fb", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -4289,6 +4289,10 @@ optimization_options (int level, int size ATTRIBUTE_UNUSED)\n     flag_schedule_insns = 0;\n #endif\n \n+  /* For -O2 and beyond, turn on -fzee for x86_64 target. */\n+  if (level > 1 && TARGET_64BIT)\n+    flag_zee = 1;\n+\n   if (TARGET_MACHO)\n     /* The Darwin libraries never set errno, so we might as well\n        avoid calling them when that's the only reason we would.  */"}, {"sha": "12cdfd95166b9e22a602b1a468ee62e8243b3bba", "filename": "gcc/implicit-zee.c", "status": "added", "additions": 1002, "deletions": 0, "changes": 1002, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fimplicit-zee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fimplicit-zee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fimplicit-zee.c?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -0,0 +1,1002 @@\n+/* Redundant Zero-extension elimination for targets that implicitly\n+   zero-extend writes to the lower 32-bit portion of 64-bit registers.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Sriraman Tallam (tmsriram@google.com) and\n+                  Silvius Rus     (rus@google.com)\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+\n+/* Problem Description :\n+   --------------------\n+   This pass is intended to be applicable only to targets that implicitly\n+   zero-extend 64-bit registers after writing to their lower 32-bit half.\n+   For instance, x86_64 zero-extends the upper bits of a register\n+   implicitly whenever an instruction writes to its lower 32-bit half.\n+   For example, the instruction *add edi,eax* also zero-extends the upper\n+   32-bits of rax after doing the addition.  These zero extensions come\n+   for free and GCC does not always exploit this well.  That is, it has\n+   been observed that there are plenty of cases where GCC explicitly\n+   zero-extends registers for x86_64 that are actually useless because\n+   these registers were already implicitly zero-extended in a prior\n+   instruction.  This pass tries to eliminate such useless zero extension\n+   instructions.\n+\n+   How does this pass work  ?\n+   --------------------------\n+\n+   This pass is run after register allocation.  Hence, all registers that\n+   this pass deals with are hard registers.  This pass first looks for a\n+   zero-extension instruction that could possibly be redundant. Such zero\n+   extension instructions show up in RTL with the pattern :\n+   (set (reg:DI x) (zero_extend:DI (reg:SI x))).\n+   where x can be any one of the 64-bit hard registers.\n+   Now, this pass tries to eliminate this instruction by merging the\n+   zero-extension with the definitions of register x. For instance, if\n+   one of the definitions of register x was  :\n+   (set (reg:SI x) (plus:SI (reg:SI z1) (reg:SI z2))),\n+   then the combination converts this into :\n+   (set (reg:DI x) (zero_extend:DI (plus:SI (reg:SI z1) (reg:SI z2)))).\n+   If all the merged definitions are recognizable assembly instructions,\n+   the zero-extension is effectively eliminated.  For example, in x86_64,\n+   implicit zero-extensions are captured with appropriate patterns in the\n+   i386.md file.  Hence, these merged definition can be matched to a single\n+   assembly instruction.  The original zero-extension instruction is then\n+   deleted if all the definitions can be merged.\n+\n+   However, there are cases where the definition instruction cannot be\n+   merged with a zero-extend.  Examples are CALL instructions.  In such\n+   cases, the original zero extension is not redundant and this pass does\n+   not delete it.\n+\n+   Handling conditional moves :\n+   ----------------------------\n+\n+   Architectures like x86_64 support conditional moves whose semantics for\n+   zero-extension differ from the other instructions.  For instance, the\n+   instruction *cmov ebx, eax*\n+   zero-extends eax onto rax only when the move from ebx to eax happens.\n+   Otherwise, eax may not be zero-extended.  Conditional moves appear as\n+   RTL instructions of the form\n+   (set (reg:SI x) (if_then_else (cond) (reg:SI y) (reg:SI z))).\n+   This pass tries to merge a zero-extension with a conditional move by\n+   actually merging the defintions of y and z with a zero-extend and then\n+   converting the conditional move into :\n+   (set (reg:DI x) (if_then_else (cond) (reg:DI y) (reg:DI z))).\n+   Since registers y and z are zero-extended, register x will also be\n+   zero-extended after the conditional move.  Note that this step has to\n+   be done transitively since the definition of a conditional copy can be\n+   another conditional copy.\n+\n+   Motivating Example I :\n+   ---------------------\n+   For this program :\n+   **********************************************\n+   bad_code.c\n+\n+   int mask[1000];\n+\n+   int foo(unsigned x)\n+   {\n+     if (x < 10)\n+       x = x * 45;\n+     else\n+       x = x * 78;\n+     return mask[x];\n+   }\n+   **********************************************\n+\n+   $ gcc -O2 -fsee bad_code.c (Turned on existing sign-extension elimination.)\n+     ........\n+     400315:       b8 4e 00 00 00          mov    $0x4e,%eax\n+     40031a:       0f af f8                imul   %eax,%edi\n+     40031d:       89 ff                   mov    %edi,%edi  ---> Useless extend.\n+     40031f:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax\n+     400326:       c3                      retq\n+     ......\n+     400330:       ba 2d 00 00 00          mov    $0x2d,%edx\n+     400335:       0f af fa                imul   %edx,%edi\n+     400338:       89 ff                   mov    %edi,%edi  ---> Useless extend.\n+     40033a:       8b 04 bd 60 19 40 00    mov    0x401960(,%rdi,4),%eax\n+     400341:       c3                      retq\n+\n+   $ gcc -O2 -fzee bad_code.c\n+     ......\n+     400315:       6b ff 4e                imul   $0x4e,%edi,%edi\n+     400318:       8b 04 bd 40 19 40 00    mov    0x401940(,%rdi,4),%eax\n+     40031f:       c3                      retq\n+     400320:       6b ff 2d                imul   $0x2d,%edi,%edi\n+     400323:       8b 04 bd 40 19 40 00    mov    0x401940(,%rdi,4),%eax\n+     40032a:       c3                      retq\n+\n+   Motivating Example II :\n+   ---------------------\n+\n+   Here is an example with a conditional move.\n+\n+   For this program :\n+   **********************************************\n+\n+   unsigned long long foo(unsigned x , unsigned y)\n+   {\n+     unsigned z;\n+     if (x > 100)\n+       z = x + y;\n+     else\n+       z = x - y;\n+     return (unsigned long long)(z);\n+   }\n+\n+   $ gcc -O2 -fsee bad_code.c (Turned on existing sign-extension elimination.)\n+     ............\n+     400360:       8d 14 3e                lea    (%rsi,%rdi,1),%edx\n+     400363:       89 f8                   mov    %edi,%eax\n+     400365:       29 f0                   sub    %esi,%eax\n+     400367:       83 ff 65                cmp    $0x65,%edi\n+     40036a:       0f 43 c2                cmovae %edx,%eax\n+     40036d:       89 c0                   mov    %eax,%eax ---> Useless extend.\n+     40036f:       c3                      retq\n+\n+   $ gcc -O2 -fzee bad_code.c\n+     .............\n+     400360:       89 fa                   mov    %edi,%edx\n+     400362:       8d 04 3e                lea    (%rsi,%rdi,1),%eax\n+     400365:       29 f2                   sub    %esi,%edx\n+     400367:       83 ff 65                cmp    $0x65,%edi\n+     40036a:       89 d6                   mov    %edx,%esi\n+     40036c:       48 0f 42 c6             cmovb  %rsi,%rax\n+     400370:       c3                      retq\n+\n+\n+   Usefulness :\n+   ----------\n+\n+   This pass reduces the dynamic instruction count of a compression benchmark by\n+   2.8% and improves its run-time by about 1%.  The compression benchmark had the\n+   following code sequence in a very hot region of code before ZEE optimized it :\n+\n+   shr $0x5, %edx\n+   mov %edx, %edx --> Useless zero-extend.\n+\n+   How to turn on ?\n+   ----------------\n+   -fzee -O2.  */\n+\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tree.h\"\n+#include \"tm_p.h\"\n+#include \"flags.h\"\n+#include \"regs.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"insn-config.h\"\n+#include \"function.h\"\n+#include \"expr.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"real.h\"\n+#include \"toplev.h\"\n+#include \"target.h\"\n+#include \"timevar.h\"\n+#include \"optabs.h\"\n+#include \"insn-codes.h\"\n+#include \"rtlhooks-def.h\"\n+/* Include output.h for dump_file.  */\n+#include \"output.h\"\n+#include \"params.h\"\n+#include \"timevar.h\"\n+#include \"tree-pass.h\"\n+#include \"df.h\"\n+#include \"cgraph.h\"\n+\n+/* This says if a register is newly created for the purpose of\n+   zero-extension.  */\n+\n+enum insn_merge_code\n+{\n+  MERGE_NOT_ATTEMPTED = 0,\n+  MERGE_SUCCESS\n+};\n+\n+/* This says if a INSN UID or its definition has already been merged\n+   with a zero-extend or not.  */\n+\n+static enum insn_merge_code *is_insn_merge_attempted;\n+static int max_insn_uid;\n+\n+/* Returns the merge code status for INSN.  */\n+\n+static enum insn_merge_code\n+get_insn_status (rtx insn)\n+{\n+  gcc_assert (INSN_UID (insn) < max_insn_uid);\n+  return is_insn_merge_attempted[INSN_UID (insn)];\n+}\n+\n+/* Sets the merge code status of INSN to CODE.  */\n+\n+static void\n+set_insn_status (rtx insn, enum insn_merge_code code)\n+{\n+  gcc_assert (INSN_UID (insn) < max_insn_uid);\n+  is_insn_merge_attempted[INSN_UID (insn)] = code;\n+}\n+\n+/* Check to see if this zero-extend matches a pattern\n+   that could be eliminated.  This is called via\n+   for_each_rtx in function find_and_remove_ze.  */\n+\n+static int\n+is_set_with_extension_DI (rtx *expr, void *data)\n+{\n+  /* Looking only for patterns of the type :\n+     SET (REG:DI X) (ZERO_EXTEND (REG:SI x))\n+   */\n+\n+  if (GET_CODE (*expr) == SET\n+      && GET_MODE (SET_DEST (*expr)) == DImode\n+      && GET_CODE (SET_DEST (*expr)) == REG\n+      && GET_CODE (SET_SRC (*expr)) == ZERO_EXTEND\n+      && GET_CODE (XEXP (SET_SRC (*expr),0)) == REG\n+      && GET_MODE (XEXP (SET_SRC (*expr),0)) == SImode\n+      && REGNO (SET_DEST (*expr)) == REGNO (XEXP (SET_SRC (*expr),0)))\n+        {\n+          *(rtx **)(data) = expr;\n+          return 1;\n+        }\n+  return 0;\n+}\n+\n+/* Given a insn (CURR_INSN) and a pointer to the SET rtx (ORIG_SET)\n+   that needs to be modified, this code modifies the SET rtx to a\n+   new SET rtx that zero_extends the right hand expression into a DImode\n+   register (NEWREG) on the left hand side.  Note that multiple\n+   assumptions are made about the nature of the set that needs\n+   to be true for this to work and is called from merge_def_and_ze.\n+\n+   Original :\n+   (set (reg:SI a) (expression))\n+\n+   Transform :\n+   (set (reg:DI a) (zero_extend (expression)))\n+\n+   Special Cases :\n+   If the expression is a constant or another zero_extend directly\n+   assign it to the DI mode register.  */\n+\n+static bool\n+combine_set_zero_extend (rtx curr_insn, rtx *orig_set, rtx newreg)\n+{\n+  rtx temp_extension, simplified_temp_extension, new_set, new_const_int;\n+  rtx orig_src;\n+  HOST_WIDE_INT val;\n+  unsigned int mask, delta_width;\n+\n+  /* Change the SET rtx and validate it.  */\n+  orig_src = SET_SRC (*orig_set);\n+  new_set = NULL_RTX;\n+\n+  /* The right hand side can also be VOIDmode.  These cases have to be\n+     handled differently.  */\n+\n+  if (GET_MODE (orig_src) != SImode)\n+    {\n+      /* Merge constants by directly moving the constant into the\n+         DImode register under some conditions.  */\n+\n+      if (GET_CODE (orig_src) == CONST_INT\n+\t  && HOST_BITS_PER_WIDE_INT >= GET_MODE_BITSIZE (SImode))\n+        {\n+          if (INTVAL (orig_src) >= 0)\n+            new_set = gen_rtx_SET (VOIDmode, newreg, orig_src);\n+          else if (INTVAL (orig_src) < 0)\n+            {\n+              /* Zero-extending a negative SImode integer into DImode\n+                 makes it a positive integer.  Convert the given negative\n+                 integer into the appropriate integer when zero-extended.  */\n+\n+              delta_width = HOST_BITS_PER_WIDE_INT - GET_MODE_BITSIZE (SImode);\n+              mask = (~(unsigned HOST_WIDE_INT) 0) >> delta_width;\n+              val = INTVAL (orig_src);\n+              val = val & mask;\n+              new_const_int = gen_rtx_CONST_INT (VOIDmode, val);\n+              new_set = gen_rtx_SET (VOIDmode, newreg, new_const_int);\n+            }\n+          else\n+            return false;\n+        }\n+      else\n+        {\n+          /* This is mostly due to a call insn that should not be\n+             optimized.  */\n+\n+          return false;\n+        }\n+    }\n+  else if (GET_CODE (orig_src) == ZERO_EXTEND)\n+    {\n+      /* Here a zero-extend is used to get to SI. Why not make it\n+         all the  way till DI.  */\n+\n+      temp_extension = gen_rtx_ZERO_EXTEND (DImode, XEXP (orig_src, 0));\n+      simplified_temp_extension = simplify_rtx (temp_extension);\n+      if (simplified_temp_extension)\n+        temp_extension = simplified_temp_extension;\n+      new_set = gen_rtx_SET (VOIDmode, newreg, temp_extension);\n+    }\n+  else if (GET_CODE (orig_src) == IF_THEN_ELSE)\n+    {\n+      /* Only IF_THEN_ELSE of phi-type copies are combined. Otherwise,\n+         in general, IF_THEN_ELSE should not be combined.  */\n+\n+      return false;\n+    }\n+  else\n+    {\n+      /* This is the normal case we expect.  */\n+\n+      temp_extension = gen_rtx_ZERO_EXTEND (DImode, orig_src);\n+      simplified_temp_extension = simplify_rtx (temp_extension);\n+      if (simplified_temp_extension)\n+        temp_extension = simplified_temp_extension;\n+      new_set = gen_rtx_SET (VOIDmode, newreg, temp_extension);\n+    }\n+\n+  gcc_assert (new_set != NULL_RTX);\n+\n+  /* This change is a part of a group of changes. Hence,\n+     validate_change will not try to commit the change.  */\n+\n+  if (validate_change (curr_insn, orig_set, new_set, true))\n+    {\n+      if (dump_file)\n+        {\n+          fprintf (dump_file, \"Merged Instruction with ZERO_EXTEND:\\n\");\n+          print_rtl_single (dump_file, curr_insn);\n+        }\n+      return true;\n+    }\n+  return false;\n+}\n+\n+/* This returns the DI mode for the SI register REG_SI.  */\n+\n+static rtx\n+get_reg_di (rtx reg_si)\n+{\n+  rtx newreg;\n+\n+  newreg = gen_rtx_REG (DImode, REGNO (reg_si));\n+  gcc_assert (newreg);\n+  return newreg;\n+}\n+\n+/* Treat if_then_else insns, where the operands of both branches\n+   are registers, as copies. For instance,\n+   Original :\n+   (set (reg:SI a) (if_then_else (cond) (reg:SI b) (reg:SI c)))\n+   Transformed :\n+   (set (reg:DI a) (if_then_else (cond) (reg:DI b) (reg:DI c)))\n+   DEF_INSN is the if_then_else insn.  */\n+\n+static bool\n+transform_ifelse (rtx def_insn)\n+{\n+  rtx set_insn = PATTERN (def_insn);\n+  rtx srcreg, dstreg, srcreg2;\n+  rtx map_srcreg, map_dstreg, map_srcreg2;\n+  rtx ifexpr;\n+  rtx cond;\n+  rtx new_set;\n+\n+  gcc_assert (GET_CODE (set_insn) == SET);\n+  cond = XEXP (SET_SRC (set_insn), 0);\n+  dstreg = SET_DEST (set_insn);\n+  srcreg = XEXP (SET_SRC (set_insn), 1);\n+  srcreg2 = XEXP (SET_SRC (set_insn), 2);\n+  map_srcreg = get_reg_di (srcreg);\n+  map_srcreg2 = get_reg_di (srcreg2);\n+  map_dstreg = get_reg_di (dstreg);\n+  ifexpr = gen_rtx_IF_THEN_ELSE (DImode, cond, map_srcreg, map_srcreg2);\n+  new_set = gen_rtx_SET (VOIDmode, map_dstreg, ifexpr);\n+\n+  if (validate_change (def_insn, &PATTERN (def_insn), new_set, true))\n+    {\n+      if (dump_file)\n+        {\n+          fprintf (dump_file, \"Cond_Move Instruction's mode extended :\\n\");\n+          print_rtl_single (dump_file, def_insn);\n+        }\n+      return true;\n+    }\n+  else\n+    return false;\n+}\n+\n+/* Function to get all the immediate definitions of an instruction.\n+   The reaching definitions are desired for WHICH_REG used in\n+   CURR_INSN.  This function returns 0 if there was an error getting\n+   a definition.  Upon success, this function returns the number of\n+   definitions and stores the definitions in DEST.  */\n+\n+static int\n+get_defs (rtx curr_insn, rtx which_reg, VEC (rtx,heap) **dest)\n+{\n+  df_ref reg_info, *defs;\n+  struct df_link *def_chain;\n+  int n_refs = 0;\n+\n+  defs = DF_INSN_USES (curr_insn);\n+  reg_info = NULL;\n+\n+  while (*defs)\n+    {\n+      reg_info = *defs;\n+      if (GET_CODE (DF_REF_REG (reg_info)) == SUBREG)\n+        return 0;\n+      if (REGNO (DF_REF_REG (reg_info)) == REGNO (which_reg))\n+        break;\n+      defs++;\n+    }\n+\n+  gcc_assert (reg_info != NULL && defs != NULL);\n+  def_chain = DF_REF_CHAIN (reg_info);\n+\n+  while (def_chain)\n+    {\n+      /* Problem getting some definition for this instruction.  */\n+\n+      if (def_chain->ref == NULL)\n+        return 0;\n+      if (DF_REF_INSN_INFO (def_chain->ref) == NULL)\n+        return 0;\n+      def_chain = def_chain->next;\n+    }\n+\n+  def_chain = DF_REF_CHAIN (reg_info);\n+\n+  if (dest == NULL)\n+    return 1;\n+\n+  while (def_chain)\n+    {\n+      VEC_safe_push (rtx, heap, *dest, DF_REF_INSN (def_chain->ref));\n+      def_chain = def_chain->next;\n+      n_refs++;\n+    }\n+  return n_refs;\n+}\n+\n+/* rtx function to check if this SET insn, EXPR, is a conditional copy insn :\n+   (set (reg:SI a ) (IF_THEN_ELSE (cond) (reg:SI b) (reg:SI c)))\n+   Called from is_insn_cond_copy.  DATA stores the two registers on each\n+   side of the condition.  */\n+\n+static int\n+is_this_a_cmove (rtx expr, void *data)\n+{\n+  /* Check for conditional (if-then-else) copy.  */\n+\n+  if (GET_CODE (expr) == SET\n+      && GET_CODE (SET_DEST (expr)) == REG\n+      && GET_MODE (SET_DEST (expr)) == SImode\n+      && GET_CODE (SET_SRC (expr))  == IF_THEN_ELSE\n+      && GET_CODE (XEXP (SET_SRC (expr), 1)) == REG\n+      && GET_MODE (XEXP (SET_SRC (expr), 1)) == SImode\n+      && GET_CODE (XEXP (SET_SRC (expr), 2)) == REG\n+      && GET_MODE (XEXP (SET_SRC (expr), 2)) == SImode)\n+    {\n+      ((rtx *)data)[0] = XEXP (SET_SRC (expr), 1);\n+      ((rtx *)data)[1] = XEXP (SET_SRC (expr), 2);\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* This returns 1 if it found\n+   (SET (reg:SI REGNO (def_reg)) (if_then_else (cond) (REG:SI x1) (REG:SI x2)))\n+   in the DEF_INSN pattern.  It stores the x1 and x2 in COPY_REG_1\n+   and COPY_REG_2.  */\n+\n+static int\n+is_insn_cond_copy (rtx def_insn, rtx *copy_reg_1, rtx *copy_reg_2)\n+{\n+  int type;\n+  rtx set_expr;\n+  rtx srcreg[2];\n+\n+  srcreg[0] = NULL_RTX;\n+  srcreg[1] = NULL_RTX;\n+\n+  set_expr = single_set (def_insn);\n+\n+  if (set_expr == NULL_RTX)\n+    return 0;\n+\n+  type = is_this_a_cmove (set_expr, (void *) srcreg);\n+\n+  if (type)\n+    {\n+      *copy_reg_1 = srcreg[0];\n+      *copy_reg_2 = srcreg[1];\n+      return type;\n+    }\n+\n+  return 0;\n+}\n+\n+/* Reaching Definitions of the zero-extended register could be conditional\n+   copies or regular definitions.  This function separates the two types into\n+   two lists, DEFS_LIST and COPIES_LIST.  This is necessary because, if a\n+   reaching definition is a conditional copy, combining the zero_extend with\n+   this definition is wrong.  Conditional copies are merged by transitively\n+   merging its definitions.  The defs_list is populated with all the reaching\n+   definitions of the zero-extension instruction (ZERO_EXTEND_INSN) which must\n+   be merged with a zero_extend.  The copies_list contains all the conditional\n+   moves that will later be extended into a DI mode conditonal move if all the\n+   merges are successful.  The function returns false when there is a failure\n+   in getting some definitions, like that of parameters.  It returns 1 upon\n+   success, 0 upon failure and 2 when all definitions of the ZERO_EXTEND_INSN\n+   were merged previously.  */\n+\n+static int\n+make_defs_and_copies_lists (rtx zero_extend_insn, rtx set_pat,\n+                            VEC (rtx,heap) **defs_list,\n+                            VEC (rtx,heap) **copies_list)\n+{\n+  bool *is_insn_visited;\n+  VEC (rtx,heap) *work_list;\n+  rtx srcreg, copy_reg_1, copy_reg_2;\n+  rtx def_insn;\n+  int n_defs = 0;\n+  int vec_index = 0;\n+  int n_worklist = 0;\n+  int i, is_copy;\n+\n+  srcreg = XEXP (SET_SRC (set_pat), 0);\n+  work_list = VEC_alloc (rtx, heap, 8);\n+\n+  /* Initialize the Work List */\n+  n_worklist = get_defs (zero_extend_insn, srcreg, &work_list);\n+\n+  if (n_worklist == 0)\n+    {\n+      VEC_free (rtx, heap, work_list);\n+      /* The number of defs being equal to zero can only imply that all of its\n+         definitions have been previously merged.  */\n+      return 2;\n+    }\n+\n+  is_insn_visited = XNEWVEC (bool, max_insn_uid);\n+\n+  for (i = 0; i < max_insn_uid; i++)\n+    is_insn_visited[i] = false;\n+\n+\n+  /* Perform transitive closure for conditional copies.  */\n+  while (n_worklist > vec_index)\n+    {\n+      def_insn = VEC_index (rtx, work_list, vec_index);\n+      gcc_assert (INSN_UID (def_insn) < max_insn_uid);\n+\n+      if (is_insn_visited[INSN_UID (def_insn)])\n+        {\n+          vec_index++;\n+          continue;\n+        }\n+\n+      is_insn_visited[INSN_UID (def_insn)] = true;\n+      copy_reg_1 = copy_reg_2 = NULL_RTX;\n+      is_copy = is_insn_cond_copy (def_insn, &copy_reg_1, &copy_reg_2);\n+      if (is_copy)\n+        {\n+          gcc_assert (copy_reg_1 && copy_reg_2);\n+\n+          /* Push it into the copy list first.  */\n+\n+          VEC_safe_push (rtx, heap, *copies_list, def_insn);\n+\n+          /* Perform transitive closure here */\n+\n+          n_defs = get_defs (def_insn, copy_reg_1, &work_list);\n+\n+          if (n_defs == 0)\n+            {\n+              VEC_free (rtx, heap, work_list);\n+              XDELETEVEC (is_insn_visited);\n+              return 0;\n+            }\n+          n_worklist += n_defs;\n+\n+          n_defs = get_defs (def_insn, copy_reg_2, &work_list);\n+          if (n_defs == 0)\n+            {\n+              VEC_free (rtx, heap, work_list);\n+              XDELETEVEC (is_insn_visited);\n+              return 0;\n+            }\n+          n_worklist += n_defs;\n+        }\n+      else\n+        {\n+          VEC_safe_push (rtx, heap, *defs_list, def_insn);\n+        }\n+      vec_index++;\n+    }\n+\n+  VEC_free (rtx, heap, work_list);\n+  XDELETEVEC (is_insn_visited);\n+  return 1;\n+}\n+\n+/* Merge the DEF_INSN with a zero-extend.  Calls combine_set_zero_extend\n+   on the SET pattern.  */\n+\n+static bool\n+merge_def_and_ze (rtx def_insn)\n+{\n+  enum rtx_code code;\n+  rtx setreg;\n+  rtx *sub_rtx;\n+  rtx s_expr;\n+  int i;\n+\n+  code = GET_CODE (PATTERN (def_insn));\n+  sub_rtx = NULL;\n+\n+  if (code == PARALLEL)\n+    {\n+      for (i = 0; i < XVECLEN (PATTERN (def_insn), 0); i++)\n+        {\n+          s_expr = XVECEXP (PATTERN (def_insn), 0, i);\n+          if (GET_CODE (s_expr) != SET)\n+            continue;\n+\n+          if (sub_rtx == NULL)\n+            sub_rtx = &XVECEXP (PATTERN (def_insn), 0, i);\n+          else\n+            {\n+              /* PARALLEL with multiple SETs.  */\n+              return false;\n+            }\n+        }\n+    }\n+  else if (code == SET)\n+    sub_rtx = &PATTERN (def_insn);\n+  else\n+    {\n+      /* It is not a PARALLEL or a SET, what could it be ? */\n+      return false;\n+    }\n+\n+  gcc_assert (sub_rtx != NULL);\n+\n+  if (GET_CODE (SET_DEST (*sub_rtx)) == REG\n+      && GET_MODE (SET_DEST (*sub_rtx)) == SImode)\n+    {\n+      setreg = get_reg_di (SET_DEST (*sub_rtx));\n+      return combine_set_zero_extend (def_insn, sub_rtx, setreg);\n+    }\n+  else\n+    return false;\n+  return true;\n+}\n+\n+/* This function goes through all reaching defs of the source\n+   of the zero extension instruction (ZERO_EXTEND_INSN) and\n+   tries to combine the zero extension with the definition\n+   instruction.  The changes are made as a group so that even\n+   if one definition cannot be merged, all reaching definitions\n+   end up not being merged. When a conditional copy is encountered,\n+   merging is attempted transitively on its definitions.  It returns\n+   true upon success and false upon failure.  */\n+\n+static bool\n+combine_reaching_defs (rtx zero_extend_insn, rtx set_pat)\n+{\n+  rtx def_insn;\n+  bool merge_successful = true;\n+  int i;\n+  int defs_ix;\n+  int outcome;\n+\n+  /* To store the definitions that have been merged.  */\n+\n+  VEC (rtx, heap) *defs_list, *copies_list, *vec;\n+  enum insn_merge_code merge_code;\n+\n+  defs_list = VEC_alloc (rtx, heap, 8);\n+  copies_list = VEC_alloc (rtx, heap, 8);\n+\n+  outcome = make_defs_and_copies_lists (zero_extend_insn,\n+                                        set_pat, &defs_list, &copies_list);\n+\n+  /* outcome == 2 implies that all the definitions for this zero_extend were\n+     merged while previously when handling other zero_extends.  */\n+\n+  if (outcome == 2)\n+    {\n+      VEC_free (rtx, heap, defs_list);\n+      VEC_free (rtx, heap, copies_list);\n+      if (dump_file)\n+        fprintf (dump_file, \"All definitions have been merged previously...\\n\");\n+      return true;\n+    }\n+\n+  if (outcome == 0)\n+    {\n+      VEC_free (rtx, heap, defs_list);\n+      VEC_free (rtx, heap, copies_list);\n+      return false;\n+    }\n+\n+  merge_successful = true;\n+\n+  /* Go through the defs vector and try to merge all the definitions\n+     in this vector.  */\n+\n+  vec = VEC_alloc (rtx, heap, 8);\n+  for (defs_ix = 0; VEC_iterate (rtx, defs_list, defs_ix, def_insn); defs_ix++)\n+    {\n+      merge_code = get_insn_status (def_insn);\n+      gcc_assert (merge_code == MERGE_NOT_ATTEMPTED);\n+\n+      if (merge_def_and_ze (def_insn))\n+        VEC_safe_push (rtx, heap, vec, def_insn);\n+      else\n+        {\n+          merge_successful = false;\n+          break;\n+        }\n+    }\n+\n+  /* Now go through the conditional copies vector and try to merge all\n+     the copies in this vector.  */\n+\n+  if (merge_successful)\n+    {\n+      for (i = 0; VEC_iterate (rtx, copies_list, i, def_insn); i++)\n+        {\n+          if (transform_ifelse (def_insn))\n+            {\n+              VEC_safe_push (rtx, heap, vec, def_insn);\n+            }\n+          else\n+            {\n+              merge_successful = false;\n+              break;\n+            }\n+        }\n+    }\n+\n+  if (merge_successful)\n+    {\n+      /* Commit the changes here if possible */\n+      /* XXX : Now, it is an all or nothing scenario.  Even if one definition\n+         cannot be merged we totally bail.  In future, allow zero-extensions to\n+         be partially eliminated along those paths where the definitions could\n+         be merged.  */\n+\n+      if (apply_change_group ())\n+        {\n+          if (dump_file)\n+            fprintf (dump_file, \"All merges were successful ....\\n\");\n+\n+          for (i = 0; VEC_iterate (rtx, vec, i, def_insn); i++)\n+            {\n+              set_insn_status (def_insn, MERGE_SUCCESS);\n+            }\n+\n+          VEC_free (rtx, heap, vec);\n+          VEC_free (rtx, heap, defs_list);\n+          VEC_free (rtx, heap, copies_list);\n+          return true;\n+        }\n+      else\n+        {\n+          /* Changes need not be cancelled explicitly as apply_change_group ()\n+             does it.   Print list of definitions in the dump_file for debug\n+             purposes.  This zero-extension cannot be deleted.  */\n+\n+          if (dump_file)\n+            {\n+              for (i = 0; VEC_iterate (rtx, vec, i, def_insn); i++)\n+                {\n+                  fprintf (dump_file, \" Ummergable definitions : \\n\");\n+                  print_rtl_single (dump_file, def_insn);\n+                }\n+            }\n+        }\n+    }\n+  else\n+    {\n+      /* Cancel any changes that have been made so far.  */\n+      cancel_changes (0);\n+    }\n+\n+  VEC_free (rtx, heap, vec);\n+  VEC_free (rtx, heap, defs_list);\n+  VEC_free (rtx, heap, copies_list);\n+  return false;\n+}\n+\n+/* Goes through the instruction stream looking for zero-extends.  If the zero\n+   extension instruction has atleast one def it adds it to a list of possible\n+   candidates for deletion.  It returns the list of candidates.  */\n+\n+static VEC (rtx,heap)*\n+find_removable_zero_extends (void)\n+{\n+  VEC (rtx, heap) *zeinsn_list;\n+  basic_block curr_block;\n+  rtx curr_insn;\n+  rtx *set_insn;\n+  rtx which_reg;\n+  int type ;\n+  int has_defs;\n+\n+  zeinsn_list = VEC_alloc (rtx, heap, 8);\n+  FOR_EACH_BB (curr_block)\n+    {\n+      FOR_BB_INSNS (curr_block, curr_insn)\n+        {\n+          if (!INSN_P (curr_insn))\n+            continue;\n+\n+          type = for_each_rtx (&PATTERN (curr_insn),\n+                               is_set_with_extension_DI,\n+                               (void *)&set_insn);\n+\n+          if (!type)\n+            continue;\n+\n+          which_reg = XEXP (SET_SRC (*set_insn), 0);\n+          has_defs = get_defs (curr_insn, which_reg, NULL);\n+          if (has_defs)\n+            VEC_safe_push (rtx, heap, zeinsn_list, curr_insn);\n+          else if (dump_file)\n+            {\n+              fprintf (dump_file, \"Cannot eliminate zero extension : \\n\");\n+              print_rtl_single (dump_file, curr_insn);\n+              fprintf (dump_file,\n+                       \"This has no defs. Could be extending parameters.\\n\");\n+            }\n+        }\n+    }\n+  return zeinsn_list;\n+}\n+\n+/* This is the main function that checks the insn stream for redundant\n+   zero extensions and tries to remove them if possible.  */\n+\n+static unsigned int\n+find_and_remove_ze (void)\n+{\n+  rtx curr_insn = NULL_RTX;\n+  int i;\n+  int ix;\n+  long long num_realized = 0;\n+  long long num_ze_opportunities = 0;\n+  VEC (rtx, heap) *zeinsn_list;\n+  VEC (rtx, heap) *zeinsn_del_list;\n+\n+  /* Construct DU chain to get all reaching definitions of each\n+     zero-extension instruction.  */\n+\n+  df_chain_add_problem (DF_UD_CHAIN + DF_DU_CHAIN);\n+  df_analyze ();\n+\n+  max_insn_uid = get_max_uid ();\n+\n+  is_insn_merge_attempted = XNEWVEC (enum insn_merge_code,\n+                                     sizeof (enum insn_merge_code)* max_insn_uid);\n+\n+  for (i = 0; i < max_insn_uid; i++)\n+    {\n+      is_insn_merge_attempted[i] = MERGE_NOT_ATTEMPTED;\n+    }\n+\n+  num_ze_opportunities = num_realized = 0;\n+\n+  zeinsn_del_list = VEC_alloc (rtx, heap, 4);\n+\n+  zeinsn_list = find_removable_zero_extends ();\n+\n+  for (ix = 0; VEC_iterate (rtx, zeinsn_list, ix, curr_insn); ix++)\n+    {\n+      num_ze_opportunities++;\n+      /* Try to combine the zero-extends with the definition here.  */\n+\n+      if (dump_file)\n+        {\n+          fprintf (dump_file, \"Trying to eliminate zero extension : \\n\");\n+          print_rtl_single (dump_file, curr_insn);\n+        }\n+\n+      if (combine_reaching_defs (curr_insn, PATTERN (curr_insn)))\n+        {\n+          if (dump_file)\n+            fprintf (dump_file, \"Eliminated the zero extension...\\n\");\n+          num_realized++;\n+          VEC_safe_push (rtx, heap, zeinsn_del_list, curr_insn);\n+        }\n+    }\n+\n+  /* Delete all useless zero extensions here in one sweep.  */\n+  for (ix = 0; VEC_iterate (rtx, zeinsn_del_list, ix, curr_insn); ix++)\n+    {\n+      delete_insn (curr_insn);\n+    }\n+\n+  free (is_insn_merge_attempted);\n+  VEC_free (rtx, heap, zeinsn_list);\n+  VEC_free (rtx, heap, zeinsn_del_list);\n+\n+  if (dump_file && num_ze_opportunities > 0)\n+    fprintf (dump_file, \"\\n %s : num_zee_opportunities = %lld \"\n+                        \"num_realized = %lld \\n\",\n+                        current_function_name (),\n+                        num_ze_opportunities, num_realized);\n+\n+  df_finish_pass (false);\n+  return 0;\n+}\n+\n+/* Find and remove redundant zero extensions.  */\n+\n+static unsigned int\n+rest_of_handle_zee (void)\n+{\n+  timevar_push (TV_ZEE);\n+  find_and_remove_ze ();\n+  timevar_pop (TV_ZEE);\n+  return 0;\n+}\n+\n+/* Run zee pass when flag_zee is set at optimization level > 0.  */\n+\n+static bool\n+gate_handle_zee (void)\n+{\n+  return (optimize > 0 && flag_zee);\n+}\n+\n+struct rtl_opt_pass pass_implicit_zee =\n+{\n+ {\n+  RTL_PASS,\n+  \"zee\",                                /* name */\n+  gate_handle_zee,                      /* gate */\n+  rest_of_handle_zee,                   /* execute */\n+  NULL,                                 /* sub */\n+  NULL,                                 /* next */\n+  0,                                    /* static_pass_number */\n+  TV_ZEE,                               /* tv_id */\n+  0,                                    /* properties_required */\n+  0,                                    /* properties_provided */\n+  0,                                    /* properties_destroyed */\n+  0,                                    /* todo_flags_start */\n+  TODO_ggc_collect |\n+  TODO_dump_func |\n+  TODO_verify_rtl_sharing,              /* todo_flags_finish */\n+ }\n+};"}, {"sha": "041837f04d31642d3e1de0ac199bad315a375634", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1031,6 +1031,7 @@ init_optimization_passes (void)\n \t  NEXT_PASS (pass_postreload_cse);\n \t  NEXT_PASS (pass_gcse2);\n \t  NEXT_PASS (pass_split_after_reload);\n+\t  NEXT_PASS (pass_implicit_zee);\n \t  NEXT_PASS (pass_branch_target_load_optimize1);\n \t  NEXT_PASS (pass_thread_prologue_and_epilogue);\n \t  NEXT_PASS (pass_rtl_dse2);"}, {"sha": "db8a78db934154b41b946e25ffe0fad475252ed6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1,3 +1,7 @@\n+2010-05-12  Sriraman Tallam  <tmsriram@google.com>\n+\n+\t* gcc.target/i386/zee.c: New file.\n+\n 2010-05-12  Jason Merrill  <jason@redhat.com>\n \n \t* g++.dg/conversion/op1.C: Expect template candidate message."}, {"sha": "4ed3aa87b9fef9d16ee2e4526a2b47ba7d1281a5", "filename": "gcc/testsuite/gcc.target/i386/zee.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzee.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzee.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fzee.c?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -fzee -S\" } */\n+/* { dg-final { scan-assembler-not \"mov\\[\\\\t \\]+\\(%\\[\\^,\\]+\\),\\[\\\\t \\]*\\\\1\" } } */\n+int mask[100];\n+int foo(unsigned x)\n+{\n+  if (x < 10)\n+    x = x * 45;\n+  else\n+    x = x * 78;\n+  return mask[x];\n+}"}, {"sha": "2a124e6a94976725339b7231071bfa04a421a992", "filename": "gcc/timevar.def", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -1,6 +1,7 @@\n /* This file contains the definitions for timing variables used to\n    measure run-time performance of the compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,\n+   2009, 2010\n    Free Software Foundation, Inc.\n    Contributed by Alex Samuel <samuel@codesourcery.com>\n \n@@ -207,6 +208,7 @@ DEFTIMEVAR (TV_RELOAD\t   \t     , \"reload\")\n DEFTIMEVAR (TV_RELOAD_CSE_REGS       , \"reload CSE regs\")\n DEFTIMEVAR (TV_SEQABSTR              , \"sequence abstraction\")\n DEFTIMEVAR (TV_GCSE_AFTER_RELOAD      , \"load CSE after reload\")\n+DEFTIMEVAR (TV_ZEE\t\t     , \"zee\")\n DEFTIMEVAR (TV_THREAD_PROLOGUE_AND_EPILOGUE, \"thread pro- & epilogue\")\n DEFTIMEVAR (TV_IFCVT2\t\t     , \"if-conversion 2\")\n DEFTIMEVAR (TV_COMBINE_STACK_ADJUST  , \"combine stack adjustments\")"}, {"sha": "5ed86b4336b4db7d17364002a522bbca9d8686b7", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/87a0ebfd203382a034b76c3a087d310908005454/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=87a0ebfd203382a034b76c3a087d310908005454", "patch": "@@ -515,6 +515,7 @@ extern struct rtl_opt_pass pass_stack_ptr_mod;\n extern struct rtl_opt_pass pass_initialize_regs;\n extern struct rtl_opt_pass pass_combine;\n extern struct rtl_opt_pass pass_if_after_combine;\n+extern struct rtl_opt_pass pass_implicit_zee;\n extern struct rtl_opt_pass pass_partition_blocks;\n extern struct rtl_opt_pass pass_match_asm_constraints;\n extern struct rtl_opt_pass pass_regmove;"}]}