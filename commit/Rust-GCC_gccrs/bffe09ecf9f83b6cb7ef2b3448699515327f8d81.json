{"sha": "bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZmZTA5ZWNmOWY4M2I2Y2I3ZWYyYjM0NDg2OTk1MTUzMjdmOGQ4MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1999-07-26T06:48:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1999-07-26T06:48:07Z"}, "message": "clipper.h (EXPAND_BUILTIN_SAVEREGS): Remove argument.\n\n        * clipper.h (EXPAND_BUILTIN_SAVEREGS): Remove argument.\n        (BUILD_VA_LIST_TYPE): New.\n        (EXPAND_BUILTIN_VA_START): New.\n        (EXPAND_BUILTIN_VA_ARG): New.\n        * clipper.c (clipper_builtin_saveregs): Only dump registers.\n        Return the address of the save area.\n        (clipper_build_va_list): New.\n        (clipper_va_start): New.\n        (clipper_va_arg): New.\n\nFrom-SVN: r28257", "tree": {"sha": "89caf38d2dc2d3a02de9a1a3e4033819d73823ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89caf38d2dc2d3a02de9a1a3e4033819d73823ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/comments", "author": null, "committer": null, "parents": [{"sha": "965eb47478f9eeaf06925b495d1258d285f3db21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/965eb47478f9eeaf06925b495d1258d285f3db21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/965eb47478f9eeaf06925b495d1258d285f3db21"}], "stats": {"total": 335, "additions": 266, "deletions": 69}, "files": [{"sha": "8c7f7e0c8ecc73abebf7a705d466e2d9485d9511", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "patch": "@@ -1,3 +1,15 @@\n+Sun Jul 25 23:44:13 1999  Richard Henderson  <rth@cygnus.com>\n+\n+\t* clipper.h (EXPAND_BUILTIN_SAVEREGS): Remove argument.\n+\t(BUILD_VA_LIST_TYPE): New.\n+\t(EXPAND_BUILTIN_VA_START): New.\n+\t(EXPAND_BUILTIN_VA_ARG): New.\n+\t* clipper.c (clipper_builtin_saveregs): Only dump registers.\n+\tReturn the address of the save area.\n+\t(clipper_build_va_list): New.\n+\t(clipper_va_start): New.\n+\t(clipper_va_arg): New.\n+\n Sun Jul 25 22:56:47 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* arc.h (EXPAND_BUILTIN_VA_START): New."}, {"sha": "3bae60b81483c68c1cccfc4edce1ddb569f35e44", "filename": "gcc/config/clipper/clipper.c", "status": "modified", "additions": 241, "deletions": 68, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2Fconfig%2Fclipper%2Fclipper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2Fconfig%2Fclipper%2Fclipper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.c?ref=bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "patch": "@@ -365,93 +365,56 @@ rev_cond_name (op)\n }\n \n \f\n-/* Do what is necessary for `va_start'.  The argument is ignored;\n-   We fill in an initial va_list.  A pointer to this constructor\n-   is returned. */\n-\n+/* Dump the argument register to the stack; return the location\n+   of the block.  */\n \n struct rtx_def *\n-clipper_builtin_saveregs (arglist)\n-     tree arglist;\n+clipper_builtin_saveregs ()\n {\n-  extern int current_function_varargs;\n-  rtx block, addr, argsize, scratch, r0_addr,r1_addr,f0_addr,f1_addr;\n+  rtx block, addr, r0_addr, r1_addr, f0_addr, f1_addr, mem;\n+  int set = get_varargs_alias_set ();\n \n-  /* Allocate the va_list constructor + save area for r0,r1,f0,f1 */\n+  /* Allocate the save area for r0,r1,f0,f1 */\n \n-  block = assign_stack_local (BLKmode,\n-\t\t\t      (6 + 6) * UNITS_PER_WORD, 2 * BITS_PER_WORD);\n+  block = assign_stack_local (BLKmode, 6 * UNITS_PER_WORD, 2 * BITS_PER_WORD);\n \n   RTX_UNCHANGING_P (block) = 1;\n   RTX_UNCHANGING_P (XEXP (block, 0)) = 1;\n \n-  addr = copy_to_reg (XEXP (block, 0));\n+  addr = XEXP (block, 0);\n \n-  f0_addr =  gen_rtx (PLUS, Pmode, addr, GEN_INT (24));\n-  f1_addr =  gen_rtx (PLUS, Pmode, addr, GEN_INT (32));\n-  r0_addr =  gen_rtx (PLUS, Pmode, addr, GEN_INT (40));\n-  r1_addr =  gen_rtx (PLUS, Pmode, addr, GEN_INT (44));\n+  r0_addr = addr;\n+  r1_addr = plus_constant (addr, 4);\n+  f0_addr = plus_constant (addr, 8);\n+  f1_addr = plus_constant (addr, 16);\n \n+  /* Store int regs  */\n \n-  /* Store float regs  */\n+  mem = gen_rtx_MEM (SImode, r0_addr);\n+  MEM_ALIAS_SET (mem) = set;\n+  emit_move_insn (mem, gen_rtx_REG (SImode, 0));\n \n-  emit_move_insn (gen_rtx (MEM, DFmode, f0_addr), gen_rtx (REG, DFmode, 16));\n-  emit_move_insn (gen_rtx (MEM, DFmode, f1_addr), gen_rtx (REG, DFmode, 17));\n+  mem = gen_rtx_MEM (SImode, r1_addr);\n+  MEM_ALIAS_SET (mem) = set;\n+  emit_move_insn (mem, gen_rtx_REG (SImode, 1));\n \n-  /* Store int regs  */\n+  /* Store float regs  */\n \n-  emit_move_insn (gen_rtx (MEM, SImode, r0_addr), gen_rtx (REG, SImode, 0));\n-  emit_move_insn (gen_rtx (MEM, SImode, r1_addr), gen_rtx (REG, SImode, 1));\n-\n-  /* Store the arg pointer in the __va_stk member.  */\n-\n-  emit_move_insn (gen_rtx (MEM, SImode, addr),\n-\t\t  copy_to_reg (virtual_incoming_args_rtx));\n-\t\t  \n-\n-  /* now move addresses of the saved regs into the pointer array */\n-\n-  scratch = gen_reg_rtx (Pmode);\n-\n-  emit_move_insn (scratch, r0_addr);\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   gen_rtx (PLUS, Pmode, addr,\n-\t\t\t\t    GEN_INT (4))),\n-\t\t  scratch);\n-\t\t  \n-  emit_move_insn (scratch, f0_addr);\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   gen_rtx (PLUS, Pmode, addr,\n-\t\t\t\t    GEN_INT (8))),\n-\t\t  scratch);\n-\t\t  \n-  emit_move_insn (scratch, r1_addr);\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   gen_rtx (PLUS, Pmode, addr,\n-\t\t\t\t    GEN_INT (12))),\n-\t\t  scratch);\n-\t\t  \n-  emit_move_insn (scratch, f1_addr);\n-  emit_move_insn (gen_rtx (MEM, SImode,\n-\t\t\t   gen_rtx (PLUS, Pmode, addr,\n-\t\t\t\t    GEN_INT (16))),\n-\t\t  scratch);\n+  mem = gen_rtx_MEM (DFmode, f0_addr);\n+  MEM_ALIAS_SET (mem) = set;\n+  emit_move_insn (mem, gen_rtx_REG (DFmode, 16));\n \n+  mem = gen_rtx_MEM (DFmode, f1_addr);\n+  MEM_ALIAS_SET (mem) = set;\n+  emit_move_insn (mem, gen_rtx_REG (DFmode, 17));\n \n   if (current_function_check_memory_usage)\n     {\n-      emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n-\t\t\t addr, ptr_mode,\n-\t\t\t GEN_INT (5 * GET_MODE_SIZE (SImode)),\n-\t\t\t TYPE_MODE (sizetype),\n-\t\t\t GEN_INT (MEMORY_USE_RW),\n-\t\t\t TYPE_MODE (integer_type_node));\n-\n       emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t f0_addr, ptr_mode,\n \t\t\t GEN_INT (GET_MODE_SIZE (DFmode)),\n \t\t\t TYPE_MODE (sizetype),\n-\t\t\t GEN_INT (MEMORY_USE_RW), \n+\t\t\t GEN_INT (MEMORY_USE_RW),\n \t\t\t TYPE_MODE (integer_type_node));\n       emit_library_call (chkr_set_right_libfunc, 1, VOIDmode, 3,\n \t\t\t f1_addr, ptr_mode,\n@@ -473,12 +436,222 @@ clipper_builtin_saveregs (arglist)\n \t\t\t TYPE_MODE (integer_type_node));\n     }\n \n-  /* Return the address of the va_list constructor, but don't put it in a\n-     register.  This fails when not optimizing and produces worse code when\n-     optimizing.  */\n-  return XEXP (block, 0);\n+  return addr;\n+}\n+\n+tree\n+clipper_build_va_list ()\n+{\n+  tree record, ap, reg, num;\n+\n+  /*\n+    struct\n+    {\n+      int __va_ap;\t\t// pointer to stack args\n+      void *__va_reg[4];\t// pointer to r0,f0,r1,f1\n+      int __va_num;\t\t// number of args processed\n+    };\n+  */\n+\n+  record = make_node (RECORD_TYPE);\n+\n+  num = build_decl (FIELD_DECL, get_identifier (\"__va_num\"),\n+\t\t    integer_type_node);\n+  DECL_FIELD_CONTEXT (num) = record;\n+\n+  reg = build_decl (FIELD_DECL, get_identifier (\"__va_reg\"),\n+\t\t    build_array_type (ptr_type_node,\n+\t\t\t\t      build_index_type (build_int_2 (3, 0))));\n+  DECL_FIELD_CONTEXT (reg) = record;\n+  TREE_CHAIN (reg) = num;\n+\n+  ap = build_decl (FIELD_DECL, get_identifier (\"__va_ap\"),\n+\t\t   integer_type_node);\n+  DECL_FIELD_CONTEXT (ap) = record;\n+  TREE_CHAIN (ap) = reg;\n+\n+  TYPE_FIELDS (record) = ap;\n+  layout_type (record);\n+\n+  return record;\n+}\n+\n+void\n+clipper_va_start (stdarg_p, valist, nextarg)\n+     int stdarg_p;\n+     tree valist;\n+     rtx nextarg ATTRIBUTE_UNUSED;\n+{\n+  tree ap_field, reg_field, num_field;\n+  tree t, u, save_area;\n+\n+  ap_field = TYPE_FIELDS (TREE_TYPE (valist));\n+  reg_field = TREE_CHAIN (ap_field);\n+  num_field = TREE_CHAIN (reg_field);\n+\n+  ap_field = build (COMPONENT_REF, TREE_TYPE (ap_field), valist, ap_field);\n+  reg_field = build (COMPONENT_REF, TREE_TYPE (reg_field), valist, reg_field);\n+  num_field = build (COMPONENT_REF, TREE_TYPE (num_field), valist, num_field);\n+\n+  /* Call __builtin_saveregs to save r0, r1, f0, and f1 in a block.  */\n+\n+  save_area = make_tree (integer_type_node, expand_builtin_saveregs ());\n+\n+  /* Set __va_ap.  */\n+\n+  t = make_tree (ptr_type_node, virtual_incoming_args_rtx);\n+  if (stdarg_p && current_function_args_info.size != 0)\n+    t = build (PLUS_EXPR, ptr_type_node, t,\n+\t       build_int_2 (current_function_args_info.size, 0));\n+  t = build (MODIFY_EXPR, TREE_TYPE (ap_field), ap_field, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Set the four entries of __va_reg.  */\n+\n+  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n+  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int (0, 0));\n+  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n+\t\t   build_int_2 (8, 0)));\n+  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n+  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int (1, 0));\n+  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n+\t\t   build_int_2 (4, 0)));\n+  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n+  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int (2, 0));\n+  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  t = fold (build (PLUS_EXPR, integer_type_node, save_area,\n+\t\t   build_int_2 (16, 0)));\n+  t = build1 (NOP_EXPR, ptr_type_node, save_area);\n+  u = build (ARRAY_REF, ptr_type_node, reg_field, build_int (3, 0));\n+  t = build (MODIFY_EXPR, ptr_type_node, u, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  /* Set __va_num.  */\n+\n+  t = build_int_2 (current_function_args_info.num, 0);\n+  t = build (MODIFY_EXPR, TREE_TYPE (num_field), num_field, t);\n+  TREE_SIZE_EFFECTS (t) = 1;\n }\n \n+rtx\n+clipper_va_arg (valist, type)\n+     tree valist, type;\n+{\n+  tree ap_field, reg_field, num_field;\n+  tree addr, t;\n+  HOST_WIDE_INT align;\n+  rtx addr_rtx, over_label = NULL_RTX, tr;\n+\n+  /*\n+    Integers:\n+\n+    if (VA.__va_num < 2)\n+      addr = VA.__va_reg[2 * VA.__va_num];\n+    else\n+      addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n+    VA.__va_num++;\n+\n+    Floats:\n+\n+    if (VA.__va_num < 2)\n+      addr = VA.__va_reg[2 * VA.__va_num + 1];\n+    else\n+      addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n+    VA.__va_num++;\n+\n+    Aggregates:\n+\n+    addr = round(VA.__va_ap), VA.__va_ap = round(VA.__va_ap) + sizeof(TYPE);\n+    VA.__va_num++;\n+  */\n+\n+  ap_field = TYPE_FIELDS (TREE_TYPE (valist));\n+  reg_field = TREE_CHAIN (ap_field);\n+  num_field = TREE_CHAIN (reg_field);\n+\n+  ap_field = build (COMPONENT_REF, TREE_TYPE (ap_field), valist, ap_field);\n+  reg_field = build (COMPONENT_REF, TREE_TYPE (reg_field), valist, reg_field);\n+  num_field = build (COMPONENT_REF, TREE_TYPE (num_field), valist, num_field);\n+\n+  addr_rtx = gen_reg_rtx (Pmode);\n+\n+  if (! AGGREGATE_TYPE_P (type))\n+    {\n+      tree inreg;\n+      rtx false_label;\n+\n+      over_label = gen_label_rtx ();\n+      false_label = gen_label_rtx ();\n+\n+      emit_cmp_and_jump_insns (expand_expr (num_field, NULL_RTX, 0,\n+\t\t\t\t\t    OPTAB_LIB_WIDEN),\n+\t\t\t       GEN_INT (2), GE, const0_rtx,\n+\t\t\t       TYPE_MODE (TREE_TYPE (num_field)),\n+\t\t\t       TREE_UNSIGNED (num_field), 0, false_label);\n+\n+      inreg = fold (build (MULT_EXPR, integer_type_node, num_field,\n+\t\t\t   build_int_2 (2, 0)));\n+      if (FLOAT_TYPE_P (type))\n+\tinreg = fold (build (PLUS_EXPR, integer_type_node, inreg,\n+\t\t\t     build_int_2 (1, 0)));\n+      inreg = fold (build (ARRAY_REF, ptr_type_node, reg_field, inreg));\n+\n+      tr = expand_expr (inreg, addr_rtx, VOIDmode, EXPAND_NORMAL);\n+      if (tr != addr_rtx)\n+\temit_move_insn (addr_rtx, tr);\n+\n+      emit_jump_insn (gen_jump (over_label));\n+      emit_barrier ();\n+      emit_label (false_label);\n+    }\n+\n+  /* Round to alignment of `type', or at least integer alignment.  */\n+\n+  align = TYPE_ALIGN (type);\n+  if (align < TYPE_ALIGN (integer_type_node))\n+    align = TYPE_ALIGN (integer_type_node);\n+  align /= BITS_PER_UNIT;\n+\n+  addr = fold (build (PLUS_EXPR, ptr_type_node, ap_field,\n+\t\t      build_int_2 (align-1, 0)));\n+  addr = fold (build (BIT_AND_EXPR, ptr_type_node, addr,\n+\t\t      build_int_2 (-align, -1)));\n+  addr = save_expr (addr);\n+\n+  tr = expand_expr (addr, addr_rtx, Pmode, EXPAND_NORMAL);\n+  if (tr != addr_rtx)\n+    emit_move_insn (addr_rtx, tr);\n+  \n+  t = build (MODIFY_EXPR, TREE_TYPE (ap_field), ap_field,\n+\t     build (PLUS_EXPR, TREE_TYPE (ap_field), \n+\t\t    addr, build_int_2 (int_size_in_bytes (type), 0)));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  if (over_label)\n+    emit_label (over_label);\n+\n+  t = build (MODIFY_EXPR, TREE_TYPE (num_field), num_field,\n+\t     build (PLUS_EXPR, TREE_TYPE (num_field), \n+\t\t    num_field, build_int_2 (1, 0)));\n+  TREE_SIDE_EFFECTS (t) = 1;\n+  expand_expr (t, const0_rtx, VOIDmode, EXPAND_NORMAL);\n+\n+  return addr_rtx;\n+}\n \n /* Return truth value of whether OP can be used as an word register\n    operand. Reject (SUBREG:SI (REG:SF )) */"}, {"sha": "9b46916302d10d2a44162e27b8b4160011225ff7", "filename": "gcc/config/clipper/clipper.h", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2Fconfig%2Fclipper%2Fclipper.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffe09ecf9f83b6cb7ef2b3448699515327f8d81/gcc%2Fconfig%2Fclipper%2Fclipper.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fclipper%2Fclipper.h?ref=bffe09ecf9f83b6cb7ef2b3448699515327f8d81", "patch": "@@ -549,7 +549,7 @@ do\t\t\t\t\t\t\t\t\t      \\\n /* Generate necessary RTL for __builtin_saveregs().\n    ARGLIST is the argument list; see expr.c.  */\n \n-#define EXPAND_BUILTIN_SAVEREGS(ARGLIST) clipper_builtin_saveregs (ARGLIST)\n+#define EXPAND_BUILTIN_SAVEREGS() clipper_builtin_saveregs ()\n \n /* This macro generates the assembly code for function entry.\n    FILE is a stdio stream to output the code to.\n@@ -1123,3 +1123,15 @@ Clipper operand formatting codes:\n #define PREDICATE_CODES \\\n   {\"int_reg_operand\", {SUBREG, REG}},\t\\\n   {\"fp_reg_operand\", {SUBREG, REG}},\n+\f\n+/* Define the `__builtin_va_list' type for the ABI.  */\n+#define BUILD_VA_LIST_TYPE(VALIST) \\\n+  (VALIST) = clipper_build_va_list ()\n+\n+/* Implement `va_start' for varargs and stdarg.  */\n+#define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n+  clipper_va_start (stdarg, valist, nextarg)\n+\n+/* Implement `va_arg'.  */\n+#define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n+  clipper_va_arg (valist, type)"}]}