{"sha": "a39a553eacce1f39fac4cffc0f5768bee425c1a1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTM5YTU1M2VhY2NlMWYzOWZhYzRjZmZjMGY1NzY4YmVlNDI1YzFhMQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T08:02:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-08-06T08:02:35Z"}, "message": "[multiple changes]\n\n2012-08-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_mech.adb (Set_Mechanisms): OUT and IN OUT parameters are\n\tnow unconditionally passed by reference. IN parameters subject\n\tto convention C_Pass_By_Copy are passed by copy, otherwise they\n\tare passed by reference.\n\n2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): According to\n\tAI95-0303, protected objects with interrupt handlers can be\n\tdeclared in nested scopes. This is a binding interpretation,\n\tand thus applies to all versions of the compiler.\n\n2012-08-06  Robert Dewar  <dewar@adacore.com>\n\n\t* frontend.adb, exp_aggr.adb: Minor reformatting.\n\n2012-08-06  Thomas Quinot  <quinot@adacore.com>\n\n\t* par-endh.adb: Minor reformatting.\n\nFrom-SVN: r190162", "tree": {"sha": "0ce70598eeda17f17973df3cf9483c742073238d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ce70598eeda17f17973df3cf9483c742073238d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a39a553eacce1f39fac4cffc0f5768bee425c1a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39a553eacce1f39fac4cffc0f5768bee425c1a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a39a553eacce1f39fac4cffc0f5768bee425c1a1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a39a553eacce1f39fac4cffc0f5768bee425c1a1/comments", "author": null, "committer": null, "parents": [{"sha": "5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5eeeed5e1a9ee8ea9fbff247c9cc6fd093fa5dcd"}], "stats": {"total": 116, "additions": 79, "deletions": 37}, "files": [{"sha": "b538ecfc8f3b4ebd2339d6d91932244fe35da4b3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -1,3 +1,25 @@\n+2012-08-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_mech.adb (Set_Mechanisms): OUT and IN OUT parameters are\n+\tnow unconditionally passed by reference. IN parameters subject\n+\tto convention C_Pass_By_Copy are passed by copy, otherwise they\n+\tare passed by reference.\n+\n+2012-08-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): According to\n+\tAI95-0303, protected objects with interrupt handlers can be\n+\tdeclared in nested scopes. This is a binding interpretation,\n+\tand thus applies to all versions of the compiler.\n+\n+2012-08-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* frontend.adb, exp_aggr.adb: Minor reformatting.\n+\n+2012-08-06  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* par-endh.adb: Minor reformatting.\n+\n 2012-08-06  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* exp_ch7.adb (Process_Transient_Objects): Remove obsolete loop"}, {"sha": "98070a9a2df9e826f796752941d6d0eeff47ff67", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 24, "deletions": 23, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -5981,6 +5981,9 @@ package body Exp_Aggr is\n    --    Bounds are within 32-bit Int range\n    --    All bounds and values are static\n \n+   --  Note: for now, in the 2-D case, we only handle component sizes of\n+   --  1, 2, 4 (cases where an integral number of elements occupies a byte).\n+\n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Typ  : constant Entity_Id  := Etype (N);\n@@ -6302,7 +6305,8 @@ package body Exp_Aggr is\n             return False;\n          else\n             return Expr_Value (L1) /= Expr_Value (L2)\n-              or else Expr_Value (H1) /= Expr_Value (H2);\n+                     or else\n+                   Expr_Value (H1) /= Expr_Value (H2);\n          end if;\n       end if;\n    end Must_Slide;\n@@ -6386,39 +6390,36 @@ package body Exp_Aggr is\n       --  Expression in original aggregate\n \n       One_Dim   : Node_Id;\n-      --  one-dimensional subaggregate\n+      --  One-dimensional subaggregate\n \n    begin\n \n-      --  For now, only deal with tight packing. The boolean case is the\n-      --  most common.\n+      --  For now, only deal with cases where an integral number of elements\n+      --  fit in a single byte. This includes the most common boolean case.\n \n-      if Comp_Size = 1\n-         or else Comp_Size = 2\n-         or else Comp_Size = 4\n+      if not (Comp_Size = 1 or else\n+              Comp_Size = 2 or else\n+              Comp_Size = 4)\n       then\n-         null;\n-\n-      else\n          return False;\n       end if;\n \n       Convert_To_Positional\n         (N, Max_Others_Replicate => 64, Handle_Bit_Packed => True);\n \n-      --  Verify that all components are static.\n+      --  Verify that all components are static\n \n       if Nkind (N) = N_Aggregate\n         and then Compile_Time_Known_Aggregate (N)\n       then\n          null;\n \n-      --  The aggregate may have been re-analyzed and converted already.\n+      --  The aggregate may have been re-analyzed and converted already\n \n       elsif Nkind (N) /= N_Aggregate then\n          return True;\n \n-      --  If component associations remain, the aggregate is not static.\n+      --  If component associations remain, the aggregate is not static\n \n       elsif Present (Component_Associations (N)) then\n          return False;\n@@ -6460,17 +6461,17 @@ package body Exp_Aggr is\n          Comp_Val : Uint;\n          --  integer value of component\n \n-         Incr  : Int;\n+         Incr : Int;\n          --  Step size for packing\n \n          Init_Shift : Int;\n-         --  endian-dependent start position for packing\n+         --  Endian-dependent start position for packing\n \n          Shift : Int;\n-         --  current insertion position\n+         --  Current insertion position\n \n-         Val   : Int;\n-         --  component of packed array being assembled.\n+         Val : Int;\n+         --  Component of packed array being assembled.\n \n       begin\n          Comps := New_List;\n@@ -6485,10 +6486,10 @@ package body Exp_Aggr is\n            xor Reverse_Storage_Order (Base_Type (Typ))\n          then\n             Init_Shift := Byte_Size - Comp_Size;\n-            Incr  := -Comp_Size;\n+            Incr := -Comp_Size;\n          else\n             Init_Shift := 0;\n-            Incr  := +Comp_Size;\n+            Incr := +Comp_Size;\n          end if;\n \n          Shift := Init_Shift;\n@@ -6531,7 +6532,7 @@ package body Exp_Aggr is\n \n          if Packed_Num > 0 then\n \n-            --  Add final incomplete byte if present.\n+            --  Add final incomplete byte if present\n \n             Append (Make_Integer_Literal (Sloc (One_Dim), Val), Comps);\n          end if;\n@@ -6540,8 +6541,8 @@ package body Exp_Aggr is\n              Unchecked_Convert_To (Typ,\n                Make_Qualified_Expression (Loc,\n                  Subtype_Mark => New_Occurrence_Of (Packed_Array, Loc),\n-               Expression =>\n-                Make_Aggregate (Loc,  Expressions => Comps))));\n+                 Expression   =>\n+                   Make_Aggregate (Loc,  Expressions => Comps))));\n          Analyze_And_Resolve (N);\n          return True;\n       end;"}, {"sha": "749e94875d720959c7d67891c282908848a9fea4", "filename": "gcc/ada/frontend.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Ffrontend.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Ffrontend.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffrontend.adb?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -282,8 +282,13 @@ begin\n    --  a context for their semantic processing.\n \n    if Config_Pragmas /= Error_List\n-     and then not Fatal_Error (Main_Unit)\n      and then Operating_Mode /= Check_Syntax\n+\n+     --  Do not attempt to process deferred configuration pragmas if the main\n+     --  unit failed to load, to avoid cascaded inconsistencies that can lead\n+     --  to a compiler crash.\n+\n+     and then not Fatal_Error (Main_Unit)\n    then\n       --  Pragmas that require some semantic activity, such as\n       --  Interrupt_State, cannot be processed until the main unit"}, {"sha": "e6d4e19d6ac721fd6183c42a8defcac3726d1d55", "filename": "gcc/ada/par-endh.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fpar-endh.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fpar-endh.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-endh.adb?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -199,7 +199,7 @@ package body Endh is\n          End_OK := True;\n          Scan; -- past END\n \n-         --  Set End_Span if expected. note that this will be useless\n+         --  Set End_Span if expected. Note that this will be useless\n          --  if we do not have the right ending keyword, but in this\n          --  case we have a malformed program anyway, and the setting\n          --  of End_Span will simply be unreliable in this case anyway."}, {"sha": "7080d37b7acd7e51723c2af0b8f7f3a1f4c35b67", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -3078,8 +3078,11 @@ package body Sem_Ch3 is\n          --  in the RM is removed) because accessibility checks are sufficient\n          --  to make handlers not at the library level illegal.\n \n+         --  AI05-0303: the AI is in fact a binding interpretation, and thus\n+         --  applies to the '95 version of the language as well.\n+\n          if Has_Interrupt_Handler (T)\n-           and then Ada_Version < Ada_2005\n+           and then Ada_Version < Ada_95\n          then\n             Error_Msg_N\n               (\"interrupt object can only be declared at library level\", Id);"}, {"sha": "6bd498ef9fcb404168015c8d07e1e527bad1ed05", "filename": "gcc/ada/sem_mech.adb", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fsem_mech.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a39a553eacce1f39fac4cffc0f5768bee425c1a1/gcc%2Fada%2Fsem_mech.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_mech.adb?ref=a39a553eacce1f39fac4cffc0f5768bee425c1a1", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1996-2011, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1996-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -352,13 +352,13 @@ package body Sem_Mech is\n                   --    Access parameters (RM B.3(68))\n                   --    Access to subprogram types (RM B.3(71))\n \n-                  --  Note: in the case of access parameters, it is the\n-                  --  pointer that is passed by value. In GNAT access\n-                  --  parameters are treated as IN parameters of an\n-                  --  anonymous access type, so this falls out free.\n+                  --  Note: in the case of access parameters, it is the pointer\n+                  --  that is passed by value. In GNAT access parameters are\n+                  --  treated as IN parameters of an anonymous access type, so\n+                  --  this falls out free.\n \n-                  --  The bottom line is that all IN elementary types\n-                  --  are passed by copy in GNAT.\n+                  --  The bottom line is that all IN elementary types are\n+                  --  passed by copy in GNAT.\n \n                   if Is_Elementary_Type (Typ) then\n                      if Ekind (Formal) = E_In_Parameter then\n@@ -385,10 +385,21 @@ package body Sem_Mech is\n                      if Convention (Typ) /= Convention_C then\n                         Set_Mechanism (Formal, By_Reference);\n \n-                     --  If convention C_Pass_By_Copy was specified for\n-                     --  the record type, then we pass by copy.\n+                     --  OUT and IN OUT parameters of record types are passed\n+                     --  by reference regardless of pragmas (RM B.3 (69/2)).\n \n-                     elsif C_Pass_By_Copy (Typ) then\n+                     elsif Ekind_In (Formal, E_Out_Parameter,\n+                                             E_In_Out_Parameter)\n+                     then\n+                        Set_Mechanism (Formal, By_Reference);\n+\n+                     --  IN parameters of record types are passed by copy only\n+                     --  when the related type has convention C_Pass_By_Copy\n+                     --  (RM B.3 (68.1/2)).\n+\n+                     elsif Ekind (Formal) = E_In_Parameter\n+                       and then C_Pass_By_Copy (Typ)\n+                     then\n                         Set_Mechanism (Formal, By_Copy);\n \n                      --  Otherwise, for a C convention record, we set the"}]}