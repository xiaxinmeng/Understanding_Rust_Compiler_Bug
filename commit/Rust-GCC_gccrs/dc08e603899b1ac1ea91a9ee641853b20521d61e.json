{"sha": "dc08e603899b1ac1ea91a9ee641853b20521d61e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwOGU2MDM4OTliMWFjMWVhOTFhOWVlNjQxODUzYjIwNTIxZDYxZQ==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2001-01-15T08:01:22Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-01-15T08:01:22Z"}, "message": "All files with updated copyright when applicable.\n\n2001-01-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\tAll files with updated copyright when applicable.\n\t* Make-lang.in (JVGENMAIN_OBS): Removed java/mangle.o.\n\t* class.c (mangle_class_field): Function removed.\n\t(append_gpp_mangled_type, mangle_static_field, mangle_field): Likewise.\n\t(utf8_cmp, cxx_keyword_p): Moved to lex.c.\n\t(build_class_ref): Call `java_mangle_class_field' instead of\n\t`mangle_class_field.'\n\t(build_dtable_decl): Rewritten to call `java_mangle_vtable.'\n\t(layout_class): Call `java_mangle_decl' instead of\n\t`mangle_static_field.'\n\t(cxx_keywords): Initialized static array moved to `lex.c.'\n\t(layout_class_method): Changed leading comment. Simplified to\n\tcall `java_mangle_decl.' Local `ptr' moved in for loop body.\n\t* decl.c (lang_mark_tree): Mark field `package_list.'\n\t* java-tree.h (TYPE_PACKAGE_LIST): New macro.\n\t(struct lang_type): New field `package_list.'\n\t(unicode_mangling_length): Prototype removed.\n\t(append_gpp_mangled_name, append_gpp_mangled_classtype,\n\temit_unicode_mangled_name): Likewise.\n\t(cxx_keyword_p): New prototype.\n\t(java_mangle_decl, java_mangle_class_field,\n\tjava_mangle_class_field_from_string, java_mangle_vtable): Likewise.\n\t* jcf-parse.c (jcf_parse_source): Constify `file' argument to\n\t`build_expr_wfl.'\n\t* jvgenmain.c (main_method_prefix): Global variable removed.\n\t(main_method_suffix): Likewise.\n\t(do_mangle_classname): New function.\n\t(main): Call it. Format changed to accomodate new mangling scheme.\n\t* lex.c: (utf8_cmp): Conditionally prototyped.\n\t(cxx_keywords): Moved from class.c, conditionally defined.\n\t(utf8_cmp, cxx_keyword_p): Likewise.\n\t* mangle.c (obstack.h, ggc.h): Included.\n\t(mangle_field_decl): New function.\n\t(mangle_method_decl, mangle_type, mangle_pointer_type,\n\tmangle_array_type, mangle_record_type,\n\tfind_compression_pointer_match, find_compression_array_match,\n\tfind_compression_record_match,\n\tfind_compression_array_template_match, set_type_package_list,\n\tentry_match_pointer_p, emit_compression_string, init_mangling,\n\tfinish_mangling, compression_table_add, mangle_member_name): Likewise.\n\t(mangle_obstack): New global.\n\t(MANGLE_RAW_STRING): New macro.\n\t(unicode_mangling_length): Turned static.\n\t(append_unicode_mangled_name): Renamed from\n\t`emit_unicode_mangled_name.'  Turned static. `mangle_obstack'\n\treplaces `obstack', removed from the parameter list.\n\t(append_gpp_mangled_name): Turned static. `mangle_obstack'\n\treplaces parameter `obstack', removed from the parameter list. Call\n\t`append_unicode_mangled_name' instead of `emit_unicode_mangled_name.\n\t(append_gpp_mangled_classtype): Removed.\n\t(compression_table, compression_next): New static variables.\n\t* parse.y (temporary_obstack): Extern declaration removed.\n\n(This is the new C++ ABI compatibility patch:\n  http://gcc.gnu.org/ml/gcc-patches/2001-01/msg01225.html)\n\nFrom-SVN: r39031", "tree": {"sha": "978174af2eae55529af123d6d167212203a572ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/978174af2eae55529af123d6d167212203a572ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc08e603899b1ac1ea91a9ee641853b20521d61e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc08e603899b1ac1ea91a9ee641853b20521d61e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc08e603899b1ac1ea91a9ee641853b20521d61e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc08e603899b1ac1ea91a9ee641853b20521d61e/comments", "author": null, "committer": null, "parents": [{"sha": "b9333bff58209a5669342bfcbb974cf92081f1e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9333bff58209a5669342bfcbb974cf92081f1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9333bff58209a5669342bfcbb974cf92081f1e1"}], "stats": {"total": 1274, "additions": 868, "deletions": 406}, "files": [{"sha": "9cb2b3c16161521a0d17f1e4f5f1fef86de788c1", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -70,6 +70,61 @@\n \t(not_accessible_p): Grant `private' access from within\n \tenclosing contexts.\n \t\n+2001-01-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\tAll files with updated copyright when applicable.\n+\t* Make-lang.in (JVGENMAIN_OBS): Removed java/mangle.o.\n+\t* class.c (mangle_class_field): Function removed.\n+\t(append_gpp_mangled_type, mangle_static_field, mangle_field): Likewise.\n+\t(utf8_cmp, cxx_keyword_p): Moved to lex.c.\n+\t(build_class_ref): Call `java_mangle_class_field' instead of\n+\t`mangle_class_field.'\n+\t(build_dtable_decl): Rewritten to call `java_mangle_vtable.'\n+\t(layout_class): Call `java_mangle_decl' instead of \n+\t`mangle_static_field.'\n+\t(cxx_keywords): Initialized static array moved to `lex.c.'\n+\t(layout_class_method): Changed leading comment. Simplified to\n+\tcall `java_mangle_decl.' Local `ptr' moved in for loop body.\n+\t* decl.c (lang_mark_tree): Mark field `package_list.'\n+\t* java-tree.h (TYPE_PACKAGE_LIST): New macro.\n+\t(struct lang_type): New field `package_list.'\n+\t(unicode_mangling_length): Prototype removed.\n+\t(append_gpp_mangled_name, append_gpp_mangled_classtype,\n+\temit_unicode_mangled_name): Likewise.\n+\t(cxx_keyword_p): New prototype.\n+\t(java_mangle_decl, java_mangle_class_field,\n+\tjava_mangle_class_field_from_string, java_mangle_vtable): Likewise.\n+\t* jcf-parse.c (jcf_parse_source): Constify `file' argument to\n+\t`build_expr_wfl.'\n+\t* jvgenmain.c (main_method_prefix): Global variable removed.\n+\t(main_method_suffix): Likewise.\n+\t(do_mangle_classname): New function.\n+\t(main): Call it. Format changed to accomodate new mangling scheme.\n+\t* lex.c: (utf8_cmp): Conditionally prototyped.\n+\t(cxx_keywords): Moved from class.c, conditionally defined.\n+\t(utf8_cmp, cxx_keyword_p): Likewise.\n+\t* mangle.c (obstack.h, ggc.h): Included.\n+\t(mangle_field_decl): New function.\n+\t(mangle_method_decl, mangle_type, mangle_pointer_type,\n+\tmangle_array_type, mangle_record_type,\n+\tfind_compression_pointer_match, find_compression_array_match,\n+\tfind_compression_record_match,\n+\tfind_compression_array_template_match, set_type_package_list,\n+\tentry_match_pointer_p, emit_compression_string, init_mangling,\n+\tfinish_mangling, compression_table_add, mangle_member_name): Likewise.\n+\t(mangle_obstack): New global.\n+\t(MANGLE_RAW_STRING): New macro.\n+\t(unicode_mangling_length): Turned static.\n+\t(append_unicode_mangled_name): Renamed from\n+\t`emit_unicode_mangled_name.'  Turned static. `mangle_obstack'\n+\treplaces `obstack', removed from the parameter list.\n+\t(append_gpp_mangled_name): Turned static. `mangle_obstack'\n+\treplaces parameter `obstack', removed from the parameter list. Call \n+\t`append_unicode_mangled_name' instead of `emit_unicode_mangled_name.\n+\t(append_gpp_mangled_classtype): Removed.\n+\t(compression_table, compression_next): New static variables.\n+\t* parse.y (temporary_obstack): Extern declaration removed.\n+\n 2001-01-05  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n \n \t* parse.y (patch_binop): Compute missing type in error situations."}, {"sha": "08ced3d85d985069a80c88edd0cf802b885a5736", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,6 +1,6 @@\n # Top level makefile fragment for the GNU compiler for the Java(TM)\n # language.\n-#   Copyright (C) 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n+#   Copyright (C) 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n #This file is part of GNU CC.\n \n@@ -111,7 +111,7 @@ JVSCAN_OBJS = java/parse-scan.o java/jv-scan.o version.o\n JCFDUMP_OBJS = java/jcf-dump.o java/jcf-io.o java/jcf-depend.o java/jcf-path.o \\\n \t\tjava/zextract.o errors.o version.o mkdeps.o\n \n-JVGENMAIN_OBJS = java/jvgenmain.o java/mangle.o\n+JVGENMAIN_OBJS = java/jvgenmain.o\n \n # Use loose warnings for this front end.\n java-warn ="}, {"sha": "5e1e0b8898ebd1034fc7a32a0d34152884e6a41c", "filename": "gcc/java/class.c", "status": "modified", "additions": 12, "deletions": 345, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -37,25 +37,18 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"parse.h\"\n #include \"ggc.h\"\n \n-static tree mangle_class_field PARAMS ((tree class));\n static tree make_method_value PARAMS ((tree));\n static tree build_java_method_type PARAMS ((tree, tree, int));\n static int32 hashUtf8String PARAMS ((const char *, int));\n static tree make_field_value PARAMS ((tree));\n static tree get_dispatch_vector PARAMS ((tree));\n static tree get_dispatch_table PARAMS ((tree, tree));\n-static void append_gpp_mangled_type PARAMS ((struct obstack *, tree));\n-static tree mangle_static_field PARAMS ((tree));\n static void add_interface_do PARAMS ((tree, tree, int));\n static tree maybe_layout_super_class PARAMS ((tree, tree));\n static int assume_compiled PARAMS ((const char *));\n static struct hash_entry *init_test_hash_newfunc PARAMS ((struct hash_entry *,\n \t\t\t\t\t\t\t  struct hash_table *,\n \t\t\t\t\t\t\t  hash_table_key));\n-static int utf8_cmp PARAMS ((const unsigned char *, int, const char *));\n-static int cxx_keyword_p PARAMS ((const char *, int));\n-static tree mangle_field PARAMS ((tree, tree));\n-\n static rtx registerClass_libfunc;\n \n extern struct obstack permanent_obstack;\n@@ -890,7 +883,8 @@ build_class_ref (type)\n \t      TREE_PUBLIC (decl) = 1;\n \t      DECL_IGNORED_P (decl) = 1;\n \t      DECL_ARTIFICIAL (decl) = 1;\n-\t      DECL_ASSEMBLER_NAME (decl) = mangle_class_field (type);\n+\t      DECL_ASSEMBLER_NAME (decl) = \n+\t\tjava_mangle_class_field (&temporary_obstack, type);\n \t      make_decl_rtl (decl, NULL);\n \t      pushdecl_top_level (decl);\n \t      if (is_compiled == 1)\n@@ -1545,147 +1539,13 @@ is_compiled_class (class)\n   return 0;\n }\n \n-/* Append the mangled name of TYPE onto OBSTACK. */\n-\n-static void\n-append_gpp_mangled_type (obstack, type)\n-     struct obstack *obstack;\n-     tree type;\n-{\n-  switch (TREE_CODE (type))\n-    {\n-      char code;\n-    case BOOLEAN_TYPE: code = 'b';  goto primitive;\n-    case CHAR_TYPE:    code = 'w';  goto primitive;\n-    case VOID_TYPE:    code = 'v';  goto primitive;\n-    case INTEGER_TYPE:\n-      /* Get the original type instead of the arguments promoted type.\n-\t Avoid symbol name clashes. Should call a function to do that.\n-\t FIXME.  */\n-      if (type == promoted_short_type_node)\n-\ttype = short_type_node;\n-      if (type == promoted_byte_type_node)\n-        type = byte_type_node;\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase  8:       code = 'c';  goto primitive;\n-\tcase 16:       code = 's';  goto primitive;\n-\tcase 32:       code = 'i';  goto primitive;\n-\tcase 64:       code = 'x';  goto primitive;\n-\tdefault:  goto bad_type;\n-\t}\n-    primitive:\n-      obstack_1grow (obstack, code);\n-      break;\n-    case REAL_TYPE:\n-      switch (TYPE_PRECISION (type))\n-\t{\n-\tcase 32:       code = 'f';  goto primitive;\n-\tcase 64:       code = 'd';  goto primitive;\n-\tdefault:  goto bad_type;\n-\t}\n-    case POINTER_TYPE:\n-      type = TREE_TYPE (type);\n-      obstack_1grow (obstack, 'P');\n-    case RECORD_TYPE:\n-      if (TYPE_ARRAY_P (type))\n-\t{\n-\t  obstack_grow (obstack, \"t6JArray1Z\", sizeof(\"t6JArray1Z\")-1);\n-\t  append_gpp_mangled_type (obstack, TYPE_ARRAY_ELEMENT (type));\n-\t}\n-      else\n-\t{\n-\t  const char *class_name = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n-\t  append_gpp_mangled_classtype (obstack, class_name);\n-\t}\n-      break;\n-    bad_type:\n-    default:\n-      fatal (\"internal error - trying to mangle unknown type\");\n-    }\n-}\n-\n-/* Build the mangled name of a field, given the class name and the\n-   field name.  */\n-\n-static tree\n-mangle_field (class, name)\n-     tree class, name;\n-{\n-  int encoded_len;\n-#if ! defined (NO_DOLLAR_IN_LABEL) || ! defined (NO_DOT_IN_LABEL)\n-  obstack_1grow (&temporary_obstack, '_');\n-#else\n-  obstack_grow (&temporary_obstack, \"__static_\", 9);\n-#endif\n-  append_gpp_mangled_type (&temporary_obstack, class);\n-  encoded_len = unicode_mangling_length (IDENTIFIER_POINTER (name),\n-\t\t\t\t\t IDENTIFIER_LENGTH (name));\n-  if (encoded_len > 0)\n-    {\n-      obstack_1grow (&temporary_obstack, 'U');\n-    }\n-#ifndef NO_DOLLAR_IN_LABEL\n-  obstack_1grow (&temporary_obstack, '$');\n-#else /* NO_DOLLAR_IN_LABEL */\n-#ifndef NO_DOT_IN_LABEL\n-  obstack_1grow (&temporary_obstack, '.');\n-#else /* NO_DOT_IN_LABEL */\n-  obstack_1grow (&temporary_obstack, '_');\n-#endif  /* NO_DOT_IN_LABEL */\n-#endif  /* NO_DOLLAR_IN_LABEL */\n-  if (encoded_len > 0)\n-    {\n-      emit_unicode_mangled_name (&temporary_obstack,\n-\t\t\t\t IDENTIFIER_POINTER (name), \n-\t\t\t\t IDENTIFIER_LENGTH (name));\n-    }\n-  else\n-    {\n-      obstack_grow (&temporary_obstack,\n-\t\t    IDENTIFIER_POINTER (name),\n-\t\t    IDENTIFIER_LENGTH (name));\n-    }\n-\n-  /* Mangle C++ keywords by appending a `$'.  */\n-  /* FIXME: NO_DOLLAR_IN_LABEL */\n-  if (cxx_keyword_p (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name)))\n-    obstack_grow (&temporary_obstack, \"$\", 1);\n-\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  name = get_identifier (obstack_base (&temporary_obstack));\n-  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n-  return name;\n-}\n-\n-/* Build the mangled name of the `class' field.  */\n-\n-static tree\n-mangle_class_field (class)\n-     tree class;\n-{\n-  /* We know that we can use `class$' to mangle the class object,\n-     because `class' is a reserved word in Java and thus can't appear\n-     as a field or method name.  */\n-  return mangle_field (class, get_identifier (\"class$\"));\n-}\n-\n-/* Build the mangled (assembly-level) name of the static field FIELD. */\n-\n-static tree\n-mangle_static_field (field)\n-     tree field;\n-{\n-  return mangle_field (DECL_CONTEXT (field), DECL_NAME (field));\n-}\n-\n /* Build a VAR_DECL for the dispatch table (vtable) for class TYPE. */\n \n tree\n build_dtable_decl (type)\n      tree type;\n {\n-  tree name, dtype;\n+  tree dtype;\n \n   /* We need to build a new dtable type so that its size is uniquely\n      computed when we're dealing with the class for real and not just\n@@ -1706,12 +1566,8 @@ build_dtable_decl (type)\n   else\n     dtype = dtable_type;\n \n-  obstack_grow (&temporary_obstack, \"__vt_\", 5);\n-  append_gpp_mangled_type (&temporary_obstack, type);\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  name = get_identifier (obstack_base (&temporary_obstack));\n-  obstack_free (&temporary_obstack, obstack_base (&temporary_obstack));\n-  return build_decl (VAR_DECL, name, dtype);\n+  return build_decl (VAR_DECL, \n+\t\t     java_mangle_vtable (&temporary_obstack, type), dtype);\n }\n \n /* Pre-pend the TYPE_FIELDS of THIS_CLASS with a dummy FIELD_DECL for the\n@@ -1836,7 +1692,8 @@ layout_class (this_class)\n       if (FIELD_STATIC (field))\n \t{\n \t  /* Set DECL_ASSEMBLER_NAME to something suitably mangled. */\n-\t  DECL_ASSEMBLER_NAME (field) = mangle_static_field (field);\n+\t  DECL_ASSEMBLER_NAME (field) = \n+\t    java_mangle_decl (&temporary_obstack, field);\n \t}\n     }\n \n@@ -1916,218 +1773,38 @@ layout_class_methods (this_class)\n #endif\n }\n \n-/* A sorted list of all C++ keywords.  */\n-\n-static const char *cxx_keywords[] =\n-{\n-  \"asm\",\n-  \"auto\",\n-  \"bool\",\n-  \"const_cast\",\n-  \"delete\",\n-  \"dynamic_cast\",\n-  \"enum\",\n-  \"explicit\",\n-  \"extern\",\n-  \"friend\",\n-  \"inline\",\n-  \"mutable\",\n-  \"namespace\",\n-  \"overload\",\n-  \"register\",\n-  \"reinterpret_cast\",\n-  \"signed\",\n-  \"sizeof\",\n-  \"static_cast\",\n-  \"struct\",\n-  \"template\",\n-  \"typedef\",\n-  \"typeid\",\n-  \"typename\",\n-  \"typenameopt\",\n-  \"union\",\n-  \"unsigned\",\n-  \"using\",\n-  \"virtual\",\n-  \"volatile\",\n-  \"wchar_t\"\n-};\n-\n /* Return 0 if NAME is equal to STR, -1 if STR is \"less\" than NAME,\n    and 1 if STR is \"greater\" than NAME.  */\n \n-static int\n-utf8_cmp (str, length, name)\n-     const unsigned char *str;\n-     int length;\n-     const char *name;\n-{\n-  const unsigned char *limit = str + length;\n-  int i;\n-\n-  for (i = 0; name[i]; ++i)\n-    {\n-      int ch = UTF8_GET (str, limit);\n-      if (ch != name[i])\n-\treturn ch - name[i];\n-    }\n-\n-  return str == limit ? 0 : 1;\n-}\n-\n-/* Return true if NAME is a C++ keyword.  */\n-\n-static int\n-cxx_keyword_p (name, length)\n-     const char *name;\n-     int length;\n-{\n-  int last = ARRAY_SIZE (cxx_keywords);\n-  int first = 0;\n-  int mid = (last + first) / 2;\n-  int old = -1;\n-\n-  for (mid = (last + first) / 2;\n-       mid != old;\n-       old = mid, mid = (last + first) / 2)\n-    {\n-      int kwl = strlen (cxx_keywords[mid]);\n-      int min_length = kwl > length ? length : kwl;\n-      int r = utf8_cmp (name, min_length, cxx_keywords[mid]);\n-\n-      if (r == 0)\n-\t{\n-\t  int i;\n-\t  /* We've found a match if all the remaining characters are\n-\t     `$'.  */\n-\t  for (i = min_length; i < length && name[i] == '$'; ++i)\n-\t    ;\n-\t  if (i == length)\n-\t    return 1;\n-\t  r = 1;\n-\t}\n-\n-      if (r < 0)\n-\tlast = mid;\n-      else\n-\tfirst = mid;\n-    }\n-  return 0;\n-}\n-\n /* Lay METHOD_DECL out, returning a possibly new value of\n-   DTABLE_COUNT.  */\n+   DTABLE_COUNT. Also mangle the method's name. */\n \n tree\n layout_class_method (this_class, super_class, method_decl, dtable_count)\n      tree this_class, super_class, method_decl, dtable_count;\n {\n-  const char *ptr;\n-  char *asm_name;\n-  tree arg, arglist, t;\n-  int method_name_needs_escapes = 0;\n   tree method_name = DECL_NAME (method_decl);\n   int method_name_is_wfl = \n     (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION);\n   if (method_name_is_wfl)\n     method_name = java_get_real_method_name (method_decl);\n \n-  if (!ID_INIT_P (method_name) && !ID_FINIT_P (method_name))\n-    {\n-      int encoded_len\n-\t= unicode_mangling_length (IDENTIFIER_POINTER (method_name), \n-\t\t\t\t   IDENTIFIER_LENGTH (method_name));\n-      if (encoded_len > 0)\n-\t{\n-\t  method_name_needs_escapes = 1;\n-\t  emit_unicode_mangled_name (&temporary_obstack,\n-\t\t\t\t     IDENTIFIER_POINTER (method_name), \n-\t\t\t\t     IDENTIFIER_LENGTH (method_name));\n-\t}\n-      else\n-\t{\n-\t  obstack_grow (&temporary_obstack,\n-\t\t\tIDENTIFIER_POINTER (method_name),\n-\t\t\tIDENTIFIER_LENGTH (method_name));\n-\t}\n-\n-      /* Mangle C++ keywords by appending a `$'.  */\n-      /* FIXME: NO_DOLLAR_IN_LABEL */\n-      if (cxx_keyword_p (IDENTIFIER_POINTER (method_name),\n-\t\t\t IDENTIFIER_LENGTH (method_name)))\n-\tobstack_grow (&temporary_obstack, \"$\", 1);\n-    }\n-\n-  obstack_grow (&temporary_obstack, \"__\", 2);\n-  if (ID_FINIT_P (method_name))\n-    obstack_grow (&temporary_obstack, \"finit\", 5);\n-  append_gpp_mangled_type (&temporary_obstack, this_class);\n   TREE_PUBLIC (method_decl) = 1;\n \n-  t = TREE_TYPE (method_decl);\n-  arglist = TYPE_ARG_TYPES (t);\n-  if (TREE_CODE (t) == METHOD_TYPE)\n-    arglist = TREE_CHAIN (arglist);\n-  for (arg = arglist; arg != end_params_node;  )\n-    {\n-      tree a = arglist;\n-      tree argtype = TREE_VALUE (arg);\n-      int tindex = 1;\n-      if (TREE_CODE (argtype) == POINTER_TYPE)\n-\t{\n-\t  /* This is O(N**2).  Do we care?  Cfr gcc/cp/method.c. */\n-\t  while (a != arg && argtype != TREE_VALUE (a))\n-\t    a = TREE_CHAIN (a), tindex++;\n-\t}\n-      else\n-\ta = arg;\n-      if (a != arg)\n-\t{\n-\t  char buf[12];\n-\t  int nrepeats = 0;\n-\t  do\n-\t    {\n-\t      arg = TREE_CHAIN (arg); nrepeats++;\n-\t    }\n-\t  while (arg != end_params_node && argtype == TREE_VALUE (arg));\n-\t  if (nrepeats > 1)\n-\t    {\n-\t      obstack_1grow (&temporary_obstack, 'N');\n-\t      sprintf (buf, \"%d\", nrepeats);\n-\t      obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t      if (nrepeats > 9)\n-\t\tobstack_1grow (&temporary_obstack, '_');\n-\t    }\n-\t  else\n-\t    obstack_1grow (&temporary_obstack, 'T');\n-\t  sprintf (buf, \"%d\", tindex);\n-\t  obstack_grow (&temporary_obstack, buf, strlen (buf));\n-\t  if (tindex > 9)\n-\t    obstack_1grow (&temporary_obstack, '_');\n-\t}\n-      else\n-\t{\n-\t  append_gpp_mangled_type (&temporary_obstack, argtype);\n-\t  arg = TREE_CHAIN (arg);\n-\t}\n-    }\n-  if (method_name_needs_escapes)\n-    obstack_1grow (&temporary_obstack, 'U');\n-\n-  obstack_1grow (&temporary_obstack, '\\0');\n-  asm_name = obstack_finish (&temporary_obstack);\n-  DECL_ASSEMBLER_NAME (method_decl) = get_identifier (asm_name);\n+  /* This is a good occasion to mangle the method's name */\n+  DECL_ASSEMBLER_NAME (method_decl) = \n+    java_mangle_decl (&temporary_obstack, method_decl);\n   /* We don't generate a RTL for the method if it's abstract, or if\n      it's an interface method that isn't clinit. */\n   if (! METHOD_ABSTRACT (method_decl) \n       || (CLASS_INTERFACE (TYPE_NAME (this_class)) \n \t  && (DECL_CLINIT_P (method_decl))))\n     make_decl_rtl (method_decl, NULL);\n-  obstack_free (&temporary_obstack, asm_name);\n \n   if (ID_INIT_P (method_name))\n     {\n       const char *p = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (this_class)));\n+      const char *ptr;\n       for (ptr = p; *ptr; )\n \t{\n \t  if (*ptr++ == '.')\n@@ -2153,16 +1830,6 @@ layout_class_method (this_class, super_class, method_decl, dtable_count)\n \t      && !CLASS_FROM_SOURCE_P (this_class))\n \t    error_with_decl (method_decl,\n \t\t\t     \"non-static method '%s' overrides static method\");\n-#if 0\n-\t  else if (TREE_TYPE (TREE_TYPE (method_decl))\n-\t\t   != TREE_TYPE (TREE_TYPE (super_method)))\n-\t    {\n-\t      error_with_decl (method_decl,\n-\t\t\t       \"Method `%s' redefined with different return type\");  \n-\t      error_with_decl (super_method,\n-\t\t\t       \"Overridden decl is here\");\n-\t    }\n-#endif\n \t}\n       else if (! METHOD_FINAL (method_decl)\n \t       && ! METHOD_PRIVATE (method_decl)"}, {"sha": "0175b32e905facf38197661cf0d61ff78148b566", "filename": "gcc/java/decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1939,6 +1939,7 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (lt->clinit_stmt_list);\n \t  ggc_mark_tree (lt->ii_block);\n \t  ggc_mark_tree (lt->dot_class);\n+\t  ggc_mark_tree (lt->package_list);\n \t}\n     }\n }"}, {"sha": "ed6ee9aa5c7abd0cd900c45039eb9a062edab1d2", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,6 +1,6 @@\n /* Definitions for parsing and type checking for the GNU compiler for\n    the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -892,6 +892,7 @@ struct lang_decl_var\n /* The decl of the synthetic method `class$' used to handle `.class'\n    for non primitive types when compiling to bytecode. */\n #define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC(T)->dot_class)\n+#define TYPE_PACKAGE_LIST(T)     (TYPE_LANG_SPECIFIC(T)->package_list)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n #define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n #define TYPE_HAS_FINAL_VARIABLE(T) (TYPE_LANG_SPECIFIC(T)->afv)\n@@ -909,6 +910,7 @@ struct lang_type\n \t\t\t\t   needs to be invoked and generated when\n \t\t\t\t   compiling to bytecode to implement\n \t\t\t\t   <non_primitive_type>.class */\n+  tree package_list;\t\t/* List of package names, progressive */\n   unsigned pic:1;\t\t/* Private Inner Class. */\n   unsigned poic:1;\t\t/* Protected Inner Class. */\n   unsigned afv:1;\t\t/* Has final variables */\n@@ -1042,7 +1044,6 @@ extern void check_for_initialization PARAMS ((tree));\n \n extern tree pushdecl_top_level PARAMS ((tree));\n extern int alloc_class_constant PARAMS ((tree));\n-extern int unicode_mangling_length PARAMS ((const char *, int));\n extern void init_expr_processing PARAMS ((void));\n extern void push_super_field PARAMS ((tree, tree));\n extern void init_class_processing PARAMS ((void));\n@@ -1060,9 +1061,6 @@ extern int push_type_0 PARAMS ((tree));\n extern void push_type PARAMS ((tree));\n extern void load_type_state PARAMS ((tree));\n extern void add_interface PARAMS ((tree, tree));\n-extern void append_gpp_mangled_name PARAMS ((struct obstack *, const char *, int));\n-extern void append_gpp_mangled_classtype PARAMS ((struct obstack *, const char *));\n-extern void emit_unicode_mangled_name PARAMS ((struct obstack *, const char *, int));\n extern tree force_evaluation_order PARAMS ((tree));\n extern int verify_constant_pool PARAMS ((struct JCF *));\n extern void start_java_method PARAMS ((tree));\n@@ -1111,6 +1109,12 @@ extern boolean java_hash_compare_tree_node PARAMS ((hash_table_key,\n \t\t\t\t\t\t    hash_table_key));\n extern void java_check_methods PARAMS ((tree));\n extern void init_jcf_parse PARAMS((void));\n+\n+extern int cxx_keyword_p PARAMS ((const char *, int));\n+extern tree java_mangle_decl PARAMS ((struct obstack *, tree));\n+extern tree java_mangle_class_field PARAMS ((struct obstack *, tree));\n+extern tree java_mangle_class_field_from_string PARAMS ((struct obstack *, char *));\n+extern tree java_mangle_vtable PARAMS ((struct obstack *, tree));\n extern const char *lang_printable_name_wls PARAMS ((tree, int));\n \n /* We use ARGS_SIZE_RTX to indicate that gcc/expr.h has been included"}, {"sha": "e917d1db2e2b59a51995ddc6aebbe7d260178e3a", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,5 +1,5 @@\n /* Parser for Java(TM) .class files.\n-   Copyright (C) 1996, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1996, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "2eaa02f1e6688fbaa03aaa07c81f469eb0df4e8f", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,5 +1,5 @@\n /* Program to generate \"main\" a Java(TM) class containing a main method.\n-   Copyright (C) 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -32,8 +32,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"tree.h\"\n #include \"java-tree.h\"\n \n-const char main_method_prefix[] = \"main__\";\n-const char main_method_suffix[] = \"Pt6JArray1ZPQ34java4lang6String\";\n+static char * do_mangle_classname PARAMS ((const char *string));\n+\n const char class_mangling_suffix[] = \"class$\";\n \n struct obstack name_obstack;\n@@ -116,9 +116,7 @@ main (int argc, const char **argv)\n   classname = argv[i];\n \n   gcc_obstack_init (&name_obstack);\n-  append_gpp_mangled_classtype (&name_obstack, classname);\n-  obstack_1grow (&name_obstack, '\\0');\n-  mangled_classname = obstack_finish (&name_obstack);\n+  mangled_classname = do_mangle_classname (classname);\n \n   if (i < argc - 1 && strcmp (argv[i + 1], \"-\") != 0)\n     {\n@@ -155,13 +153,8 @@ main (int argc, const char **argv)\n     }\n   fprintf (stream, \"  0\\n};\\n\\n\");\n \n-#ifndef NO_DOLLAR_IN_LABEL\n-  fprintf (stream, \"extern int class __attribute__ ((alias (\\\"_%s$%s\\\")));\\n\",\n-\t   mangled_classname, class_mangling_suffix);\n-#else\n-  fprintf (stream, \"extern int class __attribute__ ((alias (\\\"_%s.%s\\\")));\\n\",\n-\t   mangled_classname, class_mangling_suffix);\n-#endif\n+  fprintf (stream, \"extern int class __attribute__ ((alias (\\\"%s\\\")));\\n\",\n+\t   mangled_classname);\n   fprintf (stream, \"int main (int argc, const char **argv)\\n\");\n   fprintf (stream, \"{\\n\");\n   fprintf (stream, \"   _Jv_Compiler_Properties = props;\\n\");\n@@ -175,3 +168,36 @@ main (int argc, const char **argv)\n     }\n   return 0;\n }\n+\n+\n+static char *\n+do_mangle_classname (string)\n+     const char *string;\n+{\n+  char *ptr;\n+  int count = 0;\n+\n+#define MANGLE_NAME()\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    char buffer [128];\t\t\t\t\t\t\\\n+    sprintf (buffer, \"%d\", count);\t\t\t\t\\\n+    obstack_grow (&name_obstack, buffer, strlen (buffer));\t\\\n+    obstack_grow (&name_obstack, & ptr [-count], count);\t\\\n+    count = 0;\t\t\t\t\t\t\t\\\n+  }\n+\n+  obstack_grow (&name_obstack, \"_ZN\", 3);\n+\n+  for (ptr = (char *)string; *ptr; ptr++ )\n+    {\n+      if (ptr[0] == '.')\n+\t{\n+\t  MANGLE_NAME ();\n+\t}\n+      else\n+\tcount++;\n+    }\n+  MANGLE_NAME ();\n+  obstack_grow0 (&name_obstack, \"6class$E\", 8);\n+  return obstack_finish (&name_obstack);\n+}"}, {"sha": "32c104e770cb38c5378b4533768980f2db06c91c", "filename": "gcc/java/lex.c", "status": "modified", "additions": 103, "deletions": 1, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,5 +1,5 @@\n /* Language lexer for the GNU compiler for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -61,6 +61,10 @@ static int java_read_char PARAMS ((java_lexer *));\n static void java_allocate_new_line PARAMS ((void));\n static void java_unget_unicode PARAMS ((void));\n static unicode_t java_sneak_unicode PARAMS ((void));\n+#ifndef JC1_LITE\n+static int utf8_cmp PARAMS ((const unsigned char *, int, const char *));\n+#endif\n+\n java_lexer *java_new_lexer PARAMS ((FILE *, const char *));\n \n /* This is nonzero if we have initialized `need_byteswap'.  */\n@@ -1763,3 +1767,101 @@ java_get_line_col (filename, line, col)\n   return obstack_finish (&temporary_obstack);\n #endif\n }\n+\n+#ifndef JC1_LITE\n+static int\n+utf8_cmp (str, length, name)\n+     const unsigned char *str;\n+     int length;\n+     const char *name;\n+{\n+  const unsigned char *limit = str + length;\n+  int i;\n+\n+  for (i = 0; name[i]; ++i)\n+    {\n+      int ch = UTF8_GET (str, limit);\n+      if (ch != name[i])\n+\treturn ch - name[i];\n+    }\n+\n+  return str == limit ? 0 : 1;\n+}\n+\n+/* A sorted list of all C++ keywords.  */\n+\n+static const char *cxx_keywords[] =\n+{\n+  \"asm\",\n+  \"auto\",\n+  \"bool\",\n+  \"const_cast\",\n+  \"delete\",\n+  \"dynamic_cast\",\n+  \"enum\",\n+  \"explicit\",\n+  \"extern\",\n+  \"friend\",\n+  \"inline\",\n+  \"mutable\",\n+  \"namespace\",\n+  \"overload\",\n+  \"register\",\n+  \"reinterpret_cast\",\n+  \"signed\",\n+  \"sizeof\",\n+  \"static_cast\",\n+  \"struct\",\n+  \"template\",\n+  \"typedef\",\n+  \"typeid\",\n+  \"typename\",\n+  \"typenameopt\",\n+  \"union\",\n+  \"unsigned\",\n+  \"using\",\n+  \"virtual\",\n+  \"volatile\",\n+  \"wchar_t\"\n+};\n+\n+/* Return true if NAME is a C++ keyword.  */\n+\n+int\n+cxx_keyword_p (name, length)\n+     const char *name;\n+     int length;\n+{\n+  int last = ARRAY_SIZE (cxx_keywords);\n+  int first = 0;\n+  int mid = (last + first) / 2;\n+  int old = -1;\n+\n+  for (mid = (last + first) / 2;\n+       mid != old;\n+       old = mid, mid = (last + first) / 2)\n+    {\n+      int kwl = strlen (cxx_keywords[mid]);\n+      int min_length = kwl > length ? length : kwl;\n+      int r = utf8_cmp (name, min_length, cxx_keywords[mid]);\n+\n+      if (r == 0)\n+\t{\n+\t  int i;\n+\t  /* We've found a match if all the remaining characters are\n+\t     `$'.  */\n+\t  for (i = min_length; i < length && name[i] == '$'; ++i)\n+\t    ;\n+\t  if (i == length)\n+\t    return 1;\n+\t  r = 1;\n+\t}\n+\n+      if (r < 0)\n+\tlast = mid;\n+      else\n+\tfirst = mid;\n+    }\n+  return 0;\n+}\n+#endif /* JC1_LITE */"}, {"sha": "080d45533503393b03f84c385ada01f8a2b14b6f", "filename": "gcc/java/mangle.c", "status": "modified", "additions": 645, "deletions": 37, "changes": 682, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fmangle.c?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,6 +1,6 @@\n /* Functions related to mangling class names for the GNU compiler\n    for the Java(TM) language.\n-   Copyright (C) 1998, 1999 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2001 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -32,12 +32,211 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"java-tree.h\"\n #include \"obstack.h\"\n #include \"toplev.h\"\n+#include \"obstack.h\"\n+#include \"ggc.h\"\n+\n+static void mangle_field_decl PARAMS ((tree));\n+static void mangle_method_decl PARAMS ((tree));\n+\n+static void mangle_type PARAMS ((tree));\n+static void mangle_pointer_type PARAMS ((tree));\n+static void mangle_array_type PARAMS ((tree));\n+static int  mangle_record_type PARAMS ((tree, int));\n+\n+static int find_compression_pointer_match PARAMS ((tree));\n+static int find_compression_array_match PARAMS ((tree));\n+static int find_compression_record_match PARAMS ((tree, tree *));\n+static int find_compression_array_template_match PARAMS ((tree));\n+\n+static void set_type_package_list PARAMS ((tree));\n+static int  entry_match_pointer_p PARAMS ((tree, int));\n+static void emit_compression_string PARAMS ((int));\n+\n+static void init_mangling PARAMS ((struct obstack *));\n+static tree finish_mangling PARAMS ((void));\n+static void compression_table_add PARAMS ((tree));\n+\n+static void append_unicode_mangled_name PARAMS ((const char *, int));\n+static void append_gpp_mangled_name PARAMS ((const char *, int));\n+static int  unicode_mangling_length PARAMS ((const char *, int));\n+static int  mangle_member_name PARAMS ((tree));\n+\n+/* We use an incoming obstack, always to be provided to the interface\n+   functions. */\n+struct obstack *mangle_obstack;\n+#define MANGLE_RAW_STRING(S) \\\n+  obstack_grow (mangle_obstack, (S), sizeof (S)-1)\n+\n+/* This is the mangling interface: a decl, a class field (.class) and\n+   the vtable. */\n+\n+tree\n+java_mangle_decl (obstack, decl)\n+     struct obstack *obstack;\n+     tree decl;\n+{\n+  init_mangling (obstack);\n+  switch (TREE_CODE (decl))\n+    {\n+    case VAR_DECL:\n+      mangle_field_decl (decl);\n+      break;\n+    case FUNCTION_DECL:\n+      mangle_method_decl (decl);\n+      break;\n+    default:\n+      fatal (\"Can't mangle `%s\\' -- java_mangle_decl\", \n+\t     tree_code_name [TREE_CODE (decl)]);\n+    }\n+  return finish_mangling ();\n+}\n+\n+tree \n+java_mangle_class_field (obstack, type)\n+     struct obstack *obstack;\n+     tree type;\n+{\n+  init_mangling (obstack);\n+  mangle_record_type (type, /* from_pointer = */ 0);\n+  MANGLE_RAW_STRING (\"6class$\");\n+  obstack_1grow (mangle_obstack, 'E');\n+  return finish_mangling ();\n+}\n+\n+tree\n+java_mangle_vtable (obstack, type)\n+     struct obstack *obstack;\n+     tree type;\n+{\n+  init_mangling (obstack);\n+  MANGLE_RAW_STRING (\"TV\");\n+  mangle_record_type (type, /* from_pointer = */ 0);\n+  obstack_1grow (mangle_obstack, 'E');\n+  return finish_mangling ();\n+}\n+\n+/* Beginning of the helper functions */\n+\n+/* This mangles a field decl */\n+\n+static void\n+mangle_field_decl (decl)\n+     tree decl;\n+{\n+  tree name = DECL_NAME (decl);\n+  int field_name_needs_escapes = 0;\n+\n+  /* Mangle the name of the this the field belongs to */\n+  mangle_record_type (DECL_CONTEXT (decl), /* from_pointer = */ 0);\n+  \n+  /* Mangle the name of the field */\n+  field_name_needs_escapes = mangle_member_name (name);\n+\n+  /* Terminate the mangled name */\n+  obstack_1grow (mangle_obstack, 'E');\n+  if (field_name_needs_escapes)\n+    obstack_1grow (mangle_obstack, 'U');\n+}\n+\n+/* This mangles a method decl, first mangling its name and then all\n+   its arguments. */\n+\n+static void\n+mangle_method_decl (mdecl)\n+     tree mdecl;\n+{\n+  tree method_name = DECL_NAME (mdecl);\n+  tree arglist;\n+  int method_name_needs_escapes = 0;\n+\n+  /* Mangle the name of the type that contains mdecl */\n+  mangle_record_type (DECL_CONTEXT (mdecl), /* from_pointer = */ 0);\n+\n+  /* Before working on the method name, get to it. It might be burried\n+     in a WFL. */\n+  if (TREE_CODE (method_name) == EXPR_WITH_FILE_LOCATION)\n+    method_name = java_get_real_method_name (mdecl);\n+\n+  /* Mangle the function name. There three cases\n+       - mdecl is java.lang.Object.Object(), use `C2' for its name\n+         (denotes a base object constructor.)\n+       - mdecl is a constructor, use `C1' for its name, (denotes a\n+         complete object constructor.)\n+       - mdecl is not a constructor, standard mangling is performed.\n+     We terminate the mangled function name with a `E'. */\n+  if (ID_INIT_P (method_name))\n+    {\n+      if (DECL_CONTEXT (mdecl) == object_type_node)\n+\tobstack_grow (mangle_obstack, \"C2\", 2);\n+      else\n+\tobstack_grow (mangle_obstack, \"C1\", 2);\n+    }\n+  else\n+    method_name_needs_escapes = mangle_member_name (method_name);\n+  obstack_1grow (mangle_obstack, 'E');\n+\n+  /* We mangled type.methodName. Now onto the arguments. */\n+  arglist = TYPE_ARG_TYPES (TREE_TYPE (mdecl));\n+  if (TREE_CODE (TREE_TYPE (mdecl)) == METHOD_TYPE)\n+    arglist = TREE_CHAIN (arglist);\n+  \n+  /* No arguments is easy. We shortcut it. */\n+  if (arglist == end_params_node)\n+    obstack_1grow (mangle_obstack, 'v');\n+  else\n+    {\n+      tree arg;\n+      for (arg = arglist; arg != end_params_node;  arg = TREE_CHAIN (arg))\n+\tmangle_type (TREE_VALUE (arg));\n+    }\n+\n+  /* Terminate the mangled name */\n+  if (method_name_needs_escapes)\n+    obstack_1grow (mangle_obstack, 'U');\n+}\n+\n+/* This mangles a member name, like a function name or a field\n+   name. Handle cases were `name' is a C++ keyword.  Return a non zero\n+   value if unicode encoding was required.  */\n+\n+static int\n+mangle_member_name (name)\n+     tree name;\n+{\n+  const char * name_string = IDENTIFIER_POINTER (name);\n+  int len = IDENTIFIER_LENGTH (name);\n+  int to_return = 0;\n+\n+  if (unicode_mangling_length (name_string, len) > 0)\n+    {\n+      append_unicode_mangled_name (name_string, len);\n+      to_return = 1;\n+    }\n+  else\n+    append_gpp_mangled_name (name_string, len);\n+\n+  /* If NAME happens to be a C++ keyword, add `$' or `.' or `_'. */\n+  if (cxx_keyword_p (IDENTIFIER_POINTER (name), IDENTIFIER_LENGTH (name)))\n+    {\n+#ifndef NO_DOLLAR_IN_LABEL\n+      obstack_1grow (mangle_obstack, '$');\n+#else  /* NO_DOLLAR_IN_LABEL */\n+#ifndef NO_DOT_IN_LABEL\n+      obstack_1grow (mangle_obstack, '.');\n+#else  /* NO_DOT_IN_LABEL */\n+      obstack_1grow (mangle_obstack, '_');\n+#endif /* NO_DOT_IN_LABEL */\n+#endif /* NO_DOLLAR_IN_LABEL */\n+    }\n+\n+  return to_return;\n+}\n \n /* Assuming (NAME, LEN) is a Utf8-encoding string, calculate\n    the length of the string as mangled (a la g++) including Unicode escapes.\n    If no escapes are needed, return 0. */\n \n-int\n+static int\n unicode_mangling_length (name, len)\n      const char *name; \n      int len; \n@@ -69,9 +268,8 @@ unicode_mangling_length (name, len)\n /* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n    appropriately mangled (with Unicode escapes) to OBSTACK. */\n \n-void\n-emit_unicode_mangled_name (obstack, name, len)\n-     struct obstack *obstack;\n+static void\n+append_unicode_mangled_name (name, len)\n      const char *name;\n      int len;\n {\n@@ -94,21 +292,20 @@ emit_unicode_mangled_name (obstack, name, len)\n \t{\n \t  char buf[6];\n \t  sprintf (buf, \"_%04x\", ch);\n-\t  obstack_grow (obstack, buf, 5);\n+\t  obstack_grow (mangle_obstack, buf, 5);\n \t}\n       else\n \t{\n-\t  obstack_1grow (obstack, ch);\n+\t  obstack_1grow (mangle_obstack, ch);\n \t}\n     }\n }\n \n /* Assuming (NAME, LEN) is a Utf8-encoding string, emit the string\n    appropriately mangled (with Unicode escapes if needed) to OBSTACK. */\n \n-void\n-append_gpp_mangled_name (obstack, name, len)\n-     struct obstack *obstack;\n+static void\n+append_gpp_mangled_name (name, len)\n      const char *name;\n      int len;\n {\n@@ -118,49 +315,460 @@ append_gpp_mangled_name (obstack, name, len)\n   if (needs_escapes)\n     {\n       sprintf (buf, \"U%d\", encoded_len);\n-      obstack_grow (obstack, buf, strlen(buf));\n-      emit_unicode_mangled_name (obstack, name, len);\n+      obstack_grow (mangle_obstack, buf, strlen(buf));\n+      append_unicode_mangled_name (name, len);\n     }\n   else\n     {\n       sprintf (buf, \"%d\", len);\n-      obstack_grow (obstack, buf, strlen(buf));\n-      obstack_grow (obstack, name, len);\n+      obstack_grow (mangle_obstack, buf, strlen(buf));\n+      obstack_grow (mangle_obstack, name, len);\n     }\n }\n \n-/* Append the mangled name of a class named CLASSNAME onto OBSTACK. */\n+/* Append the mangled name of TYPE onto OBSTACK.  */\n \n-void\n-append_gpp_mangled_classtype (obstack, class_name)\n-     struct obstack *obstack;\n-     const char *class_name;\n+static void\n+mangle_type (type)\n+     tree type;\n+{\n+  switch (TREE_CODE (type))\n+    {\n+      char code;\n+    case BOOLEAN_TYPE: code = 'b';  goto primitive;\n+    case CHAR_TYPE:    code = 'w';  goto primitive;\n+    case VOID_TYPE:    code = 'v';  goto primitive;\n+    case INTEGER_TYPE:\n+      /* Get the original type instead of the arguments promoted type.\n+\t Avoid symbol name clashes. Should call a function to do that.\n+\t FIXME.  */\n+      if (type == promoted_short_type_node)\n+\ttype = short_type_node;\n+      if (type == promoted_byte_type_node)\n+        type = byte_type_node;\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase  8:       code = 'c';  goto primitive;\n+\tcase 16:       code = 's';  goto primitive;\n+\tcase 32:       code = 'i';  goto primitive;\n+\tcase 64:       code = 'x';  goto primitive;\n+\tdefault:  goto bad_type;\n+\t}\n+    primitive:\n+      obstack_1grow (mangle_obstack, code);\n+      break;\n+\n+    case REAL_TYPE:\n+      switch (TYPE_PRECISION (type))\n+\t{\n+\tcase 32:       code = 'f';  goto primitive;\n+\tcase 64:       code = 'd';  goto primitive;\n+\tdefault:  goto bad_type;\n+\t}\n+    case POINTER_TYPE:\n+      if (TYPE_ARRAY_P (TREE_TYPE (type)))\n+\tmangle_array_type (type);\n+      else\n+\tmangle_pointer_type (type);\n+      break;\n+    bad_type:\n+    default:\n+      fatal (\"internal error - trying to mangle unknown type\");\n+    }\n+}\n+\n+/* The compression table is a vector that keeps track of things we've\n+   already seen, so they can be reused. For example, java.lang.Object\n+   Would generate three entries: two package names and a type. If\n+   java.lang.String is presented next, the java.lang will be matched\n+   against the first two entries (and kept for compression as S_0), and\n+   type String would be added to the table. See mangle_record_type.\n+   COMPRESSION_NEXT is the index to the location of the next insertion\n+   of an element.  */\n+\n+static tree compression_table;\n+static int  compression_next;\n+\n+/* Find a POINTER_TYPE in the compression table. Use a special\n+   function to match pointer entries and start from the end */\n+\n+static int\n+find_compression_pointer_match (type)\n+     tree type;\n+{\n+  int i;\n+\n+  for (i = compression_next-1; i >= 0; i--)\n+    if (entry_match_pointer_p (type, i))\n+      return i;\n+  return -1;\n+}\n+\n+/* Already recorder arrays are handled like pointer as they're always\n+   associated with it.  */\n+\n+static int\n+find_compression_array_match (type)\n+     tree type;\n+{\n+  return find_compression_pointer_match (type);\n+}\n+\n+/* Match the table of type against STRING.  */\n+\n+static int\n+find_compression_array_template_match (string)\n+     tree string;\n+{\n+  int i;\n+  for (i = 0; i < compression_next; i++)\n+    if (TREE_VEC_ELT (compression_table, i) == string) \n+      return i;\n+  return -1;\n+}\n+\n+/* We go through the compression table and try to find a complete or\n+   partial match. The function returns the compression table entry\n+   that (evenutally partially) matches TYPE. *NEXT_CURRENT can be set\n+   to the rest of TYPE to be mangled. */\n+\n+static int\n+find_compression_record_match (type, next_current)\n+     tree type;\n+     tree *next_current;\n {\n-  const char *ptr;\n-  int qualifications = 0;\n+  int i, match;\n+  tree current, saved_current;\n \n-  for (ptr = class_name; *ptr != '\\0'; ptr++)\n+  /* Search from the beginning for something that matches TYPE, even\n+     partially. */\n+  for (current = TYPE_PACKAGE_LIST (type), i = 0, match = -1; current;\n+       current = TREE_CHAIN (current))\n     {\n-      if (*ptr == '.')\n-\tqualifications++;\n+      int j;\n+      for (j = i; j < compression_next; j++)\n+\tif (TREE_VEC_ELT (compression_table, j) == TREE_PURPOSE (current))\n+\t  {\n+\t    match = i = j;\n+\t    saved_current = current;\n+\t    break;\n+\t  }\n+    }\n+\n+  if (!next_current)\n+    return match;\n+\n+  /* If we have a match, set next_current to the item next to the last\n+     matched value. */\n+  if (match >= 0)\n+    *next_current = TREE_CHAIN (saved_current);\n+  /* We had no match: we'll have to start from the beginning. */\n+  if (match < 0)\n+    *next_current = TYPE_PACKAGE_LIST (type);\n+\n+  return match;\n+}\n+\n+/* Mangle a record type. If a non zero value is returned, it means\n+   that a 'N' was emitted (so that a matching 'E' can be emitted if\n+   necessary.)  */\n+\n+static int\n+mangle_record_type (type, from_pointer)\n+     tree type;\n+     int from_pointer;\n+{\n+  tree current;\n+  int match;\n+  int nadded_p = 0;\n+\n+#define ADD_N() \\\n+  do { obstack_1grow (mangle_obstack, 'N'); nadded_p = 1; } while (0)\n+\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    fatal (\"Non RECORD_TYPE argument -- mangle_record_type\");\n+\n+  if (!TYPE_PACKAGE_LIST (type))\n+    set_type_package_list (type);\n+\n+  match = find_compression_record_match (type, &current);\n+  if (match >= 0)\n+    {\n+      /* If we had a pointer, and there's more, we need to emit\n+\t 'N' after 'P' (from pointer tells us we already emitted it.) */\n+      if (from_pointer && current)\n+\tADD_N();\n+      emit_compression_string (match);\n     }\n-  if (qualifications)\n+  while (current)\n     {\n-      char buf[8];\n-      if (qualifications >= 9)\n-\tsprintf (buf, \"Q_%d_\", qualifications + 1);\n-      else\n-\tsprintf (buf, \"Q%d\", qualifications + 1);\n-      obstack_grow (obstack, buf, strlen (buf));\n+      /* Add the new type to the table */\n+      compression_table_add (TREE_PURPOSE (current));\n+      /* Add 'N' if we never got a chance to. */\n+      if (!nadded_p)\n+\tADD_N();\n+      /* Use the bare type name for the mangle. */\n+      append_gpp_mangled_name (IDENTIFIER_POINTER (TREE_VALUE (current)),\n+\t\t\t       IDENTIFIER_LENGTH (TREE_VALUE (current)));\n+      current = TREE_CHAIN (current);\n+    }\n+  return nadded_p;\n+#undef ADD_N\n+}\n+\n+/* Mangle a pointer type. There are two cases: the pointer is already\n+   in the compression table: the compression is emited sans 'P'\n+   indicator. Otherwise, a 'P' is emitted and, depending on the type,\n+   a partial compression or/plus the rest of the mangling. */\n+\n+static void\n+mangle_pointer_type (type)\n+     tree type;\n+{\n+  int match;\n+  tree pointer_type;\n+\n+  /* Search for the type already in the compression table */\n+  if ((match = find_compression_pointer_match (type)) >= 0) \n+    {\n+      emit_compression_string (match);\n+      return;\n     }\n-  for (ptr = class_name; ; ptr++)\n+  \n+  /* This didn't work. We start by mangling the pointed-to type */\n+  pointer_type = type;\n+  type = TREE_TYPE (type);\n+  if (TREE_CODE (type) != RECORD_TYPE)\n+    fatal (\"Double indirection found -- mangle_pointer_type\");\n+  \n+  obstack_1grow (mangle_obstack, 'P');\n+  if (mangle_record_type (type, /* for_pointer = */ 1))\n+    obstack_1grow (mangle_obstack, 'E');\n+\n+  /* Don't forget to insert the pointer type in the table */\n+  compression_table_add (pointer_type);\n+}\n+\n+/* Mangle an array type. Search for an easy solution first, then go\n+   through the process of finding out whether the bare array type or even\n+   the template indicator where already used an compress appropriately.\n+   It handles pointers. */\n+\n+static void\n+mangle_array_type (p_type)\n+     tree p_type;\n+{\n+  /* atms: array template mangled string. */\n+  static tree atms = NULL_TREE;\n+  tree type, elt_type;\n+  int match;\n+\n+  type = TREE_TYPE (p_type);\n+  if (!type)\n+    fatal (\"Non pointer array type -- mangle_array_type\");\n+  elt_type = TYPE_ARRAY_ELEMENT (type);\n+\n+  /* We cache a bit of the Jarray <> mangle. */\n+  if (!atms)\n+    {\n+      atms = get_identifier (\"6JArray\");\n+      ggc_add_tree_root (&atms, 1);\n+    }\n+\n+  /* Maybe we have what we're looking in the compression table. */\n+  if ((match = find_compression_array_match (p_type)) >= 0)\n+    {\n+      emit_compression_string (match);\n+      return;\n+    }\n+\n+  /* We know for a fact that all arrays are pointers */\n+  obstack_1grow (mangle_obstack, 'P');\n+  /* Maybe we already have a Jarray<t> somewhere. PSx_ will be enough. */\n+  if ((match = find_compression_record_match (type, NULL)) > 0)\n+    {\n+      emit_compression_string (match);\n+      return;\n+    }\n+\n+  /* Maybe we already have just JArray somewhere */\n+  if ((match = find_compression_array_template_match (atms)) > 0)\n+    emit_compression_string (match);\n+  else\n     {\n-      if (ptr[0] == '.' || ptr[0] == '\\0')\n+      /* Start the template mangled name */\n+      obstack_grow (mangle_obstack, \n+\t\t    IDENTIFIER_POINTER (atms), IDENTIFIER_LENGTH (atms));\n+      /* Insert in the compression table */\n+      compression_table_add (atms);\n+    } \n+\n+  /* Mangle Jarray <elt_type> */\n+  obstack_1grow (mangle_obstack, 'I');\n+  mangle_type (elt_type);\n+  obstack_1grow (mangle_obstack, 'E');\n+\n+  /* Add `Jarray <elt_type>' and `Jarray <elt_type> *' to the table */\n+  compression_table_add (type);\n+  compression_table_add (p_type);\n+}\n+\n+/* Write a substition string for entry I. Substitution string starts a\n+   -1 (encoded S_.) The base is 36, and the code shamlessly taken from\n+   cp/mangle.c.  */\n+\n+static void\n+emit_compression_string (int i)\n+{\n+  i -= 1;\t\t\t/* Adjust */\n+  obstack_1grow (mangle_obstack, 'S');\n+  if (i >= 0)\n+    {\n+      static const char digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n+      unsigned HOST_WIDE_INT n;\n+      unsigned HOST_WIDE_INT m=1;\n+      /* How many digits for I in base 36? */\n+      for (n = i; n >= 36; n /= 36, m *=36);\n+      /* Write the digits out */\n+      while (m > 0)\n \t{\n-\t  append_gpp_mangled_name (obstack, class_name, ptr - class_name);\n-\t  if (ptr[0] == '\\0')\n-\t    break;\n-\t  class_name = ptr + 1;\n+\t  int digit = i / m;\n+\t  obstack_1grow (mangle_obstack, digits [digit]);\n+\t  i -= digit * m;\n+\t  m /= 36;\n+\t}\n+    }\n+  obstack_1grow (mangle_obstack, '_');\n+}\n+\n+/* If search the compression table at index I for a pointer type\n+   equivalent to TYPE (meaning that after all the indirection, which\n+   might all be unique, we find the same RECORD_TYPE.) */\n+\n+static int\n+entry_match_pointer_p (type, i)\n+     tree type;\n+     int i;\n+{\n+  tree t = TREE_VEC_ELT (compression_table, i);\n+  \n+  while (TREE_CODE (type) == POINTER_TYPE\n+\t && TREE_CODE (t) == POINTER_TYPE)\n+    {\n+      t = TREE_TYPE (t);\n+      type = TREE_TYPE (type);\n+    }\n+  return (TREE_CODE (type) == RECORD_TYPE\n+\t  && TREE_CODE (t) == RECORD_TYPE\n+\t  && t == type);\n+}\n+\n+/* Go through all qualification of type and build a list of list node\n+   elements containings as a purpose what should be used for a match and\n+   inserted in the compression table; and as it value the raw name of the\n+   part. The result is stored in TYPE_PACKAGE_LIST to be reused.  */\n+\n+static void\n+set_type_package_list (type)\n+     tree type;\n+{\n+  int i;\n+  const char *type_string = IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (type)));\n+  char *ptr;\n+  int qualifications;\n+  tree list = NULL_TREE, elt;\n+\n+  for (ptr = (char *)type_string, qualifications = 0; *ptr; ptr++)\n+    if (*ptr == '.')\n+      qualifications += 1;\n+\n+  for (ptr = (char *)type_string, i = 0; i < qualifications; ptr++)\n+    {\n+      if (ptr [0] == '.')\n+\t{\n+\t  char c;\n+\t  tree identifier;\n+\n+\t  /* Can't use an obstack, we're already using it to\n+\t     accumulate the mangling. */\n+\t  c = ptr [0];\n+\t  ptr [0] = '\\0';\n+\t  identifier = get_identifier (type_string);\n+\t  ptr [0] = c;\n+\t  elt = build_tree_list (identifier, identifier);\n+\t  TREE_CHAIN (elt) = list;\n+\t  list = elt;\n+\t  type_string = ptr+1;\n+\t  i += 1;\n \t}\n     }\n+\n+  elt = build_tree_list (type, get_identifier (type_string));\n+  TREE_CHAIN (elt) = list;\n+  list = elt;\n+  TYPE_PACKAGE_LIST (type) = nreverse (list);\n+}\n+\n+/* Add TYPE as the last element of the compression table. Resize the\n+   compression table if necessary.  */\n+\n+static void\n+compression_table_add (type)\n+     tree type;\n+{\n+  if (compression_next == TREE_VEC_LENGTH (compression_table))\n+    {\n+      tree new = make_tree_vec (2*compression_next);\n+      int i;\n+\n+      for (i = 0; i < compression_next; i++)\n+\tTREE_VEC_ELT (new, i) = TREE_VEC_ELT (compression_table, i);\n+\n+      ggc_del_root (&compression_table);\n+      compression_table = new;\n+      ggc_add_tree_root (&compression_table, 1);\n+    }\n+  TREE_VEC_ELT (compression_table, compression_next++) = type;\n+}\n+\n+/* Mangling initialization routine.  */\n+\n+static void\n+init_mangling (obstack)\n+     struct obstack *obstack;\n+{\n+  mangle_obstack = obstack;\n+  if (!compression_table)\n+    compression_table = make_tree_vec (10);\n+  else\n+    fatal (\"Mangling already in progress -- init_mangling\");\n+\n+  /* Mangled name are to be suffixed */\n+  obstack_grow (mangle_obstack, \"_Z\", 2);\n+\n+  /* Register the compression table with the GC */\n+  ggc_add_tree_root (&compression_table, 1);\n+}\n+\n+/* Mangling finalization routine. The mangled name is returned as a\n+   IDENTIFIER_NODE.  */\n+\n+static tree\n+finish_mangling ()\n+{\n+  tree result;\n+\n+  if (!compression_table)\n+    fatal (\"Mangling already finished -- finish_mangling\");\n+\n+  ggc_del_root (&compression_table);\n+  compression_table = NULL_TREE;\n+  compression_next = 0;\n+  obstack_1grow (mangle_obstack, '\\0');\n+  result = get_identifier (obstack_base (mangle_obstack));\n+  obstack_free (mangle_obstack, obstack_base (mangle_obstack));\n+#if 0\n+  printf (\"// %s\\n\", IDENTIFIER_POINTER (result));\n+#endif\n+  return result;\n }"}, {"sha": "7d75861117746ca941cea3335ccfc6a46eb73d6a", "filename": "gcc/java/parse.y", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc08e603899b1ac1ea91a9ee641853b20521d61e/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=dc08e603899b1ac1ea91a9ee641853b20521d61e", "patch": "@@ -1,6 +1,6 @@\n /* Source code parsing and tree node generation for the GNU compiler\n    for the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by Alexandre Petit-Bianco (apbianco@cygnus.com)\n \n This file is part of GNU CC.\n@@ -2973,7 +2973,6 @@ yyerror (msg)\n \n   int save_lineno;\n   char *remainder, *code_from_source;\n-  extern struct obstack temporary_obstack;\n   \n   if (!force_error && prev_lineno == lineno)\n     return;"}]}