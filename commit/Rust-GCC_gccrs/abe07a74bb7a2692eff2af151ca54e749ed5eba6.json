{"sha": "abe07a74bb7a2692eff2af151ca54e749ed5eba6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJlMDdhNzRiYjdhMjY5MmVmZjJhZjE1MWNhNTRlNzQ5ZWQ1ZWJhNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-02-15T15:05:22Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-02-15T15:05:22Z"}, "message": "rtl-ssa: Reduce the amount of temporary memory needed [PR98863]\n\nThe rtl-ssa code uses an on-the-side IL and needs to build that IL\nfor each block and RTL insn.  I'd originally not used the classical\ndominance frontier method for placing phis on the basis that it seemed\nlike more work in this context: we're having to visit everything in\nan RPO walk anyway, so for non-backedge cases we can tell immediately\nwhether a phi node is needed.  We then speculatively created phis for\nregisters that are live across backedges and simplified them later.\nThis avoided having to walk most of the IL twice (once to build the\ninitial IL, and once to link uses to phis).\n\nHowever, as shown in PR98863, this leads to excessive temporary\nmemory in extreme cases, since we had to record the value of\nevery live register on exit from every block.  In that PR,\nthere were many registers that were live (but unused) across\na large region of code.\n\nThis patch does use the classical approach to placing phis, but tries\nto use the existing DF defs information to avoid two walks of the IL.\nWe still use the previous approach for memory, since there is no\nup-front information to indicate whether a block defines memory or not.\nHowever, since memory is just treated as a single unified thing\n(like for gimple vops), memory doesn't suffer from the same\nscalability problems as registers.\n\nWith this change, fwprop no longer seems to be a memory-hog outlier\nin the PR: the maximum RSS is similar with and without fwprop.\n\nThe PR also shows the problems inherent in using bitmap operations\ninvolving the live-in and live-out sets, which in the testcase are\nvery large.  I've therefore tried to reduce those operations to the\nbare minimum.\n\nThe patch also includes other compile-time optimisations motivated\nby the PR; see the changelog for details.\n\nI tried adding:\n\n    for (int i = 0; i < 200; ++i)\n      {\n\tcrtl->ssa = new rtl_ssa::function_info (cfun);\n\tdelete crtl->ssa;\n      }\n\nto fwprop.c to stress the code.  fwprop then took 35% of the compile\ntime for the problematic partition in the PR (measured on a release\nbuild).  fwprop takes less than .5% of the compile time when running\nnormally.\n\nThe command:\n\n  git diff 0b76990a9d75d97b84014e37519086b81824c307~ gcc/fwprop.c | \\\n    patch -p1 -R\n\nstill gives a working compiler that uses the old fwprop.c.  The compile\ntime with that version is very similar.\n\nFor a more reasonable testcase like optabs.ii at -O, I saw a 6.7%\ncompile time regression with the loop above added (i.e. creating\nthe info 201 times per pass instead of once per pass).  That goes\ndown to 4.8% with -O -g.  I can't measure a significant difference\nwith a normal compiler (no 200-iteration loop).\n\nSo I think that (as expected) the patch does make things a bit\nslower in the normal case.  But like Richi says, peak memory usage\nis harder for users to work around than slighter slower compile times.\n\ngcc/\n\tPR rtl-optimization/98863\n\t* rtl-ssa/functions.h (function_info::bb_live_out_info): Delete.\n\t(function_info::build_info): Turn into a declaration, moving the\n\tdefinition to internals.h.\n\t(function_info::bb_walker): Declare.\n\t(function_info::create_reg_use): Likewise.\n\t(function_info::calculate_potential_phi_regs): Take a build_info\n\tparameter.\n\t(function_info::place_phis, function_info::create_ebbs): Declare.\n\t(function_info::calculate_ebb_live_in_for_debug): Likewise.\n\t(function_info::populate_backedge_phis): Delete.\n\t(function_info::start_block, function_info::end_block): Declare.\n\t(function_info::populate_phi_inputs): Delete.\n\t(function_info::m_potential_phi_regs): Move information to build_info.\n\t* rtl-ssa/internals.h: New file.\n\t(function_info::bb_phi_info): New class.\n\t(function_info::build_info): Moved from functions.h.\n\tAdd a constructor and destructor.\n\t(function_info::build_info::ebb_use): Delete.\n\t(function_info::build_info::ebb_def): Likewise.\n\t(function_info::build_info::bb_live_out): Likewise.\n\t(function_info::build_info::tmp_ebb_live_in_for_debug): New variable.\n\t(function_info::build_info::potential_phi_regs): Likewise.\n\t(function_info::build_info::potential_phi_regs_for_debug): Likewise.\n\t(function_info::build_info::ebb_def_regs): Likewise.\n\t(function_info::build_info::bb_phis): Likewise.\n\t(function_info::build_info::bb_mem_live_out): Likewise.\n\t(function_info::build_info::bb_to_rpo): Likewise.\n\t(function_info::build_info::def_stack): Likewise.\n\t(function_info::build_info::old_def_stack_limit): Likewise.\n\t* rtl-ssa/internals.inl (function_info::build_info::record_reg_def):\n\tRemove the regno argument.  Push the previous definition onto the\n\tdefinition stack where necessary.\n\t* rtl-ssa/accesses.cc: Include internals.h.\n\t* rtl-ssa/changes.cc: Likewise.\n\t* rtl-ssa/blocks.cc: Likewise.\n\t(function_info::build_info::build_info): Define.\n\t(function_info::build_info::~build_info): Likewise.\n\t(function_info::bb_walker): New class.\n\t(function_info::bb_walker::bb_walker): Define.\n\t(function_info::add_live_out_use): Convert a logarithmic-complexity\n\ttest into a linear one.  Allow the same definition to be passed\n\tmultiple times.\n\t(function_info::calculate_potential_phi_regs): Moved from\n\tfunctions.cc.  Take a build_info parameter and store the\n\tinformation there instead.\n\t(function_info::place_phis): New function.\n\t(function_info::add_entry_block_defs): Update call to record_reg_def.\n\t(function_info::calculate_ebb_live_in_for_debug): New function.\n\t(function_info::add_phi_nodes): Use bb_phis to decide which\n\tregisters need phi nodes and initialize ebb_def_regs accordingly.\n\tDo not add degenerate phis here.\n\t(function_info::add_artificial_accesses): Use create_reg_use.\n\tAssert that all definitions are listed in the DF LR sets.\n\tUpdate call to record_reg_def.\n\t(function_info::record_block_live_out): Record live-out register\n\tvalues in the phis of successor blocks.  Use the live-out set\n\twhen processing the last block in an EBB, instead of always\n\tusing the live-in sets of successor blocks.  AND the live sets\n\twith the set of registers that have been defined in the EBB,\n\trather than with all potential phi registers.  Cope correctly\n\twith branches back to the start of the current EBB.\n\t(function_info::start_block): New function.\n\t(function_info::end_block): Likewise.\n\t(function_info::populate_phi_inputs): Likewise.\n\t(function_info::create_ebbs): Likewise.\n\t(function_info::process_all_blocks): Rewrite into a multi-phase\n\tprocess.\n\t* rtl-ssa/functions.cc: Include internals.h.\n\t(function_info::calculate_potential_phi_regs): Move to blocks.cc.\n\t(function_info::init_function_data): Remove caller.\n\t* rtl-ssa/insns.cc: Include internals.h\n\t(function_info::create_reg_use): New function.  Lazily any\n\tdegenerate phis needed by the linear RPO view.\n\t(function_info::record_use): Use create_reg_use.  When processing\n\tdebug uses, use potential_phi_regs and test it before checking\n\twhether the register is live on entry to the current EBB.  Lazily\n\tcalculate ebb_live_in_for_debug.\n\t(function_info::record_call_clobbers): Update call to record_reg_def.\n\t(function_info::record_def): Likewise.", "tree": {"sha": "742ecbe9bb8810e1e4cc1fa5ae8cdd06eb0b3f09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/742ecbe9bb8810e1e4cc1fa5ae8cdd06eb0b3f09"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abe07a74bb7a2692eff2af151ca54e749ed5eba6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe07a74bb7a2692eff2af151ca54e749ed5eba6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abe07a74bb7a2692eff2af151ca54e749ed5eba6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abe07a74bb7a2692eff2af151ca54e749ed5eba6/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40f235b5f00009ea35fcd8fae08566e65a864a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40f235b5f00009ea35fcd8fae08566e65a864a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40f235b5f00009ea35fcd8fae08566e65a864a46"}], "stats": {"total": 1181, "additions": 721, "deletions": 460}, "files": [{"sha": "de3a29edbeb93d924d746a874d73451b2c654219", "filename": "gcc/rtl-ssa/accesses.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Faccesses.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Faccesses.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Faccesses.cc?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -26,6 +26,7 @@\n #include \"rtl.h\"\n #include \"df.h\"\n #include \"rtl-ssa.h\"\n+#include \"rtl-ssa/internals.h\"\n #include \"rtl-ssa/internals.inl\"\n \n using namespace rtl_ssa;"}, {"sha": "3a57e95cbcf9736201b83e303d948389792a7b63", "filename": "gcc/rtl-ssa/blocks.cc", "status": "modified", "additions": 515, "deletions": 340, "changes": 855, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Fblocks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Fblocks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Fblocks.cc?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -26,13 +26,122 @@\n #include \"rtl.h\"\n #include \"df.h\"\n #include \"rtl-ssa.h\"\n+#include \"rtl-ssa/internals.h\"\n #include \"rtl-ssa/internals.inl\"\n #include \"cfganal.h\"\n #include \"cfgrtl.h\"\n #include \"predict.h\"\n+#include \"domwalk.h\"\n \n using namespace rtl_ssa;\n \n+// Prepare to build information for a function in which all register numbers\n+// are less than NUM_REGS and all basic block indices are less than\n+// NUM_BB_INDICES\n+function_info::build_info::build_info (unsigned int num_regs,\n+\t\t\t\t       unsigned int num_bb_indices)\n+  : current_bb (nullptr),\n+    current_ebb (nullptr),\n+    last_access (num_regs + 1),\n+    ebb_live_in_for_debug (nullptr),\n+    potential_phi_regs (num_regs),\n+    bb_phis (num_bb_indices),\n+    bb_mem_live_out (num_bb_indices),\n+    bb_to_rpo (num_bb_indices)\n+{\n+  last_access.safe_grow_cleared (num_regs + 1);\n+\n+  bitmap_clear (potential_phi_regs);\n+\n+  // These arrays shouldn't need to be initialized, since we'll always\n+  // write to an entry before reading from it.  But poison the contents\n+  // when checking, just to make sure we don't accidentally use an\n+  // uninitialized value.\n+  bb_phis.quick_grow (num_bb_indices);\n+  bb_mem_live_out.quick_grow (num_bb_indices);\n+  bb_to_rpo.quick_grow (num_bb_indices);\n+  if (flag_checking)\n+    {\n+      // Can't do this for bb_phis because it has a constructor.\n+      memset (bb_mem_live_out.address (), 0xaf,\n+\t      num_bb_indices * sizeof (bb_mem_live_out[0]));\n+      memset (bb_to_rpo.address (), 0xaf,\n+\t      num_bb_indices * sizeof (bb_to_rpo[0]));\n+    }\n+\n+  // Start off with an empty set of phi nodes for each block.\n+  for (bb_phi_info &info : bb_phis)\n+    bitmap_initialize (&info.regs, &bitmap_default_obstack);\n+}\n+\n+function_info::build_info::~build_info ()\n+{\n+  for (bb_phi_info &info : bb_phis)\n+    bitmap_release (&info.regs);\n+}\n+\n+// A dom_walker for populating the basic blocks.\n+class function_info::bb_walker : public dom_walker\n+{\n+public:\n+  bb_walker (function_info *, build_info &);\n+  virtual edge before_dom_children (basic_block);\n+  virtual void after_dom_children (basic_block);\n+\n+private:\n+  // Information about the function we're building.\n+  function_info *m_function;\n+  build_info &m_bi;\n+\n+  // We should treat the exit block as being the last child of this one.\n+  // See the comment in the constructor for more information.\n+  basic_block m_exit_block_dominator;\n+};\n+\n+// Prepare to walk the blocks in FUNCTION using BI.\n+function_info::bb_walker::bb_walker (function_info *function, build_info &bi)\n+  : dom_walker (CDI_DOMINATORS, ALL_BLOCKS, bi.bb_to_rpo.address ()),\n+    m_function (function),\n+    m_bi (bi),\n+    m_exit_block_dominator (nullptr)\n+{\n+  // ??? There is no dominance information associated with the exit block,\n+  // so work out its immediate dominator using predecessor blocks.  We then\n+  // walk the exit block just before popping its immediate dominator.\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, EXIT_BLOCK_PTR_FOR_FN (m_function->m_fn)->preds)\n+    if (m_exit_block_dominator)\n+      m_exit_block_dominator\n+\t= nearest_common_dominator (CDI_DOMINATORS,\n+\t\t\t\t    m_exit_block_dominator, e->src);\n+    else\n+      m_exit_block_dominator = e->src;\n+\n+  // If the exit block is unreachable, process it last.\n+  if (!m_exit_block_dominator)\n+    m_exit_block_dominator = ENTRY_BLOCK_PTR_FOR_FN (m_function->m_fn);\n+}\n+\n+edge\n+function_info::bb_walker::before_dom_children (basic_block bb)\n+{\n+  m_function->start_block (m_bi, m_function->bb (bb));\n+  return nullptr;\n+}\n+\n+void\n+function_info::bb_walker::after_dom_children (basic_block bb)\n+{\n+  // See the comment in the constructor for details.\n+  if (bb == m_exit_block_dominator)\n+    {\n+      before_dom_children (EXIT_BLOCK_PTR_FOR_FN (m_function->m_fn));\n+      after_dom_children (EXIT_BLOCK_PTR_FOR_FN (m_function->m_fn));\n+    }\n+  m_function->end_block (m_bi, m_function->bb (bb));\n+}\n+\n // See the comment above the declaration.\n void\n bb_info::print_identifier (pretty_printer *pp) const\n@@ -217,15 +326,15 @@ function_info::add_live_out_use (bb_info *bb, set_info *def)\n \n   // If the end of the block already has an artificial use, that use\n   // acts to make DEF live at the appropriate point.\n-  unsigned int regno = def->regno ();\n-  if (find_access (bb->end_insn ()->uses (), regno))\n+  use_info *use = def->last_nondebug_insn_use ();\n+  if (use && use->insn () == bb->end_insn ())\n     return;\n \n   // Currently there is no need to maintain a backward link from the end\n   // instruction to the list of live-out uses.  Such a list would be\n   // expensive to update if it was represented using the usual insn_info\n   // access arrays.\n-  use_info *use = allocate<use_info> (bb->end_insn (), def->resource (), def);\n+  use = allocate<use_info> (bb->end_insn (), def->resource (), def);\n   use->set_is_live_out_use (true);\n   add_use (use);\n }\n@@ -474,6 +583,124 @@ function_info::append_bb (bb_info *bb)\n   m_last_bb = bb;\n }\n \n+// Calculate BI.potential_phi_regs and BI.potential_phi_regs_for_debug.\n+void\n+function_info::calculate_potential_phi_regs (build_info &bi)\n+{\n+  auto *lr_info = DF_LR_BB_INFO (ENTRY_BLOCK_PTR_FOR_FN (m_fn));\n+  bool is_debug = MAY_HAVE_DEBUG_INSNS;\n+  for (unsigned int regno = 0; regno < m_num_regs; ++regno)\n+    if (regno >= DF_REG_SIZE (DF)\n+\t// Exclude registers that have a single definition that dominates\n+\t// all uses.  If the definition does not dominate all uses,\n+\t// the register will be exposed upwards to the entry block but\n+\t// will not be defined by the entry block.\n+\t|| DF_REG_DEF_COUNT (regno) > 1\n+\t|| (!bitmap_bit_p (&lr_info->def, regno)\n+\t    && bitmap_bit_p (&lr_info->out, regno)))\n+      {\n+\tbitmap_set_bit (bi.potential_phi_regs, regno);\n+\tif (is_debug)\n+\t  bitmap_set_bit (bi.potential_phi_regs_for_debug, regno);\n+      }\n+}\n+\n+// Called while building SSA form using BI.  Decide where phi nodes\n+// should be placed for each register and initialize BI.bb_phis accordingly.\n+void\n+function_info::place_phis (build_info &bi)\n+{\n+  unsigned int num_bb_indices = last_basic_block_for_fn (m_fn);\n+\n+  // Calculate dominance frontiers.\n+  auto_vec<bitmap_head> frontiers;\n+  frontiers.safe_grow (num_bb_indices);\n+  for (unsigned int i = 0; i < num_bb_indices; ++i)\n+    bitmap_initialize (&frontiers[i], &bitmap_default_obstack);\n+  compute_dominance_frontiers (frontiers.address ());\n+\n+  // In extreme cases, the number of live-in registers can be much\n+  // greater than the number of phi nodes needed in a block (see PR98863).\n+  // Try to reduce the number of operations involving live-in sets by using\n+  // PENDING as a staging area: registers in PENDING need phi nodes if\n+  // they are live on entry to the corresponding block, but do not need\n+  // phi nodes otherwise.\n+  auto_vec<bitmap_head> unfiltered;\n+  unfiltered.safe_grow (num_bb_indices);\n+  for (unsigned int i = 0; i < num_bb_indices; ++i)\n+    bitmap_initialize (&unfiltered[i], &bitmap_default_obstack);\n+\n+  // If block B1 defines R and if B2 is in the dominance frontier of B1,\n+  // queue a possible phi node for R in B2.\n+  auto_bitmap worklist;\n+  for (unsigned int b1 = 0; b1 < num_bb_indices; ++b1)\n+    {\n+      // Only access DF information for blocks that are known to exist.\n+      if (bitmap_empty_p (&frontiers[b1]))\n+\tcontinue;\n+\n+      bitmap b1_def = &DF_LR_BB_INFO (BASIC_BLOCK_FOR_FN (m_fn, b1))->def;\n+      bitmap_iterator bmi;\n+      unsigned int b2;\n+      EXECUTE_IF_SET_IN_BITMAP (&frontiers[b1], 0, b2, bmi)\n+\tif (bitmap_ior_into (&unfiltered[b2], b1_def)\n+\t    && !bitmap_empty_p (&frontiers[b2]))\n+\t  // Propagate the (potential) new phi node definitions in B2.\n+\t  bitmap_set_bit (worklist, b2);\n+    }\n+\n+  while (!bitmap_empty_p (worklist))\n+    {\n+      unsigned int b1 = bitmap_first_set_bit (worklist);\n+      bitmap_clear_bit (worklist, b1);\n+\n+      // Restrict the phi nodes to registers that are live on entry to\n+      // the block.\n+      bitmap b1_in = DF_LR_IN (BASIC_BLOCK_FOR_FN (m_fn, b1));\n+      bitmap b1_phis = &bi.bb_phis[b1].regs;\n+      if (!bitmap_ior_and_into (b1_phis, &unfiltered[b1], b1_in))\n+\tcontinue;\n+\n+      // If block B1 has a phi node for R and if B2 is in the dominance\n+      // frontier of B1, queue a possible phi node for R in B2.\n+      bitmap_iterator bmi;\n+      unsigned int b2;\n+      EXECUTE_IF_SET_IN_BITMAP (&frontiers[b1], 0, b2, bmi)\n+\tif (bitmap_ior_into (&unfiltered[b2], b1_phis)\n+\t    && !bitmap_empty_p (&frontiers[b2]))\n+\t  bitmap_set_bit (worklist, b2);\n+    }\n+\n+  basic_block cfg_bb;\n+  FOR_ALL_BB_FN (cfg_bb, m_fn)\n+    {\n+      // Calculate the set of phi nodes for blocks that don't have any\n+      // dominance frontiers.  We only need to do this once per block.\n+      unsigned int i = cfg_bb->index;\n+      bb_phi_info &phis = bi.bb_phis[i];\n+      if (bitmap_empty_p (&frontiers[i]))\n+\tbitmap_and (&phis.regs, &unfiltered[i], DF_LR_IN (cfg_bb));\n+\n+      // Create an array that contains all phi inputs for this block.\n+      // See the comment above the member variables for more information.\n+      phis.num_phis = bitmap_count_bits (&phis.regs);\n+      phis.num_preds = EDGE_COUNT (cfg_bb->preds);\n+      unsigned int num_inputs = phis.num_phis * phis.num_preds;\n+      if (num_inputs != 0)\n+\t{\n+\t  phis.inputs = XOBNEWVEC (&m_temp_obstack, set_info *, num_inputs);\n+\t  memset (phis.inputs, 0, num_inputs * sizeof (phis.inputs[0]));\n+\t}\n+    }\n+\n+  // Free the temporary bitmaps.\n+  for (unsigned int i = 0; i < num_bb_indices; ++i)\n+    {\n+      bitmap_release (&frontiers[i]);\n+      bitmap_release (&unfiltered[i]);\n+    }\n+}\n+\n // Called while building SSA form using BI, with BI.current_bb being\n // the entry block.\n //\n@@ -508,7 +735,7 @@ function_info::add_entry_block_defs (build_info &bi)\n       auto *set = allocate<set_info> (insn, full_register (regno));\n       append_def (set);\n       m_temp_defs.safe_push (set);\n-      bi.record_reg_def (regno, set);\n+      bi.record_reg_def (set);\n     }\n \n   // Create a definition that reflects the state of memory on entry to\n@@ -521,191 +748,86 @@ function_info::add_entry_block_defs (build_info &bi)\n   finish_insn_accesses (insn);\n }\n \n+// Lazily calculate the value of BI.ebb_live_in_for_debug for BI.current_ebb.\n+void\n+function_info::calculate_ebb_live_in_for_debug (build_info &bi)\n+{\n+  gcc_checking_assert (bitmap_empty_p (bi.tmp_ebb_live_in_for_debug));\n+  bi.ebb_live_in_for_debug = bi.tmp_ebb_live_in_for_debug;\n+  bitmap_and (bi.ebb_live_in_for_debug, bi.potential_phi_regs_for_debug,\n+\t      DF_LR_IN (bi.current_ebb->first_bb ()->cfg_bb ()));\n+  bitmap_tree_view (bi.ebb_live_in_for_debug);\n+}\n+\n // Called while building SSA form using BI.  Create phi nodes for the\n-// current EBB, leaving backedge inputs to be filled in later.  Set\n-// bi.last_access to the values that are live on entry to the EBB,\n-// regardless of whether or not they are phi nodes.\n+// current EBB.\n void\n function_info::add_phi_nodes (build_info &bi)\n {\n   ebb_info *ebb = bi.current_ebb;\n   basic_block cfg_bb = ebb->first_bb ()->cfg_bb ();\n-  auto *lr_info = DF_LR_BB_INFO (cfg_bb);\n \n-  // Get a local cache of the predecessor blocks' live out values.\n-  unsigned int num_preds = EDGE_COUNT (cfg_bb->preds);\n-  auto_vec<const bb_live_out_info *, 16> pred_live_outs (num_preds);\n-  bool has_backedge = false;\n-  bool has_eh_edge = false;\n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n+  // Create the register phis for this EBB.\n+  bb_phi_info &phis = bi.bb_phis[cfg_bb->index];\n+  unsigned int num_preds = phis.num_preds;\n+  unsigned int regno;\n+  bitmap_iterator in_bi;\n+  EXECUTE_IF_SET_IN_BITMAP (&phis.regs, 0, regno, in_bi)\n     {\n-      bb_info *pred_bb = this->bb (e->src);\n-      const bb_live_out_info *live_out = &bi.bb_live_out[e->src->index];\n-\n-      // In LR (but not LIVE), the registers live on entry to a block must\n-      // normally be a subset of the registers live on exit from any\n-      // given predecessor block.  The exceptions are EH edges, which\n-      // implicitly clobber all registers in eh_edge_abi.full_reg_clobbers ().\n-      // Thus if a register is upwards exposed in an EH handler, it won't\n-      // be propagated across the EH edge.\n-      //\n-      // Excluding that special case, all registers live on entry to\n-      // EBB are also live on exit from PRED_BB and were (or will be)\n-      // considered when creating LIVE_OUT.\n-      gcc_checking_assert ((e->flags & EDGE_EH)\n-\t\t\t   || !bitmap_intersect_compl_p (&lr_info->in,\n-\t\t\t\t\t\t\t DF_LR_OUT (e->src)));\n-      if (!pred_bb || !pred_bb->head_insn ())\n-\t{\n-\t  has_backedge = true;\n-\t  live_out = nullptr;\n-\t}\n-      has_eh_edge |= (e->flags & EDGE_EH);\n-      pred_live_outs.quick_push (live_out);\n-    }\n-\n-  // PRED_REG_INDICES[I] tracks the index into PRED_LIVE_OUTS[I]->reg_values\n-  // of the first unused entry.\n-  auto_vec<unsigned int, 16> pred_reg_indices (num_preds);\n-  pred_reg_indices.quick_grow_cleared (num_preds);\n-\n-  // Use this array to build up the list of inputs to each phi.\n-  m_temp_defs.safe_grow (num_preds);\n+      gcc_checking_assert (bitmap_bit_p (bi.potential_phi_regs, regno));\n \n-  // Return true if the current phi is degenerate, i.e. if all its inputs\n-  // are the same.\n-  auto is_degenerate_phi = [&]()\n-    {\n-      if (has_backedge)\n-\treturn false;\n+      // Create an array of phi inputs, to be filled in later.\n+      auto *inputs = XOBNEWVEC (&m_obstack, access_info *, num_preds);\n+      memset (inputs, 0, sizeof (access_info *) * num_preds);\n \n-      for (unsigned int i = 1; i < num_preds; ++i)\n-\tif (m_temp_defs[i] != m_temp_defs[0])\n-\t  return false;\n+      // Later code works out the correct mode of the phi.  Use BLKmode\n+      // as a placeholder for now.\n+      phi_info *phi = create_phi (ebb, { E_BLKmode, regno },\n+\t\t\t\t  inputs, num_preds);\n+      bi.record_reg_def (phi);\n+    }\n \n-      return true;\n-    };\n+  bitmap_copy (bi.ebb_def_regs, &phis.regs);\n \n-  // Finish calculating the live-in value for RESOURCE.  Decide how to\n-  // represent the value of RESOURCE on entry to EBB and return its definition.\n-  auto finish_phi = [&](resource_info resource) -> set_info *\n+  // Collect the live-in memory definitions and record whether they're\n+  // all the same.\n+  m_temp_defs.reserve (num_preds);\n+  set_info *mem_value = nullptr;\n+  bool mem_phi_is_degenerate = true;\n+  edge e;\n+  edge_iterator ei;\n+  FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n     {\n-      access_info **inputs;\n-      unsigned int num_inputs;\n-      if (is_degenerate_phi ())\n+      bb_info *pred_bb = this->bb (e->src);\n+      if (pred_bb && pred_bb->head_insn ())\n \t{\n-\t  auto *input = safe_as_a<set_info *> (m_temp_defs[0]);\n-\t  if (!input)\n-\t    // The live-in value is completely uninitialized.\n-\t    return nullptr;\n-\n-\t  unsigned int regno = input->regno ();\n-\t  if (input->is_reg () && !bitmap_bit_p (bi.ebb_use, regno))\n-\t    // The live-in value comes from a single source and there\n-\t    // are no uses of it within the EBB itself.  We therefore\n-\t    // don't need a phi node.\n-\t    return input;\n-\n-\t  // The live-in value comes from a single source and might be\n-\t  // used by the EBB itself.  Create a degenerate phi for it.\n-\t  inputs = m_temp_defs.begin ();\n-\t  num_inputs = 1;\n+\t  mem_value = bi.bb_mem_live_out[pred_bb->index ()];\n+\t  m_temp_defs.quick_push (mem_value);\n+\t  if (mem_value != m_temp_defs[0])\n+\t    mem_phi_is_degenerate = false;\n \t}\n       else\n \t{\n-\t  obstack_grow (&m_obstack, m_temp_defs.address (),\n-\t\t\tnum_preds * sizeof (access_info *));\n-\t  inputs = static_cast<access_info **> (obstack_finish (&m_obstack));\n-\t  num_inputs = num_preds;\n+\t  m_temp_defs.quick_push (nullptr);\n+\t  mem_phi_is_degenerate = false;\n \t}\n-      return create_phi (ebb, resource, inputs, num_inputs);\n-    };\n-\n-  if (bi.ebb_live_in_for_debug)\n-    bitmap_clear (bi.ebb_live_in_for_debug);\n+    }\n \n-  // Get the definition of each live input register, excluding registers\n-  // that are known to have a single definition that dominates all uses.\n-  unsigned int regno;\n-  bitmap_iterator in_bi;\n-  EXECUTE_IF_AND_IN_BITMAP (&lr_info->in, m_potential_phi_regs,\n-\t\t\t    0, regno, in_bi)\n+  // Create a phi for memory, on the assumption that something in the\n+  // EBB will need it.\n+  if (mem_phi_is_degenerate)\n     {\n-      for (unsigned int pred_i = 0; pred_i < num_preds; ++pred_i)\n-\t{\n-\t  set_info *input = nullptr;\n-\t  if (const bb_live_out_info *pred_live_out = pred_live_outs[pred_i])\n-\t    {\n-\t      // Skip over registers that aren't live on entry to this block.\n-\t      unsigned int reg_i = pred_reg_indices[pred_i];\n-\t      while (reg_i < pred_live_out->num_reg_values\n-\t\t     && pred_live_out->reg_values[reg_i]->regno () < regno)\n-\t\treg_i += 1;\n-\n-\t      // As we asserted above, REGNO is live out from the predecessor\n-\t      // block, at least by the LR reckoning.  But there are three\n-\t      // cases:\n-\t      //\n-\t      // (1) The live-out value is well-defined (the normal case),\n-\t      //     with the definition coming either from the block itself\n-\t      //     or from a predecessor block.  In this case reg_values\n-\t      //     has a set_info entry for the register.\n-\t      //\n-\t      // (2) The live-out value was not modified by the predecessor\n-\t      //     EBB and did not have a defined value on input to that\n-\t      //     EBB either.  In this case reg_values has no entry for\n-\t      //     the register.\n-\t      //\n-\t      // (3) The live-out value was modified by the predecessor EBB,\n-\t      //     but the final modification was a clobber rather than\n-\t      //     a set.  In this case reg_values again has no entry for\n-\t      //     the register.\n-\t      //\n-\t      // The phi input for (2) and (3) is undefined, which we\n-\t      // represent as a null set_info.\n-\t      if (reg_i < pred_live_out->num_reg_values)\n-\t\t{\n-\t\t  set_info *set = pred_live_out->reg_values[reg_i];\n-\t\t  if (set->regno () == regno)\n-\t\t    {\n-\t\t      input = set;\n-\t\t      reg_i += 1;\n-\t\t    }\n-\t\t}\n-\n-\t      // Fully call-clobbered values do not survive across EH edges.\n-\t      // In particular, if a call that normally sets a result register\n-\t      // throws an exception, the set of the result register should\n-\t      // not be treated as live on entry to the EH handler.\n-\t      if (has_eh_edge\n-\t\t  && HARD_REGISTER_NUM_P (regno)\n-\t\t  && eh_edge_abi.clobbers_full_reg_p (regno)\n-\t\t  && (EDGE_PRED (cfg_bb, pred_i)->flags & EDGE_EH))\n-\t\tinput = nullptr;\n-\n-\t      pred_reg_indices[pred_i] = reg_i;\n-\t    }\n-\t  m_temp_defs[pred_i] = input;\n-\t}\n-      // Later code works out the correct mode of the phi.  Use BLKmode\n-      // as a placeholder for now.\n-      bi.record_reg_def (regno, finish_phi ({ E_BLKmode, regno }));\n-      if (bi.ebb_live_in_for_debug)\n-\tbitmap_set_bit (bi.ebb_live_in_for_debug, regno);\n+      access_info *input[] = { mem_value };\n+      mem_value = create_phi (ebb, memory, input, 1);\n     }\n-\n-  // Repeat the process above for memory.\n-  for (unsigned int pred_i = 0; pred_i < num_preds; ++pred_i)\n+  else\n     {\n-      set_info *input = nullptr;\n-      if (const bb_live_out_info *pred_live_out = pred_live_outs[pred_i])\n-\tinput = pred_live_out->mem_value;\n-      m_temp_defs[pred_i] = input;\n+      obstack_grow (&m_obstack, m_temp_defs.address (),\n+\t\t    num_preds * sizeof (access_info *));\n+      auto *inputs = static_cast<access_info **> (obstack_finish (&m_obstack));\n+      mem_value = create_phi (ebb, memory, inputs, num_preds);\n     }\n-  bi.record_mem_def (finish_phi (memory));\n-\n+  bi.record_mem_def (mem_value);\n   m_temp_defs.truncate (0);\n }\n \n@@ -744,16 +866,12 @@ function_info::add_artificial_accesses (build_info &bi, df_ref_flags flags)\n       {\n \tunsigned int regno = DF_REF_REGNO (ref);\n \tmachine_mode mode = GET_MODE (DF_REF_REAL_REG (ref));\n-\tresource_info resource { mode, regno };\n \n \t// A definition must be available.\n \tgcc_checking_assert (bitmap_bit_p (&lr_info->in, regno)\n \t\t\t     || (flags != DF_REF_AT_TOP\n \t\t\t\t && bitmap_bit_p (&lr_info->def, regno)));\n-\tset_info *def = bi.current_reg_value (regno);\n-\tauto *use = allocate<use_info> (insn, resource, def);\n-\tadd_use (use);\n-\tm_temp_uses.safe_push (use);\n+\tm_temp_uses.safe_push (create_reg_use (bi, insn, { mode, regno }));\n       }\n \n   // Track the return value of memory by adding an artificial use of\n@@ -772,14 +890,17 @@ function_info::add_artificial_accesses (build_info &bi, df_ref_flags flags)\n \tmachine_mode mode = GET_MODE (DF_REF_REAL_REG (ref));\n \tresource_info resource { mode, regno };\n \n+\t// We rely on the def set being correct.\n+\tgcc_checking_assert (bitmap_bit_p (&lr_info->def, regno));\n+\n \t// If the value isn't used later in the block and isn't live\n \t// on exit, we could instead represent the definition as a\n \t// clobber_info.  However, that case should be relatively\n \t// rare and set_info is any case more compact than clobber_info.\n \tset_info *def = allocate<set_info> (insn, resource);\n \tappend_def (def);\n \tm_temp_defs.safe_push (def);\n-\tbi.record_reg_def (regno, def);\n+\tbi.record_reg_def (def);\n       }\n \n   // Model the effect of a memory clobber on an incoming edge by adding\n@@ -808,103 +929,215 @@ function_info::add_block_contents (build_info &bi)\n       add_insn_to_block (bi, insn);\n }\n \n-// Called while building SSA form using BI.  Use BI.bb_live_out to record\n-// the values that are live out from BI.current_bb.\n+// Called while building SSA form using BI.  Record live-out register values\n+// in the phi inputs of successor blocks and create live-out uses where\n+// appropriate.  Record the live-out memory value in BI.bb_mem_live_out.\n void\n function_info::record_block_live_out (build_info &bi)\n {\n   bb_info *bb = bi.current_bb;\n   ebb_info *ebb = bi.current_ebb;\n   basic_block cfg_bb = bb->cfg_bb ();\n-  bb_live_out_info *live_out = &bi.bb_live_out[bb->index ()];\n-  auto *lr_info = DF_LR_BB_INFO (bb->cfg_bb ());\n \n-  // Calculate which subset of m_potential_phi_regs is live out from EBB\n-  // at the end of BB.\n-  auto_bitmap live_out_from_ebb;\n+  // Record the live-out register values in the phi inputs of\n+  // successor blocks.\n   edge e;\n   edge_iterator ei;\n   FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n     {\n-      bb_info *dest_bb = this->bb (e->dest);\n-      if (!dest_bb || dest_bb->ebb () != ebb)\n-\tbitmap_ior_and_into (live_out_from_ebb, DF_LR_IN (e->dest),\n-\t\t\t     m_potential_phi_regs);\n+      bb_phi_info &phis = bi.bb_phis[e->dest->index];\n+      unsigned int input_i = e->dest_idx * phis.num_phis;\n+      unsigned int regno;\n+      bitmap_iterator out_bi;\n+      EXECUTE_IF_SET_IN_BITMAP (&phis.regs, 0, regno, out_bi)\n+\t{\n+\t  phis.inputs[input_i]\n+\t    = live_out_value (bb, bi.current_reg_value (regno));\n+\t  input_i += 1;\n+\t}\n     }\n \n-  // Record the live-out register values.\n-  unsigned int regno;\n-  bitmap_iterator out_bi;\n-  EXECUTE_IF_AND_IN_BITMAP (&lr_info->out, m_potential_phi_regs,\n-\t\t\t    0, regno, out_bi)\n-    if (set_info *value = live_out_value (bb, bi.current_reg_value (regno)))\n+  // Add the set of registers that were defined in this BB to the set\n+  // of potentially-live registers defined in the EBB.\n+  bitmap_ior_into (bi.ebb_def_regs, &DF_LR_BB_INFO (cfg_bb)->def);\n+\n+  // Iterate through the registers in LIVE_OUT and see whether we need\n+  // to add a live-out use for them.\n+  auto record_live_out_regs = [&](bitmap live_out)\n+    {\n+      unsigned int regno;\n+      bitmap_iterator out_bi;\n+      EXECUTE_IF_AND_IN_BITMAP (bi.ebb_def_regs, live_out, 0, regno, out_bi)\n+\t{\n+\t  set_info *value = live_out_value (bb, bi.current_reg_value (regno));\n+\t  if (value && value->ebb () == ebb)\n+\t    add_live_out_use (bb, value);\n+\t}\n+    };\n+\n+  if (bb == ebb->last_bb ())\n+    // All live-out registers might need live-out uses.\n+    record_live_out_regs (DF_LR_OUT (cfg_bb));\n+  else\n+    // Registers might need live-out uses if they are live on entry\n+    // to a successor block in a different EBB.\n+    FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n       {\n-\tif (value->ebb () == ebb && bitmap_bit_p (live_out_from_ebb, regno))\n-\t  add_live_out_use (bb, value);\n-\tobstack_ptr_grow (&m_temp_obstack, value);\n+\tbb_info *dest_bb = this->bb (e->dest);\n+\tif (dest_bb->ebb () != ebb || dest_bb == ebb->first_bb ())\n+\t  record_live_out_regs (DF_LR_IN (e->dest));\n       }\n \n-  live_out->num_reg_values = (obstack_object_size (&m_temp_obstack)\n-\t\t\t      / sizeof (set_info *));\n-  auto *data = obstack_finish (&m_temp_obstack);\n-  live_out->reg_values = static_cast<set_info **> (data);\n+  // Record the live-out memory value.\n+  bi.bb_mem_live_out[cfg_bb->index]\n+    = live_out_value (bb, bi.current_mem_value ());\n+}\n+\n+// Add BB and its contents to the SSA information.\n+void\n+function_info::start_block (build_info &bi, bb_info *bb)\n+{\n+  ebb_info *ebb = bb->ebb ();\n+\n+  // We (need to) add all blocks from one EBB before moving on to the next.\n+  bi.current_bb = bb;\n+  if (bb == ebb->first_bb ())\n+    bi.current_ebb = ebb;\n+  else\n+    gcc_assert (bi.current_ebb == ebb);\n \n-  live_out->mem_value = live_out_value (bb, bi.current_mem_value ());\n+  // Record the start of this block's definitions in the definitions stack.\n+  bi.old_def_stack_limit.safe_push (bi.def_stack.length ());\n+\n+  // Add the block itself.\n+  append_bb (bb);\n+\n+  // If the block starts an EBB, create the phi insn.  This insn should exist\n+  // for all EBBs, even if they don't (yet) need phis.\n+  if (bb == ebb->first_bb ())\n+    ebb->set_phi_insn (append_artificial_insn (bb));\n+\n+  if (bb->index () == ENTRY_BLOCK)\n+    {\n+      add_entry_block_defs (bi);\n+      record_block_live_out (bi);\n+      return;\n+    }\n+\n+  if (EDGE_COUNT (bb->cfg_bb ()->preds) == 0)\n+    {\n+      // Leave unreachable blocks empty, since there is no useful\n+      // liveness information for them, and anything they do will\n+      // be wasted work.  In a cleaned-up cfg, the only unreachable\n+      // block we should see is the exit block of a noreturn function.\n+      bb->set_head_insn (append_artificial_insn (bb));\n+      bb->set_end_insn (append_artificial_insn (bb));\n+      return;\n+    }\n+\n+  // If the block starts an EBB, create the phi nodes.\n+  if (bb == ebb->first_bb ())\n+    add_phi_nodes (bi);\n+\n+  // Process the contents of the block.\n+  add_artificial_accesses (bi, DF_REF_AT_TOP);\n+  if (bb->index () != EXIT_BLOCK)\n+    add_block_contents (bi);\n+  add_artificial_accesses (bi, df_ref_flags ());\n+  record_block_live_out (bi);\n+\n+  // If we needed to calculate a live-in set for debug purposes,\n+  // reset it to null at the end of the EBB.  Convert the underlying\n+  // bitmap to an empty list view, ready for the next calculation.\n+  if (bi.ebb_live_in_for_debug && bb == ebb->last_bb ())\n+    {\n+      bitmap_clear (bi.tmp_ebb_live_in_for_debug);\n+      bitmap_list_view (bi.tmp_ebb_live_in_for_debug);\n+      bi.ebb_live_in_for_debug = nullptr;\n+    }\n }\n \n-// Called while building SSA form using BI.  Check if BI.current_bb has\n-// any outgoing backedges.  If so, use the up-to-date contents of\n-// BI.bb_live_out to populate the associated inputs of any phi nodes.\n+// Finish adding BB and the blocks that it dominates to the SSA information.\n void\n-function_info::populate_backedge_phis (build_info &bi)\n+function_info::end_block (build_info &bi, bb_info *bb)\n {\n-  bb_info *bb = bi.current_bb;\n-  basic_block cfg_bb = bb->cfg_bb ();\n-  const bb_live_out_info *live_out = &bi.bb_live_out[bb->index ()];\n+  // Restore the register last_access information to the state it was\n+  // in before we started processing BB.\n+  unsigned int old_limit = bi.old_def_stack_limit.pop ();\n+  while (bi.def_stack.length () > old_limit)\n+    {\n+      // We pushed a definition in BB if it was the first dominating\n+      // definition (and so the previous entry was null).  In other\n+      // cases we pushed the previous dominating definition.\n+      def_info *def = bi.def_stack.pop ();\n+      unsigned int regno = def->regno ();\n+      if (def->bb () == bb)\n+\tdef = nullptr;\n+      bi.last_access[regno + 1] = def;\n+    }\n+}\n \n-  edge e;\n-  edge_iterator ei;\n-  FOR_EACH_EDGE (e, ei, cfg_bb->succs)\n+// Finish setting up the phi nodes for each block, now that we've added\n+// the contents of all blocks.\n+void\n+function_info::populate_phi_inputs (build_info &bi)\n+{\n+  auto_vec<phi_info *, 32> sorted_phis;\n+  for (ebb_info *ebb : ebbs ())\n     {\n-      // Check if this edge counts as a backedge in the current traversal.\n-      bb_info *succ_bb = this->bb (e->dest);\n-      if (!succ_bb || !succ_bb->head_insn ())\n+      if (!ebb->first_phi ())\n \tcontinue;\n \n-      // Although the phis do not keep a defined order long-term, they are\n-      // still in reverse regno order at this point.  We can therefore use\n-      // a merge operation on the phis and the live-out values.\n-      unsigned int input_i = e->dest_idx;\n-      int reg_i = live_out->num_reg_values - 1;\n-      for (phi_info *phi : succ_bb->ebb ()->phis ())\n+      // Get a sorted array of EBB's phi nodes.\n+      basic_block cfg_bb = ebb->first_bb ()->cfg_bb ();\n+      bb_phi_info &phis = bi.bb_phis[cfg_bb->index];\n+      sorted_phis.truncate (0);\n+      for (phi_info *phi : ebb->phis ())\n+\tsorted_phis.safe_push (phi);\n+      std::sort (sorted_phis.address (),\n+\t\t sorted_phis.address () + sorted_phis.length (),\n+\t\t compare_access_infos);\n+\n+      // Set the inputs of the non-degenerate register phis.  All inputs\n+      // for one edge come before all inputs for the next edge.\n+      set_info **inputs = phis.inputs;\n+      unsigned int phi_i = 0;\n+      bitmap_iterator bmi;\n+      unsigned int regno;\n+      EXECUTE_IF_SET_IN_BITMAP (&phis.regs, 0, regno, bmi)\n \t{\n-\t  set_info *input = nullptr;\n-\t  if (phi->is_mem ())\n-\t    input = live_out->mem_value;\n-\t  else\n+\t  // Skip intervening degenerate phis.\n+\t  while (sorted_phis[phi_i]->regno () < regno)\n+\t    phi_i += 1;\n+\t  phi_info *phi = sorted_phis[phi_i];\n+\t  gcc_assert (phi->regno () == regno);\n+\t  for (unsigned int input_i = 0; input_i < phis.num_preds; ++input_i)\n+\t    if (set_info *input = inputs[input_i * phis.num_phis])\n+\t      {\n+\t\tuse_info *use = phi->input_use (input_i);\n+\t\tgcc_assert (!use->def ());\n+\t\tuse->set_def (input);\n+\t\tadd_use (use);\n+\t      }\n+\t  phi_i += 1;\n+\t  inputs += 1;\n+\t}\n+\n+      // Fill in the backedge inputs to any memory phi.\n+      phi_info *mem_phi = sorted_phis.last ();\n+      if (mem_phi->is_mem () && !mem_phi->is_degenerate ())\n+\t{\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, cfg_bb->preds)\n \t    {\n-\t      // Skip over any intervening live-out values.\n-\t      unsigned int regno = phi->regno ();\n-\t      while (reg_i >= 0)\n+\t      use_info *use = mem_phi->input_use (e->dest_idx);\n+\t      if (!use->def ())\n \t\t{\n-\t\t  set_info *reg_value = live_out->reg_values[reg_i];\n-\t\t  if (reg_value->regno () < regno)\n-\t\t    break;\n-\t\t  reg_i -= 1;\n-\t\t  if (reg_value->regno () == regno)\n-\t\t    {\n-\t\t      input = reg_value;\n-\t\t      break;\n-\t\t    }\n+\t\t  use->set_def (bi.bb_mem_live_out[e->src->index]);\n+\t\t  add_use (use);\n \t\t}\n \t    }\n-\t  if (input)\n-\t    {\n-\t      use_info *use = phi->input_use (input_i);\n-\t      gcc_assert (!use->def ());\n-\t      use->set_def (input);\n-\t      add_use (use);\n-\t    }\n \t}\n     }\n }\n@@ -960,134 +1193,76 @@ choose_next_block_in_ebb (basic_block bb)\n   return best_edge ? best_edge->dest : nullptr;\n }\n \n-// Partition the function's blocks into EBBs and build SSA form for all\n-// EBBs in the function.\n+// Partition the function into extended basic blocks.  Create the\n+// associated ebb_infos and bb_infos, but don't add the bb_infos\n+// to the function list yet.\n void\n-function_info::process_all_blocks ()\n+function_info::create_ebbs (build_info &bi)\n {\n-  auto temps = temp_watermark ();\n-  unsigned int num_bb_indices = last_basic_block_for_fn (m_fn);\n-\n   // Compute the starting reverse postorder.  We tweak this later to try\n   // to get better EBB assignments.\n   auto *postorder = new int[n_basic_blocks_for_fn (m_fn)];\n   unsigned int postorder_num\n     = pre_and_rev_post_order_compute (nullptr, postorder, true);\n   gcc_assert (int (postorder_num) <= n_basic_blocks_for_fn (m_fn));\n \n-  // Construct the working state for this function and its subroutines.\n-  build_info bi;\n-  bi.last_access = XOBNEWVEC (&m_temp_obstack, access_info *, m_num_regs + 1);\n-  memset (bi.last_access, 0, (m_num_regs + 1) * sizeof (set_info *));\n-\n-  // The bb_live_out array shouldn't need to be initialized, since we'll\n-  // always write to an entry before reading from it.  But poison the\n-  // contents when checking, just to make sure we don't accidentally use\n-  // an uninitialized value.\n-  bi.bb_live_out = XOBNEWVEC (&m_temp_obstack, bb_live_out_info,\n-\t\t\t      num_bb_indices);\n-  if (flag_checking)\n-    memset (bi.bb_live_out, 0xaf,\n-\t    num_bb_indices * sizeof (bb_live_out_info));\n-\n-  // Only pay the overhead of recording a separate live-in bitmap if\n-  // there are debug instructions that might need it.\n-  auto_bitmap ebb_live_in;\n-  if (MAY_HAVE_DEBUG_INSNS)\n-    {\n-      bi.ebb_live_in_for_debug = ebb_live_in;\n-      // The bitmap is tested using individual bit operations, so optimize\n-      // for that case.\n-      bitmap_tree_view (ebb_live_in);\n-    }\n-  else\n-    bi.ebb_live_in_for_debug = nullptr;\n-\n   // Iterate over the blocks in reverse postorder.  In cases where\n   // multiple possible orders exist, prefer orders that chain blocks\n   // together into EBBs.  If multiple possible EBBs exist, try to pick\n   // the ones that are most likely to be profitable.\n-  auto_vec<bb_info *, 16> ebb;\n-  auto_bitmap ebb_use_tmp;\n-  auto_bitmap ebb_def_tmp;\n+  auto_vec<bb_info *, 16> bbs;\n+  unsigned int next_bb_index = 0;\n   for (unsigned int i = 0; i < postorder_num; ++i)\n     if (!m_bbs[postorder[i]])\n       {\n-\t// Choose and create the blocks that should form the next EBB,\n-\t// and calculate the set of registers that the EBB uses and defines\n-\t// Only do actual bitmap operations if the EBB contains multiple\n-\t// blocks.\n+\t// Choose and create the blocks that should form the next EBB.\n \tbasic_block cfg_bb = BASIC_BLOCK_FOR_FN (m_fn, postorder[i]);\n-\tbi.ebb_use = &DF_LR_BB_INFO (cfg_bb)->use;\n-\tbi.ebb_def = &DF_LR_BB_INFO (cfg_bb)->def;\n-\tebb.safe_push (create_bb_info (cfg_bb));\n-\tcfg_bb = choose_next_block_in_ebb (cfg_bb);\n-\tif (cfg_bb)\n+\tdo\n \t  {\n-\t    // An EBB with two blocks.\n-\t    bitmap_ior (ebb_use_tmp, bi.ebb_use, &DF_LR_BB_INFO (cfg_bb)->use);\n-\t    bitmap_ior (ebb_def_tmp, bi.ebb_def, &DF_LR_BB_INFO (cfg_bb)->def);\n-\t    bi.ebb_use = ebb_use_tmp;\n-\t    bi.ebb_def = ebb_def_tmp;\n-\t    ebb.safe_push (create_bb_info (cfg_bb));\n+\t    // Record the chosen block order in a new RPO.\n+\t    bi.bb_to_rpo[cfg_bb->index] = next_bb_index++;\n+\t    bbs.safe_push (create_bb_info (cfg_bb));\n \t    cfg_bb = choose_next_block_in_ebb (cfg_bb);\n-\t    while (cfg_bb)\n-\t      {\n-\t\t// An EBB with three or more blocks.\n-\t\tbitmap_ior_into (bi.ebb_use, &DF_LR_BB_INFO (cfg_bb)->use);\n-\t\tbitmap_ior_into (bi.ebb_def, &DF_LR_BB_INFO (cfg_bb)->def);\n-\t\tebb.safe_push (create_bb_info (cfg_bb));\n-\t\tcfg_bb = choose_next_block_in_ebb (cfg_bb);\n-\t      }\n \t  }\n+\twhile (cfg_bb);\n \n \t// Create the EBB itself.\n-\tbi.current_ebb = allocate<ebb_info> (ebb[0], ebb.last ());\n-\tfor (bb_info *bb : ebb)\n-\t  {\n-\t    bb->set_ebb (bi.current_ebb);\n-\t    append_bb (bb);\n-\t  }\n-\n-\t// Populate the contents of the EBB.\n-\tbi.current_ebb->set_phi_insn (append_artificial_insn (ebb[0]));\n-\tif (ebb[0]->index () == ENTRY_BLOCK)\n-\t  {\n-\t    gcc_assert (ebb.length () == 1);\n-\t    bi.current_bb = ebb[0];\n-\t    add_entry_block_defs (bi);\n-\t    record_block_live_out (bi);\n-\t  }\n-\telse if (EDGE_COUNT (ebb[0]->cfg_bb ()->preds) == 0)\n-\t  // Leave unreachable blocks empty, since there is no useful\n-\t  // liveness information for them, and anything they do will\n-\t  // be wasted work.  In a cleaned-up cfg, the only unreachable\n-\t  // block we should see is the exit block of a noreturn function.\n-\t  for (bb_info *bb : ebb)\n-\t    {\n-\t      bb->set_head_insn (append_artificial_insn (bb));\n-\t      bb->set_end_insn (append_artificial_insn (bb));\n-\t    }\n-\telse\n-\t  {\n-\t    add_phi_nodes (bi);\n-\t    for (bb_info *bb : ebb)\n-\t      {\n-\t\tbi.current_bb = bb;\n-\t\tadd_artificial_accesses (bi, DF_REF_AT_TOP);\n-\t\tif (bb->index () != EXIT_BLOCK)\n-\t\t  add_block_contents (bi);\n-\t\tadd_artificial_accesses (bi, df_ref_flags ());\n-\t\trecord_block_live_out (bi);\n-\t\tpopulate_backedge_phis (bi);\n-\t      }\n-\t  }\n-\tebb.truncate (0);\n+\tauto *ebb = allocate<ebb_info> (bbs[0], bbs.last ());\n+\tfor (bb_info *bb : bbs)\n+\t  bb->set_ebb (ebb);\n+\tbbs.truncate (0);\n       }\n \n   delete[] postorder;\n }\n \n+// Partition the function's blocks into EBBs and build SSA form for all\n+// EBBs in the function.\n+void\n+function_info::process_all_blocks ()\n+{\n+  auto temps = temp_watermark ();\n+  unsigned int num_bb_indices = last_basic_block_for_fn (m_fn);\n+\n+  build_info bi (m_num_regs, num_bb_indices);\n+\n+  calculate_potential_phi_regs (bi);\n+  create_ebbs (bi);\n+  place_phis (bi);\n+  bb_walker (this, bi).walk (ENTRY_BLOCK_PTR_FOR_FN (m_fn));\n+  populate_phi_inputs (bi);\n+\n+  if (flag_checking)\n+    {\n+      // The definition stack should be empty and all register definitions\n+      // should be back in their original undefined state.\n+      gcc_assert (bi.def_stack.is_empty ()\n+\t\t  && bi.old_def_stack_limit.is_empty ());\n+      for (unsigned int regno = 0; regno < m_num_regs; ++regno)\n+\tgcc_assert (!bi.last_access[regno + 1]);\n+    }\n+}\n+\n // Print a description of CALL_CLOBBERS to PP.\n void\n rtl_ssa::pp_ebb_call_clobbers (pretty_printer *pp,"}, {"sha": "bfab3d916f35146c75a80236603c6e4746d5de05", "filename": "gcc/rtl-ssa/changes.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Fchanges.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Fchanges.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Fchanges.cc?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -26,6 +26,7 @@\n #include \"rtl.h\"\n #include \"df.h\"\n #include \"rtl-ssa.h\"\n+#include \"rtl-ssa/internals.h\"\n #include \"rtl-ssa/internals.inl\"\n #include \"target.h\"\n #include \"predict.h\""}, {"sha": "257bc2bafa5ea69546b13b1b0c1173377c549669", "filename": "gcc/rtl-ssa/functions.cc", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Ffunctions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Ffunctions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Ffunctions.cc?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -26,6 +26,7 @@\n #include \"rtl.h\"\n #include \"df.h\"\n #include \"rtl-ssa.h\"\n+#include \"rtl-ssa/internals.h\"\n #include \"rtl-ssa/internals.inl\"\n \n using namespace rtl_ssa;\n@@ -74,23 +75,6 @@ function_info::print (pretty_printer *pp) const\n     }\n }\n \n-// Calculate m_potential_phi_regs.\n-void\n-function_info::calculate_potential_phi_regs ()\n-{\n-  auto *lr_info = DF_LR_BB_INFO (ENTRY_BLOCK_PTR_FOR_FN (m_fn));\n-  for (unsigned int regno = 0; regno < m_num_regs; ++regno)\n-    if (regno >= DF_REG_SIZE (DF)\n-\t// Exclude registers that have a single definition that dominates\n-\t// all uses.  If the definition does not dominate all uses,\n-\t// the register will be exposed upwards to the entry block but\n-\t// will not be defined by the entry block.\n-\t|| DF_REG_DEF_COUNT (regno) > 1\n-\t|| (!bitmap_bit_p (&lr_info->def, regno)\n-\t    && bitmap_bit_p (&lr_info->out, regno)))\n-      bitmap_set_bit (m_potential_phi_regs, regno);\n-}\n-\n // Initialize all member variables in preparation for (re)building\n // SSA form from scratch.\n void\n@@ -107,8 +91,6 @@ function_info::init_function_data ()\n   m_last_insn = nullptr;\n   m_last_nondebug_insn = nullptr;\n   m_free_phis = nullptr;\n-\n-  calculate_potential_phi_regs ();\n }\n \n // The initial phase of the phi simplification process.  The cumulative"}, {"sha": "58755d74cc980b8289aa4d72e057cb98d1dfb297", "filename": "gcc/rtl-ssa/functions.h", "status": "modified", "additions": 11, "deletions": 84, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Ffunctions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Ffunctions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Ffunctions.h?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -176,81 +176,9 @@ class function_info\n   void print (pretty_printer *pp) const;\n \n private:\n-  // Information about the values that are live on exit from a basic block.\n-  // This class is only used when constructing the SSA form, it isn't\n-  // designed for being kept up-to-date.\n-  class bb_live_out_info\n-  {\n-  public:\n-    // REG_VALUES contains all the registers that live out from the block,\n-    // in order of increasing register number.  There are NUM_REG_VALUES\n-    // in total.  Registers do not appear here if their values are known\n-    // to be completely undefined; in that sense, the information is\n-    // closer to DF_LIVE than to DF_LR.\n-    unsigned int num_reg_values;\n-    set_info **reg_values;\n-\n-    // The memory value that is live on exit from the block.\n-    set_info *mem_value;\n-  };\n-\n-  // Information used while constructing the SSA form and discarded\n-  // afterwards.\n-  class build_info\n-  {\n-  public:\n-    set_info *current_reg_value (unsigned int) const;\n-    set_info *current_mem_value () const;\n-\n-    void record_reg_def (unsigned int, def_info *);\n-    void record_mem_def (def_info *);\n-\n-    // The block that we're currently processing.\n-    bb_info *current_bb;\n-\n-    // The EBB that contains CURRENT_BB.\n-    ebb_info *current_ebb;\n-\n-    // Except for the local exception noted below:\n-    //\n-    // - If register R has been defined in the current EBB, LAST_ACCESS[R + 1]\n-    //   is the last definition of R in the EBB.\n-    //\n-    // - If register R is currently live but has not yet been defined\n-    //   in the EBB, LAST_ACCESS[R + 1] is the current value of R,\n-    //   or null if the register's value is completely undefined.\n-    //\n-    // - The contents are not meaningful for other registers.\n-    //\n-    // Similarly:\n-    //\n-    // - If the current EBB has defined memory, LAST_ACCESS[0] is the last\n-    //   definition of memory in the EBB.\n-    //\n-    // - Otherwise LAST_ACCESS[0] is the value of memory that is live on\n-    // - entry to the EBB.\n-    //\n-    // The exception is that while building instructions, LAST_ACCESS[I]\n-    // can temporarily be the use of regno I - 1 by that instruction.\n-    access_info **last_access;\n-\n-    // A bitmap of registers that are live on entry to this EBB, with a tree\n-    // view for quick lookup.  Only used if MAY_HAVE_DEBUG_INSNS.\n-    bitmap ebb_live_in_for_debug;\n-\n-    // A conservative superset of the registers that are used by\n-    // instructions in CURRENT_EBB.  That is, all used registers\n-    // are in the set, but some unused registers might be too.\n-    bitmap ebb_use;\n-\n-    // A similarly conservative superset of the registers that are defined\n-    // by instructions in CURRENT_EBB.\n-    bitmap ebb_def;\n-\n-    // BB_LIVE_OUT[BI] gives the live-out values for the basic block\n-    // with index BI.\n-    bb_live_out_info *bb_live_out;\n-  };\n+  class bb_phi_info;\n+  class build_info;\n+  class bb_walker;\n \n   // Return an RAII object that owns all objects allocated by\n   // allocate_temp during its lifetime.\n@@ -307,6 +235,7 @@ class function_info\n   void start_insn_accesses ();\n   void finish_insn_accesses (insn_info *);\n \n+  use_info *create_reg_use (build_info &, insn_info *, resource_info);\n   void record_use (build_info &, insn_info *, rtx_obj_reference);\n   void record_call_clobbers (build_info &, insn_info *, rtx_call_insn *);\n   void record_def (build_info &, insn_info *, rtx_obj_reference);\n@@ -327,20 +256,25 @@ class function_info\n \n   bb_info *create_bb_info (basic_block);\n   void append_bb (bb_info *);\n-  void calculate_potential_phi_regs ();\n \n   insn_info *add_placeholder_after (insn_info *);\n   void possibly_queue_changes (insn_change &);\n   void finalize_new_accesses (insn_change &);\n   void apply_changes_to_insn (insn_change &);\n \n   void init_function_data ();\n+  void calculate_potential_phi_regs (build_info &);\n+  void place_phis (build_info &);\n+  void create_ebbs (build_info &);\n   void add_entry_block_defs (build_info &);\n+  void calculate_ebb_live_in_for_debug (build_info &);\n   void add_phi_nodes (build_info &);\n   void add_artificial_accesses (build_info &, df_ref_flags);\n   void add_block_contents (build_info &);\n   void record_block_live_out (build_info &);\n-  void populate_backedge_phis (build_info &);\n+  void start_block (build_info &, bb_info *);\n+  void end_block (build_info &, bb_info *);\n+  void populate_phi_inputs (build_info &);\n   void process_all_blocks ();\n \n   void simplify_phi_setup (phi_info *, set_info **, bitmap);\n@@ -400,13 +334,6 @@ class function_info\n   auto_vec<access_info *> m_temp_defs;\n   auto_vec<access_info *> m_temp_uses;\n \n-  // The set of registers that might need to have phis associated with them.\n-  // Registers outside this set are known to have a single definition that\n-  // dominates all uses.\n-  //\n-  // Before RA, about 5% of registers are typically in the set.\n-  auto_bitmap m_potential_phi_regs;\n-\n   // A list of phis that are no longer in use.  Their uids are still unique\n   // and so can be recycled.\n   phi_info *m_free_phis;"}, {"sha": "5cc3962e81a742360efe1897b1dfdf137ae9b80e", "filename": "gcc/rtl-ssa/insns.cc", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finsns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finsns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Finsns.cc?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -26,6 +26,7 @@\n #include \"rtl.h\"\n #include \"df.h\"\n #include \"rtl-ssa.h\"\n+#include \"rtl-ssa/internals.h\"\n #include \"rtl-ssa/internals.inl\"\n #include \"predict.h\"\n #include \"print-rtl.h\"\n@@ -406,6 +407,33 @@ function_info::finish_insn_accesses (insn_info *insn)\n   insn->set_accesses (static_cast<access_info **> (addr), num_defs, num_uses);\n }\n \n+// Called while building SSA form using BI.  Create and return a use of\n+// register RESOURCE in INSN.  Create a degenerate phi where necessary.\n+use_info *\n+function_info::create_reg_use (build_info &bi, insn_info *insn,\n+\t\t\t       resource_info resource)\n+{\n+  set_info *value = bi.current_reg_value (resource.regno);\n+  if (value && value->ebb () != bi.current_ebb)\n+    {\n+      if (insn->is_debug_insn ())\n+\tvalue = look_through_degenerate_phi (value);\n+      else if (bitmap_bit_p (bi.potential_phi_regs, resource.regno))\n+\t{\n+\t  // VALUE is defined by a previous EBB and RESOURCE has multiple\n+\t  // definitions.  Create a degenerate phi in the current EBB\n+\t  // so that all definitions and uses follow a linear RPO view;\n+\t  // see rtl.texi for details.\n+\t  access_info *inputs[] = { look_through_degenerate_phi (value) };\n+\t  value = create_phi (bi.current_ebb, value->resource (), inputs, 1);\n+\t  bi.record_reg_def (value);\n+\t}\n+    }\n+  auto *use = allocate<use_info> (insn, resource, value);\n+  add_use (use);\n+  return use;\n+}\n+\n // Called while building SSA form using BI.  Record that INSN contains\n // read reference REF.  If this requires new entries to be added to\n // INSN->uses (), add those entries to the list we're building in\n@@ -450,28 +478,25 @@ function_info::record_use (build_info &bi, insn_info *insn,\n \t  if (value->ebb () == bi.current_ebb)\n \t    return true;\n \n+\t  // Check if VALUE is the function's only definition of REGNO.\n+\t  // (We already know that it dominates the use.)\n+\t  if (!bitmap_bit_p (bi.potential_phi_regs, regno))\n+\t    return true;\n+\n \t  // If the register is live on entry to the EBB but not used\n \t  // within it, VALUE is the correct live-in value.\n+\t  if (!bi.ebb_live_in_for_debug)\n+\t    calculate_ebb_live_in_for_debug (bi);\n \t  if (bitmap_bit_p (bi.ebb_live_in_for_debug, regno))\n \t    return true;\n \n-\t  // Check if VALUE is the function's only definition of REGNO\n-\t  // and if it dominates the use.\n-\t  if (regno != MEM_REGNO\n-\t      && regno < DF_REG_SIZE (DF)\n-\t      && DF_REG_DEF_COUNT (regno) == 1\n-\t      && dominated_by_p (CDI_DOMINATORS, insn->bb ()->cfg_bb (),\n-\t\t\t\t value->bb ()->cfg_bb ()))\n-\t    return true;\n-\n \t  // Punt for other cases.\n \t  return false;\n \t};\n       if (insn->is_debug_insn () && !value_is_valid ())\n \tvalue = nullptr;\n \n-      use = allocate<use_info> (insn, resource_info { mode, regno }, value);\n-      add_use (use);\n+      use = create_reg_use (bi, insn, { mode, regno });\n       m_temp_uses.safe_push (use);\n       bi.last_access[ref.regno + 1] = use;\n       use->record_reference (ref, true);\n@@ -547,7 +572,7 @@ function_info::record_call_clobbers (build_info &bi, insn_info *insn,\n \t      def->m_is_call_clobber = true;\n \t      append_def (def);\n \t      m_temp_defs.safe_push (def);\n-\t      bi.last_access[regno + 1] = def;\n+\t      bi.record_reg_def (def);\n \t    }\n \t}\n }\n@@ -599,7 +624,7 @@ function_info::record_def (build_info &bi, insn_info *insn,\n   def->record_reference (ref, true);\n   append_def (def);\n   m_temp_defs.safe_push (def);\n-  bi.last_access[ref.regno + 1] = def;\n+  bi.record_reg_def (def);\n }\n \n // Called while building SSA form using BI.  Add an insn_info for RTL"}, {"sha": "65c44ec978b585e0d8e895f31012a0778be58ba4", "filename": "gcc/rtl-ssa/internals.h", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finternals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finternals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Finternals.h?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -0,0 +1,140 @@\n+// Definition of private classes for RTL SSA                        -*- C++ -*-\n+// Copyright (C) 2020-2021 Free Software Foundation, Inc.\n+//\n+// This file is part of GCC.\n+//\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+//\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+//\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+namespace rtl_ssa {\n+\n+// Information about a basic block's phi nodes.  This class is only used when\n+// constructing the SSA form, it isn't meant to be kept up-to-date.\n+class function_info::bb_phi_info\n+{\n+public:\n+  // The set of registers that need phi nodes.\n+  bitmap_head regs;\n+\n+  // The number of registers in REGS.\n+  unsigned int num_phis;\n+\n+  // The number of inputs to each phi node.  Caching the information here\n+  // is at best a minor optimisation, but it fills a 32-bit hole that would\n+  // otherwise exist on 64-bit hosts.\n+  unsigned int num_preds;\n+\n+  // An array of all the phi inputs for this block.  It lists all inputs\n+  // from the first incoming edge followed by all inputs for the next\n+  // incoming edge, and so on.  The inputs for a given edge are sorted\n+  // by increasing register number.\n+  set_info **inputs;\n+};\n+\n+// Information used while constructing the SSA form and discarded\n+// afterwards.\n+class function_info::build_info\n+{\n+public:\n+  build_info (unsigned int, unsigned int);\n+  ~build_info ();\n+\n+  set_info *current_reg_value (unsigned int) const;\n+  set_info *current_mem_value () const;\n+\n+  void record_reg_def (def_info *);\n+  void record_mem_def (def_info *);\n+\n+  // The block that we're currently processing.\n+  bb_info *current_bb;\n+\n+  // The EBB that contains CURRENT_BB.\n+  ebb_info *current_ebb;\n+\n+  // Except for the local exception noted below:\n+  //\n+  // - If register R has been defined in the current EBB, LAST_ACCESS[R + 1]\n+  //   is the last definition of R in the EBB.\n+  //\n+  // - Otherwise, if the current EBB is dominated by a definition of R,\n+  //   LAST_ACCESS[R + 1] is the nearest dominating definition.\n+  //\n+  // - Otherwise, LAST_ACCESS[R + 1] is null.\n+  //\n+  // Similarly:\n+  //\n+  // - If the current EBB has defined memory, LAST_ACCESS[0] is the last\n+  //   definition of memory in the EBB.\n+  //\n+  // - Otherwise LAST_ACCESS[0] is the value of memory that is live on\n+  // - entry to the EBB.\n+  //\n+  // The exception is that while building instructions, LAST_ACCESS[I]\n+  // can temporarily be the use of regno I - 1 by that instruction.\n+  auto_vec<access_info *> last_access;\n+\n+  // A bitmap used to hold EBB_LIVE_IN_FOR_DEBUG.\n+  auto_bitmap tmp_ebb_live_in_for_debug;\n+\n+  // If nonnull, a bitmap of registers that are live on entry to this EBB,\n+  // with a tree view for quick lookup.  This bitmap is calculated lazily\n+  // and is only used if MAY_HAVE_DEBUG_INSNS.\n+  bitmap ebb_live_in_for_debug;\n+\n+  // The set of registers that might need to have phis associated with them.\n+  // Registers outside this set are known to have a single definition that\n+  // dominates all uses.\n+  //\n+  // Before RA, about 5% of registers are typically in the set.\n+  auto_sbitmap potential_phi_regs;\n+\n+  // A sparse bitmap representation of POTENTIAL_PHI_REGS.  Only used if\n+  // MAY_HAVE_DEBUG_INSNS.\n+  auto_bitmap potential_phi_regs_for_debug;\n+\n+  // The set of registers that have been defined so far in the current EBB.\n+  auto_bitmap ebb_def_regs;\n+\n+  // BB_PHIS[B] describes the phis for basic block B.\n+  auto_vec<bb_phi_info> bb_phis;\n+\n+  // BB_MEM_LIVE_OUT[B] is the memory value that is live on exit from\n+  // basic block B.\n+  auto_vec<set_info *> bb_mem_live_out;\n+\n+  // BB_TO_RPO[B] gives the position of block B in a reverse postorder\n+  // of the CFG.  The RPO is a tweaked version of the one normally\n+  // returned by pre_and_rev_post_order_compute, with all blocks in\n+  // an EBB having consecutive positions.\n+  auto_vec<int> bb_to_rpo;\n+\n+  // This stack is divided into sections, with one section for the\n+  // current basic block and one section for each dominating block.\n+  // Each element is a register definition.\n+  //\n+  // If the section for block B contains a definition D of a register R,\n+  // then one of two things is true:\n+  //\n+  // - D occurs in B and no definition of R dominates B.\n+  // - D dominates B and is the nearest dominating definition of R.\n+  //\n+  // The two cases are distinguished by the value of D->bb ().\n+  auto_vec<def_info *> def_stack;\n+\n+  // The top of this stack records the start of the current block's\n+  // section in DEF_STACK.\n+  auto_vec<unsigned int> old_def_stack_limit;\n+};\n+\n+}"}, {"sha": "325717d605804b0311a084014c33840fa4876ca9", "filename": "gcc/rtl-ssa/internals.inl", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finternals.inl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abe07a74bb7a2692eff2af151ca54e749ed5eba6/gcc%2Frtl-ssa%2Finternals.inl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-ssa%2Finternals.inl?ref=abe07a74bb7a2692eff2af151ca54e749ed5eba6", "patch": "@@ -574,10 +574,20 @@ inline ebb_info::ebb_info (bb_info *first_bb, bb_info *last_bb)\n {\n }\n \n-// Set the contents of last_access for register REGNO to DEF.\n-inline void\n-function_info::build_info::record_reg_def (unsigned int regno, def_info *def)\n-{\n+// Record register definition DEF in last_access, pushing a definition\n+// to def_stack where appropriate.\n+inline void\n+function_info::build_info::record_reg_def (def_info *def)\n+{\n+  unsigned int regno = def->regno ();\n+  auto *prev_dominating_def = safe_as_a<def_info *> (last_access[regno + 1]);\n+  if (!prev_dominating_def)\n+    // Indicate that DEF is the first dominating definition of REGNO.\n+    def_stack.safe_push (def);\n+  else if (prev_dominating_def->bb () != def->bb ())\n+    // Record that PREV_DOMINATING_DEF was the dominating definition\n+    // of REGNO on entry to the current block.\n+    def_stack.safe_push (prev_dominating_def);\n   last_access[regno + 1] = def;\n }\n "}]}