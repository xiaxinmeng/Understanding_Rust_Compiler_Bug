{"sha": "51526856a1ca4a9434919d012a2bed07c8395ee0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE1MjY4NTZhMWNhNGE5NDM0OTE5ZDAxMmEyYmVkMDdjODM5NWVlMA==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2012-09-15T15:52:28Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2012-09-15T15:52:28Z"}, "message": "re PR target/54222 ([avr] Implement fixed-point support)\n\ngcc/\n\tPR target/54222\n\t* config/avr/avr-fixed.md (ALL2S, ALL4S, ALL24S, ALL124S,\n\tALL124U): New mode iterators.\n\t(<code_stdname><mode>3): New insns for SS_PLUS, SS_MINUS.\n\t(<code_stdname><mode>3): New insns for US_PLUS, US_MINUS.\n\t(usneg<mode>2): New insns.\n\t(<code_stdname><mode>2): New expanders for SS_NEG, SS_ABS.\n\t(*<code_stdname><mode>2): New insns for SS_NEG, SS_ABS.\n\t* config/avr/avr-dimode.md (ALL8U, ALL8S): New mode iterators.\n\t(avr_out_plus64, avr_out_minus64): Use avr_out_plus instead.\n\t(<code_stdname><mode>3): New expanders for SS_PLUS, SS_MINUS.\n\t(<code_stdname><mode>3): New expanders for US_PLUS, US_MINUS.\n\t(<code_stdname><mode>3_insn): New insns.\n\t(<code_stdname><mode>3_const_insn): New insns.\n\t* config/avr/avr.md (cc): Add: plus. Remove: out_plus,\n\tout_plus_noclobber, minus.\n\t(length): Add: plus.  Remove: out_plus, out_plus_noclobber,\n\tplus64, minus, minus64.\n\t(abelian): New code_attr.\n\t(code_stdname): Handle: ss_plus, ss_minus, ss_neg, ss_abs,\n\tus_plus, us_minus, us_neg.\n\t(*add<mode>3, add<mode>3_clobber, add<mode>3, addpsi3, sub<mode>3):\n\tUse avr_out_plus to output.\n\t* config/avr/avr-protos.h (avr_out_plus): Change prototype.\n\t(avr_out_plus_noclobber, avr_out_minus): Remove.\n\t(avr_out_plus64, avr_out_minus64): Remove.\n\t* config/avr/avr.c (avr_out_plus_1): Add new default arguments\n\tcode_sat, sign.  Saturate after operation if code_sat != UNKNOWN.\n\t(avr_out_plus_symbol): New static function.\n\t(avr_out_plus): Rewrite.\n\t(adjust_insn_length): Handle: ADJUST_LEN_PLUS.  Remove handling\n\tof: ADJUST_LEN_OUT_PLUS, ADJUST_LEN_PLUS64, ADJUST_LEN_MINUS, \n\tADJUST_LEN_MINUS64, ADJUST_LEN_OUT_PLUS_NOCLOBBER.\n\t(notice_update_cc): Handle: CC_PLUS.  Remove handling of: CC_MINUS,\n\tCC_OUT_PLUS, CC_OUT_PLUS_NOCLOBBER\n\t(avr_out_plus_noclobber, avr_out_minus): Remove.\n\t(avr_out_plus64, avr_out_minus64): Remove.\n\t(avr_print_operand): Print raw REGNO if 'r' is used with REG.\n\nlibgcc/\n\tPR target/54222\n\t* config/avr/lib1funcs-fixed.S (__ssneg_2, __ssabs_2, __ssneg_4,\n\t__ssabs_4, __clr_8, __ssneg_8, __ssabs_8,\n\t__usadd_8, __ussub_8, __ssadd_8, __sssub_8): New functions.\n\t(__divsa3): Use __negsi2 to negate r_quoL.\n\t* config/avr/lib1funcs.S (FALIAS): New macro.\n\t(__divmodsi4): Break out and use __divmodsi4_neg1 as...\n\t(__negsi2): ...this new function.\n\t* config/avr/t-avr (LIB1ASMFUNCS): Add _negsi2, _clr_8,\n\t_ssneg_2, _ssneg_4, _ssneg_8, _ssabs_2, _ssabs_4,\n\t_ssabs_8, _ssadd_8, _sssub_8, _usadd_8, _ussub_8.\n\t(LIB2FUNCS_EXCLUDE): Fix typo for _add _sub.\n\tAdd: _ssadd*, _sssub*, _ssneg*, _ssabs* for signed fixed modes.\n\tAdd: _usadd*, _ussub*, _usneg* for unsigned fixed modes.\n\ngcc/testsuite/\n\tPR target/54222\n\t* gcc.target/avr/torture/fix-types.h: New.\n\t* gcc.target/avr/torture/vals-hr.def: New.\n\t* gcc.target/avr/torture/vals-r.def: New.\n\t* gcc.target/avr/torture/vals-k.def: New.\n\t* gcc.target/avr/torture/vals-ur.def: New.\n\t* gcc.target/avr/torture/vals-uk.def: New.\n\t* gcc.target/avr/torture/vals-uhr.def: New.\n\t* gcc.target/avr/torture/vals-llk.def: New.\n\t* gcc.target/avr/torture/vals-ullk.def: New.\n\t* gcc.target/avr/torture/sat-hr-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-r-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-k-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-ur-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-uk-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-uhr-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-llk-plus-minus.c: New.\n\t* gcc.target/avr/torture/sat-ullk-plus-minus.c: New.\n\nFrom-SVN: r191345", "tree": {"sha": "89382cc27ddcd6714736d847af8f8dc0b6289abc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/89382cc27ddcd6714736d847af8f8dc0b6289abc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51526856a1ca4a9434919d012a2bed07c8395ee0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51526856a1ca4a9434919d012a2bed07c8395ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51526856a1ca4a9434919d012a2bed07c8395ee0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51526856a1ca4a9434919d012a2bed07c8395ee0/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc2655fb3082182075b288b58c93ac563ef661a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc2655fb3082182075b288b58c93ac563ef661a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc2655fb3082182075b288b58c93ac563ef661a0"}], "stats": {"total": 2293, "additions": 2087, "deletions": 206}, "files": [{"sha": "a5e3018802fbbd8030631570ffffe8a677881e70", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -1,3 +1,44 @@\n+2012-09-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* config/avr/avr-fixed.md (ALL2S, ALL4S, ALL24S, ALL124S,\n+\tALL124U): New mode iterators.\n+\t(<code_stdname><mode>3): New insns for SS_PLUS, SS_MINUS.\n+\t(<code_stdname><mode>3): New insns for US_PLUS, US_MINUS.\n+\t(usneg<mode>2): New insns.\n+\t(<code_stdname><mode>2): New expanders for SS_NEG, SS_ABS.\n+\t(*<code_stdname><mode>2): New insns for SS_NEG, SS_ABS.\n+\t* config/avr/avr-dimode.md (ALL8U, ALL8S): New mode iterators.\n+\t(avr_out_plus64, avr_out_minus64): Use avr_out_plus instead.\n+\t(<code_stdname><mode>3): New expanders for SS_PLUS, SS_MINUS.\n+\t(<code_stdname><mode>3): New expanders for US_PLUS, US_MINUS.\n+\t(<code_stdname><mode>3_insn): New insns.\n+\t(<code_stdname><mode>3_const_insn): New insns.\n+\t* config/avr/avr.md (cc): Add: plus. Remove: out_plus,\n+\tout_plus_noclobber, minus.\n+\t(length): Add: plus.  Remove: out_plus, out_plus_noclobber,\n+\tplus64, minus, minus64.\n+\t(abelian): New code_attr.\n+\t(code_stdname): Handle: ss_plus, ss_minus, ss_neg, ss_abs,\n+\tus_plus, us_minus, us_neg.\n+\t(*add<mode>3, add<mode>3_clobber, add<mode>3, addpsi3, sub<mode>3):\n+\tUse avr_out_plus to output.\n+\t* config/avr/avr-protos.h (avr_out_plus): Change prototype.\n+\t(avr_out_plus_noclobber, avr_out_minus): Remove.\n+\t(avr_out_plus64, avr_out_minus64): Remove.\n+\t* config/avr/avr.c (avr_out_plus_1): Add new default arguments\n+\tcode_sat, sign.  Saturate after operation if code_sat != UNKNOWN.\n+\t(avr_out_plus_symbol): New static function.\n+\t(avr_out_plus): Rewrite.\n+\t(adjust_insn_length): Handle: ADJUST_LEN_PLUS.  Remove handling\n+\tof: ADJUST_LEN_OUT_PLUS, ADJUST_LEN_PLUS64, ADJUST_LEN_MINUS, \n+\tADJUST_LEN_MINUS64, ADJUST_LEN_OUT_PLUS_NOCLOBBER.\n+\t(notice_update_cc): Handle: CC_PLUS.  Remove handling of: CC_MINUS,\n+\tCC_OUT_PLUS, CC_OUT_PLUS_NOCLOBBER\n+\t(avr_out_plus_noclobber, avr_out_minus): Remove.\n+\t(avr_out_plus64, avr_out_minus64): Remove.\n+\t(avr_print_operand): Print raw REGNO if 'r' is used with REG.\n+\n 2012-09-15  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \t* config/sh/sh.c (sh_rtx_costs): Add handling of MEM, SIGN_EXTEND,"}, {"sha": "31527dbf0412bcfcdf935bc867249ccd8353557c", "filename": "gcc/config/avr/avr-dimode.md", "status": "modified", "additions": 103, "deletions": 8, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-dimode.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-dimode.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-dimode.md?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -48,10 +48,10 @@\n    (ACC_B\t10)])\n \n ;; Supported modes that are 8 bytes wide\n-(define_mode_iterator ALL8 [(DI \"\")\n-                            (DQ \"\") (UDQ \"\")\n-                            (DA \"\") (UDA \"\")\n-                            (TA \"\") (UTA \"\")])\n+(define_mode_iterator ALL8 [DI DQ UDQ DA UDA TA UTA])\n+\n+(define_mode_iterator ALL8U [UDQ UDA UTA])\n+(define_mode_iterator ALL8S [ DQ  DA  TA])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Addition\n@@ -124,9 +124,9 @@\n   \"avr_have_dimode\n    && !s8_operand (operands[0], VOIDmode)\"\n   {\n-    return avr_out_plus64 (operands[0], NULL);\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"plus64\")\n+  [(set_attr \"adjust_len\" \"plus\")\n    (set_attr \"cc\" \"clobber\")])\n \n \n@@ -185,11 +185,106 @@\n                     (match_operand:ALL8 0 \"const_operand\" \"n Ynn\")))]\n   \"avr_have_dimode\"\n   {\n-    return avr_out_minus64 (operands[0], NULL);\n+    return avr_out_plus (insn, operands);\n+  }\n+  [(set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Signed Saturating Addition and Subtraction\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"<code_stdname><mode>3\"\n+  [(set (match_operand:ALL8S 0 \"general_operand\" \"\")\n+        (ss_addsub:ALL8S (match_operand:ALL8S 1 \"general_operand\" \"\")\n+                         (match_operand:ALL8S 2 \"general_operand\" \"\")))]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+\n+    if (const_operand (operands[2], GET_MODE (operands[2])))\n+      {\n+        emit_insn (gen_<code_stdname><mode>3_const_insn (operands[2]));\n+      }\n+    else\n+      {\n+        emit_move_insn (gen_rtx_REG (<MODE>mode, ACC_B), operands[2]);\n+        emit_insn (gen_<code_stdname><mode>3_insn ());\n+      }\n+\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"<code_stdname><mode>3_insn\"\n+  [(set (reg:ALL8S ACC_A)\n+        (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                         (reg:ALL8S ACC_B)))]\n+  \"avr_have_dimode\"\n+  \"%~call __<code_stdname><mode>3\"\n+  [(set_attr \"adjust_len\" \"call\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"<code_stdname><mode>3_const_insn\"\n+  [(set (reg:ALL8S ACC_A)\n+        (ss_addsub:ALL8S (reg:ALL8S ACC_A)\n+                         (match_operand:ALL8S 0 \"const_operand\" \"n Ynn\")))]\n+  \"avr_have_dimode\"\n+  {\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"minus64\")\n+  [(set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Unsigned Saturating Addition and Subtraction\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_expand \"<code_stdname><mode>3\"\n+  [(set (match_operand:ALL8U 0 \"general_operand\" \"\")\n+        (us_addsub:ALL8U (match_operand:ALL8U 1 \"general_operand\" \"\")\n+                         (match_operand:ALL8U 2 \"general_operand\" \"\")))]\n+  \"avr_have_dimode\"\n+  {\n+    rtx acc_a = gen_rtx_REG (<MODE>mode, ACC_A);\n+\n+    emit_move_insn (acc_a, operands[1]);\n+\n+    if (const_operand (operands[2], GET_MODE (operands[2])))\n+      {\n+        emit_insn (gen_<code_stdname><mode>3_const_insn (operands[2]));\n+      }\n+    else\n+      {\n+        emit_move_insn (gen_rtx_REG (<MODE>mode, ACC_B), operands[2]);\n+        emit_insn (gen_<code_stdname><mode>3_insn ());\n+      }\n+\n+    emit_move_insn (operands[0], acc_a);\n+    DONE;\n+  })\n+\n+(define_insn \"<code_stdname><mode>3_insn\"\n+  [(set (reg:ALL8U ACC_A)\n+        (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                         (reg:ALL8U ACC_B)))]\n+  \"avr_have_dimode\"\n+  \"%~call __<code_stdname><mode>3\"\n+  [(set_attr \"adjust_len\" \"call\")\n    (set_attr \"cc\" \"clobber\")])\n \n+(define_insn \"<code_stdname><mode>3_const_insn\"\n+  [(set (reg:ALL8U ACC_A)\n+        (us_addsub:ALL8U (reg:ALL8U ACC_A)\n+                         (match_operand:ALL8U 0 \"const_operand\" \"n Ynn\")))]\n+  \"avr_have_dimode\"\n+  {\n+    return avr_out_plus (insn, operands);\n+  }\n+  [(set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"clobber\")])\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Negation"}, {"sha": "5a99499215040f2ee04ffeb2573902c3f4b3271f", "filename": "gcc/config/avr/avr-fixed.md", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-fixed.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-fixed.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-fixed.md?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -29,6 +29,12 @@\n                               (HA \"\") (UHA \"\")])\n (define_mode_iterator ALL4A [(SA \"\") (USA \"\")])\n \n+(define_mode_iterator ALL2S [HQ HA])\n+(define_mode_iterator ALL4S [SA SQ])\n+(define_mode_iterator ALL24S  [    HQ   HA  SA  SQ])\n+(define_mode_iterator ALL124S [ QQ HQ   HA  SA  SQ])\n+(define_mode_iterator ALL124U [UQQ UHQ UHA USA USQ])\n+\n ;;; Conversions\n \n (define_mode_iterator FIXED_A\n@@ -71,6 +77,112 @@\n   [(set_attr \"cc\" \"clobber\")\n    (set_attr \"adjust_len\" \"ufract\")])\n \n+;******************************************************************************\n+;** Saturated Addition and Subtraction\n+;******************************************************************************\n+\n+;; Fixme:  It would be nice if we could expand the 32-bit versions to a\n+;;    transparent libgcc call if $2 is a REG.  Problem is that it is\n+;;    not possible to describe that addition is commutative.\n+;;    And defining register classes/constraintrs for the involved hard\n+;;    registers and let IRA do the work, yields inacceptable bloated code.\n+;;    Thus, we have to live with the up to 11 instructions that are output\n+;;    for these 32-bit saturated operations.\n+\n+;; \"ssaddqq3\"  \"ssaddhq3\"  \"ssaddha3\"  \"ssaddsq3\"  \"ssaddsa3\"\n+;; \"sssubqq3\"  \"sssubhq3\"  \"sssubha3\"  \"sssubsq3\"  \"sssubsa3\"\n+(define_insn \"<code_stdname><mode>3\"\n+  [(set (match_operand:ALL124S 0 \"register_operand\"                          \"=??d,d\")\n+        (ss_addsub:ALL124S (match_operand:ALL124S 1 \"register_operand\" \"<abelian>0,0\")\n+                           (match_operand:ALL124S 2 \"nonmemory_operand\"         \"r,Ynn\")))]\n+  \"\"\n+  {\n+    return avr_out_plus (insn, operands);\n+  }\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"adjust_len\" \"plus\")])\n+\n+;; \"usadduqq3\"  \"usadduhq3\"  \"usadduha3\" \"usaddusq3\"  \"usaddusa3\"\n+;; \"ussubuqq3\"  \"ussubuhq3\"  \"ussubuha3\" \"ussubusq3\"  \"ussubusa3\"\n+(define_insn \"<code_stdname><mode>3\"\n+  [(set (match_operand:ALL124U 0 \"register_operand\"                          \"=??r,d\")\n+        (us_addsub:ALL124U (match_operand:ALL124U 1 \"register_operand\" \"<abelian>0,0\")\n+                           (match_operand:ALL124U 2 \"nonmemory_operand\"         \"r,Ynn\")))]\n+  \"\"\n+  {\n+    return avr_out_plus (insn, operands);\n+  }\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"adjust_len\" \"plus\")])\n+\n+;******************************************************************************\n+;** Saturated Negation and Absolute Value\n+;******************************************************************************\n+\n+;; Fixme: This will always result in 0.  Dunno why simplify-rtx.c says\n+;;   \"unknown\" on how to optimize this.  libgcc call would be in order,\n+;;   but the performance is *PLAIN* *HORROR* because the optimizers don't\n+;;   manage to optimize out MEMCPY that's sprincled all over fixed-bit.c  */\n+\n+(define_expand \"usneg<mode>2\"\n+  [(parallel [(match_operand:ALL124U 0 \"register_operand\" \"\")\n+              (match_operand:ALL124U 1 \"nonmemory_operand\" \"\")])]\n+  \"\"\n+  {\n+    emit_move_insn (operands[0], CONST0_RTX (<MODE>mode));\n+    DONE;\n+  })\n+\n+(define_insn \"ssnegqq2\"\n+  [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n+        (ss_neg:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))]\n+  \"\"\n+  \"neg %0\\;brvc 0f\\;dec %0\\;0:\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"3\")])\n+\n+(define_insn \"ssabsqq2\"\n+  [(set (match_operand:QQ 0 \"register_operand\"            \"=r\")\n+        (ss_abs:QQ (match_operand:QQ 1 \"register_operand\"  \"0\")))]\n+  \"\"\n+  \"sbrc %0,7\\;neg %0\\;sbrc %0,7\\;dec %0\"\n+  [(set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; \"ssneghq2\"  \"ssnegha2\"  \"ssnegsq2\"  \"ssnegsa2\"\n+;; \"ssabshq2\"  \"ssabsha2\"  \"ssabssq2\"  \"ssabssa2\"\n+(define_expand \"<code_stdname><mode>2\"\n+  [(set (match_dup 2)\n+        (match_operand:ALL24S 1 \"register_operand\" \"\"))\n+   (set (match_dup 2)\n+        (ss_abs_neg:ALL24S (match_dup 2)))\n+   (set (match_operand:ALL24S 0 \"register_operand\" \"\")\n+        (match_dup 2))]\n+  \"\"\n+  {\n+    operands[2] = gen_rtx_REG (<MODE>mode, 26 - GET_MODE_SIZE (<MODE>mode));\n+  })\n+\n+;; \"*ssneghq2\"  \"*ssnegha2\"\n+;; \"*ssabshq2\"  \"*ssabsha2\"\n+(define_insn \"*<code_stdname><mode>2\"\n+  [(set (reg:ALL2S 24)\n+        (ss_abs_neg:ALL2S (reg:ALL2S 24)))]\n+  \"\"\n+  \"%~call __<code_stdname>_2\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+;; \"*ssnegsq2\"  \"*ssnegsa2\"\n+;; \"*ssabssq2\"  \"*ssabssa2\"\n+(define_insn \"*<code_stdname><mode>2\"\n+  [(set (reg:ALL4S 22)\n+        (ss_abs_neg:ALL4S (reg:ALL4S 22)))]\n+  \"\"\n+  \"%~call __<code_stdname>_4\"\n+  [(set_attr \"type\" \"xcall\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n ;******************************************************************************\n ; mul\n "}, {"sha": "690c89bcf0103b5183095de5eaaa135efd2c2926", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -91,12 +91,8 @@ extern int avr_starting_frame_offset (void);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);\n extern const char *avr_out_sbxx_branch (rtx insn, rtx operands[]);\n extern const char* avr_out_bitop (rtx, rtx*, int*);\n-extern const char* avr_out_plus (rtx*, int*, int*);\n-extern const char* avr_out_plus_noclobber (rtx*, int*, int*);\n-extern const char* avr_out_plus64 (rtx, int*);\n+extern const char* avr_out_plus (rtx, rtx*, int* =NULL, int* =NULL);\n extern const char* avr_out_addto_sp (rtx*, int*);\n-extern const char* avr_out_minus (rtx*, int*, int*);\n-extern const char* avr_out_minus64 (rtx, int*);\n extern const char* avr_out_xload (rtx, rtx*, int*);\n extern const char* avr_out_movmem (rtx, rtx*, int*);\n extern const char* avr_out_insert_bits (rtx*, int*);"}, {"sha": "c46f488603f4eb515651ba05142ebd78ed1dcad7", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 431, "deletions": 126, "changes": 557, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -2069,9 +2069,11 @@ avr_print_operand (FILE *file, rtx x, int code)\n   else if (REG_P (x))\n     {\n       if (x == zero_reg_rtx)\n-\tfprintf (file, \"__zero_reg__\");\n+        fprintf (file, \"__zero_reg__\");\n+      else if (code == 'r' && REGNO (x) < 32)\n+        fprintf (file, \"%d\", (int) REGNO (x));\n       else\n-\tfprintf (file, reg_names[true_regnum (x) + abcd]);\n+        fprintf (file, reg_names[REGNO (x) + abcd]);\n     }\n   else if (CONST_INT_P (x))\n     {\n@@ -2172,7 +2174,7 @@ avr_print_operand (FILE *file, rtx x, int code)\n       /* Use normal symbol for direct address no linker trampoline needed */\n       output_addr_const (file, x);\n     }\n-  else if (GET_CODE (x) == CONST_FIXED)\n+  else if (CONST_FIXED_P (x))\n     {\n       HOST_WIDE_INT ival = INTVAL (avr_to_int_mode (x));\n       if (code != 0)\n@@ -2213,9 +2215,7 @@ notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n     default:\n       break;\n \n-    case CC_OUT_PLUS:\n-    case CC_OUT_PLUS_NOCLOBBER:\n-    case CC_MINUS:\n+    case CC_PLUS:\n     case CC_LDI:\n       {\n         rtx *op = recog_data.operand;\n@@ -2229,18 +2229,8 @@ notice_update_cc (rtx body ATTRIBUTE_UNUSED, rtx insn)\n           default:\n             gcc_unreachable();\n             \n-          case CC_OUT_PLUS:\n-            avr_out_plus (op, &len_dummy, &icc);\n-            cc = (enum attr_cc) icc;\n-            break;\n-            \n-          case CC_OUT_PLUS_NOCLOBBER:\n-            avr_out_plus_noclobber (op, &len_dummy, &icc);\n-            cc = (enum attr_cc) icc;\n-            break;\n-\n-          case CC_MINUS:\n-            avr_out_minus (op, &len_dummy, &icc);\n+          case CC_PLUS:\n+            avr_out_plus (insn, op, &len_dummy, &icc);\n             cc = (enum attr_cc) icc;\n             break;\n \n@@ -4246,7 +4236,7 @@ avr_out_compare (rtx insn, rtx *xop, int *plen)\n   /* Map fixed mode operands to integer operands with the same binary\n      representation.  They are easier to handle in the remainder.  */\n \n-  if (CONST_FIXED == GET_CODE (xval))\n+  if (CONST_FIXED_P (xval))\n     {\n       xreg = avr_to_int_mode (xop[0]);\n       xval = avr_to_int_mode (xop[1]);\n@@ -5987,19 +5977,32 @@ lshrsi3_out (rtx insn, rtx operands[], int *len)\n }\n \n \n-/* Output addition of register XOP[0] and compile time constant XOP[2]:\n-\n+/* Output addition of register XOP[0] and compile time constant XOP[2].\n+   CODE == PLUS:  perform addition by using ADD instructions or\n+   CODE == MINUS: perform addition by using SUB instructions:\n+   \n       XOP[0] = XOP[0] + XOP[2]\n+      \n+   Or perform addition/subtraction with register XOP[2] depending on CODE:\n+   \n+      XOP[0] = XOP[0] +/- XOP[2]\n \n-   and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n-   addition; otherwise, set *PLEN to the length of the instruction sequence (in\n-   words) printed with PLEN == NULL.  XOP[3] is an 8-bit scratch register.\n-   CODE == PLUS:  perform addition by using ADD instructions.\n-   CODE == MINUS: perform addition by using SUB instructions.\n-   Set *PCC to effect on cc0 according to respective CC_* insn attribute.  */\n+   If PLEN == NULL, print assembler instructions to perform the operation;\n+   otherwise, set *PLEN to the length of the instruction sequence (in words)\n+   printed with PLEN == NULL.  XOP[3] is an 8-bit scratch register or NULL_RTX.\n+   Set *PCC to effect on cc0 according to respective CC_* insn attribute.\n+\n+   CODE_SAT == UNKNOWN: Perform ordinary, non-saturating operation.\n+   CODE_SAT != UNKNOWN: Perform operation and saturate according to CODE_SAT.\n+   If  CODE_SAT != UNKNOWN  then SIGN contains the sign of the summand resp.\n+   the subtrahend in the original insn, provided it is a compile time constant.\n+   In all other cases, SIGN is 0.\n+\n+   Return \"\".  */\n \n static void\n-avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n+avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc,\n+                enum rtx_code code_sat = UNKNOWN, int sign = 0)\n {\n   /* MODE of the operation.  */\n   enum machine_mode mode = GET_MODE (xop[0]);\n@@ -6026,6 +6029,41 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n   /* Value to add.  There are two ways to add VAL: R += VAL and R -= -VAL.  */\n   rtx xval = xop[2];\n \n+  /* Output a BRVC instruction.  Only needed with saturation.  */\n+  bool out_brvc = true;\n+\n+  if (plen)\n+    *plen = 0;\n+\n+  if (REG_P (xop[2]))\n+    {\n+      *pcc = MINUS == code ? (int) CC_SET_CZN : (int) CC_SET_N;\n+\n+      for (i = 0; i < n_bytes; i++)\n+        {\n+          /* We operate byte-wise on the destination.  */\n+          op[0] = simplify_gen_subreg (QImode, xop[0], mode, i);\n+          op[1] = simplify_gen_subreg (QImode, xop[2], mode, i);\n+\n+          if (i == 0)\n+            avr_asm_len (code == PLUS ? \"add %0,%1\" : \"sub %0,%1\",\n+                         op, plen, 1);\n+          else\n+            avr_asm_len (code == PLUS ? \"adc %0,%1\" : \"sbc %0,%1\",\n+                         op, plen, 1);\n+        }\n+\n+      if (reg_overlap_mentioned_p (xop[0], xop[2]))\n+        {\n+          gcc_assert (REGNO (xop[0]) == REGNO (xop[2]));\n+          \n+          if (MINUS == code)\n+            return;\n+        }\n+\n+      goto saturate;\n+    }\n+\n   /* Except in the case of ADIW with 16-bit register (see below)\n      addition does not set cc0 in a usable way.  */\n   \n@@ -6034,13 +6072,39 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n   if (CONST_FIXED_P (xval))\n     xval = avr_to_int_mode (xval);\n \n+  /* Adding/Subtracting zero is a no-op.  */\n+  \n+  if (xval == const0_rtx)\n+    {\n+      *pcc = CC_NONE;\n+      return;\n+    }\n+\n   if (MINUS == code)\n     xval = simplify_unary_operation (NEG, imode, xval, imode);\n \n   op[2] = xop[3];\n \n-  if (plen)\n-    *plen = 0;\n+  if (SS_PLUS == code_sat && MINUS == code\n+      && sign < 0\n+      && 0x80 == (INTVAL (simplify_gen_subreg (QImode, xval, imode, n_bytes-1))\n+                  & GET_MODE_MASK (QImode)))\n+    {\n+      /* We compute x + 0x80 by means of SUB instructions.  We negated the\n+         constant subtrahend above and are left with  x - (-128)  so that we\n+         need something like SUBI r,128 which does not exist because SUBI sets\n+         V according to the sign of the subtrahend.  Notice the only case\n+         where this must be done is when NEG overflowed in case [2s] because\n+         the V computation needs the right sign of the subtrahend.  */\n+      \n+      rtx msb = simplify_gen_subreg (QImode, xop[0], mode, n_bytes-1);\n+\n+      avr_asm_len (\"subi %0,128\" CR_TAB\n+                   \"brmi 0f\", &msb, plen, 2);\n+      out_brvc = false;\n+\n+      goto saturate;\n+    }\n \n   for (i = 0; i < n_bytes; i++)\n     {\n@@ -6082,7 +6146,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n                                op, plen, 1);\n \n                   if (n_bytes == 2 && PLUS == code)\n-                      *pcc = CC_SET_ZN;\n+                    *pcc = CC_SET_ZN;\n                 }\n \n               i++;\n@@ -6099,6 +6163,7 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n           continue;\n         }\n       else if ((val8 == 1 || val8 == 0xff)\n+               && UNKNOWN == code_sat\n                && !started\n                && i == n_bytes - 1)\n         {\n@@ -6111,7 +6176,17 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n         {\n         case PLUS:\n \n-          gcc_assert (plen != NULL || REG_P (op[2]));\n+          gcc_assert (plen != NULL || (op[2] && REG_P (op[2])));\n+\n+          if (plen != NULL && UNKNOWN != code_sat)\n+            {\n+              /* This belongs to the x + 0x80 corner case.  The code with\n+                 ADD instruction is not smaller, thus make this case\n+                 expensive so that the caller won't pick it.  */\n+\n+              *plen += 10;\n+              break;\n+            }\n \n           if (clobber_val != (int) val8)\n             avr_asm_len (\"ldi %2,%1\", op, plen, 1);\n@@ -6147,133 +6222,369 @@ avr_out_plus_1 (rtx *xop, int *plen, enum rtx_code code, int *pcc)\n \n     } /* for all sub-bytes */\n \n-  /* No output doesn't change cc0.  */\n-  \n-  if (plen && *plen == 0)\n-    *pcc = CC_NONE;\n-}\n+ saturate:\n \n+  if (UNKNOWN == code_sat)\n+    return;\n \n-/* Output addition of register XOP[0] and compile time constant XOP[2]:\n+  *pcc = (int) CC_CLOBBER;\n \n-      XOP[0] = XOP[0] + XOP[2]\n+  /* Vanilla addition/subtraction is done.  We are left with saturation.\n+     \n+     We have to compute  A = A <op> B  where  A  is a register and\n+     B is a register or a non-zero compile time constant CONST.\n+     A is register class \"r\" if unsigned && B is REG.  Otherwise, A is in \"d\".\n+     B stands for the original operand $2 in INSN.  In the case of B = CONST\n+     SIGN in { -1, 1 } is the sign of B.  Otherwise, SIGN is 0.\n+     \n+     CODE is the instruction flavor we use in the asm sequence to perform <op>.\n+     \n+     \n+     unsigned\n+     operation        |  code |  sat if  |    b is      | sat value |  case\n+     -----------------+-------+----------+--------------+-----------+-------\n+     +  as  a + b     |  add  |  C == 1  |  const, reg  | u+ = 0xff |  [1u]\n+     +  as  a - (-b)  |  sub  |  C == 0  |  const       | u+ = 0xff |  [2u]\n+     -  as  a - b     |  sub  |  C == 1  |  const, reg  | u- = 0    |  [3u]\n+     -  as  a + (-b)  |  add  |  C == 0  |  const       | u- = 0    |  [4u]\n+     \n+     \n+     signed\n+     operation        |  code |  sat if  |    b is      | sat value |  case\n+     -----------------+-------+----------+--------------+-----------+-------\n+     +  as  a + b     |  add  |  V == 1  |  const, reg  | s+        |  [1s]\n+     +  as  a - (-b)  |  sub  |  V == 1  |  const       | s+        |  [2s]\n+     -  as  a - b     |  sub  |  V == 1  |  const, reg  | s-        |  [3s]\n+     -  as  a + (-b)  |  add  |  V == 1  |  const       | s-        |  [4s]\n+     \n+     s+  =  b < 0  ?  -0x80 :  0x7f\n+     s-  =  b < 0  ?   0x7f : -0x80\n+     \n+     The cases a - b actually perform  a - (-(-b))  if B is CONST.\n+  */\n \n-   and return \"\".  If PLEN == NULL, print assembler instructions to perform the\n-   addition; otherwise, set *PLEN to the length of the instruction sequence (in\n-   words) printed with PLEN == NULL.\n-   If PCC != 0 then set *PCC to the the instruction sequence's effect on the\n-   condition code (with respect to XOP[0]).  */\n+  op[0] = simplify_gen_subreg (QImode, xop[0], mode, n_bytes-1);\n+  op[1] = n_bytes > 1\n+    ? simplify_gen_subreg (QImode, xop[0], mode, n_bytes-2)\n+    : NULL_RTX;\n \n-const char*\n-avr_out_plus (rtx *xop, int *plen, int *pcc)\n-{\n-  int len_plus, len_minus;\n-  int cc_plus, cc_minus, cc_dummy;\n+  if (!plen && flag_print_asm_name)\n+    avr_fdump (asm_out_file, \";; %C (%C)\\n\", code_sat, code);\n \n-  if (!pcc)\n-    pcc = &cc_dummy;\n-                                   \n-  /* Work out if  XOP[0] += XOP[2]  is better or  XOP[0] -= -XOP[2].  */\n+  bool need_copy = true;\n+  int len_call = 1 + AVR_HAVE_JMP_CALL;\n   \n-  avr_out_plus_1 (xop, &len_plus, PLUS, &cc_plus);\n-  avr_out_plus_1 (xop, &len_minus, MINUS, &cc_minus);\n+  switch (code_sat)\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case SS_PLUS:\n+    case SS_MINUS:\n+      if (!plen && flag_print_asm_name)\n+        avr_fdump (asm_out_file, \";; %s = %r\\n\", sign < 0 ? \"neg\" : \"pos\",\n+                   xop[2]);\n \n-  /* Prefer MINUS over PLUS if size is equal because it sets cc0.  */\n+      if (out_brvc)\n+        avr_asm_len (\"brvc 0f\", op, plen, 1);\n+\n+      if (reg_overlap_mentioned_p (xop[0], xop[2]))\n+        {\n+          /* [1s,reg] */\n+\n+          if (n_bytes == 1)\n+            avr_asm_len (\"ldi %0,0x7f\" CR_TAB\n+                         \"adc %0,__zero_reg__\", op, plen, 2);\n+          else\n+            avr_asm_len (\"ldi %0,0x7f\" CR_TAB\n+                         \"ldi %1,0xff\" CR_TAB\n+                         \"adc %1,__zero_reg__\" CR_TAB\n+                         \"adc %0,__zero_reg__\", op, plen, 4);\n+        }\n+      else if (sign == 0 && PLUS == code)\n+        {\n+          /* [1s,reg] */\n+\n+          op[2] = simplify_gen_subreg (QImode, xop[2], mode, n_bytes-1);\n+\n+          if (n_bytes == 1)\n+            avr_asm_len (\"ldi %0,0x80\" CR_TAB\n+                         \"sbrs %2,7\"   CR_TAB\n+                         \"dec %0\", op, plen, 3);\n+          else\n+            avr_asm_len (\"ldi %0,0x80\" CR_TAB\n+                         \"cp %2,%0\"    CR_TAB\n+                         \"sbc %1,%1\"   CR_TAB\n+                         \"sbci %0,0\", op, plen, 4);\n+        }\n+      else if (sign == 0 && MINUS == code)\n+        {\n+          /* [3s,reg] */\n+\n+          op[2] = simplify_gen_subreg (QImode, xop[2], mode, n_bytes-1);\n+\n+          if (n_bytes == 1)\n+            avr_asm_len (\"ldi %0,0x7f\" CR_TAB\n+                         \"sbrs %2,7\"   CR_TAB\n+                         \"inc %0\", op, plen, 3);\n+          else\n+            avr_asm_len (\"ldi %0,0x7f\" CR_TAB\n+                         \"cp %0,%2\"    CR_TAB\n+                         \"sbc %1,%1\"   CR_TAB\n+                         \"sbci %0,-1\", op, plen, 4);\n+        }\n+      else if ((sign < 0) ^ (SS_MINUS == code_sat))\n+        {\n+          /* [1s,const,B < 0] [2s,B < 0] */\n+          /* [3s,const,B > 0] [4s,B > 0] */\n+\n+          if (n_bytes == 8)\n+            {\n+              avr_asm_len (\"%~call __clr_8\", op, plen, len_call);\n+              need_copy = false;\n+            }\n+\n+          avr_asm_len (\"ldi %0,0x80\", op, plen, 1);\n+          if (n_bytes > 1 && need_copy)\n+            avr_asm_len (\"clr %1\", op, plen, 1);\n+        }\n+      else if ((sign > 0) ^ (SS_MINUS == code_sat))\n+        {\n+          /* [1s,const,B > 0] [2s,B > 0] */\n+          /* [3s,const,B < 0] [4s,B < 0] */\n+\n+          if (n_bytes == 8)\n+            {\n+              avr_asm_len (\"sec\" CR_TAB\n+                           \"%~call __sbc_8\", op, plen, 1 + len_call);\n+              need_copy = false;\n+            }\n+\n+          avr_asm_len (\"ldi %0,0x7f\", op, plen, 1);\n+          if (n_bytes > 1 && need_copy)\n+            avr_asm_len (\"ldi %1,0xff\", op, plen, 1);\n+        }\n+      else\n+        gcc_unreachable();\n+      \n+      break;\n+\n+    case US_PLUS:\n+      /* [1u] : [2u] */\n+      \n+      avr_asm_len (PLUS == code ? \"brcc 0f\" : \"brcs 0f\", op, plen, 1);\n+      \n+      if (n_bytes == 8)\n+        {\n+          if (MINUS == code)\n+            avr_asm_len (\"sec\", op, plen, 1);\n+          avr_asm_len (\"%~call __sbc_8\", op, plen, len_call);\n+\n+          need_copy = false;\n+        }\n+      else\n+        {\n+          if (MINUS == code && !test_hard_reg_class (LD_REGS, op[0]))\n+            avr_asm_len (\"sec\" CR_TAB \"sbc %0,%0\", op, plen, 2);\n+          else\n+            avr_asm_len (PLUS == code ? \"sbc %0,%0\" : \"ldi %0,0xff\",\n+                         op, plen, 1);\n+        }\n+      break; /* US_PLUS */\n+      \n+    case US_MINUS:\n+      /* [4u] : [3u] */\n+\n+      avr_asm_len (PLUS == code ? \"brcs 0f\" : \"brcc 0f\", op, plen, 1);\n+\n+      if (n_bytes == 8)\n+        {\n+          avr_asm_len (\"%~call __clr_8\", op, plen, len_call);\n+          need_copy = false;\n+        }\n+      else\n+        avr_asm_len (\"clr %0\", op, plen, 1);\n+      \n+      break;\n+    }\n+\n+  /* We set the MSB in the unsigned case and the 2 MSBs in the signed case.\n+     Now copy the right value to the LSBs.  */\n   \n-  if (plen)\n+  if (need_copy && n_bytes > 1)\n     {\n-      *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n-      *pcc  = (len_minus <= len_plus) ? cc_minus : cc_plus;\n+      if (US_MINUS == code_sat || US_PLUS == code_sat)\n+        {\n+          avr_asm_len (\"mov %1,%0\", op, plen, 1);\n+\n+          if (n_bytes > 2)\n+            {\n+              op[0] = xop[0];\n+              if (AVR_HAVE_MOVW)\n+                avr_asm_len (\"movw %0,%1\", op, plen, 1);\n+              else\n+                avr_asm_len (\"mov %A0,%1\" CR_TAB\n+                             \"mov %B0,%1\", op, plen, 2);\n+            }\n+        }\n+      else if (n_bytes > 2)\n+        {\n+          op[0] = xop[0];\n+          avr_asm_len (\"mov %A0,%1\" CR_TAB\n+                       \"mov %B0,%1\", op, plen, 2);\n+        }\n     }\n-  else if (len_minus <= len_plus)\n-    avr_out_plus_1 (xop, NULL, MINUS, pcc);\n-  else\n-    avr_out_plus_1 (xop, NULL, PLUS, pcc);\n \n-  return \"\";\n+  if (need_copy && n_bytes == 8)\n+    {\n+      if (AVR_HAVE_MOVW)\n+        avr_asm_len (\"movw %r0+2,%0\" CR_TAB\n+                     \"movw %r0+4,%0\", xop, plen, 2);\n+      else\n+        avr_asm_len (\"mov %r0+2,%0\" CR_TAB\n+                     \"mov %r0+3,%0\" CR_TAB\n+                     \"mov %r0+4,%0\" CR_TAB\n+                     \"mov %r0+5,%0\", xop, plen, 4);\n+    }\n+\n+  avr_asm_len (\"0:\", op, plen, 0);\n }\n \n \n-/* Same as above but XOP has just 3 entries.\n-   Supply a dummy 4th operand.  */\n+/* Output addition/subtraction of register XOP[0] and a constant XOP[2] that\n+   is ont a compile-time constant:\n \n-const char*\n-avr_out_plus_noclobber (rtx *xop, int *plen, int *pcc)\n+      XOP[0] = XOP[0] +/- XOP[2]\n+\n+   This is a helper for the function below.  The only insns that need this\n+   are additions/subtraction for pointer modes, i.e. HImode and PSImode.  */\n+\n+static const char*\n+avr_out_plus_symbol (rtx *xop, enum rtx_code code, int *plen, int *pcc)\n {\n-  rtx op[4];\n+  enum machine_mode mode = GET_MODE (xop[0]);\n+  int n_bytes = GET_MODE_SIZE (mode);\n \n-  op[0] = xop[0];\n-  op[1] = xop[1];\n-  op[2] = xop[2];\n-  op[3] = NULL_RTX;\n+  /* Only pointer modes want to add symbols.  */\n+  \n+  gcc_assert (mode == HImode || mode == PSImode);\n \n-  return avr_out_plus (op, plen, pcc);\n+  *pcc = MINUS == code ? (int) CC_SET_CZN : (int) CC_SET_N;\n+\n+  avr_asm_len (PLUS == code\n+               ? \"subi %A0,lo8(-(%2))\" CR_TAB \"sbci %B0,hi8(-(%2))\"\n+               : \"subi %A0,lo8(%2)\"    CR_TAB \"sbci %B0,hi8(%2)\",\n+               xop, plen, -2);\n+\n+  if (3 == n_bytes)\n+    avr_asm_len (PLUS == code\n+                 ? \"sbci %C0,hlo8((-%2))\"\n+                 : \"sbci %C0,hlo8(%2)\", xop, plen, 1);\n+  return \"\";\n }\n \n \n-/* Output subtraction of register XOP[0] and compile time constant XOP[2]:\n+/* Prepare operands of addition/subtraction to be used with avr_out_plus_1.\n+   \n+   INSN is a single_set insn with a binary operation as SET_SRC that is\n+   one of:  PLUS, SS_PLUS, US_PLUS, MINUS, SS_MINUS, US_MINUS.\n+\n+   XOP are the operands of INSN.  In the case of 64-bit operations with\n+   constant XOP[] has just one element:  The summand/subtrahend in XOP[0].\n+   The non-saturating insns up to 32 bits may or may not supply a \"d\" class\n+   scratch as XOP[3].\n+\n+   If PLEN == NULL output the instructions.\n+   If PLEN != NULL set *PLEN to the length of the sequence in words.\n \n-      XOP[0] = XOP[0] - XOP[2]\n+   PCC is a pointer to store the instructions' effect on cc0.\n+   PCC may be NULL.\n \n-   This is basically the same as `avr_out_plus' except that we subtract.\n-   It's needed because (minus x const) is not mapped to (plus x -const)\n-   for the fixed point modes.  */\n+   PLEN and PCC default to NULL.\n+\n+   Return \"\"  */\n \n const char*\n-avr_out_minus (rtx *xop, int *plen, int *pcc)\n+avr_out_plus (rtx insn, rtx *xop, int *plen, int *pcc)\n {\n+  int cc_plus, cc_minus, cc_dummy;\n+  int len_plus, len_minus;\n   rtx op[4];\n+  rtx xdest = SET_DEST (single_set (insn));\n+  enum machine_mode mode = GET_MODE (xdest);\n+  enum machine_mode imode = int_mode_for_mode (mode);\n+  int n_bytes = GET_MODE_SIZE (mode);\n+  enum rtx_code code_sat = GET_CODE (SET_SRC (single_set (insn)));\n+  enum rtx_code code\n+    = (PLUS == code_sat || SS_PLUS == code_sat || US_PLUS == code_sat\n+       ? PLUS : MINUS);\n \n-  if (pcc)\n-    *pcc = (int) CC_SET_CZN;\n-\n-  if (REG_P (xop[2]))\n-    return avr_asm_len (\"sub %A0,%A2\" CR_TAB\n-                        \"sbc %B0,%B2\", xop, plen, -2);\n+  if (!pcc)\n+    pcc = &cc_dummy;\n \n-  if (!CONST_INT_P (xop[2])\n-      && !CONST_FIXED_P (xop[2]))\n-    return avr_asm_len (\"subi %A0,lo8(%2)\" CR_TAB\n-                        \"sbci %B0,hi8(%2)\", xop, plen, -2);\n+  /* PLUS and MINUS don't saturate:  Use modular wrap-around.  */\n   \n-  op[0] = avr_to_int_mode (xop[0]);\n-  op[1] = avr_to_int_mode (xop[1]);\n-  op[2] = gen_int_mode (-INTVAL (avr_to_int_mode (xop[2])),\n-                        GET_MODE (op[0]));\n-  op[3] = xop[3];\n+  if (PLUS == code_sat || MINUS == code_sat)\n+    code_sat = UNKNOWN;\n \n-  return avr_out_plus (op, plen, pcc);\n-}\n+  if (n_bytes <= 4 && REG_P (xop[2]))\n+    {\n+      avr_out_plus_1 (xop, plen, code, pcc, code_sat);\n+      return \"\";\n+    }\n \n+  if (8 == n_bytes)\n+    {\n+      op[0] = gen_rtx_REG (DImode, ACC_A);\n+      op[1] = gen_rtx_REG (DImode, ACC_A);\n+      op[2] = avr_to_int_mode (xop[0]);\n+    }\n+  else\n+    {\n+      if (!REG_P (xop[2])\n+          && !CONST_INT_P (xop[2])\n+          && !CONST_FIXED_P (xop[2]))\n+        {\n+          return avr_out_plus_symbol (xop, code, plen, pcc);\n+        }\n+      \n+      op[0] = avr_to_int_mode (xop[0]);\n+      op[1] = avr_to_int_mode (xop[1]);\n+      op[2] = avr_to_int_mode (xop[2]);\n+    }\n \n-/* Prepare operands of adddi3_const_insn to be used with avr_out_plus_1.  */\n+  /* Saturations and 64-bit operations don't have a clobber operand.\n+     For the other cases, the caller will provide a proper XOP[3].  */\n+  \n+  op[3] = PARALLEL == GET_CODE (PATTERN (insn)) ? xop[3] : NULL_RTX;\n \n-const char*\n-avr_out_plus64 (rtx addend, int *plen)\n-{\n-  int cc_dummy;\n-  rtx op[4];\n+  /* Saturation will need the sign of the original operand.  */\n \n-  op[0] = gen_rtx_REG (DImode, 18);\n-  op[1] = op[0];\n-  op[2] = addend;\n-  op[3] = NULL_RTX;\n+  rtx xmsb = simplify_gen_subreg (QImode, op[2], imode, n_bytes-1);\n+  int sign = INTVAL (xmsb) < 0 ? -1 : 1;\n \n-  avr_out_plus_1 (op, plen, MINUS, &cc_dummy);\n+  /* If we subtract and the subtrahend is a constant, then negate it\n+     so that avr_out_plus_1 can be used.  */\n \n-  return \"\";\n-}\n+  if (MINUS == code)\n+    op[2] = simplify_unary_operation (NEG, imode, op[2], imode);\n \n+  /* Work out the shortest sequence.  */\n \n-/* Prepare operands of subdi3_const_insn to be used with avr_out_plus64.  */\n+  avr_out_plus_1 (op, &len_minus, MINUS, &cc_plus, code_sat, sign);\n+  avr_out_plus_1 (op, &len_plus, PLUS, &cc_minus, code_sat, sign);\n \n-const char*\n-avr_out_minus64 (rtx subtrahend, int *plen)\n-{\n-  rtx xneg = avr_to_int_mode (subtrahend);\n-  xneg = simplify_unary_operation (NEG, DImode, xneg, DImode);\n+  if (plen)\n+    {\n+      *plen = (len_minus <= len_plus) ? len_minus : len_plus;\n+      *pcc  = (len_minus <= len_plus) ? cc_minus : cc_plus;\n+    }\n+  else if (len_minus <= len_plus)\n+    avr_out_plus_1 (op, NULL, MINUS, pcc, code_sat, sign);\n+  else\n+    avr_out_plus_1 (op, NULL, PLUS, pcc, code_sat, sign);\n \n-  return avr_out_plus64 (xneg, plen);\n+  return \"\";\n }\n \n \n@@ -7004,13 +7315,7 @@ adjust_insn_length (rtx insn, int len)\n       \n     case ADJUST_LEN_OUT_BITOP: avr_out_bitop (insn, op, &len); break;\n       \n-    case ADJUST_LEN_OUT_PLUS: avr_out_plus (op, &len, NULL); break;\n-    case ADJUST_LEN_PLUS64: avr_out_plus64 (op[0], &len); break;\n-    case ADJUST_LEN_MINUS: avr_out_minus (op, &len, NULL); break;\n-    case ADJUST_LEN_MINUS64: avr_out_minus64 (op[0], &len); break;\n-    case ADJUST_LEN_OUT_PLUS_NOCLOBBER:\n-      avr_out_plus_noclobber (op, &len, NULL); break;\n-\n+    case ADJUST_LEN_PLUS: avr_out_plus (insn, op, &len); break;\n     case ADJUST_LEN_ADDTO_SP: avr_out_addto_sp (op, &len); break;\n       \n     case ADJUST_LEN_MOV8:  output_movqi (insn, op, &len); break;\n@@ -8897,8 +9202,8 @@ avr_rtx_costs (rtx x, int codearg, int outer_code,\n \n static int\n avr_address_cost (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t  addr_space_t as ATTRIBUTE_UNUSED,\n-\t\t  bool speed ATTRIBUTE_UNUSED)\n+                  addr_space_t as ATTRIBUTE_UNUSED,\n+                  bool speed ATTRIBUTE_UNUSED)\n {\n   int cost = 4;\n   "}, {"sha": "8b13010e700908b8dc15ee8aab1558f5a96550e7", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 35, "deletions": 51, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -91,7 +91,7 @@\n \n ;; Condition code settings.\n (define_attr \"cc\" \"none,set_czn,set_zn,set_n,compare,clobber,\n-                   out_plus, out_plus_noclobber,ldi,minus\"\n+                   plus,ldi\"\n   (const_string \"none\"))\n \n (define_attr \"type\" \"branch,branch1,arith,xcall\"\n@@ -138,8 +138,7 @@\n ;; Otherwise do special processing depending on the attribute.\n \n (define_attr \"adjust_len\"\n-  \"out_bitop, out_plus, out_plus_noclobber, plus64, addto_sp,\n-   minus, minus64,\n+  \"out_bitop, plus, addto_sp,\n    tsthi, tstpsi, tstsi, compare, compare64, call,\n    mov8, mov16, mov24, mov32, reload_in16, reload_in24, reload_in32,\n    ufract, sfract,\n@@ -250,6 +249,10 @@\n (define_code_iterator xior [xor ior])\n (define_code_iterator eqne [eq ne])\n \n+(define_code_iterator ss_addsub [ss_plus ss_minus])\n+(define_code_iterator us_addsub [us_plus us_minus])\n+(define_code_iterator ss_abs_neg [ss_abs ss_neg])\n+\n ;; Define code attributes\n (define_code_attr extend_su\n   [(sign_extend \"s\")\n@@ -268,14 +271,21 @@\n   [(zero_extend \"r\")\n    (sign_extend \"d\")])\n \n+(define_code_attr abelian\n+  [(ss_minus \"\") (us_minus \"\")\n+   (ss_plus \"%\") (us_plus \"%\")])\n+\n ;; Map RTX code to its standard insn name\n (define_code_attr code_stdname\n   [(ashift   \"ashl\")\n    (ashiftrt \"ashr\")\n    (lshiftrt \"lshr\")\n    (ior      \"ior\")\n    (xor      \"xor\")\n-   (rotate   \"rotl\")])\n+   (rotate   \"rotl\")\n+   (ss_plus  \"ssadd\")  (ss_minus \"sssub\")  (ss_neg \"ssneg\")  (ss_abs \"ssabs\")\n+   (us_plus  \"usadd\")  (us_minus \"ussub\")  (us_neg \"usneg\")\n+   ])\n \n ;;========================================================================\n ;; The following is used by nonlocal_goto and setjmp.\n@@ -1181,17 +1191,11 @@\n                    (match_operand:ALL2 2 \"nonmemory_or_const_operand\" \"r,s,IJ YIJ,n Ynn\")))]\n   \"\"\n   {\n-    if (REG_P (operands[2]))\n-      return \"add %A0,%A2\\;adc %B0,%B2\";\n-    else if (CONST_INT_P (operands[2])\n-             || CONST_FIXED == GET_CODE (operands[2]))\n-      return avr_out_plus_noclobber (operands, NULL, NULL);\n-    else\n-      return \"subi %A0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\";\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"length\" \"2,2,2,2\")\n-   (set_attr \"adjust_len\" \"*,*,out_plus_noclobber,out_plus_noclobber\")\n-   (set_attr \"cc\" \"set_n,set_czn,out_plus_noclobber,out_plus_noclobber\")])\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n ;; Adding a constant to NO_LD_REGS might have lead to a reload of\n ;; that constant to LD_REGS.  We don't add a scratch to *addhi3\n@@ -1238,13 +1242,11 @@\n    (clobber (match_scratch:QI 3                             \"=X     ,X    ,&d\"))]\n   \"\"\n   {\n-    gcc_assert (REGNO (operands[0]) == REGNO (operands[1]));\n-    \n-    return avr_out_plus (operands, NULL, NULL);\n+    return avr_out_plus (insn, operands);\n   }\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"adjust_len\" \"out_plus\")\n-   (set_attr \"cc\" \"out_plus\")])\n+   (set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n \n ;; \"addsi3\"\n@@ -1257,14 +1259,11 @@\n    (clobber (match_scratch:QI 3                             \"=X,X ,&d\"))]\n   \"\"\n   {\n-    if (REG_P (operands[2]))\n-      return \"add %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\\;adc %D0,%D2\";\n-\n-    return avr_out_plus (operands, NULL, NULL);\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"length\" \"4,4,8\")\n-   (set_attr \"adjust_len\" \"*,out_plus,out_plus\")\n-   (set_attr \"cc\" \"set_n,out_plus,out_plus\")])\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n (define_insn \"*addpsi3_zero_extend.qi\"\n   [(set (match_operand:PSI 0 \"register_operand\"                          \"=r\")\n@@ -1318,22 +1317,11 @@\n    (clobber (match_scratch:QI 3                           \"=X,X ,X,&d\"))]\n   \"\"\n   {\n-    static const char * const asm_code[] =\n-      {\n-        \"add %A0,%A2\\;adc %B0,%B2\\;adc %C0,%C2\",\n-        \"subi %0,lo8(-(%2))\\;sbci %B0,hi8(-(%2))\\;sbci %C0,hlo8(-(%2))\",\n-        \"\",\n-        \"\"\n-      };\n-\n-    if (*asm_code[which_alternative])\n-      return asm_code[which_alternative];\n-\n-    return avr_out_plus (operands, NULL, NULL);\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"length\" \"3,3,3,6\")\n-   (set_attr \"adjust_len\" \"*,*,out_plus,out_plus\")\n-   (set_attr \"cc\" \"set_n,set_czn,out_plus,out_plus\")])\n+  [(set_attr \"length\" \"3\")\n+   (set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n (define_insn \"subpsi3\"\n   [(set (match_operand:PSI 0 \"register_operand\"           \"=r\")\n@@ -1401,10 +1389,10 @@\n    (clobber (match_scratch:QI 3                                       \"=X,X    ,&d\"))]\n   \"\"\n   {\n-    return avr_out_minus (operands, NULL, NULL);\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"adjust_len\" \"minus\")\n-   (set_attr \"cc\" \"minus\")])\n+  [(set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n (define_insn \"*subhi3_zero_extend1\"\n   [(set (match_operand:HI 0 \"register_operand\"                          \"=r\")\n@@ -1438,14 +1426,10 @@\n    (clobber (match_scratch:QI 3                                       \"=X,X    ,&d\"))]\n   \"\"\n   {\n-    if (REG_P (operands[2]))\n-      return \"sub %0,%2\\;sbc %B0,%B2\\;sbc %C0,%C2\\;sbc %D0,%D2\";\n-    \n-    return avr_out_minus (operands, NULL, NULL);\n+    return avr_out_plus (insn, operands);\n   }\n-  [(set_attr \"length\" \"4\")\n-   (set_attr \"adjust_len\" \"*,minus,minus\")\n-   (set_attr \"cc\" \"set_czn\")])\n+  [(set_attr \"adjust_len\" \"plus\")\n+   (set_attr \"cc\" \"plus\")])\n \n (define_insn \"*subsi3_zero_extend\"\n   [(set (match_operand:SI 0 \"register_operand\"                          \"=r\")"}, {"sha": "89b65e035b22f4d712f65566f74244cc0fe18b50", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -1,3 +1,24 @@\n+2012-09-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* gcc.target/avr/torture/fix-types.h: New.\n+\t* gcc.target/avr/torture/vals-hr.def: New.\n+\t* gcc.target/avr/torture/vals-r.def: New.\n+\t* gcc.target/avr/torture/vals-k.def: New.\n+\t* gcc.target/avr/torture/vals-ur.def: New.\n+\t* gcc.target/avr/torture/vals-uk.def: New.\n+\t* gcc.target/avr/torture/vals-uhr.def: New.\n+\t* gcc.target/avr/torture/vals-llk.def: New.\n+\t* gcc.target/avr/torture/vals-ullk.def: New.\n+\t* gcc.target/avr/torture/sat-hr-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-r-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-k-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-ur-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-uk-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-uhr-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-llk-plus-minus.c: New.\n+\t* gcc.target/avr/torture/sat-ullk-plus-minus.c: New.\n+\n 2012-09-14  Dehao Chen  <dehao@google.com>\n \n \t* g++.dg/debug/dwarf2/deallocator.C: New test."}, {"sha": "f6a2aeb6fa213375c990b8b06df8b1f71674267c", "filename": "gcc/testsuite/gcc.target/avr/torture/fix-types.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ffix-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ffix-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Ffix-types.h?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,134 @@\n+typedef __INT8_TYPE__  int_hr_t;\n+typedef __UINT8_TYPE__ int_uhr_t;\n+\n+typedef __INT16_TYPE__  int_hk_t;\n+typedef __UINT16_TYPE__ int_uhk_t;\n+typedef __INT16_TYPE__  int_r_t;\n+typedef __UINT16_TYPE__ int_ur_t;\n+\n+typedef __INT32_TYPE__  int_k_t;\n+typedef __UINT32_TYPE__ int_uk_t;\n+typedef __INT32_TYPE__  int_lr_t;\n+typedef __UINT32_TYPE__ int_ulr_t;\n+\n+typedef __INT64_TYPE__  int_lk_t;\n+typedef __UINT64_TYPE__ int_ulk_t;\n+typedef __INT64_TYPE__  int_llr_t;\n+typedef __UINT64_TYPE__ int_ullr_t;\n+typedef __INT64_TYPE__  int_llk_t;\n+typedef __UINT64_TYPE__ int_ullk_t;\n+\n+typedef __INT16_TYPE__  xint_hr_t;\n+typedef __UINT16_TYPE__ xint_uhr_t;\n+\n+typedef __INT32_TYPE__  xint_hk_t;\n+typedef __UINT32_TYPE__ xint_uhk_t;\n+typedef __INT32_TYPE__  xint_r_t;\n+typedef __UINT32_TYPE__ xint_ur_t;\n+\n+typedef __INT64_TYPE__  xint_k_t;\n+typedef __UINT64_TYPE__ xint_uk_t;\n+typedef __INT64_TYPE__  xint_lr_t;\n+typedef __UINT64_TYPE__ xint_ulr_t;\n+\n+#define INThr_MAX __INT8_MAX__\n+#define INThr_MIN (-__INT8_MAX__-1)\n+#define INTuhr_MAX __UINT8_MAX__\n+\n+#define INTr_MAX __INT16_MAX__\n+#define INTr_MIN (-__INT16_MAX__-1)\n+#define INTur_MAX __UINT16_MAX__\n+\n+#define INThk_MAX __INT16_MAX__\n+#define INThk_MIN (-__INT16_MAX__-1)\n+#define INTuhk_MAX __UINT16_MAX__\n+\n+#define INTlr_MAX __INT32_MAX__\n+#define INTlr_MIN (-__INT32_MAX__-1)\n+#define INTulr_MAX __UINT32_MAX__\n+\n+#define INTk_MAX __INT32_MAX__\n+#define INTk_MIN (-__INT32_MAX__-1)\n+#define INTuk_MAX __UINT32_MAX__\n+\n+#define INTlk_MAX __INT64_MAX__\n+#define INTlk_MIN (-__INT64_MAX__-1)\n+#define INTulk_MAX __UINT64_MAX__\n+\n+#define INTllk_MAX __INT64_MAX__\n+#define INTllk_MIN (-__INT64_MAX__-1)\n+#define INTullk_MAX __UINT64_MAX__\n+\n+#define SS_FUN(NAME, OP, T, FX)                 \\\n+  T __attribute__((noinline,noclone))           \\\n+  NAME##_##FX (T fa, T fb)                      \\\n+  {                                             \\\n+    int_##FX##_t ia;                            \\\n+    int_##FX##_t ib;                            \\\n+    xint_##FX##_t ic;                           \\\n+    __builtin_memcpy (&ia, &fa, sizeof (ia));   \\\n+    __builtin_memcpy (&ib, &fb, sizeof (ib));   \\\n+    ic = (xint_##FX##_t) ia OP ib;              \\\n+    if (ic > INT##FX##_MAX)                     \\\n+      ic = INT##FX##_MAX;                       \\\n+    else if (ic < INT##FX##_MIN)                \\\n+      ic = INT##FX##_MIN;                       \\\n+    ia = (int_##FX##_t) ic;                     \\\n+    __builtin_memcpy (&fa, &ia, sizeof (ia));   \\\n+    return fa;                                  \\\n+  }\n+\n+#define US_FUN(NAME, OP, T, FX)                 \\\n+  T __attribute__((noinline,noclone))           \\\n+  NAME##_##FX (T fa, T fb)                      \\\n+  {                                             \\\n+    int_##FX##_t ia;                            \\\n+    int_##FX##_t ib;                            \\\n+    xint_##FX##_t ic;                           \\\n+    __builtin_memcpy (&ia, &fa, sizeof (ia));   \\\n+    __builtin_memcpy (&ib, &fb, sizeof (ib));   \\\n+    ic = (xint_##FX##_t) ia OP ib;              \\\n+    if (ic > INT##FX##_MAX)                     \\\n+      ic = INT##FX##_MAX;                       \\\n+    else if (ic < 0)                            \\\n+      ic = 0;                                   \\\n+    ia = (int_##FX##_t) ic;                     \\\n+    __builtin_memcpy (&fa, &ia, sizeof (ia));   \\\n+    return fa;                                  \\\n+  }\n+\n+#define SS_LFUN(NAME, OP, T, FX, CMP)           \\\n+  T __attribute__((noinline,noclone))           \\\n+  NAME##_##FX (T fa, T fb)                      \\\n+  {                                             \\\n+    int_##FX##_t ia;                            \\\n+    int_##FX##_t ib;                            \\\n+    int_##FX##_t ic;                            \\\n+    __builtin_memcpy (&ia, &fa, sizeof (ia));   \\\n+    __builtin_memcpy (&ib, &fb, sizeof (ib));   \\\n+    ic = (int_##FX##_t) ia OP ib;               \\\n+    if (ic < ia && ib CMP 0)                    \\\n+      ic = INT##FX##_MAX;                       \\\n+    else if (ic > ia && 0 CMP ib)               \\\n+      ic = INT##FX##_MIN;                       \\\n+    __builtin_memcpy (&fa, &ic, sizeof (ic));   \\\n+    return fa;                                  \\\n+  }\n+\n+#define US_LFUN(NAME, OP, T, FX, CMP)           \\\n+  T __attribute__((noinline,noclone))           \\\n+  NAME##_##FX (T fa, T fb)                      \\\n+  {                                             \\\n+    int_##FX##_t ia;                            \\\n+    int_##FX##_t ib;                            \\\n+    int_##FX##_t ic;                            \\\n+    __builtin_memcpy (&ia, &fa, sizeof (ia));   \\\n+    __builtin_memcpy (&ib, &fb, sizeof (ib));   \\\n+    ic = (int_##FX##_t) ia OP ib;               \\\n+    if (ia CMP ic && 1 CMP 0)                   \\\n+      ic = INT##FX##_MAX;                       \\\n+    if (ia CMP ic && 0 CMP 1)                   \\\n+      ic = 0;                                   \\\n+    __builtin_memcpy (&fa, &ic, sizeof (ic));   \\\n+    return fa;                                  \\\n+  }"}, {"sha": "1e6215e4f4171f0996f2b4c07ce8851658e2b0ca", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-hr-plus-minus.c", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-hr-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-hr-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-hr-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,98 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef short _Fract fx_t;\n+typedef short _Sat _Fract satfx_t;\n+typedef char intfx_t;\n+\n+SS_FUN (ss_add, +, fx_t, hr)\n+SS_FUN (ss_sub, -, fx_t, hr)\n+\n+#define VAL(N, X)                               \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t ss_add2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return ss_add_hr (a, X##P##-##7hr);     \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t ss_add_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a + X##P##-##7hr;                \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t ss_sub2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return ss_sub_hr (a, X##P##-##7hr);     \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t ss_sub_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a - X##P##-##7hr;                \\\n+    }\n+#include \"vals-hr.def\"\n+#undef VAL\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add2_99 (satfx_t a)\n+{\n+  return ss_add_hr (a, __FRACT_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add_99 (satfx_t a)\n+{\n+  return a + __FRACT_MIN__;\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub2_99 (satfx_t a)\n+{\n+  return ss_sub_hr (a, __FRACT_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub_99 (satfx_t a)\n+{\n+  return a - __FRACT_MIN__;\n+}\n+\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  ss_add_##N, ss_add2_##N,                      \\\n+  ss_sub_##N, ss_sub2_##N,\n+#include \"vals-hr.def\"\n+  VAL (99,)\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, 1, 2, 0x7f, 0x80, 0x81, 0xff,\n+    0x40, 0x3e, 0x3f, 0xbf, 0xc0, 0xc1\n+  };\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "8a26ffeeb3e99efde4d5a27777ba397d30265371", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-k-plus-minus.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-k-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-k-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-k-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef _Accum fx_t;\n+typedef _Sat _Accum satfx_t;\n+typedef long intfx_t;\n+\n+SS_FUN (ss_add, +, fx_t, k)\n+SS_FUN (ss_sub, -, fx_t, k)\n+\n+#define VAL(N, X)                               \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_add_k (a, X##P##-##16k);          \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a + X##P##-##16k;                    \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_sub_k (a, X##P##-##16k);          \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a - X##P##-##16k;                    \\\n+  }\n+#include \"vals-k.def\"\n+#undef VAL\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add2_99 (satfx_t a)\n+{\n+  return ss_add_k (a, __ACCUM_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add_99 (satfx_t a)\n+{\n+  return a + __ACCUM_MIN__;\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub2_99 (satfx_t a)\n+{\n+  return ss_sub_k (a, __ACCUM_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub_99 (satfx_t a)\n+{\n+  return a - __ACCUM_MIN__;\n+}\n+\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  ss_add_##N, ss_add2_##N,                      \\\n+  ss_sub_##N, ss_sub2_##N,\n+#include \"vals-k.def\"\n+  VAL (99,)\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x40000000, 0x3e800000, 0x3f800000,\n+    0x7ffffffe, 0x7fffffff, 0x7f800000,\n+    0x7f7f7f7f, 0x7f810080, 0x7f008000,\n+    0x7f000001,\n+    0x80000000, 0x80000001, 0x80808080,\n+    0x80810000, 0x80ffffff, 0x80fffffe,\n+    0x81000000, 0x81800000, 0x81800000,\n+    0xff000000, 0xffffff01, 0xffffff80,\n+    0xffffff7f, 0xff80ff80\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "e81cbb187e0f98571764d17fd4d5729796d17854", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-llk-plus-minus.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-llk-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-llk-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-llk-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,108 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef long long _Accum fx_t;\n+typedef long long _Sat _Accum satfx_t;\n+typedef long long intfx_t;\n+\n+SS_LFUN (ss_add, +, fx_t, llk, >)\n+SS_LFUN (ss_sub, -, fx_t, llk, <)\n+\n+#define VAL(N, X)                               \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_add_llk (a, X##P##-##48llk);      \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a + X##P##-##48llk;                  \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_sub_llk (a, X##P##-##48llk);      \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a - X##P##-##48llk;                  \\\n+  }\n+#include \"vals-llk.def\"\n+#undef VAL\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add2_99 (satfx_t a)\n+{\n+  return ss_add_llk (a, __LLACCUM_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add_99 (satfx_t a)\n+{\n+  return a + __LLACCUM_MIN__;\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub2_99 (satfx_t a)\n+{\n+  return ss_sub_llk (a, __LLACCUM_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub_99 (satfx_t a)\n+{\n+  return a - __LLACCUM_MIN__;\n+}\n+\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  ss_add_##N, ss_add2_##N,                      \\\n+  ss_sub_##N, ss_sub2_##N,\n+#include \"vals-llk.def\"\n+  VAL (99,)\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x4000000000000000, 0x3e80000000000000, 0x3f80000000000000,\n+    0x7ffffffffffffffe, 0x7fffffffffffffff, 0x7f80000000000000,\n+    0x7f7f7f7f7f7f7f7f, 0x7f81000000000080, 0x7f00000080000000,\n+    0x7f00000000000001,\n+    0x8000000000000000, 0x8000000000000001, 0x8080808080808080,\n+    0x8081000000000000, 0x80ffffffffffffff, 0x80fffffffffffffe,\n+    0x8100000000000000, 0x8180000000000000, 0x818000000000000,\n+    0xff00000000000000, 0xffffffffffffff01, 0xffffffffffffff80,\n+    0xffffffffffffff7f, 0xff80ff80ff80ff80\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "e59bcf655ab499eeac1709bf07cf3dc7b581c0ff", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-r-plus-minus.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-r-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-r-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-r-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,107 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef _Fract fx_t;\n+typedef _Sat _Fract satfx_t;\n+typedef int intfx_t;\n+\n+SS_FUN (ss_add, +, fx_t, r)\n+SS_FUN (ss_sub, -, fx_t, r)\n+\n+#define VAL(N, X)                               \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_add_r (a, X##P##-##15r);          \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_add_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a + X##P##-##15r;                    \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return ss_sub_r (a, X##P##-##15r);          \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t ss_sub_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a - X##P##-##15r;                    \\\n+  }\n+#include \"vals-r.def\"\n+#undef VAL\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add2_99 (satfx_t a)\n+{\n+  return ss_add_r (a, __FRACT_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_add_99 (satfx_t a)\n+{\n+  return a + __FRACT_MIN__;\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub2_99 (satfx_t a)\n+{\n+  return ss_sub_r (a, __FRACT_MIN__);\n+}\n+\n+__attribute__((noinline,noclone))\n+satfx_t ss_sub_99 (satfx_t a)\n+{\n+  return a - __FRACT_MIN__;\n+}\n+\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  ss_add_##N, ss_add2_##N,                      \\\n+  ss_sub_##N, ss_sub2_##N,\n+#include \"vals-r.def\"\n+  VAL (99,)\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x4000, 0x3e80, 0x3f80,\n+    0x7ffe, 0x7fff,\n+    0x7f7f, 0x7f81, 0x7f80,\n+    0x7f01,\n+    0x8000, 0x8001, 0x8080,\n+    0x8081, 0x80ff, 0x80fe,\n+    0x8100, 0x8180, 0x817f,\n+    0xff00, 0xff01, 0xff01,\n+    0xff7f, 0xff80\n+  };\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "6dd191f7ac3fa6c46fb6d7d853f05aba753e682d", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-uhr-plus-minus.c", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uhr-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uhr-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uhr-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,73 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef unsigned short _Fract fx_t;\n+typedef unsigned short _Sat _Fract satfx_t;\n+typedef unsigned char intfx_t;\n+\n+US_LFUN (us_add, +, fx_t, uhr, >)\n+US_LFUN (us_sub, -, fx_t, uhr, <)\n+\n+#define VAL(N, X)                               \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_add2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return us_add_uhr (a, X##P##-##8uhr);       \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_add_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a + X##P##-##8uhr;                   \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_sub2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return us_sub_uhr (a, X##P##-##8uhr);       \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_sub_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a - X##P##-##8uhr;                   \\\n+  }\n+#include \"vals-uhr.def\"\n+#undef VAL\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  us_add_##N, us_add2_##N,                      \\\n+  us_sub_##N, us_sub2_##N,\n+#include \"vals-uhr.def\"\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, 1, 2, 0x7f, 0x80, 0x81, 0xff,\n+    0x40, 0x3e, 0x3f, 0xbf, 0xc0, 0xc1\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "c9a7cd6ba4d2f2d1d577b8deb357f6f99301b5a0", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-uk-plus-minus.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uk-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uk-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-uk-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef unsigned _Accum fx_t;\n+typedef unsigned _Sat _Accum satfx_t;\n+typedef unsigned long intfx_t;\n+\n+US_LFUN (us_add, +, fx_t, uk, >)\n+US_LFUN (us_sub, -, fx_t, uk, <)\n+\n+#define VAL(N, X)                               \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_add2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return us_add_uk (a, X##P##-##16uk);    \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_add_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a + X##P##-##16uk;               \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_sub2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return us_sub_uk (a, X##P##-##16uk);    \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_sub_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a - X##P##-##16uk;               \\\n+    }\n+#include \"vals-uk.def\"\n+#undef VAL\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  us_add_##N, us_add2_##N,                      \\\n+  us_sub_##N, us_sub2_##N,\n+#include \"vals-uk.def\"\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x40000000, 0x3e800000, 0x3f800000,\n+    0x7ffffffe, 0x7fffffff, 0x7f800000,\n+    0x7f7f7f7f, 0x7f810080, 0x7f008000,\n+    0x7f000001,\n+    0x80000000, 0x80000001, 0x80808080,\n+    0x80810000, 0x80ffffff, 0x80fffffe,\n+    0x81000000, 0x81800000, 0x81800000,\n+    0xff000000, 0xffffff01, 0xffffff80,\n+    0xffffff7f, 0xff80ff80\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "22ebb8af50faf60c252fffa506939cf308bfaa89", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-ullk-plus-minus.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ullk-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ullk-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ullk-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef unsigned long long _Accum fx_t;\n+typedef unsigned long long _Sat _Accum satfx_t;\n+typedef unsigned long long intfx_t;\n+\n+US_LFUN (us_add, +, fx_t, ullk, >)\n+US_LFUN (us_sub, -, fx_t, ullk, <)\n+\n+#define VAL(N, X)                               \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_add2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return us_add_ullk (a, X##P##-##48ullk);    \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_add_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a + X##P##-##48ullk;                 \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_sub2_##N (satfx_t a)               \\\n+  {                                             \\\n+    return us_sub_ullk (a, X##P##-##48ullk);    \\\n+  }                                             \\\n+  __attribute__((noinline,noclone))             \\\n+  satfx_t us_sub_##N (satfx_t a)                \\\n+  {                                             \\\n+    return a - X##P##-##48ullk;                 \\\n+  }\n+#include \"vals-ullk.def\"\n+#undef VAL\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  us_add_##N, us_add2_##N,                      \\\n+  us_sub_##N, us_sub2_##N,\n+#include \"vals-ullk.def\"\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x4000000000000000, 0x3e80000000000000, 0x3f80000000000000,\n+    0x7ffffffffffffffe, 0x7fffffffffffffff, 0x7f80000000000000,\n+    0x7f7f7f7f7f7f7f7f, 0x7f81000000000080, 0x7f00000080000000,\n+    0x7f00000000000001,\n+    0x8000000000000000, 0x8000000000000001, 0x8080808080808080,\n+    0x8081000000000000, 0x80ffffffffffffff, 0x80fffffffffffffe,\n+    0x8100000000000000, 0x8180000000000000, 0x818000000000000,\n+    0xff00000000000000, 0xffffffffffffff01, 0xffffffffffffff80,\n+    0xffffffffffffff7f, 0xff80ff80ff80ff80\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "bc3c0bbcd9484c297dec1b9ec1616093ca8f6743", "filename": "gcc/testsuite/gcc.target/avr/torture/sat-ur-plus-minus.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ur-plus-minus.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ur-plus-minus.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fsat-ur-plus-minus.c?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,82 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99 -fwrapv\" } */\n+\n+#include \"fix-types.h\"\n+\n+extern void abort (void);\n+extern void exit (int);\n+\n+typedef unsigned _Fract fx_t;\n+typedef unsigned _Sat _Fract satfx_t;\n+typedef unsigned int intfx_t;\n+\n+US_LFUN (us_add, +, fx_t, ur, >)\n+US_LFUN (us_sub, -, fx_t, ur, <)\n+\n+#define VAL(N, X)                               \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_add2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return us_add_ur (a, X##P##-##16ur);    \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_add_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a + X##P##-##16ur;               \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_sub2_##N (satfx_t a)             \\\n+    {                                           \\\n+        return us_sub_ur (a, X##P##-##16ur);    \\\n+    }                                           \\\n+    __attribute__((noinline,noclone))           \\\n+    satfx_t us_sub_##N (satfx_t a)              \\\n+    {                                           \\\n+        return a - X##P##-##16ur;               \\\n+    }\n+#include \"vals-ur.def\"\n+#undef VAL\n+\n+satfx_t (* __flash const fun[])(satfx_t) =\n+{\n+#define VAL(N, X)                               \\\n+  us_add_##N, us_add2_##N,                      \\\n+  us_sub_##N, us_sub2_##N,\n+#include \"vals-ur.def\"\n+#undef VAL\n+};\n+\n+\n+const volatile __flash intfx_t vals[] =\n+  {\n+    0, -1, 1, -2, 2, -127, -128, -129,\n+    0x7f, 0x80, 0x81, 0x100,\n+    0x4000, 0x3e80, 0x3f80,\n+    0x7ffe, 0x7fff,\n+    0x7f7f, 0x7f81, 0x7f80,\n+    0x7f01,\n+    0x8000, 0x8001, 0x8080,\n+    0x8081, 0x80ff, 0x80fe,\n+    0x8100, 0x8180, 0x817f,\n+    0xff00, 0xff01, 0xff01,\n+    0xff7f, 0xff80\n+  };\n+\n+\n+int main (void)\n+{\n+  for (unsigned int i = 0; i < sizeof (vals) / sizeof (*vals); i++)\n+    {\n+      satfx_t a, f1, f2;\n+      intfx_t val = vals[i];\n+      __builtin_memcpy (&a, &val, sizeof (satfx_t));\n+      for (unsigned int f = 0; f < sizeof (fun) / sizeof (*fun); f += 2)\n+        {\n+          if (fun[f](a) != fun[f+1](a))\n+            abort();\n+        }\n+    }\n+\n+  exit (0);\n+  return 0;\n+}"}, {"sha": "f6619c2ff57a7f474b6bffd64ac8ea17d279141e", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-hr.def", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-hr.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-hr.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-hr.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,12 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04,-0x3f)\n+VAL (07, 0x40)\n+VAL (08,-0x40)\n+VAL (10,-0x1)\n+VAL (12, 0x3f)\n+VAL (13,-0x3f)\n+VAL (14, 0x7f)\n+VAL (15,-0x7f)\n+"}, {"sha": "a490c69b366466445a2dd5e87e77c56f4bdd7444", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-k.def", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-k.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-k.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-k.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,32 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (05, -0x1)\n+VAL (06, -0x3f)\n+VAL (07, 0x40000000)\n+VAL (08,-0x40000000)\n+\n+VAL (10,-0x7fffffff)\n+VAL (11, 0x7fffffff)\n+VAL (12, 0x7f800000)\n+VAL (13,-0x7f800000)\n+VAL (14, 0x7f800001)\n+VAL (15,-0x7f800001)\n+VAL (16, 0x7f7f7f7f)\n+VAL (17,-0x7f7f7f7f)\n+VAL (18, 0x7f808080)\n+VAL (19,-0x7f808080)\n+VAL (20, 0x3e800000)\n+VAL (21,-0x3e800000)\n+VAL (22, 0x3f800000)\n+VAL (23,-0x3f800000)\n+VAL (24, 0x400000)\n+VAL (25,-0x400000)\n+VAL (26, 0x3f000000)\n+VAL (27,-0x3f000000)\n+VAL (28, 0xffff00)\n+VAL (29,-0xffff00)\n+VAL (30, 0x00ff00ff)\n+VAL (31,-0x00ff00ff)\n+"}, {"sha": "726a7ebed35e6a6ac5d6029623b386ebbd481b77", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-llk.def", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-llk.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-llk.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-llk.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,32 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (05, -0x1)\n+VAL (06, -0x3f)\n+VAL (07, 0x4000000000000000)\n+VAL (08,-0x4000000000000000)\n+\n+VAL (10,-0x7fffffffffffffff)\n+VAL (11, 0x7fffffffffffffff)\n+VAL (12, 0x7f80000000000000)\n+VAL (13,-0x7f80000000000000)\n+VAL (14, 0x7f80000000000001)\n+VAL (15,-0x7f80000000000001)\n+VAL (16, 0x7f7f7f7f7f7f7f7f)\n+VAL (17,-0x7f7f7f7f7f7f7f7f)\n+VAL (18, 0x7f80808080808000)\n+VAL (19,-0x7f80808080808000)\n+VAL (20, 0x3e80000000000000)\n+VAL (21,-0x3e80000000000000)\n+VAL (22, 0x3f80000000000000)\n+VAL (23,-0x3f80000000000000)\n+VAL (24, 0x40000000000000)\n+VAL (25,-0x40000000000000)\n+VAL (26, 0x3f000000000000)\n+VAL (27,-0x3f000000000000)\n+VAL (28, 0xffffff00)\n+VAL (29,-0xffffff00)\n+VAL (30, 0x00ff00ff00ff00ff)\n+VAL (31,-0x00ff00ff00ff00ff)\n+"}, {"sha": "0c5f83f7d023a202b828783938ca4040044e8604", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-r.def", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-r.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-r.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-r.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,30 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (05, -0x1)\n+VAL (06, -0x3f)\n+VAL (07, 0x4000)\n+VAL (08,-0x4000)\n+\n+VAL (10,-0x7fff)\n+VAL (11, 0x7fff)\n+VAL (12, 0x7f80)\n+VAL (13,-0x7f80)\n+VAL (14, 0x7f81)\n+VAL (15,-0x7f81)\n+VAL (16, 0x7f7f)\n+VAL (17,-0x7f7f)\n+VAL (18, 0x7f80)\n+VAL (19,-0x7f80)\n+VAL (20, 0x3e80)\n+VAL (21,-0x3e80)\n+VAL (22, 0x3f80)\n+VAL (23,-0x3f80)\n+VAL (24, 0x40)\n+VAL (25,-0x40)\n+VAL (26, 0x3f00)\n+VAL (27,-0x3f00)\n+VAL (30, 0x00ff)\n+VAL (31,-0x00ff)\n+"}, {"sha": "71441567ca579302428f072a5542d3d89bab2daf", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-uhr.def", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uhr.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uhr.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uhr.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,13 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (07, 0x40)\n+VAL (08, 0xc0)\n+VAL (10, 0xc1)\n+VAL (12, 0xff)\n+VAL (14, 0x7f)\n+VAL (16, 0x81)\n+VAL (20, 0xbf)\n+\n+VAL (99, 0x80)\n+"}, {"sha": "3e212836f4da20261c8755dfaa68839773e65f38", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-uk.def", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uk.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uk.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-uk.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,23 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (07, 0x40000000)\n+VAL (08, 0xc0000000)\n+VAL (10, 0x7fffffff)\n+VAL (12, 0x7f800000)\n+VAL (14, 0x7f800001)\n+VAL (16, 0x7f7f7f7f)\n+VAL (18, 0x7f808000)\n+VAL (20, 0x3e800000)\n+VAL (22, 0x3f800000)\n+VAL (24, 0x40000000)\n+VAL (26, 0x3f000000)\n+VAL (28, 0xffff00)\n+VAL (30, 0x00ff00ff)\n+VAL (31, 0xff00ff00)\n+VAL (32, 0x10000000)\n+VAL (33, 0xff000000)\n+\n+VAL (99, 0x80000000)\n+"}, {"sha": "620182be6408a230ced93369b0cad9429d3953a8", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-ullk.def", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ullk.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ullk.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ullk.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,20 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (07, 0x4000000000000000)\n+VAL (08, 0x4000000000000000)\n+VAL (10, 0x7fffffffffffffff)\n+VAL (12, 0x7f80000000000000)\n+VAL (14, 0x7f80000000000001)\n+VAL (16, 0x7f7f7f7f7f7f7f7f)\n+VAL (18, 0x7f80808080808000)\n+VAL (20, 0x3e80000000000000)\n+VAL (22, 0x3f80000000000000)\n+VAL (24, 0x40000000000000)\n+VAL (26, 0x3f000000000000)\n+VAL (28, 0xffffff00)\n+VAL (30, 0x00ff00ff00ff00ff)\n+\n+VAL (99, 0x8000000000000000)\n+"}, {"sha": "d6ea8f1c50d05b3d53a1375f23f5dfce4333741d", "filename": "gcc/testsuite/gcc.target/avr/torture/vals-ur.def", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ur.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ur.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Favr%2Ftorture%2Fvals-ur.def?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -0,0 +1,17 @@\n+VAL (01, 0x0)\n+VAL (02, 0x1)\n+VAL (03, 0x3f)\n+VAL (04, 0x80)\n+VAL (07, 0x4000)\n+VAL (08, 0xc000)\n+VAL (10, 0x7fff)\n+VAL (12, 0x7f80)\n+VAL (14, 0x7f81)\n+VAL (16, 0x7f7f)\n+VAL (20, 0x3e80)\n+VAL (22, 0x3f80)\n+VAL (26, 0x3f00)\n+VAL (32, 0x100)\n+\n+VAL (99, 0x8000)\n+"}, {"sha": "2045aac280397dd1529687c8f95547e7264b3952", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -1,3 +1,20 @@\n+2012-09-15  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/54222\n+\t* config/avr/lib1funcs-fixed.S (__ssneg_2, __ssabs_2, __ssneg_4,\n+\t__ssabs_4, __clr_8, __ssneg_8, __ssabs_8,\n+\t__usadd_8, __ussub_8, __ssadd_8, __sssub_8): New functions.\n+\t(__divsa3): Use __negsi2 to negate r_quoL.\n+\t* config/avr/lib1funcs.S (FALIAS): New macro.\n+\t(__divmodsi4): Break out and use __divmodsi4_neg1 as...\n+\t(__negsi2): ...this new function.\n+\t* config/avr/t-avr (LIB1ASMFUNCS): Add _negsi2, _clr_8,\n+\t_ssneg_2, _ssneg_4, _ssneg_8, _ssabs_2, _ssabs_4,\n+\t_ssabs_8, _ssadd_8, _sssub_8, _usadd_8, _ussub_8.\n+\t(LIB2FUNCS_EXCLUDE): Fix typo for _add _sub.\n+\tAdd: _ssadd*, _sssub*, _ssneg*, _ssabs* for signed fixed modes.\n+\tAdd: _usadd*, _ussub*, _usneg* for unsigned fixed modes.\n+\n 2012-09-10  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54089"}, {"sha": "ddcd02e197c27bc48474c75daeeb58e87cd816c6", "filename": "libgcc/config/avr/lib1funcs-fixed.S", "status": "modified", "additions": 222, "deletions": 2, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs-fixed.S?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -808,8 +808,8 @@ DEFUN   __divsa3\n     XCALL   __udivusa3\n     sbrs    r0, 7   ; negate result if needed\n     ret\n-    NEG4    r_quoL\n-    ret\n+    ;; negate r_quoL\n+    XJMP    __negsi2\n ENDF __divsa3\n #endif  /* defined (L_divsa3) */\n \n@@ -872,3 +872,223 @@ ENDF __udivusa3\n #undef  r_divHL\n #undef  r_divHH\n #undef  r_cnt\n+\n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Saturation, 2 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; First Argument and Return Register\n+#define A0  24\n+#define A1  A0+1\n+\n+#if defined (L_ssneg_2)\n+DEFUN __ssneg_2\n+    NEG2    A0\n+    brvc 0f\n+    sbiw    A0, 1\n+0:  ret\n+ENDF __ssneg_2\n+#endif /* L_ssneg_2 */\n+\n+#if defined (L_ssabs_2)\n+DEFUN __ssabs_2\n+    sbrs    A1, 7\n+    ret\n+    XJMP    __ssneg_2\n+ENDF __ssabs_2\n+#endif /* L_ssabs_2 */\n+\n+#undef A0\n+#undef A1\n+\n+\n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Saturation, 4 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; First Argument and Return Register\n+#define A0  22\n+#define A1  A0+1\n+#define A2  A0+2\n+#define A3  A0+3\n+\n+#if defined (L_ssneg_4)\n+DEFUN __ssneg_4\n+    XCALL   __negsi2\n+    brvc 0f\n+    ldi     A3, 0x7f\n+    ldi     A2, 0xff\n+    ldi     A1, 0xff\n+    ldi     A0, 0xff\n+0:  ret\n+ENDF __ssneg_4\n+#endif /* L_ssneg_4 */\n+\n+#if defined (L_ssabs_4)\n+DEFUN __ssabs_4\n+    sbrs    A3, 7\n+    ret\n+    XJMP    __ssneg_4\n+ENDF __ssabs_4\n+#endif /* L_ssabs_4 */\n+\n+#undef A0\n+#undef A1\n+#undef A2\n+#undef A3\n+\n+\n+\f\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Saturation, 8 Bytes\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; First Argument and Return Register\n+#define A0  18\n+#define A1  A0+1\n+#define A2  A0+2\n+#define A3  A0+3\n+#define A4  A0+4\n+#define A5  A0+5\n+#define A6  A0+6\n+#define A7  A0+7\n+\n+#if defined (L_clr_8)\n+FALIAS __usneguta2\n+FALIAS __usneguda2\n+FALIAS __usnegudq2\n+\n+;; Clear Carry and all Bytes\n+DEFUN __clr_8\n+    ;; Clear Carry and set Z\n+    sub     A7, A7\n+    ;; FALLTHRU\n+ENDF  __clr_8\n+;; Propagate Carry to all Bytes, Carry unaltered\n+DEFUN __sbc_8\n+    sbc     A7, A7\n+    sbc     A6, A6\n+    wmov    A4, A6\n+    wmov    A2, A6\n+    wmov    A0, A6\n+    ret\n+ENDF __sbc_8\n+#endif /* L_clr_8 */\n+\n+#if defined (L_ssneg_8)\n+FALIAS __ssnegta2\n+FALIAS __ssnegda2\n+FALIAS __ssnegdq2\n+\n+DEFUN __ssneg_8\n+    XCALL   __negdi2\n+    brvc 0f\n+    ;; A[] = 0x7fffffff\n+    sec\n+    XCALL   __sbc_8\n+    ldi     A7, 0x7f\n+0:  ret\n+ENDF __ssneg_8\n+#endif /* L_ssneg_8 */\n+\n+#if defined (L_ssabs_8)\n+FALIAS __ssabsta2\n+FALIAS __ssabsda2\n+FALIAS __ssabsdq2\n+\n+DEFUN __ssabs_8\n+    sbrs    A7, 7\n+    ret\n+    XJMP    __ssneg_8\n+ENDF __ssabs_8\n+#endif /* L_ssabs_8 */\n+\n+;; Second Argument\n+#define B0  10\n+#define B1  B0+1\n+#define B2  B0+2\n+#define B3  B0+3\n+#define B4  B0+4\n+#define B5  B0+5\n+#define B6  B0+6\n+#define B7  B0+7\n+\n+#if defined (L_usadd_8)\n+FALIAS __usadduta3\n+FALIAS __usadduda3\n+FALIAS __usaddudq3\n+\n+DEFUN __usadd_8\n+    XCALL   __adddi3\n+    brcs 0f\n+    ret\n+\t;; A[] = 0xffffffff\n+0:  XJMP    __sbc_8\n+ENDF __usadd_8\n+#endif /* L_usadd_8 */\n+\n+#if defined (L_ussub_8)\n+FALIAS __ussubuta3\n+FALIAS __ussubuda3\n+FALIAS __ussubudq3\n+\n+DEFUN __ussub_8\n+    XCALL   __subdi3\n+    brcs 0f\n+    ret\n+\t;; A[] = 0\n+0:  XJMP    __clr_8\n+ENDF __ussub_8\n+#endif /* L_ussub_8 */\n+\n+#if defined (L_ssadd_8)\n+FALIAS __ssaddta3\n+FALIAS __ssaddda3\n+FALIAS __ssadddq3\n+\n+DEFUN __ssadd_8\n+    ;; A = (B >= 0) ? INT64_MAX : INT64_MIN\n+    XCALL   __adddi3\n+    brvc 0f\n+    cpi     B7, 0x80\n+    XCALL   __sbc_8\n+    subi    A7, 0x80\n+0:  ret\n+ENDF __ssadd_8\n+#endif /* L_ssadd_8 */\n+\n+#if defined (L_sssub_8)\n+FALIAS __sssubta3\n+FALIAS __sssubda3\n+FALIAS __sssubdq3\n+\n+DEFUN __sssub_8\n+    XCALL   __subdi3\n+    brvc 0f\n+\t;; A = (B < 0) ? INT64_MAX : INT64_MIN\n+    ldi     A7, 0x7f\n+    cp      A7, B7\n+    XCALL   __sbc_8\n+    subi    A7, 0x80\n+0:  ret\n+ENDF __sssub_8\n+#endif /* L_sssub_8 */\n+\n+#undef A0\n+#undef A1\n+#undef A2\n+#undef A3\n+#undef A4\n+#undef A5\n+#undef A6\n+#undef A7\n+#undef B0\n+#undef B1\n+#undef B2\n+#undef B3\n+#undef B4\n+#undef B5\n+#undef B6\n+#undef B7"}, {"sha": "ad9791893066d2609f157810818bcbe4b2513f05", "filename": "libgcc/config/avr/lib1funcs.S", "status": "modified", "additions": 30, "deletions": 11, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Flib1funcs.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Flib1funcs.S?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -91,6 +91,14 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n .endfunc\n .endm\n \n+.macro FALIAS name\n+.global \\name\n+.func \\name\n+\\name:\n+.size \\name, .-\\name\n+.endfunc\n+.endm\n+\n ;; Negate a 2-byte value held in consecutive registers\n .macro NEG2  reg\n     com     \\reg+1\n@@ -99,6 +107,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n .endm\n \n ;; Negate a 4-byte value held in consecutive registers\n+;; Sets the V flag for signed overflow tests if REG >= 16\n .macro NEG4  reg\n     com     \\reg+3\n     com     \\reg+2\n@@ -1325,24 +1334,15 @@ DEFUN __divmodsi4\n     bst     r_arg1HH,7          ; store sign of dividend\n     brtc    0f\n     com     __tmp_reg__         ; r0.7 is sign of result\n-    rcall   __divmodsi4_neg1    ; dividend negative: negate\n+    XCALL   __negsi2            ; dividend negative: negate\n 0:\n     sbrc    r_arg2HH,7\n     rcall   __divmodsi4_neg2    ; divisor negative: negate\n     XCALL   __udivmodsi4        ; do the unsigned div/mod\n     sbrc    __tmp_reg__, 7      ; correct quotient sign\n     rcall   __divmodsi4_neg2\n     brtc    __divmodsi4_exit    ; correct remainder sign\n-__divmodsi4_neg1:\n-    ;; correct dividend/remainder sign\n-    com     r_arg1HH\n-    com     r_arg1HL\n-    com     r_arg1H\n-    neg     r_arg1L\n-    sbci    r_arg1H, 0xff\n-    sbci    r_arg1HL,0xff\n-    sbci    r_arg1HH,0xff\n-    ret\n+    XJMP    __negsi2\n __divmodsi4_neg2:\n     ;; correct divisor/quotient sign\n     com     r_arg2HH\n@@ -1357,6 +1357,16 @@ __divmodsi4_exit:\n ENDF __divmodsi4\n #endif /* defined (L_divmodsi4) */\n \n+#if defined (L_negsi2)\n+;; (set (reg:SI 22)\n+;;      (neg:SI (reg:SI 22)))\n+;; Sets the V flag for signed overflow tests\n+DEFUN __negsi2\n+    NEG4    22\n+    ret\n+ENDF __negsi2\n+#endif /* L_negsi2 */\n+\n #undef r_remHH\n #undef r_remHL\n #undef r_remH\n@@ -1689,6 +1699,8 @@ ENDF __divdi3_moddi3\n ;; (set (reg:DI 18)\n ;;      (plus:DI (reg:DI 18)\n ;;               (reg:DI 10)))\n+;; Sets the V flag for signed overflow tests\n+;; Sets the C flag for unsigned overflow tests\n DEFUN __adddi3\n     ADD A0,B0  $  adc A1,B1  $  adc A2,B2  $  adc A3,B3\n     adc A4,B4  $  adc A5,B5  $  adc A6,B6  $  adc A7,B7\n@@ -1700,6 +1712,8 @@ ENDF __adddi3\n ;; (set (reg:DI 18)\n ;;      (plus:DI (reg:DI 18)\n ;;               (sign_extend:SI (reg:QI 26))))\n+;; Sets the V flag for signed overflow tests\n+;; Sets the C flag for unsigned overflow tests provided 0 <= R26 < 128\n DEFUN __adddi3_s8\n     clr     TT\n     sbrc    r26, 7\n@@ -1714,6 +1728,8 @@ ENDF __adddi3_s8\n ;; (set (reg:DI 18)\n ;;      (minus:DI (reg:DI 18)\n ;;                (reg:DI 10)))\n+;; Sets the V flag for signed overflow tests\n+;; Sets the C flag for unsigned overflow tests\n DEFUN __subdi3\n     SUB A0,B0  $  sbc A1,B1  $  sbc A2,B2  $  sbc A3,B3\n     sbc A4,B4  $  sbc A5,B5  $  sbc A6,B6  $  sbc A7,B7\n@@ -1747,6 +1763,9 @@ ENDF __cmpdi2_s8\n #endif /* L_cmpdi2_s8 */\n \n #if defined (L_negdi2)\n+;; (set (reg:DI 18)\n+;;      (neg:DI (reg:DI 18)))\n+;; Sets the V flag for signed overflow tests\n DEFUN __negdi2\n \n     com  A4    $  com  A5    $  com  A6    $  com  A7"}, {"sha": "d1f55e408d354bbaeb63a3c601eb695d9f581c66", "filename": "libgcc/config/avr/t-avr", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51526856a1ca4a9434919d012a2bed07c8395ee0/libgcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Favr%2Ft-avr?ref=51526856a1ca4a9434919d012a2bed07c8395ee0", "patch": "@@ -20,7 +20,7 @@ LIB1ASMFUNCS = \\\n \t_divdi3 _udivdi3 \\\n \t_muldi3 \\\n \t_udivmod64 \\\n-\t_negdi2 \\\n+\t_negsi2 _negdi2 \\\n \t_prologue \\\n \t_epilogue \\\n \t_exit \\\n@@ -72,7 +72,12 @@ LIB1ASMFUNCS += \\\n \t_divqq3 _udivuqq3 \\\n \t_divhq3 _udivuhq3 \\\n \t_divha3 _udivuha3 \\\n-\t_divsa3 _udivusa3\n+\t_divsa3 _udivusa3 \\\n+\t_clr_8 \\\n+\t_ssneg_2 _ssneg_4 _ssneg_8 \\\n+\t_ssabs_2 _ssabs_4 _ssabs_8 \\\n+\t_ssadd_8 _sssub_8 \\\n+\t_usadd_8 _ussub_8\n \n LIB2FUNCS_EXCLUDE = \\\n \t_moddi3 _umoddi3 \\\n@@ -103,6 +108,7 @@ endif\n \n \n # Filter out supported conversions from fixed-bit.c\n+# Also filter out TQ and UTQ.\n \n conv_XY=$(conv)$(mode1)$(mode2)\n func_X=$(func)$(mode)\n@@ -141,8 +147,20 @@ allfix_modes = QQ UQQ HQ UHQ HA UHA SQ USQ SA USA DA UDA DQ UDQ TQ UTQ TA UTA\n \n LIB2FUNCS_EXCLUDE += \\\n \t$(foreach func,_add _sub,\\\n-\t$(foreach mode,$(allfix_modes),$(func_X)3))\n+\t$(foreach mode,$(allfix_modes),$(func_X)))\n \n LIB2FUNCS_EXCLUDE += \\\n \t$(foreach func,_lshr _ashl _ashr _cmp,\\\n \t$(foreach mode,$(allfix_modes),$(func_X)))\n+\n+\n+usat_modes = UQQ UHQ UHA USQ USA UDQ UDA UTQ UTA\n+ssat_modes =  QQ  HQ  HA  SQ  SA  DQ  DA  TQ  TA\n+\n+LIB2FUNCS_EXCLUDE += \\\n+\t$(foreach func,_ssadd _sssub _ssneg _ssabs,\\\n+\t$(foreach mode,$(ssat_modes),$(func_X)))\n+\n+LIB2FUNCS_EXCLUDE += \\\n+\t$(foreach func,_usadd _ussub _usneg,\\\n+\t$(foreach mode,$(usat_modes),$(func_X)))"}]}