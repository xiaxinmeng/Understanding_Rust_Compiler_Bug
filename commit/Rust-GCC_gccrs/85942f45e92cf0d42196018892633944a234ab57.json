{"sha": "85942f45e92cf0d42196018892633944a234ab57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU5NDJmNDVlOTJjZjBkNDIxOTYwMTg4OTI2MzM5NDRhMjM0YWI1Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-02-03T20:41:30Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-02-03T20:41:30Z"}, "message": "re PR ipa/59831 (ice in cgraph_speculative_call_info with -O3)\n\n\n\tPR ipa/59831\n\t* g++.dg/ipa/devirt-24.C: New testcase.\n\n\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Give up on -fno-devirtualize;\n\tTry to devirtualize by the knowledge of virtual table pointer given by\n\taggregate propagation.\n\t* ipa-prop.c (try_make_edge_direct_virtual_call): Likewise.\n\tipa_print_node_jump_functions): Dump also offset that\n\tis relevant for polymorphic calls.\n\t(determine_known_aggregate_parts): Add arg_type parameter; use it\n\tinstead of determining the type from pointer type.\n\t(ipa_compute_jump_functions_for_edge): Update call of\n\tdetermine_known_aggregate_parts.\n\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Break out from ...\n\t(gimple_get_virt_method_for_binfo): ... here; simplify using\n\tvtable_pointer_value_to_vtable.\n\t* gimple-fold.h (gimple_get_virt_method_for_vtable): Declare.\n\t* ipa-devirt.c (subbinfo_with_vtable_at_offset): Turn OFFSET parameter\n\tto unsigned HOST_WIDE_INT; Use vtable_pointer_value_to_vtable.\n\t(vtable_pointer_value_to_vtable): Break out from ...; handle also\n\tPOINTER_PLUS_EXPR.\n\t(vtable_pointer_value_to_binfo): ... here.\n\t* ipa-utils.h (vtable_pointer_value_to_vtable): Declare.\n\nFrom-SVN: r207439", "tree": {"sha": "ae16bce09c999f0a1aa07a51255fd97b90ea03c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae16bce09c999f0a1aa07a51255fd97b90ea03c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/85942f45e92cf0d42196018892633944a234ab57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85942f45e92cf0d42196018892633944a234ab57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85942f45e92cf0d42196018892633944a234ab57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85942f45e92cf0d42196018892633944a234ab57/comments", "author": null, "committer": null, "parents": [{"sha": "bddc974e716ad04c2de84f0168ebf9d192c54098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bddc974e716ad04c2de84f0168ebf9d192c54098", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bddc974e716ad04c2de84f0168ebf9d192c54098"}], "stats": {"total": 303, "additions": 241, "deletions": 62}, "files": [{"sha": "118c42ee83adff7a82ad0e6731d6d81ef961c315", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -1,3 +1,27 @@\n+2014-02-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/59831\n+\t* ipa-cp.c (ipa_get_indirect_edge_target_1): Give up on -fno-devirtualize;\n+\tTry to devirtualize by the knowledge of virtual table pointer given by\n+\taggregate propagation.\n+\t* ipa-prop.c (try_make_edge_direct_virtual_call): Likewise.\n+\tipa_print_node_jump_functions): Dump also offset that\n+\tis relevant for polymorphic calls.\n+\t(determine_known_aggregate_parts): Add arg_type parameter; use it\n+\tinstead of determining the type from pointer type.\n+\t(ipa_compute_jump_functions_for_edge): Update call of\n+\tdetermine_known_aggregate_parts.\n+\t* gimple-fold.c (gimple_get_virt_method_for_vtable): Break out from ...\n+\t(gimple_get_virt_method_for_binfo): ... here; simplify using\n+\tvtable_pointer_value_to_vtable.\n+\t* gimple-fold.h (gimple_get_virt_method_for_vtable): Declare.\n+\t* ipa-devirt.c (subbinfo_with_vtable_at_offset): Turn OFFSET parameter\n+\tto unsigned HOST_WIDE_INT; Use vtable_pointer_value_to_vtable.\n+\t(vtable_pointer_value_to_vtable): Break out from ...; handle also\n+\tPOINTER_PLUS_EXPR.\n+\t(vtable_pointer_value_to_binfo): ... here.\n+\t* ipa-utils.h (vtable_pointer_value_to_vtable): Declare.\n+\n 2014-02-03  Teresa Johnson  <tejohnson@google.com>\n \n \t* tree-vect-slp.c (vect_supported_load_permutation_p): Avoid"}, {"sha": "faea68e457bed60131f50ce810ad54e71df82cce", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -3236,33 +3236,16 @@ fold_const_aggregate_ref (tree t)\n   return fold_const_aggregate_ref_1 (t, NULL);\n }\n \n-/* Return a declaration of a function which an OBJ_TYPE_REF references. TOKEN\n-   is integer form of OBJ_TYPE_REF_TOKEN of the reference expression.\n-   KNOWN_BINFO carries the binfo describing the true type of\n-   OBJ_TYPE_REF_OBJECT(REF).  */\n+/* Lookup virtual method with index TOKEN in a virtual table V\n+   at OFFSET.  */\n \n tree\n-gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n+gimple_get_virt_method_for_vtable (HOST_WIDE_INT token,\n+\t\t\t\t   tree v,\n+\t\t\t\t   unsigned HOST_WIDE_INT offset)\n {\n-  unsigned HOST_WIDE_INT offset, size;\n-  tree v, fn, vtable, init;\n-\n-  vtable = v = BINFO_VTABLE (known_binfo);\n-  /* If there is no virtual methods table, leave the OBJ_TYPE_REF alone.  */\n-  if (!v)\n-    return NULL_TREE;\n-\n-  if (TREE_CODE (v) == POINTER_PLUS_EXPR)\n-    {\n-      offset = tree_to_uhwi (TREE_OPERAND (v, 1)) * BITS_PER_UNIT;\n-      v = TREE_OPERAND (v, 0);\n-    }\n-  else\n-    offset = 0;\n-\n-  if (TREE_CODE (v) != ADDR_EXPR)\n-    return NULL_TREE;\n-  v = TREE_OPERAND (v, 0);\n+  tree vtable = v, init, fn;\n+  unsigned HOST_WIDE_INT size;\n \n   if (TREE_CODE (v) != VAR_DECL\n       || !DECL_VIRTUAL_P (v))\n@@ -3281,6 +3264,7 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n     }\n   gcc_checking_assert (TREE_CODE (TREE_TYPE (v)) == ARRAY_TYPE);\n   size = tree_to_uhwi (TYPE_SIZE (TREE_TYPE (TREE_TYPE (v))));\n+  offset *= BITS_PER_UNIT;\n   offset += token * size;\n   fn = fold_ctor_reference (TREE_TYPE (TREE_TYPE (v)), init,\n \t\t\t    offset, size, v);\n@@ -3306,6 +3290,28 @@ gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n   return fn;\n }\n \n+/* Return a declaration of a function which an OBJ_TYPE_REF references. TOKEN\n+   is integer form of OBJ_TYPE_REF_TOKEN of the reference expression.\n+   KNOWN_BINFO carries the binfo describing the true type of\n+   OBJ_TYPE_REF_OBJECT(REF).  */\n+\n+tree\n+gimple_get_virt_method_for_binfo (HOST_WIDE_INT token, tree known_binfo)\n+{\n+  unsigned HOST_WIDE_INT offset;\n+  tree v;\n+\n+  v = BINFO_VTABLE (known_binfo);\n+  /* If there is no virtual methods table, leave the OBJ_TYPE_REF alone.  */\n+  if (!v)\n+    return NULL_TREE;\n+\n+  if (!vtable_pointer_value_to_vtable (v, &v, &offset))\n+    return NULL_TREE;\n+\n+  return gimple_get_virt_method_for_vtable (token, v, offset);\n+}\n+\n /* Return true iff VAL is a gimple expression that is known to be\n    non-negative.  Restricted to floating-point inputs.  */\n "}, {"sha": "3dbce9cf4154b7d33833bb7d3c8597d87c6fa1ee", "filename": "gcc/gimple-fold.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fgimple-fold.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fgimple-fold.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.h?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -38,6 +38,8 @@ extern tree gimple_fold_stmt_to_constant (gimple, tree (*) (tree));\n extern tree fold_const_aggregate_ref_1 (tree, tree (*) (tree));\n extern tree fold_const_aggregate_ref (tree);\n extern tree gimple_get_virt_method_for_binfo (HOST_WIDE_INT, tree);\n+extern tree gimple_get_virt_method_for_vtable (HOST_WIDE_INT, tree,\n+\t\t\t\t\t       unsigned HOST_WIDE_INT);\n extern bool gimple_val_nonnegative_real_p (tree);\n extern tree gimple_fold_indirect_ref (tree);\n extern bool arith_code_with_undefined_signed_overflow (tree_code);"}, {"sha": "18a5a03a5e178cc7e77739aa8bdc45bf65baef07", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -1479,7 +1479,7 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n   HOST_WIDE_INT token, anc_offset;\n   tree otr_type;\n   tree t;\n-  tree target;\n+  tree target = NULL;\n \n   if (param_index == -1\n       || known_vals.length () <= (unsigned int) param_index)\n@@ -1527,14 +1527,53 @@ ipa_get_indirect_edge_target_1 (struct cgraph_edge *ie,\n \treturn NULL_TREE;\n     }\n \n+  if (!flag_devirtualize)\n+    return NULL_TREE;\n+\n   gcc_assert (!ie->indirect_info->agg_contents);\n   token = ie->indirect_info->otr_token;\n   anc_offset = ie->indirect_info->offset;\n   otr_type = ie->indirect_info->otr_type;\n \n-  t = known_vals[param_index];\n+  t = NULL;\n+\n+  /* Try to work out value of virtual table pointer value in replacemnets.  */\n+  if (!t && agg_reps && !ie->indirect_info->by_ref)\n+    {\n+      while (agg_reps)\n+\t{\n+\t  if (agg_reps->index == param_index\n+\t      && agg_reps->offset == ie->indirect_info->offset\n+\t      && agg_reps->by_ref)\n+\t    {\n+\t      t = agg_reps->value;\n+\t      break;\n+\t    }\n+\t  agg_reps = agg_reps->next;\n+\t}\n+    }\n+\n+  /* Try to work out value of virtual table pointer value in known\n+     aggregate values.  */\n+  if (!t && known_aggs.length () > (unsigned int) param_index\n+      && !ie->indirect_info->by_ref)\n+    {\n+       struct ipa_agg_jump_function *agg;\n+       agg = known_aggs[param_index];\n+       t = ipa_find_agg_cst_for_param (agg, ie->indirect_info->offset,\n+\t\t\t\t       true);\n+    }\n+\n+  /* If we found the virtual table pointer, lookup the binfo.  */\n+  if (t)\n+    t = vtable_pointer_value_to_binfo (t);\n+\n+  /* Did we work out BINFO via type propagation?  */\n   if (!t && known_binfos.length () > (unsigned int) param_index)\n     t = known_binfos[param_index];\n+  /* Or do we know the constant value of pointer?  */\n+  if (!t)\n+    t = known_vals[param_index];\n   if (!t)\n     return NULL_TREE;\n "}, {"sha": "fb9c666b12d4295516f5b18367da79b41c6a6431", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -975,17 +975,24 @@ contains_type_p (tree outer_type, HOST_WIDE_INT offset,\n /* Lookup base of BINFO that has virtual table VTABLE with OFFSET.  */\n \n static tree\n-subbinfo_with_vtable_at_offset (tree binfo, tree offset, tree vtable)\n+subbinfo_with_vtable_at_offset (tree binfo, unsigned HOST_WIDE_INT offset,\n+\t\t\t\ttree vtable)\n {\n   tree v = BINFO_VTABLE (binfo);\n   int i;\n   tree base_binfo;\n+  unsigned HOST_WIDE_INT this_offset;\n \n-  gcc_assert (!v || TREE_CODE (v) == POINTER_PLUS_EXPR);\n+  if (v)\n+    {\n+      if (!vtable_pointer_value_to_vtable (v, &v, &this_offset))\n+\tgcc_unreachable ();\n+\n+      if (offset == this_offset\n+\t  && DECL_ASSEMBLER_NAME (v) == DECL_ASSEMBLER_NAME (vtable))\n+\treturn binfo;\n+    }\n   \n-  if (v && tree_int_cst_equal (TREE_OPERAND (v, 1), offset)\n-      && TREE_OPERAND (TREE_OPERAND (v, 0), 0) == vtable)\n-    return binfo;\n   for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n     if (polymorphic_type_binfo_p (base_binfo))\n       {\n@@ -996,11 +1003,12 @@ subbinfo_with_vtable_at_offset (tree binfo, tree offset, tree vtable)\n   return NULL;\n }\n \n-/* T is known constant value of virtual table pointer.  Return BINFO of the\n-   instance type.  */\n+/* T is known constant value of virtual table pointer.\n+   Store virtual table to V and its offset to OFFSET. \n+   Return false if T does not look like virtual table reference.  */\n \n-tree\n-vtable_pointer_value_to_binfo (tree t)\n+bool\n+vtable_pointer_value_to_vtable (tree t, tree *v, unsigned HOST_WIDE_INT *offset)\n {\n   /* We expect &MEM[(void *)&virtual_table + 16B].\n      We obtain object's BINFO from the context of the virtual table. \n@@ -1011,7 +1019,7 @@ vtable_pointer_value_to_binfo (tree t)\n      In the case of virtual inheritance, the virtual tables may\n      be nested, i.e. the offset may be different from 16 and we may\n      need to dive into the type representation.  */\n-  if (t && TREE_CODE (t) == ADDR_EXPR\n+  if (TREE_CODE (t) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (t, 0)) == MEM_REF\n       && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 0)) == ADDR_EXPR\n       && TREE_CODE (TREE_OPERAND (TREE_OPERAND (t, 0), 1)) == INTEGER_CST\n@@ -1020,20 +1028,47 @@ vtable_pointer_value_to_binfo (tree t)\n       && DECL_VIRTUAL_P (TREE_OPERAND (TREE_OPERAND\n \t\t\t\t\t (TREE_OPERAND (t, 0), 0), 0)))\n     {\n-      tree vtable = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 0);\n-      tree offset = TREE_OPERAND (TREE_OPERAND (t, 0), 1);\n-      tree binfo = TYPE_BINFO (DECL_CONTEXT (vtable));\n-\n-      binfo = subbinfo_with_vtable_at_offset (binfo, offset, vtable);\n-\n-      /* FIXME: for stores of construction vtables we return NULL,\n-\t because we do not have BINFO for those. Eventually we should fix\n-\t our representation to allow this case to be handled, too.\n-\t In the case we see store of BINFO we however may assume\n-\t that standard folding will be ale to cope with it.  */\n-      return binfo;\n+      *v = TREE_OPERAND (TREE_OPERAND (TREE_OPERAND (t, 0), 0), 0);\n+      *offset = tree_to_uhwi (TREE_OPERAND (TREE_OPERAND (t, 0), 1));\n+      return true;\n     }\n-  return NULL;\n+\n+  /* Alternative representation, used by C++ frontend is POINTER_PLUS_EXPR.\n+     We need to handle it when T comes from static variable initializer or\n+     BINFO. */\n+  if (TREE_CODE (t) == POINTER_PLUS_EXPR)\n+    {\n+      *offset = tree_to_uhwi (TREE_OPERAND (t, 1));\n+      t = TREE_OPERAND (t, 0);\n+    }\n+  else\n+    *offset = 0;\n+\n+  if (TREE_CODE (t) != ADDR_EXPR)\n+    return false;\n+  *v = TREE_OPERAND (t, 0);\n+  return true;\n+}\n+\n+/* T is known constant value of virtual table pointer.  Return BINFO of the\n+   instance type.  */\n+\n+tree\n+vtable_pointer_value_to_binfo (tree t)\n+{\n+  tree vtable;\n+  unsigned HOST_WIDE_INT offset;\n+\n+  if (!vtable_pointer_value_to_vtable (t, &vtable, &offset))\n+    return NULL_TREE;\n+\n+  /* FIXME: for stores of construction vtables we return NULL,\n+     because we do not have BINFO for those. Eventually we should fix\n+     our representation to allow this case to be handled, too.\n+     In the case we see store of BINFO we however may assume\n+     that standard folding will be ale to cope with it.  */\n+  return subbinfo_with_vtable_at_offset (TYPE_BINFO (DECL_CONTEXT (vtable)),\n+\t\t\t\t\t offset, vtable);\n }\n \n /* Given REF call in FNDECL, determine class of the polymorphic"}, {"sha": "37ddbde462162bdd3d1ed1ba32930cad0c500829", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -355,8 +355,10 @@ ipa_print_node_jump_functions (FILE *f, struct cgraph_node *node)\n \t\t ii->param_index, ii->offset,\n \t\t ii->by_ref ? \"by reference\" : \"by_value\");\n       else\n-\tfprintf (f, \"    indirect %s callsite, calling param %i\",\n-\t\t ii->polymorphic ? \"polymorphic\" : \"simple\", ii->param_index);\n+\tfprintf (f, \"    indirect %s callsite, calling param %i, \"\n+\t\t \"offset \" HOST_WIDE_INT_PRINT_DEC,\n+\t\t ii->polymorphic ? \"polymorphic\" : \"simple\", ii->param_index,\n+\t\t ii->offset);\n \n       if (cs->call_stmt)\n \t{\n@@ -1332,11 +1334,11 @@ struct ipa_known_agg_contents_list\n \n /* Traverse statements from CALL backwards, scanning whether an aggregate given\n    in ARG is filled in with constant values.  ARG can either be an aggregate\n-   expression or a pointer to an aggregate.  JFUNC is the jump function into\n-   which the constants are subsequently stored.  */\n+   expression or a pointer to an aggregate.  ARG_TYPE is the type of the aggregate.\n+   JFUNC is the jump function into which the constants are subsequently stored.  */\n \n static void\n-determine_known_aggregate_parts (gimple call, tree arg,\n+determine_known_aggregate_parts (gimple call, tree arg, tree arg_type,\n \t\t\t\t struct ipa_jump_func *jfunc)\n {\n   struct ipa_known_agg_contents_list *list = NULL;\n@@ -1351,18 +1353,18 @@ determine_known_aggregate_parts (gimple call, tree arg,\n      arg_base and arg_offset based on what is actually passed as an actual\n      argument.  */\n \n-  if (POINTER_TYPE_P (TREE_TYPE (arg)))\n+  if (POINTER_TYPE_P (arg_type))\n     {\n       by_ref = true;\n       if (TREE_CODE (arg) == SSA_NAME)\n \t{\n \t  tree type_size;\n-          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (TREE_TYPE (arg)))))\n+          if (!tree_fits_uhwi_p (TYPE_SIZE (TREE_TYPE (arg_type))))\n             return;\n \t  check_ref = true;\n \t  arg_base = arg;\n \t  arg_offset = 0;\n-\t  type_size = TYPE_SIZE (TREE_TYPE (TREE_TYPE (arg)));\n+\t  type_size = TYPE_SIZE (TREE_TYPE (arg_type));\n \t  arg_size = tree_to_uhwi (type_size);\n \t  ao_ref_init_from_ptr_and_size (&r, arg_base, NULL_TREE);\n \t}\n@@ -1645,13 +1647,22 @@ ipa_compute_jump_functions_for_edge (struct param_analysis_info *parms_ainfo,\n \t\t\t\t      ? TREE_TYPE (param_type)\n \t\t\t\t      : NULL);\n \n+      /* If ARG is pointer, we can not use its type to determine the type of aggregate\n+\t passed (because type conversions are ignored in gimple).  Usually we can\n+\t safely get type from function declaration, but in case of K&R prototypes or\n+\t variadic functions we can try our luck with type of the pointer passed.\n+\t TODO: Since we look for actual initialization of the memory object, we may better\n+\t work out the type based on the memory stores we find.  */\n+      if (!param_type)\n+\tparam_type = TREE_TYPE (arg);\n+\n       if ((jfunc->type != IPA_JF_PASS_THROUGH\n \t      || !ipa_get_jf_pass_through_agg_preserved (jfunc))\n \t  && (jfunc->type != IPA_JF_ANCESTOR\n \t      || !ipa_get_jf_ancestor_agg_preserved (jfunc))\n \t  && (AGGREGATE_TYPE_P (TREE_TYPE (arg))\n-\t      || (POINTER_TYPE_P (TREE_TYPE (arg)))))\n-\tdetermine_known_aggregate_parts (call, arg, jfunc);\n+\t      || POINTER_TYPE_P (param_type)))\n+\tdetermine_known_aggregate_parts (call, arg, param_type, jfunc);\n     }\n }\n \n@@ -2676,9 +2687,23 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n \t\t\t\t   struct ipa_jump_func *jfunc,\n \t\t\t\t   struct ipa_node_params *new_root_info)\n {\n-  tree binfo, target;\n+  tree binfo = NULL, target;\n+\n+  if (!flag_devirtualize)\n+    return NULL;\n \n-  binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n+  /* First try to do lookup binfo via known virtual table pointer value.  */\n+  if (!ie->indirect_info->by_ref)\n+    {\n+      tree t = ipa_find_agg_cst_for_param (&jfunc->agg,\n+\t\t\t\t\t   ie->indirect_info->offset,\n+\t\t\t\t\t   true);\n+      if (t)\n+        binfo = vtable_pointer_value_to_binfo (t);\n+    }\n+\n+  if (!binfo)\n+    binfo = ipa_value_from_jfunc (new_root_info, jfunc);\n \n   if (!binfo)\n     return NULL;\n@@ -2688,7 +2713,7 @@ try_make_edge_direct_virtual_call (struct cgraph_edge *ie,\n       binfo = gimple_extract_devirt_binfo_from_cst\n \t\t (binfo, ie->indirect_info->otr_type);\n       if (!binfo)\n-        return NULL;\n+\treturn NULL;\n     }\n \n   binfo = get_binfo_at_offset (binfo, ie->indirect_info->offset,"}, {"sha": "3f9be1795bf66b85948d3fea93572736c1fbaf63", "filename": "gcc/ipa-utils.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-utils.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Fipa-utils.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.h?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -88,6 +88,7 @@ tree get_polymorphic_call_info (tree, tree, tree *,\n \t\t\t\tHOST_WIDE_INT *,\n \t\t\t\tipa_polymorphic_call_context *);\n tree vtable_pointer_value_to_binfo (tree t);\n+bool vtable_pointer_value_to_vtable (tree, tree *, unsigned HOST_WIDE_INT *);\n \n /* Return vector containing possible targets of polymorphic call E.\n    If FINALP is non-NULL, store true if the list is complette. "}, {"sha": "e14976ba0e6ee82510992cfb7579b9c7e71a532e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -1,3 +1,8 @@\n+2014-02-03  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/59831\n+\t* g++.dg/ipa/devirt-24.C: New testcase.\n+\n 2014-02-03  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/53017"}, {"sha": "01bfdc2ec504254538a194d885f13bea74566723", "filename": "gcc/testsuite/g++.dg/ipa/devirt-24.C", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/85942f45e92cf0d42196018892633944a234ab57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/85942f45e92cf0d42196018892633944a234ab57/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fdevirt-24.C?ref=85942f45e92cf0d42196018892633944a234ab57", "patch": "@@ -0,0 +1,42 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fno-ipa-sra -fdump-ipa-inline -fdump-ipa-cp\"  } */\n+void pad(void);\n+class A {};\n+class B {\n+public:\n+  A &operator[](int);\n+};\n+class C : B {\n+public:\n+  virtual int m_fn1() { return 0; }\n+  inline A &operator[](int p1) {\n+    int a;\n+    a = m_fn1();\n+    static_cast<void>(__builtin_expect(a, 0) ?: 0);\n+    return B::operator[](p1);\n+  }\n+};\n+\n+int *e;\n+static void sort(C &p1, C &p2) {\n+  for (int i=0;; i++) {\n+    A c, d = p2[0];\n+\tpad();\n+\tpad();\n+\tpad();\n+  }\n+}\n+\n+int test ();\n+\n+void update_sources() {\n+while (test()) {\n+    C f;\n+C *b = new (C);\n+    sort(f, *b);\n+  }\n+}\n+/* { dg-final { scan-ipa-dump-times \"Discovered a virtual call to a known target\" 1 \"inline\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"inline\" } } */\n+/* { dg-final { scan-ipa-dump-times \"Aggregate passed by reference\" 1 \"cp\"  } } */\n+/* { dg-final { cleanup-ipa-dump \"cp\" } } */"}]}