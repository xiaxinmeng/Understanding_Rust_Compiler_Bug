{"sha": "1508cc4663c41afdcaf9df3499b24f6537afe818", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwOGNjNDY2M2M0MWFmZGNhZjlkZjM0OTliMjRmNjUzN2FmZTgxOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-11-09T09:34:21Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-11-09T09:34:21Z"}, "message": "Add ms2 support\n\n\tAdd ms2 support\n\t* config/ms1/ms1.md (UNSPEC_BLOCKAGE, UNSPEC_EI, UNSPEC_DI): New\n\tconstants.\n\t(call,load,store): New insn types.\n\t(mem_access, branch_access): Adjust reservation conditions.\n\t(define_delay): Adjust condition.\n\t(decrement_and_branch_until_zero): Allow for ms2.  Set branch\n\ttype.\n\t(*decrement_and_rbanch_until_zero_no_clobber): Allow for ms2.\n\t(*movqi_internal,*movsi_internal,*movsf_internal): Use load,store\n\tinsn type.\n\t(call_internal, call_value_internal, return_internal,\n\treturn_interrupt_internal, eh_return_internal, indirect_jump,\n\ttablejump): Set call insn type.\n\t(blockage, ei, di): Use appropriate unspec const.\n\t* config/ms1/ms1.c (ms1_flag_delayed_branch): New.\n\t(ms1_get_attr_type): Adjust to give load & store types.\n\t(ms1_final_prescan_insn): Adjust for new insn types.  Don't look\n\tbackwards past a barrier.\n\t(ms1_override_options): Accept ms2 arch.  Copy and reset delayed\n\tbranch scheduling.\n\t(struct branch_info, struct label_info): New.\n\t(ms1_labels): New.\n\t(ms1_add_branches, ms1_check_delay_slot, ms1_reorg_hazard): New.\n\t(ms1_machine_reorg): New.\n\t(TARGET_MACHINE_DEPENDENT_REORG): Override.\n\t* config/ms1/crtn.asm: Add nop for ms2 JAL hazard.\n\t* config/ms1/ms1.h (processor_type): Add PROCESSOR_MS2.\n\t(ASM_SPEC, LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): Add ms2.\n\t(TARGET_MS2): New.\n\nFrom-SVN: r106680", "tree": {"sha": "4d4af14484330977323d42698d9d7df9f06933b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4d4af14484330977323d42698d9d7df9f06933b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1508cc4663c41afdcaf9df3499b24f6537afe818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1508cc4663c41afdcaf9df3499b24f6537afe818", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1508cc4663c41afdcaf9df3499b24f6537afe818", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1508cc4663c41afdcaf9df3499b24f6537afe818/comments", "author": null, "committer": null, "parents": [{"sha": "456b8ce5dbc2f77b3506d18c7eaec25cf76cb573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/456b8ce5dbc2f77b3506d18c7eaec25cf76cb573", "html_url": "https://github.com/Rust-GCC/gccrs/commit/456b8ce5dbc2f77b3506d18c7eaec25cf76cb573"}], "stats": {"total": 498, "additions": 440, "deletions": 58}, "files": [{"sha": "32c9206a6835ac17923c910d7fcd12bfaebeb42d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1508cc4663c41afdcaf9df3499b24f6537afe818", "patch": "@@ -1,3 +1,36 @@\n+2005-11-09  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tAdd ms2 support\n+\t* config/ms1/ms1.md (UNSPEC_BLOCKAGE, UNSPEC_EI, UNSPEC_DI): New\n+\tconstants.\n+\t(call,load,store): New insn types.\n+\t(mem_access, branch_access): Adjust reservation conditions.\n+\t(define_delay): Adjust condition.\n+\t(decrement_and_branch_until_zero): Allow for ms2.  Set branch\n+\ttype.\n+\t(*decrement_and_rbanch_until_zero_no_clobber): Allow for ms2.\n+\t(*movqi_internal,*movsi_internal,*movsf_internal): Use load,store\n+\tinsn type.\n+\t(call_internal, call_value_internal, return_internal,\n+\treturn_interrupt_internal, eh_return_internal, indirect_jump,\n+\ttablejump): Set call insn type.\n+\t(blockage, ei, di): Use appropriate unspec const.\n+\t* config/ms1/ms1.c (ms1_flag_delayed_branch): New.\n+\t(ms1_get_attr_type): Adjust to give load & store types.\n+\t(ms1_final_prescan_insn): Adjust for new insn types.  Don't look\n+\tbackwards past a barrier.\n+\t(ms1_override_options): Accept ms2 arch.  Copy and reset delayed\n+\tbranch scheduling.\n+\t(struct branch_info, struct label_info): New.\n+\t(ms1_labels): New.\n+\t(ms1_add_branches, ms1_check_delay_slot, ms1_reorg_hazard): New.\n+\t(ms1_machine_reorg): New.\n+\t(TARGET_MACHINE_DEPENDENT_REORG): Override.\n+\t* config/ms1/crtn.asm: Add nop for ms2 JAL hazard.\n+\t* config/ms1/ms1.h (processor_type): Add PROCESSOR_MS2.\n+\t(ASM_SPEC, LIB_SPEC, STARTFILE_SPEC, ENDFILE_SPEC): Add ms2.\n+\t(TARGET_MS2): New.\n+\n 2005-11-09  Per Bothner  <per@bothner.com>\n \t    Uros Bizjak  <uros@kss-loka.si>\n \t"}, {"sha": "5fbe7ece9695544f2770f7b94afa94d3a07cca8f", "filename": "gcc/config/ms1/crtn.asm", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fcrtn.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fcrtn.asm?ref=1508cc4663c41afdcaf9df3499b24f6537afe818", "patch": "@@ -42,6 +42,7 @@\n \t.align\t\t4\n \tldw\tr14, sp, #0\n \taddi\tsp, sp, #4\n+\tnop\n \tjal\tr0, r14\n \tor\tr0, r0, r0\n \t\n@@ -50,5 +51,6 @@\n \n \tldw\tr14, sp, #0\n \taddi\tsp, sp, #4\n+\tnop\n \tjal\tr0, r14\n \tor\tr0, r0, r0"}, {"sha": "19f02a1c7469d67a405d583ed02a60ef08a13d47", "filename": "gcc/config/ms1/ms1.c", "status": "modified", "additions": 359, "deletions": 31, "changes": 390, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.c?ref=1508cc4663c41afdcaf9df3499b24f6537afe818", "patch": "@@ -84,6 +84,8 @@ struct ms1_frame_info zero_frame_info;\n /* ms1 doesn't have unsigned compares need a library call for this.  */\n struct rtx_def * ms1_ucmpsi3_libcall;\n \n+static int ms1_flag_delayed_branch;\n+\n \f\n static rtx\n ms1_struct_value_rtx (tree fndecl ATTRIBUTE_UNUSED,\n@@ -125,32 +127,31 @@ ms1_asm_output_opcode (FILE *f ATTRIBUTE_UNUSED, const char *ptr)\n   return ptr;\n }\n \n-/* Return TRUE if INSN is a memory load.  */\n-static bool\n-ms1_memory_load (rtx insn)\n-{\n-  return ((GET_CODE (insn) == SET) && (GET_CODE (XEXP (insn,1)) == MEM));\n-}\n-\n /* Given an insn, return whether it's a memory operation or a branch\n    operation, otherwise return TYPE_ARITH.  */\n static enum attr_type\n ms1_get_attr_type (rtx complete_insn)\n {\n   rtx insn = PATTERN (complete_insn);\n \n-  if ((GET_CODE (insn) == SET)\n-      && ((GET_CODE (XEXP (insn, 0)) == MEM)\n-\t  || (GET_CODE (XEXP (insn, 1)) == MEM)))\n-    return TYPE_MEM;\n-\n-  else if (((GET_CODE (insn) == SET) && (XEXP (insn, 0) == pc_rtx))\n-\t   || (GET_CODE (complete_insn) == JUMP_INSN)\n-\t   || (GET_CODE (complete_insn) == CALL_INSN))\n+  if (JUMP_P (complete_insn))\n+    return TYPE_BRANCH;\n+  if (CALL_P (complete_insn))\n     return TYPE_BRANCH;\n \n-  else\n+  if (GET_CODE (insn) != SET)\n     return TYPE_ARITH;\n+\n+  if (SET_DEST (insn) == pc_rtx)\n+    return TYPE_BRANCH;\n+\n+  if (GET_CODE (SET_DEST (insn)) == MEM)\n+    return TYPE_STORE;\n+\n+  if (GET_CODE (SET_SRC (insn)) == MEM)\n+    return TYPE_LOAD;\n+  \n+  return TYPE_ARITH;\n }\n \n /* A helper routine for insn_dependent_p called through note_stores.  */\n@@ -212,35 +213,48 @@ ms1_final_prescan_insn (rtx   insn,\n \t\t\tint   noperands ATTRIBUTE_UNUSED)\n {\n   rtx prev_i;\n+  enum attr_type prev_attr;\n \n   ms1_nops_required = 0;\n   ms1_nop_reasons = \"\";\n \n+  /* ms2 constraints are dealt with in reorg.  */\n+  if (ms1_cpu == PROCESSOR_MS2)\n+    return;\n+  \n   /* Only worry about real instructions.  */\n   if (! INSN_P (insn))\n     return;\n \n   /* Find the previous real instructions.  */\n-  prev_i = PREV_INSN (insn);\n-  while (prev_i != NULL\n+  for (prev_i = PREV_INSN (insn);\n+       prev_i != NULL\n \t && (! INSN_P (prev_i)\n \t     || GET_CODE (PATTERN (prev_i)) == USE\n-\t     || GET_CODE (PATTERN (prev_i)) == CLOBBER))\n-    prev_i = PREV_INSN (prev_i);\n-\n+\t     || GET_CODE (PATTERN (prev_i)) == CLOBBER);\n+       prev_i = PREV_INSN (prev_i))\n+    {\n+      /* If we meet a barrier, there is no flow through here.  */\n+      if (BARRIER_P (prev_i))\n+\treturn;\n+    }\n+  \n   /* If there isn't one then there is nothing that we need do.  */\n   if (prev_i == NULL || ! INSN_P (prev_i))\n     return;\n \n+  prev_attr = ms1_get_attr_type (prev_i);\n+  \n   /* Delayed branch slots already taken care of by delay branch scheduling.  */\n-  if (ms1_get_attr_type (prev_i) == TYPE_BRANCH)\n+  if (prev_attr == TYPE_BRANCH)\n     return;\n \n   switch (ms1_get_attr_type (insn))\n     {\n-    case TYPE_MEM:\n+    case TYPE_LOAD:\n+    case TYPE_STORE:\n       /* Avoid consecutive memory operation.  */\n-      if  (ms1_get_attr_type (prev_i) == TYPE_MEM\n+      if  ((prev_attr == TYPE_LOAD || prev_attr == TYPE_STORE)\n \t   && ms1_cpu == PROCESSOR_MS1_64_001)\n \t{\n \t  ms1_nops_required = 1;\n@@ -252,7 +266,7 @@ ms1_final_prescan_insn (rtx   insn,\n     case TYPE_COMPLEX:\n       /* One cycle of delay is required between load\n \t and the dependent arithmetic instruction.  */\n-      if (ms1_memory_load (PATTERN (prev_i))\n+      if (prev_attr == TYPE_LOAD\n \t  && insn_true_dependent_p (prev_i, insn))\n \t{\n \t  ms1_nops_required = 1;\n@@ -263,15 +277,15 @@ ms1_final_prescan_insn (rtx   insn,\n     case TYPE_BRANCH:\n       if (insn_dependent_p (prev_i, insn))\n \t{\n-\t  if (ms1_get_attr_type (prev_i) == TYPE_ARITH\n+\t  if (prev_attr == TYPE_ARITH\n \t      && ms1_cpu == PROCESSOR_MS1_64_001)\n \t    {\n \t      /* One cycle of delay between arith\n \t\t instructions and branch dependent on arith.  */\n \t      ms1_nops_required = 1;\n \t      ms1_nop_reasons = \"arith->branch dependency delay\";\n \t    }\n-\t  else if (ms1_memory_load (PATTERN (prev_i)))\n+\t  else if (prev_attr == TYPE_LOAD)\n \t    {\n \t      /* Two cycles of delay are required\n \t\t between load and dependent branch.  */\n@@ -790,10 +804,9 @@ ms1_override_options (void)\n       else if (!strcasecmp (ms1_cpu_string, \"MS1-16-002\"))\n \tms1_cpu = PROCESSOR_MS1_16_002;\n       else if  (!strcasecmp (ms1_cpu_string, \"MS1-16-003\"))\n-\t{\n-\t  ms1_cpu = PROCESSOR_MS1_16_003;\n-\t  target_flags |= MASK_MUL;\n-\t}\n+\tms1_cpu = PROCESSOR_MS1_16_003;\n+      else if (!strcasecmp (ms1_cpu_string, \"MS2\"))\n+\tms1_cpu = PROCESSOR_MS2;\n       else\n \terror (\"bad value (%s) for -march= switch\", ms1_cpu_string);\n     }\n@@ -806,6 +819,10 @@ ms1_override_options (void)\n       flag_gcse = 0;\n     }\n \n+  /* We do delayed branch filling in machine dependent reorg */\n+  ms1_flag_delayed_branch = flag_delayed_branch;\n+  flag_delayed_branch = 0;\n+\n   init_machine_status = ms1_init_machine_status;\n }\n \n@@ -1631,6 +1648,315 @@ ms1_pass_in_stack (enum machine_mode mode ATTRIBUTE_UNUSED, tree type)\n \t       || TREE_ADDRESSABLE (type))));\n }\n \f\n+\n+/* Structures to hold branch information during reorg.  */\n+typedef struct branch_info\n+{\n+  rtx insn;  /* The branch insn.  */\n+  \n+  struct branch_info *next;\n+} branch_info;\n+\n+typedef struct label_info\n+{\n+  rtx label;  /* The label.  */\n+  branch_info *branches;  /* branches to this label.  */\n+  struct label_info *next;\n+} label_info;\n+\n+/* Chain of labels found in current function, used during reorg.  */\n+static label_info *ms1_labels;\n+\n+/* If *X is a label, add INSN to the list of branches for that\n+   label.  */\n+\n+static int\n+ms1_add_branches (rtx *x, void *insn)\n+{\n+  if (GET_CODE (*x) == LABEL_REF)\n+    {\n+      branch_info *branch = xmalloc (sizeof (*branch));\n+      rtx label = XEXP (*x, 0);\n+      label_info *info;\n+\n+      for (info = ms1_labels; info; info = info->next)\n+\tif (info->label == label)\n+\t  break;\n+\n+      if (!info)\n+\t{\n+\t  info = xmalloc (sizeof (*info));\n+\t  info->next = ms1_labels;\n+\t  ms1_labels = info;\n+\t  \n+\t  info->label = label;\n+\t  info->branches = NULL;\n+\t}\n+\n+      branch->next = info->branches;\n+      info->branches = branch;\n+      branch->insn = insn;\n+    }\n+  return 0;\n+}\n+\n+/* If BRANCH has a filled delay slot, check if INSN is dependent upon\n+   it.  If so, undo the delay slot fill.   Returns the next insn, if\n+   we patch out the branch.  Returns the branch insn, if we cannot\n+   patch out the branch (due to anti-dependency in the delay slot).\n+   In that case, the caller must insert nops at the branch target.  */\n+\n+static rtx\n+ms1_check_delay_slot (rtx branch, rtx insn)\n+{\n+  rtx slot;\n+  rtx tmp;\n+  rtx p;\n+  rtx jmp;\n+  \n+  gcc_assert (GET_CODE (PATTERN (branch)) == SEQUENCE);\n+  if (INSN_DELETED_P (branch))\n+    return NULL_RTX;\n+  slot = XVECEXP (PATTERN (branch), 0, 1);\n+  \n+  tmp = PATTERN (insn);\n+  note_stores (PATTERN (slot), insn_dependent_p_1, &tmp);\n+  if (tmp)\n+    /* Not dependent.  */\n+    return NULL_RTX;\n+  \n+  /* Undo the delay slot.  */\n+  jmp = XVECEXP (PATTERN (branch), 0, 0);\n+  \n+  tmp = PATTERN (jmp);\n+  note_stores (PATTERN (slot), insn_dependent_p_1, &tmp);\n+  if (!tmp)\n+    /* Anti dependent. */\n+    return branch;\n+      \n+  p = PREV_INSN (branch);\n+  NEXT_INSN (p) = slot;\n+  PREV_INSN (slot) = p;\n+  NEXT_INSN (slot) = jmp;\n+  PREV_INSN (jmp) = slot;\n+  NEXT_INSN (jmp) = branch;\n+  PREV_INSN (branch) = jmp;\n+  XVECEXP (PATTERN (branch), 0, 0) = NULL_RTX;\n+  XVECEXP (PATTERN (branch), 0, 1) = NULL_RTX;\n+  delete_insn (branch);\n+  return jmp;\n+}\n+\n+/* Insert nops to satisfy pipeline constraints.  We only deal with ms2\n+   constraints here.  Earlier CPUs are dealt with by inserting nops with\n+   final_prescan (but that can lead to inferior code, and is\n+   impractical with ms2's JAL hazard).\n+\n+   ms2 dynamic constraints\n+   1) a load and a following use must be separated by one insn\n+   2) an insn and a following dependent call must be separated by two insns\n+   \n+   only arith insns are placed in delay slots so #1 cannot happen with\n+   a load in a delay slot.  #2 can happen with an arith insn in the\n+   delay slot.  */\n+\n+static void\n+ms1_reorg_hazard (void)\n+{\n+  rtx insn, next;\n+\n+  /* Find all the branches */\n+  for (insn = get_insns ();\n+       insn;\n+       insn = NEXT_INSN (insn))\n+    {\n+      rtx jmp;\n+\n+      if (!INSN_P (insn))\n+\tcontinue;\n+\n+      jmp = PATTERN (insn);\n+      \n+      if (GET_CODE (jmp) != SEQUENCE)\n+\t/* If it's not got a filled delay slot, then it can't\n+\t   conflict.  */\n+\tcontinue;\n+      \n+      jmp = XVECEXP (jmp, 0, 0);\n+\n+      if (recog_memoized (jmp) == CODE_FOR_tablejump)\n+\tfor (jmp = XEXP (XEXP (XVECEXP (PATTERN (jmp), 0, 1), 0), 0);\n+\t     !JUMP_TABLE_DATA_P (jmp);\n+\t     jmp = NEXT_INSN (jmp))\n+\t  continue;\n+\n+      for_each_rtx (&PATTERN (jmp), ms1_add_branches, insn);\n+    }\n+\n+  /* Now scan for dependencies.  */\n+  for (insn = get_insns ();\n+       insn && !INSN_P (insn);\n+       insn = NEXT_INSN (insn))\n+    continue;\n+  \n+  for (;\n+       insn;\n+       insn = next)\n+    {\n+      rtx jmp, tmp;\n+      enum attr_type attr;\n+      \n+      gcc_assert (INSN_P (insn) && !INSN_DELETED_P (insn));\n+      for (next = NEXT_INSN (insn);\n+\t   next && !INSN_P (next);\n+\t   next = NEXT_INSN (next))\n+\tcontinue;\n+\n+      jmp = insn;\n+      if (GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\tjmp = XVECEXP (PATTERN (insn), 0, 0);\n+      \n+      attr = recog_memoized (jmp) >= 0 ? get_attr_type (jmp) : TYPE_UNKNOWN;\n+      \n+      if (next && attr == TYPE_LOAD)\n+\t{\n+\t  /* A load.  See if NEXT is dependent, and if so insert a\n+\t     nop.  */\n+\t  \n+\t  tmp = PATTERN (next);\n+\t  if (GET_CODE (tmp) == SEQUENCE)\n+\t    tmp = PATTERN (XVECEXP (tmp, 0, 0));\n+\t  note_stores (PATTERN (insn), insn_dependent_p_1, &tmp);\n+\t  if (!tmp)\n+\t    emit_insn_after (gen_nop (), insn);\n+\t}\n+      \n+      if (attr == TYPE_CALL)\n+\t{\n+\t  /* A call.  Make sure we're not dependent on either of the\n+\t     previous two dynamic instructions.  */\n+\t  int nops = 0;\n+\t  int count;\n+\t  rtx prev = insn;\n+\t  rtx rescan = NULL_RTX;\n+\n+\t  for (count = 2; count && !nops;)\n+\t    {\n+\t      int type;\n+\t      \n+\t      prev = PREV_INSN (prev);\n+\t      if (!prev)\n+\t\t{\n+\t\t  /* If we reach the start of the function, we must\n+\t\t     presume the caller set the address in the delay\n+\t\t     slot of the call instruction.  */\n+\t\t  nops = count;\n+\t\t  break;\n+\t\t}\n+\t      \n+\t      if (BARRIER_P (prev))\n+\t\tbreak;\n+\t      if (LABEL_P (prev))\n+\t\t{\n+\t\t  /* Look at branches to this label.  */\n+\t\t  label_info *label;\n+\t\t  branch_info *branch;\n+\n+\t\t  for (label = ms1_labels;\n+\t\t       label;\n+\t\t       label = label->next)\n+\t\t    if (label->label == prev)\n+\t\t      {\n+\t\t\tfor (branch = label->branches;\n+\t\t\t     branch;\n+\t\t\t     branch = branch->next)\n+\t\t\t  {\n+\t\t\t    tmp = ms1_check_delay_slot (branch->insn, jmp);\n+\n+\t\t\t    if (tmp == branch->insn)\n+\t\t\t      {\n+\t\t\t\tnops = count;\n+\t\t\t\tbreak;\n+\t\t\t      }\n+\t\t\t    \n+\t\t\t    if (tmp && branch->insn == next)\n+\t\t\t      rescan = tmp;\n+\t\t\t  }\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  continue;\n+\t\t}\n+\t      if (!INSN_P (prev))\n+\t\tcontinue;\n+\t      \n+\t      if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\t\t{\n+\t\t  /* Look at the delay slot.  */\n+\t\t  tmp = ms1_check_delay_slot (prev, jmp);\n+\t\t  if (tmp == prev)\n+\t\t    nops = count;\n+\t\t  break;\n+\t\t}\n+\t      \n+\t      type = (INSN_CODE (prev) >= 0 ? get_attr_type (prev)\n+\t\t      : TYPE_COMPLEX);\n+\t      if (type == TYPE_CALL || type == TYPE_BRANCH)\n+\t\tbreak;\n+\t      \n+\t      if (type == TYPE_LOAD\n+\t\t  || type == TYPE_ARITH\n+\t\t  || type == TYPE_COMPLEX)\n+\t\t{\n+\t\t  tmp = PATTERN (jmp);\n+\t\t  note_stores (PATTERN (prev), insn_dependent_p_1, &tmp);\n+\t\t  if (!tmp)\n+\t\t    {\n+\t\t      nops = count;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n+\t      count -= INSN_CODE (prev) >= 0;\n+\t    }\n+\n+\t  if (rescan)\n+\t    for (next = NEXT_INSN (rescan);\n+\t\t next && !INSN_P (next);\n+\t\t next = NEXT_INSN (next))\n+\t      continue;\n+\t  while (nops--)\n+\t    emit_insn_before (gen_nop (), insn);\n+\t}\n+    }\n+\n+  /* Free the data structures.  */\n+  while (ms1_labels)\n+    {\n+      label_info *label = ms1_labels;\n+      branch_info *branch, *next;\n+      \n+      ms1_labels = label->next;\n+      for (branch = label->branches; branch; branch = next)\n+\t{\n+\t  next = branch->next;\n+\t  free (branch);\n+\t}\n+      free (label);\n+    }\n+}\n+\n+/* Fixup the looping instructions, do delayed branch scheduling, fixup\n+   scheduling hazards.  */\n+\n+static void\n+ms1_machine_reorg (void)\n+{\n+  if (ms1_flag_delayed_branch)\n+    dbr_schedule (get_insns (), dump_file);\n+  \n+  if (ms1_cpu == PROCESSOR_MS2)\n+    ms1_reorg_hazard ();\n+}\n+\f\n /* Initialize the GCC target structure.  */\n const struct attribute_spec ms1_attribute_table[];\n \n@@ -1646,6 +1972,8 @@ const struct attribute_spec ms1_attribute_table[];\n #define TARGET_MUST_PASS_IN_STACK       ms1_pass_in_stack\n #undef  TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES\tms1_arg_partial_bytes\n+#undef  TARGET_MACHINE_DEPENDENT_REORG\n+#define TARGET_MACHINE_DEPENDENT_REORG  ms1_machine_reorg\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \f"}, {"sha": "aa01831ade4f4fc9f3ea11fcf100a8eaffaeba5a", "filename": "gcc/config/ms1/ms1.h", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.h?ref=1508cc4663c41afdcaf9df3499b24f6537afe818", "patch": "@@ -25,7 +25,8 @@ enum processor_type\n {\n   PROCESSOR_MS1_64_001,\n   PROCESSOR_MS1_16_002,\n-  PROCESSOR_MS1_16_003\n+  PROCESSOR_MS1_16_003,\n+  PROCESSOR_MS2\n };\n \n enum epilogue_type\n@@ -40,7 +41,7 @@ extern enum processor_type ms1_cpu;\n /* A C string constant that tells the GCC driver program options to pass to\n    the assembler.  */\n #undef  ASM_SPEC\n-#define ASM_SPEC \"%{march=ms1-16-002: -march=ms1-16-002} %{march=ms1-16-003: -march=ms1-16-003} %{!march=*: -march=ms1-16-002}\"\n+#define ASM_SPEC \"%{march=ms1-16-002: -march=ms1-16-002} %{march=ms1-16-003: -march=ms1-16-003} %{march=ms2: -march=ms2} %{!march=*: -march=ms1-16-002}\"\n \n /* A string to pass to at the end of the command given to the linker.  */\n #undef  LIB_SPEC\n@@ -51,7 +52,9 @@ march=MS1-64-001:-T 64-001.ld%s; \\\n march=ms1-16-002:-T 16-002.ld%s; \\\n march=MS1-16-002:-T 16-002.ld%s; \\\n march=ms1-16-003:-T 16-003.ld%s; \\\n-march=MS1-16-003:-T 16-003.ld%s}\"\n+march=MS1-16-003:-T 16-003.ld%s; \\\n+march=ms2:-T ms2.ld%s; \\\n+march=MS2:-T ms2.ld%s}\"\n \n /* A string to pass at the very beginning of the command given to the\n    linker.  */\n@@ -62,7 +65,9 @@ march=MS1-64-001:%{!mno-crt0:crt0-64-001.o%s} startup-64-001.o%s; \\\n march=ms1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n march=MS1-16-002:%{!mno-crt0:crt0-16-002.o%s} startup-16-002.o%s; \\\n march=ms1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n-march=MS1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s} \\\n+march=MS1-16-003:%{!mno-crt0:crt0-16-003.o%s} startup-16-003.o%s; \\\n+march=ms2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s; \\\n+march=MS2:%{!mno-crt0:crt0-ms2.o%s} startup-ms2.o%s} \\\n crti.o%s crtbegin.o%s\"\n \n /* A string to pass at the end of the command given to the linker.  */\n@@ -73,7 +78,9 @@ march=MS1-64-001:exit-64-001.o%s; \\\n march=ms1-16-002:exit-16-002.o%s; \\\n march=MS1-16-002:exit-16-002.o%s; \\\n march=ms1-16-003:exit-16-003.o%s; \\\n-march=MS1-16-003:exit-16-003.o%s} \\\n+march=MS1-16-003:exit-16-003.o%s; \\\n+march=ms2:exit-ms2.o%s; \\\n+march=MS2:exit-ms2.o%s} \\\n  crtend.o%s crtn.o%s\"\n \f\n /* Run-time target specifications.  */\n@@ -89,6 +96,7 @@ march=MS1-16-003:exit-16-003.o%s} \\\n #define TARGET_MS1_64_001 (ms1_cpu == PROCESSOR_MS1_64_001)\n #define TARGET_MS1_16_002 (ms1_cpu == PROCESSOR_MS1_16_002)\n #define TARGET_MS1_16_003 (ms1_cpu == PROCESSOR_MS1_16_003)\n+#define TARGET_MS2 (ms1_cpu == PROCESSOR_MS2)\n \n #define TARGET_VERSION  fprintf (stderr, \" (ms1)\");\n "}, {"sha": "1d5ff5266f362e500c0c14b58d265d3b3b2e7ebf", "filename": "gcc/config/ms1/ms1.md", "status": "modified", "additions": 33, "deletions": 22, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1508cc4663c41afdcaf9df3499b24f6537afe818/gcc%2Fconfig%2Fms1%2Fms1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fms1%2Fms1.md?ref=1508cc4663c41afdcaf9df3499b24f6537afe818", "patch": "@@ -19,8 +19,16 @@\n ;; Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n ;; 02110-1301, USA.\n \f\n+;; UNSPECs\n+(define_constants\n+  [\n+    (UNSPEC_BLOCKAGE 0)\n+    (UNSPEC_EI 1)\n+    (UNSPEC_DI 2)\n+  ])\n+\n ;; Attributes\n-(define_attr \"type\" \"branch,mem,io,arith,complex,unknown\"\n+(define_attr \"type\" \"branch,call,load,store,io,arith,complex,unknown\"\n \t (const_string \"unknown\") )\n \n ;; If the attribute takes numeric values, no `enum' type will be defined and\n@@ -36,15 +44,16 @@\n (define_cpu_unit \"branch_unit\" \"other\")\n \n (define_insn_reservation \"mem_access\" 2\n-  (eq_attr \"type\" \"mem\")\n+  (ior (eq_attr \"type\" \"load\") (eq_attr \"type\" \"store\"))\n   \"decode_unit+memory_unit*2\")\n \n (define_insn_reservation \"io_access\" 2\n   (eq_attr \"type\" \"io\")\n   \"decode_unit+memory_unit*2\")\n \n (define_insn_reservation \"branch_access\" 2\n-  (eq_attr \"type\" \"branch\")\n+  (ior (eq_attr \"type\" \"branch\")\n+       (eq_attr \"type\" \"call\"))\n   \"decode_unit+branch_unit*2\")\n \n (define_insn_reservation \"arith_access\" 1\n@@ -64,7 +73,8 @@\n ;; the destination of the branch.  Thus, only type that will be acceptable\n ;; (safe) is the arith type.\n \n-(define_delay (eq_attr \"type\" \"branch\")\n+(define_delay (ior (eq_attr \"type\" \"branch\")\n+\t\t   (eq_attr \"type\" \"call\"))\n \t\t [(eq_attr \"type\" \"arith\") (nil) (nil)])\n \n \f\n@@ -79,7 +89,7 @@\n \t (plus:SI (match_dup 0)\n \t\t  (const_int -1)))\n     (clobber (match_scratch:SI 2 \"=X,r\"))]\n-  \"TARGET_MS1_16_003\"\n+  \"TARGET_MS1_16_003 || TARGET_MS2\"\n   \"@\n    dbnz\\t%0, %l1%#\n    #\"\n@@ -98,9 +108,10 @@\n     (set (match_dup 0)\n \t (plus:SI (match_dup 0)\n \t\t  (const_int -1)))]\n-  \"TARGET_MS1_16_003\"\n+  \"TARGET_MS1_16_003 || TARGET_MS2\"\n   \"dbnz\\t%0, %l1%#\"\n-  [(set_attr \"length\" \"4\")]\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"branch\")]\n )\n \n ;; Split the above to handle the case where operand 0 is in memory\n@@ -116,7 +127,7 @@\n \t (plus:SI (match_dup 0)\n \t\t  (const_int -1)))\n     (clobber (match_scratch:SI 2 \"\"))]\n-  \"TARGET_MS1_16_003\"\n+  \"TARGET_MS1_16_003 || TARGET_MS2\"\n   [(set (match_dup 2) (match_dup 0))\n    (set (match_dup 2) (plus:SI (match_dup 2) (const_int -1)))\n    (set (match_dup 0) (match_dup 2))\n@@ -143,7 +154,7 @@\n \t\t(label_ref (match_operand 2 \"\" \"\"))\n \t\t(pc)))\n    ]\n-  \"TARGET_MS1_16_003\"\n+  \"TARGET_MS1_16_003 || TARGET_MS2\"\n   [(parallel [(set (pc)\n \t           (if_then_else\n \t              (ne (match_dup 0) (const_int 0))\n@@ -308,7 +319,7 @@\n    stb %1, %0\n    addi %0, r0, %1\"\n   [(set_attr \"length\" \"4,4,4,4\")\n-   (set_attr \"type\" \"arith,mem,mem,arith\")])\n+   (set_attr \"type\" \"arith,load,store,arith\")])\n \n (define_insn \"*movqi_internal_nobyte\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n@@ -566,7 +577,7 @@\n   nori   %0, r0, %N1\n   ldui   %0, %H1\\;addui %0, %0, %L1\"\n   [(set_attr \"length\" \"4,4,4,4,4,4,4,8\")\n-   (set_attr \"type\" \"arith,mem,mem,arith,arith,arith,arith,complex\")]\n+   (set_attr \"type\" \"arith,load,store,arith,arith,arith,arith,complex\")]\n )\n \n ;; Floating Point Moves\n@@ -641,7 +652,7 @@\n   ldw    %0, %1\n   stw    %1, %0\"\n   [(set_attr \"length\" \"4,4,4\")\n-   (set_attr \"type\" \"arith,mem,mem\")]\n+   (set_attr \"type\" \"arith,load,store\")]\n )\n \n (define_expand \"movdf\"\n@@ -1269,7 +1280,7 @@\n   \"\"\n   \"jal r14, %0%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"register_operand\" \"\")\n@@ -1292,7 +1303,7 @@\n   \"\"\n   \"jal r14, %1%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n ;; Subroutine return\n (define_insn \"return_internal\"\n@@ -1302,7 +1313,7 @@\n   \"\"\n   \"jal r0, r14%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n ;; Interrupt return\n (define_insn \"return_interrupt_internal\"\n@@ -1312,7 +1323,7 @@\n   \"\"\n   \"reti r15%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n ;; Subroutine return\n (define_insn \"eh_return_internal\"\n@@ -1324,7 +1335,7 @@\n   \"\"\n   \"jal r0, r11%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n \n ;; Normal unconditional jump\n@@ -1341,15 +1352,15 @@\n   \"\"\n   \"jal r0,%0%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"register_operand\" \"r\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n   \"\"\n   \"jal r0, %0%#\"\n   [(set_attr \"length\" \"4\")\n-   (set_attr \"type\" \"branch\")])\n+   (set_attr \"type\" \"call\")])\n \n \f\n (define_expand \"prologue\"\n@@ -1412,7 +1423,7 @@\n ;; Pseudo instruction that prevents the scheduler from moving code above this\n ;; point.\n (define_insn \"blockage\"\n-  [(unspec_volatile [(const_int 0)] 0)]\n+  [(unspec_volatile [(const_int 0)] UNSPEC_BLOCKAGE)]\n   \"\"\n   \"\"\n   [(set_attr \"length\" \"0\")])\n@@ -1442,14 +1453,14 @@\n \n ;; Enable interrupts template\n (define_insn \"ei\"\n-  [(unspec_volatile [(const_int 0)] 1)]\n+  [(unspec_volatile [(const_int 0)] UNSPEC_EI)]\n   \"\"\n   \"ei\"\n   [(set_attr \"length\" \"4\")])\n \n ;; Enable interrupts template\n (define_insn \"di\"\n-  [(unspec_volatile [(const_int 0)] 2)]\n+  [(unspec_volatile [(const_int 0)] UNSPEC_DI)]\n   \"\"\n   \"di\"\n   [(set_attr \"length\" \"4\")])"}]}