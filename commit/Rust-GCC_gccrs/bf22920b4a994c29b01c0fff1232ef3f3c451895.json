{"sha": "bf22920b4a994c29b01c0fff1232ef3f3c451895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmYyMjkyMGI0YTk5NGMyOWIwMWMwZmZmMTIzMmVmM2YzYzQ1MTg5NQ==", "commit": {"author": {"name": "Tom de Vries", "email": "tom@codesourcery.com", "date": "2011-04-07T09:48:39Z"}, "committer": {"name": "Tom de Vries", "email": "vries@gcc.gnu.org", "date": "2011-04-07T09:48:39Z"}, "message": "re PR target/43920 (Choosing conditional execution over conditional branches for code size in some cases.)\n\n2011-04-07  Tom de Vries  <tom@codesourcery.com>\n\n\tPR target/43920\n\t* cfgcleanup.c (try_crossjump_to_edge): Add dir parameter.  Pass dir to\n\tflow_find_cross_jump.  Swap variables to implement backward replacement.\n\t(try_crossjump_bb): Add argument to try_crossjump_to_edge.\n\nFrom-SVN: r172094", "tree": {"sha": "591d7b9423c639aa975cf97c2542040d0ea39196", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/591d7b9423c639aa975cf97c2542040d0ea39196"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bf22920b4a994c29b01c0fff1232ef3f3c451895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf22920b4a994c29b01c0fff1232ef3f3c451895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf22920b4a994c29b01c0fff1232ef3f3c451895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf22920b4a994c29b01c0fff1232ef3f3c451895/comments", "author": null, "committer": null, "parents": [{"sha": "c7a69ce198cb28d64bfb2864fb6d3a1d57df5a7d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7a69ce198cb28d64bfb2864fb6d3a1d57df5a7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7a69ce198cb28d64bfb2864fb6d3a1d57df5a7d"}], "stats": {"total": 34, "additions": 27, "deletions": 7}, "files": [{"sha": "7d80ceaf10e92e4dbab5f1b6f9f0eb4709022359", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf22920b4a994c29b01c0fff1232ef3f3c451895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf22920b4a994c29b01c0fff1232ef3f3c451895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bf22920b4a994c29b01c0fff1232ef3f3c451895", "patch": "@@ -1,3 +1,10 @@\n+2011-04-07  Tom de Vries  <tom@codesourcery.com>\n+\n+\tPR target/43920\n+\t* cfgcleanup.c (try_crossjump_to_edge): Add dir parameter.  Pass dir to\n+\tflow_find_cross_jump.  Swap variables to implement backward replacement.\n+\t(try_crossjump_bb): Add argument to try_crossjump_to_edge.\n+\n 2011-04-07  Tom de Vries  <tom@codesourcery.com>\n \n \tPR target/43920"}, {"sha": "98c51ad2573fd65e9c6593000b75dc877e828cc2", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bf22920b4a994c29b01c0fff1232ef3f3c451895/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bf22920b4a994c29b01c0fff1232ef3f3c451895/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=bf22920b4a994c29b01c0fff1232ef3f3c451895", "patch": "@@ -69,7 +69,7 @@ static bool crossjumps_occured;\n    information; we should run df_analyze to enable more opportunities.  */\n static bool block_was_dirty;\n \n-static bool try_crossjump_to_edge (int, edge, edge);\n+static bool try_crossjump_to_edge (int, edge, edge, enum replace_direction);\n static bool try_crossjump_bb (int, basic_block);\n static bool outgoing_edges_match (int, basic_block, basic_block);\n static enum replace_direction old_insns_match_p (int, rtx, rtx);\n@@ -1761,16 +1761,18 @@ block_has_preserve_label (basic_block bb)\n \n /* E1 and E2 are edges with the same destination block.  Search their\n    predecessors for common code.  If found, redirect control flow from\n-   (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC.  */\n+   (maybe the middle of) E1->SRC to (maybe the middle of) E2->SRC (dir_forward),\n+   or the other way around (dir_backward).  DIR specifies the allowed\n+   replacement direction.  */\n \n static bool\n-try_crossjump_to_edge (int mode, edge e1, edge e2)\n+try_crossjump_to_edge (int mode, edge e1, edge e2,\n+                       enum replace_direction dir)\n {\n   int nmatch;\n   basic_block src1 = e1->src, src2 = e2->src;\n   basic_block redirect_to, redirect_from, to_remove;\n   basic_block osrc1, osrc2, redirect_edges_to, tmp;\n-  enum replace_direction dir;\n   rtx newpos1, newpos2;\n   edge s;\n   edge_iterator ei;\n@@ -1826,7 +1828,6 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n     return false;\n \n   /* ... and part the second.  */\n-  dir = dir_forward;\n   nmatch = flow_find_cross_jump (src1, src2, &newpos1, &newpos2, &dir);\n \n   osrc1 = src1;\n@@ -1836,6 +1837,16 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   if (newpos2 != NULL_RTX)\n     src2 = BLOCK_FOR_INSN (newpos2);\n \n+  if (dir == dir_backward)\n+    {\n+#define SWAP(T, X, Y) do { T tmp = (X); (X) = (Y); (Y) = tmp; } while (0)\n+      SWAP (basic_block, osrc1, osrc2);\n+      SWAP (basic_block, src1, src2);\n+      SWAP (edge, e1, e2);\n+      SWAP (rtx, newpos1, newpos2);\n+#undef SWAP\n+    }\n+\n   /* Don't proceed with the crossjump unless we found a sufficient number\n      of matching instructions or the 'from' block was totally matched\n      (such that its predecessors will hopefully be redirected and the\n@@ -2088,7 +2099,7 @@ try_crossjump_bb (int mode, basic_block bb)\n \t\t   || (fallthru->src->flags & BB_MODIFIED)))\n \t    continue;\n \n-\t  if (try_crossjump_to_edge (mode, e, fallthru))\n+\t  if (try_crossjump_to_edge (mode, e, fallthru, dir_forward))\n \t    {\n \t      changed = true;\n \t      ix = 0;\n@@ -2136,7 +2147,9 @@ try_crossjump_bb (int mode, basic_block bb)\n \t\t   || (e2->src->flags & BB_MODIFIED)))\n \t    continue;\n \n-\t  if (try_crossjump_to_edge (mode, e, e2))\n+\t  /* Both e and e2 are not fallthru edges, so we can crossjump in either\n+\t     direction.  */\n+\t  if (try_crossjump_to_edge (mode, e, e2, dir_both))\n \t    {\n \t      changed = true;\n \t      ix = 0;"}]}