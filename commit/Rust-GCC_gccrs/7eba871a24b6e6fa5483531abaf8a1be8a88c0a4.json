{"sha": "7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ViYTg3MWEyNGI2ZTZmYTU0ODM1MzFhYmFmOGExYmU4YTg4YzBhNA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-30T09:46:02Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-11-30T09:46:02Z"}, "message": "coretypes.h (struct pretty_print_info): Make a coretype.\n\n\t* coretypes.h (struct pretty_print_info): Make a coretype.\n\t(typedef pretty_printer): Likewise.\n\t* pretty-print.h (typedef pretty_printer): Not needed here anymore.\n\t* pretty-print.c (pp_write_text_as_dot_label_to_stream): New function.\n\t* rtl.h (str_pattern_slim): New prototype.\n\t(print_value, print_pattern, print_insn): Adjust prototypes to take\n\ta pretty-printer rather than a char buffer.\n\t* sched-vis.c (safe_concat): Remove.\n\t(print_exp): Print into a pretty-printer.\n\t(print_value): Likewise.\n\t(print_pattern): Likewise.\n\t(print_insn): Likewise.\n\t(print_insn_with_notes): New static function.\n\t(init_rtl_slim_pretty_print): New function.\n\t(dump_value_slim): Simplify.  Print into and flush a pretty-printer.\n\t(dump_insn_slim): Likewise.\n\t(dump_rtl_slim): Likewise.\n\t(str_pattern_slim): New function.\n\t* haifa-sched.c (model_recompute): Use str_pattern_slim instead of\n\tstatic buffers.\n\t(model_record_pressures): Likewise.\n\t(schedule_insn): Likewise.\n\t* sel-sched-dump.c (dump_insn_rtx_1): Likewise.\n\t(sel_prepare_string_for_dot_label): Refer to graph.c CFG dumper code.\n\t* graph.c: Include pretty-print.h.\n\t(init_graph_slim_pretty_print): New function.\n\t(print_escaped_line): Removed here, and reincarnated as\n\tpp_write_text_as_dot_label_to_stream.\n\t(draw_cfg_node): Print into a pretty printer.\n\t(draw_cfg_node_succ_edges): Likewise.\n\t(print_rtl_graph_with_bb): Likewise.\n\t* Makefile.in (graph.o): Fix dependencies.\n\t(tree-optimize.o, toplev.o, sched-vis.o): Likewise.\n\nFrom-SVN: r193990", "tree": {"sha": "4b15801bec76c3248ce31b82175d9ddd088a20d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b15801bec76c3248ce31b82175d9ddd088a20d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/comments", "author": null, "committer": null, "parents": [{"sha": "7a36dc06de2219590b17a8a06d0d4cac9bbadd7f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a36dc06de2219590b17a8a06d0d4cac9bbadd7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a36dc06de2219590b17a8a06d0d4cac9bbadd7f"}], "stats": {"total": 693, "additions": 374, "deletions": 319}, "files": [{"sha": "eb3296db557f528c38cbf41d6c064886271bcc2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -1,3 +1,39 @@\n+2012-11-30  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* coretypes.h (struct pretty_print_info): Make a coretype.\n+\t(typedef pretty_printer): Likewise.\n+\t* pretty-print.h (typedef pretty_printer): Not needed here anymore.\n+\t* pretty-print.c (pp_write_text_as_dot_label_to_stream): New function.\n+\t* rtl.h (str_pattern_slim): New prototype.\n+\t(print_value, print_pattern, print_insn): Adjust prototypes to take\n+\ta pretty-printer rather than a char buffer.\n+\t* sched-vis.c (safe_concat): Remove.\n+\t(print_exp): Print into a pretty-printer.\n+\t(print_value): Likewise.\n+\t(print_pattern): Likewise.\n+\t(print_insn): Likewise.\n+\t(print_insn_with_notes): New static function.\n+\t(init_rtl_slim_pretty_print): New function.\n+\t(dump_value_slim): Simplify.  Print into and flush a pretty-printer.\n+\t(dump_insn_slim): Likewise.\n+\t(dump_rtl_slim): Likewise.\n+\t(str_pattern_slim): New function.\n+\t* haifa-sched.c (model_recompute): Use str_pattern_slim instead of\n+\tstatic buffers.\n+\t(model_record_pressures): Likewise.\n+\t(schedule_insn): Likewise.\n+\t* sel-sched-dump.c (dump_insn_rtx_1): Likewise.\n+\t(sel_prepare_string_for_dot_label): Refer to graph.c CFG dumper code.\n+\t* graph.c: Include pretty-print.h.\n+\t(init_graph_slim_pretty_print): New function.\n+\t(print_escaped_line): Removed here, and reincarnated as\n+\tpp_write_text_as_dot_label_to_stream.\n+\t(draw_cfg_node): Print into a pretty printer.\n+\t(draw_cfg_node_succ_edges): Likewise.\n+\t(print_rtl_graph_with_bb): Likewise.\n+\t* Makefile.in (graph.o): Fix dependencies.\n+\t(tree-optimize.o, toplev.o, sched-vis.o): Likewise.\n+\n 2012-11-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* tsan.c (is_load_of_const_p): Removed."}, {"sha": "abb0648a635d67131b0456c0f7e774f7de18c306", "filename": "gcc/Makefile.in", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -1845,9 +1845,8 @@ srcextra: gcc.srcextra lang.srcextra\n gcc.srcextra: gengtype-lex.c\n \t-cp -p $^ $(srcdir)\n \n-graph.o: graph.c $(SYSTEM_H) coretypes.h $(TM_H) toplev.h $(DIAGNOSTIC_CORE_H) $(FLAGS_H) \\\n-    $(RTL_H) $(FUNCTION_H) hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(OBSTACK_H) \\\n-    $(CONFIG_H) $(EMIT_RTL_H)\n+graph.o: graph.c graph.h $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+    $(DIAGNOSTIC_CORE_H) $(TM_H) $(RTL_H) $(BASIC_BLOCK_H) $(PRETTY_PRINT_H)\n \n sbitmap.o: sbitmap.c sbitmap.h $(CONFIG_H) $(SYSTEM_H) coretypes.h\n sparseset.o: sparseset.c $(SYSTEM_H) sparseset.h $(CONFIG_H)\n@@ -2509,7 +2508,7 @@ tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(DIAGNOSTIC_H) $(BASIC_BLOCK_H) $(FLAGS_H) $(TM_H) \\\n    coretypes.h toplev.h $(DIAGNOSTIC_CORE_H) $(FUNCTION_H) langhooks.h \\\n    $(FLAGS_H) $(CGRAPH_H) $(PLUGIN_H) \\\n-   $(TREE_INLINE_H) $(GGC_H) graph.h $(CGRAPH_H) \\\n+   $(TREE_INLINE_H) $(GGC_H) $(CGRAPH_H) \\\n    $(TREE_PASS_H) $(CFGLOOP_H) $(EXCEPT_H)\n \n gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(GIMPLE_H) \\\n@@ -2691,7 +2690,7 @@ toplev.o : toplev.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    version.h $(RTL_H) $(FUNCTION_H) $(FLAGS_H) xcoffout.h $(INPUT_H) \\\n    $(INSN_ATTR_H) output.h $(DIAGNOSTIC_H) debug.h insn-config.h intl.h \\\n    $(RECOG_H) Makefile toplev.h sdbout.h dbxout.h $(EXPR_H) \\\n-   hard-reg-set.h $(BASIC_BLOCK_H) graph.h $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) \\\n+   hard-reg-set.h $(BASIC_BLOCK_H) $(EXCEPT_H) $(REGS_H) $(TIMEVAR_H) \\\n    value-prof.h $(PARAMS_H) $(TM_P_H) reload.h ira.h dwarf2asm.h $(TARGET_H) \\\n    langhooks.h insn-flags.h $(CFGLOOP_H) hosthooks.h \\\n    $(CGRAPH_H) $(COVERAGE_H) alloc-pool.h $(GGC_H) \\\n@@ -3333,8 +3332,7 @@ sched-ebb.o : sched-ebb.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(FUNCTION_H) $(INSN_ATTR_H) $(DIAGNOSTIC_CORE_H) $(RECOG_H) $(EXCEPT_H) $(TM_P_H) \\\n    $(PARAMS_H) $(TARGET_H)\n sched-vis.o : sched-vis.c $(CONFIG_H) $(SYSTEM_H) coretypes.h dumpfile.h $(TM_H) \\\n-   $(RTL_H) $(SCHED_INT_H) hard-reg-set.h $(BASIC_BLOCK_H) $(OBSTACK_H) \\\n-   $(INSN_ATTR_H) $(TREE_H)\n+   $(INSN_ATTR_H) $(RTL_H) $(TREE_H) $(BASIC_BLOCK_H) $(PRETTY_PRINT_H)\n sel-sched.o : sel-sched.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(RTL_ERROR_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \\\n    $(FUNCTION_H) $(INSN_ATTR_H)  $(RECOG_H) $(EXCEPT_H) $(PARAMS_H) \\"}, {"sha": "4672877503aa0a30826ba20b03df1886b9c2d21e", "filename": "gcc/coretypes.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -58,10 +58,11 @@ typedef struct rtvec_def *rtvec;\n typedef const struct rtvec_def *const_rtvec;\n union tree_node;\n typedef union tree_node *tree;\n+typedef const union tree_node *const_tree;\n union gimple_statement_d;\n typedef union gimple_statement_d *gimple;\n-typedef const union tree_node *const_tree;\n typedef const union gimple_statement_d *const_gimple;\n+typedef gimple gimple_seq;\n union section;\n typedef union section section;\n struct gcc_options;\n@@ -72,7 +73,8 @@ struct cl_decoded_option;\n struct cl_option_handlers;\n struct diagnostic_context;\n typedef struct diagnostic_context diagnostic_context;\n-typedef gimple gimple_seq;\n+struct pretty_print_info;\n+typedef struct pretty_print_info pretty_printer;\n \n /* Address space number for named address space support.  */\n typedef unsigned char addr_space_t;"}, {"sha": "a908e60baef6a1c03fe1ff12d3e94d4fc6d10c1c", "filename": "gcc/graph.c", "status": "modified", "additions": 58, "deletions": 66, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraph.c?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -29,6 +29,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"graph.h\"\n+#include \"pretty-print.h\"\n \n /* DOT files with the .dot extension are recognized as document templates\n    by a well-known piece of word processing software out of Redmond, WA.\n@@ -56,45 +57,30 @@ open_graph_file (const char *base, const char *mode)\n   return fp;\n }\n \n-/* Print the output from print_insn or print_pattern with GraphViz-special\n-   characters escaped as necessary.  */\n-void\n-print_escaped_line (FILE *fp, const char *buf)\n+/* Return a pretty-print buffer for output to file FP.  */\n+\n+static pretty_printer *\n+init_graph_slim_pretty_print (FILE *fp)\n {\n-  const char *p = buf;\n+  static bool initialized = false;\n+  static pretty_printer graph_slim_pp;\n \n-  while (*p)\n+  if (! initialized)\n     {\n-      switch (*p)\n-\t{\n-\tcase '\\n':\n-\t  /* Print newlines as a left-aligned newline.  */\n-\t  fputs (\"\\\\l\\\\\\n\", fp);\n-\t  break;\n-\n-\tcase '{':\n-\tcase '}':\n-\tcase '<':\n-\tcase '>':\n-\tcase '|':\n-\tcase '\"':\n-\tcase ' ':\n-\t  /* These characters have to be escaped to work with record-shape nodes.  */\n-\t  fputc ('\\\\', fp);\n-\t  /* fall through */\n-\tdefault:\n-\t  fputc (*p, fp);\n-\t  break;\n-\t}\n-      p++;\n+      pp_construct (&graph_slim_pp, /*prefix=*/NULL, /*linewidth=*/0);\n+      initialized = true;\n     }\n-  fputs (\"\\\\l\\\\\\n\", fp);\n+  else\n+    gcc_assert (! pp_last_position_in_text (&graph_slim_pp));\n+\n+  graph_slim_pp.buffer->stream = fp;\n+  return &graph_slim_pp;\n }\n \n /* Draw a basic block BB belonging to the function with FNDECL_UID\n    as its unique number.  */\n static void\n-draw_cfg_node (FILE *fp, int fndecl_uid, basic_block bb)\n+draw_cfg_node (pretty_printer *pp, int fndecl_uid, basic_block bb)\n {\n   rtx insn;\n   bool first = true;\n@@ -115,48 +101,53 @@ draw_cfg_node (FILE *fp, int fndecl_uid, basic_block bb)\n \t: \"lightgrey\";\n     }\n \n-  fprintf (fp,\n-\t   \"\\tfn_%d_basic_block_%d [shape=%s,style=filled,fillcolor=%s,label=\\\"\",\n-\t   fndecl_uid, bb->index, shape, fillcolor);\n+  pp_printf (pp,\n+\t     \"\\tfn_%d_basic_block_%d \"\n+\t     \"[shape=%s,style=filled,fillcolor=%s,label=\\\"\",\n+\t     fndecl_uid, bb->index, shape, fillcolor);\n \n   if (bb->index == ENTRY_BLOCK)\n-    fputs (\"ENTRY\", fp);\n+    pp_string (pp, \"ENTRY\");\n   else if (bb->index == EXIT_BLOCK)\n-    fputs (\"EXIT\", fp);\n+    pp_string (pp, \"EXIT\");\n   else\n     {\n-      fputc ('{', fp);\n+      pp_character (pp, '{');\n+      pp_write_text_to_stream (pp);\n+\n       /* TODO: inter-bb stuff.  */\n       FOR_BB_INSNS (bb, insn)\n \t{\n-\t  char buf[2048];\n-\n \t  if (! first)\n-\t    fputc ('|', fp);\n+\t    {\n+\t      pp_character (pp, '|');\n+\t      pp_write_text_to_stream (pp);\n+\t    }\n+\t  first = false;\n \n-\t  print_insn (buf, insn, 1);\n-\t  print_escaped_line (fp, buf);\n+\t  print_insn (pp, insn, 1);\n+\t  pp_newline (pp);\n \t  if (INSN_P (insn) && REG_NOTES (insn))\n \t    for (rtx note = REG_NOTES (insn); note; note = XEXP (note, 1))\n \t      {\n-\t\tfprintf (fp, \"      %s: \",\n-\t\t\t GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n-\t\tprint_pattern (buf, XEXP (note, 0), 1);\n-\t\tprint_escaped_line (fp, buf);\n+\t\tpp_printf (pp, \"      %s: \",\n+\t\t\t   GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n+\t\tprint_pattern (pp, XEXP (note, 0), 1);\n+\t\tpp_newline (pp);\n \t      }\n-\n-\t  first = false;\n+\t  pp_write_text_as_dot_label_to_stream (pp, /*for_record=*/true);\n \t}\n-      fputc ('}', fp);\n+      pp_character (pp, '}');\n     }\n \n-  fputs (\"\\\"];\\n\\n\", fp);\n+  pp_string (pp, \"\\\"];\\n\\n\");\n+  pp_flush (pp);\n }\n \n /* Draw all successor edges of a basic block BB belonging to the function\n    with FNDECL_UID as its unique number.  */\n static void\n-draw_cfg_node_succ_edges (FILE *fp, int fndecl_uid, basic_block bb)\n+draw_cfg_node_succ_edges (pretty_printer *pp, int fndecl_uid, basic_block bb)\n {\n   edge e;\n   edge_iterator ei;\n@@ -187,14 +178,15 @@ draw_cfg_node_succ_edges (FILE *fp, int fndecl_uid, basic_block bb)\n       if (e->flags & EDGE_ABNORMAL)\n \tcolor = \"red\";\n \n-      fprintf (fp,\n-\t       \"\\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n \"\n-\t       \"[style=%s,color=%s,weight=%d,constraint=%s];\\n\",\n-\t       fndecl_uid, e->src->index,\n-\t       fndecl_uid, e->dest->index,\n-\t       style, color, weight,\n-\t       (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? \"false\" : \"true\");\n+      pp_printf (pp,\n+\t\t \"\\tfn_%d_basic_block_%d:s -> fn_%d_basic_block_%d:n \"\n+\t\t \"[style=%s,color=%s,weight=%d,constraint=%s];\\n\",\n+\t\t fndecl_uid, e->src->index,\n+\t\t fndecl_uid, e->dest->index,\n+\t\t style, color, weight,\n+\t\t (e->flags & (EDGE_FAKE | EDGE_DFS_BACK)) ? \"false\" : \"true\");\n     }\n+  pp_flush (pp);\n }\n \n /* Print a graphical representation of the CFG of function FUN.\n@@ -208,19 +200,19 @@ print_rtl_graph_with_bb (const char *base, tree fndecl)\n   int *rpo = XNEWVEC (int, n_basic_blocks);\n   basic_block bb;\n   int i, n;\n+  pretty_printer *pp = init_graph_slim_pretty_print (fp);\n \n-  fprintf (fp,\n-\t   \"subgraph \\\"%s\\\" {\\n\"\n-\t   \"\\tcolor=\\\"black\\\";\\n\"\n-\t   \"\\tlabel=\\\"%s\\\";\\n\",\n-\t   funcname, funcname);\n+  pp_printf (pp, \"subgraph \\\"%s\\\" {\\n\"\n+\t         \"\\tcolor=\\\"black\\\";\\n\"\n+\t\t \"\\tlabel=\\\"%s\\\";\\n\",\n+\t\t funcname, funcname);\n \n   /* First print all basic blocks.\n      Visit the blocks in reverse post order to get a good ranking\n      of the nodes.  */\n   n = pre_and_rev_post_order_compute (NULL, rpo, true);\n   for (i = 0; i < n; i++)\n-    draw_cfg_node (fp, fndecl_uid, BASIC_BLOCK (rpo[i]));\n+    draw_cfg_node (pp, fndecl_uid, BASIC_BLOCK (rpo[i]));\n \n   /* Draw all edges at the end to get subgraphs right for GraphViz,\n      which requires nodes to be defined before edges to cluster\n@@ -232,10 +224,10 @@ print_rtl_graph_with_bb (const char *base, tree fndecl)\n      for ourselves is also not desirable.)  */\n   mark_dfs_back_edges ();\n   FOR_ALL_BB (bb)\n-    draw_cfg_node_succ_edges (fp, fndecl_uid, bb);\n-\n-  fputs (\"\\t}\\n\", fp);\n+    draw_cfg_node_succ_edges (pp, fndecl_uid, bb);\n \n+  pp_printf (pp, \"\\t}\\n\");\n+  pp_flush (pp);\n   fclose (fp);\n }\n "}, {"sha": "ad7e08eb00ab84fa8a4a3cd50ba463b04faf6ef7", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 6, "deletions": 13, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -2168,8 +2168,6 @@ model_recompute (rtx insn)\n \n \t    if (sched_verbose >= 5)\n \t      {\n-\t\tchar buf[2048];\n-\n \t\tif (!print_p)\n \t\t  {\n \t\t    fprintf (sched_dump, MODEL_BAR);\n@@ -2179,9 +2177,9 @@ model_recompute (rtx insn)\n \t\t    print_p = true;\n \t\t  }\n \n-\t\tprint_pattern (buf, PATTERN (insn), 0);\n \t\tfprintf (sched_dump, \";;\\t\\t| %3d %4d %-30s \",\n-\t\t\t point, INSN_UID (insn), buf);\n+\t\t\t point, INSN_UID (insn),\n+\t\t\t str_pattern_slim (PATTERN (insn)));\n \t\tfor (pci = 0; pci < ira_pressure_classes_num; pci++)\n \t\t  {\n \t\t    cl = ira_pressure_classes[pci];\n@@ -3343,18 +3341,16 @@ model_record_pressures (struct model_insn_info *insn)\n   point = model_index (insn->insn);\n   if (sched_verbose >= 2)\n     {\n-      char buf[2048];\n-\n       if (point == 0)\n \t{\n \t  fprintf (sched_dump, \"\\n;;\\tModel schedule:\\n;;\\n\");\n \t  fprintf (sched_dump, \";;\\t| idx insn | mpri hght dpth prio |\\n\");\n \t}\n-      print_pattern (buf, PATTERN (insn->insn), 0);\n       fprintf (sched_dump, \";;\\t| %3d %4d | %4d %4d %4d %4d | %-30s \",\n \t       point, INSN_UID (insn->insn), insn->model_priority,\n \t       insn->depth + insn->alap, insn->depth,\n-\t       INSN_PRIORITY (insn->insn), buf);\n+\t       INSN_PRIORITY (insn->insn),\n+\t       str_pattern_slim (PATTERN (insn->insn)));\n     }\n   calculate_reg_deaths (insn->insn, death);\n   reg_pressure = INSN_REG_PRESSURE (insn->insn);\n@@ -3715,12 +3711,9 @@ schedule_insn (rtx insn)\n   if (sched_verbose >= 1)\n     {\n       struct reg_pressure_data *pressure_info;\n-      char buf[2048];\n-\n-      print_insn (buf, insn, 0);\n-      buf[40] = 0;\n       fprintf (sched_dump, \";;\\t%3i--> %s%-40s:\",\n-\t       clock_var, (*current_sched_info->print_insn) (insn, 1), buf);\n+\t       clock_var, (*current_sched_info->print_insn) (insn, 1),\n+\t       str_pattern_slim (PATTERN (insn)));\n \n       if (recog_memoized (insn) < 0)\n \tfprintf (sched_dump, \"nothing\");"}, {"sha": "198e0425b9bfee6a7d6b127a84650c8e87c5e40f", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -99,6 +99,58 @@ pp_write_text_to_stream (pretty_printer *pp)\n   pp_clear_output_area (pp);\n }\n \n+/* As pp_write_text_to_stream, but for GraphViz label output.\n+\n+   Flush the formatted text of pretty-printer PP onto the attached stream.\n+   Replace characters in PPF that have special meaning in a GraphViz .dot\n+   file.\n+   \n+   This routine is not very fast, but it doesn't have to be as this is only\n+   be used by routines dumping intermediate representations in graph form.  */\n+\n+void\n+pp_write_text_as_dot_label_to_stream (pretty_printer *pp, bool for_record)\n+{\n+  const char *text = pp_formatted_text (pp);\n+  const char *p = text;\n+  FILE *fp = pp->buffer->stream;\n+\n+  while (*p)\n+    {\n+      switch (*p)\n+\t{\n+\t/* Print newlines as a left-aligned newline.  */\n+\tcase '\\n':\n+\t  fputs (\"\\\\l\\\\\\n\", fp);\n+\t  break;\n+\n+\t/* A pipe is only special for record-shape nodes.  */\n+\tcase '|':\n+\t  if (for_record)\n+\t    fputc ('\\\\', fp);\n+\t  fputc (*p, fp);\n+\t  break;\n+\n+\t/* The following characters always have to be escaped\n+\t   for use in labels.  */\n+\tcase '{':\n+\tcase '}':\n+\tcase '<':\n+\tcase '>':\n+\tcase '\"':\n+\tcase ' ':\n+\t  fputc ('\\\\', fp);\n+\t  /* fall through */\n+\tdefault:\n+\t  fputc (*p, fp);\n+\t  break;\n+\t}\n+      p++;\n+    }\n+\n+  pp_clear_output_area (pp);\n+}\n+\n /* Wrap a text delimited by START and END into PRETTY-PRINTER.  */\n static void\n pp_wrap_text (pretty_printer *pp, const char *start, const char *end)"}, {"sha": "8bd95ff8d9301b2b982a9e359871e2baf3a18aae", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -132,7 +132,6 @@ typedef struct\n /* The type of a hook that formats client-specific data onto a pretty_pinter.\n    A client-supplied formatter returns true if everything goes well,\n    otherwise it returns false.  */\n-typedef struct pretty_print_info pretty_printer;\n typedef bool (*printer_fn) (pretty_printer *, text_info *, const char *,\n \t\t\t    int, bool, bool, bool);\n \n@@ -343,7 +342,8 @@ extern void pp_base_indent (pretty_printer *);\n extern void pp_base_newline (pretty_printer *);\n extern void pp_base_character (pretty_printer *, int);\n extern void pp_base_string (pretty_printer *, const char *);\n-extern void pp_write_text_to_stream (pretty_printer *pp);\n+extern void pp_write_text_to_stream (pretty_printer *);\n+extern void pp_write_text_as_dot_label_to_stream (pretty_printer *, bool);\n extern void pp_base_maybe_space (pretty_printer *);\n \n /* Switch into verbatim mode and return the old mode.  */"}, {"sha": "0eccaf2e8063cc00f3cf7c245ad1355294584bf5", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -2597,16 +2597,16 @@ extern int print_rtl_single (FILE *, const_rtx);\n extern int print_rtl_single_with_indent (FILE *, const_rtx, int);\n extern void print_inline_rtx (FILE *, const_rtx, int);\n \n-/* Functions in sched-vis.c.  These must be outside INSN_SCHEDULING as\n-   sched-vis.c is compiled always.  FIXME: Ideally these functions would\n+/* Functions in sched-vis.c.  FIXME: Ideally these functions would\n    not be in sched-vis.c but in rtl.c, because they are not only used\n    by the scheduler anymore but for all \"slim\" RTL dumping.  */\n extern void dump_value_slim (FILE *, const_rtx, int);\n extern void dump_insn_slim (FILE *, const_rtx);\n extern void dump_rtl_slim (FILE *, const_rtx, const_rtx, int, int);\n-extern void print_value (char *, const_rtx, int);\n-extern void print_pattern (char *, const_rtx, int);\n-extern void print_insn (char *, const_rtx, int);\n+extern void print_value (pretty_printer *, const_rtx, int);\n+extern void print_pattern (pretty_printer *, const_rtx, int);\n+extern void print_insn (pretty_printer *, const_rtx, int);\n+extern const char *str_pattern_slim (const_rtx);\n \n /* In function.c */\n extern void reposition_prologue_and_epilogue_notes (void);"}, {"sha": "3e5a74dcf53f64b4da7abc60199dddf1fa1a7334", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 202, "deletions": 217, "changes": 419, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -30,50 +30,41 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\t/* FIXME: To dump INSN_VAR_LOCATION_DECL.  */\n-#include \"obstack.h\"\n-#include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n-#include \"insn-attr.h\"\n #include \"dumpfile.h\"\t/* for the TDF_* flags */\n-\n-static char *safe_concat (char *, char *, const char *);\n-\n-#define BUF_LEN 2048\n-\n-static char *\n-safe_concat (char *buf, char *cur, const char *str)\n-{\n-  char *end = buf + BUF_LEN - 2;\t/* Leave room for null.  */\n-  int c;\n-\n-  if (cur > end)\n-    {\n-      *end = '\\0';\n-      return end;\n-    }\n-\n-  while (cur < end && (c = *str++) != '\\0')\n-    *cur++ = c;\n-\n-  *cur = '\\0';\n-  return cur;\n-}\n-\n-/* This recognizes rtx, I classified as expressions.  These are always\n+#include \"pretty-print.h\"\n+\n+/* The functions in this file try to print RTL in a form resembling assembler\n+   mnemonics.  Because this form is more concise than the \"traditional\" form\n+   of RTL printing in Lisp-style, the form printed by this file is called\n+   \"slim\".  RTL dumps in slim format can be obtained by appending the \"-slim\"\n+   option to -fdump-rtl-<pass>.  Control flow graph output as a DOT file is\n+   always printed in slim form.\n+\n+   The normal interface to the functionality provided in this pretty-printer\n+   is through the dump_*_slim functions to print to a stream, or via the\n+   print_*_slim functions to print into a user's pretty-printer.\n+   \n+   It is also possible to obtain a string for a single pattern as a string\n+   pointer, via str_pattern_slim, but this usage is discouraged.  */\n+\n+/* A pretty-printer for slim rtl printing.  */\n+static bool rtl_slim_pp_initialized = false;\n+static pretty_printer rtl_slim_pp;\n+\n+/* This recognizes rtx'en classified as expressions.  These are always\n    represent some action on values or results of other expression, that\n    may be stored in objects representing values.  */\n \n static void\n-print_exp (char *buf, const_rtx x, int verbose)\n+print_exp (pretty_printer *pp, const_rtx x, int verbose)\n {\n-  char tmp[BUF_LEN];\n   const char *st[4];\n-  char *cur = buf;\n-  const char *fun = (char *) 0;\n-  const char *sep;\n+  const char *fun;\n   rtx op[4];\n   int i;\n \n+  fun = (char *) 0;\n   for (i = 0; i < 4; i++)\n     {\n       st[i] = (char *) 0;\n@@ -351,21 +342,18 @@ print_exp (char *buf, const_rtx x, int verbose)\n     case UNSPEC:\n     case UNSPEC_VOLATILE:\n       {\n-\tcur = safe_concat (buf, cur, \"unspec\");\n+\tpp_string (pp, \"unspec\");\n \tif (GET_CODE (x) == UNSPEC_VOLATILE)\n-\t  cur = safe_concat (buf, cur, \"/v\");\n-\tcur = safe_concat (buf, cur, \"[\");\n-\tsep = \"\";\n+\t  pp_string (pp, \"/v\");\n+\tpp_character (pp, '[');\n \tfor (i = 0; i < XVECLEN (x, 0); i++)\n \t  {\n-\t    print_pattern (tmp, XVECEXP (x, 0, i), verbose);\n-\t    cur = safe_concat (buf, cur, sep);\n-\t    cur = safe_concat (buf, cur, tmp);\n-\t    sep = \",\";\n+\t    if (i != 0)\n+\t      pp_character (pp, ',');\n+\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n \t  }\n-\tcur = safe_concat (buf, cur, \"] \");\n-\tsprintf (tmp, \"%d\", XINT (x, 1));\n-\tcur = safe_concat (buf, cur, tmp);\n+\tpp_string (pp, \"] \");\n+\tpp_decimal_int (pp, XINT (x, 1));\n       }\n       break;\n     default:\n@@ -402,266 +390,213 @@ print_exp (char *buf, const_rtx x, int verbose)\n   /* Print this as a function?  */\n   if (fun)\n     {\n-      cur = safe_concat (buf, cur, fun);\n-      cur = safe_concat (buf, cur, \"(\");\n+      pp_string (pp, fun);\n+      pp_character (pp, '(');\n     }\n \n   for (i = 0; i < 4; i++)\n     {\n       if (st[i])\n-\tcur = safe_concat (buf, cur, st[i]);\n+        pp_string (pp, st[i]);\n \n       if (op[i])\n \t{\n \t  if (fun && i != 0)\n-\t    cur = safe_concat (buf, cur, \",\");\n-\n-\t  print_value (tmp, op[i], verbose);\n-\t  cur = safe_concat (buf, cur, tmp);\n+\t    pp_character (pp, ',');\n+\t  print_value (pp, op[i], verbose);\n \t}\n     }\n \n   if (fun)\n-    cur = safe_concat (buf, cur, \")\");\n+    pp_character (pp, ')');\n }\t\t/* print_exp */\n \n /* Prints rtxes, I customarily classified as values.  They're constants,\n    registers, labels, symbols and memory accesses.  */\n \n void\n-print_value (char *buf, const_rtx x, int verbose)\n+print_value (pretty_printer *pp, const_rtx x, int verbose)\n {\n-  char t[BUF_LEN];\n-  char *cur = buf;\n+  char tmp[1024];\n \n   if (!x)\n     {\n-      safe_concat (buf, buf, \"(nil)\");\n+      pp_string (pp, \"(nil)\");\n       return;\n     }\n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n-      sprintf (t, HOST_WIDE_INT_PRINT_HEX,\n-\t       (unsigned HOST_WIDE_INT) INTVAL (x));\n-      cur = safe_concat (buf, cur, t);\n+      pp_scalar (pp, HOST_WIDE_INT_PRINT_HEX,\n+\t\t (unsigned HOST_WIDE_INT) INTVAL (x));\n       break;\n     case CONST_DOUBLE:\n       if (FLOAT_MODE_P (GET_MODE (x)))\n-\treal_to_decimal (t, CONST_DOUBLE_REAL_VALUE (x), sizeof (t), 0, 1);\n+\t{\n+\t  real_to_decimal (tmp, CONST_DOUBLE_REAL_VALUE (x),\n+\t\t\t   sizeof (tmp), 0, 1);\n+\t  pp_string (pp, tmp);\n+\t}\n       else\n-\tsprintf (t,\n-\t\t \"<\" HOST_WIDE_INT_PRINT_HEX \",\" HOST_WIDE_INT_PRINT_HEX \">\",\n-\t\t (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x),\n-\t\t (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (x));\n-      cur = safe_concat (buf, cur, t);\n+\tpp_printf (pp, \"<%wx,%wx>\",\n+\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_LOW (x),\n+\t\t   (unsigned HOST_WIDE_INT) CONST_DOUBLE_HIGH (x));\n       break;\n     case CONST_FIXED:\n-      fixed_to_decimal (t, CONST_FIXED_VALUE (x), sizeof (t));\n-      cur = safe_concat (buf, cur, t);\n+      fixed_to_decimal (tmp, CONST_FIXED_VALUE (x), sizeof (tmp));\n+      pp_string (pp, tmp);\n       break;\n     case CONST_STRING:\n-      cur = safe_concat (buf, cur, \"\\\"\");\n-      cur = safe_concat (buf, cur, XSTR (x, 0));\n-      cur = safe_concat (buf, cur, \"\\\"\");\n+      pp_printf (pp, \"\\\"%s\\\"\", XSTR (x, 0));\n       break;\n     case SYMBOL_REF:\n-      cur = safe_concat (buf, cur, \"`\");\n-      cur = safe_concat (buf, cur, XSTR (x, 0));\n-      cur = safe_concat (buf, cur, \"'\");\n+      pp_printf (pp, \"`%s'\", XSTR (x, 0));\n       break;\n     case LABEL_REF:\n-      sprintf (t, \"L%d\", INSN_UID (XEXP (x, 0)));\n-      cur = safe_concat (buf, cur, t);\n+      pp_printf (pp, \"L%d\", INSN_UID (XEXP (x, 0)));\n       break;\n     case CONST:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"const(\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \")\");\n-      break;\n     case HIGH:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"high(\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \")\");\n+    case STRICT_LOW_PART:\n+      pp_printf (pp, \"%s(\", GET_RTX_NAME (GET_CODE (x)));\n+      print_value (pp, XEXP (x, 0), verbose);\n+      pp_character (pp, ')');\n       break;\n     case REG:\n       if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n \t{\n-\t  int c = reg_names[REGNO (x)][0];\n-\t  if (ISDIGIT (c))\n-\t    cur = safe_concat (buf, cur, \"%\");\n-\n-\t  cur = safe_concat (buf, cur, reg_names[REGNO (x)]);\n+\t  if (ISDIGIT (reg_names[REGNO (x)][0]))\n+\t    pp_character (pp, '%');\n+\t  pp_string (pp, reg_names[REGNO (x)]);\n \t}\n       else\n-\t{\n-\t  sprintf (t, \"r%d\", REGNO (x));\n-\t  cur = safe_concat (buf, cur, t);\n-\t}\n+\tpp_printf (pp, \"r%d\", REGNO (x));\n       if (verbose)\n-\t{\n-\t  sprintf (t, \":%s\", GET_MODE_NAME (GET_MODE (x)));\n-\t  cur = safe_concat (buf, cur, t);\n-\t}\n+\tpp_printf (pp, \":%s\", GET_MODE_NAME (GET_MODE (x)));\n       break;\n     case SUBREG:\n-      print_value (t, SUBREG_REG (x), verbose);\n-      cur = safe_concat (buf, cur, t);\n-      sprintf (t, \"#%d\", SUBREG_BYTE (x));\n-      cur = safe_concat (buf, cur, t);\n-      break;\n-    case STRICT_LOW_PART:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"strict_low_part(\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \")\");\n+      print_value (pp, SUBREG_REG (x), verbose);\n+      pp_printf (pp, \"#%d\", SUBREG_BYTE (x));\n       break;\n     case SCRATCH:\n-      cur = safe_concat (buf, cur, \"scratch\");\n-      break;\n     case CC0:\n-      cur = safe_concat (buf, cur, \"cc0\");\n-      break;\n     case PC:\n-      cur = safe_concat (buf, cur, \"pc\");\n+      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n       break;\n     case MEM:\n-      print_value (t, XEXP (x, 0), verbose);\n-      cur = safe_concat (buf, cur, \"[\");\n-      cur = safe_concat (buf, cur, t);\n-      cur = safe_concat (buf, cur, \"]\");\n+      pp_character (pp, '[');\n+      print_value (pp, XEXP (x, 0), verbose);\n+      pp_character (pp, ']');\n       break;\n     case DEBUG_EXPR:\n-      sprintf (t, \"D#%i\", DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x)));\n-      cur = safe_concat (buf, cur, t);\n+      pp_printf (pp, \"D#%i\", DEBUG_TEMP_UID (DEBUG_EXPR_TREE_DECL (x)));\n       break;\n     default:\n-      print_exp (t, x, verbose);\n-      cur = safe_concat (buf, cur, t);\n+      print_exp (pp, x, verbose);\n       break;\n     }\n }\t\t\t\t/* print_value */\n \n-/* Print X, an RTL value node, to file F in slim format.  Include\n-   additional information if VERBOSE is nonzero.\n-\n-   Value nodes are constants, registers, labels, symbols and\n-   memory.  */\n-\n-void\n-dump_value_slim (FILE *f, const_rtx x, int verbose)\n-{\n-  char buf[BUF_LEN];\n-\n-  print_value (buf, x, verbose);\n-  fprintf (f, \"%s\", buf);\n-}\n-\n /* The next step in insn detalization, its pattern recognition.  */\n \n void\n-print_pattern (char *buf, const_rtx x, int verbose)\n+print_pattern (pretty_printer *pp, const_rtx x, int verbose)\n {\n-  char t1[BUF_LEN], t2[BUF_LEN], t3[BUF_LEN];\n-\n   if (! x)\n     {\n-      sprintf (buf, \"(nil)\");\n+      pp_string (pp, \"(nil)\");\n       return;\n     }\n \n   switch (GET_CODE (x))\n     {\n     case SET:\n-      print_value (t1, SET_DEST (x), verbose);\n-      print_value (t2, SET_SRC (x), verbose);\n-      sprintf (buf, \"%s=%s\", t1, t2);\n+      print_value (pp, SET_DEST (x), verbose);\n+      pp_character (pp, '=');\n+      print_value (pp, SET_SRC (x), verbose);\n       break;\n     case RETURN:\n     case SIMPLE_RETURN:\n     case EH_RETURN:\n-      sprintf (buf, GET_RTX_NAME (GET_CODE (x)));\n+      pp_string (pp, GET_RTX_NAME (GET_CODE (x)));\n       break;\n     case CALL:\n-      print_exp (buf, x, verbose);\n+      print_exp (pp, x, verbose);\n       break;\n     case CLOBBER:\n     case USE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"%s %s\", GET_RTX_NAME (GET_CODE (x)), t1);\n+      pp_printf (pp, \"%s \", GET_RTX_NAME (GET_CODE (x)));\n+      print_value (pp, XEXP (x, 0), verbose);\n       break;\n     case VAR_LOCATION:\n-      print_value (t1, PAT_VAR_LOCATION_LOC (x), verbose);\n-      sprintf (buf, \"loc %s\", t1);\n+      pp_string (pp, \"loc \");\n+      print_value (pp, PAT_VAR_LOCATION_LOC (x), verbose);\n       break;\n     case COND_EXEC:\n+      pp_character (pp, '(');\n       if (GET_CODE (COND_EXEC_TEST (x)) == NE\n \t  && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n-\tprint_value (t1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+\tprint_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n       else if (GET_CODE (COND_EXEC_TEST (x)) == EQ\n \t       && XEXP (COND_EXEC_TEST (x), 1) == const0_rtx)\n \t{\n-\t  t1[0] = '!';\n-\t  print_value (t1 + 1, XEXP (COND_EXEC_TEST (x), 0), verbose);\n+\t  pp_character (pp, '!');\n+\t  print_value (pp, XEXP (COND_EXEC_TEST (x), 0), verbose);\n \t}\n       else\n-\tprint_value (t1, COND_EXEC_TEST (x), verbose);\n-      print_pattern (t2, COND_EXEC_CODE (x), verbose);\n-      sprintf (buf, \"(%s) %s\", t1, t2);\n+\tprint_value (pp, COND_EXEC_TEST (x), verbose);\n+      pp_string (pp, \") \");\n+      print_pattern (pp, COND_EXEC_CODE (x), verbose);\n       break;\n     case PARALLEL:\n       {\n \tint i;\n \n-\tsprintf (t1, \"{\");\n+\tpp_character (pp, '{');\n \tfor (i = 0; i < XVECLEN (x, 0); i++)\n \t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n+\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n+\t    pp_character (pp, ';');\n \t  }\n-\tsprintf (buf, \"%s}\", t1);\n+\tpp_character (pp, '}');\n       }\n       break;\n     case SEQUENCE:\n       {\n \tint i;\n \n-\tsprintf (t1, \"sequence{\");\n+\tpp_string (pp, \"sequence{\");\n \tfor (i = 0; i < XVECLEN (x, 0); i++)\n \t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n+\t    print_pattern (pp, XVECEXP (x, 0, i), verbose);\n+\t    pp_character (pp, ';');\n \t  }\n-\tsprintf (buf, \"%s}\", t1);\n+\tpp_character (pp, '}');\n       }\n       break;\n     case ASM_INPUT:\n-      sprintf (buf, \"asm {%s}\", XSTR (x, 0));\n+      pp_printf (pp, \"asm {%s}\", XSTR (x, 0));\n       break;\n     case ADDR_VEC:\n       /* Fall through.  */\n     case ADDR_DIFF_VEC:\n-      print_value (buf, XEXP (x, 0), verbose);\n+      print_value (pp, XEXP (x, 0), verbose);\n       break;\n     case TRAP_IF:\n-      print_value (t1, TRAP_CONDITION (x), verbose);\n-      sprintf (buf, \"trap_if %s\", t1);\n+      pp_string (pp, \"trap_if \");\n+      print_value (pp, TRAP_CONDITION (x), verbose);\n       break;\n     case UNSPEC:\n     case UNSPEC_VOLATILE:\n       /* Fallthru -- leave UNSPECs to print_exp.  */\n     default:\n-      print_value (buf, x, verbose);\n+      print_value (pp, x, verbose);\n     }\n }\t\t\t\t/* print_pattern */\n \n /* This is the main function in slim rtl visualization mechanism.\n \n-   X is an insn, to be printed into BUF.\n+   X is an insn, to be printed into PP.\n \n    This function tries to print it properly in human-readable form,\n    resembling assembler mnemonics (instead of the older Lisp-style\n@@ -672,15 +607,20 @@ print_pattern (char *buf, const_rtx x, int verbose)\n    with their INSN_UIDs.  */\n \n void\n-print_insn (char *buf, const_rtx x, int verbose)\n+print_insn (pretty_printer *pp, const_rtx x, int verbose)\n {\n-  /* Collect the string to output for X in t1.  t2 is a scratch area.  */\n-  char t1[BUF_LEN], t2[BUF_LEN];\n+  if (verbose)\n+    {\n+      /* Blech, pretty-print can't print integers with a specified width.  */\n+      char uid_prefix[32];\n+      snprintf (uid_prefix, sizeof uid_prefix, \" %4d: \", INSN_UID (x));\n+      pp_string (pp, uid_prefix);\n+    }\n \n   switch (GET_CODE (x))\n     {\n     case INSN:\n-      print_pattern (t1, PATTERN (x), verbose);\n+      print_pattern (pp, PATTERN (x), verbose);\n       break;\n \n     case DEBUG_INSN:\n@@ -707,47 +647,46 @@ print_insn (char *buf, const_rtx x, int verbose)\n \t\tname = idbuf;\n \t      }\n \t  }\n+\tpp_printf (pp, \"debug %s => \", name);\n \tif (VAR_LOC_UNKNOWN_P (INSN_VAR_LOCATION_LOC (x)))\n-\t  sprintf (t1, \"debug %s optimized away\", name);\n+\t  pp_string (pp, \"optimized away\");\n \telse\n-\t  {\n-\t    print_pattern (t2, INSN_VAR_LOCATION_LOC (x), verbose);\n-\t    sprintf (t1, \"debug %s => %s\", name, t2);\n-\t  }\n+\t  print_pattern (pp, INSN_VAR_LOCATION_LOC (x), verbose);\n       }\n       break;\n \n     case JUMP_INSN:\n-      print_pattern (t1, PATTERN (x), verbose);\n+      print_pattern (pp, PATTERN (x), verbose);\n       break;\n     case CALL_INSN:\n       if (GET_CODE (PATTERN (x)) == PARALLEL)\n-        print_pattern (t1, XVECEXP (PATTERN (x), 0, 0), verbose);\n+        print_pattern (pp, XVECEXP (PATTERN (x), 0, 0), verbose);\n       else\n-\tprint_pattern (t1, PATTERN (x), verbose);\n+\tprint_pattern (pp, PATTERN (x), verbose);\n       break;\n     case CODE_LABEL:\n-      sprintf (t1, \"L%d:\", INSN_UID (x));\n+      pp_printf (pp, \"L%d:\", INSN_UID (x));\n       break;\n     case BARRIER:\n-      sprintf (t1, \"barrier\");\n+      pp_string (pp, \"barrier\");\n       break;\n     case NOTE:\n       {\n+\tpp_string (pp, GET_NOTE_INSN_NAME (NOTE_KIND (x)));\n \tswitch (NOTE_KIND (x))\n \t  {\n \t  case NOTE_INSN_EH_REGION_BEG:\n \t  case NOTE_INSN_EH_REGION_END:\n-\t    sprintf (t2, \"%d\", NOTE_EH_HANDLER (x));\n+\t    pp_printf (pp, \" %d\", NOTE_EH_HANDLER (x));\n \t    break;\n \n \t  case NOTE_INSN_BLOCK_BEG:\n \t  case NOTE_INSN_BLOCK_END:\n-\t    sprintf (t2, \"%d\", BLOCK_NUMBER (NOTE_BLOCK (x)));\n+\t    pp_printf (pp, \" %d\", BLOCK_NUMBER (NOTE_BLOCK (x)));\n \t    break;\n \n \t  case NOTE_INSN_BASIC_BLOCK:\n-\t    sprintf (t2, \"%d\", NOTE_BASIC_BLOCK (x)->index);\n+\t    pp_printf (pp, \" %d\", NOTE_BASIC_BLOCK (x)->index);\n \t    break;\n \n \t  case NOTE_INSN_DELETED_LABEL:\n@@ -756,57 +695,86 @@ print_insn (char *buf, const_rtx x, int verbose)\n \t      const char *label = NOTE_DELETED_LABEL_NAME (x);\n \t      if (label == NULL)\n \t\tlabel = \"\";\n-\t      sprintf (t2, \"(\\\"%s\\\")\", label);\n+\t      pp_printf (pp, \" (\\\"%s\\\")\", label);\n \t    }\n \t    break;\n \n \t  case NOTE_INSN_VAR_LOCATION:\n \t  case NOTE_INSN_CALL_ARG_LOCATION:\n-\t    /* It's safe here to use t1 for scratch because the output\n-\t       is printed in t2 and put back in t1 at the bottom of\n-\t       the inner switch statement.  */\n-\t    print_pattern (t1, NOTE_VAR_LOCATION (x), verbose);\n-\t    sprintf (t2, \"{%s}\", t1);\n+\t    pp_character (pp, '{');\n+\t    print_pattern (pp, NOTE_VAR_LOCATION (x), verbose);\n+\t    pp_character (pp, '}');\n \t    break;\n \n \t  default:\n-\t    t2[0] = '\\0';\n \t    break;\n \t  }\n-\tsprintf (t1, \"%s %s\", GET_NOTE_INSN_NAME (NOTE_KIND (x)), t2);\n \tbreak;\n       }\n     default:\n-      sprintf (t1, \"<What %s?>\", GET_RTX_NAME (GET_CODE (x)));\n-      break;\n+      gcc_unreachable ();\n     }\n+}\t\t\t\t/* print_insn */\n \n-  if (verbose)\n-    sprintf (buf, \" %4d: %s\", INSN_UID (x), t1);\n+/* Prerry-print a slim dump of X (an insn) to PP, including any register\n+   note attached to the instruction.  */\n+\n+static void\n+print_insn_with_notes (pretty_printer *pp, const_rtx x)\n+{\n+  pp_string (pp, print_rtx_head);\n+  print_insn (pp, x, 1);\n+  pp_newline (pp);\n+  if (INSN_P (x) && REG_NOTES (x))\n+    for (rtx note = REG_NOTES (x); note; note = XEXP (note, 1))\n+      {\n+\tpp_printf (pp, \"%s      %s\", print_rtx_head,\n+\t\t   GET_REG_NOTE_NAME (REG_NOTE_KIND (note)));\n+        print_pattern (pp, XEXP (note, 0), 1);\n+\tpp_newline (pp);\n+      }\n+}\n+\n+/* Return a pretty-print buffer set up to print to file F.  */\n+\n+static pretty_printer *\n+init_rtl_slim_pretty_print (FILE *f)\n+{\n+  if (! rtl_slim_pp_initialized)\n+    {\n+      pp_construct (&rtl_slim_pp, /*prefix=*/NULL, /*linewidth=*/0);\n+      rtl_slim_pp_initialized = true;\n+    }\n   else\n-    sprintf (buf, \"%s\", t1);\n-}\t\t\t\t/* print_insn */\n+    /* Clean out any data that str_insn_slim may have left here.  */\n+    pp_clear_output_area (&rtl_slim_pp);\n+\n+  rtl_slim_pp.buffer->stream = f;\n+  return &rtl_slim_pp;\n+}\n+\n+/* Print X, an RTL value node, to file F in slim format.  Include\n+   additional information if VERBOSE is nonzero.\n+\n+   Value nodes are constants, registers, labels, symbols and\n+   memory.  */\n+\n+void\n+dump_value_slim (FILE *f, const_rtx x, int verbose)\n+{\n+  pretty_printer *pp = init_rtl_slim_pretty_print (f);\n+  print_value (pp, x, verbose);\n+  pp_flush (pp);\n+}\n \n /* Emit a slim dump of X (an insn) to the file F, including any register\n    note attached to the instruction.  */\n void\n dump_insn_slim (FILE *f, const_rtx x)\n {\n-  char t[BUF_LEN + 32];\n-  rtx note;\n-\n-  print_insn (t, x, 1);\n-  fputs (print_rtx_head, f);\n-  fputs (t, f);\n-  putc ('\\n', f);\n-  if (INSN_P (x) && REG_NOTES (x))\n-    for (note = REG_NOTES (x); note; note = XEXP (note, 1))\n-      {\n-\tfputs (print_rtx_head, f);\n-        print_pattern (t, XEXP (note, 0), 1);\n-\tfprintf (f, \"      %s: %s\\n\",\n-\t\t GET_REG_NOTE_NAME (REG_NOTE_KIND (note)), t);\n-      }\n+  pretty_printer *pp = init_rtl_slim_pretty_print (f);\n+  print_insn_with_notes (pp, x);\n+  pp_flush (pp);\n }\n \n /* Same as above, but stop at LAST or when COUNT == 0.\n@@ -817,16 +785,33 @@ dump_rtl_slim (FILE *f, const_rtx first, const_rtx last,\n \t       int count, int flags ATTRIBUTE_UNUSED)\n {\n   const_rtx insn, tail;\n+  pretty_printer *pp = init_rtl_slim_pretty_print (f);\n \n   tail = last ? NEXT_INSN (last) : NULL_RTX;\n   for (insn = first;\n        (insn != NULL) && (insn != tail) && (count != 0);\n        insn = NEXT_INSN (insn))\n     {\n-      dump_insn_slim (f, insn);\n+      print_insn_with_notes (pp, insn);\n       if (count > 0)\n         count--;\n     }\n+\n+  pp_flush (pp);\n+}\n+\n+/* Pretty-print pattern X of some insn in non-verbose mode.\n+   Return a string pointer to the pretty-printer buffer.\n+\n+   This function is only exported exists only to accommodate some older users\n+   of the slim RTL pretty printers.  Please do not use it for new code.  */\n+\n+const char *\n+str_pattern_slim (const_rtx x)\n+{\n+  pretty_printer *pp = init_rtl_slim_pretty_print (NULL);\n+  print_pattern (pp, x, 0);\n+  return pp_base_formatted_text (pp);\n }\n \n /* Emit a slim dump of X (an insn) to stderr.  */"}, {"sha": "9e72cfd8c8bf42df78a87749e55ba98cd538e9c7", "filename": "gcc/sel-sched-dump.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fsel-sched-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7eba871a24b6e6fa5483531abaf8a1be8a88c0a4/gcc%2Fsel-sched-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-dump.c?ref=7eba871a24b6e6fa5483531abaf8a1be8a88c0a4", "patch": "@@ -136,12 +136,7 @@ dump_insn_rtx_1 (rtx insn, int flags)\n     sel_print (\"%d;\", INSN_UID (insn));\n \n   if (flags & DUMP_INSN_RTX_PATTERN)\n-    {\n-      char buf[2048];\n-\n-      print_insn (buf, insn, 0);\n-      sel_print (\"%s;\", buf);\n-    }\n+    sel_print (\"%s;\", str_pattern_slim (insn));\n \n   if (flags & DUMP_INSN_RTX_BBN)\n     {\n@@ -522,6 +517,7 @@ sel_print_insn (const_rtx insn, int aligned ATTRIBUTE_UNUSED)\n \f\n \n /* Functions for pretty printing of CFG.  */\n+/* FIXME: Using pretty-print here could simplify this stuff.  */\n \n /* Replace all occurencies of STR1 to STR2 in BUF.\n    The BUF must be large enough to hold the result.  */\n@@ -564,7 +560,8 @@ replace_str_in_buf (char *buf, const char *str1, const char *str2)\n   while (p);\n }\n \n-/* Replace characters in BUF that have special meaning in .dot file.  */\n+/* Replace characters in BUF that have special meaning in .dot file.\n+   Similar to pp_write_text_as_dot_label_to_stream.  */\n static void\n sel_prepare_string_for_dot_label (char *buf)\n {"}]}