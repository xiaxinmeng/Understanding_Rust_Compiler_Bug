{"sha": "785e6a26dace53cebed12db30f33169d25c0c719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzg1ZTZhMjZkYWNlNTNjZWJlZDEyZGIzMGYzMzE2OWQyNWMwYzcxOQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-12T01:49:20Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-12T01:49:20Z"}, "message": "(movsf, movdf): Handle a move from an integer register before reload.\n\nThis can happen if the user uses asm to put a floating point variable\nin an integer register.\n\nFrom-SVN: r4666", "tree": {"sha": "872c27f451c3580cf6dbf0eec3edb5a4ca2ba246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/872c27f451c3580cf6dbf0eec3edb5a4ca2ba246"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/785e6a26dace53cebed12db30f33169d25c0c719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785e6a26dace53cebed12db30f33169d25c0c719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/785e6a26dace53cebed12db30f33169d25c0c719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/785e6a26dace53cebed12db30f33169d25c0c719/comments", "author": null, "committer": null, "parents": [{"sha": "11e5fe42ca1d186a56b85214fa492ff309570a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11e5fe42ca1d186a56b85214fa492ff309570a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11e5fe42ca1d186a56b85214fa492ff309570a32"}], "stats": {"total": 29, "additions": 14, "deletions": 15}, "files": [{"sha": "342762ea6a66d458bb51ba946f9a4d659ec3b7ea", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/785e6a26dace53cebed12db30f33169d25c0c719/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/785e6a26dace53cebed12db30f33169d25c0c719/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=785e6a26dace53cebed12db30f33169d25c0c719", "patch": "@@ -2259,20 +2259,19 @@\n       && REGNO (SUBREG_REG (operands[1])) < FIRST_PSEUDO_REGISTER)\n     operands[1] = alter_subreg (operands[1]);\n \n-  /* If we are being called from reload, it is possible that operands[1]\n-     is a hard non-fp register.  So handle those cases.  */\n-  if (reload_in_progress && GET_CODE (operands[1]) == REG\n-      && REGNO (operands[1]) < 32)\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n     {\n       rtx stack_slot;\n \n-      /* Remember that we only see a pseudo here if it didn't get a hard\n-\t register, so it is memory.  */\n+      /* If this is a store to memory or another integer register do the\n+\t move directly.  Otherwise store to a temporary stack slot and\n+\t load from there into a floating point register.  */\n+\n       if (GET_CODE (operands[0]) == MEM\n \t  || (GET_CODE (operands[0]) == REG\n \t      && (REGNO (operands[0]) < 32\n-\t\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))\n-\t  || (GET_CODE (operands[0]) == REG && REGNO (operands[0]) < 32))\n+\t\t  || (reload_in_progress\n+\t\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))))\n \t{\n \t  emit_move_insn (operand_subword (operands[0], 0, 0, SFmode),\n \t\t\t  operand_subword (operands[1], 0, 0, SFmode));\n@@ -2371,19 +2370,19 @@\n       && REGNO (SUBREG_REG (operands[1])) < FIRST_PSEUDO_REGISTER)\n     operands[1] = alter_subreg (operands[1]);\n \n-  /* If we are being called from reload, it is possible that operands[1]\n-     is a hard non-fp register.  So handle those cases.  */\n-  if (reload_in_progress && GET_CODE (operands[1]) == REG\n-      && REGNO (operands[1]) < 32)\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) < 32)\n     {\n       rtx stack_slot;\n \n-      /* Remember that we only see a pseudo here if it didn't get a hard\n-\t register, so it is memory.  */\n+      /* If this is a store to memory or another integer register do the\n+\t move directly.  Otherwise store to a temporary stack slot and\n+\t load from there into a floating point register.  */\n+\n       if (GET_CODE (operands[0]) == MEM\n \t  || (GET_CODE (operands[0]) == REG\n \t      && (REGNO (operands[0]) < 32\n-\t\t  || REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER)))\n+\t\t  || (reload_in_progress\n+\t\t      && REGNO (operands[0]) >= FIRST_PSEUDO_REGISTER))))\n \t{\n \t  emit_move_insn (operand_subword (operands[0], 0, 0, DFmode),\n \t\t\t  operand_subword (operands[1], 0, 0, DFmode));"}]}