{"sha": "32291f940ea10975e1555e2c0ae8189e34979482", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzIyOTFmOTQwZWExMDk3NWUxNTU1ZTJjMGFlODE4OWUzNDk3OTQ4Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-04-22T23:06:09Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-04-22T23:06:09Z"}, "message": "toplev.h (wrapup_global_declarations): Declare.\n\n\t* toplev.h (wrapup_global_declarations): Declare.\n\t(check_global_declarations): Likewise.\n\t* toplev.c (wrapup_global_declarations): New function, split out\n\tfrom ...\n\t(check_global_declarations): Likewise...\n\t(compile_file): Here.\n\nFrom-SVN: r26593", "tree": {"sha": "3c71573e1c673126def01c10a1810b35cdd1b2ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c71573e1c673126def01c10a1810b35cdd1b2ad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/32291f940ea10975e1555e2c0ae8189e34979482", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32291f940ea10975e1555e2c0ae8189e34979482", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32291f940ea10975e1555e2c0ae8189e34979482", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32291f940ea10975e1555e2c0ae8189e34979482/comments", "author": null, "committer": null, "parents": [{"sha": "6b55276ed95655f743db4b87a77495a348df946f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b55276ed95655f743db4b87a77495a348df946f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b55276ed95655f743db4b87a77495a348df946f"}], "stats": {"total": 385, "additions": 214, "deletions": 171}, "files": [{"sha": "573bfb1407e1272d806c4765838bcb24bcf4dcd1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=32291f940ea10975e1555e2c0ae8189e34979482", "patch": "@@ -1,3 +1,12 @@\n+Thu Apr 22 23:08:37 1999  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* toplev.h (wrapup_global_declarations): Declare.\n+\t(check_global_declarations): Likewise.\n+\t* toplev.c (wrapup_global_declarations): New function, split out\n+\tfrom ...\n+\t(check_global_declarations): Likewise...\n+\t(compile_file): Here.\n+\n Thu Apr 22 22:34:41 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* c-parse.in (expr_no_commas): Verify we've an expr before"}, {"sha": "f0e84f42e3ad78dfe63aaa1e86c2bed4468cd388", "filename": "gcc/toplev.c", "status": "modified", "additions": 203, "deletions": 170, "changes": 373, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=32291f940ea10975e1555e2c0ae8189e34979482", "patch": "@@ -2675,6 +2675,207 @@ clean_dump_file (suffix)\n   return;\n }\n \n+/* Do any final processing required for the declarations in VEC, of\n+   which there are LEN.  We write out inline functions and variables\n+   that have been deferred until this point, but which are required.\n+   Returns non-zero if anything was put out.  */ \n+int\n+wrapup_global_declarations (vec, len)\n+     tree *vec;\n+     int len;\n+{\n+  tree decl;\n+  int i;\n+  int reconsider;\n+  int output_something = 0;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      decl = vec[i];\n+      \n+      /* We're not deferring this any longer.  */\n+      DECL_DEFER_OUTPUT (decl) = 0;\n+      \n+      if (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0\n+\t  && incomplete_decl_finalize_hook != 0)\n+\t(*incomplete_decl_finalize_hook) (decl);\n+    }\n+\n+  /* Now emit any global variables or functions that we have been\n+     putting off.  We need to loop in case one of the things emitted\n+     here references another one which comes earlier in the list.  */\n+  do\n+    {\n+      reconsider = 0;\n+      for (i = 0; i < len; i++)\n+\t{\n+\t  decl = vec[i];\n+\n+\t  if (TREE_ASM_WRITTEN (decl) || DECL_EXTERNAL (decl))\n+\t    continue;\n+\n+\t  /* Don't write out static consts, unless we still need them.\n+\n+\t     We also keep static consts if not optimizing (for debugging),\n+\t     unless the user specified -fno-keep-static-consts.\n+\t     ??? They might be better written into the debug information.\n+\t     This is possible when using DWARF.\n+\n+\t     A language processor that wants static constants to be always\n+\t     written out (even if it is not used) is responsible for\n+\t     calling rest_of_decl_compilation itself.  E.g. the C front-end\n+\t     calls rest_of_decl_compilation from finish_decl.\n+\t     One motivation for this is that is conventional in some\n+\t     environments to write things like:\n+\t     static const char rcsid[] = \"... version string ...\";\n+\t     intending to force the string to be in the executable.\n+\n+\t     A language processor that would prefer to have unneeded\n+\t     static constants \"optimized away\" would just defer writing\n+\t     them out until here.  E.g. C++ does this, because static\n+\t     constants are often defined in header files.\n+\n+\t     ??? A tempting alternative (for both C and C++) would be\n+\t     to force a constant to be written if and only if it is\n+\t     defined in a main file, as opposed to an include file.  */\n+\n+\t  if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n+\t      && (! TREE_READONLY (decl)\n+\t\t  || TREE_PUBLIC (decl)\n+\t\t  || (!optimize && flag_keep_static_consts)\n+\t\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t    {\n+\t      reconsider = 1;\n+\t      rest_of_decl_compilation (decl, NULL_PTR, 1, 1);\n+\t    }\n+\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL\n+\t      && DECL_INITIAL (decl) != 0\n+\t      && DECL_SAVED_INSNS (decl) != 0\n+\t      && (flag_keep_inline_functions\n+\t\t  || TREE_PUBLIC (decl)\n+\t\t  || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t    {\n+\t      reconsider = 1;\n+\t      temporary_allocation ();\n+\t      output_inline_function (decl);\n+\t      permanent_allocation (1);\n+\t    }\n+\t}\n+\n+      if (reconsider)\n+\toutput_something = 1;\n+    }\n+  while (reconsider);\n+\n+  return output_something;\n+}\n+\n+/* Issue appropriate warnings for the global declarations in VEC (of\n+   which there are LEN).  Output debugging information for them.  */\n+void\n+check_global_declarations (vec, len)\n+     tree *vec;\n+     int len;\n+{\n+  tree decl;\n+  int i;\n+\n+  for (i = 0; i < len; i++)\n+    {\n+      decl = vec[i];\n+\n+      if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n+\t  && ! TREE_ASM_WRITTEN (decl))\n+\t/* Cancel the RTL for this decl so that, if debugging info\n+\t   output for global variables is still to come,\n+\t   this one will be omitted.  */\n+\tDECL_RTL (decl) = NULL;\n+\n+      /* Warn about any function\n+\t declared static but not defined.\n+\t We don't warn about variables,\n+\t because many programs have static variables\n+\t that exist only to get some text into the object file.  */\n+      if (TREE_CODE (decl) == FUNCTION_DECL\n+\t  && (warn_unused\n+\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t  && DECL_INITIAL (decl) == 0\n+\t  && DECL_EXTERNAL (decl)\n+\t  && ! DECL_ARTIFICIAL (decl)\n+\t  && ! TREE_PUBLIC (decl))\n+\t{\n+\t  if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t    pedwarn_with_decl (decl,\n+\t\t\t       \"`%s' used but never defined\");\n+\t  else\n+\t    warning_with_decl (decl,\n+\t\t\t       \"`%s' declared `static' but never defined\");\n+\t  /* This symbol is effectively an \"extern\" declaration now.  */\n+\t  TREE_PUBLIC (decl) = 1;\n+\t  assemble_external (decl);\n+\t}\n+\n+      /* Warn about static fns or vars defined but not used,\n+\t but not about inline functions or static consts\n+\t since defining those in header files is normal practice.  */\n+      if (warn_unused\n+\t  && ((TREE_CODE (decl) == FUNCTION_DECL && ! DECL_INLINE (decl))\n+\t      || (TREE_CODE (decl) == VAR_DECL && ! TREE_READONLY (decl)))\n+\t  && ! DECL_IN_SYSTEM_HEADER (decl)\n+\t  && ! DECL_EXTERNAL (decl)\n+\t  && ! TREE_PUBLIC (decl)\n+\t  && ! TREE_USED (decl)\n+\t  && (TREE_CODE (decl) == FUNCTION_DECL || ! DECL_REGISTER (decl))\n+\t  /* The TREE_USED bit for file-scope decls\n+\t     is kept in the identifier, to handle multiple\n+\t     external decls in different scopes.  */\n+\t  && ! TREE_USED (DECL_NAME (decl)))\n+\twarning_with_decl (decl, \"`%s' defined but not used\");\n+\n+#ifdef SDB_DEBUGGING_INFO\n+      /* The COFF linker can move initialized global vars to the end.\n+\t And that can screw up the symbol ordering.\n+\t By putting the symbols in that order to begin with,\n+\t we avoid a problem.  mcsun!unido!fauern!tumuc!pes@uunet.uu.net.  */\n+      if (write_symbols == SDB_DEBUG && TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_PUBLIC (decl) && DECL_INITIAL (decl)\n+\t  && ! DECL_EXTERNAL (decl)\n+\t  && DECL_RTL (decl) != 0)\n+\tTIMEVAR (symout_time, sdbout_symbol (decl, 0));\n+\n+      /* Output COFF information for non-global\n+\t file-scope initialized variables.  */\n+      if (write_symbols == SDB_DEBUG\n+\t  && TREE_CODE (decl) == VAR_DECL\n+\t  && DECL_INITIAL (decl)\n+\t  && ! DECL_EXTERNAL (decl)\n+\t  && DECL_RTL (decl) != 0\n+\t  && GET_CODE (DECL_RTL (decl)) == MEM)\n+\tTIMEVAR (symout_time, sdbout_toplevel_data (decl));\n+#endif /* SDB_DEBUGGING_INFO */\n+#ifdef DWARF_DEBUGGING_INFO\n+      /* Output DWARF information for file-scope tentative data object\n+\t declarations, file-scope (extern) function declarations (which\n+\t had no corresponding body) and file-scope tagged type declarations\n+\t and definitions which have not yet been forced out.  */\n+\n+      if (write_symbols == DWARF_DEBUG\n+\t  && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n+\tTIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 1));\n+#endif\n+#ifdef DWARF2_DEBUGGING_INFO\n+      /* Output DWARF2 information for file-scope tentative data object\n+\t declarations, file-scope (extern) function declarations (which\n+\t had no corresponding body) and file-scope tagged type declarations\n+\t and definitions which have not yet been forced out.  */\n+\n+      if (write_symbols == DWARF2_DEBUG\n+\t  && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n+\tTIMEVAR (symout_time, dwarf2out_decl (decl));\n+#endif\n+    }\n+}\n \n /* Compile an entire file of output from cpp, named NAME.\n    Write a file of assembly output and various debugging dumps.  */\n@@ -3075,88 +3276,15 @@ compile_file (name)\n     tree *vec = (tree *) alloca (sizeof (tree) * len);\n     int i;\n     tree decl;\n-    int reconsider = 1;\n \n     /* Process the decls in reverse order--earliest first.\n        Put them into VEC from back to front, then take out from front.  */\n \n     for (i = 0, decl = globals; i < len; i++, decl = TREE_CHAIN (decl))\n       vec[len - i - 1] = decl;\n \n-    for (i = 0; i < len; i++)\n-      {\n-\tdecl = vec[i];\n-\n-\t/* We're not deferring this any longer.  */\n-\tDECL_DEFER_OUTPUT (decl) = 0;\n-\n-\tif (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0\n-\t    && incomplete_decl_finalize_hook != 0)\n-\t  (*incomplete_decl_finalize_hook) (decl);\n-      }\n-\n-    /* Now emit any global variables or functions that we have been putting\n-       off.  We need to loop in case one of the things emitted here\n-       references another one which comes earlier in the list.  */\n-    while (reconsider)\n-      {\n-\treconsider = 0;\n-\tfor (i = 0; i < len; i++)\n-\t  {\n-\t    decl = vec[i];\n-\n-\t    if (TREE_ASM_WRITTEN (decl) || DECL_EXTERNAL (decl))\n-\t      continue;\n-\n-\t    /* Don't write out static consts, unless we still need them.\n-\n-\t       We also keep static consts if not optimizing (for debugging),\n-\t       unless the user specified -fno-keep-static-consts.\n-\t       ??? They might be better written into the debug information.\n-\t       This is possible when using DWARF.\n-\n-\t       A language processor that wants static constants to be always\n-\t       written out (even if it is not used) is responsible for\n-\t       calling rest_of_decl_compilation itself.  E.g. the C front-end\n-\t       calls rest_of_decl_compilation from finish_decl.\n-\t       One motivation for this is that is conventional in some\n-\t       environments to write things like:\n-\t           static const char rcsid[] = \"... version string ...\";\n-\t       intending to force the string to be in the executable.\n-\n-\t       A language processor that would prefer to have unneeded\n-\t       static constants \"optimized away\" would just defer writing\n-\t       them out until here.  E.g. C++ does this, because static\n-\t       constants are often defined in header files.\n-\n-\t       ??? A tempting alternative (for both C and C++) would be\n-\t       to force a constant to be written if and only if it is\n-\t       defined in a main file, as opposed to an include file.  */\n-\n-\t    if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n-\t\t&& (! TREE_READONLY (decl)\n-\t\t    || TREE_PUBLIC (decl)\n-\t\t    || (!optimize && flag_keep_static_consts)\n-\t\t    || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n-\t      {\n-\t\treconsider = 1;\n-\t\trest_of_decl_compilation (decl, NULL_PTR, 1, 1);\n-\t      }\n-\n-\t    if (TREE_CODE (decl) == FUNCTION_DECL\n-\t\t&& DECL_INITIAL (decl) != 0\n-\t\t&& DECL_SAVED_INSNS (decl) != 0\n-\t\t&& (flag_keep_inline_functions\n-\t\t    || TREE_PUBLIC (decl)\n-\t\t    || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n-\t      {\n-\t\treconsider = 1;\n-\t\ttemporary_allocation ();\n-\t\toutput_inline_function (decl);\n-\t\tpermanent_allocation (1);\n-\t      }\n-\t  }\n-      }\n+    wrapup_global_declarations (vec, len);\n+    check_global_declarations (vec, len);\n \n     /* This must occur after the loop to output deferred functions.  Else\n        the profiler initializer would not be emitted if all the functions\n@@ -3171,101 +3299,6 @@ compile_file (name)\n        the exception table.  */\n \n     output_exception_table ();\n-\n-    for (i = 0; i < len; i++)\n-      {\n-\tdecl = vec[i];\n-\n-\tif (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl)\n-\t    && ! TREE_ASM_WRITTEN (decl))\n-\t  /* Cancel the RTL for this decl so that, if debugging info\n-\t     output for global variables is still to come,\n-\t     this one will be omitted.  */\n-\t  DECL_RTL (decl) = NULL;\n-\n-\t/* Warn about any function\n-\t   declared static but not defined.\n-\t   We don't warn about variables,\n-\t   because many programs have static variables\n-\t   that exist only to get some text into the object file.  */\n-\tif (TREE_CODE (decl) == FUNCTION_DECL\n-\t    && (warn_unused\n-\t\t|| TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t    && DECL_INITIAL (decl) == 0\n-\t    && DECL_EXTERNAL (decl)\n-\t    && ! DECL_ARTIFICIAL (decl)\n-\t    && ! TREE_PUBLIC (decl))\n-\t  {\n-\t    if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t      pedwarn_with_decl (decl,\n-\t\t\t\t \"`%s' used but never defined\");\n-\t    else\n-\t      warning_with_decl (decl,\n-\t\t\t\t \"`%s' declared `static' but never defined\");\n-\t    /* This symbol is effectively an \"extern\" declaration now.  */\n-\t    TREE_PUBLIC (decl) = 1;\n-\t    assemble_external (decl);\n-\t  }\n-\n-\t/* Warn about static fns or vars defined but not used,\n-\t   but not about inline functions or static consts\n-\t   since defining those in header files is normal practice.  */\n-\tif (warn_unused\n-\t    && ((TREE_CODE (decl) == FUNCTION_DECL && ! DECL_INLINE (decl))\n-\t\t|| (TREE_CODE (decl) == VAR_DECL && ! TREE_READONLY (decl)))\n-\t    && ! DECL_IN_SYSTEM_HEADER (decl)\n-\t    && ! DECL_EXTERNAL (decl)\n-\t    && ! TREE_PUBLIC (decl)\n-\t    && ! TREE_USED (decl)\n-\t    && (TREE_CODE (decl) == FUNCTION_DECL || ! DECL_REGISTER (decl))\n-\t    /* The TREE_USED bit for file-scope decls\n-\t       is kept in the identifier, to handle multiple\n-\t       external decls in different scopes.  */\n-\t    && ! TREE_USED (DECL_NAME (decl)))\n-\t  warning_with_decl (decl, \"`%s' defined but not used\");\n-\n-#ifdef SDB_DEBUGGING_INFO\n-\t/* The COFF linker can move initialized global vars to the end.\n-\t   And that can screw up the symbol ordering.\n-\t   By putting the symbols in that order to begin with,\n-\t   we avoid a problem.  mcsun!unido!fauern!tumuc!pes@uunet.uu.net.  */\n-\tif (write_symbols == SDB_DEBUG && TREE_CODE (decl) == VAR_DECL\n-\t    && TREE_PUBLIC (decl) && DECL_INITIAL (decl)\n-\t    && ! DECL_EXTERNAL (decl)\n-\t    && DECL_RTL (decl) != 0)\n-\t  TIMEVAR (symout_time, sdbout_symbol (decl, 0));\n-\n-\t/* Output COFF information for non-global\n-\t   file-scope initialized variables.  */\n-\tif (write_symbols == SDB_DEBUG\n-\t    && TREE_CODE (decl) == VAR_DECL\n-\t    && DECL_INITIAL (decl)\n-\t    && ! DECL_EXTERNAL (decl)\n-\t    && DECL_RTL (decl) != 0\n-\t    && GET_CODE (DECL_RTL (decl)) == MEM)\n-\t  TIMEVAR (symout_time, sdbout_toplevel_data (decl));\n-#endif /* SDB_DEBUGGING_INFO */\n-#ifdef DWARF_DEBUGGING_INFO\n-\t/* Output DWARF information for file-scope tentative data object\n-\t   declarations, file-scope (extern) function declarations (which\n-\t   had no corresponding body) and file-scope tagged type declarations\n-\t   and definitions which have not yet been forced out.  */\n-\n-\tif (write_symbols == DWARF_DEBUG\n-\t    && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n-\t  TIMEVAR (symout_time, dwarfout_file_scope_decl (decl, 1));\n-#endif\n-#ifdef DWARF2_DEBUGGING_INFO\n-\t/* Output DWARF2 information for file-scope tentative data object\n-\t   declarations, file-scope (extern) function declarations (which\n-\t   had no corresponding body) and file-scope tagged type declarations\n-\t   and definitions which have not yet been forced out.  */\n-\n-\tif (write_symbols == DWARF2_DEBUG\n-\t    && (TREE_CODE (decl) != FUNCTION_DECL || !DECL_INITIAL (decl)))\n-\t  TIMEVAR (symout_time, dwarf2out_decl (decl));\n-#endif\n-      }\n   }\n \n   /* Write out any pending weak symbol declarations.  */"}, {"sha": "3ffad1f5995826c86477b1fb1d853793405c0f81", "filename": "gcc/toplev.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/32291f940ea10975e1555e2c0ae8189e34979482/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=32291f940ea10975e1555e2c0ae8189e34979482", "patch": "@@ -113,5 +113,6 @@ extern void fnotice\t\t\tPROTO ((FILE *, const char *, ...))\n \n #undef trim_filename\n extern const char *trim_filename\tPROTO ((const char *));\n-\n+extern int wrapup_global_declarations   PROTO ((union tree_node **, int));\n+extern void check_global_declarations   PROTO ((union tree_node **, int));\n #endif /* __GCC_TOPLEV_H */"}]}