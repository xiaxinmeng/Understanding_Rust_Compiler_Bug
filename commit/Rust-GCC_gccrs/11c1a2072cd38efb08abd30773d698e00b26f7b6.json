{"sha": "11c1a2072cd38efb08abd30773d698e00b26f7b6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFjMWEyMDcyY2QzOGVmYjA4YWJkMzA3NzNkNjk4ZTAwYjI2ZjdiNg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1995-12-06T11:46:16Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1995-12-06T11:46:16Z"}, "message": "(CPP_SPEC): Add defines for the cpu type, hard or soft floating point, and the APCS PC size.\n\n(CPP_SPEC): Add defines for the cpu type, hard or soft floating\npoint, and the APCS PC size.\n(TARGET_*): Restructure.\n(ARM_FLAG_*): Many new definitions for different target options, not\nall of which are supported yet.\n(TARGET_SWITCHES): Use the ARM_FLAG_* definitions instead of explicit\nnumbers.\n(prog_mode_type): New enum.\n(floating_point_type): Split emulated floating point into FP_SOFT[23].\n(OVERRIDE_OPTIONS): Call arm_override_options.\n\t(ARM_CPU_NAME): Default to NULL if not defined by a subtarget.\n(BYTES_BIG_ENDIAN): Can now be set as a compilation option.\n(RETURN_IN_MEMORY, DEFAULT_PCC_STRUCT_RETURN): New definitions.\n(GO_IF_LEGITIMATE_OFFSET): Use different HImode offsets if compiling\nfor an architecture 4 target.  The offsets for floating point\nconstants are the same as for integers if compiling TARGET_SOFT_FLOAT\n(GO_IF_LEGITIMATE_ADDRESS): Don't allow PRE_INC and POST_DEC if\nthe size is more than 4 bytes.  Restrict the range offsets for DImode;\nlikewise for DFmode when TARGET_SOFT_FLOAT.\n(LEGITIMIZE_ADDRESS): Use symbol_mentioned_p, not LEGITIMATE_CONSTANT_P\nto determine if a constant address might be better in a register.\nHandle DFmode addresses in the same way as DImode if TARGET_SOFT_FLOAT.\n(LOAD_EXTEND_OP): If arm_arch4, then HImode also zero-extends.\n(SECONDARY_OUTPUT_RELOAD_CLASS): No need to handle floating\npoint constants any more, since arm_reorg will deal with them.\n(LEGITIMATE_CONSTANT_P): Is now anything that doesn't contain a\nLABEL.\n(GO_IF_LEGITIMATE_ADDRESS): Recognize addresses expressions generated\nby arm_reorg, but only after reload has completed.\n(MACHINE_DEPENDENT_REORG): Define.\n(ASM_OUTPUT_SPECIAL_POOL_ENTRY): There should be nothing left in\nthe pool, even if it might look like it.\n(most assembler-specific defines): Move to arm/aout.h.\n(CONSTANT_ADDRESS_P): Can't directly access constant strings when\n\tgenerating assembler for ARMASM.\n(ENCODE_SECTION_INFO): Don't define if generating ARMASM assembler.\n(ASM_OUTPUT_INTERNAL_LABEL): Generalize, so that it can be used\nwith all targeted assemblers.\n(ASM_OUTPUT_LABEL): Call arm_asm_output_label.\n\nFrom-SVN: r10681", "tree": {"sha": "e3934bdce177d809a0b9ac18b0fc7f3ac5714329", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3934bdce177d809a0b9ac18b0fc7f3ac5714329"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11c1a2072cd38efb08abd30773d698e00b26f7b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11c1a2072cd38efb08abd30773d698e00b26f7b6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11c1a2072cd38efb08abd30773d698e00b26f7b6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11c1a2072cd38efb08abd30773d698e00b26f7b6/comments", "author": null, "committer": null, "parents": [{"sha": "2b835d68114d222704505707d0315902a4201250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b835d68114d222704505707d0315902a4201250", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b835d68114d222704505707d0315902a4201250"}], "stats": {"total": 583, "additions": 226, "deletions": 357}, "files": [{"sha": "2eef03d91c6d60acfbf52f4b2fdf6f1c63910c13", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 226, "deletions": 357, "changes": 583, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11c1a2072cd38efb08abd30773d698e00b26f7b6/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11c1a2072cd38efb08abd30773d698e00b26f7b6/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=11c1a2072cd38efb08abd30773d698e00b26f7b6", "patch": "@@ -21,10 +21,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-/* Sometimes the directive `riscos' is checked.  This does not imply that this\n-   tm file can be used unchanged to build a GCC for RISC OS.\n-   (Since in fact, it can't.)  */\n-\n extern void output_func_prologue ();\n extern void output_func_epilogue ();\n extern char *output_add_immediate ();\n@@ -56,7 +52,16 @@ extern int frame_pointer_needed;\n #endif\n \n #ifndef CPP_SPEC\n-#define CPP_SPEC \"%{m6:-D__arm6__}\"\n+#define CPP_SPEC \"%{m6:-D__arm6__} \\\n+%{mcpu-*:-D__%*} \\\n+%{mcpu=*:-D__%*} \\\n+%{mapcs-32:-D__APCS_32__ -U__APCS_26__} \\\n+%{mapcs-26:-D__APCS_26__ -U__APCS_32__} \\\n+%{!mapcs-32: %{!mapcs-26:-D__APCS_26__}} \\\n+%{msoft-float:-D__SOFTFP__} \\\n+%{mhard-float:-U__SOFTFP__} \\\n+%{!mhard-float: %{!msoft-float:-U__SOFTFP__}} \\\n+\"\n #endif\n \f\n /* Run-time Target Specification.  */\n@@ -65,40 +70,81 @@ extern int frame_pointer_needed;\n   fputs (\" (ARM/generic)\", stderr);\n #endif\n \n-/* Run-time compilation parameters selecting different hardware subsets.\n-   On the ARM, misuse it in a different way.  */\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n extern int target_flags;\n \n+/* These two are used by TARGET_OPTIONS, they are parsed in OVERRIDE_OPTIONS */\n+extern char *target_cpu_name;\n+extern char *target_fpe_name;\n+\n /* Nonzero if the function prologue (and epilogue) should obey\n    the ARM Procedure Call Standard.  */\n-#define TARGET_APCS\t(target_flags & 1)\n+#define ARM_FLAG_APCS_FRAME\t(0x0001)\n \n /* Nonzero if the function prologue should output the function name to enable\n    the post mortem debugger to print a backtrace (very useful on RISCOS,\n-   unused on RISCiX).  Specifying this flag also enables -mapcs.\n+   unused on RISCiX).  Specifying this flag also enables\n+   -fno-omit-frame-pointer.\n    XXX Must still be implemented in the prologue.  */\n-#define TARGET_POKE_FUNCTION_NAME\t(target_flags & 2)\n+#define ARM_FLAG_POKE         (0x0002)\n \n /* Nonzero if floating point instructions are emulated by the FPE, in which\n    case instruction scheduling becomes very uninteresting.  */\n-#define TARGET_FPE\t(target_flags & 4)\n+#define ARM_FLAG_FPE          (0x0004)\n \n /* Nonzero if destined for an ARM6xx.  Takes out bits that assume restoration\n    of condition flags when returning from a branch & link (ie. a function) */\n-#define TARGET_6        (target_flags & 8)\n-\n-/* Leave some bits for new processor variants */\n-\n-/* Nonzero if shorts must be loaded byte at a time.  This is not necessary\n-   for the arm processor chip, but it is needed for some MMU chips.  */\n-#define TARGET_SHORT_BY_BYTES\t(target_flags & 0x200)\n-\n-/* Nonzero if GCC should use a floating point library.\n-   GCC will assume the fp regs don't exist and will not emit any fp insns.\n-   Note that this is different than fp emulation which still uses fp regs\n-   and insns - the kernel catches the trap and performs the operation.  */\n-#define TARGET_SOFT_FLOAT\t(target_flags & 0x400)\n-#define TARGET_HARD_FLOAT\t(! TARGET_SOFT_FLOAT)\n+/* ********* DEPRECATED ******** */\n+#define ARM_FLAG_ARM6         (0x0008)\n+\n+/* ********* DEPRECATED ******** */\n+#define ARM_FLAG_ARM3         (0x0010)\n+\n+/* Nonzero if destined for a processor in 32-bit program mode.  Takes out bit\n+   that assume restoration of the condition flags when returning from a\n+   branch and link (ie a function).  */\n+#define ARM_FLAG_APCS_32      (0x0020)\n+\n+/* Nonzero if stack checking should be performed on entry to each function\n+   which allocates temporary variables on the stack.  */\n+#define ARM_FLAG_APCS_STACK   (0x0040)\n+\n+/* Nonzero if floating point parameters should be passed to functions in\n+   floating point registers.  */\n+#define ARM_FLAG_APCS_FLOAT   (0x0080)\n+\n+/* Nonzero if re-entrant, position independent code should be generated.\n+   This is equivalent to -fpic.  */\n+#define ARM_FLAG_APCS_REENT   (0x0100)\n+\n+/* Nonzero if the MMU will trap unaligned word accesses, so shorts must be\n+   loaded byte-at-a-time.  */\n+#define ARM_FLAG_SHORT_BYTE   (0x0200)\n+\n+/* Nonzero if all floating point instructions are missing (and there is no\n+   emulator either).  Generate function calls for all ops in this case.  */\n+#define ARM_FLAG_SOFT_FLOAT   (0x0400)\n+\n+/* Nonzero if we should compile with BYTES_BIG_ENDIAN set to 1.  */\n+#define ARM_FLAG_BIG_END      (0x0800)\n+\n+/* Nonzero if we should compile for Thumb interworking.  */\n+#define ARM_FLAG_THUMB                (0x1000)\n+\n+#define TARGET_APCS\t\t\t(target_flags & ARM_FLAG_APCS_FRAME)\n+#define TARGET_POKE_FUNCTION_NAME\t(target_flags & ARM_FLAG_POKE)\n+#define TARGET_FPE\t\t\t(target_flags & ARM_FLAG_FPE)\n+#define TARGET_6\t\t\t(target_flags & ARM_FLAG_ARM6)\n+#define TARGET_3\t\t\t(target_flags & ARM_FLAG_ARM3)\n+#define TARGET_APCS_32\t\t\t(target_flags & ARM_FLAG_APCS_32)\n+#define TARGET_APCS_STACK\t\t(target_flags & ARM_FLAG_APCS_STACK)\n+#define TARGET_APCS_FLOAT\t\t(target_flags & ARM_FLAG_APCS_FLOAT)\n+#define TARGET_APCS_REENT\t\t(target_flags & ARM_FLAG_APCS_REENT)\n+#define TARGET_SHORT_BY_BYTES\t\t(target_flags & ARM_FLAG_SHORT_BYTE)\n+#define TARGET_SOFT_FLOAT\t\t(target_flags & ARM_FLAG_SOFT_FLOAT)\n+#define TARGET_HARD_FLOAT\t\t(! TARGET_SOFT_FLOAT)\n+#define TARGET_BIG_END\t\t\t(target_flags & ARM_FLAG_BIG_END)\n+#define TARGET_THUMB_INTERWORK\t\t(target_flags & ARM_FLAG_THUMB)\n \n /* SUBTARGET_SWITCHES is used to add flags on a per-config basis.\n    Bit 31 is reserved.  See riscix.h.  */\n@@ -108,31 +154,53 @@ extern int target_flags;\n \n #define TARGET_SWITCHES  \t\t\t\t\\\n {                         \t\t\t\t\\\n-  {\"apcs\",\t\t \t 1},\t\t\t\\\n-  {\"poke-function-name\", \t 2},\t\t\t\\\n-  {\"fpe\",\t\t \t 4},\t\t\t\\\n-  {\"6\",\t\t\t\t 8},\t\t\t\\\n-  {\"2\",\t\t\t\t-8},\t\t\t\\\n-  {\"3\",\t\t\t\t-8},\t\t\t\\\n-  {\"short-load-bytes\",\t\t (0x200)},\t\t\\\n-  {\"no-short-load-bytes\",\t-(0x200)},\t\t\\\n-  {\"short-load-words\", \t\t-(0x200)},\t\t\\\n-  {\"no-short-load-words\",\t (0x200)},\t\t\\\n-  {\"soft-float\",\t\t (0x400)},\t\t\\\n-  {\"hard-float\",\t\t-(0x400)},\t\t\\\n+  {\"apcs\",\t\t\tARM_FLAG_APCS_FRAME},\t\\\n+  {\"apcs-frame\",\t\tARM_FLAG_APCS_FRAME},\t\\\n+  {\"no-apcs-frame\",\t       -ARM_FLAG_APCS_FRAME},\t\\\n+  {\"poke-function-name\",\tARM_FLAG_POKE},\t\t\\\n+  {\"fpe\",\t\t\tARM_FLAG_FPE},\t\t\\\n+  {\"6\",\t\t\t\tARM_FLAG_ARM6},\t\t\\\n+  {\"2\",\t\t\t\tARM_FLAG_ARM3},\t\t\\\n+  {\"3\",\t\t\t\tARM_FLAG_ARM3},\t\t\\\n+  {\"apcs-32\",\t\t\tARM_FLAG_APCS_32},\t\\\n+  {\"apcs-26\",\t\t       -ARM_FLAG_APCS_32},\t\\\n+  {\"apcs-stack-check\",\t\tARM_FLAG_APCS_STACK},\t\\\n+  {\"no-apcs-stack-check\",      -ARM_FLAG_APCS_STACK},\t\\\n+  {\"apcs-float\",\t\tARM_FLAG_APCS_FLOAT},\t\\\n+  {\"no-apcs-float\",\t       -ARM_FLAG_APCS_FLOAT},\t\\\n+  {\"apcs-reentrant\",\t\tARM_FLAG_APCS_REENT},\t\\\n+  {\"no-apcs-rentrant\",\t       -ARM_FLAG_APCS_REENT},\t\\\n+  {\"short-load-bytes\",\t\tARM_FLAG_SHORT_BYTE},\t\\\n+  {\"no-short-load-bytes\",      -ARM_FLAG_SHORT_BYTE},\t\\\n+  {\"short-load-words\",\t       -ARM_FLAG_SHORT_BYTE},\t\\\n+  {\"no-short-load-words\",\tARM_FLAG_SHORT_BYTE},\t\\\n+  {\"soft-float\",\t\tARM_FLAG_SOFT_FLOAT},\t\\\n+  {\"hard-float\",\t       -ARM_FLAG_SOFT_FLOAT},\t\\\n+  {\"big-endian\",\t\tARM_FLAG_BIG_END},\t\\\n+  {\"be\",\t\t\tARM_FLAG_BIG_END},\t\\\n+  {\"little-endian\",\t       -ARM_FLAG_BIG_END},\t\\\n+  {\"le\",\t\t       -ARM_FLAG_BIG_END},\t\\\n+  {\"thumb-interwork\",\t\tARM_FLAG_THUMB},\t\\\n+  {\"no-thumb-interwork\",       -ARM_FLAG_THUMB},\t\\\n   SUBTARGET_SWITCHES\t\t\t\t\t\\\n-  {\"\",   \t\t \t TARGET_DEFAULT }\t\\\n+  {\"\",\t\t\t\tTARGET_DEFAULT }\t\\\n }\n \n-/* Which processor we are running on.  Currently this is only used to\n-   get the condition code clobbering attribute right when we are running on\n-   an arm 6 */\n+#define TARGET_OPTIONS\t\t\t\t\\\n+{\t\t\t\t\t\t\\\n+  {\"cpu-\", &target_cpu_name},\t\t\t\\\n+  {\"cpu=\", &target_cpu_name},\t\t\t\\\n+  {\"fpe-\", &target_fpe_name},\t\t\t\\\n+  {\"fpe=\", &target_fpe_name}\t\t\t\\\n+}\n \n+/* Which processor we are running on.  */\n enum processor_type \n {\n   PROCESSOR_ARM2,\n   PROCESSOR_ARM3,\n-  PROCESSOR_ARM6\n+  PROCESSOR_ARM6,\n+  PROCESSOR_ARM7\n };\n \n /* Recast the cpu class to be the cpu attribute. */\n@@ -142,41 +210,56 @@ enum processor_type\n \n extern enum processor_type arm_cpu;\n \n-/* What sort of floating point unit do we have? Hardware or software.  */\n+enum prog_mode_type\n+{\n+  prog_mode26,\n+  prog_mode32\n+};\n+\n+/* Recast the program mode class to be the prog_mode attribute */\n+#define arm_prog_mode ((enum attr_prog_mode) arm_prgmode)\n+\n+extern enum prog_mode_type arm_prgmode;\n+\n+/* What sort of floating point unit do we have? Hardware or software.\n+   If software, is it issue 2 or issue 3?  */\n enum floating_point_type\n {\n   FP_HARD,\n-  FP_SOFT\n+  FP_SOFT2,\n+  FP_SOFT3\n };\n \n /* Recast the floating point class to be the floating point attribute.  */\n #define arm_fpu_attr ((enum attr_fpu) arm_fpu)\n \n extern enum floating_point_type arm_fpu;\n \n+/* Nonzero if the processor has a fast multiply insn, and one that does\n+   a 64-bit multiply of two 32-bit values.  */\n+extern int arm_fast_multiply;\n+\n+/* Nonzero if this chip support the ARM Architecture 4 extensions */\n+extern int arm_arch4;\n+\n #ifndef TARGET_DEFAULT\n #define TARGET_DEFAULT  0\n #endif\n \n-#define TARGET_MEM_FUNCTIONS 1\n+/* A particular target can define this to a particular cpu name, eg \"arm710dmi\"\n+   and the code generated should then be appropriate for that processor.  */\n+#ifndef ARM_CPU_NAME\n+#define ARM_CPU_NAME NULL\n+#endif\n \n-/* OVERRIDE_OPTIONS takes care of the following:\n-   - if -mpoke-function-name, then -mapcs.\n-   - if doing debugging, then -mapcs; if RISCOS, then -mpoke-function-name.\n-   - if floating point is done by emulation, forget about instruction\n-     scheduling.  Note that this only saves compilation time; it doesn't\n-     matter for the final code.  */\n+/* The frame pointer register used in gcc has nothing to do with debugging;\n+   that is controlled by the APCS-FRAME option.  */\n+/* Not fully implemented yet */\n+/* #define CAN_DEBUG_WITHOUT_FP 1 */\n \n-#define OVERRIDE_OPTIONS  \\\n-{\t\t\t\t\t\t\t\t\\\n-  if (write_symbols != NO_DEBUG && flag_omit_frame_pointer)\t\\\n-    warning (\"-g without a frame pointer may not give sensible debugging\");\\\n-  if (TARGET_POKE_FUNCTION_NAME)\t\t\t\t\\\n-    target_flags |= 1;\t\t\t\t\t\t\\\n-  if (TARGET_FPE)\t\t\t\t\t\t\\\n-    flag_schedule_insns = flag_schedule_insns_after_reload = 0;\t\\\n-  arm_cpu = TARGET_6 ? PROCESSOR_ARM6: PROCESSOR_ARM2;\t\t\\\n-}\n+#define TARGET_MEM_FUNCTIONS 1\n+\n+#define OVERRIDE_OPTIONS  arm_override_options ()\n \f\n /* Target machine storage Layout.  */\n \n@@ -230,13 +313,15 @@ extern enum floating_point_type arm_fpu;\n    Most ARM processors are run in little endian mode, so that is the default.\n    If you want to have it run-time selectable, change the definition in a\n    cover file to be TARGET_BIG_ENDIAN.  */\n-#define BYTES_BIG_ENDIAN  0\n+#define BYTES_BIG_ENDIAN  (TARGET_BIG_END != 0)\n \n /* Define this if most significant word of a multiword number is the lowest\n-   numbered.  */\n+   numbered.\n+   This is always false, even when in big-endian mode.  */\n #define WORDS_BIG_ENDIAN  0\n \n-/* Define this if most significant word of doubles is the lowest numbered */\n+/* Define this if most significant word of doubles is the lowest numbered.\n+   This is always true, even when in little-endian mode.  */\n #define FLOAT_WORDS_BIG_ENDIAN 1\n \n /* Number of bits in an addressable storage unit */\n@@ -272,9 +357,6 @@ extern enum floating_point_type arm_fpu;\n \n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n \n-/* Define number of bits in most basic integer type.\n-   (If undefined, default is BITS_PER_WORD).  */\n-/* #define INT_TYPE_SIZE */\n \f\n /* Standard register usage.  */\n \n@@ -564,11 +646,9 @@ enum reg_class\n /* Return the register class of a scratch register needed to copy IN into\n    or out of a register in CLASS in MODE.  If it can be done directly,\n    NO_REGS is returned.  */\n-#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X)\t\\\n-  (((MODE) == DFmode && (CLASS) == GENERAL_REGS\t\t\\\n-    && true_regnum (X) == -1 && TARGET_HARD_FLOAT)\t\\\n-   ? GENERAL_REGS\t\t\t\t\t\\\n-   : ((MODE) == HImode && true_regnum (X) == -1) ? GENERAL_REGS : NO_REGS)\n+#define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\\\n+  (((MODE) == HImode && ! arm_arch4 && true_regnum (X) == -1)\t\\\n+   ? GENERAL_REGS : NO_REGS)\n \n /* If we need to load shorts byte-at-a-time, then we need a scratch. */\n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)\t\t\t\\\n@@ -645,6 +725,18 @@ enum reg_class\n #define FUNCTION_VALUE_REGNO_P(REGNO)  \\\n   ((REGNO) == 0 || ((REGNO) == 16) && TARGET_HARD_FLOAT)\n \n+/* How large values are returned */\n+/* A C expression which can inhibit the returning of certain function values\n+   in registers, based on the type of value. */\n+#define RETURN_IN_MEMORY(TYPE) \t\t\t\t\t\t\\\n+  (TYPE_MODE ((TYPE)) == BLKmode ||\t\t\t\t\t\\\n+   (AGGREGATE_TYPE_P ((TYPE)) && arm_return_in_memory ((TYPE))))\n+\n+/* Define DEFAULT_PCC_STRUCT_RETURN to 1 if all structure and union return\n+   values must be in memory.  On the ARM, they need only do so if larger\n+   than a word, or if they contain elements offset from zero in the struct. */\n+#define DEFAULT_PCC_STRUCT_RETURN 0\n+\n /* Define where to put the arguments to a function.\n    Value is zero to push the argument on the stack,\n    or a hard register in which to store the argument.\n@@ -831,7 +923,8 @@ enum reg_class\n \t   ldr \t\tr8, [pc, #0]\n \t   ldr\t\tpc, [pc]\n \t   .word\tstatic chain value\n-\t   .word\tfunction's address  */\n+\t   .word\tfunction's address\n+   ??? FIXME: When the trampoline returns, r8 will be clobbered.  */\n #define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\\\n   fprintf ((FILE), \"\\tldr\\t%sr8, [%spc, #0]\\n\",\t\t\t\\\n@@ -892,38 +985,38 @@ enum reg_class\n \n /* Recognize any constant value that is a valid address.  */\n /* XXX We can address any constant, eventually...  */\n-#if 0\n-#define CONSTANT_ADDRESS_P(X)\t\\\n-    ( GET_CODE(X) == LABEL_REF\t\\\n-  ||  GET_CODE(X) == SYMBOL_REF \\\n-  ||  GET_CODE(X) == CONST_INT\t\\\n-  ||  GET_CODE(X) == CONST )\n-#endif\n+\n+#ifdef AOF_ASSEMBLER\n+\n+#define CONSTANT_ADDRESS_P(X)\t\t\\\n+  (GET_CODE (X) == SYMBOL_REF\t\t\\\n+   && CONSTANT_POOL_ADDRESS_P (X))\n+\n+#else\n \n #define CONSTANT_ADDRESS_P(X)  \t\t\t\\\n   (GET_CODE (X) == SYMBOL_REF \t\t\t\\\n    && (CONSTANT_POOL_ADDRESS_P (X)\t\t\\\n        || (optimize > 0 && SYMBOL_REF_FLAG (X))))\n \n+#endif /* AOF_ASSEMBLER */\n+\n /* Nonzero if the constant value X is a legitimate general operand.\n    It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.\n \n    On the ARM, allow any integer (invalid ones are removed later by insn\n    patterns), nice doubles and symbol_refs which refer to the function's\n    constant pool XXX.  */\n-#define LEGITIMATE_CONSTANT_P(X)\t\t\t\t\\\n-  (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n-   || (GET_CODE (X) == CONST_DOUBLE\t\t\t\t\\\n-       && (const_double_rtx_ok_for_fpu (X)\t\t\t\\\n-\t   || neg_const_double_rtx_ok_for_fpu (X)))\t\t\\\n-   || CONSTANT_ADDRESS_P (X))\n+#define LEGITIMATE_CONSTANT_P(X)\t(! label_mentioned_p (X))\n \n /* Symbols in the text segment can be accessed without indirecting via the\n    constant pool; it may take an extra binary operation, but this is still\n    faster than indirecting via memory.  Don't do this when not optimizing,\n    since we won't be calculating al of the offsets necessary to do this\n    simplification.  */\n-\n+/* This doesn't work with AOF syntax, since the string table may be in\n+   a different AREA.  */\n+#ifndef AOF_ASSEMBLER\n #define ENCODE_SECTION_INFO(decl)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (optimize > 0 && TREE_CONSTANT (decl)\t\t\t\t\\\n@@ -934,7 +1027,7 @@ enum reg_class\n       SYMBOL_REF_FLAG (XEXP (rtl, 0)) = 1;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n }\n-\n+#endif\n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class.\n    We have two alternate definitions for each of them.\n@@ -995,7 +1088,7 @@ do\t\t\t\t\t\t\t\t\t\\\n   HOST_WIDE_INT range;\t\t\t\t\t\t\t\\\n   enum rtx_code code = GET_CODE (INDEX);\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-  if (GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\t\t\\\n+  if (TARGET_HARD_FLOAT && GET_MODE_CLASS (MODE) == MODE_FLOAT)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (code == CONST_INT && INTVAL (INDEX) < 1024\t\t\t\\\n \t  && INTVAL (INDEX) > -1024\t\t\t\t\t\\\n@@ -1006,7 +1099,8 @@ do\t\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (INDEX_REGISTER_RTX_P (INDEX) && GET_MODE_SIZE (MODE) <= 4)\t\\\n \tgoto LABEL;\t\t\t\t\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4  && code == MULT)\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4  && code == MULT\t\t\t\\\n+\t  && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  rtx xiop0 = XEXP (INDEX, 0);\t\t\t\t\t\\\n \t  rtx xiop1 = XEXP (INDEX, 1);\t\t\t\t\t\\\n@@ -1019,15 +1113,16 @@ do\t\t\t\t\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n \t  && (code == LSHIFTRT || code == ASHIFTRT\t\t\t\\\n-\t      || code == ASHIFT || code == ROTATERT))\t\t\t\\\n+\t      || code == ASHIFT || code == ROTATERT)\t\t\t\\\n+\t  && (! arm_arch4 || (MODE) != HImode))\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  rtx op = XEXP (INDEX, 1);\t\t\t\t\t\\\n \t  if (INDEX_REGISTER_RTX_P (XEXP (INDEX, 0))\t\t\t\\\n \t      && GET_CODE (op) == CONST_INT && INTVAL (op) > 0\t\t\\\n \t      && INTVAL (op) <= 31)\t\t\t\t\t\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n         }\t\t\t\t\t\t\t\t\\\n-      range = (MODE) == HImode ? 4095 : 4096;\t\t\t\t\\\n+      range = (MODE) == HImode ? (arm_arch4 ? 256 : 4095) : 4096;\t\\\n       if (code == CONST_INT && INTVAL (INDEX) < range\t\t\t\\\n \t  && INTVAL (INDEX) > -range)  \t      \t\t\t\t\\\n         goto LABEL;\t\t\t\t\t\t\t\\\n@@ -1040,16 +1135,33 @@ do\t\t\t\t\t\t\t\t\t\\\n    INDEX+REG, REG-INDEX, and non floating SYMBOL_REF to the constant pool.\n    Allow REG-only and AUTINC-REG if handling TImode or HImode.  Other symbol\n    refs must be forced though a static cell to ensure addressability.  */\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \\\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, LABEL)  \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n   if (BASE_REGISTER_RTX_P (X))\t\t\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n   else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n \t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n+  else if (GET_MODE_SIZE (MODE) >= 4 && reload_completed\t\t\\\n+\t   && (GET_CODE (X) == LABEL_REF\t\t\t\t\\\n+\t       || (GET_CODE (X) == CONST\t\t\t\t\\\n+\t\t   && GET_CODE (XEXP ((X), 0)) == PLUS\t\t\t\\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 0)) == LABEL_REF\t\\\n+\t\t   && GET_CODE (XEXP (XEXP ((X), 0), 1)) == CONST_INT)))\\\n+    goto LABEL;\t\t\t\t\t\t\t\t\\\n   else if ((MODE) == TImode)\t\t\t\t\t\t\\\n     ;\t\t\t\t\t\t\t\t\t\\\n+  else if ((MODE) == DImode || (TARGET_SOFT_FLOAT && (MODE) == DFmode))\t\\\n+    {                                                              \t\\\n+      if (GET_CODE (X) == PLUS && BASE_REGISTER_RTX_P (XEXP (X, 0)) \t\\\n+\t  && GET_CODE (XEXP (X, 1)) == CONST_INT)   \t\t\t\\\n+\t{                                          \t\t\t\\\n+\t  HOST_WIDE_INT val = INTVAL (XEXP (X, 1)); \t\t\t\\\n+          if (val == 4 || val == -4 || val == -8)\t\t\t\\\n+\t    goto LABEL;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   else if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx xop0 = XEXP(X,0);\t\t\t\t\t\t\\\n@@ -1073,6 +1185,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t   && CONSTANT_POOL_ADDRESS_P (X))\t\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n   else if ((GET_CODE (X) == PRE_INC || GET_CODE (X) == POST_DEC)\t\\\n+\t   && (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\\\n \t   && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n \t   && REG_OK_FOR_PRE_POST_P (XEXP (X, 0)))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n@@ -1101,17 +1214,17 @@ do\t\t\t\t\t\t\t\t\t\\\n       rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n       rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n \t\t\t\t\t\t\t\t\t \\\n-      if (CONSTANT_P (xop0) && ! LEGITIMATE_CONSTANT_P (xop0))\t\t \\\n+      if (CONSTANT_P (xop0) && ! symbol_mentioned_p (xop0))\t\t \\\n \txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n-      if (CONSTANT_P (xop1) && ! LEGITIMATE_CONSTANT_P (xop1))\t\t \\\n+      if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\t\t \\\n \txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n       if (BASE_REGISTER_RTX_P (xop0) && GET_CODE (xop1) == CONST_INT)\t \\\n \t{\t\t\t\t\t\t\t\t \\\n \t  HOST_WIDE_INT n, low_n;\t\t\t\t\t \\\n \t  rtx base_reg, val;\t\t\t\t\t\t \\\n \t  n = INTVAL (xop1);\t\t\t\t\t\t \\\n \t\t\t\t\t\t\t\t\t \\\n-\t  if (MODE == DImode)\t\t\t\t\t\t \\\n+\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t \\\n \t    {\t\t\t\t\t\t\t\t \\\n \t      low_n = n & 0x0f;\t\t\t\t\t\t \\\n \t      n &= ~0x0f;\t\t\t\t\t\t \\\n@@ -1144,7 +1257,7 @@ do\t\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t \\\n       if (CONSTANT_P (xop0))\t\t\t\t\t\t \\\n \txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n-      if (CONSTANT_P (xop1) && ! LEGITIMATE_CONSTANT_P (xop1))\t\t \\\n+      if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\t\t \\\n \txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n       if (xop0 != XEXP (X, 0) || xop1 != XEXP (X, 1))\t\t\t \\\n \t(X) = gen_rtx (MINUS, SImode, xop0, xop1);\t\t\t \\\n@@ -1153,7 +1266,6 @@ do\t\t\t\t\t\t\t\t\t\\\n     goto WIN;\t\t\t\t\t\t\t\t \\\n }\n \n-\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n@@ -1200,7 +1312,7 @@ do\t\t\t\t\t\t\t\t\t\\\n    be the code that says which one of the two operations is implicitly\n    done, NIL if none.  */\n #define LOAD_EXTEND_OP(MODE)\t\t\t\t\t\t\\\n-  ((MODE) == QImode ? ZERO_EXTEND\t\t\t\t\t\\\n+  ((arm_arch4 || (MODE) == QImode) ? ZERO_EXTEND\t\t\t\\\n    : ((BYTES_BIG_ENDIAN && (MODE) == HImode) ? SIGN_EXTEND : NIL))\n \n /* Define this if zero-extension is slow (more than one real instruction).\n@@ -1222,7 +1334,6 @@ do\t\t\t\t\t\t\t\t\t\\\n    rotates is modulo 32 used. */\n /* #define SHIFT_COUNT_TRUNCATED 1 */\n \n-/* XX This is not true, is it?  */\n /* All integers have the same format so truncation is easy.  */\n #define TRULY_NOOP_TRUNCATION(OUTPREC,INPREC)  1\n \n@@ -1271,8 +1382,8 @@ do\t\t\t\t\t\t\t\t\t\\\n   ((X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n    || (X) == arg_pointer_rtx)\n \n-#define RTX_COSTS(X,CODE,OUTER_CODE)                                    \\\n-  default:\t\t\t\t\t\t\t\t\\\n+#define RTX_COSTS(X,CODE,OUTER_CODE)\t\t\\\n+  default:\t\t\t\t\t\\\n    return arm_rtx_costs (X, CODE, OUTER_CODE);\n \n /* Moves to and from memory are quite expensive */\n@@ -1367,128 +1478,22 @@ extern int arm_compare_fp;\n   {\"reversible_cc_register\", {REG}},\n \n \f\n-/* Assembler output control */\n-\n-#ifndef ARM_OS_NAME\n-#define ARM_OS_NAME \"(generic)\"\n-#endif\n-\n-/* The text to go at the start of the assembler file */\n-#define ASM_FILE_START(STREAM)\t\t\t\t\t\t  \\\n-{\t\t\t\t\t\t\t\t\t  \\\n-  extern char *version_string;\t\t\t\t\t\t  \\\n-  fprintf (STREAM,\"%s Generated by gcc %s for ARM/%s\\n\",\t\t  \\\n-\t   ASM_COMMENT_START, version_string, ARM_OS_NAME);\t\t  \\\n-  fprintf (STREAM,\"%srfp\\t.req\\t%sr9\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%ssl\\t.req\\t%sr10\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%sfp\\t.req\\t%sr11\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%sip\\t.req\\t%sr12\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%ssp\\t.req\\t%sr13\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%slr\\t.req\\t%sr14\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-  fprintf (STREAM,\"%spc\\t.req\\t%sr15\\n\", REGISTER_PREFIX, REGISTER_PREFIX); \\\n-}\n-\n-#define ASM_APP_ON  \"\"\n-#define ASM_APP_OFF  \"\"\n-\n-/* Switch to the text or data segment.  */\n-#define TEXT_SECTION_ASM_OP  \".text\"\n-#define DATA_SECTION_ASM_OP  \".data\"\n-\n-#define REGISTER_PREFIX \"\"\n-#define USER_LABEL_PREFIX \"_\"\n-#define LOCAL_LABEL_PREFIX \"\"\n-\n-/* The assembler's names for the registers.  */\n-#ifndef REGISTER_NAMES\n-#define REGISTER_NAMES  \\\n-{\t\t\t\t                   \\\n-  \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",  \\\n-  \"r8\", \"r9\", \"sl\", \"fp\", \"ip\", \"sp\", \"lr\", \"pc\",  \\\n-  \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\",  \\\n-  \"cc\", \"sfp\", \"afp\"\t\t\t\t   \\\n-}\n-#endif\n-\n-#ifndef ADDITIONAL_REGISTER_NAMES\n-#define ADDITIONAL_REGISTER_NAMES\t\t\\\n-{\t\t\t\t\t\t\\\n-  {\"a1\", 0},\t\t\t\t\t\\\n-  {\"a2\", 1},\t\t\t\t\t\\\n-  {\"a3\", 2},\t\t\t\t\t\\\n-  {\"a4\", 3},\t\t\t\t\t\\\n-  {\"v1\", 4},\t\t\t\t\t\\\n-  {\"v2\", 5},\t\t\t\t\t\\\n-  {\"v3\", 6},\t\t\t\t\t\\\n-  {\"v4\", 7},\t\t\t\t\t\\\n-  {\"v5\", 8},\t\t\t\t\t\\\n-  {\"v6\", 9},\t\t\t\t\t\\\n-  {\"rfp\", 9}, /* Gcc used to call it this */\t\\\n-  {\"sb\", 9},\t\t\t\t\t\\\n-  {\"v7\", 10},\t\t\t\t\t\\\n-  {\"r10\", 10},\t\t\t\t\t\\\n-  {\"r11\", 11},\t/* fp */\t\t\t\\\n-  {\"r12\", 12},\t/* ip */\t\t\t\\\n-  {\"r13\", 13},\t/* sp */\t\t\t\\\n-  {\"r14\", 14},\t/* lr */\t\t\t\\\n-  {\"r15\", 15}\t/* pc */\t\t\t\\\n-}\n-#endif\n-\n-/* Arm Assembler barfs on dollars */\n-#define DOLLARS_IN_IDENTIFIERS 0\n-\n-#define NO_DOLLAR_IN_LABEL\n-\n-/* DBX register number for a given compiler register number */\n-#define DBX_REGISTER_NUMBER(REGNO)  (REGNO)\n-\n-/* Generate DBX debugging information.  riscix.h will undefine this because\n-   the native assembler does not support stabs. */\n-#define DBX_DEBUGGING_INFO  1\n-\n-/* Acorn dbx moans about continuation chars, so don't use any.  */\n-#ifndef DBX_CONTIN_LENGTH\n-#define DBX_CONTIN_LENGTH  0\n-#endif\n \n-/* Output a source filename for the debugger. RISCiX dbx insists that the\n-   ``desc'' field is set to compiler version number >= 315 (sic).  */\n-#define DBX_OUTPUT_MAIN_SOURCE_FILENAME(STREAM,NAME) \t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  fprintf (STREAM, \".stabs \\\"%s\\\",%d,0,315,%s\\n\", (NAME), N_SO,\t\t\\\n-\t   &ltext_label_name[1]);\t\t\t\t\t\\\n-  text_section ();\t\t\t\t\t\t\t\\\n-  ASM_OUTPUT_INTERNAL_LABEL (STREAM, \"Ltext\", 0);\t\t\t\\\n-} while (0)\n-  \n-/* Output a label definition.  */\n-#define ASM_OUTPUT_LABEL(STREAM,NAME)  \\\n-  arm_asm_output_label ((STREAM), (NAME))\n-\n-/* Output a function label definition.  */\n-#define ASM_DECLARE_FUNCTION_NAME(STREAM,NAME,DECL) \\\n-    ASM_OUTPUT_LABEL(STREAM, NAME)\n-\n-/* Output a globalising directive for a label.  */\n-#define ASM_GLOBALIZE_LABEL(STREAM,NAME)  \\\n-  (fprintf (STREAM, \"\\t.global\\t\"),\t  \\\n-   assemble_name (STREAM, NAME),\t  \\\n-   fputc ('\\n',STREAM))                   \\\n+/* Gcc puts the pool in the wrong place for ARM, since we can only\n+   load addresses a limited distance around the pc.  We do some\n+   special munging to move the constant pool values to the correct\n+   point in the code.  */\n+#define MACHINE_DEPENDENT_REORG(INSN)\tarm_reorg ((INSN))\n \n-/* Output a reference to a label.  */\n-#define ASM_OUTPUT_LABELREF(STREAM,NAME)  \\\n-  fprintf (STREAM, \"%s%s\", USER_LABEL_PREFIX, NAME)\n-\n-/* Make an internal label into a string.  */\n-#define ASM_GENERATE_INTERNAL_LABEL(STRING, PREFIX, NUM)  \\\n-  sprintf (STRING, \"*%s%d\", PREFIX, NUM)\n+/* The pool is empty, since we have moved everything into the code.  */\n+#define ASM_OUTPUT_SPECIAL_POOL_ENTRY(FILE,X,MODE,ALIGN,LABELNO,JUMPTO)\t\\\n+  goto JUMPTO\n \n /* Output an internal label definition.  */\n #define ASM_OUTPUT_INTERNAL_LABEL(STREAM, PREFIX, NUM)  \\\n   do                                    \t      \t   \t\t\\\n     {\t\t\t\t\t\t      \t   \t\t\\\n-      char *s = (char *) alloca (11 + strlen (PREFIX));\t   \t\t\\\n+      char *s = (char *) alloca (40 + strlen (PREFIX));\t   \t\t\\\n       extern int arm_target_label, arm_ccfsm_state;\t   \t\t\\\n       extern rtx arm_target_insn;\t\t\t\t\t\\\n \t\t\t\t\t\t           \t\t\\\n@@ -1498,19 +1503,13 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t  arm_ccfsm_state = 0;\t\t\t\t        \t\\\n \t  arm_target_insn = NULL;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n-\tstrcpy (s, \"*\");\t\t\t\t      \t\t\\\n-\tsprintf (&s[strlen (s)], \"%s%d\", (PREFIX), (NUM));   \t\t\\\n+\tASM_GENERATE_INTERNAL_LABEL (s, (PREFIX), (NUM));   \t\t\\\n \tarm_asm_output_label (STREAM, s);\t\t                \\\n     } while (0)\n \n-/* Nothing special is done about jump tables */\n-/* #define ASM_OUTPUT_CASE_LABEL(STREAM,PREFIX,NUM,TABLE)   */\n-/* #define ASM_OUTPUT_CASE_END(STREAM,NUM,TABLE)\t    */\n-\n-/* Construct a private name.  */\n-#define ASM_FORMAT_PRIVATE_NAME(OUTVAR,NAME,NUMBER)  \\\n-  ((OUTVAR) = (char *) alloca (strlen (NAME) + 10),  \\\n-   sprintf ((OUTVAR), \"%s.%d\", (NAME), (NUMBER)))\n+/* Output a label definition.  */\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\t\\\n+  arm_asm_output_label ((STREAM), (NAME))\n \n /* Output a push or a pop instruction (only used when profiling).  */\n #define ASM_OUTPUT_REG_PUSH(STREAM,REGNO) \\\n@@ -1521,132 +1520,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n   fprintf(STREAM,\"\\tldmfd\\t%ssp!,{%s%s}\\n\", \\\n \t  REGISTER_PREFIX, REGISTER_PREFIX, reg_names[REGNO])\n \n-/* Output a relative address. Not needed since jump tables are absolute\n-   but we must define it anyway.  */\n-#define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM,VALUE,REL)  \\\n-  fputs (\"- - - ASM_OUTPUT_ADDR_DIFF_ELT called!\\n\", STREAM)\n-\n-/* Output an element of a dispatch table.  */\n-#define ASM_OUTPUT_ADDR_VEC_ELT(STREAM,VALUE)  \\\n-   fprintf (STREAM, \"\\t.word\\tL%d\\n\", VALUE)\n-\n-/* Output various types of constants.  For real numbers we output hex, with\n-   a comment containing the \"human\" value, this allows us to pass NaN's which\n-   the riscix assembler doesn't understand (it also makes cross-assembling\n-   less likely to fail). */\n-\n-#define ASM_OUTPUT_LONG_DOUBLE(STREAM,VALUE)\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[3];\t\t\t\t\t\t\t\t\\\n-     arm_increase_location (12);\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.20g\", dstr);\t\t\t\\\n-     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x,0x%x,0x%x\\t%s long double %s\\n\",\t\\\n-\t\tl[2], l[1], l[0], ASM_COMMENT_START, dstr);\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx,0x%lx,0x%lx\\t%s long double %s\\n\",\\\n-\t\tl[0], l[1], l[2], ASM_COMMENT_START, dstr);\t\t\\\n-   } while (0)\n-\n-    \n-#define ASM_OUTPUT_DOUBLE(STREAM, VALUE)  \t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l[2];\t\t\t\t\t\t\t\t\\\n-     arm_increase_location (8);\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_DOUBLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.14g\", dstr);\t\t\t\\\n-     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%x, 0x%x\\t%s double %s\\n\", l[0],\t\\\n-\t\tl[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.long 0x%lx, 0x%lx\\t%s double %s\\n\", l[0],\t\\\n-\t\tl[1], ASM_COMMENT_START, dstr);\t\t\t\t\\\n-   } while (0)\n-\n-#define ASM_OUTPUT_FLOAT(STREAM, VALUE)\t\t\t\t\t\\\n-do { char dstr[30];\t\t\t\t\t\t\t\\\n-     long l;\t\t\t\t\t\t\t\t\\\n-     arm_increase_location (4);\t\t\t\t\t\t\\\n-     REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\t\t\t\\\n-     REAL_VALUE_TO_DECIMAL (VALUE, \"%.7g\", dstr);\t\t\t\\\n-     if (sizeof (int) == sizeof (long))\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%x\\t%s float %s\\n\", l,\t\t\\\n-\t\tASM_COMMENT_START, dstr);\t\t\t\t\\\n-     else\t\t\t\t\t\t\t\t\\\n-       fprintf (STREAM, \"\\t.word 0x%lx\\t%s float %s\\n\", l,\t\t\\\n-\t\tASM_COMMENT_START, dstr);\t\t\t\t\\\n-   } while (0);\n-\n-#define ASM_OUTPUT_INT(STREAM, EXP)\t\\\n-  (fprintf (STREAM, \"\\t.word\\t\"),\t\\\n-   output_addr_const (STREAM, (EXP)),\t\\\n-   arm_increase_location (4),\t\t\\\n-   fputc ('\\n', STREAM))\n-\n-#define ASM_OUTPUT_SHORT(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.short\\t\"),     \\\n-   output_addr_const (STREAM, (EXP)),  \\\n-   arm_increase_location (2),          \\\n-   fputc ('\\n', STREAM))\n-\n-#define ASM_OUTPUT_CHAR(STREAM, EXP)  \\\n-  (fprintf (STREAM, \"\\t.byte\\t\"),      \\\n-   output_addr_const (STREAM, (EXP)),  \\\n-   arm_increase_location (1),          \\\n-   fputc ('\\n', STREAM))\n-\n-#define ASM_OUTPUT_BYTE(STREAM, VALUE)  \\\n-  (fprintf (STREAM, \"\\t.byte\\t%d\\n\", VALUE),  \\\n-   arm_increase_location (1))\n-\n-#define ASM_OUTPUT_ASCII(STREAM, PTR, LEN)  \\\n-  output_ascii_pseudo_op ((STREAM), (unsigned char *)(PTR), (LEN))\n-\n-/* Output a gap.  In fact we fill it with nulls.  */\n-#define ASM_OUTPUT_SKIP(STREAM, NBYTES)  \\\n-  (arm_increase_location (NBYTES),              \\\n-   fprintf (STREAM, \"\\t.space\\t%d\\n\", NBYTES))\n-\n-/* Align output to a power of two.  Horrible /bin/as.  */\n-#define ASM_OUTPUT_ALIGN(STREAM, POWER)  \\\n-  do                                                           \\\n-    {                                                          \\\n-      register int amount = 1 << (POWER);                      \\\n-      extern int arm_text_location;\t\t\t       \\\n-                                                               \\\n-      if (amount == 2)                                         \\\n-\tfprintf (STREAM, \"\\t.even\\n\");                         \\\n-      else                                                     \\\n-\tfprintf (STREAM, \"\\t.align\\t%d\\n\", amount - 4);        \\\n-                                                               \\\n-      if (in_text_section ())                                  \\\n-\tarm_text_location = ((arm_text_location + amount - 1)  \\\n-\t\t\t     & ~(amount - 1));                 \\\n-    } while (0)\n-\n-/* Output a common block */\n-#define ASM_OUTPUT_COMMON(STREAM, NAME, SIZE, ROUNDED)  \t\t\\\n-  (fprintf (STREAM, \"\\t.comm\\t\"), \t\t     \t\t\t\\\n-   assemble_name ((STREAM), (NAME)),\t\t     \t\t\t\\\n-   fprintf(STREAM, \", %d\\t%s %d\\n\", ROUNDED, ASM_COMMENT_START, SIZE))\n-\n-/* Output a local common block.  /bin/as can't do this, so hack a `.space' into\n-   the bss segment.  Note that this is *bad* practice.  */\n-#define ASM_OUTPUT_LOCAL(STREAM,NAME,SIZE,ROUNDED)  \\\n-  output_lcomm_directive (STREAM, NAME, SIZE, ROUNDED)\n-\n-/* Output a source line for the debugger.  */\n-/* #define ASM_OUTPUT_SOURCE_LINE(STREAM,LINE) */\n-\n-/* Output a #ident directive.  */\n-#define ASM_OUTPUT_IDENT(STREAM,STRING)  \\\n-  fprintf (STREAM,\"- - - ident %s\\n\",STRING)\n-\n-/* The assembler's parentheses characters.  */\n-#define ASM_OPEN_PAREN \"(\"\n-#define ASM_CLOSE_PAREN \")\"\n-\n /* Target characters.  */\n #define TARGET_BELL\t007\n #define TARGET_BS\t010\n@@ -1662,10 +1535,6 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n   if (optimize)\t\t\t\t\t    \\\n     final_prescan_insn (INSN, OPVEC, NOPERANDS)\n \n-#ifndef ASM_COMMENT_START\n-#define ASM_COMMENT_START \"@\"\n-#endif\n-\n #define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\\\n   ((CODE) == '?' || (CODE) == '|' || (CODE) == '@')\n /* Output an operand of an instruction.  */"}]}