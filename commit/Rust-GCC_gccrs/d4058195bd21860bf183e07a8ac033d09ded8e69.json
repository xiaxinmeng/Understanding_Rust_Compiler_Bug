{"sha": "d4058195bd21860bf183e07a8ac033d09ded8e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQwNTgxOTViZDIxODYwYmYxODNlMDdhOGFjMDMzZDA5ZGVkOGU2OQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-09-03T19:13:34Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-09-03T19:13:34Z"}, "message": "Makefile.in (tlink.o): Don't depend on toplev.h.\n\n\t* Makefile.in (tlink.o): Don't depend on toplev.h.\n\n\t* collect2.c (c_file, o_file, export_file, import_file, ldout,\n\toutput_file, nm_file_name, ldd_file_name, strip_file_name,\n\tc_file_name, prefix_list, libexts, is_ctor_dtor, find_a_file,\n\tadd_prefix, prefix_from_env, prefix_from_string, do_wait,\n\tfork_execute, maybe_unlink, add_to_list,\n\textract_init_priority, write_list, dump_list,\n\tdump_prefix_list, write_list_with_asm, write_c_file,\n\twrite_c_file_stat, write_c_file_glob, scan_prog_file,\n\tscan_libraries, is_in_list, resolve_lib_name, use_import_list,\n\tignore_library, extract_string, notice, dump_file, target_machine,\n\tcollect_wait, collect_execute, libname, locatelib, aix_std_libs,\n\tread_file, print_load_command): Constify a char*.\n\t(fdopen, error, fatal, fatal_perror): Don't prototype.\n\t(my_strerror): Remove.  All callers use xstrerror instead.\n\t(xcalloc, xmalloc, xrealloc, xstrdup, putenv): Remove definitions.\n\t(main): Add prototype.  Constify lots of char* ptrs.  Change calls\n\tto xcalloc/strcpy/strcat/...  to one call to concat.\n\t(main, scan_prog_file, scan_libraries): Use an intermediate\n\t`const char **' to build an argv array.\n\t(mapfile, libselect, libcompare, locatelib): Add prototypes.\n\n\t* collect2.h (collect_execute, collect_wait, dump_file,\n\tfile_exists): Constify a char*.\n\t(ldout, c_file_name, temporary_obstack, permanent_obstack,\n\ttemporary_firstobj, vflag, debug): Add extern declarations.\n\t(fancy_abort, error, notice, fatal, fatal_perror): Add prototypes.\n\n\t* tlink.c: Don't include toplev.h.\n\t(vflag, debug, ldout, c_file_name, temporary_obstack,\n\tpermanent_obstack, temporary_firstobj): Don't declare.\n\t(tlink_execute, frob_extension, symbol_hash_lookup,\n\tfile_hash_lookup, demangled_hash_lookup, tlink_init, freadsym,\n\trecompile_files, read_repo_files, demangle_new_symbols,\n\tscan_linker_output): Constify a char*.\n\t(symbol_hash_newfunc, file_hash_newfunc, demangled_hash_newfunc,\n\tdo_tlink): Mark parameters with ATTRIBUTE_UNUSED.\n\nFrom-SVN: r29087", "tree": {"sha": "22ab06cab899e64f8be5b78f963f880fe8dbfd60", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/22ab06cab899e64f8be5b78f963f880fe8dbfd60"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4058195bd21860bf183e07a8ac033d09ded8e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4058195bd21860bf183e07a8ac033d09ded8e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4058195bd21860bf183e07a8ac033d09ded8e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4058195bd21860bf183e07a8ac033d09ded8e69/comments", "author": null, "committer": null, "parents": [{"sha": "2f11d4079a934bae14bc415f5f55fd690ca1187c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f11d4079a934bae14bc415f5f55fd690ca1187c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f11d4079a934bae14bc415f5f55fd690ca1187c"}], "stats": {"total": 591, "additions": 254, "deletions": 337}, "files": [{"sha": "9ef5e48a085093c499722e48e11749ddec1b2373", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4058195bd21860bf183e07a8ac033d09ded8e69", "patch": "@@ -1,3 +1,44 @@\n+Fri Sep  3 15:10:20 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* Makefile.in (tlink.o): Don't depend on toplev.h.\n+\n+\t* collect2.c (c_file, o_file, export_file, import_file, ldout,\n+\toutput_file, nm_file_name, ldd_file_name, strip_file_name,\n+\tc_file_name, prefix_list, libexts, is_ctor_dtor, find_a_file,\n+\tadd_prefix, prefix_from_env, prefix_from_string, do_wait,\n+\tfork_execute, maybe_unlink, add_to_list,\n+\textract_init_priority, write_list, dump_list,\n+\tdump_prefix_list, write_list_with_asm, write_c_file,\n+\twrite_c_file_stat, write_c_file_glob, scan_prog_file,\n+\tscan_libraries, is_in_list, resolve_lib_name, use_import_list,\n+\tignore_library, extract_string, notice, dump_file, target_machine,\n+\tcollect_wait, collect_execute, libname, locatelib, aix_std_libs,\n+\tread_file, print_load_command): Constify a char*.\n+\t(fdopen, error, fatal, fatal_perror): Don't prototype.\n+\t(my_strerror): Remove.  All callers use xstrerror instead.\n+\t(xcalloc, xmalloc, xrealloc, xstrdup, putenv): Remove definitions.\n+\t(main): Add prototype.  Constify lots of char* ptrs.  Change calls\n+\tto xcalloc/strcpy/strcat/...  to one call to concat.\n+\t(main, scan_prog_file, scan_libraries): Use an intermediate\n+\t`const char **' to build an argv array.\n+\t(mapfile, libselect, libcompare, locatelib): Add prototypes.\n+\n+\t* collect2.h (collect_execute, collect_wait, dump_file,\n+\tfile_exists): Constify a char*.\n+\t(ldout, c_file_name, temporary_obstack, permanent_obstack,\n+\ttemporary_firstobj, vflag, debug): Add extern declarations.\n+\t(fancy_abort, error, notice, fatal, fatal_perror): Add prototypes.\n+\n+\t* tlink.c: Don't include toplev.h.\n+\t(vflag, debug, ldout, c_file_name, temporary_obstack,\n+\tpermanent_obstack, temporary_firstobj): Don't declare.\n+\t(tlink_execute, frob_extension, symbol_hash_lookup,\n+\tfile_hash_lookup, demangled_hash_lookup, tlink_init, freadsym,\n+\trecompile_files, read_repo_files, demangle_new_symbols,\n+\tscan_linker_output): Constify a char*.\n+\t(symbol_hash_newfunc, file_hash_newfunc, demangled_hash_newfunc,\n+\tdo_tlink): Mark parameters with ATTRIBUTE_UNUSED.\n+\t\n Fri Sep  3 18:09:24 1999  Andrew Haley  <aph@cygnus.com>\n \n \t* config/m68k/m68kelf.h: Set USE_GAS; this makes gcc generate jbsr"}, {"sha": "164d939368d49e83c7a5151f0d0e410aaddde83d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=d4058195bd21860bf183e07a8ac033d09ded8e69", "patch": "@@ -1356,7 +1356,7 @@ collect2.o : collect2.c $(CONFIG_H) system.h gstab.h intl.h \\\n \t-DTARGET_MACHINE=\\\"$(target_alias)\\\" $(MAYBE_USE_COLLECT2) \\\n \t-c `echo $(srcdir)/collect2.c | sed 's,^\\./,,'`\n \n-tlink.o: tlink.c $(DEMANGLE_H) hash.h $(CONFIG_H) system.h toplev.h collect2.h\n+tlink.o: tlink.c $(DEMANGLE_H) hash.h $(CONFIG_H) system.h collect2.h\n hash.o: hash.c hash.h system.h toplev.h\n \n vfprintf.o: $(srcdir)/../libiberty/vfprintf.c $(CONFIG_H) system.h"}, {"sha": "cf655f5c6c8c0a055c43ece72a94db95caf763ad", "filename": "gcc/collect2.c", "status": "modified", "additions": 174, "deletions": 304, "changes": 478, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=d4058195bd21860bf183e07a8ac033d09ded8e69", "patch": "@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-extern char *make_temp_file PROTO ((char *));\n+extern char *make_temp_file PROTO ((const char *));\n \f\n /* On certain systems, we have code that works by scanning the object file\n    directly.  But this code uses system-specific header files and library\n@@ -196,20 +196,20 @@ int debug;\t\t\t\t/* true if -debug */\n \n static int shared_obj;\t\t        /* true if -shared */\n \n-static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list.  */\n-static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list.  */\n+static const char *c_file;\t\t/* <xxx>.c for constructor/destructor list.  */\n+static const char *o_file;\t\t/* <xxx>.o for constructor/destructor list.  */\n #ifdef COLLECT_EXPORT_LIST\n-static char *export_file;\t        /* <xxx>.x for AIX export list.  */\n-static char *import_file;\t        /* <xxx>.p for AIX import list.  */\n+static const char *export_file;\t        /* <xxx>.x for AIX export list.  */\n+static const char *import_file;\t        /* <xxx>.p for AIX import list.  */\n #endif\n-char *ldout;\t\t\t\t/* File for ld errors.  */\n-static char *output_file;\t\t/* Output file for ld.  */\n-static char *nm_file_name;\t\t/* pathname of nm */\n+const char *ldout;\t\t\t/* File for ld errors.  */\n+static const char *output_file;\t\t/* Output file for ld.  */\n+static const char *nm_file_name;\t/* pathname of nm */\n #ifdef LDD_SUFFIX\n-static char *ldd_file_name;\t\t/* pathname of ldd (or equivalent) */\n+static const char *ldd_file_name;\t/* pathname of ldd (or equivalent) */\n #endif\n-static char *strip_file_name;\t\t/* pathname of strip */\n-char *c_file_name;\t\t        /* pathname of gcc */\n+static const char *strip_file_name;\t\t/* pathname of strip */\n+const char *c_file_name;\t        /* pathname of gcc */\n static char *initname, *fininame;\t/* names of init and fini funcs */\n \n static struct head constructors;\t/* list of constructors found */\n@@ -231,8 +231,6 @@ int pexecute_pid;\n /* Defined in the automatically-generated underscore.c.  */\n extern int prepends_underscore;\n \n-extern FILE *fdopen ();\n-\n #ifndef GET_ENV_PATH_LIST\n #define GET_ENV_PATH_LIST(VAR,NAME)\tdo { (VAR) = getenv (NAME); } while (0)\n #endif\n@@ -242,15 +240,15 @@ extern FILE *fdopen ();\n \n struct prefix_list\n {\n-  char *prefix;               /* String to prepend to the path.  */\n+  const char *prefix;         /* String to prepend to the path.  */\n   struct prefix_list *next;   /* Next in linked list.  */\n };\n \n struct path_prefix\n {\n   struct prefix_list *plist;  /* List of prefixes to try */\n   int max_len;                /* Max length of a prefix in PLIST */\n-  char *name;                 /* Name of this list (used in config stuff) */\n+  const char *name;           /* Name of this list (used in config stuff) */\n };\n \n #ifdef COLLECT_EXPORT_LIST\n@@ -260,48 +258,47 @@ static struct path_prefix cmdline_lib_dirs; /* directories specified with -L */\n static struct path_prefix libpath_lib_dirs; /* directories in LIBPATH */\n static struct path_prefix *libpaths[3] = {&cmdline_lib_dirs,\n \t\t\t\t\t  &libpath_lib_dirs, NULL};\n-static char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n+static const char *libexts[3] = {\"a\", \"so\", NULL};  /* possible library extentions */\n #endif\n \n-void error\t\tPVPROTO((const char *, ...)) ATTRIBUTE_PRINTF_1;\n-void fatal\t\tPVPROTO((const char *, ...)) \n-  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-void fatal_perror\tPVPROTO((const char *, ...))\n-  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n-static char *my_strerror\tPROTO((int));\n static const char *my_strsignal\tPROTO((int));\n static void handler\t\tPROTO((int));\n-static int is_ctor_dtor\t\tPROTO((char *));\n-static char *find_a_file\tPROTO((struct path_prefix *, char *));\n-static void add_prefix\t\tPROTO((struct path_prefix *, char *));\n-static void prefix_from_env\tPROTO((char *, struct path_prefix *));\n-static void prefix_from_string\tPROTO((char *, struct path_prefix *));\n-static void do_wait\t\tPROTO((char *));\n-static void fork_execute\tPROTO((char *, char **));\n-static void maybe_unlink\tPROTO((char *));\n-static void add_to_list\t\tPROTO((struct head *, char *));\n-static int  extract_init_priority PROTO((char *));\n+static int is_ctor_dtor\t\tPROTO((const char *));\n+static char *find_a_file\tPROTO((struct path_prefix *, const char *));\n+static void add_prefix\t\tPROTO((struct path_prefix *, const char *));\n+static void prefix_from_env\tPROTO((const char *, struct path_prefix *));\n+static void prefix_from_string\tPROTO((const char *, struct path_prefix *));\n+static void do_wait\t\tPROTO((const char *));\n+static void fork_execute\tPROTO((const char *, char **));\n+static void maybe_unlink\tPROTO((const char *));\n+static void add_to_list\t\tPROTO((struct head *, const char *));\n+static int extract_init_priority PROTO((const char *));\n static void sort_ids\t\tPROTO((struct head *));\n-static void write_list\t\tPROTO((FILE *, char *, struct id *));\n+static void write_list\t\tPROTO((FILE *, const char *, struct id *));\n #ifdef COLLECT_EXPORT_LIST\n-static void dump_list\t\tPROTO((FILE *, char *, struct id *));\n+static void dump_list\t\tPROTO((FILE *, const char *, struct id *));\n #endif\n #if 0\n-static void dump_prefix_list\tPROTO((FILE *, char *, struct prefix_list *));\n+static void dump_prefix_list\tPROTO((FILE *, const char *, struct prefix_list *));\n+#endif\n+static void write_list_with_asm PROTO((FILE *, const char *, struct id *));\n+static void write_c_file\tPROTO((FILE *, const char *));\n+static void write_c_file_stat\tPROTO((FILE *, const char *));\n+#ifndef LD_INIT_SWITCH\n+static void write_c_file_glob\tPROTO((FILE *, const char *));\n #endif\n-static void write_list_with_asm PROTO((FILE *, char *, struct id *));\n-static void write_c_file\tPROTO((FILE *, char *));\n-static void scan_prog_file\tPROTO((char *, enum pass));\n+static void scan_prog_file\tPROTO((const char *, enum pass));\n #ifdef SCAN_LIBRARIES\n-static void scan_libraries\tPROTO((char *));\n+static void scan_libraries\tPROTO((const char *));\n #endif\n #ifdef COLLECT_EXPORT_LIST\n-static int is_in_list\t\tPROTO((char *, struct id *));\n+static int is_in_list\t\tPROTO((const char *, struct id *));\n static void write_aix_file\tPROTO((FILE *, struct id *));\n-static char *resolve_lib_name\tPROTO((char *));\n-static int use_import_list\tPROTO((char *));\n-static int ignore_library\tPROTO((char *));\n+static char *resolve_lib_name\tPROTO((const char *));\n+static int use_import_list\tPROTO((const char *));\n+static int ignore_library\tPROTO((const char *));\n #endif\n+static char *extract_string\tPROTO((const char **));\n \f\n #ifdef NO_DUP2\n int\n@@ -325,26 +322,6 @@ dup2 (oldfd, newfd)\n }\n #endif\n \n-static char *\n-my_strerror (e)\n-     int e;\n-{\n-\n-#ifdef HAVE_STRERROR\n-  return strerror (e);\n-\n-#else\n-\n-  if (!e)\n-    return \"\";\n-\n-  if (e > 0 && e < sys_nerr)\n-    return sys_errlist[e];\n-\n-  return \"errno = ?\";\n-#endif\n-}\n-\n static const char *\n my_strsignal (s)\n      int s;\n@@ -403,17 +380,17 @@ collect_exit (status)\n \f\n /* Notify user of a non-error.  */\n void\n-notice VPROTO((char *msgid, ...))\n+notice VPROTO((const char *msgid, ...))\n {\n #ifndef ANSI_PROTOTYPES\n-  char *msgid;\n+  const char *msgid;\n #endif\n   va_list ap;\n \n   VA_START (ap, msgid);\n \n #ifndef ANSI_PROTOTYPES\n-  msgid = va_arg (ap, char *);\n+  msgid = va_arg (ap, const char *);\n #endif\n \n   vfprintf (stderr, _(msgid), ap);\n@@ -439,7 +416,7 @@ fatal_perror VPROTO((const char * msgid, ...))\n \n   fprintf (stderr, \"collect2: \");\n   vfprintf (stderr, _(msgid), ap);\n-  fprintf (stderr, \": %s\\n\", my_strerror (e));\n+  fprintf (stderr, \": %s\\n\", xstrerror (e));\n   va_end (ap);\n \n   collect_exit (FATAL_EXIT_CODE);\n@@ -526,67 +503,20 @@ handler (signo)\n }\n \n \f\n-PTR\n-xcalloc (size1, size2)\n-  size_t size1, size2;\n-{\n-  PTR ptr = (PTR) calloc (size1, size2);\n-  if (!ptr)\n-    fatal (\"out of memory\");\n-  return ptr;\n-}\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  PTR ptr = (PTR) malloc (size);\n-  if (!ptr)\n-    fatal (\"out of memory\");\n-  return ptr;\n-}\n-\n-PTR\n-xrealloc (old, size)\n-  PTR old;\n-  size_t size;\n-{\n-  register PTR ptr;\n-  if (old)\n-    ptr = (PTR) realloc (old, size);\n-  else\n-    ptr = (PTR) malloc (size);\n-  if (ptr == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return ptr;\n-}\n-\n int\n file_exists (name)\n-     char *name;\n+     const char *name;\n {\n   return access (name, R_OK) == 0;\n }\n \n-/* Make a copy of a string INPUT with size SIZE.  */\n-\n-char *\n-xstrdup (input)\n-  const char *input;\n-{\n-  register size_t len = strlen (input) + 1;\n-  register char *output = xmalloc (len);\n-  memcpy (output, input, len);\n-  return output;\n-}\n-\n /* Parse a reasonable subset of shell quoting syntax.  */\n \n static char *\n extract_string (pp)\n-     char **pp;\n+     const char **pp;\n {\n-  char *p = *pp;\n+  const char *p = *pp;\n   int backquote = 0;\n   int inside = 0;\n \n@@ -615,7 +545,7 @@ extract_string (pp)\n \f\n void\n dump_file (name)\n-     char *name;\n+     const char *name;\n {\n   FILE *stream = fopen (name, \"r\");\n   int no_demangle = !! getenv (\"COLLECT_NO_DEMANGLE\");\n@@ -630,7 +560,8 @@ dump_file (name)\n \tobstack_1grow (&temporary_obstack, c);\n       if (obstack_object_size (&temporary_obstack) > 0)\n \t{\n-\t  char *word, *p, *result;\n+\t  const char *word, *p;\n+\t  char *result;\n \t  obstack_1grow (&temporary_obstack, '\\0');\n \t  word = obstack_finish (&temporary_obstack);\n \n@@ -676,13 +607,13 @@ dump_file (name)\n \n static int\n is_ctor_dtor (s)\n-     char *s;\n+     const char *s;\n {\n-  struct names { char *name; int len; int ret; int two_underscores; };\n+  struct names { const char *name; int len; int ret; int two_underscores; };\n \n   register struct names *p;\n   register int ch;\n-  register char *orig_s = s;\n+  register const char *orig_s = s;\n \n   static struct names special[] = {\n #ifdef NO_DOLLAR_IN_LABEL\n@@ -731,54 +662,6 @@ is_ctor_dtor (s)\n   return 0;\n }\n \f\n-/* Routine to add variables to the environment.  */\n-\n-#ifndef HAVE_PUTENV\n-\n-int\n-putenv (str)\n-     char *str;\n-{\n-#ifndef VMS\t\t\t/* nor about VMS */\n-\n-  extern char **environ;\n-  char **old_environ = environ;\n-  char **envp;\n-  int num_envs = 0;\n-  int name_len = 1;\n-  char *p = str;\n-  int ch;\n-\n-  while ((ch = *p++) != '\\0' && ch != '=')\n-    name_len++;\n-\n-  if (!ch)\n-    abort ();\n-\n-  /* Search for replacing an existing environment variable, and\n-     count the number of total environment variables.  */\n-  for (envp = old_environ; *envp; envp++)\n-    {\n-      num_envs++;\n-      if (!strncmp (str, *envp, name_len))\n-\t{\n-\t  *envp = str;\n-\t  return 0;\n-\t}\n-    }\n-\n-  /* Add a new environment variable */\n-  environ = (char **) xmalloc (sizeof (char *) * (num_envs+2));\n-  *environ = str;\n-  bcopy ((char *) old_environ, (char *) (environ + 1),\n-\t sizeof (char *) * (num_envs+1));\n-\n-  return 0;\n-#endif\t/* VMS */\n-}\n-\n-#endif\t/* HAVE_PUTENV */\n-\f\n /* By default, colon separates directories in a path.  */\n #ifndef PATH_SEPARATOR\n #define PATH_SEPARATOR ':'\n@@ -793,7 +676,7 @@ static struct path_prefix cpath, path;\n /* This is the name of the target machine.  We use it to form the name\n    of the files to execute.  */\n \n-static char *target_machine = TARGET_MACHINE;\n+static const char *const target_machine = TARGET_MACHINE;\n #endif\n \n /* Search for NAME using prefix list PPREFIX.  We only look for executable\n@@ -804,7 +687,7 @@ static char *target_machine = TARGET_MACHINE;\n static char *\n find_a_file (pprefix, name)\n      struct path_prefix *pprefix;\n-     char *name;\n+     const char *name;\n {\n   char *temp;\n   struct prefix_list *pl;\n@@ -887,7 +770,7 @@ find_a_file (pprefix, name)\n static void\n add_prefix (pprefix, prefix)\n      struct path_prefix *pprefix;\n-     char *prefix;\n+     const char *prefix;\n {\n   struct prefix_list *pl, **prev;\n   int len;\n@@ -922,10 +805,10 @@ add_prefix (pprefix, prefix)\n \n static void\n prefix_from_env (env, pprefix)\n-     char *env;\n+     const char *env;\n      struct path_prefix *pprefix;\n {\n-  char *p;\n+  const char *p;\n   GET_ENV_PATH_LIST (p, env);\n \n   if (p)\n@@ -934,10 +817,10 @@ prefix_from_env (env, pprefix)\n \n static void\n prefix_from_string (p, pprefix)\n-     char *p;\n+     const char *p;\n      struct path_prefix *pprefix;\n {\n-  char *startp, *endp;\n+  const char *startp, *endp;\n   char *nstore = (char *) xmalloc (strlen (p) + 3);\n \n   if (debug)\n@@ -976,43 +859,44 @@ prefix_from_string (p, pprefix)\n \f\n /* Main program.  */\n \n+int main \t\tPROTO ((int, char *[]));\n int\n main (argc, argv)\n      int argc;\n      char *argv[];\n {\n-  char *ld_suffix\t= \"ld\";\n-  char *full_ld_suffix\t= ld_suffix;\n-  char *real_ld_suffix\t= \"real-ld\";\n-  char *collect_ld_suffix = \"collect-ld\";\n-  char *nm_suffix\t= \"nm\";\n-  char *full_nm_suffix\t= nm_suffix;\n-  char *gnm_suffix\t= \"gnm\";\n-  char *full_gnm_suffix\t= gnm_suffix;\n+  const char *ld_suffix\t= \"ld\";\n+  const char *full_ld_suffix\t= ld_suffix;\n+  const char *real_ld_suffix\t= \"real-ld\";\n+  const char *collect_ld_suffix = \"collect-ld\";\n+  const char *nm_suffix\t= \"nm\";\n+  const char *full_nm_suffix\t= nm_suffix;\n+  const char *gnm_suffix\t= \"gnm\";\n+  const char *full_gnm_suffix\t= gnm_suffix;\n #ifdef LDD_SUFFIX\n-  char *ldd_suffix\t= LDD_SUFFIX;\n-  char *full_ldd_suffix\t= ldd_suffix;\n-#endif\n-  char *strip_suffix\t= \"strip\";\n-  char *full_strip_suffix = strip_suffix;\n-  char *gstrip_suffix\t= \"gstrip\";\n-  char *full_gstrip_suffix = gstrip_suffix;\n-  char *arg;\n+  const char *ldd_suffix\t= LDD_SUFFIX;\n+  const char *full_ldd_suffix\t= ldd_suffix;\n+#endif\n+  const char *strip_suffix\t= \"strip\";\n+  const char *full_strip_suffix = strip_suffix;\n+  const char *gstrip_suffix\t= \"gstrip\";\n+  const char *full_gstrip_suffix = gstrip_suffix;\n+  const char *arg;\n   FILE *outf;\n #ifdef COLLECT_EXPORT_LIST\n   FILE *exportf;\n   FILE *importf;\n #endif\n-  char *ld_file_name;\n-  char *p;\n+  const char *ld_file_name;\n+  const char *p;\n   char **c_argv;\n-  char **c_ptr;\n+  const char **c_ptr;\n   char **ld1_argv;\n-  char **ld1;\n+  const char **ld1;\n   char **ld2_argv;\n-  char **ld2;\n+  const char **ld2;\n   char **object_lst;\n-  char **object;\n+  const char **object;\n   int first_file;\n   int num_c_args\t= argc+9;\n \n@@ -1030,9 +914,9 @@ main (argc, argv)\n   /* Do not invoke xcalloc before this point, since locale needs to be\n      set first, in case a diagnostic is issued.  */\n \n-  ld1 = ld1_argv = (char **) xcalloc (sizeof (char *), argc+3);\n-  ld2 = ld2_argv = (char **) xcalloc (sizeof (char *), argc+6);\n-  object = object_lst = (char **) xcalloc (sizeof (char *), argc);\n+  ld1 = (const char **)(ld1_argv = (char **) xcalloc(sizeof (char *), argc+3));\n+  ld2 = (const char **)(ld2_argv = (char **) xcalloc(sizeof (char *), argc+6));\n+  object = (const char **)(object_lst = (char **) xcalloc(sizeof (char *), argc));\n \n #ifdef DEBUG\n   debug = 1;\n@@ -1064,14 +948,15 @@ main (argc, argv)\n   p = getenv (\"COLLECT_GCC_OPTIONS\");\n   while (p && *p)\n     {\n-      char *q = extract_string (&p);\n+      const char *q = extract_string (&p);\n       if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))\n \tnum_c_args++;\n     }\n   obstack_free (&temporary_obstack, temporary_firstobj);\n   ++num_c_args;\n \n-  c_ptr = c_argv = (char **) xcalloc (sizeof (char *), num_c_args);\n+  c_ptr = (const char **)\n+    (c_argv = (char **) xcalloc (sizeof (char *), num_c_args));\n \n   if (argc < 2)\n     fatal (\"no arguments\");\n@@ -1107,51 +992,23 @@ main (argc, argv)\n      But it we look for a program in the system directories, we need to\n      qualify the program name with the target machine.  */\n \n-  full_ld_suffix\n-    = xcalloc (strlen (ld_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_ld_suffix, target_machine);\n-  strcat (full_ld_suffix, \"-\");\n-  strcat (full_ld_suffix, ld_suffix);\n+  full_ld_suffix = concat(target_machine, \"-\", ld_suffix, NULL);\n \n #if 0\n-  full_gld_suffix\n-    = xcalloc (strlen (gld_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_gld_suffix, target_machine);\n-  strcat (full_gld_suffix, \"-\");\n-  strcat (full_gld_suffix, gld_suffix);\n+  full_gld_suffix = concat (target_machine, \"-\", gld_suffix, NULL);\n #endif\n \n-  full_nm_suffix\n-    = xcalloc (strlen (nm_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_nm_suffix, target_machine);\n-  strcat (full_nm_suffix, \"-\");\n-  strcat (full_nm_suffix, nm_suffix);\n-\n-  full_gnm_suffix\n-    = xcalloc (strlen (gnm_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_gnm_suffix, target_machine);\n-  strcat (full_gnm_suffix, \"-\");\n-  strcat (full_gnm_suffix, gnm_suffix);\n+  full_nm_suffix = concat (target_machine, \"-\", nm_suffix, NULL);\n \n+  full_gnm_suffix = concat (target_machine, \"-\", gnm_suffix, NULL);\n+  \n #ifdef LDD_SUFFIX\n-  full_ldd_suffix\n-    = xcalloc (strlen (ldd_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_ldd_suffix, target_machine);\n-  strcat (full_ldd_suffix, \"-\");\n-  strcat (full_ldd_suffix, ldd_suffix);\n-#endif\n-\n-  full_strip_suffix\n-    = xcalloc (strlen (strip_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_strip_suffix, target_machine);\n-  strcat (full_strip_suffix, \"-\");\n-  strcat (full_strip_suffix, strip_suffix);\n+  full_ldd_suffix = concat (target_machine, \"-\", ldd_suffix, NULL);\n+#endif\n+\n+  full_strip_suffix = concat (target_machine, \"-\", strip_suffix, NULL);\n   \n-  full_gstrip_suffix\n-    = xcalloc (strlen (gstrip_suffix) + strlen (target_machine) + 2, 1);\n-  strcpy (full_gstrip_suffix, target_machine);\n-  strcat (full_gstrip_suffix, \"-\");\n-  strcat (full_gstrip_suffix, gstrip_suffix);\n+  full_gstrip_suffix = concat (target_machine, \"-\", gstrip_suffix, NULL);\n #endif /* CROSS_COMPILE */\n \n   /* Try to discover a valid linker/nm/strip to use.  */\n@@ -1216,9 +1073,7 @@ main (argc, argv)\n   if (c_file_name == 0)\n     {\n #ifdef CROSS_COMPILE\n-      c_file_name = xcalloc (sizeof (\"gcc-\") + strlen (target_machine) + 1, 1);\n-      strcpy (c_file_name, target_machine);\n-      strcat (c_file_name, \"-gcc\");\n+      c_file_name = concat (target_machine, \"-gcc\", NULL);\n #else\n       c_file_name = \"gcc\";\n #endif\n@@ -1268,7 +1123,7 @@ main (argc, argv)\n   p = getenv (\"COLLECT_GCC_OPTIONS\");\n   while (p && *p)\n     {\n-      char *q = extract_string (&p);\n+      const char *q = extract_string (&p);\n       if (*q == '-' && (q[1] == 'm' || q[1] == 'f'))\n \t*c_ptr++ = obstack_copy0 (&permanent_obstack, q, strlen (q));\n       if (strcmp (q, \"-EL\") == 0 || strcmp (q, \"-EB\") == 0)\n@@ -1330,7 +1185,7 @@ main (argc, argv)\n #ifdef COLLECT_EXPORT_LIST\n \t      {\n \t        /* Resolving full library name.  */\n-\t\tchar *s = resolve_lib_name (arg+2);\n+\t\tconst char *s = resolve_lib_name (arg+2);\n \n \t\t/* If we will use an import list for this library,\n \t\t   we should exclude it from ld args.  */\n@@ -1478,7 +1333,7 @@ main (argc, argv)\n #endif\n \n   *c_ptr++ = c_file;\n-  *object = *c_ptr = *ld1 = (char *) 0;\n+  *c_ptr = *ld1 = *object = (char *) 0;\n \n   if (vflag)\n     {\n@@ -1491,7 +1346,7 @@ main (argc, argv)\n \n   if (debug)\n     {\n-      char *ptr;\n+      const char *ptr;\n       fprintf (stderr, \"ld_file_name        = %s\\n\",\n \t       (ld_file_name ? ld_file_name : \"not found\"));\n       fprintf (stderr, \"c_file_name         = %s\\n\",\n@@ -1593,11 +1448,13 @@ main (argc, argv)\n       /* Strip now if it was requested on the command line.  */\n       if (strip_flag)\n \t{\n-\t  char **strip_argv = (char **) xcalloc (sizeof (char *), 3);\n+\t  char **real_strip_argv = (char **) xcalloc (sizeof (char *), 3);\n+\t  const char ** strip_argv = (const char **) real_strip_argv;\n+\t  \n \t  strip_argv[0] = strip_file_name;\n \t  strip_argv[1] = output_file;\n \t  strip_argv[2] = (char *) 0;\n-\t  fork_execute (\"strip\", strip_argv);\n+\t  fork_execute (\"strip\", real_strip_argv);\n \t}\n \n #ifdef COLLECT_EXPORT_LIST\n@@ -1705,7 +1562,7 @@ main (argc, argv)\n \n int\n collect_wait (prog)\n-     char *prog;\n+     const char *prog;\n {\n   int status;\n \n@@ -1732,7 +1589,7 @@ collect_wait (prog)\n \n static void\n do_wait (prog)\n-     char *prog;\n+     const char *prog;\n {\n   int ret = collect_wait (prog);\n   if (ret != 0)\n@@ -1747,9 +1604,9 @@ do_wait (prog)\n \n void\n collect_execute (prog, argv, redir)\n-     char *prog;\n+     const char *prog;\n      char **argv;\n-     char *redir;\n+     const char *redir;\n {\n   char *errmsg_fmt;\n   char *errmsg_arg;\n@@ -1760,7 +1617,7 @@ collect_execute (prog, argv, redir)\n   if (vflag || debug)\n     {\n       char **p_argv;\n-      char *str;\n+      const char *str;\n \n       if (argv[0])\n \tfprintf (stderr, \"%s\", argv[0]);\n@@ -1821,7 +1678,7 @@ collect_execute (prog, argv, redir)\n \n static void\n fork_execute (prog, argv)\n-     char *prog;\n+     const char *prog;\n      char **argv;\n {\n   collect_execute (prog, argv, NULL);\n@@ -1832,7 +1689,7 @@ fork_execute (prog, argv)\n \n static void\n maybe_unlink (file)\n-     char *file;\n+     const char *file;\n {\n   if (!debug)\n     unlink (file);\n@@ -1848,7 +1705,7 @@ static long sequence_number = 0;\n static void\n add_to_list (head_ptr, name)\n      struct head *head_ptr;\n-     char *name;\n+     const char *name;\n {\n   struct id *newid\n     = (struct id *) xcalloc (sizeof (struct id) + strlen (name), 1);\n@@ -1882,7 +1739,7 @@ add_to_list (head_ptr, name)\n \n static int\n extract_init_priority (name)\n-     char *name;\n+     const char *name;\n {\n   int pos = 0, pri;\n \n@@ -1943,7 +1800,7 @@ sort_ids (head_ptr)\n static void\n write_list (stream, prefix, list)\n      FILE *stream;\n-     char *prefix;\n+     const char *prefix;\n      struct id *list;\n {\n   while (list)\n@@ -1957,7 +1814,7 @@ write_list (stream, prefix, list)\n /* This function is really used only on AIX, but may be useful.  */\n static int\n is_in_list (prefix, list)\n-     char *prefix;\n+     const char *prefix;\n      struct id *list;\n {\n   while (list)\n@@ -1974,7 +1831,7 @@ is_in_list (prefix, list)\n static void\n dump_list (stream, prefix, list)\n      FILE *stream;\n-     char *prefix;\n+     const char *prefix;\n      struct id *list;\n {\n   while (list)\n@@ -1989,7 +1846,7 @@ dump_list (stream, prefix, list)\n static void\n dump_prefix_list (stream, prefix, list)\n      FILE *stream;\n-     char *prefix;\n+     const char *prefix;\n      struct prefix_list *list;\n {\n   while (list)\n@@ -2003,7 +1860,7 @@ dump_prefix_list (stream, prefix, list)\n static void\n write_list_with_asm (stream, prefix, list)\n      FILE *stream;\n-     char *prefix;\n+     const char *prefix;\n      struct id *list;\n {\n   while (list)\n@@ -2020,15 +1877,16 @@ write_list_with_asm (stream, prefix, list)\n static void\n write_c_file_stat (stream, name)\n      FILE *stream;\n-     char *name;\n+     const char *name ATTRIBUTE_UNUSED;\n {\n-  char *prefix, *p, *q;\n+  const char *p, *q;\n+  char *prefix, *r;\n   int frames = (frame_tables.number > 0);\n \n   /* Figure out name of output_file, stripping off .so version.  */\n   p = rindex (output_file, '/');\n   if (p == 0)\n-    p = (char *) output_file;\n+    p = output_file;\n   else\n     p++;\n   q = p;\n@@ -2055,9 +1913,9 @@ write_c_file_stat (stream, name)\n   prefix = xmalloc (q - p + 1);\n   strncpy (prefix, p, q - p);\n   prefix[q - p] = 0;\n-  for (q = prefix; *q; q++)\n-    if (!ISALNUM ((unsigned char)*q))\n-      *q = '_';\n+  for (r = prefix; *r; r++)\n+    if (!ISALNUM ((unsigned char)*r))\n+      *r = '_';\n   if (debug)\n     notice (\"\\nwrite_c_file - output name is %s, prefix is %s\\n\",\n \t    output_file, prefix);\n@@ -2155,7 +2013,7 @@ write_c_file_stat (stream, name)\n static void\n write_c_file_glob (stream, name)\n      FILE *stream;\n-     char *name;\n+     const char *name ATTRIBUTE_UNUSED;\n {\n   /* Write the tables as C code  */\n \n@@ -2220,7 +2078,7 @@ write_c_file_glob (stream, name)\n static void\n write_c_file (stream, name)\n      FILE *stream;\n-     char *name;\n+     const char *name;\n {\n   fprintf (stream, \"#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\");\n #ifndef LD_INIT_SWITCH\n@@ -2259,12 +2117,13 @@ write_aix_file (stream, list)\n \n static void\n scan_prog_file (prog_name, which_pass)\n-     char *prog_name;\n+     const char *prog_name;\n      enum pass which_pass;\n {\n   void (*int_handler) ();\n   void (*quit_handler) ();\n-  char *nm_argv[4];\n+  char *real_nm_argv[4];\n+  const char **nm_argv = (const char **) real_nm_argv;\n   int pid;\n   int argc = 0;\n   int pipe_fd[2];\n@@ -2295,8 +2154,8 @@ scan_prog_file (prog_name, which_pass)\n   /* Trace if needed.  */\n   if (vflag)\n     {\n-      char **p_argv;\n-      char *str;\n+      const char **p_argv;\n+      const char *str;\n \n       for (p_argv = &nm_argv[0]; (str = *p_argv) != (char *) 0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n@@ -2324,7 +2183,7 @@ scan_prog_file (prog_name, which_pass)\n       if (close (pipe_fd[1]) < 0)\n \tfatal_perror (\"close %d\", pipe_fd[1]);\n \n-      execv (nm_file_name, nm_argv);\n+      execv (nm_file_name, real_nm_argv);\n       fatal_perror (\"execvp %s\", nm_file_name);\n     }\n \n@@ -2446,9 +2305,11 @@ struct head libraries;\n \n /* Map the file indicated by NAME into memory and store its address.  */\n \n+static void mapfile\t\t\tPROTO ((const char *));\n+\n static void\n mapfile (name)\n-     char *name;\n+     const char *name;\n {\n   int fp;\n   struct stat s;\n@@ -2460,15 +2321,17 @@ mapfile (name)\n   objsize = s.st_size;\n   object = (unsigned) mmap (0, objsize, PROT_READ|PROT_WRITE, MAP_PRIVATE,\n \t\t\t    fp, 0);\n-  if (object == -1)\n+  if (object == (unsigned)-1)\n     fatal (\"unable to mmap file '%s'\", name);\n \n   close (fp);\n }\n \n /* Helpers for locatelib.  */\n \n-static char *libname;\n+static const char *libname;\n+\n+static int libselect\t\t\tPROTO ((struct direct *));\n \n static int\n libselect (d)\n@@ -2484,6 +2347,7 @@ libselect (d)\n    We must verify that the extension is numeric, because Sun saves the\n    original versions of patched libraries with a .FCS extension.  Files with\n    invalid extensions must go last in the sort, so that they will not be used.  */\n+static int libcompare\t\tPROTO ((struct direct **, struct direct **));\n \n static int\n libcompare (d1, d2)\n@@ -2528,16 +2392,17 @@ libcompare (d1, d2)\n \n /* Given the name NAME of a dynamic dependency, find its pathname and add\n    it to the list of libraries.  */\n+static void locatelib\t\t\tPROTO ((const char *));\n \n static void\n locatelib (name)\n-     char *name;\n+     const char *name;\n {\n-  static char **l;\n+  static const char **l;\n   static int cnt;\n   char buf[MAXPATHLEN];\n   char *p, *q;\n-  char **pp;\n+  const char **pp;\n \n   if (l == 0)\n     {\n@@ -2567,7 +2432,7 @@ locatelib (name)\n \t  q = (char *) xmalloc (strlen (p) + 1);\n \t  strcpy (q, p);\n \t}\n-      l = (char **) xmalloc ((cnt + 3) * sizeof (char *));\n+      l = (const char **) xmalloc ((cnt + 3) * sizeof (char *));\n       pp = l;\n       if (ldr)\n \t{\n@@ -2623,7 +2488,7 @@ locatelib (name)\n \n static void \n scan_libraries (prog_name)\n-     char *prog_name;\n+     const char *prog_name;\n {\n   struct exec *header;\n   char *base;\n@@ -2698,13 +2563,14 @@ scan_libraries (prog_name)\n \n static void \n scan_libraries (prog_name)\n-     char *prog_name;\n+     const char *prog_name;\n {\n   static struct head libraries;\t\t/* list of shared libraries found */\n   struct id *list;\n   void (*int_handler) ();\n   void (*quit_handler) ();\n   char *ldd_argv[4];\n+  const char **ldd_argv = (const char **) real_ldd_argv;\n   int pid;\n   int argc = 0;\n   int pipe_fd[2];\n@@ -2732,8 +2598,8 @@ scan_libraries (prog_name)\n   /* Trace if needed.  */\n   if (vflag)\n     {\n-      char **p_argv;\n-      char *str;\n+      const char **p_argv;\n+      const char *str;\n \n       for (p_argv = &ldd_argv[0]; (str = *p_argv) != (char *) 0; p_argv++)\n \tfprintf (stderr, \" %s\", str);\n@@ -2761,7 +2627,7 @@ scan_libraries (prog_name)\n       if (close (pipe_fd[1]) < 0)\n \tfatal_perror (\"close %d\", pipe_fd[1]);\n \n-      execv (ldd_file_name, ldd_argv);\n+      execv (ldd_file_name, real_ldd_argv);\n       fatal_perror (\"execv %s\", ldd_file_name);\n     }\n \n@@ -2876,7 +2742,7 @@ extern char *ldgetname ();\n \n static void\n scan_prog_file (prog_name, which_pass)\n-     char *prog_name;\n+     const char *prog_name;\n      enum pass which_pass;\n {\n   LDFILE *ldptr = NULL;\n@@ -2901,7 +2767,11 @@ scan_prog_file (prog_name, which_pass)\n   do\n     {\n #endif\n-      if ((ldptr = ldopen (prog_name, ldptr)) != NULL)\n+      /* Some platforms (e.g. OSF4) declare ldopen as taking a\n+         non-const char * filename parameter, even though it will not\n+         modify that string.  So we must cast away const-ness here,\n+         which will cause -Wcast-qual to burp.  */\n+      if ((ldptr = ldopen ((char *)prog_name, ldptr)) != NULL)\n \t{\n \t  if (! MY_ISCOFF (HEADER (ldptr).f_magic))\n \t    fatal (\"%s: not a COFF file\", prog_name);\n@@ -3070,7 +2940,7 @@ scan_prog_file (prog_name, which_pass)\n    generate import list for an object or to use it directly.  */\n static int\n use_import_list (prog_name)\n-     char *prog_name;\n+     const char *prog_name;\n {\n   char *p;\n \n@@ -3088,7 +2958,7 @@ use_import_list (prog_name)\n    returns a full library name including a path.  */\n static char *\n resolve_lib_name (name)\n-     char *name;\n+     const char *name;\n {\n   char *lib_buf;\n   int i, j, l = 0;\n@@ -3109,7 +2979,7 @@ resolve_lib_name (name)\n               /* The following lines are needed because path_prefix list\n                  may contain directories both with trailing '/' and\n                  without it.  */\n-              char *p = \"\";\n+              const char *p = \"\";\n               if (list->prefix[strlen(list->prefix)-1] != '/')\n                 p = \"/\";\n        \t      sprintf (lib_buf, \"%s%slib%s.%s\",\n@@ -3132,7 +3002,7 @@ if (debug) fprintf (stderr, \"found: %s\\n\", lib_buf);\n \n /* Array of standard AIX libraries which should not\n    be scanned for ctors/dtors.  */\n-static char* aix_std_libs[] = {\n+static const char *aix_std_libs[] = {\n   \"/unix\",\n   \"/lib/libc.a\",\n   \"/lib/libc_r.a\",\n@@ -3148,9 +3018,9 @@ static char* aix_std_libs[] = {\n    if this name matches the location of a standard AIX library. */\n static int\n ignore_library (name)\n-     char *name;\n+     const char *name;\n {\n-  char **p = &aix_std_libs[0];\n+  const char **p = &aix_std_libs[0];\n   while (*p++ != NULL)\n     if (! strcmp (name, *p)) return 1;\n   return 0;\n@@ -3213,7 +3083,7 @@ static void add_func_table\tPROTO((mo_header_t *, load_all_t *,\n static void print_header\tPROTO((mo_header_t *));\n static void print_load_command\tPROTO((load_union_t *, size_t, int));\n static void bad_header\t\tPROTO((int));\n-static struct file_info\t*read_file  PROTO((char *, int, int));\n+static struct file_info\t*read_file  PROTO((const char *, int, int));\n static void end_file\t\tPROTO((struct file_info *));\n \f\n /* OSF/rose specific version to scan the name list of the loaded\n@@ -3228,7 +3098,7 @@ static void end_file\t\tPROTO((struct file_info *));\n \n static void\n scan_prog_file (prog_name, which_pass)\n-     char *prog_name;\n+     const char *prog_name;\n      enum pass which_pass;\n {\n   char *obj;\n@@ -3337,7 +3207,7 @@ scan_prog_file (prog_name, which_pass)\n \n \t  if (debug)\n \t    {\n-\t      char *kind = \"unknown\";\n+\t      const char *kind = \"unknown\";\n \n \t      switch (load_hdr->sym.symc_kind)\n \t\t{\n@@ -3628,7 +3498,7 @@ print_load_command (load_hdr, offset, number)\n      int number;\n {\n   mo_long_t type = load_hdr->hdr.ldci_cmd_type;\n-  char *type_str = (char *) 0;\n+  const char *type_str = (char *) 0;\n \n   switch (type)\n     {\n@@ -3661,7 +3531,7 @@ print_load_command (load_hdr, offset, number)\n \n   else\n     {\n-      char *region = \"\";\n+      const char *region = \"\";\n       switch (load_hdr->region.regc_usage_type)\n \t{\n \tcase REG_TEXT_T:\tregion = \", .text\";\tbreak;\n@@ -3710,7 +3580,7 @@ bad_header (status)\n \n static struct file_info *\n read_file (name, fd, rw)\n-     char *name;\t\t/* filename */\n+     const char *name;\t\t/* filename */\n      int fd;\t\t\t/* file descriptor */\n      int rw;\t\t\t/* read/write */\n {"}, {"sha": "87c06f59ea662f933263c7fb8156494c017a8b97", "filename": "gcc/collect2.h", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Fcollect2.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Fcollect2.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.h?ref=d4058195bd21860bf183e07a8ac033d09ded8e69", "patch": "@@ -23,14 +23,29 @@ Boston, MA 02111-1307, USA.  */\n \n extern void do_tlink PARAMS ((char **, char **));\n \n-extern void collect_execute PARAMS ((char *, char **, char *));\n+extern void collect_execute PARAMS ((const char *, char **, const char *));\n \n extern void collect_exit PARAMS ((int)) ATTRIBUTE_NORETURN;\n \n-extern int collect_wait PARAMS ((char *));\n+extern int collect_wait PARAMS ((const char *));\n \n-extern void dump_file PARAMS ((char *));\n+extern void dump_file PARAMS ((const char *));\n \n-extern int file_exists PARAMS ((char *));\n+extern int file_exists PARAMS ((const char *));\n+\n+extern const char *ldout;\n+extern const char *c_file_name;\n+extern struct obstack temporary_obstack;\n+extern struct obstack permanent_obstack;\n+extern char *temporary_firstobj;\n+extern int vflag, debug;\n+\n+extern void fancy_abort PARAMS ((void)) ATTRIBUTE_NORETURN;\n+extern void error PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+extern void notice PARAMS ((const char *, ...)) ATTRIBUTE_PRINTF_1;\n+extern void fatal PARAMS ((const char *, ...)) \n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+extern void fatal_perror PARAMS ((const char *, ...))\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n #endif /* ! __COLLECT2_H__ */"}, {"sha": "a3df317389f1896b40c2488c19922b2c02b29f36", "filename": "gcc/tlink.c", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4058195bd21860bf183e07a8ac033d09ded8e69/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=d4058195bd21860bf183e07a8ac033d09ded8e69", "patch": "@@ -25,7 +25,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"hash.h\"\n #include \"demangle.h\"\n-#include \"toplev.h\"\n #include \"collect2.h\"\n \n #define MAX_ITERATIONS 17\n@@ -34,14 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n \n-/* Defined in collect2.c.  */\n-extern int vflag, debug;\n-extern char *ldout;\n-extern char *c_file_name;\n-extern struct obstack temporary_obstack;\n-extern struct obstack permanent_obstack;\n-extern char * temporary_firstobj;\n-\n /* Defined in the automatically-generated underscore.c.  */\n extern int prepends_underscore;\n \n@@ -95,8 +86,8 @@ static symbol * symbol_pop PARAMS ((void));\n static void file_push PARAMS ((file *));\n static file * file_pop PARAMS ((void));\n static void tlink_init PARAMS ((void));\n-static int tlink_execute PARAMS ((char *, char **, char *));\n-static char * frob_extension PARAMS ((char *, const char *));\n+static int tlink_execute PARAMS ((const char *, char **, const char *));\n+static char * frob_extension PARAMS ((const char *, const char *));\n static char * obstack_fgets PARAMS ((FILE *, struct obstack *));\n static char * tfgets PARAMS ((FILE *));\n static char * pfgets PARAMS ((FILE *));\n@@ -115,7 +106,7 @@ static struct hash_entry *\n symbol_hash_newfunc (entry, table, string)\n      struct hash_entry *entry;\n      struct hash_table *table;\n-     hash_table_key string;\n+     hash_table_key string ATTRIBUTE_UNUSED;\n {\n   struct symbol_hash_entry *ret = (struct symbol_hash_entry *) entry;\n   if (ret == NULL)\n@@ -140,7 +131,7 @@ symbol_hash_lookup (string, create)\n      boolean create;\n {\n   return ((struct symbol_hash_entry *)\n-\t  hash_lookup (&symbol_table, (hash_table_key) string, \n+\t  hash_lookup (&symbol_table, (const hash_table_key) string, \n \t\t       create, string_copy));\n }\n \n@@ -153,7 +144,7 @@ static struct hash_entry *\n file_hash_newfunc (entry, table, string)\n      struct hash_entry *entry;\n      struct hash_table *table;\n-     hash_table_key string;\n+     hash_table_key string ATTRIBUTE_UNUSED;\n {\n    struct file_hash_entry *ret = (struct file_hash_entry *) entry;\n   if (ret == NULL)\n@@ -177,7 +168,7 @@ file_hash_lookup (string)\n      const char *string;\n {\n   return ((struct file_hash_entry *)\n-\t  hash_lookup (&file_table, (hash_table_key) string, true, \n+\t  hash_lookup (&file_table, (const hash_table_key) string, true, \n \t\t       string_copy));\n }\n \n@@ -190,7 +181,7 @@ static struct hash_entry *\n demangled_hash_newfunc (entry, table, string)\n      struct hash_entry *entry;\n      struct hash_table *table;\n-     hash_table_key string;\n+     hash_table_key string ATTRIBUTE_UNUSED;\n {\n   struct demangled_hash_entry *ret = (struct demangled_hash_entry *) entry;\n   if (ret == NULL)\n@@ -212,7 +203,7 @@ demangled_hash_lookup (string, create)\n      boolean create;\n {\n   return ((struct demangled_hash_entry *)\n-\t  hash_lookup (&demangled_table, (hash_table_key) string, \n+\t  hash_lookup (&demangled_table, (const hash_table_key) string, \n \t\t       create, string_copy));\n }\n \f\n@@ -296,7 +287,7 @@ file_pop ()\n static void\n tlink_init ()\n {\n-  char *p;\n+  const char *p;\n \n   hash_table_init (&symbol_table, symbol_hash_newfunc, string_hash,\n \t\t   string_compare);\n@@ -322,20 +313,20 @@ tlink_init ()\n \n static int\n tlink_execute (prog, argv, redir)\n-     char *prog;\n+     const char *prog;\n      char **argv;\n-     char *redir;\n+     const char *redir;\n {\n   collect_execute (prog, argv, redir);\n   return collect_wait (prog);\n } \n \n static char *\n frob_extension (s, ext)\n-     char *s;\n+     const char *s;\n      const char *ext;\n {\n-  char *p = rindex (s, '/');\n+  const char *p = rindex (s, '/');\n   if (! p)\n     p = s;\n   p = rindex (p, '.');\n@@ -391,7 +382,7 @@ freadsym (stream, f, chosen)\n   symbol *sym;\n \n   {\n-    char *name = tfgets (stream);\n+    const char *name = tfgets (stream);\n     sym = symbol_hash_lookup (name, true);\n   }\n \n@@ -507,7 +498,7 @@ recompile_files ()\n     {\n       char *line, *command;\n       FILE *stream = fopen ((char*) f->root.key, \"r\");\n-      char *outname = frob_extension ((char*) f->root.key, \".rnw\");\n+      const char *outname = frob_extension ((char*) f->root.key, \".rnw\");\n       FILE *output = fopen (outname, \"w\");\n \n       while ((line = tfgets (stream)) != NULL)\n@@ -559,7 +550,7 @@ read_repo_files (object_lst)\n \n   for (; *object; object++)\n     {\n-      char *p = frob_extension (*object, \".rpo\");\n+      const char *p = frob_extension (*object, \".rpo\");\n       file *f;\n \n       if (! file_exists (p))\n@@ -586,7 +577,7 @@ demangle_new_symbols ()\n   while ((sym = symbol_pop ()) != NULL)\n     {\n       demangled *dem;\n-      char *p = cplus_demangle ((char*) sym->root.key, \n+      const char *p = cplus_demangle ((char*) sym->root.key, \n \t\t\t\tDMGL_PARAMS | DMGL_ANSI);\n \n       if (! p)\n@@ -635,7 +626,7 @@ scan_linker_output (fname)\n       if (! sym && ! end)\n \t/* Try a mangled name in quotes.  */\n \t{\n-\t  char *oldq = q+1;\n+\t  const char *oldq = q+1;\n \t  demangled *dem = 0;\n \t  q = 0;\n \n@@ -694,7 +685,7 @@ scan_linker_output (fname)\n \n void\n do_tlink (ld_argv, object_lst)\n-     char **ld_argv, **object_lst;\n+     char **ld_argv, **object_lst ATTRIBUTE_UNUSED;\n {\n   int exit = tlink_execute (\"ld\", ld_argv, ldout);\n "}]}