{"sha": "6a11476684547180634a11896c3b91a9970ea133", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmExMTQ3NjY4NDU0NzE4MDYzNGExMTg5NmMzYjkxYTk5NzBlYTEzMw==", "commit": {"author": {"name": "Jan Sjodin", "email": "jan.sjodin@amd.com", "date": "2009-01-07T15:53:03Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-01-07T15:53:03Z"}, "message": "re PR middle-end/38492 ([graphite] segfaulting code when compiled with -fgraphite -fgraphite-identity)\n\n2009-01-07  Jan Sjodin  <jan.sjodin@amd.com>\n\n\tPR tree-optimization/38492\n\tPR tree-optimization/38498\n\t* tree-check.c (operator_is_linear, scev_is_linear_expression): New.\n\t* tree-chrec.h (scev_is_linear_expression): Declared.\n\t* graphite.c (graphite_cannot_represent_loop_niter): New.\n\t(scopdet_basic_block_info): Call graphite_cannot_represent_loop_niter.\n\t(graphite_loop_normal_form): Use gcc_assert.\n\t(scan_tree_for_params): Use CASE_CONVERT.\n\t(phi_node_is_iv, bb_contains_non_iv_scalar_phi_nodes): New.\n\t(build_scop_conditions_1): Call bb_contains_non_iv_scalar_phi_nodes.\n\tUse gcc_assert.  Discard scops that contain unhandled cases.\n\t(build_scop_conditions): Return a boolean status for unhandled cases.\n\t(strip_mine_profitable_p): Print the loop number, not its depth.\n\t(is_interchange_valid): Pass the depth of the loop nest, don't\n\trecompute it wrongly.\n\t(graphite_trans_bb_block): Same.\n\t(graphite_trans_bb_block): Print tentative of loop blocking.\n\t(graphite_trans_scop_block): Do not print that the loop has been\n\tblocked.\n\t(graphite_transform_loops): Do not handle scops that contain condition\n\tscalar phi nodes.\n\n\t* testsuite/gcc.dg/graphite/pr38500.c: Fixed warning as committed\n\tin trunk.\n\t* testsuite/gcc.dg/graphite/block-0.c: Update test.\n\t* testsuite/gcc.dg/graphite/block-1.c: Same.\n\t* testsuite/gcc.dg/graphite/block-2.c: Remove xfail and test for blocking.\n\t* testsuite/gcc.dg/graphite/block-4.c: Remove test for strip mine.\n\t* testsuite/gcc.dg/graphite/block-3.c: New.\n\t* testsuite/gcc.dg/graphite/pr38498.c: New.\n\nFrom-SVN: r143159", "tree": {"sha": "429c78cd924118d3099784ae768f27d331682928", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/429c78cd924118d3099784ae768f27d331682928"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a11476684547180634a11896c3b91a9970ea133", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a11476684547180634a11896c3b91a9970ea133", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a11476684547180634a11896c3b91a9970ea133", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a11476684547180634a11896c3b91a9970ea133/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65b82caa2b4417c19b28e533298dbf61d4ba230b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65b82caa2b4417c19b28e533298dbf61d4ba230b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65b82caa2b4417c19b28e533298dbf61d4ba230b"}], "stats": {"total": 339, "additions": 280, "deletions": 59}, "files": [{"sha": "b379b1ba7098557decb8574639781795185a26f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -1,3 +1,27 @@\n+2009-01-07  Jan Sjodin  <jan.sjodin@amd.com>\n+\n+\tPR tree-optimization/38492\n+\tPR tree-optimization/38498\n+\t* tree-check.c (operator_is_linear, scev_is_linear_expression): New.\n+\t* tree-chrec.h (scev_is_linear_expression): Declared.\n+\t* graphite.c (graphite_cannot_represent_loop_niter): New.\n+\t(scopdet_basic_block_info): Call graphite_cannot_represent_loop_niter.\n+\t(graphite_loop_normal_form): Use gcc_assert.\n+\t(scan_tree_for_params): Use CASE_CONVERT.\n+\t(phi_node_is_iv, bb_contains_non_iv_scalar_phi_nodes): New.\n+\t(build_scop_conditions_1): Call bb_contains_non_iv_scalar_phi_nodes.\n+\tUse gcc_assert.  Discard scops that contain unhandled cases.\n+\t(build_scop_conditions): Return a boolean status for unhandled cases.\n+\t(strip_mine_profitable_p): Print the loop number, not its depth.\n+\t(is_interchange_valid): Pass the depth of the loop nest, don't\n+\trecompute it wrongly.\n+\t(graphite_trans_bb_block): Same.\n+\t(graphite_trans_bb_block): Print tentative of loop blocking.\n+\t(graphite_trans_scop_block): Do not print that the loop has been\n+\tblocked.\n+\t(graphite_transform_loops): Do not handle scops that contain condition\n+\tscalar phi nodes.\n+\n 2009-01-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tAVX Programming Reference (December, 2008)"}, {"sha": "645def2b8a7c57464b1cdc86a4f7da6c0b4937b0", "filename": "gcc/graphite.c", "status": "modified", "additions": 135, "deletions": 53, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Fgraphite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Fgraphite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -1579,6 +1579,17 @@ move_sd_regions (VEC (sd_region, heap) **source, VEC (sd_region, heap) **target)\n   VEC_free (sd_region, heap, *source);\n }\n \n+/* Return true when it is not possible to represent the upper bound of\n+   LOOP in the polyhedral representation.  */\n+\n+static bool\n+graphite_cannot_represent_loop_niter (loop_p loop)\n+{\n+  tree niter = number_of_latch_executions (loop);\n+\n+  return chrec_contains_undetermined (niter)\n+    || !scev_is_linear_expression (niter);\n+}\n /* Store information needed by scopdet_* functions.  */\n \n struct scopdet_info\n@@ -1650,8 +1661,7 @@ scopdet_basic_block_info (basic_block bb, VEC (sd_region, heap) **scops,\n \tif (result.last->loop_father != loop)\n \t  result.next = NULL;\n \n-        if (TREE_CODE (number_of_latch_executions (loop))\n-            == SCEV_NOT_KNOWN)\n+        if (graphite_cannot_represent_loop_niter (loop))\n           result.difficult = true;\n \n         if (sinfo.difficult)\n@@ -2350,9 +2360,7 @@ graphite_loop_normal_form (loop_p loop)\n   gimple_seq stmts;\n   edge exit = single_dom_exit (loop);\n \n-  if (!number_of_iterations_exit (loop, exit, &niter, false))\n-    gcc_unreachable ();\n-\n+  gcc_assert (number_of_iterations_exit (loop, exit, &niter, false));\n   nit = force_gimple_operand (unshare_expr (niter.niter), &stmts, true,\n \t\t\t      NULL_TREE);\n   if (stmts)\n@@ -2732,8 +2740,7 @@ scan_tree_for_params (scop_p s, tree e, CloogMatrix *c, int r, Value k,\n \t}\n       break;\n \n-    case NOP_EXPR:\n-    case CONVERT_EXPR:\n+    CASE_CONVERT:\n     case NON_LVALUE_EXPR:\n       scan_tree_for_params (s, TREE_OPERAND (e, 0), c, r, k, subtract);\n       break;\n@@ -3278,13 +3285,63 @@ add_conditions_to_domain (graphite_bb_p gb)\n     }\n }\n \n-/* Helper recursive function.  */\n+/* Returns true when PHI defines an induction variable in the loop\n+   containing the PHI node.  */\n \n-static void\n+static bool\n+phi_node_is_iv (gimple phi)\n+{\n+  loop_p loop = gimple_bb (phi)->loop_father;\n+  tree scev = analyze_scalar_evolution (loop, gimple_phi_result (phi));\n+\n+  return tree_contains_chrecs (scev, NULL);\n+}\n+\n+/* Returns true when BB contains scalar phi nodes that are not an\n+   induction variable of a loop.  */\n+\n+static bool\n+bb_contains_non_iv_scalar_phi_nodes (basic_block bb)\n+{\n+  gimple phi = NULL;\n+  gimple_stmt_iterator si;\n+\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+    if (is_gimple_reg (gimple_phi_result (gsi_stmt (si))))\n+      {\n+\t/* Store the unique scalar PHI node: at this point, loops\n+\t   should be in cannonical form, so we expect to see at most\n+\t   one scalar phi node in the loop header.  */\n+\tif (phi\n+\t    || bb != bb->loop_father->header)\n+\t  return true;\n+\n+\tphi = gsi_stmt (si);\n+      }\n+\n+  if (!phi\n+      || phi_node_is_iv (phi))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Helper recursive function.  Record in CONDITIONS and CASES all\n+   conditions from 'if's and 'switch'es occurring in BB from SCOP.\n+\n+   Returns false when the conditions contain scalar computations that\n+   depend on the condition, i.e. when there are scalar phi nodes on\n+   the junction after the condition.  Only the computations occurring\n+   on memory can be handled in the polyhedral model: operations that\n+   define scalar evolutions in conditions, that can potentially be\n+   used to index memory, can't be handled by the polyhedral model.  */\n+\n+static bool\n build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n \t\t\t VEC (gimple, heap) **cases, basic_block bb,\n \t\t\t scop_p scop)\n {\n+  bool res = true;\n   int i, j;\n   graphite_bb_p gbb;\n   gimple_stmt_iterator gsi;\n@@ -3293,9 +3350,11 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n   \n   /* Make sure we are in the SCoP.  */\n   if (!bb_in_scop_p (bb, scop))\n-    return;\n+    return true;\n+\n+  if (bb_contains_non_iv_scalar_phi_nodes (bb))\n+    return false;\n \n-  /* Record conditions in graphite_bb.  */\n   gbb = gbb_from_bb (bb);\n   if (gbb)\n     {\n@@ -3331,13 +3390,18 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n \t\t/* Recursively scan the then or else part.  */\n \t\tif (e->flags & EDGE_TRUE_VALUE)\n \t\t  VEC_safe_push (gimple, heap, *cases, stmt);\n-\t\telse if (e->flags & EDGE_FALSE_VALUE)\n-\t\t  VEC_safe_push (gimple, heap, *cases, NULL);\n-\t\telse\n-\t\t  gcc_unreachable ();\n+\t\telse \n+\t\t  {\n+\t\t    gcc_assert (e->flags & EDGE_FALSE_VALUE);\n+\t\t    VEC_safe_push (gimple, heap, *cases, NULL);\n+\t\t  }\n \n \t\tVEC_safe_push (gimple, heap, *conditions, stmt);\n-\t\tbuild_scop_conditions_1 (conditions, cases, e->dest, scop);\n+\t\tif (!build_scop_conditions_1 (conditions, cases, e->dest, scop))\n+\t\t  {\n+\t\t    res = false;\n+\t\t    goto done;\n+\t\t  }\n \t\tVEC_pop (gimple, *conditions);\n \t\tVEC_pop (gimple, *cases);\n \t      }\n@@ -3358,81 +3422,99 @@ build_scop_conditions_1 (VEC (gimple, heap) **conditions,\n \t\tbb_child = label_to_block\n \t\t  (CASE_LABEL (gimple_switch_label (stmt, i)));\n \n-\t\t/* Do not handle multiple values for the same block.  */\n \t\tfor (k = 0; k < n; k++)\n \t\t  if (i != k\n \t\t      && label_to_block \n \t\t      (CASE_LABEL (gimple_switch_label (stmt, k))) == bb_child)\n \t\t    break;\n \n-\t\tif (k != n)\n-\t\t  continue;\n-\n-\t\t/* Switch cases with more than one predecessor are not\n-\t\t   handled.  */\n-\t\tif (VEC_length (edge, bb_child->preds) != 1)\n-\t\t  continue;\n+\t\t/* Switches with multiple case values for the same\n+\t\t   block are not handled.  */\n+\t\tif (k != n\n+\t\t    /* Switch cases with more than one predecessor are\n+\t\t       not handled.  */\n+\t\t    || VEC_length (edge, bb_child->preds) != 1)\n+\t\t  {\n+\t\t    res = false;\n+\t\t    goto done;\n+\t\t  }\n \n \t\t/* Recursively scan the corresponding 'case' block.  */\n-\n \t\tfor (gsi_search_gimple_label = gsi_start_bb (bb_child);\n \t\t     !gsi_end_p (gsi_search_gimple_label);\n \t\t     gsi_next (&gsi_search_gimple_label))\n \t\t  {\n-\t\t    gimple stmt_gimple_label \n-\t\t      = gsi_stmt (gsi_search_gimple_label);\n+\t\t    gimple label = gsi_stmt (gsi_search_gimple_label);\n \n-\t\t    if (gimple_code (stmt_gimple_label) == GIMPLE_LABEL)\n+\t\t    if (gimple_code (label) == GIMPLE_LABEL)\n \t\t      {\n-\t\t\ttree t = gimple_label_label (stmt_gimple_label);\n+\t\t\ttree t = gimple_label_label (label);\n \n-\t\t\tif (t == gimple_switch_label (stmt, i))\n-\t\t\t  VEC_replace (gimple, *cases, n_cases,\n-\t\t\t\t       stmt_gimple_label);\n-\t\t\telse\n-\t\t\t  gcc_unreachable ();\n+\t\t\tgcc_assert (t == gimple_switch_label (stmt, i));\n+\t\t\tVEC_replace (gimple, *cases, n_cases, label);\n+\t\t\tbreak;\n \t\t      }\n \t\t  }\n \n-\t\tbuild_scop_conditions_1 (conditions, cases, bb_child, scop);\n+\t\tif (!build_scop_conditions_1 (conditions, cases, bb_child, scop))\n+\t\t  {\n+\t\t    res = false;\n+\t\t    goto done;\n+\t\t  }\n \n \t\t/* Remove the scanned block from the dominator successors.  */\n \t\tfor (j = 0; VEC_iterate (basic_block, dom, j, bb_iter); j++)\n \t\t  if (bb_iter == bb_child)\n \t\t    {\n \t\t      VEC_unordered_remove (basic_block, dom, j);\n \t\t      break;\n-\t\t    }  \n+\t\t    }\n \t      }\n \n \t    VEC_pop (gimple, *conditions);\n \t    VEC_pop (gimple, *cases);\n \t    break;\n \t  }\n+\n \tdefault:\n \t  break;\n       }\n   }\n \n   /* Scan all immediate dominated successors.  */\n   for (i = 0; VEC_iterate (basic_block, dom, i, bb_child); i++)\n-    build_scop_conditions_1 (conditions, cases, bb_child, scop);\n+    if (!build_scop_conditions_1 (conditions, cases, bb_child, scop))\n+      {\n+\tres = false;\n+\tgoto done;\n+      }\n \n+ done:\n   VEC_free (basic_block, heap, dom);\n+  return res;\n }\n \n-/* Record all 'if' and 'switch' conditions in each gbb of SCOP.  */\n+/* Record all conditions from SCOP.\n \n-static void\n+   Returns false when the conditions contain scalar computations that\n+   depend on the condition, i.e. when there are scalar phi nodes on\n+   the junction after the condition.  Only the computations occurring\n+   on memory can be handled in the polyhedral model: operations that\n+   define scalar evolutions in conditions, that can potentially be\n+   used to index memory, can't be handled by the polyhedral model.  */\n+\n+static bool\n build_scop_conditions (scop_p scop)\n {\n+  bool res;\n   VEC (gimple, heap) *conditions = NULL;\n   VEC (gimple, heap) *cases = NULL;\n \n-  build_scop_conditions_1 (&conditions, &cases, SCOP_ENTRY (scop), scop);\n+  res = build_scop_conditions_1 (&conditions, &cases, SCOP_ENTRY (scop), scop);\n \n   VEC_free (gimple, heap, conditions);\n   VEC_free (gimple, heap, cases);\n+  return res;\n }\n \n /* Build the current domain matrix: the loops belonging to the current\n@@ -4064,18 +4146,17 @@ expand_scalar_variables_expr (tree type, tree op0, enum tree_code code,\n \t  expand_scalar_variables_stmt (def_stmt, bb, scop,\n \t\t\t\t\told_loop_father, map);\n \t  return get_new_name_from_old_name (map, op0);\n-\t  \n \t}\n       else\n \t{\n \t  if (gimple_code (def_stmt) != GIMPLE_ASSIGN\n \t      || !bb_in_scop_p (gimple_bb (def_stmt), scop))\n \t    return get_new_name_from_old_name (map, op0);\n-\t  \n+\n \t  var0 = gimple_assign_rhs1 (def_stmt);\n \t  subcode = gimple_assign_rhs_code (def_stmt);\n \t  var1 = gimple_assign_rhs2 (def_stmt);\n-\t  \n+\n \t  return expand_scalar_variables_expr (type, var0, subcode, var1,\n \t\t\t\t\t       bb, scop, old_loop_father, map);\n \t}\n@@ -4100,7 +4181,7 @@ expand_scalar_variables_stmt (gimple stmt, basic_block bb, scop_p scop,\n     {\n       tree use = USE_FROM_PTR (use_p);\n       tree type = TREE_TYPE (use);\n-      enum tree_code code  = TREE_CODE (use);\n+      enum tree_code code = TREE_CODE (use);\n       tree use_expr = expand_scalar_variables_expr (type, use, code, NULL, bb,\n \t\t\t\t\t\t    scop, old_loop_father, map);\n       if (use_expr != use)\n@@ -5607,7 +5688,7 @@ strip_mine_profitable_p (graphite_bb_p gb, int stride,\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \t{\n \t  fprintf (dump_file, \"\\nStrip Mining is not profitable for loop %d:\",\n-\t\t   loop_index);\n+\t\t   loop->num);\n \t  fprintf (dump_file, \"number of iterations is too low.\\n\");\n \t}\n     }\n@@ -5616,17 +5697,16 @@ strip_mine_profitable_p (graphite_bb_p gb, int stride,\n }\n  \n /* Determines when the interchange of LOOP_A and LOOP_B belonging to\n-   SCOP is legal.  */\n+   SCOP is legal.  DEPTH is the number of loops around.  */\n \n static bool\n-is_interchange_valid (scop_p scop, int loop_a, int loop_b)\n+is_interchange_valid (scop_p scop, int loop_a, int loop_b, int depth)\n {\n   bool res;\n   VEC (ddr_p, heap) *dependence_relations;\n   VEC (data_reference_p, heap) *datarefs;\n \n   struct loop *nest = VEC_index (loop_p, SCOP_LOOP_NEST (scop), loop_a);\n-  int depth = perfect_loop_nest_depth (nest);\n   lambda_trans_matrix trans;\n \n   gcc_assert (loop_a < loop_b);\n@@ -5692,7 +5772,7 @@ graphite_trans_bb_block (graphite_bb_p gb, int stride, int loops)\n \n   for (i = start ; i < nb_loops; i++)\n     for (j = i + 1; j < nb_loops; j++)\n-      if (!is_interchange_valid (scop, i, j))\n+      if (!is_interchange_valid (scop, i, j, nb_loops))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -5716,6 +5796,10 @@ graphite_trans_bb_block (graphite_bb_p gb, int stride, int loops)\n   for (i = 1; i < nb_loops - start; i++)\n     graphite_trans_bb_move_loop (gb, start + 2 * i, start + i);\n \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"\\nLoops containing BB %d will be loop blocked.\\n\",\n+\t     GBB_BB (gb)->index);\n+\n   return true;\n }\n \n@@ -5858,9 +5942,6 @@ graphite_trans_scop_block (scop_p scop)\n     transform_done |= graphite_trans_loop_block (bbs, last_nb_loops - j);\n   VEC_free (graphite_bb_p, heap, bbs);\n \n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"\\nLoop blocked.\\n\");\n-\n   return transform_done;\n }\n \n@@ -5978,7 +6059,8 @@ graphite_transform_loops (void)\n \n       build_scop_canonical_schedules (scop);\n       build_bb_loops (scop);\n-      build_scop_conditions (scop);\n+      if (!build_scop_conditions (scop))\n+\tcontinue;\n       find_scop_parameters (scop);\n       build_scop_context (scop);\n "}, {"sha": "4055cfcbcae497cc1d778bdac5a58c63960c7bf6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -1,3 +1,16 @@\n+2009-01-07  Jan Sjodin  <jan.sjodin@amd.com>\n+\n+\tPR tree-optimization/38492\n+\tPR tree-optimization/38498\n+\t* testsuite/gcc.dg/graphite/pr38500.c: Fixed warning as committed\n+\tin trunk.\n+\t* testsuite/gcc.dg/graphite/block-0.c: Update test.\n+\t* testsuite/gcc.dg/graphite/block-1.c: Same.\n+\t* testsuite/gcc.dg/graphite/block-2.c: Remove xfail and test for blocking.\n+\t* testsuite/gcc.dg/graphite/block-4.c: Remove test for strip mine.\n+\t* testsuite/gcc.dg/graphite/block-3.c: New.\n+\t* testsuite/gcc.dg/graphite/pr38498.c: New.\n+\n 2009-01-07  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tAVX Programming Reference (December, 2008)"}, {"sha": "627f044fc14ce57142be3e9f5eb04e5fc12f13bd", "filename": "gcc/testsuite/gcc.dg/graphite/block-0.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-0.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -21,5 +21,5 @@ main()\n   return toto();\n }\n \n-/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\"} } */ \n+/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 1 \"graphite\"} } */ \n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "0a70e9e10a410a0e0983c4e16a1e7db6a458d5c8", "filename": "gcc/testsuite/gcc.dg/graphite/block-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-1.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -36,5 +36,5 @@ int main()\n   return sum;\n }\n \n-/* { dg-final { scan-tree-dump-times \"Loop blocked\" 2 \"graphite\"} } */ \n+/* { dg-final { scan-tree-dump-times \"will be loop blocked\" 2 \"graphite\"} } */ \n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "fc4e889e7915efe8e2344ec48f0185bac6aeb422", "filename": "gcc/testsuite/gcc.dg/graphite/block-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-2.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -28,5 +28,4 @@ void fallbackSort ( UInt32* fmap,\n    }\n    AssertH ( j < 256, 1005 );\n }\n-/* { dg-final { scan-tree-dump-times \"Loop blocked\" 1 \"graphite\" { xfail *-*-* }} } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "369df2fec7e45141f27a71c28f23fcc8b13f32b7", "filename": "gcc/testsuite/gcc.dg/graphite/block-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-3.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-options \"-O2 -floop-block -fdump-tree-graphite-all\" } */\n+\n+#define N 24\n+#define M 1000\n+\n+float A[1000][1000][1000], B[1000][1000], C[1000][1000];\n+\n+void test (void)\n+{\n+  int i, j, k;\n+\n+  /* These loops contain too few iterations for being strip-mined by 64.  */\n+  for (i = 0; i < 24; i++)\n+    for (j = 0; j < 24; j++)\n+      for (k = 0; k < 24; k++)\n+        A[i][j][k] = B[i][k] * C[k][j];\n+\n+  /* These loops should still be strip mined.  */\n+  for (i = 0; i < 1000; i++)\n+    for (j = 0; j < 1000; j++)\n+      for (k = 0; k < 1000; k++)\n+        A[i][j][k] = B[i][k] * C[k][j];\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "e3649f01d2d0c40736f919fd25f6464601a1f4e0", "filename": "gcc/testsuite/gcc.dg/graphite/block-4.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fblock-4.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -9,18 +9,15 @@ void test (void)\n {\n   int i, j, k;\n \n-  /* These loops contain too few iterations for being strip-mined by 64.  */\n   for (i = 0; i < 24; i++)\n     for (j = 0; j < 24; j++)\n       for (k = 0; k < 24; k++)\n         A[i][j] = B[i][k] * C[k][j];\n \n-  /* These loops should still be strip mined.  */\n   for (i = 0; i < 1000; i++)\n     for (j = 0; j < 1000; j++)\n       for (k = 0; k < 1000; k++)\n         A[i][j] = B[i][k] * C[k][j];\n }\n \n-/* { dg-final { scan-tree-dump-times \"Strip Mining is not profitable\" 2 \"graphite\" } } */\n /* { dg-final { cleanup-tree-dump \"graphite\" } } */"}, {"sha": "c79bbad554de51022024743d65011f638f7f58ad", "filename": "gcc/testsuite/gcc.dg/graphite/pr38498.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38498.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38498.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgraphite%2Fpr38498.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-options \"-O2 -floop-block\" } */\n+\n+double test_vector (float **data, int rows, int cols, int vqrows,double epsilon, int maxiter,int **mean, int *map)\n+{\n+    int i, j, r, it;\n+    double sqerr, prev_sqerr=0, t;\n+    unsigned int *sel;\n+    int *count;\n+    for (it = 0;; it++) \n+    {\n+        if ((sqerr == 0.0) || (it >= maxiter-1) ||((it > 0) && ( ((prev_sqerr - sqerr) / prev_sqerr) < epsilon )) )\n+            for (i = 0; i < vqrows; i++) \n+            {\n+                for (j = 0; j < cols; j++)\n+                    mean[i][j] = 0.0;\n+                count[i] = 0;\n+            }\n+    }\n+}"}, {"sha": "7a065b6b8b0b27334aa1b623466f0817dcfca812", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -1430,3 +1430,64 @@ for_each_scev_op (tree *scev, bool (*cbck) (tree *, void *), void *data)\n     }\n }\n \n+/* Returns true when the operation can be part of a linear\n+   expression.  */\n+\n+static inline bool\n+operator_is_linear (tree scev)\n+{\n+  switch (TREE_CODE (scev))\n+    {\n+    case INTEGER_CST:\n+    case POLYNOMIAL_CHREC:\n+    case PLUS_EXPR:\n+    case POINTER_PLUS_EXPR:\n+    case MULT_EXPR:\n+    case MINUS_EXPR:\n+    case NEGATE_EXPR:\n+    case SSA_NAME:\n+    case NON_LVALUE_EXPR:\n+    CASE_CONVERT:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Return true when SCEV is a linear expression.  Linear expressions\n+   can contain additions, substractions and multiplications.\n+   Multiplications are restricted to constant scaling: \"cst * x\".  */\n+\n+bool\n+scev_is_linear_expression (tree scev)\n+{\n+  if (scev == NULL\n+      || !operator_is_linear (scev))\n+    return false;\n+\n+  if (TREE_CODE (scev) == MULT_EXPR)\n+    return !(tree_contains_chrecs (TREE_OPERAND (scev, 0), NULL)\n+\t     && tree_contains_chrecs (TREE_OPERAND (scev, 1), NULL));\n+\n+  switch (TREE_CODE_LENGTH (TREE_CODE (scev)))\n+    {\n+    case 3:\n+      return scev_is_linear_expression (TREE_OPERAND (scev, 0))\n+\t&& scev_is_linear_expression (TREE_OPERAND (scev, 1))\n+\t&& scev_is_linear_expression (TREE_OPERAND (scev, 2));\n+\n+    case 2:\n+      return scev_is_linear_expression (TREE_OPERAND (scev, 0))\n+\t&& scev_is_linear_expression (TREE_OPERAND (scev, 1));\n+      \n+    case 1:\n+      return scev_is_linear_expression (TREE_OPERAND (scev, 0));\n+\n+    case 0:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}"}, {"sha": "fa372a2450b763f3980e8dae08681879d3de0fdf", "filename": "gcc/tree-chrec.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftree-chrec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a11476684547180634a11896c3b91a9970ea133/gcc%2Ftree-chrec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.h?ref=6a11476684547180634a11896c3b91a9970ea133", "patch": "@@ -84,6 +84,7 @@ extern bool evolution_function_is_affine_multivariate_p (const_tree, int);\n extern bool evolution_function_is_univariate_p (const_tree);\n extern unsigned nb_vars_in_chrec (tree);\n extern bool evolution_function_is_invariant_p (tree, int);\n+extern bool scev_is_linear_expression (tree);\n \n /* Determines whether CHREC is equal to zero.  */\n "}]}