{"sha": "96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY4NDJiY2RlNmU3NjAwZjNkNTI1ODA1ZWY1YmE3ZGVhM2IzZGJmNQ==", "commit": {"author": {"name": "Bo Thorsen", "email": "bo@gcc.gnu.org", "date": "2002-05-27T14:01:40Z"}, "committer": {"name": "Bo Thorsen", "email": "bo@gcc.gnu.org", "date": "2002-05-27T14:01:40Z"}, "message": "libgcc-x86_64-glibc.ver: Copy this file from the 3.1 branch.\n\n2002-05-23  Bo Thorsen  <bo@suse.de>\n\n        * config/i386/libgcc-x86_64-glibc.ver: Copy this file from the\n\t3.1 branch. The file was made by Jakub Jelinek.\n\t* config/i386/linux64.h (MD_FALLBACK_FRAME_STATE_FOR): Add i386\n\tsupport so multilib doesn't break. And don't define this at all\n\twhen -Dinhibit_libc is used.\n\t(MULTILIB_DEFAULTS): Always set default to 64 bit compilation.\n\t* config/i386/t-linux64: Implement full multilib support. Patch\n\toriginally done by Andreas Jaeger and Jakub Jelinek.\n\nFrom-SVN: r53927", "tree": {"sha": "e87605a18bba39e1c541a5f0a3097e566eecac2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e87605a18bba39e1c541a5f0a3097e566eecac2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5/comments", "author": null, "committer": null, "parents": [{"sha": "b86aa7b0487f06daa14d302950147b24edf1d478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b86aa7b0487f06daa14d302950147b24edf1d478", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b86aa7b0487f06daa14d302950147b24edf1d478"}], "stats": {"total": 79, "additions": 76, "deletions": 3}, "files": [{"sha": "5ea9520c2dcfb19571b174dad8722c886d3600a4", "filename": "gcc/config/i386/linux64.h", "status": "modified", "additions": 62, "deletions": 1, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5/gcc%2Fconfig%2Fi386%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5/gcc%2Fconfig%2Fi386%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Flinux64.h?ref=96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "patch": "@@ -65,14 +65,19 @@ Boston, MA 02111-1307, USA.  */\n   %{m32:%{!shared:crtend.o%s} %{shared:crtendS.o%s} crtn.o%s} \\\n   %{!m32:%{!shared:crtend.o%s} %{shared:crtendS.o%s} /usr/lib64/crtn.o%s}\"\n \n+#define MULTILIB_DEFAULTS { \"m64\" }\n+\n /* Do code reading to identify a signal frame, and set the frame\n-   state data appropriately.  See unwind-dw2.c for the structs.  */\n+   state data appropriately.  See unwind-dw2.c for the structs.  \n+   Don't use this at all if inhibit_libc is used.  */\n \n+#ifndef inhibit_libc\n #ifdef IN_LIBGCC2\n #include <signal.h>\n #include <sys/ucontext.h>\n #endif\n \n+#ifdef __x86_64__\n #define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n@@ -129,3 +134,59 @@ Boston, MA 02111-1307, USA.  */\n     (FS)->retaddr_column = 16;\t\t\t\t\t\t\\\n     goto SUCCESS;\t\t\t\t\t\t\t\\\n   } while (0)\n+#else /* ifdef __x86_64__  */\n+#define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\\n+    struct sigcontext *sc_;\t\t\t\t\t\t\\\n+    long new_cfa_;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* popl %eax ; movl $__NR_sigreturn,%eax ; int $0x80  */\t\t\\\n+    if (*(unsigned short *)(pc_+0) == 0xb858\t\t\t\t\\\n+\t&& *(unsigned int *)(pc_+2) == 119\t\t\t\t\\\n+\t&& *(unsigned short *)(pc_+6) == 0x80cd)\t\t\t\\\n+      sc_ = (CONTEXT)->cfa + 4;\t\t\t\t\t\t\\\n+    /* movl $__NR_rt_sigreturn,%eax ; int $0x80  */\t\t\t\\\n+    else if (*(unsigned char *)(pc_+0) == 0xb8\t\t\t\t\\\n+\t     && *(unsigned int *)(pc_+1) == 173\t\t\t\t\\\n+\t     && *(unsigned short *)(pc_+5) == 0x80cd)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tstruct rt_sigframe {\t\t\t\t\t\t\\\n+\t  int sig;\t\t\t\t\t\t\t\\\n+\t  struct siginfo *pinfo;\t\t\t\t\t\\\n+\t  void *puc;\t\t\t\t\t\t\t\\\n+\t  struct siginfo info;\t\t\t\t\t\t\\\n+\t  struct ucontext uc;\t\t\t\t\t\t\\\n+\t} *rt_ = (CONTEXT)->cfa;\t\t\t\t\t\\\n+\tsc_ = (struct sigcontext *) &rt_->uc.uc_mcontext;\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    else\t\t\t\t\t\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    new_cfa_ = sc_->esp;\t\t\t\t\t\t\\\n+    (FS)->cfa_how = CFA_REG_OFFSET;\t\t\t\t\t\\\n+    (FS)->cfa_reg = 4;\t\t\t\t\t\t\t\\\n+    (FS)->cfa_offset = new_cfa_ - (long) (CONTEXT)->cfa;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+    /* The SVR4 register numbering macros aren't usable in libgcc.  */\t\\\n+    (FS)->regs.reg[0].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[0].loc.offset = (long)&sc_->eax - new_cfa_;\t\t\\\n+    (FS)->regs.reg[3].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[3].loc.offset = (long)&sc_->ebx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[1].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[1].loc.offset = (long)&sc_->ecx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[2].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[2].loc.offset = (long)&sc_->edx - new_cfa_;\t\t\\\n+    (FS)->regs.reg[6].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[6].loc.offset = (long)&sc_->esi - new_cfa_;\t\t\\\n+    (FS)->regs.reg[7].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[7].loc.offset = (long)&sc_->edi - new_cfa_;\t\t\\\n+    (FS)->regs.reg[5].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[5].loc.offset = (long)&sc_->ebp - new_cfa_;\t\t\\\n+    (FS)->regs.reg[8].how = REG_SAVED_OFFSET;\t\t\t\t\\\n+    (FS)->regs.reg[8].loc.offset = (long)&sc_->eip - new_cfa_;\t\t\\\n+    (FS)->retaddr_column = 8;\t\t\t\t\t\t\\\n+    goto SUCCESS;\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif /* ifdef __x86_64__  */\n+#endif /* ifdef inhibit_libc  */"}, {"sha": "46a7caadf772e9ef2e0b423fcb98abec5394a400", "filename": "gcc/config/i386/t-linux64", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5/gcc%2Fconfig%2Fi386%2Ft-linux64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96842bcde6e7600f3d525805ef5ba7dea3b3dbf5/gcc%2Fconfig%2Fi386%2Ft-linux64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Ft-linux64?ref=96842bcde6e7600f3d525805ef5ba7dea3b3dbf5", "patch": "@@ -1,3 +1,15 @@\n-# On x86-64 we do not need any exports for glibc, override the settings\n+# On x86-64 we do not need any exports for glibc for 64-bit libgcc_s,\n+# override the settings\n # from t-slibgcc-elf-ver and t-linux\n-SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver\n+SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \\\n+\t\t $(srcdir)/config/i386/libgcc-x86_64-glibc.ver\n+\n+MULTILIB_OPTIONS = m64/m32\n+MULTILIB_DIRNAMES = 64 32 \n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib\n+\n+EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o\n+\n+SHLIB_SLIBDIR_SUFFIXES = 64:64 32:"}]}