{"sha": "d5e1935b09fa05093e31d7ce5e21b7e71957c103", "node_id": "C_kwDOANBUbNoAKGQ1ZTE5MzViMDlmYTA1MDkzZTMxZDdjZTVlMjFiN2U3MTk1N2MxMDM", "commit": {"author": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-08-31T09:58:08Z"}, "committer": {"name": "Mikael Morin", "email": "mikael@gcc.gnu.org", "date": "2022-09-25T12:44:54Z"}, "message": "fortran: Support clobbering of ASSOCIATE variables [PR41453]\n\nThis is in spirit a revert of:\nr9-3051-gc109362313623d83fe0a5194bceaf994cf0c6ce0\n\nThat commit added a condition to avoid generating ICE with clobbers\nof ASSOCIATE variables.\nThe test added at that point continues to pass if we remove that\ncondition now.\n\n\tPR fortran/41453\n\tPR fortran/87401\n\ngcc/fortran/ChangeLog:\n\n\t* trans-expr.cc (gfc_conv_procedure_call): Remove condition\n\tdisabling clobber generation for ASSOCIATE variables.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/intent_optimize_8.f90: New test.", "tree": {"sha": "b69a1c41a04aa3c65212d4367dd33b711728c865", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b69a1c41a04aa3c65212d4367dd33b711728c865"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d5e1935b09fa05093e31d7ce5e21b7e71957c103", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e1935b09fa05093e31d7ce5e21b7e71957c103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5e1935b09fa05093e31d7ce5e21b7e71957c103", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5e1935b09fa05093e31d7ce5e21b7e71957c103/comments", "author": null, "committer": null, "parents": [{"sha": "467ef2c40dbaf9d1219d9642e90df77dc61f4fae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/467ef2c40dbaf9d1219d9642e90df77dc61f4fae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/467ef2c40dbaf9d1219d9642e90df77dc61f4fae"}], "stats": {"total": 46, "additions": 45, "deletions": 1}, "files": [{"sha": "c2c7382c7d77333400416a43690d235e3814fbb0", "filename": "gcc/fortran/trans-expr.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e1935b09fa05093e31d7ce5e21b7e71957c103/gcc%2Ffortran%2Ftrans-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e1935b09fa05093e31d7ce5e21b7e71957c103/gcc%2Ffortran%2Ftrans-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.cc?ref=d5e1935b09fa05093e31d7ce5e21b7e71957c103", "patch": "@@ -6527,7 +6527,6 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t\t  && !e->symtree->n.sym->attr.dimension\n \t\t\t  && !e->symtree->n.sym->attr.pointer\n \t\t\t  && !e->symtree->n.sym->attr.allocatable\n-\t\t\t  && !e->symtree->n.sym->attr.associate_var\n \t\t\t  && e->ts.type != BT_CHARACTER\n \t\t\t  && e->ts.type != BT_DERIVED\n \t\t\t  && e->ts.type != BT_CLASS"}, {"sha": "4336fceab027ee0bd0e279fb2744fa22ad587403", "filename": "gcc/testsuite/gfortran.dg/intent_optimize_8.f90", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d5e1935b09fa05093e31d7ce5e21b7e71957c103/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d5e1935b09fa05093e31d7ce5e21b7e71957c103/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintent_optimize_8.f90?ref=d5e1935b09fa05093e31d7ce5e21b7e71957c103", "patch": "@@ -0,0 +1,45 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -fno-ipa-modref -fdump-tree-optimized -fdump-tree-original\" }\n+!\n+! PR fortran/41453\n+! Check that the INTENT(OUT) attribute causes one clobber to be emitted in\n+! the caller before each call to FOO in the *.original dump, and the\n+! initialization constants to be optimized away in the *.optimized dump,\n+! in the case of associate variables.\n+\n+module x\n+implicit none\n+contains\n+  subroutine foo(a)\n+    integer, intent(out) :: a\n+    a = 42\n+  end subroutine foo\n+end module x\n+\n+program main\n+  use x\n+  implicit none\n+  integer :: c1, c2\n+\n+  c1 = 123456789\n+  associate (d1 => c1)\n+    call foo(d1)\n+    if (d1 /= 42) stop 1\n+  end associate\n+  if (c1 /= 42) stop 2\n+\n+  c2 = 0\n+  associate (d2 => c2)\n+    d2 = 987654321\n+    call foo(d2)\n+    if (d2 /= 42) stop 3\n+  end associate\n+  if (c2 /= 42) stop 4\n+\n+end program main\n+\n+! { dg-final { scan-tree-dump-times \"CLOBBER\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump \"d1 = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump \"\\\\*d2 = {CLOBBER};\" \"original\" } }\n+! { dg-final { scan-tree-dump-not \"123456789\" \"optimized\" { target __OPTIMIZE__ } } }\n+! { dg-final { scan-tree-dump-not \"987654321\" \"optimized\" { target __OPTIMIZE__ } } }"}]}