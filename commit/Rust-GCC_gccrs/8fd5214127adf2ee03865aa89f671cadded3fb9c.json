{"sha": "8fd5214127adf2ee03865aa89f671cadded3fb9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGZkNTIxNDEyN2FkZjJlZTAzODY1YWE4OWY2NzFjYWRkZWQzZmI5Yw==", "commit": {"author": {"name": "Kito Cheng", "email": "kito.cheng@gmail.com", "date": "2018-04-08T08:31:52Z"}, "committer": {"name": "Chung-Ju Wu", "email": "jasonwucj@gcc.gnu.org", "date": "2018-04-08T08:31:52Z"}, "message": "[NDS32] Implement n8 pipeline.\n\ngcc/\n\t* config.gcc (nds32*-*-*): Check that n6/n8/s8 are valid to --with-cpu.\n\t* config/nds32/nds32-n8.md: New file.\n\t* config/nds32/nds32-opts.h (nds32_cpu_type): Add CPU_N6 and CPU_N8.\n\t* config/nds32/nds32-pipelines-auxiliary.c: Implementation for n8\n\tpipeline.\n\t* config/nds32/nds32-protos.h: More declarations for n8 pipeline.\n\t* config/nds32/nds32-utils.c: More implementations for n8 pipeline.\n\t* config/nds32/nds32.md (pipeline_model): Add n8.\n\t* config/nds32/nds32.opt (mcpu): Support n8 pipeline cpus.\n\t* config/nds32/pipelines.md: Include n8 settings.\n\nCo-Authored-By: Chung-Ju Wu <jasonwucj@gmail.com>\n\nFrom-SVN: r259219", "tree": {"sha": "66451221400ad89b13ce75a705831e26d69d1ead", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/66451221400ad89b13ce75a705831e26d69d1ead"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8fd5214127adf2ee03865aa89f671cadded3fb9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd5214127adf2ee03865aa89f671cadded3fb9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8fd5214127adf2ee03865aa89f671cadded3fb9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8fd5214127adf2ee03865aa89f671cadded3fb9c/comments", "author": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b99353a2aadd2de47694db415005ab137dd33959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b99353a2aadd2de47694db415005ab137dd33959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b99353a2aadd2de47694db415005ab137dd33959"}], "stats": {"total": 814, "additions": 810, "deletions": 4}, "files": [{"sha": "c5fe9678c1988620881a980a04f56f0ea9c86620", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -1,3 +1,17 @@\n+2018-04-08  Kito Cheng  <kito.cheng@gmail.com>\n+\t    Chung-Ju Wu  <jasonwucj@gmail.com>\n+\n+\t* config.gcc (nds32*-*-*): Check that n6/n8/s8 are valid to --with-cpu.\n+\t* config/nds32/nds32-n8.md: New file.\n+\t* config/nds32/nds32-opts.h (nds32_cpu_type): Add CPU_N6 and CPU_N8.\n+\t* config/nds32/nds32-pipelines-auxiliary.c: Implementation for n8\n+\tpipeline.\n+\t* config/nds32/nds32-protos.h: More declarations for n8 pipeline.\n+\t* config/nds32/nds32-utils.c: More implementations for n8 pipeline.\n+\t* config/nds32/nds32.md (pipeline_model): Add n8.\n+\t* config/nds32/nds32.opt (mcpu): Support n8 pipeline cpus.\n+\t* config/nds32/pipelines.md: Include n8 settings.\n+\n 2018-04-08  Kito Cheng  <kito.cheng@gmail.com>\n \t    Chung-Ju Wu  <jasonwucj@gmail.com>\n "}, {"sha": "4df7201ec0089bfd65c5edd67679274a44e2373c", "filename": "gcc/config.gcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -4315,11 +4315,11 @@ case \"${target}\" in\n \t\t\"\")\n \t\t\twith_cpu=n9\n \t\t\t;;\n-\t\tn9)\n+\t\tn6 | n8 | s8 | n9)\n \t\t\t# OK\n \t\t\t;;\n \t\t*)\n-\t\t\techo \"Cannot accept --with-cpu=$with_cpu, available values are: n9\" 1>&2\n+\t\t\techo \"Cannot accept --with-cpu=$with_cpu, available values are: n6 n8 s8 n9\" 1>&2\n \t\t\texit 1\n \t\t\t;;\n \t\tesac"}, {"sha": "d6242f8f0e11de9e2d9c1c63a411ab7ec901e36a", "filename": "gcc/config/nds32/nds32-n8.md", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-n8.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-n8.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-n8.md?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -0,0 +1,389 @@\n+;; Pipeline descriptions of Andes NDS32 cpu for GNU compiler\n+;; Copyright (C) 2012-2018 Free Software Foundation, Inc.\n+;; Contributed by Andes Technology Corporation.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 3, or (at your\n+;; option) any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+\n+;; ------------------------------------------------------------------------\n+;; Define N8 pipeline settings.\n+;; ------------------------------------------------------------------------\n+\n+(define_automaton \"nds32_n8_machine\")\n+\n+;; ------------------------------------------------------------------------\n+;; Pipeline Stages\n+;; ------------------------------------------------------------------------\n+;; IF - Instruction Fetch\n+;; II - Instruction Issue / Address Generation\n+;; EX - Instruction Execution\n+;; EXD - Psuedo Stage / Load Data Completion\n+\n+(define_cpu_unit \"n8_ii\" \"nds32_n8_machine\")\n+(define_cpu_unit \"n8_ex\" \"nds32_n8_machine\")\n+\n+(define_insn_reservation \"nds_n8_unknown\" 1\n+  (and (eq_attr \"type\" \"unknown\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_misc\" 1\n+  (and (eq_attr \"type\" \"misc\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_alu\" 1\n+  (and (eq_attr \"type\" \"alu\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load\" 1\n+  (and (match_test \"nds32::load_single_p (insn)\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store\" 1\n+  (and (match_test \"nds32::store_single_p (insn)\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_1\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"1\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_2\" 1\n+  (and (ior (and (eq_attr \"type\" \"load_multiple\")\n+\t\t (eq_attr \"combo\" \"2\"))\n+\t    (match_test \"nds32::load_double_p (insn)\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ii+n8_ex, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_3\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"3\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*2, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_4\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"4\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*3, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_5\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"5\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*4, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_6\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"6\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*5, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_7\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"7\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*6, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_8\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"8\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*7, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_load_multiple_12\" 1\n+  (and (and (eq_attr \"type\" \"load_multiple\")\n+\t    (eq_attr \"combo\" \"12\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*11, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_1\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"1\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_2\" 1\n+  (and (ior (and (eq_attr \"type\" \"store_multiple\")\n+\t\t (eq_attr \"combo\" \"2\"))\n+\t    (match_test \"nds32::store_double_p (insn)\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ii+n8_ex, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_3\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"3\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*2, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_4\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"4\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*3, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_5\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"5\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*4, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_6\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"6\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*5, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_7\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"7\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*6, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_8\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"8\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*7, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_store_multiple_12\" 1\n+  (and (and (eq_attr \"type\" \"store_multiple\")\n+\t    (eq_attr \"combo\" \"12\"))\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*11, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_mul_fast\" 1\n+  (and (match_test \"nds32_mul_config != MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n8\")))\n+  \"n8_ii, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_mul_slow\" 1\n+  (and (match_test \"nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mul\")\n+\t    (eq_attr \"pipeline_model\" \"n8\")))\n+  \"n8_ii, n8_ex*16\")\n+\n+(define_insn_reservation \"nds_n8_mac_fast\" 1\n+  (and (match_test \"nds32_mul_config != MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n8\")))\n+  \"n8_ii, n8_ii+n8_ex, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_mac_slow\" 1\n+  (and (match_test \"nds32_mul_config == MUL_TYPE_SLOW\")\n+       (and (eq_attr \"type\" \"mac\")\n+\t    (eq_attr \"pipeline_model\" \"n8\")))\n+  \"n8_ii, (n8_ii+n8_ex)*16, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_div\" 1\n+  (and (eq_attr \"type\" \"div\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, (n8_ii+n8_ex)*36, n8_ex\")\n+\n+(define_insn_reservation \"nds_n8_branch\" 1\n+  (and (eq_attr \"type\" \"branch\")\n+       (eq_attr \"pipeline_model\" \"n8\"))\n+  \"n8_ii, n8_ex\")\n+\n+;; ------------------------------------------------------------------------\n+;; Comment Notations and Bypass Rules\n+;; ------------------------------------------------------------------------\n+;; Producers (LHS)\n+;;   LD_!bi\n+;;     Load data from the memory (without updating the base register) and\n+;;     produce the loaded data. The result is ready at EXD.\n+;;   LD_bi\n+;;     Load data from the memory (with updating the base register) and\n+;;     produce the loaded data. The result is ready at EXD. Because the\n+;;     register port is 2R1W, two micro-operations are required in order\n+;;     to write two registers. The base register is updated by the second\n+;;     micro-operation and the result is ready at EX.\n+;;   LMW(N, M)\n+;;     There are N micro-operations within an instruction that loads multiple\n+;;     words. The result produced by the M-th micro-operation is sent to\n+;;     consumers. The result is ready at EXD. If the base register should be\n+;;     updated, an extra micro-operation is inserted to the sequence, and the\n+;;     result is ready at EX.\n+;;   ADDR_OUT\n+;;     Most load/store instructions can produce an address output if updating\n+;;     the base register is required. The result is ready at EX, which is\n+;;     produced by ALU.\n+;;   ALU, MUL, MAC\n+;;     The result is ready at EX.\n+;;   MOVD44_O\n+;;     A double-word move instruction needs to write registers twice. Because\n+;;     the register port is 2R1W, two micro-operations are required. The even\n+;;     number reigster is updated by the first one, and the odd number register\n+;;     is updated by the second one. Each of the results is ready at EX.\n+;;     The letter 'O' stands for odd.\n+;;   DIV_Rs\n+;;     A division instruction saves the quotient result to Rt and saves the\n+;;     remainder result to Rs. It requires two micro-operations because the\n+;;     register port is 2R1W. The first micro-operation writes to Rt, and\n+;;     the seconde one writes to Rs. Each of the results is ready at EX.\n+;;\n+;; Consumers (RHS)\n+;;   ALU, MUL, DIV\n+;;     Require operands at EX.\n+;;   MOVD44_E\n+;;     The letter 'E' stands for even, which is accessed by the first micro-\n+;;     operation and a movd44 instruction. The operand is required at EX.\n+;;   MAC_RaRb\n+;;     A MAC instruction is separated into two micro-operations. The first\n+;;     micro-operation does the multiplication, which requires operands Ra\n+;;     and Rb at EX. The second micro-options does the accumulation, which\n+;;     requires the operand Rt at EX.\n+;;   ADDR_IN_MOP(N)\n+;;     Because the reigster port is 2R1W, some load/store instructions are\n+;;     separated into many micro-operations. N denotes the address input is\n+;;     required by the N-th micro-operation. Such operand is required at II.\n+;;   ST_bi\n+;;     A post-increment store instruction requires its data at EX.\n+;;   ST_!bi_RI\n+;;     A store instruction with an immediate offset requires its data at EX.\n+;;     If the offset field is a register (ST_!bi_RR), the instruction will be\n+;;     separated into two micro-operations, and the second one requires the\n+;;     input operand at EX in order to store it to the memory.\n+;;   SMW(N, M)\n+;;     There are N micro-operations within an instruction that stores multiple\n+;;     words. Each M-th micro-operation requires its data at EX. If the base\n+;;     register should be updated, an extra micro-operation is inserted to the\n+;;     sequence.\n+;;   BR_COND\n+;;     If a branch instruction is conditional, its input data is required at EX.\n+\n+;; LD_!bi -> ADDR_IN_MOP(1)\n+(define_bypass 3\n+  \"nds_n8_load\"\n+  \"nds_n8_branch,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_load_to_ii_p\"\n+)\n+\n+;; LMW(N, N) -> ADDR_IN_MOP(1)\n+(define_bypass 3\n+  \"nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12\"\n+  \"nds_n8_branch,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_last_load_to_ii_p\"\n+)\n+\n+;; LMW(N, N - 1) -> ADDR_IN_MOP(1)\n+(define_bypass 2\n+  \"nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12\"\n+  \"nds_n8_branch,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_last_load_two_to_ii_p\"\n+)\n+\n+;; LD_bi -> ADDR_IN_MOP(1)\n+(define_bypass 2\n+  \"nds_n8_load\"\n+  \"nds_n8_branch,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_load_bi_to_ii_p\"\n+)\n+\n+;; LD_!bi -> ALU, MOVD44_E, MUL, MAC_RaRb, DIV, BR_COND, ST_bi, ST_!bi_RI, SMW(N, 1)\n+(define_bypass 2\n+  \"nds_n8_load\"\n+  \"nds_n8_alu,\n+   nds_n8_mul_fast, nds_n8_mul_slow,\\\n+   nds_n8_mac_fast, nds_n8_mac_slow,\\\n+   nds_n8_div,\\\n+   nds_n8_branch,\\\n+   nds_n8_store,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_load_to_ex_p\"\n+)\n+\n+;; ALU, MOVD44_O, MUL, MAC, DIV_Rs, LD_bi, ADDR_OUT -> ADDR_IN_MOP(1)\n+(define_bypass 2\n+  \"nds_n8_alu,\n+   nds_n8_mul_fast, nds_n8_mul_slow,\\\n+   nds_n8_mac_fast, nds_n8_mac_slow,\\\n+   nds_n8_div,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds_n8_branch,\\\n+   nds_n8_load, nds_n8_store,\\\n+   nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_ex_to_ii_p\"\n+)\n+\n+;; LMW(N, N) -> ALU, MOVD44_E, MUL, MAC_RaRb, DIV, BR_COND, ST_bi, ST_!bi_RI, SMW(N, 1)\n+(define_bypass 2\n+  \"nds_n8_load_multiple_1,nds_n8_load_multiple_2, nds_n8_load_multiple_3,\\\n+   nds_n8_load_multiple_4,nds_n8_load_multiple_5, nds_n8_load_multiple_6,\\\n+   nds_n8_load_multiple_7,nds_n8_load_multiple_8, nds_n8_load_multiple_12\"\n+  \"nds_n8_alu,\n+   nds_n8_mul_fast, nds_n8_mul_slow,\\\n+   nds_n8_mac_fast, nds_n8_mac_slow,\\\n+   nds_n8_div,\\\n+   nds_n8_branch,\\\n+   nds_n8_store,\\\n+   nds_n8_store_multiple_1,nds_n8_store_multiple_2, nds_n8_store_multiple_3,\\\n+   nds_n8_store_multiple_4,nds_n8_store_multiple_5, nds_n8_store_multiple_6,\\\n+   nds_n8_store_multiple_7,nds_n8_store_multiple_8, nds_n8_store_multiple_12\"\n+  \"nds32_n8_last_load_to_ex_p\"\n+)"}, {"sha": "9d3dd6931cb76aa5c3b2a25d5fb2ef6233bf0904", "filename": "gcc/config/nds32/nds32-opts.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-opts.h?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -37,6 +37,8 @@ enum nds32_arch_type\n /* The various ANDES CPU.  */\n enum nds32_cpu_type\n {\n+  CPU_N6,\n+  CPU_N8,\n   CPU_N9,\n   CPU_SIMPLE\n };"}, {"sha": "c2330f02041a8fad472e0dd88e8405cf037c938a", "filename": "gcc/config/nds32/nds32-pipelines-auxiliary.c", "status": "modified", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-pipelines-auxiliary.c?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -343,6 +343,108 @@ movd44_even_dep_p (rtx_insn *insn, rtx def_reg)\n using namespace nds32;\n using namespace nds32::scheduling;\n \n+namespace { // anonymous namespace\n+/* Check the dependency between the producer defining DEF_REG and CONSUMER\n+   requiring input operand at AG (II).  */\n+bool\n+n8_consumed_by_addr_in_p (rtx_insn *consumer, rtx def_reg)\n+{\n+  rtx use_rtx;\n+\n+  switch (get_attr_type (consumer))\n+    {\n+    case TYPE_BRANCH:\n+      use_rtx = extract_branch_target_rtx (consumer);\n+      break;\n+\n+    case TYPE_LOAD:\n+      if (load_single_p (consumer))\n+\tuse_rtx = extract_mem_rtx (consumer);\n+      else\n+\tuse_rtx = extract_base_reg (consumer);\n+      break;\n+\n+    case TYPE_STORE:\n+      if (store_single_p (consumer)\n+\t  && (!post_update_insn_p (consumer)\n+\t      || immed_offset_p (extract_mem_rtx (consumer))))\n+\tuse_rtx = extract_mem_rtx (consumer);\n+      else\n+\tuse_rtx = extract_base_reg (consumer);\n+      break;\n+\n+    case TYPE_LOAD_MULTIPLE:\n+    case TYPE_STORE_MULTIPLE:\n+      use_rtx = extract_base_reg (consumer);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return reg_overlap_p (def_reg, use_rtx);\n+}\n+\n+/* Check the dependency between the producer defining DEF_REG and CONSUMER\n+   requiring input operand at EX.  */\n+bool\n+n8_consumed_by_ex_p (rtx_insn *consumer, rtx def_reg)\n+{\n+  rtx use_rtx;\n+\n+  switch (get_attr_type (consumer))\n+    {\n+    case TYPE_ALU:\n+      if (movd44_even_dep_p (consumer, def_reg))\n+\treturn true;\n+\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_MUL:\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_MAC:\n+      use_rtx = extract_mac_non_acc_rtx (consumer);\n+      break;\n+\n+   /* Some special instructions, divmodsi4 and udivmodsi4, produce two\n+      results, the quotient and the remainder.  It requires two micro-\n+      operations in order to write two registers. We have to check the\n+      dependency from the producer to the first micro-operation.  */\n+    case TYPE_DIV:\n+      if (INSN_CODE (consumer) == CODE_FOR_divmodsi4\n+\t  || INSN_CODE (consumer) == CODE_FOR_udivmodsi4)\n+\tuse_rtx = SET_SRC (parallel_element (consumer, 0));\n+      else\n+\tuse_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_BRANCH:\n+      use_rtx = extract_branch_condition_rtx (consumer);\n+      break;\n+\n+    case TYPE_STORE:\n+      /* exclude ST_!bi_RR */\n+      if (!post_update_insn_p (consumer)\n+\t  && !immed_offset_p (extract_mem_rtx (consumer)))\n+\treturn false;\n+\n+      use_rtx = SET_SRC (PATTERN (consumer));\n+      break;\n+\n+    case TYPE_STORE_MULTIPLE:\n+      use_rtx = extract_nth_access_rtx (consumer, 0);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return reg_overlap_p (def_reg, use_rtx);\n+}\n+\n /* Check the dependency between the producer defining DEF_REG and CONSUMER\n    requiring input operand at EX.  */\n bool\n@@ -514,6 +616,152 @@ n9_3r2w_consumed_by_ex_dep_p (rtx_insn *consumer, rtx def_reg)\n   return false;\n }\n \n+\n+} // anonymous namespace\n+\n+/* ------------------------------------------------------------------------ */\n+\n+/* Guard functions for N8 core.  */\n+\n+bool\n+nds32_n8_load_to_ii_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  if (post_update_insn_p (producer))\n+    return false;\n+\n+  rtx def_reg = SET_DEST (PATTERN (producer));\n+\n+  return n8_consumed_by_addr_in_p (consumer, def_reg);\n+}\n+\n+bool\n+nds32_n8_load_bi_to_ii_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  if (!post_update_insn_p (producer))\n+    return false;\n+\n+  rtx def_reg = SET_DEST (PATTERN (producer));\n+\n+  return n8_consumed_by_addr_in_p (consumer, def_reg);\n+}\n+\n+bool\n+nds32_n8_load_to_ex_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  if (post_update_insn_p (producer))\n+    return false;\n+\n+  rtx def_reg = SET_DEST (PATTERN (producer));\n+\n+  return n8_consumed_by_ex_p (consumer, def_reg);\n+}\n+\n+bool\n+nds32_n8_ex_to_ii_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  rtx def_reg;\n+\n+  switch (get_attr_type (producer))\n+    {\n+    case TYPE_ALU:\n+      if (movd44_insn_p (producer))\n+\tdef_reg = extract_movd44_odd_reg (producer);\n+      else\n+\tdef_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    case TYPE_MUL:\n+    case TYPE_MAC:\n+      def_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    case TYPE_DIV:\n+      if (INSN_CODE (producer) == CODE_FOR_divmodsi4\n+\t  || INSN_CODE (producer) == CODE_FOR_udivmodsi4)\n+\tdef_reg = SET_DEST (parallel_element (producer, 1));\n+      else\n+\tdef_reg = SET_DEST (PATTERN (producer));\n+      break;\n+\n+    case TYPE_LOAD:\n+    case TYPE_STORE:\n+    case TYPE_LOAD_MULTIPLE:\n+    case TYPE_STORE_MULTIPLE:\n+      if (!post_update_insn_p (producer))\n+\treturn false;\n+\n+      def_reg = extract_base_reg (producer);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return n8_consumed_by_addr_in_p (consumer, def_reg);\n+}\n+\n+bool\n+nds32_n8_last_load_to_ii_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  /* If PRODUCER is a post-update LMW insn, the last micro-operation updates\n+     the base register and the result is ready in EX stage, so we don't need\n+     to handle that case in this guard function and the corresponding bypass\n+     rule.  */\n+  if (post_update_insn_p (producer))\n+    return false;\n+\n+  rtx last_def_reg = extract_nth_access_reg (producer, -1);\n+\n+  if (last_def_reg == NULL_RTX)\n+    return false;\n+\n+  gcc_assert (REG_P (last_def_reg) || GET_CODE (last_def_reg) == SUBREG);\n+\n+  return n8_consumed_by_addr_in_p (consumer, last_def_reg);\n+}\n+\n+bool\n+nds32_n8_last_load_two_to_ii_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  int index = -2;\n+\n+  /* If PRODUCER is a post-update insn, there is an additional one micro-\n+     operation inserted in the end, so the last memory access operation should\n+     be handled by this guard function and the corresponding bypass rule.  */\n+  if (post_update_insn_p (producer))\n+    index = -1;\n+\n+  rtx last_two_def_reg = extract_nth_access_reg (producer, index);\n+\n+  if (last_two_def_reg == NULL_RTX)\n+    return false;\n+\n+  gcc_assert (REG_P (last_two_def_reg)\n+\t      || GET_CODE (last_two_def_reg) == SUBREG);\n+\n+  return n8_consumed_by_addr_in_p (consumer, last_two_def_reg);\n+}\n+\n+bool\n+nds32_n8_last_load_to_ex_p (rtx_insn *producer, rtx_insn *consumer)\n+{\n+  /* If PRODUCER is a post-update LMW insn, the last micro-operation updates\n+     the base register and the result is ready in EX stage, so we don't need\n+     to handle that case in this guard function and the corresponding bypass\n+     rule.  */\n+  if (post_update_insn_p (producer))\n+    return false;\n+\n+  rtx last_def_reg = extract_nth_access_reg (producer, -1);\n+\n+  if (last_def_reg == NULL_RTX)\n+    return false;\n+\n+  gcc_assert (REG_P (last_def_reg) || GET_CODE (last_def_reg) == SUBREG);\n+\n+  return n8_consumed_by_ex_p (consumer, last_def_reg);\n+}\n+\n /* Guard functions for N9 cores.  */\n \n /* Check dependencies from MM to EX.  */"}, {"sha": "f9bba8ae95f812216fc9042534be2ecc6a130c28", "filename": "gcc/config/nds32/nds32-protos.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-protos.h?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -99,6 +99,14 @@ extern bool nds32_valid_multiple_load_store_p (rtx, bool, bool);\n \n /* Auxiliary functions for guard function checking in pipelines.md.  */\n \n+extern bool nds32_n8_load_to_ii_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_load_bi_to_ii_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_load_to_ex_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_ex_to_ii_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_last_load_to_ii_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_last_load_two_to_ii_p (rtx_insn *, rtx_insn *);\n+extern bool nds32_n8_last_load_to_ex_p (rtx_insn *, rtx_insn *);\n+\n extern bool nds32_n9_2r1w_mm_to_ex_p (rtx_insn *, rtx_insn *);\n extern bool nds32_n9_3r2w_mm_to_ex_p (rtx_insn *, rtx_insn *);\n extern bool nds32_n9_last_load_to_ex_p (rtx_insn *, rtx_insn *);\n@@ -251,8 +259,12 @@ rtx extract_base_reg (rtx_insn *);\n rtx extract_shift_reg (rtx);\n \n bool movd44_insn_p (rtx_insn *);\n+rtx extract_movd44_odd_reg (rtx_insn *);\n \n rtx extract_mac_non_acc_rtx (rtx_insn *);\n+\n+rtx extract_branch_target_rtx (rtx_insn *);\n+rtx extract_branch_condition_rtx (rtx_insn *);\n } // namespace nds32\n \n /* Functions for create nds32 specific optimization pass.  */"}, {"sha": "b0151be39dc6463d784c354642a7cc5bb667ac8a", "filename": "gcc/config/nds32/nds32-utils.c", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32-utils.c?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -377,6 +377,33 @@ movd44_insn_p (rtx_insn *insn)\n   return false;\n }\n \n+/* Extract the second result (odd reg) of a movd44 insn.  */\n+rtx\n+extract_movd44_odd_reg (rtx_insn *insn)\n+{\n+  gcc_assert (movd44_insn_p (insn));\n+\n+  rtx def_reg = SET_DEST (PATTERN (insn));\n+  machine_mode mode;\n+\n+  gcc_assert (REG_P (def_reg) || GET_CODE (def_reg) == SUBREG);\n+  switch (GET_MODE (def_reg))\n+    {\n+    case E_DImode:\n+      mode = SImode;\n+      break;\n+\n+    case E_DFmode:\n+      mode = SFmode;\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  return gen_highpart (mode, def_reg);\n+}\n+\n /* Extract the rtx representing non-accumulation operands of a MAC insn.  */\n rtx\n extract_mac_non_acc_rtx (rtx_insn *insn)\n@@ -396,4 +423,89 @@ extract_mac_non_acc_rtx (rtx_insn *insn)\n     }\n }\n \n+/* Extract the rtx representing the branch target to help recognize\n+   data hazards.  */\n+rtx\n+extract_branch_target_rtx (rtx_insn *insn)\n+{\n+  gcc_assert (CALL_P (insn) || JUMP_P (insn));\n+\n+  rtx body = PATTERN (insn);\n+\n+  if (GET_CODE (body) == SET)\n+    {\n+      /* RTXs in IF_THEN_ELSE are branch conditions.  */\n+      if (GET_CODE (SET_SRC (body)) == IF_THEN_ELSE)\n+        return NULL_RTX;\n+\n+      return SET_SRC (body);\n+    }\n+\n+  if (GET_CODE (body) == CALL)\n+    return XEXP (body, 0);\n+\n+  if (GET_CODE (body) == PARALLEL)\n+    {\n+      rtx first_rtx = parallel_element (body, 0);\n+\n+      if (GET_CODE (first_rtx) == SET)\n+\treturn SET_SRC (first_rtx);\n+\n+      if (GET_CODE (first_rtx) == CALL)\n+\treturn XEXP (first_rtx, 0);\n+    }\n+\n+  /* Handle special cases of bltzal, bgezal and jralnez.  */\n+  if (GET_CODE (body) == COND_EXEC)\n+    {\n+      rtx addr_rtx = XEXP (body, 1);\n+\n+      if (GET_CODE (addr_rtx) == SET)\n+\treturn SET_SRC (addr_rtx);\n+\n+      if (GET_CODE (addr_rtx) == PARALLEL)\n+\t{\n+\t  rtx first_rtx = parallel_element (addr_rtx, 0);\n+\n+\t  if (GET_CODE (first_rtx) == SET)\n+\t    {\n+\t      rtx call_rtx = SET_SRC (first_rtx);\n+\t      gcc_assert (GET_CODE (call_rtx) == CALL);\n+\n+\t      return XEXP (call_rtx, 0);\n+\t    }\n+\n+\t  if (GET_CODE (first_rtx) == CALL)\n+\t    return XEXP (first_rtx, 0);\n+\t}\n+    }\n+\n+  gcc_unreachable ();\n+}\n+\n+/* Extract the rtx representing the branch condition to help recognize\n+   data hazards.  */\n+rtx\n+extract_branch_condition_rtx (rtx_insn *insn)\n+{\n+  gcc_assert (CALL_P (insn) || JUMP_P (insn));\n+\n+  rtx body = PATTERN (insn);\n+\n+  if (GET_CODE (body) == SET)\n+    {\n+      rtx if_then_else_rtx = SET_SRC (body);\n+\n+      if (GET_CODE (if_then_else_rtx) == IF_THEN_ELSE)\n+        return XEXP (if_then_else_rtx, 0);\n+\n+      return NULL_RTX;\n+    }\n+\n+  if (GET_CODE (body) == COND_EXEC)\n+    return XEXP (body, 0);\n+\n+  return NULL_RTX;\n+}\n+\n } // namespace nds32"}, {"sha": "9ea72d70ced79ad9078f72e2e5614a55828b2ab9", "filename": "gcc/config/nds32/nds32.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.md?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -56,9 +56,10 @@\n ;; ------------------------------------------------------------------------\n \n ;; CPU pipeline model.\n-(define_attr \"pipeline_model\" \"n9,simple\"\n+(define_attr \"pipeline_model\" \"n8,n9,simple\"\n   (const\n-    (cond [(match_test \"nds32_cpu_option == CPU_N9\")  (const_string \"n9\")\n+    (cond [(match_test \"nds32_cpu_option == CPU_N6 || nds32_cpu_option == CPU_N8\")  (const_string \"n8\")\n+\t   (match_test \"nds32_cpu_option == CPU_N9\")  (const_string \"n9\")\n \t   (match_test \"nds32_cpu_option == CPU_SIMPLE\") (const_string \"simple\")]\n \t  (const_string \"n9\"))))\n "}, {"sha": "f7d98a81c9f81a1edefe5a1349f85c0b89fc3f10", "filename": "gcc/config/nds32/nds32.opt", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fnds32.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.opt?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -174,6 +174,30 @@ Enum\n Name(nds32_cpu_type) Type(enum nds32_cpu_type)\n Known cpu types (for use with the -mcpu= option):\n \n+EnumValue\n+Enum(nds32_cpu_type) String(n6) Value(CPU_N6)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n650) Value(CPU_N6)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n8) Value(CPU_N8)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(n801) Value(CPU_N8)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(sn8) Value(CPU_N8)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(sn801) Value(CPU_N8)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(s8) Value(CPU_N8)\n+\n+EnumValue\n+Enum(nds32_cpu_type) String(s801) Value(CPU_N8)\n+\n EnumValue\n Enum(nds32_cpu_type) String(n9) Value(CPU_N9)\n "}, {"sha": "b31d7e6579378e44f4a6498fd305101f33b79fcd", "filename": "gcc/config/nds32/pipelines.md", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fpipelines.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8fd5214127adf2ee03865aa89f671cadded3fb9c/gcc%2Fconfig%2Fnds32%2Fpipelines.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fpipelines.md?ref=8fd5214127adf2ee03865aa89f671cadded3fb9c", "patch": "@@ -18,6 +18,10 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; ------------------------------------------------------------------------\n+;; Include N8 pipeline settings.\n+;; ------------------------------------------------------------------------\n+(include \"nds32-n8.md\")\n \n ;; ------------------------------------------------------------------------\n ;; Include N9/N10 pipeline settings."}]}