{"sha": "f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI5YWZlNWYxNDQ1YmE2YzMzMTE2Y2EyNmViOGNkOWEyOWE0YTQ2YQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T14:16:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2014-02-06T14:16:52Z"}, "message": "Code clean ups.\n\nFrom-SVN: r207560", "tree": {"sha": "5a8e13696c158c85c370de398856874654015769", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a8e13696c158c85c370de398856874654015769"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a/comments", "author": null, "committer": null, "parents": [{"sha": "aa9b151a9e3630f78c1517d016fa26dc3277b506", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa9b151a9e3630f78c1517d016fa26dc3277b506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa9b151a9e3630f78c1517d016fa26dc3277b506"}], "stats": {"total": 52, "additions": 39, "deletions": 13}, "files": [{"sha": "29366d06498cfba77fd74c47a2c087a7dff872f6", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 39, "deletions": 13, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=f29afe5f1445ba6c33116ca26eb8cd9a29a4a46a", "patch": "@@ -3280,6 +3280,7 @@ package body Exp_Aggr is\n       T    : Entity_Id;\n       Temp : Entity_Id;\n \n+      Aggr_Code   : List_Id;\n       Instr       : Node_Id;\n       Target_Expr : Node_Id;\n       Parent_Kind : Node_Kind;\n@@ -3361,9 +3362,7 @@ package body Exp_Aggr is\n       end if;\n \n       if Requires_Transient_Scope (Typ) then\n-         Establish_Transient_Scope\n-           (N, Sec_Stack =>\n-                 Is_Controlled (Typ) or else Has_Controlled_Component (Typ));\n+         Establish_Transient_Scope (N, Sec_Stack => Needs_Finalization (Typ));\n       end if;\n \n       --  If the aggregate is non-limited, create a temporary. If it is limited\n@@ -3401,8 +3400,20 @@ package body Exp_Aggr is\n          Set_No_Initialization (Instr);\n          Insert_Action (N, Instr);\n          Initialize_Discriminants (Instr, T);\n+\n          Target_Expr := New_Occurrence_Of (Temp, Loc);\n-         Insert_Actions (N, Build_Record_Aggr_Code (N, T, Target_Expr));\n+         Aggr_Code   := Build_Record_Aggr_Code (N, T, Target_Expr);\n+\n+         --  Save the last assignment statement associated with the aggregate\n+         --  when building a controlled object. This reference is utilized by\n+         --  the finalization machinery when marking an object as successfully\n+         --  initialized.\n+\n+         if Needs_Finalization (T) then\n+            Set_Last_Aggregate_Assignment (Temp, Last (Aggr_Code));\n+         end if;\n+\n+         Insert_Actions (N, Aggr_Code);\n          Rewrite (N, New_Occurrence_Of (Temp, Loc));\n          Analyze_And_Resolve (N, T);\n       end if;\n@@ -5702,17 +5713,15 @@ package body Exp_Aggr is\n       then\n          Convert_To_Assignments (N, Typ);\n \n-      --  Temporaries for controlled aggregates need to be attached to a final\n-      --  chain in order to be properly finalized, so it has to be created in\n-      --  the front-end\n+      --  An aggregate used to initialize a controlled object must be turned\n+      --  into component assignments as the components themselves may require\n+      --  finalization actions such as adjustment.\n \n-      elsif Is_Controlled (Typ)\n-        or else Has_Controlled_Component (Base_Type (Typ))\n-      then\n+      elsif Needs_Finalization (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n-         --  Ada 2005 (AI-287): In case of default initialized components we\n-         --  convert the aggregate into assignments.\n+      --  Ada 2005 (AI-287): In case of default initialized components we\n+      --  convert the aggregate into assignments.\n \n       elsif Has_Default_Init_Comps (N) then\n          Convert_To_Assignments (N, Typ);\n@@ -6188,9 +6197,26 @@ package body Exp_Aggr is\n       Typ    : Entity_Id;\n       Target : Node_Id) return List_Id\n    is\n+      Aggr_Code : List_Id;\n+\n    begin\n       if Is_Record_Type (Etype (N)) then\n-         return Build_Record_Aggr_Code (N, Typ, Target);\n+         Aggr_Code := Build_Record_Aggr_Code (N, Typ, Target);\n+\n+         --  Save the last assignment statement associated with the aggregate\n+         --  when building a controlled object. This reference is utilized by\n+         --  the finalization machinery when marking an object as successfully\n+         --  initialized.\n+\n+         if Needs_Finalization (Typ)\n+           and then Is_Entity_Name (Target)\n+           and then Present (Entity (Target))\n+           and then Ekind (Entity (Target)) = E_Variable\n+         then\n+            Set_Last_Aggregate_Assignment (Entity (Target), Last (Aggr_Code));\n+         end if;\n+\n+         return Aggr_Code;\n \n       else pragma Assert (Is_Array_Type (Etype (N)));\n          return"}]}