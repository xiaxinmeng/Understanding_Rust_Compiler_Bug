{"sha": "e157f73660e50bd02f5c2c6d94624de70303e579", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE1N2Y3MzY2MGU1MGJkMDJmNWMyYzZkOTQ2MjRkZTcwMzAzZTU3OQ==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2008-08-31T10:00:30Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2008-08-31T10:00:30Z"}, "message": "gfortran.h (enum gfc_statement): New entry `ST_GENERIC'.\n\n2008-08-31  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.h (enum gfc_statement): New entry `ST_GENERIC'.\n\t(struct gfc_tbp_generic): New type.\n\t(struct gfc_typebound_proc): Removed `target' and added union with\n\t`specific' and `generic' members; new members `overridden',\n\t`subroutine', `function' and `is_generic'.\n\t(struct gfc_expr): New members `derived' and `name' in compcall union\n\tmember and changed type of `tbp' to gfc_typebound_proc.\n\t(gfc_compare_interfaces), (gfc_compare_actual_formal): Made public.\n\t* match.h (gfc_typebound_default_access): New global.\n\t(gfc_match_generic): New method.\n\t* decl.c (gfc_match_generic): New method.\n\t(match_binding_attributes): New argument `generic' and handle it.\n\t(match_procedure_in_type): Mark matched binding as non-generic.\n\t* interface.c (gfc_compare_interfaces): Made public.\n\t(gfc_compare_actual_formal): Ditto.\n\t(check_interface_1), (compare_parameter): Use new public names.\n\t(gfc_procedure_use), (gfc_search_interface): Ditto.\n\t* match.c (match_typebound_call): Set base-symbol referenced.\n\t* module.c (binding_generic): New global array.\n\t(current_f2k_derived): New global.\n\t(mio_typebound_proc): Handle IO of GENERIC bindings.\n\t(mio_f2k_derived): Record current f2k-namespace in current_f2k_derived.\n\t* parse.c (decode_statement): Handle GENERIC statement.\n\t(gfc_ascii_statement): Ditto.\n\t(typebound_default_access), (set_typebound_default_access): Removed.\n\t(gfc_typebound_default_access): New global.\n\t(parse_derived_contains): New default-access implementation and handle\n\tGENERIC statements encountered.\n\t* primary.c (gfc_match_varspec): Adapted to new gfc_typebound_proc\n\tstructure and removed check for SUBROUTINE/FUNCTION from here.\n\t* resolve.c (extract_compcall_passed_object): New method.\n\t(update_compcall_arglist): Use it.\n\t(resolve_typebound_static): Adapted to new gfc_typebound_proc structure.\n\t(resolve_typebound_generic_call): New method.\n\t(resolve_typebound_call): Check target is a SUBROUTINE and handle calls\n\tto GENERIC bindings.\n\t(resolve_compcall): Ditto (check for target being FUNCTION).\n\t(check_typebound_override): Handle GENERIC bindings.\n\t(check_generic_tbp_ambiguity), (resolve_typebound_generic): New methods.\n\t(resolve_typebound_procedure): Handle GENERIC bindings and set new\n\tattributes subroutine, function and overridden in gfc_typebound_proc.\n\t(resolve_fl_derived): Ensure extended type is resolved before the\n\textending one is.\n\t* st.c (gfc_free_statement): Fix bug with free'ing EXEC_COMPCALL's.\n\t* symbol.c (gfc_find_typebound_proc): Adapt for GENERIC changes.\n\n2008-08-31  Daniel Kraft  <d@domob.eu>\n\n\t* gfortran.dg/typebound_generic_1.f03: New test.\n\t* gfortran.dg/typebound_generic_2.f03: New test.\n\t* gfortran.dg/typebound_generic_3.f03: New test.\n\nFrom-SVN: r139822", "tree": {"sha": "f1e34fc56018b9fd2a92bf9de5854b3ef33fc9bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f1e34fc56018b9fd2a92bf9de5854b3ef33fc9bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e157f73660e50bd02f5c2c6d94624de70303e579", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e157f73660e50bd02f5c2c6d94624de70303e579", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e157f73660e50bd02f5c2c6d94624de70303e579", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e157f73660e50bd02f5c2c6d94624de70303e579/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f40751dd3417bc2b10d85a8f6afa3771c6de7101", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40751dd3417bc2b10d85a8f6afa3771c6de7101", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40751dd3417bc2b10d85a8f6afa3771c6de7101"}], "stats": {"total": 1079, "additions": 938, "deletions": 141}, "files": [{"sha": "13ddef193dc6d682c73778d3e9ae35c73056ec3e", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -1,3 +1,51 @@\n+2008-08-31  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.h (enum gfc_statement): New entry `ST_GENERIC'.\n+\t(struct gfc_tbp_generic): New type.\n+\t(struct gfc_typebound_proc): Removed `target' and added union with\n+\t`specific' and `generic' members; new members `overridden',\n+\t`subroutine', `function' and `is_generic'.\n+\t(struct gfc_expr): New members `derived' and `name' in compcall union\n+\tmember and changed type of `tbp' to gfc_typebound_proc.\n+\t(gfc_compare_interfaces), (gfc_compare_actual_formal): Made public.\n+\t* match.h (gfc_typebound_default_access): New global.\n+\t(gfc_match_generic): New method.\n+\t* decl.c (gfc_match_generic): New method.\n+\t(match_binding_attributes): New argument `generic' and handle it.\n+\t(match_procedure_in_type): Mark matched binding as non-generic.\n+\t* interface.c (gfc_compare_interfaces): Made public.\n+\t(gfc_compare_actual_formal): Ditto.\n+\t(check_interface_1), (compare_parameter): Use new public names.\n+\t(gfc_procedure_use), (gfc_search_interface): Ditto.\n+\t* match.c (match_typebound_call): Set base-symbol referenced.\n+\t* module.c (binding_generic): New global array.\n+\t(current_f2k_derived): New global.\n+\t(mio_typebound_proc): Handle IO of GENERIC bindings.\n+\t(mio_f2k_derived): Record current f2k-namespace in current_f2k_derived.\n+\t* parse.c (decode_statement): Handle GENERIC statement.\n+\t(gfc_ascii_statement): Ditto.\n+\t(typebound_default_access), (set_typebound_default_access): Removed.\n+\t(gfc_typebound_default_access): New global.\n+\t(parse_derived_contains): New default-access implementation and handle\n+\tGENERIC statements encountered.\n+\t* primary.c (gfc_match_varspec): Adapted to new gfc_typebound_proc\n+\tstructure and removed check for SUBROUTINE/FUNCTION from here.\n+\t* resolve.c (extract_compcall_passed_object): New method.\n+\t(update_compcall_arglist): Use it.\n+\t(resolve_typebound_static): Adapted to new gfc_typebound_proc structure.\n+\t(resolve_typebound_generic_call): New method.\n+\t(resolve_typebound_call): Check target is a SUBROUTINE and handle calls\n+\tto GENERIC bindings.\n+\t(resolve_compcall): Ditto (check for target being FUNCTION).\n+\t(check_typebound_override): Handle GENERIC bindings.\n+\t(check_generic_tbp_ambiguity), (resolve_typebound_generic): New methods.\n+\t(resolve_typebound_procedure): Handle GENERIC bindings and set new\n+\tattributes subroutine, function and overridden in gfc_typebound_proc.\n+\t(resolve_fl_derived): Ensure extended type is resolved before the\n+\textending one is.\n+\t* st.c (gfc_free_statement): Fix bug with free'ing EXEC_COMPCALL's.\n+\t* symbol.c (gfc_find_typebound_proc): Adapt for GENERIC changes.\n+\n 2008-08-29  Jan Hubicka  <jh@suse.cz>\n \t\n \t* parse.c (parse_interface): Silence uninitialized var warning."}, {"sha": "b3ec1a66e22cdc29c964f17967aaec36aa04974f", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 219, "deletions": 70, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -6721,7 +6721,7 @@ gfc_match_enumerator_def (void)\n /* Match binding attributes.  */\n \n static match\n-match_binding_attributes (gfc_typebound_proc* ba)\n+match_binding_attributes (gfc_typebound_proc* ba, bool generic)\n {\n   bool found_passing = false;\n   match m;\n@@ -6736,120 +6736,135 @@ match_binding_attributes (gfc_typebound_proc* ba)\n \n   /* If we find a comma, we believe there are binding attributes.  */\n   if (gfc_match_char (',') == MATCH_NO)\n-    return MATCH_NO;\n+    {\n+      ba->access = gfc_typebound_default_access;\n+      return MATCH_NO;\n+    }\n \n   do\n     {\n-      /* NOPASS flag.  */\n-      m = gfc_match (\" nopass\");\n+      /* Access specifier.  */\n+\n+      m = gfc_match (\" public\");\n       if (m == MATCH_ERROR)\n \tgoto error;\n       if (m == MATCH_YES)\n \t{\n-\t  if (found_passing)\n+\t  if (ba->access != ACCESS_UNKNOWN)\n \t    {\n-\t      gfc_error (\"Binding attributes already specify passing, illegal\"\n-\t\t\t \" NOPASS at %C\");\n+\t      gfc_error (\"Duplicate access-specifier at %C\");\n \t      goto error;\n \t    }\n \n-\t  found_passing = true;\n-\t  ba->nopass = 1;\n+\t  ba->access = ACCESS_PUBLIC;\n \t  continue;\n \t}\n \n-      /* NON_OVERRIDABLE flag.  */\n-      m = gfc_match (\" non_overridable\");\n+      m = gfc_match (\" private\");\n       if (m == MATCH_ERROR)\n \tgoto error;\n       if (m == MATCH_YES)\n \t{\n-\t  if (ba->non_overridable)\n+\t  if (ba->access != ACCESS_UNKNOWN)\n \t    {\n-\t      gfc_error (\"Duplicate NON_OVERRIDABLE at %C\");\n+\t      gfc_error (\"Duplicate access-specifier at %C\");\n \t      goto error;\n \t    }\n \n-\t  ba->non_overridable = 1;\n+\t  ba->access = ACCESS_PRIVATE;\n \t  continue;\n \t}\n \n-      /* DEFERRED flag.  */\n-      /* TODO: Handle really once implemented.  */\n-      m = gfc_match (\" deferred\");\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_YES)\n-\t{\n-\t  gfc_error (\"DEFERRED not yet implemented at %C\");\n-\t  goto error;\n-\t}\n-\n-      /* PASS possibly including argument.  */\n-      m = gfc_match (\" pass\");\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_YES)\n+      /* If inside GENERIC, the following is not allowed.  */\n+      if (!generic)\n \t{\n-\t  char arg[GFC_MAX_SYMBOL_LEN + 1];\n \n-\t  if (found_passing)\n+\t  /* NOPASS flag.  */\n+\t  m = gfc_match (\" nopass\");\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_YES)\n \t    {\n-\t      gfc_error (\"Binding attributes already specify passing, illegal\"\n-\t\t\t \" PASS at %C\");\n-\t      goto error;\n+\t      if (found_passing)\n+\t\t{\n+\t\t  gfc_error (\"Binding attributes already specify passing,\"\n+\t\t\t     \" illegal NOPASS at %C\");\n+\t\t  goto error;\n+\t\t}\n+\n+\t      found_passing = true;\n+\t      ba->nopass = 1;\n+\t      continue;\n \t    }\n \n-\t  m = gfc_match (\" ( %n )\", arg);\n+\t  /* NON_OVERRIDABLE flag.  */\n+\t  m = gfc_match (\" non_overridable\");\n \t  if (m == MATCH_ERROR)\n \t    goto error;\n \t  if (m == MATCH_YES)\n-\t    ba->pass_arg = xstrdup (arg);\n-\t  gcc_assert ((m == MATCH_YES) == (ba->pass_arg != NULL));\n-\n-\t  found_passing = true;\n-\t  ba->nopass = 0;\n-\t  continue;\n-\t}\n+\t    {\n+\t      if (ba->non_overridable)\n+\t\t{\n+\t\t  gfc_error (\"Duplicate NON_OVERRIDABLE at %C\");\n+\t\t  goto error;\n+\t\t}\n \n-      /* Access specifier.  */\n+\t      ba->non_overridable = 1;\n+\t      continue;\n+\t    }\n \n-      m = gfc_match (\" public\");\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_YES)\n-\t{\n-\t  if (ba->access != ACCESS_UNKNOWN)\n+\t  /* DEFERRED flag.  */\n+\t  /* TODO: Handle really once implemented.  */\n+\t  m = gfc_match (\" deferred\");\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_YES)\n \t    {\n-\t      gfc_error (\"Duplicate access-specifier at %C\");\n+\t      gfc_error (\"DEFERRED not yet implemented at %C\");\n \t      goto error;\n \t    }\n \n-\t  ba->access = ACCESS_PUBLIC;\n-\t  continue;\n-\t}\n-\n-      m = gfc_match (\" private\");\n-      if (m == MATCH_ERROR)\n-\tgoto error;\n-      if (m == MATCH_YES)\n-\t{\n-\t  if (ba->access != ACCESS_UNKNOWN)\n+\t  /* PASS possibly including argument.  */\n+\t  m = gfc_match (\" pass\");\n+\t  if (m == MATCH_ERROR)\n+\t    goto error;\n+\t  if (m == MATCH_YES)\n \t    {\n-\t      gfc_error (\"Duplicate access-specifier at %C\");\n-\t      goto error;\n+\t      char arg[GFC_MAX_SYMBOL_LEN + 1];\n+\n+\t      if (found_passing)\n+\t\t{\n+\t\t  gfc_error (\"Binding attributes already specify passing,\"\n+\t\t\t     \" illegal PASS at %C\");\n+\t\t  goto error;\n+\t\t}\n+\n+\t      m = gfc_match (\" ( %n )\", arg);\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto error;\n+\t      if (m == MATCH_YES)\n+\t\tba->pass_arg = xstrdup (arg);\n+\t      gcc_assert ((m == MATCH_YES) == (ba->pass_arg != NULL));\n+\n+\t      found_passing = true;\n+\t      ba->nopass = 0;\n+\t      continue;\n \t    }\n \n-\t  ba->access = ACCESS_PRIVATE;\n-\t  continue;\n \t}\n \n       /* Nothing matching found.  */\n-      gfc_error (\"Expected binding attribute at %C\");\n+      if (generic)\n+\tgfc_error (\"Expected access-specifier at %C\");\n+      else\n+\tgfc_error (\"Expected binding attribute at %C\");\n       goto error;\n     }\n   while (gfc_match_char (',') == MATCH_YES);\n \n+  if (ba->access == ACCESS_UNKNOWN)\n+    ba->access = gfc_typebound_default_access;\n+\n   return MATCH_YES;\n \n error:\n@@ -6890,9 +6905,10 @@ match_procedure_in_type (void)\n   /* Construct the data structure.  */\n   tb = gfc_get_typebound_proc ();\n   tb->where = gfc_current_locus;\n+  tb->is_generic = 0;\n \n   /* Match binding attributes.  */\n-  m = match_binding_attributes (tb);\n+  m = match_binding_attributes (tb, false);\n   if (m == MATCH_ERROR)\n     return m;\n   seen_attrs = (m == MATCH_YES);\n@@ -6962,9 +6978,10 @@ match_procedure_in_type (void)\n   gcc_assert (ns);\n \n   /* See if we already have a binding with this name in the symtree which would\n-     be an error.  */\n+     be an error.  If a GENERIC already targetted this binding, it may be\n+     already there but then typebound is still NULL.  */\n   stree = gfc_find_symtree (ns->sym_root, name);\n-  if (stree)\n+  if (stree && stree->typebound)\n     {\n       gfc_error (\"There's already a procedure with binding name '%s' for the\"\n \t\t \" derived type '%s' at %C\", name, block->name);\n@@ -6974,14 +6991,146 @@ match_procedure_in_type (void)\n   /* Insert it and set attributes.  */\n   if (gfc_get_sym_tree (name, ns, &stree))\n     return MATCH_ERROR;\n-  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->target))\n+  if (gfc_get_sym_tree (target, gfc_current_ns, &tb->u.specific))\n     return MATCH_ERROR;\n+  gfc_set_sym_referenced (tb->u.specific->n.sym);\n   stree->typebound = tb;\n \n   return MATCH_YES;\n }\n \n \n+/* Match a GENERIC procedure binding inside a derived type.  */\n+\n+match\n+gfc_match_generic (void)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  gfc_symbol* block;\n+  gfc_typebound_proc tbattr; /* Used for match_binding_attributes.  */\n+  gfc_typebound_proc* tb;\n+  gfc_symtree* st;\n+  gfc_namespace* ns;\n+  match m;\n+\n+  /* Check current state.  */\n+  if (gfc_current_state () == COMP_DERIVED)\n+    {\n+      gfc_error (\"GENERIC at %C must be inside a derived-type CONTAINS\");\n+      return MATCH_ERROR;\n+    }\n+  if (gfc_current_state () != COMP_DERIVED_CONTAINS)\n+    return MATCH_NO;\n+  block = gfc_state_stack->previous->sym;\n+  ns = block->f2k_derived;\n+  gcc_assert (block && ns);\n+\n+  /* See if we get an access-specifier.  */\n+  m = match_binding_attributes (&tbattr, true);\n+  if (m == MATCH_ERROR)\n+    goto error;\n+\n+  /* Now the colons, those are required.  */\n+  if (gfc_match (\" ::\") != MATCH_YES)\n+    {\n+      gfc_error (\"Expected '::' at %C\");\n+      goto error;\n+    }\n+\n+  /* The binding name and =>.  */\n+  m = gfc_match (\" %n =>\", name);\n+  if (m == MATCH_ERROR)\n+    return MATCH_ERROR;\n+  if (m == MATCH_NO)\n+    {\n+      gfc_error (\"Expected generic name at %C\");\n+      goto error;\n+    }\n+\n+  /* If there's already something with this name, check that it is another\n+     GENERIC and then extend that rather than build a new node.  */\n+  st = gfc_find_symtree (ns->sym_root, name);\n+  if (st)\n+    {\n+      if (!st->typebound || !st->typebound->is_generic)\n+\t{\n+\t  gfc_error (\"There's already a non-generic procedure with binding name\"\n+\t\t     \" '%s' for the derived type '%s' at %C\",\n+\t\t     name, block->name);\n+\t  goto error;\n+\t}\n+\n+      tb = st->typebound;\n+      if (tb->access != tbattr.access)\n+\t{\n+\t  gfc_error (\"Binding at %C must have the same access as already\"\n+\t\t     \" defined binding '%s'\", name);\n+\t  goto error;\n+\t}\n+    }\n+  else\n+    {\n+      if (gfc_get_sym_tree (name, ns, &st))\n+\treturn MATCH_ERROR;\n+\n+      st->typebound = tb = gfc_get_typebound_proc ();\n+      tb->where = gfc_current_locus;\n+      tb->access = tbattr.access;\n+      tb->is_generic = 1;\n+      tb->u.generic = NULL;\n+    }\n+\n+  /* Now, match all following names as specific targets.  */\n+  do\n+    {\n+      gfc_symtree* target_st;\n+      gfc_tbp_generic* target;\n+\n+      m = gfc_match_name (name);\n+      if (m == MATCH_ERROR)\n+\tgoto error;\n+      if (m == MATCH_NO)\n+\t{\n+\t  gfc_error (\"Expected specific binding name at %C\");\n+\t  goto error;\n+\t}\n+\n+      if (gfc_get_sym_tree (name, ns, &target_st))\n+\tgoto error;\n+\n+      /* See if this is a duplicate specification.  */\n+      for (target = tb->u.generic; target; target = target->next)\n+\tif (target_st == target->specific_st)\n+\t  {\n+\t    gfc_error (\"'%s' already defined as specific binding for the\"\n+\t\t       \" generic '%s' at %C\", name, st->n.sym->name);\n+\t    goto error;\n+\t  }\n+\n+      gfc_set_sym_referenced (target_st->n.sym);\n+\n+      target = gfc_get_tbp_generic ();\n+      target->specific_st = target_st;\n+      target->specific = NULL;\n+      target->next = tb->u.generic;\n+      tb->u.generic = target;\n+    }\n+  while (gfc_match (\" ,\") == MATCH_YES);\n+\n+  /* Here should be the end.  */\n+  if (gfc_match_eos () != MATCH_YES)\n+    {\n+      gfc_error (\"Junk after GENERIC binding at %C\");\n+      goto error;\n+    }\n+\n+  return MATCH_YES;\n+\n+error:\n+  return MATCH_ERROR;\n+}\n+\n+\n /* Match a FINAL declaration inside a derived type.  */\n \n match"}, {"sha": "9020029c84877758f83d1a55939afd5bc0ddb339", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -229,7 +229,7 @@ typedef enum\n   ST_OMP_PARALLEL, ST_OMP_PARALLEL_DO, ST_OMP_PARALLEL_SECTIONS,\n   ST_OMP_PARALLEL_WORKSHARE, ST_OMP_SECTIONS, ST_OMP_SECTION, ST_OMP_SINGLE,\n   ST_OMP_THREADPRIVATE, ST_OMP_WORKSHARE, ST_OMP_TASK, ST_OMP_END_TASK,\n-  ST_OMP_TASKWAIT, ST_PROCEDURE,\n+  ST_OMP_TASKWAIT, ST_PROCEDURE, ST_GENERIC,\n   ST_GET_FCN_CHARACTERISTICS, ST_NONE\n }\n gfc_statement;\n@@ -992,22 +992,49 @@ typedef struct\n gfc_user_op;\n \n \n+/* A list of specific bindings that are associated with a generic spec.  */\n+typedef struct gfc_tbp_generic\n+{\n+  /* The parser sets specific_st, upon resolution we look for the corresponding\n+     gfc_typebound_proc and set specific for further use.  */\n+  struct gfc_symtree* specific_st;\n+  struct gfc_typebound_proc* specific;\n+\n+  struct gfc_tbp_generic* next;\n+}\n+gfc_tbp_generic;\n+\n+#define gfc_get_tbp_generic() XCNEW (gfc_tbp_generic)\n+\n+\n /* Data needed for type-bound procedures.  */\n-typedef struct\n+typedef struct gfc_typebound_proc\n {\n-  struct gfc_symtree* target;\n-  locus where; /* Where the PROCEDURE definition was.  */\n+  locus where; /* Where the PROCEDURE/GENERIC definition was.  */\n+\n+  union\n+  {\n+    struct gfc_symtree* specific;\n+    gfc_tbp_generic* generic;\n+  }\n+  u;\n \n   gfc_access access;\n   char* pass_arg; /* Argument-name for PASS.  NULL if not specified.  */\n \n+  /* The overridden type-bound proc (or GENERIC with this name in the\n+     parent-type) or NULL if non.  */\n+  struct gfc_typebound_proc* overridden;\n+\n   /* Once resolved, we use the position of pass_arg in the formal arglist of\n      the binding-target procedure to identify it.  The first argument has\n      number 1 here, the second 2, and so on.  */\n   unsigned pass_arg_num;\n \n   unsigned nopass:1; /* Whether we have NOPASS (PASS otherwise).  */\n   unsigned non_overridable:1;\n+  unsigned is_generic:1;\n+  unsigned function:1, subroutine:1;\n }\n gfc_typebound_proc;\n \n@@ -1565,7 +1592,9 @@ typedef struct gfc_expr\n     struct\n     {\n       gfc_actual_arglist* actual;\n-      gfc_symtree* tbp;\n+      gfc_typebound_proc* tbp;\n+      gfc_symbol* derived;\n+      const char* name;\n     }\n     compcall;\n \n@@ -2472,6 +2501,7 @@ int gfc_is_compile_time_shape (gfc_array_spec *);\n void gfc_free_interface (gfc_interface *);\n int gfc_compare_derived_types (gfc_symbol *, gfc_symbol *);\n int gfc_compare_types (gfc_typespec *, gfc_typespec *);\n+int gfc_compare_interfaces (gfc_symbol*, gfc_symbol*, int);\n void gfc_check_interfaces (gfc_namespace *);\n void gfc_procedure_use (gfc_symbol *, gfc_actual_arglist **, locus *);\n gfc_symbol *gfc_search_interface (gfc_interface *, int,\n@@ -2483,6 +2513,8 @@ gfc_try gfc_add_interface (gfc_symbol *);\n gfc_interface *gfc_current_interface_head (void);\n void gfc_set_current_interface_head (gfc_interface *);\n gfc_symtree* gfc_find_sym_in_symtree (gfc_symbol*);\n+int gfc_compare_actual_formal (gfc_actual_arglist**, gfc_formal_arglist*,\n+      \t\t\t       int, int, locus*);\n \n /* io.c */\n extern gfc_st_label format_asterisk;"}, {"sha": "9df24ffd33e168d4cf824fca007f2cb66117486e", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -479,7 +479,6 @@ compare_type_rank (gfc_symbol *s1, gfc_symbol *s2)\n }\n \n \n-static int compare_interfaces (gfc_symbol *, gfc_symbol *, int);\n static int compare_intr_interfaces (gfc_symbol *, gfc_symbol *);\n \n /* Given two symbols that are formal arguments, compare their types\n@@ -954,8 +953,8 @@ generic_correspondence (gfc_formal_arglist *f1, gfc_formal_arglist *f2)\n    We return nonzero if there exists an actual argument list that\n    would be ambiguous between the two interfaces, zero otherwise.  */\n \n-static int\n-compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n+int\n+gfc_compare_interfaces (gfc_symbol *s1, gfc_symbol *s2, int generic_flag)\n {\n   gfc_formal_arglist *f1, *f2;\n \n@@ -1173,7 +1172,7 @@ check_interface1 (gfc_interface *p, gfc_interface *q0,\n \tif (p->sym->name == q->sym->name && p->sym->module == q->sym->module)\n \t  continue;\n \n-\tif (compare_interfaces (p->sym, q->sym, generic_flag))\n+\tif (gfc_compare_interfaces (p->sym, q->sym, generic_flag))\n \t  {\n \t    if (referenced)\n \t      {\n@@ -1460,7 +1459,7 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t if (!compare_intr_interfaces (formal, actual->symtree->n.sym))\n \t   goto proc_fail;\n \t}\n-      else if (!compare_interfaces (formal, actual->symtree->n.sym, 0))\n+      else if (!gfc_compare_interfaces (formal, actual->symtree->n.sym, 0))\n \tgoto proc_fail;\n \n       return 1;\n@@ -1819,9 +1818,9 @@ has_vector_subscript (gfc_expr *e)\n    errors when things don't match instead of just returning the status\n    code.  */\n \n-static int\n-compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n-\t\t       int ranks_must_agree, int is_elemental, locus *where)\n+int\n+gfc_compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n+      \t\t\t   int ranks_must_agree, int is_elemental, locus *where)\n {\n   gfc_actual_arglist **new_arg, *a, *actual, temp;\n   gfc_formal_arglist *f;\n@@ -2449,8 +2448,8 @@ gfc_procedure_use (gfc_symbol *sym, gfc_actual_arglist **ap, locus *where)\n       return;\n     }\n \n-  if (!compare_actual_formal (ap, sym->formal, 0,\n-\t\t\t      sym->attr.elemental, where))\n+  if (!gfc_compare_actual_formal (ap, sym->formal, 0,\n+\t\t  \t\t  sym->attr.elemental, where))\n     return;\n \n   check_intents (sym->formal, *ap);\n@@ -2479,7 +2478,7 @@ gfc_search_interface (gfc_interface *intr, int sub_flag,\n \n       r = !intr->sym->attr.elemental;\n \n-      if (compare_actual_formal (ap, intr->sym->formal, r, !r, NULL))\n+      if (gfc_compare_actual_formal (ap, intr->sym->formal, r, !r, NULL))\n \t{\n \t  check_intents (intr->sym->formal, *ap);\n \t  if (gfc_option.warn_aliasing)"}, {"sha": "3b9d3d21d7123d408b9c477bc30160945318fd96", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -2525,6 +2525,7 @@ match_typebound_call (gfc_symtree* varst)\n   base->expr_type = EXPR_VARIABLE;\n   base->symtree = varst;\n   base->where = gfc_current_locus;\n+  gfc_set_sym_referenced (varst->n.sym);\n   \n   m = gfc_match_varspec (base, 0, true);\n   if (m == MATCH_NO)"}, {"sha": "ff9e8a8d174a89edf77bd23ca3b8451af650d051", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -36,6 +36,9 @@ extern gfc_st_label *gfc_statement_label;\n extern int gfc_matching_procptr_assignment;\n extern bool gfc_matching_prefix;\n \n+/* Default access specifier while matching procedure bindings.  */\n+extern gfc_access gfc_typebound_default_access;\n+\n /****************** All gfc_match* routines *****************/\n \n /* match.c.  */\n@@ -141,6 +144,7 @@ match gfc_match_end (gfc_statement *);\n match gfc_match_data_decl (void);\n match gfc_match_formal_arglist (gfc_symbol *, int, int);\n match gfc_match_procedure (void);\n+match gfc_match_generic (void);\n match gfc_match_function_decl (void);\n match gfc_match_entry (void);\n match gfc_match_subroutine (void);"}, {"sha": "c92780386f155d3fc5c79ac3fff9740524a57163", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 43, "deletions": 1, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -1698,6 +1698,12 @@ static const mstring binding_overriding[] =\n     minit (\"NON_OVERRIDABLE\", 1),\n     minit (NULL, -1)\n };\n+static const mstring binding_generic[] =\n+{\n+    minit (\"SPECIFIC\", 0),\n+    minit (\"GENERIC\", 1),\n+    minit (NULL, -1)\n+};\n \n \n /* Specialization of mio_name.  */\n@@ -3189,6 +3195,8 @@ mio_namespace_ref (gfc_namespace **nsp)\n \n /* Save/restore the f2k_derived namespace of a derived-type symbol.  */\n \n+static gfc_namespace* current_f2k_derived;\n+\n static void\n mio_typebound_proc (gfc_typebound_proc** proc)\n {\n@@ -3202,13 +3210,13 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n   gcc_assert (*proc);\n \n   mio_lparen ();\n-  mio_symtree_ref (&(*proc)->target);\n \n   (*proc)->access = MIO_NAME (gfc_access) ((*proc)->access, access_types);\n \n   (*proc)->nopass = mio_name ((*proc)->nopass, binding_passing);\n   (*proc)->non_overridable = mio_name ((*proc)->non_overridable,\n \t\t\t\t       binding_overriding);\n+  (*proc)->is_generic = mio_name ((*proc)->is_generic, binding_generic);\n \n   if (iomode == IO_INPUT)\n     (*proc)->pass_arg = NULL;\n@@ -3217,6 +3225,38 @@ mio_typebound_proc (gfc_typebound_proc** proc)\n   mio_integer (&flag);\n   (*proc)->pass_arg_num = (unsigned) flag;\n \n+  if ((*proc)->is_generic)\n+    {\n+      gfc_tbp_generic* g;\n+\n+      mio_lparen ();\n+\n+      if (iomode == IO_OUTPUT)\n+\tfor (g = (*proc)->u.generic; g; g = g->next)\n+\t  mio_allocated_string (g->specific_st->name);\n+      else\n+\t{\n+\t  (*proc)->u.generic = NULL;\n+\t  while (peek_atom () != ATOM_RPAREN)\n+\t    {\n+\t      g = gfc_get_tbp_generic ();\n+\t      g->specific = NULL;\n+\n+\t      require_atom (ATOM_STRING);\n+\t      gfc_get_sym_tree (atom_string, current_f2k_derived,\n+\t\t\t\t&g->specific_st);\n+\t      gfc_free (atom_string);\n+\n+\t      g->next = (*proc)->u.generic;\n+\t      (*proc)->u.generic = g;\n+\t    }\n+\t}\n+\n+      mio_rparen ();\n+    }\n+  else\n+    mio_symtree_ref (&(*proc)->u.specific);\n+\n   mio_rparen ();\n }\n \n@@ -3260,6 +3300,8 @@ mio_finalizer (gfc_finalizer **f)\n static void\n mio_f2k_derived (gfc_namespace *f2k)\n {\n+  current_f2k_derived = f2k;\n+\n   /* Handle the list of finalizer procedures.  */\n   mio_lparen ();\n   if (iomode == IO_OUTPUT)"}, {"sha": "c5493dff70503f88f174acc5272b71cf55d73792", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -372,6 +372,7 @@ decode_statement (void)\n       break;\n \n     case 'g':\n+      match (\"generic\", gfc_match_generic, ST_GENERIC);\n       match (\"go to\", gfc_match_goto, ST_GOTO);\n       break;\n \n@@ -1195,6 +1196,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_FUNCTION:\n       p = \"FUNCTION\";\n       break;\n+    case ST_GENERIC:\n+      p = \"GENERIC\";\n+      break;\n     case ST_GOTO:\n       p = \"GOTO\";\n       break;\n@@ -1691,21 +1695,10 @@ unexpected_eof (void)\n }\n \n \n-/* Set the default access attribute for a typebound procedure; this is used\n-   as callback for gfc_traverse_symtree.  */\n-\n-static gfc_access typebound_default_access;\n-\n-static void\n-set_typebound_default_access (gfc_symtree* stree)\n-{\n-  if (stree->typebound && stree->typebound->access == ACCESS_UNKNOWN)\n-    stree->typebound->access = typebound_default_access;\n-}\n-\n-\n /* Parse the CONTAINS section of a derived type definition.  */\n \n+gfc_access gfc_typebound_default_access;\n+\n static bool\n parse_derived_contains (void)\n {\n@@ -1730,6 +1723,8 @@ parse_derived_contains (void)\n   accept_statement (ST_CONTAINS);\n   push_state (&s, COMP_DERIVED_CONTAINS, NULL);\n \n+  gfc_typebound_default_access = ACCESS_PUBLIC;\n+\n   to_finish = false;\n   while (!to_finish)\n     {\n@@ -1755,6 +1750,15 @@ parse_derived_contains (void)\n \t  seen_comps = true;\n \t  break;\n \n+\tcase ST_GENERIC:\n+\t  if (gfc_notify_std (GFC_STD_F2003, \"Fortran 2003:  GENERIC binding\"\n+\t\t\t\t\t     \" at %C\") == FAILURE)\n+\t    error_flag = true;\n+\n+\t  accept_statement (ST_GENERIC);\n+\t  seen_comps = true;\n+\t  break;\n+\n \tcase ST_FINAL:\n \t  if (gfc_notify_std (GFC_STD_F2003,\n \t\t\t      \"Fortran 2003:  FINAL procedure declaration\"\n@@ -1801,6 +1805,7 @@ parse_derived_contains (void)\n \t    }\n \n \t  accept_statement (ST_PRIVATE);\n+\t  gfc_typebound_default_access = ACCESS_PRIVATE;\n \t  seen_private = true;\n \t  break;\n \n@@ -1823,12 +1828,6 @@ parse_derived_contains (void)\n   pop_state ();\n   gcc_assert (gfc_current_state () == COMP_DERIVED);\n \n-  /* Walk the parsed type-bound procedures and set ACCESS_UNKNOWN attributes\n-     to PUBLIC or PRIVATE depending on seen_private.  */\n-  typebound_default_access = (seen_private ? ACCESS_PRIVATE : ACCESS_PUBLIC);\n-  gfc_traverse_symtree (gfc_current_block ()->f2k_derived->sym_root,\n-\t\t\t&set_typebound_default_access);\n-\n   return error_flag;\n }\n "}, {"sha": "3a72dda8a992493caf330a5fb845dfe76d0e41db", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -1709,7 +1709,6 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n   gfc_ref *substring, *tail;\n   gfc_component *component;\n   gfc_symbol *sym = primary->symtree->n.sym;\n-  gfc_symtree *tbp;\n   match m;\n   bool unknown;\n \n@@ -1754,6 +1753,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n   for (;;)\n     {\n       gfc_try t;\n+      gfc_symtree *tbp;\n \n       m = gfc_match_name (name);\n       if (m == MATCH_NO)\n@@ -1772,13 +1772,20 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \t  gcc_assert (!tail || !tail->next);\n \t  gcc_assert (primary->expr_type == EXPR_VARIABLE);\n \n-\t  tbp_sym = tbp->typebound->target->n.sym;\n+\t  if (tbp->typebound->is_generic)\n+\t    tbp_sym = NULL;\n+\t  else\n+\t    tbp_sym = tbp->typebound->u.specific->n.sym;\n \n \t  primary->expr_type = EXPR_COMPCALL;\n-\t  primary->value.compcall.tbp = tbp;\n-\t  primary->ts = tbp_sym->ts;\n-\n-\t  m = gfc_match_actual_arglist (tbp_sym->attr.subroutine,\n+\t  primary->value.compcall.tbp = tbp->typebound;\n+\t  primary->value.compcall.derived = sym;\n+\t  primary->value.compcall.name = tbp->name;\n+\t  gcc_assert (primary->symtree->n.sym->attr.referenced);\n+\t  if (tbp_sym)\n+\t    primary->ts = tbp_sym->ts;\n+\n+\t  m = gfc_match_actual_arglist (tbp->typebound->subroutine,\n \t\t\t\t\t&primary->value.compcall.actual);\n \t  if (m == MATCH_ERROR)\n \t    return MATCH_ERROR;\n@@ -1793,16 +1800,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag)\n \t\t}\n \t    }\n \n-\t  if (sub_flag && !tbp_sym->attr.subroutine)\n-\t    {\n-\t      gfc_error (\"'%s' at %C should be a SUBROUTINE\", name);\n-\t      return MATCH_ERROR;\n-\t    }\n-\t  if (!sub_flag && !tbp_sym->attr.function)\n-\t    {\n-\t      gfc_error (\"'%s' at %C should be a FUNCTION\", name);\n-\t      return MATCH_ERROR;\n-\t    }\n+\t  gfc_set_sym_referenced (tbp->n.sym);\n \n \t  break;\n \t}"}, {"sha": "440461c82a87337b0e0baff9cd7071073552d2cd", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 313, "deletions": 14, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -4306,24 +4306,42 @@ update_arglist_pass (gfc_actual_arglist* lst, gfc_expr* po, unsigned argpos)\n }\n \n \n-/* Update the arglist of an EXPR_COMPCALL expression to include the\n-   passed-object.  */\n+/* Extract the passed-object from an EXPR_COMPCALL (a copy of it).  */\n \n-static gfc_try\n-update_compcall_arglist (gfc_expr* e)\n+static gfc_expr*\n+extract_compcall_passed_object (gfc_expr* e)\n {\n   gfc_expr* po;\n-  gfc_typebound_proc* tbp;\n \n-  tbp = e->value.compcall.tbp->typebound;\n+  gcc_assert (e->expr_type == EXPR_COMPCALL);\n \n   po = gfc_get_expr ();\n   po->expr_type = EXPR_VARIABLE;\n   po->symtree = e->symtree;\n   po->ref = gfc_copy_ref (e->ref);\n \n   if (gfc_resolve_expr (po) == FAILURE)\n+    return NULL;\n+\n+  return po;\n+}\n+\n+\n+/* Update the arglist of an EXPR_COMPCALL expression to include the\n+   passed-object.  */\n+\n+static gfc_try\n+update_compcall_arglist (gfc_expr* e)\n+{\n+  gfc_expr* po;\n+  gfc_typebound_proc* tbp;\n+\n+  tbp = e->value.compcall.tbp;\n+\n+  po = extract_compcall_passed_object (e);\n+  if (!po)\n     return FAILURE;\n+\n   if (po->rank > 0)\n     {\n       gfc_error (\"Passed-object at %L must be scalar\", &e->where);\n@@ -4353,13 +4371,14 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n \t\t\t  gfc_actual_arglist** actual)\n {\n   gcc_assert (e->expr_type == EXPR_COMPCALL);\n+  gcc_assert (!e->value.compcall.tbp->is_generic);\n \n   /* Update the actual arglist for PASS.  */\n   if (update_compcall_arglist (e) == FAILURE)\n     return FAILURE;\n \n   *actual = e->value.compcall.actual;\n-  *target = e->value.compcall.tbp->typebound->target;\n+  *target = e->value.compcall.tbp->u.specific;\n \n   gfc_free_ref_list (e->ref);\n   e->ref = NULL;\n@@ -4369,6 +4388,74 @@ resolve_typebound_static (gfc_expr* e, gfc_symtree** target,\n }\n \n \n+/* Given an EXPR_COMPCALL calling a GENERIC typebound procedure, figure out\n+   which of the specific bindings (if any) matches the arglist and transform\n+   the expression into a call of that binding.  */\n+\n+static gfc_try\n+resolve_typebound_generic_call (gfc_expr* e)\n+{\n+  gfc_typebound_proc* genproc;\n+  const char* genname;\n+\n+  gcc_assert (e->expr_type == EXPR_COMPCALL);\n+  genname = e->value.compcall.name;\n+  genproc = e->value.compcall.tbp;\n+\n+  if (!genproc->is_generic)\n+    return SUCCESS;\n+\n+  /* Try the bindings on this type and in the inheritance hierarchy.  */\n+  for (; genproc; genproc = genproc->overridden)\n+    {\n+      gfc_tbp_generic* g;\n+\n+      gcc_assert (genproc->is_generic);\n+      for (g = genproc->u.generic; g; g = g->next)\n+\t{\n+\t  gfc_symbol* target;\n+\t  gfc_actual_arglist* args;\n+\t  bool matches;\n+\n+\t  gcc_assert (g->specific);\n+\t  target = g->specific->u.specific->n.sym;\n+\n+\t  /* Get the right arglist by handling PASS/NOPASS.  */\n+\t  args = gfc_copy_actual_arglist (e->value.compcall.actual);\n+\t  if (!g->specific->nopass)\n+\t    {\n+\t      gfc_expr* po;\n+\t      po = extract_compcall_passed_object (e);\n+\t      if (!po)\n+\t\treturn FAILURE;\n+\n+\t      args = update_arglist_pass (args, po, g->specific->pass_arg_num);\n+\t    }\n+\n+\t  /* Check if this arglist matches the formal.  */\n+\t  matches = gfc_compare_actual_formal (&args, target->formal, 1,\n+\t\t\t\t\t       target->attr.elemental, NULL);\n+\n+\t  /* Clean up and break out of the loop if we've found it.  */\n+\t  gfc_free_actual_arglist (args);\n+\t  if (matches)\n+\t    {\n+\t      e->value.compcall.tbp = g->specific;\n+\t      goto success;\n+\t    }\n+\t}\n+    }\n+\n+  /* Nothing matching found!  */\n+  gfc_error (\"Found no matching specific binding for the call to the GENERIC\"\n+\t     \" '%s' at %L\", genname, &e->where);\n+  return FAILURE;\n+\n+success:\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve a call to a type-bound subroutine.  */\n \n static gfc_try\n@@ -4377,6 +4464,17 @@ resolve_typebound_call (gfc_code* c)\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n \n+  /* Check that's really a SUBROUTINE.  */\n+  if (!c->expr->value.compcall.tbp->subroutine)\n+    {\n+      gfc_error (\"'%s' at %L should be a SUBROUTINE\",\n+\t\t c->expr->value.compcall.name, &c->loc);\n+      return FAILURE;\n+    }\n+\n+  if (resolve_typebound_generic_call (c->expr) == FAILURE)\n+    return FAILURE;\n+\n   /* Transform into an ordinary EXEC_CALL for now.  */\n \n   if (resolve_typebound_static (c->expr, &target, &newactual) == FAILURE)\n@@ -4402,13 +4500,27 @@ resolve_compcall (gfc_expr* e)\n   gfc_actual_arglist* newactual;\n   gfc_symtree* target;\n \n-  /* For now, we simply transform it into a EXPR_FUNCTION call with the same\n+  /* Check that's really a FUNCTION.  */\n+  if (!e->value.compcall.tbp->function)\n+    {\n+      gfc_error (\"'%s' at %L should be a FUNCTION\",\n+\t\t e->value.compcall.name, &e->where);\n+      return FAILURE;\n+    }\n+\n+  if (resolve_typebound_generic_call (e) == FAILURE)\n+    return FAILURE;\n+\n+  /* For now, we simply transform it into an EXPR_FUNCTION call with the same\n      arglist to the TBP's binding target.  */\n \n   if (resolve_typebound_static (e, &target, &newactual) == FAILURE)\n     return FAILURE;\n \n   e->value.function.actual = newactual;\n+  e->value.function.name = e->value.compcall.name;\n+  e->value.function.isym = NULL;\n+  e->value.function.esym = NULL;\n   e->symtree = target;\n   e->expr_type = EXPR_FUNCTION;\n \n@@ -7771,9 +7883,20 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n   gfc_formal_arglist* proc_formal;\n   gfc_formal_arglist* old_formal;\n \n+  /* This procedure should only be called for non-GENERIC proc.  */\n+  gcc_assert (!proc->typebound->is_generic);\n+\n+  /* If the overwritten procedure is GENERIC, this is an error.  */\n+  if (old->typebound->is_generic)\n+    {\n+      gfc_error (\"Can't overwrite GENERIC '%s' at %L\",\n+\t\t old->name, &proc->typebound->where);\n+      return FAILURE;\n+    }\n+\n   where = proc->typebound->where;\n-  proc_target = proc->typebound->target->n.sym;\n-  old_target = old->typebound->target->n.sym;\n+  proc_target = proc->typebound->u.specific->n.sym;\n+  old_target = old->typebound->u.specific->n.sym;\n \n   /* Check that overridden binding is not NON_OVERRIDABLE.  */\n   if (old->typebound->non_overridable)\n@@ -7933,6 +8056,161 @@ check_typebound_override (gfc_symtree* proc, gfc_symtree* old)\n }\n \n \n+/* Check if two GENERIC targets are ambiguous and emit an error is they are.  */\n+\n+static gfc_try\n+check_generic_tbp_ambiguity (gfc_tbp_generic* t1, gfc_tbp_generic* t2,\n+\t\t\t     const char* generic_name, locus where)\n+{\n+  gfc_symbol* sym1;\n+  gfc_symbol* sym2;\n+\n+  gcc_assert (t1->specific && t2->specific);\n+  gcc_assert (!t1->specific->is_generic);\n+  gcc_assert (!t2->specific->is_generic);\n+\n+  sym1 = t1->specific->u.specific->n.sym;\n+  sym2 = t2->specific->u.specific->n.sym;\n+\n+  /* Both must be SUBROUTINEs or both must be FUNCTIONs.  */\n+  if (sym1->attr.subroutine != sym2->attr.subroutine\n+      || sym1->attr.function != sym2->attr.function)\n+    {\n+      gfc_error (\"'%s' and '%s' can't be mixed FUNCTION/SUBROUTINE for\"\n+\t\t \" GENERIC '%s' at %L\",\n+\t\t sym1->name, sym2->name, generic_name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* Compare the interfaces.  */\n+  if (gfc_compare_interfaces (sym1, sym2, 1))\n+    {\n+      gfc_error (\"'%s' and '%s' for GENERIC '%s' at %L are ambiguous\",\n+\t\t sym1->name, sym2->name, generic_name, &where);\n+      return FAILURE;\n+    }\n+\n+  return SUCCESS;\n+}\n+\n+\n+/* Resolve a GENERIC procedure binding for a derived type.  */\n+\n+static gfc_try\n+resolve_typebound_generic (gfc_symbol* derived, gfc_symtree* st)\n+{\n+  gfc_tbp_generic* target;\n+  gfc_symtree* first_target;\n+  gfc_symbol* super_type;\n+  gfc_symtree* inherited;\n+  locus where;\n+\n+  gcc_assert (st->typebound);\n+  gcc_assert (st->typebound->is_generic);\n+\n+  where = st->typebound->where;\n+  super_type = gfc_get_derived_super_type (derived);\n+\n+  /* Find the overridden binding if any.  */\n+  st->typebound->overridden = NULL;\n+  if (super_type)\n+    {\n+      gfc_symtree* overridden;\n+      overridden = gfc_find_typebound_proc (super_type, NULL, st->name, true);\n+\n+      if (overridden && overridden->typebound)\n+\tst->typebound->overridden = overridden->typebound;\n+    }\n+\n+  /* Try to find the specific bindings for the symtrees in our target-list.  */\n+  gcc_assert (st->typebound->u.generic);\n+  for (target = st->typebound->u.generic; target; target = target->next)\n+    if (!target->specific)\n+      {\n+\tgfc_typebound_proc* overridden_tbp;\n+\tgfc_tbp_generic* g;\n+\tconst char* target_name;\n+\n+\ttarget_name = target->specific_st->name;\n+\n+\t/* Defined for this type directly.  */\n+\tif (target->specific_st->typebound)\n+\t  {\n+\t    target->specific = target->specific_st->typebound;\n+\t    goto specific_found;\n+\t  }\n+\n+\t/* Look for an inherited specific binding.  */\n+\tif (super_type)\n+\t  {\n+\t    inherited = gfc_find_typebound_proc (super_type, NULL,\n+\t\t\t\t\t\t target_name, true);\n+\n+\t    if (inherited)\n+\t      {\n+\t\tgcc_assert (inherited->typebound);\n+\t\ttarget->specific = inherited->typebound;\n+\t\tgoto specific_found;\n+\t      }\n+\t  }\n+\n+\tgfc_error (\"Undefined specific binding '%s' as target of GENERIC '%s'\"\n+\t\t   \" at %L\", target_name, st->name, &where);\n+\treturn FAILURE;\n+\n+\t/* Once we've found the specific binding, check it is not ambiguous with\n+\t   other specifics already found or inherited for the same GENERIC.  */\n+specific_found:\n+\tgcc_assert (target->specific);\n+\n+\t/* This must really be a specific binding!  */\n+\tif (target->specific->is_generic)\n+\t  {\n+\t    gfc_error (\"GENERIC '%s' at %L must target a specific binding,\"\n+\t\t       \" '%s' is GENERIC, too\", st->name, &where, target_name);\n+\t    return FAILURE;\n+\t  }\n+\n+\t/* Check those already resolved on this type directly.  */\n+\tfor (g = st->typebound->u.generic; g; g = g->next)\n+\t  if (g != target && g->specific\n+\t      && check_generic_tbp_ambiguity (target, g, st->name, where)\n+\t\t  == FAILURE)\n+\t    return FAILURE;\n+\n+\t/* Check for ambiguity with inherited specific targets.  */\n+\tfor (overridden_tbp = st->typebound->overridden; overridden_tbp;\n+\t     overridden_tbp = overridden_tbp->overridden)\n+\t  if (overridden_tbp->is_generic)\n+\t    {\n+\t      for (g = overridden_tbp->u.generic; g; g = g->next)\n+\t\t{\n+\t\t  gcc_assert (g->specific);\n+\t\t  if (check_generic_tbp_ambiguity (target, g,\n+\t\t\t\t\t\t   st->name, where) == FAILURE)\n+\t\t    return FAILURE;\n+\t\t}\n+\t    }\n+      }\n+\n+  /* If we attempt to \"overwrite\" a specific binding, this is an error.  */\n+  if (st->typebound->overridden && !st->typebound->overridden->is_generic)\n+    {\n+      gfc_error (\"GENERIC '%s' at %L can't overwrite specific binding with\"\n+\t\t \" the same name\", st->name, &where);\n+      return FAILURE;\n+    }\n+\n+  /* Take the SUBROUTINE/FUNCTION attributes of the first specific target, as\n+     all must have the same attributes here.  */\n+  first_target = st->typebound->u.generic->specific->u.specific;\n+  st->typebound->subroutine = first_target->n.sym->attr.subroutine;\n+  st->typebound->function = first_target->n.sym->attr.function;\n+\n+  return SUCCESS;\n+}\n+\n+\n /* Resolve the type-bound procedures for a derived type.  */\n \n static gfc_symbol* resolve_bindings_derived;\n@@ -7951,9 +8229,19 @@ resolve_typebound_procedure (gfc_symtree* stree)\n   if (!stree->typebound)\n     return;\n \n+  /* If this is a GENERIC binding, use that routine.  */\n+  if (stree->typebound->is_generic)\n+    {\n+      if (resolve_typebound_generic (resolve_bindings_derived, stree)\n+\t    == FAILURE)\n+\tgoto error;\n+      return;\n+    }\n+\n   /* Get the target-procedure to check it.  */\n-  gcc_assert (stree->typebound->target);\n-  proc = stree->typebound->target->n.sym;\n+  gcc_assert (!stree->typebound->is_generic);\n+  gcc_assert (stree->typebound->u.specific);\n+  proc = stree->typebound->u.specific->n.sym;\n   where = stree->typebound->where;\n \n   /* Default access should already be resolved from the parser.  */\n@@ -7970,14 +8258,17 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t\t \" an explicit interface at %L\", proc->name, &where);\n       goto error;\n     }\n+  stree->typebound->subroutine = proc->attr.subroutine;\n+  stree->typebound->function = proc->attr.function;\n \n   /* Find the super-type of the current derived type.  We could do this once and\n      store in a global if speed is needed, but as long as not I believe this is\n      more readable and clearer.  */\n   super_type = gfc_get_derived_super_type (resolve_bindings_derived);\n \n-  /* If PASS, resolve and check arguments.  */\n-  if (!stree->typebound->nopass)\n+  /* If PASS, resolve and check arguments if not already resolved / loaded\n+     from a .mod file.  */\n+  if (!stree->typebound->nopass && stree->typebound->pass_arg_num == 0)\n     {\n       if (stree->typebound->pass_arg)\n \t{\n@@ -8039,12 +8330,16 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \n   /* If we are extending some type, check that we don't override a procedure\n      flagged NON_OVERRIDABLE.  */\n+  stree->typebound->overridden = NULL;\n   if (super_type)\n     {\n       gfc_symtree* overridden;\n       overridden = gfc_find_typebound_proc (super_type, NULL,\n \t\t\t\t\t    stree->name, true);\n \n+      if (overridden && overridden->typebound)\n+\tstree->typebound->overridden = overridden->typebound;\n+\n       if (overridden && check_typebound_override (stree, overridden) == FAILURE)\n \tgoto error;\n     }\n@@ -8121,6 +8416,10 @@ resolve_fl_derived (gfc_symbol *sym)\n \n   super_type = gfc_get_derived_super_type (sym);\n \n+  /* Ensure the extended type gets resolved before we do.  */\n+  if (super_type && resolve_fl_derived (super_type) == FAILURE)\n+    return FAILURE;\n+\n   for (c = sym->components; c != NULL; c = c->next)\n     {\n       /* If this type is an extension, see if this component has the same name"}, {"sha": "18f1b6d91c44c993a419fc8a416a30fb7092d714", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -109,7 +109,6 @@ gfc_free_statement (gfc_code *p)\n       break;\n \n     case EXEC_COMPCALL:\n-      gfc_free_expr (p->expr);\n     case EXEC_CALL:\n     case EXEC_ASSIGN_CALL:\n       gfc_free_actual_arglist (p->ext.actual);"}, {"sha": "5b7db4c75ea775ce7b1c5193477eee4a735bcf8d", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -4279,11 +4279,8 @@ gfc_find_typebound_proc (gfc_symbol* derived, gfc_try* t,\n   /* Try to find it in the current type's namespace.  */\n   gcc_assert (derived->f2k_derived);\n   res = gfc_find_symtree (derived->f2k_derived->sym_root, name);\n-  if (res)\n+  if (res && res->typebound)\n     {\n-      if (!res->typebound)\n-\treturn NULL;\n-\n       /* We found one.  */\n       if (t)\n \t*t = SUCCESS;"}, {"sha": "647714a88b36251d280fcf162b332478c4d7dcfa", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -1,3 +1,9 @@\n+2008-08-31  Daniel Kraft  <d@domob.eu>\n+\n+\t* gfortran.dg/typebound_generic_1.f03: New test.\n+\t* gfortran.dg/typebound_generic_2.f03: New test.\n+\t* gfortran.dg/typebound_generic_3.f03: New test.\n+\n 2008-08-30  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \tPR middle-end/36444"}, {"sha": "08303557cf7e1407ed04356e2fb066d9668b30db", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_1.f03", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_1.f03?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -0,0 +1,95 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Compiling and errors with GENERIC binding declarations.\n+! Bindings with NOPASS.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE somet\n+  CONTAINS\n+    PROCEDURE, NOPASS :: p1 => intf1\n+    PROCEDURE, NOPASS :: p1a => intf1a\n+    PROCEDURE, NOPASS :: p2 => intf2\n+    PROCEDURE, NOPASS :: p3 => intf3\n+    PROCEDURE, NOPASS :: subr\n+\n+    GENERIC :: gen1 => p1a ! { dg-error \"are ambiguous\" }\n+\n+    GENERIC, PUBLIC :: gen1 => p1, p2\n+    GENERIC :: gen1 => p3 ! Implicitelly PUBLIC.\n+    GENERIC, PRIVATE :: gen2 => p1\n+\n+    GENERIC :: gen2 => p2 ! { dg-error \"same access\" }\n+    GENERIC :: gen1 => p1 ! { dg-error \"already defined as specific binding\" }\n+    GENERIC, PASS :: gen3 => p1 ! { dg-error \"Expected access-specifier\" }\n+    GENERIC :: p1 => p1 ! { dg-error \"already a non-generic procedure\" }\n+    PROCEDURE, NOPASS :: gen1 => intf1 ! { dg-error \"already a procedure\" }\n+    GENERIC :: gen3 => ! { dg-error \"specific binding\" }\n+    GENERIC :: gen4 => p1 x ! { dg-error \"Junk after\" }\n+    GENERIC :: gen4 => p_notthere ! { dg-error \"Undefined specific binding\" }\n+    GENERIC :: gen5 => gen1 ! { dg-error \"must target a specific binding\" }\n+\n+    GENERIC :: gensubr => p2 ! { dg-error \"mixed FUNCTION/SUBROUTINE\" }\n+    GENERIC :: gensubr => subr\n+\n+  END TYPE somet\n+\n+  TYPE supert\n+  CONTAINS\n+    PROCEDURE, NOPASS :: p1 => intf1\n+    PROCEDURE, NOPASS :: p1a => intf1a\n+    PROCEDURE, NOPASS :: p2 => intf2\n+    PROCEDURE, NOPASS :: p3 => intf3\n+    PROCEDURE, NOPASS :: sub1 => subr\n+\n+    GENERIC :: gen1 => p1, p2\n+    GENERIC :: gen1 => p3\n+    GENERIC :: gen2 => p1\n+    GENERIC :: gensub => sub1\n+  END TYPE supert\n+\n+  TYPE, EXTENDS(supert) :: t\n+  CONTAINS\n+    GENERIC :: gen2 => p1a ! { dg-error \"are ambiguous\" }\n+    GENERIC :: gen2 => p3\n+    GENERIC :: p1 => p2 ! { dg-error \"can't overwrite specific\" }\n+    GENERIC :: gensub => p2 ! { dg-error \"mixed FUNCTION/SUBROUTINE\" }\n+\n+    PROCEDURE, NOPASS :: gen1 => intf1 ! { dg-error \"Can't overwrite GENERIC\" }\n+  END TYPE t\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION intf1 (a, b)\n+    IMPLICIT NONE\n+    INTEGER :: a, b\n+    intf1 = 42\n+  END FUNCTION intf1\n+\n+  INTEGER FUNCTION intf1a (a, b)\n+    IMPLICIT NONE\n+    INTEGER :: a, b\n+    intf1a = 42\n+  END FUNCTION intf1a\n+\n+  INTEGER FUNCTION intf2 (a, b)\n+    IMPLICIT NONE\n+    REAL :: a, b\n+    intf2 = 42.0\n+  END FUNCTION intf2\n+\n+  LOGICAL FUNCTION intf3 ()\n+    IMPLICIT NONE\n+    intf3 = .TRUE.\n+  END FUNCTION intf3\n+\n+  SUBROUTINE subr (x)\n+    IMPLICIT NONE\n+    INTEGER :: x\n+  END SUBROUTINE subr\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "c18b306b906a6dac833486d673357a70bf47e7ad", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_2.f03", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_2.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_2.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_2.f03?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do compile }\n+\n+! Type-bound procedures\n+! Check for errors with calls to GENERIC bindings and their module IO.\n+! Calls with NOPASS.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE supert\n+  CONTAINS\n+    PROCEDURE, NOPASS :: func_int\n+    PROCEDURE, NOPASS :: sub_int\n+    GENERIC :: func => func_int\n+    GENERIC :: sub => sub_int\n+  END TYPE supert\n+\n+  TYPE, EXTENDS(supert) :: t\n+  CONTAINS\n+    PROCEDURE, NOPASS :: func_real\n+    GENERIC :: func => func_real\n+  END TYPE t\n+\n+CONTAINS\n+\n+  INTEGER FUNCTION func_int (x)\n+    IMPLICIT NONE\n+    INTEGER :: x\n+    func_int = x\n+  END FUNCTION func_int\n+\n+  INTEGER FUNCTION func_real (x)\n+    IMPLICIT NONE\n+    REAL :: x\n+    func_real = INT(x * 4.2)\n+  END FUNCTION func_real\n+\n+  SUBROUTINE sub_int (x)\n+    IMPLICIT NONE\n+    INTEGER :: x\n+  END SUBROUTINE sub_int\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+\n+  TYPE(t) :: myobj\n+\n+  ! These are ok.\n+  CALL myobj%sub (1)\n+  WRITE (*,*) myobj%func (1)\n+  WRITE (*,*) myobj%func (2.5)\n+\n+  ! These are not.\n+  CALL myobj%sub (2.5) ! { dg-error \"no matching specific binding\" }\n+  WRITE (*,*) myobj%func (\"hello\") ! { dg-error \"no matching specific binding\" }\n+  CALL myobj%func (2.5) ! { dg-error \"SUBROUTINE\" }\n+  WRITE (*,*) myobj%sub (1) ! { dg-error \"FUNCTION\" }\n+\n+END PROGRAM main\n+\n+! { dg-final { cleanup-modules \"m\" } }"}, {"sha": "fc56574097632d0790d50bbf84280b3f49eb990a", "filename": "gcc/testsuite/gfortran.dg/typebound_generic_3.f03", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e157f73660e50bd02f5c2c6d94624de70303e579/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_generic_3.f03?ref=e157f73660e50bd02f5c2c6d94624de70303e579", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do run }\n+\n+! FIXME: Remove -w once switched to polymorphic passed-object dummy arguments.\n+! { dg-options \"-w\" }\n+\n+! Type-bound procedures\n+! Check calls with GENERIC bindings.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t\n+  CONTAINS\n+    PROCEDURE, NOPASS :: plain_int\n+    PROCEDURE, NOPASS :: plain_real\n+    PROCEDURE, PASS(me) :: passed_intint\n+    PROCEDURE, PASS(me) :: passed_realreal\n+\n+    GENERIC :: gensub => plain_int, plain_real, passed_intint, passed_realreal\n+  END TYPE t\n+\n+CONTAINS\n+\n+  SUBROUTINE plain_int (x)\n+    IMPLICIT NONE\n+    INTEGER :: x\n+    WRITE (*,*) \"Plain Integer\"\n+  END SUBROUTINE plain_int\n+\n+  SUBROUTINE plain_real (x)\n+    IMPLICIT NONE\n+    REAL :: x\n+    WRITE (*,*) \"Plain Real\"\n+  END SUBROUTINE plain_real\n+\n+  SUBROUTINE passed_intint (me, x, y)\n+    IMPLICIT NONE\n+    TYPE(t) :: me\n+    INTEGER :: x, y\n+    WRITE (*,*) \"Passed Integer\"\n+  END SUBROUTINE passed_intint\n+\n+  SUBROUTINE passed_realreal (x, me, y)\n+    IMPLICIT NONE\n+    REAL :: x, y\n+    TYPE(t) :: me\n+    WRITE (*,*) \"Passed Real\"\n+  END SUBROUTINE passed_realreal\n+\n+END MODULE m\n+\n+PROGRAM main\n+  USE m\n+  IMPLICIT NONE\n+\n+  TYPE(t) :: myobj\n+\n+  CALL myobj%gensub (5)\n+  CALL myobj%gensub (2.5)\n+  CALL myobj%gensub (5, 5)\n+  CALL myobj%gensub (2.5, 2.5)\n+END PROGRAM main\n+\n+! { dg-output \"Plain Integer(\\n|\\r\\n|\\r).*Plain Real(\\n|\\r\\n|\\r).*Passed Integer(\\n|\\r\\n|\\r).*Passed Real\" }\n+! { dg-final { cleanup-modules \"m\" } }"}]}