{"sha": "3fdc651fed8f150778148b0409c0d2852f8b571a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2ZkYzY1MWZlZDhmMTUwNzc4MTQ4YjA0MDljMGQyODUyZjhiNTcxYQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-03-16T13:10:15Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1999-03-16T13:10:15Z"}, "message": "cppfiles.c (read_and_prescan): Map backslash-newline to '\\r' (which cannot otherwise appear in the processed...\n\n1999-03-16 16:06 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cppfiles.c (read_and_prescan): Map backslash-newline to '\\r'\n\t(which cannot otherwise appear in the processed buffer) and\n\tmove it out of tokens that it appears in the middle of.\n\tImprove performance.\n\t(find_position): New function.\n\t* cpplib.c: \\r (one character) indicates backslash\n\tnewline, not \\\\\\n (two characters).  It cannot appear in the\n\tmiddle of a token.  Call CPP_BUMP_LINE (pfile) whenever\n\tparsing moves past \\n or \\r.  Increment pfile->lineno whenever\n\ta \\n is placed into token_buffer.  Only one mark can exist at\n\ta time, and CPP_BUMP_LINE must not be used while it is\n\tactive.  It is automatically cleared by cpp_pop_buffer and\n\tparse_goto_mark.  \\r is not in is_hor_space or is_space.\n\t(NEWLINE_FIX, NEWLINE_FIX1, adjust_position,\n\tupdate_position, count_newlines, parse_move_mark): Removed.\n\t(parse_string, copy_comment): New functions.\n\t(parse_name): Returns void.\n\t(parse_set_mark, parse_clear_mark, parse_goto_mark): Take only\n\tone argument, a cpp_reader *.  Change for new marking scheme.\n\t(skip_comment): Handle CHILL line comments too.  Second\n\targument is now first character of comment marker; all callers\n\tchanged.  Issue error for unterminated block comment here.\n\t(cpp_skip_hspace): Recognize CHILL comments.\n\t(copy_rest_of_line): Likewise.  Call skip_comment and\n\tparse_string directly, don't go through cpp_get_token.  Emit\n\t\"/**/\" for block comments if -traditional (create_definition\n\tneeds this).\n\t(do_define): Don't play with put_out_comments.\n\t(cpp_push_buffer): Initialize ->mark to -1.\n\t(cpp_buf_line_and_col): Just read out the values in the buffer\n\tstructure.\n\t(output_line_command): Use cpp_buf_line_and_col.  Fix\n\tformatting.  Remove stale code.\n\t(cpp_get_token): Break out string parsing code to\n\tparse_string.  Use skip_comment for CHILL comments too.  Use\n\tcopy_comment for put_out_comments instead of dinking with\n\tmarks.  Remove stale code.  Don't call output_line_command\n\tunless it's necessary.\n\t* cpplib.h (parse_marker): Removed.\n\t(struct cpp_buffer): line_base is now a unsigned char *; add\n\t`mark' [long], remove `marks' [struct parse_marker *].\n\t(parse_set_mark, parse_clear_mark, parse_goto_mark): Update\n\tprototypes.\n\t(CPP_BUMP_LINE, CPP_BUMP_BUFFER_LINE): New macros.\n\t* cppinit.c (is_hor_space, is_space): '\\r' is not considered\n\twhitespace.\n\t* cppexp.c (cpp_parse_expression): Use cpp_skip_hspace, not\n\tSKIP_WHITE_SPACE.\n\t* cpphash.c (macarg): Disable line commands while expanding.\n\nFrom-SVN: r25802", "tree": {"sha": "aca71f4d74eba9693f38e9c8c1736e1b2c31167f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aca71f4d74eba9693f38e9c8c1736e1b2c31167f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3fdc651fed8f150778148b0409c0d2852f8b571a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fdc651fed8f150778148b0409c0d2852f8b571a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3fdc651fed8f150778148b0409c0d2852f8b571a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3fdc651fed8f150778148b0409c0d2852f8b571a/comments", "author": null, "committer": null, "parents": [{"sha": "d888cbc4929b8825f434502d245c5ad93509502a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d888cbc4929b8825f434502d245c5ad93509502a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d888cbc4929b8825f434502d245c5ad93509502a"}], "stats": {"total": 1249, "additions": 666, "deletions": 583}, "files": [{"sha": "f697c1ce4615f19cfe1c2d5a5da755c6389b2f7e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -1,3 +1,58 @@\n+1999-03-16 16:06 -0500  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cppfiles.c (read_and_prescan): Map backslash-newline to '\\r'\n+\t(which cannot otherwise appear in the processed buffer) and\n+\tmove it out of tokens that it appears in the middle of.\n+\tImprove performance.\n+\t(find_position): New function.\n+\n+\t* cpplib.c: \\r (one character) indicates backslash\n+\tnewline, not \\\\\\n (two characters).  It cannot appear in the\n+\tmiddle of a token.  Call CPP_BUMP_LINE (pfile) whenever\n+\tparsing moves past \\n or \\r.  Increment pfile->lineno whenever\n+\ta \\n is placed into token_buffer.  Only one mark can exist at\n+\ta time, and CPP_BUMP_LINE must not be used while it is\n+\tactive.  It is automatically cleared by cpp_pop_buffer and\n+\tparse_goto_mark.  \\r is not in is_hor_space or is_space.\n+\n+\t(NEWLINE_FIX, NEWLINE_FIX1, adjust_position,\n+\tupdate_position, count_newlines, parse_move_mark): Removed.\n+\t(parse_string, copy_comment): New functions.\n+\t(parse_name): Returns void.\n+\t(parse_set_mark, parse_clear_mark, parse_goto_mark): Take only\n+\tone argument, a cpp_reader *.  Change for new marking scheme.\n+\t(skip_comment): Handle CHILL line comments too.  Second\n+\targument is now first character of comment marker; all callers\n+\tchanged.  Issue error for unterminated block comment here.\n+\t(cpp_skip_hspace): Recognize CHILL comments.\n+\t(copy_rest_of_line): Likewise.  Call skip_comment and\n+\tparse_string directly, don't go through cpp_get_token.  Emit\n+\t\"/**/\" for block comments if -traditional (create_definition\n+\tneeds this).\n+\t(do_define): Don't play with put_out_comments.\n+\t(cpp_push_buffer): Initialize ->mark to -1.\n+\t(cpp_buf_line_and_col): Just read out the values in the buffer\n+\tstructure.\n+\t(output_line_command): Use cpp_buf_line_and_col.  Fix\n+\tformatting.  Remove stale code.\n+\t(cpp_get_token): Break out string parsing code to\n+\tparse_string.  Use skip_comment for CHILL comments too.  Use\n+\tcopy_comment for put_out_comments instead of dinking with\n+\tmarks.  Remove stale code.  Don't call output_line_command\n+\tunless it's necessary.\n+\n+\t* cpplib.h (parse_marker): Removed.\n+\t(struct cpp_buffer): line_base is now a unsigned char *; add\n+\t`mark' [long], remove `marks' [struct parse_marker *].\n+\t(parse_set_mark, parse_clear_mark, parse_goto_mark): Update\n+\tprototypes.\n+\t(CPP_BUMP_LINE, CPP_BUMP_BUFFER_LINE): New macros.\n+\t* cppinit.c (is_hor_space, is_space): '\\r' is not considered\n+\twhitespace.\n+\t* cppexp.c (cpp_parse_expression): Use cpp_skip_hspace, not\n+\tSKIP_WHITE_SPACE.\n+\t* cpphash.c (macarg): Disable line commands while expanding.\n+\n Tue Mar 16 11:30:19 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \t* c-lex.c (yylex) : Remove warning for integer literals being"}, {"sha": "eaec4686d7590ad84eed8ddf76adf83147558456", "filename": "gcc/cppexp.c", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -101,8 +101,6 @@ static HOST_WIDEST_INT right_shift PARAMS ((cpp_reader *, HOST_WIDEST_INT, int,\n #define SKIP_OPERAND 8\n /*#define UNSIGNEDP 16*/\n \n-#define SKIP_WHITE_SPACE(p) do { while (is_hor_space[*p]) p++; } while (0)\n-\n struct operation {\n     short op;\n     char rprio; /* Priority of op (relative to it right operand).  */\n@@ -444,12 +442,12 @@ cpp_lex (pfile, skip_evaluation)\n \t  cpp_buffer *ip = CPP_BUFFER (pfile);\n \t  U_CHAR *tok;\n \n-\t  SKIP_WHITE_SPACE (ip->cur);\n+\t  cpp_skip_hspace (pfile);\n \t  if (*ip->cur == '(')\n \t    {\n \t      paren++;\n \t      ip->cur++;\t\t\t/* Skip over the paren */\n-\t      SKIP_WHITE_SPACE (ip->cur);\n+\t      cpp_skip_hspace (pfile);\n \t    }\n \n \t  if (!is_idstart[*ip->cur])\n@@ -460,7 +458,7 @@ cpp_lex (pfile, skip_evaluation)\n \t  while (is_idchar[*ip->cur])\n \t    ++ip->cur;\n \t  len = ip->cur - tok;\n-\t  SKIP_WHITE_SPACE (ip->cur);\n+\t  cpp_skip_hspace (pfile);\n \t  if (paren)\n \t    {\n \t      if (*ip->cur != ')')"}, {"sha": "7828569c0dd233f4d38f478fcb5992c023c4f060", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 221, "deletions": 104, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -757,15 +757,51 @@ actual_directory (pfile, fname)\n   return x;\n }\n \n-/* Read the entire contents of file DESC into buffer BUF, convert end-of-line\n-   markers to canonical form, and convert trigraphs if enabled.  Also, make\n-   sure there is a newline at the end of the file.  LEN is how much room we\n-   have to start with (this can be expanded if necessary).\n-   Returns -1 on failure, or the actual length of the data to be scanned.\n+/* Almost but not quite the same as adjust_position in cpplib.c.\n+   Used only by read_and_prescan. */\n+static void\n+find_position (start, limit, linep, colp)\n+     U_CHAR *start;\n+     U_CHAR *limit;\n+     long *linep;\n+     long *colp;\n+{\n+  long line = *linep, col = 0;\n+  while (start < limit)\n+    {\n+      U_CHAR ch = *start++;\n+      if (ch == '\\n' || ch == '\\r')\n+\tline++, col = 1;\n+      else\n+\tcol++;\n+    }\n+  *linep = line, *colp = col;\n+}\n \n-   N.B. This function has been rearranged to out-of-line the uncommon cases\n-   as much as possible; this is important to prevent it from being a\n-   performance bottleneck.  */\n+/* Read the entire contents of file DESC into buffer BUF.  LEN is how\n+   much memory to allocate initially; more will be allocated if\n+   necessary.  Convert end-of-line markers (\\n, \\r, \\r\\n, \\n\\r) to\n+   canonical form (\\n).  If enabled, convert and/or warn about\n+   trigraphs.  Convert backslash-newline to a one-character escape\n+   (\\r) and remove it from \"embarrassing\" places (i.e. the middle of a\n+   token).  If there is no newline at the end of the file, add one and\n+   warn.  Returns -1 on failure, or the actual length of the data to\n+   be scanned.\n+\n+   This function does a lot of work, and can be a serious performance\n+   bottleneck.  It has been tuned heavily; make sure you understand it\n+   before hacking.  The common case - no trigraphs, Unix style line\n+   breaks, backslash-newline set off by whitespace, newline at EOF -\n+   has been optimized at the expense of the others.  The performance\n+   penalty for DOS style line breaks (\\r\\n) is about 15%.\n+   \n+   Warnings lose particularly heavily since we have to determine the\n+   line number, which involves scanning from the beginning of the file\n+   or from the last warning.  The penalty for the absence of a newline\n+   at the end of reload1.c is about 60%.  (reload1.c is 329k.)\n+\n+   If your file has more than one kind of end-of-line marker, you\n+   will get messed-up line numbering.  */\n \n static long\n read_and_prescan (pfile, fp, desc, len)\n@@ -774,29 +810,47 @@ read_and_prescan (pfile, fp, desc, len)\n      int desc;\n      size_t len;\n {\n-  U_CHAR *buf = (U_CHAR *) xmalloc (len);\n+  U_CHAR *buf = xmalloc (len);\n   U_CHAR *ip, *op, *line_base;\n   U_CHAR *ibase;\n-  unsigned int line;\n+  unsigned int line, deferred_newlines;\n   int count;\n   size_t offset;\n-  /* 4096 bytes of buffer proper, 2 to detect running off the end without\n-     address arithmetic all the time, and 2 for pushback in the case there's\n-     a potential trigraph or end-of-line digraph at the end of a block. */\n-#define INTERMED_BUFFER_SIZE 4096\n-  U_CHAR intermed[INTERMED_BUFFER_SIZE + 2 + 2];\n+  /* PIPE_BUF bytes of buffer proper, 2 to detect running off the end\n+     without address arithmetic all the time, and 2 for pushback in\n+     the case there's a potential trigraph or end-of-line digraph at\n+     the end of a block. */\n+  U_CHAR intermed[PIPE_BUF + 2 + 2];\n+\n+  /* Table of characters that can't be handled in the inner loop.\n+     Keep these contiguous to optimize the performance of the code generated\n+     for the switch that uses them.  */\n+  #define SPECCASE_EMPTY     0\n+  #define SPECCASE_NUL       1\n+  #define SPECCASE_CR        2\n+  #define SPECCASE_BACKSLASH 3\n+  #define SPECCASE_QUESTION  4\n+  U_CHAR speccase[256];\n \n   offset = 0;\n   op = buf;\n   line_base = buf;\n   line = 1;\n   ibase = intermed + 2;\n+  deferred_newlines = 0;\n+\n+  memset (speccase, SPECCASE_EMPTY, sizeof (speccase));\n+  speccase['\\0'] = SPECCASE_NUL;\n+  speccase['\\r'] = SPECCASE_CR;\n+  speccase['\\\\'] = SPECCASE_BACKSLASH;\n+  if (CPP_OPTIONS (pfile)->trigraphs || CPP_OPTIONS (pfile)->warn_trigraphs)\n+    speccase['?'] = SPECCASE_QUESTION;\n \n   for (;;)\n     {\n     read_next:\n \n-      count = read (desc, intermed + 2, INTERMED_BUFFER_SIZE);\n+      count = read (desc, intermed + 2, PIPE_BUF);\n       if (count < 0)\n \tgoto error;\n       else if (count == 0)\n@@ -806,16 +860,16 @@ read_and_prescan (pfile, fp, desc, len)\n       ip = ibase;\n       ibase = intermed + 2;\n       ibase[count] = ibase[count+1] = '\\0';\n-      \n+\n       if (offset > len)\n \t{\n \t  size_t delta_op;\n \t  size_t delta_line_base;\n \t  len *= 2;\n \t  if (offset > len)\n-\t      /* len overflowed.\n-\t\t This could happen if the file is larger than half the\n-\t\t maximum address space of the machine. */\n+\t    /* len overflowed.\n+\t       This could happen if the file is larger than half the\n+\t       maximum address space of the machine. */\n \t    goto too_big;\n \n \t  delta_op = op - buf;\n@@ -827,93 +881,155 @@ read_and_prescan (pfile, fp, desc, len)\n \n       for (;;)\n \t{\n-\t  unsigned int c;\n-\t  c = *ip++;\n-\t  switch (c)\n+\t  unsigned int span = 0;\n+\n+\t  /* Deal with \\-newline in the middle of a token. */\n+\t  if (deferred_newlines)\n \t    {\n-\t      /* The default case is at the top so gcc will realize\n-\t\t it's the common case, and leave c in a register.\n-\t         Also, cache utilization is a little better this way. */\n-\t    default:\n-\t      *op++ = c;\n-\t      break;\n-\t      \n-\t    case '\\0':\n+\t      while (speccase[ip[span]] == SPECCASE_EMPTY\n+\t\t     && ip[span] != '\\n'\n+\t\t     && ip[span] != '\\t'\n+\t\t     && ip[span] != ' ')\n+\t\tspan++;\n+\t      memcpy (op, ip, span);\n+\t      op += span;\n+\t      ip += span;\n+\t      if (*ip == '\\n' || *ip == '\\t'\n+\t\t  || *ip == ' ' || *ip == ' ')\n+\t\twhile (deferred_newlines)\n+\t\t  deferred_newlines--, *op++ = '\\r';\n+\t      span = 0;\n+\t    }\n+\n+\t  /* Copy as much as we can without special treatment. */\n+\t  while (speccase[ip[span]] == SPECCASE_EMPTY) span++;\n+\t  memcpy (op, ip, span);\n+\t  op += span;\n+\t  ip += span;\n+\n+\t  switch (speccase[*ip++])\n+\t    {\n+\t    case SPECCASE_NUL:  /* \\0 */\n+\t      ibase[-1] = op[-1];\n \t      goto read_next;\n-\t    case '\\r':\n-\t      if (*ip == '\\n') ip++;\n+\n+\t    case SPECCASE_CR:  /* \\r */\n+\t      if (*ip == '\\n')\n+\t\tip++;\n \t      else if (*ip == '\\0')\n \t\t{\n \t\t  --ibase;\n \t\t  intermed[1] = '\\r';\n \t\t  goto read_next;\n \t\t}\n+\t      else if (ip[-2] == '\\n')\n+\t\tcontinue;\n \t      *op++ = '\\n';\n-\t      line++;\n-\t      line_base = op;\n \t      break;\n \n-\t    case '\\n':\n-\t      if (*ip == '\\r') ip++;\n-\t      else if (*ip == '\\0')\n+\t    case SPECCASE_BACKSLASH:  /* \\ */\n+\t    backslash:\n+\t    {\n+\t      /* If we're at the end of the intermediate buffer,\n+\t\t we have to shift the backslash down to the start\n+\t\t and come back next pass. */\n+\t      if (*ip == '\\0')\n \t\t{\n \t\t  --ibase;\n-\t\t  intermed[1] = '\\n';\n+\t\t  intermed[1] = '\\\\';\n \t\t  goto read_next;\n \t\t}\n-\t      *op++ = '\\n';\n-\t      line++;\n-\t      line_base = op;\n-\t      break;\n-\n-\t    case '?':\n-\t      if (CPP_OPTIONS (pfile)->trigraphs\n-\t\t  || CPP_OPTIONS (pfile)->warn_trigraphs)\n+\t      else if (*ip == '\\n')\n \t\t{\n-\t\t  unsigned int d;\n-\t\t  /* If we're at the end of the intermediate buffer,\n-\t\t     we have to shift the ?'s down to the start and\n-\t\t     come back next pass. */\n-\t\t  d = ip[0];\n-\t\t  if (d == '\\0')\n-\t\t    {\n-\t\t      --ibase;\n-\t\t      intermed[1] = '?';\n-\t\t      goto read_next;\n-\t\t    }\n-\t\t  if (d != '?')\n-\t\t    {\n-\t\t      *op++ = '?';\n-\t\t      break;\n-\t\t    }\n-\t\t  d = ip[1];\n-\t\t  if (d == '\\0')\n+\t\t  ip++;\n+\t\t  if (*ip == '\\r') ip++;\n+\t\t  if (*ip == '\\n' || *ip == '\\t' || *ip == ' ')\n+\t\t    *op++ = '\\r';\n+\t\t  else if (op[-1] == '\\t' || op[-1] == ' '\n+\t\t\t   || op[-1] == '\\r' || op[-1] == '\\n')\n+\t\t    *op++ = '\\r';\n+\t\t  else\n+\t\t    deferred_newlines++;\n+\t\t  line++;\n+\t\t  line_base = op;\n+\t\t}\n+\t      else if (*ip == '\\r')\n+\t\t{\n+\t\t  ip++;\n+\t\t  if (*ip == '\\n') ip++;\n+\t\t  else if (*ip == '\\0')\n \t\t    {\n \t\t      ibase -= 2;\n-\t\t      intermed[0] = intermed[1] = '?';\n+\t\t      intermed[0] = '\\\\';\n+\t\t      intermed[1] = '\\r';\n \t\t      goto read_next;\n \t\t    }\n-\t\t  if (!trigraph_table[d])\n-\t\t    {\n-\t\t      *op++ = '?';\n-\t\t      break;\n-\t\t    }\n-\n-\t\t  if (CPP_OPTIONS (pfile)->warn_trigraphs)\n-\t\t    cpp_warning_with_line (pfile, line, op-line_base,\n-\t\t\t\t\t   \"trigraph ??%c encountered\", d);\n-\t\t  if (CPP_OPTIONS (pfile)->trigraphs)\n-\t\t    *op++ = trigraph_table[d];\n+\t\t  else if (*ip == '\\r' || *ip == '\\t' || *ip == ' ')\n+\t\t    *op++ = '\\r';\n \t\t  else\n-\t\t    {\n-\t\t      *op++ = '?';\n-\t\t      *op++ = '?';\n-\t\t      *op++ = d;\n-\t\t    }\n-\t\t  ip += 2;\n+\t\t    deferred_newlines++;\n+\t\t  line++;\n+\t\t  line_base = op;\n \t\t}\n \t      else\n-\t\t*op++ = c;\n+\t\t*op++ = '\\\\';\n+\t    }\n+\t    break;\n+\n+\t    case SPECCASE_QUESTION: /* ? */\n+\t      {\n+\t\tunsigned int d;\n+\t\t/* If we're at the end of the intermediate buffer,\n+\t\t   we have to shift the ?'s down to the start and\n+\t\t   come back next pass. */\n+\t\td = ip[0];\n+\t\tif (d == '\\0')\n+\t\t  {\n+\t\t    --ibase;\n+\t\t    intermed[1] = '?';\n+\t\t    goto read_next;\n+\t\t  }\n+\t\tif (d != '?')\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    break;\n+\t\t  }\n+\t\td = ip[1];\n+\t\tif (d == '\\0')\n+\t\t  {\n+\t\t    ibase -= 2;\n+\t\t    intermed[0] = intermed[1] = '?';\n+\t\t    goto read_next;\n+\t\t  }\n+\t\tif (!trigraph_table[d])\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    break;\n+\t\t  }\n+\n+\t\tif (CPP_OPTIONS (pfile)->warn_trigraphs)\n+\t\t  {\n+\t\t    long col;\n+\t\t    find_position (line_base, op, &line, &col);\n+\t\t    line_base = op - col;\n+\t\t    cpp_warning_with_line (pfile, line, col,\n+\t\t\t\t\t   \"trigraph ??%c encountered\", d);\n+\t\t  }\n+\t\tif (CPP_OPTIONS (pfile)->trigraphs)\n+\t\t  {\n+\t\t    if (trigraph_table[d] == '\\\\')\n+\t\t      goto backslash;\n+\t\t    else\n+\t\t      *op++ = trigraph_table[d];\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    *op++ = '?';\n+\t\t    *op++ = '?';\n+\t\t    *op++ = d;\n+\t\t  }\n+\t\tip += 2;\n+\t      }\n \t    }\n \t}\n     }\n@@ -922,47 +1038,48 @@ read_and_prescan (pfile, fp, desc, len)\n     return 0;\n \n   /* Deal with pushed-back chars at true EOF.\n-     If two chars were pushed back, they must both be ?'s.\n-     If one was, it might be ?, \\r, or \\n, and \\r needs to\n-     become \\n.\n+     This may be any of:  ?? ? \\ \\r \\n \\\\r \\\\n.\n+     \\r must become \\n, \\\\r or \\\\n must become \\r.\n      We know we have space already. */\n   if (ibase == intermed)\n     {\n-      *op++ = '?';\n-      *op++ = '?';\n+      if (*ibase == '?')\n+\t{\n+\t  *op++ = '?';\n+\t  *op++ = '?';\n+\t}\n+      else\n+\t*op++ = '\\r';\n     }\n   else if (ibase == intermed + 1)\n     {\n-      if (*ibase == '?')\n-\t*op++ = '?';\n-      else\n+      if (*ibase == '\\r')\n \t*op++ = '\\n';\n+      else\n+\t*op++ = *ibase;\n     }\n \n-  if (op[-1] != '\\n' || op[-2] == '\\\\')\n+  if (op[-1] != '\\n')\n     {\n-      if (CPP_PEDANTIC (pfile))\n-\tcpp_pedwarn_with_line (pfile, line, op - line_base,\n-\t\t\t       \"no newline at end of file\");\n-      if (offset + 2 > len)\n+      long col;\n+      find_position (line_base, op, &line, &col);\n+      cpp_warning_with_line (pfile, line, col, \"no newline at end of file\\n\");\n+      if (offset + 1 > len)\n \t{\n-\t  len += 2;\n-\t  if (offset + 2 > len)\n+\t  len += 1;\n+\t  if (offset + 1 > len)\n \t    goto too_big;\n \t  buf = (U_CHAR *) xrealloc (buf, len);\n \t  op = buf + offset;\n \t}\n-      if (op[-1] == '\\\\')\n-\t*op++ = '\\n';\n       *op++ = '\\n';\n     }\n \n-  fp->buf =\n-    (U_CHAR *) ((len - offset < 20) ? (PTR) buf : xrealloc (buf, op - buf));\n+  fp->buf = ((len - offset < 20) ? buf : (U_CHAR *)xrealloc (buf, op - buf));\n   return op - buf;\n \n  too_big:\n-  cpp_error (pfile, \"file is too large\");\n+  cpp_error (pfile, \"file is too large (>%lu bytes)\\n\", (unsigned long)offset);\n   free (buf);\n   return -1;\n "}, {"sha": "ff63bd816811b1955d330b18ecb47e342983d458", "filename": "gcc/cpphash.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -787,6 +787,7 @@ macarg (pfile, rest_args)\n   /* Try to parse as much of the argument as exists at this\n      input stack level.  */\n   pfile->no_macro_expand++;\n+  CPP_OPTIONS (pfile)->no_line_commands++;\n   for (;;)\n     {\n       token = cpp_get_token (pfile);\n@@ -824,6 +825,7 @@ macarg (pfile, rest_args)\n \n done:\n   CPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n+  CPP_OPTIONS (pfile)->no_line_commands--;\n   pfile->no_macro_expand--;\n \n   return token;"}, {"sha": "08bbff410b3096df69ca73426a20ef4142ac793c", "filename": "gcc/cppinit.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -255,15 +255,16 @@ U_CHAR is_idstart[256] =\n   ['_']  = 1,\n };\n \n-/* Table to tell if a character is horizontal space. */\n+/* Table to tell if a character is horizontal space.\n+   \\r is magical, so it is not in here.  */\n U_CHAR is_hor_space[256] =\n {\n-  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\r'] = 1\n+  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1,\n };\n /* table to tell if a character is horizontal or vertical space.  */\n U_CHAR is_space[256] =\n {\n-  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\r'] = 1, ['\\n'] = 1,\n+  [' '] = 1, ['\\t'] = 1, ['\\v'] = 1, ['\\f'] = 1, ['\\n'] = 1,\n };\n /* Table to handle trigraph conversion, which occurs before all other\n    processing, everywhere in the file.  (This is necessary since one\n@@ -362,14 +363,12 @@ initialize_char_syntax (dollar_in_ident)\n   is_hor_space['\\t'] = 1;\n   is_hor_space['\\v'] = 1;\n   is_hor_space['\\f'] = 1;\n-  is_hor_space['\\r'] = 1;\n \n   is_space[' '] = 1;\n   is_space['\\t'] = 1;\n   is_space['\\v'] = 1;\n   is_space['\\f'] = 1;\n   is_space['\\n'] = 1;\n-  is_space['\\r'] = 1;\n \n   /* trigraph conversion */\n   trigraph_table['='] = '#';  trigraph_table[')'] = ']';"}, {"sha": "8cbe54804811de556272684c69b9fb283f2b7ed0", "filename": "gcc/cpplib.c", "status": "modified", "additions": 370, "deletions": 450, "changes": 820, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -36,21 +36,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n    (Note that it is false while we're expanding macro *arguments*.) */\n #define CPP_IS_MACRO_BUFFER(PBUF) ((PBUF)->data != NULL)\n \n-/* Move all backslash-newline pairs out of embarrassing places.\n-   Exchange all such pairs following BP\n-   with any potentially-embarrassing characters that follow them.\n-   Potentially-embarrassing characters are / and *\n-   (because a backslash-newline inside a comment delimiter\n-   would cause it not to be recognized).  */\n-\n-#define NEWLINE_FIX \\\n-  do {while (PEEKC() == '\\\\' && PEEKN(1) == '\\n') FORWARD(2); } while(0)\n-\n-/* Same, but assume we've already read the potential '\\\\' into C.  */\n-#define NEWLINE_FIX1(C) do { \\\n-    while ((C) == '\\\\' && PEEKC() == '\\n') { FORWARD(1); (C) = GETC(); }\\\n-  } while(0)\n-\n /* Forward declarations.  */\n \n static char *my_strerror\t\tPROTO ((int));\n@@ -60,7 +45,10 @@ static HOST_WIDEST_INT eval_if_expression\tPROTO ((cpp_reader *));\n static void conditional_skip\t\tPROTO ((cpp_reader *, int,\n \t\t\t\t\t\tenum node_type, U_CHAR *));\n static void skip_if_group\t\tPROTO ((cpp_reader *));\n-static int parse_name                   PARAMS ((cpp_reader *, int));\n+\n+static void parse_name\t\t\tPARAMS ((cpp_reader *, int));\n+static void parse_string\t\tPARAMS ((cpp_reader *, int));\n+static int parse_assertion\t\tPARAMS ((cpp_reader *));\n \n /* External declarations.  */\n \n@@ -245,106 +233,188 @@ null_cleanup (pbuf, pfile)\n   return 0;\n }\n \n-/* Assuming we have read '/'.\n-   If this is the start of a comment (followed by '*' or '/'),\n-   skip to the end of the comment, and return ' '.\n-   Return EOF if we reached the end of file before the end of the comment.\n-   If not the start of a comment, return '/'.  */\n+/* Skip a comment - C, C++, or Chill style.  M is the first character\n+   of the comment marker.  If this really is a comment, skip to its\n+   end and return ' '.  If we hit end-of-file before end-of-comment,\n+   return EOF.  If this is not a comment, return M (which will be\n+   '/' or '-').  */\n \n static int\n-skip_comment (pfile, linep)\n+skip_comment (pfile, m)\n      cpp_reader *pfile;\n-     long *linep;\n+     int m;\n {\n-  int c = 0;\n-  while (PEEKC() == '\\\\' && PEEKN(1) == '\\n')\n-    {\n-      if (linep)\n-\t(*linep)++;\n-      FORWARD(2);\n-    }\n-  if (PEEKC() == '*')\n+  if (m == '/' && PEEKC() == '*')\n     {\n+      int c, prev_c = -1;\n+      long line, col;\n+      \n       FORWARD(1);\n+      cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n       for (;;)\n \t{\n-\t  int prev_c = c;\n \t  c = GETC ();\n \t  if (c == EOF)\n-\t    return EOF;\n-\t  while (c == '\\\\' && PEEKC() == '\\n')\n \t    {\n-\t      if (linep)\n-\t\t(*linep)++;\n-\t      FORWARD(1), c = GETC();\n+\t      cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n+\t      return EOF;\n \t    }\n-\t  if (prev_c == '*' && c == '/')\n+\t  else if (c == '\\n' || c == '\\r')\n+\t    CPP_BUMP_LINE (pfile);\n+\t  else if (c == '/' && prev_c == '*')\n \t    return ' ';\n-\t  if (c == '\\n' && linep)\n-\t    (*linep)++;\n+\t  else if (c == '*' && prev_c == '/'\n+\t\t   && CPP_OPTIONS (pfile)->warn_comments)\n+\t    cpp_warning (pfile, \"`/*' within comment\");\n+\n+\t  prev_c = c;\n \t}\n     }\n-  else if (PEEKC() == '/' && CPP_OPTIONS (pfile)->cplusplus_comments)\n+  else if ((m == '/' && PEEKC() == '/'\n+\t    && CPP_OPTIONS (pfile)->cplusplus_comments)\n+\t   || (m == '-' && PEEKC() == '-'\n+\t       && CPP_OPTIONS (pfile)->chill))\n     {\n       FORWARD(1);\n       for (;;)\n \t{\n-\t  c = GETC ();\n+\t  int c = GETC ();\n \t  if (c == EOF)\n \t    return ' '; /* Allow // to be terminated by EOF.  */\n-\t  while (c == '\\\\' && PEEKC() == '\\n')\n+\t      if (c == '\\n')\n+\t\t{\n+\t\t  /* Don't consider final '\\n' to be part of comment.  */\n+\t\t  FORWARD(-1);\n+\t\t  return ' ';\n+\t\t}\n+\t      else if (c == '\\r')\n+\t\tCPP_BUMP_LINE (pfile);\n+\t}\n+    }\n+  else\n+    return m;\n+}\n+\n+/* Identical to skip_comment except that it copies the comment into the\n+   token_buffer.  This is used if put_out_comments.  */\n+static int\n+copy_comment (pfile, m)\n+     cpp_reader *pfile;\n+     int m;\n+{\n+  if (m == '/' && PEEKC() == '*')\n+    {\n+      int c, prev_c = -1;\n+      long line, col;\n+\n+      CPP_PUTC (pfile, '/');\n+      CPP_PUTC (pfile, '*');\n+      FORWARD(1);\n+      cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n+      for (;;)\n+\t{\n+\t  c = GETC ();\n+\t  if (c == EOF)\n \t    {\n-\t      FORWARD(1);\n-\t      c = GETC();\n-\t      if (linep)\n-\t\t(*linep)++;\n+\t      cpp_error_with_line (pfile, line, col, \"unterminated comment\");\n+\t      /* We must pretend this was a legitimate comment, so that the\n+\t\t output in token_buffer is not passed back tagged CPP_POP. */\n+\t      return ' ';\n \t    }\n+\t  else if (c == '\\r')\n+\t    {\n+\t      CPP_BUMP_LINE (pfile);\n+\t      continue;\n+\t    }\n+\n+\t  CPP_PUTC (pfile, c);\n \t  if (c == '\\n')\n+\t    {\n+\t      pfile->lineno++;\n+\t      CPP_BUMP_LINE (pfile);\n+\t    }\n+\t  else if (c == '/' && prev_c == '*')\n+\t    return ' ';\n+\t  else if (c == '*' && prev_c == '/'\n+\t\t   && CPP_OPTIONS (pfile)->warn_comments)\n+\t    cpp_warning (pfile, \"`/*' within comment\");\n+\n+\t  prev_c = c;\n+\t}\n+    }\n+  else if ((m == '/' && PEEKC() == '/'\n+\t    && CPP_OPTIONS (pfile)->cplusplus_comments)\n+\t   || (m == '-' && PEEKC() == '-'\n+\t       && CPP_OPTIONS (pfile)->chill))\n+    {\n+      CPP_PUTC (pfile, m);\n+      CPP_PUTC (pfile, m);\n+      FORWARD(1);\n+      for (;;)\n+\t{\n+\t  int c = GETC ();\n+\t  if (c == EOF)\n+\t    return ' '; /* Allow line comments to be terminated by EOF. */\n+\t  else if (c == '\\n')\n \t    {\n \t      /* Don't consider final '\\n' to be part of comment.  */\n \t      FORWARD(-1);\n \t      return ' ';\n \t    }\n+\t  else if (c == '\\r')\n+\t    CPP_BUMP_LINE (pfile);\n+\n+\t  CPP_PUTC (pfile, c);\n \t}\n     }\n   else\n-    return '/';\n-}     \n+    return m;\n+}\n+\n \n /* Skip whitespace \\-newline and comments.  Does not macro-expand.  */\n \n void\n cpp_skip_hspace (pfile)\n      cpp_reader *pfile;\n {\n+  int c;\n   while (1)\n     {\n-      int c = PEEKC();\n+      c = GETC();\n       if (c == EOF)\n-\treturn; /* FIXME */\n-      if (is_hor_space[c])\n+\treturn;\n+      else if (is_hor_space[c])\n \t{\n \t  if ((c == '\\f' || c == '\\v') && CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n \t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n-\t  FORWARD(1);\n \t}\n-      else if (c == '/')\n+      else if (c == '\\r')\n \t{\n-\t  FORWARD (1);\n-\t  c = skip_comment (pfile, NULL);\n-\t  if (c == '/')\n-\t    FORWARD(-1);\n-\t  if (c == EOF || c == '/')\n+\t  CPP_BUFFER (pfile)->lineno++;\n+\t}\n+      else if (c == '/' || c == '-')\n+\t{\n+\t  c = skip_comment (pfile, c);\n+\t  if (c == EOF)\n \t    return;\n+\t  else if (c != ' ')\n+\t    {\n+\t      FORWARD(-1);\n+\t      return;\n+\t    }\n \t}\n-      else if (c == '\\\\' && PEEKN(1) == '\\n') {\n-\tFORWARD(2);\n-      }\n       else if (c == '@' && CPP_BUFFER (pfile)->has_escapes\n-\t       && is_hor_space[PEEKN(1)])\n-\tFORWARD(2);\n-      else return;\n+\t       && PEEKC() == ' ')\n+\t{\n+\t  FORWARD(1);\n+\t}\n+      else\n+\t{\n+\t  FORWARD(-1);\n+\t  return;\n+\t}\n     }\n }\n \n@@ -355,51 +425,52 @@ static void\n copy_rest_of_line (pfile)\n      cpp_reader *pfile;\n {\n-  struct cpp_options *opts = CPP_OPTIONS (pfile);\n   for (;;)\n     {\n       int c = GETC();\n-      int nextc;\n       switch (c)\n \t{\n+\tcase '\\n':\n+\t  FORWARD(-1);\n \tcase EOF:\n-\t  goto end_directive;\n-\tcase '\\\\':\n-\t  if (PEEKC() == '\\n')\n-\t    {\n-\t      FORWARD (1);\n-\t      continue;\n-\t    }\n+\t  CPP_NUL_TERMINATE (pfile);\n+\t  return;\n+\n+\tcase '\\r':\n+\t  CPP_BUFFER (pfile)->lineno++;\n+\t  continue;\n \tcase '\\'':\n \tcase '\\\"':\n-\t  goto scan_directive_token;\n-\t  break;\n+\t  parse_string (pfile, c);\n+\t  continue;\n \tcase '/':\n-\t  nextc = PEEKC();\n-\t  if (nextc == '*' || (opts->cplusplus_comments && nextc == '/'))\n-\t    goto scan_directive_token;\n+\t  if (PEEKC() == '*' && CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      CPP_PUTS (pfile, \"/**/\", 4);\n+\t      skip_comment (pfile, c);\n+\t      continue;\n+\t    }\n+\t  /* else fall through */\n+\tcase '-':\n+\t  c = skip_comment (pfile, c);\n \t  break;\n+\n \tcase '\\f':\n \tcase '\\v':\n \t  if (CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"%s in preprocessing directive\",\n \t\t\t c == '\\f' ? \"formfeed\" : \"vertical tab\");\n \t  break;\n \n-\tcase '\\n':\n-\t  FORWARD(-1);\n-\t  goto end_directive;\n-\tscan_directive_token:\n-\t  FORWARD(-1);\n-\t  cpp_get_token (pfile);\n-\t  continue;\n \t}\n       CPP_PUTC (pfile, c);\n     }\n- end_directive: ;\n-  CPP_NUL_TERMINATE (pfile);\n }\n \n+/* FIXME: It is almost definitely a performance win to make this do\n+   the scan itself.  >75% of calls to copy_r_o_l are from here or\n+   skip_if_group, which means the common case is to copy stuff into the\n+   token_buffer only to discard it.  */\n void\n skip_rest_of_line (pfile)\n      cpp_reader *pfile;\n@@ -415,7 +486,8 @@ skip_rest_of_line (pfile)\n static int\n handle_directive (pfile)\n      cpp_reader *pfile;\n-{ int c;\n+{\n+  int c;\n   register struct directive *kt;\n   int ident_length;\n   U_CHAR *ident;\n@@ -590,16 +662,11 @@ do_define (pfile, keyword)\n   int hashcode;\n   MACRODEF mdef;\n   HASHNODE *hp;\n-  int save_put_out_comments;\n   long here;\n   U_CHAR *macro, *buf, *end;\n \n   here = CPP_WRITTEN (pfile);\n-  \n-  save_put_out_comments = CPP_OPTIONS (pfile)->put_out_comments;\n-  CPP_OPTIONS (pfile)->put_out_comments = CPP_TRADITIONAL (pfile);\n   copy_rest_of_line (pfile);\n-  CPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n \n   /* Copy out the line so we can pop the token buffer. */\n   buf = pfile->token_buffer + here;\n@@ -696,6 +763,7 @@ cpp_push_buffer (pfile, buffer, length)\n   new->buf = new->cur = buffer;\n   new->alimit = new->rlimit = buffer + length;\n   new->prev = buf;\n+  new->mark = -1;\n \n   CPP_BUFFER (pfile) = new;\n   return new;\n@@ -781,59 +849,22 @@ cpp_expand_to_buffer (pfile, buf, length)\n   CPP_NUL_TERMINATE (pfile);\n }\n \n-static void\n-adjust_position (buf, limit, linep, colp)\n-     U_CHAR *buf;\n-     U_CHAR *limit;\n-     long *linep;\n-     long *colp;\n-{\n-  while (buf < limit)\n-    {\n-      U_CHAR ch = *buf++;\n-      if (ch == '\\n')\n-\t(*linep)++, (*colp) = 1;\n-      else\n-\t(*colp)++;\n-    }\n-}\n-\n-/* Move line_base forward, updating lineno and colno.  */\n-\n-static void\n-update_position (pbuf)\n-     register cpp_buffer *pbuf;\n-{\n-  unsigned char *old_pos = pbuf->buf + pbuf->line_base;\n-  unsigned char *new_pos = pbuf->cur;\n-  register struct parse_marker *mark;\n-  for (mark = pbuf->marks;  mark != NULL; mark = mark->next)\n-    {\n-      if (pbuf->buf + mark->position < new_pos)\n-\tnew_pos = pbuf->buf + mark->position;\n-    }\n-  pbuf->line_base += new_pos - old_pos;\n-  adjust_position (old_pos, new_pos, &pbuf->lineno, &pbuf->colno);\n-}\n-\n void\n cpp_buf_line_and_col (pbuf, linep, colp)\n      register cpp_buffer *pbuf;\n      long *linep, *colp;\n {\n-  long dummy;\n-  if (colp == NULL)\n-    colp = &dummy;\n   if (pbuf)\n     {\n       *linep = pbuf->lineno;\n-      *colp = pbuf->colno;\n-      adjust_position (pbuf->buf + pbuf->line_base, pbuf->cur, linep, colp);\n+      if (colp)\n+\t*colp = pbuf->cur - pbuf->line_base;\n     }\n   else\n     {\n       *linep = 0;\n-      *colp = 0;\n+      if (colp)\n+\t*colp = 0;\n     }\n }\n \n@@ -851,21 +882,6 @@ cpp_file_buffer (pfile)\n   return NULL;\n }\n \n-static long\n-count_newlines (buf, limit)\n-     register U_CHAR *buf;\n-     register U_CHAR *limit;\n-{\n-  register long count = 0;\n-  while (buf < limit)\n-    {\n-      U_CHAR ch = *buf++;\n-      if (ch == '\\n')\n-\tcount++;\n-    }\n-  return count;\n-}\n-\n /*\n  * write out a #line command, for instance, after an #include file.\n  * If CONDITIONAL is nonzero, we can omit the #line if it would\n@@ -886,73 +902,56 @@ output_line_command (pfile, conditional, file_change)\n   if (ip->fname == NULL)\n     return;\n \n-  update_position (ip);\n-\n   if (CPP_OPTIONS (pfile)->no_line_commands\n       || CPP_OPTIONS (pfile)->no_output)\n     return;\n \n-  line = CPP_BUFFER (pfile)->lineno;\n-  col = CPP_BUFFER (pfile)->colno;\n-  adjust_position (CPP_LINE_BASE (ip), ip->cur, &line, &col);\n+  cpp_buf_line_and_col (CPP_BUFFER (pfile), &line, &col);\n \n-  if (CPP_OPTIONS (pfile)->no_line_commands)\n-    return;\n+  if (conditional)\n+    {\n+      if (line == pfile->lineno)\n+\treturn;\n \n-  if (conditional) {\n-    if (line == pfile->lineno)\n-      return;\n-\n-    /* If the inherited line number is a little too small,\n-       output some newlines instead of a #line command.  */\n-    if (line > pfile->lineno && line < pfile->lineno + 8) {\n-      CPP_RESERVE (pfile, 20);\n-      while (line > pfile->lineno) {\n-\tCPP_PUTC_Q (pfile, '\\n');\n-\tpfile->lineno++;\n-      }\n-      return;\n+      /* If the inherited line number is a little too small,\n+\t output some newlines instead of a #line command.  */\n+      if (line > pfile->lineno && line < pfile->lineno + 8)\n+\t{\n+\t  CPP_RESERVE (pfile, 20);\n+\t  while (line > pfile->lineno)\n+\t    {\n+\t      CPP_PUTC_Q (pfile, '\\n');\n+\t      pfile->lineno++;\n+\t    }\n+\t  return;\n+\t}\n     }\n-  }\n-\n-#if 0\n-  /* Don't output a line number of 0 if we can help it.  */\n-  if (ip->lineno == 0 && ip->bufp - ip->buf < ip->length\n-      && *ip->bufp == '\\n') {\n-    ip->lineno++;\n-    ip->bufp++;\n-  }\n-#endif\n \n   CPP_RESERVE (pfile, 4 * strlen (ip->nominal_fname) + 50);\n-  {\n-#ifdef OUTPUT_LINE_COMMANDS\n-    static char sharp_line[] = \"#line \";\n-#else\n-    static char sharp_line[] = \"# \";\n-#endif\n-    CPP_PUTS_Q (pfile, sharp_line, sizeof(sharp_line)-1);\n-  }\n+  CPP_PUTS_Q (pfile, \"# \", 2);\n \n   sprintf ((char *) CPP_PWRITTEN (pfile), \"%ld \", line);\n   CPP_ADJUST_WRITTEN (pfile, strlen (CPP_PWRITTEN (pfile)));\n \n   quote_string (pfile, ip->nominal_fname); \n-  if (file_change != same_file) {\n-    CPP_PUTC_Q (pfile, ' ');\n-    CPP_PUTC_Q (pfile, file_change == enter_file ? '1' : '2');\n-  }\n+  if (file_change != same_file)\n+    {\n+      CPP_PUTC_Q (pfile, ' ');\n+      CPP_PUTC_Q (pfile, file_change == enter_file ? '1' : '2');\n+    }\n   /* Tell cc1 if following text comes from a system header file.  */\n-  if (ip->system_header_p) {\n-    CPP_PUTC_Q (pfile, ' ');\n-    CPP_PUTC_Q (pfile, '3');\n-  }\n+  if (ip->system_header_p)\n+    {\n+      CPP_PUTC_Q (pfile, ' ');\n+      CPP_PUTC_Q (pfile, '3');\n+    }\n #ifndef NO_IMPLICIT_EXTERN_C\n   /* Tell cc1plus if following text should be treated as C.  */\n-  if (ip->system_header_p == 2 && CPP_OPTIONS (pfile)->cplusplus) {\n-    CPP_PUTC_Q (pfile, ' ');\n-    CPP_PUTC_Q (pfile, '4');\n-  }\n+  if (ip->system_header_p == 2 && CPP_OPTIONS (pfile)->cplusplus)\n+    {\n+      CPP_PUTC_Q (pfile, ' ');\n+      CPP_PUTC_Q (pfile, '4');\n+    }\n #endif\n   CPP_PUTC_Q (pfile, '\\n');\n   pfile->lineno = line;\n@@ -1886,6 +1885,7 @@ skip_if_group (pfile)\n \t{\n \t  if (CPP_OPTIONS (pfile)->output_conditionals)\n \t    CPP_PUTC (pfile, c);\n+\t  CPP_BUMP_LINE (pfile);\n \t  continue;\n \t}\n       else if (c == '#')\n@@ -1915,7 +1915,11 @@ skip_if_group (pfile)\n \t{\n \t  /* \\n */\n \t  if (CPP_OPTIONS (pfile)->output_conditionals)\n-\t    CPP_PUTC (pfile, c);\n+\t    {\n+\t      CPP_PUTC (pfile, c);\n+\t      pfile->lineno++;\n+\t    }\n+\t  CPP_BUMP_LINE (pfile);\n \t}\n     }\t  \n \n@@ -1998,10 +2002,9 @@ do_endif (pfile, keyword)\n \t{\n \t  /* This #endif matched a #ifndef at the start of the file.\n \t     See if it is at the end of the file.  */\n-\t  struct parse_marker start_mark;\n \t  int c;\n \n-\t  parse_set_mark (&start_mark, pfile);\n+\t  parse_set_mark (pfile);\n \n \t  for (;;)\n \t    {\n@@ -2010,8 +2013,7 @@ do_endif (pfile, keyword)\n \t      if (c != '\\n')\n \t\tbreak;\n \t    }\n-\t  parse_goto_mark (&start_mark, pfile);\n-\t  parse_clear_mark (&start_mark);\n+\t  parse_goto_mark (pfile);\n \n \t  if (c == EOF)\n \t    {\n@@ -2057,8 +2059,6 @@ cpp_get_token (pfile)\n      cpp_reader *pfile;\n {\n   register int c, c2, c3;\n-  long old_written;\n-  long start_line, start_column;\n   enum cpp_token token;\n   struct cpp_options *opts = CPP_OPTIONS (pfile);\n \n@@ -2099,68 +2099,27 @@ cpp_get_token (pfile)\n     {\n       switch (c)\n \t{\n-\t  long newlines;\n-\t  struct parse_marker start_mark;\n \tcase '/':\n \t  if (PEEKC () == '=')\n \t    goto op2;\n+\n+\tcomment:\n \t  if (opts->put_out_comments)\n-\t    parse_set_mark (&start_mark, pfile);\n-\t  newlines = 0;\n-\t  cpp_buf_line_and_col (cpp_file_buffer (pfile),\n-\t\t\t\t&start_line, &start_column);\n-\t  c = skip_comment (pfile, &newlines);\n-\t  if (opts->put_out_comments && (c == '/' || c == EOF))\n-\t    parse_clear_mark (&start_mark);\n-\t  if (c == '/')\n-\t    goto randomchar;\n+\t    c = copy_comment (pfile, c);\n+\t  else\n+\t    c = skip_comment (pfile, c);\n \t  if (c == EOF)\n-\t    {\n-\t      cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t\t   \"unterminated comment\");\n-\t      goto handle_eof;\n-\t    }\n-\t  c = '/';  /* Initial letter of comment.  */\n-\treturn_comment:\n+\t    goto handle_eof;\n+\t  else if (c != ' ')\n+\t    goto randomchar;\n+\t  \n \t  /* Comments are equivalent to spaces.\n \t     For -traditional, a comment is equivalent to nothing.  */\n-\t  if (opts->put_out_comments)\n-\t    {\n-\t      cpp_buffer *pbuf = CPP_BUFFER (pfile);\n-\t      U_CHAR *start = pbuf->buf + start_mark.position;\n-\t      int len = pbuf->cur - start;\n-\t      CPP_RESERVE(pfile, 1 + len);\n-\t      CPP_PUTC_Q (pfile, c);\n-\t      CPP_PUTS_Q (pfile, start, len);\n-\t      pfile->lineno += newlines;\n-\t      parse_clear_mark (&start_mark);\n-\t      return CPP_COMMENT;\n-\t    }\n-\t  else if (CPP_TRADITIONAL (pfile))\n-\t    {\n-\t      return CPP_COMMENT;\n-\t    }\n+\t  if (opts->traditional || opts->put_out_comments)\n+\t    return CPP_COMMENT;\n \t  else\n \t    {\n-#if 0\n-\t      /* This may not work if cpp_get_token is called recursively,\n-\t\t since many places look for horizontal space.  */\n-\t      if (newlines)\n-\t\t{\n-\t\t  /* Copy the newlines into the output buffer, in order to\n-\t\t     avoid the pain of a #line every time a multiline comment\n-\t\t     is seen.  */\n-\t\t  CPP_RESERVE(pfile, newlines);\n-\t\t  while (--newlines >= 0)\n-\t\t    {\n-\t\t      CPP_PUTC_Q (pfile, '\\n');\n-\t\t      pfile->lineno++;\n-\t\t    }\n-\t\t  return CPP_VSPACE;\n-\t\t}\n-#endif\n-\t      CPP_RESERVE(pfile, 1);\n-\t      CPP_PUTC_Q (pfile, ' ');\n+\t      CPP_PUTC (pfile, c);\n \t      return CPP_HSPACE;\n \t    }\n #if 0\n@@ -2218,91 +2177,7 @@ cpp_get_token (pfile)\n \tcase '\\\"':\n \tcase '\\'':\n \tstring:\n-\t  /* A single quoted string is treated like a double -- some\n-\t     programs (e.g., troff) are perverse this way */\n-\t  cpp_buf_line_and_col (cpp_file_buffer (pfile),\n-\t\t\t\t&start_line, &start_column);\n-\t  old_written = CPP_WRITTEN (pfile);\n-\t  CPP_PUTC (pfile, c);\n-\t  while (1)\n-\t    {\n-\t      int cc = GETC();\n-\t      if (cc == EOF)\n-\t\t{\n-\t\t  if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n-\t\t    {\n-\t\t      /* try harder: this string crosses a macro expansion\n-\t\t\t boundary.  This can happen naturally if -traditional.\n-\t\t\t Otherwise, only -D can make a macro with an unmatched\n-\t\t\t quote.  */\n-\t\t\tcpp_pop_buffer (pfile);\n-\t\t\tcontinue;\n-\t\t    }\n-\t\t  if (!CPP_TRADITIONAL (pfile))\n-\t\t    {\n-\t\t      cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t      \"unterminated string or character constant\");\n-\t\t      if (pfile->multiline_string_line != start_line\n-\t\t\t  && pfile->multiline_string_line != 0)\n-\t\t\tcpp_error_with_line (pfile,\n-\t\t\t\t\t     pfile->multiline_string_line, -1,\n-\t\t\t       \"possible real start of unterminated constant\");\n-\t\t      pfile->multiline_string_line = 0;\n-\t\t    }\n-\t\t  break;\n-\t\t}\n-\t      CPP_PUTC (pfile, cc);\n-\t      switch (cc)\n-\t\t{\n-\t\tcase '\\n':\n-\t\t  /* Traditionally, end of line ends a string constant with\n-\t\t no error.  So exit the loop and record the new line.  */\n-\t\t  if (CPP_TRADITIONAL (pfile))\n-\t\t    goto while2end;\n-\t\t  if (c == '\\'')\n-\t\t    {\n-\t\t      cpp_error_with_line (pfile, start_line, start_column,\n-\t\t\t\t\t   \"unterminated character constant\");\n-\t\t      goto while2end;\n-\t\t    }\n-\t\t  if (CPP_PEDANTIC (pfile)\n-\t\t      && pfile->multiline_string_line == 0)\n-\t\t    {\n-\t\t      cpp_pedwarn_with_line (pfile, start_line, start_column,\n-\t\t\t       \"string constant runs past end of line\");\n-\t\t    }\n-\t\t  if (pfile->multiline_string_line == 0)\n-\t\t    pfile->multiline_string_line = start_line;\n-\t\t  break;\n-\t\t\n-\t\tcase '\\\\':\n-\t\t  cc = GETC();\n-\t\t  if (cc == '\\n')\n-\t\t    {\n-\t\t      /* Backslash newline is replaced by nothing at all.  */\n-\t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n-\t\t      pfile->lineno++;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      /* ANSI stupidly requires that in \\\\ the second \\\n-\t\t\t is *not* prevented from combining with a newline.  */\n-\t\t      NEWLINE_FIX1(cc);\n-\t\t      if (cc != EOF)\n-\t\t\tCPP_PUTC (pfile, cc);\n-\t\t    }\n-\t\t  break;\n-\n-\t\tcase '\\\"':\n-\t\tcase '\\'':\n-\t\t  if (cc == c)\n-\t\t    goto while2end;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\twhile2end:\n-\t  pfile->lineno += count_newlines (pfile->token_buffer + old_written,\n-\t\t\t\t\t   CPP_PWRITTEN (pfile));\n+\t  parse_string (pfile, c);\n \t  pfile->only_seen_white = 0;\n \t  return c == '\\'' ? CPP_CHAR : CPP_STRING;\n \n@@ -2319,7 +2194,6 @@ cpp_get_token (pfile)\n \tcase '&':\n \tcase '+':\n \tcase '|':\n-\t  NEWLINE_FIX;\n \t  c2 = PEEKC ();\n \t  if (c2 == c || c2 == '=')\n \t    goto op2;\n@@ -2330,35 +2204,14 @@ cpp_get_token (pfile)\n \tcase '%':\n \tcase '=':\n \tcase '^':\n-\t  NEWLINE_FIX;\n \t  if (PEEKC () == '=')\n \t    goto op2;\n \t  goto randomchar;\n \n \tcase '-':\n-\t  NEWLINE_FIX;\n \t  c2 = PEEKC ();\n \t  if (c2 == '-' && opts->chill)\n-\t    {\n-\t      /* Chill style comment */\n-\t      if (opts->put_out_comments)\n-\t\tparse_set_mark (&start_mark, pfile);\n-\t      FORWARD(1);  /* Skip second '-'.  */\n-\t      for (;;)\n-\t\t{\n-\t\t  c = GETC ();\n-\t\t  if (c == EOF)\n-\t\t    break;\n-\t\t  if (c == '\\n')\n-\t\t    {\n-\t\t      /* Don't consider final '\\n' to be part of comment.  */\n-\t\t      FORWARD(-1);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t      c = '-';\n-\t      goto return_comment;\n-\t    }\n+\t    goto comment;  /* Chill style comment */\n \t  if (c2 == '-' || c2 == '=' || c2 == '>')\n \t    goto op2;\n \t  goto randomchar;\n@@ -2372,19 +2225,23 @@ cpp_get_token (pfile)\n \t\t  if (c == '>')\n \t\t    break;\n \t\t  c = GETC ();\n-\t\t  NEWLINE_FIX1 (c);\n \t\t  if (c == '\\n' || c == EOF)\n \t\t    {\n \t\t      cpp_error (pfile,\n \t\t\t\t \"missing '>' in `#include <FILENAME>'\");\n \t\t      break;\n \t\t    }\n+\t\t  else if (c == '\\r')\n+\t\t    {\n+\t\t      /* Backslash newline is replaced by nothing. */\n+\t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t      CPP_BUMP_LINE (pfile);\n+\t\t    }\n \t\t}\n \t      return CPP_STRING;\n \t    }\n \t  /* else fall through */\n \tcase '>':\n-\t  NEWLINE_FIX;\n \t  c2 = PEEKC ();\n \t  if (c2 == '=')\n \t    goto op2;\n@@ -2394,7 +2251,6 @@ cpp_get_token (pfile)\n \t  CPP_RESERVE (pfile, 4);\n \t  CPP_PUTC (pfile, c);\n \t  CPP_PUTC (pfile, c2);\n-\t  NEWLINE_FIX;\n \t  c3 = PEEKC ();\n \t  if (c3 == '=')\n \t    CPP_PUTC_Q (pfile, GETC ());\n@@ -2413,7 +2269,7 @@ cpp_get_token (pfile)\n \t\t  parse_name (pfile, GETC ());\n \t\t  return CPP_NAME;\n \t\t}\n-\t      else if (is_space [c])\n+\t      else if (c == ' ')\n \t\t{\n \t\t  CPP_RESERVE (pfile, 2);\n \t\t  if (pfile->output_escapes)\n@@ -2430,7 +2286,6 @@ cpp_get_token (pfile)\n \t  goto randomchar;\n \n \tcase '.':\n-\t  NEWLINE_FIX;\n \t  c2 = PEEKC ();\n \t  if (ISDIGIT(c2))\n \t    {\n@@ -2439,7 +2294,6 @@ cpp_get_token (pfile)\n \t      c = GETC ();\n \t      goto number;\n \t    }\n-\t  /* FIXME - misses the case \"..\\\\\\n.\" */\n \t  if (c2 == '.' && PEEKN(1) == '.')\n \t    {\n \t      CPP_RESERVE(pfile, 4);\n@@ -2456,15 +2310,13 @@ cpp_get_token (pfile)\n \top2:\n \t  token = CPP_OTHER;\n \t  pfile->only_seen_white = 0;\n-        op2any:\n \t  CPP_RESERVE(pfile, 3);\n \t  CPP_PUTC_Q (pfile, c);\n \t  CPP_PUTC_Q (pfile, GETC ());\n \t  CPP_NUL_TERMINATE_Q (pfile);\n \t  return token;\n \n \tcase 'L':\n-\t  NEWLINE_FIX;\n \t  c2 = PEEKC ();\n \t  if ((c2 == '\\'' || c2 == '\\\"') && !CPP_TRADITIONAL (pfile))\n \t    {\n@@ -2482,7 +2334,6 @@ cpp_get_token (pfile)\n \t    {\n \t      CPP_RESERVE (pfile, 2);\n \t      CPP_PUTC_Q (pfile, c);\n-\t      NEWLINE_FIX;\n \t      c = PEEKC ();\n \t      if (c == EOF)\n \t\tbreak;\n@@ -2512,14 +2363,7 @@ cpp_get_token (pfile)\n \t\t  if (c == EOF)\n \t\t    goto chill_number_eof;\n \t\t  if (!is_idchar[c])\n-\t\t    {\n-\t\t      if (c == '\\\\' && PEEKC() == '\\n')\n-\t\t\t{\n-\t\t\t  FORWARD(2);\n-\t\t\t  continue;\n-\t\t\t}\n-\t\t      break;\n-\t\t    }\n+\t\t    break;\n \t\t  CPP_PUTC (pfile, c);\n \t\t}\n \t      if (c == '\\'')\n@@ -2584,10 +2428,9 @@ cpp_get_token (pfile)\n \t       decide this is not a macro call and leave things that way.  */\n \t    if (hp->type == T_MACRO && hp->value.defn->nargs >= 0)\n \t    {\n-\t      struct parse_marker macro_mark;\n \t      int is_macro_call, macbuf_whitespace = 0;\n \n-\t      parse_set_mark (&macro_mark, pfile);\n+\t      parse_set_mark (pfile);\n \t      for (;;)\n \t\t{\n \t\t  cpp_skip_hspace (pfile);\n@@ -2603,26 +2446,28 @@ cpp_get_token (pfile)\n                     {\n                       if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n                         {\n-                          if (macro_mark.position !=\n+                          if (CPP_BUFFER (pfile)->mark !=\n                               (CPP_BUFFER (pfile)->cur\n                                - CPP_BUFFER (pfile)->buf))\n                              macbuf_whitespace = 1;\n \n-                          parse_clear_mark (&macro_mark);\n+\t\t\t  /* The mark goes away automatically when\n+\t\t\t     the buffer is popped. */\n                           cpp_pop_buffer (pfile);\n-                          parse_set_mark (&macro_mark, pfile);\n+                          parse_set_mark (pfile);\n                         }\n                       else\n                         break;\n                     }\n \t\t}\n \t      if (!is_macro_call)\n                 {\n-                  parse_goto_mark (&macro_mark, pfile);\n+                  parse_goto_mark (pfile);\n                   if (macbuf_whitespace)\n                     CPP_PUTC (pfile, ' ');\n                 }\n-\t      parse_clear_mark (&macro_mark);\n+\t      else\n+\t\tparse_clear_mark (pfile);\n \t      if (!is_macro_call)\n \t\treturn CPP_NAME;\n \t    }\n@@ -2634,7 +2479,7 @@ cpp_get_token (pfile)\n \t  }\n \t  goto get_next;\n \n-\tcase ' ':  case '\\t':  case '\\v':  case '\\r':\n+\tcase ' ':  case '\\t':  case '\\v':\n \t  for (;;)\n \t    {\n \t      CPP_PUTC (pfile, c);\n@@ -2646,18 +2491,21 @@ cpp_get_token (pfile)\n \t  return CPP_HSPACE;\n \n         case '\\\\':\n-\t  c2 = PEEKC ();\n-\t  if (c2 != '\\n')\n-\t    goto randomchar;\n-\t  token = CPP_HSPACE;\n-\t  goto op2any;\n+\t  goto randomchar;\n+\n+\tcase '\\r':\n+\t  /* Backslash newline is ignored. */\n+\t  CPP_BUMP_LINE (pfile);\n+\t  goto get_next;\n \n \tcase '\\n':\n \t  CPP_PUTC (pfile, c);\n \t  if (pfile->only_seen_white == 0)\n \t    pfile->only_seen_white = 1;\n+\t  CPP_BUMP_LINE (pfile);\n \t  pfile->lineno++;\n-\t  output_line_command (pfile, 1, same_file);\n+\t  if (CPP_BUFFER (pfile)->lineno != pfile->lineno)\n+\t    output_line_command (pfile, 1, same_file);\n \t  return CPP_VSPACE;\n \n \tcase '(': token = CPP_LPAREN;    goto char1;\n@@ -2697,19 +2545,15 @@ cpp_get_non_space_token (pfile)\n \n /* Parse an identifier starting with C.  */\n \n-static int\n+static void\n parse_name (pfile, c)\n-     cpp_reader *pfile; int c;\n+     cpp_reader *pfile;\n+     int c;\n {\n   for (;;)\n   {\n       if (! is_idchar[c])\n       {\n-\t  if (c == '\\\\' && PEEKC() == '\\n')\n-\t  {\n-\t      FORWARD(2);\n-\t      continue;\n-\t  }\n \t  FORWARD (-1);\n \t  break;\n       }\n@@ -2724,7 +2568,95 @@ parse_name (pfile, c)\n \tbreak;\n   }\n   CPP_NUL_TERMINATE_Q (pfile);\n-  return 1;\n+  return;\n+}\n+\n+/* Parse a string starting with C.  A single quoted string is treated\n+   like a double -- some programs (e.g., troff) are perverse this way.\n+   (However, a single quoted string is not allowed to extend over\n+   multiple lines.  */\n+static void\n+parse_string (pfile, c)\n+     cpp_reader *pfile;\n+     int c;\n+{\n+  long start_line, start_column;\n+  \n+  cpp_buf_line_and_col (cpp_file_buffer (pfile), &start_line, &start_column);\n+\n+  CPP_PUTC (pfile, c);\n+  while (1)\n+    {\n+      int cc = GETC();\n+      if (cc == EOF)\n+\t{\n+\t  if (CPP_IS_MACRO_BUFFER (CPP_BUFFER (pfile)))\n+\t    {\n+\t      /* try harder: this string crosses a macro expansion\n+\t\t boundary.  This can happen naturally if -traditional.\n+\t\t Otherwise, only -D can make a macro with an unmatched\n+\t\t quote.  */\n+\t      cpp_pop_buffer (pfile);\n+\t      continue;\n+\t    }\n+\t  if (!CPP_TRADITIONAL (pfile))\n+\t    {\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t\t \"unterminated string or character constant\");\n+\t      if (pfile->multiline_string_line != start_line\n+\t\t  && pfile->multiline_string_line != 0)\n+\t\tcpp_error_with_line (pfile,\n+\t\t\t\t     pfile->multiline_string_line, -1,\n+\t\t\t       \"possible real start of unterminated constant\");\n+\t      pfile->multiline_string_line = 0;\n+\t    }\n+\t  break;\n+\t}\n+      CPP_PUTC (pfile, cc);\n+      switch (cc)\n+\t{\n+\tcase '\\n':\n+\t  CPP_BUMP_LINE (pfile);\n+\t  pfile->lineno++;\n+\t  /* Traditionally, end of line ends a string constant with\n+\t     no error.  */\n+\t  if (CPP_TRADITIONAL (pfile))\n+\t    return;\n+\t  /* Character constants may not extend over multiple lines.  */\n+\t  if (c == '\\'')\n+\t    {\n+\t      cpp_error_with_line (pfile, start_line, start_column,\n+\t\t\t\t   \"unterminated character constant\");\n+\t      return;\n+\t    }\n+\t  if (CPP_PEDANTIC (pfile) && pfile->multiline_string_line == 0)\n+\t    {\n+\t      cpp_pedwarn_with_line (pfile, start_line, start_column,\n+\t\t\t\t     \"string constant runs past end of line\");\n+\t    }\n+\t  if (pfile->multiline_string_line == 0)\n+\t    pfile->multiline_string_line = start_line;\n+\t  break;\n+\n+\tcase '\\r':\n+\t  /* Backslash newline is replaced by nothing at all.  */\n+\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t  CPP_BUMP_LINE (pfile);\n+\t  break;\n+\n+\tcase '\\\\':\n+\t  cc = GETC();\n+\t  if (cc != EOF)\n+\t    CPP_PUTC (pfile, cc);\n+\t  break;\n+\n+\tcase '\\\"':\n+\tcase '\\'':\n+\t  if (cc == c)\n+\t    return;\n+\t  break;\n+\t}\n+    }\n }\n \n /* Read an assertion into the token buffer, converting to\n@@ -2752,7 +2684,7 @@ parse_assertion (pfile)\n   c = PEEKC();\n   if (c != '(')\n     {\n-      if (is_hor_space[c])\n+      if (is_hor_space[c] || c == '\\r')\n \tcpp_skip_hspace (pfile);\n       c = PEEKC();\n     }\n@@ -2772,17 +2704,17 @@ parse_assertion (pfile)\n \t      dropwhite = 1;\n \t    }\n \t}\n-      else if (c == '\\\\' && PEEKC() == '\\n')\n-\tFORWARD(1);\n       else if (c == '\\n' || c == EOF)\n \t{\n \t  if (c == '\\n') FORWARD(-1);\n \t  cpp_error (pfile, \"un-terminated assertion answer\");\n \t  return 0;\n \t}\n+      else if (c == '\\r')\n+\tCPP_BUMP_LINE (pfile);\n       else\n \t{\n-\t  CPP_PUTC(pfile, c);\n+\t  CPP_PUTC (pfile, c);\n \t  dropwhite = 0;\n \t}\n     }\n@@ -2795,9 +2727,9 @@ parse_assertion (pfile)\n       return 0;\n     }\n   else\n-    CPP_PUTC(pfile, ')');\n+    CPP_PUTC (pfile, ')');\n \n-  CPP_NUL_TERMINATE(pfile);\n+  CPP_NUL_TERMINATE (pfile);\n   return 2;\n }\n \n@@ -2971,62 +2903,50 @@ cpp_read_check_assertion (pfile)\n   return result;\n }\n \n-/* Initialize PMARK to remember the current position of PFILE.  */\n+/* Remember the current position of PFILE.  */\n \n void\n-parse_set_mark (pmark, pfile)\n-     struct parse_marker *pmark;\n+parse_set_mark (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *pbuf = CPP_BUFFER (pfile);\n-  pmark->next = pbuf->marks;\n-  pbuf->marks = pmark;\n-  pmark->buf = pbuf;\n-  pmark->position = pbuf->cur - pbuf->buf;\n-}\n-\n-/* Cleanup PMARK - we no longer need it.  */\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  if (ip->mark != -1)\n+      cpp_fatal (pfile,\n+\t\t \"cpp internal error: ip->mark != -1 in parse_set_mark\");\n \n-void\n-parse_clear_mark (pmark)\n-     struct parse_marker *pmark;\n-{\n-  struct parse_marker **pp = &pmark->buf->marks;\n-  for (; ; pp = &(*pp)->next) {\n-    if (*pp == NULL) abort ();\n-    if (*pp == pmark) break;\n-  }\n-  *pp = pmark->next;\n+  ip->mark = ip->cur - ip->buf;\n }\n \n-/* Backup the current position of PFILE to that saved in PMARK.  */\n+/* Clear the current mark - we no longer need it.  */\n \n void\n-parse_goto_mark (pmark, pfile)\n-     struct parse_marker *pmark;\n+parse_clear_mark (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *pbuf = CPP_BUFFER (pfile);\n-  if (pbuf != pmark->buf)\n-    cpp_fatal (pfile, \"internal error %s\", \"parse_goto_mark\");\n-  pbuf->cur = pbuf->buf + pmark->position;\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  if (ip->mark == -1)\n+      cpp_fatal (pfile,\n+\t\t \"cpp internal error: ip->mark == -1 in parse_clear_mark\");\n+\n+  ip->mark = -1;\n }\n \n-/* Reset PMARK to point to the current position of PFILE.  (Same\n-   as parse_clear_mark (PMARK), parse_set_mark (PMARK, PFILE) but faster.  */\n+/* Backup the current position of PFILE to that saved in its mark,\n+   and clear the mark.  */\n \n void\n-parse_move_mark (pmark, pfile)\n-     struct parse_marker *pmark;\n+parse_goto_mark (pfile)\n      cpp_reader *pfile;\n {\n-  cpp_buffer *pbuf = CPP_BUFFER (pfile);\n-  if (pbuf != pmark->buf)\n-    cpp_fatal (pfile, \"internal error %s\", \"parse_move_mark\");\n-  pmark->position = pbuf->cur - pbuf->buf;\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+  if (ip->mark == -1)\n+      cpp_fatal (pfile,\n+\t\t \"cpp internal error: ip->mark == -1 in parse_goto_mark\");\n+\n+  ip->cur = ip->buf + ip->mark;\n+  ip->mark = -1;\n }\n \n-\f\n void\n cpp_print_file_and_line (pfile)\n      cpp_reader *pfile;"}, {"sha": "9af3b4b6343d337cd08d23b66f8d064d070ee2e2", "filename": "gcc/cpplib.h", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3fdc651fed8f150778148b0409c0d2852f8b571a/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=3fdc651fed8f150778148b0409c0d2852f8b571a", "patch": "@@ -72,19 +72,9 @@ enum cpp_token {\n typedef enum cpp_token (*parse_underflow_t) PARAMS((cpp_reader *));\n typedef int (*parse_cleanup_t) PARAMS((cpp_buffer *, cpp_reader *));\n \n-/* A parse_marker indicates a previous position,\n-   which we can backtrack to. */\n-\n-struct parse_marker {\n-  cpp_buffer *buf;\n-  struct parse_marker *next;\n-  int position;\n-};\n-\n-extern void parse_set_mark PARAMS ((struct parse_marker *, cpp_reader *));\n-extern void parse_clear_mark PARAMS ((struct parse_marker *));\n-extern void parse_goto_mark PARAMS((struct parse_marker *, cpp_reader *));\n-extern void parse_move_mark PARAMS((struct parse_marker *, cpp_reader *));\n+extern void parse_set_mark\tPARAMS ((cpp_reader *));\n+extern void parse_clear_mark\tPARAMS ((cpp_reader *));\n+extern void parse_goto_mark\tPARAMS ((cpp_reader *));\n \n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n@@ -95,15 +85,13 @@ extern enum cpp_token cpp_get_non_space_token PARAMS ((cpp_reader *));\n /* This frees resources used by PFILE. */\n extern void cpp_cleanup PARAMS ((cpp_reader *PFILE));\n \n-/* If we have a huge buffer, may need to cache more recent counts */\n-#define CPP_LINE_BASE(BUF) ((BUF)->buf + (BUF)->line_base)\n-\n struct cpp_buffer\n {\n   unsigned char *cur;\t /* current position */\n   unsigned char *rlimit; /* end of valid data */\n   unsigned char *buf;\t /* entire buffer */\n   unsigned char *alimit; /* end of allocated buffer */\n+  unsigned char *line_base; /* start of current line */\n \n   struct cpp_buffer *prev;\n \n@@ -120,13 +108,13 @@ struct cpp_buffer\n      to record control macros. */\n   struct include_hash *ihash;\n \n-  long line_base;\n   long lineno; /* Line number at CPP_LINE_BASE. */\n   long colno; /* Column number at CPP_LINE_BASE. */\n+  long mark;  /* Saved position for lengthy backtrack. */\n   parse_underflow_t underflow;\n   parse_cleanup_t cleanup;\n   void *data;\n-  struct parse_marker *marks;\n+  \n   /* Value of if_stack at start of this file.\n      Used to prohibit unmatched #endif (etc) in an include file.  */\n   struct if_stack *if_stack;\n@@ -289,8 +277,12 @@ struct cpp_reader\n #define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n #define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n \n-#define CPP_OPTIONS(PFILE) ((PFILE)->opts)\n+/* Advance the current line by one. */\n+#define CPP_BUMP_BUFFER_LINE(PBUF) ((PBUF)->lineno++,\\\n+\t\t\t\t    (PBUF)->line_base = (PBUF)->cur)\n+#define CPP_BUMP_LINE(PFILE) CPP_BUMP_BUFFER_LINE(CPP_BUFFER(PFILE))\n \n+#define CPP_OPTIONS(PFILE) ((PFILE)->opts)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n #define CPP_PREV_BUFFER(BUFFER) ((BUFFER)->prev)\n /* The bottom of the buffer stack. */"}]}