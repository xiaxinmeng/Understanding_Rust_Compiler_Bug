{"sha": "47210a041b3b40319b8dee64f00d479b1781eb57", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcyMTBhMDQxYjNiNDAzMTliOGRlZTY0ZjAwZDQ3OWIxNzgxZWI1Nw==", "commit": {"author": {"name": "Renlin Li", "email": "renlin.li@arm.com", "date": "2017-05-15T11:24:56Z"}, "committer": {"name": "Renlin Li", "email": "renlin@gcc.gnu.org", "date": "2017-05-15T11:24:56Z"}, "message": "[PATCH][AARCH64]Simplify call, call_value, sibcall, sibcall_value patterns.\n\ngcc/ChangeLog\n\n2017-05-15  Renlin Li  <renlin.li@arm.com>\n\n\t* config/aarch64/aarch64-protos.h (aarch64_expand_call): Declare.\n\t* config/aarch64/aarch64.c (aarch64_expand_call): Define.\n\t* config/aarch64/constraints.md (Usf): Add long call check.\n\t* config/aarch64/aarch64.md (call): Use aarch64_expand_call.\n\t(call_value): Likewise.\n\t(sibcall): Likewise.\n\t(sibcall_value): Likewise.\n\t(call_insn): New.\n\t(call_value_insn): New.\n\t(sibcall_insn): Update rtx pattern.\n\t(sibcall_value_insn): Likewise.\n\t(call_internal): Remove.\n\t(call_value_internal): Likewise.\n\t(sibcall_internal): Likewise.\n\t(sibcall_value_internal): Likewise.\n\t(call_reg): Likewise.\n\t(call_symbol): Likewise.\n\t(call_value_reg): Likewise.\n\t(call_value_symbol): Likewise.\n\nFrom-SVN: r248056", "tree": {"sha": "53a77fc48d52d149408165bdedb0e02da2ad0e1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/53a77fc48d52d149408165bdedb0e02da2ad0e1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47210a041b3b40319b8dee64f00d479b1781eb57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47210a041b3b40319b8dee64f00d479b1781eb57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47210a041b3b40319b8dee64f00d479b1781eb57", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47210a041b3b40319b8dee64f00d479b1781eb57/comments", "author": null, "committer": null, "parents": [{"sha": "7543c8b64cbcbeff998f6112dc8b6e07645e55a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7543c8b64cbcbeff998f6112dc8b6e07645e55a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7543c8b64cbcbeff998f6112dc8b6e07645e55a9"}], "stats": {"total": 216, "additions": 87, "deletions": 129}, "files": [{"sha": "0654ce757948a53f558923e07a428ed725810f14", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47210a041b3b40319b8dee64f00d479b1781eb57", "patch": "@@ -1,3 +1,25 @@\n+2017-05-15  Renlin Li  <renlin.li@arm.com>\n+\n+\t* config/aarch64/aarch64-protos.h (aarch64_expand_call): Declare.\n+\t* config/aarch64/aarch64.c (aarch64_expand_call): Define.\n+\t* config/aarch64/constraints.md (Usf): Add long call check.\n+\t* config/aarch64/aarch64.md (call): Use aarch64_expand_call.\n+\t(call_value): Likewise.\n+\t(sibcall): Likewise.\n+\t(sibcall_value): Likewise.\n+\t(call_insn): New.\n+\t(call_value_insn): New.\n+\t(sibcall_insn): Update rtx pattern.\n+\t(sibcall_value_insn): Likewise.\n+\t(call_internal): Remove.\n+\t(call_value_internal): Likewise.\n+\t(sibcall_internal): Likewise.\n+\t(sibcall_value_internal): Likewise.\n+\t(call_reg): Likewise.\n+\t(call_symbol): Likewise.\n+\t(call_value_reg): Likewise.\n+\t(call_value_symbol): Likewise.\n+\n 2017-05-14  Krister Walfridsson  <krister.walfridsson@gmail.com>\n \n \tPR target/80600"}, {"sha": "ac91865b75fda43b94ddf9caa5ac09be17b0f8ab", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=47210a041b3b40319b8dee64f00d479b1781eb57", "patch": "@@ -312,6 +312,7 @@ bool aarch64_const_vec_all_same_int_p (rtx, HOST_WIDE_INT);\n bool aarch64_constant_address_p (rtx);\n bool aarch64_emit_approx_div (rtx, rtx, rtx);\n bool aarch64_emit_approx_sqrt (rtx, rtx, bool);\n+void aarch64_expand_call (rtx, rtx, bool);\n bool aarch64_expand_movmem (rtx *);\n bool aarch64_float_const_zero_rtx_p (rtx);\n bool aarch64_function_arg_regno_p (unsigned);"}, {"sha": "5e546bf9091918371ac4835fe2f9806e48f16458", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=47210a041b3b40319b8dee64f00d479b1781eb57", "patch": "@@ -4651,6 +4651,50 @@ aarch64_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)\n   return true;\n }\n \n+/* This function is used by the call expanders of the machine description.\n+   RESULT is the register in which the result is returned.  It's NULL for\n+   \"call\" and \"sibcall\".\n+   MEM is the location of the function call.\n+   SIBCALL indicates whether this function call is normal call or sibling call.\n+   It will generate different pattern accordingly.  */\n+\n+void\n+aarch64_expand_call (rtx result, rtx mem, bool sibcall)\n+{\n+  rtx call, callee, tmp;\n+  rtvec vec;\n+  machine_mode mode;\n+\n+  gcc_assert (MEM_P (mem));\n+  callee = XEXP (mem, 0);\n+  mode = GET_MODE (callee);\n+  gcc_assert (mode == Pmode);\n+\n+  /* Decide if we should generate indirect calls by loading the\n+     address of the callee into a register before performing\n+     the branch-and-link.  */\n+  if (SYMBOL_REF_P (callee)\n+      ? (aarch64_is_long_call_p (callee)\n+\t || aarch64_is_noplt_call_p (callee))\n+      : !REG_P (callee))\n+    XEXP (mem, 0) = force_reg (mode, callee);\n+\n+  call = gen_rtx_CALL (VOIDmode, mem, const0_rtx);\n+\n+  if (result != NULL_RTX)\n+    call = gen_rtx_SET (result, call);\n+\n+  if (sibcall)\n+    tmp = ret_rtx;\n+  else\n+    tmp = gen_rtx_CLOBBER (VOIDmode, gen_rtx_REG (Pmode, LR_REGNUM));\n+\n+  vec = gen_rtvec (2, call, tmp);\n+  call = gen_rtx_PARALLEL (VOIDmode, vec);\n+\n+  aarch64_emit_call_insn (call);\n+}\n+\n /* Emit call insn with PAT and do aarch64-specific handling.  */\n \n void"}, {"sha": "93972d134b1eeba0e339f00528fc2e03f0c02052", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 18, "deletions": 128, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=47210a041b3b40319b8dee64f00d479b1781eb57", "patch": "@@ -717,12 +717,6 @@\n ;; Subroutine calls and sibcalls\n ;; -------------------------------------------------------------------\n \n-(define_expand \"call_internal\"\n-  [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n-\t\t    (match_operand 1 \"general_operand\" \"\"))\n-\t      (use (match_operand 2 \"\" \"\"))\n-\t      (clobber (reg:DI LR_REGNUM))])])\n-\n (define_expand \"call\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n \t\t    (match_operand 1 \"general_operand\" \"\"))\n@@ -731,57 +725,22 @@\n   \"\"\n   \"\n   {\n-    rtx callee, pat;\n-\n-    /* In an untyped call, we can get NULL for operand 2.  */\n-    if (operands[2] == NULL)\n-      operands[2] = const0_rtx;\n-\n-    /* Decide if we should generate indirect calls by loading the\n-       64-bit address of the callee into a register before performing\n-       the branch-and-link.  */\n-    callee = XEXP (operands[0], 0);\n-    if (GET_CODE (callee) == SYMBOL_REF\n-\t? (aarch64_is_long_call_p (callee)\n-\t   || aarch64_is_noplt_call_p (callee))\n-\t: !REG_P (callee))\n-      XEXP (operands[0], 0) = force_reg (Pmode, callee);\n-\n-    pat = gen_call_internal (operands[0], operands[1], operands[2]);\n-    aarch64_emit_call_insn (pat);\n+    aarch64_expand_call (NULL_RTX, operands[0], false);\n     DONE;\n   }\"\n )\n \n-(define_insn \"*call_reg\"\n-  [(call (mem:DI (match_operand:DI 0 \"register_operand\" \"r\"))\n+(define_insn \"*call_insn\"\n+  [(call (mem:DI (match_operand:DI 0 \"aarch64_call_insn_operand\" \"r, Usf\"))\n \t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n    (clobber (reg:DI LR_REGNUM))]\n   \"\"\n-  \"blr\\\\t%0\"\n-  [(set_attr \"type\" \"call\")]\n-)\n-\n-(define_insn \"*call_symbol\"\n-  [(call (mem:DI (match_operand:DI 0 \"\" \"\"))\n-\t (match_operand 1 \"\" \"\"))\n-   (use (match_operand 2 \"\" \"\"))\n-   (clobber (reg:DI LR_REGNUM))]\n-  \"GET_CODE (operands[0]) == SYMBOL_REF\n-   && !aarch64_is_long_call_p (operands[0])\n-   && !aarch64_is_noplt_call_p (operands[0])\"\n-  \"bl\\\\t%a0\"\n-  [(set_attr \"type\" \"call\")]\n+  \"@\n+  blr\\\\t%0\n+  bl\\\\t%a0\"\n+  [(set_attr \"type\" \"call, call\")]\n )\n \n-(define_expand \"call_value_internal\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (match_operand 1 \"memory_operand\" \"\")\n-\t\t\t (match_operand 2 \"general_operand\" \"\")))\n-\t      (use (match_operand 3 \"\" \"\"))\n-\t      (clobber (reg:DI LR_REGNUM))])])\n-\n (define_expand \"call_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand 1 \"memory_operand\" \"\")\n@@ -791,90 +750,35 @@\n   \"\"\n   \"\n   {\n-    rtx callee, pat;\n-\n-    /* In an untyped call, we can get NULL for operand 3.  */\n-    if (operands[3] == NULL)\n-      operands[3] = const0_rtx;\n-\n-    /* Decide if we should generate indirect calls by loading the\n-       64-bit address of the callee into a register before performing\n-       the branch-and-link.  */\n-    callee = XEXP (operands[1], 0);\n-    if (GET_CODE (callee) == SYMBOL_REF\n-\t? (aarch64_is_long_call_p (callee)\n-\t   || aarch64_is_noplt_call_p (callee))\n-\t: !REG_P (callee))\n-      XEXP (operands[1], 0) = force_reg (Pmode, callee);\n-\n-    pat = gen_call_value_internal (operands[0], operands[1], operands[2],\n-                                   operands[3]);\n-    aarch64_emit_call_insn (pat);\n+    aarch64_expand_call (operands[0], operands[1], false);\n     DONE;\n   }\"\n )\n \n-(define_insn \"*call_value_reg\"\n+(define_insn \"*call_value_insn\"\n   [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"register_operand\" \"r\"))\n+\t(call (mem:DI (match_operand:DI 1 \"aarch64_call_insn_operand\" \"r, Usf\"))\n \t\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n    (clobber (reg:DI LR_REGNUM))]\n   \"\"\n-  \"blr\\\\t%1\"\n-  [(set_attr \"type\" \"call\")]\n-\n-)\n-\n-(define_insn \"*call_value_symbol\"\n-  [(set (match_operand 0 \"\" \"\")\n-\t(call (mem:DI (match_operand:DI 1 \"\" \"\"))\n-\t      (match_operand 2 \"\" \"\")))\n-   (use (match_operand 3 \"\" \"\"))\n-   (clobber (reg:DI LR_REGNUM))]\n-  \"GET_CODE (operands[1]) == SYMBOL_REF\n-   && !aarch64_is_long_call_p (operands[1])\n-   && !aarch64_is_noplt_call_p (operands[1])\"\n-  \"bl\\\\t%a1\"\n-  [(set_attr \"type\" \"call\")]\n+  \"@\n+  blr\\\\t%1\n+  bl\\\\t%a1\"\n+  [(set_attr \"type\" \"call, call\")]\n )\n \n-(define_expand \"sibcall_internal\"\n-  [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n-\t\t    (match_operand 1 \"general_operand\" \"\"))\n-\t      (return)\n-\t      (use (match_operand 2 \"\" \"\"))])])\n-\n (define_expand \"sibcall\"\n   [(parallel [(call (match_operand 0 \"memory_operand\" \"\")\n \t\t    (match_operand 1 \"general_operand\" \"\"))\n \t      (return)\n \t      (use (match_operand 2 \"\" \"\"))])]\n   \"\"\n   {\n-    rtx pat;\n-    rtx callee = XEXP (operands[0], 0);\n-    if (!REG_P (callee)\n-       && ((GET_CODE (callee) != SYMBOL_REF)\n-\t   || aarch64_is_noplt_call_p (callee)))\n-      XEXP (operands[0], 0) = force_reg (Pmode, callee);\n-\n-    if (operands[2] == NULL_RTX)\n-      operands[2] = const0_rtx;\n-\n-    pat = gen_sibcall_internal (operands[0], operands[1], operands[2]);\n-    aarch64_emit_call_insn (pat);\n+    aarch64_expand_call (NULL_RTX, operands[0], true);\n     DONE;\n   }\n )\n \n-(define_expand \"sibcall_value_internal\"\n-  [(parallel [(set (match_operand 0 \"\" \"\")\n-\t\t   (call (match_operand 1 \"memory_operand\" \"\")\n-\t\t\t (match_operand 2 \"general_operand\" \"\")))\n-\t      (return)\n-\t      (use (match_operand 3 \"\" \"\"))])])\n-\n (define_expand \"sibcall_value\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n \t\t   (call (match_operand 1 \"memory_operand\" \"\")\n@@ -883,28 +787,15 @@\n \t      (use (match_operand 3 \"\" \"\"))])]\n   \"\"\n   {\n-    rtx pat;\n-    rtx callee = XEXP (operands[1], 0);\n-    if (!REG_P (callee)\n-       && ((GET_CODE (callee) != SYMBOL_REF)\n-\t   || aarch64_is_noplt_call_p (callee)))\n-      XEXP (operands[1], 0) = force_reg (Pmode, callee);\n-\n-    if (operands[3] == NULL_RTX)\n-      operands[3] = const0_rtx;\n-\n-    pat = gen_sibcall_value_internal (operands[0], operands[1], operands[2],\n-                                      operands[3]);\n-    aarch64_emit_call_insn (pat);\n+    aarch64_expand_call (operands[0], operands[1], true);\n     DONE;\n   }\n )\n \n (define_insn \"*sibcall_insn\"\n   [(call (mem:DI (match_operand:DI 0 \"aarch64_call_insn_operand\" \"Ucs, Usf\"))\n \t (match_operand 1 \"\" \"\"))\n-   (return)\n-   (use (match_operand 2 \"\" \"\"))]\n+   (return)]\n   \"SIBLING_CALL_P (insn)\"\n   \"@\n    br\\\\t%0\n@@ -917,8 +808,7 @@\n \t(call (mem:DI\n \t\t(match_operand:DI 1 \"aarch64_call_insn_operand\" \"Ucs, Usf\"))\n \t      (match_operand 2 \"\" \"\")))\n-   (return)\n-   (use (match_operand 3 \"\" \"\"))]\n+   (return)]\n   \"SIBLING_CALL_P (insn)\"\n   \"@\n    br\\\\t%1"}, {"sha": "88e840f2898d2da3e51e753578ee59bce4f462fa", "filename": "gcc/config/aarch64/constraints.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47210a041b3b40319b8dee64f00d479b1781eb57/gcc%2Fconfig%2Faarch64%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fconstraints.md?ref=47210a041b3b40319b8dee64f00d479b1781eb57", "patch": "@@ -126,7 +126,8 @@\n (define_constraint \"Usf\"\n   \"@internal Usf is a symbol reference under the context where plt stub allowed.\"\n   (and (match_code \"symbol_ref\")\n-       (match_test \"!aarch64_is_noplt_call_p (op)\")))\n+       (match_test \"!(aarch64_is_noplt_call_p (op)\n+\t\t      || aarch64_is_long_call_p (op))\")))\n \n (define_constraint \"UsM\"\n   \"@internal"}]}