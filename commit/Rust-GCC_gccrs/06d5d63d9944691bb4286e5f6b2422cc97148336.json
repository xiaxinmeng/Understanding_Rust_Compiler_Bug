{"sha": "06d5d63d9944691bb4286e5f6b2422cc97148336", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDZkNWQ2M2Q5OTQ0NjkxYmI0Mjg2ZTVmNmIyNDIyY2M5NzE0ODMzNg==", "commit": {"author": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2020-03-27T05:02:56Z"}, "committer": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2020-03-27T05:02:56Z"}, "message": "modulo-sched: fix bootstrap compare-debug issue\n\nThis patch removes all debug insns from DDG analysis.  It fixes bootstrap\ncomparison failure on powerpc64le when running with -fmodulo-sched enabled.\n\n\t* ddg.c (create_ddg_dep_from_intra_loop_link): Remove assertions.\n\t(create_ddg_dep_no_link): Likewise.\n\t(add_cross_iteration_register_deps): Move debug instruction check.\n\tOther minor refactoring.\n\t(add_intra_loop_mem_dep): Do not check for debug instructions.\n\t(add_inter_loop_mem_dep): Likewise.\n\t(build_intra_loop_deps): Likewise.\n\t(create_ddg): Do not include debug insns into the graph.\n\t* ddg.h (struct ddg): Remove num_debug field.\n\t* modulo-sched.c (doloop_register_get): Adjust condition.\n\t(res_MII): Remove DDG num_debug field usage.\n\t(sms_schedule_by_order): Use assertion against debug insns.\n\t(ps_has_conflicts): Drop debug insn check.\n\ntestsuite:\n\n    \t* gcc.c-torture/execute/pr70127-debug-sms.c: New test.\n    \t* gcc.dg/torture/pr87197-debug-sms.c: New test.", "tree": {"sha": "bfa9ad03e474a6bd143e40add3388080049a765e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bfa9ad03e474a6bd143e40add3388080049a765e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06d5d63d9944691bb4286e5f6b2422cc97148336", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d5d63d9944691bb4286e5f6b2422cc97148336", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06d5d63d9944691bb4286e5f6b2422cc97148336", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06d5d63d9944691bb4286e5f6b2422cc97148336/comments", "author": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d69548a1b2c85220ac6354564fd272beb9263f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d69548a1b2c85220ac6354564fd272beb9263f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d69548a1b2c85220ac6354564fd272beb9263f"}], "stats": {"total": 267, "additions": 147, "deletions": 120}, "files": [{"sha": "c472a13f5da7a5bcd83a2bd0ae1badf217465190", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -1,3 +1,19 @@\n+2020-03-27  Roman Zhuykov  <zhroma@ispras.ru>\n+\n+\t* ddg.c (create_ddg_dep_from_intra_loop_link): Remove assertions.\n+\t(create_ddg_dep_no_link): Likewise.\n+\t(add_cross_iteration_register_deps): Move debug instruction check.\n+\tOther minor refactoring.\n+\t(add_intra_loop_mem_dep): Do not check for debug instructions.\n+\t(add_inter_loop_mem_dep): Likewise.\n+\t(build_intra_loop_deps): Likewise.\n+\t(create_ddg): Do not include debug insns into the graph.\n+\t* ddg.h (struct ddg): Remove num_debug field.\n+\t* modulo-sched.c (doloop_register_get): Adjust condition.\n+\t(res_MII): Remove DDG num_debug field usage.\n+\t(sms_schedule_by_order): Use assertion against debug insns.\n+\t(ps_has_conflicts): Drop debug insn check.\n+\n 2020-03-26  Richard Earnshaw  <rearnsha@arm.com>\n \n \tPR target/94220"}, {"sha": "3bea4d18ee886525e24bcde0529f2a43fad4300e", "filename": "gcc/ddg.c", "status": "modified", "additions": 63, "deletions": 106, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fddg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fddg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.c?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -185,9 +185,6 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n   else if (DEP_TYPE (link) == REG_DEP_OUTPUT)\n     t = OUTPUT_DEP;\n \n-  gcc_assert (!DEBUG_INSN_P (dest_node->insn) || t == ANTI_DEP);\n-  gcc_assert (!DEBUG_INSN_P (src_node->insn) || t == ANTI_DEP);\n-\n   /* We currently choose not to create certain anti-deps edges and\n      compensate for that by generating reg-moves based on the life-range\n      analysis.  The anti-deps that will be deleted are the ones which\n@@ -222,9 +219,9 @@ create_ddg_dep_from_intra_loop_link (ddg_ptr g, ddg_node_ptr src_node,\n         }\n     }\n \n-   latency = dep_cost (link);\n-   e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n-   add_edge_to_ddg (g, e);\n+  latency = dep_cost (link);\n+  e = create_ddg_edge (src_node, dest_node, t, dt, latency, distance);\n+  add_edge_to_ddg (g, e);\n }\n \n /* The same as the above function, but it doesn't require a link parameter.  */\n@@ -237,9 +234,6 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n   enum reg_note dep_kind;\n   struct _dep _dep, *dep = &_dep;\n \n-  gcc_assert (!DEBUG_INSN_P (to->insn) || d_t == ANTI_DEP);\n-  gcc_assert (!DEBUG_INSN_P (from->insn) || d_t == ANTI_DEP);\n-\n   if (d_t == ANTI_DEP)\n     dep_kind = REG_DEP_ANTI;\n   else if (d_t == OUTPUT_DEP)\n@@ -272,16 +266,15 @@ create_ddg_dep_no_link (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to,\n static void\n add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n {\n-  int regno = DF_REF_REGNO (last_def);\n   struct df_link *r_use;\n   int has_use_in_bb_p = false;\n-  rtx_insn *def_insn = DF_REF_INSN (last_def);\n-  ddg_node_ptr last_def_node = get_node_of_insn (g, def_insn);\n-  ddg_node_ptr use_node;\n+  int regno = DF_REF_REGNO (last_def);\n+  ddg_node_ptr last_def_node = get_node_of_insn (g, DF_REF_INSN (last_def));\n   df_ref first_def = df_bb_regno_first_def_find (g->bb, regno);\n+  ddg_node_ptr first_def_node = get_node_of_insn (g, DF_REF_INSN (first_def));\n+  ddg_node_ptr use_node;\n \n-  gcc_assert (last_def_node);\n-  gcc_assert (first_def);\n+  gcc_assert (last_def_node && first_def && first_def_node);\n \n   if (flag_checking && DF_REF_ID (last_def) != DF_REF_ID (first_def))\n     {\n@@ -300,6 +293,9 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \n       rtx_insn *use_insn = DF_REF_INSN (r_use->ref);\n \n+      if (DEBUG_INSN_P (use_insn))\n+\tcontinue;\n+\n       /* ??? Do not handle uses with DF_REF_IN_NOTE notes.  */\n       use_node = get_node_of_insn (g, use_insn);\n       gcc_assert (use_node);\n@@ -310,35 +306,28 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n \t     iteration.  Any such upwards exposed use appears before\n \t     the last_def def.  */\n \t  create_ddg_dep_no_link (g, last_def_node, use_node,\n-\t\t\t\t  DEBUG_INSN_P (use_insn) ? ANTI_DEP : TRUE_DEP,\n-\t\t\t\t  REG_DEP, 1);\n+\t\t\t\t  TRUE_DEP, REG_DEP, 1);\n \t}\n-      else if (!DEBUG_INSN_P (use_insn))\n+      else\n \t{\n \t  /* Add anti deps from last_def's uses in the current iteration\n \t     to the first def in the next iteration.  We do not add ANTI\n \t     dep when there is an intra-loop TRUE dep in the opposite\n \t     direction, but use regmoves to fix such disregarded ANTI\n \t     deps when broken.\tIf the first_def reaches the USE then\n-\t     there is such a dep.  */\n-\t  ddg_node_ptr first_def_node = get_node_of_insn (g,\n-\t\t\t\t\t\t\t  DF_REF_INSN (first_def));\n-\n-\t  gcc_assert (first_def_node);\n-\n-         /* Always create the edge if the use node is a branch in\n-            order to prevent the creation of reg-moves.  \n-            If the address that is being auto-inc or auto-dec in LAST_DEF\n-            is used in USE_INSN then do not remove the edge to make sure\n-            reg-moves will not be created for that address.  */\n-          if (DF_REF_ID (last_def) != DF_REF_ID (first_def)\n-              || !flag_modulo_sched_allow_regmoves\n+\t     there is such a dep.\n+\t     Always create the edge if the use node is a branch in\n+\t     order to prevent the creation of reg-moves.\n+\t     If the address that is being auto-inc or auto-dec in LAST_DEF\n+\t     is used in USE_INSN then do not remove the edge to make sure\n+\t     reg-moves will not be created for that address.  */\n+\t  if (DF_REF_ID (last_def) != DF_REF_ID (first_def)\n+\t      || !flag_modulo_sched_allow_regmoves\n \t      || JUMP_P (use_node->insn)\n-              || autoinc_var_is_used_p (DF_REF_INSN (last_def), use_insn)\n+\t      || autoinc_var_is_used_p (DF_REF_INSN (last_def), use_insn)\n \t      || def_has_ccmode_p (DF_REF_INSN (last_def)))\n-            create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n-                                    REG_DEP, 1);\n-\n+\t    create_ddg_dep_no_link (g, use_node, first_def_node, ANTI_DEP,\n+\t\t\t\t    REG_DEP, 1);\n \t}\n     }\n   /* Create an inter-loop output dependence between LAST_DEF (which is the\n@@ -348,19 +337,11 @@ add_cross_iteration_register_deps (ddg_ptr g, df_ref last_def)\n      defs starting with a true dependence to a use which can be in the\n      next iteration; followed by an anti dependence of that use to the\n      first def (i.e. if there is a use between the two defs.)  */\n-  if (!has_use_in_bb_p)\n-    {\n-      ddg_node_ptr dest_node;\n-\n-      if (DF_REF_ID (last_def) == DF_REF_ID (first_def))\n-\treturn;\n-\n-      dest_node = get_node_of_insn (g, DF_REF_INSN (first_def));\n-      gcc_assert (dest_node);\n-      create_ddg_dep_no_link (g, last_def_node, dest_node,\n-\t\t\t      OUTPUT_DEP, REG_DEP, 1);\n-    }\n+  if (!has_use_in_bb_p && DF_REF_ID (last_def) != DF_REF_ID (first_def))\n+    create_ddg_dep_no_link (g, last_def_node, first_def_node,\n+\t\t\t    OUTPUT_DEP, REG_DEP, 1);\n }\n+\n /* Build inter-loop dependencies, by looking at DF analysis backwards.  */\n static void\n build_inter_loop_deps (ddg_ptr g)\n@@ -417,13 +398,9 @@ add_intra_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n   if (mem_write_insn_p (from->insn))\n     {\n       if (mem_read_insn_p (to->insn))\n-\tcreate_ddg_dep_no_link (g, from, to,\n-\t\t\t\tDEBUG_INSN_P (to->insn)\n-\t\t\t\t? ANTI_DEP : TRUE_DEP, MEM_DEP, 0);\n+\tcreate_ddg_dep_no_link (g, from, to, TRUE_DEP, MEM_DEP, 0);\n       else\n-\tcreate_ddg_dep_no_link (g, from, to,\n-\t\t\t\tDEBUG_INSN_P (to->insn)\n-\t\t\t\t? ANTI_DEP : OUTPUT_DEP, MEM_DEP, 0);\n+\tcreate_ddg_dep_no_link (g, from, to, OUTPUT_DEP, MEM_DEP, 0);\n     }\n   else if (!mem_read_insn_p (to->insn))\n     create_ddg_dep_no_link (g, from, to, ANTI_DEP, MEM_DEP, 0);\n@@ -441,13 +418,9 @@ add_inter_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n   if (mem_write_insn_p (from->insn))\n     {\n       if (mem_read_insn_p (to->insn))\n-  \tcreate_ddg_dep_no_link (g, from, to,\n-\t\t\t\tDEBUG_INSN_P (to->insn)\n-\t\t\t\t? ANTI_DEP : TRUE_DEP, MEM_DEP, 1);\n+\tcreate_ddg_dep_no_link (g, from, to, TRUE_DEP, MEM_DEP, 1);\n       else if (from->cuid != to->cuid)\n-  \tcreate_ddg_dep_no_link (g, from, to,\n-\t\t\t\tDEBUG_INSN_P (to->insn)\n-\t\t\t\t? ANTI_DEP : OUTPUT_DEP, MEM_DEP, 1);\n+\tcreate_ddg_dep_no_link (g, from, to, OUTPUT_DEP, MEM_DEP, 1);\n     }\n   else\n     {\n@@ -456,13 +429,9 @@ add_inter_loop_mem_dep (ddg_ptr g, ddg_node_ptr from, ddg_node_ptr to)\n       else if (from->cuid != to->cuid)\n \t{\n \t  create_ddg_dep_no_link (g, from, to, ANTI_DEP, MEM_DEP, 1);\n-\t  if (DEBUG_INSN_P (from->insn) || DEBUG_INSN_P (to->insn))\n-\t    create_ddg_dep_no_link (g, to, from, ANTI_DEP, MEM_DEP, 1);\n-\t  else\n-\t    create_ddg_dep_no_link (g, to, from, TRUE_DEP, MEM_DEP, 1);\n+\t  create_ddg_dep_no_link (g, to, from, TRUE_DEP, MEM_DEP, 1);\n \t}\n     }\n-\n }\n \n /* Perform intra-block Data Dependency analysis and connect the nodes in\n@@ -491,20 +460,10 @@ build_intra_loop_deps (ddg_ptr g)\n       sd_iterator_def sd_it;\n       dep_t dep;\n \n-      if (! INSN_P (dest_node->insn))\n-\tcontinue;\n-\n       FOR_EACH_DEP (dest_node->insn, SD_LIST_BACK, sd_it, dep)\n \t{\n \t  rtx_insn *src_insn = DEP_PRO (dep);\n-\t  ddg_node_ptr src_node;\n-\n-\t  /* Don't add dependencies on debug insns to non-debug insns\n-\t     to avoid codegen differences between -g and -g0.  */\n-\t  if (DEBUG_INSN_P (src_insn) && !DEBUG_INSN_P (dest_node->insn))\n-\t    continue;\n-\n-\t  src_node = get_node_of_insn (g, src_insn);\n+\t  ddg_node_ptr src_node = get_node_of_insn (g, src_insn);\n \n \t  if (!src_node)\n \t    continue;\n@@ -521,8 +480,7 @@ build_intra_loop_deps (ddg_ptr g)\n \t  for (j = 0; j <= i; j++)\n \t    {\n \t      ddg_node_ptr j_node = &g->nodes[j];\n-\t      if (DEBUG_INSN_P (j_node->insn))\n-\t\tcontinue;\n+\n \t      if (mem_access_insn_p (j_node->insn))\n \t\t{\n \t\t  /* Don't bother calculating inter-loop dep if an intra-loop dep\n@@ -573,23 +531,21 @@ create_ddg (basic_block bb, int closing_branch_deps)\n   for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n-      if (! INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n+      if (!INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n \tcontinue;\n \n-      if (DEBUG_INSN_P (insn))\n-\tg->num_debug++;\n-      else\n+      if (NONDEBUG_INSN_P (insn))\n \t{\n \t  if (mem_read_insn_p (insn))\n \t    g->num_loads++;\n \t  if (mem_write_insn_p (insn))\n \t    g->num_stores++;\n+\t  num_nodes++;\n \t}\n-      num_nodes++;\n     }\n \n   /* There is nothing to do for this BB.  */\n-  if ((num_nodes - g->num_debug) <= 1)\n+  if (num_nodes <= 1)\n     {\n       free (g);\n       return NULL;\n@@ -604,38 +560,39 @@ create_ddg (basic_block bb, int closing_branch_deps)\n   for (insn = BB_HEAD (bb); insn != NEXT_INSN (BB_END (bb));\n        insn = NEXT_INSN (insn))\n     {\n-      if (! INSN_P (insn))\n-\t{\n-\t  if (! first_note && NOTE_P (insn)\n-\t      && NOTE_KIND (insn) !=  NOTE_INSN_BASIC_BLOCK)\n-\t    first_note = insn;\n-\t  continue;\n-\t}\n+      if (LABEL_P (insn) || NOTE_INSN_BASIC_BLOCK_P (insn))\n+\tcontinue;\n+\n+      if (!first_note && (INSN_P (insn) || NOTE_P (insn)))\n+\tfirst_note = insn;\n+\n+      if (!INSN_P (insn) || GET_CODE (PATTERN (insn)) == USE)\n+\tcontinue;\n+\n       if (JUMP_P (insn))\n \t{\n \t  gcc_assert (!g->closing_branch);\n \t  g->closing_branch = &g->nodes[i];\n \t}\n-      else if (GET_CODE (PATTERN (insn)) == USE)\n+\n+      if (NONDEBUG_INSN_P (insn))\n \t{\n-\t  if (! first_note)\n-\t    first_note = insn;\n-\t  continue;\n-\t}\n+\t  g->nodes[i].cuid = i;\n+\t  g->nodes[i].successors = sbitmap_alloc (num_nodes);\n+\t  bitmap_clear (g->nodes[i].successors);\n+\t  g->nodes[i].predecessors = sbitmap_alloc (num_nodes);\n+\t  bitmap_clear (g->nodes[i].predecessors);\n \n-      g->nodes[i].cuid = i;\n-      g->nodes[i].successors = sbitmap_alloc (num_nodes);\n-      bitmap_clear (g->nodes[i].successors);\n-      g->nodes[i].predecessors = sbitmap_alloc (num_nodes);\n-      bitmap_clear (g->nodes[i].predecessors);\n-      g->nodes[i].first_note = (first_note ? first_note : insn);\n+\t  gcc_checking_assert (first_note);\n+\t  g->nodes[i].first_note = first_note;\n \n-      g->nodes[i].aux.count = -1;\n-      g->nodes[i].max_dist = XCNEWVEC (int, num_nodes);\n-      for (j = 0; j < num_nodes; j++)\n-\tg->nodes[i].max_dist[j] = -1;\n+\t  g->nodes[i].aux.count = -1;\n+\t  g->nodes[i].max_dist = XCNEWVEC (int, num_nodes);\n+\t  for (j = 0; j < num_nodes; j++)\n+\t    g->nodes[i].max_dist[j] = -1;\n \n-      g->nodes[i++].insn = insn;\n+\t  g->nodes[i++].insn = insn;\n+\t}\n       first_note = NULL;\n     }\n "}, {"sha": "c5fb256cc11a1740bf3d8c29f48c15e0d757f3df", "filename": "gcc/ddg.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fddg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fddg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fddg.h?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -116,9 +116,6 @@ struct ddg\n   int num_loads;\n   int num_stores;\n \n-  /* Number of debug instructions in the BB.  */\n-  int num_debug;\n-\n   /* This array holds the nodes in the graph; it is indexed by the node\n      cuid, which follows the order of the instructions in the BB.  */\n   ddg_node_ptr nodes;"}, {"sha": "77254b31b422099b8e852ab8a3706092f0e1f0ed", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -369,7 +369,7 @@ doloop_register_get (rtx_insn *head, rtx_insn *tail)\n                              : prev_nondebug_insn (tail));\n \n   for (insn = head; insn != first_insn_not_to_check; insn = NEXT_INSN (insn))\n-    if (!DEBUG_INSN_P (insn) && reg_mentioned_p (reg, insn))\n+    if (NONDEBUG_INSN_P (insn) && reg_mentioned_p (reg, insn))\n       {\n         if (dump_file)\n         {\n@@ -428,7 +428,7 @@ res_MII (ddg_ptr g)\n   if (targetm.sched.sms_res_mii)\n     return targetm.sched.sms_res_mii (g);\n \n-  return ((g->num_nodes - g->num_debug) / issue_rate);\n+  return g->num_nodes / issue_rate;\n }\n \n \n@@ -2152,11 +2152,7 @@ sms_schedule_by_order (ddg_ptr g, int mii, int maxii, int *nodes_order)\n   \t  ddg_node_ptr u_node = &ps->g->nodes[u];\n \t  rtx_insn *insn = u_node->insn;\n \n-\t  if (!NONDEBUG_INSN_P (insn))\n-\t    {\n-\t      bitmap_clear_bit (tobe_scheduled, u);\n-\t      continue;\n-\t    }\n+\t  gcc_checking_assert (NONDEBUG_INSN_P (insn));\n \n \t  if (bitmap_bit_p (sched_nodes, u))\n \t    continue;\n@@ -3158,9 +3154,6 @@ ps_has_conflicts (partial_schedule_ptr ps, int from, int to)\n \t{\n \t  rtx_insn *insn = ps_rtl_insn (ps, crr_insn->id);\n \n-\t  if (!NONDEBUG_INSN_P (insn))\n-\t    continue;\n-\n \t  /* Check if there is room for the current insn.  */\n \t  if (!can_issue_more || state_dead_lock_p (curr_state))\n \t    return true;"}, {"sha": "98f090721d161c1b1e93ef71e3e3a0b81035c5d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -1,4 +1,9 @@\n-2020-03-26  Marek Polacek  <polacek@redhat.com>\n+2020-03-27  Roman Zhuykov  <zhroma@ispras.ru>\n+\n+\t* gcc.c-torture/execute/pr70127-debug-sms.c: New test.\n+\t* gcc.dg/torture/pr87197-debug-sms.c: New test.\n+\n+2020-03-27  Marek Polacek  <polacek@redhat.com>\n \n \tPR c++/94336 - template keyword accepted before destructor names.\n \t* g++.dg/template/template-keyword2.C: New test."}, {"sha": "46911789be882230e196603ee4c7527f93594a52", "filename": "gcc/testsuite/gcc.c-torture/execute/pr70127-debug-sms.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr70127-debug-sms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr70127-debug-sms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr70127-debug-sms.c?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-additional-options \"-fcompare-debug -fmodulo-sched\" } */\n+\n+struct S { int f; signed int g : 2; } a[1], c = {5, 1}, d;\n+short b;\n+\n+__attribute__((noinline, noclone)) void\n+foo (int x)\n+{\n+  if (x != 1)\n+    __builtin_abort ();\n+}\n+\n+int\n+main ()\n+{\n+  while (b++ <= 0)\n+    {\n+      struct S e = {1, 1};\n+      d = e = a[0] = c;\n+    }\n+  foo (a[0].g);\n+  return 0;\n+}"}, {"sha": "fbbf1b389ea64bc94f918bcd3233e67b23dfab64", "filename": "gcc/testsuite/gcc.dg/torture/pr87197-debug-sms.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87197-debug-sms.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06d5d63d9944691bb4286e5f6b2422cc97148336/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87197-debug-sms.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr87197-debug-sms.c?ref=06d5d63d9944691bb4286e5f6b2422cc97148336", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fcompare-debug -fmodulo-sched --param sms-min-sc=1\" } */\n+\n+int a, c, e, f, g;\n+void\n+h (int i)\n+{\n+  a = i;\n+}\n+void\n+j (char *i, long k)\n+{\n+  while (k--)\n+    c = *i++;\n+}\n+void\n+l (unsigned char *i, long k)\n+{\n+  unsigned char *b = i + k;\n+  while (i < b)\n+    {\n+      h (*i);\n+      i++;\n+    }\n+}\n+void\n+m ()\n+{\n+  while (e)\n+    {\n+      float d = g;\n+      l ((char *) &d, sizeof (g));\n+      if (f)\n+\tj ((char *) &d, sizeof (g));\n+    }\n+}"}]}