{"sha": "210c4ef4def87040cb3eda8b10f001a6083a3899", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjEwYzRlZjRkZWY4NzA0MGNiM2VkYThiMTBmMDAxYTYwODNhMzg5OQ==", "commit": {"author": {"name": "Geert Bosch", "email": "bosch@gnat.com", "date": "2001-10-08T13:24:19Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-10-08T13:24:19Z"}, "message": "ceinfo.adb: Add utility for consistency checking of einfo.ad[bs].\n\n2001-10-08  Geert Bosch  (bosch@gnat.com)\n\n\t* ceinfo.adb: Add utility for consistency checking of einfo.ad[bs].\n\n\t* csinfo.adb: Add utility for consistency checking of sinfo.ad[bs].\n\nFrom-SVN: r46074", "tree": {"sha": "e2a76d2bb7c95a66eff8f1290caf271b7d970f3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2a76d2bb7c95a66eff8f1290caf271b7d970f3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/210c4ef4def87040cb3eda8b10f001a6083a3899", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210c4ef4def87040cb3eda8b10f001a6083a3899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/210c4ef4def87040cb3eda8b10f001a6083a3899", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/210c4ef4def87040cb3eda8b10f001a6083a3899/comments", "author": null, "committer": null, "parents": [{"sha": "b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4075f6b7d43d4c22d12c0d63aa4dfa3c835177d"}], "stats": {"total": 850, "additions": 850, "deletions": 0}, "files": [{"sha": "f3f357184881b2593b574558161e3eab38fbecb3", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=210c4ef4def87040cb3eda8b10f001a6083a3899", "patch": "@@ -1,3 +1,9 @@\n+2001-10-08  Geert Bosch  (bosch@gnat.com)\n+\n+\t* ceinfo.adb: Add utility for consistency checking of einfo.ad[bs].\n+\n+\t* csinfo.adb: Add utility for consistency checking of sinfo.ad[bs].\n+\n 2001-10-07  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* 5oosinte.adb: Fix spelling error of \"separate\" as \"seperate\"."}, {"sha": "e5ab95c61bb3a61738deae2082ec973d86c7dfdc", "filename": "gcc/ada/ceinfo.adb", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2Fceinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2Fceinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fceinfo.adb?ref=210c4ef4def87040cb3eda8b10f001a6083a3899", "patch": "@@ -0,0 +1,208 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                               C E I N F O                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$                             --\n+--                                                                          --\n+--             Copyright (C) 1998 Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Program to check consistency of einfo.ads and einfo.adb. Checks that\n+--  field name usage is consistent, including comments mentioning fields.\n+\n+with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n+with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n+with Ada.Text_IO;                   use Ada.Text_IO;\n+\n+with GNAT.Spitbol;                  use GNAT.Spitbol;\n+with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n+with GNAT.Spitbol.Table_VString;\n+\n+procedure CEinfo is\n+\n+   package TV renames GNAT.Spitbol.Table_VString;\n+   use TV;\n+\n+   Infil  : File_Type;\n+   Lineno : Natural := 0;\n+\n+   Err : exception;\n+   --  Raised on fatal error\n+\n+   Fieldnm    : VString;\n+   Accessfunc : VString;\n+   Line       : VString;\n+\n+   Fields : GNAT.Spitbol.Table_VString.Table (500);\n+   --  Maps field names to underlying field access name\n+\n+   UC : Pattern := Any (\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\");\n+\n+   Fnam : Pattern := (UC & Break (' ')) * Fieldnm;\n+\n+   Field_Def : Pattern := \"--    \" & Fnam & \" (\" & Break (')') * Accessfunc;\n+\n+   Field_Ref : Pattern := \"   --    \" & Fnam & Break ('(') & Len (1) &\n+                            Break (')') * Accessfunc;\n+\n+   Field_Com : Pattern := \"   --    \" & Fnam & Span (' ') &\n+                            (Break (' ') or Rest) * Accessfunc;\n+\n+   Func_Hedr : Pattern := \"   function \" & Fnam;\n+\n+   Func_Retn : Pattern := \"      return \" & Break (' ') * Accessfunc;\n+\n+   Proc_Hedr : Pattern := \"   procedure \" & Fnam;\n+\n+   Proc_Setf : Pattern := \"      Set_\" & Break (' ') * Accessfunc;\n+\n+   procedure Next_Line;\n+   --  Read next line trimmed from Infil into Line and bump Lineno\n+\n+   procedure Next_Line is\n+   begin\n+      Line := Get_Line (Infil);\n+      Trim (Line);\n+      Lineno := Lineno + 1;\n+   end Next_Line;\n+\n+--  Start of processing for CEinfo\n+\n+begin\n+   Anchored_Mode := True;\n+   New_Line;\n+   Open (Infil, In_File, \"einfo.ads\");\n+\n+   Put_Line (\"Acquiring field names from spec\");\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Access Kinds --\");\n+\n+      if Match (Line, Field_Def) then\n+         Set (Fields, Fieldnm, Accessfunc);\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"Checking consistent references in spec\");\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Description of Defined\");\n+   end loop;\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Component_Alignment Control\");\n+\n+      if Match (Line, Field_Ref) then\n+         if Accessfunc /= \"synth\"\n+              and then\n+            Accessfunc /= \"special\"\n+              and then\n+            Accessfunc /= Get (Fields, Fieldnm)\n+         then\n+            if Present (Fields, Fieldnm) then\n+               Put_Line (\"*** field name incorrect at line \" & Lineno);\n+               Put_Line (\"      found field \" & Accessfunc);\n+               Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n+\n+            else\n+               Put_Line\n+                 (\"*** unknown field name \" & Fieldnm & \" at line \" & Lineno);\n+            end if;\n+         end if;\n+      end if;\n+   end loop;\n+\n+   Close (Infil);\n+   Open (Infil, In_File, \"einfo.adb\");\n+   Lineno := 0;\n+\n+   Put_Line (\"Check listing of fields in body\");\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Attribute Access Functions --\");\n+\n+      if Match (Line, Field_Com)\n+        and then Fieldnm /= \"(unused)\"\n+        and then Accessfunc /= Get (Fields, Fieldnm)\n+      then\n+         if Present (Fields, Fieldnm) then\n+            Put_Line (\"*** field name incorrect at line \" & Lineno);\n+            Put_Line (\"      found field \" & Accessfunc);\n+            Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n+\n+         else\n+            Put_Line\n+              (\"*** unknown field name \" & Fieldnm & \" at line \" & Lineno);\n+         end if;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"Check references in access routines in body\");\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Classification Functions --\");\n+\n+      if Match (Line, Func_Hedr) then\n+         null;\n+\n+      elsif Match (Line, Func_Retn)\n+        and then Accessfunc /= Get (Fields, Fieldnm)\n+        and then Fieldnm /= \"Mechanism\"\n+      then\n+         Put_Line (\"*** incorrect field at line \" & Lineno);\n+         Put_Line (\"      found field \" & Accessfunc);\n+         Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"Check references in set routines in body\");\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Attribute Set Procedures\");\n+   end loop;\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   ------------\");\n+\n+      if Match (Line, Proc_Hedr) then\n+         null;\n+\n+      elsif Match (Line, Proc_Setf)\n+        and then Accessfunc /= Get (Fields, Fieldnm)\n+        and then Fieldnm /= \"Mechanism\"\n+      then\n+         Put_Line (\"*** incorrect field at line \" & Lineno);\n+         Put_Line (\"      found field \" & Accessfunc);\n+         Put_Line (\"      expecting field \" & Get (Fields, Fieldnm));\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"All tests completed successfully, no errors detected\");\n+\n+end CEinfo;"}, {"sha": "4964f033ed40968d82212299a1e9c318966d8b87", "filename": "gcc/ada/csinfo.adb", "status": "added", "additions": 636, "deletions": 0, "changes": 636, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2Fcsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/210c4ef4def87040cb3eda8b10f001a6083a3899/gcc%2Fada%2Fcsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcsinfo.adb?ref=210c4ef4def87040cb3eda8b10f001a6083a3899", "patch": "@@ -0,0 +1,636 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                               C S I N F O                                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--                            $Revision$\n+--                                                                          --\n+--          Copyright (C) 1992-2001 Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 2,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT;  see file COPYING.  If not, write --\n+-- to  the Free Software Foundation,  59 Temple Place - Suite 330,  Boston, --\n+-- MA 02111-1307, USA.                                                      --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- It is now maintained by Ada Core Technologies Inc (http://www.gnat.com). --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Program to check consistency of sinfo.ads and sinfo.adb. Checks that\n+--  field name usage is consistent and that assertion cross-reference lists\n+--  are correct, as well as making sure that all the comments on field name\n+--  usage are consistent.\n+\n+with Ada.Strings.Unbounded;         use Ada.Strings.Unbounded;\n+with Ada.Strings.Unbounded.Text_IO; use Ada.Strings.Unbounded.Text_IO;\n+with Ada.Strings.Maps;              use Ada.Strings.Maps;\n+with Ada.Strings.Maps.Constants;    use Ada.Strings.Maps.Constants;\n+with Ada.Text_IO;                   use Ada.Text_IO;\n+\n+with GNAT.Spitbol;                  use GNAT.Spitbol;\n+with GNAT.Spitbol.Patterns;         use GNAT.Spitbol.Patterns;\n+with GNAT.Spitbol.Table_Boolean;\n+with GNAT.Spitbol.Table_VString;\n+\n+procedure CSinfo is\n+\n+   package TB renames GNAT.Spitbol.Table_Boolean;\n+   package TV renames GNAT.Spitbol.Table_VString;\n+   use TB, TV;\n+\n+   Infil  : File_Type;\n+   Lineno : Natural := 0;\n+\n+   Err : exception;\n+   --  Raised on fatal error\n+\n+   Done : exception;\n+   --  Raised after error is found to terminate run\n+\n+   WSP : Pattern := Span (' ' & ASCII.HT);\n+\n+   Fields   : TV.Table (300);\n+   Fields1  : TV.Table (300);\n+   Refs     : TV.Table (300);\n+   Refscopy : TV.Table (300);\n+   Special  : TB.Table (50);\n+   Inlines  : TV.Table (100);\n+\n+   --  The following define the standard fields used for binary operator,\n+   --  unary operator, and other expression nodes. Numbers in the range 1-5\n+   --  refer to the Fieldn fields. Letters D-R refer to flags:\n+\n+   --      D = Flag4\n+   --      E = Flag5\n+   --      F = Flag6\n+   --      G = Flag7\n+   --      H = Flag8\n+   --      I = Flag9\n+   --      J = Flag10\n+   --      K = Flag11\n+   --      L = Flag12\n+   --      M = Flag13\n+   --      N = Flag14\n+   --      O = Flag15\n+   --      P = Flag16\n+   --      Q = Flag17\n+   --      R = Flag18\n+\n+   Flags : TV.Table (20);\n+   --  Maps flag numbers to letters\n+\n+   N_Fields : Pattern := BreakX (\"JL\");\n+   E_Fields : Pattern := BreakX (\"5EFGHIJLOP\");\n+   U_Fields : Pattern := BreakX (\"1345EFGHIJKLOPQ\");\n+   B_Fields : Pattern := BreakX (\"12345EFGHIJKLOPQ\");\n+\n+   Line : VString;\n+   Bad  : Boolean;\n+\n+   Field       : VString := Nul;\n+   Fields_Used : VString := Nul;\n+   Name        : VString := Nul;\n+   Next        : VString := Nul;\n+   Node        : VString := Nul;\n+   Ref         : VString := Nul;\n+   Synonym     : VString := Nul;\n+   Nxtref      : VString := Nul;\n+\n+   Which_Field : aliased VString := Nul;\n+\n+   Node_Search : Pattern := WSP & \"--  N_\" & Rest * Node;\n+   Break_Punc  : Pattern := Break (\" .,\");\n+   Plus_Binary : Pattern := WSP & \"--  plus fields for binary operator\";\n+   Plus_Unary  : Pattern := WSP & \"--  plus fields for unary operator\";\n+   Plus_Expr   : Pattern := WSP & \"--  plus fields for expression\";\n+   Break_Syn   : Pattern := WSP &  \"--  \" & Break (' ') * Synonym &\n+                              \" (\" & Break (')') * Field;\n+   Break_Field : Pattern := BreakX ('-') * Field;\n+   Get_Field   : Pattern := BreakX (Decimal_Digit_Set) &\n+                              Span (Decimal_Digit_Set) * Which_Field;\n+   Break_WFld  : Pattern := Break (Which_Field'Access);\n+   Get_Funcsyn : Pattern := WSP & \"function \" & Rest * Synonym;\n+   Extr_Field  : Pattern := BreakX ('-') & \"-- \" & Rest * Field;\n+   Get_Procsyn : Pattern := WSP & \"procedure Set_\" & Rest * Synonym;\n+   Get_Inline  : Pattern := WSP & \"pragma Inline (\" & Break (')') * Name;\n+   Set_Name    : Pattern := \"Set_\" & Rest * Name;\n+   Func_Rest   : Pattern := \"   function \" & Rest * Synonym;\n+   Get_Nxtref  : Pattern := Break (',') * Nxtref & ',';\n+   Test_Syn    : Pattern := Break ('=') & \"= N_\" &\n+                              (Break (\" ,)\") or Rest) * Next;\n+   Chop_Comma  : Pattern := BreakX (',') * Next;\n+   Return_Fld  : Pattern := WSP & \"return \" & Break (' ') * Field;\n+   Set_Syn     : Pattern := \"   procedure Set_\" & Rest * Synonym;\n+   Set_Fld     : Pattern := WSP & \"Set_\" & Break (' ') * Field & \" (N, Val)\";\n+   Break_With  : Pattern := Break ('_') ** Field & \"_With_Parent\";\n+\n+   type VStringA is array (Natural range <>) of VString;\n+\n+   procedure Next_Line;\n+   --  Read next line trimmed from Infil into Line and bump Lineno\n+\n+   procedure Sort (A : in out VStringA);\n+   --  Sort a (small) array of VString's\n+\n+   procedure Next_Line is\n+   begin\n+      Line := Get_Line (Infil);\n+      Trim (Line);\n+      Lineno := Lineno + 1;\n+   end Next_Line;\n+\n+   procedure Sort (A : in out VStringA) is\n+      Temp : VString;\n+\n+   begin\n+      <<Sort>>\n+         for J in 1 .. A'Length - 1 loop\n+            if A (J) > A (J + 1) then\n+               Temp := A (J);\n+               A (J) := A (J + 1);\n+               A (J + 1) := Temp;\n+               goto Sort;\n+            end if;\n+         end loop;\n+   end Sort;\n+\n+--  Start of processing for CSinfo\n+\n+begin\n+   Anchored_Mode := True;\n+   New_Line;\n+   Open (Infil, In_File, \"sinfo.ads\");\n+   Put_Line (\"Check for field name consistency\");\n+\n+   --  Setup table for mapping flag numbers to letters\n+\n+   Set (Flags, \"4\",  V (\"D\"));\n+   Set (Flags, \"5\",  V (\"E\"));\n+   Set (Flags, \"6\",  V (\"F\"));\n+   Set (Flags, \"7\",  V (\"G\"));\n+   Set (Flags, \"8\",  V (\"H\"));\n+   Set (Flags, \"9\",  V (\"I\"));\n+   Set (Flags, \"10\", V (\"J\"));\n+   Set (Flags, \"11\", V (\"K\"));\n+   Set (Flags, \"12\", V (\"L\"));\n+   Set (Flags, \"13\", V (\"M\"));\n+   Set (Flags, \"14\", V (\"N\"));\n+   Set (Flags, \"15\", V (\"O\"));\n+   Set (Flags, \"16\", V (\"P\"));\n+   Set (Flags, \"17\", V (\"Q\"));\n+   Set (Flags, \"18\", V (\"R\"));\n+\n+   --  Special fields table. The following fields are not recorded or checked\n+   --  by Csinfo, since they are specially handled. This means that he both\n+   --  the field definitions, and the corresponding subprograms are ignored.\n+\n+   Set (Special, \"Analyzed\",                 True);\n+   Set (Special, \"Assignment_OK\",            True);\n+   Set (Special, \"Associated_Node\",          True);\n+   Set (Special, \"Cannot_Be_Constant\",       True);\n+   Set (Special, \"Chars\",                    True);\n+   Set (Special, \"Comes_From_Source\",        True);\n+   Set (Special, \"Do_Overflow_Check\",        True);\n+   Set (Special, \"Do_Range_Check\",           True);\n+   Set (Special, \"Entity\",                   True);\n+   Set (Special, \"Error_Posted\",             True);\n+   Set (Special, \"Etype\",                    True);\n+   Set (Special, \"Evaluate_Once\",            True);\n+   Set (Special, \"First_Itype\",              True);\n+   Set (Special, \"Has_Dynamic_Itype\",        True);\n+   Set (Special, \"Has_Dynamic_Range_Check\",  True);\n+   Set (Special, \"Has_Dynamic_Length_Check\", True);\n+   Set (Special, \"Has_Private_View\",         True);\n+   Set (Special, \"Is_Controlling_Actual\",    True);\n+   Set (Special, \"Is_Overloaded\",            True);\n+   Set (Special, \"Is_Static_Expression\",     True);\n+   Set (Special, \"Left_Opnd\",                True);\n+   Set (Special, \"Must_Not_Freeze\",          True);\n+   Set (Special, \"Parens\",                   True);\n+   Set (Special, \"Raises_Constraint_Error\",  True);\n+   Set (Special, \"Right_Opnd\",               True);\n+\n+   --  Loop to acquire information from node definitions in sinfo.ads,\n+   --  checking for consistency in Op/Flag assignments to each synonym\n+\n+   loop\n+      Bad := False;\n+      Next_Line;\n+      exit when Match (Line, \"   -- Node Access Functions\");\n+\n+      if Match (Line, Node_Search)\n+        and then not Match (Node, Break_Punc)\n+      then\n+         Fields_Used := Nul;\n+\n+      elsif Node = \"\" then\n+         null;\n+\n+      elsif Line = \"\" then\n+         Node := Nul;\n+\n+      elsif Match (Line, Plus_Binary) then\n+         Bad := Match (Fields_Used, B_Fields);\n+\n+      elsif Match (Line, Plus_Unary) then\n+         Bad := Match (Fields_Used, U_Fields);\n+\n+      elsif Match (Line, Plus_Expr) then\n+         Bad := Match (Fields_Used, E_Fields);\n+\n+      elsif not Match (Line, Break_Syn) then\n+         null;\n+\n+      elsif Match (Synonym, \"plus\") then\n+         null;\n+\n+      else\n+         Match (Field, Break_Field);\n+\n+         if not Present (Special, Synonym) then\n+\n+            if Present (Fields, Synonym) then\n+               if Field /= Get (Fields, Synonym) then\n+                  Put_Line\n+                    (\"Inconsistent field reference at line\" &\n+                     Lineno'Img & \" for \" & Synonym);\n+                  raise Done;\n+               end if;\n+\n+            else\n+               Set (Fields, Synonym, Field);\n+            end if;\n+\n+            Set (Refs, Synonym, Node & ',' & Get (Refs, Synonym));\n+            Match (Field, Get_Field);\n+\n+            if Match (Field, \"Flag\") then\n+               Which_Field := Get (Flags, Which_Field);\n+            end if;\n+\n+            if Match (Fields_Used, Break_WFld) then\n+               Put_Line\n+                 (\"Overlapping field at line \" & Lineno'Img &\n+                  \" for \" & Synonym);\n+               raise Done;\n+            end if;\n+\n+            Append (Fields_Used, Which_Field);\n+            Bad := Bad or Match (Fields_Used, N_Fields);\n+         end if;\n+      end if;\n+\n+      if Bad then\n+         Put_Line (\"fields conflict with standard fields for node \" & Node);\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for function consistency\");\n+\n+   --  Loop through field function definitions to make sure they are OK\n+\n+   Fields1 := Fields;\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Node Update\");\n+\n+      if Match (Line, Get_Funcsyn)\n+        and then not Present (Special, Synonym)\n+      then\n+         if not Present (Fields1, Synonym) then\n+            Put_Line\n+              (\"function on line \" &  Lineno &\n+               \" is for unused synonym\");\n+            raise Done;\n+         end if;\n+\n+         Next_Line;\n+\n+         if not Match (Line, Extr_Field) then\n+            raise Err;\n+         end if;\n+\n+         if Field /= Get (Fields1, Synonym) then\n+            Put_Line (\"Wrong field in function \" & Synonym);\n+            raise Done;\n+\n+         else\n+            Delete (Fields1, Synonym);\n+         end if;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for missing functions\");\n+\n+   declare\n+      List : TV.Table_Array := Convert_To_Array (Fields1);\n+\n+   begin\n+      if List'Length > 0 then\n+         Put_Line (\"No function for field synonym \" & List (1).Name);\n+         raise Done;\n+      end if;\n+   end;\n+\n+   --  Check field set procedures\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for set procedure consistency\");\n+\n+   Fields1 := Fields;\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Inline Pragmas\");\n+      exit when Match (Line, \"   -- Iterator Procedures\");\n+\n+      if Match (Line, Get_Procsyn)\n+        and then not Present (Special, Synonym)\n+      then\n+         if not Present (Fields1, Synonym) then\n+            Put_Line\n+              (\"procedure on line \" & Lineno & \" is for unused synonym\");\n+            raise Done;\n+         end if;\n+\n+         Next_Line;\n+\n+         if not Match (Line, Extr_Field) then\n+            raise Err;\n+         end if;\n+\n+         if Field /= Get (Fields1, Synonym) then\n+            Put_Line (\"Wrong field in procedure Set_\" & Synonym);\n+            raise Done;\n+\n+         else\n+            Delete (Fields1, Synonym);\n+         end if;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for missing set procedures\");\n+\n+   declare\n+      List : TV.Table_Array := Convert_To_Array (Fields1);\n+\n+   begin\n+      if List'Length > 0 then\n+         Put_Line (\"No procedure for field synonym Set_\" & List (1).Name);\n+         raise Done;\n+      end if;\n+   end;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check pragma Inlines are all for existing subprograms\");\n+\n+   Clear (Fields1);\n+   while not End_Of_File (Infil) loop\n+      Next_Line;\n+\n+      if Match (Line, Get_Inline)\n+        and then not Present (Special, Name)\n+      then\n+         exit when Match (Name, Set_Name);\n+\n+         if not Present (Fields, Name) then\n+            Put_Line\n+              (\"Pragma Inline on line \" & Lineno &\n+               \" does not correspond to synonym\");\n+            raise Done;\n+\n+         else\n+            Set (Inlines, Name, Get (Inlines, Name) & 'r');\n+         end if;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check no pragma Inlines were omitted\");\n+\n+   declare\n+      List : TV.Table_Array := Convert_To_Array (Fields);\n+      Nxt  : VString := Nul;\n+\n+   begin\n+      for M in List'Range loop\n+         Nxt := List (M).Name;\n+\n+         if Get (Inlines, Nxt) /= \"r\" then\n+            Put_Line (\"Incorrect pragma Inlines for \" & Nxt);\n+            raise Done;\n+         end if;\n+      end loop;\n+   end;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Clear (Inlines);\n+\n+   Close (Infil);\n+   Open (Infil, In_File, \"sinfo.adb\");\n+   Lineno := 0;\n+   Put_Line (\"Check references in functions in body\");\n+\n+   Refscopy := Refs;\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Field Access Functions --\");\n+   end loop;\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"   -- Field Set Procedures --\");\n+\n+      if Match (Line, Func_Rest)\n+        and then not Present (Special, Synonym)\n+      then\n+         Ref := Get (Refs, Synonym);\n+         Delete (Refs, Synonym);\n+\n+         if Ref = \"\" then\n+            Put_Line\n+              (\"Function on line \" & Lineno & \" is for unknown synonym\");\n+            raise Err;\n+         end if;\n+\n+         --  Alpha sort of references for this entry\n+\n+         declare\n+            Refa   : VStringA (1 .. 100);\n+            N      : Natural := 0;\n+\n+         begin\n+            loop\n+               exit when not Match (Ref, Get_Nxtref, Nul);\n+               N := N + 1;\n+               Refa (N) := Nxtref;\n+            end loop;\n+\n+            Sort (Refa (1 .. N));\n+            Next_Line;\n+            Next_Line;\n+            Next_Line;\n+\n+            --  Checking references for one entry\n+\n+            for M in 1 .. N loop\n+               Next_Line;\n+\n+               if not Match (Line, Test_Syn) then\n+                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n+                  raise Done;\n+               end if;\n+\n+               Match (Next, Chop_Comma);\n+\n+               if Next /= Refa (M) then\n+                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n+                  raise Done;\n+               end if;\n+            end loop;\n+\n+            Next_Line;\n+            Match (Line, Return_Fld);\n+\n+            if Field /= Get (Fields, Synonym) then\n+               Put_Line\n+                (\"Wrong field for function \" & Synonym & \" at line \" &\n+                 Lineno & \" should be \" & Get (Fields, Synonym));\n+               raise Done;\n+            end if;\n+         end;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for missing functions in body\");\n+\n+   declare\n+      List : TV.Table_Array := Convert_To_Array (Refs);\n+\n+   begin\n+      if List'Length /= 0 then\n+         Put_Line (\"Missing function \" & List (1).Name & \" in body\");\n+         raise Done;\n+      end if;\n+   end;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check Set procedures in body\");\n+   Refs := Refscopy;\n+\n+   loop\n+      Next_Line;\n+      exit when Match (Line, \"end\");\n+      exit when Match (Line, \"   -- Iterator Procedures\");\n+\n+      if Match (Line, Set_Syn)\n+        and then not Present (Special, Synonym)\n+      then\n+         Ref := Get (Refs, Synonym);\n+         Delete (Refs, Synonym);\n+\n+         if Ref = \"\" then\n+            Put_Line\n+              (\"Function on line \" & Lineno & \" is for unknown synonym\");\n+            raise Err;\n+         end if;\n+\n+         --  Alpha sort of references for this entry\n+\n+         declare\n+            Refa   : VStringA (1 .. 100);\n+            N      : Natural;\n+\n+         begin\n+            N := 0;\n+\n+            loop\n+               exit when not Match (Ref, Get_Nxtref, Nul);\n+               N := N + 1;\n+               Refa (N) := Nxtref;\n+            end loop;\n+\n+            Sort (Refa (1 .. N));\n+\n+            Next_Line;\n+            Next_Line;\n+            Next_Line;\n+\n+            --  Checking references for one entry\n+\n+            for M in 1 .. N loop\n+               Next_Line;\n+\n+               if not Match (Line, Test_Syn)\n+                 or else Next /= Refa (M)\n+               then\n+                  Put_Line (\"Expecting N_\" & Refa (M) & \" at line \" & Lineno);\n+                  raise Err;\n+               end if;\n+            end loop;\n+\n+            loop\n+               Next_Line;\n+               exit when Match (Line, Set_Fld);\n+            end loop;\n+\n+            Match (Field, Break_With);\n+\n+            if Field /= Get (Fields, Synonym) then\n+               Put_Line\n+                 (\"Wrong field for procedure Set_\" & Synonym &\n+                  \" at line \" & Lineno & \" should be \" &\n+                  Get (Fields, Synonym));\n+               raise Done;\n+            end if;\n+\n+            Delete (Fields1, Synonym);\n+         end;\n+      end if;\n+   end loop;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"Check for missing set procedures in body\");\n+\n+   declare\n+      List : TV.Table_Array := Convert_To_Array (Fields1);\n+\n+   begin\n+      if List'Length /= 0 then\n+         Put_Line (\"Missing procedure Set_\" & List (1).Name & \" in body\");\n+         raise Done;\n+      end if;\n+   end;\n+\n+   Put_Line (\"     OK\");\n+   New_Line;\n+   Put_Line (\"All tests completed successfully, no errors detected\");\n+\n+exception\n+   when Done =>\n+      null;\n+\n+end CSinfo;"}]}