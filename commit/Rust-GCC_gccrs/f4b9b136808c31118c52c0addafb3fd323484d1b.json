{"sha": "f4b9b136808c31118c52c0addafb3fd323484d1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRiOWIxMzY4MDhjMzExMThjNTJjMGFkZGFmYjNmZDMyMzQ4NGQxYg==", "commit": {"author": {"name": "Cl\u00e9ment Chigot", "email": "chigot.c@gmail.com", "date": "2020-05-29T09:39:42Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-08-10T23:45:16Z"}, "message": "runtime: revert eqtype for AIX\n\nAIX linker is not able to merge identical type descriptors in a single\nsymbol if there are coming from different object or shared object files.\nThis results into several pointers referencing the same type\ndescriptors.\nThus, eqtype is needed to ensure that these different symbols will be\nconsidered as the same type descriptor.\n\nFixes golang/go#39276\n\ngcc/go/ChangeLog:\n\n\t* go-c.h (struct go_create_gogo_args): Add need_eqtype field.\n\t* go-lang.c (go_langhook_init): Set need_eqtype.\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/235697", "tree": {"sha": "cc518ef3fc753c719afdcd1c2eb5476188f3c027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cc518ef3fc753c719afdcd1c2eb5476188f3c027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4b9b136808c31118c52c0addafb3fd323484d1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b9b136808c31118c52c0addafb3fd323484d1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4b9b136808c31118c52c0addafb3fd323484d1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4b9b136808c31118c52c0addafb3fd323484d1b/comments", "author": {"login": "Helflym", "id": 23002587, "node_id": "MDQ6VXNlcjIzMDAyNTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23002587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Helflym", "html_url": "https://github.com/Helflym", "followers_url": "https://api.github.com/users/Helflym/followers", "following_url": "https://api.github.com/users/Helflym/following{/other_user}", "gists_url": "https://api.github.com/users/Helflym/gists{/gist_id}", "starred_url": "https://api.github.com/users/Helflym/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Helflym/subscriptions", "organizations_url": "https://api.github.com/users/Helflym/orgs", "repos_url": "https://api.github.com/users/Helflym/repos", "events_url": "https://api.github.com/users/Helflym/events{/privacy}", "received_events_url": "https://api.github.com/users/Helflym/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "636686662326496f68451e7eb91882fe462f850a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/636686662326496f68451e7eb91882fe462f850a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/636686662326496f68451e7eb91882fe462f850a"}], "stats": {"total": 128, "additions": 107, "deletions": 21}, "files": [{"sha": "3a005d5dd69d46bb5d7a23d8a163f5b9a951f1f2", "filename": "gcc/go/go-c.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgo-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgo-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-c.h?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -50,6 +50,7 @@ struct go_create_gogo_args\n   const char* debug_escape_hash;\n   int64_t nil_check_size_threshold;\n   bool debug_optimization;\n+  bool need_eqtype;\n };\n \n extern void go_create_gogo (const struct go_create_gogo_args*);"}, {"sha": "2cfb41042bddfa7bcdc3c33bc92a805e120fdf26", "filename": "gcc/go/go-lang.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgo-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgo-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-lang.c?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -119,6 +119,7 @@ go_langhook_init (void)\n   args.debug_escape_hash = go_debug_escape_hash;\n   args.nil_check_size_threshold = TARGET_AIX ? -1 : 4096;\n   args.debug_optimization = go_debug_optimization;\n+  args.need_eqtype = TARGET_AIX ? true : false;\n   args.linemap = go_get_linemap();\n   args.backend = go_get_backend();\n   go_create_gogo (&args);"}, {"sha": "93aa18cec06758b7a013c07fa47e04bd9f14251f", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -1,4 +1,4 @@\n-307665073fce992ea8112f74b91954e770afcc70\n+c512af85eb8c75a759b5e4fc6b72041fe09b75f1\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "d295fd10136aa2b6da9eb819841d5fa5f56bd0bc", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -208,7 +208,7 @@ Expression::is_same_variable(Expression* a, Expression* b)\n // assignment.\n \n Expression*\n-Expression::convert_for_assignment(Gogo*, Type* lhs_type,\n+Expression::convert_for_assignment(Gogo* gogo, Type* lhs_type,\n \t\t\t\t   Expression* rhs, Location location)\n {\n   Type* rhs_type = rhs->type();\n@@ -229,7 +229,7 @@ Expression::convert_for_assignment(Gogo*, Type* lhs_type,\n                                                         location);\n     }\n   else if (!are_identical && rhs_type->interface_type() != NULL)\n-    return Expression::convert_interface_to_type(lhs_type, rhs, location);\n+    return Expression::convert_interface_to_type(gogo, lhs_type, rhs, location);\n   else if (lhs_type->is_slice_type() && rhs_type->is_nil_type())\n     {\n       // Assigning nil to a slice.\n@@ -498,7 +498,7 @@ Expression::convert_interface_to_interface(Type *lhs_type, Expression* rhs,\n // non-interface type.\n \n Expression*\n-Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n+Expression::convert_interface_to_type(Gogo* gogo, Type *lhs_type, Expression* rhs,\n                                       Location location)\n {\n   // We are going to evaluate RHS multiple times.\n@@ -507,8 +507,11 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n   // Build an expression to check that the type is valid.  It will\n   // panic with an appropriate runtime type error if the type is not\n   // valid.\n-  // (lhs_type != rhs_type ? panicdottype(lhs_type, rhs_type, inter_type) :\n-  //    nil /*dummy*/)\n+  // (lhs_type == rhs_type ? nil /*dummy*/ :\n+  //    panicdottype(lhs_type, rhs_type, inter_type))\n+  // For some Oses, we need to call runtime.eqtype instead of\n+  // lhs_type == rhs_type, as we may have unmerged type descriptors\n+  // from shared libraries.\n   Expression* lhs_type_expr = Expression::make_type_descriptor(lhs_type,\n                                                                 location);\n   Expression* rhs_descriptor =\n@@ -518,15 +521,23 @@ Expression::convert_interface_to_type(Type *lhs_type, Expression* rhs,\n   Expression* rhs_inter_expr = Expression::make_type_descriptor(rhs_type,\n                                                                 location);\n \n-  Expression* cond = Expression::make_binary(OPERATOR_NOTEQ, lhs_type_expr,\n-                                             rhs_descriptor, location);\n+  Expression* cond;\n+  if (gogo->need_eqtype()) {\n+    cond = Runtime::make_call(Runtime::EQTYPE, location,\n+                              2, lhs_type_expr,\n+                              rhs_descriptor);\n+  } else {\n+    cond = Expression::make_binary(OPERATOR_EQEQ, lhs_type_expr,\n+                                   rhs_descriptor, location);\n+  }\n+\n   rhs_descriptor = Expression::get_interface_type_descriptor(rhs);\n   Expression* panic = Runtime::make_call(Runtime::PANICDOTTYPE, location,\n                                          3, lhs_type_expr->copy(),\n                                          rhs_descriptor,\n                                          rhs_inter_expr);\n   Expression* nil = Expression::make_nil(location);\n-  Expression* check = Expression::make_conditional(cond, panic, nil,\n+  Expression* check = Expression::make_conditional(cond, nil, panic,\n                                                    location);\n \n   // If the conversion succeeds, pull out the value."}, {"sha": "acb2732bddea4ba6e59e33f3617900a7c1077119", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -1273,7 +1273,7 @@ class Expression\n   }\n \n   static Expression*\n-  convert_interface_to_type(Type*, Expression*, Location);\n+  convert_interface_to_type(Gogo*, Type*, Expression*, Location);\n \n   static Expression*\n   import_identifier(Import_function_body*, Location);"}, {"sha": "e026d6592ba0955fee6ec097d627a3467449a858", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -46,6 +46,8 @@ go_create_gogo(const struct go_create_gogo_args* args)\n   ::gogo->set_nil_check_size_threshold(args->nil_check_size_threshold);\n   if (args->debug_optimization)\n     ::gogo->set_debug_optimization(args->debug_optimization);\n+  if (args->need_eqtype)\n+    ::gogo->set_need_eqtype(args->need_eqtype);\n }\n \n // Parse the input files."}, {"sha": "13de74bc8700e263f120c45c159f6f654aec7eef", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -57,6 +57,7 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n     debug_escape_level_(0),\n     debug_optimization_(false),\n     nil_check_size_threshold_(4096),\n+    need_eqtype_(false),\n     verify_types_(),\n     interface_types_(),\n     specific_type_functions_(),"}, {"sha": "45be1732aa0fa97f39323bf1104f7023cbc9f77d", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -360,6 +360,17 @@ class Gogo\n   set_nil_check_size_threshold(int64_t bytes)\n   { this->nil_check_size_threshold_ = bytes; }\n \n+  // Return whether runtime.eqtype calls are needed when comparing\n+  // type descriptors.\n+  bool\n+  need_eqtype() const\n+  { return this->need_eqtype_; }\n+\n+  // Set if calls to runtime.eqtype are needed.\n+  void\n+  set_need_eqtype(bool b)\n+  { this->need_eqtype_ = b; }\n+\n   // Import a package.  FILENAME is the file name argument, LOCAL_NAME\n   // is the local name to give to the package.  If LOCAL_NAME is empty\n   // the declarations are added to the global scope.\n@@ -1161,6 +1172,9 @@ class Gogo\n   bool debug_optimization_;\n   // Nil-check size threshhold.\n   int64_t nil_check_size_threshold_;\n+  // Whether runtime.eqtype calls are needed when comparing type\n+  // descriptors.\n+  bool need_eqtype_;\n   // A list of types to verify.\n   std::vector<Type*> verify_types_;\n   // A list of interface types defined while parsing."}, {"sha": "0796cbaadceadedc779e90171f9920af03c58da5", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -340,6 +340,9 @@ DEF_GO_RUNTIME(PANICDOTTYPE, \"runtime.panicdottype\", P3(TYPE, TYPE, TYPE),\n // Return whether we can convert a type to an interface type.\n DEF_GO_RUNTIME(IFACET2IP, \"runtime.ifaceT2Ip\", P2(TYPE, TYPE), R1(BOOL))\n \n+// Compare two type descriptors for equality.\n+DEF_GO_RUNTIME(EQTYPE, \"runtime.eqtype\", P2(TYPE, TYPE), R1(BOOL))\n+\n // Compare two empty interface values.\n DEF_GO_RUNTIME(EFACEEQ, \"runtime.efaceeq\", P2(EFACE, EFACE), R1(BOOL))\n "}, {"sha": "b5b22cfd0f8c33944eefb1426abddc1d579d203c", "filename": "libgo/go/runtime/alg.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -276,7 +276,7 @@ func nilinterequal(p, q unsafe.Pointer) bool {\n }\n func efaceeq(x, y eface) bool {\n \tt := x._type\n-\tif t != y._type {\n+\tif !eqtype(t, y._type) {\n \t\treturn false\n \t}\n \tif t == nil {\n@@ -301,7 +301,7 @@ func ifaceeq(x, y iface) bool {\n \t\treturn false\n \t}\n \tt := *(**_type)(xtab)\n-\tif t != *(**_type)(y.tab) {\n+\tif !eqtype(t, *(**_type)(y.tab)) {\n \t\treturn false\n \t}\n \teq := t.equal\n@@ -322,7 +322,7 @@ func ifacevaleq(x iface, t *_type, p unsafe.Pointer) bool {\n \t\treturn false\n \t}\n \txt := *(**_type)(x.tab)\n-\tif xt != t {\n+\tif !eqtype(xt, t) {\n \t\treturn false\n \t}\n \teq := t.equal\n@@ -343,7 +343,7 @@ func ifaceefaceeq(x iface, y eface) bool {\n \t\treturn false\n \t}\n \txt := *(**_type)(x.tab)\n-\tif xt != y._type {\n+\tif !eqtype(xt, y._type) {\n \t\treturn false\n \t}\n \teq := xt.equal\n@@ -360,7 +360,7 @@ func efacevaleq(x eface, t *_type, p unsafe.Pointer) bool {\n \tif x._type == nil {\n \t\treturn false\n \t}\n-\tif x._type != t {\n+\tif !eqtype(x._type, t) {\n \t\treturn false\n \t}\n \teq := t.equal"}, {"sha": "71d64eec40b1813c32e6382d24fdb65977f20a90", "filename": "libgo/go/runtime/eqtype.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Feqtype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Feqtype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Feqtype.go?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !aix,gccgo\n+\n+package runtime\n+\n+import (\n+\t_ \"unsafe\"\n+)\n+\n+// go:linkname is required as eqtype is a compiler-called\n+// function on some OSes.\n+//\n+//go:linkname eqtype\n+\n+// Return whether two type descriptors are equal.\n+func eqtype(t1, t2 *_type) bool {\n+\treturn t1 == t2\n+}"}, {"sha": "6d32022945cb57bce262380a1a34f2a3066c087a", "filename": "libgo/go/runtime/eqtype_aix_gccgo.go", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Feqtype_aix_gccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Feqtype_aix_gccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Feqtype_aix_gccgo.go?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix,gccgo\n+\n+package runtime\n+\n+import (\n+\t_ \"unsafe\"\n+)\n+\n+// eqtype is a compiler-called function.\n+//\n+//go:linkname eqtype\n+\n+// Return whether two type descriptors are equal.\n+// This is gccgo-specific, as some linkers are not able\n+// to merge identical type descriptors coming from\n+// different object or shared object files.\n+func eqtype(t1, t2 *_type) bool {\n+\tswitch {\n+\tcase t1 == t2:\n+\t\treturn true\n+\tcase t1 == nil || t2 == nil:\n+\t\treturn false\n+\tcase t1.kind != t2.kind || t1.hash != t2.hash:\n+\t\treturn false\n+\tdefault:\n+\t\treturn t1.string() == t2.string()\n+\t}\n+}"}, {"sha": "5667ddb6b95b19c393017ff1da388fffa97490c8", "filename": "libgo/go/runtime/iface.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Fiface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4b9b136808c31118c52c0addafb3fd323484d1b/libgo%2Fgo%2Fruntime%2Fiface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fiface.go?ref=f4b9b136808c31118c52c0addafb3fd323484d1b", "patch": "@@ -232,7 +232,7 @@ func (m *itab) init() string {\n \t\t\tri++\n \t\t}\n \n-\t\tif lhsMethod.typ != rhsMethod.mtyp {\n+\t\tif !eqtype(lhsMethod.typ, rhsMethod.mtyp) {\n \t\t\tm.methods[1] = nil\n \t\t\treturn *lhsMethod.name\n \t\t}\n@@ -406,7 +406,7 @@ func ifaceI2I2(inter *_type, i iface) (iface, bool) {\n \n // Convert an empty interface to a pointer non-interface type.\n func ifaceE2T2P(t *_type, e eface) (unsafe.Pointer, bool) {\n-\tif t != e._type {\n+\tif !eqtype(t, e._type) {\n \t\treturn nil, false\n \t} else {\n \t\treturn e.data, true\n@@ -415,7 +415,7 @@ func ifaceE2T2P(t *_type, e eface) (unsafe.Pointer, bool) {\n \n // Convert a non-empty interface to a pointer non-interface type.\n func ifaceI2T2P(t *_type, i iface) (unsafe.Pointer, bool) {\n-\tif i.tab == nil || t != *(**_type)(i.tab) {\n+\tif i.tab == nil || !eqtype(t, *(**_type)(i.tab)) {\n \t\treturn nil, false\n \t} else {\n \t\treturn i.data, true\n@@ -424,7 +424,7 @@ func ifaceI2T2P(t *_type, i iface) (unsafe.Pointer, bool) {\n \n // Convert an empty interface to a non-pointer non-interface type.\n func ifaceE2T2(t *_type, e eface, ret unsafe.Pointer) bool {\n-\tif t != e._type {\n+\tif !eqtype(t, e._type) {\n \t\ttypedmemclr(t, ret)\n \t\treturn false\n \t} else {\n@@ -439,7 +439,7 @@ func ifaceE2T2(t *_type, e eface, ret unsafe.Pointer) bool {\n \n // Convert a non-empty interface to a non-pointer non-interface type.\n func ifaceI2T2(t *_type, i iface, ret unsafe.Pointer) bool {\n-\tif i.tab == nil || t != *(**_type)(i.tab) {\n+\tif i.tab == nil || !eqtype(t, *(**_type)(i.tab)) {\n \t\ttypedmemclr(t, ret)\n \t\treturn false\n \t} else {\n@@ -485,7 +485,7 @@ func ifaceT2Ip(to, from *_type) bool {\n \t\t\tri++\n \t\t}\n \n-\t\tif fromMethod.mtyp != toMethod.typ {\n+\t\tif !eqtype(fromMethod.mtyp, toMethod.typ) {\n \t\t\treturn false\n \t\t}\n "}]}