{"sha": "96a45535c32b2f22650347c5152dd0e791e8582d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZhNDU1MzVjMzJiMmYyMjY1MDM0N2M1MTUyZGQwZTc5MWU4NTgyZA==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-07T10:38:29Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-07T10:38:29Z"}, "message": "hard-reg-set.h: Add multiple include guard.\n\n\t* hard-reg-set.h: Add multiple include guard.\n\t* basic-block.h (struct loop): Add `sink' field.\n\t* loop.h: Include sbitmap.h, hard-reg-set.h, and basic-block.h.\n\t(emit_iv_add_mult): Delete.\n\t(loop_iv_add_mult_hoist, loop_iv_add_mult_sink): Define.\n\t(loop_iv_add_mult_emit_before, loop_insn_sink): Define.\n\t(unroll_loop): Remove end_insert_before argument.\n\t* loop.c (loop_givs_rescan): Remove end_insert_before argument.\n\t(maybe_eliminate_biv_1): Likewise.\n\t(emit_iv_add_mult): Delete.\n\t(gen_add_mult, loop_regs_update): New.\n\t(loop_insn_emit_after, loop_insn_emit_before): New.\n\t(loop_insn_sink, loop_insn_sink_or_swim): New.\n\t(emit_iv_add_mult): Delete.\n\t(scan_loop): Set loop->sink.\n\t(loop_givs_reduce): Use loop_insn_sink and its ilk.\n\t(loop_givs_rescan, strength_reduce, check_dbra_loop): Likewise.\n\t(maybe_eliminate_biv_1): Likewise.\n\t(maybe_eliminate_biv_1): Add basic block argument.\n\t* unroll.c (unroll_loop): Remove end_insert_before argument.\n\t(find_splittable_regs): Likewise.\n\t(find_splittable_regs): Use loop_insn_sink and its ilk.\n\t(find_splittable_givs, final_biv_value, final_giv_value): Likewise.\n\nFrom-SVN: r38766", "tree": {"sha": "e732de7860b16b8d7c4c01ec79928e4af7e71b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e732de7860b16b8d7c4c01ec79928e4af7e71b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96a45535c32b2f22650347c5152dd0e791e8582d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a45535c32b2f22650347c5152dd0e791e8582d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96a45535c32b2f22650347c5152dd0e791e8582d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96a45535c32b2f22650347c5152dd0e791e8582d/comments", "author": null, "committer": null, "parents": [{"sha": "804a718aac4681c268c0b3a4a713cc5abec1f0cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804a718aac4681c268c0b3a4a713cc5abec1f0cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804a718aac4681c268c0b3a4a713cc5abec1f0cd"}], "stats": {"total": 454, "additions": 297, "deletions": 157}, "files": [{"sha": "bcdb2ba6201ad0fc6b4ff59c1304346334a96839", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -1,3 +1,29 @@\n+2001-01-07  Michael Hayes  <mhayes@redhat.com>\n+\n+\t* hard-reg-set.h: Add multiple include guard.\n+\t* basic-block.h (struct loop): Add `sink' field.\n+\t* loop.h: Include sbitmap.h, hard-reg-set.h, and basic-block.h.\n+\t(emit_iv_add_mult): Delete.\n+\t(loop_iv_add_mult_hoist, loop_iv_add_mult_sink): Define.\n+\t(loop_iv_add_mult_emit_before, loop_insn_sink): Define.\n+\t(unroll_loop): Remove end_insert_before argument.\n+\t* loop.c (loop_givs_rescan): Remove end_insert_before argument.\n+\t(maybe_eliminate_biv_1): Likewise.\n+\t(emit_iv_add_mult): Delete.\n+\t(gen_add_mult, loop_regs_update): New.\n+\t(loop_insn_emit_after, loop_insn_emit_before): New.\n+\t(loop_insn_sink, loop_insn_sink_or_swim): New.\n+\t(emit_iv_add_mult): Delete.\n+\t(scan_loop): Set loop->sink.\n+\t(loop_givs_reduce): Use loop_insn_sink and its ilk.\n+\t(loop_givs_rescan, strength_reduce, check_dbra_loop): Likewise.\n+\t(maybe_eliminate_biv_1): Likewise.\n+\t(maybe_eliminate_biv_1): Add basic block argument.\n+\t* unroll.c (unroll_loop): Remove end_insert_before argument.\n+\t(find_splittable_regs): Likewise.\n+\t(find_splittable_regs): Use loop_insn_sink and its ilk.\n+\t(find_splittable_givs, final_biv_value, final_giv_value): Likewise.\n+\n 2001-01-07  Michael Hayes  <mhayes@redhat.com>\n \n \t* loop.h (loop_insn_hoist): New prototype."}, {"sha": "f86ff3cbcbad16fb58bda40c30d43426d40f07e5", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -365,6 +365,9 @@ struct loop\n   /* Place in the loop where control enters.  */\n   rtx scan_start;\n \n+  /* The position where to sink insns out of the loop.  */\n+  rtx sink;\n+\n   /* List of all LABEL_REFs which refer to code labels outside the\n      loop.  Used by routines that need to know all loop exits, such as\n      final_biv_value and final_giv_value."}, {"sha": "57ab2860421c5d4f2040344013242dc704250d5c", "filename": "gcc/hard-reg-set.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Fhard-reg-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Fhard-reg-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhard-reg-set.h?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -18,6 +18,8 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n+#ifndef _HARD_REG_SET_H\n+#define _HARD_REG_SET_H 1\n \n /* Define the type of a set of hard registers.  */\n \n@@ -472,3 +474,5 @@ extern int n_non_fixed_regs;\n /* Vector indexed by hardware reg giving its name.  */\n \n extern const char * reg_names[FIRST_PSEUDO_REGISTER];\n+\n+#endif /* _HARD_REG_SET_H */"}, {"sha": "2a2c23c0ff52a56ee41de0d512ad5c7512cdb8ec", "filename": "gcc/loop.c", "status": "modified", "additions": 221, "deletions": 102, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -188,7 +188,7 @@ static int loop_giv_reduce_benefit PARAMS((struct loop *, struct iv_class *,\n static void loop_givs_dead_check PARAMS((struct loop *, struct iv_class *));\n static void loop_givs_reduce PARAMS((struct loop *, struct iv_class *));\n static void loop_givs_rescan PARAMS((struct loop *, struct iv_class *,\n-\t\t\t\t     rtx *, rtx));\n+\t\t\t\t     rtx *));\n static void loop_ivs_free PARAMS((struct loop *));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n static void find_single_use_in_loop PARAMS ((struct loop_regs *, rtx, rtx));\n@@ -225,7 +225,8 @@ static int product_cheap_p PARAMS ((rtx, rtx));\n static int maybe_eliminate_biv PARAMS ((const struct loop *, struct iv_class *,\n \t\t\t\t\tint, int, int));\n static int maybe_eliminate_biv_1 PARAMS ((const struct loop *, rtx, rtx,\n-\t\t\t\t\t  struct iv_class *, int, rtx));\n+\t\t\t\t\t  struct iv_class *, int,\n+\t\t\t\t\t  basic_block, rtx));\n static int last_use_this_basic_block PARAMS ((rtx, rtx));\n static void record_initial PARAMS ((rtx, rtx, void *));\n static void update_reg_last_use PARAMS ((rtx, rtx));\n@@ -244,10 +245,15 @@ static void try_swap_copy_prop PARAMS ((const struct loop *, rtx,\n static int replace_label PARAMS ((rtx *, void *));\n static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n+static rtx gen_add_mult PARAMS ((rtx, rtx, rtx, rtx));\n+static void loop_regs_update PARAMS ((const struct loop *, rtx));\n static int iv_add_mult_cost PARAMS ((rtx, rtx, rtx, rtx));\n \n+static rtx loop_insn_emit_after PARAMS((const struct loop *, basic_block, \n+\t\t\t\t\trtx, rtx));\n static rtx loop_insn_emit_before PARAMS((const struct loop *, basic_block, \n \t\t\t\t\t rtx, rtx));\n+static rtx loop_insn_sink_or_swim PARAMS((const struct loop *, rtx));\n \n static void loop_dump_aux PARAMS ((const struct loop *, FILE *, int));\n void debug_biv PARAMS ((const struct induction *));\n@@ -568,6 +574,15 @@ scan_loop (loop, flags)\n \n   loop->scan_start = p;\n \n+  /* If loop end is the end of the current function, then emit a\n+     NOTE_INSN_DELETED after loop_end and set loop->sink to the dummy\n+     note insn.  This is the position we use when sinking insns out of\n+     the loop.  */\n+  if (NEXT_INSN (loop->end) != 0)\n+    loop->sink = NEXT_INSN (loop->end);\n+  else\n+    loop->sink = emit_note_after (NOTE_INSN_DELETED, loop->end);\n+\n   /* Set up variables describing this loop.  */\n   prescan_loop (loop);\n   threshold = (loop_info->has_call ? 1 : 2) * (1 + n_non_fixed_regs);\n@@ -3908,20 +3923,22 @@ loop_givs_reduce (loop, bl)\n \t\tinsert_before = v->insn;\n \t      \n \t      if (tv->mult_val == const1_rtx)\n-\t\temit_iv_add_mult (tv->add_val, v->mult_val,\n-\t\t\t\t  v->new_reg, v->new_reg, insert_before);\n+\t\tloop_iv_add_mult_emit_before (loop, tv->add_val, v->mult_val,\n+\t\t\t\t\t      v->new_reg, v->new_reg, \n+\t\t\t\t\t      0, insert_before);\n \t      else /* tv->mult_val == const0_rtx */\n \t\t/* A multiply is acceptable here\n \t\t   since this is presumed to be seldom executed.  */\n-\t\temit_iv_add_mult (tv->add_val, v->mult_val,\n-\t\t\t\t  v->add_val, v->new_reg, insert_before);\n+\t\tloop_iv_add_mult_emit_before (loop, tv->add_val, v->mult_val,\n+\t\t\t\t\t      v->add_val, v->new_reg, \n+\t\t\t\t\t      0, insert_before);\n \t    }\n \t  \n \t  /* Add code at loop start to initialize giv's reduced reg.  */\n \t  \n-\t  emit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),\n-\t\t\t    v->mult_val, v->add_val, v->new_reg,\n-\t\t\t    loop->start);\n+\t  loop_iv_add_mult_hoist (loop,\n+\t\t\t\t  extend_value_for_giv (v, bl->initial_value),\n+\t\t\t\t  v->mult_val, v->add_val, v->new_reg);\n \t}\n     }\n }\n@@ -3959,11 +3976,10 @@ loop_givs_dead_check (loop, bl)\n \n \n static void\n-loop_givs_rescan (loop, bl, reg_map, end_insert_before)\n+loop_givs_rescan (loop, bl, reg_map)\n      struct loop *loop;\n      struct iv_class *bl;\n      rtx *reg_map;\n-     rtx end_insert_before;\n {\n   struct induction *v;\n \n@@ -4042,22 +4058,12 @@ loop_givs_rescan (loop, bl, reg_map, end_insert_before)\n \t not replaceable.  The correct final value is the same as the\n \t value that the giv starts the reversed loop with.  */\n       if (bl->reversed && ! v->replaceable)\n-\temit_iv_add_mult (extend_value_for_giv (v, bl->initial_value),\n-\t\t\t  v->mult_val, v->add_val, v->dest_reg,\n-\t\t\t  end_insert_before);\n+\tloop_iv_add_mult_sink (loop, \n+\t\t\t       extend_value_for_giv (v, bl->initial_value),\n+\t\t\t       v->mult_val, v->add_val, v->dest_reg);\n       else if (v->final_value)\n-\t{\n-\t  /* If the loop has multiple exits, emit the insn before the\n-\t     loop to ensure that it will always be executed no matter\n-\t     how the loop exits.  Otherwise, emit the insn after the loop,\n-\t     since this is slightly more efficient.  */\n-\t  if (loop->exit_count)\n-\t    loop_insn_hoist (loop, \n-\t\t\t     gen_move_insn (v->dest_reg, v->final_value));\n-\t  else\n-\t    emit_insn_before (gen_move_insn (v->dest_reg, v->final_value),\n-\t\t\t      end_insert_before);\n-\t}\n+\tloop_insn_sink_or_swim (loop, \n+\t\t\t\tgen_move_insn (v->dest_reg, v->final_value));\n       \n       if (loop_dump_stream)\n \t{\n@@ -4207,24 +4213,11 @@ strength_reduce (loop, insn_count, flags)\n   /* Map of pseudo-register replacements.  */\n   rtx *reg_map = NULL;\n   int reg_map_size;\n-  rtx end_insert_before;\n   int unrolled_insn_copies = 0;\n   rtx test_reg = gen_rtx_REG (word_mode, LAST_VIRTUAL_REGISTER + 1);\n \n   addr_placeholder = gen_reg_rtx (Pmode);\n \n-  /* Save insn immediately after the loop_end.  Insns inserted after loop_end\n-     must be put before this insn, so that they will appear in the right\n-     order (i.e. loop order).\n-\n-     If loop_end is the end of the current function, then emit a\n-     NOTE_INSN_DELETED after loop_end and set end_insert_before to the\n-     dummy note insn.  */\n-  if (NEXT_INSN (loop->end) != 0)\n-    end_insert_before = NEXT_INSN (loop->end);\n-  else\n-    end_insert_before = emit_note_after (NOTE_INSN_DELETED, loop->end);\n-\n   ivs->n_regs = max_reg_before_loop;\n   ivs->regs = (struct iv *) xcalloc (ivs->n_regs, sizeof (struct iv));\n \n@@ -4237,7 +4230,7 @@ strength_reduce (loop, insn_count, flags)\n       /* Can still unroll the loop anyways, but indicate that there is no\n \t strength reduction info available.  */\n       if (flags & LOOP_UNROLL)\n-\tunroll_loop (loop, insn_count, end_insert_before, 0);\n+\tunroll_loop (loop, insn_count, 0);\n \n       loop_ivs_free (loop);\n       return;\n@@ -4366,7 +4359,7 @@ strength_reduce (loop, insn_count, flags)\n \t For each giv register that can be reduced now: if replaceable,\n \t substitute reduced reg wherever the old giv occurs;\n \t else add new move insn \"giv_reg = reduced_reg\".  */\n-      loop_givs_rescan (loop, bl, reg_map, end_insert_before);\n+      loop_givs_rescan (loop, bl, reg_map);\n \n       /* All the givs based on the biv bl have been reduced if they\n \t merit it.  */\n@@ -4420,22 +4413,8 @@ strength_reduce (loop, insn_count, flags)\n \t     value, so we don't need another one.  We can't calculate the\n \t     proper final value for such a biv here anyways.  */\n \t  if (bl->final_value && ! bl->reversed)\n-\t    {\n-\t      rtx insert_before;\n-\n-\t      /* If the loop has multiple exits, emit the insn before the\n-\t\t loop to ensure that it will always be executed no matter\n-\t\t how the loop exits.  Otherwise, emit the insn after the\n-\t\t loop, since this is slightly more efficient.  */\n-\t      if (loop->exit_count)\n-\t\tinsert_before = loop->start;\n-\t      else\n-\t\tinsert_before = end_insert_before;\n-\n-\t      emit_insn_before (gen_move_insn (bl->biv->dest_reg, \n-\t\t\t\t\t       bl->final_value),\n-\t\t\t\tend_insert_before);\n-\t    }\n+\t      loop_insn_sink_or_swim (loop, gen_move_insn\n+\t\t\t\t      (bl->biv->dest_reg, bl->final_value));\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Reg %d: biv eliminated\\n\",\n@@ -4489,7 +4468,7 @@ strength_reduce (loop, insn_count, flags)\n   if ((flags & LOOP_UNROLL)\n       || (loop_info->n_iterations > 0\n \t  && unrolled_insn_copies <= insn_count))\n-    unroll_loop (loop, insn_count, end_insert_before, 1);\n+    unroll_loop (loop, insn_count, 1);\n \n #ifdef HAVE_doloop_end\n   if (HAVE_doloop_end && (flags & LOOP_BCT) && flag_branch_on_count_reg)\n@@ -6863,40 +6842,38 @@ combine_givs (regs, bl)\n   free (can_combine);\n }\n \f\n-/* EMIT code before INSERT_BEFORE to set REG = B * M + A.  */\n+/* Generate sequence for REG = B * M + A.  */\n \n-void\n-emit_iv_add_mult (b, m, a, reg, insert_before)\n+static rtx\n+gen_add_mult (b, m, a, reg)\n      rtx b;          /* initial value of basic induction variable */\n      rtx m;          /* multiplicative constant */\n      rtx a;          /* additive constant */\n      rtx reg;        /* destination register */\n-     rtx insert_before;\n {\n   rtx seq;\n   rtx result;\n \n-  /* Prevent unexpected sharing of these rtx.  */\n-  a = copy_rtx (a);\n-  b = copy_rtx (b);\n-\n-  /* Increase the lifetime of any invariants moved further in code.  */\n-  update_reg_last_use (a, insert_before);\n-  update_reg_last_use (b, insert_before);\n-  update_reg_last_use (m, insert_before);\n-\n   start_sequence ();\n+  /* Use unsigned arithmetic.  */\n   result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 1);\n   if (reg != result)\n     emit_move_insn (reg, result);\n   seq = gen_sequence ();\n   end_sequence ();\n \n-  emit_insn_before (seq, insert_before);\n+  return seq;\n+}\n+\n+\n+/* Update registers created in insn sequence SEQ.  */\n \n-  /* It is entirely possible that the expansion created lots of new\n-     registers.  Iterate over the sequence we just created and\n-     record them all.  */\n+static void\n+loop_regs_update (loop, seq)\n+     const struct loop *loop ATTRIBUTE_UNUSED;\n+     rtx seq;\n+{\n+  /* Update register info for alias analysis.  */\n \n   if (GET_CODE (seq) == SEQUENCE)\n     {\n@@ -6916,8 +6893,99 @@ emit_iv_add_mult (b, m, a, reg, insert_before)\n     }\n }\n \n-/* Similar to emit_iv_add_mult, but compute cost rather than emitting\n-   insns.  */\n+\n+/* EMIT code before BEFORE_BB/BEFORE_INSN to set REG = B * M + A.  */\n+\n+void\n+loop_iv_add_mult_emit_before (loop, b, m, a, reg, before_bb, before_insn)\n+     const struct loop *loop;\n+     rtx b;          /* initial value of basic induction variable */\n+     rtx m;          /* multiplicative constant */\n+     rtx a;          /* additive constant */\n+     rtx reg;        /* destination register */\n+     basic_block before_bb;\n+     rtx before_insn;\n+{\n+  rtx seq;\n+\n+  if (! before_insn)\n+    {\n+      loop_iv_add_mult_hoist (loop, b, m, a, reg);\n+      return;\n+    }\n+\n+  /* Use copy_rtx to prevent unexpected sharing of these rtx.  */\n+  seq = gen_add_mult (copy_rtx (b), m, copy_rtx (a), reg);\n+\n+  /* Increase the lifetime of any invariants moved further in code.  */\n+  update_reg_last_use (a, before_insn);\n+  update_reg_last_use (b, before_insn);\n+  update_reg_last_use (m, before_insn);\n+\n+  loop_insn_emit_before (loop, before_bb, before_insn, seq);\n+\n+  /* It is possible that the expansion created lots of new registers.\n+     Iterate over the sequence we just created and record them all.  */\n+  loop_regs_update (loop, seq);\n+}\n+\n+\n+/* Emit insns in loop pre-header to set REG = B * M + A.  */\n+\n+void\n+loop_iv_add_mult_sink (loop, b, m, a, reg)\n+     const struct loop *loop;\n+     rtx b;          /* initial value of basic induction variable */\n+     rtx m;          /* multiplicative constant */\n+     rtx a;          /* additive constant */\n+     rtx reg;        /* destination register */\n+{\n+  rtx seq;\n+\n+  /* Use copy_rtx to prevent unexpected sharing of these rtx.  */\n+  seq = gen_add_mult (copy_rtx (b), m, copy_rtx (a), reg);\n+\n+  /* Increase the lifetime of any invariants moved further in code.\n+     ???? Is this really necessary?  */\n+  update_reg_last_use (a, loop->sink);\n+  update_reg_last_use (b, loop->sink);\n+  update_reg_last_use (m, loop->sink);\n+\n+  loop_insn_sink (loop, seq);\n+\n+  /* It is possible that the expansion created lots of new registers.\n+     Iterate over the sequence we just created and record them all.  */\n+  loop_regs_update (loop, seq);\n+}\n+\n+\n+/* Emit insns after loop to set REG = B * M + A.  */\n+\n+void\n+loop_iv_add_mult_hoist (loop, b, m, a, reg)\n+     const struct loop *loop;\n+     rtx b;          /* initial value of basic induction variable */\n+     rtx m;          /* multiplicative constant */\n+     rtx a;          /* additive constant */\n+     rtx reg;        /* destination register */\n+{\n+  rtx seq;\n+\n+  /* Use copy_rtx to prevent unexpected sharing of these rtx.  */\n+  seq = gen_add_mult (copy_rtx (b), m, copy_rtx (a), reg);\n+\n+  loop_insn_hoist (loop, seq);\n+\n+  /* It is possible that the expansion created lots of new registers.\n+     Iterate over the sequence we just created and record them all.  */\n+  loop_regs_update (loop, seq);\n+}\n+\n+\n+\n+/* Similar to gen_add_mult, but compute cost rather than generating\n+   sequence.  */\n+\n static int\n iv_add_mult_cost (b, m, a, reg)\n      rtx b;          /* initial value of basic induction variable */\n@@ -6929,7 +6997,7 @@ iv_add_mult_cost (b, m, a, reg)\n   rtx last, result;\n \n   start_sequence ();\n-  result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 0);\n+  result = expand_mult_add (b, reg, m, a, GET_MODE (reg), 1);\n   if (reg != result)\n     emit_move_insn (reg, result);\n   last = get_last_insn ();\n@@ -7517,8 +7585,7 @@ check_dbra_loop (loop, insn_count)\n \t      if ((REGNO_LAST_UID (bl->regno) != INSN_UID (first_compare))\n \t\t  || ! bl->init_insn\n \t\t  || REGNO_FIRST_UID (bl->regno) != INSN_UID (bl->init_insn))\n-\t\temit_insn_after (gen_move_insn (reg, final_value),\n-\t\t\t\t loop_end);\n+\t\tloop_insn_sink (loop, gen_move_insn (reg, final_value));\n \n \t      /* Delete compare/branch at end of loop.  */\n \t      delete_insn (PREV_INSN (loop_end));\n@@ -7630,17 +7697,16 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n   rtx reg = bl->biv->dest_reg;\n-  rtx loop_start = loop->start;\n-  rtx loop_end = loop->end;\n   rtx p;\n \n   /* Scan all insns in the loop, stopping if we find one that uses the\n      biv in a way that we cannot eliminate.  */\n \n-  for (p = loop_start; p != loop_end; p = NEXT_INSN (p))\n+  for (p = loop->start; p != loop->end; p = NEXT_INSN (p))\n     {\n       enum rtx_code code = GET_CODE (p);\n-      rtx where = threshold >= insn_count ? loop_start : p;\n+      basic_block where_bb = 0;\n+      rtx where_insn = threshold >= insn_count ? 0 : p;\n \n       /* If this is a libcall that sets a giv, skip ahead to its end.  */\n       if (GET_RTX_CLASS (code) == 'i')\n@@ -7666,7 +7732,7 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n       if ((code == INSN || code == JUMP_INSN || code == CALL_INSN)\n \t  && reg_mentioned_p (reg, PATTERN (p))\n \t  && ! maybe_eliminate_biv_1 (loop, PATTERN (p), p, bl,\n-\t\t\t\t      eliminate_p, where))\n+\t\t\t\t      eliminate_p, where_bb, where_insn))\n \t{\n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n@@ -7676,7 +7742,7 @@ maybe_eliminate_biv (loop, bl, eliminate_p, threshold, insn_count)\n \t}\n     }\n \n-  if (p == loop_end)\n+  if (p == loop->end)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream, \"biv %d %s eliminated.\\n\",\n@@ -7748,18 +7814,20 @@ biv_elimination_giv_has_0_offset (biv, giv, insn)\n \n    If BIV does not appear in X, return 1.\n \n-   If ELIMINATE_P is non-zero, actually do the elimination.  WHERE indicates\n-   where extra insns should be added.  Depending on how many items have been\n-   moved out of the loop, it will either be before INSN or at the start of\n-   the loop.  */\n+   If ELIMINATE_P is non-zero, actually do the elimination.\n+   WHERE_INSN/WHERE_BB indicate where extra insns should be added.\n+   Depending on how many items have been moved out of the loop, it\n+   will either be before INSN (when WHERE_INSN is non-zero) or at the\n+   start of the loop (when WHERE_INSN is zero).  */\n \n static int\n-maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n+maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where_bb, where_insn)\n      const struct loop *loop;\n      rtx x, insn;\n      struct iv_class *bl;\n      int eliminate_p;\n-     rtx where;\n+     basic_block where_bb;\n+     rtx where_insn;\n {\n   enum rtx_code code = GET_CODE (x);\n   rtx reg = bl->biv->dest_reg;\n@@ -7870,7 +7938,7 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\ttem = gen_reg_rtx (GET_MODE (v->new_reg));\n \n \t\temit_insn_before (gen_move_insn (tem, copy_rtx (v->add_val)),\n-\t\t\t\t  where);\n+\t\t\t\t  where_insn);\n \n \t\t/* Substitute the new register for its invariant value in\n \t\t   the compare expression.  */\n@@ -7936,7 +8004,9 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t  {\n \t\t    /* Otherwise, load it into a register.  */\n \t\t    tem = gen_reg_rtx (mode);\n-\t\t    emit_iv_add_mult (arg, v->mult_val, v->add_val, tem, where);\n+\t\t    loop_iv_add_mult_emit_before (loop, arg,\n+\t\t\t\t\t\t  v->mult_val, v->add_val,\n+\t\t\t\t\t\t  tem, where_bb, where_insn);\n \t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n \t\t  }\n \t\tif (apply_change_group ())\n@@ -7969,7 +8039,9 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t\t\t v->new_reg, 1);\n \n \t\t/* Compute value to compare against.  */\n-\t\temit_iv_add_mult (arg, v->mult_val, v->add_val, tem, where);\n+\t\tloop_iv_add_mult_emit_before (loop, arg, \n+\t\t\t\t\t      v->mult_val, v->add_val,\n+\t\t\t\t\t      tem, where_bb, where_insn);\n \t\t/* Use it in this insn.  */\n \t\tvalidate_change (insn, &XEXP (x, arg_operand), tem, 1);\n \t\tif (apply_change_group ())\n@@ -8005,8 +8077,9 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t\t\t\t     v->new_reg, 1);\n \n \t\t    /* Compute value to compare against.  */\n-\t\t    emit_iv_add_mult (arg, v->mult_val, v->add_val,\n-\t\t\t\t      tem, where);\n+\t\t    loop_iv_add_mult_emit_before (loop, arg, \n+\t\t\t\t\t\t  v->mult_val, v->add_val,\n+\t\t\t\t\t\t  tem, where_bb, where_insn);\n \t\t    validate_change (insn, &XEXP (x, arg_operand), tem, 1);\n \t\t    if (apply_change_group ())\n \t\t      return 1;\n@@ -8087,14 +8160,14 @@ maybe_eliminate_biv_1 (loop, x, insn, bl, eliminate_p, where)\n \t{\n \tcase 'e':\n \t  if (! maybe_eliminate_biv_1 (loop, XEXP (x, i), insn, bl,\n-\t\t\t\t       eliminate_p, where))\n+\t\t\t\t       eliminate_p, where_bb, where_insn))\n \t    return 0;\n \t  break;\n \n \tcase 'E':\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (! maybe_eliminate_biv_1 (loop, XVECEXP (x, i, j), insn, bl,\n-\t\t\t\t\t eliminate_p, where))\n+\t\t\t\t\t eliminate_p, where_bb, where_insn))\n \t      return 0;\n \t  break;\n \t}\n@@ -8152,7 +8225,7 @@ record_initial (dest, set, data)\n /* If any of the registers in X are \"old\" and currently have a last use earlier\n    than INSN, update them to have a last use of INSN.  Their actual last use\n    will be the previous insn but it will not have a valid uid_luid so we can't\n-   use it.  */\n+   use it.  X must be a source expression only.  */\n \n static void\n update_reg_last_use (x, insn)\n@@ -8162,11 +8235,15 @@ update_reg_last_use (x, insn)\n   /* Check for the case where INSN does not have a valid luid.  In this case,\n      there is no need to modify the regno_last_uid, as this can only happen\n      when code is inserted after the loop_end to set a pseudo's final value,\n-     and hence this insn will never be the last use of x.  */\n+     and hence this insn will never be the last use of x. \n+     ???? This comment is not correct.  See for example loop_givs_reduce.  \n+     This may insert an insn before another new insn.  */\n   if (GET_CODE (x) == REG && REGNO (x) < max_reg_before_loop\n       && INSN_UID (insn) < max_uid_for_loop\n       && REGNO_LAST_LUID (REGNO (x)) < INSN_LUID (insn))\n-    REGNO_LAST_UID (REGNO (x)) = INSN_UID (insn);\n+    {\n+      REGNO_LAST_UID (REGNO (x)) = INSN_UID (insn);\n+    }\n   else\n     {\n       register int i, j;\n@@ -9360,6 +9437,20 @@ replace_label (x, data)\n   return 0;\n }\n \f\n+/* Emit insn for PATTERN after WHERE_INSN in basic block WHERE_BB\n+   (ignored in the interim).  */\n+\n+static rtx\n+loop_insn_emit_after (loop, where_bb, where_insn, pattern)\n+     const struct loop *loop ATTRIBUTE_UNUSED;\n+     basic_block where_bb ATTRIBUTE_UNUSED;\n+     rtx where_insn;\n+     rtx pattern;\n+{\n+  return emit_insn_after (pattern, where_insn);\n+}\n+\n+\n /* If WHERE_INSN is non-zero emit insn for PATTERN before WHERE_INSN\n    in basic block WHERE_BB (ignored in the interim) within the loop\n    otherwise hoist PATTERN into the loop pre-header.  */\n@@ -9386,6 +9477,34 @@ loop_insn_hoist (loop, pattern)\n {\n   return loop_insn_emit_before (loop, 0, loop->start, pattern);\n }\n+\n+\n+/* Sink insn for PATTERN after the loop end.  */\n+\n+rtx\n+loop_insn_sink (loop, pattern)\n+     const struct loop *loop;\n+     rtx pattern;\n+{\n+  return loop_insn_emit_before (loop, 0, loop->sink, pattern);\n+}\n+\n+\n+/* If the loop has multiple exits, emit insn for PATTERN before the\n+   loop to ensure that it will always be executed no matter how the\n+   loop exits.  Otherwise, emit the insn for PATTERN after the loop,\n+   since this is slightly more efficient.  */\n+\n+static rtx\n+loop_insn_sink_or_swim (loop, pattern)\n+     const struct loop *loop;\n+     rtx pattern;\n+{\n+  if (loop->exit_count)\n+    return loop_insn_hoist (loop, pattern);\n+  else\n+    return loop_insn_sink (loop, pattern);\n+}\n \f\n static void\n loop_biv_dump (v, file, verbose)"}, {"sha": "f01bd67baab11f926e5942c1793292923606caa2", "filename": "gcc/loop.h", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -19,6 +19,9 @@ the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n #include \"bitmap.h\"\n+#include \"sbitmap.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n \n /* Flags passed to loop_optimize.  */\n #define LOOP_UNROLL 1\n@@ -386,11 +389,15 @@ extern FILE *loop_dump_stream;\n    unroll.c.  */\n int loop_invariant_p PARAMS ((const struct loop *, rtx));\n rtx get_condition_for_loop PARAMS ((const struct loop *, rtx));\n-void emit_iv_add_mult PARAMS ((rtx, rtx, rtx, rtx, rtx));\n+void loop_iv_add_mult_hoist PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n+void loop_iv_add_mult_sink PARAMS ((const struct loop *, rtx, rtx, rtx, rtx));\n+void loop_iv_add_mult_emit_before PARAMS ((const struct loop *, rtx, \n+\t\t\t\t\t   rtx, rtx, rtx,\n+\t\t\t\t\t   basic_block, rtx));\n rtx express_from PARAMS ((struct induction *, struct induction *));\n rtx extend_value_for_giv PARAMS ((struct induction *, rtx));\n \n-void unroll_loop PARAMS ((struct loop *, int, rtx, int));\n+void unroll_loop PARAMS ((struct loop *, int, int));\n rtx biv_total_increment PARAMS ((struct iv_class *));\n unsigned HOST_WIDE_INT loop_iterations PARAMS ((struct loop *));\n int precondition_loop_p PARAMS ((const struct loop *,\n@@ -404,6 +411,7 @@ int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n int loop_insn_first_p PARAMS ((rtx, rtx));\n typedef rtx (*loop_insn_callback) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n+rtx loop_insn_sink PARAMS((const struct loop *, rtx));\n rtx loop_insn_hoist PARAMS((const struct loop *, rtx));\n \n /* Forward declarations for non-static functions declared in doloop.c.  */"}, {"sha": "fbd52245e034833b4b0eacce1d41f133272fd9e4", "filename": "gcc/unroll.c", "status": "modified", "additions": 33, "deletions": 53, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Funroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96a45535c32b2f22650347c5152dd0e791e8582d/gcc%2Funroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funroll.c?ref=96a45535c32b2f22650347c5152dd0e791e8582d", "patch": "@@ -206,7 +206,7 @@ static void copy_loop_body PARAMS ((struct loop *, rtx, rtx,\n \t\t\t\t    struct inline_remap *, rtx, int,\n \t\t\t\t    enum unroll_types, rtx, rtx, rtx, rtx));\n static int find_splittable_regs PARAMS ((const struct loop *,\n-\t\t\t\t\t enum unroll_types, rtx, int));\n+\t\t\t\t\t enum unroll_types, int));\n static int find_splittable_givs PARAMS ((const struct loop *,\n \t\t\t\t\t struct iv_class *, enum unroll_types,\n \t\t\t\t\t rtx, int));\n@@ -222,19 +222,16 @@ static rtx ujump_to_loop_cont PARAMS ((rtx, rtx));\n /* Try to unroll one loop and split induction variables in the loop.\n \n    The loop is described by the arguments LOOP and INSN_COUNT.\n-   END_INSERT_BEFORE indicates where insns should be added which need\n-   to be executed when the loop falls through.  STRENGTH_REDUCTION_P\n-   indicates whether information generated in the strength reduction\n-   pass is available.\n+   STRENGTH_REDUCTION_P indicates whether information generated in the\n+   strength reduction pass is available.\n \n    This function is intended to be called from within `strength_reduce'\n    in loop.c.  */\n \n void\n-unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n+unroll_loop (loop, insn_count, strength_reduce_p)\n      struct loop *loop;\n      int insn_count;\n-     rtx end_insert_before;\n      int strength_reduce_p;\n {\n   struct loop_info *loop_info = LOOP_INFO (loop);\n@@ -1045,7 +1042,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n \n \t  sequence = gen_sequence ();\n \t  end_sequence ();\n-\t  emit_insn_before (sequence, loop_start);\n+\t  loop_insn_hoist (loop, sequence);\n \n \t  /* Only the last copy of the loop body here needs the exit\n \t     test, so set copy_end to exclude the compare/branch here,\n@@ -1163,8 +1160,7 @@ unroll_loop (loop, insn_count, end_insert_before, strength_reduce_p)\n   if (splitting_not_safe)\n     temp = 0;\n   else\n-    temp = find_splittable_regs (loop, unroll_type,\n-\t\t\t\t end_insert_before, unroll_number);\n+    temp = find_splittable_regs (loop, unroll_type, unroll_number);\n \n   /* find_splittable_regs may have created some new registers, so must\n      reallocate the reg_map with the new larger size, and must realloc\n@@ -2431,10 +2427,9 @@ biv_total_increment (bl)\n    times, since multiplies by small integers (1,2,3,4) are very cheap.  */\n \n static int\n-find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n+find_splittable_regs (loop, unroll_type, unroll_number)\n      const struct loop *loop;\n      enum unroll_types unroll_type;\n-     rtx end_insert_before;\n      int unroll_number;\n {\n   struct loop_ivs *ivs = LOOP_IVS (loop);\n@@ -2444,8 +2439,6 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n   rtx biv_final_value;\n   int biv_splittable;\n   int result = 0;\n-  rtx loop_start = loop->start;\n-  rtx loop_end = loop->end;\n \n   for (bl = ivs->list; bl; bl = bl->next)\n     {\n@@ -2469,7 +2462,7 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n       biv_final_value = 0;\n       if (unroll_type != UNROLL_COMPLETELY\n \t  && (loop->exit_count || unroll_type == UNROLL_NAIVE)\n-\t  && (REGNO_LAST_LUID (bl->regno) >= INSN_LUID (loop_end)\n+\t  && (REGNO_LAST_LUID (bl->regno) >= INSN_LUID (loop->end)\n \t      || ! bl->init_insn\n \t      || INSN_UID (bl->init_insn) >= max_uid_for_loop\n \t      || (REGNO_FIRST_LUID (bl->regno)\n@@ -2512,8 +2505,8 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n \t\t  rtx tem = gen_reg_rtx (bl->biv->mode);\n \n \t\t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t\t  emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n-\t\t\t\t    loop_start);\n+\t\t  loop_insn_hoist (loop, \n+\t\t\t\t   gen_move_insn (tem, bl->biv->src_reg));\n \n \t\t  if (loop_dump_stream)\n \t\t    fprintf (loop_dump_stream,\n@@ -2558,9 +2551,8 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n \t     how the loop exits.  Otherwise emit the insn after the loop,\n \t     since this is slightly more efficient.  */\n \t  if (! loop->exit_count)\n-\t    emit_insn_before (gen_move_insn (bl->biv->src_reg,\n-\t\t\t\t\t     biv_final_value),\n-\t\t\t      end_insert_before);\n+\t    loop_insn_sink (loop, gen_move_insn (bl->biv->src_reg,\n+\t\t\t\t\t\t biv_final_value));\n \t  else\n \t    {\n \t      /* Create a new register to hold the value of the biv, and then\n@@ -2571,11 +2563,9 @@ find_splittable_regs (loop, unroll_type, end_insert_before, unroll_number)\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n \t      record_base_value (REGNO (tem), bl->biv->add_val, 0);\n \n-\t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n-\t\t\t\tloop_start);\n-\t      emit_insn_before (gen_move_insn (bl->biv->src_reg,\n-\t\t\t\t\t       biv_final_value),\n-\t\t\t\tloop_start);\n+\t      loop_insn_hoist (loop, gen_move_insn (tem, bl->biv->src_reg));\n+\t      loop_insn_hoist (loop, gen_move_insn (bl->biv->src_reg,\n+\t\t\t\t\t\t    biv_final_value));\n \n \t      if (loop_dump_stream)\n \t\tfprintf (loop_dump_stream, \"Biv %d mapped to %d for split.\\n\",\n@@ -2717,9 +2707,8 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t     to its final value before loop start to ensure that this insn\n \t     will always be executed, no matter how we exit.  */\n \t  tem = gen_reg_rtx (v->mode);\n-\t  emit_insn_before (gen_move_insn (tem, v->dest_reg), loop_start);\n-\t  emit_insn_before (gen_move_insn (v->dest_reg, final_value),\n-\t\t\t    loop_start);\n+\t  loop_insn_hoist (loop, gen_move_insn (tem, v->dest_reg));\n+\t  loop_insn_hoist (loop, gen_move_insn (v->dest_reg, final_value));\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream, \"Giv %d mapped to %d for split.\\n\",\n@@ -2752,8 +2741,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t      rtx tem = gen_reg_rtx (bl->biv->mode);\n \n \t      record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t      emit_insn_before (gen_move_insn (tem, bl->biv->src_reg),\n-\t\t\t\tloop->start);\n+\t      loop_insn_hoist (loop, gen_move_insn (tem, bl->biv->src_reg));\n \t      biv_initial_value = tem;\n \t    }\n \t  biv_initial_value = extend_value_for_giv (v, biv_initial_value);\n@@ -2795,8 +2783,8 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t{\n \t\t  rtx tem = gen_reg_rtx (v->mode);\n \t\t  record_base_value (REGNO (tem), v->add_val, 0);\n-\t\t  emit_iv_add_mult (bl->initial_value, v->mult_val,\n-\t\t\t\t    v->add_val, tem, loop->start);\n+\t\t  loop_iv_add_mult_hoist (loop, bl->initial_value, v->mult_val,\n+\t\t\t\t\t  v->add_val, tem);\n \t\t  value = tem;\n \t\t}\n \n@@ -2923,17 +2911,15 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t     instruction on machines with complex addressing modes.\n \t\t     If we can't recognize it, then delete it and emit insns\n \t\t     to calculate the value from scratch.  */\n-\t\t  emit_insn_before (gen_rtx_SET (VOIDmode, tem,\n-\t\t\t\t\t\t copy_rtx (v->new_reg)),\n-\t\t\t\t    loop->start);\n+\t\t  loop_insn_hoist (loop, gen_rtx_SET (VOIDmode, tem,\n+\t\t\t\t\t\t      copy_rtx (v->new_reg)));\n \t\t  if (recog_memoized (PREV_INSN (loop->start)) < 0)\n \t\t    {\n \t\t      rtx sequence, ret;\n \n \t\t      /* We can't use bl->initial_value to compute the initial\n \t\t\t value, because the loop may have been preconditioned.\n-\t\t\t We must calculate it from NEW_REG.  Try using\n-\t\t\t force_operand instead of emit_iv_add_mult.  */\n+\t\t\t We must calculate it from NEW_REG.  */\n \t\t      delete_insn (PREV_INSN (loop->start));\n \n \t\t      start_sequence ();\n@@ -2942,7 +2928,7 @@ find_splittable_givs (loop, bl, unroll_type, increment, unroll_number)\n \t\t\temit_move_insn (tem, ret);\n \t\t      sequence = gen_sequence ();\n \t\t      end_sequence ();\n-\t\t      emit_insn_before (sequence, loop->start);\n+\t\t      loop_insn_hoist (loop, sequence);\n \n \t\t      if (loop_dump_stream)\n \t\t\tfprintf (loop_dump_stream,\n@@ -3140,7 +3126,6 @@ final_biv_value (loop, bl)\n      const struct loop *loop;\n      struct iv_class *bl;\n {\n-  rtx loop_end = loop->end;\n   unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n   rtx increment, tem;\n \n@@ -3182,11 +3167,8 @@ final_biv_value (loop, bl)\n \n \t  tem = gen_reg_rtx (bl->biv->mode);\n \t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t  /* Make sure loop_end is not the last insn.  */\n-\t  if (NEXT_INSN (loop_end) == 0)\n-\t    emit_note_after (NOTE_INSN_DELETED, loop_end);\n-\t  emit_iv_add_mult (increment, GEN_INT (n_iterations),\n-\t\t\t    bl->initial_value, tem, NEXT_INSN (loop_end));\n+\t  loop_iv_add_mult_sink (loop, increment, GEN_INT (n_iterations),\n+\t\t\t\t bl->initial_value, tem);\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,\n@@ -3222,7 +3204,7 @@ final_giv_value (loop, v)\n   struct iv_class *bl;\n   rtx insn;\n   rtx increment, tem;\n-  rtx insert_before, seq;\n+  rtx seq;\n   rtx loop_end = loop->end;\n   unsigned HOST_WIDE_INT n_iterations = LOOP_INFO (loop)->n_iterations;\n \n@@ -3279,15 +3261,13 @@ final_giv_value (loop, v)\n \t     We must search from the insn that sets the giv to the end\n \t     of the loop to calculate this value.  */\n \n-\t  insert_before = NEXT_INSN (loop_end);\n-\n \t  /* Put the final biv value in tem.  */\n \t  tem = gen_reg_rtx (v->mode);\n \t  record_base_value (REGNO (tem), bl->biv->add_val, 0);\n-\t  emit_iv_add_mult (extend_value_for_giv (v, increment),\n-\t\t\t    GEN_INT (n_iterations),\n-\t\t\t    extend_value_for_giv (v, bl->initial_value),\n-\t\t\t    tem, insert_before);\n+\t  loop_iv_add_mult_sink (loop, extend_value_for_giv (v, increment),\n+\t\t\t\t GEN_INT (n_iterations),\n+\t\t\t\t extend_value_for_giv (v, bl->initial_value),\n+\t\t\t\t tem);\n \n \t  /* Subtract off extra increments as we find them.  */\n \t  for (insn = NEXT_INSN (v->insn); insn != loop_end;\n@@ -3304,12 +3284,12 @@ final_giv_value (loop, v)\n \t\t\t\t\tOPTAB_LIB_WIDEN);\n \t\t    seq = gen_sequence ();\n \t\t    end_sequence ();\n-\t\t    emit_insn_before (seq, insert_before);\n+\t\t    loop_insn_sink (loop, seq);\n \t\t  }\n \t    }\n \n \t  /* Now calculate the giv's final value.  */\n-\t  emit_iv_add_mult (tem, v->mult_val, v->add_val, tem, insert_before);\n+\t  loop_iv_add_mult_sink (loop, tem, v->mult_val, v->add_val, tem);\n \n \t  if (loop_dump_stream)\n \t    fprintf (loop_dump_stream,"}]}