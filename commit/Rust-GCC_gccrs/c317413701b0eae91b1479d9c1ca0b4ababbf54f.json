{"sha": "c317413701b0eae91b1479d9c1ca0b4ababbf54f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzMxNzQxMzcwMWIwZWFlOTFiMTQ3OWQ5YzFjYTBiNGFiYWJiZjU0Zg==", "commit": {"author": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-09T22:24:01Z"}, "committer": {"name": "Doug Evans", "email": "dje@gnu.org", "date": "1996-01-09T22:24:01Z"}, "message": "(merge_attributes): Moved to tree.c.\n\nFrom-SVN: r10956", "tree": {"sha": "653d1251d571fc9d11e540855db77ba9a4936a3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/653d1251d571fc9d11e540855db77ba9a4936a3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c317413701b0eae91b1479d9c1ca0b4ababbf54f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c317413701b0eae91b1479d9c1ca0b4ababbf54f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c317413701b0eae91b1479d9c1ca0b4ababbf54f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c317413701b0eae91b1479d9c1ca0b4ababbf54f/comments", "author": null, "committer": null, "parents": [{"sha": "f3209e2f768a7da9c91f3a06ff3afdf84cc44134", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3209e2f768a7da9c91f3a06ff3afdf84cc44134", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3209e2f768a7da9c91f3a06ff3afdf84cc44134"}], "stats": {"total": 37, "additions": 0, "deletions": 37}, "files": [{"sha": "50fbad0ffbd7383a24edf964f8c55fc0db025d9b", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c317413701b0eae91b1479d9c1ca0b4ababbf54f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c317413701b0eae91b1479d9c1ca0b4ababbf54f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=c317413701b0eae91b1479d9c1ca0b4ababbf54f", "patch": "@@ -166,43 +166,6 @@ qualify_type (type, like)\n   return c_build_type_variant (type, constflag, volflag);\n }\n \f\n-/* Return an attribute list that is the union of a1 and a2.  */\n-tree\n-merge_attributes (a1, a2)\n-     register tree a1, a2;\n-{\n-  tree attributes;\n-\n-  /* Either one unset?  Take the set one.  */\n-\n-  if (! (attributes = a1))\n-    attributes = a2;\n-\n-  /* One that completely contains the other?  Take it.  */\n-\n-  else if (a2 && ! attribute_list_contained (a1, a2))\n-    if (attribute_list_contained (a2, a1))\n-      attributes = a2;\n-    else\n-      {\n-\t/* Pick the longest list, and hang on the other list.  */\n-\t/* ??? For the moment we punt on the issue of attrs with args.  */\n-\n-\tif (list_length (a1) < list_length (a2))\n-\t  attributes = a2, a2 = a1;\n-\n-\tfor (; a2; a2 = TREE_CHAIN (a2))\n-\t  if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n-\t\t\t\tattributes) == NULL_TREE)\n-\t    {\n-\t      a1 = copy_node (a2);\n-\t      TREE_CHAIN (a1) = attributes;\n-\t      attributes = a1;\n-\t    }\n-      }\n-  return attributes;\n-}\n-\n /* Return the common type of two types.\n    We assume that comptypes has already been done and returned 1;\n    if that isn't so, this may crash.  In particular, we assume that qualifiers"}]}