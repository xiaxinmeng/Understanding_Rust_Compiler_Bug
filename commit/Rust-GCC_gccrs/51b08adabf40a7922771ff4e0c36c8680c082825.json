{"sha": "51b08adabf40a7922771ff4e0c36c8680c082825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTFiMDhhZGFiZjQwYTc5MjI3NzFmZjRlMGMzNmM4NjgwYzA4MjgyNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-14T17:59:48Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2013-06-14T17:59:48Z"}, "message": "compiler: fix computation of Offsetof.\n\nThe implied offsets must be taken into account\nwhen the selector involves anonymous fields.\n\nFrom-SVN: r200098", "tree": {"sha": "0578244ff530b3ebc00aed42fca943c03feb3d58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0578244ff530b3ebc00aed42fca943c03feb3d58"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/51b08adabf40a7922771ff4e0c36c8680c082825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b08adabf40a7922771ff4e0c36c8680c082825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51b08adabf40a7922771ff4e0c36c8680c082825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51b08adabf40a7922771ff4e0c36c8680c082825/comments", "author": null, "committer": null, "parents": [{"sha": "24244e4debd3261c8237d15d940fd10df5b0005a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/24244e4debd3261c8237d15d940fd10df5b0005a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/24244e4debd3261c8237d15d940fd10df5b0005a"}], "stats": {"total": 49, "additions": 37, "deletions": 12}, "files": [{"sha": "afc183207f7f3e6da8b860f633772c65021512fa", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 24, "deletions": 12, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=51b08adabf40a7922771ff4e0c36c8680c082825", "patch": "@@ -7279,19 +7279,31 @@ Builtin_call_expression::do_numeric_constant_value(Numeric_constant* nc) const\n       Field_reference_expression* farg = arg->field_reference_expression();\n       if (farg == NULL)\n \treturn false;\n-      Expression* struct_expr = farg->expr();\n-      Type* st = struct_expr->type();\n-      if (st->struct_type() == NULL)\n-\treturn false;\n-      if (st->named_type() != NULL)\n-\tst->named_type()->convert(this->gogo_);\n-      unsigned int offset;\n-      if (!st->struct_type()->backend_field_offset(this->gogo_,\n-\t\t\t\t\t\t   farg->field_index(),\n-\t\t\t\t\t\t   &offset))\n-\treturn false;\n+      unsigned int total_offset = 0;\n+      while (true)\n+        {\n+          Expression* struct_expr = farg->expr();\n+          Type* st = struct_expr->type();\n+          if (st->struct_type() == NULL)\n+            return false;\n+          if (st->named_type() != NULL)\n+            st->named_type()->convert(this->gogo_);\n+          unsigned int offset;\n+          if (!st->struct_type()->backend_field_offset(this->gogo_,\n+\t\t\t\t\t\t       farg->field_index(),\n+\t\t\t\t\t\t       &offset))\n+            return false;\n+          total_offset += offset;\n+          if (farg->implicit() && struct_expr->field_reference_expression() != NULL)\n+            {\n+              // Go up until we reach the original base.\n+              farg = struct_expr->field_reference_expression();\n+              continue;\n+            }\n+          break;\n+        }\n       nc->set_unsigned_long(Type::lookup_integer_type(\"uintptr\"),\n-\t\t\t    static_cast<unsigned long>(offset));\n+\t\t\t    static_cast<unsigned long>(total_offset));\n       return true;\n     }\n   else if (this->code_ == BUILTIN_REAL || this->code_ == BUILTIN_IMAG)"}, {"sha": "36f4c0d79f22779a45841209b9deba23fe30a1d0", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=51b08adabf40a7922771ff4e0c36c8680c082825", "patch": "@@ -1860,6 +1860,15 @@ class Field_reference_expression : public Expression\n   field_index() const\n   { return this->field_index_; }\n \n+  // Return whether this node was implied by an anonymous field.\n+  bool\n+  implicit() const\n+  { return this->implicit_; }\n+\n+  void\n+  set_implicit(bool implicit)\n+  { this->implicit_ = implicit; }\n+\n   // Set the struct expression.  This is used when parsing.\n   void\n   set_struct_expression(Expression* expr)\n@@ -1914,6 +1923,9 @@ class Field_reference_expression : public Expression\n   Expression* expr_;\n   // The zero-based index of the field we are retrieving.\n   unsigned int field_index_;\n+  // Whether this node was emitted implicitly for an embedded field,\n+  // that is, expr_ is not the expr_ of the original user node.\n+  bool implicit_;\n   // Whether we have already emitted a fieldtrack call.\n   bool called_fieldtrack_;\n };"}, {"sha": "4fbb162edd18431a3b2945f5b175f63eba551d86", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/51b08adabf40a7922771ff4e0c36c8680c082825/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=51b08adabf40a7922771ff4e0c36c8680c082825", "patch": "@@ -4532,6 +4532,7 @@ Struct_type::field_reference_depth(Expression* struct_expr,\n \t      go_assert(sub != NULL);\n \t    }\n \t  sub->set_struct_expression(here);\n+          sub->set_implicit(true);\n \t}\n       else if (subdepth > found_depth)\n \tdelete sub;"}]}