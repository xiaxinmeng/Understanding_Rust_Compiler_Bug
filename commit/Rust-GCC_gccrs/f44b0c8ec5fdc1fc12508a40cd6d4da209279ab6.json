{"sha": "f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ0YjBjOGVjNWZkYzFmYzEyNTA4YTQwY2Q2ZDRkYTIwOTI3OWFiNg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-07-11T21:02:31Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-07-11T21:02:31Z"}, "message": "cp-tree.h (saved_scope): Make old_bindings a vector.\n\n\t* cp-tree.h (saved_scope): Make old_bindings a vector.\n\t(unuse_fields): Remove.\n\t* name-lookup.h (cxx_saved_binding): Define it.\n\t* class.c (pushclass): Don't use unuse_fields.\n\t* name-lookup.c (cxx_saved_binding_make): Remove.\n\t(store_binding): Add new bindings to a vector, using an\n\taccumulator style, rather than adding them to a list.\n\t(store_bindings): Adjust accordingly.\n\t(store_class_bindings): Likewise.\n\t(push_to_top_level): Likewise.\n\t(pop_from_top_level): Likewise.\n\t* optimize.c (maybe_clone_body): Must push_to_top_level and\n\tpop_from_top_level calls outside of loop.\n\t* parser.c (cp_parser_class_specifier): Move push_scope/pop_scope\n\tcalls here from cp_parser_late_parsing_default_args.\n\t(cp_parser_save_default_args): Record the class type in which the\n\tfunction is declared.\n\t(cp_parser_late_parsing_default_args): Do not call\n\tpush_nested_class/pop_nested_class.\n\t* search.c (dfs_unuse_fields): Remove.\n\t(unuse_fields): Remove.\n\n\t* g++.dg/parse/defarg8.C: New test.\n\nFrom-SVN: r84530", "tree": {"sha": "b47ca1ae95a6c5cdd74d9e1827122aa0590299ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b47ca1ae95a6c5cdd74d9e1827122aa0590299ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/comments", "author": null, "committer": null, "parents": [{"sha": "4dcf7d66acad759f4c62caaa39d8b981ced74892", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dcf7d66acad759f4c62caaa39d8b981ced74892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dcf7d66acad759f4c62caaa39d8b981ced74892"}], "stats": {"total": 219, "additions": 109, "deletions": 110}, "files": [{"sha": "ea3b13ff532793d064eea6c14c96ea374776e48c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -1,3 +1,27 @@\n+2004-07-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (saved_scope): Make old_bindings a vector.\n+\t(unuse_fields): Remove.\n+\t* name-lookup.h (cxx_saved_binding): Define it.\n+\t* class.c (pushclass): Don't use unuse_fields.\n+\t* name-lookup.c (cxx_saved_binding_make): Remove.\n+\t(store_binding): Add new bindings to a vector, using an\n+\taccumulator style, rather than adding them to a list.\n+\t(store_bindings): Adjust accordingly.\n+\t(store_class_bindings): Likewise.\n+\t(push_to_top_level): Likewise.\n+\t(pop_from_top_level): Likewise.\n+\t* optimize.c (maybe_clone_body): Must push_to_top_level and\n+\tpop_from_top_level calls outside of loop.\n+\t* parser.c (cp_parser_class_specifier): Move push_scope/pop_scope\n+\tcalls here from cp_parser_late_parsing_default_args.\n+\t(cp_parser_save_default_args): Record the class type in which the\n+\tfunction is declared.\n+\t(cp_parser_late_parsing_default_args): Do not call\n+\tpush_nested_class/pop_nested_class.\n+\t* search.c (dfs_unuse_fields): Remove.\n+\t(unuse_fields): Remove.\n+\n 2004-07-11  Joseph S. Myers  <jsm@polyomino.org.uk>\n \n \t* cp-lang.c (LANG_HOOKS_MAYBE_BUILD_CLEANUP, LANG_HOOKS_PUSHLEVEL,"}, {"sha": "f13ccac378bc9eaba1dd5f49a574c05930f55d84", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -5569,7 +5569,6 @@ pushclass (tree type)\n \t  if (type_decl && TREE_CODE (type_decl) == TYPE_DECL)\n \t    set_identifier_type_value (id, type_decl);\n \t}\n-      unuse_fields (type);\n     }\n   \n   cxx_remember_type_decls (CLASSTYPE_NESTED_UTDS (type));"}, {"sha": "6cfe2805caa3f8fab51f04605eaf345cc75ead77", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -630,7 +630,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n \n struct saved_scope GTY(())\n {\n-  cxx_saved_binding *old_bindings;\n+  VEC(cxx_saved_binding) *old_bindings;\n   tree old_namespace;\n   tree decl_ns_list;\n   tree class_name;\n@@ -4015,7 +4015,6 @@ extern void maybe_suppress_debug_info\t\t(tree);\n extern void note_debug_info_needed\t\t(tree);\n extern void push_class_decls\t\t\t(tree);\n extern void pop_class_decls\t\t\t(void);\n-extern void unuse_fields\t\t\t(tree);\n extern void print_search_statistics\t\t(void);\n extern void init_search_processing\t\t(void);\n extern void reinit_search_statistics\t\t(void);"}, {"sha": "c47c6beae72763a3b5642dfc3813ed1cee4ea7e4", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 34, "deletions": 52, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -4809,69 +4809,46 @@ pushtag (tree name, tree type, int globalize)\n   timevar_pop (TV_NAME_LOOKUP);\n }\n \f\n-/* Allocate storage for saving a C++ binding.  */\n-#define cxx_saved_binding_make() \\\n-  (ggc_alloc (sizeof (cxx_saved_binding)))\n-\n-struct cxx_saved_binding GTY(())\n-{\n-  /* Link that chains saved C++ bindings for a given name into a stack.  */\n-  cxx_saved_binding *previous;\n-  /* The name of the current binding.  */\n-  tree identifier;\n-  /* The binding we're saving.  */\n-  cxx_binding *binding;\n-  tree class_value;\n-  tree real_type_value;\n-};\n-\n /* Subroutines for reverting temporarily to top-level for instantiation\n    of templates and such.  We actually need to clear out the class- and\n    local-value slots of all identifiers, so that only the global values\n    are at all visible.  Simply setting current_binding_level to the global\n    scope isn't enough, because more binding levels may be pushed.  */\n struct saved_scope *scope_chain;\n \n-/* If ID is not already in the SEARCH_BINDINGS, prepend its binding\n-   information to OLD_BINDINGS.  Returns the new OLD_BINDINGS\n-   list.  */\n+/* If ID has not already been marked, add an appropriate binding to\n+   *OLD_BINDINGS.  */\n \n-static cxx_saved_binding *\n-store_binding (tree id,\n-\t       cxx_saved_binding *old_bindings,\n-\t       cxx_saved_binding *search_bindings)\n+static void\n+store_binding (tree id, VEC(cxx_saved_binding) **old_bindings)\n {\n   cxx_saved_binding *saved;\n-  cxx_saved_binding *t1;\n \n   if (!id\n       /* Note that we may have an IDENTIFIER_CLASS_VALUE even when\n \t we have no IDENTIFIER_BINDING if we have left the class\n \t scope, but cached the class-level declarations.  */\n       || !(IDENTIFIER_BINDING (id) || IDENTIFIER_CLASS_VALUE (id)))\n-     return old_bindings;\n+    return;\n \n-  for (t1 = search_bindings; t1; t1 = t1->previous)\n-    if (t1->identifier == id)\n-     return old_bindings;\n+  if (IDENTIFIER_MARKED (id))\n+    return;\n+  \n+  IDENTIFIER_MARKED (id) = 1;\n \n-  my_friendly_assert (TREE_CODE (id) == IDENTIFIER_NODE, 135);\n-  saved = cxx_saved_binding_make ();\n-  saved->previous = old_bindings;\n+  saved = VEC_safe_push (cxx_saved_binding, *old_bindings, NULL);\n   saved->identifier = id;\n   saved->binding = IDENTIFIER_BINDING (id);\n   saved->class_value = IDENTIFIER_CLASS_VALUE (id);;\n   saved->real_type_value = REAL_IDENTIFIER_TYPE_VALUE (id);\n   IDENTIFIER_BINDING (id) = NULL;\n   IDENTIFIER_CLASS_VALUE (id) = NULL_TREE;\n-  return saved;\n }\n \n-static cxx_saved_binding *\n-store_bindings (tree names, cxx_saved_binding *old_bindings)\n+static void\n+store_bindings (tree names, VEC(cxx_saved_binding) **old_bindings)\n {\n   tree t;\n-  cxx_saved_binding *search_bindings = old_bindings;\n \n   timevar_push (TV_NAME_LOOKUP);\n   for (t = names; t; t = TREE_CHAIN (t))\n@@ -4883,38 +4860,36 @@ store_bindings (tree names, cxx_saved_binding *old_bindings)\n       else\n \tid = DECL_NAME (t);\n \n-      old_bindings \n-\t= store_binding (id, old_bindings, search_bindings);\n+      store_binding (id, old_bindings);\n     }\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n /* Like store_bindings, but NAMES is a vector of cp_class_binding\n    objects, rather than a TREE_LIST.  */\n \n-static cxx_saved_binding *\n+static void\n store_class_bindings (VEC(cp_class_binding) *names, \n-\t\t      cxx_saved_binding *old_bindings)\n+\t\t      VEC(cxx_saved_binding) **old_bindings)\n {\n   size_t i;\n   cp_class_binding *cb;\n-  cxx_saved_binding *search_bindings = old_bindings;\n \n   timevar_push (TV_NAME_LOOKUP);\n   for (i = 0; \n        (cb = VEC_iterate(cp_class_binding, names, i));\n        ++i)\n-    old_bindings \n-      = store_binding (cb->identifier, old_bindings, search_bindings);\n-  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, old_bindings);\n+    store_binding (cb->identifier, old_bindings);\n+  timevar_pop (TV_NAME_LOOKUP);\n }\n \n void\n push_to_top_level (void)\n {\n   struct saved_scope *s;\n   struct cp_binding_level *b;\n-  cxx_saved_binding *old_bindings;\n+  cxx_saved_binding *sb;\n+  size_t i;\n   int need_pop;\n \n   timevar_push (TV_NAME_LOOKUP);\n@@ -4931,10 +4906,9 @@ push_to_top_level (void)\n   else\n     need_pop = 0;\n \n-  old_bindings = NULL;\n   if (scope_chain && previous_class_level)\n-    old_bindings = store_class_bindings (previous_class_level->class_shadowed,\n-\t\t\t\t\t old_bindings);\n+    store_class_bindings (previous_class_level->class_shadowed,\n+\t\t\t  &s->old_bindings);\n \n   /* Have to include the global scope, because class-scope decls\n      aren't listed anywhere useful.  */\n@@ -4949,18 +4923,23 @@ push_to_top_level (void)\n       if (global_scope_p (b))\n \tbreak;\n \n-      old_bindings = store_bindings (b->names, old_bindings);\n+      store_bindings (b->names, &s->old_bindings);\n       /* We also need to check class_shadowed to save class-level type\n \t bindings, since pushclass doesn't fill in b->names.  */\n       if (b->kind == sk_class)\n-\told_bindings = store_class_bindings (b->class_shadowed, old_bindings);\n+\tstore_class_bindings (b->class_shadowed, &s->old_bindings);\n \n       /* Unwind type-value slots back to top level.  */\n       for (t = b->type_shadowed; t; t = TREE_CHAIN (t))\n \tSET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (t), TREE_VALUE (t));\n     }\n+\n+  for (i = 0;\n+       (sb = VEC_iterate (cxx_saved_binding, s->old_bindings, i));\n+       ++i)\n+    IDENTIFIER_MARKED (sb->identifier) = 0;\n+\n   s->prev = scope_chain;\n-  s->old_bindings = old_bindings;\n   s->bindings = b;\n   s->need_pop_function_context = need_pop;\n   s->function_decl = current_function_decl;\n@@ -4978,6 +4957,7 @@ pop_from_top_level (void)\n {\n   struct saved_scope *s = scope_chain;\n   cxx_saved_binding *saved;\n+  size_t i;\n \n   timevar_push (TV_NAME_LOOKUP); \n   /* Clear out class-level bindings cache.  */\n@@ -4987,7 +4967,9 @@ pop_from_top_level (void)\n   current_lang_base = 0;\n \n   scope_chain = s->prev;\n-  for (saved = s->old_bindings; saved; saved = saved->previous)\n+  for (i = 0; \n+       (saved = VEC_iterate (cxx_saved_binding, s->old_bindings, i));\n+       ++i)\n     {\n       tree id = saved->identifier;\n "}, {"sha": "b7e59e8536b4c2500feb8e050d5572b605d3fa7e", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -51,10 +51,6 @@ extern void binding_table_foreach (binding_table, bt_foreach_proc, void *);\n extern binding_entry binding_table_find (binding_table, tree);\n extern void cxx_remember_type_decls (binding_table);\n \f\n-/* Datatype used to temporarily save C++ bindings (for implicit\n-   instantiations purposes and like).  Implemented in decl.c.  */\n-typedef struct cxx_saved_binding cxx_saved_binding;\n-\n /* Datatype that represents binding established by a declaration between\n    a name and a C++ entity.  */\n typedef struct cxx_binding cxx_binding;\n@@ -84,6 +80,20 @@ struct cxx_binding GTY(())\n   unsigned is_local : 1;\n };\n \n+/* Datatype used to temporarily save C++ bindings (for implicit\n+   instantiations purposes and like).  Implemented in decl.c.  */\n+typedef struct cxx_saved_binding GTY(())\n+{\n+  /* The name of the current binding.  */\n+  tree identifier;\n+  /* The binding we're saving.  */\n+  cxx_binding *binding;\n+  tree class_value;\n+  tree real_type_value;\n+} cxx_saved_binding;\n+\n+DEF_VEC_O(cxx_saved_binding);\n+\n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n extern void pop_binding (tree, tree);"}, {"sha": "8a3ebe6ebbeb012c9162bc187aadd49eec4d88d4", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -88,6 +88,7 @@ maybe_clone_body (tree fn)\n \n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n+  push_to_top_level ();\n   for (clone = TREE_CHAIN (fn);\n        clone && DECL_CLONED_FUNCTION_P (clone);\n        clone = TREE_CHAIN (clone))\n@@ -131,7 +132,6 @@ maybe_clone_body (tree fn)\n \tupdate_cloned_parm (parm, clone_parm);\n \n       /* Start processing the function.  */\n-      push_to_top_level ();\n       start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n       /* Remap the parameters.  */\n@@ -198,8 +198,8 @@ maybe_clone_body (tree fn)\n       finish_function (0);\n       BLOCK_ABSTRACT_ORIGIN (DECL_INITIAL (clone)) = DECL_INITIAL (fn);\n       expand_or_defer_fn (clone);\n-      pop_from_top_level ();\n     }\n+  pop_from_top_level ();\n \n   /* We don't need to process the original function any further.  */\n   return 1;"}, {"sha": "fc5e8a57bcdb7396d78005b1366796433cbc47fd", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -12386,6 +12386,8 @@ cp_parser_class_specifier (cp_parser* parser)\n     {\n       tree queue_entry;\n       tree fn;\n+      tree class_type;\n+      bool pop_p;\n \n       /* In a first pass, parse default arguments to the functions.\n \t Then, in a second pass, parse the bodies of the functions.\n@@ -12397,21 +12399,33 @@ cp_parser_class_specifier (cp_parser* parser)\n             };\n \n          */\n+      class_type = NULL_TREE;\n+      pop_p = false;\n       for (TREE_PURPOSE (parser->unparsed_functions_queues)\n \t     = nreverse (TREE_PURPOSE (parser->unparsed_functions_queues));\n \t   (queue_entry = TREE_PURPOSE (parser->unparsed_functions_queues));\n \t   TREE_PURPOSE (parser->unparsed_functions_queues)\n \t     = TREE_CHAIN (TREE_PURPOSE (parser->unparsed_functions_queues)))\n \t{\n \t  fn = TREE_VALUE (queue_entry);\n-\t  /* Make sure that any template parameters are in scope.  */\n-\t  maybe_begin_member_template_processing (fn);\n \t  /* If there are default arguments that have not yet been processed,\n \t     take care of them now.  */\n+\t  if (class_type != TREE_PURPOSE (queue_entry))\n+\t    {\n+\t      if (pop_p)\n+\t\tpop_scope (class_type);\n+\t      class_type = TREE_PURPOSE (queue_entry);\n+\t      pop_p = push_scope (class_type);\n+\t    }\n+\t  /* Make sure that any template parameters are in scope.  */\n+\t  maybe_begin_member_template_processing (fn);\n+\t  /* Parse the default argument expressions.  */\n \t  cp_parser_late_parsing_default_args (parser, fn);\n \t  /* Remove any template parameters from the symbol table.  */\n \t  maybe_end_member_template_processing ();\n \t}\n+      if (pop_p)\n+\tpop_scope (class_type);\n       /* Now parse the body of the functions.  */\n       for (TREE_VALUE (parser->unparsed_functions_queues)\n \t     = nreverse (TREE_VALUE (parser->unparsed_functions_queues));\n@@ -12429,7 +12443,6 @@ cp_parser_class_specifier (cp_parser* parser)\n \t  cp_parser_late_parsing_for_member (parser, fn);\n \t  function_depth--;\n \t}\n-\n     }\n \n   /* Put back any saved access checks.  */\n@@ -15240,15 +15253,17 @@ cp_parser_save_default_args (cp_parser* parser, tree decl)\n     if (TREE_PURPOSE (probe))\n       {\n \tTREE_PURPOSE (parser->unparsed_functions_queues)\n-\t  = tree_cons (NULL_TREE, decl,\n+\t  = tree_cons (current_class_type, decl,\n \t\t       TREE_PURPOSE (parser->unparsed_functions_queues));\n \tbreak;\n       }\n   return;\n }\n \n /* FN is a FUNCTION_DECL which may contains a parameter with an\n-   unparsed DEFAULT_ARG.  Parse the default args now.  */\n+   unparsed DEFAULT_ARG.  Parse the default args now.  This function\n+   assumes that the current scope is the scope in which the default\n+   argument should be processed.  */\n \n static void\n cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n@@ -15288,11 +15303,7 @@ cp_parser_late_parsing_default_args (cp_parser *parser, tree fn)\n       saved_local_variables_forbidden_p = parser->local_variables_forbidden_p;\n       parser->local_variables_forbidden_p = true;\n        /* Parse the assignment-expression.  */\n-      if (DECL_CLASS_SCOPE_P (fn))\n-\tpush_nested_class (DECL_CONTEXT (fn));\n       TREE_PURPOSE (parameters) = cp_parser_assignment_expression (parser);\n-      if (DECL_CLASS_SCOPE_P (fn))\n-\tpop_nested_class ();\n \n       /* If the token stream has not been completely used up, then\n \t there was extra junk after the end of the default"}, {"sha": "da9a7cfdc7fdd4c93f6185c3244509b0ad3085b1", "filename": "gcc/cp/search.c", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -88,7 +88,6 @@ static tree dfs_debug_unmarkedp (tree, int, void *);\n static tree dfs_debug_mark (tree, void *);\n static tree dfs_push_type_decls (tree, void *);\n static tree dfs_push_decls (tree, void *);\n-static tree dfs_unuse_fields (tree, void *);\n static tree add_conversions (tree, void *);\n static int look_for_overrides_r (tree, tree);\n static struct search_level *push_search_level (struct stack_level *,\n@@ -2247,45 +2246,6 @@ push_class_decls (tree type)\n   dfs_walk (TYPE_BINFO (type), dfs_push_decls, marked_pushdecls_p, 0);\n }\n \n-/* Here's a subroutine we need because C lacks lambdas.  */\n-\n-static tree\n-dfs_unuse_fields (tree binfo, void *data ATTRIBUTE_UNUSED)\n-{\n-  tree type = TREE_TYPE (binfo);\n-  tree fields;\n-\n-  if (TREE_CODE (type) == TYPENAME_TYPE)\n-    fields = TYPENAME_TYPE_FULLNAME (type);\n-  else if (TREE_CODE (type) == TYPEOF_TYPE)\n-    fields = TYPEOF_TYPE_EXPR (type);\n-  else if (TREE_CODE (type) == TEMPLATE_TYPE_PARM\n-\t   || TREE_CODE (type) == TEMPLATE_TEMPLATE_PARM\n-\t   || TREE_CODE (type) == BOUND_TEMPLATE_TEMPLATE_PARM)\n-    fields = TEMPLATE_TYPE_PARM_INDEX (type);\n-  else\n-    fields = TYPE_FIELDS (type);\n-\n-  for (; fields; fields = TREE_CHAIN (fields))\n-    {\n-      if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n-\tcontinue;\n-\n-      TREE_USED (fields) = 0;\n-      if (DECL_NAME (fields) == NULL_TREE\n-\t  && ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n-\tunuse_fields (TREE_TYPE (fields));\n-    }\n-\n-  return NULL_TREE;\n-}\n-\n-void\n-unuse_fields (tree type)\n-{\n-  dfs_walk (TYPE_BINFO (type), dfs_unuse_fields, unmarkedp, 0);\n-}\n-\n void\n pop_class_decls (void)\n {"}, {"sha": "fe9a0655fb77fec4bde64b834b02b21b85c29f85", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -1,3 +1,7 @@\n+2004-07-11  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/parse/defarg8.C: New test.\n+\n 2004-07-11  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \tPR fortran/16433"}, {"sha": "1f1f078aa16dbe05286dfda7c13b802b504d5c14", "filename": "gcc/testsuite/g++.dg/parse/defarg8.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg8.C?ref=f44b0c8ec5fdc1fc12508a40cd6d4da209279ab6", "patch": "@@ -0,0 +1,10 @@\n+struct A {\n+  static void g(int);\n+};\n+\n+struct S {\n+  static int i;\n+\n+  friend void f(int = i);\n+  friend void A::g(int = i);\n+};"}]}