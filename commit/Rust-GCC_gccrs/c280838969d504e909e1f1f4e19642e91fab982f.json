{"sha": "c280838969d504e909e1f1f4e19642e91fab982f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI4MDgzODk2OWQ1MDRlOTA5ZTFmMWY0ZTE5NjQyZTkxZmFiOTgyZg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-02-23T12:18:44Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2019-02-23T12:18:44Z"}, "message": "re PR fortran/89385 (Incorrect members of C descriptor for an allocatable object)\n\n2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89385\n\tPR fortran/89366\n\t* decl.c (gfc_verify_c_interop_param): Restriction on string\n\tlength being one is lifted for F2018.\n\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): For scalar\n\tcharacters with intent in, make a temporary and copy the result\n\tof the expression evaluation into it.\n\t(gfc_conv_procedure_call): Set a flag for character formal args\n\thaving a character length that is not unity. If the procedure\n\tis bind C, call gfc_conv_gfc_desc_to_cfi_desc in this case.\n\tAlso, extend bind C calls to unconditionally convert both\n\tpointers and allocatable expressions.\n\n2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89385\n\t* gfortran.dg/ISO_Fortran_binding_1.f90 : Correct test for\n\tpreviously incorrect lbound for allocatable expressions. Also\n\tcorrect stop values to avoid repetition.\n\t* gfortran.dg/ISO_Fortran_binding_5.f90 : New test\n\t* gfortran.dg/ISO_Fortran_binding_5.c : Support previous test.\n\n\tPR fortran/89366\n\t* gfortran.dg/ISO_Fortran_binding_6.f90 : New test\n\t* gfortran.dg/ISO_Fortran_binding_6.c : Support previous test.\n\t* gfortran.dg/pr32599.f03 : Set standard to F2008.\n\n2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/89385\n\tPR fortran/89366\n\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc) : In the\n\tinterchange between character and derived, the character type\n\twas being set incorrectly.\n\t(gfc_desc_to_cfi_desc) : Eliminate the interchange of types in\n\tthis function. Do not add the kind and length information to\n\tthe type field of structures. Lbounds were incorrectly being\n\tset to zero for allocatable and pointer descriptors. Should\n\thave been non-pointer, non-allocatables that received this\n\ttreatment.\n\nFrom-SVN: r269156", "tree": {"sha": "0d97a4275e8f81a6df83f1a711e9d0f11a88d493", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d97a4275e8f81a6df83f1a711e9d0f11a88d493"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c280838969d504e909e1f1f4e19642e91fab982f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c280838969d504e909e1f1f4e19642e91fab982f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c280838969d504e909e1f1f4e19642e91fab982f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c280838969d504e909e1f1f4e19642e91fab982f/comments", "author": null, "committer": null, "parents": [{"sha": "ace857f95d819377507f81ff4fc88ebf8b913eef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ace857f95d819377507f81ff4fc88ebf8b913eef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ace857f95d819377507f81ff4fc88ebf8b913eef"}], "stats": {"total": 324, "additions": 296, "deletions": 28}, "files": [{"sha": "3b5028cd0c2bce527c6a4baf03f11328f78151f0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -1,3 +1,18 @@\n+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89385\n+\tPR fortran/89366\n+\t* decl.c (gfc_verify_c_interop_param): Restriction on string\n+\tlength being one is lifted for F2018.\n+\t* trans-expr.c (gfc_conv_gfc_desc_to_cfi_desc): For scalar\n+\tcharacters with intent in, make a temporary and copy the result\n+\tof the expression evaluation into it.\n+\t(gfc_conv_procedure_call): Set a flag for character formal args\n+\thaving a character length that is not unity. If the procedure\n+\tis bind C, call gfc_conv_gfc_desc_to_cfi_desc in this case.\n+\tAlso, extend bind C calls to unconditionally convert both\n+\tpointers and allocatable expressions.\n+\n 2019-02-23  David Malcolm  <dmalcolm@redhat.com>\n \t    Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "3c8c5ffaaaa151d17e887f7714126bbaa0f81229", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -1499,12 +1499,13 @@ gfc_verify_c_interop_param (gfc_symbol *sym)\n \t      if (!cl || !cl->length || cl->length->expr_type != EXPR_CONSTANT\n                   || mpz_cmp_si (cl->length->value.integer, 1) != 0)\n \t\t{\n-\t\t  gfc_error (\"Character argument %qs at %L \"\n-\t\t\t     \"must be length 1 because \"\n-                             \"procedure %qs is BIND(C)\",\n-\t\t\t     sym->name, &sym->declared_at,\n-                             sym->ns->proc_name->name);\n-\t\t  retval = false;\n+\t\t  if (!gfc_notify_std (GFC_STD_F2018,\n+\t\t\t\t       \"Character argument %qs at %L \"\n+\t\t\t\t       \"must be length 1 because \"\n+\t\t\t\t       \"procedure %qs is BIND(C)\",\n+\t\t\t\t       sym->name, &sym->declared_at,\n+\t\t\t\t       sym->ns->proc_name->name))\n+\t\t    retval = false;\n \t\t}\n \t    }\n "}, {"sha": "cff3d7c2930f1fc3ca6dc63fdc2944b738283771", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 40, "deletions": 6, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -5012,6 +5012,8 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \t\t\t\tgfc_conv_descriptor_data_get (parmse->expr),\n \t\t\t\tsize);\n \t  gfc_add_expr_to_block (&parmse->pre, tmp);\n+\n+\t  /* The temporary 'ptr' is freed below.  */\n \t  gfc_conv_descriptor_data_set (&parmse->pre, parmse->expr, ptr);\n \t}\n \n@@ -5026,7 +5028,26 @@ gfc_conv_gfc_desc_to_cfi_desc (gfc_se *parmse, gfc_expr *e, gfc_symbol *fsym)\n \n       /* Copy the scalar for INTENT(IN).  */\n       if (e->expr_type == EXPR_VARIABLE && fsym->attr.intent == INTENT_IN)\n-\tparmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n+\t{\n+\t  if (e->ts.type != BT_CHARACTER)\n+\t    parmse->expr = gfc_evaluate_now (parmse->expr, &parmse->pre);\n+\t  else\n+\t    {\n+\t      /* The temporary string 'ptr' is freed below.  */\n+\t      tmp = build_pointer_type (TREE_TYPE (parmse->expr));\n+\t      ptr = gfc_create_var (tmp, \"str\");\n+\t      tmp = build_call_expr_loc (input_location,\n+\t\t\t\t builtin_decl_explicit (BUILT_IN_MALLOC),\n+\t\t\t\t 1, parmse->string_length);\n+\t      tmp = fold_convert (TREE_TYPE (ptr), tmp);\n+\t      gfc_add_modify (&parmse->pre, ptr, tmp);\n+\t      tmp = gfc_build_memcpy_call (ptr, parmse->expr,\n+\t\t\t\t\t   parmse->string_length);\n+\t      gfc_add_expr_to_block (&parmse->pre, tmp);\n+\t      parmse->expr = ptr;\n+\t    }\n+\t}\n+\n       parmse->expr = gfc_conv_scalar_to_descriptor (parmse,\n \t\t\t\t\t\t    parmse->expr, attr);\n     }\n@@ -5188,11 +5209,18 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n        arg = arg->next, formal = formal ? formal->next : NULL, ++argc)\n     {\n       bool finalized = false;\n+      bool non_unity_length_string = false;\n \n       e = arg->expr;\n       fsym = formal ? formal->sym : NULL;\n       parm_kind = MISSING;\n \n+      if (fsym && fsym->ts.type == BT_CHARACTER && fsym->ts.u.cl\n+\t  && (!fsym->ts.u.cl->length\n+\t      || fsym->ts.u.cl->length->expr_type != EXPR_CONSTANT\n+\t      || mpz_cmp_si (fsym->ts.u.cl->length->value.integer, 1) != 0))\n+\tnon_unity_length_string = true;\n+\n       /* If the procedure requires an explicit interface, the actual\n \t argument is passed according to the corresponding formal\n \t argument.  If the corresponding formal argument is a POINTER,\n@@ -5418,9 +5446,12 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t\t}\n \n \t      else if (sym->attr.is_bind_c && e\n-\t\t       && fsym && fsym->attr.dimension\n-\t\t       && (fsym->as->type == AS_ASSUMED_RANK\n-\t\t\t   || fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t       && ((fsym && fsym->attr.dimension\n+\t\t\t    && (fsym->attr.pointer\n+\t\t\t\t|| fsym->attr.allocatable\n+\t\t\t\t|| fsym->as->type == AS_ASSUMED_RANK\n+\t\t\t\t|| fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t\t   || non_unity_length_string))\n \t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n \n@@ -5865,8 +5896,11 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \n \t      if (sym->attr.is_bind_c && e\n \t\t  && fsym && fsym->attr.dimension\n-\t\t  && (fsym->as->type == AS_ASSUMED_RANK\n-\t\t      || fsym->as->type == AS_ASSUMED_SHAPE))\n+\t\t  && (fsym->attr.pointer\n+\t\t      || fsym->attr.allocatable\n+\t\t      || fsym->as->type == AS_ASSUMED_RANK\n+\t\t      || fsym->as->type == AS_ASSUMED_SHAPE\n+\t\t      || non_unity_length_string))\n \t\t/* Implement F2018, C.12.6.1: paragraph (2).  */\n \t\tgfc_conv_gfc_desc_to_cfi_desc (&parmse, e, fsym);\n "}, {"sha": "0d1cdecd6df72bf682740af83698d29b6d1d847b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -1,3 +1,17 @@\n+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89385\n+\t* gfortran.dg/ISO_Fortran_binding_1.f90 : Correct test for\n+\tpreviously incorrect lbound for allocatable expressions. Also\n+\tcorrect stop values to avoid repetition.\n+\t* gfortran.dg/ISO_Fortran_binding_5.f90 : New test\n+\t* gfortran.dg/ISO_Fortran_binding_5.c : Support previous test.\n+\n+\tPR fortran/89366\n+\t* gfortran.dg/ISO_Fortran_binding_6.f90 : New test\n+\t* gfortran.dg/ISO_Fortran_binding_6.c : Support previous test.\n+\t* gfortran.dg/pr32599.f03 : Set standard to F2008.\n+\n 2019-02-22  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c++/89390"}, {"sha": "e12b3a06e41fa68962852d02b8b28d7aa0b7f130", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_1.f90", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_1.f90?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -192,7 +192,9 @@ subroutine test_CFI_section (arg)\n     a = [(real(i), i = 1, 100)]\n     lower(1) = 10\n     strides(1) = 5\n-    if (int (sum(a(lower(1)::strides(1))) &\n+! Remember, 'a' being non pointer, non-allocatable, the C descriptor\n+! lbounds are set to zero.\n+    if (int (sum(a(lower(1)+1::strides(1))) &\n              - c_section(1, a, lower, strides)) .ne. 0) stop 28\n ! Case (ii) from F2018:18.5.5.7.\n     arg(:,1:10) = reshape ([(real(i), i = 1, 100)], [10,10])\n@@ -222,7 +224,7 @@ subroutine test_CFI_select_part\n       end do\n     end do\n ! Now do the test.\n-    if (int (c_select_part (type_t) - sum_z_5) .ne. 0) stop 28\n+    if (int (c_select_part (type_t) - sum_z_5) .ne. 0) stop 30\n   end subroutine test_CFI_select_part\n \n   subroutine test_CFI_setpointer\n@@ -232,13 +234,13 @@ subroutine test_CFI_setpointer\n     integer, dimension(2) :: lbounds = [-1, -2]\n ! The C-function resets the lbounds\n     ptr(1:, 1:) => tgt\n-    if (c_setpointer (ptr, lbounds) .ne. 0) stop 30\n-    if (any (lbound(ptr) .ne. lbounds)) stop 31\n+    if (c_setpointer (ptr, lbounds) .ne. 0) stop 31\n+    if (any (lbound(ptr) .ne. lbounds)) stop 32\n   end subroutine test_CFI_setpointer\n \n   subroutine test_assumed_size (arg)\n     integer, dimension(2,*) :: arg\n ! The C-function checks contiguousness and that extent[1] == -1.\n-    if (c_assumed_size (arg) .ne. 0) stop 32\n+    if (c_assumed_size (arg) .ne. 0) stop 33\n   end subroutine\n end"}, {"sha": "116f548ad99e311b9911317dfc5e9e68a7ba7adb", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_5.c", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.c?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -0,0 +1,83 @@\n+/* Test fix for PR89385.  */\n+\n+/* Contributed by Reinhold Bader  <Bader@lrz.de>  */\n+\n+#include <stdio.h>\n+#include <math.h>\n+#include \"ISO_Fortran_binding.h\"\n+\n+typedef struct {\n+  int i;\n+  float r[2];\n+} cstruct;\n+\n+\n+void Psub(CFI_cdesc_t *this, CFI_cdesc_t *that, int *ierr) {\n+    int status = 0;\n+    cstruct *cu;\n+    float *ct;\n+    CFI_dim_t *dim;\n+    if (this->elem_len != sizeof(float)) {\n+\tprintf(\"FAIL: this->elem_len %i\\n\",(int) this->elem_len);\n+\tstatus++;\n+    }\n+    if (this->type != CFI_type_float) {\n+\tprintf(\"FAIL: this->type\\n\");\n+\tstatus++;\n+    }\n+    if (this->rank != 2) {\n+\tprintf(\"FAIL: this->rank %i\\n\",this->rank);\n+\tstatus++;\n+    }\n+    if (this->attribute != CFI_attribute_allocatable) {\n+\tprintf(\"FAIL: this->attribute\\n\");\n+\tstatus++;\n+    }\n+    dim = this->dim;\n+    if (dim[0].lower_bound != 3 || dim[0].extent != 4)  {\n+\tprintf(\"FAIL: dim[0] %d %d\\n\", dim[0].lower_bound, dim[0].extent);\n+\tstatus++;\n+    }\n+    if (dim[1].lower_bound != 1 || dim[1].extent != 5)  {\n+\tprintf(\"FAIL: dim[1] %d %d\\n\", dim[1].lower_bound, dim[1].extent);\n+\tstatus++;\n+    }\n+\n+    if (that->elem_len != sizeof(cstruct)) {\n+\tprintf(\"FAIL: that->elem_len\\n\");\n+\tstatus++;\n+    }\n+    if (that->type != CFI_type_struct) {\n+\tprintf(\"FAIL: that->type %d %d\\n\", that->type, CFI_type_struct);\n+\tstatus++;\n+    }\n+     if (that->rank != 1) {\n+\tprintf(\"FAIL: that->rank\\n\");\n+\tstatus++;\n+    }\n+    if (that->attribute != CFI_attribute_allocatable) {\n+\tprintf(\"FAIL: that->attribute\\n\");\n+\tstatus++;\n+    }\n+    dim = that->dim;\n+    if (dim[0].lower_bound != 1 || dim[0].extent != 1)  {\n+\tprintf(\"FAIL: dim[0] %d %d\\n\" , dim[0].lower_bound, dim[0].extent);\n+\tstatus++;\n+    }\n+    cu = (cstruct *) ((CFI_cdesc_t *) that)->base_addr;\n+    if (cu->i != 4 || fabs(cu->r[1] -  2.2) > 1.0e-6) {\n+\tprintf(\"FAIL: value of that %i %f %f\\n\",cu->i,cu->r[1],cu->r[2]);\n+\tstatus++;\n+    }\n+\n+    ct = (float *) ((CFI_cdesc_t *) this)->base_addr;\n+    if ( fabs(ct[5] +  2.0) > 1.0e-6) {\n+\tprintf(\"FAIL: value of this %f\\n\",ct[5]);\n+\tstatus++;\n+    }\n+\n+\n+    *ierr = status;\n+\n+}\n+"}, {"sha": "97c2c5202bb278d06ed13e90cf3d65e4c710018b", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_5.f90", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_5.f90?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -0,0 +1,36 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_5.c }\n+!\n+! Test fix of PR89385.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+program allocatable_01\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  type, bind(c) :: cstruct\n+     integer(c_int) :: i\n+     real(c_float) :: r(2)\n+  end type cstruct\n+  interface\n+     subroutine psub(this, that, ierr) bind(c, name='Psub')\n+       import :: c_float, cstruct, c_int\n+       real(c_float), allocatable :: this(:,:)\n+       type(cstruct), allocatable :: that(:)\n+       integer(c_int), intent(inout) :: ierr\n+     end subroutine psub\n+  end interface\n+\n+  real(c_float), allocatable :: t(:,:)\n+  type(cstruct), allocatable :: u(:)\n+  integer(c_int) :: ierr\n+\n+  allocate(t(3:6,5))\n+  t = 0.0\n+  t(4,2) = -2.0\n+  allocate(u(1), source=[ cstruct( 4, [1.1,2.2] ) ] )\n+  call psub(t, u, ierr)\n+\n+  deallocate(t,u)\n+  if (ierr .ne. 0) stop ierr\n+end program allocatable_01"}, {"sha": "704b27cb28a41eb3dbcf38b3d642d814b76076dd", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_6.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.c?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -0,0 +1,23 @@\n+/* Test fix for PR89366.  */\n+\n+/* Contributed by Reinhold Bader  <Bader@lrz.de>  */\n+\n+#include <stdio.h>\n+#include <math.h>\n+#include \"ISO_Fortran_binding.h\"\n+\n+#define DEBUG 0\n+\n+void process_string(CFI_cdesc_t *this, int *ierr) {\n+  char *cstr;\n+  cstr = (char *) this->base_addr;\n+  *ierr = 0;\n+  if (this->rank != 0) {\n+    *ierr = 1;\n+    return;\n+  }\n+  if (DEBUG == 1) {\n+    printf(\"elem_len member has value %i %s\\n\",this->elem_len, cstr);\n+  }\n+\n+}"}, {"sha": "a5b34be62d8639a523d5c488ee6239ea1e4b2182", "filename": "gcc/testsuite/gfortran.dg/ISO_Fortran_binding_6.f90", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FISO_Fortran_binding_6.f90?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -0,0 +1,41 @@\n+! { dg-do run }\n+! { dg-additional-sources ISO_Fortran_binding_6.c }\n+!\n+! Test fix of PR89366.\n+!\n+! Contributed by Reinhold Bader  <Bader@lrz.de>\n+!\n+program assumed_length_01\n+  use, intrinsic :: iso_c_binding\n+  implicit none\n+  integer, parameter :: strlen = 12\n+  integer(c_int) :: ierr(3)\n+  character(kind=c_char,len=strlen) :: s1\n+  character(kind=c_char,len=:), allocatable :: s2\n+  character(kind=c_char,len=:), pointer :: s3\n+!\n+! invoke a C function that processes an assumed length string\n+  interface\n+     subroutine process_string(this, ierr) BIND(C)\n+       import :: c_char, c_int\n+       character(kind=c_char,len=*), intent(in) :: this(..)\n+       integer(c_int), intent(inout) :: ierr\n+     end subroutine process_string\n+  end interface\n+!\n+!\n+  ierr = 0\n+  s1 = c_char_'wrzlprmft' // c_null_char\n+  call process_string(s1, ierr(1))\n+  if (ierr(1) /= 0) stop 1\n+  s2 = c_char_'wrzlprmft' // c_null_char\n+  allocate(s3, source=trim(s1))\n+  call process_string(s2, ierr(2))\n+  if (ierr(2) /= 0) stop 2\n+  call process_string(s3, ierr(3))\n+  if (ierr(3) /= 0) stop 3\n+  if (sum(abs(ierr)) == 0) write(*,*) 'OK'\n+\n+  deallocate(s2,s3)\n+\n+end program assumed_length_01"}, {"sha": "297b75a7444a1321c13916bd8dadd4de2af20903", "filename": "gcc/testsuite/gfortran.dg/pr32599.f03", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr32599.f03?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -1,26 +1,30 @@\n ! { dg-do compile }\n+! { dg-options \"-std=f2008\" }\n+!\n ! PR fortran/32599\n-! Verifies that character string arguments to a bind(c) procedure have length \n-! 1, or no len is specified.  \n+! Verifies that character string arguments to a bind(c) procedure have length\n+! 1, or no len is specified. Note that the C interop extensions in F2018 allow\n+! string arguments of length greater than one to be passed to a C descriptor.\n+!\n module pr32599\n   interface\n      subroutine destroy(path) BIND(C) ! { dg-error \"must be length 1\" }\n        use iso_c_binding\n        implicit none\n-       character(len=*,kind=c_char), intent(IN) :: path \n+       character(len=*,kind=c_char), intent(IN) :: path\n      end subroutine destroy\n \n      subroutine create(path) BIND(C) ! { dg-error \"must be length 1\" }\n        use iso_c_binding\n        implicit none\n-       character(len=5,kind=c_char), intent(IN) :: path \n+       character(len=5,kind=c_char), intent(IN) :: path\n      end subroutine create\n \n      ! This should be valid.\n      subroutine create1(path) BIND(C)\n        use iso_c_binding\n        implicit none\n-       character(len=1,kind=c_char), intent(IN) :: path \n+       character(len=1,kind=c_char), intent(IN) :: path\n      end subroutine create1\n \n      ! This should be valid."}, {"sha": "d0a3962ba29aad6c92a0a9a32b4c4bffd56b56be", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -1,3 +1,17 @@\n+2019-02-23  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/89385\n+\tPR fortran/89366\n+\t* runtime/ISO_Fortran_binding.c (cfi_desc_to_gfc_desc) : In the\n+\tinterchange between character and derived, the character type\n+\twas being set incorrectly.\n+\t(gfc_desc_to_cfi_desc) : Eliminate the interchange of types in\n+\tthis function. Do not add the kind and length information to\n+\tthe type field of structures. Lbounds were incorrectly being\n+\tset to zero for allocatable and pointer descriptors. Should\n+\thave been non-pointer, non-allocatables that received this\n+\ttreatment.\n+\n 2019-01-30  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \tPR libfortran/88678\n@@ -47,7 +61,7 @@\n \n \tPR libfortran/88776\n \t* io/open.c (newunit): Free format buffer if the unit specified is for\n-\tstdin, stdout, or stderr. \n+\tstdin, stdout, or stderr.\n \n 2019-01-12  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n "}, {"sha": "6b7b10fb8362ba2bd14530b4f1012c0c4bce053b", "filename": "libgfortran/runtime/ISO_Fortran_binding.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c280838969d504e909e1f1f4e19642e91fab982f/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c280838969d504e909e1f1f4e19642e91fab982f/libgfortran%2Fruntime%2FISO_Fortran_binding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fruntime%2FISO_Fortran_binding.c?ref=c280838969d504e909e1f1f4e19642e91fab982f", "patch": "@@ -59,7 +59,7 @@ cfi_desc_to_gfc_desc (gfc_array_void *d, CFI_cdesc_t **s_ptr)\n   if (GFC_DESCRIPTOR_TYPE (d) == BT_CHARACTER)\n     GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n   else if (GFC_DESCRIPTOR_TYPE (d) == BT_DERIVED)\n-    GFC_DESCRIPTOR_TYPE (d) = BT_DERIVED;\n+    GFC_DESCRIPTOR_TYPE (d) = BT_CHARACTER;\n \n   d->dtype.attribute = (signed short)s->attribute;\n \n@@ -105,19 +105,20 @@ gfc_desc_to_cfi_desc (CFI_cdesc_t **d_ptr, const gfc_array_void *s)\n   d->attribute = (CFI_attribute_t)s->dtype.attribute;\n \n   if (GFC_DESCRIPTOR_TYPE (s) == BT_CHARACTER)\n-    d->type = CFI_type_struct;\n-  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)\n     d->type = CFI_type_Character;\n+  else if (GFC_DESCRIPTOR_TYPE (s) == BT_DERIVED)\n+    d->type = CFI_type_struct;\n   else\n     d->type = (CFI_type_t)GFC_DESCRIPTOR_TYPE (s);\n \n-  d->type = (CFI_type_t)(d->type\n+  if (GFC_DESCRIPTOR_TYPE (s) != BT_DERIVED)\n+    d->type = (CFI_type_t)(d->type\n \t\t+ ((CFI_type_t)d->elem_len << CFI_type_kind_shift));\n \n   /* Full pointer or allocatable arrays have zero lower_bound.  */\n   for (n = 0; n < GFC_DESCRIPTOR_RANK (s); n++)\n     {\n-      if (d->attribute == CFI_attribute_other)\n+      if (d->attribute != CFI_attribute_other)\n \td->dim[n].lower_bound = (CFI_index_t)GFC_DESCRIPTOR_LBOUND(s, n);\n       else\n \td->dim[n].lower_bound = 0;"}]}