{"sha": "8df7772284a47cf93f4474ab500d5987d2f8ebdd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRmNzc3MjI4NGE0N2NmOTNmNDQ3NGFiNTAwZDU5ODdkMmY4ZWJkZA==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@bitrange.com", "date": "2012-10-22T09:22:11Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2012-10-22T09:22:11Z"}, "message": "stmt.c (expand_nl_goto_receiver): Remove almost-copy of expand_builtin_setjmp_receiver.\n\n\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n\texpand_builtin_setjmp_receiver.\n\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n\twith NULL for the label parameter.\n\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n\tthe frame-pointer.  Adjust comments.\n\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n\tonly if LABEL is non-NULL.\n\nFrom-SVN: r192676", "tree": {"sha": "ec49f89bda96be4ab7f93d0fccc3cdd469f8a4fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec49f89bda96be4ab7f93d0fccc3cdd469f8a4fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8df7772284a47cf93f4474ab500d5987d2f8ebdd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df7772284a47cf93f4474ab500d5987d2f8ebdd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8df7772284a47cf93f4474ab500d5987d2f8ebdd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8df7772284a47cf93f4474ab500d5987d2f8ebdd/comments", "author": null, "committer": null, "parents": [{"sha": "f24f688ff32f64c039dddfda8cdd6e67a42b37c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f24f688ff32f64c039dddfda8cdd6e67a42b37c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f24f688ff32f64c039dddfda8cdd6e67a42b37c9"}], "stats": {"total": 115, "additions": 33, "deletions": 82}, "files": [{"sha": "128837f8e4c0bfe68158c8694f4217fb5126f60b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8df7772284a47cf93f4474ab500d5987d2f8ebdd", "patch": "@@ -1,3 +1,14 @@\n+2012-10-22  Hans-Peter Nilsson  <hp@bitrange.com>\n+\n+\t* stmt.c (expand_nl_goto_receiver): Remove almost-copy of\n+\texpand_builtin_setjmp_receiver.\n+\t(expand_label): Adjust, call expand_builtin_setjmp_receiver\n+\twith NULL for the label parameter.\n+\t* builtins.c (expand_builtin_setjmp_receiver): Don't clobber\n+\tthe frame-pointer.  Adjust comments.\n+\t[HAVE_builtin_setjmp_receiver]: Emit builtin_setjmp_receiver\n+\tonly if LABEL is non-NULL.\n+\n 2012-10-21  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/i386-protos.h (memory_address_length): Add new bool"}, {"sha": "6d501c47ad89df870bd4f71b16d1e4aa267515ae", "filename": "gcc/builtins.c", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8df7772284a47cf93f4474ab500d5987d2f8ebdd", "patch": "@@ -885,14 +885,15 @@ expand_builtin_setjmp_setup (rtx buf_addr, rtx receiver_label)\n }\n \n /* Construct the trailing part of a __builtin_setjmp call.  This is\n-   also called directly by the SJLJ exception handling code.  */\n+   also called directly by the SJLJ exception handling code.\n+   If RECEIVER_LABEL is NULL, instead contruct a nonlocal goto handler.  */\n \n void\n expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n {\n   rtx chain;\n \n-  /* Clobber the FP when we get here, so we have to make sure it's\n+  /* Mark the FP as used when we get here, so we have to make sure it's\n      marked as used by this function.  */\n   emit_use (hard_frame_pointer_rtx);\n \n@@ -907,17 +908,28 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #ifdef HAVE_nonlocal_goto\n   if (! HAVE_nonlocal_goto)\n #endif\n-    {\n-      emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-      /* This might change the hard frame pointer in ways that aren't\n-\t apparent to early optimization passes, so force a clobber.  */\n-      emit_clobber (hard_frame_pointer_rtx);\n-    }\n+    /* First adjust our frame pointer to its actual value.  It was\n+       previously set to the start of the virtual area corresponding to\n+       the stacked variables when we branched here and now needs to be\n+       adjusted to the actual hardware fp value.\n+\n+       Assignments to virtual registers are converted by\n+       instantiate_virtual_regs into the corresponding assignment\n+       to the underlying register (fp in this case) that makes\n+       the original assignment true.\n+       So the following insn will actually be decrementing fp by\n+       STARTING_FRAME_OFFSET.  */\n+    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n \n #if !HARD_FRAME_POINTER_IS_ARG_POINTER\n   if (fixed_regs[ARG_POINTER_REGNUM])\n     {\n #ifdef ELIMINABLE_REGS\n+      /* If the argument pointer can be eliminated in favor of the\n+\t frame pointer, we don't need to restore it.  We assume here\n+\t that if such an elimination is present, it can always be used.\n+\t This is the case on all known machines; if we don't make this\n+\t assumption, we do unnecessary saving on many machines.  */\n       size_t i;\n       static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n \n@@ -938,7 +950,7 @@ expand_builtin_setjmp_receiver (rtx receiver_label ATTRIBUTE_UNUSED)\n #endif\n \n #ifdef HAVE_builtin_setjmp_receiver\n-  if (HAVE_builtin_setjmp_receiver)\n+  if (receiver_label != NULL && HAVE_builtin_setjmp_receiver)\n     emit_insn (gen_builtin_setjmp_receiver (receiver_label));\n   else\n #endif"}, {"sha": "07e7cc74159541fbdaff55b5eab208491cec7cc8", "filename": "gcc/stmt.c", "status": "modified", "additions": 1, "deletions": 73, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8df7772284a47cf93f4474ab500d5987d2f8ebdd/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=8df7772284a47cf93f4474ab500d5987d2f8ebdd", "patch": "@@ -106,7 +106,6 @@ extern basic_block label_to_block_fn (struct function *, tree);\n \f\n static int n_occurrences (int, const char *);\n static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n-static void expand_nl_goto_receiver (void);\n static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree, tree);\n static char *resolve_operand_name_1 (char *, tree, tree, tree);\n@@ -200,7 +199,7 @@ expand_label (tree label)\n \n   if (DECL_NONLOCAL (label))\n     {\n-      expand_nl_goto_receiver ();\n+      expand_builtin_setjmp_receiver (NULL);\n       nonlocal_goto_handler_labels\n \t= gen_rtx_EXPR_LIST (VOIDmode, label_r,\n \t\t\t     nonlocal_goto_handler_labels);\n@@ -1556,77 +1555,6 @@ expand_return (tree retval)\n     }\n }\n \f\n-/* Emit code to restore vital registers at the beginning of a nonlocal goto\n-   handler.  */\n-static void\n-expand_nl_goto_receiver (void)\n-{\n-  rtx chain;\n-\n-  /* Clobber the FP when we get here, so we have to make sure it's\n-     marked as used by this function.  */\n-  emit_use (hard_frame_pointer_rtx);\n-\n-  /* Mark the static chain as clobbered here so life information\n-     doesn't get messed up for it.  */\n-  chain = targetm.calls.static_chain (current_function_decl, true);\n-  if (chain && REG_P (chain))\n-    emit_clobber (chain);\n-\n-#ifdef HAVE_nonlocal_goto\n-  if (! HAVE_nonlocal_goto)\n-#endif\n-    /* First adjust our frame pointer to its actual value.  It was\n-       previously set to the start of the virtual area corresponding to\n-       the stacked variables when we branched here and now needs to be\n-       adjusted to the actual hardware fp value.\n-\n-       Assignments are to virtual registers are converted by\n-       instantiate_virtual_regs into the corresponding assignment\n-       to the underlying register (fp in this case) that makes\n-       the original assignment true.\n-       So the following insn will actually be\n-       decrementing fp by STARTING_FRAME_OFFSET.  */\n-    emit_move_insn (virtual_stack_vars_rtx, hard_frame_pointer_rtx);\n-\n-#if !HARD_FRAME_POINTER_IS_ARG_POINTER\n-  if (fixed_regs[ARG_POINTER_REGNUM])\n-    {\n-#ifdef ELIMINABLE_REGS\n-      /* If the argument pointer can be eliminated in favor of the\n-\t frame pointer, we don't need to restore it.  We assume here\n-\t that if such an elimination is present, it can always be used.\n-\t This is the case on all known machines; if we don't make this\n-\t assumption, we do unnecessary saving on many machines.  */\n-      static const struct elims {const int from, to;} elim_regs[] = ELIMINABLE_REGS;\n-      size_t i;\n-\n-      for (i = 0; i < ARRAY_SIZE (elim_regs); i++)\n-\tif (elim_regs[i].from == ARG_POINTER_REGNUM\n-\t    && elim_regs[i].to == HARD_FRAME_POINTER_REGNUM)\n-\t  break;\n-\n-      if (i == ARRAY_SIZE (elim_regs))\n-#endif\n-\t{\n-\t  /* Now restore our arg pointer from the address at which it\n-\t     was saved in our stack frame.  */\n-\t  emit_move_insn (crtl->args.internal_arg_pointer,\n-\t\t\t  copy_to_reg (get_arg_pointer_save_area ()));\n-\t}\n-    }\n-#endif\n-\n-#ifdef HAVE_nonlocal_goto_receiver\n-  if (HAVE_nonlocal_goto_receiver)\n-    emit_insn (gen_nonlocal_goto_receiver ());\n-#endif\n-\n-  /* We must not allow the code we just generated to be reordered by\n-     scheduling.  Specifically, the update of the frame pointer must\n-     happen immediately, not later.  */\n-  emit_insn (gen_blockage ());\n-}\n \f\n /* Emit code to save the current value of stack.  */\n rtx"}]}