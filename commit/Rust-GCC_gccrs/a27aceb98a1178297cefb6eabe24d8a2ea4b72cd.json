{"sha": "a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI3YWNlYjk4YTExNzgyOTdjZWZiNmVhYmUyNGQ4YTJlYTRiNzJjZA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T07:41:08Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2020-05-25T07:44:55Z"}, "message": "Change description of fat pointertype  with -fgnat-encodings=minimal\n\nThis makes a step back in the representation of fat pointer types in\nthe debug info with -fgnat-encodings=minimal so as to avoid hiding the\ndata indirection and making it easiser to synthetize the construct.\n\ngcc/ada/ChangeLog\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Add a\n\tdescription of the various types associated with the unconstrained\n\ttype.  Declare the fat pointer earlier.  Set the current function\n\tas context on the template type, and the fat pointer type on the\n\tarray type.  Always mark the fat pointer type as artificial and set\n\tit as the context for the pointer type to the array.  Also reuse\n\tGNU_ENTITY_NAME.  Finish up the unconstrained type at the very end.\n\t* gcc-interface/misc.c (gnat_get_array_descr_info): Do not handle\n\tfat pointer types and tidy up accordingly.\n\t* gcc-interface/utils.c (build_unc_object_type): Do not set the\n\tcontext on the template type.", "tree": {"sha": "4535e71ff85ae22254a4aa72f9076fca0236f2a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4535e71ff85ae22254a4aa72f9076fca0236f2a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/comments", "author": null, "committer": null, "parents": [{"sha": "49d6f7243ae7f8e7d8ed162776847fae47c3f218", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/49d6f7243ae7f8e7d8ed162776847fae47c3f218", "html_url": "https://github.com/Rust-GCC/gccrs/commit/49d6f7243ae7f8e7d8ed162776847fae47c3f218"}], "stats": {"total": 175, "additions": 84, "deletions": 91}, "files": [{"sha": "a900f53efe0bddffe4fd8f7ef73e0724d7c45d3c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "patch": "@@ -1,3 +1,17 @@\n+2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Add a\n+\tdescription of the various types associated with the unconstrained\n+\ttype.  Declare the fat pointer earlier.  Set the current function\n+\tas context on the template type, and the fat pointer type on the\n+\tarray type.  Always mark the fat pointer type as artificial and set\n+\tit as the context for the pointer type to the array.  Also reuse\n+\tGNU_ENTITY_NAME.  Finish up the unconstrained type at the very end.\n+\t* gcc-interface/misc.c (gnat_get_array_descr_info): Do not handle\n+\tfat pointer types and tidy up accordingly.\n+\t* gcc-interface/utils.c (build_unc_object_type): Do not set the\n+\tcontext on the template type.\n+\n 2020-05-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (operand_type): New static inline function."}, {"sha": "a36b1298bed664e98827add14f8cf6ab5ac2c05a", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 56, "deletions": 40, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "patch": "@@ -2099,16 +2099,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n       /* Array Types and Subtypes\n \n-\t Unconstrained array types are represented by E_Array_Type and\n-\t constrained array types are represented by E_Array_Subtype.  There\n-\t are no actual objects of an unconstrained array type; all we have\n-\t are pointers to that type.\n+\t In GNAT unconstrained array types are represented by E_Array_Type and\n+\t constrained array types are represented by E_Array_Subtype.  They are\n+\t translated into UNCONSTRAINED_ARRAY_TYPE and ARRAY_TYPE respectively.\n+\t But there are no actual objects of an unconstrained array type; all we\n+\t have are pointers to that type.  In addition to the type node itself,\n+\t 4 other types associated with it are built in the process:\n \n-\t The following fields are defined on array types and subtypes:\n+\t   1. the array type (suffix XUA) containing the actual data,\n \n-\t\tComponent_Type     Component type of the array.\n-\t\tNumber_Dimensions  Number of dimensions (an int).\n-\t\tFirst_Index\t   Type of first index.  */\n+\t   2. the template type (suffix XUB) containng the bounds,\n+\n+\t   3. the fat pointer type (suffix XUP) representing a pointer or a\n+\t      reference to the unconstrained array type:\n+\t\tXUP = struct { XUA *, XUB * }\n+\n+\t   4. the object record type (suffix XUT) containing bounds and data:\n+\t\tXUT = struct { XUB, XUA }\n+\n+\t The bounds of the array type XUA (de)reference the XUB * field of a\n+\t PLACEHOLDER_EXPR for the fat pointer type XUP, so the array type XUA\n+\t is to be interpreted in the context of the fat pointer type XUB for\n+\t debug info purposes.  */\n \n     case E_Array_Type:\n       {\n@@ -2120,7 +2132,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \ttree gnu_template_reference, gnu_template_fields, gnu_fat_type;\n \ttree *gnu_index_types = XALLOCAVEC (tree, ndim);\n \ttree *gnu_temp_fields = XALLOCAVEC (tree, ndim);\n-\ttree gnu_max_size = size_one_node, tem, t;\n+\ttree gnu_max_size = size_one_node, tem, obj;\n \tEntity_Id gnat_index;\n \tint index;\n \ttree comp_type;\n@@ -2195,7 +2207,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    TREE_TYPE (tem) = ptr_type_node;\n \t    TREE_TYPE (DECL_CHAIN (tem)) = gnu_ptr_template;\n \t    TYPE_DECL_SUPPRESS_DEBUG (TYPE_STUB_DECL (gnu_fat_type)) = 0;\n-\t    for (t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))\n+\t    for (tree t = gnu_fat_type; t; t = TYPE_NEXT_VARIANT (t))\n \t      SET_TYPE_UNCONSTRAINED_ARRAY (t, gnu_type);\n \t  }\n \telse\n@@ -2212,6 +2224,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    SET_TYPE_UNCONSTRAINED_ARRAY (gnu_fat_type, gnu_type);\n \t  }\n \n+\t/* If the GNAT encodings are used, give the fat pointer type a name.\n+\t   If this is a packed array, tell the debugger how to interpret the\n+\t   underlying bits by fetching that of the implementation type.  But\n+\t   in any case, mark it as artificial so the debugger can skip it.  */\n+\tconst Entity_Id gnat_name\n+\t  = (Present (Packed_Array_Impl_Type (gnat_entity))\n+\t     && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    ? Packed_Array_Impl_Type (gnat_entity)\n+\t    : gnat_entity;\n+\ttree xup_name\n+\t  = (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    ? create_concat_name (gnat_name, \"XUP\")\n+\t    : gnu_entity_name;\n+\tcreate_type_decl (xup_name, gnu_fat_type, true, debug_info_p,\n+\t\t\t  gnat_entity);\n+\n \t/* Build a reference to the template from a PLACEHOLDER_EXPR that\n \t   is the fat pointer.  This will be used to access the individual\n \t   fields once we build them.  */\n@@ -2313,6 +2341,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    = chainon (gnu_template_fields, gnu_temp_fields[index]);\n \tfinish_record_type (gnu_template_type, gnu_template_fields, 0,\n \t\t\t    debug_info_p);\n+\tTYPE_CONTEXT (gnu_template_type) = current_function_decl;\n \tTYPE_READONLY (gnu_template_type) = 1;\n \n \t/* If Component_Size is not already specified, annotate it with the\n@@ -2369,39 +2398,18 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \tif (TYPE_ALIAS_SET_KNOWN_P (gnu_fat_type))\n \t  record_component_aliases (gnu_fat_type);\n \n-\t/* The result type is an UNCONSTRAINED_ARRAY_TYPE that indicates the\n-\t   corresponding fat pointer.  */\n-\tTREE_TYPE (gnu_type) = gnu_fat_type;\n-\tTYPE_POINTER_TO (gnu_type) = gnu_fat_type;\n-\tTYPE_REFERENCE_TO (gnu_type) = gnu_fat_type;\n-\tSET_TYPE_MODE (gnu_type, BLKmode);\n-\tSET_TYPE_ALIGN (gnu_type, TYPE_ALIGN (tem));\n-\n \t/* If the maximum size doesn't overflow, use it.  */\n \tif (gnu_max_size\n \t    && TREE_CODE (gnu_max_size) == INTEGER_CST\n \t    && !TREE_OVERFLOW (gnu_max_size)\n \t    && compare_tree_int (gnu_max_size, TYPE_ARRAY_SIZE_LIMIT) <= 0)\n \t  TYPE_ARRAY_MAX_SIZE (tem) = gnu_max_size;\n \n+\t/* See the above description for the rationale.  */\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUA\"), tem,\n \t\t\t  artificial_p, debug_info_p, gnat_entity);\n-\n-\t/* If the GNAT encodings are used, give the fat pointer type a name.\n-\t   If this is a packed array, tell the debugger how to interpret the\n-\t   underlying bits by fetching that of the implementation type.  */\n-\tconst Entity_Id gnat_name\n-\t  = (Present (Packed_Array_Impl_Type (gnat_entity))\n-\t     && gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    ? Packed_Array_Impl_Type (gnat_entity)\n-\t    : gnat_entity;\n-\n-\ttree xup_name\n-\t  = (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    ? get_entity_name (gnat_name)\n-\t    : create_concat_name (gnat_name, \"XUP\");\n-\tcreate_type_decl (xup_name, gnu_fat_type, artificial_p, debug_info_p,\n-\t\t\t  gnat_entity);\n+\tTYPE_CONTEXT (tem) = gnu_fat_type;\n+\tTYPE_CONTEXT (TYPE_POINTER_TO (tem)) = gnu_fat_type;\n \n \t/* Create the type to be designated by thin pointers: a record type for\n \t   the array and its template.  We used to shift the fields to have the\n@@ -2412,14 +2420,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t   don't have to name them as a GNAT encoding, except if specifically\n \t   asked to.  */\n \ttree xut_name\n-\t  = (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-\t    ? get_entity_name (gnat_name)\n-\t    : create_concat_name (gnat_name, \"XUT\");\n-\ttem = build_unc_object_type (gnu_template_type, tem, xut_name,\n+\t  = (gnat_encodings != DWARF_GNAT_ENCODINGS_MINIMAL)\n+\t    ? create_concat_name (gnat_name, \"XUT\")\n+\t    : gnu_entity_name;\n+\tobj = build_unc_object_type (gnu_template_type, tem, xut_name,\n \t\t\t\t     debug_info_p);\n \n-\tSET_TYPE_UNCONSTRAINED_ARRAY (tem, gnu_type);\n-\tTYPE_OBJECT_RECORD_TYPE (gnu_type) = tem;\n+\tSET_TYPE_UNCONSTRAINED_ARRAY (obj, gnu_type);\n+\tTYPE_OBJECT_RECORD_TYPE (gnu_type) = obj;\n+\n+\t/* The result type is an UNCONSTRAINED_ARRAY_TYPE that indicates the\n+\t   corresponding fat pointer.  */\n+\tTREE_TYPE (gnu_type) = gnu_fat_type;\n+\tTYPE_POINTER_TO (gnu_type) = gnu_fat_type;\n+\tTYPE_REFERENCE_TO (gnu_type) = gnu_fat_type;\n+\tSET_TYPE_MODE (gnu_type, BLKmode);\n+\tSET_TYPE_ALIGN (gnu_type, TYPE_ALIGN (tem));\n       }\n       break;\n "}, {"sha": "5a5850a85e043829a4abd66d50f7d65e3e9eacec", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "patch": "@@ -778,7 +778,7 @@ gnat_get_array_descr_info (const_tree const_type,\n {\n   tree type = const_cast<tree> (const_type);\n   tree first_dimen, dimen;\n-  bool is_packed_array, is_array, is_fat_ptr;\n+  bool is_packed_array, is_array;\n   int i;\n \n   /* Temporaries created in the first pass and used in the second one for thin\n@@ -807,45 +807,16 @@ gnat_get_array_descr_info (const_tree const_type,\n       && TYPE_INDEX_TYPE (TYPE_DOMAIN (type)))\n     {\n       is_array = true;\n-      is_fat_ptr = false;\n       first_dimen = type;\n-      info->data_location = NULL_TREE;\n     }\n \n-  else if (TYPE_IS_FAT_POINTER_P (type)\n-\t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n-    {\n-      tree ua_type = TYPE_UNCONSTRAINED_ARRAY (type);\n-\n-      /* This will be our base object address.  */\n-      tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n-\n-      /* We assume below that maybe_unconstrained_array returns an INDIRECT_REF\n-\t node.  */\n-      tree ua_val\n-        = maybe_unconstrained_array (build_unary_op (INDIRECT_REF,\n-\t\t\t\t\t\t     ua_type,\n-\t\t\t\t\t\t     placeholder_expr));\n-\n-      is_array = false;\n-      is_fat_ptr = true;\n-      first_dimen = TREE_TYPE (ua_val);\n-\n-      /* Get the *address* of the array, not the array itself.  */\n-      info->data_location = TREE_OPERAND (ua_val, 0);\n-    }\n-\n-  /* Unlike fat pointers (which appear for unconstrained arrays passed in\n-     argument), thin pointers are used only for array access types, so we want\n-     them to appear in the debug info as pointers to an array type.  That's why\n-     we match only the RECORD_TYPE here instead of the POINTER_TYPE with the\n-     TYPE_IS_THIN_POINTER_P predicate.  */\n+  /* As well as array types embedded in a record type with their bounds.  */\n   else if (TREE_CODE (type) == RECORD_TYPE\n \t   && TYPE_CONTAINS_TEMPLATE_P (type)\n \t   && gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {\n       /* This will be our base object address.  Note that we assume that\n-\t pointers to these will actually point to the array field (thin\n+\t pointers to this will actually point to the array field (thin\n \t pointers are shifted).  */\n       tree placeholder_expr = build0 (PLACEHOLDER_EXPR, type);\n       tree placeholder_addr\n@@ -856,7 +827,7 @@ gnat_get_array_descr_info (const_tree const_type,\n       tree array_field = DECL_CHAIN (bounds_field);\n       tree array_type = TREE_TYPE (array_field);\n \n-      /* Shift the thin pointer address to get the address of the template.  */\n+      /* Shift back the address to get the address of the template.  */\n       tree shift_amount\n \t= fold_build1 (NEGATE_EXPR, sizetype, byte_position (array_field));\n       tree template_addr\n@@ -865,18 +836,12 @@ gnat_get_array_descr_info (const_tree const_type,\n       template_addr\n \t= fold_convert (TYPE_POINTER_TO (bounds_type), template_addr);\n \n+      thinptr_template_expr\n+\t= build_unary_op (INDIRECT_REF, NULL_TREE, template_addr);\n+      thinptr_bound_field = TYPE_FIELDS (bounds_type);\n+\n       is_array = false;\n-      is_fat_ptr = false;\n       first_dimen = array_type;\n-\n-      /* The thin pointer is already the pointer to the array data, so there's\n-\t no need for a specific \"data location\" expression.  */\n-      info->data_location = NULL_TREE;\n-\n-      thinptr_template_expr = build_unary_op (INDIRECT_REF,\n-\t\t\t\t\t      bounds_type,\n-\t\t\t\t\t      template_addr);\n-      thinptr_bound_field = TYPE_FIELDS (bounds_type);\n     }\n \n   else\n@@ -932,7 +897,7 @@ gnat_get_array_descr_info (const_tree const_type,\n       /* We are interested in the stored bounds for the debug info.  */\n       tree index_type = TYPE_INDEX_TYPE (TYPE_DOMAIN (dimen));\n \n-      if (is_array || is_fat_ptr)\n+      if (is_array)\n \t{\n \t  /* GDB does not handle very well the self-referencial bound\n \t     expressions we are able to generate here for XUA types (they are\n@@ -983,6 +948,7 @@ gnat_get_array_descr_info (const_tree const_type,\n   /* These are Fortran-specific fields.  They make no sense here.  */\n   info->allocated = NULL_TREE;\n   info->associated = NULL_TREE;\n+  info->data_location = NULL_TREE;\n \n   if (gnat_encodings == DWARF_GNAT_ENCODINGS_MINIMAL)\n     {"}, {"sha": "fb08b6c90ed88b144174e851afc1340faaf598dc", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a27aceb98a1178297cefb6eabe24d8a2ea4b72cd/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=a27aceb98a1178297cefb6eabe24d8a2ea4b72cd", "patch": "@@ -891,6 +891,9 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n \t     their GNAT encodings.  */\n \t  if (TREE_CODE (t) == ARRAY_TYPE && !TYPE_NAME (t))\n \t    TYPE_NAME (t) = DECL_NAME (decl);\n+\t  /* Remark the canonical fat pointer type as artificial.  */\n+\t  if (TYPE_IS_FAT_POINTER_P (t))\n+\t    TYPE_ARTIFICIAL (t) = 1;\n \t  t = NULL_TREE;\n \t}\n       else if (TYPE_NAME (t)\n@@ -4167,7 +4170,6 @@ tree\n build_unc_object_type (tree template_type, tree object_type, tree name,\n \t\t       bool debug_info_p)\n {\n-  tree decl;\n   tree type = make_node (RECORD_TYPE);\n   tree template_field\n     = create_field_decl (get_identifier (\"BOUNDS\"), template_type, type,\n@@ -4183,12 +4185,7 @@ build_unc_object_type (tree template_type, tree object_type, tree name,\n \n   /* Declare it now since it will never be declared otherwise.  This is\n      necessary to ensure that its subtrees are properly marked.  */\n-  decl = create_type_decl (name, type, true, debug_info_p, Empty);\n-\n-  /* template_type will not be used elsewhere than here, so to keep the debug\n-     info clean and in order to avoid scoping issues, make decl its\n-     context.  */\n-  gnat_set_type_context (template_type, decl);\n+  create_type_decl (name, type, true, debug_info_p, Empty);\n \n   return type;\n }"}]}