{"sha": "8589ae15787afc9ab55d5f6a53582e84896faffe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODU4OWFlMTU3ODdhZmM5YWI1NWQ1ZjZhNTM1ODJlODQ4OTZmYWZmZQ==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2004-08-03T15:00:49Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2004-08-03T15:00:49Z"}, "message": "ra-build.c (conflicts_between_webs): For webs that cross a call add conflicts to regs_invalidated_by_call.\n\n2004-08-03  Pat Haugen  <pthaugen@us.ibm.com>\n\n        * ra-build.c (conflicts_between_webs): For webs that cross a call add\n        conflicts to regs_invalidated_by_call.\n\nFrom-SVN: r85482", "tree": {"sha": "3164915de82af253641d1ec14bbc4aa52b2fbaf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3164915de82af253641d1ec14bbc4aa52b2fbaf8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8589ae15787afc9ab55d5f6a53582e84896faffe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8589ae15787afc9ab55d5f6a53582e84896faffe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8589ae15787afc9ab55d5f6a53582e84896faffe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8589ae15787afc9ab55d5f6a53582e84896faffe/comments", "author": null, "committer": null, "parents": [{"sha": "8ee6eb4e8c7bba61f471d259f84cb11f92120eb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee6eb4e8c7bba61f471d259f84cb11f92120eb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee6eb4e8c7bba61f471d259f84cb11f92120eb7"}], "stats": {"total": 21, "additions": 15, "deletions": 6}, "files": [{"sha": "40fd96b3e1190c75f048e9d2f879409d47e74988", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8589ae15787afc9ab55d5f6a53582e84896faffe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8589ae15787afc9ab55d5f6a53582e84896faffe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8589ae15787afc9ab55d5f6a53582e84896faffe", "patch": "@@ -1,3 +1,8 @@\n+2004-08-03  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\t* ra-build.c (conflicts_between_webs): For webs that cross a call add\n+\tconflicts to regs_invalidated_by_call.\n+\n 2004-08-03  Paul Brook  <paul@codesourcery.com>\n \n \t* config/arm/arm.c (emit_sfm): Only emit a single frame adjustment."}, {"sha": "63fb24e05970bbebc8f369df60c026db6972bc8a", "filename": "gcc/ra-build.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8589ae15787afc9ab55d5f6a53582e84896faffe/gcc%2Fra-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8589ae15787afc9ab55d5f6a53582e84896faffe/gcc%2Fra-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-build.c?ref=8589ae15787afc9ab55d5f6a53582e84896faffe", "patch": "@@ -2176,9 +2176,7 @@ static void\n conflicts_between_webs (struct df *df)\n {\n   unsigned int i;\n-#ifdef STACK_REGS\n   struct dlist *d;\n-#endif\n   bitmap ignore_defs = BITMAP_XMALLOC ();\n   unsigned int have_ignored;\n   unsigned int *pass_cache = xcalloc (num_webs, sizeof (int));\n@@ -2253,18 +2251,24 @@ conflicts_between_webs (struct df *df)\n   free (pass_cache);\n   BITMAP_XFREE (ignore_defs);\n \n-#ifdef STACK_REGS\n-  /* Pseudos can't go in stack regs if they are live at the beginning of\n-     a block that is reached by an abnormal edge.  */\n   for (d = WEBS(INITIAL); d; d = d->next)\n     {\n       struct web *web = DLIST_WEB (d);\n       int j;\n+\n+      if (web->crosses_call)\n+\tfor (j = 0; j < FIRST_PSEUDO_REGISTER; j++)\n+\t  if (TEST_HARD_REG_BIT (regs_invalidated_by_call, j))\n+\t    record_conflict (web, hardreg2web[j]);\n+\n+#ifdef STACK_REGS\n+      /* Pseudos can't go in stack regs if they are live at the beginning of\n+\t a block that is reached by an abnormal edge.  */\n       if (web->live_over_abnormal)\n \tfor (j = FIRST_STACK_REG; j <= LAST_STACK_REG; j++)\n \t  record_conflict (web, hardreg2web[j]);\n-    }\n #endif\n+    }\n }\n \n /* Remember that a web was spilled, and change some characteristics"}]}