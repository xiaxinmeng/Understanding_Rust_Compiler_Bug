{"sha": "69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk3MDhlMGFmYmYzYTM3NTdiOWY2ODliYjU0YWNmZjFkN2U4ZDllYw==", "commit": {"author": {"name": "Mihail Ionescu", "email": "mihail.ionescu@arm.com", "date": "2019-05-08T14:36:15Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2019-05-08T14:36:15Z"}, "message": "[arm][PR88167] Fix __builtin_return_address returns invalid address\n\nThis patch fixes a problem with the thumb1 prologue code where the link\nregister could be unconditionally used as a scratch register even if the\nreturn value was still live at the end of the prologue.\n\nAdditionally, the patch improves the code generated when we are not\nusing many low call-saved registers to make use of any unused call\nclobbered registers to help with the saving of high registers that\ncannot be pushed directly (quite rare in normal code as the register\nallocator correctly prefers low registers).\n\n2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>\n\t    Richard Earnshaw  <rearnsha@arm.com>\n\ngcc:\n\n\tPR target/88167\n\t* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New\n\tfunction.\n\t(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.\n\t(thumb1_compute_save_core_reg_mask): Don't force a spare work\n\tregister if both the epilogue and prologue can use call-clobbered\n\tregs.\n\t(thumb1_unexpanded_epilogue): Use\n\tthumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for\n\tpicking temporaries for restoring high regs to match that of the\n\tprologue where possible.\n\t(thumb1_expand_prologue): Add any usable call-clobbered low registers to\n\tthe list of work registers.  Detect if the return address is still live\n\tat the end of the prologue and avoid using it for a work register if so.\n\tIf the return address is not live, add LR to the list of pushable regs\n\tafter the first pass.\n\ngcc/testsuite:\n\n\tPR target/88167\n\t* gcc.target/arm/pr88167-1.c: New test.\n\t* gcc.target/arm/pr88167-2.c: New test.\n\n\nCo-Authored-By: Richard Earnshaw <rearnsha@arm.com>\n\nFrom-SVN: r271012", "tree": {"sha": "ecab78ea40e90eb3e8088b2bb966d1c675b8e801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ecab78ea40e90eb3e8088b2bb966d1c675b8e801"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/comments", "author": null, "committer": null, "parents": [{"sha": "857c72026ed7d78a7bf92f3d9a3d773f1a5edbc3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/857c72026ed7d78a7bf92f3d9a3d773f1a5edbc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/857c72026ed7d78a7bf92f3d9a3d773f1a5edbc3"}], "stats": {"total": 144, "additions": 127, "deletions": 17}, "files": [{"sha": "7723381047dce7ab07beaaf75da490059627a3e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "patch": "@@ -1,3 +1,23 @@\n+2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>\n+\t    Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88167\n+\t* config/arm/arm.c (thumb1_prologue_unused_call_clobbered_lo_regs): New\n+\tfunction.\n+\t(thumb1_epilogue_unused_call_clobbered_lo_regs): New function.\n+\t(thumb1_compute_save_core_reg_mask): Don't force a spare work\n+\tregister if both the epilogue and prologue can use call-clobbered\n+\tregs.\n+\t(thumb1_unexpanded_epilogue): Use\n+\tthumb1_epilogue_unused_call_clobbered_lo_regs.  Reverse the logic for\n+\tpicking temporaries for restoring high regs to match that of the\n+\tprologue where possible.\n+\t(thumb1_expand_prologue): Add any usable call-clobbered low registers to\n+\tthe list of work registers.  Detect if the return address is still live\n+\tat the end of the prologue and avoid using it for a work register if so.\n+\tIf the return address is not live, add LR to the list of pushable regs\n+\tafter the first pass.\n+\n 2019-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \tPR tree-optimization/90078"}, {"sha": "91bb65130b83c4726fe2258180dff19542918788", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 67, "deletions": 17, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "patch": "@@ -19670,6 +19670,35 @@ arm_compute_save_core_reg_mask (void)\n   return save_reg_mask;\n }\n \n+/* Return a mask for the call-clobbered low registers that are unused\n+   at the end of the prologue.  */\n+static unsigned long\n+thumb1_prologue_unused_call_clobbered_lo_regs (void)\n+{\n+  unsigned long mask = 0;\n+\n+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)\n+    if (!callee_saved_reg_p (reg)\n+\t&& !REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t     reg))\n+      mask |= 1 << reg;\n+  return mask;\n+}\n+\n+/* Similarly for the start of the epilogue.  */\n+static unsigned long\n+thumb1_epilogue_unused_call_clobbered_lo_regs (void)\n+{\n+  unsigned long mask = 0;\n+\n+  for (int reg = 0; reg <= LAST_LO_REGNUM; reg++)\n+    if (!callee_saved_reg_p (reg)\n+\t&& !REGNO_REG_SET_P (df_get_live_in (EXIT_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t     reg))\n+      mask |= 1 << reg;\n+  return mask;\n+}\n+\n /* Compute a bit mask of which core registers need to be\n    saved on the stack for the current function.  */\n static unsigned long\n@@ -19701,10 +19730,19 @@ thumb1_compute_save_core_reg_mask (void)\n   if (mask & 0xff || thumb_force_lr_save ())\n     mask |= (1 << LR_REGNUM);\n \n-  /* Make sure we have a low work register if we need one.\n-     We will need one if we are going to push a high register,\n-     but we are not currently intending to push a low register.  */\n+  bool call_clobbered_scratch\n+    = (thumb1_prologue_unused_call_clobbered_lo_regs ()\n+       && thumb1_epilogue_unused_call_clobbered_lo_regs ());\n+\n+  /* Make sure we have a low work register if we need one.  We will\n+     need one if we are going to push a high register, but we are not\n+     currently intending to push a low register.  However if both the\n+     prologue and epilogue have a spare call-clobbered low register,\n+     then we won't need to find an additional work register.  It does\n+     not need to be the same register in the prologue and\n+     epilogue.  */\n   if ((mask & 0xff) == 0\n+      && !call_clobbered_scratch\n       && ((mask & 0x0f00) || TARGET_BACKTRACE))\n     {\n       /* Use thumb_find_work_register to choose which register\n@@ -24930,49 +24968,46 @@ thumb1_unexpanded_epilogue (void)\n       unsigned long mask = live_regs_mask & 0xff;\n       int next_hi_reg;\n \n-      /* The available low registers depend on the size of the value we are\n-         returning.  */\n-      if (size <= 12)\n-\tmask |=  1 << 3;\n-      if (size <= 8)\n-\tmask |= 1 << 2;\n+      mask |= thumb1_epilogue_unused_call_clobbered_lo_regs ();\n \n       if (mask == 0)\n \t/* Oh dear!  We have no low registers into which we can pop\n            high registers!  */\n \tinternal_error\n \t  (\"no low registers available for popping high registers\");\n \n-      for (next_hi_reg = 8; next_hi_reg < 13; next_hi_reg++)\n+      for (next_hi_reg = 12; next_hi_reg > LAST_LO_REGNUM; next_hi_reg--)\n \tif (live_regs_mask & (1 << next_hi_reg))\n \t  break;\n \n       while (high_regs_pushed)\n \t{\n \t  /* Find lo register(s) into which the high register(s) can\n              be popped.  */\n-\t  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n+\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)\n \t    {\n \t      if (mask & (1 << regno))\n \t\thigh_regs_pushed--;\n \t      if (high_regs_pushed == 0)\n \t\tbreak;\n \t    }\n \n-\t  mask &= (2 << regno) - 1;\t/* A noop if regno == 8 */\n+\t  if (high_regs_pushed == 0 && regno >= 0)\n+\t    mask &= ~((1 << regno) - 1);\n \n \t  /* Pop the values into the low register(s).  */\n \t  thumb_pop (asm_out_file, mask);\n \n \t  /* Move the value(s) into the high registers.  */\n-\t  for (regno = 0; regno <= LAST_LO_REGNUM; regno++)\n+\t  for (regno = LAST_LO_REGNUM; regno >= 0; regno--)\n \t    {\n \t      if (mask & (1 << regno))\n \t\t{\n \t\t  asm_fprintf (asm_out_file, \"\\tmov\\t%r, %r\\n\", next_hi_reg,\n \t\t\t       regno);\n \n-\t\t  for (next_hi_reg++; next_hi_reg < 13; next_hi_reg++)\n+\t\t  for (next_hi_reg--; next_hi_reg > LAST_LO_REGNUM;\n+\t\t       next_hi_reg--)\n \t\t    if (live_regs_mask & (1 << next_hi_reg))\n \t\t      break;\n \t\t}\n@@ -25354,10 +25389,20 @@ thumb1_expand_prologue (void)\n \t  break;\n \n       /* Here we need to mask out registers used for passing arguments\n-\t even if they can be pushed.  This is to avoid using them to stash the high\n-\t registers.  Such kind of stash may clobber the use of arguments.  */\n+\t even if they can be pushed.  This is to avoid using them to\n+\t stash the high registers.  Such kind of stash may clobber the\n+\t use of arguments.  */\n       pushable_regs = l_mask & (~arg_regs_mask);\n-      if (lr_needs_saving)\n+      pushable_regs |= thumb1_prologue_unused_call_clobbered_lo_regs ();\n+\n+      /* Normally, LR can be used as a scratch register once it has been\n+\t saved; but if the function examines its own return address then\n+\t the value is still live and we need to avoid using it.  */\n+      bool return_addr_live\n+\t= REGNO_REG_SET_P (df_get_live_out (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n+\t\t\t   LR_REGNUM);\n+\n+      if (lr_needs_saving || return_addr_live)\n \tpushable_regs &= ~(1 << LR_REGNUM);\n \n       if (pushable_regs == 0)\n@@ -25398,6 +25443,11 @@ thumb1_expand_prologue (void)\n \t      push_mask |= 1 << LR_REGNUM;\n \t      real_regs_mask |= 1 << LR_REGNUM;\n \t      lr_needs_saving = false;\n+\t      /* If the return address is not live at this point, we\n+\t\t can add LR to the list of registers that we can use\n+\t\t for pushes.  */\n+\t      if (!return_addr_live)\n+\t\tpushable_regs |= 1 << LR_REGNUM;\n \t    }\n \n \t  insn = thumb1_emit_multi_reg_push (push_mask, real_regs_mask);"}, {"sha": "ca9d2055a065caa4a0999b72575942d6f1e3bda9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "patch": "@@ -1,3 +1,10 @@\n+2019-05-08  Mihail Ionescu  <mihail.ionescu@arm.com>\n+\t    Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/88167\n+\t* gcc.target/arm/pr88167-1.c: New test.\n+\t* gcc.target/arm/pr88167-2.c: New test.\n+\n 2018-05-08  Bin Cheng  <bin.cheng@linux.alibaba.com>\n \n \tPR tree-optimization/90078"}, {"sha": "517a86d6e4ba91aa502995dc5f2c3ef070bcf882", "filename": "gcc/testsuite/gcc.target/arm/pr88167-1.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-1.c?ref=69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_thumb1_ok } */\n+/* { dg-options \"-O2 -mthumb\" }  */\n+\n+void *retaddr;\n+\n+void foo (void) {\n+  retaddr = __builtin_return_address (0);\n+\n+  /* Used for enforcing registers stacking.  */\n+  asm volatile (\"\" : : : \"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\",\n+\t\t\t \"r8\", \"r9\", \"r10\", \"r11\", \"r12\");\n+}\n+\n+/* { dg-final { scan-assembler-not \"mov\\tlr,\" } } */"}, {"sha": "6a303345eb9808957e2b029243eea5a341385ad9", "filename": "gcc/testsuite/gcc.target/arm/pr88167-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69708e0afbf3a3757b9f689bb54acff1d7e8d9ec/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fpr88167-2.c?ref=69708e0afbf3a3757b9f689bb54acff1d7e8d9ec", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2\" }  */\n+/* { dg-skip-if \"\" { ! { arm_thumb1 } } } */\n+\n+int __attribute__((noclone, noinline))\n+foo (int a, long long b) {\n+  /* Used for enforcing registers stacking.  */\n+  asm volatile (\"\" : : : \"r0\", \"r1\", \"r2\", \"r3\",\n+\t\t\t \"r8\", \"r9\", \"r10\", \"r11\", \"r12\");\n+  return (int) b;\n+}\n+\n+int main ()\n+{\n+  if (foo (1, 0x1000000000000003LL) != 3)\n+    __builtin_abort ();\n+  __builtin_exit (0);\n+}"}]}