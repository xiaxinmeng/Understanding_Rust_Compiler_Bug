{"sha": "5e9bec999ea3f54fc6abfabc9d43bacfdd550892", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU5YmVjOTk5ZWEzZjU0ZmM2YWJmYWJjOWQ0M2JhY2ZkZDU1MDg5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:14:04Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:14:04Z"}, "message": "Add prototypes for layout_record and layout_union.\n\n(smallest_mode_for_size): New function.\n(variable_size): Allow variable sizes if global_bindings_p returns a negative\nvalue.\n(mode_for_size): Fix incorrect comment.\n(layout_decl): If DECL has a size already, don't copy from type.\n(layout_type, case INTEGER_TYPE, ENUMERAL_TYPE): Use smallest integer mode\nthat fits, whether or not it fits exactly.\n\nFrom-SVN: r4776", "tree": {"sha": "389918c825ddc54d4c8b37ba134c9a83bac5395e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/389918c825ddc54d4c8b37ba134c9a83bac5395e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e9bec999ea3f54fc6abfabc9d43bacfdd550892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9bec999ea3f54fc6abfabc9d43bacfdd550892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e9bec999ea3f54fc6abfabc9d43bacfdd550892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e9bec999ea3f54fc6abfabc9d43bacfdd550892/comments", "author": null, "committer": null, "parents": [{"sha": "457a2d9ce658ff0e39f6c0b7bf23de5470e4c7a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/457a2d9ce658ff0e39f6c0b7bf23de5470e4c7a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/457a2d9ce658ff0e39f6c0b7bf23de5470e4c7a8"}], "stats": {"total": 47, "additions": 38, "deletions": 9}, "files": [{"sha": "620c0bb2b91a653edd20ae5f3bca3c8582010840", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 38, "deletions": 9, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e9bec999ea3f54fc6abfabc9d43bacfdd550892/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e9bec999ea3f54fc6abfabc9d43bacfdd550892/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=5e9bec999ea3f54fc6abfabc9d43bacfdd550892", "patch": "@@ -1,5 +1,5 @@\n /* C-compiler utilities for types and variables storage layout\n-   Copyright (C) 1987, 1988, 1992 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1992, 1993 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -47,6 +47,11 @@ int maximum_field_alignment;\n #define GET_MODE_ALIGNMENT(MODE)   \\\n   MIN (BIGGEST_ALIGNMENT, \t   \\\n        MAX (1, (GET_MODE_UNIT_SIZE (MODE) * BITS_PER_UNIT)))\n+\n+static enum machine_mode smallest_mode_for_size  PROTO((unsigned int,\n+\t\t\t\t\t\t\tenum mode_class));\n+static tree layout_record\tPROTO((tree));\n+static void layout_union\tPROTO((tree));\n \f\n /* SAVE_EXPRs for sizes of types and decls, waiting to be expanded.  */\n \n@@ -79,7 +84,13 @@ variable_size (size)\n {\n   size = save_expr (size);\n \n-  if (global_bindings_p ())\n+  /* If the language-processor is to take responsibility for variable-sized\n+     items (e.g., languages which have elaboration procedures like Ada),\n+     just return SIZE unchanged.  */\n+  if (global_bindings_p () < 0)\n+    return size;\n+\n+  else if (global_bindings_p ())\n     {\n       if (TREE_CONSTANT (size))\n \terror (\"type size can't be explicitly evaluated\");\n@@ -120,7 +131,7 @@ mode_for_size (size, class, limit)\n   if (limit && size > MAX_FIXED_MODE_SIZE)\n     return BLKmode;\n \n-  /* Get the last mode which has this size, in the specified class.  */\n+  /* Get the first mode which has this size, in the specified class.  */\n   for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n        mode = GET_MODE_WIDER_MODE (mode))\n     if (GET_MODE_BITSIZE (mode) == size)\n@@ -129,6 +140,26 @@ mode_for_size (size, class, limit)\n   return BLKmode;\n }\n \n+/* Similar, but never return BLKmode; return the narrowest mode that\n+   contains at least the requested number of bits.  */\n+\n+static enum machine_mode\n+smallest_mode_for_size (size, class)\n+     unsigned int size;\n+     enum mode_class class;\n+{\n+  register enum machine_mode mode;\n+\n+  /* Get the first mode which has at least this size, in the\n+     specified class.  */\n+  for (mode = GET_CLASS_NARROWEST_MODE (class); mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_BITSIZE (mode) >= size)\n+      return mode;\n+\n+  abort ();\n+}\n+\n /* Return the value of VALUE, rounded up to a multiple of DIVISOR.  */\n \n tree\n@@ -179,8 +210,9 @@ layout_decl (decl, known_align)\n   /* Usually the size and mode come from the data type without change.  */\n \n   DECL_MODE (decl) = TYPE_MODE (type);\n-  DECL_SIZE (decl) = TYPE_SIZE (type);\n   TREE_UNSIGNED (decl) = TREE_UNSIGNED (type);\n+  if (DECL_SIZE (decl) == 0)\n+    DECL_SIZE (decl) = TYPE_SIZE (type);\n \n   if (code == FIELD_DECL && DECL_BIT_FIELD (decl))\n     {\n@@ -669,11 +701,8 @@ layout_type (type)\n       if (TREE_INT_CST_HIGH (TYPE_MIN_VALUE (type)) >= 0)\n \tTREE_UNSIGNED (type) = 1;\n \n-      /* We pass 0 for the last arg of mode_for_size because otherwise\n-\t on the Apollo using long long causes a crash.\n-\t It seems better to use integer modes than to try to support\n-\t integer types with BLKmode.  */\n-      TYPE_MODE (type) = mode_for_size (TYPE_PRECISION (type), MODE_INT, 0);\n+      TYPE_MODE (type) = smallest_mode_for_size (TYPE_PRECISION (type),\n+\t\t\t\t\t\t MODE_INT);\n       TYPE_SIZE (type) = size_int (GET_MODE_BITSIZE (TYPE_MODE (type)));\n       break;\n "}]}