{"sha": "52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJiYTJmNmQxNDdiNWQzNmQ1ZDgxMjIwMGY3Y2JlZGUwODAzZjdmMQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-12-16T15:38:19Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-12-16T15:38:19Z"}, "message": "reorg.c (mostly_true_jump): Clean up code depending on LABEL_OUTSIDE_LOOP_P and loop notes.\n\n\t* reorg.c (mostly_true_jump): Clean up code depending on\n\tLABEL_OUTSIDE_LOOP_P and loop notes.  Remove code doing\n\tpoor man's branch prediction, instead rely on REG_BR_PROB\n\tnotes to be available.\n\nFrom-SVN: r108653", "tree": {"sha": "c319077994161c5a5df9b44f54d22e7cf5199a43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c319077994161c5a5df9b44f54d22e7cf5199a43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52ba2f6d147b5d36d5d812200f7cbede0803f7f1/comments", "author": null, "committer": null, "parents": [{"sha": "5adb25cf832a5e71551ed24fa6b2a3ba6f7a48f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5adb25cf832a5e71551ed24fa6b2a3ba6f7a48f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5adb25cf832a5e71551ed24fa6b2a3ba6f7a48f9"}], "stats": {"total": 63, "additions": 10, "deletions": 53}, "files": [{"sha": "a73bcb424ee0254c39f59d4c1e477bd9395c22e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ba2f6d147b5d36d5d812200f7cbede0803f7f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ba2f6d147b5d36d5d812200f7cbede0803f7f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "patch": "@@ -1,3 +1,10 @@\n+2005-12-16  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* reorg.c (mostly_true_jump): Clean up code depending on\n+\tLABEL_OUTSIDE_LOOP_P and loop notes.  Remove code doing\n+\tpoor man's branch prediction, instead rely on REG_BR_PROB\n+\tnotes to be available.\n+\n 2005-12-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/24899"}, {"sha": "104ad8e467f559265571642bfb857f19b7d1e831", "filename": "gcc/reorg.c", "status": "modified", "additions": 3, "deletions": 53, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52ba2f6d147b5d36d5d812200f7cbede0803f7f1/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52ba2f6d147b5d36d5d812200f7cbede0803f7f1/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=52ba2f6d147b5d36d5d812200f7cbede0803f7f1", "patch": "@@ -964,8 +964,7 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n {\n   rtx target_label = JUMP_LABEL (jump_insn);\n   rtx insn, note;\n-  int rare_dest = rare_destination (target_label);\n-  int rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n+  int rare_dest, rare_fallthrough;\n \n   /* If branch probabilities are available, then use that number since it\n      always gives a correct answer.  */\n@@ -984,32 +983,10 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n \treturn -1;\n     }\n \n-  /* ??? Ought to use estimate_probability instead.  */\n-\n-  /* If this is a branch outside a loop, it is highly unlikely.  */\n-  if (GET_CODE (PATTERN (jump_insn)) == SET\n-      && GET_CODE (SET_SRC (PATTERN (jump_insn))) == IF_THEN_ELSE\n-      && ((GET_CODE (XEXP (SET_SRC (PATTERN (jump_insn)), 1)) == LABEL_REF\n-\t   && LABEL_OUTSIDE_LOOP_P (XEXP (SET_SRC (PATTERN (jump_insn)), 1)))\n-\t  || (GET_CODE (XEXP (SET_SRC (PATTERN (jump_insn)), 2)) == LABEL_REF\n-\t      && LABEL_OUTSIDE_LOOP_P (XEXP (SET_SRC (PATTERN (jump_insn)), 2)))))\n-    return -1;\n-\n-  if (target_label)\n-    {\n-      /* If this is the test of a loop, it is very likely true.  We scan\n-\t backwards from the target label.  If we find a NOTE_INSN_LOOP_BEG\n-\t before the next real insn, we assume the branch is to the top of\n-\t the loop.  */\n-      for (insn = PREV_INSN (target_label);\n-\t   insn && NOTE_P (insn);\n-\t   insn = PREV_INSN (insn))\n-\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-\t  return 2;\n-    }\n-\n   /* Look at the relative rarities of the fallthrough and destination.  If\n      they differ, we can predict the branch that way.  */\n+  rare_dest = rare_destination (target_label);\n+  rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n \n   switch (rare_fallthrough - rare_dest)\n     {\n@@ -1030,33 +1007,6 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n   if (condition == 0)\n     return 0;\n \n-  /* EQ tests are usually false and NE tests are usually true.  Also,\n-     most quantities are positive, so we can make the appropriate guesses\n-     about signed comparisons against zero.  */\n-  switch (GET_CODE (condition))\n-    {\n-    case CONST_INT:\n-      /* Unconditional branch.  */\n-      return 1;\n-    case EQ:\n-      return 0;\n-    case NE:\n-      return 1;\n-    case LE:\n-    case LT:\n-      if (XEXP (condition, 1) == const0_rtx)\n-\treturn 0;\n-      break;\n-    case GE:\n-    case GT:\n-      if (XEXP (condition, 1) == const0_rtx)\n-\treturn 1;\n-      break;\n-\n-    default:\n-      break;\n-    }\n-\n   /* Predict backward branches usually take, forward branches usually not.  If\n      we don't know whether this is forward or backward, assume the branch\n      will be taken, since most are.  */"}]}