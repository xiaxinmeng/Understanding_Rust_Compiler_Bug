{"sha": "f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "node_id": "C_kwDOANBUbNoAKGY1NTZjZDhiZDc5MjliZThiNzNjNjZkNTVmOThmZWFjOGM5ZWYxZWU", "commit": {"author": {"name": "Ju-Zhe Zhong", "email": "juzhe.zhong@rivai.ai", "date": "2022-10-24T02:08:53Z"}, "committer": {"name": "Kito Cheng", "email": "kito.cheng@sifive.com", "date": "2022-10-26T09:01:36Z"}, "message": "RISC-V: Support load/store in mov<mode> pattern for RVV modes.\n\ngcc/ChangeLog:\n\n\t* config.gcc (riscv*): Add riscv-v.o to extra_objs.\n\t* config/riscv/constraints.md (vu): New constraint.\n\t(vi): Ditto.\n\t(Wc0): Ditto.\n\t(Wc1): Ditto.\n\t* config/riscv/predicates.md (vector_length_operand): New.\n\t(reg_or_mem_operand): Ditto.\n\t(vector_move_operand): Ditto.\n\t(vector_mask_operand): Ditto.\n\t(vector_merge_operand): Ditto.\n\t* config/riscv/riscv-protos.h (riscv_regmode_natural_size) New.\n\t(riscv_vector::const_vec_all_same_in_range_p): Ditto.\n\t(riscv_vector::legitimize_move): Ditto.\n\t(tail_policy): Ditto.\n\t(mask_policy): Ditto.\n\t* config/riscv/riscv-v.cc: New.\n\t* config/riscv/riscv-vector-builtins-bases.cc\n\t(vsetvl::expand): Refactor how LMUL encoding.\n\t* config/riscv/riscv.cc (riscv_print_operand): Update how LMUL\n\tprint and mask operand print.\n\t(riscv_regmode_natural_size): New.\n\t* config/riscv/riscv.h (REGMODE_NATURAL_SIZE): New.\n\t* config/riscv/riscv.md (mode): Add vector modes.\n\t* config/riscv/t-riscv (riscv-v.o) New.\n\t* config/riscv/vector-iterators.md: New.\n\t* config/riscv/vector.md (vundefined<mode>): New.\n\t(mov<mode>): New.\n\t(*mov<mode>): New.\n\t(@vsetvl<mode>_no_side_effects): New.\n\t(@pred_mov<mode>): New.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.target/riscv/rvv/base/mov-1.c: New.\n\t* gcc.target/riscv/rvv/base/mov-10.c: New.\n\t* gcc.target/riscv/rvv/base/mov-11.c: New.\n\t* gcc.target/riscv/rvv/base/mov-12.c: New.\n\t* gcc.target/riscv/rvv/base/mov-13.c: New.\n\t* gcc.target/riscv/rvv/base/mov-2.c: New.\n\t* gcc.target/riscv/rvv/base/mov-3.c: New.\n\t* gcc.target/riscv/rvv/base/mov-4.c: New.\n\t* gcc.target/riscv/rvv/base/mov-5.c: New.\n\t* gcc.target/riscv/rvv/base/mov-6.c: New.\n\t* gcc.target/riscv/rvv/base/mov-7.c: New.\n\t* gcc.target/riscv/rvv/base/mov-8.c: New.\n\t* gcc.target/riscv/rvv/base/mov-9.c: New.", "tree": {"sha": "b2953766e61d3674ec7dc730d3b0dd94aae9158f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2953766e61d3674ec7dc730d3b0dd94aae9158f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/comments", "author": {"login": "zhongjuzhe", "id": 66454988, "node_id": "MDQ6VXNlcjY2NDU0OTg4", "avatar_url": "https://avatars.githubusercontent.com/u/66454988?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhongjuzhe", "html_url": "https://github.com/zhongjuzhe", "followers_url": "https://api.github.com/users/zhongjuzhe/followers", "following_url": "https://api.github.com/users/zhongjuzhe/following{/other_user}", "gists_url": "https://api.github.com/users/zhongjuzhe/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhongjuzhe/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhongjuzhe/subscriptions", "organizations_url": "https://api.github.com/users/zhongjuzhe/orgs", "repos_url": "https://api.github.com/users/zhongjuzhe/repos", "events_url": "https://api.github.com/users/zhongjuzhe/events{/privacy}", "received_events_url": "https://api.github.com/users/zhongjuzhe/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kito-cheng", "id": 2723185, "node_id": "MDQ6VXNlcjI3MjMxODU=", "avatar_url": "https://avatars.githubusercontent.com/u/2723185?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kito-cheng", "html_url": "https://github.com/kito-cheng", "followers_url": "https://api.github.com/users/kito-cheng/followers", "following_url": "https://api.github.com/users/kito-cheng/following{/other_user}", "gists_url": "https://api.github.com/users/kito-cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/kito-cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kito-cheng/subscriptions", "organizations_url": "https://api.github.com/users/kito-cheng/orgs", "repos_url": "https://api.github.com/users/kito-cheng/repos", "events_url": "https://api.github.com/users/kito-cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/kito-cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86654b2cc167b540f4f144549b80748ce0054729", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86654b2cc167b540f4f144549b80748ce0054729", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86654b2cc167b540f4f144549b80748ce0054729"}], "stats": {"total": 2449, "additions": 2421, "deletions": 28}, "files": [{"sha": "e8fe623c6fe0cafb5d97550d28994cbcd14c8fc5", "filename": "gcc/config.gcc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -516,7 +516,7 @@ pru-*-*)\n \t;;\n riscv*)\n \tcpu_type=riscv\n-\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o\"\n+\textra_objs=\"riscv-builtins.o riscv-c.o riscv-sr.o riscv-shorten-memrefs.o riscv-selftests.o riscv-v.o\"\n \textra_objs=\"${extra_objs} riscv-vector-builtins.o riscv-vector-builtins-shapes.o riscv-vector-builtins-bases.o\"\n \td_target_objs=\"riscv-d.o\"\n \textra_headers=\"riscv_vector.h\""}, {"sha": "951dcc52d6b8987ef8d53ec91fd3bb7a5713668d", "filename": "gcc/config/riscv/constraints.md", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fconstraints.md?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -128,3 +128,25 @@\n   \"POLY_INT\"\n   (and (match_code \"const_poly_int\")\n        (match_test \"known_eq (rtx_to_poly_int64 (op), BYTES_PER_RISCV_VECTOR)\")))\n+\n+(define_constraint \"vu\"\n+  \"A undefined vector value.\"\n+  (and (match_code \"unspec\")\n+       (match_test \"XINT (op, 1) == UNSPEC_VUNDEF\")))\n+\n+(define_constraint \"vi\"\n+  \"A vector 5-bit signed immediate.\"\n+  (and (match_code \"const_vector\")\n+       (match_test \"riscv_vector::const_vec_all_same_in_range_p (op, -16, 15)\")))\n+\n+(define_constraint \"Wc0\"\n+  \"@internal\n+ A constraint that matches a vector of immediate all zeros.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"op == CONST0_RTX (GET_MODE (op))\")))\n+\n+(define_constraint \"Wc1\"\n+  \"@internal\n+ A constraint that matches a vector of immediate all ones.\"\n+ (and (match_code \"const_vector\")\n+      (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))"}, {"sha": "c2ff41bb0fd87635cdaef88acaecae301110a96c", "filename": "gcc/config/riscv/predicates.md", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fpredicates.md?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -262,3 +262,26 @@\n \n \treturn true;\n })\n+\n+;; Predicates for the V extension.\n+(define_special_predicate \"vector_length_operand\"\n+  (ior (match_operand 0 \"pmode_register_operand\")\n+       (match_operand 0 \"const_csr_operand\")))\n+\n+(define_predicate \"reg_or_mem_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_operand 0 \"memory_operand\")))\n+\n+(define_predicate \"vector_move_operand\"\n+  (ior (match_operand 0 \"nonimmediate_operand\")\n+       (match_code \"const_vector\")))\n+\n+(define_predicate \"vector_mask_operand\"\n+  (ior (match_operand 0 \"register_operand\")\n+       (match_test \"op == CONSTM1_RTX (GET_MODE (op))\")))\n+\n+(define_predicate \"vector_merge_operand\"\n+  (ior (match_operand 0 \"memory_operand\")\n+       (ior (match_operand 0 \"register_operand\")\n+\t    (match_test \"GET_CODE (op) == UNSPEC\n+\t\t\t && (XINT (op, 1) == UNSPEC_VUNDEF)\"))))"}, {"sha": "386c0027ff487d0b274eb70fe905db42f81f83fb", "filename": "gcc/config/riscv/riscv-protos.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-protos.h?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -76,6 +76,7 @@ extern rtx riscv_gen_gpr_save_insn (struct riscv_frame_info *);\n extern bool riscv_gpr_save_operation_p (rtx);\n extern void riscv_reinit (void);\n extern bool riscv_v_ext_enabled_vector_mode_p (machine_mode);\n+extern poly_uint64 riscv_regmode_natural_size (machine_mode);\n \n /* Routines implemented in riscv-c.cc.  */\n void riscv_cpu_cpp_builtins (cpp_reader *);\n@@ -126,6 +127,19 @@ extern bool verify_type_context (location_t, type_context_kind, const_tree, bool\n extern void handle_pragma_vector (void);\n extern tree builtin_decl (unsigned, bool);\n extern rtx expand_builtin (unsigned int, tree, rtx);\n+extern bool const_vec_all_same_in_range_p (rtx, HOST_WIDE_INT, HOST_WIDE_INT);\n+extern bool legitimize_move (rtx, rtx, machine_mode);\n+enum tail_policy\n+{\n+  TAIL_UNDISTURBED = 0,\n+  TAIL_AGNOSTIC = 1,\n+};\n+\n+enum mask_policy\n+{\n+  MASK_UNDISTURBED = 0,\n+  MASK_AGNOSTIC = 1,\n+};\n }\n \n /* We classify builtin types into two classes:"}, {"sha": "6615a5c7ffe977d1e4001bac148fc1f284735635", "filename": "gcc/config/riscv/riscv-v.cc", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-v.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-v.cc?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,180 @@\n+/* Subroutines used for code generation for RISC-V 'V' Extension for GNU\n+   compiler. Copyright (C) 2022-2022 Free Software Foundation, Inc. Contributed\n+   by Juzhe Zhong (juzhe.zhong@rivai.ai), RiVAI Technologies Ltd.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3, or (at your option)\n+   any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but\n+   WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+   General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#define IN_TARGET_CODE 1\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"backend.h\"\n+#include \"rtl.h\"\n+#include \"insn-config.h\"\n+#include \"insn-attr.h\"\n+#include \"recog.h\"\n+#include \"alias.h\"\n+#include \"tree.h\"\n+#include \"stringpool.h\"\n+#include \"attribs.h\"\n+#include \"explow.h\"\n+#include \"memmodel.h\"\n+#include \"emit-rtl.h\"\n+#include \"tm_p.h\"\n+#include \"target.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+\n+using namespace riscv_vector;\n+\n+namespace riscv_vector {\n+\n+template <int MAX_OPERANDS> class insn_expander\n+{\n+public:\n+  insn_expander () : m_opno (0) {}\n+  void add_output_operand (rtx x, machine_mode mode)\n+  {\n+    create_output_operand (&m_ops[m_opno++], x, mode);\n+    gcc_assert (m_opno <= MAX_OPERANDS);\n+  }\n+  void add_input_operand (rtx x, machine_mode mode)\n+  {\n+    create_input_operand (&m_ops[m_opno++], x, mode);\n+    gcc_assert (m_opno <= MAX_OPERANDS);\n+  }\n+  void add_all_one_mask_operand (machine_mode mode)\n+  {\n+    add_input_operand (CONSTM1_RTX (mode), mode);\n+  }\n+  void add_vundef_operand (machine_mode mode)\n+  {\n+    add_input_operand (gen_rtx_UNSPEC (mode, gen_rtvec (1, const0_rtx),\n+\t\t\t\t       UNSPEC_VUNDEF),\n+\t\t       mode);\n+  }\n+  void add_policy_operand (enum tail_policy vta, enum mask_policy vma)\n+  {\n+    rtx tail_policy_rtx = vta == TAIL_UNDISTURBED ? const0_rtx : const1_rtx;\n+    rtx mask_policy_rtx = vma == MASK_UNDISTURBED ? const0_rtx : const1_rtx;\n+    add_input_operand (tail_policy_rtx, Pmode);\n+    add_input_operand (mask_policy_rtx, Pmode);\n+  }\n+\n+  void expand (enum insn_code icode, bool temporary_volatile_p = false)\n+  {\n+    if (temporary_volatile_p)\n+      {\n+\ttemporary_volatile_ok v (true);\n+\texpand_insn (icode, m_opno, m_ops);\n+      }\n+    else\n+      expand_insn (icode, m_opno, m_ops);\n+  }\n+\n+private:\n+  int m_opno;\n+  expand_operand m_ops[MAX_OPERANDS];\n+};\n+\n+/* Return true if X is a const_vector with all duplicate elements, which is in\n+   the range between MINVAL and MAXVAL.  */\n+bool\n+const_vec_all_same_in_range_p (rtx x, HOST_WIDE_INT minval,\n+\t\t\t       HOST_WIDE_INT maxval)\n+{\n+  rtx elt;\n+  return (const_vec_duplicate_p (x, &elt) && CONST_INT_P (elt)\n+\t  && IN_RANGE (INTVAL (elt), minval, maxval));\n+}\n+\n+/* Emit an RVV unmask && vl mov from SRC to DEST.  */\n+static void\n+emit_pred_move (rtx dest, rtx src, rtx vl, machine_mode mask_mode)\n+{\n+  insn_expander<7> e;\n+\n+  machine_mode mode = GET_MODE (dest);\n+  if (register_operand (src, mode) && register_operand (dest, mode))\n+    {\n+      emit_move_insn (dest, src);\n+      return;\n+    }\n+\n+  e.add_output_operand (dest, mode);\n+  e.add_all_one_mask_operand (mask_mode);\n+  /* For load operation, we create undef operand.\n+     For store operation, we make it depend on the dest memory to\n+     avoid potential bugs.  */\n+  if (MEM_P (src))\n+    e.add_vundef_operand (mode);\n+  else\n+    e.add_input_operand (dest, mode);\n+\n+  e.add_input_operand (src, mode);\n+  e.add_input_operand (vl, Pmode);\n+\n+  e.add_policy_operand (TAIL_AGNOSTIC, MASK_AGNOSTIC);\n+\n+  enum insn_code icode;\n+  icode = code_for_pred_mov (mode);\n+  e.expand (icode, true);\n+}\n+\n+/* Expand a pre-RA RVV data move from SRC to DEST.\n+   It expands move for RVV fractional vector modes.  */\n+bool\n+legitimize_move (rtx dest, rtx src, machine_mode mask_mode)\n+{\n+  machine_mode mode = GET_MODE (dest);\n+  /* For whole registers load/store or register-register move,\n+     we don't need to specially handle them, just let them go\n+     through \"*mov<mode>\" and then use the codegen directly.  */\n+  if ((known_ge (GET_MODE_SIZE (mode), BYTES_PER_RISCV_VECTOR)\n+       && (GET_MODE_CLASS (mode) != MODE_VECTOR_BOOL))\n+      || (register_operand (src, mode) && register_operand (dest, mode)))\n+    {\n+      /* Need to force register if mem <- !reg.  */\n+      if (MEM_P (dest) && !REG_P (src))\n+\tsrc = force_reg (mode, src);\n+      return false;\n+    }\n+\n+  rtx vlmax = gen_reg_rtx (Pmode);\n+  unsigned int sew = GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL\n+\t\t       ? 8\n+\t\t       : GET_MODE_BITSIZE (GET_MODE_INNER (mode));\n+  emit_insn (gen_vsetvl_no_side_effects (\n+    Pmode, vlmax, gen_rtx_REG (Pmode, 0), gen_int_mode (sew, Pmode),\n+    gen_int_mode ((unsigned int) mode, Pmode), const1_rtx, const1_rtx));\n+\n+  if (!register_operand (src, mode) && !register_operand (dest, mode))\n+    {\n+      rtx tmp = gen_reg_rtx (mode);\n+      if (MEM_P (src))\n+\temit_pred_move (tmp, src, vlmax, mask_mode);\n+      else\n+\temit_move_insn (tmp, src);\n+      src = tmp;\n+    }\n+  emit_pred_move (dest, src, vlmax, mask_mode);\n+  return true;\n+}\n+\n+} // namespace riscv_vector"}, {"sha": "713a7566e29aba23d86d39dcc7493d4903ddbe6d", "filename": "gcc/config/riscv/riscv-vector-builtins-bases.cc", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv-vector-builtins-bases.cc?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -72,18 +72,8 @@ class vsetvl : public function_base\n     e.add_input_operand (Pmode,\n \t\t\t gen_int_mode (GET_MODE_BITSIZE (inner_mode), Pmode));\n \n-    /* LMUL. Define the bitmap rule as follows:\n-       |      4       | 3 2 1 0 |\n-       | fractional_p | factor  |\n-    */\n-    bool fractional_p = known_lt (GET_MODE_SIZE (mode), BYTES_PER_RISCV_VECTOR);\n-    unsigned int factor\n-      = fractional_p ? exact_div (BYTES_PER_RISCV_VECTOR, GET_MODE_SIZE (mode))\n-\t\t\t .to_constant ()\n-\t\t     : exact_div (GET_MODE_SIZE (mode), BYTES_PER_RISCV_VECTOR)\n-\t\t\t .to_constant ();\n-    e.add_input_operand (Pmode,\n-\t\t\t gen_int_mode ((fractional_p << 4) | factor, Pmode));\n+    /* LMUL.  */\n+    e.add_input_operand (Pmode, gen_int_mode ((unsigned int) mode, Pmode));\n \n     /* TA.  */\n     e.add_input_operand (Pmode, gen_int_mode (1, Pmode));"}, {"sha": "23d8e1f09828ee37d3254f81569c9b13c9d4adc1", "filename": "gcc/config/riscv/riscv.cc", "status": "modified", "additions": 59, "deletions": 8, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.cc?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -4145,22 +4145,58 @@ riscv_print_operand (FILE *file, rtx op, int letter)\n   switch (letter)\n     {\n       case 'm': {\n-\tif (code == CONST_INT)\n+\tif (riscv_v_ext_vector_mode_p (mode))\n \t  {\n-\t    /* LMUL. Define the bitmap rule as follows:\n-\t       |      4       | 3 2 1 0 |\n-\t       | fractional_p | factor  |\n-\t    */\n-\t    bool fractional_p = (UINTVAL (op) >> 4) & 0x1;\n-\t    unsigned int factor = UINTVAL (op) & 0xf;\n+\t    /* Calculate lmul according to mode and print the value.  */\n+\t    poly_int64 size = GET_MODE_SIZE (mode);\n+\t    unsigned int lmul;\n+\t    if (known_lt (size, BYTES_PER_RISCV_VECTOR))\n+\t      lmul = 1;\n+\t    else\n+\t      lmul = exact_div (size, BYTES_PER_RISCV_VECTOR).to_constant ();\n+\t    asm_fprintf (file, \"%d\", lmul);\n+\t  }\n+\telse if (code == CONST_INT)\n+\t  {\n+\t    /* The value in the operand is the unsigned int value\n+\t       converted from (enum machine_mode).\n+\t       This RTX is generated as follows:\n+\n+\t       machine_mode mode = XXXmode;\n+\t       operand = gen_int_mode ((unsigned int)mode, Pmode);\n+\n+\t       So we convert it back into machine_mode and then calculate\n+\t       the LMUL according to GET_MODE_SIZE.  */\n+\n+\t    machine_mode rvv_mode = (machine_mode) UINTVAL (op);\n+\t    /* For rvv mask modes, we can not calculate LMUL simpily according\n+\t       to BYTES_PER_RISCV_VECTOR. When rvv_mode = VNx4BImode.\n+\t       Set SEW = 8, LMUL = 1 by default if TARGET_MIN_VLEN == 32.\n+\t       Set SEW = 8, LMUL = 1 / 2 by default if TARGET_MIN_VLEN > 32.  */\n+\t    bool bool_p = GET_MODE_CLASS (rvv_mode) == MODE_VECTOR_BOOL;\n+\t    poly_int64 m1_size = BYTES_PER_RISCV_VECTOR;\n+\t    poly_int64 rvv_size\n+\t      = bool_p ? GET_MODE_NUNITS (rvv_mode) : GET_MODE_SIZE (rvv_mode);\n+\t    bool fractional_p = known_lt (rvv_size, BYTES_PER_RISCV_VECTOR);\n+\t    unsigned int factor\n+\t      = fractional_p ? exact_div (m1_size, rvv_size).to_constant ()\n+\t\t\t     : exact_div (rvv_size, m1_size).to_constant ();\n \t    asm_fprintf (file, \"%s%d\", fractional_p ? \"mf\" : \"m\", factor);\n \t  }\n \telse\n \t  output_operand_lossage (\"invalid vector constant\");\n \tbreak;\n       }\n       case 'p': {\n-\tif (code == CONST_INT)\n+\tif (GET_MODE_CLASS (mode) == MODE_VECTOR_BOOL)\n+\t  {\n+\t    /* Print for RVV mask operand.\n+\t       If op is reg, print \",v0.t\".\n+\t       Otherwise, don't print anything.  */\n+\t    if (code == REG)\n+\t      fprintf (file, \",%s.t\", reg_names[REGNO (op)]);\n+\t  }\n+\telse if (code == CONST_INT)\n \t  {\n \t    /* Tail && Mask policy.  */\n \t    bool agnostic_p = UINTVAL (op) & 0x1;\n@@ -6416,6 +6452,21 @@ riscv_vector_alignment (const_tree type)\n   return wi::umin (min_size, 128).to_uhwi ();\n }\n \n+/* Implement REGMODE_NATURAL_SIZE.  */\n+\n+poly_uint64\n+riscv_regmode_natural_size (machine_mode mode)\n+{\n+  /* The natural size for RVV data modes is one RVV data vector,\n+     and similarly for predicates.  We can't independently modify\n+     anything smaller than that.  */\n+  /* ??? For now, only do this for variable-width RVV registers.\n+     Doing it for constant-sized registers breaks lower-subreg.c.  */\n+  if (!riscv_vector_chunks.is_constant () && riscv_v_ext_vector_mode_p (mode))\n+    return BYTES_PER_RISCV_VECTOR;\n+  return UNITS_PER_WORD;\n+}\n+\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\""}, {"sha": "9dbc84635912f243c904b9bba19f83d6fde16efd", "filename": "gcc/config/riscv/riscv.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.h?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -1080,4 +1080,6 @@ extern void riscv_remove_unneeded_save_restore_calls (void);\n \n #define REGISTER_TARGET_PRAGMAS() riscv_register_pragmas ()\n \n+#define REGMODE_NATURAL_SIZE(MODE) riscv_regmode_natural_size (MODE)\n+\n #endif /* ! GCC_RISCV_H */"}, {"sha": "ae907a751268f55b4a0e7c1b844d29bfcf2cc432", "filename": "gcc/config/riscv/riscv.md", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Friscv.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Friscv.md?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -152,7 +152,14 @@\n   (const_string \"unknown\"))\n \n ;; Main data type used by the insn\n-(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,HF,SF,DF,TF\"\n+(define_attr \"mode\" \"unknown,none,QI,HI,SI,DI,TI,HF,SF,DF,TF,\n+  VNx1BI,VNx2BI,VNx4BI,VNx8BI,VNx16BI,VNx32BI,VNx64BI,\n+  VNx1QI,VNx2QI,VNx4QI,VNx8QI,VNx16QI,VNx32QI,VNx64QI,\n+  VNx1HI,VNx2HI,VNx4HI,VNx8HI,VNx16HI,VNx32HI,\n+  VNx1SI,VNx2SI,VNx4SI,VNx8SI,VNx16SI,\n+  VNx1DI,VNx2DI,VNx4DI,VNx8DI,\n+  VNx1SF,VNx2SF,VNx4SF,VNx8SF,VNx16SF,\n+  VNx1DF,VNx2DF,VNx4DF,VNx8DF\"\n   (const_string \"unknown\"))\n \n ;; True if the main data type is twice the size of a word."}, {"sha": "7997db3d898b6e0de56de6bfce13b4d5588514ec", "filename": "gcc/config/riscv/t-riscv", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Ft-riscv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Ft-riscv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Ft-riscv?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -63,6 +63,10 @@ riscv-selftests.o: $(srcdir)/config/riscv/riscv-selftests.cc\n \t$(COMPILE) $<\n \t$(POSTCOMPILE)\n \n+riscv-v.o: $(srcdir)/config/riscv/riscv-v.cc\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n PASSES_EXTRA += $(srcdir)/config/riscv/riscv-passes.def\n \n $(common_out_file): $(srcdir)/config/riscv/riscv-cores.def \\"}, {"sha": "627e2f78f65d6cc47d08d978b29234c17bbec569", "filename": "gcc/config/riscv/vector-iterators.md", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fvector-iterators.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector-iterators.md?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,58 @@\n+;; Iterators for RISC-V 'V' Extension for GNU compiler.\n+;; Copyright (C) 2022-2022 Free Software Foundation, Inc.\n+;; Contributed by Juzhe Zhong (juzhe.zhong@rivai.ai), RiVAI Technologies Ltd.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 3, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING3.  If not see\n+;; <http://www.gnu.org/licenses/>.\n+\n+(define_mode_iterator V [\n+  VNx1QI VNx2QI VNx4QI VNx8QI VNx16QI VNx32QI (VNx64QI \"TARGET_MIN_VLEN > 32\")\n+  VNx1HI VNx2HI VNx4HI VNx8HI VNx16HI (VNx32HI \"TARGET_MIN_VLEN > 32\")\n+  VNx1SI VNx2SI VNx4SI VNx8SI (VNx16SI \"TARGET_MIN_VLEN > 32\")\n+  VNx1DI VNx2DI VNx4DI (VNx8DI \"TARGET_MIN_VLEN > 32\")\n+  (VNx1SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx2SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx4SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx8SF \"TARGET_VECTOR_ELEN_FP_32\")\n+  (VNx16SF \"TARGET_VECTOR_ELEN_FP_32 && TARGET_MIN_VLEN > 32\")\n+  (VNx1DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx2DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx4DF \"TARGET_VECTOR_ELEN_FP_64\")\n+  (VNx8DF \"TARGET_VECTOR_ELEN_FP_64\")\n+])\n+\n+(define_mode_iterator VB [\n+  VNx1BI VNx2BI VNx4BI VNx8BI VNx16BI VNx32BI\n+  (VNx64BI \"TARGET_MIN_VLEN > 32\")\n+])\n+\n+(define_mode_attr VM [\n+  (VNx1QI \"VNx1BI\") (VNx2QI \"VNx2BI\") (VNx4QI \"VNx4BI\") (VNx8QI \"VNx8BI\") (VNx16QI \"VNx16BI\") (VNx32QI \"VNx32BI\") (VNx64QI \"VNx64BI\")\n+  (VNx1HI \"VNx1BI\") (VNx2HI \"VNx2BI\") (VNx4HI \"VNx4BI\") (VNx8HI \"VNx8BI\") (VNx16HI \"VNx16BI\") (VNx32HI \"VNx32BI\")\n+  (VNx1SI \"VNx1BI\") (VNx2SI \"VNx2BI\") (VNx4SI \"VNx4BI\") (VNx8SI \"VNx8BI\") (VNx16SI \"VNx16BI\")\n+  (VNx1DI \"VNx1BI\") (VNx2DI \"VNx2BI\") (VNx4DI \"VNx4BI\") (VNx8DI \"VNx8BI\")\n+  (VNx1SF \"VNx1BI\") (VNx2SF \"VNx2BI\") (VNx4SF \"VNx4BI\") (VNx8SF \"VNx8BI\") (VNx16SF \"VNx16BI\")\n+  (VNx1DF \"VNx1BI\") (VNx2DF \"VNx2BI\") (VNx4DF \"VNx4BI\") (VNx8DF \"VNx8BI\")\n+])\n+\n+(define_mode_attr sew [\n+  (VNx1QI \"8\") (VNx2QI \"8\") (VNx4QI \"8\") (VNx8QI \"8\") (VNx16QI \"8\") (VNx32QI \"8\") (VNx64QI \"8\")\n+  (VNx1HI \"16\") (VNx2HI \"16\") (VNx4HI \"16\") (VNx8HI \"16\") (VNx16HI \"16\") (VNx32HI \"16\")\n+  (VNx1SI \"32\") (VNx2SI \"32\") (VNx4SI \"32\") (VNx8SI \"32\") (VNx16SI \"32\")\n+  (VNx1DI \"64\") (VNx2DI \"64\") (VNx4DI \"64\") (VNx8DI \"64\")\n+  (VNx1SF \"32\") (VNx2SF \"32\") (VNx4SF \"32\") (VNx8SF \"32\") (VNx16SF \"32\")\n+  (VNx1DF \"64\") (VNx2DF \"64\") (VNx4DF \"64\") (VNx8DF \"64\")\n+])"}, {"sha": "451ed23ef5ae6b9cba3bb14e83e65c2f95cd051f", "filename": "gcc/config/riscv/vector.md", "status": "modified", "additions": 273, "deletions": 6, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Fconfig%2Friscv%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Friscv%2Fvector.md?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -26,10 +26,71 @@\n ;; - Auto-vectorization (TBD)\n ;; - Combine optimization (TBD)\n \n+(include \"vector-iterators.md\")\n+\n (define_c_enum \"unspec\" [\n   UNSPEC_VSETVL\n+  UNSPEC_VUNDEF\n+  UNSPEC_VPREDICATE\n ])\n \n+;; -----------------------------------------------------------------\n+;; ---- Miscellaneous Operations\n+;; -----------------------------------------------------------------\n+\n+(define_insn \"vundefined<mode>\"\n+  [(set (match_operand:V 0 \"register_operand\" \"=vr\")\n+\t(unspec:V [(const_int 0)] UNSPEC_VUNDEF))]\n+  \"TARGET_VECTOR\"\n+  \"\")\n+\n+;; -----------------------------------------------------------------\n+;; ---- Moves Operations\n+;; -----------------------------------------------------------------\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:V 0 \"reg_or_mem_operand\")\n+\t(match_operand:V 1 \"vector_move_operand\"))]\n+  \"TARGET_VECTOR\"\n+{\n+  if (riscv_vector::legitimize_move (operands[0], operands[1], <VM>mode))\n+    DONE;\n+})\n+\n+;; This pattern is used for code-gen for whole register load/stores.\n+;; Also applicable for all register moves.\n+;; Fractional vector modes load/store are not allowed to match this pattern.\n+;; Mask modes load/store are not allowed to match this pattern.\n+(define_insn \"*mov<mode>\"\n+  [(set (match_operand:V 0 \"reg_or_mem_operand\" \"=vr,m,vr\")\n+\t(match_operand:V 1 \"reg_or_mem_operand\" \"m,vr,vr\"))]\n+  \"TARGET_VECTOR && ((register_operand (operands[0], <MODE>mode)\n+\t\t      && register_operand (operands[1], <MODE>mode))\n+   || known_ge (GET_MODE_SIZE (<MODE>mode), BYTES_PER_RISCV_VECTOR))\"\n+  \"@\n+   vl%m1re<sew>.v\\t%0,%1\n+   vs%m1r.v\\t%1,%0\n+   vmv%m1r.v\\t%0,%1\"\n+  [(set_attr \"type\" \"vldr,vstr,vmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:VB 0 \"reg_or_mem_operand\")\n+\t(match_operand:VB 1 \"vector_move_operand\"))]\n+  \"TARGET_VECTOR\"\n+{\n+  if (riscv_vector::legitimize_move (operands[0], operands[1], <MODE>mode))\n+     DONE;\n+})\n+\n+(define_insn \"*mov<mode>\"\n+  [(set (match_operand:VB 0 \"register_operand\" \"=vr\")\n+\t(match_operand:VB 1 \"register_operand\" \"vr\"))]\n+  \"TARGET_VECTOR\"\n+  \"vmv1r.v\\t%0,%1\"\n+  [(set_attr \"type\" \"vmov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n ;; -----------------------------------------------------------------\n ;; ---- 6. Configuration-Setting Instructions\n ;; -----------------------------------------------------------------\n@@ -50,13 +111,98 @@\n ;; operands[3]: LMUL\n ;; operands[4]: Tail policy 0 or 1 (undisturbed/agnostic)\n ;; operands[5]: Mask policy 0 or 1 (undisturbed/agnostic)\n+\n+;; We define 2 types of \"vsetvl*\" instruction patterns:\n+\n+;; -  \"@vsetvl<mode>\" is a parallel format which has side effects.\n+\n+;; -  \"@vsetvl<mode>_no_side_effects\" has no side effects.\n+\n+;; -  \"@vsetvl<mode>\" is used by \"vsetvl\" intrinsics and \"insert-vsetvl\" PASS.\n+\n+;; -  \"@vsetvl<mode>_no_side_effects\" is used by GCC standard patterns.\n+\n+;; -  \"@vsetvl<mode>\" includes VL/VTYPE global registers status (define set)\n+;; and each RVV instruction includes VL/VTYPE global registers status (use)\n+;; so that we can guarantee each RVV instruction can execute with correct\n+;; VL/VTYPE global registers status after \"insert-vsetvl\" PASS.\n+\n+;; -  \"@vsetvl<mode>_no_side_effects\" has no side effects and excludes VL/VTYPE\n+;; global registers status (define set). It's only used by GCC standard pattern\n+;; expansion. For example: \"mov<mode>\" pattern for fractional vector modes which\n+;; need to set VL/VTYPE. Then we could manually call this pattern to gain benefits\n+;; from the optimization of each GCC internal PASS.\n+\n+;; 1. void foo (float *in, float *out)\n+;;    {\n+;;      vfloat32mf2_t v = *(vfloat32mf2_t*)in;\n+;;      *(vfloat32mf2_t*)out = v;\n+;;    }\n+;; We could eliminate the second \"vsetvl\" by calling \"@vsetvl<mode>_no_side_effects\".\n+;;\n+;; \"@vsetvl<mode>\":               ;; \"@vsetvl<mode>_no_side_effects\":\n+;; vsetvli a4,zero,e32,mf2,ta,ma  ;; vsetvli a4,zero,e32,mf2,ta,ma\n+;; vle32.v v24,(a0)               ;; vle32.v v24,(a0)\n+;; vsetvli a4,zero,e32,mf2,ta,ma  ;; --\n+;; vse32.v v24,(a1)               ;; vse32.v v24,(a1)\n+;; ret                            ;; ret\n+\n+;; 2. void foo (int8_t *in, int8_t *out, int M)\n+;;    {\n+;;      for (int i = 0; i < M; i++){\n+;;        vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+;;        *(vint8mf2_t*)(out + i) = v;\n+;;      }\n+;;    }\n+;;\n+;; Hoist \"vsetvl\" instruction in LICM:\n+;; \"@vsetvl<mode>\":                  ;; \"@vsetvl<mode>_no_side_effects\":\n+;; -                                 ;;   vsetvli a4,zero,e32,mf2,ta,ma\n+;; LOOP:                             ;; LOOP:\n+;;   vsetvli a4,zero,e32,mf2,ta,ma   ;; -\n+;;   vle32.v v24,(a0)                ;;   vle32.v v24,(a0)\n+;;   vsetvli a4,zero,e32,mf2,ta,ma   ;; -\n+;;   vse32.v v24,(a1)                ;;   vse32.v v24,(a1)\n+\n+;; However, it may produce wrong codegen if we exclude VL/VTYPE in \"vsevl<mode>\".\n+;; 3. void foo (int8_t *in, int8_t *out, int32_t *in2, int32_t *out2, int M)\n+;;    {\n+;;      for (int i = 0; i < M; i++){\n+;;        vint8mf2_t v = *(vint8mf2_t*)(in + i);\n+;;        vint32mf2_t v2 = *(vint32mf2_t*)(in + i + i);\n+;;        *(vint8mf2_t*)(out + i) = v;\n+;;        *(vint32mf2_t*)(out + i + i) = v2;\n+;;      }\n+;;    }\n+;;\n+;; vsetvli a6,zero,e8,mf2,ta,ma\n+;; vsetvli a2,zero,e32,mf2,ta,ma\n+;; LOOP:\n+;;   vle8.v  v25,(a0)\n+;;   vle32.v v24,(a5)\n+;;   addi    a0,a0,1\n+;;   vse8.v  v25,(a1)\n+;;   vse32.v v24,(a3)\n+;;\n+;; Both vle8.v and vle32.v are using the wrong VL/VTYPE status.\n+;; We leave it to \"insert-vsetvl\" PASS to correct this situation.\n+\n+;; The \"insert-vsetvl\" PASS mechanism:\n+;; 1. Before \"insert-vsetvl\" PASS, only RVV instructions are generated\n+;;    by GCC standard pattern expansion has the corresponding \"vsetvl\".\n+;;    We exploit each GCC internal optimization pass to optimize the \"vsetvl\".\n+;; 2. Correct the VL/VTYPE status for each GCC standard pattern RVV instructions.\n+;;    Insert vsetvl for each RVV instructions that has no VL/VTYPE status if necessary.\n+;;    For example: RVV intrinsics.\n+;; 3. Optimize \"vsetvl\" instructions.\n+\n (define_insn \"@vsetvl<mode>\"\n-  [(set (match_operand:P 0 \"register_operand\" \"=r,r\")\n-\t(unspec:P [(match_operand:P 1 \"csr_operand\" \"r,K\")\n-\t\t   (match_operand 2 \"const_int_operand\" \"i,i\")\n-\t\t   (match_operand 3 \"const_int_operand\" \"i,i\")\n-\t\t   (match_operand 4 \"const_int_operand\" \"i,i\")\n-\t\t   (match_operand 5 \"const_int_operand\" \"i,i\")] UNSPEC_VSETVL))\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"csr_operand\" \"rK\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 3 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 4 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 5 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))\n    (set (reg:SI VL_REGNUM)\n \t(unspec:SI [(match_dup 1)\n \t\t    (match_dup 2)\n@@ -70,3 +216,124 @@\n   \"vset%i1vli\\t%0,%1,e%2,%m3,t%p4,m%p5\"\n   [(set_attr \"type\" \"vsetvl\")\n    (set_attr \"mode\" \"<MODE>\")])\n+\n+;; We keep it as no side effects before reload_completed.\n+;; In this case, we can gain benefits from different GCC\n+;; internal PASS such as cprop, fwprop, combine,...etc.\n+\n+;; Then recover it for \"insert-vsetvl\" and \"sched2\" PASS\n+;; in order to get correct codegen.\n+(define_insn_and_split \"@vsetvl<mode>_no_side_effects\"\n+  [(set (match_operand:P 0 \"register_operand\" \"=r\")\n+\t(unspec:P [(match_operand:P 1 \"csr_operand\" \"rK\")\n+\t\t   (match_operand 2 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 3 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 4 \"const_int_operand\" \"i\")\n+\t\t   (match_operand 5 \"const_int_operand\" \"i\")] UNSPEC_VSETVL))]\n+  \"TARGET_VECTOR\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(parallel\n+    [(set (match_dup 0)\n+\t  (unspec:P [(match_dup 1) (match_dup 2) (match_dup 3)\n+\t\t     (match_dup 4) (match_dup 5)] UNSPEC_VSETVL))\n+     (set (reg:SI VL_REGNUM)\n+\t  (unspec:SI [(match_dup 1) (match_dup 2) (match_dup 3)] UNSPEC_VSETVL))\n+     (set (reg:SI VTYPE_REGNUM)\n+\t  (unspec:SI [(match_dup 2) (match_dup 3) (match_dup 4)\n+\t\t      (match_dup 5)] UNSPEC_VSETVL))])]\n+  \"\"\n+  [(set_attr \"type\" \"vsetvl\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; RVV machine description matching format\n+;; (define_insn \"\"\n+;;   [(set (match_operand:MODE 0)\n+;; \t(if_then_else:MODE\n+;; \t  (unspec:<MODE:VM>\n+;; \t    [(match_operand:<VM> 1 \"vector_mask_operand\")\n+;; \t     (match_operand N + 4 \"vector_length_operand\")\n+;; \t     (match_operand N + 5 \"const_int_operand\")\n+;; \t     (match_operand N + 6 \"const_int_operand\")\n+;; \t     (reg:SI VL_REGNUM)\n+;; \t     (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+;; \t  (instruction operation:MODE\n+;; \t     (match_operand 3\n+;; \t     (match_operand 4\n+;; \t     (match_operand 5\n+;;           ................\n+;; \t     (match_operand N + 3)\n+;; \t  (match_operand:MODE 2 \"vector_reg_or_const0_operand\")))]\n+;;\n+;; (unspec:[........] UNSPEC_VPREDICATE) is a predicate wrapper.\n+;; Include mask predicate && length predicate && vector policy.\n+\n+;; -------------------------------------------------------------------------------\n+;; ---- Predicated Mov\n+;; -------------------------------------------------------------------------------\n+;; Includes:\n+;; - 7.4. Vector Unit-Stride Instructions\n+;; - 11.16 Vector Integer Move Instructions\n+;; - 13.16 Vector Floating-Point Move Instruction\n+;; - 15.1 Vector Mask-Register Logical Instructions\n+;; -------------------------------------------------------------------------------\n+\n+;; vle.v/vse.v/vmv.v.v/vmv.v.x/vmv.v.i/vfmv.v.f.\n+;; For vle.v/vmv.v.v/vmv.v.x/vmv.v.i/vfmv.v.f, we may need merge and mask operand.\n+;; For vse.v, we don't need merge operand, so it should always match \"vu\".\n+;; constraint alternative 0 ~ 1 match vle.v.\n+;; constraint alternative 2 match vse.v.\n+;; constraint alternative 3 match vmv.v.v.\n+;; constraint alternative 4 match vmv.v.i.\n+;; For vmv.v.i, we allow 2 following cases:\n+;;    1. (const_vector:VNx1QI repeat [\n+;;                (const_int:QI N)]), -15 <= N < 16.\n+;;    2. (const_vector:VNx1SF repeat [\n+;;                (const_double:SF 0.0 [0x0.0p+0])]).\n+(define_insn \"@pred_mov<mode>\"\n+  [(set (match_operand:V 0 \"nonimmediate_operand\"        \"=vd,  vr,     m,    vr,    vr\")\n+        (if_then_else:V\n+          (unspec:<VM>\n+            [(match_operand:<VM> 1 \"vector_mask_operand\" \" vm, Wc1, vmWc1, vmWc1,   Wc1\")\n+             (match_operand 4 \"vector_length_operand\"    \" rK,  rK,    rK,    rK,    rK\")\n+             (match_operand 5 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n+             (match_operand 6 \"const_int_operand\"        \"  i,   i,     i,     i,     i\")\n+             (reg:SI VL_REGNUM)\n+             (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+          (match_operand:V 3 \"vector_move_operand\"       \"  m,   m,    vr,    vr, viWc0\")\n+          (match_operand:V 2 \"vector_merge_operand\"      \"  0,  vu,     0,   vu0,   vu0\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vle<sew>.v\\t%0,%3%p1\n+   vle<sew>.v\\t%0,%3%p1\n+   vse<sew>.v\\t%3,%0%p1\n+   vmv.v.v\\t%0,%3\n+   vmv.v.i\\t%0,v%3\"\n+  [(set_attr \"type\" \"vlde,vlde,vste,vimov,vimov\")\n+   (set_attr \"mode\" \"<MODE>\")])\n+\n+;; vlm.v/vsm.v/vmclr.m/vmset.m.\n+;; constraint alternative 0 match vlm.v.\n+;; constraint alternative 2 match vsm.v.\n+;; constraint alternative 3 match vmclr.m.\n+;; constraint alternative 4 match vmset.m.\n+(define_insn \"@pred_mov<mode>\"\n+  [(set (match_operand:VB 0 \"nonimmediate_operand\"       \"=vr,   m,  vr,  vr\")\n+        (if_then_else:VB\n+          (unspec:VB\n+            [(match_operand:VB 1 \"vector_mask_operand\"   \"Wc1, Wc1, Wc1, Wc1\")\n+             (match_operand 4 \"vector_length_operand\"    \" rK,  rK,  rK,  rK\")\n+             (match_operand 5 \"const_int_operand\"        \"  i,   i,   i,   i\")\n+             (match_operand 6 \"const_int_operand\"        \"  i,   i,   i,   i\")\n+             (reg:SI VL_REGNUM)\n+             (reg:SI VTYPE_REGNUM)] UNSPEC_VPREDICATE)\n+          (match_operand:VB 3 \"vector_move_operand\"      \"  m,  vr, Wc0, Wc1\")\n+          (match_operand:VB 2 \"vector_merge_operand\"     \" vu,   0,  vu,  vu\")))]\n+  \"TARGET_VECTOR\"\n+  \"@\n+   vlm.v\\t%0,%3\n+   vsm.v\\t%3,%0\n+   vmclr.m\\t%0\n+   vmset.m\\t%0\"\n+  [(set_attr \"type\" \"vldm,vstm,vmalu,vmalu\")\n+   (set_attr \"mode\" \"<MODE>\")])"}, {"sha": "6a235e308f9042c9ac49db9f184040355c292094", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-1.c", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-1.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,179 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov1:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov1 (int8_t *in, int8_t *out)\n+{\n+  vint8mf8_t v = *(vint8mf8_t*)in;\n+  *(vint8mf8_t*)out = v;\n+}\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov2 (int8_t *in, int8_t *out)\n+{\n+  vint8mf4_t v = *(vint8mf4_t*)in;\n+  *(vint8mf4_t*)out = v;\n+}\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov3 (int8_t *in, int8_t *out)\n+{\n+  vint8mf2_t v = *(vint8mf2_t*)in;\n+  *(vint8mf2_t*)out = v;\n+}\n+\n+/*\n+** mov4:\n+**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (int8_t *in, int8_t *out)\n+{\n+  vint8m1_t v = *(vint8m1_t*)in;\n+  *(vint8m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (int8_t *in, int8_t *out)\n+{\n+  vint8m2_t v = *(vint8m2_t*)in;\n+  *(vint8m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (int8_t *in, int8_t *out)\n+{\n+  vint8m4_t v = *(vint8m4_t*)in;\n+  *(vint8m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (int8_t *in, int8_t *out)\n+{\n+  vint8m8_t v = *(vint8m8_t*)in;\n+  *(vint8m8_t*)out = v;\n+}\n+\n+/*\n+** mov8:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov8 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf8_t v = *(vuint8mf8_t*)in;\n+  *(vuint8mf8_t*)out = v;\n+}\n+\n+/*\n+** mov9:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov9 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf4_t v = *(vuint8mf4_t*)in;\n+  *(vuint8mf4_t*)out = v;\n+}\n+\n+/*\n+** mov10:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov10 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8mf2_t v = *(vuint8mf2_t*)in;\n+  *(vuint8mf2_t*)out = v;\n+}\n+\n+/*\n+** mov11:\n+**\tvl1re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov11 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8m1_t v = *(vuint8m1_t*)in;\n+  *(vuint8m1_t*)out = v;\n+}\n+\n+/*\n+** mov12:\n+**\tvl2re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov12 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8m2_t v = *(vuint8m2_t*)in;\n+  *(vuint8m2_t*)out = v;\n+}\n+\n+/*\n+** mov13:\n+**\tvl4re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov13 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8m4_t v = *(vuint8m4_t*)in;\n+  *(vuint8m4_t*)out = v;\n+}\n+\n+/*\n+** mov14:\n+**\tvl8re8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov14 (uint8_t *in, uint8_t *out)\n+{\n+  vuint8m8_t v = *(vuint8m8_t*)in;\n+  *(vuint8m8_t*)out = v;\n+}"}, {"sha": "10aa8297c30f6cd97e1e057d47ea0e2743a37702", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-10.c", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-10.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,385 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h> \n+\n+/*\n+** mov1:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov1 (int8_t *in, int8_t *out) \n+{ \n+ register vint8mf8_t v1 asm(\"v1\") = *(vint8mf8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint8mf8_t v2 asm(\"v2\") = v1; \n+ *(vint8mf8_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov2 (int8_t *in, int8_t *out) \n+{ \n+ register vint8mf4_t v1 asm(\"v1\") = *(vint8mf4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint8mf4_t v2 asm(\"v2\") = v1; \n+ *(vint8mf4_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov3 (int8_t *in, int8_t *out) \n+{ \n+ register vint8mf2_t v1 asm(\"v1\") = *(vint8mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint8mf2_t v2 asm(\"v2\") = v1; \n+ *(vint8mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov4:\n+**\tvl1re8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov4 (int8_t *in, int8_t *out) \n+{ \n+ register vint8m1_t v1 asm(\"v1\") = *(vint8m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint8m1_t v2 asm(\"v2\") = v1; \n+ *(vint8m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov5:\n+**\tvl2re8\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov5 (int8_t *in, int8_t *out) \n+{ \n+ register vint8m2_t v2 asm(\"v2\") = *(vint8m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vint8m2_t v4 asm(\"v4\") = v2; \n+ *(vint8m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov6:\n+**\tvl4re8\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov6 (int8_t *in, int8_t *out) \n+{ \n+ register vint8m4_t v4 asm(\"v4\") = *(vint8m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vint8m4_t v8 asm(\"v8\") = v4; \n+ *(vint8m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov7:\n+**\tvl8re8\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov7 (int8_t *in, int8_t *out) \n+{ \n+ register vint8m8_t v8 asm(\"v8\") = *(vint8m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vint8m8_t v16 asm(\"v16\") = v8; \n+ *(vint8m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov8:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov8 (int16_t *in, int16_t *out) \n+{ \n+ register vint16mf4_t v1 asm(\"v1\") = *(vint16mf4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint16mf4_t v2 asm(\"v2\") = v1; \n+ *(vint16mf4_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov9:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov9 (int16_t *in, int16_t *out) \n+{ \n+ register vint16mf2_t v1 asm(\"v1\") = *(vint16mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint16mf2_t v2 asm(\"v2\") = v1; \n+ *(vint16mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov10:\n+**\tvl1re16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov10 (int16_t *in, int16_t *out) \n+{ \n+ register vint16m1_t v1 asm(\"v1\") = *(vint16m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint16m1_t v2 asm(\"v2\") = v1; \n+ *(vint16m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov11:\n+**\tvl2re16\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov11 (int16_t *in, int16_t *out) \n+{ \n+ register vint16m2_t v2 asm(\"v2\") = *(vint16m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vint16m2_t v4 asm(\"v4\") = v2; \n+ *(vint16m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov12:\n+**\tvl4re16\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov12 (int16_t *in, int16_t *out) \n+{ \n+ register vint16m4_t v4 asm(\"v4\") = *(vint16m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vint16m4_t v8 asm(\"v8\") = v4; \n+ *(vint16m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov13:\n+**\tvl8re16\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov13 (int32_t *in, int32_t *out) \n+{ \n+ register vint16m8_t v8 asm(\"v8\") = *(vint16m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vint16m8_t v16 asm(\"v16\") = v8; \n+ *(vint16m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov14:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov14 (int32_t *in, int32_t *out) \n+{ \n+ register vint32mf2_t v1 asm(\"v1\") = *(vint32mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint32mf2_t v2 asm(\"v2\") = v1; \n+ *(vint32mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov15:\n+**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov15 (int32_t *in, int32_t *out) \n+{ \n+ register vint32m1_t v1 asm(\"v1\") = *(vint32m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint32m1_t v2 asm(\"v2\") = v1; \n+ *(vint32m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov16:\n+**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov16 (int32_t *in, int32_t *out) \n+{ \n+ register vint32m2_t v2 asm(\"v2\") = *(vint32m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vint32m2_t v4 asm(\"v4\") = v2; \n+ *(vint32m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov17:\n+**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov17 (int32_t *in, int32_t *out) \n+{ \n+ register vint32m4_t v4 asm(\"v4\") = *(vint32m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vint32m4_t v8 asm(\"v8\") = v4; \n+ *(vint32m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov18:\n+**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov18 (int32_t *in, int32_t *out) \n+{ \n+ register vint32m8_t v8 asm(\"v8\") = *(vint32m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vint32m8_t v16 asm(\"v16\") = v8; \n+ *(vint32m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov19:\n+**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov19 (int64_t *in, int64_t *out) \n+{ \n+ register vint64m1_t v1 asm(\"v1\") = *(vint64m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint64m1_t v2 asm(\"v2\") = v1; \n+ *(vint64m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov20:\n+**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov20 (int64_t *in, int64_t *out) \n+{ \n+ register vint64m2_t v2 asm(\"v2\") = *(vint64m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vint64m2_t v4 asm(\"v4\") = v2; \n+ *(vint64m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov21:\n+**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov21 (int64_t *in, int64_t *out) \n+{ \n+ register vint64m4_t v4 asm(\"v4\") = *(vint64m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vint64m4_t v8 asm(\"v8\") = v4; \n+ *(vint64m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov22:\n+**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov22 (int64_t *in, int64_t *out) \n+{ \n+ register vint64m8_t v8 asm(\"v8\") = *(vint64m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vint64m8_t v16 asm(\"v16\") = v8; \n+ *(vint64m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}"}, {"sha": "f8da5bb6b9359ffa5034f9454f8e3f805bed69f6", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-11.c", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-11.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,385 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h> \n+\n+/*\n+** mov1:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov1 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8mf8_t v1 asm(\"v1\") = *(vuint8mf8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint8mf8_t v2 asm(\"v2\") = v1; \n+ *(vuint8mf8_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov2 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8mf4_t v1 asm(\"v1\") = *(vuint8mf4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint8mf4_t v2 asm(\"v2\") = v1; \n+ *(vuint8mf4_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov3 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8mf2_t v1 asm(\"v1\") = *(vuint8mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint8mf2_t v2 asm(\"v2\") = v1; \n+ *(vuint8mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov4:\n+**\tvl1re8\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov4 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8m1_t v1 asm(\"v1\") = *(vuint8m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint8m1_t v2 asm(\"v2\") = v1; \n+ *(vuint8m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov5:\n+**\tvl2re8\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov5 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8m2_t v2 asm(\"v2\") = *(vuint8m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vuint8m2_t v4 asm(\"v4\") = v2; \n+ *(vuint8m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov6:\n+**\tvl4re8\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov6 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8m4_t v4 asm(\"v4\") = *(vuint8m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vuint8m4_t v8 asm(\"v8\") = v4; \n+ *(vuint8m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov7:\n+**\tvl8re8\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov7 (uint8_t *in, uint8_t *out) \n+{ \n+ register vuint8m8_t v8 asm(\"v8\") = *(vuint8m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vuint8m8_t v16 asm(\"v16\") = v8; \n+ *(vuint8m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov8:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov8 (uint16_t *in, uint16_t *out) \n+{ \n+ register vuint16mf4_t v1 asm(\"v1\") = *(vuint16mf4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint16mf4_t v2 asm(\"v2\") = v1; \n+ *(vuint16mf4_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov9:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov9 (uint16_t *in, uint16_t *out) \n+{ \n+ register vuint16mf2_t v1 asm(\"v1\") = *(vuint16mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint16mf2_t v2 asm(\"v2\") = v1; \n+ *(vuint16mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov10:\n+**\tvl1re16\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov10 (uint16_t *in, uint16_t *out) \n+{ \n+ register vuint16m1_t v1 asm(\"v1\") = *(vuint16m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint16m1_t v2 asm(\"v2\") = v1; \n+ *(vuint16m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov11:\n+**\tvl2re16\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov11 (uint16_t *in, uint16_t *out) \n+{ \n+ register vuint16m2_t v2 asm(\"v2\") = *(vuint16m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vuint16m2_t v4 asm(\"v4\") = v2; \n+ *(vuint16m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov12:\n+**\tvl4re16\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov12 (uint16_t *in, uint16_t *out) \n+{ \n+ register vuint16m4_t v4 asm(\"v4\") = *(vuint16m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vuint16m4_t v8 asm(\"v8\") = v4; \n+ *(vuint16m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov13:\n+**\tvl8re16\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov13 (uint32_t *in, uint32_t *out) \n+{ \n+ register vuint16m8_t v8 asm(\"v8\") = *(vuint16m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vuint16m8_t v16 asm(\"v16\") = v8; \n+ *(vuint16m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov14:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov14 (uint32_t *in, uint32_t *out) \n+{ \n+ register vuint32mf2_t v1 asm(\"v1\") = *(vuint32mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint32mf2_t v2 asm(\"v2\") = v1; \n+ *(vuint32mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov15:\n+**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov15 (uint32_t *in, uint32_t *out) \n+{ \n+ register vuint32m1_t v1 asm(\"v1\") = *(vuint32m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint32m1_t v2 asm(\"v2\") = v1; \n+ *(vuint32m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov16:\n+**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov16 (uint32_t *in, uint32_t *out) \n+{ \n+ register vuint32m2_t v2 asm(\"v2\") = *(vuint32m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vuint32m2_t v4 asm(\"v4\") = v2; \n+ *(vuint32m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov17:\n+**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov17 (uint32_t *in, uint32_t *out)\n+{ \n+ register vuint32m4_t v4 asm(\"v4\") = *(vuint32m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vuint32m4_t v8 asm(\"v8\") = v4; \n+ *(vuint32m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov18:\n+**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov18 (uint32_t *in, uint32_t *out) \n+{ \n+ register vuint32m8_t v8 asm(\"v8\") = *(vuint32m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vuint32m8_t v16 asm(\"v16\") = v8; \n+ *(vuint32m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov19:\n+**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov19 (uint64_t *in, uint64_t *out) \n+{ \n+ register vuint64m1_t v1 asm(\"v1\") = *(vuint64m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vuint64m1_t v2 asm(\"v2\") = v1; \n+ *(vuint64m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov20:\n+**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov20 (uint64_t *in, uint64_t *out) \n+{ \n+ register vuint64m2_t v2 asm(\"v2\") = *(vuint64m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vuint64m2_t v4 asm(\"v4\") = v2; \n+ *(vuint64m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov21:\n+**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov21 (uint64_t *in, uint64_t *out) \n+{ \n+ register vuint64m4_t v4 asm(\"v4\") = *(vuint64m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vuint64m4_t v8 asm(\"v8\") = v4; \n+ *(vuint64m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov22:\n+**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov22 (uint64_t *in, uint64_t *out) \n+{ \n+ register vuint64m8_t v8 asm(\"v8\") = *(vuint64m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vuint64m8_t v16 asm(\"v16\") = v8; \n+ *(vuint64m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}"}, {"sha": "5b8ce40b62d40bbfd08d710f2842fc3086d7f327", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-12.c", "status": "added", "additions": 159, "deletions": 0, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-12.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,159 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h> \n+\n+/*\n+** mov14:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov14 (float *in, float *out) \n+{ \n+ register vfloat32mf2_t v1 asm(\"v1\") = *(vfloat32mf2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vfloat32mf2_t v2 asm(\"v2\") = v1; \n+ *(vfloat32mf2_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov15:\n+**\tvl1re32\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov15 (float *in, float *out) \n+{ \n+ register vfloat32m1_t v1 asm(\"v1\") = *(vfloat32m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vfloat32m1_t v2 asm(\"v2\") = v1; \n+ *(vfloat32m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov16:\n+**\tvl2re32\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov16 (float *in, float *out) \n+{ \n+ register vfloat32m2_t v2 asm(\"v2\") = *(vfloat32m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vfloat32m2_t v4 asm(\"v4\") = v2; \n+ *(vfloat32m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov17:\n+**\tvl4re32\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov17 (float *in, float *out)\n+{ \n+ register vfloat32m4_t v4 asm(\"v4\") = *(vfloat32m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vfloat32m4_t v8 asm(\"v8\") = v4; \n+ *(vfloat32m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov18:\n+**\tvl8re32\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov18 (float *in, float *out) \n+{ \n+ register vfloat32m8_t v8 asm(\"v8\") = *(vfloat32m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vfloat32m8_t v16 asm(\"v16\") = v8; \n+ *(vfloat32m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}\n+\n+/*\n+** mov19:\n+**\tvl1re64\\.v\\tv1,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv1r\\.v\\tv2,v1\n+**\t...\n+**  ret\n+*/\n+void mov19 (uint64_t *in, uint64_t *out) \n+{ \n+ register vfloat64m1_t v1 asm(\"v1\") = *(vfloat64m1_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vfloat64m1_t v2 asm(\"v2\") = v1; \n+ *(vfloat64m1_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}\n+\n+/*\n+** mov20:\n+**\tvl2re64\\.v\\tv2,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv2r\\.v\\tv4,v2\n+**\t...\n+**  ret\n+*/\n+void mov20 (uint64_t *in, uint64_t *out) \n+{ \n+ register vfloat64m2_t v2 asm(\"v2\") = *(vfloat64m2_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+ register vfloat64m2_t v4 asm(\"v4\") = v2; \n+ *(vfloat64m2_t*)out = v4; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+}\n+\n+/*\n+** mov21:\n+**\tvl4re64\\.v\\tv4,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv4r\\.v\\tv8,v4\n+**\t...\n+**  ret\n+*/\n+void mov21 (uint64_t *in, uint64_t *out) \n+{ \n+ register vfloat64m4_t v4 asm(\"v4\") = *(vfloat64m4_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v4)); \n+ register vfloat64m4_t v8 asm(\"v8\") = v4; \n+ *(vfloat64m4_t*)out = v8; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+}\n+\n+/*\n+** mov22:\n+**\tvl8re64\\.v\\tv8,0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\t...\n+**  vmv8r\\.v\\tv16,v8\n+**\t...\n+**  ret\n+*/\n+void mov22 (uint64_t *in, uint64_t *out) \n+{ \n+ register vfloat64m8_t v8 asm(\"v8\") = *(vfloat64m8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v8)); \n+ register vfloat64m8_t v16 asm(\"v16\") = v8; \n+ *(vfloat64m8_t*)out = v16; \n+ asm volatile (\"# %0\"::\"vr\"(v16)); \n+}"}, {"sha": "8c630f3bedb7945645cbb926fd50a03e7859b981", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-13.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-13.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+\n+#include <riscv_vector.h> \n+\n+void mov1 (int8_t *in, int8_t *out) \n+{ \n+ register vint8mf8_t v1 asm(\"v1\") = *(vint8mf8_t*)in; \n+ asm volatile (\"# %0\"::\"vr\"(v1)); \n+ register vint8mf8_t v2 asm(\"v2\") = v1;\n+ asm volatile (\"#\":::\"v2\"); \n+ *(vint8mf8_t*)out = v2; \n+ asm volatile (\"# %0\"::\"vr\"(v2)); \n+}"}, {"sha": "b9bdd515747ec6c01e14ab262ee63a21de4c9e7f", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-2.c", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-2.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,153 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov2 (int16_t *in, int16_t *out)\n+{\n+  vint16mf4_t v = *(vint16mf4_t*)in;\n+  *(vint16mf4_t*)out = v;\n+}\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov3 (int16_t *in, int16_t *out)\n+{\n+  vint16mf2_t v = *(vint16mf2_t*)in;\n+  *(vint16mf2_t*)out = v;\n+}\n+\n+/*\n+** mov4:\n+**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (int16_t *in, int16_t *out)\n+{\n+  vint16m1_t v = *(vint16m1_t*)in;\n+  *(vint16m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (int16_t *in, int16_t *out)\n+{\n+  vint16m2_t v = *(vint16m2_t*)in;\n+  *(vint16m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (int16_t *in, int16_t *out)\n+{\n+  vint16m4_t v = *(vint16m4_t*)in;\n+  *(vint16m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (int16_t *in, int16_t *out)\n+{\n+  vint16m8_t v = *(vint16m8_t*)in;\n+  *(vint16m8_t*)out = v;\n+}\n+\n+/*\n+** mov8:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov8 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16mf4_t v = *(vuint16mf4_t*)in;\n+  *(vuint16mf4_t*)out = v;\n+}\n+\n+/*\n+** mov9:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e16,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov9 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16mf2_t v = *(vuint16mf2_t*)in;\n+  *(vuint16mf2_t*)out = v;\n+}\n+\n+/*\n+** mov10:\n+**\tvl1re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov10 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16m1_t v = *(vuint16m1_t*)in;\n+  *(vuint16m1_t*)out = v;\n+}\n+\n+/*\n+** mov11:\n+**\tvl2re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov11 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16m2_t v = *(vuint16m2_t*)in;\n+  *(vuint16m2_t*)out = v;\n+}\n+\n+/*\n+** mov12:\n+**\tvl4re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov12 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16m4_t v = *(vuint16m4_t*)in;\n+  *(vuint16m4_t*)out = v;\n+}\n+\n+/*\n+** mov13:\n+**\tvl8re16\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov13 (uint16_t *in, uint16_t *out)\n+{\n+  vuint16m8_t v = *(vuint16m8_t*)in;\n+  *(vuint16m8_t*)out = v;\n+}"}, {"sha": "a7a89db2735f6654a0f4d249c4c60c156ae208d8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-3.c", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-3.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,127 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov3 (int32_t *in, int32_t *out)\n+{\n+  vint32mf2_t v = *(vint32mf2_t*)in;\n+  *(vint32mf2_t*)out = v;\n+}\n+\n+/*\n+** mov4:\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (int32_t *in, int32_t *out)\n+{\n+  vint32m1_t v = *(vint32m1_t*)in;\n+  *(vint32m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (int32_t *in, int32_t *out)\n+{\n+  vint32m2_t v = *(vint32m2_t*)in;\n+  *(vint32m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (int32_t *in, int32_t *out)\n+{\n+  vint32m4_t v = *(vint32m4_t*)in;\n+  *(vint32m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (int32_t *in, int32_t *out)\n+{\n+  vint32m8_t v = *(vint32m8_t*)in;\n+  *(vint32m8_t*)out = v;\n+}\n+\n+/*\n+** mov8:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov8 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32mf2_t v = *(vuint32mf2_t*)in;\n+  *(vuint32mf2_t*)out = v;\n+}\n+\n+/*\n+** mov9:\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov9 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32m1_t v = *(vuint32m1_t*)in;\n+  *(vuint32m1_t*)out = v;\n+}\n+\n+/*\n+** mov10:\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov10 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32m2_t v = *(vuint32m2_t*)in;\n+  *(vuint32m2_t*)out = v;\n+}\n+\n+/*\n+** mov11:\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov11 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32m4_t v = *(vuint32m4_t*)in;\n+  *(vuint32m4_t*)out = v;\n+}\n+\n+/*\n+** mov12:\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov12 (uint32_t *in, uint32_t *out)\n+{\n+  vuint32m8_t v = *(vuint32m8_t*)in;\n+  *(vuint32m8_t*)out = v;\n+}"}, {"sha": "e8cfb4b10b4557ee5d713a3fa3fd7a96cf5de3c8", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-4.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-4.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov4:\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (int64_t *in, int64_t *out)\n+{\n+  vint64m1_t v = *(vint64m1_t*)in;\n+  *(vint64m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (int64_t *in, int64_t *out)\n+{\n+  vint64m2_t v = *(vint64m2_t*)in;\n+  *(vint64m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (int64_t *in, int64_t *out)\n+{\n+  vint64m4_t v = *(vint64m4_t*)in;\n+  *(vint64m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (int64_t *in, int64_t *out)\n+{\n+  vint64m8_t v = *(vint64m8_t*)in;\n+  *(vint64m8_t*)out = v;\n+}\n+\n+/*\n+** mov8:\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov8 (uint64_t *in, uint64_t *out)\n+{\n+  vuint64m1_t v = *(vuint64m1_t*)in;\n+  *(vuint64m1_t*)out = v;\n+}\n+\n+/*\n+** mov9:\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov9 (uint64_t *in, uint64_t *out)\n+{\n+  vuint64m2_t v = *(vuint64m2_t*)in;\n+  *(vuint64m2_t*)out = v;\n+}\n+\n+/*\n+** mov10:\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov10 (uint64_t *in, uint64_t *out)\n+{\n+  vuint64m4_t v = *(vuint64m4_t*)in;\n+  *(vuint64m4_t*)out = v;\n+}\n+\n+/*\n+** mov11:\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov11 (uint64_t *in, uint64_t *out)\n+{\n+  vuint64m8_t v = *(vuint64m8_t*)in;\n+  *(vuint64m8_t*)out = v;\n+}"}, {"sha": "5ca232ba86793d46d44c270f90fc178c642e2281", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-5.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-5.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e32,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov3 (float *in, float *out)\n+{\n+  vfloat32mf2_t v = *(vfloat32mf2_t*)in;\n+  *(vfloat32mf2_t*)out = v;\n+}\n+\n+/*\n+** mov4:\n+**\tvl1re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (float *in, float *out)\n+{\n+  vfloat32m1_t v = *(vfloat32m1_t*)in;\n+  *(vfloat32m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (float *in, float *out)\n+{\n+  vfloat32m2_t v = *(vfloat32m2_t*)in;\n+  *(vfloat32m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (float *in, float *out)\n+{\n+  vfloat32m4_t v = *(vfloat32m4_t*)in;\n+  *(vfloat32m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re32\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (float *in, float *out)\n+{\n+  vfloat32m8_t v = *(vfloat32m8_t*)in;\n+  *(vfloat32m8_t*)out = v;\n+}"}, {"sha": "41fc73bb099a05ac62b5e4c274efc08509d1f9b9", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-6.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-6.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov4:\n+**\tvl1re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs1r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (double *in, double *out)\n+{\n+  vfloat64m1_t v = *(vfloat64m1_t*)in;\n+  *(vfloat64m1_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvl2re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs2r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (double *in, double *out)\n+{\n+  vfloat64m2_t v = *(vfloat64m2_t*)in;\n+  *(vfloat64m2_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvl4re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs4r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (double *in, double *out)\n+{\n+  vfloat64m4_t v = *(vfloat64m4_t*)in;\n+  *(vfloat64m4_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvl8re64\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvs8r\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (double *in, double *out)\n+{\n+  vfloat64m8_t v = *(vfloat64m8_t*)in;\n+  *(vfloat64m8_t*)out = v;\n+}"}, {"sha": "d4636e0adfbc9bdf26f8892d691dc296151a7ebc", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-7.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-7.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+\n+#include <riscv_vector.h>\n+\n+/* This testcase is testing whether RISC-V define REGMODE_NATURAL_SIZE.  */\n+void foo (int8_t *in, int8_t *out)\n+{\n+  vint8mf2_t v = *(vint8mf2_t*)in;\n+  vint32mf2_t v2 = *(vint32mf2_t*)in;\n+  *(vint8mf2_t*)out = v;\n+  *(vint32mf2_t*)(out + 16) = v2;\n+}"}, {"sha": "9447b05899d59993c1e7014fd1b203abff6a0979", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-8.c", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-8.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,96 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/*\n+** mov1:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf8,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov1 (int8_t *in, int8_t *out)\n+{\n+  vbool64_t v = *(vbool64_t*)in;\n+  *(vbool64_t*)out = v;\n+}\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov2 (int8_t *in, int8_t *out)\n+{\n+  vbool32_t v = *(vbool32_t*)in;\n+  *(vbool32_t*)out = v;\n+}\n+\n+/*\n+** mov3:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov3 (int8_t *in, int8_t *out)\n+{\n+  vbool16_t v = *(vbool16_t*)in;\n+  *(vbool16_t*)out = v;\n+}\n+\n+/*\n+** mov4:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m1,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov4 (int8_t *in, int8_t *out)\n+{\n+  vbool8_t v = *(vbool8_t*)in;\n+  *(vbool8_t*)out = v;\n+}\n+\n+/*\n+** mov5:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m2,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov5 (int8_t *in, int8_t *out)\n+{\n+  vbool4_t v = *(vbool4_t*)in;\n+  *(vbool4_t*)out = v;\n+}\n+\n+/*\n+** mov6:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m4,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov6 (int8_t *in, int8_t *out)\n+{\n+  vbool2_t v = *(vbool2_t*)in;\n+  *(vbool2_t*)out = v;\n+}\n+\n+/*\n+** mov7:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*m8,\\s*t[au],\\s*m[au]\n+**\tvlm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvsm\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov7 (int8_t *in, int8_t *out)\n+{\n+  vbool1_t v = *(vbool1_t*)in;\n+  *(vbool1_t*)out = v;\n+}"}, {"sha": "6d39e3c0f4df4b08597d3367dd913087ec551d07", "filename": "gcc/testsuite/gcc.target/riscv/rvv/base/mov-9.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f556cd8bd7929be8b73c66d55f98feac8c9ef1ee/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Friscv%2Frvv%2Fbase%2Fmov-9.c?ref=f556cd8bd7929be8b73c66d55f98feac8c9ef1ee", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-march=rv32gcv -mabi=ilp32d -O3 -fno-schedule-insns -fno-schedule-insns2\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <riscv_vector.h>\n+\n+/* Test tieable of RVV types with same LMUL.  */\n+/*\n+** mov1:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf2,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),1\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),2\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov1 (int8_t *in, int8_t *out, int M)\n+{\n+  vint8mf2_t v1 = *(vint8mf2_t*)(in);\n+  vint16mf2_t v2 = *(vint16mf2_t*)(in);\n+  vint32mf2_t v3 = *(vint32mf2_t*)(in);\n+  *(vint8mf2_t*)(out) = v1;\n+  *(vint16mf2_t*)(out + 1) = v2;\n+  *(vint32mf2_t*)(out + 2) = v3;\n+}\n+\n+/*\n+** mov2:\n+**\tvsetvli\\s+(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),\\s*zero,\\s*e8,\\s*mf4,\\s*t[au],\\s*m[au]\n+**\tvle8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  addi\\t(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),(?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7]),1\n+**\tvse8\\.v\\s+(?:v[0-9]|v[1-2][0-9]|v3[0-1]),0\\s*\\((?:ra|[sgtf]p|t[0-6]|s[0-9]|s10|s11|a[0-7])\\)\n+**  ret\n+*/\n+void mov2 (int8_t *in, int8_t *out, int M)\n+{\n+  vint8mf4_t v1 = *(vint8mf4_t*)(in);\n+  vint16mf4_t v2 = *(vint16mf4_t*)(in);\n+  *(vint8mf4_t*)(out) = v1;\n+  *(vint16mf4_t*)(out + 1) = v2;\n+}"}]}