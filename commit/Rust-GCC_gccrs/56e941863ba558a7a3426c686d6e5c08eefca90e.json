{"sha": "56e941863ba558a7a3426c686d6e5c08eefca90e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZlOTQxODYzYmE1NThhN2EzNDI2YzY4NmQ2ZTVjMDhlZWZjYTkwZQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T08:22:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-08-03T08:22:52Z"}, "message": "[multiple changes]\n\n2011-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* gnat_ugn.texi: Document -Wstack-usage.\n\t* gcc-interface/misc.c (enumerate_modes): Add guard for ghost FP modes.\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_prag.adb Issue an error (not a warning) when a C++ type does not\n\thave keyword LIMITED.\n\n2011-08-03  Yannick Moy  <moy@adacore.com>\n\n\t* alfa.adb, alfa.ads, alfa_test.adb: New files.\n\t* ali.adb (Known_ALI_Lines): add 'C' lines (SCO) and 'F' lines (ALFA)\n\t(Scan_ALI): do not issue a fatal error if parsing known lines after Xref\n\tsection (does not happen in compiler, only if code directly calls\n\tScan_ALI).\n\t* get_alfa.adb, get_alfa.ads: New files.\n\t* lib-writ.adb, lib-writ.ads (Write_ALI): output ALFA information if\n\tneeded.\n\t* lib-xref-alfa.adb: New file.\n\t* lib-xref.adb, lib-xref.ads\n\t(Xref_Entry): redefine information needed in cross-references for ALFA.\n\tPush ALFA treatments in separated local package.\n\t(Enclosing_Subpragram_Or_Package): treat specially subprogram\n\tidentifiers. Return entity of package body instead of spec. Return\n\tEmpty for a scope with no location.\n\t(Generate_Reference): adapt to new components for ALFA information.\n\tRemove the need for D references on definitions.\n\t(Is_Local_Reference): moved to ALFA local package\n\t(Output_References): extract subfunction as Extract_Source_Name\n\t(Output_Local_References): remove procedure, replaced by filtering of\n\tcross-references in package ALFA and printing in Put_ALFA.\n\t(Write_Entity_Name): remove procedure\n\t* lib.adb, lib.ads (Extract_Source_Name): extract here function to\n\tprint exact name of entity as it appears in source file\n\t(Unit_Ref_Table): make type public for use in Lib.Xref.ALFA\n\t* put_alfa.adb, put_alfa.ads: New files.\n\t* xref_lib.adb (Search_Xref): protect read of cross-references against\n\treading other sections of the ALI file, in gnatxref\n\t(Search): protect read of cross-references against reading other\n\tsections of the ALI file, in gnatfind.\n\t* gcc-interface/Make-lang.in: Update dependencies.\n\n2011-08-03  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_ch3.adb: Minor reformatting.\n\n2011-08-03  Jose Ruiz  <ruiz@adacore.com>\n\n\t* s-inmaop-vxworks.adb (Setup_Interrupt_Mask): Do nothing instead of\n\traising an exception.\n\n2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Set_String_Literal_Subtype): if index type is an integer\n\ttype, always use 1 as the lower bound or string, even if lower bound of\n\tcontext is not static, to handle properly null strings in a non-static\n\tcontext.\n\n2011-08-03  Bob Duff  <duff@adacore.com>\n\n\t* sem_prag.adb (Resolve_Aggregate): An array aggregate with 'others' is\n\talways legal on the right-hand side of an assignment statement; there\n\tis always an applicable index constraint in this case. Therefore, the\n\tcheck for Pkind = N_Assignment_Statement is now unconditional -- it\n\tdoesn't depend on whether Is_Constrained (Typ).\n\nFrom-SVN: r177239", "tree": {"sha": "eeabf64a1a78064507c612cff6b0b9e20b698374", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eeabf64a1a78064507c612cff6b0b9e20b698374"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56e941863ba558a7a3426c686d6e5c08eefca90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e941863ba558a7a3426c686d6e5c08eefca90e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56e941863ba558a7a3426c686d6e5c08eefca90e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56e941863ba558a7a3426c686d6e5c08eefca90e/comments", "author": null, "committer": null, "parents": [{"sha": "4317e442b4eced893bf40c552deb37c303d81102", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4317e442b4eced893bf40c552deb37c303d81102", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4317e442b4eced893bf40c552deb37c303d81102"}], "stats": {"total": 5836, "additions": 4027, "deletions": 1809}, "files": [{"sha": "7babb5075921d1f0a212e1367ef0dac387796001", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -1,3 +1,71 @@\n+2011-08-03  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat_ugn.texi: Document -Wstack-usage.\n+\t* gcc-interface/misc.c (enumerate_modes): Add guard for ghost FP modes.\n+\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_prag.adb Issue an error (not a warning) when a C++ type does not\n+\thave keyword LIMITED.\n+\n+2011-08-03  Yannick Moy  <moy@adacore.com>\n+\n+\t* alfa.adb, alfa.ads, alfa_test.adb: New files.\n+\t* ali.adb (Known_ALI_Lines): add 'C' lines (SCO) and 'F' lines (ALFA)\n+\t(Scan_ALI): do not issue a fatal error if parsing known lines after Xref\n+\tsection (does not happen in compiler, only if code directly calls\n+\tScan_ALI).\n+\t* get_alfa.adb, get_alfa.ads: New files.\n+\t* lib-writ.adb, lib-writ.ads (Write_ALI): output ALFA information if\n+\tneeded.\n+\t* lib-xref-alfa.adb: New file.\n+\t* lib-xref.adb, lib-xref.ads\n+\t(Xref_Entry): redefine information needed in cross-references for ALFA.\n+\tPush ALFA treatments in separated local package.\n+\t(Enclosing_Subpragram_Or_Package): treat specially subprogram\n+\tidentifiers. Return entity of package body instead of spec. Return\n+\tEmpty for a scope with no location.\n+\t(Generate_Reference): adapt to new components for ALFA information.\n+\tRemove the need for D references on definitions.\n+\t(Is_Local_Reference): moved to ALFA local package\n+\t(Output_References): extract subfunction as Extract_Source_Name\n+\t(Output_Local_References): remove procedure, replaced by filtering of\n+\tcross-references in package ALFA and printing in Put_ALFA.\n+\t(Write_Entity_Name): remove procedure\n+\t* lib.adb, lib.ads (Extract_Source_Name): extract here function to\n+\tprint exact name of entity as it appears in source file\n+\t(Unit_Ref_Table): make type public for use in Lib.Xref.ALFA\n+\t* put_alfa.adb, put_alfa.ads: New files.\n+\t* xref_lib.adb (Search_Xref): protect read of cross-references against\n+\treading other sections of the ALI file, in gnatxref\n+\t(Search): protect read of cross-references against reading other\n+\tsections of the ALI file, in gnatfind.\n+\t* gcc-interface/Make-lang.in: Update dependencies.\n+\n+2011-08-03  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_ch3.adb: Minor reformatting.\n+\n+2011-08-03  Jose Ruiz  <ruiz@adacore.com>\n+\n+\t* s-inmaop-vxworks.adb (Setup_Interrupt_Mask): Do nothing instead of\n+\traising an exception.\n+\n+2011-08-03  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Set_String_Literal_Subtype): if index type is an integer\n+\ttype, always use 1 as the lower bound or string, even if lower bound of\n+\tcontext is not static, to handle properly null strings in a non-static\n+\tcontext.\n+\n+2011-08-03  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_prag.adb (Resolve_Aggregate): An array aggregate with 'others' is\n+\talways legal on the right-hand side of an assignment statement; there\n+\tis always an applicable index constraint in this case. Therefore, the\n+\tcheck for Pkind = N_Assignment_Statement is now unconditional -- it\n+\tdoesn't depend on whether Is_Constrained (Typ).\n+\n 2011-08-03  Robert Dewar  <dewar@adacore.com>\n \n \t* exp_ch5.adb, sem_prag.adb, exp_ch4.adb: Minor reformatting."}, {"sha": "42997b73461c2e1b55ea6732f8741497e461acea", "filename": "gcc/ada/alfa.adb", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,203 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                 A L F A                                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Output;   use Output;\n+with Put_ALFA;\n+\n+package body ALFA is\n+\n+   -----------\n+   -- dalfa --\n+   -----------\n+\n+   procedure dalfa is\n+   begin\n+      --  Dump ALFA file table\n+\n+      Write_Line (\"ALFA File Table\");\n+      Write_Line (\"---------------\");\n+\n+      for Index in 1 .. ALFA_File_Table.Last loop\n+         declare\n+            AFR : ALFA_File_Record renames ALFA_File_Table.Table (Index);\n+\n+         begin\n+            Write_Str (\"  \");\n+            Write_Int (Int (Index));\n+            Write_Str (\".  File_Num = \");\n+            Write_Int (Int (AFR.File_Num));\n+            Write_Str (\"  File_Name = \"\"\");\n+\n+            if AFR.File_Name /= null then\n+               Write_Str (AFR.File_Name.all);\n+            end if;\n+\n+            Write_Char ('\"');\n+            Write_Str (\"  From = \");\n+            Write_Int (Int (AFR.From_Scope));\n+            Write_Str (\"  To = \");\n+            Write_Int (Int (AFR.To_Scope));\n+            Write_Eol;\n+         end;\n+      end loop;\n+\n+      --  Dump ALFA scope table\n+\n+      Write_Eol;\n+      Write_Line (\"ALFA Scope Table\");\n+      Write_Line (\"----------------\");\n+\n+      for Index in 1 .. ALFA_Scope_Table.Last loop\n+         declare\n+            ASR : ALFA_Scope_Record renames ALFA_Scope_Table.Table (Index);\n+\n+         begin\n+            Write_Str (\"  \");\n+            Write_Int (Int (Index));\n+            Write_Str (\".  File_Num = \");\n+            Write_Int (Int (ASR.File_Num));\n+            Write_Str (\"  Scope_Num = \");\n+            Write_Int (Int (ASR.Scope_Num));\n+            Write_Str (\"  Scope_Name = \"\"\");\n+\n+            if ASR.Scope_Name /= null then\n+               Write_Str (ASR.Scope_Name.all);\n+            end if;\n+\n+            Write_Char ('\"');\n+            Write_Str  (\"  Line = \");\n+            Write_Int  (Int (ASR.Line));\n+            Write_Str  (\"  Col = \");\n+            Write_Int  (Int (ASR.Col));\n+            Write_Str  (\"  Type = \");\n+            Write_Char (ASR.Stype);\n+            Write_Str  (\"  From = \");\n+            Write_Int  (Int (ASR.From_Xref));\n+            Write_Str  (\"  To = \");\n+            Write_Int  (Int (ASR.To_Xref));\n+            Write_Str  (\"  Scope_Entity = \");\n+            Write_Int  (Int (ASR.Scope_Entity));\n+            Write_Eol;\n+         end;\n+      end loop;\n+\n+      --  Dump ALFA cross-reference table\n+\n+      Write_Eol;\n+      Write_Line (\"ALFA Xref Table\");\n+      Write_Line (\"---------------\");\n+\n+      for Index in 1 .. ALFA_Xref_Table.Last loop\n+         declare\n+            AXR : ALFA_Xref_Record renames ALFA_Xref_Table.Table (Index);\n+\n+         begin\n+            Write_Str  (\"  \");\n+            Write_Int  (Int (Index));\n+            Write_Str (\".  Entity_Name = \"\"\");\n+\n+            if AXR.Entity_Name /= null then\n+               Write_Str (AXR.Entity_Name.all);\n+            end if;\n+\n+            Write_Char ('\"');\n+            Write_Str (\"  Entity_Line = \");\n+            Write_Int (Int (AXR.Entity_Line));\n+            Write_Str (\"  Entity_Col = \");\n+            Write_Int (Int (AXR.Entity_Col));\n+            Write_Str (\"  File_Num = \");\n+            Write_Int (Int (AXR.File_Num));\n+            Write_Str (\"  Scope_Num = \");\n+            Write_Int (Int (AXR.Scope_Num));\n+            Write_Str (\"  Line = \");\n+            Write_Int (Int (AXR.Line));\n+            Write_Str (\"  Col = \");\n+            Write_Int (Int (AXR.Col));\n+            Write_Str (\"  Type = \");\n+            Write_Char (AXR.Rtype);\n+            Write_Eol;\n+         end;\n+      end loop;\n+   end dalfa;\n+\n+   ----------------\n+   -- Initialize --\n+   ----------------\n+\n+   procedure Initialize_ALFA_Tables is\n+   begin\n+      ALFA_File_Table.Init;\n+      ALFA_Scope_Table.Init;\n+      ALFA_Xref_Table.Init;\n+   end Initialize_ALFA_Tables;\n+\n+   -----------\n+   -- palfa --\n+   -----------\n+\n+   procedure palfa is\n+\n+      procedure Write_Info_Char (C : Character) renames Write_Char;\n+      --  Write one character;\n+\n+      function Write_Info_Col return Positive;\n+      --  Return next column for writing\n+\n+      procedure Write_Info_Initiate (Key : Character) renames Write_Char;\n+      --  Start new one and write one character;\n+\n+      procedure Write_Info_Nat (N : Nat);\n+      --  Write value of N\n+\n+      procedure Write_Info_Terminate renames Write_Eol;\n+      --  Terminate current line\n+\n+      --------------------\n+      -- Write_Info_Col --\n+      --------------------\n+\n+      function Write_Info_Col return Positive is\n+      begin\n+         return Positive (Column);\n+      end Write_Info_Col;\n+\n+      --------------------\n+      -- Write_Info_Nat --\n+      --------------------\n+\n+      procedure Write_Info_Nat (N : Nat) is\n+      begin\n+         Write_Int (N);\n+      end Write_Info_Nat;\n+\n+      procedure Debug_Put_ALFA is new Put_ALFA;\n+\n+      --  Start of processing for palfa\n+\n+   begin\n+      Debug_Put_ALFA;\n+   end palfa;\n+\n+end ALFA;"}, {"sha": "cf0e43db143093ddfcf366021961c8267164df9b", "filename": "gcc/ada/alfa.ads", "status": "added", "additions": 316, "deletions": 0, "changes": 316, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,316 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                                 A L F A                                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package defines tables used to store information needed for the ALFA\n+--  mode. It is used by procedures in Lib.Xref.ALFA to build the ALFA\n+--  information before writing it out to the ALI file, and by Get_ALFA/Put_ALFA\n+--  to read and write the text form that is used in the ALI file.\n+\n+with Types;      use Types;\n+with GNAT.Table;\n+\n+package ALFA is\n+\n+   --  ALFA information can exist in one of two forms. In the ALI file, it is\n+   --  represented using a text format that is described in this specification.\n+   --  Internally it is stored using three tables ALFA_Xref_Table,\n+   --  ALFA_Scope_Table and ALFA_File_Table, which are also defined in this\n+   --  unit.\n+\n+   --  Lib.Xref.ALFA is part of the compiler. It extracts ALFA information from\n+   --  the complete set of cross-references generated during compilation.\n+\n+   --  Get_ALFA reads the text lines in ALI format and populates the internal\n+   --  tables with corresponding information.\n+\n+   --  Put_ALFA reads the internal tables and generates text lines in the ALI\n+   --  format.\n+\n+   ---------------------\n+   -- ALFA ALI Format --\n+   ---------------------\n+\n+   --  ALFA information is generated on a unit-by-unit basis in the ALI file,\n+   --  using lines that start with the identifying character F (\"Formal\").\n+   --  These lines are generated if one of the -gnatd.E (SPARK generation mode)\n+   --  or gnatd.F (Why generation mode) switches is set.\n+\n+   --  The ALFA information follows the cross-reference information, so it\n+   --  needs not be read by tools like gnatbind, gnatmake etc.\n+\n+   --  -------------------\n+   --  -- Scope Section --\n+   --  -------------------\n+\n+   --  A first section defines the scopes in which entities are defined and\n+   --  referenced. A scope is a package/subprogram declaration/body. Note that\n+   --  a package declaration and body define two different scopes. Similarly, a\n+   --  subprogram declaration and body, when both present, define two different\n+   --  scopes.\n+\n+   --    FD dependency-number filename\n+\n+   --      This header precedes scope information for the unit identified by\n+   --      dependency number and file name. The dependency number is the index\n+   --      into the generated D lines and is ones-origin (e.g. 2 = reference to\n+   --      second generated D line).\n+\n+   --      The list of FD lines should match the list of D lines defined in the\n+   --      ALI file, in the same order.\n+\n+   --      Note that the filename here will reflect the original name if a\n+   --      Source_Reference pragma was encountered (since all line number\n+   --      references will be with respect to the original file).\n+\n+   --      Note: the filename is redundant in that it could be deduced from the\n+   --      corresponding D line, but it is convenient at least for human\n+   --      reading of the ALFA information, and means that the ALFA information\n+   --      can stand on its own without needing other parts of the ALI file.\n+\n+   --    FS . scope line type col entity\n+\n+   --      scope is the ones-origin scope number for the current file (e.g. 2 =\n+   --      reference to the second FS line in this FD block).\n+\n+   --      line is the line number of the scope entity. The name of the entity\n+   --      starts in column col. Columns are numbered from one, and if\n+   --      horizontal tab characters are present, the column number is computed\n+   --      assuming standard 1,9,17,.. tab stops. For example, if the entity is\n+   --      the first token on the line, and is preceded by space-HT-space, then\n+   --      the column would be column 10.\n+\n+   --      type is a single letter identifying the type of the entity, using\n+   --      the same code as in cross-references:\n+\n+   --        K = package\n+   --        V = function\n+   --        U = procedure\n+\n+   --      col is the column number of the scope entity\n+\n+   --      entity is the name of the scope entity, with casing in the canonical\n+   --      casing for the source file where it is defined.\n+\n+   --  ------------------\n+   --  -- Xref Section --\n+   --  ------------------\n+\n+   --  A second section defines cross-references useful for computing the set\n+   --  of global variables read/written in each subprogram/package.\n+\n+   --    FX dependency-number filename . entity-number entity\n+\n+   --      dependency-number and filename identity a file in FD lines\n+\n+   --      entity-number and identity identify a scope entity in FS lines for\n+   --      the file previously identified.\n+\n+   --    line col entity ref*\n+\n+   --      line is the line number of the referenced entity\n+\n+   --      col is the column number of the referenced entity\n+\n+   --      entity is the name of the referenced entity as written in the source\n+   --      file where it is defined.\n+\n+   --  There may be zero or more ref entries on each line\n+\n+   --    (file |)? ((. scope :)? line type col)*\n+\n+   --      file is the dependency number of the file with the reference. It and\n+   --      the following vertical bar are omitted if the file is the same as\n+   --      the previous ref, and the refs for the current file are first (and\n+   --      do not need a bar).\n+\n+   --      scope is the scope number of the scope with the reference. It and\n+   --      the following colon are omitted if the scope is the same as the\n+   --      previous ref, and the refs for the current scope are first (and do\n+   --      not need a colon).\n+\n+   --      line is the line number of the reference\n+\n+   --      col is the column number of the reference\n+\n+   --      type is one of the following, using the same code as in\n+   --      cross-references:\n+\n+   --        m = modification\n+   --        r = reference\n+   --        s = subprogram reference in a static call\n+\n+   --    Examples: ??? add examples here\n+\n+   ----------------\n+   -- Xref Table --\n+   ----------------\n+\n+   --  The following table records ALFA cross-references\n+\n+   type Xref_Index is new Int;\n+   --  Used to index values in this table. Values start at 1 and are assigned\n+   --  sequentially as entries are constructed.\n+\n+   type ALFA_Xref_Record is record\n+      Entity_Name : String_Ptr;\n+      --  Pointer to entity name in ALI file\n+\n+      Entity_Line : Nat;\n+      --  Line number for the entity referenced\n+\n+      Entity_Col : Nat;\n+      --  Column number for the entity referenced\n+\n+      File_Num : Nat;\n+      --  Set to the file dependency number for the cross-reference. Note\n+      --  that if no file entry is present explicitly, this is just a copy\n+      --  of the reference for the current cross-reference section.\n+\n+      Scope_Num : Nat;\n+      --  Set to the scope number for the cross-reference. Note that if no\n+      --  scope entry is present explicitly, this is just a copy of the\n+      --  reference for the current cross-reference section.\n+\n+      Line : Nat;\n+      --  Line number for the reference\n+\n+      Rtype : Character;\n+      --  Indicates type of reference, using code used in ALI file:\n+      --    r = reference\n+      --    m = modification\n+      --    s = call\n+\n+      Col : Nat;\n+      --  Column number for the reference\n+   end record;\n+\n+   package ALFA_Xref_Table is new GNAT.Table (\n+     Table_Component_Type => ALFA_Xref_Record,\n+     Table_Index_Type     => Xref_Index,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 2000,\n+     Table_Increment      => 300);\n+\n+   -----------------\n+   -- Scope Table --\n+   -----------------\n+\n+   --  This table keeps track of the scopes and the corresponding starting and\n+   --  ending indexes (From, To) in the Xref table.\n+\n+   type Scope_Index is new Int;\n+   --  Used to index values in this table. Values start at 1 and are assigned\n+   --  sequentially as entries are constructed.\n+\n+   type ALFA_Scope_Record is record\n+      Scope_Name : String_Ptr;\n+      --  Pointer to scope name in ALI file\n+\n+      File_Num : Nat;\n+      --  Set to the file dependency number for the scope\n+\n+      Scope_Num : Nat;\n+      --  Set to the scope number for the scope\n+\n+      Line : Nat;\n+      --  Line number for the scope\n+\n+      Stype : Character;\n+      --  Indicates type of scope, using code used in ALI file:\n+      --    K = package\n+      --    V = function\n+      --    U = procedure\n+\n+      Col : Nat;\n+      --  Column number for the scope\n+\n+      From_Xref : Xref_Index;\n+      --  Starting index in Xref table for this scope\n+\n+      To_Xref : Xref_Index;\n+      --  Ending index in Xref table for this scope\n+\n+      --  The following component is only used in-memory, not printed out in\n+      --  ALI file.\n+\n+      Scope_Entity : Entity_Id := Empty;\n+      --  Entity (subprogram or package) for the scope\n+   end record;\n+\n+   package ALFA_Scope_Table is new GNAT.Table (\n+     Table_Component_Type => ALFA_Scope_Record,\n+     Table_Index_Type     => Scope_Index,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 200,\n+     Table_Increment      => 300);\n+\n+   ----------------\n+   -- File Table --\n+   ----------------\n+\n+   --  This table keeps track of the units and the corresponding starting and\n+   --  ending indexes (From, To) in the Scope table.\n+\n+   type File_Index is new Int;\n+   --  Used to index values in this table. Values start at 1 and are assigned\n+   --  sequentially as entries are constructed.\n+\n+   type ALFA_File_Record is record\n+      File_Name : String_Ptr;\n+      --  Pointer to file name in ALI file\n+\n+      File_Num : Nat;\n+      --  Dependency number in ALI file\n+\n+      From_Scope : Scope_Index;\n+      --  Starting index in Scope table for this unit\n+\n+      To_Scope : Scope_Index;\n+      --  Ending index in Scope table for this unit\n+   end record;\n+\n+   package ALFA_File_Table is new GNAT.Table (\n+     Table_Component_Type => ALFA_File_Record,\n+     Table_Index_Type     => File_Index,\n+     Table_Low_Bound      => 1,\n+     Table_Initial        => 20,\n+     Table_Increment      => 200);\n+\n+   -----------------\n+   -- Subprograms --\n+   -----------------\n+\n+   procedure dalfa;\n+   --  Debug routine to dump internal ALFA tables. This is a raw format dump\n+   --  showing exactly what the tables contain.\n+\n+   procedure Initialize_ALFA_Tables;\n+   --  Reset tables for a new compilation\n+\n+   procedure palfa;\n+   --  Debugging procedure to output contents of ALFA binary tables in the\n+   --  format in which they appear in an ALI file.\n+\n+end ALFA;"}, {"sha": "c190d1f1f4ad1617b632048854d2fd9ae71d1788", "filename": "gcc/ada/alfa_test.adb", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa_test.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Falfa_test.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Falfa_test.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,332 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                          GNAT SYSTEM UTILITIES                           --\n+--                                                                          --\n+--                            A L F A _ T E S T                             --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2011, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This utility program is used to test proper operation of the Get_ALFA and\n+--  Put_ALFA units. To run it, compile any source file with switch -gnatd.E or\n+--  -gnatd.F to get an ALI file file.ALI containing ALFA information. Then run\n+--  this utility using:\n+\n+--     ALFA_Test file.ali\n+\n+--  This test will read the ALFA information from the ALI file, and use\n+--  Get_ALFA to store this in binary form in the internal tables in ALFA. Then\n+--  Put_ALFA is used to write the information from these tables back into text\n+--  form. This output is compared with the original ALFA information in the ALI\n+--  file and the two should be identical. If not an error message is output.\n+\n+with Get_ALFA;\n+with Put_ALFA;\n+\n+with ALFA;  use ALFA;\n+with Types; use Types;\n+\n+with Ada.Command_Line;      use Ada.Command_Line;\n+with Ada.Streams;           use Ada.Streams;\n+with Ada.Streams.Stream_IO; use Ada.Streams.Stream_IO;\n+with Ada.Text_IO;\n+\n+procedure ALFA_Test is\n+   Infile    : File_Type;\n+   Outfile_1 : File_Type;\n+   Outfile_2 : File_Type;\n+   C         : Character;\n+\n+   Stop : exception;\n+   --  Terminate execution\n+\n+   use ASCII;\n+\n+begin\n+   if Argument_Count /= 1 then\n+      Ada.Text_IO.Put_Line (\"Usage: alfa_test FILE.ali\");\n+      raise Stop;\n+   end if;\n+\n+   Create (Outfile_1, Out_File, \"log1\");\n+   Create (Outfile_2, Out_File, \"log2\");\n+   Open   (Infile,    In_File,  Argument (1));\n+\n+   --  Read input file till we get to first 'F' line\n+\n+   Process : declare\n+      Output_Col : Positive := 1;\n+\n+      function Get_Char (F : File_Type) return Character;\n+      --  Read one character from specified  file\n+\n+      procedure Put_Char (F : File_Type; C : Character);\n+      --  Write one character to specified file\n+\n+      function Get_Output_Col return Positive;\n+      --  Return current column in output file, where each line starts at\n+      --  column 1 and terminate with LF, and HT is at columns 1, 9, etc.\n+      --  All output is supposed to be carried through Put_Char.\n+\n+      --------------\n+      -- Get_Char --\n+      --------------\n+\n+      function Get_Char (F : File_Type) return Character is\n+         Item : Stream_Element_Array (1 .. 1);\n+         Last : Stream_Element_Offset;\n+\n+      begin\n+         Read (F, Item, Last);\n+\n+         if Last /= 1 then\n+            return Types.EOF;\n+         else\n+            return Character'Val (Item (1));\n+         end if;\n+      end Get_Char;\n+\n+      --------------------\n+      -- Get_Output_Col --\n+      --------------------\n+\n+      function Get_Output_Col return Positive is\n+      begin\n+         return Output_Col;\n+      end Get_Output_Col;\n+\n+      --------------\n+      -- Put_Char --\n+      --------------\n+\n+      procedure Put_Char (F : File_Type; C : Character) is\n+         Item : Stream_Element_Array (1 .. 1);\n+      begin\n+         if C /= CR and then C /= EOF then\n+            if C = LF then\n+               Output_Col := 1;\n+            elsif C = HT then\n+               Output_Col := ((Output_Col + 6) / 8) * 8 + 1;\n+            else\n+               Output_Col := Output_Col + 1;\n+            end if;\n+\n+            Item (1) := Character'Pos (C);\n+            Write (F, Item);\n+         end if;\n+      end Put_Char;\n+\n+      --  Subprograms used by Get_ALFA (these also copy the output to Outfile_1\n+      --  for later comparison with the output generated by Put_ALFA).\n+\n+      function  Getc  return Character;\n+      function  Nextc return Character;\n+      procedure Skipc;\n+\n+      ----------\n+      -- Getc --\n+      ----------\n+\n+      function Getc  return Character is\n+         C : Character;\n+      begin\n+         C := Get_Char (Infile);\n+         Put_Char (Outfile_1, C);\n+         return C;\n+      end Getc;\n+\n+      -----------\n+      -- Nextc --\n+      -----------\n+\n+      function Nextc return Character is\n+         C : Character;\n+      begin\n+         C := Get_Char (Infile);\n+\n+         if C /= EOF then\n+            Set_Index (Infile, Index (Infile) - 1);\n+         end if;\n+\n+         return C;\n+      end Nextc;\n+\n+      -----------\n+      -- Skipc --\n+      -----------\n+\n+      procedure Skipc is\n+         C : Character;\n+         pragma Unreferenced (C);\n+      begin\n+         C := Getc;\n+      end Skipc;\n+\n+      --  Subprograms used by Put_ALFA, which write information to Outfile_2\n+\n+      function Write_Info_Col return Positive;\n+      procedure Write_Info_Char (C : Character);\n+      procedure Write_Info_Initiate (Key : Character);\n+      procedure Write_Info_Nat (N : Nat);\n+      procedure Write_Info_Terminate;\n+\n+      --------------------\n+      -- Write_Info_Col --\n+      --------------------\n+\n+      function Write_Info_Col return Positive is\n+      begin\n+         return Get_Output_Col;\n+      end Write_Info_Col;\n+\n+      ---------------------\n+      -- Write_Info_Char --\n+      ---------------------\n+\n+      procedure Write_Info_Char (C : Character) is\n+      begin\n+         Put_Char (Outfile_2, C);\n+      end Write_Info_Char;\n+\n+      -------------------------\n+      -- Write_Info_Initiate --\n+      -------------------------\n+\n+      procedure Write_Info_Initiate (Key : Character) is\n+      begin\n+         Write_Info_Char (Key);\n+      end Write_Info_Initiate;\n+\n+      --------------------\n+      -- Write_Info_Nat --\n+      --------------------\n+\n+      procedure Write_Info_Nat (N : Nat) is\n+      begin\n+         if N > 9 then\n+            Write_Info_Nat (N / 10);\n+         end if;\n+\n+         Write_Info_Char (Character'Val (48 + N mod 10));\n+      end Write_Info_Nat;\n+\n+      --------------------------\n+      -- Write_Info_Terminate --\n+      --------------------------\n+\n+      procedure Write_Info_Terminate is\n+      begin\n+         Write_Info_Char (LF);\n+      end Write_Info_Terminate;\n+\n+      --  Local instantiations of Put_ALFA and Get_ALFA\n+\n+      procedure Get_ALFA_Info is new Get_ALFA;\n+      procedure Put_ALFA_Info is new Put_ALFA;\n+\n+   --  Start of processing for Process\n+\n+   begin\n+      --  Loop to skip till first 'F' line\n+\n+      loop\n+         C := Get_Char (Infile);\n+\n+         if C = EOF then\n+            Ada.Text_IO.Put_Line\n+              (Argument (1) & \": no SCO found, recompile with -gnateS\");\n+            raise Stop;\n+\n+         elsif C = LF or else C = CR then\n+            loop\n+               C := Get_Char (Infile);\n+               exit when C /= LF and then C /= CR;\n+            end loop;\n+\n+            exit when C = 'F';\n+         end if;\n+      end loop;\n+\n+      --  Position back to initial 'F' of first 'F' line\n+\n+      Set_Index (Infile, Index (Infile) - 1);\n+\n+      --  Read ALFA information to internal ALFA tables, also copying ALFA info\n+      --  to Outfile_1.\n+\n+      Initialize_ALFA_Tables;\n+      Get_ALFA_Info;\n+\n+      --  Write ALFA information from internal ALFA tables to Outfile_2\n+\n+      Put_ALFA_Info;\n+\n+      --  Junk blank line (see comment at end of Lib.Writ)\n+\n+      Write_Info_Terminate;\n+\n+      --  Now Outfile_1 and Outfile_2 should be identical\n+\n+      Compare_Files : declare\n+         Line : Natural;\n+         Col  : Natural;\n+         C1   : Character;\n+         C2   : Character;\n+\n+      begin\n+         Reset (Outfile_1, In_File);\n+         Reset (Outfile_2, In_File);\n+\n+         --  Loop to compare the two files\n+\n+         Line := 1;\n+         Col  := 1;\n+         loop\n+            C1 := Get_Char (Outfile_1);\n+            C2 := Get_Char (Outfile_2);\n+            exit when C1 = EOF or else C1 /= C2;\n+\n+            if C1 = LF then\n+               Line := Line + 1;\n+               Col  := 1;\n+            else\n+               Col := Col + 1;\n+            end if;\n+         end loop;\n+\n+         --  If we reached the end of file, then the files were identical,\n+         --  otherwise, we have a failure in the comparison.\n+\n+         if C1 = EOF then\n+            --  Success: exit silently\n+\n+            null;\n+\n+         else\n+            Ada.Text_IO.Put_Line\n+              (Argument (1) & \": failure, files log1 and log2 differ at line\"\n+               & Line'Img & \" column\" & Col'Img);\n+         end if;\n+      end Compare_Files;\n+   end Process;\n+\n+exception\n+   when Stop =>\n+      null;\n+end ALFA_Test;"}, {"sha": "026837c7afa4e04986e73beab2e86e0abe0926b6", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -55,6 +55,8 @@ package body ALI is\n       'X'    => True,   -- xref\n       'S'    => True,   -- specific dispatching\n       'Y'    => True,   -- limited_with\n+      'C'    => True,   -- SCO information\n+      'F'    => True,   -- ALFA information\n       others => False);\n \n    --------------------\n@@ -2436,9 +2438,10 @@ package body ALI is\n \n       --  Here after dealing with xref sections\n \n-      if C /= EOF and then C /= 'X' then\n-         Fatal_Error;\n-      end if;\n+      --  Ignore remaining lines, which belong to an additional section of the\n+      --  ALI file not considered here (like SCO or ALFA).\n+\n+      Check_Unknown_Line;\n \n       return Id;\n "}, {"sha": "af994c1decddde0fbd2922d0731f3c6a5d879a00", "filename": "gcc/ada/gcc-interface/Make-lang.in", "status": "modified", "additions": 1080, "deletions": 1030, "changes": 2110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgcc-interface%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2FMake-lang.in?ref=56e941863ba558a7a3426c686d6e5c08eefca90e"}, {"sha": "f651af5afe37974b9c98b9bb61bf0eed052f1e26", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -713,6 +713,10 @@ enumerate_modes (void (*f) (const char *, int, int, int, int, int, int))\n \t{\n \t  const struct real_format *fmt = REAL_MODE_FORMAT (inner_mode);\n \n+\t  /* ??? Cope with the ghost XFmode of the ARM port.  */\n+\t  if (!fmt)\n+\t    continue;\n+\n \t  if (fmt->b == 2)\n \t    digs = (fmt->p - 1) * 1233 / 4096; /* scale by log (2) */\n "}, {"sha": "95a0f94008b4f481115fe0c9772235cc8970ffcd", "filename": "gcc/ada/get_alfa.adb", "status": "added", "additions": 460, "deletions": 0, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fget_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fget_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_alfa.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,460 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             G E T _ A L F A                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with ALFA;  use ALFA;\n+with Types; use Types;\n+\n+with Ada.IO_Exceptions; use Ada.IO_Exceptions;\n+\n+procedure Get_ALFA is\n+   C    : Character;\n+\n+   use ASCII;\n+   --  For CR/LF\n+\n+   Cur_File : Nat;\n+   --  Dependency number for the current file\n+\n+   Cur_Scope : Nat;\n+   --  Scope number for the current scope entity\n+\n+   Cur_File_Idx : File_Index;\n+   --  Index in ALFA_File_Table of the current file\n+\n+   Cur_Scope_Idx : Scope_Index;\n+   --  Index in ALFA_Scope_Table of the current scope\n+\n+   Name_Str : String (1 .. 32768);\n+   Name_Len : Natural := 0;\n+   --  Local string used to store name of File/entity scanned as\n+   --  Name_Str (1 .. Name_Len).\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function At_EOL return Boolean;\n+   --  Skips any spaces, then checks if we are the end of a line. If so,\n+   --  returns True (but does not skip over the EOL sequence). If not,\n+   --  then returns False.\n+\n+   procedure Check (C : Character);\n+   --  Checks that file is positioned at given character, and if so skips past\n+   --  it, If not, raises Data_Error.\n+\n+   function Get_Nat return Nat;\n+   --  On entry the file is positioned to a digit. On return, the file is\n+   --  positioned past the last digit, and the returned result is the decimal\n+   --  value read. Data_Error is raised for overflow (value greater than\n+   --  Int'Last), or if the initial character is not a digit.\n+\n+   procedure Get_Name;\n+   --  On entry the file is positioned to a name. On return, the file is\n+   --  positioned past the last character, and the name scanned is returned in\n+   --  Name_Str (1 .. Name_Len).\n+\n+   procedure Skip_EOL;\n+   --  Called with the current character about to be read being LF or CR. Skips\n+   --  past CR/LF characters until either a non-CR/LF character is found, or\n+   --  the end of file is encountered.\n+\n+   procedure Skip_Spaces;\n+   --  Skips zero or more spaces at the current position, leaving the file\n+   --  positioned at the first non-blank character (or Types.EOF).\n+\n+   ------------\n+   -- At_EOL --\n+   ------------\n+\n+   function At_EOL return Boolean is\n+   begin\n+      Skip_Spaces;\n+      return Nextc = CR or else Nextc = LF;\n+   end At_EOL;\n+\n+   -----------\n+   -- Check --\n+   -----------\n+\n+   procedure Check (C : Character) is\n+   begin\n+      if Nextc = C then\n+         Skipc;\n+      else\n+         raise Data_Error;\n+      end if;\n+   end Check;\n+\n+   -------------\n+   -- Get_Nat --\n+   -------------\n+\n+   function Get_Nat return Nat is\n+      Val : Nat;\n+      C   : Character;\n+\n+   begin\n+      C := Nextc;\n+      Val := 0;\n+\n+      if C not in '0' .. '9' then\n+         raise Data_Error;\n+      end if;\n+\n+      --  Loop to read digits of integer value\n+\n+      loop\n+         declare\n+            pragma Unsuppress (Overflow_Check);\n+         begin\n+            Val := Val * 10 + (Character'Pos (C) - Character'Pos ('0'));\n+         end;\n+\n+         Skipc;\n+         C := Nextc;\n+\n+         exit when C not in '0' .. '9';\n+      end loop;\n+\n+      return Val;\n+\n+   exception\n+      when Constraint_Error =>\n+         raise Data_Error;\n+   end Get_Nat;\n+\n+   --------------\n+   -- Get_Name --\n+   --------------\n+\n+   procedure Get_Name is\n+      N : Integer;\n+\n+   begin\n+      N := 0;\n+      while Nextc > ' ' loop\n+         N := N + 1;\n+         Name_Str (N) := Getc;\n+      end loop;\n+\n+      Name_Len := N;\n+   end Get_Name;\n+\n+   --------------\n+   -- Skip_EOL --\n+   --------------\n+\n+   procedure Skip_EOL is\n+      C : Character;\n+\n+   begin\n+      loop\n+         Skipc;\n+         C := Nextc;\n+         exit when C /= LF and then C /= CR;\n+\n+         if C = ' ' then\n+            Skip_Spaces;\n+            C := Nextc;\n+            exit when C /= LF and then C /= CR;\n+         end if;\n+      end loop;\n+   end Skip_EOL;\n+\n+   -----------------\n+   -- Skip_Spaces --\n+   -----------------\n+\n+   procedure Skip_Spaces is\n+   begin\n+      while Nextc = ' ' loop\n+         Skipc;\n+      end loop;\n+   end Skip_Spaces;\n+\n+--  Start of processing for Get_ALFA\n+\n+begin\n+   Initialize_ALFA_Tables;\n+\n+   Cur_File      := 0;\n+   Cur_Scope     := 0;\n+   Cur_File_Idx  := 1;\n+   Cur_Scope_Idx := 0;\n+\n+   --  Loop through lines of ALFA information\n+\n+   while Nextc = 'F' loop\n+      Skipc;\n+\n+      C := Getc;\n+\n+      --  Make sure first line is a File line\n+\n+      if ALFA_File_Table.Last = 0 and then C /= 'D' then\n+         raise Data_Error;\n+      end if;\n+\n+      --  Otherwise dispatch on type of line\n+\n+      case C is\n+\n+         --  Header entry for scope section\n+\n+         when 'D' =>\n+\n+            --  Complete previous entry if any\n+\n+            if ALFA_File_Table.Last /= 0 then\n+               ALFA_File_Table.Table (ALFA_File_Table.Last).To_Scope :=\n+                 ALFA_Scope_Table.Last;\n+            end if;\n+\n+            --  Scan out dependency number and file name\n+\n+            Skip_Spaces;\n+            Cur_File := Get_Nat;\n+            Skip_Spaces;\n+            Get_Name;\n+\n+            --  Make new File table entry (will fill in To_Scope later)\n+\n+            ALFA_File_Table.Append (\n+              (File_Name  => new String'(Name_Str (1 .. Name_Len)),\n+               File_Num   => Cur_File,\n+               From_Scope => ALFA_Scope_Table.Last + 1,\n+               To_Scope   => 0));\n+\n+            --  Initialize counter for scopes\n+\n+            Cur_Scope := 1;\n+\n+         --  Scope entry\n+\n+         when 'S' =>\n+            declare\n+               Scope : Nat;\n+               Line  : Nat;\n+               Col   : Nat;\n+               Typ   : Character;\n+\n+            begin\n+               --  Scan out location\n+\n+               Skip_Spaces;\n+               Check ('.');\n+               Scope := Get_Nat;\n+               Check (' ');\n+               Line  := Get_Nat;\n+               Typ   := Getc;\n+               Col   := Get_Nat;\n+\n+               pragma Assert (Scope = Cur_Scope);\n+               pragma Assert         (Typ = 'K'\n+                              or else Typ = 'V'\n+                              or else Typ = 'U');\n+\n+               --  Scan out scope entity name\n+\n+               Skip_Spaces;\n+               Get_Name;\n+\n+               --  Make new scope table entry (will fill in From_Xref and\n+               --  To_Xref later). Initial range (From_Xref .. To_Xref) is\n+               --  empty for scopes without entities.\n+\n+               ALFA_Scope_Table.Append (\n+                 (Scope_Entity => Empty,\n+                  Scope_Name   => new String'(Name_Str (1 .. Name_Len)),\n+                  File_Num     => Cur_File,\n+                  Scope_Num    => Cur_Scope,\n+                  Line         => Line,\n+                  Stype        => Typ,\n+                  Col          => Col,\n+                  From_Xref    => 1,\n+                  To_Xref      => 0));\n+            end;\n+\n+            --  Update counter for scopes\n+\n+            Cur_Scope := Cur_Scope + 1;\n+\n+         --  Header entry for cross-ref section\n+\n+         when 'X' =>\n+\n+            --  Scan out dependency number and file name (ignored)\n+\n+            Skip_Spaces;\n+            Cur_File := Get_Nat;\n+            Skip_Spaces;\n+            Get_Name;\n+\n+            --  Update component From_Xref of current file if first reference\n+            --  in this file.\n+\n+            while ALFA_File_Table.Table (Cur_File_Idx).File_Num /= Cur_File\n+            loop\n+               Cur_File_Idx := Cur_File_Idx + 1;\n+            end loop;\n+\n+            --  Scan out scope entity number and entity name (ignored)\n+\n+            Skip_Spaces;\n+            Check ('.');\n+            Cur_Scope := Get_Nat;\n+            Skip_Spaces;\n+            Get_Name;\n+\n+            --  Update component To_Xref of previous scope\n+\n+            if Cur_Scope_Idx /= 0 then\n+               ALFA_Scope_Table.Table (Cur_Scope_Idx).To_Xref :=\n+                 ALFA_Xref_Table.Last;\n+            end if;\n+\n+            --  Update component From_Xref of current scope\n+\n+            Cur_Scope_Idx := ALFA_File_Table.Table (Cur_File_Idx).From_Scope;\n+\n+            while ALFA_Scope_Table.Table (Cur_Scope_Idx).Scope_Num /= Cur_Scope\n+            loop\n+               Cur_Scope_Idx := Cur_Scope_Idx + 1;\n+            end loop;\n+\n+            ALFA_Scope_Table.Table (Cur_Scope_Idx).From_Xref :=\n+              ALFA_Xref_Table.Last + 1;\n+\n+         --  Cross reference entry\n+\n+         when ' ' =>\n+            declare\n+               XR_Entity      : String_Ptr;\n+               XR_Entity_Line : Nat;\n+               XR_Entity_Col  : Nat;\n+\n+               XR_File        : Nat;\n+               --  Keeps track of the current file (changed by nn|)\n+\n+               XR_Scope       : Nat;\n+               --  Keeps track of the current scope (changed by nn:)\n+\n+            begin\n+               XR_File  := Cur_File;\n+               XR_Scope := Cur_Scope;\n+\n+               XR_Entity_Line := Get_Nat;\n+               Check (' ');\n+               XR_Entity_Col  := Get_Nat;\n+\n+               Skip_Spaces;\n+               Get_Name;\n+               XR_Entity := new String'(Name_Str (1 .. Name_Len));\n+\n+               --  Initialize to scan items on one line\n+\n+               Skip_Spaces;\n+\n+               --  Loop through cross-references for this entity\n+\n+               loop\n+\n+                  declare\n+                     Line  : Nat;\n+                     Col   : Nat;\n+                     N     : Nat;\n+                     Rtype : Character;\n+\n+                  begin\n+                     Skip_Spaces;\n+\n+                     if At_EOL then\n+                        Skip_EOL;\n+                        exit when Nextc /= '.';\n+                        Skipc;\n+                     end if;\n+\n+                     if Nextc = '.' then\n+                        Skipc;\n+                        XR_Scope := Get_Nat;\n+                        Check (':');\n+\n+                     else\n+                        N := Get_Nat;\n+\n+                        if Nextc = '|' then\n+                           XR_File := N;\n+                           Skipc;\n+\n+                        else\n+                           Line  := N;\n+                           Rtype := Getc;\n+                           Col   := Get_Nat;\n+\n+                           pragma Assert         (Rtype = 'r'\n+                                          or else Rtype = 'm'\n+                                          or else Rtype = 's');\n+\n+                           ALFA_Xref_Table.Append (\n+                             (Entity_Name => XR_Entity,\n+                              Entity_Line => XR_Entity_Line,\n+                              Entity_Col  => XR_Entity_Col,\n+                              File_Num    => XR_File,\n+                              Scope_Num   => XR_Scope,\n+                              Line        => Line,\n+                              Rtype       => Rtype,\n+                              Col         => Col));\n+                        end if;\n+                     end if;\n+                  end;\n+               end loop;\n+            end;\n+\n+         --  No other ALFA lines are possible\n+\n+         when others =>\n+            raise Data_Error;\n+      end case;\n+\n+      --  For cross reference lines, the end-of-line character has been skipped\n+      --  already.\n+\n+      if C /= ' ' then\n+         Skip_EOL;\n+      end if;\n+   end loop;\n+\n+   --  Here with all Xrefs stored, complete last entries in File and Scope\n+   --  tables.\n+\n+   if ALFA_File_Table.Last /= 0 then\n+      ALFA_File_Table.Table (ALFA_File_Table.Last).To_Scope :=\n+        ALFA_Scope_Table.Last;\n+   end if;\n+\n+   if Cur_Scope_Idx /= 0 then\n+      ALFA_Scope_Table.Table (Cur_Scope_Idx).To_Xref := ALFA_Xref_Table.Last;\n+   end if;\n+end Get_ALFA;"}, {"sha": "a4660321a65bb968f803be7c6985c5c653bc57d5", "filename": "gcc/ada/get_alfa.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fget_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fget_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fget_alfa.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             G E T _ A L F A                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the function used to read ALFA information from an\n+--  ALI file and populate the tables defined in package ALFA with the result.\n+\n+generic\n+   --  These subprograms provide access to the ALI file. Locating, opening and\n+   --  providing access to the ALI file is the callers' responsibility.\n+\n+   with function Getc return Character is <>;\n+   --  Get next character, positioning the ALI file ready to read the following\n+   --  character (equivalent to calling Nextc, then Skipc). If the end of file\n+   --  is encountered, the value Types.EOF is returned.\n+\n+   with function Nextc return Character is <>;\n+   --  Look at the next character, and return it, leaving the position of the\n+   --  file unchanged, so that a subsequent call to Getc or Nextc will return\n+   --  this same character. If the file is positioned at the end of file, then\n+   --  Types.EOF is returned.\n+\n+   with procedure Skipc is <>;\n+   --  Skip past the current character (which typically was read with Nextc),\n+   --  and position to the next character, which will be returned by the next\n+   --  call to Getc or Nextc.\n+\n+procedure Get_ALFA;\n+--  Load ALFA information from ALI file text format into internal ALFA tables\n+--  (ALFA.ALFA_Xref_Table, ALFA.ALFA_Scope_Table and ALFA.ALFA_File_Table). On\n+--  entry the input file is positioned to the initial 'F' of the first ALFA\n+--  line in the ALI file. On return, the file is positioned either to the end\n+--  of file, or to the first character of the line following the ALFA\n+--  information (which will never start with an 'F').\n+--\n+--  If a format error is detected in the input, then an exception is raised\n+--  (Ada.IO_Exceptions.Data_Error), with the file positioned to the error."}, {"sha": "e0521f44d0b25eeb4c31924f2e28a589e9a1122d", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -4006,7 +4006,7 @@ See @ref{Stack Overflow Checking} for details.\n @item -fstack-usage\n @cindex @option{-fstack-usage} (@command{gcc})\n Makes the compiler output stack usage information for the program, on a\n-per-function basis. See @ref{Static Stack Usage Analysis} for details.\n+per-subprogram basis. See @ref{Static Stack Usage Analysis} for details.\n \n @item -fcallgraph-info@r{[}=su@r{]}\n @cindex @option{-fcallgraph-info} (@command{gcc})\n@@ -5823,9 +5823,14 @@ Similarly, @option{^-Wuninitialized^WARNINGS=UNINITIALIZED^} activates\n the back end warning for uninitialized variables. This switch must be\n used in conjunction with an optimization level greater than zero.\n \n+@item -Wstack-usage=@var{len}\n+@cindex @option{-Wstack-usage}\n+Warn if the stack usage of a subprogram might be larger than @var{len} bytes.\n+See @ref{Static Stack Usage Analysis} for details.\n+\n @item ^-Wall^/ALL_BACK_END_WARNINGS^\n @cindex @option{-Wall}\n-This switch enables all the above warnings from the @option{GCC} back end.\n+This switch enables most warnings from the @option{GCC} back end.\n The code generator detects a number of warning situations that are missed\n by the @option{GNAT} front end, and this switch can be used to activate them.\n The use of this switch also sets the default front end warning mode to\n@@ -17170,6 +17175,10 @@ of the function stack analysis. When it is qualified with  @code{bounded}, it\n means that the second field is a reliable maximum of the function stack\n utilization.\n \n+A unit compiled with @option{-Wstack-usage} will issue a warning for each\n+subprogram whose stack usage might be larger than the specified amount of\n+bytes.  The wording is in keeping with the qualifier documented above.\n+\n @node Dynamic Stack Usage Analysis\n @section Dynamic Stack Usage Analysis\n "}, {"sha": "eb33a1a207f3782f854953a2d60fa8ed9d7b4674", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -32,6 +32,7 @@ with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n with Lib.Util; use Lib.Util;\n with Lib.Xref; use Lib.Xref;\n+               use Lib.Xref.ALFA;\n with Nlists;   use Nlists;\n with Gnatvsn;  use Gnatvsn;\n with Opt;      use Opt;\n@@ -1293,19 +1294,22 @@ package body Lib.Writ is\n \n       --  Output cross-references\n \n-      Output_References;\n+      if Opt.Xref_Active then\n+         Output_References;\n+      end if;\n \n       --  Output SCO information if present\n \n       if Generate_SCO then\n          SCO_Output;\n       end if;\n \n-      --  Output references by subprogram\n+      --  Output ALFA information if needed\n \n-      if ALFA_Mode then\n-         Write_Info_EOL;\n-         Output_Local_References;\n+      if Opt.Xref_Active and then ALFA_Mode then\n+         Collect_ALFA (Sdep_Table => Sdep_Table,\n+                       Num_Sdep   => Num_Sdep);\n+         Output_ALFA;\n       end if;\n \n       --  Output final blank line and we are done. This final blank line is"}, {"sha": "fa75a4dd547469e521e030cbd2b18a3c7486a409", "filename": "gcc/ada/lib-writ.ads", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-writ.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-writ.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -709,6 +709,13 @@ package Lib.Writ is\n    --  The Source Coverage Obligation (SCO) information follows the cross-\n    --  reference data. See the spec of Par_SCO for full details of the format.\n \n+   ----------------------\n+   -- ALFA Information --\n+   ----------------------\n+\n+   --  The ALFA information follows the SCO information. See the spec of Alfa\n+   --  for full details of the format.\n+\n    ----------------------\n    -- Global Variables --\n    ----------------------"}, {"sha": "a5dca53ab8a5c3b52f75c118ca03be5c04004e94", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "added", "additions": 938, "deletions": 0, "changes": 938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,938 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                        L I B . X R E F . A L F A                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with ALFA;        use ALFA;\n+with Einfo;       use Einfo;\n+with Put_ALFA;\n+with GNAT.HTable;\n+\n+separate (Lib.Xref)\n+package body ALFA is\n+\n+   ---------------------\n+   -- Local Constants --\n+   ---------------------\n+\n+   --  True for each entity kind used in ALFA\n+   ALFA_Entities : constant array (Entity_Kind) of Boolean :=\n+     (E_Void                                       => False,\n+      E_Variable                                   => True,\n+      E_Component                                  => False,\n+      E_Constant                                   => True,\n+      E_Discriminant                               => False,\n+\n+      E_Loop_Parameter                             => True,\n+      E_In_Parameter                               => True,\n+      E_Out_Parameter                              => True,\n+      E_In_Out_Parameter                           => True,\n+      E_Generic_In_Out_Parameter                   => False,\n+\n+      E_Generic_In_Parameter                       => False,\n+      E_Named_Integer                              => False,\n+      E_Named_Real                                 => False,\n+      E_Enumeration_Type                           => False,\n+      E_Enumeration_Subtype                        => False,\n+\n+      E_Signed_Integer_Type                        => False,\n+      E_Signed_Integer_Subtype                     => False,\n+      E_Modular_Integer_Type                       => False,\n+      E_Modular_Integer_Subtype                    => False,\n+      E_Ordinary_Fixed_Point_Type                  => False,\n+\n+      E_Ordinary_Fixed_Point_Subtype               => False,\n+      E_Decimal_Fixed_Point_Type                   => False,\n+      E_Decimal_Fixed_Point_Subtype                => False,\n+      E_Floating_Point_Type                        => False,\n+      E_Floating_Point_Subtype                     => False,\n+\n+      E_Access_Type                                => False,\n+      E_Access_Subtype                             => False,\n+      E_Access_Attribute_Type                      => False,\n+      E_Allocator_Type                             => False,\n+      E_General_Access_Type                        => False,\n+\n+      E_Access_Subprogram_Type                     => False,\n+      E_Access_Protected_Subprogram_Type           => False,\n+      E_Anonymous_Access_Subprogram_Type           => False,\n+      E_Anonymous_Access_Protected_Subprogram_Type => False,\n+      E_Anonymous_Access_Type                      => False,\n+\n+      E_Array_Type                                 => False,\n+      E_Array_Subtype                              => False,\n+      E_String_Type                                => False,\n+      E_String_Subtype                             => False,\n+      E_String_Literal_Subtype                     => False,\n+\n+      E_Class_Wide_Type                            => False,\n+      E_Class_Wide_Subtype                         => False,\n+      E_Record_Type                                => False,\n+      E_Record_Subtype                             => False,\n+      E_Record_Type_With_Private                   => False,\n+\n+      E_Record_Subtype_With_Private                => False,\n+      E_Private_Type                               => False,\n+      E_Private_Subtype                            => False,\n+      E_Limited_Private_Type                       => False,\n+      E_Limited_Private_Subtype                    => False,\n+\n+      E_Incomplete_Type                            => False,\n+      E_Incomplete_Subtype                         => False,\n+      E_Task_Type                                  => False,\n+      E_Task_Subtype                               => False,\n+      E_Protected_Type                             => False,\n+\n+      E_Protected_Subtype                          => False,\n+      E_Exception_Type                             => False,\n+      E_Subprogram_Type                            => False,\n+      E_Enumeration_Literal                        => False,\n+      E_Function                                   => True,\n+\n+      E_Operator                                   => True,\n+      E_Procedure                                  => True,\n+      E_Entry                                      => False,\n+      E_Entry_Family                               => False,\n+      E_Block                                      => False,\n+\n+      E_Entry_Index_Parameter                      => False,\n+      E_Exception                                  => False,\n+      E_Generic_Function                           => False,\n+      E_Generic_Package                            => False,\n+      E_Generic_Procedure                          => False,\n+\n+      E_Label                                      => False,\n+      E_Loop                                       => False,\n+      E_Return_Statement                           => False,\n+      E_Package                                    => False,\n+\n+      E_Package_Body                               => False,\n+      E_Protected_Object                           => False,\n+      E_Protected_Body                             => False,\n+      E_Task_Body                                  => False,\n+      E_Subprogram_Body                            => False);\n+\n+   --  True for each reference type used in ALFA\n+   ALFA_References : constant array (Character) of Boolean :=\n+     ('m' => True,\n+      'r' => True,\n+      's' => True,\n+      others => False);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Add_ALFA_File (U : Unit_Number_Type; D : Nat);\n+   --  Add file U and all scopes in U to the tables ALFA_File_Table and\n+   --  ALFA_Scope_Table.\n+\n+   procedure Add_ALFA_Scope (N : Node_Id);\n+   --  Add scope N to the table ALFA_Scope_Table\n+\n+   procedure Add_ALFA_Xrefs;\n+   --  Filter table Xrefs to add all references used in ALFA to the table\n+   --  ALFA_Xref_Table.\n+\n+   procedure Traverse_Declarations_Or_Statements  (L : List_Id);\n+   procedure Traverse_Handled_Statement_Sequence  (N : Node_Id);\n+   procedure Traverse_Package_Body                (N : Node_Id);\n+   procedure Traverse_Package_Declaration         (N : Node_Id);\n+   procedure Traverse_Subprogram_Body             (N : Node_Id);\n+   --  Traverse the corresponding construct, generating ALFA scope table\n+   --  entries.\n+\n+   -------------------\n+   -- Add_ALFA_File --\n+   -------------------\n+\n+   procedure Add_ALFA_File (U : Unit_Number_Type; D : Nat) is\n+      Lu   : Node_Id;\n+      From : Scope_Index;\n+\n+      S : constant Source_File_Index := Source_Index (U);\n+   begin\n+      --  Source file could be inexistant as a result of an error, if option\n+      --  gnatQ is used.\n+\n+      if S = No_Source_File then\n+         return;\n+      end if;\n+\n+      From := ALFA_Scope_Table.Last + 1;\n+\n+      --  Get Unit (checking case of subunit)\n+\n+      Lu := Unit (Cunit (U));\n+\n+      if Nkind (Lu) = N_Subunit then\n+         Lu := Proper_Body (Lu);\n+      end if;\n+\n+      --  Traverse the unit\n+\n+      if Nkind (Lu) = N_Subprogram_Body then\n+         Traverse_Subprogram_Body (Lu);\n+\n+      elsif Nkind (Lu) = N_Subprogram_Declaration then\n+         Add_ALFA_Scope (Lu);\n+\n+      elsif Nkind (Lu) = N_Package_Declaration then\n+         Traverse_Package_Declaration (Lu);\n+\n+      elsif Nkind (Lu) = N_Package_Body then\n+         Traverse_Package_Body (Lu);\n+\n+      --  ??? TBD\n+\n+      elsif Nkind (Lu) = N_Generic_Package_Declaration then\n+         null;\n+\n+      --  ??? TBD\n+\n+      elsif Nkind (Lu) in N_Generic_Instantiation then\n+         null;\n+\n+      --  All other cases of compilation units (e.g. renamings), generate\n+      --  no ALFA information.\n+\n+      else\n+         null;\n+      end if;\n+\n+      --  Update scope numbers\n+\n+      for S in From .. ALFA_Scope_Table.Last loop\n+         declare\n+            E : Entity_Id renames ALFA_Scope_Table.Table (S).Scope_Entity;\n+         begin\n+            if Lib.Get_Source_Unit (E) = U then\n+               ALFA_Scope_Table.Table (S).Scope_Num := Int (S - From) + 1;\n+               ALFA_Scope_Table.Table (S).File_Num  := D;\n+\n+            else\n+               --  Remove scope S which is not located in unit U, for example\n+               --  for scope inside generics that get instantiated.\n+\n+               for J in S .. ALFA_Scope_Table.Last - 1 loop\n+                  ALFA_Scope_Table.Table (J) := ALFA_Scope_Table.Table (J + 1);\n+               end loop;\n+               ALFA_Scope_Table.Set_Last (ALFA_Scope_Table.Last - 1);\n+            end if;\n+         end;\n+      end loop;\n+\n+      --  Make entry for new file in file table\n+\n+      Get_Name_String (Reference_Name (S));\n+\n+      ALFA_File_Table.Append (\n+        (File_Name  => new String'(Name_Buffer (1 .. Name_Len)),\n+         File_Num   => D,\n+         From_Scope => From,\n+         To_Scope   => ALFA_Scope_Table.Last));\n+   end Add_ALFA_File;\n+\n+   --------------------\n+   -- Add_ALFA_Scope --\n+   --------------------\n+\n+   procedure Add_ALFA_Scope (N : Node_Id) is\n+      E   : constant Entity_Id  := Defining_Entity (N);\n+      Loc : constant Source_Ptr := Sloc (E);\n+      Typ : Character;\n+\n+   begin\n+      --  Ignore scopes without a proper location\n+\n+      if Sloc (N) = No_Location then\n+         return;\n+      end if;\n+\n+      case Ekind (E) is\n+         when E_Function =>\n+            Typ := 'V';\n+\n+         when E_Procedure =>\n+            Typ := 'U';\n+\n+         when E_Subprogram_Body =>\n+            declare\n+               Spec : Node_Id;\n+\n+            begin\n+               Spec := Parent (E);\n+\n+               if Nkind (Spec) = N_Defining_Program_Unit_Name then\n+                  Spec := Parent (Spec);\n+               end if;\n+\n+               if Nkind (Spec) = N_Function_Specification then\n+                  Typ := 'V';\n+               else\n+                  pragma Assert\n+                    (Nkind (Spec) = N_Procedure_Specification);\n+                  Typ := 'U';\n+               end if;\n+            end;\n+\n+         when E_Package | E_Package_Body =>\n+            Typ := 'K';\n+\n+         when E_Void =>\n+            --  Compilation of prj-attr.adb with -gnatn creates a node with\n+            --  entity E_Void for the package defined at a-charac.ads16:13\n+\n+            --  ??? TBD\n+\n+            return;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+\n+      --  File_Num and Scope_Num are filled later. From_Xref and To_Xref are\n+      --  filled even later, but are initialized to represent an empty range.\n+\n+      ALFA_Scope_Table.Append (\n+        (Scope_Name   => new String'(Exact_Source_Name (Sloc (E))),\n+         File_Num     => 0,\n+         Scope_Num    => 0,\n+         Line         => Nat (Get_Logical_Line_Number (Loc)),\n+         Stype        => Typ,\n+         Col          => Nat (Get_Column_Number (Loc)),\n+         From_Xref    => 1,\n+         To_Xref      => 0,\n+         Scope_Entity => E));\n+   end Add_ALFA_Scope;\n+\n+   --------------------\n+   -- Add_ALFA_Xrefs --\n+   --------------------\n+\n+   procedure Add_ALFA_Xrefs is\n+      Prev_Scope_Idx  : Scope_Index;\n+      Cur_Scope_Idx   : Scope_Index;\n+      From_Xref_Idx   : Xref_Index;\n+      Cur_Entity      : Entity_Id;\n+      Cur_Entity_Name : String_Ptr;\n+\n+      package Scopes is\n+         No_Scope : constant Nat := 0;\n+         function Get_Scope_Num (N : Entity_Id) return Nat;\n+         procedure Set_Scope_Num (N : Entity_Id; Num : Nat);\n+      end Scopes;\n+\n+      package body Scopes is\n+         type Scope is record\n+            Num    : Nat;\n+            Entity : Entity_Id;\n+         end record;\n+\n+         type Scope_Hashed is range 0 .. 255;\n+\n+         function Scope_Hash (E : Entity_Id) return Scope_Hashed;\n+\n+         function Scope_Hash (E : Entity_Id) return Scope_Hashed is\n+            Value  : constant Int := Int (E);\n+            Modulo : constant Int := Int (Scope_Hashed'Last) + 1;\n+         begin\n+            return Scope_Hashed (Value - (Value / Modulo) * Modulo);\n+         end Scope_Hash;\n+\n+         package Scopes is new GNAT.HTable.Simple_HTable\n+           (Header_Num => Scope_Hashed,\n+            Element    => Scope,\n+            No_Element => (Num => No_Scope, Entity => Empty),\n+            Key        => Entity_Id,\n+            Hash       => Scope_Hash,\n+            Equal      => \"=\");\n+\n+         function Get_Scope_Num (N : Entity_Id) return Nat is\n+         begin\n+            return Scopes.Get (N).Num;\n+         end Get_Scope_Num;\n+\n+         procedure Set_Scope_Num (N : Entity_Id; Num : Nat) is\n+         begin\n+            Scopes.Set (K => N, E => Scope'(Num => Num, Entity => N));\n+         end Set_Scope_Num;\n+      end Scopes;\n+\n+      use Scopes;\n+\n+      Nrefs : Nat := Xrefs.Last;\n+      --  Number of references in table. This value may get reset (reduced)\n+      --  when we eliminate duplicate reference entries as well as references\n+      --  not suitable for local cross-references.\n+\n+      Rnums : array (0 .. Nrefs) of Nat;\n+      --  This array contains numbers of references in the Xrefs table. This\n+      --  list is sorted in output order. The extra 0'th entry is convenient\n+      --  for the call to sort. When we sort the table, we move the entries in\n+      --  Rnums around, but we do not move the original table entries.\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean;\n+      --  Comparison function for Sort call\n+\n+      procedure Move (From : Natural; To : Natural);\n+      --  Move procedure for Sort call\n+\n+      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n+\n+      --------\n+      -- Lt --\n+      --------\n+\n+      function Lt (Op1, Op2 : Natural) return Boolean is\n+         T1 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op1)));\n+         T2 : constant Xref_Entry := Xrefs.Table (Rnums (Nat (Op2)));\n+\n+      begin\n+         --  First test: if entity is in different unit, sort by unit. Notice\n+         --  that we use Ent_Scope_File rather than Eun, as Eun may refer to\n+         --  the file where the generic scope is defined, and it may be\n+         --  different from the file where the enclosing scope is defined. It\n+         --  is the latter which matters for a correct order here.\n+\n+         if T1.Ent_Scope_File /= T2.Ent_Scope_File then\n+            return Dependency_Num (T1.Ent_Scope_File) <\n+              Dependency_Num (T2.Ent_Scope_File);\n+\n+         --  Second test: within same unit, sort by location of the scope of\n+         --  the entity definition.\n+\n+         elsif Get_Scope_Num (T1.Ent_Scope) /=\n+           Get_Scope_Num (T2.Ent_Scope)\n+         then\n+            return Get_Scope_Num (T1.Ent_Scope) < Get_Scope_Num (T2.Ent_Scope);\n+\n+         --  Third test: within same unit and scope, sort by location of\n+         --  entity definition.\n+\n+         elsif T1.Def /= T2.Def then\n+            return T1.Def < T2.Def;\n+\n+         --  Fourth test: if reference is in same unit as entity definition,\n+         --  sort first.\n+\n+         elsif T1.Lun /= T2.Lun and then T1.Ent_Scope_File = T1.Lun then\n+            return True;\n+         elsif T1.Lun /= T2.Lun and then T2.Ent_Scope_File = T2.Lun then\n+            return False;\n+\n+         --  Fifth test: if reference is in same unit and same scope as entity\n+         --  definition, sort first.\n+\n+         elsif T1.Ent_Scope_File = T1.Lun\n+           and then T1.Ref_Scope /= T2.Ref_Scope\n+           and then T1.Ent_Scope = T1.Ref_Scope\n+         then\n+            return True;\n+         elsif T1.Ent_Scope_File = T1.Lun\n+           and then T1.Ref_Scope /= T2.Ref_Scope\n+           and then T2.Ent_Scope = T2.Ref_Scope\n+         then\n+            return False;\n+\n+         --  Sixth test: for same entity, sort by reference location unit\n+\n+         elsif T1.Lun /= T2.Lun then\n+            return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n+\n+         --  Seventh test: for same entity, sort by reference location scope\n+\n+         elsif Get_Scope_Num (T1.Ref_Scope) /=\n+           Get_Scope_Num (T2.Ref_Scope)\n+         then\n+            return Get_Scope_Num (T1.Ref_Scope) < Get_Scope_Num (T2.Ref_Scope);\n+\n+         --  Eighth test: order of location within referencing unit\n+\n+         elsif T1.Loc /= T2.Loc then\n+            return T1.Loc < T2.Loc;\n+\n+         --  Finally, for two locations at the same address, we prefer the one\n+         --  that does NOT have the type 'r' so that a modification or\n+         --  extension takes preference, when there are more than one reference\n+         --  at the same location. As a result, in the case of entities that\n+         --  are in-out actuals, the read reference follows the modify\n+         --  reference.\n+\n+         else\n+            return T2.Typ = 'r';\n+         end if;\n+      end Lt;\n+\n+      ----------\n+      -- Move --\n+      ----------\n+\n+      procedure Move (From : Natural; To : Natural) is\n+      begin\n+         Rnums (Nat (To)) := Rnums (Nat (From));\n+      end Move;\n+\n+      --  Start of processing for Add_ALFA_Xrefs\n+   begin\n+\n+      for J in ALFA_Scope_Table.First .. ALFA_Scope_Table.Last loop\n+         Set_Scope_Num (N   => ALFA_Scope_Table.Table (J).Scope_Entity,\n+                        Num => ALFA_Scope_Table.Table (J).Scope_Num);\n+      end loop;\n+\n+      --  Set up the pointer vector for the sort\n+\n+      for J in 1 .. Nrefs loop\n+         Rnums (J) := J;\n+      end loop;\n+\n+      --  Eliminate entries not appropriate for ALFA. Should be prior to\n+      --  sorting cross-references, as it discards useless references which do\n+      --  not have a proper format for the comparison function (like no\n+      --  location).\n+\n+      Eliminate_Before_Sort : declare\n+         NR : Nat;\n+\n+         function Is_ALFA_Scope (E : Entity_Id) return Boolean;\n+         --  Return whether the entity or reference scope is adequate\n+\n+         -------------------\n+         -- Is_ALFA_Scope --\n+         -------------------\n+\n+         function Is_ALFA_Scope (E : Entity_Id) return Boolean is\n+         begin\n+            return Present (E)\n+              and then not Is_Generic_Unit (E)\n+              and then Renamed_Entity (E) = Empty\n+              and then Get_Scope_Num (E) /= No_Scope;\n+         end Is_ALFA_Scope;\n+\n+         --  Start of processing for Eliminate_Before_Sort\n+      begin\n+\n+         NR    := Nrefs;\n+         Nrefs := 0;\n+\n+         for J in 1 .. NR loop\n+            if ALFA_Entities (Ekind (Xrefs.Table (Rnums (J)).Ent))\n+              and then ALFA_References (Xrefs.Table (Rnums (J)).Typ)\n+              and then Is_ALFA_Scope (Xrefs.Table (Rnums (J)).Ent_Scope)\n+              and then Is_ALFA_Scope (Xrefs.Table (Rnums (J)).Ref_Scope)\n+            then\n+               Nrefs         := Nrefs + 1;\n+               Rnums (Nrefs) := Rnums (J);\n+            end if;\n+         end loop;\n+      end Eliminate_Before_Sort;\n+\n+      --  Sort the references\n+\n+      Sorting.Sort (Integer (Nrefs));\n+\n+      Eliminate_After_Sort : declare\n+         NR    : Nat;\n+\n+         Crloc : Source_Ptr;\n+         --  Current reference location\n+\n+         Prevt : Character;\n+         --  reference kind of previous reference\n+\n+      begin\n+         --  Eliminate duplicate entries\n+\n+         --  We need this test for NR because if we force ALI file generation\n+         --  in case of errors detected, it may be the case that Nrefs is 0, so\n+         --  we should not reset it here\n+\n+         if Nrefs >= 2 then\n+            NR    := Nrefs;\n+            Nrefs := 1;\n+\n+            for J in 2 .. NR loop\n+               if Xrefs.Table (Rnums (J)) /=\n+                 Xrefs.Table (Rnums (Nrefs))\n+               then\n+                  Nrefs := Nrefs + 1;\n+                  Rnums (Nrefs) := Rnums (J);\n+               end if;\n+            end loop;\n+         end if;\n+\n+         --  Eliminate the reference if it is at the same location as the\n+         --  previous one, unless it is a read-reference that indicates that\n+         --  the entity is an in-out actual in a call.\n+\n+         NR    := Nrefs;\n+         Nrefs := 0;\n+         Crloc := No_Location;\n+         Prevt := 'm';\n+\n+         for J in 1 .. NR loop\n+            if Xrefs.Table (Rnums (J)).Loc /= Crloc\n+              or else (Prevt = 'm'\n+                        and then Xrefs.Table (Rnums (J)).Typ = 'r')\n+            then\n+               Crloc         := Xrefs.Table (Rnums (J)).Loc;\n+               Prevt         := Xrefs.Table (Rnums (J)).Typ;\n+               Nrefs         := Nrefs + 1;\n+               Rnums (Nrefs) := Rnums (J);\n+            end if;\n+         end loop;\n+      end Eliminate_After_Sort;\n+\n+      --  Initialize loop\n+\n+      Prev_Scope_Idx := 1;\n+      Cur_Scope_Idx  := 1;\n+      From_Xref_Idx  := 1;\n+      Cur_Entity     := Empty;\n+\n+      if ALFA_Scope_Table.Last /= 0 then\n+         ALFA_Scope_Table.Table (1).From_Xref := 1;\n+      end if;\n+\n+      --  Loop to output references\n+\n+      for Refno in 1 .. Nrefs loop\n+         Add_One_Xref : declare\n+\n+            -----------------------\n+            -- Local Subprograms --\n+            -----------------------\n+\n+            function Cur_Scope return Node_Id;\n+            --  Return the scope entity which corresponds to index\n+            --  Cur_Scope_Idx in table ALFA_Scope_Table.\n+\n+            function Is_Future_Scope_Entity (E : Entity_Id) return Boolean;\n+            --  Check whether entity E is in ALFA_Scope_Table at index\n+            --  Cur_Scope_Idx or higher.\n+\n+            function Is_Past_Scope_Entity (E : Entity_Id) return Boolean;\n+            --  Check whether entity E is in ALFA_Scope_Table at index strictly\n+            --  lower than Cur_Scope_Idx.\n+\n+            ---------------\n+            -- Cur_Scope --\n+            ---------------\n+\n+            function Cur_Scope return Node_Id is\n+            begin\n+               return ALFA_Scope_Table.Table (Cur_Scope_Idx).Scope_Entity;\n+            end Cur_Scope;\n+\n+            ----------------------------\n+            -- Is_Future_Scope_Entity --\n+            ----------------------------\n+\n+            function Is_Future_Scope_Entity (E : Entity_Id) return Boolean is\n+            begin\n+               for J in Cur_Scope_Idx .. ALFA_Scope_Table.Last loop\n+                  if E = ALFA_Scope_Table.Table (J).Scope_Entity then\n+                     return True;\n+                  end if;\n+               end loop;\n+\n+               --  If this assertion fails, this means that the scope which we\n+               --  are looking for has been treated already, which reveals a\n+               --  problem in the order of cross-references.\n+\n+               pragma Assert (not Is_Past_Scope_Entity (E));\n+\n+               return False;\n+            end Is_Future_Scope_Entity;\n+\n+            --------------------------\n+            -- Is_Past_Scope_Entity --\n+            --------------------------\n+\n+            function Is_Past_Scope_Entity (E : Entity_Id) return Boolean is\n+            begin\n+               for J in ALFA_Scope_Table.First .. Cur_Scope_Idx - 1 loop\n+                  if E = ALFA_Scope_Table.Table (J).Scope_Entity then\n+                     return True;\n+                  end if;\n+               end loop;\n+\n+               return False;\n+            end Is_Past_Scope_Entity;\n+\n+            ---------------------\n+            -- Local Variables --\n+            ---------------------\n+\n+            XE  : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n+\n+         begin\n+            --  If this assertion fails, this means that the scope which we\n+            --  are looking for is not in ALFA scope table, which reveals\n+            --  either a problem in the construction of the scope table, or an\n+            --  erroneous scope for the current cross-reference.\n+\n+            pragma Assert (Is_Future_Scope_Entity (XE.Ent_Scope));\n+\n+            if XE.Ent_Scope /= Cur_Scope then\n+               ALFA_Scope_Table.Table (Cur_Scope_Idx).From_Xref :=\n+                 From_Xref_Idx;\n+               From_Xref_Idx := ALFA_Xref_Table.Last + 1;\n+            end if;\n+\n+            while XE.Ent_Scope /= Cur_Scope loop\n+               Cur_Scope_Idx := Cur_Scope_Idx + 1;\n+               pragma Assert (Cur_Scope_Idx <= ALFA_Scope_Table.Last);\n+            end loop;\n+\n+            if Prev_Scope_Idx /= Cur_Scope_Idx\n+              and then ALFA_Xref_Table.Last /= 0\n+            then\n+               ALFA_Scope_Table.Table (Prev_Scope_Idx).To_Xref :=\n+                 ALFA_Xref_Table.Last;\n+               Prev_Scope_Idx := Cur_Scope_Idx;\n+            end if;\n+\n+            if XE.Ent /= Cur_Entity then\n+               Cur_Entity_Name :=\n+                 new String'(Exact_Source_Name (Sloc (XE.Ent)));\n+            end if;\n+\n+            ALFA_Xref_Table.Append (\n+              (Entity_Name => Cur_Entity_Name,\n+               Entity_Line => Int (Get_Logical_Line_Number (XE.Def)),\n+               Entity_Col  => Int (Get_Column_Number (XE.Def)),\n+               File_Num    => Dependency_Num (XE.Lun),\n+               Scope_Num   => Get_Scope_Num (XE.Ref_Scope),\n+               Line        => Int (Get_Logical_Line_Number (XE.Loc)),\n+               Rtype       => XE.Typ,\n+               Col         => Int (Get_Column_Number (XE.Loc))));\n+         end Add_One_Xref;\n+      end loop;\n+\n+      ALFA_Scope_Table.Table (Cur_Scope_Idx).From_Xref := From_Xref_Idx;\n+      ALFA_Scope_Table.Table (Cur_Scope_Idx).To_Xref   := ALFA_Xref_Table.Last;\n+   end Add_ALFA_Xrefs;\n+\n+   ------------------\n+   -- Collect_ALFA --\n+   ------------------\n+\n+   procedure Collect_ALFA (Sdep_Table : Unit_Ref_Table; Num_Sdep : Nat) is\n+   begin\n+      --  Cross-references should have been computed first\n+\n+      pragma Assert (Xrefs.Last /= 0);\n+\n+      Initialize_ALFA_Tables;\n+\n+      --  Generate file and scope ALFA information\n+\n+      for D in 1 .. Num_Sdep loop\n+\n+         --  Ignore file for System\n+\n+         if Units.Table (Sdep_Table (D)).Source_Index /=\n+           System_Source_File_Index\n+         then\n+            Add_ALFA_File (U => Sdep_Table (D), D => D);\n+         end if;\n+      end loop;\n+\n+      --  Generate cross reference ALFA information\n+\n+      Add_ALFA_Xrefs;\n+   end Collect_ALFA;\n+\n+   -----------------------------------------\n+   -- Traverse_Declarations_Or_Statements --\n+   -----------------------------------------\n+\n+   procedure Traverse_Declarations_Or_Statements (L : List_Id) is\n+      N : Node_Id;\n+\n+   begin\n+      --  Loop through statements or declarations\n+\n+      N := First (L);\n+      while Present (N) loop\n+         case Nkind (N) is\n+\n+            --  Package declaration\n+\n+            when N_Package_Declaration =>\n+               Traverse_Package_Declaration (N);\n+\n+            --  Generic package declaration ??? TBD\n+\n+            when N_Generic_Package_Declaration =>\n+               null;\n+\n+            --  Package body\n+\n+            when N_Package_Body =>\n+               if Ekind (Defining_Entity (N)) /= E_Generic_Package then\n+                  Traverse_Package_Body (N);\n+               end if;\n+\n+            --  Subprogram declaration\n+\n+            when N_Subprogram_Declaration =>\n+               Add_ALFA_Scope (N);\n+\n+            --  Generic subprogram declaration ??? TBD\n+\n+            when N_Generic_Subprogram_Declaration =>\n+               null;\n+\n+            --  Subprogram body\n+\n+            when N_Subprogram_Body =>\n+               if not Is_Generic_Subprogram (Defining_Entity (N)) then\n+                  Traverse_Subprogram_Body (N);\n+               end if;\n+\n+            --  Block statement\n+\n+            when N_Block_Statement =>\n+               Traverse_Declarations_Or_Statements (Declarations (N));\n+               Traverse_Handled_Statement_Sequence\n+                 (Handled_Statement_Sequence (N));\n+\n+            when N_If_Statement =>\n+\n+               --  Traverse the statements in the THEN part\n+\n+               Traverse_Declarations_Or_Statements (Then_Statements (N));\n+\n+               --  Loop through ELSIF parts if present\n+\n+               if Present (Elsif_Parts (N)) then\n+                  declare\n+                     Elif : Node_Id := First (Elsif_Parts (N));\n+\n+                  begin\n+                     while Present (Elif) loop\n+                        Traverse_Declarations_Or_Statements\n+                          (Then_Statements (Elif));\n+                        Next (Elif);\n+                     end loop;\n+                  end;\n+               end if;\n+\n+               --  Finally traverse the ELSE statements if present\n+\n+               Traverse_Declarations_Or_Statements (Else_Statements (N));\n+\n+            --  Case statement\n+\n+            when N_Case_Statement =>\n+\n+               --  Process case branches\n+\n+               declare\n+                  Alt : Node_Id;\n+               begin\n+                  Alt := First (Alternatives (N));\n+                  while Present (Alt) loop\n+                     Traverse_Declarations_Or_Statements (Statements (Alt));\n+                     Next (Alt);\n+                  end loop;\n+               end;\n+\n+            --  Extended return statement\n+\n+            when N_Extended_Return_Statement =>\n+               Traverse_Handled_Statement_Sequence\n+                 (Handled_Statement_Sequence (N));\n+\n+            --  Loop\n+\n+            when N_Loop_Statement =>\n+               Traverse_Declarations_Or_Statements (Statements (N));\n+\n+            when others =>\n+               null;\n+         end case;\n+\n+         Next (N);\n+      end loop;\n+   end Traverse_Declarations_Or_Statements;\n+\n+   -----------------------------------------\n+   -- Traverse_Handled_Statement_Sequence --\n+   -----------------------------------------\n+\n+   procedure Traverse_Handled_Statement_Sequence (N : Node_Id) is\n+      Handler : Node_Id;\n+\n+   begin\n+      if Present (N) then\n+         Traverse_Declarations_Or_Statements (Statements (N));\n+\n+         if Present (Exception_Handlers (N)) then\n+            Handler := First (Exception_Handlers (N));\n+            while Present (Handler) loop\n+               Traverse_Declarations_Or_Statements (Statements (Handler));\n+               Next (Handler);\n+            end loop;\n+         end if;\n+      end if;\n+   end Traverse_Handled_Statement_Sequence;\n+\n+   ---------------------------\n+   -- Traverse_Package_Body --\n+   ---------------------------\n+\n+   procedure Traverse_Package_Body (N : Node_Id) is\n+   begin\n+      Add_ALFA_Scope (N);\n+      Traverse_Declarations_Or_Statements (Declarations (N));\n+      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+   end Traverse_Package_Body;\n+\n+   ----------------------------------\n+   -- Traverse_Package_Declaration --\n+   ----------------------------------\n+\n+   procedure Traverse_Package_Declaration (N : Node_Id) is\n+      Spec : constant Node_Id := Specification (N);\n+   begin\n+      Add_ALFA_Scope (N);\n+      Traverse_Declarations_Or_Statements (Visible_Declarations (Spec));\n+      Traverse_Declarations_Or_Statements (Private_Declarations (Spec));\n+   end Traverse_Package_Declaration;\n+\n+   ------------------------------\n+   -- Traverse_Subprogram_Body --\n+   ------------------------------\n+\n+   procedure Traverse_Subprogram_Body (N : Node_Id) is\n+   begin\n+      Add_ALFA_Scope (N);\n+      Traverse_Declarations_Or_Statements (Declarations (N));\n+      Traverse_Handled_Statement_Sequence (Handled_Statement_Sequence (N));\n+   end Traverse_Subprogram_Body;\n+\n+end ALFA;"}, {"sha": "a8d5e00bd010ed72bcd93c59bc3c4b842a0cdcb4", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 64, "deletions": 561, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -27,7 +27,6 @@ with Atree;    use Atree;\n with Csets;    use Csets;\n with Elists;   use Elists;\n with Errout;   use Errout;\n-with Lib.Util; use Lib.Util;\n with Nlists;   use Nlists;\n with Opt;      use Opt;\n with Restrict; use Restrict;\n@@ -43,7 +42,6 @@ with Snames;   use Snames;\n with Stringt;  use Stringt;\n with Stand;    use Stand;\n with Table;    use Table;\n-with Widechar; use Widechar;\n \n with GNAT.Heap_Sort_G;\n \n@@ -62,9 +60,6 @@ package body Lib.Xref is\n       Ent : Entity_Id;\n       --  Entity referenced (E parameter to Generate_Reference)\n \n-      Sub : Entity_Id;\n-      --  Entity of the closest enclosing subprogram or package\n-\n       Def : Source_Ptr;\n       --  Original source location for entity being referenced. Note that these\n       --  values are used only during the output process, they are not set when\n@@ -76,22 +71,27 @@ package body Lib.Xref is\n       --  to Generate_Reference). Set to No_Location for the case of a\n       --  defining occurrence.\n \n-      Slc : Source_Ptr;\n-      --  Original source location for entity Sub\n-\n       Typ : Character;\n       --  Reference type (Typ param to Generate_Reference)\n \n       Eun : Unit_Number_Type;\n       --  Unit number corresponding to Ent\n \n-      Sun : Unit_Number_Type;\n-      --  Unit number corresponding to Sub\n-\n       Lun : Unit_Number_Type;\n       --  Unit number corresponding to Loc. Value is undefined and not\n       --  referenced if Loc is set to No_Location.\n \n+      --  The following components are only used for ALFA cross-references\n+\n+      Ref_Scope : Entity_Id;\n+      --  Entity of the closest subprogram or package enclosing the reference\n+\n+      Ent_Scope : Entity_Id;\n+      --  Entity of the closest subprogram or package enclosing the definition,\n+      --  which should be located in the same file as the definition itself.\n+\n+      Ent_Scope_File : Unit_Number_Type;\n+      --  File for entity Ent_Scope\n    end record;\n \n    package Xrefs is new Table.Table (\n@@ -102,16 +102,19 @@ package body Lib.Xref is\n      Table_Increment      => Alloc.Xrefs_Increment,\n      Table_Name           => \"Xrefs\");\n \n+   ----------------------\n+   -- ALFA Information --\n+   ----------------------\n+\n+   package body ALFA is separate;\n+\n    ------------------------\n    --  Local Subprograms --\n    ------------------------\n \n    function Enclosing_Subprogram_Or_Package (N : Node_Id) return Entity_Id;\n    --  Return the closest enclosing subprogram of package\n \n-   function Is_Local_Reference_Type (Typ : Character) return Boolean;\n-   --  Return whether Typ is a suitable reference type for a local reference\n-\n    procedure Generate_Prim_Op_References (Typ : Entity_Id);\n    --  For a tagged type, generate implicit references to its primitive\n    --  operations, for source navigation. This is done right before emitting\n@@ -121,20 +124,25 @@ package body Lib.Xref is\n    function Lt (T1, T2 : Xref_Entry) return Boolean;\n    --  Order cross-references\n \n-   procedure Write_Entity_Name (E : Entity_Id; Cursrc : Source_Buffer_Ptr);\n-   --  Output entity name for E. We use the occurrence from the actual\n-   --  source program at the definition point.\n-\n    -------------------------------------\n    -- Enclosing_Subprogram_Or_Package --\n    -------------------------------------\n \n-   function Enclosing_Subprogram_Or_Package (N : Node_Id) return Entity_Id\n-   is\n-      Result : Entity_Id;\n+   function Enclosing_Subprogram_Or_Package (N : Node_Id) return Entity_Id is\n+      Result         : Entity_Id;\n \n    begin\n-      Result := N;\n+      --  If N is the defining identifier for a subprogram, then return the\n+      --  enclosing subprogram or package, not this subprogram.\n+\n+      if Nkind_In (N, N_Defining_Identifier, N_Defining_Operator_Symbol)\n+        and then Nkind (Parent (N)) in N_Subprogram_Specification\n+      then\n+         Result := Parent (Parent (Parent (N)));\n+      else\n+         Result := N;\n+      end if;\n+\n       loop\n          exit when No (Result);\n \n@@ -144,7 +152,7 @@ package body Lib.Xref is\n                exit;\n \n             when N_Package_Body =>\n-               Result := Corresponding_Spec (Result);\n+               Result := Defining_Unit_Name (Result);\n                exit;\n \n             when N_Subprogram_Specification =>\n@@ -168,6 +176,14 @@ package body Lib.Xref is\n          Result := Defining_Identifier (Result);\n       end if;\n \n+      --  Do no return a scope without a proper location\n+\n+      if Present (Result)\n+        and then Sloc (Result) = No_Location\n+      then\n+         return Empty;\n+      end if;\n+\n       return Result;\n    end Enclosing_Subprogram_Or_Package;\n \n@@ -214,39 +230,16 @@ package body Lib.Xref is\n          Loc  := Original_Location (Sloc (E));\n \n          Xrefs.Table (Indx).Ent := E;\n+         Xrefs.Table (Indx).Typ := ' ';\n+         Xrefs.Table (Indx).Def := No_Location;\n+         Xrefs.Table (Indx).Loc := No_Location;\n \n-         if ALFA_Mode\n-           and then Nkind_In (Parent (E),\n-                              N_Object_Declaration,\n-                              N_Parameter_Specification)\n-         then\n-            --  In ALFA mode, define precise 'D' references for object\n-            --  definition.\n+         Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n \n-            declare\n-               Sub : constant Entity_Id := Enclosing_Subprogram_Or_Package (E);\n-               Slc : constant Source_Ptr := Original_Location (Sloc (Sub));\n-               Sun : constant Unit_Number_Type := Get_Source_Unit (Slc);\n-            begin\n-               Xrefs.Table (Indx).Typ := 'D';\n-               Xrefs.Table (Indx).Sub := Sub;\n-               Xrefs.Table (Indx).Def := Loc;\n-               Xrefs.Table (Indx).Loc := Loc;\n-               Xrefs.Table (Indx).Slc := Slc;\n-               Xrefs.Table (Indx).Lun := Get_Source_Unit (Loc);\n-               Xrefs.Table (Indx).Sun := Sun;\n-            end;\n-         else\n-            Xrefs.Table (Indx).Typ := ' ';\n-            Xrefs.Table (Indx).Sub := Empty;\n-            Xrefs.Table (Indx).Def := No_Location;\n-            Xrefs.Table (Indx).Loc := No_Location;\n-            Xrefs.Table (Indx).Slc := No_Location;\n-            Xrefs.Table (Indx).Lun := No_Unit;\n-            Xrefs.Table (Indx).Sun := No_Unit;\n-         end if;\n+         Xrefs.Table (Indx).Ref_Scope      := Empty;\n+         Xrefs.Table (Indx).Ent_Scope      := Empty;\n+         Xrefs.Table (Indx).Ent_Scope_File := No_Unit;\n \n-         Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n          Set_Has_Xref_Entry (E);\n \n          if In_Inlined_Body then\n@@ -371,9 +364,10 @@ package body Lib.Xref is\n       Nod  : Node_Id;\n       Ref  : Source_Ptr;\n       Def  : Source_Ptr;\n-      Slc  : Source_Ptr;\n       Ent  : Entity_Id;\n-      Sub  : Entity_Id;\n+\n+      Ref_Scope     : Entity_Id;\n+      Ent_Scope     : Entity_Id;\n \n       Call   : Node_Id;\n       Formal : Entity_Id;\n@@ -934,17 +928,16 @@ package body Lib.Xref is\n \n          --  Record reference to entity\n \n-         Sub := Enclosing_Subprogram_Or_Package (N);\n-\n          Ref := Original_Location (Sloc (Nod));\n          Def := Original_Location (Sloc (Ent));\n-         Slc := Original_Location (Sloc (Sub));\n+\n+         Ref_Scope := Enclosing_Subprogram_Or_Package (N);\n+         Ent_Scope := Enclosing_Subprogram_Or_Package (Ent);\n \n          Xrefs.Increment_Last;\n          Indx := Xrefs.Last;\n \n          Xrefs.Table (Indx).Loc := Ref;\n-         Xrefs.Table (Indx).Slc := Slc;\n \n          --  Overriding operations are marked with 'P'\n \n@@ -959,9 +952,12 @@ package body Lib.Xref is\n \n          Xrefs.Table (Indx).Eun := Get_Source_Unit (Def);\n          Xrefs.Table (Indx).Lun := Get_Source_Unit (Ref);\n-         Xrefs.Table (Indx).Sun := Get_Source_Unit (Slc);\n          Xrefs.Table (Indx).Ent := Ent;\n-         Xrefs.Table (Indx).Sub := Sub;\n+\n+         Xrefs.Table (Indx).Ref_Scope      := Ref_Scope;\n+         Xrefs.Table (Indx).Ent_Scope      := Ent_Scope;\n+         Xrefs.Table (Indx).Ent_Scope_File := Get_Source_Unit (Ent_Scope);\n+\n          Set_Has_Xref_Entry (Ent);\n       end if;\n    end Generate_Reference;\n@@ -1036,19 +1032,6 @@ package body Lib.Xref is\n       Xrefs.Init;\n    end Initialize;\n \n-   -----------------------------\n-   -- Is_Local_Reference_Type --\n-   -----------------------------\n-\n-   function Is_Local_Reference_Type (Typ : Character) return Boolean is\n-   begin\n-      return Typ = 'r' or else\n-             Typ = 'm' or else\n-             Typ = 's' or else\n-             Typ = 'I' or else\n-             Typ = 'D';\n-   end Is_Local_Reference_Type;\n-\n    --------\n    -- Lt --\n    --------\n@@ -1320,10 +1303,6 @@ package body Lib.Xref is\n    --  Start of processing for Output_References\n \n    begin\n-      if not Opt.Xref_Active then\n-         return;\n-      end if;\n-\n       --  First we add references to the primitive operations of tagged types\n       --  declared in the main unit.\n \n@@ -1522,9 +1501,6 @@ package body Lib.Xref is\n          Curru : Unit_Number_Type;\n          --  Current reference unit for one entity\n \n-         Cursrc : Source_Buffer_Ptr;\n-         --  Current xref unit source text\n-\n          Curent : Entity_Id;\n          --  Current entity\n \n@@ -1657,20 +1633,11 @@ package body Lib.Xref is\n \n          for Refno in 1 .. Nrefs loop\n             Output_One_Ref : declare\n-               P2  : Source_Ptr;\n                Ent : Entity_Id;\n \n-               WC  : Char_Code;\n-               Err : Boolean;\n-               pragma Warnings (Off, WC);\n-               pragma Warnings (Off, Err);\n-\n                XE : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n                --  The current entry to be accessed\n \n-               P : Source_Ptr;\n-               --  Used to index into source buffer to get entity name\n-\n                Left  : Character;\n                Right : Character;\n                --  Used for {} or <> or () for type reference\n@@ -2015,7 +1982,6 @@ package body Lib.Xref is\n                      end if;\n \n                      Curxu := XE.Eun;\n-                     Cursrc := Source_Text (Source_Index (Curxu));\n \n                      Write_Info_Initiate ('X');\n                      Write_Info_Char (' ');\n@@ -2149,51 +2115,14 @@ package body Lib.Xref is\n                      --  Output entity name. We use the occurrence from the\n                      --  actual source program at the definition point.\n \n-                     P := Original_Location (Sloc (XE.Ent));\n-\n-                     --  Entity is character literal\n-\n-                     if Cursrc (P) = ''' then\n-                        Write_Info_Char (Cursrc (P));\n-                        Write_Info_Char (Cursrc (P + 1));\n-                        Write_Info_Char (Cursrc (P + 2));\n-\n-                     --  Entity is operator symbol\n-\n-                     elsif Cursrc (P) = '\"' or else Cursrc (P) = '%' then\n-                        Write_Info_Char (Cursrc (P));\n-\n-                        P2 := P;\n-                        loop\n-                           P2 := P2 + 1;\n-                           Write_Info_Char (Cursrc (P2));\n-                           exit when Cursrc (P2) = Cursrc (P);\n-                        end loop;\n-\n-                     --  Entity is identifier\n-\n-                     else\n-                        loop\n-                           if Is_Start_Of_Wide_Char (Cursrc, P) then\n-                              Scan_Wide (Cursrc, P, WC, Err);\n-                           elsif not Identifier_Char (Cursrc (P)) then\n-                              exit;\n-                           else\n-                              P := P + 1;\n-                           end if;\n-                        end loop;\n-\n-                        --  Write out the identifier by copying the exact\n-                        --  source characters used in its declaration. Note\n-                        --  that this means wide characters will be in their\n-                        --  original encoded form.\n-\n-                        for J in\n-                          Original_Location (Sloc (XE.Ent)) .. P - 1\n-                        loop\n-                           Write_Info_Char (Cursrc (J));\n+                     declare\n+                        Ent_Name : constant String :=\n+                                     Exact_Source_Name (Sloc (XE.Ent));\n+                     begin\n+                        for C in Ent_Name'Range loop\n+                           Write_Info_Char (Ent_Name (C));\n                         end loop;\n-                     end if;\n+                     end;\n \n                      --  See if we have a renaming reference\n \n@@ -2391,430 +2320,4 @@ package body Lib.Xref is\n       end Output_Refs;\n    end Output_References;\n \n-   -----------------------------\n-   -- Output_Local_References --\n-   -----------------------------\n-\n-   procedure Output_Local_References is\n-\n-      Nrefs : Nat := Xrefs.Last;\n-      --  Number of references in table. This value may get reset (reduced)\n-      --  when we eliminate duplicate reference entries as well as references\n-      --  not suitable for local cross-references.\n-\n-      Rnums : array (0 .. Nrefs) of Nat;\n-      --  This array contains numbers of references in the Xrefs table. This\n-      --  list is sorted in output order. The extra 0'th entry is convenient\n-      --  for the call to sort. When we sort the table, we move the entries in\n-      --  Rnums around, but we do not move the original table entries.\n-\n-      Curxu : Unit_Number_Type;\n-      --  Current xref unit\n-\n-      Curru : Unit_Number_Type;\n-      --  Current reference unit for one entity\n-\n-      Cursu : Unit_Number_Type;\n-      --  Current reference unit for one enclosing subprogram\n-\n-      Cursrc : Source_Buffer_Ptr;\n-      --  Current xref unit source text\n-\n-      Cursub : Entity_Id;\n-      --  Current enclosing subprogram\n-\n-      Curent : Entity_Id;\n-      --  Current entity\n-\n-      Curnam : String (1 .. Name_Buffer'Length);\n-      Curlen : Natural;\n-      --  Simple name and length of current entity\n-\n-      Curdef : Source_Ptr;\n-      --  Original source location for current entity\n-\n-      Crloc : Source_Ptr;\n-      --  Current reference location\n-\n-      Ctyp  : Character;\n-      --  Entity type character\n-\n-      Prevt : Character;\n-      --  Reference kind of previous reference\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean;\n-      --  Comparison function for Sort call\n-\n-      function Name_Change (X : Entity_Id) return Boolean;\n-      --  Determines if entity X has a different simple name from Curent\n-\n-      procedure Move (From : Natural; To : Natural);\n-      --  Move procedure for Sort call\n-\n-      package Sorting is new GNAT.Heap_Sort_G (Move, Lt);\n-\n-      --------\n-      -- Lt --\n-      --------\n-\n-      function Lt (Op1, Op2 : Natural) return Boolean is\n-         T1 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op1)));\n-         T2 : Xref_Entry renames Xrefs.Table (Rnums (Nat (Op2)));\n-\n-      begin\n-         if T1.Slc = No_Location then\n-            return True;\n-\n-         elsif T2.Slc = No_Location then\n-            return False;\n-\n-         elsif T1.Sun /= T2.Sun then\n-            return Dependency_Num (T1.Sun) < Dependency_Num (T2.Sun);\n-\n-         elsif T1.Slc /= T2.Slc then\n-            return T1.Slc < T2.Slc;\n-\n-         else\n-            return Lt (T1, T2);\n-         end if;\n-      end Lt;\n-\n-      ----------\n-      -- Move --\n-      ----------\n-\n-      procedure Move (From : Natural; To : Natural) is\n-      begin\n-         Rnums (Nat (To)) := Rnums (Nat (From));\n-      end Move;\n-\n-      -----------------\n-      -- Name_Change --\n-      -----------------\n-\n-      --  Why a string comparison here??? Why not compare Name_Id values???\n-\n-      function Name_Change (X : Entity_Id) return Boolean is\n-      begin\n-         Get_Unqualified_Name_String (Chars (X));\n-\n-         if Name_Len /= Curlen then\n-            return True;\n-         else\n-            return Name_Buffer (1 .. Curlen) /= Curnam (1 .. Curlen);\n-         end if;\n-      end Name_Change;\n-\n-      --  Start of processing for Output_Subprogram_References\n-   begin\n-\n-      --  Replace enclosing subprogram pointer by corresponding specification\n-      --  when appropriate. This could not be done before as the information\n-      --  was not always available when registering references.\n-\n-      for J in 1 .. Xrefs.Last loop\n-         if Present (Xrefs.Table (J).Sub) then\n-            declare\n-               N   : constant Node_Id :=\n-                       Parent (Parent (Xrefs.Table (J).Sub));\n-               Sub : Entity_Id;\n-               Slc : Source_Ptr;\n-               Sun : Unit_Number_Type;\n-            begin\n-               if Nkind (N) = N_Subprogram_Body\n-                 and then not Acts_As_Spec (N)\n-               then\n-                  Sub := Corresponding_Spec (N);\n-\n-                  if Nkind (Sub) = N_Defining_Program_Unit_Name then\n-                     Sub := Defining_Identifier (Sub);\n-                  end if;\n-\n-                  Slc := Original_Location (Sloc (Sub));\n-                  Sun := Get_Source_Unit (Slc);\n-\n-                  Xrefs.Table (J).Sub := Sub;\n-                  Xrefs.Table (J).Slc := Slc;\n-                  Xrefs.Table (J).Sun := Sun;\n-               end if;\n-            end;\n-         end if;\n-      end loop;\n-\n-      --  Set up the pointer vector for the sort\n-\n-      for J in 1 .. Nrefs loop\n-         Rnums (J) := J;\n-      end loop;\n-\n-      --  Sort the references\n-\n-      Sorting.Sort (Integer (Nrefs));\n-\n-      declare\n-         NR : Nat;\n-\n-      begin\n-         --  Eliminate duplicate entries\n-\n-         --  We need this test for NR because if we force ALI file generation\n-         --  in case of errors detected, it may be the case that Nrefs is zero,\n-         --  so we should not reset it here.\n-\n-         if Nrefs >= 2 then\n-            NR    := Nrefs;\n-            Nrefs := 1;\n-\n-            for J in 2 .. NR loop\n-               if Xrefs.Table (Rnums (J)) /= Xrefs.Table (Rnums (Nrefs)) then\n-                  Nrefs         := Nrefs + 1;\n-                  Rnums (Nrefs) := Rnums (J);\n-               end if;\n-            end loop;\n-         end if;\n-\n-         --  Eliminate entries not appropriate for local references\n-\n-         NR    := Nrefs;\n-         Nrefs := 0;\n-\n-         for J in 1 .. NR loop\n-            if Lref_Entity_Status (Ekind (Xrefs.Table (Rnums (J)).Ent))\n-              and then Is_Local_Reference_Type (Xrefs.Table (Rnums (J)).Typ)\n-            then\n-               Nrefs         := Nrefs + 1;\n-               Rnums (Nrefs) := Rnums (J);\n-            end if;\n-         end loop;\n-      end;\n-\n-      --  Initialize loop through references\n-\n-      Curxu  := No_Unit;\n-      Cursub := Empty;\n-      Curent := Empty;\n-      Curdef := No_Location;\n-      Curru  := No_Unit;\n-      Cursu  := No_Unit;\n-      Crloc  := No_Location;\n-      Prevt  := 'm';\n-\n-      --  Loop to output references\n-\n-      for Refno in 1 .. Nrefs loop\n-         Output_One_Ref : declare\n-            Ent : Entity_Id;\n-\n-            XE  : Xref_Entry renames Xrefs.Table (Rnums (Refno));\n-            --  The current entry to be accessed\n-\n-         begin\n-            Ent  := XE.Ent;\n-            Ctyp := Xref_Entity_Letters (Ekind (Ent));\n-\n-            --  Start new Unit section if subprogram in new unit\n-\n-            if XE.Sun /= Cursu then\n-               if Write_Info_Col > 1 then\n-                  Write_Info_EOL;\n-               end if;\n-\n-               Cursu := XE.Sun;\n-\n-               Write_Info_Initiate ('F');\n-               Write_Info_Char (' ');\n-               Write_Info_Nat (Dependency_Num (XE.Sun));\n-               Write_Info_Char (' ');\n-               Write_Info_Name (Reference_Name (Source_Index (XE.Sun)));\n-               Write_Info_EOL;\n-            end if;\n-\n-            --  Start new Subprogram section if new subprogram\n-\n-            if XE.Sub /= Cursub then\n-               if Write_Info_Col > 1 then\n-                  Write_Info_EOL;\n-               end if;\n-\n-               Cursub := XE.Sub;\n-               Cursrc := Source_Text (Source_Index (Cursu));\n-\n-               Write_Info_Initiate ('S');\n-               Write_Info_Char (' ');\n-               Write_Info_Nat (Int (Get_Logical_Line_Number (XE.Slc)));\n-               Write_Info_Char (Xref_Entity_Letters (Ekind (XE.Sub)));\n-               Write_Info_Nat (Int (Get_Column_Number (XE.Slc)));\n-               Write_Info_Char (' ');\n-               Write_Entity_Name (XE.Sub, Cursrc);\n-\n-               --  Indicate that the entity is in the unit of the current local\n-               --  xref section.\n-\n-               Curru := Cursu;\n-\n-               --  End of processing for subprogram output\n-\n-               Curxu  := No_Unit;\n-               Curent := Empty;\n-            end if;\n-\n-            --  Start new Xref section if new xref unit\n-\n-            if XE.Eun /= Curxu then\n-               if Write_Info_Col > 1 then\n-                  Write_Info_EOL;\n-               end if;\n-\n-               Curxu  := XE.Eun;\n-               Cursrc := Source_Text (Source_Index (Curxu));\n-\n-               Write_Info_Initiate ('X');\n-               Write_Info_Char (' ');\n-               Write_Info_Nat (Dependency_Num (XE.Eun));\n-               Write_Info_Char (' ');\n-               Write_Info_Name (Reference_Name (Source_Index (XE.Eun)));\n-\n-               --  End of processing for Xref section output\n-\n-               Curru := Cursu;\n-            end if;\n-\n-            --  Start new Entity line if new entity. Note that we consider two\n-            --  entities the same if they have the same name and source\n-            --  location. This causes entities in instantiations to be treated\n-            --  as though they referred to the template.\n-\n-            if No (Curent)\n-              or else\n-                (XE.Ent /= Curent\n-                  and then (Name_Change (XE.Ent) or else XE.Def /= Curdef))\n-            then\n-               Curent := XE.Ent;\n-               Curdef := XE.Def;\n-\n-               Get_Unqualified_Name_String (Chars (XE.Ent));\n-               Curlen := Name_Len;\n-               Curnam (1 .. Curlen) := Name_Buffer (1 .. Curlen);\n-\n-               if Write_Info_Col > 1 then\n-                  Write_Info_EOL;\n-               end if;\n-\n-               --  Write line and column number information\n-\n-               Write_Info_Nat  (Int (Get_Logical_Line_Number (XE.Def)));\n-               Write_Info_Char (Ctyp);\n-               Write_Info_Nat  (Int (Get_Column_Number (XE.Def)));\n-               Write_Info_Char (' ');\n-\n-               --  Output entity name\n-\n-               Write_Entity_Name (XE.Ent, Cursrc);\n-\n-               --  End of processing for entity output\n-\n-               Crloc := No_Location;\n-            end if;\n-\n-            --  Output the reference if it is not as the same location as the\n-            --  previous one, or it is a read-reference that indicates that the\n-            --  entity is an in-out actual in a call.\n-\n-            if XE.Loc /= No_Location\n-              and then\n-                (XE.Loc /= Crloc\n-                  or else (Prevt = 'm' and then XE.Typ = 'r'))\n-            then\n-               Crloc := XE.Loc;\n-               Prevt := XE.Typ;\n-\n-               --  Start continuation if line full, else blank\n-\n-               if Write_Info_Col > 72 then\n-                  Write_Info_EOL;\n-                  Write_Info_Initiate ('.');\n-               end if;\n-\n-               Write_Info_Char (' ');\n-\n-               --  Output file number if changed\n-\n-               if XE.Lun /= Curru then\n-                  Curru := XE.Lun;\n-                  Write_Info_Nat (Dependency_Num (Curru));\n-                  Write_Info_Char ('|');\n-               end if;\n-\n-               --  Write line and column number information\n-\n-               Write_Info_Nat  (Int (Get_Logical_Line_Number (XE.Loc)));\n-               Write_Info_Char (XE.Typ);\n-               Write_Info_Nat  (Int (Get_Column_Number (XE.Loc)));\n-            end if;\n-         end Output_One_Ref;\n-      end loop;\n-\n-      Write_Info_EOL;\n-   end Output_Local_References;\n-\n-   -----------------------\n-   -- Write_Entity_Name --\n-   -----------------------\n-\n-   procedure Write_Entity_Name (E : Entity_Id; Cursrc : Source_Buffer_Ptr) is\n-      P, P2 : Source_Ptr;\n-      --  Used to index into source buffer to get entity name\n-\n-      WC    : Char_Code;\n-      Err   : Boolean;\n-      pragma Warnings (Off, WC);\n-      pragma Warnings (Off, Err);\n-\n-   begin\n-      P := Original_Location (Sloc (E));\n-\n-      --  Entity is character literal\n-\n-      if Cursrc (P) = ''' then\n-         Write_Info_Char (Cursrc (P));\n-         Write_Info_Char (Cursrc (P + 1));\n-         Write_Info_Char (Cursrc (P + 2));\n-\n-         --  Entity is operator symbol\n-\n-      elsif Cursrc (P) = '\"' or else Cursrc (P) = '%' then\n-         Write_Info_Char (Cursrc (P));\n-\n-         P2 := P;\n-         loop\n-            P2 := P2 + 1;\n-            Write_Info_Char (Cursrc (P2));\n-            exit when Cursrc (P2) = Cursrc (P);\n-         end loop;\n-\n-         --  Entity is identifier\n-\n-      else\n-         loop\n-            if Is_Start_Of_Wide_Char (Cursrc, P) then\n-               Scan_Wide (Cursrc, P, WC, Err);\n-            elsif not Identifier_Char (Cursrc (P)) then\n-               exit;\n-            else\n-               P := P + 1;\n-            end if;\n-         end loop;\n-\n-         --  Write out the identifier by copying the exact source characters\n-         --  used in its declaration. Note that this means wide characters will\n-         --  be in their original encoded form.\n-\n-         for J in\n-           Original_Location (Sloc (E)) .. P - 1\n-         loop\n-            Write_Info_Char (Cursrc (J));\n-         end loop;\n-      end if;\n-   end Write_Entity_Name;\n-\n end Lib.Xref;"}, {"sha": "c5aa20fd199832caab574593e02393ac531d87ea", "filename": "gcc/ada/lib-xref.ads", "status": "modified", "additions": 24, "deletions": 132, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib-xref.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -26,7 +26,9 @@\n --  This package contains for collecting and outputting cross-reference\n --  information.\n \n-with Einfo; use Einfo;\n+with Einfo;    use Einfo;\n+with Lib.Util; use Lib.Util;\n+with Put_ALFA;\n \n package Lib.Xref is\n \n@@ -564,134 +566,6 @@ package Lib.Xref is\n    --    y     abstract function               entry or entry family\n    --    z     generic formal parameter        (unused)\n \n-   -------------------------------------------------------------\n-   -- Format of Local Cross-Reference Information in ALI File --\n-   -------------------------------------------------------------\n-\n-   --  Local cross-reference sections follow the cross-reference section in an\n-   --  ALI file, so that they need not be read by gnatbind, gnatmake etc.\n-\n-   --  A local cross-reference section has a header of the form\n-\n-   --     S line type col entity\n-\n-   --        These precisely define a subprogram or package, with the same\n-   --        components as described for cross-reference sections.\n-\n-   --  These sections are grouped in chapters for each unit introduced by\n-\n-   --     F dependency-number filename\n-\n-   --  Each section groups a number of cross-reference sub-sections introduced\n-   --  by\n-\n-   --     X dependency-number filename\n-\n-   --  Inside each cross-reference sub-section, there are a number of\n-   --  references like\n-\n-   --     line type col entity ref ref ...\n-\n-   -----------------------------------\n-   -- Local-Reference Entity Filter --\n-   -----------------------------------\n-\n-   Lref_Entity_Status : array (Entity_Kind) of Boolean :=\n-     (E_Void                                       => False,\n-      E_Variable                                   => True,\n-      E_Component                                  => False,\n-      E_Constant                                   => True,\n-      E_Discriminant                               => False,\n-\n-      E_Loop_Parameter                             => True,\n-      E_In_Parameter                               => True,\n-      E_Out_Parameter                              => True,\n-      E_In_Out_Parameter                           => True,\n-      E_Generic_In_Out_Parameter                   => False,\n-\n-      E_Generic_In_Parameter                       => False,\n-      E_Named_Integer                              => False,\n-      E_Named_Real                                 => False,\n-      E_Enumeration_Type                           => False,\n-      E_Enumeration_Subtype                        => False,\n-\n-      E_Signed_Integer_Type                        => False,\n-      E_Signed_Integer_Subtype                     => False,\n-      E_Modular_Integer_Type                       => False,\n-      E_Modular_Integer_Subtype                    => False,\n-      E_Ordinary_Fixed_Point_Type                  => False,\n-\n-      E_Ordinary_Fixed_Point_Subtype               => False,\n-      E_Decimal_Fixed_Point_Type                   => False,\n-      E_Decimal_Fixed_Point_Subtype                => False,\n-      E_Floating_Point_Type                        => False,\n-      E_Floating_Point_Subtype                     => False,\n-\n-      E_Access_Type                                => False,\n-      E_Access_Subtype                             => False,\n-      E_Access_Attribute_Type                      => False,\n-      E_Allocator_Type                             => False,\n-      E_General_Access_Type                        => False,\n-\n-      E_Access_Subprogram_Type                     => False,\n-      E_Access_Protected_Subprogram_Type           => False,\n-      E_Anonymous_Access_Subprogram_Type           => False,\n-      E_Anonymous_Access_Protected_Subprogram_Type => False,\n-      E_Anonymous_Access_Type                      => False,\n-\n-      E_Array_Type                                 => False,\n-      E_Array_Subtype                              => False,\n-      E_String_Type                                => False,\n-      E_String_Subtype                             => False,\n-      E_String_Literal_Subtype                     => False,\n-\n-      E_Class_Wide_Type                            => False,\n-      E_Class_Wide_Subtype                         => False,\n-      E_Record_Type                                => False,\n-      E_Record_Subtype                             => False,\n-      E_Record_Type_With_Private                   => False,\n-\n-      E_Record_Subtype_With_Private                => False,\n-      E_Private_Type                               => False,\n-      E_Private_Subtype                            => False,\n-      E_Limited_Private_Type                       => False,\n-      E_Limited_Private_Subtype                    => False,\n-\n-      E_Incomplete_Type                            => False,\n-      E_Incomplete_Subtype                         => False,\n-      E_Task_Type                                  => False,\n-      E_Task_Subtype                               => False,\n-      E_Protected_Type                             => False,\n-\n-      E_Protected_Subtype                          => False,\n-      E_Exception_Type                             => False,\n-      E_Subprogram_Type                            => False,\n-      E_Enumeration_Literal                        => False,\n-      E_Function                                   => True,\n-\n-      E_Operator                                   => True,\n-      E_Procedure                                  => True,\n-      E_Entry                                      => False,\n-      E_Entry_Family                               => False,\n-      E_Block                                      => False,\n-\n-      E_Entry_Index_Parameter                      => False,\n-      E_Exception                                  => False,\n-      E_Generic_Function                           => False,\n-      E_Generic_Package                            => False,\n-      E_Generic_Procedure                          => False,\n-\n-      E_Label                                      => False,\n-      E_Loop                                       => False,\n-      E_Return_Statement                           => False,\n-      E_Package                                    => False,\n-\n-      E_Package_Body                               => False,\n-      E_Protected_Object                           => False,\n-      E_Protected_Body                             => False,\n-      E_Task_Body                                  => False,\n-      E_Subprogram_Body                            => False);\n-\n    --------------------------------------\n    -- Handling of Imported Subprograms --\n    --------------------------------------\n@@ -708,6 +582,27 @@ package Lib.Xref is\n    --  Import at line 4, that its body is in C, and that the link name as given\n    --  in the pragma is \"there\".\n \n+   ----------------------\n+   -- ALFA Information --\n+   ----------------------\n+\n+   --  This package defines procedures for collecting ALFA information and\n+   --  printing in ALI files.\n+\n+   package ALFA is\n+\n+      procedure Collect_ALFA (Sdep_Table : Unit_Ref_Table; Num_Sdep : Nat);\n+      --  Collect ALFA information from library units (for files and scopes)\n+      --  and from cross-references. Fill in the tables in library package\n+      --  called ALFA.\n+\n+      procedure Output_ALFA is new Put_ALFA;\n+      --  Output ALFA information to the ALI files, based on the information\n+      --  collected in the tables in library package called ALFA, and using\n+      --  routines in Lib.Util.\n+\n+   end ALFA;\n+\n    -----------------\n    -- Subprograms --\n    -----------------\n@@ -790,9 +685,6 @@ package Lib.Xref is\n    procedure Output_References;\n    --  Output references to the current ali file\n \n-   procedure Output_Local_References;\n-   --  Output references in each subprogram of the current ali file\n-\n    procedure Initialize;\n    --  Initialize internal tables\n "}, {"sha": "c5149bee3b0a25de4dbfb215660c6d78a86ac982", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 69, "deletions": 11, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,16 +33,18 @@ pragma Style_Checks (All_Checks);\n --  Subprogram ordering not enforced in this unit\n --  (because of some logical groupings).\n \n-with Atree;   use Atree;\n-with Einfo;   use Einfo;\n-with Fname;   use Fname;\n-with Output;  use Output;\n-with Sinfo;   use Sinfo;\n-with Sinput;  use Sinput;\n-with Stand;   use Stand;\n-with Stringt; use Stringt;\n-with Tree_IO; use Tree_IO;\n-with Uname;   use Uname;\n+with Atree;    use Atree;\n+with Csets;    use Csets;\n+with Einfo;    use Einfo;\n+with Fname;    use Fname;\n+with Output;   use Output;\n+with Sinfo;    use Sinfo;\n+with Sinput;   use Sinput;\n+with Stand;    use Stand;\n+with Stringt;  use Stringt;\n+with Tree_IO;  use Tree_IO;\n+with Uname;    use Uname;\n+with Widechar; use Widechar;\n \n package body Lib is\n \n@@ -478,6 +480,62 @@ package body Lib is\n       return Check_Same_Extended_Unit (S1, S2) = Yes_Before;\n    end Earlier_In_Extended_Unit;\n \n+   -----------------------\n+   -- Exact_Source_Name --\n+   -----------------------\n+\n+   function Exact_Source_Name (Loc : Source_Ptr) return String is\n+      U    : constant Unit_Number_Type  := Get_Source_Unit (Loc);\n+      Buf  : constant Source_Buffer_Ptr := Source_Text (Source_Index (U));\n+      Orig : constant Source_Ptr        := Original_Location (Loc);\n+      P    : Source_Ptr;\n+\n+      WC   : Char_Code;\n+      Err  : Boolean;\n+      pragma Warnings (Off, WC);\n+      pragma Warnings (Off, Err);\n+\n+   begin\n+      --  Entity is character literal\n+\n+      if Buf (Orig) = ''' then\n+         return String (Buf (Orig .. Orig + 2));\n+\n+      --  Entity is operator symbol\n+\n+      elsif Buf (Orig) = '\"' or else Buf (Orig) = '%' then\n+         P := Orig;\n+\n+         loop\n+            P := P + 1;\n+            exit when Buf (P) = Buf (Orig);\n+         end loop;\n+\n+         return String (Buf (Orig .. P));\n+\n+      --  Entity is identifier\n+\n+      else\n+         P := Orig;\n+\n+         loop\n+            if Is_Start_Of_Wide_Char (Buf, P) then\n+               Scan_Wide (Buf, P, WC, Err);\n+            elsif not Identifier_Char (Buf (P)) then\n+               exit;\n+            else\n+               P := P + 1;\n+            end if;\n+         end loop;\n+\n+         --  Write out the identifier by copying the exact source characters\n+         --  used in its declaration. Note that this means wide characters will\n+         --  be in their original encoded form.\n+\n+         return String (Buf (Orig .. P - 1));\n+      end if;\n+   end Exact_Source_Name;\n+\n    ----------------------------\n    -- Entity_Is_In_Main_Unit --\n    ----------------------------"}, {"sha": "845b45ab6c776f8e8939134e99d81eb324187479", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -39,6 +39,9 @@ with Types; use Types;\n \n package Lib is\n \n+   type Unit_Ref_Table is array (Pos range <>) of Unit_Number_Type;\n+   --  Type to hold list of indirect references to unit number table\n+\n    type Compiler_State_Type is (Parsing, Analyzing);\n    Compiler_State : Compiler_State_Type;\n    --  Indicates current state of compilation. This is used to implement the\n@@ -551,6 +554,10 @@ package Lib is\n    --  extended unit. Note: this routine will not give reliable results if\n    --  called after Sprint has been called with -gnatD set.\n \n+   function Exact_Source_Name (Loc : Source_Ptr) return String;\n+   --  Return the name of an entity at location Loc exactly as written in the\n+   --  source.\n+\n    function Compilation_Switches_Last return Nat;\n    --  Return the count of stored compilation switches\n \n@@ -816,9 +823,6 @@ private\n    --  is in the main source file. This ensures that not found messages and\n    --  circular dependency messages reference the original with in this source.\n \n-   type Unit_Ref_Table is array (Pos range <>) of Unit_Number_Type;\n-   --  Type to hold list of indirect references to unit number table\n-\n    type Load_Stack_Entry is record\n       Unit_Number : Unit_Number_Type;\n       With_Node   : Node_Id;"}, {"sha": "1e1a661ac97f894041dca05c25f5761ecdb23b4b", "filename": "gcc/ada/put_alfa.adb", "status": "added", "additions": 220, "deletions": 0, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fput_alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fput_alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,220 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P U T _ A L F A                              --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with ALFA; use ALFA;\n+\n+procedure Put_ALFA is\n+begin\n+   --  Loop through entries in ALFA_File_Table\n+\n+   for J in 1 .. ALFA_File_Table.Last loop\n+      declare\n+         F     : ALFA_File_Record renames ALFA_File_Table.Table (J);\n+\n+         Start : Scope_Index;\n+         Stop  : Scope_Index;\n+\n+      begin\n+         Start := F.From_Scope;\n+         Stop  := F.To_Scope;\n+\n+         if Start <= Stop then\n+            Write_Info_Initiate ('F');\n+            Write_Info_Char ('D');\n+            Write_Info_Char (' ');\n+            Write_Info_Nat (F.File_Num);\n+            Write_Info_Char (' ');\n+\n+            for N in F.File_Name'Range loop\n+               Write_Info_Char (F.File_Name (N));\n+            end loop;\n+\n+            Write_Info_Terminate;\n+         end if;\n+\n+         --  Loop through scope entries for this file\n+\n+         loop\n+            exit when Start = Stop + 1;\n+            pragma Assert (Start <= Stop);\n+\n+            declare\n+               S : ALFA_Scope_Record renames ALFA_Scope_Table.Table (Start);\n+\n+            begin\n+               Write_Info_Initiate ('F');\n+               Write_Info_Char ('S');\n+               Write_Info_Char (' ');\n+               Write_Info_Char ('.');\n+               Write_Info_Nat (S.Scope_Num);\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (S.Line);\n+               Write_Info_Char (S.Stype);\n+               Write_Info_Nat (S.Col);\n+               Write_Info_Char (' ');\n+\n+               for N in S.Scope_Name'Range loop\n+                  Write_Info_Char (S.Scope_Name (N));\n+               end loop;\n+\n+               Write_Info_Terminate;\n+            end;\n+\n+            Start := Start + 1;\n+         end loop;\n+      end;\n+   end loop;\n+\n+   --  Loop through entries in ALFA_File_Table\n+\n+   for J in 1 .. ALFA_File_Table.Last loop\n+      declare\n+         F           : ALFA_File_Record renames ALFA_File_Table.Table (J);\n+\n+         Start       : Scope_Index;\n+         Stop        : Scope_Index;\n+\n+         File        : Nat;\n+         Scope       : Nat;\n+         Entity_Line : Nat;\n+         Entity_Col  : Nat;\n+\n+      begin\n+         Start := F.From_Scope;\n+         Stop  := F.To_Scope;\n+\n+         --  Loop through scope entries for this file\n+\n+         loop\n+            exit when Start = Stop + 1;\n+            pragma Assert (Start <= Stop);\n+\n+            Output_One_Scope : declare\n+               S : ALFA_Scope_Record renames ALFA_Scope_Table.Table (Start);\n+\n+               XStart : Xref_Index;\n+               XStop  : Xref_Index;\n+\n+            begin\n+               XStart := S.From_Xref;\n+               XStop  := S.To_Xref;\n+\n+               if XStart > XStop then\n+                  goto Continue;\n+               end if;\n+\n+               Write_Info_Initiate ('F');\n+               Write_Info_Char ('X');\n+               Write_Info_Char (' ');\n+               Write_Info_Nat (F.File_Num);\n+               Write_Info_Char (' ');\n+\n+               for N in F.File_Name'Range loop\n+                  Write_Info_Char (F.File_Name (N));\n+               end loop;\n+\n+               Write_Info_Char (' ');\n+               Write_Info_Char ('.');\n+               Write_Info_Nat (S.Scope_Num);\n+               Write_Info_Char (' ');\n+\n+               for N in S.Scope_Name'Range loop\n+                  Write_Info_Char (S.Scope_Name (N));\n+               end loop;\n+\n+               File        := F.File_Num;\n+               Scope       := S.Scope_Num;\n+               Entity_Line := 0;\n+               Entity_Col  := 0;\n+\n+               --  Loop through cross reference entries for this scope\n+\n+               loop\n+                  exit when XStart = XStop + 1;\n+                  pragma Assert (XStart <= XStop);\n+\n+                  Output_One_Xref : declare\n+                     R : ALFA_Xref_Record renames\n+                           ALFA_Xref_Table.Table (XStart);\n+\n+                  begin\n+                     if R.Entity_Line /= Entity_Line\n+                       or else R.Entity_Col /= Entity_Col\n+                     then\n+                        Write_Info_Terminate;\n+\n+                        Write_Info_Initiate ('F');\n+                        Write_Info_Char (' ');\n+                        Write_Info_Nat (R.Entity_Line);\n+                        Write_Info_Char (' ');\n+                        Write_Info_Nat (R.Entity_Col);\n+                        Write_Info_Char (' ');\n+\n+                        for N in R.Entity_Name'Range loop\n+                           Write_Info_Char (R.Entity_Name (N));\n+                        end loop;\n+\n+                        Entity_Line := R.Entity_Line;\n+                        Entity_Col  := R.Entity_Col;\n+                     end if;\n+\n+                     if Write_Info_Col > 72 then\n+                        Write_Info_Terminate;\n+                        Write_Info_Initiate ('.');\n+                     end if;\n+\n+                     Write_Info_Char (' ');\n+\n+                     if R.File_Num /= File then\n+                        Write_Info_Nat (R.File_Num);\n+                        Write_Info_Char ('|');\n+                        File  := R.File_Num;\n+                        Scope := 0;\n+                     end if;\n+\n+                     if R.Scope_Num /= Scope then\n+                        Write_Info_Char ('.');\n+                        Write_Info_Nat (R.Scope_Num);\n+                        Write_Info_Char (':');\n+                        Scope := R.Scope_Num;\n+                     end if;\n+\n+                     Write_Info_Nat (R.Line);\n+                     Write_Info_Char (R.Rtype);\n+                     Write_Info_Nat (R.Col);\n+                  end Output_One_Xref;\n+\n+                  XStart := XStart + 1;\n+               end loop;\n+\n+               Write_Info_Terminate;\n+            end Output_One_Scope;\n+\n+         <<Continue>>\n+            Start := Start + 1;\n+         end loop;\n+      end;\n+   end loop;\n+end Put_ALFA;"}, {"sha": "70db554e2f847fee3fd6b8c2e38b6e27471727e0", "filename": "gcc/ada/put_alfa.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fput_alfa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fput_alfa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fput_alfa.ads?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                             P U T _ A L F A                              --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License --\n+-- for  more details.  You should have  received  a copy of the GNU General --\n+-- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n+-- http://www.gnu.org/licenses for a complete copy of the license.          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the function used to read ALFA information from the\n+--  internal tables defined in package ALFA, and output text information for\n+--  the ALI file. The interface allows control over the destination of the\n+--  output, so that this routine can also be used for debugging purposes.\n+\n+with Types; use Types;\n+\n+generic\n+   --  The following procedures are used to output text information. The\n+   --  destination of the text information is thus under control of the\n+   --  particular instantiation. In particular, this procedure is used to\n+   --  write output to the ALI file, and also for debugging output.\n+\n+   with function Write_Info_Col return Positive is <>;\n+   --  Return the column in which the next character will be written\n+\n+   with procedure Write_Info_Char (C : Character) is <>;\n+   --  Output one character\n+\n+   with procedure Write_Info_Initiate (Key : Character) is <>;\n+   --  Initiate write of new line to output file, the parameter is the\n+   --  keyword character for the line.\n+\n+   with procedure Write_Info_Nat (N : Nat) is <>;\n+   --  Write image of N to output file with no leading or trailing blanks\n+\n+   with procedure Write_Info_Terminate is <>;\n+   --  Terminate current info line and output lines built in Info_Buffer\n+\n+procedure Put_ALFA;\n+--  Read information from ALFA tables (ALFA.ALFA_Xref_Table,\n+--  ALFA.ALFA_Scope_Table and ALFA.ALFA_File_Table) and output corresponding\n+--  information in ALI format using the Write_Info procedures."}, {"sha": "84b1801b8ebeaa855168f5dfe47d2cb7b93ae5da", "filename": "gcc/ada/s-inmaop-vxworks.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fs-inmaop-vxworks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fs-inmaop-vxworks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-inmaop-vxworks.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -7,7 +7,7 @@\n --                                  B o d y                                 --\n --                                                                          --\n --             Copyright (C) 1991-1994, Florida State University            --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--                     Copyright (C) 1995-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -247,9 +247,15 @@ package body System.Interrupt_Management.Operations is\n \n    procedure Setup_Interrupt_Mask is\n    begin\n-      Raise_Exception\n-        (Program_Error'Identity,\n-         \"Setup_Interrupt_Mask unimplemented\");\n+      --  Nothing to be done. Ada interrupt facilities on VxWorks do not use\n+      --  signals but hardware interrupts. Therefore, interrupt management does\n+      --  not need anything related to signal masking. Note that this procedure\n+      --  cannot raise an exception (as some others in this package) because\n+      --  the generic implementation of the Timer_Server and timing events make\n+      --  explicit calls to this routine to make ensure proper signal masking\n+      --  on targets needed that.\n+\n+      null;\n    end Setup_Interrupt_Mask;\n \n end System.Interrupt_Management.Operations;"}, {"sha": "e433376db9ee147675f0900435edbd71caf5d204", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -1108,7 +1108,9 @@ package body Sem_Aggr is\n             --  allowed inside the array aggregate. The test checks the context\n             --  in which the array aggregate occurs. If the context does not\n             --  permit it, or the aggregate type is unconstrained, an OTHERS\n-            --  choice is not allowed.\n+            --  choice is not allowed (except that it is always allowed on the\n+            --  right-hand side of an assignment statement; in this case the\n+            --  constrainedness of the type doesn't matter).\n \n             --  If expansion is disabled (generic context, or semantics-only\n             --  mode) actual subtypes cannot be constructed, and the type of an\n@@ -1125,21 +1127,21 @@ package body Sem_Aggr is\n \n             Set_Etype (N, Aggr_Typ);  --  May be overridden later on\n \n-            if Is_Constrained (Typ) and then\n-              (Pkind = N_Assignment_Statement      or else\n-               Pkind = N_Parameter_Association     or else\n-               Pkind = N_Function_Call             or else\n-               Pkind = N_Procedure_Call_Statement  or else\n-               Pkind = N_Generic_Association       or else\n-               Pkind = N_Formal_Object_Declaration or else\n-               Pkind = N_Simple_Return_Statement   or else\n-               Pkind = N_Object_Declaration        or else\n-               Pkind = N_Component_Declaration     or else\n-               Pkind = N_Parameter_Specification   or else\n-               Pkind = N_Qualified_Expression      or else\n-               Pkind = N_Aggregate                 or else\n-               Pkind = N_Extension_Aggregate       or else\n-               Pkind = N_Component_Association)\n+            if Pkind = N_Assignment_Statement or else\n+              (Is_Constrained (Typ) and then\n+                 (Pkind = N_Parameter_Association     or else\n+                  Pkind = N_Function_Call             or else\n+                  Pkind = N_Procedure_Call_Statement  or else\n+                  Pkind = N_Generic_Association       or else\n+                  Pkind = N_Formal_Object_Declaration or else\n+                  Pkind = N_Simple_Return_Statement   or else\n+                  Pkind = N_Object_Declaration        or else\n+                  Pkind = N_Component_Declaration     or else\n+                  Pkind = N_Parameter_Specification   or else\n+                  Pkind = N_Qualified_Expression      or else\n+                  Pkind = N_Aggregate                 or else\n+                  Pkind = N_Extension_Aggregate       or else\n+                  Pkind = N_Component_Association))\n             then\n                Aggr_Resolved :=\n                  Resolve_Array_Aggregate"}, {"sha": "83c4e0a968dd5161c14a6d2287d398eabc5cc9c6", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -14793,7 +14793,7 @@ package body Sem_Ch3 is\n                Error_Msg_NE (\"invalid redeclaration of }\", Id, Prev);\n             end if;\n \n-            Set_Full_View (Prev,  Id);\n+            Set_Full_View (Prev, Id);\n             Append_Entity (Id, Current_Scope);\n             Set_Is_Public (Id, Is_Public (Prev));\n             Set_Is_Internal (Id);"}, {"sha": "ebc51619772e80911bc0877613b571c4de4bcb88", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -4156,24 +4156,18 @@ package body Sem_Prag is\n          elsif Is_Record_Type (Def_Id)\n            and then C = Convention_CPP\n          then\n-            --  Types treated as CPP classes are treated as limited, but we\n-            --  don't require them to be declared this way. A warning is issued\n-            --  to encourage the user to declare them as limited. This is not\n-            --  an error, for compatibility reasons, because these types have\n-            --  been supported this way for some time.\n+            --  Types treated as CPP classes must be declared limited (note:\n+            --  this used to be a warning but there is no real benefit to it\n+            --  since we did effectively intend to treat the type as limited\n+            --  anyway).\n \n             if not Is_Limited_Type (Def_Id) then\n                Error_Msg_N\n-                 (\"imported 'C'P'P type should be \" &\n-                    \"explicitly declared limited?\",\n-                  Get_Pragma_Arg (Arg2));\n-               Error_Msg_N\n-                 (\"\\type will be considered limited\",\n+                 (\"imported 'C'P'P type must be limited\",\n                   Get_Pragma_Arg (Arg2));\n             end if;\n \n             Set_Is_CPP_Class (Def_Id);\n-            Set_Is_Limited_Record (Def_Id);\n \n             --  Imported CPP types must not have discriminants (because C++\n             --  classes do not have discriminants).\n@@ -7053,24 +7047,18 @@ package body Sem_Prag is\n                Error_Pragma_Arg (\"pragma% applicable to tagged types \", Arg1);\n             end if;\n \n-            --  Types treated as CPP classes are treated as limited, but we\n-            --  don't require them to be declared this way. A warning is issued\n-            --  to encourage the user to declare them as limited. This is not\n-            --  an error, for compatibility reasons, because these types have\n-            --  been supported this way for some time.\n+            --  Types treated as CPP classes must be declared limited (note:\n+            --  this used to be a warning but there is no real benefit to it\n+            --  since we did effectively intend to treat the type as limited\n+            --  anyway).\n \n             if not Is_Limited_Type (Typ) then\n                Error_Msg_N\n-                 (\"imported 'C'P'P type should be \" &\n-                    \"explicitly declared limited?\",\n-                  Get_Pragma_Arg (Arg1));\n-               Error_Msg_N\n-                 (\"\\type will be considered limited\",\n+                 (\"imported 'C'P'P type must be limited\",\n                   Get_Pragma_Arg (Arg1));\n             end if;\n \n             Set_Is_CPP_Class      (Typ);\n-            Set_Is_Limited_Record (Typ);\n             Set_Convention        (Typ, Convention_CPP);\n \n             --  Imported CPP types must not have discriminants (because C++"}, {"sha": "85cd8509b89d172d981c62bc6a8876ca6f3c33bc", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -9906,13 +9906,23 @@ package body Sem_Res is\n             Index         : Node_Id;\n \n          begin\n-            Set_String_Literal_Low_Bound\n-              (Subtype_Id,\n-               Make_Attribute_Reference (Loc,\n-                 Attribute_Name => Name_First,\n-                 Prefix         =>\n-                   New_Occurrence_Of (Base_Type (Index_Type), Loc)));\n-            Set_Etype (String_Literal_Low_Bound (Subtype_Id), Index_Type);\n+            if Is_Integer_Type (Index_Type) then\n+               Set_String_Literal_Low_Bound\n+                 (Subtype_Id, Make_Integer_Literal (Loc, 1));\n+\n+            else\n+               --  If the index type is an enumeration type, build bounds\n+               --  expression with attributes.\n+\n+               Set_String_Literal_Low_Bound\n+                 (Subtype_Id,\n+                  Make_Attribute_Reference (Loc,\n+                    Attribute_Name => Name_First,\n+                    Prefix         =>\n+                      New_Occurrence_Of (Base_Type (Index_Type), Loc)));\n+               Set_Etype (String_Literal_Low_Bound (Subtype_Id), Index_Type);\n+            end if;\n+\n             Analyze_And_Resolve (String_Literal_Low_Bound (Subtype_Id));\n \n             --  Build bona fide subtype for the string, and wrap it in an"}, {"sha": "9db1643d51f36d2aae7d048155ba12aec5f6b635", "filename": "gcc/ada/xref_lib.adb", "status": "modified", "additions": 34, "deletions": 9, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fxref_lib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56e941863ba558a7a3426c686d6e5c08eefca90e/gcc%2Fada%2Fxref_lib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fxref_lib.adb?ref=56e941863ba558a7a3426c686d6e5c08eefca90e", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1998-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1998-2011, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1764,11 +1764,24 @@ package body Xref_Lib is\n          then\n             begin\n                Open (Ali_Name.all, ALIfile);\n-               while ALIfile.Buffer (ALIfile.Current_Line) /= EOF loop\n+\n+               --  The cross-reference section in the ALI file may be followed\n+               --  by other sections, which can be identified by the starting\n+               --  character of every line, which should neither be 'X' nor a\n+               --  figure in '1' .. '9'.\n+\n+               --  The loop tests below also take into account the end-of-file\n+               --  possibility.\n+\n+               while ALIfile.Buffer (ALIfile.Current_Line) = 'X' loop\n                   Parse_X_Filename (ALIfile);\n-                  Parse_Identifier_Info\n-                    (Pattern, ALIfile, Local_Symbols,\n-                     Der_Info, Type_Tree, Wide_Search, Labels_As_Ref => True);\n+\n+                  while ALIfile.Buffer (ALIfile.Current_Line) in '1' .. '9'\n+                  loop\n+                     Parse_Identifier_Info\n+                       (Pattern, ALIfile, Local_Symbols, Der_Info, Type_Tree,\n+                        Wide_Search, Labels_As_Ref => True);\n+                  end loop;\n                end loop;\n \n             exception\n@@ -1818,11 +1831,23 @@ package body Xref_Lib is\n             if Read_Only or else Is_Writable_File (F) then\n                Open (F, ALIfile, True);\n \n-               while ALIfile.Buffer (ALIfile.Current_Line) /= EOF loop\n+               --  The cross-reference section in the ALI file may be followed\n+               --  by other sections, which can be identified by the starting\n+               --  character of every line, which should neither be 'X' nor a\n+               --  figure in '1' .. '9'.\n+\n+               --  The loop tests below also take into account the end-of-file\n+               --  possibility.\n+\n+               while ALIfile.Buffer (ALIfile.Current_Line) = 'X' loop\n                   Parse_X_Filename (ALIfile);\n-                  Parse_Identifier_Info\n-                    (Null_Pattern, ALIfile, Local_Symbols, Der_Info,\n-                     Labels_As_Ref => False);\n+\n+                  while ALIfile.Buffer (ALIfile.Current_Line) in '1' .. '9'\n+                  loop\n+                     Parse_Identifier_Info\n+                       (Null_Pattern, ALIfile, Local_Symbols, Der_Info,\n+                        Labels_As_Ref => False);\n+                  end loop;\n                end loop;\n             end if;\n "}]}