{"sha": "f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZlNTBhN2Q2NGU5YjE2NWI1NGVkM2UzMzNhNjc5M2EwMTgzYzc3ZQ==", "commit": {"author": {"name": "Wish Wu", "email": "wishwu007@gmail.com", "date": "2017-09-06T14:30:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2017-09-06T14:30:46Z"}, "message": "asan.c (initialize_sanitizer_builtins): Add BT_FN_VOID_UINT8_UINT8...\n\n\t* asan.c (initialize_sanitizer_builtins): Add\n\tBT_FN_VOID_UINT8_UINT8, BT_FN_VOID_UINT16_UINT16,\n\tBT_FN_VOID_UINT32_UINT32, BT_FN_VOID_UINT64_UINT64,\n\tBT_FN_VOID_FLOAT_FLOAT, BT_FN_VOID_DOUBLE_DOUBLE and\n\tBT_FN_VOID_UINT64_PTR variables.\n\t* builtin-types.def (BT_FN_VOID_UINT8_UINT8): New fn type.\n\t(BT_FN_VOID_UINT16_UINT16): Likewise.\n\t(BT_FN_VOID_UINT32_UINT32): Likewise.\n\t(BT_FN_VOID_FLOAT_FLOAT): Likewise.\n\t(BT_FN_VOID_DOUBLE_DOUBLE): Likewise.\n\t(BT_FN_VOID_UINT64_PTR): Likewise.\n\t* common.opt (flag_sanitize_coverage): New variable.\n\t(fsanitize-coverage=trace-pc): Remove.\n\t(fsanitize-coverage=): Add.\n\t* flag-types.h (enum sanitize_coverage_code): New enum.\n\t* fold-const.c (fold_range_test): Disable non-short-circuit\n\toptimization if flag_sanitize_coverage.\n\t(fold_truth_andor): Likewise.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n\t* opts.c (COVERAGE_SANITIZER_OPT): Define.\n\t(coverage_sanitizer_opts): New array.\n\t(get_closest_sanitizer_option): Add OPTS argument, handle also\n\tOPT_fsanitize_coverage_.\n\t(parse_sanitizer_options): Adjusted to also handle\n\tOPT_fsanitize_coverage_.\n\t(common_handle_option): Add OPT_fsanitize_coverage_.\n\t* sancov.c (instrument_comparison, instrument_switch): New function.\n\t(sancov_pass): Add trace-cmp support.\n\t* sanitizer.def (BUILT_IN_SANITIZER_COV_TRACE_CMP1,\n\tBUILT_IN_SANITIZER_COV_TRACE_CMP2, BUILT_IN_SANITIZER_COV_TRACE_CMP4,\n\tBUILT_IN_SANITIZER_COV_TRACE_CMP8,\n\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP1,\n\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP2,\n\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP4,\n\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP8,\n\tBUILT_IN_SANITIZER_COV_TRACE_CMPF, BUILT_IN_SANITIZER_COV_TRACE_CMPD,\n\tBUILT_IN_SANITIZER_COV_TRACE_SWITCH): New builtins.\n\t* doc/invoke.texi: Document -fsanitize-coverage=trace-cmp.\n\n\t* gcc.dg/sancov/cmp0.c: New test.\n\nCo-Authored-By: Jakub Jelinek <jakub@redhat.com>\n\nFrom-SVN: r251801", "tree": {"sha": "a8dd0e66bf4e2c57b0422c8dc9ed9ab8e9e1ebfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8dd0e66bf4e2c57b0422c8dc9ed9ab8e9e1ebfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/comments", "author": null, "committer": null, "parents": [{"sha": "181613096914e3791c7ae68ad53a2fae571b9c5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/181613096914e3791c7ae68ad53a2fae571b9c5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/181613096914e3791c7ae68ad53a2fae571b9c5f"}], "stats": {"total": 576, "additions": 541, "deletions": 35}, "files": [{"sha": "c8851e6cb07caf4421dcc0875e95af2dc5360ac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -1,3 +1,45 @@\n+2017-09-06  Wish Wu  <wishwu007@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* asan.c (initialize_sanitizer_builtins): Add\n+\tBT_FN_VOID_UINT8_UINT8, BT_FN_VOID_UINT16_UINT16,\n+\tBT_FN_VOID_UINT32_UINT32, BT_FN_VOID_UINT64_UINT64,\n+\tBT_FN_VOID_FLOAT_FLOAT, BT_FN_VOID_DOUBLE_DOUBLE and\n+\tBT_FN_VOID_UINT64_PTR variables.\n+\t* builtin-types.def (BT_FN_VOID_UINT8_UINT8): New fn type.\n+\t(BT_FN_VOID_UINT16_UINT16): Likewise.\n+\t(BT_FN_VOID_UINT32_UINT32): Likewise.\n+\t(BT_FN_VOID_FLOAT_FLOAT): Likewise.\n+\t(BT_FN_VOID_DOUBLE_DOUBLE): Likewise.\n+\t(BT_FN_VOID_UINT64_PTR): Likewise.\n+\t* common.opt (flag_sanitize_coverage): New variable.\n+\t(fsanitize-coverage=trace-pc): Remove.\n+\t(fsanitize-coverage=): Add.\n+\t* flag-types.h (enum sanitize_coverage_code): New enum.\n+\t* fold-const.c (fold_range_test): Disable non-short-circuit\n+\toptimization if flag_sanitize_coverage.\n+\t(fold_truth_andor): Likewise.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n+\t* opts.c (COVERAGE_SANITIZER_OPT): Define.\n+\t(coverage_sanitizer_opts): New array.\n+\t(get_closest_sanitizer_option): Add OPTS argument, handle also\n+\tOPT_fsanitize_coverage_.\n+\t(parse_sanitizer_options): Adjusted to also handle\n+\tOPT_fsanitize_coverage_.\n+\t(common_handle_option): Add OPT_fsanitize_coverage_.\n+\t* sancov.c (instrument_comparison, instrument_switch): New function.\n+\t(sancov_pass): Add trace-cmp support.\n+\t* sanitizer.def (BUILT_IN_SANITIZER_COV_TRACE_CMP1,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CMP2, BUILT_IN_SANITIZER_COV_TRACE_CMP4,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CMP8,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP1,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP2,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP4,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CONST_CMP8,\n+\tBUILT_IN_SANITIZER_COV_TRACE_CMPF, BUILT_IN_SANITIZER_COV_TRACE_CMPD,\n+\tBUILT_IN_SANITIZER_COV_TRACE_SWITCH): New builtins.\n+\t* doc/invoke.texi: Document -fsanitize-coverage=trace-cmp.\n+\n 2017-09-06  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* config/arm/parsecpu.awk (fatal): Note that we've encountered an"}, {"sha": "2aa0a795af2016140b9fb743ea66c8f29f60556c", "filename": "gcc/asan.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -2709,6 +2709,29 @@ initialize_sanitizer_builtins (void)\n   tree BT_FN_SIZE_CONST_PTR_INT\n     = build_function_type_list (size_type_node, const_ptr_type_node,\n \t\t\t\tinteger_type_node, NULL_TREE);\n+\n+  tree BT_FN_VOID_UINT8_UINT8\n+    = build_function_type_list (void_type_node, unsigned_char_type_node,\n+\t\t\t\tunsigned_char_type_node, NULL_TREE);\n+  tree BT_FN_VOID_UINT16_UINT16\n+    = build_function_type_list (void_type_node, uint16_type_node,\n+\t\t\t\tuint16_type_node, NULL_TREE);\n+  tree BT_FN_VOID_UINT32_UINT32\n+    = build_function_type_list (void_type_node, uint32_type_node,\n+\t\t\t\tuint32_type_node, NULL_TREE);\n+  tree BT_FN_VOID_UINT64_UINT64\n+    = build_function_type_list (void_type_node, uint64_type_node,\n+\t\t\t\tuint64_type_node, NULL_TREE);\n+  tree BT_FN_VOID_FLOAT_FLOAT\n+    = build_function_type_list (void_type_node, float_type_node,\n+\t\t\t\tfloat_type_node, NULL_TREE);\n+  tree BT_FN_VOID_DOUBLE_DOUBLE\n+    = build_function_type_list (void_type_node, double_type_node,\n+\t\t\t\tdouble_type_node, NULL_TREE);\n+  tree BT_FN_VOID_UINT64_PTR\n+    = build_function_type_list (void_type_node, uint64_type_node,\n+\t\t\t\tptr_type_node, NULL_TREE);\n+\n   tree BT_FN_BOOL_VPTR_PTR_IX_INT_INT[5];\n   tree BT_FN_IX_CONST_VPTR_INT[5];\n   tree BT_FN_IX_VPTR_IX_INT[5];"}, {"sha": "1894603350280c738b14d3bab9570105647516c4", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -338,8 +338,20 @@ DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTRMODE_PTR,\n \t\t     BT_VOID, BT_PTRMODE, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTRMODE,\n \t\t     BT_VOID, BT_PTR, BT_PTRMODE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT8_UINT8,\n+     \t\t     BT_VOID, BT_UINT8, BT_UINT8)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT16_UINT16,\n+     \t\t     BT_VOID, BT_UINT16, BT_UINT16)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT32_UINT32,\n+     \t\t     BT_VOID, BT_UINT32, BT_UINT32)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT64_UINT64,\n      \t\t     BT_VOID, BT_UINT64, BT_UINT64)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_FLOAT_FLOAT,\n+     \t\t     BT_VOID, BT_FLOAT, BT_FLOAT)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_DOUBLE_DOUBLE,\n+     \t\t     BT_VOID, BT_DOUBLE, BT_DOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_UINT64_PTR,\n+     \t\t     BT_VOID, BT_UINT64, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_VOID_VALIST_REF_VALIST_ARG,\n \t\t     BT_VOID, BT_VALIST_REF, BT_VALIST_ARG)\n DEF_FUNCTION_TYPE_2 (BT_FN_LONG_LONG_LONG,"}, {"sha": "0873fb9436fff16602f4d5650627529c58af24bd", "filename": "gcc/common.opt", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -233,10 +233,9 @@ unsigned int flag_sanitize\n Variable\n unsigned int flag_sanitize_recover = (SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT | SANITIZE_KERNEL_ADDRESS) & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN)\n \n-fsanitize-coverage=trace-pc\n-Common Report Var(flag_sanitize_coverage)\n-Enable coverage-guided fuzzing code instrumentation.\n-Inserts call to __sanitizer_cov_trace_pc into every basic block.\n+; What the coverage sanitizers should instrument\n+Variable\n+unsigned int flag_sanitize_coverage\n \n ; Flag whether a prefix has been added to dump_base_name\n Variable\n@@ -982,6 +981,10 @@ fsanitize=\n Common Driver Report Joined\n Select what to sanitize.\n \n+fsanitize-coverage=\n+Common Report Joined\n+Select what to coverage sanitize.\n+\n fasan-shadow-offset=\n Common Joined RejectNegative Var(common_deferred_options) Defer\n -fasan-shadow-offset=<number>\tUse custom shadow memory offset."}, {"sha": "88edc937d862e959883c7f2d08cd833469c347c4", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -11169,6 +11169,20 @@ is usable even in freestanding environments.\n Enable coverage-guided fuzzing code instrumentation.\n Inserts a call to @code{__sanitizer_cov_trace_pc} into every basic block.\n \n+@item -fsanitize-coverage=trace-cmp\n+@opindex fsanitize-coverage=trace-cmp\n+Enable dataflow guided fuzzing code instrumentation.\n+Inserts a call to @code{__sanitizer_cov_trace_cmp1},\n+@code{__sanitizer_cov_trace_cmp2}, @code{__sanitizer_cov_trace_cmp4} or\n+@code{__sanitizer_cov_trace_cmp8} for integral comparison with both operands\n+variable or @code{__sanitizer_cov_trace_const_cmp1},\n+@code{__sanitizer_cov_trace_const_cmp2},\n+@code{__sanitizer_cov_trace_const_cmp4} or\n+@code{__sanitizer_cov_trace_const_cmp8} for integral comparison with one\n+operand constant, @code{__sanitizer_cov_trace_cmpf} or\n+@code{__sanitizer_cov_trace_cmpd} for float or double comparisons and\n+@code{__sanitizer_cov_trace_switch} for switch statements.\n+\n @item -fbounds-check\n @opindex fbounds-check\n For front ends that support it, generate additional code to check that"}, {"sha": "4938f69b1b6f5adad96243c8f2f1d454949bd201", "filename": "gcc/flag-types.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -252,6 +252,14 @@ enum sanitize_code {\n \t\t\t\t  | SANITIZE_BOUNDS_STRICT\n };\n \n+/* Different trace modes.  */\n+enum sanitize_coverage_code {\n+  /* Trace PC.  */\n+  SANITIZE_COV_TRACE_PC = 1 << 0,\n+  /* Trace Comparison.  */\n+  SANITIZE_COV_TRACE_CMP = 1 << 1\n+};\n+\n /* flag_vtable_verify initialization levels. */\n enum vtv_priority {\n   VTV_NO_PRIORITY       = 0,  /* i.E. Do NOT do vtable verification. */"}, {"sha": "16bf45694bfe5e301caa527542d861be49c0647d", "filename": "gcc/fold-const.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -5394,6 +5394,7 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n      short-circuited branch and the underlying object on both sides\n      is the same, make a non-short-circuit operation.  */\n   else if (LOGICAL_OP_NON_SHORT_CIRCUIT\n+\t   && !flag_sanitize_coverage\n \t   && lhs != 0 && rhs != 0\n \t   && (code == TRUTH_ANDIF_EXPR\n \t       || code == TRUTH_ORIF_EXPR)\n@@ -8047,6 +8048,7 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n     return tem;\n \n   if (LOGICAL_OP_NON_SHORT_CIRCUIT\n+      && !flag_sanitize_coverage\n       && (code == TRUTH_AND_EXPR\n           || code == TRUTH_ANDIF_EXPR\n           || code == TRUTH_OR_EXPR"}, {"sha": "5aa5d066dbe29efd284cca231867021f0da4b0d1", "filename": "gcc/opts.c", "status": "modified", "additions": 51, "deletions": 19, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -1526,6 +1526,17 @@ const struct sanitizer_opts_s sanitizer_opts[] =\n   { NULL, 0U, 0UL, false }\n };\n \n+/* -f{,no-}sanitize-coverage= suboptions.  */\n+const struct sanitizer_opts_s coverage_sanitizer_opts[] =\n+{\n+#define COVERAGE_SANITIZER_OPT(name, flags) \\\n+    { #name, flags, sizeof #name - 1, true }\n+  COVERAGE_SANITIZER_OPT (trace-pc, SANITIZE_COV_TRACE_PC),\n+  COVERAGE_SANITIZER_OPT (trace-cmp, SANITIZE_COV_TRACE_CMP),\n+#undef COVERAGE_SANITIZER_OPT\n+  { NULL, 0U, 0UL, false }\n+};\n+\n /* A struct for describing a run of chars within a string.  */\n \n struct string_fragment\n@@ -1556,31 +1567,34 @@ struct edit_distance_traits<const string_fragment &>\n \n /* Given ARG, an unrecognized sanitizer option, return the best\n    matching sanitizer option, or NULL if there isn't one.\n-   CODE is OPT_fsanitize_ or OPT_fsanitize_recover_.\n+   OPTS is array of candidate sanitizer options.\n+   CODE is OPT_fsanitize_, OPT_fsanitize_recover_ or\n+   OPT_fsanitize_coverage_.\n    VALUE is non-zero for the regular form of the option, zero\n    for the \"no-\" form (e.g. \"-fno-sanitize-recover=\").  */\n \n static const char *\n get_closest_sanitizer_option (const string_fragment &arg,\n+\t\t\t      const struct sanitizer_opts_s *opts,\n \t\t\t      enum opt_code code, int value)\n {\n   best_match <const string_fragment &, const char*> bm (arg);\n-  for (int i = 0; sanitizer_opts[i].name != NULL; ++i)\n+  for (int i = 0; opts[i].name != NULL; ++i)\n     {\n       /* -fsanitize=all is not valid, so don't offer it.  */\n-      if (sanitizer_opts[i].flag == ~0U\n-\t  && code == OPT_fsanitize_\n+      if (code == OPT_fsanitize_\n+\t  && opts[i].flag == ~0U\n \t  && value)\n \tcontinue;\n \n       /* For -fsanitize-recover= (and not -fno-sanitize-recover=),\n \t don't offer the non-recoverable options.  */\n-      if (!sanitizer_opts[i].can_recover\n-\t  && code == OPT_fsanitize_recover_\n+      if (code == OPT_fsanitize_recover_\n+\t  && !opts[i].can_recover\n \t  && value)\n \tcontinue;\n \n-      bm.consider (sanitizer_opts[i].name);\n+      bm.consider (opts[i].name);\n     }\n   return bm.get_best_meaningful_candidate ();\n }\n@@ -1594,6 +1608,13 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t\t\t unsigned int flags, int value, bool complain)\n {\n   enum opt_code code = (enum opt_code) scode;\n+\n+  const struct sanitizer_opts_s *opts;\n+  if (code == OPT_fsanitize_coverage_)\n+    opts = coverage_sanitizer_opts;\n+  else\n+    opts = sanitizer_opts;\n+\n   while (*p != 0)\n     {\n       size_t len, i;\n@@ -1611,12 +1632,11 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t}\n \n       /* Check to see if the string matches an option class name.  */\n-      for (i = 0; sanitizer_opts[i].name != NULL; ++i)\n-\tif (len == sanitizer_opts[i].len\n-\t    && memcmp (p, sanitizer_opts[i].name, len) == 0)\n+      for (i = 0; opts[i].name != NULL; ++i)\n+\tif (len == opts[i].len && memcmp (p, opts[i].name, len) == 0)\n \t  {\n \t    /* Handle both -fsanitize and -fno-sanitize cases.  */\n-\t    if (value && sanitizer_opts[i].flag == ~0U)\n+\t    if (value && opts[i].flag == ~0U)\n \t      {\n \t\tif (code == OPT_fsanitize_)\n \t\t  {\n@@ -1633,14 +1653,14 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t\t   -fsanitize-recover=return if -fsanitize-recover=undefined\n \t\t   is selected.  */\n \t\tif (code == OPT_fsanitize_recover_\n-\t\t    && sanitizer_opts[i].flag == SANITIZE_UNDEFINED)\n+\t\t    && opts[i].flag == SANITIZE_UNDEFINED)\n \t\t  flags |= (SANITIZE_UNDEFINED\n \t\t\t    & ~(SANITIZE_UNREACHABLE | SANITIZE_RETURN));\n \t\telse\n-\t\t  flags |= sanitizer_opts[i].flag;\n+\t\t  flags |= opts[i].flag;\n \t      }\n \t    else\n-\t      flags &= ~sanitizer_opts[i].flag;\n+\t      flags &= ~opts[i].flag;\n \t    found = true;\n \t    break;\n \t  }\n@@ -1649,21 +1669,27 @@ parse_sanitizer_options (const char *p, location_t loc, int scode,\n \t{\n \t  const char *hint\n \t    = get_closest_sanitizer_option (string_fragment (p, len),\n-\t\t\t\t\t    code, value);\n+\t\t\t\t\t    opts, code, value);\n+\n+\t  const char *suffix;\n+\t  if (code == OPT_fsanitize_recover_)\n+\t    suffix = \"-recover\";\n+\t  else if (code == OPT_fsanitize_coverage_)\n+\t    suffix = \"-coverage\";\n+\t  else\n+\t    suffix = \"\";\n \n \t  if (hint)\n \t    error_at (loc,\n \t\t      \"unrecognized argument to -f%ssanitize%s= option: %q.*s;\"\n \t\t      \" did you mean %qs?\",\n \t\t      value ? \"\" : \"no-\",\n-\t\t      code == OPT_fsanitize_ ? \"\" : \"-recover\",\n-\t\t      (int) len, p, hint);\n+\t\t      suffix, (int) len, p, hint);\n \t  else\n \t    error_at (loc,\n \t\t      \"unrecognized argument to -f%ssanitize%s= option: %q.*s\",\n \t\t      value ? \"\" : \"no-\",\n-\t\t      code == OPT_fsanitize_ ? \"\" : \"-recover\",\n-\t\t      (int) len, p);\n+\t\t      suffix, (int) len, p);\n \t}\n \n       if (comma == NULL)\n@@ -1956,6 +1982,12 @@ common_handle_option (struct gcc_options *opts,\n \t  &= ~(SANITIZE_UNDEFINED | SANITIZE_UNDEFINED_NONDEFAULT);\n       break;\n \n+    case OPT_fsanitize_coverage_:\n+      opts->x_flag_sanitize_coverage\n+\t= parse_sanitizer_options (arg, loc, code,\n+\t\t\t\t   opts->x_flag_sanitize_coverage, value, true);\n+      break;\n+\n     case OPT_O:\n     case OPT_Os:\n     case OPT_Ofast:"}, {"sha": "2f8d5681e4f18028b738af5fbfaa6d49033359de", "filename": "gcc/sancov.c", "status": "modified", "additions": 251, "deletions": 11, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fsancov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fsancov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsancov.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -1,6 +1,7 @@\n /* Code coverage instrumentation for fuzzing.\n    Copyright (C) 2015-2017 Free Software Foundation, Inc.\n-   Contributed by Dmitry Vyukov <dvyukov@google.com>\n+   Contributed by Dmitry Vyukov <dvyukov@google.com> and\n+   Wish Wu <wishwu007@gmail.com>\n \n This file is part of GCC.\n \n@@ -29,32 +30,271 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"stmt.h\"\n #include \"gimple-iterator.h\"\n+#include \"gimple-builder.h\"\n #include \"tree-cfg.h\"\n #include \"tree-pass.h\"\n #include \"tree-iterator.h\"\n+#include \"fold-const.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"output.h\"\n+#include \"cgraph.h\"\n #include \"asan.h\"\n \n namespace {\n \n+/* Instrument one comparison operation, which compares lhs and rhs.\n+   Call the instrumentation function with the comparison operand.\n+   For integral comparisons if exactly one of the comparison operands is\n+   constant, call __sanitizer_cov_trace_const_cmp* instead of\n+   __sanitizer_cov_trace_cmp*.  */\n+\n+static void\n+instrument_comparison (gimple_stmt_iterator *gsi, tree lhs, tree rhs)\n+{\n+  tree type = TREE_TYPE (lhs);\n+  enum built_in_function fncode = END_BUILTINS;\n+  tree to_type = NULL_TREE;\n+  bool c = false;\n+\n+  if (INTEGRAL_TYPE_P (type))\n+    {\n+      c = (is_gimple_min_invariant (lhs)\n+\t   ^ is_gimple_min_invariant (rhs));\n+      switch (int_size_in_bytes (type))\n+\t{\n+\tcase 1:\n+      \t  fncode = c ? BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP1\n+\t\t     : BUILT_IN_SANITIZER_COV_TRACE_CMP1;\n+\t  to_type = unsigned_char_type_node;\n+\t  break;\n+\tcase 2:\n+      \t  fncode = c ? BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP2\n+\t\t     : BUILT_IN_SANITIZER_COV_TRACE_CMP2;\n+\t  to_type = uint16_type_node;\n+\t  break;\n+\tcase 4:\n+      \t  fncode = c ? BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP4\n+\t\t     : BUILT_IN_SANITIZER_COV_TRACE_CMP4;\n+\t  to_type = uint32_type_node;\n+\t  break;\n+\tdefault:\n+      \t  fncode = c ? BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP8\n+\t\t     : BUILT_IN_SANITIZER_COV_TRACE_CMP8;\n+\t  to_type = uint64_type_node;\n+\t  break;\n+\t}\n+    }\n+  else if (SCALAR_FLOAT_TYPE_P (type))\n+    {\n+      if (TYPE_MODE (type) == TYPE_MODE (float_type_node))\n+\t{\n+      \t  fncode = BUILT_IN_SANITIZER_COV_TRACE_CMPF;\n+\t  to_type = float_type_node;\n+\t}\n+      else if (TYPE_MODE (type) == TYPE_MODE (double_type_node))\n+\t{\n+      \t  fncode = BUILT_IN_SANITIZER_COV_TRACE_CMPD;\n+\t  to_type = double_type_node;\n+\t}\n+    }\n+\n+  if (to_type != NULL_TREE)\n+    {\n+      gimple_seq seq = NULL;\n+\n+      if (!useless_type_conversion_p (to_type, type))\n+\t{\n+\t  if (TREE_CODE (lhs) == INTEGER_CST)\n+\t    lhs = fold_convert (to_type, lhs);\n+\t  else\n+\t    {\n+\t      gimple_seq_add_stmt (&seq, build_type_cast (to_type, lhs));\n+\t      lhs = gimple_assign_lhs (gimple_seq_last_stmt (seq));\n+\t    }\n+\n+\t  if (TREE_CODE (rhs) == INTEGER_CST)\n+\t    rhs = fold_convert (to_type, rhs);\n+\t  else\n+\t    {\n+\t      gimple_seq_add_stmt (&seq, build_type_cast (to_type, rhs));\n+\t      rhs = gimple_assign_lhs (gimple_seq_last_stmt (seq));\n+\t    }\n+\t}\n+\n+      if (c && !is_gimple_min_invariant (lhs))\n+\tstd::swap (lhs, rhs);\n+\n+      tree fndecl = builtin_decl_implicit (fncode);\n+      gimple *gcall = gimple_build_call (fndecl, 2, lhs, rhs);\n+      gimple_seq_add_stmt (&seq, gcall);\n+\n+      gimple_seq_set_location (seq, gimple_location (gsi_stmt (*gsi)));\n+      gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n+    }\n+}\n+\n+/* Instrument switch statement.  Call __sanitizer_cov_trace_switch with\n+   the value of the index and array that contains number of case values,\n+   the bitsize of the index and the case values converted to uint64_t.  */\n+\n+static void\n+instrument_switch (gimple_stmt_iterator *gsi, gimple *stmt, function *fun)\n+{\n+  gswitch *switch_stmt = as_a<gswitch *> (stmt);\n+  tree index = gimple_switch_index (switch_stmt);\n+  HOST_WIDE_INT size_in_bytes = int_size_in_bytes (TREE_TYPE (index));\n+  if (size_in_bytes == -1 || size_in_bytes > 8)\n+    return;\n+\n+  location_t loc = gimple_location (stmt);\n+  unsigned i, n = gimple_switch_num_labels (switch_stmt), num = 0;\n+  for (i = 1; i < n; ++i)\n+    {\n+      tree label = gimple_switch_label (switch_stmt, i);\n+\n+      tree low_case = CASE_LOW (label);\n+      if (low_case != NULL_TREE)\n+\tnum++;\n+\n+      tree high_case = CASE_HIGH (label);\n+      if (high_case != NULL_TREE)\n+\tnum++;\n+    }\n+\n+  tree case_array_type\n+   = build_array_type (build_type_variant (uint64_type_node, 1, 0),\n+\t\t       build_index_type (size_int (num + 2 - 1)));\n+\n+  char name[64];\n+  static size_t case_array_count = 0;\n+  ASM_GENERATE_INTERNAL_LABEL (name, \"LCASEARRAY\", case_array_count++);\n+  tree case_array_var = build_decl (loc, VAR_DECL, get_identifier (name),\n+\t\t\t\t    case_array_type);\n+  TREE_STATIC (case_array_var) = 1;\n+  TREE_PUBLIC (case_array_var) = 0;\n+  TREE_CONSTANT (case_array_var) = 1;\n+  TREE_READONLY (case_array_var) = 1;\n+  DECL_EXTERNAL (case_array_var) = 0;\n+  DECL_ARTIFICIAL (case_array_var) = 1;\n+  DECL_IGNORED_P (case_array_var) = 1;\n+\n+  vec <constructor_elt, va_gc> *v = NULL;\n+  vec_alloc (v, num + 2);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  build_int_cst (uint64_type_node, num));\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t  build_int_cst (uint64_type_node,\n+\t\t\t\t\t size_in_bytes * BITS_PER_UNIT));\n+  for (i = 1; i < n; ++i)\n+    {\n+      tree label = gimple_switch_label (switch_stmt, i);\n+\n+      tree low_case = CASE_LOW (label);\n+      if (low_case != NULL_TREE)\n+\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\tfold_convert (uint64_type_node, low_case));\n+\n+      tree high_case = CASE_HIGH (label);\n+      if (high_case != NULL_TREE)\n+\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t\tfold_convert (uint64_type_node, high_case));\n+    }\n+  tree ctor = build_constructor (case_array_type, v);\n+  TREE_STATIC (ctor) = 1;\n+  TREE_PUBLIC (ctor) = 0;\n+  TREE_CONSTANT (ctor) = 1;\n+  TREE_READONLY (ctor) = 1;\n+  DECL_INITIAL (case_array_var) = ctor;\n+  varpool_node::finalize_decl (case_array_var);\n+  add_local_decl (fun, case_array_var);\n+\n+  gimple_seq seq = NULL;\n+\n+  if (!useless_type_conversion_p (uint64_type_node, TREE_TYPE (index)))\n+    {\n+      if (TREE_CODE (index) == INTEGER_CST)\n+\tindex = fold_convert (uint64_type_node, index);\n+      else\n+\t{\n+\t  gimple_seq_add_stmt (&seq, build_type_cast (uint64_type_node, index));\n+\t  index = gimple_assign_lhs (gimple_seq_last_stmt (seq));\n+\t}\n+    }\n+\n+  tree fndecl = builtin_decl_implicit (BUILT_IN_SANITIZER_COV_TRACE_SWITCH);\n+  gimple *gcall = gimple_build_call (fndecl, 2, index,\n+\t\t\t\t     build_fold_addr_expr (case_array_var));\n+  gimple_seq_add_stmt (&seq, gcall);\n+\n+  gimple_seq_set_location (seq, loc);\n+  gsi_insert_seq_before (gsi, seq, GSI_SAME_STMT);\n+}\n+\n unsigned\n sancov_pass (function *fun)\n {\n   initialize_sanitizer_builtins ();\n \n   /* Insert callback into beginning of every BB. */\n-  tree fndecl = builtin_decl_implicit (BUILT_IN_SANITIZER_COV_TRACE_PC);\n-  basic_block bb;\n-  FOR_EACH_BB_FN (bb, fun)\n+  if (flag_sanitize_coverage & SANITIZE_COV_TRACE_PC)\n     {\n-      gimple_stmt_iterator gsi = gsi_start_nondebug_after_labels_bb (bb);\n-      if (gsi_end_p (gsi))\n-\tcontinue;\n-      gimple *stmt = gsi_stmt (gsi);\n-      gimple *gcall = gimple_build_call (fndecl, 0);\n-      gimple_set_location (gcall, gimple_location (stmt));\n-      gsi_insert_before (&gsi, gcall, GSI_SAME_STMT);\n+      basic_block bb;\n+      tree fndecl = builtin_decl_implicit (BUILT_IN_SANITIZER_COV_TRACE_PC);\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  gimple_stmt_iterator gsi = gsi_start_nondebug_after_labels_bb (bb);\n+\t  if (gsi_end_p (gsi))\n+\t    continue;\n+\t  gimple *stmt = gsi_stmt (gsi);\n+\t  gimple *gcall = gimple_build_call (fndecl, 0);\n+\t  gimple_set_location (gcall, gimple_location (stmt));\n+\t  gsi_insert_before (&gsi, gcall, GSI_SAME_STMT);\n+\t}\n+    }\n+\n+  /* Insert callback into every comparison related operation.  */\n+  if (flag_sanitize_coverage & SANITIZE_COV_TRACE_CMP)\n+    {\n+      basic_block bb;\n+      FOR_EACH_BB_FN (bb, fun)\n+\t{\n+\t  gimple_stmt_iterator gsi;\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple *stmt = gsi_stmt (gsi);\n+\t      enum tree_code rhs_code;\n+\t      switch (gimple_code (stmt))\n+\t\t{\n+\t\tcase GIMPLE_ASSIGN:\n+\t\t  rhs_code = gimple_assign_rhs_code (stmt);\n+\t\t  if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+\t\t    instrument_comparison (&gsi,\n+\t\t\t\t\t   gimple_assign_rhs1 (stmt),\n+\t\t\t\t\t   gimple_assign_rhs2 (stmt));\n+\t\t  else if (rhs_code == COND_EXPR\n+\t\t\t   && COMPARISON_CLASS_P (gimple_assign_rhs1 (stmt)))\n+\t\t    {\n+\t\t      tree cond = gimple_assign_rhs1 (stmt);\n+\t\t      instrument_comparison (&gsi, TREE_OPERAND (cond, 0),\n+\t\t\t\t\t     TREE_OPERAND (cond, 1));\n+\t\t    }\n+\t\t  break;\n+\t\tcase GIMPLE_COND:\n+\t\t  instrument_comparison (&gsi,\n+\t\t\t\t\t gimple_cond_lhs (stmt),\n+\t\t\t\t\t gimple_cond_rhs (stmt));\n+\t\t  break;\n+\n+\t\tcase GIMPLE_SWITCH:\n+\t\t  instrument_switch (&gsi, stmt, fun);\n+\t\t  break;\n+\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n     }\n   return 0;\n }"}, {"sha": "9d963f05c21d67d667c653344740fac7cd096357", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -537,6 +537,39 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_UBSAN_HANDLE_DYNAMIC_TYPE_CACHE_MISS_ABORT,\n DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_PC,\n \t\t      \"__sanitizer_cov_trace_pc\",\n \t\t      BT_FN_VOID, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMP1,\n+\t\t      \"__sanitizer_cov_trace_cmp1\",\n+\t\t      BT_FN_VOID_UINT8_UINT8, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMP2,\n+\t\t      \"__sanitizer_cov_trace_cmp2\",\n+\t\t      BT_FN_VOID_UINT16_UINT16, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMP4,\n+\t\t      \"__sanitizer_cov_trace_cmp4\",\n+\t\t      BT_FN_VOID_UINT32_UINT32, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMP8,\n+\t\t      \"__sanitizer_cov_trace_cmp8\",\n+\t\t      BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP1,\n+\t\t      \"__sanitizer_cov_trace_const_cmp1\",\n+\t\t      BT_FN_VOID_UINT8_UINT8, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP2,\n+\t\t      \"__sanitizer_cov_trace_const_cmp2\",\n+\t\t      BT_FN_VOID_UINT16_UINT16, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP4,\n+\t\t      \"__sanitizer_cov_trace_const_cmp4\",\n+\t\t      BT_FN_VOID_UINT32_UINT32, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CONST_CMP8,\n+\t\t      \"__sanitizer_cov_trace_const_cmp8\",\n+\t\t      BT_FN_VOID_UINT64_UINT64, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMPF,\n+\t\t      \"__sanitizer_cov_trace_cmpf\",\n+\t\t      BT_FN_VOID_FLOAT_FLOAT, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_CMPD,\n+\t\t      \"__sanitizer_cov_trace_cmpd\",\n+\t\t      BT_FN_VOID_DOUBLE_DOUBLE, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_SANITIZER_COV_TRACE_SWITCH,\n+\t\t      \"__sanitizer_cov_trace_switch\",\n+\t\t      BT_FN_VOID_UINT64_PTR, ATTR_NOTHROW_LEAF_LIST)\n \n /* This has to come after all the sanitizer builtins.  */\n DEF_BUILTIN_STUB(END_SANITIZER_BUILTINS, (const char *)0)"}, {"sha": "cd283c0a4093cc89df44ff4a5924f8016e6f3435", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -1,3 +1,8 @@\n+2017-09-06  Wish Wu  <wishwu007@gmail.com>\n+\t    Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/sancov/cmp0.c: New test.\n+\n 2017-09-06  Richard Biener  <rguenther@suse.de>\n \n \t* gcc.c-torture/execute/20050604-1.c: Adjust to be a better"}, {"sha": "3a17de91ce29625a732595a33d3f97f207a27672", "filename": "gcc/testsuite/gcc.dg/sancov/cmp0.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsancov%2Fcmp0.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -0,0 +1,92 @@\n+/* Basic test on number of inserted callbacks.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize-coverage=trace-cmp -fdump-tree-optimized\" } */\n+\n+void\n+foo (char *a, short *b, int *c, long long *d, float *e, double *f)\n+{\n+  if (*a)\n+    *a += 1;\n+  if (*b)\n+    *b = *a;\n+  if (*c)\n+    *c += 1;\n+  if (*d)\n+    *d = *c;\n+  if (*e == *c)\n+    *e = *c;\n+  if (*f == *e)\n+    *f = *e;\n+  switch (*a)\n+    {\n+    case 2:\n+      *b += 2;\n+      break;\n+    case 3:\n+      *b += 3;\n+      break;\n+    case 4:\n+      *b += 4;\n+      break;\n+    case 5:\n+      *b += 5;\n+      break;\n+    case 6:\n+      *b += 6;\n+      break;\n+    case 7 ... 24:\n+      *b += 7;\n+      break;\n+    default:\n+      break;\n+    }\n+  switch (*d)\n+    {\n+    case 3:\n+      *d += 3;\n+    case -4:\n+      *d -= 4;\n+    case -5:\n+      *d -= 5;\n+    case -6:\n+      *d -= 6;\n+    case -7:\n+      *d -= 7;\n+    case -8:\n+      *d -= 8;\n+    case -9:\n+      *d -= 9;\n+    case -10:\n+      *d -= 10;\n+    }\n+}\n+\n+void\n+bar (int *c)\n+{\n+  if (*c == 27)\n+    *c += 2;\n+  if (*c == 37)\n+    *c += 2;\n+}\n+\n+int\n+baz (int *c, long long d, long long e)\n+{\n+  *c = (*c == 48) ? 12 : 24;\n+  return d == e;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp1 \\\\(0, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp2 \\\\(0, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp4 \\\\(0, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp8 \\\\(0, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp4 \\\\(27, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp4 \\\\(37, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp4 \\\\(48, \" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_cmp8 \\\\(\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_cmpf \\\\(\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_cmpd \\\\(\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_const_cmp\" 7 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_cmp\" 3 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"__builtin___sanitizer_cov_trace_switch \\\\(\" 2 \"optimized\" } } */"}, {"sha": "a211335889b1d4c1fce2fa3c0e37f3f3c30f103d", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6e50a7d64e9b165b54ed3e333a6793a0183c77e/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=f6e50a7d64e9b165b54ed3e333a6793a0183c77e", "patch": "@@ -560,7 +560,7 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \t{\n \t  tree t1, t2;\n \t  gimple_stmt_iterator gsi;\n-\t  if (!LOGICAL_OP_NON_SHORT_CIRCUIT)\n+\t  if (!LOGICAL_OP_NON_SHORT_CIRCUIT || flag_sanitize_coverage)\n \t    return false;\n \t  /* Only do this optimization if the inner bb contains only the conditional. */\n \t  if (!gsi_one_before_end_p (gsi_start_nondebug_after_labels_bb (inner_cond_bb)))"}]}