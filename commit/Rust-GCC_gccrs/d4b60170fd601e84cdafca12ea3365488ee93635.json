{"sha": "d4b60170fd601e84cdafca12ea3365488ee93635", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiNjAxNzBmZDYwMWU4NGNkYWZjYTEyZWEzMzY1NDg4ZWU5MzYzNQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "1999-12-18T21:33:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1999-12-18T21:33:23Z"}, "message": "alias.c: Minor reformatting.\n\n\t* alias.c: Minor reformatting.\n\t* flow.c: Likewise.\n\t* regs.h: Likewise.\n\t* stor-layout.c: Likewise.\n\t* fold-const.c: Likewise.\n \t(OVERFLOW_SUM_SIGN): Renamed from overflow_sum_sign.\n\t(struct cb_args, const_binop_1, const_binop): Pass type of arg,\n\tnot arg itself.\n\t(size_int_wide): Cache nodes even if garbage collecting.\n\t(twoval_comparison_p): Reenable SAVE_EXPR case if operand\n\tof SAVE_EXPR has no side effects.\n\t* cse.c: Move a comment.\n\t* tree.c: Minor reformatting.\n\t(int_size_in_bytes): Return -1 if constant overflows.\n\t* reload.c (combine_reloads): Do nothing if no output reload\n\nFrom-SVN: r31017", "tree": {"sha": "b29d6812261abeb25b182a176f35382f12cb98bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b29d6812261abeb25b182a176f35382f12cb98bd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4b60170fd601e84cdafca12ea3365488ee93635", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b60170fd601e84cdafca12ea3365488ee93635", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4b60170fd601e84cdafca12ea3365488ee93635", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4b60170fd601e84cdafca12ea3365488ee93635/comments", "author": null, "committer": null, "parents": [{"sha": "3f0aabf20a84ccd50d38dca8f252f887558d31ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f0aabf20a84ccd50d38dca8f252f887558d31ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f0aabf20a84ccd50d38dca8f252f887558d31ff"}], "stats": {"total": 745, "additions": 416, "deletions": 329}, "files": [{"sha": "fd8a0b67fb52916efed17fa6340553245ef70872", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -1,3 +1,21 @@\n+Sat Dec 18 16:28:43 1999  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c: Minor reformatting.\n+\t* flow.c: Likewise.\n+\t* regs.h: Likewise.\n+\t* stor-layout.c: Likewise.\n+\t* fold-const.c: Likewise.\n+ \t(OVERFLOW_SUM_SIGN): Renamed from overflow_sum_sign.\n+\t(struct cb_args, const_binop_1, const_binop): Pass type of arg,\n+\tnot arg itself.\n+\t(size_int_wide): Cache nodes even if garbage collecting.\n+\t(twoval_comparison_p): Reenable SAVE_EXPR case if operand\n+\tof SAVE_EXPR has no side effects.\n+\t* cse.c: Move a comment.\n+\t* tree.c: Minor reformatting.\n+\t(int_size_in_bytes): Return -1 if constant overflows.\n+\t* reload.c (combine_reloads): Do nothing if no output reload\n+\n Sat Dec 18 18:30:20 1999  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* unroll.c (copy_loop_body): Don't treat a REG like a PLUS."}, {"sha": "e788ed3b0b578644c444c4d8a7127e2335e9b743", "filename": "gcc/alias.c", "status": "modified", "additions": 58, "deletions": 58, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -53,7 +53,7 @@ Boston, MA 02111-1307, USA.  */\n          int    double\n \n    (The arrows are directed and point downwards.)  If, when comparing\n-   two alias sets, we can hold one set fixed, and trace the other set\n+   two alias sets, we can hold one set fixed,  trace the other set\n    downwards, and at some point find the first set, the two MEMs can\n    alias one another.  In this situation we say the alias set for\n    `struct S' is the `superset' and that those for `int' and `double'\n@@ -63,7 +63,8 @@ Boston, MA 02111-1307, USA.  */\n    However, this is no actual entry for alias set zero.  It is an\n    error to attempt to explicitly construct a subset of zero.  */\n \n-typedef struct alias_set_entry {\n+typedef struct alias_set_entry\n+{\n   /* The alias set number, as stored in MEM_ALIAS_SET.  */\n   int alias_set;\n \n@@ -75,7 +76,7 @@ typedef struct alias_set_entry {\n      continuing our example above, the children here will be all of\n      `int', `double', `float', and `struct S'.  */\n   splay_tree children;\n-}* alias_set_entry;\n+} *alias_set_entry;\n \n static rtx canon_rtx\t\t\tPROTO((rtx));\n static int rtx_equal_for_memref_p\tPROTO((rtx, rtx));\n@@ -98,6 +99,7 @@ static int nonlocal_reference_p         PROTO((rtx));\n \n /* Set up all info needed to perform alias analysis on memory references.  */\n \n+/* Returns the size in bytes of the mode of X.  */\n #define SIZE_FOR_MODE(X) (GET_MODE_SIZE (GET_MODE (X)))\n \n /* Returns nonzero if MEM1 and MEM2 do not alias because they are in\n@@ -134,7 +136,8 @@ static int nonlocal_reference_p         PROTO((rtx));\n \n static rtx *reg_base_value;\n static rtx *new_reg_base_value;\n-static unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n+static unsigned int reg_base_value_size; /* size of reg_base_value array */\n+\n #define REG_BASE_VALUE(X) \\\n   ((unsigned) REGNO (X) < reg_base_value_size ? reg_base_value[REGNO (X)] : 0)\n \n@@ -184,10 +187,10 @@ static alias_set_entry\n get_alias_set_entry (alias_set)\n      int alias_set;\n {\n-  splay_tree_node sn =  \n-    splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n+  splay_tree_node sn\n+    = splay_tree_lookup (alias_sets, (splay_tree_key) alias_set);\n \n-  return sn ? ((alias_set_entry) sn->value) : ((alias_set_entry) 0);\n+  return sn != 0 ? ((alias_set_entry) sn->value) : 0;\n }\n \n /* Returns nonzero value if the alias sets for MEM1 and MEM2 are such\n@@ -208,8 +211,8 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n    gen_rtx_MEM, and the MEM_ALIAS_SET is not cleared.  If we begin to\n    use alias sets to indicate that spilled registers cannot alias each\n    other, we might need to remove this check.  */\n-  if (!flag_strict_aliasing && \n-      (MEM_ALIAS_SET (mem1) || MEM_ALIAS_SET (mem2)))\n+  if (! flag_strict_aliasing\n+      && (MEM_ALIAS_SET (mem1) != 0 || MEM_ALIAS_SET (mem2) != 0))\n     abort ();\n #endif\n \n@@ -222,26 +225,26 @@ mems_in_disjoint_alias_sets_p (mem1, mem2)\n   if (current_function_stdarg || current_function_varargs)\n     return 0;\n \n-  if (!MEM_ALIAS_SET (mem1) || !MEM_ALIAS_SET (mem2))\n-    /* We have no alias set information for one of the MEMs, so we\n-       have to assume it can alias anything.  */\n+  /* If have no alias set information for one of the MEMs, we have to assume\n+     it can alias anything.  */\n+  if (MEM_ALIAS_SET (mem1) == 0 || MEM_ALIAS_SET (mem2) == 0)\n     return 0;\n \n+  /* If the two alias sets are the same, they may alias.  */\n   if (MEM_ALIAS_SET (mem1) == MEM_ALIAS_SET (mem2))\n-    /* The two alias sets are the same, so they may alias.  */\n     return 0;\n \n   /* Iterate through each of the children of the first alias set,\n      comparing it with the second alias set.  */\n   ase = get_alias_set_entry (MEM_ALIAS_SET (mem1));\n-  if (ase && splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem2)))\n+  if (ase != 0 && splay_tree_lookup (ase->children,\n+\t\t\t\t     (splay_tree_key) MEM_ALIAS_SET (mem2)))\n     return  0;\n \n   /* Now do the same, but with the alias sets reversed.  */\n   ase = get_alias_set_entry (MEM_ALIAS_SET (mem2));\n-  if (ase && splay_tree_lookup (ase->children,\n-\t\t\t\t(splay_tree_key) MEM_ALIAS_SET (mem1)))\n+  if (ase != 0 && splay_tree_lookup (ase->children,\n+\t\t\t\t     (splay_tree_key) MEM_ALIAS_SET (mem1)))\n     return  0;\n \n   /* The two MEMs are in distinct alias sets, and neither one is the\n@@ -257,9 +260,7 @@ insert_subset_children (node, data)\n      splay_tree_node node;\n      void *data;\n {\n-  splay_tree_insert ((splay_tree) data,\n-\t\t     node->key,\n-\t\t     node->value);\n+  splay_tree_insert ((splay_tree) data, node->key, node->value);\n \n   return 0;\n }\n@@ -286,33 +287,32 @@ record_alias_subset (superset, subset)\n     abort ();\n \n   superset_entry = get_alias_set_entry (superset);\n-  if (!superset_entry) \n+  if (superset_entry == 0) \n     {\n       /* Create an entry for the SUPERSET, so that we have a place to\n \t attach the SUBSET.  */\n-      superset_entry = \n-\t(alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n+      superset_entry\n+\t= (alias_set_entry) xmalloc (sizeof (struct alias_set_entry));\n       superset_entry->alias_set = superset;\n       superset_entry->children \n \t= splay_tree_new (splay_tree_compare_ints, 0, 0);\n-      splay_tree_insert (alias_sets, \n-\t\t\t (splay_tree_key) superset,\n+      splay_tree_insert (alias_sets, (splay_tree_key) superset,\n \t\t\t (splay_tree_value) superset_entry);\n \n     }\n \n   subset_entry = get_alias_set_entry (subset);\n+\n+  /* If there is an entry for the subset, enter all of its children\n+     (if they are not already present) as children of the SUPERSET.  */\n   if (subset_entry) \n-    /* There is an entry for the subset.  Enter all of its children\n-       (if they are not already present) as children of the SUPERSET.  */\n     splay_tree_foreach (subset_entry->children,\n \t\t\tinsert_subset_children,\n \t\t\tsuperset_entry->children);\n \n   /* Enter the SUBSET itself as a child of the SUPERSET.  */\n   splay_tree_insert (superset_entry->children, \n-\t\t     (splay_tree_key) subset,\n-\t\t     /*value=*/0);\n+\t\t     (splay_tree_key) subset, 0);\n }\n \n /* Inside SRC, the source of a SET, find a base address.  */\n@@ -328,7 +328,7 @@ find_base_value (src)\n       return src;\n \n     case REG:\n-      /* At the start of a function argument registers have known base\n+      /* At the start of a function, argument registers have known base\n \t values which may be lost later.  Returning an ADDRESS\n \t expression here allows optimization based on argument values\n \t even when the argument registers are used for other purposes.  */\n@@ -363,7 +363,8 @@ find_base_value (src)\n       src = XEXP (src, 0);\n       if (GET_CODE (src) != PLUS && GET_CODE (src) != MINUS)\n \tbreak;\n-      /* fall through */\n+\n+      /* ... fall through ... */\n \n     case PLUS:\n     case MINUS:\n@@ -375,42 +376,31 @@ find_base_value (src)\n \tif (GET_CODE (src_0) == REG)\n \t  {\n \t    temp = find_base_value (src_0);\n-\t    if (temp)\n+\t    if (temp != 0)\n \t      src_0 = temp;\n \t  }\n \n \tif (GET_CODE (src_1) == REG)\n \t  {\n \t    temp = find_base_value (src_1);\n-\t    if (temp)\n+\t    if (temp!= 0)\n \t      src_1 = temp;\n \t  }\n \n-\t/* Guess which operand is the base address.\n-\n+\t/* Guess which operand is the base address:\n \t   If either operand is a symbol, then it is the base.  If\n \t   either operand is a CONST_INT, then the other is the base.  */\n-\n-\tif (GET_CODE (src_1) == CONST_INT\n-\t    || GET_CODE (src_0) == SYMBOL_REF\n-\t    || GET_CODE (src_0) == LABEL_REF\n-\t    || GET_CODE (src_0) == CONST)\n+\tif (GET_CODE (src_1) == CONST_INT || CONSTANT_P (src_0))\n \t  return find_base_value (src_0);\n-\n-\tif (GET_CODE (src_0) == CONST_INT\n-\t    || GET_CODE (src_1) == SYMBOL_REF\n-\t    || GET_CODE (src_1) == LABEL_REF\n-\t    || GET_CODE (src_1) == CONST)\n+\telse if (GET_CODE (src_0) == CONST_INT || CONSTANT_P (src_1))\n \t  return find_base_value (src_1);\n \n-\t/* This might not be necessary anymore. \n-\n+\t/* This might not be necessary anymore:\n \t   If either operand is a REG that is a known pointer, then it\n \t   is the base.  */\n-\tif (GET_CODE (src_0) == REG && REGNO_POINTER_FLAG (REGNO (src_0)))\n+\telse if (GET_CODE (src_0) == REG && REGNO_POINTER_FLAG (REGNO (src_0)))\n \t  return find_base_value (src_0);\n-\n-\tif (GET_CODE (src_1) == REG && REGNO_POINTER_FLAG (REGNO (src_1)))\n+\telse if (GET_CODE (src_1) == REG && REGNO_POINTER_FLAG (REGNO (src_1)))\n \t  return find_base_value (src_1);\n \n \treturn 0;\n@@ -442,7 +432,7 @@ find_base_value (src)\n \n /* Called from init_alias_analysis indirectly through note_stores.  */\n \n-/* while scanning insns to find base values, reg_seen[N] is nonzero if\n+/* While scanning insns to find base values, reg_seen[N] is nonzero if\n    register N has been set in this function.  */\n static char *reg_seen;\n \n@@ -523,6 +513,7 @@ record_set (dest, set, data)\n }\n \n /* Called from loop optimization when a new pseudo-register is created.  */\n+\n void\n record_base_value (regno, val, invariant)\n      int regno;\n@@ -541,11 +532,11 @@ record_base_value (regno, val, invariant)\n   if (GET_CODE (val) == REG)\n     {\n       if ((unsigned) REGNO (val) < reg_base_value_size)\n-\t{\n-\t  reg_base_value[regno] = reg_base_value[REGNO (val)];\n-\t}\n+\treg_base_value[regno] = reg_base_value[REGNO (val)];\n+\n       return;\n     }\n+\n   reg_base_value[regno] = find_base_value (val);\n }\n \n@@ -574,16 +565,19 @@ canon_rtx (x)\n \t  return gen_rtx_PLUS (GET_MODE (x), x0, x1);\n \t}\n     }\n+\n   /* This gives us much better alias analysis when called from\n      the loop optimizer.   Note we want to leave the original\n      MEM alone, but need to return the canonicalized MEM with\n      all the flags with their original values.  */\n   else if (GET_CODE (x) == MEM)\n     {\n       rtx addr = canon_rtx (XEXP (x, 0));\n+\n       if (addr != XEXP (x, 0))\n \t{\n \t  rtx new = gen_rtx_MEM (GET_MODE (x), addr);\n+\n \t  RTX_UNCHANGING_P (new) = RTX_UNCHANGING_P (x);\n \t  MEM_COPY_ATTRIBUTES (new, x);\n \t  MEM_ALIAS_SET (new) = MEM_ALIAS_SET (x);\n@@ -611,6 +605,7 @@ rtx_equal_for_memref_p (x, y)\n     return 1;\n   if (x == 0 || y == 0)\n     return 0;\n+\n   x = canon_rtx (x);\n   y = canon_rtx (y);\n \n@@ -643,7 +638,8 @@ rtx_equal_for_memref_p (x, y)\n   if (code == CONST_DOUBLE)\n     return 0;\n   if (code == ADDRESSOF)\n-    return REGNO (XEXP (x, 0)) == REGNO (XEXP (y, 0)) && XINT (x, 1) == XINT (y, 1);\n+    return (REGNO (XEXP (x, 0)) == REGNO (XEXP (y, 0))\n+\t    && XINT (x, 1) == XINT (y, 1));\n \n   /* For commutative operations, the RTX match if the operand match in any\n      order.  Also handle the simple binary and unary cases without a loop.  */\n@@ -680,7 +676,8 @@ rtx_equal_for_memref_p (x, y)\n \n \t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (rtx_equal_for_memref_p (XVECEXP (x, i, j), XVECEXP (y, i, j)) == 0)\n+\t    if (rtx_equal_for_memref_p (XVECEXP (x, i, j),\n+\t\t\t\t\tXVECEXP (y, i, j)) == 0)\n \t      return 0;\n \t  break;\n \n@@ -795,14 +792,14 @@ find_base_term (x)\n \t/* If either base term is named object or a special address\n \t   (like an argument or stack reference), then use it for the\n \t   base term.  */\n-\tif (tmp1\n+\tif (tmp1 != 0\n \t    && (GET_CODE (tmp1) == SYMBOL_REF\n \t\t|| GET_CODE (tmp1) == LABEL_REF\n \t\t|| (GET_CODE (tmp1) == ADDRESS\n \t\t    && GET_MODE (tmp1) != VOIDmode)))\n \t  return tmp1;\n \n-\tif (tmp2\n+\tif (tmp2 != 0\n \t    && (GET_CODE (tmp2) == SYMBOL_REF\n \t\t|| GET_CODE (tmp2) == LABEL_REF\n \t\t|| (GET_CODE (tmp2) == ADDRESS\n@@ -846,8 +843,10 @@ base_alias_check (x, y, x_mode, y_mode)\n   if (x_base == 0)\n     {\n       rtx x_c;\n+\n       if (! flag_expensive_optimizations || (x_c = canon_rtx (x)) == x)\n \treturn 1;\n+\n       x_base = find_base_term (x_c);\n       if (x_base == 0)\n \treturn 1;\n@@ -858,6 +857,7 @@ base_alias_check (x, y, x_mode, y_mode)\n       rtx y_c;\n       if (! flag_expensive_optimizations || (y_c = canon_rtx (y)) == y)\n \treturn 1;\n+\n       y_base = find_base_term (y_c);\n       if (y_base == 0)\n \treturn 1;"}, {"sha": "c27c8fd4dc8da3ee086a8b68ffe02491985aab28", "filename": "gcc/cse.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -722,11 +722,6 @@ dump_class (classp)\n     }\n }\n \n-/* Return an estimate of the cost of computing rtx X.\n-   One use is in cse, to decide which expression to keep in the hash table.\n-   Another is in rtl generation, to pick the cheapest way to multiply.\n-   Other uses like the latter are expected in the future.  */\n-\n /* Internal function, to compute cost when X is not a register; called\n    from COST macro to keep it simple.  */\n \n@@ -755,6 +750,11 @@ notreg_cost (x)\n \n #define COSTS_N_INSNS(N) ((N) * 4 - 2)\n \n+/* Return an estimate of the cost of computing rtx X.\n+   One use is in cse, to decide which expression to keep in the hash table.\n+   Another is in rtl generation, to pick the cheapest way to multiply.\n+   Other uses like the latter are expected in the future.  */\n+\n int\n rtx_cost (x, outer_code)\n      rtx x;"}, {"sha": "eff2a05d68675a15b6a4f5a85ae730d2b8f7ba66", "filename": "gcc/flow.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -103,8 +103,8 @@ Boston, MA 02111-1307, USA.  */\n    a REG_INC element is added to the insn's REG_NOTES list.\n \n    life_analysis fills in certain vectors containing information about\n-   register usage: reg_n_refs, reg_n_deaths, reg_n_sets, reg_live_length,\n-   reg_n_calls_crosses and reg_basic_block.\n+   register usage: REG_N_REFS, REG_N_DEATHS, REG_N_SETS, REG_LIVE_LENGTH,\n+   REG_N_CALLS_CROSSED and REG_BASIC_BLOCK.\n \n    life_analysis sets current_function_sp_is_unchanging if the function\n    doesn't modify the stack pointer.  */\n@@ -178,10 +178,8 @@ varray_type basic_block_info;\n \n /* The special entry and exit blocks.  */\n \n-struct basic_block_def entry_exit_blocks[2] = \n-{\n-  {\n-    NULL,\t\t\t/* head */\n+struct basic_block_def entry_exit_blocks[2]\n+= {{NULL,\t\t\t/* head */\n     NULL,\t\t\t/* end */\n     NULL,\t\t\t/* pred */\n     NULL,\t\t\t/* succ */\n@@ -2392,8 +2390,10 @@ calculate_loop_depth (dump)\n \n   /* The loop infrastructure does the real job for us.  */\n   flow_loops_find (&loops);\n+\n   if (dump)\n     flow_loops_dump (&loops, dump, 0);\n+\n   flow_loops_free (&loops);\n }\n \f\n@@ -6802,6 +6802,7 @@ flow_loop_level_compute (loop, depth)\n /* Compute the loop nesting depth and enclosed loop level for the loop\n    hierarchy tree specfied by LOOPS.  Return the maximum enclosed loop\n    level.  */\n+\n static int \n flow_loops_level_compute (loops)\n      struct loops *loops;\n@@ -6813,6 +6814,7 @@ flow_loops_level_compute (loops)\n /* Find all the natural loops in the function and save in LOOPS structure\n    and recalculate loop_depth information in basic block structures.\n    Return the number of natural loops found.  */\n+\n int \n flow_loops_find (loops)\n        struct loops *loops;\n@@ -6872,8 +6874,8 @@ flow_loops_find (loops)\n       flow_depth_first_order_compute (dfs_order);\n \n       /* Allocate loop structures.  */\n-      loops->array = (struct loop *)\n-\txcalloc (num_loops, sizeof (struct loop));\n+      loops->array\n+\t= (struct loop *) xcalloc (num_loops, sizeof (struct loop));\n       \n       headers = sbitmap_alloc (n_basic_blocks);\n       sbitmap_zero (headers);\n@@ -6921,8 +6923,8 @@ flow_loops_find (loops)\n \t\t  \n \t\t  /* Find nodes contained within the loop.  */\n \t\t  loop->nodes = sbitmap_alloc (n_basic_blocks);\n-\t\t  loop->num_nodes =\n-\t\t    flow_loop_nodes_find (header, latch, loop->nodes);\n+\t\t  loop->num_nodes\n+\t\t    = flow_loop_nodes_find (header, latch, loop->nodes);\n \t\t  \n \t\t  /* Find edges which exit the loop.  Note that a node\n \t\t     may have several exit edges.  */"}, {"sha": "335cb5cbc3e9d9ee766a305a631ee5a4b633077c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 132, "deletions": 110, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -66,7 +66,9 @@ static tree split_tree\t\tPROTO((tree, enum tree_code, tree *, tree *,\n \t\t\t\t       int));\n static tree associate_trees\tPROTO((tree, tree, enum tree_code, tree));\n static tree int_const_binop\tPROTO((enum tree_code, tree, tree, int, int));\n+static void const_binop_1\tPROTO((PTR));\n static tree const_binop\t\tPROTO((enum tree_code, tree, tree, int));\n+static void fold_convert_1\tPROTO((PTR));\n static tree fold_convert\tPROTO((tree, tree));\n static enum tree_code invert_tree_comparison PROTO((enum tree_code));\n static enum tree_code swap_tree_comparison PROTO((enum tree_code));\n@@ -100,29 +102,31 @@ static tree strip_compound_expr PROTO((tree, tree));\n static int multiple_of_p\tPROTO((tree, tree, tree));\n static tree constant_boolean_node PROTO((int, tree));\n static int count_cond\t\tPROTO((tree, int));\n-static void const_binop_1\tPROTO((PTR));\n-static void fold_convert_1\tPROTO((PTR));\n \n #ifndef BRANCH_COST\n #define BRANCH_COST 1\n #endif\n \n-/* Suppose A1 + B1 = SUM1, using 2's complement arithmetic ignoring overflow.\n-   Suppose A, B and SUM have the same respective signs as A1, B1, and SUM1.\n-   Then this yields nonzero if overflow occurred during the addition.\n-   Overflow occurs if A and B have the same sign, but A and SUM differ in sign.\n-   Use `^' to test whether signs differ, and `< 0' to isolate the sign.  */\n-#define overflow_sum_sign(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n+/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n+   overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n+   and SUM1.  Then this yields nonzero if overflow occurred during the\n+   addition.\n+\n+   Overflow occurs if A and B have the same sign, but A and SUM differ in\n+   sign.  Use `^' to test whether signs differ, and `< 0' to isolate the\n+   sign.  */\n+#define OVERFLOW_SUM_SIGN(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n \f\n /* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n    We do that by representing the two-word integer in 4 words, with only\n-   HOST_BITS_PER_WIDE_INT/2 bits stored in each word, as a positive number.  */\n+   HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive\n+   number.  The value of the word is LOWPART + HIGHPART * BASE.  */\n \n #define LOWPART(x) \\\n-  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT/2)) - 1))\n+  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)) - 1))\n #define HIGHPART(x) \\\n-  ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT/2)\n-#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT/2)\n+  ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT / 2)\n+#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT / 2)\n \n /* Unpack a two-word integer into 4 words.\n    LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n@@ -148,16 +152,16 @@ decode (words, low, hi)\n      HOST_WIDE_INT *words;\n      HOST_WIDE_INT *low, *hi;\n {\n-  *low = words[0] | words[1] * BASE;\n-  *hi = words[2] | words[3] * BASE;\n+  *low = words[0] + words[1] * BASE;\n+  *hi = words[2] + words[3] * BASE;\n }\n \f\n-/* Make the integer constant T valid for its type\n-   by setting to 0 or 1 all the bits in the constant\n-   that don't belong in the type.\n-   Yield 1 if a signed overflow occurs, 0 otherwise.\n-   If OVERFLOW is nonzero, a signed overflow has already occurred\n-   in calculating T, so propagate it.\n+/* Make the integer constant T valid for its type by setting to 0 or 1 all\n+   the bits in the constant that don't belong in the type.\n+\n+   Return 1 if a signed overflow occurs, 0 otherwise.  If OVERFLOW is\n+   nonzero, a signed overflow has already occurred in calculating T, so\n+   propagate it.\n \n    Make the real constant T valid for its type by calling CHECK_FLOAT_VALUE,\n    if it exists.  */\n@@ -195,10 +199,8 @@ force_fit_type (t, overflow)\n   if (prec == 2 * HOST_BITS_PER_WIDE_INT)\n     ;\n   else if (prec > HOST_BITS_PER_WIDE_INT)\n-    {\n-      TREE_INT_CST_HIGH (t)\n-\t&= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-    }\n+    TREE_INT_CST_HIGH (t)\n+      &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n   else\n     {\n       TREE_INT_CST_HIGH (t) = 0;\n@@ -220,10 +222,8 @@ force_fit_type (t, overflow)\n       /* Value is negative:\n \t set to 1 all the bits that are outside this type's precision.  */\n       if (prec > HOST_BITS_PER_WIDE_INT)\n-\t{\n-\t  TREE_INT_CST_HIGH (t)\n-\t    |= ((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-\t}\n+\tTREE_INT_CST_HIGH (t)\n+\t  |= ((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n       else\n \t{\n \t  TREE_INT_CST_HIGH (t) = -1;\n@@ -232,7 +232,7 @@ force_fit_type (t, overflow)\n \t}\n     }\n \n-  /* Yield nonzero if signed overflow occurred.  */\n+  /* Return nonzero if signed overflow occurred.  */\n   return\n     ((overflow | (low ^ TREE_INT_CST_LOW (t)) | (high ^ TREE_INT_CST_HIGH (t)))\n      != 0);\n@@ -255,7 +255,7 @@ add_double (l1, h1, l2, h2, lv, hv)\n \n   *lv = l;\n   *hv = h;\n-  return overflow_sum_sign (h1, h2, h);\n+  return OVERFLOW_SUM_SIGN (h1, h2, h);\n }\n \n /* Negate a doubleword integer with doubleword result.\n@@ -975,10 +975,9 @@ exact_real_inverse (mode, r)\n   return 1;\n }\n \n-\n /* Convert C9X hexadecimal floating point string constant S.  Return\n    real value type in mode MODE.  This function uses the host computer's\n-   fp arithmetic when there is no REAL_ARITHMETIC.  */\n+   floating point arithmetic when there is no REAL_ARITHMETIC.  */\n \n REAL_VALUE_TYPE\n real_hex_to_f (s, mode)\n@@ -988,8 +987,13 @@ real_hex_to_f (s, mode)\n    REAL_VALUE_TYPE ip;\n    char *p = s;\n    unsigned HOST_WIDE_INT low, high;\n-   int frexpon, expon, shcount, nrmcount, k;\n-   int sign, expsign, decpt, isfloat, isldouble, gotp, lost;\n+   int expon, shcount, nrmcount, k;\n+   int sign, expsign, isfloat, isldouble;\n+   int lost = 0;/* Nonzero low order bits shifted out and discarded.  */\n+   int frexpon = 0;  /* Bits after the decimal point.  */\n+   int expon = 0;  /* Value of exponent.  */\n+   int decpt = 0;  /* How many decimal points.  */\n+   int gotp = 0;  /* How many P's.  */\n    char c;\n \n    isldouble = 0;\n@@ -1027,11 +1031,6 @@ real_hex_to_f (s, mode)\n \n    high = 0;\n    low = 0;\n-   lost = 0; /* Nonzero low order bits shifted out and discarded.  */\n-   frexpon = 0;  /* Bits after the decimal point.  */\n-   expon = 0;  /* Value of exponent.  */\n-   decpt = 0;  /* How many decimal points.  */\n-   gotp = 0;  /* How many P's.  */\n    shcount = 0;\n    while ((c = *p) != '\\0')\n      {\n@@ -1058,7 +1057,7 @@ real_hex_to_f (s, mode)\n \t     {\n \t       /* Record nonzero lost bits.  */\n \t       lost |= k;\n-\t       if (!decpt)\n+\t       if (! decpt)\n \t\t frexpon -= 4;\n \t     }\n \t   ++p;\n@@ -1068,6 +1067,7 @@ real_hex_to_f (s, mode)\n \t   ++decpt;\n \t   ++p;\n \t }\n+\n        else if (c == 'p' || c == 'P')\n \t {\n \t   ++gotp;\n@@ -1078,13 +1078,15 @@ real_hex_to_f (s, mode)\n \t       expsign = -1;\n \t       ++p;\n \t     }\n+\n \t   /* Value of exponent.\n \t      The exponent field is a decimal integer.  */\n \t   while (ISDIGIT(*p))\n \t     {\n \t       k = (*p++ & 0x7f) - '0';\n \t       expon = 10 * expon + k;\n \t     }\n+\n \t   expon *= expsign;\n \t   /* F suffix is ambiguous in the significand part\n \t      so it must appear after the decimal exponent field.  */\n@@ -1095,6 +1097,7 @@ real_hex_to_f (s, mode)\n \t       break;\n \t     }\n \t }\n+\n        else if (c == 'l' || c == 'L')\n \t {\n \t   isldouble = 1;\n@@ -1104,18 +1107,19 @@ real_hex_to_f (s, mode)\n        else\n \t break;\n      }\n+\n    /* Abort if last character read was not legitimate.  */\n    c = *p;\n    if ((c != '\\0' && c != ' ' && c != '\\n' && c != '\\r') || (decpt > 1))\n      abort ();\n+\n    /* There must be either one decimal point or one p.  */\n    if (decpt == 0 && gotp == 0)\n      abort ();\n+\n    shcount -= 4;\n-   if ((high == 0) && (low == 0))\n-     {\n-       return dconst0;\n-     }\n+   if (high == 0 && low == 0))\n+     return dconst0;\n \n    /* Normalize.  */\n    nrmcount = 0;\n@@ -1125,6 +1129,7 @@ real_hex_to_f (s, mode)\n        low = 0;\n        nrmcount += 32;\n      }\n+\n    /* Leave a high guard bit for carry-out.  */\n    if ((high & 0x80000000) != 0)\n      {\n@@ -1133,18 +1138,21 @@ real_hex_to_f (s, mode)\n        high = high >> 1;\n        nrmcount -= 1;\n      }\n+\n    if ((high & 0xffff8000) == 0)\n      {\n        high = (high << 16) + ((low >> 16) & 0xffff);\n        low = low << 16;\n        nrmcount += 16;\n      }\n+\n    while ((high & 0xc0000000) == 0)\n      {\n        high = (high << 1) + ((low >> 31) & 1);\n        low = low << 1;\n        nrmcount += 1;\n      }\n+\n    if (isfloat || GET_MODE_SIZE(mode) == UNITS_PER_WORD)\n      {\n        /* Keep 24 bits precision, bits 0x7fffff80.\n@@ -1193,6 +1201,7 @@ real_hex_to_f (s, mode)\n        low &= 0xffffff80;\n #endif\n      }\n+\n    ip = (double) high;\n    ip =  REAL_VALUE_LDEXP (ip, 32) + (double) low;\n    /* Apply shifts and exponent value as power of 2.  */\n@@ -1449,7 +1458,7 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n     case MINUS_EXPR:\n       neg_double (int2l, int2h, &low, &hi);\n       add_double (int1l, int1h, low, hi, &low, &hi);\n-      overflow = overflow_sum_sign (hi, int2h, int1h);\n+      overflow = OVERFLOW_SUM_SIGN (hi, int2h, int1h);\n       break;\n \n     case MULT_EXPR:\n@@ -1515,21 +1524,18 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n     case MIN_EXPR:\n     case MAX_EXPR:\n       if (uns)\n-\t{\n-\t  low = (((unsigned HOST_WIDE_INT) int1h\n-\t\t  < (unsigned HOST_WIDE_INT) int2h)\n-\t\t || (((unsigned HOST_WIDE_INT) int1h\n-\t\t      == (unsigned HOST_WIDE_INT) int2h)\n-\t\t     && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n-\t}\n+\tlow = (((unsigned HOST_WIDE_INT) int1h\n+\t\t< (unsigned HOST_WIDE_INT) int2h)\n+\t       || (((unsigned HOST_WIDE_INT) int1h\n+\t\t    == (unsigned HOST_WIDE_INT) int2h)\n+\t\t   && ((unsigned HOST_WIDE_INT) int1l\n+\t\t       < (unsigned HOST_WIDE_INT) int2l)));\n       else\n-\t{\n-\t  low = ((int1h < int2h)\n-\t\t || ((int1h == int2h)\n-\t\t     && ((unsigned HOST_WIDE_INT) int1l\n-\t\t\t < (unsigned HOST_WIDE_INT) int2l)));\n-\t}\n+\tlow = ((int1h < int2h)\n+\t       || ((int1h == int2h)\n+\t\t   && ((unsigned HOST_WIDE_INT) int1l\n+\t\t       < (unsigned HOST_WIDE_INT) int2l)));\n+\n       if (low == (code == MIN_EXPR))\n \tlow = int1l, hi = int1h;\n       else\n@@ -1558,34 +1564,38 @@ int_const_binop (code, arg1, arg2, notrunc, forsize)\n \t: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)\n        | TREE_OVERFLOW (arg1)\n        | TREE_OVERFLOW (arg2));\n+\n   /* If we're doing a size calculation, unsigned arithmetic does overflow.\n      So check if force_fit_type truncated the value.  */\n   if (forsize\n       && ! TREE_OVERFLOW (t)\n       && (TREE_INT_CST_HIGH (t) != hi\n \t  || TREE_INT_CST_LOW (t) != low))\n     TREE_OVERFLOW (t) = 1;\n+\n   TREE_CONSTANT_OVERFLOW (t) = (TREE_OVERFLOW (t)\n \t\t\t\t| TREE_CONSTANT_OVERFLOW (arg1)\n \t\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n   return t;\n }\n \n+/* Define input and output argument for const_binop_1.  */\n struct cb_args\n {\n-  /* Input */\n-  tree arg1;\n-  REAL_VALUE_TYPE d1, d2;\n-  enum tree_code code;\n-  /* Output */\n-  tree t;\n+  enum tree_code code;\t\t/* Input: tree code for operation*/\n+  tree type;\t\t\t/* Input: tree type for operation. */\n+  REAL_VALUE_TYPE d1, d2;\t/* Input: floating point operands. */\n+  tree t;\t\t\t/* Output: constant for result. */\n };\n \n+/* Do the real arithmetic for const_binop while protected by a\n+   float overflow handler.  */\n+\n static void\n const_binop_1 (data)\n   PTR data;\n {\n-  struct cb_args * args = (struct cb_args *) data;\n+  struct cb_args *args = (struct cb_args *) data;\n   REAL_VALUE_TYPE value;\n \n #ifdef REAL_ARITHMETIC\n@@ -1626,16 +1636,15 @@ const_binop_1 (data)\n       abort ();\n     }\n #endif /* no REAL_ARITHMETIC */\n-  args->t =\n-    build_real (TREE_TYPE (args->arg1),\n-\t\treal_value_truncate (TYPE_MODE (TREE_TYPE (args->arg1)),\n-\t\t\t\t     value));\n+\n+  args->t\n+    = build_real (args->type,\n+\t\t  real_value_truncate (TYPE_MODE (args->type), value));\n }\n \n-/* Combine two constants ARG1 and ARG2 under operation CODE\n-   to produce a new constant.\n-   We assume ARG1 and ARG2 have the same data type,\n-   or at least are the same kind of constant and the same machine mode.\n+/* Combine two constants ARG1 and ARG2 under operation CODE to produce a new\n+   constant.  We assume ARG1 and ARG2 have the same data type, or at least\n+   are the same kind of constant and the same machine mode.\n \n    If NOTRUNC is nonzero, do not truncate the result to fit the data type.  */\n \n@@ -1670,19 +1679,17 @@ const_binop (code, arg1, arg2, notrunc)\n \treturn arg2;\n \n       /* Setup input for const_binop_1() */\n-      args.arg1 = arg1;\n+      args.type = TREE_TYPE (arg1);\n       args.d1 = d1;\n       args.d2 = d2;\n       args.code = code;\n       \n       if (do_float_handler (const_binop_1, (PTR) &args))\n-\t{\n-\t  /* Receive output from const_binop_1() */\n-\t  t = args.t;\n-\t}\n+\t/* Receive output from const_binop_1. */\n+\tt = args.t;\n       else\n \t{\n-\t  /* We got an exception from const_binop_1() */\n+\t  /* We got an exception from const_binop_1. */\n \t  t = copy_node (arg1);\n \t  overflow = 1;\n \t}\n@@ -1776,36 +1783,51 @@ const_binop (code, arg1, arg2, notrunc)\n   return 0;\n }\n \f\n-/* Return an INTEGER_CST with value V .  The type is determined by bit_p:\n-   if it is zero, the type is taken from sizetype; if it is one, the type\n-   is taken from bitsizetype.  */\n+/* Return an INTEGER_CST with value whose HOST_BITS_PER_WIDE_INT bits are\n+   given by HIGH and whose HOST_BITS_PER_WIDE_INT bits are given by NUMBER.\n+\n+   If BIT_P is nonzero, this represents a size in bit and the type of the\n+   result will be bitsizetype, othewise it represents a size in bytes and\n+   the type of the result will be sizetype.  */\n \n tree\n size_int_wide (number, high, bit_p)\n      unsigned HOST_WIDE_INT number, high;\n      int bit_p;\n {\n+  /* Type-size nodes already made for small sizes.  */\n+  static tree size_table[2 * HOST_BITS_PER_WIDE_INT + 1][2];\n+  static int init_p = 0;\n   tree t;\n   \n-  if (!ggc_p)\n+  if (ggc_p && ! init_p)\n     {\n-      /* Type-size nodes already made for small sizes.  */\n-      static tree size_table[2*HOST_BITS_PER_WIDE_INT + 1][2];\n+      ggc_add_tree_root ((tree *) size_table,\n+\t\t\t sizeof size_table / sizeof (tree));\n+      init_p = 1;\n+    }\n+\n+  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && high == 0\n+      && size_table[number][bit_p] != 0)\n+    return size_table[number][bit_p];\n \n-      if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high\n-\t  && size_table[number][bit_p] != 0)\n-\treturn size_table[number][bit_p];\n-      if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && ! high)\n+  if (number < 2*HOST_BITS_PER_WIDE_INT + 1 && high == 0)\n+    {\n+      if (! ggc_p)\n \t{\n-\t  push_obstacks_nochange ();\n \t  /* Make this a permanent node.  */\n+\t  push_obstacks_nochange ();\n \t  end_temporary_allocation ();\n-\t  t = build_int_2 (number, 0);\n-\t  TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n-\t  size_table[number][bit_p] = t;\n-\t  pop_obstacks ();\n-\t  return t;\n \t}\n+\n+      t = build_int_2 (number, 0);\n+      TREE_TYPE (t) = bit_p ? bitsizetype : sizetype;\n+      size_table[number][bit_p] = t;\n+\n+      if (! ggc_p)\n+\tpop_obstacks ();\n+\n+      return t;\n     }\n \n   t = build_int_2 (number, high);\n@@ -1879,14 +1901,17 @@ ssize_binop (code, arg0, arg1)\n   return fold (build (code, ssizetype, arg0, arg1));\n }\n \f\n+/* This structure is used to communicate arguments to fold_convert_1.  */\n struct fc_args\n {\n-  /* Input */\n-  tree arg1, type;\n-  /* Output */\n-  tree t;\n+  tree arg1;\t\t\t/* Input: value to convert. */\n+  tree type;\t\t\t/* Input: type to convert value to. */\n+  tree t;\t\t\t/* Ouput: result of conversion. */\n };\n \n+/* Function to convert floating-point constants, protected by floating\n+   point exception handler.  */\n+\n static void\n fold_convert_1 (data)\n   PTR data;\n@@ -2400,11 +2425,8 @@ twoval_comparison_p (arg, cval1, cval2, save_p)\n \t       || code == COMPOUND_EXPR))\n     class = '2';\n \n-  /* ??? Disable this since the SAVE_EXPR might already be in use outside\n-     the expression.  There may be no way to make this work, but it needs\n-     to be looked at again for 2.6.  */\n-#if 0\n-  else if (class == 'e' && code == SAVE_EXPR && SAVE_EXPR_RTL (arg) == 0)\n+  else if (class == 'e' && code == SAVE_EXPR && SAVE_EXPR_RTL (arg) == 0\n+\t   && ! TREE_SIDE_EFFECTS (TREE_OPERAND (arg, 0)))\n     {\n       /* If we've already found a CVAL1 or CVAL2, this expression is\n \t two complex to handle.  */\n@@ -2414,7 +2436,6 @@ twoval_comparison_p (arg, cval1, cval2, save_p)\n       class = '1';\n       *save_p = 1;\n     }\n-#endif\n \n   switch (class)\n     {\n@@ -4513,6 +4534,7 @@ constant_boolean_node (value, type)\n   else \n     {\n       tree t = build_int_2 (value, 0);\n+\n       TREE_TYPE (t) = type;\n       return t;\n     }\n@@ -4559,10 +4581,8 @@ fold (expr)\n   register enum tree_code code = TREE_CODE (t);\n   register int kind;\n   int invert;\n-\n   /* WINS will be nonzero when the switch is done\n      if all operands are constant.  */\n-\n   int wins = 1;\n \n   /* Don't try to process an RTL_EXPR since its operands aren't trees. \n@@ -4737,11 +4757,13 @@ fold (expr)\n \t      && (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0))\n \t\t  == TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 2), 0)))\n \t      && ! (INTEGRAL_TYPE_P (TREE_TYPE (t))\n-\t\t    && INTEGRAL_TYPE_P (TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0)))\n+\t\t    && (INTEGRAL_TYPE_P\n+\t\t\t(TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0))))\n \t\t    && TYPE_PRECISION (TREE_TYPE (t)) <= BITS_PER_WORD))\n \t    t = build1 (code, type,\n \t\t\tbuild (COND_EXPR,\n-\t\t\t       TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0)),\n+\t\t\t       TREE_TYPE (TREE_OPERAND\n+\t\t\t\t\t  (TREE_OPERAND (t, 1), 0)),\n \t\t\t       TREE_OPERAND (t, 0),\n \t\t\t       TREE_OPERAND (TREE_OPERAND (t, 1), 0),\n \t\t\t       TREE_OPERAND (TREE_OPERAND (t, 2), 0)));"}, {"sha": "ff267febc30619d4b9f1f82d1c77d3f7d5a2cccb", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -1,5 +1,5 @@\n /* Define per-register tables for data flow info and register allocation.\n-   Copyright (C) 1987, 1993, 1994, 1995, 1997, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 93-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -39,13 +39,13 @@ Boston, MA 02111-1307, USA.  */\n extern int max_regno;\n \n /* Register information indexed by register number */\n-typedef struct reg_info_def {\n-\t\t\t\t/* fields set by reg_scan */\n+typedef struct reg_info_def\n+{\t\t\t\t/* fields set by reg_scan */\n   int first_uid;\t\t/* UID of first insn to use (REG n) */\n   int last_uid;\t\t\t/* UID of last insn to use (REG n) */\n   int last_note_uid;\t\t/* UID of last note to use (REG n) */\n \n-\t\t\t\t/* fields set by both reg_scan and flow_analysis */\n+\t\t\t\t/* fields set by reg_scan & flow_analysis */\n   int sets;\t\t\t/* # of times (REG n) is set */\n \n \t\t\t\t/* fields set by flow_analysis */"}, {"sha": "529a2c6ebb5191905e8de90d5f4c87f627aeb741", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -1718,7 +1718,7 @@ combine_reloads ()\n      that it does not occur in the output (we already know it isn't an\n      earlyclobber.  If this is an asm insn, give up.  */\n \n-  if (INSN_CODE (this_insn) == -1)\n+  if (INSN_CODE (this_insn) == -1 || output_reload == -1)\n     return;\n \n   for (i = 1; i < insn_data[INSN_CODE (this_insn)].n_operands; i++)"}, {"sha": "4fa645af9d9213837ee6e69047fb5e7dd395acca", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 45, "deletions": 40, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -1,5 +1,5 @@\n /* C-compiler utilities for types and variables storage layout\n-   Copyright (C) 1987, 88, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 88, 92-98, 1999 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -21,7 +21,6 @@ Boston, MA 02111-1307, USA.  */\n \n #include \"config.h\"\n #include \"system.h\"\n-\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"tm_p.h\"\n@@ -67,6 +66,7 @@ get_pending_sizes ()\n   /* Put each SAVE_EXPR into the current function.  */\n   for (t = chain; t; t = TREE_CHAIN (t))\n     SAVE_EXPR_CONTEXT (TREE_VALUE (t)) = current_function_decl;\n+\n   pending_sizes = 0;\n   return chain;\n }\n@@ -123,7 +123,8 @@ variable_size (size)\n        Also, we would like to pass const0_rtx here, but don't have it.  */\n     expand_expr (size, expand_expr (integer_zero_node, NULL_PTR, VOIDmode, 0),\n \t\t VOIDmode, 0);\n-  else if (current_function && current_function->x_dont_save_pending_sizes_p)\n+  else if (current_function != 0\n+\t   && current_function->x_dont_save_pending_sizes_p)\n     /* The front-end doesn't want us to keep a list of the expressions\n        that determine sizes for variable size objects.  */\n     ;\n@@ -203,7 +204,8 @@ int_mode_for_mode (mode)\n     case MODE_RANDOM:\n       if (mode == BLKmode)\n         break;\n-      /* FALLTHRU */\n+\n+      /* ... fall through ... */\n \n     case MODE_CC:\n     default:\n@@ -282,8 +284,8 @@ layout_decl (decl, known_align)\n \t   || (! DECL_PACKED (decl) &&  TYPE_ALIGN (type) > DECL_ALIGN (decl)))\n     DECL_ALIGN (decl) = TYPE_ALIGN (type);\n \n-  /* See if we can use an ordinary integer mode for a bit-field.  */\n-  /* Conditions are: a fixed size that is correct for another mode\n+  /* See if we can use an ordinary integer mode for a bit-field. \n+     Conditions are: a fixed size that is correct for another mode\n      and occupying a complete byte or bytes on proper boundary.  */\n   if (code == FIELD_DECL)\n     {\n@@ -385,6 +387,7 @@ layout_record (rec)\n \t  pending_statics = tree_cons (NULL_TREE, field, pending_statics);\n \t  continue;\n \t}\n+\n       /* Enumerators and enum types which are local to this class need not\n \t be laid out.  Likewise for initialized constant fields.  */\n       if (TREE_CODE (field) != FIELD_DECL)\n@@ -639,7 +642,8 @@ layout_record (rec)\n       tree unpacked_size;\n       TYPE_PACKED (rec) = 0;\n #ifdef ROUND_TYPE_ALIGN\n-      unpacked_align = ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), unpacked_align);\n+      unpacked_align\n+\t= ROUND_TYPE_ALIGN (rec, TYPE_ALIGN (rec), unpacked_align);\n #else\n       unpacked_align = MAX (TYPE_ALIGN (rec), unpacked_align);\n #endif\n@@ -825,6 +829,7 @@ layout_type (type)\n     case BOOLEAN_TYPE:  /* Used for Java, Pascal, and Chill. */\n       if (TYPE_PRECISION (type) == 0)\n \tTYPE_PRECISION (type) = 1; /* default to one byte/boolean. */\n+\n       /* ... fall through ... */\n \n     case INTEGER_TYPE:\n@@ -937,9 +942,11 @@ layout_type (type)\n \t    element_size = TYPE_SIZE (element);\n \t    if (TYPE_PACKED (type) && INTEGRAL_TYPE_P (element))\n \t      {\n-\t\tHOST_WIDE_INT maxvalue, minvalue;\n-\t\tmaxvalue = TREE_INT_CST_LOW (TYPE_MAX_VALUE (element));\n-\t\tminvalue = TREE_INT_CST_LOW (TYPE_MIN_VALUE (element));\n+\t\tHOST_WIDE_INT maxvalue\n+\t\t  = TREE_INT_CST_LOW (TYPE_MAX_VALUE (element));\n+\t\tHOST_WIDE_INT minvalue\n+\t\t  = TREE_INT_CST_LOW (TYPE_MIN_VALUE (element));\n+\n \t\tif (maxvalue - minvalue == 1\n \t\t    && (maxvalue == 1 || maxvalue == 0))\n \t\t  element_size = integer_one_node;\n@@ -957,10 +964,8 @@ layout_type (type)\n \t       set correctly in that case.  */\n \t    if (TYPE_SIZE_UNIT (element) != 0\n \t\t&& element_size != integer_one_node)\n-\t      {\n-\t        TYPE_SIZE_UNIT (type)\n-\t\t  = size_binop (MULT_EXPR, TYPE_SIZE_UNIT (element), length);\n-\t      }\n+\t      TYPE_SIZE_UNIT (type)\n+\t\t= size_binop (MULT_EXPR, TYPE_SIZE_UNIT (element), length);\n \t  }\n \n \t/* Now round the alignment and size,\n@@ -976,12 +981,14 @@ layout_type (type)\n #ifdef ROUND_TYPE_SIZE\n \tif (TYPE_SIZE (type) != 0)\n \t  {\n-\t    tree tmp;\n-\t    tmp = ROUND_TYPE_SIZE (type, TYPE_SIZE (type), TYPE_ALIGN (type));\n+\t    tree tmp\n+\t      = ROUND_TYPE_SIZE (type, TYPE_SIZE (type), TYPE_ALIGN (type));\n+\n \t    /* If the rounding changed the size of the type, remove any\n \t       pre-calculated TYPE_SIZE_UNIT.  */\n \t    if (simple_cst_equal (TYPE_SIZE (type), tmp) != 1)\n \t      TYPE_SIZE_UNIT (type) = NULL;\n+\n \t    TYPE_SIZE (type) = tmp;\n \t  }\n #endif\n@@ -999,7 +1006,8 @@ layout_type (type)\n \t\t\t       MODE_INT, 1);\n \n \t    if (STRICT_ALIGNMENT && TYPE_ALIGN (type) < BIGGEST_ALIGNMENT\n-\t\t&& (int)TYPE_ALIGN (type) < TREE_INT_CST_LOW (TYPE_SIZE (type))\n+\t\t&& ((int) TYPE_ALIGN (type)\n+\t\t    < TREE_INT_CST_LOW (TYPE_SIZE (type)))\n \t\t&& TYPE_MODE (type) != BLKmode)\n \t      {\n \t\tTYPE_NO_FORCE_BLK (type) = 1;\n@@ -1066,7 +1074,7 @@ layout_type (type)\n \t     then stick with BLKmode.  */\n \t  if (STRICT_ALIGNMENT\n \t      && ! (TYPE_ALIGN (type) >= BIGGEST_ALIGNMENT\n-\t\t    || ((int)TYPE_ALIGN (type)\n+\t\t    || ((int) TYPE_ALIGN (type)\n \t\t\t>= TREE_INT_CST_LOW (TYPE_SIZE (type)))))\n \t    {\n \t      if (TYPE_MODE (type) != BLKmode)\n@@ -1190,14 +1198,13 @@ layout_type (type)\n   /* If we failed to find a simple way to calculate the unit size\n      of the type above, find it by division.  */\n   if (TYPE_SIZE_UNIT (type) == 0 && TYPE_SIZE (type) != 0)\n-    {\n-      /* TYPE_SIZE (type) is computed in bitsizetype.  After the division, the\n-\t result will fit in sizetype.  We will get more efficient code using\n-\t sizetype, so we force a conversion.  */\n-      tree unit_size = size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n-\t\t\t\t   size_int (BITS_PER_UNIT));\n-      TYPE_SIZE_UNIT (type) = convert (sizetype, unit_size);\n-    }\n+    /* TYPE_SIZE (type) is computed in bitsizetype.  After the division, the\n+       result will fit in sizetype.  We will get more efficient code using\n+       sizetype, so we force a conversion.  */\n+    TYPE_SIZE_UNIT (type)\n+      = convert (sizetype,\n+\t\t size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n+\t\t\t     size_int (BITS_PER_UNIT)));\n \n   /* Once again evaluate only once, either now or as soon as safe.  */\n   if (TYPE_SIZE_UNIT (type) != 0\n@@ -1217,7 +1224,7 @@ layout_type (type)\n \n       /* Copy it into all variants.  */\n       for (variant = TYPE_MAIN_VARIANT (type);\n-\t   variant;\n+\t   variant != 0;\n \t   variant = TYPE_NEXT_VARIANT (variant))\n \t{\n \t  TYPE_SIZE (variant) = size;\n@@ -1265,14 +1272,12 @@ make_signed_type (precision)\n \n   /* The first type made with this or `make_unsigned_type'\n      is the type for size values.  */\n-\n   if (sizetype == 0)\n     set_sizetype (type);\n \n   /* Lay out the type: set its alignment, size, etc.  */\n \n   layout_type (type);\n-\n   return type;\n }\n \n@@ -1306,25 +1311,24 @@ void\n set_sizetype (type)\n      tree type;\n {\n-  int oprecision = TYPE_PRECISION (type), precision;\n-\n-  sizetype = type;\n-\n+  int oprecision = TYPE_PRECISION (type);\n   /* The *bitsizetype types use a precision that avoids overflows when\n-     calculating signed sizes / offsets in bits.  */\n-  precision = oprecision + BITS_PER_UNIT_LOG + 1;\n-  /* However, when cross-compiling from a 32 bit to a 64 bit host,\n-     we are limited to 64 bit precision.  */\n-  if (precision > 2 * HOST_BITS_PER_WIDE_INT)\n-    precision = 2 * HOST_BITS_PER_WIDE_INT;\n+     calculating signed sizes / offsets in bits.  However, when\n+     cross-compiling from a 32 bit to a 64 bit host, we are limited to 64 bit\n+     precision.  */\n+  int precision = MAX (oprecision + BITS_PER_UNIT_LOG + 1,\n+\t\t       2 * HOST_BITS_PER_WIDE_INT);\n \n+  sizetype = type;\n   bitsizetype = make_node (INTEGER_TYPE);\n   TYPE_NAME (bitsizetype) = TYPE_NAME (type);\n   TYPE_PRECISION (bitsizetype) = precision;\n+\n   if (TREE_UNSIGNED (type))\n     fixup_unsigned_type (bitsizetype);\n   else\n     fixup_signed_type (bitsizetype);\n+\n   layout_type (bitsizetype);\n \n   if (TREE_UNSIGNED (type))\n@@ -1343,7 +1347,8 @@ set_sizetype (type)\n     }\n   TYPE_NAME (bitsizetype) = TYPE_NAME (sizetype);\n \n-  ggc_add_tree_root ((tree*) &sizetype_tab, sizeof(sizetype_tab)/sizeof(tree));\n+  ggc_add_tree_root ((tree *) &sizetype_tab,\n+\t\t     sizeof sizetype_tab / sizeof (tree));\n }\n \n /* Set the extreme values of TYPE based on its precision in bits,"}, {"sha": "6f6caf94f7402e4109cb555f683ebca342a488af", "filename": "gcc/tree.c", "status": "modified", "additions": 141, "deletions": 101, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4b60170fd601e84cdafca12ea3365488ee93635/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d4b60170fd601e84cdafca12ea3365488ee93635", "patch": "@@ -271,9 +271,9 @@ struct type_hash\n #define TYPE_HASH_SIZE 59\n struct type_hash *type_hash_table[TYPE_HASH_SIZE];\n \n+static void build_real_from_int_cst_1 PROTO((PTR));\n static void set_type_quals PROTO((tree, int));\n static void append_random_chars PROTO((char *));\n-static void build_real_from_int_cst_1 PROTO((PTR));\n static void mark_type_hash PROTO ((void *));\n static void fix_sizetype PROTO ((tree));\n \n@@ -321,11 +321,14 @@ init_obstacks ()\n \n   /* Init the hash table of identifiers.  */\n   bzero ((char *) hash_table, sizeof hash_table);\n-\n-  ggc_add_tree_root (hash_table, MAX_HASH_TABLE);\n-  ggc_add_root (type_hash_table, TYPE_HASH_SIZE, \n-\t\tsizeof(struct type_hash *),\n-\t\tmark_type_hash);\n+  ggc_add_tree_root (hash_table, sizeof hash_table / sizeof (tree));\n+\n+  /* Initialize the hash table of types.  */\n+  bzero ((char *) type_hash_table,\n+\t sizeof type_hash_table / sizeof type_hash_table[0]);\n+  ggc_add_root (type_hash_table,\n+\t\tsizeof type_hash_table / sizeof type_hash_table [0],\n+\t\tsizeof type_hash_table[0], mark_type_hash);\n   ggc_add_tree_root (global_trees, TI_MAX);\n }\n \n@@ -574,6 +577,7 @@ permanent_allocation (function_end)\n     }\n   else\n     obstack_free (&momentary_obstack, momentary_firstobj);\n+\n   obstack_free (function_maybepermanent_obstack, maybepermanent_firstobj);\n   obstack_free (&temp_decl_obstack, temp_decl_firstobj);\n \n@@ -880,8 +884,8 @@ resume_momentary (yes)\n void\n init_tree_codes ()\n {\n-  built_in_filename = \n-    ggc_alloc_string (BUILT_IN_FILENAME, sizeof (BUILT_IN_FILENAME));\n+  built_in_filename\n+    = ggc_alloc_string (BUILT_IN_FILENAME, sizeof (BUILT_IN_FILENAME));\n   ggc_add_string_root (&built_in_filename, 1);\n }\n \n@@ -1379,6 +1383,7 @@ build_int_2_wide (low, hi)\n      HOST_WIDE_INT low, hi;\n {\n   register tree t = make_node (INTEGER_CST);\n+\n   TREE_INT_CST_LOW (t) = low;\n   TREE_INT_CST_HIGH (t) = hi;\n   TREE_TYPE (t) = integer_type_node;\n@@ -1456,31 +1461,37 @@ real_value_from_int_cst (type, i)\n   return d;\n }\n \n+/* Args to pass to and from build_real_from_int_cst_1.  */\n+\n struct brfic_args\n {\n-  /* Input */\n-  tree type, i;\n-  /* Output */\n-  REAL_VALUE_TYPE d;\n+  tree type;\t\t\t/* Input: type to conver to. */\n+  tree i;\t\t\t/* Input: operand to convert */\n+  REAL_VALUE_TYPE d;\t\t/* Output: floating point value. */\n };\n \n+/* Convert an integer to a floating point value while protected by a floating\n+   point exception handler.  */\n+\n static void\n build_real_from_int_cst_1 (data)\n   PTR data;\n {\n-  struct brfic_args * args = (struct brfic_args *) data;\n+  struct brfic_args *args = (struct brfic_args *) data;\n   \n #ifdef REAL_ARITHMETIC\n   args->d = real_value_from_int_cst (args->type, args->i);\n #else\n-  args->d =\n-    REAL_VALUE_TRUNCATE (TYPE_MODE (args->type),\n-\t\t\t real_value_from_int_cst (args->type, args->i));\n+  args->d\n+    = REAL_VALUE_TRUNCATE (TYPE_MODE (args->type),\n+\t\t\t   real_value_from_int_cst (args->type, args->i));\n #endif\n }\n \n-/* This function can't be implemented if we can't do arithmetic\n-   on the float representation.  */\n+/* Given a tree representing an integer constant I, return a tree\n+   representing the same value as a floating-point constant of type TYPE.\n+   We cannot perform this operation if there is no way of doing arithmetic\n+   on floating-point values.  */\n \n tree\n build_real_from_int_cst (type, i)\n@@ -1500,10 +1511,8 @@ build_real_from_int_cst (type, i)\n   args.i = i;\n \n   if (do_float_handler (build_real_from_int_cst_1, (PTR) &args))\n-    {\n-      /* Receive output from build_real_from_int_cst_1() */\n-      d = args.d;\n-    }\n+    /* Receive output from build_real_from_int_cst_1() */\n+    d = args.d;\n   else\n     {\n       /* We got an exception from build_real_from_int_cst_1() */\n@@ -1538,11 +1547,13 @@ build_string (len, str)\n      deferring constant output in varasm.c.  */\n \n   register tree s = make_node (STRING_CST);\n+\n   TREE_STRING_LENGTH (s) = len;\n   if (ggc_p)\n     TREE_STRING_POINTER (s) = ggc_alloc_string (str, len);\n   else\n     TREE_STRING_POINTER (s) = obstack_copy0 (saveable_obstack, str, len);\n+\n   return s;\n }\n \n@@ -1897,10 +1908,8 @@ chain_member (elem, chain)\n }\n \n /* Return nonzero if ELEM is equal to TREE_VALUE (CHAIN) for any piece of\n-   chain CHAIN.  */\n-/* ??? This function was added for machine specific attributes but is no\n-   longer used.  It could be deleted if we could confirm all front ends\n-   don't use it.  */\n+   chain CHAIN.  This and the next function are currently unused, but\n+   are retained for completeness.  */\n \n int\n chain_member_value (elem, chain)\n@@ -1918,9 +1927,6 @@ chain_member_value (elem, chain)\n \n /* Return nonzero if ELEM is equal to TREE_PURPOSE (CHAIN)\n    for any piece of chain CHAIN.  */\n-/* ??? This function was added for machine specific attributes but is no\n-   longer used.  It could be deleted if we could confirm all front ends\n-   don't use it.  */\n \n int\n chain_member_purpose (elem, chain)\n@@ -2058,6 +2064,7 @@ build_decl_list (parm, value)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n+\n   current_obstack = &temp_decl_obstack;\n   node = build_tree_list (parm, value);\n   current_obstack = ambient_obstack;\n@@ -2072,6 +2079,7 @@ build_expr_list (parm, value)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n+\n   current_obstack = expression_obstack;\n   node = build_tree_list (parm, value);\n   current_obstack = ambient_obstack;\n@@ -2086,9 +2094,6 @@ tree\n tree_cons (purpose, value, chain)\n      tree purpose, value, chain;\n {\n-#if 0\n-  register tree node = make_node (TREE_LIST);\n-#else\n   register tree node;\n \n   if (ggc_p)\n@@ -2108,7 +2113,6 @@ tree_cons (purpose, value, chain)\n   TREE_SET_CODE (node, TREE_LIST);\n   if (current_obstack == &permanent_obstack)\n     TREE_PERMANENT (node) = 1;\n-#endif\n \n   TREE_CHAIN (node) = chain;\n   TREE_PURPOSE (node) = purpose;\n@@ -2124,6 +2128,7 @@ decl_tree_cons (purpose, value, chain)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n+\n   current_obstack = &temp_decl_obstack;\n   node = tree_cons (purpose, value, chain);\n   current_obstack = ambient_obstack;\n@@ -2138,6 +2143,7 @@ expr_tree_cons (purpose, value, chain)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n+\n   current_obstack = expression_obstack;\n   node = tree_cons (purpose, value, chain);\n   current_obstack = ambient_obstack;\n@@ -2152,8 +2158,8 @@ perm_tree_cons (purpose, value, chain)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = &permanent_obstack;\n \n+  current_obstack = &permanent_obstack;\n   node = tree_cons (purpose, value, chain);\n   current_obstack = ambient_obstack;\n   return node;\n@@ -2167,8 +2173,8 @@ temp_tree_cons (purpose, value, chain)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = &temporary_obstack;\n \n+  current_obstack = &temporary_obstack;\n   node = tree_cons (purpose, value, chain);\n   current_obstack = ambient_obstack;\n   return node;\n@@ -2182,8 +2188,8 @@ saveable_tree_cons (purpose, value, chain)\n {\n   register tree node;\n   register struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = saveable_obstack;\n \n+  current_obstack = saveable_obstack;\n   node = tree_cons (purpose, value, chain);\n   current_obstack = ambient_obstack;\n   return node;\n@@ -2206,11 +2212,13 @@ size_in_bytes (type)\n \n   type = TYPE_MAIN_VARIANT (type);\n   t = TYPE_SIZE_UNIT (type);\n+\n   if (t == 0)\n     {\n       incomplete_type_error (NULL_TREE, type);\n       return integer_zero_node;\n     }\n+\n   if (TREE_CODE (t) == INTEGER_CST)\n     force_fit_type (t, 0);\n \n@@ -2233,6 +2241,7 @@ int_size_in_bytes (type)\n   t = TYPE_SIZE_UNIT (type);\n   if (t == 0\n       || TREE_CODE (t) != INTEGER_CST\n+      || TREE_OVERFLOW (t)\n       || TREE_INT_CST_HIGH (t) != 0)\n     return -1;\n \n@@ -2433,7 +2442,7 @@ unsave_expr_1 (expr)\n   switch (TREE_CODE (expr))\n     {\n     case SAVE_EXPR:\n-      if (!SAVE_EXPR_PERSISTENT_P (expr))\n+      if (! SAVE_EXPR_PERSISTENT_P (expr))\n \tSAVE_EXPR_RTL (expr) = 0;\n       break;\n \n@@ -2444,7 +2453,7 @@ unsave_expr_1 (expr)\n       \n     case RTL_EXPR:\n       /* I don't yet know how to emit a sequence multiple times.  */\n-      if (RTL_EXPR_SEQUENCE (expr))\n+      if (RTL_EXPR_SEQUENCE (expr) != 0)\n \tabort ();\n       break;\n \n@@ -2453,7 +2462,7 @@ unsave_expr_1 (expr)\n       break;\n \n     default:\n-      if (lang_unsave_expr_now)\n+      if (lang_unsave_expr_now != 0)\n \t(*lang_unsave_expr_now) (expr);\n       break;\n     }\n@@ -2468,7 +2477,7 @@ unsave_expr_now_r (expr)\n   enum tree_code code;\n \n   /* There's nothing to do for NULL_TREE.  */\n-  if (!expr)\n+  if (expr == 0)\n     return;\n \n   unsave_expr_1 (expr);\n@@ -2521,7 +2530,7 @@ tree\n unsave_expr_now (expr)\n      tree expr;\n {\n-  if (lang_unsave)\n+  if (lang_unsave!= 0)\n     (*lang_unsave) (&expr);\n   else\n     unsave_expr_now_r (expr);\n@@ -3304,6 +3313,7 @@ build_block (vars, tags, subblocks, supercontext, chain)\n      tree vars, tags, subblocks, supercontext, chain;\n {\n   register tree block = make_node (BLOCK);\n+\n   BLOCK_VARS (block) = vars;\n   BLOCK_SUBBLOCKS (block) = subblocks;\n   BLOCK_SUPERCONTEXT (block) = supercontext;\n@@ -3323,7 +3333,7 @@ build_expr_wfl (node, file, line, col)\n      int line, col;\n {\n   static const char *last_file = 0;\n-  static tree  last_filenode = NULL_TREE;\n+  static tree last_filenode = NULL_TREE;\n   register tree wfl = make_node (EXPR_WITH_FILE_LOCATION);\n \n   EXPR_WFL_NODE (wfl) = node;\n@@ -3333,12 +3343,14 @@ build_expr_wfl (node, file, line, col)\n       last_file = file;\n       last_filenode = file ? get_identifier (file) : NULL_TREE;\n     }\n+\n   EXPR_WFL_FILENAME_NODE (wfl) = last_filenode;\n   if (node)\n     {\n       TREE_SIDE_EFFECTS (wfl) = TREE_SIDE_EFFECTS (node);\n       TREE_TYPE (wfl) = TREE_TYPE (node);\n     }\n+\n   return wfl;\n }\n \f\n@@ -3433,7 +3445,8 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \n #ifdef VALID_MACHINE_DECL_ATTRIBUTE\n   if (decl != 0\n-      && VALID_MACHINE_DECL_ATTRIBUTE (decl, decl_attr_list, attr_name, attr_args))\n+      && VALID_MACHINE_DECL_ATTRIBUTE (decl, decl_attr_list, attr_name,\n+\t\t\t\t       attr_args))\n     {\n       tree attr = lookup_attribute (IDENTIFIER_POINTER (attr_name),\n \t\t\t\t    decl_attr_list);\n@@ -3482,8 +3495,10 @@ valid_machine_attribute (attr_name, attr_args, decl, type)\n \t  else\n \t    TYPE_ATTRIBUTES (type) = type_attr_list;\n \t}\n+\n       if (decl != 0)\n \tTREE_TYPE (decl) = type;\n+\n       validated = 1;\n     }\n \n@@ -3606,12 +3621,12 @@ merge_attributes (a1, a2)\n \n   /* Either one unset?  Take the set one.  */\n \n-  if (! (attributes = a1))\n+  if ((attributes = a1) == 0)\n     attributes = a2;\n \n   /* One that completely contains the other?  Take it.  */\n \n-  else if (a2 && ! attribute_list_contained (a1, a2))\n+  else if (a2 != 0 && ! attribute_list_contained (a1, a2))\n   {\n     if (attribute_list_contained (a2, a1))\n       attributes = a2;\n@@ -3623,7 +3638,7 @@ merge_attributes (a1, a2)\n \tif (list_length (a1) < list_length (a2))\n \t  attributes = a2, a2 = a1;\n \n-\tfor (; a2; a2 = TREE_CHAIN (a2))\n+\tfor (; a2 != 0; a2 = TREE_CHAIN (a2))\n \t  if (lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (a2)),\n \t\t\t\tattributes) == NULL_TREE)\n \t    {\n@@ -3744,8 +3759,10 @@ type_hash_list (list)\n {\n   register int hashcode;\n   register tree tail;\n+\n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n     hashcode += TYPE_HASH (TREE_VALUE (tail));\n+\n   return hashcode;\n }\n \n@@ -3785,6 +3802,7 @@ type_hash_lookup (hashcode, type)\n \t\t&& type_list_equal (TYPE_DOMAIN (h->type),\n \t\t\t\t    TYPE_DOMAIN (type)))))\n       return h->type;\n+\n   return 0;\n }\n \n@@ -3834,6 +3852,7 @@ type_hash_canon (hashcode, type)\n     {\n       if (!ggc_p)\n \tobstack_free (TYPE_OBSTACK (type), type);\n+\n #ifdef GATHER_STATISTICS\n       tree_node_counts[(int)t_kind]--;\n       tree_node_sizes[(int)t_kind] -= sizeof (struct tree_type);\n@@ -3873,6 +3892,7 @@ attribute_hash_list (list)\n {\n   register int hashcode;\n   register tree tail;\n+\n   for (hashcode = 0, tail = list; tail; tail = TREE_CHAIN (tail))\n     /* ??? Do we want to add in TREE_VALUE too? */\n     hashcode += TYPE_HASH (TREE_PURPOSE (tail));\n@@ -3910,7 +3930,7 @@ attribute_list_contained (l1, l2)\n \n   /* Maybe the lists are similar.  */\n   for (t1 = l1, t2 = l2;\n-       t1 && t2\n+       t1 != 0 && t2 != 0\n         && TREE_PURPOSE (t1) == TREE_PURPOSE (t2)\n         && TREE_VALUE (t1) == TREE_VALUE (t2);\n        t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2));\n@@ -3919,13 +3939,14 @@ attribute_list_contained (l1, l2)\n   if (t1 == 0 && t2 == 0)\n      return 1;\n \n-  for (; t2; t2 = TREE_CHAIN (t2))\n+  for (; t2 != 0; t2 = TREE_CHAIN (t2))\n     {\n       tree attr\n \t= lookup_attribute (IDENTIFIER_POINTER (TREE_PURPOSE (t2)), l1);\n \n-      if (attr == NULL_TREE)\n+      if (attr == 0)\n \treturn 0;\n+\n       if (simple_cst_equal (TREE_VALUE (t2), TREE_VALUE (attr)) != 1)\n \treturn 0;\n     }\n@@ -3964,13 +3985,16 @@ tree_int_cst_equal (t1, t2)\n {\n   if (t1 == t2)\n     return 1;\n+\n   if (t1 == 0 || t2 == 0)\n     return 0;\n+\n   if (TREE_CODE (t1) == INTEGER_CST\n       && TREE_CODE (t2) == INTEGER_CST\n       && TREE_INT_CST_LOW (t1) == TREE_INT_CST_LOW (t2)\n       && TREE_INT_CST_HIGH (t1) == TREE_INT_CST_HIGH (t2))\n     return 1;\n+\n   return 0;\n }\n \n@@ -3984,8 +4008,9 @@ tree_int_cst_lt (t1, t2)\n   if (t1 == t2)\n     return 0;\n \n-  if (!TREE_UNSIGNED (TREE_TYPE (t1)))\n+  if (! TREE_UNSIGNED (TREE_TYPE (t1)))\n     return INT_CST_LT (t1, t2);\n+\n   return INT_CST_LT_UNSIGNED (t1, t2);\n }\n \n@@ -4023,7 +4048,7 @@ simple_cst_list_equal (l1, l2)\n       l2 = TREE_CHAIN (l2);\n     }\n \n-  return (l1 == l2);\n+  return l1 == l2;\n }\n \n /* Return truthvalue of whether T1 is the same tree structure as T2.\n@@ -4038,6 +4063,7 @@ simple_cst_equal (t1, t2)\n {\n   register enum tree_code code1, code2;\n   int cmp;\n+  int i;\n \n   if (t1 == t2)\n     return 1;\n@@ -4055,6 +4081,7 @@ simple_cst_equal (t1, t2)\n       else\n \treturn simple_cst_equal (TREE_OPERAND (t1, 0), t2);\n     }\n+\n   else if (code2 == NOP_EXPR || code2 == CONVERT_EXPR\n \t   || code2 == NON_LVALUE_EXPR)\n     return simple_cst_equal (t1, TREE_OPERAND (t2, 0));\n@@ -4065,16 +4092,16 @@ simple_cst_equal (t1, t2)\n   switch (code1)\n     {\n     case INTEGER_CST:\n-      return TREE_INT_CST_LOW (t1) == TREE_INT_CST_LOW (t2)\n-\t&& TREE_INT_CST_HIGH (t1) == TREE_INT_CST_HIGH (t2);\n+      return (TREE_INT_CST_LOW (t1) == TREE_INT_CST_LOW (t2)\n+\t      && TREE_INT_CST_HIGH (t1) == TREE_INT_CST_HIGH (t2));\n \n     case REAL_CST:\n       return REAL_VALUES_IDENTICAL (TREE_REAL_CST (t1), TREE_REAL_CST (t2));\n \n     case STRING_CST:\n-      return TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n-\t&& !bcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n-\t\t  TREE_STRING_LENGTH (t1));\n+      return (TREE_STRING_LENGTH (t1) == TREE_STRING_LENGTH (t2)\n+\t      && ! bcmp (TREE_STRING_POINTER (t1), TREE_STRING_POINTER (t2),\n+\t\t\t TREE_STRING_LENGTH (t1)));\n \n     case CONSTRUCTOR:\n       if (CONSTRUCTOR_ELTS (t1) == CONSTRUCTOR_ELTS (t2))\n@@ -4089,7 +4116,8 @@ simple_cst_equal (t1, t2)\n       cmp = simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n       if (cmp <= 0)\n \treturn cmp;\n-      return simple_cst_list_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n+      return\n+\tsimple_cst_list_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n \n     case TARGET_EXPR:\n       /* Special case: if either target is an unallocated VAR_DECL,\n@@ -4105,19 +4133,23 @@ simple_cst_equal (t1, t2)\n \tcmp = 1;\n       else\n \tcmp = simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n       if (cmp <= 0)\n \treturn cmp;\n+\n       return simple_cst_equal (TREE_OPERAND (t1, 1), TREE_OPERAND (t2, 1));\n \n     case WITH_CLEANUP_EXPR:\n       cmp = simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n       if (cmp <= 0)\n \treturn cmp;\n+\n       return simple_cst_equal (TREE_OPERAND (t1, 2), TREE_OPERAND (t1, 2));\n \n     case COMPONENT_REF:\n       if (TREE_OPERAND (t1, 1) == TREE_OPERAND (t2, 1))\n \treturn simple_cst_equal (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0));\n+\n       return 0;\n \n     case VAR_DECL:\n@@ -4139,20 +4171,20 @@ simple_cst_equal (t1, t2)\n \n   switch (TREE_CODE_CLASS (code1))\n     {\n-      int i;\n     case '1':\n     case '2':\n     case '<':\n     case 'e':\n     case 'r':\n     case 's':\n       cmp = 1;\n-      for (i=0; i<tree_code_length[(int) code1]; ++i)\n+      for (i = 0; i < tree_code_length[(int) code1]; i++)\n \t{\n \t  cmp = simple_cst_equal (TREE_OPERAND (t1, i), TREE_OPERAND (t2, i));\n \t  if (cmp <= 0)\n \t    return cmp;\n \t}\n+\n       return cmp;\n \n     default:\n@@ -4175,7 +4207,7 @@ build_pointer_type (to_type)\n \n   /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n \n-  if (t)\n+  if (t != 0)\n     return t;\n \n   /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n@@ -4196,6 +4228,34 @@ build_pointer_type (to_type)\n   return t;\n }\n \n+/* Build the node for the type of references-to-TO_TYPE.  */\n+\n+tree\n+build_reference_type (to_type)\n+     tree to_type;\n+{\n+  register tree t = TYPE_REFERENCE_TO (to_type);\n+\n+  /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n+\n+  if (t)\n+    return t;\n+\n+  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n+  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n+  t = make_node (REFERENCE_TYPE);\n+  pop_obstacks ();\n+\n+  TREE_TYPE (t) = to_type;\n+\n+  /* Record this type as the pointer to TO_TYPE.  */\n+  TYPE_REFERENCE_TO (to_type) = t;\n+\n+  layout_type (t);\n+\n+  return t;\n+}\n+\n /* Create a type of integers to be the TYPE_DOMAIN of an ARRAY_TYPE.\n    MAXVAL should be the maximum value in the domain\n    (one less than the length of the array).\n@@ -4302,13 +4362,15 @@ index_type_equal (itype1, itype2)\n {\n   if (TREE_CODE (itype1) != TREE_CODE (itype2))\n     return 0;\n+\n   if (TREE_CODE (itype1) == INTEGER_TYPE)\n     {\n       if (TYPE_PRECISION (itype1) != TYPE_PRECISION (itype2)\n \t  || TYPE_MODE (itype1) != TYPE_MODE (itype2)\n \t  || simple_cst_equal (TYPE_SIZE (itype1), TYPE_SIZE (itype2)) != 1\n \t  || TYPE_ALIGN (itype1) != TYPE_ALIGN (itype2))\n \treturn 0;\n+\n       if (1 == simple_cst_equal (TYPE_MIN_VALUE (itype1),\n \t\t\t\t TYPE_MIN_VALUE (itype2))\n \t  && 1 == simple_cst_equal (TYPE_MAX_VALUE (itype1),\n@@ -4407,34 +4469,6 @@ build_function_type (value_type, arg_types)\n   return t;\n }\n \n-/* Build the node for the type of references-to-TO_TYPE.  */\n-\n-tree\n-build_reference_type (to_type)\n-     tree to_type;\n-{\n-  register tree t = TYPE_REFERENCE_TO (to_type);\n-\n-  /* First, if we already have a type for pointers to TO_TYPE, use it.  */\n-\n-  if (t)\n-    return t;\n-\n-  /* We need a new one.  Put this in the same obstack as TO_TYPE.   */\n-  push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));\n-  t = make_node (REFERENCE_TYPE);\n-  pop_obstacks ();\n-\n-  TREE_TYPE (t) = to_type;\n-\n-  /* Record this type as the pointer to TO_TYPE.  */\n-  TYPE_REFERENCE_TO (to_type) = t;\n-\n-  layout_type (t);\n-\n-  return t;\n-}\n-\n /* Construct, lay out and return the type of methods belonging to class\n    BASETYPE and whose arguments and values are described by TYPE.\n    If that type exists already, reuse it.\n@@ -4550,9 +4584,9 @@ build_complex_type (component_type)\n       else if (component_type == long_long_unsigned_type_node)\n \tname = \"complex long long unsigned int\";\n       else\n-\tname = (char *)0;\n+\tname = 0;\n \n-      if (name)\n+      if (name != 0)\n \tTYPE_NAME (t) = get_identifier (name);\n     }\n \n@@ -4684,8 +4718,8 @@ get_narrower (op, unsignedp_ptr)\n   while (TREE_CODE (op) == NOP_EXPR)\n     {\n       register int bitschange\n-\t= TYPE_PRECISION (TREE_TYPE (op))\n-\t  - TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op, 0)));\n+\t= (TYPE_PRECISION (TREE_TYPE (op))\n+\t   - TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (op, 0))));\n \n       /* Truncations are many-one so cannot be removed.  */\n       if (bitschange < 0)\n@@ -4841,11 +4875,14 @@ decl_type_context (decl)\n \t  || TREE_CODE (context) == UNION_TYPE\n \t  || TREE_CODE (context) == QUAL_UNION_TYPE)\n \treturn context;\n+\n       if (TREE_CODE (context) == TYPE_DECL\n \t  || TREE_CODE (context) == FUNCTION_DECL)\n \tcontext = DECL_CONTEXT (context);\n+\n       else if (TREE_CODE (context) == BLOCK)\n \tcontext = BLOCK_SUPERCONTEXT (context);\n+\n       else\n \t/* Unhandled CONTEXT!?  */\n \tabort ();\n@@ -4955,8 +4992,8 @@ dump_tree_statistics ()\n #endif\t/* NO_DOT_IN_LABEL */\n #endif\t/* NO_DOLLAR_IN_LABEL */\n \n-extern char * first_global_object_name;\n-extern char * weak_global_object_name;\n+extern char *first_global_object_name;\n+extern char *weak_global_object_name;\n \n /* Appends 6 random characters to TEMPLATE to (hopefully) avoid name\n    clashes in cases where we can't reliably choose a unique name.\n@@ -5039,10 +5076,10 @@ get_file_function_name_long (type)\n   buf = (char *) alloca (sizeof (FILE_FUNCTION_FORMAT) + strlen (p)\n \t\t\t + strlen (type));\n \n-  /* Set up the name of the file-level functions we may need.  */\n-  /* Use a global object (which is already required to be unique over\n+  /* Set up the name of the file-level functions we may need. \n+     Use a global object (which is already required to be unique over\n      the program) rather than the file name (which imposes extra\n-     constraints).  -- Raeburn@MIT.EDU, 10 Jan 1990.  */\n+     constraints).  */\n   sprintf (buf, FILE_FUNCTION_FORMAT, type, p);\n \n   /* Don't need to pull weird characters out of global names.  */\n@@ -5077,12 +5114,12 @@ get_file_function_name (kind)\n      int kind;\n {\n   char p[2];\n+\n   p[0] = kind;\n   p[1] = 0;\n \n   return get_file_function_name_long (p);\n }\n-\n \f\n /* Expand (the constant part of) a SET_TYPE CONSTRUCTOR node.\n    The result is placed in BUFFER (which has length BIT_SIZE),\n@@ -5221,7 +5258,7 @@ int\n get_alias_set (t)\n      tree t;\n {\n-  if (!flag_strict_aliasing || !lang_get_alias_set)\n+  if (! flag_strict_aliasing || lang_get_alias_set == 0)\n     /* If we're not doing any lanaguage-specific alias analysis, just\n        assume everything aliases everything else.  */\n     return 0;\n@@ -5235,6 +5272,7 @@ int\n new_alias_set ()\n {\n   static int last_alias_set;\n+\n   if (flag_strict_aliasing)\n     return ++last_alias_set;\n   else\n@@ -5321,8 +5359,8 @@ build_common_tree_nodes (signed_char)\n   unsigned_intTI_type_node = make_unsigned_type (GET_MODE_BITSIZE (TImode));\n }\n \n-/* For type TYPE, fill in the proper type for TYPE_SIZE and\n-   TYPE_SIZE_UNIT.  */\n+/* For type TYPE, fill in the proper type for TYPE_SIZE and TYPE_SIZE_UNIT.  */\n+\n static void\n fix_sizetype (type)\n      tree type;\n@@ -5334,6 +5372,7 @@ fix_sizetype (type)\n /* Call this function after calling build_common_tree_nodes and set_sizetype.\n    It will fix the previously made nodes to have proper references to\n    sizetype, and it will create several other common tree nodes.  */\n+\n void\n build_common_tree_nodes_2 (short_double)\n      int short_double;\n@@ -5373,6 +5412,7 @@ build_common_tree_nodes_2 (short_double)\n \n   void_type_node = make_node (VOID_TYPE);\n   layout_type (void_type_node);\t/* Uses size_zero_node */\n+\n   /* We are not going to have real types in C with less than byte alignment,\n      so we might as well not have any types that claim to have it.  */\n   TYPE_ALIGN (void_type_node) = BITS_PER_UNIT;"}]}