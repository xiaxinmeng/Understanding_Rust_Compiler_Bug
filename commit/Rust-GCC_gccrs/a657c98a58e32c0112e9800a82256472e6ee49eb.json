{"sha": "a657c98a58e32c0112e9800a82256472e6ee49eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY1N2M5OGE1OGUzMmMwMTEyZTk4MDBhODIyNTY0NzJlNmVlNDllYg==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2004-08-24T20:16:41Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2004-08-24T20:16:41Z"}, "message": "arm.md: Include predicates.md.\n\n* arm.md: Include predicates.md.\n* predicates.md: New file.\n* arm.c (s_register_operand, arm_hard_register_operand)\n(arm_general_register_operand, f_register_operand, reg_or_int_operand)\n(arm_immediate_operand, arm_neg_immediate_operand)\n(arm_not_immediate_operand, arm_rhs_operand, arm_rhsm_operand)\n(arm_add_operand, arm_addimm_operand, arm_not_operand)\n(offsettable_memory_operand, alignable_memory_operand)\n(arm_reload_memory_operand, arm_float_rhs_operand)\n(arm_float_add_operand, vfp_compare_operand, arm_float_compare_operand)\n(index_operand, shiftable_operator, logical_binary_operator)\n(shift_operator, equality_operator, arm_comparison_operator)\n(minmax_operator, cc_register, dominant_cc_register)\n(arm_extendqisi_mem_op, power_of_two_operand, nonimmediate_di_operand)\n(di_operand, nonimmediate_soft_df_operand, soft_df_operand)\n(const_shift_operand, load_multiple_operation)\n(store_multiple_operation, multi_register_push, thumb_cmp_operand)\n(thumb_cmpneg_operand, thumb_cbrch_target_operand)\n(cirrus_register_operand, cirrus_fp_register)\n(cirrus_shift_const): Delete, replaced with equivalents in\npredicates.md.\n(shift_op): Handle ROTATE.\n* arm-protos.h: Delete declarations for above.\n* arm.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES): Delete.\n* t-arm (MD_INCLUDES): Add predicates.md.\n(s-preds): Depends on MD_INCLUDES.\n\nFrom-SVN: r86512", "tree": {"sha": "b10ec7180a44eb07ace1f0b833696d505ad035f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b10ec7180a44eb07ace1f0b833696d505ad035f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a657c98a58e32c0112e9800a82256472e6ee49eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a657c98a58e32c0112e9800a82256472e6ee49eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a657c98a58e32c0112e9800a82256472e6ee49eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a657c98a58e32c0112e9800a82256472e6ee49eb/comments", "author": null, "committer": null, "parents": [{"sha": "886ce862cb96d58a91700af29baea916af2aae35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/886ce862cb96d58a91700af29baea916af2aae35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/886ce862cb96d58a91700af29baea916af2aae35"}], "stats": {"total": 1324, "additions": 510, "deletions": 814}, "files": [{"sha": "71573960708a1f7939b9d346e59f87838db2054c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -1,3 +1,32 @@\n+2004-08-24  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.md: Include predicates.md.\n+\t* predicates.md: New file.\n+\t* arm.c (s_register_operand, arm_hard_register_operand)\n+\t(arm_general_register_operand, f_register_operand, reg_or_int_operand)\n+\t(arm_immediate_operand, arm_neg_immediate_operand)\n+\t(arm_not_immediate_operand, arm_rhs_operand, arm_rhsm_operand)\n+\t(arm_add_operand, arm_addimm_operand, arm_not_operand)\n+\t(offsettable_memory_operand, alignable_memory_operand)\n+\t(arm_reload_memory_operand, arm_float_rhs_operand)\n+\t(arm_float_add_operand, vfp_compare_operand, arm_float_compare_operand)\n+\t(index_operand, shiftable_operator, logical_binary_operator)\n+\t(shift_operator, equality_operator, arm_comparison_operator)\n+\t(minmax_operator, cc_register, dominant_cc_register)\n+\t(arm_extendqisi_mem_op, power_of_two_operand, nonimmediate_di_operand)\n+\t(di_operand, nonimmediate_soft_df_operand, soft_df_operand)\n+\t(const_shift_operand, load_multiple_operation)\n+\t(store_multiple_operation, multi_register_push, thumb_cmp_operand)\n+\t(thumb_cmpneg_operand, thumb_cbrch_target_operand)\n+\t(cirrus_register_operand, cirrus_fp_register)\n+\t(cirrus_shift_const): Delete, replaced with equivalents in\n+\tpredicates.md.\n+\t(shift_op): Handle ROTATE.\n+\t* arm-protos.h: Delete declarations for above.\n+\t* arm.h (PREDICATE_CODES, SPECIAL_MODE_PREDICATES): Delete.\n+\t* t-arm (MD_INCLUDES): Add predicates.md.\n+\t(s-preds): Depends on MD_INCLUDES.\n+\n 2004-08-24  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.c (mips_gen_conditional_trap): Fix mode."}, {"sha": "7a75002ffec9062c5aac478bfb00c2743ae9713a", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -61,49 +61,8 @@ extern int arm_const_double_rtx (rtx);\n extern int neg_const_double_rtx_ok_for_fpa (rtx);\n extern enum reg_class vfp_secondary_reload_class (enum machine_mode, rtx);\n \n-/* Predicates.  */\n-extern int s_register_operand (rtx, enum machine_mode);\n-extern int arm_hard_register_operand (rtx, enum machine_mode);\n-extern int arm_general_register_operand (rtx, enum machine_mode);\n-extern int f_register_operand (rtx, enum machine_mode);\n-extern int reg_or_int_operand (rtx, enum machine_mode);\n-extern int arm_reload_memory_operand (rtx, enum machine_mode);\n-extern int arm_rhs_operand (rtx, enum machine_mode);\n-extern int arm_rhsm_operand (rtx, enum machine_mode);\n-extern int arm_add_operand (rtx, enum machine_mode);\n-extern int arm_addimm_operand (rtx, enum machine_mode);\n-extern int arm_not_operand (rtx, enum machine_mode);\n-extern int arm_extendqisi_mem_op (rtx, enum machine_mode);\n-extern int offsettable_memory_operand (rtx, enum machine_mode);\n-extern int alignable_memory_operand (rtx, enum machine_mode);\n-extern int arm_float_rhs_operand (rtx, enum machine_mode);\n-extern int arm_float_add_operand (rtx, enum machine_mode);\n-extern int power_of_two_operand (rtx, enum machine_mode);\n-extern int nonimmediate_di_operand (rtx, enum machine_mode);\n-extern int di_operand (rtx, enum machine_mode);\n-extern int nonimmediate_soft_df_operand (rtx, enum machine_mode);\n-extern int soft_df_operand (rtx, enum machine_mode);\n-extern int index_operand (rtx, enum machine_mode);\n-extern int const_shift_operand (rtx, enum machine_mode);\n-extern int arm_comparison_operator (rtx, enum machine_mode);\n-extern int shiftable_operator (rtx, enum machine_mode);\n-extern int shift_operator (rtx, enum machine_mode);\n-extern int equality_operator (rtx, enum machine_mode);\n-extern int minmax_operator (rtx, enum machine_mode);\n-extern int cc_register (rtx, enum machine_mode);\n-extern int dominant_cc_register (rtx, enum machine_mode);\n-extern int logical_binary_operator (rtx, enum machine_mode);\n-extern int multi_register_push (rtx, enum machine_mode);\n-extern int load_multiple_operation (rtx, enum machine_mode);\n-extern int store_multiple_operation (rtx, enum machine_mode);\n-extern int cirrus_fp_register (rtx, enum machine_mode);\n-extern int cirrus_general_operand (rtx, enum machine_mode);\n-extern int cirrus_register_operand (rtx, enum machine_mode);\n-extern int cirrus_shift_const (rtx, enum machine_mode);\n extern int cirrus_memory_offset (rtx);\n extern int arm_coproc_mem_operand (rtx, bool);\n-extern int vfp_compare_operand (rtx, enum machine_mode);\n-extern int arm_float_compare_operand (rtx, enum machine_mode);\n extern int arm_no_early_store_addr_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_dep (rtx, rtx);\n extern int arm_no_early_alu_shift_value_dep (rtx, rtx);\n@@ -191,8 +150,6 @@ extern void thumb_final_prescan_insn (rtx);\n extern const char *thumb_load_double_from_address (rtx *);\n extern const char *thumb_output_move_mem_multiple (int, rtx *);\n extern void thumb_expand_movmemqi (rtx *);\n-extern int thumb_cmp_operand (rtx, enum machine_mode);\n-extern int thumb_cbrch_target_operand (rtx, enum machine_mode);\n extern rtx *thumb_legitimize_pic_address (rtx, enum machine_mode, rtx);\n extern int thumb_go_if_legitimate_address (enum machine_mode, rtx);\n extern rtx arm_return_addr (int, rtx);"}, {"sha": "ce9a27c231ae8295000a31c7e8a3aafaec397bc8", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 7, "deletions": 719, "changes": 726, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -4624,243 +4624,6 @@ neg_const_double_rtx_ok_for_fpa (rtx x)\n \f\n /* Predicates for `match_operand' and `match_operator'.  */\n \n-/* s_register_operand is the same as register_operand, but it doesn't accept\n-   (SUBREG (MEM)...).\n-\n-   This function exists because at the time it was put in it led to better\n-   code.  SUBREG(MEM) always needs a reload in the places where\n-   s_register_operand is used, and this seemed to lead to excessive\n-   reloading.  */\n-int\n-s_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  /* We don't consider registers whose class is NO_REGS\n-     to be a register operand.  */\n-  /* XXX might have to check for lo regs only for thumb ??? */\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n-}\n-\n-/* A hard register operand (even before reload.  */\n-int\n-arm_hard_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  return (GET_CODE (op) == REG\n-\t  && REGNO (op) < FIRST_PSEUDO_REGISTER);\n-}\n-\n-/* An arm register operand.  */\n-int\n-arm_general_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) <= LAST_ARM_REGNUM\n-\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER));\n-}\n-\n-/* Only accept reg, subreg(reg), const_int.  */\n-int\n-reg_or_int_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    return 1;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  /* We don't consider registers whose class is NO_REGS\n-     to be a register operand.  */\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n-}\n-\n-/* Return 1 if OP is an item in memory, given that we are in reload.  */\n-int\n-arm_reload_memory_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  int regno = true_regnum (op);\n-\n-  return (!CONSTANT_P (op)\n-\t  && (regno == -1\n-\t      || (GET_CODE (op) == REG\n-\t\t  && REGNO (op) >= FIRST_PSEUDO_REGISTER)));\n-}\n-\n-/* Return TRUE for valid operands for the rhs of an ARM instruction.  */\n-int\n-arm_rhs_operand (rtx op, enum machine_mode mode)\n-{\n-  return (s_register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op))));\n-}\n-\n-/* Return TRUE for valid operands for the\n-   rhs of an ARM instruction, or a load.  */\n-int\n-arm_rhsm_operand (rtx op, enum machine_mode mode)\n-{\n-  return (s_register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT && const_ok_for_arm (INTVAL (op)))\n-\t  || memory_operand (op, mode));\n-}\n-\n-/* Return TRUE for valid operands for the rhs of an ARM instruction, or if a\n-   constant that is valid when negated.  */\n-int\n-arm_add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_THUMB)\n-    return thumb_cmp_operand (op, mode);\n-\n-  return (s_register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (const_ok_for_arm (INTVAL (op))\n-\t\t  || const_ok_for_arm (-INTVAL (op)))));\n-}\n-\n-/* Return TRUE for valid ARM constants (or when valid if negated).  */\n-int\n-arm_addimm_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (const_ok_for_arm (INTVAL (op))\n-\t      || const_ok_for_arm (-INTVAL (op))));\n-}\n-\n-int\n-arm_not_operand (rtx op, enum machine_mode mode)\n-{\n-  return (s_register_operand (op, mode)\n-\t  || (GET_CODE (op) == CONST_INT\n-\t      && (const_ok_for_arm (INTVAL (op))\n-\t\t  || const_ok_for_arm (~INTVAL (op)))));\n-}\n-\n-/* Return TRUE if the operand is a memory reference which contains an\n-   offsettable address.  */\n-int\n-offsettable_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  return (mode == GET_MODE (op)\n-\t  && GET_CODE (op) == MEM\n-\t  && offsettable_address_p (reload_completed | reload_in_progress,\n-\t\t\t\t    mode, XEXP (op, 0)));\n-}\n-\n-/* Return TRUE if the operand is a memory reference which is, or can be\n-   made word aligned by adjusting the offset.  */\n-int\n-alignable_memory_operand (rtx op, enum machine_mode mode)\n-{\n-  rtx reg;\n-\n-  if (mode == VOIDmode)\n-    mode = GET_MODE (op);\n-\n-  if (mode != GET_MODE (op) || GET_CODE (op) != MEM)\n-    return 0;\n-\n-  op = XEXP (op, 0);\n-\n-  return ((GET_CODE (reg = op) == REG\n-\t   || (GET_CODE (op) == SUBREG\n-\t       && GET_CODE (reg = SUBREG_REG (op)) == REG)\n-\t   || (GET_CODE (op) == PLUS\n-\t       && GET_CODE (XEXP (op, 1)) == CONST_INT\n-\t       && (GET_CODE (reg = XEXP (op, 0)) == REG\n-\t\t   || (GET_CODE (XEXP (op, 0)) == SUBREG\n-\t\t       && GET_CODE (reg = SUBREG_REG (XEXP (op, 0))) == REG))))\n-\t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 32);\n-}\n-\n-/* Similar to s_register_operand, but does not allow hard integer\n-   registers.  */\n-int\n-f_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return 0;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  /* We don't consider registers whose class is NO_REGS\n-     to be a register operand.  */\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) == FPA_REGS));\n-}\n-\n-/* Return TRUE for valid operands for the rhs of an floating point insns.\n-   Allows regs or certain consts on FPA, just regs for everything else.  */\n-int\n-arm_float_rhs_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (TARGET_FPA && GET_CODE (op) == CONST_DOUBLE)\n-    return arm_const_double_rtx (op);\n-\n-  return FALSE;\n-}\n-\n-int\n-arm_float_add_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (TARGET_FPA && GET_CODE (op) == CONST_DOUBLE)\n-    return (arm_const_double_rtx (op)\n-\t    || neg_const_double_rtx_ok_for_fpa (op));\n-\n-  return FALSE;\n-}\n-\n-\n-/* Return TRUE if OP is suitable for the rhs of a floating point comparison.\n-   Depends which fpu we are targeting.  */\n-\n-int\n-arm_float_compare_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_VFP)\n-    return vfp_compare_operand (op, mode);\n-  else\n-    return arm_float_rhs_operand (op, mode);\n-}\n-\n-\n /* Return nonzero if OP is a valid Cirrus memory address pattern.  */\n int\n cirrus_memory_offset (rtx op)\n@@ -4898,55 +4661,6 @@ cirrus_memory_offset (rtx op)\n   return 0;\n }\n \n-int\n-arm_extendqisi_mem_op (rtx op, enum machine_mode mode)\n-{\n-  if (!memory_operand (op, mode))\n-    return 0;\n-\n-  return arm_legitimate_address_p (mode, XEXP (op, 0), SIGN_EXTEND, 0);\n-}\n-\n-/* Return nonzero if OP is a Cirrus or general register.  */\n-int\n-cirrus_register_operand (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS\n-\t      || REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS));\n-}\n-\n-/* Return nonzero if OP is a cirrus FP register.  */\n-int\n-cirrus_fp_register (rtx op, enum machine_mode mode)\n-{\n-  if (GET_MODE (op) != mode && mode != VOIDmode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  return (GET_CODE (op) == REG\n-\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n-\t      || REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS));\n-}\n-\n-/* Return nonzero if OP is a 6bit constant (0..63).  */\n-int\n-cirrus_shift_const (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) >= 0\n-\t  && INTVAL (op) < 64);\n-}\n-\n-\n /* Return TRUE if OP is a valid VFP memory address pattern.\n    WB if true if writeback address modes are allowed.  */\n \n@@ -5014,18 +4728,6 @@ arm_coproc_mem_operand (rtx op, bool wb)\n }\n \n \n-/* Return TRUE if OP is a REG or constant zero.  */\n-int\n-vfp_compare_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  return (GET_CODE (op) == CONST_DOUBLE\n-\t  && arm_const_double_rtx (op));\n-}\n-\n-\n /* Return GENERAL_REGS if a scratch register required to reload x to/from\n    VFP registers.  Otherwise return NO_REGS.  */\n \n@@ -5211,262 +4913,6 @@ cirrus_reorg (rtx first)\n     }\n }\n \n-/* Return nonzero if OP is a constant power of two.  */\n-int\n-power_of_two_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) == CONST_INT)\n-    {\n-      HOST_WIDE_INT value = INTVAL (op);\n-\n-      return value != 0  &&  (value & (value - 1)) == 0;\n-    }\n-\n-  return FALSE;\n-}\n-\n-/* Return TRUE for a valid operand of a DImode operation.\n-   Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).\n-   Note that this disallows MEM(REG+REG), but allows\n-   MEM(PRE/POST_INC/DEC(REG)).  */\n-int\n-di_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && GET_MODE (op) != DImode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_DOUBLE:\n-    case CONST_INT:\n-      return TRUE;\n-\n-    case MEM:\n-      return memory_address_p (DImode, XEXP (op, 0));\n-\n-    default:\n-      return FALSE;\n-    }\n-}\n-\n-/* Like di_operand, but don't accept constants.  */\n-int\n-nonimmediate_di_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (mode != VOIDmode && GET_MODE (op) != VOIDmode && GET_MODE (op) != DImode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) == MEM)\n-    return memory_address_p (DImode, XEXP (op, 0));\n-\n-  return FALSE;\n-}\n-\n-/* Return TRUE for a valid operand of a DFmode operation when soft-float.\n-   Either: REG, SUBREG, CONST_DOUBLE or MEM(DImode_address).\n-   Note that this disallows MEM(REG+REG), but allows\n-   MEM(PRE/POST_INC/DEC(REG)).  */\n-int\n-soft_df_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG && CONSTANT_P (SUBREG_REG (op)))\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  switch (GET_CODE (op))\n-    {\n-    case CONST_DOUBLE:\n-      return TRUE;\n-\n-    case MEM:\n-      return memory_address_p (DFmode, XEXP (op, 0));\n-\n-    default:\n-      return FALSE;\n-    }\n-}\n-\n-/* Like soft_df_operand, but don't accept constants.  */\n-int\n-nonimmediate_soft_df_operand (rtx op, enum machine_mode mode)\n-{\n-  if (s_register_operand (op, mode))\n-    return TRUE;\n-\n-  if (mode != VOIDmode && GET_MODE (op) != mode)\n-    return FALSE;\n-\n-  if (GET_CODE (op) == SUBREG)\n-    op = SUBREG_REG (op);\n-\n-  if (GET_CODE (op) == MEM)\n-    return memory_address_p (DFmode, XEXP (op, 0));\n-  return FALSE;\n-}\n-\n-/* Return TRUE for valid index operands.  */\n-int\n-index_operand (rtx op, enum machine_mode mode)\n-{\n-  return (s_register_operand (op, mode)\n-\t  || (immediate_operand (op, mode)\n-\t      && (GET_CODE (op) != CONST_INT\n-\t\t  || (INTVAL (op) < 4096 && INTVAL (op) > -4096))));\n-}\n-\n-/* Return TRUE for valid shifts by a constant. This also accepts any\n-   power of two on the (somewhat overly relaxed) assumption that the\n-   shift operator in this case was a mult.  */\n-int\n-const_shift_operand (rtx op, enum machine_mode mode)\n-{\n-  return (power_of_two_operand (op, mode)\n-\t  || (immediate_operand (op, mode)\n-\t      && (GET_CODE (op) != CONST_INT\n-\t\t  || (INTVAL (op) < 32 && INTVAL (op) > 0))));\n-}\n-\n-/* Return TRUE for arithmetic operators which can be combined with a multiply\n-   (shift).  */\n-int\n-shiftable_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code;\n-\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  code = GET_CODE (x);\n-\n-  return (code == PLUS || code == MINUS\n-\t  || code == IOR || code == XOR || code == AND);\n-}\n-\n-/* Return TRUE for binary logical operators.  */\n-int\n-logical_binary_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code;\n-\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  code = GET_CODE (x);\n-\n-  return (code == IOR || code == XOR || code == AND);\n-}\n-\n-/* Return TRUE for shift operators.  */\n-int\n-shift_operator (rtx x,enum machine_mode mode)\n-{\n-  enum rtx_code code;\n-\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  code = GET_CODE (x);\n-\n-  if (code == MULT)\n-    return power_of_two_operand (XEXP (x, 1), mode);\n-\n-  return (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT\n-\t  || code == ROTATERT);\n-}\n-\n-/* Return TRUE if x is EQ or NE.  */\n-int\n-equality_operator (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return GET_CODE (x) == EQ || GET_CODE (x) == NE;\n-}\n-\n-/* Return TRUE if x is a comparison operator other than LTGT or UNEQ.  */\n-int\n-arm_comparison_operator (rtx x, enum machine_mode mode)\n-{\n-  return (comparison_operator (x, mode)\n-\t  && GET_CODE (x) != LTGT\n-\t  && GET_CODE (x) != UNEQ);\n-}\n-\n-/* Return TRUE for SMIN SMAX UMIN UMAX operators.  */\n-int\n-minmax_operator (rtx x, enum machine_mode mode)\n-{\n-  enum rtx_code code = GET_CODE (x);\n-\n-  if (GET_MODE (x) != mode)\n-    return FALSE;\n-\n-  return code == SMIN || code == SMAX || code == UMIN || code == UMAX;\n-}\n-\n-/* Return TRUE if this is the condition code register, if we aren't given\n-   a mode, accept any class CCmode register.  */\n-int\n-cc_register (rtx x, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    {\n-      mode = GET_MODE (x);\n-\n-      if (GET_MODE_CLASS (mode) != MODE_CC)\n-\treturn FALSE;\n-    }\n-\n-  if (   GET_MODE (x) == mode\n-      && GET_CODE (x) == REG\n-      && REGNO    (x) == CC_REGNUM)\n-    return TRUE;\n-\n-  return FALSE;\n-}\n-\n-/* Return TRUE if this is the condition code register, if we aren't given\n-   a mode, accept any class CCmode register which indicates a dominance\n-   expression.  */\n-int\n-dominant_cc_register (rtx x, enum machine_mode mode)\n-{\n-  if (mode == VOIDmode)\n-    {\n-      mode = GET_MODE (x);\n-\n-      if (GET_MODE_CLASS (mode) != MODE_CC)\n-\treturn FALSE;\n-    }\n-\n-  if (mode != CC_DNEmode && mode != CC_DEQmode\n-      && mode != CC_DLEmode && mode != CC_DLTmode\n-      && mode != CC_DGEmode && mode != CC_DGTmode\n-      && mode != CC_DLEUmode && mode != CC_DLTUmode\n-      && mode != CC_DGEUmode && mode != CC_DGTUmode)\n-    return FALSE;\n-\n-  return cc_register (x, mode);\n-}\n-\n /* Return TRUE if X references a SYMBOL_REF.  */\n int\n symbol_mentioned_p (rtx x)\n@@ -5582,124 +5028,6 @@ adjacent_mem_locations (rtx a, rtx b)\n   return 0;\n }\n \n-/* Return 1 if OP is a load multiple operation.  It is known to be\n-   parallel and the first section will be tested.  */\n-int\n-load_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int dest_regno;\n-  rtx src_addr;\n-  HOST_WIDE_INT i = 1, base = 0;\n-  rtx elt;\n-\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-    return 0;\n-\n-  /* Check to see if this might be a write-back.  */\n-  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n-    {\n-      i++;\n-      base = 1;\n-\n-      /* Now check it more carefully.  */\n-      if (GET_CODE (SET_DEST (elt)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n-          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n-        return 0;\n-    }\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= i\n-      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != REG\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != MEM)\n-    return 0;\n-\n-  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));\n-  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);\n-\n-  for (; i < count; i++)\n-    {\n-      elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_DEST (elt)) != REG\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || REGNO (SET_DEST (elt)) != (unsigned int)(dest_regno + i - base)\n-          || GET_CODE (SET_SRC (elt)) != MEM\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n-          || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n-          || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n-          || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != (i - base) * 4)\n-        return 0;\n-    }\n-\n-  return 1;\n-}\n-\n-/* Return 1 if OP is a store multiple operation.  It is known to be\n-   parallel and the first section will be tested.  */\n-int\n-store_multiple_operation (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  HOST_WIDE_INT count = XVECLEN (op, 0);\n-  int src_regno;\n-  rtx dest_addr;\n-  HOST_WIDE_INT i = 1, base = 0;\n-  rtx elt;\n-\n-  if (count <= 1\n-      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-    return 0;\n-\n-  /* Check to see if this might be a write-back.  */\n-  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n-    {\n-      i++;\n-      base = 1;\n-\n-      /* Now check it more carefully.  */\n-      if (GET_CODE (SET_DEST (elt)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n-          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n-          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n-        return 0;\n-    }\n-\n-  /* Perform a quick check so we don't blow up below.  */\n-  if (count <= i\n-      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n-      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != MEM\n-      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != REG)\n-    return 0;\n-\n-  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));\n-  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);\n-\n-  for (; i < count; i++)\n-    {\n-      elt = XVECEXP (op, 0, i);\n-\n-      if (GET_CODE (elt) != SET\n-          || GET_CODE (SET_SRC (elt)) != REG\n-          || GET_MODE (SET_SRC (elt)) != SImode\n-          || REGNO (SET_SRC (elt)) != (unsigned int)(src_regno + i - base)\n-          || GET_CODE (SET_DEST (elt)) != MEM\n-          || GET_MODE (SET_DEST (elt)) != SImode\n-          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n-          || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n-          || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n-          || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != (i - base) * 4)\n-        return 0;\n-    }\n-\n-  return 1;\n-}\n-\n int\n load_multiple_sequence (rtx *operands, int nops, int *regs, int *base,\n \t\t\tHOST_WIDE_INT *load_offset)\n@@ -6106,17 +5434,6 @@ emit_stm_seq (rtx *operands, int nops)\n   return \"\";\n }\n \n-int\n-multi_register_push (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  if (GET_CODE (op) != PARALLEL\n-      || (GET_CODE (XVECEXP (op, 0, 0)) != SET)\n-      || (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC)\n-      || (XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != UNSPEC_PUSH_MULT))\n-    return 0;\n-\n-  return 1;\n-}\n \f\n /* Routines for use in generating RTL.  */\n \n@@ -9093,6 +8410,13 @@ shift_op (rtx op, HOST_WIDE_INT *amountp)\n       mnem = \"lsr\";\n       break;\n \n+    case ROTATE:\n+      if (*amountp == -1)\n+\tabort ();\n+      *amountp = 32 - *amountp;\n+\n+      /* Fall through.  */\n+\n     case ROTATERT:\n       mnem = \"ror\";\n       break;\n@@ -14177,42 +13501,6 @@ thumb_expand_movmemqi (rtx *operands)\n     }\n }\n \n-int\n-thumb_cmp_operand (rtx op, enum machine_mode mode)\n-{\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && INTVAL (op) < 256\n-\t   && INTVAL (op) >= 0)\n-\t  || s_register_operand (op, mode));\n-}\n-\n-int\n-thumb_cmpneg_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == CONST_INT\n-\t  && INTVAL (op) < 0\n-\t  && INTVAL (op) > -256);\n-}\n-\n-/* Return TRUE if a result can be stored in OP without clobbering the\n-   condition code register.  Prior to reload we only accept a\n-   register.  After reload we have to be able to handle memory as\n-   well, since a pseudo may not get a hard reg and reload cannot\n-   handle output-reloads on jump insns.\n-\n-   We could possibly handle mem before reload as well, but that might\n-   complicate things with the need to handle increment\n-   side-effects.  */\n-\n-int\n-thumb_cbrch_target_operand (rtx op, enum machine_mode mode)\n-{\n-  return (s_register_operand (op, mode)\n-\t  || ((reload_in_progress || reload_completed)\n-\t      && memory_operand (op, mode)));\n-}\n-\n-/* Handle storing a half-word to memory during reload.  */\n void\n thumb_reload_out_hi (rtx *operands)\n {"}, {"sha": "23e72ab184d10a726f3512e26b43a514e04fc6e0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -2594,57 +2594,6 @@ extern int making_const_table;\n    : arm_gen_return_addr_mask ())\n \n \f\n-/* Define the codes that are matched by predicates in arm.c */\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"s_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"arm_general_register_operand\", {SUBREG, REG}},\t\t\t\\\n-  {\"arm_hard_register_operand\", {REG}},\t\t\t\t\t\\\n-  {\"f_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n-  {\"arm_add_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"arm_addimm_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"arm_float_add_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n-  {\"arm_float_rhs_operand\",    {SUBREG, REG, CONST_DOUBLE}},\t\t\\\n-  {\"arm_rhs_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"arm_not_operand\",    {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"index_operand\",      {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"thumb_cmp_operand\",  {SUBREG, REG, CONST_INT}},\t\t\t\\\n-  {\"thumb_cmpneg_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"thumb_cbrch_target_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"offsettable_memory_operand\", {MEM}},\t\t\t\t\\\n-  {\"alignable_memory_operand\", {MEM}},\t\t\t\t\t\\\n-  {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n-  {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n-  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATERT, MULT}},\t\\\n-  {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n-  {\"nonimmediate_di_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"soft_df_operand\", {SUBREG, REG, CONST_DOUBLE, MEM}},\t\t\\\n-  {\"nonimmediate_soft_df_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"load_multiple_operation\",  {PARALLEL}},\t\t\t\t\\\n-  {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n-  {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n-  {\"arm_comparison_operator\", {EQ, NE, LE, LT, GE, GT, GEU, GTU, LEU,\t\\\n-\t\t\t       LTU, UNORDERED, ORDERED, UNLT, UNLE,\t\\\n-\t\t\t       UNGE, UNGT}},\t\t\t\t\\\n-  {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n-  {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\\n-  {\"cc_register\", {REG}},\t\t\t\t\t\t\\\n-  {\"logical_binary_operator\", {AND, IOR, XOR}},\t\t\t\t\\\n-  {\"cirrus_register_operand\", {REG}},\t\t\t\t\t\\\n-  {\"cirrus_fp_register\", {REG}},\t\t\t\t\t\\\n-  {\"cirrus_shift_const\", {CONST_INT}},\t\t\t\t\t\\\n-  {\"dominant_cc_register\", {REG}},\t\t\t\t\t\\\n-  {\"arm_float_compare_operand\", {REG, CONST_DOUBLE}},\t\t\t\\\n-  {\"vfp_compare_operand\", {REG, CONST_DOUBLE}},\n-\n-/* Define this if you have special predicates that know special things\n-   about modes.  Genrecog will warn about certain forms of\n-   match_operand without a mode; if the operand predicate is listed in\n-   SPECIAL_MODE_PREDICATES, the warning will be suppressed.  */\n-#define SPECIAL_MODE_PREDICATES\t\t\t\\\n- \"cc_register\", \"dominant_cc_register\",\n-\n enum arm_builtins\n {\n   ARM_BUILTIN_GETWCX,"}, {"sha": "08d62e95a5aef0effbb56d069ed847019436575d", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -286,6 +286,8 @@\n ;; distant label.  Only applicable to Thumb code.\n (define_attr \"far_jump\" \"yes,no\" (const_string \"no\"))\n \n+(include \"predicates.md\")\n+\n ;;---------------------------------------------------------------------------\n ;; Pipeline descriptions\n "}, {"sha": "ed438026f01c0531b13a3a32edbd148401616ef3", "filename": "gcc/config/arm/predicates.md", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fpredicates.md?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -0,0 +1,470 @@\n+;; Predicate definitions for ARM and Thumb\n+;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;; Contributed by ARM Ltd.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published\n+;; by the Free Software Foundation; either version 2, or (at your\n+;; option) any later version.\n+\n+;; GCC is distributed in the hope that it will be useful, but WITHOUT\n+;; ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+;; or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+;; License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+(define_predicate \"s_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  /* XXX might have to check for lo regs only for thumb ??? */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) != NO_REGS));\n+})\n+\n+;; Any hard register.\n+(define_predicate \"arm_hard_register_operand\"\n+  (match_code \"reg\")\n+{\n+  return REGNO (op) < FIRST_PSEUDO_REGISTER;\n+})\n+\n+;; Any core register, or any pseudo.  */ \n+(define_predicate \"arm_general_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) <= LAST_ARM_REGNUM\n+\t      || REGNO (op) >= FIRST_PSEUDO_REGISTER));\n+})\n+\n+(define_predicate \"f_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  /* We don't consider registers whose class is NO_REGS\n+     to be a register operand.  */\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) == FPA_REGS));\n+})\n+\n+;; Reg, subreg(reg) or const_int.\n+(define_predicate \"reg_or_int_operand\"\n+  (ior (match_code \"const_int\")\n+       (match_operand 0 \"s_register_operand\")))\n+\n+(define_predicate \"arm_immediate_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"const_ok_for_arm (INTVAL (op))\")))\n+\n+(define_predicate \"arm_neg_immediate_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"const_ok_for_arm (-INTVAL (op))\")))\n+\n+(define_predicate \"arm_not_immediate_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"const_ok_for_arm (~INTVAL (op))\")))\n+\n+;; Something valid on the RHS of an ARM data-processing instruction\n+(define_predicate \"arm_rhs_operand\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (match_operand 0 \"arm_immediate_operand\")))\n+\n+(define_predicate \"arm_rhsm_operand\"\n+  (ior (match_operand 0 \"arm_rhs_operand\")\n+       (match_operand 0 \"memory_operand\")))\n+\n+(define_predicate \"arm_add_operand\"\n+  (ior (match_operand 0 \"arm_rhs_operand\")\n+       (match_operand 0 \"arm_neg_immediate_operand\")))\n+\n+(define_predicate \"arm_addimm_operand\"\n+  (ior (match_operand 0 \"arm_immediate_operand\")\n+       (match_operand 0 \"arm_neg_immediate_operand\")))\n+\n+(define_predicate \"arm_not_operand\"\n+  (ior (match_operand 0 \"arm_rhs_operand\")\n+       (match_operand 0 \"arm_not_immediate_operand\")))\n+\n+;; True if the operand is a memory reference which contains an\n+;; offsettable address.\n+(define_predicate \"offsettable_memory_operand\"\n+  (and (match_code \"mem\")\n+       (match_test\n+        \"offsettable_address_p (reload_completed | reload_in_progress,\n+\t\t\t\tmode, XEXP (op, 0))\")))\n+\n+;; True if the operand is a memory reference which is, or can be made,\n+;; word aligned by adjusting the offset.\n+(define_predicate \"alignable_memory_operand\"\n+  (match_code \"mem\")\n+{\n+  rtx reg;\n+\n+  op = XEXP (op, 0);\n+\n+  return ((GET_CODE (reg = op) == REG\n+\t   || (GET_CODE (op) == SUBREG\n+\t       && GET_CODE (reg = SUBREG_REG (op)) == REG)\n+\t   || (GET_CODE (op) == PLUS\n+\t       && GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t       && (GET_CODE (reg = XEXP (op, 0)) == REG\n+\t\t   || (GET_CODE (XEXP (op, 0)) == SUBREG\n+\t\t       && GET_CODE (reg = SUBREG_REG (XEXP (op, 0))) == REG))))\n+\t  && REGNO_POINTER_ALIGN (REGNO (reg)) >= 32);\n+})\n+\n+(define_predicate \"arm_reload_memory_operand\"\n+  (and (match_code \"reg,subreg\")\n+       (match_test \"(!CONSTANT_P (op)\n+\t\t     && (true_regnum(op) == -1\n+\t\t\t || (GET_CODE (op) == REG\n+\t\t\t     && REGNO (op) >= FIRST_PSEUDO_REGISTER)))\")))\n+\n+;; True for valid operands for the rhs of an floating point insns.\n+;;   Allows regs or certain consts on FPA, just regs for everything else.\n+(define_predicate \"arm_float_rhs_operand\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (and (match_code \"const_double\")\n+\t    (match_test \"TARGET_FPA && arm_const_double_rtx (op)\"))))\n+\n+(define_predicate \"arm_float_add_operand\"\n+  (ior (match_operand 0 \"arm_float_rhs_operand\")\n+       (and (match_code \"const_double\")\n+\t    (match_test \"TARGET_FPA && neg_const_double_rtx_ok_for_fpa (op)\"))))\n+\n+(define_predicate \"vfp_compare_operand\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (and (match_code \"const_double\")\n+\t    (match_test \"arm_const_double_rtx (op)\"))))\n+\n+(define_predicate \"arm_float_compare_operand\"\n+  (if_then_else (match_test \"TARGET_VFP\")\n+\t\t(match_operand 0 \"vfp_compare_operand\")\n+\t\t(match_operand 0 \"arm_float_rhs_operand\")))\n+\n+;; True for valid index operands.\n+(define_predicate \"index_operand\"\n+  (ior (match_operand 0 \"s_register_operand\")\n+       (and (match_operand 0 \"immediate_operand\")\n+\t    (match_test \"(GET_CODE (op) != CONST_INT\n+\t\t\t  || (INTVAL (op) < 4096 && INTVAL (op) > -4096))\"))))\n+\n+;; True for operators that can be combined with a shift in ARM state.\n+(define_special_predicate \"shiftable_operator\"\n+  (and (match_code \"plus,minus,ior,xor,and\")\n+       (match_test \"mode == GET_MODE (op)\")))\n+\n+;; True for logical binary opertors.\n+(define_special_predicate \"logical_binary_operator\"\n+  (and (match_code \"ior,xor,and\")\n+       (match_test \"mode == GET_MODE (op)\")))\n+\n+;; True for shift operators.\n+(define_special_predicate \"shift_operator\"\n+  (and (ior (ior (and (match_code \"mult\")\n+\t\t      (match_test \"power_of_two_operand (XEXP (op, 1), mode)\"))\n+\t\t (and (match_code \"rotate\")\n+\t\t      (match_test \"GET_CODE (XEXP (op, 1)) == CONST_INT\n+\t\t\t\t   && ((unsigned HOST_WIDE_INT) INTVAL (XEXP (op, 1))) < 32\")))\n+\t    (match_code \"ashift,ashiftrt,lshiftrt,rotatert\"))\n+       (match_test \"mode == GET_MODE (op)\")))\n+\n+;; True for EQ & NE\n+(define_special_predicate \"equality_operator\"\n+  (match_code \"eq,ne\"))\n+\n+;; True for comparisons other than LTGT or UNEQ.\n+(define_special_predicate \"arm_comparison_operator\"\n+  (match_code \"eq,ne,le,lt,ge,gt,geu,gtu,leu,ltu,unordered,ordered,unlt,unle,unge,ungt\"))\n+\n+(define_special_predicate \"minmax_operator\"\n+  (and (match_code \"smin,smax,umin,umax\")\n+       (match_test \"mode == GET_MODE (op)\")))\n+\n+(define_special_predicate \"cc_register\"\n+  (and (match_code \"reg\")\n+       (and (match_test \"REGNO (op) == CC_REGNUM\")\n+\t    (ior (match_test \"mode == GET_MODE (op)\")\n+\t\t (match_test \"mode == VOIDmode && GET_MODE_CLASS (GET_MODE (op)) == MODE_CC\")))))\n+\n+(define_special_predicate \"dominant_cc_register\"\n+  (match_code \"reg\")\n+{\n+  if (mode == VOIDmode)\n+    {\n+      mode = GET_MODE (op);\n+      \n+      if (GET_MODE_CLASS (mode) != MODE_CC)\n+\treturn false;\n+    }\n+\n+  return (cc_register (op, mode)\n+\t  && (mode == CC_DNEmode\n+\t     || mode == CC_DEQmode\n+\t     || mode == CC_DLEmode\n+\t     || mode == CC_DLTmode\n+\t     || mode == CC_DGEmode\n+\t     || mode == CC_DGTmode\n+\t     || mode == CC_DLEUmode\n+\t     || mode == CC_DLTUmode\n+\t     || mode == CC_DGEUmode\n+\t     || mode == CC_DGTUmode));\n+})\n+\n+(define_special_predicate \"arm_extendqisi_mem_op\"\n+  (and (match_operand 0 \"memory_operand\")\n+       (match_test \"arm_legitimate_address_p (mode, XEXP (op, 0), SIGN_EXTEND,\n+\t\t\t\t\t      0)\")))\n+\n+(define_predicate \"power_of_two_operand\"\n+  (match_code \"const_int\")\n+{\n+  HOST_WIDE_INT value = INTVAL (op);\n+\n+  return value != 0 && (value & (value - 1)) == 0;\n+})\n+\n+(define_predicate \"nonimmediate_di_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+   if (s_register_operand (op, mode))\n+     return true;\n+\n+   if (GET_CODE (op) == SUBREG)\n+     op = SUBREG_REG (op);\n+\n+   return GET_CODE (op) == MEM && memory_address_p (DImode, XEXP (op, 0));\n+})\n+\n+(define_predicate \"di_operand\"\n+  (ior (match_code \"const_int,const_double\")\n+       (and (match_code \"reg,subreg,mem\")\n+\t    (match_operand 0 \"nonimmediate_di_operand\"))))\n+\n+(define_predicate \"nonimmediate_soft_df_operand\"\n+  (match_code \"reg,subreg,mem\")\n+{\n+  if (s_register_operand (op, mode))\n+    return true;\n+\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return GET_CODE (op) == MEM && memory_address_p (DFmode, XEXP (op, 0));\n+})\n+\n+(define_predicate \"soft_df_operand\"\n+  (ior (match_code \"const_double\")\n+       (and (match_code \"reg,subreg,mem\")\n+\t    (match_operand 0 \"nonimmediate_soft_df_operand\"))))\n+\n+(define_predicate \"const_shift_operand\"\n+  (and (match_code \"const_int\")\n+       (ior (match_operand 0 \"power_of_two_operand\")\n+\t    (match_test \"((unsigned HOST_WIDE_INT) INTVAL (op)) < 32\"))))\n+\n+\n+(define_special_predicate \"load_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  HOST_WIDE_INT count = XVECLEN (op, 0);\n+  int dest_regno;\n+  rtx src_addr;\n+  HOST_WIDE_INT i = 1, base = 0;\n+  rtx elt;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    return false;\n+\n+  /* Check to see if this might be a write-back.  */\n+  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n+    {\n+      i++;\n+      base = 1;\n+\n+      /* Now check it more carefully.  */\n+      if (GET_CODE (SET_DEST (elt)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n+          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n+        return false;\n+    }\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= i\n+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != REG\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != MEM)\n+    return false;\n+\n+  dest_regno = REGNO (SET_DEST (XVECEXP (op, 0, i - 1)));\n+  src_addr = XEXP (SET_SRC (XVECEXP (op, 0, i - 1)), 0);\n+\n+  for (; i < count; i++)\n+    {\n+      elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_DEST (elt)) != REG\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || REGNO (SET_DEST (elt)) != (unsigned int)(dest_regno + i - base)\n+          || GET_CODE (SET_SRC (elt)) != MEM\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != PLUS\n+          || !rtx_equal_p (XEXP (XEXP (SET_SRC (elt), 0), 0), src_addr)\n+          || GET_CODE (XEXP (XEXP (SET_SRC (elt), 0), 1)) != CONST_INT\n+          || INTVAL (XEXP (XEXP (SET_SRC (elt), 0), 1)) != (i - base) * 4)\n+        return false;\n+    }\n+\n+  return true;\n+})\n+\n+(define_special_predicate \"store_multiple_operation\"\n+  (match_code \"parallel\")\n+{\n+  HOST_WIDE_INT count = XVECLEN (op, 0);\n+  int src_regno;\n+  rtx dest_addr;\n+  HOST_WIDE_INT i = 1, base = 0;\n+  rtx elt;\n+\n+  if (count <= 1\n+      || GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+    return false;\n+\n+  /* Check to see if this might be a write-back.  */\n+  if (GET_CODE (SET_SRC (elt = XVECEXP (op, 0, 0))) == PLUS)\n+    {\n+      i++;\n+      base = 1;\n+\n+      /* Now check it more carefully.  */\n+      if (GET_CODE (SET_DEST (elt)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 0)) != REG\n+          || GET_CODE (XEXP (SET_SRC (elt), 1)) != CONST_INT\n+          || INTVAL (XEXP (SET_SRC (elt), 1)) != (count - 1) * 4)\n+        return false;\n+    }\n+\n+  /* Perform a quick check so we don't blow up below.  */\n+  if (count <= i\n+      || GET_CODE (XVECEXP (op, 0, i - 1)) != SET\n+      || GET_CODE (SET_DEST (XVECEXP (op, 0, i - 1))) != MEM\n+      || GET_CODE (SET_SRC (XVECEXP (op, 0, i - 1))) != REG)\n+    return false;\n+\n+  src_regno = REGNO (SET_SRC (XVECEXP (op, 0, i - 1)));\n+  dest_addr = XEXP (SET_DEST (XVECEXP (op, 0, i - 1)), 0);\n+\n+  for (; i < count; i++)\n+    {\n+      elt = XVECEXP (op, 0, i);\n+\n+      if (GET_CODE (elt) != SET\n+          || GET_CODE (SET_SRC (elt)) != REG\n+          || GET_MODE (SET_SRC (elt)) != SImode\n+          || REGNO (SET_SRC (elt)) != (unsigned int)(src_regno + i - base)\n+          || GET_CODE (SET_DEST (elt)) != MEM\n+          || GET_MODE (SET_DEST (elt)) != SImode\n+          || GET_CODE (XEXP (SET_DEST (elt), 0)) != PLUS\n+          || !rtx_equal_p (XEXP (XEXP (SET_DEST (elt), 0), 0), dest_addr)\n+          || GET_CODE (XEXP (XEXP (SET_DEST (elt), 0), 1)) != CONST_INT\n+          || INTVAL (XEXP (XEXP (SET_DEST (elt), 0), 1)) != (i - base) * 4)\n+        return false;\n+    }\n+\n+  return true;\n+})\n+\n+(define_special_predicate \"multi_register_push\"\n+  (match_code \"parallel\")\n+{\n+  if ((GET_CODE (XVECEXP (op, 0, 0)) != SET)\n+      || (GET_CODE (SET_SRC (XVECEXP (op, 0, 0))) != UNSPEC)\n+      || (XINT (SET_SRC (XVECEXP (op, 0, 0)), 1) != UNSPEC_PUSH_MULT))\n+    return false;\n+\n+  return true;\n+})\n+\n+;;-------------------------------------------------------------------------\n+;;\n+;; Thumb predicates\n+;;\n+\n+(define_predicate \"thumb_cmp_operand\"\n+  (ior (and (match_code \"reg,subreg\")\n+\t    (match_operand 0 \"s_register_operand\"))\n+       (and (match_code \"const_int\")\n+\t    (match_test \"((unsigned HOST_WIDE_INT) INTVAL (op)) < 256\"))))\n+\n+(define_predicate \"thumb_cmpneg_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) < 0 && INTVAL (op) > -256\")))\n+\n+;; Return TRUE if a result can be stored in OP without clobbering the\n+;; condition code register.  Prior to reload we only accept a\n+;; register.  After reload we have to be able to handle memory as\n+;; well, since a pseudo may not get a hard reg and reload cannot\n+;; handle output-reloads on jump insns.\n+\n+;; We could possibly handle mem before reload as well, but that might\n+;; complicate things with the need to handle increment\n+;; side-effects.\n+(define_predicate \"thumb_cbrch_target_operand\"\n+  (and (match_code \"reg,subreg,mem\")\n+       (ior (match_operand 0 \"s_register_operand\")\n+\t    (and (match_test \"reload_in_progress || reload_completed\")\n+\t\t (match_operand 0 \"memory_operand\")))))\n+\n+;;-------------------------------------------------------------------------\n+;;\n+;; MAVERICK predicates\n+;;\n+\n+(define_predicate \"cirrus_register_operand\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS\n+\t      || REGNO_REG_CLASS (REGNO (op)) == GENERAL_REGS));\n+})\n+\n+(define_predicate \"cirrus_fp_register\"\n+  (match_code \"reg,subreg\")\n+{\n+  if (GET_CODE (op) == SUBREG)\n+    op = SUBREG_REG (op);\n+\n+  return (GET_CODE (op) == REG\n+\t  && (REGNO (op) >= FIRST_PSEUDO_REGISTER\n+\t      || REGNO_REG_CLASS (REGNO (op)) == CIRRUS_REGS));\n+})\n+\n+(define_predicate \"cirrus_shift_const\"\n+  (and (match_code \"const_int\")\n+       (match_test \"((unsigned HOST_WIDE_INT) INTVAL (op)) < 64\")))\n+\n+"}, {"sha": "21cab03cf6e529d5ace095b96bd49f2dc1bb6fc6", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a657c98a58e32c0112e9800a82256472e6ee49eb/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=a657c98a58e32c0112e9800a82256472e6ee49eb", "patch": "@@ -1,6 +1,7 @@\n # Rules common to all arm targets\n \n MD_INCLUDES= \t$(srcdir)/config/arm/arm-tune.md \\\n+\t\t$(srcdir)/config/arm/predicates.md \\\n \t\t$(srcdir)/config/arm/arm-generic.md \\\n \t\t$(srcdir)/config/arm/arm1026ejs.md \\\n \t\t$(srcdir)/config/arm/arm1136jfs.md \\\n@@ -10,7 +11,7 @@ MD_INCLUDES= \t$(srcdir)/config/arm/arm-tune.md \\\n \t\t$(srcdir)/config/arm/iwmmxt.md \\\n \t\t$(srcdir)/config/arm/vfp.md\n \n-s-config s-conditions s-flags s-codes s-constants s-emit s-recog \\\n+s-config s-conditions s-flags s-codes s-constants s-emit s-recog s-preds \\\n \ts-opinit s-extract s-peep s-attr s-attrtab s-output: $(MD_INCLUDES)\n \n $(srcdir)/config/arm/arm-tune.md: $(srcdir)/config/arm/gentune.sh \\"}]}