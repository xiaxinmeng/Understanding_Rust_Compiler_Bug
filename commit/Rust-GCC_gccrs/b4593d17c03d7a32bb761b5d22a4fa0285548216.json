{"sha": "b4593d17c03d7a32bb761b5d22a4fa0285548216", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjQ1OTNkMTdjMDNkN2EzMmJiNzYxYjVkMjJhNGZhMDI4NTU0ODIxNg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "2000-04-27T05:42:25Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2000-04-27T05:42:25Z"}, "message": "flow.c (mark_set_1): New arguments code and flags; update all callers.\n\n        * flow.c (mark_set_1): New arguments code and flags; update all\n        callers.  Track regno_first and regno_last; do HARD_REGNO_NREGS\n        test in one place.  Tidy flags tests.  Don't bias REG_N_REFS by\n        loop_depth when optimizing for size.  Do new_dead update after\n        emitting REG_UNUSED notes.  Merge mark_set_reg code.\n        (mark_set_reg): Remove.\n        (propagate_one_insn): Use mark_set_1 for call-clobbered registers;\n        arrange to not emit REG_UNUSED notes.\n\nFrom-SVN: r33462", "tree": {"sha": "4103b984f7b1ba5364d6a9236672deedcbd025ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4103b984f7b1ba5364d6a9236672deedcbd025ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b4593d17c03d7a32bb761b5d22a4fa0285548216", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4593d17c03d7a32bb761b5d22a4fa0285548216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4593d17c03d7a32bb761b5d22a4fa0285548216", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4593d17c03d7a32bb761b5d22a4fa0285548216/comments", "author": null, "committer": null, "parents": [{"sha": "443b75c925b8b46c819fced9c4266f590b359bae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/443b75c925b8b46c819fced9c4266f590b359bae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/443b75c925b8b46c819fced9c4266f590b359bae"}], "stats": {"total": 231, "additions": 97, "deletions": 134}, "files": [{"sha": "0aa46f254af3ff4badc95a753880805cce9a6c71", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4593d17c03d7a32bb761b5d22a4fa0285548216/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4593d17c03d7a32bb761b5d22a4fa0285548216/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b4593d17c03d7a32bb761b5d22a4fa0285548216", "patch": "@@ -1,3 +1,14 @@\n+2000-04-26  Richard Henderson  <rth@cygnus.com>\n+\n+\t* flow.c (mark_set_1): New arguments code and flags; update all\n+\tcallers.  Track regno_first and regno_last; do HARD_REGNO_NREGS\n+\ttest in one place.  Tidy flags tests.  Don't bias REG_N_REFS by\n+\tloop_depth when optimizing for size.  Do new_dead update after\n+\temitting REG_UNUSED notes.  Merge mark_set_reg code.\n+\t(mark_set_reg): Remove.\n+\t(propagate_one_insn): Use mark_set_1 for call-clobbered registers;\n+\tarrange to not emit REG_UNUSED notes.\n+\n 2000-04-26  Richard Henderson  <rth@cygnus.com>\n \n \t* flow.c (find_auto_inc): Use pbi->bb instead of BLOCK_FOR_INSN."}, {"sha": "7b24942977fe29e3dcf88c9c08401bab2c95643f", "filename": "gcc/flow.c", "status": "modified", "additions": 86, "deletions": 134, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b4593d17c03d7a32bb761b5d22a4fa0285548216/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b4593d17c03d7a32bb761b5d22a4fa0285548216/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b4593d17c03d7a32bb761b5d22a4fa0285548216", "patch": "@@ -336,9 +336,8 @@ static int libcall_dead_p\t\tPARAMS ((struct propagate_block_info *,\n static void mark_set_regs\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n static void mark_set_1\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, rtx));\n-static int mark_set_reg\t\t\tPARAMS ((struct propagate_block_info *,\n-\t\t\t\t\t\t rtx, rtx, int *, int *));\n+\t\t\t\t\t\t enum rtx_code, rtx, rtx,\n+\t\t\t\t\t\t rtx, int));\n #ifdef AUTO_INC_DEC\n static void find_auto_inc\t\tPARAMS ((struct propagate_block_info *,\n \t\t\t\t\t\t rtx, rtx));\n@@ -3408,16 +3407,17 @@ propagate_one_insn (pbi, insn)\n \t       note;\n \t       note = XEXP (note, 1))\n \t    if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n-\t      mark_set_1 (pbi, XEXP (XEXP (note, 0), 0), cond, insn);\n+\t      mark_set_1 (pbi, CLOBBER, XEXP (XEXP (note, 0), 0),\n+\t\t\t  cond, insn, pbi->flags);\n \n \t  /* Calls change all call-used and global registers.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    if (call_used_regs[i] && ! global_regs[i]\n \t\t&& ! fixed_regs[i])\n \t      {\n-\t\tint dummy;\n-\t\tmark_set_reg (pbi, gen_rtx_REG (reg_raw_mode[i], i),\n-\t\t\t      cond, &dummy, &dummy);\n+\t\t/* We do not want REG_UNUSED notes for these registers.  */\n+\t\tmark_set_1 (pbi, CLOBBER, gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t    cond, insn, pbi->flags & ~PROP_DEATH_NOTES);\n \t      }\n \t}\n \n@@ -3895,13 +3895,14 @@ mark_set_regs (pbi, x, insn)\n      rtx x, insn;\n {\n   rtx cond = NULL_RTX;\n+  enum rtx_code code;\n \n  retry:\n-  switch (GET_CODE (x))\n+  switch (code = GET_CODE (x))\n     {\n     case SET:\n     case CLOBBER:\n-      mark_set_1 (pbi, SET_DEST (x), cond, insn);\n+      mark_set_1 (pbi, code, SET_DEST (x), cond, insn, pbi->flags);\n       return;\n \n     case COND_EXEC:\n@@ -3915,7 +3916,7 @@ mark_set_regs (pbi, x, insn)\n \tfor (i = XVECLEN (x, 0) - 1; i >= 0; i--)\n \t  {\n \t    rtx sub = XVECEXP (x, 0, i);\n-\t    switch (GET_CODE (sub))\n+\t    switch (code = GET_CODE (sub))\n \t      {\n \t      case COND_EXEC:\n \t\tif (cond != NULL_RTX)\n@@ -3929,7 +3930,7 @@ mark_set_regs (pbi, x, insn)\n \n \t      case SET:\n \t      case CLOBBER:\n-\t\tmark_set_1 (pbi, SET_DEST (sub), cond, insn);\n+\t\tmark_set_1 (pbi, code, SET_DEST (sub), cond, insn, pbi->flags);\n \t\tbreak;\n \n \t      default:\n@@ -3947,23 +3948,23 @@ mark_set_regs (pbi, x, insn)\n /* Process a single SET rtx, X.  */\n \n static void\n-mark_set_1 (pbi, reg, cond, insn)\n+mark_set_1 (pbi, code, reg, cond, insn, flags)\n      struct propagate_block_info *pbi;\n+     enum rtx_code code;\n      rtx reg, cond, insn;\n+     int flags;\n {\n-  register int regno = -1;\n-  int flags = pbi->flags;\n+  int regno_first = -1, regno_last = -1;\n+  int i;\n \n   /* Some targets place small structures in registers for\n      return values of functions.  We have to detect this\n      case specially here to get correct flow information.  */\n   if (GET_CODE (reg) == PARALLEL\n       && GET_MODE (reg) == BLKmode)\n     {\n-      register int i;\n-\n       for (i = XVECLEN (reg, 0) - 1; i >= 0; i--)\n-\tmark_set_1 (pbi, XVECEXP (reg, 0, i), cond, insn);\n+\tmark_set_1 (pbi, code, XVECEXP (reg, 0, i), cond, insn, flags);\n       return;\n     }\n \n@@ -4037,23 +4038,35 @@ mark_set_1 (pbi, reg, cond, insn)\n     }\n \n   if (GET_CODE (reg) == REG\n-      && (regno = REGNO (reg),\n-\t  ! (regno == FRAME_POINTER_REGNUM\n+      && (regno_first = REGNO (reg),\n+\t  ! (regno_first == FRAME_POINTER_REGNUM\n \t     && (! reload_completed || frame_pointer_needed)))\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n-      && ! (regno == HARD_FRAME_POINTER_REGNUM\n+      && ! (regno_first == HARD_FRAME_POINTER_REGNUM\n \t    && (! reload_completed || frame_pointer_needed))\n #endif\n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n-      && ! (regno == ARG_POINTER_REGNUM && fixed_regs[regno])\n+      && ! (regno_first == ARG_POINTER_REGNUM && fixed_regs[regno_first])\n #endif\n       )\n     {\n-      int some_was_live, some_was_dead;\n+      int some_was_live = 0, some_was_dead = 0;\n \n-      /* Perform the pbi datastructure update.  */\n-      if (! mark_set_reg (pbi, reg, cond, &some_was_live, &some_was_dead))\n-\treturn;\n+      if (regno_first < FIRST_PSEUDO_REGISTER)\n+\tregno_last = (regno_first\n+\t\t      + HARD_REGNO_NREGS (regno_first, GET_MODE (reg)) - 1);\n+      else\n+        regno_last = regno_first;\n+\n+      for (i = regno_first; i <= regno_last; ++i)\n+\t{\n+\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, i);\n+\t  if (pbi->local_set)\n+\t    SET_REGNO_REG_SET (pbi->local_set, i);\n+\n+\t  some_was_live |= needed_regno;\n+\t  some_was_dead |= ! needed_regno;\n+\t}\n \n       /* Additional data to record if this is the final pass.  */\n       if (flags & (PROP_LOG_LINKS | PROP_REG_INFO\n@@ -4064,56 +4077,44 @@ mark_set_1 (pbi, reg, cond, insn)\n \n \t  y = NULL_RTX;\n \t  if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t    y = pbi->reg_next_use[regno];\n-\n-\t  /* If this is a hard reg, record this function uses the reg.  */\n-\n-\t  if (regno < FIRST_PSEUDO_REGISTER)\n \t    {\n-\t      register int i;\n-\t      int endregno = regno + HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-\n-\t      if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t        for (i = regno; i < endregno; i++)\n-\t\t  {\n-\t\t    /* The next use is no longer \"next\", since a store\n-\t\t       intervenes.  */\n-\t\t    pbi->reg_next_use[i] = 0;\n-\t\t  }\n+\t      y = pbi->reg_next_use[regno_first];\n \n-\t      if (flags & PROP_REG_INFO)\n-\t        for (i = regno; i < endregno; i++)\n-\t\t  {\n-\t\t    regs_ever_live[i] = 1;\n-\t\t    REG_N_SETS (i)++;\n-\t\t  }\n+\t      /* The next use is no longer next, since a store intervenes.  */\n+\t      for (i = regno_first; i <= regno_last; ++i)\n+\t\tpbi->reg_next_use[i] = 0;\n \t    }\n-\t  else\n-\t    {\n-\t      /* The next use is no longer \"next\", since a store\n-\t\t intervenes.  */\n-\t      if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\t        pbi->reg_next_use[regno] = 0;\n \n-\t      /* Keep track of which basic blocks each reg appears in.  */\n-\n-\t      if (flags & PROP_REG_INFO)\n+\t  if (flags & PROP_REG_INFO)\n+\t    {\n+\t      for (i = regno_first; i <= regno_last; ++i)\n \t\t{\n-\t          if (REG_BASIC_BLOCK (regno) == REG_BLOCK_UNKNOWN)\n-\t\t    REG_BASIC_BLOCK (regno) = blocknum;\n-\t          else if (REG_BASIC_BLOCK (regno) != blocknum)\n-\t\t    REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n-\n-\t          /* Count (weighted) references, stores, etc.  This counts a\n+\t\t  /* Count (weighted) references, stores, etc.  This counts a\n \t\t     register twice if it is modified, but that is correct.  */\n-\t          REG_N_SETS (regno)++;\n-\t          REG_N_REFS (regno) += pbi->bb->loop_depth + 1;\n-\t\t  \n+\t\t  REG_N_SETS (i) += 1;\n+\t\t  REG_N_REFS (i) += (optimize_size ? 1\n+\t\t\t\t     : pbi->bb->loop_depth + 1);\n+\n \t          /* The insns where a reg is live are normally counted\n \t\t     elsewhere, but we want the count to include the insn\n \t\t     where the reg is set, and the normal counting mechanism\n \t\t     would not count it.  */\n-\t          REG_LIVE_LENGTH (regno)++;\n+\t          REG_LIVE_LENGTH (i) += 1;\n+\t\t}\n+\n+\t      /* If this is a hard reg, record this function uses the reg.  */\n+\t      if (regno_first < FIRST_PSEUDO_REGISTER)\n+\t\t{\n+\t\t  for (i = regno_first; i <= regno_last; i++)\n+\t\t    regs_ever_live[i] = 1;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Keep track of which basic blocks each reg appears in.  */\n+\t\t  if (REG_BASIC_BLOCK (regno_first) == REG_BLOCK_UNKNOWN)\n+\t\t    REG_BASIC_BLOCK (regno_first) = blocknum;\n+\t\t  else if (REG_BASIC_BLOCK (regno_first) != blocknum)\n+\t\t    REG_BASIC_BLOCK (regno_first) = REG_BLOCK_GLOBAL;\n \t\t}\n \t    }\n \n@@ -4131,15 +4132,15 @@ mark_set_1 (pbi, reg, cond, insn)\n \t\t     even if reload can make what appear to be valid\n \t\t     assignments later.  */\n \t\t  if (y && (BLOCK_NUM (y) == blocknum)\n-\t\t      && (regno >= FIRST_PSEUDO_REGISTER\n+\t\t      && (regno_first >= FIRST_PSEUDO_REGISTER\n \t\t\t  || asm_noperands (PATTERN (y)) < 0))\n \t\t    LOG_LINKS (y) = alloc_INSN_LIST (insn, LOG_LINKS (y));\n \t\t}\n \t    }\n \t  else if (! some_was_live)\n \t    {\n \t      if (flags & PROP_REG_INFO)\n-\t\tREG_N_DEATHS (REGNO (reg))++;\n+\t\tREG_N_DEATHS (regno_first) += 1;\n \n \t      if (flags & PROP_DEATH_NOTES)\n \t\t{\n@@ -4162,24 +4163,32 @@ mark_set_1 (pbi, reg, cond, insn)\n \t\t     for those parts that were not needed.  This case should\n \t\t     be rare.  */\n \n-\t\t  int i;\n-\n-\t\t  for (i = HARD_REGNO_NREGS (regno, GET_MODE (reg)) - 1;\n-\t\t       i >= 0; i--)\n-\t\t    if (! REGNO_REG_SET_P (pbi->reg_live, regno + i))\n+\t\t  for (i = regno_first; i <= regno_last; ++i)\n+\t\t    if (! REGNO_REG_SET_P (pbi->reg_live, i))\n \t\t      REG_NOTES (insn)\n-\t\t\t= (alloc_EXPR_LIST\n-\t\t\t   (REG_UNUSED,\n-\t\t\t    gen_rtx_REG (reg_raw_mode[regno + i], regno + i),\n-\t\t\t    REG_NOTES (insn)));\n+\t\t\t= alloc_EXPR_LIST (REG_UNUSED,\n+\t\t\t\t\t   gen_rtx_REG (reg_raw_mode[i], i),\n+\t\t\t\t\t   REG_NOTES (insn));\n \t\t}\n \t    }\n \t}\n+\n+      /* Mark the register as being dead.  */\n+      if (some_was_live\n+\t  /* The stack pointer is never dead.  Well, not strictly true,\n+\t     but it's very difficult to tell from here.  Hopefully\n+\t     combine_stack_adjustments will fix up the most egregious\n+\t     errors.  */\n+\t  && regno_first != STACK_POINTER_REGNUM)\n+\t{\n+\t  for (i = regno_first; i <= regno_last; ++i)\n+\t    SET_REGNO_REG_SET (pbi->new_dead, i);\n+\t}\n     }\n   else if (GET_CODE (reg) == REG)\n     {\n       if (flags & (PROP_LOG_LINKS | PROP_AUTOINC))\n-\tpbi->reg_next_use[regno] = 0;\n+\tpbi->reg_next_use[regno_first] = 0;\n     }\n \n   /* If this is the last pass and this is a SCRATCH, show it will be dying\n@@ -4191,63 +4200,6 @@ mark_set_1 (pbi, reg, cond, insn)\n \t  = alloc_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n     }\n }\n-\n-/* Update data structures for a (possibly conditional) store into REG.\n-   Return true if REG is now unconditionally dead.  */\n-\n-static int\n-mark_set_reg (pbi, reg, cond, p_some_was_live, p_some_was_dead)\n-     struct propagate_block_info *pbi;\n-     rtx reg;\n-     rtx cond ATTRIBUTE_UNUSED;\n-     int *p_some_was_live, *p_some_was_dead;\n-{\n-  int regno = REGNO (reg);\n-  int some_was_live = REGNO_REG_SET_P (pbi->reg_live, regno);\n-  int some_was_dead = ! some_was_live;\n-\n-  /* Mark it as a significant register for this basic block.  */\n-  if (pbi->local_set)\n-    SET_REGNO_REG_SET (pbi->local_set, regno);\n-\n-  /* A hard reg in a wide mode may really be multiple registers.\n-     If so, mark all of them just like the first.  */\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (--n > 0)\n-\t{\n-\t  int regno_n = regno + n;\n-\t  int needed_regno = REGNO_REG_SET_P (pbi->reg_live, regno_n);\n-\t  if (pbi->local_set)\n-\t    SET_REGNO_REG_SET (pbi->local_set, regno_n);\n-\n-\t  some_was_live |= needed_regno;\n-\t  some_was_dead |= ! needed_regno;\n-\t}\n-    }\n-\n-  *p_some_was_live = some_was_live;\n-  *p_some_was_dead = some_was_dead;\n-\n-  /* The stack pointer is never dead.  Well, not strictly true, but it's\n-     very difficult to tell from here.  Hopefully combine_stack_adjustments\n-     will fix up the most egregious errors.  */\n-  if (regno == STACK_POINTER_REGNUM)\n-    return 0;\n-\n-  /* Mark it as dead before this insn.  */\n-  SET_REGNO_REG_SET (pbi->new_dead, regno);\n-  if (regno < FIRST_PSEUDO_REGISTER)\n-    {\n-      int n = HARD_REGNO_NREGS (regno, GET_MODE (reg));\n-      while (--n > 0)\n-\tSET_REGNO_REG_SET (pbi->new_dead, regno + n);\n-    }\n-\n-  /* Unconditionally dead.  */\n-  return 1;\n-}\n \f\n #ifdef AUTO_INC_DEC\n "}]}