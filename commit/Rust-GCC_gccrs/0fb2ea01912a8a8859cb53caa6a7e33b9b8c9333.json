{"sha": "0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZiMmVhMDE5MTJhOGE4ODU5Y2I1M2NhYTZhN2UzM2I5YjhjOTMzMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-24T15:19:11Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-24T15:19:11Z"}, "message": "[multiple changes]\n\n2004-05-24  Geert Bosch  <bosch@gnat.com>\n\n\t* a-numaux-x86.adb (Reduce): Reimplement using an approximation of Pi\n\twith 192 bits of precision, sufficient to reduce a double-extended\n\targuments X with a maximum relative error of T'Machine_Epsilon, for X\n\tin -2.0**32 .. 2.0**32.\n\t(Cos, Sin):  Always reduce arguments of 1/4 Pi or larger, to prevent\n\treduction by the processor, which only uses a 68-bit approximation of\n\tPi.\n\t(Tan): Always reduce arguments and compute function either using\n\tthe processor's fptan instruction, or by dividing sin and cos as needed.\n\n2004-05-24  Doug Rupp  <rupp@gnat.com>\n\n\t* adaint.c (__gnat_readdir): Cast CRTL function retun value to avoid\n\tgcc error on 32/64 bit VMS.\n\n2004-05-24  Olivier Hainque  <hainque@act-europe.fr>\n\n\t* init.c (__gnat_error_handler): Handle EEXIST as EACCES for SIGSEGVs,\n\tsince this is what we get for stack overflows although not documented\n\tas such.\n\tDocument the issues which may require adjustments to our signal\n\thandlers.\n\n2004-05-24  Ed Schonberg  <schonberg@gnat.com>\n\n\t* inline.adb (Add_Scope_To_Clean): Do not add cleanup actions to the\n\tenclosing dynamic scope if the instantiation is within a generic unit.\n\n2004-05-24  Arnaud Charlet  <charlet@act-europe.fr>\n\n\t* exp_dbug.ads: Fix typo.\n\n\t* Makefile.in: s-osinte-linux-ia64.ads was misnamed.\n\tRename it to its proper name: system-linux-ia64.ads\n\t(stamp-gnatlib1): Remove extra target specific run time files when\n\tsetting up the rts directory.\n\n2004-05-24  Javier Miranda  <miranda@gnat.com>\n\n\t* einfo.ads, einfo.adb (Limited_Views): Removed.\n\t(Limited_View): New attribute that replaces the previous one. It is\n\tnow a bona fide package with the limited-view list through the\n\tfirst_entity and first_private attributes.\n\n\t* sem_ch10.adb (Install_Private_With_Clauses): Give support to\n\tlimited-private-with clause.\n\t(Install_Limited_Withed_Unit): Install the private declarations of a\n\tlimited-private-withed package. Update the installation of the shadow\n\tentities according to the new structure (see Build_Limited_Views)\n\t(Build_Limited_Views): Replace the previous implementation of the\n\tlimited view by a package entity that references the first shadow\n\tentity plus the first shadow private entity (required for limited-\n\tprivate-with clause)\n\t(New_Internal_Shadow_Entity): Code cleanup.\n\t(Remove_Limited_With_Clause): Update the implementation to undo the\n\tnew work carried out by Build_Limited_Views.\n\t(Build_Chain): Complete documentation.\n\tReplace Ada0Y by Ada 0Y in comments\n\tMinor reformating\n\n\t* sem_ch3.adb (Array_Type_Declaration): In case of anonymous access\n\ttypes the level of accessibility depends on the enclosing type\n\tdeclaration.\n\n\t* sem_ch8.adb (Find_Expanded_Name): Fix condition to detect shadow\n\tentities. Complete documentation of previous change.\n\n2004-05-24  Robert Dewar  <dewar@gnat.com>\n\n\t* namet.adb: Minor reformatting\n\tAvoid use of name I (replace by J)\n\tMinor code restructuring\n\n\t* sem_ch6.adb: Minor reformatting\n\n\t* lib-writ.adb: Do not set restriction as active if this is a\n\tRestriction_Warning case.\n\n\t* sem_prag.adb: Reset restriction warning flag if real pragma\n\trestriction encountered.\n\n\t* s-htable.adb: Minor reformatting\n\tChange rotate count to 3 in Hash (improves hash for small strings)\n\n\t* 5qsystem.ads: Add comments for type Address (no literals allowed).\n\n\t* gnat_ugn.texi: Add new section of documentation \"Code Generation\n\tControl\", which describes the use of -m switches.\n\n2004-05-24  Eric Botcazou  <ebotcazou@act-europe.fr>\n\n\t(tree_transform) <N_Identifier>: Do the dereference directly through\n\tthe DECL_INITIAL for renamed variables.\n\nFrom-SVN: r82205", "tree": {"sha": "3771082957c81623666f68cc0fc153c68f93f964", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3771082957c81623666f68cc0fc153c68f93f964"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/comments", "author": null, "committer": null, "parents": [{"sha": "c86dd7db77896014952396f60db88ce551b5a431", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c86dd7db77896014952396f60db88ce551b5a431", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c86dd7db77896014952396f60db88ce551b5a431"}], "stats": {"total": 959, "additions": 630, "deletions": 329}, "files": [{"sha": "9052e2b16bb14da59825a475266dd65a3a52259c", "filename": "gcc/ada/5qsystem.ads", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2F5qsystem.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2F5qsystem.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2F5qsystem.ads?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -64,6 +64,14 @@ pragma Pure (System);\n \n    type Address is new Long_Integer;\n    Null_Address : constant Address;\n+   --  Although this is declared as an integer type, no arithmetic operations\n+   --  are available (see abstract declarations below), and furthermore there\n+   --  is special processing in the compiler that prevents the use of integer\n+   --  literals with this type (use To_Address to convert integer literals).\n+   --\n+   --  Conversion to and from Short_Address is however freely permitted, and\n+   --  is indeed the reason that Address is declared as an integer type. See\n+   --\n \n    Storage_Unit : constant := 8;\n    Word_Size    : constant := 64;"}, {"sha": "a8a95d1b1b8b0799b4677977fa2dc6d44198421e", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -1,3 +1,99 @@\n+2004-05-24  Geert Bosch  <bosch@gnat.com>\n+\n+\t* a-numaux-x86.adb (Reduce): Reimplement using an approximation of Pi\n+\twith 192 bits of precision, sufficient to reduce a double-extended\n+\targuments X with a maximum relative error of T'Machine_Epsilon, for X\n+\tin -2.0**32 .. 2.0**32.\n+\t(Cos, Sin):  Always reduce arguments of 1/4 Pi or larger, to prevent\n+\treduction by the processor, which only uses a 68-bit approximation of\n+\tPi.\n+\t(Tan): Always reduce arguments and compute function either using\n+\tthe processor's fptan instruction, or by dividing sin and cos as needed.\n+\n+2004-05-24  Doug Rupp  <rupp@gnat.com>\n+\n+\t* adaint.c (__gnat_readdir): Cast CRTL function retun value to avoid\n+\tgcc error on 32/64 bit VMS.\n+\n+2004-05-24  Olivier Hainque  <hainque@act-europe.fr>\n+\n+\t* init.c (__gnat_error_handler): Handle EEXIST as EACCES for SIGSEGVs,\n+\tsince this is what we get for stack overflows although not documented\n+\tas such.\n+\tDocument the issues which may require adjustments to our signal\n+\thandlers.\n+\n+2004-05-24  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* inline.adb (Add_Scope_To_Clean): Do not add cleanup actions to the\n+\tenclosing dynamic scope if the instantiation is within a generic unit.\n+\n+2004-05-24  Arnaud Charlet  <charlet@act-europe.fr>\n+\n+\t* exp_dbug.ads: Fix typo.\n+\n+\t* Makefile.in: s-osinte-linux-ia64.ads was misnamed.\n+\tRename it to its proper name: system-linux-ia64.ads\n+\t(stamp-gnatlib1): Remove extra target specific run time files when\n+\tsetting up the rts directory.\n+\n+2004-05-24  Javier Miranda  <miranda@gnat.com>\n+\n+\t* einfo.ads, einfo.adb (Limited_Views): Removed.\n+\t(Limited_View): New attribute that replaces the previous one. It is\n+\tnow a bona fide package with the limited-view list through the\n+\tfirst_entity and first_private attributes.\n+\n+\t* sem_ch10.adb (Install_Private_With_Clauses): Give support to\n+\tlimited-private-with clause.\n+\t(Install_Limited_Withed_Unit): Install the private declarations of a\n+\tlimited-private-withed package. Update the installation of the shadow\n+\tentities according to the new structure (see Build_Limited_Views)\n+\t(Build_Limited_Views): Replace the previous implementation of the\n+\tlimited view by a package entity that references the first shadow\n+\tentity plus the first shadow private entity (required for limited-\n+\tprivate-with clause)\n+\t(New_Internal_Shadow_Entity): Code cleanup.\n+\t(Remove_Limited_With_Clause): Update the implementation to undo the\n+\tnew work carried out by Build_Limited_Views.\n+\t(Build_Chain): Complete documentation.\n+\tReplace Ada0Y by Ada 0Y in comments\n+\tMinor reformating\n+\n+\t* sem_ch3.adb (Array_Type_Declaration): In case of anonymous access\n+\ttypes the level of accessibility depends on the enclosing type\n+\tdeclaration.\n+\n+\t* sem_ch8.adb (Find_Expanded_Name): Fix condition to detect shadow\n+\tentities. Complete documentation of previous change.\n+\n+2004-05-24  Robert Dewar  <dewar@gnat.com>\n+\n+\t* namet.adb: Minor reformatting\n+\tAvoid use of name I (replace by J)\n+\tMinor code restructuring\n+\n+\t* sem_ch6.adb: Minor reformatting\n+\n+\t* lib-writ.adb: Do not set restriction as active if this is a\n+\tRestriction_Warning case.\n+\n+\t* sem_prag.adb: Reset restriction warning flag if real pragma\n+\trestriction encountered.\n+\n+\t* s-htable.adb: Minor reformatting\n+\tChange rotate count to 3 in Hash (improves hash for small strings)\n+\n+\t* 5qsystem.ads: Add comments for type Address (no literals allowed).\n+\n+\t* gnat_ugn.texi: Add new section of documentation \"Code Generation\n+\tControl\", which describes the use of -m switches.\n+\n+2004-05-24  Eric Botcazou  <ebotcazou@act-europe.fr>\n+\n+\t(tree_transform) <N_Identifier>: Do the dereference directly through\n+\tthe DECL_INITIAL for renamed variables.\n+\n 2004-05-24  Arnaud Charlet  <charlet@act-europe.fr>\n \n \t* s-osinte-linux-ia64.ads: Renamed system-linux-ia64.ads"}, {"sha": "79d404516e70cba4e8762fb77895f3c5ee526cae", "filename": "gcc/ada/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.in?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -1268,7 +1268,7 @@ ifeq ($(strip $(filter-out %ia64 linux%,$(arch) $(osys))),)\n   s-taprop.adb<s-taprop-linux.adb \\\n   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \\\n   s-taspri.ads<s-taspri-linux.ads \\\n-  system.ads<s-osinte-linux-ia64.ads\n+  system.ads<system-linux-ia64.ads\n \n   TOOLS_TARGET_PAIRS=mlib-tgt.adb<mlib-tgt-linux.adb\n   MISCLIB=\n@@ -1663,6 +1663,7 @@ install-gnatlib: ../stamp-gnatlib\n # Remove files to be replaced by target dependent sources\n \t$(RM) $(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n \t                rts/$(word 1,$(subst <, ,$(PAIR))))\n+\t$(RM) rts/*-*-*.ads rts/*-*-*.adb\n # Copy new target dependent sources\n \t$(foreach PAIR,$(LIBGNAT_TARGET_PAIRS), \\\n \t          $(LN_S) $(fsrcpfx)$(word 2,$(subst <, ,$(PAIR))) \\"}, {"sha": "b11867036f2cab33efc2bbfd339232b4073d368f", "filename": "gcc/ada/a-numaux-x86.adb", "status": "modified", "additions": 133, "deletions": 153, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fa-numaux-x86.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fa-numaux-x86.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-numaux-x86.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -7,7 +7,7 @@\n --                                 B o d y                                  --\n --                        (Machine Version for x86)                         --\n --                                                                          --\n---          Copyright (C) 1998-2001 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1998-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -41,61 +41,7 @@ with System.Machine_Code; use System.Machine_Code;\n \n package body Ada.Numerics.Aux is\n \n-   NL           : constant String := ASCII.LF & ASCII.HT;\n-\n-   type FPU_Stack_Pointer is range 0 .. 7;\n-   for FPU_Stack_Pointer'Size use 3;\n-\n-   type FPU_Status_Word is record\n-      B   : Boolean; -- FPU Busy (for 8087 compatibility only)\n-      ES  : Boolean; -- Error Summary Status\n-      SF  : Boolean; -- Stack Fault\n-\n-      Top : FPU_Stack_Pointer;\n-\n-      --  Condition Code Flags\n-\n-      --  C2 is set by FPREM and FPREM1 to indicate incomplete reduction.\n-      --  In case of successfull recorction, C0, C3 and C1 are set to the\n-      --  three least significant bits of the result (resp. Q2, Q1 and Q0).\n-\n-      --  C2 is used by FPTAN, FSIN, FCOS, and FSINCOS to indicate that\n-      --  that source operand is beyond the allowable range of\n-      --  -2.0**63 .. 2.0**63.\n-\n-      C3  : Boolean;\n-      C2  : Boolean;\n-      C1  : Boolean;\n-      C0  : Boolean;\n-\n-      --  Exception Flags\n-\n-      PE  : Boolean; -- Precision\n-      UE  : Boolean; -- Underflow\n-      OE  : Boolean; -- Overflow\n-      ZE  : Boolean; -- Zero Divide\n-      DE  : Boolean; -- Denormalized Operand\n-      IE  : Boolean; -- Invalid Operation\n-   end record;\n-\n-   for FPU_Status_Word use record\n-      B   at 0 range 15 .. 15;\n-      C3  at 0 range 14 .. 14;\n-      Top at 0 range 11 .. 13;\n-      C2  at 0 range 10 .. 10;\n-      C1  at 0 range  9 ..  9;\n-      C0  at 0 range  8 ..  8;\n-      ES  at 0 range  7 ..  7;\n-      SF  at 0 range  6 ..  6;\n-      PE  at 0 range  5 ..  5;\n-      UE  at 0 range  4 ..  4;\n-      OE  at 0 range  3 ..  3;\n-      ZE  at 0 range  2 ..  2;\n-      DE  at 0 range  1 ..  1;\n-      IE  at 0 range  0 ..  0;\n-   end record;\n-\n-   for FPU_Status_Word'Size use 16;\n+   NL : constant String := ASCII.LF & ASCII.HT;\n \n    -----------------------\n    -- Local subprograms --\n@@ -109,12 +55,9 @@ package body Ada.Numerics.Aux is\n    --  to calculate the exponentiation. This is used by Pow for values\n    --  for values of Y in the open interval (-0.25, 0.25)\n \n-   function Reduce (X : Double) return Double;\n-   --  Implement partial reduction of X by Pi in the x86.\n-\n-   --  Note that for the Sin, Cos and Tan functions completely accurate\n-   --  reduction of the argument is done for arguments in the range of\n-   --  -2.0**63 .. 2.0**63, using a 66-bit approximation of Pi.\n+   procedure Reduce (X : in out Double; Q : out Natural);\n+   --  Implements reduction of X by Pi/2. Q is the quadrant of the final\n+   --  result in the range 0 .. 3. The absolute value of X is at most Pi.\n \n    pragma Inline (Is_Nan);\n    pragma Inline (Reduce);\n@@ -123,9 +66,8 @@ package body Ada.Numerics.Aux is\n    --  Basic Elementary Functions --\n    ---------------------------------\n \n-   --  This section implements a few elementary functions that are\n-   --  used to build the more complex ones. This ordering enables\n-   --  better inlining.\n+   --  This section implements a few elementary functions that are used to\n+   --  build the more complex ones. This ordering enables better inlining.\n \n    ----------\n    -- Atan --\n@@ -206,20 +148,45 @@ package body Ada.Numerics.Aux is\n    -- Reduce --\n    ------------\n \n-   function Reduce (X : Double) return Double is\n-      Result : Double;\n+   procedure Reduce (X : in out Double; Q : out Natural) is\n+      Half_Pi     : constant := Pi / 2.0;\n+      Two_Over_Pi : constant := 2.0 / Pi;\n+\n+      HM : constant := Integer'Min (Double'Machine_Mantissa / 2, Natural'Size);\n+      M  : constant Double := 0.5 + 2.0**(1 - HM); -- Splitting constant\n+      P1 : constant Double := Double'Leading_Part (Half_Pi, HM);\n+      P2 : constant Double := Double'Leading_Part (Half_Pi - P1, HM);\n+      P3 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2, HM);\n+      P4 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2 - P3, HM);\n+      P5 : constant Double := Double'Leading_Part (Half_Pi - P1 - P2 - P3\n+                                                                 - P4, HM);\n+      P6 : constant Double := Double'Model (Half_Pi - P1 - P2 - P3 - P4 - P5);\n+      K  : Double := X * Two_Over_Pi;\n    begin\n-      Asm\n-        (Template =>\n-         --  Partial argument reduction\n-         \"fldpi                \" & NL\n-       & \"fadd    %%st(0), %%st\" & NL\n-       & \"fxch    %%st(1)      \" & NL\n-       & \"fprem1               \" & NL\n-       & \"fstp    %%st(1)      \",\n-         Outputs  => Double'Asm_Output (\"=t\", Result),\n-         Inputs   => Double'Asm_Input  (\"0\", X));\n-      return Result;\n+      --  For X < 2.0**32, all products below are computed exactly.\n+      --  Due to cancellation effects all subtractions are exact as well.\n+      --  As no double extended floating-point number has more than 75\n+      --  zeros after the binary point, the result will be the correctly\n+      --  rounded result of X - K * (Pi / 2.0).\n+\n+      while abs K >= 2.0**HM loop\n+         K := K * M - (K * M - K);\n+         X := (((((X - K * P1) - K * P2) - K * P3)\n+                     - K * P4) - K * P5) - K * P6;\n+         K := X * Two_Over_Pi;\n+      end loop;\n+\n+      if K /= K then\n+\n+         --  K is not a number, because X was not finite\n+\n+         raise Constraint_Error;\n+      end if;\n+\n+      K := Double'Rounding (K);\n+      Q := Integer (K) mod 4;\n+      X := (((((X - K * P1) - K * P2) - K * P3)\n+                  - K * P4) - K * P5) - K * P6;\n    end Reduce;\n \n    ----------\n@@ -241,9 +208,9 @@ package body Ada.Numerics.Aux is\n       return Result;\n    end Sqrt;\n \n-   ---------------------------------\n-   --  Other Elementary Functions --\n-   ---------------------------------\n+   --------------------------------\n+   -- Other Elementary Functions --\n+   --------------------------------\n \n    --  These are built using the previously implemented basic functions\n \n@@ -253,6 +220,7 @@ package body Ada.Numerics.Aux is\n \n    function Acos (X : Double) return Double is\n       Result  : Double;\n+\n    begin\n       Result := 2.0 * Atan (Sqrt ((1.0 - X) / (1.0 + X)));\n \n@@ -271,8 +239,8 @@ package body Ada.Numerics.Aux is\n \n    function Asin (X : Double) return Double is\n       Result  : Double;\n-   begin\n \n+   begin\n       Result := Atan (X / Sqrt ((1.0 - X) * (1.0 + X)));\n \n       --  The result value is NaN iff input was invalid\n@@ -289,29 +257,38 @@ package body Ada.Numerics.Aux is\n    ---------\n \n    function Cos (X : Double) return Double is\n-      Reduced_X : Double := X;\n+      Reduced_X : Double := abs X;\n       Result    : Double;\n-      Status    : FPU_Status_Word;\n+      Quadrant  : Natural range 0 .. 3;\n \n    begin\n+      if Reduced_X > Pi / 4.0 then\n+         Reduce (Reduced_X, Quadrant);\n+\n+         case Quadrant is\n+            when 0 =>\n+               Asm (Template  => \"fcos\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+            when 1 =>\n+               Asm (Template  => \"fsin\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", -Reduced_X));\n+            when 2 =>\n+               Asm (Template  => \"fcos ; fchs\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+            when 3 =>\n+               Asm (Template  => \"fsin\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+         end case;\n \n-      loop\n-         Asm\n-           (Template =>\n-            \"fcos                 \" & NL\n-          & \"xorl    %%eax, %%eax \" & NL\n-          & \"fnstsw  %%ax         \",\n-            Outputs  => (Double'Asm_Output         (\"=t\", Result),\n-                        FPU_Status_Word'Asm_Output (\"=a\", Status)),\n-            Inputs   => Double'Asm_Input           (\"0\", Reduced_X));\n-\n-         exit when not Status.C2;\n-\n-         --  Original argument was not in range and the result\n-         --  is the unmodified argument.\n-\n-         Reduced_X := Reduce (Result);\n-      end loop;\n+      else\n+         Asm (Template  => \"fcos\",\n+              Outputs  => Double'Asm_Output (\"=t\", Result),\n+              Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+      end if;\n \n       return Result;\n    end Cos;\n@@ -322,7 +299,6 @@ package body Ada.Numerics.Aux is\n \n    function Logarithmic_Pow (X, Y : Double) return Double is\n       Result  : Double;\n-\n    begin\n       Asm (Template => \"\"             --  X                  : Y\n        & \"fyl2x                \" & NL --  Y * Log2 (X)\n@@ -339,7 +315,6 @@ package body Ada.Numerics.Aux is\n          Inputs   =>\n            (Double'Asm_Input  (\"0\", X),\n             Double'Asm_Input  (\"u\", Y)));\n-\n       return Result;\n    end Logarithmic_Pow;\n \n@@ -351,8 +326,7 @@ package body Ada.Numerics.Aux is\n       type Mantissa_Type is mod 2**Double'Machine_Mantissa;\n       --  Modular type that can hold all bits of the mantissa of Double\n \n-      --  For negative exponents, a division is done\n-      --  at the end of the processing.\n+      --  For negative exponents, do divide at the end of the processing\n \n       Negative_Y : constant Boolean := Y < 0.0;\n       Abs_Y      : constant Double := abs Y;\n@@ -370,8 +344,7 @@ package body Ada.Numerics.Aux is\n       Factor : Double := 1.0;\n \n    begin\n-      --  Select algorithm for calculating Pow:\n-      --  integer cases fall through\n+      --  Select algorithm for calculating Pow (integer cases fall through)\n \n       if Exp_High >= 2.0**Double'Machine_Mantissa then\n \n@@ -395,7 +368,6 @@ package body Ada.Numerics.Aux is\n \n       elsif Exp_High /= Abs_Y then\n          Exp_Low := Abs_Y - Exp_High;\n-\n          Factor := 1.0;\n \n          if Exp_Low /= 0.0 then\n@@ -473,27 +445,36 @@ package body Ada.Numerics.Aux is\n    function Sin (X : Double) return Double is\n       Reduced_X : Double := X;\n       Result    : Double;\n-      Status    : FPU_Status_Word;\n+      Quadrant  : Natural range 0 .. 3;\n \n    begin\n+      if abs X > Pi / 4.0 then\n+         Reduce (Reduced_X, Quadrant);\n+\n+         case Quadrant is\n+            when 0 =>\n+               Asm (Template  => \"fsin\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+            when 1 =>\n+               Asm (Template  => \"fcos\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+            when 2 =>\n+               Asm (Template  => \"fsin\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", -Reduced_X));\n+            when 3 =>\n+               Asm (Template  => \"fcos ; fchs\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+         end case;\n \n-      loop\n-         Asm\n-           (Template =>\n-            \"fsin                 \" & NL\n-          & \"xorl    %%eax, %%eax \" & NL\n-          & \"fnstsw  %%ax         \",\n-            Outputs  => (Double'Asm_Output          (\"=t\", Result),\n-                         FPU_Status_Word'Asm_Output (\"=a\", Status)),\n-            Inputs   => Double'Asm_Input            (\"0\", Reduced_X));\n-\n-         exit when not Status.C2;\n-\n-         --  Original argument was not in range and the result\n-         --  is the unmodified argument.\n-\n-         Reduced_X := Reduce (Result);\n-      end loop;\n+      else\n+         Asm (Template  => \"fsin\",\n+            Outputs  => Double'Asm_Output (\"=t\", Result),\n+            Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+      end if;\n \n       return Result;\n    end Sin;\n@@ -505,30 +486,34 @@ package body Ada.Numerics.Aux is\n    function Tan (X : Double) return Double is\n       Reduced_X : Double := X;\n       Result    : Double;\n-      Status    : FPU_Status_Word;\n+      Quadrant  : Natural range 0 .. 3;\n \n    begin\n+      if abs X > Pi / 4.0 then\n+         Reduce (Reduced_X, Quadrant);\n+\n+         if Quadrant mod 2 = 0 then\n+            Asm (Template  => \"fptan\" & NL\n+                            & \"ffree   %%st(0)\"  & NL\n+                            & \"fincstp\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+         else\n+            Asm (Template  => \"fsincos\" & NL\n+                            & \"fdivp   %%st(1)\" & NL\n+                            & \"fchs\",\n+                  Outputs  => Double'Asm_Output (\"=t\", Result),\n+                  Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+         end if;\n \n-      loop\n-         Asm\n-           (Template =>\n-            \"fptan                \" & NL\n-          & \"xorl    %%eax, %%eax \" & NL\n-          & \"fnstsw  %%ax         \" & NL\n-          & \"ffree   %%st(0)      \" & NL\n-          & \"fincstp              \",\n-\n-            Outputs  => (Double'Asm_Output         (\"=t\", Result),\n-                        FPU_Status_Word'Asm_Output (\"=a\", Status)),\n-            Inputs   => Double'Asm_Input           (\"0\", Reduced_X));\n-\n-         exit when not Status.C2;\n-\n-         --  Original argument was not in range and the result\n-         --  is the unmodified argument.\n-\n-         Reduced_X := Reduce (Result);\n-      end loop;\n+      else\n+         Asm (Template  =>\n+               \"fptan                 \" & NL\n+             & \"ffree   %%st(0)      \" & NL\n+             & \"fincstp              \",\n+               Outputs  => Double'Asm_Output (\"=t\", Result),\n+               Inputs   => Double'Asm_Input  (\"0\", Reduced_X));\n+      end if;\n \n       return Result;\n    end Tan;\n@@ -543,11 +528,9 @@ package body Ada.Numerics.Aux is\n \n       if abs X < 25.0 then\n          return (Exp (X) - Exp (-X)) / 2.0;\n-\n       else\n          return Exp (X) / 2.0;\n       end if;\n-\n    end Sinh;\n \n    ----------\n@@ -560,11 +543,9 @@ package body Ada.Numerics.Aux is\n \n       if abs X < 22.0 then\n          return (Exp (X) + Exp (-X)) / 2.0;\n-\n       else\n          return Exp (X) / 2.0;\n       end if;\n-\n    end Cosh;\n \n    ----------\n@@ -574,7 +555,7 @@ package body Ada.Numerics.Aux is\n    function Tanh (X : Double) return Double is\n    begin\n       --  Return the Hyperbolic Tangent of x\n-      --\n+\n       --                                    x    -x\n       --                                   e  - e        Sinh (X)\n       --       Tanh (X) is defined to be -----------   = --------\n@@ -586,7 +567,6 @@ package body Ada.Numerics.Aux is\n       end if;\n \n       return 1.0 / (1.0 + Exp (-2.0 * X)) - 1.0 / (1.0 + Exp (2.0 * X));\n-\n    end Tanh;\n \n end Ada.Numerics.Aux;"}, {"sha": "92573fd46d582c4d70a40df1413d6c105371c9a4", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -806,7 +806,7 @@ __gnat_readdir (DIR *dirp, char *buffer)\n     return NULL;\n \n #else\n-  struct dirent *dirent = readdir (dirp);\n+  struct dirent *dirent = (struct dirent *) readdir (dirp);\n \n   if (dirent != NULL)\n     {"}, {"sha": "df32596a9427fa6d4034ded6f1dd68e1cda9050b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -205,7 +205,7 @@ package body Einfo is\n    --    Inner_Instances                 Elist23\n    --    Enum_Pos_To_Rep                 Node23\n    --    Packed_Array_Type               Node23\n-   --    Limited_Views                   Elist23\n+   --    Limited_View                    Node23\n    --    Privals_Chain                   Elist23\n    --    Protected_Operation             Node23\n \n@@ -1708,11 +1708,11 @@ package body Einfo is\n       return Node20 (Id);\n    end Last_Entity;\n \n-   function Limited_Views (Id : E) return L is\n+   function Limited_View (Id : E) return E is\n    begin\n       pragma Assert (Ekind (Id) = E_Package);\n-      return Elist23 (Id);\n-   end Limited_Views;\n+      return Node23 (Id);\n+   end Limited_View;\n \n    function Lit_Indexes (Id : E) return E is\n    begin\n@@ -3666,11 +3666,11 @@ package body Einfo is\n       Set_Node20 (Id, V);\n    end Set_Last_Entity;\n \n-   procedure Set_Limited_Views (Id : E; V : L) is\n+   procedure Set_Limited_View (Id : E; V : E) is\n    begin\n       pragma Assert (Ekind (Id) = E_Package);\n-      Set_Elist23 (Id, V);\n-   end Set_Limited_Views;\n+      Set_Node23 (Id, V);\n+   end Set_Limited_View;\n \n    procedure Set_Lit_Indexes (Id : E; V : E) is\n    begin"}, {"sha": "3b5c5bc033bbd583cc22203642850df682230dfd", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -2391,11 +2391,12 @@ package Einfo is\n --       Points to a the last entry in the list of associated entities chained\n --       through the Next_Entity field. Empty if no entities are chained.\n \n---    Limited_Views (Elist23)\n---       Present in non-generic package entities that are not instances.\n---       The elements of this list are the shadow entities created for the\n---       types and local packages that are declared in a package that appears\n---       in a limited_with clause (Ada0Y: AI-50217)\n+--    Limited_View (Node23)\n+--       Present in non-generic package entities that are not instances. Bona\n+--       fide package with the limited-view list through the first_entity and\n+--       first_private attributes. The elements of this list are the shadow\n+--       entities created for the types and local packages that are declared\n+--       in a package that appears in a limited_with clause (Ada0Y: AI-50217)\n \n --    Lit_Indexes (Node15)\n --       Present in enumeration types and subtypes. Non-empty only for the\n@@ -4454,7 +4455,7 @@ package Einfo is\n    --    Scope_Depth_Value             (Uint22)\n    --    Generic_Renamings             (Elist23)  (for an instance)\n    --    Inner_Instances               (Elist23)  (generic case only)\n-   --    Limited_Views                 (Elist23)  (non-generic, not instance)\n+   --    Limited_View                  (Node23)   (non-generic, not instance)\n    --    Delay_Subprogram_Descriptors  (Flag50)\n    --    Body_Needed_For_SAL           (Flag40)\n    --    Discard_Names                 (Flag88)\n@@ -5187,7 +5188,7 @@ package Einfo is\n    function Kill_Range_Checks                  (Id : E) return B;\n    function Kill_Tag_Checks                    (Id : E) return B;\n    function Last_Entity                        (Id : E) return E;\n-   function Limited_Views                      (Id : E) return L;\n+   function Limited_View                       (Id : E) return E;\n    function Lit_Indexes                        (Id : E) return E;\n    function Lit_Strings                        (Id : E) return E;\n    function Machine_Radix_10                   (Id : E) return B;\n@@ -5661,7 +5662,7 @@ package Einfo is\n    procedure Set_Kill_Range_Checks             (Id : E; V : B := True);\n    procedure Set_Kill_Tag_Checks               (Id : E; V : B := True);\n    procedure Set_Last_Entity                   (Id : E; V : E);\n-   procedure Set_Limited_Views                 (Id : E; V : L);\n+   procedure Set_Limited_View                  (Id : E; V : E);\n    procedure Set_Lit_Indexes                   (Id : E; V : E);\n    procedure Set_Lit_Strings                   (Id : E; V : E);\n    procedure Set_Machine_Radix_10              (Id : E; V : B := True);\n@@ -6187,7 +6188,7 @@ package Einfo is\n    pragma Inline (Kill_Range_Checks);\n    pragma Inline (Kill_Tag_Checks);\n    pragma Inline (Last_Entity);\n-   pragma Inline (Limited_Views);\n+   pragma Inline (Limited_View);\n    pragma Inline (Lit_Indexes);\n    pragma Inline (Lit_Strings);\n    pragma Inline (Machine_Radix_10);\n@@ -6496,7 +6497,7 @@ package Einfo is\n    pragma Inline (Set_Kill_Range_Checks);\n    pragma Inline (Set_Kill_Tag_Checks);\n    pragma Inline (Set_Last_Entity);\n-   pragma Inline (Set_Limited_Views);\n+   pragma Inline (Set_Limited_View);\n    pragma Inline (Set_Lit_Indexes);\n    pragma Inline (Set_Lit_Strings);\n    pragma Inline (Set_Machine_Radix_10);"}, {"sha": "0abca3055ca128227ffe5d07c5fea43d5d389f64", "filename": "gcc/ada/exp_dbug.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fexp_dbug.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fexp_dbug.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dbug.ads?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -104,7 +104,7 @@ package Exp_Dbug is\n       --    __nn  (two underscores)\n \n       --  where nn is a serial number (2 for the second overloaded function,\n-      --  2 for the third, etc.). A suffix of __1 is always omitted (i.e. no\n+      --  3 for the third, etc.). A suffix of __1 is always omitted (i.e. no\n       --  suffix implies the first instance).\n \n       --  These names are prefixed by the normal full qualification. So"}, {"sha": "c75882bc78cd31f12ecb7df77f3341d7b6e9d752", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -3646,6 +3646,7 @@ describe the switches in more detail in functionally grouped sections.\n * Exception Handling Control::\n * Units to Sources Mapping Files::\n * Integrated Preprocessing::\n+* Code Generation Control::\n @ifset vms\n * Return Codes::\n @end ifset\n@@ -6534,6 +6535,35 @@ This switch is similar to switch @option{^-D^/ASSOCIATE^} of @code{gnatprep}.\n \n @end table\n \n+@node Code Generation Control\n+@subsection Code Generation Control\n+\n+@noindent\n+\n+The GCC technology provides a wide range of target dependent\n+@option{-m} switches for controlling\n+details of code generation with respect to different versions of\n+architectures. This includes variations in instruction sets (e.g.\n+different members of the power pc family), and different requirements\n+for optimal arrangement of instructions (e.g. different members of\n+the x86 family). The list of available @option{-m} switches may be\n+found in the GCC documentation.\n+\n+Use of the these @option{-m} switches may in some cases result in improved\n+code performance.\n+\n+The GNAT Pro technology is tested and qualified without any\n+@option{-m} switches,\n+so generally the most reliable approach is to avoid the use of these\n+switches. However, we generally expect most of these switches to work\n+successfully with GNAT Pro, and many customers have reported successful\n+use of these options.\n+\n+Our general advice is to avoid the use of @option{-m} switches unless\n+special needs lead to requirements in this area. In particular,\n+there is no point in using @option{-m} switches to improve performance\n+unless you actually see a performance improvement.\n+\n @ifset vms\n @node Return Codes\n @subsection Return Codes"}, {"sha": "9d79b6c3c0e233f87b286b8313c2e3f2a92d237e", "filename": "gcc/ada/init.c", "status": "modified", "additions": 63, "deletions": 1, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -262,6 +262,51 @@ __gnat_set_globals (int main_priority,\n    at all; the intention is that this be replaced by system specific\n    code where initialization is required. */\n \n+/* Notes on the Zero Cost Exceptions scheme and its impact on the signal\n+   handlers implemented below :\n+\n+   What we call Zero Cost Exceptions is implemented using the GCC eh\n+   circuitry, even if the underlying implementation is setjmp/longjmp\n+   based. In any case ...\n+\n+   The GCC unwinder expects to be dealing with call return addresses, since\n+   this is the \"nominal\" case of what we retrieve while unwinding a regular\n+   call chain. To evaluate if a handler applies at some point in this chain,\n+   the propagation engine needs to determine what region the corresponding\n+   call instruction pertains to. The return address may not be attached to the\n+   same region as the call, so the unwinder unconditionally substracts \"some\"\n+   amount to the return addresses it gets to search the region tables. The\n+   exact amount is computed to ensure that the resulting address is inside the\n+   call instruction, and is thus target dependant (think about delay slots for\n+   instance).\n+\n+   When we raise an exception from a signal handler, e.g. to transform a\n+   SIGSEGV into Storage_Error, things need to appear as if the signal handler\n+   had been \"called\" by the instruction which triggered the signal, so that\n+   exception handlers that apply there are considered. What the unwinder will\n+   retrieve as the return address from the signal handler is what it will find\n+   as the faulting instruction address in the corresponding signal context\n+   pushed by the kernel. Leaving this address untouched may loose, because if\n+   the triggering instruction happens to be the very first of a region, the\n+   later adjustements performed by the unwinder would yield an address outside\n+   that region. We need to compensate for those adjustments at some point,\n+   which we currently do in the GCC unwinding fallback macro.\n+\n+   The thread at http://gcc.gnu.org/ml/gcc-patches/2004-05/msg00343.html\n+   describes a couple of issues with our current approach. Basically: on some\n+   targets the adjustment to apply depends on the triggering signal, which is\n+   not easily accessible from the macro, and we actually do not tackle this as\n+   of today. Besides, other languages, e.g. Java, deal with this by performing\n+   the adjustment in the signal handler before the raise, so our adjustments\n+   may break those front-ends.\n+\n+   To have it all right, we should either find a way to deal with the signal\n+   variants from the macro and convert Java on all targets (ugh), or remove\n+   our macro adjustments and update our signal handlers a-la-java way.  The\n+   latter option appears the simplest, although some targets have their share\n+   of subtleties to account for.  See for instance the syscall(SYS_sigaction)\n+   story in libjava/include/i386-signal.h.  */\n+\n /***********************************/\n /* __gnat_initialize (AIX Version) */\n /***********************************/\n@@ -1051,6 +1096,18 @@ struct Machine_State\n \n static void __gnat_error_handler (int, int, sigcontext_t *);\n \n+/* We are not setting the SA_SIGINFO bit in the sigaction flags when\n+   connecting that handler, with the effects described in the sigaction\n+   man page:\n+\n+          SA_SIGINFO [...]\n+          If cleared and the signal is caught, the first argument is\n+          also the signal number but the second argument is the signal\n+          code identifying the cause of the signal. The third argument\n+          points to a sigcontext_t structure containing the receiving\n+\t  process's context when the signal was delivered.\n+*/\n+\n static void\n __gnat_error_handler (int sig, int code, sigcontext_t *sc)\n {\n@@ -1076,8 +1133,13 @@ __gnat_error_handler (int sig, int code, sigcontext_t *sc)\n \t  exception = &program_error; /* ??? storage_error ??? */\n \t  msg = \"SIGSEGV: (Autogrow for file failed)\";\n \t}\n-      else if (code == EACCES)\n+      else if (code == EACCES || code == EEXIST)\n \t{\n+\t  /* ??? We handle stack overflows here, some of which do trigger\n+\t         SIGSEGV + EEXIST on Irix 6.5 although EEXIST is not part of\n+\t         the documented valid codes for SEGV in the signal(5) man\n+\t         page.  */\n+\n \t  /* ??? Re-add smarts to further verify that we launched\n \t\t the stack into a guard page, not an attempt to\n \t\t write to .text or something */"}, {"sha": "7ca0e31d7e1b5da859f8ec7e5f3aca94db2d2564", "filename": "gcc/ada/inline.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Finline.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Finline.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finline.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2003 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -467,6 +467,22 @@ package body Inline is\n          return;\n       end if;\n \n+      --  If the instance appears within a generic subprogram there is nothing\n+      --  to finalize either.\n+\n+      declare\n+         S : Entity_Id;\n+      begin\n+         S := Scope (Inst);\n+         while Present (S) and then S /= Standard_Standard loop\n+            if Is_Generic_Subprogram (S) then\n+               return;\n+            end if;\n+\n+            S := Scope (S);\n+         end loop;\n+      end;\n+\n       Elmt := First_Elmt (To_Clean);\n \n       while Present (Elmt) loop"}, {"sha": "c4dd7668d489c894fb8cd313aaf80c6e85c944e5", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -944,7 +944,9 @@ package body Lib.Writ is\n       --  First the information for the boolean restrictions\n \n       for R in All_Boolean_Restrictions loop\n-         if Main_Restrictions.Set (R) then\n+         if Main_Restrictions.Set (R)\n+           and then not Restriction_Warnings (R)\n+         then\n             Write_Info_Char ('r');\n          elsif Main_Restrictions.Violated (R) then\n             Write_Info_Char ('v');"}, {"sha": "78c0df49895f67e6742cc8e67e791c3b0db10a0b", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 55, "deletions": 56, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -139,18 +139,17 @@ package body Namet is\n \n    begin\n       if Debug_Flag_H then\n-\n          for J in F'Range loop\n             F (J) := 0;\n          end loop;\n \n-         for I in Hash_Index_Type loop\n-            if Hash_Table (I) = No_Name then\n+         for J in Hash_Index_Type loop\n+            if Hash_Table (J) = No_Name then\n                F (0) := F (0) + 1;\n \n             else\n                Write_Str (\"Hash_Table (\");\n-               Write_Int (Int (I));\n+               Write_Int (Int (J));\n                Write_Str (\") has \");\n \n                declare\n@@ -160,7 +159,7 @@ package body Namet is\n \n                begin\n                   C := 0;\n-                  N := Hash_Table (I);\n+                  N := Hash_Table (J);\n \n                   while N /= No_Name loop\n                      N := Name_Entries.Table (N).Hash_Link;\n@@ -177,7 +176,7 @@ package body Namet is\n                      F (Max_Chain_Length) := F (Max_Chain_Length) + 1;\n                   end if;\n \n-                  N := Hash_Table (I);\n+                  N := Hash_Table (J);\n \n                   while N /= No_Name loop\n                      S := Name_Entries.Table (N).Name_Chars_Index;\n@@ -196,27 +195,27 @@ package body Namet is\n \n          Write_Eol;\n \n-         for I in Int range 0 .. Max_Chain_Length loop\n-            if F (I) /= 0 then\n+         for J in Int range 0 .. Max_Chain_Length loop\n+            if F (J) /= 0 then\n                Write_Str (\"Number of hash chains of length \");\n \n-               if I < 10 then\n+               if J < 10 then\n                   Write_Char (' ');\n                end if;\n \n-               Write_Int (I);\n+               Write_Int (J);\n \n-               if I = Max_Chain_Length then\n+               if J = Max_Chain_Length then\n                   Write_Str (\" or greater\");\n                end if;\n \n                Write_Str (\" = \");\n-               Write_Int (F (I));\n+               Write_Int (F (J));\n                Write_Eol;\n \n-               if I /= 0 then\n-                  Nsyms := Nsyms + F (I);\n-                  Probes := Probes + F (I) * (1 + I) * 100;\n+               if J /= 0 then\n+                  Nsyms := Nsyms + F (J);\n+                  Probes := Probes + F (J) * (1 + J) * 100;\n                end if;\n             end if;\n          end loop;\n@@ -560,6 +559,8 @@ package body Namet is\n    -- Get_Name_String --\n    ---------------------\n \n+   --  Procedure version leaving result in Name_Buffer, length in Name_Len\n+\n    procedure Get_Name_String (Id : Name_Id) is\n       S : Int;\n \n@@ -574,6 +575,12 @@ package body Namet is\n       end loop;\n    end Get_Name_String;\n \n+   ---------------------\n+   -- Get_Name_String --\n+   ---------------------\n+\n+   --  Function version returning a string\n+\n    function Get_Name_String (Id : Name_Id) return String is\n       S : Int;\n \n@@ -656,45 +663,12 @@ package body Namet is\n    ----------\n \n    function Hash return Hash_Index_Type is\n-      subtype Int_0_12 is Int range 0 .. 12;\n-      --  Used to avoid when others on case jump below\n-\n-      Even_Name_Len : Integer;\n-      --  Last even numbered position (used for >12 case)\n-\n    begin\n-\n-      --  Special test for 12 (rather than counting on a when others for the\n-      --  case statement below) avoids some Ada compilers converting the case\n-      --  statement into successive jumps.\n-\n-      --  The case of a name longer than 12 characters is handled by taking\n-      --  the first 6 odd numbered characters and the last 6 even numbered\n-      --  characters\n-\n-      if Name_Len > 12 then\n-         Even_Name_Len := (Name_Len) / 2 * 2;\n-\n-         return ((((((((((((\n-           Character'Pos (Name_Buffer (01))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len - 10))) * 2 +\n-           Character'Pos (Name_Buffer (03))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len - 08))) * 2 +\n-           Character'Pos (Name_Buffer (05))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len - 06))) * 2 +\n-           Character'Pos (Name_Buffer (07))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len - 04))) * 2 +\n-           Character'Pos (Name_Buffer (09))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len - 02))) * 2 +\n-           Character'Pos (Name_Buffer (11))) * 2 +\n-           Character'Pos (Name_Buffer (Even_Name_Len))) mod Hash_Num;\n-      end if;\n-\n       --  For the cases of 1-12 characters, all characters participate in the\n       --  hash. The positioning is randomized, with the bias that characters\n       --  later on participate fully (i.e. are added towards the right side).\n \n-      case Int_0_12 (Name_Len) is\n+      case Name_Len is\n \n          when 0 =>\n             return 0;\n@@ -813,6 +787,26 @@ package body Namet is\n               Character'Pos (Name_Buffer (10))) * 2 +\n               Character'Pos (Name_Buffer (12))) mod Hash_Num;\n \n+         --  Names longer than 12 characters are handled by taking the first\n+         --  6 odd numbered characters and the last 6 even numbered characters.\n+\n+         when others => declare\n+               Even_Name_Len : constant Integer := (Name_Len) / 2 * 2;\n+         begin\n+            return ((((((((((((\n+              Character'Pos (Name_Buffer (01))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len - 10))) * 2 +\n+              Character'Pos (Name_Buffer (03))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len - 08))) * 2 +\n+              Character'Pos (Name_Buffer (05))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len - 06))) * 2 +\n+              Character'Pos (Name_Buffer (07))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len - 04))) * 2 +\n+              Character'Pos (Name_Buffer (09))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len - 02))) * 2 +\n+              Character'Pos (Name_Buffer (11))) * 2 +\n+              Character'Pos (Name_Buffer (Even_Name_Len))) mod Hash_Num;\n+         end;\n       end case;\n    end Hash;\n \n@@ -821,7 +815,6 @@ package body Namet is\n    ----------------\n \n    procedure Initialize is\n-\n    begin\n       Name_Chars.Init;\n       Name_Entries.Init;\n@@ -853,12 +846,20 @@ package body Namet is\n    -- Is_Internal_Name --\n    ----------------------\n \n+   --  Version taking an argument\n+\n    function Is_Internal_Name (Id : Name_Id) return Boolean is\n    begin\n       Get_Name_String (Id);\n       return Is_Internal_Name;\n    end Is_Internal_Name;\n \n+   ----------------------\n+   -- Is_Internal_Name --\n+   ----------------------\n+\n+   --  Version taking its input from Name_Buffer\n+\n    function Is_Internal_Name return Boolean is\n    begin\n       if Name_Buffer (1) = '_'\n@@ -1033,8 +1034,8 @@ package body Namet is\n \n                S := Name_Entries.Table (New_Id).Name_Chars_Index;\n \n-               for I in 1 .. Name_Len loop\n-                  if Name_Chars.Table (S + Int (I)) /= Name_Buffer (I) then\n+               for J in 1 .. Name_Len loop\n+                  if Name_Chars.Table (S + Int (J)) /= Name_Buffer (J) then\n                      goto No_Match;\n                   end if;\n                end loop;\n@@ -1069,9 +1070,9 @@ package body Namet is\n \n          --  Set corresponding string entry in the Name_Chars table\n \n-         for I in 1 .. Name_Len loop\n+         for J in 1 .. Name_Len loop\n             Name_Chars.Increment_Last;\n-            Name_Chars.Table (Name_Chars.Last) := Name_Buffer (I);\n+            Name_Chars.Table (Name_Chars.Last) := Name_Buffer (J);\n          end loop;\n \n          Name_Chars.Increment_Last;\n@@ -1149,11 +1150,9 @@ package body Namet is\n       if In_Character_Range (C) then\n          declare\n             CC : constant Character := Get_Character (C);\n-\n          begin\n             if CC in 'a' .. 'z' or else CC in '0' .. '9' then\n                Name_Buffer (Name_Len) := CC;\n-\n             else\n                Name_Buffer (Name_Len) := 'U';\n                Set_Hex_Chars (Natural (C));"}, {"sha": "5e3675a1e8cd2230ff60a532a48dd1b51289f7ac", "filename": "gcc/ada/s-htable.adb", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---           Copyright (C) 1995-2002 Ada Core Technologies, Inc.            --\n+--           Copyright (C) 1995-2004 Ada Core Technologies, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -182,9 +182,9 @@ package body System.HTable is\n \n    end Static_HTable;\n \n-   --------------------\n-   --  Simple_HTable --\n-   --------------------\n+   -------------------\n+   -- Simple_HTable --\n+   -------------------\n \n    package body Simple_HTable is\n \n@@ -221,7 +221,6 @@ package body System.HTable is\n \n       function  Get (K : Key) return Element is\n          Tmp : constant Elmt_Ptr := Tab.Get (K);\n-\n       begin\n          if Tmp = null then\n             return No_Element;\n@@ -236,7 +235,6 @@ package body System.HTable is\n \n       function Get_First return Element is\n          Tmp : constant Elmt_Ptr := Tab.Get_First;\n-\n       begin\n          if Tmp = null then\n             return No_Element;\n@@ -260,7 +258,6 @@ package body System.HTable is\n \n       function Get_Next return Element is\n          Tmp : constant Elmt_Ptr := Tab.Get_Next;\n-\n       begin\n          if Tmp = null then\n             return No_Element;\n@@ -318,7 +315,6 @@ package body System.HTable is\n \n       procedure Set (K : Key; E : Element) is\n          Tmp : constant Elmt_Ptr := Tab.Get (K);\n-\n       begin\n          if Tmp = null then\n             Tab.Set (new Element_Wrapper'(K, E, null));\n@@ -348,15 +344,16 @@ package body System.HTable is\n       function Rotate_Left (Value : Uns; Amount : Natural) return Uns;\n       pragma Import (Intrinsic, Rotate_Left);\n \n-      Tmp : Uns := 0;\n+      Hash_Value : Uns;\n \n    begin\n+      Hash_Value := 0;\n       for J in Key'Range loop\n-         Tmp := Rotate_Left (Tmp, 1) + Character'Pos (Key (J));\n+         Hash_Value := Rotate_Left (Hash_Value, 3) + Character'Pos (Key (J));\n       end loop;\n \n       return Header_Num'First +\n-               Header_Num'Base (Tmp mod Header_Num'Range_Length);\n+               Header_Num'Base (Hash_Value mod Header_Num'Range_Length);\n    end Hash;\n \n end System.HTable;"}, {"sha": "333bae3a9a70e53e8aec7fcd674589e402a8ab13", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 157, "deletions": 72, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -28,7 +28,6 @@ with Atree;    use Atree;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n with Errout;   use Errout;\n-with Elists;   use Elists;\n with Exp_Util; use Exp_Util;\n with Fname;    use Fname;\n with Fname.UF; use Fname.UF;\n@@ -77,7 +76,7 @@ package body Sem_Ch10 is\n    --  in a limited_with clause. If the package was not previously analyzed\n    --  then it also performs a basic decoration of the real entities; this\n    --  is required to do not pass non-decorated entities to the back-end.\n-   --  Implements Ada0Y (AI-50217).\n+   --  Implements Ada 0Y (AI-50217).\n \n    procedure Check_Body_Needed_For_SAL (Unit_Name : Entity_Id);\n    --  Check whether the source for the body of a compilation unit must\n@@ -101,7 +100,7 @@ package body Sem_Ch10 is\n    --  through a regular with clause. This procedure creates the implicit\n    --  limited with_clauses for the parents and loads the corresponding units.\n    --  The shadow entities are created when the inserted clause is analyzed.\n-   --  Implements Ada0Y (AI-50217).\n+   --  Implements Ada 0Y (AI-50217).\n \n    procedure Expand_With_Clause (Nam : Node_Id; N : Node_Id);\n    --  When a child unit appears in a context clause, the implicit withs on\n@@ -129,11 +128,11 @@ package body Sem_Ch10 is\n \n    procedure Install_Limited_Context_Clauses (N : Node_Id);\n    --  Subsidiary to Install_Context. Process only limited with_clauses\n-   --  for current unit. Implements Ada0Y (AI-50217).\n+   --  for current unit. Implements Ada 0Y (AI-50217).\n \n    procedure Install_Limited_Withed_Unit (N : Node_Id);\n    --  Place shadow entities for a limited_with package in the visibility\n-   --  structures for the current compilation. Implements Ada0Y (AI-50217).\n+   --  structures for the current compilation. Implements Ada 0Y (AI-50217).\n \n    procedure Install_Withed_Unit\n      (With_Clause     : Node_Id;\n@@ -182,7 +181,7 @@ package body Sem_Ch10 is\n \n    procedure Remove_Limited_With_Clause (N : Node_Id);\n    --  Remove from visibility the shadow entities introduced for a package\n-   --  mentioned in a limited_with clause. Implements Ada0Y (AI-50217).\n+   --  mentioned in a limited_with clause. Implements Ada 0Y (AI-50217).\n \n    procedure Remove_Parents (Lib_Unit : Node_Id);\n    --  Remove_Parents checks if Lib_Unit is a child spec. If so then the parent\n@@ -620,7 +619,7 @@ package body Sem_Ch10 is\n             Item := First (Context_Items (N));\n             while Present (Item) loop\n \n-               --  Ada0Y (AI-50217): Do not consider limited-withed units\n+               --  Ada 0Y (AI-50217): Do not consider limited-withed units\n \n                if Nkind (Item) = N_With_Clause\n                   and then not Implicit_With (Item)\n@@ -799,8 +798,8 @@ package body Sem_Ch10 is\n       --  Loop through context items. This is done is three passes:\n       --  a) The first pass analyze non-limited with-clauses.\n       --  b) The second pass add implicit limited_with clauses for\n-      --     the parents of child units (Ada0Y: AI-50217)\n-      --  c) The third pass analyzes limited_with clauses (Ada0Y: AI-50217)\n+      --     the parents of child units (Ada 0Y: AI-50217)\n+      --  c) The third pass analyzes limited_with clauses (Ada 0Y: AI-50217)\n \n       Item := First (Context_Items (N));\n       while Present (Item) loop\n@@ -1617,7 +1616,7 @@ package body Sem_Ch10 is\n \n    begin\n       if Limited_Present (N) then\n-         --  Ada0Y (AI-50217): Build visibility structures but do not\n+         --  Ada 0Y (AI-50217): Build visibility structures but do not\n          --  analyze unit\n \n          Build_Limited_Views (N);\n@@ -3033,7 +3032,6 @@ package body Sem_Ch10 is\n          if Nkind (Item) = N_With_Clause\n            and then Limited_Present (Item)\n          then\n-\n             Check_Withed_Unit (Item);\n \n             if Private_Present (Library_Unit (Item)) then\n@@ -3165,7 +3163,7 @@ package body Sem_Ch10 is\n \n    procedure Install_Private_With_Clauses (P : Entity_Id) is\n       Decl   : constant Node_Id := Unit_Declaration_Node (P);\n-      Clause : Node_Id;\n+      Item   : Node_Id;\n \n    begin\n       if Debug_Flag_I then\n@@ -3175,15 +3173,20 @@ package body Sem_Ch10 is\n       end if;\n \n       if Nkind (Parent (Decl)) = N_Compilation_Unit then\n-         Clause := First (Context_Items (Parent (Decl)));\n-         while Present (Clause) loop\n-            if Nkind (Clause) = N_With_Clause\n-              and then Private_Present (Clause)\n+         Item := First (Context_Items (Parent (Decl)));\n+\n+         while Present (Item) loop\n+            if Nkind (Item) = N_With_Clause\n+              and then Private_Present (Item)\n             then\n-               Install_Withed_Unit (Clause, Private_With_OK => True);\n+               if Limited_Present (Item) then\n+                  Install_Limited_Withed_Unit (Item);\n+               else\n+                  Install_Withed_Unit (Item, Private_With_OK => True);\n+               end if;\n             end if;\n \n-            Next (Clause);\n+            Next (Item);\n          end loop;\n       end if;\n    end Install_Private_With_Clauses;\n@@ -3274,10 +3277,11 @@ package body Sem_Ch10 is\n                            Get_Source_Unit (Library_Unit (N));\n       P_Unit           : constant Entity_Id := Unit (Library_Unit (N));\n       P                : Entity_Id;\n-      Lim_Elmt         : Elmt_Id;\n-      Lim_Typ          : Entity_Id;\n       Is_Child_Package : Boolean := False;\n \n+      Lim_Header       : Entity_Id;\n+      Lim_Typ          : Entity_Id;\n+\n       function In_Chain (E : Entity_Id) return Boolean;\n       --  Check that the shadow entity is not already in the homonym\n       --  chain, for example through a limited_with clause in a parent unit.\n@@ -3362,6 +3366,35 @@ package body Sem_Ch10 is\n                    or else (Is_Child_Package\n                              and then Is_Visible_Child_Unit (P)))\n       then\n+         --  Ada 0Y (AI-262): Install the private declarations of P\n+\n+         if Private_Present (N)\n+           and then not In_Private_Part (P)\n+         then\n+            declare\n+               Id : Entity_Id;\n+            begin\n+               Id := First_Private_Entity (P);\n+\n+               while Present (Id) loop\n+                  if not Is_Internal (Id)\n+                    and then not Is_Child_Unit (Id)\n+                  then\n+                     if not In_Chain (Id) then\n+                        Set_Homonym (Id, Current_Entity (Id));\n+                        Set_Current_Entity (Id);\n+                     end if;\n+\n+                     Set_Is_Immediately_Visible (Id);\n+                  end if;\n+\n+                  Next_Entity (Id);\n+               end loop;\n+\n+               Set_In_Private_Part (P);\n+            end;\n+         end if;\n+\n          return;\n       end if;\n \n@@ -3430,12 +3463,17 @@ package body Sem_Ch10 is\n \n       Set_Is_Immediately_Visible (P);\n \n-      --  Install each incomplete view\n+      --  Install each incomplete view. The first element of the limited view\n+      --  is a header (an E_Package entity) that is used to reference the first\n+      --  shadow entity in the private part of the package\n+\n+      Lim_Header := Limited_View (P);\n+      Lim_Typ    := First_Entity (Lim_Header);\n \n-      Lim_Elmt   := First_Elmt (Limited_Views (P));\n+      while Present (Lim_Typ) loop\n \n-      while Present (Lim_Elmt) loop\n-         Lim_Typ  := Node (Lim_Elmt);\n+         exit when not Private_Present (N)\n+                        and then Lim_Typ = First_Private_Entity (Lim_Header);\n \n          if not In_Chain (Lim_Typ) then\n             Set_Homonym (Lim_Typ, Current_Entity (Lim_Typ));\n@@ -3446,10 +3484,9 @@ package body Sem_Ch10 is\n                Write_Name (Chars (Lim_Typ));\n                Write_Eol;\n             end if;\n-\n          end if;\n \n-         Next_Elmt (Lim_Elmt);\n+         Next_Entity (Lim_Typ);\n       end loop;\n \n       --  The context clause has installed a limited-view, mark it\n@@ -3643,9 +3680,13 @@ package body Sem_Ch10 is\n       Unum : constant Unit_Number_Type := Get_Source_Unit (Library_Unit (N));\n       P    : constant Entity_Id        := Cunit_Entity (Unum);\n \n-      Spec        : Node_Id;         --  To denote a package specification\n-      Lim_Typ     : Entity_Id;       --  To denote shadow entities.\n-      Comp_Typ    : Entity_Id;       --  To denote real entities.\n+      Spec        : Node_Id;            --  To denote a package specification\n+      Lim_Typ     : Entity_Id;          --  To denote shadow entities\n+      Comp_Typ    : Entity_Id;          --  To denote real entities\n+\n+      Lim_Header  : Entity_Id;          --  Package entity\n+      Last_Lim_E  : Entity_Id := Empty; --  Last limited entity built\n+      Last_Pub_Lim_E : Entity_Id;       --  To set the first private entity\n \n       procedure Decorate_Incomplete_Type\n         (E    : Entity_Id;\n@@ -3665,16 +3706,18 @@ package body Sem_Ch10 is\n       --  Set basic attributes of tagged type T, including its class_wide type.\n       --  The parameters Loc, Scope are used to decorate the class_wide type.\n \n-      procedure Build_Chain (Spec : Node_Id; Scope : Entity_Id);\n+      procedure Build_Chain\n+        (Scope      : Entity_Id;\n+         First_Decl : Node_Id);\n       --  Construct list of shadow entities and attach it to entity of\n       --  package that is mentioned in a limited_with clause.\n \n       function New_Internal_Shadow_Entity\n         (Kind       : Entity_Kind;\n          Sloc_Value : Source_Ptr;\n          Id_Char    : Character) return Entity_Id;\n-      --  This function is similar to New_Internal_Entity, except that the\n-      --  entity is not added to the scope's list of entities.\n+      --  Build a new internal entity and append it to the list of shadow\n+      --  entities available through the limited-header\n \n       ------------------------------\n       -- Decorate_Incomplete_Type --\n@@ -3685,13 +3728,13 @@ package body Sem_Ch10 is\n          Scop : Entity_Id)\n       is\n       begin\n-         Set_Ekind                     (E, E_Incomplete_Type);\n-         Set_Scope                     (E, Scop);\n-         Set_Etype                     (E, E);\n-         Set_Is_First_Subtype          (E, True);\n-         Set_Stored_Constraint         (E, No_Elist);\n-         Set_Full_View                 (E, Empty);\n-         Init_Size_Align               (E);\n+         Set_Ekind             (E, E_Incomplete_Type);\n+         Set_Scope             (E, Scop);\n+         Set_Etype             (E, E);\n+         Set_Is_First_Subtype  (E, True);\n+         Set_Stored_Constraint (E, No_Elist);\n+         Set_Full_View         (E, Empty);\n+         Init_Size_Align       (E);\n       end Decorate_Incomplete_Type;\n \n       --------------------------\n@@ -3725,7 +3768,7 @@ package body Sem_Ch10 is\n             Set_Equivalent_Type           (CW, Empty);\n             Set_From_With_Type            (CW, From_With_Type (T));\n \n-            Set_Class_Wide_Type (T, CW);\n+            Set_Class_Wide_Type           (T, CW);\n          end if;\n       end Decorate_Tagged_Type;\n \n@@ -3750,36 +3793,54 @@ package body Sem_Ch10 is\n          Sloc_Value : Source_Ptr;\n          Id_Char    : Character) return Entity_Id\n       is\n-         N : constant Entity_Id :=\n+         E : constant Entity_Id :=\n                Make_Defining_Identifier (Sloc_Value,\n                  Chars => New_Internal_Name (Id_Char));\n \n       begin\n-         Set_Ekind          (N, Kind);\n-         Set_Is_Internal    (N, True);\n+         Set_Ekind       (E, Kind);\n+         Set_Is_Internal (E, True);\n \n          if Kind in Type_Kind then\n-            Init_Size_Align (N);\n+            Init_Size_Align (E);\n          end if;\n \n-         return N;\n+         Append_Entity (E, Lim_Header);\n+         Last_Lim_E := E;\n+         return E;\n       end New_Internal_Shadow_Entity;\n \n       -----------------\n       -- Build_Chain --\n       -----------------\n \n-      --  Could use more comments below ???\n-\n-      procedure Build_Chain (Spec : Node_Id; Scope : Entity_Id) is\n+      procedure Build_Chain\n+        (Scope         : Entity_Id;\n+         First_Decl    : Node_Id)\n+      is\n          Analyzed_Unit : constant Boolean := Analyzed (Cunit (Unum));\n          Is_Tagged     : Boolean;\n          Decl          : Node_Id;\n \n       begin\n-         Decl := First (Visible_Declarations (Spec));\n+         Decl := First_Decl;\n \n          while Present (Decl) loop\n+\n+            --  For each library_package_declaration in the environment, there\n+            --  is an implicit declaration of a *limited view* of that library\n+            --  package. The limited view of a package contains:\n+            --\n+            --   * For each nested package_declaration, a declaration of the\n+            --     limited view of that package, with the same defining-\n+            --     program-unit name.\n+            --\n+            --   * For each type_declaration in the visible part, an incomplete\n+            --     type-declaration with the same defining_identifier, whose\n+            --     completion is the type_declaration. If the type_declaration\n+            --     is tagged, then the incomplete_type_declaration is tagged\n+            --     incomplete.\n+\n             if Nkind (Decl) = N_Full_Type_Declaration then\n                Is_Tagged :=\n                   Nkind (Type_Definition (Decl)) = N_Record_Definition\n@@ -3797,7 +3858,7 @@ package body Sem_Ch10 is\n \n                --  Create shadow entity for type\n \n-               Lim_Typ  := New_Internal_Shadow_Entity\n+               Lim_Typ := New_Internal_Shadow_Entity\n                  (Kind       => Ekind (Comp_Typ),\n                   Sloc_Value => Sloc (Comp_Typ),\n                   Id_Char    => 'Z');\n@@ -3813,7 +3874,6 @@ package body Sem_Ch10 is\n                end if;\n \n                Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n-               Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n \n             elsif Nkind (Decl) = N_Private_Type_Declaration\n               and then Tagged_Present (Decl)\n@@ -3836,7 +3896,6 @@ package body Sem_Ch10 is\n                Decorate_Tagged_Type (Sloc (Decl), Lim_Typ, Scope);\n \n                Set_Non_Limited_View (Lim_Typ, Comp_Typ);\n-               Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n \n             elsif Nkind (Decl) = N_Package_Declaration then\n \n@@ -3868,9 +3927,9 @@ package body Sem_Ch10 is\n                   --  Note: The non_limited_view attribute is not used\n                   --  for local packages.\n \n-                  Append_Elmt (Lim_Typ,  To => Limited_Views (P));\n-\n-                  Build_Chain (Spec, Scope => Lim_Typ);\n+                  Build_Chain\n+                    (Scope      => Lim_Typ,\n+                     First_Decl => First (Visible_Declarations (Spec)));\n                end;\n             end if;\n \n@@ -3931,12 +3990,41 @@ package body Sem_Ch10 is\n       end if;\n \n       Set_Ekind (P, E_Package);\n-      Set_Limited_Views     (P, New_Elmt_List);\n-      --  Set_Entity (Name (N), P);\n \n-      --  Create the auxiliary chain\n+      --  Build the header of the limited_view\n+\n+      Lim_Header := Make_Defining_Identifier (Sloc (N),\n+                      Chars => New_Internal_Name (Id_Char => 'Z'));\n+      Set_Ekind (Lim_Header, E_Package);\n+      Set_Is_Internal (Lim_Header);\n+      Set_Limited_View (P, Lim_Header);\n+\n+      --  Create the auxiliary chain. All the shadow entities are appended\n+      --  to the list of entities of the limited-view header\n+\n+      Build_Chain\n+        (Scope      => P,\n+         First_Decl => First (Visible_Declarations (Spec)));\n+\n+      --  Save the last built shadow entity. It is needed later to set the\n+      --  reference to the first shadow entity in the private part\n+\n+      Last_Pub_Lim_E := Last_Lim_E;\n+\n+      --  Ada 0Y (AI-262): Add the limited view of the private declarations\n+      --  Required to give support to limited-private-with clauses\n+\n+      Build_Chain (Scope      => P,\n+                   First_Decl => First (Private_Declarations (Spec)));\n+\n+      if Last_Pub_Lim_E /= Empty then\n+         Set_First_Private_Entity (Lim_Header,\n+                                   Next_Entity (Last_Pub_Lim_E));\n+      else\n+         Set_First_Private_Entity (Lim_Header,\n+                                   First_Entity (P));\n+      end if;\n \n-      Build_Chain (Spec, Scope => P);\n       Set_Limited_View_Installed (Spec);\n    end Build_Limited_Views;\n \n@@ -4065,7 +4153,7 @@ package body Sem_Ch10 is\n       Unit_Name : Entity_Id;\n \n    begin\n-      --  Ada0Y (AI-50217): We remove the context clauses in two phases:\n+      --  Ada 0Y (AI-50217): We remove the context clauses in two phases:\n       --  limited-views first and regular-views later (to maintain the\n       --  stack model).\n \n@@ -4082,7 +4170,6 @@ package body Sem_Ch10 is\n            and then Limited_View_Installed (Item)\n          then\n             Remove_Limited_With_Clause (Item);\n-\n          end if;\n \n          Next (Item);\n@@ -4131,10 +4218,9 @@ package body Sem_Ch10 is\n    --------------------------------\n \n    procedure Remove_Limited_With_Clause (N : Node_Id) is\n-      P_Unit    : constant Entity_Id := Unit (Library_Unit (N));\n-      P         : Entity_Id := Defining_Unit_Name (Specification (P_Unit));\n-      Lim_Elmt  : Elmt_Id;\n-      Lim_Typ   : Entity_Id;\n+      P_Unit     : constant Entity_Id := Unit (Library_Unit (N));\n+      P          : Entity_Id := Defining_Unit_Name (Specification (P_Unit));\n+      Lim_Typ    : Entity_Id;\n \n    begin\n       if Nkind (P) = N_Defining_Program_Unit_Name then\n@@ -4151,15 +4237,15 @@ package body Sem_Ch10 is\n          Write_Eol;\n       end if;\n \n-      --  Remove all shadow entities from visibility\n-\n-      Lim_Elmt  := First_Elmt (Limited_Views (P));\n+      --  Remove all shadow entities from visibility. The first element of the\n+      --  limited view is a header (an E_Package entity) that is used to\n+      --  reference the first shadow entity in the private part of the package\n \n-      while Present (Lim_Elmt) loop\n-         Lim_Typ  := Node (Lim_Elmt);\n+      Lim_Typ    := First_Entity (Limited_View (P));\n \n+      while Present (Lim_Typ) loop\n          Unchain (Lim_Typ);\n-         Next_Elmt (Lim_Elmt);\n+         Next_Entity (Lim_Typ);\n       end loop;\n \n       --  Indicate that the limited view of the package is not installed\n@@ -4205,7 +4291,6 @@ package body Sem_Ch10 is\n                      Write_Name (Chars (Ent));\n                      Write_Eol;\n                   end if;\n-\n                end if;\n \n                Next_Entity (Ent);"}, {"sha": "109c05b7adadb84dc72b7c42a9dc0de028f24e67", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -2980,7 +2980,7 @@ package body Sem_Ch3 is\n          --  types the level of accessibility depends on the enclosing type\n          --  declaration\n \n-         Set_Scope (Element_Type, T); --  Ada 0Y (AI-230)\n+         Set_Scope (Element_Type, Current_Scope); --  Ada 0Y (AI-230)\n \n          --  Ada 0Y (AI-254)\n "}, {"sha": "69cc4d097f5bab4338ce5ed2f7d2cbba73a60ecc", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -796,6 +796,7 @@ package body Sem_Ch6 is\n \n       procedure Check_Following_Pragma is\n          Prag : Node_Id;\n+\n       begin\n          if Front_End_Inlining\n            and then Is_List_Member (N)\n@@ -817,6 +818,8 @@ package body Sem_Ch6 is\n          end if;\n       end Check_Following_Pragma;\n \n+   --  Start of processing for Analyze_Subprogram_Body\n+\n    begin\n       if Debug_Flag_C then\n          Write_Str (\"====  Compiling subprogram body \");"}, {"sha": "2ec768d37165add69f32fb9e352418622a94fe81", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -696,8 +696,10 @@ package body Sem_Ch8 is\n \n          Analyze_And_Resolve (Nam, T);\n \n-         --  Ada 0Y (AI-230): Renaming of anonymous access-to-constant types\n-         --  allowed if and only if the renamed object is access-to-constant\n+         --  Ada 0Y (AI-231): \"In the case where the type is defined by an\n+         --  access_definition, the renamed entity shall be of an access-to-\n+         --  constant type if and only if the access_definition defines an\n+         --  access-to-constant type\" ARM 8.5.1(4)\n \n          if Constant_Present (Access_Definition (N))\n            and then not Is_Access_Constant (Etype (Nam))\n@@ -3525,7 +3527,8 @@ package body Sem_Ch8 is\n         and then From_With_Type (P_Name)\n       then\n          if From_With_Type (Id)\n-           or else (Ekind (Id) = E_Package and then From_With_Type (Id))\n+           or else Is_Type (Id)\n+           or else Ekind (Id) = E_Package\n          then\n             null;\n          else"}, {"sha": "d3ee90e982fec8924d4cf47d05ee1eefd5034524", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -3257,17 +3257,17 @@ package body Sem_Prag is\n          Val   : Uint;\n \n          procedure Set_Warning (R : All_Restrictions);\n-         --  If this is a Restriction_Warnings pragma, set warning flag\n+         --  If this is a Restriction_Warnings pragma, set warning flag,\n+         --  otherwise flag gets cleared.\n \n          -----------------\n          -- Set_Warning --\n          -----------------\n \n          procedure Set_Warning (R : All_Restrictions) is\n          begin\n-            if Prag_Id = Pragma_Restriction_Warnings then\n-               Restriction_Warnings (R) := True;\n-            end if;\n+            Restriction_Warnings (R) :=\n+              Prag_Id = Pragma_Restriction_Warnings;\n          end Set_Warning;\n \n       --  Start of processing for Process_Restrictions_Or_Restriction_Warnings"}, {"sha": "b32d4a63f874b85eb32f8ec7312ca264d31c6246", "filename": "gcc/ada/trans.c", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333/gcc%2Fada%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftrans.c?ref=0fb2ea01912a8a8859cb53caa6a7e33b9b8c9333", "patch": "@@ -273,7 +273,7 @@ gnat_to_gnu (Node_Id gnat_node)\n {\n   tree gnu_root;\n   bool made_sequence = false;\n-    \n+\n   /* We support the use of this on statements now as a transition\n      to full function-at-a-time processing.  So we need to see if anything\n      we do generates RTL and returns error_mark_node.  */\n@@ -517,14 +517,32 @@ tree_transform (Node_Id gnat_node)\n \t\t  && DECL_BY_COMPONENT_PTR_P (gnu_result))))\n \t{\n \t  int ro = DECL_POINTS_TO_READONLY_P (gnu_result);\n+\t  tree initial;\n \n \t  if (TREE_CODE (gnu_result) == PARM_DECL\n \t      && DECL_BY_COMPONENT_PTR_P (gnu_result))\n \t    gnu_result = convert (build_pointer_type (gnu_result_type),\n \t\t\t\t  gnu_result);\n \n-\t  gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n-\t\t\t\t       fold (gnu_result));\n+\t  /* If the object is constant, we try to do the dereference directly\n+\t     through the DECL_INITIAL.  This is actually required in order to\n+\t     get correct aliasing information for renamed objects that are\n+\t     components of non-aliased aggregates, because the type of\n+\t     the renamed object and that of the aggregate don't alias.  */\n+\t  if (TREE_READONLY (gnu_result)\n+\t      && DECL_INITIAL (gnu_result)\n+\t      /* Strip possible conversion to reference type.  */\n+\t      && (initial = TREE_CODE (DECL_INITIAL (gnu_result)) == NOP_EXPR\n+\t\t\t    ? TREE_OPERAND (DECL_INITIAL (gnu_result), 0)\n+\t\t\t    : DECL_INITIAL (gnu_result), 1)\n+\t      && TREE_CODE (initial) == ADDR_EXPR\n+\t      && (TREE_CODE (TREE_OPERAND (initial, 0)) == ARRAY_REF\n+\t\t  || TREE_CODE (TREE_OPERAND (initial, 0)) == COMPONENT_REF))\n+\t    gnu_result = TREE_OPERAND (initial, 0);\n+\t  else\n+\t    gnu_result = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\t \t fold (gnu_result));\n+\n \t  TREE_READONLY (gnu_result) = TREE_STATIC (gnu_result) = ro;\n \t}\n \n@@ -4373,7 +4391,7 @@ end_block_stmt ()\n \n   return gnu_retval;\n }\n-   \n+\n /* Build a BLOCK_STMT from GNAT_LIST, a possibly-empty list of statements.  */\n \n static tree\n@@ -4394,7 +4412,7 @@ build_block_stmt (List_Id gnat_list)\n \n   gnu_result = end_block_stmt ();\n   return TREE_CODE (gnu_result) == NULL_STMT ? NULL_TREE : gnu_result;\n-} \n+}\n \n /* Build an EXPR_STMT to evaluate INSNS.  Use Sloc from GNAT_NODE.   */\n \n@@ -4523,7 +4541,7 @@ gnat_expand_stmt (tree gnu_stmt)\n \t  }\n       break;\n \n-    default: \n+    default:\n      abort ();\n     }\n }"}]}