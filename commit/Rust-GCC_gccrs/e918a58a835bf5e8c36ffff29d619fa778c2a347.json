{"sha": "e918a58a835bf5e8c36ffff29d619fa778c2a347", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTkxOGE1OGE4MzViZjVlOGMzNmZmZmYyOWQ2MTlmYTc3OGMyYTM0Nw==", "commit": {"author": {"name": "Rafael Avila de Espindola", "email": "espindola@google.com", "date": "2008-03-04T22:20:34Z"}, "committer": {"name": "Rafael Espindola", "email": "espindola@gcc.gnu.org", "date": "2008-03-04T22:20:34Z"}, "message": "fold-const.c (tree_simple_nonnegative_warnv_p): New.\n\n2008-03-04  Rafael Espindola  <espindola@google.com>\n\n        * fold-const.c (tree_simple_nonnegative_warnv_p): New.\n        (tree_unary_nonnegative_warnv_p): New.\n        (tree_binary_nonnegative_warnv_p): New.\n        (tree_single_nonnegative_warnv_p): New.\n        (tree_invalid_nonnegative_warnv_p): New.\n        (tree_expr_nonnegative_warnv_p): Redefine in term of the new functions.\n\nFrom-SVN: r132875", "tree": {"sha": "16846c4822ad2ee58f97b4349a12af73fde815d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16846c4822ad2ee58f97b4349a12af73fde815d9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e918a58a835bf5e8c36ffff29d619fa778c2a347", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e918a58a835bf5e8c36ffff29d619fa778c2a347", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e918a58a835bf5e8c36ffff29d619fa778c2a347", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e918a58a835bf5e8c36ffff29d619fa778c2a347/comments", "author": null, "committer": null, "parents": [{"sha": "2925e1c8ad156081706df4a2447fb74af08c8a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2925e1c8ad156081706df4a2447fb74af08c8a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2925e1c8ad156081706df4a2447fb74af08c8a22"}], "stats": {"total": 341, "additions": 247, "deletions": 94}, "files": [{"sha": "a536011f8170e1aac7e95fa6be44abb52384d7fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e918a58a835bf5e8c36ffff29d619fa778c2a347/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e918a58a835bf5e8c36ffff29d619fa778c2a347/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e918a58a835bf5e8c36ffff29d619fa778c2a347", "patch": "@@ -1,3 +1,12 @@\n+2008-03-04  Rafael Espindola  <espindola@google.com>\n+\n+\t* fold-const.c (tree_simple_nonnegative_warnv_p): New.\n+\t(tree_unary_nonnegative_warnv_p): New.\n+\t(tree_binary_nonnegative_warnv_p): New.\n+\t(tree_single_nonnegative_warnv_p): New.\n+\t(tree_invalid_nonnegative_warnv_p): New.\n+\t(tree_expr_nonnegative_warnv_p): Redefine in term of the new functions.\n+\n 2008-03-04  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR 28322"}, {"sha": "e32a737f2929e7b58201ce1017170fe47645ff79", "filename": "gcc/fold-const.c", "status": "modified", "additions": 238, "deletions": 94, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e918a58a835bf5e8c36ffff29d619fa778c2a347/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e918a58a835bf5e8c36ffff29d619fa778c2a347/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=e918a58a835bf5e8c36ffff29d619fa778c2a347", "patch": "@@ -14043,106 +14043,161 @@ multiple_of_p (tree type, const_tree top, const_tree bottom)\n     }\n }\n \n-/* Return true if `t' is known to be non-negative.  If the return\n+/* Return true if CODE or TYPE is known to be non-negative. */\n+\n+static bool\n+tree_simple_nonnegative_warnv_p (enum tree_code code, tree type)\n+{\n+  if ((TYPE_PRECISION (type) != 1 || TYPE_UNSIGNED (type))\n+      && truth_value_p (code))\n+    /* Truth values evaluate to 0 or 1, which is nonnegative unless we\n+       have a signed:1 type (where the value is -1 and 0).  */\n+    return true;\n+  return false;\n+}\n+\n+/* Return true if (CODE OP0) is known to be non-negative.  If the return\n    value is based on the assumption that signed overflow is undefined,\n    set *STRICT_OVERFLOW_P to true; otherwise, don't change\n    *STRICT_OVERFLOW_P.  */\n \n-bool\n-tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+static bool\n+tree_unary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n+\t\t\t\tbool *strict_overflow_p)\n {\n-  if (t == error_mark_node)\n-    return false;\n-\n-  if (TYPE_UNSIGNED (TREE_TYPE (t)))\n+  if (TYPE_UNSIGNED (type))\n     return true;\n \n-  switch (TREE_CODE (t))\n+  switch (code)\n     {\n-    case SSA_NAME:\n-      /* Query VRP to see if it has recorded any information about\n-\t the range of this object.  */\n-      return ssa_name_nonnegative_p (t);\n-\n     case ABS_EXPR:\n       /* We can't return 1 if flag_wrapv is set because\n \t ABS_EXPR<INT_MIN> = INT_MIN.  */\n-      if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n+      if (!INTEGRAL_TYPE_P (type))\n \treturn true;\n-      if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n+      if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n \t  *strict_overflow_p = true;\n \t  return true;\n \t}\n       break;\n \n-    case INTEGER_CST:\n-      return tree_int_cst_sgn (t) >= 0;\n+    case NON_LVALUE_EXPR:\n+    case FLOAT_EXPR:\n+    case FIX_TRUNC_EXPR:\n+      return tree_expr_nonnegative_warnv_p (op0,\n+\t\t\t\t\t    strict_overflow_p);\n \n-    case REAL_CST:\n-      return ! REAL_VALUE_NEGATIVE (TREE_REAL_CST (t));\n+    case NOP_EXPR:\n+      {\n+\ttree inner_type = TREE_TYPE (op0);\n+\ttree outer_type = type;\n \n-    case FIXED_CST:\n-      return ! FIXED_VALUE_NEGATIVE (TREE_FIXED_CST (t));\n+\tif (TREE_CODE (outer_type) == REAL_TYPE)\n+\t  {\n+\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n+\t      return tree_expr_nonnegative_warnv_p (op0,\n+\t\t\t\t\t\t    strict_overflow_p);\n+\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n+\t      {\n+\t\tif (TYPE_UNSIGNED (inner_type))\n+\t\t  return true;\n+\t\treturn tree_expr_nonnegative_warnv_p (op0,\n+\t\t\t\t\t\t      strict_overflow_p);\n+\t      }\n+\t  }\n+\telse if (TREE_CODE (outer_type) == INTEGER_TYPE)\n+\t  {\n+\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n+\t      return tree_expr_nonnegative_warnv_p (op0,\n+\t\t\t\t\t\t    strict_overflow_p);\n+\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n+\t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n+\t\t      && TYPE_UNSIGNED (inner_type);\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      return tree_simple_nonnegative_warnv_p (code, type);\n+    }\n+\n+  /* We don't know sign of `t', so be conservative and return false.  */\n+  return false;\n+}\n+\n+/* Return true if (CODE OP0 OP1) is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n+\n+static bool\n+tree_binary_nonnegative_warnv_p (enum tree_code code, tree type, tree op0,\n+\t\t\t\t      tree op1, bool *strict_overflow_p)\n+{\n+  if (TYPE_UNSIGNED (type))\n+    return true;\n \n+  switch (code)\n+    {\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (t)))\n-\treturn (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+      if (FLOAT_TYPE_P (type))\n+\treturn (tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t       strict_overflow_p)\n-\t\t&& tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t&& tree_expr_nonnegative_warnv_p (op1,\n \t\t\t\t\t\t  strict_overflow_p));\n \n       /* zero_extend(x) + zero_extend(y) is non-negative if x and y are\n \t both unsigned and at least 2 bits shorter than the result.  */\n-      if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (t, 1)) == NOP_EXPR)\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TREE_CODE (op0) == NOP_EXPR\n+\t  && TREE_CODE (op1) == NOP_EXPR)\n \t{\n-\t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n-\t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n+\t  tree inner1 = TREE_TYPE (TREE_OPERAND (op0, 0));\n+\t  tree inner2 = TREE_TYPE (TREE_OPERAND (op1, 0));\n \t  if (TREE_CODE (inner1) == INTEGER_TYPE && TYPE_UNSIGNED (inner1)\n \t      && TREE_CODE (inner2) == INTEGER_TYPE && TYPE_UNSIGNED (inner2))\n \t    {\n \t      unsigned int prec = MAX (TYPE_PRECISION (inner1),\n \t\t\t\t       TYPE_PRECISION (inner2)) + 1;\n-\t      return prec < TYPE_PRECISION (TREE_TYPE (t));\n+\t      return prec < TYPE_PRECISION (type);\n \t    }\n \t}\n       break;\n \n     case MULT_EXPR:\n-      if (FLOAT_TYPE_P (TREE_TYPE (t)))\n+      if (FLOAT_TYPE_P (type))\n \t{\n \t  /* x * x for floating point x is always non-negative.  */\n-\t  if (operand_equal_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1), 0))\n+\t  if (operand_equal_p (op0, op1, 0))\n \t    return true;\n-\t  return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t  return (tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t\t strict_overflow_p)\n-\t\t  && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t  && tree_expr_nonnegative_warnv_p (op1,\n \t\t\t\t\t\t    strict_overflow_p));\n \t}\n \n       /* zero_extend(x) * zero_extend(y) is non-negative if x and y are\n \t both unsigned and their total bits is shorter than the result.  */\n-      if (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t  && TREE_CODE (TREE_OPERAND (t, 0)) == NOP_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (t, 1)) == NOP_EXPR)\n+      if (TREE_CODE (type) == INTEGER_TYPE\n+\t  && TREE_CODE (op0) == NOP_EXPR\n+\t  && TREE_CODE (op1) == NOP_EXPR)\n \t{\n-\t  tree inner1 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 0), 0));\n-\t  tree inner2 = TREE_TYPE (TREE_OPERAND (TREE_OPERAND (t, 1), 0));\n+\t  tree inner1 = TREE_TYPE (TREE_OPERAND (op0, 0));\n+\t  tree inner2 = TREE_TYPE (TREE_OPERAND (op1, 0));\n \t  if (TREE_CODE (inner1) == INTEGER_TYPE && TYPE_UNSIGNED (inner1)\n \t      && TREE_CODE (inner2) == INTEGER_TYPE && TYPE_UNSIGNED (inner2))\n \t    return TYPE_PRECISION (inner1) + TYPE_PRECISION (inner2)\n-\t\t   < TYPE_PRECISION (TREE_TYPE (t));\n+\t\t   < TYPE_PRECISION (type);\n \t}\n       return false;\n \n     case BIT_AND_EXPR:\n     case MAX_EXPR:\n-      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+      return (tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t     strict_overflow_p)\n-\t      || tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t      || tree_expr_nonnegative_warnv_p (op1,\n \t\t\t\t\t\tstrict_overflow_p));\n \n     case BIT_IOR_EXPR:\n@@ -14153,68 +14208,80 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n-      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+      return (tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t     strict_overflow_p)\n-\t      && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t      && tree_expr_nonnegative_warnv_p (op1,\n \t\t\t\t\t\tstrict_overflow_p));\n \n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n     case ROUND_MOD_EXPR:\n-    case SAVE_EXPR:\n-    case NON_LVALUE_EXPR:\n-    case FLOAT_EXPR:\n-    case FIX_TRUNC_EXPR:\n-      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+      return tree_expr_nonnegative_warnv_p (op0,\n \t\t\t\t\t    strict_overflow_p);\n+    default:\n+      return tree_simple_nonnegative_warnv_p (code, type);\n+    }\n \n-    case COMPOUND_EXPR:\n-    case MODIFY_EXPR:\n-    case GIMPLE_MODIFY_STMT:\n-      return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n-\t\t\t\t\t    strict_overflow_p);\n+  /* We don't know sign of `t', so be conservative and return false.  */\n+  return false;\n+}\n \n-    case BIND_EXPR:\n-      return tree_expr_nonnegative_warnv_p (expr_last (TREE_OPERAND (t, 1)),\n-\t\t\t\t\t    strict_overflow_p);\n+/* Return true if T is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n+\n+static bool\n+tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  if (TYPE_UNSIGNED (TREE_TYPE (t)))\n+    return true;\n+\n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n+    case SSA_NAME:\n+      /* Query VRP to see if it has recorded any information about\n+\t the range of this object.  */\n+      return ssa_name_nonnegative_p (t);\n+\n+    case INTEGER_CST:\n+      return tree_int_cst_sgn (t) >= 0;\n+\n+    case REAL_CST:\n+      return ! REAL_VALUE_NEGATIVE (TREE_REAL_CST (t));\n+\n+    case FIXED_CST:\n+      return ! FIXED_VALUE_NEGATIVE (TREE_FIXED_CST (t));\n \n     case COND_EXPR:\n       return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n \t\t\t\t\t     strict_overflow_p)\n \t      && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 2),\n \t\t\t\t\t\tstrict_overflow_p));\n+    default:\n+      return tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t\t   TREE_TYPE (t));\n+    }\n+  /* We don't know sign of `t', so be conservative and return false.  */\n+  return false;\n+}\n \n-    case NOP_EXPR:\n-      {\n-\ttree inner_type = TREE_TYPE (TREE_OPERAND (t, 0));\n-\ttree outer_type = TREE_TYPE (t);\n+/* Return true if T is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n \n-\tif (TREE_CODE (outer_type) == REAL_TYPE)\n-\t  {\n-\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n-\t      {\n-\t\tif (TYPE_UNSIGNED (inner_type))\n-\t\t  return true;\n-\t\treturn tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n-\t\t\t\t\t\t      strict_overflow_p);\n-\t      }\n-\t  }\n-\telse if (TREE_CODE (outer_type) == INTEGER_TYPE)\n-\t  {\n-\t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t,0),\n-\t\t\t\t\t\t    strict_overflow_p);\n-\t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n-\t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n-\t\t      && TYPE_UNSIGNED (inner_type);\n-\t  }\n-      }\n-      break;\n+static bool\n+tree_invalid_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  if (TYPE_UNSIGNED (TREE_TYPE (t)))\n+    return true;\n \n+  enum tree_code code = TREE_CODE (t);\n+  switch (code)\n+    {\n     case TARGET_EXPR:\n       {\n \ttree temp = TARGET_EXPR_SLOT (t);\n@@ -14372,25 +14439,102 @@ tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n \t    default:\n \t      break;\n \t    }\n+\treturn tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t\t     TREE_TYPE (t));\n       }\n+      break;\n \n-      /* ... fall through ...  */\n+    case COMPOUND_EXPR:\n+    case MODIFY_EXPR:\n+    case GIMPLE_MODIFY_STMT:\n+      return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t\t\t    strict_overflow_p);\n+    case BIND_EXPR:\n+      return tree_expr_nonnegative_warnv_p (expr_last (TREE_OPERAND (t, 1)),\n+\t\t\t\t\t    strict_overflow_p);\n+    case SAVE_EXPR:\n+      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t    strict_overflow_p);\n \n     default:\n-      {\n-\ttree type = TREE_TYPE (t);\n-\tif ((TYPE_PRECISION (type) != 1 || TYPE_UNSIGNED (type))\n-\t    && truth_value_p (TREE_CODE (t)))\n-\t  /* Truth values evaluate to 0 or 1, which is nonnegative unless we\n-             have a signed:1 type (where the value is -1 and 0).  */\n-\t  return true;\n-      }\n+      return tree_simple_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t\t   TREE_TYPE (t));\n     }\n \n   /* We don't know sign of `t', so be conservative and return false.  */\n   return false;\n }\n \n+/* Return true if T is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n+\n+bool\n+tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n+{\n+  enum tree_code code;\n+  if (t == error_mark_node)\n+    return false;\n+\n+  code = TREE_CODE (t);\n+  switch (TREE_CODE_CLASS (code))\n+    {\n+    case tcc_binary:\n+    case tcc_comparison:\n+      return tree_binary_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t      TREE_TYPE (t),\n+\t\t\t\t\t      TREE_OPERAND (t, 0),\n+\t\t\t\t\t      TREE_OPERAND (t, 1),\n+\t\t\t\t\t      strict_overflow_p);\n+\n+    case tcc_unary:\n+      return tree_unary_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t     TREE_TYPE (t),\n+\t\t\t\t\t     TREE_OPERAND (t, 0),\n+\t\t\t\t\t     strict_overflow_p);\n+\n+    case tcc_constant:\n+    case tcc_declaration:\n+    case tcc_reference:\n+      return tree_single_nonnegative_warnv_p (t, strict_overflow_p);\n+\n+    default:\n+      break;\n+    }\n+\n+  switch (code)\n+    {\n+    case TRUTH_AND_EXPR:\n+    case TRUTH_OR_EXPR:\n+    case TRUTH_XOR_EXPR:\n+      return tree_binary_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t      TREE_TYPE (t),\n+\t\t\t\t\t      TREE_OPERAND (t, 0),\n+\t\t\t\t\t      TREE_OPERAND (t, 1),\n+\t\t\t\t\t      strict_overflow_p);\n+    case TRUTH_NOT_EXPR:\n+      return tree_unary_nonnegative_warnv_p (TREE_CODE (t),\n+\t\t\t\t\t     TREE_TYPE (t),\n+\t\t\t\t\t     TREE_OPERAND (t, 0),\n+\t\t\t\t\t     strict_overflow_p);\n+\n+    case COND_EXPR:\n+    case CONSTRUCTOR:\n+    case OBJ_TYPE_REF:\n+    case ASSERT_EXPR:\n+    case ADDR_EXPR:\n+    case WITH_SIZE_EXPR:\n+    case EXC_PTR_EXPR:\n+    case SSA_NAME:\n+    case FILTER_EXPR:\n+      return tree_single_nonnegative_warnv_p (t, strict_overflow_p);\n+\n+    default:\n+      return tree_invalid_nonnegative_warnv_p (t, strict_overflow_p);\n+    }\n+}\n+\n /* Return true if `t' is known to be non-negative.  Handle warnings\n    about undefined signed overflow.  */\n "}]}