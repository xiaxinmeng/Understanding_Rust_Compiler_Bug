{"sha": "cba079f354a55363916759f6f186f92c5616b98a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JhMDc5ZjM1NGE1NTM2MzkxNjc1OWY2ZjE4NmY5MmM1NjE2Yjk4YQ==", "commit": {"author": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T14:32:35Z"}, "committer": {"name": "Sandra Loosemore", "email": "sandra@codesourcery.com", "date": "2020-09-19T20:54:16Z"}, "message": "Move loop and switch tree data structures from cp/ to c-family/.\n\nThis patch moves the definitions for DO_STMT, FOR_STMT, WHILE_STMT,\nSWITCH_STMT, BREAK_STMT, and CONTINUE_STMT from the C++ front end to\nc-family.  This includes the genericizers, pretty-printers, and dump\nsupport as well as the tree definitions and accessors.  Some related\ncode for OMP_FOR and similar OMP constructs is also moved.\n\n2020-08-12  Sandra Loosemore  <sandra@codesourcery.com>\n\n\tgcc/c-family/\n\t* c-common.c (c_block_may_fallthrough): New, split from\n\tcxx_block_may_fallthrough in the cp front end.\n\t(c_common_init_ts): Move handling of loop and switch-related\n\tstatements here from the cp front end.\n\t* c-common.def (FOR_STMT, WHILE_STMT, DO_STMT): Move here from\n\tcp front end.\n\t(BREAK_STMT, CONTINUE_STMT, SWITCH_STMT): Likewise.\n\t* c-common.h (c_block_may_fallthru): Declare.\n\t(bc_state_t): Move here from cp front end.\n\t(save_bc_state, restore_bc_state): Declare.\n\t(c_genericize_control_stmt): Declare.\n\t(WHILE_COND, WHILE_BODY): Likewise.\n\t(DO_COND, DO_BODY): Likewise.\n\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY, FOR_SCOPE): Likewise.\n\t(SWITCH_STMT_COND, SWITCH_STMT_BODY): Likewise.\n\t(SWITCH_STMT_TYPE, SWITCH_STMT_SCOPE): Likewise.\n\t(SWITCH_STMT_ALL_CASES_P, SWITCH_STMT_NO_BREAK_P): Likewise.\n\t(LABEL_DECL_BREAK, LABEL_DECL_CONTINUE): Likewise.\n\t* c-dump.c (dump_stmt): Copy from cp front end.\n\t(c_dump_tree): Move code to handle structured loop and switch\n\ttree nodes here from cp front end.\n\t* c-gimplify.c: Adjust includes.\n\t(enum bc_t, bc_label, begin_bc_block, finish_bc_block): Move from\n\tcp front end.\n\t(save_bc_state, restore_bc_state): New functions using old code\n\tfrom cp front end.\n\t(get_bc_label, expr_loc_or_loc): Move from cp front end.\n\t(genericize_c_loop): Move from cp front end.\n\t(genericize_for_stmt, genericize_while_stmt): Likewise.\n\t(genericize_do_stmt, genericize_switch_stmt): Likewise.\n\t(genericize_continue_stmt, genericize_break_stmt): Likewise.\n\t(genericize_omp_for_stmt): Likewise.\n\t(c_genericize_control_stmt): New function using code split from\n\tcp front end.\n\t(c_genericize_control_r): New.\n\t(c_genericize): Call walk_tree with c_genericize_control_r.\n\t* c-pretty-print.c (c_pretty_printer::statement): Move code to handle\n\tstructured loop and switch tree nodes here from cp front end.\n\n\tgcc/cp/\n\t* cp-gimplify.c (enum bc_t, bc_label): Move to c-family.\n\t(begin_bc_block, finish_bc_block, get_bc_label): Likewise.\n\t(genericize_cp_loop): Likewise.\n\t(genericize_for_stmt, genericize_while_stmt): Likewise.\n\t(genericize_do_stmt, genericize_switch_stmt): Likewise.\n\t(genericize_continue_stmt, genericize_break_stmt): Likewise.\n\t(genericize_omp_for_stmt): Likewise.\n\t(cp_genericize_r): Call c_genericize_control_stmt instead of\n\tabove functions directly.\n\t(cp_genericize): Call save_bc_state and restore_bc_state instead\n\tof manipulating bc_label directly.\n\t* cp-objcp-common.c (cxx_block_may_fallthru): Defer to\n\tc_block_may_fallthru instead of handling SWITCH_STMT here.\n\t(cp_common_init_ts): Move handling of loop and switch-related\n\tstatements to c-family.\n\t* cp-tree.def (FOR_STMT, WHILE_STMT, DO_STMT): Move to c-family.\n\t(BREAK_STMT, CONTINUE_STMT, SWITCH_STMT): Likewise.\n\t* cp-tree.h (LABEL_DECL_BREAK, LABEL_DECL_CONTINUE): Likewise.\n\t(WHILE_COND, WHILE_BODY): Likewise.\n\t(DO_COND, DO_BODY): Likewise.\n\t(FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY, FOR_SCOPE): Likewise.\n\t(SWITCH_STMT_COND, SWITCH_STMT_BODY): Likewise.\n\t(SWITCH_STMT_TYPE, SWITCH_STMT_SCOPE): Likewise.\n\t(SWITCH_STMT_ALL_CASES_P, SWITCH_STMT_NO_BREAK_P): Likewise.\n\t* cxx-pretty-print.c (cxx_pretty_printer::statement): Move code\n\tto handle structured loop and switch tree nodes to c-family.\n\t* dump.c (cp_dump_tree): Likewise.\n\n\tgcc/\n\t* doc/generic.texi (Basic Statements): Document SWITCH_EXPR here,\n\tnot SWITCH_STMT.\n\t(Statements for C and C++): Rename node to reflect what\n\tthe introduction already says about sharing between C and C++\n\tfront ends.  Copy-edit and correct documentation for structured\n\tloops and switch.", "tree": {"sha": "a797afe19b592943e8baf602824a39e261a94a5d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a797afe19b592943e8baf602824a39e261a94a5d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cba079f354a55363916759f6f186f92c5616b98a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba079f354a55363916759f6f186f92c5616b98a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba079f354a55363916759f6f186f92c5616b98a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba079f354a55363916759f6f186f92c5616b98a/comments", "author": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SandraLoosemore", "id": 104087111, "node_id": "U_kgDOBjQ-Rw", "avatar_url": "https://avatars.githubusercontent.com/u/104087111?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SandraLoosemore", "html_url": "https://github.com/SandraLoosemore", "followers_url": "https://api.github.com/users/SandraLoosemore/followers", "following_url": "https://api.github.com/users/SandraLoosemore/following{/other_user}", "gists_url": "https://api.github.com/users/SandraLoosemore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SandraLoosemore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SandraLoosemore/subscriptions", "organizations_url": "https://api.github.com/users/SandraLoosemore/orgs", "repos_url": "https://api.github.com/users/SandraLoosemore/repos", "events_url": "https://api.github.com/users/SandraLoosemore/events{/privacy}", "received_events_url": "https://api.github.com/users/SandraLoosemore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7d2d4be7650acceb9d39327e21ee04f640c152f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7d2d4be7650acceb9d39327e21ee04f640c152f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7d2d4be7650acceb9d39327e21ee04f640c152f"}], "stats": {"total": 1349, "additions": 751, "deletions": 598}, "files": [{"sha": "e16ca3894bc70022274712b3d9aad50635662211", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -5007,6 +5007,24 @@ c_switch_covers_all_cases_p (splay_tree cases, tree type)\n   return true;\n }\n \n+/* Return true if stmt can fall through.  Used by block_may_fallthru\n+   default case.  */\n+\n+bool\n+c_block_may_fallthru (const_tree stmt)\n+{\n+  switch (TREE_CODE (stmt))\n+    {\n+    case SWITCH_STMT:\n+      return (!SWITCH_STMT_ALL_CASES_P (stmt)\n+\t      || !SWITCH_STMT_NO_BREAK_P (stmt)\n+\t      || block_may_fallthru (SWITCH_STMT_BODY (stmt)));\n+\n+    default:\n+      return true;\n+    }\n+}\n+\n /* Finish an expression taking the address of LABEL (an\n    IDENTIFIER_NODE).  Returns an expression for the address.\n \n@@ -8126,6 +8144,12 @@ c_common_init_ts (void)\n   MARK_TS_EXP (SIZEOF_EXPR);\n   MARK_TS_EXP (C_MAYBE_CONST_EXPR);\n   MARK_TS_EXP (EXCESS_PRECISION_EXPR);\n+  MARK_TS_EXP (BREAK_STMT);\n+  MARK_TS_EXP (CONTINUE_STMT);\n+  MARK_TS_EXP (DO_STMT);\n+  MARK_TS_EXP (FOR_STMT);\n+  MARK_TS_EXP (SWITCH_STMT);\n+  MARK_TS_EXP (WHILE_STMT);\n }\n \n /* Build a user-defined numeric literal out of an integer constant type VALUE"}, {"sha": "1954bfe1f808f92342d5dc6940cb9cc0cf8758d5", "filename": "gcc/c-family/c-common.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.def?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -55,6 +55,30 @@ DEFTREECODE (USERDEF_LITERAL, \"userdef_literal\", tcc_exceptional, 3)\n    or for the purpose of -Wsizeof-pointer-memaccess warning.  */\n DEFTREECODE (SIZEOF_EXPR, \"sizeof_expr\", tcc_expression, 1)\n \n+/* Used to represent a `for' statement. The operands are\n+   FOR_INIT_STMT, FOR_COND, FOR_EXPR, FOR_BODY, and FOR_SCOPE,\n+   respectively.  */\n+DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_statement, 5)\n+\n+/* Used to represent a 'while' statement. The operands are WHILE_COND\n+   and WHILE_BODY, respectively.  */\n+DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_statement, 2)\n+\n+/* Used to represent a 'do' statement. The operands are DO_COND and\n+   DO_BODY, respectively.  */\n+DEFTREECODE (DO_STMT, \"do_stmt\", tcc_statement, 2)\n+\n+/* Used to represent a 'break' statement.  */\n+DEFTREECODE (BREAK_STMT, \"break_stmt\", tcc_statement, 0)\n+\n+/* Used to represent a 'continue' statement.  */\n+DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", tcc_statement, 0)\n+\n+/* Used to represent a 'switch' statement. The operands are\n+   SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE, and\n+   SWITCH_STMT_SCOPE, respectively.  */\n+DEFTREECODE (SWITCH_STMT, \"switch_stmt\", tcc_statement, 4)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "6abfe4b1a312ef1edefcc7bf98145b4b810cae0f", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -1008,6 +1008,7 @@ extern int case_compare (splay_tree_key, splay_tree_key);\n \n extern tree c_add_case_label (location_t, splay_tree, tree, tree, tree);\n extern bool c_switch_covers_all_cases_p (splay_tree, tree);\n+extern bool c_block_may_fallthru (const_tree);\n \n extern tree build_function_call (location_t, tree, tree);\n \n@@ -1115,7 +1116,15 @@ class substring_loc;\n extern const char *c_get_substring_location (const substring_loc &substr_loc,\n \t\t\t\t\t     location_t *out_loc);\n \n-/* In c-gimplify.c  */\n+/* In c-gimplify.c.  */\n+typedef struct bc_state\n+{\n+  tree bc_label[2];\n+} bc_state_t;\n+extern void save_bc_state (bc_state_t *);\n+extern void restore_bc_state (bc_state_t *);\n+extern tree c_genericize_control_stmt (tree *, int *, void *,\n+\t\t\t\t       walk_tree_fn, walk_tree_lh);\n extern void c_genericize (tree);\n extern int c_gimplify_expr (tree *, gimple_seq *, gimple_seq *);\n extern tree c_build_bind_expr (location_t, tree, tree);\n@@ -1279,6 +1288,48 @@ extern tree build_userdef_literal (tree suffix_id, tree value,\n \t\t\t\t   enum overflow_type overflow,\n \t\t\t\t   tree num_string);\n \n+\n+/* WHILE_STMT accessors. These give access to the condition of the\n+   while statement and the body of the while statement, respectively.  */\n+#define WHILE_COND(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n+#define WHILE_BODY(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n+\n+/* DO_STMT accessors. These give access to the condition of the do\n+   statement and the body of the do statement, respectively.  */\n+#define DO_COND(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n+#define DO_BODY(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n+\n+/* FOR_STMT accessors. These give access to the init statement,\n+   condition, update expression, and body of the for statement,\n+   respectively.  */\n+#define FOR_INIT_STMT(NODE)\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n+#define FOR_COND(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n+#define FOR_EXPR(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n+#define FOR_BODY(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n+#define FOR_SCOPE(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 4)\n+\n+#define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n+#define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n+#define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n+#define SWITCH_STMT_SCOPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 3)\n+/* True if there are case labels for all possible values of switch cond, either\n+   because there is a default: case label or because the case label ranges cover\n+   all values.  */\n+#define SWITCH_STMT_ALL_CASES_P(NODE) \\\n+  TREE_LANG_FLAG_0 (SWITCH_STMT_CHECK (NODE))\n+/* True if the body of a switch stmt contains no BREAK_STMTs.  */\n+#define SWITCH_STMT_NO_BREAK_P(NODE) \\\n+  TREE_LANG_FLAG_2 (SWITCH_STMT_CHECK (NODE))\n+\n+\n+/* Nonzero if NODE is the target for genericization of 'break' stmts.  */\n+#define LABEL_DECL_BREAK(NODE) \\\n+  DECL_LANG_FLAG_0 (LABEL_DECL_CHECK (NODE))\n+\n+/* Nonzero if NODE is the target for genericization of 'continue' stmts.  */\n+#define LABEL_DECL_CONTINUE(NODE) \\\n+  DECL_LANG_FLAG_1 (LABEL_DECL_CHECK (NODE))\n+\n extern bool convert_vector_to_array_for_subscript (location_t, tree *, tree);\n \n /* Possibe cases of scalar_to_vector conversion.  */"}, {"sha": "d3caacc87a1f732060fd5f5016ad46c9f2826f11", "filename": "gcc/c-family/c-dump.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-dump.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -26,6 +26,13 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Dump any C-specific tree codes and attributes of common codes.  */\n \n+static void\n+dump_stmt (dump_info_p di, const_tree t)\n+{\n+  if (EXPR_HAS_LOCATION (t))\n+    dump_int (di, \"line\", EXPR_LINENO (t));\n+}\n+\n bool\n c_dump_tree (void *dump_info, tree t)\n {\n@@ -42,6 +49,37 @@ c_dump_tree (void *dump_info, tree t)\n \tdump_string (di, \"bitfield\");\n       break;\n \n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      dump_stmt (di, t);\n+      break;\n+\n+    case DO_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"body\", DO_BODY (t));\n+      dump_child (\"cond\", DO_COND (t));\n+      break;\n+\n+    case FOR_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"init\", FOR_INIT_STMT (t));\n+      dump_child (\"cond\", FOR_COND (t));\n+      dump_child (\"expr\", FOR_EXPR (t));\n+      dump_child (\"body\", FOR_BODY (t));\n+      break;\n+\n+    case SWITCH_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", SWITCH_STMT_COND (t));\n+      dump_child (\"body\", SWITCH_STMT_BODY (t));\n+      break;\n+\n+    case WHILE_STMT:\n+      dump_stmt (di, t);\n+      dump_child (\"cond\", WHILE_COND (t));\n+      dump_child (\"body\", WHILE_BODY (t));\n+      break;\n+\n     default:\n       break;\n     }"}, {"sha": "db930fc5ee5aeb568e0d1ca03d667e59bed7c638", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 408, "deletions": 0, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"function.h\"\n #include \"basic-block.h\"\n #include \"tree.h\"\n+#include \"tree-iterator.h\"\n+#include \"predict.h\"\n #include \"gimple.h\"\n #include \"cgraph.h\"\n #include \"c-pretty-print.h\"\n@@ -107,6 +109,399 @@ ubsan_walk_array_refs_r (tree *tp, int *walk_subtrees, void *data)\n \n /* Gimplification of statement trees.  */\n \n+/* Local declarations.  */\n+\n+enum bc_t { bc_break = 0, bc_continue = 1 };\n+\n+/* Stack of labels which are targets for \"break\" or \"continue\",\n+   linked through TREE_CHAIN.  */\n+static tree bc_label[2];\n+\n+/* Begin a scope which can be exited by a break or continue statement.  BC\n+   indicates which.\n+\n+   Just creates a label with location LOCATION and pushes it into the current\n+   context.  */\n+\n+static tree\n+begin_bc_block (enum bc_t bc, location_t location)\n+{\n+  tree label = create_artificial_label (location);\n+  DECL_CHAIN (label) = bc_label[bc];\n+  bc_label[bc] = label;\n+  if (bc == bc_break)\n+    LABEL_DECL_BREAK (label) = true;\n+  else\n+    LABEL_DECL_CONTINUE (label) = true;\n+  return label;\n+}\n+\n+/* Finish a scope which can be exited by a break or continue statement.\n+   LABEL was returned from the most recent call to begin_bc_block.  BLOCK is\n+   an expression for the contents of the scope.\n+\n+   If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n+   BLOCK.  Otherwise, just forget the label.  */\n+\n+static void\n+finish_bc_block (tree *block, enum bc_t bc, tree label)\n+{\n+  gcc_assert (label == bc_label[bc]);\n+\n+  if (TREE_USED (label))\n+    append_to_statement_list (build1 (LABEL_EXPR, void_type_node, label),\n+\t\t\t      block);\n+\n+  bc_label[bc] = DECL_CHAIN (label);\n+  DECL_CHAIN (label) = NULL_TREE;\n+}\n+\n+/* Allow saving and restoring break/continue state.  */\n+\n+void\n+save_bc_state (bc_state_t *state)\n+{\n+  state->bc_label[bc_break] = bc_label[bc_break];\n+  state->bc_label[bc_continue] = bc_label[bc_continue];\n+  bc_label[bc_break] = NULL_TREE;\n+  bc_label[bc_continue] = NULL_TREE;\n+}\n+\n+void\n+restore_bc_state (bc_state_t *state)\n+{\n+  gcc_assert (bc_label[bc_break] == NULL);\n+  gcc_assert (bc_label[bc_continue] == NULL);\n+  bc_label[bc_break] = state->bc_label[bc_break];\n+  bc_label[bc_continue] = state->bc_label[bc_continue];\n+}\n+\n+/* Get the LABEL_EXPR to represent a break or continue statement\n+   in the current block scope.  BC indicates which.  */\n+\n+static tree\n+get_bc_label (enum bc_t bc)\n+{\n+  tree label = bc_label[bc];\n+  gcc_assert (label);\n+\n+  /* Mark the label used for finish_bc_block.  */\n+  TREE_USED (label) = 1;\n+  return label;\n+}\n+\n+/* Return the location from EXPR, or OR_LOC if the former is unknown.  */\n+\n+location_t\n+expr_loc_or_loc (const_tree expr, location_t or_loc)\n+{\n+  tree t = CONST_CAST_TREE (expr);\n+  location_t loc = UNKNOWN_LOCATION;\n+  if (t)\n+    loc = EXPR_LOCATION (t);\n+  if (loc == UNKNOWN_LOCATION)\n+    loc = or_loc;\n+  return loc;\n+}\n+\n+/* Build a generic representation of one of the C loop forms.  COND is the\n+   loop condition or NULL_TREE.  BODY is the (possibly compound) statement\n+   controlled by the loop.  INCR is the increment expression of a for-loop,\n+   or NULL_TREE.  COND_IS_FIRST indicates whether the condition is\n+   evaluated before the loop body as in while and for loops, or after the\n+   loop body as in do-while loops.  */\n+\n+static void\n+genericize_c_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n+\t\t   tree incr, bool cond_is_first, int *walk_subtrees,\n+\t\t   void *data, walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree blab, clab;\n+  tree exit = NULL;\n+  tree stmt_list = NULL;\n+  tree debug_begin = NULL;\n+\n+  protected_set_expr_location_if_unset (incr, start_locus);\n+\n+  walk_tree_1 (&cond, func, data, NULL, lh);\n+  walk_tree_1 (&incr, func, data, NULL, lh);\n+\n+  blab = begin_bc_block (bc_break, start_locus);\n+  clab = begin_bc_block (bc_continue, start_locus);\n+\n+  walk_tree_1 (&body, func, data, NULL, lh);\n+  *walk_subtrees = 0;\n+\n+  if (MAY_HAVE_DEBUG_MARKER_STMTS\n+      && (!cond || !integer_zerop (cond)))\n+    {\n+      debug_begin = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+      SET_EXPR_LOCATION (debug_begin, expr_loc_or_loc (cond, start_locus));\n+    }\n+\n+  if (cond && TREE_CODE (cond) != INTEGER_CST)\n+    {\n+      /* If COND is constant, don't bother building an exit.  If it's false,\n+\t we won't build a loop.  If it's true, any exits are in the body.  */\n+      location_t cloc = expr_loc_or_loc (cond, start_locus);\n+      exit = build1_loc (cloc, GOTO_EXPR, void_type_node,\n+\t\t\t get_bc_label (bc_break));\n+      exit = fold_build3_loc (cloc, COND_EXPR, void_type_node, cond,\n+\t\t\t      build_empty_stmt (cloc), exit);\n+    }\n+\n+  if (exit && cond_is_first)\n+    {\n+      append_to_statement_list (debug_begin, &stmt_list);\n+      debug_begin = NULL_TREE;\n+      append_to_statement_list (exit, &stmt_list);\n+    }\n+  append_to_statement_list (body, &stmt_list);\n+  finish_bc_block (&stmt_list, bc_continue, clab);\n+  if (incr)\n+    {\n+      if (MAY_HAVE_DEBUG_MARKER_STMTS)\n+\t{\n+\t  tree d = build0 (DEBUG_BEGIN_STMT, void_type_node);\n+\t  SET_EXPR_LOCATION (d, expr_loc_or_loc (incr, start_locus));\n+\t  append_to_statement_list (d, &stmt_list);\n+\t}\n+      append_to_statement_list (incr, &stmt_list);\n+    }\n+  append_to_statement_list (debug_begin, &stmt_list);\n+  if (exit && !cond_is_first)\n+    append_to_statement_list (exit, &stmt_list);\n+\n+  if (!stmt_list)\n+    stmt_list = build_empty_stmt (start_locus);\n+\n+  tree loop;\n+  if (cond && integer_zerop (cond))\n+    {\n+      if (cond_is_first)\n+\tloop = fold_build3_loc (start_locus, COND_EXPR,\n+\t\t\t\tvoid_type_node, cond, stmt_list,\n+\t\t\t\tbuild_empty_stmt (start_locus));\n+      else\n+\tloop = stmt_list;\n+    }\n+  else\n+    {\n+      location_t loc = start_locus;\n+      if (!cond || integer_nonzerop (cond))\n+\tloc = EXPR_LOCATION (expr_first (body));\n+      if (loc == UNKNOWN_LOCATION)\n+\tloc = start_locus;\n+      loop = build1_loc (loc, LOOP_EXPR, void_type_node, stmt_list);\n+    }\n+\n+  stmt_list = NULL;\n+  append_to_statement_list (loop, &stmt_list);\n+  finish_bc_block (&stmt_list, bc_break, blab);\n+  if (!stmt_list)\n+    stmt_list = build_empty_stmt (start_locus);\n+\n+  *stmt_p = stmt_list;\n+}\n+\n+/* Genericize a FOR_STMT node *STMT_P.  */\n+\n+static void\n+genericize_for_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t     walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+  tree expr = NULL;\n+  tree loop;\n+  tree init = FOR_INIT_STMT (stmt);\n+\n+  if (init)\n+    {\n+      walk_tree_1 (&init, func, data, NULL, lh);\n+      append_to_statement_list (init, &expr);\n+    }\n+\n+  genericize_c_loop (&loop, EXPR_LOCATION (stmt), FOR_COND (stmt),\n+\t\t     FOR_BODY (stmt), FOR_EXPR (stmt), 1, walk_subtrees,\n+\t\t     data, func, lh);\n+  append_to_statement_list (loop, &expr);\n+  if (expr == NULL_TREE)\n+    expr = loop;\n+  *stmt_p = expr;\n+}\n+\n+/* Genericize a WHILE_STMT node *STMT_P.  */\n+\n+static void\n+genericize_while_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t       walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+  genericize_c_loop (stmt_p, EXPR_LOCATION (stmt), WHILE_COND (stmt),\n+\t\t     WHILE_BODY (stmt), NULL_TREE, 1, walk_subtrees,\n+\t\t     data, func, lh);\n+}\n+\n+/* Genericize a DO_STMT node *STMT_P.  */\n+\n+static void\n+genericize_do_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t    walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+  genericize_c_loop (stmt_p, EXPR_LOCATION (stmt), DO_COND (stmt),\n+\t\t     DO_BODY (stmt), NULL_TREE, 0, walk_subtrees,\n+\t\t     data, func, lh);\n+}\n+\n+/* Genericize a SWITCH_STMT node *STMT_P by turning it into a SWITCH_EXPR.  */\n+\n+static void\n+genericize_switch_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t\twalk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+  tree break_block, body, cond, type;\n+  location_t stmt_locus = EXPR_LOCATION (stmt);\n+\n+  body = SWITCH_STMT_BODY (stmt);\n+  if (!body)\n+    body = build_empty_stmt (stmt_locus);\n+  cond = SWITCH_STMT_COND (stmt);\n+  type = SWITCH_STMT_TYPE (stmt);\n+\n+  walk_tree_1 (&cond, func, data, NULL, lh);\n+\n+  break_block = begin_bc_block (bc_break, stmt_locus);\n+\n+  walk_tree_1 (&body, func, data, NULL, lh);\n+  walk_tree_1 (&type, func, data, NULL, lh);\n+  *walk_subtrees = 0;\n+\n+  if (TREE_USED (break_block))\n+    SWITCH_BREAK_LABEL_P (break_block) = 1;\n+  finish_bc_block (&body, bc_break, break_block);\n+  *stmt_p = build2_loc (stmt_locus, SWITCH_EXPR, type, cond, body);\n+  SWITCH_ALL_CASES_P (*stmt_p) = SWITCH_STMT_ALL_CASES_P (stmt);\n+  gcc_checking_assert (!SWITCH_STMT_NO_BREAK_P (stmt)\n+\t\t       || !TREE_USED (break_block));\n+}\n+\n+/* Genericize a CONTINUE_STMT node *STMT_P.  */\n+\n+static void\n+genericize_continue_stmt (tree *stmt_p)\n+{\n+  tree stmt_list = NULL;\n+  tree pred = build_predict_expr (PRED_CONTINUE, NOT_TAKEN);\n+  tree label = get_bc_label (bc_continue);\n+  location_t location = EXPR_LOCATION (*stmt_p);\n+  tree jump = build1_loc (location, GOTO_EXPR, void_type_node, label);\n+  append_to_statement_list_force (pred, &stmt_list);\n+  append_to_statement_list (jump, &stmt_list);\n+  *stmt_p = stmt_list;\n+}\n+\n+/* Genericize a BREAK_STMT node *STMT_P.  */\n+\n+static void\n+genericize_break_stmt (tree *stmt_p)\n+{\n+  tree label = get_bc_label (bc_break);\n+  location_t location = EXPR_LOCATION (*stmt_p);\n+  *stmt_p = build1_loc (location, GOTO_EXPR, void_type_node, label);\n+}\n+\n+/* Genericize a OMP_FOR node *STMT_P.  */\n+\n+static void\n+genericize_omp_for_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t\t walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+  location_t locus = EXPR_LOCATION (stmt);\n+  tree clab = begin_bc_block (bc_continue, locus);\n+\n+  walk_tree_1 (&OMP_FOR_BODY (stmt), func, data, NULL, lh);\n+  if (TREE_CODE (stmt) != OMP_TASKLOOP)\n+    walk_tree_1 (&OMP_FOR_CLAUSES (stmt), func, data, NULL, lh);\n+  walk_tree_1 (&OMP_FOR_INIT (stmt), func, data, NULL, lh);\n+  walk_tree_1 (&OMP_FOR_COND (stmt), func, data, NULL, lh);\n+  walk_tree_1 (&OMP_FOR_INCR (stmt), func, data, NULL, lh);\n+  walk_tree_1 (&OMP_FOR_PRE_BODY (stmt), func, data, NULL, lh);\n+  *walk_subtrees = 0;\n+\n+  finish_bc_block (&OMP_FOR_BODY (stmt), bc_continue, clab);\n+}\n+\n+\n+/* Lower structured control flow tree nodes, such as loops.  The\n+   STMT_P, WALK_SUBTREES, and DATA arguments are as for the walk_tree_fn\n+   type.  FUNC and LH are language-specific functions passed to walk_tree_1\n+   for node visiting and traversal, respectively; they are used to do\n+   subtree processing in a language-dependent way.  */\n+\n+tree\n+c_genericize_control_stmt (tree *stmt_p, int *walk_subtrees, void *data,\n+\t\t\t   walk_tree_fn func, walk_tree_lh lh)\n+{\n+  tree stmt = *stmt_p;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case FOR_STMT:\n+      genericize_for_stmt (stmt_p, walk_subtrees, data, func, lh);\n+      break;\n+\n+    case WHILE_STMT:\n+      genericize_while_stmt (stmt_p, walk_subtrees, data, func, lh);\n+      break;\n+\n+    case DO_STMT:\n+      genericize_do_stmt (stmt_p, walk_subtrees, data, func, lh);\n+      break;\n+\n+    case SWITCH_STMT:\n+      genericize_switch_stmt (stmt_p, walk_subtrees, data, func, lh);\n+      break;\n+\n+    case CONTINUE_STMT:\n+      genericize_continue_stmt (stmt_p);\n+      break;\n+\n+    case BREAK_STMT:\n+      genericize_break_stmt (stmt_p);\n+      break;\n+\n+    case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_DISTRIBUTE:\n+    case OMP_LOOP:\n+    case OMP_TASKLOOP:\n+    case OACC_LOOP:\n+      genericize_omp_for_stmt (stmt_p, walk_subtrees, data, func, lh);\n+      break;\n+\n+    default:\n+      break;\n+    }\n+\n+  return NULL;\n+}\n+\n+\n+/* Wrapper for c_genericize_control_stmt to allow it to be used as a walk_tree\n+   callback.  This is appropriate for C; C++ calls c_genericize_control_stmt\n+   directly.  */\n+\n+static tree\n+c_genericize_control_r (tree *stmt_p, int *walk_subtrees, void *data)\n+{\n+  c_genericize_control_stmt (stmt_p, walk_subtrees, data,\n+\t\t\t     c_genericize_control_r, NULL);\n+  return NULL;\n+}\n+\n /* Convert the tree representation of FNDECL from C frontend trees to\n    GENERIC.  */\n \n@@ -128,6 +523,19 @@ c_genericize (tree fndecl)\n     walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n \t\t\t\t  do_warn_duplicated_branches_r, NULL);\n \n+  /* Genericize loops and other structured control constructs.  The C++\n+     front end has already done this in lang-specific code.  */\n+  if (!c_dialect_cxx ())\n+    {\n+      bc_state_t save_state;\n+      push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n+      save_bc_state (&save_state);\n+      walk_tree (&DECL_SAVED_TREE (fndecl), c_genericize_control_r,\n+\t\t NULL, NULL);\n+      restore_bc_state (&save_state);\n+      pop_cfun ();\n+    }\n+\n   /* Dump the C-specific tree IR.  */\n   dump_orig = get_dump_info (TDI_original, &local_dump_flags);\n   if (dump_orig)"}, {"sha": "c364e1c4a4dd7e93830f6cf7d0770a722c28491d", "filename": "gcc/c-family/c-pretty-print.c", "status": "modified", "additions": 87, "deletions": 5, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fc-family%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-pretty-print.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -2364,15 +2364,97 @@ c_pretty_printer::expression (tree e)\n /* Statements.  */\n \n void\n-c_pretty_printer::statement (tree stmt)\n+c_pretty_printer::statement (tree t)\n {\n-  if (stmt == NULL)\n+  if (t == NULL)\n     return;\n \n-  if (pp_needs_newline (this))\n-    pp_newline_and_indent (this, 0);\n+  switch (TREE_CODE (t))\n+    {\n+\n+    case SWITCH_STMT:\n+      pp_c_ws_string (this, \"switch\");\n+      pp_space (this);\n+      pp_c_left_paren (this);\n+      expression (SWITCH_STMT_COND (t));\n+      pp_c_right_paren (this);\n+      pp_indentation (this) += 3;\n+      pp_needs_newline (this) = true;\n+      statement (SWITCH_STMT_BODY (t));\n+      pp_newline_and_indent (this, -3);\n+      break;\n+\n+      /* iteration-statement:\n+\t    while ( expression ) statement\n+\t    do statement while ( expression ) ;\n+\t    for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n+\t    for ( declaration expression(opt) ; expression(opt) ) statement  */\n+    case WHILE_STMT:\n+      pp_c_ws_string (this, \"while\");\n+      pp_space (this);\n+      pp_c_left_paren (this);\n+      expression (WHILE_COND (t));\n+      pp_c_right_paren (this);\n+      pp_newline_and_indent (this, 3);\n+      statement (WHILE_BODY (t));\n+      pp_indentation (this) -= 3;\n+      pp_needs_newline (this) = true;\n+      break;\n+\n+    case DO_STMT:\n+      pp_c_ws_string (this, \"do\");\n+      pp_newline_and_indent (this, 3);\n+      statement (DO_BODY (t));\n+      pp_newline_and_indent (this, -3);\n+      pp_c_ws_string (this, \"while\");\n+      pp_space (this);\n+      pp_c_left_paren (this);\n+      expression (DO_COND (t));\n+      pp_c_right_paren (this);\n+      pp_c_semicolon (this);\n+      pp_needs_newline (this) = true;\n+      break;\n \n-  dump_generic_node (this, stmt, pp_indentation (this), TDF_NONE, true);\n+    case FOR_STMT:\n+      pp_c_ws_string (this, \"for\");\n+      pp_space (this);\n+      pp_c_left_paren (this);\n+      if (FOR_INIT_STMT (t))\n+\tstatement (FOR_INIT_STMT (t));\n+      else\n+\tpp_c_semicolon (this);\n+      pp_needs_newline (this) = false;\n+      pp_c_whitespace (this);\n+      if (FOR_COND (t))\n+\texpression (FOR_COND (t));\n+      pp_c_semicolon (this);\n+      pp_needs_newline (this) = false;\n+      pp_c_whitespace (this);\n+      if (FOR_EXPR (t))\n+\texpression (FOR_EXPR (t));\n+      pp_c_right_paren (this);\n+      pp_newline_and_indent (this, 3);\n+      statement (FOR_BODY (t));\n+      pp_indentation (this) -= 3;\n+      pp_needs_newline (this) = true;\n+      break;\n+\n+      /* jump-statement:\n+\t    goto identifier;\n+\t    continue ;\n+\t    return expression(opt) ;  */\n+    case BREAK_STMT:\n+    case CONTINUE_STMT:\n+      pp_string (this, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n+      pp_c_semicolon (this);\n+      pp_needs_newline (this) = true;\n+      break;\n+\n+    default:\n+      if (pp_needs_newline (this))\n+\tpp_newline_and_indent (this, 0);\n+      dump_generic_node (this, t, pp_indentation (this), TDF_NONE, true);\n+    }\n }\n \n \f"}, {"sha": "bc8a03c7b41aa4982d20e166bf3703205ec825fb", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 83, "deletions": 386, "changes": 469, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -49,66 +49,6 @@ static tree cp_fold_r (tree *, int *, void *);\n static void cp_genericize_tree (tree*, bool);\n static tree cp_fold (tree);\n \n-/* Local declarations.  */\n-\n-enum bc_t { bc_break = 0, bc_continue = 1 };\n-\n-/* Stack of labels which are targets for \"break\" or \"continue\",\n-   linked through TREE_CHAIN.  */\n-static tree bc_label[2];\n-\n-/* Begin a scope which can be exited by a break or continue statement.  BC\n-   indicates which.\n-\n-   Just creates a label with location LOCATION and pushes it into the current\n-   context.  */\n-\n-static tree\n-begin_bc_block (enum bc_t bc, location_t location)\n-{\n-  tree label = create_artificial_label (location);\n-  DECL_CHAIN (label) = bc_label[bc];\n-  bc_label[bc] = label;\n-  if (bc == bc_break)\n-    LABEL_DECL_BREAK (label) = true;\n-  else\n-    LABEL_DECL_CONTINUE (label) = true;\n-  return label;\n-}\n-\n-/* Finish a scope which can be exited by a break or continue statement.\n-   LABEL was returned from the most recent call to begin_bc_block.  BLOCK is\n-   an expression for the contents of the scope.\n-\n-   If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n-   BLOCK.  Otherwise, just forget the label.  */\n-\n-static void\n-finish_bc_block (tree *block, enum bc_t bc, tree label)\n-{\n-  gcc_assert (label == bc_label[bc]);\n-\n-  if (TREE_USED (label))\n-    append_to_statement_list (build1 (LABEL_EXPR, void_type_node, label),\n-\t\t\t      block);\n-\n-  bc_label[bc] = DECL_CHAIN (label);\n-  DECL_CHAIN (label) = NULL_TREE;\n-}\n-\n-/* Get the LABEL_EXPR to represent a break or continue statement\n-   in the current block scope.  BC indicates which.  */\n-\n-static tree\n-get_bc_label (enum bc_t bc)\n-{\n-  tree label = bc_label[bc];\n-\n-  /* Mark the label used for finish_bc_block.  */\n-  TREE_USED (label) = 1;\n-  return label;\n-}\n-\n /* Genericize a TRY_BLOCK.  */\n \n static void\n@@ -231,228 +171,6 @@ genericize_if_stmt (tree *stmt_p)\n   *stmt_p = stmt;\n }\n \n-/* Build a generic representation of one of the C loop forms.  COND is the\n-   loop condition or NULL_TREE.  BODY is the (possibly compound) statement\n-   controlled by the loop.  INCR is the increment expression of a for-loop,\n-   or NULL_TREE.  COND_IS_FIRST indicates whether the condition is\n-   evaluated before the loop body as in while and for loops, or after the\n-   loop body as in do-while loops.  */\n-\n-static void\n-genericize_cp_loop (tree *stmt_p, location_t start_locus, tree cond, tree body,\n-\t\t    tree incr, bool cond_is_first, int *walk_subtrees,\n-\t\t    void *data)\n-{\n-  tree blab, clab;\n-  tree exit = NULL;\n-  tree stmt_list = NULL;\n-  tree debug_begin = NULL;\n-\n-  protected_set_expr_location_if_unset (incr, start_locus);\n-\n-  cp_walk_tree (&cond, cp_genericize_r, data, NULL);\n-  cp_walk_tree (&incr, cp_genericize_r, data, NULL);\n-\n-  blab = begin_bc_block (bc_break, start_locus);\n-  clab = begin_bc_block (bc_continue, start_locus);\n-\n-  cp_walk_tree (&body, cp_genericize_r, data, NULL);\n-  *walk_subtrees = 0;\n-\n-  if (MAY_HAVE_DEBUG_MARKER_STMTS\n-      && (!cond || !integer_zerop (cond)))\n-    {\n-      debug_begin = build0 (DEBUG_BEGIN_STMT, void_type_node);\n-      SET_EXPR_LOCATION (debug_begin, cp_expr_loc_or_loc (cond, start_locus));\n-    }\n-\n-  if (cond && TREE_CODE (cond) != INTEGER_CST)\n-    {\n-      /* If COND is constant, don't bother building an exit.  If it's false,\n-\t we won't build a loop.  If it's true, any exits are in the body.  */\n-      location_t cloc = cp_expr_loc_or_loc (cond, start_locus);\n-      exit = build1_loc (cloc, GOTO_EXPR, void_type_node,\n-\t\t\t get_bc_label (bc_break));\n-      exit = fold_build3_loc (cloc, COND_EXPR, void_type_node, cond,\n-\t\t\t      build_empty_stmt (cloc), exit);\n-    }\n-\n-  if (exit && cond_is_first)\n-    {\n-      append_to_statement_list (debug_begin, &stmt_list);\n-      debug_begin = NULL_TREE;\n-      append_to_statement_list (exit, &stmt_list);\n-    }\n-  append_to_statement_list (body, &stmt_list);\n-  finish_bc_block (&stmt_list, bc_continue, clab);\n-  if (incr)\n-    {\n-      if (MAY_HAVE_DEBUG_MARKER_STMTS)\n-\t{\n-\t  tree d = build0 (DEBUG_BEGIN_STMT, void_type_node);\n-\t  SET_EXPR_LOCATION (d, cp_expr_loc_or_loc (incr, start_locus));\n-\t  append_to_statement_list (d, &stmt_list);\n-\t}\n-      append_to_statement_list (incr, &stmt_list);\n-    }\n-  append_to_statement_list (debug_begin, &stmt_list);\n-  if (exit && !cond_is_first)\n-    append_to_statement_list (exit, &stmt_list);\n-\n-  if (!stmt_list)\n-    stmt_list = build_empty_stmt (start_locus);\n-\n-  tree loop;\n-  if (cond && integer_zerop (cond))\n-    {\n-      if (cond_is_first)\n-\tloop = fold_build3_loc (start_locus, COND_EXPR,\n-\t\t\t\tvoid_type_node, cond, stmt_list,\n-\t\t\t\tbuild_empty_stmt (start_locus));\n-      else\n-\tloop = stmt_list;\n-    }\n-  else\n-    {\n-      location_t loc = start_locus;\n-      if (!cond || integer_nonzerop (cond))\n-\tloc = EXPR_LOCATION (expr_first (body));\n-      if (loc == UNKNOWN_LOCATION)\n-\tloc = start_locus;\n-      loop = build1_loc (loc, LOOP_EXPR, void_type_node, stmt_list);\n-    }\n-\n-  stmt_list = NULL;\n-  append_to_statement_list (loop, &stmt_list);\n-  finish_bc_block (&stmt_list, bc_break, blab);\n-  if (!stmt_list)\n-    stmt_list = build_empty_stmt (start_locus);\n-\n-  *stmt_p = stmt_list;\n-}\n-\n-/* Genericize a FOR_STMT node *STMT_P.  */\n-\n-static void\n-genericize_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  tree stmt = *stmt_p;\n-  tree expr = NULL;\n-  tree loop;\n-  tree init = FOR_INIT_STMT (stmt);\n-\n-  if (init)\n-    {\n-      cp_walk_tree (&init, cp_genericize_r, data, NULL);\n-      append_to_statement_list (init, &expr);\n-    }\n-\n-  genericize_cp_loop (&loop, EXPR_LOCATION (stmt), FOR_COND (stmt),\n-\t\t      FOR_BODY (stmt), FOR_EXPR (stmt), 1, walk_subtrees, data);\n-  append_to_statement_list (loop, &expr);\n-  if (expr == NULL_TREE)\n-    expr = loop;\n-  *stmt_p = expr;\n-}\n-\n-/* Genericize a WHILE_STMT node *STMT_P.  */\n-\n-static void\n-genericize_while_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  tree stmt = *stmt_p;\n-  genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), WHILE_COND (stmt),\n-\t\t      WHILE_BODY (stmt), NULL_TREE, 1, walk_subtrees, data);\n-}\n-\n-/* Genericize a DO_STMT node *STMT_P.  */\n-\n-static void\n-genericize_do_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  tree stmt = *stmt_p;\n-  genericize_cp_loop (stmt_p, EXPR_LOCATION (stmt), DO_COND (stmt),\n-\t\t      DO_BODY (stmt), NULL_TREE, 0, walk_subtrees, data);\n-}\n-\n-/* Genericize a SWITCH_STMT node *STMT_P by turning it into a SWITCH_EXPR.  */\n-\n-static void\n-genericize_switch_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  tree stmt = *stmt_p;\n-  tree break_block, body, cond, type;\n-  location_t stmt_locus = EXPR_LOCATION (stmt);\n-\n-  body = SWITCH_STMT_BODY (stmt);\n-  if (!body)\n-    body = build_empty_stmt (stmt_locus);\n-  cond = SWITCH_STMT_COND (stmt);\n-  type = SWITCH_STMT_TYPE (stmt);\n-\n-  cp_walk_tree (&cond, cp_genericize_r, data, NULL);\n-\n-  break_block = begin_bc_block (bc_break, stmt_locus);\n-\n-  cp_walk_tree (&body, cp_genericize_r, data, NULL);\n-  cp_walk_tree (&type, cp_genericize_r, data, NULL);\n-  *walk_subtrees = 0;\n-\n-  if (TREE_USED (break_block))\n-    SWITCH_BREAK_LABEL_P (break_block) = 1;\n-  finish_bc_block (&body, bc_break, break_block);\n-  *stmt_p = build2_loc (stmt_locus, SWITCH_EXPR, type, cond, body);\n-  SWITCH_ALL_CASES_P (*stmt_p) = SWITCH_STMT_ALL_CASES_P (stmt);\n-  gcc_checking_assert (!SWITCH_STMT_NO_BREAK_P (stmt)\n-\t\t       || !TREE_USED (break_block));\n-}\n-\n-/* Genericize a CONTINUE_STMT node *STMT_P.  */\n-\n-static void\n-genericize_continue_stmt (tree *stmt_p)\n-{\n-  tree stmt_list = NULL;\n-  tree pred = build_predict_expr (PRED_CONTINUE, NOT_TAKEN);\n-  tree label = get_bc_label (bc_continue);\n-  location_t location = EXPR_LOCATION (*stmt_p);\n-  tree jump = build1_loc (location, GOTO_EXPR, void_type_node, label);\n-  append_to_statement_list_force (pred, &stmt_list);\n-  append_to_statement_list (jump, &stmt_list);\n-  *stmt_p = stmt_list;\n-}\n-\n-/* Genericize a BREAK_STMT node *STMT_P.  */\n-\n-static void\n-genericize_break_stmt (tree *stmt_p)\n-{\n-  tree label = get_bc_label (bc_break);\n-  location_t location = EXPR_LOCATION (*stmt_p);\n-  *stmt_p = build1_loc (location, GOTO_EXPR, void_type_node, label);\n-}\n-\n-/* Genericize a OMP_FOR node *STMT_P.  */\n-\n-static void\n-genericize_omp_for_stmt (tree *stmt_p, int *walk_subtrees, void *data)\n-{\n-  tree stmt = *stmt_p;\n-  location_t locus = EXPR_LOCATION (stmt);\n-  tree clab = begin_bc_block (bc_continue, locus);\n-\n-  cp_walk_tree (&OMP_FOR_BODY (stmt), cp_genericize_r, data, NULL);\n-  if (TREE_CODE (stmt) != OMP_TASKLOOP)\n-    cp_walk_tree (&OMP_FOR_CLAUSES (stmt), cp_genericize_r, data, NULL);\n-  cp_walk_tree (&OMP_FOR_INIT (stmt), cp_genericize_r, data, NULL);\n-  cp_walk_tree (&OMP_FOR_COND (stmt), cp_genericize_r, data, NULL);\n-  cp_walk_tree (&OMP_FOR_INCR (stmt), cp_genericize_r, data, NULL);\n-  cp_walk_tree (&OMP_FOR_PRE_BODY (stmt), cp_genericize_r, data, NULL);\n-  *walk_subtrees = 0;\n-\n-  finish_bc_block (&OMP_FOR_BODY (stmt), bc_continue, clab);\n-}\n-\n /* Hook into the middle of gimplifying an OMP_FOR node.  */\n \n static enum gimplify_status\n@@ -1565,7 +1283,8 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t      break;\n \t    }\n \tif (TREE_CODE (stmt) == OMP_TASKLOOP)\n-\t  genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n+\t  c_genericize_control_stmt (stmt_p, walk_subtrees, data,\n+\t\t\t\t     cp_genericize_r, cp_walk_subtrees);\n \telse\n \t  cp_walk_tree (&OMP_BODY (stmt), cp_genericize_r, data, NULL);\n \twtd->omp_ctx = omp_ctx.outer;\n@@ -1636,103 +1355,10 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n       gcc_assert (!CONVERT_EXPR_VBASE_PATH (stmt));\n       break;\n \n-    case FOR_STMT:\n-      genericize_for_stmt (stmt_p, walk_subtrees, data);\n-      break;\n-\n-    case WHILE_STMT:\n-      genericize_while_stmt (stmt_p, walk_subtrees, data);\n-      break;\n-\n-    case DO_STMT:\n-      genericize_do_stmt (stmt_p, walk_subtrees, data);\n-      break;\n-\n-    case SWITCH_STMT:\n-      genericize_switch_stmt (stmt_p, walk_subtrees, data);\n-      break;\n-\n-    case CONTINUE_STMT:\n-      genericize_continue_stmt (stmt_p);\n-      break;\n-\n-    case BREAK_STMT:\n-      genericize_break_stmt (stmt_p);\n-      break;\n-\n     case SPACESHIP_EXPR:\n       *stmt_p = genericize_spaceship (*stmt_p);\n       break;\n \n-    case OMP_DISTRIBUTE:\n-      /* Need to explicitly instantiate copy ctors on class iterators of\n-\t composite distribute parallel for.  */\n-      if (OMP_FOR_INIT (*stmt_p) == NULL_TREE)\n-\t{\n-\t  tree *data[4] = { NULL, NULL, NULL, NULL };\n-\t  tree inner = walk_tree (&OMP_FOR_BODY (*stmt_p),\n-\t\t\t\t  find_combined_omp_for, data, NULL);\n-\t  if (inner != NULL_TREE\n-\t      && TREE_CODE (inner) == OMP_FOR)\n-\t    {\n-\t      for (int i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner)); i++)\n-\t\tif (OMP_FOR_ORIG_DECLS (inner)\n-\t\t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n-\t\t\t\t  i)) == TREE_LIST\n-\t\t    && TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n-\t\t\t\t     i)))\n-\t\t  {\n-\t\t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner), i);\n-\t\t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n-\t\t       case we need to solve is distribute parallel for.  */\n-\t\t    gcc_assert (TREE_CODE (inner) == OMP_FOR\n-\t\t\t\t&& data[1]);\n-\t\t    tree orig_decl = TREE_PURPOSE (orig);\n-\t\t    tree c, cl = NULL_TREE;\n-\t\t    for (c = OMP_FOR_CLAUSES (inner);\n-\t\t\t c; c = OMP_CLAUSE_CHAIN (c))\n-\t\t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n-\t\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n-\t\t\t  && OMP_CLAUSE_DECL (c) == orig_decl)\n-\t\t\t{\n-\t\t\t  cl = c;\n-\t\t\t  break;\n-\t\t\t}\n-\t\t    if (cl == NULL_TREE)\n-\t\t      {\n-\t\t\tfor (c = OMP_PARALLEL_CLAUSES (*data[1]);\n-\t\t\t     c; c = OMP_CLAUSE_CHAIN (c))\n-\t\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n-\t\t\t      && OMP_CLAUSE_DECL (c) == orig_decl)\n-\t\t\t    {\n-\t\t\t      cl = c;\n-\t\t\t      break;\n-\t\t\t    }\n-\t\t      }\n-\t\t    if (cl)\n-\t\t      {\n-\t\t\torig_decl = require_complete_type (orig_decl);\n-\t\t\ttree inner_type = TREE_TYPE (orig_decl);\n-\t\t\tif (orig_decl == error_mark_node)\n-\t\t\t  continue;\n-\t\t\tif (TYPE_REF_P (TREE_TYPE (orig_decl)))\n-\t\t\t  inner_type = TREE_TYPE (inner_type);\n-\n-\t\t\twhile (TREE_CODE (inner_type) == ARRAY_TYPE)\n-\t\t\t  inner_type = TREE_TYPE (inner_type);\n-\t\t\tget_copy_ctor (inner_type, tf_warning_or_error);\n-\t\t      }\n-\t\t}\n-\t    }\n-\t}\n-      /* FALLTHRU */\n-    case OMP_FOR:\n-    case OMP_SIMD:\n-    case OMP_LOOP:\n-    case OACC_LOOP:\n-      genericize_omp_for_stmt (stmt_p, walk_subtrees, data);\n-      break;\n-\n     case PTRMEM_CST:\n       /* By the time we get here we're handing off to the back end, so we don't\n \t need or want to preserve PTRMEM_CST anymore.  */\n@@ -1868,6 +1494,84 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t}\n       break;\n \n+    case OMP_DISTRIBUTE:\n+      /* Need to explicitly instantiate copy ctors on class iterators of\n+\t composite distribute parallel for.  */\n+      if (OMP_FOR_INIT (*stmt_p) == NULL_TREE)\n+\t{\n+\t  tree *data[4] = { NULL, NULL, NULL, NULL };\n+\t  tree inner = walk_tree (&OMP_FOR_BODY (*stmt_p),\n+\t\t\t\t  find_combined_omp_for, data, NULL);\n+\t  if (inner != NULL_TREE\n+\t      && TREE_CODE (inner) == OMP_FOR)\n+\t    {\n+\t      for (int i = 0; i < TREE_VEC_LENGTH (OMP_FOR_INIT (inner)); i++)\n+\t\tif (OMP_FOR_ORIG_DECLS (inner)\n+\t\t    && TREE_CODE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n+\t\t\t\t  i)) == TREE_LIST\n+\t\t    && TREE_PURPOSE (TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner),\n+\t\t\t\t     i)))\n+\t\t  {\n+\t\t    tree orig = TREE_VEC_ELT (OMP_FOR_ORIG_DECLS (inner), i);\n+\t\t    /* Class iterators aren't allowed on OMP_SIMD, so the only\n+\t\t       case we need to solve is distribute parallel for.  */\n+\t\t    gcc_assert (TREE_CODE (inner) == OMP_FOR\n+\t\t\t\t&& data[1]);\n+\t\t    tree orig_decl = TREE_PURPOSE (orig);\n+\t\t    tree c, cl = NULL_TREE;\n+\t\t    for (c = OMP_FOR_CLAUSES (inner);\n+\t\t\t c; c = OMP_CLAUSE_CHAIN (c))\n+\t\t      if ((OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t\t   || OMP_CLAUSE_CODE (c) == OMP_CLAUSE_LASTPRIVATE)\n+\t\t\t  && OMP_CLAUSE_DECL (c) == orig_decl)\n+\t\t\t{\n+\t\t\t  cl = c;\n+\t\t\t  break;\n+\t\t\t}\n+\t\t    if (cl == NULL_TREE)\n+\t\t      {\n+\t\t\tfor (c = OMP_PARALLEL_CLAUSES (*data[1]);\n+\t\t\t     c; c = OMP_CLAUSE_CHAIN (c))\n+\t\t\t  if (OMP_CLAUSE_CODE (c) == OMP_CLAUSE_PRIVATE\n+\t\t\t      && OMP_CLAUSE_DECL (c) == orig_decl)\n+\t\t\t    {\n+\t\t\t      cl = c;\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t      }\n+\t\t    if (cl)\n+\t\t      {\n+\t\t\torig_decl = require_complete_type (orig_decl);\n+\t\t\ttree inner_type = TREE_TYPE (orig_decl);\n+\t\t\tif (orig_decl == error_mark_node)\n+\t\t\t  continue;\n+\t\t\tif (TYPE_REF_P (TREE_TYPE (orig_decl)))\n+\t\t\t  inner_type = TREE_TYPE (inner_type);\n+\n+\t\t\twhile (TREE_CODE (inner_type) == ARRAY_TYPE)\n+\t\t\t  inner_type = TREE_TYPE (inner_type);\n+\t\t\tget_copy_ctor (inner_type, tf_warning_or_error);\n+\t\t      }\n+\t\t}\n+\t    }\n+\t}\n+      /* FALLTHRU */\n+\n+    case FOR_STMT:\n+    case WHILE_STMT:\n+    case DO_STMT:\n+    case SWITCH_STMT:\n+    case CONTINUE_STMT:\n+    case BREAK_STMT:\n+    case OMP_FOR:\n+    case OMP_SIMD:\n+    case OMP_LOOP:\n+    case OACC_LOOP:\n+      /* These cases are handled by shared code.  */\n+      c_genericize_control_stmt (stmt_p, walk_subtrees, data,\n+\t\t\t\t cp_genericize_r, cp_walk_subtrees);\n+      break;\n+\n     default:\n       if (IS_TYPE_OR_DECL_P (stmt))\n \t*walk_subtrees = 0;\n@@ -2033,11 +1737,8 @@ cp_genericize (tree fndecl)\n     return;\n \n   /* Allow cp_genericize calls to be nested.  */\n-  tree save_bc_label[2];\n-  save_bc_label[bc_break] = bc_label[bc_break];\n-  save_bc_label[bc_continue] = bc_label[bc_continue];\n-  bc_label[bc_break] = NULL_TREE;\n-  bc_label[bc_continue] = NULL_TREE;\n+  bc_state_t save_state;\n+  save_bc_state (&save_state);\n \n   /* We do want to see every occurrence of the parms, so we can't just use\n      walk_tree's hash functionality.  */\n@@ -2047,11 +1748,7 @@ cp_genericize (tree fndecl)\n \n   /* Do everything else.  */\n   c_genericize (fndecl);\n-\n-  gcc_assert (bc_label[bc_break] == NULL);\n-  gcc_assert (bc_label[bc_continue] == NULL);\n-  bc_label[bc_break] = save_bc_label[bc_break];\n-  bc_label[bc_continue] = save_bc_label[bc_continue];\n+  restore_bc_state (&save_state);\n }\n \f\n /* Build code to apply FN to each member of ARG1 and ARG2.  FN may be"}, {"sha": "e1397b7b7104a05f7c8aa60d6017adb11f046a9a", "filename": "gcc/cp/cp-objcp-common.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-objcp-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-objcp-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-objcp-common.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -314,13 +314,8 @@ cxx_block_may_fallthru (const_tree stmt)\n \treturn true;\n       return block_may_fallthru (ELSE_CLAUSE (stmt));\n \n-    case SWITCH_STMT:\n-      return (!SWITCH_STMT_ALL_CASES_P (stmt)\n-\t      || !SWITCH_STMT_NO_BREAK_P (stmt)\n-\t      || block_may_fallthru (SWITCH_STMT_BODY (stmt)));\n-\n     default:\n-      return true;\n+      return c_block_may_fallthru (stmt);\n     }\n }\n \n@@ -478,20 +473,14 @@ cp_common_init_ts (void)\n   MARK_TS_TYPE_NON_COMMON (TYPE_PACK_EXPANSION);\n \n   /* Statements.  */\n-  MARK_TS_EXP (BREAK_STMT);\n   MARK_TS_EXP (CLEANUP_STMT);\n-  MARK_TS_EXP (CONTINUE_STMT);\n-  MARK_TS_EXP (DO_STMT);\n   MARK_TS_EXP (EH_SPEC_BLOCK);\n-  MARK_TS_EXP (FOR_STMT);\n   MARK_TS_EXP (HANDLER);\n   MARK_TS_EXP (IF_STMT);\n   MARK_TS_EXP (OMP_DEPOBJ);\n   MARK_TS_EXP (RANGE_FOR_STMT);\n-  MARK_TS_EXP (SWITCH_STMT);\n   MARK_TS_EXP (TRY_BLOCK);\n   MARK_TS_EXP (USING_STMT);\n-  MARK_TS_EXP (WHILE_STMT);\n \n   /* Random expressions.  */\n   MARK_TS_EXP (ADDRESSOF_EXPR);"}, {"sha": "a188576013b0b260a9f8a9b846f1d8f4abbf347e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -300,35 +300,12 @@ DEFTREECODE (CLEANUP_STMT, \"cleanup_stmt\", tcc_statement, 3)\n    and COND_EXPR for the benefit of templates.  */\n DEFTREECODE (IF_STMT, \"if_stmt\", tcc_statement, 4)\n \n-/* Used to represent a `for' statement. The operands are\n-   FOR_INIT_STMT, FOR_COND, FOR_EXPR, and FOR_BODY, respectively.  */\n-DEFTREECODE (FOR_STMT, \"for_stmt\", tcc_statement, 5)\n-\n /* Used to represent a range-based `for' statement. The operands are\n    RANGE_FOR_DECL, RANGE_FOR_EXPR, RANGE_FOR_BODY, RANGE_FOR_SCOPE,\n    RANGE_FOR_UNROLL, and RANGE_FOR_INIT_STMT, respectively.  Only used in\n    templates.  */\n DEFTREECODE (RANGE_FOR_STMT, \"range_for_stmt\", tcc_statement, 6)\n \n-/* Used to represent a 'while' statement. The operands are WHILE_COND\n-   and WHILE_BODY, respectively.  */\n-DEFTREECODE (WHILE_STMT, \"while_stmt\", tcc_statement, 2)\n-\n-/* Used to represent a 'do' statement. The operands are DO_BODY and\n-   DO_COND, respectively.  */\n-DEFTREECODE (DO_STMT, \"do_stmt\", tcc_statement, 2)\n-\n-/* Used to represent a 'break' statement.  */\n-DEFTREECODE (BREAK_STMT, \"break_stmt\", tcc_statement, 0)\n-\n-/* Used to represent a 'continue' statement.  */\n-DEFTREECODE (CONTINUE_STMT, \"continue_stmt\", tcc_statement, 0)\n-\n-/* Used to represent a 'switch' statement. The operands are\n-   SWITCH_STMT_COND, SWITCH_STMT_BODY, SWITCH_STMT_TYPE, and\n-   SWITCH_STMT_SCOPE, respectively.  */\n-DEFTREECODE (SWITCH_STMT, \"switch_stmt\", tcc_statement, 4)\n-\n /* Used to represent an expression statement.  Use `EXPR_STMT_EXPR' to\n    obtain the expression.  */\n DEFTREECODE (EXPR_STMT, \"expr_stmt\", tcc_expression, 1)"}, {"sha": "713538149735d206dc4902f45e4649f5deb5b327", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -4028,14 +4028,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define DECL_LOCAL_DECL_P(NODE) \\\n   DECL_LANG_FLAG_0 (VAR_OR_FUNCTION_DECL_CHECK (NODE))\n \n-/* Nonzero if NODE is the target for genericization of 'break' stmts.  */\n-#define LABEL_DECL_BREAK(NODE) \\\n-  DECL_LANG_FLAG_0 (LABEL_DECL_CHECK (NODE))\n-\n-/* Nonzero if NODE is the target for genericization of 'continue' stmts.  */\n-#define LABEL_DECL_CONTINUE(NODE) \\\n-  DECL_LANG_FLAG_1 (LABEL_DECL_CHECK (NODE))\n-\n /* Nonzero if NODE is the target for genericization of 'return' stmts\n    in constructors/destructors of targetm.cxx.cdtor_returns_this targets.  */\n #define LABEL_DECL_CDTOR(NODE) \\\n@@ -5088,25 +5080,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n    building an IF_STMT; IF_STMT_EXTRA_ARGS is used after it is complete.  */\n #define IF_STMT_EXTRA_ARGS(NODE) IF_SCOPE (NODE)\n \n-/* WHILE_STMT accessors. These give access to the condition of the\n-   while statement and the body of the while statement, respectively.  */\n-#define WHILE_COND(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 0)\n-#define WHILE_BODY(NODE)\tTREE_OPERAND (WHILE_STMT_CHECK (NODE), 1)\n-\n-/* DO_STMT accessors. These give access to the condition of the do\n-   statement and the body of the do statement, respectively.  */\n-#define DO_COND(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 0)\n-#define DO_BODY(NODE)\t\tTREE_OPERAND (DO_STMT_CHECK (NODE), 1)\n-\n-/* FOR_STMT accessors. These give access to the init statement,\n-   condition, update expression, and body of the for statement,\n-   respectively.  */\n-#define FOR_INIT_STMT(NODE)\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 0)\n-#define FOR_COND(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 1)\n-#define FOR_EXPR(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n-#define FOR_BODY(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n-#define FOR_SCOPE(NODE)\t\tTREE_OPERAND (FOR_STMT_CHECK (NODE), 4)\n-\n /* RANGE_FOR_STMT accessors. These give access to the declarator,\n    expression, body, and scope of the statement, respectively.  */\n #define RANGE_FOR_DECL(NODE)\tTREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 0)\n@@ -5117,19 +5090,6 @@ more_aggr_init_expr_args_p (const aggr_init_expr_arg_iterator *iter)\n #define RANGE_FOR_INIT_STMT(NODE) TREE_OPERAND (RANGE_FOR_STMT_CHECK (NODE), 5)\n #define RANGE_FOR_IVDEP(NODE)\tTREE_LANG_FLAG_6 (RANGE_FOR_STMT_CHECK (NODE))\n \n-#define SWITCH_STMT_COND(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n-#define SWITCH_STMT_BODY(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n-#define SWITCH_STMT_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n-#define SWITCH_STMT_SCOPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 3)\n-/* True if there are case labels for all possible values of switch cond, either\n-   because there is a default: case label or because the case label ranges cover\n-   all values.  */\n-#define SWITCH_STMT_ALL_CASES_P(NODE) \\\n-  TREE_LANG_FLAG_0 (SWITCH_STMT_CHECK (NODE))\n-/* True if the body of a switch stmt contains no BREAK_STMTs.  */\n-#define SWITCH_STMT_NO_BREAK_P(NODE) \\\n-  TREE_LANG_FLAG_2 (SWITCH_STMT_CHECK (NODE))\n-\n /* STMT_EXPR accessor.  */\n #define STMT_EXPR_STMT(NODE)\tTREE_OPERAND (STMT_EXPR_CHECK (NODE), 0)\n "}, {"sha": "d10c18db0398a6d3f97d59b58881ee9dcbd01820", "filename": "gcc/cp/cxx-pretty-print.c", "status": "modified", "additions": 0, "deletions": 78, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcxx-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fcxx-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcxx-pretty-print.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -2019,73 +2019,6 @@ cxx_pretty_printer::statement (tree t)\n \t}\n       break;\n \n-    case SWITCH_STMT:\n-      pp_cxx_ws_string (this, \"switch\");\n-      pp_space (this);\n-      pp_cxx_left_paren (this);\n-      expression (SWITCH_STMT_COND (t));\n-      pp_cxx_right_paren (this);\n-      pp_indentation (this) += 3;\n-      pp_needs_newline (this) = true;\n-      statement (SWITCH_STMT_BODY (t));\n-      pp_newline_and_indent (this, -3);\n-      break;\n-\n-      /* iteration-statement:\n-\t    while ( expression ) statement\n-\t    do statement while ( expression ) ;\n-\t    for ( expression(opt) ; expression(opt) ; expression(opt) ) statement\n-\t    for ( declaration expression(opt) ; expression(opt) ) statement  */\n-    case WHILE_STMT:\n-      pp_cxx_ws_string (this, \"while\");\n-      pp_space (this);\n-      pp_cxx_left_paren (this);\n-      expression (WHILE_COND (t));\n-      pp_cxx_right_paren (this);\n-      pp_newline_and_indent (this, 3);\n-      statement (WHILE_BODY (t));\n-      pp_indentation (this) -= 3;\n-      pp_needs_newline (this) = true;\n-      break;\n-\n-    case DO_STMT:\n-      pp_cxx_ws_string (this, \"do\");\n-      pp_newline_and_indent (this, 3);\n-      statement (DO_BODY (t));\n-      pp_newline_and_indent (this, -3);\n-      pp_cxx_ws_string (this, \"while\");\n-      pp_space (this);\n-      pp_cxx_left_paren (this);\n-      expression (DO_COND (t));\n-      pp_cxx_right_paren (this);\n-      pp_cxx_semicolon (this);\n-      pp_needs_newline (this) = true;\n-      break;\n-\n-    case FOR_STMT:\n-      pp_cxx_ws_string (this, \"for\");\n-      pp_space (this);\n-      pp_cxx_left_paren (this);\n-      if (FOR_INIT_STMT (t))\n-\tstatement (FOR_INIT_STMT (t));\n-      else\n-\tpp_cxx_semicolon (this);\n-      pp_needs_newline (this) = false;\n-      pp_cxx_whitespace (this);\n-      if (FOR_COND (t))\n-\texpression (FOR_COND (t));\n-      pp_cxx_semicolon (this);\n-      pp_needs_newline (this) = false;\n-      pp_cxx_whitespace (this);\n-      if (FOR_EXPR (t))\n-\texpression (FOR_EXPR (t));\n-      pp_cxx_right_paren (this);\n-      pp_newline_and_indent (this, 3);\n-      statement (FOR_BODY (t));\n-      pp_indentation (this) -= 3;\n-      pp_needs_newline (this) = true;\n-      break;\n-\n     case RANGE_FOR_STMT:\n       pp_cxx_ws_string (this, \"for\");\n       pp_space (this);\n@@ -2109,17 +2042,6 @@ cxx_pretty_printer::statement (tree t)\n       pp_needs_newline (this) = true;\n       break;\n \n-      /* jump-statement:\n-\t    goto identifier;\n-\t    continue ;\n-\t    return expression(opt) ;  */\n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      pp_string (this, TREE_CODE (t) == BREAK_STMT ? \"break\" : \"continue\");\n-      pp_cxx_semicolon (this);\n-      pp_needs_newline (this) = true;\n-      break;\n-\n       /* expression-statement:\n \t    expression(opt) ;  */\n     case EXPR_STMT:"}, {"sha": "81d2c16d5db1d1fb1274286dd45f74f8fd8f0137", "filename": "gcc/cp/dump.c", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fdump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fcp%2Fdump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdump.c?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -280,25 +280,6 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"else\", ELSE_CLAUSE (t));\n       break;\n \n-    case BREAK_STMT:\n-    case CONTINUE_STMT:\n-      dump_stmt (di, t);\n-      break;\n-\n-    case DO_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"body\", DO_BODY (t));\n-      dump_child (\"cond\", DO_COND (t));\n-      break;\n-\n-    case FOR_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"init\", FOR_INIT_STMT (t));\n-      dump_child (\"cond\", FOR_COND (t));\n-      dump_child (\"expr\", FOR_EXPR (t));\n-      dump_child (\"body\", FOR_BODY (t));\n-      break;\n-\n     case RANGE_FOR_STMT:\n       dump_stmt (di, t);\n       dump_child (\"init\", RANGE_FOR_INIT_STMT (t));\n@@ -307,18 +288,6 @@ cp_dump_tree (void* dump_info, tree t)\n       dump_child (\"body\", RANGE_FOR_BODY (t));\n       break;\n \n-    case SWITCH_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", SWITCH_STMT_COND (t));\n-      dump_child (\"body\", SWITCH_STMT_BODY (t));\n-      break;\n-\n-    case WHILE_STMT:\n-      dump_stmt (di, t);\n-      dump_child (\"cond\", WHILE_COND (t));\n-      dump_child (\"body\", WHILE_BODY (t));\n-      break;\n-\n     case STMT_EXPR:\n       dump_child (\"stmt\", STMT_EXPR_STMT (t));\n       break;"}, {"sha": "7373266c69f393139dabe21437aa8b3c2b5b0b4a", "filename": "gcc/doc/generic.texi", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fdoc%2Fgeneric.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba079f354a55363916759f6f186f92c5616b98a/gcc%2Fdoc%2Fgeneric.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgeneric.texi?ref=cba079f354a55363916759f6f186f92c5616b98a", "patch": "@@ -2032,14 +2032,19 @@ These nodes represent conditional exits from the nearest enclosing\n nonzero, then the loop should be exited.  An @code{EXIT_EXPR} will only\n appear within a @code{LOOP_EXPR}.\n \n-@item SWITCH_STMT\n+@item SWITCH_EXPR\n \n-Used to represent a @code{switch} statement.  The @code{SWITCH_STMT_COND}\n-is the expression on which the switch is occurring.  See the documentation\n-for an @code{IF_STMT} for more information on the representation used\n-for the condition.  The @code{SWITCH_STMT_BODY} is the body of the switch\n-statement.   The @code{SWITCH_STMT_TYPE} is the original type of switch\n-expression as given in the source, before any compiler conversions.\n+Used to represent a @code{switch} statement.  The @code{SWITCH_COND}\n+is the expression on which the switch is occurring.  The\n+@code{SWITCH_BODY} is the body of the switch statement.\n+@code{SWITCH_ALL_CASES_P} is true if the switch includes a default\n+label or the case label ranges cover all possible values of the\n+condition expression.\n+\n+Note that @code{TREE_TYPE} for a @code{SWITCH_EXPR} represents the\n+original type of switch expression as given in the source, before any\n+compiler conversions, instead of the type of the switch expression\n+itself (which is not meaningful).\n \n @item CASE_LABEL_EXPR\n \n@@ -2713,7 +2718,7 @@ should submit your patches for inclusion in GCC@.\n * Namespaces::                  Namespaces.\n * Classes::                     Classes.\n * Functions for C++::           Overloading and accessors for C++.\n-* Statements for C++::          Statements specific to C and C++.\n+* Statements for C and C++::    Statements specific to C and C++.\n * C++ Expressions::    From @code{typeid} to @code{throw}.\n @end menu\n \n@@ -3256,8 +3261,8 @@ This predicate holds if the function an overloaded\n @c Function Bodies\n @c ---------------------------------------------------------------------\n \n-@node Statements for C++\n-@subsection Statements for C++\n+@node Statements for C and C++\n+@subsection Statements for C and C++\n @cindex statements\n @tindex BREAK_STMT\n @tindex CLEANUP_STMT\n@@ -3299,15 +3304,13 @@ This predicate holds if the function an overloaded\n @findex WHILE_BODY\n @findex WHILE_COND\n \n-A function that has a definition in the current translation unit will\n-have a non-@code{NULL} @code{DECL_INITIAL}.  However, back ends should not make\n+A function that has a definition in the current translation unit has\n+a non-@code{NULL} @code{DECL_INITIAL}.  However, back ends should not make\n use of the particular value given by @code{DECL_INITIAL}.\n \n-The @code{DECL_SAVED_TREE} macro will give the complete body of the\n+The @code{DECL_SAVED_TREE} gives the complete body of the\n function.\n \n-@subsubsection Statements\n-\n There are tree nodes corresponding to all of the source-level\n statement constructs, used within the C and C++ frontends.  These are\n enumerated here, together with a list of the various macros that can\n@@ -3332,7 +3335,7 @@ In template functions, the same nodes are used, but sometimes in\n slightly different ways.\n \n Many of the statements have substatements.  For example, a @code{while}\n-loop will have a body, which is itself a statement.  If the substatement\n+loop has a body, which is itself a statement.  If the substatement\n is @code{NULL_TREE}, it is considered equivalent to a statement\n consisting of a single @code{;}, i.e., an expression statement in which\n the expression has been omitted.  A substatement may in fact be a list\n@@ -3361,7 +3364,7 @@ void process_stmt (stmt)\n @end smallexample\n In other words, while the @code{then} clause of an @code{if} statement\n in C++ can be only one statement (although that one statement may be a\n-compound statement), the intermediate representation will sometimes use\n+compound statement), the intermediate representation sometimes uses\n several statements chained together.\n \n @table @code\n@@ -3418,9 +3421,10 @@ the initialization statement for the loop.  The @code{FOR_COND} is the\n termination condition.  The @code{FOR_EXPR} is the expression executed\n right before the @code{FOR_COND} on each loop iteration; often, this\n expression increments a counter.  The body of the loop is given by\n-@code{FOR_BODY}.  Note that @code{FOR_INIT_STMT} and @code{FOR_BODY}\n-return statements, while @code{FOR_COND} and @code{FOR_EXPR} return\n-expressions.\n+@code{FOR_BODY}.  @code{FOR_SCOPE} holds the scope of the @code{for}\n+statement (used in the C++ front end only).  Note that\n+@code{FOR_INIT_STMT} and @code{FOR_BODY} return statements, while\n+@code{FOR_COND} and @code{FOR_EXPR} return expressions.\n \n @item HANDLER\n \n@@ -3441,8 +3445,6 @@ evaluated, the statement should be executed.  Then, the\n @code{TREE_VALUE} should be used as the conditional expression itself.\n This representation is used to handle C++ code like this:\n \n-C++ distinguishes between this and @code{COND_EXPR} for handling templates.\n-\n @smallexample\n if (int i = 7) @dots{}\n @end smallexample\n@@ -3454,6 +3456,8 @@ The @code{THEN_CLAUSE} represents the statement given by the @code{then}\n condition, while the @code{ELSE_CLAUSE} represents the statement given\n by the @code{else} condition.\n \n+C++ distinguishes between this and @code{COND_EXPR} for handling templates.\n+\n @item SUBOBJECT\n \n In a constructor, these nodes are used to mark the point at which a\n@@ -3470,6 +3474,14 @@ for an @code{IF_STMT} for more information on the representation used\n for the condition.  The @code{SWITCH_STMT_BODY} is the body of the switch\n statement.   The @code{SWITCH_STMT_TYPE} is the original type of switch\n expression as given in the source, before any compiler conversions.\n+The @code{SWITCH_STMT_SCOPE} is the statement scope (used in the\n+C++ front end only).\n+\n+There are also two boolean flags used with @code{SWITCH_STMT}.\n+@code{SWITCH_STMT_ALL_CASES_P} is true if the switch includes a default label\n+or the case label ranges cover all possible values of the condition\n+expression.  @code{SWITCH_STMT_NO_BREAK_P} is true if there are no\n+@code{break} statements in the switch.\n \n @item TRY_BLOCK\n Used to represent a @code{try} block.  The body of the try block is"}]}