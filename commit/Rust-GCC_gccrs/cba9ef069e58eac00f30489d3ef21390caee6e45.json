{"sha": "cba9ef069e58eac00f30489d3ef21390caee6e45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2JhOWVmMDY5ZTU4ZWFjMDBmMzA0ODlkM2VmMjEzOTBjYWVlNmU0NQ==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-01-30T22:37:07Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-02-07T14:24:43Z"}, "message": "libstdc++: Implement C++20 range adaptors\n\nThis patch implements [range.adaptors].  It also includes the changes from P3280\nand P3278 and P3323, without which many standard examples won't work.\n\nThe implementation is mostly dictated by the spec and there was not much room\nfor implementation discretion.  The most interesting part that was not specified\nby the spec is the design of the range adaptors and range adaptor closures,\nwhich I tried to design in a way that minimizes boilerplate and statefulness (so\nthat e.g. the composition of two stateless closures is stateless).\n\nWhat is left unimplemented is caching of calls to begin() in filter_view,\ndrop_view and reverse_view, which is required to guarantee that begin() has\namortized constant time complexity.  I can implement this in a subsequent patch.\n\n\"Interesting\" parts of the patch are marked with XXX comments.\n\nlibstdc++-v3/ChangeLog:\n\n\tImplement C++20 range adaptors\n\t* include/std/ranges: Include <bits/refwrap.h> and <tuple>.\n\t(subrange::_S_store_size): Mark as const instead of constexpr to\n\tavoid what seems to be a bug in GCC.\n\t(__detail::__box): Give it defaulted copy and move constructors.\n\t(views::_Single::operator()): Mark constexpr.\n\t(views::_Iota::operator()): Mark constexpr.\n\t(__detail::Empty): Define.\n\t(views::_RangeAdaptor, views::_RangeAdaptorClosure, ref_view, all_view,\n\tviews::all, filter_view, views::filter, transform_view,\n\tviews::transform, take_view, views::take, take_while_view,\n\tviews::take_while, drop_view, views::drop, join_view, views::join,\n\t__detail::require_constant, __detail::tiny_range, split_view,\n\tviews::split, views::_Counted, views::counted, common_view,\n\tviews::common, reverse_view, views::reverse,\n\tviews::__detail::__is_reversible_subrange,\n\tviews::__detail::__is_reverse_view, reverse_view, views::reverse,\n\t__detail::__has_tuple_element, elements_view, views::elements,\n\tviews::keys, views::values): Define.\n\t* testsuite/std/ranges/adaptors/all.cc: New test.\n\t* testsuite/std/ranges/adaptors/common.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/counted.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/drop.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/drop_while.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/elements.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/filter.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/join.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/reverse.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/split.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/take.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/take_while.cc: Likewise.\n\t* testsuite/std/ranges/adaptors/transform.cc: Likewise.", "tree": {"sha": "894b68bbe8f13d3479116d1d7150f1b64d664a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/894b68bbe8f13d3479116d1d7150f1b64d664a38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cba9ef069e58eac00f30489d3ef21390caee6e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba9ef069e58eac00f30489d3ef21390caee6e45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cba9ef069e58eac00f30489d3ef21390caee6e45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cba9ef069e58eac00f30489d3ef21390caee6e45/comments", "author": null, "committer": null, "parents": [{"sha": "0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d57370c9cc3c1fb68be96b8cc15b92496c4dd21"}], "stats": {"total": 3536, "additions": 3531, "deletions": 5}, "files": [{"sha": "2903074dabefd7f149427ff987baa408c6d60a05", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -1,3 +1,38 @@\n+2020-02-07  Patrick Palka  <ppalka@redhat.com>\n+\n+\tImplement C++20 range adaptors\n+\t* include/std/ranges: Include <bits/refwrap.h> and <tuple>.\n+\t(subrange::_S_store_size): Mark as const instead of constexpr to\n+\tavoid what seems to be a bug in GCC.\n+\t(__detail::__box): Give it defaulted copy and move constructors.\n+\t(views::_Single::operator()): Mark constexpr.\n+\t(views::_Iota::operator()): Mark constexpr.\n+\t(__detail::Empty): Define.\n+\t(views::_RangeAdaptor, views::_RangeAdaptorClosure, ref_view, all_view,\n+\tviews::all, filter_view, views::filter, transform_view,\n+\tviews::transform, take_view, views::take, take_while_view,\n+\tviews::take_while, drop_view, views::drop, join_view, views::join,\n+\t__detail::require_constant, __detail::tiny_range, split_view,\n+\tviews::split, views::_Counted, views::counted, common_view,\n+\tviews::common, reverse_view, views::reverse,\n+\tviews::__detail::__is_reversible_subrange,\n+\tviews::__detail::__is_reverse_view, reverse_view, views::reverse,\n+\t__detail::__has_tuple_element, elements_view, views::elements,\n+\tviews::keys, views::values): Define.\n+\t* testsuite/std/ranges/adaptors/all.cc: New test.\n+\t* testsuite/std/ranges/adaptors/common.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/counted.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/drop.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/drop_while.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/elements.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/filter.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/join.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/reverse.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/split.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/take.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/take_while.cc: Likewise.\n+\t* testsuite/std/ranges/adaptors/transform.cc: Likewise.\n+\n 2020-02-07  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* libsupc++/compare (__cmp_cat::type): Define typedef for underlying"}, {"sha": "9f4fa3414d0c7c7c747cf41eed8e64b8f630b9a5", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 2400, "deletions": 5, "changes": 2405, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -38,11 +38,13 @@\n \n #if __cpp_lib_concepts\n \n+#include <bits/refwrap.h>\n #include <compare>\n #include <initializer_list>\n #include <iterator>\n #include <limits>\n #include <optional>\n+#include <tuple>\n \n /**\n  * @defgroup ranges Ranges\n@@ -255,7 +257,8 @@ namespace ranges\n     class subrange : public view_interface<subrange<_It, _Sent, _Kind>>\n     {\n     private:\n-      static constexpr bool _S_store_size\n+      // XXX: gcc complains when using constexpr here\n+      static const bool _S_store_size\n \t= _Kind == subrange_kind::sized && !sized_sentinel_for<_Sent, _It>;\n \n       _It _M_begin = _It();\n@@ -507,6 +510,9 @@ namespace ranges\n \t: std::optional<_Tp>{std::in_place}\n \t{ }\n \n+\t__box(const __box&) = default;\n+\t__box(__box&&) = default;\n+\n \tusing std::optional<_Tp>::operator=;\n \n \t__box&\n@@ -922,7 +928,7 @@ namespace views\n   struct _Single\n   {\n     template<typename _Tp>\n-      auto\n+      constexpr auto\n       operator()(_Tp&& __e) const\n       { return single_view{std::forward<_Tp>(__e)}; }\n   };\n@@ -932,20 +938,2409 @@ namespace views\n   struct _Iota\n   {\n     template<typename _Tp>\n-      auto\n+      constexpr auto\n       operator()(_Tp&& __e) const\n       { return iota_view{std::forward<_Tp>(__e)}; }\n \n     template<typename _Tp, typename _Up>\n-      auto\n+      constexpr auto\n       operator()(_Tp&& __e, _Up&& __f) const\n       { return iota_view{std::forward<_Tp>(__e), std::forward<_Tp>(__f)}; }\n   };\n \n   inline constexpr _Iota iota{};\n+} // namespace views\n+\n+namespace __detail\n+{\n+  struct _Empty { };\n+} // namespace __detail\n+\n+namespace views\n+{\n+  namespace __adaptor\n+  {\n+    template<typename _Callable>\n+      struct _RangeAdaptorClosure;\n+\n+    template<typename _Callable>\n+      struct _RangeAdaptor\n+      {\n+      protected:\n+\t[[no_unique_address]]\n+\t  conditional_t<!is_default_constructible_v<_Callable>,\n+\t\t\t_Callable, __detail::_Empty> _M_callable;\n+\n+      public:\n+\tconstexpr\n+\t_RangeAdaptor(const _Callable& = {})\n+\t  requires is_default_constructible_v<_Callable>\n+\t{ }\n+\n+\tconstexpr\n+\t_RangeAdaptor(_Callable __callable)\n+\t  requires (!is_default_constructible_v<_Callable>)\n+\t  : _M_callable(std::move(__callable))\n+\t{ }\n+\n+\ttemplate<typename... _Args>\n+\t  requires (sizeof...(_Args) >= 1)\n+\t  constexpr auto\n+\t  operator()(_Args&&... __args) const\n+\t  {\n+\t    if constexpr (is_invocable_v<_Callable, _Args...>)\n+\t      {\n+\t\tstatic_assert(sizeof...(_Args) != 1,\n+\t\t\t      \"a _RangeAdaptor that accepts only one argument \"\n+\t\t\t      \"should be defined as a _RangeAdaptorClosure\");\n+\t\treturn _Callable{}(std::forward<_Args>(__args)...);\n+\t      }\n+\t    else\n+\t      {\n+\t\tauto __closure = [__args...] <typename _Range> (_Range&& __r) {\n+\t\t  return _Callable{}(std::forward<_Range>(__r), __args...);\n+\t\t};\n+\t\tusing _ClosureType = decltype(__closure);\n+\t\treturn _RangeAdaptorClosure<_ClosureType>(std::move(__closure));\n+\t      }\n+\t  }\n+      };\n+\n+    template<typename _Callable>\n+      struct _RangeAdaptorClosure : public _RangeAdaptor<_Callable>\n+      {\n+\tusing _RangeAdaptor<_Callable>::_RangeAdaptor;\n+\n+\ttemplate<viewable_range _Range>\n+\t  requires requires { declval<_Callable>()(declval<_Range>()); }\n+\t  constexpr auto\n+\t  operator()(_Range&& __r) const\n+\t  {\n+\t    if constexpr (is_default_constructible_v<_Callable>)\n+\t      return _Callable{}(std::forward<_Range>(__r));\n+\t    else\n+\t      return this->_M_callable(std::forward<_Range>(__r));\n+\t  }\n+\n+\ttemplate<viewable_range _Range>\n+\t  requires requires { declval<_Callable>()(declval<_Range>()); }\n+\t  friend constexpr auto\n+\t  operator|(_Range&& __r, const _RangeAdaptorClosure& __o)\n+\t  { return __o(std::forward<_Range>(__r)); }\n \n+\ttemplate<typename _Tp>\n+\t  friend constexpr auto\n+\t  operator|(const _RangeAdaptorClosure<_Tp>& __x,\n+\t\t    const _RangeAdaptorClosure& __y)\n+\t  {\n+\t    if constexpr (is_default_constructible_v<_Tp>\n+\t\t\t  && is_default_constructible_v<_Callable>)\n+\t      {\n+\t\tauto __closure = [] <typename _Up> (_Up&& __e) {\n+\t\t  return std::forward<_Up>(__e) | decltype(__x){} | decltype(__y){};\n+\t\t};\n+\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n+\t      }\n+\t    else if constexpr (is_default_constructible_v<_Tp>\n+\t\t\t       && !is_default_constructible_v<_Callable>)\n+\t      {\n+\t\tauto __closure = [__y] <typename _Up> (_Up&& __e) {\n+\t\t  return std::forward<_Up>(__e) | decltype(__x){} | __y;\n+\t\t};\n+\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n+\t      }\n+\t    else if constexpr (!is_default_constructible_v<_Tp>\n+\t\t\t       && is_default_constructible_v<_Callable>)\n+\t      {\n+\t\tauto __closure = [__x] <typename _Up> (_Up&& __e) {\n+\t\t  return std::forward<_Up>(__e) | __x | decltype(__y){};\n+\t\t};\n+\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n+\t      }\n+\t    else\n+\t      {\n+\t\tauto __closure = [__x, __y] <typename _Up> (_Up&& __e) {\n+\t\t  return std::forward<_Up>(__e) | __x | __y;\n+\t\t};\n+\t\treturn _RangeAdaptorClosure<decltype(__closure)>(__closure);\n+\t      }\n+\t  }\n+      };\n+\n+    template<typename _Callable>\n+      _RangeAdaptorClosure(_Callable) -> _RangeAdaptorClosure<_Callable>;\n+  } // namespace __adaptor\n } // namespace views\n-} // namespace ranges\n+\n+  template<range _Range> requires is_object_v<_Range>\n+    class ref_view : public view_interface<ref_view<_Range>>\n+    {\n+    private:\n+      _Range* _M_r = nullptr;\n+\n+      static void _S_fun(_Range&); // not defined\n+      static void _S_fun(_Range&&) = delete;\n+\n+    public:\n+      constexpr\n+      ref_view() noexcept = default;\n+\n+      template<__detail::__not_same_as<ref_view> _Tp>\n+\trequires convertible_to<_Tp, _Range&>\n+\t  && requires { _S_fun(declval<_Tp>()); }\n+\tconstexpr\n+\tref_view(_Tp&& __t)\n+\t  : _M_r(std::__addressof(static_cast<_Range&>(std::forward<_Tp>(__t))))\n+\t{ }\n+\n+      constexpr _Range&\n+      base() const\n+      { return *_M_r; }\n+\n+      constexpr iterator_t<_Range>\n+      begin() const\n+      { return ranges::begin(*_M_r); }\n+\n+      constexpr sentinel_t<_Range>\n+      end() const\n+      { return ranges::end(*_M_r); }\n+\n+      constexpr bool\n+      empty() const requires requires { ranges::empty(*_M_r); }\n+      { return ranges::empty(*_M_r); }\n+\n+      constexpr auto\n+      size() const requires sized_range<_Range>\n+      { return ranges::size(*_M_r); }\n+\n+      constexpr auto\n+      data() const requires contiguous_range<_Range>\n+      { return ranges::data(*_M_r); }\n+    };\n+\n+  template<typename _Range>\n+    ref_view(_Range&) -> ref_view<_Range>;\n+\n+  template<typename _Tp>\n+    inline constexpr bool enable_safe_range<ref_view<_Tp>> = true;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptorClosure all\n+      = [] <viewable_range _Range> (_Range&& __r)\n+      {\n+\tif constexpr (view<decay_t<_Range>>)\n+\t  return std::forward<_Range>(__r);\n+\telse if constexpr (requires { ref_view{std::forward<_Range>(__r)}; })\n+\t  return ref_view{std::forward<_Range>(__r)};\n+\telse\n+\t  return subrange{std::forward<_Range>(__r)};\n+      };\n+  } // namespace views\n+\n+  template<viewable_range _Range>\n+    using all_view = decltype(views::all(declval<_Range>()));\n+\n+  // XXX: the following algos are copied from ranges_algo.h to avoid a circular\n+  // dependency with that header.\n+  namespace __detail\n+  {\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr _Iter\n+      find_if(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})\n+      {\n+\twhile (__first != __last\n+\t    && !(bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n+\t  ++__first;\n+\treturn __first;\n+      }\n+\n+    template<input_iterator _Iter, sentinel_for<_Iter> _Sent,\n+\t     typename _Proj = identity,\n+\t     indirect_unary_predicate<projected<_Iter, _Proj>> _Pred>\n+      constexpr _Iter\n+      find_if_not(_Iter __first, _Sent __last, _Pred __pred, _Proj __proj = {})\n+      {\n+\twhile (__first != __last\n+\t    && (bool)std::__invoke(__pred, std::__invoke(__proj, *__first)))\n+\t  ++__first;\n+\treturn __first;\n+      }\n+\n+    template<typename _Tp, typename _Proj = identity,\n+\t     indirect_strict_weak_order<projected<const _Tp*, _Proj>>\n+\t       _Comp = ranges::less>\n+      constexpr const _Tp&\n+      min(const _Tp& __a, const _Tp& __b, _Comp __comp = {}, _Proj __proj = {})\n+      {\n+\tif (std::__invoke(std::move(__comp),\n+\t\t\t  std::__invoke(__proj, __b),\n+\t\t\t  std::__invoke(__proj, __a)))\n+\t  return __b;\n+\telse\n+\t  return __a;\n+      }\n+\n+    template<input_iterator _Iter1, sentinel_for<_Iter1> _Sent1,\n+\t     input_iterator _Iter2, sentinel_for<_Iter2> _Sent2,\n+\t     typename _Pred = ranges::equal_to,\n+\t     typename _Proj1 = identity, typename _Proj2 = identity>\n+      requires indirectly_comparable<_Iter1, _Iter2, _Pred, _Proj1, _Proj2>\n+      constexpr pair<_Iter1, _Iter2>\n+      mismatch(_Iter1 __first1, _Sent1 __last1, _Iter2 __first2, _Sent2 __last2,\n+\t       _Pred __pred = {}, _Proj1 __proj1 = {}, _Proj2 __proj2 = {})\n+      {\n+\twhile (__first1 != __last1 && __first2 != __last2\n+\t       && (bool)std::__invoke(__pred,\n+\t\t\t\t      std::__invoke(__proj1, *__first1),\n+\t\t\t\t      std::__invoke(__proj2, *__first2)))\n+\t{\n+\t  ++__first1;\n+\t  ++__first2;\n+\t}\n+\treturn { std::move(__first1), std::move(__first2) };\n+      }\n+  } // namespace __detail\n+\n+  template<input_range _Vp,\n+\t   indirect_unary_predicate<iterator_t<_Vp>> _Pred>\n+    requires view<_Vp> && is_object_v<_Pred>\n+    class filter_view : public view_interface<filter_view<_Vp, _Pred>>\n+    {\n+    private:\n+      struct _Sentinel;\n+\n+      struct _Iterator\n+      {\n+      private:\n+\tstatic constexpr auto\n+\t_S_iter_concept()\n+\t{\n+\t  if constexpr (bidirectional_range<_Vp>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (forward_range<_Vp>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return input_iterator_tag{};\n+\t}\n+\n+\tstatic constexpr auto\n+\t_S_iter_cat()\n+\t{\n+\t  using _Cat = iterator_traits<iterator_t<_Vp>>::iterator_category;\n+\t  if constexpr (derived_from<_Cat, bidirectional_iterator_tag>)\n+\t    return bidirectional_iterator_tag{};\n+\t  else if constexpr (derived_from<_Cat, forward_iterator_tag>)\n+\t    return forward_iterator_tag{};\n+\t  else\n+\t    return _Cat{};\n+\t}\n+\n+\tfriend filter_view;\n+\n+\titerator_t<_Vp> _M_current = iterator_t<_Vp>();\n+\tfilter_view* _M_parent = nullptr;\n+\n+      public:\n+\tusing iterator_concept = decltype(_S_iter_concept());\n+\tusing iterator_category = decltype(_S_iter_cat());\n+\tusing value_type = range_value_t<_Vp>;\n+\tusing difference_type = range_difference_t<_Vp>;\n+\n+\t_Iterator() = default;\n+\n+\tconstexpr\n+\t_Iterator(filter_view& __parent, iterator_t<_Vp> __current)\n+\t  : _M_current(std::move(__current)),\n+\t    _M_parent(std::__addressof(__parent))\n+\t{ }\n+\n+\tconstexpr iterator_t<_Vp>\n+\tbase() const &\n+\t  requires copyable<iterator_t<_Vp>>\n+\t{ return _M_current; }\n+\n+\tconstexpr iterator_t<_Vp>\n+\tbase() &&\n+\t{ return std::move(_M_current); }\n+\n+\tconstexpr range_reference_t<_Vp>\n+\toperator*() const\n+\t{ return *_M_current; }\n+\n+\tconstexpr iterator_t<_Vp>\n+\toperator->() const\n+\t  requires __detail::__has_arrow<iterator_t<_Vp>>\n+\t    && copyable<iterator_t<_Vp>>\n+\t{ return _M_current; }\n+\n+\tconstexpr _Iterator&\n+\toperator++()\n+\t{\n+\t  _M_current = __detail::find_if(std::move(++_M_current),\n+\t\t\t\t\t ranges::end(_M_parent->_M_base),\n+\t\t\t\t\t std::ref(*_M_parent->_M_pred));\n+\t  return *this;\n+\t}\n+\n+\tconstexpr void\n+\toperator++(int)\n+\t{ ++*this; }\n+\n+\tconstexpr _Iterator\n+\toperator++(int) requires forward_range<_Vp>\n+\t{\n+\t  auto __tmp = *this;\n+\t  ++*this;\n+\t  return __tmp;\n+\t}\n+\n+\tconstexpr _Iterator&\n+\toperator--() requires bidirectional_range<_Vp>\n+\t{\n+\t  do\n+\t    --_M_current;\n+\t  while (!std::__invoke(*_M_parent->_M_pred, *_M_current));\n+\t  return *this;\n+\t}\n+\n+\tconstexpr _Iterator\n+\toperator--(int) requires bidirectional_range<_Vp>\n+\t{\n+\t  auto __tmp = *this;\n+\t  --*this;\n+\t  return __tmp;\n+\t}\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Iterator& __y)\n+\t  requires equality_comparable<iterator_t<_Vp>>\n+\t{ return __x._M_current == __y._M_current; }\n+\n+\tfriend constexpr range_rvalue_reference_t<_Vp>\n+\titer_move(const _Iterator& __i)\n+\t  noexcept(noexcept(ranges::iter_move(__i._M_current)))\n+\t{ return ranges::iter_move(__i._M_current); }\n+\n+\tfriend constexpr void\n+\titer_swap(const _Iterator& __x, const _Iterator& __y)\n+\t  noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n+\t  requires indirectly_swappable<iterator_t<_Vp>>\n+\t{ ranges::iter_swap(__x._M_current, __y._M_current); }\n+      };\n+\n+      struct _Sentinel\n+      {\n+      private:\n+\tsentinel_t<_Vp> _M_end = sentinel_t<_Vp>();\n+\n+\tconstexpr bool\n+\t__equal(const _Iterator& __i) const\n+\t{ return __i._M_current == _M_end; }\n+\n+      public:\n+\t_Sentinel() = default;\n+\n+\tconstexpr explicit\n+\t_Sentinel(filter_view& __parent)\n+\t  : _M_end(ranges::end(__parent._M_base))\n+\t{ }\n+\n+\tconstexpr sentinel_t<_Vp>\n+\tbase() const\n+\t{ return _M_end; }\n+\n+\tfriend constexpr bool\n+\toperator==(const _Iterator& __x, const _Sentinel& __y)\n+\t{ return __y.__equal(__x); }\n+      };\n+\n+      _Vp _M_base = _Vp();\n+      __detail::__box<_Pred> _M_pred;\n+\n+    public:\n+      filter_view() = default;\n+\n+      constexpr\n+      filter_view(_Vp __base, _Pred __pred)\n+\t: _M_base(std::move(__base)), _M_pred(std::move(__pred))\n+      { }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<input_range _Range>\n+\trequires viewable_range<_Range>\n+\t  && constructible_from<_Vp, all_view<_Range>>\n+\tconstexpr\n+\tfilter_view(_Range&& __r, _Pred __pred)\n+\t  : _M_base(views::all(std::forward<_Range>(__r))),\n+\t    _M_pred(std::move(__pred))\n+\t{ }\n+      */\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr _Iterator\n+      begin()\n+      {\n+\t// XXX: we need to cache the result here as per [range.filter.view]\n+\t__glibcxx_assert(_M_pred.has_value());\n+\treturn {*this, __detail::find_if(ranges::begin(_M_base),\n+\t\t\t\t\t ranges::end(_M_base),\n+\t\t\t\t\t std::ref(*_M_pred))};\n+      }\n+\n+      constexpr auto\n+      end()\n+      {\n+\tif constexpr (common_range<_Vp>)\n+\t  return _Iterator{*this, ranges::end(_M_base)};\n+\telse\n+\t  return _Sentinel{*this};\n+      }\n+    };\n+\n+  template<typename _Range, typename _Pred>\n+    filter_view(_Range&&, _Pred) -> filter_view<all_view<_Range>, _Pred>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor filter\n+      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n+      {\n+\treturn filter_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n+      };\n+  } // namespace views\n+\n+  template<input_range _Vp, copy_constructible _Fp>\n+    requires view<_Vp> && is_object_v<_Fp>\n+      && regular_invocable<_Fp&, range_reference_t<_Vp>>\n+    class transform_view : public view_interface<transform_view<_Vp, _Fp>>\n+    {\n+    private:\n+      template<bool _Const>\n+\tstruct _Sentinel;\n+\n+      template<bool _Const>\n+\tstruct _Iterator\n+\t{\n+\tprivate:\n+\t  using _Parent\n+\t    = conditional_t<_Const, const transform_view, transform_view>;\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  static constexpr auto\n+\t  _S_iter_concept()\n+\t  {\n+\t    if constexpr (random_access_range<_Vp>)\n+\t      return random_access_iterator_tag{};\n+\t    else if constexpr (bidirectional_range<_Vp>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (forward_range<_Vp>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return input_iterator_tag{};\n+\t  }\n+\n+\t  static constexpr auto\n+\t  _S_iter_cat()\n+\t  {\n+\t    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t    if constexpr (derived_from<_Cat, contiguous_iterator_tag>)\n+\t      return random_access_iterator_tag{};\n+\t    else\n+\t      return _Cat{};\n+\t  }\n+\n+\t  static constexpr decltype(auto)\n+\t  __iter_move(const _Iterator& __i = {})\n+\t    noexcept(noexcept(std::__invoke(*__i._M_parent->_M_fun,\n+\t\t\t\t\t    *__i._M_current)))\n+\t  {\n+\t    if constexpr (is_lvalue_reference_v<decltype(*__i)>)\n+\t      return std::move(*__i);\n+\t    else\n+\t      return *__i;\n+\t  }\n+\n+\t  iterator_t<_Base> _M_current = iterator_t<_Base>();\n+\t  _Parent* _M_parent = nullptr;\n+\n+\tpublic:\n+\t  using iterator_concept = decltype(_S_iter_concept());\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t  using value_type\n+\t    = remove_cvref_t<invoke_result_t<_Fp&, range_reference_t<_Base>>>;\n+\t  using difference_type = range_difference_t<_Base>;\n+\n+\t  _Iterator() = default;\n+\n+\t  constexpr\n+\t  _Iterator(_Parent& __parent, iterator_t<_Base> __current)\n+\t    : _M_current(std::move(__current)),\n+\t      _M_parent(std::__addressof(__parent))\n+\t  { }\n+\n+\t  constexpr\n+\t  _Iterator(_Iterator<!_Const> __i)\n+\t    requires _Const\n+\t      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n+\t    : _M_current(std::move(__i._M_current)), _M_parent(__i._M_parent)\n+\t  { }\n+\n+\t  constexpr iterator_t<_Base>\n+\t  base() const &\n+\t    requires copyable<iterator_t<_Base>>\n+\t  { return _M_current; }\n+\n+\t  constexpr iterator_t<_Base>\n+\t  base() &&\n+\t  { return std::move(_M_current); }\n+\n+\t  constexpr decltype(auto)\n+\t  operator*() const\n+\t  { return std::__invoke(*_M_parent->_M_fun, *_M_current); }\n+\n+\t  constexpr _Iterator&\n+\t  operator++()\n+\t  {\n+\t    ++_M_current;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr void\n+\t  operator++(int)\n+\t  { ++_M_current; }\n+\n+\t  constexpr _Iterator\n+\t  operator++(int) requires forward_range<_Base>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    ++*this;\n+\t    return __tmp;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator--() requires bidirectional_range<_Base>\n+\t  {\n+\t    --_M_current;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr _Iterator\n+\t  operator--(int) requires bidirectional_range<_Base>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    --*this;\n+\t    return __tmp;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator+=(difference_type __n) requires random_access_range<_Base>\n+\t  {\n+\t    _M_current += __n;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator-=(difference_type __n) requires random_access_range<_Base>\n+\t  {\n+\t    _M_current -= __n;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr decltype(auto)\n+\t  operator[](difference_type __n) const\n+\t    requires random_access_range<_Base>\n+\t  { return std::__invoke(*_M_parent->_M_fun, _M_current[__n]); }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator& __x, const _Iterator& __y)\n+\t    requires equality_comparable<iterator_t<_Base>>\n+\t  { return __x._M_current == __y._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator<(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __x._M_current < __y._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator>(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __y < __x; }\n+\n+\t  friend constexpr bool\n+\t  operator<=(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return !(__y < __x); }\n+\n+\t  friend constexpr bool\n+\t  operator>=(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return !(__x < __y); }\n+\n+#ifdef __cpp_lib_three_way_comparison\n+\t  friend constexpr auto\n+\t  operator<=>(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t      && three_way_comparable<iterator_t<_Base>>\n+\t  { return __x._M_current <=> __y._M_current; }\n+#endif\n+\n+\t  friend constexpr _Iterator\n+\t  operator+(_Iterator __i, difference_type __n)\n+\t    requires random_access_range<_Base>\n+\t  { return {*__i._M_parent, __i._M_current + __n}; }\n+\n+\t  friend constexpr _Iterator\n+\t  operator+(difference_type __n, _Iterator __i)\n+\t    requires random_access_range<_Base>\n+\t  { return {*__i._M_parent, __i._M_current + __n}; }\n+\n+\t  friend constexpr _Iterator\n+\t  operator-(_Iterator __i, difference_type __n)\n+\t    requires random_access_range<_Base>\n+\t  { return {*__i._M_parent, __i._M_current - __n}; }\n+\n+\t  friend constexpr difference_type\n+\t  operator-(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __x._M_current - __y._M_current; }\n+\n+\t  friend constexpr decltype(auto)\n+\t  iter_move(const _Iterator& __i) noexcept(noexcept(__iter_move()))\n+\t  { return __iter_move(__i); }\n+\n+\t  friend constexpr void\n+\t  iter_swap(const _Iterator& __x, const _Iterator& __y)\n+\t    noexcept(noexcept(ranges::iter_swap(__x._M_current, __y._M_current)))\n+\t    requires indirectly_swappable<iterator_t<_Base>>\n+\t  { return ranges::iter_swap(__x._M_current, __y._M_current); }\n+\n+\t  friend _Sentinel<_Const>;\n+\t};\n+\n+      template<bool _Const>\n+\tstruct _Sentinel\n+\t{\n+\tprivate:\n+\t  using _Parent\n+\t    = conditional_t<_Const, const transform_view, transform_view>;\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  constexpr range_difference_t<_Base>\n+\t  __distance_from(const _Iterator<_Const>& __i) const\n+\t  { return _M_end - __i._M_current; }\n+\n+\t  constexpr bool\n+\t  __equal(const _Iterator<_Const>& __i) const\n+\t  { return __i._M_current == _M_end; }\n+\n+\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\n+\tpublic:\n+\t  _Sentinel() = default;\n+\n+\t  constexpr explicit\n+\t  _Sentinel(sentinel_t<_Base> __end)\n+\t    : _M_end(__end)\n+\t  { }\n+\n+\t  constexpr\n+\t  _Sentinel(_Sentinel<!_Const> __i)\n+\t    requires _Const\n+\t      && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+\t    : _M_end(std::move(__i._M_end))\n+\t  { }\n+\n+\t  constexpr sentinel_t<_Base>\n+\t  base() const\n+\t  { return _M_end; }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator<_Const>& __x, const _Sentinel& __y)\n+\t  { return __y.__equal(__x); }\n+\n+\t  friend constexpr range_difference_t<_Base>\n+\t  operator-(const _Iterator<_Const>& __x, const _Sentinel& __y)\n+\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+\t  { return -__y.__distance_from(__x); }\n+\n+\t  friend constexpr range_difference_t<_Base>\n+\t  operator-(const _Sentinel& __y, const _Iterator<_Const>& __x)\n+\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+\t  { return __y.__distance_from(__x); }\n+\t};\n+\n+      _Vp _M_base = _Vp();\n+      __detail::__box<_Fp> _M_fun;\n+\n+    public:\n+      transform_view() = default;\n+\n+      constexpr\n+      transform_view(_Vp __base, _Fp __fun)\n+\t: _M_base(std::move(__base)), _M_fun(std::move(__fun))\n+      { }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<input_range _Range>\n+\trequires viewable_range<_Range>\n+\t  && constructible_from<_Vp, all_view<_Range>>\n+\tconstexpr\n+\ttransform_view(_Range&& __r, _Fp __fun)\n+\t  : _M_base(views::all(std::forward<_Range>(__r)))\n+\t{\n+\t}\n+\t*/\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base ; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr _Iterator<false>\n+      begin()\n+      { return _Iterator<false>{*this, ranges::begin(_M_base)}; }\n+\n+      constexpr _Iterator<true>\n+      begin() const\n+\trequires range<const _Vp>\n+\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n+      { return _Iterator<true>{*this, ranges::begin(_M_base)}; }\n+\n+      constexpr _Sentinel<false>\n+      end()\n+      { return _Sentinel<false>{ranges::end(_M_base)}; }\n+\n+      constexpr _Iterator<false>\n+      end() requires common_range<_Vp>\n+      { return _Iterator<false>{*this, ranges::end(_M_base)}; }\n+\n+      constexpr _Sentinel<true>\n+      end() const\n+\trequires range<const _Vp>\n+\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n+      { return _Sentinel<true>{ranges::end(_M_base)}; }\n+\n+      constexpr _Iterator<true>\n+      end() const\n+\trequires common_range<const _Vp>\n+\t  && regular_invocable<const _Fp&, range_reference_t<const _Vp>>\n+      { return _Iterator<true>{*this, ranges::end(_M_base)}; }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      { return ranges::size(_M_base); }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      { return ranges::size(_M_base); }\n+    };\n+\n+  template<typename _Range, typename _Fp>\n+    transform_view(_Range&&, _Fp) -> transform_view<all_view<_Range>, _Fp>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor transform\n+      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)\n+      {\n+\treturn transform_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};\n+      };\n+  } // namespace views\n+\n+  template<view _Vp>\n+    class take_view : public view_interface<take_view<_Vp>>\n+    {\n+    private:\n+      template<bool _Const>\n+\tstruct _Sentinel\n+\t{\n+\tprivate:\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\t  using _CI = counted_iterator<iterator_t<_Base>>;\n+\n+\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\n+\tpublic:\n+\t  _Sentinel() = default;\n+\n+\t  constexpr explicit\n+\t  _Sentinel(sentinel_t<_Base> __end)\n+\t    : _M_end(__end)\n+\t  { }\n+\n+\t  constexpr\n+\t  _Sentinel(_Sentinel<!_Const> __s)\n+\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+\t    : _M_end(std::move(__s._M_end))\n+\t  { }\n+\n+\t  constexpr sentinel_t<_Base>\n+\t  base() const\n+\t  { return _M_end; }\n+\n+\t  friend constexpr bool operator==(const _CI& __y, const _Sentinel& __x)\n+\t  { return __y.count() == 0 || __y.base() == __x._M_end; }\n+\t};\n+\n+      _Vp _M_base = _Vp();\n+      range_difference_t<_Vp> _M_count = 0;\n+\n+    public:\n+      take_view() = default;\n+\n+      constexpr\n+      take_view(_Vp base, range_difference_t<_Vp> __count)\n+\t: _M_base(std::move(base)), _M_count(std::move(__count))\n+      { }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<viewable_range _Range>\n+\trequires constructible_from<_Vp, all_view<_Range>>\n+      constexpr\n+      take_view(_Range&& __r, range_difference_t<_Vp> __count)\n+\t: _M_base(views::all(std::forward<_Range>(__r))), _M_count(__count)\n+      { }\n+      */\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin() requires (!__detail::__simple_view<_Vp>)\n+      {\n+\tif constexpr (sized_range<_Vp>)\n+\t  {\n+\t    if constexpr (random_access_range<_Vp>)\n+\t      return ranges::begin(_M_base);\n+\t    else\n+\t      return counted_iterator{ranges::begin(_M_base), size()};\n+\t  }\n+\telse\n+\t  return counted_iterator{ranges::begin(_M_base), _M_count};\n+      }\n+\n+      constexpr auto\n+      begin() const requires range<const _Vp>\n+      {\n+\tif constexpr (sized_range<const _Vp>)\n+\t  {\n+\t    if constexpr (random_access_range<const _Vp>)\n+\t      return ranges::begin(_M_base);\n+\t    else\n+\t      return counted_iterator{ranges::begin(_M_base), size()};\n+\t  }\n+\telse\n+\t  return counted_iterator{ranges::begin(_M_base), _M_count};\n+      }\n+\n+      constexpr auto\n+      end() requires (!__detail::__simple_view<_Vp>)\n+      {\n+\tif constexpr (sized_range<_Vp>)\n+\t  {\n+\t    if constexpr (random_access_range<_Vp>)\n+\t      return ranges::begin(_M_base) + size();\n+\t    else\n+\t      return default_sentinel;\n+\t  }\n+\telse\n+\t  return _Sentinel<false>{ranges::end(_M_base)};\n+      }\n+\n+      constexpr auto\n+      end() const requires range<const _Vp>\n+      {\n+\tif constexpr (sized_range<const _Vp>)\n+\t  {\n+\t    if constexpr (random_access_range<const _Vp>)\n+\t      return ranges::begin(_M_base) + size();\n+\t    else\n+\t      return default_sentinel;\n+\t  }\n+\telse\n+\t  return _Sentinel<true>{ranges::end(_M_base)};\n+      }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      {\n+\tauto __n = ranges::size(_M_base);\n+\treturn __detail::min(__n, static_cast<decltype(__n)>(_M_count));\n+      }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      {\n+\tauto __n = ranges::size(_M_base);\n+\treturn __detail::min(__n, static_cast<decltype(__n)>(_M_count));\n+      }\n+    };\n+\n+  template<range _Range>\n+    take_view(_Range&&, range_difference_t<_Range>)\n+      -> take_view<all_view<_Range>>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor take\n+      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)\n+      {\n+\treturn take_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n+      };\n+  } // namespace views\n+\n+  template<view _Vp, typename _Pred>\n+    requires input_range<_Vp> && is_object_v<_Pred>\n+      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>\n+    class take_while_view : public view_interface<take_while_view<_Vp, _Pred>>\n+    {\n+      template<bool _Const>\n+\tstruct _Sentinel\n+\t{\n+\tprivate:\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\t  const _Pred* _M_pred = nullptr;\n+\n+\tpublic:\n+\t  _Sentinel() = default;\n+\n+\t  constexpr explicit\n+\t  _Sentinel(sentinel_t<_Base> __end, const _Pred* __pred)\n+\t    : _M_end(__end), _M_pred(__pred)\n+\t  { }\n+\n+\t  constexpr\n+\t  _Sentinel(_Sentinel<!_Const> __s)\n+\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+\t    : _M_end(__s._M_end), _M_pred(__s._M_pred)\n+\t  { }\n+\n+\t  constexpr sentinel_t<_Base>\n+\t  base() const { return _M_end; }\n+\n+\t  friend constexpr bool\n+\t  operator==(const iterator_t<_Base>& __x, const _Sentinel& __y)\n+\t  { return __y._M_end == __x || !std::__invoke(*__y._M_pred, *__x); }\n+\t};\n+\n+      _Vp _M_base;\n+      __detail::__box<_Pred> _M_pred;\n+\n+    public:\n+      take_while_view() = default;\n+\n+      constexpr\n+      take_while_view(_Vp base, _Pred __pred)\n+\t: _M_base(std::move(base)), _M_pred(std::move(__pred))\n+      {\n+      }\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr const _Pred&\n+      pred() const\n+      { return *_M_pred; }\n+\n+      constexpr auto\n+      begin() requires (!__detail::__simple_view<_Vp>)\n+      { return ranges::begin(_M_base); }\n+\n+      constexpr auto\n+      begin() const requires range<const _Vp>\n+      { return ranges::begin(_M_base); }\n+\n+      constexpr auto\n+      end() requires (!__detail::__simple_view<_Vp>)\n+      { return _Sentinel<false>(ranges::end(_M_base),\n+\t\t\t\tstd::__addressof(*_M_pred)); }\n+\n+      constexpr auto\n+      end() const requires range<const _Vp>\n+      { return _Sentinel<true>(ranges::end(_M_base),\n+\t\t\t       std::__addressof(*_M_pred)); }\n+    };\n+\n+  template<typename _Range, typename _Pred>\n+    take_while_view(_Range&&, _Pred)\n+      -> take_while_view<all_view<_Range>, _Pred>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor take_while\n+      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n+      {\n+\treturn take_while_view{std::forward<_Range>(__r), std::forward<_Pred>(__p)};\n+      };\n+  } // namespace views\n+\n+  template<view _Vp>\n+    class drop_view : public view_interface<drop_view<_Vp>>\n+    {\n+    private:\n+      _Vp _M_base;\n+      range_difference_t<_Vp> _M_count;\n+\n+    public:\n+      drop_view() = default;\n+\n+      constexpr\n+      drop_view(_Vp __base, range_difference_t<_Vp> __count)\n+\t: _M_base(std::move(__base)), _M_count(__count)\n+      { __glibcxx_assert(__count >= 0); }\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin() requires (!(__detail::__simple_view<_Vp>\n+\t\t\t  && random_access_range<_Vp>))\n+      {\n+\t// XXX: we need to cache the result here as per [range.drop.view]\n+\treturn ranges::next(ranges::begin(_M_base), _M_count,\n+\t\t\t    ranges::end(_M_base));\n+      }\n+\n+      constexpr auto\n+      begin() const requires random_access_range<const _Vp>\n+      {\n+\treturn ranges::next(ranges::begin(_M_base), _M_count,\n+\t\t\t    ranges::end(_M_base));\n+      }\n+\n+      constexpr auto\n+      end() requires (!__detail::__simple_view<_Vp>)\n+      { return ranges::end(_M_base); }\n+\n+      constexpr auto\n+      end() const requires range<const _Vp>\n+      { return ranges::end(_M_base); }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      {\n+\tconst auto __s = ranges::size(_M_base);\n+\tconst auto __c = static_cast<decltype(__s)>(_M_count);\n+\treturn __s < __c ? 0 : __s - __c;\n+      }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      {\n+\tconst auto __s = ranges::size(_M_base);\n+\tconst auto __c = static_cast<decltype(__s)>(_M_count);\n+\treturn __s < __c ? 0 : __s - __c;\n+      }\n+    };\n+\n+  template<typename _Range>\n+    drop_view(_Range&&, range_difference_t<_Range>)\n+      -> drop_view<all_view<_Range>>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor drop\n+      = [] <viewable_range _Range, typename _Tp> (_Range&& __r, _Tp&& __n)\n+      {\n+\treturn drop_view{std::forward<_Range>(__r), std::forward<_Tp>(__n)};\n+      };\n+  } // namespace views\n+\n+  template<view _Vp, typename _Pred>\n+    requires input_range<_Vp> && is_object_v<_Pred>\n+      && indirect_unary_predicate<const _Pred, iterator_t<_Vp>>\n+    class drop_while_view : public view_interface<drop_while_view<_Vp, _Pred>>\n+    {\n+    private:\n+      _Vp _M_base;\n+      __detail::__box<_Pred> _M_pred;\n+\n+    public:\n+      drop_while_view() = default;\n+\n+      constexpr\n+      drop_while_view(_Vp __base, _Pred __pred)\n+\t: _M_base(std::move(__base)), _M_pred(std::move(__pred))\n+      { }\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr const _Pred&\n+      pred() const\n+      { return *_M_pred; }\n+\n+      constexpr auto\n+      begin()\n+      {\n+\t// XXX: we need to cache the result here as per [range.drop.while.view]\n+\treturn __detail::find_if_not(ranges::begin(_M_base),\n+\t\t\t\t     ranges::end(_M_base),\n+\t\t\t\t     std::cref(*_M_pred));\n+      }\n+\n+      constexpr auto\n+      end()\n+      { return ranges::end(_M_base); }\n+    };\n+\n+  template<typename _Range, typename _Pred>\n+    drop_while_view(_Range&&, _Pred)\n+      -> drop_while_view<all_view<_Range>, _Pred>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor drop_while\n+      = [] <viewable_range _Range, typename _Pred> (_Range&& __r, _Pred&& __p)\n+      {\n+\treturn drop_while_view{std::forward<_Range>(__r),\n+\t\t\t       std::forward<_Pred>(__p)};\n+      };\n+  } // namespace views\n+\n+  template<input_range _Vp>\n+    requires view<_Vp> && input_range<range_reference_t<_Vp>>\n+      && (is_reference_v<range_reference_t<_Vp>>\n+\t  || view<range_value_t<_Vp>>)\n+    class join_view : public view_interface<join_view<_Vp>>\n+    {\n+    private:\n+      using _InnerRange = range_reference_t<_Vp>;\n+\n+      template<bool _Const>\n+\tstruct _Sentinel;\n+\n+      template<bool _Const>\n+\tstruct _Iterator\n+\t{\n+\tprivate:\n+\t  using _Parent = conditional_t<_Const, const join_view, join_view>;\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  static constexpr bool _S_ref_is_glvalue\n+\t    = is_reference_v<range_reference_t<_Base>>;\n+\n+\t  constexpr void\n+\t  _M_satisfy()\n+\t  {\n+\t    auto __update_inner = [this] (range_reference_t<_Base> __x) -> auto&\n+\t    {\n+\t      if constexpr (_S_ref_is_glvalue)\n+\t\treturn __x;\n+\t      else\n+\t\treturn (_M_parent->_M_inner = views::all(std::move(__x)));\n+\t    };\n+\n+\t    for (; _M_outer != ranges::end(_M_parent->_M_base); ++_M_outer)\n+\t      {\n+\t\tauto& inner = __update_inner(*_M_outer);\n+\t\t_M_inner = ranges::begin(inner);\n+\t\tif (_M_inner != ranges::end(inner))\n+\t\t  return;\n+\t      }\n+\n+\t    if constexpr (_S_ref_is_glvalue)\n+\t      _M_inner = iterator_t<range_reference_t<_Base>>();\n+\t  }\n+\n+\t  static constexpr auto\n+\t  _S_iter_concept()\n+\t  {\n+\t    if constexpr (_S_ref_is_glvalue\n+\t\t\t  && bidirectional_range<_Base>\n+\t\t\t  && bidirectional_range<range_reference_t<_Base>>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (_S_ref_is_glvalue\n+\t\t\t       && forward_range<_Base>\n+\t\t\t       && forward_range<range_reference_t<_Base>>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return input_iterator_tag{};\n+\t  }\n+\n+\t  static constexpr auto\n+\t  _S_iter_cat()\n+\t  {\n+\t    using _OuterCat\n+\t      = iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t    using _InnerCat\n+\t      = iterator_traits<iterator_t<range_reference_t<_Base>>>\n+\t\t ::iterator_category;\n+\t    if constexpr (_S_ref_is_glvalue\n+\t\t\t  && derived_from<_OuterCat, bidirectional_iterator_tag>\n+\t\t\t  && derived_from<_InnerCat, bidirectional_iterator_tag>)\n+\t      return bidirectional_iterator_tag{};\n+\t    else if constexpr (_S_ref_is_glvalue\n+\t\t\t       && derived_from<_OuterCat, forward_iterator_tag>\n+\t\t\t       && derived_from<_InnerCat, forward_iterator_tag>)\n+\t      return forward_iterator_tag{};\n+\t    else if constexpr (derived_from<_OuterCat, input_iterator_tag>\n+\t\t\t       && derived_from<_InnerCat, input_iterator_tag>)\n+\t      return input_iterator_tag{};\n+\t    else\n+\t      return output_iterator_tag{};\n+\t  }\n+\n+\t  iterator_t<_Base> _M_outer = iterator_t<_Base>();\n+\t  iterator_t<range_reference_t<_Base>> _M_inner\n+\t    = iterator_t<range_reference_t<_Base>>();\n+\t  _Parent* _M_parent = nullptr;\n+\n+\tpublic:\n+\t  using iterator_concept = decltype(_S_iter_concept());\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t  using value_type = range_value_t<range_reference_t<_Base>>;\n+\t  using difference_type\n+\t    = common_type_t<range_difference_t<_Base>,\n+\t\t\t    range_difference_t<range_reference_t<_Base>>>;\n+\n+\t  _Iterator() = default;\n+\n+\t  // XXX: had to change the type of __outer from iterator_t<_Vp> to\n+\t  // iterator_t<_Base> here, a possible defect in the spec?\n+\t  constexpr\n+\t  _Iterator(_Parent& __parent, iterator_t<_Base> __outer)\n+\t    : _M_outer(std::move(__outer)),\n+\t      _M_parent(std::__addressof(__parent))\n+\t  { _M_satisfy(); }\n+\n+\t  constexpr\n+\t  _Iterator(_Iterator<!_Const> __i)\n+\t    requires _Const\n+\t      && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n+\t      && convertible_to<iterator_t<_InnerRange>,\n+\t\t\t\titerator_t<range_reference_t<_Base>>>\n+\t    : _M_outer(std::move(__i._M_outer)), _M_inner(__i._M_inner),\n+\t      _M_parent(__i._M_parent)\n+\t  { }\n+\n+\t  constexpr decltype(auto)\n+\t  operator*() const\n+\t  { return *_M_inner; }\n+\n+\t  constexpr iterator_t<_Base>\n+\t  operator->() const\n+\t    requires __detail::__has_arrow<iterator_t<_Base>>\n+\t      && copyable<iterator_t<_Base>>\n+\t  { return _M_inner; }\n+\n+\t  constexpr _Iterator&\n+\t  operator++()\n+\t  {\n+\t    auto&& __inner_range = [this] () -> decltype(auto) {\n+\t      if constexpr (_S_ref_is_glvalue)\n+\t\treturn *_M_outer;\n+\t      else\n+\t\treturn _M_parent->_M_inner;\n+\t    }();\n+\t    if (++_M_inner == ranges::end(__inner_range))\n+\t      {\n+\t\t++_M_outer;\n+\t\t_M_satisfy();\n+\t      }\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr void\n+\t  operator++(int)\n+\t  { ++*this; }\n+\n+\t  constexpr _Iterator\n+\t  operator++(int)\n+\t    requires _S_ref_is_glvalue && forward_range<_Base>\n+\t      && forward_range<range_reference_t<_Base>>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    ++*this;\n+\t    return __tmp;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator--()\n+\t    requires _S_ref_is_glvalue && bidirectional_range<_Base>\n+\t      && bidirectional_range<range_reference_t<_Base>>\n+\t  {\n+\t    if (_M_outer == ranges::end(_M_parent->_M_base))\n+\t      _M_inner = ranges::end(*--_M_outer);\n+\t    while (_M_inner == ranges::begin(*_M_outer))\n+\t      _M_inner = ranges::end(*--_M_outer);\n+\t    --_M_inner;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr _Iterator\n+\t  operator--(int)\n+\t    requires _S_ref_is_glvalue && bidirectional_range<_Base>\n+\t      && bidirectional_range<range_reference_t<_Base>>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    --*this;\n+\t    return __tmp;\n+\t  }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator& __x, const _Iterator& __y)\n+\t    requires _S_ref_is_glvalue\n+\t      && equality_comparable<iterator_t<_Base>>\n+\t      && equality_comparable<iterator_t<range_reference_t<_Base>>>\n+\t  {\n+\t    return (__x._M_outer == __y._M_outer\n+\t\t    && __x._M_inner == __y._M_inner);\n+\t  }\n+\n+\t  friend constexpr decltype(auto)\n+\t  iter_move(const _Iterator& __i)\n+\t  noexcept(noexcept(ranges::iter_move(__i._M_inner)))\n+\t  { return ranges::iter_move(__i._M_inner); }\n+\n+\t  friend constexpr void\n+\t  iter_swap(const _Iterator& __x, const _Iterator& __y)\n+\t    noexcept(noexcept(ranges::iter_swap(__x._M_inner, __y._M_inner)))\n+\t  { return ranges::iter_swap(__x._M_inner, __y._M_inner); }\n+\n+\t  friend _Sentinel<_Const>;\n+\t};\n+\n+      template<bool _Const>\n+\tstruct _Sentinel\n+\t{\n+\tprivate:\n+\t  using _Parent = conditional_t<_Const, const join_view, join_view>;\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  constexpr bool\n+\t  __equal(const _Iterator<_Const>& __i) const\n+\t  { return __i._M_outer == _M_end; }\n+\n+\t  sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\n+\tpublic:\n+\t  _Sentinel() = default;\n+\n+\t  constexpr explicit\n+\t  _Sentinel(_Parent& __parent)\n+\t    : _M_end(ranges::end(__parent._M_base))\n+\t  { }\n+\n+\t  constexpr\n+\t  _Sentinel(_Sentinel<!_Const> __s)\n+\t    requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+\t    : _M_end(std::move(__s._M_end))\n+\t  { }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator<_Const>& __x, const _Sentinel& __y)\n+\t  { return __y.__equal(__x); }\n+\t};\n+\n+      _Vp _M_base = _Vp();\n+\n+      // XXX: _M_inner is \"present only when !is_reference_v<_InnerRange>\"\n+      // Applied P3278 and made this field mutable.\n+      [[no_unique_address]] mutable\n+\tconditional_t<!is_reference_v<_InnerRange>,\n+\t\t      all_view<_InnerRange>, __detail::_Empty> _M_inner;\n+\n+    public:\n+      join_view() = default;\n+\n+      constexpr explicit\n+      join_view(_Vp __base)\n+\t: _M_base(std::move(__base))\n+      { }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<input_range _Range>\n+\trequires viewable_range<_Range>\n+\t  && constructible_from<_Vp, all_view<_Range>>\n+      constexpr explicit\n+      join_view(_Range&& __r)\n+\t: _M_base(views::all(std::forward<_Range>(__r)))\n+      { }\n+      */\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin()\n+      {\n+\treturn _Iterator<__detail::__simple_view<_Vp>>{*this,\n+\t\t\t\t\t\t       ranges::begin(_M_base)};\n+      }\n+\n+      constexpr auto\n+      begin() const\n+\trequires input_range<const _Vp>\n+\t  && is_reference_v<range_reference_t<const _Vp>>\n+      {\n+\treturn _Iterator<true>{*this, ranges::begin(_M_base)};\n+      }\n+\n+      constexpr auto\n+      end()\n+      {\n+\tif constexpr (forward_range<_Vp> && is_reference_v<_InnerRange>\n+\t\t      && forward_range<_InnerRange>\n+\t\t      && common_range<_Vp> && common_range<_InnerRange>)\n+\t  return _Iterator<__detail::__simple_view<_Vp>>{*this,\n+\t\t\t\t\t\t\t ranges::end(_M_base)};\n+\telse\n+\t  return _Sentinel<__detail::__simple_view<_Vp>>{*this};\n+      }\n+\n+      constexpr auto\n+      end() const\n+\trequires input_range<const _Vp>\n+\t  && is_reference_v<range_reference_t<const _Vp>>\n+      {\n+\tif constexpr (forward_range<const _Vp>\n+\t\t      && is_reference_v<range_reference_t<const _Vp>>\n+\t\t      && forward_range<range_reference_t<const _Vp>>\n+\t\t      && common_range<const _Vp>\n+\t\t      && common_range<range_reference_t<const _Vp>>)\n+\t  return _Iterator<true>{*this, ranges::end(_M_base)};\n+\telse\n+\t  return _Sentinel<true>{*this};\n+      }\n+    };\n+\n+  template<typename _Range>\n+    explicit join_view(_Range&&) -> join_view<all_view<_Range>>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptorClosure join\n+      = [] <viewable_range _Range> (_Range&& __r)\n+      {\n+\treturn join_view{std::forward<_Range>(__r)};\n+      };\n+  } // namespace views\n+\n+  namespace __detail\n+  {\n+    template<auto>\n+      struct __require_constant;\n+\n+    template<typename _Range>\n+      concept __tiny_range = sized_range<_Range>\n+\t&& requires\n+\t   { typename __require_constant<remove_reference_t<_Range>::size()>; }\n+\t&& (remove_reference_t<_Range>::size() <= 1);\n+  }\n+\n+  template<input_range _Vp, forward_range _Pattern>\n+    requires view<_Vp> && view<_Pattern>\n+      && indirectly_comparable<iterator_t<_Vp>, iterator_t<_Pattern>,\n+\t\t\t       ranges::equal_to>\n+      && (forward_range<_Vp> || __detail::__tiny_range<_Pattern>)\n+    class split_view : public view_interface<split_view<_Vp, _Pattern>>\n+    {\n+    private:\n+      template<bool _Const>\n+\tstruct _InnerIter;\n+\n+      template<bool _Const>\n+\tstruct _OuterIter\n+\t{\n+\tprivate:\n+\t  using _Parent = conditional_t<_Const, const split_view, split_view>;\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  constexpr bool\n+\t  __at_end() const\n+\t  { return _M_current == ranges::end(_M_parent->_M_base); }\n+\n+\t  // XXX: [24.7.11.3.1]\n+\t  //  Many of the following specifications refer to the notional member\n+\t  //  current of outer-iterator.  current is equivalent to current_\u00ad if\n+\t  //  V models forward_range, and parent_->current_\u00ad otherwise.\n+\t  constexpr auto&\n+\t  __current()\n+\t  {\n+\t    if constexpr (forward_range<_Vp>)\n+\t      return _M_current;\n+\t    else\n+\t      return _M_parent->_M_current;\n+\t  }\n+\n+\t  constexpr auto&\n+\t  __current() const\n+\t  {\n+\t    if constexpr (forward_range<_Vp>)\n+\t      return _M_current;\n+\t    else\n+\t      return _M_parent->_M_current;\n+\t  }\n+\n+\t  _Parent* _M_parent = nullptr;\n+\n+\t  // XXX: _M_current is present only if \"V models forward_range\"\n+\t  [[no_unique_address]]\n+\t    conditional_t<forward_range<_Vp>,\n+\t\t\t  iterator_t<_Base>, __detail::_Empty> _M_current;\n+\n+\tpublic:\n+\t  using iterator_concept = conditional_t<forward_range<_Base>,\n+\t\t\t\t\t\t forward_iterator_tag,\n+\t\t\t\t\t\t input_iterator_tag>;\n+\t  using iterator_category = input_iterator_tag;\n+\t  using difference_type = range_difference_t<_Base>;\n+\n+\t  struct value_type : view_interface<value_type>\n+\t  {\n+\t  private:\n+\t    _OuterIter _M_i = _OuterIter();\n+\n+\t  public:\n+\t    value_type() = default;\n+\n+\t    constexpr explicit\n+\t    value_type(_OuterIter __i)\n+\t      : _M_i(std::move(__i))\n+\t    { }\n+\n+\t    constexpr _InnerIter<_Const>\n+\t    begin() const\n+\t      requires copyable<_OuterIter>\n+\t    { return _InnerIter<_Const>{_M_i}; }\n+\n+\t    constexpr _InnerIter<_Const>\n+\t    begin()\n+\t      requires (!copyable<_OuterIter>)\n+\t    { return _InnerIter<_Const>{std::move(_M_i)}; }\n+\n+\t    constexpr default_sentinel_t\n+\t    end() const\n+\t    { return default_sentinel; }\n+\t  };\n+\n+\t  _OuterIter() = default;\n+\n+\t  constexpr explicit\n+\t  _OuterIter(_Parent& __parent) requires (!forward_range<_Base>)\n+\t    : _M_parent(address(__parent))\n+\t  { }\n+\n+\t  constexpr\n+\t  _OuterIter(_Parent& __parent, iterator_t<_Base> __current)\n+\t    requires forward_range<_Base>\n+\t    : _M_parent(std::__addressof(__parent)),\n+\t      _M_current(std::move(__current))\n+\t  { }\n+\n+\t  constexpr\n+\t  _OuterIter(_OuterIter<!_Const> __i)\n+\t    requires _Const\n+\t      && convertible_to<iterator_t<_Vp>, iterator_t<const _Vp>>\n+\t    : _M_parent(__i._M_parent), _M_current(std::move(__i._M_current))\n+\t  { }\n+\n+\t  constexpr value_type\n+\t  operator*() const\n+\t  { return value_type{*this}; }\n+\n+\t  constexpr _OuterIter&\n+\t  operator++()\n+\t  {\n+\t    const auto __end = ranges::end(_M_parent->_M_base);\n+\t    if (_M_current == __end)\n+\t      return *this;\n+\t    const auto [__pbegin, __pend] = subrange{_M_parent->_M_pattern};\n+\t    if (__pbegin == __pend)\n+\t      ++_M_current;\n+\t    else\n+\t      do\n+\t\t{\n+\t\t  auto [__b, __p]\n+\t\t    = __detail::mismatch(std::move(_M_current), __end,\n+\t\t\t\t\t __pbegin, __pend);\n+\t\t  _M_current = std::move(__b);\n+\t\t  if (__p == __pend)\n+\t\t    break;\n+\t\t} while (++_M_current != __end);\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr decltype(auto)\n+\t  operator++(int)\n+\t  {\n+\t    if constexpr (forward_range<_Base>)\n+\t      {\n+\t\tauto __tmp = *this;\n+\t\t++*this;\n+\t\treturn __tmp;\n+\t      }\n+\t    else\n+\t      ++*this;\n+\t  }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _OuterIter& __x, const _OuterIter& __y)\n+\t    requires forward_range<_Base>\n+\t  { return __x._M_current == __y._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _OuterIter& __x, default_sentinel_t)\n+\t  { return __x.__at_end(); };\n+\n+\t  friend _InnerIter<_Const>;\n+\t};\n+\n+      template<bool _Const>\n+\tstruct _InnerIter\n+\t{\n+\tprivate:\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  constexpr bool\n+\t  __at_end() const\n+\t  {\n+\t    auto [__pcur, __pend] = subrange{_M_i._M_parent->_M_pattern};\n+\t    auto __end = ranges::end(_M_i._M_parent->_M_base);\n+\t    if constexpr (__detail::__tiny_range<_Pattern>)\n+\t      {\n+\t\tconst auto& __cur = _M_i.__current();\n+\t\tif (__cur == __end)\n+\t\t  return true;\n+\t\tif (__pcur == __pend)\n+\t\t  return _M_incremented;\n+\t\treturn *__cur == *__pcur;\n+\t      }\n+\t    else\n+\t      {\n+\t\tauto __cur = _M_i.__current();\n+\t\tif (__cur == __end)\n+\t\t  return true;\n+\t\tif (__pcur == __pend)\n+\t\t  return _M_incremented;\n+\t\tdo\n+\t\t  {\n+\t\t    if (*__cur != *__pcur)\n+\t\t      return false;\n+\t\t    if (++__pcur == __pend)\n+\t\t      return true;\n+\t\t  } while (++__cur != __end);\n+\t\treturn false;\n+\t      }\n+\t  }\n+\n+\t  static constexpr auto\n+\t  _S_iter_cat()\n+\t  {\n+\t    using _Cat = iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t    if constexpr (derived_from<_Cat, forward_iterator_tag>)\n+\t      return forward_iterator_tag{};\n+\t    else\n+\t      return _Cat{};\n+\t  }\n+\n+\t  static constexpr decltype(auto)\n+\t  __iter_move(const _InnerIter& __i = {})\n+\t  noexcept(noexcept(ranges::iter_move(__i._M_i.__current())))\n+\t  { return ranges::iter_move(__i._M_i.__current()); }\n+\n+\t  static constexpr void\n+\t  __iter_swap(const _InnerIter& __x = {}, const _InnerIter& __y = {})\n+\t    noexcept(noexcept(ranges::iter_swap(__x._M_i.__current(),\n+\t\t\t\t\t\t__y._M_i.__current())))\n+\t  { ranges::iter_swap(__x._M_i.__current(), __y._M_i.__current()); }\n+\n+\t  _OuterIter<_Const> _M_i = _OuterIter<_Const>();\n+\t  bool _M_incremented = false;\n+\n+\tpublic:\n+\t  using iterator_concept = typename _OuterIter<_Const>::iterator_concept;\n+\t  using iterator_category = decltype(_S_iter_cat());\n+\t  using value_type = range_value_t<_Base>;\n+\t  using difference_type = range_difference_t<_Base>;\n+\n+\t  _InnerIter() = default;\n+\n+\t  constexpr explicit\n+\t  _InnerIter(_OuterIter<_Const> __i)\n+\t    : _M_i(std::move(__i))\n+\t  { }\n+\n+\t  constexpr decltype(auto)\n+\t  operator*() const\n+\t  { return *_M_i._M_current; }\n+\n+\t  constexpr _InnerIter&\n+\t  operator++()\n+\t  {\n+\t    _M_incremented = true;\n+\t    if constexpr (!forward_range<_Base>)\n+\t      if constexpr (_Pattern::size() == 0)\n+\t\treturn *this;\n+\t    ++_M_i.__current();\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr decltype(auto)\n+\t  operator++(int)\n+\t  {\n+\t    if constexpr (forward_range<_Vp>)\n+\t      {\n+\t\tauto __tmp = *this;\n+\t\t++*this;\n+\t\treturn __tmp;\n+\t      }\n+\t    else\n+\t      ++*this;\n+\t  }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _InnerIter& __x, const _InnerIter& __y)\n+\t    requires forward_range<_Base>\n+\t  { return __x._M_i.__current() == __y._M_i.__current(); }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _InnerIter& __x, default_sentinel_t)\n+\t  { return __x.__at_end(); }\n+\n+\t  friend constexpr decltype(auto)\n+\t  iter_move(const _InnerIter& __i) noexcept(noexcept(__iter_move()))\n+\t  { return __iter_move(__i); }\n+\n+\t  friend constexpr void\n+\t  iter_swap(const _InnerIter& __x, const _InnerIter& __y)\n+\t    noexcept(noexcept(__iter_swap()))\n+\t    requires indirectly_swappable<iterator_t<_Base>>\n+\t  { __iter_swap(__x, __y); }\n+\t};\n+\n+      _Vp _M_base = _Vp();\n+      _Pattern _M_pattern = _Pattern();\n+\n+      // XXX: _M_current is \"present only if !forward_range<V>\"\n+      [[no_unique_address]]\n+\tconditional_t<!forward_range<_Vp>,\n+\t\t      iterator_t<_Vp>, __detail::_Empty> _M_current;\n+\n+\n+    public:\n+      split_view() = default;\n+\n+      constexpr\n+      split_view(_Vp __base, _Pattern __pattern)\n+\t: _M_base(std::move(__base)), _M_pattern(std::move(__pattern))\n+      { }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<input_range _Range, forward_range _Pred>\n+\trequires constructible_from<_Vp, all_view<_Range>>\n+\t  && constructible_from<_Pattern, all_view<_Pred>>\n+\tconstexpr\n+\tsplit_view(_Range&& __r, _Pred&& __p)\n+\t  : _M_base(views::all(std::forward<_Range>(__r))),\n+\t    _M_pattern(views::all(std::forward<_Pred>(__p)))\n+      { }\n+      */\n+\n+      template<input_range _Range>\n+\trequires constructible_from<_Vp, all_view<_Range>>\n+\t  && constructible_from<_Pattern, single_view<range_value_t<_Range>>>\n+\tconstexpr\n+\tsplit_view(_Range&& __r, range_value_t<_Range> __e)\n+\t  : _M_base(views::all(std::forward<_Range>(__r))),\n+\t    _M_pattern(std::move(__e))\n+\t{ }\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin()\n+      {\n+\tif constexpr (forward_range<_Vp>)\n+\t  return _OuterIter<__detail::__simple_view<_Vp>>{*this,\n+\t\t\t\t\t\t\tranges::begin(_M_base)};\n+\telse\n+\t  {\n+\t    _M_current = ranges::begin(_M_base);\n+\t    return _OuterIter<false>{*this};\n+\t  }\n+      }\n+\n+      constexpr auto\n+      begin() const requires forward_range<_Vp> && forward_range<const _Vp>\n+      {\n+\treturn _OuterIter<true>{*this, ranges::begin(_M_base)};\n+      }\n+\n+      constexpr auto\n+      end() requires forward_range<_Vp> && common_range<_Vp>\n+      {\n+\treturn _OuterIter<__detail::__simple_view<_Vp>>{*this, ranges::end(_M_base)};\n+      }\n+\n+      constexpr auto\n+      end() const\n+      {\n+\tif constexpr (forward_range<_Vp>\n+\t\t      && forward_range<const _Vp>\n+\t\t      && common_range<const _Vp>)\n+\t  return _OuterIter<true>{*this, ranges::end(_M_base)};\n+\telse\n+\t  return default_sentinel;\n+      }\n+    };\n+\n+  template<typename _Range, typename _Pred>\n+    split_view(_Range&&, _Pred&&)\n+      -> split_view<all_view<_Range>, all_view<_Pred>>;\n+\n+  template<input_range _Range>\n+    split_view(_Range&&, range_value_t<_Range>)\n+      -> split_view<all_view<_Range>, single_view<range_value_t<_Range>>>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptor split\n+      = [] <viewable_range _Range, typename _Fp> (_Range&& __r, _Fp&& __f)\n+      {\n+\treturn split_view{std::forward<_Range>(__r), std::forward<_Fp>(__f)};\n+      };\n+  } // namespace views\n+\n+  namespace views\n+  {\n+    struct _Counted\n+    {\n+      template<input_or_output_iterator _Iter>\n+      constexpr auto\n+      operator()(_Iter __i, iter_difference_t<_Iter> __n) const\n+      {\n+\tif constexpr (random_access_iterator<_Iter>)\n+\t  return subrange{__i, __i + __n};\n+\telse\n+\t  return subrange{counted_iterator{std::move(__i), __n},\n+\t\t\t  default_sentinel};\n+      }\n+    };\n+\n+    inline constexpr _Counted counted{};\n+  } // namespace views\n+\n+  template<view _Vp>\n+    requires (!common_range<_Vp>) && copyable<iterator_t<_Vp>>\n+    class common_view : public view_interface<common_view<_Vp>>\n+    {\n+    private:\n+      _Vp _M_base = _Vp();\n+\n+    public:\n+      common_view() = default;\n+\n+      constexpr explicit\n+      common_view(_Vp __r)\n+\t: _M_base(std::move(__r))\n+      { }\n+\n+      /* XXX: P3280 doesn't remove this constructor, but I think it should?\n+      template<viewable_range _Range>\n+\trequires (!common_range<_Range>) && constructible_from<_Vp, all_view<_Range>>\n+\tconstexpr explicit\n+\tcommon_view(_Range&& __r)\n+\t  : _M_base(views::all(std::forward<_Range>(__r)))\n+\t{ }\n+\t*/\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin()\n+      {\n+\tif constexpr (random_access_range<_Vp> && sized_range<_Vp>)\n+\t  return ranges::begin(_M_base);\n+\telse\n+\t  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>\n+\t\t  (ranges::begin(_M_base));\n+      }\n+\n+      constexpr auto\n+      begin() const requires range<const _Vp>\n+      {\n+\tif constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)\n+\t  return ranges::begin(_M_base);\n+\telse\n+\t  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>\n+\t\t  (ranges::begin(_M_base));\n+      }\n+\n+      constexpr auto\n+      end()\n+      {\n+\tif constexpr (random_access_range<_Vp> && sized_range<_Vp>)\n+\t  return ranges::begin(_M_base) + ranges::size(_M_base);\n+\telse\n+\t  return common_iterator<iterator_t<_Vp>, sentinel_t<_Vp>>\n+\t\t  (ranges::end(_M_base));\n+      }\n+\n+      constexpr auto\n+      end() const requires range<const _Vp>\n+      {\n+\tif constexpr (random_access_range<const _Vp> && sized_range<const _Vp>)\n+\t  return ranges::begin(_M_base) + ranges::size(_M_base);\n+\telse\n+\t  return common_iterator<iterator_t<const _Vp>, sentinel_t<const _Vp>>\n+\t\t  (ranges::end(_M_base));\n+      }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      { return ranges::size(_M_base); }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      { return ranges::size(_M_base); }\n+    };\n+\n+  template<typename _Range>\n+    common_view(_Range&&) -> common_view<all_view<_Range>>;\n+\n+  namespace views\n+  {\n+    inline constexpr __adaptor::_RangeAdaptorClosure common\n+      = [] <viewable_range _Range> (_Range&& __r)\n+      {\n+\tif constexpr (common_range<_Range>\n+\t\t      && requires { views::all(std::forward<_Range>(__r)); })\n+\t  return views::all(std::forward<_Range>(__r));\n+\telse\n+\t  return common_view{std::forward<_Range>(__r)};\n+      };\n+\n+  } // namespace views\n+\n+  template<view _Vp>\n+    requires bidirectional_range<_Vp>\n+    class reverse_view : public view_interface<reverse_view<_Vp>>\n+    {\n+    private:\n+      _Vp _M_base = _Vp();\n+\n+    public:\n+      reverse_view() = default;\n+\n+      constexpr explicit\n+      reverse_view(_Vp __r)\n+\t: _M_base(std::move(__r))\n+\t{ }\n+\n+      /* XXX: P3280 removes this constructor\n+      template<viewable_range _Range>\n+\trequires bidirectional_range<_Range> && constructible_from<_Vp, all_view<_Range>>\n+\tconstexpr explicit\n+\treverse_view(_Range&& __r)\n+\t  : _M_base(views::all(std::forward<_Range>(__r)))\n+\t{ }\n+\t*/\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr reverse_iterator<iterator_t<_Vp>>\n+      begin()\n+      {\n+\t// XXX: we need to cache the result here as per [range.reverse.view]\n+\treturn make_reverse_iterator(ranges::next(ranges::begin(_M_base),\n+\t\t\t\t\t\t  ranges::end(_M_base)));\n+      }\n+\n+      constexpr auto\n+      begin() requires common_range<_Vp>\n+      { return make_reverse_iterator(ranges::end(_M_base)); }\n+\n+      constexpr auto\n+      begin() const requires common_range<const _Vp>\n+      { return make_reverse_iterator(ranges::end(_M_base)); }\n+\n+      constexpr reverse_iterator<iterator_t<_Vp>>\n+      end()\n+      { return make_reverse_iterator(ranges::begin(_M_base)); }\n+\n+      constexpr auto\n+      end() const requires common_range<const _Vp>\n+      { return make_reverse_iterator(ranges::begin(_M_base)); }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      { return ranges::size(_M_base); }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      { return ranges::size(_M_base); }\n+    };\n+\n+  template<typename _Range>\n+    reverse_view(_Range&&) -> reverse_view<all_view<_Range>>;\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<typename>\n+\tinline constexpr bool __is_reversible_subrange = false;\n+\n+      template<typename _Iter, subrange_kind _Kind>\n+\tinline constexpr bool\n+\t  __is_reversible_subrange<subrange<reverse_iterator<_Iter>,\n+\t\t\t\t\t    reverse_iterator<_Iter>,\n+\t\t\t\t\t    _Kind>> = true;\n+\n+      template<typename>\n+\tinline constexpr bool __is_reverse_view = false;\n+\n+      template<typename _Vp>\n+\tinline constexpr bool __is_reverse_view<reverse_view<_Vp>> = true;\n+    }\n+\n+    inline constexpr __adaptor::_RangeAdaptorClosure reverse\n+      = [] <viewable_range _Range> (_Range&& __r)\n+      {\n+\tusing _Tp = remove_cvref_t<_Range>;\n+\tif constexpr (__detail::__is_reverse_view<_Tp>)\n+\t  return std::forward<_Range>(__r).base();\n+\telse if constexpr (__detail::__is_reversible_subrange<_Tp>)\n+\t  {\n+\t    using _Iter = decltype(ranges::begin(__r).base());\n+\t    if constexpr (sized_range<_Tp>)\n+\t      return subrange<_Iter, _Iter, subrange_kind::sized>\n+\t\t      (__r.end().base(), __r.begin().base(), __r.size());\n+\t    else\n+\t      return subrange<_Iter, _Iter, subrange_kind::unsized>\n+\t\t      (__r.end().base(), __r.begin().base());\n+\t  }\n+\telse\n+\t  return reverse_view{std::forward<_Range>(__r)};\n+      };\n+  } // namespace views\n+\n+  namespace __detail\n+  {\n+    template<typename _Tp, size_t _Nm>\n+    concept __has_tuple_element = requires(_Tp __t)\n+      {\n+\ttypename tuple_size<_Tp>::type;\n+\trequires _Nm < tuple_size_v<_Tp>;\n+\ttypename tuple_element_t<_Nm, _Tp>;\n+\t// XXX: we applied P3323 here\n+\t{ std::get<_Nm>(__t) }\n+\t  -> convertible_to<const tuple_element_t<_Nm, _Tp>&>;\n+      };\n+  }\n+\n+  template<input_range _Vp, size_t _Nm>\n+    requires view<_Vp>\n+      && __detail::__has_tuple_element<range_value_t<_Vp>, _Nm>\n+      && __detail::__has_tuple_element<remove_reference_t<range_reference_t<_Vp>>,\n+\t\t\t\t       _Nm>\n+    class elements_view : public view_interface<elements_view<_Vp, _Nm>>\n+    {\n+    public:\n+      elements_view() = default;\n+\n+      constexpr explicit\n+      elements_view(_Vp base)\n+\t: _M_base(std::move(base))\n+      { }\n+\n+      constexpr _Vp\n+      base() const& requires copy_constructible<_Vp>\n+      { return _M_base; }\n+\n+      constexpr _Vp\n+      base() &&\n+      { return std::move(_M_base); }\n+\n+      constexpr auto\n+      begin() requires (!__detail::__simple_view<_Vp>)\n+      { return _Iterator<false>(ranges::begin(_M_base)); }\n+\n+      constexpr auto\n+      begin() const requires __detail::__simple_view<_Vp>\n+      { return _Iterator<true>(ranges::begin(_M_base)); }\n+\n+      constexpr auto\n+      end() requires (!__detail::__simple_view<_Vp>)\n+      { return ranges::end(_M_base); }\n+\n+      constexpr auto\n+      end() const requires __detail::__simple_view<_Vp>\n+      { return ranges::end(_M_base); }\n+\n+      constexpr auto\n+      size() requires sized_range<_Vp>\n+      { return ranges::size(_M_base); }\n+\n+      constexpr auto\n+      size() const requires sized_range<const _Vp>\n+      { return ranges::size(_M_base); }\n+\n+    private:\n+      template<bool _Const>\n+\tstruct _Iterator\n+\t{\n+\t  using _Base = conditional_t<_Const, const _Vp, _Vp>;\n+\n+\t  iterator_t<_Base> _M_current;\n+\n+\t  friend _Iterator<!_Const>;\n+\n+\tpublic:\n+\t  using iterator_category\n+\t    = typename iterator_traits<iterator_t<_Base>>::iterator_category;\n+\t  using value_type\n+\t    = remove_cvref_t<tuple_element_t<_Nm, range_value_t<_Base>>>;\n+\t  using difference_type = range_difference_t<_Base>;\n+\n+\t  _Iterator() = default;\n+\n+\t  constexpr explicit\n+\t  _Iterator(iterator_t<_Base> current)\n+\t    : _M_current(std::move(current))\n+\t  { }\n+\n+\t  constexpr\n+\t  _Iterator(_Iterator<!_Const> i)\n+\t    requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n+\t    : _M_current(std::move(i._M_current))\n+\t  { }\n+\n+\t  constexpr iterator_t<_Base>\n+\t  base() const&\n+\t    requires copyable<iterator_t<_Base>>\n+\t  { return _M_current; }\n+\n+\t  constexpr iterator_t<_Base>\n+\t  base() &&\n+\t  { return std::move(_M_current); }\n+\n+\t  constexpr decltype(auto)\n+\t    operator*() const\n+\t  { return std::get<_Nm>(*_M_current); }\n+\n+\t  constexpr _Iterator&\n+\t  operator++()\n+\t  {\n+\t    ++_M_current;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr void\n+\t  operator++(int) requires (!forward_range<_Base>)\n+\t  { ++_M_current; }\n+\n+\t  constexpr _Iterator\n+\t  operator++(int) requires forward_range<_Base>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    ++_M_current;\n+\t    return __tmp;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator--() requires bidirectional_range<_Base>\n+\t  {\n+\t    --_M_current;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr _Iterator\n+\t  operator--(int) requires bidirectional_range<_Base>\n+\t  {\n+\t    auto __tmp = *this;\n+\t    --_M_current;\n+\t    return __tmp;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator+=(difference_type __n)\n+\t    requires random_access_range<_Base>\n+\t  {\n+\t    _M_current += __n;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr _Iterator&\n+\t  operator-=(difference_type __n)\n+\t    requires random_access_range<_Base>\n+\t  {\n+\t    _M_current -= __n;\n+\t    return *this;\n+\t  }\n+\n+\t  constexpr decltype(auto)\n+\t  operator[](difference_type __n) const\n+\t    requires random_access_range<_Base>\n+\t  { return std::get<_Nm>(*(_M_current + __n)); }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator& __x, const _Iterator& __y)\n+\t    requires equality_comparable<iterator_t<_Base>>\n+\t  { return __x._M_current == __y._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator==(const _Iterator& __x, const sentinel_t<_Base>& __y)\n+\t  { return __x._M_current == __y; }\n+\n+\t  friend constexpr bool\n+\t  operator<(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __x._M_current < __y._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator>(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __y._M_current < __x._M_current; }\n+\n+\t  friend constexpr bool\n+\t  operator<=(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return !(__y._M_current > __x._M_current); }\n+\n+\t  friend constexpr bool\n+\t  operator>=(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return !(__x._M_current > __y._M_current); }\n+\n+#ifdef __cpp_lib_three_way_comparison\n+\t  friend constexpr auto\n+\t  operator<=>(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t      && three_way_comparable<iterator_t<_Base>>\n+\t  { return __x._M_current <=> __y._M_current; }\n+#endif\n+\n+\t  friend constexpr _Iterator\n+\t  operator+(const _Iterator& __x, difference_type __y)\n+\t    requires random_access_range<_Base>\n+\t  { return _Iterator{__x} += __y; }\n+\n+\t  friend constexpr _Iterator\n+\t  operator+(difference_type __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __y + __x; }\n+\n+\t  friend constexpr _Iterator\n+\t  operator-(const _Iterator& __x, difference_type __y)\n+\t    requires random_access_range<_Base>\n+\t  { return _Iterator{__x} -= __y; }\n+\n+\t  friend constexpr difference_type\n+\t  operator-(const _Iterator& __x, const _Iterator& __y)\n+\t    requires random_access_range<_Base>\n+\t  { return __x._M_current - __y._M_current; }\n+\n+\t  friend constexpr difference_type\n+\t  operator-(const _Iterator<_Const>& __x, const sentinel_t<_Base>& __y)\n+\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+\t  { return __x._M_current - __y; }\n+\n+\t  friend constexpr difference_type\n+\t  operator-(const sentinel_t<_Base>& __x, const _Iterator<_Const>& __y)\n+\t    requires sized_sentinel_for<sentinel_t<_Base>, iterator_t<_Base>>\n+\t  { return -(__y - __x); }\n+\t};\n+\n+      _Vp _M_base = _Vp();\n+    };\n+\n+  template<typename _Range>\n+    using keys_view = elements_view<all_view<_Range>, 0>;\n+\n+  template<typename _Range>\n+    using values_view = elements_view<all_view<_Range>, 1>;\n+\n+  namespace views\n+  {\n+    template<size_t _Nm>\n+    inline constexpr __adaptor::_RangeAdaptorClosure elements\n+      = [] <viewable_range _Range> (_Range&& __r)\n+      {\n+\treturn elements_view<all_view<_Range>, _Nm>{std::forward<_Range>(__r)};\n+      };\n+\n+    inline constexpr __adaptor::_RangeAdaptorClosure keys = elements<0>;\n+    inline constexpr __adaptor::_RangeAdaptorClosure values = elements<1>;\n+  } // namespace views\n+\n+} // namespace ranges\n+\n+  namespace views = ranges::views;\n+\n+  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>\n+    struct tuple_size<ranges::subrange<_Iter, _Sent, _Kind>>\n+    : integral_constant<size_t, 2>\n+    { };\n+\n+  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>\n+    struct tuple_element<0, ranges::subrange<_Iter, _Sent, _Kind>>\n+    { using type = _Iter; };\n+\n+  template<typename _Iter, typename _Sent, ranges::subrange_kind _Kind>\n+    struct tuple_element<1, ranges::subrange<_Iter, _Sent, _Kind>>\n+    { using type = _Sent; };\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace\n #endif // library concepts"}, {"sha": "577ce7460e6cf2866051b0990e0d6ee91154313c", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/all.cc", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fall.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,122 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto v = views::all(x);\n+\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(ranges::random_access_range<decltype(v)>);\n+\n+  VERIFY( ranges::size(v) == 5 );\n+  VERIFY( ranges::size(x | views::all) == 5 );\n+  VERIFY( ranges::size(v | views::all | views::all) == 5 );\n+  VERIFY( ranges::size(v | (views::all | views::all)) == 5 );\n+\n+  ranges::reverse(v);\n+  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[5] = { 0 };\n+  int k = 0;\n+  for (auto&& i : ranges::ref_view{x})\n+    i += ++k;\n+  VERIFY( ranges::equal(x, (int[]){1,2,3,4,5}) );\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  std::array ints{0,1,2,3,4,5};\n+  auto even = [] (int i) { return i%2==0; };\n+  auto odd = [] (int i) { return i%2==1; };\n+  auto square = [] (int i) { return i*i; };\n+  int sum = 0;\n+  for (auto v : (ints\n+\t\t | (views::all\n+\t\t    | (views::filter(even)\n+\t\t    | (views::filter(odd) | views::all)))\n+\t\t | views::transform(square)))\n+    sum += v;\n+  return sum == 0;\n+}\n+\n+constexpr bool\n+test04()\n+{\n+  auto odd = [] (int i) { return i%2==1; };\n+  auto square = [] (int i) { return i*i; };\n+  auto increment = [] (int i) { return i+1; };\n+  auto small = [] (int i) { return i<30; };\n+  auto non_negative = [] (int i) { return i>=0; };\n+  auto negative = [] (int i) { return i<0; };\n+  return ranges::equal(views::iota(-5)\n+\t\t       | views::drop_while(negative)\n+\t\t       | views::take_while(non_negative)\n+\t\t       | views::transform(increment)\n+\t\t       | views::filter(odd)\n+\t\t       | views::take(3)\n+\t\t       | views::all\n+\t\t       | views::transform(square),\n+\t\t       views::iota(-5)\n+\t\t       | views::drop_while(negative)\n+\t\t       | views::drop(1)\n+\t\t       | views::filter(odd)\n+\t\t       | views::transform(square)\n+\t\t       | views::take_while(small)\n+\t\t       | views::take_while(small));\n+}\n+\n+static_assert(std::is_empty_v<decltype(views::common\n+\t\t\t\t       | views::join\n+\t\t\t\t       | views::all\n+\t\t\t\t       | views::common\n+\t\t\t\t       | views::keys\n+\t\t\t\t       | views::reverse)>);\n+static_assert(sizeof(decltype(views::take(5) | views::drop(5)))\n+\t      == sizeof(decltype(views::take(5)\n+\t\t\t\t | views::join\n+\t\t\t\t | views::common\n+\t\t\t\t | views::all\n+\t\t\t\t | views::keys\n+\t\t\t\t | views::drop(5)\n+\t\t\t\t | views::reverse)));\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  static_assert(test03());\n+  static_assert(test04());\n+}"}, {"sha": "b73796835bec6daf16b9525e90cf8b8bd2d222cd", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/common.cc", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcommon.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,68 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,1,3};\n+  auto v = x | views::common;\n+  VERIFY( std::count(v.begin(), v.end(), 1) == 2);\n+  static_assert(ranges::common_range<decltype(v)>);\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(ranges::random_access_range<decltype(v)>);\n+  static_assert(std::same_as<decltype(v), decltype(views::common(v))>);\n+\n+  auto v2 = v | (views::common | views::common);\n+  VERIFY( std::count(v2.begin(), v2.end(), 1) == 2);\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,1,3};\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto v = ranges::common_view(rx);\n+  VERIFY( std::count(v.begin(), v.end(), 1) == 2);\n+  static_assert(ranges::common_range<decltype(v)>);\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(ranges::forward_range<decltype(v)>);\n+  static_assert(std::same_as<decltype(v), decltype(views::common(v))>);\n+\n+  auto v2 = v | (views::common | views::common);\n+  VERIFY( std::count(v2.begin(), v2.end(), 1) == 2);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e81f9062d3975b1ca7d1508c92b3cee0f7185416", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/counted.cc", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcounted.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcounted.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fcounted.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,64 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {0,1,2,3,4,5,0,1,2,3,4,5};\n+  auto v = views::counted(x, 5);\n+  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(ranges::common_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {0,1,2,3,4,5,0,1,2,3,4,5};\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto v = views::counted(rx.begin(), 5);\n+  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(!ranges::bidirectional_range<R>);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "93fbafcf5a347e24022c0065d56c9715caa43909", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop.cc", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,107 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto v = x | views::drop(3);\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+  VERIFY( ranges::equal(v, (int[]){4,5}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto t = views::drop(3) | views::reverse;\n+  auto v = x | t;\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+  VERIFY( ranges::equal(v, (int[]){5,4}) );\n+}\n+\n+void\n+test03()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto v = rx | views::drop(3);\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::sized_range<R>);\n+  static_assert(ranges::bidirectional_range<R>);\n+  VERIFY( ranges::equal(v, (int[]){4,5}) );\n+}\n+\n+\n+void\n+test04()\n+{\n+  auto v = views::iota(0) | views::drop(10);\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::sized_range<R>);\n+  VERIFY( ranges::equal(v | views::take(3), (int[]){10,11,12}) );\n+}\n+\n+void\n+test05()\n+{\n+  int x[] = {1,2,3};\n+  auto r = ranges::subrange(x, x+1);\n+  auto v = views::drop(r, 2);\n+  VERIFY( ranges::begin(v) == x+1 );\n+  VERIFY( ranges::size(v) == 0 );\n+}\n+\n+void\n+test06()\n+{\n+  int x[] = {1,2,3};\n+  VERIFY( ranges::empty(x | views::drop(10)) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+  test06();\n+}"}, {"sha": "be47551563d1701b7d8fac5fd13205b2a644af14", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/drop_while.cc", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fdrop_while.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,63 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  auto p = [] (int i) { return i != 16; };\n+  auto v = views::iota(10) | views::drop_while(p);\n+  VERIFY( ranges::equal(v | views::take(5), (int[]){16,17,18,19,20}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto v = rx | views::drop_while([] (int i) { return i<4; });\n+  VERIFY( ranges::equal(v, (int[]){4,5}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::bidirectional_range<R>);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}\n+"}, {"sha": "d846c4cf33eaf5f366bf341d555fa9ac4ab787e8", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/elements.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Felements.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,52 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+#include <tuple>\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  std::tuple<int, int> x[] = {{1,2},{3,4},{5,6}};\n+  auto v0 = x | views::elements<0>;\n+  VERIFY( ranges::equal(v0, (int[]){1,3,5}) );\n+  VERIFY( ranges::equal(v0, x | views::keys) );\n+  VERIFY( ranges::size(v0) == 3 );\n+\n+  using R0 = decltype(v0);\n+  static_assert(ranges::random_access_range<R0>);\n+  static_assert(ranges::sized_range<R0>);\n+\n+  auto v1 = x | views::reverse | views::elements<1> | views::reverse;\n+  VERIFY( ranges::equal(v1, (int[]){2,4,6}) );\n+  VERIFY( ranges::equal(v1, x | views::values) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}, {"sha": "83d52967a0fe290607a6da9ef50878acef42ffd5", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/filter.cc", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ffilter.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,97 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5,6};\n+  auto is_odd = [] (int i) { return i%2==1; };\n+  auto v = x | views::filter(is_odd);\n+  using R = decltype(v);\n+  static_assert(std::same_as<int&, decltype(*v.begin())>);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::input_range<R>);\n+  static_assert(ranges::common_range<R>);\n+  static_assert(!ranges::sized_range<R>);\n+  static_assert(ranges::bidirectional_range<R>);\n+  static_assert(!ranges::random_access_range<R>);\n+  static_assert(ranges::range<ranges::all_view<R>>);\n+  VERIFY( ranges::equal(v, (int[]){1,3,5}) );\n+  VERIFY( ranges::equal(v | views::reverse, (int[]){5,3,1}) );\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5,6};\n+  auto f = [flag=false] (int) mutable { return flag = !flag; };\n+  auto v = views::filter(f)(x);\n+  using R = decltype(v);\n+  static_assert(std::same_as<int&, decltype(*v.begin())>);\n+  static_assert(ranges::range<R>);\n+  static_assert(std::copyable<R>);\n+  static_assert(!ranges::view<const R>);\n+  VERIFY( ranges::equal(v, (int[]){1,3,5}) );\n+}\n+\n+struct X\n+{\n+  int i, j;\n+};\n+\n+void\n+test03()\n+{\n+  X x[] = {{1,3}, {2,5}, {3,7}, {4,9}};\n+  test_range<X, bidirectional_iterator_wrapper> rx(x);\n+  auto v = rx | views::filter([] (auto&& p) { return p.i%2==0; });\n+  int sum = 0;\n+  for (auto i = v.begin(); i != v.end(); ++i)\n+    sum += i->j;\n+  VERIFY( sum == 14 );\n+}\n+\n+void\n+test04()\n+{\n+  auto yes = [] (int) { return true; };\n+  VERIFY( ranges::equal(views::iota(0) | views::filter(yes) | views::take(1),\n+\t\t\t(int[]){0}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "d3e652da0098c1df1fd4f44bfc7121f2bc1dd245", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/join.cc", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fjoin.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,112 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <string>\n+#include <string_view>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  using namespace std::literals;\n+  std::string_view cs[] = {\"the\", \"quick\", \"brown\", \"fox\"};\n+  auto v = cs | views::join;\n+  VERIFY( ranges::equal(v, \"thequickbrownfox\"sv) );\n+  using R = decltype(v);\n+  static_assert(ranges::bidirectional_range<R>);\n+  static_assert(ranges::bidirectional_range<const R>);\n+  static_assert(ranges::common_range<R>);\n+  static_assert(ranges::common_range<const R>);\n+}\n+\n+void\n+test02()\n+{\n+  auto v = (views::iota(0,4)\n+\t    | views::transform([] (int i) { return views::iota(0,i); })\n+\t    | views::join);\n+  VERIFY( ranges::equal(v, (int[]){0,0,1,0,1,2}) );\n+  using R = decltype(v);\n+  static_assert(ranges::input_range<R>);\n+  static_assert(!ranges::range<const R>);\n+  static_assert(!ranges::forward_range<R>);\n+  static_assert(!ranges::common_range<const R>);\n+}\n+\n+void\n+test03()\n+{\n+  auto v = (views::iota(0,4)\n+\t    | views::transform([] (int i) { return views::iota(0,i); })\n+\t    | views::filter([] (auto) { return true; })\n+\t    | views::join);\n+  VERIFY( ranges::equal(v, (int[]){0,0,1,0,1,2}) );\n+  using R = decltype(v);\n+  static_assert(ranges::input_range<R>);\n+  static_assert(!ranges::range<const R>);\n+  static_assert(!ranges::forward_range<R>);\n+  static_assert(!ranges::common_range<const R>);\n+}\n+\n+void\n+test04()\n+{\n+  auto v = (views::iota(0,4)\n+\t    | views::transform([] (int i) { return views::iota(0,i); }));\n+  auto v2 = ranges::ref_view{v};\n+  VERIFY( ranges::equal(v2 | views::join, (int[]){0,0,1,0,1,2}) );\n+  using R = decltype(v2);\n+  static_assert(ranges::random_access_range<R>);\n+  static_assert(ranges::range<const R>);\n+  static_assert(ranges::common_range<const R>);\n+  static_assert(ranges::random_access_range<ranges::range_reference_t<R>>);\n+  static_assert(!std::is_reference_v<ranges::range_reference_t<R>>);\n+}\n+\n+void\n+test05()\n+{\n+  using namespace std::literals;\n+  std::vector<std::string> x = {\"the\", \" \", \"quick\", \" \", \"brown\", \" \", \"fox\"};\n+  auto v = x | views::join | views::split(' ');\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+  test05();\n+}"}, {"sha": "0c6aceabbedaeda0dbf99c8ea2e7792772c65b5f", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/reverse.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Freverse.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto v = x | views::reverse;\n+  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );\n+  VERIFY( ranges::equal(v | views::reverse, x) );\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(ranges::sized_range<decltype(v)>);\n+  static_assert(ranges::common_range<decltype(v)>);\n+  static_assert(ranges::random_access_range<decltype(v)>);\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto v = views::reverse(rx);\n+  VERIFY( ranges::equal(v, (int[]){5,4,3,2,1}) );\n+  VERIFY( ranges::equal(v | views::reverse, rx) );\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(!ranges::sized_range<decltype(v)>);\n+  static_assert(ranges::common_range<decltype(v)>);\n+  static_assert(!ranges::random_access_range<decltype(v)>);\n+  static_assert(ranges::bidirectional_range<decltype(v)>);\n+}\n+\n+void\n+test03()\n+{\n+  int x[] = {1,7,3,6,5,2,4,8};\n+  auto is_even = [] (int i) { return i%2==0; };\n+  int sum = 0;\n+  for (auto i : x | views::reverse | views::filter(is_even))\n+    sum += i;\n+  VERIFY( sum == 20 );\n+}\n+\n+void\n+test04()\n+{\n+  int x[] = {1,2,3,4,5};\n+  VERIFY( ranges::equal(x | views::reverse | (views::reverse | views::reverse),\n+\t\t\t(int[]){5,4,3,2,1}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "129a8249f217a250e2a7c48b190d8136f60c9df7", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/split.cc", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fsplit.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,82 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <string>\n+#include <string_view>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+using namespace std::literals;\n+\n+void\n+test01()\n+{\n+  auto x = \"the  quick  brown  fox\"sv;\n+  auto p = std::string{\"  \"};\n+  auto v = x | views::split(p);\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test02()\n+{\n+  auto x = \"the quick brown fox\"sv;\n+  auto v = x | views::split(' ');\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+void\n+test03()\n+{\n+  char x[] = \"the quick brown fox\";\n+  test_range<char, forward_iterator_wrapper> rx(x);\n+  auto v = rx | views::split(' ');\n+  auto i = v.begin();\n+  VERIFY( ranges::equal(*i++, \"the\"sv) );\n+  VERIFY( ranges::equal(*i++, \"quick\"sv) );\n+  VERIFY( ranges::equal(*i++, \"brown\"sv) );\n+  VERIFY( ranges::equal(*i++, \"fox\"sv) );\n+  VERIFY( i == v.end() );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "e2d2edbe0a8dcd61e19f5ce204155f763cf5907a", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/take.cc", "status": "added", "additions": 95, "deletions": 0, "changes": 95, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,95 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::bidirectional_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = ranges::views;\n+\n+void\n+test01()\n+{\n+  auto v = views::iota(0) | views::take(5);\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(!ranges::sized_range<decltype(v)>);\n+  static_assert(!ranges::common_range<decltype(v)>);\n+  static_assert(ranges::random_access_range<decltype(v)>);\n+  static_assert(!ranges::contiguous_range<decltype(v)>);\n+  static_assert(ranges::range<const decltype(v)>);\n+  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );\n+}\n+\n+void\n+test02()\n+{\n+  auto v = views::take(views::iota(0, 20), 5);\n+  static_assert(ranges::view<decltype(v)>);\n+  static_assert(ranges::sized_range<decltype(v)>);\n+  static_assert(ranges::common_range<decltype(v)>);\n+  static_assert(ranges::random_access_range<decltype(v)>);\n+  static_assert(!ranges::contiguous_range<decltype(v)>);\n+  static_assert(ranges::range<const decltype(v)>);\n+  VERIFY( ranges::equal(v, (int[]){0,1,2,3,4}) );\n+}\n+\n+void\n+test03()\n+{\n+  int x[] = {0,1,2,3,4,5};\n+  auto is_odd = [] (int i) { return i%2 == 1; };\n+  auto v = x | views::filter(is_odd) | views::take(3);\n+  ranges::begin(v);\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::sized_range<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::forward_range<R>);\n+  static_assert(!ranges::random_access_range<R>);\n+  static_assert(!ranges::range<const R>);\n+  VERIFY( ranges::equal(v, (int[]){1,3,5}) );\n+}\n+\n+void\n+test04()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, bidirectional_iterator_wrapper> rx(x);\n+  auto v = ranges::take_view{rx, 3};\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::sized_range<R>);\n+  static_assert(ranges::bidirectional_range<R>);\n+  VERIFY( ranges::equal(v | views::take(5), (int[]){1,2,3}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  test04();\n+}"}, {"sha": "b261ffd1aaeabdf9d158cf1aeea11bf5b1f0e3f5", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/take_while.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftake_while.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,62 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::forward_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  auto p = [] (int i) { return i != 16; };\n+  auto v = views::iota(10) | views::take_while(p);\n+  VERIFY( ranges::equal(v, (int[]){10,11,12,13,14,15}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+}\n+\n+void\n+test02()\n+{\n+  int x[] = {1,2,3,4,5};\n+  test_range<int, forward_iterator_wrapper> rx(x);\n+  auto v = rx | views::take_while([] (int i) { return i<4; });\n+  VERIFY( ranges::equal(v, (int[]){1,2,3}) );\n+  using R = decltype(v);\n+  static_assert(ranges::view<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::forward_range<R>);\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+}"}, {"sha": "ad51fffb43dd6ab105a7f46ff896fb9f64919df2", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/transform.cc", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cba9ef069e58eac00f30489d3ef21390caee6e45/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Ftransform.cc?ref=cba9ef069e58eac00f30489d3ef21390caee6e45", "patch": "@@ -0,0 +1,86 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+\n+#include <algorithm>\n+#include <ranges>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+using __gnu_test::test_range;\n+using __gnu_test::random_access_iterator_wrapper;\n+\n+namespace ranges = std::ranges;\n+namespace views = std::ranges::views;\n+\n+void\n+test01()\n+{\n+  int x[] = {1,2,3,4,5};\n+  auto is_odd = [] (int i) { return i%2==1; };\n+  auto v = x | views::transform(is_odd);\n+  VERIFY( ranges::equal(v, (int[]){1,0,1,0,1}) );\n+  using R = decltype(v);\n+  static_assert(std::same_as<bool, decltype(*ranges::begin(v))>);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+}\n+\n+struct X\n+{\n+  int i,j;\n+};\n+\n+void\n+test02()\n+{\n+  X x[] = {{1,2},{3,4},{5,6},{7,8},{9,10}};\n+  test_range<X, random_access_iterator_wrapper> rx(x);\n+  auto v = rx | views::transform(&X::i);\n+  VERIFY( ranges::size(v) == 5 );\n+  VERIFY( ranges::distance(v.begin(), v.end()) == 5 );\n+  VERIFY( ranges::equal(v, (int[]){1,3,5,7,9}) );\n+  VERIFY( ranges::equal(v | views::reverse, (int[]){9,7,5,3,1}) );\n+  using R = decltype(v);\n+  static_assert(std::same_as<int&, decltype(*ranges::begin(v))>);\n+  static_assert(std::same_as<int, std::iter_value_t<ranges::iterator_t<R>>>);\n+  static_assert(ranges::view<R>);\n+  static_assert(ranges::sized_range<R>);\n+  static_assert(!ranges::common_range<R>);\n+  static_assert(ranges::random_access_range<R>);\n+}\n+\n+void\n+test03()\n+{\n+  auto id = [] (int i) { return i; };\n+  auto v = views::iota(0) | (views::filter(id)\n+\t\t\t     | views::transform(id)\n+\t\t\t     | views::take(5));\n+  VERIFY( ranges::equal(v, (int[]){1,2,3,4,5}) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+}"}]}