{"sha": "4009bb7d50ece62b164d3717d218ed16b51bddf4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwOWJiN2Q1MGVjZTYyYjE2NGQzNzE3ZDIxOGVkMTZiNTFiZGRmNA==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@redhat.com", "date": "2001-08-09T04:19:12Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2001-08-09T04:19:12Z"}, "message": "check-init.c (flags.h): Include\n\n2001-08-08  Alexandre Petit-Bianco  <apbianco@redhat.com>\n\n\t* check-init.c (flags.h): Include\n\t(check_init): Don't report uninitialized static class\n\tinitialization flags, don't free bit index when doing static class\n\tinitialization optimization.\n\t(check_for_initialization): Return type changed to `unsigned int.'\n\t(attach_initialized_static_class): New function.\n\t* class.c (add_method_1): Create the initialized static class\n\ttable if necessary.\n\t(finish_class): Always emit deferred inline methods.\n\t* decl.c (emit_init_test_initialization): Moved to expr.c\n\t(complete_start_java_method): Don't traverse\n\tDECL_FUNCTION_INIT_TEST_TABLE.\n\t(lang_mark_tree): Mark hash tables in function decls.\n\t* expr.c (emit_init_test_initialization): Moved from decl.c.\n\t(build_class_init): Create LAG_DECL_SPECIFIC for the static class\n\tinitialization flag, set DECL_CONTEXT and\n\tLOCAL_CLASS_INITIALIZATION_FLAG.\n\t(java_lang_expand_expr): Emit initialization code for static class\n\tinitialized flags when entering block, if necessary.\n\t* gcj.texi (-fno-optimize-static-class-initialization): Documented.\n\t* java-tree.h (flag_optimize_sci): New global variable declaration.\n\t(DECL_FUNCTION_INITIALIZED_CLASS_TABLE): New macro.\n\t(DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND): Likewise.\n\t(LOCAL_FINAL_P): Fixed typo in comment.\n\t(FINAL_VARIABLE_P): Likewise.\n\t(LOCAL_CLASS_INITIALIZATIO_FLAG): New macro.\n\t(LOCAL_CLASS_INITIALIZATIO_FLAG_P): Likewise.\n\t(struct lang_decl): New fields `ict', `smic' and `cif.'\n\t(check_for_initialization): New returned value for global.\n\t(attach_initialized_static_class): New global function.\n\t(STATIC_CLASS_INIT_OPT_P): New macro.\n\t* lang-options.h (-fno-optimize-static-class-initialization): New flag.\n\t* lang.c (java_decode_option): Handle\n\t`-fno-optimize-static-class-initialization'\n\t* parse.y (start_complete_expand_method): New function.\n\t(java_expand_method_bodies): Likewise.\n\t(attach_init_test_initialization_flags): Likewise.\n\t(adjust_init_test_initialization): Likewise.\n\t(emit_test_initialization): Likewise.\n\t(java_complete_expand_methods): Nullify abstract and native method\n\tbodies.\n\t(java_complete_expand_method): New locals `fbody', `block_body'\n\tand `exception_copy.' Reorganized: directly return on empty method\n\tbodies, call `start_complete_expand_method', remember definitely\n\tinitialized static class in function, don't expand method bodies.\n\t(java_expand_classes): Call `java_expand_method_bodies' before\n\t`finish_class' when compiling to native.\n\t(resolve_expression_name): Use `orig' after building outer class\n\tfield access.\n\t(patch_invoke): Remember static method invokations.\n\n(http://gcc.gnu.org/ml/gcc-patches/2001-08/msg00454.html)\n\nFrom-SVN: r44733", "tree": {"sha": "1c89de048bc9427066e52a374b05b125c6ec6ba2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c89de048bc9427066e52a374b05b125c6ec6ba2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4009bb7d50ece62b164d3717d218ed16b51bddf4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4009bb7d50ece62b164d3717d218ed16b51bddf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4009bb7d50ece62b164d3717d218ed16b51bddf4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4009bb7d50ece62b164d3717d218ed16b51bddf4/comments", "author": null, "committer": null, "parents": [{"sha": "6351543d13052c85f87b6e1e8af0273279a5c771", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6351543d13052c85f87b6e1e8af0273279a5c771", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6351543d13052c85f87b6e1e8af0273279a5c771"}], "stats": {"total": 694, "additions": 541, "deletions": 153}, "files": [{"sha": "7734a5f1daeb655c90e73c6c37e894ea174005d7", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -1,3 +1,56 @@\n+2001-08-08  Alexandre Petit-Bianco  <apbianco@redhat.com>\n+\n+\t* check-init.c (flags.h): Include\n+\t(check_init): Don't report uninitialized static class\n+\tinitialization flags, don't free bit index when doing static class\n+\tinitialization optimization.\n+\t(check_for_initialization): Return type changed to `unsigned int.'\n+\t(attach_initialized_static_class): New function.\n+\t* class.c (add_method_1): Create the initialized static class\n+\ttable if necessary.\n+\t(finish_class): Always emit deferred inline methods.\n+\t* decl.c (emit_init_test_initialization): Moved to expr.c\n+\t(complete_start_java_method): Don't traverse\n+\tDECL_FUNCTION_INIT_TEST_TABLE.\n+\t(lang_mark_tree): Mark hash tables in function decls.\n+\t* expr.c (emit_init_test_initialization): Moved from decl.c.\n+\t(build_class_init): Create LAG_DECL_SPECIFIC for the static class\n+\tinitialization flag, set DECL_CONTEXT and\n+\tLOCAL_CLASS_INITIALIZATION_FLAG.\n+\t(java_lang_expand_expr): Emit initialization code for static class\n+\tinitialized flags when entering block, if necessary.\n+\t* gcj.texi (-fno-optimize-static-class-initialization): Documented.\n+\t* java-tree.h (flag_optimize_sci): New global variable declaration.\n+\t(DECL_FUNCTION_INITIALIZED_CLASS_TABLE): New macro.\n+\t(DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND): Likewise.\n+\t(LOCAL_FINAL_P): Fixed typo in comment.\n+\t(FINAL_VARIABLE_P): Likewise.\n+\t(LOCAL_CLASS_INITIALIZATIO_FLAG): New macro.\n+\t(LOCAL_CLASS_INITIALIZATIO_FLAG_P): Likewise.\n+\t(struct lang_decl): New fields `ict', `smic' and `cif.'\n+\t(check_for_initialization): New returned value for global.\n+\t(attach_initialized_static_class): New global function.\n+\t(STATIC_CLASS_INIT_OPT_P): New macro.\n+\t* lang-options.h (-fno-optimize-static-class-initialization): New flag.\n+\t* lang.c (java_decode_option): Handle\n+\t`-fno-optimize-static-class-initialization'\n+\t* parse.y (start_complete_expand_method): New function.\n+\t(java_expand_method_bodies): Likewise.\n+\t(attach_init_test_initialization_flags): Likewise.\n+\t(adjust_init_test_initialization): Likewise.\n+\t(emit_test_initialization): Likewise.\n+\t(java_complete_expand_methods): Nullify abstract and native method\n+\tbodies.\n+\t(java_complete_expand_method): New locals `fbody', `block_body'\n+\tand `exception_copy.' Reorganized: directly return on empty method\n+\tbodies, call `start_complete_expand_method', remember definitely\n+\tinitialized static class in function, don't expand method bodies.\n+\t(java_expand_classes): Call `java_expand_method_bodies' before\n+\t`finish_class' when compiling to native.\n+\t(resolve_expression_name): Use `orig' after building outer class\n+\tfield access.\n+\t(patch_invoke): Remember static method invokations.\n+\n 2001-08-06  Richard Henderson  <rth@redhat.com>\n \n         * class.c (emit_register_classes): Pass a symbol_ref and priority"}, {"sha": "b108c45ce3a85abcde5e37e383060e5ca9310b61", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -25,6 +25,7 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #include \"config.h\"\n #include \"system.h\"\n #include \"tree.h\"\n+#include \"flags.h\" /* Needed for optimize. */\n #include \"java-tree.h\"\n #include \"toplev.h\" /* Needed for fatal. */\n \n@@ -370,7 +371,12 @@ check_init (exp, before)\n       if (! FIELD_STATIC (exp) && DECL_NAME (exp) != NULL_TREE)\n \t{\n \t  int index = DECL_BIT_INDEX (exp);\n-\t  if (index >= 0 && ! SET_P (before, index))\n+\t  /* We don't want to report and mark as non initialized flags\n+\t     the are, they will be marked initialized later on when\n+\t     assigned to `true.' */\n+\t  if ((STATIC_CLASS_INIT_OPT_P ()\n+\t       && ! LOCAL_CLASS_INITIALIZATION_FLAG_P (exp))\n+\t      && index >= 0 && ! SET_P (before, index))\n \t    {\n \t      parse_error_context \n \t\t(wfl, \"Variable `%s' may not have been initialized\",\n@@ -398,8 +404,13 @@ check_init (exp, before)\n \n \t  if (index >= 0)\n \t    SET_BIT (before, index);\n-\t  /* Minor optimization.  See comment for start_current_locals. */\n-\t  if (index >= start_current_locals\n+\t  /* Minor optimization.  See comment for start_current_locals.\n+\t     If we're optimizing for class initialization, we keep\n+\t     this information to check whether the variable is\n+\t     definitely assigned when once we checked the whole\n+\t     function. */\n+\t  if (! STATIC_CLASS_INIT_OPT_P ()\n+\t      && index >= start_current_locals\n \t      && index == num_current_locals - 1)\n \t    {\n \t      num_current_locals--;\n@@ -732,10 +743,35 @@ check_init (exp, before)\n     }\n }\n \n-void\n+unsigned int\n check_for_initialization (body)\n      tree body;\n {\n   word before = 0;\n   check_init (body, &before);\n+  return before;\n+}\n+\n+/* Call for every element in DECL_FUNCTION_INITIALIZED_CLASS_TABLE of\n+   a method to consider whether the type indirectly described by ENTRY\n+   is definitly initialized and thus remembered as such. */\n+\n+bool\n+attach_initialized_static_class (entry, ptr)\n+     struct hash_entry *entry;\n+     PTR ptr;\n+{\n+  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n+  tree fndecl = DECL_CONTEXT (ite->init_test_decl);\n+  int index = DECL_BIT_INDEX (ite->init_test_decl);\n+\n+  /* If the initializer flag has been definitly assigned (not taking\n+     into account its first mandatory assignment which has been\n+     already added but escaped analysis.) */\n+  if (fndecl && METHOD_STATIC (fndecl)\n+      && (DECL_INITIAL (ite->init_test_decl) == boolean_true_node\n+\t  || (index >= 0 && SET_P (((word *) ptr), index))))\n+    hash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n+\t\t entry->key, TRUE, NULL);\n+  return true;\n }"}, {"sha": "7e153b5b8f5bedad1accf218838c55c55e638df9", "filename": "gcc/java/class.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -673,6 +673,18 @@ add_method_1 (handle_class, access_flags, name, function_type)\n \t\t   init_test_hash_newfunc, java_hash_hash_tree_node, \n \t\t   java_hash_compare_tree_node);\n \n+  /* Initialize the initialized (static) class table. */\n+  if (access_flags & ACC_STATIC)\n+    hash_table_init (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (fndecl),\n+\t\t     init_test_hash_newfunc, java_hash_hash_tree_node,\n+\t\t     java_hash_compare_tree_node);\n+\n+  /* Initialize the static method invocation compound table */\n+  if (STATIC_CLASS_INIT_OPT_P ())\n+    hash_table_init (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl),\n+\t\t     init_test_hash_newfunc, java_hash_hash_tree_node,\n+\t\t     java_hash_compare_tree_node);\n+\n   TREE_CHAIN (fndecl) = TYPE_METHODS (handle_class);\n   TYPE_METHODS (handle_class) = fndecl;\n \n@@ -1484,18 +1496,11 @@ finish_class ()\n     {\n       if (! TREE_ASM_WRITTEN (method) && DECL_SAVED_INSNS (method) != 0)\n \t{\n-\t  /* It's a deferred inline method.  Decide if we need to emit it. */\n-\t  if (flag_keep_inline_functions\n-\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (method))\n-\t      || ! METHOD_PRIVATE (method)\n-\t      || saw_native_method)\n-\t    {\n-\t      output_inline_function (method);\n-\t      /* Scan the list again to see if there are any earlier\n-                 methods to emit. */\n-\t      method = type_methods;\n-\t      continue;\n-\t    }\n+\t  output_inline_function (method);\n+\t  /* Scan the list again to see if there are any earlier\n+\t     methods to emit. */\n+\t  method = type_methods;\n+\t  continue;\n \t}\n       method = TREE_CHAIN (method);\n     }"}, {"sha": "4eb073933a995c5fa2dab3711626eb2113e3e7c6", "filename": "gcc/java/decl.c", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -49,8 +49,6 @@ static tree push_jvm_slot PARAMS ((int, tree));\n static tree lookup_name_current_level PARAMS ((tree));\n static tree push_promoted_type PARAMS ((const char *, tree));\n static struct binding_level *make_binding_level PARAMS ((void));\n-static bool emit_init_test_initialization PARAMS ((struct hash_entry *,\n-\t\t\t\t\t\t      hash_table_key));\n static tree create_primitive_vtable PARAMS ((const char *));\n static tree check_local_named_variable PARAMS ((tree, tree, int, int *));\n static tree check_local_unnamed_variable PARAMS ((tree, tree, tree));\n@@ -1639,35 +1637,6 @@ build_result_decl (fndecl)\n   return (DECL_RESULT (fndecl) = build_decl (RESULT_DECL, NULL_TREE, restype));\n }\n \n-/* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE in order\n-   to emit initialization code for each test flag.  */\n-\n-static bool\n-emit_init_test_initialization (entry, key)\n-  struct hash_entry *entry;\n-  hash_table_key key ATTRIBUTE_UNUSED;\n-{\n-  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n-  tree klass = build_class_ref ((tree) entry->key);\n-  expand_decl (ite->init_test_decl);\n-\n-  /* We initialize the class init check variable by looking at the\n-     `state' field of the class to see if it is already initialized.\n-     This makes things a bit faster if the class is already\n-     initialized, which should be the common case.  */\n-  expand_expr_stmt\n-    (build (MODIFY_EXPR, boolean_type_node, \n-\t    ite->init_test_decl,\n-\t    build (GE_EXPR, boolean_type_node,\n-\t\t   build (COMPONENT_REF, byte_type_node,\n-\t\t\t  build1 (INDIRECT_REF, class_type_node, klass),\n-\t\t\t  lookup_field (&class_type_node,\n-\t\t\t\t\tget_identifier (\"state\"))),\n-\t\t   build_int_2 (JV_STATE_DONE, 0))));\n-\n-  return true;\n-}\n-\n void\n complete_start_java_method (fndecl)\n   tree fndecl;\n@@ -1679,11 +1648,6 @@ complete_start_java_method (fndecl)\n \n       /* Set up parameters and prepare for return, for the function.  */\n       expand_function_start (fndecl, 0);\n-\n-      /* Emit initialization code for test flags.  */\n-      if (! always_initialize_class_p)\n-\thash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (fndecl),\n-\t\t       emit_init_test_initialization, 0);\n     }\n \n #if 0\n@@ -1871,6 +1835,9 @@ lang_mark_tree (t)\n \t  ggc_mark_tree (ld->function_decl_body);\n \t  ggc_mark_tree (ld->called_constructor);\n \t  ggc_mark_tree (ld->inner_access);\n+\t  ggc_mark_tree_hash_table (&ld->init_test_table);\n+\t  ggc_mark_tree_hash_table (&ld->ict);\n+\t  ggc_mark_tree_hash_table (&ld->smic);\n \t}\n     }\n   else if (TYPE_P (t))"}, {"sha": "f7056fee4f4ff7ad02b93c896aeb39972dba3473", "filename": "gcc/java/expr.c", "status": "modified", "additions": 65, "deletions": 4, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -82,6 +82,8 @@ static tree build_java_check_indexed_type PARAMS ((tree, tree));\n static tree java_array_data_offset PARAMS ((tree)); \n static tree case_identity PARAMS ((tree, tree)); \n static unsigned char peek_opcode_at_pc PARAMS ((struct JCF *, int, int));\n+static bool emit_init_test_initialization PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\t   PTR ptr));\n \n static tree operand_type[59];\n extern struct obstack permanent_obstack;\n@@ -1710,10 +1712,20 @@ build_class_init (clas, expr)\n \t\t     TRUE, NULL);\n       \n       if (ite->init_test_decl == 0)\n-\tite->init_test_decl = build_decl (VAR_DECL, NULL_TREE, \n-\t\t\t\t\t  boolean_type_node);\n-      /* Tell the check-init code to ignore this decl.  */\n-      DECL_BIT_INDEX(ite->init_test_decl) = -1;\n+\t{\n+\t  /* Build a declaration and mark it as a flag used to track\n+\t     static class initializations. */\n+\t  ite->init_test_decl = build_decl (VAR_DECL, NULL_TREE,\n+\t\t\t\t\t    boolean_type_node);\n+\t  MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (ite->init_test_decl);\n+\t  LOCAL_CLASS_INITIALIZATION_FLAG (ite->init_test_decl) = 1;\n+\t  DECL_CONTEXT (ite->init_test_decl) = current_function_decl;\n+\n+\t  /* Tell the check-init code to ignore this decl when not\n+             optimizing class initialization. */\n+\t  if (!STATIC_CLASS_INIT_OPT_P ())\n+\t    DECL_BIT_INDEX(ite->init_test_decl) = -1;\n+\t}\n \n       init = build (CALL_EXPR, void_type_node,\n \t\t    build_address_of (soft_initclass_node),\n@@ -2459,16 +2471,31 @@ java_lang_expand_expr (exp, target, tmode, modifier)\n \t{\n \t  tree local;\n \t  tree body = BLOCK_EXPR_BODY (exp);\n+\t  /* Set to 1 or more when we found a static class\n+             initialization flag. */\n+\t  int found_class_initialization_flag = 0;\n+\n \t  pushlevel (2);\t/* 2 and above */\n \t  expand_start_bindings (0);\n \t  local = BLOCK_EXPR_DECLS (exp);\n \t  while (local)\n \t    {\n \t      tree next = TREE_CHAIN (local);\n+\t      found_class_initialization_flag +=\n+\t\tLOCAL_CLASS_INITIALIZATION_FLAG_P (local);\n \t      layout_decl (local, 0);\n \t      expand_decl (pushdecl (local));\n \t      local = next;\n \t    }\n+\n+\t  /* Emit initialization code for test flags if we saw one. */\n+\t  if (! always_initialize_class_p \n+\t      && current_function_decl\n+\t      && found_class_initialization_flag)\n+\t    hash_traverse \n+\t      (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n+\t       emit_init_test_initialization, NULL);\n+\n \t  /* Avoid deep recursion for long block.  */\n \t  while (TREE_CODE (body) == COMPOUND_EXPR)\n \t    {\n@@ -3335,3 +3362,37 @@ force_evaluation_order (node)\n     }\n   return node;\n }\n+\n+/* Called for every element in DECL_FUNCTION_INIT_TEST_TABLE of a\n+   method in order to emit initialization code for each test flag.  */\n+\n+static bool\n+emit_init_test_initialization (entry, key)\n+  struct hash_entry *entry;\n+  hash_table_key key ATTRIBUTE_UNUSED;\n+{\n+  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n+  tree klass = build_class_ref ((tree) entry->key);\n+  tree rhs;\n+\n+  /* If the DECL_INITIAL of the test flag is set to true, it\n+     means that the class is already initialized the time it\n+     is in use. */\n+  if (DECL_INITIAL (ite->init_test_decl) == boolean_true_node)\n+    rhs = boolean_true_node;\n+  /* Otherwise, we initialize the class init check variable by looking\n+     at the `state' field of the class to see if it is already\n+     initialized.  This makes things a bit faster if the class is\n+     already initialized, which should be the common case.  */\n+  else\n+    rhs = build (GE_EXPR, boolean_type_node,\n+\t\t build (COMPONENT_REF, byte_type_node,\n+\t\t\tbuild1 (INDIRECT_REF, class_type_node, klass),\n+\t\t\tlookup_field (&class_type_node,\n+\t\t\t\t      get_identifier (\"state\"))),\n+\t\t build_int_2 (JV_STATE_DONE, 0));\n+\n+  expand_expr_stmt (build (MODIFY_EXPR, boolean_type_node, \n+\t\t\t   ite->init_test_decl, rhs));\n+  return true;\n+}"}, {"sha": "6a52fc64ca59b451d8b255ffc82e01a6879f8c9e", "filename": "gcc/java/gcj.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fgcj.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fgcj.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgcj.texi?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -356,6 +356,14 @@ compiling a class with native methods, and these methods are implemented\n using JNI, then you must use @code{-fjni}.  This option causes\n @code{gcj} to generate stubs which will invoke the underlying JNI\n methods.\n+\n+@item -fno-optimize-static-class-initialization\n+When the optimization level is greather or equal to @code{-O2},\n+@code{gcj} will try to optimize the way calls into the runtime are made\n+to initialize static classes upon their first use (this optimization\n+isn't carried out if @code{-C} was specified.) When compiling to native\n+code, @code{-fno-optimize-static-class-initialization} will turn this\n+optimization off, regardless of the optimization level in use.\n @end table\n \n "}, {"sha": "d114747a8e7beb36c10fe4a99ba4e2b4c02572fd", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -186,6 +186,10 @@ extern int flag_hash_synchronization;\n /* When non zero, generate checks for references to NULL.  */\n extern int flag_check_references;\n \n+/* Used through STATIC_CLASS_INIT_OPT_P to check whether static\n+   initialization optimization should be performed.  */\n+extern int flag_optimize_sci;\n+\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -704,6 +708,16 @@ struct lang_identifier\n    class has been initialized in this function, and FALSE otherwise.  */\n #define DECL_FUNCTION_INIT_TEST_TABLE(DECL) \\\n   (DECL_LANG_SPECIFIC(DECL)->init_test_table)\n+/* For each static function decl, itc contains a hash table whose\n+   entries are keyed on class named that are definitively initialized\n+   in DECL.  */\n+#define DECL_FUNCTION_INITIALIZED_CLASS_TABLE(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->ict)\n+/* For each static function call, smic contains contains a hash table\n+   whose entries are keyed on the compound statement that encapsulate\n+   the invocation.  */\n+#define DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND(DECL) \\\n+  (DECL_LANG_SPECIFIC(DECL)->smic)\n /* The Number of Artificial Parameters (NAP) DECL contains. this$<n>\n    is excluded, because sometimes created as a parameter before the\n    function decl exists. */\n@@ -815,11 +829,18 @@ struct lang_identifier\n   (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->local_final)\n /* True if NODE is a local final. */\n #define LOCAL_FINAL_P(NODE) (DECL_LANG_SPECIFIC (NODE) && LOCAL_FINAL (NODE))\n-/* True if NODE is a final variable */\n+/* True if NODE is a final variable. */\n #define FINAL_VARIABLE_P(NODE) (FIELD_FINAL (NODE) && !FIELD_STATIC (NODE))\n-/* True if NODE is a class final variable */\n+/* True if NODE is a class final variable. */\n #define CLASS_FINAL_VARIABLE_P(NODE) \\\n   (FIELD_FINAL (NODE) && FIELD_STATIC (NODE))\n+/* True if NODE is a class initialization flag. This macro accesses\n+   the flag to read or set it.  */\n+#define LOCAL_CLASS_INITIALIZATION_FLAG(NODE) \\\n+    (((struct lang_decl_var*)DECL_LANG_SPECIFIC(NODE))->cif)\n+/* True if NODE is a class initialization flag. */\n+#define LOCAL_CLASS_INITIALIZATION_FLAG_P(NODE) \\\n+    (DECL_LANG_SPECIFIC (NODE) && LOCAL_CLASS_INITIALIZATION_FLAG(NODE))\n /* Create a DECL_LANG_SPECIFIC if necessary. */\n #define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n   if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n@@ -858,6 +879,8 @@ struct lang_decl\n \t\t\t\t   list of other constructor it calls */\n   struct hash_table init_test_table;\n \t\t\t\t/* Class initialization test variables  */\n+  struct hash_table ict;\t/* Initialized (static) Class Table */\n+  struct hash_table smic;\t/* Static method invocation compound */\n   tree inner_access;\t\t/* The identifier of the access method\n \t\t\t\t   used for invocation from inner classes */\n   int nap;\t\t\t/* Number of artificial parameters */\n@@ -888,6 +911,7 @@ struct lang_decl_var\n   int final_liic : 1;\t\t/* Final locally initialized in ctors */\n   int final_ierr : 1;\t\t/* Initialization error already detected */\n   int local_final : 1;\t\t/* True if the decl is a local final */\n+  int cif : 1;\t\t\t/* True: decl is a class initialization flag */\n };\n \n /* Macro to access fields in `struct lang_type'.  */\n@@ -1061,7 +1085,7 @@ extern void parse_error_context PARAMS ((tree cl, const char *, ...))\n extern tree build_primtype_type_ref PARAMS ((const char *));\n extern void finish_class PARAMS ((void));\n extern void java_layout_seen_class_methods PARAMS ((void));\n-extern void check_for_initialization PARAMS ((tree));\n+extern unsigned int check_for_initialization PARAMS ((tree));\n \n extern tree pushdecl_top_level PARAMS ((tree));\n extern int alloc_class_constant PARAMS ((tree));\n@@ -1129,6 +1153,8 @@ extern tree get_boehm_type_descriptor PARAMS ((tree));\n extern unsigned long java_hash_hash_tree_node PARAMS ((hash_table_key));\n extern bool java_hash_compare_tree_node PARAMS ((hash_table_key, \n \t\t\t\t\t\t    hash_table_key));\n+extern bool attach_initialized_static_class PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\t     PTR));\n extern void java_check_methods PARAMS ((tree));\n extern void init_jcf_parse PARAMS((void));\n extern void init_src_parse PARAMS((void));\n@@ -1559,6 +1585,10 @@ extern tree *type_map;\n   (inherits_from_p ((TYPE), runtime_exception_type_node)\t\\\n    || inherits_from_p ((TYPE), error_exception_type_node))\n \n+/* True when we can perform static class initialization optimization */\n+#define STATIC_CLASS_INIT_OPT_P() \\\n+  (flag_optimize_sci && (optimize >= 2) && ! flag_emit_class_files)\n+\n extern int java_error_count;\t\t\t\t\t\\\n \n /* Make the current function where this macro is invoked report error"}, {"sha": "06a4c4d69101c8f9b0a93f2522ea4ccaf41e20b7", "filename": "gcc/java/lang-options.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Flang-options.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Flang-options.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang-options.h?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -52,3 +52,5 @@ DEFINE_LANG_NAME (\"Java\")\n     N_(\"Warn if .class files are out of date\") },\n   { \"-fforce-classes-archive-check\", \n     N_(\"Always check for non gcj generated classes archives\") },\n+  { \"-fno-optimize-static-class-initialization\",\n+    N_(\"Never optimize static class initialization code\") },"}, {"sha": "b9cb0fea7b6f64e609eb50c9a6c3cec681773ec2", "filename": "gcc/java/lang.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -146,6 +146,10 @@ int flag_extraneous_semicolon;\n /* When non zero, always check for a non gcj generated classes archive.  */\n int flag_force_classes_archive_check;\n \n+/* When zero, don't optimize static class initialization. This flag shouldn't\n+   be tested alone, use STATIC_CLASS_INITIALIZATION_OPTIMIZATION_P instead.  */\n+int flag_optimize_sci = 1;\n+\n /* Table of language-dependent -f options.\n    STRING is the option name.  VARIABLE is the address of the variable.\n    ON_VALUE is the value to store in VARIABLE\n@@ -295,6 +299,15 @@ java_decode_option (argc, argv)\n     }\n #undef ARG\n \n+#undef ARG\n+#define ARG \"-fno-optimize-static-class-initialization\"\n+  if (strncmp (p, ARG, sizeof (ARG) - 1) == 0)\n+    {\n+      flag_optimize_sci = 0;\n+      return 1;\n+    }\n+#undef ARG\n+\n   if (p[0] == '-' && p[1] == 'f')\n     {\n       /* Some kind of -f option."}, {"sha": "a1f36aaa281b1771a2b9bb6e1a4d524336ecbe0b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 307, "deletions": 94, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4009bb7d50ece62b164d3717d218ed16b51bddf4/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4009bb7d50ece62b164d3717d218ed16b51bddf4", "patch": "@@ -147,7 +147,9 @@ static tree java_complete_tree PARAMS ((tree));\n static tree maybe_generate_pre_expand_clinit PARAMS ((tree));\n static int analyze_clinit_body PARAMS ((tree));\n static int maybe_yank_clinit PARAMS ((tree));\n+static void start_complete_expand_method PARAMS ((tree));\n static void java_complete_expand_method PARAMS ((tree));\n+static void java_expand_method_bodies PARAMS ((tree));\n static int  unresolved_type_p PARAMS ((tree, tree *));\n static void create_jdep_list PARAMS ((struct parser_ctxt *));\n static tree build_expr_block PARAMS ((tree, tree));\n@@ -332,6 +334,12 @@ static void create_new_parser_context PARAMS ((int));\n static void mark_parser_ctxt PARAMS ((void *));\n static tree maybe_build_class_init_for_field PARAMS ((tree, tree));\n \n+static bool attach_init_test_initialization_flags PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\t\t  PTR));\n+static bool adjust_init_test_initialization PARAMS ((struct hash_entry *,\n+\t\t\t\t\t\t     PTR));\n+static bool emit_test_initialization PARAMS ((struct hash_entry *, PTR));\n+\n /* Number of error found so far. */\n int java_error_count; \n /* Number of warning found so far. */\n@@ -7513,12 +7521,17 @@ java_complete_expand_methods (class_decl)\n   /* First, do the ordinary methods. */\n   for (decl = first_decl; decl; decl = TREE_CHAIN (decl))\n     {\n+      /* Ctors aren't part of this batch. */\n+      if (DECL_CONSTRUCTOR_P (decl) || DECL_CLINIT_P (decl))\n+\tcontinue;\n+      \n       /* Skip abstract or native methods -- but do handle native\n  \t methods when generating JNI stubs.  */\n-      if (METHOD_ABSTRACT (decl)\n- \t  || (! flag_jni && METHOD_NATIVE (decl))\n-\t  || DECL_CONSTRUCTOR_P (decl) || DECL_CLINIT_P (decl))\n-\tcontinue;\n+      if (METHOD_ABSTRACT (decl) || (! flag_jni && METHOD_NATIVE (decl)))\n+\t{\n+\t  DECL_FUNCTION_BODY (decl) = NULL_TREE;\n+\t  continue;\n+\t}\n \n       if (METHOD_NATIVE (decl))\n  \t{\n@@ -7751,118 +7764,180 @@ maybe_yank_clinit (mdecl)\n   return 1;\n }\n \n+/* Install the argument from MDECL. Suitable to completion and\n+   expansion of mdecl's body.  */\n+\n+static void\n+start_complete_expand_method (mdecl)\n+     tree mdecl;\n+{\n+  tree tem, *ptr;\n+\n+  pushlevel (1);\t\t/* Prepare for a parameter push */\n+  ptr = &DECL_ARGUMENTS (mdecl);\n+  tem  = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));\n+\n+  while (tem)\n+    {\n+      tree next = TREE_CHAIN (tem);\n+      tree type = TREE_TYPE (tem);\n+      if (PROMOTE_PROTOTYPES\n+\t  && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n+\t  && INTEGRAL_TYPE_P (type))\n+\ttype = integer_type_node;\n+      DECL_ARG_TYPE (tem) = type;\n+      layout_decl (tem, 0);\n+      pushdecl (tem);\n+      *ptr = tem;\n+      ptr = &TREE_CHAIN (tem);\n+      tem = next;\n+    }\n+  *ptr = NULL_TREE;\n+  pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n+  lineno = DECL_SOURCE_LINE_FIRST (mdecl);\n+  build_result_decl (mdecl);\n+}\n+\n \n /* Complete and expand a method.  */\n \n static void\n java_complete_expand_method (mdecl)\n      tree mdecl;\n {\n-  int yank_clinit = 0;\n+  tree fbody, block_body, exception_copy;\n \n   current_function_decl = mdecl;\n   /* Fix constructors before expanding them */\n   if (DECL_CONSTRUCTOR_P (mdecl))\n     fix_constructors (mdecl);\n   \n   /* Expand functions that have a body */\n-  if (DECL_FUNCTION_BODY (mdecl))\n-    {\n-      tree fbody = DECL_FUNCTION_BODY (mdecl);\n-      tree block_body = BLOCK_EXPR_BODY (fbody);\n-      tree exception_copy = NULL_TREE;\n-      tree tem, *ptr;\n-\n-      current_function_decl = mdecl;\n-\n-      if (! quiet_flag)\n-\tfprintf (stderr, \" [%s.\",\n-\t\t lang_printable_name (DECL_CONTEXT (mdecl), 0));\n-      announce_function (mdecl);\n-      if (! quiet_flag)\n-\tfprintf (stderr, \"]\");\n-\n-      pushlevel (1);\t\t/* Prepare for a parameter push */\n-      ptr = &DECL_ARGUMENTS (mdecl);\n-      tem  = BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (current_function_decl));\n-      while (tem)\n-\t{\n-\t  tree next = TREE_CHAIN (tem);\n-\t  tree type = TREE_TYPE (tem);\n-\t  if (PROMOTE_PROTOTYPES\n-\t      && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n-\t      && INTEGRAL_TYPE_P (type))\n-\t    type = integer_type_node;\n-\t  DECL_ARG_TYPE (tem) = type;\n-\t  layout_decl (tem, 0);\n-\t  pushdecl (tem);\n-\t  *ptr = tem;\n-\t  ptr = &TREE_CHAIN (tem);\n-\t  tem = next;\n-\t}\n-      *ptr = NULL_TREE;\n-      pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n-      lineno = DECL_SOURCE_LINE_FIRST (mdecl);\n-\n-      build_result_decl (mdecl);\n-\n-      current_this \n-\t= (!METHOD_STATIC (mdecl) ? \n-\t   BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)) : NULL_TREE);\n-\n-      /* Purge the `throws' list of unchecked exceptions. If we're\n-\t doing xref, save a copy of the list and re-install it\n-\t later. */\n-      if (flag_emit_xref)\n-\texception_copy = copy_list (DECL_FUNCTION_THROWS (mdecl));\n-\n-      purge_unchecked_exceptions (mdecl);\n-\n-      /* Install exceptions thrown with `throws' */\n-      PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n+  if (!DECL_FUNCTION_BODY (mdecl))\n+    return;\n \n-      if (block_body != NULL_TREE)\n-\t{\n-\t  block_body = java_complete_tree (block_body);\n+  fbody = DECL_FUNCTION_BODY (mdecl);\n+  block_body = BLOCK_EXPR_BODY (fbody);\n+  exception_copy = NULL_TREE;\n \n-\t  if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n-\t    check_for_initialization (block_body);\n-\t  ctxp->explicit_constructor_p = 0;\n-\t}\n+  current_function_decl = mdecl;\n \n-      BLOCK_EXPR_BODY (fbody) = block_body;\n+  if (! quiet_flag)\n+    fprintf (stderr, \" [%s.\",\n+\t     lang_printable_name (DECL_CONTEXT (mdecl), 0));\n+  announce_function (mdecl);\n+  if (! quiet_flag)\n+    fprintf (stderr, \"]\");\n+  \n+  /* Prepare the function for tree completion */\n+  start_complete_expand_method (mdecl);\n \n-      /* If we saw a return but couldn't evaluate it properly, we'll\n-\t have an error_mark_node here. */\n-      if (block_body != error_mark_node\n-\t  && (block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE\n-\t  && !flag_emit_xref)\n-\tmissing_return_error (current_function_decl);\n+  /* Install the current this */\n+  current_this = (!METHOD_STATIC (mdecl) ? \n+\t\t  BLOCK_EXPR_DECLS (DECL_FUNCTION_BODY (mdecl)) : NULL_TREE);\n \n-      /* Check wether we could just get rid of clinit, now the picture\n-         is complete. */\n-      if (!(yank_clinit = maybe_yank_clinit (mdecl)))\n-\tcomplete_start_java_method (mdecl); \n+  /* Purge the `throws' list of unchecked exceptions. If we're doing\n+     xref, save a copy of the list and re-install it later. */\n+  if (flag_emit_xref)\n+    exception_copy = copy_list (DECL_FUNCTION_THROWS (mdecl));\n+  purge_unchecked_exceptions (mdecl);\n+  \n+  /* Install exceptions thrown with `throws' */\n+  PUSH_EXCEPTIONS (DECL_FUNCTION_THROWS (mdecl));\n+  \n+  if (block_body != NULL_TREE)\n+    {\n+      block_body = java_complete_tree (block_body);\n       \n-      /* Don't go any further if we've found error(s) during the\n-\t expansion */\n-      if (!java_error_count && !yank_clinit)\n-\tsource_end_java_method ();\n-      else\n+      /* Before we check initialization, attached all class initialization\n+\t variable to the block_body */\n+      hash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n+\t\t     attach_init_test_initialization_flags, block_body);\n+      \n+      if (! flag_emit_xref && ! METHOD_NATIVE (mdecl))\n \t{\n-\t  if (java_error_count)\n-\t    pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n-\t  poplevel (1, 0, 1);\n+\t  unsigned int state = check_for_initialization (block_body);\n+\t  \n+\t  /* Go through all the flags marking the initialization of\n+\t     static variables and see whether they're definitively\n+\t     assigned, in which case the type is remembered as\n+\t     definitively initialized in MDECL. */\n+\t  if (STATIC_CLASS_INIT_OPT_P ())\n+\t    {\n+\t      hash_traverse (&DECL_FUNCTION_INIT_TEST_TABLE (mdecl),\n+\t\t\t     attach_initialized_static_class, (PTR)&state);\n+\n+\t      /* Always register the context as properly initialized in\n+\t\t MDECL. This used with caution helps removing extra\n+\t\t initialization of self. */\n+\t      if (METHOD_STATIC (mdecl))\n+\t\thash_lookup (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (mdecl),\n+\t\t\t     (hash_table_key) DECL_CONTEXT (mdecl),\n+\t\t\t     TRUE, NULL);\n+\t    }\n \t}\n+      ctxp->explicit_constructor_p = 0;\n+    }\n+  \n+  BLOCK_EXPR_BODY (fbody) = block_body;\n+  \n+  /* If we saw a return but couldn't evaluate it properly, we'll have\n+     an error_mark_node here. */\n+  if (block_body != error_mark_node\n+      && (block_body == NULL_TREE || CAN_COMPLETE_NORMALLY (block_body))\n+      && TREE_CODE (TREE_TYPE (TREE_TYPE (mdecl))) != VOID_TYPE\n+      && !flag_emit_xref)\n+    missing_return_error (current_function_decl);\n \n-      /* Pop the exceptions and sanity check */\n-      POP_EXCEPTIONS();\n-      if (currently_caught_type_list)\n-\tabort ();\n+  /* See if we can get rid of <clinit> if MDECL happens to be <clinit> */\n+  maybe_yank_clinit (mdecl);\n \n-      if (flag_emit_xref)\n-\tDECL_FUNCTION_THROWS (mdecl) = exception_copy;\n+  /* Pop the current level, with special measures if we found errors. */\n+  if (java_error_count)\n+    pushdecl_force_head (DECL_ARGUMENTS (mdecl));\n+  poplevel (1, 0, 1);\n+\n+  /* Pop the exceptions and sanity check */\n+  POP_EXCEPTIONS();\n+  if (currently_caught_type_list)\n+    abort ();\n+\n+  /* Restore the copy of the list of exceptions if emitting xrefs. */\n+  if (flag_emit_xref)\n+    DECL_FUNCTION_THROWS (mdecl) = exception_copy;\n+}\n+\n+/* For with each class for which there's code to generate. */\n+\n+static void\n+java_expand_method_bodies (class)\n+     tree class;\n+{\n+  tree decl;\n+  for (decl = TYPE_METHODS (class); decl; decl = TREE_CHAIN (decl))\n+    {\n+      if (!DECL_FUNCTION_BODY (decl))\n+\tcontinue;\n+\n+      current_function_decl = decl;\n+\n+      /* It's time to assign the variable flagging static class\n+\t initialization based on which classes invoked static methods\n+\t are definitely initializing. This should be flagged. */\n+      if (STATIC_CLASS_INIT_OPT_P ())\n+\thash_traverse (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (decl),\n+\t\t       adjust_init_test_initialization, NULL);\n+\n+      /* Prepare the function for RTL expansion */  \n+      start_complete_expand_method (decl);\n+\n+      /* Expand function start, generate initialization flag\n+\t assignment, and handle synchronized methods. */\n+      complete_start_java_method (decl);\n+\n+      /* Expand the rest of the function body and terminate\n+         expansion. */\n+      source_end_java_method ();\n     }\n }\n \n@@ -8783,7 +8858,10 @@ java_expand_classes ()\n \t  if (flag_emit_xref)\n \t    expand_xref (current_class);\n \t  else if (! flag_syntax_only)\n-\t    finish_class ();\n+\t    {\n+\t      java_expand_method_bodies (current_class);\n+\t      finish_class ();\n+\t    }\n \t}\n     }\n }\n@@ -8963,7 +9041,10 @@ resolve_expression_name (id, orig)\n \t\t      static_ref_err (id, DECL_NAME (decl), current_class);\n \t\t      return error_mark_node;\n \t\t    }\n-\t\t  return build_outer_field_access (id, decl);\n+\t\t  access = build_outer_field_access (id, decl);\n+\t\t  if (orig)\n+\t\t    *orig = access;\n+\t\t  return access;\n \t\t}\n \n \t      /* Otherwise build what it takes to access the field */\n@@ -10438,6 +10519,30 @@ patch_invoke (patch, method, args)\n       TREE_SIDE_EFFECTS (patch) = 1;\n     }\n \n+  /* In order to be able to modify PATCH later, we SAVE_EXPR it and\n+     put it as the first expression of a COMPOUND_EXPR. The second\n+     expression being an empty statement to be later patched if\n+     necessary. We remember a TREE_LIST (the PURPOSE is the method,\n+     the VALUE is the compound) in a hashtable and return a\n+     COMPOUND_EXPR built so that the result of the evaluation of the\n+     original PATCH node is returned. */\n+  if (STATIC_CLASS_INIT_OPT_P ()\n+      && current_function_decl && METHOD_STATIC (method))\n+    {\n+      tree list;\n+      tree fndecl = current_function_decl;\n+      tree save = save_expr (patch);\n+      tree type = TREE_TYPE (patch);\n+\n+      patch = build (COMPOUND_EXPR, type, save, empty_stmt_node);\n+      list = build_tree_list (method, patch);\n+\n+      hash_lookup (&DECL_FUNCTION_STATIC_METHOD_INVOCATION_COMPOUND (fndecl),\n+\t\t   (const hash_table_key) list, TRUE, NULL);\n+\n+      patch = build (COMPOUND_EXPR, type, patch, save);\n+    }\n+\n   return patch;\n }\n \n@@ -15853,3 +15958,111 @@ init_src_parse ()\n   /* Register roots with the garbage collector.  */\n   ggc_add_tree_root (src_parse_roots, sizeof (src_parse_roots) / sizeof(tree));\n }\n+\n+\f\n+\n+/* This section deals with the functions that are called when tables\n+   recording class initialization information are traversed.  */\n+\n+/* Attach to PTR (a block) the declaration found in ENTRY. */\n+\n+static bool\n+attach_init_test_initialization_flags (entry, ptr)\n+     struct hash_entry *entry;\n+     PTR ptr;\n+{\n+  tree block = (tree)ptr;\n+  struct init_test_hash_entry *ite = (struct init_test_hash_entry *) entry;\n+  \n+  TREE_CHAIN (ite->init_test_decl) = BLOCK_EXPR_DECLS (block);\n+  BLOCK_EXPR_DECLS (block) = ite->init_test_decl;\n+  return true;\n+}\n+\n+/* This function is called for each statement calling a static\n+   function.  ENTRY is a TREE_LIST whose PURPOSE is the called\n+   function and VALUE is a compound whose second operand can be\n+   patched with static class initialization flag assignments.  */\n+\n+static bool\n+adjust_init_test_initialization (entry, info)\n+     struct hash_entry *entry;\n+     PTR info ATTRIBUTE_UNUSED;\n+{\n+  tree list = (tree)(entry->key);\n+  tree called_method = TREE_PURPOSE (list);\n+  tree compound = TREE_VALUE (list);\n+  tree assignment_compound_list = build_tree_list (called_method, NULL);\n+\n+  /* For each class definitely initialized in CALLED_METHOD, fill\n+     ASSIGNMENT_COMPOUND with assignment to the class initialization flag. */\n+  hash_traverse (&DECL_FUNCTION_INITIALIZED_CLASS_TABLE (called_method),\n+\t\t emit_test_initialization, assignment_compound_list);\n+\n+  if (TREE_VALUE (assignment_compound_list))\n+    TREE_OPERAND (compound, 1) = TREE_VALUE (assignment_compound_list);\n+\n+  return true;\n+}\n+\n+/* This function is called for each classes that is known definitely\n+   assigned when a given static method was called. This function\n+   augments a compound expression (INFO) storing all assignment to\n+   initialized static class flags if a flag already existed, otherwise\n+   a new one is created.  */\n+\n+static bool\n+emit_test_initialization (entry, info)\n+     struct hash_entry *entry;\n+     PTR info;\n+{\n+  tree l = (tree) info;\n+  tree decl, init;\n+\n+  struct init_test_hash_entry *ite = (struct init_test_hash_entry *)\n+    hash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n+\t\t entry->key, FALSE, NULL);\n+\n+  /* If we haven't found a flag and we're dealing with self registered\n+     with current_function_decl, then don't do anything. Self is\n+     always added as definitely initialized but this information is\n+     valid only if used outside the current function. */\n+  if (! ite)\n+    {\n+      if (current_function_decl != TREE_PURPOSE (l))\n+\tite = (struct init_test_hash_entry *)\n+\t  hash_lookup (&DECL_FUNCTION_INIT_TEST_TABLE (current_function_decl),\n+\t\t       entry->key, TRUE, NULL);\n+      else\n+\treturn true;\n+    }\n+\n+  /* If we don't have a variable, create one and install it. */\n+  if (! ite->init_test_decl)\n+    {\n+      tree block;\n+      \n+      decl = build_decl (VAR_DECL, NULL_TREE, boolean_type_node);\n+      MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC (decl);\n+      LOCAL_CLASS_INITIALIZATION_FLAG (decl) = 1;\n+      DECL_CONTEXT (decl) = current_function_decl;\n+      DECL_INITIAL (decl) = boolean_true_node;\n+\n+      /* The trick is to find the right context for it. */\n+      block = BLOCK_SUBBLOCKS (GET_CURRENT_BLOCK (current_function_decl));\n+      TREE_CHAIN (decl) = BLOCK_EXPR_DECLS (block);\n+      BLOCK_EXPR_DECLS (block) = decl;\n+      ite->init_test_decl = decl;\n+    }\n+  else\n+    decl = ite->init_test_decl;\n+\n+  /* Now simply augment the compound that holds all the assignments\n+     pertaining to this method invocation. */\n+  init = build (MODIFY_EXPR, boolean_type_node, decl, boolean_true_node);\n+  TREE_SIDE_EFFECTS (init) = 1;\n+  TREE_VALUE (l) = add_stmt_to_compound (TREE_VALUE (l), void_type_node, init);\n+  TREE_SIDE_EFFECTS (TREE_VALUE (l)) = 1;\n+\n+  return true;\n+}"}]}