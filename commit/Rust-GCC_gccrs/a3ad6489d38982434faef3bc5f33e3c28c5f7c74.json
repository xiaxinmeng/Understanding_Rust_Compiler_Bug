{"sha": "a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNhZDY0ODlkMzg5ODI0MzRmYWVmM2JjNWYzM2UzYzI4YzVmN2M3NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-05T20:52:35Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-03-05T20:59:25Z"}, "message": "openmp: Avoid ICEs due to orphaned labels in OpenMP regions [PR99322]\n\nWhen performing cfg cleanup at the end of cfg pass, if there are any OpenMP\nregions and some basic blocks are unreachable and contain forced labels,\nremove_bb moves the labels to previous bb, but if the two bb belong to different\nOpenMP regions, that means it will end up in a different function from where\nit was assumed to be and checked e.g. during gimplification or OpenMP region\nSESE checking.\n\nThe following patch will place the labels to some bb from the right OpenMP\nregion if the previous bb is not that.  I think it should happen very rarely,\nnormally the bbs from each OpenMP region should be from the before-cfg pass\nadjacent and the problems will usually be only if the OpenMP regions are\nno-return, so I hope it isn't fatal that it searches through all bbs on the miss.\nIf it turns out to be a problem, it can always lazily create some better data\nstructure and maintain it through bb removals when it reaches that case the\nfirst time.\n\n2021-03-05  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR middle-end/99322\n\t* tree-cfg.c (bb_to_omp_idx): New variable.\n\t(execute_build_cfg): Release the bb_to_omp_idx vector after\n\tcleanup_tree_cfg returns.\n\t(handle_abnormal_edges): Remove bb_to_omp_idx argument, adjust\n\tfor bb_to_omp_idx being a vec<int> instead of pointer to array\n\tof ints.\n\t(make_edges): Remove bb_to_omp_idx local variable, don't pass\n\tit to handle_abnormal_edges, adjust for bb_to_omp_idx being a\n\tvec<int> instead of pointer to array of ints and don't free/release\n\tit at the end.\n\t(remove_bb): When removing a bb and placing forced label somewhere\n\telse, ensure it is put into the same OpenMP region during cfg\n\tpass if possible or to entry successor as fallback.  Unregister\n\tbb from bb_to_omp_idx.\n\n\t* c-c++-common/gomp/pr99322.c: New test.", "tree": {"sha": "d2f291a88c785acbe74821873330542172c3001c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d2f291a88c785acbe74821873330542172c3001c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3ad6489d38982434faef3bc5f33e3c28c5f7c74/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e64dd6b3f6706de571c6ed3c4b7a8c8b67f22b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e64dd6b3f6706de571c6ed3c4b7a8c8b67f22b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e64dd6b3f6706de571c6ed3c4b7a8c8b67f22b7"}], "stats": {"total": 94, "additions": 74, "deletions": 20}, "files": [{"sha": "447dda8974861ad7895c3cd63b13a3d0bf63b540", "filename": "gcc/testsuite/c-c++-common/gomp/pr99322.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ad6489d38982434faef3bc5f33e3c28c5f7c74/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99322.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ad6489d38982434faef3bc5f33e3c28c5f7c74/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99322.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr99322.c?ref=a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "patch": "@@ -0,0 +1,26 @@\n+/* PR middle-end/99322 */\n+/* { dg-do compile } */\n+\n+void foo (void);\n+void qux (void *);\n+\n+void\n+bar (void)\n+{\n+  #pragma omp parallel\n+  for (;;)\n+    for (int i = 0; i < 8; ++i)\n+      foo ();\n+  { lab:; }\n+  qux (&&lab);\n+}\n+\n+void\n+baz (void)\n+{\n+  qux (&&lab);\n+  #pragma omp parallel\n+  for (;;)\n+    ;\n+  lab:;\n+}"}, {"sha": "d04ce212561fd6fa23adc50e517793f050489e2c", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 48, "deletions": 20, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3ad6489d38982434faef3bc5f33e3c28c5f7c74/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3ad6489d38982434faef3bc5f33e3c28c5f7c74/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=a3ad6489d38982434faef3bc5f33e3c28c5f7c74", "patch": "@@ -93,6 +93,9 @@ static hash_map<edge, tree> *edge_to_cases;\n \n static bitmap touched_switch_bbs;\n \n+/* OpenMP region idxs for blocks during cfg pass.  */\n+static vec<int> bb_to_omp_idx;\n+\n /* CFG statistics.  */\n struct cfg_stats_d\n {\n@@ -372,6 +375,9 @@ execute_build_cfg (void)\n       dump_scope_blocks (dump_file, dump_flags);\n     }\n   cleanup_tree_cfg ();\n+\n+  bb_to_omp_idx.release ();\n+\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   replace_loop_annotate ();\n   return 0;\n@@ -724,16 +730,15 @@ get_abnormal_succ_dispatcher (basic_block bb)\n    if COMPUTED_GOTO is false, otherwise factor the computed gotos.  */\n \n static void\n-handle_abnormal_edges (basic_block *dispatcher_bbs,\n-\t\t       basic_block for_bb, int *bb_to_omp_idx,\n+handle_abnormal_edges (basic_block *dispatcher_bbs, basic_block for_bb,\n \t\t       auto_vec<basic_block> *bbs, bool computed_goto)\n {\n   basic_block *dispatcher = dispatcher_bbs + (computed_goto ? 1 : 0);\n   unsigned int idx = 0;\n   basic_block bb;\n   bool inner = false;\n \n-  if (bb_to_omp_idx)\n+  if (!bb_to_omp_idx.is_empty ())\n     {\n       dispatcher = dispatcher_bbs + 2 * bb_to_omp_idx[for_bb->index];\n       if (bb_to_omp_idx[for_bb->index] != 0)\n@@ -748,7 +753,7 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n       /* Check if there are any basic blocks that need to have\n \t abnormal edges to this dispatcher.  If there are none, return\n \t early.  */\n-      if (bb_to_omp_idx == NULL)\n+      if (bb_to_omp_idx.is_empty ())\n \t{\n \t  if (bbs->is_empty ())\n \t    return;\n@@ -790,7 +795,7 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n \n \t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n \t    {\n-\t      if (bb_to_omp_idx\n+\t      if (!bb_to_omp_idx.is_empty ()\n \t\t  && bb_to_omp_idx[bb->index] != bb_to_omp_idx[for_bb->index])\n \t\tcontinue;\n \n@@ -820,7 +825,7 @@ handle_abnormal_edges (basic_block *dispatcher_bbs,\n \t  /* Create predecessor edges of the dispatcher.  */\n \t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n \t    {\n-\t      if (bb_to_omp_idx\n+\t      if (!bb_to_omp_idx.is_empty ()\n \t\t  && bb_to_omp_idx[bb->index] != bb_to_omp_idx[for_bb->index])\n \t\tcontinue;\n \t      make_edge (bb, *dispatcher, EDGE_ABNORMAL);\n@@ -957,7 +962,6 @@ make_edges (void)\n   struct omp_region *cur_region = NULL;\n   auto_vec<basic_block> ab_edge_goto;\n   auto_vec<basic_block> ab_edge_call;\n-  int *bb_to_omp_idx = NULL;\n   int cur_omp_region_idx = 0;\n \n   /* Create an edge from entry to the first block with executable\n@@ -971,7 +975,7 @@ make_edges (void)\n     {\n       int mer;\n \n-      if (bb_to_omp_idx)\n+      if (!bb_to_omp_idx.is_empty ())\n \tbb_to_omp_idx[bb->index] = cur_omp_region_idx;\n \n       mer = make_edges_bb (bb, &cur_region, &cur_omp_region_idx);\n@@ -980,8 +984,8 @@ make_edges (void)\n       else if (mer == 2)\n \tab_edge_call.safe_push (bb);\n \n-      if (cur_region && bb_to_omp_idx == NULL)\n-\tbb_to_omp_idx = XCNEWVEC (int, n_basic_blocks_for_fn (cfun));\n+      if (cur_region && bb_to_omp_idx.is_empty ())\n+\tbb_to_omp_idx.safe_grow_cleared (n_basic_blocks_for_fn (cfun), true);\n     }\n \n   /* Computed gotos are hell to deal with, especially if there are\n@@ -1006,7 +1010,7 @@ make_edges (void)\n       basic_block *dispatcher_bbs = dispatcher_bb_array;\n       int count = n_basic_blocks_for_fn (cfun);\n \n-      if (bb_to_omp_idx)\n+      if (!bb_to_omp_idx.is_empty ())\n \tdispatcher_bbs = XCNEWVEC (basic_block, 2 * count);\n \n       FOR_EACH_BB_FN (bb, cfun)\n@@ -1024,12 +1028,12 @@ make_edges (void)\n \t      /* Make an edge to every label block that has been marked as a\n \t\t potential target for a computed goto or a non-local goto.  */\n \t      if (FORCED_LABEL (target))\n-\t\thandle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n-\t\t\t\t       &ab_edge_goto, true);\n+\t\thandle_abnormal_edges (dispatcher_bbs, bb, &ab_edge_goto,\n+\t\t\t\t       true);\n \t      if (DECL_NONLOCAL (target))\n \t\t{\n-\t\t  handle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n-\t\t\t\t\t &ab_edge_call, false);\n+\t\t  handle_abnormal_edges (dispatcher_bbs, bb, &ab_edge_call,\n+\t\t\t\t\t false);\n \t\t  break;\n \t\t}\n \t    }\n@@ -1044,17 +1048,15 @@ make_edges (void)\n \t\t  && ((gimple_call_flags (call_stmt) & ECF_RETURNS_TWICE)\n \t\t      || gimple_call_builtin_p (call_stmt,\n \t\t\t\t\t\tBUILT_IN_SETJMP_RECEIVER)))\n-\t\thandle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n-\t\t\t\t       &ab_edge_call, false);\n+\t\thandle_abnormal_edges (dispatcher_bbs, bb, &ab_edge_call,\n+\t\t\t\t       false);\n \t    }\n \t}\n \n-      if (bb_to_omp_idx)\n+      if (!bb_to_omp_idx.is_empty ())\n \tXDELETE (dispatcher_bbs);\n     }\n \n-  XDELETE (bb_to_omp_idx);\n-\n   omp_free_regions ();\n }\n \n@@ -2301,6 +2303,30 @@ remove_bb (basic_block bb)\n \t\t  new_bb = single_succ (new_bb);\n \t\t  gcc_assert (new_bb != bb);\n \t\t}\n+\t      if ((unsigned) bb->index < bb_to_omp_idx.length ()\n+\t\t  && ((unsigned) new_bb->index >= bb_to_omp_idx.length ()\n+\t\t      || (bb_to_omp_idx[bb->index]\n+\t\t\t  != bb_to_omp_idx[new_bb->index])))\n+\t\t{\n+\t\t  /* During cfg pass make sure to put orphaned labels\n+\t\t     into the right OMP region.  */\n+\t\t  unsigned int i;\n+\t\t  int idx;\n+\t\t  new_bb = NULL;\n+\t\t  FOR_EACH_VEC_ELT (bb_to_omp_idx, i, idx)\n+\t\t    if (i >= NUM_FIXED_BLOCKS\n+\t\t\t&& idx == bb_to_omp_idx[bb->index]\n+\t\t\t&& i != (unsigned) bb->index)\n+\t\t      {\n+\t\t\tnew_bb = BASIC_BLOCK_FOR_FN (cfun, i);\n+\t\t\tbreak;\n+\t\t      }\n+\t\t  if (new_bb == NULL)\n+\t\t    {\n+\t\t      new_bb = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n+\t\t      gcc_assert (new_bb != bb);\n+\t\t    }\n+\t\t}\n \t      new_gsi = gsi_after_labels (new_bb);\n \t      gsi_remove (&i, false);\n \t      gsi_insert_before (&new_gsi, stmt, GSI_NEW_STMT);\n@@ -2319,6 +2345,8 @@ remove_bb (basic_block bb)\n \t}\n     }\n \n+  if ((unsigned) bb->index < bb_to_omp_idx.length ())\n+    bb_to_omp_idx[bb->index] = -1;\n   remove_phi_nodes_and_edges_for_unreachable_block (bb);\n   bb->il.gimple.seq = NULL;\n   bb->il.gimple.phi_nodes = NULL;"}]}