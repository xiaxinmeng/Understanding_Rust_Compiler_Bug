{"sha": "f7bb41af65aa53933814ec82474497876d396b33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdiYjQxYWY2NWFhNTM5MzM4MTRlYzgyNDc0NDk3ODc2ZDM5NmIzMw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-02T07:14:48Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-09-02T07:14:48Z"}, "message": "[multiple changes]\n\n2011-09-02  Bob Duff  <duff@adacore.com>\n\n\t* einfo.adb: (Has_Xref_Entry): Do not call\n\tImplementation_Base_Type. Lib.Xref has been\n\trewritten to avoid the need for it, and it was costly.\n\t* s-htable.ads,s-htable.adb: (Present,Set_If_Not_Present): New\n\tfunctions in support of efficient xref.\n\t* lib-xref-alfa.adb: Misc changes related to Key component of\n\ttype Xref_Entry.\n\t* lib-xref.adb: (Add_Entry,etc): Speed improvement.\n\t(New_Entry): Call Implementation_Base_Type, because Has_Xref_Entry\n\tno longer does. This is the one place where it is needed.\n\n2011-09-02  Johannes Kanig  <kanig@adacore.com>\n\n\t* g-comlin.adb (Getopt): New optional argument Concatenate to have\n\tsimilar interface as the other Getopt function.\n\n2011-09-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb: (Expand_Allocator_Expression): Do not generate\n\ta call to Set_Finalize_Address if there is no allocator available.\n\t* exp_util.adb: (Build_Allocate_Deallocate_Proc): Account for\n\ta case of allocator expansion where the allocator is not expanded but\n\tneeds a custom allocate routine. Code reformatting.\n\t(Is_Finalizable_Transient): Remove local variables Has_Rens and\n\tRen_Obj. Code reformatting.\n\t(Is_Renamed): Renamed to Is_Aliased. Add code to detect aliasing\n\tthrough the use of 'reference.\n\t* sem_ch4.adb: (Analyze_Allocator): Detect allocators generated\n\tas part of build-in-place expansion. They are intentionally marked as\n\tcoming from source, but their parents are not.\n\nFrom-SVN: r178436", "tree": {"sha": "8c77a20466ed1782c4853f1bf84f75cd195f61f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8c77a20466ed1782c4853f1bf84f75cd195f61f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7bb41af65aa53933814ec82474497876d396b33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7bb41af65aa53933814ec82474497876d396b33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7bb41af65aa53933814ec82474497876d396b33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7bb41af65aa53933814ec82474497876d396b33/comments", "author": null, "committer": null, "parents": [{"sha": "bd0bc43e58edb507c01ecabdfdf0e7717a825324", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd0bc43e58edb507c01ecabdfdf0e7717a825324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd0bc43e58edb507c01ecabdfdf0e7717a825324"}], "stats": {"total": 828, "additions": 530, "deletions": 298}, "files": [{"sha": "8f63086a214952cba8389cde94c07e1c28ddce7c", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -1,3 +1,36 @@\n+2011-09-02  Bob Duff  <duff@adacore.com>\n+\n+\t* einfo.adb: (Has_Xref_Entry): Do not call\n+\tImplementation_Base_Type. Lib.Xref has been\n+\trewritten to avoid the need for it, and it was costly.\n+\t* s-htable.ads,s-htable.adb: (Present,Set_If_Not_Present): New\n+\tfunctions in support of efficient xref.\n+\t* lib-xref-alfa.adb: Misc changes related to Key component of\n+\ttype Xref_Entry.\n+\t* lib-xref.adb: (Add_Entry,etc): Speed improvement.\n+\t(New_Entry): Call Implementation_Base_Type, because Has_Xref_Entry\n+\tno longer does. This is the one place where it is needed.\n+\n+2011-09-02  Johannes Kanig  <kanig@adacore.com>\n+\n+\t* g-comlin.adb (Getopt): New optional argument Concatenate to have\n+\tsimilar interface as the other Getopt function.\n+\n+2011-09-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb: (Expand_Allocator_Expression): Do not generate\n+\ta call to Set_Finalize_Address if there is no allocator available.\n+\t* exp_util.adb: (Build_Allocate_Deallocate_Proc): Account for\n+\ta case of allocator expansion where the allocator is not expanded but\n+\tneeds a custom allocate routine. Code reformatting.\n+\t(Is_Finalizable_Transient): Remove local variables Has_Rens and\n+\tRen_Obj. Code reformatting.\n+\t(Is_Renamed): Renamed to Is_Aliased. Add code to detect aliasing\n+\tthrough the use of 'reference.\n+\t* sem_ch4.adb: (Analyze_Allocator): Detect allocators generated\n+\tas part of build-in-place expansion. They are intentionally marked as\n+\tcoming from source, but their parents are not.\n+\n 2011-09-02  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_ch10.adb (Analyze_With_Clause): If the library unit"}, {"sha": "494f31b9f1c55c38ff56baab8b7f9fedddc9382c", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -1599,7 +1599,7 @@ package body Einfo is\n \n    function Has_Xref_Entry (Id : E) return B is\n    begin\n-      return Flag182 (Implementation_Base_Type (Id));\n+      return Flag182 (Id);\n    end Has_Xref_Entry;\n \n    function Hiding_Loop_Variable (Id : E) return E is"}, {"sha": "3c6754b26bb6da5c0650a5d4177cbcaedd96af3f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -1137,11 +1137,14 @@ package body Exp_Ch4 is\n \n             --  Since .NET/JVM compilers do not support address arithmetic,\n             --  this call is skipped. The same is done for CodePeer because\n-            --  primitive Finalize_Address is never generated.\n+            --  primitive Finalize_Address is never generated. Do not create\n+            --  this call if there is no allocator available any more.\n \n             if VM_Target = No_VM\n               and then not CodePeer_Mode\n               and then Present (Finalization_Master (PtrT))\n+              and then Present (Temp_Decl)\n+              and then Nkind (Expression (Temp_Decl)) = N_Allocator\n             then\n                Insert_Action (N,\n                  Make_Set_Finalize_Address_Call"}, {"sha": "65311f8eec3b517671aa7ae0d9f4af9adf0c6253", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 81, "deletions": 54, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -494,13 +494,39 @@ package body Exp_Util is\n             Expr := N;\n          end if;\n \n-         Ptr_Typ := Base_Type (Etype (Expr));\n+         --  In certain cases an allocator with a qualified expression may\n+         --  be relocated and used as the initialization expression of a\n+         --  temporary:\n+\n+         --    before:\n+         --       Obj : Ptr_Typ := new Desig_Typ'(...);\n+\n+         --    after:\n+         --       Tmp : Ptr_Typ := new Desig_Typ'(...);\n+         --       Obj : Ptr_Typ := Tmp;\n+\n+         --  Since the allocator is always marked as analyzed to avoid infinite\n+         --  expansion, it will never be processed by this routine given that\n+         --  the designated type needs finalization actions. Detect this case\n+         --  and complete the expansion of the allocator.\n+\n+         if Nkind (Expr) = N_Identifier\n+           and then Nkind (Parent (Entity (Expr))) = N_Object_Declaration\n+           and then Nkind (Expression (Parent (Entity (Expr)))) = N_Allocator\n+         then\n+            Build_Allocate_Deallocate_Proc (Parent (Entity (Expr)), True);\n+            return;\n+         end if;\n \n-         --  The allocator may have been rewritten into something else\n+         --  The allocator may have been rewritten into something else in which\n+         --  case the expansion performed by this routine does not apply.\n \n-         if Nkind (Expr) = N_Allocator then\n-            Proc_To_Call := Procedure_To_Call (Expr);\n+         if Nkind (Expr) /= N_Allocator then\n+            return;\n          end if;\n+\n+         Ptr_Typ := Base_Type (Etype (Expr));\n+         Proc_To_Call := Procedure_To_Call (Expr);\n       end if;\n \n       Pool_Id := Associated_Storage_Pool (Ptr_Typ);\n@@ -3723,11 +3749,9 @@ package body Exp_Util is\n      (Decl     : Node_Id;\n       Rel_Node : Node_Id) return Boolean\n    is\n-      Obj_Id   : constant Entity_Id := Defining_Identifier (Decl);\n-      Obj_Typ  : constant Entity_Id := Base_Type (Etype (Obj_Id));\n-      Desig    : Entity_Id := Obj_Typ;\n-      Has_Rens : Boolean   := True;\n-      Ren_Obj  : Entity_Id;\n+      Obj_Id  : constant Entity_Id := Defining_Identifier (Decl);\n+      Obj_Typ : constant Entity_Id := Base_Type (Etype (Obj_Id));\n+      Desig   : Entity_Id := Obj_Typ;\n \n       function Initialized_By_Access (Trans_Id : Entity_Id) return Boolean;\n       --  Determine whether transient object Trans_Id is initialized either\n@@ -3741,14 +3765,15 @@ package body Exp_Util is\n       --  value 1 and BIPaccess is not null. This case creates an aliasing\n       --  between the returned value and the value denoted by BIPaccess.\n \n-      function Is_Allocated (Trans_Id : Entity_Id) return Boolean;\n-      --  Determine whether transient object Trans_Id is allocated on the heap\n-\n-      function Is_Renamed\n+      function Is_Aliased\n         (Trans_Id   : Entity_Id;\n          First_Stmt : Node_Id) return Boolean;\n-      --  Determine whether transient object Trans_Id has been renamed in the\n-      --  statement list starting from First_Stmt.\n+      --  Determine whether transient object Trans_Id has been renamed or\n+      --  aliased through 'reference in the statement list starting from\n+      --  First_Stmt.\n+\n+      function Is_Allocated (Trans_Id : Entity_Id) return Boolean;\n+      --  Determine whether transient object Trans_Id is allocated on the heap\n \n       ---------------------------\n       -- Initialized_By_Access --\n@@ -3849,30 +3874,14 @@ package body Exp_Util is\n          return False;\n       end Initialized_By_Aliased_BIP_Func_Call;\n \n-      ------------------\n-      -- Is_Allocated --\n-      ------------------\n-\n-      function Is_Allocated (Trans_Id : Entity_Id) return Boolean is\n-         Expr : constant Node_Id := Expression (Parent (Trans_Id));\n-\n-      begin\n-         return\n-           Is_Access_Type (Etype (Trans_Id))\n-             and then Present (Expr)\n-             and then Nkind (Expr) = N_Allocator;\n-      end Is_Allocated;\n-\n       ----------------\n-      -- Is_Renamed --\n+      -- Is_Aliased --\n       ----------------\n \n-      function Is_Renamed\n+      function Is_Aliased\n         (Trans_Id   : Entity_Id;\n          First_Stmt : Node_Id) return Boolean\n       is\n-         Stmt : Node_Id;\n-\n          function Extract_Renamed_Object\n            (Ren_Decl : Node_Id) return Entity_Id;\n          --  Given an object renaming declaration, retrieve the entity of the\n@@ -3918,26 +3927,30 @@ package body Exp_Util is\n             return Empty;\n          end Extract_Renamed_Object;\n \n-      --  Start of processing for Is_Renamed\n-\n-      begin\n-         --  If a previous invocation of this routine has determined that a\n-         --  list has no renamings, then no point in repeating the same scan.\n-\n-         if not Has_Rens then\n-            return False;\n-         end if;\n+         --  Local variables\n \n-         --  Assume that the statement list does not have a renaming. This is a\n-         --  minor optimization.\n+         Expr    : Node_Id;\n+         Ren_Obj : Entity_Id;\n+         Stmt    : Node_Id;\n \n-         Has_Rens := False;\n+      --  Start of processing for Is_Aliased\n \n+      begin\n          Stmt := First_Stmt;\n          while Present (Stmt) loop\n-            if Nkind (Stmt) = N_Object_Renaming_Declaration then\n-               Has_Rens := True;\n-               Ren_Obj  := Extract_Renamed_Object (Stmt);\n+            if Nkind (Stmt) = N_Object_Declaration then\n+               Expr := Expression (Stmt);\n+\n+               if Present (Expr)\n+                 and then Nkind (Expr) = N_Reference\n+                 and then Nkind (Prefix (Expr)) = N_Identifier\n+                 and then Entity (Prefix (Expr)) = Trans_Id\n+               then\n+                  return True;\n+               end if;\n+\n+            elsif Nkind (Stmt) = N_Object_Renaming_Declaration then\n+               Ren_Obj := Extract_Renamed_Object (Stmt);\n \n                if Present (Ren_Obj)\n                  and then Ren_Obj = Trans_Id\n@@ -3950,7 +3963,21 @@ package body Exp_Util is\n          end loop;\n \n          return False;\n-      end Is_Renamed;\n+      end Is_Aliased;\n+\n+      ------------------\n+      -- Is_Allocated --\n+      ------------------\n+\n+      function Is_Allocated (Trans_Id : Entity_Id) return Boolean is\n+         Expr : constant Node_Id := Expression (Parent (Trans_Id));\n+\n+      begin\n+         return\n+           Is_Access_Type (Etype (Trans_Id))\n+             and then Present (Expr)\n+             and then Nkind (Expr) = N_Allocator;\n+      end Is_Allocated;\n \n    --  Start of processing for Is_Finalizable_Transient\n \n@@ -3967,6 +3994,11 @@ package body Exp_Util is\n           and then Requires_Transient_Scope (Desig)\n           and then Nkind (Rel_Node) /= N_Simple_Return_Statement\n \n+         --  Do not consider renamed or 'reference-d transient objects because\n+         --  the act of renaming extends the object's lifetime.\n+\n+          and then not Is_Aliased (Obj_Id, Decl)\n+\n          --  Do not consider transient objects allocated on the heap since they\n          --  are attached to a finalization master.\n \n@@ -3985,11 +4017,6 @@ package body Exp_Util is\n \n           and then not Initialized_By_Aliased_BIP_Func_Call (Obj_Id)\n \n-         --  Do not consider renamed transient objects because the act of\n-         --  renaming extends the object's lifetime.\n-\n-          and then not Is_Renamed (Obj_Id, Decl)\n-\n          --  Do not consider conversions of tags to class-wide types\n \n           and then not Is_Tag_To_CW_Conversion (Obj_Id);"}, {"sha": "cce88b9daedb9c1a34e862394e544af0c811f2db", "filename": "gcc/ada/g-comlin.adb", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fg-comlin.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fg-comlin.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -3236,9 +3236,10 @@ package body GNAT.Command_Line is\n    ------------\n \n    procedure Getopt\n-     (Config   : Command_Line_Configuration;\n-      Callback : Switch_Handler := null;\n-      Parser   : Opt_Parser     := Command_Line_Parser)\n+     (Config      : Command_Line_Configuration;\n+      Callback    : Switch_Handler := null;\n+      Parser      : Opt_Parser := Command_Line_Parser;\n+      Concatenate : Boolean := True)\n    is\n       Getopt_Switches : String_Access;\n       C               : Character := ASCII.NUL;\n@@ -3373,7 +3374,7 @@ package body GNAT.Command_Line is\n \n       loop\n          C := Getopt (Switches    => Getopt_Switches.all,\n-                      Concatenate => True,\n+                      Concatenate => Concatenate,\n                       Parser      => Parser);\n \n          if C = '*' then"}, {"sha": "f19d7baea5b1f37c8615e7c6dc338380c557dfa8", "filename": "gcc/ada/g-comlin.ads", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fg-comlin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fg-comlin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-comlin.ads?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -703,9 +703,10 @@ package GNAT.Command_Line is\n    --  switch.\n \n    procedure Getopt\n-     (Config   : Command_Line_Configuration;\n-      Callback : Switch_Handler := null;\n-      Parser   : Opt_Parser := Command_Line_Parser);\n+     (Config      : Command_Line_Configuration;\n+      Callback    : Switch_Handler := null;\n+      Parser      : Opt_Parser := Command_Line_Parser;\n+      Concatenate : Boolean := True);\n    --  Similar to the standard Getopt function.\n    --  For each switch found on the command line, this calls Callback, if the\n    --  switch is not handled automatically.\n@@ -716,6 +717,9 @@ package GNAT.Command_Line is\n    --  variable). This function will in fact never call [Callback] if all\n    --  switches were handled automatically and there is nothing left to do.\n    --\n+   --  The option Concatenate is identical to the one of the standard Getopt\n+   --  function.\n+   --\n    --  This procedure automatically adds -h and --help to the valid switches,\n    --  to display the help message and raises Exit_From_Command_Line.\n    --  If an invalid switch is specified on the command line, this procedure"}, {"sha": "8a29818f37c67e858bf44d3a119f103bab7b3d6a", "filename": "gcc/ada/lib-xref-alfa.adb", "status": "modified", "additions": 63, "deletions": 56, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Flib-xref-alfa.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Flib-xref-alfa.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref-alfa.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -456,10 +456,11 @@ package body Alfa is\n          --  Second test: within same unit, sort by location of the scope of\n          --  the entity definition.\n \n-         elsif Get_Scope_Num (T1.Ent_Scope) /=\n-           Get_Scope_Num (T2.Ent_Scope)\n+         elsif Get_Scope_Num (T1.Key.Ent_Scope) /=\n+           Get_Scope_Num (T2.Key.Ent_Scope)\n          then\n-            return Get_Scope_Num (T1.Ent_Scope) < Get_Scope_Num (T2.Ent_Scope);\n+            return Get_Scope_Num (T1.Key.Ent_Scope) <\n+              Get_Scope_Num (T2.Key.Ent_Scope);\n \n          --  Third test: within same unit and scope, sort by location of\n          --  entity definition.\n@@ -470,41 +471,47 @@ package body Alfa is\n          --  Fourth test: if reference is in same unit as entity definition,\n          --  sort first.\n \n-         elsif T1.Lun /= T2.Lun and then T1.Ent_Scope_File = T1.Lun then\n+         elsif\n+           T1.Key.Lun /= T2.Key.Lun and then T1.Ent_Scope_File = T1.Key.Lun\n+         then\n             return True;\n-         elsif T1.Lun /= T2.Lun and then T2.Ent_Scope_File = T2.Lun then\n+\n+         elsif\n+           T1.Key.Lun /= T2.Key.Lun and then T2.Ent_Scope_File = T2.Key.Lun\n+         then\n             return False;\n \n          --  Fifth test: if reference is in same unit and same scope as entity\n          --  definition, sort first.\n \n-         elsif T1.Ent_Scope_File = T1.Lun\n-           and then T1.Ref_Scope /= T2.Ref_Scope\n-           and then T1.Ent_Scope = T1.Ref_Scope\n+         elsif T1.Ent_Scope_File = T1.Key.Lun\n+           and then T1.Key.Ref_Scope /= T2.Key.Ref_Scope\n+           and then T1.Key.Ent_Scope = T1.Key.Ref_Scope\n          then\n             return True;\n-         elsif T1.Ent_Scope_File = T1.Lun\n-           and then T1.Ref_Scope /= T2.Ref_Scope\n-           and then T2.Ent_Scope = T2.Ref_Scope\n+         elsif T1.Ent_Scope_File = T1.Key.Lun\n+           and then T1.Key.Ref_Scope /= T2.Key.Ref_Scope\n+           and then T2.Key.Ent_Scope = T2.Key.Ref_Scope\n          then\n             return False;\n \n          --  Sixth test: for same entity, sort by reference location unit\n \n-         elsif T1.Lun /= T2.Lun then\n-            return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n+         elsif T1.Key.Lun /= T2.Key.Lun then\n+            return Dependency_Num (T1.Key.Lun) < Dependency_Num (T2.Key.Lun);\n \n          --  Seventh test: for same entity, sort by reference location scope\n \n-         elsif Get_Scope_Num (T1.Ref_Scope) /=\n-           Get_Scope_Num (T2.Ref_Scope)\n+         elsif Get_Scope_Num (T1.Key.Ref_Scope) /=\n+           Get_Scope_Num (T2.Key.Ref_Scope)\n          then\n-            return Get_Scope_Num (T1.Ref_Scope) < Get_Scope_Num (T2.Ref_Scope);\n+            return Get_Scope_Num (T1.Key.Ref_Scope) <\n+              Get_Scope_Num (T2.Key.Ref_Scope);\n \n          --  Eighth test: order of location within referencing unit\n \n-         elsif T1.Loc /= T2.Loc then\n-            return T1.Loc < T2.Loc;\n+         elsif T1.Key.Loc /= T2.Key.Loc then\n+            return T1.Key.Loc < T2.Key.Loc;\n \n          --  Finally, for two locations at the same address prefer the one that\n          --  does NOT have the type 'r', so that a modification or extension\n@@ -513,7 +520,7 @@ package body Alfa is\n          --  in-out actuals, the read reference follows the modify reference.\n \n          else\n-            return T2.Typ = 'r';\n+            return T2.Key.Typ = 'r';\n          end if;\n       end Lt;\n \n@@ -563,7 +570,7 @@ package body Alfa is\n \n          --  Set entity at this point with newly created \"Heap\" variable\n \n-         Xrefs.Table (Xrefs.Last).Ent := Heap;\n+         Xrefs.Table (Xrefs.Last).Key.Ent := Heap;\n \n          Nrefs         := Nrefs + 1;\n          Rnums (Nrefs) := Xrefs.Last;\n@@ -637,13 +644,13 @@ package body Alfa is\n          Nrefs := 0;\n \n          for J in 1 .. NR loop\n-            if Alfa_Entities (Ekind (Xrefs.Table (Rnums (J)).Ent))\n-              and then Alfa_References (Xrefs.Table (Rnums (J)).Typ)\n-              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Ent_Scope)\n-              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Ref_Scope)\n-              and then not Is_Global_Constant (Xrefs.Table (Rnums (J)).Ent)\n-              and then Is_Alfa_Reference (Xrefs.Table (Rnums (J)).Ent,\n-                                          Xrefs.Table (Rnums (J)).Typ)\n+            if Alfa_Entities (Ekind (Xrefs.Table (Rnums (J)).Key.Ent))\n+              and then Alfa_References (Xrefs.Table (Rnums (J)).Key.Typ)\n+              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Key.Ent_Scope)\n+              and then Is_Alfa_Scope (Xrefs.Table (Rnums (J)).Key.Ref_Scope)\n+              and then not Is_Global_Constant (Xrefs.Table (Rnums (J)).Key.Ent)\n+              and then Is_Alfa_Reference (Xrefs.Table (Rnums (J)).Key.Ent,\n+                                          Xrefs.Table (Rnums (J)).Key.Typ)\n             then\n                Nrefs         := Nrefs + 1;\n                Rnums (Nrefs) := Rnums (J);\n@@ -695,12 +702,12 @@ package body Alfa is\n          Prevt := 'm';\n \n          for J in 1 .. NR loop\n-            if Xrefs.Table (Rnums (J)).Loc /= Crloc\n+            if Xrefs.Table (Rnums (J)).Key.Loc /= Crloc\n               or else (Prevt = 'm'\n-                        and then Xrefs.Table (Rnums (J)).Typ = 'r')\n+                        and then Xrefs.Table (Rnums (J)).Key.Typ = 'r')\n             then\n-               Crloc         := Xrefs.Table (Rnums (J)).Loc;\n-               Prevt         := Xrefs.Table (Rnums (J)).Typ;\n+               Crloc         := Xrefs.Table (Rnums (J)).Key.Loc;\n+               Prevt         := Xrefs.Table (Rnums (J)).Key.Typ;\n                Nrefs         := Nrefs + 1;\n                Rnums (Nrefs) := Rnums (J);\n             end if;\n@@ -814,53 +821,53 @@ package body Alfa is\n             --  construction of the scope table, or an erroneous scope for the\n             --  current cross-reference.\n \n-            pragma Assert (Is_Future_Scope_Entity (XE.Ent_Scope));\n+            pragma Assert (Is_Future_Scope_Entity (XE.Key.Ent_Scope));\n \n             --  Update the range of cross references to which the current scope\n             --  refers to. This may be the empty range only for the first scope\n             --  considered.\n \n-            if XE.Ent_Scope /= Cur_Scope then\n+            if XE.Key.Ent_Scope /= Cur_Scope then\n                Alfa_Scope_Table.Table (Cur_Scope_Idx).From_Xref :=\n                  From_Xref_Idx;\n                Alfa_Scope_Table.Table (Cur_Scope_Idx).To_Xref :=\n                  Alfa_Xref_Table.Last;\n                From_Xref_Idx := Alfa_Xref_Table.Last + 1;\n             end if;\n \n-            while XE.Ent_Scope /= Cur_Scope loop\n+            while XE.Key.Ent_Scope /= Cur_Scope loop\n                Cur_Scope_Idx := Cur_Scope_Idx + 1;\n                pragma Assert (Cur_Scope_Idx <= Alfa_Scope_Table.Last);\n             end loop;\n \n-            if XE.Ent /= Cur_Entity then\n+            if XE.Key.Ent /= Cur_Entity then\n                Cur_Entity_Name :=\n-                 new String'(Unique_Name (XE.Ent));\n+                 new String'(Unique_Name (XE.Key.Ent));\n             end if;\n \n-            if XE.Ent = Heap then\n+            if XE.Key.Ent = Heap then\n                Alfa_Xref_Table.Append (\n                  (Entity_Name => Cur_Entity_Name,\n                   Entity_Line => 0,\n-                  Etype       => Get_Entity_Type (XE.Ent),\n+                  Etype       => Get_Entity_Type (XE.Key.Ent),\n                   Entity_Col  => 0,\n-                  File_Num    => Dependency_Num (XE.Lun),\n-                  Scope_Num   => Get_Scope_Num (XE.Ref_Scope),\n-                  Line        => Int (Get_Logical_Line_Number (XE.Loc)),\n-                  Rtype       => XE.Typ,\n-                  Col         => Int (Get_Column_Number (XE.Loc))));\n+                  File_Num    => Dependency_Num (XE.Key.Lun),\n+                  Scope_Num   => Get_Scope_Num (XE.Key.Ref_Scope),\n+                  Line        => Int (Get_Logical_Line_Number (XE.Key.Loc)),\n+                  Rtype       => XE.Key.Typ,\n+                  Col         => Int (Get_Column_Number (XE.Key.Loc))));\n \n             else\n                Alfa_Xref_Table.Append (\n                  (Entity_Name => Cur_Entity_Name,\n                   Entity_Line => Int (Get_Logical_Line_Number (XE.Def)),\n-                  Etype       => Get_Entity_Type (XE.Ent),\n+                  Etype       => Get_Entity_Type (XE.Key.Ent),\n                   Entity_Col  => Int (Get_Column_Number (XE.Def)),\n-                  File_Num    => Dependency_Num (XE.Lun),\n-                  Scope_Num   => Get_Scope_Num (XE.Ref_Scope),\n-                  Line        => Int (Get_Logical_Line_Number (XE.Loc)),\n-                  Rtype       => XE.Typ,\n-                  Col         => Int (Get_Column_Number (XE.Loc))));\n+                  File_Num    => Dependency_Num (XE.Key.Lun),\n+                  Scope_Num   => Get_Scope_Num (XE.Key.Ref_Scope),\n+                  Line        => Int (Get_Logical_Line_Number (XE.Key.Loc)),\n+                  Rtype       => XE.Key.Typ,\n+                  Col         => Int (Get_Column_Number (XE.Key.Loc))));\n             end if;\n          end Add_One_Xref;\n       end loop;\n@@ -1071,20 +1078,20 @@ package body Alfa is\n \n          --  Entity is filled later on with the special \"Heap\" variable\n \n-         Drefs.Table (Indx).Ent := Empty;\n+         Drefs.Table (Indx).Key.Ent := Empty;\n \n          Drefs.Table (Indx).Def := No_Location;\n-         Drefs.Table (Indx).Loc := Ref;\n-         Drefs.Table (Indx).Typ := Typ;\n+         Drefs.Table (Indx).Key.Loc := Ref;\n+         Drefs.Table (Indx).Key.Typ := Typ;\n \n          --  It is as if the special \"Heap\" was defined in every scope where it\n          --  is referenced.\n \n-         Drefs.Table (Indx).Eun := Get_Source_Unit (Ref);\n-         Drefs.Table (Indx).Lun := Get_Source_Unit (Ref);\n+         Drefs.Table (Indx).Key.Eun := Get_Source_Unit (Ref);\n+         Drefs.Table (Indx).Key.Lun := Get_Source_Unit (Ref);\n \n-         Drefs.Table (Indx).Ref_Scope := Ref_Scope;\n-         Drefs.Table (Indx).Ent_Scope := Ref_Scope;\n+         Drefs.Table (Indx).Key.Ref_Scope := Ref_Scope;\n+         Drefs.Table (Indx).Key.Ent_Scope := Ref_Scope;\n          Drefs.Table (Indx).Ent_Scope_File := Get_Source_Unit (Ref_Scope);\n       end if;\n    end Generate_Dereference;"}, {"sha": "2dbf5ff23d20b079a7f7393e7976103ae54a4598", "filename": "gcc/ada/lib-xref.adb", "status": "modified", "additions": 285, "deletions": 177, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Flib-xref.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Flib-xref.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-xref.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -44,6 +44,7 @@ with Stand;    use Stand;\n with Table;    use Table;\n \n with GNAT.Heap_Sort_G;\n+with GNAT.HTable;\n \n package body Lib.Xref is\n \n@@ -56,16 +57,13 @@ package body Lib.Xref is\n \n    subtype Xref_Entry_Number is Int;\n \n-   type Xref_Entry is record\n+   type Xref_Key is record\n+      --  These are the components of Xref_Entry that participate in hash\n+      --  lookups.\n+\n       Ent : Entity_Id;\n       --  Entity referenced (E parameter to Generate_Reference)\n \n-      Def : Source_Ptr;\n-      --  Original source location for entity being referenced. Note that these\n-      --  values are used only during the output process, they are not set when\n-      --  the entries are originally built. This is because private entities\n-      --  can be swapped when the initial call is made.\n-\n       Loc : Source_Ptr;\n       --  Location of reference (Original_Location (Sloc field of N parameter\n       --  to Generate_Reference). Set to No_Location for the case of a\n@@ -89,9 +87,22 @@ package body Lib.Xref is\n       Ent_Scope : Entity_Id;\n       --  Entity of the closest subprogram or package enclosing the definition,\n       --  which should be located in the same file as the definition itself.\n+   end record;\n+\n+   type Xref_Entry is record\n+      Key : Xref_Key;\n \n       Ent_Scope_File : Unit_Number_Type;\n       --  File for entity Ent_Scope\n+\n+      Def : Source_Ptr;\n+      --  Original source location for entity being referenced. Note that these\n+      --  values are used only during the output process, they are not set when\n+      --  the entries are originally built. This is because private entities\n+      --  can be swapped when the initial call is made.\n+\n+      HTable_Next : Xref_Entry_Number;\n+      --  For use only by Static_HTable\n    end record;\n \n    package Xrefs is new Table.Table (\n@@ -102,6 +113,44 @@ package body Lib.Xref is\n      Table_Increment      => Alloc.Xrefs_Increment,\n      Table_Name           => \"Xrefs\");\n \n+   --------------\n+   -- Xref_Set --\n+   --------------\n+\n+   --  We keep a set of xref entries, in order to avoid inserting duplicate\n+   --  entries into the above Xrefs table. An entry is in Xref_Set if and only\n+   --  if it is in Xrefs.\n+\n+   Num_Buckets : constant := 2**16;\n+\n+   subtype Header_Num is Integer range 0 .. Num_Buckets - 1;\n+   type Null_Type is null record;\n+   pragma Unreferenced (Null_Type);\n+\n+   function Hash (F : Xref_Entry_Number) return Header_Num;\n+\n+   function Equal (F1, F2 : Xref_Entry_Number) return Boolean;\n+\n+   procedure HT_Set_Next (E : Xref_Entry_Number; Next : Xref_Entry_Number);\n+\n+   function  HT_Next (E : Xref_Entry_Number) return Xref_Entry_Number;\n+\n+   function Get_Key (E : Xref_Entry_Number) return Xref_Entry_Number;\n+\n+   pragma Inline (Hash, Equal, HT_Set_Next, HT_Next, Get_Key);\n+\n+   package Xref_Set is new GNAT.HTable.Static_HTable (\n+     Header_Num,\n+     Element    => Xref_Entry,\n+     Elmt_Ptr   => Xref_Entry_Number,\n+     Null_Ptr   => 0,\n+     Set_Next   => HT_Set_Next,\n+     Next       => HT_Next,\n+     Key        => Xref_Entry_Number,\n+     Get_Key    => Get_Key,\n+     Hash       => Hash,\n+     Equal      => Equal);\n+\n    ----------------------\n    -- Alfa Information --\n    ----------------------\n@@ -121,14 +170,51 @@ package body Lib.Xref is\n    function Lt (T1, T2 : Xref_Entry) return Boolean;\n    --  Order cross-references\n \n+   procedure Add_Entry (Key : Xref_Key; Ent_Scope_File : Unit_Number_Type);\n+   --  Add an entry to the tables of Xref_Entries, avoiding duplicates\n+\n+   ---------------\n+   -- Add_Entry --\n+   ---------------\n+\n+   procedure Add_Entry (Key : Xref_Key; Ent_Scope_File : Unit_Number_Type) is\n+   begin\n+      Xrefs.Increment_Last; -- tentative\n+      Xrefs.Table (Xrefs.Last).Key := Key;\n+\n+      --  Set the entry in Xref_Set, and if newly set, keep the above\n+      --  tentative increment.\n+\n+      if Xref_Set.Set_If_Not_Present (Xrefs.Last) then\n+         Xrefs.Table (Xrefs.Last).Ent_Scope_File := Ent_Scope_File;\n+         --  Leave Def and HTable_Next uninitialized\n+\n+         Set_Has_Xref_Entry (Key.Ent);\n+\n+      --  It was already in Xref_Set, so throw away the tentatively-added\n+      --  entry\n+\n+      else\n+         Xrefs.Decrement_Last;\n+      end if;\n+   end Add_Entry;\n+\n+   -----------\n+   -- Equal --\n+   -----------\n+\n+   function Equal (F1, F2 : Xref_Entry_Number) return Boolean is\n+      Result : constant Boolean :=\n+        Xrefs.Table (F1).Key = Xrefs.Table (F2).Key;\n+   begin\n+      return Result;\n+   end Equal;\n+\n    -------------------------\n    -- Generate_Definition --\n    -------------------------\n \n    procedure Generate_Definition (E : Entity_Id) is\n-      Loc  : Source_Ptr;\n-      Indx : Nat;\n-\n    begin\n       pragma Assert (Nkind (E) in N_Entity);\n \n@@ -159,22 +245,15 @@ package body Lib.Xref is\n          and then In_Extended_Main_Source_Unit (E)\n          and then not Is_Internal_Name (Chars (E))\n       then\n-         Xrefs.Increment_Last;\n-         Indx := Xrefs.Last;\n-         Loc  := Original_Location (Sloc (E));\n-\n-         Xrefs.Table (Indx).Ent := E;\n-         Xrefs.Table (Indx).Typ := ' ';\n-         Xrefs.Table (Indx).Def := No_Location;\n-         Xrefs.Table (Indx).Loc := No_Location;\n-\n-         Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n-\n-         Xrefs.Table (Indx).Ref_Scope      := Empty;\n-         Xrefs.Table (Indx).Ent_Scope      := Empty;\n-         Xrefs.Table (Indx).Ent_Scope_File := No_Unit;\n-\n-         Set_Has_Xref_Entry (E);\n+         Add_Entry\n+           ((Ent => E,\n+             Loc => No_Location,\n+             Typ => ' ',\n+             Eun => Get_Source_Unit (Original_Location (Sloc (E))),\n+             Lun => No_Unit,\n+             Ref_Scope => Empty,\n+             Ent_Scope => Empty),\n+            Ent_Scope_File => No_Unit);\n \n          if In_Inlined_Body then\n             Set_Referenced (E);\n@@ -294,14 +373,16 @@ package body Lib.Xref is\n       Set_Ref : Boolean   := True;\n       Force   : Boolean   := False)\n    is\n-      Indx : Nat;\n       Nod  : Node_Id;\n       Ref  : Source_Ptr;\n       Def  : Source_Ptr;\n       Ent  : Entity_Id;\n \n-      Ref_Scope     : Entity_Id;\n-      Ent_Scope     : Entity_Id;\n+      Actual_Typ  : Character := Typ;\n+\n+      Ref_Scope      : Entity_Id;\n+      Ent_Scope      : Entity_Id;\n+      Ent_Scope_File : Unit_Number_Type;\n \n       Call   : Node_Id;\n       Formal : Entity_Id;\n@@ -865,34 +946,33 @@ package body Lib.Xref is\n          Ref := Original_Location (Sloc (Nod));\n          Def := Original_Location (Sloc (Ent));\n \n-         Ref_Scope := Alfa.Enclosing_Subprogram_Or_Package (N);\n-         Ent_Scope := Alfa.Enclosing_Subprogram_Or_Package (Ent);\n-\n-         Xrefs.Increment_Last;\n-         Indx := Xrefs.Last;\n-\n-         Xrefs.Table (Indx).Loc := Ref;\n-\n-         --  Overriding operations are marked with 'P'\n-\n-         if Typ = 'p'\n+         if Actual_Typ = 'p'\n            and then Is_Subprogram (N)\n            and then Present (Overridden_Operation (N))\n          then\n-            Xrefs.Table (Indx).Typ := 'P';\n-         else\n-            Xrefs.Table (Indx).Typ := Typ;\n+            Actual_Typ := 'P';\n          end if;\n \n-         Xrefs.Table (Indx).Eun := Get_Source_Unit (Def);\n-         Xrefs.Table (Indx).Lun := Get_Source_Unit (Ref);\n-         Xrefs.Table (Indx).Ent := Ent;\n+         if Alfa_Mode then\n+            Ref_Scope := Alfa.Enclosing_Subprogram_Or_Package (N);\n+            Ent_Scope := Alfa.Enclosing_Subprogram_Or_Package (Ent);\n+            Ent_Scope_File := Get_Source_Unit (Ent_Scope);\n \n-         Xrefs.Table (Indx).Ref_Scope      := Ref_Scope;\n-         Xrefs.Table (Indx).Ent_Scope      := Ent_Scope;\n-         Xrefs.Table (Indx).Ent_Scope_File := Get_Source_Unit (Ent_Scope);\n+         else\n+            Ref_Scope := Empty;\n+            Ent_Scope := Empty;\n+            Ent_Scope_File := No_Unit;\n+         end if;\n \n-         Set_Has_Xref_Entry (Ent);\n+         Add_Entry\n+           ((Ent => Ent,\n+             Loc => Ref,\n+             Typ => Actual_Typ,\n+             Eun => Get_Source_Unit (Def),\n+             Lun => Get_Source_Unit (Ref),\n+             Ref_Scope => Ref_Scope,\n+             Ent_Scope => Ent_Scope),\n+            Ent_Scope_File => Ent_Scope_File);\n       end if;\n    end Generate_Reference;\n \n@@ -957,6 +1037,49 @@ package body Lib.Xref is\n       end loop;\n    end Generate_Reference_To_Generic_Formals;\n \n+   -------------\n+   -- Get_Key --\n+   -------------\n+\n+   function Get_Key (E : Xref_Entry_Number) return Xref_Entry_Number is\n+   begin\n+      return E;\n+   end Get_Key;\n+\n+   ----------\n+   -- Hash --\n+   ----------\n+\n+   function Hash (F : Xref_Entry_Number) return Header_Num is\n+      --  It is unlikely to have two references to the same entity at the same\n+      --  source location, so the hash function depends only on the Ent and Loc\n+      --  fields.\n+\n+      XE : Xref_Entry renames Xrefs.Table (F);\n+      type M is mod 2**32;\n+      H : constant M := M'Mod (XE.Key.Ent) + 2**7 * M'Mod (XE.Key.Loc);\n+   begin\n+      return Header_Num (H mod Num_Buckets);\n+   end Hash;\n+\n+   -----------------\n+   -- HT_Set_Next --\n+   -----------------\n+\n+   procedure HT_Set_Next (E : Xref_Entry_Number; Next : Xref_Entry_Number) is\n+   begin\n+      Xrefs.Table (E).HTable_Next := Next;\n+   end HT_Set_Next;\n+\n+   -------------\n+   -- HT_Next --\n+   -------------\n+\n+   function HT_Next (E : Xref_Entry_Number) return Xref_Entry_Number is\n+   begin\n+      return Xrefs.Table (E).HTable_Next;\n+   end HT_Next;\n+\n    ----------------\n    -- Initialize --\n    ----------------\n@@ -974,8 +1097,8 @@ package body Lib.Xref is\n    begin\n       --  First test: if entity is in different unit, sort by unit\n \n-      if T1.Eun /= T2.Eun then\n-         return Dependency_Num (T1.Eun) < Dependency_Num (T2.Eun);\n+      if T1.Key.Eun /= T2.Key.Eun then\n+         return Dependency_Num (T1.Key.Eun) < Dependency_Num (T2.Key.Eun);\n \n       --  Second test: within same unit, sort by entity Sloc\n \n@@ -984,21 +1107,21 @@ package body Lib.Xref is\n \n       --  Third test: sort definitions ahead of references\n \n-      elsif T1.Loc = No_Location then\n+      elsif T1.Key.Loc = No_Location then\n          return True;\n \n-      elsif T2.Loc = No_Location then\n+      elsif T2.Key.Loc = No_Location then\n          return False;\n \n       --  Fourth test: for same entity, sort by reference location unit\n \n-      elsif T1.Lun /= T2.Lun then\n-         return Dependency_Num (T1.Lun) < Dependency_Num (T2.Lun);\n+      elsif T1.Key.Lun /= T2.Key.Lun then\n+         return Dependency_Num (T1.Key.Lun) < Dependency_Num (T2.Key.Lun);\n \n       --  Fifth test: order of location within referencing unit\n \n-      elsif T1.Loc /= T2.Loc then\n-         return T1.Loc < T2.Loc;\n+      elsif T1.Key.Loc /= T2.Key.Loc then\n+         return T1.Key.Loc < T2.Key.Loc;\n \n       --  Finally, for two locations at the same address, we prefer\n       --  the one that does NOT have the type 'r' so that a modification\n@@ -1008,7 +1131,7 @@ package body Lib.Xref is\n       --  the modify reference.\n \n       else\n-         return T2.Typ = 'r';\n+         return T2.Key.Typ = 'r';\n       end if;\n    end Lt;\n \n@@ -1245,7 +1368,7 @@ package body Lib.Xref is\n \n       begin\n          for J in 1 .. Xrefs.Last loop\n-            Ent := Xrefs.Table (J).Ent;\n+            Ent := Xrefs.Table (J).Key.Ent;\n \n             if Is_Type (Ent)\n               and then Is_Tagged_Type (Ent)\n@@ -1283,9 +1406,7 @@ package body Lib.Xref is\n       Handle_Orphan_Type_References : declare\n          J    : Nat;\n          Tref : Entity_Id;\n-         Indx : Nat;\n          Ent  : Entity_Id;\n-         Loc  : Source_Ptr;\n \n          L, R : Character;\n          pragma Warnings (Off, L);\n@@ -1302,18 +1423,20 @@ package body Lib.Xref is\n \n          procedure New_Entry (E : Entity_Id) is\n          begin\n-            if Present (E)\n-              and then not Has_Xref_Entry (E)\n+            pragma Assert (Present (E));\n+\n+            if not Has_Xref_Entry (Implementation_Base_Type (E))\n               and then Sloc (E) > No_Location\n             then\n-               Xrefs.Increment_Last;\n-               Indx := Xrefs.Last;\n-               Loc  := Original_Location (Sloc (E));\n-               Xrefs.Table (Indx).Ent := E;\n-               Xrefs.Table (Indx).Loc := No_Location;\n-               Xrefs.Table (Indx).Eun := Get_Source_Unit (Loc);\n-               Xrefs.Table (Indx).Lun := No_Unit;\n-               Set_Has_Xref_Entry (E);\n+               Add_Entry\n+                 ((Ent => E,\n+                   Loc => No_Location,\n+                   Typ => Character'First,\n+                   Eun => Get_Source_Unit (Original_Location (Sloc (E))),\n+                   Lun => No_Unit,\n+                   Ref_Scope => Empty,\n+                   Ent_Scope => Empty),\n+                  Ent_Scope_File => No_Unit);\n             end if;\n          end New_Entry;\n \n@@ -1326,7 +1449,7 @@ package body Lib.Xref is\n \n          J := 1;\n          while J <= Xrefs.Last loop\n-            Ent := Xrefs.Table (J).Ent;\n+            Ent := Xrefs.Table (J).Key.Ent;\n             Get_Type_Reference (Ent, Tref, L, R);\n \n             if Present (Tref)\n@@ -1393,15 +1516,15 @@ package body Lib.Xref is\n                      Prim := Parent_Op (Node (Op));\n \n                      if Present (Prim) then\n-                        Xrefs.Increment_Last;\n-                        Indx := Xrefs.Last;\n-                        Loc  := Original_Location (Sloc (Prim));\n-                        Xrefs.Table (Indx).Ent := Prim;\n-                        Xrefs.Table (Indx).Loc := No_Location;\n-                        Xrefs.Table (Indx).Eun :=\n-                          Get_Source_Unit (Sloc (Prim));\n-                        Xrefs.Table (Indx).Lun := No_Unit;\n-                        Set_Has_Xref_Entry (Prim);\n+                        Add_Entry\n+                          ((Ent => Prim,\n+                            Loc => No_Location,\n+                            Typ => Character'First,\n+                            Eun => Get_Source_Unit (Sloc (Prim)),\n+                            Lun => No_Unit,\n+                            Ref_Scope => Empty,\n+                            Ent_Scope => Empty),\n+                           Ent_Scope_File => No_Unit);\n                      end if;\n \n                      Next_Elmt (Op);\n@@ -1418,9 +1541,8 @@ package body Lib.Xref is\n \n       Output_Refs : declare\n \n-         Nrefs : Nat := Xrefs.Last;\n-         --  Number of references in table. This value may get reset (reduced)\n-         --  when we eliminate duplicate reference entries.\n+         Nrefs : constant Nat := Xrefs.Last;\n+         --  Number of references in table\n \n          Rnums : array (0 .. Nrefs) of Nat;\n          --  This array contains numbers of references in the Xrefs table.\n@@ -1523,37 +1645,13 @@ package body Lib.Xref is\n          for J in 1 .. Nrefs loop\n             Rnums (J) := J;\n             Xrefs.Table (J).Def :=\n-              Original_Location (Sloc (Xrefs.Table (J).Ent));\n+              Original_Location (Sloc (Xrefs.Table (J).Key.Ent));\n          end loop;\n \n          --  Sort the references\n \n          Sorting.Sort (Integer (Nrefs));\n \n-         --  Eliminate duplicate entries\n-\n-         declare\n-            NR : constant Nat := Nrefs;\n-\n-         begin\n-            --  We need this test for NR because if we force ALI file\n-            --  generation in case of errors detected, it may be the case\n-            --  that Nrefs is 0, so we should not reset it here\n-\n-            if NR >= 2 then\n-               Nrefs := 1;\n-\n-               for J in 2 .. NR loop\n-                  if Xrefs.Table (Rnums (J)) /=\n-                     Xrefs.Table (Rnums (Nrefs))\n-                  then\n-                     Nrefs := Nrefs + 1;\n-                     Rnums (Nrefs) := Rnums (J);\n-                  end if;\n-               end loop;\n-            end if;\n-         end;\n-\n          --  Initialize loop through references\n \n          Curxu  := No_Unit;\n@@ -1773,7 +1871,7 @@ package body Lib.Xref is\n             --  Start of processing for Output_One_Ref\n \n             begin\n-               Ent := XE.Ent;\n+               Ent := XE.Key.Ent;\n                Ctyp := Xref_Entity_Letters (Ekind (Ent));\n \n                --  Skip reference if it is the only reference to an entity,\n@@ -1782,10 +1880,10 @@ package body Lib.Xref is\n                --  consisting only of packages with END lines, where no\n                --  entity from the package is actually referenced.\n \n-               if XE.Typ = 'e'\n+               if XE.Key.Typ = 'e'\n                  and then Ent /= Curent\n                  and then (Refno = Nrefs or else\n-                             Ent /= Xrefs.Table (Rnums (Refno + 1)).Ent)\n+                             Ent /= Xrefs.Table (Rnums (Refno + 1)).Key.Ent)\n                  and then\n                    not In_Extended_Main_Source_Unit (Ent)\n                then\n@@ -1795,7 +1893,7 @@ package body Lib.Xref is\n                --  For private type, get full view type\n \n                if Ctyp = '+'\n-                 and then Present (Full_View (XE.Ent))\n+                 and then Present (Full_View (XE.Key.Ent))\n                then\n                   Ent := Underlying_Type (Ent);\n \n@@ -1813,15 +1911,15 @@ package body Lib.Xref is\n                --  For variable reference, get corresponding type\n \n                if Ctyp = '*' then\n-                  Ent := Etype (XE.Ent);\n+                  Ent := Etype (XE.Key.Ent);\n                   Ctyp := Fold_Lower (Xref_Entity_Letters (Ekind (Ent)));\n \n                   --  If variable is private type, get full view type\n \n                   if Ctyp = '+'\n-                    and then Present (Full_View (Etype (XE.Ent)))\n+                    and then Present (Full_View (Etype (XE.Key.Ent)))\n                   then\n-                     Ent := Underlying_Type (Etype (XE.Ent));\n+                     Ent := Underlying_Type (Etype (XE.Key.Ent));\n \n                      if Present (Ent) then\n                         Ctyp := Fold_Lower (Xref_Entity_Letters (Ekind (Ent)));\n@@ -1839,13 +1937,13 @@ package body Lib.Xref is\n                   --  Special handling for access parameters and objects of\n                   --  an anonymous access type.\n \n-                  if Ekind_In (Etype (XE.Ent),\n+                  if Ekind_In (Etype (XE.Key.Ent),\n                                E_Anonymous_Access_Type,\n                                E_Anonymous_Access_Subprogram_Type,\n                                E_Anonymous_Access_Protected_Subprogram_Type)\n                   then\n-                     if Is_Formal (XE.Ent)\n-                       or else Ekind_In (XE.Ent, E_Variable, E_Constant)\n+                     if Is_Formal (XE.Key.Ent)\n+                       or else Ekind_In (XE.Key.Ent, E_Variable, E_Constant)\n                      then\n                         Ctyp := 'p';\n                      end if;\n@@ -1859,8 +1957,8 @@ package body Lib.Xref is\n \n                --  Special handling for abstract types and operations\n \n-               if Is_Overloadable (XE.Ent)\n-                 and then Is_Abstract_Subprogram (XE.Ent)\n+               if Is_Overloadable (XE.Key.Ent)\n+                 and then Is_Abstract_Subprogram (XE.Key.Ent)\n                then\n                   if Ctyp = 'U' then\n                      Ctyp := 'x';            --  Abstract procedure\n@@ -1869,10 +1967,10 @@ package body Lib.Xref is\n                      Ctyp := 'y';            --  Abstract function\n                   end if;\n \n-               elsif Is_Type (XE.Ent)\n-                 and then Is_Abstract_Type (XE.Ent)\n+               elsif Is_Type (XE.Key.Ent)\n+                 and then Is_Abstract_Type (XE.Key.Ent)\n                then\n-                  if Is_Interface (XE.Ent) then\n+                  if Is_Interface (XE.Key.Ent) then\n                      Ctyp := 'h';\n \n                   elsif Ctyp = 'R' then\n@@ -1887,41 +1985,42 @@ package body Lib.Xref is\n                --  Suppress references to object definitions, used for local\n                --  references.\n \n-                 or else XE.Typ = 'D'\n-                 or else XE.Typ = 'I'\n+                 or else XE.Key.Typ = 'D'\n+                 or else XE.Key.Typ = 'I'\n \n                --  Suppress self references, except for bodies that act as\n                --  specs.\n \n-                 or else (XE.Loc = XE.Def\n+                 or else (XE.Key.Loc = XE.Def\n                            and then\n-                             (XE.Typ /= 'b'\n-                               or else not Is_Subprogram (XE.Ent)))\n+                             (XE.Key.Typ /= 'b'\n+                               or else not Is_Subprogram (XE.Key.Ent)))\n \n                --  Also suppress definitions of body formals (we only\n                --  treat these as references, and the references were\n                --  separately recorded).\n \n-                 or else (Is_Formal (XE.Ent)\n-                           and then Present (Spec_Entity (XE.Ent)))\n+                 or else (Is_Formal (XE.Key.Ent)\n+                           and then Present (Spec_Entity (XE.Key.Ent)))\n                then\n                   null;\n \n                else\n                   --  Start new Xref section if new xref unit\n \n-                  if XE.Eun /= Curxu then\n+                  if XE.Key.Eun /= Curxu then\n                      if Write_Info_Col > 1 then\n                         Write_Info_EOL;\n                      end if;\n \n-                     Curxu := XE.Eun;\n+                     Curxu := XE.Key.Eun;\n \n                      Write_Info_Initiate ('X');\n                      Write_Info_Char (' ');\n-                     Write_Info_Nat (Dependency_Num (XE.Eun));\n+                     Write_Info_Nat (Dependency_Num (XE.Key.Eun));\n                      Write_Info_Char (' ');\n-                     Write_Info_Name (Reference_Name (Source_Index (XE.Eun)));\n+                     Write_Info_Name\n+                       (Reference_Name (Source_Index (XE.Key.Eun)));\n                   end if;\n \n                   --  Start new Entity line if new entity. Note that we\n@@ -1932,14 +2031,14 @@ package body Lib.Xref is\n \n                   if No (Curent)\n                     or else\n-                      (XE.Ent /= Curent\n+                      (XE.Key.Ent /= Curent\n                          and then\n-                           (Name_Change (XE.Ent) or else XE.Def /= Curdef))\n+                           (Name_Change (XE.Key.Ent) or else XE.Def /= Curdef))\n                   then\n-                     Curent := XE.Ent;\n+                     Curent := XE.Key.Ent;\n                      Curdef := XE.Def;\n \n-                     Get_Unqualified_Name_String (Chars (XE.Ent));\n+                     Get_Unqualified_Name_String (Chars (XE.Key.Ent));\n                      Curlen := Name_Len;\n                      Curnam (1 .. Curlen) := Name_Buffer (1 .. Curlen);\n \n@@ -2051,7 +2150,7 @@ package body Lib.Xref is\n \n                      declare\n                         Ent_Name : constant String :=\n-                                     Exact_Source_Name (Sloc (XE.Ent));\n+                                     Exact_Source_Name (Sloc (XE.Key.Ent));\n                      begin\n                         for C in Ent_Name'Range loop\n                            Write_Info_Char (Ent_Name (C));\n@@ -2060,22 +2159,22 @@ package body Lib.Xref is\n \n                      --  See if we have a renaming reference\n \n-                     if Is_Object (XE.Ent)\n-                       and then Present (Renamed_Object (XE.Ent))\n+                     if Is_Object (XE.Key.Ent)\n+                       and then Present (Renamed_Object (XE.Key.Ent))\n                      then\n-                        Rref := Renamed_Object (XE.Ent);\n+                        Rref := Renamed_Object (XE.Key.Ent);\n \n-                     elsif Is_Overloadable (XE.Ent)\n-                       and then Nkind (Parent (Declaration_Node (XE.Ent))) =\n-                                            N_Subprogram_Renaming_Declaration\n+                     elsif Is_Overloadable (XE.Key.Ent)\n+                       and then Nkind (Parent (Declaration_Node (XE.Key.Ent)))\n+                                           = N_Subprogram_Renaming_Declaration\n                      then\n-                        Rref := Name (Parent (Declaration_Node (XE.Ent)));\n+                        Rref := Name (Parent (Declaration_Node (XE.Key.Ent)));\n \n-                     elsif Ekind (XE.Ent) = E_Package\n-                       and then Nkind (Declaration_Node (XE.Ent)) =\n+                     elsif Ekind (XE.Key.Ent) = E_Package\n+                       and then Nkind (Declaration_Node (XE.Key.Ent)) =\n                                          N_Package_Renaming_Declaration\n                      then\n-                        Rref := Name (Declaration_Node (XE.Ent));\n+                        Rref := Name (Declaration_Node (XE.Key.Ent));\n \n                      else\n                         Rref := Empty;\n@@ -2128,12 +2227,13 @@ package body Lib.Xref is\n                      --  Write out information about generic parent, if entity\n                      --  is an instance.\n \n-                     if  Is_Generic_Instance (XE.Ent) then\n+                     if  Is_Generic_Instance (XE.Key.Ent) then\n                         declare\n                            Gen_Par : constant Entity_Id :=\n                                        Generic_Parent\n                                          (Specification\n-                                            (Unit_Declaration_Node (XE.Ent)));\n+                                            (Unit_Declaration_Node\n+                                               (XE.Key.Ent)));\n                            Loc     : constant Source_Ptr := Sloc (Gen_Par);\n                            Gen_U   : constant Unit_Number_Type :=\n                                        Get_Source_Unit (Loc);\n@@ -2154,15 +2254,16 @@ package body Lib.Xref is\n \n                      --  See if we have a type reference and if so output\n \n-                     Check_Type_Reference (XE.Ent, False);\n+                     Check_Type_Reference (XE.Key.Ent, False);\n \n                      --  Additional information for types with progenitors\n \n-                     if Is_Record_Type (XE.Ent)\n-                       and then Present (Interfaces (XE.Ent))\n+                     if Is_Record_Type (XE.Key.Ent)\n+                       and then Present (Interfaces (XE.Key.Ent))\n                      then\n                         declare\n-                           Elmt : Elmt_Id := First_Elmt (Interfaces (XE.Ent));\n+                           Elmt : Elmt_Id :=\n+                                    First_Elmt (Interfaces (XE.Key.Ent));\n                         begin\n                            while Present (Elmt) loop\n                               Check_Type_Reference (Node (Elmt), True);\n@@ -2173,11 +2274,11 @@ package body Lib.Xref is\n                      --  For array types, list index types as well. (This is\n                      --  not C, indexes have distinct types).\n \n-                     elsif Is_Array_Type (XE.Ent) then\n+                     elsif Is_Array_Type (XE.Key.Ent) then\n                         declare\n                            Indx : Node_Id;\n                         begin\n-                           Indx := First_Index (XE.Ent);\n+                           Indx := First_Index (XE.Key.Ent);\n                            while Present (Indx) loop\n                               Check_Type_Reference\n                                 (First_Subtype (Etype (Indx)), True);\n@@ -2189,10 +2290,11 @@ package body Lib.Xref is\n                      --  If the entity is an overriding operation, write info\n                      --  on operation that was overridden.\n \n-                     if Is_Subprogram (XE.Ent)\n-                       and then Present (Overridden_Operation (XE.Ent))\n+                     if Is_Subprogram (XE.Key.Ent)\n+                       and then Present (Overridden_Operation (XE.Key.Ent))\n                      then\n-                        Output_Overridden_Op (Overridden_Operation (XE.Ent));\n+                        Output_Overridden_Op\n+                          (Overridden_Operation (XE.Key.Ent));\n                      end if;\n \n                      --  End of processing for entity output\n@@ -2204,13 +2306,13 @@ package body Lib.Xref is\n                   --  as the previous one, or it is a read-reference that\n                   --  indicates that the entity is an in-out actual in a call.\n \n-                  if XE.Loc /= No_Location\n+                  if XE.Key.Loc /= No_Location\n                     and then\n-                      (XE.Loc /= Crloc\n-                        or else (Prevt = 'm' and then  XE.Typ = 'r'))\n+                      (XE.Key.Loc /= Crloc\n+                        or else (Prevt = 'm' and then  XE.Key.Typ = 'r'))\n                   then\n-                     Crloc := XE.Loc;\n-                     Prevt := XE.Typ;\n+                     Crloc := XE.Key.Loc;\n+                     Prevt := XE.Key.Typ;\n \n                      --  Start continuation if line full, else blank\n \n@@ -2223,25 +2325,26 @@ package body Lib.Xref is\n \n                      --  Output file number if changed\n \n-                     if XE.Lun /= Curru then\n-                        Curru := XE.Lun;\n+                     if XE.Key.Lun /= Curru then\n+                        Curru := XE.Key.Lun;\n                         Write_Info_Nat (Dependency_Num (Curru));\n                         Write_Info_Char ('|');\n                      end if;\n \n-                     Write_Info_Nat  (Int (Get_Logical_Line_Number (XE.Loc)));\n-                     Write_Info_Char (XE.Typ);\n+                     Write_Info_Nat\n+                       (Int (Get_Logical_Line_Number (XE.Key.Loc)));\n+                     Write_Info_Char (XE.Key.Typ);\n \n-                     if Is_Overloadable (XE.Ent)\n-                       and then Is_Imported (XE.Ent)\n-                       and then XE.Typ = 'b'\n+                     if Is_Overloadable (XE.Key.Ent)\n+                       and then Is_Imported (XE.Key.Ent)\n+                       and then XE.Key.Typ = 'b'\n                      then\n-                        Output_Import_Export_Info (XE.Ent);\n+                        Output_Import_Export_Info (XE.Key.Ent);\n                      end if;\n \n-                     Write_Info_Nat (Int (Get_Column_Number (XE.Loc)));\n+                     Write_Info_Nat (Int (Get_Column_Number (XE.Key.Loc)));\n \n-                     Output_Instantiation_Refs (Sloc (XE.Ent));\n+                     Output_Instantiation_Refs (Sloc (XE.Key.Ent));\n                   end if;\n                end if;\n             end Output_One_Ref;\n@@ -2254,4 +2357,9 @@ package body Lib.Xref is\n       end Output_Refs;\n    end Output_References;\n \n+begin\n+   --  Reset is necessary because Elmt_Ptr does not default to Null_Ptr,\n+   --  because it's not an access type.\n+\n+   Xref_Set.Reset;\n end Lib.Xref;"}, {"sha": "68a4ac30d0413a58161ee27ad80106b234a3d953", "filename": "gcc/ada/s-htable.adb", "status": "modified", "additions": 36, "deletions": 1, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fs-htable.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fs-htable.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                    Copyright (C) 1995-2010, AdaCore                      --\n+--                    Copyright (C) 1995-2011, AdaCore                      --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -121,6 +121,15 @@ package body System.HTable is\n          return Iterator_Ptr;\n       end Get_Non_Null;\n \n+      -------------\n+      -- Present --\n+      -------------\n+\n+      function Present (K : Key) return Boolean is\n+      begin\n+         return Get (K) /= Null_Ptr;\n+      end Present;\n+\n       ------------\n       -- Remove --\n       ------------\n@@ -181,6 +190,32 @@ package body System.HTable is\n          Table (Index) := E;\n       end Set;\n \n+      ------------------------\n+      -- Set_If_Not_Present --\n+      ------------------------\n+\n+      function Set_If_Not_Present (E : Elmt_Ptr) return Boolean is\n+         K     : constant Key := Get_Key (E);\n+         Index : constant Header_Num := Hash (K);\n+         Elmt  : Elmt_Ptr := Table (Index);\n+\n+      begin\n+         loop\n+            if Elmt = Null_Ptr then\n+               Set_Next (E, Table (Index));\n+               Table (Index) := E;\n+\n+               return True;\n+\n+            elsif Equal (Get_Key (Elmt), K) then\n+               return False;\n+\n+            else\n+               Elmt := Next (Elmt);\n+            end if;\n+         end loop;\n+      end Set_If_Not_Present;\n+\n    end Static_HTable;\n \n    -------------------"}, {"sha": "29fb5fbd16355c4a57dd6732c47b702a0a895f94", "filename": "gcc/ada/s-htable.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fs-htable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fs-htable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-htable.ads?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---                     Copyright (C) 1995-2010, AdaCore                     --\n+--                     Copyright (C) 1995-2011, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -183,6 +183,14 @@ package System.HTable is\n       --  Returns the latest inserted element pointer with the given Key\n       --  or null if none.\n \n+      function Present (K : Key) return Boolean;\n+      --  True if an element whose Get_Key is K is in the table\n+\n+      function Set_If_Not_Present (E : Elmt_Ptr) return Boolean;\n+      --  If Present (Get_Key (E)), returns False. Otherwise, does Set (E), and\n+      --  then returns True. Present (Get_Key (E)) is always True afterward,\n+      --  and the result True indicates E is newly Set.\n+\n       procedure Remove (K : Key);\n       --  Removes the latest inserted element pointer associated with the\n       --  given key if any, does nothing if none."}, {"sha": "3f049643287ba4d1b61c0ac824040e13485783bf", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7bb41af65aa53933814ec82474497876d396b33/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=f7bb41af65aa53933814ec82474497876d396b33", "patch": "@@ -490,8 +490,14 @@ package body Sem_Ch4 is\n \n          Resolve (Expression (E), Type_Id);\n \n+         --  Allocators generated by the build-in-place expansion mechanism\n+         --  are explicitly marked as coming from source but do not need to be\n+         --  checked for limited initialization. To exclude this case, ensure\n+         --  that the parent of the allocator is a source node.\n+\n          if Is_Limited_Type (Type_Id)\n            and then Comes_From_Source (N)\n+           and then Comes_From_Source (Parent (N))\n            and then not In_Instance_Body\n          then\n             if not OK_For_Limited_Init (Type_Id, Expression (E)) then"}]}