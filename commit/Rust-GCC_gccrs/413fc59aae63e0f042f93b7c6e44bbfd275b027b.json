{"sha": "413fc59aae63e0f042f93b7c6e44bbfd275b027b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEzZmM1OWFhZTYzZTBmMDQyZjkzYjdjNmU0NGJiZmQyNzViMDI3Yg==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2006-10-10T22:18:06Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2006-10-10T22:18:06Z"}, "message": "re PR target/26504 (compute_frame_pointer_to_cfa_displacement error for avr target with --with-dwarf2)\n\n\t* config/avr/predicates.md: New file.\n\t* config/avr/avr.md: Include it.\n\t(REG_SP): New constant.\n\t(peepholes): Use predicates.\n\t(sbrx_branch, sbrx_and_branchhi, sbrx_and_branchsi, branch, rvbranch,\n\tdifficult_branch,  difficult_rvbranch, cbi, sbi, sbix_branch,\n\tsbix_branch_bit7, sbix_branch_tmp, sbix_branch_tmp_bit7): Ditto.\n\tPR target/26504\n\t* config/avr/avr.h (FRAME_POINTER_CFA_OFFSET): Define.\n\nFrom-SVN: r117616", "tree": {"sha": "6c72ee86ee98ab6eb09f21fbf65c51e594d19b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6c72ee86ee98ab6eb09f21fbf65c51e594d19b6a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/413fc59aae63e0f042f93b7c6e44bbfd275b027b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/413fc59aae63e0f042f93b7c6e44bbfd275b027b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/413fc59aae63e0f042f93b7c6e44bbfd275b027b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/413fc59aae63e0f042f93b7c6e44bbfd275b027b/comments", "author": null, "committer": null, "parents": [{"sha": "05ee9ca08fa14577c842dbf0bece1b0d4e56eb00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05ee9ca08fa14577c842dbf0bece1b0d4e56eb00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05ee9ca08fa14577c842dbf0bece1b0d4e56eb00"}], "stats": {"total": 220, "additions": 153, "deletions": 67}, "files": [{"sha": "564b7fbd88d22a43c1a84b0afdd0e488b904fc08", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=413fc59aae63e0f042f93b7c6e44bbfd275b027b", "patch": "@@ -1,3 +1,13 @@\n+2006-10-10  Anatoly Sokolov <aesok@post.ru>\n+\n+\t* config/avr/predicates.md: New file.\n+\t* config/avr/avr.md: Include it.\n+\t(REG_SP): New constant.\n+\t(peepholes): Use predicates.\n+\t(sbrx_branch, sbrx_and_branchhi, sbrx_and_branchsi, branch, rvbranch,\n+\tdifficult_branch,  difficult_rvbranch, cbi, sbi, sbix_branch,\n+\tsbix_branch_bit7, sbix_branch_tmp, sbix_branch_tmp_bit7): Ditto.\n+\n 2006-10-10  Adam Nemet  <anemet@caviumnetworks.com>\n \n \t* config/mips/mips.c (mips_save_restore_reg): Use gen_frame_mem to"}, {"sha": "0f3051e77a4b3b9b39c66f65f71ec7a166af825c", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 58, "deletions": 67, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=413fc59aae63e0f042f93b7c6e44bbfd275b027b", "patch": "@@ -43,11 +43,13 @@\n    (REG_Y\t28)\n    (REG_Z\t30)\n    (REG_W\t24)\n+   (REG_SP\t32)\n    (TMP_REGNO\t0)\t; temporary register r0\n    (ZERO_REGNO\t1)\t; zero register r1\n    (UNSPEC_STRLEN\t0)\n    (UNSPEC_INDEX_JMP\t1)])\n \n+(include \"predicates.md\")\n (include \"constraints.md\")\n   \n ;; Condition code settings.\n@@ -223,10 +225,11 @@\n \n (define_peephole2\n   [(match_scratch:QI 2 \"d\")\n-   (set (match_operand:QI 0 \"register_operand\" \"\")\n+   (set (match_operand:QI 0 \"l_register_operand\" \"\")\n \t(match_operand:QI 1 \"immediate_operand\" \"\"))]\n   \"(operands[1] != const0_rtx\n-    && test_hard_reg_class (NO_LD_REGS, operands[0]))\"\n+    && operands[1] != const1_rtx\n+    && operands[1] != constm1_rtx)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (clobber (match_dup 2))])]\n   \"if (!avr_peep2_scratch_safe (operands[2]))\n@@ -252,10 +255,10 @@\n \n (define_peephole2\n   [(match_scratch:QI 2 \"d\")\n-   (set (match_operand:HI 0 \"register_operand\" \"\")\n-       (match_operand:HI 1 \"immediate_operand\" \"\"))]\n-  \"(operands[1] != const0_rtx\n-    && test_hard_reg_class (NO_LD_REGS, operands[0]))\"\n+   (set (match_operand:HI 0 \"l_register_operand\" \"\")\n+        (match_operand:HI 1 \"immediate_operand\" \"\"))]\n+  \"(operands[1] != const0_rtx \n+    && operands[1] != constm1_rtx)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (clobber (match_dup 2))])]\n   \"if (!avr_peep2_scratch_safe (operands[2]))\n@@ -301,10 +304,10 @@\n \n (define_peephole2\n   [(match_scratch:QI 2 \"d\")\n-   (set (match_operand:SI 0 \"register_operand\" \"\")\n-       (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+   (set (match_operand:SI 0 \"l_register_operand\" \"\")\n+        (match_operand:SI 1 \"immediate_operand\" \"\"))]\n   \"(operands[1] != const0_rtx\n-    && test_hard_reg_class (NO_LD_REGS, operands[0]))\"\n+    && operands[1] != constm1_rtx)\"\n   [(parallel [(set (match_dup 0) (match_dup 1))\n \t      (clobber (match_dup 2))])]\n   \"if (!avr_peep2_scratch_safe (operands[2]))\n@@ -1854,15 +1857,15 @@\n (define_insn \"*sbrx_branch\"\n   [(set (pc)\n         (if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"eqne_operator\"\n \t\t\t [(zero_extract\n \t\t\t   (match_operand:QI 1 \"register_operand\" \"r\")\n \t\t\t   (const_int 1)\n \t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE\"\n+  \"\"\n   \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n@@ -1876,15 +1879,14 @@\n (define_insn \"*sbrx_and_branchhi\"\n   [(set (pc)\n         (if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"eqne_operator\"\n \t\t\t [(and:HI\n \t\t\t   (match_operand:HI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:HI 2 \"const_int_operand\" \"n\"))\n+\t\t\t   (match_operand:HI 2 \"single_one_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && exact_log2 (INTVAL (operands[2]) & 0xffff) >= 0\"\n+  \"\"\n   \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n@@ -1898,15 +1900,14 @@\n (define_insn \"*sbrx_and_branchsi\"\n   [(set (pc)\n         (if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"eqne_operator\"\n \t\t\t [(and:SI\n \t\t\t   (match_operand:SI 1 \"register_operand\" \"r\")\n-\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t\t\t   (match_operand:SI 2 \"single_one_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && exact_log2 (INTVAL (operands[2]) & 0xffffffff) >= 0\"\n+  \"\"\n   \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n@@ -2001,27 +2002,25 @@\n \n (define_insn \"branch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"comparison_operator\"\n+        (if_then_else (match_operator 1 \"simple_comparison_operator\"\n                         [(cc0)\n                          (const_int 0)])\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n-  \"! (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n-      || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"\"\n   \"*\n    return ret_cond_branch (operands[1], avr_jump_mode (operands[0],insn), 0);\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"difficult_branch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"comparison_operator\"\n+        (if_then_else (match_operator 1 \"difficult_comparison_operator\"\n                         [(cc0)\n                          (const_int 0)])\n                       (label_ref (match_operand 0 \"\" \"\"))\n                       (pc)))]\n-  \"(GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n-    || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"\"\n   \"*\n    return ret_cond_branch (operands[1], avr_jump_mode (operands[0],insn), 0);\"\n   [(set_attr \"type\" \"branch1\")\n@@ -2031,25 +2030,25 @@\n \n (define_insn \"rvbranch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"comparison_operator\" [(cc0)\n-                                                               (const_int 0)])\n+        (if_then_else (match_operator 1 \"simple_comparison_operator\" \n+\t                [(cc0)\n+                         (const_int 0)])\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"! (GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n-      || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"\"\n   \"*\n    return ret_cond_branch (operands[1], avr_jump_mode (operands[0], insn), 1);\"\n   [(set_attr \"type\" \"branch1\")\n    (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"difficult_rvbranch\"\n   [(set (pc)\n-        (if_then_else (match_operator 1 \"comparison_operator\" [(cc0)\n-                                                               (const_int 0)])\n+        (if_then_else (match_operator 1 \"difficult_comparison_operator\" \n+\t                [(cc0)\n+                         (const_int 0)])\n                       (pc)\n                       (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"(GET_CODE (operands[1]) == GT || GET_CODE (operands[1]) == GTU\n-    || GET_CODE (operands[1]) == LE || GET_CODE (operands[1]) == LEU)\"\n+  \"\"\n   \"*\n    return ret_cond_branch (operands[1], avr_jump_mode (operands[0], insn), 1);\"\n   [(set_attr \"type\" \"branch\")\n@@ -2289,11 +2288,10 @@\n ;; Clear/set/test a single bit in I/O address space.\n \n (define_insn \"*cbi\"\n-  [(set (mem:QI (match_operand 0 \"const_int_operand\" \"n\"))\n+  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n \t(and:QI (mem:QI (match_dup 0))\n-\t\t(match_operand 1 \"const_int_operand\" \"n\")))]\n-  \"avr_io_address_p (operands[0], 1 + 0x20)\n-   && exact_log2 (~INTVAL (operands[1]) & 0xff) >= 0\"\n+\t\t(match_operand:QI 1 \"single_zero_operand\" \"n\")))]\n+  \"(optimize > 0)\"\n {\n   operands[2] = GEN_INT (exact_log2 (~INTVAL (operands[1]) & 0xff));\n   return AS2 (cbi,%0-0x20,%2);\n@@ -2302,11 +2300,10 @@\n    (set_attr \"cc\" \"none\")])\n \n (define_insn \"*sbi\"\n-  [(set (mem:QI (match_operand 0 \"const_int_operand\" \"n\"))\n+  [(set (mem:QI (match_operand 0 \"low_io_address_operand\" \"n\"))\n \t(ior:QI (mem:QI (match_dup 0))\n-\t\t(match_operand 1 \"const_int_operand\" \"n\")))]\n-  \"avr_io_address_p (operands[0], 1 + 0x20)\n-   && exact_log2 (INTVAL (operands[1]) & 0xff) >= 0\"\n+\t\t(match_operand:QI 1 \"single_one_operand\" \"n\")))]\n+  \"(optimize > 0)\"\n {\n   operands[2] = GEN_INT (exact_log2 (INTVAL (operands[1]) & 0xff));\n   return AS2 (sbi,%0-0x20,%2);\n@@ -2318,16 +2315,15 @@\n (define_insn \"*sbix_branch\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"eqne_operator\"\n \t\t\t [(zero_extract\n-\t\t\t   (mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t\t   (mem:QI (match_operand 1 \"low_io_address_operand\" \"n\"))\n \t\t\t   (const_int 1)\n \t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && avr_io_address_p (operands[1], 1 + 0x20)\"\n+  \"(optimize > 0)\"\n   \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n@@ -2342,13 +2338,12 @@\n (define_insn \"*sbix_branch_bit7\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t (match_operator 0 \"gelt_operator\"\n+\t\t\t [(mem:QI (match_operand 1 \"low_io_address_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == GE || GET_CODE (operands[0]) == LT)\n-   && avr_io_address_p (operands[1], 1 + 0x20)\"\n+  \"(optimize > 0)\"\n {\n   operands[3] = operands[2];\n   operands[2] = GEN_INT (7);\n@@ -2367,16 +2362,15 @@\n (define_insn \"*sbix_branch_tmp\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n+\t (match_operator 0 \"eqne_operator\"\n \t\t\t [(zero_extract\n-\t\t\t   (mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t\t\t   (mem:QI (match_operand 1 \"higth_io_address_operand\" \"n\"))\n \t\t\t   (const_int 1)\n \t\t\t   (match_operand 2 \"const_int_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 3 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == EQ || GET_CODE (operands[0]) == NE)\n-   && avr_io_address_p (operands[1], 1) && INTVAL (operands[1]) >= 0x40\"\n+  \"(optimize > 0)\"\n   \"* return avr_out_sbxx_branch (insn, operands);\"\n   [(set (attr \"length\")\n \t(if_then_else (and (ge (minus (pc) (match_dup 3)) (const_int -2046))\n@@ -2390,13 +2384,12 @@\n (define_insn \"*sbix_branch_tmp_bit7\"\n   [(set (pc)\n \t(if_then_else\n-\t (match_operator 0 \"comparison_operator\"\n-\t\t\t [(mem:QI (match_operand 1 \"const_int_operand\" \"n\"))\n+\t (match_operator 0 \"gelt_operator\"\n+\t\t\t [(mem:QI (match_operand 1 \"higth_io_address_operand\" \"n\"))\n \t\t\t  (const_int 0)])\n \t (label_ref (match_operand 2 \"\" \"\"))\n \t (pc)))]\n-  \"(GET_CODE (operands[0]) == GE || GET_CODE (operands[0]) == LT)\n-   && avr_io_address_p (operands[1], 1) && INTVAL (operands[1]) >= 0x40\"\n+  \"(optimize > 0)\"\n {\n   operands[3] = operands[2];\n   operands[2] = GEN_INT (7);\n@@ -2414,20 +2407,19 @@\n ;; ************************* Peepholes ********************************\n \n (define_peephole\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+  [(set (match_operand:SI 0 \"d_register_operand\" \"\")\n         (plus:SI (match_dup 0)\n                  (const_int -1)))\n    (parallel\n     [(set (cc0)\n           (compare (match_dup 0)\n \t\t   (const_int -1)))\n-     (clobber (match_operand:QI 1 \"register_operand\" \"\"))])\n+     (clobber (match_operand:QI 1 \"d_register_operand\" \"\"))])\n    (set (pc)\n \t(if_then_else (ne (cc0) (const_int 0))\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(test_hard_reg_class (LD_REGS, operands[0])\n-    && test_hard_reg_class (LD_REGS, operands[1]))\"\n+  \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2453,20 +2445,19 @@\n }\")\n \n (define_peephole\n-  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+  [(set (match_operand:HI 0 \"d_register_operand\" \"\")\n         (plus:HI (match_dup 0)\n                  (const_int -1)))\n    (parallel\n     [(set (cc0)\n           (compare (match_dup 0)\n \t\t   (const_int 65535)))\n-     (clobber (match_operand:QI 1 \"register_operand\" \"\"))])\n+     (clobber (match_operand:QI 1 \"d_register_operand\" \"\"))])\n    (set (pc)\n \t(if_then_else (ne (cc0) (const_int 0))\n \t\t      (label_ref (match_operand 2 \"\" \"\"))\n \t\t      (pc)))]\n-  \"(test_hard_reg_class (LD_REGS, operands[0])\n-    && test_hard_reg_class (LD_REGS, operands[1]))\"\n+  \"\"\n   \"*\n {\n   CC_STATUS_INIT;\n@@ -2488,7 +2479,7 @@\n }\")\n \n (define_peephole\n-  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+  [(set (match_operand:QI 0 \"d_register_operand\" \"\")\n         (plus:QI (match_dup 0)\n                  (const_int -1)))\n    (set (cc0)\n@@ -2498,7 +2489,7 @@\n \t(if_then_else (ne (cc0) (const_int 0))\n \t\t      (label_ref (match_operand 1 \"\" \"\"))\n \t\t      (pc)))]\n-  \"test_hard_reg_class (LD_REGS, operands[0])\"\n+  \"\"\n   \"*\n {\n   CC_STATUS_INIT;"}, {"sha": "9b9f8dafe8538349733194a2e28042e1df3d8037", "filename": "gcc/config/avr/predicates.md", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/413fc59aae63e0f042f93b7c6e44bbfd275b027b/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=413fc59aae63e0f042f93b7c6e44bbfd275b027b", "patch": "@@ -0,0 +1,85 @@\n+;; Predicate definitions for ATMEL AVR micro controllers.\n+;; Copyright (C) 2006 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; Registers from r0 to r15.\n+(define_predicate \"l_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) <= 15\")))\n+\n+;; Registers from r16 to r31.\n+(define_predicate \"d_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) >= 16 && REGNO (op) <= 31\")))\n+\n+;; SP register.\n+(define_predicate \"stack_register_operand\"\n+  (and (match_code \"reg\")\n+       (match_test \"REGNO (op) == REG_SP\")))\n+\n+;; Return true if OP is a valid address for an I/O register.\n+(define_predicate \"io_address_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0x20 \n+                    && INTVAL (op) <= 0x60 - GET_MODE_SIZE (mode)\")))\n+\n+;; Return true if OP is a valid address for lower half of I/O space.\n+(define_predicate \"low_io_address_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0x20 \n+                    && INTVAL (op) <= 0x40 - GET_MODE_SIZE (mode)\")))\n+       \n+;; Return true if OP is a valid address for higth half of I/O space.\n+(define_predicate \"higth_io_address_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"INTVAL (op) >= 0x40 \n+                    && INTVAL (op) <= 0x60 - GET_MODE_SIZE (mode)\")))\n+       \n+;; Returns 1 if OP is a SYMBOL_REF.\n+(define_predicate \"symbol_ref_operand\"\n+  (match_code \"symbol_ref\"))\n+\n+;; Return true if OP is a constant that contains only one 1 in its\n+;; binary representation.\n+(define_predicate \"single_one_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2(INTVAL (op) & GET_MODE_MASK (mode)) >= 0\")))\n+\n+;; Return true if OP is a constant that contains only one 0 in its\n+;; binary representation.\n+(define_predicate \"single_zero_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"exact_log2(~INTVAL (op) & GET_MODE_MASK (mode)) >= 0\")))\n+      \n+;; True for EQ & NE\n+(define_predicate \"eqne_operator\"\n+  (match_code \"eq,ne\"))\n+       \n+;; True for GE & LT\n+(define_predicate \"gelt_operator\"\n+  (match_code \"ge,lt\"))\n+       \n+;; True for GT, GTU, LE & LEU\n+(define_predicate \"difficult_comparison_operator\"\n+  (match_code \"gt,gtu,le,leu\"))\n+\n+;; False for GT, GTU, LE & LEU\n+(define_predicate \"simple_comparison_operator\"\n+  (and (match_operand 0 \"comparison_operator\")\n+       (not (match_code \"gt,gtu,le,leu\"))))"}]}