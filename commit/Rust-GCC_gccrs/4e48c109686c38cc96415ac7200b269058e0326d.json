{"sha": "4e48c109686c38cc96415ac7200b269058e0326d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU0OGMxMDk2ODZjMzhjYzk2NDE1YWM3MjAwYjI2OTA1OGUwMzI2ZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-08-07T20:13:52Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-08-07T20:13:52Z"}, "message": "future (_State_baseV2::_M_set_result): Pass pointers to _M_do_set.\n\n\t* include/std/future (_State_baseV2::_M_set_result): Pass pointers to\n\t_M_do_set.\n\t(_State_baseV2::_M_do_set): Change parameters to pointers.\n\t(_State_baseV2::_Setter): Change _M_arg from reference to pointer.\n\t(_State_baseV2::__setter): Initialize _Setter with pointers.\n\t(_State_baseV2::__setter(promise<void>*)): Remove overload.\n\t(promise::set_value, promise::set_exception): Pass setter directly\n\tto _M_set_result.\n\t(_State_baseV2::_Task_setter): Add template parameter for callable\n\ttype and replace std::function member with pointer to that type.\n\tChange _M_result member from reference to pointer.\n\t(_State_baseV2::_S_task_setter): Change parameter to lvalue reference\n\tand initialize _Task_setter with pointers.\n\t(__location_invariant): Specialize for _Setter and _Task_setter.\n\nFrom-SVN: r213737", "tree": {"sha": "ae33b523c844eedaec0bce42c4bbdd0aa7df280d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ae33b523c844eedaec0bce42c4bbdd0aa7df280d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e48c109686c38cc96415ac7200b269058e0326d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e48c109686c38cc96415ac7200b269058e0326d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e48c109686c38cc96415ac7200b269058e0326d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e48c109686c38cc96415ac7200b269058e0326d/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2d45625fa77114876f0069ceb12c105721b38331", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d45625fa77114876f0069ceb12c105721b38331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d45625fa77114876f0069ceb12c105721b38331"}], "stats": {"total": 137, "additions": 66, "deletions": 71}, "files": [{"sha": "00a76a82a6820a61bcc5700c9d97879f1adfa318", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48c109686c38cc96415ac7200b269058e0326d/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48c109686c38cc96415ac7200b269058e0326d/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4e48c109686c38cc96415ac7200b269058e0326d", "patch": "@@ -11,6 +11,21 @@\n \t* testsuite/23_containers/list/requirements/dr438/insert_neg.cc:\n \tLikewise.\n \n+\t* include/std/future (_State_baseV2::_M_set_result): Pass pointers to\n+\t_M_do_set.\n+\t(_State_baseV2::_M_do_set): Change parameters to pointers.\n+\t(_State_baseV2::_Setter): Change _M_arg from reference to pointer.\n+\t(_State_baseV2::__setter): Initialize _Setter with pointers.\n+\t(_State_baseV2::__setter(promise<void>*)): Remove overload.\n+\t(promise::set_value, promise::set_exception): Pass setter directly\n+\tto _M_set_result.\n+\t(_State_baseV2::_Task_setter): Add template parameter for callable\n+\ttype and replace std::function member with pointer to that type.\n+\tChange _M_result member from reference to pointer.\n+\t(_State_baseV2::_S_task_setter): Change parameter to lvalue reference\n+\tand initialize _Task_setter with pointers.\n+\t(__location_invariant): Specialize for _Setter and _Task_setter.\n+\n 2014-08-02  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/15339"}, {"sha": "c3aaaec22d9bcb899d9bf8584ba9399fd562618a", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 51, "deletions": 71, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e48c109686c38cc96415ac7200b269058e0326d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e48c109686c38cc96415ac7200b269058e0326d/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=4e48c109686c38cc96415ac7200b269058e0326d", "patch": "@@ -358,7 +358,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         // all calls to this function are serialized,\n         // side-effects of invoking __res only happen once\n \tcall_once(_M_once, &_State_baseV2::_M_do_set, this,\n-\t\t  ref(__res), ref(__lock));\n+\t\t  std::__addressof(__res), std::__addressof(__lock));\n \tif (__lock.owns_lock())\n \t  _M_cond.notify_all();\n \telse if (!__ignore_failure)\n@@ -396,19 +396,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         struct _Setter<_Res, _Arg&>\n         {\n           // check this is only used by promise<R>::set_value(const R&)\n-          // or promise<R>::set_value(R&)\n+          // or promise<R&>::set_value(R&)\n           static_assert(is_same<_Res, _Arg&>::value  // promise<R&>\n-              || is_same<const _Res, _Arg>::value,  // promise<R>\n+              || is_same<const _Res, _Arg>::value,   // promise<R>\n               \"Invalid specialisation\");\n \n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n-            _M_promise->_M_storage->_M_set(_M_arg);\n+            _M_promise->_M_storage->_M_set(*_M_arg);\n             return std::move(_M_promise->_M_storage);\n           }\n           promise<_Res>*    _M_promise;\n-          _Arg&             _M_arg;\n+          _Arg*             _M_arg;\n         };\n \n       // set rvalues\n@@ -418,11 +418,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n-            _M_promise->_M_storage->_M_set(std::move(_M_arg));\n+            _M_promise->_M_storage->_M_set(std::move(*_M_arg));\n             return std::move(_M_promise->_M_storage);\n           }\n           promise<_Res>*    _M_promise;\n-          _Res&             _M_arg;\n+          _Res*             _M_arg;\n         };\n \n       struct __exception_ptr_tag { };\n@@ -434,31 +434,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n           typename promise<_Res>::_Ptr_type operator()()\n           {\n             _State_baseV2::_S_check(_M_promise->_M_future);\n-            _M_promise->_M_storage->_M_error = _M_ex;\n+            _M_promise->_M_storage->_M_error = *_M_ex;\n             return std::move(_M_promise->_M_storage);\n           }\n \n           promise<_Res>*   _M_promise;\n-          exception_ptr&    _M_ex;\n+          exception_ptr*    _M_ex;\n         };\n \n       template<typename _Res, typename _Arg>\n         static _Setter<_Res, _Arg&&>\n         __setter(promise<_Res>* __prom, _Arg&& __arg)\n         {\n-          return _Setter<_Res, _Arg&&>{ __prom, __arg };\n+          return _Setter<_Res, _Arg&&>{ __prom, &__arg };\n         }\n \n       template<typename _Res>\n         static _Setter<_Res, __exception_ptr_tag>\n         __setter(exception_ptr& __ex, promise<_Res>* __prom)\n         {\n-          return _Setter<_Res, __exception_ptr_tag>{ __prom, __ex };\n+          return _Setter<_Res, __exception_ptr_tag>{ __prom, &__ex };\n         }\n \n-      static _Setter<void, void>\n-      __setter(promise<void>* __prom);\n-\n       template<typename _Tp>\n         static void\n         _S_check(const shared_ptr<_Tp>& __p)\n@@ -469,10 +466,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     private:\n       void\n-      _M_do_set(function<_Ptr_type()>& __f, unique_lock<mutex>& __lock)\n+      _M_do_set(function<_Ptr_type()>* __f, unique_lock<mutex>* __lock)\n       {\n-        _Ptr_type __res = __f(); // do not hold lock while running setter\n-\t__lock.lock();\n+        _Ptr_type __res = (*__f)(); // do not hold lock while running setter\n+\t__lock->lock();\n         _M_result.swap(__res);\n       }\n \n@@ -514,15 +511,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       static std::shared_ptr<_State_base>\n       _S_make_async_state(_BoundFn&& __fn);\n \n-    template<typename _Res_ptr,\n+    template<typename _Res_ptr, typename _Fn,\n \t     typename _Res = typename _Res_ptr::element_type::result_type>\n       struct _Task_setter;\n \n     template<typename _Res_ptr, typename _BoundFn>\n-      static _Task_setter<_Res_ptr>\n-      _S_task_setter(_Res_ptr& __ptr, _BoundFn&& __call)\n+      static _Task_setter<_Res_ptr, _BoundFn>\n+      _S_task_setter(_Res_ptr& __ptr, _BoundFn& __call)\n       {\n-\treturn _Task_setter<_Res_ptr>{ __ptr, std::ref(__call) };\n+\treturn { std::__addressof(__ptr), std::__addressof(__call) };\n       }\n   };\n \n@@ -554,6 +551,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void _M_destroy() { delete this; }\n     };\n \n+  // Allow _Setter objects to be stored locally in std::function\n+  template<typename _Res, typename _Arg>\n+    struct __is_location_invariant\n+    <__future_base::_State_base::_Setter<_Res, _Arg>>\n+    : true_type { };\n+\n+  // Allow _Task_setter objects to be stored locally in std::function\n+  template<typename _Res_ptr, typename _Fn, typename _Res>\n+    struct __is_location_invariant\n+    <__future_base::_Task_setter<_Res_ptr, _Fn, _Res>>\n+    : true_type { };\n+\n #ifndef _GLIBCXX_ASYNC_ABI_COMPAT\n \n   /// Common implementation for future and shared_future.\n@@ -994,24 +1003,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Setting the result\n       void\n       set_value(const _Res& __r)\n-      {\n-        auto __setter = _State::__setter(this, __r);\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(this, __r)); }\n \n       void\n       set_value(_Res&& __r)\n-      {\n-        auto __setter = _State::__setter(this, std::move(__r));\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(this, std::move(__r))); }\n \n       void\n       set_exception(exception_ptr __p)\n-      {\n-        auto __setter = _State::__setter(__p, this);\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(__p, this)); }\n     };\n \n   template<typename _Res>\n@@ -1092,17 +1092,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Setting the result\n       void\n       set_value(_Res& __r)\n-      {\n-        auto __setter = _State::__setter(this, __r);\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(this, __r)); }\n \n       void\n       set_exception(exception_ptr __p)\n-      {\n-        auto __setter = _State::__setter(__p, this);\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(__p, this)); }\n     };\n \n   /// Explicit specialization for promise<void>\n@@ -1177,10 +1171,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       void\n       set_exception(exception_ptr __p)\n-      {\n-        auto __setter = _State::__setter(__p, this);\n-        _M_future->_M_set_result(std::move(__setter));\n-      }\n+      { _M_future->_M_set_result(_State::__setter(__p, this)); }\n     };\n \n   // set void\n@@ -1196,64 +1187,54 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       promise<void>*    _M_promise;\n     };\n \n-  inline __future_base::_State_base::_Setter<void, void>\n-  __future_base::_State_base::__setter(promise<void>* __prom)\n-  {\n-    return _Setter<void, void>{ __prom };\n-  }\n-\n   inline void\n   promise<void>::set_value()\n-  {\n-    auto __setter = _State::__setter(this);\n-    _M_future->_M_set_result(std::move(__setter));\n-  }\n-\n+  { _M_future->_M_set_result(_State::_Setter<void, void>{ this }); }\n \n-  template<typename _Ptr_type, typename _Res>\n+  template<typename _Ptr_type, typename _Fn, typename _Res>\n     struct __future_base::_Task_setter\n     {\n       _Ptr_type operator()()\n       {\n \t__try\n \t  {\n-\t    _M_result->_M_set(_M_fn());\n+\t    (*_M_result)->_M_set((*_M_fn)());\n \t  }\n \t__catch(const __cxxabiv1::__forced_unwind&)\n \t  {\n \t    __throw_exception_again; // will cause broken_promise\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_result->_M_error = current_exception();\n+\t    (*_M_result)->_M_error = current_exception();\n \t  }\n-\treturn std::move(_M_result);\n+\treturn std::move(*_M_result);\n       }\n-      _Ptr_type&                _M_result;\n-      std::function<_Res()>     _M_fn;\n+      _Ptr_type*\t_M_result;\n+      _Fn*\t\t_M_fn;\n     };\n \n-  template<typename _Ptr_type>\n-    struct __future_base::_Task_setter<_Ptr_type, void>\n+  template<typename _Ptr_type, typename _Fn>\n+    struct __future_base::_Task_setter<_Ptr_type, _Fn, void>\n     {\n       _Ptr_type operator()()\n       {\n \t__try\n \t  {\n-\t    _M_fn();\n+\t    (*_M_fn)();\n \t  }\n \t__catch(const __cxxabiv1::__forced_unwind&)\n \t  {\n \t    __throw_exception_again; // will cause broken_promise\n \t  }\n \t__catch(...)\n \t  {\n-\t    _M_result->_M_error = current_exception();\n+\t    (*_M_result)->_M_error = current_exception();\n \t  }\n-\treturn std::move(_M_result);\n+\treturn std::move(*_M_result);\n       }\n-      _Ptr_type&                _M_result;\n-      std::function<void()>     _M_fn;\n+      _Ptr_type*\t_M_result;\n+      _Fn*\t\t_M_fn;\n     };\n \n   template<typename _Res, typename... _Args>\n@@ -1294,8 +1275,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// bound arguments decay so wrap lvalue references\n \tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n \t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n-\tauto __setter = _S_task_setter(this->_M_result, std::move(__boundfn));\n-\tthis->_M_set_result(std::move(__setter));\n+\tthis->_M_set_result(_S_task_setter(this->_M_result, __boundfn));\n       }\n \n       virtual shared_ptr<_Task_state_base<_Res(_Args...)>>"}]}