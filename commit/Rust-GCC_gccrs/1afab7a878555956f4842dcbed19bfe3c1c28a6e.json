{"sha": "1afab7a878555956f4842dcbed19bfe3c1c28a6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFmYWI3YTg3ODU1NTk1NmY0ODQyZGNiZWQxOWJmZTNjMWMyOGE2ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-07T21:16:11Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-06-07T21:16:11Z"}, "message": "compiler: improve write barrier generation\n    \n    For string, slice, interface values, do assignments field by\n    field instead of using typedmemmove.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/181297\n\nFrom-SVN: r272055", "tree": {"sha": "2eabbd83ae15107c9d8981d043ef0aa5411fd6de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2eabbd83ae15107c9d8981d043ef0aa5411fd6de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1afab7a878555956f4842dcbed19bfe3c1c28a6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afab7a878555956f4842dcbed19bfe3c1c28a6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1afab7a878555956f4842dcbed19bfe3c1c28a6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1afab7a878555956f4842dcbed19bfe3c1c28a6e/comments", "author": null, "committer": null, "parents": [{"sha": "7a649ef59f9c32dd164a8e62b6eddb778cd7cb12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a649ef59f9c32dd164a8e62b6eddb778cd7cb12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a649ef59f9c32dd164a8e62b6eddb778cd7cb12"}], "stats": {"total": 123, "additions": 116, "deletions": 7}, "files": [{"sha": "91b85c0fecd47e15522f6b9afddbe2472f0082c0", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=1afab7a878555956f4842dcbed19bfe3c1c28a6e", "patch": "@@ -1,4 +1,4 @@\n-9df825b5f142ac2b6f48a8dac94fcff740acd411\n+b79e9e79fddc9040ab58c7c518eb08454f308def\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "22dd2fc4c1d3eb8999d20b4ad567293e9419c6d5", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=1afab7a878555956f4842dcbed19bfe3c1c28a6e", "patch": "@@ -237,7 +237,7 @@ class Expression\n \n   // Make an expression that evaluates to some characteristic of an string.\n   // For simplicity, the enum values must match the field indexes in the\n-  // underlying struct.\n+  // underlying struct.  This returns an lvalue.\n   enum String_info\n     {\n       // The underlying data in the string.\n@@ -448,7 +448,7 @@ class Expression\n \n   // Make an expression that evaluates to some characteristic of a\n   // slice.  For simplicity, the enum values must match the field indexes\n-  // in the underlying struct.\n+  // in the underlying struct.  This returns an lvalue.\n   enum Slice_info\n     {\n       // The underlying data of the slice.\n@@ -469,7 +469,7 @@ class Expression\n \n   // Make an expression that evaluates to some characteristic of an\n   // interface.  For simplicity, the enum values must match the field indexes\n-  // in the underlying struct.\n+  // in the underlying struct.  This returns an lvalue.\n   enum Interface_info\n     {\n       // The type descriptor of an empty interface."}, {"sha": "47cffee8db84ef4421802bf25273ad1f4fd33323", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 112, "deletions": 3, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1afab7a878555956f4842dcbed19bfe3c1c28a6e/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=1afab7a878555956f4842dcbed19bfe3c1c28a6e", "patch": "@@ -822,6 +822,7 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n   Type* unsafe_ptr_type = Type::make_pointer_type(Type::make_void_type());\n   lhs = Expression::make_unsafe_cast(unsafe_ptr_type, lhs, loc);\n \n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n   Expression* call;\n   switch (type->base()->classification())\n     {\n@@ -837,17 +838,125 @@ Gogo::assign_with_write_barrier(Function* function, Block* enclosing,\n     case Type::TYPE_CHANNEL:\n       {\n \t// These types are all represented by a single pointer.\n-\tType* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n \trhs = Expression::make_unsafe_cast(uintptr_type, rhs, loc);\n \tcall = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);\n       }\n       break;\n \n     case Type::TYPE_STRING:\n-    case Type::TYPE_STRUCT:\n-    case Type::TYPE_ARRAY:\n+      {\n+        // Assign the length field directly.\n+        Expression* llen =\n+          Expression::make_string_info(indir->copy(),\n+                                       Expression::STRING_INFO_LENGTH,\n+                                       loc);\n+        Expression* rlen =\n+          Expression::make_string_info(rhs,\n+                                       Expression::STRING_INFO_LENGTH,\n+                                       loc);\n+        Statement* as = Statement::make_assignment(llen, rlen, loc);\n+        inserter->insert(as);\n+\n+        // Assign the data field with a write barrier.\n+        lhs =\n+          Expression::make_string_info(indir->copy(),\n+                                       Expression::STRING_INFO_DATA,\n+                                       loc);\n+        rhs =\n+          Expression::make_string_info(rhs,\n+                                       Expression::STRING_INFO_DATA,\n+                                       loc);\n+        assign = Statement::make_assignment(lhs, rhs, loc);\n+        lhs = Expression::make_unary(OPERATOR_AND, lhs, loc);\n+        rhs = Expression::make_unsafe_cast(uintptr_type, rhs, loc);\n+        call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);\n+      }\n+      break;\n+\n     case Type::TYPE_INTERFACE:\n       {\n+        // Assign the first field directly.\n+        // The first field is either a type descriptor or a method table.\n+        // Type descriptors are either statically created, or created by\n+        // the reflect package. For the latter the reflect package keeps\n+        // all references.\n+        // Method tables are either statically created or persistently\n+        // allocated.\n+        // In all cases they don't need a write barrier.\n+        Expression* ltab =\n+          Expression::make_interface_info(indir->copy(),\n+                                          Expression::INTERFACE_INFO_METHODS,\n+                                          loc);\n+        Expression* rtab =\n+          Expression::make_interface_info(rhs,\n+                                          Expression::INTERFACE_INFO_METHODS,\n+                                          loc);\n+        Statement* as = Statement::make_assignment(ltab, rtab, loc);\n+        inserter->insert(as);\n+\n+        // Assign the data field with a write barrier.\n+        lhs =\n+          Expression::make_interface_info(indir->copy(),\n+                                          Expression::INTERFACE_INFO_OBJECT,\n+                                          loc);\n+        rhs =\n+          Expression::make_interface_info(rhs,\n+                                          Expression::INTERFACE_INFO_OBJECT,\n+                                          loc);\n+        assign = Statement::make_assignment(lhs, rhs, loc);\n+        lhs = Expression::make_unary(OPERATOR_AND, lhs, loc);\n+        rhs = Expression::make_unsafe_cast(uintptr_type, rhs, loc);\n+        call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);\n+      }\n+      break;\n+\n+    case Type::TYPE_ARRAY:\n+      if (type->is_slice_type())\n+       {\n+          // Assign the lenth fields directly.\n+          Expression* llen =\n+            Expression::make_slice_info(indir->copy(),\n+                                        Expression::SLICE_INFO_LENGTH,\n+                                        loc);\n+          Expression* rlen =\n+            Expression::make_slice_info(rhs,\n+                                        Expression::SLICE_INFO_LENGTH,\n+                                        loc);\n+          Statement* as = Statement::make_assignment(llen, rlen, loc);\n+          inserter->insert(as);\n+\n+          // Assign the capacity fields directly.\n+          Expression* lcap =\n+            Expression::make_slice_info(indir->copy(),\n+                                        Expression::SLICE_INFO_CAPACITY,\n+                                        loc);\n+          Expression* rcap =\n+            Expression::make_slice_info(rhs,\n+                                        Expression::SLICE_INFO_CAPACITY,\n+                                        loc);\n+          as = Statement::make_assignment(lcap, rcap, loc);\n+          inserter->insert(as);\n+\n+          // Assign the data field with a write barrier.\n+          lhs =\n+            Expression::make_slice_info(indir->copy(),\n+                                        Expression::SLICE_INFO_VALUE_POINTER,\n+                                        loc);\n+          rhs =\n+            Expression::make_slice_info(rhs,\n+                                        Expression::SLICE_INFO_VALUE_POINTER,\n+                                        loc);\n+          assign = Statement::make_assignment(lhs, rhs, loc);\n+          lhs = Expression::make_unary(OPERATOR_AND, lhs, loc);\n+          rhs = Expression::make_unsafe_cast(uintptr_type, rhs, loc);\n+          call = Runtime::make_call(Runtime::GCWRITEBARRIER, loc, 2, lhs, rhs);\n+          break;\n+        }\n+      // fallthrough\n+\n+    case Type::TYPE_STRUCT:\n+      {\n+        // TODO: split assignments for small struct/array?\n \trhs = Expression::make_unary(OPERATOR_AND, rhs, loc);\n \trhs->unary_expression()->set_does_not_escape();\n \tcall = Runtime::make_call(Runtime::TYPEDMEMMOVE, loc, 3,"}]}