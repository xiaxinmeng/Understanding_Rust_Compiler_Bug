{"sha": "66e97274cef35ed40584c7a09096fffa061fddf0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjZlOTcyNzRjZWYzNWVkNDA1ODRjN2EwOTA5NmZmZmEwNjFmZGRmMA==", "commit": {"author": {"name": "Justin Squirek", "email": "squirek@adacore.com", "date": "2020-09-02T18:20:55Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-23T08:25:06Z"}, "message": "[Ada] Further Ada 2020 work on accessibility checking\n\ngcc/ada/\n\n\t* checks.adb (Apply_Accessibility_Check): Skip checks against\n\tthe extra accessibility of a function result when in Ada 2005\n\tmode or earlier.\n\t* exp_ch3.adb (Build_Initialization_Call): Modify accessibility\n\tlevel calls to use Accessibility_Level.\n\t(Expand_N_Object_Declaration): Modify accessibility level calls\n\tto use Accessibility_Level.\n\t* exp_ch4.adb (Expand_Allocator_Expression): Add static check\n\tfor anonymous access discriminants. Remove unneeded propagation\n\tof accessibility actual.\n\t(Expand_N_In): Modify accessibility level calls to use\n\tAccessibility_Level.\n\t(Expand_N_Type_Conversion): Modify accessibility level calls to\n\tuse Accessibility_Level.\n\t* exp_ch5.adb (Expand_N_Assignment_Statement): Modify\n\taccessibility level calls to use Accessibility_Level.\n\t* exp_ch6.adb (Expand_Call_Helper): Rewrite accessibility\n\tcalculation for the extra accessibility of result actual in\n\tfunction calls, and modify accessibility level calls to use\n\tAccessibility_Level.\n\t(Check_Against_Result_Level): Removed.\n\t* exp_ch9.adb (Expand_N_Requeue_Statement): Add dynamic\n\taccessibility check for requeues\n\t* sem_attr.adb (Resolve_Attribute): Modify accessibility level\n\tcalls to use Accessibility_Level.\n\t* sem_ch13.adb (Associate_Storage_Pool): Modify accessibility\n\tlevel calls to use Accessibility_Level.\n\t* sem_ch4.adb (Analyze_Call): Add static check for explicitly\n\taliased formals in function calls within return statements.\n\t* sem_ch6.adb (Check_Return_Construct_Accessibility): Rewrite\n\troutine to account for non-aggregate return objects.\n\t(Generate_Minimum_Accessibility): Created.\n\t(Analyze_Call): Modify accessibility level calls to use\n\tAccessibility_Level.\n\t(Analyze_Subprogram_Body_Helper): Add generation of minimum\n\taccessibility for the extra accessibility of the function\n\tresult.\n\t* sem_ch9.adb (Analyze_Requeue): Modify accessibility level\n\tcalls to use Accessibility_Level.\n\t* sem_res.adb: (Check_Aliased_Parameters): Modify accessibility\n\tlevel calls to use Accessibility_Level.\n\t(Valid_Conversion): Modify accessibility level calls to use\n\tAccessibility_Level.\n\t* sem_util.adb, sem_util.ads (Accessibility_Level_Helper):\n\tRenamed to Accessibility_Level, add detection for functions in\n\tprefix notation, and add cases where to return zero when\n\tspecified. Modified to take new, more descriptive, parameters.\n\t(Accessibility_Level): Created.\n\t(Function_Call_Level): Removed.\n\t(Function_Call_Or_Allocator_Level): Created to centralize the\n\tcalculation accessibility levels for function calls and\n\tallocators.\n\t(Static_Accessibility_Level): Removed.\n\t(Dynamic_Accessibility_Level): Removed.\n\t(Get_Dynamic_Accessibility): Renamed from Get_Accessibility.\n\t(In_Return_Value): Created to determine if a given expression\n\tcontributes to the current function's return value.\n\t(Is_Master): Created.\n\t(Is_Explicitly_Aliased): Created", "tree": {"sha": "746562266244eef49baed136304bad56d5096c73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/746562266244eef49baed136304bad56d5096c73"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66e97274cef35ed40584c7a09096fffa061fddf0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e97274cef35ed40584c7a09096fffa061fddf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e97274cef35ed40584c7a09096fffa061fddf0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e97274cef35ed40584c7a09096fffa061fddf0/comments", "author": {"login": "AdaDoom3", "id": 3445599, "node_id": "MDQ6VXNlcjM0NDU1OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/3445599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/AdaDoom3", "html_url": "https://github.com/AdaDoom3", "followers_url": "https://api.github.com/users/AdaDoom3/followers", "following_url": "https://api.github.com/users/AdaDoom3/following{/other_user}", "gists_url": "https://api.github.com/users/AdaDoom3/gists{/gist_id}", "starred_url": "https://api.github.com/users/AdaDoom3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/AdaDoom3/subscriptions", "organizations_url": "https://api.github.com/users/AdaDoom3/orgs", "repos_url": "https://api.github.com/users/AdaDoom3/repos", "events_url": "https://api.github.com/users/AdaDoom3/events{/privacy}", "received_events_url": "https://api.github.com/users/AdaDoom3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15e2ad005b1c815136e8eebff2d82b48b4591503", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15e2ad005b1c815136e8eebff2d82b48b4591503", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15e2ad005b1c815136e8eebff2d82b48b4591503"}], "stats": {"total": 1496, "additions": 925, "deletions": 571}, "files": [{"sha": "b389da5accb379cc570f421de6a5f7ab4cb64bff", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 24, "deletions": 9, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -589,7 +589,6 @@ package body Checks is\n       then\n          Param_Ent := Entity (N);\n          while Present (Renamed_Object (Param_Ent)) loop\n-\n             --  Renamed_Object must return an Entity_Name here\n             --  because of preceding \"Present (E_E_A (...))\" test.\n \n@@ -605,25 +604,41 @@ package body Checks is\n       --  are enabled.\n \n       elsif Present (Param_Ent)\n-         and then Present (Get_Accessibility (Param_Ent))\n+         and then Present (Get_Dynamic_Accessibility (Param_Ent))\n          and then not Accessibility_Checks_Suppressed (Param_Ent)\n          and then not Accessibility_Checks_Suppressed (Typ)\n       then\n+         --  Obtain the parameter's accessibility level\n+\n          Param_Level :=\n-           New_Occurrence_Of (Get_Accessibility (Param_Ent), Loc);\n+           New_Occurrence_Of (Get_Dynamic_Accessibility (Param_Ent), Loc);\n \n          --  Use the dynamic accessibility parameter for the function's result\n          --  when one has been created instead of statically referring to the\n          --  deepest type level so as to appropriatly handle the rules for\n          --  RM 3.10.2 (10.1/3).\n \n-         if Ekind (Scope (Param_Ent))\n-              in E_Function | E_Operator | E_Subprogram_Type\n-           and then Present (Extra_Accessibility_Of_Result (Scope (Param_Ent)))\n+         if Ekind (Scope (Param_Ent)) = E_Function\n+           and then In_Return_Value (N)\n+           and then Ekind (Typ) = E_Anonymous_Access_Type\n          then\n-            Type_Level :=\n-              New_Occurrence_Of\n-                (Extra_Accessibility_Of_Result (Scope (Param_Ent)), Loc);\n+            --  Associate the level of the result type to the extra result\n+            --  accessibility parameter belonging to the current function.\n+\n+            if Present (Extra_Accessibility_Of_Result (Scope (Param_Ent))) then\n+               Type_Level :=\n+                 New_Occurrence_Of\n+                   (Extra_Accessibility_Of_Result (Scope (Param_Ent)), Loc);\n+\n+            --  In Ada 2005 and earlier modes, a result extra accessibility\n+            --  parameter is not generated and no dynamic check is performed.\n+\n+            else\n+               return;\n+            end if;\n+\n+         --  Otherwise get the type's accessibility level normally\n+\n          else\n             Type_Level :=\n               Make_Integer_Literal (Loc, Deepest_Type_Access_Level (Typ));"}, {"sha": "f8b6ee68d6a31eda8b48199d369cd2cbaafba4ed", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -1812,7 +1812,7 @@ package body Exp_Ch3 is\n              Selector_Name             =>\n                Make_Identifier (Loc, Name_uInit_Level),\n              Explicit_Actual_Parameter =>\n-               Dynamic_Accessibility_Level (Id_Ref)));\n+               Accessibility_Level (Id_Ref, Dynamic_Level)));\n       end if;\n \n       Append_To (Res,\n@@ -7517,13 +7517,13 @@ package body Exp_Ch3 is\n             elsif Nkind (Expr) = N_Function_Call\n               and then Ekind (Etype (Name (Expr))) = E_Anonymous_Access_Type\n             then\n-               Level_Expr := Make_Integer_Literal (Loc,\n-                               Static_Accessibility_Level (Def_Id));\n+               Level_Expr := Accessibility_Level\n+                               (Def_Id, Object_Decl_Level);\n \n             --  General case\n \n             else\n-               Level_Expr := Dynamic_Accessibility_Level (Expr);\n+               Level_Expr := Accessibility_Level (Expr, Dynamic_Level);\n             end if;\n \n             Level_Decl :=\n@@ -8203,7 +8203,7 @@ package body Exp_Ch3 is\n                   --  type is deeper than that of the pool.\n \n                   if Type_Access_Level (Def_Id)\n-                       > Static_Accessibility_Level (Pool)\n+                       > Static_Accessibility_Level (Pool, Object_Decl_Level)\n                     and then Is_Class_Wide_Type (Etype (Pool))\n                     and then not Accessibility_Checks_Suppressed (Def_Id)\n                     and then not Accessibility_Checks_Suppressed (Pool)"}, {"sha": "076e0def3023ab69f7581444ca84f995f0fd5a3c", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -823,6 +823,37 @@ package body Exp_Ch4 is\n \n       Apply_Predicate_Check (Exp, T);\n \n+      --  Check that any anonymous access discriminants are suitable\n+      --  for use in an allocator.\n+\n+      --  Note: This check is performed here instead of during analysis so that\n+      --  we can check against the fully resolved etype of Exp.\n+\n+      if Is_Entity_Name (Exp)\n+        and then Has_Anonymous_Access_Discriminant (Etype (Exp))\n+        and then Static_Accessibility_Level (Exp, Object_Decl_Level)\n+                   > Static_Accessibility_Level (N, Object_Decl_Level)\n+      then\n+         --  A dynamic check and a warning are generated when we are within\n+         --  an instance.\n+\n+         if In_Instance then\n+            Insert_Action (N,\n+              Make_Raise_Program_Error (Loc,\n+                Reason => PE_Accessibility_Check_Failed));\n+\n+            Error_Msg_N (\"anonymous access discriminant is too deep for use\"\n+                         & \" in allocator<<\", N);\n+            Error_Msg_N (\"\\Program_Error [<<\", N);\n+\n+         --  Otherwise, make the error static\n+\n+         else\n+            Error_Msg_N (\"anonymous access discriminant is too deep for use\"\n+                          & \" in allocator\", N);\n+         end if;\n+      end if;\n+\n       if Do_Range_Check (Exp) then\n          Generate_Range_Check (Exp, T, CE_Range_Check_Failed);\n       end if;\n@@ -850,35 +881,6 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  In the case of an Ada 2012 allocator whose initial value comes from a\n-      --  function call, pass \"the accessibility level determined by the point\n-      --  of call\" (AI05-0234) to the function. Conceptually, this belongs in\n-      --  Expand_Call but it couldn't be done there (because the Etype of the\n-      --  allocator wasn't set then) so we generate the parameter here. See\n-      --  the Boolean variable Defer in (a block within) Expand_Call.\n-\n-      if Ada_Version >= Ada_2012 and then Nkind (Exp) = N_Function_Call then\n-         declare\n-            Subp : Entity_Id;\n-\n-         begin\n-            if Nkind (Name (Exp)) = N_Explicit_Dereference then\n-               Subp := Designated_Type (Etype (Prefix (Name (Exp))));\n-            else\n-               Subp := Entity (Name (Exp));\n-            end if;\n-\n-            Subp := Ultimate_Alias (Subp);\n-\n-            if Present (Extra_Accessibility_Of_Result (Subp)) then\n-               Add_Extra_Actual_To_Call\n-                 (Subprogram_Call => Exp,\n-                  Extra_Formal    => Extra_Accessibility_Of_Result (Subp),\n-                  Extra_Actual    => Dynamic_Accessibility_Level (PtrT));\n-            end if;\n-         end;\n-      end if;\n-\n       Aggr_In_Place := Is_Delayed_Aggregate (Exp);\n \n       --  Case of tagged type or type requiring finalization\n@@ -6870,7 +6872,8 @@ package body Exp_Ch4 is\n                   --  objects of an anonymous access type.\n \n                   else\n-                     Param_Level := Dynamic_Accessibility_Level (Expr_Entity);\n+                     Param_Level := Accessibility_Level\n+                                      (Expr_Entity, Dynamic_Level);\n \n                      Type_Level :=\n                        Make_Integer_Literal (Loc, Type_Access_Level (Rtyp));\n@@ -12285,8 +12288,8 @@ package body Exp_Ch4 is\n            and then Ekind (Operand_Type) = E_Anonymous_Access_Type\n            and then Nkind (Operand) = N_Selected_Component\n            and then Ekind (Entity (Selector_Name (Operand))) = E_Discriminant\n-           and then Static_Accessibility_Level (Operand) >\n-                      Type_Access_Level (Target_Type)\n+           and then Static_Accessibility_Level (Operand, Zero_On_Dynamic_Level)\n+                      > Type_Access_Level (Target_Type)\n          then\n             Raise_Accessibility_Error;\n             goto Done;"}, {"sha": "93351cf4c855fda2601f3d928c01968af27e8413", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -2518,7 +2518,7 @@ package body Exp_Ch5 is\n                                Condition =>\n                                  Make_Op_Gt (Loc,\n                                    Left_Opnd  =>\n-                                     Dynamic_Accessibility_Level (Rhs),\n+                                     Accessibility_Level (Rhs, Dynamic_Level),\n                                    Right_Opnd =>\n                                      Make_Integer_Literal (Loc,\n                                        Intval =>\n@@ -2534,7 +2534,8 @@ package body Exp_Ch5 is\n                                          (Effective_Extra_Accessibility\n                                             (Entity (Lhs)), Loc),\n                                      Expression =>\n-                                        Dynamic_Accessibility_Level (Rhs));\n+                                       Accessibility_Level\n+                                         (Rhs, Dynamic_Level));\n \n          begin\n             if not Accessibility_Checks_Suppressed (Entity (Lhs)) then"}, {"sha": "b7620262e2f22434e3b54b674dfabdf44d06374c", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 35, "deletions": 132, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -2936,8 +2936,8 @@ package body Exp_Ch6 is\n                         New_Occurrence_Of\n                           (Lvl, Loc),\n                       Expression =>\n-                        Dynamic_Accessibility_Level\n-                          (Expression (Res_Assn))));\n+                        Accessibility_Level\n+                          (Expression (Res_Assn), Dynamic_Level)));\n                end if;\n             end Expand_Branch;\n \n@@ -3961,23 +3961,24 @@ package body Exp_Ch6 is\n \n                   Add_Extra_Actual\n                     (Expr =>\n-                       New_Occurrence_Of (Get_Accessibility (Parm_Ent), Loc),\n+                       New_Occurrence_Of\n+                         (Get_Dynamic_Accessibility (Parm_Ent), Loc),\n                      EF   => Extra_Accessibility (Formal));\n                end;\n \n             --  Conditional expressions\n \n             elsif Nkind (Prev) = N_Expression_With_Actions\n-                   and then Nkind (Original_Node (Prev)) in\n-                              N_If_Expression | N_Case_Expression\n+              and then Nkind (Original_Node (Prev)) in\n+                         N_If_Expression | N_Case_Expression\n             then\n                Add_Cond_Expression_Extra_Actual (Formal);\n \n             --  Normal case\n \n             else\n                Add_Extra_Actual\n-                 (Expr => Dynamic_Accessibility_Level (Prev),\n+                 (Expr => Accessibility_Level (Prev, Dynamic_Level),\n                   EF   => Extra_Accessibility (Formal));\n             end if;\n          end if;\n@@ -4202,110 +4203,44 @@ package body Exp_Ch6 is\n           Present (Extra_Accessibility_Of_Result (Ultimate_Alias (Subp)))\n       then\n          declare\n-            Ancestor : Node_Id := Parent (Call_Node);\n-            Level    : Node_Id := Empty;\n-            Defer    : Boolean := False;\n+            Extra_Form : Node_Id := Empty;\n+            Level      : Node_Id := Empty;\n \n          begin\n-            --  Unimplemented: if Subp returns an anonymous access type, then\n-\n-            --    a) if the call is the operand of an explict conversion, then\n-            --       the target type of the conversion (a named access type)\n-            --       determines the accessibility level pass in;\n-\n-            --    b) if the call defines an access discriminant of an object\n-            --       (e.g., the discriminant of an object being created by an\n-            --       allocator, or the discriminant of a function result),\n-            --       then the accessibility level to pass in is that of the\n-            --       discriminated object being initialized).\n-\n-            --  ???\n-\n-            while Nkind (Ancestor) = N_Qualified_Expression\n-            loop\n-               Ancestor := Parent (Ancestor);\n-            end loop;\n-\n-            case Nkind (Ancestor) is\n-               when N_Allocator =>\n-\n-                  --  At this point, we'd like to assign\n-\n-                  --    Level := Dynamic_Accessibility_Level (Ancestor);\n-\n-                  --  but Etype of Ancestor may not have been set yet,\n-                  --  so that doesn't work.\n-\n-                  --  Handle this later in Expand_Allocator_Expression.\n-\n-                  Defer := True;\n-\n-               when N_Object_Declaration\n-                  | N_Object_Renaming_Declaration\n-               =>\n-                  declare\n-                     Def_Id : constant Entity_Id :=\n-                                Defining_Identifier (Ancestor);\n-\n-                  begin\n-                     if Is_Return_Object (Def_Id) then\n-                        if Present (Extra_Accessibility_Of_Result\n-                                     (Return_Applies_To (Scope (Def_Id))))\n-                        then\n-                           --  Pass along value that was passed in if the\n-                           --  routine we are returning from also has an\n-                           --  Accessibility_Of_Result formal.\n-\n-                           Level :=\n-                             New_Occurrence_Of\n-                              (Extra_Accessibility_Of_Result\n-                                (Return_Applies_To (Scope (Def_Id))), Loc);\n-                        end if;\n-                     else\n-                        Level :=\n-                          Make_Integer_Literal (Loc,\n-                            Intval => Static_Accessibility_Level (Def_Id));\n-                     end if;\n-                  end;\n-\n-               when N_Simple_Return_Statement =>\n-                  if Present (Extra_Accessibility_Of_Result\n-                               (Return_Applies_To\n-                                 (Return_Statement_Entity (Ancestor))))\n-                  then\n-                     --  Pass along value that was passed in if the returned\n-                     --  routine also has an Accessibility_Of_Result formal.\n+            --  Detect cases where the function call has been internally\n+            --  generated by examining the original node and return library\n+            --  level - taking care to avoid ignoring function calls expanded\n+            --  in prefix notation.\n+\n+            if Nkind (Original_Node (Call_Node)) not in N_Function_Call\n+                                                      | N_Selected_Component\n+                                                      | N_Indexed_Component\n+            then\n+               Level := Make_Integer_Literal\n+                          (Loc, Scope_Depth (Standard_Standard));\n \n-                     Level :=\n-                       New_Occurrence_Of\n-                         (Extra_Accessibility_Of_Result\n-                           (Return_Applies_To\n-                             (Return_Statement_Entity (Ancestor))), Loc);\n-                  end if;\n+            --  Otherwise get the level normally based on the call node\n \n-               when others =>\n-                  null;\n-            end case;\n-\n-            if not Defer then\n-               if not Present (Level) then\n+            else\n+               Level := Accessibility_Level (Call_Node, Dynamic_Level);\n \n-                  --  The \"innermost master that evaluates the function call\".\n+            end if;\n \n-                  --  ??? - Should we use Integer'Last here instead in order\n-                  --  to deal with (some of) the problems associated with\n-                  --  calls to subps whose enclosing scope is unknown (e.g.,\n-                  --  Anon_Access_To_Subp_Param.all)?\n+            --  It may be possible that we are re-expanding an already\n+            --  expanded call when are are dealing with dispatching ???\n \n-                  Level :=\n-                    Make_Integer_Literal (Loc,\n-                      Intval => Scope_Depth (Current_Scope) + 1);\n-               end if;\n+            if not Present (Parameter_Associations (Call_Node))\n+              or else Nkind (Last (Parameter_Associations (Call_Node)))\n+                        /= N_Parameter_Association\n+              or else not Is_Accessibility_Actual\n+                              (Last (Parameter_Associations (Call_Node)))\n+            then\n+               Extra_Form := Extra_Accessibility_Of_Result\n+                               (Ultimate_Alias (Subp));\n \n                Add_Extra_Actual\n                  (Expr => Level,\n-                  EF   =>\n-                    Extra_Accessibility_Of_Result (Ultimate_Alias (Subp)));\n+                  EF   => Extra_Form);\n             end if;\n          end;\n       end if;\n@@ -7186,27 +7121,6 @@ package body Exp_Ch6 is\n       --  of the return object to the specific type on assignments to the\n       --  individual components.\n \n-      procedure Check_Against_Result_Level (Level : Node_Id);\n-      --  Check the given accessibility level against the level\n-      --  determined by the point of call. (AI05-0234).\n-\n-      --------------------------------\n-      -- Check_Against_Result_Level --\n-      --------------------------------\n-\n-      procedure Check_Against_Result_Level (Level : Node_Id) is\n-      begin\n-         Insert_Action (N,\n-           Make_Raise_Program_Error (Loc,\n-             Condition =>\n-               Make_Op_Gt (Loc,\n-                 Left_Opnd  => Level,\n-                 Right_Opnd =>\n-                   New_Occurrence_Of\n-                     (Extra_Accessibility_Of_Result (Scope_Id), Loc)),\n-                 Reason => PE_Accessibility_Check_Failed));\n-      end Check_Against_Result_Level;\n-\n    --  Start of processing for Expand_Simple_Function_Return\n \n    begin\n@@ -7648,17 +7562,6 @@ package body Exp_Ch6 is\n              Suppress  => All_Checks);\n       end if;\n \n-      --  Determine if the special rules within RM 3.10.2 for explicitly\n-      --  aliased formals apply to Exp - in which case we require a dynamic\n-      --  check to be generated.\n-\n-      if Is_Special_Aliased_Formal_Access (Exp, Scope_Id) then\n-         Check_Against_Result_Level\n-           (Make_Integer_Literal (Loc,\n-             Static_Accessibility_Level\n-               (Entity (Ultimate_Prefix (Prefix (Exp))))));\n-      end if;\n-\n       --  If we are returning a nonscalar object that is possibly unaligned,\n       --  then copy the value into a temporary first. This copy may need to\n       --  expand to a loop of component operations."}, {"sha": "72077236c9d70729e171dd68b3af6e91a03789a0", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -10073,6 +10073,7 @@ package body Exp_Ch9 is\n       Conc_Typ : Entity_Id;\n       Concval  : Node_Id;\n       Ename    : Node_Id;\n+      Enc_Subp : Entity_Id;\n       Index    : Node_Id;\n       Old_Typ  : Entity_Id;\n \n@@ -10589,6 +10590,26 @@ package body Exp_Ch9 is\n          Old_Typ := Scope (Old_Typ);\n       end loop;\n \n+      --  Obtain the innermost enclosing callable construct for use in\n+      --  generating a dynamic accessibility check.\n+\n+      Enc_Subp := Current_Scope;\n+\n+      if Ekind (Enc_Subp) not in Entry_Kind | Subprogram_Kind then\n+         Enc_Subp := Enclosing_Subprogram (Enc_Subp);\n+      end if;\n+\n+      --  Generate a dynamic accessibility check on the target object\n+\n+      Insert_Before_And_Analyze (N,\n+        Make_Raise_Program_Error (Loc,\n+          Condition =>\n+            Make_Op_Gt (Loc,\n+              Left_Opnd  => Accessibility_Level (Name (N), Dynamic_Level),\n+              Right_Opnd => Make_Integer_Literal (Loc,\n+                              Scope_Depth (Enc_Subp))),\n+          Reason    => PE_Accessibility_Check_Failed));\n+\n       --  Ada 2012 (AI05-0030): We have a dispatching requeue of the form\n       --  Concval.Ename where the type of Concval is class-wide concurrent\n       --  interface."}, {"sha": "e361601eb9cea9438ceac82a1c5349a0b18e91d2", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -11286,10 +11286,9 @@ package body Sem_Attr is\n                  --  Otherwise a check will be generated later when the return\n                  --  statement gets expanded.\n \n-                 and then not Is_Special_Aliased_Formal_Access\n-                                (N, Current_Scope)\n+                 and then not Is_Special_Aliased_Formal_Access (N)\n                  and then\n-                   Static_Accessibility_Level (P) >\n+                   Static_Accessibility_Level (N, Zero_On_Dynamic_Level) >\n                      Deepest_Type_Access_Level (Btyp)\n                then\n                   --  In an instance, this is a runtime check, but one we know\n@@ -11433,8 +11432,19 @@ package body Sem_Attr is\n \n                if Attr_Id /= Attribute_Unchecked_Access\n                  and then Ekind (Btyp) = E_General_Access_Type\n+\n+                 --  Call Accessibility_Level directly to avoid returning zero\n+                 --  on cases where the prefix is an explicitly aliased\n+                 --  parameter in a return statement, instead of using the\n+                 --  normal Static_Accessibility_Level function.\n+\n+                 --  Shouldn't this be handled somehow in\n+                 --  Static_Accessibility_Level ???\n+\n+                 and then Nkind (Accessibility_Level (P, Dynamic_Level))\n+                            = N_Integer_Literal\n                  and then\n-                   Static_Accessibility_Level (P)\n+                   Intval (Accessibility_Level (P, Dynamic_Level))\n                      > Deepest_Type_Access_Level (Btyp)\n                then\n                   Accessibility_Message;\n@@ -11456,7 +11466,7 @@ package body Sem_Attr is\n                --  anonymous_access_to_protected, there are no accessibility\n                --  checks either. Omit check entirely for Unrestricted_Access.\n \n-               elsif Static_Accessibility_Level (P)\n+               elsif Static_Accessibility_Level (P, Zero_On_Dynamic_Level)\n                        > Deepest_Type_Access_Level (Btyp)\n                  and then Comes_From_Source (N)\n                  and then Ekind (Btyp) = E_Access_Protected_Subprogram_Type"}, {"sha": "70130945ce1bd809897c10b372ef1da3e3bcd822", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -7285,7 +7285,8 @@ package body Sem_Ch13 is\n                   --  check (B)\n \n                   if Type_Access_Level (Ent)\n-                       > Static_Accessibility_Level (Pool)\n+                       > Static_Accessibility_Level\n+                           (Pool, Object_Decl_Level)\n                   then\n                      Error_Msg_N\n                        (\"subpool access type has deeper accessibility \""}, {"sha": "d06a4a852e944a665ae002b72b57952ba1331d10", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -976,7 +976,7 @@ package body Sem_Ch4 is\n       Nam     : Node_Id;\n       X       : Interp_Index;\n       It      : Interp;\n-      Nam_Ent : Entity_Id;\n+      Nam_Ent : Entity_Id := Empty;\n       Success : Boolean := False;\n \n       Deref : Boolean := False;\n@@ -1471,6 +1471,46 @@ package body Sem_Ch4 is\n          End_Interp_List;\n       end if;\n \n+      --  Check the accessibility level for actuals for explicitly aliased\n+      --  formals.\n+\n+      if Nkind (N) = N_Function_Call\n+        and then Comes_From_Source (N)\n+        and then Present (Nam_Ent)\n+        and then In_Return_Value (N)\n+      then\n+         declare\n+            Form : Node_Id;\n+            Act  : Node_Id;\n+         begin\n+            Act  := First_Actual (N);\n+            Form := First_Formal (Nam_Ent);\n+\n+            while Present (Form) and then Present (Act) loop\n+               --  Check whether the formal is aliased and if the accessibility\n+               --  level of the actual is deeper than the accessibility level\n+               --  of the enclosing subprogam to which the current return\n+               --  statement applies.\n+\n+               --  Should we be checking Is_Entity_Name on Act? Won't this miss\n+               --  other cases ???\n+\n+               if Is_Explicitly_Aliased (Form)\n+                 and then Is_Entity_Name (Act)\n+                 and then Static_Accessibility_Level\n+                            (Act, Zero_On_Dynamic_Level)\n+                              > Subprogram_Access_Level (Current_Subprogram)\n+               then\n+                  Error_Msg_N (\"actual for explicitly aliased formal is too\"\n+                                & \" short lived\", Act);\n+               end if;\n+\n+               Next_Formal (Form);\n+               Next_Actual (Act);\n+            end loop;\n+         end;\n+      end if;\n+\n       if Ada_Version >= Ada_2012 then\n \n          --  Check if the call contains a function with writable actuals"}, {"sha": "88bbdf76c77671f52b4d5f015df86fbe49bcf991", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 271, "deletions": 170, "changes": 441, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -784,20 +784,19 @@ package body Sem_Ch6 is\n       ------------------------------------------\n \n       procedure Check_Return_Construct_Accessibility (Return_Stmt : Node_Id) is\n-         Assoc         : Node_Id;\n-         Agg           : Node_Id := Empty;\n-         Discr         : Entity_Id;\n-         Expr          : Node_Id;\n-         Obj           : Node_Id;\n-         Process_Exprs : Boolean := False;\n-         Return_Con    : Node_Id;\n+         Return_Con : Node_Id;\n+         Assoc      : Node_Id := Empty;\n+         Assoc_Expr : Node_Id;\n+         Disc       : Entity_Id;\n+         Obj_Decl   : Node_Id;\n+         Unqual     : Node_Id;\n \n       begin\n          --  Only perform checks on record types with access discriminants and\n          --  non-internally generated functions.\n \n          if not Is_Record_Type (R_Type)\n-           or else not Has_Discriminants (R_Type)\n+           or else not Has_Anonymous_Access_Discriminant (R_Type)\n            or else not Comes_From_Source (Return_Stmt)\n          then\n             return;\n@@ -837,166 +836,219 @@ package body Sem_Ch6 is\n \n             Return_Con := Original_Node (Return_Con);\n          else\n-            Return_Con := Return_Stmt;\n+            Return_Con := Expression (Return_Stmt);\n          end if;\n \n-         --  We may need to check an aggregate or a subtype indication\n-         --  depending on how the discriminants were specified and whether\n-         --  we are looking at an extended return statement.\n+         --  Obtain the accessibility levels of the expressions associated\n+         --  with all anonymous access discriminants, then generate a\n+         --  dynamic check or static error when relevant.\n \n-         if Nkind (Return_Con) = N_Object_Declaration\n-           and then Nkind (Object_Definition (Return_Con))\n-                      = N_Subtype_Indication\n+         Unqual := Unqualify (Original_Node (Return_Con));\n+\n+         --  Obtain the corresponding declaration based on the return object's\n+         --  identifier.\n+\n+         if Nkind (Unqual) = N_Identifier\n+           and then Nkind (Parent (Entity (Unqual)))\n+                      in N_Object_Declaration\n+                       | N_Object_Renaming_Declaration\n          then\n-            Assoc := Original_Node\n-                       (First\n-                         (Constraints\n-                           (Constraint (Object_Definition (Return_Con)))));\n+            Obj_Decl := Original_Node (Parent (Entity (Unqual)));\n+\n+         --  We were passed the object declaration directly, so use it\n+\n+         elsif Nkind (Unqual) in N_Object_Declaration\n+                               | N_Object_Renaming_Declaration\n+         then\n+            Obj_Decl := Unqual;\n+\n+         --  Otherwise, we are looking at something else\n+\n          else\n-            --  Qualified expressions may be nested\n+            Obj_Decl := Empty;\n \n-            Agg := Original_Node (Expression (Return_Con));\n-            while Nkind (Agg) = N_Qualified_Expression loop\n-               Agg := Original_Node (Expression (Agg));\n-            end loop;\n+         end if;\n+\n+         --  Hop up object renamings when present\n+\n+         if Present (Obj_Decl)\n+           and then Nkind (Obj_Decl) = N_Object_Renaming_Declaration\n+         then\n+            while Nkind (Obj_Decl) = N_Object_Renaming_Declaration loop\n+\n+               if Nkind (Name (Obj_Decl)) not in N_Entity then\n+                  --  We may be looking at the expansion of iterators or\n+                  --  some other internally generated construct, so it is safe\n+                  --  to ignore checks ???\n+\n+                  if not Comes_From_Source (Obj_Decl) then\n+                     return;\n+                  end if;\n \n-            --  If we are looking at an aggregate instead of a function call we\n-            --  can continue checking accessibility for the supplied\n-            --  discriminant associations.\n+                  Obj_Decl := Original_Node\n+                                (Declaration_Node\n+                                  (Ultimate_Prefix (Name (Obj_Decl))));\n+\n+               --  Move up to the next declaration based on the object's name\n \n-            if Nkind (Agg) = N_Aggregate then\n-               if Present (Expressions (Agg)) then\n-                  Assoc         := First (Expressions (Agg));\n-                  Process_Exprs := True;\n                else\n-                  Assoc := First (Component_Associations (Agg));\n+                  Obj_Decl := Original_Node\n+                                (Declaration_Node (Name (Obj_Decl)));\n                end if;\n+            end loop;\n+         end if;\n+\n+         --  Obtain the discriminant values from the return aggregate\n \n-            --  Otherwise the expression is not of interest ???\n+         --  Do we cover extension aggregates correctly ???\n \n+         if Nkind (Unqual) = N_Aggregate then\n+            if Present (Expressions (Unqual)) then\n+               Assoc := First (Expressions (Unqual));\n             else\n-               return;\n+               Assoc := First (Component_Associations (Unqual));\n             end if;\n-         end if;\n \n-         --  Move through the discriminants checking the accessibility level\n-         --  of each co-extension's associated expression.\n+         --  There is an object declaration for the return object\n \n-         Discr := First_Discriminant (R_Type);\n-         while Present (Discr) loop\n-            if Ekind (Etype (Discr)) = E_Anonymous_Access_Type then\n+         elsif Present (Obj_Decl) then\n+            --  When a subtype indication is present in an object declaration\n+            --  it must contain the object's discriminants.\n+\n+            if Nkind (Object_Definition (Obj_Decl)) = N_Subtype_Indication then\n+               Assoc := First\n+                          (Constraints\n+                            (Constraint\n+                              (Object_Definition (Obj_Decl))));\n+\n+            --  The object declaration contains an aggregate\n+\n+            elsif Present (Expression (Obj_Decl)) then\n+\n+               if Nkind (Unqualify (Expression (Obj_Decl))) = N_Aggregate then\n+                  --  Grab the first associated discriminant expresion\n+\n+                  if Present\n+                       (Expressions (Unqualify (Expression (Obj_Decl))))\n+                  then\n+                     Assoc := First\n+                                (Expressions\n+                                  (Unqualify (Expression (Obj_Decl))));\n+                  else\n+                     Assoc := First\n+                                (Component_Associations\n+                                  (Unqualify (Expression (Obj_Decl))));\n+                  end if;\n+\n+               --  Otherwise, this is something else\n \n-               if Nkind (Assoc) = N_Attribute_Reference then\n-                  Expr := Assoc;\n-               elsif Nkind (Assoc) in\n-                       N_Component_Association | N_Discriminant_Association\n-               then\n-                  Expr := Expression (Assoc);\n                else\n-                  Expr := Empty;\n+                  return;\n                end if;\n \n-               --  This anonymous access discriminant has an associated\n-               --  expression which needs checking.\n-\n-               if Present (Expr)\n-                 and then Nkind (Expr) = N_Attribute_Reference\n-                 and then Attribute_Name (Expr) /= Name_Unrestricted_Access\n-               then\n-                  --  Obtain the object to perform static checks on by moving\n-                  --  up the prefixes in the expression taking into account\n-                  --  named access types and renamed objects within the\n-                  --  expression.\n+            --  There are no supplied discriminants in the object declaration,\n+            --  so get them from the type definition since they must be default\n+            --  initialized.\n \n-                  --  Note, this loop duplicates some of the logic in\n-                  --  Object_Access_Level since we have to check special rules\n-                  --  based on the context we are in (a return aggregate)\n-                  --  relating to formals of the current function.\n+            --  Do we handle constrained subtypes correctly ???\n \n-                  Obj := Original_Node (Prefix (Expr));\n-                  loop\n-                     while Nkind (Obj) in N_Explicit_Dereference\n-                                        | N_Indexed_Component\n-                                        | N_Selected_Component\n-                     loop\n-                        --  When we encounter a named access type then we can\n-                        --  ignore accessibility checks on the dereference.\n+            elsif Nkind (Unqual) = N_Object_Declaration then\n+               Assoc := First_Discriminant\n+                          (Etype (Object_Definition (Obj_Decl)));\n \n-                        if Ekind (Etype (Original_Node (Prefix (Obj))))\n-                             in E_Access_Type ..\n-                                E_Access_Protected_Subprogram_Type\n-                        then\n-                           if Nkind (Obj) = N_Selected_Component then\n-                              Obj := Selector_Name (Obj);\n-                           else\n-                              Obj := Original_Node (Prefix (Obj));\n-                           end if;\n-                           exit;\n-                        end if;\n+            else\n+               Assoc := First_Discriminant (Etype (Unqual));\n+            end if;\n \n-                        Obj := Original_Node (Prefix (Obj));\n-                     end loop;\n+         --  When we are not looking at an aggregate or an identifier, return\n+         --  since any other construct (like a function call) is not\n+         --  applicable since checks will be performed on the side of the\n+         --  callee.\n \n-                     if Nkind (Obj) = N_Selected_Component then\n-                        Obj := Selector_Name (Obj);\n-                     end if;\n+         else\n+            return;\n+         end if;\n \n-                     --  Check for renamings\n+         --  Obtain the discriminants so we know the actual type in case the\n+         --  value of their associated expression gets implicitly converted.\n \n-                     pragma Assert (Is_Entity_Name (Obj));\n+         if No (Obj_Decl) then\n+            pragma Assert (Nkind (Unqual) = N_Aggregate);\n \n-                     if Present (Renamed_Object (Entity (Obj))) then\n-                        Obj := Renamed_Object (Entity (Obj));\n-                     else\n-                        exit;\n-                     end if;\n-                  end loop;\n+            Disc := First_Discriminant (Etype (Unqual));\n \n-                  --  Do not check aliased formals statically\n+         else\n+            Disc := First_Discriminant\n+                      (Etype (Defining_Identifier (Obj_Decl)));\n+         end if;\n \n-                  if Is_Formal (Entity (Obj))\n-                    and then (Is_Aliased (Entity (Obj))\n-                               or else Ekind (Etype (Entity (Obj))) =\n-                                         E_Anonymous_Access_Type)\n-                  then\n-                     null;\n+         --  Loop through each of the discriminants and check each expression\n+         --  associated with an anonymous access discriminant.\n \n-                  --  Otherwise, handle the expression normally, avoiding the\n-                  --  special logic above, and call Object_Access_Level with\n-                  --  the original expression.\n+         while Present (Assoc) and then Present (Disc) loop\n+            --  Unwrap the associated expression\n \n-                  elsif Static_Accessibility_Level (Expr) >\n-                          Scope_Depth (Scope (Scope_Id))\n-                  then\n-                     Error_Msg_N\n-                       (\"access discriminant in return aggregate would \"\n-                        & \"be a dangling reference\", Obj);\n-                  end if;\n-               end if;\n-            end if;\n+            if Nkind (Assoc)\n+                 in N_Component_Association | N_Discriminant_Association\n+            then\n+               Assoc_Expr := Expression (Assoc);\n \n-            Next_Discriminant (Discr);\n+            elsif Nkind (Assoc) in N_Entity\n+              and then Ekind (Assoc) = E_Discriminant\n+            then\n+               Assoc_Expr := Discriminant_Default_Value (Assoc);\n \n-            if not Is_List_Member (Assoc) then\n-               Assoc := Empty;\n             else\n-               Nlists.Next (Assoc);\n+               Assoc_Expr := Assoc;\n             end if;\n \n-            --  After aggregate expressions, examine component associations if\n-            --  present.\n+            --  Check the accessibility level of the expression when the\n+            --  discriminant is of an anonymous access type.\n+\n+            if Present (Assoc_Expr)\n+              and then Ekind (Etype (Disc)) = E_Anonymous_Access_Type\n+            then\n+               --  Perform a static check first, if possible\n \n-            if No (Assoc) then\n-               if Present (Agg)\n-                 and then Process_Exprs\n-                 and then Present (Component_Associations (Agg))\n+               if Static_Accessibility_Level\n+                    (Expr              => Assoc_Expr,\n+                     Level             => Zero_On_Dynamic_Level,\n+                     In_Return_Context => True)\n+                      > Scope_Depth (Scope (Scope_Id))\n                then\n-                  Assoc         := First (Component_Associations (Agg));\n-                  Process_Exprs := False;\n-               else\n+                  Error_Msg_N\n+                    (\"access discriminant in return object would be a dangling\"\n+                     & \" reference\", Return_Stmt);\n                   exit;\n+\n+               end if;\n+\n+               --  Otherwise, generate a dynamic check based on the extra\n+               --  accessibility of the result.\n+\n+               if Present (Extra_Accessibility_Of_Result (Scope_Id)) then\n+                  Insert_Before_And_Analyze (Return_Stmt,\n+                    Make_Raise_Program_Error (Loc,\n+                      Condition =>\n+                        Make_Op_Gt (Loc,\n+                          Left_Opnd  => Accessibility_Level\n+                                          (Expr              => Assoc_Expr,\n+                                           Level             => Dynamic_Level,\n+                                           In_Return_Context => True),\n+                          Right_Opnd => Extra_Accessibility_Of_Result\n+                                          (Scope_Id)),\n+                      Reason    => PE_Accessibility_Check_Failed));\n                end if;\n             end if;\n+\n+            --  Iterate over the discriminants\n+\n+            Disc := Next_Discriminant (Disc);\n+            if not Is_List_Member (Assoc) then\n+               exit;\n+            else\n+               Nlists.Next (Assoc);\n+            end if;\n          end loop;\n       end Check_Return_Construct_Accessibility;\n \n@@ -1436,8 +1488,8 @@ package body Sem_Ch6 is\n \n          if (Ada_Version < Ada_2005 or else Debug_Flag_Dot_L)\n            and then Is_Limited_View (Etype (Scope_Id))\n-           and then Static_Accessibility_Level (Expr) >\n-                      Subprogram_Access_Level (Scope_Id)\n+           and then Static_Accessibility_Level (Expr, Zero_On_Dynamic_Level)\n+                      > Subprogram_Access_Level (Scope_Id)\n          then\n             --  Suppress the message in a generic, where the rewriting\n             --  is irrelevant.\n@@ -2578,6 +2630,9 @@ package body Sem_Ch6 is\n       Loc       : constant Source_Ptr := Sloc (N);\n       Prev_Id   : constant Entity_Id  := Current_Entity_In_Scope (Body_Id);\n \n+      Body_Nod         : Node_Id := Empty;\n+      Minimum_Acc_Objs : List_Id := No_List;\n+\n       Conformant : Boolean;\n       Desig_View : Entity_Id := Empty;\n       Exch_Views : Elist_Id  := No_Elist;\n@@ -2662,6 +2717,13 @@ package body Sem_Ch6 is\n       --  limited views with the non-limited ones. Return the list of changes\n       --  to be used to undo the transformation.\n \n+      procedure Generate_Minimum_Accessibility\n+        (Extra_Access : Entity_Id;\n+         Related_Form : Entity_Id := Empty);\n+      --  Generate a minimum accessibility object for a given extra\n+      --  accessibility formal (Extra_Access) and its related formal if it\n+      --  exists.\n+\n       function Is_Private_Concurrent_Primitive\n         (Subp_Id : Entity_Id) return Boolean;\n       --  Determine whether subprogram Subp_Id is a primitive of a concurrent\n@@ -3439,6 +3501,66 @@ package body Sem_Ch6 is\n          return Result;\n       end Exchange_Limited_Views;\n \n+      ------------------------------------\n+      -- Generate_Minimum_Accessibility --\n+      ------------------------------------\n+\n+      procedure Generate_Minimum_Accessibility\n+        (Extra_Access : Entity_Id;\n+         Related_Form : Entity_Id := Empty)\n+      is\n+         Loc      : constant Source_Ptr := Sloc (Body_Nod);\n+         Form     : Entity_Id;\n+         Obj_Node : Node_Id;\n+      begin\n+         --  When no related formal exists then we are dealing with an\n+         --  extra accessibility formal for a function result.\n+\n+         if No (Related_Form) then\n+            Form := Extra_Access;\n+         else\n+            Form := Related_Form;\n+         end if;\n+\n+         --  Create the minimum accessibility object\n+\n+         Obj_Node :=\n+            Make_Object_Declaration (Loc,\n+             Defining_Identifier =>\n+               Make_Temporary\n+                 (Loc, 'A', Extra_Access),\n+             Object_Definition   => New_Occurrence_Of\n+                                      (Standard_Natural, Loc),\n+             Expression          =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix         => New_Occurrence_Of\n+                                     (Standard_Natural, Loc),\n+                 Attribute_Name => Name_Min,\n+                 Expressions    => New_List (\n+                   Make_Integer_Literal (Loc,\n+                     Scope_Depth (Body_Id)),\n+                   New_Occurrence_Of\n+                     (Extra_Access, Loc))));\n+\n+         --  Add the new local object to the Minimum_Acc_Obj to\n+         --  be later prepended to the subprogram's list of\n+         --  declarations after we are sure all expansion is\n+         --  done.\n+\n+         if Present (Minimum_Acc_Objs) then\n+            Prepend (Obj_Node, Minimum_Acc_Objs);\n+         else\n+            Minimum_Acc_Objs := New_List (Obj_Node);\n+         end if;\n+\n+         --  Register the object and analyze it\n+\n+         Set_Minimum_Accessibility\n+           (Form, Defining_Identifier (Obj_Node));\n+\n+         Analyze (Obj_Node);\n+      end Generate_Minimum_Accessibility;\n+\n       -------------------------------------\n       -- Is_Private_Concurrent_Primitive --\n       -------------------------------------\n@@ -3770,9 +3892,6 @@ package body Sem_Ch6 is\n \n       --  Local variables\n \n-      Body_Nod         : Node_Id := Empty;\n-      Minimum_Acc_Objs : List_Id := No_List;\n-\n       Saved_GM   : constant Ghost_Mode_Type := Ghost_Mode;\n       Saved_IGR  : constant Node_Id         := Ignored_Ghost_Region;\n       Saved_EA   : constant Boolean         := Expander_Active;\n@@ -4650,7 +4769,7 @@ package body Sem_Ch6 is\n \n       --  This method is used to supplement our \"small integer model\" for\n       --  accessibility-check generation (for more information see\n-      --  Dynamic_Accessibility_Level).\n+      --  Accessibility_Level).\n \n       --  Because we allow accessibility values greater than our expected value\n       --  passing along the same extra accessibility formal as an actual\n@@ -4701,49 +4820,31 @@ package body Sem_Ch6 is\n \n                      --    A60b : constant natural := natural'min(1, paramL);\n \n-                     declare\n-                        Loc      : constant Source_Ptr := Sloc (Body_Nod);\n-                        Obj_Node : constant Node_Id :=\n-                           Make_Object_Declaration (Loc,\n-                            Defining_Identifier =>\n-                              Make_Temporary\n-                                (Loc, 'A', Extra_Accessibility (Form)),\n-                            Constant_Present    => True,\n-                            Object_Definition   => New_Occurrence_Of\n-                                                     (Standard_Natural, Loc),\n-                            Expression          =>\n-                              Make_Attribute_Reference (Loc,\n-                                Prefix         => New_Occurrence_Of\n-                                                    (Standard_Natural, Loc),\n-                                Attribute_Name => Name_Min,\n-                                Expressions    => New_List (\n-                                  Make_Integer_Literal (Loc,\n-                                    Scope_Depth (Current_Scope)),\n-                                  New_Occurrence_Of\n-                                    (Extra_Accessibility (Form), Loc))));\n-                     begin\n-                        --  Add the new local object to the Minimum_Acc_Obj to\n-                        --  be later prepended to the subprogram's list of\n-                        --  declarations after we are sure all expansion is\n-                        --  done.\n+                     Generate_Minimum_Accessibility\n+                       (Extra_Accessibility (Form), Form);\n+                  end if;\n \n-                        if Present (Minimum_Acc_Objs) then\n-                           Prepend (Obj_Node, Minimum_Acc_Objs);\n-                        else\n-                           Minimum_Acc_Objs := New_List (Obj_Node);\n-                        end if;\n+                  Next_Formal (Form);\n+               end loop;\n \n-                        --  Register the object and analyze it\n+               --  Generate the minimum accessibility level object for the\n+               --  function's Extra_Accessibility_Of_Result.\n \n-                        Set_Minimum_Accessibility\n-                          (Form, Defining_Identifier (Obj_Node));\n+               --    A31b : constant natural := natural'min (2, funcL);\n \n-                        Analyze (Obj_Node);\n-                     end;\n-                  end if;\n+               if Ekind (Body_Id) = E_Function\n+                 and then Present (Extra_Accessibility_Of_Result (Body_Id))\n+               then\n+                  Generate_Minimum_Accessibility\n+                    (Extra_Accessibility_Of_Result (Body_Id));\n \n-                  Next_Formal (Form);\n-               end loop;\n+                  --  Replace the Extra_Accessibility_Of_Result with the new\n+                  --  minimum accessibility object.\n+\n+                  Set_Extra_Accessibility_Of_Result\n+                    (Body_Id, Minimum_Accessibility\n+                                (Extra_Accessibility_Of_Result (Body_Id)));\n+               end if;\n             end if;\n          end;\n       end if;"}, {"sha": "a9d720b18a4b5a4f99016cef3cc2721b9e4aa3ac", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -2360,7 +2360,8 @@ package body Sem_Ch9 is\n          --  entry body) unless it is a parameter of the innermost enclosing\n          --  accept statement (or entry body).\n \n-         if Static_Accessibility_Level (Target_Obj) >= Scope_Depth (Outer_Ent)\n+         if Static_Accessibility_Level (Target_Obj, Zero_On_Dynamic_Level)\n+              >= Scope_Depth (Outer_Ent)\n            and then\n              (not Is_Entity_Name (Target_Obj)\n                or else not Is_Formal (Entity (Target_Obj))"}, {"sha": "a24c9c2463850bc7cabe42532dff64b736166dbb", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -3500,15 +3500,15 @@ package body Sem_Res is\n             elsif Ekind (Etype (Nam)) = E_Anonymous_Access_Type then\n                if Nkind (Parent (N)) = N_Type_Conversion\n                  and then Type_Access_Level (Etype (Parent (N)))\n-                            < Static_Accessibility_Level (A)\n+                            < Static_Accessibility_Level (A, Object_Decl_Level)\n                then\n                   Error_Msg_N (\"aliased actual has wrong accessibility\", A);\n                end if;\n \n             elsif Nkind (Parent (N)) = N_Qualified_Expression\n               and then Nkind (Parent (Parent (N))) = N_Allocator\n               and then Type_Access_Level (Etype (Parent (Parent (N))))\n-                         < Static_Accessibility_Level (A)\n+                         < Static_Accessibility_Level (A, Object_Decl_Level)\n             then\n                Error_Msg_N\n                  (\"aliased actual in allocator has wrong accessibility\", A);\n@@ -5061,8 +5061,9 @@ package body Sem_Res is\n          elsif Nkind (Disc_Exp) = N_Attribute_Reference\n            and then Get_Attribute_Id (Attribute_Name (Disc_Exp)) =\n                       Attribute_Access\n-           and then Static_Accessibility_Level (Prefix (Disc_Exp)) >\n-                      Deepest_Type_Access_Level (Alloc_Typ)\n+           and then Static_Accessibility_Level\n+                      (Disc_Exp, Zero_On_Dynamic_Level)\n+                        > Deepest_Type_Access_Level (Alloc_Typ)\n          then\n             Error_Msg_N\n               (\"prefix of attribute has deeper level than allocator type\",\n@@ -5073,8 +5074,9 @@ package body Sem_Res is\n \n          elsif Ekind (Etype (Disc_Exp)) = E_Anonymous_Access_Type\n            and then Nkind (Disc_Exp) = N_Selected_Component\n-           and then Static_Accessibility_Level (Prefix (Disc_Exp)) >\n-                      Deepest_Type_Access_Level (Alloc_Typ)\n+           and then Static_Accessibility_Level\n+                      (Disc_Exp, Zero_On_Dynamic_Level)\n+                        > Deepest_Type_Access_Level (Alloc_Typ)\n          then\n             Error_Msg_N\n               (\"access discriminant has deeper level than allocator type\",\n@@ -13351,12 +13353,13 @@ package body Sem_Res is\n             then\n                --  When the operand is a selected access discriminant the check\n                --  needs to be made against the level of the object denoted by\n-               --  the prefix of the selected name (Object_Access_Level handles\n+               --  the prefix of the selected name (Accessibility_Level handles\n                --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Static_Accessibility_Level (Operand)\n-                            > Deepest_Type_Access_Level (Target_Type)\n+                 and then Static_Accessibility_Level\n+                            (Operand, Zero_On_Dynamic_Level)\n+                              > Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise\n@@ -13524,6 +13527,13 @@ package body Sem_Res is\n                          N_Function_Specification\n                         or else Ekind (Target_Type) in\n                                   Anonymous_Access_Kind)\n+\n+              --  Check we are not in a return value ???\n+\n+              and then (not In_Return_Value (N)\n+                         or else\n+                           Nkind (Associated_Node_For_Itype (Target_Type))\n+                             = N_Component_Declaration)\n             then\n                --  In an instance, this is a run-time check, but one we know\n                --  will fail, so generate an appropriate warning. The raise\n@@ -13558,12 +13568,13 @@ package body Sem_Res is\n             then\n                --  When the operand is a selected access discriminant the check\n                --  needs to be made against the level of the object denoted by\n-               --  the prefix of the selected name (Object_Access_Level handles\n+               --  the prefix of the selected name (Accessibility_Level handles\n                --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n-                 and then Static_Accessibility_Level (Operand)\n-                            > Deepest_Type_Access_Level (Target_Type)\n+                 and then Static_Accessibility_Level\n+                            (Operand, Zero_On_Dynamic_Level)\n+                              > Deepest_Type_Access_Level (Target_Type)\n                then\n                   --  In an instance, this is a run-time check, but one we know\n                   --  will fail, so generate an appropriate warning. The raise"}, {"sha": "0eb49050cd91fae9bf089a34736720edc347df14", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 383, "deletions": 189, "changes": 572, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -98,11 +98,6 @@ package body Sem_Util is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Accessibility_Level_Helper\n-     (Expr   : Node_Id;\n-      Static : Boolean := False) return Node_Id;\n-   --  Unified static and dynamic accessibility level calculation subroutine\n-\n    function Build_Component_Subtype\n      (C   : List_Id;\n       Loc : Source_Ptr;\n@@ -275,16 +270,21 @@ package body Sem_Util is\n       return Interface_List (Nod);\n    end Abstract_Interface_List;\n \n-   --------------------------------\n-   -- Accessibility_Level_Helper --\n-   --------------------------------\n+   -------------------------\n+   -- Accessibility_Level --\n+   -------------------------\n \n-   function Accessibility_Level_Helper\n-     (Expr   : Node_Id;\n-      Static : Boolean := False) return Node_Id\n+   function Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Node_Id\n    is\n       Loc : constant Source_Ptr := Sloc (Expr);\n \n+      function Accessibility_Level (Expr : Node_Id) return Node_Id\n+        is (Accessibility_Level (Expr, Level, In_Return_Context));\n+      --  Renaming of the enclosing function to facilitate recursive calls\n+\n       function Make_Level_Literal (Level : Uint) return Node_Id;\n       --  Construct an integer literal representing an accessibility level\n       --  with its type set to Natural.\n@@ -295,7 +295,8 @@ package body Sem_Util is\n       --  enclosing dynamic scope (effectively the accessibility\n       --  level of the innermost enclosing master).\n \n-      function Function_Call_Level (Call_Ent : Entity_Id) return Node_Id;\n+      function Function_Call_Or_Allocator_Level\n+        (N : Node_Id) return Node_Id;\n       --  Centralized processing of subprogram calls which may appear in\n       --  prefix notation.\n \n@@ -306,8 +307,9 @@ package body Sem_Util is\n       function Innermost_Master_Scope_Depth\n         (N : Node_Id) return Uint\n       is\n-         Encl_Scop : Entity_Id;\n-         Node_Par  : Node_Id := Parent (N);\n+         Encl_Scop           : Entity_Id;\n+         Node_Par            : Node_Id := Parent (N);\n+         Master_Lvl_Modifier : Int     := 0;\n \n       begin\n          --  Locate the nearest enclosing node (by traversing Parents)\n@@ -319,6 +321,7 @@ package body Sem_Util is\n          --  among other things. These cases are detected properly ???\n \n          while Present (Node_Par) loop\n+\n             if Present (Defining_Entity\n                          (Node_Par, Empty_On_Errors => True))\n             then\n@@ -328,7 +331,7 @@ package body Sem_Util is\n                --  Ignore transient scopes made during expansion\n \n                if Comes_From_Source (Node_Par) then\n-                  return Scope_Depth (Encl_Scop);\n+                  return Scope_Depth (Encl_Scop) + Master_Lvl_Modifier;\n                end if;\n \n             --  For a return statement within a function, return\n@@ -342,15 +345,21 @@ package body Sem_Util is\n               and then Ekind (Current_Scope) = E_Function\n             then\n                return Scope_Depth (Current_Scope);\n+\n+            --  Statements are counted as masters\n+\n+            elsif Is_Master (Node_Par) then\n+               Master_Lvl_Modifier := Master_Lvl_Modifier + 1;\n+\n             end if;\n \n             Node_Par := Parent (Node_Par);\n          end loop;\n \n-         pragma Assert (False);\n-\n          --  Should never reach the following return\n \n+         pragma Assert (False);\n+\n          return Scope_Depth (Current_Scope) + 1;\n       end Innermost_Master_Scope_Depth;\n \n@@ -366,66 +375,102 @@ package body Sem_Util is\n          return Result;\n       end Make_Level_Literal;\n \n-      -------------------------\n-      -- Function_Call_Level --\n-      -------------------------\n+      --------------------------------------\n+      -- Function_Call_Or_Allocator_Level --\n+      --------------------------------------\n \n-      function Function_Call_Level (Call_Ent : Entity_Id) return Node_Id is\n-         Par : Node_Id;\n+      function Function_Call_Or_Allocator_Level (N : Node_Id) return Node_Id is\n+         Par      : Node_Id;\n+         Prev_Par : Node_Id;\n       begin\n          --  Results of functions are objects, so we either get the\n          --  accessibility of the function or, in case of a call which is\n          --  indirect, the level of the access-to-subprogram type.\n \n          --  This code looks wrong ???\n \n-         if Ada_Version < Ada_2005 then\n-            if Is_Entity_Name (Name (Call_Ent)) then\n+         if Nkind (N) = N_Function_Call\n+           and then Ada_Version < Ada_2005\n+         then\n+            if Is_Entity_Name (Name (N)) then\n                return Make_Level_Literal\n-                        (Subprogram_Access_Level (Entity (Name (Call_Ent))));\n+                        (Subprogram_Access_Level (Entity (Name (N))));\n             else\n                return Make_Level_Literal\n-                        (Type_Access_Level (Etype (Prefix (Name (Call_Ent)))));\n+                        (Type_Access_Level (Etype (Prefix (Name (N)))));\n             end if;\n+\n+         --  We ignore coextensions as they cannot be implemented under the\n+         --  \"small-integer\" model.\n+\n+         elsif Nkind (N) = N_Allocator\n+           and then (Is_Static_Coextension (N)\n+                      or else Is_Dynamic_Coextension (N))\n+         then\n+            return Make_Level_Literal\n+                     (Scope_Depth (Standard_Standard));\n          end if;\n \n          --  Named access types have a designated level\n \n-         if Is_Named_Access_Type (Etype (Call_Ent)) then\n-            return Make_Level_Literal (Type_Access_Level (Etype (Call_Ent)));\n+         if Is_Named_Access_Type (Etype (N)) then\n+            return Make_Level_Literal (Type_Access_Level (Etype (N)));\n \n          --  Otherwise, the level is dictated by RM 3.10.2 (10.7/3)\n \n          else\n+            if Nkind (N) = N_Function_Call then\n+               --  Dynamic checks are generated when we are within a return\n+               --  value or we are in a function call within an anonymous\n+               --  access discriminant constraint of a return object (signified\n+               --  by In_Return_Context) on the side of the callee.\n+\n+               --  So, in this case, return library accessibility level to null\n+               --  out the check on the side of the caller.\n+\n+               if In_Return_Value (N)\n+                 or else In_Return_Context\n+               then\n+                  return Make_Level_Literal\n+                           (Subprogram_Access_Level (Current_Subprogram));\n+               end if;\n+            end if;\n+\n             --  Find any relevant enclosing parent nodes that designate an\n             --  object being initialized.\n \n             --  Note: The above is only relevant if the result is used \"in its\n             --  entirety\" as RM 3.10.2 (10.2/3) states. However, this is\n             --  accounted for in the case statement in the main body of\n-            --  Accessibility_Level_Helper for N_Selected_Component.\n-\n-            --  How are we sure, for example, that we are not coming up from,\n-            --  say, the left hand part of an assignment. More verification\n-            --  needed ???\n+            --  Accessibility_Level for N_Selected_Component.\n \n-            Par := Parent (Expr);\n+            Par      := Parent (Expr);\n+            Prev_Par := Empty;\n             while Present (Par) loop\n-               exit when Nkind (Par) in N_Assignment_Statement\n-                                      | N_Object_Declaration\n-                                      | N_Function_Call;\n-               Par := Parent (Par);\n-            end loop;\n+               --  Detect an expanded implicit conversion, typically this\n+               --  occurs on implicitly converted actuals in calls.\n \n-            --  If no object is being initialized then the level is that of the\n-            --  innermost master of the call, according to RM 3.10.2 (10.6/3).\n+               --  Does this catch all implicit conversions ???\n \n-            if No (Par) or else Nkind (Par) = N_Function_Call then\n-               return Make_Level_Literal (Innermost_Master_Scope_Depth (Expr));\n-            end if;\n+               if Nkind (Par) = N_Type_Conversion\n+                 and then Is_Named_Access_Type (Etype (Par))\n+               then\n+                  return Make_Level_Literal\n+                           (Type_Access_Level (Etype (Par)));\n+               end if;\n+\n+               --  Jump out when we hit an object declaration or the right-hand\n+               --  side of an assignment, or a construct such as an aggregate\n+               --  subtype indication which would be the result is not used\n+               --  \"in its entirety.\"\n \n-            --  The function call was used to initialize the entire object, so\n-            --  the master is \"that of the object.\"\n+               exit when Nkind (Par) in N_Object_Declaration\n+                           or else (Nkind (Par) = N_Assignment_Statement\n+                                     and then Name (Par) /= Prev_Par);\n+\n+               Prev_Par := Par;\n+               Par      := Parent (Par);\n+            end loop;\n \n             --  Assignment statements are handled in a similar way in\n             --  accordance to the left-hand part. However, strictly speaking,\n@@ -441,23 +486,24 @@ package body Sem_Util is\n                when N_Assignment_Statement =>\n                   --  Return the accessiblity level of the left-hand part\n \n-                  return Accessibility_Level_Helper (Name (Par), Static);\n-\n-               --  Should never get here\n+                  return Accessibility_Level\n+                           (Expr              => Name (Par),\n+                            Level             => Object_Decl_Level,\n+                            In_Return_Context => In_Return_Context);\n \n                when others =>\n-                  raise Program_Error;\n+                  return Make_Level_Literal\n+                           (Innermost_Master_Scope_Depth (Expr));\n             end case;\n          end if;\n-      end Function_Call_Level;\n+      end Function_Call_Or_Allocator_Level;\n \n       --  Local variables\n \n       E   : Entity_Id := Original_Node (Expr);\n-      Par : Node_Id;\n       Pre : Node_Id;\n \n-   --  Start of processing for Accessibility_Level_Helper\n+   --  Start of processing for Accessibility_Level\n \n    begin\n       --  We could be looking at a reference to a formal due to the expansion\n@@ -493,74 +539,7 @@ package body Sem_Util is\n          --  (14/3).\n \n          when N_Allocator =>\n-            --  Anonymous allocator\n-\n-            if Ekind (Etype (Expr)) = E_Anonymous_Access_Type then\n-               --  Hop up to find a relevant parent node\n-\n-               Par := Parent (Expr);\n-               while Present (Par) loop\n-                  exit when Nkind (Par) in N_Assignment_Statement\n-                                         | N_Object_Declaration\n-                                         | N_Subprogram_Call;\n-                  Par := Parent (Par);\n-               end loop;\n-\n-               --  Handle each of the static cases outlined in RM 3.10.2 (14)\n-\n-               case Nkind (Par) is\n-                  --  For an anonymous allocator whose type is that of a\n-                  --  stand-alone object of an anonymous access-to-object\n-                  --  type, the accessibility level is that of the\n-                  --  declaration of the stand-alone object.\n-\n-                  when N_Object_Declaration =>\n-                     return Make_Level_Literal\n-                              (Scope_Depth\n-                                (Scope (Defining_Identifier (Par))));\n-\n-                  --  In an assignment statement the level is that of the\n-                  --  object at the left-hand side.\n-\n-                  when N_Assignment_Statement =>\n-                     return Make_Level_Literal\n-                              (Scope_Depth\n-                                (Scope (Entity (Name (Par)))));\n-\n-                  --  Subprogram calls have a level one deeper than the\n-                  --  nearest enclosing scope.\n-\n-                  when N_Subprogram_Call =>\n-                     return Make_Level_Literal\n-                              (Innermost_Master_Scope_Depth\n-                                (Parent (Expr)) + 1);\n-\n-                  --  Should never get here\n-\n-                  when others =>\n-                     declare\n-                        S : constant String :=\n-                              Node_Kind'Image (Nkind (Parent (Expr)));\n-                     begin\n-                        Error_Msg_Strlen := S'Length;\n-                        Error_Msg_String (1 .. Error_Msg_Strlen) := S;\n-                        Error_Msg_N\n-                          (\"unsupported context for anonymous allocator (~)\",\n-                           Parent (Expr));\n-                     end;\n-\n-                     --  Return standard in case of error\n-\n-                     return Make_Level_Literal\n-                              (Scope_Depth (Standard_Standard));\n-               end case;\n-\n-            --  Normal case of a named access type\n-\n-            else\n-               return Make_Level_Literal\n-                        (Type_Access_Level (Etype (Expr)));\n-            end if;\n+            return Function_Call_Or_Allocator_Level (E);\n \n          --  We could reach this point for two reasons. Either the expression\n          --  applies to a special attribute ('Loop_Entry, 'Result, or 'Old), or\n@@ -574,7 +553,7 @@ package body Sem_Util is\n             --  prefix.\n \n             if Attribute_Name (E) = Name_Access then\n-               return Accessibility_Level_Helper (Prefix (E), Static);\n+               return Accessibility_Level (Prefix (E));\n \n             --  Unchecked or unrestricted attributes have unlimited depth\n \n@@ -599,11 +578,11 @@ package body Sem_Util is\n                --  Anonymous access types\n \n                elsif Nkind (Pre) in N_Has_Entity\n-                 and then Present (Get_Accessibility (Entity (Pre)))\n-                 and then not Static\n+                 and then Present (Get_Dynamic_Accessibility (Entity (Pre)))\n+                 and then Level = Dynamic_Level\n                then\n                   return New_Occurrence_Of\n-                           (Get_Accessibility (Entity (Pre)), Loc);\n+                           (Get_Dynamic_Accessibility (Entity (Pre)), Loc);\n \n                --  Otherwise the level is treated in a similar way as\n                --  aggregates according to RM 6.1.1 (35.1/4) which concerns\n@@ -624,16 +603,43 @@ package body Sem_Util is\n          --  means we are near the end of our recursive traversal.\n \n          when N_Defining_Identifier =>\n+            --  A dynamic check is performed on the side of the callee when we\n+            --  are within a return statement, so return a library-level\n+            --  accessibility level to null out checks on the side of the\n+            --  caller.\n+\n+            if Is_Explicitly_Aliased (E)\n+              and then Level /= Dynamic_Level\n+              and then (In_Return_Value (Expr)\n+                         or else In_Return_Context)\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n+            --  Something went wrong and an extra accessibility formal has not\n+            --  been generated when one should have ???\n+\n+            elsif Is_Formal (E)\n+              and then not Present (Get_Dynamic_Accessibility (E))\n+              and then Ekind (Etype (E)) = E_Anonymous_Access_Type\n+            then\n+               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n+\n             --  Stand-alone object of an anonymous access type \"SAOAAT\"\n \n-            if (Is_Formal (E)\n-                 or else Ekind (E) in E_Variable\n-                                    | E_Constant)\n-              and then Present (Get_Accessibility (E))\n-              and then not Static\n+            elsif (Is_Formal (E)\n+                    or else Ekind (E) in E_Variable\n+                                       | E_Constant)\n+              and then Present (Get_Dynamic_Accessibility (E))\n+              and then (Level = Dynamic_Level\n+                         or else Level = Zero_On_Dynamic_Level)\n             then\n+               if Level = Zero_On_Dynamic_Level then\n+                  return Make_Level_Literal\n+                           (Scope_Depth (Standard_Standard));\n+               end if;\n+\n                return\n-                 New_Occurrence_Of (Get_Accessibility (E), Loc);\n+                 New_Occurrence_Of (Get_Dynamic_Accessibility (E), Loc);\n \n             --  Initialization procedures have a special extra accessitility\n             --  parameter associated with the level at which the object\n@@ -647,14 +653,6 @@ package body Sem_Util is\n                return New_Occurrence_Of\n                         (Init_Proc_Level_Formal (Current_Scope), Loc);\n \n-            --  Extra accessibility has not been added yet, but the formal\n-            --  needs one. So return Standard_Standard ???\n-\n-            elsif Ekind (Etype (E)) = E_Anonymous_Access_Type\n-              and then Static\n-            then\n-               return Make_Level_Literal (Scope_Depth (Standard_Standard));\n-\n             --  Current instance of the type is deeper than that of the type\n             --  according to RM 3.10.2 (21).\n \n@@ -669,8 +667,7 @@ package body Sem_Util is\n             elsif Present (Renamed_Object (E))\n               and then Comes_From_Source (Renamed_Object (E))\n             then\n-               return Accessibility_Level_Helper\n-                        (Renamed_Object (E), Static);\n+               return Accessibility_Level (Renamed_Object (E));\n \n             --  Named access types get their level from their associated type\n \n@@ -705,11 +702,18 @@ package body Sem_Util is\n          when N_Indexed_Component | N_Selected_Component =>\n             Pre := Original_Node (Prefix (E));\n \n+            --  When E is an indexed component or selected component and\n+            --  the current Expr is a function call, we know that we are\n+            --  looking at an expanded call in prefix notation.\n+\n+            if Nkind (Expr) = N_Function_Call then\n+               return Function_Call_Or_Allocator_Level (Expr);\n+\n             --  If the prefix is a named access type, then we are dealing\n             --  with an implicit deferences. In that case the level is that\n             --  of the named access type in the prefix.\n \n-            if Is_Named_Access_Type (Etype (Pre)) then\n+            elsif Is_Named_Access_Type (Etype (Pre)) then\n                return Make_Level_Literal\n                         (Type_Access_Level (Etype (Pre)));\n \n@@ -764,13 +768,29 @@ package body Sem_Util is\n             elsif Nkind (Pre) = N_Function_Call\n               and then not Is_Named_Access_Type (Etype (Pre))\n             then\n+               --  Dynamic checks are generated when we are within a return\n+               --  value or we are in a function call within an anonymous\n+               --  access discriminant constraint of a return object (signified\n+               --  by In_Return_Context) on the side of the callee.\n+\n+               --  So, in this case, return a library accessibility level to\n+               --  null out the check on the side of the caller.\n+\n+               if (In_Return_Value (E)\n+                    or else In_Return_Context)\n+                 and then Level /= Dynamic_Level\n+               then\n+                  return Make_Level_Literal\n+                           (Scope_Depth (Standard_Standard));\n+               end if;\n+\n                return Make_Level_Literal\n                         (Innermost_Master_Scope_Depth (Expr));\n \n             --  Otherwise, continue recursing over the expression prefixes\n \n             else\n-               return Accessibility_Level_Helper (Prefix (E), Static);\n+               return Accessibility_Level (Prefix (E));\n             end if;\n \n          --  Qualified expressions\n@@ -780,13 +800,13 @@ package body Sem_Util is\n                return Make_Level_Literal\n                         (Type_Access_Level (Etype (E)));\n             else\n-               return Accessibility_Level_Helper (Expression (E), Static);\n+               return Accessibility_Level (Expression (E));\n             end if;\n \n          --  Handle function calls\n \n          when N_Function_Call =>\n-            return Function_Call_Level (E);\n+            return Function_Call_Or_Allocator_Level (E);\n \n          --  Explicit dereference accessibility level calculation\n \n@@ -802,7 +822,7 @@ package body Sem_Util is\n             --  Otherwise, recurse deeper\n \n             else\n-               return Accessibility_Level_Helper (Prefix (E), Static);\n+               return Accessibility_Level (Prefix (E));\n             end if;\n \n          --  Type conversions\n@@ -817,7 +837,7 @@ package body Sem_Util is\n             if Is_View_Conversion (E)\n               or else Ekind (Etype (E)) = E_Anonymous_Access_Type\n             then\n-               return Accessibility_Level_Helper (Expression (E), Static);\n+               return Accessibility_Level (Expression (E));\n \n             --  We don't care about the master if we are looking at a named\n             --  access type.\n@@ -833,7 +853,7 @@ package body Sem_Util is\n             --  Should use Innermost_Master_Scope_Depth ???\n \n             else\n-               return Accessibility_Level_Helper (Current_Scope, Static);\n+               return Accessibility_Level (Current_Scope);\n             end if;\n \n          --  Default to the type accessibility level for the type of the\n@@ -842,7 +862,21 @@ package body Sem_Util is\n          when others =>\n             return Make_Level_Literal (Type_Access_Level (Etype (E)));\n       end case;\n-   end Accessibility_Level_Helper;\n+   end Accessibility_Level;\n+\n+   --------------------------------\n+   -- Static_Accessibility_Level --\n+   --------------------------------\n+\n+   function Static_Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Static_Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Uint\n+   is\n+   begin\n+      return Intval\n+               (Accessibility_Level (Expr, Level, In_Return_Context));\n+   end Static_Accessibility_Level;\n \n    ----------------------------------\n    -- Acquire_Warning_Match_String --\n@@ -902,7 +936,6 @@ package body Sem_Util is\n \n    procedure Add_Block_Identifier (N : Node_Id; Id : out Entity_Id) is\n       Loc : constant Source_Ptr := Sloc (N);\n-\n    begin\n       pragma Assert (Nkind (N) = N_Block_Statement);\n \n@@ -5473,8 +5506,9 @@ package body Sem_Util is\n          if Present (Pref_Encl_Typ)\n            and then No (Cont_Encl_Typ)\n            and then Is_Public_Operation\n-           and then Scope_Depth (Pref_Encl_Typ) >=\n-                                       Static_Accessibility_Level (Context)\n+           and then Scope_Depth (Pref_Encl_Typ)\n+                      >= Static_Accessibility_Level\n+                           (Context, Object_Decl_Level)\n          then\n             Error_Msg_N\n               (\"??possible unprotected access to protected data\", Expr);\n@@ -7669,15 +7703,6 @@ package body Sem_Util is\n       Analyze (N);\n    end Diagnose_Iterated_Component_Association;\n \n-   ---------------------------------\n-   -- Dynamic_Accessibility_Level --\n-   ---------------------------------\n-\n-   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id is\n-   begin\n-      return Accessibility_Level_Helper (Expr);\n-   end Dynamic_Accessibility_Level;\n-\n    ------------------------\n    -- Discriminated_Size --\n    ------------------------\n@@ -10174,11 +10199,11 @@ package body Sem_Util is\n       end if;\n    end Gather_Components;\n \n-   -----------------------\n-   -- Get_Accessibility --\n-   -----------------------\n+   -------------------------------\n+   -- Get_Dynamic_Accessibility --\n+   -------------------------------\n \n-   function Get_Accessibility (E : Entity_Id) return Entity_Id is\n+   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id is\n    begin\n       --  When minimum accessibility is set for E then we utilize it - except\n       --  in a few edge cases like the expansion of select statements where\n@@ -10196,7 +10221,7 @@ package body Sem_Util is\n       end if;\n \n       return Extra_Accessibility (E);\n-   end Get_Accessibility;\n+   end Get_Dynamic_Accessibility;\n \n    ------------------------\n    -- Get_Actual_Subtype --\n@@ -11394,6 +11419,31 @@ package body Sem_Util is\n       end if;\n    end Has_Access_Values;\n \n+   ---------------------------------------\n+   -- Has_Anonymous_Access_Discriminant --\n+   ---------------------------------------\n+\n+   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean\n+   is\n+      Disc : Node_Id;\n+\n+   begin\n+      if not Has_Discriminants (Typ) then\n+         return False;\n+      end if;\n+\n+      Disc := First_Discriminant (Typ);\n+      while Present (Disc) loop\n+         if Ekind (Etype (Disc)) = E_Anonymous_Access_Type then\n+            return True;\n+         end if;\n+\n+         Next_Discriminant (Disc);\n+      end loop;\n+\n+      return False;\n+   end Has_Anonymous_Access_Discriminant;\n+\n    ------------------------------\n    -- Has_Compatible_Alignment --\n    ------------------------------\n@@ -12554,6 +12604,18 @@ package body Sem_Util is\n            (Directly_Designated_Type (Etype (Formal))) = E;\n    end Is_Access_Subprogram_Wrapper;\n \n+   ---------------------------\n+   -- Is_Explicitly_Aliased --\n+   ---------------------------\n+\n+   function Is_Explicitly_Aliased (N : Node_Id) return Boolean is\n+   begin\n+      return Is_Formal (N)\n+               and then Present (Parent (N))\n+               and then Nkind (Parent (N)) = N_Parameter_Specification\n+               and then Aliased_Present (Parent (N));\n+   end Is_Explicitly_Aliased;\n+\n    ----------------------------\n    -- Is_Container_Aggregate --\n    ----------------------------\n@@ -14155,6 +14217,96 @@ package body Sem_Util is\n       return False;\n    end In_Subtree;\n \n+   ---------------------\n+   -- In_Return_Value --\n+   ---------------------\n+\n+   function In_Return_Value (Expr : Node_Id) return Boolean is\n+      Par              : Node_Id;\n+      Prev_Par         : Node_Id;\n+      Pre              : Node_Id;\n+      In_Function_Call : Boolean := False;\n+\n+   begin\n+      --  Move through parent nodes to determine if Expr contributes to the\n+      --  return value of the current subprogram.\n+\n+      Par      := Expr;\n+      Prev_Par := Empty;\n+      while Present (Par) loop\n+\n+         case Nkind (Par) is\n+            --  Ignore ranges and they don't contribute to the result\n+\n+            when N_Range =>\n+               return False;\n+\n+            --  An object declaration whose parent is an extended return\n+            --  statement is a return object.\n+\n+            when N_Object_Declaration =>\n+               if Present (Parent (Par))\n+                 and then Nkind (Parent (Par)) = N_Extended_Return_Statement\n+               then\n+                  return True;\n+               end if;\n+\n+            --  We hit a simple return statement, so we know we are in one\n+\n+            when N_Simple_Return_Statement =>\n+               return True;\n+\n+            --  Only include one nexting level of function calls\n+\n+            when N_Function_Call =>\n+               if not In_Function_Call then\n+                  In_Function_Call := True;\n+               else\n+                  return False;\n+               end if;\n+\n+            --  Check if we are on the right-hand side of an assignment\n+            --  statement to a return object.\n+\n+            --  This is not specified in the RM ???\n+\n+            when N_Assignment_Statement =>\n+               if Prev_Par = Name (Par) then\n+                  return False;\n+               end if;\n+\n+               Pre := Name (Par);\n+               while Present (Pre) loop\n+                  if Is_Entity_Name (Pre)\n+                    and then Is_Return_Object (Entity (Pre))\n+                  then\n+                     return True;\n+                  end if;\n+\n+                  exit when Nkind (Pre) not in N_Selected_Component\n+                                             | N_Indexed_Component\n+                                             | N_Slice;\n+\n+                  Pre := Prefix (Pre);\n+               end loop;\n+\n+            --  Otherwise, we hit a master which was not relevant\n+\n+            when others =>\n+               if Is_Master (Par) then\n+                  return False;\n+               end if;\n+         end case;\n+\n+         --  Iterate up to the next parent, keeping track of the previous one\n+\n+         Prev_Par := Par;\n+         Par      := Parent (Par);\n+      end loop;\n+\n+      return False;\n+   end In_Return_Value;\n+\n    ---------------------\n    -- In_Visible_Part --\n    ---------------------\n@@ -17438,6 +17590,62 @@ package body Sem_Util is\n       end if;\n    end Is_Local_Variable_Reference;\n \n+   ---------------\n+   -- Is_Master --\n+   ---------------\n+\n+   function Is_Master (N : Node_Id) return Boolean is\n+      Disable_Subexpression_Masters : constant Boolean := True;\n+\n+   begin\n+      if Nkind (N) in N_Subprogram_Body | N_Task_Body | N_Entry_Body\n+        or else Is_Statement (N)\n+      then\n+         return True;\n+      end if;\n+\n+      --  We avoid returning True when the master is a subexpression described\n+      --  in RM 7.6.1(3/2) for the proposes of accessibility level calculation\n+      --  in Accessibility_Level_Helper.Innermost_Master_Scope_Depth ???\n+\n+      if not Disable_Subexpression_Masters\n+        and then Nkind (N) in N_Subexpr\n+      then\n+         declare\n+            Par : Node_Id := N;\n+\n+            subtype N_Simple_Statement_Other_Than_Simple_Return\n+              is Node_Kind with Static_Predicate =>\n+                N_Simple_Statement_Other_Than_Simple_Return\n+                  in N_Abort_Statement\n+                   | N_Assignment_Statement\n+                   | N_Code_Statement\n+                   | N_Delay_Statement\n+                   | N_Entry_Call_Statement\n+                   | N_Free_Statement\n+                   | N_Goto_Statement\n+                   | N_Null_Statement\n+                   | N_Raise_Statement\n+                   | N_Requeue_Statement\n+                   | N_Exit_Statement\n+                   | N_Procedure_Call_Statement;\n+         begin\n+            while Present (Par) loop\n+               Par := Parent (Par);\n+               if Nkind (Par) in N_Subexpr |\n+                 N_Simple_Statement_Other_Than_Simple_Return\n+               then\n+                  return False;\n+               end if;\n+            end loop;\n+\n+            return True;\n+         end;\n+      end if;\n+\n+      return False;\n+   end Is_Master;\n+\n    -----------------------\n    -- Is_Name_Reference --\n    -----------------------\n@@ -19609,16 +19817,20 @@ package body Sem_Util is\n    --------------------------------------\n \n    function Is_Special_Aliased_Formal_Access\n-     (Exp  : Node_Id;\n-      Scop : Entity_Id) return Boolean is\n+     (Exp               : Node_Id;\n+      In_Return_Context : Boolean := False) return Boolean\n+   is\n+      Scop : constant Entity_Id := Current_Subprogram;\n    begin\n       --  Verify the expression is an access reference to 'Access within a\n       --  return statement as this is the only time an explicitly aliased\n       --  formal has different semantics.\n \n       if Nkind (Exp) /= N_Attribute_Reference\n         or else Get_Attribute_Id (Attribute_Name (Exp)) /= Attribute_Access\n-        or else Nkind (Parent (Exp)) /= N_Simple_Return_Statement\n+        or else not (In_Return_Value (Exp)\n+                      or else In_Return_Context)\n+        or else not Needs_Result_Accessibility_Level (Scop)\n       then\n          return False;\n       end if;\n@@ -19628,17 +19840,8 @@ package body Sem_Util is\n       --  that Scop returns an anonymous access type, otherwise the special\n       --  rules dictating a need for a dynamic check are not in effect.\n \n-      declare\n-         P_Ult : constant Node_Id := Ultimate_Prefix (Prefix (Exp));\n-      begin\n-         return Is_Entity_Name (P_Ult)\n-           and then Is_Aliased (Entity (P_Ult))\n-           and then Is_Formal  (Entity (P_Ult))\n-           and then Scope (Entity (P_Ult)) = Scop\n-           and then Ekind (Scop) in\n-                      E_Function | E_Operator | E_Subprogram_Type\n-           and then Needs_Result_Accessibility_Level (Scop);\n-      end;\n+      return Is_Entity_Name (Prefix (Exp))\n+               and then Is_Explicitly_Aliased (Entity (Prefix (Exp)));\n    end Is_Special_Aliased_Formal_Access;\n \n    -----------------------------\n@@ -27637,15 +27840,6 @@ package body Sem_Util is\n       return Result;\n    end Should_Ignore_Pragma_Sem;\n \n-   --------------------------------\n-   -- Static_Accessibility_Level --\n-   --------------------------------\n-\n-   function Static_Accessibility_Level (Expr : Node_Id) return Uint is\n-   begin\n-      return Intval (Accessibility_Level_Helper (Expr, Static => True));\n-   end Static_Accessibility_Level;\n-\n    --------------------\n    -- Static_Boolean --\n    --------------------"}, {"sha": "1b993f9cc9e63d792cfe298a9641053721c54e15", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 65, "deletions": 12, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66e97274cef35ed40584c7a09096fffa061fddf0/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=66e97274cef35ed40584c7a09096fffa061fddf0", "patch": "@@ -43,6 +43,36 @@ package Sem_Util is\n    --  including the cases where there can't be any because e.g. the type is\n    --  not tagged.\n \n+   type Accessibility_Level_Kind is\n+     (Dynamic_Level,\n+      Object_Decl_Level,\n+      Zero_On_Dynamic_Level);\n+   --  Accessibility_Level_Kind is an enumerated type which captures the\n+   --  different modes in which an accessibility level could be obtained for\n+   --  a given expression.\n+\n+   --  When in the context of the function Accessibility_Level,\n+   --  Accessibility_Level_Kind signals what type of accessibility level to\n+   --  obtain. For example, when Level is Dynamic_Level, a defining identifier\n+   --  associated with a SAOOAAT may be returned or an N_Integer_Literal node.\n+   --  When the level is Object_Decl_Level, an N_Integer_Literal node is\n+   --  returned containing the level of the declaration of the object if\n+   --  relevant (be it a SAOOAAT or otherwise). Finally, Zero_On_Dynamic_Level\n+   --  returns library level for all cases where the accessibility level is\n+   --  dynamic (used to bypass static accessibility checks in dynamic cases).\n+\n+   function Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Node_Id;\n+   --  Centralized accessibility level calculation routine for finding the\n+   --  accessibility level of a given expression Expr.\n+\n+   --  In_Return_Context forcing the Accessibility_Level calculations to be\n+   --  carried out \"as if\" Expr existed in a return value. This is useful for\n+   --  calculating the accessibility levels for discriminant associations\n+   --  and return aggregates.\n+\n    function Acquire_Warning_Match_String (Str_Lit : Node_Id) return String;\n    --  Used by pragma Warnings (Off, string), and Warn_As_Error (string) to get\n    --  the given string argument, adding leading and trailing asterisks if they\n@@ -704,12 +734,6 @@ package Sem_Util is\n    --  private components of protected objects, but is generally useful when\n    --  restriction No_Implicit_Heap_Allocation is active.\n \n-   function Dynamic_Accessibility_Level (Expr : Node_Id) return Node_Id;\n-   --  Expr should be an expression of an access type. Builds an integer\n-   --  literal except in cases involving anonymous access types, where\n-   --  accessibility levels are tracked at run time (access parameters and\n-   --  stand-alone objects of anonymous access types).\n-\n    function Effective_Extra_Accessibility (Id : Entity_Id) return Entity_Id;\n    --  Same as Einfo.Extra_Accessibility except thtat object renames\n    --  are looked through.\n@@ -1054,7 +1078,7 @@ package Sem_Util is\n    --  discriminants. Otherwise all components of the parent must be included\n    --  in the subtype for semantic analysis.\n \n-   function Get_Accessibility (E : Entity_Id) return Entity_Id;\n+   function Get_Dynamic_Accessibility (E : Entity_Id) return Entity_Id;\n    --  Obtain the accessibility level for a given entity formal taking into\n    --  account both extra and minimum accessibility.\n \n@@ -1282,6 +1306,9 @@ package Sem_Util is\n    --  as an access type internally, this function tests only for access types\n    --  known to the programmer. See also Has_Tagged_Component.\n \n+   function Has_Anonymous_Access_Discriminant (Typ : Entity_Id) return Boolean;\n+   --  Returns True if Typ has one or more anonymous access discriminants\n+\n    type Alignment_Result is (Known_Compatible, Unknown, Known_Incompatible);\n    --  Result of Has_Compatible_Alignment test, description found below. Note\n    --  that the values are arranged in increasing order of problematicness.\n@@ -1410,6 +1437,20 @@ package Sem_Util is\n    --  Return True if the loop has no side effect and can therefore be\n    --  marked for removal. Return False if N is not a N_Loop_Statement.\n \n+   subtype Static_Accessibility_Level_Kind\n+     is Accessibility_Level_Kind range Object_Decl_Level\n+                                         .. Zero_On_Dynamic_Level;\n+   --  Restrict the reange of Accessibility_Level_Kind to be non-dynamic for\n+   --  use in the static version of Accessibility_Level below.\n+\n+   function Static_Accessibility_Level\n+     (Expr              : Node_Id;\n+      Level             : Static_Accessibility_Level_Kind;\n+      In_Return_Context : Boolean := False) return Uint;\n+   --  Overloaded version of Accessibility_Level which returns a universal\n+   --  integer for use in compile-time checking. Note: Level is restricted to\n+   --  be non-dynamic.\n+\n    function Has_Overriding_Initialize (T : Entity_Id) return Boolean;\n    --  Predicate to determine whether a controlled type has a user-defined\n    --  Initialize primitive (and, in Ada 2012, whether that primitive is\n@@ -1531,6 +1572,11 @@ package Sem_Util is\n    function In_Quantified_Expression (N : Node_Id) return Boolean;\n    --  Returns true if the expression N occurs within a quantified expression\n \n+   function In_Return_Value (Expr : Node_Id) return Boolean;\n+   --  Returns true if the expression Expr occurs within a simple return\n+   --  statement or is part of an assignment to the return object in an\n+   --  extended return statement.\n+\n    function In_Reverse_Storage_Order_Object (N : Node_Id) return Boolean;\n    --  Returns True if N denotes a component or subcomponent in a record or\n    --  array that has Reverse_Storage_Order.\n@@ -1872,6 +1918,9 @@ package Sem_Util is\n    function Is_Entry_Declaration (Id : Entity_Id) return Boolean;\n    --  Determine whether entity Id is the spec entity of an entry [family]\n \n+   function Is_Explicitly_Aliased (N : Node_Id) return Boolean;\n+   --  Determine if a given node N is an explicitly aliased formal parameter.\n+\n    function Is_Expanded_Priority_Attribute (E : Entity_Id) return Boolean;\n    --  Check whether a function in a call is an expanded priority attribute,\n    --  which is transformed into an Rtsfind call to Get_Ceiling. This expansion\n@@ -1984,6 +2033,9 @@ package Sem_Util is\n    --  parameter of the current enclosing subprogram.\n    --  Why are OUT parameters not considered here ???\n \n+   function Is_Master (N : Node_Id) return Boolean;\n+   --  Determine if the given node N constitutes a finalization master\n+\n    function Is_Name_Reference (N : Node_Id) return Boolean;\n    --  Determine whether arbitrary node N is a reference to a name. This is\n    --  similar to Is_Object_Reference but returns True only if N can be renamed\n@@ -2144,11 +2196,15 @@ package Sem_Util is\n    --  created for a single task type.\n \n    function Is_Special_Aliased_Formal_Access\n-     (Exp  : Node_Id;\n-      Scop : Entity_Id) return Boolean;\n+     (Exp               : Node_Id;\n+      In_Return_Context : Boolean := False) return Boolean;\n    --  Determines whether a dynamic check must be generated for explicitly\n    --  aliased formals within a function Scop for the expression Exp.\n \n+   --  In_Return_Context forces Is_Special_Aliased_Formal_Access to assume\n+   --  that Exp is within a return value which is useful for checking\n+   --  expressions within discriminant associations of return objects.\n+\n    --  More specially, Is_Special_Aliased_Formal_Access checks that Exp is a\n    --  'Access attribute reference within a return statement where the ultimate\n    --  prefix is an aliased formal of Scop and that Scop returns an anonymous\n@@ -2648,9 +2704,6 @@ package Sem_Util is\n    --  is known at compile time. If the bounds are not known at compile time,\n    --  the function returns the value zero.\n \n-   function Static_Accessibility_Level (Expr : Node_Id) return Uint;\n-   --  Return the numeric accessibility level of the expression Expr\n-\n    function Original_Aspect_Pragma_Name (N : Node_Id) return Name_Id;\n    --  Retrieve the name of aspect or pragma N, taking into account a possible\n    --  rewrite and whether the pragma is generated from an aspect as the names"}]}