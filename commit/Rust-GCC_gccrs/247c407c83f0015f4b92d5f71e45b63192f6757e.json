{"sha": "247c407c83f0015f4b92d5f71e45b63192f6757e", "node_id": "C_kwDOANBUbNoAKDI0N2M0MDdjODNmMDAxNWY0YjkyZDVmNzFlNDViNjMxOTJmNjc1N2U", "commit": {"author": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-18T11:15:40Z"}, "committer": {"name": "Roger Sayle", "email": "roger@nextmovesoftware.com", "date": "2021-10-18T11:18:00Z"}, "message": "Try placing RTL folded constants in the constant pool.\n\nMy recent attempts to come up with a testcase for my patch to evaluate\nss_plus in simplify-rtx.c, identified a missed optimization opportunity\n(that's potentially a long-time regression): The RTL optimizers no longer\nplace constants in the constant pool.\n\nThe motivating x86_64 example is the simple program:\n\ntypedef char v8qi __attribute__ ((vector_size (8)));\n\nv8qi foo()\n{\n  v8qi tx = { 1, 0, 0, 0, 0, 0, 0, 0 };\n  v8qi ty = { 2, 0, 0, 0, 0, 0, 0, 0 };\n  v8qi t = __builtin_ia32_paddsb(tx, ty);\n  return t;\n}\n\nwhich (with my previous patch) currently results in:\nfoo:\tmovq    .LC0(%rip), %xmm0\n        movq    .LC1(%rip), %xmm1\n        paddsb  %xmm1, %xmm0\n        ret\n\neven though the RTL contains the result in a REG_EQUAL note:\n\n(insn 7 6 12 2 (set (reg:V8QI 83)\n        (ss_plus:V8QI (reg:V8QI 84)\n            (reg:V8QI 85))) \"ssaddqi3.c\":7:12 1419 {*mmx_ssaddv8qi3}\n     (expr_list:REG_DEAD (reg:V8QI 85)\n        (expr_list:REG_DEAD (reg:V8QI 84)\n            (expr_list:REG_EQUAL (const_vector:V8QI [\n                        (const_int 3 [0x3])\n                        (const_int 0 [0]) repeated x7\n                    ])\n                (nil)))))\n\nTogether with the patch below, GCC will now generate the much\nmore sensible:\nfoo:\tmovq    .LC2(%rip), %xmm0\n        ret\n\nMy first approach was to look in cse.c (where the REG_EQUAL note gets\nadded) and notice that the constant pool handling functionality has been\nunreachable for a while.  A quick search for constant_pool_entries_cost\nshows that it's initialized to zero, but never set to a non-zero value,\nmeaning that force_const_mem is never called.  This functionality used\nto work way back in 2003, but has been lost over time:\nhttps://gcc.gnu.org/pipermail/gcc-patches/2003-October/116435.html\n\nThe changes to cse.c below restore this functionality (placing suitable\nconstants in the constant pool) with two significant refinements;\n(i) it only attempts to do this if the function already uses a constant\npool (thanks to the availability of crtl->uses_constant_pool since 2003).\n(ii) it allows different constants (i.e. modes) to have different costs,\nso that floating point \"doubles\" and 64-bit, 128-bit, 256-bit and 512-bit\nvectors don't all have the share the same cost.  Back in 2003, the\nassumption was that everything in a constant pool had the same\ncost, hence the global variable constant_pool_entries_cost.\n\nAlthough this is a useful CSE fix, it turns out that it doesn't cure\nmy motivating problem above.  CSE only considers a single instruction,\nso determines that it's cheaper to perform the ss_plus (COSTS_N_INSNS(1))\nthan read the result from the constant pool (COSTS_N_INSNS(2)).  It's\nonly when the other reads from the constant pool are also eliminated,\nthat this transformation is a win.  Hence a better place to perform\nthis transformation is in combine, where after failing to \"recog\" the\nload of a suitable constant, it can retry after calling force_const_mem.\nThis achieves the desired transformation and allows the backend insn_cost\ncall-back to control whether or not using the constant pool is preferrable.\n\nAlas, it's rare to change code generation without affecting something in\nGCC's testsuite.  On x86_64-pc-linux-gnu there were two families of new\nfailures (and I'd predict similar benign fallout on other platforms).\nOne failure was gcc.target/i386/387-12.c (aka PR target/26915), where\nthe test is missing an explicit -m32 flag.  On i686, it's very reasonable\nto materialize -1.0 using \"fld1; fchs\", but on x86_64-pc-linux-gnu we\ncurrently generate the awkward:\ntestm1: fld1\n        fchs\n        fstpl   -8(%rsp)\n        movsd   -8(%rsp), %xmm0\n        ret\n\nwhich combine now very reasonably simplifies to just:\ntestm1: movsd   .LC3(%rip), %xmm0\n\tret\n\nThe other class of x86_64-pc-linux-gnu failure was from materialization\nof vector constants using vpbroadcast (e.g. gcc.target/i386/pr90773-17.c)\nwhere the decision is finely balanced; the load of an integer register\nwith an immediate constant, followed by a vpbroadcast is deemed to be\nCOSTS_N_INSNS(2), whereas a load from the constant pool is also reported\nas COSTS_N_INSNS(2).  My solution is to tweak the i386.c's rtx_costs\nso that all other things being equal, an instruction (sequence) that\naccesses memory is fractionally more expensive than one that doesn't.\n\n2021-10-18  Roger Sayle  <roger@nextmovesoftware.com>\n\ngcc/ChangeLog\n\t* combine.c (recog_for_combine): For an unrecognized move/set of\n\ta constant, try force_const_mem to place it in the constant pool.\n\t* cse.c (constant_pool_entries_cost, constant_pool_entries_regcost):\n\tDelete global variables (that are no longer assigned a cost value).\n\t(cse_insn): Simplify logic for deciding whether to place a folded\n\tconstant in the constant pool using force_const_mem.\n\t(cse_main): Remove zero initialization of constant_pool_entries_cost\n\tand constant_pool_entries_regcost.\n\n\t* config/i386/i386.c (ix86_rtx_costs): Make memory accesses\n\tfractionally more expensive, when optimizing for speed.\n\ngcc/testsuite/ChangeLog\n\t* gcc.target/i386/387-12.c: Add explicit -m32 option.", "tree": {"sha": "8203d4eeab5b3e00e2981babbf0d4f37270ac4f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8203d4eeab5b3e00e2981babbf0d4f37270ac4f8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/247c407c83f0015f4b92d5f71e45b63192f6757e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247c407c83f0015f4b92d5f71e45b63192f6757e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/247c407c83f0015f4b92d5f71e45b63192f6757e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/247c407c83f0015f4b92d5f71e45b63192f6757e/comments", "author": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rogersayle", "id": 13512313, "node_id": "MDQ6VXNlcjEzNTEyMzEz", "avatar_url": "https://avatars.githubusercontent.com/u/13512313?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rogersayle", "html_url": "https://github.com/rogersayle", "followers_url": "https://api.github.com/users/rogersayle/followers", "following_url": "https://api.github.com/users/rogersayle/following{/other_user}", "gists_url": "https://api.github.com/users/rogersayle/gists{/gist_id}", "starred_url": "https://api.github.com/users/rogersayle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rogersayle/subscriptions", "organizations_url": "https://api.github.com/users/rogersayle/orgs", "repos_url": "https://api.github.com/users/rogersayle/repos", "events_url": "https://api.github.com/users/rogersayle/events{/privacy}", "received_events_url": "https://api.github.com/users/rogersayle/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "815f15d3384edbdd73cc54536f30947e15183151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815f15d3384edbdd73cc54536f30947e15183151", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815f15d3384edbdd73cc54536f30947e15183151"}], "stats": {"total": 79, "additions": 43, "deletions": 36}, "files": [{"sha": "03e9a7809193fd882203997b15a5e0a15609626d", "filename": "gcc/combine.c", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=247c407c83f0015f4b92d5f71e45b63192f6757e", "patch": "@@ -11567,7 +11567,27 @@ recog_for_combine (rtx *pnewpat, rtx_insn *insn, rtx *pnotes)\n   bool changed = false;\n \n   if (GET_CODE (pat) == SET)\n-    changed = change_zero_ext (pat);\n+    {\n+      /* For an unrecognized single set of a constant, try placing it in\n+\t the constant pool, if this function already uses one.  */\n+      rtx src = SET_SRC (pat);\n+      if (CONSTANT_P (src)\n+\t  && !CONST_INT_P (src)\n+\t  && crtl->uses_const_pool)\n+\t{\n+\t  machine_mode mode = GET_MODE (src);\n+\t  if (mode == VOIDmode)\n+\t    mode = GET_MODE (SET_DEST (pat));\n+\t  src = force_const_mem (mode, src);\n+\t  if (src)\n+\t    {\n+\t      SUBST (SET_SRC (pat), src);\n+\t      changed = true;\n+\t    }\n+\t}\n+      else\n+\tchanged = change_zero_ext (pat);\n+    }\n   else if (GET_CODE (pat) == PARALLEL)\n     {\n       int i;"}, {"sha": "3c3336d230a2cf33fd1009986d833d903e944e9d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=247c407c83f0015f4b92d5f71e45b63192f6757e", "patch": "@@ -20801,6 +20801,13 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t*total = cost->sse_op;\n       return true;\n \n+    case MEM:\n+      /* An insn that accesses memory is slightly more expensive\n+         than one that does not.  */\n+      if (speed)\n+        *total += 1;\n+      return false;\n+\n     default:\n       return false;\n     }"}, {"sha": "4c3988ee430e99cff74c32cdf9b6382505edd415", "filename": "gcc/cse.c", "status": "modified", "additions": 14, "deletions": 34, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=247c407c83f0015f4b92d5f71e45b63192f6757e", "patch": "@@ -491,14 +491,6 @@ static struct table_elt *table[HASH_SIZE];\n \n static struct table_elt *free_element_chain;\n \n-/* Set to the cost of a constant pool reference if one was found for a\n-   symbolic constant.  If this was found, it means we should try to\n-   convert constants into constant pool entries if they don't fit in\n-   the insn.  */\n-\n-static int constant_pool_entries_cost;\n-static int constant_pool_entries_regcost;\n-\n /* Trace a patch through the CFG.  */\n \n struct branch_path\n@@ -4609,9 +4601,6 @@ cse_insn (rtx_insn *insn)\n       int src_folded_regcost = MAX_COST;\n       int src_related_regcost = MAX_COST;\n       int src_elt_regcost = MAX_COST;\n-      /* Set nonzero if we need to call force_const_mem on with the\n-\t contents of src_folded before using it.  */\n-      int src_folded_force_flag = 0;\n       scalar_int_mode int_mode;\n \n       dest = SET_DEST (sets[i].rtl);\n@@ -5166,15 +5155,7 @@ cse_insn (rtx_insn *insn)\n \t\t\t     src_related_cost, src_related_regcost) <= 0\n \t      && preferable (src_folded_cost, src_folded_regcost,\n \t\t\t     src_elt_cost, src_elt_regcost) <= 0)\n-\t    {\n-\t      trial = src_folded, src_folded_cost = MAX_COST;\n-\t      if (src_folded_force_flag)\n-\t\t{\n-\t\t  rtx forced = force_const_mem (mode, trial);\n-\t\t  if (forced)\n-\t\t    trial = forced;\n-\t\t}\n-\t    }\n+\t    trial = src_folded, src_folded_cost = MAX_COST;\n \t  else if (src\n \t\t   && preferable (src_cost, src_regcost,\n \t\t\t\t  src_eqv_cost, src_eqv_regcost) <= 0\n@@ -5361,23 +5342,24 @@ cse_insn (rtx_insn *insn)\n \t      break;\n \t    }\n \n-\t  /* If we previously found constant pool entries for\n-\t     constants and this is a constant, try making a\n-\t     pool entry.  Put it in src_folded unless we already have done\n-\t     this since that is where it likely came from.  */\n+\t  /* If the current function uses a constant pool and this is a\n+\t     constant, try making a pool entry. Put it in src_folded\n+\t     unless we already have done this since that is where it\n+\t     likely came from.  */\n \n-\t  else if (constant_pool_entries_cost\n+\t  else if (crtl->uses_const_pool\n \t\t   && CONSTANT_P (trial)\n-\t\t   && (src_folded == 0\n-\t\t       || (!MEM_P (src_folded)\n-\t\t\t   && ! src_folded_force_flag))\n+\t\t   && !CONST_INT_P (trial)\n+\t\t   && (src_folded == 0 || !MEM_P (src_folded))\n \t\t   && GET_MODE_CLASS (mode) != MODE_CC\n \t\t   && mode != VOIDmode)\n \t    {\n-\t      src_folded_force_flag = 1;\n-\t      src_folded = trial;\n-\t      src_folded_cost = constant_pool_entries_cost;\n-\t      src_folded_regcost = constant_pool_entries_regcost;\n+\t      src_folded = force_const_mem (mode, trial);\n+\t      if (src_folded)\n+\t\t{\n+\t\t  src_folded_cost = COST (src_folded, mode);\n+\t\t  src_folded_regcost = approx_reg_cost (src_folded);\n+\t\t}\n \t    }\n \t}\n \n@@ -6630,8 +6612,6 @@ cse_main (rtx_insn *f ATTRIBUTE_UNUSED, int nregs)\n   cse_cfg_altered = false;\n   cse_jumps_altered = false;\n   recorded_label_ref = false;\n-  constant_pool_entries_cost = 0;\n-  constant_pool_entries_regcost = 0;\n   ebb_data.path_size = 0;\n   ebb_data.nsets = 0;\n   rtl_hooks = cse_rtl_hooks;"}, {"sha": "7fe50a21981d44001c398b27b4fb314fe2b0c60c", "filename": "gcc/testsuite/gcc.target/i386/387-12.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/247c407c83f0015f4b92d5f71e45b63192f6757e/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2F387-12.c?ref=247c407c83f0015f4b92d5f71e45b63192f6757e", "patch": "@@ -1,6 +1,6 @@\n /* PR target/26915 */\n /* { dg-do compile } */\n-/* { dg-options \"-O -mfpmath=387 -mfancy-math-387\" } */\n+/* { dg-options \"-O -m32 -mfpmath=387 -mfancy-math-387\" } */\n \n double testm0(void)\n {"}]}