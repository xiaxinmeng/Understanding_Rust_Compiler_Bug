{"sha": "0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyZDIzNzExZDhiNWY4ZWNjODY5ZDZhZGU0MDdmMjNlMzdhYzgyYw==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2018-09-14T15:52:04Z"}, "committer": {"name": "Uros Bizjak", "email": "uros@gcc.gnu.org", "date": "2018-09-14T15:52:04Z"}, "message": "reg-stack.c: Include regs.h.\n\n\t* reg-stack.c: Include regs.h.\n\t(replace_reg): Assert that mode is MODE_FLOAT or MODE_COMPLEX_FLOAT.\n\t(emit_pop_insn): Default pop insn mode to the reg_raw_mode of\n\tFIRST_STACK_REG, not DFmode.\n\t(emit_swap_insn): Default swap insn mode to the reg_raw_mode of\n\tFIRST_STACK_REG, not XFmode.  Explicitly construct swap RTX.\n\t(change stack): Default register mode to the reg_raw_mode of\n\tFIRST_STACK_REG, not DFmode.\n\t* config/i386/i386.md (*swap<mode>): Remove insn pattern.\n\t(*swapxf): Rename from swapxf.\n\nFrom-SVN: r264319", "tree": {"sha": "2a513f3ae907b334b2b2613da359290ce4e5ee41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a513f3ae907b334b2b2613da359290ce4e5ee41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8cafacb5fe6c8809df154021823fa1b3c0edcbfe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cafacb5fe6c8809df154021823fa1b3c0edcbfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cafacb5fe6c8809df154021823fa1b3c0edcbfe"}], "stats": {"total": 70, "additions": 38, "deletions": 32}, "files": [{"sha": "9b826f4c96e67dafcf5678311a2a2fc40ec5f431", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "patch": "@@ -1,3 +1,16 @@\n+2018-09-14  Uros Bizjak  <ubizjak@gmail.com>\n+\n+\t* reg-stack.c: Include regs.h.\n+\t(replace_reg): Assert that mode is MODE_FLOAT or MODE_COMPLEX_FLOAT.\n+\t(emit_pop_insn): Default pop insn mode to the reg_raw_mode of\n+\tFIRST_STACK_REG, not DFmode.\n+\t(emit_swap_insn): Default swap insn mode to the reg_raw_mode of\n+\tFIRST_STACK_REG, not XFmode.  Explicitly construct swap RTX.\n+\t(change stack): Default register mode to the reg_raw_mode of\n+\tFIRST_STACK_REG, not DFmode.\n+\t* config/i386/i386.md (*swap<mode>): Remove insn pattern.\n+\t(*swapxf): Rename from swapxf.\n+\n 2018-09-14  Carl Love  <cel@us.ibm.com>\n \n \t* config/rs6000/emmintrin.h: Add _MM_SHUFFLE2."}, {"sha": "ab1237e23da86ad95f5fe3f8bf51f430bb7a7782", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "patch": "@@ -3864,7 +3864,7 @@\n     operands[1] = CONST1_RTX (<MODE>mode);\n })\n \n-(define_insn \"swapxf\"\n+(define_insn \"*swapxf\"\n   [(set (match_operand:XF 0 \"register_operand\" \"+f\")\n \t(match_operand:XF 1 \"register_operand\" \"+f\"))\n    (set (match_dup 1)\n@@ -3878,22 +3878,8 @@\n }\n   [(set_attr \"type\" \"fxch\")\n    (set_attr \"mode\" \"XF\")])\n-\n-(define_insn \"*swap<mode>\"\n-  [(set (match_operand:MODEF 0 \"fp_register_operand\" \"+f\")\n-\t(match_operand:MODEF 1 \"fp_register_operand\" \"+f\"))\n-   (set (match_dup 1)\n-\t(match_dup 0))]\n-  \"TARGET_80387 || reload_completed\"\n-{\n-  if (STACK_TOP_P (operands[0]))\n-    return \"fxch\\t%1\";\n-  else\n-    return \"fxch\\t%0\";\n-}\n-  [(set_attr \"type\" \"fxch\")\n-   (set_attr \"mode\" \"<MODE>\")])\n \f\n+\n ;; Zero extension instructions\n \n (define_expand \"zero_extendsidi2\""}, {"sha": "97d758c8307b11fd0ca3301e779cf0ca1f47b4ff", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c2d23711d8b5f8ecc869d6ade407f23e37ac82c/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=0c2d23711d8b5f8ecc869d6ade407f23e37ac82c", "patch": "@@ -162,6 +162,7 @@\n #include \"df.h\"\n #include \"insn-config.h\"\n #include \"memmodel.h\"\n+#include \"regs.h\"\n #include \"emit-rtl.h\"  /* FIXME: Can go away once crtl is moved to rtl.h.  */\n #include \"recog.h\"\n #include \"varasm.h\"\n@@ -711,7 +712,7 @@ replace_reg (rtx *reg, int regno)\n   gcc_assert (IN_RANGE (regno, FIRST_STACK_REG, LAST_STACK_REG));\n   gcc_assert (STACK_REG_P (*reg));\n \n-  gcc_assert (SCALAR_FLOAT_MODE_P (GET_MODE (*reg))\n+  gcc_assert (GET_MODE_CLASS (GET_MODE (*reg)) == MODE_FLOAT\n \t      || GET_MODE_CLASS (GET_MODE (*reg)) == MODE_COMPLEX_FLOAT);\n \n   *reg = FP_MODE_REG (regno, GET_MODE (*reg));\n@@ -765,8 +766,10 @@ get_hard_regnum (stack_ptr regstack, rtx reg)\n    cases the movdf pattern to pop.  */\n \n static rtx_insn *\n-emit_pop_insn (rtx_insn *insn, stack_ptr regstack, rtx reg, enum emit_where where)\n+emit_pop_insn (rtx_insn *insn, stack_ptr regstack, rtx reg,\n+\t       enum emit_where where)\n {\n+  machine_mode raw_mode = reg_raw_mode[FIRST_STACK_REG];\n   rtx_insn *pop_insn;\n   rtx pop_rtx;\n   int hard_regno;\n@@ -775,8 +778,8 @@ emit_pop_insn (rtx_insn *insn, stack_ptr regstack, rtx reg, enum emit_where wher\n      CLOBBER and USE expressions.  */\n   if (COMPLEX_MODE_P (GET_MODE (reg)))\n     {\n-      rtx reg1 = FP_MODE_REG (REGNO (reg), DFmode);\n-      rtx reg2 = FP_MODE_REG (REGNO (reg) + 1, DFmode);\n+      rtx reg1 = FP_MODE_REG (REGNO (reg), raw_mode);\n+      rtx reg2 = FP_MODE_REG (REGNO (reg) + 1, raw_mode);\n \n       pop_insn = NULL;\n       if (get_hard_regnum (regstack, reg1) >= 0)\n@@ -791,15 +794,15 @@ emit_pop_insn (rtx_insn *insn, stack_ptr regstack, rtx reg, enum emit_where wher\n \n   gcc_assert (hard_regno >= FIRST_STACK_REG);\n \n-  pop_rtx = gen_rtx_SET (FP_MODE_REG (hard_regno, DFmode),\n-\t\t\t FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  pop_rtx = gen_rtx_SET (FP_MODE_REG (hard_regno, raw_mode),\n+\t\t\t FP_MODE_REG (FIRST_STACK_REG, raw_mode));\n \n   if (where == EMIT_AFTER)\n     pop_insn = emit_insn_after (pop_rtx, insn);\n   else\n     pop_insn = emit_insn_before (pop_rtx, insn);\n \n-  add_reg_note (pop_insn, REG_DEAD, FP_MODE_REG (FIRST_STACK_REG, DFmode));\n+  add_reg_note (pop_insn, REG_DEAD, FP_MODE_REG (FIRST_STACK_REG, raw_mode));\n \n   regstack->reg[regstack->top - (hard_regno - FIRST_STACK_REG)]\n     = regstack->reg[regstack->top];\n@@ -820,7 +823,6 @@ static void\n emit_swap_insn (rtx_insn *insn, stack_ptr regstack, rtx reg)\n {\n   int hard_regno;\n-  rtx swap_rtx;\n   int other_reg;\t\t/* swap regno temps */\n   rtx_insn *i1;\t\t\t/* the stack-reg insn prior to INSN */\n   rtx i1set = NULL_RTX;\t\t/* the SET rtx within I1 */\n@@ -978,9 +980,13 @@ emit_swap_insn (rtx_insn *insn, stack_ptr regstack, rtx reg)\n       return;\n     }\n \n-  swap_rtx = gen_swapxf (FP_MODE_REG (hard_regno, XFmode),\n-\t\t\t FP_MODE_REG (FIRST_STACK_REG, XFmode));\n-\n+  machine_mode raw_mode = reg_raw_mode[FIRST_STACK_REG];\n+  rtx op1 = FP_MODE_REG (hard_regno, raw_mode);\n+  rtx op2 = FP_MODE_REG (FIRST_STACK_REG, raw_mode);\n+  rtx swap_rtx\n+    = gen_rtx_PARALLEL (VOIDmode,\n+\t\t\tgen_rtvec (2, gen_rtx_SET (op1, op2),\n+\t\t\t\t   gen_rtx_SET (op2, op1)));\n   if (i1)\n     emit_insn_after (swap_rtx, i1);\n   else if (current_block)\n@@ -2487,6 +2493,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \t      enum emit_where where)\n {\n   int reg;\n+  machine_mode raw_mode = reg_raw_mode[FIRST_STACK_REG];\n   rtx_insn *update_end = NULL;\n   int i;\n \n@@ -2588,7 +2595,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \t\tnext--;\n \t      dest = next--;\n \t    }\n-\t  emit_pop_insn (insn, old, FP_MODE_REG (old->reg[dest], DFmode),\n+\t  emit_pop_insn (insn, old, FP_MODE_REG (old->reg[dest], raw_mode),\n \t\t\t EMIT_BEFORE);\n \t}\n     }\n@@ -2610,11 +2617,11 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \t  {\n \t    while (TEST_HARD_REG_BIT (new_stack->reg_set, old->reg[next]))\n \t      next--;\n-\t    emit_pop_insn (insn, old, FP_MODE_REG (old->reg[next], DFmode),\n+\t    emit_pop_insn (insn, old, FP_MODE_REG (old->reg[next], raw_mode),\n \t\t\t   EMIT_BEFORE);\n \t  }\n \telse\n-\t  emit_pop_insn (insn, old, FP_MODE_REG (old->reg[old->top], DFmode),\n+\t  emit_pop_insn (insn, old, FP_MODE_REG (old->reg[old->top], raw_mode),\n \t\t\t EMIT_BEFORE);\n     }\n \n@@ -2661,7 +2668,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \t\tgcc_assert (reg != -1);\n \n \t\temit_swap_insn (insn, old,\n-\t\t\t\tFP_MODE_REG (old->reg[reg], DFmode));\n+\t\t\t\tFP_MODE_REG (old->reg[reg], raw_mode));\n \t      }\n \n \t    /* See if any regs remain incorrect.  If so, bring an\n@@ -2672,7 +2679,7 @@ change_stack (rtx_insn *insn, stack_ptr old, stack_ptr new_stack,\n \t      if (new_stack->reg[reg] != old->reg[reg])\n \t\t{\n \t\t  emit_swap_insn (insn, old,\n-\t\t\t\t  FP_MODE_REG (old->reg[reg], DFmode));\n+\t\t\t\t  FP_MODE_REG (old->reg[reg], raw_mode));\n \t\t  break;\n \t\t}\n \t  } while (reg >= 0);"}]}