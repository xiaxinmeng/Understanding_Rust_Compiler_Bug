{"sha": "ec24a740308c01129bd934831787db53fbde8bc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMyNGE3NDAzMDhjMDExMjliZDkzNDgzMTc4N2RiNTNmYmRlOGJjMQ==", "commit": {"author": {"name": "Eric Christopher", "email": "echristo@redhat.com", "date": "2003-09-04T09:55:33Z"}, "committer": {"name": "Eric Christopher", "email": "echristo@gcc.gnu.org", "date": "2003-09-04T09:55:33Z"}, "message": "mips.c (mips_expand_prologue): Convert to calls.struct_value_rtx hook.\n\n2003-09-04  Eric Christopher  <echristo@redhat.com>\n\n\t* config/mips/mips.c (mips_expand_prologue): Convert to\n\tcalls.struct_value_rtx hook.\n\t(reg_or_const_float_1_operand): New.\n\t* config/mips/mips.h: Update Comments.\n\t(mips_arg): Add reg_or_const_float_1_operand.\n\t* config/mips/mips.md (divdf3); Convert to expander.\n\t(divsf3): Ditto.\n\t(*divdf3): New pattern.\n\t(*divsf3): Ditto.\n\nFrom-SVN: r71056", "tree": {"sha": "3808c958616d172c4a6eeab1dbede7f7bb078898", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3808c958616d172c4a6eeab1dbede7f7bb078898"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec24a740308c01129bd934831787db53fbde8bc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec24a740308c01129bd934831787db53fbde8bc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec24a740308c01129bd934831787db53fbde8bc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec24a740308c01129bd934831787db53fbde8bc1/comments", "author": {"login": "echristo", "id": 327308, "node_id": "MDQ6VXNlcjMyNzMwOA==", "avatar_url": "https://avatars.githubusercontent.com/u/327308?v=4", "gravatar_id": "", "url": "https://api.github.com/users/echristo", "html_url": "https://github.com/echristo", "followers_url": "https://api.github.com/users/echristo/followers", "following_url": "https://api.github.com/users/echristo/following{/other_user}", "gists_url": "https://api.github.com/users/echristo/gists{/gist_id}", "starred_url": "https://api.github.com/users/echristo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/echristo/subscriptions", "organizations_url": "https://api.github.com/users/echristo/orgs", "repos_url": "https://api.github.com/users/echristo/repos", "events_url": "https://api.github.com/users/echristo/events{/privacy}", "received_events_url": "https://api.github.com/users/echristo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a18b933f3a0a682daba07527fcfeb8e4fdd2dde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a18b933f3a0a682daba07527fcfeb8e4fdd2dde", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a18b933f3a0a682daba07527fcfeb8e4fdd2dde"}], "stats": {"total": 109, "additions": 80, "deletions": 29}, "files": [{"sha": "2b90b2a0a5b7481725d04da290b475576ce7d20d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ec24a740308c01129bd934831787db53fbde8bc1", "patch": "@@ -1,3 +1,15 @@\n+2003-09-04  Eric Christopher  <echristo@redhat.com>\n+\n+\t* config/mips/mips.c (mips_expand_prologue): Convert to\n+\tcalls.struct_value_rtx hook.\n+\t(reg_or_const_float_1_operand): New.\n+\t* config/mips/mips.h: Update Comments.\n+\t(mips_arg): Add reg_or_const_float_1_operand.\n+\t* config/mips/mips.md (divdf3); Convert to expander.\n+\t(divsf3): Ditto.\n+\t(*divdf3): New pattern.\n+\t(*divsf3): Ditto.\n+\n Thu Sep  4 10:43:24 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* toplev.c (wrapup_global_declarations): Fix final pass in\n@@ -91,7 +103,7 @@ Thu Sep  4 10:43:24 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tEXPAND_BUILTIN_SAVEREGS, SETUP_INCOMING_VARARGS,\n \tSTRICT_ARGUMENT_NAMING, PRETEND_OUTGOING_VARARGS_NAMED): Convert\n \tto hooks.\n-\t\n+\n \t* config/alpha/alpha.c (alpha_output_mi_thunk_osf): Pass function\n \tto aggregate_value_p.\n \t* config/arm/arm.c (arm_init_cumulative_args,\n@@ -108,7 +120,7 @@ Thu Sep  4 10:43:24 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tfunction to aggregate_value_p.\n \t* objc/objc-act.c (generate_struct_by_value_array): Pass NULL to\n \taggregate_value_p.\n-\t\n+\n \t* config/sh/sh-protos.h (sh_builtin_saveregs): Remove.\n \t(sh_attr_renesas_p, sh_cfun_attr_renesas_p, sh_function_arg,\n \tsh_function_arg_advance, sh_pass_in_reg_p): New.  * config/sh/sh.c\n@@ -150,7 +162,7 @@ Thu Sep  4 10:43:24 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \tSETUP_INCOMING_VARARGS, EXPAND_BUILTIN_SAVEREGS,\n \tPROMOTE_PROTOTYPES): Moved to sh.c.  * config/sh/sh.md (call): Set\n \tcall cookie to indicate renesas calls.\n-\t\n+\n 2003-09-03  Mostafa Hagog  <mustafa@il.ibm.com>\n \n \t* gcse.c (replace_one_set): New function."}, {"sha": "8bd2139d9efbd54b0bf1928f95143272d044b1db", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=ec24a740308c01129bd934831787db53fbde8bc1", "patch": "@@ -1303,6 +1303,28 @@ reg_or_0_operand (rtx op, enum machine_mode mode)\n     }\n }\n \n+/* Accept a register or the floating point constant 1 in the appropriate mode.  */\n+\n+int\n+reg_or_const_float_1_operand (rtx op, enum machine_mode mode)\n+{\n+  REAL_VALUE_TYPE d;\n+\n+  switch (GET_CODE (op))\n+    {\n+    case CONST_DOUBLE:\n+      if (mode != GET_MODE (op)\n+\t  || (mode != DFmode && mode != SFmode))\n+\treturn 0;\n+\n+      REAL_VALUE_FROM_CONST_DOUBLE (d, op);\n+      return REAL_VALUES_EQUAL (d, dconst1);\n+\n+    default:\n+      return register_operand (op, mode);\n+    }\n+}\n+\n /* Accept the floating point constant 1 in the appropriate mode.  */\n \n int\n@@ -6714,7 +6736,7 @@ mips_expand_prologue (void)\n   /* If struct value address is treated as the first argument, make it so.  */\n   if (aggregate_value_p (DECL_RESULT (fndecl), fndecl)\n       && ! current_function_returns_pcc_struct\n-      && struct_value_incoming_rtx == 0)\n+      && targetm.calls.struct_value_rtx (fndecl, 0) == 0)\n     {\n       tree type = build_pointer_type (fntype);\n       tree function_result_decl = build_decl (PARM_DECL, NULL_TREE, type);"}, {"sha": "b72399ee02ca5f73f8bcadb94b5c2f1df5c492d1", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 17, "deletions": 23, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=ec24a740308c01129bd934831787db53fbde8bc1", "patch": "@@ -515,9 +515,9 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Use GP relative sdata/sbss sections (now ignored)\")},\t\t\\\n   {\"gpopt\",\t\t  0,\t\t\t\t\t\t\\\n      N_(\"Use GP relative sdata/sbss sections (now ignored)\")},\t\t\\\n-  {\"no-gpOPT\",\t\t  0,\t\t\t\t\t\\\n+  {\"no-gpOPT\",\t\t  0,\t\t\t\t\t        \\\n      N_(\"Don't use GP relative sdata/sbss sections (now ignored)\")},\t\\\n-  {\"no-gpopt\",\t\t  0,\t\t\t\t\t\\\n+  {\"no-gpopt\",\t\t  0,\t\t\t\t\t        \\\n      N_(\"Don't use GP relative sdata/sbss sections (now ignored)\")},\t\\\n   {\"stats\",\t\t  0,\t\t\t\t\t\t\\\n      N_(\"Output compiler statistics (now ignored)\")},\t\t\t\\\n@@ -1415,12 +1415,7 @@ extern const struct mips_cpu_info *mips_tune_info;\n    on the full register even if a narrower mode is specified.  */\n #define WORD_REGISTER_OPERATIONS\n \n-/* Define if loading in MODE, an integral mode narrower than BITS_PER_WORD\n-   will either zero-extend or sign-extend.  The value of this macro should\n-   be the code that says which one of the two operations is implicitly\n-   done, NIL if none.\n-\n-   When in 64 bit mode, mips_move_1word will sign extend SImode and CCmode\n+/* When in 64 bit mode, move insns will sign extend SImode and CCmode\n    moves.  All other references are zero extended.  */\n #define LOAD_EXTEND_OP(MODE) \\\n   (TARGET_64BIT && ((MODE) == SImode || (MODE) == CCmode) \\\n@@ -1809,31 +1804,31 @@ enum reg_class\n    sub-initializer must be suitable as an initializer for the type\n    `HARD_REG_SET' which is defined in `hard-reg-set.h'.  */\n \n-#define REG_CLASS_CONTENTS\t\t\t\t\t\t\\\n-{\t\t\t\t\t\t\t\t\t\\\n+#define REG_CLASS_CONTENTS\t\t\t\t\t\t                                \\\n+{\t\t\t\t\t\t\t\t\t                                \\\n   { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* no registers */\t\\\n   { 0x0003000c, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 nonarg regs */\\\n   { 0x000300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 registers */\t\\\n   { 0x01000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 T register */\t\\\n   { 0x010300fc, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* mips16 and T regs */ \\\n   { 0x02000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* SVR4 PIC function address register */ \\\n-  { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* Every other GPR */ \\\n+  { 0xfdffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* Every other GPR */   \\\n   { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* integer registers */\t\\\n   { 0x00000000, 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0x00000000 },\t/* floating registers*/\t\\\n   { 0x00000000, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* hi register */\t\\\n   { 0x00000000, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t/* lo register */\t\\\n   { 0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000000, 0x00000000 },\t/* mul/div registers */\t\\\n-  { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 }, /* cop0 registers */ \\\n-  { 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 }, /* cop2 registers */ \\\n-  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, /* cop3 registers */ \\\n+  { 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },   /* cop0 registers */    \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },   /* cop2 registers */    \\\n+  { 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff },   /* cop3 registers */    \\\n   { 0xffffffff, 0x00000000, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t/* union classes */     \\\n   { 0xffffffff, 0x00000000, 0x00000002, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n   { 0x00000000, 0xffffffff, 0x00000001, 0x00000000, 0x00000000, 0x00000000 },\t\t\t\t\\\n-  { 0xffffffff, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },\t\t\t\\\n-  { 0xffffffff, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },\t\\\n-  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff }, \\\n-  { 0x00000000, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff }, \\\n-  { 0xffffffff, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff }, \\\n+  { 0xffffffff, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000, 0x00000000 },\t\t\t        \\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff, 0x00000000 },\t                        \\\n+  { 0xffffffff, 0x00000000, 0x00000000, 0x00000000, 0xffff0000, 0x0000ffff },                           \\\n+  { 0x00000000, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff },                           \\\n+  { 0xffffffff, 0x00000000, 0xffff0000, 0xffffffff, 0xffffffff, 0x0000ffff },                           \\\n   { 0x00000000, 0x00000000, 0x000007f8, 0x00000000, 0x00000000, 0x00000000 },\t/* status registers */\t\\\n   { 0xffffffff, 0xffffffff, 0xffff07ff, 0xffffffff, 0xffffffff, 0x0000ffff }\t/* all registers */\t\\\n }\n@@ -2668,9 +2663,7 @@ typedef struct mips_args {\n \f\n /* Specify the machine mode that this machine uses\n    for the index in the tablejump instruction.\n-   ??? Using HImode in mips16 mode can cause overflow.  However, the\n-   overflow is no more likely than the overflow in a branch\n-   instruction.  Large functions can currently break in both ways.  */\n+   ??? Using HImode in mips16 mode can cause overflow. */\n #define CASE_VECTOR_MODE \\\n   (TARGET_MIPS16 ? HImode : ptr_mode)\n \n@@ -2808,6 +2801,7 @@ typedef struct mips_args {\n   {\"small_int\",\t\t\t{ CONST_INT }},\t\t\t\t\\\n   {\"mips_const_double_ok\",\t{ CONST_DOUBLE }},\t\t\t\\\n   {\"const_float_1_operand\",\t{ CONST_DOUBLE }},\t\t\t\\\n+  {\"reg_or_const_float_1_operand\", { CONST_DOUBLE, REG}},               \\\n   {\"simple_memory_operand\",\t{ MEM, SUBREG }},\t\t\t\\\n   {\"equality_op\",\t\t{ EQ, NE }},\t\t\t\t\\\n   {\"cmp_op\",\t\t\t{ EQ, NE, GT, GE, GTU, GEU, LT, LE,\t\\\n@@ -3366,7 +3360,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n   if (TARGET_EMBEDDED_PIC || TARGET_MIPS16)\t\t\t\t\\\n     function_section (current_function_decl);\t\t\t\t\\\n-  (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);\t\t\t\\\n+  (*targetm.asm_out.internal_label) (FILE, PREFIX, NUM);\t\t\\\n } while (0)\n \n /* This is how to output an assembler line"}, {"sha": "7b5f1b7433cf7e618db85dfd091c18af09660815", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec24a740308c01129bd934831787db53fbde8bc1/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=ec24a740308c01129bd934831787db53fbde8bc1", "patch": "@@ -2365,6 +2365,17 @@\n ;;  ....................\n ;;\n \n+(define_expand \"divdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(div:DF (match_operand:DF 1 \"reg_or_const_float_1_operand\" \"\")\n+\t\t(match_operand:DF 2 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+{\n+  if (const_float_1_operand (operands[1], DFmode))\n+    if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n+      FAIL;\n+})\n+\n ;; This pattern works around the early SB-1 rev2 core \"F1\" erratum:\n ;;\n ;; If an mfc1 or dmfc1 happens to access the floating point register\n@@ -2376,7 +2387,8 @@\n ;;\n ;; The workaround is to insert an unconditional 'mov' from/to the\n ;; long latency op destination register.\n-(define_insn \"divdf3\"\n+\n+(define_insn \"*divdf3\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n \t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n@@ -2395,6 +2407,17 @@\n                       (const_int 4)))])\n \n \n+(define_expand \"divsf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(div:SF (match_operand:SF 1 \"reg_or_const_float_1_operand\" \"\")\n+\t\t(match_operand:SF 2 \"register_operand\" \"\")))]\n+  \"TARGET_HARD_FLOAT\"\n+{\n+  if (const_float_1_operand (operands[1], SFmode))\n+    if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n+      FAIL;\n+})\n+\n ;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n ;; \"divdf3\" comment for details).\n ;;\n@@ -2406,7 +2429,7 @@\n ;; Therefore, we only allow div.s if not working around SB-1 rev2\n ;; errata, or if working around those errata and a slight loss of\n ;; precision is OK (i.e., flag_unsafe_math_optimizations is set).\n-(define_insn \"divsf3\"\n+(define_insn \"*divsf3\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n \t\t(match_operand:SF 2 \"register_operand\" \"f\")))]"}]}