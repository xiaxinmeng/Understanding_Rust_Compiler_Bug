{"sha": "aaad548e18f57f1af985bce7e9bed143c02f2261", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFhZDU0OGUxOGY1N2YxYWY5ODViY2U3ZTliZWQxNDNjMDJmMjI2MQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely.gcc@gmail.com", "date": "2013-03-16T02:48:06Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2013-03-16T02:48:06Z"}, "message": "re PR libstdc++/56492 (std::packaged_task requires CopyConstructible stored task)\n\n\tPR libstdc++/56492\n\t* include/std/future (__future_base::_Result): Add result_type\n\ttypedef.\n\t(__future_base::_S_allocate_result): Overload for std::allocator.\n\t(__future_base::_Task_setter): Use _Result::result_type instead of\n\tdeducing the type from the task.\n\t(__future_base::_Task_state): Store allocator to allow shared state\n\tto be reset.  Replace std::function with member of target object type\n\taccessed via ...\n\t(__future_base::_Task_state_base): New abstract base class.\n\t(__future_base::_Task_state_base::_M_run): New virtual function to\n\tinvoke type-erased target object.\n\t(__future_base::_Task_state_base::_M_reset): New virtual function to\n\tcreate new shared_state using same target object and allocator.\n\t(__future_base::__create_task_state): Allocate a new _Task_state.\n\t(packaged_task::packaged_task): Use __create_task_state.\n\t(packaged_task::reset): Use _Task_state_base::_M_reset.\n\t* testsuite/30_threads/packaged_task/cons/56492.cc: New.\n\nFrom-SVN: r196695", "tree": {"sha": "46b4804fbfae19bc420f6e418eaca811c77bfad1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/46b4804fbfae19bc420f6e418eaca811c77bfad1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaad548e18f57f1af985bce7e9bed143c02f2261", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaad548e18f57f1af985bce7e9bed143c02f2261", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaad548e18f57f1af985bce7e9bed143c02f2261", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaad548e18f57f1af985bce7e9bed143c02f2261/comments", "author": null, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b5e1443a6542d749ac3df1730667276ce8141e13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5e1443a6542d749ac3df1730667276ce8141e13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5e1443a6542d749ac3df1730667276ce8141e13"}], "stats": {"total": 253, "additions": 175, "deletions": 78}, "files": [{"sha": "e8211a307d0a0e41efb5bbf74211537641ffffd8", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=aaad548e18f57f1af985bce7e9bed143c02f2261", "patch": "@@ -1,3 +1,24 @@\n+2013-03-16  Jonathan Wakely  <jwakely.gcc@gmail.com>\n+\n+\tPR libstdc++/56492\n+\t* include/std/future (__future_base::_Result): Add result_type\n+\ttypedef.\n+\t(__future_base::_S_allocate_result): Overload for std::allocator.\n+\t(__future_base::_Task_setter): Use _Result::result_type instead of\n+\tdeducing the type from the task.\n+\t(__future_base::_Task_state): Store allocator to allow shared state\n+\tto be reset.  Replace std::function with member of target object type\n+\taccessed via ...\n+\t(__future_base::_Task_state_base): New abstract base class.\n+\t(__future_base::_Task_state_base::_M_run): New virtual function to\n+\tinvoke type-erased target object.\n+\t(__future_base::_Task_state_base::_M_reset): New virtual function to\n+\tcreate new shared_state using same target object and allocator.\n+\t(__future_base::__create_task_state): Allocate a new _Task_state.\n+\t(packaged_task::packaged_task): Use __create_task_state.\n+\t(packaged_task::reset): Use _Task_state_base::_M_reset.\n+\t* testsuite/30_threads/packaged_task/cons/56492.cc: New.\n+\n 2013-03-15  Tom Tromey  <tromey@redhat.com>\n \n \t* libsupc++/unwind-cxx.h: Include sys/sdt.h if detected."}, {"sha": "30100fe05e488dfc211462d3110c4f03492ba497", "filename": "libstdc++-v3/include/std/future", "status": "modified", "additions": 119, "deletions": 78, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffuture?ref=aaad548e18f57f1af985bce7e9bed143c02f2261", "patch": "@@ -214,6 +214,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tbool \t\t\t_M_initialized;\n \n       public:\n+\ttypedef _Res result_type;\n+\n \t_Result() noexcept : _M_initialized() { }\n \t\n \t~_Result()\n@@ -281,17 +283,23 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         typename __traits::allocator_type __a2(__a);\n         __result_type* __p = __traits::allocate(__a2, 1);\n         __try\n-\t{\n-\t  __traits::construct(__a2, __p, __a);\n-        }\n+\t  {\n+\t    __traits::construct(__a2, __p, __a);\n+\t  }\n         __catch(...)\n-        {\n-\t  __traits::deallocate(__a2, __p, 1);\n-          __throw_exception_again;\n-        }\n+\t  {\n+\t    __traits::deallocate(__a2, __p, 1);\n+\t    __throw_exception_again;\n+\t  }\n         return _Ptr<__result_type>(__p);\n       }\n \n+    template<typename _Res, typename _Tp>\n+      static _Ptr<_Result<_Res>>\n+      _S_allocate_result(const std::allocator<_Tp>& __a)\n+      {\n+\treturn _Ptr<_Result<_Res>>(new _Result<_Res>);\n+      }\n \n     /// Base class for state between a promise and one or more\n     /// associated futures.\n@@ -482,6 +490,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       class _Async_state_impl;\n \n     template<typename _Signature>\n+      class _Task_state_base;\n+\n+    template<typename _Fn, typename _Alloc, typename _Signature>\n       class _Task_state;\n \n     template<typename _BoundFn>\n@@ -492,31 +503,24 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       static std::shared_ptr<_State_base>\n       _S_make_async_state(_BoundFn&& __fn);\n \n-    template<typename _Res_ptr, typename _Res>\n+    template<typename _Res_ptr,\n+\t     typename _Res = typename _Res_ptr::element_type::result_type>\n       struct _Task_setter;\n \n     template<typename _Res_ptr, typename _BoundFn>\n-      class _Task_setter_helper\n-      {\n-\ttypedef typename remove_reference<_BoundFn>::type::result_type __res;\n-      public:\n-\ttypedef _Task_setter<_Res_ptr, __res> __type;\n-      };\n-\n-    template<typename _Res_ptr, typename _BoundFn>\n-      static typename _Task_setter_helper<_Res_ptr, _BoundFn>::__type\n+      static _Task_setter<_Res_ptr>\n       _S_task_setter(_Res_ptr& __ptr, _BoundFn&& __call)\n       {\n-\ttypedef _Task_setter_helper<_Res_ptr, _BoundFn> __helper_type;\n-\ttypedef typename __helper_type::__type _Setter;\n-\treturn _Setter{ __ptr, std::ref(__call) };\n+\treturn _Task_setter<_Res_ptr>{ __ptr, std::ref(__call) };\n       }\n   };\n \n   /// Partial specialization for reference types.\n   template<typename _Res>\n     struct __future_base::_Result<_Res&> : __future_base::_Result_base\n     {\n+      typedef _Res& result_type;\n+\n       _Result() noexcept : _M_value_ptr() { }\n \n       void _M_set(_Res& __res) noexcept { _M_value_ptr = &__res; }\n@@ -533,6 +537,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n     struct __future_base::_Result<void> : __future_base::_Result_base\n     {\n+      typedef void result_type;\n+\n     private:\n       void _M_destroy() { delete this; }\n     };\n@@ -1197,15 +1203,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Ptr_type operator()()\n       {\n-        __try\n+\t__try\n \t  {\n \t    _M_result->_M_set(_M_fn());\n \t  }\n \t__catch(...)\n \t  {\n \t    _M_result->_M_error = current_exception();\n \t  }\n-        return std::move(_M_result);\n+\treturn std::move(_M_result);\n       }\n       _Ptr_type&                _M_result;\n       std::function<_Res()>     _M_fn;\n@@ -1216,7 +1222,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     {\n       _Ptr_type operator()()\n       {\n-        __try\n+\t__try\n \t  {\n \t    _M_fn();\n \t  }\n@@ -1231,49 +1237,85 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Res, typename... _Args>\n-    struct __future_base::_Task_state<_Res(_Args...)> final\n+    struct __future_base::_Task_state_base<_Res(_Args...)>\n     : __future_base::_State_base\n     {\n       typedef _Res _Res_type;\n \n-      _Task_state(std::function<_Res(_Args...)> __task)\n-      : _M_result(new _Result<_Res>()), _M_task(std::move(__task))\n-      { }\n+      template<typename _Alloc>\n+\t_Task_state_base(const _Alloc& __a)\n+\t: _M_result(_S_allocate_result<_Res>(__a))\n+\t{ }\n \n-      template<typename _Func, typename _Alloc>\n-        _Task_state(_Func&& __task, const _Alloc& __a)\n-        : _M_result(_S_allocate_result<_Res>(__a)),\n-\t  _M_task(allocator_arg, __a, std::move(__task))\n-        { }\n+      virtual void\n+      _M_run(_Args... __args) = 0;\n \n-      void\n+      virtual shared_ptr<_Task_state_base>\n+      _M_reset() = 0;\n+\n+      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;\n+      _Ptr_type _M_result;\n+    };\n+\n+  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>\n+    struct __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)> final\n+    : __future_base::_Task_state_base<_Res(_Args...)>\n+    {\n+      _Task_state(_Fn&& __fn, const _Alloc& __a)\n+      : _Task_state_base<_Res(_Args...)>(__a), _M_impl(std::move(__fn), __a)\n+      { }\n+\n+    private:\n+      virtual void\n       _M_run(_Args... __args)\n       {\n-        // bound arguments decay so wrap lvalue references\n-\tauto __boundfn = std::__bind_simple(std::ref(_M_task),\n+\t// bound arguments decay so wrap lvalue references\n+\tauto __boundfn = std::__bind_simple(std::ref(_M_impl._M_fn),\n \t    _S_maybe_wrap_ref(std::forward<_Args>(__args))...);\n-        auto __setter = _S_task_setter(_M_result, std::move(__boundfn));\n-        _M_set_result(std::move(__setter));\n+\tauto __setter = _S_task_setter(this->_M_result, std::move(__boundfn));\n+\tthis->_M_set_result(std::move(__setter));\n       }\n \n-      typedef __future_base::_Ptr<_Result<_Res>> _Ptr_type;\n-      _Ptr_type _M_result;\n-      std::function<_Res(_Args...)> _M_task;\n+      virtual shared_ptr<_Task_state_base<_Res(_Args...)>>\n+      _M_reset();\n \n       template<typename _Tp>\n-        static reference_wrapper<_Tp>\n-        _S_maybe_wrap_ref(_Tp& __t)\n-        { return std::ref(__t); }\n+\tstatic reference_wrapper<_Tp>\n+\t_S_maybe_wrap_ref(_Tp& __t)\n+\t{ return std::ref(__t); }\n \n       template<typename _Tp>\n-        static typename enable_if<!is_lvalue_reference<_Tp>::value,\n-                        _Tp>::type&&\n-        _S_maybe_wrap_ref(_Tp&& __t)\n-        { return std::forward<_Tp>(__t); }\n+\tstatic\n+\ttypename enable_if<!is_lvalue_reference<_Tp>::value, _Tp>::type&&\n+\t_S_maybe_wrap_ref(_Tp&& __t)\n+\t{ return std::forward<_Tp>(__t); }\n+\n+      struct _Impl : _Alloc\n+      {\n+\t_Impl(_Fn&& __fn, const _Alloc& __a)\n+\t  : _Alloc(__a), _M_fn(std::move(__fn)) { }\n+\t_Fn _M_fn;\n+      } _M_impl;\n     };\n \n+    template<typename _Signature, typename _Fn, typename _Alloc>\n+      static shared_ptr<__future_base::_Task_state_base<_Signature>>\n+      __create_task_state(_Fn&& __fn, const _Alloc& __a)\n+      {\n+\ttypedef __future_base::_Task_state<_Fn, _Alloc, _Signature> _State;\n+\treturn std::allocate_shared<_State>(__a, std::move(__fn), __a);\n+      }\n+\n+  template<typename _Fn, typename _Alloc, typename _Res, typename... _Args>\n+    shared_ptr<__future_base::_Task_state_base<_Res(_Args...)>>\n+    __future_base::_Task_state<_Fn, _Alloc, _Res(_Args...)>::_M_reset()\n+    {\n+      return __create_task_state<_Res(_Args...)>(std::move(_M_impl._M_fn),\n+\t\t\t\t\t\t static_cast<_Alloc&>(_M_impl));\n+    }\n+\n   template<typename _Task, typename _Fn, bool\n-           = is_same<_Task, typename decay<_Fn>::type>::value>\n+\t   = is_same<_Task, typename decay<_Fn>::type>::value>\n     struct __constrain_pkgdtask\n     { typedef void __type; };\n \n@@ -1285,7 +1327,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Res, typename... _ArgTypes>\n     class packaged_task<_Res(_ArgTypes...)>\n     {\n-      typedef __future_base::_Task_state<_Res(_ArgTypes...)>  _State_type;\n+      typedef __future_base::_Task_state_base<_Res(_ArgTypes...)> _State_type;\n       shared_ptr<_State_type>                   _M_state;\n \n     public:\n@@ -1295,56 +1337,53 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 2095.  missing constructors needed for uses-allocator construction\n       template<typename _Allocator>\n-        explicit\n-        packaged_task(allocator_arg_t, const _Allocator& __a) noexcept\n-        { }\n+\tpackaged_task(allocator_arg_t, const _Allocator& __a) noexcept\n+\t{ }\n \n       template<typename _Fn, typename = typename\n-               __constrain_pkgdtask<packaged_task, _Fn>::__type>\n-        explicit\n-        packaged_task(_Fn&& __fn)\n-        : _M_state(std::make_shared<_State_type>(std::forward<_Fn>(__fn)))\n-        { }\n+\t       __constrain_pkgdtask<packaged_task, _Fn>::__type>\n+\texplicit\n+\tpackaged_task(_Fn&& __fn)\n+\t: packaged_task(allocator_arg, std::allocator<int>(), std::move(__fn))\n+\t{ }\n \n       // _GLIBCXX_RESOLVE_LIB_DEFECTS\n       // 2097.  packaged_task constructors should be constrained\n-      template<typename _Fn, typename _Allocator, typename = typename\n-               __constrain_pkgdtask<packaged_task, _Fn>::__type>\n-        explicit\n-        packaged_task(allocator_arg_t, const _Allocator& __a, _Fn&& __fn)\n-        : _M_state(std::allocate_shared<_State_type>(__a,\n-                                                     std::forward<_Fn>(__fn)))\n-        { }\n+      template<typename _Fn, typename _Alloc, typename = typename\n+\t       __constrain_pkgdtask<packaged_task, _Fn>::__type>\n+\texplicit\n+\tpackaged_task(allocator_arg_t, const _Alloc& __a, _Fn&& __fn)\n+\t: _M_state(__create_task_state<_Res(_ArgTypes...)>(\n+\t\t    std::forward<_Fn>(__fn), __a))\n+\t{ }\n \n       ~packaged_task()\n       {\n         if (static_cast<bool>(_M_state) && !_M_state.unique())\n-          _M_state->_M_break_promise(std::move(_M_state->_M_result));\n+\t  _M_state->_M_break_promise(std::move(_M_state->_M_result));\n       }\n \n       // No copy\n       packaged_task(const packaged_task&) = delete;\n       packaged_task& operator=(const packaged_task&) = delete;\n \n       template<typename _Allocator>\n-        explicit\n-        packaged_task(allocator_arg_t, const _Allocator&,\n-                      const packaged_task&) = delete;\n+\tpackaged_task(allocator_arg_t, const _Allocator&,\n+\t\t      const packaged_task&) = delete;\n \n       // Move support\n       packaged_task(packaged_task&& __other) noexcept\n       { this->swap(__other); }\n \n       template<typename _Allocator>\n-        explicit\n-        packaged_task(allocator_arg_t, const _Allocator&,\n-                      packaged_task&& __other) noexcept\n-        { this->swap(__other); }\n+\tpackaged_task(allocator_arg_t, const _Allocator&,\n+\t\t      packaged_task&& __other) noexcept\n+\t{ this->swap(__other); }\n \n       packaged_task& operator=(packaged_task&& __other) noexcept\n       {\n-        packaged_task(std::move(__other)).swap(*this);\n-        return *this;\n+\tpackaged_task(std::move(__other)).swap(*this);\n+\treturn *this;\n       }\n \n       void\n@@ -1364,15 +1403,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       void\n       operator()(_ArgTypes... __args)\n       {\n-        __future_base::_State_base::_S_check(_M_state);\n-        _M_state->_M_run(std::forward<_ArgTypes>(__args)...);\n+\t__future_base::_State_base::_S_check(_M_state);\n+\t_M_state->_M_run(std::forward<_ArgTypes>(__args)...);\n       }\n \n       void\n       reset()\n       {\n-        __future_base::_State_base::_S_check(_M_state);\n-        packaged_task(std::move(_M_state->_M_task)).swap(*this);\n+\t__future_base::_State_base::_S_check(_M_state);\n+\tpackaged_task __tmp;\n+\t__tmp._M_state = _M_state;\n+\t_M_state = _M_state->_M_reset();\n       }\n     };\n "}, {"sha": "02296bb5aa6b672baa890b79e7469f6228d27875", "filename": "libstdc++-v3/testsuite/30_threads/packaged_task/cons/56492.cc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2F56492.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaad548e18f57f1af985bce7e9bed143c02f2261/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2F56492.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fpackaged_task%2Fcons%2F56492.cc?ref=aaad548e18f57f1af985bce7e9bed143c02f2261", "patch": "@@ -0,0 +1,35 @@\n+// { dg-do compile { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+// { dg-require-atomic-builtins \"\" }\n+\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <future>\n+\n+struct S\n+{\n+  S() = default;\n+  S(S&&) = default;\n+  void operator()() { }\n+};\n+\n+std::packaged_task<void ()> pt{ S{} };"}]}