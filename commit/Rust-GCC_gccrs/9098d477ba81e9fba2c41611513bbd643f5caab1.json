{"sha": "9098d477ba81e9fba2c41611513bbd643f5caab1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTA5OGQ0NzdiYTgxZTlmYmEyYzQxNjExNTEzYmJkNjQzZjVjYWFiMQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-10T09:00:59Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-10T09:00:59Z"}, "message": "[Ada] Elaboration order v4.0 and cycle detection\n\nThis patch introduces a new cycle detection algorithm which is based on\nTarjan's \"Enumeration of the Elementary Circuits of a Directed Graph\"\nalgorithm, with several ideas borrowed from Jonson's \"Finding all the\nElementary Circuits of a Directed Graph\" algorithm.\n\nNo need for a test because the new algorithm improves the performance of\ncycle detection only.\n\n2019-07-10  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* bindo.adb: Update the section on switches.\n\t* bindo-graphs.adb\n\t(Add_Cycle, Add_Vertex_And_Complement): Remove.\n\t(Create): The graph no longer needs a set of recorded cycles\n\tbecause the cycles are not rediscovered in permuted forms.\n\t(Cycle_End_Vertices): New routine.\n\t(Destroy): The graph no longer needs a set of recorded cycles\n\tbecause the cycles are not rediscovered in permuted forms.\n\t(Destroy_Library_Graph_Vertex): Move to the library level.\n\t(Find_All_Cycles_Through_Vertex, Find_All_Cycles_With_Edge):\n\tRemove.\n\t(Find_Cycles_From_Successor, Find_Cycles_From_Vertex,\n\tFind_Cycles_In_Component, Has_Elaborate_All_Edge): New routines.\n\t(Insert_And_Sort): Remove.\n\t(Is_Elaborate_Body_Edge): Use predicate\n\tIs_Vertex_With_Elaborate_Body.\n\t(Is_Recorded_Cycle): Remove.\n\t(Is_Vertex_With_Elaborate_Body): New routine.\n\t(Normalize_And_Add_Cycle): Remove.\n\t(Precedence): Rename to xxx_Precedence, where xxx relates to the\n\tinput.  These versions better reflect the desired input\n\tprecedence.\n\t(Record_Cycle): New routine.\n\t(Remove_Vertex_And_Complement, Set_Is_Recorded_Cycle): Remove.\n\t(Trace_xxx): Update all versions to use debug switch -d_t.\n\t(Trace_Component): New routine.\n\t(Trace_Eol): Removed.\n\t(Trace_Vertex): Do not output the component as this information\n\tis already available when the component is traced.\n\t(Unvisit, Visit): New routine.\n\t* bindo-graphs.ads: Add new instance LGV_Lists.  Remove instance\n\tRC_Sets.  Update the structure of type Library_Graph_Attributes\n\tto remove the set of recorded cycles.\n\t(Destroy_Library_Graph_Vertex): Move to the library level.\n\t* bindo-writers.adb (Write_Component_Vertices): Output\n\tinformation about the number of vertices.\n\t* debug.adb: Document the use of binder switch -d_t.  Update the\n\tuse of binder switch -d_T.\n\nFrom-SVN: r273330", "tree": {"sha": "71b7c7c6c5ab74bdaf085fa64e84d2e6c375aa8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b7c7c6c5ab74bdaf085fa64e84d2e6c375aa8d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9098d477ba81e9fba2c41611513bbd643f5caab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9098d477ba81e9fba2c41611513bbd643f5caab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9098d477ba81e9fba2c41611513bbd643f5caab1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9098d477ba81e9fba2c41611513bbd643f5caab1/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "74b96685bb00766f8931c95d45d6e2c4d719cf1a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74b96685bb00766f8931c95d45d6e2c4d719cf1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74b96685bb00766f8931c95d45d6e2c4d719cf1a"}], "stats": {"total": 2287, "additions": 1402, "deletions": 885}, "files": [{"sha": "ecbee098f54db77f57ff92ebd49bc57c41e3f9f5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -1,3 +1,44 @@\n+2019-07-10  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* bindo.adb: Update the section on switches.\n+\t* bindo-graphs.adb\n+\t(Add_Cycle, Add_Vertex_And_Complement): Remove.\n+\t(Create): The graph no longer needs a set of recorded cycles\n+\tbecause the cycles are not rediscovered in permuted forms.\n+\t(Cycle_End_Vertices): New routine.\n+\t(Destroy): The graph no longer needs a set of recorded cycles\n+\tbecause the cycles are not rediscovered in permuted forms.\n+\t(Destroy_Library_Graph_Vertex): Move to the library level.\n+\t(Find_All_Cycles_Through_Vertex, Find_All_Cycles_With_Edge):\n+\tRemove.\n+\t(Find_Cycles_From_Successor, Find_Cycles_From_Vertex,\n+\tFind_Cycles_In_Component, Has_Elaborate_All_Edge): New routines.\n+\t(Insert_And_Sort): Remove.\n+\t(Is_Elaborate_Body_Edge): Use predicate\n+\tIs_Vertex_With_Elaborate_Body.\n+\t(Is_Recorded_Cycle): Remove.\n+\t(Is_Vertex_With_Elaborate_Body): New routine.\n+\t(Normalize_And_Add_Cycle): Remove.\n+\t(Precedence): Rename to xxx_Precedence, where xxx relates to the\n+\tinput.  These versions better reflect the desired input\n+\tprecedence.\n+\t(Record_Cycle): New routine.\n+\t(Remove_Vertex_And_Complement, Set_Is_Recorded_Cycle): Remove.\n+\t(Trace_xxx): Update all versions to use debug switch -d_t.\n+\t(Trace_Component): New routine.\n+\t(Trace_Eol): Removed.\n+\t(Trace_Vertex): Do not output the component as this information\n+\tis already available when the component is traced.\n+\t(Unvisit, Visit): New routine.\n+\t* bindo-graphs.ads: Add new instance LGV_Lists.  Remove instance\n+\tRC_Sets.  Update the structure of type Library_Graph_Attributes\n+\tto remove the set of recorded cycles.\n+\t(Destroy_Library_Graph_Vertex): Move to the library level.\n+\t* bindo-writers.adb (Write_Component_Vertices): Output\n+\tinformation about the number of vertices.\n+\t* debug.adb: Document the use of binder switch -d_t.  Update the\n+\tuse of binder switch -d_T.\n+\n 2019-07-10  Yannick Moy  <moy@adacore.com>\n \n \t* sem_spark.adb (Get_Root_Object): Replace precondition by error"}, {"sha": "f1bfe4701504ec286e260ec64cea5cfbf9d8e3aa", "filename": "gcc/ada/bindo-graphs.adb", "status": "modified", "additions": 1312, "deletions": 848, "changes": 2160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-graphs.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-graphs.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.adb?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -94,6 +94,18 @@ package body Bindo.Graphs is\n       null;\n    end Destroy_Library_Graph_Edge;\n \n+   ----------------------------------\n+   -- Destroy_Library_Graph_Vertex --\n+   ----------------------------------\n+\n+   procedure Destroy_Library_Graph_Vertex\n+     (Vertex : in out Library_Graph_Vertex_Id)\n+   is\n+      pragma Unreferenced (Vertex);\n+   begin\n+      null;\n+   end Destroy_Library_Graph_Vertex;\n+\n    --------------------------------\n    -- Hash_Invocation_Graph_Edge --\n    --------------------------------\n@@ -1047,16 +1059,6 @@ package body Bindo.Graphs is\n       --  corresponding specs or bodies, where the body is a predecessor\n       --  and the spec is a successor. Add all edges to list Edges.\n \n-      procedure Add_Cycle\n-        (G      : Library_Graph;\n-         Attrs  : Library_Graph_Cycle_Attributes;\n-         Indent : Indentation_Level);\n-      pragma Inline (Add_Cycle);\n-      --  Store a cycle described by attributes Attrs in library graph G,\n-      --  unless a prior rotation of it already exists. The edges of the cycle\n-      --  must be in normalized form. Indent is the desired indentation level\n-      --  for tracing.\n-\n       function Add_Edge_With_Return\n         (G              : Library_Graph;\n          Pred           : Library_Graph_Vertex_Id;\n@@ -1070,16 +1072,6 @@ package body Bindo.Graphs is\n       --  involves a task activation. If Pred and Succ are already related,\n       --  no edge is created and No_Library_Graph_Edge is returned.\n \n-      procedure Add_Vertex_And_Complement\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Set           : LGV_Sets.Membership_Set;\n-         Do_Complement : Boolean);\n-      pragma Inline (Add_Vertex_And_Complement);\n-      --  Add vertex Vertex of library graph G to set Set. If the vertex is\n-      --  part of an Elaborate_Body pair, or flag Do_Complement is set, add\n-      --  the complementary vertex to the set.\n-\n       function At_Least_One_Edge_Satisfies\n         (G         : Library_Graph;\n          Cycle     : Library_Graph_Cycle_Id;\n@@ -1094,13 +1086,48 @@ package body Bindo.Graphs is\n       pragma Inline (Copy_Cycle_Path);\n       --  Create a deep copy of list Cycle_Path\n \n+      function Cycle_End_Vertices\n+        (G                    : Library_Graph;\n+         Vertex               : Library_Graph_Vertex_Id;\n+         Elaborate_All_Active : Boolean) return LGV_Sets.Membership_Set;\n+      pragma Inline (Cycle_End_Vertices);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Collect the vertices that terminate a cycle starting\n+      --  from vertex Vertex of library graph G in a set. This is usually the\n+      --  vertex itself, unless the vertex is part of an Elaborate_Body pair,\n+      --  or flag Elaborate_All_Active is set. In that case the complementary\n+      --  vertex is also added to the set.\n+\n       function Cycle_Kind_Of\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Library_Graph_Cycle_Kind;\n       pragma Inline (Cycle_Kind_Of);\n       --  Determine the cycle kind of edge Edge of library graph G if the edge\n       --  participated in a circuit.\n \n+      function Cycle_Kind_Precedence\n+        (Kind        : Library_Graph_Cycle_Kind;\n+         Compared_To : Library_Graph_Cycle_Kind) return Precedence_Kind;\n+      pragma Inline (Cycle_Kind_Precedence);\n+      --  Determine the precedence of cycle kind Kind compared to cycle kind\n+      --  Compared_To.\n+\n+      function Cycle_Path_Precedence\n+        (G           : Library_Graph;\n+         Path        : LGE_Lists.Doubly_Linked_List;\n+         Compared_To : LGE_Lists.Doubly_Linked_List) return Precedence_Kind;\n+      pragma Inline (Cycle_Path_Precedence);\n+      --  Determine the precedence of cycle path Path of library graph G\n+      --  compared to path Compared_To.\n+\n+      function Cycle_Precedence\n+        (G           : Library_Graph;\n+         Cycle       : Library_Graph_Cycle_Id;\n+         Compared_To : Library_Graph_Cycle_Id) return Precedence_Kind;\n+      pragma Inline (Cycle_Precedence);\n+      --  Determine the precedence of cycle Cycle of library graph G compared\n+      --  to cycle Compared_To.\n+\n       procedure Decrement_Library_Graph_Edge_Count\n         (G    : Library_Graph;\n          Kind : Library_Graph_Edge_Kind);\n@@ -1121,40 +1148,133 @@ package body Bindo.Graphs is\n       pragma Inline (Delete_Edge);\n       --  Delete edge Edge from library graph G\n \n-      procedure Find_All_Cycles_Through_Vertex\n-        (G                      : Library_Graph;\n-         Vertex                 : Library_Graph_Vertex_Id;\n-         End_Vertices           : LGV_Sets.Membership_Set;\n-         Most_Significant_Edge  : Library_Graph_Edge_Id;\n-         Invocation_Edge_Count  : Natural;\n-         Spec_And_Body_Together : Boolean;\n-         Cycle_Path             : LGE_Lists.Doubly_Linked_List;\n-         Visited_Vertices       : LGV_Sets.Membership_Set;\n-         Indent                 : Indentation_Level);\n-      pragma Inline (Find_All_Cycles_Through_Vertex);\n-      --  Explore all edges to successors of vertex Vertex of library graph G\n-      --  in an attempt to find a cycle. A cycle is considered closed when the\n-      --  Vertex appears in set End_Vertices. Most_Significant_Edge denotes the\n-      --  edge with the highest significance along the candidate cycle path.\n-      --  Invocation_Edge_Count denotes the number of invocation edges along\n-      --  the candidate cycle path. Spec_And_Body_Together should be set when\n-      --  spec and body vertices must be treated as one vertex. Cycle_Path is\n-      --  the candidate cycle path. Visited_Vertices denotes the set of visited\n-      --  vertices so far. Indent is the desired indentation level for tracing.\n-\n-      procedure Find_All_Cycles_With_Edge\n-        (G                      : Library_Graph;\n-         Initial_Edge           : Library_Graph_Edge_Id;\n-         Spec_And_Body_Together : Boolean;\n-         Cycle_Path             : LGE_Lists.Doubly_Linked_List;\n-         Visited_Vertices       : LGV_Sets.Membership_Set;\n-         Indent                 : Indentation_Level);\n-      pragma Inline (Find_All_Cycles_With_Edge);\n-      --  Find all cycles which contain edge Initial_Edge of library graph G.\n-      --  Spec_And_Body_Together should be set when spec and body vertices must\n-      --  be treated as one vertex. Cycle_Path is the candidate cycle path.\n-      --  Visited_Vertices is the set of visited vertices so far. Indent is\n-      --  the desired indentation level for tracing.\n+      function Edge_Precedence\n+        (G           : Library_Graph;\n+         Edge        : Library_Graph_Edge_Id;\n+         Compared_To : Library_Graph_Edge_Id) return Precedence_Kind;\n+      pragma Inline (Edge_Precedence);\n+      --  Determine the precedence of edge Edge of library graph G compared to\n+      --  edge Compared_To.\n+\n+      procedure Find_Cycles_From_Successor\n+        (G                     : Library_Graph;\n+         Edge                  : Library_Graph_Edge_Id;\n+         End_Vertices          : LGV_Sets.Membership_Set;\n+         Deleted_Vertices      : LGV_Sets.Membership_Set;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path_Stack      : LGE_Lists.Doubly_Linked_List;\n+         Visited_Set           : LGV_Sets.Membership_Set;\n+         Visited_Stack         : LGV_Lists.Doubly_Linked_List;\n+         Cycle_Count           : in out Natural;\n+         Cycle_Limit           : Natural;\n+         Elaborate_All_Active  : Boolean;\n+         Has_Cycle             : out Boolean;\n+         Indent                : Indentation_Level);\n+      pragma Inline (Find_Cycles_From_Successor);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Find all cycles from the successor indicated by edge\n+      --  Edge of library graph G. If at least one cycle exists, set Has_Cycle\n+      --  to True. The remaining parameters are as follows:\n+      --\n+      --    * End vertices is the set of vertices that terminate a potential\n+      --      cycle.\n+      --\n+      --    * Deleted vertices is the set of vertices that have been expended\n+      --      during previous depth-first searches and should not be visited\n+      --      for the rest of the algorithm.\n+      --\n+      --    * Most_Significant_Edge is the current highest precedence edge on\n+      --      the path of the potential cycle.\n+      --\n+      --    * Invocation_Edge_Count is the number of invocation edges on the\n+      --      path of the potential cycle.\n+      --\n+      --    * Cycle_Path_Stack is the path of the potential cycle.\n+      --\n+      --    * Visited_Set is the set of vertices that have been visited during\n+      --      the current depth-first search.\n+      --\n+      --    * Visited_Stack maintains the vertices of Visited_Set in a stack\n+      --      for later unvisiting.\n+      --\n+      --    * Cycle_Count is the number of cycles discovered so far.\n+      --\n+      --    * Cycle_Limit is the upper bound of the number of cycles to be\n+      --      discovered.\n+      --\n+      --    * Elaborate_All_Active should be set when the component currently\n+      --      being examined for cycles contains an Elaborate_All edge.\n+      --\n+      --    * Indent in the desired indentation level for tracing.\n+\n+      procedure Find_Cycles_From_Vertex\n+        (G                     : Library_Graph;\n+         Vertex                : Library_Graph_Vertex_Id;\n+         End_Vertices          : LGV_Sets.Membership_Set;\n+         Deleted_Vertices      : LGV_Sets.Membership_Set;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path_Stack      : LGE_Lists.Doubly_Linked_List;\n+         Visited_Set           : LGV_Sets.Membership_Set;\n+         Visited_Stack         : LGV_Lists.Doubly_Linked_List;\n+         Cycle_Count           : in out Natural;\n+         Cycle_Limit           : Natural;\n+         Elaborate_All_Active  : Boolean;\n+         Is_Start_Vertex       : Boolean;\n+         Has_Cycle             : out Boolean;\n+         Indent                : Indentation_Level);\n+      pragma Inline (Find_Cycles_From_Vertex);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Find all cycles from vertex Vertex of library graph\n+      --  G. If at least one cycle exists, set Has_Cycle to True. The remaining\n+      --  parameters are as follows:\n+      --\n+      --    * End_Vertices is the set of vertices that terminate a potential\n+      --      cycle.\n+      --\n+      --    * Deleted_Vertices is the set of vertices that have been expended\n+      --      during previous depth-first searches and should not be visited\n+      --      for the rest of the algorithm.\n+      --\n+      --    * Most_Significant_Edge is the current highest precedence edge on\n+      --      the path of the potential cycle.\n+      --\n+      --    * Invocation_Edge_Count is the number of invocation edges on the\n+      --      path of the potential cycle.\n+      --\n+      --    * Cycle_Path_Stack is the path of the potential cycle.\n+      --\n+      --    * Visited_Set is the set of vertices that have been visited during\n+      --      the current depth-first search.\n+      --\n+      --    * Visited_Stack maintains the vertices of Visited_Set in a stack\n+      --      for later unvisiting.\n+      --\n+      --    * Cycle_Count is the number of cycles discovered so far.\n+      --\n+      --    * Cycle_Limit is the upper bound of the number of cycles to be\n+      --      discovered.\n+      --\n+      --    * Elaborate_All_Active should be set when the component currently\n+      --      being examined for cycles contains an Elaborate_All edge.\n+      --\n+      --    * Indent in the desired indentation level for tracing.\n+\n+      procedure Find_Cycles_In_Component\n+        (G           : Library_Graph;\n+         Comp        : Component_Id;\n+         Cycle_Count : in out Natural;\n+         Cycle_Limit : Natural);\n+      pragma Inline (Find_Cycles_In_Component);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Find all cycles in component Comp of library graph\n+      --  G. The remaining parameters are as follows:\n+      --\n+      --    * Cycle_Count is the number of cycles discovered so far.\n+      --\n+      --    * Cycle_Limit is the upper bound of the number of cycles to be\n+      --      discovered.\n \n       function Find_First_Lower_Precedence_Cycle\n         (G     : Library_Graph;\n@@ -1201,6 +1321,21 @@ package body Bindo.Graphs is\n       --  Determine whether vertex Vertex of library graph G is subject to\n       --  pragma Elaborate_Body.\n \n+      function Has_Elaborate_All_Edge\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Boolean;\n+      pragma Inline (Has_Elaborate_All_Edge);\n+      --  Determine whether component Comp of library graph G contains an\n+      --  Elaborate_All edge that links two vertices in the same component.\n+\n+      function Has_Elaborate_All_Edge\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Has_Elaborate_All_Edge);\n+      --  Determine whether vertex Vertex of library graph G contains an\n+      --  Elaborate_All edge to a successor where both the vertex and the\n+      --  successor reside in the same component.\n+\n       function Highest_Precedence_Edge\n         (G     : Library_Graph;\n          Left  : Library_Graph_Edge_Id;\n@@ -1238,13 +1373,6 @@ package body Bindo.Graphs is\n       --  Initialize on the initial call or re-initialize on subsequent calls\n       --  all components of library graph G.\n \n-      procedure Insert_And_Sort\n-        (G     : Library_Graph;\n-         Cycle : Library_Graph_Cycle_Id);\n-      pragma Inline (Insert_And_Sort);\n-      --  Insert cycle Cycle in library graph G and sort it based on its\n-      --  precedence relative to all recorded cycles.\n-\n       function Is_Cycle_Initiating_Edge\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Boolean;\n@@ -1302,13 +1430,6 @@ package body Bindo.Graphs is\n       --  cycle and is the result of a with dependency between its successor\n       --  and predecessor.\n \n-      function Is_Recorded_Cycle\n-        (G     : Library_Graph;\n-         Attrs : Library_Graph_Cycle_Attributes) return Boolean;\n-      pragma Inline (Is_Recorded_Cycle);\n-      --  Determine whether a cycle described by its attributes Attrs has\n-      --  has already been recorded in library graph G.\n-\n       function Is_Recorded_Edge\n         (G   : Library_Graph;\n          Rel : Predecessor_Successor_Relation) return Boolean;\n@@ -1323,6 +1444,14 @@ package body Bindo.Graphs is\n       --  Determine whether the successor of invocation edge Edge represents a\n       --  unit that was compiled with the static model.\n \n+      function Is_Vertex_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean;\n+      pragma Inline (Is_Vertex_With_Elaborate_Body);\n+      --  Determine whether vertex Vertex of library graph G denotes a spec\n+      --  subject to pragma Elaborate_Body or the completing body of such a\n+      --  spec.\n+\n       function Links_Vertices_In_Same_Component\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Boolean;\n@@ -1338,73 +1467,39 @@ package body Bindo.Graphs is\n       --  Determine whether edge Edge of library graph G is an invocation edge,\n       --  and if it is return Count + 1, otherwise return Count.\n \n-      procedure Normalize_And_Add_Cycle\n-        (G                     : Library_Graph;\n-         Most_Significant_Edge : Library_Graph_Edge_Id;\n-         Invocation_Edge_Count : Natural;\n-         Cycle_Path            : LGE_Lists.Doubly_Linked_List;\n-         Indent                : Indentation_Level);\n-      pragma Inline (Normalize_And_Add_Cycle);\n-      --  Normalize a cycle described by its path Cycle_Path and add it to\n-      --  library graph G. Most_Significant_Edge denotes the edge with the\n-      --  highest significance along the cycle path. Invocation_Edge_Count\n-      --  denotes the number of invocation edges along the cycle path. Indent\n-      --  is the desired indentation level for tracing.\n-\n       procedure Normalize_Cycle_Path\n         (Cycle_Path            : LGE_Lists.Doubly_Linked_List;\n          Most_Significant_Edge : Library_Graph_Edge_Id);\n       pragma Inline (Normalize_Cycle_Path);\n       --  Normalize cycle path Path by rotating it until its starting edge is\n       --  Sig_Edge.\n \n+      procedure Order_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id);\n+      pragma Inline (Order_Cycle);\n+      --  Insert cycle Cycle in library graph G and sort it based on its\n+      --  precedence relative to all recorded cycles.\n+\n       function Path\n         (G     : Library_Graph;\n          Cycle : Library_Graph_Cycle_Id) return LGE_Lists.Doubly_Linked_List;\n       pragma Inline (Path);\n       --  Obtain the path of edges which comprises cycle Cycle of library\n       --  graph G.\n \n-      function Precedence\n-        (G           : Library_Graph;\n-         Cycle       : Library_Graph_Cycle_Id;\n-         Compared_To : Library_Graph_Cycle_Id) return Precedence_Kind;\n-      pragma Inline (Precedence);\n-      --  Determine the precedence of cycle Cycle of library graph G compared\n-      --  to cycle Compared_To.\n-\n-      function Precedence\n-        (Kind        : Library_Graph_Cycle_Kind;\n-         Compared_To : Library_Graph_Cycle_Kind) return Precedence_Kind;\n-      pragma Inline (Precedence);\n-      --  Determine the precedence of cycle kind Kind compared to cycle kind\n-      --  Compared_To.\n-\n-      function Precedence\n-        (G           : Library_Graph;\n-         Edge        : Library_Graph_Edge_Id;\n-         Compared_To : Library_Graph_Edge_Id) return Precedence_Kind;\n-      pragma Inline (Precedence);\n-      --  Determine the precedence of edge Edge of library graph G compared to\n-      --  edge Compared_To.\n-\n-      function Precedence\n-        (G           : Library_Graph;\n-         Vertex      : Library_Graph_Vertex_Id;\n-         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind;\n-      pragma Inline (Precedence);\n-      --  Determine the precedence of vertex Vertex of library graph G compared\n-      --  to vertex Compared_To.\n-\n-      procedure Remove_Vertex_And_Complement\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Set           : LGV_Sets.Membership_Set;\n-         Do_Complement : Boolean);\n-      pragma Inline (Remove_Vertex_And_Complement);\n-      --  Remove vertex Vertex of library graph G from set Set. If the vertex\n-      --  is part of an Elaborate_Body pair, or Do_Complement is set, remove\n-      --  the complementary vertex from the set.\n+      procedure Record_Cycle\n+        (G                     : Library_Graph;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path            : LGE_Lists.Doubly_Linked_List;\n+         Indent                : Indentation_Level);\n+      pragma Inline (Record_Cycle);\n+      --  Normalize a cycle described by its path Cycle_Path and add it to\n+      --  library graph G. Most_Significant_Edge denotes the edge with the\n+      --  highest significance along the cycle path. Invocation_Edge_Count\n+      --  is the number of invocation edges along the cycle path. Indent is\n+      --  the desired indentation level for tracing.\n \n       procedure Set_Component_Attributes\n         (G    : Library_Graph;\n@@ -1420,14 +1515,6 @@ package body Bindo.Graphs is\n       pragma Inline (Set_Corresponding_Vertex);\n       --  Associate vertex Val of library graph G with unit U_Id\n \n-      procedure Set_Is_Recorded_Cycle\n-        (G     : Library_Graph;\n-         Attrs : Library_Graph_Cycle_Attributes;\n-         Val   : Boolean := True);\n-      pragma Inline (Set_Is_Recorded_Cycle);\n-      --  Mark a cycle described by its attributes Attrs as recorded in library\n-      --  graph G depending on value Val.\n-\n       procedure Set_Is_Recorded_Edge\n         (G   : Library_Graph;\n          Rel : Predecessor_Successor_Relation;\n@@ -1457,6 +1544,14 @@ package body Bindo.Graphs is\n       pragma Inline (Set_LGV_Attributes);\n       --  Set the attributes of vertex Vertex of library graph G to value Val\n \n+      procedure Trace_Component\n+        (G      : Library_Graph;\n+         Comp   : Component_Id;\n+         Indent : Indentation_Level);\n+      pragma Inline (Trace_Component);\n+      --  Write the contents of component Comp of library graph G to standard\n+      --  output. Indent is the desired indentation level for tracing.\n+\n       procedure Trace_Cycle\n         (G      : Library_Graph;\n          Cycle  : Library_Graph_Cycle_Id;\n@@ -1473,10 +1568,6 @@ package body Bindo.Graphs is\n       --  Write the contents of edge Edge of library graph G to standard\n       --  output. Indent is the desired indentation level for tracing.\n \n-      procedure Trace_Eol;\n-      pragma Inline (Trace_Eol);\n-      --  Write an end-of-line to standard output\n-\n       procedure Trace_Vertex\n         (G      : Library_Graph;\n          Vertex : Library_Graph_Vertex_Id;\n@@ -1485,6 +1576,15 @@ package body Bindo.Graphs is\n       --  Write the contents of vertex Vertex of library graph G to standard\n       --  output. Indent is the desired indentation level for tracing.\n \n+      procedure Unvisit\n+        (Vertex        : Library_Graph_Vertex_Id;\n+         Visited_Set   : LGV_Sets.Membership_Set;\n+         Visited_Stack : LGV_Lists.Doubly_Linked_List);\n+      pragma Inline (Unvisit);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Unwind the Visited_Stack by removing the top vertex\n+      --  from set Visited_Set until vertex Vertex is reached, inclusive.\n+\n       procedure Update_Pending_Predecessors\n         (Strong_Predecessors : in out Natural;\n          Weak_Predecessors   : in out Natural;\n@@ -1508,6 +1608,23 @@ package body Bindo.Graphs is\n       --  LGE_Is's successor vertex of library graph G must wait on before\n       --  it can be elaborated.\n \n+      function Vertex_Precedence\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind;\n+      pragma Inline (Vertex_Precedence);\n+      --  Determine the precedence of vertex Vertex of library graph G compared\n+      --  to vertex Compared_To.\n+\n+      procedure Visit\n+        (Vertex        : Library_Graph_Vertex_Id;\n+         Visited_Set   : LGV_Sets.Membership_Set;\n+         Visited_Stack : LGV_Lists.Doubly_Linked_List);\n+      pragma Inline (Visit);\n+      --  Part of Tarjan's enumeration of the elementary circuits of a directed\n+      --  graph algorithm. Push vertex Vertex on the Visited_Stack and add it\n+      --  to set Visited_Set.\n+\n       --------------------\n       -- Activates_Task --\n       --------------------\n@@ -1616,44 +1733,6 @@ package body Bindo.Graphs is\n          end loop;\n       end Add_Body_Before_Spec_Edges;\n \n-      ---------------\n-      -- Add_Cycle --\n-      ---------------\n-\n-      procedure Add_Cycle\n-        (G      : Library_Graph;\n-         Attrs  : Library_Graph_Cycle_Attributes;\n-         Indent : Indentation_Level)\n-      is\n-         Cycle : Library_Graph_Cycle_Id;\n-\n-      begin\n-         pragma Assert (Present (G));\n-\n-         --  Nothing to do when the cycle has already been recorded, possibly\n-         --  in a rotated form.\n-\n-         if Is_Recorded_Cycle (G, Attrs) then\n-            return;\n-         end if;\n-\n-         --  Mark the cycle as recorded. This prevents further attempts to add\n-         --  rotations of the same cycle.\n-\n-         Set_Is_Recorded_Cycle (G, Attrs);\n-\n-         --  Save the attributes of the cycle\n-\n-         Cycle := Sequence_Next_Cycle;\n-         Set_LGC_Attributes (G, Cycle, Attrs);\n-\n-         Trace_Cycle (G, Cycle, Indent);\n-\n-         --  Insert the cycle in the list of all cycle based on its precedence\n-\n-         Insert_And_Sort (G, Cycle);\n-      end Add_Cycle;\n-\n       --------------\n       -- Add_Edge --\n       --------------\n@@ -1799,34 +1878,6 @@ package body Bindo.Graphs is\n          Set_Corresponding_Vertex (G, U_Id, Vertex);\n       end Add_Vertex;\n \n-      -------------------------------\n-      -- Add_Vertex_And_Complement --\n-      -------------------------------\n-\n-      procedure Add_Vertex_And_Complement\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Set           : LGV_Sets.Membership_Set;\n-         Do_Complement : Boolean)\n-      is\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n-         pragma Assert (LGV_Sets.Present (Set));\n-\n-         Complement : constant Library_Graph_Vertex_Id :=\n-                        Complementary_Vertex\n-                          (G                => G,\n-                           Vertex           => Vertex,\n-                           Force_Complement => Do_Complement);\n-\n-      begin\n-         LGV_Sets.Insert (Set, Vertex);\n-\n-         if Present (Complement) then\n-            LGV_Sets.Insert (Set, Complement);\n-         end if;\n-      end Add_Vertex_And_Complement;\n-\n       ---------------------------------\n       -- At_Least_One_Edge_Satisfies --\n       ---------------------------------\n@@ -2051,14 +2102,56 @@ package body Bindo.Graphs is\n            DG.Create\n              (Initial_Vertices => Initial_Vertices,\n               Initial_Edges    => Initial_Edges);\n-         G.Recorded_Cycles      := RC_Sets.Create          (Initial_Vertices);\n          G.Recorded_Edges       := RE_Sets.Create          (Initial_Edges);\n          G.Unit_To_Vertex       := Unit_Tables.Create      (Initial_Vertices);\n          G.Vertex_Attributes    := LGV_Tables.Create       (Initial_Vertices);\n \n          return G;\n       end Create;\n \n+      ------------------------\n+      -- Cycle_End_Vertices --\n+      ------------------------\n+\n+      function Cycle_End_Vertices\n+        (G                    : Library_Graph;\n+         Vertex               : Library_Graph_Vertex_Id;\n+         Elaborate_All_Active : Boolean) return LGV_Sets.Membership_Set\n+      is\n+         Complement   : Library_Graph_Vertex_Id;\n+         End_Vertices : LGV_Sets.Membership_Set := LGV_Sets.Nil;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         End_Vertices := LGV_Sets.Create (2);\n+\n+         --  The input vertex always terminates a cycle path\n+\n+         LGV_Sets.Insert (End_Vertices, Vertex);\n+\n+         --  Add the complementary vertex to the set of cycle terminating\n+         --  vertices when either Elaborate_All is in effect, or the input\n+         --  vertex is part of an Elaborat_Body pair.\n+\n+         if Elaborate_All_Active\n+           or else Is_Vertex_With_Elaborate_Body (G, Vertex)\n+         then\n+            Complement :=\n+              Complementary_Vertex\n+                (G                => G,\n+                 Vertex           => Vertex,\n+                 Force_Complement => Elaborate_All_Active);\n+\n+            if Present (Complement) then\n+               LGV_Sets.Insert (End_Vertices, Complement);\n+            end if;\n+         end if;\n+\n+         return End_Vertices;\n+      end Cycle_End_Vertices;\n+\n       -------------------\n       -- Cycle_Kind_Of --\n       -------------------\n@@ -2091,84 +2184,252 @@ package body Bindo.Graphs is\n          end if;\n       end Cycle_Kind_Of;\n \n-      ----------------------------------------\n-      -- Decrement_Library_Graph_Edge_Count --\n-      ----------------------------------------\n+      ---------------------------\n+      -- Cycle_Kind_Precedence --\n+      ---------------------------\n \n-      procedure Decrement_Library_Graph_Edge_Count\n-        (G    : Library_Graph;\n-         Kind : Library_Graph_Edge_Kind)\n+      function Cycle_Kind_Precedence\n+        (Kind        : Library_Graph_Cycle_Kind;\n+         Compared_To : Library_Graph_Cycle_Kind) return Precedence_Kind\n       is\n-         pragma Assert (Present (G));\n-\n-         Count : Natural renames G.Counts (Kind);\n+         Comp_Pos : constant Integer :=\n+                      Library_Graph_Cycle_Kind'Pos (Compared_To);\n+         Kind_Pos : constant Integer := Library_Graph_Cycle_Kind'Pos (Kind);\n \n       begin\n-         Count := Count - 1;\n-      end Decrement_Library_Graph_Edge_Count;\n+         --  A lower ordinal indicates a higher precedence\n \n-      ------------------------------------\n-      -- Decrement_Pending_Predecessors --\n-      ------------------------------------\n+         if Kind_Pos < Comp_Pos then\n+            return Higher_Precedence;\n \n-      procedure Decrement_Pending_Predecessors\n-        (G    : Library_Graph;\n-         Comp : Component_Id;\n-         Edge : Library_Graph_Edge_Id)\n-      is\n-         Attrs : Component_Attributes;\n+         elsif Kind_Pos > Comp_Pos then\n+            return Lower_Precedence;\n \n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Comp));\n+         else\n+            return Equal_Precedence;\n+         end if;\n+      end Cycle_Kind_Precedence;\n \n-         Attrs := Get_Component_Attributes (G, Comp);\n+      ---------------------------\n+      -- Cycle_Path_Precedence --\n+      ---------------------------\n \n-         Update_Pending_Predecessors\n-           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n-            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n-            Update_Weak         => Is_Invocation_Edge (G, Edge),\n-            Value               => -1);\n+      function Cycle_Path_Precedence\n+        (G           : Library_Graph;\n+         Path        : LGE_Lists.Doubly_Linked_List;\n+         Compared_To : LGE_Lists.Doubly_Linked_List) return Precedence_Kind\n+      is\n+         procedure Next_Available\n+           (Iter : in out LGE_Lists.Iterator;\n+            Edge : out Library_Graph_Edge_Id);\n+         pragma Inline (Next_Available);\n+         --  Obtain the next edge available through iterator Iter, or return\n+         --  No_Library_Graph_Edge if the iterator has been exhausted.\n+\n+         --------------------\n+         -- Next_Available --\n+         --------------------\n+\n+         procedure Next_Available\n+           (Iter : in out LGE_Lists.Iterator;\n+            Edge : out Library_Graph_Edge_Id)\n+         is\n+         begin\n+            --  Assume that the iterator has been exhausted\n+\n+            Edge := No_Library_Graph_Edge;\n+\n+            if LGE_Lists.Has_Next (Iter) then\n+               LGE_Lists.Next (Iter, Edge);\n+            end if;\n+         end Next_Available;\n \n-         Set_Component_Attributes (G, Comp, Attrs);\n-      end Decrement_Pending_Predecessors;\n+         --  Local variables\n \n-      ------------------------------------\n-      -- Decrement_Pending_Predecessors --\n-      ------------------------------------\n+         Comp_Edge : Library_Graph_Edge_Id;\n+         Comp_Iter : LGE_Lists.Iterator;\n+         Path_Edge : Library_Graph_Edge_Id;\n+         Path_Iter : LGE_Lists.Iterator;\n+         Prec      : Precedence_Kind;\n \n-      procedure Decrement_Pending_Predecessors\n-        (G      : Library_Graph;\n-         Vertex : Library_Graph_Vertex_Id;\n-         Edge   : Library_Graph_Edge_Id)\n-      is\n-         Attrs : Library_Graph_Vertex_Attributes;\n+      --  Start of processing for Cycle_Path_Precedence\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n+         pragma Assert (LGE_Lists.Present (Path));\n+         pragma Assert (LGE_Lists.Present (Compared_To));\n \n-         Attrs := Get_LGV_Attributes (G, Vertex);\n+         --  Assume that the paths have equal precedence\n \n-         Update_Pending_Predecessors\n-           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n-            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n-            Update_Weak         => Is_Invocation_Edge (G, Edge),\n-            Value               => -1);\n+         Prec := Equal_Precedence;\n \n-         Set_LGV_Attributes (G, Vertex, Attrs);\n-      end Decrement_Pending_Predecessors;\n+         Comp_Iter := LGE_Lists.Iterate (Compared_To);\n+         Path_Iter := LGE_Lists.Iterate (Path);\n \n-      -----------------------------------\n-      -- Delete_Body_Before_Spec_Edges --\n-      -----------------------------------\n+         Next_Available (Comp_Iter, Comp_Edge);\n+         Next_Available (Path_Iter, Path_Edge);\n \n-      procedure Delete_Body_Before_Spec_Edges\n-        (G     : Library_Graph;\n-         Edges : LGE_Lists.Doubly_Linked_List)\n-      is\n-         Edge : Library_Graph_Edge_Id;\n-         Iter : LGE_Lists.Iterator;\n+         --  IMPORTANT:\n+         --\n+         --    * The iteration must run to completion in order to unlock the\n+         --      edges of both paths.\n+\n+         while Present (Comp_Edge) or else Present (Path_Edge) loop\n+            if Prec = Equal_Precedence\n+              and then Present (Comp_Edge)\n+              and then Present (Path_Edge)\n+            then\n+               Prec :=\n+                 Edge_Precedence\n+                   (G           => G,\n+                    Edge        => Path_Edge,\n+                    Compared_To => Comp_Edge);\n+            end if;\n+\n+            Next_Available (Comp_Iter, Comp_Edge);\n+            Next_Available (Path_Iter, Path_Edge);\n+         end loop;\n+\n+         return Prec;\n+      end Cycle_Path_Precedence;\n+\n+      ----------------------\n+      -- Cycle_Precedence --\n+      ----------------------\n+\n+      function Cycle_Precedence\n+        (G           : Library_Graph;\n+         Cycle       : Library_Graph_Cycle_Id;\n+         Compared_To : Library_Graph_Cycle_Id) return Precedence_Kind\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Cycle));\n+         pragma Assert (Present (Compared_To));\n+\n+         Comp_Invs  : constant Natural :=\n+                        Invocation_Edge_Count (G, Compared_To);\n+         Comp_Len   : constant Natural := Length (G, Compared_To);\n+         Cycle_Invs : constant Natural := Invocation_Edge_Count (G, Cycle);\n+         Cycle_Len  : constant Natural := Length (G, Cycle);\n+         Kind_Prec  : constant Precedence_Kind :=\n+                        Cycle_Kind_Precedence\n+                          (Kind        => Kind (G, Cycle),\n+                           Compared_To => Kind (G, Compared_To));\n+\n+      begin\n+         --  Prefer a cycle with higher precedence based on its kind\n+\n+         if Kind_Prec = Higher_Precedence\n+              or else\n+            Kind_Prec = Lower_Precedence\n+         then\n+            return Kind_Prec;\n+\n+         --  Prefer a shorter cycle\n+\n+         elsif Cycle_Len < Comp_Len then\n+            return Higher_Precedence;\n+\n+         elsif Cycle_Len > Comp_Len then\n+            return Lower_Precedence;\n+\n+         --  Prefer a cycle wih fewer invocation edges\n+\n+         elsif Cycle_Invs < Comp_Invs then\n+            return Higher_Precedence;\n+\n+         elsif Cycle_Invs > Comp_Invs then\n+            return Lower_Precedence;\n+\n+         --  Prever a cycle with a higher path precedence\n+\n+         else\n+            return\n+              Cycle_Path_Precedence\n+                (G           => G,\n+                 Path        => Path (G, Cycle),\n+                 Compared_To => Path (G, Compared_To));\n+         end if;\n+      end Cycle_Precedence;\n+\n+      ----------------------------------------\n+      -- Decrement_Library_Graph_Edge_Count --\n+      ----------------------------------------\n+\n+      procedure Decrement_Library_Graph_Edge_Count\n+        (G    : Library_Graph;\n+         Kind : Library_Graph_Edge_Kind)\n+      is\n+         pragma Assert (Present (G));\n+\n+         Count : Natural renames G.Counts (Kind);\n+\n+      begin\n+         Count := Count - 1;\n+      end Decrement_Library_Graph_Edge_Count;\n+\n+      ------------------------------------\n+      -- Decrement_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G    : Library_Graph;\n+         Comp : Component_Id;\n+         Edge : Library_Graph_Edge_Id)\n+      is\n+         Attrs : Component_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Attrs := Get_Component_Attributes (G, Comp);\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => -1);\n+\n+         Set_Component_Attributes (G, Comp, Attrs);\n+      end Decrement_Pending_Predecessors;\n+\n+      ------------------------------------\n+      -- Decrement_Pending_Predecessors --\n+      ------------------------------------\n+\n+      procedure Decrement_Pending_Predecessors\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id;\n+         Edge   : Library_Graph_Edge_Id)\n+      is\n+         Attrs : Library_Graph_Vertex_Attributes;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         Attrs := Get_LGV_Attributes (G, Vertex);\n+\n+         Update_Pending_Predecessors\n+           (Strong_Predecessors => Attrs.Pending_Strong_Predecessors,\n+            Weak_Predecessors   => Attrs.Pending_Weak_Predecessors,\n+            Update_Weak         => Is_Invocation_Edge (G, Edge),\n+            Value               => -1);\n+\n+         Set_LGV_Attributes (G, Vertex, Attrs);\n+      end Decrement_Pending_Predecessors;\n+\n+      -----------------------------------\n+      -- Delete_Body_Before_Spec_Edges --\n+      -----------------------------------\n+\n+      procedure Delete_Body_Before_Spec_Edges\n+        (G     : Library_Graph;\n+         Edges : LGE_Lists.Doubly_Linked_List)\n+      is\n+         Edge : Library_Graph_Edge_Id;\n+         Iter : LGE_Lists.Iterator;\n \n       begin\n          pragma Assert (Present (G));\n@@ -2240,7 +2501,6 @@ package body Bindo.Graphs is\n          LGC_Lists.Destroy        (G.Cycles);\n          LGE_Tables.Destroy       (G.Edge_Attributes);\n          DG.Destroy               (G.Graph);\n-         RC_Sets.Destroy          (G.Recorded_Cycles);\n          RE_Sets.Destroy          (G.Recorded_Edges);\n          Unit_Tables.Destroy      (G.Unit_To_Vertex);\n          LGV_Tables.Destroy       (G.Vertex_Attributes);\n@@ -2283,18 +2543,6 @@ package body Bindo.Graphs is\n          null;\n       end Destroy_Library_Graph_Edge_Attributes;\n \n-      ----------------------------------\n-      -- Destroy_Library_Graph_Vertex --\n-      ----------------------------------\n-\n-      procedure Destroy_Library_Graph_Vertex\n-        (Vertex : in out Library_Graph_Vertex_Id)\n-      is\n-         pragma Unreferenced (Vertex);\n-      begin\n-         null;\n-      end Destroy_Library_Graph_Vertex;\n-\n       ---------------------------------------------\n       -- Destroy_Library_Graph_Vertex_Attributes --\n       ---------------------------------------------\n@@ -2307,6 +2555,62 @@ package body Bindo.Graphs is\n          null;\n       end Destroy_Library_Graph_Vertex_Attributes;\n \n+      ---------------------\n+      -- Edge_Precedence --\n+      ---------------------\n+\n+      function Edge_Precedence\n+        (G           : Library_Graph;\n+         Edge        : Library_Graph_Edge_Id;\n+         Compared_To : Library_Graph_Edge_Id) return Precedence_Kind\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Edge));\n+         pragma Assert (Present (Compared_To));\n+\n+         Comp_Succ : constant Library_Graph_Vertex_Id :=\n+                       Successor (G, Compared_To);\n+         Edge_Succ : constant Library_Graph_Vertex_Id :=\n+                       Successor (G, Edge);\n+         Kind_Prec : constant Precedence_Kind :=\n+                       Cycle_Kind_Precedence\n+                         (Kind        => Cycle_Kind_Of (G, Edge),\n+                          Compared_To => Cycle_Kind_Of (G, Compared_To));\n+         Succ_Prec : constant Precedence_Kind :=\n+                       Vertex_Precedence\n+                         (G           => G,\n+                          Vertex      => Edge_Succ,\n+                          Compared_To => Comp_Succ);\n+\n+      begin\n+         --  Prefer an edge with a higher cycle kind precedence\n+\n+         if Kind_Prec = Higher_Precedence\n+              or else\n+            Kind_Prec = Lower_Precedence\n+         then\n+            return Kind_Prec;\n+\n+         --  Prefer an edge whose successor has a higher precedence\n+\n+         elsif Comp_Succ /= Edge_Succ\n+           and then (Succ_Prec = Higher_Precedence\n+                       or else\n+                     Succ_Prec = Lower_Precedence)\n+         then\n+            return Succ_Prec;\n+\n+         --  Prefer an edge whose predecessor has a higher precedence\n+\n+         else\n+            return\n+              Vertex_Precedence\n+                (G           => G,\n+                 Vertex      => Predecessor (G, Edge),\n+                 Compared_To => Predecessor (G, Compared_To));\n+         end if;\n+      end Edge_Precedence;\n+\n       ---------------\n       -- File_Name --\n       ---------------\n@@ -2322,320 +2626,512 @@ package body Bindo.Graphs is\n          return File_Name (Unit (G, Vertex));\n       end File_Name;\n \n-      ------------------------------------\n-      -- Find_All_Cycles_Through_Vertex --\n-      ------------------------------------\n+      ---------------------\n+      -- Find_Components --\n+      ---------------------\n \n-      procedure Find_All_Cycles_Through_Vertex\n-        (G                      : Library_Graph;\n-         Vertex                 : Library_Graph_Vertex_Id;\n-         End_Vertices           : LGV_Sets.Membership_Set;\n-         Most_Significant_Edge  : Library_Graph_Edge_Id;\n-         Invocation_Edge_Count  : Natural;\n-         Spec_And_Body_Together : Boolean;\n-         Cycle_Path             : LGE_Lists.Doubly_Linked_List;\n-         Visited_Vertices       : LGV_Sets.Membership_Set;\n-         Indent                 : Indentation_Level)\n-      is\n-         Edge_Indent : constant Indentation_Level :=\n-                         Indent + Nested_Indentation;\n+      procedure Find_Components (G : Library_Graph) is\n+         Edges : LGE_Lists.Doubly_Linked_List;\n+\n+      begin\n+         pragma Assert (Present (G));\n+\n+         --  Initialize or reinitialize the components of the graph\n+\n+         Initialize_Components (G);\n+\n+         --  Create a set of special edges that link a predecessor body with a\n+         --  successor spec. This is an illegal dependency, however using such\n+         --  edges eliminates the need to create yet another graph, where both\n+         --  spec and body are collapsed into a single vertex.\n+\n+         Edges := LGE_Lists.Create;\n+         Add_Body_Before_Spec_Edges (G, Edges);\n+\n+         DG.Find_Components (G.Graph);\n+\n+         --  Remove the special edges that link a predecessor body with a\n+         --  successor spec because they cause unresolvable circularities.\n \n-         Iter      : Edges_To_Successors_Iterator;\n-         Next_Edge : Library_Graph_Edge_Id;\n+         Delete_Body_Before_Spec_Edges (G, Edges);\n+         LGE_Lists.Destroy (Edges);\n+\n+         --  Update the number of predecessors various components must wait on\n+         --  before they can be elaborated.\n+\n+         Update_Pending_Predecessors_Of_Components (G);\n+      end Find_Components;\n+\n+      -----------------\n+      -- Find_Cycles --\n+      -----------------\n+\n+      procedure Find_Cycles (G : Library_Graph) is\n+         All_Cycle_Limit : constant Natural := 64;\n+         --  The performance of Tarjan's algorithm may degrate to exponential\n+         --  when pragma Elaborate_All is in effect, or some vertex is part of\n+         --  an Elaborate_Body pair. In this case the algorithm discovers all\n+         --  combinations of edges that close a circuit starting and ending on\n+         --  some start vertex while going through different vertices. Use a\n+         --  limit on the total number of cycles within a component to guard\n+         --  against such degradation.\n+\n+         Comp        : Component_Id;\n+         Cycle_Count : Natural;\n+         Iter        : Component_Iterator;\n \n       begin\n          pragma Assert (Present (G));\n-         pragma Assert (LGV_Sets.Present (End_Vertices));\n-         pragma Assert (Present (Most_Significant_Edge));\n-         pragma Assert (LGE_Lists.Present (Cycle_Path));\n-         pragma Assert (LGV_Sets.Present (Visited_Vertices));\n \n-         --  Nothing to do when there is no vertex\n+         --  The cycles of graph G are discovered using Tarjan's enumeration\n+         --  of the elementary circuits of a directed graph algorithm. Do not\n+         --  modify this code unless you intimately understand the algorithm.\n+         --\n+         --  The logic of the algorithm is split among the following routines:\n+         --\n+         --    Cycle_End_Vertices\n+         --    Find_Cycles_From_Successor\n+         --    Find_Cycles_From_Vertex\n+         --    Find_Cycles_In_Component\n+         --    Unvisit\n+         --    Visit\n+         --\n+         --  The original algorithm has been significantly modified in order to\n+         --\n+         --    * Accomodate the semantics of Elaborate_All and Elaborate_Body.\n+         --\n+         --    * Capture cycle paths as edges rather than vertices.\n+         --\n+         --    * Take advantage of graph components.\n \n-         if not Present (Vertex) then\n-            return;\n-         end if;\n+         --  Assume that the graph does not contain a cycle\n \n-         --  The current vertex denotes the end vertex of the cycle and closes\n-         --  the circuit. Normalize the cycle such that it is rotated with its\n-         --  most significant edge first, and record it for diagnostics.\n+         Cycle_Count := 0;\n \n-         if LGV_Sets.Contains (End_Vertices, Vertex) then\n-            Trace_Vertex (G, Vertex, Indent);\n+         --  Run the modified version of the algorithm on each component of the\n+         --  graph.\n \n-            Normalize_And_Add_Cycle\n-              (G                     => G,\n-               Most_Significant_Edge => Most_Significant_Edge,\n-               Invocation_Edge_Count => Invocation_Edge_Count,\n-               Cycle_Path            => Cycle_Path,\n-               Indent                => Indent + Nested_Indentation);\n+         Iter := Iterate_Components (G);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Comp);\n \n-         --  Otherwise extend the search for a cycle only when the vertex has\n-         --  not been visited yet.\n+            Find_Cycles_In_Component\n+              (G           => G,\n+               Comp        => Comp,\n+               Cycle_Count => Cycle_Count,\n+               Cycle_Limit => All_Cycle_Limit);\n+         end loop;\n+      end Find_Cycles;\n \n-         elsif not LGV_Sets.Contains (Visited_Vertices, Vertex) then\n-            Trace_Vertex (G, Vertex, Indent);\n+      --------------------------------\n+      -- Find_Cycles_From_Successor --\n+      --------------------------------\n+\n+      procedure Find_Cycles_From_Successor\n+        (G                     : Library_Graph;\n+         Edge                  : Library_Graph_Edge_Id;\n+         End_Vertices          : LGV_Sets.Membership_Set;\n+         Deleted_Vertices      : LGV_Sets.Membership_Set;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path_Stack      : LGE_Lists.Doubly_Linked_List;\n+         Visited_Set           : LGV_Sets.Membership_Set;\n+         Visited_Stack         : LGV_Lists.Doubly_Linked_List;\n+         Cycle_Count           : in out Natural;\n+         Cycle_Limit           : Natural;\n+         Elaborate_All_Active  : Boolean;\n+         Has_Cycle             : out Boolean;\n+         Indent                : Indentation_Level)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Edge));\n+         pragma Assert (LGV_Sets.Present  (End_Vertices));\n+         pragma Assert (LGV_Sets.Present  (Deleted_Vertices));\n+         pragma Assert (LGE_Lists.Present (Cycle_Path_Stack));\n+         pragma Assert (LGV_Sets.Present  (Visited_Set));\n+         pragma Assert (LGV_Lists.Present (Visited_Stack));\n+\n+         Succ        : constant Library_Graph_Vertex_Id := Successor (G, Edge);\n+         Succ_Indent : constant Indentation_Level       :=\n+                         Indent + Nested_Indentation;\n+\n+      begin\n+         --  Assume that the successor reached via the edge does not result in\n+         --  a cycle.\n+\n+         Has_Cycle := False;\n+\n+         --  Nothing to do when the edge connects two vertices residing in two\n+         --  different components.\n+\n+         if not Is_Cyclic_Edge (G, Edge) then\n+            return;\n+         end if;\n \n-            --  Prepare for vertex backtracking\n+         Trace_Edge (G, Edge, Indent);\n+\n+         --  The modified version does not place vertices on the \"point stack\",\n+         --  but instead collects the edges comprising the cycle. Prepare the\n+         --  edge for backtracking.\n+\n+         LGE_Lists.Prepend (Cycle_Path_Stack, Edge);\n+\n+         Find_Cycles_From_Vertex\n+           (G                     => G,\n+            Vertex                => Succ,\n+            End_Vertices          => End_Vertices,\n+            Deleted_Vertices      => Deleted_Vertices,\n+            Most_Significant_Edge => Most_Significant_Edge,\n+            Invocation_Edge_Count => Invocation_Edge_Count,\n+            Cycle_Path_Stack      => Cycle_Path_Stack,\n+            Visited_Set           => Visited_Set,\n+            Visited_Stack         => Visited_Stack,\n+            Cycle_Count           => Cycle_Count,\n+            Cycle_Limit           => Cycle_Limit,\n+            Elaborate_All_Active  => Elaborate_All_Active,\n+            Is_Start_Vertex       => False,\n+            Has_Cycle             => Has_Cycle,\n+            Indent                => Succ_Indent);\n+\n+         --  The modified version does not place vertices on the \"point stack\",\n+         --  but instead collects the edges comprising the cycle. Backtrack the\n+         --  edge.\n \n-            LGV_Sets.Insert (Visited_Vertices, Vertex);\n+         LGE_Lists.Delete_First (Cycle_Path_Stack);\n+      end Find_Cycles_From_Successor;\n \n-            --  Extend the search via all edges to successors of the vertex\n+      -----------------------------\n+      -- Find_Cycles_From_Vertex --\n+      -----------------------------\n \n-            Iter := Iterate_Edges_To_Successors (G, Vertex);\n-            while Has_Next (Iter) loop\n-               Next (Iter, Next_Edge);\n+      procedure Find_Cycles_From_Vertex\n+        (G                     : Library_Graph;\n+         Vertex                : Library_Graph_Vertex_Id;\n+         End_Vertices          : LGV_Sets.Membership_Set;\n+         Deleted_Vertices      : LGV_Sets.Membership_Set;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path_Stack      : LGE_Lists.Doubly_Linked_List;\n+         Visited_Set           : LGV_Sets.Membership_Set;\n+         Visited_Stack         : LGV_Lists.Doubly_Linked_List;\n+         Cycle_Count           : in out Natural;\n+         Cycle_Limit           : Natural;\n+         Elaborate_All_Active  : Boolean;\n+         Is_Start_Vertex       : Boolean;\n+         Has_Cycle             : out Boolean;\n+         Indent                : Indentation_Level)\n+      is\n+         Edge_Indent : constant Indentation_Level :=\n+                         Indent + Nested_Indentation;\n+\n+         Complement : Library_Graph_Vertex_Id;\n+         Edge       : Library_Graph_Edge_Id;\n+         Iter       : Edges_To_Successors_Iterator;\n \n-               if Is_Cyclic_Edge (G, Next_Edge) then\n-                  Trace_Edge (G, Next_Edge, Edge_Indent);\n+         Complement_Has_Cycle : Boolean;\n+         --  This flag is set when either Elaborate_All is in effect or the\n+         --  current vertex is part of an Elaborate_Body pair, and visiting\n+         --  the \"complementary\" vertex resulted in a cycle.\n \n-                  --  Prepare for edge backtracking. Prepending ensures that\n-                  --  final ordering of edges can be traversed from successor\n-                  --  to predecessor.\n+         Successor_Has_Cycle : Boolean;\n+         --  This flag is set when visiting at least once successor of the\n+         --  current vertex resulted in a cycle.\n \n-                  LGE_Lists.Prepend (Cycle_Path, Next_Edge);\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (LGV_Sets.Present  (End_Vertices));\n+         pragma Assert (LGV_Sets.Present  (Deleted_Vertices));\n+         pragma Assert (LGE_Lists.Present (Cycle_Path_Stack));\n+         pragma Assert (LGV_Sets.Present  (Visited_Set));\n+         pragma Assert (LGV_Lists.Present (Visited_Stack));\n \n-                  --  Extend the search via the successor of the next edge\n+         --  Assume that the vertex does not close a circuit\n \n-                  Find_All_Cycles_Through_Vertex\n-                    (G                      => G,\n-                     Vertex                 => Successor (G, Next_Edge),\n-                     End_Vertices           => End_Vertices,\n+         Has_Cycle := False;\n \n-                     --  The next edge may be more important than the current\n-                     --  most important edge, thus \"upgrading\" the nature of\n-                     --  the cycle, and shifting its point of normalization.\n+         --  Nothing to do when the limit on the number of saved cycles has\n+         --  been reached. This protects against a combinatorial explostion\n+         --  in components with Elaborate_All cycles.\n \n-                     Most_Significant_Edge  =>\n-                       Highest_Precedence_Edge\n-                         (G     => G,\n-                          Left  => Next_Edge,\n-                          Right => Most_Significant_Edge),\n+         if Cycle_Count >= Cycle_Limit then\n+            return;\n \n-                     --  The next edge may be an invocation edge, in which case\n-                     --  the count of invocation edges increases by one.\n+         --  The vertex closes the circuit, thus resulting in a cycle. Save\n+         --  the cycle for later diagnostics. The initial invocation of the\n+         --  routine always ignores the starting vertex to prevent a spurious\n+         --  self cycle.\n \n-                     Invocation_Edge_Count  =>\n-                       Maximum_Invocation_Edge_Count\n-                         (G     => G,\n-                          Edge  => Next_Edge,\n-                          Count => Invocation_Edge_Count),\n-                     Spec_And_Body_Together => Spec_And_Body_Together,\n-                     Cycle_Path             => Cycle_Path,\n-                     Visited_Vertices       => Visited_Vertices,\n-                     Indent                 => Indent);\n+         elsif not Is_Start_Vertex\n+           and then LGV_Sets.Contains (End_Vertices, Vertex)\n+         then\n+            Trace_Vertex (G, Vertex, Indent);\n \n-                  --  Backtrack the edge\n+            Record_Cycle\n+              (G                     => G,\n+               Most_Significant_Edge => Most_Significant_Edge,\n+               Invocation_Edge_Count => Invocation_Edge_Count,\n+               Cycle_Path            => Cycle_Path_Stack,\n+               Indent                => Indent);\n \n-                  LGE_Lists.Delete_First (Cycle_Path);\n-               end if;\n-            end loop;\n+            Has_Cycle   := True;\n+            Cycle_Count := Cycle_Count + 1;\n+            return;\n \n-            --  Extend the search via the complementary vertex when the current\n-            --  vertex is part of an Elaborate_Body pair, or the initial edge\n-            --  is an Elaborate_All edge.\n+         --  Nothing to do when the vertex has already been deleted. This\n+         --  indicates that all available cycles involving the vertex have\n+         --  been discovered, and the vertex cannot contribute further to\n+         --  the depth-first search.\n \n-            Find_All_Cycles_Through_Vertex\n-              (G                      => G,\n-               Vertex                 =>\n-                 Complementary_Vertex\n-                   (G                => G,\n-                    Vertex           => Vertex,\n-                    Force_Complement => Spec_And_Body_Together),\n-               End_Vertices           => End_Vertices,\n-               Most_Significant_Edge  => Most_Significant_Edge,\n-               Invocation_Edge_Count  => Invocation_Edge_Count,\n-               Spec_And_Body_Together => Spec_And_Body_Together,\n-               Cycle_Path             => Cycle_Path,\n-               Visited_Vertices       => Visited_Vertices,\n-               Indent                 => Indent);\n+         elsif LGV_Sets.Contains (Deleted_Vertices, Vertex) then\n+            return;\n \n-            --  Backtrack the vertex\n+         --  Nothing to do when the vertex has already been visited. This\n+         --  indicates that the depth-first search initiated from some start\n+         --  vertex already encountered this vertex, and the visited stack has\n+         --  not been unrolled yet.\n \n-            LGV_Sets.Delete (Visited_Vertices, Vertex);\n+         elsif LGV_Sets.Contains (Visited_Set, Vertex) then\n+            return;\n          end if;\n-      end Find_All_Cycles_Through_Vertex;\n \n-      -------------------------------\n-      -- Find_All_Cycles_With_Edge --\n-      -------------------------------\n-\n-      procedure Find_All_Cycles_With_Edge\n-        (G                      : Library_Graph;\n-         Initial_Edge           : Library_Graph_Edge_Id;\n-         Spec_And_Body_Together : Boolean;\n-         Cycle_Path             : LGE_Lists.Doubly_Linked_List;\n-         Visited_Vertices       : LGV_Sets.Membership_Set;\n-         Indent                 : Indentation_Level)\n-      is\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Initial_Edge));\n-         pragma Assert (LGE_Lists.Present (Cycle_Path));\n-         pragma Assert (LGV_Sets.Present (Visited_Vertices));\n+         Trace_Vertex (G, Vertex, Indent);\n \n-         Pred : constant Library_Graph_Vertex_Id :=\n-                           Predecessor (G, Initial_Edge);\n-         Succ : constant Library_Graph_Vertex_Id :=\n-                           Successor   (G, Initial_Edge);\n+         --  Mark the vertex as visited\n \n-         End_Vertices : LGV_Sets.Membership_Set;\n+         Visit\n+           (Vertex        => Vertex,\n+            Visited_Set   => Visited_Set,\n+            Visited_Stack => Visited_Stack);\n \n-      begin\n-         Trace_Edge (G, Initial_Edge, Indent);\n+         --  Extend the depth-first search via all the edges to successors\n \n-         --  Use a set to represent the end vertices of the cycle. The set is\n-         --  needed to accommodate the Elaborate_All and Elaborate_Body cases\n-         --  where a cycle may terminate on either a spec or a body vertex.\n+         Iter := Iterate_Edges_To_Successors (G, Vertex);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n \n-         End_Vertices := LGV_Sets.Create (2);\n-         Add_Vertex_And_Complement\n-           (G             => G,\n-            Vertex        => Pred,\n-            Set           => End_Vertices,\n-            Do_Complement => Spec_And_Body_Together);\n+            Find_Cycles_From_Successor\n+              (G                     => G,\n+               Edge                  => Edge,\n+               End_Vertices          => End_Vertices,\n+               Deleted_Vertices      => Deleted_Vertices,\n+\n+               --  The edge may be more important than the most important edge\n+               --  up to this point, thus \"upgrading\" the nature of the cycle,\n+               --  and shifting its point of normalization.\n+\n+               Most_Significant_Edge =>\n+                 Highest_Precedence_Edge\n+                   (G     => G,\n+                    Left  => Edge,\n+                    Right => Most_Significant_Edge),\n+\n+               --  The edge may be an invocation edge, in which case the count\n+               --  of invocation edges increases by one.\n+\n+               Invocation_Edge_Count =>\n+                 Maximum_Invocation_Edge_Count\n+                   (G     => G,\n+                    Edge  => Edge,\n+                    Count => Invocation_Edge_Count),\n+\n+               Cycle_Path_Stack      => Cycle_Path_Stack,\n+               Visited_Set           => Visited_Set,\n+               Visited_Stack         => Visited_Stack,\n+               Cycle_Count           => Cycle_Count,\n+               Cycle_Limit           => Cycle_Limit,\n+               Elaborate_All_Active  => Elaborate_All_Active,\n+               Has_Cycle             => Successor_Has_Cycle,\n+               Indent                => Edge_Indent);\n+\n+            Has_Cycle := Has_Cycle or Successor_Has_Cycle;\n+         end loop;\n \n-         --  Prepare for edge backtracking\n-         --\n-         --  The initial edge starts the path. During the traversal, edges with\n-         --  higher precedence may be discovered, in which case they supersede\n-         --  the initial edge in terms of significance. Prepending to the cycle\n-         --  path ensures that the vertices can be visited in the proper order\n-         --  for diagnostics.\n+         --  Visit the complementary vertex of the current vertex when pragma\n+         --  Elaborate_All is in effect, or the current vertex is part of an\n+         --  Elaborate_Body pair.\n \n-         LGE_Lists.Prepend (Cycle_Path, Initial_Edge);\n+         if Elaborate_All_Active\n+           or else Is_Vertex_With_Elaborate_Body (G, Vertex)\n+         then\n+            Complement :=\n+              Complementary_Vertex\n+                (G                => G,\n+                 Vertex           => Vertex,\n+                 Force_Complement => Elaborate_All_Active);\n+\n+            if Present (Complement) then\n+               Find_Cycles_From_Vertex\n+                 (G                     => G,\n+                  Vertex                => Complement,\n+                  End_Vertices          => End_Vertices,\n+                  Deleted_Vertices      => Deleted_Vertices,\n+                  Most_Significant_Edge => Most_Significant_Edge,\n+                  Invocation_Edge_Count => Invocation_Edge_Count,\n+                  Cycle_Path_Stack      => Cycle_Path_Stack,\n+                  Visited_Set           => Visited_Set,\n+                  Visited_Stack         => Visited_Stack,\n+                  Cycle_Count           => Cycle_Count,\n+                  Cycle_Limit           => Cycle_Limit,\n+                  Elaborate_All_Active  => Elaborate_All_Active,\n+                  Is_Start_Vertex       => Is_Start_Vertex,\n+                  Has_Cycle             => Complement_Has_Cycle,\n+                  Indent                => Indent);\n+\n+               Has_Cycle := Has_Cycle or Complement_Has_Cycle;\n+            end if;\n+         end if;\n \n-         --  Prepare for vertex backtracking\n+         --  The original algorithm clears the \"marked stack\" in two places:\n          --\n-         --  The predecessor is considered the terminator of the path. Add it\n-         --  to the set of visited vertices along with its complement vertex\n-         --  in the Elaborate_All and Elaborate_Body cases to prevent infinite\n-         --  recursion.\n-\n-         Add_Vertex_And_Complement\n-           (G             => G,\n-            Vertex        => Pred,\n-            Set           => Visited_Vertices,\n-            Do_Complement => Spec_And_Body_Together);\n-\n-         --  Traverse a potential cycle by continuously visiting successors\n-         --  until either the predecessor of the initial edge is reached, or\n-         --  no more successors are available.\n-\n-         Find_All_Cycles_Through_Vertex\n-           (G                      => G,\n-            Vertex                 => Succ,\n-            End_Vertices           => End_Vertices,\n-            Most_Significant_Edge  => Initial_Edge,\n-            Invocation_Edge_Count  =>\n-              Maximum_Invocation_Edge_Count\n-                (G     => G,\n-                 Edge  => Initial_Edge,\n-                 Count => 0),\n-            Spec_And_Body_Together => Spec_And_Body_Together,\n-            Cycle_Path             => Cycle_Path,\n-            Visited_Vertices       => Visited_Vertices,\n-            Indent                 => Indent + Nested_Indentation);\n-\n-         --  Backtrack the edge\n-\n-         LGE_Lists.Delete_First (Cycle_Path);\n-\n-         --  Backtrack the predecessor, along with the complement vertex in the\n-         --  Elaborate_All and Elaborate_Body cases.\n-\n-         Remove_Vertex_And_Complement\n-           (G             => G,\n-            Vertex        => Pred,\n-            Set           => Visited_Vertices,\n-            Do_Complement => Spec_And_Body_Together);\n-\n-         LGV_Sets.Destroy (End_Vertices);\n-      end Find_All_Cycles_With_Edge;\n-\n-      ---------------------\n-      -- Find_Components --\n-      ---------------------\n+         --     * When the depth-first search starting from the current vertex\n+         --       discovers at least one cycle, and\n+         --\n+         --     * When the depth-first search initiated from a start vertex\n+         --       completes.\n+         --\n+         --  The modified version handles both cases in one place.\n \n-      procedure Find_Components (G : Library_Graph) is\n-         Edges : LGE_Lists.Doubly_Linked_List;\n+         if Has_Cycle or else Is_Start_Vertex then\n+            Unvisit\n+              (Vertex        => Vertex,\n+               Visited_Set   => Visited_Set,\n+               Visited_Stack => Visited_Stack);\n+         end if;\n \n-      begin\n-         pragma Assert (Present (G));\n+         --  Delete a start vertex from the graph once its depth-first search\n+         --  completes. This action preserves the invariant where a cycle is\n+         --  not rediscovered \"later\" in some permuted form.\n \n-         --  Initialize or reinitialize the components of the graph\n+         if Is_Start_Vertex then\n+            LGV_Sets.Insert (Deleted_Vertices, Vertex);\n+         end if;\n+      end Find_Cycles_From_Vertex;\n \n-         Initialize_Components (G);\n+      ------------------------------\n+      -- Find_Cycles_In_Component --\n+      ------------------------------\n \n-         --  Create a set of special edges that link a predecessor body with a\n-         --  successor spec. This is an illegal dependency, however using such\n-         --  edges eliminates the need to create yet another graph, where both\n-         --  spec and body are collapsed into a single vertex.\n+      procedure Find_Cycles_In_Component\n+        (G           : Library_Graph;\n+         Comp        : Component_Id;\n+         Cycle_Count : in out Natural;\n+         Cycle_Limit : Natural)\n+      is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n \n-         Edges := LGE_Lists.Create;\n-         Add_Body_Before_Spec_Edges (G, Edges);\n+         Num_Of_Vertices : constant Natural :=\n+                             Number_Of_Component_Vertices (G, Comp);\n \n-         DG.Find_Components (G.Graph);\n+         Elaborate_All_Active : constant Boolean :=\n+                                  Has_Elaborate_All_Edge (G, Comp);\n+         --  The presence of an Elaborate_All edge within a component causes\n+         --  all spec-body pairs to be treated as one vertex.\n \n-         --  Remove the special edges that link a predecessor body with a\n-         --  successor spec because they cause unresolvable circularities.\n+         Has_Cycle : Boolean;\n+         Iter      : Component_Vertex_Iterator;\n+         Vertex    : Library_Graph_Vertex_Id;\n \n-         Delete_Body_Before_Spec_Edges (G, Edges);\n-         LGE_Lists.Destroy (Edges);\n+         Cycle_Path_Stack : LGE_Lists.Doubly_Linked_List := LGE_Lists.Nil;\n+         --  The \"point stack\" of Tarjan's algorithm. The original maintains\n+         --  a stack of vertices, however for diagnostic purposes using edges\n+         --  is preferable.\n \n-         --  Update the number of predecessors various components must wait on\n-         --  before they can be elaborated.\n+         Deleted_Vertices : LGV_Sets.Membership_Set := LGV_Sets.Nil;\n+         --  The original algorithm alters the graph by deleting vertices with\n+         --  lower ordinals compared to some starting vertex. Since the graph\n+         --  must remain intact for diagnostic purposes, vertices are instead\n+         --  inserted in this set and treated as \"deleted\".\n \n-         Update_Pending_Predecessors_Of_Components (G);\n-      end Find_Components;\n+         End_Vertices : LGV_Sets.Membership_Set := LGV_Sets.Nil;\n+         --  The original algorithm uses a single vertex to indicate the start\n+         --  and end vertex of a cycle. The semantics of pragmas Elaborate_All\n+         --  and Elaborate_Body increase this number by one. The end vertices\n+         --  are added to this set and treated as \"cycle-terminating\".\n \n-      -----------------\n-      -- Find_Cycles --\n-      -----------------\n+         Visited_Set : LGV_Sets.Membership_Set := LGV_Sets.Nil;\n+         --  The \"mark\" array of Tarjan's algorithm. Since the original visits\n+         --  all vertices in increasing ordinal number 1 .. N, the array offers\n+         --  a one to one mapping between a vertex and its \"marked\" state. The\n+         --  modified version however visits vertices within components, where\n+         --  their ordinals are not contiguous. Vertices are added to this set\n+         --  and treated as \"marked\".\n \n-      procedure Find_Cycles (G : Library_Graph) is\n-         Cycle_Path       : LGE_Lists.Doubly_Linked_List;\n-         Edge             : Library_Graph_Edge_Id;\n-         Iter             : All_Edge_Iterator;\n-         Visited_Vertices : LGV_Sets.Membership_Set;\n+         Visited_Stack : LGV_Lists.Doubly_Linked_List := LGV_Lists.Nil;\n+         --  The \"marked stack\" of Tarjan's algorithm\n \n       begin\n-         pragma Assert (Present (G));\n+         Trace_Component (G, Comp, No_Indentation);\n \n-         --  Use a list of edges to describe the path of a cycle\n+         --  Initialize all component-level data structures\n \n-         Cycle_Path := LGE_Lists.Create;\n+         Cycle_Path_Stack := LGE_Lists.Create;\n+         Deleted_Vertices := LGV_Sets.Create (Num_Of_Vertices);\n+         Visited_Set      := LGV_Sets.Create (Num_Of_Vertices);\n+         Visited_Stack    := LGV_Lists.Create;\n \n-         --  Use a set of visited vertices to prevent infinite traversal of the\n-         --  graph.\n-\n-         Visited_Vertices := LGV_Sets.Create (Number_Of_Vertices (G));\n+         --  The modified version does not use ordinals to visit vertices in\n+         --  1 .. N fashion. To preserve the invariant of the original, this\n+         --  version deletes a vertex after its depth-first search completes.\n+         --  The timing of the deletion is sound because all cycles through\n+         --  that vertex have already been discovered, thus the vertex cannot\n+         --  contribute to any cycles discovered \"later\" in the algorithm.\n \n-         --  Inspect all edges, trying to find an edge that links two vertices\n-         --  in the same component.\n-\n-         Iter := Iterate_All_Edges (G);\n+         Iter := Iterate_Component_Vertices (G, Comp);\n          while Has_Next (Iter) loop\n-            Next (Iter, Edge);\n-\n-            --  Find all cycles involving the current edge. Duplicate cycles in\n-            --  the forms of rotations are not saved for diagnostic purposes.\n-\n-            if Is_Cycle_Initiating_Edge (G, Edge) then\n-               Find_All_Cycles_With_Edge\n-                 (G                      => G,\n-                  Initial_Edge           => Edge,\n-                  Spec_And_Body_Together => Is_Elaborate_All_Edge (G, Edge),\n-                  Cycle_Path             => Cycle_Path,\n-                  Visited_Vertices       => Visited_Vertices,\n-                  Indent                 => No_Indentation);\n-\n-               Trace_Eol;\n-            end if;\n+            Next (Iter, Vertex);\n+\n+            --  Construct the set of vertices (at most 2) that terminates a\n+            --  potential cycle that starts from the current vertex.\n+\n+            End_Vertices :=\n+              Cycle_End_Vertices\n+                (G                    => G,\n+                 Vertex               => Vertex,\n+                 Elaborate_All_Active => Elaborate_All_Active);\n+\n+            --  The modified version maintans two addition attributes while\n+            --  performing the depth-first search:\n+            --\n+            --    * The most significant edge of the current potential cycle.\n+            --\n+            --    * The number of invocation edges encountered along the path\n+            --      of the current potential cycle.\n+            --\n+            --  Both attributes are used in the heuristic which determines the\n+            --  importance of cycles.\n+\n+            Find_Cycles_From_Vertex\n+              (G                     => G,\n+               Vertex                => Vertex,\n+               End_Vertices          => End_Vertices,\n+               Deleted_Vertices      => Deleted_Vertices,\n+               Most_Significant_Edge => No_Library_Graph_Edge,\n+               Invocation_Edge_Count => 0,\n+               Cycle_Path_Stack      => Cycle_Path_Stack,\n+               Visited_Set           => Visited_Set,\n+               Visited_Stack         => Visited_Stack,\n+               Cycle_Count           => Cycle_Count,\n+               Cycle_Limit           => Cycle_Limit,\n+               Elaborate_All_Active  => Elaborate_All_Active,\n+               Is_Start_Vertex       => True,\n+               Has_Cycle             => Has_Cycle,\n+               Indent                => Nested_Indentation);\n+\n+            --  Destroy the cycle-terminating vertices because a new set must\n+            --  be constructed for the next vertex.\n+\n+            LGV_Sets.Destroy (End_Vertices);\n          end loop;\n \n-         LGE_Lists.Destroy (Cycle_Path);\n-         LGV_Sets.Destroy  (Visited_Vertices);\n-      end Find_Cycles;\n+         --  Destroy all component-level data structures\n+\n+         LGE_Lists.Destroy (Cycle_Path_Stack);\n+         LGV_Sets.Destroy  (Deleted_Vertices);\n+         LGV_Sets.Destroy  (Visited_Set);\n+         LGV_Lists.Destroy (Visited_Stack);\n+      end Find_Cycles_In_Component;\n \n       ---------------------------------------\n       -- Find_First_Lower_Precedence_Cycle --\n@@ -2670,7 +3166,7 @@ package body Bindo.Graphs is\n             Next (Iter, Current_Cycle);\n \n             if not Present (Lesser_Cycle)\n-              and then Precedence\n+              and then Cycle_Precedence\n                          (G           => G,\n                           Cycle       => Cycle,\n                           Compared_To => Current_Cycle) = Higher_Precedence\n@@ -2776,6 +3272,77 @@ package body Bindo.Graphs is\n          return Seen;\n       end Has_Elaborate_All_Cycle;\n \n+      ----------------------------\n+      -- Has_Elaborate_All_Edge --\n+      ----------------------------\n+\n+      function Has_Elaborate_All_Edge\n+        (G    : Library_Graph;\n+         Comp : Component_Id) return Boolean\n+      is\n+         Has_Edge : Boolean;\n+         Iter     : Component_Vertex_Iterator;\n+         Vertex   : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         --  Assume that there is no Elaborate_All edge\n+\n+         Has_Edge := False;\n+\n+         --  IMPORTANT:\n+         --\n+         --    * The iteration must run to completion in order to unlock the\n+         --      component vertices.\n+\n+         Iter := Iterate_Component_Vertices (G, Comp);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Vertex);\n+\n+            Has_Edge := Has_Edge or else Has_Elaborate_All_Edge (G, Vertex);\n+         end loop;\n+\n+         return Has_Edge;\n+      end Has_Elaborate_All_Edge;\n+\n+      ----------------------------\n+      -- Has_Elaborate_All_Edge --\n+      ----------------------------\n+\n+      function Has_Elaborate_All_Edge\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+         Edge     : Library_Graph_Edge_Id;\n+         Has_Edge : Boolean;\n+         Iter     : Edges_To_Successors_Iterator;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         --  Assume that there is no Elaborate_All edge\n+\n+         Has_Edge := False;\n+\n+         --  IMPORTANT:\n+         --\n+         --    * The iteration must run to completion in order to unlock the\n+         --      edges to successors.\n+\n+         Iter := Iterate_Edges_To_Successors (G, Vertex);\n+         while Has_Next (Iter) loop\n+            Next (Iter, Edge);\n+\n+            Has_Edge :=\n+              Has_Edge or else Is_Cyclic_Elaborate_All_Edge (G, Edge);\n+         end loop;\n+\n+         return Has_Edge;\n+      end Has_Elaborate_All_Edge;\n+\n       ------------------------\n       -- Has_Elaborate_Body --\n       ------------------------\n@@ -2961,7 +3528,7 @@ package body Bindo.Graphs is\n \n          if Present (Left) and then Present (Right) then\n             Edge_Prec :=\n-              Precedence\n+              Edge_Precedence\n                 (G           => G,\n                  Edge        => Left,\n                  Compared_To => Right);\n@@ -3109,50 +3676,6 @@ package body Bindo.Graphs is\n          end if;\n       end Initialize_Components;\n \n-      ---------------------\n-      -- Insert_And_Sort --\n-      ---------------------\n-\n-      procedure Insert_And_Sort\n-        (G     : Library_Graph;\n-         Cycle : Library_Graph_Cycle_Id)\n-      is\n-         Lesser_Cycle : Library_Graph_Cycle_Id;\n-\n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Cycle));\n-         pragma Assert (LGC_Lists.Present (G.Cycles));\n-\n-         --  The input cycle is the first to be inserted\n-\n-         if LGC_Lists.Is_Empty (G.Cycles) then\n-            LGC_Lists.Prepend (G.Cycles, Cycle);\n-\n-         --  Otherwise the list of all cycles contains at least one cycle.\n-         --  Insert the input cycle based on its precedence.\n-\n-         else\n-            Lesser_Cycle := Find_First_Lower_Precedence_Cycle (G, Cycle);\n-\n-            --  The list contains at least one cycle, and the input cycle has a\n-            --  higher precedence compared to some cycle in the list.\n-\n-            if Present (Lesser_Cycle) then\n-               LGC_Lists.Insert_Before\n-                 (L      => G.Cycles,\n-                  Before => Lesser_Cycle,\n-                  Elem   => Cycle);\n-\n-            --  Otherwise the input cycle has the lowest precedence among all\n-            --  cycles.\n-\n-            else\n-               LGC_Lists.Append (G.Cycles, Cycle);\n-            end if;\n-         end if;\n-      end Insert_And_Sort;\n-\n       ---------------------------\n       -- Invocation_Edge_Count --\n       ---------------------------\n@@ -3496,17 +4019,13 @@ package body Bindo.Graphs is\n         (G    : Library_Graph;\n          Edge : Library_Graph_Edge_Id) return Boolean\n       is\n+      begin\n          pragma Assert (Present (G));\n          pragma Assert (Present (Edge));\n \n-         Succ : constant Library_Graph_Vertex_Id := Successor (G, Edge);\n-\n-      begin\n          return\n            Kind (G, Edge) = With_Edge\n-             and then\n-               (Is_Spec_With_Elaborate_Body (G, Succ)\n-                 or else Is_Body_Of_Spec_With_Elaborate_Body (G, Succ));\n+             and then Is_Vertex_With_Elaborate_Body (G, Successor (G, Edge));\n       end Is_Elaborate_Body_Edge;\n \n       -----------------------\n@@ -3622,20 +4141,6 @@ package body Bindo.Graphs is\n          return U_Rec.Preelab or else U_Rec.Pure;\n       end Is_Preelaborated_Unit;\n \n-      -----------------------\n-      -- Is_Recorded_Cycle --\n-      -----------------------\n-\n-      function Is_Recorded_Cycle\n-        (G     : Library_Graph;\n-         Attrs : Library_Graph_Cycle_Attributes) return Boolean\n-      is\n-      begin\n-         pragma Assert (Present (G));\n-\n-         return RC_Sets.Contains (G.Recorded_Cycles, Attrs);\n-      end Is_Recorded_Cycle;\n-\n       ----------------------\n       -- Is_Recorded_Edge --\n       ----------------------\n@@ -3722,6 +4227,24 @@ package body Bindo.Graphs is\n              and then not Is_Dynamically_Elaborated (G, Successor (G, Edge));\n       end Is_Static_Successor_Edge;\n \n+      -----------------------------------\n+      -- Is_Vertex_With_Elaborate_Body --\n+      -----------------------------------\n+\n+      function Is_Vertex_With_Elaborate_Body\n+        (G      : Library_Graph;\n+         Vertex : Library_Graph_Vertex_Id) return Boolean\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+\n+         return\n+           Is_Spec_With_Elaborate_Body (G, Vertex)\n+             or else\n+           Is_Body_Of_Spec_With_Elaborate_Body (G, Vertex);\n+      end Is_Vertex_With_Elaborate_Body;\n+\n       ---------------------------------\n       -- Is_Weakly_Elaborable_Vertex --\n       ----------------------------------\n@@ -4107,50 +4630,6 @@ package body Bindo.Graphs is\n          DG.Next (DG.Component_Vertex_Iterator (Iter), Vertex);\n       end Next;\n \n-      -----------------------------\n-      -- Normalize_And_Add_Cycle --\n-      -----------------------------\n-\n-      procedure Normalize_And_Add_Cycle\n-        (G                     : Library_Graph;\n-         Most_Significant_Edge : Library_Graph_Edge_Id;\n-         Invocation_Edge_Count : Natural;\n-         Cycle_Path            : LGE_Lists.Doubly_Linked_List;\n-         Indent                : Indentation_Level)\n-      is\n-         Path : LGE_Lists.Doubly_Linked_List;\n-\n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Most_Significant_Edge));\n-         pragma Assert (LGE_Lists.Present (Cycle_Path));\n-\n-         --  Replicate the path of the cycle in order to avoid sharing lists\n-\n-         Path := Copy_Cycle_Path (Cycle_Path);\n-\n-         --  Normalize the path of the cycle such that its most significant\n-         --  edge is the first in the list of edges.\n-\n-         Normalize_Cycle_Path\n-           (Cycle_Path            => Path,\n-            Most_Significant_Edge => Most_Significant_Edge);\n-\n-         --  Save the cycle for diagnostic purposes. Its kind is determined by\n-         --  its most significant edge.\n-\n-         Add_Cycle\n-           (G      => G,\n-            Attrs  =>\n-             (Invocation_Edge_Count => Invocation_Edge_Count,\n-              Kind                  =>\n-                Cycle_Kind_Of\n-                  (G    => G,\n-                   Edge => Most_Significant_Edge),\n-              Path                  => Path),\n-            Indent => Indent);\n-      end Normalize_And_Add_Cycle;\n-\n       --------------------------\n       -- Normalize_Cycle_Path --\n       --------------------------\n@@ -4256,12 +4735,56 @@ package body Bindo.Graphs is\n       -- Number_Of_Vertices --\n       ------------------------\n \n-      function Number_Of_Vertices (G : Library_Graph) return Natural is\n-      begin\n-         pragma Assert (Present (G));\n+      function Number_Of_Vertices (G : Library_Graph) return Natural is\n+      begin\n+         pragma Assert (Present (G));\n+\n+         return DG.Number_Of_Vertices (G.Graph);\n+      end Number_Of_Vertices;\n+\n+      -----------------\n+      -- Order_Cycle --\n+      -----------------\n+\n+      procedure Order_Cycle\n+        (G     : Library_Graph;\n+         Cycle : Library_Graph_Cycle_Id)\n+      is\n+         Lesser_Cycle : Library_Graph_Cycle_Id;\n+\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Cycle));\n+         pragma Assert (LGC_Lists.Present (G.Cycles));\n+\n+         --  The input cycle is the first to be inserted\n+\n+         if LGC_Lists.Is_Empty (G.Cycles) then\n+            LGC_Lists.Prepend (G.Cycles, Cycle);\n+\n+         --  Otherwise the list of all cycles contains at least one cycle.\n+         --  Insert the input cycle based on its precedence.\n+\n+         else\n+            Lesser_Cycle := Find_First_Lower_Precedence_Cycle (G, Cycle);\n+\n+            --  The list contains at least one cycle, and the input cycle has a\n+            --  higher precedence compared to some cycle in the list.\n+\n+            if Present (Lesser_Cycle) then\n+               LGC_Lists.Insert_Before\n+                 (L      => G.Cycles,\n+                  Before => Lesser_Cycle,\n+                  Elem   => Cycle);\n+\n+            --  Otherwise the input cycle has the lowest precedence among all\n+            --  cycles.\n \n-         return DG.Number_Of_Vertices (G.Graph);\n-      end Number_Of_Vertices;\n+            else\n+               LGC_Lists.Append (G.Cycles, Cycle);\n+            end if;\n+         end if;\n+      end Order_Cycle;\n \n       ----------\n       -- Path --\n@@ -4399,146 +4922,6 @@ package body Bindo.Graphs is\n          return Get_LGV_Attributes (G, Vertex).Pending_Weak_Predecessors;\n       end Pending_Weak_Predecessors;\n \n-      ----------------\n-      -- Precedence --\n-      ----------------\n-\n-      function Precedence\n-        (G           : Library_Graph;\n-         Cycle       : Library_Graph_Cycle_Id;\n-         Compared_To : Library_Graph_Cycle_Id) return Precedence_Kind\n-      is\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Cycle));\n-         pragma Assert (Present (Compared_To));\n-\n-         Comp_Invs  : constant Natural :=\n-                        Invocation_Edge_Count (G, Compared_To);\n-         Comp_Len   : constant Natural := Length (G, Compared_To);\n-         Cycle_Invs : constant Natural := Invocation_Edge_Count (G, Cycle);\n-         Cycle_Len  : constant Natural := Length (G, Cycle);\n-         Kind_Prec  : constant Precedence_Kind :=\n-                        Precedence\n-                          (Kind        => Kind (G, Cycle),\n-                           Compared_To => Kind (G, Compared_To));\n-\n-      begin\n-         if Kind_Prec = Higher_Precedence\n-              or else\n-            Kind_Prec = Lower_Precedence\n-         then\n-            return Kind_Prec;\n-\n-         --  Otherwise both cycles have the same precedence based on their\n-         --  kind. Prefer a cycle with fewer invocation edges.\n-\n-         elsif Cycle_Invs < Comp_Invs then\n-            return Higher_Precedence;\n-\n-         elsif Cycle_Invs > Comp_Invs then\n-            return Lower_Precedence;\n-\n-         --  Otherwise both cycles have the same number of invocation edges.\n-         --  Prefer a cycle with a smaller length.\n-\n-         elsif Cycle_Len < Comp_Len then\n-            return Higher_Precedence;\n-\n-         elsif Cycle_Len > Comp_Len then\n-            return Lower_Precedence;\n-\n-         else\n-            return Equal_Precedence;\n-         end if;\n-      end Precedence;\n-\n-      ----------------\n-      -- Precedence --\n-      ----------------\n-\n-      function Precedence\n-        (Kind        : Library_Graph_Cycle_Kind;\n-         Compared_To : Library_Graph_Cycle_Kind) return Precedence_Kind\n-      is\n-         Comp_Pos : constant Integer :=\n-                      Library_Graph_Cycle_Kind'Pos (Compared_To);\n-         Kind_Pos : constant Integer := Library_Graph_Cycle_Kind'Pos (Kind);\n-\n-      begin\n-         --  A lower ordinal indicates higher precedence\n-\n-         if Kind_Pos < Comp_Pos then\n-            return Higher_Precedence;\n-\n-         elsif Kind_Pos > Comp_Pos then\n-            return Lower_Precedence;\n-\n-         else\n-            return Equal_Precedence;\n-         end if;\n-      end Precedence;\n-\n-      ----------------\n-      -- Precedence --\n-      ----------------\n-\n-      function Precedence\n-        (G           : Library_Graph;\n-         Edge        : Library_Graph_Edge_Id;\n-         Compared_To : Library_Graph_Edge_Id) return Precedence_Kind\n-      is\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Edge));\n-         pragma Assert (Present (Compared_To));\n-\n-         Kind_Prec : constant Precedence_Kind :=\n-                       Precedence\n-                         (Kind        => Cycle_Kind_Of (G, Edge),\n-                          Compared_To => Cycle_Kind_Of (G, Compared_To));\n-\n-      begin\n-         if Kind_Prec = Higher_Precedence\n-              or else\n-            Kind_Prec = Lower_Precedence\n-         then\n-            return Kind_Prec;\n-\n-         --  Otherwise both edges have the same precedence based on their cycle\n-         --  kinds. Prefer an edge whose successor has higher precedence.\n-\n-         else\n-            return\n-              Precedence\n-                (G           => G,\n-                 Vertex      => Successor (G, Edge),\n-                 Compared_To => Successor (G, Compared_To));\n-         end if;\n-      end Precedence;\n-\n-      ----------------\n-      -- Precedence --\n-      ----------------\n-\n-      function Precedence\n-        (G           : Library_Graph;\n-         Vertex      : Library_Graph_Vertex_Id;\n-         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind\n-      is\n-      begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n-         pragma Assert (Present (Compared_To));\n-\n-         --  Use lexicographical order to determine precedence and ensure\n-         --  deterministic behavior.\n-\n-         if Uname_Less (Name (G, Vertex), Name (G, Compared_To)) then\n-            return Higher_Precedence;\n-         else\n-            return Lower_Precedence;\n-         end if;\n-      end Precedence;\n-\n       -----------------\n       -- Predecessor --\n       -----------------\n@@ -4615,33 +4998,59 @@ package body Bindo.Graphs is\n          end if;\n       end Proper_Spec;\n \n-      ----------------------------------\n-      -- Remove_Vertex_And_Complement --\n-      ----------------------------------\n+      ------------------\n+      -- Record_Cycle --\n+      ------------------\n \n-      procedure Remove_Vertex_And_Complement\n-        (G             : Library_Graph;\n-         Vertex        : Library_Graph_Vertex_Id;\n-         Set           : LGV_Sets.Membership_Set;\n-         Do_Complement : Boolean)\n+      procedure Record_Cycle\n+        (G                     : Library_Graph;\n+         Most_Significant_Edge : Library_Graph_Edge_Id;\n+         Invocation_Edge_Count : Natural;\n+         Cycle_Path            : LGE_Lists.Doubly_Linked_List;\n+         Indent                : Indentation_Level)\n       is\n+         Cycle : Library_Graph_Cycle_Id;\n+         Path  : LGE_Lists.Doubly_Linked_List;\n+\n+      begin\n          pragma Assert (Present (G));\n-         pragma Assert (Present (Vertex));\n-         pragma Assert (LGV_Sets.Present (Set));\n+         pragma Assert (Present (Most_Significant_Edge));\n+         pragma Assert (LGE_Lists.Present (Cycle_Path));\n \n-         Complement : constant Library_Graph_Vertex_Id :=\n-                        Complementary_Vertex\n-                          (G                => G,\n-                           Vertex           => Vertex,\n-                           Force_Complement => Do_Complement);\n+         --  Replicate the path of the cycle in order to avoid sharing lists\n \n-      begin\n-         LGV_Sets.Delete (Set, Vertex);\n+         Path := Copy_Cycle_Path (Cycle_Path);\n \n-         if Present (Complement) then\n-            LGV_Sets.Delete (Set, Complement);\n-         end if;\n-      end Remove_Vertex_And_Complement;\n+         --  Normalize the path of the cycle such that its most significant\n+         --  edge is the first in the list of edges.\n+\n+         Normalize_Cycle_Path\n+           (Cycle_Path            => Path,\n+            Most_Significant_Edge => Most_Significant_Edge);\n+\n+         --  Save the cycle for diagnostic purposes. Its kind is determined by\n+         --  its most significant edge.\n+\n+         Cycle := Sequence_Next_Cycle;\n+\n+         Set_LGC_Attributes\n+           (G     => G,\n+            Cycle => Cycle,\n+            Val   =>\n+              (Invocation_Edge_Count => Invocation_Edge_Count,\n+               Kind                  =>\n+                 Cycle_Kind_Of\n+                   (G    => G,\n+                    Edge => Most_Significant_Edge),\n+               Path                  => Path));\n+\n+         Trace_Cycle (G, Cycle, Indent);\n+\n+         --  Order the cycle based on its precedence relative to previously\n+         --  discovered cycles.\n+\n+         Order_Cycle (G, Cycle);\n+      end Record_Cycle;\n \n       -----------------------------------------\n       -- Same_Library_Graph_Cycle_Attributes --\n@@ -4737,25 +5146,6 @@ package body Bindo.Graphs is\n          Set_LGV_Attributes (G, Vertex, Attrs);\n       end Set_In_Elaboration_Order;\n \n-      ---------------------------\n-      -- Set_Is_Recorded_Cycle --\n-      ---------------------------\n-\n-      procedure Set_Is_Recorded_Cycle\n-        (G     : Library_Graph;\n-         Attrs : Library_Graph_Cycle_Attributes;\n-         Val   : Boolean := True)\n-      is\n-      begin\n-         pragma Assert (Present (G));\n-\n-         if Val then\n-            RC_Sets.Insert (G.Recorded_Cycles, Attrs);\n-         else\n-            RC_Sets.Delete (G.Recorded_Cycles, Attrs);\n-         end if;\n-      end Set_Is_Recorded_Cycle;\n-\n       --------------------------\n       -- Set_Is_Recorded_Edge --\n       --------------------------\n@@ -4840,6 +5230,34 @@ package body Bindo.Graphs is\n          return DG.Destination_Vertex (G.Graph, Edge);\n       end Successor;\n \n+      ---------------------\n+      -- Trace_Component --\n+      ---------------------\n+\n+      procedure Trace_Component\n+        (G      : Library_Graph;\n+         Comp   : Component_Id;\n+         Indent : Indentation_Level)\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         --  Nothing to do when switch -d_t (output cycle detection trace\n+         --  information) is not in effect.\n+\n+         if not Debug_Flag_Underscore_T then\n+            return;\n+         end if;\n+\n+         Write_Eol;\n+         Indent_By (Indent);\n+         Write_Str (\"component (Comp_\");\n+         Write_Int (Int (Comp));\n+         Write_Str (\")\");\n+         Write_Eol;\n+      end Trace_Component;\n+\n       -----------------\n       -- Trace_Cycle --\n       -----------------\n@@ -4861,15 +5279,15 @@ package body Bindo.Graphs is\n          pragma Assert (Present (G));\n          pragma Assert (Present (Cycle));\n \n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n+         --  Nothing to do when switch -d_t (output cycle detection trace\n+         --  information) is not in effect.\n \n-         if not Debug_Flag_Underscore_TT then\n+         if not Debug_Flag_Underscore_T then\n             return;\n          end if;\n \n          Indent_By (Indent);\n-         Write_Str (\"cycle (Cycle_Id_\");\n+         Write_Str (\"cycle (LGC_Id_\");\n          Write_Int (Int (Cycle));\n          Write_Str (\")\");\n          Write_Eol;\n@@ -4920,10 +5338,10 @@ package body Bindo.Graphs is\n          Succ : constant Library_Graph_Vertex_Id := Successor   (G, Edge);\n \n       begin\n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n+         --  Nothing to do when switch -d_t (output cycle detection trace\n+         --  information) is not in effect.\n \n-         if not Debug_Flag_Underscore_TT then\n+         if not Debug_Flag_Underscore_T then\n             return;\n          end if;\n \n@@ -4953,22 +5371,6 @@ package body Bindo.Graphs is\n          Write_Eol;\n       end Trace_Edge;\n \n-      ---------------\n-      -- Trace_Eol --\n-      ---------------\n-\n-      procedure Trace_Eol is\n-      begin\n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n-\n-         if not Debug_Flag_Underscore_TT then\n-            return;\n-         end if;\n-\n-         Write_Eol;\n-      end Trace_Eol;\n-\n       ------------------\n       -- Trace_Vertex --\n       ------------------\n@@ -4985,10 +5387,10 @@ package body Bindo.Graphs is\n          pragma Assert (Present (G));\n          pragma Assert (Present (Vertex));\n \n-         --  Nothing to do when switch -d_T (output elaboration order and cycle\n-         --  detection trace information) is not in effect.\n+         --  Nothing to do when switch -d_t (output cycle detection trace\n+         --  information) is not in effect.\n \n-         if not Debug_Flag_Underscore_TT then\n+         if not Debug_Flag_Underscore_T then\n             return;\n          end if;\n \n@@ -4998,12 +5400,6 @@ package body Bindo.Graphs is\n          Write_Str (\")\");\n          Write_Eol;\n \n-         Indent_By (Attr_Indent);\n-         Write_Str (\"Component (Comp_Id_\");\n-         Write_Int (Int (Component (G, Vertex)));\n-         Write_Str (\")\");\n-         Write_Eol;\n-\n          Indent_By  (Attr_Indent);\n          Write_Str  (\"Unit (U_Id_\");\n          Write_Int  (Int (Unit (G, Vertex)));\n@@ -5027,6 +5423,32 @@ package body Bindo.Graphs is\n          return Get_LGV_Attributes (G, Vertex).Unit;\n       end Unit;\n \n+      -------------\n+      -- Unvisit --\n+      -------------\n+\n+      procedure Unvisit\n+        (Vertex        : Library_Graph_Vertex_Id;\n+         Visited_Set   : LGV_Sets.Membership_Set;\n+         Visited_Stack : LGV_Lists.Doubly_Linked_List)\n+      is\n+         Current_Vertex : Library_Graph_Vertex_Id;\n+\n+      begin\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (LGV_Sets.Present  (Visited_Set));\n+         pragma Assert (LGV_Lists.Present (Visited_Stack));\n+\n+         while not LGV_Lists.Is_Empty (Visited_Stack) loop\n+            Current_Vertex := LGV_Lists.First (Visited_Stack);\n+\n+            LGV_Lists.Delete_First (Visited_Stack);\n+            LGV_Sets.Delete (Visited_Set, Current_Vertex);\n+\n+            exit when Current_Vertex = Vertex;\n+         end loop;\n+      end Unvisit;\n+\n       ---------------------------------\n       -- Update_Pending_Predecessors --\n       ---------------------------------\n@@ -5097,6 +5519,48 @@ package body Bindo.Graphs is\n                Edge => Edge);\n          end if;\n       end Update_Pending_Predecessors_Of_Components;\n+\n+      -----------------------\n+      -- Vertex_Precedence --\n+      -----------------------\n+\n+      function Vertex_Precedence\n+        (G           : Library_Graph;\n+         Vertex      : Library_Graph_Vertex_Id;\n+         Compared_To : Library_Graph_Vertex_Id) return Precedence_Kind\n+      is\n+      begin\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (Present (Compared_To));\n+\n+         --  Use lexicographical order to determine precedence and ensure\n+         --  deterministic behavior.\n+\n+         if Uname_Less (Name (G, Vertex), Name (G, Compared_To)) then\n+            return Higher_Precedence;\n+         else\n+            return Lower_Precedence;\n+         end if;\n+      end Vertex_Precedence;\n+\n+      -----------\n+      -- Visit --\n+      -----------\n+\n+      procedure Visit\n+        (Vertex        : Library_Graph_Vertex_Id;\n+         Visited_Set   : LGV_Sets.Membership_Set;\n+         Visited_Stack : LGV_Lists.Doubly_Linked_List)\n+      is\n+      begin\n+         pragma Assert (Present (Vertex));\n+         pragma Assert (LGV_Sets.Present  (Visited_Set));\n+         pragma Assert (LGV_Lists.Present (Visited_Stack));\n+\n+         LGV_Sets.Insert   (Visited_Set,   Vertex);\n+         LGV_Lists.Prepend (Visited_Stack, Vertex);\n+      end Visit;\n    end Library_Graphs;\n \n    -------------"}, {"sha": "8323784481805b4ea1122047bd5cf43058dd135b", "filename": "gcc/ada/bindo-graphs.ads", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-graphs.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-graphs.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-graphs.ads?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -174,6 +174,11 @@ package Bindo.Graphs is\n    First_Library_Graph_Vertex : constant Library_Graph_Vertex_Id :=\n                                   No_Library_Graph_Vertex + 1;\n \n+   procedure Destroy_Library_Graph_Vertex\n+     (Vertex : in out Library_Graph_Vertex_Id);\n+   pragma Inline (Destroy_Library_Graph_Vertex);\n+   --  Destroy library graph vertex Vertex\n+\n    function Hash_Library_Graph_Vertex\n      (Vertex : Library_Graph_Vertex_Id) return Bucket_Range_Type;\n    pragma Inline (Hash_Library_Graph_Vertex);\n@@ -183,6 +188,11 @@ package Bindo.Graphs is\n    pragma Inline (Present);\n    --  Determine whether library graph vertex Vertex exists\n \n+   package LGV_Lists is new Doubly_Linked_Lists\n+     (Element_Type    => Library_Graph_Vertex_Id,\n+      \"=\"             => \"=\",\n+      Destroy_Element => Destroy_Library_Graph_Vertex);\n+\n    package LGV_Sets is new Membership_Sets\n      (Element_Type => Library_Graph_Vertex_Id,\n       \"=\"          => \"=\",\n@@ -1406,11 +1416,6 @@ package Bindo.Graphs is\n       -- Vertices --\n       --------------\n \n-      procedure Destroy_Library_Graph_Vertex\n-        (Vertex : in out Library_Graph_Vertex_Id);\n-      pragma Inline (Destroy_Library_Graph_Vertex);\n-      --  Destroy library graph vertex Vertex\n-\n       --  The following type represents the attributes of a library graph\n       --  vertex.\n \n@@ -1593,15 +1598,6 @@ package Bindo.Graphs is\n          Destroy_Value         => Destroy_Library_Graph_Cycle_Attributes,\n          Hash                  => Hash_Library_Graph_Cycle);\n \n-      ---------------------\n-      -- Recorded cycles --\n-      ---------------------\n-\n-      package RC_Sets is new Membership_Sets\n-        (Element_Type => Library_Graph_Cycle_Attributes,\n-         \"=\"          => Same_Library_Graph_Cycle_Attributes,\n-         Hash         => Hash_Library_Graph_Cycle_Attributes);\n-\n       --------------------\n       -- Recorded edges --\n       --------------------\n@@ -1693,10 +1689,6 @@ package Bindo.Graphs is\n          --  The underlying graph describing the relations between edges and\n          --  vertices.\n \n-         Recorded_Cycles : RC_Sets.Membership_Set := RC_Sets.Nil;\n-         --  The set of recorded cycles, used to prevent duplicate cycles in\n-         --  the graph.\n-\n          Recorded_Edges : RE_Sets.Membership_Set := RE_Sets.Nil;\n          --  The set of recorded edges, used to prevent duplicate edges in the\n          --  graph."}, {"sha": "c4784d4a3b92ae18eb76efcf220675fcf6601726", "filename": "gcc/ada/bindo-writers.adb", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -1102,6 +1102,8 @@ package body Bindo.Writers is\n          Write_Eol;\n \n          Write_Component_Vertices (G, Comp);\n+\n+         Write_Eol;\n       end Write_Component;\n \n       ------------------------------\n@@ -1112,25 +1114,34 @@ package body Bindo.Writers is\n         (G    : Library_Graph;\n          Comp : Component_Id)\n       is\n+         pragma Assert (Present (G));\n+         pragma Assert (Present (Comp));\n+\n+         Num_Of_Vertices : constant Natural :=\n+                             Number_Of_Component_Vertices (G, Comp);\n+\n          Iter   : Component_Vertex_Iterator;\n          Vertex : Library_Graph_Vertex_Id;\n \n       begin\n-         pragma Assert (Present (G));\n-         pragma Assert (Present (Comp));\n+         Write_Str (\"  Vertices: \");\n+         Write_Int (Int (Num_Of_Vertices));\n+         Write_Eol;\n \n-         Iter := Iterate_Component_Vertices (G, Comp);\n-         while Has_Next (Iter) loop\n-            Next (Iter, Vertex);\n+         if Num_Of_Vertices > 0 then\n+            Iter := Iterate_Component_Vertices (G, Comp);\n+            while Has_Next (Iter) loop\n+               Next (Iter, Vertex);\n \n-            Write_Str  (\"    library graph vertex (LGV_Id_\");\n-            Write_Int  (Int (Vertex));\n-            Write_Str  (\") name = \");\n-            Write_Name (Name (G, Vertex));\n+               Write_Str  (\"    library graph vertex (LGV_Id_\");\n+               Write_Int  (Int (Vertex));\n+               Write_Str  (\") name = \");\n+               Write_Name (Name (G, Vertex));\n+               Write_Eol;\n+            end loop;\n+         else\n             Write_Eol;\n-         end loop;\n-\n-         Write_Eol;\n+         end if;\n       end Write_Component_Vertices;\n \n       ----------------------"}, {"sha": "c46761786039185297817d4b439285bd56b86864", "filename": "gcc/ada/bindo.adb", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fbindo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo.adb?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -322,6 +322,11 @@ package body Bindo is\n    --        In addition, GNATbind does not create an edge to the body of the\n    --        pragma argument.\n    --\n+   --  -d_t  Output cycle detection trace information\n+   --\n+   --        GNATbind outputs trace information on cycle detection activities\n+   --        to standard output.\n+   --\n    --  -d_A  Output ALI invocation tables\n    --\n    --        GNATbind outputs the contents of ALI table Invocation_Constructs\n@@ -352,8 +357,8 @@ package body Bindo is\n    --\n    --  -d_T  Output elaboration-order trace information\n    --\n-   --        GNATbind outputs trace information on elaboration-order and cycle-\n-   --        detection activities to standard output.\n+   --        GNATbind outputs trace information on elaboration-order detection\n+   --        activities to standard output.\n    --\n    --  -d_V  Validate bindo cycles, graphs, and order\n    --\n@@ -395,7 +400,7 @@ package body Bindo is\n    --  number of files in the bind, Bindo may emit anywhere between several MBs\n    --  to several hundred MBs of data to standard output. The switches are:\n    --\n-   --    -d_A -d_C -d_I -d_L -d_P -d_T -d_V\n+   --    -d_A -d_C -d_I -d_L -d_P -d_t -d_T -d_V\n    --\n    --  Bindo offers several debugging routines that can be invoked from gdb.\n    --  Those are defined in the body of Bindo.Writers, in sections denoted by"}, {"sha": "89bb7f8ca33dcfdabb83291518cf49befb5c08f3", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9098d477ba81e9fba2c41611513bbd643f5caab1/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=9098d477ba81e9fba2c41611513bbd643f5caab1", "patch": "@@ -368,7 +368,7 @@ package body Debug is\n    --  d_q\n    --  d_r\n    --  d_s\n-   --  d_t\n+   --  d_t  Output cycle detection trace information\n    --  d_u\n    --  d_v\n    --  d_w\n@@ -380,6 +380,7 @@ package body Debug is\n    --  d_B\n    --  d_C  Diagnose all cycles\n    --  d_D\n+   --  d_E\n    --  d_F\n    --  d_G\n    --  d_H\n@@ -394,7 +395,7 @@ package body Debug is\n    --  d_Q\n    --  d_R\n    --  d_S\n-   --  d_T  Output elaboration order and cycle detection trace information\n+   --  d_T  Output elaboration order trace information\n    --  d_U\n    --  d_V  Validate bindo cycles, graphs, and order\n    --  d_W\n@@ -1149,6 +1150,9 @@ package body Debug is\n    --       elaboration order and no longer creates an implicit dependency on\n    --       the body of the argument.\n \n+   --  d_t  GNATBIND output trace information of cycle detection activities to\n+   --       standard output.\n+\n    --  d_A  GNATBIND output the contents of all ALI invocation-related tables\n    --       in textual format to standard output.\n \n@@ -1163,8 +1167,8 @@ package body Debug is\n \n    --  d_P  GNATBIND outputs the cycle paths to standard output\n \n-   --  d_T  GNATBIND outputs trace information of elaboration order and cycle\n-   --       detection activities to standard output.\n+   --  d_T  GNATBIND outputs trace information of elaboration order detection\n+   --       activities to standard output.\n \n    --  d_V  GNATBIND validates the invocation graph, library graph along with\n    --       its cycles, and the elaboration order."}]}