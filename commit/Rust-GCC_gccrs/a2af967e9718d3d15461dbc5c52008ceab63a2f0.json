{"sha": "a2af967e9718d3d15461dbc5c52008ceab63a2f0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTJhZjk2N2U5NzE4ZDNkMTU0NjFkYmM1YzUyMDA4Y2VhYjYzYTJmMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-10-25T21:37:33Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-10-25T21:37:33Z"}, "message": "[C++ PATCH] Kill IDENTIFIER_LABEL_VALUE\n\nhttps://gcc.gnu.org/ml/gcc-patches/2017-10/msg01854.html\n\tKill IDENTIFIER_LABEL_VALUE.\n\t* cp-tree.h (lang_identifier): Delete label_value slot.\n\t(IDENTIFIER_LABEL_VALUE, SET_IDENTIFIER_LABEL_VALUE): Delete.\n\t(struct named_label_hasher): Rename to ...\n\t(struct named_label_hash): ... here.  Reimplement.\n\t(struct language_function): Adjust x_named_labels.\n\t* name-lookup.h (struct cp_label_binding): Delete.\n\t(struct cp_binding_level): Delete shadowed_labels slot.\n\t* decl.c (struct named_label_entry): Add name and outer slots.\n\t(pop_label): Rename to ...\n\t(check_label_used): ... here.  Don't pop.\n\t(note_label, sort_labels): Delete.\n\t(pop_labels, pop_local_label): Reimplement.\n\t(poplevel): Pop local labels as any other decl. Remove\n\tshadowed_labels handling.\n\t(named_label_hash::hash, named_label_hash::equal): New.\n\t(make_label_decl): Absorb into ...\n\t(lookup_label_1): ... here.  Add making_local_p arg, reimplement.\n\t(lookup_label, declare_local_label): Adjust.\n\t(check_goto, define_label): Adjust.\n\t* lex.c (make_conv_op_name): Don't clear IDENTIFIER_LABEL_VALUE.\n\t* ptree.c (cxx_print_identifier): Don't print identifier binding.\n\nFrom-SVN: r254087", "tree": {"sha": "f6836d25afadb688414fefdc89db506d2709781a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f6836d25afadb688414fefdc89db506d2709781a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2af967e9718d3d15461dbc5c52008ceab63a2f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2af967e9718d3d15461dbc5c52008ceab63a2f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2af967e9718d3d15461dbc5c52008ceab63a2f0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2af967e9718d3d15461dbc5c52008ceab63a2f0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "733ba9b9a347d8a2ac2dedec820c51481c5c6338", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/733ba9b9a347d8a2ac2dedec820c51481c5c6338", "html_url": "https://github.com/Rust-GCC/gccrs/commit/733ba9b9a347d8a2ac2dedec820c51481c5c6338"}], "stats": {"total": 337, "additions": 155, "deletions": 182}, "files": [{"sha": "81776640cf14db0b7e95d98317aadd6b0d41f10a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -1,5 +1,28 @@\n 2017-10-25  Nathan Sidwell  <nathan@acm.org>\n \n+\tKill IDENTIFIER_LABEL_VALUE.\n+\t* cp-tree.h (lang_identifier): Delete label_value slot.\n+\t(IDENTIFIER_LABEL_VALUE, SET_IDENTIFIER_LABEL_VALUE): Delete.\n+\t(struct named_label_hasher): Rename to ...\n+\t(struct named_label_hash): ... here.  Reimplement.\n+\t(struct language_function): Adjust x_named_labels.\n+\t* name-lookup.h (struct cp_label_binding): Delete.\n+\t(struct cp_binding_level): Delete shadowed_labels slot.\n+\t* decl.c (struct named_label_entry): Add name and outer slots.\n+\t(pop_label): Rename to ...\n+\t(check_label_used): ... here.  Don't pop.\n+\t(note_label, sort_labels): Delete.\n+\t(pop_labels, pop_local_label): Reimplement.\n+\t(poplevel): Pop local labels as any other decl. Remove\n+\tshadowed_labels handling.\n+\t(named_label_hash::hash, named_label_hash::equal): New.\n+\t(make_label_decl): Absorb into ...\n+\t(lookup_label_1): ... here.  Add making_local_p arg, reimplement.\n+\t(lookup_label, declare_local_label): Adjust.\n+\t(check_goto, define_label): Adjust.\n+\t* lex.c (make_conv_op_name): Don't clear IDENTIFIER_LABEL_VALUE.\n+\t* ptree.c (cxx_print_identifier): Don't print identifier binding.\n+\n \t* decl.c (identifier_goto): Reduce duplication.\n \t(check_previous_goto_1): Likewise.\n \t(check_goto): Move var decls to initialization."}, {"sha": "f2570b003862f2567cc885965305ac898ac8949b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -561,7 +561,6 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n struct GTY(()) lang_identifier {\n   struct c_common_identifier c_common;\n   cxx_binding *bindings;\n-  tree label_value;\n };\n \n /* Return a typed pointer version of T if it designates a\n@@ -996,11 +995,6 @@ enum GTY(()) abstract_class_use {\n #define SET_IDENTIFIER_TYPE_VALUE(NODE,TYPE) (TREE_TYPE (NODE) = (TYPE))\n #define IDENTIFIER_HAS_TYPE_VALUE(NODE) (IDENTIFIER_TYPE_VALUE (NODE) ? 1 : 0)\n \n-#define IDENTIFIER_LABEL_VALUE(NODE) \\\n-  (LANG_IDENTIFIER_CAST (NODE)->label_value)\n-#define SET_IDENTIFIER_LABEL_VALUE(NODE, VALUE)   \\\n-  IDENTIFIER_LABEL_VALUE (NODE) = (VALUE)\n-\n /* Kinds of identifiers.  Values are carefully chosen.  */\n enum cp_identifier_kind {\n   cik_normal = 0,\t/* Not a special identifier.  */\n@@ -1662,12 +1656,22 @@ struct cxx_int_tree_map_hasher : ggc_ptr_hash<cxx_int_tree_map>\n   static bool equal (cxx_int_tree_map *, cxx_int_tree_map *);\n };\n \n-struct named_label_entry;\n+struct named_label_entry; /* Defined in decl.c.  */\n \n-struct named_label_hasher : ggc_ptr_hash<named_label_entry>\n+struct named_label_hash : ggc_remove <named_label_entry *>\n {\n-  static hashval_t hash (named_label_entry *);\n-  static bool equal (named_label_entry *, named_label_entry *);\n+  typedef named_label_entry *value_type;\n+  typedef tree compare_type; /* An identifier.  */\n+\n+  inline static hashval_t hash (value_type);\n+  inline static bool equal (const value_type, compare_type);\n+\n+  inline static void mark_empty (value_type &p) {p = NULL;}\n+  inline static bool is_empty (value_type p) {return !p;}\n+\n+  /* Nothing is deletable.  Everything is insertable.  */\n+  inline static bool is_deleted (value_type) { return false; }\n+  inline static void mark_deleted (value_type) { gcc_unreachable (); }\n };\n \n /* Global state pertinent to the current function.  */\n@@ -1696,7 +1700,8 @@ struct GTY(()) language_function {\n \n   BOOL_BITFIELD invalid_constexpr : 1;\n \n-  hash_table<named_label_hasher> *x_named_labels;\n+  hash_table<named_label_hash> *x_named_labels;\n+\n   cp_binding_level *bindings;\n   vec<tree, va_gc> *x_local_names;\n   /* Tracking possibly infinite loops.  This is a vec<tree> only because"}, {"sha": "42b52748e2a7892c323ef335fb6241b7b44053c6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 116, "deletions": 156, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -189,27 +189,33 @@ struct GTY((chain_next (\"%h.next\"))) named_label_use_entry {\n    function, and so we can check the validity of jumps to these labels.  */\n \n struct GTY((for_user)) named_label_entry {\n-  /* The decl itself.  */\n-  tree label_decl;\n+\n+  tree name;  /* Name of decl. */\n+\n+  tree label_decl; /* LABEL_DECL, unless deleted local label. */\n+\n+  named_label_entry *outer; /* Outer shadowed chain.  */\n \n   /* The binding level to which the label is *currently* attached.\n      This is initially set to the binding level in which the label\n      is defined, but is modified as scopes are closed.  */\n   cp_binding_level *binding_level;\n+\n   /* The head of the names list that was current when the label was\n      defined, or the inner scope popped.  These are the decls that will\n      be skipped when jumping to the label.  */\n   tree names_in_scope;\n+\n   /* A vector of all decls from all binding levels that would be\n      crossed by a backward branch to the label.  */\n   vec<tree, va_gc> *bad_decls;\n \n   /* A list of uses of the label, before the label is defined.  */\n-  struct named_label_use_entry *uses;\n+  named_label_use_entry *uses;\n \n   /* The following bits are set after the label is defined, and are\n-     updated as scopes are popped.  They indicate that a backward jump\n-     to the label will illegally enter a scope of the given flavor.  */\n+     updated as scopes are popped.  They indicate that a jump to the\n+     label will illegally enter a scope of the given flavor.  */\n   bool in_try_scope;\n   bool in_catch_scope;\n   bool in_omp_scope;\n@@ -347,7 +353,7 @@ finish_scope (void)\n    in a valid manner, and issue any appropriate warnings or errors.  */\n \n static void\n-pop_label (tree label, tree old_value)\n+check_label_used (tree label)\n {\n   if (!processing_template_decl)\n     {\n@@ -364,32 +370,6 @@ pop_label (tree label, tree old_value)\n       else \n \twarn_for_unused_label (label);\n     }\n-\n-  SET_IDENTIFIER_LABEL_VALUE (DECL_NAME (label), old_value);\n-}\n-\n-/* Push all named labels into a vector, so that we can sort it on DECL_UID\n-   to avoid code generation differences.  */\n-\n-int\n-note_label (named_label_entry **slot, vec<named_label_entry **> &labels)\n-{\n-  labels.quick_push (slot);\n-  return 1;\n-}\n-\n-/* Helper function to sort named label entries in a vector by DECL_UID.  */\n-\n-static int\n-sort_labels (const void *a, const void *b)\n-{\n-  named_label_entry **slot1 = *(named_label_entry **const *) a;\n-  named_label_entry **slot2 = *(named_label_entry **const *) b;\n-  if (DECL_UID ((*slot1)->label_decl) < DECL_UID ((*slot2)->label_decl))\n-    return -1;\n-  if (DECL_UID ((*slot1)->label_decl) > DECL_UID ((*slot2)->label_decl))\n-    return 1;\n-  return 0;\n }\n \n /* At the end of a function, all labels declared within the function\n@@ -399,46 +379,49 @@ sort_labels (const void *a, const void *b)\n static void\n pop_labels (tree block)\n {\n-  if (named_labels)\n+  if (!named_labels)\n+    return;\n+\n+  hash_table<named_label_hash>::iterator end (named_labels->end ());\n+  for (hash_table<named_label_hash>::iterator iter\n+\t (named_labels->begin ()); iter != end; ++iter)\n     {\n-      auto_vec<named_label_entry **, 32> labels;\n-      named_label_entry **slot;\n-      unsigned int i;\n+      named_label_entry *ent = *iter;\n \n-      /* Push all the labels into a vector and sort them by DECL_UID,\n-\t so that gaps between DECL_UIDs don't affect code generation.  */\n-      labels.reserve_exact (named_labels->elements ());\n-      named_labels->traverse<vec<named_label_entry **> &, note_label> (labels);\n-      labels.qsort (sort_labels);\n-      FOR_EACH_VEC_ELT (labels, i, slot)\n+      gcc_checking_assert (!ent->outer);\n+      if (ent->label_decl)\n \t{\n-\t  struct named_label_entry *ent = *slot;\n-\n-\t  pop_label (ent->label_decl, NULL_TREE);\n+\t  check_label_used (ent->label_decl);\n \n \t  /* Put the labels into the \"variables\" of the top-level block,\n \t     so debugger can see them.  */\n \t  DECL_CHAIN (ent->label_decl) = BLOCK_VARS (block);\n \t  BLOCK_VARS (block) = ent->label_decl;\n-\n-\t  named_labels->clear_slot (slot);\n \t}\n-      named_labels = NULL;\n+      ggc_free (ent);\n     }\n+\n+  named_labels = NULL;\n }\n \n /* At the end of a block with local labels, restore the outer definition.  */\n \n static void\n-pop_local_label (tree label, tree old_value)\n+pop_local_label (tree id, tree label)\n {\n-  struct named_label_entry dummy;\n-\n-  pop_label (label, old_value);\n+  check_label_used (label);\n+  named_label_entry **slot = named_labels->find_slot_with_hash\n+    (id, IDENTIFIER_HASH_VALUE (id), NO_INSERT);\n+  named_label_entry *ent = *slot;\n \n-  dummy.label_decl = label;\n-  named_label_entry **slot = named_labels->find_slot (&dummy, NO_INSERT);\n-  named_labels->clear_slot (slot);\n+  if (ent->outer)\n+    ent = ent->outer;\n+  else\n+    {\n+      ent = ggc_cleared_alloc<named_label_entry> ();\n+      ent->name = id;\n+    }\n+  *slot = ent;\n }\n \n /* The following two routines are used to interface to Objective-C++.\n@@ -579,7 +562,6 @@ poplevel (int keep, int reverse, int functionbody)\n   int leaving_for_scope;\n   scope_kind kind;\n   unsigned ix;\n-  cp_label_binding *label_bind;\n \n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n  restart:\n@@ -613,11 +595,12 @@ poplevel (int keep, int reverse, int functionbody)\n      Usually current_binding_level->names is in reverse order.\n      But parameter decls were previously put in forward order.  */\n \n+  decls = current_binding_level->names;\n   if (reverse)\n-    current_binding_level->names\n-      = decls = nreverse (current_binding_level->names);\n-  else\n-    decls = current_binding_level->names;\n+    {\n+      decls = nreverse (decls);\n+      current_binding_level->names = decls;\n+    }\n \n   /* If there were any declarations or structure tags in that level,\n      or if this level is a function body,\n@@ -770,7 +753,10 @@ poplevel (int keep, int reverse, int functionbody)\n \t    }\n \t}\n       /* Remove the binding.  */\n-      pop_local_binding (name, decl);\n+      if (TREE_CODE (decl) == LABEL_DECL)\n+\tpop_local_label (name, decl);\n+      else\n+\tpop_local_binding (name, decl);\n     }\n \n   /* Remove declarations for any `for' variables from inner scopes\n@@ -784,11 +770,6 @@ poplevel (int keep, int reverse, int functionbody)\n        link; link = TREE_CHAIN (link))\n     SET_IDENTIFIER_TYPE_VALUE (TREE_PURPOSE (link), TREE_VALUE (link));\n \n-  /* Restore the IDENTIFIER_LABEL_VALUEs for local labels.  */\n-  FOR_EACH_VEC_SAFE_ELT_REVERSE (current_binding_level->shadowed_labels,\n-\t\t\t         ix, label_bind)\n-    pop_local_label (label_bind->label, label_bind->prev_value);\n-\n   /* There may be OVERLOADs (wrapped in TREE_LISTs) on the BLOCK_VARs\n      list if a `using' declaration put them there.  The debugging\n      back ends won't understand OVERLOAD, so we remove them here.\n@@ -2949,112 +2930,103 @@ redeclaration_error_message (tree newdecl, tree olddecl)\n     }\n }\n \f\n+\n /* Hash and equality functions for the named_label table.  */\n \n hashval_t\n-named_label_hasher::hash (named_label_entry *ent)\n+named_label_hash::hash (const value_type entry)\n {\n-  return DECL_UID (ent->label_decl);\n+  return IDENTIFIER_HASH_VALUE (entry->name);\n }\n \n bool\n-named_label_hasher::equal (named_label_entry *a, named_label_entry *b)\n+named_label_hash::equal (const value_type entry, compare_type name)\n {\n-  return a->label_decl == b->label_decl;\n+  return name == entry->name;\n }\n \n-/* Create a new label, named ID.  */\n+/* Look for a label named ID in the current function.  If one cannot\n+   be found, create one.  Return the named_label_entry, or NULL on\n+   failure.  */\n \n-static tree\n-make_label_decl (tree id, int local_p)\n+static named_label_entry *\n+lookup_label_1 (tree id, bool making_local_p)\n {\n-  struct named_label_entry *ent;\n-  tree decl;\n-\n-  decl = build_decl (input_location, LABEL_DECL, id, void_type_node);\n-\n-  DECL_CONTEXT (decl) = current_function_decl;\n-  SET_DECL_MODE (decl, VOIDmode);\n-  C_DECLARED_LABEL_FLAG (decl) = local_p;\n-\n-  /* Say where one reference is to the label, for the sake of the\n-     error if it is not defined.  */\n-  DECL_SOURCE_LOCATION (decl) = input_location;\n-\n-  /* Record the fact that this identifier is bound to this label.  */\n-  SET_IDENTIFIER_LABEL_VALUE (id, decl);\n+  /* You can't use labels at global scope.  */\n+  if (current_function_decl == NULL_TREE)\n+    {\n+      error (\"label %qE referenced outside of any function\", id);\n+      return NULL;\n+    }\n \n-  /* Create the label htab for the function on demand.  */\n   if (!named_labels)\n-    named_labels = hash_table<named_label_hasher>::create_ggc (13);\n+    named_labels = hash_table<named_label_hash>::create_ggc (13);\n \n-  /* Record this label on the list of labels used in this function.\n-     We do this before calling make_label_decl so that we get the\n-     IDENTIFIER_LABEL_VALUE before the new label is declared.  */\n-  ent = ggc_cleared_alloc<named_label_entry> ();\n-  ent->label_decl = decl;\n-\n-  named_label_entry **slot = named_labels->find_slot (ent, INSERT);\n-  gcc_assert (*slot == NULL);\n-  *slot = ent;\n+  hashval_t hash = IDENTIFIER_HASH_VALUE (id);\n+  named_label_entry **slot\n+    = named_labels->find_slot_with_hash (id, hash, INSERT);\n+  named_label_entry *old = *slot;\n+  \n+  if (old && old->label_decl)\n+    {\n+      if (!making_local_p)\n+\treturn old;\n \n-  return decl;\n-}\n+      if (old->binding_level == current_binding_level)\n+\t{\n+\t  error (\"local label %qE conflicts with existing label\", id);\n+\t  inform (DECL_SOURCE_LOCATION (old->label_decl), \"previous label\");\n+\t  return NULL;\n+\t}\n+    }\n \n-/* Look for a label named ID in the current function.  If one cannot\n-   be found, create one.  (We keep track of used, but undefined,\n-   labels, and complain about them at the end of a function.)  */\n+  /* We are making a new decl, create or reuse the named_label_entry  */\n+  named_label_entry *ent = NULL;\n+  if (old && !old->label_decl)\n+    ent = old;\n+  else\n+    {\n+      ent = ggc_cleared_alloc<named_label_entry> ();\n+      ent->name = id;\n+      ent->outer = old;\n+      *slot = ent;\n+    }\n \n-static tree\n-lookup_label_1 (tree id)\n-{\n-  tree decl;\n+  /* Now create the LABEL_DECL.  */\n+  tree decl = build_decl (input_location, LABEL_DECL, id, void_type_node);\n \n-  /* You can't use labels at global scope.  */\n-  if (current_function_decl == NULL_TREE)\n+  DECL_CONTEXT (decl) = current_function_decl;\n+  SET_DECL_MODE (decl, VOIDmode);\n+  if (making_local_p)\n     {\n-      error (\"label %qE referenced outside of any function\", id);\n-      return NULL_TREE;\n+      C_DECLARED_LABEL_FLAG (decl) = true;\n+      DECL_CHAIN (decl) = current_binding_level->names;\n+      current_binding_level->names = decl;\n     }\n \n-  /* See if we've already got this label.  */\n-  decl = IDENTIFIER_LABEL_VALUE (id);\n-  if (decl != NULL_TREE && DECL_CONTEXT (decl) == current_function_decl)\n-    return decl;\n+  ent->label_decl = decl;\n \n-  decl = make_label_decl (id, /*local_p=*/0);\n-  return decl;\n+  return ent;\n }\n \n /* Wrapper for lookup_label_1.  */\n \n tree\n lookup_label (tree id)\n {\n-  tree ret;\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n-  ret = lookup_label_1 (id);\n+  named_label_entry *ent = lookup_label_1 (id, false);\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return ret;\n+  return ent ? ent->label_decl : NULL_TREE;\n }\n \n-/* Declare a local label named ID.  */\n-\n tree\n declare_local_label (tree id)\n {\n-  tree decl;\n-  cp_label_binding bind;\n-\n-  /* Add a new entry to the SHADOWED_LABELS list so that when we leave\n-     this scope we can restore the old value of IDENTIFIER_TYPE_VALUE.  */\n-  bind.prev_value = IDENTIFIER_LABEL_VALUE (id);\n-\n-  decl = make_label_decl (id, /*local_p=*/1);\n-  bind.label = decl;\n-  vec_safe_push (current_binding_level->shadowed_labels, bind);\n-\n-  return decl;\n+  bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  named_label_entry *ent = lookup_label_1 (id, true);\n+  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n+  return ent ? ent->label_decl : NULL_TREE;\n }\n \n /* Returns nonzero if it is ill-formed to jump past the declaration of\n@@ -3232,8 +3204,6 @@ check_switch_goto (cp_binding_level* level)\n void\n check_goto (tree decl)\n {\n-  struct named_label_entry *ent, dummy;\n-\n   /* We can't know where a computed goto is jumping.\n      So we assume that it's OK.  */\n   if (TREE_CODE (decl) != LABEL_DECL)\n@@ -3244,22 +3214,22 @@ check_goto (tree decl)\n   if (decl == cdtor_label)\n     return;\n \n-  dummy.label_decl = decl;\n-  ent = named_labels->find (&dummy);\n-  gcc_assert (ent != NULL);\n+  hashval_t hash = IDENTIFIER_HASH_VALUE (DECL_NAME (decl));\n+  named_label_entry **slot\n+    = named_labels->find_slot_with_hash (DECL_NAME (decl), hash, NO_INSERT);\n+  named_label_entry *ent = *slot;\n \n   /* If the label hasn't been defined yet, defer checking.  */\n   if (! DECL_INITIAL (decl))\n     {\n-      struct named_label_use_entry *new_use;\n-\n       /* Don't bother creating another use if the last goto had the\n \t same data, and will therefore create the same set of errors.  */\n       if (ent->uses\n \t  && ent->uses->names_in_scope == current_binding_level->names)\n \treturn;\n \n-      new_use = ggc_alloc<named_label_use_entry> ();\n+      named_label_use_entry *new_use\n+\t= ggc_alloc<named_label_use_entry> ();\n       new_use->binding_level = current_binding_level;\n       new_use->names_in_scope = current_binding_level->names;\n       new_use->o_goto_locus = input_location;\n@@ -3378,25 +3348,15 @@ check_omp_return (void)\n static tree\n define_label_1 (location_t location, tree name)\n {\n-  struct named_label_entry *ent, dummy;\n-  cp_binding_level *p;\n-  tree decl;\n-\n-  decl = lookup_label (name);\n-\n-  dummy.label_decl = decl;\n-  ent = named_labels->find (&dummy);\n-  gcc_assert (ent != NULL);\n-\n   /* After labels, make any new cleanups in the function go into their\n      own new (temporary) binding contour.  */\n-  for (p = current_binding_level;\n+  for (cp_binding_level *p = current_binding_level;\n        p->kind != sk_function_parms;\n        p = p->level_chain)\n     p->more_cleanups_ok = 0;\n \n-  if (name == get_identifier (\"wchar_t\"))\n-    permerror (input_location, \"label named wchar_t\");\n+  named_label_entry *ent = lookup_label_1 (name, false);\n+  tree decl = ent->label_decl;\n \n   if (DECL_INITIAL (decl) != NULL_TREE)\n     {"}, {"sha": "da9187d644486babc0896dfb9135a0ba7c25b19b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -585,7 +585,6 @@ make_conv_op_name (tree type)\n \n       /* Just in case something managed to bind.  */\n       IDENTIFIER_BINDING (identifier) = NULL;\n-      IDENTIFIER_LABEL_VALUE (identifier) = NULL_TREE;\n \n       /* Hang TYPE off the identifier so it can be found easily later\n \t when performing conversions.  */"}, {"sha": "1fc128070d30b7619dc1f99a1973f6f7abfaa7b0", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -148,15 +148,6 @@ struct GTY(()) cp_class_binding {\n   tree identifier;\n };\n \n-\n-struct GTY(()) cp_label_binding {\n-  /* The bound LABEL_DECL.  */\n-  tree label;\n-  /* The previous IDENTIFIER_LABEL_VALUE.  */\n-  tree prev_value;\n-};\n-\n-\n /* For each binding contour we allocate a binding_level structure\n    which records the names defined in that contour.\n    Contours include:\n@@ -202,10 +193,6 @@ struct GTY(()) cp_binding_level {\n       the class.  */\n   tree type_shadowed;\n \n-  /* Similar to class_shadowed, but for IDENTIFIER_LABEL_VALUE, and\n-      used for all binding levels.  */\n-  vec<cp_label_binding, va_gc> *shadowed_labels;\n-\n   /* For each level (except not the global one),\n       a chain of BLOCK nodes for all the levels\n       that were entered and exited one level down.  */"}, {"sha": "90bae2a7039e58ce6cdec29cbb4c57e966093a3c", "filename": "gcc/cp/ptree.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fptree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2af967e9718d3d15461dbc5c52008ceab63a2f0/gcc%2Fcp%2Fptree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fptree.c?ref=a2af967e9718d3d15461dbc5c52008ceab63a2f0", "patch": "@@ -177,7 +177,6 @@ cxx_print_identifier (FILE *file, tree node, int indent)\n     indent_to (file, indent + 4);\n   fprintf (file, \"%s local bindings <%p>\", get_identifier_kind_name (node),\n \t   (void *) IDENTIFIER_BINDING (node));\n-  print_node (file, \"label\", IDENTIFIER_LABEL_VALUE (node), indent + 4);\n }\n \n void"}]}