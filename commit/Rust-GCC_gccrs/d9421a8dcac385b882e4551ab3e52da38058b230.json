{"sha": "d9421a8dcac385b882e4551ab3e52da38058b230", "node_id": "C_kwDOANBUbNoAKGQ5NDIxYThkY2FjMzg1Yjg4MmU0NTUxYWIzZTUyZGEzODA1OGIyMzA", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T19:32:14Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-12-14T21:41:58Z"}, "message": "rs6000: Rename functions with \"new\" in their names\n\nWhile we had two sets of built-in functionality at the same time, I put \"new\"\nin the names of quite a few functions.  Time to undo that.\n\n2021-12-02  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-c.c (altivec_resolve_new_overloaded_builtin):\n\tRemove forward declaration.\n\t(rs6000_new_builtin_type_compatible): Rename to\n\trs6000_builtin_type_compatible.\n\t(rs6000_builtin_type_compatible): Remove.\n\t(altivec_resolve_overloaded_builtin): Remove.\n\t(altivec_build_new_resolved_builtin): Rename to\n\taltivec_build_resolved_builtin.\n\t(altivec_resolve_new_overloaded_builtin): Rename to\n\taltivec_resolve_overloaded_builtin.  Remove static keyword.  Adjust\n\tcalled function names.\n\t* config/rs6000/rs6000-call.c (rs6000_expand_new_builtin): Remove\n\tforward declaration.\n\t(rs6000_gimple_fold_new_builtin): Likewise.\n\t(rs6000_invalid_new_builtin): Rename to rs6000_invalid_builtin.\n\t(rs6000_gimple_fold_builtin): Remove.\n\t(rs6000_new_builtin_valid_without_lhs): Rename to\n\trs6000_builtin_valid_without_lhs.\n\t(rs6000_new_builtin_is_supported): Rename to\n\trs6000_builtin_is_supported.\n\t(rs6000_gimple_fold_new_mma_builtin): Rename to\n\trs6000_gimple_fold_mma_builtin.\n\t(rs6000_gimple_fold_new_builtin): Rename to\n\trs6000_gimple_fold_builtin.  Remove static keyword.  Adjust called\n\tfunction names.\n\t(rs6000_expand_builtin): Remove.\n\t(new_cpu_expand_builtin): Rename to cpu_expand_builtin.\n\t(new_mma_expand_builtin): Rename to mma_expand_builtin.\n\t(new_htm_spr_num): Rename to htm_spr_num.\n\t(new_htm_expand_builtin): Rename to htm_expand_builtin.  Change name\n\tof called function.\n\t(rs6000_expand_new_builtin): Rename to rs6000_expand_builtin.  Remove\n\tstatic keyword.  Adjust called function names.\n\t(rs6000_new_builtin_decl): Rename to rs6000_builtin_decl.  Remove\n\tstatic keyword.\n\t(rs6000_builtin_decl): Remove.\n\t* config/rs6000/rs6000-gen-builtins.c (write_decls): In gnerated code,\n\trename rs6000_new_builtin_is_supported to rs6000_builtin_is_supported.\n\t* config/rs6000/rs6000-internal.h (rs6000_invalid_new_builtin): Rename\n\tto rs6000_invalid_builtin.\n\t* config/rs6000/rs6000.c (rs6000_new_builtin_vectorized_function):\n\tRename to rs6000_builtin_vectorized_function.\n\t(rs6000_new_builtin_md_vectorized_function): Rename to\n\trs6000_builtin_md_vectorized_function.\n\t(rs6000_builtin_vectorized_function): Remove.\n\t(rs6000_builtin_md_vectorized_function): Remove.", "tree": {"sha": "08ab3c653a5c724fd2bbf46b7e8252c06b06f45d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08ab3c653a5c724fd2bbf46b7e8252c06b06f45d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9421a8dcac385b882e4551ab3e52da38058b230", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9421a8dcac385b882e4551ab3e52da38058b230", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9421a8dcac385b882e4551ab3e52da38058b230", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9421a8dcac385b882e4551ab3e52da38058b230/comments", "author": null, "committer": null, "parents": [{"sha": "9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e855d235a08ba941f8e5ba398f1c3e8b497ba93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e855d235a08ba941f8e5ba398f1c3e8b497ba93"}], "stats": {"total": 255, "additions": 80, "deletions": 175}, "files": [{"sha": "f790c72d62131da24dc64fadf4dd561d75e372ac", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 42, "deletions": 78, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=d9421a8dcac385b882e4551ab3e52da38058b230", "patch": "@@ -37,9 +37,6 @@\n \n #include \"rs6000-internal.h\"\n \n-static tree altivec_resolve_new_overloaded_builtin (location_t, tree, void *);\n-\n-\n /* Handle the machine specific pragma longcall.  Its syntax is\n \n    # pragma longcall ( TOGGLE )\n@@ -817,7 +814,7 @@ is_float128_p (tree t)\n \n /* Return true iff ARGTYPE can be compatibly passed as PARMTYPE.  */\n static bool\n-rs6000_new_builtin_type_compatible (tree parmtype, tree argtype)\n+rs6000_builtin_type_compatible (tree parmtype, tree argtype)\n {\n   if (parmtype == error_mark_node)\n     return false;\n@@ -840,23 +837,6 @@ rs6000_new_builtin_type_compatible (tree parmtype, tree argtype)\n   return lang_hooks.types_compatible_p (parmtype, argtype);\n }\n \n-static inline bool\n-rs6000_builtin_type_compatible (tree t, int id)\n-{\n-  tree builtin_type;\n-  builtin_type = rs6000_builtin_type (id);\n-  if (t == error_mark_node)\n-    return false;\n-  if (INTEGRAL_TYPE_P (t) && INTEGRAL_TYPE_P (builtin_type))\n-    return true;\n-  else if (TARGET_IEEEQUAD && TARGET_LONG_DOUBLE_128\n-\t   && is_float128_p (t) && is_float128_p (builtin_type))\n-    return true;\n-  else\n-    return lang_hooks.types_compatible_p (t, builtin_type);\n-}\n-\n-\n /* In addition to calling fold_convert for EXPR of type TYPE, also\n    call c_fully_fold to remove any C_MAYBE_CONST_EXPRs that could be\n    hiding there (PR47197).  */\n@@ -873,16 +853,6 @@ fully_fold_convert (tree type, tree expr)\n   return result;\n }\n \n-/* Implementation of the resolve_overloaded_builtin target hook, to\n-   support Altivec's overloaded builtins.  */\n-\n-tree\n-altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n-\t\t\t\t    void *passed_arglist)\n-{\n-  return altivec_resolve_new_overloaded_builtin (loc, fndecl, passed_arglist);\n-}\n-\n /* Build a tree for a function call to an Altivec non-overloaded builtin.\n    The overloaded builtin that matched the types and args is described\n    by DESC.  The N arguments are given in ARGS, respectively.\n@@ -891,10 +861,9 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n    a small exception for vec_{all,any}_{ge,le} predicates. */\n \n static tree\n-altivec_build_new_resolved_builtin (tree *args, int n, tree fntype,\n-\t\t\t\t    tree ret_type,\n-\t\t\t\t    rs6000_gen_builtins bif_id,\n-\t\t\t\t    rs6000_gen_builtins ovld_id)\n+altivec_build_resolved_builtin (tree *args, int n, tree fntype, tree ret_type,\n+\t\t\t\trs6000_gen_builtins bif_id,\n+\t\t\t\trs6000_gen_builtins ovld_id)\n {\n   tree argtypes = TYPE_ARG_TYPES (fntype);\n   tree arg_type[MAX_OVLD_ARGS];\n@@ -963,9 +932,9 @@ altivec_build_new_resolved_builtin (tree *args, int n, tree fntype,\n    support Altivec's overloaded builtins.  FIXME: This code needs\n    to be brutally factored.  */\n \n-static tree\n-altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n-\t\t\t\t\tvoid *passed_arglist)\n+tree\n+altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n+\t\t\t\t    void *passed_arglist)\n {\n   vec<tree, va_gc> *arglist = static_cast<vec<tree, va_gc> *> (passed_arglist);\n   unsigned int nargs = vec_safe_length (arglist);\n@@ -1096,7 +1065,7 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t\tvec<tree, va_gc> *params = make_tree_vector ();\n \t\tvec_safe_push (params, arg0);\n \t\tvec_safe_push (params, arg1);\n-\t\ttree call = altivec_resolve_new_overloaded_builtin\n+\t\ttree call = altivec_resolve_overloaded_builtin\n \t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_CMPEQ],\n \t\t   params);\n \t\t/* Use save_expr to ensure that operands used more than once\n@@ -1106,7 +1075,7 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t\tparams = make_tree_vector ();\n \t\tvec_safe_push (params, call);\n \t\tvec_safe_push (params, call);\n-\t\treturn altivec_resolve_new_overloaded_builtin\n+\t\treturn altivec_resolve_overloaded_builtin\n \t\t  (loc, rs6000_builtin_decls_x[RS6000_OVLD_VEC_NOR], params);\n \t      }\n \t      /* Other types are errors.  */\n@@ -1165,19 +1134,17 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t\tadd_sub_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n \n \t      tree call\n-\t\t= altivec_resolve_new_overloaded_builtin (loc,\n-\t\t\t\t\t\t\t  add_sub_builtin,\n-\t\t\t\t\t\t\t  params);\n+\t\t= altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n+\t\t\t\t\t\t      params);\n \t      tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n \t      tree ones_vector = build_vector_from_val (arg0_type, const1);\n \t      tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n \t\t\t\t\t       arg2, ones_vector);\n \t      params = make_tree_vector ();\n \t      vec_safe_push (params, call);\n \t      vec_safe_push (params, and_expr);\n-\t      return altivec_resolve_new_overloaded_builtin (loc,\n-\t\t\t\t\t\t\t     add_sub_builtin,\n-\t\t\t\t\t\t\t     params);\n+\t      return altivec_resolve_overloaded_builtin (loc, add_sub_builtin,\n+\t\t\t\t\t\t\t params);\n \t    }\n \t  /* For {un}signed __int128s use the vaddeuqm/vsubeuqm instruction\n \t     directly.  */\n@@ -1244,9 +1211,8 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t    else\n \t      as_c_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUBC];\n \n-\t    tree call1 = altivec_resolve_new_overloaded_builtin (loc,\n-\t\t\t\t\t\t\t\t as_c_builtin,\n-\t\t\t\t\t\t\t\t params);\n+\t    tree call1 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n+\t\t\t\t\t\t\t     params);\n \t    params = make_tree_vector ();\n \t    vec_safe_push (params, arg0);\n \t    vec_safe_push (params, arg1);\n@@ -1256,24 +1222,23 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t    else\n \t      as_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_SUB];\n \n-\t    tree call2 = altivec_resolve_new_overloaded_builtin (loc,\n-\t\t\t\t\t\t\t\t as_builtin,\n-\t\t\t\t\t\t\t\t params);\n+\t    tree call2 = altivec_resolve_overloaded_builtin (loc, as_builtin,\n+\t\t\t\t\t\t\t     params);\n \t    tree const1 = build_int_cstu (TREE_TYPE (arg0_type), 1);\n \t    tree ones_vector = build_vector_from_val (arg0_type, const1);\n \t    tree and_expr = fold_build2_loc (loc, BIT_AND_EXPR, arg0_type,\n \t\t\t\t\t     arg2, ones_vector);\n \t    params = make_tree_vector ();\n \t    vec_safe_push (params, call2);\n \t    vec_safe_push (params, and_expr);\n-\t    call2 = altivec_resolve_new_overloaded_builtin (loc, as_c_builtin,\n-\t\t\t\t\t\t\t    params);\n+\t    call2 = altivec_resolve_overloaded_builtin (loc, as_c_builtin,\n+\t\t\t\t\t\t\tparams);\n \t    params = make_tree_vector ();\n \t    vec_safe_push (params, call1);\n \t    vec_safe_push (params, call2);\n \t    tree or_builtin = rs6000_builtin_decls_x[RS6000_OVLD_VEC_OR];\n-\t    return altivec_resolve_new_overloaded_builtin (loc, or_builtin,\n-\t\t\t\t\t\t\t   params);\n+\t    return altivec_resolve_overloaded_builtin (loc, or_builtin,\n+\t\t\t\t\t\t       params);\n \t    }\n \t  /* For {un}signed __int128s use the vaddecuq/vsubbecuq\n \t     instructions.  This occurs through normal processing.  */\n@@ -1779,17 +1744,17 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n \ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n \n-\tif (rs6000_new_builtin_type_compatible (types[0], parmtype0)\n-\t    && rs6000_new_builtin_type_compatible (types[1], parmtype1))\n+\tif (rs6000_builtin_type_compatible (types[0], parmtype0)\n+\t    && rs6000_builtin_type_compatible (types[1], parmtype1))\n \t  {\n \t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n-\t\t&& rs6000_new_builtin_is_supported (instance->bifid))\n+\t\t&& rs6000_builtin_is_supported (instance->bifid))\n \t      {\n \t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t\t   ret_type,\n-\t\t\t\t\t\t\t   instance->bifid,\n-\t\t\t\t\t\t\t   fcode);\n+\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t       ret_type,\n+\t\t\t\t\t\t       instance->bifid,\n+\t\t\t\t\t\t       fcode);\n \t      }\n \t    else\n \t      unsupported_builtin = true;\n@@ -1837,17 +1802,17 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \ttree parmtype0 = TREE_VALUE (TYPE_ARG_TYPES (fntype));\n \ttree parmtype1 = TREE_VALUE (TREE_CHAIN (TYPE_ARG_TYPES (fntype)));\n \n-\tif (rs6000_new_builtin_type_compatible (types[0], parmtype0)\n-\t    && rs6000_new_builtin_type_compatible (types[1], parmtype1))\n+\tif (rs6000_builtin_type_compatible (types[0], parmtype0)\n+\t    && rs6000_builtin_type_compatible (types[1], parmtype1))\n \t  {\n \t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n-\t\t&& rs6000_new_builtin_is_supported (instance->bifid))\n+\t\t&& rs6000_builtin_is_supported (instance->bifid))\n \t      {\n \t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t\t   ret_type,\n-\t\t\t\t\t\t\t   instance->bifid,\n-\t\t\t\t\t\t\t   fcode);\n+\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t       ret_type,\n+\t\t\t\t\t\t       instance->bifid,\n+\t\t\t\t\t\t       fcode);\n \t      }\n \t    else\n \t      unsupported_builtin = true;\n@@ -1869,8 +1834,7 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t\t arg_i++)\n \t      {\n \t\ttree parmtype = TREE_VALUE (nextparm);\n-\t\tif (!rs6000_new_builtin_type_compatible (types[arg_i],\n-\t\t\t\t\t\t\t parmtype))\n+\t\tif (!rs6000_builtin_type_compatible (types[arg_i], parmtype))\n \t\t  {\n \t\t    mismatch = true;\n \t\t    break;\n@@ -1881,16 +1845,16 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t    if (mismatch)\n \t      continue;\n \n-\t    supported = rs6000_new_builtin_is_supported (instance->bifid);\n+\t    supported = rs6000_builtin_is_supported (instance->bifid);\n \t    if (rs6000_builtin_decl (instance->bifid, false) != error_mark_node\n \t\t&& supported)\n \t      {\n \t\ttree fntype = rs6000_builtin_info_x[instance->bifid].fntype;\n \t\ttree ret_type = TREE_TYPE (instance->fntype);\n-\t\treturn altivec_build_new_resolved_builtin (args, n, fntype,\n-\t\t\t\t\t\t\t   ret_type,\n-\t\t\t\t\t\t\t   instance->bifid,\n-\t\t\t\t\t\t\t   fcode);\n+\t\treturn altivec_build_resolved_builtin (args, n, fntype,\n+\t\t\t\t\t\t       ret_type,\n+\t\t\t\t\t\t       instance->bifid,\n+\t\t\t\t\t\t       fcode);\n \t      }\n \t    else\n \t      {\n@@ -1908,7 +1872,7 @@ altivec_resolve_new_overloaded_builtin (location_t loc, tree fndecl,\n \t    /* Indicate that the instantiation of the overloaded builtin\n \t       name is not available with the target flags in effect.  */\n \t    rs6000_gen_builtins fcode = (rs6000_gen_builtins) instance->bifid;\n-\t    rs6000_invalid_new_builtin (fcode);\n+\t    rs6000_invalid_builtin (fcode);\n \t    /* Provide clarity of the relationship between the overload\n \t       and the instantiation.  */\n \t    const char *internal_name"}, {"sha": "833a290833a2e86e2cb5170d6f88e6660e733480", "filename": "gcc/config/rs6000/rs6000-call.c", "status": "modified", "additions": 30, "deletions": 69, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-call.c?ref=d9421a8dcac385b882e4551ab3e52da38058b230", "patch": "@@ -167,9 +167,6 @@ static const struct\n   { \"arch_3_1\",\t\tPPC_FEATURE2_ARCH_3_1,\t\t1 },\n   { \"mma\",\t\tPPC_FEATURE2_MMA,\t\t1 },\n };\n-\n-static rtx rs6000_expand_new_builtin (tree, rtx, rtx, machine_mode, int);\n-static bool rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi);\n \f\n /* Nonzero if we can use a floating-point register to pass this arg.  */\n #define USE_FP_FOR_ARG_P(CUM,MODE)\t\t\\\n@@ -3258,7 +3255,7 @@ altivec_expand_vec_ext_builtin (tree exp, rtx target)\n    appropriate target options being set.  */\n \n void\n-rs6000_invalid_new_builtin (enum rs6000_gen_builtins fncode)\n+rs6000_invalid_builtin (enum rs6000_gen_builtins fncode)\n {\n   size_t j = (size_t) fncode;\n   const char *name = rs6000_builtin_info_x[j].bifname;\n@@ -3479,20 +3476,11 @@ fold_mergeeo_helper (gimple_stmt_iterator *gsi, gimple *stmt, int use_odd)\n   gsi_replace (gsi, g, true);\n }\n \n-/* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n-   a constant, use rs6000_fold_builtin.)  */\n-\n-bool\n-rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n-{\n-  return rs6000_gimple_fold_new_builtin (gsi);\n-}\n-\n /*  Helper function to sort out which built-ins may be valid without having\n     a LHS.  */\n static bool\n-rs6000_new_builtin_valid_without_lhs (enum rs6000_gen_builtins fn_code,\n-\t\t\t\t      tree fndecl)\n+rs6000_builtin_valid_without_lhs (enum rs6000_gen_builtins fn_code,\n+\t\t\t\t  tree fndecl)\n {\n   if (TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node)\n     return true;\n@@ -3520,7 +3508,7 @@ rs6000_new_builtin_valid_without_lhs (enum rs6000_gen_builtins fn_code,\n /* Check whether a builtin function is supported in this target\n    configuration.  */\n bool\n-rs6000_new_builtin_is_supported (enum rs6000_gen_builtins fncode)\n+rs6000_builtin_is_supported (enum rs6000_gen_builtins fncode)\n {\n   switch (rs6000_builtin_info_x[(size_t) fncode].enable)\n     {\n@@ -3576,8 +3564,8 @@ rs6000_new_builtin_is_supported (enum rs6000_gen_builtins fncode)\n    __vector_quad arguments into pass-by-value arguments, leading to more\n    efficient code generation.  */\n static bool\n-rs6000_gimple_fold_new_mma_builtin (gimple_stmt_iterator *gsi,\n-\t\t\t\t    rs6000_gen_builtins fn_code)\n+rs6000_gimple_fold_mma_builtin (gimple_stmt_iterator *gsi,\n+\t\t\t\trs6000_gen_builtins fn_code)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   size_t fncode = (size_t) fn_code;\n@@ -3776,8 +3764,8 @@ rs6000_gimple_fold_new_mma_builtin (gimple_stmt_iterator *gsi,\n \n /* Fold a machine-dependent built-in in GIMPLE.  (For folding into\n    a constant, use rs6000_fold_builtin.)  */\n-static bool\n-rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi)\n+bool\n+rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt = gsi_stmt (*gsi);\n   tree fndecl = gimple_call_fndecl (stmt);\n@@ -3796,23 +3784,23 @@ rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi)\n \t\t\t  : \"nothing\";\n \n   if (TARGET_DEBUG_BUILTIN)\n-      fprintf (stderr, \"rs6000_gimple_fold_new_builtin %d %s %s\\n\",\n+      fprintf (stderr, \"rs6000_gimple_fold_builtin %d %s %s\\n\",\n \t       fn_code, fn_name1, fn_name2);\n \n   if (!rs6000_fold_gimple)\n     return false;\n \n   /* Prevent gimple folding for code that does not have a LHS, unless it is\n-     allowed per the rs6000_new_builtin_valid_without_lhs helper function.  */\n+     allowed per the rs6000_builtin_valid_without_lhs helper function.  */\n   if (!gimple_call_lhs (stmt)\n-      && !rs6000_new_builtin_valid_without_lhs (fn_code, fndecl))\n+      && !rs6000_builtin_valid_without_lhs (fn_code, fndecl))\n     return false;\n \n   /* Don't fold invalid builtins, let rs6000_expand_builtin diagnose it.  */\n-  if (!rs6000_new_builtin_is_supported (fn_code))\n+  if (!rs6000_builtin_is_supported (fn_code))\n     return false;\n \n-  if (rs6000_gimple_fold_new_mma_builtin (gsi, fn_code))\n+  if (rs6000_gimple_fold_mma_builtin (gsi, fn_code))\n     return true;\n \n   switch (fn_code)\n@@ -4755,20 +4743,6 @@ rs6000_gimple_fold_new_builtin (gimple_stmt_iterator *gsi)\n   return false;\n }\n \n-/* Expand an expression EXP that calls a built-in function,\n-   with result going to TARGET if that's convenient\n-   (and in mode MODE if that's convenient).\n-   SUBTARGET may be used as the target for computing one of EXP's operands.\n-   IGNORE is nonzero if the value is to be ignored.  */\n-\n-rtx\n-rs6000_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n-\t\t       machine_mode mode ATTRIBUTE_UNUSED,\n-\t\t       int ignore ATTRIBUTE_UNUSED)\n-{\n-  return rs6000_expand_new_builtin (exp, target, subtarget, mode, ignore);\n-}\n-\n /* Expand ALTIVEC_BUILTIN_MASK_FOR_LOAD.  */\n rtx\n rs6000_expand_ldst_mask (rtx target, tree arg0)\n@@ -4803,8 +4777,8 @@ rs6000_expand_ldst_mask (rtx target, tree arg0)\n \n /* Expand the CPU builtin in FCODE and store the result in TARGET.  */\n static rtx\n-new_cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n-\t\t\ttree exp ATTRIBUTE_UNUSED, rtx target)\n+cpu_expand_builtin (enum rs6000_gen_builtins fcode,\n+\t\t    tree exp ATTRIBUTE_UNUSED, rtx target)\n {\n   /* __builtin_cpu_init () is a nop, so expand to nothing.  */\n   if (fcode == RS6000_BIF_CPU_INIT)\n@@ -5206,8 +5180,8 @@ stv_expand_builtin (insn_code icode, rtx *op,\n \n /* Expand the MMA built-in in EXP, and return it.  */\n static rtx\n-new_mma_expand_builtin (tree exp, rtx target, insn_code icode,\n-\t\t\trs6000_gen_builtins fcode)\n+mma_expand_builtin (tree exp, rtx target, insn_code icode,\n+\t\t    rs6000_gen_builtins fcode)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   bool void_func = TREE_TYPE (TREE_TYPE (fndecl)) == void_type_node;\n@@ -5319,7 +5293,7 @@ new_mma_expand_builtin (tree exp, rtx target, insn_code icode,\n \n /* Return the appropriate SPR number associated with the given builtin.  */\n static inline HOST_WIDE_INT\n-new_htm_spr_num (enum rs6000_gen_builtins code)\n+htm_spr_num (enum rs6000_gen_builtins code)\n {\n   if (code == RS6000_BIF_GET_TFHAR\n       || code == RS6000_BIF_SET_TFHAR)\n@@ -5338,8 +5312,8 @@ new_htm_spr_num (enum rs6000_gen_builtins code)\n /* Expand the HTM builtin in EXP and store the result in TARGET.\n    Return the expanded rtx.  */\n static rtx\n-new_htm_expand_builtin (bifdata *bifaddr, rs6000_gen_builtins fcode,\n-\t\t\ttree exp, rtx target)\n+htm_expand_builtin (bifdata *bifaddr, rs6000_gen_builtins fcode,\n+\t\t    tree exp, rtx target)\n {\n   if (!TARGET_POWERPC64\n       && (fcode == RS6000_BIF_TABORTDC\n@@ -5425,7 +5399,7 @@ new_htm_expand_builtin (bifdata *bifaddr, rs6000_gen_builtins fcode,\n   if (uses_spr)\n     {\n       machine_mode mode = TARGET_POWERPC64 ? DImode : SImode;\n-      op[nopnds++] = gen_rtx_CONST_INT (mode, new_htm_spr_num (fcode));\n+      op[nopnds++] = gen_rtx_CONST_INT (mode, htm_spr_num (fcode));\n     }\n   /* If this builtin accesses a CR field, then pass in a scratch\n      CR field as the last operand.  */\n@@ -5497,11 +5471,9 @@ new_htm_expand_builtin (bifdata *bifaddr, rs6000_gen_builtins fcode,\n    SUBTARGET may be used as the target for computing one of EXP's operands.\n    IGNORE is nonzero if the value is to be ignored.\n    Use the new builtin infrastructure.  */\n-static rtx\n-rs6000_expand_new_builtin (tree exp, rtx target,\n-\t\t\t   rtx /* subtarget */,\n-\t\t\t   machine_mode /* mode */,\n-\t\t\t   int ignore)\n+rtx\n+rs6000_expand_builtin (tree exp, rtx target, rtx /* subtarget */,\n+\t\t       machine_mode /* mode */, int ignore)\n {\n   tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n   enum rs6000_gen_builtins fcode\n@@ -5610,7 +5582,7 @@ rs6000_expand_new_builtin (tree exp, rtx target,\n \t|| (e == ENB_P10_64 && TARGET_POWER10 && TARGET_POWERPC64)\n \t|| (e == ENB_MMA && TARGET_MMA)))\n     {\n-      rs6000_invalid_new_builtin (fcode);\n+      rs6000_invalid_builtin (fcode);\n       return expand_call (exp, target, ignore);\n     }\n \n@@ -5636,7 +5608,7 @@ rs6000_expand_new_builtin (tree exp, rtx target,\n     }\n \n   if (bif_is_cpu (*bifaddr))\n-    return new_cpu_expand_builtin (fcode, exp, target);\n+    return cpu_expand_builtin (fcode, exp, target);\n \n   if (bif_is_init (*bifaddr))\n     return altivec_expand_vec_init_builtin (TREE_TYPE (exp), exp, target);\n@@ -5651,7 +5623,7 @@ rs6000_expand_new_builtin (tree exp, rtx target,\n     return altivec_expand_predicate_builtin (icode, exp, target);\n \n   if (bif_is_htm (*bifaddr))\n-    return new_htm_expand_builtin (bifaddr, fcode, exp, target);\n+    return htm_expand_builtin (bifaddr, fcode, exp, target);\n \n   if (bif_is_32bit (*bifaddr) && TARGET_32BIT)\n     {\n@@ -5837,7 +5809,7 @@ rs6000_expand_new_builtin (tree exp, rtx target,\n     return lxvrze_expand_builtin (target, icode, op, mode[0], mode[1]);\n \n   if (bif_is_mma (*bifaddr))\n-    return new_mma_expand_builtin (exp, target, icode, fcode);\n+    return mma_expand_builtin (exp, target, icode, fcode);\n \n   if (fcode == RS6000_BIF_PACK_IF\n       && TARGET_LONG_DOUBLE_128\n@@ -6386,8 +6358,8 @@ rs6000_init_builtins (void)\n   return;\n }\n \n-static tree\n-rs6000_new_builtin_decl (unsigned code, bool /* initialize_p */)\n+tree\n+rs6000_builtin_decl (unsigned code, bool /* initialize_p */)\n {\n   rs6000_gen_builtins fcode = (rs6000_gen_builtins) code;\n \n@@ -6397,17 +6369,6 @@ rs6000_new_builtin_decl (unsigned code, bool /* initialize_p */)\n   return rs6000_builtin_decls_x[code];\n }\n \n-/* Returns the rs6000 builtin decl for CODE.  Note that we don't check\n-   the builtin mask here since there could be some #pragma/attribute\n-   target functions and the rs6000_builtin_mask could be wrong when\n-   this checking happens, though it will be updated properly later.  */\n-\n-tree\n-rs6000_builtin_decl (unsigned code, bool initialize_p ATTRIBUTE_UNUSED)\n-{\n-  return rs6000_new_builtin_decl (code, initialize_p);\n-}\n-\n /* Return the internal arg pointer used for function incoming\n    arguments.  When -fsplit-stack, the arg pointer is r12 so we need\n    to copy it to a pseudo in order for it to be preserved over calls"}, {"sha": "5c621c53f2b7fc782271f86e6721763c90237ccf", "filename": "gcc/config/rs6000/rs6000-gen-builtins.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-gen-builtins.c?ref=d9421a8dcac385b882e4551ab3e52da38058b230", "patch": "@@ -2382,8 +2382,7 @@ write_decls (void)\n \n   fprintf (header_file, \"extern void rs6000_init_generated_builtins ();\\n\\n\");\n   fprintf (header_file,\n-\t   \"extern bool rs6000_new_builtin_is_supported \"\n-\t   \"(rs6000_gen_builtins);\\n\");\n+\t   \"extern bool rs6000_builtin_is_supported (rs6000_gen_builtins);\\n\");\n   fprintf (header_file,\n \t   \"extern tree rs6000_builtin_decl (unsigned, \"\n \t   \"bool ATTRIBUTE_UNUSED);\\n\\n\");"}, {"sha": "49904b3f33dd52456454cd6761d37ffbc43cc939", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=d9421a8dcac385b882e4551ab3e52da38058b230", "patch": "@@ -142,7 +142,7 @@ extern void rs6000_output_mi_thunk (FILE *file,\n extern bool rs6000_output_addr_const_extra (FILE *file, rtx x);\n extern bool rs6000_gimple_fold_builtin (gimple_stmt_iterator *gsi);\n extern tree rs6000_build_builtin_va_list (void);\n-extern void rs6000_invalid_new_builtin (rs6000_gen_builtins fncode);\n+extern void rs6000_invalid_builtin (rs6000_gen_builtins fncode);\n extern void rs6000_va_start (tree valist, rtx nextarg);\n extern tree rs6000_gimplify_va_arg (tree valist, tree type, gimple_seq *pre_p,\n \t\t\t\t    gimple_seq *post_p);"}, {"sha": "9303e4e843f2037352cc2c0113ad09d2dcecade5", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 25, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9421a8dcac385b882e4551ab3e52da38058b230/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d9421a8dcac385b882e4551ab3e52da38058b230", "patch": "@@ -5568,14 +5568,14 @@ rs6000_loop_unroll_adjust (unsigned nunroll, struct loop *loop)\n    Implement targetm.vectorize.builtin_vectorized_function.  */\n \n static tree\n-rs6000_new_builtin_vectorized_function (unsigned int fn, tree type_out,\n-\t\t\t\t\ttree type_in)\n+rs6000_builtin_vectorized_function (unsigned int fn, tree type_out,\n+\t\t\t\t    tree type_in)\n {\n   machine_mode in_mode, out_mode;\n   int in_n, out_n;\n \n   if (TARGET_DEBUG_BUILTIN)\n-    fprintf (stderr, \"rs6000_new_builtin_vectorized_function (%s, %s, %s)\\n\",\n+    fprintf (stderr, \"rs6000_builtin_vectorized_function (%s, %s, %s)\\n\",\n \t     combined_fn_name (combined_fn (fn)),\n \t     GET_MODE_NAME (TYPE_MODE (type_out)),\n \t     GET_MODE_NAME (TYPE_MODE (type_in)));\n@@ -5700,15 +5700,15 @@ rs6000_new_builtin_vectorized_function (unsigned int fn, tree type_out,\n /* Implement targetm.vectorize.builtin_md_vectorized_function.  */\n \n static tree\n-rs6000_new_builtin_md_vectorized_function (tree fndecl, tree type_out,\n-\t\t\t\t\t   tree type_in)\n+rs6000_builtin_md_vectorized_function (tree fndecl, tree type_out,\n+\t\t\t\t       tree type_in)\n {\n   machine_mode in_mode, out_mode;\n   int in_n, out_n;\n \n   if (TARGET_DEBUG_BUILTIN)\n     fprintf (stderr,\n-\t     \"rs6000_new_builtin_md_vectorized_function (%s, %s, %s)\\n\",\n+\t     \"rs6000_builtin_md_vectorized_function (%s, %s, %s)\\n\",\n \t     IDENTIFIER_POINTER (DECL_NAME (fndecl)),\n \t     GET_MODE_NAME (TYPE_MODE (type_out)),\n \t     GET_MODE_NAME (TYPE_MODE (type_in)));\n@@ -5918,25 +5918,6 @@ rs6000_builtin_vectorized_libmass (combined_fn fn, tree type_out,\n   return new_fndecl;\n }\n \n-/* Returns a function decl for a vectorized version of the builtin function\n-   with builtin function code FN and the result vector type TYPE, or NULL_TREE\n-   if it is not available.  */\n-\n-static tree\n-rs6000_builtin_vectorized_function (unsigned int fn, tree type_out,\n-\t\t\t\t    tree type_in)\n-{\n-  return rs6000_new_builtin_vectorized_function (fn, type_out, type_in);\n-}\n-\n-/* Implement TARGET_VECTORIZE_BUILTIN_MD_VECTORIZED_FUNCTION.  */\n-\n-static tree\n-rs6000_builtin_md_vectorized_function (tree fndecl, tree type_out,\n-\t\t\t\t       tree type_in)\n-{\n-  return rs6000_new_builtin_md_vectorized_function (fndecl, type_out, type_in);\n-}\n \f\n /* Default CPU string for rs6000*_file_start functions.  */\n static const char *rs6000_default_cpu;"}]}