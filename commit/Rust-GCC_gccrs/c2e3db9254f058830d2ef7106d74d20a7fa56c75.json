{"sha": "c2e3db9254f058830d2ef7106d74d20a7fa56c75", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJlM2RiOTI1NGYwNTg4MzBkMmVmNzEwNmQ3NGQyMGE3ZmE1NmM3NQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "1999-09-16T15:45:15Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "1999-09-16T15:45:15Z"}, "message": "gjavah.c (get_field_name, [...]): Use xmalloc, not malloc.\n\n\t* gjavah.c (get_field_name, print_method_info, print_include,\n\tadd_namelet): Use xmalloc, not malloc.\n\n\t* jcf-depend.c (add_entry): Likewise.  Use xstrdup, not strdup.\n\t(munge): Use xrealloc, not realloc, trust xrealloc to handle a\n\tNULL pointer.\n\n\t* jcf-io.c (open_in_zip, find_class): Use xstrdup, not strdup.\n\n\t* jcf-parse.c (jcf_out_of_synch, yyparse): Likewise.\n\n\t* jcf-path.c (add_entry): Likewise.\n\n\t* jcf.h (ALLOC, REALLOC): Use xmalloc/xrealloc, not malloc/realloc.\n\n\t* jv-scan.c (xmalloc): Remove definition.\n\n\t* jvgenmain.c (xmalloc): Likewise.\n\n\t* jvspec.c (lang_specific_driver): Use xcalloc, not xmalloc/bzero.\n\n\t* lex.c (java_store_unicode): Use xrealloc, not realloc.\n\n\t* parse-scan.y: Use concat, not of xmalloc/assign/strcpy.  Use\n\tconcat, not xmalloc/sprintf.\n\t(java_push_parser_context): Use xcalloc, not xmalloc/bzero.\n\t(xstrdup): Remove definition.\n\n\t* parse.y (duplicate_declaration_error_p,\n\tconstructor_circularity_msg, verify_constructor_circularity,\n\tcheck_abstract_method_definitions, java_check_regular_methods,\n\tjava_check_abstract_methods, patch_method_invocation,\n\tcheck_for_static_method_reference, patch_assignment, patch_binop,\n\tpatch_cast, array_constructor_check_entry, patch_return,\n\tpatch_conditional_expr): Use xstrdup, not strdup.\n\n\t* zextract.c (ALLOC): Use xmalloc, not malloc.\n\nFrom-SVN: r29457", "tree": {"sha": "16053d5d21a42fd79947636788b0a774368e0381", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/16053d5d21a42fd79947636788b0a774368e0381"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2e3db9254f058830d2ef7106d74d20a7fa56c75", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e3db9254f058830d2ef7106d74d20a7fa56c75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2e3db9254f058830d2ef7106d74d20a7fa56c75", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2e3db9254f058830d2ef7106d74d20a7fa56c75/comments", "author": null, "committer": null, "parents": [{"sha": "7ca3e7133c3d125d31155affbddfb40ea29a0b9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7ca3e7133c3d125d31155affbddfb40ea29a0b9d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7ca3e7133c3d125d31155affbddfb40ea29a0b9d"}], "stats": {"total": 425, "additions": 196, "deletions": 229}, "files": [{"sha": "debc540f0dab68313c9618bd979449337bda58a8", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -1,3 +1,43 @@\n+1999-09-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* gjavah.c (get_field_name, print_method_info, print_include,\n+\tadd_namelet): Use xmalloc, not malloc.\n+\n+\t* jcf-depend.c (add_entry): Likewise.  Use xstrdup, not strdup.\n+\t(munge): Use xrealloc, not realloc, trust xrealloc to handle a\n+\tNULL pointer.\n+\n+\t* jcf-io.c (open_in_zip, find_class): Use xstrdup, not strdup.\n+\n+\t* jcf-parse.c (jcf_out_of_synch, yyparse): Likewise.\n+\t\n+\t* jcf-path.c (add_entry): Likewise.\n+\n+\t* jcf.h (ALLOC, REALLOC): Use xmalloc/xrealloc, not malloc/realloc.\n+\n+\t* jv-scan.c (xmalloc): Remove definition.\n+\n+\t* jvgenmain.c (xmalloc): Likewise.\n+\n+\t* jvspec.c (lang_specific_driver): Use xcalloc, not xmalloc/bzero.\n+\n+\t* lex.c (java_store_unicode): Use xrealloc, not realloc.\n+\n+\t* parse-scan.y: Use concat, not of xmalloc/assign/strcpy.  Use\n+\tconcat, not xmalloc/sprintf.\n+\t(java_push_parser_context): Use xcalloc, not xmalloc/bzero.\n+\t(xstrdup): Remove definition.\n+\n+\t* parse.y (duplicate_declaration_error_p,\n+\tconstructor_circularity_msg, verify_constructor_circularity,\n+\tcheck_abstract_method_definitions, java_check_regular_methods,\n+\tjava_check_abstract_methods, patch_method_invocation,\n+\tcheck_for_static_method_reference, patch_assignment, patch_binop,\n+\tpatch_cast, array_constructor_check_entry, patch_return,\n+\tpatch_conditional_expr): Use xstrdup, not strdup.\n+\n+\t* zextract.c (ALLOC): Use xmalloc, not malloc.\n+\n Sun Sep 12 23:30:09 1999  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* Make-lang.in (jvspec.o): Depend on system.h and gcc.h."}, {"sha": "a29cb62b87a5ebe6bb9c5762d41c073eba9ea3db", "filename": "gcc/java/gjavah.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fgjavah.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fgjavah.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fgjavah.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -385,7 +385,7 @@ get_field_name (jcf, name_index, flags)\n \t  return NULL;\n \t}\n \n-      override = (char *) malloc (length + 3);\n+      override = xmalloc (length + 3);\n       memcpy (override, name, length);\n       strcpy (override + length, \"__\");\n     }\n@@ -568,8 +568,8 @@ DEFUN(print_method_info, (stream, jcf, name_index, sig_index, flags),\n     {\n       struct method_name *nn;\n \n-      nn = (struct method_name *) malloc (sizeof (struct method_name));\n-      nn->name = (char *) malloc (length);\n+      nn = (struct method_name *) xmalloc (sizeof (struct method_name));\n+      nn->name = (char *) xmalloc (length);\n       memcpy (nn->name, str, length);\n       nn->length = length;\n       nn->next = method_name_list;\n@@ -1072,8 +1072,8 @@ print_include (out, utf8, len)\n \treturn;\n     }\n \n-  incl = (struct include *) malloc (sizeof (struct include));\n-  incl->name = malloc (len + 1);\n+  incl = (struct include *) xmalloc (sizeof (struct include));\n+  incl->name = xmalloc (len + 1);\n   strncpy (incl->name, utf8, len);\n   incl->name[len] = '\\0';\n   incl->next = all_includes;\n@@ -1157,8 +1157,8 @@ add_namelet (name, name_limit, parent)\n \n   if (n == NULL)\n     {\n-      n = (struct namelet *) malloc (sizeof (struct namelet));\n-      n->name = malloc (p - name + 1);\n+      n = (struct namelet *) xmalloc (sizeof (struct namelet));\n+      n->name = xmalloc (p - name + 1);\n       strncpy (n->name, name, p - name);\n       n->name[p - name] = '\\0';\n       n->is_class = (p == name_limit || *p == '$');"}, {"sha": "ca0b246320a90e0274f98b2d8e802553f1a5d54b", "filename": "gcc/java/jcf-depend.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-depend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-depend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-depend.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -90,8 +90,8 @@ add_entry (entp, name)\n     if (! strcmp (ent->file, name))\n       return;\n \n-  ent = (struct entry *) malloc (sizeof (struct entry));\n-  ent->file = strdup (name);\n+  ent = (struct entry *) xmalloc (sizeof (struct entry));\n+  ent->file = xstrdup (name);\n   ent->next = *entp;\n   *entp = ent;\n }\n@@ -177,10 +177,7 @@ munge (filename)\n   if (buflen < len)\n     {\n       buflen = len;\n-      if (buffer == NULL)\n-\tbuffer = malloc (buflen);\n-      else\n-\tbuffer = realloc (buffer, buflen);\n+      buffer = xrealloc (buffer, buflen);\n     }\n \n   dst = buffer;"}, {"sha": "2d43a513e8eee4739f9bc4ff9f20c584f693477a", "filename": "gcc/java/jcf-io.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-io.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -169,8 +169,8 @@ DEFUN(open_in_zip, (jcf, zipfile, zipmember, is_system),\n \t  jcf->read_ptr = jcf->buffer;\n \t  jcf->read_end = jcf->buffer_end;\n \t  jcf->filbuf = jcf_unexpected_eof;\n-\t  jcf->filename = strdup (zipfile);\n-\t  jcf->classname = strdup (zipmember);\n+\t  jcf->filename = xstrdup (zipfile);\n+\t  jcf->classname = xstrdup (zipmember);\n \t  jcf->zipd = (void *)zipd;\n \t  if (lseek (zipf->fd, zipd->filestart, 0) < 0\n \t      || read (zipf->fd, jcf->buffer, zipd->size) != zipd->size)\n@@ -414,14 +414,14 @@ DEFUN(find_class, (classname, classname_length, jcf, source_ok),\n     {\n       JCF_ZERO (jcf);\t\t/* JCF_FINISH relies on this */\n       jcf->java_source = 1;\n-      jcf->filename = (char *) strdup (buffer);\n+      jcf->filename = xstrdup (buffer);\n       close (fd);\t\t/* We use STDIO for source file */\n     }\n   else\n     buffer = open_class (buffer, jcf, fd, dep_file);\n   jcf->classname = (char *) ALLOC (classname_length + 1);\n   strncpy (jcf->classname, classname, classname_length + 1);\n-  jcf->classname = (char *) strdup (classname);\n+  jcf->classname = xstrdup (classname);\n   return buffer;\n #endif\n }"}, {"sha": "f32072c5ff749a6d2c68750f1c2b261bcee4bad9", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -449,7 +449,7 @@ void\n DEFUN(jcf_out_of_synch, (jcf),\n       JCF *jcf)\n {\n-  char *source = strdup (jcf->filename);\n+  char *source = xstrdup (jcf->filename);\n   int i = strlen (source);\n \n   while (source[i] != '.')\n@@ -778,7 +778,7 @@ int\n yyparse ()\n {\n   int several_files = 0;\n-  char *list = strdup (input_filename), *next;\n+  char *list = xstrdup (input_filename), *next;\n   tree node, current_file_list = NULL_TREE;\n \n   do "}, {"sha": "056be31d12cb930c7a7cfd80a918ce8b66e53188", "filename": "gcc/java/jcf-path.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-path.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf-path.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-path.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -167,11 +167,11 @@ add_entry (entp, filename, is_system)\n       strcpy (f2, filename);\n       f2[len] = DIR_SEPARATOR;\n       f2[len + 1] = '\\0';\n-      n->name = strdup (f2);\n+      n->name = xstrdup (f2);\n       ++len;\n     }\n   else\n-    n->name = strdup (filename);\n+    n->name = xstrdup (filename);\n \n   if (len > longest_path)\n     longest_path = len;"}, {"sha": "e19c80d7fd099e3d5ffaa5e0bde946afa25188c6", "filename": "gcc/java/jcf.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjcf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf.h?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -53,8 +53,8 @@ The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n #define JCF_u2 unsigned short\n #endif\n \n-#define ALLOC (void*)malloc\n-#define REALLOC (void*)realloc\n+#define ALLOC xmalloc\n+#define REALLOC xrealloc\n #ifndef FREE\n #define FREE(PTR) free(PTR)\n #endif"}, {"sha": "21970d749666d264916c9f3a4e65b1c2c929f123", "filename": "gcc/java/jv-scan.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjv-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjv-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjv-scan.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -200,14 +200,3 @@ gcc_obstack_init (obstack)\n \t\t  (void *(*) (long)) OBSTACK_CHUNK_ALLOC,\n \t\t  (void (*) (void *)) OBSTACK_CHUNK_FREE);\n }\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR val = (PTR) malloc (size);\n- \n-  if (val == 0)\n-    fatal (\"virtual memory exhausted\");\n-  return val;\n-}"}, {"sha": "07044848def3e44456d437f890e9467914feb1a6", "filename": "gcc/java/jvgenmain.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjvgenmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjvgenmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvgenmain.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -127,17 +127,3 @@ main (int argc, const char **argv)\n     }\n   return 0;\n }\n-\n-PTR\n-xmalloc (size)\n-  size_t size;\n-{\n-  register PTR val = (PTR) malloc (size);\n- \n-  if (val == 0)\n-    {\n-      fprintf(stderr, \"jvgenmain: virtual memory exhausted\");\n-      exit(FATAL_EXIT_CODE);\n-    }\n-  return val;\n-}"}, {"sha": "7aa143cbe060fea8593663e5ffd56e30df891a64", "filename": "gcc/java/jvspec.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjvspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fjvspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjvspec.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -192,8 +192,7 @@ lang_specific_driver (in_argc, in_argv, in_added_libraries)\n   argv = *in_argv;\n   added_libraries = *in_added_libraries;\n \n-  args = (int *) xmalloc (argc * sizeof (int));\n-  bzero ((char *) args, argc * sizeof (int));\n+  args = (int *) xcalloc (argc, sizeof (int));\n \n   for (i = 1; i < argc; i++)\n     {"}, {"sha": "814c8969429c6a41226b70742a65b5ef2beb546e", "filename": "gcc/java/lex.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flex.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -252,9 +252,9 @@ java_store_unicode (l, c, unicode_escape_p)\n   if (l->size == l->max)\n     {\n       l->max += JAVA_LINE_MAX;\n-      l->line = (unicode_t *)realloc (l->line, sizeof (unicode_t)*l->max);\n-      l->unicode_escape_p = (char *)realloc (l->unicode_escape_p, \n-\t\t\t\t\t     sizeof (char)*l->max);\n+      l->line = (unicode_t *) xrealloc (l->line, sizeof (unicode_t)*l->max);\n+      l->unicode_escape_p = (char *) xrealloc (l->unicode_escape_p, \n+\t\t\t\t\t       sizeof (char)*l->max);\n     }\n   l->line [l->size] = c;\n   l->unicode_escape_p [l->size++] = unicode_escape_p;"}, {"sha": "5c9721a667de1c3d578ffa96c7e93d69e288220b", "filename": "gcc/java/parse-scan.c", "status": "modified", "additions": 90, "deletions": 112, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -405,40 +405,40 @@ static const short yyrhs[] = {   123,\n #if YYDEBUG != 0\n static const short yyrline[] = { 0,\n    175,   180,   182,   183,   184,   185,   186,   190,   192,   195,\n-   201,   206,   213,   215,   218,   222,   226,   230,   232,   239,\n-   249,   251,   254,   258,   267,   272,   273,   274,   275,   276,\n-   277,   278,   279,   282,   284,   287,   289,   292,   297,   299,\n-   302,   306,   310,   312,   313,   319,   328,   339,   346,   346,\n-   349,   351,   352,   355,   356,   359,   362,   366,   368,   371,\n-   373,   376,   378,   379,   380,   383,   385,   386,   387,   391,\n-   394,   398,   401,   404,   406,   409,   412,   416,   418,   422,\n-   426,   429,   430,   432,   439,   446,   452,   455,   457,   465,\n-   481,   497,   498,   501,   504,   508,   510,   511,   515,   517,\n-   520,   530,   532,   535,   537,   543,   546,   550,   552,   553,\n-   554,   558,   560,   563,   565,   569,   571,   576,   579,   581,\n-   583,   587,   589,   592,   594,   597,   599,   602,   604,   605,\n-   606,   609,   613,   618,   620,   621,   622,   625,   627,   631,\n-   633,   636,   638,   641,   643,   644,   647,   651,   654,   658,\n-   660,   661,   662,   663,   664,   667,   669,   670,   671,   672,\n-   675,   677,   678,   679,   680,   681,   682,   683,   684,   685,\n-   686,   689,   693,   698,   702,   708,   712,   714,   715,   716,\n-   717,   718,   719,   722,   726,   730,   734,   738,   740,   741,\n-   742,   745,   747,   750,   755,   757,   760,   762,   765,   769,\n-   773,   777,   781,   785,   787,   790,   792,   795,   799,   802,\n-   803,   804,   807,   808,   811,   813,   816,   818,   821,   823,\n-   826,   828,   831,   835,   837,   840,   845,   847,   848,   851,\n-   853,   856,   860,   865,   867,   870,   872,   873,   874,   875,\n-   876,   877,   881,   883,   885,   889,   893,   895,   899,   900,\n-   904,   905,   906,   907,   910,   913,   916,   918,   919,   922,\n-   924,   925,   926,   929,   930,   933,   935,   938,   942,   944,\n-   947,   949,   952,   955,   957,   958,   959,   960,   963,   966,\n-   969,   971,   973,   974,   977,   981,   985,   987,   988,   989,\n-   990,   993,   997,  1001,  1003,  1004,  1005,  1008,  1010,  1011,\n-  1012,  1015,  1017,  1018,  1019,  1022,  1024,  1025,  1028,  1030,\n-  1031,  1032,  1035,  1037,  1038,  1039,  1040,  1041,  1044,  1046,\n-  1047,  1050,  1052,  1055,  1057,  1060,  1062,  1065,  1067,  1070,\n-  1072,  1075,  1077,  1080,  1082,  1085,  1089,  1092,  1093,  1096,\n-  1098,  1101,  1105\n+   201,   206,   213,   215,   218,   222,   226,   230,   232,   236,\n+   243,   245,   248,   252,   259,   264,   265,   266,   267,   268,\n+   269,   270,   271,   274,   276,   279,   281,   284,   289,   291,\n+   294,   298,   302,   304,   305,   311,   320,   331,   338,   338,\n+   341,   343,   344,   347,   348,   351,   354,   358,   360,   363,\n+   365,   368,   370,   371,   372,   375,   377,   378,   379,   383,\n+   386,   390,   393,   396,   398,   401,   404,   408,   410,   414,\n+   418,   421,   422,   424,   431,   438,   444,   447,   449,   455,\n+   471,   487,   488,   491,   494,   498,   500,   501,   505,   507,\n+   510,   520,   522,   525,   527,   533,   536,   540,   542,   543,\n+   544,   548,   550,   553,   555,   559,   561,   566,   569,   571,\n+   573,   577,   579,   582,   584,   587,   589,   592,   594,   595,\n+   596,   599,   603,   608,   610,   611,   612,   615,   617,   621,\n+   623,   626,   628,   631,   633,   634,   637,   641,   644,   648,\n+   650,   651,   652,   653,   654,   657,   659,   660,   661,   662,\n+   665,   667,   668,   669,   670,   671,   672,   673,   674,   675,\n+   676,   679,   683,   688,   692,   698,   702,   704,   705,   706,\n+   707,   708,   709,   712,   716,   720,   724,   728,   730,   731,\n+   732,   735,   737,   740,   745,   747,   750,   752,   755,   759,\n+   763,   767,   771,   775,   777,   780,   782,   785,   789,   792,\n+   793,   794,   797,   798,   801,   803,   806,   808,   811,   813,\n+   816,   818,   821,   825,   827,   830,   835,   837,   838,   841,\n+   843,   846,   850,   855,   857,   860,   862,   863,   864,   865,\n+   866,   867,   871,   873,   875,   879,   883,   885,   889,   890,\n+   894,   895,   896,   897,   900,   903,   906,   908,   909,   912,\n+   914,   915,   916,   919,   920,   923,   925,   928,   932,   934,\n+   937,   939,   942,   945,   947,   948,   949,   950,   953,   956,\n+   959,   961,   963,   964,   967,   971,   975,   977,   978,   979,\n+   980,   983,   987,   991,   993,   994,   995,   998,  1000,  1001,\n+  1002,  1005,  1007,  1008,  1009,  1012,  1014,  1015,  1018,  1020,\n+  1021,  1022,  1025,  1027,  1028,  1029,  1030,  1031,  1034,  1036,\n+  1037,  1040,  1042,  1045,  1047,  1050,  1052,  1055,  1057,  1060,\n+  1062,  1065,  1067,  1070,  1072,  1075,  1079,  1082,  1083,  1086,\n+  1088,  1091,  1095\n };\n #endif\n \n@@ -1378,7 +1378,7 @@ static const short yycheck[] = {     3,\n #define YYPURE 1\n \n /* -*-C-*-  Note some compilers choke on comments on `#line' lines.  */\n-#line 3 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n+#line 3 \"/usr/local/gnu/share/bison.simple\"\n \n /* Skeleton output parser for bison,\n    Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.\n@@ -1571,7 +1571,7 @@ __yy_memcpy (char *to, char *from, int count)\n #endif\n #endif\n \f\n-#line 196 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n+#line 196 \"/usr/local/gnu/share/bison.simple\"\n \n /* The user can define YYPARSE_PARAM as the name of an argument to be passed\n    into yyparse.  The argument should have type void *.\n@@ -1899,35 +1899,27 @@ case 12:\n case 19:\n #line 233 \"./parse-scan.y\"\n {\n-\t\t  char *n = xmalloc (strlen (yyvsp[-2].node)+2);\n-\t\t  n [0] = '[';\n-\t\t  strcpy (n+1, yyvsp[-2].node);\n-\t\t  yyval.node = n;\n+\t\t  yyval.node = concat (\"[\", yyvsp[-2].node, NULL);\n \t\t;\n     break;}\n case 20:\n-#line 240 \"./parse-scan.y\"\n+#line 237 \"./parse-scan.y\"\n {\t\n-\t\t  char *n = xmalloc (strlen (yyvsp[-2].node)+2);\n-\t\t  n [0] = '[';\n-\t\t  strcpy (n+1, yyvsp[-2].node);\n-\t\t  yyval.node = n;\n+\t\t  yyval.node = concat (\"[\", yyvsp[-2].node, NULL);\n \t\t;\n     break;}\n case 24:\n-#line 260 \"./parse-scan.y\"\n+#line 254 \"./parse-scan.y\"\n { \n-\t\t  char *n = xmalloc (strlen (yyvsp[-2].node)+strlen (yyvsp[0].node)+2);\n-\t\t  sprintf (n, \"%s.%s\", yyvsp[-2].node, yyvsp[0].node);\n-\t\t  yyval.node = n;\n+\t\t  yyval.node = concat (yyvsp[-2].node, \".\", yyvsp[0].node, NULL);\n \t\t;\n     break;}\n case 38:\n-#line 294 \"./parse-scan.y\"\n+#line 286 \"./parse-scan.y\"\n { package_name = yyvsp[-1].node; ;\n     break;}\n case 46:\n-#line 321 \"./parse-scan.y\"\n+#line 313 \"./parse-scan.y\"\n { \n \t\t  if (yyvsp[0].value == PUBLIC_TK)\n \t\t    modifier_value++;\n@@ -1937,7 +1929,7 @@ case 46:\n \t\t;\n     break;}\n case 47:\n-#line 329 \"./parse-scan.y\"\n+#line 321 \"./parse-scan.y\"\n { \n \t\t  if (yyvsp[0].value == PUBLIC_TK)\n \t\t    modifier_value++;\n@@ -1947,81 +1939,79 @@ case 47:\n \t\t;\n     break;}\n case 48:\n-#line 341 \"./parse-scan.y\"\n+#line 333 \"./parse-scan.y\"\n { \n \t\t  report_class_declaration(yyvsp[-2].node);\n \t\t  modifier_value = 0;\n                 ;\n     break;}\n case 50:\n-#line 347 \"./parse-scan.y\"\n+#line 339 \"./parse-scan.y\"\n { report_class_declaration(yyvsp[-2].node); ;\n     break;}\n case 56:\n-#line 361 \"./parse-scan.y\"\n+#line 353 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 57:\n-#line 363 \"./parse-scan.y\"\n+#line 355 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 70:\n-#line 393 \"./parse-scan.y\"\n+#line 385 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 71:\n-#line 395 \"./parse-scan.y\"\n+#line 387 \"./parse-scan.y\"\n { modifier_value = 0; ;\n     break;}\n case 76:\n-#line 411 \"./parse-scan.y\"\n+#line 403 \"./parse-scan.y\"\n { bracket_count = 0; USE_ABSORBER; ;\n     break;}\n case 77:\n-#line 413 \"./parse-scan.y\"\n+#line 405 \"./parse-scan.y\"\n { ++bracket_count; ;\n     break;}\n case 81:\n-#line 428 \"./parse-scan.y\"\n+#line 420 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 83:\n-#line 431 \"./parse-scan.y\"\n+#line 423 \"./parse-scan.y\"\n { modifier_value = 0; ;\n     break;}\n case 84:\n-#line 433 \"./parse-scan.y\"\n+#line 425 \"./parse-scan.y\"\n { \n                   report_main_declaration (yyvsp[-1].declarator);\n \t\t  modifier_value = 0;\n \t\t;\n     break;}\n case 85:\n-#line 441 \"./parse-scan.y\"\n+#line 433 \"./parse-scan.y\"\n { \n \t\t  struct method_declarator *d;\n \t\t  NEW_METHOD_DECLARATOR (d, yyvsp[-2].node, NULL);\n \t\t  yyval.declarator = d;\n \t\t;\n     break;}\n case 86:\n-#line 447 \"./parse-scan.y\"\n+#line 439 \"./parse-scan.y\"\n { \n \t\t  struct method_declarator *d;\n \t\t  NEW_METHOD_DECLARATOR (d, yyvsp[-3].node, yyvsp[-1].node);\n \t\t  yyval.declarator = d;\n \t\t;\n     break;}\n case 89:\n-#line 458 \"./parse-scan.y\"\n+#line 450 \"./parse-scan.y\"\n {\n-\t\t  char *n = xmalloc (strlen (yyvsp[-2].node)+strlen(yyvsp[0].node)+2);\n-\t\t  sprintf (n, \"%s,%s\", yyvsp[-2].node, yyvsp[0].node);\n-\t\t  yyval.node = n;\n+\t\t  yyval.node = concat (yyvsp[-2].node, \",\", yyvsp[0].node, NULL);\n \t\t;\n     break;}\n case 90:\n-#line 467 \"./parse-scan.y\"\n+#line 457 \"./parse-scan.y\"\n { \n \t\t  USE_ABSORBER;\n \t\t  if (bracket_count)\n@@ -2038,7 +2028,7 @@ case 90:\n \t\t;\n     break;}\n case 91:\n-#line 482 \"./parse-scan.y\"\n+#line 472 \"./parse-scan.y\"\n {\n \t\t  if (bracket_count)\n \t\t    {\n@@ -2054,112 +2044,112 @@ case 91:\n \t\t;\n     break;}\n case 94:\n-#line 503 \"./parse-scan.y\"\n+#line 493 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 95:\n-#line 505 \"./parse-scan.y\"\n+#line 495 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 101:\n-#line 522 \"./parse-scan.y\"\n+#line 512 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 103:\n-#line 533 \"./parse-scan.y\"\n+#line 523 \"./parse-scan.y\"\n { modifier_value = 0; ;\n     break;}\n case 105:\n-#line 538 \"./parse-scan.y\"\n+#line 528 \"./parse-scan.y\"\n { modifier_value = 0; ;\n     break;}\n case 106:\n-#line 545 \"./parse-scan.y\"\n+#line 535 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 107:\n-#line 547 \"./parse-scan.y\"\n+#line 537 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 114:\n-#line 564 \"./parse-scan.y\"\n+#line 554 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 115:\n-#line 566 \"./parse-scan.y\"\n+#line 556 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 118:\n-#line 578 \"./parse-scan.y\"\n+#line 568 \"./parse-scan.y\"\n { report_class_declaration (yyvsp[-1].node); modifier_value = 0; ;\n     break;}\n case 119:\n-#line 580 \"./parse-scan.y\"\n+#line 570 \"./parse-scan.y\"\n { report_class_declaration (yyvsp[-1].node); modifier_value = 0; ;\n     break;}\n case 120:\n-#line 582 \"./parse-scan.y\"\n+#line 572 \"./parse-scan.y\"\n { report_class_declaration (yyvsp[-2].node); modifier_value = 0; ;\n     break;}\n case 121:\n-#line 584 \"./parse-scan.y\"\n+#line 574 \"./parse-scan.y\"\n { report_class_declaration (yyvsp[-2].node); modifier_value = 0; ;\n     break;}\n case 148:\n-#line 653 \"./parse-scan.y\"\n+#line 643 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 149:\n-#line 655 \"./parse-scan.y\"\n+#line 645 \"./parse-scan.y\"\n { modifier_value = 0; ;\n     break;}\n case 173:\n-#line 695 \"./parse-scan.y\"\n+#line 685 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 226:\n-#line 842 \"./parse-scan.y\"\n+#line 832 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 243:\n-#line 882 \"./parse-scan.y\"\n+#line 872 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 244:\n-#line 884 \"./parse-scan.y\"\n+#line 874 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 246:\n-#line 890 \"./parse-scan.y\"\n+#line 880 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 255:\n-#line 912 \"./parse-scan.y\"\n+#line 902 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 273:\n-#line 954 \"./parse-scan.y\"\n+#line 944 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 274:\n-#line 956 \"./parse-scan.y\"\n+#line 946 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 279:\n-#line 965 \"./parse-scan.y\"\n+#line 955 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 282:\n-#line 972 \"./parse-scan.y\"\n+#line 962 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n case 337:\n-#line 1091 \"./parse-scan.y\"\n+#line 1081 \"./parse-scan.y\"\n { USE_ABSORBER; ;\n     break;}\n }\n    /* the action file gets copied in in place of this dollarsign */\n-#line 498 \"/usr/cygnus/TBD-TBD/share/bison.simple\"\n+#line 498 \"/usr/local/gnu/share/bison.simple\"\n \f\n   yyvsp -= yylen;\n   yyssp -= yylen;\n@@ -2355,7 +2345,7 @@ case 337:\n   yystate = yyn;\n   goto yynewstate;\n }\n-#line 1109 \"./parse-scan.y\"\n+#line 1099 \"./parse-scan.y\"\n \n \f\n /* Create a new parser context */\n@@ -2364,9 +2354,8 @@ void\n java_push_parser_context ()\n {\n   struct parser_ctxt *new = \n-    (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n+    (struct parser_ctxt *) xcalloc (1, sizeof (struct parser_ctxt));\n \n-  bzero ((PTR) new, sizeof (struct parser_ctxt));\n   new->next = ctxp;\n   ctxp = new;\n }  \n@@ -2436,14 +2425,3 @@ yyerror (msg)\n      const char *msg ATTRIBUTE_UNUSED;\n {\n }\n-\n-char *\n-xstrdup (s)\n-     const char *s;\n-{\n-  char *ret;\n-\n-  ret = xmalloc (strlen (s) + 1);\n-  strcpy (ret, s);\n-  return ret;\n-}"}, {"sha": "dee5dc2ddf423a3839b053c603d638cf59f5831d", "filename": "gcc/java/parse-scan.y", "status": "modified", "additions": 5, "deletions": 27, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse-scan.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse-scan.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse-scan.y?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -231,17 +231,11 @@ array_type:\n \tprimitive_type OSB_TK CSB_TK\n |\tname OSB_TK CSB_TK\n \t\t{\n-\t\t  char *n = xmalloc (strlen ($1)+2);\n-\t\t  n [0] = '[';\n-\t\t  strcpy (n+1, $1);\n-\t\t  $$ = n;\n+\t\t  $$ = concat (\"[\", $1, NULL);\n \t\t}\n |\tarray_type OSB_TK CSB_TK\n \t\t{\t\n-\t\t  char *n = xmalloc (strlen ($1)+2);\n-\t\t  n [0] = '[';\n-\t\t  strcpy (n+1, $1);\n-\t\t  $$ = n;\n+\t\t  $$ = concat (\"[\", $1, NULL);\n \t\t}\n ;\n \n@@ -258,9 +252,7 @@ simple_name:\n qualified_name:\n \tname DOT_TK identifier\n \t\t{ \n-\t\t  char *n = xmalloc (strlen ($1)+strlen ($3)+2);\n-\t\t  sprintf (n, \"%s.%s\", $1, $3);\n-\t\t  $$ = n;\n+\t\t  $$ = concat ($1, \".\", $3, NULL);\n \t\t}\n ;\n \n@@ -456,9 +448,7 @@ formal_parameter_list:\n \tformal_parameter\n |\tformal_parameter_list C_TK formal_parameter\n \t\t{\n-\t\t  char *n = xmalloc (strlen ($1)+strlen($3)+2);\n-\t\t  sprintf (n, \"%s,%s\", $1, $3);\n-\t\t  $$ = n;\n+\t\t  $$ = concat ($1, \",\", $3, NULL);\n \t\t}\n ;\n \n@@ -1114,9 +1104,8 @@ void\n java_push_parser_context ()\n {\n   struct parser_ctxt *new = \n-    (struct parser_ctxt *)xmalloc(sizeof (struct parser_ctxt));\n+    (struct parser_ctxt *) xcalloc (1, sizeof (struct parser_ctxt));\n \n-  bzero ((PTR) new, sizeof (struct parser_ctxt));\n   new->next = ctxp;\n   ctxp = new;\n }  \n@@ -1186,14 +1175,3 @@ yyerror (msg)\n      const char *msg ATTRIBUTE_UNUSED;\n {\n }\n-\n-char *\n-xstrdup (s)\n-     const char *s;\n-{\n-  char *ret;\n-\n-  ret = xmalloc (strlen (s) + 1);\n-  strcpy (ret, s);\n-  return ret;\n-}"}, {"sha": "7d8571e3c14e5c19e5e7da64801368b9872f3830", "filename": "gcc/java/parse.c", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -5710,14 +5710,14 @@ duplicate_declaration_error_p (new_field_name, new_type, cl)\n \t\t\t  new_field_name);\n   if (decl)\n     {\n-      char *t1 = strdup (purify_type_name\n+      char *t1 = xstrdup (purify_type_name\n \t\t\t ((TREE_CODE (new_type) == POINTER_TYPE \n \t\t\t   && TREE_TYPE (new_type) == NULL_TREE) ?\n \t\t\t  IDENTIFIER_POINTER (TYPE_NAME (new_type)) :\n \t\t\t  lang_printable_name (new_type, 1)));\n       /* The type may not have been completed by the time we report\n \t the error */\n-      char *t2 = strdup (purify_type_name\n+      char *t2 = xstrdup (purify_type_name\n \t\t\t ((TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE \n \t\t\t   && TREE_TYPE (TREE_TYPE (decl)) == NULL_TREE) ?\n \t\t\t  IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))) :\n@@ -6191,7 +6191,7 @@ constructor_circularity_msg (from, to)\n      tree from, to;\n {\n   static char string [4096];\n-  char *t = strdup (lang_printable_name (from, 0));\n+  char *t = xstrdup (lang_printable_name (from, 0));\n   sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 0));\n   free (t);\n   return string;\n@@ -6224,7 +6224,7 @@ verify_constructor_circularity (meth, current)\n \t\t  java_error_count--;\n \t\t}\n \t    }\n-\t  t = strdup (lang_printable_name (meth, 0));\n+\t  t = xstrdup (lang_printable_name (meth, 0));\n \t  parse_error_context (TREE_PURPOSE (c), \n \t\t\t       \"%s: recursive invocation of constructor `%s'\",\n \t\t\t       constructor_circularity_msg (current, meth), t);\n@@ -7227,7 +7227,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n \t that CLASS can use. */\n       if (!found)\n \t{\n-\t  char *t = strdup (lang_printable_name \n+\t  char *t = xstrdup (lang_printable_name \n \t\t\t    (TREE_TYPE (TREE_TYPE (method)), 0));\n \t  tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n \t  tree saved_wfl = NULL_TREE;\n@@ -7377,7 +7377,7 @@ java_check_regular_methods (class_decl)\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n \t{\n-\t  char *t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n+\t  char *t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n \t\t\t\t\t\t 0));\n \t  parse_error_context \n \t    (method_wfl,\n@@ -7568,7 +7568,7 @@ java_check_abstract_methods (interface_decl)\n \t  char *t;\n \t  tree saved_found_wfl = DECL_NAME (found);\n \t  reset_method_name (found);\n-\t  t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n+\t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n@@ -9758,7 +9758,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t  list = lookup_method_invoke (0, wfl, type, identifier, args);\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n-\t      char *fct_name = strdup (lang_printable_name (list, 0));\n+\t      char *fct_name = xstrdup (lang_printable_name (list, 0));\n \t      parse_error_context \n \t\t(identifier_wfl,\n \t\t \"Can't make static reference to method `%s %s' in class `%s'\",\n@@ -9904,7 +9904,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n      return the call */\n   if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n     {\n-      char *fct_name = strdup (lang_printable_name (list, 0));\n+      char *fct_name = xstrdup (lang_printable_name (list, 0));\n       parse_error_context \n \t(wfl, \"Can't access %s method `%s %s.%s' from `%s'\",\n \t java_accstring_lookup (get_access_flags_from_decl (list)),\n@@ -9969,7 +9969,7 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n   if (METHOD_STATIC (current_function_decl) \n       && !METHOD_STATIC (method) && !primary && !CALL_CONSTRUCTOR_P (node))\n     {\n-      char *fct_name = strdup (lang_printable_name (method, 0));\n+      char *fct_name = xstrdup (lang_printable_name (method, 0));\n       parse_error_context \n \t(wfl, \"Can't make static reference to method `%s %s' in class `%s'\", \n \t lang_printable_name (TREE_TYPE (TREE_TYPE (method)), 0), fct_name,\n@@ -11689,8 +11689,8 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Explicit cast required. This is an error */\n   if (!new_rhs)\n     {\n-      char *t1 = strdup (lang_printable_name (TREE_TYPE (rhs), 0));\n-      char *t2 = strdup (lang_printable_name (lhs_type, 0));\n+      char *t1 = xstrdup (lang_printable_name (TREE_TYPE (rhs), 0));\n+      char *t2 = xstrdup (lang_printable_name (lhs_type, 0));\n       tree wfl;\n       char operation [32];\t/* Max size known */\n \n@@ -12425,7 +12425,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t the type operand. This is a compile time error. */\n       else\n \t{\n-\t  char *t1 = strdup (lang_printable_name (op1_type, 0));\n+\t  char *t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n \t  parse_error_context \n \t    (wfl_operator, \"Impossible for `%s' to be instance of `%s'\",\n@@ -12534,7 +12534,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n       else\n \t{\n \t  char *t1;\n-\t  t1 = strdup (lang_printable_name (op1_type, 0));\n+\t  t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  parse_error_context \n \t    (wfl_operator, \"Incompatible type for `%s'. Can't convert `%s' \"\n \t     \"to `%s'\", operator_string (node), t1, \n@@ -13129,7 +13129,7 @@ patch_cast (node, wfl_operator)\n     }\n \n   /* Any other casts are proven incorrect at compile time */\n-  t1 = strdup (lang_printable_name (op_type, 0));\n+  t1 = xstrdup (lang_printable_name (op_type, 0));\n   parse_error_context (wfl_operator, \"Invalid cast from `%s' to `%s'\",\n \t\t       t1, lang_printable_name (cast_type, 0));\n   free (t1);\n@@ -13470,7 +13470,7 @@ array_constructor_check_entry (type, entry)\n       const char *msg = (!valid_cast_to_p (type_value, type) ?\n \t\t   \"Can't\" : \"Explicit cast needed to\");\n       if (!array_type_string)\n-\tarray_type_string = strdup (lang_printable_name (type, 1));\n+\tarray_type_string = xstrdup (lang_printable_name (type, 1));\n       parse_error_context \n \t(wfl_operator, \"Incompatible type for array. %s convert `%s' to `%s'\",\n \t msg, lang_printable_name (type_value, 1), array_type_string);\n@@ -13549,7 +13549,7 @@ patch_return (node)\n \n       else if (!DECL_CONSTRUCTOR_P (meth))\n \t{\n-\t  char *t = strdup (lang_printable_name (mtype, 0));\n+\t  char *t = xstrdup (lang_printable_name (mtype, 0));\n \t  parse_error_context (wfl_operator, \n \t\t\t       \"`return' with%s value from `%s %s'\",\n \t\t\t       (error_found == 1 ? \"\" : \"out\"), \n@@ -14525,7 +14525,7 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n   /* If we don't have any resulting type, we're in trouble */\n   if (!resulting_type)\n     {\n-      char *t = strdup (lang_printable_name (t1, 0));\n+      char *t = xstrdup (lang_printable_name (t1, 0));\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n \t\t\t   \"convert `%s' to `%s'\", t,"}, {"sha": "59b21444544d272dcde1a04a313c9ebf2db50be6", "filename": "gcc/java/parse.y", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -3123,14 +3123,14 @@ duplicate_declaration_error_p (new_field_name, new_type, cl)\n \t\t\t  new_field_name);\n   if (decl)\n     {\n-      char *t1 = strdup (purify_type_name\n+      char *t1 = xstrdup (purify_type_name\n \t\t\t ((TREE_CODE (new_type) == POINTER_TYPE \n \t\t\t   && TREE_TYPE (new_type) == NULL_TREE) ?\n \t\t\t  IDENTIFIER_POINTER (TYPE_NAME (new_type)) :\n \t\t\t  lang_printable_name (new_type, 1)));\n       /* The type may not have been completed by the time we report\n \t the error */\n-      char *t2 = strdup (purify_type_name\n+      char *t2 = xstrdup (purify_type_name\n \t\t\t ((TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE \n \t\t\t   && TREE_TYPE (TREE_TYPE (decl)) == NULL_TREE) ?\n \t\t\t  IDENTIFIER_POINTER (TYPE_NAME (TREE_TYPE (decl))) :\n@@ -3604,7 +3604,7 @@ constructor_circularity_msg (from, to)\n      tree from, to;\n {\n   static char string [4096];\n-  char *t = strdup (lang_printable_name (from, 0));\n+  char *t = xstrdup (lang_printable_name (from, 0));\n   sprintf (string, \"`%s' invokes `%s'\", t, lang_printable_name (to, 0));\n   free (t);\n   return string;\n@@ -3637,7 +3637,7 @@ verify_constructor_circularity (meth, current)\n \t\t  java_error_count--;\n \t\t}\n \t    }\n-\t  t = strdup (lang_printable_name (meth, 0));\n+\t  t = xstrdup (lang_printable_name (meth, 0));\n \t  parse_error_context (TREE_PURPOSE (c), \n \t\t\t       \"%s: recursive invocation of constructor `%s'\",\n \t\t\t       constructor_circularity_msg (current, meth), t);\n@@ -4640,7 +4640,7 @@ check_abstract_method_definitions (do_interface, class_decl, type)\n \t that CLASS can use. */\n       if (!found)\n \t{\n-\t  char *t = strdup (lang_printable_name \n+\t  char *t = xstrdup (lang_printable_name \n \t\t\t    (TREE_TYPE (TREE_TYPE (method)), 0));\n \t  tree ccn = DECL_NAME (TYPE_NAME (DECL_CONTEXT (method)));\n \t  tree saved_wfl = NULL_TREE;\n@@ -4790,7 +4790,7 @@ java_check_regular_methods (class_decl)\n \t types. */\n       if (TREE_TYPE (TREE_TYPE (found)) != TREE_TYPE (TREE_TYPE (method)))\n \t{\n-\t  char *t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n+\t  char *t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)),\n \t\t\t\t\t\t 0));\n \t  parse_error_context \n \t    (method_wfl,\n@@ -4981,7 +4981,7 @@ java_check_abstract_methods (interface_decl)\n \t  char *t;\n \t  tree saved_found_wfl = DECL_NAME (found);\n \t  reset_method_name (found);\n-\t  t = strdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n+\t  t = xstrdup (lang_printable_name (TREE_TYPE (TREE_TYPE (found)), 0));\n \t  parse_error_context \n \t    (method_wfl,\n \t     \"Method `%s' was defined with return type `%s' in class `%s'\",\n@@ -7171,7 +7171,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t  list = lookup_method_invoke (0, wfl, type, identifier, args);\n \t  if (list && !METHOD_STATIC (list))\n \t    {\n-\t      char *fct_name = strdup (lang_printable_name (list, 0));\n+\t      char *fct_name = xstrdup (lang_printable_name (list, 0));\n \t      parse_error_context \n \t\t(identifier_wfl,\n \t\t \"Can't make static reference to method `%s %s' in class `%s'\",\n@@ -7317,7 +7317,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n      return the call */\n   if (not_accessible_p (DECL_CONTEXT (current_function_decl), list, 0))\n     {\n-      char *fct_name = strdup (lang_printable_name (list, 0));\n+      char *fct_name = xstrdup (lang_printable_name (list, 0));\n       parse_error_context \n \t(wfl, \"Can't access %s method `%s %s.%s' from `%s'\",\n \t java_accstring_lookup (get_access_flags_from_decl (list)),\n@@ -7382,7 +7382,7 @@ check_for_static_method_reference (wfl, node, method, where, primary)\n   if (METHOD_STATIC (current_function_decl) \n       && !METHOD_STATIC (method) && !primary && !CALL_CONSTRUCTOR_P (node))\n     {\n-      char *fct_name = strdup (lang_printable_name (method, 0));\n+      char *fct_name = xstrdup (lang_printable_name (method, 0));\n       parse_error_context \n \t(wfl, \"Can't make static reference to method `%s %s' in class `%s'\", \n \t lang_printable_name (TREE_TYPE (TREE_TYPE (method)), 0), fct_name,\n@@ -9102,8 +9102,8 @@ patch_assignment (node, wfl_op1, wfl_op2)\n   /* Explicit cast required. This is an error */\n   if (!new_rhs)\n     {\n-      char *t1 = strdup (lang_printable_name (TREE_TYPE (rhs), 0));\n-      char *t2 = strdup (lang_printable_name (lhs_type, 0));\n+      char *t1 = xstrdup (lang_printable_name (TREE_TYPE (rhs), 0));\n+      char *t2 = xstrdup (lang_printable_name (lhs_type, 0));\n       tree wfl;\n       char operation [32];\t/* Max size known */\n \n@@ -9838,7 +9838,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n \t the type operand. This is a compile time error. */\n       else\n \t{\n-\t  char *t1 = strdup (lang_printable_name (op1_type, 0));\n+\t  char *t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n \t  parse_error_context \n \t    (wfl_operator, \"Impossible for `%s' to be instance of `%s'\",\n@@ -9947,7 +9947,7 @@ patch_binop (node, wfl_op1, wfl_op2)\n       else\n \t{\n \t  char *t1;\n-\t  t1 = strdup (lang_printable_name (op1_type, 0));\n+\t  t1 = xstrdup (lang_printable_name (op1_type, 0));\n \t  parse_error_context \n \t    (wfl_operator, \"Incompatible type for `%s'. Can't convert `%s' \"\n \t     \"to `%s'\", operator_string (node), t1, \n@@ -10542,7 +10542,7 @@ patch_cast (node, wfl_operator)\n     }\n \n   /* Any other casts are proven incorrect at compile time */\n-  t1 = strdup (lang_printable_name (op_type, 0));\n+  t1 = xstrdup (lang_printable_name (op_type, 0));\n   parse_error_context (wfl_operator, \"Invalid cast from `%s' to `%s'\",\n \t\t       t1, lang_printable_name (cast_type, 0));\n   free (t1);\n@@ -10883,7 +10883,7 @@ array_constructor_check_entry (type, entry)\n       const char *msg = (!valid_cast_to_p (type_value, type) ?\n \t\t   \"Can't\" : \"Explicit cast needed to\");\n       if (!array_type_string)\n-\tarray_type_string = strdup (lang_printable_name (type, 1));\n+\tarray_type_string = xstrdup (lang_printable_name (type, 1));\n       parse_error_context \n \t(wfl_operator, \"Incompatible type for array. %s convert `%s' to `%s'\",\n \t msg, lang_printable_name (type_value, 1), array_type_string);\n@@ -10962,7 +10962,7 @@ patch_return (node)\n \n       else if (!DECL_CONSTRUCTOR_P (meth))\n \t{\n-\t  char *t = strdup (lang_printable_name (mtype, 0));\n+\t  char *t = xstrdup (lang_printable_name (mtype, 0));\n \t  parse_error_context (wfl_operator, \n \t\t\t       \"`return' with%s value from `%s %s'\",\n \t\t\t       (error_found == 1 ? \"\" : \"out\"), \n@@ -11938,7 +11938,7 @@ patch_conditional_expr (node, wfl_cond, wfl_op1)\n   /* If we don't have any resulting type, we're in trouble */\n   if (!resulting_type)\n     {\n-      char *t = strdup (lang_printable_name (t1, 0));\n+      char *t = xstrdup (lang_printable_name (t1, 0));\n       SET_WFL_OPERATOR (wfl_operator, node, wfl_op1);\n       parse_error_context (wfl_operator, \"Incompatible type for `?:'. Can't \"\n \t\t\t   \"convert `%s' to `%s'\", t,"}, {"sha": "d959c3b8bdaf3fa902659494e0a64e34be671a64", "filename": "gcc/java/zextract.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fzextract.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2e3db9254f058830d2ef7106d74d20a7fa56c75/gcc%2Fjava%2Fzextract.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fzextract.c?ref=c2e3db9254f058830d2ef7106d74d20a7fa56c75", "patch": "@@ -262,7 +262,7 @@ read_zip_archive (zipf)\n     return -2;\n   zipf->count = makeword(&buffer[TOTAL_ENTRIES_CENTRAL_DIR]);\n   zipf->dir_size = makelong(&buffer[SIZE_CENTRAL_DIRECTORY]);\n-#define ALLOC malloc\n+#define ALLOC xmalloc\n   /* Allocate 1 more to allow appending '\\0' to last filename. */\n   zipf->central_directory = ALLOC (zipf->dir_size+1);\n   if (lseek (zipf->fd, -(zipf->dir_size+ECREC_SIZE+4), SEEK_CUR) < 0)"}]}