{"sha": "ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU3YTIzYTNmYWI3NGViZDQ1MjAzZDQ4ZmEwOTY4MWM5OTQ1ZWU3YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-31T09:18:06Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-31T09:18:06Z"}, "message": "Move clone_info to summary\n\n\t* Makefile.in: (OBJS): Add symtab-clones.o\n\t(GTFILES): Add symtab-clones.h\n\t* cgraph.c: Include symtab-clones.h.\n\t(cgraph_edge::resolve_speculation): Fix formating\n\t(cgraph_edge::redirect_call_stmt_to_callee): Update.\n\t(cgraph_update_edges_for_call_stmt): Update\n\t(release_function_body): Fix formating.\n\t(cgraph_node::remove): Fix formating.\n\t(cgraph_node::dump): Fix formating.\n\t(cgraph_node::get_availability): Fix formating.\n\t(cgraph_node::call_for_symbol_thunks_and_aliases): Fix formating.\n\t(set_const_flag_1): Fix formating.\n\t(set_pure_flag_1): Fix formating.\n\t(cgraph_node::can_remove_if_no_direct_calls_p): Fix formating.\n\t(collect_callers_of_node_1): Fix formating.\n\t(clone_of_p): Update.\n\t(cgraph_node::verify_node): Update.\n\t(cgraph_c_finalize): Call clone_info::release ().\n\t* cgraph.h (struct cgraph_clone_info): Move to symtab-clones.h.\n\t(cgraph_node): Remove clone_info.\n\t(symbol_table): Add m_clones.\n\t* cgraphclones.c: Include symtab-clone.h.\n\t(duplicate_thunk_for_node): Update.\n\t(cgraph_node::create_clone): Update.\n\t(cgraph_node::create_virtual_clone): Update.\n\t(cgraph_node::find_replacement): Update.\n\t(cgraph_node::materialize_clone): Update.\n\t* gengtype.c (open_base_files): Include symtab-clones.h.\n\t* ipa-cp.c: Include symtab-clones.h.\n\t(initialize_node_lattices): Update.\n\t(want_remove_some_param_p): Update.\n\t(create_specialized_node): Update.\n\t* ipa-fnsummary.c: Include symtab-clones.h.\n\t(ipa_fn_summary_t::duplicate): Update.\n\t* ipa-modref.c: Include symtab-clones.h.\n\t(update_signature): Update.\n\t* ipa-param-manipulation.c: Include symtab-clones.h.\n\t(ipa_param_body_adjustments::common_initialization): Update.\n\t* ipa-prop.c: Include symtab-clones.h.\n\t(adjust_agg_replacement_values): Update.\n\t(ipcp_get_parm_bits): Update.\n\t(ipcp_update_bits): Update.\n\t(ipcp_update_vr): Update.\n\t* ipa-sra.c: Include symtab-clones.h.\n\t(process_isra_node_results): Update.\n\t(disable_unavailable_parameters): Update.\n\t* lto-cgraph.c: Include symtab-clone.h.\n\t(output_cgraph_opt_summary_p): Update.\n\t(output_node_opt_summary): Update.\n\t(input_node_opt_summary): Update.\n\t* symtab-clones.cc: New file.\n\t* symtab-clones.h: New file.\n\t* tree-inline.c (expand_call_inline): Update.\n\t(update_clone_info): Update.\n\t(tree_function_versioning): Update.", "tree": {"sha": "dd288d22c32cd5f609204c5a62c74dd025194459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd288d22c32cd5f609204c5a62c74dd025194459"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/comments", "author": null, "committer": null, "parents": [{"sha": "617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617695cdc2b3d950f1e4deb5ea85d5cc302943f4"}], "stats": {"total": 523, "additions": 371, "deletions": 152}, "files": [{"sha": "7b94497b6f2e1f126f0a9f73aedf62fb3c28a796", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -1299,6 +1299,7 @@ OBJS = \\\n \tcfgrtl.o \\\n \tsymtab.o \\\n \tsymtab-thunks.o \\\n+\tsymtab-clones.o \\\n \tcgraph.o \\\n \tcgraphbuild.o \\\n \tcgraphunit.o \\\n@@ -2594,6 +2595,7 @@ GTFILES = $(CPPLIB_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/output.h $(srcdir)/cfgloop.h $(srcdir)/cfg.h $(srcdir)/profile-count.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/ipa-ref.h $(srcdir)/cgraph.h \\\n   $(srcdir)/symtab-thunks.h $(srcdir)/symtab-thunks.cc \\\n+  $(srcdir)/symtab-clones.h \\\n   $(srcdir)/reload.h $(srcdir)/caller-save.c $(srcdir)/symtab.c \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n   $(srcdir)/ipa-prop.c $(srcdir)/ipa-cp.c $(srcdir)/ipa-utils.h \\"}, {"sha": "9f3a72843105dbfe72fe203b10d70ad7c05f3cc4", "filename": "gcc/cgraph.c", "status": "modified", "additions": 53, "deletions": 43, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -66,6 +66,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-inline.h\"\n #include \"tree-nested.h\"\n #include \"symtab-thunks.h\"\n+#include \"symtab-clones.h\"\n \n /* FIXME: Only for PROP_loops, but cgraph shouldn't have to know about this.  */\n #include \"tree-pass.h\"\n@@ -1236,7 +1237,7 @@ cgraph_edge::resolve_speculation (cgraph_edge *edge, tree callee_decl)\n     {\n       cgraph_edge *tmp = edge;\n       if (dump_file)\n-        fprintf (dump_file, \"Speculative call turned into direct call.\\n\");\n+\tfprintf (dump_file, \"Speculative call turned into direct call.\\n\");\n       edge = e2;\n       e2 = tmp;\n       /* FIXME:  If EDGE is inlined, we should scale up the frequencies\n@@ -1488,38 +1489,43 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \t  return e->call_stmt;\n \t}\n     }\n-\n   if (flag_checking && decl)\n     {\n       cgraph_node *node = cgraph_node::get (decl);\n-      gcc_assert (!node || !node->clone.param_adjustments);\n+      clone_info *info = clone_info::get (node);\n+      gcc_assert (!node || !info || !info->param_adjustments);\n     }\n \n+  clone_info *callee_info = clone_info::get (e->callee);\n+  clone_info *caller_info = clone_info::get (e->caller);\n+\n   if (symtab->dump_file)\n     {\n+\n       fprintf (symtab->dump_file, \"updating call of %s -> %s: \",\n \t       e->caller->dump_name (), e->callee->dump_name ());\n       print_gimple_stmt (symtab->dump_file, e->call_stmt, 0, dump_flags);\n-      if (e->callee->clone.param_adjustments)\n-\te->callee->clone.param_adjustments->dump (symtab->dump_file);\n+      if (callee_info && callee_info->param_adjustments)\n+\tcallee_info->param_adjustments->dump (symtab->dump_file);\n       unsigned performed_len\n-\t= vec_safe_length (e->caller->clone.performed_splits);\n+\t= vec_safe_length (caller_info->performed_splits);\n       if (performed_len > 0)\n \tfprintf (symtab->dump_file, \"Performed splits records:\\n\");\n       for (unsigned i = 0; i < performed_len; i++)\n \t{\n \t  ipa_param_performed_split *sm\n-\t    = &(*e->caller->clone.performed_splits)[i];\n+\t    = &(*caller_info->performed_splits)[i];\n \t  print_node_brief (symtab->dump_file, \"  dummy_decl: \", sm->dummy_decl,\n \t\t\t    TDF_UID);\n \t  fprintf (symtab->dump_file, \", unit_offset: %u\\n\", sm->unit_offset);\n \t}\n     }\n \n-  if (ipa_param_adjustments *padjs = e->callee->clone.param_adjustments)\n+  if (ipa_param_adjustments *padjs\n+\t = callee_info ? callee_info->param_adjustments : NULL)\n     {\n       /* We need to defer cleaning EH info on the new statement to\n-         fixup-cfg.  We may not have dominator information at this point\n+\t fixup-cfg.  We may not have dominator information at this point\n \t and thus would end up with unreachable blocks and have no way\n \t to communicate that we need to run CFG cleanup then.  */\n       int lp_nr = lookup_stmt_eh_lp (e->call_stmt);\n@@ -1528,7 +1534,8 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \n       tree old_fntype = gimple_call_fntype (e->call_stmt);\n       new_stmt = padjs->modify_call (e->call_stmt,\n-\t\t\t\t     e->caller->clone.performed_splits,\n+\t\t\t\t     caller_info\n+\t\t\t\t     ? caller_info->performed_splits : NULL,\n \t\t\t\t     e->callee->decl, false);\n       cgraph_node *origin = e->callee;\n       while (origin->clone_of)\n@@ -1577,7 +1584,7 @@ cgraph_edge::redirect_call_stmt_to_callee (cgraph_edge *e)\n \t  var = get_or_create_ssa_default_def\n \t\t  (DECL_STRUCT_FUNCTION (e->caller->decl), var);\n \t  gimple *set_stmt = gimple_build_assign (lhs, var);\n-          gsi = gsi_for_stmt (new_stmt);\n+\t  gsi = gsi_for_stmt (new_stmt);\n \t  gsi_insert_before_without_update (&gsi, set_stmt, GSI_SAME_STMT);\n \t  update_stmt_fn (DECL_STRUCT_FUNCTION (e->caller->decl), set_stmt);\n \t}\n@@ -1703,7 +1710,8 @@ cgraph_update_edges_for_call_stmt (gimple *old_stmt, tree old_decl,\n   if (orig->clones)\n     for (node = orig->clones; node != orig;)\n       {\n-        cgraph_update_edges_for_call_stmt_node (node, old_stmt, old_decl, new_stmt);\n+\tcgraph_update_edges_for_call_stmt_node (node, old_stmt, old_decl,\n+\t\t\t\t\t\tnew_stmt);\n \tif (node->clones)\n \t  node = node->clones;\n \telse if (node->next_sibling_clone)\n@@ -1809,7 +1817,7 @@ release_function_body (tree decl)\n \tfree_histograms (fn);\n       gimple_set_body (decl, NULL);\n       /* Struct function hangs a lot of data that would leak if we didn't\n-         removed all pointers to it.   */\n+\t removed all pointers to it.   */\n       ggc_free (fn);\n       DECL_STRUCT_FUNCTION (decl) = NULL;\n     }\n@@ -1880,7 +1888,7 @@ cgraph_node::remove (void)\n       cgraph_node *n, *next;\n \n       if (clone_of)\n-        {\n+\t{\n \t  for (n = clones; n->next_sibling_clone; n = n->next_sibling_clone)\n \t    n->clone_of = clone_of;\n \t  n->clone_of = clone_of;\n@@ -1890,7 +1898,7 @@ cgraph_node::remove (void)\n \t  clone_of->clones = clones;\n \t}\n       else\n-        {\n+\t{\n \t  /* We are removing node with clones.  This makes clones inconsistent,\n \t     but assume they will be removed subsequently and just keep clone\n \t     tree intact.  This can happen in unreachable function removal since\n@@ -2248,12 +2256,12 @@ cgraph_node::dump (FILE *f)\n     {\n       if (edge->indirect_info->polymorphic)\n \t{\n-          fprintf (f, \"   Polymorphic indirect call of type \");\n+\t  fprintf (f, \"   Polymorphic indirect call of type \");\n \t  print_generic_expr (f, edge->indirect_info->otr_type, TDF_SLIM);\n \t  fprintf (f, \" token:%i\", (int) edge->indirect_info->otr_token);\n \t}\n       else\n-        fprintf (f, \"   Indirect call\");\n+\tfprintf (f, \"   Indirect call\");\n       edge->dump_edge_flags (f);\n       if (edge->indirect_info->param_index != -1)\n \t{\n@@ -2350,8 +2358,8 @@ cgraph_node::get_availability (symtab_node *ref)\n \n      Also comdat groups are always resolved in groups.  */\n   else if ((this == ref && !has_aliases_p ())\n-           || (ref && get_comdat_group ()\n-               && get_comdat_group () == ref->get_comdat_group ()))\n+\t   || (ref && get_comdat_group ()\n+\t       && get_comdat_group () == ref->get_comdat_group ()))\n     avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can\n      be overwritten at runtime.  It is not meaningful to enforce any sane\n@@ -2419,7 +2427,7 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n       || (avail = get_availability ()) > AVAIL_INTERPOSABLE)\n     {\n       if (callback (this, data))\n-        return true;\n+\treturn true;\n     }\n   FOR_EACH_ALIAS (this, ref)\n     {\n@@ -2614,8 +2622,8 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n     {\n       if (TREE_READONLY (node->decl))\n \t{\n-          TREE_READONLY (node->decl) = 0;\n-          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  TREE_READONLY (node->decl) = 0;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n \t  *changed = true;\n \t}\n     }\n@@ -2642,14 +2650,14 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n \t{\n \t  if (!looping && DECL_LOOPING_CONST_OR_PURE_P (node->decl))\n \t    {\n-              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t      DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n \t      *changed = true;\n \t    }\n \t}\n       else if (node->binds_to_current_def_p ())\n \t{\n \t  TREE_READONLY (node->decl) = true;\n-          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n \t  DECL_PURE_P (node->decl) = false;\n \t  *changed = true;\n \t}\n@@ -2661,12 +2669,12 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n \t  if (!DECL_PURE_P (node->decl))\n \t    {\n \t      DECL_PURE_P (node->decl) = true;\n-              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n+\t      DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n \t      *changed = true;\n \t    }\n \t  else if (!looping && DECL_LOOPING_CONST_OR_PURE_P (node->decl))\n \t    {\n-              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t      DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n \t      *changed = true;\n \t    }\n \t}\n@@ -2685,9 +2693,9 @@ set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n       {\n \t/* Virtual thunks access virtual offset in the vtable, so they can\n \t   only be pure, never const.  */\n-        if (set_const\n+\tif (set_const\n \t    && (thunk_info::get (e->caller)->virtual_offset_p\n-\t        || !node->binds_to_current_def_p (e->caller)))\n+\t\t|| !node->binds_to_current_def_p (e->caller)))\n \t  *changed |= e->caller->set_pure_flag (true, looping);\n \telse\n \t  set_const_flag_1 (e->caller, set_const, looping, changed);\n@@ -2757,23 +2765,23 @@ set_pure_flag_1 (cgraph_node *node, void *data)\n     {\n       if (!DECL_PURE_P (node->decl) && !TREE_READONLY (node->decl))\n \t{\n-          DECL_PURE_P (node->decl) = true;\n-          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = info->looping;\n+\t  DECL_PURE_P (node->decl) = true;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = info->looping;\n \t  info->changed = true;\n \t}\n       else if (DECL_LOOPING_CONST_OR_PURE_P (node->decl)\n \t       && !info->looping)\n \t{\n-          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n \t  info->changed = true;\n \t}\n     }\n   else\n     {\n       if (DECL_PURE_P (node->decl))\n \t{\n-          DECL_PURE_P (node->decl) = false;\n-          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  DECL_PURE_P (node->decl) = false;\n+\t  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n \t  info->changed = true;\n \t}\n     }\n@@ -2927,7 +2935,7 @@ cgraph_node::can_remove_if_no_direct_calls_p (bool will_inline)\n       /* If function is not being inlined, we care only about\n \t references outside of the comdat group.  */\n       if (!will_inline)\n-        for (int i = 0; next->iterate_referring (i, ref); i++)\n+\tfor (int i = 0; next->iterate_referring (i, ref); i++)\n \t  if (ref->referring->get_comdat_group () != get_comdat_group ())\n \t    return false;\n     }\n@@ -3031,7 +3039,7 @@ collect_callers_of_node_1 (cgraph_node *node, void *data)\n     for (cs = node->callers; cs != NULL; cs = cs->next_caller)\n       if (!cs->indirect_inlining_edge\n \t  && !cs->caller->thunk)\n-        redirect_callers->safe_push (cs);\n+\tredirect_callers->safe_push (cs);\n   return false;\n }\n \n@@ -3083,8 +3091,9 @@ clone_of_p (cgraph_node *node, cgraph_node *node2)\n \treturn true;\n       node = node->callees->callee->ultimate_alias_target ();\n \n-      if (!node2->clone.param_adjustments\n-\t  || node2->clone.param_adjustments->first_param_intact_p ())\n+      clone_info *info = clone_info::get (node2);\n+      if (!info || !info->param_adjustments\n+\t  || info->param_adjustments->first_param_intact_p ())\n \treturn false;\n       if (node2->former_clone_of == node->decl\n \t  || node2->former_clone_of == node->former_clone_of)\n@@ -3615,7 +3624,7 @@ cgraph_node::verify_node (void)\n       if (callees)\n \t{\n \t  error (\"Alias has call edges\");\n-          error_found = true;\n+\t  error_found = true;\n \t}\n       for (i = 0; iterate_reference (i, ref); i++)\n \tif (ref->use != IPA_REF_ALIAS)\n@@ -3642,18 +3651,18 @@ cgraph_node::verify_node (void)\n       if (!callees)\n \t{\n \t  error (\"No edge out of thunk node\");\n-          error_found = true;\n+\t  error_found = true;\n \t}\n       else if (callees->next_callee)\n \t{\n \t  error (\"More than one edge out of thunk node\");\n-          error_found = true;\n+\t  error_found = true;\n \t}\n       if (gimple_has_body_p (decl) && !inlined_to)\n-        {\n+\t{\n \t  error (\"Thunk is not supposed to have body\");\n-          error_found = true;\n-        }\n+\t  error_found = true;\n+\t}\n     }\n   else if (analyzed && gimple_has_body_p (decl)\n \t   && !TREE_ASM_WRITTEN (decl)\n@@ -3998,6 +4007,7 @@ cgraph_c_finalize (void)\n {\n   nested_function_info::release ();\n   thunk_info::release ();\n+  clone_info::release ();\n   symtab = NULL;\n \n   x_cgraph_nodes_queue = NULL;"}, {"sha": "cf543705e135158ac2c27bb39655b2928b24898f", "filename": "gcc/cgraph.h", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -691,27 +691,6 @@ struct GTY(()) ipa_replace_map\n   int parm_num;\n };\n \n-struct GTY(()) cgraph_clone_info\n-{\n-  /* Constants discovered by IPA-CP, i.e. which parameter should be replaced\n-     with what.  */\n-  vec<ipa_replace_map *, va_gc> *tree_map;\n-  /* Parameter modification that IPA-SRA decided to perform.  */\n-  ipa_param_adjustments *param_adjustments;\n-  /* Lists of dummy-decl and offset pairs representing split formal parameters\n-     in the caller.  Offsets of all new replacements are enumerated, those\n-     coming from the same original parameter have the same dummy decl stored\n-     along with them.\n-\n-     Dummy decls sit in call statement arguments followed by new parameter\n-     decls (or their SSA names) in between (caller) clone materialization and\n-     call redirection.  Redirection then recognizes the dummy variable and\n-     together with the stored offsets can reconstruct what exactly the new\n-     parameter decls represent and can leave in place only those that the\n-     callee expects.  */\n-  vec<ipa_param_performed_split, va_gc> *performed_splits;\n-};\n-\n enum cgraph_simd_clone_arg_type\n {\n   SIMD_CLONE_ARG_TYPE_VECTOR,\n@@ -879,7 +858,7 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n       next_sibling_clone (NULL), prev_sibling_clone (NULL), clones (NULL),\n       clone_of (NULL), call_site_hash (NULL), former_clone_of (NULL),\n       simdclone (NULL), simd_clones (NULL), ipa_transforms_to_apply (vNULL),\n-      inlined_to (NULL), rtl (NULL), clone (),\n+      inlined_to (NULL), rtl (NULL),\n       count (profile_count::uninitialized ()),\n       count_materialization_scale (REG_BR_PROB_BASE), profile_id (0),\n       unit_id (0), tp_first_run (0), thunk (false),\n@@ -1409,7 +1388,6 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   cgraph_node *inlined_to;\n \n   struct cgraph_rtl_info *rtl;\n-  cgraph_clone_info clone;\n \n   /* Expected number of executions: calculated in profile.c.  */\n   profile_count count;\n@@ -2190,10 +2168,16 @@ struct asmname_hasher : ggc_ptr_hash <symtab_node>\n   static bool equal (symtab_node *n, const_tree t);\n };\n \n+/* Core summaries maintained about symbols.  */\n+\n struct thunk_info;\n template <class T> class function_summary;\n typedef function_summary <thunk_info *> thunk_summary;\n \n+struct clone_info;\n+template <class T> class function_summary;\n+typedef function_summary <clone_info *> clone_summary;\n+\n class GTY((tag (\"SYMTAB\"))) symbol_table\n {\n public:\n@@ -2210,7 +2194,7 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   function_flags_ready (false), cpp_implicit_aliases_done (false),\n   section_hash (NULL), assembler_name_hash (NULL), init_priority_hash (NULL),\n   dump_file (NULL), ipa_clones_dump_file (NULL), cloned_nodes (),\n-  m_thunks (NULL),\n+  m_thunks (NULL), m_clones (NULL),\n   m_first_edge_removal_hook (NULL), m_first_cgraph_removal_hook (NULL),\n   m_first_edge_duplicated_hook (NULL), m_first_cgraph_duplicated_hook (NULL),\n   m_first_cgraph_insertion_hook (NULL), m_first_varpool_insertion_hook (NULL),\n@@ -2495,6 +2479,9 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Thunk annotations.  */\n   thunk_summary *m_thunks;\n \n+  /* Virtual clone annotations.  */\n+  clone_summary *m_clones;\n+\n private:\n   /* Allocate a cgraph_edge structure and fill it with data according to the\n      parameters of which only CALLEE can be NULL (when creating an indirect"}, {"sha": "b5793f90b64bcd626229719e552522129f980fd7", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n #include \"symtab-thunks.h\"\n+#include \"symtab-clones.h\"\n \n /* Create clone of edge in the node N represented by CALL_EXPR\n    the callgraph.  */\n@@ -201,16 +202,17 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n       }\n \n   tree new_decl;\n-  if (node->clone.param_adjustments)\n+  clone_info *info = clone_info::get (node);\n+  if (info && info->param_adjustments)\n     {\n       /* We do not need to duplicate this_adjusting thunks if we have removed\n \t this.  */\n       if (i->this_adjusting\n-\t  && !node->clone.param_adjustments->first_param_intact_p ())\n+\t  && !info->param_adjustments->first_param_intact_p ())\n \treturn node;\n \n       new_decl = copy_node (thunk->decl);\n-      ipa_param_body_adjustments body_adj (node->clone.param_adjustments,\n+      ipa_param_body_adjustments body_adj (info->param_adjustments,\n \t\t\t\t\t   new_decl);\n       body_adj.modify_formal_parameters ();\n     }\n@@ -237,7 +239,9 @@ duplicate_thunk_for_node (cgraph_node *thunk, cgraph_node *node)\n   new_thunk->thunk = thunk->thunk;\n   new_thunk->unique_name = in_lto_p;\n   new_thunk->former_clone_of = thunk->decl;\n-  new_thunk->clone.param_adjustments = node->clone.param_adjustments;\n+  if (info->param_adjustments)\n+    clone_info::get_create (new_thunk)->param_adjustments\n+\t   = info->param_adjustments;\n   new_thunk->unit_id = thunk->unit_id;\n   new_thunk->merged_comdat = thunk->merged_comdat;\n   new_thunk->merged_extern_inline = thunk->merged_extern_inline;\n@@ -403,13 +407,16 @@ cgraph_node::create_clone (tree new_decl, profile_count prof_count,\n   new_node->unit_id = unit_id;\n   new_node->merged_comdat = merged_comdat;\n   new_node->merged_extern_inline = merged_extern_inline;\n+  clone_info *info = clone_info::get (this);\n \n   if (param_adjustments)\n-    new_node->clone.param_adjustments = param_adjustments;\n-  else\n-    new_node->clone.param_adjustments = clone.param_adjustments;\n-  new_node->clone.tree_map = NULL;\n-  new_node->clone.performed_splits = vec_safe_copy (clone.performed_splits);\n+    clone_info::get_create (new_node)->param_adjustments = param_adjustments;\n+  else if (info && info->param_adjustments)\n+    clone_info::get_create (new_node)->param_adjustments\n+\t = info->param_adjustments;\n+  if (info && info->performed_splits)\n+    clone_info::get_create (new_node)->performed_splits\n+\t = vec_safe_copy (info->performed_splits);\n   new_node->split_part = split_part;\n \n   FOR_EACH_VEC_ELT (redirect_callers, i, e)\n@@ -616,7 +623,8 @@ cgraph_node::create_virtual_clone (vec<cgraph_edge *> redirect_callers,\n      ABI support for this.  */\n   set_new_clone_decl_and_node_flags (new_node);\n   new_node->ipcp_clone = ipcp_clone;\n-  new_node->clone.tree_map = tree_map;\n+  if (tree_map)\n+    clone_info::get_create (new_node)->tree_map = tree_map;\n   if (!implicit_section)\n     new_node->set_section (get_section ());\n \n@@ -682,7 +690,9 @@ cgraph_node::find_replacement (void)\n       clones = NULL;\n \n       /* Copy clone info.  */\n-      next_inline_clone->clone = clone;\n+      clone_info *info = clone_info::get (this);\n+      if (info)\n+\t*clone_info::get_create (next_inline_clone) = *info;\n \n       /* Now place it into clone tree at same level at NODE.  */\n       next_inline_clone->clone_of = clone_of;\n@@ -1087,6 +1097,7 @@ void cgraph_node::remove_from_clone_tree ()\n void\n cgraph_node::materialize_clone ()\n {\n+  clone_info *info = clone_info::get (this);\n   clone_of->get_untransformed_body ();\n   former_clone_of = clone_of->decl;\n   if (clone_of->former_clone_of)\n@@ -1096,29 +1107,30 @@ cgraph_node::materialize_clone ()\n       fprintf (symtab->dump_file, \"cloning %s to %s\\n\",\n \t       clone_of->dump_name (),\n \t       dump_name ());\n-      if (clone.tree_map)\n+      if (info->tree_map)\n         {\n \t  fprintf (symtab->dump_file, \"    replace map:\");\n \t  for (unsigned int i = 0;\n-\t       i < vec_safe_length (clone.tree_map);\n+\t       i < vec_safe_length (info->tree_map);\n \t       i++)\n \t    {\n \t      ipa_replace_map *replace_info;\n-\t      replace_info = (*clone.tree_map)[i];\n+\t      replace_info = (*info->tree_map)[i];\n \t      fprintf (symtab->dump_file, \"%s %i -> \",\n \t\t       i ? \",\" : \"\", replace_info->parm_num);\n \t      print_generic_expr (symtab->dump_file,\n \t\t\t\t  replace_info->new_tree);\n \t    }\n \t  fprintf (symtab->dump_file, \"\\n\");\n \t}\n-      if (clone.param_adjustments)\n-\tclone.param_adjustments->dump (symtab->dump_file);\n+      if (info->param_adjustments)\n+\tinfo->param_adjustments->dump (symtab->dump_file);\n     }\n   clear_stmts_in_references ();\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n   tree_function_versioning (clone_of->decl, decl,\n-\t\t\t    clone.tree_map, clone.param_adjustments,\n+\t\t\t    info ? info->tree_map : NULL,\n+\t\t\t    info ? info->param_adjustments : NULL,\n \t\t\t    true, NULL, NULL);\n   if (symtab->dump_file)\n     {"}, {"sha": "a7cf5c25893b8e8b7a62231e133804ec5808d5e9", "filename": "gcc/gengtype.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -1727,6 +1727,7 @@ open_base_files (void)\n       \"target-globals.h\", \"ipa-ref.h\", \"cgraph.h\", \"symbol-summary.h\",\n       \"ipa-prop.h\", \"ipa-fnsummary.h\", \"dwarf2out.h\", \"omp-general.h\",\n       \"omp-offload.h\", \"ipa-modref-tree.h\", \"ipa-modref.h\", \"symtab-thunks.h\",\n+      \"symtab-clones.h\",\n       NULL\n     };\n     const char *const *ifp;"}, {"sha": "140515668a62160615c42f2ba29f1c8ceedbbad8", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -124,6 +124,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"dbgcnt.h\"\n+#include \"symtab-clones.h\"\n \n template <typename valtype> class ipcp_value;\n \n@@ -1226,18 +1227,21 @@ initialize_node_lattices (struct cgraph_node *node)\n \n   auto_vec<bool, 16> surviving_params;\n   bool pre_modified = false;\n-  if (!disable && node->clone.param_adjustments)\n+\n+  clone_info *cinfo = clone_info::get (node);\n+\n+  if (!disable && cinfo && cinfo->param_adjustments)\n     {\n       /* At the moment all IPA optimizations should use the number of\n \t parameters of the prevailing decl as the m_always_copy_start.\n \t Handling any other value would complicate the code below, so for the\n \t time bing let's only assert it is so.  */\n-      gcc_assert ((node->clone.param_adjustments->m_always_copy_start\n+      gcc_assert ((cinfo->param_adjustments->m_always_copy_start\n \t\t   == ipa_get_param_count (info))\n-\t\t  || node->clone.param_adjustments->m_always_copy_start < 0);\n+\t\t  || cinfo->param_adjustments->m_always_copy_start < 0);\n \n       pre_modified = true;\n-      node->clone.param_adjustments->get_surviving_params (&surviving_params);\n+      cinfo->param_adjustments->get_surviving_params (&surviving_params);\n \n       if (dump_file && (dump_flags & TDF_DETAILS)\n \t  && !node->alias && !node->thunk)\n@@ -4456,9 +4460,10 @@ want_remove_some_param_p (cgraph_node *node, vec<tree> known_csts)\n \n       if (!filled_vec)\n        {\n-         if (!node->clone.param_adjustments)\n+\t clone_info *info = clone_info::get (node);\n+\t if (!info || !info->param_adjustments)\n            return true;\n-         node->clone.param_adjustments->get_surviving_params (&surviving);\n+\t info->param_adjustments->get_surviving_params (&surviving);\n          filled_vec = true;\n        }\n       if (surviving.length() < (unsigned) i &&  surviving[i])\n@@ -4484,7 +4489,9 @@ create_specialized_node (struct cgraph_node *node,\n   struct ipa_agg_replacement_value *av;\n   struct cgraph_node *new_node;\n   int i, count = ipa_get_param_count (info);\n-  ipa_param_adjustments *old_adjustments = node->clone.param_adjustments;\n+  clone_info *cinfo = clone_info::get (node);\n+  ipa_param_adjustments *old_adjustments = cinfo\n+\t\t\t\t\t   ? cinfo->param_adjustments : NULL;\n   ipa_param_adjustments *new_adjustments;\n   gcc_assert (!info->ipcp_orig_node);\n   gcc_assert (node->can_change_signature\n@@ -4538,7 +4545,7 @@ create_specialized_node (struct cgraph_node *node,\n   else\n     new_adjustments = NULL;\n \n-  replace_trees = vec_safe_copy (node->clone.tree_map);\n+  replace_trees = cinfo ? vec_safe_copy (cinfo->tree_map) : NULL;\n   for (i = 0; i < count; i++)\n     {\n       tree t = known_csts[i];"}, {"sha": "0393f2cad11f2edbf83c559e2e46ea0c16eabf0a", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"tree-into-ssa.h\"\n+#include \"symtab-clones.h\"\n \n /* Summaries.  */\n fast_function_summary <ipa_fn_summary *, va_gc> *ipa_fn_summaries;\n@@ -811,9 +812,10 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n      that are known to be false or true.  */\n   info->conds = vec_safe_copy (info->conds);\n \n+  clone_info *cinfo = clone_info::get (dst);\n   /* When there are any replacements in the function body, see if we can figure\n      out that something was optimized out.  */\n-  if (ipa_node_params_sum && dst->clone.tree_map)\n+  if (ipa_node_params_sum && cinfo && cinfo->tree_map)\n     {\n       vec<size_time_entry, va_gc> *entry = info->size_time_table;\n       /* Use SRC parm info since it may not be copied yet.  */\n@@ -834,7 +836,7 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t{\n \t  struct ipa_replace_map *r;\n \n-\t  for (j = 0; vec_safe_iterate (dst->clone.tree_map, j, &r); j++)\n+\t  for (j = 0; vec_safe_iterate (cinfo->tree_map, j, &r); j++)\n \t    {\n \t      if (r->parm_num == i)\n \t\t{"}, {"sha": "b40f3da3ba2b0debc84c72168da234322b182981", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -60,6 +60,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n #include \"attr-fnspec.h\"\n+#include \"symtab-clones.h\"\n \n /* Class (from which there is one global instance) that holds modref summaries\n    for all analyzed functions.  */\n@@ -1606,7 +1607,8 @@ modref_read (void)\n static void\n update_signature (struct cgraph_node *node)\n {\n-  if (!node->clone.param_adjustments)\n+  clone_info *info = clone_info::get (node);\n+  if (!info || !info->param_adjustments)\n     return;\n \n   modref_summary *r = optimization_summaries\n@@ -1625,9 +1627,9 @@ update_signature (struct cgraph_node *node)\n   size_t i, max = 0;\n   ipa_adjusted_param *p;\n \n-  FOR_EACH_VEC_SAFE_ELT (node->clone.param_adjustments->m_adj_params, i, p)\n+  FOR_EACH_VEC_SAFE_ELT (info->param_adjustments->m_adj_params, i, p)\n     {\n-      int idx = node->clone.param_adjustments->get_original_index (i);\n+      int idx = info->param_adjustments->get_original_index (i);\n       if (idx > (int)max)\n \tmax = idx;\n     }\n@@ -1637,9 +1639,9 @@ update_signature (struct cgraph_node *node)\n   map.reserve (max + 1);\n   for (i = 0; i <= max; i++)\n     map.quick_push (-1);\n-  FOR_EACH_VEC_SAFE_ELT (node->clone.param_adjustments->m_adj_params, i, p)\n+  FOR_EACH_VEC_SAFE_ELT (info->param_adjustments->m_adj_params, i, p)\n     {\n-      int idx = node->clone.param_adjustments->get_original_index (i);\n+      int idx = info->param_adjustments->get_original_index (i);\n       if (idx >= 0)\n \tmap[idx] = i;\n     }"}, {"sha": "2bbea21be2ebee04da5c7e95a218dbbabe1f5519", "filename": "gcc/ipa-param-manipulation.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-param-manipulation.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-param-manipulation.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-param-manipulation.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -40,6 +40,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-ssa.h\"\n #include \"tree-inline.h\"\n+#include \"alloc-pool.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-clones.h\"\n \n \n /* Actual prefixes of different newly synthetized parameters.  Keep in sync\n@@ -1072,7 +1075,8 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t\t  ipa_param_performed_split ps;\n \t\t  ps.dummy_decl = dummy_decl;\n \t\t  ps.unit_offset = apm->unit_offset;\n-\t\t  vec_safe_push (m_id->dst_node->clone.performed_splits, ps);\n+\t\t  vec_safe_push (clone_info::get_create\n+\t\t\t\t   (m_id->dst_node)->performed_splits, ps);\n \t\t}\n \t      else\n \t\tregister_replacement (apm, new_parm);\n@@ -1131,11 +1135,11 @@ ipa_param_body_adjustments::common_initialization (tree old_fndecl,\n \t when they were in fact replaced by a constant.  */\n       auto_vec <int, 16> index_mapping;\n       bool need_remap = false;\n+      clone_info *info = clone_info::get (m_id->src_node);\n \n-      if (m_id && m_id->src_node->clone.param_adjustments)\n+      if (m_id && info && info->param_adjustments)\n \t{\n-\t  ipa_param_adjustments *prev_adjustments\n-\t    = m_id->src_node->clone.param_adjustments;\n+\t  ipa_param_adjustments *prev_adjustments = info->param_adjustments;\n \t  prev_adjustments->get_updated_indices (&index_mapping);\n \t  need_remap = true;\n \t}"}, {"sha": "d4ef6ff8a8e7997b5c6f8056d03e8101f89457df", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -53,6 +53,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"options.h\"\n+#include \"symtab-clones.h\"\n \n /* Function summary where the parameter infos are actually stored. */\n ipa_node_params_t *ipa_node_params_sum = NULL;\n@@ -5419,12 +5420,13 @@ adjust_agg_replacement_values (struct cgraph_node *node,\n \t\t\t       struct ipa_agg_replacement_value *aggval)\n {\n   struct ipa_agg_replacement_value *v;\n+  clone_info *cinfo = clone_info::get (node);\n \n-  if (!node->clone.param_adjustments)\n+  if (!cinfo || !cinfo->param_adjustments)\n     return;\n \n   auto_vec<int, 16> new_indices;\n-  node->clone.param_adjustments->get_updated_indices (&new_indices);\n+  cinfo->param_adjustments->get_updated_indices (&new_indices);\n   for (v = aggval; v; v = v->next)\n     {\n       gcc_checking_assert (v->index >= 0);\n@@ -5577,9 +5579,10 @@ ipcp_get_parm_bits (tree parm, tree *value, widest_int *mask)\n \treturn false;\n     }\n \n-  if (cnode->clone.param_adjustments)\n+  clone_info *cinfo = clone_info::get (cnode);\n+  if (cinfo && cinfo->param_adjustments)\n     {\n-      i = cnode->clone.param_adjustments->get_original_index (i);\n+      i = cinfo->param_adjustments->get_original_index (i);\n       if (i < 0)\n \treturn false;\n     }\n@@ -5610,9 +5613,10 @@ ipcp_update_bits (struct cgraph_node *node)\n \n   auto_vec<int, 16> new_indices;\n   bool need_remapping = false;\n-  if (node->clone.param_adjustments)\n+  clone_info *cinfo = clone_info::get (node);\n+  if (cinfo && cinfo->param_adjustments)\n     {\n-      node->clone.param_adjustments->get_updated_indices (&new_indices);\n+      cinfo->param_adjustments->get_updated_indices (&new_indices);\n       need_remapping = true;\n     }\n   auto_vec <tree, 16> parm_decls;\n@@ -5731,9 +5735,10 @@ ipcp_update_vr (struct cgraph_node *node)\n \n   auto_vec<int, 16> new_indices;\n   bool need_remapping = false;\n-  if (node->clone.param_adjustments)\n+  clone_info *cinfo = clone_info::get (node);\n+  if (cinfo && cinfo->param_adjustments)\n     {\n-      node->clone.param_adjustments->get_updated_indices (&new_indices);\n+      cinfo->param_adjustments->get_updated_indices (&new_indices);\n       need_remapping = true;\n     }\n   auto_vec <tree, 16> parm_decls;"}, {"sha": "82acc6a21cbf088b5b430d77bed565de28ca30f9", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -84,6 +84,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfganal.h\"\n #include \"tree-streamer.h\"\n #include \"internal-fn.h\"\n+#include \"symtab-clones.h\"\n \n static void ipa_sra_summarize_function (cgraph_node *);\n \n@@ -3686,10 +3687,11 @@ process_isra_node_results (cgraph_node *node,\n \n   auto_vec<bool, 16> surviving_params;\n   bool check_surviving = false;\n-  if (node->clone.param_adjustments)\n+  clone_info *cinfo = clone_info::get (node);\n+  if (cinfo && cinfo->param_adjustments)\n     {\n       check_surviving = true;\n-      node->clone.param_adjustments->get_surviving_params (&surviving_params);\n+      cinfo->param_adjustments->get_surviving_params (&surviving_params);\n     }\n \n   unsigned param_count = vec_safe_length (ifs->m_parameters);\n@@ -3723,7 +3725,8 @@ process_isra_node_results (cgraph_node *node,\n     }\n \n   vec<ipa_adjusted_param, va_gc> *new_params = NULL;\n-  if (ipa_param_adjustments *old_adjustments = node->clone.param_adjustments)\n+  if (ipa_param_adjustments *old_adjustments\n+\t = cinfo ? cinfo->param_adjustments : NULL)\n     {\n       unsigned old_adj_len = vec_safe_length (old_adjustments->m_adj_params);\n       for (unsigned i = 0; i < old_adj_len; i++)\n@@ -3784,10 +3787,11 @@ disable_unavailable_parameters (cgraph_node *node, isra_func_summary *ifs)\n \n   auto_vec<bool, 16> surviving_params;\n   bool check_surviving = false;\n-  if (node->clone.param_adjustments)\n+  clone_info *cinfo = clone_info::get (node);\n+  if (cinfo && cinfo->param_adjustments)\n     {\n       check_surviving = true;\n-      node->clone.param_adjustments->get_surviving_params (&surviving_params);\n+      cinfo->param_adjustments->get_surviving_params (&surviving_params);\n     }\n   bool dumped_first = false;\n   for (unsigned i = 0; i < len; i++)"}, {"sha": "8718678136dbe4a57ef522aea91d9a271d105c75", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"symbol-summary.h\"\n #include \"symtab-thunks.h\"\n+#include \"symtab-clones.h\"\n \n /* True when asm nodes has been output.  */\n bool asm_nodes_output = false;\n@@ -1823,9 +1824,10 @@ input_offload_tables (bool do_force_output)\n static int\n output_cgraph_opt_summary_p (struct cgraph_node *node)\n {\n-  return ((node->clone_of || node->former_clone_of)\n-\t  && (node->clone.tree_map\n-\t      || node->clone.param_adjustments));\n+  if (node->clone_of || node->former_clone_of)\n+    return true;\n+  clone_info *info = clone_info::get (node);\n+  return info && (info->tree_map || info->param_adjustments);\n }\n \n /* Output optimization summary for EDGE to OB.  */\n@@ -1849,9 +1851,12 @@ output_node_opt_summary (struct output_block *ob,\n   /* TODO: Should this code be moved to ipa-param-manipulation?  */\n   struct bitpack_d bp;\n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, (node->clone.param_adjustments != NULL), 1);\n+  clone_info *info = clone_info::get (node);\n+  \n+  bp_pack_value (&bp, (info && info->param_adjustments != NULL), 1);\n   streamer_write_bitpack (&bp);\n-  if (ipa_param_adjustments *adjustments = node->clone.param_adjustments)\n+  if (ipa_param_adjustments *adjustments\n+\t\t = info ? info->param_adjustments : NULL)\n     {\n       streamer_write_uhwi (ob, vec_safe_length (adjustments->m_adj_params));\n       ipa_adjusted_param *adj;\n@@ -1879,17 +1884,18 @@ output_node_opt_summary (struct output_block *ob,\n \t}\n       streamer_write_hwi (ob, adjustments->m_always_copy_start);\n       bp = bitpack_create (ob->main_stream);\n-      bp_pack_value (&bp, node->clone.param_adjustments->m_skip_return, 1);\n+      bp_pack_value (&bp, info->param_adjustments->m_skip_return, 1);\n       streamer_write_bitpack (&bp);\n     }\n \n-  streamer_write_uhwi (ob, vec_safe_length (node->clone.tree_map));\n-  FOR_EACH_VEC_SAFE_ELT (node->clone.tree_map, i, map)\n-    {\n-      streamer_write_uhwi (ob, map->parm_num);\n-      gcc_assert (EXPR_LOCATION (map->new_tree) == UNKNOWN_LOCATION);\n-      stream_write_tree (ob, map->new_tree, true);\n-    }\n+  streamer_write_uhwi (ob, info ? vec_safe_length (info->tree_map) : 0);\n+  if (info)\n+    FOR_EACH_VEC_SAFE_ELT (info->tree_map, i, map)\n+      {\n+\tstreamer_write_uhwi (ob, map->parm_num);\n+\tgcc_assert (EXPR_LOCATION (map->new_tree) == UNKNOWN_LOCATION);\n+\tstream_write_tree (ob, map->new_tree, true);\n+      }\n \n   if (lto_symtab_encoder_in_partition_p (encoder, node))\n     {\n@@ -1959,6 +1965,8 @@ input_node_opt_summary (struct cgraph_node *node,\n   struct bitpack_d bp;\n   bp = streamer_read_bitpack (ib_main);\n   bool have_adjustments = bp_unpack_value (&bp, 1);\n+  clone_info *info = clone_info::get_create (node);\n+\n   if (have_adjustments)\n     {\n       count = streamer_read_uhwi (ib_main);\n@@ -1991,7 +1999,7 @@ input_node_opt_summary (struct cgraph_node *node,\n       int always_copy_start = streamer_read_hwi (ib_main);\n       bp = streamer_read_bitpack (ib_main);\n       bool skip_return = bp_unpack_value (&bp, 1);\n-      node->clone.param_adjustments\n+      info->param_adjustments\n \t= (new (ggc_alloc <ipa_param_adjustments> ())\n \t   ipa_param_adjustments (new_params, always_copy_start, skip_return));\n     }\n@@ -2001,7 +2009,7 @@ input_node_opt_summary (struct cgraph_node *node,\n     {\n       struct ipa_replace_map *map = ggc_alloc<ipa_replace_map> ();\n \n-      vec_safe_push (node->clone.tree_map, map);\n+      vec_safe_push (info->tree_map, map);\n       map->parm_num = streamer_read_uhwi (ib_main);\n       map->new_tree = stream_read_tree (ib_main, data_in);\n     }"}, {"sha": "76b86c6496f6e05a42c5ae460463928890c74c8c", "filename": "gcc/symtab-clones.cc", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fsymtab-clones.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fsymtab-clones.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-clones.cc?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -0,0 +1,76 @@\n+/* Support for virtual clones in symbol table.\n+   Copyright (C) 2003-2020 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"predict.h\"\n+#include \"target.h\"\n+#include \"rtl.h\"\n+#include \"alloc-pool.h\"\n+#include \"cgraph.h\"\n+#include \"symbol-summary.h\"\n+#include \"symtab-clones.h\"\n+#include \"lto-streamer.h\"\n+#include \"data-streamer.h\"\n+\n+namespace {\n+\n+/* Function summary for clone_infos.  */\n+class GTY((user)) clone_infos_t: public function_summary <clone_info *>\n+{\n+public:\n+  clone_infos_t (symbol_table *table, bool ggc):\n+    function_summary<clone_info *> (table, ggc) { }\n+\n+  /* Hook that is called by summary when a node is duplicated.  */\n+  virtual void duplicate (cgraph_node *node,\n+\t\t\t  cgraph_node *node2,\n+\t\t\t  clone_info *data,\n+\t\t\t  clone_info *data2);\n+};\n+\n+/* Duplication hook.  */\n+void\n+clone_infos_t::duplicate (cgraph_node *, cgraph_node *,\n+\t\t\t  clone_info *src, clone_info *dst)\n+{\n+  *dst = *src;\n+}\n+\n+}  /* anon namespace  */\n+\n+/* Return thunk_info possibly creating new one.  */\n+clone_info *\n+clone_info::get_create (cgraph_node *node)\n+{\n+  if (!symtab->m_clones)\n+    {\n+      symtab->m_clones\n+\t = new (ggc_alloc_no_dtor <clone_infos_t> ())\n+\t     clone_infos_t (symtab, true);\n+      symtab->m_clones->disable_insertion_hook ();\n+      symtab->m_clones->disable_duplication_hook ();\n+    }\n+  return symtab->m_clones->get_create (node);\n+}"}, {"sha": "a34fe21412ed69c76dabcfe8276df2d45bd72ad5", "filename": "gcc/symtab-clones.h", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fsymtab-clones.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Fsymtab-clones.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab-clones.h?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -0,0 +1,90 @@\n+/* Representation of adjustment made to virtual clones in the symbol table.\n+   Copyright (C) 2003-2020 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_SYMTAB_CLONES_H\n+#define GCC_SYMTAB_CLONES_H\n+\n+struct GTY(()) clone_info\n+{\n+  /* Constructor.  */\n+  clone_info ()\n+    : tree_map (NULL),\n+      param_adjustments (NULL),\n+      performed_splits (NULL)\n+  {\n+  }\n+  /* Constants discovered by IPA-CP, i.e. which parameter should be replaced\n+     with what.  */\n+  vec<ipa_replace_map *, va_gc> *tree_map;\n+  /* Parameter modification that IPA-SRA decided to perform.  */\n+  ipa_param_adjustments *param_adjustments;\n+  /* Lists of dummy-decl and offset pairs representing split formal parameters\n+     in the caller.  Offsets of all new replacements are enumerated, those\n+     coming from the same original parameter have the same dummy decl stored\n+     along with them.\n+\n+     Dummy decls sit in call statement arguments followed by new parameter\n+     decls (or their SSA names) in between (caller) clone materialization and\n+     call redirection.  Redirection then recognizes the dummy variable and\n+     together with the stored offsets can reconstruct what exactly the new\n+     parameter decls represent and can leave in place only those that the\n+     callee expects.  */\n+  vec<ipa_param_performed_split, va_gc> *performed_splits;\n+\n+  /* Return clone_info, if available.  */\n+  static clone_info *get (cgraph_node *node);\n+\n+  /* Return clone_info possibly creating new one.  */\n+  static clone_info *get_create (cgraph_node *node);\n+\n+  /* Remove clone_info.  */\n+  static void remove (cgraph_node *node);\n+\n+  /* Release all clone_infos.  */\n+  static void release (void);\n+};\n+\n+/* Return clone_info, if available.  */\n+inline clone_info *\n+clone_info::get (cgraph_node *node)\n+{\n+  if (!symtab->m_clones)\n+    return NULL;\n+  return symtab->m_clones->get (node);\n+}\n+\n+\n+/* Remove clone_info association for NODE.  */\n+inline void\n+clone_info::remove (cgraph_node *node)\n+{\n+  symtab->m_clones->remove (node);\n+}\n+\n+/* Free clone info summaries.  */\n+inline void\n+clone_info::release ()\n+{\n+  if (symtab->m_clones)\n+    delete (symtab->m_clones);\n+  symtab->m_clones = NULL;\n+}\n+\n+#endif  /* GCC_SYMTAB_CLONES_H  */"}, {"sha": "32424b169c7310c03168baf43cc56a8b6ef2f15b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 30, "deletions": 21, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae7a23a3fab74ebd45203d48fa09681c9945ee7a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ae7a23a3fab74ebd45203d48fa09681c9945ee7a", "patch": "@@ -64,6 +64,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"alloc-pool.h\"\n #include \"symbol-summary.h\"\n #include \"symtab-thunks.h\"\n+#include \"symtab-clones.h\"\n \n /* I'm not real happy about this, but we need to handle gimple and\n    non-gimple trees.  */\n@@ -4702,6 +4703,7 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n   use_operand_p use;\n   gimple *simtenter_stmt = NULL;\n   vec<tree> *simtvars_save;\n+  clone_info *info;\n \n   /* The gimplifier uses input_location in too many places, such as\n      internal_get_tmp_var ().  */\n@@ -5024,31 +5026,33 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id,\n   /* Add local vars in this inlined callee to caller.  */\n   add_local_variables (id->src_cfun, cfun, id);\n \n-  if (id->src_node->clone.performed_splits)\n+  info = clone_info::get (id->src_node);\n+  if (info && info->performed_splits)\n     {\n+      clone_info *dst_info = clone_info::get_create (id->dst_node);\n       /* Any calls from the inlined function will be turned into calls from the\n \t function we inline into.  We must preserve notes about how to split\n \t parameters such calls should be redirected/updated.  */\n-      unsigned len = vec_safe_length (id->src_node->clone.performed_splits);\n+      unsigned len = vec_safe_length (info->performed_splits);\n       for (unsigned i = 0; i < len; i++)\n \t{\n \t  ipa_param_performed_split ps\n-\t    = (*id->src_node->clone.performed_splits)[i];\n+\t    = (*info->performed_splits)[i];\n \t  ps.dummy_decl = remap_decl (ps.dummy_decl, id);\n-\t  vec_safe_push (id->dst_node->clone.performed_splits, ps);\n+\t  vec_safe_push (dst_info->performed_splits, ps);\n \t}\n \n       if (flag_checking)\n \t{\n-\t  len = vec_safe_length (id->dst_node->clone.performed_splits);\n+\t  len = vec_safe_length (dst_info->performed_splits);\n \t  for (unsigned i = 0; i < len; i++)\n \t    {\n \t      ipa_param_performed_split *ps1\n-\t\t= &(*id->dst_node->clone.performed_splits)[i];\n+\t\t= &(*dst_info->performed_splits)[i];\n \t      for (unsigned j = i + 1; j < len; j++)\n \t\t{\n \t\t  ipa_param_performed_split *ps2\n-\t\t    = &(*id->dst_node->clone.performed_splits)[j];\n+\t\t    = &(*dst_info->performed_splits)[j];\n \t\t  gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n \t\t\t      || ps1->unit_offset != ps2->unit_offset);\n \t\t}\n@@ -6074,8 +6078,9 @@ tree_versionable_function_p (tree fndecl)\n static void\n update_clone_info (copy_body_data * id)\n {\n+  clone_info *dst_info = clone_info::get (id->dst_node);\n   vec<ipa_param_performed_split, va_gc> *cur_performed_splits\n-    = id->dst_node->clone.performed_splits;\n+    = dst_info ? dst_info->performed_splits : NULL;\n   if (cur_performed_splits)\n     {\n       unsigned len = cur_performed_splits->length ();\n@@ -6092,23 +6097,24 @@ update_clone_info (copy_body_data * id)\n   for (node = id->dst_node->clones; node != id->dst_node;)\n     {\n       /* First update replace maps to match the new body.  */\n-      if (node->clone.tree_map)\n-        {\n+      clone_info *info = clone_info::get (node);\n+      if (info && info->tree_map)\n+\t{\n \t  unsigned int i;\n-          for (i = 0; i < vec_safe_length (node->clone.tree_map); i++)\n+\t  for (i = 0; i < vec_safe_length (info->tree_map); i++)\n \t    {\n \t      struct ipa_replace_map *replace_info;\n-\t      replace_info = (*node->clone.tree_map)[i];\n+\t      replace_info = (*info->tree_map)[i];\n \t      walk_tree (&replace_info->new_tree, copy_tree_body_r, id, NULL);\n \t    }\n \t}\n-      if (node->clone.performed_splits)\n+      if (info && info->performed_splits)\n \t{\n-\t  unsigned len = vec_safe_length (node->clone.performed_splits);\n+\t  unsigned len = vec_safe_length (info->performed_splits);\n \t  for (unsigned i = 0; i < len; i++)\n \t    {\n \t      ipa_param_performed_split *ps\n-\t\t= &(*node->clone.performed_splits)[i];\n+\t\t= &(*info->performed_splits)[i];\n \t      ps->dummy_decl = remap_decl (ps->dummy_decl, id);\n \t    }\n \t}\n@@ -6118,29 +6124,31 @@ update_clone_info (copy_body_data * id)\n \t     a copy of function body for later during inlining, that would just\n \t     duplicate all entries.  So let's have a look whether anything\n \t     referring to the first dummy_decl is present.  */\n-\t  unsigned dst_len = vec_safe_length (node->clone.performed_splits);\n+\t  if (!info)\n+\t    info = clone_info::get_create (node);\n+\t  unsigned dst_len = vec_safe_length (info->performed_splits);\n \t  ipa_param_performed_split *first = &(*cur_performed_splits)[0];\n \t  for (unsigned i = 0; i < dst_len; i++)\n-\t    if ((*node->clone.performed_splits)[i].dummy_decl\n+\t    if ((*info->performed_splits)[i].dummy_decl\n \t\t== first->dummy_decl)\n \t      {\n \t\tlen = 0;\n \t\tbreak;\n \t      }\n \n \t  for (unsigned i = 0; i < len; i++)\n-\t    vec_safe_push (node->clone.performed_splits,\n+\t    vec_safe_push (info->performed_splits,\n \t\t\t   (*cur_performed_splits)[i]);\n \t  if (flag_checking)\n \t    {\n \t      for (unsigned i = 0; i < dst_len; i++)\n \t\t{\n \t\t  ipa_param_performed_split *ps1\n-\t\t    = &(*node->clone.performed_splits)[i];\n+\t\t    = &(*info->performed_splits)[i];\n \t\t  for (unsigned j = i + 1; j < dst_len; j++)\n \t\t    {\n \t\t      ipa_param_performed_split *ps2\n-\t\t\t= &(*node->clone.performed_splits)[j];\n+\t\t\t= &(*info->performed_splits)[j];\n \t\t      gcc_assert (ps1->dummy_decl != ps2->dummy_decl\n \t\t\t\t  || ps1->unit_offset != ps2->unit_offset);\n \t\t    }\n@@ -6270,8 +6278,9 @@ tree_function_versioning (tree old_decl, tree new_decl,\n       = copy_static_chain (p, &id);\n \n   auto_vec<int, 16> new_param_indices;\n+  clone_info *info = clone_info::get (old_version_node);\n   ipa_param_adjustments *old_param_adjustments\n-    = old_version_node->clone.param_adjustments;\n+    = info ? info->param_adjustments : NULL;\n   if (old_param_adjustments)\n     old_param_adjustments->get_updated_indices (&new_param_indices);\n "}]}