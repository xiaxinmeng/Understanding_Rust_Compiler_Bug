{"sha": "4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRmNmFiYzZiM2UzODk5ZjJjNjE5ZDI3YzRjODczYThhOGUyNTM0MQ==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-16T11:29:53Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2002-06-16T11:29:53Z"}, "message": "TODO: Update.\n\n2002-06-16  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* docs/doxygen/TODO:  Update.\n\t* docs/doxygen/tables.html:  Uncomment magical middle column.\n\t* docs/doxygen/user.cfg.in:  Kludge to ignore function-like macros.\n\t* include/bits/stl_queue.h:  Doxygenate and reformat.\n\t* include/bits/ios_base.h, include/std/std_streambuf.h:  Add comment\n\tfor deprecated names required by the standard.\n\nFrom-SVN: r54666", "tree": {"sha": "5f05d1afe0bc46c3a952fc97cf0f787e68a6b8db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5f05d1afe0bc46c3a952fc97cf0f787e68a6b8db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/comments", "author": null, "committer": null, "parents": [{"sha": "77bb9994b87b68f5b3f194e282754169788f6b9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77bb9994b87b68f5b3f194e282754169788f6b9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77bb9994b87b68f5b3f194e282754169788f6b9c"}], "stats": {"total": 484, "additions": 358, "deletions": 126}, "files": [{"sha": "94eff35ff098f771ec473f64c80b66aa735a8e72", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -1,3 +1,12 @@\n+2002-06-16  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* docs/doxygen/TODO:  Update.\n+\t* docs/doxygen/tables.html:  Uncomment magical middle column.\n+\t* docs/doxygen/user.cfg.in:  Kludge to ignore function-like macros.\n+\t* include/bits/stl_queue.h:  Doxygenate and reformat.\n+\t* include/bits/ios_base.h, include/std/std_streambuf.h:  Add comment\n+\tfor deprecated names required by the standard.\n+\n 2002-06-14  J.T. Conklin  <jtc@acorntoolworks.com>\n \n \t* configure.in (target_alias): Fix."}, {"sha": "50ddfe7f2d6433645d10e33a9b405d48bc66e0a5", "filename": "libstdc++-v3/docs/doxygen/TODO", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2FTODO?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -25,7 +25,8 @@ c20             Note A\n c21             Untouched, Note B\n c22             Untouched\n c23             See doxygroups.cc and Note B.  Notes on what invalidates\n-                iterators need to be added.\n+                iterators need to be added.  std::list-specific memfns need\n+                to be filled out.\n c24             stl_iterator.h (__normal_iterator, other small TODO bits)\n                 stream iterators\n c25             stl_algo.h (lots of stuff)"}, {"sha": "7c340529352bc9da21b4e311921706b8d6a8a8d6", "filename": "libstdc++-v3/docs/doxygen/tables.html", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Ftables.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Ftables.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Ftables.html?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -39,21 +39,23 @@ <h1>Tables</h1>\n \n <a name=\"65\"><p>\n <table cellpadding=\"3\" cellspacing=\"5\" align=\"center\" rules=\"rows\" border=\"3\"\n-       cols=\"4\" title=\"Table 65\">\n+       cols=\"5\" title=\"Table 65\">\n <caption><h2>Table 65 --- Container Requirements</h2></caption>\n-<tr><th colspan=\"4\">\n+<tr><th colspan=\"5\">\n Anything calling itself a container must meet these minimum requirements.\n </th></tr>\n <tr>\n <td><strong>expression</strong></td>\n <td><strong>result type</strong></td>\n+<td><strong>operational semantics</strong></td>\n <td><strong>notes, pre-/post-conditions, assertions</strong></td>\n <td><strong>complexity</strong></td>\n </tr>\n \n <tr>\n <td>X::value_type</td>\n <td>T</td>\n+<td>&nbsp;</td>\n <td>T is Assignable</td>\n <td>compile time</td>\n </tr>\n@@ -62,19 +64,22 @@ <h1>Tables</h1>\n <td>X::reference</td>\n <td>lvalue of T</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>compile time</td>\n </tr>\n \n <tr>\n <td>X::const_reference</td>\n <td>const lvalue of T</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>compile time</td>\n </tr>\n \n <tr>\n <td>X::iterator</td>\n <td>iterator type pointing to T</td>\n+<td>&nbsp;</td>\n <td>Any iterator category except output iterator.\n     Convertible to X::const_iterator.</td>\n <td>compile time</td>\n@@ -83,55 +88,63 @@ <h1>Tables</h1>\n <tr>\n <td>X::const_iterator</td>\n <td>iterator type pointing to const T</td>\n+<td>&nbsp;</td>\n <td>Any iterator category except output iterator.</td>\n <td>compile time</td>\n </tr>\n \n <tr>\n <td>X::difference_type</td>\n <td>signed integral type</td>\n+<td>&nbsp;</td>\n <td>identical to the difference type of X::iterator and X::const_iterator</td>\n <td>compile time</td>\n </tr>\n \n <tr>\n <td>X::size_type</td>\n <td>unsigned integral type</td>\n+<td>&nbsp;</td>\n <td>size_type can represent any non-negative value of difference_type</td>\n <td>compile time</td>\n </tr>\n \n <tr>\n <td>X u;</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>post: u.size() == 0</td>\n <td>constant</td>\n </tr>\n \n <tr>\n <td>X();</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>X().size == 0</td>\n <td>constant</td>\n </tr>\n \n <tr>\n <td>X(a);</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>a == X(a)</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>X u(a);<br />X u = a;</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>post: u == a.  Equivalent to: X u; u = a;</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>(&amp;a)-&gt;~X();</td>\n <td>void</td>\n+<td>&nbsp;</td>\n <td>dtor is applied to every element of a; all the memory is deallocated</td>\n <td>linear</td>\n </tr>\n@@ -140,19 +153,22 @@ <h1>Tables</h1>\n <td>a.begin()</td>\n <td>iterator; const_iterator for constant a</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>constant</td>\n </tr>\n \n <tr>\n <td>a.end()</td>\n <td>iterator; const_iterator for constant a</td>\n <td>&nbsp;</td>\n+<td>&nbsp;</td>\n <td>constant</td>\n </tr>\n \n <tr>\n <td>a == b</td>\n <td>convertible to bool</td>\n+<td>&nbsp;</td>\n <td>== is an equivalence relation.  a.size()==b.size() &amp;&amp;\n     equal(a.begin(),a.end(),b.begin())</td>\n <td>linear</td>\n@@ -161,20 +177,23 @@ <h1>Tables</h1>\n <tr>\n <td>a != b</td>\n <td>convertible to bool</td>\n+<td>&nbsp;</td>\n <td>equivalent to !(a==b)</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>a.swap(b)</td>\n <td>void</td>\n+<td>&nbsp;</td>\n <td>swap(a,b)</td>\n <td>may or may not have constant complexity</td>\n </tr>\n \n <tr>\n <td>r = a</td>\n <td>X&amp;</td>\n+<td>&nbsp;</td>\n <td>r == a</td>\n <td>linear</td>\n </tr>\n@@ -184,55 +203,55 @@ <h1>Tables</h1>\n <tr>\n <td>a.size()</td>\n <td>size_type</td>\n-<!--<td>a.end() - a.begin()</td>-->\n+<td>a.end() - a.begin()</td>\n <td>&nbsp;</td>\n <td>may or may not have constant complexity</td>\n </tr>\n \n <tr>\n <td>a.max_size()</td>\n <td>size_type</td>\n-<!--<td>size() of the largest possible container</td>-->\n+<td>size() of the largest possible container</td>\n <td>&nbsp;</td>\n <td>may or may not have constant complexity</td>\n </tr>\n \n <tr>\n <td>a.empty()</td>\n <td>convertible to bool</td>\n-<!--<td>a.size() == 0</td>-->\n+<td>a.size() == 0</td>\n <td>&nbsp;</td>\n <td>constant</td>\n </tr>\n \n <tr>\n <td>a &lt; b</td>\n <td>convertible to bool</td>\n-<!--<td>lexographical_compare(a.begin,a.end(),b.begin(),b.end())</td>-->\n+<td>lexographical_compare( a.begin, a.end(), b.begin(), b.end())</td>\n <td>pre: &lt; is defined for T and is a total ordering relation</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>a &gt; b</td>\n <td>convertible to bool</td>\n-<!--<td>b &lt; a</td>-->\n+<td>b &lt; a</td>\n <td>&nbsp;</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>a &lt;= b</td>\n <td>convertible to bool</td>\n-<!--<td>!(a &gt; b)</td>-->\n+<td>!(a &gt; b)</td>\n <td>&nbsp;</td>\n <td>linear</td>\n </tr>\n \n <tr>\n <td>a &gt;= b</td>\n <td>convertible to bool</td>\n-<!--<td>!(a &lt; b)</td>-->\n+<td>!(a &lt; b)</td>\n <td>&nbsp;</td>\n <td>linear</td>\n </tr>"}, {"sha": "dff2f3f9d110f42f6b53979cf741b3376c3854e4", "filename": "libstdc++-v3/docs/doxygen/user.cfg.in", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fdoxygen%2Fuser.cfg.in?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -669,13 +669,13 @@ ENABLE_PREPROCESSING   = YES\n # compilation will be performed. Macro expansion can be done in a controlled \n # way by setting EXPAND_ONLY_PREDEF to YES.\n \n-MACRO_EXPANSION        = NO\n+MACRO_EXPANSION        = YES\n \n # If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES \n # then the macro expansion is limited to the macros specified with the \n # PREDEFINED and EXPAND_AS_PREDEFINED tags.\n \n-EXPAND_ONLY_PREDEF     = NO\n+EXPAND_ONLY_PREDEF     = YES\n \n # If the SEARCH_INCLUDES tag is set to YES (the default) the includes files \n # in the INCLUDE_PATH (see below) will be search if a #include is found.\n@@ -701,10 +701,19 @@ INCLUDE_FILE_PATTERNS  =\n # or name=definition (no spaces). If the definition and the = are \n # omitted =1 is assumed.\n \n-PREDEFINED             = _GLIBCPP_DEPRECATED\n+### The deprecated functions are clearly marked as such in the code, but\n+### the DEPRECATED macro must be defined for that code to be seen by doxygen.\n+### The class_requires macros are kludges because SKIP_FUNCTION_MACROS is\n+### completely broken, and the presence of the macros confuses the parser.\n+\n+PREDEFINED             = _GLIBCPP_DEPRECATED              \\\n+                         __glibcpp_class_requires=\"//\"    \\\n+                         __glibcpp_class_requires2=\"//\"   \\\n+                         __glibcpp_class_requires3=\"//\"   \\\n+                         __glibcpp_class_requires4=\"//\"\n \n # If the MACRO_EXPANSION and EXPAND_PREDEF_ONLY tags are set to YES then \n-# this tag can be used to specify a list of macro names that should be expanded. \n+# this tag can be used to specify a list of macro names that should be expanded.\n # The macro definition that is found in the sources will be used. \n # Use the PREDEFINED tag if you want to use a different macro definition.\n "}, {"sha": "83037047f6f85de14e3435651083e4825c8a355b", "filename": "libstdc++-v3/include/bits/ios_base.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fios_base.h?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -217,6 +217,7 @@ namespace std\n     static const seekdir end = \t\tseekdir(SEEK_END);\n \n #ifdef _GLIBCPP_DEPRECATED\n+    // Annex D.6\n     typedef int io_state;\n     typedef int open_mode;\n     typedef int seek_dir;"}, {"sha": "bcfb2304e9b1a0cafa46dec75d73242d98b67c86", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 303, "deletions": 112, "changes": 415, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -1,6 +1,6 @@\n // Queue implementation -*- C++ -*-\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -63,182 +63,373 @@\n \n #include <bits/concept_check.h>\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n {\n \n // Forward declarations of operators < and ==, needed for friend declaration.\n \n-template <class _Tp, \n-          class _Sequence = deque<_Tp> >\n+template <typename _Tp, typename _Sequence = deque<_Tp> >\n class queue;\n \n-template <class _Tp, class _Seq>\n+template <typename _Tp, typename _Seq>\n inline bool operator==(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);\n \n-template <class _Tp, class _Seq>\n+template <typename _Tp, typename _Seq>\n inline bool operator<(const queue<_Tp, _Seq>&, const queue<_Tp, _Seq>&);\n \n \n-template <class _Tp, class _Sequence>\n-class queue\n+/**\n+ *  @brief  A standard container giving FIFO behavior.\n+ *\n+ *  @ingroup Containers\n+ *  @ingroup Sequences\n+ *\n+ *  Meets many of the requirements of a <a href=\"tables.html#65\">container</a>,\n+ *  but does not define anything to do with iterators.  Very few of the\n+ *  other standard container interfaces are defined.\n+ *\n+ *  This is not a true container, but an @e adaptor.  It holds another\n+ *  container, and provides a wrapper interface to that container.  The\n+ *  wrapper is what enforces strict first-in-first-out %queue behavior.\n+ *\n+ *  The second template parameter defines the type of the underlying\n+ *  sequence/container.  It defaults to std::deque, but it can be any type\n+ *  that supports @c front, @c back, @c push_back, and @c pop_front,\n+ *  such as std::list or an appropriate user-defined type.\n+ *\n+ *  Members not found in \"normal\" containers are @c container_type,\n+ *  which is a typedef for the second Sequence parameter, and @c push and\n+ *  @c pop, which are standard %queue/FIFO operations.\n+*/\n+template <typename _Tp, typename _Sequence>\n+  class queue\n {\n   // concept requirements\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n   __glibcpp_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n   __glibcpp_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n \n-  template <class _Tp1, class _Seq1>\n+  template <typename _Tp1, typename _Seq1>\n   friend bool operator== (const queue<_Tp1, _Seq1>&,\n                           const queue<_Tp1, _Seq1>&);\n-  template <class _Tp1, class _Seq1>\n+  template <typename _Tp1, typename _Seq1>\n   friend bool operator< (const queue<_Tp1, _Seq1>&,\n                          const queue<_Tp1, _Seq1>&);\n+\n public:\n-  typedef typename _Sequence::value_type      value_type;\n-  typedef typename _Sequence::size_type       size_type;\n-  typedef          _Sequence                  container_type;\n+  typedef typename _Sequence::value_type                value_type;\n+  typedef typename _Sequence::reference                 reference;\n+  typedef typename _Sequence::const_reference           const_reference;\n+  typedef typename _Sequence::size_type                 size_type;\n+  typedef          _Sequence                            container_type;\n \n-  typedef typename _Sequence::reference       reference;\n-  typedef typename _Sequence::const_reference const_reference;\n protected:\n+  /**\n+   *  'c' is the underlying container.  Maintainers wondering why this isn't\n+   *  uglified as per style guidelines should note that this name is\n+   *  specified in the standard, [23.2.3.1].  (Why?  Presumably for the same\n+   *  reason that it's protected instead of private:  to allow derivation.\n+   *  But none of the other containers allow for derivation.  Odd.)\n+  */\n   _Sequence c;\n+\n public:\n-  explicit queue(const _Sequence& __c = _Sequence()) : c(__c) {}\n-\n-  bool empty() const { return c.empty(); }\n-  size_type size() const { return c.size(); }\n-  reference front() { return c.front(); }\n-  const_reference front() const { return c.front(); }\n-  reference back() { return c.back(); }\n-  const_reference back() const { return c.back(); }\n-  void push(const value_type& __x) { c.push_back(__x); }\n-  void pop() { c.pop_front(); }\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  queue(const _Sequence& __c = _Sequence())\n+  : c(__c) {}\n+\n+  /**\n+   *  Returns true if the %queue is empty.\n+  */\n+  bool\n+  empty() const { return c.empty(); }\n+\n+  /**  Returns the number of elements in the %queue.  */\n+  size_type\n+  size() const { return c.size(); }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the first element of the\n+   *  %queue.\n+  */\n+  reference\n+  front() { return c.front(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the %queue.\n+  */\n+  const_reference\n+  front() const { return c.front(); }\n+\n+  /**\n+   *  Returns a read/write reference to the data at the last element of the\n+   *  %queue.\n+  */\n+  reference\n+  back() { return c.back(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the last\n+   *  element of the %queue.\n+  */\n+  const_reference\n+  back() const { return c.back(); }\n+\n+  /**\n+   *  @brief  Add data to the end of the %queue.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical %queue operation.  The function creates an element at\n+   *  the end of the %queue and assigns the given data to it.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+  */\n+  void\n+  push(const value_type& __x) { c.push_back(__x); }\n+\n+  /**\n+   *  @brief  Removes first element.\n+   *\n+   *  This is a typical %queue operation.  It shrinks the %queue by one.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+   *\n+   *  Note that no data is returned, and if the first element's data is\n+   *  needed, it should be retrieved before pop() is called.\n+  */\n+  void\n+  pop() { c.pop_front(); }\n };\n \n-template <class _Tp, class _Sequence>\n-bool \n-operator==(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return __x.c == __y.c;\n-}\n-\n-template <class _Tp, class _Sequence>\n-bool\n-operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return __x.c < __y.c;\n-}\n-\n-template <class _Tp, class _Sequence>\n-bool\n-operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return !(__x == __y);\n-}\n-\n-template <class _Tp, class _Sequence>\n-bool \n-operator>(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return __y < __x;\n-}\n-\n-template <class _Tp, class _Sequence>\n-bool \n-operator<=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return !(__y < __x);\n-}\n-\n-template <class _Tp, class _Sequence>\n-bool \n-operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n-{\n-  return !(__x < __y);\n-}\n \n-template <class _Tp, \n-          class _Sequence = vector<_Tp>,\n-          class _Compare  = less<typename _Sequence::value_type> >\n-class priority_queue\n+/**\n+ *  @brief  Queue equality comparison.\n+ *  @param  x  A %queue.\n+ *  @param  y  A %queue of the same type as @a x.\n+ *  @return  True iff the size and elements of the queues are equal.\n+ *\n+ *  This is an equivalence relation.  Complexity and semantics depend on the\n+ *  underlying sequence type, but the expected rules are:  this relation is\n+ *  linear in the size of the sequences, and queues are considered equivalent\n+ *  if their sequences compare equal.\n+*/\n+template <typename _Tp, typename _Sequence>\n+  inline bool \n+  operator==(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return __x.c == __y.c; }\n+\n+/**\n+ *  @brief  Queue ordering relation.\n+ *  @param  x  A %queue.\n+ *  @param  y  A %queue of the same type as @a x.\n+ *  @return  True iff @a x is lexographically less than @a y.\n+ *\n+ *  This is an total ordering relation.  Complexity and semantics depend on the\n+ *  underlying sequence type, but the expected rules are:  this relation is\n+ *  linear in the size of the sequences, the elements must be comparable\n+ *  with @c <, and std::lexographical_compare() is usually used to make the\n+ *  determination.\n+*/\n+template <typename _Tp, typename _Sequence>\n+  inline bool\n+  operator<(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return __x.c < __y.c; }\n+\n+/// Based on operator==\n+template <typename _Tp, typename _Sequence>\n+  inline bool\n+  operator!=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return !(__x == __y); }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Sequence>\n+  inline bool \n+  operator>(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return __y < __x; }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Sequence>\n+  inline bool \n+  operator<=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return !(__y < __x); }\n+\n+/// Based on operator<\n+template <typename _Tp, typename _Sequence>\n+  inline bool \n+  operator>=(const queue<_Tp, _Sequence>& __x, const queue<_Tp, _Sequence>& __y)\n+  { return !(__x < __y); }\n+\n+\n+/**\n+ *  @brief  A standard container automatically sorting its contents.\n+ *\n+ *  @ingroup Containers\n+ *  @ingroup Sequences\n+ *\n+ *  This is not a true container, but an @e adaptor.  It holds another\n+ *  container, and provides a wrapper interface to that container.  The\n+ *  wrapper is what enforces sorting and first-in-first-out %queue behavior.\n+ *  Very few of the standard container/sequence interface requirements are\n+ *  met (e.g., iterators).\n+ *\n+ *  The second template parameter defines the type of the underlying\n+ *  sequence/container.  It defaults to std::vector, but it can be any type\n+ *  that supports @c front(), @c push_back, @c pop_back, and random-access\n+ *  iterators, such as std::deque or an appropriate user-defined type.\n+ *\n+ *  The third template parameter supplies the means of making priority\n+ *  comparisons.  It defaults to @c less<value_type> but can be anything\n+ *  defining a strict weak ordering.\n+ *\n+ *  Members not found in \"normal\" containers are @c container_type,\n+ *  which is a typedef for the second Sequence parameter, and @c push and\n+ *  @c pop, which are standard %queue/FIFO operations.\n+ *\n+ *  @note  No equality/comparison operators are provided for %priority_queue.\n+ *\n+ *  @note  Sorting of the elements takes place as they are added to, and\n+ *         removed from, the %priority_queue using the %priority_queue's\n+ *         member functions.  If you access the elements by other means, and\n+ *         change their data such that the sorting order would be different,\n+ *         the %priority_queue will not re-sort the elements for you.  (How\n+ *         could it know to do so?)\n+*/\n+template <typename _Tp, typename _Sequence = vector<_Tp>,\n+          typename _Compare  = less<typename _Sequence::value_type> >\n+  class priority_queue\n {\n   // concept requirements\n+  typedef typename _Sequence::value_type _Sequence_value_type;\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n   __glibcpp_class_requires(_Sequence, _SequenceConcept)\n   __glibcpp_class_requires(_Sequence, _RandomAccessContainerConcept)\n-  typedef typename _Sequence::value_type _Sequence_value_type;\n-  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept);\n-  __glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept);\n+  __glibcpp_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+  __glibcpp_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept)\n \n public:\n-  typedef typename _Sequence::value_type      value_type;\n-  typedef typename _Sequence::size_type       size_type;\n-  typedef          _Sequence                  container_type;\n+  typedef typename _Sequence::value_type                value_type;\n+  typedef typename _Sequence::reference                 reference;\n+  typedef typename _Sequence::const_reference           const_reference;\n+  typedef typename _Sequence::size_type                 size_type;\n+  typedef          _Sequence                            container_type;\n \n-  typedef typename _Sequence::reference       reference;\n-  typedef typename _Sequence::const_reference const_reference;\n protected:\n-  _Sequence c;\n-  _Compare comp;\n-public:\n-  explicit priority_queue(const _Compare& __x = _Compare(),\n-\t\t\t  const _Sequence& __s = _Sequence()) \n-    : c(__s), comp(__x) \n-    { make_heap(c.begin(), c.end(), comp); }\n-\n-  template <class _InputIterator>\n-  priority_queue(_InputIterator __first, _InputIterator __last,\n-                 const _Compare& __x = _Compare(),\n-\t\t const _Sequence& __s = _Sequence())\n-  : c(__s), comp(__x)\n-  { \n-    c.insert(c.end(), __first, __last);\n-    make_heap(c.begin(), c.end(), comp);\n-  }\n-\n-  bool empty() const { return c.empty(); }\n-  size_type size() const { return c.size(); }\n-  const_reference top() const { return c.front(); }\n+  //  See queue::c for notes on these names.\n+  _Sequence  c;\n+  _Compare   comp;\n \n+public:\n+  /**\n+   *  @brief  Default constructor creates no elements.\n+  */\n+  explicit\n+  priority_queue(const _Compare& __x = _Compare(),\n+                 const _Sequence& __s = _Sequence()) \n+  : c(__s), comp(__x) \n+  { make_heap(c.begin(), c.end(), comp); }\n+\n+  /**\n+   *  @brief  Builds a %queue from a range.\n+   *  @param  first  An input iterator.\n+   *  @param  last  An input iterator.\n+   *  @param  x  A comparison functor describing a strict weak ordering.\n+   *  @param  s  An initial sequence with which to start.\n+   * \n+   *  Begins by copying @a s, inserting a copy of the elements from\n+   *  @a [first,last) into the copy of @a s, then ordering the copy\n+   *  according to @a x.\n+   *\n+   *  For more information on function objects, see the documentation on\n+   *  @link s20_3_1_base functor base classes@endlink.\n+  */\n+  template <typename _InputIterator>\n+    priority_queue(_InputIterator __first, _InputIterator __last,\n+                   const _Compare& __x = _Compare(),\n+                   const _Sequence& __s = _Sequence())\n+    : c(__s), comp(__x)\n+    { \n+      c.insert(c.end(), __first, __last);\n+      make_heap(c.begin(), c.end(), comp);\n+    }\n+\n+  /**\n+   *  Returns true if the %queue is empty.\n+  */\n+  bool\n+  empty() const { return c.empty(); }\n+\n+  /**  Returns the number of elements in the %queue.  */\n+  size_type\n+  size() const { return c.size(); }\n+\n+  /**\n+   *  Returns a read-only (constant) reference to the data at the first\n+   *  element of the %queue.\n+  */\n+  const_reference\n+  top() const { return c.front(); }\n+\n+  /**\n+   *  @brief  Add data to the %queue.\n+   *  @param  x  Data to be added.\n+   *\n+   *  This is a typical %queue operation.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+  */\n   void \n   push(const value_type& __x) \n   {\n     try \n       {\n-\tc.push_back(__x); \n-\tpush_heap(c.begin(), c.end(), comp);\n+        c.push_back(__x); \n+        push_heap(c.begin(), c.end(), comp);\n       }\n     catch(...)\n       {\n-\tc.clear();\n-\t__throw_exception_again; \n+        c.clear();\n+        __throw_exception_again; \n       }\n   }\n \n+  /**\n+   *  @brief  Removes first element.\n+   *\n+   *  This is a typical %queue operation.  It shrinks the %queue by one.\n+   *  The time complexity of the operation depends on the underlying\n+   *  sequence.\n+   *\n+   *  Note that no data is returned, and if the first element's data is\n+   *  needed, it should be retrieved before pop() is called.\n+  */\n   void \n   pop() \n   {\n     try \n       {\n-\tpop_heap(c.begin(), c.end(), comp);\n-\tc.pop_back();\n+        pop_heap(c.begin(), c.end(), comp);\n+        c.pop_back();\n       }\n     catch(...)\n       {\n-\tc.clear();\n-\t__throw_exception_again; \n+        c.clear();\n+        __throw_exception_again; \n       }\n   }\n };\n \n-// no equality is provided\n+// No equality/comparison operators are provided for priority_queue.\n \n } // namespace std\n \n #endif /* __GLIBCPP_INTERNAL_QUEUE_H */\n \n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "a319b89e2e9b2f19efaf405f04b53a33b8c830a7", "filename": "libstdc++-v3/include/std/std_streambuf.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4df6abc6b3e3899f2c619d27c4c873a8a8e25341/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_streambuf.h?ref=4df6abc6b3e3899f2c619d27c4c873a8a8e25341", "patch": "@@ -464,6 +464,8 @@ namespace std\n       { return traits_type::eof(); }\n \n #ifdef _GLIBCPP_DEPRECATED\n+    // http://gcc.gnu.org/ml/libstdc++/2002-05/msg00168.html\n+    // Annex D.6\n     public:\n       void \n       stossc() "}]}