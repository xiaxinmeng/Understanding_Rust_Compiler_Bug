{"sha": "72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJlNzMyZjg5ZDA1YzA3NjhjYWY3NTlhOGFhM2VhNmY3YTJiYmEyMg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2012-06-26T13:55:34Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2012-06-26T13:55:34Z"}, "message": "re PR c++/53752 (ice in write_array_type)\n\n2012-06-26  Richard Guenther  <rguenther@suse.de>\n\n\tPR c++/53752\n\t* mangle.c (write_array_type): Truncate the number-of-elements\n\tresult.\n\n\t* g++.dg/torture/pr53752.C: New testcase.\n\nFrom-SVN: r188986", "tree": {"sha": "ff0b42b68e82a4f0a8a41e34bf34d8f25f3b4657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff0b42b68e82a4f0a8a41e34bf34d8f25f3b4657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3c04921bfd0e4d1d122d42e57d4d95a44eeef857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c04921bfd0e4d1d122d42e57d4d95a44eeef857", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c04921bfd0e4d1d122d42e57d4d95a44eeef857"}], "stats": {"total": 170, "additions": 170, "deletions": 0}, "files": [{"sha": "6fb9b421a82eb29087cdbb1e47da286828679be8", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "patch": "@@ -1,3 +1,9 @@\n+2012-06-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR c++/53752\n+\t* mangle.c (write_array_type): Truncate the number-of-elements\n+\tresult.\n+\n 2012-06-25  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/53498"}, {"sha": "5bdf02000d708b8ba1a6cc44fda383931c3286eb", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "patch": "@@ -3121,6 +3121,9 @@ write_array_type (const tree type)\n \t     elements in the array, not the largest allowed index.  */\n \t  double_int dmax\n \t    = double_int_add (tree_to_double_int (max), double_int_one);\n+\t  /* Truncate the result - this will mangle [0, SIZE_INT_MAX]\n+\t     number of elements as zero.  */\n+\t  dmax = double_int_zext (dmax, TYPE_PRECISION (TREE_TYPE (max)));\n \t  gcc_assert (double_int_fits_in_uhwi_p (dmax));\n \t  write_unsigned_number (dmax.low);\n \t}"}, {"sha": "ea8a1834c955004493769ce7264685a71b1c4c9c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "patch": "@@ -1,3 +1,8 @@\n+2012-06-26  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR c++/53752\n+\t* g++.dg/torture/pr53752.C: New testcase.\n+\n 2012-06-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/53748"}, {"sha": "fd6c687667cdec87ba67bc4e19d6963956b8b17e", "filename": "gcc/testsuite/g++.dg/torture/pr53752.C", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53752.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72e732f89d05c0768caf759a8aa3ea6f7a2bba22/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53752.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr53752.C?ref=72e732f89d05c0768caf759a8aa3ea6f7a2bba22", "patch": "@@ -0,0 +1,156 @@\n+// { dg-do compile }\n+// { dg-options \"-g\" }\n+\n+typedef unsigned int uint32_t;\n+typedef unsigned long int uint64_t;\n+namespace mpl_ {\n+    template< typename T, T N > struct integral_c {\n+\tstatic const T value = N;\n+    };\n+}\n+namespace mpl {\n+    using namespace mpl_;\n+};\n+template <class T, T val> struct integral_constant : public mpl::integral_c<T, val> {\n+    typedef integral_constant<bool,false> type;\n+};\n+template< typename T > struct is_lvalue_reference : public ::integral_constant<bool,false> {\n+};\n+template< typename T > struct is_rvalue_reference : public ::integral_constant<bool,false> {\n+};\n+namespace type_traits {\n+    template <bool b1, bool b2, bool b3 = false, bool b4 = false, bool b5 = false, bool b6 = false, bool b7 = false> struct ice_or;\n+    template <> struct ice_or<false, false, false, false, false, false, false> {\n+\tstatic const bool value = false;\n+    };\n+}\n+template <typename T> struct is_reference_impl {\n+    static const bool value = (::type_traits::ice_or< ::is_lvalue_reference<T>::value, ::is_rvalue_reference<T>::value >::value)                  ;\n+};\n+template< typename T > struct is_reference : public ::integral_constant<bool,::is_reference_impl<T>::value> {\n+};\n+struct na {\n+};\n+namespace mpl {\n+    template<       bool C     , typename T1     , typename T2     > struct if_c {\n+\ttypedef T2 type;\n+    };\n+    template<       typename T1 = na     , typename T2 = na     , typename T3 = na     > struct if_ {\n+\ttypedef if_c<           static_cast<bool>(T1::value)         , T2         , T3         > almost_type_;\n+\ttypedef typename almost_type_::type type;\n+    };\n+}\n+namespace optional_detail {\n+    template<class T> struct types_when_isnt_ref {\n+\ttypedef T & reference_type ;\n+    }\n+    ;\n+    template<class T> struct types_when_is_ref {\n+    }\n+    ;\n+    struct optional_tag {\n+    }\n+    ;\n+    template<class T> class optional_base : public optional_tag {\n+\ttypedef types_when_isnt_ref<T> types_when_not_ref ;\n+\ttypedef types_when_is_ref<T> types_when_ref ;\n+    protected :\n+\ttypedef typename is_reference<T>::type is_reference_predicate ;\n+\ttypedef typename mpl::if_<is_reference_predicate,types_when_ref,types_when_not_ref>::type types ;\n+\ttypedef typename types::reference_type reference_type ;\n+    }\n+    ;\n+}\n+template<class T> class optional : public optional_detail::optional_base<T> {\n+    typedef optional_detail::optional_base<T> base ;\n+public :\n+    typedef typename base::reference_type reference_type ;\n+    reference_type operator *() {\n+    }\n+};\n+namespace noncopyable_ {\n+    class noncopyable   {\n+    };\n+}\n+typedef noncopyable_::noncopyable noncopyable;\n+template<class T> class shared_ptr {\n+public:\n+    T * operator-> () const     {\n+    }\n+};\n+typedef uint64_t block_address;\n+class transaction_manager : noncopyable {\n+public:\n+    typedef shared_ptr<transaction_manager> ptr;\n+};\n+template <typename ValueType>  class NoOpRefCounter {\n+};\n+struct uint64_traits {\n+};\n+namespace btree_detail {\n+    class shadow_spine : private noncopyable {\n+    public:\n+\tshadow_spine(transaction_manager::ptr tm)     : tm_(tm) {\n+\t}\n+\ttransaction_manager::ptr tm_;\n+    };\n+}\n+template <unsigned Levels, typename ValueTraits>  class btree {\n+public:\n+    typedef shared_ptr<btree<Levels, ValueTraits> > ptr;\n+    typedef uint64_t key[Levels];\n+    typedef typename ValueTraits::value_type value_type;\n+    typedef optional<value_type> maybe_value;\n+    btree(typename transaction_manager::ptr tm,         typename ValueTraits::ref_counter rc);\n+    maybe_value lookup(key const &key) const;\n+    void insert(key const &key, typename ValueTraits::value_type const &value);\n+    template <typename ValueTraits2>   bool   insert_location(btree_detail::shadow_spine &spine,     block_address block,     uint64_t key,     int *index);\n+    typename transaction_manager::ptr tm_;\n+    block_address root_;\n+    typename ValueTraits::ref_counter rc_;\n+};\n+template <unsigned Levels, typename ValueTraits> void btree<Levels, ValueTraits>:: insert(key const &key,        typename ValueTraits::value_type const &value) {\n+    using namespace btree_detail;\n+    block_address block = root_;\n+    int index = 0;\n+    shadow_spine spine(tm_);\n+    for (unsigned level = 0;\n+\t level < Levels - 1;\n+\t ++level) {\n+\tbool need_insert = insert_location<uint64_traits>(spine, block, key[level], &index);\n+\tif (need_insert) {\n+\t    btree<Levels - 1, ValueTraits> new_tree(tm_, rc_);\n+\t}\n+    }\n+}\n+struct device_details_disk {\n+}\n+__attribute__ ((packed));\n+struct device_details {\n+};\n+struct device_details_traits {\n+    typedef device_details value_type;\n+    typedef NoOpRefCounter<device_details> ref_counter;\n+};\n+typedef uint32_t thin_dev_t;\n+typedef btree<1, device_details_traits> detail_tree;\n+struct metadata {\n+    typedef shared_ptr<metadata> ptr;\n+    detail_tree::ptr details_;\n+};\n+class thin_pool;\n+class thin {\n+    void set_snapshot_time(uint32_t time);\n+    thin_dev_t dev_;\n+    thin_pool *pool_;\n+};\n+class thin_pool {\n+public:\n+    metadata::ptr md_;\n+};\n+void thin::set_snapshot_time(uint32_t time) {\n+    uint64_t key[1] = {\n+\tdev_ };\n+    optional<device_details> mdetail = pool_->md_->details_->lookup(key);\n+    pool_->md_->details_->insert(key, *mdetail);\n+}"}]}