{"sha": "c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzBlZTVkNTIxZTM4YjNjN2YwZmU0M2JjOWI5M2M5ZWMyZGEzMmY4MQ==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-04-05T03:51:15Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-04-05T03:51:15Z"}, "message": "regrename.c (regno_first_use_in): Wrap prototype in PARAMS.\n\n\t* regrename.c (regno_first_use_in): Wrap prototype in PARAMS.\n\t(regrename_optimize): Rename variables `def_uses' and\n\t`ext_basic_blocks' to avoid conflicts with similarly named\n\ttypedefs in traditional C.\n\nFrom-SVN: r32921", "tree": {"sha": "6155757e74434ce55658ea8c947631717b8cb980", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6155757e74434ce55658ea8c947631717b8cb980"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81/comments", "author": null, "committer": null, "parents": [{"sha": "3ccb603d24071da2691cc1d0cc35901e3ef47ac3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ccb603d24071da2691cc1d0cc35901e3ef47ac3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ccb603d24071da2691cc1d0cc35901e3ef47ac3"}], "stats": {"total": 115, "additions": 60, "deletions": 55}, "files": [{"sha": "38c450f9310c6d08c9f2fa8df1017de56a108f99", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "patch": "@@ -1,5 +1,10 @@\n 2000-04-04  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n+\t* regrename.c (regno_first_use_in): Wrap prototype in PARAMS.\n+\t(regrename_optimize): Rename variables `def_uses' and\n+\t`ext_basic_blocks' to avoid conflicts with similarly named\n+\ttypedefs in traditional C.\n+\n \t* calls.c (initialize_argument_information): Fix typo in previous\n \tchange.\n "}, {"sha": "024429cf30b87ddbd8ecacea514c7107575553ba", "filename": "gcc/regrename.c", "status": "modified", "additions": 55, "deletions": 55, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=c0ee5d521e38b3c7f0fe43bc9b93c9ec2da32f81", "patch": "@@ -91,15 +91,15 @@ static void find_ext_basic_blocks PARAMS ((ext_basic_blocks *));\n static void find_one_ext_basic_block PARAMS ((int, basic_block, sbitmap *,\n \t\t\t\t\t      ext_basic_blocks *));\n static enum reg_class get_reg_class PARAMS ((rtx, rtx, int, enum reg_class));\n-static rtx regno_first_use_in (int, rtx);\n+static rtx regno_first_use_in PARAMS ((int, rtx));\n \n void\n regrename_optimize ()\n {\n   int b, eb, i, inum, r, rc, replace_ok;\n   rtx insn;\n-  def_uses def_uses;\n-  ext_basic_blocks ext_basic_blocks;\n+  def_uses du;\n+  ext_basic_blocks ebb;\n \n \n   /* Registers used in a given class */\n@@ -133,39 +133,39 @@ regrename_optimize ()\n   VARRAY_RTX_INIT (uid_ruid, UID_RUID_HIGH_BOUND + 1, \"uid_ruid\");\n   VARRAY_LONG_INIT (uid_rbid, UID_RUID_HIGH_BOUND + 1, \"uid_rbid\");\n \n-  ext_basic_blocks.basic_block =\n+  ebb.basic_block =\n     sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_zero (ext_basic_blocks.basic_block, n_basic_blocks);\n-  ext_basic_blocks.exit =\n+  sbitmap_vector_zero (ebb.basic_block, n_basic_blocks);\n+  ebb.exit =\n     sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n-  sbitmap_vector_zero (ext_basic_blocks.exit, n_basic_blocks);\n+  sbitmap_vector_zero (ebb.exit, n_basic_blocks);\n \n-  find_ext_basic_blocks (&ext_basic_blocks);\n+  find_ext_basic_blocks (&ebb);\n \n-  def_uses.def_class = def_uses.use_class = 0;\n+  du.def_class = du.use_class = 0;\n \n   /* Build uid_ruid and uid_rbid for this extended basic block */\n   for (b = 0; b < n_basic_blocks; b++)\n-    if (TEST_BIT (ext_basic_blocks.basic_block[b], b))\n+    if (TEST_BIT (ebb.basic_block[b], b))\n       {\n-\tfor (eb = def_uses.high_bound = 0; eb < n_basic_blocks; eb++)\n+\tfor (eb = du.high_bound = 0; eb < n_basic_blocks; eb++)\n \t  {\n-\t    if (TEST_BIT (ext_basic_blocks.basic_block[b], eb))\n+\t    if (TEST_BIT (ebb.basic_block[b], eb))\n \t      {\n \t\tbasic_block bb = BASIC_BLOCK (eb);\n \t\t/* Calculate high bound for uid_ruid and allocate if necessary */\n \t\tfor (insn = bb->head;\n \t\t     insn != NEXT_INSN (bb->end);\n-\t\t     def_uses.high_bound++, insn = NEXT_INSN (insn))\n+\t\t     du.high_bound++, insn = NEXT_INSN (insn))\n \t\t  {\n \t\t    int uid_ruid_high_bound = VARRAY_SIZE (uid_ruid);\n-\t\t    if (def_uses.high_bound + 4 >= uid_ruid_high_bound)\n+\t\t    if (du.high_bound + 4 >= uid_ruid_high_bound)\n \t\t      {\n \t\t\tVARRAY_GROW (uid_ruid, uid_ruid_high_bound * 2);\n \t\t\tVARRAY_GROW (uid_rbid, uid_ruid_high_bound * 2);\n \t\t      }\n-\t\t    VARRAY_RTX (uid_ruid, def_uses.high_bound) = insn;\n-\t\t    VARRAY_LONG (uid_rbid, def_uses.high_bound) = eb;\n+\t\t    VARRAY_RTX (uid_ruid, du.high_bound) = insn;\n+\t\t    VARRAY_LONG (uid_rbid, du.high_bound) = eb;\n \t\t  }\n \t      }\n \t  }\n@@ -177,32 +177,32 @@ regrename_optimize ()\n \tCLEAR_HARD_REG_SET (tmp_bitmap);\n \tCLEAR_HARD_REG_SET (renamed_regs);\n \n-\tdef_uses.defs =\n-\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, def_uses.high_bound + 1);\n-\tsbitmap_vector_zero (def_uses.defs, FIRST_PSEUDO_REGISTER);\n-\tdef_uses.uses =\n-\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, def_uses.high_bound + 1);\n-\tsbitmap_vector_zero (def_uses.uses, FIRST_PSEUDO_REGISTER);\n-\tdef_uses.require_call_save_reg = sbitmap_alloc (def_uses.high_bound + 1);\n-\tsbitmap_zero (def_uses.require_call_save_reg);\n-\tdefs_live_exit = sbitmap_alloc (def_uses.high_bound + 1);\n+\tdu.defs =\n+\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n+\tsbitmap_vector_zero (du.defs, FIRST_PSEUDO_REGISTER);\n+\tdu.uses =\n+\t  sbitmap_vector_alloc (FIRST_PSEUDO_REGISTER, du.high_bound + 1);\n+\tsbitmap_vector_zero (du.uses, FIRST_PSEUDO_REGISTER);\n+\tdu.require_call_save_reg = sbitmap_alloc (du.high_bound + 1);\n+\tsbitmap_zero (du.require_call_save_reg);\n+\tdefs_live_exit = sbitmap_alloc (du.high_bound + 1);\n \tsbitmap_zero (defs_live_exit);\n \n-\tdef_uses.def_class = xrealloc\n-\t  (def_uses.def_class,\n-\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * def_uses.high_bound);\n+\tdu.def_class = xrealloc\n+\t  (du.def_class,\n+\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * du.high_bound);\n \n-\tdef_uses.use_class = xrealloc\n-\t  (def_uses.use_class,\n-\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * def_uses.high_bound);\n+\tdu.use_class = xrealloc\n+\t  (du.use_class,\n+\t   sizeof (enum reg_class) * FIRST_PSEUDO_REGISTER * du.high_bound);\n \n-\tbuild_def_use (b, &ext_basic_blocks, &regs_used, &def_uses,\n+\tbuild_def_use (b, &ebb, &regs_used, &du,\n \t\t       &defs_live_exit);\n \n \tif (rtl_dump_file)\n \t  {\n-\t    dump_ext_bb_info (b, &ext_basic_blocks);\n-\t    dump_def_use_chain (&global_live_at_end, &def_uses, &uid_ruid);\n+\t    dump_ext_bb_info (b, &ebb);\n+\t    dump_def_use_chain (&global_live_at_end, &du, &uid_ruid);\n \t  }\n \n \t/* Available registers are not: used in the block, live at the start,\n@@ -215,15 +215,15 @@ regrename_optimize ()\n \tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_start);\n \tfor (eb = 0; eb < n_basic_blocks; eb++)\n \t  {\n-\t    if (TEST_BIT (ext_basic_blocks.basic_block[b], eb))\n+\t    if (TEST_BIT (ebb.basic_block[b], eb))\n \t      {\n \t\tbasic_block bb = BASIC_BLOCK (eb);\n \t\tREG_SET_TO_HARD_REG_SET (global_live_at_end, bb->global_live_at_end);\n \t\tIOR_HARD_REG_SET (tmp_bitmap, global_live_at_end);\n \t      }\n \t  }\n \n-\tdef_idx = xcalloc (def_uses.high_bound, sizeof (int));\n+\tdef_idx = xcalloc (du.high_bound, sizeof (int));\n \n \t/* Only consider registers in this extended block and in this class\n \t   that are defined more than once.  Replace them if permissible. */\n@@ -240,21 +240,21 @@ regrename_optimize ()\n \t       definitions of this register in this block. and def_idx\n \t       is the ordinal position of this insn in the block. */\n \t    for (i = 0, def_idx[def_cnt] = 0;\n-\t\t i < def_uses.high_bound;\n+\t\t i < du.high_bound;\n \t\t i++)\n \t      {\n-\t\tif (TEST_BIT (def_uses.defs[r], i)\n+\t\tif (TEST_BIT (du.defs[r], i)\n \t\t    && consider_def (VARRAY_RTX (uid_ruid, i), r,\n-\t\t\t\t     &def_uses, i))\n+\t\t\t\t     &du, i))\n \t\t  {\n \t\t    int first_use = 1;\n \t\t    def_idx[def_cnt] = i;\n \n \t\t    /* Only consider definitions that have a use. */\n-\t\t    for (use_idx = i + 1; use_idx < def_uses.high_bound;\n+\t\t    for (use_idx = i + 1; use_idx < du.high_bound;\n \t\t\t use_idx++)\n \t\t      {\n-\t\t\tif (TEST_BIT (def_uses.uses[r], use_idx))\n+\t\t\tif (TEST_BIT (du.uses[r], use_idx))\n \t\t\t  {\n \t\t\t    if (consider_use (VARRAY_RTX (uid_ruid, use_idx), r,\n \t\t\t\t\t      VARRAY_LONG (uid_rbid, i),\n@@ -274,7 +274,7 @@ regrename_optimize ()\n \t\t\t\tbreak;\n \t\t\t      }\n \t\t\t  }\n-\t\t\tif (TEST_BIT (def_uses.defs[r], use_idx))\n+\t\t\tif (TEST_BIT (du.defs[r], use_idx))\n \t\t\t  break;\n \t\t      }\n \t\t    /* Scan until the next def to avoid renaming\n@@ -285,7 +285,7 @@ regrename_optimize ()\n \t\t\t  && GET_CODE (VARRAY_RTX (uid_ruid, call_idx))\n \t\t\t  == CALL_INSN)\n \t\t\t{\n-\t\t\t  SET_BIT (def_uses.require_call_save_reg, i);\n+\t\t\t  SET_BIT (du.require_call_save_reg, i);\n \t\t\t}\n \t\t  }\n \t      }\n@@ -313,8 +313,8 @@ regrename_optimize ()\n \t\t    if (GET_MODE_CLASS (GET_MODE (reg_use)) == MODE_FLOAT)\n \t\t      break;\n #endif\n-\t\t    rc = (int) DU_REG_CLASS (def_uses.def_class,\n-\t\t\t\t      r, def_uses.high_bound, def_idx[def]);\n+\t\t    rc = (int) DU_REG_CLASS (du.def_class,\n+\t\t\t\t      r, du.high_bound, def_idx[def]);\n \t\t    COPY_HARD_REG_SET (avail_regs,\n \t\t\t\t   reg_class_contents[(enum reg_class) rc]);\n \t\t    AND_COMPL_HARD_REG_SET (avail_regs, tmp_bitmap);\n@@ -337,7 +337,7 @@ regrename_optimize ()\n \t\t      {\n \t\t\tavail_reg = reg_alloc_order[ar_idx];\n \t\t\tif (consider_available (reg_use, avail_reg, &avail_regs,\n-\t\t\t\t\t\trc, &def_uses, def_idx[def]))\n+\t\t\t\t\t\trc, &du, def_idx[def]))\n \t\t\t  break;\n \t\t      }\n \n@@ -353,7 +353,7 @@ regrename_optimize ()\n \t\t\t\t     INSN_UID (VARRAY_RTX (uid_ruid,\n \t\t\t\t\t\t\t   def_idx[def])));\n \n-\t\t\t    if (TEST_BIT (def_uses.require_call_save_reg,\n+\t\t\t    if (TEST_BIT (du.require_call_save_reg,\n \t\t\t\t\t  def_idx[def]))\n \t\t\t      fprintf (rtl_dump_file, \" crosses a call\");\n \t\t\t    fprintf (rtl_dump_file, \". No available registers\\n\");\n@@ -368,11 +368,11 @@ regrename_optimize ()\n \t\t       remainder of block until new register is defined\n \t\t       again */\n \t\t    replace_ok = replace_reg_in_block\n-\t\t      (&def_uses, &uid_ruid, def_idx[def], reg_use, avail_reg);\n+\t\t      (&du, &uid_ruid, def_idx[def], reg_use, avail_reg);\n \t\t    /* Replace failed, so restore previous register */\n \t\t    if (!replace_ok)\n \t\t      {\n-\t\t\treplace_reg_in_block (&def_uses, &uid_ruid, def_idx[def],\n+\t\t\treplace_reg_in_block (&du, &uid_ruid, def_idx[def],\n \t\t\t\t\t    gen_rtx_REG (GET_MODE (reg_use),\n \t\t\t\t\t\t\t avail_reg),\n \t\t\t\t\t      REGNO (reg_use));\n@@ -392,14 +392,14 @@ regrename_optimize ()\n \t      try_next_def:\n \t\tcontinue;\n \t      }\n-\t    sbitmap_zero (def_uses.defs[r]);\n+\t    sbitmap_zero (du.defs[r]);\n \t  no_available_regs:\n \t    continue;\n \t  }\n \tfree (def_idx);\n-\tsbitmap_vector_free (def_uses.defs);\n-\tsbitmap_vector_free (def_uses.uses);\n-\tsbitmap_free (def_uses.require_call_save_reg);\n+\tsbitmap_vector_free (du.defs);\n+\tsbitmap_vector_free (du.uses);\n+\tsbitmap_free (du.require_call_save_reg);\n \tsbitmap_free (defs_live_exit);\n \tCLEAR_HARD_REG_SET (regs_used);\n \tCLEAR_HARD_REG_SET (renamed_regs);\n@@ -408,8 +408,8 @@ regrename_optimize ()\n \t  VARRAY_RTX (uid_ruid, inum) = (rtx) 0;\n       }\n \n-  sbitmap_vector_free (ext_basic_blocks.basic_block);\n-  sbitmap_vector_free (ext_basic_blocks.exit);\n+  sbitmap_vector_free (ebb.basic_block);\n+  sbitmap_vector_free (ebb.exit);\n }\n \n /* Build def/use chain DU for extended basic block EBB having root B."}]}