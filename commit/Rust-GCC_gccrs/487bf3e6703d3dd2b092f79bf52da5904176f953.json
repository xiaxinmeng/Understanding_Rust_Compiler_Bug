{"sha": "487bf3e6703d3dd2b092f79bf52da5904176f953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDg3YmYzZTY3MDNkM2RkMmIwOTJmNzliZjUyZGE1OTA0MTc2Zjk1Mw==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2006-01-09T16:56:49Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2006-01-09T16:56:49Z"}, "message": "tree-ssa-dom.c (simplify_cond_and_lookup_avail_expr): Remove code to propagate the RHS of a cast into COND_EXPR_COND.\n\n        * tree-ssa-dom.c (simplify_cond_and_lookup_avail_expr): Remove\n        code to propagate the RHS of a cast into COND_EXPR_COND.  Remove\n        now unused arguments.  Callers updated.\n        (eliminate_redundant_computations): Remove now unused arguments,\n        callers updated.\n        (local_fold): Remove, no longer used.\n        (find_equivalent_equality_comparison): Removed from tree-ssa-dom.c\n        and moved to...\n        * tree-ssa-forwprop.c (find_equivalent_equality_comparison): Here.\n        (simplify_cond): New function.\n        (forward_propagate_into_cond): Call simplify_cond.\n\nFrom-SVN: r109502", "tree": {"sha": "f25d3e3fc6c291e9620d52bbd2922ca9435a0a26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f25d3e3fc6c291e9620d52bbd2922ca9435a0a26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/487bf3e6703d3dd2b092f79bf52da5904176f953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487bf3e6703d3dd2b092f79bf52da5904176f953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/487bf3e6703d3dd2b092f79bf52da5904176f953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/487bf3e6703d3dd2b092f79bf52da5904176f953/comments", "author": null, "committer": null, "parents": [{"sha": "c49c0c3963e9881c190058bf2219f05f1b3cf75b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49c0c3963e9881c190058bf2219f05f1b3cf75b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49c0c3963e9881c190058bf2219f05f1b3cf75b"}], "stats": {"total": 300, "additions": 156, "deletions": 144}, "files": [{"sha": "020d1a457116e4cc6668b6500d73dbc777c67710", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=487bf3e6703d3dd2b092f79bf52da5904176f953", "patch": "@@ -1,3 +1,17 @@\n+2005-01-09  Jeff Law  <law@redhat.com>\n+\n+\t* tree-ssa-dom.c (simplify_cond_and_lookup_avail_expr): Remove\n+\tcode to propagate the RHS of a cast into COND_EXPR_COND.  Remove\n+\tnow unused arguments.  Callers updated.\n+\t(eliminate_redundant_computations): Remove now unused arguments,\n+\tcallers updated.\n+\t(local_fold): Remove, no longer used.\n+\t(find_equivalent_equality_comparison): Removed from tree-ssa-dom.c\n+\tand moved to...\n+\t* tree-ssa-forwprop.c (find_equivalent_equality_comparison): Here.\n+\t(simplify_cond): New function.\n+\t(forward_propagate_into_cond): Call simplify_cond.\n+\n 2006-01-09  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/i386/sse.md (*vec_extractv2di_1_sse2): New."}, {"sha": "3631a218b63b801ee731c1a56b2e6b09ef831d96", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 7, "deletions": 143, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=487bf3e6703d3dd2b092f79bf52da5904176f953", "patch": "@@ -273,13 +273,12 @@ static void htab_statistics (FILE *, htab_t);\n static void record_cond (tree, tree);\n static void record_const_or_copy (tree, tree);\n static void record_equality (tree, tree);\n-static tree simplify_cond_and_lookup_avail_expr (tree, stmt_ann_t, int);\n-static tree find_equivalent_equality_comparison (tree);\n+static tree simplify_cond_and_lookup_avail_expr (tree);\n static void record_range (tree, basic_block);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n static void record_equivalences_from_phis (basic_block);\n static void record_equivalences_from_incoming_edge (basic_block);\n-static bool eliminate_redundant_computations (tree, stmt_ann_t);\n+static bool eliminate_redundant_computations (tree);\n static void record_equivalences_from_stmt (tree, int, stmt_ann_t);\n static void thread_across_edge (struct dom_walk_data *, edge);\n static void dom_opt_finalize_block (struct dom_walk_data *, basic_block);\n@@ -292,21 +291,6 @@ static void restore_nonzero_vars_to_original_value (void);\n static inline bool unsafe_associative_fp_binop (tree);\n \n \n-/* Local version of fold that doesn't introduce cruft.  */\n-\n-static tree\n-local_fold (tree t)\n-{\n-  t = fold (t);\n-\n-  /* Strip away useless type conversions.  Both the NON_LVALUE_EXPR that\n-     may have been added by fold, and \"useless\" type conversions that might\n-     now be apparent due to propagation.  */\n-  STRIP_USELESS_TYPE_CONVERSION (t);\n-\n-  return t;\n-}\n-\n /* Allocate an EDGE_INFO for edge E and attach it to E.\n    Return the new EDGE_INFO structure.  */\n \n@@ -904,9 +888,7 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t    {\n \t      cached_lhs = lookup_avail_expr (dummy_cond, false);\n \t      if (!cached_lhs || ! is_gimple_min_invariant (cached_lhs))\n-\t\tcached_lhs = simplify_cond_and_lookup_avail_expr (dummy_cond,\n-\t\t\t\t\t\t\t\t  NULL,\n-\t\t\t\t\t\t\t\t  false);\n+\t\tcached_lhs = simplify_cond_and_lookup_avail_expr (dummy_cond);\n \t    }\n \t}\n       /* We can have conditionals which just test the state of a\n@@ -1797,99 +1779,13 @@ simple_iv_increment_p (tree stmt)\n   return false;\n }\n \n-/* COND is a condition of the form:\n-\n-     x == const or x != const\n-\n-   Look back to x's defining statement and see if x is defined as\n-\n-     x = (type) y;\n-\n-   If const is unchanged if we convert it to type, then we can build\n-   the equivalent expression:\n-\n-\n-      y == const or y != const\n-\n-   Which may allow further optimizations.\n-\n-   Return the equivalent comparison or NULL if no such equivalent comparison\n-   was found.  */\n-\n-static tree\n-find_equivalent_equality_comparison (tree cond)\n-{\n-  tree op0 = TREE_OPERAND (cond, 0);\n-  tree op1 = TREE_OPERAND (cond, 1);\n-  tree def_stmt = SSA_NAME_DEF_STMT (op0);\n-\n-  /* OP0 might have been a parameter, so first make sure it\n-     was defined by a MODIFY_EXPR.  */\n-  if (def_stmt && TREE_CODE (def_stmt) == MODIFY_EXPR)\n-    {\n-      tree def_rhs = TREE_OPERAND (def_stmt, 1);\n-\n-\n-      /* If either operand to the comparison is a pointer to\n-\t a function, then we can not apply this optimization\n-\t as some targets require function pointers to be\n-\t canonicalized and in this case this optimization would\n-\t eliminate a necessary canonicalization.  */\n-      if ((POINTER_TYPE_P (TREE_TYPE (op0))\n-\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) == FUNCTION_TYPE)\n-\t  || (POINTER_TYPE_P (TREE_TYPE (op1))\n-\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (op1))) == FUNCTION_TYPE))\n-\treturn NULL;\n-\t      \n-      /* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */\n-      if ((TREE_CODE (def_rhs) == NOP_EXPR\n-\t   || TREE_CODE (def_rhs) == CONVERT_EXPR)\n-\t  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME)\n-\t{\n-\t  tree def_rhs_inner = TREE_OPERAND (def_rhs, 0);\n-\t  tree def_rhs_inner_type = TREE_TYPE (def_rhs_inner);\n-\t  tree new;\n-\n-\t  if (TYPE_PRECISION (def_rhs_inner_type)\n-\t      > TYPE_PRECISION (TREE_TYPE (def_rhs)))\n-\t    return NULL;\n-\n-\t  /* If the inner type of the conversion is a pointer to\n-\t     a function, then we can not apply this optimization\n-\t     as some targets require function pointers to be\n-\t     canonicalized.  This optimization would result in\n-\t     canonicalization of the pointer when it was not originally\n-\t     needed/intended.  */\n-\t  if (POINTER_TYPE_P (def_rhs_inner_type)\n-\t      && TREE_CODE (TREE_TYPE (def_rhs_inner_type)) == FUNCTION_TYPE)\n-\t    return NULL;\n-\n-\t  /* What we want to prove is that if we convert OP1 to\n-\t     the type of the object inside the NOP_EXPR that the\n-\t     result is still equivalent to SRC. \n-\n-\t     If that is true, the build and return new equivalent\n-\t     condition which uses the source of the typecast and the\n-\t     new constant (which has only changed its type).  */\n-\t  new = build1 (TREE_CODE (def_rhs), def_rhs_inner_type, op1);\n-\t  new = local_fold (new);\n-\t  if (is_gimple_val (new) && tree_int_cst_equal (new, op1))\n-\t    return build2 (TREE_CODE (cond), TREE_TYPE (cond),\n-\t\t\t   def_rhs_inner, new);\n-\t}\n-    }\n-  return NULL;\n-}\n-\n /* STMT is a COND_EXPR for which we could not trivially determine its\n    result.  This routine attempts to find equivalent forms of the\n    condition which we may be able to optimize better.  It also \n    uses simple value range propagation to optimize conditionals.  */\n \n static tree\n-simplify_cond_and_lookup_avail_expr (tree stmt,\n-\t\t\t\t     stmt_ann_t ann,\n-\t\t\t\t     int insert)\n+simplify_cond_and_lookup_avail_expr (tree stmt)\n {\n   tree cond = COND_EXPR_COND (stmt);\n \n@@ -1908,37 +1804,6 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t  struct vrp_hash_elt vrp_hash_elt, *vrp_hash_elt_p;\n \t  void **slot;\n \n-\t  /* First see if we have test of an SSA_NAME against a constant\n-\t     where the SSA_NAME is defined by an earlier typecast which\n-\t     is irrelevant when performing tests against the given\n-\t     constant.  */\n-\t  if (TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n-\t    {\n-\t      tree new_cond = find_equivalent_equality_comparison (cond);\n-\n-\t      if (new_cond)\n-\t\t{\n-\t\t  /* Update the statement to use the new equivalent\n-\t\t     condition.  */\n-\t\t  COND_EXPR_COND (stmt) = new_cond;\n-\n-\t\t  /* If this is not a real stmt, ann will be NULL and we\n-\t\t     avoid processing the operands.  */\n-\t\t  if (ann)\n-\t\t    mark_stmt_modified (stmt);\n-\n-\t\t  /* Lookup the condition and return its known value if it\n-\t\t     exists.  */\n-\t\t  new_cond = lookup_avail_expr (stmt, insert);\n-\t\t  if (new_cond)\n-\t\t    return new_cond;\n-\n-\t\t  /* The operands have changed, so update op0 and op1.  */\n-\t\t  op0 = TREE_OPERAND (cond, 0);\n-\t\t  op1 = TREE_OPERAND (cond, 1);\n-\t\t}\n-\t    }\n-\n \t  /* Consult the value range records for this variable (if they exist)\n \t     to see if we can eliminate or simplify this conditional. \n \n@@ -2386,7 +2251,7 @@ propagate_to_outgoing_edges (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n    table.  */\n \n static bool\n-eliminate_redundant_computations (tree stmt, stmt_ann_t ann)\n+eliminate_redundant_computations (tree stmt)\n {\n   tree *expr_p, def = NULL_TREE;\n   bool insert = true;\n@@ -2414,7 +2279,7 @@ eliminate_redundant_computations (tree stmt, stmt_ann_t ann)\n   /* If this is a COND_EXPR and we did not find its expression in\n      the hash table, simplify the condition and try again.  */\n   if (! cached_lhs && TREE_CODE (stmt) == COND_EXPR)\n-    cached_lhs = simplify_cond_and_lookup_avail_expr (stmt, ann, insert);\n+    cached_lhs = simplify_cond_and_lookup_avail_expr (stmt);\n \n   opt_stats.num_exprs_considered++;\n \n@@ -2816,8 +2681,7 @@ optimize_stmt (struct dom_walk_data *walk_data ATTRIBUTE_UNUSED,\n \t\t\t|| TREE_CODE (stmt) == SWITCH_EXPR));\n \n   if (may_optimize_p)\n-    may_have_exposed_new_symbols\n-      |= eliminate_redundant_computations (stmt, ann);\n+    may_have_exposed_new_symbols |= eliminate_redundant_computations (stmt);\n \n   /* Record any additional equivalences created by this statement.  */\n   if (TREE_CODE (stmt) == MODIFY_EXPR)"}, {"sha": "2f857dc1076c5ebc9bd4e113b8c754e8e8c757af", "filename": "gcc/tree-ssa-forwprop.c", "status": "modified", "additions": 135, "deletions": 1, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2Ftree-ssa-forwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/487bf3e6703d3dd2b092f79bf52da5904176f953/gcc%2Ftree-ssa-forwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-forwprop.c?ref=487bf3e6703d3dd2b092f79bf52da5904176f953", "patch": "@@ -36,7 +36,8 @@ Boston, MA 02110-1301, USA.  */\n \n /* This pass propagates the RHS of assignment statements into use\n    sites of the LHS of the assignment.  It's basically a specialized\n-   form of tree combination.\n+   form of tree combination.   It is hoped all of this can disappear\n+   when we have a generalized tree combiner.\n \n    Note carefully that after propagation the resulting statement\n    must still be a proper gimple statement.  Right now we simply\n@@ -142,6 +143,9 @@ Boston, MA 02110-1301, USA.  */\n \n      ptr2 = &x[index];\n \n+  We also propagate casts into SWITCH_EXPR and COND_EXPR conditions to\n+  allow us to remove the cast and {NOT_EXPR,NEG_EXPR} into a subsequent\n+  {NOT_EXPR,NEG_EXPR}.\n \n    This will (of course) be extended as other needs arise.  */\n \n@@ -398,6 +402,129 @@ forward_propagate_into_cond_1 (tree cond, tree *test_var_p)\n   return new_cond;\n }\n \n+/* COND is a condition of the form:\n+\n+     x == const or x != const\n+\n+   Look back to x's defining statement and see if x is defined as\n+\n+     x = (type) y;\n+\n+   If const is unchanged if we convert it to type, then we can build\n+   the equivalent expression:\n+\n+\n+      y == const or y != const\n+\n+   Which may allow further optimizations.\n+\n+   Return the equivalent comparison or NULL if no such equivalent comparison\n+   was found.  */\n+\n+static tree\n+find_equivalent_equality_comparison (tree cond)\n+{\n+  tree op0 = TREE_OPERAND (cond, 0);\n+  tree op1 = TREE_OPERAND (cond, 1);\n+  tree def_stmt = SSA_NAME_DEF_STMT (op0);\n+\n+  while (def_stmt\n+\t && TREE_CODE (def_stmt) == MODIFY_EXPR\n+\t && TREE_CODE (TREE_OPERAND (def_stmt, 1)) == SSA_NAME)\n+    def_stmt = SSA_NAME_DEF_STMT (TREE_OPERAND (def_stmt, 1));\n+\n+  /* OP0 might have been a parameter, so first make sure it\n+     was defined by a MODIFY_EXPR.  */\n+  if (def_stmt && TREE_CODE (def_stmt) == MODIFY_EXPR)\n+    {\n+      tree def_rhs = TREE_OPERAND (def_stmt, 1);\n+\n+      /* If either operand to the comparison is a pointer to\n+\t a function, then we can not apply this optimization\n+\t as some targets require function pointers to be\n+\t canonicalized and in this case this optimization would\n+\t eliminate a necessary canonicalization.  */\n+      if ((POINTER_TYPE_P (TREE_TYPE (op0))\n+\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (op0))) == FUNCTION_TYPE)\n+\t  || (POINTER_TYPE_P (TREE_TYPE (op1))\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (op1))) == FUNCTION_TYPE))\n+\treturn NULL;\n+\t      \n+      /* Now make sure the RHS of the MODIFY_EXPR is a typecast.  */\n+      if ((TREE_CODE (def_rhs) == NOP_EXPR\n+\t   || TREE_CODE (def_rhs) == CONVERT_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (def_rhs, 0)) == SSA_NAME)\n+\t{\n+\t  tree def_rhs_inner = TREE_OPERAND (def_rhs, 0);\n+\t  tree def_rhs_inner_type = TREE_TYPE (def_rhs_inner);\n+\t  tree new;\n+\n+\t  if (TYPE_PRECISION (def_rhs_inner_type)\n+\t      > TYPE_PRECISION (TREE_TYPE (def_rhs)))\n+\t    return NULL;\n+\n+\t  /* If the inner type of the conversion is a pointer to\n+\t     a function, then we can not apply this optimization\n+\t     as some targets require function pointers to be\n+\t     canonicalized.  This optimization would result in\n+\t     canonicalization of the pointer when it was not originally\n+\t     needed/intended.  */\n+\t  if (POINTER_TYPE_P (def_rhs_inner_type)\n+\t      && TREE_CODE (TREE_TYPE (def_rhs_inner_type)) == FUNCTION_TYPE)\n+\t    return NULL;\n+\n+\t  /* What we want to prove is that if we convert OP1 to\n+\t     the type of the object inside the NOP_EXPR that the\n+\t     result is still equivalent to SRC. \n+\n+\t     If that is true, the build and return new equivalent\n+\t     condition which uses the source of the typecast and the\n+\t     new constant (which has only changed its type).  */\n+\t  new = fold_build1 (TREE_CODE (def_rhs), def_rhs_inner_type, op1);\n+\t  STRIP_USELESS_TYPE_CONVERSION (new);\n+\t  if (is_gimple_val (new) && tree_int_cst_equal (new, op1))\n+\t    return build2 (TREE_CODE (cond), TREE_TYPE (cond),\n+\t\t\t   def_rhs_inner, new);\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* STMT is a COND_EXPR\n+\n+   This routine attempts to find equivalent forms of the condition\n+   which we may be able to optimize better.  */\n+\n+static void\n+simplify_cond (tree stmt)\n+{\n+  tree cond = COND_EXPR_COND (stmt);\n+\n+  if (COMPARISON_CLASS_P (cond))\n+    {\n+      tree op0 = TREE_OPERAND (cond, 0);\n+      tree op1 = TREE_OPERAND (cond, 1);\n+\n+      if (TREE_CODE (op0) == SSA_NAME && is_gimple_min_invariant (op1))\n+\t{\n+\t  /* First see if we have test of an SSA_NAME against a constant\n+\t     where the SSA_NAME is defined by an earlier typecast which\n+\t     is irrelevant when performing tests against the given\n+\t     constant.  */\n+\t  if (TREE_CODE (cond) == EQ_EXPR || TREE_CODE (cond) == NE_EXPR)\n+\t    {\n+\t      tree new_cond = find_equivalent_equality_comparison (cond);\n+\n+\t      if (new_cond)\n+\t\t{\n+\t\t  COND_EXPR_COND (stmt) = new_cond;\n+\t\t  update_stmt (stmt);\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Forward propagate a single-use variable into COND_EXPR as many\n    times as possible.  */\n \n@@ -436,6 +563,13 @@ forward_propagate_into_cond (tree cond_expr)\n \t  bsi_remove (&bsi, true);\n \t}\n     }\n+\n+  /* There are further simplifications that can be performed\n+     on COND_EXPRs.  Specifically, when comparing an SSA_NAME\n+     against a constant where the SSA_NAME is the result of a\n+     conversion.  Perhaps this should be folded into the rest\n+     of the COND_EXPR simplification code.  */\n+  simplify_cond (cond_expr);\n }\n \n /* We've just substituted an ADDR_EXPR into stmt.  Update all the "}]}