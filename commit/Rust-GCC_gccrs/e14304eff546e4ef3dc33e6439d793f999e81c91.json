{"sha": "e14304eff546e4ef3dc33e6439d793f999e81c91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE0MzA0ZWZmNTQ2ZTRlZjNkYzMzZTY0MzlkNzkzZjk5OWU4MWM5MQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2011-11-09T20:06:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-11-09T20:06:31Z"}, "message": "generic-morestack.c: Include <string.h>.\n\nlibgcc/:\n\t* generic-morestack.c: Include <string.h>.\n\t(uintptr_type): Define.\n\t(struct initial_sp): Add dont_block_signals field.  Reduce size of\n\textra array by 1.\n\t(allocate_segment): Set prev field to NULL.  Don't set\n\t__morestack_current_segment or __morestack_segments.\n\t(__generic_morestack): Update current->prev and *pp after calling\n\tallocate_segment.\n\t(__morestack_block_signals): Don't do anything if\n\tdont_block_signals is set.\n\t(__morestack_unblock_signals): Likewise.\n\t(__generic_findstack): Check for initial_sp == NULL.  Add casts to\n\tuintptr_type.\n\t(__splitstack_block_signals): New function.\n\t(enum __splitstack_content_offsets): Define.\n\t(__splitstack_getcontext, __splitstack_setcontext): New functions.\n\t(__splitstack_makecontext): New function.\n\t(__splitstack_block_signals_context): New function.\n\t(__splitstack_find_context): New function.\n\t* config/i386/morestack.S (__morestack_get_guard): New function.\n\t(__morestack_set_guard, __morestack_make_guard): New functions.\n\t* libgcc-std.ver.in: Add new functions to GCC_4.7.0.\n\ngcc/testsuite/:\n\t* lib/target-supports.exp (check_effective_target_ucontext_h): New\n\tprocedure.\n\t* gcc.dg/split-5.c: New test.\n\nFrom-SVN: r181234", "tree": {"sha": "b16db4d1e1ec9a11ee2ee00a183a6daa8b383c59", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b16db4d1e1ec9a11ee2ee00a183a6daa8b383c59"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e14304eff546e4ef3dc33e6439d793f999e81c91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14304eff546e4ef3dc33e6439d793f999e81c91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e14304eff546e4ef3dc33e6439d793f999e81c91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e14304eff546e4ef3dc33e6439d793f999e81c91/comments", "author": null, "committer": null, "parents": [{"sha": "8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ee9fac21ec877d5e0bbcd3460eb584bbeccf836"}], "stats": {"total": 548, "additions": 527, "deletions": 21}, "files": [{"sha": "ad7fbea6a1a65d1abe5a1cc5929dbf4c5b5995a0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -1,3 +1,9 @@\n+2011-11-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* lib/target-supports.exp (check_effective_target_ucontext_h): New\n+\tprocedure.\n+\t* gcc.dg/split-5.c: New test.\n+\n 2011-11-09  Patrick Marlier  <patrick.marlier@gmail.com>\n \n \t* gcc.dg/tm/memopt-1.c:  Adjust regexp. "}, {"sha": "601640f22e926879fc91771d764870dd005f5b7c", "filename": "gcc/testsuite/gcc.dg/split-5.c", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fsplit-5.c?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -0,0 +1,171 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target split_stack } */\n+/* { dg-require-effective-target pthread_h } */\n+/* { dg-require-effective-target ucontext_h } */\n+/* { dg-options \"-pthread -fsplit-stack\" } */\n+\n+#include <stdlib.h>\n+#include <pthread.h>\n+#include <ucontext.h>\n+\n+extern void __splitstack_getcontext (void *context[10]);\n+\n+extern void __splitstack_setcontext (void *context[10]);\n+\n+extern void *__splitstack_makecontext (size_t, void *context[10], size_t *);\n+\n+extern void __splitstack_block_signals (int *, int *);\n+\n+extern void __splitstack_block_signals_context (void *context[10], int *,\n+\t\t\t\t\t\tint *);\n+\n+extern void *__splitstack_find (void *, void *, size_t *, void **, void **,\n+\t\t\t\tvoid **);\n+\n+extern void *__splitstack_find_context (void *context[10], size_t *, void **,\n+\t\t\t\t\tvoid **, void **);\n+\n+static ucontext_t c1;\n+static void *s1[10];\n+\n+static ucontext_t c2;\n+static void *s2[10];\n+\n+static void swap (ucontext_t *, void *fs[10], ucontext_t *, void *ts[10])\n+  __attribute__ ((no_split_stack));\n+\n+static void\n+swap (ucontext_t *fu, void *fs[10], ucontext_t *tu, void *ts[10])\n+{\n+  __splitstack_getcontext (fs);\n+  __splitstack_setcontext (ts);\n+  swapcontext (fu, tu);\n+  __splitstack_setcontext (fs);\n+}\n+\n+/* Use a noinline function to ensure that the buffer is not removed\n+   from the stack.  */\n+static void use_buffer (char *buf) __attribute__ ((noinline));\n+static void\n+use_buffer (char *buf)\n+{\n+  buf[0] = '\\0';\n+}\n+\n+static void\n+down (int i, const char *msg, ucontext_t *me, void *mes[10],\n+      ucontext_t *other, void *others[10])\n+{\n+  char buf[10000];\n+\n+  if (i > 0)\n+    {\n+      use_buffer (buf);\n+      swap (me, mes, other, others);\n+      down (i - 1, msg, me, mes, other, others);\n+    }\n+  else\n+    {\n+      int c = 0;\n+      void *stack;\n+      size_t stack_size;\n+      void *next_segment = NULL;\n+      void *next_sp = NULL;\n+      void *initial_sp = NULL;\n+\n+      stack = __splitstack_find_context (mes, &stack_size, &next_segment,\n+\t\t\t\t\t&next_sp, &initial_sp);\n+      if (stack != NULL)\n+\t{\n+\t  ++c;\n+\t  while (__splitstack_find (next_segment, next_sp, &stack_size,\n+\t\t\t\t    &next_segment, &next_sp, &initial_sp)\n+\t\t != NULL)\n+\t    ++c;\n+\t}\n+    }\n+}\n+\n+static void\n+go1 (void)\n+{\n+  down (1000, \"go1\", &c1, s1, &c2, s2);\n+  pthread_exit (NULL);\n+}\n+\n+static void\n+go2 (void)\n+{\n+  down (1000, \"go2\", &c2, s2, &c1, s1);\n+  pthread_exit (NULL);\n+}\n+\n+struct thread_context\n+{\n+  ucontext_t *u;\n+  void **s;\n+};\n+\n+static void *start_thread (void *) __attribute__ ((no_split_stack));\n+\n+static void *\n+start_thread (void *context)\n+{\n+  struct thread_context *tc = (struct thread_context *) context;\n+  int block;\n+\n+  block = 0;\n+  __splitstack_block_signals (&block, NULL);\n+  __splitstack_setcontext (tc->s);\n+  setcontext (tc->u);\n+  abort ();\n+}\n+\n+int\n+main (int argc __attribute__ ((unused)), char **argv __attribute__ ((unused)))\n+{\n+  pthread_t tid;\n+  int err;\n+  size_t size;\n+  struct thread_context tc;\n+  int block;\n+\n+  if (getcontext (&c1) < 0)\n+    abort ();\n+\n+  c2 = c1;\n+\n+  c1.uc_stack.ss_sp = __splitstack_makecontext (8192, &s1[0], &size);\n+  if (c1.uc_stack.ss_sp == NULL)\n+    abort ();\n+  c1.uc_stack.ss_flags = 0;\n+  c1.uc_stack.ss_size = size;\n+  c1.uc_link = NULL;\n+  block = 0;\n+  __splitstack_block_signals_context (&s1[0], &block, NULL);\n+  makecontext (&c1, go1, 0);\n+\n+  c2.uc_stack.ss_sp = __splitstack_makecontext (8192, &s2[0], &size);\n+  if (c2.uc_stack.ss_sp == NULL)\n+    abort ();\n+  c2.uc_stack.ss_flags = 0;\n+  c2.uc_stack.ss_size = size;\n+  c2.uc_link = NULL;\n+  __splitstack_block_signals_context (&s2[0], &block, NULL);\n+  makecontext (&c2, go2, 0);\n+\n+  block = 0;\n+  __splitstack_block_signals (&block, NULL);\n+\n+  tc.u = &c1;\n+  tc.s = &s1[0];\n+  err = pthread_create (&tid, NULL, start_thread, &tc);\n+  if (err != 0)\n+    abort ();\n+\n+  err = pthread_join (tid, NULL);\n+  if (err != 0)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "9430910203436392f54ac358fdedd62b601a69be", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -4401,3 +4401,11 @@ proc check_effective_target_non_strict_align {} {\n \tvoid foo(void) { z = (c *) y; }\n     } \"-Wcast-align\"]\n }\n+\n+# Return 1 if the target has <ucontext.h>.\n+\n+proc check_effective_target_ucontext_h { } {\n+    return [check_no_compiler_messages ucontext_h assembly {\n+\t#include <ucontext.h>\n+    }]\n+}"}, {"sha": "bfaa1a0b1eae9dde547b605412435c4e6132b25e", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -1,3 +1,28 @@\n+2011-11-09  Ian Lance Taylor  <iant@google.com>\n+\n+\t* generic-morestack.c: Include <string.h>.\n+\t(uintptr_type): Define.\n+\t(struct initial_sp): Add dont_block_signals field.  Reduce size of\n+\textra array by 1.\n+\t(allocate_segment): Set prev field to NULL.  Don't set\n+\t__morestack_current_segment or __morestack_segments.\n+\t(__generic_morestack): Update current->prev and *pp after calling\n+\tallocate_segment.\n+\t(__morestack_block_signals): Don't do anything if\n+\tdont_block_signals is set.\n+\t(__morestack_unblock_signals): Likewise.\n+\t(__generic_findstack): Check for initial_sp == NULL.  Add casts to\n+\tuintptr_type.\n+\t(__splitstack_block_signals): New function.\n+\t(enum __splitstack_content_offsets): Define.\n+\t(__splitstack_getcontext, __splitstack_setcontext): New functions.\n+\t(__splitstack_makecontext): New function.\n+\t(__splitstack_block_signals_context): New function.\n+\t(__splitstack_find_context): New function.\n+\t* config/i386/morestack.S (__morestack_get_guard): New function.\n+\t(__morestack_set_guard, __morestack_make_guard): New functions.\n+\t* libgcc-std.ver.in: Add new functions to GCC_4.7.0.\n+\n 2011-11-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config.host (i[34567]86-*-cygwin*): Move i386/t-mingw-pthread ..."}, {"sha": "0667590bcf0e0abe44a6b018a52a55b8bb2770c8", "filename": "libgcc/config/i386/morestack.S", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Fconfig%2Fi386%2Fmorestack.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Fi386%2Fmorestack.S?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -1,5 +1,5 @@\n # x86/x86_64 support for -fsplit-stack.\n-# Copyright (C) 2009, 2010 Free Software Foundation, Inc.\n+# Copyright (C) 2009, 2010, 2011 Free Software Foundation, Inc.\n # Contributed by Ian Lance Taylor <iant@google.com>.\n \n # This file is part of GCC.\n@@ -620,6 +620,82 @@ __stack_split_initialize:\n \t.size\t__stack_split_initialize, . - __stack_split_initialize\n #endif\n \n+# Routines to get and set the guard, for __splitstack_getcontext,\n+# __splitstack_setcontext, and __splitstack_makecontext.\n+\n+# void *__morestack_get_guard (void) returns the current stack guard.\n+\t.text\n+\t.global\t__morestack_get_guard\n+\t.hidden\t__morestack_get_guard\n+\n+#ifdef __ELF__\n+\t.type\t__morestack_get_guard,@function\n+#endif\n+\n+__morestack_get_guard:\n+\n+#ifndef __x86_64__\n+\tmovl\t%gs:0x30,%eax\n+#else\n+#ifdef __LP64__\n+\tmovq\t%fs:0x70,%rax\n+#else\n+\tmovl\t%fs:0x40,%eax\n+#endif\n+#endif\n+\tret\n+\n+#ifdef __ELF__\n+\t.size\t__morestack_get_guard, . - __morestack_get_guard\n+#endif\n+\n+# void __morestack_set_guard (void *) sets the stack guard.\n+\t.global\t__morestack_set_guard\n+\t.hidden\t__morestack_set_guard\n+\n+#ifdef __ELF__\n+\t.type\t__morestack_set_guard,@function\n+#endif\n+\n+__morestack_set_guard:\n+\n+#ifndef __x86_64__\n+\tmovl\t4(%esp),%eax\n+\tmovl\t%eax,%gs:0x30\n+#else\n+\tX86_64_SAVE_NEW_STACK_BOUNDARY (di)\n+#endif\n+\tret\n+\n+#ifdef __ELF__\n+\t.size\t__morestack_set_guard, . - __morestack_set_guard\n+#endif\n+\n+# void *__morestack_make_guard (void *, size_t) returns the stack\n+# guard value for a stack.\n+\t.global\t__morestack_make_guard\n+\t.hidden\t__morestack_make_guard\n+\n+#ifdef __ELF__\n+\t.type\t__morestack_make_guard,@function\n+#endif\n+\n+__morestack_make_guard:\n+\n+#ifndef __x86_64__\n+\tmovl\t4(%esp),%eax\n+\tsubl\t8(%esp),%eax\n+\taddl\t$BACKOFF,%eax\n+#else\n+\tsubq\t%rsi,%rdi\n+\taddq\t$BACKOFF,%rdi\n+\tmovq\t%rdi,%rax\n+#endif\n+\tret\n+\n+#ifdef __ELF__\n+\t.size\t__morestack_make_guard, . - __morestack_make_guard\n+#endif\n \n # Make __stack_split_initialize a high priority constructor.  FIXME:\n # This is ELF specific."}, {"sha": "00a3b1c3bf064ee8d79414e8b53137ac03bbd269", "filename": "libgcc/generic-morestack.c", "status": "modified", "additions": 233, "deletions": 19, "changes": 252, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Fgeneric-morestack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Fgeneric-morestack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fgeneric-morestack.c?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -41,12 +41,15 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <errno.h>\n #include <signal.h>\n #include <stdlib.h>\n+#include <string.h>\n #include <unistd.h>\n #include <sys/mman.h>\n #include <sys/uio.h>\n \n #include \"generic-morestack.h\"\n \n+typedef unsigned uintptr_type __attribute__ ((mode (pointer)));\n+\n /* This file contains subroutines that are used by code compiled with\n    -fsplit-stack.  */\n \n@@ -88,14 +91,50 @@ extern void *\n __morestack_allocate_stack_space (size_t size)\n   __attribute__ ((visibility (\"hidden\")));\n \n-/* This is a function which -fsplit-stack code can call to get a list\n-   of the stacks.  Since it is not called only by the compiler, it is\n-   not hidden.  */\n+/* These are functions which -fsplit-stack code can call.  These are\n+   not called by the compiler, and are not hidden.  FIXME: These\n+   should be in some header file somewhere, somehow.  */\n \n extern void *\n __splitstack_find (void *, void *, size_t *, void **, void **, void **)\n   __attribute__ ((visibility (\"default\")));\n \n+extern void\n+__splitstack_block_signals (int *, int *)\n+  __attribute__ ((visibility (\"default\")));\n+\n+extern void\n+__splitstack_getcontext (void *context[10])\n+  __attribute__ ((no_split_stack, visibility (\"default\")));\n+\n+extern void\n+__splitstack_setcontext (void *context[10])\n+  __attribute__ ((no_split_stack, visibility (\"default\")));\n+\n+extern void *\n+__splitstack_makecontext (size_t, void *context[10], size_t *)\n+  __attribute__ ((visibility (\"default\")));\n+\n+extern void\n+__splitstack_block_signals_context (void *context[10], int *, int *)\n+  __attribute__ ((visibility (\"default\")));\n+\n+extern void *\n+__splitstack_find_context (void *context[10], size_t *, void **, void **,\n+\t\t\t   void **)\n+  __attribute__ ((visibility (\"default\")));\n+\n+/* These functions must be defined by the processor specific code.  */\n+\n+extern void *__morestack_get_guard (void)\n+  __attribute__ ((no_split_stack, visibility (\"hidden\")));\n+\n+extern void __morestack_set_guard (void *)\n+  __attribute__ ((no_split_stack, visibility (\"hidden\")));\n+\n+extern void *__morestack_make_guard (void *, size_t)\n+  __attribute__ ((no_split_stack, visibility (\"hidden\")));\n+\n /* When we allocate a stack segment we put this header at the\n    start.  */\n \n@@ -138,8 +177,13 @@ struct initial_sp\n   /* A signal mask, put here so that the thread can use it without\n      needing stack space.  */\n   sigset_t mask;\n+  /* Non-zero if we should not block signals.  This is a reversed flag\n+     so that the default zero value is the safe value.  The type is\n+     uintptr_type because it replaced one of the void * pointers in\n+     extra.  */\n+  uintptr_type dont_block_signals;\n   /* Some extra space for later extensibility.  */\n-  void *extra[5];\n+  void *extra[4];\n };\n \n /* A list of memory blocks allocated by dynamic stack allocation.\n@@ -339,18 +383,13 @@ allocate_segment (size_t frame_size)\n \n   pss = (struct stack_segment *) space;\n \n-  pss->prev = __morestack_current_segment;\n+  pss->prev = NULL;\n   pss->next = NULL;\n   pss->size = allocate - overhead;\n   pss->dynamic_allocation = NULL;\n   pss->free_dynamic_allocation = NULL;\n   pss->extra = NULL;\n \n-  if (__morestack_current_segment != NULL)\n-    __morestack_current_segment->next = pss;\n-  else\n-    __morestack_segments = pss;\n-\n   return pss;\n }\n \n@@ -513,7 +552,11 @@ __generic_morestack (size_t *pframe_size, void *old_stack, size_t param_size)\n   current = *pp;\n \n   if (current == NULL)\n-    current = allocate_segment (frame_size + param_size);\n+    {\n+      current = allocate_segment (frame_size + param_size);\n+      current->prev = __morestack_current_segment;\n+      *pp = current;\n+    }\n \n   current->old_stack = old_stack;\n \n@@ -614,7 +657,9 @@ extern int pthread_sigmask (int, const sigset_t *, sigset_t *)\n void\n __morestack_block_signals (void)\n {\n-  if (pthread_sigmask)\n+  if (__morestack_initial_sp.dont_block_signals)\n+    ;\n+  else if (pthread_sigmask)\n     pthread_sigmask (SIG_BLOCK, &__morestack_fullmask,\n \t\t     &__morestack_initial_sp.mask);\n   else\n@@ -627,7 +672,9 @@ __morestack_block_signals (void)\n void\n __morestack_unblock_signals (void)\n {\n-  if (pthread_sigmask)\n+  if (__morestack_initial_sp.dont_block_signals)\n+    ;\n+  else if (pthread_sigmask)\n     pthread_sigmask (SIG_SETMASK, &__morestack_initial_sp.mask, NULL);\n   else\n     sigprocmask (SIG_SETMASK, &__morestack_initial_sp.mask, NULL);\n@@ -727,6 +774,10 @@ __generic_findstack (void *stack)\n     }\n \n   /* We have popped back to the original stack.  */\n+\n+  if (__morestack_initial_sp.sp == NULL)\n+    return 0;\n+\n #ifdef STACK_GROWS_DOWNWARD\n   if ((char *) stack >= (char *) __morestack_initial_sp.sp)\n     used = 0;\n@@ -796,11 +847,14 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n   void *ret;\n   char *nsp;\n \n-  if (segment_arg == (void *) 1)\n+  if (segment_arg == (void *) (uintptr_type) 1)\n     {\n       char *isp = (char *) *initial_sp;\n \n-      *next_segment = (void *) 2;\n+      if (isp == NULL)\n+\treturn NULL;\n+\n+      *next_segment = (void *) (uintptr_type) 2;\n       *next_sp = NULL;\n #ifdef STACK_GROWS_DOWNWARD\n       if ((char *) sp >= isp)\n@@ -814,7 +868,7 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n       return (void *) isp;\n #endif\n     }\n-  else if (segment_arg == (void *) 2)\n+  else if (segment_arg == (void *) (uintptr_type) 2)\n     return NULL;\n   else if (segment_arg != NULL)\n     segment = (struct stack_segment *) segment_arg;\n@@ -826,8 +880,8 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n       while (1)\n \t{\n \t  if (segment == NULL)\n-\t    return __splitstack_find ((void *) 1, sp, len, next_segment,\n-\t\t\t\t      next_sp, initial_sp);\n+\t    return __splitstack_find ((void *) (uintptr_type) 1, sp, len,\n+\t\t\t\t      next_segment, next_sp, initial_sp);\n \t  if ((char *) sp >= (char *) (segment + 1)\n \t      && (char *) sp <= (char *) (segment + 1) + segment->size)\n \t    break;\n@@ -836,7 +890,7 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n     }\n \n   if (segment->prev == NULL)\n-    *next_segment = (void *) 1;\n+    *next_segment = (void *) (uintptr_type) 1;\n   else\n     *next_segment = segment->prev;\n \n@@ -878,4 +932,164 @@ __splitstack_find (void *segment_arg, void *sp, size_t *len,\n   return ret;\n }\n \n+/* Tell the split stack code whether it has to block signals while\n+   manipulating the stack.  This is for programs in which some threads\n+   block all signals.  If a thread already blocks signals, there is no\n+   need for the split stack code to block them as well.  If NEW is not\n+   NULL, then if *NEW is non-zero signals will be blocked while\n+   splitting the stack, otherwise they will not.  If OLD is not NULL,\n+   *OLD will be set to the old value.  */\n+\n+void\n+__splitstack_block_signals (int *new, int *old)\n+{\n+  if (old != NULL)\n+    *old = __morestack_initial_sp.dont_block_signals ? 0 : 1;\n+  if (new != NULL)\n+    __morestack_initial_sp.dont_block_signals = *new ? 0 : 1;\n+}\n+\n+/* The offsets into the arrays used by __splitstack_getcontext and\n+   __splitstack_setcontext.  */\n+\n+enum __splitstack_context_offsets\n+{\n+  MORESTACK_SEGMENTS = 0,\n+  CURRENT_SEGMENT = 1,\n+  CURRENT_STACK = 2,\n+  STACK_GUARD = 3,\n+  INITIAL_SP = 4,\n+  INITIAL_SP_LEN = 5,\n+  BLOCK_SIGNALS = 6,\n+\n+  NUMBER_OFFSETS = 10\n+};\n+\n+/* Get the current split stack context.  This may be used for\n+   coroutine switching, similar to getcontext.  The argument should\n+   have at least 10 void *pointers for extensibility, although we\n+   don't currently use all of them.  This would normally be called\n+   immediately before a call to getcontext or swapcontext or\n+   setjmp.  */\n+\n+void\n+__splitstack_getcontext (void *context[NUMBER_OFFSETS])\n+{\n+  memset (context, 0, NUMBER_OFFSETS * sizeof (void *));\n+  context[MORESTACK_SEGMENTS] = (void *) __morestack_segments;\n+  context[CURRENT_SEGMENT] = (void *) __morestack_current_segment;\n+  context[CURRENT_STACK] = (void *) &context;\n+  context[STACK_GUARD] = __morestack_get_guard ();\n+  context[INITIAL_SP] = (void *) __morestack_initial_sp.sp;\n+  context[INITIAL_SP_LEN] = (void *) (uintptr_type) __morestack_initial_sp.len;\n+  context[BLOCK_SIGNALS] = (void *) __morestack_initial_sp.dont_block_signals;\n+}\n+\n+/* Set the current split stack context.  The argument should be a\n+   context previously passed to __splitstack_getcontext.  This would\n+   normally be called immediately after a call to getcontext or\n+   swapcontext or setjmp if something jumped to it.  */\n+\n+void\n+__splitstack_setcontext (void *context[NUMBER_OFFSETS])\n+{\n+  __morestack_segments = (struct stack_segment *) context[MORESTACK_SEGMENTS];\n+  __morestack_current_segment =\n+    (struct stack_segment *) context[CURRENT_SEGMENT];\n+  __morestack_set_guard (context[STACK_GUARD]);\n+  __morestack_initial_sp.sp = context[INITIAL_SP];\n+  __morestack_initial_sp.len = (size_t) context[INITIAL_SP_LEN];\n+  __morestack_initial_sp.dont_block_signals =\n+    (uintptr_type) context[BLOCK_SIGNALS];\n+}\n+\n+/* Create a new split stack context.  This will allocate a new stack\n+   segment which may be used by a coroutine.  STACK_SIZE is the\n+   minimum size of the new stack.  The caller is responsible for\n+   actually setting the stack pointer.  This would normally be called\n+   before a call to makecontext, and the returned stack pointer and\n+   size would be used to set the uc_stack field.  A function called\n+   via makecontext on a stack created by __splitstack_makecontext may\n+   not return.  Note that the returned pointer points to the lowest\n+   address in the stack space, and thus may not be the value to which\n+   to set the stack pointer.  */\n+\n+void *\n+__splitstack_makecontext (size_t stack_size, void *context[NUMBER_OFFSETS],\n+\t\t\t  size_t *size)\n+{\n+  struct stack_segment *segment;\n+  void *initial_sp;\n+\n+  memset (context, 0, NUMBER_OFFSETS * sizeof (void *));\n+  segment = allocate_segment (stack_size);\n+  context[MORESTACK_SEGMENTS] = segment;\n+  context[CURRENT_SEGMENT] = segment;\n+#ifdef STACK_GROWS_DOWNWARD\n+  initial_sp = (void *) ((char *) (segment + 1) + segment->size);\n+#else\n+  initial_sp = (void *) (segment + 1);\n+#endif\n+  context[STACK_GUARD] = __morestack_make_guard (initial_sp, segment->size);\n+  context[INITIAL_SP] = NULL;\n+  context[INITIAL_SP_LEN] = 0;\n+  *size = segment->size;\n+  return (void *) (segment + 1);\n+}\n+\n+/* Like __splitstack_block_signals, but operating on CONTEXT, rather\n+   than on the current state.  */\n+\n+void\n+__splitstack_block_signals_context (void *context[NUMBER_OFFSETS], int *new,\n+\t\t\t\t    int *old)\n+{\n+  if (old != NULL)\n+    *old = ((uintptr_type) context[BLOCK_SIGNALS]) != 0 ? 0 : 1;\n+  if (new != NULL)\n+    context[BLOCK_SIGNALS] = (void *) (uintptr_type) (*new ? 0 : 1);\n+}\n+\n+/* Find the stack segments associated with a split stack context.\n+   This will return the address of the first stack segment and set\n+   *STACK_SIZE to its size.  It will set next_segment, next_sp, and\n+   initial_sp which may be passed to __splitstack_find to find the\n+   remaining segments.  */\n+\n+void *\n+__splitstack_find_context (void *context[NUMBER_OFFSETS], size_t *stack_size,\n+\t\t\t   void **next_segment, void **next_sp,\n+\t\t\t   void **initial_sp)\n+{\n+  void *sp;\n+  struct stack_segment *segment;\n+\n+  *initial_sp = context[INITIAL_SP];\n+\n+  sp = context[CURRENT_STACK];\n+  if (sp == NULL)\n+    {\n+      /* Most likely this context was created but was never used.  The\n+\t value 2 is a code used by __splitstack_find to mean that we\n+\t have reached the end of the list of stacks.  */\n+      *next_segment = (void *) (uintptr_type) 2;\n+      *next_sp = NULL;\n+      *initial_sp = NULL;\n+      return NULL;\n+    }\n+\n+  segment = context[CURRENT_SEGMENT];\n+  if (segment == NULL)\n+    {\n+      /* Most likely this context was saved by a thread which was not\n+\t created using __splistack_makecontext and which has never\n+\t split the stack.  The value 1 is a code used by\n+\t __splitstack_find to look at the initial stack.  */\n+      segment = (struct stack_segment *) (uintptr_type) 1;\n+    }\n+\n+  return __splitstack_find (segment, sp, stack_size, next_segment, next_sp,\n+\t\t\t    initial_sp);\n+}\n+\n #endif /* !defined (inhibit_libc) */"}, {"sha": "2d66612d1c56e46564aa4c4897c11073647bcd9a", "filename": "libgcc/libgcc-std.ver.in", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Flibgcc-std.ver.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e14304eff546e4ef3dc33e6439d793f999e81c91/libgcc%2Flibgcc-std.ver.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Flibgcc-std.ver.in?ref=e14304eff546e4ef3dc33e6439d793f999e81c91", "patch": "@@ -1,5 +1,5 @@\n # Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,\n-# 2008, 2010 Free Software Foundation, Inc.\n+# 2008, 2010, 2011 Free Software Foundation, Inc.\n #\n # This file is part of GCC.\n #\n@@ -1926,4 +1926,10 @@ GCC_4.7.0 {\n   __PFX__clrsbsi2\n   __PFX__clrsbdi2\n   __PFX__clrsbti2\n+  __splitstack_block_signals\n+  __splitstack_getcontext\n+  __splitstack_setcontext\n+  __splitstack_makecontext\n+  __splitstack_block_signals_context\n+  __splitstack_find_context\n }"}]}