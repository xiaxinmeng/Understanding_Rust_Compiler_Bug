{"sha": "3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzQ1NGViNzMxYjIxM2NkYTY0Y2JkN2FjMThhOWQwMDkzYzMzY2JjNw==", "commit": {"author": {"name": "Denis Chertykov", "email": "denisc@overta.ru", "date": "2000-05-09T17:53:54Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-05-09T17:53:54Z"}, "message": "avr-protos.h (extra_constraint): change a type of second argument from char to int to avoid warnings.\n\n \t* config/avr/avr-protos.h (extra_constraint): change a type of\n\tsecond argument from char to int to avoid warnings.\n\t(asm_output_byte): Likewise.\n\n\t* config/avr/avr.c (MAX_LD_OFFSET) New macro.\n\t(initial_elimination_offset): Handle elimination from\n\tFRAME_POINTER_REGNUM to STACK_POINTER_REGNUM.\n\t(legitimate_address_p): Use MAX_LD_OFFSET.\n\t(legitimize_address): Likewise.\n\t(out_movqi_r_mr): Likewise.\n\t(out_movhi_r_mr): Likewise, use `fatal_insn' instead of `fatal'.\n\t(out_movsi_r_mr): Use MAX_LD_OFFSET.\n\t(out_movsi_mr_r): Likewise.\n\t(out_movqi_mr_r): Likewise.\n\t(out_movhi_mr_r): Likewise.\n\t(notice_update_cc): Correct CC for the ashrqi3 with the shift\n\tcount as CONST_INT != 6.\n\t(ashlqi3_out): Coding style modifications. Run `fatal_insn' if\n\tshift count is a CONSTANT_P, but not a CONST_INT.\n\t(ashlhi3_out): Coding style modifications.\n\t(ashlsi3_out): Likewise.\n\t(ashrhi3_out): Likewise.\n\t(ashrsi3_out): Likewise.\n\t(lshrhi3_out): Likewise.\n\t(lshrsi3_out): Likewise.\n\t(ashrqi3_out): Generate shift for any known constant count without\n\tscratch register. Run `fatal_insn' if shift count is a CONSTANT_P,\n\tbut not a CONST_INT.\n\t(lshrqi3_out): Coding style modifications. Run `fatal_insn' if\n\tshift count is a CONSTANT_P, but not a CONST_INT.\n\t(extra_constraint): change a type of\n\tsecond argument from char to int to avoid warnings.\n\t(asm_output_byte): Likewise.\n\t(asm_file_end): Output size generated commands count as a hex\n\tnumber too.\n\n\t* config/avr/avr.h (RETURN_ADDR_RTX): New macro.\n\n\t* config/avr/avr.md (addhi3): Fragment commented by &&0 is\n\tremoved.\n\t(ashlqi3): Values of \"length\" attribute changed. Shift count\n\tuses constraints 'n' instead of 'i'.\n\t(ashrqi3): Likewise. Values of \"cc\" attribute changed. Generate\n\tshifts without clobber register.\n\t(lshrqi3): Shift count uses constraints 'n' instead of 'i'.\n\t(call_insn): Correct test for which_alternative == 1 (was 0).\n\t(call_value_insn): Likewise.\n\n\t* config/avr/t-avr: Remove definition of FLOAT while generates\n\tfp-bit.c\n\nFrom-SVN: r33802", "tree": {"sha": "39d0cbe8ae83caf442106c714b33af99b4c31047", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d0cbe8ae83caf442106c714b33af99b4c31047"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/comments", "author": null, "committer": null, "parents": [{"sha": "7a544ce153d84b697ec10a5acfd9b2e35a94fd87", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a544ce153d84b697ec10a5acfd9b2e35a94fd87", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a544ce153d84b697ec10a5acfd9b2e35a94fd87"}], "stats": {"total": 463, "additions": 314, "deletions": 149}, "files": [{"sha": "fb1de4dd5a9707ba1a08046821e35983524e4aea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -1,3 +1,56 @@\n+Tue May  9 20:52:43 2000  Denis Chertykov  <denisc@overta.ru>\n+\n+ \t* config/avr/avr-protos.h (extra_constraint): change a type of\n+\tsecond argument from char to int to avoid warnings.\n+\t(asm_output_byte): Likewise.\n+\t\n+\t* config/avr/avr.c (MAX_LD_OFFSET) New macro.\n+\t(initial_elimination_offset): Handle elimination from\n+\tFRAME_POINTER_REGNUM to STACK_POINTER_REGNUM.\n+\t(legitimate_address_p): Use MAX_LD_OFFSET.\n+\t(legitimize_address): Likewise.\n+\t(out_movqi_r_mr): Likewise.\n+\t(out_movhi_r_mr): Likewise, use `fatal_insn' instead of `fatal'.\n+\t(out_movsi_r_mr): Use MAX_LD_OFFSET.\n+\t(out_movsi_mr_r): Likewise.\n+\t(out_movqi_mr_r): Likewise.\n+\t(out_movhi_mr_r): Likewise.\n+\t(notice_update_cc): Correct CC for the ashrqi3 with the shift\n+\tcount as CONST_INT != 6.\n+\t(ashlqi3_out): Coding style modifications. Run `fatal_insn' if\n+\tshift count is a CONSTANT_P, but not a CONST_INT.\n+\t(ashlhi3_out): Coding style modifications.\n+\t(ashlsi3_out): Likewise.\n+\t(ashrhi3_out): Likewise.\n+\t(ashrsi3_out): Likewise.\n+\t(lshrhi3_out): Likewise.\n+\t(lshrsi3_out): Likewise.\n+\t(ashrqi3_out): Generate shift for any known constant count without\n+\tscratch register. Run `fatal_insn' if shift count is a CONSTANT_P,\n+\tbut not a CONST_INT.\n+\t(lshrqi3_out): Coding style modifications. Run `fatal_insn' if\n+\tshift count is a CONSTANT_P, but not a CONST_INT. \n+\t(extra_constraint): change a type of\n+\tsecond argument from char to int to avoid warnings.\n+\t(asm_output_byte): Likewise.\n+\t(asm_file_end): Output size generated commands count as a hex\n+\tnumber too.\n+\n+\t* config/avr/avr.h (RETURN_ADDR_RTX): New macro.\n+\n+\t* config/avr/avr.md (addhi3): Fragment commented by &&0 is\n+\tremoved.\n+\t(ashlqi3): Values of \"length\" attribute changed. Shift count\n+\tuses constraints 'n' instead of 'i'.\n+\t(ashrqi3): Likewise. Values of \"cc\" attribute changed. Generate\n+\tshifts without clobber register.\n+\t(lshrqi3): Shift count uses constraints 'n' instead of 'i'.\n+\t(call_insn): Correct test for which_alternative == 1 (was 0).\n+\t(call_value_insn): Likewise.\n+\t\n+\t* config/avr/t-avr: Remove definition of FLOAT while generates\n+\tfp-bit.c\n+\n 2000-05-09  Bruce Korb  <bkorb@gnu.org>\n \n \t* fixinc/check.tpl:  Template for checking fixes"}, {"sha": "90dc5aac649644b3fc333cff4d6af1e095a411ef", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -110,7 +110,7 @@ extern char * lshrsi3_out     PARAMS ((rtx insn, rtx operands[], int *len));\n extern enum reg_class preferred_reload_class PARAMS ((rtx x,\n \t\t\t\t\t\t     enum reg_class class));\n extern int    avr_address_cost       PARAMS ((rtx x));\n-extern int    extra_constraint       PARAMS ((rtx x, char c));\n+extern int    extra_constraint       PARAMS ((rtx x, int c));\n extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,\n \t\t\t\t\t     enum machine_mode mode));\n extern int    adjust_insn_length     PARAMS ((rtx insn, int len));\n@@ -123,7 +123,7 @@ extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n \t\t\t\t\t     RTX_CODE outer_code));\n extern void   asm_output_char        PARAMS ((FILE *file, rtx value));\n extern void   asm_output_short       PARAMS ((FILE *file, rtx value));\n-extern void   asm_output_byte        PARAMS ((FILE *file, char value));\n+extern void   asm_output_byte        PARAMS ((FILE *file, int value));\n extern enum reg_class secondary_input_reload_class PARAMS ((enum reg_class,\n \t\t\t\t\t\t\t   enum machine_mode,\n \t\t\t\t\t\t\t   rtx));"}, {"sha": "73758cabf12f954fd75ffc96acc6a84c10130d2d", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 245, "deletions": 125, "changes": 370, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -40,6 +40,8 @@\n #include \"recog.h\"\n #include \"tm_p.h\"\n \n+/* Maximal allowed offset for an address in the LD command */\n+#define MAX_LD_OFFSET(MODE) (64 - (signed)GET_MODE_SIZE (MODE))\n \n static int    avr_naked_function_p PARAMS ((tree));\n static int    interrupt_function_p PARAMS ((tree));\n@@ -230,7 +232,7 @@ interrupt_function_p (func)\n   return a != NULL_TREE;\n }\n \n-/* Return nonzero if FUNC is an signal function as specified\n+/* Return nonzero if FUNC is a signal function as specified\n    by the \"signal\" attribute.  */\n \n static int\n@@ -254,24 +256,30 @@ initial_elimination_offset (from,to)\n      int to ATTRIBUTE_UNUSED;\n {\n   int reg;\n-  int interrupt_func_p = interrupt_function_p (current_function_decl);\n-  int signal_func_p = signal_function_p (current_function_decl);\n-  int leaf_func_p = leaf_function_p ();\n-  int offset= frame_pointer_needed ? 2 : 0;\n-\n-  for (reg = 0; reg < 32; ++reg)\n-    {\n-      if ((!leaf_func_p && (call_used_regs[reg]\n-\t\t\t    && (interrupt_func_p || signal_func_p)))\n-\t  || (regs_ever_live[reg]\n-\t      && (!call_used_regs[reg] || interrupt_func_p || signal_func_p)\n-\t      && ! (frame_pointer_needed\n-\t\t    && (reg == REG_Y || reg == (REG_Y+1)))))\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return 0;\n+  else\n+    {\n+      int interrupt_func_p = interrupt_function_p (current_function_decl);\n+      int signal_func_p = signal_function_p (current_function_decl);\n+      int leaf_func_p = leaf_function_p ();\n+      int offset= frame_pointer_needed ? 2 : 0;\n+\n+      for (reg = 0; reg < 32; ++reg)\n \t{\n-\t  ++offset;\n+\t  if ((!leaf_func_p && (call_used_regs[reg]\n+\t\t\t\t&& (interrupt_func_p || signal_func_p)))\n+\t      || (regs_ever_live[reg]\n+\t\t  && (!call_used_regs[reg] || interrupt_func_p || signal_func_p)\n+\t\t  && ! (frame_pointer_needed\n+\t\t\t&& (reg == REG_Y || reg == (REG_Y+1)))))\n+\t    {\n+\t      ++offset;\n+\t    }\n \t}\n+      return get_frame_size () + 2 + 1 + offset;\n     }\n-  return get_frame_size () + 2 + 1 + offset;\n+  return 0;\n }\n \n /* This function checks sequence of live registers */\n@@ -672,7 +680,7 @@ legitimate_address_p (mode, x, strict)\n \t  && REG_P (XEXP (x, 0))\n \t  && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t  && INTVAL (XEXP (x, 1)) >= 0\n-\t  && INTVAL (XEXP (x, 1)) <= (64 - GET_MODE_SIZE (mode))\n+\t  && INTVAL (XEXP (x, 1)) <= MAX_LD_OFFSET (mode)\n \t  && reg_renumber\n \t  )\n \tfprintf (stderr, \"(r%d ---> r%d)\", REGNO (XEXP (x, 0)),\n@@ -689,7 +697,7 @@ legitimate_address_p (mode, x, strict)\n \t   && GET_CODE (XEXP (x, 1)) == CONST_INT\n \t   && INTVAL (XEXP (x, 1)) >= 0)\n     {\n-      int fit = INTVAL (XEXP (x, 1)) <= (64 - GET_MODE_SIZE (mode));\n+      int fit = INTVAL (XEXP (x, 1)) <= MAX_LD_OFFSET (mode);\n       if (fit)\n \t{\n \t  if (! strict\n@@ -741,7 +749,7 @@ legitimize_address (x, oldx, mode)\n \t{\n \t  int offs = INTVAL (XEXP (oldx,1));\n \t  if (frame_pointer_rtx != XEXP (oldx,0))\n-\t    if (offs > 64 - GET_MODE_SIZE (mode))\n+\t    if (offs > MAX_LD_OFFSET (mode))\n \t      {\n \t\tif (TARGET_ALL_DEBUG)\n \t\t  fprintf (stderr, \"force_reg (big offset)\\n\");\n@@ -938,6 +946,8 @@ notice_update_cc (body, insn)\n      rtx body ATTRIBUTE_UNUSED;\n      rtx insn;\n {\n+  rtx set;\n+  \n   switch (get_attr_cc (insn))\n     {\n     case CC_NONE:\n@@ -949,44 +959,58 @@ notice_update_cc (body, insn)\n       break;\n \n     case CC_SET_ZN:\n-      {\n-\trtx set = single_set (insn);\n-\tCC_STATUS_INIT;\n-\tif (set)\n-\t  {\n-\t    cc_status.flags |= CC_NO_OVERFLOW;\n-\t    cc_status.value1 = SET_DEST (set);\n-\t  }\n-      }\n+      set = single_set (insn);\n+      CC_STATUS_INIT;\n+      if (set)\n+\t{\n+\t  cc_status.flags |= CC_NO_OVERFLOW;\n+\t  cc_status.value1 = SET_DEST (set);\n+\t}\n       break;\n \n     case CC_SET_CZN:\n       /* Insn sets the Z,N,C flags of CC to recog_operand[0].\n          The V flag may or may not be known but that's ok because\n          alter_cond will change tests to use EQ/NE.  */\n-      {\n-\trtx set = single_set (insn);\n-\tCC_STATUS_INIT;\n-\tif (set)\n-\t  {\n-\t    cc_status.value1 = SET_DEST (set);\n-\t    cc_status.flags |= CC_OVERFLOW_UNUSABLE;\n-\t  }\n-      }\n+      set = single_set (insn);\n+      CC_STATUS_INIT;\n+      if (set)\n+\t{\n+\t  cc_status.value1 = SET_DEST (set);\n+\t  cc_status.flags |= CC_OVERFLOW_UNUSABLE;\n+\t}\n       break;\n \n     case CC_COMPARE:\n-      {\n-\trtx set = single_set (insn);\n-\tCC_STATUS_INIT;\n-\tif (set)\n-\t  cc_status.value1 = SET_SRC (set);\n-      }\n+      set = single_set (insn);\n+      CC_STATUS_INIT;\n+      if (set)\n+\tcc_status.value1 = SET_SRC (set);\n       break;\n-\n+      \n     case CC_CLOBBER:\n       /* Insn doesn't leave CC in a usable state.  */\n       CC_STATUS_INIT;\n+\n+      /* Correct CC for the ashrqi3 with the shift count as CONST_INT != 6 */\n+      set = single_set (insn);\n+      if (set)\n+\t{\n+\t  rtx src = SET_SRC (set);\n+\t  \n+\t  if (GET_CODE (src) == ASHIFTRT\n+\t      && GET_MODE (src) == QImode)\n+\t    {\n+\t      rtx x = XEXP (src, 1);\n+\n+\t      if (GET_CODE (x) == CONST_INT\n+\t\t  && INTVAL (x) != 6)\n+\t\t{\n+\t\t  cc_status.value1 = SET_DEST (set);\n+\t\t  cc_status.flags |= CC_OVERFLOW_UNUSABLE;\n+\t\t}\n+\t    }\n+\t}\n       break;\n     }\n }\n@@ -1273,7 +1297,7 @@ out_movqi_r_mr (insn, op, l)\n \t      int disp = INTVAL (XEXP (x,1));\n \t      if (REGNO (XEXP (x,0)) != REG_Y)\n \t\tfatal_insn (\"Incorrect insn:\",insn);\n-\t      if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[1])))\n+\t      if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n \t\t{\n \t\t  if (l)\n \t\t    *l = 3;\n@@ -1358,12 +1382,12 @@ out_movhi_r_mr (insn, op, l)\n       int disp = INTVAL(XEXP (XEXP (op[1],0), 1));\n       int reg_base = true_regnum (XEXP (XEXP (op[1],0), 0));\n       \n-      if (disp > 64 - GET_MODE_SIZE (GET_MODE (op[1])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (op[1])))\n \t{\n \t  rtx x = XEXP (op[1],0);\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[1])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n \t    {\n \t      op[4] = GEN_INT (disp - 62);\n \t      return *l=4, (AS2 (adiw, r28, %4) CR_TAB\n@@ -1425,20 +1449,16 @@ out_movhi_r_mr (insn, op, l)\n   else if (GET_CODE (XEXP (op[1],0)) == PRE_DEC) /* (--R) */\n     {\n       if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n-\t{\n-\t  debug_rtx (insn);\n-\t  fatal (\"Internal error. Incorrect insn.\");\n-\t}\n+\tfatal_insn (\"Incorrect insn:\", insn);\n+      \n       return *l=2, (AS2 (ld,%B0,%1) CR_TAB\n \t\t    AS2 (ld,%A0,%1));\n     }\n   else if (GET_CODE (XEXP (op[1],0)) == POST_INC) /* (R++) */\n     {\n       if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n-\t{\n-\t  debug_rtx (insn);\n-\t  fatal (\"Internal error. Incorrect insn.\");\n-\t}\n+\tfatal_insn (\"Incorrect insn:\", insn);\n+      \n       return *l=2, (AS2 (ld,%A0,%1)  CR_TAB\n \t\t    AS2 (ld,%B0,%1));\n     }\n@@ -1514,12 +1534,12 @@ out_movsi_r_mr (insn,op,l)\n     {\n       int disp = INTVAL(XEXP (XEXP (op[1],0), 1));\n       \n-      if (disp > 64 - GET_MODE_SIZE (GET_MODE (op[1])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (op[1])))\n \t{\n \t  rtx x = XEXP (op[1],0);\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[1])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n \t    {\n \t      op[4] = GEN_INT (disp - 60);\n \t      return *l=6,(AS2 (adiw, r28, %4) CR_TAB\n@@ -1652,12 +1672,12 @@ out_movsi_mr_r (insn,op,l)\n   else if (GET_CODE (XEXP (op[0],0)) == PLUS) /* (R + i) */\n     {\n       int disp = INTVAL(XEXP (XEXP (op[0],0), 1));\n-      if (disp > 64 - GET_MODE_SIZE (GET_MODE (op[0])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (op[0])))\n \t{\n \t  rtx x = XEXP (op[0],0);\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[0])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n \t    {\n \t      op[4] = GEN_INT (disp - 60);\n \t      return *l=6,(AS2 (adiw, r28, %4) CR_TAB\n@@ -1781,7 +1801,7 @@ out_movqi_mr_r (insn, op, l)\n \t      int disp = INTVAL (XEXP (x,1));\n \t      if (REGNO (XEXP (x,0)) != REG_Y)\n \t\tfatal_insn (\"Incorrect insn:\",insn);\n-\t      if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[0])))\n+\t      if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n \t\t{\n \t\t  if (l)\n \t\t    *l = 3;\n@@ -1877,12 +1897,12 @@ out_movhi_mr_r (insn,op,l)\n   else if (GET_CODE (XEXP (op[0],0)) == PLUS)\n     {\n       int disp = INTVAL(XEXP (XEXP (op[0],0), 1));\n-      if (disp > 64 - GET_MODE_SIZE (GET_MODE (op[0])))\n+      if (disp > MAX_LD_OFFSET (GET_MODE (op[0])))\n \t{\n \t  rtx x = XEXP (op[0],0);\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n-\t  if (disp <= 63 + 64 - GET_MODE_SIZE (GET_MODE (op[0])))\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n \t    {\n \t      op[4] = GEN_INT (disp - 62);\n \t      return *l=4,(AS2 (adiw, r28, %4) CR_TAB\n@@ -2107,73 +2127,86 @@ ashlqi3_out (insn,operands,len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+\n       if (!len)\n \tlen = &k;\n+\n       switch (INTVAL (operands[2]))\n \t{\n-\tdefault: len = t; break;\n+\tdefault:\n+\t  *len = 1;\n+\t  return AS1 (clr,%0);\n+\t  \n \tcase 1:\n-\t  *len=1;\n+\t  *len = 1;\n \t  return AS1 (lsl,%0);\n+\t  \n \tcase 2:\n-\t  *len=2;\n+\t  *len = 2;\n \t  return (AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0));\n+\n \tcase 3:\n-\t  *len=3;\n+\t  *len = 3;\n \t  return (AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0));\n+\n \tcase 4:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n-\t      *len=2;\n+\t      *len = 2;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS2 (andi,%0,0xf0));\n \t    }\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0));\n+\n \tcase 5:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n-\t      *len=3;\n+\t      *len = 3;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS1 (lsl,%0)  CR_TAB\n \t\t      AS2 (andi,%0,0xe0));\n \t    }\n-\t  *len=5;\n+\t  *len = 5;\n \t  return (AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0));\n+\n \tcase 6:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n-\t      *len=4;\n+\t      *len = 4;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS1 (lsl,%0)  CR_TAB\n \t\t      AS1 (lsl,%0)  CR_TAB\n \t\t      AS2 (andi,%0,0xc0));\n \t    }\n-\t  *len=6;\n+\t  *len = 6;\n \t  return (AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0) CR_TAB\n \t\t  AS1 (lsl,%0));\n+\n \tcase 7:\n-\t  *len=3;\n+\t  *len = 3;\n \t  return (AS1 (ror,%0) CR_TAB\n \t\t  AS1 (clr,%0) CR_TAB\n \t\t  AS1 (ror,%0));\n \t}\n     }\n+  else if (CONSTANT_P (operands[2]))\n+    fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n+\n   if (len)\n     *len = 3;\n   out_shift_with_cnt (AS1 (lsl,%0),\n@@ -2194,21 +2227,26 @@ ashlhi3_out (insn,operands,len)\n     {\n       int k;\n       int *t=len;\n+\n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\t  \n \tcase 1:\n-\t  *len=2;\n+\t  *len = 2;\n \t  return (AS1 (lsl,%A0) CR_TAB\n \t\t  AS1 (rol,%B0));\n+\n \tcase 2:\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsl,%A0) CR_TAB\n \t\t  AS1 (rol,%B0) CR_TAB\n \t\t  AS1 (lsl,%0)  CR_TAB\n \t\t  AS1 (rol,%B0));\n+\n \tcase 8:\n \t  if (true_regnum (operands[0]) + 1 == true_regnum (operands[1]))\n \t    return *len = 1, AS1 (clr,%A0);\n@@ -2238,65 +2276,80 @@ ashlsi3_out (insn,operands,len)\n     {\n       int k;\n       int *t=len;\n+      \n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\t  \n \tcase 1:\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsl,%A0) CR_TAB\n \t\t  AS1 (rol,%B0) CR_TAB\n \t\t  AS1 (rol,%C0) CR_TAB\n \t\t  AS1 (rol,%D0));\n+\n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n-\t    *len=4;\n+\t    *len = 4;\n \t    if (reg0 >= reg1)\n \t      return (AS2 (mov,%D0,%C1)  CR_TAB\n \t\t      AS2 (mov,%C0,%B1)  CR_TAB\n \t\t      AS2 (mov,%B0,%A1)  CR_TAB\n \t\t      AS1 (clr,%A0));\n \t    else if (reg0 + 1 == reg1)\n-\t      return *len = 1, AS1 (clr,%A0);\n+\t      {\n+\t\t*len = 1;\n+\t\treturn AS1 (clr,%A0);\n+\t      }\n \t    else\n \t      return (AS1 (clr,%A0)      CR_TAB\n \t\t      AS2 (mov,%B0,%A1)  CR_TAB\n \t\t      AS2 (mov,%C0,%B1)  CR_TAB\n \t\t      AS2 (mov,%D0,%C1));\n \t  }\n+\n \tcase 16:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n-\t    *len=4;\n+\t    *len = 4;\n \t    if (reg0 + 1 >= reg1)\n \t      return (AS2 (mov,%D0,%B1)  CR_TAB\n \t\t      AS2 (mov,%C0,%A1)  CR_TAB\n \t\t      AS1 (clr,%B0)      CR_TAB\n \t\t      AS1 (clr,%A0));\n \t    if (reg0 + 2 == reg1)\n-\t      return *len = 2, (AS1 (clr,%B0)      CR_TAB\n-\t\t\t\tAS1 (clr,%A0));\n+\t      {\n+\t\t*len = 2;\n+\t\treturn (AS1 (clr,%B0)      CR_TAB\n+\t\t\tAS1 (clr,%A0));\n+\t      }\n \t    else\n \t      return (AS2 (mov,%C0,%A1)  CR_TAB\n \t\t      AS2 (mov,%D0,%B1)  CR_TAB\n \t\t      AS1 (clr,%B0)      CR_TAB\n \t\t      AS1 (clr,%A0));\n \t  }\n+\n \tcase 24:\n-\t  *len=4;\n+\t  *len = 4;\n \t  if (true_regnum (operands[0]) + 3 != true_regnum (operands[1]))\n \t    return (AS2 (mov,%D0,%A1)  CR_TAB\n \t\t    AS1 (clr,%C0)      CR_TAB\n \t\t    AS1 (clr,%B0)      CR_TAB\n \t\t    AS1 (clr,%A0));\n \t  else\n-\t    return *len = 3, (AS1 (clr,%C0)      CR_TAB\n-\t\t\t      AS1 (clr,%B0)      CR_TAB\n-\t\t\t      AS1 (clr,%A0));\n+\t    {\n+\t      *len = 3;\n+\t      return (AS1 (clr,%C0)      CR_TAB\n+\t\t      AS1 (clr,%B0)      CR_TAB\n+\t\t      AS1 (clr,%A0));\n+\t    }\n \t}\n     }\n   if (len)\n@@ -2319,33 +2372,60 @@ ashrqi3_out (insn,operands,len)\n {\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n-      int *t=len;\n       int k;\n+\n       if (!len)\n \tlen = &k;\n+\n       switch (INTVAL (operands[2]))\n \t{\n-\tdefault: len = t; break;\n \tcase 1:\n-\t  *len=1;\n+\t  *len = 1;\n \t  return AS1 (asr,%0);\n+\n \tcase 2:\n-\t  *len=2;\n+\t  *len = 2;\n \t  return (AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0));\n+\n \tcase 3:\n-\t  *len=3;\n+\t  *len = 3;\n \t  return (AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0));\n+\n \tcase 4:\n-\t  *len=4;\n+\t  *len = 4;\n+\t  return (AS1 (asr,%0) CR_TAB\n+\t\t  AS1 (asr,%0) CR_TAB\n+\t\t  AS1 (asr,%0) CR_TAB\n+\t\t  AS1 (asr,%0));\n+\n+\tcase 5:\n+\t  *len = 5;\n \t  return (AS1 (asr,%0) CR_TAB\n+\t\t  AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0) CR_TAB\n \t\t  AS1 (asr,%0));\n+\n+\tcase 6:\n+\t  *len = 4;\n+\t  return (AS2 (bst,%0,6)  CR_TAB\n+\t\t  AS1 (lsl,%0)    CR_TAB\n+\t\t  AS2 (sbc,%0,%0) CR_TAB\n+\t\t  AS2 (bld,%0,0));\n+\n+\tdefault:\n+\tcase 7:\n+\t  *len = 2;\n+\t  return (AS1 (lsl,%0) CR_TAB\n+\t\t  AS2 (sbc,%0,%0));\n \t}\n     }\n+  else if (CONSTANT_P (operands[2]))\n+    fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n+\n   if (len)\n     *len = 3;\n   out_shift_with_cnt (AS1 (asr,%0),\n@@ -2365,22 +2445,27 @@ ashrhi3_out (insn,operands,len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+      int *t = len;\n+      \n       if (!len)\n \tlen = &k;\n+\n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\t  \n \tcase 1:\n \t  *len=2;\n \t  return (AS1 (asr,%B0) CR_TAB\n \t\t  AS1 (ror,%A0));\n+\n \tcase 2:\n \t  *len=4;\n \t  return (AS1 (asr,%B0)  CR_TAB\n \t\t  AS1 (ror,%A0) CR_TAB\n \t\t  AS1 (asr,%B0)  CR_TAB\n \t\t  AS1 (ror,%A0));\n+\n \tcase 8:\n \t  if (true_regnum (operands[0]) != true_regnum (operands[1]) + 1)\n \t    return *len = 4, (AS2 (mov,%A0,%B1) CR_TAB\n@@ -2391,6 +2476,7 @@ ashrhi3_out (insn,operands,len)\n \t    return *len = 3, (AS1 (clr,%B0)     CR_TAB\n \t\t\t      AS2 (sbrc,%A0,7)  CR_TAB\n \t\t\t      AS1 (dec,%B0));\n+\n \tcase 15:\n \t  return *len = 3, (AS1 (lsl,%B0)     CR_TAB\n \t\t\t    AS2 (sbc,%A0,%A0) CR_TAB\n@@ -2418,17 +2504,21 @@ ashrsi3_out (insn,operands,len)\n     {\n       int k;\n       int *t = len;\n+      \n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\n \tcase 1:\n \t  *len=4;\n \t  return (AS1 (asr,%D0)  CR_TAB\n-\t\t  AS1 (ror,%C0) CR_TAB\n-\t\t  AS1 (ror,%B0) CR_TAB\n+\t\t  AS1 (ror,%C0)  CR_TAB\n+\t\t  AS1 (ror,%B0)  CR_TAB\n \t\t  AS1 (ror,%A0));\n+\n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n@@ -2442,9 +2532,12 @@ ashrsi3_out (insn,operands,len)\n \t\t      AS2 (sbrc,%C0,7)  CR_TAB\n \t\t      AS1 (dec,%D0));\n \t    else if (reg0 == reg1 + 1)\n-\t      return *len = 3, (AS1 (clr,%D0)     CR_TAB\n-\t\t\t\tAS2 (sbrc,%C0,7)  CR_TAB\n-\t\t\t\tAS1 (dec,%D0));\n+\t      {\n+\t\t*len = 3;\n+\t\treturn (AS1 (clr,%D0)     CR_TAB\n+\t\t\tAS2 (sbrc,%C0,7)  CR_TAB\n+\t\t\tAS1 (dec,%D0));\n+\t      }\n \t    else\n \t      return (AS1 (clr,%D0)     CR_TAB\n \t\t      AS2 (sbrc,%D1,7)  CR_TAB\n@@ -2453,6 +2546,7 @@ ashrsi3_out (insn,operands,len)\n \t\t      AS2 (mov,%B0,%C1) CR_TAB\n \t\t      AS2 (mov,%A0,%B1));\n \t  }\n+\t  \n \tcase 16:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n@@ -2478,6 +2572,7 @@ ashrsi3_out (insn,operands,len)\n \t\t      AS1 (com,%D0)     CR_TAB\n \t\t      AS2 (mov,%C0,%D0));\n \t  }\n+\n \tcase 24:\n \t  if (true_regnum (operands[0]) != true_regnum (operands[1]) + 3)\n \t    return *len = 6, (AS2 (mov,%A0,%D1) CR_TAB\n@@ -2515,73 +2610,85 @@ lshrqi3_out (insn,operands,len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+\n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n-\tdefault: len = t; break;\n+\tdefault:\n+\t  *len = 1;\n+\t  return AS1 (clr,%0);\n+\n \tcase 1:\n-\t  *len=1;\n+\t  *len = 1;\n \t  return AS1 (lsr,%0);\n+\n \tcase 2:\n-\t  *len=2;\n+\t  *len = 2;\n \t  return (AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0));\n \tcase 3:\n-\t  *len=3;\n+\t  *len = 3;\n \t  return (AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0));\n+\t  \n \tcase 4:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n \t      *len=2;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS2 (andi,%0,0x0f));\n \t    }\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0));\n+\t  \n \tcase 5:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n-\t      *len=3;\n+\t      *len = 3;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS1 (lsr,%0)  CR_TAB\n \t\t      AS2 (andi,%0,0x7));\n \t    }\n-\t  *len=5;\n+\t  *len = 5;\n \t  return (AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0));\n+\t  \n \tcase 6:\n \t  if (TEST_HARD_REG_CLASS (LD_REGS, true_regnum (operands[0])))\n \t    {\n-\t      *len=4;\n+\t      *len = 4;\n \t      return (AS1 (swap,%0) CR_TAB\n \t\t      AS1 (lsr,%0)  CR_TAB\n \t\t      AS1 (lsr,%0)  CR_TAB\n \t\t      AS2 (andi,%0,0x3));\n \t    }\n-\t  *len=6;\n+\t  *len = 6;\n \t  return (AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0) CR_TAB\n \t\t  AS1 (lsr,%0));\n+\t  \n \tcase 7:\n-\t  *len=3;\n+\t  *len = 3;\n \t  return (AS1 (rol,%0) CR_TAB\n \t\t  AS1 (clr,%0) CR_TAB\n \t\t  AS1 (rol,%0));\n \t}\n     }\n+  else if (CONSTANT_P (operands[2]))\n+    fatal_insn (\"Internal compiler bug.\\nIncorrect shift:\", insn);\n+  \n   if (len)\n     *len = 3;\n   out_shift_with_cnt (AS1 (lsr,%0),\n@@ -2600,22 +2707,27 @@ lshrhi3_out (insn,operands,len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+      int *t = len;\n+      \n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\t  \n \tcase 1:\n-\t  *len=2;\n+\t  *len = 2;\n \t  return (AS1 (lsr,%B0) CR_TAB\n \t\t  AS1 (ror,%A0));\n+\t  \n \tcase 2:\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsr,%B0)  CR_TAB\n \t\t  AS1 (ror,%A0)  CR_TAB\n \t\t  AS1 (lsr,%B0)  CR_TAB\n \t\t  AS1 (ror,%A0));\n+\t  \n \tcase 8:\n \t  if (true_regnum (operands[0]) != true_regnum (operands[1]) + 1)\n \t    return *len = 2, (AS2 (mov,%A0,%B1) CR_TAB\n@@ -2624,10 +2736,11 @@ lshrhi3_out (insn,operands,len)\n \t    return *len = 1, AS1 (clr,%B0);\n \t  \n \tcase 15:\n-\t  return *len = 4, (AS1 (lsl,%B0)     CR_TAB\n-\t\t\t    AS2 (sbc,%A0,%A0) CR_TAB\n-\t\t\t    AS1 (neg,%A0)     CR_TAB\n-\t\t\t    AS1 (clr,%B0));\n+\t  *len = 4;\n+\t  return (AS1 (lsl,%B0)     CR_TAB\n+\t\t  AS2 (sbc,%A0,%A0) CR_TAB\n+\t\t  AS1 (neg,%A0)     CR_TAB\n+\t\t  AS1 (clr,%B0));\n \t}\n     }\n   if (len)\n@@ -2649,23 +2762,27 @@ lshrsi3_out (insn,operands,len)\n   if (GET_CODE (operands[2]) == CONST_INT)\n     {\n       int k;\n-      int *t=len;\n+      int *t = len;\n+      \n       if (!len)\n \tlen = &k;\n+      \n       switch (INTVAL (operands[2]))\n \t{\n \tdefault: len = t; break;\n+\t  \n \tcase 1:\n-\t  *len=4;\n+\t  *len = 4;\n \t  return (AS1 (lsr,%D0)  CR_TAB\n \t\t  AS1 (ror,%C0) CR_TAB\n \t\t  AS1 (ror,%B0) CR_TAB\n \t\t  AS1 (ror,%A0));\n+\t  \n \tcase 8:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n-\t    *len=4;\n+\t    *len = 4;\n \t    if (reg0 <= reg1)\n \t      return (AS2 (mov,%A0,%B1) CR_TAB\n \t\t      AS2 (mov,%B0,%C1) CR_TAB\n@@ -2679,11 +2796,12 @@ lshrsi3_out (insn,operands,len)\n \t\t      AS2 (mov,%B0,%C1) CR_TAB\n \t\t      AS2 (mov,%A0,%B1)); \n \t  }\n+\t  \n \tcase 16:\n \t  {\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n-\t    *len=4;\n+\t    *len = 4;\n \t    if (reg0 <= reg1 + 1)\n \t      return (AS2 (mov,%A0,%C1) CR_TAB\n \t\t      AS2 (mov,%B0,%D1) CR_TAB\n@@ -2698,6 +2816,7 @@ lshrsi3_out (insn,operands,len)\n \t\t      AS1 (clr,%C0)     CR_TAB\n \t\t      AS1 (clr,%D0));\n \t  }\n+\t  \n \tcase 24:\n \t  if (true_regnum (operands[0]) != true_regnum (operands[1]) + 3)\n \t    return *len = 4, (AS2 (mov,%A0,%D1) CR_TAB\n@@ -3010,7 +3129,7 @@ asm_output_char(file,value)\n void\n asm_output_byte (file,value)\n      FILE *file;\n-     char value;\n+     int value;\n {\n   fprintf (file, \"\\t.byte 0x%x\\n\",value & 0xff);\n }\n@@ -3342,9 +3461,10 @@ asm_file_end (file)\n      FILE *file;\n {\n   fprintf (file,\n-\t   \"/* File %s: code %4d (%4d), prologues %3d, epilogues %3d */\\n\",\n+\t   \"/* File %s: code %4d = 0x%04x (%4d), prologues %3d, epilogues %3d */\\n\",\n \t   main_input_filename,\n \t   commands_in_file,\n+\t   commands_in_file,\n \t   commands_in_file - commands_in_prologues - commands_in_epilogues,\n \t   commands_in_prologues, commands_in_epilogues);\n }\n@@ -3487,7 +3607,7 @@ avr_address_cost (rtx x)\n int\n extra_constraint (x,c)\n      rtx x;\n-     char c;\n+     int c;\n {\n   if (c == 'Q'\n       && GET_CODE (x) == MEM\n@@ -3506,7 +3626,7 @@ extra_constraint (x,c)\n \t  && REG_P (XEXP (XEXP (x,0), 0))\n \t  && GET_CODE (XEXP (XEXP (x,0), 1)) == CONST_INT\n \t  && (INTVAL (XEXP (XEXP (x,0), 1))\n-\t      <= (64 - GET_MODE_SIZE (GET_MODE (x)))))\n+\t      <= MAX_LD_OFFSET (GET_MODE (x))))\n \t{\n \t  rtx xx = XEXP (XEXP (x,0), 0);\n \t  int regno = REGNO (xx);\n@@ -3667,7 +3787,7 @@ avr_function_value (type,func)\n      tree type;\n      tree func ATTRIBUTE_UNUSED;\n {\n-  int offs;\n+  unsigned int offs;\n   if (TYPE_MODE (type) != BLKmode)\n     return avr_libcall_value (TYPE_MODE (type));\n   "}, {"sha": "f459bc038da9399e89bc07ce224bad3558c0e6a8", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -1079,6 +1079,9 @@ enum reg_class {\n    registers.  This macro must be defined if `ELIMINABLE_REGS' is\n    defined.  */\n \n+#define RETURN_ADDR_RTX(count, x) \\\n+  gen_rtx_MEM (Pmode, memory_address (Pmode, plus_constant (tem, 1)))\n+\n #define PUSH_ROUNDING(NPUSHED) (NPUSHED)\n /* A C expression that is the number of bytes actually pushed onto the\n    stack when an instruction attempts to push NPUSHED bytes."}, {"sha": "064e9ab92894819709121dbf7100364444247cbf", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 11, "deletions": 21, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -254,7 +254,7 @@\n     case 1:  /* mov r,L */\n       return (AS1 (clr,%A0) CR_TAB\n \t      AS1 (clr,%B0));\n-    case 2: /* mov r,d */\n+    case 2: /* ld d,i */\n       if (operands[1] == const1_rtx\n           && (link = find_reg_note (insn, REG_WAS_0, 0))\n \t  /* Make sure the insn that stored the 0 is still present.  */\n@@ -272,7 +272,7 @@\n       return out_movhi_r_mr (insn, operands, NULL);\n     case 4: /* mov m,r*/\n         {\n-          rtx save1=NULL;\n+          rtx save1 = NULL;\n           if (operands[1] == const0_rtx)\n             {\n               save1 = operands[1];\n@@ -543,15 +543,6 @@\n       short tmp = INTVAL (operands[2]);\n       operands[2] = GEN_INT(tmp);\n     }\n- if (! (reload_completed | reload_in_progress))\n-   {\n-     if (REGNO (operands[0]) != REGNO (operands[1])\n-\t && REGNO (operands[0]) != REGNO (operands[2])&&0)\n-       {\n-\t emit_move_insn (operands[0], operands[1]);\n-\t operands[1] = operands[0];\n-       }\n-   }\n }\")\n \n \n@@ -871,10 +862,10 @@\n (define_insn \"ashlqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,!d,r,r\")\n \t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n-\t\t   (match_operand:QI 2 \"general_operand\" \"r,i,i,Qm\")))]\n+\t\t   (match_operand:QI 2 \"general_operand\" \"r,n,n,Qm\")))]\n   \"\"\n   \"* return ashlqi3_out (insn, operands, NULL);\"\n-  [(set_attr \"length\" \"6,4,6,7\")\n+  [(set_attr \"length\" \"5,4,6,7\")\n    (set_attr \"cc\" \"clobber,set_czn,set_czn,clobber\")])\n \n (define_insn \"ashlhi3\"\n@@ -903,12 +894,11 @@\n (define_insn \"ashrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,r,r,r,r\")\n \t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"r,P,K,i,Qm\")))\n-   (clobber (match_scratch:QI 3 \"=X,X,X,&d,X\"))]\n+\t\t     (match_operand:QI 2 \"general_operand\" \"r,P,K,n,Qm\")))]\n   \"\"\n-  \"* return ashrqi3_out (insn,operands, NULL);\"\n-  [(set_attr \"length\" \"6,1,2,4,7\")\n-   (set_attr \"cc\" \"clobber,clobber,clobber,clobber,clobber\")])\n+  \"* return ashrqi3_out (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"5,1,2,5,7\")\n+   (set_attr \"cc\" \"clobber,set_zn,set_zn,clobber,clobber\")])\n \n (define_insn \"ashrhi3\"\n   [(set (match_operand:HI 0 \"register_operand\"             \"=r,r,r,r,r,r\")\n@@ -936,7 +926,7 @@\n (define_insn \"lshrqi3\"\n   [(set (match_operand:QI 0 \"register_operand\" \"=r,d,r,r\")\n \t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0,0,0,0\")\n-\t\t     (match_operand:QI 2 \"general_operand\" \"r,i,i,Qm\")))]\n+\t\t     (match_operand:QI 2 \"general_operand\" \"r,n,n,Qm\")))]\n   \"\"\n   \"* return lshrqi3_out (insn,operands, NULL);\"\n   [(set_attr \"length\" \"6,4,6,7\")\n@@ -1621,7 +1611,7 @@\n    (set (attr \"length\")\n \t(cond [(eq (symbol_ref \"which_alternative\") (const_int 0))\n \t       (const_int 1)\n-\t       (eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (eq (symbol_ref \"which_alternative\") (const_int 1))\n \t       (const_int 3)\n \t       (eq (symbol_ref \"!AVR_MEGA\")\n \t\t   (const_int 0))\n@@ -1651,7 +1641,7 @@\n    (set (attr \"length\")\n \t(cond [(eq (symbol_ref \"which_alternative\") (const_int 0))\n \t       (const_int 1)\n-\t       (eq (symbol_ref \"which_alternative\") (const_int 0))\n+\t       (eq (symbol_ref \"which_alternative\") (const_int 1))\n \t       (const_int 3)\n \t       (eq (symbol_ref \"!AVR_MEGA\")\n \t\t   (const_int 0))"}, {"sha": "1bc971eac045102439aa011fbc2b885b9d8c1e2f", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3454eb731b213cda64cbd7ac18a9d0093c33cbc7/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=3454eb731b213cda64cbd7ac18a9d0093c33cbc7", "patch": "@@ -32,7 +32,6 @@ TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc\n #LIBGCC2 = $(LIBGCC1)\n \n fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/avr/t-avr\n-\techo '#define FLOAT' > fp-bit.c\n \techo '#define FLOAT_ONLY' >> fp-bit.c\n \techo '#define CMPtype QItype' >> fp-bit.c\n \techo '#define DF SF' >> fp-bit.c"}]}