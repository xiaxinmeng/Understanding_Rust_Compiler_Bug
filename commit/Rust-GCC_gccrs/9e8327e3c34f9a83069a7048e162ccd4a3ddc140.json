{"sha": "9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWU4MzI3ZTNjMzRmOWE4MzA2OWE3MDQ4ZTE2MmNjZDRhM2RkYzE0MA==", "commit": {"author": {"name": "Ulrich Weigand", "email": "uweigand@de.ibm.com", "date": "2003-08-28T12:28:40Z"}, "committer": {"name": "Ulrich Weigand", "email": "uweigand@gcc.gnu.org", "date": "2003-08-28T12:28:40Z"}, "message": "s390.c (legitmate_constant_p): Use LARL on zSeries machines even in 31-bit addressing mode.\n\n\t* config/s390/s390.c (legitmate_constant_p): Use LARL on\n\tzSeries machines even in 31-bit addressing mode.\n\t(legitimate_reload_constant_p): Likewise.\n\t(legitimize_pic_address): Likewise.\n\t(legitimize_tls_address): Likewise.\n\t(s390_split_branches): Likewise.\n\t(s390_dump_pool): Likewise.\n\t(s390_mainpool_finish): Likewise.\n\t(s390_chunkify_start): Likewise.\n\t(s390_select_rtx_section): Likewise.\n\t* config/s390/s390.md (\"doloop_si\"): Likewise.\n\t(\"pool_start_31\", \"pool_end_31\"): Likewise.\n\t(\"pool_start_64\", \"pool_end_64\"): Likewise.\n\t(\"main_base_31_small\", \"main_base_31_large\"): Likewise.\n\t(\"main_base_64\"): Likewise.\n\t(\"reload_base_31\", \"reload_base_64\"): Likewise.\n\t(\"*movsi_larl\"): New insn.\n\t(\"cjump\", \"icjump\"): Use long branches on zSeries machines.\n\t(\"jump\"): Likewise.\n\t(\"call\"): Use BRASL on zSeries machines.\n\t(\"call_value\", \"call_value_tls\"): Likewise.\n\t(\"brasl\", \"bras\", \"basr_64\", \"basr_31\", \"bas_64\", \"bas_31\"): Remove\n\tand replace by ...\n\t(\"*bras\", \"*brasl\", \"*basr\") ... these new insns.\n\t(\"brasl_r\", \"bras_r\", \"basr_64_r\", \"basr_31_r\", \"bas_64_r\",\n\t\"bas_31_r\"): Remove and replace by ...\n\t(\"*bras_r\", \"*brasl_r\", \"*basr_r\") ... these new insns.\n\t(\"brasl_tls\", \"bras_tls\", \"basr_64_tls\", \"basr_31_tls\",\n\t\"bas_64_tls\", \"bas_31_tls\"): Remove and replace by ...\n\t(\"*bras_tls\", \"*brasl_tls\", \"*basr_tls\") ... these new insns.\n\t(\"*return_si\", \"*return_di\"): Remove and replace by ...\n\t(\"*return\"): ... this new insn.\n\t(\"rotlsi3\"): Allow on zSeries machines.\n\n\t* config/s390/s390.c (legitimize_reload_constant_p): Use\n\tLL/LH type instructions in z/Architecture mode.\n\t* config/s390/s390.md (\"*movsi_lli\"): Likewise.\n\t(\"*andsi3_ni\", \"*andhi3_ni\", \"*andqi3_ni\"): Likewise.\n\t(\"*iorsi3_ni\", \"*iorhi3_ni\", \"*iorqi3_ni\"): Likewise.\n\t(\"*extendqisi2\"): Use LB in z/Architecture mode.\n\t(\"*zero_extendqisi2_64\", \"*zero_extendqisi2_31\"): Use LLGC in\n\tz/Architecture mode.\n\t(\"zero_extendqihi2\", \"*zero_extendqihi2_64\", \"*zero_extendqihi2_31\"):\n\tLikewise.\n\n\t* config/s390/s390.md (\"*tmdi_ext\"): Allow in both 64-bit\n\tand 31-bit mode.\n\t(\"ptr_extend\"): Allow only in 64-bit mode.\n\nFrom-SVN: r70882", "tree": {"sha": "a76164cf1ea3a2006a395dad2d0e1f94cca53843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a76164cf1ea3a2006a395dad2d0e1f94cca53843"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/comments", "author": null, "committer": null, "parents": [{"sha": "22bd385b2b2c5e3a8b2bc1370cd576b75195d72e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22bd385b2b2c5e3a8b2bc1370cd576b75195d72e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22bd385b2b2c5e3a8b2bc1370cd576b75195d72e"}], "stats": {"total": 469, "additions": 229, "deletions": 240}, "files": [{"sha": "1ba1a2124ce47a2d34181197b5d6fa8ffb886c6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "patch": "@@ -1,3 +1,54 @@\n+2003-08-28  Ulrich Weigand  <uweigand@de.ibm.com>\n+\n+\t* config/s390/s390.c (legitmate_constant_p): Use LARL on\n+\tzSeries machines even in 31-bit addressing mode.\n+\t(legitimate_reload_constant_p): Likewise.\n+\t(legitimize_pic_address): Likewise.\n+\t(legitimize_tls_address): Likewise.\n+\t(s390_split_branches): Likewise.\n+\t(s390_dump_pool): Likewise.\n+\t(s390_mainpool_finish): Likewise.\n+\t(s390_chunkify_start): Likewise.\n+\t(s390_select_rtx_section): Likewise.\n+\t* config/s390/s390.md (\"doloop_si\"): Likewise.\n+\t(\"pool_start_31\", \"pool_end_31\"): Likewise.\n+\t(\"pool_start_64\", \"pool_end_64\"): Likewise.\n+\t(\"main_base_31_small\", \"main_base_31_large\"): Likewise.\n+\t(\"main_base_64\"): Likewise.\n+\t(\"reload_base_31\", \"reload_base_64\"): Likewise.\n+\t(\"*movsi_larl\"): New insn.\n+\t(\"cjump\", \"icjump\"): Use long branches on zSeries machines.\n+\t(\"jump\"): Likewise.\n+\t(\"call\"): Use BRASL on zSeries machines.\n+\t(\"call_value\", \"call_value_tls\"): Likewise.\n+\t(\"brasl\", \"bras\", \"basr_64\", \"basr_31\", \"bas_64\", \"bas_31\"): Remove \n+\tand replace by ...\n+\t(\"*bras\", \"*brasl\", \"*basr\") ... these new insns.\n+\t(\"brasl_r\", \"bras_r\", \"basr_64_r\", \"basr_31_r\", \"bas_64_r\", \n+\t\"bas_31_r\"): Remove and replace by ...\n+\t(\"*bras_r\", \"*brasl_r\", \"*basr_r\") ... these new insns.\n+\t(\"brasl_tls\", \"bras_tls\", \"basr_64_tls\", \"basr_31_tls\", \n+\t\"bas_64_tls\", \"bas_31_tls\"): Remove and replace by ...\n+\t(\"*bras_tls\", \"*brasl_tls\", \"*basr_tls\") ... these new insns.\n+\t(\"*return_si\", \"*return_di\"): Remove and replace by ...\n+\t(\"*return\"): ... this new insn.\n+\t(\"rotlsi3\"): Allow on zSeries machines.\n+\n+\t* config/s390/s390.c (legitimize_reload_constant_p): Use\n+\tLL/LH type instructions in z/Architecture mode.\n+\t* config/s390/s390.md (\"*movsi_lli\"): Likewise.\n+\t(\"*andsi3_ni\", \"*andhi3_ni\", \"*andqi3_ni\"): Likewise.\n+\t(\"*iorsi3_ni\", \"*iorhi3_ni\", \"*iorqi3_ni\"): Likewise.\n+\t(\"*extendqisi2\"): Use LB in z/Architecture mode.\n+\t(\"*zero_extendqisi2_64\", \"*zero_extendqisi2_31\"): Use LLGC in \n+\tz/Architecture mode.\n+\t(\"zero_extendqihi2\", \"*zero_extendqihi2_64\", \"*zero_extendqihi2_31\"): \n+\tLikewise.\n+\t\n+\t* config/s390/s390.md (\"*tmdi_ext\"): Allow in both 64-bit\n+\tand 31-bit mode.\n+\t(\"ptr_extend\"): Allow only in 64-bit mode.\n+\n 2003-08-27  Daniel Jacobowitz  <drow@mvista.com>\n \n \t* gcc.c (STANDARD_EXEC_PREFIX, STANDARD_STARTFILE_PREFIX)"}, {"sha": "4bdb40584acce2ce52961786e1ccfc8ae33c828c", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "patch": "@@ -1631,7 +1631,7 @@ legitimate_constant_p (register rtx op)\n     return 1;\n \n   /* Accept immediate LARL operands.  */\n-  if (TARGET_64BIT && larl_operand (op, VOIDmode))\n+  if (TARGET_CPU_ZARCH && larl_operand (op, VOIDmode))\n     return 1;\n \n   /* Thread-local symbols are never legal constants.  This is\n@@ -1730,12 +1730,12 @@ legitimate_reload_constant_p (register rtx op)\n     return 1;\n \n   /* Accept lliXX operands.  */\n-  if (TARGET_64BIT\n+  if (TARGET_ZARCH\n       && s390_single_hi (op, DImode, 0) >= 0)\n   return 1;\n \n   /* Accept larl operands.  */\n-  if (TARGET_64BIT\n+  if (TARGET_CPU_ZARCH\n       && larl_operand (op, VOIDmode))\n     return 1;\n \n@@ -2260,7 +2260,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n       || (GET_CODE (addr) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (addr)))\n     {\n       /* This is a local symbol.  */\n-      if (TARGET_64BIT && larl_operand (addr, VOIDmode))\n+      if (TARGET_CPU_ZARCH && larl_operand (addr, VOIDmode))\n         {\n           /* Access local symbols PC-relative via LARL.\n              This is the same as in the non-PIC case, so it is\n@@ -2309,7 +2309,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n           emit_move_insn (reg, new);\n           new = reg;\n         }\n-      else if (TARGET_64BIT)\n+      else if (TARGET_CPU_ZARCH)\n         {\n           /* If the GOT offset might be >= 4k, we determine the position\n              of the GOT entry via a PC-relative LARL (@GOTENT).  */\n@@ -2378,7 +2378,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n                   /* @PLT is OK as is on 64-bit, must be converted to\n                      GOT-relative @PLTOFF on 31-bit.  */\n                   case UNSPEC_PLT:\n-                    if (!TARGET_64BIT)\n+                    if (!TARGET_CPU_ZARCH)\n                       {\n                         rtx temp = reg? reg : gen_reg_rtx (Pmode);\n \n@@ -2418,7 +2418,7 @@ legitimize_pic_address (rtx orig, rtx reg)\n \t\t|| (GET_CODE (op0) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op0)))\n \t      && GET_CODE (op1) == CONST_INT)\n \t    {\n-              if (TARGET_64BIT && larl_operand (op0, VOIDmode))\n+              if (TARGET_CPU_ZARCH && larl_operand (op0, VOIDmode))\n                 {\n                   if (INTVAL (op1) & 1)\n                     {\n@@ -2625,7 +2625,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n \t    temp = gen_reg_rtx (Pmode);\n \t    emit_move_insn (temp, new);\n \t  }\n-\telse if (TARGET_64BIT)\n+\telse if (TARGET_CPU_ZARCH)\n \t  {\n \t    /* If the GOT offset might be >= 4k, we determine the position\n \t       of the GOT entry via a PC-relative LARL.  */\n@@ -2714,7 +2714,7 @@ legitimize_tls_address (rtx addr, rtx reg)\n       switch (XINT (XEXP (addr, 0), 1))\n \t{\n \tcase UNSPEC_INDNTPOFF:\n-\t  if (TARGET_64BIT)\n+\t  if (TARGET_CPU_ZARCH)\n \t    new = addr;\n \t  else\n \t    abort ();\n@@ -3806,12 +3806,12 @@ s390_split_branches (rtx temp_reg, bool *temp_used)\n       else\n \tcontinue;\n \n-      if (get_attr_length (insn) <= (TARGET_64BIT ? 6 : 4))\n+      if (get_attr_length (insn) <= (TARGET_CPU_ZARCH ? 6 : 4))\n \tcontinue;\n \n       *temp_used = 1;\n \n-      if (TARGET_64BIT)\n+      if (TARGET_CPU_ZARCH)\n \t{\n \t  tmp = emit_insn_before (gen_rtx_SET (Pmode, temp_reg, *label), insn);\n \t  INSN_ADDRESSES_NEW (tmp, -1);\n@@ -4212,7 +4212,7 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n \n   /* Pool start insn switches to proper section\n      and guarantees necessary alignment.  */\n-  if (TARGET_64BIT)\n+  if (TARGET_CPU_ZARCH)\n     insn = emit_insn_after (gen_pool_start_64 (), pool->pool_insn);\n   else\n     insn = emit_insn_after (gen_pool_start_31 (), pool->pool_insn);\n@@ -4253,7 +4253,7 @@ s390_dump_pool (struct constant_pool *pool, bool remote_label)\n \n   /* Pool end insn switches back to previous section\n      and guarantees necessary alignment.  */\n-  if (TARGET_64BIT)\n+  if (TARGET_CPU_ZARCH)\n     insn = emit_insn_after (gen_pool_end_64 (), insn);\n   else\n     insn = emit_insn_after (gen_pool_end_31 (), insn);\n@@ -4380,9 +4380,9 @@ s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n   /* We need correct insn addresses.  */\n   shorten_branches (get_insns ());\n \n-  /* In 64-bit, we use a LARL to load the pool register.  The pool is\n+  /* On zSeries, we use a LARL to load the pool register.  The pool is\n      located in the .rodata section, so we emit it after the function.  */\n-  if (TARGET_64BIT)\n+  if (TARGET_CPU_ZARCH)\n     {\n       insn = gen_main_base_64 (base_reg, pool->label);\n       insn = emit_insn_after (insn, pool->pool_insn);\n@@ -4396,7 +4396,7 @@ s390_mainpool_finish (struct constant_pool *pool, rtx base_reg)\n       s390_dump_pool (pool, 0);\n     }\n \n-  /* In 31-bit, if the total size of the function's code plus literal pool\n+  /* On S/390, if the total size of the function's code plus literal pool\n      does not exceed 4096 bytes, we use BASR to set up a function base\n      pointer, and emit the literal pool at the end of the function.  */\n   else if (INSN_ADDRESSES (INSN_UID (get_last_insn ()))\n@@ -4496,7 +4496,7 @@ s390_chunkify_start (rtx base_reg)\n   rtx insn;\n \n   rtx (*gen_reload_base) (rtx, rtx) =\n-    TARGET_64BIT? gen_reload_base_64 : gen_reload_base_31;\n+    TARGET_CPU_ZARCH? gen_reload_base_64 : gen_reload_base_31;\n \n \n   /* We need correct insn addresses.  */\n@@ -4562,7 +4562,7 @@ s390_chunkify_start (rtx base_reg)\n           || INSN_ADDRESSES (INSN_UID (insn)) == -1)\n \tcontinue;\n \n-      if (TARGET_64BIT)\n+      if (TARGET_CPU_ZARCH)\n \t{\n \t  if (curr_pool->size < S390_POOL_CHUNK_MAX)\n \t    continue;\n@@ -5426,7 +5426,7 @@ s390_load_got (int maybe_dead)\n       SYMBOL_REF_FLAGS (got_symbol) = SYMBOL_FLAG_LOCAL;\n     }\n \n-  if (TARGET_64BIT)\n+  if (TARGET_CPU_ZARCH)\n     {\n       rtx insn = emit_move_insn (pic_offset_table_rtx, got_symbol);\n       if (maybe_dead)\n@@ -6583,7 +6583,7 @@ s390_select_rtx_section (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t rtx x ATTRIBUTE_UNUSED,\n \t\t\t unsigned HOST_WIDE_INT align ATTRIBUTE_UNUSED)\n {\n-  if (TARGET_64BIT)\n+  if (TARGET_CPU_ZARCH)\n     readonly_data_section ();\n   else\n     function_section (current_function_decl);"}, {"sha": "01a9904b068b960d3a01951dc5a00c4446b16a96", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 158, "deletions": 220, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e8327e3c34f9a83069a7048e162ccd4a3ddc140/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=9e8327e3c34f9a83069a7048e162ccd4a3ddc140", "patch": "@@ -429,8 +429,7 @@\n         (compare (and:DI (match_operand:DI 0 \"memory_operand\" \"Q,S\")\n                          (match_operand:DI 1 \"immediate_operand\" \"n,n\"))\n                  (match_operand:DI 2 \"immediate_operand\" \"n,n\")))]\n-  \"TARGET_64BIT\n-   && s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n+  \"s390_match_ccmode (insn, s390_tm_ccmode (operands[1], operands[2], 0))\n    && s390_single_qi (operands[1], DImode, 0) >= 0\"\n {\n   int part = s390_single_qi (operands[1], DImode, 0);\n@@ -1237,7 +1236,7 @@\n (define_insn \"*movsi_lli\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (match_operand:SI 1 \"immediate_operand\" \"n\"))]\n-  \"TARGET_64BIT && s390_single_hi (operands[1], SImode, 0) >= 0\n+  \"TARGET_ZARCH && s390_single_hi (operands[1], SImode, 0) >= 0\n    && !FP_REG_P (operands[0])\"\n {\n   int part = s390_single_hi (operands[1], SImode, 0);\n@@ -1262,6 +1261,15 @@\n   [(set_attr \"op_type\" \"RXY\")\n    (set_attr \"type\" \"la\")])\n \n+(define_insn \"*movsi_larl\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+        (match_operand:SI 1 \"larl_operand\" \"X\"))]\n+  \"!TARGET_64BIT && TARGET_CPU_ZARCH\n+   && !FP_REG_P (operands[0])\"\n+  \"larl\\t%0,%1\"\n+   [(set_attr \"op_type\" \"RIL\")\n+    (set_attr \"type\"    \"larl\")])\n+\n (define_insn \"*movsi\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,d,d,R,T,!*f,!*f,!*f,!R,!T,?Q\")\n         (match_operand:SI 1 \"general_operand\" \"d,R,T,d,d,*f,R,T,*f,*f,?Q\"))]\n@@ -2356,14 +2364,14 @@\n (define_insn \"*extendqisi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (sign_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_64BIT && TARGET_LONG_DISPLACEMENT\"\n+  \"TARGET_LONG_DISPLACEMENT\"\n   \"lb\\t%0,%1\"\n   [(set_attr \"op_type\" \"RXY\")])\n \n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n         (sign_extend:SI (match_operand:QI 1 \"s_operand\" \"\")))]\n-  \"(!TARGET_64BIT || !TARGET_LONG_DISPLACEMENT) && !reload_completed\"\n+  \"!TARGET_LONG_DISPLACEMENT && !reload_completed\"\n   [(parallel\n     [(set (match_dup 0) (unspec:SI [(match_dup 1)] UNSPEC_SETHIGH))\n      (clobber (reg:CC 33))])\n@@ -2601,14 +2609,14 @@\n (define_insn \"*zero_extendqisi2_64\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n         (zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"llgc\\t%0,%1\"\n   [(set_attr \"op_type\" \"RXY\")])\n \n (define_insn_and_split \"*zero_extendqisi2_31\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=&d\")\n         (zero_extend:SI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (const_int 0))\n@@ -2623,7 +2631,7 @@\n (define_expand \"zero_extendqihi2\"\n   [(set (match_operand:HI 0 \"register_operand\" \"\")\n         (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"\n {\n   operands[1] = gen_lowpart (HImode, operands[1]);\n@@ -2635,14 +2643,14 @@\n (define_insn \"*zero_extendqihi2_64\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=d\")\n         (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"llgc\\t%0,%1\"\n   [(set_attr \"op_type\" \"RXY\")])\n \n (define_insn_and_split \"*zero_extendqihi2_31\"\n   [(set (match_operand:HI 0 \"register_operand\" \"=&d\")\n         (zero_extend:HI (match_operand:QI 1 \"memory_operand\" \"m\")))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_ZARCH\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0) (const_int 0))\n@@ -4787,7 +4795,7 @@\n         (and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n                 (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT && s390_single_hi (operands[2], SImode, -1) >= 0\"\n+  \"TARGET_ZARCH && s390_single_hi (operands[2], SImode, -1) >= 0\"\n {\n   int part = s390_single_hi (operands[2], SImode, -1);\n   operands[2] = GEN_INT (s390_extract_hi (operands[2], SImode, part));\n@@ -4840,7 +4848,7 @@\n         (and:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n                 (match_operand:HI 2 \"nonmemory_operand\" \"d,n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    nr\\t%0,%2\n    nill\\t%0,%x2\"\n@@ -4882,7 +4890,7 @@\n         (and:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n                 (match_operand:QI 2 \"nonmemory_operand\" \"d,n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    nr\\t%0,%2\n    nill\\t%0,%b2\"\n@@ -5041,7 +5049,7 @@\n         (ior:SI (match_operand:SI 1 \"nonimmediate_operand\" \"0\")\n                 (match_operand:SI 2 \"immediate_operand\" \"n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT && s390_single_hi (operands[2], SImode, 0) >= 0\"\n+  \"TARGET_ZARCH && s390_single_hi (operands[2], SImode, 0) >= 0\"\n {\n   int part = s390_single_hi (operands[2], SImode, 0);\n   operands[2] = GEN_INT (s390_extract_hi (operands[2], SImode, part));\n@@ -5094,7 +5102,7 @@\n         (ior:HI (match_operand:HI 1 \"register_operand\" \"%0,0\")\n                 (match_operand:HI 2 \"nonmemory_operand\" \"d,n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    or\\t%0,%2\n    oill\\t%0,%x2\"\n@@ -5136,7 +5144,7 @@\n         (ior:QI (match_operand:QI 1 \"register_operand\" \"%0,0\")\n                 (match_operand:QI 2 \"nonmemory_operand\" \"d,n\")))\n    (clobber (reg:CC 33))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_ZARCH\"\n   \"@\n    or\\t%0,%2\n    oill\\t%0,%b2\"\n@@ -5733,7 +5741,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n \t(rotate:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n \t\t   (match_operand:SI 2 \"nonmemory_operand\" \"J,a\")))]\n-  \"TARGET_64BIT\"\n+  \"TARGET_CPU_ZARCH\"\n   \"@\n    rll\\t%0,%1,%c2\n    rll\\t%0,%1,0(%2)\"\n@@ -6164,7 +6172,7 @@\n {\n   if (get_attr_length (insn) == 4)\n     return \"j%C1\\t%l0\";\n-  else if (TARGET_64BIT)\n+  else if (TARGET_CPU_ZARCH)\n     return \"jg%C1\\t%l0\";\n   else\n     abort ();\n@@ -6174,7 +6182,7 @@\n    (set (attr \"length\")\n         (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                 (const_int 4)\n-               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+               (ne (symbol_ref \"TARGET_CPU_ZARCH\") (const_int 0))\n                  (const_int 6)\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n@@ -6213,7 +6221,7 @@\n {\n   if (get_attr_length (insn) == 4)\n     return \"j%D1\\t%l0\";\n-  else if (TARGET_64BIT)\n+  else if (TARGET_CPU_ZARCH)\n     return \"jg%D1\\t%l0\";\n   else\n     abort ();\n@@ -6223,7 +6231,7 @@\n    (set (attr \"length\")\n         (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                 (const_int 4)\n-               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+               (ne (symbol_ref \"TARGET_CPU_ZARCH\") (const_int 0))\n                  (const_int 6)\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n@@ -6332,7 +6340,7 @@\n    (set (attr \"length\")\n         (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                 (const_int 4)\n-               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+               (ne (symbol_ref \"TARGET_CPU_ZARCH\") (const_int 0))\n                  (const_int 10)\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n@@ -6473,7 +6481,7 @@\n {\n   if (get_attr_length (insn) == 4)\n     return \"j\\t%l0\";\n-  else if (TARGET_64BIT)\n+  else if (TARGET_CPU_ZARCH)\n     return \"jg\\t%l0\";\n   else\n     abort ();\n@@ -6483,7 +6491,7 @@\n    (set (attr \"length\")\n         (cond [(lt (abs (minus (pc) (match_dup 0))) (const_int 60000))\n                 (const_int 4)\n-               (ne (symbol_ref \"TARGET_64BIT\") (const_int 0))\n+               (ne (symbol_ref \"TARGET_CPU_ZARCH\") (const_int 0))\n                  (const_int 6)\n                (eq (symbol_ref \"flag_pic\") (const_int 0))\n                  (const_int 6)] (const_int 8)))])\n@@ -6625,6 +6633,7 @@\n    (use (match_operand 2 \"\" \"\"))]\n   \"\"\n {\n+  bool plt_call = false;\n   rtx insn;\n \n   /* Direct function calls need special treatment.  */\n@@ -6638,11 +6647,12 @@\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n           sym = gen_rtx_CONST (Pmode, sym);\n+\t  plt_call = true;\n         }\n \n       /* Unless we can use the bras(l) insn, force the\n          routine address into a register.  */\n-      if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n+      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n \t{\n \t  if (flag_pic)\n \t    sym = legitimize_pic_address (sym, 0);\n@@ -6656,6 +6666,11 @@\n   /* Emit insn.  */\n   insn = emit_call_insn (gen_call_exp (operands[0], operands[1],\n   \t\t\t\t       gen_rtx_REG (Pmode, RETURN_REGNUM)));\n+\n+  /* 31-bit PLT stubs use the GOT register implicitly.  */\n+  if (!TARGET_64BIT && plt_call)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+  \n   DONE;\n })\n \n@@ -6666,62 +6681,40 @@\n   \"\"\n   \"\")\n \n-(define_insn \"brasl\"\n-  [(call (mem:QI (match_operand:DI 0 \"bras_sym_operand\" \"X\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"brasl\\t%2,%0\"\n-  [(set_attr \"op_type\" \"RIL\")\n-   (set_attr \"type\"    \"jsr\")])\n-\n-(define_insn \"bras\"\n-  [(call (mem:QI (match_operand:SI 0 \"bras_sym_operand\" \"X\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_SMALL_EXEC\"\n+(define_insn \"*bras\"\n+  [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n+         (match_operand 1 \"const_int_operand\" \"n\"))\n+   (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n+  \"TARGET_SMALL_EXEC && GET_MODE (operands[2]) == Pmode\"\n   \"bras\\t%2,%0\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n \n-(define_insn \"basr_64\"\n-  [(call (mem:QI (match_operand:DI 0 \"register_operand\" \"a\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"basr\\t%2,%0\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n-\n-(define_insn \"basr_31\"\n-  [(call (mem:QI (match_operand:SI 0 \"register_operand\" \"a\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"!TARGET_64BIT\"\n-  \"basr\\t%2,%0\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"    \"agen\")])\n-\n-(define_insn \"bas_64\"\n-  [(call (mem:QI (match_operand:QI 0 \"address_operand\" \"U\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:DI 2 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"bas\\t%2,%a0\"\n-  [(set_attr \"op_type\" \"RX\")\n-   (set_attr \"type\"    \"jsr\")])\n-\n-(define_insn \"bas_31\"\n-  [(call (mem:QI (match_operand:QI 0 \"address_operand\" \"U\"))\n-         (match_operand:SI 1 \"const_int_operand\" \"n\"))\n-   (clobber (match_operand:SI 2 \"register_operand\" \"=r\"))]\n-  \"!TARGET_64BIT\"\n-  \"bas\\t%2,%a0\"\n-  [(set_attr \"op_type\" \"RX\")\n+(define_insn \"*brasl\"\n+  [(call (mem:QI (match_operand 0 \"bras_sym_operand\" \"X\"))\n+         (match_operand 1 \"const_int_operand\" \"n\"))\n+   (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n+  \"TARGET_CPU_ZARCH && GET_MODE (operands[2]) == Pmode\"\n+  \"brasl\\t%2,%0\"\n+  [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n \n+(define_insn \"*basr\"\n+  [(call (mem:QI (match_operand 0 \"address_operand\" \"U\"))\n+         (match_operand 1 \"const_int_operand\" \"n\"))\n+   (clobber (match_operand 2 \"register_operand\" \"=r\"))]\n+  \"GET_MODE (operands[2]) == Pmode\"\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \"basr\\t%2,%0\";\n+  else\n+    return \"bas\\t%2,%a0\";\n+}\n+  [(set (attr \"op_type\")\n+        (if_then_else (match_operand 0 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")])\n \n ;\n ; call_value instruction pattern(s).\n@@ -6734,6 +6727,7 @@\n    (use (match_operand 3 \"\" \"\"))]\n   \"\"\n {\n+  bool plt_call = false;\n   rtx insn;\n \n   /* Direct function calls need special treatment.  */\n@@ -6747,11 +6741,12 @@\n         {\n           sym = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, sym), UNSPEC_PLT);\n           sym = gen_rtx_CONST (Pmode, sym);\n+\t  plt_call = true;\n         }\n \n       /* Unless we can use the bras(l) insn, force the\n          routine address into a register.  */\n-      if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n+      if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n         {\n \t  if (flag_pic)\n \t    sym = legitimize_pic_address (sym, 0);\n@@ -6766,6 +6761,11 @@\n   insn = emit_call_insn (\n \t    gen_call_value_exp (operands[0], operands[1], operands[2],\n   \t\t\t\tgen_rtx_REG (Pmode, RETURN_REGNUM)));\n+\n+  /* 31-bit PLT stubs use the GOT register implicitly.  */\n+  if (!TARGET_64BIT && plt_call)\n+    use_reg (&CALL_INSN_FUNCTION_USAGE (insn), pic_offset_table_rtx);\n+  \n   DONE;\n })\n \n@@ -6777,68 +6777,43 @@\n   \"\"\n   \"\")\n \n-(define_insn \"brasl_r\"\n+(define_insn \"*bras_r\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:DI 1 \"bras_sym_operand\" \"X\"))\n+        (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n               (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"brasl\\t%3,%1\"\n-  [(set_attr \"op_type\" \"RIL\")\n-   (set_attr \"type\"    \"jsr\")])\n-\n-(define_insn \"bras_r\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:SI 1 \"bras_sym_operand\" \"X\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_SMALL_EXEC\"\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n+  \"TARGET_SMALL_EXEC && GET_MODE (operands[3]) == Pmode\"\n   \"bras\\t%3,%1\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n \n-(define_insn \"basr_r_64\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:DI 1 \"register_operand\" \"a\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"basr\\t%3,%1\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n-\n-(define_insn \"basr_r_31\"\n+(define_insn \"*brasl_r\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:SI 1 \"register_operand\" \"a\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"!TARGET_64BIT\"\n-  \"basr\\t%3,%1\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n-\n-(define_insn \"bas_r_64\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"U\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))]\n-  \"TARGET_64BIT\"\n-  \"bas\\t%3,%a1\"\n-  [(set_attr \"op_type\" \"RX\")\n+        (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n+              (match_operand 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n+  \"TARGET_CPU_ZARCH && GET_MODE (operands[3]) == Pmode\"\n+  \"brasl\\t%3,%1\"\n+  [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n \n-(define_insn \"bas_r_31\"\n+(define_insn \"*basr_r\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"U\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))]\n-  \"!TARGET_64BIT\"\n-  \"bas\\t%3,%a1\"\n-   [(set_attr \"op_type\" \"RX\")\n-    (set_attr \"type\"    \"jsr\")])\n-\n+        (call (mem:QI (match_operand 1 \"address_operand\" \"U\"))\n+              (match_operand 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))]\n+  \"GET_MODE (operands[3]) == Pmode\"\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \"basr\\t%3,%1\";\n+  else\n+    return \"bas\\t%3,%a1\";\n+}\n+  [(set (attr \"op_type\")\n+        (if_then_else (match_operand 1 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")])\n \n ;;\n ;;- Thread-local storage support.\n@@ -6922,7 +6897,7 @@\n \n   /* Unless we can use the bras(l) insn, force the\n      routine address into a register.  */\n-  if (!TARGET_SMALL_EXEC && !TARGET_64BIT)\n+  if (!TARGET_SMALL_EXEC && !TARGET_CPU_ZARCH)\n     {\n       if (flag_pic)\n \tsym = legitimize_pic_address (sym, 0);\n@@ -6956,74 +6931,46 @@\n   \"\"\n   \"\")\n \n-(define_insn \"brasl_tls\"\n+(define_insn \"*bras_tls\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:DI 1 \"bras_sym_operand\" \"X\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:DI 4 \"\" \"\"))]\n-  \"TARGET_64BIT\"\n-  \"brasl\\t%3,%1%J4\"\n-  [(set_attr \"op_type\" \"RIL\")\n-   (set_attr \"type\"    \"jsr\")])\n-\n-(define_insn \"bras_tls\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:SI 1 \"bras_sym_operand\" \"X\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:SI 4 \"\" \"\"))]\n-  \"TARGET_SMALL_EXEC\"\n+        (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n+              (match_operand 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))\n+   (use (match_operand 4 \"\" \"\"))]\n+  \"TARGET_SMALL_EXEC && GET_MODE (operands[3]) == Pmode\"\n   \"bras\\t%3,%1%J4\"\n   [(set_attr \"op_type\" \"RI\")\n    (set_attr \"type\"    \"jsr\")])\n \n-(define_insn \"basr_tls_64\"\n+(define_insn \"*brasl_tls\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:DI 1 \"register_operand\" \"a\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:DI 4 \"\" \"\"))]\n-  \"TARGET_64BIT\"\n-  \"basr\\t%3,%1%J4\"\n-  [(set_attr \"op_type\" \"RR\")\n+        (call (mem:QI (match_operand 1 \"bras_sym_operand\" \"X\"))\n+              (match_operand 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))\n+   (use (match_operand 4 \"\" \"\"))]\n+  \"TARGET_CPU_ZARCH && GET_MODE (operands[3]) == Pmode\"\n+  \"brasl\\t%3,%1%J4\"\n+  [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"jsr\")])\n \n-(define_insn \"basr_tls_31\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:SI 1 \"register_operand\" \"a\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:SI 4 \"\" \"\"))]\n-  \"!TARGET_64BIT\"\n-  \"basr\\t%3,%1%J4\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n-\n-(define_insn \"bas_tls_64\"\n+(define_insn \"*basr_tls\"\n   [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"U\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:DI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:DI 4 \"\" \"\"))]\n-  \"TARGET_64BIT\"\n-  \"bas\\t%3,%a1%J4\"\n-  [(set_attr \"op_type\" \"RX\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n-\n-(define_insn \"bas_tls_31\"\n-  [(set (match_operand 0 \"register_operand\" \"=df\")\n-        (call (mem:QI (match_operand:QI 1 \"address_operand\" \"U\"))\n-              (match_operand:SI 2 \"const_int_operand\" \"n\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=r\"))\n-   (use (match_operand:SI 4 \"\" \"\"))]\n-  \"!TARGET_64BIT\"\n-  \"bas\\t%3,%a1%J4\"\n-   [(set_attr \"op_type\" \"RX\")\n-    (set_attr \"type\"    \"jsr\")\n-    (set_attr \"atype\"   \"agen\")])\n+        (call (mem:QI (match_operand 1 \"address_operand\" \"U\"))\n+              (match_operand 2 \"const_int_operand\" \"n\")))\n+   (clobber (match_operand 3 \"register_operand\" \"=r\"))\n+   (use (match_operand 4 \"\" \"\"))]\n+  \"GET_MODE (operands[3]) == Pmode\"\n+{\n+  if (get_attr_op_type (insn) == OP_TYPE_RR)\n+    return \"basr\\t%3,%1%J4\";\n+  else\n+    return \"bas\\t%3,%a1%J4\";\n+}\n+  [(set (attr \"op_type\")\n+        (if_then_else (match_operand 1 \"register_operand\" \"\")\n+                      (const_string \"RR\") (const_string \"RX\")))\n+   (set_attr \"type\"  \"jsr\")\n+   (set_attr \"atype\" \"agen\")])\n \n ;;\n ;;- Miscellaneous instructions.\n@@ -7207,52 +7154,52 @@\n \n (define_insn \"pool_start_31\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_CPU_ZARCH\"\n   \".align\\t4\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"pool_end_31\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_CPU_ZARCH\"\n   \".align\\t2\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"2\")])\n \n (define_insn \"pool_start_64\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_POOL_START)]\n-  \"TARGET_64BIT\"\n+  \"TARGET_CPU_ZARCH\"\n   \".section\\t.rodata\\;.align\\t8\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n (define_insn \"pool_end_64\"\n   [(unspec_volatile [(const_int 0)] UNSPECV_POOL_END)]\n-  \"TARGET_64BIT\"\n+  \"TARGET_CPU_ZARCH\"\n   \".previous\"\n   [(set_attr \"op_type\"  \"NN\")\n    (set_attr \"length\"   \"0\")])\n \n (define_insn \"main_base_31_small\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n-  \"!TARGET_64BIT\"\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n+  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n   \"basr\\t%0,0\"\n   [(set_attr \"op_type\" \"RR\")\n    (set_attr \"type\"    \"la\")])\n \n (define_insn \"main_base_31_large\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))\n    (set (pc) (label_ref (match_operand 2 \"\" \"\")))]\n-  \"!TARGET_64BIT\"\n+  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n   \"bras\\t%0,%2\"\n   [(set_attr \"op_type\" \"RI\")])\n \n (define_insn \"main_base_64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n-  \"TARGET_64BIT\"\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_MAIN_BASE))]\n+  \"TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n   \"larl\\t%0,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"larl\")])\n@@ -7264,18 +7211,18 @@\n   [(set_attr \"op_type\" \"NN\")])\n \n (define_insn \"reload_base_31\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n-        (unspec:SI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n-  \"!TARGET_64BIT\"\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n+  \"!TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n   \"basr\\t%0,0\\;la\\t%0,%1-.(%0)\"\n   [(set_attr \"op_type\" \"NN\")\n    (set_attr \"type\"    \"la\")\n    (set_attr \"length\"  \"6\")])\n \n (define_insn \"reload_base_64\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=a\")\n-        (unspec:DI [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n-  \"TARGET_64BIT\"\n+  [(set (match_operand 0 \"register_operand\" \"=a\")\n+        (unspec [(label_ref (match_operand 1 \"\" \"\"))] UNSPEC_RELOAD_BASE))]\n+  \"TARGET_CPU_ZARCH && GET_MODE (operands[0]) == Pmode\"\n   \"larl\\t%0,%1\"\n   [(set_attr \"op_type\" \"RIL\")\n    (set_attr \"type\"    \"larl\")])\n@@ -7302,32 +7249,23 @@\n   \"\"\n   \"s390_emit_epilogue (); DONE;\")\n \n-\n-(define_insn \"*return_si\"\n+(define_insn \"*return\"\n   [(return)\n-   (use (match_operand:SI 0 \"register_operand\" \"a\"))]\n-  \"!TARGET_64BIT\"\n+   (use (match_operand 0 \"register_operand\" \"a\"))]\n+  \"GET_MODE (operands[0]) == Pmode\"\n   \"br\\t%0\"\n   [(set_attr \"op_type\" \"RR\")\n    (set_attr \"type\"    \"jsr\")\n    (set_attr \"atype\"   \"agen\")])\n \n-(define_insn \"*return_di\"\n-  [(return)\n-   (use (match_operand:DI 0 \"register_operand\" \"a\"))]\n-  \"TARGET_64BIT\"\n-  \"br\\t%0\"\n-  [(set_attr \"op_type\" \"RR\")\n-   (set_attr \"type\"    \"jsr\")\n-   (set_attr \"atype\"   \"agen\")])\n \n ;; Instruction definition to extend a 31-bit pointer into a 64-bit\n ;; pointer. This is used for compatability.\n \n (define_expand \"ptr_extend\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n         (match_operand:SI 1 \"register_operand\" \"r\"))]\n-   \"\"\n+  \"TARGET_64BIT\"\n {\n   emit_insn (gen_anddi3 (operands[0],\n \t\t\t gen_lowpart (DImode, operands[1]),"}]}