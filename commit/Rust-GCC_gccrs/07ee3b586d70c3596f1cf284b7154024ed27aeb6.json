{"sha": "07ee3b586d70c3596f1cf284b7154024ed27aeb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdlZTNiNTg2ZDcwYzM1OTZmMWNmMjg0YjcxNTQwMjRlZDI3YWViNg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-02-18T22:05:47Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-02-18T22:05:47Z"}, "message": "h8300-protos.h: Add prototypes for h8300_hard_regno_nregs and h8300_hard_regno_mode_ok.\n\n\t* config/h8300/h8300-protos.h: Add prototypes for\n\th8300_hard_regno_nregs and h8300_hard_regno_mode_ok.\n\t* config/h8300/h8300.c (h8300_hard_regno_nregs): New.\n\t(h8300_hard_regno_mode_ok): Likewise.\n\t* config/h8300/h8300.h (HARD_REGNO_NREGS): Call\n\th8300_hard_regno_nregs().\n\t(HARD_REGNO_MODE_OK): Call h8300_hard_regno_mode_ok().\n\nFrom-SVN: r78050", "tree": {"sha": "a9b54d1c0a1b60af70d9616806b0e0cc2aaa616a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a9b54d1c0a1b60af70d9616806b0e0cc2aaa616a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07ee3b586d70c3596f1cf284b7154024ed27aeb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ee3b586d70c3596f1cf284b7154024ed27aeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07ee3b586d70c3596f1cf284b7154024ed27aeb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07ee3b586d70c3596f1cf284b7154024ed27aeb6/comments", "author": null, "committer": null, "parents": [{"sha": "22234f56d2395ae470961d3eb5fdc65a7597af9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22234f56d2395ae470961d3eb5fdc65a7597af9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22234f56d2395ae470961d3eb5fdc65a7597af9a"}], "stats": {"total": 64, "additions": 42, "deletions": 22}, "files": [{"sha": "e0af65acbbd72bd6f66daf3cfe4919c417156d0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07ee3b586d70c3596f1cf284b7154024ed27aeb6", "patch": "@@ -1,3 +1,13 @@\n+2004-02-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/h8300/h8300-protos.h: Add prototypes for\n+\th8300_hard_regno_nregs and h8300_hard_regno_mode_ok.\n+\t* config/h8300/h8300.c (h8300_hard_regno_nregs): New.\n+\t(h8300_hard_regno_mode_ok): Likewise.\n+\t* config/h8300/h8300.h (HARD_REGNO_NREGS): Call\n+\th8300_hard_regno_nregs().\n+\t(HARD_REGNO_MODE_OK): Call h8300_hard_regno_mode_ok().\n+\n 2004-02-18  Per Bothner  <per@bothner.com>\n \n \t* cpphash.h (struct cpp_buffer):  Restore return_at_eof field.  This"}, {"sha": "4f03f9815f1c944cfd8edefd3a58991621a70add", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=07ee3b586d70c3596f1cf284b7154024ed27aeb6", "patch": "@@ -104,6 +104,8 @@ extern int h8300_current_function_interrupt_function_p (void);\n extern int h8300_initial_elimination_offset (int, int);\n extern int h8300_regs_ok_for_stm (int, rtx[]);\n extern int h8300_hard_regno_rename_ok (unsigned int, unsigned int);\n+extern int h8300_hard_regno_nregs (int, enum machine_mode);\n+extern int h8300_hard_regno_mode_ok (int, enum machine_mode);\n \n struct cpp_reader;\n extern void h8300_pr_interrupt (struct cpp_reader *);"}, {"sha": "b34ddd32c31a2c30bbef17f38bddf4e3e4fa4c49", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=07ee3b586d70c3596f1cf284b7154024ed27aeb6", "patch": "@@ -4706,6 +4706,32 @@ h8300_legitimate_address_p (rtx x, int strict)\n \n   return 0;\n }\n+\n+/* Worker function for HARD_REGNO_NREGS.\n+\n+   We pretend the MAC register is 32bits -- we don't have any data\n+   types on the H8 series to handle more than 32bits.  */\n+\n+int\n+h8300_hard_regno_nregs (int regno ATTRIBUTE_UNUSED, enum machine_mode mode)\n+{\n+  return (GET_MODE_SIZE (mode) + UNITS_PER_WORD - 1) / UNITS_PER_WORD;\n+}\n+\n+/* Worker function for HARD_REGNO_MODE_OK.  */\n+\n+int\n+h8300_hard_regno_mode_ok (int regno, enum machine_mode mode)\n+{\n+  if (TARGET_H8300)\n+    /* If an even reg, then anything goes.  Otherwise the mode must be\n+       QI or HI.  */\n+    return ((regno & 1) == 0) || (mode == HImode) || (mode == QImode);\n+  else\n+    /* MAC register can only be of SImode.  Otherwise, anything\n+       goes.  */\n+    return regno == MAC_REG ? mode == SImode : 1;\n+}\n \f\n /* Perform target dependent optabs initialization.  */\n static void"}, {"sha": "6b2d1aa264aa575a263f8c55bf0e1c82c9e60ba8", "filename": "gcc/config/h8300/h8300.h", "status": "modified", "additions": 4, "deletions": 22, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07ee3b586d70c3596f1cf284b7154024ed27aeb6/gcc%2Fconfig%2Fh8300%2Fh8300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.h?ref=07ee3b586d70c3596f1cf284b7154024ed27aeb6", "patch": "@@ -316,29 +316,11 @@ extern int target_flags;\n     fixed_regs[MAC_REG] = call_used_regs[MAC_REG] = 1;\t\\\n }\n \n-/* Return number of consecutive hard regs needed starting at reg REGNO\n-   to hold something of mode MODE.\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\t\\\n+  h8300_hard_regno_nregs ((REGNO), (MODE))\n \n-   This is ordinarily the length in words of a value of mode MODE\n-   but can be less for certain modes in special long registers.\n-\n-   We pretend the MAC register is 32bits -- we don't have any data\n-   types on the H8 series to handle more than 32bits.  */\n-\n-#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n-   ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n-\n-/* Value is 1 if hard register REGNO can hold a value of machine-mode\n-   MODE.\n-\n-   H8/300: If an even reg, then anything goes. Otherwise the mode must be QI\n-           or HI.\n-   H8/300H: Anything goes.  */\n-\n-#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\t\t\t\\\n-  (TARGET_H8300\t\t\t\t\t\t\t\t\\\n-   ? ((((REGNO) & 1) == 0) || ((MODE) == HImode) || ((MODE) == QImode))\t\\\n-   : (REGNO) == MAC_REG ? (MODE) == SImode : 1)\n+#define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n+  h8300_hard_regno_mode_ok ((REGNO), (MODE))\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n    when one has mode MODE1 and one has mode MODE2."}]}