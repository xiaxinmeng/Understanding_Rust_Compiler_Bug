{"sha": "ab6d55ef6209019d4268546aa030928b72f59b49", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWI2ZDU1ZWY2MjA5MDE5ZDQyNjg1NDZhYTAzMDkyOGI3MmY1OWI0OQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-31T18:24:40Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-07-31T18:24:40Z"}, "message": "sched-vis.c (print_exp): Handle FMA explicitly.\n\n\t* sched-vis.c (print_exp): Handle FMA explicitly.  Simplify handling\n\tof RTX_UNARY function-like operations.  Print unknown expression\n\tRTX classes as pseudo-functions.\n\t(print_pattern): Simplify return pattern printing.\n\t(dump_insn_slim): Print the value of notes as a pattern for proper\n\tprinting of CFA notes.\n\nFrom-SVN: r190016", "tree": {"sha": "d4c1b9e1c166a450c3a93ea86fe2a4026d093df5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4c1b9e1c166a450c3a93ea86fe2a4026d093df5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab6d55ef6209019d4268546aa030928b72f59b49", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6d55ef6209019d4268546aa030928b72f59b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab6d55ef6209019d4268546aa030928b72f59b49", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab6d55ef6209019d4268546aa030928b72f59b49/comments", "author": null, "committer": null, "parents": [{"sha": "aa36f90b55f5f77036c6032f7f4de39fc88690c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa36f90b55f5f77036c6032f7f4de39fc88690c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa36f90b55f5f77036c6032f7f4de39fc88690c2"}], "stats": {"total": 98, "additions": 54, "deletions": 44}, "files": [{"sha": "968cc1c6fa1698d3be6ffbc9a3c21d9e4e421769", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6d55ef6209019d4268546aa030928b72f59b49/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6d55ef6209019d4268546aa030928b72f59b49/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ab6d55ef6209019d4268546aa030928b72f59b49", "patch": "@@ -1,3 +1,12 @@\n+2012-07-31  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* sched-vis.c (print_exp): Handle FMA explicitly.  Simplify handling\n+\tof RTX_UNARY function-like operations.  Print unknown expression\n+\tRTX classes as pseudo-functions.\n+\t(print_pattern): Simplify return pattern printing.\n+\t(dump_insn_slim): Print the value of notes as a pattern for proper\n+\tprinting of CFA notes.\n+\n 2012-07-31  Dehao Chen  <dehao@google.com>\n \n \t* predict.c (tree_estimate_probability_driver): Normalize the"}, {"sha": "abd83443e748ff7e9f1f8ba6d94e3b9a7f624165", "filename": "gcc/sched-vis.c", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab6d55ef6209019d4268546aa030928b72f59b49/gcc%2Fsched-vis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab6d55ef6209019d4268546aa030928b72f59b49/gcc%2Fsched-vis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-vis.c?ref=ab6d55ef6209019d4268546aa030928b72f59b49", "patch": "@@ -114,6 +114,15 @@ print_exp (char *buf, const_rtx x, int verbose)\n       st[0] = \"-\";\n       op[0] = XEXP (x, 0);\n       break;\n+    case FMA:\n+      st[0] = \"{\";\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"*\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \"+\";\n+      op[2] = XEXP (x, 2);\n+      st[3] = \"}\";\n+      break;\n     case MULT:\n       op[0] = XEXP (x, 0);\n       st[1] = \"*\";\n@@ -203,66 +212,34 @@ print_exp (char *buf, const_rtx x, int verbose)\n       st[1] = \">->\";\n       op[1] = XEXP (x, 1);\n       break;\n-    case ABS:\n-      fun = \"abs\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case SQRT:\n-      fun = \"sqrt\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case FFS:\n-      fun = \"ffs\";\n-      op[0] = XEXP (x, 0);\n-      break;\n-    case EQ:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"==\";\n-      op[1] = XEXP (x, 1);\n-      break;\n     case NE:\n       op[0] = XEXP (x, 0);\n       st[1] = \"!=\";\n       op[1] = XEXP (x, 1);\n       break;\n-    case GT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \">\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case GTU:\n-      fun = \"gtu\";\n-      op[0] = XEXP (x, 0);\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LT:\n-      op[0] = XEXP (x, 0);\n-      st[1] = \"<\";\n-      op[1] = XEXP (x, 1);\n-      break;\n-    case LTU:\n-      fun = \"ltu\";\n+    case EQ:\n       op[0] = XEXP (x, 0);\n+      st[1] = \"==\";\n       op[1] = XEXP (x, 1);\n       break;\n     case GE:\n       op[0] = XEXP (x, 0);\n       st[1] = \">=\";\n       op[1] = XEXP (x, 1);\n       break;\n-    case GEU:\n-      fun = \"geu\";\n+    case GT:\n       op[0] = XEXP (x, 0);\n+      st[1] = \">\";\n       op[1] = XEXP (x, 1);\n       break;\n     case LE:\n       op[0] = XEXP (x, 0);\n       st[1] = \"<=\";\n       op[1] = XEXP (x, 1);\n       break;\n-    case LEU:\n-      fun = \"leu\";\n+    case LT:\n       op[0] = XEXP (x, 0);\n+      st[1] = \"<\";\n       op[1] = XEXP (x, 1);\n       break;\n     case SIGN_EXTRACT:\n@@ -390,8 +367,33 @@ print_exp (char *buf, const_rtx x, int verbose)\n       }\n       break;\n     default:\n-      /* If (verbose) debug_rtx (x);  */\n-      st[0] = GET_RTX_NAME (GET_CODE (x));\n+      {\n+\t/* Most unhandled codes can be printed as pseudo-functions.  */\n+        if (GET_RTX_CLASS (GET_CODE (x)) == RTX_UNARY)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t  }\n+        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_COMPARE\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_COMPARE\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_BIN_ARITH\n+\t\t || GET_RTX_CLASS (GET_CODE (x)) == RTX_COMM_ARITH)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t    op[1] = XEXP (x, 1);\n+\t  }\n+        else if (GET_RTX_CLASS (GET_CODE (x)) == RTX_TERNARY)\n+\t  {\n+\t    fun = GET_RTX_NAME (GET_CODE (x));\n+\t    op[0] = XEXP (x, 0);\n+\t    op[1] = XEXP (x, 1);\n+\t    op[2] = XEXP (x, 2);\n+\t  }\n+\telse\n+\t  /* Give up, just print the RTX name.  */\n+\t  st[0] = GET_RTX_NAME (GET_CODE (x));\n+      }\n       break;\n     }\n \n@@ -559,10 +561,9 @@ print_pattern (char *buf, const_rtx x, int verbose)\n       sprintf (buf, \"%s=%s\", t1, t2);\n       break;\n     case RETURN:\n-      sprintf (buf, \"return\");\n-      break;\n     case SIMPLE_RETURN:\n-      sprintf (buf, \"simple_return\");\n+    case EH_RETURN:\n+      sprintf (buf, GET_RTX_NAME (GET_CODE (x)));\n       break;\n     case CALL:\n       print_exp (buf, x, verbose);\n@@ -774,7 +775,7 @@ dump_insn_slim (FILE *f, const_rtx x)\n     for (note = REG_NOTES (x); note; note = XEXP (note, 1))\n       {\n \tfputs (print_rtx_head, f);\n-        print_value (t, XEXP (note, 0), 1);\n+        print_pattern (t, XEXP (note, 0), 1);\n \tfprintf (f, \"      %s: %s\\n\",\n \t\t GET_REG_NOTE_NAME (REG_NOTE_KIND (note)), t);\n       }"}]}