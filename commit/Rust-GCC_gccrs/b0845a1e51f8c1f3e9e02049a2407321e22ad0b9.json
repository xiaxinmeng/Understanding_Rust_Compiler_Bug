{"sha": "b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjA4NDVhMWU1MWY4YzFmM2U5ZTAyMDQ5YTI0MDczMjFlMjJhZDBiOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-30T02:45:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-04-30T02:45:54Z"}, "message": "dwarf2out.c (gen_type_die_with_usage): Call verify_type.\n\n\t* dwarf2out.c (gen_type_die_with_usage): Call verify_type.\n\t* ipa-chkp.c (chkp_copy_function_type_adding_bounds): Do not produce\n\tbugus variants.\n\t* tree.c: Include print-tree.h and ipa-utils.h\n\t(free_lang_data_in_type): Clear TYPE_VFIELD leaked by C FE.\n\t(free_lang_data_in_cgraph): Call verify_type.\n\t(verify_type_variant): New function.\n\t(verify_type): New function.\n\t* tree.h (verify_type): Declare.\n\n\t* lto.c (lto_fixup_state): Call verify_type.\n\nFrom-SVN: r222606", "tree": {"sha": "c055c1c170c01ef4e61d0784cef0bc2b574383cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c055c1c170c01ef4e61d0784cef0bc2b574383cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/comments", "author": null, "committer": null, "parents": [{"sha": "e022edafa0e797ed9c15663e083bbaa3f4b8dff7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e022edafa0e797ed9c15663e083bbaa3f4b8dff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e022edafa0e797ed9c15663e083bbaa3f4b8dff7"}], "stats": {"total": 208, "additions": 192, "deletions": 16}, "files": [{"sha": "9dae922f5fcb805c9fd4e59eb20b9b227f43f4bd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -1,3 +1,15 @@\n+2015-04-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* dwarf2out.c (gen_type_die_with_usage): Call verify_type.\n+\t* ipa-chkp.c (chkp_copy_function_type_adding_bounds): Do not produce\n+\tbugus variants.\n+\t* tree.c: Include print-tree.h and ipa-utils.h\n+\t(free_lang_data_in_type): Clear TYPE_VFIELD leaked by C FE.\n+\t(free_lang_data_in_cgraph): Call verify_type.\n+\t(verify_type_variant): New function.\n+\t(verify_type): New function.\n+\t* tree.h (verify_type): Declare.\n+\n 2015-04-29  Steve Ellcey  <sellcey@imgtec.com>\n \n \t* config/mips/mips-cpus.def: (mips4): Change default processor"}, {"sha": "8d5c062a315c5f8b7c70cdc8b2517aa14c5e0562", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -20238,6 +20238,11 @@ gen_type_die_with_usage (tree type, dw_die_ref context_die,\n   if (type == NULL_TREE || type == error_mark_node)\n     return;\n \n+#ifdef ENABLE_CHECKING\n+  if (type)\n+     verify_type (type);\n+#endif\n+\n   if (TYPE_NAME (type) != NULL_TREE\n       && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n       && is_redundant_typedef (TYPE_NAME (type))"}, {"sha": "23e08cbfc6f55a13657af0c84f23b7a4d2060441", "filename": "gcc/ipa-chkp.c", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Fipa-chkp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Fipa-chkp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-chkp.c?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -244,7 +244,7 @@ tree\n chkp_copy_function_type_adding_bounds (tree orig_type)\n {\n   tree type;\n-  tree arg_type, attrs, t;\n+  tree arg_type, attrs;\n   unsigned len = list_length (TYPE_ARG_TYPES (orig_type));\n   unsigned *indexes = XALLOCAVEC (unsigned, len);\n   unsigned idx = 0, new_idx = 0;\n@@ -327,20 +327,6 @@ chkp_copy_function_type_adding_bounds (tree orig_type)\n       TYPE_ATTRIBUTES (type) = attrs;\n     }\n \n-  t = TYPE_MAIN_VARIANT (orig_type);\n-  if (orig_type != t)\n-    {\n-      TYPE_MAIN_VARIANT (type) = t;\n-      TYPE_NEXT_VARIANT (type) = TYPE_NEXT_VARIANT (t);\n-      TYPE_NEXT_VARIANT (t) = type;\n-    }\n-  else\n-    {\n-      TYPE_MAIN_VARIANT (type) = type;\n-      TYPE_NEXT_VARIANT (type) = NULL;\n-    }\n-\n-\n   return type;\n }\n "}, {"sha": "ff8a213ab62c24ed85c5e93989243a077f63cbd9", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -1,6 +1,10 @@\n+2015-04-29  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto.c (lto_fixup_state): Call verify_type.\n+\n 2015-04-18  Trevor Saunders  <tsaunders@mozilla.com>\n \n-\t* \tlto.c: Adjust for hash_table changes.\n+\t* lto.c: Adjust for hash_table changes.\n \n 2015-03-27  Jan Hubicka  <hubicka@ucw.cz>\n "}, {"sha": "4b4005b4b36a5e2a7afd1e92beca8f8553587751", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -2844,6 +2844,10 @@ lto_fixup_state (struct lto_in_decl_state *state)\n       for (i = 0; i < vec_safe_length (trees); i++)\n \t{\n \t  tree t = (*trees)[i];\n+#ifdef ENABLE_CHECKING\n+\t  if (TYPE_P (t))\n+\t    verify_type (t);\n+#endif\n \t  if (VAR_OR_FUNCTION_DECL_P (t)\n \t      && (TREE_PUBLIC (t) || DECL_EXTERNAL (t)))\n \t    (*trees)[i] = lto_symtab_prevailing_decl (t);"}, {"sha": "a597d52ab7a0a91408e13cb717c1f858e00580dd", "filename": "gcc/tree.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -102,6 +102,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"debug.h\"\n #include \"intl.h\"\n #include \"builtins.h\"\n+#include \"print-tree.h\"\n+#include \"ipa-utils.h\"\n \n /* Tree code classes.  */\n \n@@ -5077,6 +5079,11 @@ free_lang_data_in_type (tree type)\n       else\n \tTYPE_FIELDS (type) = NULL_TREE;\n \n+      /* FIXME: C FE uses TYPE_VFIELD to record C_TYPE_INCOMPLETE_VARS\n+ \t and danagle the pointer from time to time.  */\n+      if (TYPE_VFIELD (type) && TREE_CODE (TYPE_VFIELD (type)) != FIELD_DECL)\n+        TYPE_VFIELD (type) = NULL_TREE;\n+\n       TYPE_METHODS (type) = NULL_TREE;\n       if (TYPE_BINFO (type))\n \t{\n@@ -5784,6 +5791,10 @@ free_lang_data_in_cgraph (void)\n   /* Traverse every type found freeing its language data.  */\n   FOR_EACH_VEC_ELT (fld.types, i, t)\n     free_lang_data_in_type (t);\n+#ifdef ENABLE_CHECKING\n+  FOR_EACH_VEC_ELT (fld.types, i, t)\n+    verify_type (t);\n+#endif\n \n   delete fld.pset;\n   fld.worklist.release ();\n@@ -12425,4 +12436,157 @@ element_mode (const_tree t)\n   return TYPE_MODE (t);\n }\n \n+/* Veirfy that basic properties of T match TV and thus T can be a variant of\n+   TV.  TV should be the more specified variant (i.e. the main variant).  */\n+\n+static bool\n+verify_type_variant (const_tree t, tree tv)\n+{\n+  if (TREE_CODE (t) != TREE_CODE (tv))\n+    {\n+      error (\"type variant has different TREE_CODE\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  if (COMPLETE_TYPE_P (t) && TYPE_SIZE (t) != TYPE_SIZE (tv))\n+    {\n+      error (\"type variant has different TYPE_SIZE\");\n+      debug_tree (tv);\n+      error (\"type variant's TYPE_SIZE\");\n+      debug_tree (TYPE_SIZE (tv));\n+      error (\"type's TYPE_SIZE\");\n+      debug_tree (TYPE_SIZE (t));\n+      return false;\n+    }\n+  if (COMPLETE_TYPE_P (t)\n+      && TYPE_SIZE_UNIT (t) != TYPE_SIZE_UNIT (tv)\n+      /* FIXME: ideally we should compare pointer equality, but java FE produce\n+ \t variants where size is INTEGER_CST of different type (int wrt size_type)\n+\t during libjava biuld.  */\n+      && !operand_equal_p (TYPE_SIZE_UNIT (t), TYPE_SIZE_UNIT (tv), 0))\n+    {\n+      error (\"type variant has different TYPE_SIZE_UNIT\");\n+      debug_tree (tv);\n+      error (\"type variant's TYPE_SIZE_UNIT\");\n+      debug_tree (TYPE_SIZE_UNIT (tv));\n+      error (\"type's TYPE_SIZE_UNIT\");\n+      debug_tree (TYPE_SIZE_UNIT (t));\n+      return false;\n+    }\n+  /* FIXME: C FE uses TYPE_VFIELD to record C_TYPE_INCOMPLETE_VARS\n+     and danagle the pointer from time to time.  */\n+  if (RECORD_OR_UNION_TYPE_P (t) && TYPE_VFIELD (t) != TYPE_VFIELD (tv)\n+      && (!TYPE_VFIELD (tv) || TREE_CODE (TYPE_VFIELD (tv)) != TREE_LIST))\n+    {\n+      error (\"type variant has different TYPE_VFIELD\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  if (((TREE_CODE (t) == ENUMERAL_TYPE && COMPLETE_TYPE_P (t))\n+\t|| TREE_CODE (t) == INTEGER_TYPE\n+\t|| TREE_CODE (t) == BOOLEAN_TYPE\n+\t|| TREE_CODE (t) == REAL_TYPE\n+\t|| TREE_CODE (t) == FIXED_POINT_TYPE)\n+       && (TYPE_MAX_VALUE (t) != TYPE_MAX_VALUE (tv)\n+\t   || TYPE_MIN_VALUE (t) != TYPE_MIN_VALUE (tv)))\n+    {\n+      error (\"type variant has different TYPE_MAX_VALUE or TYPE_MIN_VALUE\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  if (TREE_CODE (t) == METHOD_TYPE\n+      && TYPE_METHOD_BASETYPE (t) != TYPE_METHOD_BASETYPE (tv))\n+    {\n+      error (\"type variant has different TYPE_METHOD_BASETYPE\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  /* FIXME: this check triggers during libstdc++ build that is a bug.\n+     It affects non-LTO debug output only, because free_lang_data clears\n+     this anyway.  */\n+  if (RECORD_OR_UNION_TYPE_P (t) && COMPLETE_TYPE_P (t) && 0\n+      && TYPE_METHODS (t) != TYPE_METHODS (tv))\n+    {\n+      error (\"type variant has different TYPE_METHODS\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  if (TREE_CODE (t) == OFFSET_TYPE\n+      && TYPE_OFFSET_BASETYPE (t) != TYPE_OFFSET_BASETYPE (tv))\n+    {\n+      error (\"type variant has different TYPE_OFFSET_BASETYPE\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  if (TREE_CODE (t) == ARRAY_TYPE\n+      && TYPE_ARRAY_MAX_SIZE (t) != TYPE_ARRAY_MAX_SIZE (tv))\n+    {\n+      error (\"type variant has different TYPE_ARRAY_MAX_SIZE\");\n+      debug_tree (tv);\n+      return false;\n+    }\n+  /* FIXME: Be lax and allow TYPE_BINFO to be missing in variant types\n+     or even type's main variant.  This is needed to make bootstrap pass\n+     and the bug seems new in GCC 5.\n+     C++ FE should be updated to make this consistent and we should check\n+     that TYPE_BINFO is always NULL for !COMPLETE_TYPE_P and otherwise there\n+     is a match with main variant.\n+\n+     Also disable the check for Java for now because of parser hack that builds\n+     first an dummy BINFO and then sometimes replace it by real BINFO in some\n+     of the copies.  */\n+  if (RECORD_OR_UNION_TYPE_P (t) && TYPE_BINFO (t) && TYPE_BINFO (tv)\n+      && TYPE_BINFO (t) != TYPE_BINFO (tv)\n+      /* FIXME: Java sometimes keep dump TYPE_BINFOs on variant types.\n+\t Since there is no cheap way to tell C++/Java type w/o LTO, do checking\n+\t at LTO time only.  */\n+      && (in_lto_p && odr_type_p (t)))\n+    {\n+      error (\"type variant has different TYPE_BINFO\");\n+      debug_tree (tv);\n+      error (\"type variant's TYPE_BINFO\");\n+      debug_tree (TYPE_BINFO (tv));\n+      error (\"type's TYPE_BINFO\");\n+      debug_tree (TYPE_BINFO (t));\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Verify type T.  */\n+\n+void\n+verify_type (const_tree t)\n+{\n+  bool error_found = false;\n+  tree mv = TYPE_MAIN_VARIANT (t);\n+  if (!mv)\n+    {\n+      error (\"Main variant is not defined\");\n+      error_found = true;\n+    }\n+  else if (mv != TYPE_MAIN_VARIANT (mv))\n+    {\n+      error (\"TYPE_MAIN_VARIANT has different TYPE_MAIN_VARIANT\");\n+      debug_tree (mv);\n+      error_found = true;\n+    }\n+  else if (t != mv && !verify_type_variant (t, mv))\n+    error_found = true;\n+  /* FIXME: C FE uses TYPE_VFIELD to record C_TYPE_INCOMPLETE_VARS\n+     and danagle the pointer from time to time.  */\n+  if (RECORD_OR_UNION_TYPE_P (t) && TYPE_VFIELD (t)\n+      && TREE_CODE (TYPE_VFIELD (t)) != FIELD_DECL\n+      && TREE_CODE (TYPE_VFIELD (t)) != TREE_LIST)\n+    {\n+      error (\"TYPE_VFIELD is not FIELD_DECL nor TREE_LIST\");\n+      debug_tree (TYPE_VFIELD (t));\n+    }\n+  if (error_found)\n+    {\n+      debug_tree (const_cast <tree> (t));\n+      internal_error (\"verify_type failed\");\n+    }\n+}\n+\n #include \"gt-tree.h\""}, {"sha": "19741869b4820d78f45ddaf566254c2d9d928af8", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b0845a1e51f8c1f3e9e02049a2407321e22ad0b9/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b0845a1e51f8c1f3e9e02049a2407321e22ad0b9", "patch": "@@ -4501,6 +4501,7 @@ extern tree drop_tree_overflow (tree);\n extern int tree_map_base_eq (const void *, const void *);\n extern unsigned int tree_map_base_hash (const void *);\n extern int tree_map_base_marked_p (const void *);\n+extern void DEBUG_FUNCTION verify_type (const_tree t);\n \n #define tree_map_eq tree_map_base_eq\n extern unsigned int tree_map_hash (const void *);"}]}