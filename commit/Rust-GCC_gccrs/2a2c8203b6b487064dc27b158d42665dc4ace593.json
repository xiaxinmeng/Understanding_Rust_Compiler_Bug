{"sha": "2a2c8203b6b487064dc27b158d42665dc4ace593", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmEyYzgyMDNiNmI0ODcwNjRkYzI3YjE1OGQ0MjY2NWRjNGFjZTU5Mw==", "commit": {"author": {"name": "John F. Carr", "email": "jfc@mit.edu", "date": "1997-08-22T06:39:29Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-22T06:39:29Z"}, "message": "alias.c (find_base_value): Improve handling of PLUS, MINUS, and LO_SUM.\n\n        * alias.c (find_base_value): Improve handling of PLUS, MINUS, and\n        LO_SUM.\n        (record_set): Handle LO_SUM like PLUS.\n        (init_alias_analysis): When following chains of base addresses,\n        do not stop on reaching a hard register.\nUpdates from jfc.\n\nFrom-SVN: r14888", "tree": {"sha": "3a6143645c46dbc5a02af990a7a7f78fb5a6b3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a6143645c46dbc5a02af990a7a7f78fb5a6b3e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a2c8203b6b487064dc27b158d42665dc4ace593", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2c8203b6b487064dc27b158d42665dc4ace593", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a2c8203b6b487064dc27b158d42665dc4ace593", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a2c8203b6b487064dc27b158d42665dc4ace593/comments", "author": {"login": "VoxSciurorum", "id": 60116679, "node_id": "MDQ6VXNlcjYwMTE2Njc5", "avatar_url": "https://avatars.githubusercontent.com/u/60116679?v=4", "gravatar_id": "", "url": "https://api.github.com/users/VoxSciurorum", "html_url": "https://github.com/VoxSciurorum", "followers_url": "https://api.github.com/users/VoxSciurorum/followers", "following_url": "https://api.github.com/users/VoxSciurorum/following{/other_user}", "gists_url": "https://api.github.com/users/VoxSciurorum/gists{/gist_id}", "starred_url": "https://api.github.com/users/VoxSciurorum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/VoxSciurorum/subscriptions", "organizations_url": "https://api.github.com/users/VoxSciurorum/orgs", "repos_url": "https://api.github.com/users/VoxSciurorum/repos", "events_url": "https://api.github.com/users/VoxSciurorum/events{/privacy}", "received_events_url": "https://api.github.com/users/VoxSciurorum/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d80357b7048ff36da6f7fc7d19d9e8dabc4af939", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d80357b7048ff36da6f7fc7d19d9e8dabc4af939", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d80357b7048ff36da6f7fc7d19d9e8dabc4af939"}], "stats": {"total": 109, "additions": 66, "deletions": 43}, "files": [{"sha": "1b1ea0916098a9686b4298b79b9fc3c042299b3a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2c8203b6b487064dc27b158d42665dc4ace593/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2c8203b6b487064dc27b158d42665dc4ace593/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a2c8203b6b487064dc27b158d42665dc4ace593", "patch": "@@ -1,3 +1,11 @@\n+Thu Aug 21 23:52:16 1997  John F. Carr  <jfc@mit.edu>\n+\n+\t* alias.c (find_base_value): Improve handling of PLUS, MINUS, and\n+\tLO_SUM.\n+\t(record_set): Handle LO_SUM like PLUS.\n+\t(init_alias_analysis): When following chains of base addresses,\n+\tdo not stop on reaching a hard register.\n+\n Thu Aug 21 20:17:37 1997  Jeffrey A Law  (law@cygnus.com)\n \n \t* version.c: Bump for new snapshot."}, {"sha": "225d254b515a2a536655e6aca4e7cb5d47700051", "filename": "gcc/alias.c", "status": "modified", "additions": 58, "deletions": 43, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a2c8203b6b487064dc27b158d42665dc4ace593/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a2c8203b6b487064dc27b158d42665dc4ace593/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=2a2c8203b6b487064dc27b158d42665dc4ace593", "patch": "@@ -40,9 +40,17 @@ static int memrefs_conflict_p\t\tPROTO((int, rtx, int, rtx,\n    If all sets after the first add or subtract to the current value\n    or otherwise modify it so it does not point to a different top level\n    object, reg_base_value[N] is equal to the address part of the source\n-   of the first set.  The value will be a SYMBOL_REF, a LABEL_REF, or\n-   (address (reg)) to indicate that the address is derived from an\n-   argument or fixed register.  */\n+   of the first set.\n+\n+   A base address can be an ADDRESS, SYMBOL_REF, or LABEL_REF.  ADDRESS\n+   expressions represent certain special values: function arguments and\n+   the stack, frame, and argument pointers.  The contents of an address\n+   expression are not used (but they are descriptive for debugging);\n+   only the address and mode matter.  Pointer equality, not rtx_equal_p,\n+   determines whether two ADDRESS expressions refer to the same base\n+   address.  The mode determines whether it is a function argument or\n+   other special value. */\n+\n rtx *reg_base_value;\n unsigned int reg_base_value_size;\t/* size of reg_base_value array */\n #define REG_BASE_VALUE(X) \\\n@@ -68,14 +76,13 @@ static int reg_known_value_size;\n    here.  */\n char *reg_known_equiv_p;\n \n-/* Inside SRC, the source of a SET, find a base address.  */\n+/* True when scanning insns from the start of the rtl to the\n+   NOTE_INSN_FUNCTION_BEG note.  */\n \n-/* When copying arguments into pseudo-registers, record the (ADDRESS)\n-   expression for the argument directly so that even if the argument\n-   register is changed later (e.g. for a function call) the original\n-   value is noted.  */\n static int copying_arguments;\n \n+/* Inside SRC, the source of a SET, find a base address.  */\n+\n static rtx\n find_base_value (src)\n      register rtx src;\n@@ -87,7 +94,11 @@ find_base_value (src)\n       return src;\n \n     case REG:\n-      if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n+      /* At the start of a function argument registers have known base\n+\t values which may be lost later.  Returning an ADDRESS\n+\t expression here allows optimization based on argument values\n+\t even when the argument registers are used for other purposes.  */\n+      if (REGNO (src) < FIRST_PSEUDO_REGISTER && copying_arguments)\n \treturn reg_base_value[REGNO (src)];\n       return src;\n \n@@ -107,43 +118,48 @@ find_base_value (src)\n       if (GET_CODE (src) != PLUS && GET_CODE (src) != MINUS)\n \tbreak;\n       /* fall through */\n+\n     case PLUS:\n     case MINUS:\n-      /* Guess which operand to set the register equivalent to.  */\n-      /* If the first operand is a symbol or the second operand is\n-\t an integer, the first operand is the base address.  */\n-      if (GET_CODE (XEXP (src, 0)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (src, 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (src, 1)) == CONST_INT)\n-\treturn XEXP (src, 0);\n-      /* If an operand is a register marked as a pointer, it is the base.  */\n-      if (GET_CODE (XEXP (src, 0)) == REG\n-\t  && REGNO_POINTER_FLAG (REGNO (XEXP (src, 0))))\n-\tsrc = XEXP (src, 0);\n-      else if (GET_CODE (XEXP (src, 1)) == REG\n-\t  && REGNO_POINTER_FLAG (REGNO (XEXP (src, 1))))\n-\tsrc = XEXP (src, 1);\n-      else\n+      {\n+\trtx src_0 = XEXP (src, 0), src_1 = XEXP (src, 1);\n+\n+\t/* Guess which operand is the base address.\n+\n+\t   If the first operand is a symbol or the second operand is\n+\t   an integer, the first operand is the base address.  Else if\n+\t   either operand is a register marked as a pointer, it is the\n+\t   base address.  */\n+\n+\tif (GET_CODE (src_1) == CONST_INT\n+\t    || GET_CODE (src_0) == SYMBOL_REF\n+\t    || GET_CODE (src_0) == LABEL_REF\n+\t    || GET_CODE (src_0) == CONST)\n+\t  return find_base_value (src_0);\n+\n+\tif (GET_CODE (src_0) == REG && REGNO_POINTER_FLAG (REGNO (src_0)))\n+\t  return find_base_value (src_0);\n+\n+\tif (GET_CODE (src_1) == REG && REGNO_POINTER_FLAG (REGNO (src_1)))\n+\t  return find_base_value (src_1);\n+\n \treturn 0;\n-      if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\treturn reg_base_value[REGNO (src)];\n-      return src;\n+      }\n+\n+    case LO_SUM:\n+      /* The standard form is (lo_sum reg sym) so look only at the\n+\t second operand.  */\n+      return find_base_value (XEXP (src, 1));\n \n     case AND:\n       /* If the second operand is constant set the base\n \t address to the first operand. */\n-      if (GET_CODE (XEXP (src, 1)) == CONST_INT\n-\t  && GET_CODE (XEXP (src, 0)) == REG)\n-\t{\n-\t  src = XEXP (src, 0);\n-\t  if (copying_arguments && REGNO (src) < FIRST_PSEUDO_REGISTER)\n-\t    return reg_base_value[REGNO (src)];\n-\t  return src;\n-\t}\n+      if (GET_CODE (XEXP (src, 1)) == CONST_INT && INTVAL (XEXP (src, 1)) != 0)\n+\treturn find_base_value (XEXP (src, 0));\n       return 0;\n \n     case HIGH:\n-      return XEXP (src, 0);\n+      return find_base_value (XEXP (src, 0));\n     }\n \n   return 0;\n@@ -155,8 +171,8 @@ find_base_value (src)\n    register N has been set in this function.  */\n static char *reg_seen;\n \n-static\n-void record_set (dest, set)\n+static void\n+record_set (dest, set)\n      rtx dest, set;\n {\n   register int regno;\n@@ -202,6 +218,7 @@ void record_set (dest, set)\n   if (reg_base_value[regno])\n     switch (GET_CODE (src))\n       {\n+      case LO_SUM:\n       case PLUS:\n       case MINUS:\n \tif (XEXP (src, 0) != dest && XEXP (src, 1) != dest)\n@@ -211,10 +228,6 @@ void record_set (dest, set)\n \tif (XEXP (src, 0) != dest || GET_CODE (XEXP (src, 1)) != CONST_INT)\n \t  reg_base_value[regno] = 0;\n \tbreak;\n-      case LO_SUM:\n-\tif (XEXP (src, 0) != dest)\n-\t  reg_base_value[regno] = 0;\n-\tbreak;\n       default:\n \treg_base_value[regno] = 0;\n \tbreak;\n@@ -931,8 +944,10 @@ init_alias_analysis ()\n \t= gen_rtx (ADDRESS, Pmode, arg_pointer_rtx);\n       reg_base_value[FRAME_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, frame_pointer_rtx);\n+#if HARD_FRAME_POINTER_REGNUM != FRAME_POINTER_REGNUM\n       reg_base_value[HARD_FRAME_POINTER_REGNUM]\n \t= gen_rtx (ADDRESS, Pmode, hard_frame_pointer_rtx);\n+#endif\n     }\n \n   copying_arguments = 1;\n@@ -947,7 +962,7 @@ init_alias_analysis ()\n \t  rtx noalias_note;\n \t  if (GET_CODE (PATTERN (insn)) == SET\n \t      && (noalias_note = find_reg_note (insn, REG_NOALIAS, NULL_RTX)))\n-\t      record_set (SET_DEST (PATTERN (insn)), 0);\n+\t    record_set (SET_DEST (PATTERN (insn)), 0);\n \t  else\n \t    note_stores (PATTERN (insn), record_set);\n \t}"}]}