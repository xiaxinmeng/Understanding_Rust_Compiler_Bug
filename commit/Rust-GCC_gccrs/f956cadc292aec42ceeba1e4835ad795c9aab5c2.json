{"sha": "f956cadc292aec42ceeba1e4835ad795c9aab5c2", "node_id": "C_kwDOANBUbNoAKGY5NTZjYWRjMjkyYWVjNDJjZWViYTFlNDgzNWFkNzk1YzlhYWI1YzI", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-31T19:09:10Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-08-31T19:09:10Z"}, "message": "libstdc++: Implement ranges::adjacent_view from P2321R2\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/ranges (adjacent_view): Define.\n\t(enable_borrowed_range<adjacent_view>): Define.\n\t(__detail::__repeated_tuple): Define.\n\t(adjacent_view::_Iterator): Define.\n\t(adjacent_view::_Sentinel): Define.\n\t(views::__detail::__can_adjacent_view): Define.\n\t(views::_Adjacent): Define.\n\t(views::adjacent): Define.\n\t(views::pairwise): Define.\n\t* testsuite/std/ranges/adaptors/adjacent/1.cc: New test.", "tree": {"sha": "de02195a2e2bd37472d6ff5d5198d3e3ec909ef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de02195a2e2bd37472d6ff5d5198d3e3ec909ef4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f956cadc292aec42ceeba1e4835ad795c9aab5c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f956cadc292aec42ceeba1e4835ad795c9aab5c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f956cadc292aec42ceeba1e4835ad795c9aab5c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f956cadc292aec42ceeba1e4835ad795c9aab5c2/comments", "author": null, "committer": null, "parents": [{"sha": "4d5660907c2b4c301fcbdc3dc713879fa31afec0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d5660907c2b4c301fcbdc3dc713879fa31afec0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d5660907c2b4c301fcbdc3dc713879fa31afec0"}], "stats": {"total": 468, "additions": 468, "deletions": 0}, "files": [{"sha": "2352aad76fc6d734ea27a1c75f79ccfedba5f693", "filename": "libstdc++-v3/include/std/ranges", "status": "modified", "additions": 358, "deletions": 0, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f956cadc292aec42ceeba1e4835ad795c9aab5c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f956cadc292aec42ceeba1e4835ad795c9aab5c2/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Franges?ref=f956cadc292aec42ceeba1e4835ad795c9aab5c2", "patch": "@@ -5081,6 +5081,364 @@ namespace views::__adaptor\n \n     inline constexpr _ZipTransform zip_transform;\n   }\n+\n+  template<forward_range _Vp, size_t _Nm>\n+    requires view<_Vp> && (_Nm > 0)\n+  class adjacent_view : public view_interface<adjacent_view<_Vp, _Nm>>\n+  {\n+    _Vp _M_base = _Vp();\n+\n+    template<bool> class _Iterator;\n+    template<bool> class _Sentinel;\n+\n+    struct __as_sentinel\n+    { };\n+\n+  public:\n+    adjacent_view() requires default_initializable<_Vp> = default;\n+\n+    constexpr explicit\n+    adjacent_view(_Vp __base)\n+      : _M_base(std::move(__base))\n+    { }\n+\n+    constexpr auto\n+    begin() requires (!__detail::__simple_view<_Vp>)\n+    { return _Iterator<false>(ranges::begin(_M_base), ranges::end(_M_base)); }\n+\n+    constexpr auto\n+    begin() const requires range<const _Vp>\n+    { return _Iterator<true>(ranges::begin(_M_base), ranges::end(_M_base)); }\n+\n+    constexpr auto\n+    end() requires (!__detail::__simple_view<_Vp>)\n+    {\n+      if constexpr (common_range<_Vp>)\n+\treturn _Iterator<false>(__as_sentinel{}, ranges::begin(_M_base), ranges::end(_M_base));\n+      else\n+\treturn _Sentinel<false>(ranges::end(_M_base));\n+    }\n+\n+    constexpr auto\n+    end() const requires range<const _Vp>\n+    {\n+      if constexpr (common_range<const _Vp>)\n+\treturn _Iterator<true>(__as_sentinel{}, ranges::begin(_M_base), ranges::end(_M_base));\n+      else\n+\treturn _Sentinel<true>(ranges::end(_M_base));\n+    }\n+\n+    constexpr auto\n+    size() requires sized_range<_Vp>\n+    {\n+      using _ST = decltype(ranges::size(_M_base));\n+      using _CT = common_type_t<_ST, size_t>;\n+      auto __sz = static_cast<_CT>(ranges::size(_M_base));\n+      __sz -= std::min<_CT>(__sz, _Nm - 1);\n+      return static_cast<_ST>(__sz);\n+    }\n+\n+    constexpr auto\n+    size() const requires sized_range<const _Vp>\n+    {\n+      using _ST = decltype(ranges::size(_M_base));\n+      using _CT = common_type_t<_ST, size_t>;\n+      auto __sz = static_cast<_CT>(ranges::size(_M_base));\n+      __sz -= std::min<_CT>(__sz, _Nm - 1);\n+      return static_cast<_ST>(__sz);\n+    }\n+  };\n+\n+  template<typename _Vp, size_t _Nm>\n+    inline constexpr bool enable_borrowed_range<adjacent_view<_Vp, _Nm>>\n+      = enable_borrowed_range<_Vp>;\n+\n+  namespace __detail\n+  {\n+    // Yields tuple<_Tp, ..., _Tp> with _Nm elements.\n+    template<typename _Tp, size_t _Nm>\n+      using __repeated_tuple = decltype(std::tuple_cat(std::declval<array<_Tp, _Nm>>()));\n+  }\n+\n+  template<forward_range _Vp, size_t _Nm>\n+    requires view<_Vp> && (_Nm > 0)\n+  template<bool _Const>\n+  class adjacent_view<_Vp, _Nm>::_Iterator\n+  {\n+    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+    array<iterator_t<_Base>, _Nm> _M_current = array<iterator_t<_Base>, _Nm>();\n+\n+    constexpr\n+    _Iterator(iterator_t<_Base> __first, sentinel_t<_Base> __last)\n+    {\n+      for (auto& __i : _M_current)\n+\t{\n+\t  __i = __first;\n+\t  ranges::advance(__first, 1, __last);\n+\t}\n+    }\n+\n+    constexpr\n+    _Iterator(__as_sentinel, iterator_t<_Base> __first, iterator_t<_Base> __last)\n+    {\n+      if constexpr (!bidirectional_range<_Base>)\n+\tfor (auto& __it : _M_current)\n+\t  __it = __last;\n+      else\n+\tfor (size_t __i = 0; __i < _Nm; ++__i)\n+\t  {\n+\t    _M_current[_Nm - 1 - __i] = __last;\n+\t    ranges::advance(__last, -1, __first);\n+\t  }\n+    }\n+\n+    static auto\n+    _S_iter_concept()\n+    {\n+      if constexpr (random_access_range<_Base>)\n+\treturn random_access_iterator_tag{};\n+      else if constexpr (bidirectional_range<_Base>)\n+\treturn bidirectional_iterator_tag{};\n+      else\n+\treturn forward_iterator_tag{};\n+    }\n+\n+    friend class adjacent_view;\n+\n+  public:\n+    using iterator_category = input_iterator_tag;\n+    using iterator_concept = decltype(_S_iter_concept());\n+    using value_type = conditional_t<_Nm == 2,\n+\t\t\t\t     pair<range_value_t<_Base>, range_value_t<_Base>>,\n+\t\t\t\t     __detail::__repeated_tuple<range_value_t<_Base>, _Nm>>;\n+    using difference_type = range_difference_t<_Base>;\n+\n+    _Iterator() = default;\n+\n+    constexpr\n+    _Iterator(_Iterator<!_Const> __i)\n+      requires _Const && convertible_to<iterator_t<_Vp>, iterator_t<_Base>>\n+    {\n+      for (size_t __j = 0; __j < _Nm; ++__j)\n+\t_M_current[__j] = std::move(__i[__j]);\n+    }\n+\n+    constexpr auto\n+    operator*() const\n+    {\n+      auto __f = [](auto& __i) -> decltype(auto) { return *__i; };\n+      return __detail::__tuple_transform(__f, _M_current);\n+    }\n+\n+    constexpr _Iterator&\n+    operator++()\n+    {\n+      for (auto& __i : _M_current)\n+\t++__i;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator++(int)\n+    {\n+      auto __tmp = *this;\n+      ++*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator--() requires bidirectional_range<_Base>\n+    {\n+      for (auto& __i : _M_current)\n+\t--__i;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator\n+    operator--(int) requires bidirectional_range<_Base>\n+    {\n+      auto __tmp = *this;\n+      --*this;\n+      return __tmp;\n+    }\n+\n+    constexpr _Iterator&\n+    operator+=(difference_type __x)\n+      requires random_access_range<_Base>\n+    {\n+      for (auto& __i : _M_current)\n+\t__i += __x;\n+      return *this;\n+    }\n+\n+    constexpr _Iterator&\n+    operator-=(difference_type __x)\n+      requires random_access_range<_Base>\n+    {\n+      for (auto& __i : _M_current)\n+\t__i -= __x;\n+      return *this;\n+    }\n+\n+    constexpr auto\n+    operator[](difference_type __n) const\n+      requires random_access_range<_Base>\n+    {\n+      auto __f = [&](auto& __i) -> decltype(auto) { return __i[__n]; };\n+      return __detail::__tuple_transform(__f, _M_current);\n+    }\n+\n+    friend constexpr bool\n+    operator==(const _Iterator& __x, const _Iterator& __y)\n+    { return __x._M_current.back() == __y._M_current.back(); }\n+\n+    friend constexpr bool\n+    operator<(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __x._M_current.back() < __y._M_current.back(); }\n+\n+    friend constexpr bool\n+    operator>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return __y < __x; }\n+\n+    friend constexpr bool\n+    operator<=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return !(__y < __x); }\n+\n+    friend constexpr bool\n+    operator>=(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+    { return !(__x < __y); }\n+\n+    friend constexpr auto\n+    operator<=>(const _Iterator& __x, const _Iterator& __y)\n+      requires random_access_range<_Base>\n+\t&& three_way_comparable<iterator_t<_Base>>\n+    { return __x._M_current.back() <=> __y._M_current.back(); }\n+\n+    friend constexpr _Iterator\n+    operator+(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator+(difference_type __n, const _Iterator& __i)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r = __i;\n+      __r += __n;\n+      return __r;\n+    }\n+\n+    friend constexpr _Iterator\n+    operator-(const _Iterator& __i, difference_type __n)\n+      requires random_access_range<_Base>\n+    {\n+      auto __r = __i;\n+      __r -= __n;\n+      return __r;\n+    }\n+\n+    friend constexpr difference_type\n+    operator-(const _Iterator& __x, const _Iterator& __y)\n+      requires sized_sentinel_for<iterator_t<_Base>, iterator_t<_Base>>\n+    { return __x._M_current.back() - __y._M_current.back(); }\n+\n+    friend constexpr auto\n+    iter_move(const _Iterator& __i)\n+    { return __detail::__tuple_transform(ranges::iter_move, __i._M_current); }\n+\n+    friend constexpr void\n+    iter_swap(const _Iterator& __l, const _Iterator& __r)\n+      requires indirectly_swappable<iterator_t<_Base>>\n+    {\n+      for (size_t __i = 0; __i < _Nm; __i++)\n+\tranges::iter_swap(__l._M_current[__i], __r._M_current[__i]);\n+    }\n+  };\n+\n+  template<forward_range _Vp, size_t _Nm>\n+    requires view<_Vp> && (_Nm > 0)\n+  template<bool _Const>\n+  class adjacent_view<_Vp, _Nm>::_Sentinel\n+  {\n+    using _Base = __detail::__maybe_const_t<_Const, _Vp>;\n+\n+    sentinel_t<_Base> _M_end = sentinel_t<_Base>();\n+\n+    constexpr explicit\n+    _Sentinel(sentinel_t<_Base> __end)\n+      : _M_end(__end)\n+    { }\n+\n+    friend class adjacent_view;\n+\n+  public:\n+    _Sentinel() = default;\n+\n+    constexpr\n+    _Sentinel(_Sentinel<!_Const> __i)\n+      requires _Const && convertible_to<sentinel_t<_Vp>, sentinel_t<_Base>>\n+      : _M_end(std::move(__i._M_end))\n+    { }\n+\n+    template<bool _OtherConst>\n+      requires sentinel_for<sentinel_t<_Base>,\n+\t\t\t    iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n+    friend constexpr bool\n+    operator==(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_current.back() == __y._M_end; }\n+\n+    template<bool _OtherConst>\n+      requires sized_sentinel_for<sentinel_t<_Base>,\n+\t\t\t\t  iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vp>>\n+    operator-(const _Iterator<_OtherConst>& __x, const _Sentinel& __y)\n+    { return __x._M_current.back() - __y._M_end; }\n+\n+    template<bool _OtherConst>\n+      requires sized_sentinel_for<sentinel_t<_Base>,\n+\t\t\t\t  iterator_t<__detail::__maybe_const_t<_OtherConst, _Vp>>>\n+    friend constexpr range_difference_t<__detail::__maybe_const_t<_OtherConst, _Vp>>\n+    operator-(const _Sentinel& __y, const _Iterator<_OtherConst>& __x)\n+    { return __y._M_end - __x._M_current.back(); }\n+  };\n+\n+  namespace views\n+  {\n+    namespace __detail\n+    {\n+      template<size_t _Nm, typename _Range>\n+\tconcept __can_adjacent_view\n+\t  = requires { adjacent_view<all_t<_Range>, _Nm>(std::declval<_Range>()); };\n+    }\n+\n+    template<size_t _Nm>\n+      struct _Adjacent : __adaptor::_RangeAdaptorClosure\n+      {\n+\ttemplate<viewable_range _Range>\n+\t  requires (_Nm == 0) || __detail::__can_adjacent_view<_Nm, _Range>\n+\t  constexpr auto\n+\t  operator() [[nodiscard]] (_Range&& __r) const\n+\t  {\n+\t    if constexpr (_Nm == 0)\n+\t      return views::empty<tuple<>>;\n+\t    else\n+\t      return adjacent_view<all_t<_Range>, _Nm>(std::forward<_Range>(__r));\n+\t  }\n+      };\n+\n+    template<size_t _Nm>\n+      inline constexpr _Adjacent<_Nm> adjacent;\n+\n+    inline constexpr auto pairwise = adjacent<2>;\n+  }\n #endif // C++23\n } // namespace ranges\n "}, {"sha": "9829f79364f3cd2fded6103726d5ef6da027f7e4", "filename": "libstdc++-v3/testsuite/std/ranges/adaptors/adjacent/1.cc", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f956cadc292aec42ceeba1e4835ad795c9aab5c2/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f956cadc292aec42ceeba1e4835ad795c9aab5c2/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Franges%2Fadaptors%2Fadjacent%2F1.cc?ref=f956cadc292aec42ceeba1e4835ad795c9aab5c2", "patch": "@@ -0,0 +1,110 @@\n+// { dg-options \"-std=gnu++23\" }\n+// { dg-do run { target c++23 } }\n+\n+#include <ranges>\n+#include <algorithm>\n+#include <utility>\n+#include <testsuite_hooks.h>\n+#include <testsuite_iterators.h>\n+\n+namespace ranges = std::ranges;\n+namespace views = std::views;\n+\n+constexpr bool\n+test01()\n+{\n+  static_assert(ranges::empty(std::array{1, 2, 3} | views::adjacent<0>));\n+\n+  auto v1 = std::array{1, 2} | views::adjacent<1>;\n+  const auto i0 = v1.begin(), i1 = v1.begin() + 1;\n+  VERIFY( i0 + 1 - 1 == i0 );\n+  VERIFY( i0 < i1 );\n+  VERIFY( i1 < v1.end() );\n+  VERIFY( i1 - i0 == 1 );\n+  VERIFY( i0 - i1 == -1 );\n+  VERIFY( v1.end() - i1 == 1 );\n+  VERIFY( i1 - v1.end() == -1 );\n+  ranges::iter_swap(i0, i1);\n+  VERIFY( ranges::equal(std::move(v1) | views::keys, (int[]){2, 1}) );\n+\n+  int x[] = {1, 2, 3, 4};\n+  auto v2 = x | views::pairwise;\n+  auto i2 = v2.begin();\n+  i2 += 2;\n+  i2 -= -1;\n+  VERIFY( i2 == v2.end() );\n+  VERIFY( ranges::size(v2) == 3 );\n+  VERIFY( ranges::size(std::as_const(v2)) == 3 );\n+  VERIFY( ranges::equal(v2 | views::keys, (int[]){1, 2, 3}) );\n+  VERIFY( ranges::equal(v2 | views::values, (int[]){2, 3, 4}) );\n+\n+  int y[] = {1, 2, 3, 4, 5};\n+  const auto v3 = y | views::adjacent<3>;\n+  VERIFY( ranges::size(v3) == 3 );\n+  for (unsigned i = 0; i < ranges::size(x); i++)\n+    {\n+      VERIFY( &std::get<0>(v3[i]) == &y[i] + 0 );\n+      VERIFY( &std::get<1>(v3[i]) == &y[i] + 1 );\n+      VERIFY( &std::get<2>(v3[i]) == &y[i] + 2 );\n+    }\n+\n+  const auto v5 = y | views::adjacent<5>;\n+  VERIFY( ranges::equal(v5, views::single(std::make_tuple(1, 2, 3, 4, 5))) );\n+\n+  const auto v6 = y | views::adjacent<6>;\n+  VERIFY( ranges::empty(v6) );\n+\n+  const auto v0 = y | views::adjacent<0>;\n+  VERIFY( ranges::empty(v0) );\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test02()\n+{\n+  using __gnu_test::test_input_range;\n+  using __gnu_test::test_forward_range;\n+  using __gnu_test::test_random_access_range;\n+\n+  using ty1 = ranges::adjacent_view<views::all_t<test_forward_range<int>>, 2>;\n+  static_assert(ranges::forward_range<ty1>);\n+  static_assert(!ranges::bidirectional_range<ty1>);\n+  static_assert(!ranges::sized_range<ty1>);\n+\n+  using ty2 = ranges::adjacent_view<views::all_t<test_random_access_range<int>>, 3>;\n+  static_assert(ranges::random_access_range<ty2>);\n+  static_assert(ranges::sized_range<ty2>);\n+\n+  return true;\n+}\n+\n+constexpr bool\n+test03()\n+{\n+  auto v = views::iota(0, 4) | views::filter([](auto) { return true; }) | views::pairwise;\n+  using ty = decltype(v);\n+  static_assert(ranges::forward_range<ty>);\n+  static_assert(ranges::common_range<ty>);\n+  static_assert(!ranges::sized_range<ty>);\n+  VERIFY( v.begin() == v.begin() );\n+  VERIFY( v.begin() != v.end() );\n+  VERIFY( ranges::next(v.begin(), 3) == v.end() );\n+  auto it = v.begin();\n+  ++it;\n+  it++;\n+  VERIFY( ranges::next(it) == v.end() );\n+  it--;\n+  --it;\n+  VERIFY( it == v.begin() );\n+\n+  return true;\n+}\n+\n+int\n+main()\n+{\n+  static_assert(test01());\n+  static_assert(test02());\n+  static_assert(test03());\n+}"}]}