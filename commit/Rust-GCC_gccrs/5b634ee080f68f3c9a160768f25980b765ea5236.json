{"sha": "5b634ee080f68f3c9a160768f25980b765ea5236", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWI2MzRlZTA4MGY2OGYzYzlhMTYwNzY4ZjI1OTgwYjc2NWVhNTIzNg==", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2010-11-16T01:01:57Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2010-11-16T01:01:57Z"}, "message": "gcc.c: Include \"vec.h\".\n\n\t* gcc.c: Include \"vec.h\".\n\t(argbuf): Make into a VEC.\n\t(argbuf_length, argbuf_index): Remove.\n\t(alloc_args, clear_args, store_arg, execute, insert_wrapper,\n\tdo_spec, do_self_spec, do_spec_1, eval_spec_function, main,\n\tcompare_debug_dump_opt_spec_function: Use VEC interfaces on\n\targbuf.\n\t* Makefile.in (GCC_OBJS): Add vec.o and ggc-none.o.\n\t(gcc.o): Depend on $(VEC_H).\n\nFrom-SVN: r166788", "tree": {"sha": "523bcecb3a25e62315fb875ad193792cfb0bde07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/523bcecb3a25e62315fb875ad193792cfb0bde07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5b634ee080f68f3c9a160768f25980b765ea5236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b634ee080f68f3c9a160768f25980b765ea5236", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b634ee080f68f3c9a160768f25980b765ea5236", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b634ee080f68f3c9a160768f25980b765ea5236/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "376fb8380a625e3b67edcdf5e633c422344dbb7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/376fb8380a625e3b67edcdf5e633c422344dbb7e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/376fb8380a625e3b67edcdf5e633c422344dbb7e"}], "stats": {"total": 171, "additions": 89, "deletions": 82}, "files": [{"sha": "a7014850891a2bbae12f51e37dfe004d33cd21cb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5b634ee080f68f3c9a160768f25980b765ea5236", "patch": "@@ -1,3 +1,15 @@\n+2010-11-15  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.c: Include \"vec.h\".\n+\t(argbuf): Make into a VEC.\n+\t(argbuf_length, argbuf_index): Remove.\n+\t(alloc_args, clear_args, store_arg, execute, insert_wrapper,\n+\tdo_spec, do_self_spec, do_spec_1, eval_spec_function, main,\n+\tcompare_debug_dump_opt_spec_function: Use VEC interfaces on\n+\targbuf.\n+\t* Makefile.in (GCC_OBJS): Add vec.o and ggc-none.o.\n+\t(gcc.o): Depend on $(VEC_H).\n+\n 2010-11-15  Richard Henderson  <rth@redhat.com>\n \n \t* loop-unroll.c (analyze_insn_to_expand_var): Accept accumulation"}, {"sha": "ec57cf2448907de3a194396a1ae5f7040d642ca6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=5b634ee080f68f3c9a160768f25980b765ea5236", "patch": "@@ -1137,7 +1137,7 @@ FORTRAN_TARGET_OBJS=@fortran_target_objs@\n \n # Object files for gcc driver.\n GCC_OBJS = gcc.o opts-common.o gcc-options.o diagnostic.o pretty-print.o \\\n-  input.o\n+  input.o vec.o ggc-none.o\n \n # Language-specific object files shared by all C-family front ends.\n C_COMMON_OBJS = c-family/c-common.o c-family/c-cppbuiltin.o c-family/c-dump.o \\\n@@ -2192,7 +2192,7 @@ DRIVER_DEFINES = \\\n \n gcc.o: gcc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) intl.h multilib.h \\\n     Makefile $(lang_specs_files) specs.h prefix.h $(GCC_H) $(FLAGS_H) \\\n-    configargs.h $(OBSTACK_H) $(OPTS_H) $(DIAGNOSTIC_H)\n+    configargs.h $(OBSTACK_H) $(OPTS_H) $(DIAGNOSTIC_H) $(VEC_H)\n \t(SHLIB_LINK='$(SHLIB_LINK)'; \\\n \t$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \\\n   $(DRIVER_DEFINES) \\"}, {"sha": "58f7a31482c0d970ec23c20ad8db24ff4cfdb53e", "filename": "gcc/gcc.c", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5b634ee080f68f3c9a160768f25980b765ea5236/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=5b634ee080f68f3c9a160768f25980b765ea5236", "patch": "@@ -47,6 +47,7 @@ compilation is specified by a string called a \"spec\".  */\n #include \"diagnostic.h\"\n #include \"flags.h\"\n #include \"opts.h\"\n+#include \"vec.h\"\n \n #ifdef HAVE_MMAP_FILE\n # include <sys/mman.h>\n@@ -1503,19 +1504,15 @@ set_spec (const char *name, const char *spec)\n \f\n /* Accumulate a command (program name and args), and run it.  */\n \n-/* Vector of pointers to arguments in the current line of specifications.  */\n-\n-static const char **argbuf;\n-\n-/* Number of elements allocated in argbuf.  */\n+typedef const char *const_char_p; /* For DEF_VEC_P.  */\n+DEF_VEC_P(const_char_p);\n+DEF_VEC_ALLOC_P(const_char_p,heap);\n \n-static int argbuf_length;\n-\n-/* Number of elements in argbuf currently in use (containing args).  */\n+/* Vector of pointers to arguments in the current line of specifications.  */\n \n-static int argbuf_index;\n+static VEC(const_char_p,heap) *argbuf;\n \n-/* Position in the argbuf array containing the name of the output file\n+/* Position in the argbuf vector containing the name of the output file\n    (the value associated with the \"-o\" flag).  */\n \n static int have_o_argbuf_index = 0;\n@@ -1552,16 +1549,15 @@ static int signal_count;\n static void\n alloc_args (void)\n {\n-  argbuf_length = 10;\n-  argbuf = XNEWVEC (const char *, argbuf_length);\n+  argbuf = VEC_alloc (const_char_p, heap, 10);\n }\n \n /* Clear out the vector of arguments (after a command is executed).  */\n \n static void\n clear_args (void)\n {\n-  argbuf_index = 0;\n+  VEC_truncate (const_char_p, argbuf, 0);\n }\n \n /* Add one argument to the vector at the end.\n@@ -1574,14 +1570,10 @@ clear_args (void)\n static void\n store_arg (const char *arg, int delete_always, int delete_failure)\n {\n-  if (argbuf_index + 1 == argbuf_length)\n-    argbuf = XRESIZEVEC (const char *, argbuf, (argbuf_length *= 2));\n-\n-  argbuf[argbuf_index++] = arg;\n-  argbuf[argbuf_index] = 0;\n+  VEC_safe_push (const_char_p, heap, argbuf, arg);\n \n   if (strcmp (arg, \"-o\") == 0)\n-    have_o_argbuf_index = argbuf_index;\n+    have_o_argbuf_index = VEC_length (const_char_p, argbuf);\n   if (delete_always || delete_failure)\n     {\n       const char *p;\n@@ -2459,21 +2451,24 @@ execute (void)\n     const char *prog;\t\t/* program name.  */\n     const char **argv;\t\t/* vector of args.  */\n   };\n+  const char *arg;\n \n   struct command *commands;\t/* each command buffer with above info.  */\n \n   gcc_assert (!processing_spec_function);\n \n   if (wrapper_string)\n     {\n-      string = find_a_file (&exec_prefixes, argbuf[0], X_OK, false);\n-      argbuf[0] = (string) ? string : argbuf[0];\n+      string = find_a_file (&exec_prefixes,\n+\t\t\t    VEC_index (const_char_p, argbuf, 0), X_OK, false);\n+      if (string)\n+\tVEC_replace (const_char_p, argbuf, 0, string);\n       insert_wrapper (wrapper_string);\n     }\n \n   /* Count # of piped commands.  */\n-  for (n_commands = 1, i = 0; i < argbuf_index; i++)\n-    if (strcmp (argbuf[i], \"|\") == 0)\n+  for (n_commands = 1, i = 0; VEC_iterate (const_char_p, argbuf, i, arg); i++)\n+    if (strcmp (arg, \"|\") == 0)\n       n_commands++;\n \n   /* Get storage for each command.  */\n@@ -2483,33 +2478,35 @@ execute (void)\n      and record info about each one.\n      Also search for the programs that are to be run.  */\n \n-  commands[0].prog = argbuf[0]; /* first command.  */\n-  commands[0].argv = &argbuf[0];\n+  VEC_safe_push (const_char_p, heap, argbuf, 0);\n+\n+  commands[0].prog = VEC_index (const_char_p, argbuf, 0); /* first command.  */\n+  commands[0].argv = VEC_address (const_char_p, argbuf);\n \n   if (!wrapper_string)\n     {\n       string = find_a_file (&exec_prefixes, commands[0].prog, X_OK, false);\n       commands[0].argv[0] = (string) ? string : commands[0].argv[0];\n     }\n \n-  for (n_commands = 1, i = 0; i < argbuf_index; i++)\n-    if (strcmp (argbuf[i], \"|\") == 0)\n+  for (n_commands = 1, i = 0; VEC_iterate (const_char_p, argbuf, i, arg); i++)\n+    if (arg && strcmp (arg, \"|\") == 0)\n       {\t\t\t\t/* each command.  */\n #if defined (__MSDOS__) || defined (OS2) || defined (VMS)\n \tfatal_error (\"-pipe not supported\");\n #endif\n-\targbuf[i] = 0;\t/* termination of command args.  */\n-\tcommands[n_commands].prog = argbuf[i + 1];\n-\tcommands[n_commands].argv = &argbuf[i + 1];\n+\tVEC_replace (const_char_p, argbuf, i, 0); /* Termination of\n+\t\t\t\t\t\t     command args.  */\n+\tcommands[n_commands].prog = VEC_index (const_char_p, argbuf, i + 1);\n+\tcommands[n_commands].argv\n+\t  = &(VEC_address (const_char_p, argbuf))[i + 1];\n \tstring = find_a_file (&exec_prefixes, commands[n_commands].prog,\n \t\t\t      X_OK, false);\n \tif (string)\n \t  commands[n_commands].argv[0] = string;\n \tn_commands++;\n       }\n \n-  argbuf[argbuf_index] = 0;\n-\n   /* If -v, print what we are about to do, and maybe query.  */\n \n   if (verbose_flag)\n@@ -4104,6 +4101,7 @@ insert_wrapper (const char *wrapper)\n   int i;\n   char *buf = xstrdup (wrapper);\n   char *p = buf;\n+  unsigned int old_length = VEC_length (const_char_p, argbuf);\n \n   do\n     {\n@@ -4113,15 +4111,10 @@ insert_wrapper (const char *wrapper)\n     }\n   while ((p = strchr (p, ',')) != NULL);\n \n-  if (argbuf_index + n >= argbuf_length)\n-    {\n-      argbuf_length = argbuf_length * 2;\n-      while (argbuf_length < argbuf_index + n)\n-\targbuf_length *= 2;\n-      argbuf = XRESIZEVEC (const char *, argbuf, argbuf_length);\n-    }\n-  for (i = argbuf_index - 1; i >= 0; i--)\n-    argbuf[i + n] = argbuf[i];\n+  VEC_safe_grow (const_char_p, heap, argbuf, old_length + n);\n+  memmove (VEC_address (const_char_p, argbuf) + n,\n+\t   VEC_address (const_char_p, argbuf),\n+\t   old_length * sizeof (const_char_p));\n \n   i = 0;\n   p = buf;\n@@ -4132,11 +4125,11 @@ insert_wrapper (const char *wrapper)\n           *p = 0;\n           p++;\n         }\n-      argbuf[i++] = p;\n+      VEC_replace (const_char_p, argbuf, i, p);\n+      i++;\n     }\n   while ((p = strchr (p, ',')) != NULL);\n   gcc_assert (i == n);\n-  argbuf_index += n;\n }\n \n /* Process the spec SPEC and run the commands specified therein.\n@@ -4153,12 +4146,13 @@ do_spec (const char *spec)\n      If -pipe, this forces out the last command if it ended in `|'.  */\n   if (value == 0)\n     {\n-      if (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], \"|\"))\n-\targbuf_index--;\n+      if (VEC_length (const_char_p, argbuf) > 0\n+\t  && !strcmp (VEC_last (const_char_p, argbuf), \"|\"))\n+\tVEC_pop (const_char_p, argbuf);\n \n       set_collect_gcc_options ();\n \n-      if (argbuf_index > 0)\n+      if (VEC_length (const_char_p, argbuf) > 0)\n \tvalue = execute ();\n     }\n \n@@ -4254,7 +4248,7 @@ do_self_spec (const char *spec)\n     if ((switches[i].live_cond & SWITCH_IGNORE))\n       switches[i].live_cond |= SWITCH_IGNORE_PERMANENTLY;\n \n-  if (argbuf_index > 0)\n+  if (VEC_length (const_char_p, argbuf) > 0)\n     {\n       const char **argbuf_copy;\n       struct cl_decoded_option *decoded_options;\n@@ -4264,11 +4258,14 @@ do_self_spec (const char *spec)\n \n       /* Create a copy of argbuf with a dummy argv[0] entry for\n \t decode_cmdline_options_to_array.  */\n-      argbuf_copy = XNEWVEC (const char *, argbuf_index + 1);\n+      argbuf_copy = XNEWVEC (const char *,\n+\t\t\t     VEC_length (const_char_p, argbuf) + 1);\n       argbuf_copy[0] = \"\";\n-      memcpy (argbuf_copy + 1, argbuf, argbuf_index * sizeof (const char *));\n+      memcpy (argbuf_copy + 1, VEC_address (const_char_p, argbuf),\n+\t      VEC_length (const_char_p, argbuf) * sizeof (const char *));\n \n-      decode_cmdline_options_to_array (argbuf_index + 1, argbuf_copy,\n+      decode_cmdline_options_to_array (VEC_length (const_char_p, argbuf) + 1,\n+\t\t\t\t       argbuf_copy,\n \t\t\t\t       CL_DRIVER, &decoded_options,\n \t\t\t\t       &decoded_options_count);\n \n@@ -4435,7 +4432,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n       case '\\n':\n \tend_going_arg ();\n \n-\tif (argbuf_index > 0 && !strcmp (argbuf[argbuf_index - 1], \"|\"))\n+\tif (VEC_length (const_char_p, argbuf) > 0\n+\t    && !strcmp (VEC_last (const_char_p, argbuf), \"|\"))\n \t  {\n \t    /* A `|' before the newline means use a pipe here,\n \t       but only if -pipe was specified.\n@@ -4446,12 +4444,12 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t\tbreak;\n \t      }\n \t    else\n-\t      argbuf_index--;\n+\t      VEC_pop (const_char_p, argbuf);\n \t  }\n \n \tset_collect_gcc_options ();\n \n-\tif (argbuf_index > 0)\n+\tif (VEC_length (const_char_p, argbuf) > 0)\n \t  {\n \t    value = execute ();\n \t    if (value)\n@@ -4947,7 +4945,7 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \n \t  case 'W':\n \t    {\n-\t      int cur_index = argbuf_index;\n+\t      unsigned int cur_index = VEC_length (const_char_p, argbuf);\n \t      /* Handle the {...} following the %W.  */\n \t      if (*p != '{')\n \t\tfatal_error (\"spec %qs has invalid %<%%W%c%>\", spec, *p);\n@@ -4957,8 +4955,8 @@ do_spec_1 (const char *spec, int inswitch, const char *soft_matched_part)\n \t      end_going_arg ();\n \t      /* If any args were output, mark the last one for deletion\n \t\t on failure.  */\n-\t      if (argbuf_index != cur_index)\n-\t\trecord_temp_file (argbuf[argbuf_index - 1], 0, 1);\n+\t      if (VEC_length (const_char_p, argbuf) != cur_index)\n+\t\trecord_temp_file (VEC_last (const_char_p, argbuf), 0, 1);\n \t      break;\n \t    }\n \n@@ -5302,9 +5300,7 @@ eval_spec_function (const char *func, const char *args)\n   const char *funcval;\n \n   /* Saved spec processing context.  */\n-  int save_argbuf_index;\n-  int save_argbuf_length;\n-  const char **save_argbuf;\n+  VEC(const_char_p,heap) *save_argbuf;\n \n   int save_arg_going;\n   int save_delete_this_arg;\n@@ -5320,8 +5316,6 @@ eval_spec_function (const char *func, const char *args)\n     fatal_error (\"unknown spec function %qs\", func);\n \n   /* Push the spec processing context.  */\n-  save_argbuf_index = argbuf_index;\n-  save_argbuf_length = argbuf_length;\n   save_argbuf = argbuf;\n \n   save_arg_going = arg_going;\n@@ -5342,12 +5336,11 @@ eval_spec_function (const char *func, const char *args)\n   /* argbuf_index is an index for the next argument to be inserted, and\n      so contains the count of the args already inserted.  */\n \n-  funcval = (*sf->func) (argbuf_index, argbuf);\n+  funcval = (*sf->func) (VEC_length (const_char_p, argbuf),\n+\t\t\t VEC_address (const_char_p, argbuf));\n \n   /* Pop the spec processing context.  */\n-  argbuf_index = save_argbuf_index;\n-  argbuf_length = save_argbuf_length;\n-  free (argbuf);\n+  VEC_free (const_char_p, heap, argbuf);\n   argbuf = save_argbuf;\n \n   arg_going = save_arg_going;\n@@ -6320,10 +6313,10 @@ main (int argc, char **argv)\n   if (*sysroot_suffix_spec != 0\n       && do_spec_2 (sysroot_suffix_spec) == 0)\n     {\n-      if (argbuf_index > 1)\n+      if (VEC_length (const_char_p, argbuf) > 1)\n         error (\"spec failure: more than one arg to SYSROOT_SUFFIX_SPEC\");\n-      else if (argbuf_index == 1)\n-        target_sysroot_suffix = xstrdup (argbuf[argbuf_index -1]);\n+      else if (VEC_length (const_char_p, argbuf) == 1)\n+        target_sysroot_suffix = xstrdup (VEC_last (const_char_p, argbuf));\n     }\n \n #ifdef HAVE_LD_SYSROOT\n@@ -6343,20 +6336,21 @@ main (int argc, char **argv)\n   if (*sysroot_hdrs_suffix_spec != 0\n       && do_spec_2 (sysroot_hdrs_suffix_spec) == 0)\n     {\n-      if (argbuf_index > 1)\n+      if (VEC_length (const_char_p, argbuf) > 1)\n         error (\"spec failure: more than one arg to SYSROOT_HEADERS_SUFFIX_SPEC\");\n-      else if (argbuf_index == 1)\n-        target_sysroot_hdrs_suffix = xstrdup (argbuf[argbuf_index -1]);\n+      else if (VEC_length (const_char_p, argbuf) == 1)\n+        target_sysroot_hdrs_suffix = xstrdup (VEC_last (const_char_p, argbuf));\n     }\n \n   /* Look for startfiles in the standard places.  */\n   if (*startfile_prefix_spec != 0\n       && do_spec_2 (startfile_prefix_spec) == 0\n       && do_spec_1 (\" \", 0, NULL) == 0)\n     {\n+      const char *arg;\n       int ndx;\n-      for (ndx = 0; ndx < argbuf_index; ndx++)\n-\tadd_sysrooted_prefix (&startfile_prefixes, argbuf[ndx], \"BINUTILS\",\n+      FOR_EACH_VEC_ELT (const_char_p, argbuf, ndx, arg)\n+\tadd_sysrooted_prefix (&startfile_prefixes, arg, \"BINUTILS\",\n \t\t\t      PREFIX_PRIORITY_LAST, 0, 1);\n     }\n   /* We should eventually get rid of all these and stick to\n@@ -8087,19 +8081,20 @@ compare_debug_dump_opt_spec_function (int arg,\n   do_spec_2 (\"%{fdump-final-insns=*:%*}\");\n   do_spec_1 (\" \", 0, NULL);\n \n-  if (argbuf_index > 0 && strcmp (argv[argbuf_index - 1], \".\"))\n+  if (VEC_length (const_char_p, argbuf) > 0\n+      && strcmp (argv[VEC_length (const_char_p, argbuf) - 1], \".\"))\n     {\n       if (!compare_debug)\n \treturn NULL;\n \n-      name = xstrdup (argv[argbuf_index - 1]);\n+      name = xstrdup (argv[VEC_length (const_char_p, argbuf) - 1]);\n       ret = NULL;\n     }\n   else\n     {\n       const char *ext = NULL;\n \n-      if (argbuf_index > 0)\n+      if (VEC_length (const_char_p, argbuf) > 0)\n \t{\n \t  do_spec_2 (\"%{o*:%*}%{!o:%{!S:%b%O}%{S:%b.s}}\");\n \t  ext = \".gkd\";\n@@ -8111,9 +8106,9 @@ compare_debug_dump_opt_spec_function (int arg,\n \n       do_spec_1 (\" \", 0, NULL);\n \n-      gcc_assert (argbuf_index > 0);\n+      gcc_assert (VEC_length (const_char_p, argbuf) > 0);\n \n-      name = concat (argbuf[argbuf_index - 1], ext, NULL);\n+      name = concat (VEC_last (const_char_p, argbuf), ext, NULL);\n \n       ret = concat (\"-fdump-final-insns=\", name, NULL);\n     }\n@@ -8157,9 +8152,9 @@ compare_debug_self_opt_spec_function (int arg,\n   do_spec_2 (\"%{c|S:%{o*:%*}}\");\n   do_spec_1 (\" \", 0, NULL);\n \n-  if (argbuf_index > 0)\n+  if (VEC_length (const_char_p, argbuf) > 0)\n     debug_auxbase_opt = concat (\"-auxbase-strip \",\n-\t\t\t\targbuf[argbuf_index - 1],\n+\t\t\t\tVEC_last (const_char_p, argbuf),\n \t\t\t\tNULL);\n   else\n     debug_auxbase_opt = NULL;"}]}