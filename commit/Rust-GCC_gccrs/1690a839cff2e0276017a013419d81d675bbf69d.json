{"sha": "1690a839cff2e0276017a013419d81d675bbf69d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5MGE4MzljZmYyZTAyNzYwMTdhMDEzNDE5ZDgxZDY3NWJiZjY5ZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-08-28T17:43:56Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-09-09T21:22:06Z"}, "message": "analyzer: generalize sm-malloc to new/delete [PR94355]\n\nThis patch generalizes the state machine in sm-malloc.c to support\nmultiple allocator APIs, and adds just enough support for C++ new and\ndelete to demonstrate the feature, allowing for detection of code\npaths where the result of new in C++ can leak - for some crude examples,\nat least (bearing in mind that the analyzer doesn't yet know about\ne.g. vfuncs, exceptions, inheritance, RTTI, etc)\n\nIt also implements a new warning: -Wanalyzer-mismatching-deallocation.\nFor example:\n\ndemo.cc: In function 'void test()':\ndemo.cc:8:8: warning: 'f' should have been deallocated with 'delete'\n  but was deallocated with 'free' [CWE-762] [-Wanalyzer-mismatching-deallocation]\n    8 |   free (f);\n      |   ~~~~~^~~\n  'void test()': events 1-2\n    |\n    |    7 |   foo *f = new foo;\n    |      |                ^~~\n    |      |                |\n    |      |                (1) allocated here (expects deallocation with 'delete')\n    |    8 |   free (f);\n    |      |   ~~~~~~~~\n    |      |        |\n    |      |        (2) deallocated with 'free' here; allocation at (1) expects deallocation with 'delete'\n    |\n\nThe patch also adds just enough knowledge of exception-handling to\nsuppress a false positive from -Wanalyzer-malloc-leak on\ng++.dg/analyzer/pr96723.C on the exception-handling CFG edge after\noperator new.  It does this by adding a constraint that the result is\nNULL if an exception was thrown from operator new, since the result from\noperator new is lost when following that exception-handling CFG edge.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/94355\n\t* analyzer.opt (Wanalyzer-mismatching-deallocation): New warning.\n\t* region-model-impl-calls.cc\n\t(region_model::impl_call_operator_new): New.\n\t(region_model::impl_call_operator_delete): New.\n\t* region-model.cc (region_model::on_call_pre): Detect operator new\n\tand operator delete.\n\t(region_model::on_call_post): Likewise.\n\t(region_model::maybe_update_for_edge): Detect EH edges and call...\n\t(region_model::apply_constraints_for_exception): New function.\n\t* region-model.h (region_model::impl_call_operator_new): New decl.\n\t(region_model::impl_call_operator_delete): New decl.\n\t(region_model::apply_constraints_for_exception): New decl.\n\t* sm-malloc.cc (enum resource_state): New.\n\t(struct allocation_state): New state subclass.\n\t(enum wording): New.\n\t(struct api): New.\n\t(malloc_state_machine::custom_data_t): New typedef.\n\t(malloc_state_machine::add_state): New decl.\n\t(malloc_state_machine::m_unchecked)\n\t(malloc_state_machine::m_nonnull)\n\t(malloc_state_machine::m_freed): Delete these states in favor\n\tof...\n\t(malloc_state_machine::m_malloc)\n\t(malloc_state_machine::m_scalar_new)\n\t(malloc_state_machine::m_vector_new): ...this new api instances,\n\twhich own their own versions of these states.\n\t(malloc_state_machine::on_allocator_call): New decl.\n\t(malloc_state_machine::on_deallocator_call): New decl.\n\t(api::api): New ctor.\n\t(dyn_cast_allocation_state): New.\n\t(as_a_allocation_state): New.\n\t(get_rs): New.\n\t(unchecked_p): New.\n\t(nonnull_p): New.\n\t(freed_p): New.\n\t(malloc_diagnostic::describe_state_change): Use unchecked_p and\n\tnonnull_p.\n\t(class mismatching_deallocation): New.\n\t(double_free::double_free): Add funcname param for initializing\n\tm_funcname.\n\t(double_free::emit): Use m_funcname in warning message rather\n\tthan hardcoding \"free\".\n\t(double_free::describe_state_change): Likewise.  Use freed_p.\n\t(double_free::describe_call_with_state): Use freed_p.\n\t(double_free::describe_final_event): Use m_funcname in message\n\trather than hardcoding \"free\".\n\t(double_free::m_funcname): New field.\n\t(possible_null::describe_state_change): Use unchecked_p.\n\t(possible_null::describe_return_of_state): Likewise.\n\t(use_after_free::use_after_free): Add param for initializing m_api.\n\t(use_after_free::emit): Use m_api->m_dealloc_funcname in message\n\trather than hardcoding \"free\".\n\t(use_after_free::describe_state_change): Use freed_p.  Change the\n\twording of the message based on the API.\n\t(use_after_free::describe_final_event): Use\n\tm_api->m_dealloc_funcname in message rather than hardcoding\n\t\"free\".  Change the wording of the message based on the API.\n\t(use_after_free::m_api): New field.\n\t(malloc_leak::describe_state_change): Use unchecked_p.  Update\n\tfor renaming of m_malloc_event to m_alloc_event.\n\t(malloc_leak::describe_final_event): Update for renaming of\n\tm_malloc_event to m_alloc_event.\n\t(malloc_leak::m_malloc_event): Rename...\n\t(malloc_leak::m_alloc_event): ...to this.\n\t(free_of_non_heap::free_of_non_heap): Add param for initializing\n\tm_funcname.\n\t(free_of_non_heap::emit): Use m_funcname in message rather than\n\thardcoding \"free\".\n\t(free_of_non_heap::describe_final_event): Likewise.\n\t(free_of_non_heap::m_funcname): New field.\n\t(allocation_state::dump_to_pp): New.\n\t(allocation_state::get_nonnull): New.\n\t(malloc_state_machine::malloc_state_machine): Update for changes\n\tto state fields and new api fields.\n\t(malloc_state_machine::add_state): New.\n\t(malloc_state_machine::on_stmt): Move malloc/calloc handling to\n\ton_allocator_call and call it, passing in the API pointer.\n\tLikewise for free, moving it to on_deallocator_call.  Handle calls\n\tto operator new and delete in an analogous way.  Use unchecked_p\n\twhen testing for possibly-null-arg and possibly-null-deref, and\n\ttransition to the non-null for the correct API.  Remove redundant\n\tnode param from call to on_zero_assignment.  Use freed_p for\n\tuse-after-free check, and pass in API.\n\t(malloc_state_machine::on_allocator_call): New, based on code in\n\ton_stmt.\n\t(malloc_state_machine::on_deallocator_call): Likewise.\n\t(malloc_state_machine::on_phi): Mark node param with\n\tATTRIBUTE_UNUSED; don't pass it to on_zero_assignment.\n\t(malloc_state_machine::on_condition): Mark node param with\n\tATTRIBUTE_UNUSED.  Replace on_transition calls with get_state and\n\tset_next_state pairs, transitioning to the non-null state for the\n\tappropriate API.\n\t(malloc_state_machine::can_purge_p): Port to new state approach.\n\t(malloc_state_machine::on_zero_assignment): Replace on_transition\n\tcalls with get_state and set_next_state pairs.  Drop redundant\n\tnode param.\n\t* sm.h (state_machine::add_custom_state): New.\n\ngcc/ChangeLog:\n\tPR analyzer/94355\n\t* doc/invoke.texi: Document -Wanalyzer-mismatching-deallocation.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/94355\n\t* g++.dg/analyzer/new-1.C: New test.\n\t* g++.dg/analyzer/new-vs-malloc.C: New test.", "tree": {"sha": "908c48e8c98d7b40644a52b4f325a4a0fa812db0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/908c48e8c98d7b40644a52b4f325a4a0fa812db0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1690a839cff2e0276017a013419d81d675bbf69d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1690a839cff2e0276017a013419d81d675bbf69d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1690a839cff2e0276017a013419d81d675bbf69d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1690a839cff2e0276017a013419d81d675bbf69d/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcf56ef5d562eef8d715a76228a5aa1312c689d5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fcf56ef5d562eef8d715a76228a5aa1312c689d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fcf56ef5d562eef8d715a76228a5aa1312c689d5"}], "stats": {"total": 790, "additions": 675, "deletions": 115}, "files": [{"sha": "07bff33921713e61696a040c53540ce355e684d7", "filename": "gcc/analyzer/analyzer.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fanalyzer.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fanalyzer.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.opt?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -70,6 +70,10 @@ Wanalyzer-malloc-leak\n Common Var(warn_analyzer_malloc_leak) Init(1) Warning\n Warn about code paths in which a heap-allocated pointer leaks.\n \n+Wanalyzer-mismatching-deallocation\n+Common Var(warn_analyzer_mismatching_deallocation) Init(1) Warning\n+Warn about code paths in which the wrong deallocation function is called.\n+\n Wanalyzer-possible-null-argument\n Common Var(warn_analyzer_possible_null_argument) Init(1) Warning\n Warn about code paths in which a possibly-NULL value is passed to a must-not-be-NULL function argument."}, {"sha": "fa85035b22d0bf5a971902548e8f5b0818c18bab", "filename": "gcc/analyzer/region-model-impl-calls.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model-impl-calls.cc?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -318,6 +318,41 @@ region_model::impl_call_memset (const call_details &cd)\n   return false;\n }\n \n+/* Handle the on_call_pre part of \"operator new\".  */\n+\n+bool\n+region_model::impl_call_operator_new (const call_details &cd)\n+{\n+  const svalue *size_sval = cd.get_arg_svalue (0);\n+  const region *new_reg = create_region_for_heap_alloc (size_sval);\n+  if (cd.get_lhs_type ())\n+    {\n+      const svalue *ptr_sval\n+\t= m_mgr->get_ptr_svalue (cd.get_lhs_type (), new_reg);\n+      cd.maybe_set_lhs (ptr_sval);\n+    }\n+  return false;\n+}\n+\n+/* Handle the on_call_pre part of \"operator delete\", which comes in\n+   both sized and unsized variants (2 arguments and 1 argument\n+   respectively).  */\n+\n+bool\n+region_model::impl_call_operator_delete (const call_details &cd)\n+{\n+  const svalue *ptr_sval = cd.get_arg_svalue (0);\n+  if (const region_svalue *ptr_to_region_sval\n+      = ptr_sval->dyn_cast_region_svalue ())\n+    {\n+      /* If the ptr points to an underlying heap region, delete it,\n+\t poisoning pointers.  */\n+      const region *freed_reg = ptr_to_region_sval->get_pointee ();\n+      unbind_region_and_descendents (freed_reg, POISON_KIND_FREED);\n+    }\n+  return false;\n+}\n+\n /* Handle the on_call_pre part of \"strlen\".\n    Return true if the LHS is updated.  */\n "}, {"sha": "03c7daf0d1e6552f4a845c5ff5f35f0f681a8152", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -706,6 +706,16 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n \t  if (impl_call_strlen (cd))\n \t    return false;\n \t}\n+      else if (is_named_call_p (callee_fndecl, \"operator new\", call, 1))\n+\treturn impl_call_operator_new (cd);\n+      else if (is_named_call_p (callee_fndecl, \"operator new []\", call, 1))\n+\treturn impl_call_operator_new (cd);\n+      else if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n+\t       || is_named_call_p (callee_fndecl, \"operator delete\", call, 2)\n+\t       || is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n+\t{\n+\t  /* Handle in \"on_call_post\".  */\n+\t}\n       else if (!fndecl_has_gimple_body_p (callee_fndecl)\n \t       && !DECL_PURE_P (callee_fndecl)\n \t       && !fndecl_built_in_p (callee_fndecl))\n@@ -746,12 +756,22 @@ region_model::on_call_post (const gcall *call,\n \t\t\t    region_model_context *ctxt)\n {\n   if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n-    if (is_named_call_p (callee_fndecl, \"free\", call, 1))\n-      {\n-\tcall_details cd (call, this, ctxt);\n-\timpl_call_free (cd);\n-\treturn;\n-      }\n+    {\n+      if (is_named_call_p (callee_fndecl, \"free\", call, 1))\n+\t{\n+\t  call_details cd (call, this, ctxt);\n+\t  impl_call_free (cd);\n+\t  return;\n+\t}\n+      if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n+\t  || is_named_call_p (callee_fndecl, \"operator delete\", call, 2)\n+\t  || is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n+\t{\n+\t  call_details cd (call, this, ctxt);\n+\t  impl_call_operator_delete (cd);\n+\t  return;\n+\t}\n+    }\n \n   if (unknown_side_effects)\n     handle_unrecognized_call (call, ctxt);\n@@ -2191,6 +2211,11 @@ region_model::maybe_update_for_edge (const superedge &edge,\n       return apply_constraints_for_gswitch (*switch_sedge, switch_stmt, ctxt);\n     }\n \n+  /* Apply any constraints due to an exception being thrown.  */\n+  if (const cfg_superedge *cfg_sedge = dyn_cast <const cfg_superedge *> (&edge))\n+    if (cfg_sedge->get_flags () & EDGE_EH)\n+      return apply_constraints_for_exception (last_stmt, ctxt);\n+\n   return true;\n }\n \n@@ -2349,6 +2374,34 @@ region_model::apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n     }\n }\n \n+/* Apply any constraints due to an exception being thrown at LAST_STMT.\n+\n+   If they are feasible, add the constraints and return true.\n+\n+   Return false if the constraints contradict existing knowledge\n+   (and so the edge should not be taken).  */\n+\n+bool\n+region_model::apply_constraints_for_exception (const gimple *last_stmt,\n+\t\t\t\t\t       region_model_context *ctxt)\n+{\n+  gcc_assert (last_stmt);\n+  if (const gcall *call = dyn_cast <const gcall *> (last_stmt))\n+    if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n+      if (is_named_call_p (callee_fndecl, \"operator new\", call, 1)\n+\t  || is_named_call_p (callee_fndecl, \"operator new []\", call, 1))\n+\t{\n+\t  /* We have an exception thrown from operator new.\n+\t     Add a constraint that the result was NULL, to avoid a false\n+\t     leak report due to the result being lost when following\n+\t     the EH edge.  */\n+\t  if (tree lhs = gimple_call_lhs (call))\n+\t    return add_constraint (lhs, EQ_EXPR, null_pointer_node, ctxt);\n+\t  return true;\n+\t}\n+  return true;\n+}\n+\n /* For use with push_frame when handling a top-level call within the analysis.\n    PARAM has a defined but unknown initial value.\n    Anything it points to has escaped, since the calling context \"knows\""}, {"sha": "4707293175a1ef2c7cd2b94cb7009ceab54d6166", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -2556,6 +2556,8 @@ class region_model\n   bool impl_call_malloc (const call_details &cd);\n   bool impl_call_memset (const call_details &cd);\n   bool impl_call_strlen (const call_details &cd);\n+  bool impl_call_operator_new (const call_details &cd);\n+  bool impl_call_operator_delete (const call_details &cd);\n \n   void handle_unrecognized_call (const gcall *call,\n \t\t\t\t region_model_context *ctxt);\n@@ -2694,6 +2696,8 @@ class region_model\n   bool apply_constraints_for_gswitch (const switch_cfg_superedge &edge,\n \t\t\t\t      const gswitch *switch_stmt,\n \t\t\t\t      region_model_context *ctxt);\n+  bool apply_constraints_for_exception (const gimple *last_stmt,\n+\t\t\t\t\tregion_model_context *ctxt);\n \n   int poison_any_pointers_to_descendents (const region *reg,\n \t\t\t\t\t  enum poison_kind pkind);"}, {"sha": "2b5a870d35f804820627c0855cbbf4c35f76381a", "filename": "gcc/analyzer/sm-malloc.cc", "status": "modified", "additions": 481, "deletions": 109, "changes": 590, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fsm-malloc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fsm-malloc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm-malloc.cc?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -48,15 +48,128 @@ namespace ana {\n \n namespace {\n \n+class api;\n+class malloc_state_machine;\n+\n+/* An enum for discriminating between different kinds of allocation_state.  */\n+\n+enum resource_state\n+{\n+  /* States that are independent of api.  */\n+\n+  /* The start state.  */\n+  RS_START,\n+\n+  /* State for a pointer that's known to be NULL.  */\n+  RS_NULL,\n+\n+  /* State for a pointer that's known to not be on the heap (e.g. to a local\n+     or global).  */\n+  RS_NON_HEAP,\n+\n+  /* Stop state, for pointers we don't want to track any more.  */\n+  RS_STOP,\n+\n+  /* States that relate to a specific api.  */\n+\n+  /* State for a pointer returned from the api's allocator that hasn't\n+     been checked for NULL.\n+     It could be a pointer to heap-allocated memory, or could be NULL.  */\n+  RS_UNCHECKED,\n+\n+  /* State for a pointer returned from the api's allocator,\n+     known to be non-NULL.  */\n+  RS_NONNULL,\n+\n+  /* State for a pointer passed to the api's deallocator.  */\n+  RS_FREED\n+};\n+\n+/* Custom state subclass, which can optionally refer to an an api.  */\n+\n+struct allocation_state : public state_machine::state\n+{\n+  allocation_state (const char *name, unsigned id,\n+\t\t    enum resource_state rs, const api *a)\n+  : state (name, id), m_rs (rs), m_api (a)\n+  {}\n+\n+  void dump_to_pp (pretty_printer *pp) const FINAL OVERRIDE;\n+\n+  const allocation_state *get_nonnull () const;\n+\n+  enum resource_state m_rs;\n+  const api *m_api;\n+};\n+\n+/* An enum for choosing which wording to use in various diagnostics\n+   when describing deallocations.  */\n+\n+enum wording\n+{\n+  WORDING_FREED,\n+  WORDING_DELETED\n+};\n+\n+/* Represents a particular family of API calls for allocating/deallocating\n+   heap memory that should be matched e.g.\n+   - malloc/free\n+   - scalar new/delete\n+   - vector new[]/delete[]\n+   etc.\n+\n+   We track the expected deallocation function, but not the allocation\n+   function - there could be more than one allocator per deallocator.  For\n+   example, there could be dozens of allocators for \"free\" beyond just\n+   malloc e.g. calloc, xstrdup, etc.  We don't want to explode the number\n+   of states by tracking individual allocators in the exploded graph;\n+   we merely want to track \"this value expects to have 'free' called on it\".\n+   Perhaps we can reconstruct which allocator was used later, when emitting\n+   the path, if it's necessary for precision of wording of diagnostics.  */\n+\n+struct api\n+{\n+  api (malloc_state_machine *sm,\n+       const char *name,\n+       const char *dealloc_funcname,\n+       enum wording wording);\n+\n+  /* An internal name for identifying this API in dumps.  */\n+  const char *m_name;\n+\n+  /* The name of the deallocation function, for use in diagnostics.  */\n+  const char *m_dealloc_funcname;\n+\n+  /* Which wording to use in diagnostics.  */\n+  enum wording m_wording;\n+\n+  /* Pointers to api-specific states.\n+     These states are owned by the state_machine base class.  */\n+\n+  /* State for an unchecked result from this api's allocator.  */\n+  state_machine::state_t m_unchecked;\n+\n+  /* State for a known non-NULL result from this apis's allocator.  */\n+  state_machine::state_t m_nonnull;\n+\n+  /* State for a value passed to this api's deallocator.  */\n+  state_machine::state_t m_freed;\n+};\n+\n /* A state machine for detecting misuses of the malloc/free API.\n \n    See sm-malloc.dot for an overview (keep this in-sync with that file).  */\n \n class malloc_state_machine : public state_machine\n {\n public:\n+  typedef allocation_state custom_data_t;\n+\n   malloc_state_machine (logger *logger);\n \n+  state_t\n+  add_state (const char *name, enum resource_state rs, const api *a);\n+\n   bool inherited_state_p () const FINAL OVERRIDE { return false; }\n \n   state_machine::state_t\n@@ -98,20 +211,15 @@ class malloc_state_machine : public state_machine\n   bool reset_when_passed_to_unknown_fn_p (state_t s,\n \t\t\t\t\t  bool is_mutable) const FINAL OVERRIDE;\n \n-  /* State for a pointer returned from malloc that hasn't been checked for\n-     NULL.\n-     It could be a pointer to heap-allocated memory, or could be NULL.  */\n-  state_t m_unchecked;\n+  api m_malloc;\n+  api m_scalar_new;\n+  api m_vector_new;\n+\n+  /* States that are independent of api.  */\n \n   /* State for a pointer that's known to be NULL.  */\n   state_t m_null;\n \n-  /* State for a pointer to heap-allocated memory, known to be non-NULL.  */\n-  state_t m_nonnull;\n-\n-  /* State for a pointer to freed memory.  */\n-  state_t m_freed;\n-\n   /* State for a pointer that's known to not be on the heap (e.g. to a local\n      or global).  */\n   state_t m_non_heap; // TODO: or should this be a different state machine?\n@@ -121,12 +229,89 @@ class malloc_state_machine : public state_machine\n   state_t m_stop;\n \n private:\n+  void on_allocator_call (sm_context *sm_ctxt,\n+\t\t\t  const gcall *call,\n+\t\t\t  const api &ap) const;\n+  void on_deallocator_call (sm_context *sm_ctxt,\n+\t\t\t    const supernode *node,\n+\t\t\t    const gcall *call,\n+\t\t\t    const api &ap) const;\n   void on_zero_assignment (sm_context *sm_ctxt,\n-\t\t\t   const supernode *node,\n \t\t\t   const gimple *stmt,\n \t\t\t   tree lhs) const;\n };\n \n+/* struct api.  */\n+\n+api::api (malloc_state_machine *sm,\n+\t  const char *name,\n+\t  const char *dealloc_funcname,\n+\t  enum wording wording)\n+: m_name (name),\n+  m_dealloc_funcname (dealloc_funcname),\n+  m_wording (wording),\n+  m_unchecked (sm->add_state (\"unchecked\", RS_UNCHECKED, this)),\n+  m_nonnull (sm->add_state (\"nonnull\", RS_NONNULL, this)),\n+  m_freed (sm->add_state (\"freed\", RS_FREED, this))\n+{\n+}\n+\n+/* Return STATE cast to the custom state subclass, or NULL for the start state.\n+   Everything should be an allocation_state apart from the start state.  */\n+\n+static const allocation_state *\n+dyn_cast_allocation_state (state_machine::state_t state)\n+{\n+  if (state->get_id () == 0)\n+    return NULL;\n+  return static_cast <const allocation_state *> (state);\n+}\n+\n+/* Return STATE cast to the custom state subclass, for a state that is\n+   already known to not be the start state .  */\n+\n+static const allocation_state *\n+as_a_allocation_state (state_machine::state_t state)\n+{\n+  gcc_assert (state->get_id () != 0);\n+  return static_cast <const allocation_state *> (state);\n+}\n+\n+/* Get the resource_state for STATE.  */\n+\n+static enum resource_state\n+get_rs (state_machine::state_t state)\n+{\n+  if (const allocation_state *astate = dyn_cast_allocation_state (state))\n+    return astate->m_rs;\n+  else\n+    return RS_START;\n+}\n+\n+/* Return true if STATE is an unchecked result from an allocator.  */\n+\n+static bool\n+unchecked_p (state_machine::state_t state)\n+{\n+  return get_rs (state) == RS_UNCHECKED;\n+}\n+\n+/* Return true if STATE is a non-null result from an allocator.  */\n+\n+static bool\n+nonnull_p (state_machine::state_t state)\n+{\n+  return get_rs (state) == RS_NONNULL;\n+}\n+\n+/* Return true if STATE is a value that has been passed to a deallocator.  */\n+\n+static bool\n+freed_p (state_machine::state_t state)\n+{\n+  return get_rs (state) == RS_FREED;\n+}\n+\n /* Class for diagnostics relating to malloc_state_machine.  */\n \n class malloc_diagnostic : public pending_diagnostic\n@@ -145,11 +330,11 @@ class malloc_diagnostic : public pending_diagnostic\n     OVERRIDE\n   {\n     if (change.m_old_state == m_sm.get_start_state ()\n-\t&& change.m_new_state == m_sm.m_unchecked)\n+\t&& unchecked_p (change.m_new_state))\n       // TODO: verify that it's the allocation stmt, not a copy\n       return label_text::borrow (\"allocated here\");\n-    if (change.m_old_state == m_sm.m_unchecked\n-\t&& change.m_new_state == m_sm.m_nonnull)\n+    if (unchecked_p (change.m_old_state)\n+\t&& nonnull_p (change.m_new_state))\n       {\n \tif (change.m_expr)\n \t  return change.formatted_print (\"assuming %qE is non-NULL\",\n@@ -160,7 +345,7 @@ class malloc_diagnostic : public pending_diagnostic\n       }\n     if (change.m_new_state == m_sm.m_null)\n       {\n-\tif (change.m_old_state == m_sm.m_unchecked)\n+\tif (unchecked_p (change.m_old_state))\n \t  {\n \t    if (change.m_expr)\n \t      return change.formatted_print (\"assuming %qE is NULL\",\n@@ -188,13 +373,75 @@ class malloc_diagnostic : public pending_diagnostic\n   tree m_arg;\n };\n \n+/* Concrete subclass for reporting mismatching allocator/deallocator\n+   diagnostics.  */\n+\n+class mismatching_deallocation : public malloc_diagnostic\n+{\n+public:\n+  mismatching_deallocation (const malloc_state_machine &sm, tree arg,\n+\t\t\t    const api *expected_dealloc,\n+\t\t\t    const api *actual_dealloc)\n+  : malloc_diagnostic (sm, arg),\n+    m_expected_dealloc (expected_dealloc),\n+    m_actual_dealloc (actual_dealloc)\n+  {}\n+\n+  const char *get_kind () const FINAL OVERRIDE\n+  {\n+    return \"mismatching_deallocation\";\n+  }\n+\n+  bool emit (rich_location *rich_loc) FINAL OVERRIDE\n+  {\n+    auto_diagnostic_group d;\n+    diagnostic_metadata m;\n+    m.add_cwe (762); /* CWE-762: Mismatched Memory Management Routines.  */\n+    return warning_meta (rich_loc, m, OPT_Wanalyzer_mismatching_deallocation,\n+\t\t\t \"%qE should have been deallocated with %qs\"\n+\t\t\t \" but was deallocated with %qs\",\n+\t\t\t m_arg, m_expected_dealloc->m_dealloc_funcname,\n+\t\t\t m_actual_dealloc->m_dealloc_funcname);\n+  }\n+\n+  label_text describe_state_change (const evdesc::state_change &change)\n+    FINAL OVERRIDE\n+  {\n+    if (unchecked_p (change.m_new_state))\n+      {\n+\tm_alloc_event = change.m_event_id;\n+\treturn change.formatted_print (\"allocated here\"\n+\t\t\t\t       \" (expects deallocation with %qs)\",\n+\t\t\t\t       m_expected_dealloc->m_dealloc_funcname);\n+      }\n+    return malloc_diagnostic::describe_state_change (change);\n+  }\n+\n+  label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n+  {\n+    if (m_alloc_event.known_p ())\n+      return ev.formatted_print\n+\t(\"deallocated with %qs here;\"\n+\t \" allocation at %@ expects deallocation with %qs\",\n+\t m_actual_dealloc->m_dealloc_funcname, &m_alloc_event,\n+\t m_expected_dealloc->m_dealloc_funcname);\n+    return ev.formatted_print (\"deallocated with %qs here\",\n+\t\t\t       m_actual_dealloc->m_dealloc_funcname);\n+  }\n+\n+private:\n+  diagnostic_event_id_t m_alloc_event;\n+  const api *m_expected_dealloc;\n+  const api *m_actual_dealloc;\n+};\n+\n /* Concrete subclass for reporting double-free diagnostics.  */\n \n class double_free : public malloc_diagnostic\n {\n public:\n-  double_free (const malloc_state_machine &sm, tree arg)\n-  : malloc_diagnostic (sm, arg)\n+  double_free (const malloc_state_machine &sm, tree arg, const char *funcname)\n+  : malloc_diagnostic (sm, arg), m_funcname (funcname)\n   {}\n \n   const char *get_kind () const FINAL OVERRIDE { return \"double_free\"; }\n@@ -205,24 +452,24 @@ class double_free : public malloc_diagnostic\n     diagnostic_metadata m;\n     m.add_cwe (415); /* CWE-415: Double Free.  */\n     return warning_meta (rich_loc, m, OPT_Wanalyzer_double_free,\n-\t\t\t \"double-%<free%> of %qE\", m_arg);\n+\t\t\t \"double-%<%s%> of %qE\", m_funcname, m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n     FINAL OVERRIDE\n   {\n-    if (change.m_new_state == m_sm.m_freed)\n+    if (freed_p (change.m_new_state))\n       {\n \tm_first_free_event = change.m_event_id;\n-\treturn change.formatted_print (\"first %qs here\", \"free\");\n+\treturn change.formatted_print (\"first %qs here\", m_funcname);\n       }\n     return malloc_diagnostic::describe_state_change (change);\n   }\n \n   label_text describe_call_with_state (const evdesc::call_with_state &info)\n     FINAL OVERRIDE\n   {\n-    if (info.m_state == m_sm.m_freed)\n+    if (freed_p (info.m_state))\n       return info.formatted_print\n \t(\"passing freed pointer %qE in call to %qE from %qE\",\n \t info.m_expr, info.m_callee_fndecl, info.m_caller_fndecl);\n@@ -233,13 +480,14 @@ class double_free : public malloc_diagnostic\n   {\n     if (m_first_free_event.known_p ())\n       return ev.formatted_print (\"second %qs here; first %qs was at %@\",\n-\t\t\t\t \"free\", \"free\",\n+\t\t\t\t m_funcname, m_funcname,\n \t\t\t\t &m_first_free_event);\n-    return ev.formatted_print (\"second %qs here\", \"free\");\n+    return ev.formatted_print (\"second %qs here\", m_funcname);\n   }\n \n private:\n   diagnostic_event_id_t m_first_free_event;\n+  const char *m_funcname;\n };\n \n /* Abstract subclass for describing possible bad uses of NULL.\n@@ -256,7 +504,7 @@ class possible_null : public malloc_diagnostic\n     FINAL OVERRIDE\n   {\n     if (change.m_old_state == m_sm.get_start_state ()\n-\t&& change.m_new_state == m_sm.m_unchecked)\n+\t&& unchecked_p (change.m_new_state))\n       {\n \tm_origin_of_unchecked_event = change.m_event_id;\n \treturn label_text::borrow (\"this call could return NULL\");\n@@ -267,7 +515,7 @@ class possible_null : public malloc_diagnostic\n   label_text describe_return_of_state (const evdesc::return_of_state &info)\n     FINAL OVERRIDE\n   {\n-    if (info.m_state == m_sm.m_unchecked)\n+    if (unchecked_p (info.m_state))\n       return info.formatted_print (\"possible return of NULL to %qE from %qE\",\n \t\t\t\t   info.m_caller_fndecl, info.m_callee_fndecl);\n     return label_text ();\n@@ -480,8 +728,9 @@ class null_arg : public malloc_diagnostic\n class use_after_free : public malloc_diagnostic\n {\n public:\n-  use_after_free (const malloc_state_machine &sm, tree arg)\n-  : malloc_diagnostic (sm, arg)\n+  use_after_free (const malloc_state_machine &sm, tree arg,\n+\t\t  const api *a)\n+  : malloc_diagnostic (sm, arg), m_api (a)\n   {}\n \n   const char *get_kind () const FINAL OVERRIDE { return \"use_after_free\"; }\n@@ -492,31 +741,52 @@ class use_after_free : public malloc_diagnostic\n     diagnostic_metadata m;\n     m.add_cwe (416);\n     return warning_meta (rich_loc, m, OPT_Wanalyzer_use_after_free,\n-\t\t\t \"use after %<free%> of %qE\", m_arg);\n+\t\t\t \"use after %<%s%> of %qE\",\n+\t\t\t m_api->m_dealloc_funcname, m_arg);\n   }\n \n   label_text describe_state_change (const evdesc::state_change &change)\n     FINAL OVERRIDE\n   {\n-    if (change.m_new_state == m_sm.m_freed)\n+    if (freed_p (change.m_new_state))\n       {\n \tm_free_event = change.m_event_id;\n-\treturn label_text::borrow (\"freed here\");\n+\tswitch (m_api->m_wording)\n+\t  {\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  case WORDING_FREED:\n+\t    return label_text::borrow (\"freed here\");\n+\t  case WORDING_DELETED:\n+\t    return label_text::borrow (\"deleted here\");\n+\t  }\n       }\n     return malloc_diagnostic::describe_state_change (change);\n   }\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n+    const char *funcname = m_api->m_dealloc_funcname;\n     if (m_free_event.known_p ())\n-      return ev.formatted_print (\"use after %<free%> of %qE; freed at %@\",\n-\t\t\t\t ev.m_expr, &m_free_event);\n+      switch (m_api->m_wording)\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase WORDING_FREED:\n+\t  return ev.formatted_print (\"use after %<%s%> of %qE; freed at %@\",\n+\t\t\t\t     funcname, ev.m_expr, &m_free_event);\n+\tcase WORDING_DELETED:\n+\t  return ev.formatted_print (\"use after %<%s%> of %qE; deleted at %@\",\n+\t\t\t\t     funcname, ev.m_expr, &m_free_event);\n+\t}\n     else\n-      return ev.formatted_print (\"use after %<free%> of %qE\", ev.m_expr);\n+      return ev.formatted_print (\"use after %<%s%> of %qE\",\n+\t\t\t\t funcname, ev.m_expr);\n   }\n \n private:\n   diagnostic_event_id_t m_free_event;\n+  const api *m_api;\n };\n \n class malloc_leak : public malloc_diagnostic\n@@ -542,9 +812,9 @@ class malloc_leak : public malloc_diagnostic\n   label_text describe_state_change (const evdesc::state_change &change)\n     FINAL OVERRIDE\n   {\n-    if (change.m_new_state == m_sm.m_unchecked)\n+    if (unchecked_p (change.m_new_state))\n       {\n-\tm_malloc_event = change.m_event_id;\n+\tm_alloc_event = change.m_event_id;\n \treturn label_text::borrow (\"allocated here\");\n       }\n     return malloc_diagnostic::describe_state_change (change);\n@@ -554,31 +824,32 @@ class malloc_leak : public malloc_diagnostic\n   {\n     if (ev.m_expr)\n       {\n-\tif (m_malloc_event.known_p ())\n+\tif (m_alloc_event.known_p ())\n \t  return ev.formatted_print (\"%qE leaks here; was allocated at %@\",\n-\t\t\t\t     ev.m_expr, &m_malloc_event);\n+\t\t\t\t     ev.m_expr, &m_alloc_event);\n \telse\n \t  return ev.formatted_print (\"%qE leaks here\", ev.m_expr);\n       }\n     else\n       {\n-\tif (m_malloc_event.known_p ())\n+\tif (m_alloc_event.known_p ())\n \t  return ev.formatted_print (\"%qs leaks here; was allocated at %@\",\n-\t\t\t\t     \"<unknown>\", &m_malloc_event);\n+\t\t\t\t     \"<unknown>\", &m_alloc_event);\n \telse\n \t  return ev.formatted_print (\"%qs leaks here\", \"<unknown>\");\n       }\n   }\n \n private:\n-  diagnostic_event_id_t m_malloc_event;\n+  diagnostic_event_id_t m_alloc_event;\n };\n \n class free_of_non_heap : public malloc_diagnostic\n {\n public:\n-  free_of_non_heap (const malloc_state_machine &sm, tree arg)\n-  : malloc_diagnostic (sm, arg), m_kind (KIND_UNKNOWN)\n+  free_of_non_heap (const malloc_state_machine &sm, tree arg,\n+\t\t    const char *funcname)\n+  : malloc_diagnostic (sm, arg), m_funcname (funcname), m_kind (KIND_UNKNOWN)\n   {\n   }\n \n@@ -602,15 +873,15 @@ class free_of_non_heap : public malloc_diagnostic\n \tgcc_unreachable ();\n       case KIND_UNKNOWN:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n-\t\t\t     \"%<free%> of %qE which points to memory\"\n+\t\t\t     \"%<%s%> of %qE which points to memory\"\n \t\t\t     \" not on the heap\",\n-\t\t\t     m_arg);\n+\t\t\t     m_funcname, m_arg);\n \tbreak;\n       case KIND_ALLOCA:\n \treturn warning_meta (rich_loc, m, OPT_Wanalyzer_free_of_non_heap,\n-\t\t\t     \"%<free%> of memory allocated on the stack by\"\n+\t\t\t     \"%<%s%> of memory allocated on the stack by\"\n \t\t\t     \" %qs (%qE) will corrupt the heap\",\n-\t\t\t     \"alloca\", m_arg);\n+\t\t\t     m_funcname, \"alloca\", m_arg);\n \tbreak;\n       }\n   }\n@@ -639,7 +910,7 @@ class free_of_non_heap : public malloc_diagnostic\n \n   label_text describe_final_event (const evdesc::final_event &ev) FINAL OVERRIDE\n   {\n-    return ev.formatted_print (\"call to %qs here\", \"free\");\n+    return ev.formatted_print (\"call to %qs here\", m_funcname);\n   }\n \n private:\n@@ -648,20 +919,54 @@ class free_of_non_heap : public malloc_diagnostic\n     KIND_UNKNOWN,\n     KIND_ALLOCA\n   };\n+  const char *m_funcname;\n   enum kind m_kind;\n };\n \n+/* struct allocation_state : public state_machine::state.  */\n+\n+/* Implementation of state_machine::state::dump_to_pp vfunc\n+   for allocation_state: append the API that this allocation is\n+   associated with.  */\n+\n+void\n+allocation_state::dump_to_pp (pretty_printer *pp) const\n+{\n+  state_machine::state::dump_to_pp (pp);\n+  if (m_api)\n+    pp_printf (pp, \" (%s)\", m_api->m_name);\n+}\n+\n+/* Given a allocation_state for an api, get the \"nonnull\" state\n+   for the corresponding allocator.  */\n+\n+const allocation_state *\n+allocation_state::get_nonnull () const\n+{\n+  gcc_assert (m_api);\n+  return as_a_allocation_state (m_api->m_nonnull);\n+}\n+\n /* malloc_state_machine's ctor.  */\n \n malloc_state_machine::malloc_state_machine (logger *logger)\n-: state_machine (\"malloc\", logger)\n-{\n-  m_unchecked = add_state (\"unchecked\");\n-  m_null = add_state (\"null\");\n-  m_nonnull = add_state (\"nonnull\");\n-  m_freed = add_state (\"freed\");\n-  m_non_heap = add_state (\"non-heap\");\n-  m_stop = add_state (\"stop\");\n+: state_machine (\"malloc\", logger),\n+  m_malloc (this, \"malloc\", \"free\", WORDING_FREED),\n+  m_scalar_new (this, \"new\", \"delete\", WORDING_DELETED),\n+  m_vector_new (this, \"new[]\", \"delete[]\", WORDING_DELETED)\n+{\n+  gcc_assert (m_start->get_id () == 0);\n+  m_null = add_state (\"null\", RS_FREED, NULL);\n+  m_non_heap = add_state (\"non-heap\", RS_NON_HEAP, NULL);\n+  m_stop = add_state (\"stop\", RS_STOP, NULL);\n+}\n+\n+state_machine::state_t\n+malloc_state_machine::add_state (const char *name, enum resource_state rs,\n+\t\t\t\t const api *a)\n+{\n+  return add_custom_state (new allocation_state (name, alloc_state_id (),\n+\t\t\t\t\t\t rs, a));\n }\n \n /* Implementation of state_machine::on_stmt vfunc for malloc_state_machine.  */\n@@ -681,13 +986,23 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    || is_named_call_p (callee_fndecl, \"__builtin_malloc\", call, 1)\n \t    || is_named_call_p (callee_fndecl, \"__builtin_calloc\", call, 2))\n \t  {\n-\t    tree lhs = gimple_call_lhs (call);\n-\t    if (lhs)\n-\t      sm_ctxt->on_transition (node, stmt, lhs, m_start, m_unchecked);\n-\t    else\n-\t      {\n-\t\t/* TODO: report leak.  */\n-\t      }\n+\t    on_allocator_call (sm_ctxt, call, m_malloc);\n+\t    return true;\n+\t  }\n+\n+\tif (is_named_call_p (callee_fndecl, \"operator new\", call, 1))\n+\t  on_allocator_call (sm_ctxt, call, m_scalar_new);\n+\telse if (is_named_call_p (callee_fndecl, \"operator new []\", call, 1))\n+\t  on_allocator_call (sm_ctxt, call, m_vector_new);\n+\telse if (is_named_call_p (callee_fndecl, \"operator delete\", call, 1)\n+\t\t || is_named_call_p (callee_fndecl, \"operator delete\", call, 2))\n+\t  {\n+\t    on_deallocator_call (sm_ctxt, node, call, m_scalar_new);\n+\t    return true;\n+\t  }\n+\telse if (is_named_call_p (callee_fndecl, \"operator delete []\", call, 1))\n+\t  {\n+\t    on_deallocator_call (sm_ctxt, node, call, m_vector_new);\n \t    return true;\n \t  }\n \n@@ -704,32 +1019,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t    || is_std_named_call_p (callee_fndecl, \"free\", call, 1)\n \t    || is_named_call_p (callee_fndecl, \"__builtin_free\", call, 1))\n \t  {\n-\t    tree arg = gimple_call_arg (call, 0);\n-\t    tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n-\n-\t    /* start/unchecked/nonnull -> freed.  */\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_start, m_freed);\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_unchecked, m_freed);\n-\t    sm_ctxt->on_transition (node, stmt, arg, m_nonnull, m_freed);\n-\n-\t    /* Keep state \"null\" as-is, rather than transitioning to \"free\";\n-\t       we don't want to complain about double-free of NULL.  */\n-\n-\t    /* freed -> stop, with warning.  */\n-\t    if (sm_ctxt->get_state (stmt, arg) == m_freed)\n-\t      {\n-\t\tsm_ctxt->warn (node, stmt, arg,\n-\t\t\t       new double_free (*this, diag_arg));\n-\t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n-\t      }\n-\n-\t    /* non-heap -> stop, with warning.  */\n-\t    if (sm_ctxt->get_state (stmt, arg) == m_non_heap)\n-\t      {\n-\t\tsm_ctxt->warn (node, stmt, arg,\n-\t\t\t       new free_of_non_heap (*this, diag_arg));\n-\t\tsm_ctxt->set_next_state (stmt, arg, m_stop);\n-\t      }\n+\t    on_deallocator_call (sm_ctxt, node, call, m_malloc);\n \t    return true;\n \t  }\n \n@@ -752,13 +1042,16 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t\t      tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \t\t      state_t state = sm_ctxt->get_state (stmt, arg);\n \t\t      /* Can't use a switch as the states are non-const.  */\n-\t\t      if (state == m_unchecked)\n+\t\t      if (unchecked_p (state))\n \t\t\t{\n \t\t\t  sm_ctxt->warn (node, stmt, arg,\n \t\t\t\t\t new possible_null_arg (*this, diag_arg,\n \t\t\t\t\t\t\t\tcallee_fndecl,\n \t\t\t\t\t\t\t\ti));\n-\t\t\t  sm_ctxt->set_next_state (stmt, arg, m_nonnull);\n+\t\t\t  const allocation_state *astate\n+\t\t\t    = as_a_allocation_state (state);\n+\t\t\t  sm_ctxt->set_next_state (stmt, arg,\n+\t\t\t\t\t\t   astate->get_nonnull ());\n \t\t\t}\n \t\t      else if (state == m_null)\n \t\t\t{\n@@ -776,7 +1069,7 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \n   if (tree lhs = sm_ctxt->is_zero_assignment (stmt))\n     if (any_pointer_p (lhs))\n-      on_zero_assignment (sm_ctxt, node, stmt,lhs);\n+      on_zero_assignment (sm_ctxt, stmt,lhs);\n \n   /* If we have \"LHS = &EXPR;\" and EXPR is something other than a MEM_REF,\n      transition LHS from start to non_heap.\n@@ -813,42 +1106,113 @@ malloc_state_machine::on_stmt (sm_context *sm_ctxt,\n \t  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n \n \t  state_t state = sm_ctxt->get_state (stmt, arg);\n-\t  /* Can't use a switch as the states are non-const.  */\n-\t  if (state == m_unchecked)\n+\t  if (unchecked_p (state))\n \t    {\n \t      sm_ctxt->warn (node, stmt, arg,\n \t\t\t     new possible_null_deref (*this, diag_arg));\n-\t      sm_ctxt->set_next_state (stmt, arg, m_nonnull);\n+\t      const allocation_state *astate = as_a_allocation_state (state);\n+\t      sm_ctxt->set_next_state (stmt, arg, astate->get_nonnull ());\n \t    }\n \t  else if (state == m_null)\n \t    {\n \t      sm_ctxt->warn (node, stmt, arg,\n \t\t\t     new null_deref (*this, diag_arg));\n \t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t    }\n-\t  else if (state == m_freed)\n+\t  else if (freed_p (state))\n \t    {\n+\t      const allocation_state *astate = as_a_allocation_state (state);\n \t      sm_ctxt->warn (node, stmt, arg,\n-\t\t\t     new use_after_free (*this, diag_arg));\n+\t\t\t     new use_after_free (*this, diag_arg,\n+\t\t\t\t\t\t astate->m_api));\n \t      sm_ctxt->set_next_state (stmt, arg, m_stop);\n \t    }\n \t}\n     }\n   return false;\n }\n \n+/* Handle a call to an allocator.  */\n+\n+void\n+malloc_state_machine::on_allocator_call (sm_context *sm_ctxt,\n+\t\t\t\t\t const gcall *call,\n+\t\t\t\t\t const api &ap) const\n+{\n+  tree lhs = gimple_call_lhs (call);\n+  if (lhs)\n+    {\n+      if (sm_ctxt->get_state (call, lhs) == m_start)\n+\tsm_ctxt->set_next_state (call, lhs, ap.m_unchecked);\n+    }\n+  else\n+    {\n+      /* TODO: report leak.  */\n+    }\n+}\n+\n+void\n+malloc_state_machine::on_deallocator_call (sm_context *sm_ctxt,\n+\t\t\t\t\t   const supernode *node,\n+\t\t\t\t\t   const gcall *call,\n+\t\t\t\t\t   const api &ap) const\n+{\n+  tree arg = gimple_call_arg (call, 0);\n+  tree diag_arg = sm_ctxt->get_diagnostic_tree (arg);\n+\n+  state_t state = sm_ctxt->get_state (call, arg);\n+\n+  /* start/unchecked/nonnull -> freed.  */\n+  if (state == m_start)\n+    sm_ctxt->set_next_state (call, arg, ap.m_freed);\n+  else if (unchecked_p (state) || nonnull_p (state))\n+    {\n+      const allocation_state *astate = as_a_allocation_state (state);\n+\n+      if (astate->m_api != &ap)\n+\t{\n+\t  /* Wrong allocator.  */\n+\t  pending_diagnostic *d\n+\t    = new mismatching_deallocation (*this, diag_arg,\n+\t\t\t\t\t    astate->m_api, &ap);\n+\t  sm_ctxt->warn (node, call, arg, d);\n+\t}\n+      sm_ctxt->set_next_state (call, arg, ap.m_freed);\n+    }\n+\n+  /* Keep state \"null\" as-is, rather than transitioning to \"freed\";\n+     we don't want to complain about double-free of NULL.  */\n+\n+  else if (state == ap.m_freed)\n+    {\n+      /* freed -> stop, with warning.  */\n+      sm_ctxt->warn (node, call, arg,\n+\t\t     new double_free (*this, diag_arg,\n+\t\t\t\t      ap.m_dealloc_funcname));\n+      sm_ctxt->set_next_state (call, arg, m_stop);\n+    }\n+  else if (state == m_non_heap)\n+    {\n+      /* non-heap -> stop, with warning.  */\n+      sm_ctxt->warn (node, call, arg,\n+\t\t     new free_of_non_heap (*this, diag_arg,\n+\t\t\t\t\t   ap.m_dealloc_funcname));\n+      sm_ctxt->set_next_state (call, arg, m_stop);\n+    }\n+}\n+\n /* Implementation of state_machine::on_phi vfunc for malloc_state_machine.  */\n \n void\n malloc_state_machine::on_phi (sm_context *sm_ctxt,\n-\t\t\t      const supernode *node,\n+\t\t\t      const supernode *node ATTRIBUTE_UNUSED,\n \t\t\t      const gphi *phi,\n \t\t\t      tree rhs) const\n {\n   if (zerop (rhs))\n     {\n       tree lhs = gimple_phi_result (phi);\n-      on_zero_assignment (sm_ctxt, node, phi, lhs);\n+      on_zero_assignment (sm_ctxt, phi, lhs);\n     }\n }\n \n@@ -857,7 +1221,7 @@ malloc_state_machine::on_phi (sm_context *sm_ctxt,\n \n void\n malloc_state_machine::on_condition (sm_context *sm_ctxt,\n-\t\t\t\t    const supernode *node,\n+\t\t\t\t    const supernode *node ATTRIBUTE_UNUSED,\n \t\t\t\t    const gimple *stmt,\n \t\t\t\t    tree lhs,\n \t\t\t\t    enum tree_code op,\n@@ -874,14 +1238,19 @@ malloc_state_machine::on_condition (sm_context *sm_ctxt,\n   if (op == NE_EXPR)\n     {\n       log (\"got 'ARG != 0' match\");\n-      sm_ctxt->on_transition (node, stmt,\n-\t\t\t      lhs, m_unchecked, m_nonnull);\n+      state_t s = sm_ctxt->get_state (stmt, lhs);\n+      if (unchecked_p (s))\n+\t{\n+\t  const allocation_state *astate = as_a_allocation_state (s);\n+\t  sm_ctxt->set_next_state (stmt, lhs, astate->get_nonnull ());\n+\t}\n     }\n   else if (op == EQ_EXPR)\n     {\n       log (\"got 'ARG == 0' match\");\n-      sm_ctxt->on_transition (node, stmt,\n-\t\t\t      lhs, m_unchecked, m_null);\n+      state_t s = sm_ctxt->get_state (stmt, lhs);\n+      if (unchecked_p (s))\n+\tsm_ctxt->set_next_state (stmt, lhs, m_null);\n     }\n }\n \n@@ -892,7 +1261,8 @@ malloc_state_machine::on_condition (sm_context *sm_ctxt,\n bool\n malloc_state_machine::can_purge_p (state_t s) const\n {\n-  return s != m_unchecked && s != m_nonnull;\n+  enum resource_state rs = get_rs (s);\n+  return rs != RS_UNCHECKED && rs != RS_NONNULL;\n }\n \n /* Implementation of state_machine::on_leak vfunc for malloc_state_machine\n@@ -926,14 +1296,16 @@ malloc_state_machine::reset_when_passed_to_unknown_fn_p (state_t s,\n \n void\n malloc_state_machine::on_zero_assignment (sm_context *sm_ctxt,\n-\t\t\t\t\t  const supernode *node,\n \t\t\t\t\t  const gimple *stmt,\n \t\t\t\t\t  tree lhs) const\n {\n-  sm_ctxt->on_transition (node, stmt, lhs, m_start, m_null);\n-  sm_ctxt->on_transition (node, stmt, lhs, m_unchecked, m_null);\n-  sm_ctxt->on_transition (node, stmt, lhs, m_nonnull, m_null);\n-  sm_ctxt->on_transition (node, stmt, lhs, m_freed, m_null);\n+  state_t s = sm_ctxt->get_state (stmt, lhs);\n+  enum resource_state rs = get_rs (s);\n+  if (rs == RS_START\n+      || rs == RS_UNCHECKED\n+      || rs == RS_NONNULL\n+      || rs == RS_FREED)\n+    sm_ctxt->set_next_state (stmt, lhs, m_null);\n }\n \n } // anonymous namespace"}, {"sha": "f44ad9222007cc8e3fffb3ebbbd94cd9ba7c15ce", "filename": "gcc/analyzer/sm.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fsm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fanalyzer%2Fsm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsm.h?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -125,6 +125,12 @@ class state_machine : public log_user\n \n protected:\n   state_t add_state (const char *name);\n+  state_t add_custom_state (state *s)\n+  {\n+    m_states.safe_push (s);\n+    return s;\n+  }\n+\n   unsigned alloc_state_id () { return m_next_state_id++; }\n \n private:"}, {"sha": "070445a4b77c22b8cf4cd7a64dc57d668ae1463f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -414,6 +414,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wno-analyzer-file-leak @gol\n -Wno-analyzer-free-of-non-heap @gol\n -Wno-analyzer-malloc-leak @gol\n+-Wno-analyzer-mismatching-deallocation @gol\n -Wno-analyzer-null-argument @gol\n -Wno-analyzer-null-dereference @gol\n -Wno-analyzer-possible-null-argument @gol\n@@ -8645,6 +8646,7 @@ Enabling this option effectively enables the following warnings:\n -Wanalyzer-file-leak @gol\n -Wanalyzer-free-of-non-heap @gol\n -Wanalyzer-malloc-leak @gol\n+-Wanalyzer-mismatching-deallocation @gol\n -Wanalyzer-possible-null-argument @gol\n -Wanalyzer-possible-null-dereference @gol\n -Wanalyzer-null-argument @gol\n@@ -8729,6 +8731,17 @@ to disable it.\n This diagnostic warns for paths through the code in which a\n pointer allocated via @code{malloc} is leaked.\n \n+@item -Wno-analyzer-mismatching-deallocation\n+@opindex Wanalyzer-mismatching-deallocation\n+@opindex Wno-analyzer-mismatching-deallocation\n+This warning requires @option{-fanalyzer}, which enables it; use\n+@option{-Wno-analyzer-mismatching-deallocation}\n+to disable it.\n+\n+This diagnostic warns for paths through the code in which the\n+wrong deallocation function is called on a pointer value, based on\n+which function was used to allocate the pointer value.\n+\n @item -Wno-analyzer-possible-null-argument\n @opindex Wanalyzer-possible-null-argument\n @opindex Wno-analyzer-possible-null-argument"}, {"sha": "fadb1d2f7391e6d88155375451a45227bd18608e", "filename": "gcc/testsuite/g++.dg/analyzer/new-1.C", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-1.C?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -0,0 +1,52 @@\n+void test_1 ()\n+{\n+  char* p = new char; // { dg-message \"allocated here\" }\n+} // { dg-warning \"leak of 'p'\" }\n+\n+void test_2 ()\n+{\n+  char* p = new char;\n+  delete p;\n+}\n+\n+/* double-delete shows up as use-after-delete\n+   due to a clobber before the delete.  */\n+\n+void test_3 ()\n+{\n+  char* p = new char;\n+  delete p; // { dg-message \"deleted here\" }\n+  delete p;\n+} // { dg-warning \"use after 'delete'\" }\n+// FIXME: should be on the 2nd delete, not here\n+\n+void test_4 ()\n+{\n+  char *p = new char[16]; // { dg-message \"allocated here\" }\n+  delete[] p; // { dg-message \"first 'delete\\\\\\[\\\\\\]' here\" }\n+  delete[] p; // { dg-warning \"double-'delete\\\\\\[\\\\\\]' of 'p'\" }\n+}\n+\n+void test_5 ()\n+{\n+  char *p = new char[16];\n+  delete p; // { dg-warning \"'p' should have been deallocated with 'delete\\\\\\[\\\\\\]' but was deallocated with 'delete'\" }\n+}\n+\n+void test_6 ()\n+{\n+  char *p = new char;\n+  delete[] p; // { dg-warning \"'p' should have been deallocated with 'delete' but was deallocated with 'delete\\\\\\[\\\\\\]'\" }\n+}\n+\n+char test_7 (char *p)\n+{\n+  delete p;  // { dg-message \"deleted here\" }\n+  return *p; // { dg-warning \"use after 'delete' of 'p'\" }\n+}\n+\n+char test_8 (char *p)\n+{\n+  delete[] p; // { dg-message \"deleted here\" }\n+  return *p;  // { dg-warning \"use after 'delete\\\\\\[\\\\\\]' of 'p'\" }\n+}"}, {"sha": "cb0b32424ca94d873a884ace5b6bda0c4bcc6f79", "filename": "gcc/testsuite/g++.dg/analyzer/new-vs-malloc.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-vs-malloc.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1690a839cff2e0276017a013419d81d675bbf69d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-vs-malloc.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fanalyzer%2Fnew-vs-malloc.C?ref=1690a839cff2e0276017a013419d81d675bbf69d", "patch": "@@ -0,0 +1,21 @@\n+#include <cstdlib>\n+\n+struct s {};\n+\n+void test_1 ()\n+{\n+  s *p = new s; // { dg-message \"allocated here \\\\(expects deallocation with 'delete'\\\\)\"\n+  free (p); // { dg-warning \"'p' should have been deallocated with 'delete' but was deallocated with 'free'\" }\n+}\n+\n+void test_2 ()\n+{\n+  char *p = new char[16]; // { dg-message \"allocated here \\\\(expects deallocation with 'delete\\\\\\[\\\\\\]'\\\\)\"\n+  free (p); // { dg-warning \"'p' should have been deallocated with 'delete\\\\\\[\\\\\\]' but was deallocated with 'free'\" }\n+}\n+\n+void test_3 ()\n+{\n+  char *p = (char *)malloc (16); // { dg-message \"allocated here \\\\(expects deallocation with 'free'\\\\)\"\n+  delete[] p; // { dg-warning \"'p' should have been deallocated with 'free' but was deallocated with 'delete\\\\\\[\\\\\\]'\" }\n+}"}]}