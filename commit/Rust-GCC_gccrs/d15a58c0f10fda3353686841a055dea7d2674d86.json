{"sha": "d15a58c0f10fda3353686841a055dea7d2674d86", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDE1YTU4YzBmMTBmZGEzMzUzNjg2ODQxYTA1NWRlYTdkMjY3NGQ4Ng==", "commit": {"author": {"name": "Neil Booth", "email": "neil@daikokuya.demon.co.uk", "date": "2002-01-03T18:32:55Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2002-01-03T18:32:55Z"}, "message": "cppmacro.c: Don't include intl.h.\n\n\t* cppmacro.c: Don't include intl.h.  Update comments.\n\t(new_number_token): Allocate enough buffer for 64-bit unsigned\n\tintegers; update prototype.\n\t* cppmain.c: Update comments.\n\nFrom-SVN: r48518", "tree": {"sha": "4b0b3ec26267cd45c6d5a08758733db9a4023f1f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b0b3ec26267cd45c6d5a08758733db9a4023f1f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d15a58c0f10fda3353686841a055dea7d2674d86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15a58c0f10fda3353686841a055dea7d2674d86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d15a58c0f10fda3353686841a055dea7d2674d86", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d15a58c0f10fda3353686841a055dea7d2674d86/comments", "author": null, "committer": null, "parents": [{"sha": "2fd174098b42203109ccbf3e1c6a128c32596255", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fd174098b42203109ccbf3e1c6a128c32596255", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fd174098b42203109ccbf3e1c6a128c32596255"}], "stats": {"total": 105, "additions": 63, "deletions": 42}, "files": [{"sha": "f19a346fa85bf8768d50455dbf342bd3df5858cf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d15a58c0f10fda3353686841a055dea7d2674d86", "patch": "@@ -1,3 +1,10 @@\n+2002-01-03  Neil Booth  <neil@daikokuya.demon.co.uk>\n+\n+\t* cppmacro.c: Don't include intl.h.  Update comments.\n+\t(new_number_token): Allocate enough buffer for 64-bit unsigned\n+\tintegers; update prototype.\n+\t* cppmain.c: Update comments.\n+\n 2002-01-03  William Cohen  <wcohen@redhat.com>\n \n \t* function.h (struct function): Add profile."}, {"sha": "c36389eff396fae33eb4549a30b43d9667991faf", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 54, "deletions": 38, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=d15a58c0f10fda3353686841a055dea7d2674d86", "patch": "@@ -25,7 +25,6 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n \n #include \"config.h\"\n #include \"system.h\"\n-#include \"intl.h\"\t\t/* for _(\"<command line>\") below.  */\n #include \"cpplib.h\"\n #include \"cpphash.h\"\n \n@@ -70,7 +69,7 @@ static unsigned char *quote_string PARAMS ((unsigned char *,\n \t\t\t\t\t    unsigned int));\n static const cpp_token *new_string_token PARAMS ((cpp_reader *, U_CHAR *,\n \t\t\t\t\t\t  unsigned int));\n-static const cpp_token *new_number_token PARAMS ((cpp_reader *, int));\n+static const cpp_token *new_number_token PARAMS ((cpp_reader *, unsigned int));\n static const cpp_token *stringify_arg PARAMS ((cpp_reader *, macro_arg *));\n static void paste_all_tokens PARAMS ((cpp_reader *, const cpp_token *));\n static bool paste_tokens PARAMS ((cpp_reader *, const cpp_token **,\n@@ -112,12 +111,13 @@ new_string_token (pfile, text, len)\n static const cpp_token *\n new_number_token (pfile, number)\n      cpp_reader *pfile;\n-     int number;\n+     unsigned int number;\n {\n   cpp_token *token = _cpp_temp_token (pfile);\n-  unsigned char *buf = _cpp_unaligned_alloc (pfile, 20);\n+  /* 21 bytes holds all NUL-terminated unsigned 64-bit numbers.  */\n+  unsigned char *buf = _cpp_unaligned_alloc (pfile, 21);\n \n-  sprintf ((char *) buf, \"%d\", number);\n+  sprintf ((char *) buf, \"%u\", number);\n   token->type = CPP_NUMBER;\n   token->val.str.text = buf;\n   token->val.str.len = ustrlen (buf);\n@@ -133,8 +133,8 @@ static const char * const monthnames[] =\n \n /* Handle builtin macros like __FILE__, and push the resulting token\n    on the context stack.  Also handles _Pragma, for which no new token\n-   is created.  Returns 1 on success, 0 to return the token to the\n-   caller.  */\n+   is created.  Returns 1 if it generates a new token context, 0 to\n+   return the token to the caller.  */\n static int\n builtin_macro (pfile, node)\n      cpp_reader *pfile;\n@@ -241,8 +241,9 @@ builtin_macro (pfile, node)\n   return 1;\n }\n \n-/* Adds backslashes before all backslashes and double quotes appearing\n-   in strings.  Non-printable characters are converted to octal.  */\n+/* Copies SRC, of length LEN, to DEST, adding backslashes before all\n+   backslashes and double quotes.  Non-printable characters are\n+   converted to octal.  DEST must be of sufficient size.  */\n static U_CHAR *\n quote_string (dest, src, len)\n      U_CHAR *dest;\n@@ -273,8 +274,8 @@ quote_string (dest, src, len)\n   return dest;\n }\n \n-/* Convert a token sequence to a single string token according to the\n-   rules of the ISO C #-operator.  */\n+/* Convert a token sequence ARG to a single string token according to\n+   the rules of the ISO C #-operator.  */\n static const cpp_token *\n stringify_arg (pfile, arg)\n      cpp_reader *pfile;\n@@ -399,11 +400,13 @@ paste_tokens (pfile, plhs, rhs)\n   return valid;\n }\n \n-/* Handles an arbitrarily long sequence of ## operators.  This\n-   implementation is left-associative, non-recursive, and finishes a\n-   paste before handling succeeding ones.  If the paste fails, we back\n-   up a token to just after the ## operator, with the effect that it\n-   appears in the output stream normally.  */\n+/* Handles an arbitrarily long sequence of ## operators, with initial\n+   operand LHS.  This implementation is left-associative,\n+   non-recursive, and finishes a paste before handling succeeding\n+   ones.  If a paste fails, we back up to the RHS of the failing ##\n+   operator before pushing the context containing the result of prior\n+   successful pastes, with the effect that the RHS appears in the\n+   output stream after the pasted LHS normally.  */\n static void\n paste_all_tokens (pfile, lhs)\n      cpp_reader *pfile;\n@@ -446,9 +449,11 @@ paste_all_tokens (pfile, lhs)\n   push_token_context (pfile, NULL, lhs, 1);\n }\n \n-/* Reads and returns the arguments to a function-like macro invocation.\n-   Assumes the opening parenthesis has been processed.  If there is an\n-   error, emits an appropriate diagnostic and returns NULL.  */\n+/* Reads and returns the arguments to a function-like macro\n+   invocation.  Assumes the opening parenthesis has been processed.\n+   If there is an error, emits an appropriate diagnostic and returns\n+   NULL.  Each argument is terminated by a CPP_EOF token, for the\n+   future benefit of expand_arg().  */\n static _cpp_buff *\n collect_args (pfile, node)\n      cpp_reader *pfile;\n@@ -653,19 +658,19 @@ funlike_invocation_p (pfile, node)\n   return NULL;\n }\n \n-/* Push the context of a macro onto the context stack.  TOKEN is the\n-   macro name.  If we can successfully start expanding the macro,\n-   TOKEN is replaced with the first token of the expansion, and we\n-   return non-zero.  */\n+/* Push the context of a macro with hash entry NODE onto the context\n+   stack.  If we can successfully expand the macro, we push a context\n+   containing its yet-to-be-rescanned replacement list and return one.\n+   Otherwise, we don't push a context and return zero.  */\n static int\n enter_macro_context (pfile, node)\n      cpp_reader *pfile;\n      cpp_hashnode *node;\n {\n-  /* Macros invalidate controlling macros.  */\n+  /* The presence of a macro invalidates a file's controlling macro.  */\n   pfile->mi_valid = false;\n \n-  /* Handle macros and the _Pragma operator.  */\n+  /* Handle standard macros.  */\n   if (! (node->flags & NODE_BUILTIN))\n     {\n       cpp_macro *macro = node->value.macro;\n@@ -706,12 +711,14 @@ enter_macro_context (pfile, node)\n       return 1;\n     }\n \n+  /* Handle built-in macros and the _Pragma operator.  */\n   return builtin_macro (pfile, node);\n }\n \n-/* Take the expansion of a function-like MACRO, replacing parameters\n-   with the actual arguments.  Each argument is macro-expanded before\n-   replacement, unless operated upon by the # or ## operators.  */\n+/* Replace the parameters in a function-like macro of NODE with the\n+   actual ARGS, and place the result in a newly pushed token context.\n+   Expand each argument before replacing, unless it is operated upon\n+   by the # or ## operators.  */\n static void\n replace_args (pfile, node, args)\n      cpp_reader *pfile;\n@@ -864,7 +871,8 @@ padding_token (pfile, source)\n   return result;\n }\n \n-/* Move to the next context.  Create one if there is none.  */\n+/* Get a new uninitialized context.  Create a new one if we cannot\n+   re-use an old one.  */\n static cpp_context *\n next_context (pfile)\n      cpp_reader *pfile;\n@@ -918,6 +926,12 @@ push_token_context (pfile, macro, first, count)\n   context->last.token = first + count;\n }\n \n+/* Expand an argument ARG before replacing parameters in a\n+   function-like macro.  This works by pushing a context with the\n+   argument's tokens, and then expanding that into a temporary buffer\n+   as if it were a normal part of the token stream.  collect_args()\n+   has terminated the argument's tokens with a CPP_EOF so that we know\n+   when we have fully expanded the argument.  */\n static void\n expand_arg (pfile, arg)\n      cpp_reader *pfile;\n@@ -956,13 +970,15 @@ expand_arg (pfile, arg)\n   _cpp_pop_context (pfile);\n }\n \n+/* Pop the current context off the stack, re-enabling the macro if the\n+   context represented a macro's replacement list.  The context\n+   structure is not freed so that we can re-use it later.  */\n void\n _cpp_pop_context (pfile)\n      cpp_reader *pfile;\n {\n   cpp_context *context = pfile->context;\n \n-  /* Re-enable a macro when leaving its expansion.  */\n   if (context->macro)\n     context->macro->flags &= ~NODE_DISABLED;\n \n@@ -1040,7 +1056,8 @@ cpp_get_token (pfile)\n \t}\n       else\n \t{\n-\t  /* Flag this token as always unexpandable.  */\n+\t  /* Flag this token as always unexpandable.  FIXME: move this\n+\t     to collect_args()?.  */\n \t  cpp_token *t = _cpp_temp_token (pfile);\n \t  t->type = result->type;\n \t  t->flags = result->flags | NO_EXPAND;\n@@ -1149,7 +1166,6 @@ warn_of_redefinition (node, macro2)\n }\n \n /* Free the definition of hashnode H.  */\n-\n void\n _cpp_free_definition (h)\n      cpp_hashnode *h;\n@@ -1267,6 +1283,8 @@ alloc_expansion_token (pfile, macro)\n   return &((cpp_token *) BUFF_FRONT (pfile->a_buff))[macro->count++];\n }\n \n+/* Lex a token from the expansion of MACRO, but mark parameters as we\n+   find them and warn of traditional stringification.  */\n static cpp_token *\n lex_expansion_token (pfile, macro)\n      cpp_reader *pfile;\n@@ -1277,7 +1295,7 @@ lex_expansion_token (pfile, macro)\n   pfile->cur_token = alloc_expansion_token (pfile, macro);\n   token = _cpp_lex_direct (pfile);\n \n-  /* Is this an argument?  */\n+  /* Is this a parameter?  */\n   if (token->type == CPP_NAME && token->val.node->arg_index)\n     {\n       token->type = CPP_MACRO_ARG;\n@@ -1390,7 +1408,7 @@ _cpp_create_definition (pfile, node)\n   /* Don't count the CPP_EOF.  */\n   macro->count--;\n \n-  /* Clear whitespace on first token for macro equivalence purposes.  */\n+  /* Clear whitespace on first token for warn_of_redefinition().  */\n   if (macro->count)\n     macro->expansion[0].flags &= ~PREV_WHITE;\n \n@@ -1444,9 +1462,8 @@ _cpp_create_definition (pfile, node)\n   return ok;\n }\n \n-/* Warn if a token in `string' matches one of the function macro\n-   arguments in `info'.  This function assumes that the macro is a\n-   function macro and not an object macro.  */\n+/* Warn if a token in STRING matches one of a function-like MACRO's\n+   parameters.  */\n static void\n check_trad_stringification (pfile, macro, string)\n      cpp_reader *pfile;\n@@ -1493,7 +1510,6 @@ check_trad_stringification (pfile, macro, string)\n    debugging info.  e.g. \"PASTE(X, Y) X ## Y\", or \"MACNAME EXPANSION\".\n    Caller is expected to generate the \"#define\" bit if needed.  The\n    returned text is temporary, and automatically freed later.  */\n-\n const unsigned char *\n cpp_macro_definition (pfile, node)\n      cpp_reader *pfile;"}, {"sha": "70f5bb3a738a0b231dd7f486b753df4183f4b7de", "filename": "gcc/cppmain.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d15a58c0f10fda3353686841a055dea7d2674d86/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=d15a58c0f10fda3353686841a055dea7d2674d86", "patch": "@@ -162,7 +162,7 @@ do_preprocessing (argc, argv)\n     {\n       cpp_finish_options (pfile);\n \n-      /* A successful cpp_start_read guarantees that we can call\n+      /* A successful cpp_read_main_file guarantees that we can call\n \t cpp_scan_nooutput or cpp_get_token next.  */\n       if (options->no_output)\n \tcpp_scan_nooutput (pfile);\n@@ -275,7 +275,6 @@ check_multiline_token (str)\n /* If the token read on logical line LINE needs to be output on a\n    different line to the current one, output the required newlines or\n    a line marker, and return 1.  Otherwise return 0.  */\n-\n static void\n maybe_print_line (map, line)\n      const struct line_map *map;\n@@ -330,8 +329,7 @@ print_line (map, line, special_flags)\n }\n \n /* Called when a line of output is started.  TOKEN is the first token\n-   of the line, and may be CPP_EOF.  */\n-\n+   of the line, and at end of file will be CPP_EOF.  */\n static void\n cb_line_change (pfile, token, parsing_args)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;"}]}