{"sha": "4253435ecaf28bfc387407dd5a2fb4f4283ed203", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI1MzQzNWVjYWYyOGJmYzM4NzQwN2RkNWEyZmI0ZjQyODNlZDIwMw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2018-02-07T22:54:59Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-02-07T22:54:59Z"}, "message": "re PR target/84154 (PowerPC GCC 7 and 8 have regression in converting fp to short/char and returning it)\n\n[gcc]\n2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/84154\n\t* config/rs6000/rs6000.md (fix_trunc<SFDF:mode><QHI:mode>2):\n\tConvert from define_expand to be define_insn_and_split.  Rework\n\tfloat/double/_Float128 conversions to QI/HI/SImode to work with\n\tboth ISA 2.07 (power8) or ISA 3.0 (power9).  Fix regression where\n\tconversions to QI/HImode types did a store and then a load to\n\ttruncate the value.  For conversions to VSX registers, don't split\n\tthe insn, instead emit the code directly.  Use the code iterator\n\tany_fix to combine signed and unsigned conversions.\n\t(fix<uns>_trunc<SFDF:mode>si2_p8): Likewise.\n\t(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.\n\t(fix_trunc<IEEE128:mode><QHI:mode>2): Likewise.\n\t(fix<uns>_trunc<SFDF:mode><QHI:mode>2): Likewise.\n\t(fix_<mode>di2_hw): Likewise.\n\t(fixuns_<mode>di2_hw): Likewise.\n\t(fix_<mode>si2_hw): Likewise.\n\t(fixuns_<mode>si2_hw): Likewise.\n\t(fix<uns>_<IEEE128:mode><SDI:mode>2_hw): Likewise.\n\t(fix<uns>_trunc<IEEE128:mode><QHI:mode>2): Likewise.\n\t(fctiw<u>z_<mode>_smallint): Rename fctiw<u>z_<mode>_smallint to\n\tfix<uns>_trunc<SFDF:mode>si2_p8.\n\t(fix_trunc<SFDF:mode><QHI:mode>2_internal): Delete, no longer\n\tused.\n\t(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n\t(fix<uns>_<mode>_mem): Likewise.\n\t(fctiw<u>z_<mode>_mem): Likewise.\n\t(fix<uns>_<mode>_mem): Likewise.\n\t(fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem): On ISA 3.0, prevent\n\tthe register allocator from doing a direct move to the GPRs to do\n\ta store, and instead use the ISA 3.0 store byte/half-word from\n\tvector register instruction.  For IEEE 128-bit floating point,\n\talso optimize stores of 32-bit ints.\n\t(fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem): Likewise.\n\n[gcc/testsuite]\n2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n\n\tPR target/84154\n\t* gcc.target/powerpc/pr84154-1.c: New tests.\n\t* gcc.target/powerpc/pr84154-2.c: Likewise.\n\t* gcc.target/powerpc/pr84154-3.c: Likewise.\n\nFrom-SVN: r257470", "tree": {"sha": "6d4bdda4a97c6e5c2340b03281d8cd2da9ca1875", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d4bdda4a97c6e5c2340b03281d8cd2da9ca1875"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4253435ecaf28bfc387407dd5a2fb4f4283ed203", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4253435ecaf28bfc387407dd5a2fb4f4283ed203", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4253435ecaf28bfc387407dd5a2fb4f4283ed203", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4253435ecaf28bfc387407dd5a2fb4f4283ed203/comments", "author": null, "committer": null, "parents": [{"sha": "54af445d3c7fdf26a2e96bac51c763c4c571d2b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54af445d3c7fdf26a2e96bac51c763c4c571d2b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54af445d3c7fdf26a2e96bac51c763c4c571d2b8"}], "stats": {"total": 421, "additions": 292, "deletions": 129}, "files": [{"sha": "59e1f8fada8950085dec6276ee65e58f5174941f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -1,3 +1,39 @@\n+2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/84154\n+\t* config/rs6000/rs6000.md (fix_trunc<SFDF:mode><QHI:mode>2):\n+\tConvert from define_expand to be define_insn_and_split.  Rework\n+\tfloat/double/_Float128 conversions to QI/HI/SImode to work with\n+\tboth ISA 2.07 (power8) or ISA 3.0 (power9).  Fix regression where\n+\tconversions to QI/HImode types did a store and then a load to\n+\ttruncate the value.  For conversions to VSX registers, don't split\n+\tthe insn, instead emit the code directly.  Use the code iterator\n+\tany_fix to combine signed and unsigned conversions.\n+\t(fix<uns>_trunc<SFDF:mode>si2_p8): Likewise.\n+\t(fixuns_trunc<SFDF:mode><QHI:mode>2): Likewise.\n+\t(fix_trunc<IEEE128:mode><QHI:mode>2): Likewise.\n+\t(fix<uns>_trunc<SFDF:mode><QHI:mode>2): Likewise.\n+\t(fix_<mode>di2_hw): Likewise.\n+\t(fixuns_<mode>di2_hw): Likewise.\n+\t(fix_<mode>si2_hw): Likewise.\n+\t(fixuns_<mode>si2_hw): Likewise.\n+\t(fix<uns>_<IEEE128:mode><SDI:mode>2_hw): Likewise.\n+\t(fix<uns>_trunc<IEEE128:mode><QHI:mode>2): Likewise.\n+\t(fctiw<u>z_<mode>_smallint): Rename fctiw<u>z_<mode>_smallint to\n+\tfix<uns>_trunc<SFDF:mode>si2_p8.\n+\t(fix_trunc<SFDF:mode><QHI:mode>2_internal): Delete, no longer\n+\tused.\n+\t(fixuns_trunc<SFDF:mode><QHI:mode>2_internal): Likewise.\n+\t(fix<uns>_<mode>_mem): Likewise.\n+\t(fctiw<u>z_<mode>_mem): Likewise.\n+\t(fix<uns>_<mode>_mem): Likewise.\n+\t(fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem): On ISA 3.0, prevent\n+\tthe register allocator from doing a direct move to the GPRs to do\n+\ta store, and instead use the ISA 3.0 store byte/half-word from\n+\tvector register instruction.  For IEEE 128-bit floating point,\n+\talso optimize stores of 32-bit ints.\n+\t(fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem): Likewise.\n+\n 2018-02-07  Alan Hayward  <alan.hayward@arm.com>\n \n \t* genextract.c (push_pathstr_operand): New function to support"}, {"sha": "33f0d959f5d09598abcbe3b35a28b1685f90ad9a", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 76, "deletions": 129, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -5700,43 +5700,59 @@\n    xscvdpsxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"fix_trunc<SFDF:mode><QHI:mode>2\"\n-  [(parallel [(set (match_operand:<QHI:MODE> 0 \"nonimmediate_operand\")\n-\t\t   (fix:QHI (match_operand:SFDF 1 \"gpc_reg_operand\")))\n-\t      (clobber (match_scratch:DI 2))])]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\"\n+;; If we have ISA 3.0, QI/HImode values can go in both VSX registers and GPR\n+;; registers.  If we have ISA 2.07, we don't allow QI/HImode values in the\n+;; vector registers, so we need to do direct moves to the GPRs, but SImode\n+;; values can go in VSX registers.  Keeping the direct move part through\n+;; register allocation prevents the register allocator from doing a direct move\n+;; of the SImode value to a GPR, and then a store/load.\n+(define_insn_and_split \"fix<uns>_trunc<SFDF:mode><QHI:mode>2\"\n+  [(set (match_operand:<QHI:MODE> 0 \"gpc_reg_operand\" \"=wJ,wJwK,r\")\n+\t(any_fix:QHI (match_operand:SFDF 1 \"gpc_reg_operand\" \"wJ,wJwK,wa\")))\n+   (clobber (match_scratch:SI 2 \"=X,X,wi\"))]\n+  \"TARGET_DIRECT_MOVE\"\n+  \"@\n+   fctiw<u>z %0,%1\n+   xscvdp<su>xws %x0,%x1\n+   #\"\n+  \"&& reload_completed && int_reg_operand (operands[0], <QHI:MODE>mode)\"\n+  [(set (match_dup 2)\n+\t(any_fix:SI (match_dup 1)))\n+   (set (match_dup 3)\n+\t(match_dup 2))]\n {\n-  if (MEM_P (operands[0]))\n-    operands[0] = rs6000_address_for_fpconvert (operands[0]);\n-})\n+  operands[3] = gen_rtx_REG (SImode, REGNO (operands[0]));\n+}\n+  [(set_attr \"length\" \"4,4,8\")\n+   (set_attr \"type\" \"fp\")])\n+\n+(define_insn \"*fix<uns>_trunc<SFDF:mode>si2_p8\"\n+  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=d,wa\")\n+\t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"d,wa\")))]\n+  \"TARGET_DIRECT_MOVE\"\n+  \"@\n+   fctiw<u>z %0,%1\n+   xscvdp<su>xws %x0,%x1\"\n+  [(set_attr \"type\" \"fp\")])\n \n-(define_insn_and_split \"*fix_trunc<SFDF:mode><QHI:mode>2_internal\"\n-  [(set (match_operand:<QHI:MODE> 0 \"reg_or_indexed_operand\" \"=wIwJ,rZ\")\n-\t(fix:QHI\n-\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n-   (clobber (match_scratch:DI 2 \"=X,wi\"))]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\"\n+;; Keep the convert and store together through register allocation to prevent\n+;; the register allocator from getting clever and doing a direct move to a GPR\n+;; and then store for reg+offset stores.\n+(define_insn_and_split \"*fix<uns>_trunc<SFDF:mode><QHSI:mode>2_mem\"\n+  [(set (match_operand:QHSI 0 \"memory_operand\" \"=Z\")\n+\t(any_fix:QHSI (match_operand:SFDF 1 \"gpc_reg_operand\" \"wa\")))\n+   (clobber (match_scratch:SI 2 \"=wa\"))]\n+    \"(<QHSI:MODE>mode == SImode && TARGET_P8_VECTOR) || TARGET_P9_VECTOR\"\n   \"#\"\n   \"&& reload_completed\"\n-  [(const_int 0)]\n+  [(set (match_dup 2)\n+\t(any_fix:SI (match_dup 1)))\n+   (set (match_dup 0)\n+\t(match_dup 3))]\n {\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-\n-  if (vsx_register_operand (dest, <QHI:MODE>mode))\n-    {\n-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));\n-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (di_dest, src));\n-    }\n-  else\n-    {\n-      rtx tmp = operands[2];\n-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));\n-\n-      emit_insn (gen_fix_trunc<SFDF:mode>di2 (tmp, src));\n-      emit_move_insn (dest, tmp2);\n-    }\n-  DONE;\n+  operands[3] = (<QHSI:MODE>mode == SImode\n+\t\t ? operands[2]\n+\t\t : gen_rtx_REG (<QHSI:MODE>mode, REGNO (operands[2])));\n })\n \n (define_expand \"fixuns_trunc<mode>si2\"\n@@ -5803,71 +5819,6 @@\n    xscvdpuxds %x0,%x1\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_expand \"fixuns_trunc<SFDF:mode><QHI:mode>2\"\n-  [(parallel [(set (match_operand:<QHI:MODE> 0 \"nonimmediate_operand\")\n-\t\t   (unsigned_fix:QHI (match_operand:SFDF 1 \"gpc_reg_operand\")))\n-\t      (clobber (match_scratch:DI 2))])]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\"\n-{\n-  if (MEM_P (operands[0]))\n-    operands[0] = rs6000_address_for_fpconvert (operands[0]);\n-})\n-\n-(define_insn_and_split \"*fixuns_trunc<SFDF:mode><QHI:mode>2_internal\"\n-  [(set (match_operand:<QHI:MODE> 0 \"reg_or_indexed_operand\" \"=wIwJ,rZ\")\n-\t(unsigned_fix:QHI\n-\t (match_operand:SFDF 1 \"gpc_reg_operand\" \"<SFDF:Fv>,<SFDF:Fv>\")))\n-   (clobber (match_scratch:DI 2 \"=X,wi\"))]\n-  \"TARGET_P9_VECTOR && TARGET_DIRECT_MOVE_64BIT\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(const_int 0)]\n-{\n-  rtx dest = operands[0];\n-  rtx src = operands[1];\n-\n-  if (vsx_register_operand (dest, <QHI:MODE>mode))\n-    {\n-      rtx di_dest = gen_rtx_REG (DImode, REGNO (dest));\n-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (di_dest, src));\n-    }\n-  else\n-    {\n-      rtx tmp = operands[2];\n-      rtx tmp2 = gen_rtx_REG (<QHI:MODE>mode, REGNO (tmp));\n-\n-      emit_insn (gen_fixuns_trunc<SFDF:mode>di2 (tmp, src));\n-      emit_move_insn (dest, tmp2);\n-    }\n-  DONE;\n-})\n-\n-;; If -mvsx-small-integer, we can represent the FIX operation directly.  On\n-;; older machines, we have to use an UNSPEC to produce a SImode and move it\n-;; to another location, since SImode is not allowed in vector registers.\n-(define_insn \"*fctiw<u>z_<mode>_smallint\"\n-  [(set (match_operand:SI 0 \"vsx_register_operand\" \"=d,wi\")\n-\t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"<Ff>,<Fv>\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_P8_VECTOR\"\n-  \"@\n-   fctiw<u>z %0,%1\n-   xscvdp<su>xws %x0,%x1\"\n-  [(set_attr \"type\" \"fp\")])\n-\n-;; Combiner pattern to prevent moving the result of converting a floating point\n-;; value to 32-bit integer to GPR in order to save it.\n-(define_insn_and_split \"*fctiw<u>z_<mode>_mem\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(any_fix:SI (match_operand:SFDF 1 \"gpc_reg_operand\" \"wa\")))\n-   (clobber (match_scratch:SI 2 \"=wa\"))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && TARGET_P8_VECTOR\"\n-  \"#\"\n-  \"&& reload_completed\"\n-  [(set (match_dup 2)\n-\t(any_fix:SI (match_dup 1)))\n-   (set (match_dup 0)\n-\t(match_dup 2))])\n-\n ;; Here, we use (set (reg) (unspec:DI [(fix:SI ...)] UNSPEC_FCTIWZ))\n ;; rather than (set (subreg:SI (reg)) (fix:SI ...))\n ;; because the first makes it clear that operand 0 is not live\n@@ -14362,49 +14313,45 @@\n    (set_attr \"length\" \"8\")])\n \n ;; Conversion between IEEE 128-bit and integer types\n-(define_insn \"fix_<mode>di2_hw\"\n-  [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n-\t(fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n-  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqpsdz %0,%1\"\n-  [(set_attr \"type\" \"vecfloat\")\n-   (set_attr \"size\" \"128\")])\n-\n-(define_insn \"fixuns_<mode>di2_hw\"\n-  [(set (match_operand:DI 0 \"altivec_register_operand\" \"=v\")\n-\t(unsigned_fix:DI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n-  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqpudz %0,%1\"\n-  [(set_attr \"type\" \"vecfloat\")\n-   (set_attr \"size\" \"128\")])\n \n-(define_insn \"fix_<mode>si2_hw\"\n-  [(set (match_operand:SI 0 \"altivec_register_operand\" \"=v\")\n-\t(fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n-  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqpswz %0,%1\"\n+;; The fix function for DImode and SImode was declared earlier as a\n+;; define_expand.  It calls into rs6000_expand_float128_convert if we don't\n+;; have IEEE 128-bit hardware support.  QImode and HImode are not provided\n+;; unless we have the IEEE 128-bit hardware.\n+;;\n+;; Unlike the code for converting SFmode/DFmode to QImode/HImode, we don't have\n+;; to provide a GPR target that used direct move and a conversion in the GPR\n+;; which works around QImode/HImode not being allowed in vector registers in\n+;; ISA 2.07 (power8).\n+(define_insn \"fix<uns>_<IEEE128:mode><SDI:mode>2_hw\"\n+  [(set (match_operand:SDI 0 \"altivec_register_operand\" \"=v\")\n+\t(any_fix:SDI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)\"\n+  \"xscvqp<su><wd>z %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")\n    (set_attr \"size\" \"128\")])\n \n-(define_insn \"fixuns_<mode>si2_hw\"\n-  [(set (match_operand:SI 0 \"altivec_register_operand\" \"=v\")\n-\t(unsigned_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n-  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n-  \"xscvqpuwz %0,%1\"\n+(define_insn \"fix<uns>_trunc<IEEE128:mode><QHI:mode>2\"\n+  [(set (match_operand:QHI 0 \"altivec_register_operand\" \"=v\")\n+\t(any_fix:QHI\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))]\n+  \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<IEEE128:MODE>mode)\"\n+  \"xscvqp<su>wz %0,%1\"\n   [(set_attr \"type\" \"vecfloat\")\n    (set_attr \"size\" \"128\")])\n \n-;; Combiner pattern to prevent moving the result of converting an IEEE 128-bit\n-;; floating point value to 32-bit integer to GPR in order to save it.\n-(define_insn_and_split \"*fix<uns>_<mode>_mem\"\n-  [(set (match_operand:SI 0 \"memory_operand\" \"=Z\")\n-\t(any_fix:SI (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))\n-   (clobber (match_scratch:SI 2 \"=v\"))]\n+;; Combiner patterns to prevent moving the result of converting an IEEE 128-bit\n+;; floating point value to 8/16/32-bit integer to GPR in order to save it.\n+(define_insn_and_split \"*fix<uns>_trunc<IEEE128:mode><QHSI:mode>2_mem\"\n+  [(set (match_operand:QHSI 0 \"memory_operand\" \"=Z\")\n+\t(any_fix:QHSI\n+\t (match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")))\n+   (clobber (match_scratch:QHSI 2 \"=v\"))]\n   \"TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 2)\n-\t(any_fix:SI (match_dup 1)))\n+\t(any_fix:QHSI (match_dup 1)))\n    (set (match_dup 0)\n \t(match_dup 2))])\n "}, {"sha": "3b61a96799869c6eabe4ede885e40e63492daa63", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -1,3 +1,10 @@\n+2018-02-07  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/84154\n+\t* gcc.target/powerpc/pr84154-1.c: New tests.\n+\t* gcc.target/powerpc/pr84154-2.c: Likewise.\n+\t* gcc.target/powerpc/pr84154-3.c: Likewise.\n+\n 2018-02-07  Will Schmidt  <will_schmidt@vnet.ibm.com>\n \n \t* gcc.target/powerpc/builtins-mergew-mergeow.c:  Update dg-requires."}, {"sha": "c7c61be0defa45bffda40953f163244f4419d1fa", "filename": "gcc/testsuite/gcc.target/powerpc/pr84154-1.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-1.c?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-options \"-mpower8-vector -O2\" } */\n+\n+/* PR target/84154.  Make sure conversion to char/short does not generate a\n+   store and a load on ISA 2.07 and newer systems.  */\n+\n+unsigned char\n+double_to_uc (double x)\n+{\n+  return x;\n+}\n+\n+signed char\n+double_to_sc (double x)\n+{\n+  return x;\n+}\n+\n+unsigned short\n+double_to_us (double x)\n+{\n+  return x;\n+}\n+\n+short\n+double_to_ss (double x)\n+{\n+  return x;\n+}\n+\n+unsigned int\n+double_to_ui (double x)\n+{\n+  return x;\n+}\n+\n+int\n+double_to_si (double x)\n+{\n+  return x;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mextsb\\M}                  1 } } */\n+/* { dg-final { scan-assembler-times {\\mextsh\\M}                  1 } } */\n+/* { dg-final { scan-assembler-times {\\mfctiwuz\\M|\\mxscvdpuxws\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mfctiwz\\M|\\mxscvdpsxws\\M}  3 } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrwz\\M}                6 } } */\n+/* { dg-final { scan-assembler-times {\\mrlwinm\\M}                 2 } } */\n+/* { dg-final { scan-assembler-not   {\\mlbz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlhz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlha\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}                   } } */\n+/* { dg-final { scan-assembler-not   {\\mstw\\M}                      } } */"}, {"sha": "619777ce8dd301824082c9d6ed7ba4cdbffb2cf7", "filename": "gcc/testsuite/gcc.target/powerpc/pr84154-2.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-2.c?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_p8vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-options \"-mcpu=power8 -O2\" } */\n+\n+/* PR target/84154.  Make sure on ISA 2.07 (power8) that we store the result of\n+   a conversion to char/short using an offsettable address does not generate\n+   direct moves for storing 32-bit integers, but does do a direct move for\n+   8/16-bit integers.  */\n+\n+void\n+double_to_uc (double x, unsigned char *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_sc (double x, signed char *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_us (double x, unsigned short *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_ss (double x, short *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_ui (double x, unsigned int *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_si (double x, int *p)\n+{\n+  p[3] = x;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\mfctiwuz\\M|\\mxscvdpuxws\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mfctiwz\\M|\\mxscvdpsxws\\M}  3 } } */\n+/* { dg-final { scan-assembler-times {\\mmfvsrwz\\M}                4 } } */\n+/* { dg-final { scan-assembler-times {\\mstfiwx\\M|\\mstxsiwx\\M}     2 } } */\n+/* { dg-final { scan-assembler-times {\\mstb\\M}                    2 } } */\n+/* { dg-final { scan-assembler-times {\\msth\\M}                    2 } } */\n+/* { dg-final { scan-assembler-not   {\\mlbz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlhz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlha\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}                   } } */\n+/* { dg-final { scan-assembler-not   {\\mstw\\M}                      } } */"}, {"sha": "0361e2f1b517778642e5f44e5eb884441dd7caaa", "filename": "gcc/testsuite/gcc.target/powerpc/pr84154-3.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4253435ecaf28bfc387407dd5a2fb4f4283ed203/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr84154-3.c?ref=4253435ecaf28bfc387407dd5a2fb4f4283ed203", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"\" { powerpc*-*-darwin* } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-options \"-mcpu=power9 -O2\" } */\n+\n+/* PR target/84154.  Make sure on ISA 3.0 we store the result of a conversion\n+   to char/short using an offsettable address does not generate direct moves\n+   for storing 8/16/32-bit integers.  */\n+\n+void\n+double_to_uc (double x, unsigned char *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_sc (double x, signed char *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_us (double x, unsigned short *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_ss (double x, short *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_ui (double x, unsigned int *p)\n+{\n+  p[3] = x;\n+}\n+\n+void\n+double_to_si (double x, int *p)\n+{\n+  p[3] = x;\n+}\n+\n+/* { dg-final { scan-assembler-times {\\maddi\\M}                   6 } } */\n+/* { dg-final { scan-assembler-times {\\mfctiwuz\\M|\\mxscvdpuxws\\M} 3 } } */\n+/* { dg-final { scan-assembler-times {\\mfctiwz\\M|\\mxscvdpsxws\\M}  3 } } */\n+/* { dg-final { scan-assembler-times {\\mstfiwx\\M|\\mstxsiwx\\M}     2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxsibx\\M}                2 } } */\n+/* { dg-final { scan-assembler-times {\\mstxsihx\\M}                2 } } */\n+/* { dg-final { scan-assembler-not   {\\mlbz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlhz\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mlha\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrwz\\M}                  } } */\n+/* { dg-final { scan-assembler-not   {\\mmfvsrd\\M}                   } } */\n+/* { dg-final { scan-assembler-not   {\\mstw\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\mstb\\M}                      } } */\n+/* { dg-final { scan-assembler-not   {\\msth\\M}                      } } */"}]}