{"sha": "752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzUyY2RjNGUyOWMyMDQ5YTBmNGM5ZWMxYmI5NTIyYjdjMzIzYWExNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-10-10T11:42:55Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-10-10T11:42:55Z"}, "message": "modulo-sched.c (ps_reg_move_info): Add num_consecutive_stages.\n\ngcc/\n\t* modulo-sched.c (ps_reg_move_info): Add num_consecutive_stages.\n\t(SCHED_FIRST_REG_MOVE, SCHED_NREG_MOVES): Delete.\n\t(node_sched_params): Remove first_reg_move and nreg_moves.\n\t(ps_num_consecutive_stages, extend_node_sched_params): New functions.\n\t(update_node_sched_params): Move up file.\n\t(print_node_sched_params): Print the stage.  Don't dump info related\n\tto first_reg_move and nreg_moves.\n\t(set_columns_for_row): New function.\n\t(set_columns_for_ps): Move up file and use set_columns_for_row.\n\t(schedule_reg_move): New function.\n\t(schedule_reg_moves): Call extend_node_sched_params and\n\tschedule_reg_move.  Extend size of uses bitmap.  Initialize\n\tnum_consecutive_stages.  Return false if a move could not be\n\tscheduled.\n\t(apply_reg_moves): Don't emit moves here.\n\t(permute_partial_schedule): Handle register moves.\n\t(duplicate_insns_of_cycles): Remove for_prolog.  Emit moves according\n\tto the same stage-count test as ddg nodes.\n\t(generate_prolog_epilog): Update calls accordingly.\n\t(sms_schedule): Allow move-scheduling to add a new first stage.\n\nFrom-SVN: r179744", "tree": {"sha": "d08c11dd8e2aa1b0cc7db6e3dc9312b780d7f84b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d08c11dd8e2aa1b0cc7db6e3dc9312b780d7f84b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14/comments", "author": null, "committer": null, "parents": [{"sha": "1287d8ea2c76801a0e29f4afbb0cb9449343696c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1287d8ea2c76801a0e29f4afbb0cb9449343696c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1287d8ea2c76801a0e29f4afbb0cb9449343696c"}], "stats": {"total": 410, "additions": 294, "deletions": 116}, "files": [{"sha": "1a29ef3b61770b463254ef8b000c195fa57a42ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "patch": "@@ -1,3 +1,26 @@\n+2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* modulo-sched.c (ps_reg_move_info): Add num_consecutive_stages.\n+\t(SCHED_FIRST_REG_MOVE, SCHED_NREG_MOVES): Delete.\n+\t(node_sched_params): Remove first_reg_move and nreg_moves.\n+\t(ps_num_consecutive_stages, extend_node_sched_params): New functions.\n+\t(update_node_sched_params): Move up file.\n+\t(print_node_sched_params): Print the stage.  Don't dump info related\n+\tto first_reg_move and nreg_moves.\n+\t(set_columns_for_row): New function.\n+\t(set_columns_for_ps): Move up file and use set_columns_for_row.\n+\t(schedule_reg_move): New function.\n+\t(schedule_reg_moves): Call extend_node_sched_params and\n+\tschedule_reg_move.  Extend size of uses bitmap.  Initialize\n+\tnum_consecutive_stages.  Return false if a move could not be\n+\tscheduled.\n+\t(apply_reg_moves): Don't emit moves here.\n+\t(permute_partial_schedule): Handle register moves.\n+\t(duplicate_insns_of_cycles): Remove for_prolog.  Emit moves according\n+\tto the same stage-count test as ddg nodes.\n+\t(generate_prolog_epilog): Update calls accordingly.\n+\t(sms_schedule): Allow move-scheduling to add a new first stage.\n+\n 2011-10-10  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* modulo-sched.c (ps_insn): Adjust comment."}, {"sha": "d12f53b5ebe06683f025da2da32d4caadc1f5534", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 271, "deletions": 116, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=752cdc4e29c2049a0f4c9ec1bb9522b7c323aa14", "patch": "@@ -153,6 +153,9 @@ struct ps_reg_move_info\n   rtx old_reg;\n   rtx new_reg;\n \n+  /* The number of consecutive stages that the move occupies.  */\n+  int num_consecutive_stages;\n+\n   /* An instruction that sets NEW_REG to the correct value.  The first\n      move associated with DEF will have an rhs of OLD_REG; later moves\n      use the result of the previous move.  */\n@@ -218,8 +221,6 @@ static partial_schedule_ptr sms_schedule_by_order (ddg_ptr, int, int, int *);\n static void permute_partial_schedule (partial_schedule_ptr, rtx);\n static void generate_prolog_epilog (partial_schedule_ptr, struct loop *,\n                                     rtx, rtx);\n-static void duplicate_insns_of_cycles (partial_schedule_ptr,\n-\t\t\t\t       int, int, int, rtx);\n static int calculate_stage_count (partial_schedule_ptr, int);\n static void calculate_must_precede_follow (ddg_node_ptr, int, int,\n \t\t\t\t\t   int, int, sbitmap, sbitmap, sbitmap);\n@@ -233,8 +234,6 @@ static void remove_node_from_ps (partial_schedule_ptr, ps_insn_ptr);\n \n #define SCHED_PARAMS(x) VEC_index (node_sched_params, node_sched_param_vec, x)\n #define SCHED_TIME(x) (SCHED_PARAMS (x)->time)\n-#define SCHED_FIRST_REG_MOVE(x) (SCHED_PARAMS (x)->first_reg_move)\n-#define SCHED_NREG_MOVES(x) (SCHED_PARAMS (x)->nreg_moves)\n #define SCHED_ROW(x) (SCHED_PARAMS (x)->row)\n #define SCHED_STAGE(x) (SCHED_PARAMS (x)->stage)\n #define SCHED_COLUMN(x) (SCHED_PARAMS (x)->column)\n@@ -244,15 +243,6 @@ typedef struct node_sched_params\n {\n   int time;\t/* The absolute scheduling cycle.  */\n \n-  /* The following field (first_reg_move) is the ps_insn id of the first\n-     register-move instruction added to handle the modulo-variable-expansion\n-     of the register defined by this node.  This register-move copies the\n-     original register defined by the node.  */\n-  int first_reg_move;\n-\n-  /* The number of register-move instructions added.  */\n-  int nreg_moves;\n-\n   int row;    /* Holds time % ii.  */\n   int stage;  /* Holds time / ii.  */\n \n@@ -344,6 +334,17 @@ ps_first_note (partial_schedule_ptr ps, int id)\n   return ps->g->nodes[id].first_note;\n }\n \n+/* Return the number of consecutive stages that are occupied by\n+   partial schedule instruction ID in PS.  */\n+static int\n+ps_num_consecutive_stages (partial_schedule_ptr ps, int id)\n+{\n+  if (id < ps->g->num_nodes)\n+    return 1;\n+  else\n+    return ps_reg_move (ps, id)->num_consecutive_stages;\n+}\n+\n /* Given HEAD and TAIL which are the first and last insns in a loop;\n    return the register which controls the loop.  Return zero if it has\n    more than one occurrence in the loop besides the control part or the\n@@ -456,6 +457,45 @@ set_node_sched_params (ddg_ptr g)\n \t\t\t node_sched_param_vec, g->num_nodes);\n }\n \n+/* Make sure that node_sched_param_vec has an entry for every move in PS.  */\n+static void\n+extend_node_sched_params (partial_schedule_ptr ps)\n+{\n+  VEC_safe_grow_cleared (node_sched_params, heap, node_sched_param_vec,\n+\t\t\t ps->g->num_nodes + VEC_length (ps_reg_move_info,\n+\t\t\t\t\t\t\tps->reg_moves));\n+}\n+\n+/* Update the sched_params (time, row and stage) for node U using the II,\n+   the CYCLE of U and MIN_CYCLE.\n+   We're not simply taking the following\n+   SCHED_STAGE (u) = CALC_STAGE_COUNT (SCHED_TIME (u), min_cycle, ii);\n+   because the stages may not be aligned on cycle 0.  */\n+static void\n+update_node_sched_params (int u, int ii, int cycle, int min_cycle)\n+{\n+  int sc_until_cycle_zero;\n+  int stage;\n+\n+  SCHED_TIME (u) = cycle;\n+  SCHED_ROW (u) = SMODULO (cycle, ii);\n+\n+  /* The calculation of stage count is done adding the number\n+     of stages before cycle zero and after cycle zero.  */\n+  sc_until_cycle_zero = CALC_STAGE_COUNT (-1, min_cycle, ii);\n+\n+  if (SCHED_TIME (u) < 0)\n+    {\n+      stage = CALC_STAGE_COUNT (-1, SCHED_TIME (u), ii);\n+      SCHED_STAGE (u) = sc_until_cycle_zero - stage;\n+    }\n+  else\n+    {\n+      stage = CALC_STAGE_COUNT (SCHED_TIME (u), 0, ii);\n+      SCHED_STAGE (u) = sc_until_cycle_zero + stage - 1;\n+    }\n+}\n+\n static void\n print_node_sched_params (FILE *file, int num_nodes, partial_schedule_ptr ps)\n {\n@@ -466,21 +506,169 @@ print_node_sched_params (FILE *file, int num_nodes, partial_schedule_ptr ps)\n   for (i = 0; i < num_nodes; i++)\n     {\n       node_sched_params_ptr nsp = SCHED_PARAMS (i);\n-      int j;\n \n       fprintf (file, \"Node = %d; INSN = %d\\n\", i,\n \t       INSN_UID (ps_rtl_insn (ps, i)));\n       fprintf (file, \" asap = %d:\\n\", NODE_ASAP (&ps->g->nodes[i]));\n       fprintf (file, \" time = %d:\\n\", nsp->time);\n-      fprintf (file, \" nreg_moves = %d:\\n\", nsp->nreg_moves);\n-      for (j = 0; j < nsp->nreg_moves; j++)\n-\t{\n-\t  ps_reg_move_info *move = ps_reg_move (ps, nsp->first_reg_move + j);\n+      fprintf (file, \" stage = %d:\\n\", nsp->stage);\n+    }\n+}\n+\n+/* Set SCHED_COLUMN for each instruction in row ROW of PS.  */\n+static void\n+set_columns_for_row (partial_schedule_ptr ps, int row)\n+{\n+  ps_insn_ptr cur_insn;\n+  int column;\n+\n+  column = 0;\n+  for (cur_insn = ps->rows[row]; cur_insn; cur_insn = cur_insn->next_in_row)\n+    SCHED_COLUMN (cur_insn->id) = column++;\n+}\n+\n+/* Set SCHED_COLUMN for each instruction in PS.  */\n+static void\n+set_columns_for_ps (partial_schedule_ptr ps)\n+{\n+  int row;\n+\n+  for (row = 0; row < ps->ii; row++)\n+    set_columns_for_row (ps, row);\n+}\n+\n+/* Try to schedule the move with ps_insn identifier I_REG_MOVE in PS.\n+   Its single predecessor has already been scheduled, as has its\n+   ddg node successors.  (The move may have also another move as its\n+   successor, in which case that successor will be scheduled later.)\n+\n+   The move is part of a chain that satisfies register dependencies\n+   between a producing ddg node and various consuming ddg nodes.\n+   If some of these dependencies have a distance of 1 (meaning that\n+   the use is upward-exposoed) then DISTANCE1_USES is nonnull and\n+   contains the set of uses with distance-1 dependencies.\n+   DISTANCE1_USES is null otherwise.\n+\n+   MUST_FOLLOW is a scratch bitmap that is big enough to hold\n+   all current ps_insn ids.\n+\n+   Return true on success.  */\n+static bool\n+schedule_reg_move (partial_schedule_ptr ps, int i_reg_move,\n+\t\t   sbitmap distance1_uses, sbitmap must_follow)\n+{\n+  unsigned int u;\n+  int this_time, this_distance, this_start, this_end, this_latency;\n+  int start, end, c, ii;\n+  sbitmap_iterator sbi;\n+  ps_reg_move_info *move;\n+  rtx this_insn;\n+  ps_insn_ptr psi;\n+\n+  move = ps_reg_move (ps, i_reg_move);\n+  ii = ps->ii;\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Scheduling register move INSN %d; ii = %d\"\n+\t       \", min cycle = %d\\n\\n\", INSN_UID (move->insn), ii,\n+\t       PS_MIN_CYCLE (ps));\n+      print_rtl_single (dump_file, move->insn);\n+      fprintf (dump_file, \"\\n%11s %11s %5s\\n\", \"start\", \"end\", \"time\");\n+      fprintf (dump_file, \"=========== =========== =====\\n\");\n+    }\n+\n+  start = INT_MIN;\n+  end = INT_MAX;\n+\n+  /* For dependencies of distance 1 between a producer ddg node A\n+     and consumer ddg node B, we have a chain of dependencies:\n+\n+        A --(T,L1,1)--> M1 --(T,L2,0)--> M2 ... --(T,Ln,0)--> B\n+\n+     where Mi is the ith move.  For dependencies of distance 0 between\n+     a producer ddg node A and consumer ddg node C, we have a chain of\n+     dependencies:\n+\n+        A --(T,L1',0)--> M1' --(T,L2',0)--> M2' ... --(T,Ln',0)--> C\n+\n+     where Mi' occupies the same position as Mi but occurs a stage later.\n+     We can only schedule each move once, so if we have both types of\n+     chain, we model the second as:\n+\n+        A --(T,L1',1)--> M1 --(T,L2',0)--> M2 ... --(T,Ln',-1)--> C\n \n-\t  fprintf (file, \" reg_move = \");\n-\t  print_rtl_single (file, move->insn);\n+     First handle the dependencies between the previously-scheduled\n+     predecessor and the move.  */\n+  this_insn = ps_rtl_insn (ps, move->def);\n+  this_latency = insn_latency (this_insn, move->insn);\n+  this_distance = distance1_uses && move->def < ps->g->num_nodes ? 1 : 0;\n+  this_time = SCHED_TIME (move->def) - this_distance * ii;\n+  this_start = this_time + this_latency;\n+  this_end = this_time + ii;\n+  if (dump_file)\n+    fprintf (dump_file, \"%11d %11d %5d %d --(T,%d,%d)--> %d\\n\",\n+\t     this_start, this_end, SCHED_TIME (move->def),\n+\t     INSN_UID (this_insn), this_latency, this_distance,\n+\t     INSN_UID (move->insn));\n+\n+  if (start < this_start)\n+    start = this_start;\n+  if (end > this_end)\n+    end = this_end;\n+\n+  /* Handle the dependencies between the move and previously-scheduled\n+     successors.  */\n+  EXECUTE_IF_SET_IN_SBITMAP (move->uses, 0, u, sbi)\n+    {\n+      this_insn = ps_rtl_insn (ps, u);\n+      this_latency = insn_latency (move->insn, this_insn);\n+      if (distance1_uses && !TEST_BIT (distance1_uses, u))\n+\tthis_distance = -1;\n+      else\n+\tthis_distance = 0;\n+      this_time = SCHED_TIME (u) + this_distance * ii;\n+      this_start = this_time - ii;\n+      this_end = this_time - this_latency;\n+      if (dump_file)\n+\tfprintf (dump_file, \"%11d %11d %5d %d --(T,%d,%d)--> %d\\n\",\n+\t\t this_start, this_end, SCHED_TIME (u), INSN_UID (move->insn),\n+\t\t this_latency, this_distance, INSN_UID (this_insn));\n+\n+      if (start < this_start)\n+\tstart = this_start;\n+      if (end > this_end)\n+\tend = this_end;\n+    }\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"----------- ----------- -----\\n\");\n+      fprintf (dump_file, \"%11d %11d %5s %s\\n\", start, end, \"\", \"(max, min)\");\n+    }\n+\n+  sbitmap_zero (must_follow);\n+  SET_BIT (must_follow, move->def);\n+\n+  start = MAX (start, end - (ii - 1));\n+  for (c = end; c >= start; c--)\n+    {\n+      psi = ps_add_node_check_conflicts (ps, i_reg_move, c,\n+\t\t\t\t\t move->uses, must_follow);\n+      if (psi)\n+\t{\n+\t  update_node_sched_params (i_reg_move, ii, c, PS_MIN_CYCLE (ps));\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"\\nScheduled register move INSN %d at\"\n+\t\t     \" time %d, row %d\\n\\n\", INSN_UID (move->insn), c,\n+\t\t     SCHED_ROW (i_reg_move));\n+\t  return true;\n \t}\n     }\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"\\nNo available slot\\n\\n\");\n+\n+  return false;\n }\n \n /*\n@@ -508,6 +696,9 @@ schedule_reg_moves (partial_schedule_ptr ps)\n       int nreg_moves = 0, i_reg_move;\n       rtx prev_reg, old_reg;\n       int first_move;\n+      int distances[2];\n+      sbitmap must_follow;\n+      sbitmap distance1_uses;\n       rtx set = single_set (u->insn);\n       \n       /* Skip instructions that do not set a register.  */\n@@ -516,6 +707,7 @@ schedule_reg_moves (partial_schedule_ptr ps)\n  \n       /* Compute the number of reg_moves needed for u, by looking at life\n \t ranges started at u (excluding self-loops).  */\n+      distances[0] = distances[1] = false;\n       for (e = u->out; e; e = e->next_out)\n \tif (e->type == TRUE_DEP && e->dest != e->src)\n \t  {\n@@ -546,6 +738,11 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t\tgcc_assert (!autoinc_var_is_used_p (u->insn, e->dest->insn));\n \t      }\n \t    \n+\t    if (nreg_moves4e)\n+\t      {\n+\t\tgcc_assert (e->distance < 2);\n+\t\tdistances[e->distance] = true;\n+\t      }\n \t    nreg_moves = MAX (nreg_moves, nreg_moves4e);\n \t  }\n \n@@ -556,11 +753,10 @@ schedule_reg_moves (partial_schedule_ptr ps)\n       first_move = VEC_length (ps_reg_move_info, ps->reg_moves);\n       VEC_safe_grow_cleared (ps_reg_move_info, heap, ps->reg_moves,\n \t\t\t     first_move + nreg_moves);\n+      extend_node_sched_params (ps);\n \n       /* Record the moves associated with this node.  */\n       first_move += ps->g->num_nodes;\n-      SCHED_FIRST_REG_MOVE (i) = first_move;\n-      SCHED_NREG_MOVES (i) = nreg_moves;\n \n       /* Generate each move.  */\n       old_reg = prev_reg = SET_DEST (single_set (u->insn));\n@@ -569,15 +765,18 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \t  ps_reg_move_info *move = ps_reg_move (ps, first_move + i_reg_move);\n \n \t  move->def = i_reg_move > 0 ? first_move + i_reg_move - 1 : i;\n-\t  move->uses = sbitmap_alloc (g->num_nodes);\n+\t  move->uses = sbitmap_alloc (first_move + nreg_moves);\n \t  move->old_reg = old_reg;\n \t  move->new_reg = gen_reg_rtx (GET_MODE (prev_reg));\n+\t  move->num_consecutive_stages = distances[0] && distances[1] ? 2 : 1;\n \t  move->insn = gen_move_insn (move->new_reg, copy_rtx (prev_reg));\n \t  sbitmap_zero (move->uses);\n \n \t  prev_reg = move->new_reg;\n \t}\n \n+      distance1_uses = distances[1] ? sbitmap_alloc (g->num_nodes) : NULL;\n+\n       /* Every use of the register defined by node may require a different\n \t copy of this register, depending on the time the use is scheduled.\n \t Record which uses require which move results.  */\n@@ -601,8 +800,21 @@ schedule_reg_moves (partial_schedule_ptr ps)\n \n \t\tmove = ps_reg_move (ps, first_move + dest_copy - 1);\n \t\tSET_BIT (move->uses, e->dest->cuid);\n+\t\tif (e->distance == 1)\n+\t\t  SET_BIT (distance1_uses, e->dest->cuid);\n \t      }\n \t  }\n+\n+      must_follow = sbitmap_alloc (first_move + nreg_moves);\n+      for (i_reg_move = 0; i_reg_move < nreg_moves; i_reg_move++)\n+\tif (!schedule_reg_move (ps, first_move + i_reg_move,\n+\t\t\t\tdistance1_uses, must_follow))\n+\t  break;\n+      sbitmap_free (must_follow);\n+      if (distance1_uses)\n+\tsbitmap_free (distance1_uses);\n+      if (i_reg_move < nreg_moves)\n+\treturn false;\n     }\n   return true;\n }\n@@ -626,39 +838,6 @@ apply_reg_moves (partial_schedule_ptr ps)\n \t  df_insn_rescan (ps->g->nodes[i_use].insn);\n \t}\n     }\n-\n-  FOR_EACH_VEC_ELT (ps_reg_move_info, ps->reg_moves, i, move)\n-    add_insn_before (move->insn, ps_first_note (ps, move->def), NULL);\n-}\n-\n-/* Update the sched_params (time, row and stage) for node U using the II,\n-   the CYCLE of U and MIN_CYCLE.  \n-   We're not simply taking the following\n-   SCHED_STAGE (u) = CALC_STAGE_COUNT (SCHED_TIME (u), min_cycle, ii);\n-   because the stages may not be aligned on cycle 0.  */\n-static void\n-update_node_sched_params (int u, int ii, int cycle, int min_cycle)\n-{\n-  int sc_until_cycle_zero;\n-  int stage;\n-\n-  SCHED_TIME (u) = cycle;\n-  SCHED_ROW (u) = SMODULO (cycle, ii);\n-\n-  /* The calculation of stage count is done adding the number\n-     of stages before cycle zero and after cycle zero.  */\n-  sc_until_cycle_zero = CALC_STAGE_COUNT (-1, min_cycle, ii);\n-\n-  if (SCHED_TIME (u) < 0)\n-    {\n-      stage = CALC_STAGE_COUNT (-1, SCHED_TIME (u), ii);\n-      SCHED_STAGE (u) = sc_until_cycle_zero - stage;\n-    }\n-  else\n-    {\n-      stage = CALC_STAGE_COUNT (SCHED_TIME (u), 0, ii);\n-      SCHED_STAGE (u) = sc_until_cycle_zero + stage - 1;\n-    }\n }\n \n /* Bump the SCHED_TIMEs of all nodes by AMOUNT.  Set the values of\n@@ -699,22 +878,6 @@ reset_sched_times (partial_schedule_ptr ps, int amount)\n       }\n }\n  \n-/* Set SCHED_COLUMN of each node according to its position in PS.  */\n-static void\n-set_columns_for_ps (partial_schedule_ptr ps)\n-{\n-  int row;\n-\n-  for (row = 0; row < ps->ii; row++)\n-    {\n-      ps_insn_ptr cur_insn = ps->rows[row];\n-      int column = 0;\n-\n-      for (; cur_insn; cur_insn = cur_insn->next_in_row)\n-\tSCHED_COLUMN (cur_insn->id) = column++;\n-    }\n-}\n-\n /* Permute the insns according to their order in PS, from row 0 to\n    row ii-1, and position them right before LAST.  This schedules\n    the insns of the loop kernel.  */\n@@ -731,8 +894,13 @@ permute_partial_schedule (partial_schedule_ptr ps, rtx last)\n \trtx insn = ps_rtl_insn (ps, ps_ij->id);\n \n \tif (PREV_INSN (last) != insn)\n-\t  reorder_insns_nobb (ps_first_note (ps, ps_ij->id), insn,\n-\t\t\t      PREV_INSN (last));\n+\t  {\n+\t    if (ps_ij->id < ps->g->num_nodes)\n+\t      reorder_insns_nobb (ps_first_note (ps, ps_ij->id), insn,\n+\t\t\t\t  PREV_INSN (last));\n+\t    else\n+\t      add_insn_before (insn, last, NULL);\n+\t  }\n       }\n }\n \n@@ -935,7 +1103,7 @@ optimize_sc (partial_schedule_ptr ps, ddg_ptr g)\n \n static void\n duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n-\t\t\t   int to_stage, int for_prolog, rtx count_reg)\n+\t\t\t   int to_stage, rtx count_reg)\n {\n   int row;\n   ps_insn_ptr ps_ij;\n@@ -944,7 +1112,7 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n     for (ps_ij = ps->rows[row]; ps_ij; ps_ij = ps_ij->next_in_row)\n       {\n \tint u = ps_ij->id;\n-\tint j, i_reg_moves, i_reg_move;\n+\tint first_u, last_u;\n \trtx u_insn;\n \n         /* Do not duplicate any insn which refers to count_reg as it\n@@ -958,42 +1126,15 @@ duplicate_insns_of_cycles (partial_schedule_ptr ps, int from_stage,\n             || JUMP_P (u_insn))\n           continue;\n \n-\tif (for_prolog)\n-\t  {\n-\t    /* SCHED_STAGE (u) >= from_stage == 0.  Generate increasing\n-\t       number of reg_moves starting with the second occurrence of\n-\t       u, which is generated if its SCHED_STAGE <= to_stage.  */\n-\t    i_reg_moves = to_stage - SCHED_STAGE (u) + 1;\n-\t    i_reg_moves = MAX (i_reg_moves, 0);\n-\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n-\n-\t    /* The reg_moves start from the *first* reg_move backwards.  */\n-\t    i_reg_move = SCHED_FIRST_REG_MOVE (u) + (i_reg_moves - 1);\n-\t  }\n-\telse /* It's for the epilog.  */\n-\t  {\n-\t    /* SCHED_STAGE (u) <= to_stage.  Generate all reg_moves,\n-\t       starting to decrease one stage after u no longer occurs;\n-\t       that is, generate all reg_moves until\n-\t       SCHED_STAGE (u) == from_stage - 1.  */\n-\t    i_reg_moves = (SCHED_NREG_MOVES (u)\n-\t\t\t   - (from_stage - SCHED_STAGE (u) - 1));\n-\t    i_reg_moves = MAX (i_reg_moves, 0);\n-\t    i_reg_moves = MIN (i_reg_moves, SCHED_NREG_MOVES (u));\n-\n-\t    /* The reg_moves start from the *last* reg_move forwards.  */\n-\t    i_reg_move = SCHED_FIRST_REG_MOVE (u) + (SCHED_NREG_MOVES (u) - 1);\n-\t  }\n-\n-\tfor (j = 0; j < i_reg_moves; j++)\n+\tfirst_u = SCHED_STAGE (u);\n+\tlast_u = first_u + ps_num_consecutive_stages (ps, u) - 1;\n+\tif (from_stage <= last_u && to_stage >= first_u)\n \t  {\n-\t    ps_reg_move_info *move = ps_reg_move (ps, i_reg_move - j);\n-\n-\t    emit_insn (copy_rtx (PATTERN (move->insn)));\n+\t    if (u < ps->g->num_nodes)\n+\t      duplicate_insn_chain (ps_first_note (ps, u), u_insn);\n+\t    else\n+\t      emit_insn (copy_rtx (PATTERN (u_insn)));\n \t  }\n-\tif (SCHED_STAGE (u) >= from_stage\n-\t    && SCHED_STAGE (u) <= to_stage)\n-\t  duplicate_insn_chain (ps_first_note (ps, u), u_insn);\n       }\n }\n \n@@ -1027,7 +1168,7 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n     }\n \n   for (i = 0; i < last_stage; i++)\n-    duplicate_insns_of_cycles (ps, 0, i, 1, count_reg);\n+    duplicate_insns_of_cycles (ps, 0, i, count_reg);\n \n   /* Put the prolog on the entry edge.  */\n   e = loop_preheader_edge (loop);\n@@ -1039,7 +1180,7 @@ generate_prolog_epilog (partial_schedule_ptr ps, struct loop *loop,\n   start_sequence ();\n \n   for (i = 0; i < last_stage; i++)\n-    duplicate_insns_of_cycles (ps, i + 1, last_stage, 0, count_reg);\n+    duplicate_insns_of_cycles (ps, i + 1, last_stage, count_reg);\n \n   /* Put the epilogue on the exit edge.  */\n   gcc_assert (single_exit (loop));\n@@ -1375,8 +1516,7 @@ sms_schedule (void)\n     {\n       rtx head, tail;\n       rtx count_reg, count_init;\n-      int mii, rec_mii;\n-      unsigned stage_count;\n+      int mii, rec_mii, stage_count, min_cycle;\n       HOST_WIDEST_INT loop_count = 0;\n       bool opt_sc_p;\n \n@@ -1486,13 +1626,12 @@ sms_schedule (void)\n \t\t}\n \n \t      gcc_assert (stage_count >= 1);\n-\t      PS_STAGE_COUNT (ps) = stage_count;\n \t    }\n \n \t  /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n \t     1 means that there is no interleaving between iterations thus\n \t     we let the scheduling passes do the job in this case.  */\n-\t  if (stage_count < (unsigned) PARAM_VALUE (PARAM_SMS_MIN_SC)\n+\t  if (stage_count < PARAM_VALUE (PARAM_SMS_MIN_SC)\n \t      || (count_init && (loop_count <= stage_count))\n \t      || (flag_branch_probabilities && (trip_count <= stage_count)))\n \t    {\n@@ -1520,13 +1659,29 @@ sms_schedule (void)\n \t  \n \t  set_columns_for_ps (ps);\n \n+\t  min_cycle = PS_MIN_CYCLE (ps) - SMODULO (PS_MIN_CYCLE (ps), ps->ii);\n \t  if (!schedule_reg_moves (ps))\n \t    {\n \t      mii = ps->ii + 1;\n \t      free_partial_schedule (ps);\n \t      continue;\n \t    }\n \n+\t  /* Moves that handle incoming values might have been added\n+\t     to a new first stage.  Bump the stage count if so.\n+\n+\t     ??? Perhaps we could consider rotating the schedule here\n+\t     instead?  */\n+\t  if (PS_MIN_CYCLE (ps) < min_cycle)\n+\t    {\n+\t      reset_sched_times (ps, 0);\n+\t      stage_count++;\n+\t    }\n+\n+\t  /* The stage count should now be correct without rotation.  */\n+\t  gcc_checking_assert (stage_count == calculate_stage_count (ps, 0));\n+\t  PS_STAGE_COUNT (ps) = stage_count;\n+\n \t  canon_loop (loop);\n \n           if (dump_file)"}]}