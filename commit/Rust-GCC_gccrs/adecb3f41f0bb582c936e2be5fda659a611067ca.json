{"sha": "adecb3f41f0bb582c936e2be5fda659a611067ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWRlY2IzZjQxZjBiYjU4MmM5MzZlMmJlNWZkYTY1OWE2MTEwNjdjYQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-21T15:55:56Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-21T15:55:56Z"}, "message": "Make-lang.in (cc1plus): Make it depend on gxx.gperf.\n\n\t* Make-lang.in (cc1plus): Make it depend on gxx.gperf.\n\t* cp-tree.h: Fix typo in documentation on pointers-to-members.\n\t(cp_build_qualified_type): Make it a macro.\n\t(cp_build_qualified_type_real): Declare.\n\t* decl.c (grokdeclarator): Remove misleading comment.  Avoid\n\tproblem with template parameters and restrict-qualification.\n\t* gxx.gperf: Replace NORID with RID_UNUSED throughout.\n\t* hash.h: Regenerated.\n\t* lex.h (rid): Move RID_FIRST_MODIFIER and RID_LAST_MODIFIER into\n\tthe enumeration.\n\t(NORID): Remove definition.\n\t* pt.c (tsubst_aggr_type): Use cp_build_qualified_type_real.\n\t(tsubst): Likewise.  Remove special handling for FUNCTION_TYPEs.\n\t(fn_type_unification): Check that the function type resulting from\n\tthe deduction is legal.\n\t(check_cv_quals_for_unify): Don't handle FUNCTION_TYPEs specially.\n\t(unify): Use cp_build_qualified_type_real.\n\t* tree.c (build_cplus_array_type_1): Handle error_marks as inputs.\n\t(cp_build_qualified_type): Rename to ...\n\t(cp_build_qualified_type_real): Add additional COMPLAIN parameter\n\tand modify appropriately.\n\nCo-Authored-By: Nathan Sidwell <nathan@acm.org>\n\nFrom-SVN: r27086", "tree": {"sha": "4e92434070d5a41b4f55d72fcc9bd86c081920ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e92434070d5a41b4f55d72fcc9bd86c081920ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/adecb3f41f0bb582c936e2be5fda659a611067ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adecb3f41f0bb582c936e2be5fda659a611067ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/adecb3f41f0bb582c936e2be5fda659a611067ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/adecb3f41f0bb582c936e2be5fda659a611067ca/comments", "author": null, "committer": null, "parents": [{"sha": "7133357a34e813233a8b949ac335e9521c8b8270", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7133357a34e813233a8b949ac335e9521c8b8270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7133357a34e813233a8b949ac335e9521c8b8270"}], "stats": {"total": 396, "additions": 225, "deletions": 171}, "files": [{"sha": "6c64408f1db1e3038da29951480071d63e5adca0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -1,5 +1,28 @@\n 1999-05-21  Mark Mitchell  <mark@codesourcery.com>\n-\n+            Nathan Sidwell  <nathan@acm.org>\n+\t\n+\t* Make-lang.in (cc1plus): Make it depend on gxx.gperf.\n+\t* cp-tree.h: Fix typo in documentation on pointers-to-members.\n+\t(cp_build_qualified_type): Make it a macro.\n+\t(cp_build_qualified_type_real): Declare.\n+\t* decl.c (grokdeclarator): Remove misleading comment.  Avoid\n+\tproblem with template parameters and restrict-qualification.\n+\t* gxx.gperf: Replace NORID with RID_UNUSED throughout.\n+\t* hash.h: Regenerated.\n+\t* lex.h (rid): Move RID_FIRST_MODIFIER and RID_LAST_MODIFIER into\n+\tthe enumeration.\n+\t(NORID): Remove definition.\n+\t* pt.c (tsubst_aggr_type): Use cp_build_qualified_type_real.\n+\t(tsubst): Likewise.  Remove special handling for FUNCTION_TYPEs.\n+\t(fn_type_unification): Check that the function type resulting from\n+\tthe deduction is legal.\n+\t(check_cv_quals_for_unify): Don't handle FUNCTION_TYPEs specially.\n+\t(unify): Use cp_build_qualified_type_real.\n+\t* tree.c (build_cplus_array_type_1): Handle error_marks as inputs.\n+\t(cp_build_qualified_type): Rename to ...\n+\t(cp_build_qualified_type_real): Add additional COMPLAIN parameter\n+\tand modify appropriately.\n+\t\n \t* typeck.c (build_ptrmemfunc): Handle PTRMEM_CSTs carefully to\n \treveal optimization opportunities.\n "}, {"sha": "72795da34993af7b80b52c294fac0a5ad863dc43", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -120,7 +120,7 @@ CXX_SRCS = $(srcdir)/cp/call.c $(srcdir)/cp/decl2.c \\\n  $(srcdir)/cp/repo.c $(srcdir)/cp/semantics.c\n \n cc1plus$(exeext): $(P) $(CXX_SRCS) $(LIBDEPS) stamp-objlist c-common.o c-pragma.o \\\n-\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def hash.o\n+\t$(srcdir)/cp/cp-tree.h $(srcdir)/cp/cp-tree.def $(srcdir)/cp/gxx.gperf hash.o\n \tcd cp; $(MAKE) $(FLAGS_TO_PASS) $(CXX_FLAGS_TO_PASS) ../cc1plus$(exeext)\n #\f\n # Build hooks:"}, {"sha": "b2b6313fd8583ba4bbeefb4d73104f252092bec9", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -1721,7 +1721,7 @@ extern int flag_new_for_scope;\n    non-virtual function.  Of course, `&f__2B2' is the name of that\n    function.\n \n-   (Of course, the exactl values may differ depending on the mangling\n+   (Of course, the exact values may differ depending on the mangling\n    scheme, sizes of types, and such.).  */\n      \n /* Get the POINTER_TYPE to the METHOD_TYPE associated with this\n@@ -2100,7 +2100,6 @@ extern void check_function_format\t\tPROTO((tree, tree, tree));\n /* Print an error message for invalid operands to arith operation CODE.\n    NOP_EXPR is used as a special case (see truthvalue_conversion).  */\n extern void binary_op_error                     PROTO((enum tree_code));\n-extern tree cp_build_qualified_type             PROTO((tree, int));\n extern tree canonical_type_variant              PROTO((tree));\n extern void c_expand_expr_stmt                  PROTO((tree));\n /* Validate the expression after `case' and apply default promotions.  */\n@@ -3387,6 +3386,9 @@ extern int is_dummy_object\t\t\tPROTO((tree));\n extern tree search_tree                         PROTO((tree, tree (*)(tree)));\n extern int cp_valid_lang_attribute\t\tPROTO((tree, tree, tree, tree));\n extern tree make_ptrmem_cst                     PROTO((tree, tree));\n+extern tree cp_build_qualified_type_real        PROTO((tree, int, int));\n+#define cp_build_qualified_type(TYPE, QUALS) \\\n+  cp_build_qualified_type_real ((TYPE), (QUALS), /*complain=*/1)\n \n #define scratchalloc expralloc\n #define scratch_tree_cons expr_tree_cons"}, {"sha": "dd2dbb754b0184f9e765ccd93d9b57154e55c89f", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -11650,9 +11650,11 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n     if (RIDBIT_SETP (RID_STATIC, specbits))\n       DECL_THIS_STATIC (decl) = 1;\n \n-    /* Record constancy and volatility.  */\n-    /* FIXME: Disallow `restrict' pointer-to-member declarations.  */\n-    c_apply_type_quals_to_decl (type_quals, decl);\n+    /* Record constancy and volatility.  There's no need to do this\n+       when processing a template; we'll do this for the instantiated\n+       declaration based on the type of DECL.  */\n+    if (!processing_template_decl)\n+      c_apply_type_quals_to_decl (type_quals, decl);\n \n     return decl;\n   }"}, {"sha": "2134939fed7260ab5dcfa33e9fa02a05186ae5f2", "filename": "gcc/cp/gxx.gperf", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fgxx.gperf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fgxx.gperf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fgxx.gperf?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -3,109 +3,109 @@\n %}\n struct resword { const char *name; short token; enum rid rid;};\n %%\n-__alignof, ALIGNOF, NORID\n-__alignof__, ALIGNOF, NORID\n-__asm, ASM_KEYWORD, NORID\n-__asm__, ASM_KEYWORD, NORID\n-__attribute, ATTRIBUTE, NORID\n-__attribute__, ATTRIBUTE, NORID\n+__alignof, ALIGNOF, RID_UNUSED\n+__alignof__, ALIGNOF, RID_UNUSED\n+__asm, ASM_KEYWORD, RID_UNUSED\n+__asm__, ASM_KEYWORD, RID_UNUSED\n+__attribute, ATTRIBUTE, RID_UNUSED\n+__attribute__, ATTRIBUTE, RID_UNUSED\n __complex, TYPESPEC, RID_COMPLEX\n __complex__, TYPESPEC, RID_COMPLEX\n __const, CV_QUALIFIER, RID_CONST\n __const__, CV_QUALIFIER, RID_CONST\n-__extension__, EXTENSION, NORID\n-__imag, IMAGPART, NORID\n-__imag__, IMAGPART, NORID\n+__extension__, EXTENSION, RID_UNUSED\n+__imag, IMAGPART, RID_UNUSED\n+__imag__, IMAGPART, RID_UNUSED\n __inline, SCSPEC, RID_INLINE\n __inline__, SCSPEC, RID_INLINE\n-__label__, LABEL, NORID\n+__label__, LABEL, RID_UNUSED\n __null, CONSTANT, RID_NULL\n-__real, REALPART, NORID\n-__real__, REALPART, NORID\n+__real, REALPART, RID_UNUSED\n+__real__, REALPART, RID_UNUSED\n __restrict, CV_QUALIFIER, RID_RESTRICT\n __restrict__, CV_QUALIFIER, RID_RESTRICT\n __signature__, AGGR, RID_SIGNATURE\t/* Extension */,\n __signed, TYPESPEC, RID_SIGNED\n __signed__, TYPESPEC, RID_SIGNED\n-__sigof__, SIGOF, NORID\t\t/* Extension */,\n-__typeof, TYPEOF, NORID\n-__typeof__, TYPEOF, NORID\n+__sigof__, SIGOF, RID_UNUSED\t\t/* Extension */,\n+__typeof, TYPEOF, RID_UNUSED\n+__typeof__, TYPEOF, RID_UNUSED\n __volatile, CV_QUALIFIER, RID_VOLATILE\n __volatile__, CV_QUALIFIER, RID_VOLATILE\n __wchar_t, TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,\n-asm, ASM_KEYWORD, NORID,\n-and, ANDAND, NORID,\n-and_eq, ASSIGN, NORID,\n+asm, ASM_KEYWORD, RID_UNUSED,\n+and, ANDAND, RID_UNUSED,\n+and_eq, ASSIGN, RID_UNUSED,\n auto, SCSPEC, RID_AUTO,\n-bitand, '&', NORID,\n-bitor, '|', NORID,\n+bitand, '&', RID_UNUSED,\n+bitor, '|', RID_UNUSED,\n bool, TYPESPEC, RID_BOOL,\n-break, BREAK, NORID,\n-case, CASE, NORID,\n-catch, CATCH, NORID,\n+break, BREAK, RID_UNUSED,\n+case, CASE, RID_UNUSED,\n+catch, CATCH, RID_UNUSED,\n char, TYPESPEC, RID_CHAR,\n class, AGGR, RID_CLASS,\n-compl, '~', NORID,\n+compl, '~', RID_UNUSED,\n const, CV_QUALIFIER, RID_CONST,\n-const_cast, CONST_CAST, NORID,\n-continue, CONTINUE, NORID,\n-default, DEFAULT, NORID,\n-delete, DELETE, NORID,\n-do, DO, NORID,\n+const_cast, CONST_CAST, RID_UNUSED,\n+continue, CONTINUE, RID_UNUSED,\n+default, DEFAULT, RID_UNUSED,\n+delete, DELETE, RID_UNUSED,\n+do, DO, RID_UNUSED,\n double, TYPESPEC, RID_DOUBLE,\n-dynamic_cast, DYNAMIC_CAST, NORID,\n-else, ELSE, NORID,\n-enum, ENUM, NORID,\n+dynamic_cast, DYNAMIC_CAST, RID_UNUSED,\n+else, ELSE, RID_UNUSED,\n+enum, ENUM, RID_UNUSED,\n explicit, SCSPEC, RID_EXPLICIT,\n export, SCSPEC, RID_EXPORT,\n extern, SCSPEC, RID_EXTERN,\n-false, CXX_FALSE, NORID,\n+false, CXX_FALSE, RID_UNUSED,\n float, TYPESPEC, RID_FLOAT,\n-for, FOR, NORID,\n+for, FOR, RID_UNUSED,\n friend, SCSPEC, RID_FRIEND,\n-goto, GOTO, NORID,\n-if, IF, NORID,\n+goto, GOTO, RID_UNUSED,\n+if, IF, RID_UNUSED,\n inline, SCSPEC, RID_INLINE,\n int, TYPESPEC, RID_INT,\n long, TYPESPEC, RID_LONG,\n mutable, SCSPEC, RID_MUTABLE,\n-namespace, NAMESPACE, NORID,\n-new, NEW, NORID,\n-not, '!', NORID,\n-not_eq, EQCOMPARE, NORID,\n-operator, OPERATOR, NORID,\n-or, OROR, NORID,\n-or_eq, ASSIGN, NORID,\n+namespace, NAMESPACE, RID_UNUSED,\n+new, NEW, RID_UNUSED,\n+not, '!', RID_UNUSED,\n+not_eq, EQCOMPARE, RID_UNUSED,\n+operator, OPERATOR, RID_UNUSED,\n+or, OROR, RID_UNUSED,\n+or_eq, ASSIGN, RID_UNUSED,\n private, VISSPEC, RID_PRIVATE,\n protected, VISSPEC, RID_PROTECTED,\n public, VISSPEC, RID_PUBLIC,\n register, SCSPEC, RID_REGISTER,\n-reinterpret_cast, REINTERPRET_CAST, NORID,\n-return, RETURN_KEYWORD, NORID,\n+reinterpret_cast, REINTERPRET_CAST, RID_UNUSED,\n+return, RETURN_KEYWORD, RID_UNUSED,\n short, TYPESPEC, RID_SHORT,\n signature, AGGR, RID_SIGNATURE\t/* Extension */,\n signed, TYPESPEC, RID_SIGNED,\n-sigof, SIGOF, NORID\t\t/* Extension */,\n-sizeof, SIZEOF, NORID,\n+sigof, SIGOF, RID_UNUSED\t\t/* Extension */,\n+sizeof, SIZEOF, RID_UNUSED,\n static, SCSPEC, RID_STATIC,\n-static_cast, STATIC_CAST, NORID,\n+static_cast, STATIC_CAST, RID_UNUSED,\n struct, AGGR, RID_RECORD,\n-switch, SWITCH, NORID,\n+switch, SWITCH, RID_UNUSED,\n template, TEMPLATE, RID_TEMPLATE,\n-this, THIS, NORID,\n-throw, THROW, NORID,\n-true, CXX_TRUE, NORID,\n-try, TRY, NORID,\n+this, THIS, RID_UNUSED,\n+throw, THROW, RID_UNUSED,\n+true, CXX_TRUE, RID_UNUSED,\n+try, TRY, RID_UNUSED,\n typedef, SCSPEC, RID_TYPEDEF,\n-typename, TYPENAME_KEYWORD, NORID,\n-typeid, TYPEID, NORID,\n-typeof, TYPEOF, NORID,\n+typename, TYPENAME_KEYWORD, RID_UNUSED,\n+typeid, TYPEID, RID_UNUSED,\n+typeof, TYPEOF, RID_UNUSED,\n union, AGGR, RID_UNION,\n unsigned, TYPESPEC, RID_UNSIGNED,\n-using, USING, NORID,\n+using, USING, RID_UNUSED,\n virtual, SCSPEC, RID_VIRTUAL,\n void, TYPESPEC, RID_VOID,\n volatile, CV_QUALIFIER, RID_VOLATILE,\n-while, WHILE, NORID,\n-xor, '^', NORID,\n-xor_eq, ASSIGN, NORID,\n+while, WHILE, RID_UNUSED,\n+xor, '^', RID_UNUSED,\n+xor_eq, ASSIGN, RID_UNUSED,"}, {"sha": "b7db192440c74ddac4675e2fed268c2417a7a943", "filename": "gcc/cp/hash.h", "status": "modified", "additions": 60, "deletions": 60, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fhash.h?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -78,16 +78,16 @@ is_reserved_word (str, len)\n   static struct resword wordlist[] =\n     {\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"else\", ELSE, NORID,},\n+      {\"else\", ELSE, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"delete\", DELETE, NORID,},\n-      {\"case\", CASE, NORID,},\n-      {\"__real__\", REALPART, NORID},\n+      {\"delete\", DELETE, RID_UNUSED,},\n+      {\"case\", CASE, RID_UNUSED,},\n+      {\"__real__\", REALPART, RID_UNUSED},\n       {\"\", 0, 0},\n-      {\"true\", CXX_TRUE, NORID,},\n-      {\"catch\", CATCH, NORID,},\n-      {\"typeid\", TYPEID, NORID,},\n-      {\"try\", TRY, NORID,},\n+      {\"true\", CXX_TRUE, RID_UNUSED,},\n+      {\"catch\", CATCH, RID_UNUSED,},\n+      {\"typeid\", TYPEID, RID_UNUSED,},\n+      {\"try\", TRY, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n       {\"void\", TYPESPEC, RID_VOID,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n@@ -96,23 +96,23 @@ is_reserved_word (str, len)\n       {\"protected\", VISSPEC, RID_PROTECTED,},\n       {\"extern\", SCSPEC, RID_EXTERN,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"not\", '!', NORID,},\n+      {\"not\", '!', RID_UNUSED,},\n       {\"\", 0, 0},\n       {\"__signed\", TYPESPEC, RID_SIGNED},\n       {\"int\", TYPESPEC, RID_INT,},\n       {\"__signed__\", TYPESPEC, RID_SIGNED},\n-      {\"__real\", REALPART, NORID},\n+      {\"__real\", REALPART, RID_UNUSED},\n       {\"\", 0, 0},\n-      {\"xor_eq\", ASSIGN, NORID,},\n+      {\"xor_eq\", ASSIGN, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"__attribute\", ATTRIBUTE, NORID},\n-      {\"__asm__\", ASM_KEYWORD, NORID},\n-      {\"__attribute__\", ATTRIBUTE, NORID},\n-      {\"compl\", '~', NORID,},\n+      {\"__attribute\", ATTRIBUTE, RID_UNUSED},\n+      {\"__asm__\", ASM_KEYWORD, RID_UNUSED},\n+      {\"__attribute__\", ATTRIBUTE, RID_UNUSED},\n+      {\"compl\", '~', RID_UNUSED,},\n       {\"public\", VISSPEC, RID_PUBLIC,},\n-      {\"not_eq\", EQCOMPARE, NORID,},\n-      {\"switch\", SWITCH, NORID,},\n-      {\"__extension__\", EXTENSION, NORID},\n+      {\"not_eq\", EQCOMPARE, RID_UNUSED,},\n+      {\"switch\", SWITCH, RID_UNUSED,},\n+      {\"__extension__\", EXTENSION, RID_UNUSED},\n       {\"const\", CV_QUALIFIER, RID_CONST,},\n       {\"static\", SCSPEC, RID_STATIC,},\n       {\"\", 0, 0},\n@@ -121,104 +121,104 @@ is_reserved_word (str, len)\n       {\"__inline__\", SCSPEC, RID_INLINE},\n       {\"__restrict__\", CV_QUALIFIER, RID_RESTRICT},\n       {\"inline\", SCSPEC, RID_INLINE,},\n-      {\"const_cast\", CONST_CAST, NORID,},\n-      {\"static_cast\", STATIC_CAST, NORID,},\n+      {\"const_cast\", CONST_CAST, RID_UNUSED,},\n+      {\"static_cast\", STATIC_CAST, RID_UNUSED,},\n       {\"__restrict\", CV_QUALIFIER, RID_RESTRICT},\n-      {\"xor\", '^', NORID,},\n+      {\"xor\", '^', RID_UNUSED,},\n       {\"__wchar_t\", TYPESPEC, RID_WCHAR  /* Unique to ANSI C++ */,},\n-      {\"new\", NEW, NORID,},\n-      {\"__alignof__\", ALIGNOF, NORID},\n+      {\"new\", NEW, RID_UNUSED,},\n+      {\"__alignof__\", ALIGNOF, RID_UNUSED},\n       {\"signed\", TYPESPEC, RID_SIGNED,},\n-      {\"and\", ANDAND, NORID,},\n+      {\"and\", ANDAND, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"explicit\", SCSPEC, RID_EXPLICIT,},\n       {\"\", 0, 0},\n-      {\"__imag__\", IMAGPART, NORID},\n-      {\"while\", WHILE, NORID,},\n+      {\"__imag__\", IMAGPART, RID_UNUSED},\n+      {\"while\", WHILE, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"do\", DO, NORID,},\n-      {\"typename\", TYPENAME_KEYWORD, NORID,},\n+      {\"do\", DO, RID_UNUSED,},\n+      {\"typename\", TYPENAME_KEYWORD, RID_UNUSED,},\n       {\"friend\", SCSPEC, RID_FRIEND,},\n-      {\"continue\", CONTINUE, NORID,},\n+      {\"continue\", CONTINUE, RID_UNUSED,},\n       {\"class\", AGGR, RID_CLASS,},\n-      {\"default\", DEFAULT, NORID,},\n-      {\"this\", THIS, NORID,},\n-      {\"dynamic_cast\", DYNAMIC_CAST, NORID,},\n-      {\"typeof\", TYPEOF, NORID,},\n+      {\"default\", DEFAULT, RID_UNUSED,},\n+      {\"this\", THIS, RID_UNUSED,},\n+      {\"dynamic_cast\", DYNAMIC_CAST, RID_UNUSED,},\n+      {\"typeof\", TYPEOF, RID_UNUSED,},\n       {\"virtual\", SCSPEC, RID_VIRTUAL,},\n       {\"export\", SCSPEC, RID_EXPORT,},\n-      {\"and_eq\", ASSIGN, NORID,},\n-      {\"__typeof__\", TYPEOF, NORID},\n+      {\"and_eq\", ASSIGN, RID_UNUSED,},\n+      {\"__typeof__\", TYPEOF, RID_UNUSED},\n       {\"__const__\", CV_QUALIFIER, RID_CONST},\n       {\"__volatile\", CV_QUALIFIER, RID_VOLATILE},\n       {\"short\", TYPESPEC, RID_SHORT,},\n       {\"__volatile__\", CV_QUALIFIER, RID_VOLATILE},\n       {\"__const\", CV_QUALIFIER, RID_CONST},\n-      {\"namespace\", NAMESPACE, NORID,},\n+      {\"namespace\", NAMESPACE, RID_UNUSED,},\n       {\"char\", TYPESPEC, RID_CHAR,},\n       {\"unsigned\", TYPESPEC, RID_UNSIGNED,},\n       {\"double\", TYPESPEC, RID_DOUBLE,},\n-      {\"or_eq\", ASSIGN, NORID,},\n+      {\"or_eq\", ASSIGN, RID_UNUSED,},\n       {\"__null\", CONSTANT, RID_NULL},\n-      {\"if\", IF, NORID,},\n+      {\"if\", IF, RID_UNUSED,},\n       {\"__signature__\", AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"__label__\", LABEL, NORID},\n+      {\"__label__\", LABEL, RID_UNUSED},\n       {\"long\", TYPESPEC, RID_LONG,},\n-      {\"__imag\", IMAGPART, NORID},\n-      {\"__asm\", ASM_KEYWORD, NORID},\n+      {\"__imag\", IMAGPART, RID_UNUSED},\n+      {\"__asm\", ASM_KEYWORD, RID_UNUSED},\n       {\"\", 0, 0},\n-      {\"__sigof__\", SIGOF, NORID\t\t/* Extension */,},\n+      {\"__sigof__\", SIGOF, RID_UNUSED\t\t/* Extension */,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"struct\", AGGR, RID_RECORD,},\n       {\"\", 0, 0},\n       {\"volatile\", CV_QUALIFIER, RID_VOLATILE,},\n-      {\"false\", CXX_FALSE, NORID,},\n-      {\"sizeof\", SIZEOF, NORID,},\n+      {\"false\", CXX_FALSE, RID_UNUSED,},\n+      {\"sizeof\", SIZEOF, RID_UNUSED,},\n       {\"__complex__\", TYPESPEC, RID_COMPLEX},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"for\", FOR, NORID,},\n-      {\"or\", OROR, NORID,},\n+      {\"for\", FOR, RID_UNUSED,},\n+      {\"or\", OROR, RID_UNUSED,},\n       {\"register\", SCSPEC, RID_REGISTER,},\n-      {\"throw\", THROW, NORID,},\n+      {\"throw\", THROW, RID_UNUSED,},\n       {\"\", 0, 0},\n-      {\"using\", USING, NORID,},\n+      {\"using\", USING, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0},\n       {\"__complex\", TYPESPEC, RID_COMPLEX},\n       {\"\", 0, 0},\n-      {\"asm\", ASM_KEYWORD, NORID,},\n+      {\"asm\", ASM_KEYWORD, RID_UNUSED,},\n       {\"signature\", AGGR, RID_SIGNATURE\t/* Extension */,},\n-      {\"enum\", ENUM, NORID,},\n-      {\"reinterpret_cast\", REINTERPRET_CAST, NORID,},\n+      {\"enum\", ENUM, RID_UNUSED,},\n+      {\"reinterpret_cast\", REINTERPRET_CAST, RID_UNUSED,},\n       {\"mutable\", SCSPEC, RID_MUTABLE,},\n-      {\"__alignof\", ALIGNOF, NORID},\n-      {\"return\", RETURN_KEYWORD, NORID,},\n+      {\"__alignof\", ALIGNOF, RID_UNUSED},\n+      {\"return\", RETURN_KEYWORD, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0},\n       {\"float\", TYPESPEC, RID_FLOAT,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"bool\", TYPESPEC, RID_BOOL,},\n       {\"\", 0, 0},\n       {\"typedef\", SCSPEC, RID_TYPEDEF,},\n-      {\"__typeof\", TYPEOF, NORID},\n-      {\"bitand\", '&', NORID,},\n-      {\"break\", BREAK, NORID,},\n+      {\"__typeof\", TYPEOF, RID_UNUSED},\n+      {\"bitand\", '&', RID_UNUSED,},\n+      {\"break\", BREAK, RID_UNUSED,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"union\", AGGR, RID_UNION,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"goto\", GOTO, NORID,},\n-      {\"sigof\", SIGOF, NORID\t\t/* Extension */,},\n+      {\"goto\", GOTO, RID_UNUSED,},\n+      {\"sigof\", SIGOF, RID_UNUSED\t\t/* Extension */,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"bitor\", '|', NORID,},\n+      {\"bitor\", '|', RID_UNUSED,},\n       {\"auto\", SCSPEC, RID_AUTO,},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0}, {\"\", 0, 0},\n       {\"\", 0, 0}, {\"\", 0, 0},\n-      {\"operator\", OPERATOR, NORID,}\n+      {\"operator\", OPERATOR, RID_UNUSED,}\n     };\n \n   if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)"}, {"sha": "5c2a1d148c6891c812c6a92535724b9b2a68d082", "filename": "gcc/cp/lex.h", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Flex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Flex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.h?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -43,8 +43,9 @@ enum rid\n   /* This is where grokdeclarator starts its search when setting the specbits.\n      The first seven are in the order of most frequently used, as found\n      building libg++.  */\n+  RID_FIRST_MODIFIER,\n \n-  RID_EXTERN,\n+  RID_EXTERN = RID_FIRST_MODIFIER,\n   RID_CONST,\n   RID_LONG,\n   RID_TYPEDEF,\n@@ -66,6 +67,7 @@ enum rid\n   RID_COMPLEX,\n   RID_RESTRICT,\n \n+  RID_LAST_MODIFIER = RID_RESTRICT,\n   /* This is where grokdeclarator ends its search when setting the\n      specbits.  */\n \n@@ -81,11 +83,6 @@ enum rid\n   RID_MAX\n };\n \n-#define NORID RID_UNUSED\n-\n-#define RID_FIRST_MODIFIER RID_EXTERN\n-#define RID_LAST_MODIFIER RID_COMPLEX\n-\n /* The type that can represent all values of RIDBIT.  */\n /* We assume that we can stick in at least 32 bits into this.  */\n typedef struct { unsigned long idata[2]; }"}, {"sha": "6db901c9299a1022dcd5cf170d6450fc2e618bac", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 41, "deletions": 30, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -5311,7 +5311,8 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n \t{\n \t  tree r = build_ptrmemfunc_type\n \t    (tsubst (TYPE_PTRMEMFUNC_FN_TYPE (t), args, complain, in_decl));\n-\t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n+\t  return cp_build_qualified_type_real (r, TYPE_QUALS (t),\n+\t\t\t\t\t       complain);\n \t}\n \n       /* else fall through */\n@@ -5349,7 +5350,8 @@ tsubst_aggr_type (t, args, complain, in_decl, entering_scope)\n \t\t\t\t     entering_scope);\n \t  pop_momentary ();\n \n-\t  return cp_build_qualified_type (r, TYPE_QUALS (t));\n+\t  return cp_build_qualified_type_real (r, TYPE_QUALS (t),\n+\t\t\t\t\t       complain);\n \t}\n       else \n \t/* This is not a template type, so there's nothing to do.  */\n@@ -6208,18 +6210,9 @@ tsubst (t, args, complain, in_decl)\n \t\t  {\n \t\t    my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (arg))\n \t\t\t\t\t== 't', 0);\n-\n-\t\t    /* If we're not COMPLAINing, don't let an attempt\n-\t\t       to qualify a FUNCTION_TYPE reach\n-\t\t       cp_build_qualified_type.  That will result in\n-\t\t       an error message.  */\n-\t\t    if (!complain\n-\t\t\t&& TREE_CODE (arg) == FUNCTION_TYPE\n-\t\t\t&& CP_TYPE_QUALS (t) != TYPE_UNQUALIFIED)\n-\t\t      return error_mark_node;\n-\n-\t\t    return cp_build_qualified_type\n-\t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t));\n+\t\t    return cp_build_qualified_type_real\n+\t\t      (arg, CP_TYPE_QUALS (arg) | CP_TYPE_QUALS (t),\n+\t\t       complain);\n \t\t  }\n \t\telse if (TREE_CODE (t) == TEMPLATE_TEMPLATE_PARM)\n \t\t  {\n@@ -6244,7 +6237,9 @@ tsubst (t, args, complain, in_decl)\n \t\t\t\t\t\t   argvec, in_decl, \n \t\t\t\t\t\t   DECL_CONTEXT (arg),\n \t\t\t\t\t\t   /*entering_scope=*/0);\n-\t\t\treturn cp_build_qualified_type (r, TYPE_QUALS (t));\n+\t\t\treturn cp_build_qualified_type_real (r, \n+\t\t\t\t\t\t\t     TYPE_QUALS (t),\n+\t\t\t\t\t\t\t     complain);\n \t\t      }\n \t\t    else\n \t\t      /* We are processing a template argument list.  */ \n@@ -6411,7 +6406,7 @@ tsubst (t, args, complain, in_decl)\n \t  r = build_pointer_type (type);\n \telse\n \t  r = build_reference_type (type);\n-\tr = cp_build_qualified_type (r, TYPE_QUALS (t));\n+\tr = cp_build_qualified_type_real (r, TYPE_QUALS (t), complain);\n \n \t/* Will this ever be needed for TYPE_..._TO values?  */\n \tlayout_type (r);\n@@ -6553,9 +6548,10 @@ tsubst (t, args, complain, in_decl)\n \tf = make_typename_type (ctx, f);\n \tif (f == error_mark_node)\n \t  return f;\n-\treturn cp_build_qualified_type (f, \n-\t\t\t\t\tCP_TYPE_QUALS (f) \n-\t\t\t\t\t| CP_TYPE_QUALS (t));\n+\treturn cp_build_qualified_type_real (f, \n+\t\t\t\t\t     CP_TYPE_QUALS (f) \n+\t\t\t\t\t     | CP_TYPE_QUALS (t),\n+\t\t\t\t\t     complain);\n       }\n \n     case INDIRECT_REF:\n@@ -7388,6 +7384,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n {\n   tree parms;\n   tree fntype;\n+  int result;\n \n   my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n   \n@@ -7446,9 +7443,25 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n      because the standard doesn't seem to explicitly prohibit it.  Our\n      callers must be ready to deal with unification failures in any\n      event.  */\n-  return type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n-\t\t\t\ttargs, parms, args, /*subr=*/0,\n-\t\t\t\tstrict, /*allow_incomplete*/1);\n+  result = type_unification_real (DECL_INNERMOST_TEMPLATE_PARMS (fn), \n+\t\t\t\t  targs, parms, args, /*subr=*/0,\n+\t\t\t\t  strict, /*allow_incomplete*/1);\n+\n+  if (result == 0) \n+    /* All is well so far.  Now, check:\n+       \n+       [temp.deduct] \n+       \n+       When all template arguments have been deduced, all uses of\n+       template parameters in nondeduced contexts are replaced with\n+       the corresponding deduced argument values.  If the\n+       substitution results in an invalid type, as described above,\n+       type deduction fails.  */\n+    if (tsubst (TREE_TYPE (fn), targs, /*complain=*/0, NULL_TREE)\n+\t== error_mark_node)\n+      return 1;\n+\n+  return result;\n }\n \n /* Adjust types before performing type deduction, as described in\n@@ -8040,11 +8053,6 @@ check_cv_quals_for_unify (strict, arg, parm)\n       && !at_least_as_qualified_p (parm, arg))\n     return 0;\n \n-  /* Don't allow unification to create a qualified function type.  */\n-  if (TREE_CODE (arg) == FUNCTION_TYPE \n-      && CP_TYPE_QUALS (parm) != TYPE_UNQUALIFIED)\n-    return 0;\n-\n   return 1;\n }\n \n@@ -8198,9 +8206,12 @@ unify (tparms, targs, parm, arg, strict)\n \t  /* Consider the case where ARG is `const volatile int' and\n \t     PARM is `const T'.  Then, T should be `volatile int'.  */\n \t  arg = \n-\t    cp_build_qualified_type (arg,\n-\t\t\t\t     CP_TYPE_QUALS (arg) \n-\t\t\t\t     & ~CP_TYPE_QUALS (parm));\n+\t    cp_build_qualified_type_real (arg,\n+\t\t\t\t\t  CP_TYPE_QUALS (arg) \n+\t\t\t\t\t  & ~CP_TYPE_QUALS (parm),\n+\t\t\t\t\t  /*complain=*/0);\n+\t  if (arg == error_mark_node)\n+\t    return 1;\n \t}\n \n       /* Simple cases: Value already set, does match or doesn't.  */"}, {"sha": "9d77217e0a82da621b4562d4cdf4a6a9faab4828", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/adecb3f41f0bb582c936e2be5fda659a611067ca/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=adecb3f41f0bb582c936e2be5fda659a611067ca", "patch": "@@ -407,6 +407,9 @@ build_cplus_array_type_1 (elt_type, index_type)\n   register struct obstack *ambient_saveable_obstack = saveable_obstack;\n   tree t;\n \n+  if (elt_type == error_mark_node || index_type == error_mark_node)\n+    return error_mark_node;\n+\n   /* We need a new one.  If both ELT_TYPE and INDEX_TYPE are permanent,\n      make this permanent too.  */\n   if (TREE_PERMANENT (elt_type)\n@@ -454,43 +457,59 @@ build_cplus_array_type (elt_type, index_type)\n   return t;\n }\n \f\n-/* Make a variant type in the proper way for C/C++, propagating qualifiers\n-   down to the element type of an array.  */\n+/* Make a variant of TYPE, qualified with the TYPE_QUALS.  Handles\n+   arrays correctly.  In particular, if TYPE is an array of T's, and\n+   TYPE_QUALS is non-empty, returns an array of qualified T's.  If\n+   at attempt is made to qualify a type illegally, and COMPLAIN is\n+   non-zero, an error is issued.  If COMPLAIN is zero, error_mark_node\n+   is returned.  */\n \n tree\n-cp_build_qualified_type (type, type_quals)\n+cp_build_qualified_type_real (type, type_quals, complain)\n      tree type;\n      int type_quals;\n+     int complain;\n {\n   if (type == error_mark_node)\n     return type;\n   \n   /* A restrict-qualified pointer type must be a pointer (or reference)\n      to object or incomplete type.  */\n   if ((type_quals & TYPE_QUAL_RESTRICT)\n+      && TREE_CODE (type) != TEMPLATE_TYPE_PARM\n       && (!POINTER_TYPE_P (type)\n \t  || TYPE_PTRMEM_P (type)\n \t  || TREE_CODE (TREE_TYPE (type)) == FUNCTION_TYPE))\n     {\n-      cp_error (\"`%T' cannot be `restrict'-qualified\", type);\n+      if (complain)\n+\tcp_error (\"`%T' cannot be `restrict'-qualified\", type);\n+      else\n+\treturn error_mark_node;\n+\n       type_quals &= ~TYPE_QUAL_RESTRICT;\n     }\n \n   if (type_quals != TYPE_UNQUALIFIED\n       && TREE_CODE (type) == FUNCTION_TYPE)\n     {\n-      cp_error (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n+      if (complain)\n+\tcp_error (\"`%T' cannot be `const'-, `volatile'-, or `restrict'-qualified\", type);\n+      else\n+\treturn error_mark_node;\n       type_quals = TYPE_UNQUALIFIED;\n     }\n   else if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       tree real_main_variant = TYPE_MAIN_VARIANT (type);\n-\n+      tree element_type = cp_build_qualified_type_real (TREE_TYPE (type),\n+\t\t\t\t\t\t\ttype_quals,\n+\t\t\t\t\t\t\tcomplain);\n       push_obstacks (TYPE_OBSTACK (real_main_variant),\n \t\t     TYPE_OBSTACK (real_main_variant));\n-      type = build_cplus_array_type_1 (cp_build_qualified_type \n-\t\t\t\t       (TREE_TYPE (type), type_quals),\n+      type = build_cplus_array_type_1 (element_type,\n \t\t\t\t       TYPE_DOMAIN (type));\n+      if (type == error_mark_node)\n+\treturn error_mark_node;\n \n       /* TYPE must be on same obstack as REAL_MAIN_VARIANT.  If not,\n \t make a copy.  (TYPE might have come from the hash table and"}]}