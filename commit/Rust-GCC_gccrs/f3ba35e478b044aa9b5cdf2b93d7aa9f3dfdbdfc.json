{"sha": "f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNiYTM1ZTQ3OGIwNDRhYTliNWNkZjJiOTNkN2FhOWYzZGZkYmRmYw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-07-13T12:55:15Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-07-13T12:55:15Z"}, "message": "emit-rtl.c (try_split): Update mark_jump_label call.\n\n\t* emit-rtl.c (try_split): Update mark_jump_label call.\n\t* flow.c (find_sub_basic_blocks): Likewise.\n\t* jump.c (cross_jump_death_matters, find_cross_jump, do_cross_jump,\n\tjump_back_p): Kill.\n\t(mark_all_labels): Kill second parameter.\n\t(jump_optimize, jump_optimize_1): Kill cross_jump parameter.\n\t(rebuild_jump_labels, jump_optimize_minimal): Update call\n\tof jump_optimize_1.\n\t(jump_optimize_1): Kill crossjumping code.\n\t(mark_jump_label): Kill cross_jump parameter.\n\t* rtl.h (mark_jump_label, jump_optimize): Update prototypes.\n\t(JUMP_CROSS_JUMP, JUMP_CROSS_JUMP_DEATH_MATTERS): Kill.\n\t* reg-stack.c (reg_to_stack): Do not rebuild if not needed; do\n\t splitting.\n\t* toplev.c (enum dump_file_index): Kill DFI_jump2; put DFI_stack before\n\tDFI_bpro.\n\t(rest_of_compilation): Update calls to jump_optimize; kill jump2 pass;\n\treorganize passes to do reg-stack first, bb-reorder second.\n\t* invoke.texi (-d letters doc): Remove the jump2 pass.\n\nFrom-SVN: r43979", "tree": {"sha": "f566f12b1a4cd0cd531469ea7a5678678fb3e149", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f566f12b1a4cd0cd531469ea7a5678678fb3e149"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/comments", "author": null, "committer": null, "parents": [{"sha": "dd697c0d319e7af9bc0beae8ea588c81c552bea4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd697c0d319e7af9bc0beae8ea588c81c552bea4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd697c0d319e7af9bc0beae8ea588c81c552bea4"}], "stats": {"total": 630, "additions": 91, "deletions": 539}, "files": [{"sha": "6e078ca55492053f91a62ef78abd9d9a4bbaca69", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -1,3 +1,25 @@\n+Fri Jul 13 14:46:21 CEST 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* emit-rtl.c (try_split): Update mark_jump_label call.\n+\t* flow.c (find_sub_basic_blocks): Likewise.\n+\t* jump.c (cross_jump_death_matters, find_cross_jump, do_cross_jump,\n+\tjump_back_p): Kill.\n+\t(mark_all_labels): Kill second parameter.\n+\t(jump_optimize, jump_optimize_1): Kill cross_jump parameter.\n+\t(rebuild_jump_labels, jump_optimize_minimal): Update call\n+\tof jump_optimize_1.\n+\t(jump_optimize_1): Kill crossjumping code.\n+\t(mark_jump_label): Kill cross_jump parameter.\n+\t* rtl.h (mark_jump_label, jump_optimize): Update prototypes.\n+\t(JUMP_CROSS_JUMP, JUMP_CROSS_JUMP_DEATH_MATTERS): Kill.\n+\t* reg-stack.c (reg_to_stack): Do not rebuild if not needed; do\n+\t splitting.\n+\t* toplev.c (enum dump_file_index): Kill DFI_jump2; put DFI_stack before\n+\tDFI_bpro.\n+\t(rest_of_compilation): Update calls to jump_optimize; kill jump2 pass;\n+\treorganize passes to do reg-stack first, bb-reorder second.\n+\t* invoke.texi (-d letters doc): Remove the jump2 pass.\n+\n 2001-07-12  Steve Ellcey <sje@cup.hp.com>\n \n \t* toplev.c (compile_file): Put call of ASM_FILE_START inside ifdef."}, {"sha": "3b13ad81dfcdec90a39ebef16eea7c021d22aa94", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -2908,9 +2908,6 @@ Dump after sibling call optimizations, to @file{@var{file}.01.sibling}.\n @item j\n @opindex dj\n Dump after the first jump optimization, to @file{@var{file}.03.jump}.\n-@item J\n-@opindex dJ\n-Dump after the last jump optimization, to @file{@var{file}.29.jump2}.\n @item k\n @opindex dk\n Dump after conversion from registers to stack, to @file{@var{file}.32.stack}."}, {"sha": "7518614c5bbcdf1ad31f4e1dc6b556377f067787", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -2518,7 +2518,7 @@ try_split (pat, trial, last)\n \t  for (i = XVECLEN (seq, 0) - 1; i >= 0; i--)\n \t    if (GET_CODE (XVECEXP (seq, 0, i)) == JUMP_INSN)\n \t      mark_jump_label (PATTERN (XVECEXP (seq, 0, i)),\n-\t\t\t       XVECEXP (seq, 0, i), 0, 0);\n+\t\t\t       XVECEXP (seq, 0, i), 0);\n \n \t  /* If we are splitting a CALL_INSN, look for the CALL_INSN\n \t     in SEQ and copy our CALL_INSN_FUNCTION_USAGE to it.  */"}, {"sha": "d0980f49a4b74e47813d003abef8f23740ddcd6f", "filename": "gcc/flow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -798,7 +798,7 @@ find_sub_basic_blocks (bb)\n       bb = BASIC_BLOCK (i);\n       if (GET_CODE (bb->end) == JUMP_INSN)\n \t{\n-\t  mark_jump_label (PATTERN (bb->end), bb->end, 0, 0);\n+\t  mark_jump_label (PATTERN (bb->end), bb->end, 0);\n \t  make_label_edge (NULL, bb, JUMP_LABEL (bb->end), 0);\n \t}\n       insn = NEXT_INSN (insn);"}, {"sha": "96e87a8c9ec54304313fe5845f2429d2af2b6bf0", "filename": "gcc/jump.c", "status": "modified", "additions": 31, "deletions": 474, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -36,11 +36,6 @@ Boston, MA 02111-1307, USA.  */\n    formerly used them.  The JUMP_LABEL info is sometimes looked\n    at by later passes.\n \n-   Optionally, cross-jumping can be done.  Currently it is done\n-   only the last time (when after reload and before final).\n-   In fact, the code for cross-jumping now assumes that register\n-   allocation has been done, since it uses `rtx_renumbered_equal_p'.\n-\n    Jump optimization is done after cse when cse's constant-propagation\n    causes jumps to become unconditional or to be deleted.\n \n@@ -96,23 +91,12 @@ static rtx *jump_chain;\n \n static int max_jump_chain;\n \n-/* Indicates whether death notes are significant in cross jump analysis.\n-   Normally they are not significant, because of A and B jump to C,\n-   and R dies in A, it must die in B.  But this might not be true after\n-   stack register conversion, and we must compare death notes in that\n-   case.  */\n-\n-static int cross_jump_death_matters = 0;\n-\n static int init_label_info\t\tPARAMS ((rtx));\n static void delete_barrier_successors\tPARAMS ((rtx));\n-static void mark_all_labels\t\tPARAMS ((rtx, int));\n+static void mark_all_labels\t\tPARAMS ((rtx));\n static rtx delete_unreferenced_labels\tPARAMS ((rtx));\n static void delete_noop_moves\t\tPARAMS ((rtx));\n static int duplicate_loop_exit_test\tPARAMS ((rtx));\n-static void find_cross_jump\t\tPARAMS ((rtx, rtx, int, rtx *, rtx *));\n-static void do_cross_jump\t\tPARAMS ((rtx, rtx, rtx));\n-static int jump_back_p\t\t\tPARAMS ((rtx, rtx));\n static int tension_vector_labels\tPARAMS ((rtx, int));\n static void delete_computation\t\tPARAMS ((rtx));\n static void redirect_exp_1\t\tPARAMS ((rtx *, rtx, rtx, rtx));\n@@ -123,20 +107,19 @@ static void delete_from_jump_chain\tPARAMS ((rtx));\n static int delete_labelref_insn\t\tPARAMS ((rtx, rtx, int));\n static void mark_modified_reg\t\tPARAMS ((rtx, rtx, void *));\n static void redirect_tablejump\t\tPARAMS ((rtx, rtx));\n-static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int, int));\n+static void jump_optimize_1\t\tPARAMS ((rtx, int, int, int, int));\n static int returnjump_p_1\t        PARAMS ((rtx *, void *));\n static void delete_prior_computation    PARAMS ((rtx, rtx));\n \f\n /* Main external entry point into the jump optimizer.  See comments before\n    jump_optimize_1 for descriptions of the arguments.  */\n void\n-jump_optimize (f, cross_jump, noop_moves, after_regscan)\n+jump_optimize (f, noop_moves, after_regscan)\n      rtx f;\n-     int cross_jump;\n      int noop_moves;\n      int after_regscan;\n {\n-  jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, 0, 0);\n+  jump_optimize_1 (f, noop_moves, after_regscan, 0, 0);\n }\n \n /* Alternate entry into the jump optimizer.  This entry point only rebuilds\n@@ -146,7 +129,7 @@ void\n rebuild_jump_labels (f)\n      rtx f;\n {\n-  jump_optimize_1 (f, 0, 0, 0, 1, 0);\n+  jump_optimize_1 (f, 0, 0, 1, 0);\n }\n \n /* Alternate entry into the jump optimizer.  Do only trivial optimizations.  */\n@@ -155,17 +138,13 @@ void\n jump_optimize_minimal (f)\n      rtx f;\n {\n-  jump_optimize_1 (f, 0, 0, 0, 0, 1);\n+  jump_optimize_1 (f, 0, 0, 0, 1);\n }\n \f\n /* Delete no-op jumps and optimize jumps to jumps\n    and jumps around jumps.\n    Delete unused labels and unreachable code.\n \n-   If CROSS_JUMP is 1, detect matching code\n-   before a jump and its destination and unify them.\n-   If CROSS_JUMP is 2, do cross-jumping, but pay attention to death notes.\n-\n    If NOOP_MOVES is nonzero, delete no-op move insns.\n \n    If AFTER_REGSCAN is nonzero, then this jump pass is being run immediately\n@@ -193,10 +172,9 @@ jump_optimize_minimal (f)\n   */\n \n static void\n-jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n+jump_optimize_1 (f, noop_moves, after_regscan,\n \t\t mark_labels_only, minimal)\n      rtx f;\n-     int cross_jump;\n      int noop_moves;\n      int after_regscan;\n      int mark_labels_only;\n@@ -212,15 +190,14 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n   enum rtx_code reversed_code;\n #endif\n \n-  cross_jump_death_matters = (cross_jump == 2);\n   max_uid = init_label_info (f) + 1;\n \n   /* Leave some extra room for labels and duplicate exit test insns\n      we make.  */\n   max_jump_chain = max_uid * 14 / 10;\n   jump_chain = (rtx *) xcalloc (max_jump_chain, sizeof (rtx));\n \n-  mark_all_labels (f, cross_jump);\n+  mark_all_labels (f);\n \n   /* Keep track of labels used from static data; we don't track them\n      closely enough to delete them here, so make sure their reference\n@@ -574,125 +551,6 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\t}\n \t    }\n #endif\n-\t  else\n-\t    {\n-\t      /* Now that the jump has been tensioned,\n-\t\t try cross jumping: check for identical code\n-\t\t before the jump and before its target label.  */\n-\n-\t      /* First, cross jumping of conditional jumps:  */\n-\n-\t      if (cross_jump && condjump_p (insn))\n-\t\t{\n-\t\t  rtx newjpos, newlpos;\n-\t\t  rtx x = prev_real_insn (JUMP_LABEL (insn));\n-\n-\t\t  /* A conditional jump may be crossjumped\n-\t\t     only if the place it jumps to follows\n-\t\t     an opposing jump that comes back here.  */\n-\n-\t\t  if (x != 0 && ! jump_back_p (x, insn))\n-\t\t    /* We have no opposing jump;\n-\t\t       cannot cross jump this insn.  */\n-\t\t    x = 0;\n-\n-\t\t  newjpos = 0;\n-\t\t  /* TARGET is nonzero if it is ok to cross jump\n-\t\t     to code before TARGET.  If so, see if matches.  */\n-\t\t  if (x != 0)\n-\t\t    find_cross_jump (insn, x, 2,\n-\t\t\t\t     &newjpos, &newlpos);\n-\n-\t\t  if (newjpos != 0)\n-\t\t    {\n-\t\t      do_cross_jump (insn, newjpos, newlpos);\n-\t\t      /* Make the old conditional jump\n-\t\t\t into an unconditional one.  */\n-\t\t      PATTERN (insn) = gen_jump (JUMP_LABEL (insn));\n-\t\t      INSN_CODE (insn) = -1;\n-\t\t      emit_barrier_after (insn);\n-\t\t      /* Add to jump_chain unless this is a new label\n-\t\t\t whose UID is too large.  */\n-\t\t      if (INSN_UID (JUMP_LABEL (insn)) < max_jump_chain)\n-\t\t\t{\n-\t\t\t  jump_chain[INSN_UID (insn)]\n-\t\t\t    = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n-\t\t\t  jump_chain[INSN_UID (JUMP_LABEL (insn))] = insn;\n-\t\t\t}\n-\t\t      changed = 1;\n-\t\t      next = insn;\n-\t\t    }\n-\t\t}\n-\n-\t      /* Cross jumping of unconditional jumps:\n-\t\t a few differences.  */\n-\n-\t      if (cross_jump && simplejump_p (insn))\n-\t\t{\n-\t\t  rtx newjpos, newlpos;\n-\t\t  rtx target;\n-\n-\t\t  newjpos = 0;\n-\n-\t\t  /* TARGET is nonzero if it is ok to cross jump\n-\t\t     to code before TARGET.  If so, see if matches.  */\n-\t\t  find_cross_jump (insn, JUMP_LABEL (insn), 1,\n-\t\t\t\t   &newjpos, &newlpos);\n-\n-\t\t  /* If cannot cross jump to code before the label,\n-\t\t     see if we can cross jump to another jump to\n-\t\t     the same label.  */\n-\t\t  /* Try each other jump to this label.  */\n-\t\t  if (INSN_UID (JUMP_LABEL (insn)) < max_uid)\n-\t\t    for (target = jump_chain[INSN_UID (JUMP_LABEL (insn))];\n-\t\t\t target != 0 && newjpos == 0;\n-\t\t\t target = jump_chain[INSN_UID (target)])\n-\t\t      if (target != insn\n-\t\t\t  && JUMP_LABEL (target) == JUMP_LABEL (insn)\n-\t\t\t  /* Ignore TARGET if it's deleted.  */\n-\t\t\t  && ! INSN_DELETED_P (target))\n-\t\t\tfind_cross_jump (insn, target, 2,\n-\t\t\t\t\t &newjpos, &newlpos);\n-\n-\t\t  if (newjpos != 0)\n-\t\t    {\n-\t\t      do_cross_jump (insn, newjpos, newlpos);\n-\t\t      changed = 1;\n-\t\t      next = insn;\n-\t\t    }\n-\t\t}\n-\n-\t      /* This code was dead in the previous jump.c!  */\n-\t      if (cross_jump && GET_CODE (PATTERN (insn)) == RETURN)\n-\t\t{\n-\t\t  /* Return insns all \"jump to the same place\"\n-\t\t     so we can cross-jump between any two of them.  */\n-\n-\t\t  rtx newjpos, newlpos, target;\n-\n-\t\t  newjpos = 0;\n-\n-\t\t  /* If cannot cross jump to code before the label,\n-\t\t     see if we can cross jump to another jump to\n-\t\t     the same label.  */\n-\t\t  /* Try each other jump to this label.  */\n-\t\t  for (target = jump_chain[0];\n-\t\t       target != 0 && newjpos == 0;\n-\t\t       target = jump_chain[INSN_UID (target)])\n-\t\t    if (target != insn\n-\t\t\t&& ! INSN_DELETED_P (target)\n-\t\t\t&& GET_CODE (PATTERN (target)) == RETURN)\n-\t\t      find_cross_jump (insn, target, 2,\n-\t\t\t\t       &newjpos, &newlpos);\n-\n-\t\t  if (newjpos != 0)\n-\t\t    {\n-\t\t      do_cross_jump (insn, newjpos, newlpos);\n-\t\t      changed = 1;\n-\t\t      next = insn;\n-\t\t    }\n-\t\t}\n-\t    }\n \t}\n \n       first = 0;\n@@ -837,16 +695,11 @@ delete_barrier_successors (f)\n \n    For each label, make a chain (using `jump_chain')\n    of all the *unconditional* jumps that jump to it;\n-   also make a chain of all returns.\n-\n-   CROSS_JUMP indicates whether we are doing cross jumping\n-   and if we are whether we will be paying attention to\n-   death notes or not.  */\n+   also make a chain of all returns.  */\n \n static void\n-mark_all_labels (f, cross_jump)\n+mark_all_labels (f)\n      rtx f;\n-     int cross_jump;\n {\n   rtx insn;\n \n@@ -856,24 +709,24 @@ mark_all_labels (f, cross_jump)\n \tif (GET_CODE (insn) == CALL_INSN\n \t    && GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n \t  {\n-\t    mark_all_labels (XEXP (PATTERN (insn), 0), cross_jump);\n-\t    mark_all_labels (XEXP (PATTERN (insn), 1), cross_jump);\n-\t    mark_all_labels (XEXP (PATTERN (insn), 2), cross_jump);\n+\t    mark_all_labels (XEXP (PATTERN (insn), 0));\n+\t    mark_all_labels (XEXP (PATTERN (insn), 1));\n+\t    mark_all_labels (XEXP (PATTERN (insn), 2));\n \n \t    /* Canonicalize the tail recursion label attached to the\n \t       CALL_PLACEHOLDER insn.  */\n \t    if (XEXP (PATTERN (insn), 3))\n \t      {\n \t\trtx label_ref = gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t   XEXP (PATTERN (insn), 3));\n-\t\tmark_jump_label (label_ref, insn, cross_jump, 0);\n+\t\tmark_jump_label (label_ref, insn, 0);\n \t\tXEXP (PATTERN (insn), 3) = XEXP (label_ref, 0);\n \t      }\n \n \t    continue;\n \t  }\n \n-\tmark_jump_label (PATTERN (insn), insn, cross_jump, 0);\n+\tmark_jump_label (PATTERN (insn), insn, 0);\n \tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n \t  {\n \t    /* When we know the LABEL_REF contained in a REG used in\n@@ -889,7 +742,7 @@ mark_all_labels (f, cross_jump)\n \t\t    rtx label_ref = gen_rtx_LABEL_REF (VOIDmode,\n \t\t\t\t\t\t       XEXP (label_note, 0));\n \n-\t\t    mark_jump_label (label_ref, insn, cross_jump, 0);\n+\t\t    mark_jump_label (label_ref, insn, 0);\n \t\t    XEXP (label_note, 0) = XEXP (label_ref, 0);\n \t\t    JUMP_LABEL (insn) = XEXP (label_note, 0);\n \t\t  }\n@@ -1213,7 +1066,7 @@ duplicate_loop_exit_test (loop_start)\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \n-\t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n+\t  mark_jump_label (PATTERN (copy), copy, 0);\n \n \t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n \t     make them.  */\n@@ -1241,7 +1094,7 @@ duplicate_loop_exit_test (loop_start)\n \t\t\t\t\tloop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n-\t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n+\t  mark_jump_label (PATTERN (copy), copy, 0);\n \t  if (REG_NOTES (insn))\n \t    {\n \t      REG_NOTES (copy) = copy_insn_1 (REG_NOTES (insn));\n@@ -1302,7 +1155,7 @@ duplicate_loop_exit_test (loop_start)\n       if (! first_copy)\n \tfirst_copy = copy;\n \n-      mark_jump_label (PATTERN (copy), copy, 0, 0);\n+      mark_jump_label (PATTERN (copy), copy, 0);\n       if (INSN_UID (copy) < max_jump_chain\n \t  && INSN_UID (JUMP_LABEL (copy)) < max_jump_chain)\n \t{\n@@ -1372,248 +1225,6 @@ squeeze_notes (start, end)\n   return start;\n }\n \f\n-/* Compare the instructions before insn E1 with those before E2\n-   to find an opportunity for cross jumping.\n-   (This means detecting identical sequences of insns followed by\n-   jumps to the same place, or followed by a label and a jump\n-   to that label, and replacing one with a jump to the other.)\n-\n-   Assume E1 is a jump that jumps to label E2\n-   (that is not always true but it might as well be).\n-   Find the longest possible equivalent sequences\n-   and store the first insns of those sequences into *F1 and *F2.\n-   Store zero there if no equivalent preceding instructions are found.\n-\n-   We give up if we find a label in stream 1.\n-   Actually we could transfer that label into stream 2.  */\n-\n-static void\n-find_cross_jump (e1, e2, minimum, f1, f2)\n-     rtx e1, e2;\n-     int minimum;\n-     rtx *f1, *f2;\n-{\n-  register rtx i1 = e1, i2 = e2;\n-  register rtx p1, p2;\n-  int lose = 0;\n-\n-  rtx last1 = 0, last2 = 0;\n-  rtx afterlast1 = 0, afterlast2 = 0;\n-\n-  *f1 = 0;\n-  *f2 = 0;\n-\n-  while (1)\n-    {\n-      i1 = prev_nonnote_insn (i1);\n-\n-      i2 = PREV_INSN (i2);\n-      while (i2 && (GET_CODE (i2) == NOTE || GET_CODE (i2) == CODE_LABEL))\n-\ti2 = PREV_INSN (i2);\n-\n-      if (i1 == 0)\n-\tbreak;\n-\n-      /* Don't allow the range of insns preceding E1 or E2\n-\t to include the other (E2 or E1).  */\n-      if (i2 == e1 || i1 == e2)\n-\tbreak;\n-\n-      /* If we will get to this code by jumping, those jumps will be\n-\t tensioned to go directly to the new label (before I2),\n-\t so this cross-jumping won't cost extra.  So reduce the minimum.  */\n-      if (GET_CODE (i1) == CODE_LABEL)\n-\t{\n-\t  --minimum;\n-\t  break;\n-\t}\n-\n-      if (i2 == 0 || GET_CODE (i1) != GET_CODE (i2))\n-\tbreak;\n-\n-      p1 = PATTERN (i1);\n-      p2 = PATTERN (i2);\n-\n-      /* If this is a CALL_INSN, compare register usage information.\n-\t If we don't check this on stack register machines, the two\n-\t CALL_INSNs might be merged leaving reg-stack.c with mismatching\n-\t numbers of stack registers in the same basic block.\n-\t If we don't check this on machines with delay slots, a delay slot may\n-\t be filled that clobbers a parameter expected by the subroutine.\n-\n-\t ??? We take the simple route for now and assume that if they're\n-\t equal, they were constructed identically.  */\n-\n-      if (GET_CODE (i1) == CALL_INSN\n-\t  && ! rtx_equal_p (CALL_INSN_FUNCTION_USAGE (i1),\n-\t\t\t    CALL_INSN_FUNCTION_USAGE (i2)))\n-\tlose = 1;\n-\n-#ifdef STACK_REGS\n-      /* If cross_jump_death_matters is not 0, the insn's mode\n-\t indicates whether or not the insn contains any stack-like\n-\t regs.  */\n-\n-      if (!lose && cross_jump_death_matters && stack_regs_mentioned (i1))\n-\t{\n-\t  /* If register stack conversion has already been done, then\n-\t     death notes must also be compared before it is certain that\n-\t     the two instruction streams match.  */\n-\n-\t  rtx note;\n-\t  HARD_REG_SET i1_regset, i2_regset;\n-\n-\t  CLEAR_HARD_REG_SET (i1_regset);\n-\t  CLEAR_HARD_REG_SET (i2_regset);\n-\n-\t  for (note = REG_NOTES (i1); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& STACK_REG_P (XEXP (note, 0)))\n-\t      SET_HARD_REG_BIT (i1_regset, REGNO (XEXP (note, 0)));\n-\n-\t  for (note = REG_NOTES (i2); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_DEAD\n-\t\t&& STACK_REG_P (XEXP (note, 0)))\n-\t      SET_HARD_REG_BIT (i2_regset, REGNO (XEXP (note, 0)));\n-\n-\t  GO_IF_HARD_REG_EQUAL (i1_regset, i2_regset, done);\n-\n-\t  lose = 1;\n-\n-\tdone:\n-\t  ;\n-\t}\n-#endif\n-\n-      /* Don't allow old-style asm or volatile extended asms to be accepted\n-\t for cross jumping purposes.  It is conceptually correct to allow\n-\t them, since cross-jumping preserves the dynamic instruction order\n-\t even though it is changing the static instruction order.  However,\n-\t if an asm is being used to emit an assembler pseudo-op, such as\n-\t the MIPS `.set reorder' pseudo-op, then the static instruction order\n-\t matters and it must be preserved.  */\n-      if (GET_CODE (p1) == ASM_INPUT || GET_CODE (p2) == ASM_INPUT\n-\t  || (GET_CODE (p1) == ASM_OPERANDS && MEM_VOLATILE_P (p1))\n-\t  || (GET_CODE (p2) == ASM_OPERANDS && MEM_VOLATILE_P (p2)))\n-\tlose = 1;\n-\n-      if (lose || GET_CODE (p1) != GET_CODE (p2)\n-\t  || ! rtx_renumbered_equal_p (p1, p2))\n-\t{\n-\t  /* The following code helps take care of G++ cleanups.  */\n-\t  rtx equiv1;\n-\t  rtx equiv2;\n-\n-\t  if (!lose && GET_CODE (p1) == GET_CODE (p2)\n-\t      && ((equiv1 = find_reg_note (i1, REG_EQUAL, NULL_RTX)) != 0\n-\t\t  || (equiv1 = find_reg_note (i1, REG_EQUIV, NULL_RTX)) != 0)\n-\t      && ((equiv2 = find_reg_note (i2, REG_EQUAL, NULL_RTX)) != 0\n-\t\t  || (equiv2 = find_reg_note (i2, REG_EQUIV, NULL_RTX)) != 0)\n-\t      /* If the equivalences are not to a constant, they may\n-\t\t reference pseudos that no longer exist, so we can't\n-\t\t use them.  */\n-\t      && CONSTANT_P (XEXP (equiv1, 0))\n-\t      && rtx_equal_p (XEXP (equiv1, 0), XEXP (equiv2, 0)))\n-\t    {\n-\t      rtx s1 = single_set (i1);\n-\t      rtx s2 = single_set (i2);\n-\t      if (s1 != 0 && s2 != 0\n-\t\t  && rtx_renumbered_equal_p (SET_DEST (s1), SET_DEST (s2)))\n-\t\t{\n-\t\t  validate_change (i1, &SET_SRC (s1), XEXP (equiv1, 0), 1);\n-\t\t  validate_change (i2, &SET_SRC (s2), XEXP (equiv2, 0), 1);\n-\t\t  if (! rtx_renumbered_equal_p (p1, p2))\n-\t\t    cancel_changes (0);\n-\t\t  else if (apply_change_group ())\n-\t\t    goto win;\n-\t\t}\n-\t    }\n-\n-\t  /* Insns fail to match; cross jumping is limited to the following\n-\t     insns.  */\n-\n-#ifdef HAVE_cc0\n-\t  /* Don't allow the insn after a compare to be shared by\n-\t     cross-jumping unless the compare is also shared.\n-\t     Here, if either of these non-matching insns is a compare,\n-\t     exclude the following insn from possible cross-jumping.  */\n-\t  if (sets_cc0_p (p1) || sets_cc0_p (p2))\n-\t    last1 = afterlast1, last2 = afterlast2, ++minimum;\n-#endif\n-\n-\t  /* If cross-jumping here will feed a jump-around-jump\n-\t     optimization, this jump won't cost extra, so reduce\n-\t     the minimum.  */\n-\t  if (GET_CODE (i1) == JUMP_INSN\n-\t      && JUMP_LABEL (i1)\n-\t      && prev_real_insn (JUMP_LABEL (i1)) == e1)\n-\t    --minimum;\n-\t  break;\n-\t}\n-\n-    win:\n-      if (GET_CODE (p1) != USE && GET_CODE (p1) != CLOBBER)\n-\t{\n-\t  /* Ok, this insn is potentially includable in a cross-jump here.  */\n-\t  afterlast1 = last1, afterlast2 = last2;\n-\t  last1 = i1, last2 = i2, --minimum;\n-\t}\n-    }\n-\n-  if (minimum <= 0 && last1 != 0 && last1 != e1)\n-    *f1 = last1, *f2 = last2;\n-}\n-\n-static void\n-do_cross_jump (insn, newjpos, newlpos)\n-     rtx insn, newjpos, newlpos;\n-{\n-  /* Find an existing label at this point\n-     or make a new one if there is none.  */\n-  register rtx label = get_label_before (newlpos);\n-\n-  /* Make the same jump insn jump to the new point.  */\n-  if (GET_CODE (PATTERN (insn)) == RETURN)\n-    {\n-      /* Remove from jump chain of returns.  */\n-      delete_from_jump_chain (insn);\n-      /* Change the insn.  */\n-      PATTERN (insn) = gen_jump (label);\n-      INSN_CODE (insn) = -1;\n-      JUMP_LABEL (insn) = label;\n-      LABEL_NUSES (label)++;\n-      /* Add to new the jump chain.  */\n-      if (INSN_UID (label) < max_jump_chain\n-\t  && INSN_UID (insn) < max_jump_chain)\n-\t{\n-\t  jump_chain[INSN_UID (insn)] = jump_chain[INSN_UID (label)];\n-\t  jump_chain[INSN_UID (label)] = insn;\n-\t}\n-    }\n-  else\n-    redirect_jump (insn, label, 1);\n-\n-  /* Delete the matching insns before the jump.  Also, remove any REG_EQUAL\n-     or REG_EQUIV note in the NEWLPOS stream that isn't also present in\n-     the NEWJPOS stream.  */\n-\n-  while (newjpos != insn)\n-    {\n-      rtx lnote;\n-\n-      for (lnote = REG_NOTES (newlpos); lnote; lnote = XEXP (lnote, 1))\n-\tif ((REG_NOTE_KIND (lnote) == REG_EQUAL\n-\t     || REG_NOTE_KIND (lnote) == REG_EQUIV)\n-\t    && ! find_reg_note (newjpos, REG_EQUAL, XEXP (lnote, 0))\n-\t    && ! find_reg_note (newjpos, REG_EQUIV, XEXP (lnote, 0)))\n-\t  remove_note (newlpos, lnote);\n-\n-      delete_insn (newjpos);\n-      newjpos = next_real_insn (newjpos);\n-      newlpos = next_real_insn (newlpos);\n-    }\n-}\n-\f\n /* Return the label before INSN, or put a new label there.  */\n \n rtx\n@@ -1658,50 +1269,6 @@ get_label_after (insn)\n   return label;\n }\n \f\n-/* Return 1 if INSN is a jump that jumps to right after TARGET\n-   only on the condition that TARGET itself would drop through.\n-   Assumes that TARGET is a conditional jump.  */\n-\n-static int\n-jump_back_p (insn, target)\n-     rtx insn, target;\n-{\n-  rtx cinsn, ctarget;\n-  enum rtx_code codei, codet;\n-  rtx set, tset;\n-\n-  if (! any_condjump_p (insn)\n-      || any_uncondjump_p (target)\n-      || target != prev_real_insn (JUMP_LABEL (insn)))\n-    return 0;\n-  set = pc_set (insn);\n-  tset = pc_set (target);\n-\n-  cinsn = XEXP (SET_SRC (set), 0);\n-  ctarget = XEXP (SET_SRC (tset), 0);\n-\n-  codei = GET_CODE (cinsn);\n-  codet = GET_CODE (ctarget);\n-\n-  if (XEXP (SET_SRC (set), 1) == pc_rtx)\n-    {\n-      codei = reversed_comparison_code (cinsn, insn);\n-      if (codei == UNKNOWN)\n-\treturn 0;\n-    }\n-\n-  if (XEXP (SET_SRC (tset), 2) == pc_rtx)\n-    {\n-      codet = reversed_comparison_code (ctarget, target);\n-      if (codei == UNKNOWN)\n-\treturn 0;\n-    }\n-\n-  return (codei == codet\n-\t  && rtx_renumbered_equal_p (XEXP (cinsn, 0), XEXP (ctarget, 0))\n-\t  && rtx_renumbered_equal_p (XEXP (cinsn, 1), XEXP (ctarget, 1)));\n-}\n-\f\n /* Given a comparison (CODE ARG0 ARG1), inside a insn, INSN, return an code\n    of reversed comparison if it is possible to do so.  Otherwise return UNKNOWN.\n    UNKNOWN may be returned in case we are having CC_MODE compare and we don't\n@@ -2471,16 +2038,12 @@ tension_vector_labels (x, idx)\n    must be kept distinct if we have not yet done loop-optimization,\n    because the gap between them is where loop-optimize\n    will want to move invariant code to.  CROSS_JUMP tells us\n-   that loop-optimization is done with.\n-\n-   Once reload has completed (CROSS_JUMP non-zero), we need not consider\n-   two labels distinct if they are separated by only USE or CLOBBER insns.  */\n+   that loop-optimization is done with.  */\n \n void\n-mark_jump_label (x, insn, cross_jump, in_mem)\n+mark_jump_label (x, insn, in_mem)\n      register rtx x;\n      rtx insn;\n-     int cross_jump;\n      int in_mem;\n {\n   register RTX_CODE code = GET_CODE (x);\n@@ -2509,7 +2072,7 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \n       /* If this is a constant-pool reference, see if it is a label.  */\n       if (CONSTANT_POOL_ADDRESS_P (x))\n-\tmark_jump_label (get_pool_constant (x), insn, cross_jump, in_mem);\n+\tmark_jump_label (get_pool_constant (x), insn, in_mem);\n       break;\n \n     case LABEL_REF:\n@@ -2537,19 +2100,14 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t  {\n \t    if (GET_CODE (next) == CODE_LABEL)\n \t      label = next;\n-\t    else if (cross_jump && GET_CODE (next) == INSN\n-\t\t     && (GET_CODE (PATTERN (next)) == USE\n-\t\t\t || GET_CODE (PATTERN (next)) == CLOBBER))\n-\t      continue;\n \t    else if (GET_CODE (next) != NOTE)\n \t      break;\n-\t    else if (! cross_jump\n-\t\t     && (NOTE_LINE_NUMBER (next) == NOTE_INSN_LOOP_BEG\n-\t\t\t || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n-\t\t\t /* ??? Optional.  Disables some optimizations, but\n-\t\t\t    makes gcov output more accurate with -O.  */\n-\t\t\t || (flag_test_coverage\n-\t\t\t     && NOTE_LINE_NUMBER (next) > 0)))\n+\t    else if ((NOTE_LINE_NUMBER (next) == NOTE_INSN_LOOP_BEG\n+\t\t      || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n+\t\t      /* ??? Optional.  Disables some optimizations, but\n+\t\t\t makes gcov output more accurate with -O.  */\n+\t\t      || (flag_test_coverage\n+\t\t\t  && NOTE_LINE_NUMBER (next) > 0)))\n \t      break;\n \t  }\n \n@@ -2605,8 +2163,7 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t  int eltnum = code == ADDR_DIFF_VEC ? 1 : 0;\n \n \t  for (i = 0; i < XVECLEN (x, eltnum); i++)\n-\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX,\n-\t\t\t     cross_jump, in_mem);\n+\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX, in_mem);\n \t}\n       return;\n \n@@ -2618,12 +2175,12 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n       if (fmt[i] == 'e')\n-\tmark_jump_label (XEXP (x, i), insn, cross_jump, in_mem);\n+\tmark_jump_label (XEXP (x, i), insn, in_mem);\n       else if (fmt[i] == 'E')\n \t{\n \t  register int j;\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    mark_jump_label (XVECEXP (x, i, j), insn, cross_jump, in_mem);\n+\t    mark_jump_label (XVECEXP (x, i, j), insn, in_mem);\n \t}\n     }\n }"}, {"sha": "bdd1c98dbbf3245efeb165a46054e7dc57c87c94", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -419,6 +419,9 @@ reg_to_stack (first, file)\n   int max_uid;\n   block_info bi;\n \n+  if (!optimize)\n+    split_all_insns (0);\n+\n   /* See if there is something to do.  Flow analysis is quite\n      expensive so we might save some compilation time.  */\n   for (i = FIRST_STACK_REG; i <= LAST_STACK_REG; i++)\n@@ -429,7 +432,8 @@ reg_to_stack (first, file)\n \n   /* Ok, floating point instructions exist.  If not optimizing, \n      build the CFG and run life analysis.  */\n-  find_basic_blocks (first, max_reg_num (), file);\n+  if (!optimize)\n+    find_basic_blocks (first, max_reg_num (), file);\n   count_or_remove_death_notes (NULL, 1);\n   life_analysis (first, file, PROP_DEATH_NOTES);\n "}, {"sha": "5dd39862097146644e6660f2a08ef073e407990d", "filename": "gcc/rtl.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -1285,7 +1285,7 @@ extern enum rtx_code reverse_condition_maybe_unordered PARAMS ((enum rtx_code));\n extern enum rtx_code swap_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code unsigned_condition\tPARAMS ((enum rtx_code));\n extern enum rtx_code signed_condition\tPARAMS ((enum rtx_code));\n-extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int, int));\n+extern void mark_jump_label\t\tPARAMS ((rtx, rtx, int));\n \n /* In jump.c */\n extern rtx squeeze_notes\t\tPARAMS ((rtx, rtx));\n@@ -1715,7 +1715,7 @@ extern int rtx_renumbered_equal_p\tPARAMS ((rtx, rtx));\n extern int true_regnum\t\t\tPARAMS ((rtx));\n extern int redirect_jump_1\t\tPARAMS ((rtx, rtx));\n extern int redirect_jump\t\tPARAMS ((rtx, rtx, int));\n-extern void jump_optimize\t\tPARAMS ((rtx, int, int, int));\n+extern void jump_optimize\t\tPARAMS ((rtx, int, int));\n extern void jump_optimize_minimal\tPARAMS ((rtx));\n extern void rebuild_jump_labels\t\tPARAMS ((rtx));\n extern void thread_jumps\t\tPARAMS ((rtx, int, int));\n@@ -1729,8 +1729,6 @@ extern int condjump_in_parallel_p\tPARAMS ((rtx));\n extern void never_reached_warning\tPARAMS ((rtx));\n \n /* Flags for jump_optimize() */\n-#define JUMP_CROSS_JUMP\t\t\t1\n-#define JUMP_CROSS_JUMP_DEATH_MATTERS\t2\n #define JUMP_NOOP_MOVES\t\t\t1\n #define JUMP_AFTER_REGSCAN\t\t1\n "}, {"sha": "1e2e0b27b25a07aafa936fbe43838cfd060a31aa", "filename": "gcc/toplev.c", "status": "modified", "additions": 29, "deletions": 55, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=f3ba35e478b044aa9b5cdf2b93d7aa9f3dfdbdfc", "patch": "@@ -282,11 +282,10 @@ enum dump_file_index\n   DFI_rnreg,\n   DFI_ce2,\n   DFI_sched2,\n+  DFI_stack,\n   DFI_bbro,\n-  DFI_jump2,\n   DFI_mach,\n   DFI_dbr,\n-  DFI_stack,\n   DFI_MAX\n };\n \n@@ -296,7 +295,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"              o q   u     \"\n-\t\"       H  K   OPQ  TUV  YZ\"\n+\t\"       H JK   OPQ  TUV  YZ\"\n */\n \n struct dump_file_info dump_file[DFI_MAX] =\n@@ -330,7 +329,6 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"ce2\",\t'E', 1, 0, 0 },\n   { \"sched2\",\t'R', 1, 0, 0 },\n   { \"bbro\",\t'B', 1, 0, 0 },\n-  { \"jump2\",\t'J', 1, 0, 0 },\n   { \"mach\",\t'M', 1, 0, 0 },\n   { \"dbr\",\t'd', 0, 0, 0 },\n   { \"stack\",\t'k', 1, 0, 0 },\n@@ -2839,8 +2837,7 @@ rest_of_compilation (decl)\n \n \t      optimize = 0;\n \t      find_exception_handler_labels ();\n-\t      jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t\t     !JUMP_AFTER_REGSCAN);\n+\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \t      optimize = saved_optimize;\n \t    }\n \n@@ -2947,8 +2944,7 @@ rest_of_compilation (decl)\n   expected_value_to_br_prob ();\n \n   reg_scan (insns, max_reg_num (), 0);\n-  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t JUMP_AFTER_REGSCAN);\n+  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n \n   timevar_pop (TV_JUMP);\n \n@@ -3090,8 +3086,7 @@ rest_of_compilation (decl)\n       if (tem || optimize > 1)\n \t{\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t\t !JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n \t}\n \n@@ -3163,8 +3158,7 @@ rest_of_compilation (decl)\n \t{\n \t  tem = tem2 = 0;\n \t  timevar_push (TV_JUMP);\n-\t  jump_optimize (insns, !JUMP_CROSS_JUMP, !JUMP_NOOP_MOVES,\n-\t\t\t !JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \t  timevar_pop (TV_JUMP);\n \n \t  if (flag_expensive_optimizations)\n@@ -3237,8 +3231,7 @@ rest_of_compilation (decl)\n \t  delete_trivially_dead_insns (insns, max_reg_num ());\n \n \t  reg_scan (insns, max_reg_num (), 0);\n-\t  jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n+\t  jump_optimize (insns, !JUMP_NOOP_MOVES, JUMP_AFTER_REGSCAN);\n \n \t  timevar_push (TV_IFCVT);\n \n@@ -3256,8 +3249,7 @@ rest_of_compilation (decl)\n \t  if (tem)\n \t    {\n \t      timevar_push (TV_JUMP);\n-\t      jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t\t     !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+\t      jump_optimize (insns, !JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n \t      timevar_pop (TV_JUMP);\n \t    }\n \t}\n@@ -3571,8 +3563,7 @@ rest_of_compilation (decl)\n   timevar_push (TV_FLOW2);\n   open_dump_file (DFI_flow2, decl);\n \n-  jump_optimize (insns, !JUMP_CROSS_JUMP,\n-\t\t JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n+  jump_optimize (insns, JUMP_NOOP_MOVES, !JUMP_AFTER_REGSCAN);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n   /* On some machines, the prologue and epilogue code, or parts thereof,\n@@ -3637,6 +3628,10 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_ce2, print_rtl_with_bb, insns);\n       timevar_pop (TV_IFCVT2);\n     }\n+#ifdef STACK_REGS\n+  if (optimize)\n+    split_all_insns (1);\n+#endif\n \n #ifdef INSN_SCHEDULING\n   if (optimize > 0 && flag_schedule_insns_after_reload)\n@@ -3663,6 +3658,17 @@ rest_of_compilation (decl)\n     = optimize > 0 && only_leaf_regs_used () && leaf_function_p ();\n #endif\n \n+#ifdef STACK_REGS\n+  timevar_push (TV_REG_STACK);\n+  open_dump_file (DFI_stack, decl);\n+\n+  reg_to_stack (insns, rtl_dump_file);\n+\n+  close_dump_file (DFI_stack, print_rtl, insns);\n+  timevar_pop (TV_REG_STACK);\n+\n+  ggc_collect ();\n+#endif\n   if (optimize > 0 && flag_reorder_blocks)\n     {\n       timevar_push (TV_REORDER_BLOCKS);\n@@ -3671,26 +3677,10 @@ rest_of_compilation (decl)\n       reorder_basic_blocks ();\n \n       close_dump_file (DFI_bbro, print_rtl_with_bb, insns);\n+      cleanup_cfg (CLEANUP_EXPENSIVE | CLEANUP_POST_REGSTACK);\n       timevar_pop (TV_REORDER_BLOCKS);\n     }\n \n-  /* One more attempt to remove jumps to .+1 left by dead-store elimination.\n-     Also do cross-jumping this time and delete no-op move insns.  */\n-\n-  if (optimize > 0)\n-    {\n-      timevar_push (TV_JUMP);\n-      open_dump_file (DFI_jump2, decl);\n-\n-      jump_optimize (insns, JUMP_CROSS_JUMP, JUMP_NOOP_MOVES,\n-\t\t     !JUMP_AFTER_REGSCAN);\n-\n-      /* CFG no longer kept up to date.  */\n-\n-      close_dump_file (DFI_jump2, print_rtl, insns);\n-      timevar_pop (TV_JUMP);\n-    }\n-\n   /* If a machine dependent reorganization is needed, call it.  */\n #ifdef MACHINE_DEPENDENT_REORG\n   open_dump_file (DFI_mach, decl);\n@@ -3702,6 +3692,8 @@ rest_of_compilation (decl)\n   ggc_collect ();\n #endif\n \n+  /* CFG no longer kept up to date.  */\n+\n   /* If a scheduling pass for delayed branches is to be done,\n      call the scheduling code.  */\n \n@@ -3720,28 +3712,10 @@ rest_of_compilation (decl)\n     }\n #endif\n \n+#if defined (HAVE_ATTR_length) && !defined (STACK_REGS)\n   timevar_push (TV_SHORTEN_BRANCH);\n-  if (0\n-#ifdef HAVE_ATTR_length\n-      || 1\n-#endif\n-#ifdef STACK_REGS\n-      || 1\n-#endif\n-      )\n-    split_all_insns (0);\n+  split_all_insns (0);\n   timevar_pop (TV_SHORTEN_BRANCH);\n-\n-#ifdef STACK_REGS\n-  timevar_push (TV_REG_STACK);\n-  open_dump_file (DFI_stack, decl);\n-\n-  reg_to_stack (insns, rtl_dump_file);\n-\n-  close_dump_file (DFI_stack, print_rtl, insns);\n-  timevar_pop (TV_REG_STACK);\n-\n-  ggc_collect ();\n #endif\n \n   convert_to_eh_region_ranges ();"}]}