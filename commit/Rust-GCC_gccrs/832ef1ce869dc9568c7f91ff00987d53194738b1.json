{"sha": "832ef1ce869dc9568c7f91ff00987d53194738b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMyZWYxY2U4NjlkYzk1NjhjN2Y5MWZmMDA5ODdkNTMxOTQ3MzhiMQ==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2005-01-09T22:57:45Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2005-01-09T22:57:45Z"}, "message": "re PR fortran/17675 ([Regression w.r.t. g77] Alignment constraints not honored in EQUIVALENCE)\n\n2005-01-09  Paul Brook  <paul@codesourcery.com>\n\n\tPR fortran/17675\n\t* trans-common.c (current_common, current_offset): Remove.\n\t(create_common): Add head argument.\n\t(align_segment): New function.\n\t(apply_segment_offset): New function.\n\t(translate_common): Merge code from new_segment.  Handle alignment.\n\t(new_segment): Remove.\n\t(finish_equivalences): Ensure proper alignment.\ntestsuite/\n\t* gfortran.dg/common_2.f90: New file.\n\t* gfortran.dg/common_3.f90: New file.\n\nFrom-SVN: r93122", "tree": {"sha": "c22196ec02502cd35005a6f2c53a95eb645eafdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c22196ec02502cd35005a6f2c53a95eb645eafdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/832ef1ce869dc9568c7f91ff00987d53194738b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832ef1ce869dc9568c7f91ff00987d53194738b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/832ef1ce869dc9568c7f91ff00987d53194738b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/832ef1ce869dc9568c7f91ff00987d53194738b1/comments", "author": null, "committer": null, "parents": [{"sha": "351bae3d7df284c94babb81e1b5bb6142c5963a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351bae3d7df284c94babb81e1b5bb6142c5963a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351bae3d7df284c94babb81e1b5bb6142c5963a8"}], "stats": {"total": 239, "additions": 188, "deletions": 51}, "files": [{"sha": "9553ef3dbbec6dea29b320d5290e9d2e886a00ed", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=832ef1ce869dc9568c7f91ff00987d53194738b1", "patch": "@@ -1,3 +1,14 @@\n+2005-01-09  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/17675\n+\t* trans-common.c (current_common, current_offset): Remove.\n+\t(create_common): Add head argument.\n+\t(align_segment): New function.\n+\t(apply_segment_offset): New function.\n+\t(translate_common): Merge code from new_segment.  Handle alignment.\n+\t(new_segment): Remove.\n+\t(finish_equivalences): Ensure proper alignment.\n+\n 2005-01-08  Tobias Schl\"uter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* trans-const.c: Don't include unused math.h."}, {"sha": "a00e7e8959cd97ca892cd80b67c0d5b911d135f9", "filename": "gcc/fortran/trans-common.c", "status": "modified", "additions": 148, "deletions": 51, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=832ef1ce869dc9568c7f91ff00987d53194738b1", "patch": "@@ -116,8 +116,7 @@ typedef struct segment_info\n   struct segment_info *next;\n } segment_info;\n \n-static segment_info *current_segment, *current_common;\n-static HOST_WIDE_INT current_offset;\n+static segment_info * current_segment;\n static gfc_namespace *gfc_common_ns = NULL;\n \n #define BLANK_COMMON_NAME \"__BLNK__\"\n@@ -354,7 +353,7 @@ build_common_decl (gfc_common_head *com, tree union_type, bool is_init)\n    backend declarations for all of the elements.  */\n \n static void\n-create_common (gfc_common_head *com)\n+create_common (gfc_common_head *com, segment_info * head)\n {\n   segment_info *s, *next_s;\n   tree union_type;\n@@ -368,7 +367,7 @@ create_common (gfc_common_head *com)\n   rli = start_record_layout (union_type);\n   field_link = &TYPE_FIELDS (union_type);\n \n-  for (s = current_common; s; s = s->next)\n+  for (s = head; s; s = s->next)\n     {\n       build_field (s, union_type, rli);\n \n@@ -393,7 +392,7 @@ create_common (gfc_common_head *com)\n       HOST_WIDE_INT offset = 0;\n \n       list = NULL_TREE;\n-      for (s = current_common; s; s = s->next)\n+      for (s = head; s; s = s->next)\n         {\n           if (s->sym->value)\n             {\n@@ -427,7 +426,7 @@ create_common (gfc_common_head *com)\n     }\n \n   /* Build component reference for each variable.  */\n-  for (s = current_common; s; s = next_s)\n+  for (s = head; s; s = next_s)\n     {\n       s->sym->backend_decl = build3 (COMPONENT_REF, TREE_TYPE (s->field),\n \t\t\t\t     decl, s->field, NULL_TREE);\n@@ -699,29 +698,149 @@ add_equivalences (void)\n }\n \n \n-/* Given a seed symbol, create a new segment consisting of that symbol\n-   and all of the symbols equivalenced with that symbol.  */\n+/* Returns the offset neccessary to properly align the current equivalence.\n+   Sets *palign to the required alignment.  */\n+\n+static HOST_WIDE_INT\n+align_segment (unsigned HOST_WIDE_INT * palign)\n+{\n+  segment_info *s;\n+  unsigned HOST_WIDE_INT offset;\n+  unsigned HOST_WIDE_INT max_align;\n+  unsigned HOST_WIDE_INT this_align;\n+  unsigned HOST_WIDE_INT this_offset;\n+\n+  max_align = 1;\n+  offset = 0;\n+  for (s = current_segment; s; s = s->next)\n+    {\n+      this_align = TYPE_ALIGN_UNIT (s->field);\n+      if (s->offset & (this_align - 1))\n+\t{\n+\t  /* Field is misaligned.  */\n+\t  this_offset = this_align - ((s->offset + offset) & (this_align - 1));\n+\t  if (this_offset & (max_align - 1))\n+\t    {\n+\t      /* Aligning this field would misalign a previous field.  */\n+\t      gfc_error (\"The equivalence set for variable '%s' \"\n+\t\t\t \"declared at %L violates alignment requirents\",\n+\t\t\t s->sym->name, &s->sym->declared_at);\n+\t    }\n+\t  offset += this_offset;\n+\t}\n+      max_align = this_align;\n+    }\n+  if (palign)\n+    *palign = max_align;\n+  return offset;\n+}\n+\n+\n+/* Adjust segment offsets by the given amount.  */\n \n static void\n-new_segment (gfc_common_head *common, gfc_symbol *sym)\n+apply_segment_offset (segment_info * s, HOST_WIDE_INT offset)\n {\n+  for (; s; s = s->next)\n+    s->offset += offset;\n+}\n+\n+\n+/* Lay out a symbol in a common block.  If the symbol has already been seen\n+   then check the location is consistent.  Otherwise create segments\n+   for that symbol and all the symbols equivalenced with it.  */\n+\n+/* Translate a single common block.  */\n+\n+static void\n+translate_common (gfc_common_head *common, gfc_symbol *var_list)\n+{\n+  gfc_symbol *sym;\n+  segment_info *s;\n+  segment_info *common_segment;\n+  HOST_WIDE_INT offset;\n+  HOST_WIDE_INT current_offset;\n+  unsigned HOST_WIDE_INT align;\n+  unsigned HOST_WIDE_INT max_align;\n+\n+  common_segment = NULL;\n+  current_offset = 0;\n+  max_align = 1;\n+\n+  /* Add symbols to the segment.  */\n+  for (sym = var_list; sym; sym = sym->common_next)\n+    {\n+      if (sym->equiv_built)\n+\t{\n+\t  /* Symbol has already been added via an equivalence.  */\n+\t  current_segment = common_segment;\n+\t  s = find_segment_info (sym);\n+\n+\t  /* Ensure the current location is properly aligned.  */\n+\t  align = TYPE_ALIGN_UNIT (s->field);\n+\t  current_offset = (current_offset + align - 1) &~ (align - 1);\n+\n+\t  /* Verify that it ended up where we expect it.  */\n+\t  if (s->offset != current_offset)\n+\t    {\n+\t      gfc_error (\"Equivalence for '%s' does not match ordering of \"\n+\t\t\t \"COMMON '%s' at %L\", sym->name,\n+\t\t\t common->name, &common->where);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* A symbol we haven't seen before.  */\n+\t  s = current_segment = get_segment_info (sym, current_offset);\n \n-  current_segment = get_segment_info (sym, current_offset);\n+\t  /* Add all objects directly or indirectly equivalenced with this\n+\t     symbol.  */\n+\t  add_equivalences ();\n \n-  /* The offset of the next common variable.  */\n-  current_offset += current_segment->length;\n+\t  if (current_segment->offset < 0)\n+\t    gfc_error (\"The equivalence set for '%s' cause an invalid \"\n+\t\t       \"extension to COMMON '%s' at %L\", sym->name,\n+\t\t       common->name, &common->where);\n \n-  /* Add all object directly or indirectly equivalenced with this common\n-     variable.  */\n-  add_equivalences ();\n+\t  offset = align_segment (&align);\n+\t  apply_segment_offset (current_segment, offset);\n \n-  if (current_segment->offset < 0)\n-    gfc_error (\"The equivalence set for '%s' cause an invalid \"\n-\t       \"extension to COMMON '%s' at %L\", sym->name,\n-\t       common->name, &common->where);\n+\t  if (offset & (max_align - 1))\n+\t    {\n+\t      /* The required offset conflicts with previous alignment\n+\t\t requirements.  Insert padding immediately before this\n+\t\t segment.  */\n+\t      gfc_warning (\"Padding of %d bytes required before '%s' in \"\n+\t\t\t   \"COMMON '%s' at %L\", offset, s->sym->name,\n+\t\t\t   common->name, &common->where);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Offset the whole common block.  */\n+\t      apply_segment_offset (common_segment, offset);\n+\t    }\n \n-  /* Add these to the common block.  */\n-  current_common = add_segments (current_common, current_segment);\n+\t  /* Apply the offset to the new segments.  */\n+\t  apply_segment_offset (current_segment, offset);\n+\t  current_offset += offset;\n+\t  if (max_align < align)\n+\t    max_align = align;\n+\n+\t  /* Add the new segments to the common block.  */\n+\t  common_segment = add_segments (common_segment, current_segment);\n+\t}\n+\n+      /* The offset of the next common variable.  */\n+      current_offset += s->length;\n+    }\n+\n+  if (common_segment->offset != 0)\n+    {\n+      gfc_warning (\"COMMON '%s' at %L requires %d bytes of padding at start\",\n+\t\t   common->name, &common->where, common_segment->offset);\n+    }\n+\n+  create_common (common, common_segment);\n }\n \n \n@@ -732,7 +851,6 @@ finish_equivalences (gfc_namespace *ns)\n {\n   gfc_equiv *z, *y;\n   gfc_symbol *sym;\n-  segment_info *v;\n   HOST_WIDE_INT min_offset;\n \n   for (z = ns->equiv; z; z = z->next)\n@@ -746,47 +864,26 @@ finish_equivalences (gfc_namespace *ns)\n         /* All objects directly or indirectly equivalenced with this symbol.  */\n         add_equivalences ();\n \n-        /* Calculate the minimal offset.  */\n-        min_offset = current_segment->offset;\n+        /* Bias the offsets to to start at zero.  */\n+        min_offset = -current_segment->offset;\n+\n+\t/* Ensure the block is properly aligned.  */\n+\tmin_offset += align_segment (NULL);\n \n-        /* Adjust the offset of each equivalence object.  */\n-        for (v = current_segment; v; v = v->next)\n-\t  v->offset -= min_offset;\n+\tapply_segment_offset (current_segment, min_offset);\n \n-        current_common = current_segment;\n-        create_common (NULL);\n+\t/* Create the decl.  */\n+        create_common (NULL, current_segment);\n         break;\n       }\n }\n \n \n-/* Translate a single common block.  */\n-\n-static void\n-translate_common (gfc_common_head *common, gfc_symbol *var_list)\n-{\n-  gfc_symbol *sym;\n-\n-  current_common = NULL;\n-  current_offset = 0;\n-\n-  /* Add symbols to the segment.  */\n-  for (sym = var_list; sym; sym = sym->common_next)\n-    {\n-      if (! sym->equiv_built)\n-\tnew_segment (common, sym);\n-    }\n-\n-  create_common (common);\n-}\n-\n-\n /* Work function for translating a named common block.  */\n \n static void\n named_common (gfc_symtree *st)\n {\n-\n   translate_common (st->n.common, st->n.common->head);\n }\n "}, {"sha": "1c3629da0d6deac399cd6acf14c67219eae44091", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=832ef1ce869dc9568c7f91ff00987d53194738b1", "patch": "@@ -1,3 +1,8 @@\n+2005-01-09  Paul Brook  <paul@codesourcery.com>\n+\n+\t* gfortran.dg/common_2.f90: New file.\n+\t* gfortran.dg/common_3.f90: New file.\n+\n 2005-01-09  Zdenek Dvorak  <dvorakz@suse.cz>\n \n \t* gcc.dg/tree-ssa/loop-4.c: Fix outcome."}, {"sha": "661e582059ff9d7f99b146dea9f873a233b14b51", "filename": "gcc/testsuite/gfortran.dg/common_2.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_2.f90?ref=832ef1ce869dc9568c7f91ff00987d53194738b1", "patch": "@@ -0,0 +1,15 @@\n+! { dg-do run }\n+! The equivalence was causing us to miss out c when laying out the common\n+! block.\n+program common_2\n+  common /block/ a, b, c, d\n+  integer a, b, c, d, n\n+  dimension n(4)\n+  equivalence (a, n(1))\n+  equivalence (c, n(3))\n+  a = 1\n+  b = 2\n+  c = 3\n+  d = 4\n+  if (any (n .ne. (/1, 2, 3, 4/))) call abort\n+end program"}, {"sha": "818738e45d377aa9cf630b70898ab9226e2dde6f", "filename": "gcc/testsuite/gfortran.dg/common_3.f90", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/832ef1ce869dc9568c7f91ff00987d53194738b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcommon_3.f90?ref=832ef1ce869dc9568c7f91ff00987d53194738b1", "patch": "@@ -0,0 +1,9 @@\n+! { dg-do compile }\n+! Check that equivalences match common block layout.\n+program common_3\n+  common /block/ a, b, c, d ! { dg-error \"not match ordering\" \"\" }\n+  integer a, b, c, d, n\n+  dimension n(4)\n+  equivalence (a, n(1))\n+  equivalence (c, n(4))\n+end program"}]}