{"sha": "5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkxMGZiNTliOWRmOWRiZGRlOGE3MGE3MTYwOWM0YmMxNDY3YTI5Yg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.vnet.ibm.com", "date": "2009-09-14T16:59:12Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2009-09-14T16:59:12Z"}, "message": "Fix PR 41210 & 41331 on powerpc\n\nFrom-SVN: r151691", "tree": {"sha": "ad3c1fb09c7be8aee817570885e9f6f2a67e66cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad3c1fb09c7be8aee817570885e9f6f2a67e66cf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/comments", "author": null, "committer": null, "parents": [{"sha": "6c1c1dfa24f6239c3d70c901693de65b3390da65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c1c1dfa24f6239c3d70c901693de65b3390da65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c1c1dfa24f6239c3d70c901693de65b3390da65"}], "stats": {"total": 112, "additions": 65, "deletions": 47}, "files": [{"sha": "8971af86ff48af01621a7b7dd1921a51dfe245e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "patch": "@@ -1,3 +1,22 @@\n+2009-09-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/41210\n+\t* config/rs6000/rs6000.c (rs6000_function_value): V2DF and V2DI\n+\tare returned in the same register (vs34 or v2) that Altivec vector\n+\ttypes are returned in.\n+\t(rs6000_libcall_value): Ditto.\n+\n+\tPR target/41331\n+\t* config/rs6000/rs6000.c (rs6000_emit_move): Use gen_add3_insn\n+\tinstead of explicit addsi3/adddi3 calls.\n+\t(rs6000_split_multireg_move): Ditto.\n+\t(rs6000_emit_allocate_stack): Ditto.\n+\t(rs6000_emit_prologue): Ditto.\n+\t(rs6000_output_mi_thunk): Ditto.\n+\n+\t* config/rs6000/rs6000.md (bswapdi*): Don't assume the pointer\n+\tsize is 64 bits if we can use 64-bit registers.\n+\n 2009-09-14  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.c (bfin_longcall_p): Don't use short calls for weak"}, {"sha": "f796c08d3c86491b78bd1b20574a17feef86e6e6", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 15, "deletions": 33, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "patch": "@@ -6488,10 +6488,7 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t      rtx other = XEXP (XEXP (operands[1], 0), 1);\n \n \t      sym = force_reg (mode, sym);\n-\t      if (mode == SImode)\n-\t\temit_insn (gen_addsi3 (operands[0], sym, other));\n-\t      else\n-\t\temit_insn (gen_adddi3 (operands[0], sym, other));\n+\t      emit_insn (gen_add3_insn (operands[0], sym, other));\n \t      return;\n \t    }\n \n@@ -16473,9 +16470,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t      delta_rtx = (GET_CODE (XEXP (src, 0)) == PRE_INC\n \t\t\t   ? GEN_INT (GET_MODE_SIZE (GET_MODE (src)))\n \t\t\t   : GEN_INT (-GET_MODE_SIZE (GET_MODE (src))));\n-\t      emit_insn (TARGET_32BIT\n-\t\t\t ? gen_addsi3 (breg, breg, delta_rtx)\n-\t\t\t : gen_adddi3 (breg, breg, delta_rtx));\n+\t      emit_insn (gen_add3_insn (breg, breg, delta_rtx));\n \t      src = replace_equiv_address (src, breg);\n \t    }\n \t  else if (! rs6000_offsettable_memref_p (src))\n@@ -16525,9 +16520,7 @@ rs6000_split_multireg_move (rtx dst, rtx src)\n \t\t  used_update = true;\n \t\t}\n \t      else\n-\t\temit_insn (TARGET_32BIT\n-\t\t\t   ? gen_addsi3 (breg, breg, delta_rtx)\n-\t\t\t   : gen_adddi3 (breg, breg, delta_rtx));\n+\t\temit_insn (gen_add3_insn (breg, breg, delta_rtx));\n \t      dst = replace_equiv_address (dst, breg);\n \t    }\n \t  else\n@@ -17728,14 +17721,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n \t  && REGNO (stack_limit_rtx) > 1\n \t  && REGNO (stack_limit_rtx) <= 31)\n \t{\n-\t  emit_insn (TARGET_32BIT\n-\t\t     ? gen_addsi3 (tmp_reg,\n-\t\t\t\t   stack_limit_rtx,\n-\t\t\t\t   GEN_INT (size))\n-\t\t     : gen_adddi3 (tmp_reg,\n-\t\t\t\t   stack_limit_rtx,\n-\t\t\t\t   GEN_INT (size)));\n-\n+\t  emit_insn (gen_add3_insn (tmp_reg, stack_limit_rtx, GEN_INT (size)));\n \t  emit_insn (gen_cond_trap (LTU, stack_reg, tmp_reg,\n \t\t\t\t    const0_rtx));\n \t}\n@@ -18648,9 +18634,7 @@ rs6000_emit_prologue (void)\n           rtx ptr_reg = (sp_reg_rtx == frame_reg_rtx\n                          ? sp_reg_rtx : r11);\n \n-          emit_insn (TARGET_32BIT\n-                     ? gen_addsi3 (r11, ptr_reg, offset)\n-                     : gen_adddi3 (r11, ptr_reg, offset));\n+\t  emit_insn (gen_add3_insn (r11, ptr_reg, offset));\n         }\n \n       par = rs6000_make_savres_rtx (info, frame_reg_rtx,\n@@ -20090,12 +20074,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n   /* Apply the constant offset, if required.  */\n   if (delta)\n-    {\n-      rtx delta_rtx = GEN_INT (delta);\n-      emit_insn (TARGET_32BIT\n-\t\t ? gen_addsi3 (this_rtx, this_rtx, delta_rtx)\n-\t\t : gen_adddi3 (this_rtx, this_rtx, delta_rtx));\n-    }\n+    emit_insn (gen_add3_insn (this_rtx, this_rtx, GEN_INT (delta)));\n \n   /* Apply the offset from the vtable, if required.  */\n   if (vcall_offset)\n@@ -20106,9 +20085,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n       emit_move_insn (tmp, gen_rtx_MEM (Pmode, this_rtx));\n       if (((unsigned HOST_WIDE_INT) vcall_offset) + 0x8000 >= 0x10000)\n \t{\n-\t  emit_insn (TARGET_32BIT\n-\t\t     ? gen_addsi3 (tmp, tmp, vcall_offset_rtx)\n-\t\t     : gen_adddi3 (tmp, tmp, vcall_offset_rtx));\n+\t  emit_insn (gen_add3_insn (tmp, tmp, vcall_offset_rtx));\n \t  emit_move_insn (tmp, gen_rtx_MEM (Pmode, tmp));\n \t}\n       else\n@@ -20117,9 +20094,7 @@ rs6000_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n \n \t  emit_move_insn (tmp, gen_rtx_MEM (Pmode, loc));\n \t}\n-      emit_insn (TARGET_32BIT\n-\t\t ? gen_addsi3 (this_rtx, this_rtx, tmp)\n-\t\t : gen_adddi3 (this_rtx, this_rtx, tmp));\n+      emit_insn (gen_add3_insn (this_rtx, this_rtx, tmp));\n     }\n \n   /* Generate a tail call to the target function.  */\n@@ -25002,6 +24977,10 @@ rs6000_function_value (const_tree valtype, const_tree func ATTRIBUTE_UNUSED)\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI\n \t   && ALTIVEC_VECTOR_MODE (mode))\n     regno = ALTIVEC_ARG_RETURN;\n+  else if (TREE_CODE (valtype) == VECTOR_TYPE\n+\t   && TARGET_VSX && TARGET_ALTIVEC_ABI\n+\t   && VSX_VECTOR_MODE (mode))\n+    regno = ALTIVEC_ARG_RETURN;\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT\n \t   && (mode == DFmode || mode == DCmode\n \t       || mode == TFmode || mode == TCmode))\n@@ -25043,6 +25022,9 @@ rs6000_libcall_value (enum machine_mode mode)\n   else if (ALTIVEC_VECTOR_MODE (mode)\n \t   && TARGET_ALTIVEC && TARGET_ALTIVEC_ABI)\n     regno = ALTIVEC_ARG_RETURN;\n+  else if (VSX_VECTOR_MODE (mode)\n+\t   && TARGET_VSX && TARGET_ALTIVEC_ABI)\n+    regno = ALTIVEC_ARG_RETURN;\n   else if (COMPLEX_MODE_P (mode) && targetm.calls.split_complex_arg)\n     return rs6000_complex_function_value (mode);\n   else if (TARGET_E500_DOUBLE && TARGET_HARD_FLOAT"}, {"sha": "8ea90d825d7b1100fc16760c868f5423ac192ce7", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "patch": "@@ -2392,9 +2392,11 @@\n   if (!REG_P (operands[0]) && !REG_P (operands[1]))\n     operands[1] = force_reg (DImode, operands[1]);\n \n-  if (TARGET_32BIT)\n+  if (!TARGET_POWERPC64)\n     {\n-      /* 32-bit needs fewer scratch registers.  */\n+      /* 32-bit mode needs fewer scratch registers, but 32-bit addressing mode\n+\t that uses 64-bit registers needs the same scratch registers as 64-bit\n+\t mode.  */\n       emit_insn (gen_bswapdi2_32bit (operands[0], operands[1]));\n       DONE;\n     }\n@@ -2453,13 +2455,13 @@\n   addr1 = XEXP (src, 0);\n   if (GET_CODE (addr1) == PLUS)\n     {\n-      emit_insn (gen_adddi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n-      addr2 = gen_rtx_PLUS (DImode, op2, XEXP (addr1, 1));\n+      emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));\n     }\n   else\n     {\n       emit_move_insn (op2, GEN_INT (4));\n-      addr2 = gen_rtx_PLUS (DImode, op2, addr1);\n+      addr2 = gen_rtx_PLUS (Pmode, op2, addr1);\n     }\n \n   if (BYTES_BIG_ENDIAN)\n@@ -2503,13 +2505,13 @@\n   addr1 = XEXP (dest, 0);\n   if (GET_CODE (addr1) == PLUS)\n     {\n-      emit_insn (gen_adddi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n-      addr2 = gen_rtx_PLUS (DImode, op2, XEXP (addr1, 1));\n+      emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      addr2 = gen_rtx_PLUS (Pmode, op2, XEXP (addr1, 1));\n     }\n   else\n     {\n       emit_move_insn (op2, GEN_INT (4));\n-      addr2 = gen_rtx_PLUS (DImode, op2, addr1);\n+      addr2 = gen_rtx_PLUS (Pmode, op2, addr1);\n     }\n \n   emit_insn (gen_lshrdi3 (op3, src, GEN_INT (32)));\n@@ -2559,15 +2561,15 @@\n   [(set (match_operand:DI 0 \"reg_or_mem_operand\" \"=&r,Z,??&r\")\n \t(bswap:DI (match_operand:DI 1 \"reg_or_mem_operand\" \"Z,r,r\")))\n    (clobber (match_scratch:SI 2 \"=&b,&b,X\"))]\n-  \"TARGET_32BIT && (REG_P (operands[0]) || REG_P (operands[1]))\"\n+  \"!TARGET_POWERPC64 && (REG_P (operands[0]) || REG_P (operands[1]))\"\n   \"#\"\n   [(set_attr \"length\" \"16,12,36\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(bswap:DI (match_operand:DI 1 \"indexed_or_indirect_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n+  \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n   \"\n {\n@@ -2584,7 +2586,7 @@\n   addr1 = XEXP (src, 0);\n   if (GET_CODE (addr1) == PLUS)\n     {\n-      emit_insn (gen_addsi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));\n       addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));\n     }\n   else\n@@ -2612,7 +2614,7 @@\n   [(set (match_operand:DI 0 \"indexed_or_indirect_operand\" \"\")\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"gpc_reg_operand\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n+  \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n   \"\n {\n@@ -2629,7 +2631,7 @@\n   addr1 = XEXP (dest, 0);\n   if (GET_CODE (addr1) == PLUS)\n     {\n-      emit_insn (gen_addsi3 (op2, XEXP (addr1, 0), GEN_INT (4)));\n+      emit_insn (gen_add3_insn (op2, XEXP (addr1, 0), GEN_INT (4)));\n       addr2 = gen_rtx_PLUS (SImode, op2, XEXP (addr1, 1));\n     }\n   else\n@@ -2657,7 +2659,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(bswap:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")))\n    (clobber (match_operand:SI 2 \"\" \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n+  \"!TARGET_POWERPC64 && reload_completed\"\n   [(const_int 0)]\n   \"\n {"}, {"sha": "bcc86bfc148f00005b1a7890ce532c20363f7180", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "patch": "@@ -1,3 +1,9 @@\n+2009-09-14  Michael Meissner  <meissner@linux.vnet.ibm.com>\n+\n+\tPR target/41331\n+\t* gcc.target/powerpc/bswap64-4.c: New file to test bswap64 on a\n+\t-m32 -mpowerpc64 system.\n+\n 2009-09-14  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \tFrom Jie Zhang <jie.zhang@analog.com>:"}, {"sha": "074780ceaa474494faebeb7747354d44ba340e34", "filename": "gcc/testsuite/gcc.target/powerpc/bswap64-4.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap64-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5910fb59b9df9dbdde8a70a71609c4bc1467a29b/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap64-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbswap64-4.c?ref=5910fb59b9df9dbdde8a70a71609c4bc1467a29b", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-options \"-O2 -mpowerpc64\" } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-final { scan-assembler-times \"lwbrx\" 2 } } */\n+/* { dg-final { scan-assembler-times \"stwbrx\" 2 } } */\n+\n+long long swap_load (long long *a) { return __builtin_bswap64 (*a); }\n+long long swap_reg (long long a) { return __builtin_bswap64 (a); }\n+void swap_store (long long *a, long long b) { *a = __builtin_bswap64 (b); }"}]}