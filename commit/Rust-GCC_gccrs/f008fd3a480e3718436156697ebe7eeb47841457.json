{"sha": "f008fd3a480e3718436156697ebe7eeb47841457", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAwOGZkM2E0ODBlMzcxODQzNjE1NjY5N2ViZTdlZWI0Nzg0MTQ1Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-14T14:55:04Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-09-14T14:55:04Z"}, "message": "c++: Fix __is_*constructible/assignable for templates [PR102305]\n\nis_xible_helper returns error_mark_node (i.e. false from the traits)\nfor abstract classes by testing ABSTRACT_CLASS_TYPE_P (to) early.\nUnfortunately, as the testcase shows, that doesn't work on class templates\nthat haven't been instantiated yet, ABSTRACT_CLASS_TYPE_P for them is false\nuntil it is instantiated, which is done when the routine later constructs\na dummy object with that type.\n\nThe following patch fixes this by calling complete_type first, so that\nABSTRACT_CLASS_TYPE_P test will work properly, while keeping the handling\nof arrays with unknown bounds, or incomplete types where it is done\ncurrently.\n\n2021-09-14  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR c++/102305\n\t* method.c (is_xible_helper): Call complete_type on to.\n\n\t* g++.dg/cpp0x/pr102305.C: New test.", "tree": {"sha": "8730e0037a1d4b53d79d4be1d20c94e177d68573", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8730e0037a1d4b53d79d4be1d20c94e177d68573"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f008fd3a480e3718436156697ebe7eeb47841457", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f008fd3a480e3718436156697ebe7eeb47841457", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f008fd3a480e3718436156697ebe7eeb47841457", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f008fd3a480e3718436156697ebe7eeb47841457/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33fdbbe4ce6055eb858096d01720ccf94aa854ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33fdbbe4ce6055eb858096d01720ccf94aa854ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33fdbbe4ce6055eb858096d01720ccf94aa854ec"}], "stats": {"total": 40, "additions": 40, "deletions": 0}, "files": [{"sha": "32f7186a7749931b48f38f471a758329a86bc0b5", "filename": "gcc/cp/method.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008fd3a480e3718436156697ebe7eeb47841457/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008fd3a480e3718436156697ebe7eeb47841457/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=f008fd3a480e3718436156697ebe7eeb47841457", "patch": "@@ -2081,6 +2081,7 @@ constructible_expr (tree to, tree from)\n static tree\n is_xible_helper (enum tree_code code, tree to, tree from, bool trivial)\n {\n+  to = complete_type (to);\n   deferring_access_check_sentinel acs (dk_no_deferred);\n   if (VOID_TYPE_P (to) || ABSTRACT_CLASS_TYPE_P (to)\n       || (from && FUNC_OR_METHOD_TYPE_P (from)"}, {"sha": "e63adcf53640f8501b2aaa8548cee227f0fe0b30", "filename": "gcc/testsuite/g++.dg/cpp0x/pr102305.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f008fd3a480e3718436156697ebe7eeb47841457/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr102305.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f008fd3a480e3718436156697ebe7eeb47841457/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr102305.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr102305.C?ref=f008fd3a480e3718436156697ebe7eeb47841457", "patch": "@@ -0,0 +1,39 @@\n+// PR c++/102305\n+// { dg-do compile { target c++11 } }\n+\n+namespace std\n+{\n+  template<typename _Tp, _Tp __v>\n+    struct integral_constant\n+    {\n+      static constexpr _Tp value = __v;\n+      typedef integral_constant<_Tp, __v> type;\n+    };\n+\n+  template<typename _Tp, _Tp __v>\n+    constexpr _Tp integral_constant<_Tp, __v>::value;\n+\n+  typedef integral_constant<bool, true> true_type;\n+  typedef integral_constant<bool, false> false_type;\n+\n+  template<bool __v>\n+    using bool_constant = integral_constant<bool, __v>;\n+\n+  template<typename _Tp, typename... _Args>\n+    struct is_constructible\n+    : public bool_constant<__is_constructible(_Tp, _Args...)>\n+    {\n+    };\n+}\n+\n+template<typename>\n+struct A {\n+  virtual ~A() = 0;\n+};\n+\n+struct B {\n+  virtual ~B() = 0;\n+};\n+\n+static_assert(!std::is_constructible<A<int> >::value, \"\");\n+static_assert(!std::is_constructible<B>::value, \"\");"}]}