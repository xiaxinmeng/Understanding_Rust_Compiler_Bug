{"sha": "6ba7b54780fd483f81c39e0ac07537cbe40063df", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJhN2I1NDc4MGZkNDgzZjgxYzM5ZTBhYzA3NTM3Y2JlNDAwNjNkZg==", "commit": {"author": {"name": "Maciej W. Rozycki", "email": "macro@ds2.pg.gda.pl", "date": "2004-03-03T08:59:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-03-03T08:59:31Z"}, "message": "mips.h (MASK_FIX_SB1): Bump.\n\n\t* config/mips/mips.h (MASK_FIX_SB1): Bump.\n\t(MASK_FIX_R4400, TARGET_FIX_R4400): New macros.\n\t(TARGET_SWITCHES): Add -mfix-r4400 and -mno-fix-r4400.\n\t* config/mips/mips.c (mips_output_division): Fill the branch delay\n\tslot with a nop if TARGET_FIX_R4000.  Extend R4000 workarounds to\n\tTARGET_FIX_R4400.\n\t(mips_output_division): Adjust accordingly.\n\t(override_options): Make -march=r4400 imply -mfix-r4400 by default.\n\t* doc/invoke.texi: Document -mfix-r4400 and new errata workarounds.\n\nCo-Authored-By: Richard Sandiford <rsandifo@redhat.com>\n\nFrom-SVN: r78825", "tree": {"sha": "a81bd2f3b171961d46da6a6e7864aa0e966ea1be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a81bd2f3b171961d46da6a6e7864aa0e966ea1be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ba7b54780fd483f81c39e0ac07537cbe40063df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba7b54780fd483f81c39e0ac07537cbe40063df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ba7b54780fd483f81c39e0ac07537cbe40063df", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ba7b54780fd483f81c39e0ac07537cbe40063df/comments", "author": null, "committer": null, "parents": [{"sha": "ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec8e098d3d9adeb04512169974fd67acd9b9ca0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec8e098d3d9adeb04512169974fd67acd9b9ca0f"}], "stats": {"total": 159, "additions": 138, "deletions": 21}, "files": [{"sha": "e812431d85351faef92cbe7d23a77eb748584e9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ba7b54780fd483f81c39e0ac07537cbe40063df", "patch": "@@ -1,3 +1,16 @@\n+2004-03-03  Maciej W. Rozycki  <macro@ds2.pg.gda.pl>\n+\t    Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.h (MASK_FIX_SB1): Bump.\n+\t(MASK_FIX_R4400, TARGET_FIX_R4400): New macros.\n+\t(TARGET_SWITCHES): Add -mfix-r4400 and -mno-fix-r4400.\n+\t* config/mips/mips.c (mips_output_division): Fill the branch delay\n+\tslot with a nop if TARGET_FIX_R4000.  Extend R4000 workarounds to\n+\tTARGET_FIX_R4400.\n+\t(mips_output_division): Adjust accordingly.\n+\t(override_options): Make -march=r4400 imply -mfix-r4400 by default.\n+\t* doc/invoke.texi: Document -mfix-r4400 and new errata workarounds.\n+\n 2004-03-03  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* alias.c (rtx_equal_for_memref_p): Use predicates"}, {"sha": "bfd597060553f980e5a6c573556f82b850267a84", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 100, "deletions": 19, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6ba7b54780fd483f81c39e0ac07537cbe40063df", "patch": "@@ -1321,7 +1321,7 @@ mips_idiv_insns (void)\n   count = 1;\n   if (TARGET_CHECK_ZERO_DIV)\n     count += 2;\n-  if (TARGET_FIX_R4000)\n+  if (TARGET_FIX_R4000 || TARGET_FIX_R4400)\n     count++;\n   return count;\n }\n@@ -5101,6 +5101,12 @@ override_options (void)\n   if ((target_flags_explicit & MASK_FIX_R4000) == 0\n       && mips_matching_cpu_name_p (mips_arch_info->name, \"r4000\"))\n     target_flags |= MASK_FIX_R4000;\n+\n+  /* Default to working around R4400 errata only if the processor\n+     was selected explicitly.  */\n+  if ((target_flags_explicit & MASK_FIX_R4400) == 0\n+      && mips_matching_cpu_name_p (mips_arch_info->name, \"r4400\"))\n+    target_flags |= MASK_FIX_R4400;\n }\n \n /* Implement CONDITIONAL_REGISTER_USAGE.  */\n@@ -9171,26 +9177,106 @@ mips_output_conditional_branch (rtx insn, rtx *operands, int two_operands_p,\n   return 0;\n }\n \f\n-/* Used to output div or ddiv instruction DIVISION, which has the\n-   operands given by OPERANDS.  If we need a divide-by-zero check,\n-   output the instruction and return an asm string that traps if\n-   operand 2 is zero.\n-\n-   The original R4000 has a cpu bug.  If a double-word or a variable\n-   shift executes immediately after starting an integer division, the\n-   shift may give an incorrect result.  Avoid this by adding a nop on\n-   the R4000.  See quotations of errata #16 and #28 from \"MIPS\n-   R4000PC/SC Errata, Processor Revision 2.2 and 3.0\" in mips.md for\n-   details.\n-\n-   Otherwise just return DIVISION itself.  */\n+/* Used to output div or ddiv instruction DIVISION, which has the operands\n+   given by OPERANDS.  Add in a divide-by-zero check if needed.\n+\n+   When working around R4000 and R4400 errata, we need to make sure that\n+   the division is not immediately followed by a shift[1][2].  We also\n+   need to stop the division from being put into a branch delay slot[3].\n+   The easiest way to avoid both problems is to add a nop after the\n+   division.  When a divide-by-zero check is neeeded, this nop can be\n+   used to fill the branch delay slot.\n+\n+   [1] If a double-word or a variable shift executes immediately\n+       after starting an integer division, the shift may give an\n+       incorrect result.  See quotations of errata #16 and #28 from\n+       \"MIPS R4000PC/SC Errata, Processor Revision 2.2 and 3.0\"\n+       in mips.md for details.\n+\n+   [2] A similar bug to [1] exists for all revisions of the\n+       R4000 and the R4400 when run in an MC configuration.\n+       From \"MIPS R4000MC Errata, Processor Revision 2.2 and 3.0\":\n+\n+       \"19. In this following sequence:\n+\n+\t\t    ddiv\t\t(or ddivu or div or divu)\n+\t\t    dsll32\t\t(or dsrl32, dsra32)\n+\n+\t    if an MPT stall occurs, while the divide is slipping the cpu\n+\t    pipeline, then the following double shift would end up with an\n+\t    incorrect result.\n+\n+\t    Workaround: The compiler needs to avoid generating any\n+\t    sequence with divide followed by extended double shift.\"\n+\n+       This erratum is also present in \"MIPS R4400MC Errata, Processor\n+       Revision 1.0\" and \"MIPS R4400MC Errata, Processor Revision 2.0\n+       & 3.0\" as errata #10 and #4, respectively.\n+\n+   [3] From \"MIPS R4000PC/SC Errata, Processor Revision 2.2 and 3.0\"\n+       (also valid for MIPS R4000MC processors):\n+\n+       \"52. R4000SC: This bug does not apply for the R4000PC.\n+\n+\t    There are two flavors of this bug:\n+\n+\t    1) If the instruction just after divide takes an RF exception\n+\t       (tlb-refill, tlb-invalid) and gets an instruction cache\n+\t       miss (both primary and secondary) and the line which is\n+\t       currently in secondary cache at this index had the first\n+\t       data word, where the bits 5..2 are set, then R4000 would\n+\t       get a wrong result for the div.\n+\n+\t    ##1\n+\t\t    nop\n+\t\t    div\tr8, r9\n+\t\t    -------------------\t\t# end-of page. -tlb-refill\n+\t\t    nop\n+\t    ##2\n+\t\t    nop\n+\t\t    div\tr8, r9\n+\t\t    -------------------\t\t# end-of page. -tlb-invalid\n+\t\t    nop\n+\n+\t    2) If the divide is in the taken branch delay slot, where the\n+\t       target takes RF exception and gets an I-cache miss for the\n+\t       exception vector or where I-cache miss occurs for the\n+\t       target address, under the above mentioned scenarios, the\n+\t       div would get wrong results.\n+\n+\t    ##1\n+\t\t    j\tr2\t\t# to next page mapped or unmapped\n+\t\t    div\tr8,r9\t\t# this bug would be there as long\n+\t\t\t\t\t# as there is an ICache miss and\n+\t\t    nop\t\t\t# the \"data pattern\" is present\n+\n+\t    ##2\n+\t\t    beq\tr0, r0, NextPage\t# to Next page\n+\t\t    div\tr8,r9\n+\t\t    nop\n+\n+\t    This bug is present for div, divu, ddiv, and ddivu\n+\t    instructions.\n+\n+\t    Workaround: For item 1), OS could make sure that the next page\n+\t    after the divide instruction is also mapped.  For item 2), the\n+\t    compiler could make sure that the divide instruction is not in\n+\t    the branch delay slot.\"\n+\n+       These processors have PRId values of 0x00004220 and 0x00004300 for\n+       the R4000 and 0x00004400, 0x00004500 and 0x00004600 for the R4400.  */\n \n const char *\n mips_output_division (const char *division, rtx *operands)\n {\n   const char *s;\n \n   s = division;\n+  if (TARGET_FIX_R4000 || TARGET_FIX_R4400)\n+    {\n+      output_asm_insn (s, operands);\n+      s = \"nop\";\n+    }\n   if (TARGET_CHECK_ZERO_DIV)\n     {\n       if (TARGET_MIPS16)\n@@ -9205,11 +9291,6 @@ mips_output_division (const char *division, rtx *operands)\n \t  s = \"break\\t7%)\\n1:\";\n \t}\n     }\n-  if (TARGET_FIX_R4000)\n-    {\n-      output_asm_insn (s, operands);\n-      s = \"nop\";\n-    }\n   return s;\n }\n \f"}, {"sha": "d2612c929b9532152f7fb5c057b2d9142e1cb5ce", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=6ba7b54780fd483f81c39e0ac07537cbe40063df", "patch": "@@ -170,7 +170,8 @@ extern const struct mips_cpu_info *mips_tune_info;\n \t\t\t   0x00800000\t/* Store uninitialized\n \t\t\t\t\t   consts in rodata */\n #define MASK_FIX_R4000\t   0x01000000\t/* Work around R4000 errata.  */\n-#define MASK_FIX_SB1       0x02000000   /* Work around SB-1 errata.  */\n+#define MASK_FIX_R4400\t   0x02000000\t/* Work around R4400 errata.  */\n+#define MASK_FIX_SB1\t   0x04000000\t/* Work around SB-1 errata.  */\n \n \t\t\t\t\t/* Debug switches, not documented */\n #define MASK_DEBUG\t0\t\t/* unused */\n@@ -252,6 +253,9 @@ extern const struct mips_cpu_info *mips_tune_info;\n \t\t\t\t\t/* Work around R4000 errata.  */\n #define TARGET_FIX_R4000\t(target_flags & MASK_FIX_R4000)\n \n+\t\t\t\t\t/* Work around R4400 errata.  */\n+#define TARGET_FIX_R4400\t\t(target_flags & MASK_FIX_R4400)\n+\n /* True if we should use NewABI-style relocation operators for\n    symbolic addresses.  This is never true for mips16 code,\n    which has its own conventions.  */\n@@ -596,6 +600,10 @@ extern const struct mips_cpu_info *mips_tune_info;\n      N_(\"Work around R4000 errata\")},\t\t\t\t\t\\\n   {\"no-fix-r4000\",\t -MASK_FIX_R4000,\t\t\t\t\\\n      N_(\"Don't work around R4000 errata\")},\t\t\t\t\\\n+  {\"fix-r4400\",\t\t  MASK_FIX_R4400,\t\t\t\t\\\n+     N_(\"Work around R4400 errata\")},\t\t\t\t\t\\\n+  {\"no-fix-r4400\",\t -MASK_FIX_R4400,\t\t\t\t\\\n+     N_(\"Don't work around R4400 errata\")},\t\t\t\t\\\n   {\"check-zero-division\",-MASK_NO_CHECK_ZERO_DIV,\t\t\t\\\n      N_(\"Trap on integer divide by zero\")},\t\t\t\t\\\n   {\"no-check-zero-division\", MASK_NO_CHECK_ZERO_DIV,\t\t\t\\"}, {"sha": "4fb703ce105778eb6cefba9d3a850465b8add14f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ba7b54780fd483f81c39e0ac07537cbe40063df/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6ba7b54780fd483f81c39e0ac07537cbe40063df", "patch": "@@ -478,7 +478,8 @@ in the following sections.\n -mcheck-zero-division  -mno-check-zero-division @gol\n -mmemcpy  -mno-memcpy  -mlong-calls  -mno-long-calls @gol\n -mmad  -mno-mad  -mfused-madd  -mno-fused-madd  -nocpp @gol\n--mfix-r4000  -mno-fix-r4000  -mfix-sb1  -mno-fix-sb1 @gol\n+-mfix-r4000  -mno-fix-r4000  -mfix-r4400  -mno-fix-r4400 @gol\n+-mfix-sb1  -mno-fix-sb1 @gol\n -mflush-func=@var{func}  -mno-flush-func @gol\n -mbranch-likely  -mno-branch-likely}\n \n@@ -8048,6 +8049,20 @@ immediately after starting an integer division.\n @item\n A double-word or a variable shift may give an incorrect result if executed\n while an integer multiplication is in progress.\n+@item\n+An integer division may give an incorrect result if started in a delay slot\n+of a taken branch or a jump.\n+@end itemize\n+\n+@item -mfix-r4400\n+@itemx -mno-fix-r4400\n+@opindex mfix-r4400\n+@opindex mno-fix-r4400\n+Work around certain R4400 CPU errata:\n+@itemize @minus\n+@item\n+A double-word or a variable shift may give an incorrect result if executed\n+immediately after starting an integer division.\n @end itemize\n \n @item -mfix-sb1"}]}