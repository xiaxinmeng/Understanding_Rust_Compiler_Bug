{"sha": "e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTdiZDk0Y2NiOGFiMzdjNzViNDJhNzM1Y2JkOTlhMDVmNWYzZTg5MA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-07-29T17:47:31Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-07-29T17:47:31Z"}, "message": "cfgloop.c (update_latch_info): Update dominator of the new block.\n\n\t* cfgloop.c (update_latch_info): Update dominator of the new block.\n\t(canonicalize_loop_headers, flow_loops_find): Do not free dominance\n\tinfo.\n\t* dominance.c (verify_dominators): Check that the dominance tree is\n\tconnected.\n\t(recount_dominator): Ignore unreachable blocks.\n\t(iterate_fix_dominators): Cleanup old dominance information before\n\trecomputing it.\n\nFrom-SVN: r85307", "tree": {"sha": "593182763d4cd5ae55c67b3a00af45d725ccefd7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/593182763d4cd5ae55c67b3a00af45d725ccefd7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/comments", "author": null, "committer": null, "parents": [{"sha": "d397dbcd99452ed440e1a99495436af91513a5ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d397dbcd99452ed440e1a99495436af91513a5ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d397dbcd99452ed440e1a99495436af91513a5ac"}], "stats": {"total": 57, "additions": 45, "deletions": 12}, "files": [{"sha": "c66a8d0ab87d1b005b78bdf548dbdaff93e6b54e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "patch": "@@ -1,3 +1,14 @@\n+2004-07-29  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloop.c (update_latch_info): Update dominator of the new block.\n+\t(canonicalize_loop_headers, flow_loops_find): Do not free dominance\n+\tinfo.\n+\t* dominance.c (verify_dominators): Check that the dominance tree is\n+\tconnected.\n+\t(recount_dominator): Ignore unreachable blocks.\n+\t(iterate_fix_dominators): Cleanup old dominance information before\n+\trecomputing it.\n+\n 2004-07-29  Diego Novillo  <dnovillo@redhat.com>\n \n \t* tree-ssa-operands.c (get_expr_operands): Revert changes"}, {"sha": "58d9dd08dba6499142807b8081e08f44fe4303ce", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "patch": "@@ -575,6 +575,7 @@ update_latch_info (basic_block jump)\n   HEADER_BLOCK (jump) = 0;\n   alloc_aux_for_edge (jump->pred, sizeof (int));\n   LATCH_EDGE (jump->pred) = 0;\n+  set_immediate_dominator (CDI_DOMINATORS, jump, jump->pred->src);\n }\n \n /* A callback for make_forwarder block, to redirect all edges except for\n@@ -606,9 +607,6 @@ canonicalize_loop_headers (void)\n   basic_block header;\n   edge e;\n \n-  /* Compute the dominators.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   alloc_aux_for_blocks (sizeof (int));\n   alloc_aux_for_edges (sizeof (int));\n \n@@ -638,8 +636,6 @@ canonicalize_loop_headers (void)\n \tHEADER_BLOCK (header) = num_latches;\n     }\n \n-  free_dominance_info (CDI_DOMINATORS);\n-\n   if (HEADER_BLOCK (ENTRY_BLOCK_PTR->succ->dest))\n     {\n       basic_block bb;\n@@ -711,6 +707,10 @@ canonicalize_loop_headers (void)\n \n   free_aux_for_blocks ();\n   free_aux_for_edges ();\n+\n+#ifdef ENABLE_CHECKING\n+  verify_dominators (CDI_DOMINATORS);\n+#endif\n }\n \n /* Find all the natural loops in the function and save in LOOPS structure and\n@@ -747,12 +747,12 @@ flow_loops_find (struct loops *loops, int flags)\n   dfs_order = NULL;\n   rc_order = NULL;\n \n+  /* Ensure that the dominators are computed.  */\n+  calculate_dominance_info (CDI_DOMINATORS);\n+\n   /* Join loops with shared headers.  */\n   canonicalize_loop_headers ();\n \n-  /* Compute the dominators.  */\n-  calculate_dominance_info (CDI_DOMINATORS);\n-\n   /* Count the number of loop headers.  This should be the\n      same as the number of natural loops.  */\n   headers = sbitmap_alloc (last_basic_block);\n@@ -880,10 +880,6 @@ flow_loops_find (struct loops *loops, int flags)\n \n       loops->num = num_loops;\n     }\n-  else\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-    }\n \n   sbitmap_free (headers);\n "}, {"sha": "d46d8f56ecdd4cff044f6ee75833541b241fdf74", "filename": "gcc/dominance.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=e7bd94ccb8ab37c75b42a735cbd99a05f5f3e890", "patch": "@@ -824,6 +824,20 @@ verify_dominators (enum cdi_direction dir)\n \t  err = 1;\n \t}\n     }\n+\n+  if (dir == CDI_DOMINATORS\n+      && dom_computed[dir] >= DOM_NO_FAST_QUERY)\n+    {\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  if (!dominated_by_p (dir, bb, ENTRY_BLOCK_PTR))\n+\t    {\n+\t      error (\"ENTRY does not dominate bb %d\", bb->index);\n+\t      err = 1;\n+\t    }\n+\t}\n+    }\n+\n   if (err)\n     abort ();\n }\n@@ -846,6 +860,11 @@ recount_dominator (enum cdi_direction dir, basic_block bb)\n     {\n       for (e = bb->pred; e; e = e->pred_next)\n \t{\n+\t  /* Ignore the predecessors that either are not reachable from\n+\t     the entry block, or whose dominator was not determined yet.  */\n+\t  if (!dominated_by_p (dir, e->src, ENTRY_BLOCK_PTR))\n+\t    continue;\n+\n \t  if (!dominated_by_p (dir, e->src, bb))\n \t    dom_bb = nearest_common_dominator (dir, dom_bb, e->src);\n \t}\n@@ -873,6 +892,9 @@ iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n   if (!dom_computed[dir])\n     abort ();\n \n+  for (i = 0; i < n; i++)\n+    set_immediate_dominator (dir, bbs[i], NULL);\n+\n   while (changed)\n     {\n       changed = 0;\n@@ -887,6 +909,10 @@ iterate_fix_dominators (enum cdi_direction dir, basic_block *bbs, int n)\n \t    }\n \t}\n     }\n+\n+  for (i = 0; i < n; i++)\n+    if (!get_immediate_dominator (dir, bbs[i]))\n+      abort ();\n }\n \n void"}]}