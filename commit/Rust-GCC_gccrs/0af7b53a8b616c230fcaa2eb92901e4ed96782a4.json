{"sha": "0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFmN2I1M2E4YjYxNmMyMzBmY2FhMmViOTI5MDFlNGVkOTY3ODJhNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-05-08T20:24:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-08T20:24:33Z"}, "message": "dg-extract-results.py: New file.\n\ncontrib/\n\t* dg-extract-results.py: New file.\n\t* dg-extract-results.sh: Use it if the environment seems suitable.\n\nFrom-SVN: r210243", "tree": {"sha": "4e19a04307373fec45e6b13996a0ea720bc3058f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e19a04307373fec45e6b13996a0ea720bc3058f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e70c7f5bc7db5a1cac513a57f1846211e6413cec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e70c7f5bc7db5a1cac513a57f1846211e6413cec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e70c7f5bc7db5a1cac513a57f1846211e6413cec"}], "stats": {"total": 591, "additions": 591, "deletions": 0}, "files": [{"sha": "6f90f4879d3c6709e9d0cfea16e869373d8ce899", "filename": "contrib/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "patch": "@@ -1,3 +1,8 @@\n+2014-05-08  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* dg-extract-results.py: New file.\n+\t* dg-extract-results.sh: Use it if the environment seems suitable.\n+\n 2014-04-22  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* config-list.mk (LIST): Remove sparc-sun-solaris2.9, i686-solaris2.9."}, {"sha": "196b6b2eebb9419e58b56bf9dcbced4024333f85", "filename": "contrib/dg-extract-results.py", "status": "added", "additions": 577, "deletions": 0, "changes": 577, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2Fdg-extract-results.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2Fdg-extract-results.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fdg-extract-results.py?ref=0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "patch": "@@ -0,0 +1,577 @@\n+#!/usr/bin/python\n+#\n+# Copyright (C) 2014 Free Software Foundation, Inc.\n+#\n+# This script is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+\n+import sys\n+import getopt\n+import re\n+from datetime import datetime\n+\n+# True if unrecognised lines should cause a fatal error.  Might want to turn\n+# this on by default later.\n+strict = False\n+\n+# True if the order of .log segments should match the .sum file, false if\n+# they should keep the original order.\n+sort_logs = True\n+\n+class Named:\n+    def __init__ (self, name):\n+        self.name = name\n+\n+    def __cmp__ (self, other):\n+        return cmp (self.name, other.name)\n+\n+class ToolRun (Named):\n+    def __init__ (self, name):\n+        Named.__init__ (self, name)\n+        # The variations run for this tool, mapped by --target_board name.\n+        self.variations = dict()\n+\n+    # Return the VariationRun for variation NAME.\n+    def get_variation (self, name):\n+        if name not in self.variations:\n+            self.variations[name] = VariationRun (name)\n+        return self.variations[name]\n+\n+class VariationRun (Named):\n+    def __init__ (self, name):\n+        Named.__init__ (self, name)\n+        # A segment of text before the harness runs start, describing which\n+        # baseboard files were loaded for the target.\n+        self.header = None\n+        # The harnesses run for this variation, mapped by filename.\n+        self.harnesses = dict()\n+        # A list giving the number of times each type of result has\n+        # been seen.\n+        self.counts = []\n+\n+    # Return the HarnessRun for harness NAME.\n+    def get_harness (self, name):\n+        if name not in self.harnesses:\n+            self.harnesses[name] = HarnessRun (name)\n+        return self.harnesses[name]\n+\n+class HarnessRun (Named):\n+    def __init__ (self, name):\n+        Named.__init__ (self, name)\n+        # Segments of text that make up the harness run, mapped by a test-based\n+        # key that can be used to order them.\n+        self.segments = dict()\n+        # Segments of text that make up the harness run but which have\n+        # no recognized test results.  These are typically harnesses that\n+        # are completely skipped for the target.\n+        self.empty = []\n+        # A list of results.  Each entry is a pair in which the first element\n+        # is a unique sorting key and in which the second is the full\n+        # PASS/FAIL line.\n+        self.results = []\n+\n+    # Add a segment of text to the harness run.  If the segment includes\n+    # test results, KEY is an example of one of them, and can be used to\n+    # combine the individual segments in order.  If the segment has no\n+    # test results (e.g. because the harness doesn't do anything for the\n+    # current configuration) then KEY is None instead.  In that case\n+    # just collect the segments in the order that we see them.\n+    def add_segment (self, key, segment):\n+        if key:\n+            assert key not in self.segments\n+            self.segments[key] = segment\n+        else:\n+            self.empty.append (segment)\n+\n+class Segment:\n+    def __init__ (self, filename, start):\n+        self.filename = filename\n+        self.start = start\n+        self.lines = 0\n+\n+class Prog:\n+    def __init__ (self):\n+        # The variations specified on the command line.\n+        self.variations = []\n+        # The variations seen in the input files.\n+        self.known_variations = set()\n+        # The tools specified on the command line.\n+        self.tools = []\n+        # Whether to create .sum rather than .log output.\n+        self.do_sum = True\n+        # Regexps used while parsing.\n+        self.test_run_re = re.compile (r'^Test Run By (\\S+) on (.*)$')\n+        self.tool_re = re.compile (r'^\\t\\t=== (.*) tests ===$')\n+        self.result_re = re.compile (r'^(PASS|XPASS|FAIL|XFAIL|UNRESOLVED'\n+                                     r'|WARNING|ERROR|UNSUPPORTED|UNTESTED'\n+                                     r'|KFAIL):\\s*(\\S+)')\n+        self.completed_re = re.compile (r'.* completed at (.*)')\n+        # Pieces of text to write at the head of the output.\n+        # start_line is a pair in which the first element is a datetime\n+        # and in which the second is the associated 'Test Run By' line.\n+        self.start_line = None\n+        self.native_line = ''\n+        self.target_line = ''\n+        self.host_line = ''\n+        self.acats_premable = ''\n+        # Pieces of text to write at the end of the output.\n+        # end_line is like start_line but for the 'runtest completed' line.\n+        self.acats_failures = []\n+        self.version_output = ''\n+        self.end_line = None\n+        # Known summary types.\n+        self.count_names = [\n+            '# of expected passes\\t\\t',\n+            '# of unexpected failures\\t',\n+            '# of unexpected successes\\t',\n+            '# of expected failures\\t\\t',\n+            '# of unknown successes\\t\\t',\n+            '# of known failures\\t\\t',\n+            '# of untested testcases\\t\\t',\n+            '# of unresolved testcases\\t',\n+            '# of unsupported tests\\t\\t'\n+        ]\n+        self.runs = dict()\n+\n+    def usage (self):\n+        name = sys.argv[0]\n+        sys.stderr.write ('Usage: ' + name\n+                          + ''' [-t tool] [-l variant-list] [-L] log-or-sum-file ...\n+\n+    tool           The tool (e.g. g++, libffi) for which to create a\n+                   new test summary file.  If not specified then output\n+                   is created for all tools.\n+    variant-list   One or more test variant names.  If the list is\n+                   not specified then one is constructed from all\n+                   variants in the files for <tool>.\n+    sum-file       A test summary file with the format of those\n+                   created by runtest from DejaGnu.\n+    If -L is used, merge *.log files instead of *.sum.  In this\n+    mode the exact order of lines may not be preserved, just different\n+    Running *.exp chunks should be in correct order.\n+''')\n+        sys.exit (1)\n+\n+    def fatal (self, what, string):\n+        if not what:\n+            what = sys.argv[0]\n+        sys.stderr.write (what + ': ' + string + '\\n')\n+        sys.exit (1)\n+\n+    # Parse the command-line arguments.\n+    def parse_cmdline (self):\n+        try:\n+            (options, self.files) = getopt.getopt (sys.argv[1:], 'l:t:L')\n+            if len (self.files) == 0:\n+                self.usage()\n+            for (option, value) in options:\n+                if option == '-l':\n+                    self.variations.append (value)\n+                elif option == '-t':\n+                    self.tools.append (value)\n+                else:\n+                    self.do_sum = False\n+        except getopt.GetoptError as e:\n+            self.fatal (None, e.msg)\n+\n+    # Try to parse time string TIME, returning an arbitrary time on failure.\n+    # Getting this right is just a nice-to-have so failures should be silent.\n+    def parse_time (self, time):\n+        try:\n+            return datetime.strptime (time, '%c')\n+        except ValueError:\n+            return datetime.now()\n+\n+    # Parse an integer and abort on failure.\n+    def parse_int (self, filename, value):\n+        try:\n+            return int (value)\n+        except ValueError:\n+            self.fatal (filename, 'expected an integer, got: ' + value)\n+\n+    # Return a list that represents no test results.\n+    def zero_counts (self):\n+        return [0 for x in self.count_names]\n+\n+    # Return the ToolRun for tool NAME.\n+    def get_tool (self, name):\n+        if name not in self.runs:\n+            self.runs[name] = ToolRun (name)\n+        return self.runs[name]\n+\n+    # Add the result counts in list FROMC to TOC.\n+    def accumulate_counts (self, toc, fromc):\n+        for i in range (len (self.count_names)):\n+            toc[i] += fromc[i]\n+\n+    # Parse the list of variations after 'Schedule of variations:'.\n+    # Return the number seen.\n+    def parse_variations (self, filename, file):\n+        num_variations = 0\n+        while True:\n+            line = file.readline()\n+            if line == '':\n+                self.fatal (filename, 'could not parse variation list')\n+            if line == '\\n':\n+                break\n+            self.known_variations.add (line.strip())\n+            num_variations += 1\n+        return num_variations\n+\n+    # Parse from the first line after 'Running target ...' to the end\n+    # of the run's summary.\n+    def parse_run (self, filename, file, tool, variation, num_variations):\n+        header = None\n+        harness = None\n+        segment = None\n+        final_using = 0\n+\n+        # If this is the first run for this variation, add any text before\n+        # the first harness to the header.\n+        if not variation.header:\n+            segment = Segment (filename, file.tell())\n+            variation.header = segment\n+\n+        # Parse up until the first line of the summary.\n+        if num_variations == 1:\n+            end = '\\t\\t=== ' + tool.name + ' Summary ===\\n'\n+        else:\n+            end = ('\\t\\t=== ' + tool.name + ' Summary for '\n+                   + variation.name + ' ===\\n')\n+        while True:\n+            line = file.readline()\n+            if line == '':\n+                self.fatal (filename, 'no recognised summary line')\n+            if line == end:\n+                break\n+\n+            # Look for the start of a new harness.\n+            if line.startswith ('Running ') and line.endswith (' ...\\n'):\n+                # Close off the current harness segment, if any.\n+                if harness:\n+                    segment.lines -= final_using\n+                    harness.add_segment (first_key, segment)\n+                name = line[len ('Running '):-len(' ...\\n')]\n+                harness = variation.get_harness (name)\n+                segment = Segment (filename, file.tell())\n+                first_key = None\n+                final_using = 0\n+                continue\n+\n+            # Record test results.  Associate the first test result with\n+            # the harness segment, so that if a run for a particular harness\n+            # has been split up, we can reassemble the individual segments\n+            # in a sensible order.\n+            match = self.result_re.match (line)\n+            if match:\n+                if not harness:\n+                    self.fatal (filename, 'saw test result before harness name')\n+                name = match.group (2)\n+                # Ugly hack to get the right order for gfortran.\n+                if name.startswith ('gfortran.dg/g77/'):\n+                    name = 'h' + name\n+                key = (name, len (harness.results))\n+                harness.results.append ((key, line))\n+                if not first_key and sort_logs:\n+                    first_key = key\n+\n+            # 'Using ...' lines are only interesting in a header.  Splitting\n+            # the test up into parallel runs leads to more 'Using ...' lines\n+            # than there would be in a single log.\n+            if line.startswith ('Using '):\n+                final_using += 1\n+            else:\n+                final_using = 0\n+\n+            # Add other text to the current segment, if any.\n+            if segment:\n+                segment.lines += 1\n+\n+        # Close off the final harness segment, if any.\n+        if harness:\n+            segment.lines -= final_using\n+            harness.add_segment (first_key, segment)\n+\n+        # Parse the rest of the summary (the '# of ' lines).\n+        if len (variation.counts) == 0:\n+            variation.counts = self.zero_counts()\n+        while True:\n+            before = file.tell()\n+            line = file.readline()\n+            if line == '':\n+                break\n+            if line == '\\n':\n+                continue\n+            if not line.startswith ('# '):\n+                file.seek (before)\n+                break\n+            found = False\n+            for i in range (len (self.count_names)):\n+                if line.startswith (self.count_names[i]):\n+                    count = line[len (self.count_names[i]):-1].strip()\n+                    variation.counts[i] += self.parse_int (filename, count)\n+                    found = True\n+                    break\n+            if not found:\n+                self.fatal (filename, 'unknown test result: ' + line[:-1])\n+\n+    # Parse an acats run, which uses a different format from dejagnu.\n+    # We have just skipped over '=== acats configuration ==='.\n+    def parse_acats_run (self, filename, file):\n+        # Parse the preamble, which describes the configuration and logs\n+        # the creation of support files.\n+        record = (self.acats_premable == '')\n+        if record:\n+            self.acats_premable = '\\t\\t=== acats configuration ===\\n'\n+        while True:\n+            line = file.readline()\n+            if line == '':\n+                self.fatal (filename, 'could not parse acats preamble')\n+            if line == '\\t\\t=== acats tests ===\\n':\n+                break\n+            if record:\n+                self.acats_premable += line\n+\n+        # Parse the test results themselves, using a dummy variation name.\n+        tool = self.get_tool ('acats')\n+        variation = tool.get_variation ('none')\n+        self.parse_run (filename, file, tool, variation, 1)\n+\n+        # Parse the failure list.\n+        while True:\n+            before = file.tell()\n+            line = file.readline()\n+            if line.startswith ('*** FAILURES: '):\n+                self.acats_failures.append (line[len ('*** FAILURES: '):-1])\n+                continue\n+            file.seek (before)\n+            break\n+\n+    # Parse the final summary at the end of a log in order to capture\n+    # the version output that follows it.\n+    def parse_final_summary (self, filename, file):\n+        record = (self.version_output == '')\n+        while True:\n+            line = file.readline()\n+            if line == '':\n+                break\n+            if line.startswith ('# of '):\n+                continue\n+            if record:\n+                self.version_output += line\n+            if line == '\\n':\n+                break\n+\n+    # Parse a .log or .sum file.\n+    def parse_file (self, filename, file):\n+        tool = None\n+        target = None\n+        num_variations = 1\n+        while True:\n+            line = file.readline()\n+            if line == '':\n+                return\n+\n+            # Parse the list of variations, which comes before the test\n+            # runs themselves.\n+            if line.startswith ('Schedule of variations:'):\n+                num_variations = self.parse_variations (filename, file)\n+                continue\n+\n+            # Parse a testsuite run for one tool/variation combination.\n+            if line.startswith ('Running target '):\n+                name = line[len ('Running target '):-1]\n+                if not tool:\n+                    self.fatal (filename, 'could not parse tool name')\n+                if name not in self.known_variations:\n+                    self.fatal (filename, 'unknown target: ' + name)\n+                self.parse_run (filename, file, tool,\n+                                tool.get_variation (name),\n+                                num_variations)\n+                # If there is only one variation then there is no separate\n+                # summary for it.  Record any following version output.\n+                if num_variations == 1:\n+                    self.parse_final_summary (filename, file)\n+                continue\n+\n+            # Parse the start line.  In the case where several files are being\n+            # parsed, pick the one with the earliest time.\n+            match = self.test_run_re.match (line)\n+            if match:\n+                time = self.parse_time (match.group (2))\n+                if not self.start_line or self.start_line[0] > time:\n+                    self.start_line = (time, line)\n+                continue\n+\n+            # Parse the form used for native testing.\n+            if line.startswith ('Native configuration is '):\n+                self.native_line = line\n+                continue\n+\n+            # Parse the target triplet.\n+            if line.startswith ('Target is '):\n+                self.target_line = line\n+                continue\n+\n+            # Parse the host triplet.\n+            if line.startswith ('Host   is '):\n+                self.host_line = line\n+                continue\n+\n+            # Parse the acats premable.\n+            if line == '\\t\\t=== acats configuration ===\\n':\n+                self.parse_acats_run (filename, file)\n+                continue\n+\n+            # Parse the tool name.\n+            match = self.tool_re.match (line)\n+            if match:\n+                tool = self.get_tool (match.group (1))\n+                continue\n+\n+            # Skip over the final summary (which we instead create from\n+            # individual runs) and parse the version output.\n+            if tool and line == '\\t\\t=== ' + tool.name + ' Summary ===\\n':\n+                if file.readline() != '\\n':\n+                    self.fatal (filename, 'expected blank line after summary')\n+                self.parse_final_summary (filename, file)\n+                continue\n+\n+            # Parse the completion line.  In the case where several files\n+            # are being parsed, pick the one with the latest time.\n+            match = self.completed_re.match (line)\n+            if match:\n+                time = self.parse_time (match.group (1))\n+                if not self.end_line or self.end_line[0] < time:\n+                    self.end_line = (time, line)\n+                continue\n+\n+            # Sanity check to make sure that important text doesn't get\n+            # dropped accidentally.\n+            if strict and line.strip() != '':\n+                self.fatal (filename, 'unrecognised line: ' + line[:-1])\n+\n+    # Output a segment of text.\n+    def output_segment (self, segment):\n+        with open (segment.filename, 'r') as file:\n+            file.seek (segment.start)\n+            for i in range (segment.lines):\n+                sys.stdout.write (file.readline())\n+\n+    # Output a summary giving the number of times each type of result has\n+    # been seen.\n+    def output_summary (self, tool, counts):\n+        for i in range (len (self.count_names)):\n+            name = self.count_names[i]\n+            # dejagnu only prints result types that were seen at least once,\n+            # but acats always prints a number of unexpected failures.\n+            if (counts[i] > 0\n+                or (tool.name == 'acats'\n+                    and name.startswith ('# of unexpected failures'))):\n+                sys.stdout.write ('%s%d\\n' % (name, counts[i]))\n+\n+    # Output unified .log or .sum information for a particular variation,\n+    # with a summary at the end.\n+    def output_variation (self, tool, variation):\n+        self.output_segment (variation.header)\n+        for harness in sorted (variation.harnesses.values()):\n+            sys.stdout.write ('Running ' + harness.name + ' ...\\n')\n+            if self.do_sum:\n+                # Keep the original test result order if there was only\n+                # one segment for this harness.  This is needed for\n+                # unsorted.exp, which has unusual test names.  Otherwise\n+                # sort the tests by test filename.  If there are several\n+                # subtests for the same test filename (such as 'compilation',\n+                # 'test for excess errors', etc.) then keep the subtests\n+                # in the original order.\n+                if len (harness.segments) > 1:\n+                    harness.results.sort()\n+                for (key, line) in harness.results:\n+                    sys.stdout.write (line)\n+            else:\n+                # Rearrange the log segments into test order (but without\n+                # rearranging text within those segments).\n+                for key in sorted (harness.segments.keys()):\n+                    self.output_segment (harness.segments[key])\n+                for segment in harness.empty:\n+                    self.output_segment (segment)\n+        if len (self.variations) > 1:\n+            sys.stdout.write ('\\t\\t=== ' + tool.name + ' Summary for '\n+                              + variation.name + ' ===\\n\\n')\n+            self.output_summary (tool, variation.counts)\n+\n+    # Output unified .log or .sum information for a particular tool,\n+    # with a summary at the end.\n+    def output_tool (self, tool):\n+        counts = self.zero_counts()\n+        if tool.name == 'acats':\n+            # acats doesn't use variations, so just output everything.\n+            # It also has a different approach to whitespace.\n+            sys.stdout.write ('\\t\\t=== ' + tool.name + ' tests ===\\n')\n+            for variation in tool.variations.values():\n+                self.output_variation (tool, variation)\n+                self.accumulate_counts (counts, variation.counts)\n+            sys.stdout.write ('\\t\\t=== ' + tool.name + ' Summary ===\\n')\n+        else:\n+            # Output the results in the usual dejagnu runtest format.\n+            sys.stdout.write ('\\n\\t\\t=== ' + tool.name + ' tests ===\\n\\n'\n+                              'Schedule of variations:\\n')\n+            for name in self.variations:\n+                if name in tool.variations:\n+                    sys.stdout.write ('    ' + name + '\\n')\n+            sys.stdout.write ('\\n')\n+            for name in self.variations:\n+                if name in tool.variations:\n+                    variation = tool.variations[name]\n+                    sys.stdout.write ('Running target '\n+                                      + variation.name + '\\n')\n+                    self.output_variation (tool, variation)\n+                    self.accumulate_counts (counts, variation.counts)\n+            sys.stdout.write ('\\n\\t\\t=== ' + tool.name + ' Summary ===\\n\\n')\n+        self.output_summary (tool, counts)\n+\n+    def main (self):\n+        self.parse_cmdline()\n+        try:\n+            # Parse the input files.\n+            for filename in self.files:\n+                with open (filename, 'r') as file:\n+                    self.parse_file (filename, file)\n+\n+            # Decide what to output.\n+            if len (self.variations) == 0:\n+                self.variations = sorted (self.known_variations)\n+            else:\n+                for name in self.variations:\n+                    if name not in self.known_variations:\n+                        self.fatal (None, 'no results for ' + name)\n+            if len (self.tools) == 0:\n+                self.tools = sorted (self.runs.keys())\n+\n+            # Output the header.\n+            if self.start_line:\n+                sys.stdout.write (self.start_line[1])\n+            sys.stdout.write (self.native_line)\n+            sys.stdout.write (self.target_line)\n+            sys.stdout.write (self.host_line)\n+            sys.stdout.write (self.acats_premable)\n+\n+            # Output the main body.\n+            for name in self.tools:\n+                if name not in self.runs:\n+                    self.fatal (None, 'no results for ' + name)\n+                self.output_tool (self.runs[name])\n+\n+            # Output the footer.\n+            if len (self.acats_failures) > 0:\n+                sys.stdout.write ('*** FAILURES: '\n+                                  + ' '.join (self.acats_failures) + '\\n')\n+            sys.stdout.write (self.version_output)\n+            if self.end_line:\n+                sys.stdout.write (self.end_line[1])\n+        except IOError as e:\n+            self.fatal (e.filename, e.strerror)\n+\n+Prog().main()"}, {"sha": "a83c8e8d67841f5dcbac4dd66f35d2ec2b28e3b8", "filename": "contrib/dg-extract-results.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2Fdg-extract-results.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0af7b53a8b616c230fcaa2eb92901e4ed96782a4/contrib%2Fdg-extract-results.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fdg-extract-results.sh?ref=0af7b53a8b616c230fcaa2eb92901e4ed96782a4", "patch": "@@ -28,6 +28,15 @@\n \n PROGNAME=dg-extract-results.sh\n \n+# Try to use the python version if possible, since it tends to be faster.\n+PYTHON_VER=`echo \"$0\" | sed 's/sh$/py/'`\n+if test \"$PYTHON_VER\" != \"$0\" &&\n+   test -f \"$PYTHON_VER\" &&\n+   python -c 'import sys; sys.exit (0 if sys.version_info >= (2, 6) else 1)' \\\n+     > /dev/null 2> /dev/null; then\n+  exec python $PYTHON_VER \"$@\"\n+fi\n+\n usage() {\n   cat <<EOF >&2\n Usage: $PROGNAME [-t tool] [-l variant-list] [-L] sum-file ..."}]}