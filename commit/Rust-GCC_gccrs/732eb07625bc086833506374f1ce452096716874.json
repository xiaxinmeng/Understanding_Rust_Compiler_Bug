{"sha": "732eb07625bc086833506374f1ce452096716874", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMyZWIwNzYyNWJjMDg2ODMzNTA2Mzc0ZjFjZTQ1MjA5NjcxNjg3NA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-05-24T20:55:57Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2016-05-24T20:55:57Z"}, "message": "c++config (_GLIBCXX14_USE_CONSTEXPR): New.\n\n2016-05-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/c++config (_GLIBCXX14_USE_CONSTEXPR): New.\n\t* include/bits/hashtable_policy.h\n\t(_Prime_rehash_policy::__has_load_factor): New. Mark rehash policy\n\thaving load factor management.\n\t(_Mask_range_hashing): New.\n\t(__clp2): New.\n\t(_Power2_rehash_policy): New.\n\t(_Inserts<>): Remove last template parameter, _Unique_keys, so that\n\tpartial specializations only depend on whether iterators are constant\n\tor not.\n\t* testsuite/23_containers/unordered_set/hash_policy/26132.cc: Adapt to\n\ttest new hash policy.\n\t* testsuite/23_containers/unordered_set/hash_policy/load_factor.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/hash_policy/rehash.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/insert/hash_policy.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/max_load_factor/robustness.cc:\n\tLikewise.\n\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc:\n\tNew.\n\t* testsuite/performance/23_containers/insert/54075.cc: Add benchmark\n\tusing the new hash policy.\n\t* testsuite/performance/23_containers/insert_erase/41975.cc: Likewise.\n\nFrom-SVN: r236669", "tree": {"sha": "1c97ba8f330c8ef523c1b2d84d0113c5009687c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c97ba8f330c8ef523c1b2d84d0113c5009687c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/732eb07625bc086833506374f1ce452096716874", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732eb07625bc086833506374f1ce452096716874", "html_url": "https://github.com/Rust-GCC/gccrs/commit/732eb07625bc086833506374f1ce452096716874", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/732eb07625bc086833506374f1ce452096716874/comments", "author": null, "committer": null, "parents": [{"sha": "f65e97fd3dc83bdbe6a1415f9527e68c35b841b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65e97fd3dc83bdbe6a1415f9527e68c35b841b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65e97fd3dc83bdbe6a1415f9527e68c35b841b3"}], "stats": {"total": 797, "additions": 565, "deletions": 232}, "files": [{"sha": "3fc811d1611a461f21cf98322ced7c1edcdb89cf", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -1,3 +1,31 @@\n+2016-05-24  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\n+\t* include/bits/c++config (_GLIBCXX14_USE_CONSTEXPR): New.\n+\t* include/bits/hashtable_policy.h\n+\t(_Prime_rehash_policy::__has_load_factor): New. Mark rehash policy\n+\thaving load factor management.\n+\t(_Mask_range_hashing): New.\n+\t(__clp2): New.\n+\t(_Power2_rehash_policy): New.\n+\t(_Inserts<>): Remove last template parameter, _Unique_keys, so that\n+\tpartial specializations only depend on whether iterators are constant\n+\tor not.\n+\t* testsuite/23_containers/unordered_set/hash_policy/26132.cc: Adapt to\n+\ttest new hash policy.\n+\t* testsuite/23_containers/unordered_set/hash_policy/load_factor.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/hash_policy/rehash.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/insert/hash_policy.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/max_load_factor/robustness.cc:\n+\tLikewise.\n+\t* testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc:\n+\tNew.\n+\t* testsuite/performance/23_containers/insert/54075.cc: Add benchmark\n+\tusing the new hash policy.\n+\t* testsuite/performance/23_containers/insert_erase/41975.cc: Likewise.\n+\n 2016-05-24  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/stl_queue.h (priority_queue::value_compare): Define."}, {"sha": "78353ae9eb6108674a76b3ebb4483ebcce316bc1", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -106,8 +106,10 @@\n #ifndef _GLIBCXX14_CONSTEXPR\n # if __cplusplus >= 201402L\n #  define _GLIBCXX14_CONSTEXPR constexpr\n+#  define _GLIBCXX14_USE_CONSTEXPR constexpr\n # else\n #  define _GLIBCXX14_CONSTEXPR\n+#  define _GLIBCXX14_USE_CONSTEXPR const\n # endif\n #endif\n "}, {"sha": "0b317c335b8cde7f658364bca509a951b2ce1733", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 167, "deletions": 52, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -31,6 +31,8 @@\n #ifndef _HASHTABLE_POLICY_H\n #define _HASHTABLE_POLICY_H 1\n \n+#include <bits/stl_algobase.h> // for std::min.\n+\n namespace std _GLIBCXX_VISIBILITY(default)\n {\n _GLIBCXX_BEGIN_NAMESPACE_VERSION\n@@ -457,6 +459,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// smallest prime that keeps the load factor small enough.\n   struct _Prime_rehash_policy\n   {\n+    using __has_load_factor = std::true_type;\n+\n     _Prime_rehash_policy(float __z = 1.0) noexcept\n     : _M_max_load_factor(__z), _M_next_resize(0) { }\n \n@@ -501,6 +505,135 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     mutable std::size_t\t_M_next_resize;\n   };\n \n+  /// Range hashing function assuming that second arg is a power of 2.\n+  struct _Mask_range_hashing\n+  {\n+    typedef std::size_t first_argument_type;\n+    typedef std::size_t second_argument_type;\n+    typedef std::size_t result_type;\n+\n+    result_type\n+    operator()(first_argument_type __num,\n+\t       second_argument_type __den) const noexcept\n+    { return __num & (__den - 1); }\n+  };\n+\n+  /// Compute closest power of 2.\n+  _GLIBCXX14_CONSTEXPR\n+  inline std::size_t\n+  __clp2(std::size_t n) noexcept\n+  {\n+#if __SIZEOF_SIZE_T__ >= 8\n+    std::uint_fast64_t x = n;\n+#else\n+    std::uint_fast32_t x = n;\n+#endif\n+    // Algorithm from Hacker's Delight, Figure 3-3.\n+    x = x - 1;\n+    x = x | (x >> 1);\n+    x = x | (x >> 2);\n+    x = x | (x >> 4);\n+    x = x | (x >> 8);\n+    x = x | (x >>16);\n+#if __SIZEOF_SIZE_T__ >= 8\n+    x = x | (x >>32);\n+#endif\n+    return x + 1;\n+  }\n+\n+  /// Rehash policy providing power of 2 bucket numbers. Avoids modulo\n+  /// operations.\n+  struct _Power2_rehash_policy\n+  {\n+    using __has_load_factor = std::true_type;\n+\n+    _Power2_rehash_policy(float __z = 1.0) noexcept\n+    : _M_max_load_factor(__z), _M_next_resize(0) { }\n+\n+    float\n+    max_load_factor() const noexcept\n+    { return _M_max_load_factor; }\n+\n+    // Return a bucket size no smaller than n (as long as n is not above the\n+    // highest power of 2).\n+    std::size_t\n+    _M_next_bkt(std::size_t __n) const noexcept\n+    {\n+      _GLIBCXX14_USE_CONSTEXPR size_t __max_width\n+\t= std::min<size_t>(sizeof(size_t), 8);\n+      _GLIBCXX14_USE_CONSTEXPR auto __max_bkt\n+\t= std::size_t(1) << (__max_width * __CHAR_BIT__ - 1);\n+\n+      std::size_t __res = __clp2(__n);\n+\n+      if (__res == __n)\n+\t__res <<= 1;\n+\n+      if (__res == 0)\n+\t__res = __max_bkt;\n+\n+      if (__res == __max_bkt)\n+\t// Set next resize to the max value so that we never try to rehash again\n+\t// as we already reach the biggest possible bucket number.\n+\t// Note that it might result in max_load_factor not being respected.\n+\t_M_next_resize = std::size_t(-1);\n+      else\n+\t_M_next_resize\n+\t  = __builtin_ceil(__res * (long double)_M_max_load_factor);\n+\n+      return __res;\n+    }\n+\n+    // Return a bucket count appropriate for n elements\n+    std::size_t\n+    _M_bkt_for_elements(std::size_t __n) const noexcept\n+    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }\n+\n+    // __n_bkt is current bucket count, __n_elt is current element count,\n+    // and __n_ins is number of elements to be inserted.  Do we need to\n+    // increase bucket count?  If so, return make_pair(true, n), where n\n+    // is the new bucket count.  If not, return make_pair(false, 0).\n+    std::pair<bool, std::size_t>\n+    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,\n+\t\t   std::size_t __n_ins) const noexcept\n+    {\n+      if (__n_elt + __n_ins >= _M_next_resize)\n+\t{\n+\t  long double __min_bkts = (__n_elt + __n_ins)\n+\t\t\t\t\t/ (long double)_M_max_load_factor;\n+\t  if (__min_bkts >= __n_bkt)\n+\t    return std::make_pair(true,\n+\t      _M_next_bkt(std::max<std::size_t>(__builtin_floor(__min_bkts) + 1,\n+\t\t\t\t\t\t__n_bkt * _S_growth_factor)));\n+\n+\t  _M_next_resize\n+\t    = __builtin_floor(__n_bkt * (long double)_M_max_load_factor);\n+\t  return std::make_pair(false, 0);\n+\t}\n+      else\n+\treturn std::make_pair(false, 0);\n+    }\n+\n+    typedef std::size_t _State;\n+\n+    _State\n+    _M_state() const noexcept\n+    { return _M_next_resize; }\n+\n+    void\n+    _M_reset() noexcept\n+    { _M_next_resize = 0; }\n+\n+    void\n+    _M_reset(_State __state) noexcept\n+    { _M_next_resize = __state; }\n+\n+    static const std::size_t _S_growth_factor = 2;\n+\n+    float\t\t_M_max_load_factor;\n+    mutable std::size_t\t_M_next_resize;\n+  };\n+\n   // Base classes for std::_Hashtable.  We define these base classes\n   // because in some cases we want to do different things depending on\n   // the value of a policy class.  In some cases the policy class\n@@ -776,8 +909,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n \t   typename _RehashPolicy, typename _Traits,\n-\t   bool _Constant_iterators = _Traits::__constant_iterators::value,\n-\t   bool _Unique_keys = _Traits::__unique_keys::value>\n+\t   bool _Constant_iterators = _Traits::__constant_iterators::value>\n     struct _Insert;\n \n   /// Specialization.\n@@ -786,65 +918,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t   typename _H1, typename _H2, typename _Hash,\n \t   typename _RehashPolicy, typename _Traits>\n     struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t   _RehashPolicy, _Traits, true, true>\n+\t\t   _RehashPolicy, _Traits, true>\n     : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n       using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t\t_Equal, _H1, _H2, _Hash,\n \t\t\t\t\t_RehashPolicy, _Traits>;\n-      using value_type = typename __base_type::value_type;\n-      using iterator = typename __base_type::iterator;\n-      using const_iterator =  typename __base_type::const_iterator;\n-\n-      using __unique_keys = typename __base_type::__unique_keys;\n-      using __hashtable = typename __base_type::__hashtable;\n-      using __node_gen_type = typename __base_type::__node_gen_type;\n-\n-      using __base_type::insert;\n \n-      std::pair<iterator, bool>\n-      insert(value_type&& __v)\n-      {\n-\t__hashtable& __h = this->_M_conjure_hashtable();\n-\t__node_gen_type __node_gen(__h);\n-\treturn __h._M_insert(std::move(__v), __node_gen, __unique_keys());\n-      }\n-\n-      iterator\n-      insert(const_iterator __hint, value_type&& __v)\n-      {\n-\t__hashtable& __h = this->_M_conjure_hashtable();\n-\t__node_gen_type __node_gen(__h);\n-\treturn __h._M_insert(__hint, std::move(__v), __node_gen,\n-\t\t\t     __unique_keys());\n-      }\n-    };\n+      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,\n+\t\t\t\t\t       _Equal, _H1, _H2, _Hash,\n+\t\t\t\t\t       _Traits>;\n \n-  /// Specialization.\n-  template<typename _Key, typename _Value, typename _Alloc,\n-\t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy, typename _Traits>\n-    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t   _RehashPolicy, _Traits, true, false>\n-    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n-    {\n-      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,\n-\t\t\t\t\t_Equal, _H1, _H2, _Hash,\n-\t\t\t\t\t_RehashPolicy, _Traits>;\n       using value_type = typename __base_type::value_type;\n       using iterator = typename __base_type::iterator;\n       using const_iterator =  typename __base_type::const_iterator;\n \n       using __unique_keys = typename __base_type::__unique_keys;\n+      using __ireturn_type = typename __hashtable_base::__ireturn_type;\n       using __hashtable = typename __base_type::__hashtable;\n       using __node_gen_type = typename __base_type::__node_gen_type;\n \n       using __base_type::insert;\n \n-      iterator\n+      __ireturn_type\n       insert(value_type&& __v)\n       {\n \t__hashtable& __h = this->_M_conjure_hashtable();\n@@ -866,9 +963,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy, typename _Traits, bool _Unique_keys>\n+\t   typename _RehashPolicy, typename _Traits>\n     struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,\n-\t\t   _RehashPolicy, _Traits, false, _Unique_keys>\n+\t\t   _RehashPolicy, _Traits, false>\n     : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t\t   _H1, _H2, _Hash, _RehashPolicy, _Traits>\n     {\n@@ -912,28 +1009,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t}\n    };\n \n+  template<typename _Policy>\n+    using __has_load_factor = typename _Policy::__has_load_factor;\n+\n   /**\n    *  Primary class template  _Rehash_base.\n    *\n    *  Give hashtable the max_load_factor functions and reserve iff the\n-   *  rehash policy is _Prime_rehash_policy.\n+   *  rehash policy supports it.\n   */\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n \t   typename _H1, typename _H2, typename _Hash,\n-\t   typename _RehashPolicy, typename _Traits>\n+\t   typename _RehashPolicy, typename _Traits,\n+\t   typename =\n+\t     __detected_or_t<std::false_type, __has_load_factor, _RehashPolicy>>\n     struct _Rehash_base;\n \n-  /// Specialization.\n+  /// Specialization when rehash policy doesn't provide load factor management.\n   template<typename _Key, typename _Value, typename _Alloc,\n \t   typename _ExtractKey, typename _Equal,\n-\t   typename _H1, typename _H2, typename _Hash, typename _Traits>\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n     struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n-\t\t\t_H1, _H2, _Hash, _Prime_rehash_policy, _Traits>\n+\t\t      _H1, _H2, _Hash, _RehashPolicy, _Traits,\n+\t\t      std::false_type>\n+    {\n+    };\n+\n+  /// Specialization when rehash policy provide load factor management.\n+  template<typename _Key, typename _Value, typename _Alloc,\n+\t   typename _ExtractKey, typename _Equal,\n+\t   typename _H1, typename _H2, typename _Hash,\n+\t   typename _RehashPolicy, typename _Traits>\n+    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n+\t\t\t_H1, _H2, _Hash, _RehashPolicy, _Traits,\n+\t\t\tstd::true_type>\n     {\n       using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t     _Equal, _H1, _H2, _Hash,\n-\t\t\t\t     _Prime_rehash_policy, _Traits>;\n+\t\t\t\t     _RehashPolicy, _Traits>;\n \n       float\n       max_load_factor() const noexcept\n@@ -946,7 +1061,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       max_load_factor(float __z)\n       {\n \t__hashtable* __this = static_cast<__hashtable*>(this);\n-\t__this->__rehash_policy(_Prime_rehash_policy(__z));\n+\t__this->__rehash_policy(_RehashPolicy(__z));\n       }\n \n       void"}, {"sha": "5c01fa72a891f786c67db52b71d1765400689ebb", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/26132.cc", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F26132.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F26132.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2F26132.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -23,35 +23,48 @@\n #include <testsuite_hooks.h>\n \n // libstdc++/26132\n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n-\n-  for (float lf = 1.0; lf < 101.0; lf *= 10.0)\n-    for (int size = 1; size <= 6561; size *= 3)\n-      {\n-\tstd::unordered_set<int> us1;\n-\ttypedef std::unordered_set<int>::size_type size_type;\n-\t\n-\tus1.max_load_factor(10.0);\n-\n-\tfor (int i = 0; i < size; ++i)\n-\t  us1.insert(i);\n-\n-\tus1.max_load_factor(lf);\n-\n-\tfor (int i = 1; i <= 6561; i *= 81)\n-\t  {\n-\t    const size_type n = size * 81 / i;\n-\t    us1.rehash(n);\n-\t    VERIFY( us1.bucket_count() > us1.size() / us1.max_load_factor() );\n-\t    VERIFY( us1.bucket_count() >= n );\n-\t  }\n-      }\n-}\n+template<typename _USet>\n+  void test()\n+  {\n+    bool test __attribute__((unused)) = true;\n+\n+    for (float lf = 1.0; lf < 101.0; lf *= 10.0)\n+      for (int size = 1; size <= 6561; size *= 3)\n+\t{\n+\t  _USet us1;\n+\t  typedef typename _USet::size_type size_type;\n+\n+\t  us1.max_load_factor(10.0);\n+\n+\t  for (int i = 0; i < size; ++i)\n+\t    us1.insert(i);\n+\n+\t  us1.max_load_factor(lf);\n+\n+\t  for (int i = 1; i <= 6561; i *= 81)\n+\t    {\n+\t      const size_type n = size * 81 / i;\n+\t      us1.rehash(n);\n+\t      VERIFY( us1.bucket_count() > us1.size() / us1.max_load_factor() );\n+\t      VERIFY( us1.bucket_count() >= n );\n+\t    }\n+\t}\n+  }\n+\n+template<typename _Value>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, std::allocator<_Value>,\n+\t\t  std::__detail::_Identity,\n+\t\t  std::equal_to<_Value>,\n+\t\t  std::hash<_Value>,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n \n int main()\n {\n-  test01();\n+  test<std::unordered_set<int>>();\n+  test<unordered_set_power2_rehash<int>>();\n   return 0;\n }"}, {"sha": "0c3b7f84167f5c6b0aee0fdb47d970b44deea3c2", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/load_factor.cc", "status": "modified", "additions": 37, "deletions": 23, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fload_factor.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fload_factor.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fload_factor.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -18,41 +18,55 @@\n // { dg-options \"-std=gnu++11\" }\n \n #include <unordered_set>\n+\n #include <testsuite_hooks.h>\n \n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n+template<typename _USet>\n+  void test()\n   {\n-    std::unordered_set<int> us;\n-    for (int i = 0; i != 100000; ++i)\n+    bool test __attribute__((unused)) = true;\n     {\n-      us.insert(i);\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      _USet us;\n+      for (int i = 0; i != 100000; ++i)\n+\t{\n+\t  us.insert(i);\n+\t  VERIFY( us.load_factor() <= us.max_load_factor() );\n+\t}\n     }\n-  }\n-  {\n-    std::unordered_set<int> us;\n-    us.max_load_factor(3.f);\n-    for (int i = 0; i != 100000; ++i)\n     {\n-      us.insert(i);\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      _USet us;\n+      us.max_load_factor(3.f);\n+      for (int i = 0; i != 100000; ++i)\n+\t{\n+\t  us.insert(i);\n+\t  VERIFY( us.load_factor() <= us.max_load_factor() );\n+\t}\n     }\n-  }\n-  {\n-    std::unordered_set<int> us;\n-    us.max_load_factor(.3f);\n-    for (int i = 0; i != 100000; ++i)\n     {\n-      us.insert(i);\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n+      _USet us;\n+      us.max_load_factor(.3f);\n+      for (int i = 0; i != 100000; ++i)\n+\t{\n+\t  us.insert(i);\n+\t  VERIFY( us.load_factor() <= us.max_load_factor() );\n+\t}\n     }\n   }\n-}\n+\n+template<typename _Value>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, std::allocator<_Value>,\n+\t\t  std::__detail::_Identity,\n+\t\t  std::equal_to<_Value>,\n+\t\t  std::hash<_Value>,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n \n int main()\n {\n-  test01();\n+  test<std::unordered_set<int>>();\n+  test<unordered_set_power2_rehash<int>>();\n   return 0;\n }"}, {"sha": "1d01d0a19f5d14bcc0210220cf8a35b47bc116fe", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/power2_rehash.cc", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Fpower2_rehash.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -0,0 +1,42 @@\n+// Copyright (C) 2016 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+//\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <unordered_set>\n+\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  std::__detail::_Power2_rehash_policy policy;\n+  VERIFY( policy._M_next_bkt(1) == 2 );\n+  VERIFY( policy._M_next_bkt(2) == 4 );\n+  VERIFY( policy._M_next_bkt(3) == 4 );\n+  VERIFY( policy._M_next_bkt(5) == 8 );\n+  VERIFY( policy._M_next_bkt(33) == 64 );\n+  VERIFY( policy._M_next_bkt((std::size_t(1) << (sizeof(std::size_t) * 8 - 2)) + 1)\n+\t  == (std::size_t(1) << (sizeof(std::size_t) * 8 - 1)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "2dac583598d13c0ba970598fbc62860c2bf1a034", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/hash_policy/rehash.cc", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fhash_policy%2Frehash.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -18,13 +18,15 @@\n // { dg-options \"-std=gnu++11\" }\n \n #include <unordered_set>\n+\n #include <testsuite_hooks.h>\n \n-void test01()\n+template<typename _USet>\n+void test()\n {\n   bool test __attribute__((unused)) = true;\n-  std::unordered_set<int> us;\n-  typedef typename std::unordered_set<int>::size_type size_type;\n+  _USet us;\n+  typedef typename _USet::size_type size_type;\n   bool rehashed = false;\n   for (int i = 0; i != 100000; ++i)\n   {\n@@ -55,8 +57,20 @@ void test01()\n   VERIFY( rehashed );\n }\n \n+template<typename _Value>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, std::allocator<_Value>,\n+\t\t  std::__detail::_Identity,\n+\t\t  std::equal_to<_Value>,\n+\t\t  std::hash<_Value>,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n+\n int main()\n {\n-  test01();\n+  test<std::unordered_set<int>>();\n+  test<unordered_set_power2_rehash<int>>();\n   return 0;\n }"}, {"sha": "7dcaf3958c0f290f16eac103c8dccc96225813ec", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/insert/hash_policy.cc", "status": "modified", "additions": 106, "deletions": 78, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finsert%2Fhash_policy.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -20,94 +20,122 @@\n #include <unordered_set>\n #include <vector>\n #include <limits>\n+\n #include <ext/throw_allocator.h>\n+\n #include <testsuite_hooks.h>\n \n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n+template<template<typename _Value, typename _Hash,\n+\t\t  typename _Pred, typename _Alloc>\n+\t   typename _USet>\n+  void test01()\n+  {\n+    bool test __attribute__((unused)) = true;\n \n-  typedef std::numeric_limits<std::size_t> nl_size_t;\n-  std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n-\t\t     __gnu_cxx::throw_allocator_limit<int> > us;\n-  const int nb = 100;\n-  int scheduled_throw_counter = 0;\n-  std::size_t thrown_exceptions = 0;\n-  for (int i = 0; i != nb; ++i)\n-    {\n-      if ((float)(us.size() + 1)\n-\t  / (float)us.bucket_count() >= us.max_load_factor())\n-\t{\n-\t  // We are going to need a rehash, lets introduce allocation issues:\n-\t  __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n-\t}\n-      try\n-\t{\n-\t  VERIFY(us.insert(i).second);\n-\t  scheduled_throw_counter = 0;\n-\t}\n-      catch (const __gnu_cxx::forced_error&)\n-\t{\n-\t  ++thrown_exceptions;\n-\t  --i;\n-\t}\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n-      __gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n-    }\n+    // Make sure whatever happen we restore throw allocator limit at exit.\n+    __gnu_cxx::limit_condition::adjustor_base adj;\n \n-  VERIFY( thrown_exceptions != 0 );\n-  // Check that all values have been inserted:\n-  for (int i = 0; i != nb; ++i)\n-    {\n-      VERIFY( us.count(i) == 1 );\n-    }\n-}\n+    typedef std::numeric_limits<std::size_t> nl_size_t;\n+    _USet<int, std::hash<int>, std::equal_to<int>,\n+\t  __gnu_cxx::throw_allocator_limit<int> > us;\n+    const int nb = 100;\n+    int scheduled_throw_counter = 0;\n+    std::size_t thrown_exceptions = 0;\n+    for (int i = 0; i != nb; ++i)\n+      {\n+\tif ((float)(us.size() + 1)\n+\t    / (float)us.bucket_count() >= us.max_load_factor())\n+\t  {\n+\t    // We are going to need a rehash, lets introduce allocation issues:\n+\t    __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n+\t  }\n+\ttry\n+\t  {\n+\t    VERIFY(us.insert(i).second);\n+\t    scheduled_throw_counter = 0;\n+\t  }\n+\tcatch (const __gnu_cxx::forced_error&)\n+\t  {\n+\t    ++thrown_exceptions;\n+\t    --i;\n+\t  }\n+\tVERIFY( us.load_factor() <= us.max_load_factor() );\n+\t__gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n+      }\n \n-void test02()\n-{\n-  bool test __attribute__((unused)) = true;\n+    VERIFY( thrown_exceptions != 0 );\n+    // Check that all values have been inserted:\n+    for (int i = 0; i != nb; ++i)\n+      {\n+\tVERIFY( us.count(i) == 1 );\n+      }\n+  }\n \n-  typedef std::numeric_limits<std::size_t> nl_size_t;\n-  std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n-\t\t     __gnu_cxx::throw_allocator_limit<int> > us;\n-  const int nb = 100;\n-  int scheduled_throw_counter = 0;\n-  std::size_t thrown_exceptions = 0;\n-  for (int i = 0; i != nb; ++i)\n-    {\n-      if ((float)(us.size() + 2)\n-\t  / (float)us.bucket_count() >= us.max_load_factor())\n-\t{\n-\t  // We are going to need a rehash, lets introduce allocation issues:\n-\t  __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n-\t}\n-      try\n-\t{\n-\t  std::vector<int> v = { i, i };\n-\t  // Check the insert range robustness\n-\t  us.insert(v.begin(), v.end());\n-\t  scheduled_throw_counter = 0;\n-\t}\n-      catch (const __gnu_cxx::forced_error&)\n-\t{\n-\t  ++thrown_exceptions;\n-\t  --i;\n-\t}\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n-      __gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n-    }\n+template<template<typename _Value, typename _Hash,\n+\t\t  typename _Pred, typename _Alloc>\n+\t   typename _USet>\n+  void test02()\n+  {\n+    bool test __attribute__((unused)) = true;\n \n-  VERIFY( thrown_exceptions != 0 );\n-  // Check that all values have been inserted:\n-  for (int i = 0; i != nb; ++i)\n-    {\n-      VERIFY( us.count(i) == 1 );\n-    }\n-}\n+    // Make sure whatever happen we restore throw allocator limit at exit.\n+    __gnu_cxx::limit_condition::adjustor_base adj;\n+\n+    typedef std::numeric_limits<std::size_t> nl_size_t;\n+    _USet<int, std::hash<int>, std::equal_to<int>,\n+\t\t       __gnu_cxx::throw_allocator_limit<int> > us;\n+    const int nb = 100;\n+    int scheduled_throw_counter = 0;\n+    std::size_t thrown_exceptions = 0;\n+    for (int i = 0; i != nb; ++i)\n+      {\n+\tif ((float)(us.size() + 2)\n+\t    / (float)us.bucket_count() >= us.max_load_factor())\n+\t  {\n+\t    // We are going to need a rehash, lets introduce allocation issues:\n+\t    __gnu_cxx::limit_condition::set_limit(scheduled_throw_counter++);\n+\t  }\n+\ttry\n+\t  {\n+\t    std::vector<int> v = { i, i };\n+\t    // Check the insert range robustness\n+\t    us.insert(v.begin(), v.end());\n+\t    scheduled_throw_counter = 0;\n+\t  }\n+\tcatch (const __gnu_cxx::forced_error&)\n+\t  {\n+\t    ++thrown_exceptions;\n+\t    --i;\n+\t  }\n+\tVERIFY( us.load_factor() <= us.max_load_factor() );\n+\t__gnu_cxx::limit_condition::set_limit(nl_size_t::max());\n+      }\n+\n+    VERIFY( thrown_exceptions != 0 );\n+    // Check that all values have been inserted:\n+    for (int i = 0; i != nb; ++i)\n+      {\n+\tVERIFY( us.count(i) == 1 );\n+      }\n+  }\n+\n+template<typename _Value, typename _Hash,\n+\t typename _Pred, typename _Alloc>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, _Alloc,\n+\t\t  std::__detail::_Identity,\n+\t\t  _Pred,\n+\t\t  _Hash,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n \n int main()\n {\n-  test01();\n-  test02();\n+  test01<std::unordered_set>();\n+  test01<unordered_set_power2_rehash>();\n+  test02<std::unordered_set>();\n+  test02<unordered_set_power2_rehash>();\n   return 0;\n }"}, {"sha": "b95c86f4af4f277148ab047c1550982551b6c217", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/max_load_factor/robustness.cc", "status": "modified", "additions": 62, "deletions": 46, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmax_load_factor%2Frobustness.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmax_load_factor%2Frobustness.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fmax_load_factor%2Frobustness.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -22,62 +22,78 @@\n #include <ext/throw_allocator.h>\n #include <testsuite_hooks.h>\n \n-void test01()\n-{\n-  bool test __attribute__((unused)) = true;\n+template<template<typename _Value, typename _Hash,\n+\t\t  typename _Pred, typename _Alloc>\n+\t   typename _USet>\n+  void test()\n+  {\n+    bool test __attribute__((unused)) = true;\n \n-  typedef std::numeric_limits<std::size_t> nl_size_t;\n-  std::unordered_set<int, std::hash<int>, std::equal_to<int>,\n-\t\t     __gnu_cxx::throw_allocator_limit<int> > us;\n-  int val = 0;\n-  for (; val != 100; ++val)\n-    {\n-      VERIFY( us.insert(val).second );\n-      VERIFY( us.load_factor() <= us.max_load_factor() );\n-    }\n+    typedef std::numeric_limits<std::size_t> nl_size_t;\n+    _USet<int, std::hash<int>, std::equal_to<int>,\n+\t  __gnu_cxx::throw_allocator_limit<int> > us;\n+    int val = 0;\n+    for (; val != 100; ++val)\n+      {\n+\tVERIFY( us.insert(val).second );\n+\tVERIFY( us.load_factor() <= us.max_load_factor() );\n+      }\n \n-  float cur_max_load_factor = us.max_load_factor();\n-  int counter = 0;\n-  std::size_t thrown_exceptions = 0;\n+    float cur_max_load_factor = us.max_load_factor();\n+    int counter = 0;\n+    std::size_t thrown_exceptions = 0;\n \n-  // Reduce max load factor.\n-  us.max_load_factor(us.max_load_factor() / 2);\n+    // Reduce max load factor.\n+    us.max_load_factor(us.max_load_factor() / 4);\n \n-  // At this point load factor is higher than max_load_factor because we can't\n-  // rehash in max_load_factor call.\n-  VERIFY( us.load_factor() > us.max_load_factor() );\n+    // At this point load factor is higher than max_load_factor because we can't\n+    // rehash in max_load_factor call.\n+    VERIFY( us.load_factor() > us.max_load_factor() );\n \n-  while (true)\n-    {\n-      __gnu_cxx::limit_condition::set_limit(counter++);\n-      bool do_break = false;\n-      try\n-\t{\n-\t  size_t nbkts = us.bucket_count();\n-\t  // Check that unordered_set will still be correctly resized when\n-\t  // needed.\n-\t  VERIFY( us.insert(val++).second );\n+    while (true)\n+      {\n+\t__gnu_cxx::limit_condition::limit_adjustor adjustor(counter++);\n+\tbool do_break = false;\n+\ttry\n+\t  {\n+\t    size_t nbkts = us.bucket_count();\n+\t    // Check that unordered_set will still be correctly resized when\n+\t    // needed.\n+\t    VERIFY( us.insert(val++).second );\n+\t    VERIFY( us.bucket_count() != nbkts );\n+\t    VERIFY( us.load_factor() <= us.max_load_factor() );\n+\t    do_break = true;\n+\t  }\n+\tcatch (const __gnu_cxx::forced_error&)\n+\t  {\n+\t    // max load factor doesn't change.\n+\t    VERIFY( us.max_load_factor() == .25f );\n+\t    ++thrown_exceptions;\n+\t  }\n \n-\t  VERIFY( us.bucket_count() != nbkts );\n-\t  VERIFY( us.load_factor() <= us.max_load_factor() );\n-\t  do_break = true;\n-\t}\n-      catch (const __gnu_cxx::forced_error&)\n-\t{\n-\t  // max load factor doesn't change.\n-\t  VERIFY( us.max_load_factor() == .5f );\n-\t  ++thrown_exceptions;\n-\t}\n+\tif (do_break)\n+\t  break;\n+      }\n \n-      if (do_break)\n-\tbreak;\n-    }\n+    VERIFY( thrown_exceptions > 0 );\n+  }\n \n-  VERIFY( thrown_exceptions > 0 );\n-}\n+\n+template<typename _Value, typename _Hash,\n+\t typename _Pred, typename _Alloc>\n+  using unordered_set_power2_rehash =\n+  std::_Hashtable<_Value, _Value, _Alloc,\n+\t\t  std::__detail::_Identity,\n+\t\t  _Pred,\n+\t\t  _Hash,\n+\t\t  std::__detail::_Mask_range_hashing,\n+\t\t  std::__detail::_Default_ranged_hash,\n+\t\t  std::__detail::_Power2_rehash_policy,\n+\t\t  std::__detail::_Hashtable_traits<false, true, true>>;\n \n int main()\n {\n-  test01();\n+  test<std::unordered_set>();\n+  test<unordered_set_power2_rehash>();\n   return 0;\n }"}, {"sha": "784ac71ec1566e3104f911b3eeaeca2fbfb32de9", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/54075.cc", "status": "modified", "additions": 34, "deletions": 1, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2F54075.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -127,7 +127,27 @@ template<bool cache>\n   using __umset = std::__umset_hashtable<Foo, HashFunction,\n \t\t\t\t\t std::equal_to<Foo>,\n \t\t\t\t\t std::allocator<Foo>,\n-\t\t\t\t\t std::__uset_traits<cache>>;\n+\t\t\t\t\t std::__umset_traits<cache>>;\n+\n+template<bool cache>\n+  using __uset2 =\n+\t      std::_Hashtable<Foo, Foo, std::allocator<Foo>,\n+\t\t\t      std::__detail::_Identity,\n+\t\t\t      std::equal_to<Foo>, HashFunction,\n+\t\t\t      std::__detail::_Mask_range_hashing,\n+\t\t\t      std::__detail::_Default_ranged_hash,\n+\t\t\t      std::__detail::_Power2_rehash_policy,\n+\t\t\t      std::__uset_traits<cache>>;\n+\n+template<bool cache>\n+  using __umset2 =\n+\t      std::_Hashtable<Foo, Foo, std::allocator<Foo>,\n+\t\t\t      std::__detail::_Identity,\n+\t\t\t      std::equal_to<Foo>, HashFunction,\n+\t\t\t      std::__detail::_Mask_range_hashing,\n+\t\t\t      std::__detail::_Default_ranged_hash,\n+\t\t\t      std::__detail::_Power2_rehash_policy,\n+\t\t\t      std::__umset_traits<cache>>;\n \n int main()\n {\n@@ -181,6 +201,19 @@ int main()\n   stop_counters(time, resource);\n   report_performance(__FILE__, \"std benches\", time, resource);\n \n+  start_counters(time, resource);\n+  bench<__uset2<false>>(\n+\t\"std::unordered_set2 without hash code cached \", foos);\n+  bench<__uset2<true>>(\n+\t\"std::unordered_set2 with hash code cached \", foos);\n+  bench<__umset2<false>>(\n+\t\"std::unordered_multiset2 without hash code cached \", foos);\n+  bench<__umset2<true>>(\n+\t\"std::unordered_multiset2 with hash code cached \", foos);\n+\n+  stop_counters(time, resource);\n+  report_performance(__FILE__, \"std2 benches\", time, resource);\n+\n   bench<std::unordered_set<Foo, HashFunction>>(\n \t\"std::unordered_set default cache \", foos);\n   bench<std::unordered_multiset<Foo, HashFunction>>("}, {"sha": "44781d2fdd7fdfb98ff62f15e5f320de766ff377", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert_erase/41975.cc", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/732eb07625bc086833506374f1ce452096716874/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert_erase%2F41975.cc?ref=732eb07625bc086833506374f1ce452096716874", "patch": "@@ -176,6 +176,16 @@ template<bool cache>\n \t\t\t\t\tstd::allocator<int>,\n \t\t\t\t\tcache>;\n \n+template<bool cache>\n+  using __uset2 =\n+\t      std::_Hashtable<int, int, std::allocator<int>,\n+\t\t\t      std::__detail::_Identity,\n+\t\t\t      std::equal_to<int>, std::hash<int>,\n+\t\t\t      std::__detail::_Mask_range_hashing,\n+\t\t\t      std::__detail::_Default_ranged_hash,\n+\t\t\t      std::__detail::_Power2_rehash_policy,\n+\t\t\t      std::__uset_traits<cache>>;\n+\n template<bool cache>\n   using __str_uset = \n \t      std::__uset_hashtable<std::string, std::hash<std::string>,\n@@ -190,6 +200,16 @@ template<bool cache>\n \t\t\t\t\tstd::allocator<std::string>,\n \t\t\t\t\tcache>;\n \n+template<bool cache>\n+  using __str_uset2 =\n+\t      std::_Hashtable<std::string, std::string, std::allocator<std::string>,\n+\t\t\t      std::__detail::_Identity,\n+\t\t\t      std::equal_to<std::string>, std::hash<std::string>,\n+\t\t\t      std::__detail::_Mask_range_hashing,\n+\t\t\t      std::__detail::_Default_ranged_hash,\n+\t\t\t      std::__detail::_Power2_rehash_policy,\n+\t\t\t      std::__uset_traits<cache>>;\n+\n int main()\n {\n   bench<__tr1_uset<false>>(\n@@ -202,6 +222,10 @@ int main()\n \t\"std::unordered_set<int> with hash code cached\");\n   bench<std::unordered_set<int>>(\n \t\"std::unordered_set<int> default cache\");\n+  bench<__uset2<false>>(\n+\t\"std::unordered_set2<int> without hash code cached\");\n+  bench<__uset2<true>>(\n+\t\"std::unordered_set2<int> with hash code cached\");\n   bench_str<__tr1_str_uset<false>>(\n \t\"std::tr1::unordered_set<string> without hash code cached\");\n   bench_str<__tr1_str_uset<true>>(\n@@ -210,7 +234,11 @@ int main()\n \t\"std::unordered_set<string> without hash code cached\");\n   bench_str<__str_uset<true>>(\n \t\"std::unordered_set<string> with hash code cached\");\n-    bench_str<std::unordered_set<std::string>>(\n+  bench_str<std::unordered_set<std::string>>(\n \t\"std::unordered_set<string> default cache\");\n+  bench_str<__str_uset2<false>>(\n+\t\"std::unordered_set2<string> without hash code cached\");\n+  bench_str<__str_uset2<true>>(\n+\t\"std::unordered_set2<string> with hash code cached\");\n   return 0;\n }"}]}