{"sha": "1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWMyOGQxMmY2MTZiNzEyNjlmMWI3ZTFlZmM2MWMyODdjOWI0Y2EzOA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2019-07-02T08:28:24Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-07-02T08:28:24Z"}, "message": "tree-ssa-alias.c (nonoverlapping_component_refs_for_decl_p): Rename to ..\n\n\n\t* tree-ssa-alias.c (nonoverlapping_component_refs_for_decl_p): Rename\n\tto ..\n\t(nonoverlapping_component_refs_since_match_p): ... this one;\n\thandle also non-decl bases; return -1 if search gave up.\n\t(alias_stats): Rename nonoverlapping_component_refs_of_decl_p_may_alias,\n\tnonoverlapping_component_refs_of_decl_p_no_alias to\n\tnonoverlapping_component_refs_since_match_p_may_alias,\n\tnonoverlapping_component_refs_since_match_p_no_alias.\n\t(dump_alias_stats): Update dumping.\n\t(aliasing_matching_component_refs_p):  Break out from ...;\n\tdispatch to nonoverlapping_component_refs_for_decl_p\n\tand nonoverlapping_component_refs_since_match_p.\n\t(aliasing_component_refs_p): ... here; call\n\tnonoverlapping_component_refs_p in scenarios where we can not\n\tprecisely determine base match.\n\t(decl_refs_may_alias_p): Use\n\tnonoverlapping_component_refs_since_match_p.\n\t(indirect_ref_may_alias_decl_p): Do not call\n\tnonoverlapping_component_refs_p.\n\t(indirect_refs_may_alias_p): Likewise.\n\n\t* gcc.dg/tree-ssa/alias-access-path-7.c: New testcase.\n\nFrom-SVN: r272926", "tree": {"sha": "dd4ae2e07ac139e4f22b0dbf60499511dd8cac5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd4ae2e07ac139e4f22b0dbf60499511dd8cac5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/comments", "author": null, "committer": null, "parents": [{"sha": "f51b4aed271f256f029ed4447141a7d1e8017a8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f51b4aed271f256f029ed4447141a7d1e8017a8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f51b4aed271f256f029ed4447141a7d1e8017a8c"}], "stats": {"total": 306, "additions": 209, "deletions": 97}, "files": [{"sha": "b9ec15b19465ae20a6e7d76253b5de9e9d75007a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "patch": "@@ -1,3 +1,26 @@\n+2019-07-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree-ssa-alias.c (nonoverlapping_component_refs_for_decl_p): Rename\n+\tto ..\n+\t(nonoverlapping_component_refs_since_match_p): ... this one;\n+\thandle also non-decl bases; return -1 if search gave up.\n+\t(alias_stats): Rename nonoverlapping_component_refs_of_decl_p_may_alias,\n+\tnonoverlapping_component_refs_of_decl_p_no_alias to\n+\tnonoverlapping_component_refs_since_match_p_may_alias,\n+\tnonoverlapping_component_refs_since_match_p_no_alias.\n+\t(dump_alias_stats): Update dumping.\n+\t(aliasing_matching_component_refs_p):  Break out from ...;\n+\tdispatch to nonoverlapping_component_refs_for_decl_p\n+\tand nonoverlapping_component_refs_since_match_p.\n+\t(aliasing_component_refs_p): ... here; call\n+\tnonoverlapping_component_refs_p in scenarios where we can not\n+\tprecisely determine base match.\n+\t(decl_refs_may_alias_p): Use\n+\tnonoverlapping_component_refs_since_match_p.\n+\t(indirect_ref_may_alias_decl_p): Do not call\n+\tnonoverlapping_component_refs_p.\n+\t(indirect_refs_may_alias_p): Likewise.\n+\n 2019-07-02  Jan Hubicka  <jh@suse.cz>\n \n \t* tree-inline.c (remap_gimple_stmt): Do not subtitute handled components"}, {"sha": "423e075a9dcb28d0eebe0b0cc74f29f1307699d4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "patch": "@@ -1,3 +1,7 @@\n+2019-07-02  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-ssa/alias-access-path-7.c: New testcase.\n+\n 2019-07-02  Jan Hubicka  <jh@suse.cz>\n \n \t* g++.dg/lto/pr90990_0.C: New testcase."}, {"sha": "05cf037c2abd56f7e389cebccf92944bd65f4521", "filename": "gcc/testsuite/gcc.dg/tree-ssa/alias-access-path-7.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Falias-access-path-7.c?ref=1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fno-strict-aliasing -fdump-tree-optimized\" } */\n+\n+struct S\n+{\n+  int i;\n+  int j;\n+};\n+struct U\n+{\n+  struct S a[10];\n+};\n+int\n+foo (struct U *u, int n, int i, int j)\n+{\n+  u->a[i].i = 123;\n+  u->a[j].j = j;\n+  return u->a[i].i;\n+}\n+/* { dg-final { scan-tree-dump-times \"return 123\" 1 \"optimized\"} } */"}, {"sha": "3763b8598a23cea04e63d2d3ee3b2d81ee1dab7f", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 162, "deletions": 97, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c28d12f616b71269f1b7e1efc61c287c9b4ca38/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=1c28d12f616b71269f1b7e1efc61c287c9b4ca38", "patch": "@@ -87,6 +87,8 @@ along with GCC; see the file COPYING3.  If not see\n    this file.  Low-level disambiguators dealing with points-to\n    information are in tree-ssa-structalias.c.  */\n \n+static int nonoverlapping_component_refs_since_match_p (tree, tree, tree, tree);\n+static bool nonoverlapping_component_refs_p (const_tree, const_tree);\n \n /* Query statistics for the different low-level disambiguators.\n    A high-level query may trigger multiple of them.  */\n@@ -102,8 +104,8 @@ static struct {\n   unsigned HOST_WIDE_INT aliasing_component_refs_p_no_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_may_alias;\n   unsigned HOST_WIDE_INT nonoverlapping_component_refs_p_no_alias;\n-  unsigned HOST_WIDE_INT nonoverlapping_component_refs_of_decl_p_may_alias;\n-  unsigned HOST_WIDE_INT nonoverlapping_component_refs_of_decl_p_no_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_since_match_p_may_alias;\n+  unsigned HOST_WIDE_INT nonoverlapping_component_refs_since_match_p_no_alias;\n } alias_stats;\n \n void\n@@ -134,12 +136,12 @@ dump_alias_stats (FILE *s)\n \t   alias_stats.nonoverlapping_component_refs_p_no_alias,\n \t   alias_stats.nonoverlapping_component_refs_p_no_alias\n \t   + alias_stats.nonoverlapping_component_refs_p_may_alias);\n-  fprintf (s, \"  nonoverlapping_component_refs_of_decl_p: \"\n+  fprintf (s, \"  nonoverlapping_component_refs_since_match_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n-\t   alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias,\n-\t   alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias\n-\t   + alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias);\n+\t   alias_stats.nonoverlapping_component_refs_since_match_p_no_alias,\n+\t   alias_stats.nonoverlapping_component_refs_since_match_p_no_alias\n+\t   + alias_stats.nonoverlapping_component_refs_since_match_p_may_alias);\n   fprintf (s, \"  aliasing_component_refs_p: \"\n \t   HOST_WIDE_INT_PRINT_DEC\" disambiguations, \"\n \t   HOST_WIDE_INT_PRINT_DEC\" queries\\n\",\n@@ -848,6 +850,47 @@ type_has_components_p (tree type)\n \t || TREE_CODE (type) == COMPLEX_TYPE;\n }\n \n+/* MATCH1 and MATCH2 which are part of access path of REF1 and REF2\n+   respectively are either pointing to same address or are completely\n+   disjoint.\n+\n+   Try to disambiguate using the access path starting from the match\n+   and return false if there is no conflict.\n+\n+   Helper for aliasing_component_refs_p.  */\n+\n+static bool\n+aliasing_matching_component_refs_p (tree match1, tree ref1,\n+\t\t\t\t    poly_int64 offset1, poly_int64 max_size1,\n+\t\t\t\t    tree match2, tree ref2,\n+\t\t\t\t    poly_int64 offset2, poly_int64 max_size2)\n+{\n+  poly_int64 offadj, sztmp, msztmp;\n+  bool reverse;\n+\n+\n+  get_ref_base_and_extent (match2, &offadj, &sztmp, &msztmp, &reverse);\n+  offset2 -= offadj;\n+  get_ref_base_and_extent (match1, &offadj, &sztmp, &msztmp, &reverse);\n+  offset1 -= offadj;\n+  if (!ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n+    {\n+      ++alias_stats.aliasing_component_refs_p_no_alias;\n+      return false;\n+    }\n+\n+  int cmp = nonoverlapping_component_refs_since_match_p (match1, ref1,\n+\t\t\t\t\t\t\t match2, ref2);\n+  if (cmp == 1\n+      || (cmp == -1 && nonoverlapping_component_refs_p (ref1, ref2)))\n+    {\n+      ++alias_stats.aliasing_component_refs_p_no_alias;\n+      return false;\n+    }\n+  ++alias_stats.aliasing_component_refs_p_may_alias;\n+  return true;\n+}\n+\n /* Determine if the two component references REF1 and REF2 which are\n    based on access types TYPE1 and TYPE2 and of which at least one is based\n    on an indirect reference may alias.  \n@@ -969,37 +1012,24 @@ aliasing_component_refs_p (tree ref1,\n \t}\n       if (same_p2 == 1)\n \t{\n-\t  poly_int64 offadj, sztmp, msztmp;\n-\t  bool reverse;\n-\n \t  /* We assume that arrays can overlap by multiple of their elements\n \t     size as tested in gcc.dg/torture/alias-2.c.\n \t     This partial overlap happen only when both arrays are bases of\n \t     the access and not contained within another component ref.\n-\t     To be safe we also assume partial overlap for VLAs.  */\n+\t     To be safe we also assume partial overlap for VLAs. */\n \t  if (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n \t      && (!TYPE_SIZE (TREE_TYPE (base1))\n \t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n \t\t  || ref == base2))\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t      return true;\n-\t    }\n-\n-\t  get_ref_base_and_extent (ref, &offadj, &sztmp, &msztmp, &reverse);\n-\t  offset2 -= offadj;\n-\t  get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n-\t  offset1 -= offadj;\n-\t  if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t      return true;\n-\t    }\n+\t    /* Setting maybe_match to true triggers\n+\t       nonoverlapping_component_refs_p test later that still may do\n+\t       useful disambiguation.  */\n+\t    maybe_match = true;\n \t  else\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_no_alias;\n-\t      return false;\n-\t    }\n+\t    return aliasing_matching_component_refs_p (base1, ref1,\n+\t\t\t\t\t\t       offset1, max_size1,\n+\t\t\t\t\t\t       ref, ref2,\n+\t\t\t\t\t\t       offset2, max_size2);\n \t}\n     }\n \n@@ -1033,32 +1063,16 @@ aliasing_component_refs_p (tree ref1,\n \t}\n       if (same_p1 == 1)\n \t{\n-\t  poly_int64 offadj, sztmp, msztmp;\n-\t  bool reverse;\n-\n \t  if (TREE_CODE (TREE_TYPE (base2)) == ARRAY_TYPE\n \t      && (!TYPE_SIZE (TREE_TYPE (base2))\n \t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base2))) != INTEGER_CST\n \t\t  || ref == base1))\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t      return true;\n-\t    }\n-\n-\t  get_ref_base_and_extent (ref, &offadj, &sztmp, &msztmp, &reverse);\n-\t  offset1 -= offadj;\n-\t  get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n-\t  offset2 -= offadj;\n-\t  if (ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2))\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_may_alias;\n-\t      return true;\n-\t    }\n+\t    maybe_match = true;\n \t  else\n-\t    {\n-\t      ++alias_stats.aliasing_component_refs_p_no_alias;\n-\t      return false;\n-\t    }\n+\t    return aliasing_matching_component_refs_p (ref, ref1,\n+\t\t\t\t\t\t       offset1, max_size1,\n+\t\t\t\t\t\t       base2, ref2,\n+\t\t\t\t\t\t       offset2, max_size2);\n \t}\n     }\n \n@@ -1067,7 +1081,15 @@ aliasing_component_refs_p (tree ref1,\n      continuation of another.  If we was not able to decide about equivalence,\n      we need to give up.  */\n   if (maybe_match)\n-    return true;\n+    {\n+      if (!nonoverlapping_component_refs_p (ref1, ref2))\n+\t{\n+\t  ++alias_stats.aliasing_component_refs_p_may_alias;\n+\t  return true;\n+\t}\n+      ++alias_stats.aliasing_component_refs_p_no_alias;\n+      return false;\n+    }\n \n   /* If we have two type access paths B1.path1 and B2.path2 they may\n      only alias if either B1 is in B2.path2 or B2 is in B1.path1.\n@@ -1083,6 +1105,7 @@ aliasing_component_refs_p (tree ref1,\n       && (base1_alias_set == ref2_alias_set\n           || alias_set_subset_of (base1_alias_set, ref2_alias_set)))\n     {\n+      gcc_checking_assert (!nonoverlapping_component_refs_p (ref1, ref2));\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n       return true;\n     }\n@@ -1095,58 +1118,94 @@ aliasing_component_refs_p (tree ref1,\n       && (base2_alias_set == ref1_alias_set\n \t  || alias_set_subset_of (base2_alias_set, ref1_alias_set)))\n     {\n+      gcc_checking_assert (!nonoverlapping_component_refs_p (ref1, ref2));\n       ++alias_stats.aliasing_component_refs_p_may_alias;\n       return true;\n     }\n   ++alias_stats.aliasing_component_refs_p_no_alias;\n   return false;\n }\n \n-/* Return true if we can determine that component references REF1 and REF2,\n-   that are within a common DECL, cannot overlap.  */\n+/* Try to disambiguate REF1 and REF2 under the assumption that MATCH1 and\n+   MATCH2 either point to the same address or are disjoint.\n+   MATCH1 and MATCH2 are assumed to be ref in the access path of REF1 and REF2\n+   respectively or NULL in the case we established equivalence of bases.\n \n-static bool\n-nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n+   This test works by matching the initial segment of the access path\n+   and does not rely on TBAA thus is safe for !flag_strict_aliasing if\n+   match was determined without use of TBAA oracle.\n+\n+   Return 1 if we can determine that component references REF1 and REF2,\n+   that are within a common DECL, cannot overlap.\n+\n+   Return 0 if paths are same and thus there is nothing to disambiguate more\n+   (i.e. there is must alias assuming there is must alias between MATCH1 and\n+   MATCH2)\n+\n+   Return -1 if we can not determine 0 or 1 - this happens when we met\n+   non-matching types was met in the path.\n+   In this case it may make sense to continue by other disambiguation\n+   oracles.  */\n+\n+static int\n+nonoverlapping_component_refs_since_match_p (tree match1, tree ref1,\n+\t\t\t\t\t     tree match2, tree ref2)\n {\n   auto_vec<tree, 16> component_refs1;\n   auto_vec<tree, 16> component_refs2;\n \n   /* Create the stack of handled components for REF1.  */\n   while (handled_component_p (ref1))\n     {\n-      component_refs1.safe_push (ref1);\n+      if (TREE_CODE (ref1) == VIEW_CONVERT_EXPR\n+\t  || TREE_CODE (ref1) == BIT_FIELD_REF)\n+\tcomponent_refs1.truncate (0);\n+      else\n+        component_refs1.safe_push (ref1);\n+      if (ref1 == match1)\n+\tbreak;\n       ref1 = TREE_OPERAND (ref1, 0);\n     }\n-  if (TREE_CODE (ref1) == MEM_REF)\n+  if (TREE_CODE (ref1) == MEM_REF && ref1 != match1)\n     {\n       if (!integer_zerop (TREE_OPERAND (ref1, 1)))\n \t{\n-\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t  return false;\n+\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  return -1;\n \t}\n-      ref1 = TREE_OPERAND (TREE_OPERAND (ref1, 0), 0);\n+    }\n+  /* TODO: Handle TARGET_MEM_REF later.  */\n+  if (TREE_CODE (ref1) == TARGET_MEM_REF && ref1 != match1)\n+    {\n+      ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+      return -1;\n     }\n \n   /* Create the stack of handled components for REF2.  */\n   while (handled_component_p (ref2))\n     {\n-      component_refs2.safe_push (ref2);\n+      if (TREE_CODE (ref2) == VIEW_CONVERT_EXPR\n+\t  || TREE_CODE (ref2) == BIT_FIELD_REF)\n+\tcomponent_refs2.truncate (0);\n+      else\n+        component_refs2.safe_push (ref2);\n+      if (ref2 == match2)\n+\tbreak;\n       ref2 = TREE_OPERAND (ref2, 0);\n     }\n-  if (TREE_CODE (ref2) == MEM_REF)\n+  if (TREE_CODE (ref2) == MEM_REF && ref2 != match2)\n     {\n       if (!integer_zerop (TREE_OPERAND (ref2, 1)))\n \t{\n-\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t  return false;\n+\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  return -1;\n \t}\n-      ref2 = TREE_OPERAND (TREE_OPERAND (ref2, 0), 0);\n     }\n-\n-  /* Bases must be either same or uncomparable.  */\n-  gcc_checking_assert (ref1 == ref2\n-\t\t       || (DECL_P (ref1) && DECL_P (ref2)\n-\t\t\t   && compare_base_decls (ref1, ref2) != 0));\n+  if (TREE_CODE (ref2) == TARGET_MEM_REF && ref2 != match2)\n+    {\n+      ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+      return -1;\n+    }\n \n   /* Pop the stacks in parallel and examine the COMPONENT_REFs of the same\n      rank.  This is sufficient because we start from the same DECL and you\n@@ -1160,8 +1219,9 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n \t{\n \t  if (component_refs1.is_empty ())\n \t    {\n-\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t      return false;\n+\t      ++alias_stats\n+\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t      return 0;\n \t    }\n \t  ref1 = component_refs1.pop ();\n \t}\n@@ -1171,8 +1231,9 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n \t{\n \t  if (component_refs2.is_empty ())\n \t    {\n-\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t      return false;\n+\t      ++alias_stats\n+\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t      return 0;\n \t    }\n \t  ref2 = component_refs2.pop ();\n \t}\n@@ -1182,8 +1243,9 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n       if (TREE_CODE (ref1) != COMPONENT_REF\n \t  || TREE_CODE (ref2) != COMPONENT_REF)\n \t{\n-\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t  return false;\n+\t  ++alias_stats\n+\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  return -1;\n \t}\n \n       tree field1 = TREE_OPERAND (ref1, 1);\n@@ -1198,8 +1260,8 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n       /* We cannot disambiguate fields in a union or qualified union.  */\n       if (type1 != type2 || TREE_CODE (type1) != RECORD_TYPE)\n \t{\n-\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t  return false;\n+\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t  return -1;\n \t}\n \n       if (field1 != field2)\n@@ -1209,23 +1271,25 @@ nonoverlapping_component_refs_of_decl_p (tree ref1, tree ref2)\n \t  if (DECL_BIT_FIELD_REPRESENTATIVE (field1) == field2\n \t      || DECL_BIT_FIELD_REPRESENTATIVE (field2) == field1)\n \t    {\n-\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t      return false;\n+\t      ++alias_stats\n+\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t      return 0;\n \t    }\n \t  /* Different fields of the same record type cannot overlap.\n \t     ??? Bitfields can overlap at RTL level so punt on them.  */\n \t  if (DECL_BIT_FIELD (field1) && DECL_BIT_FIELD (field2))\n \t    {\n-\t      ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-\t      return false;\n+\t      ++alias_stats\n+\t\t.nonoverlapping_component_refs_since_match_p_may_alias;\n+\t      return 0;\n \t    }\n-\t  ++alias_stats.nonoverlapping_component_refs_of_decl_p_no_alias;\n-\t  return true;\n+\t  ++alias_stats.nonoverlapping_component_refs_since_match_p_no_alias;\n+\t  return 1;\n \t}\n     }\n \n-  ++alias_stats.nonoverlapping_component_refs_of_decl_p_may_alias;\n-  return false;\n+  ++alias_stats.nonoverlapping_component_refs_since_match_p_may_alias;\n+  return 0;\n }\n \n /* qsort compare function to sort FIELD_DECLs after their\n@@ -1246,7 +1310,7 @@ ncr_compar (const void *field1_, const void *field2_)\n }\n \n /* Return true if we can determine that the fields referenced cannot\n-   overlap for any pair of objects.  */\n+   overlap for any pair of objects.  This relies on TBAA.  */\n \n static bool\n nonoverlapping_component_refs_p (const_tree x, const_tree y)\n@@ -1408,7 +1472,8 @@ decl_refs_may_alias_p (tree ref1, tree base1,\n      so we disambiguate component references manually.  */\n   if (ref1 && ref2\n       && handled_component_p (ref1) && handled_component_p (ref2)\n-      && nonoverlapping_component_refs_of_decl_p (ref1, ref2))\n+      && nonoverlapping_component_refs_since_match_p (NULL, ref1,\n+\t\t\t\t\t\t      NULL, ref2) == 1)\n     return false;\n \n   return true;     \n@@ -1537,10 +1602,6 @@ indirect_ref_may_alias_decl_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n \t      && TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) == INTEGER_CST)))\n     return ranges_maybe_overlap_p (doffset1, max_size1, doffset2, max_size2);\n \n-  if (ref1 && ref2\n-      && nonoverlapping_component_refs_p (ref1, ref2))\n-    return false;\n-\n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n       && (handled_component_p (ref1) || handled_component_p (ref2)))\n@@ -1609,8 +1670,16 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n     {\n       poly_offset_int moff1 = mem_ref_offset (base1) << LOG2_BITS_PER_UNIT;\n       poly_offset_int moff2 = mem_ref_offset (base2) << LOG2_BITS_PER_UNIT;\n-      return ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n-\t\t\t\t     offset2 + moff2, max_size2);\n+      if (!ranges_maybe_overlap_p (offset1 + moff1, max_size1,\n+\t\t\t\t   offset2 + moff2, max_size2))\n+\treturn false;\n+      if (ref1 && ref2)\n+\t{\n+\t  int res = nonoverlapping_component_refs_since_match_p (NULL, ref1,\n+\t\t\t\t\t\t\t\t NULL, ref2);\n+\t  if (res != -1)\n+\t    return !res;\n+\t}\n     }\n   if (!ptr_derefs_may_alias_p (ptr1, ptr2))\n     return false;\n@@ -1652,10 +1721,6 @@ indirect_refs_may_alias_p (tree ref1 ATTRIBUTE_UNUSED, tree base1,\n       && TREE_CODE (TREE_TYPE (ptrtype1)) != ARRAY_TYPE)\n     return ranges_maybe_overlap_p (offset1, max_size1, offset2, max_size2);\n \n-  if (ref1 && ref2\n-      && nonoverlapping_component_refs_p (ref1, ref2))\n-    return false;\n-\n   /* Do access-path based disambiguation.  */\n   if (ref1 && ref2\n       && (handled_component_p (ref1) || handled_component_p (ref2)))"}]}