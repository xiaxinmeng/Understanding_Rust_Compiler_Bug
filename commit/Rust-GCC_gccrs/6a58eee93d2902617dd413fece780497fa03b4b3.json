{"sha": "6a58eee93d2902617dd413fece780497fa03b4b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE1OGVlZTkzZDI5MDI2MTdkZDQxM2ZlY2U3ODA0OTdmYTAzYjRiMw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-04-10T00:15:58Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-04-10T00:15:58Z"}, "message": "basic-block.h (flow_delete_block_noexpunge): Declare.\n\n\t* basic-block.h (flow_delete_block_noexpunge): Declare.\n\t(expunge_block_nocompact): Declare.\n\t* cfg.c (expunge_block_nocompact): Split out from ...\n\t(expunge_block): ... here.\n\t* cfgrtl.c (can_delete_label_p): Don't use exception_handler_labels.\n\t(flow_delete_block_noexpunge): Split out from ...\n\t(flow_delete_block): ... here.\n\t* cfgcleanup.c (delete_unreachable_blocks): Compact while\n\tremoving dead blocks.\n\t* except.c (exception_handler_labels): Remove.\n\t(exception_handler_label_map): New.\n\t(struct eh_region): Add aka member.\n\t(mark_ehl_map_entry, mark_ehl_map, free_region): New.\n\t(ehl_hash, ehl_eq, ehl_free, add_ehl_entry): New.\n\t(for_each_eh_label, for_each_eh_label_1): New.\n\t(init_eh): Register exception_handler_label_map.\n\t(free_eh_status): Use free_region.\n\t(find_exception_handler_labels): Use the map, not the list.\n\t(remove_exception_handler_label): Likewise.\n\t(maybe_remove_eh_handler): Likewise.\n\t(remove_eh_handler): Use the region aka bitmap.\n\t* except.h (exception_handler_labels): Remove.\n\t(for_each_eh_label): Declare.\n\t* jump.c (rebuild_jump_labels): Don't check exception_handler_labels.\n\t* loop.c (invalidate_loops_containing_label): New.\n\t(find_and_verify_loops): Use it.  Use for_each_eh_label.\n\t* sched-rgn.c (is_cfg_nonregular): Use\n\tcurrent_function_has_exception_handlers.\n\nFrom-SVN: r52100", "tree": {"sha": "3634a27519c3d4e86e699e40edd03e6636c09ae2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3634a27519c3d4e86e699e40edd03e6636c09ae2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a58eee93d2902617dd413fece780497fa03b4b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a58eee93d2902617dd413fece780497fa03b4b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a58eee93d2902617dd413fece780497fa03b4b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a58eee93d2902617dd413fece780497fa03b4b3/comments", "author": null, "committer": null, "parents": [{"sha": "4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fc4e47839a0dcb61bd3ba937e831a0212f468d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fc4e47839a0dcb61bd3ba937e831a0212f468d9"}], "stats": {"total": 393, "additions": 297, "deletions": 96}, "files": [{"sha": "8aa893630648226c0044ec11edf2a8292595612b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -1,3 +1,34 @@\n+2002-04-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* basic-block.h (flow_delete_block_noexpunge): Declare.\n+\t(expunge_block_nocompact): Declare.\n+\t* cfg.c (expunge_block_nocompact): Split out from ...\n+\t(expunge_block): ... here.\n+\t* cfgrtl.c (can_delete_label_p): Don't use exception_handler_labels.\n+\t(flow_delete_block_noexpunge): Split out from ...\n+\t(flow_delete_block): ... here.\n+\t* cfgcleanup.c (delete_unreachable_blocks): Compact while\n+\tremoving dead blocks.\n+\t* except.c (exception_handler_labels): Remove.\n+\t(exception_handler_label_map): New.\n+\t(struct eh_region): Add aka member.\n+\t(mark_ehl_map_entry, mark_ehl_map, free_region): New.\n+\t(ehl_hash, ehl_eq, ehl_free, add_ehl_entry): New.\n+\t(for_each_eh_label, for_each_eh_label_1): New.\n+\t(init_eh): Register exception_handler_label_map.\n+\t(free_eh_status): Use free_region.\n+\t(find_exception_handler_labels): Use the map, not the list.\n+\t(remove_exception_handler_label): Likewise.\n+\t(maybe_remove_eh_handler): Likewise.\n+\t(remove_eh_handler): Use the region aka bitmap.\n+\t* except.h (exception_handler_labels): Remove.\n+\t(for_each_eh_label): Declare.\n+\t* jump.c (rebuild_jump_labels): Don't check exception_handler_labels.\n+\t* loop.c (invalidate_loops_containing_label): New.\n+\t(find_and_verify_loops): Use it.  Use for_each_eh_label.\n+\t* sched-rgn.c (is_cfg_nonregular): Use\n+\tcurrent_function_has_exception_handlers.\n+\n 2002-04-09  Richard Henderson  <rth@redhat.com>\n \n \t* sbitmap.c (sbitmap_union_of_diff, sbitmap_a_and_b, sbitmap_a_xor_b,"}, {"sha": "24d2af83575e14cc64c8dff8c280b13434745ec0", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -1,5 +1,5 @@\n /* Define control and data flow tables, and regsets.\n-   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1987, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -316,6 +316,7 @@ extern void redirect_edge_pred\t\tPARAMS ((edge, basic_block));\n extern basic_block create_basic_block_structure PARAMS ((int, rtx, rtx, rtx));\n extern basic_block create_basic_block\tPARAMS ((int, rtx, rtx));\n extern int flow_delete_block\t\tPARAMS ((basic_block));\n+extern int flow_delete_block_noexpunge\tPARAMS ((basic_block));\n extern void clear_bb_flags\t\tPARAMS ((void));\n extern void merge_blocks_nomove\t\tPARAMS ((basic_block, basic_block));\n extern void tidy_fallthru_edge\t\tPARAMS ((edge, basic_block,\n@@ -637,6 +638,7 @@ extern void debug_regset\t\tPARAMS ((regset));\n extern void allocate_reg_life_data      PARAMS ((void));\n extern void allocate_bb_life_data\tPARAMS ((void));\n extern void expunge_block\t\tPARAMS ((basic_block));\n+extern void expunge_block_nocompact\tPARAMS ((basic_block));\n extern basic_block alloc_block\t\tPARAMS ((void));\n extern void find_unreachable_blocks\tPARAMS ((void));\n extern int delete_noop_moves\t\tPARAMS ((rtx));"}, {"sha": "766c1b8ff3d7569655f325df80fd8e2e6b13ac11", "filename": "gcc/cfg.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -222,6 +222,17 @@ alloc_block ()\n \n /* Remove block B from the basic block array and compact behind it.  */\n \n+void\n+expunge_block_nocompact (b)\n+     basic_block b;\n+{\n+  /* Invalidate data to make bughunting easier.  */\n+  memset (b, 0, sizeof *b);\n+  b->index = -3;\n+  b->succ = (edge) first_deleted_block;\n+  first_deleted_block = (basic_block) b;\n+}\n+\n void\n expunge_block (b)\n      basic_block b;\n@@ -235,13 +246,10 @@ expunge_block (b)\n       x->index = i;\n     }\n \n-  /* Invalidate data to make bughunting easier.  */\n-  memset (b, 0, sizeof *b);\n-  b->index = -3;\n-  basic_block_info->num_elements--;\n   n_basic_blocks--;\n-  b->succ = (edge) first_deleted_block;\n-  first_deleted_block = (basic_block) b;\n+  basic_block_info->num_elements--;\n+\n+  expunge_block_nocompact (b);\n }\n \f\n /* Create an edge connecting SRC and DST with FLAGS optionally using"}, {"sha": "74a2256b5e2971b85e3c6c2eee6ad1555d4d2538", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -1,6 +1,6 @@\n /* Control flow optimization code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -1751,22 +1751,33 @@ try_optimize_cfg (mode)\n static bool\n delete_unreachable_blocks ()\n {\n-  int i;\n+  int i, j;\n   bool changed = false;\n \n   find_unreachable_blocks ();\n \n-  /* Delete all unreachable basic blocks.  Count down so that we\n-     don't interfere with the block renumbering that happens in\n-     flow_delete_block.  */\n+  /* Delete all unreachable basic blocks.  Do compaction concurrently,\n+     as otherwise we can wind up with O(N^2) behaviour here when we \n+     have oodles of dead code.  */\n \n-  for (i = n_basic_blocks - 1; i >= 0; --i)\n+  for (i = j = 0; i < n_basic_blocks; ++i)\n     {\n       basic_block b = BASIC_BLOCK (i);\n \n       if (!(b->flags & BB_REACHABLE))\n-\tflow_delete_block (b), changed = true;\n+\t{\n+\t  flow_delete_block_noexpunge (b);\n+\t  expunge_block_nocompact (b);\n+\t  changed = true;\n+\t}\n+      else\n+\t{\n+\t  BASIC_BLOCK (j) = b;\n+\t  b->index = j++;\n+\t}\n     }\n+  n_basic_blocks = j;\n+  basic_block_info->num_elements = j;\n \n   if (changed)\n     tidy_fallthru_edges ();"}, {"sha": "a56eea2e9400f6e94056ae5d5efcdd733abcae7d", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -1,6 +1,6 @@\n /* Control flow graph manipulation code for GNU compiler.\n    Copyright (C) 1987, 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-   1999, 2000, 2001 Free Software Foundation, Inc.\n+   1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -102,8 +102,7 @@ can_delete_label_p (label)\n \t  /* User declared labels must be preserved.  */\n \t  && LABEL_NAME (label) == 0\n \t  && !in_expr_list_p (forced_labels, label)\n-\t  && !in_expr_list_p (label_value_list, label)\n-\t  && !in_expr_list_p (exception_handler_labels, label));\n+\t  && !in_expr_list_p (label_value_list, label));\n }\n \n /* Delete INSN by patching it out.  Return the next insn.  */\n@@ -363,7 +362,7 @@ create_basic_block (index, head, end)\n    to post-process the stream to remove empty blocks, loops, ranges, etc.  */\n \n int\n-flow_delete_block (b)\n+flow_delete_block_noexpunge (b)\n      basic_block b;\n {\n   int deleted_handler = 0;\n@@ -412,6 +411,15 @@ flow_delete_block (b)\n   b->pred = NULL;\n   b->succ = NULL;\n \n+  return deleted_handler;\n+}\n+\n+int\n+flow_delete_block (b)\n+     basic_block b;\n+{\n+  int deleted_handler = flow_delete_block_noexpunge (b);\n+  \n   /* Remove the basic block from the array, and compact behind it.  */\n   expunge_block (b);\n "}, {"sha": "d4a903e597c5c9de678b722d80a51e5bbca89169", "filename": "gcc/except.c", "status": "modified", "additions": 199, "deletions": 49, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -98,8 +98,15 @@ int (*lang_eh_type_covers) PARAMS ((tree a, tree b));\n /* Map a type to a runtime object to match type.  */\n tree (*lang_eh_runtime_type) PARAMS ((tree));\n \n-/* A list of labels used for exception handlers.  */\n-rtx exception_handler_labels;\n+/* A hash table of label to region number.  */\n+\n+struct ehl_map_entry\n+{\n+  rtx label;\n+  struct eh_region *region;\n+};\n+\n+static htab_t exception_handler_label_map;\n \n static int call_site_base;\n static unsigned int sjlj_funcdef_number;\n@@ -126,6 +133,10 @@ struct eh_region\n   /* An identifier for this region.  */\n   int region_number;\n \n+  /* When a region is deleted, its parents inherit the REG_EH_REGION\n+     numbers already assigned.  */\n+  bitmap aka;\n+\n   /* Each region does exactly one thing.  */\n   enum eh_region_type\n   {\n@@ -242,6 +253,10 @@ struct eh_status\n \n \f\n static void mark_eh_region\t\t\tPARAMS ((struct eh_region *));\n+static int mark_ehl_map_entry\t\t\tPARAMS ((PTR *, PTR));\n+static void mark_ehl_map\t\t\tPARAMS ((void *));\n+\n+static void free_region\t\t\t\tPARAMS ((struct eh_region *));\n \n static int t2r_eq\t\t\t\tPARAMS ((const PTR,\n \t\t\t\t\t\t\t const PTR));\n@@ -292,8 +307,15 @@ static void sjlj_emit_dispatch_table\n      PARAMS ((rtx, struct sjlj_lp_info *));\n static void sjlj_build_landing_pads\t\tPARAMS ((void));\n \n+static hashval_t ehl_hash\t\t\tPARAMS ((const PTR));\n+static int ehl_eq\t\t\t\tPARAMS ((const PTR,\n+\t\t\t\t\t\t\t const PTR));\n+static void ehl_free\t\t\t\tPARAMS ((PTR));\n+static void add_ehl_entry\t\t\tPARAMS ((rtx,\n+\t\t\t\t\t\t\t struct eh_region *));\n static void remove_exception_handler_label\tPARAMS ((rtx));\n static void remove_eh_handler\t\t\tPARAMS ((struct eh_region *));\n+static int for_each_eh_label_1\t\t\tPARAMS ((PTR *, PTR));\n \n struct reachable_info;\n \n@@ -364,7 +386,7 @@ doing_eh (do_warn)\n void\n init_eh ()\n {\n-  ggc_add_rtx_root (&exception_handler_labels, 1);\n+  ggc_add_root (&exception_handler_label_map, 1, 1, mark_ehl_map);\n \n   if (! flag_exceptions)\n     return;\n@@ -511,6 +533,25 @@ mark_eh_region (region)\n   ggc_mark_rtx (region->post_landing_pad);\n }\n \n+static int\n+mark_ehl_map_entry (pentry, data)\n+     PTR *pentry;\n+     PTR data ATTRIBUTE_UNUSED;\n+{\n+  struct ehl_map_entry *entry = *(struct ehl_map_entry **) pentry;\n+  ggc_mark_rtx (entry->label);\n+  return 1;\n+}\n+\n+static void\n+mark_ehl_map (pp)\n+    void *pp;\n+{\n+  htab_t map = *(htab_t *) pp;\n+  if (map)\n+    htab_traverse (map, mark_ehl_map_entry, NULL);\n+}\n+\n void\n mark_eh_status (eh)\n      struct eh_status *eh;\n@@ -572,6 +613,16 @@ mark_eh_status (eh)\n   ggc_mark_rtx (eh->sjlj_exit_after);\n }\n \n+static inline void\n+free_region (r)\n+     struct eh_region *r;\n+{\n+  /* Note that the aka bitmap is freed by regset_release_memory.  But if\n+     we ever replace with a non-obstack implementation, this would be\n+     the place to do it.  */\n+  free (r);\n+}\n+\n void\n free_eh_status (f)\n      struct function *f;\n@@ -586,7 +637,7 @@ free_eh_status (f)\n \t  struct eh_region *r = eh->region_array[i];\n \t  /* Mind we don't free a region struct more than once.  */\n \t  if (r && r->region_number == i)\n-\t    free (r);\n+\t    free_region (r);\n \t}\n       free (eh->region_array);\n     }\n@@ -600,20 +651,20 @@ free_eh_status (f)\n \t  else if (r->next_peer)\n \t    {\n \t      next = r->next_peer;\n-\t      free (r);\n+\t      free_region (r);\n \t      r = next;\n \t    }\n \t  else\n \t    {\n \t      do {\n \t        next = r->outer;\n-\t        free (r);\n+\t        free_region (r);\n \t        r = next;\n \t\tif (r == NULL)\n \t\t  goto tree_done;\n \t      } while (r->next_peer == NULL);\n \t      next = r->next_peer;\n-\t      free (r);\n+\t      free_region (r);\n \t      r = next;\n \t    }\n \t}\n@@ -628,7 +679,12 @@ free_eh_status (f)\n \n   free (eh);\n   f->eh = NULL;\n-  exception_handler_labels = NULL;\n+\n+  if (exception_handler_label_map)\n+    {\n+      htab_delete (exception_handler_label_map);\n+      exception_handler_label_map = NULL;\n+    }\n }\n \n \f\n@@ -1312,13 +1368,50 @@ convert_from_eh_region_ranges ()\n   remove_unreachable_regions (insns);\n }\n \n+static void\n+add_ehl_entry (label, region)\n+     rtx label;\n+     struct eh_region *region;\n+{\n+  struct ehl_map_entry **slot, *entry;\n+\n+  LABEL_PRESERVE_P (label) = 1;\n+\n+  entry = (struct ehl_map_entry *) xmalloc (sizeof (*entry));\n+  entry->label = label;\n+  entry->region = region;\n+\n+  slot = (struct ehl_map_entry **)\n+    htab_find_slot (exception_handler_label_map, entry, INSERT);\n+  if (*slot)\n+    abort ();\n+  *slot = entry;\n+}\n+\n+static void\n+ehl_free (pentry)\n+     PTR pentry;\n+{\n+  struct ehl_map_entry *entry = (struct ehl_map_entry *)pentry;\n+  LABEL_PRESERVE_P (entry->label) = 0;\n+  free (entry);\n+}\n+\n void\n find_exception_handler_labels ()\n {\n-  rtx list = NULL_RTX;\n   int i;\n \n-  free_EXPR_LIST_list (&exception_handler_labels);\n+  if (exception_handler_label_map)\n+    htab_empty (exception_handler_label_map);\n+  else\n+    {\n+      /* ??? The expansion factor here (3/2) must be greater than the htab\n+\t occupancy factor (4/3) to avoid unnecessary resizing.  */\n+      exception_handler_label_map\n+        = htab_create (cfun->eh->last_region_number * 3 / 2,\n+\t\t       ehl_hash, ehl_eq, ehl_free);\n+    }\n \n   if (cfun->eh->region_tree == NULL)\n     return;\n@@ -1336,15 +1429,13 @@ find_exception_handler_labels ()\n \tlab = region->label;\n \n       if (lab)\n-\tlist = alloc_EXPR_LIST (0, lab, list);\n+\tadd_ehl_entry (lab, region);\n     }\n \n   /* For sjlj exceptions, need the return label to remain live until\n      after landing pad generation.  */\n   if (USING_SJLJ_EXCEPTIONS && ! cfun->eh->built_landing_pads)\n-    list = alloc_EXPR_LIST (0, return_label, list);\n-\n-  exception_handler_labels = list;\n+    add_ehl_entry (return_label, NULL);\n }\n \n bool\n@@ -2430,28 +2521,50 @@ finish_eh_generation ()\n   cleanup_cfg (CLEANUP_PRE_LOOP);\n }\n \f\n+static hashval_t\n+ehl_hash (pentry)\n+     const PTR pentry;\n+{\n+  struct ehl_map_entry *entry = (struct ehl_map_entry *) pentry;\n+\n+  /* 2^32 * ((sqrt(5) - 1) / 2) */\n+  const hashval_t scaled_golden_ratio = 0x9e3779b9;\n+  return CODE_LABEL_NUMBER (entry->label) * scaled_golden_ratio;\n+}\n+\n+static int\n+ehl_eq (pentry, pdata)\n+     const PTR pentry;\n+     const PTR pdata;\n+{\n+  struct ehl_map_entry *entry = (struct ehl_map_entry *) pentry;\n+  struct ehl_map_entry *data = (struct ehl_map_entry *) pdata;\n+\n+  return entry->label == data->label;\n+}\n+\n /* This section handles removing dead code for flow.  */\n \n-/* Remove LABEL from the exception_handler_labels list.  */\n+/* Remove LABEL from exception_handler_label_map.  */\n \n static void\n remove_exception_handler_label (label)\n      rtx label;\n {\n-  rtx *pl, l;\n+  struct ehl_map_entry **slot, tmp;\n \n-  /* If exception_handler_labels was not built yet,\n+  /* If exception_handler_label_map was not built yet,\n      there is nothing to do.  */\n-  if (exception_handler_labels == NULL)\n+  if (exception_handler_label_map == NULL)\n     return;\n \n-  for (pl = &exception_handler_labels, l = *pl;\n-       XEXP (l, 0) != label;\n-       pl = &XEXP (l, 1), l = *pl)\n-    continue;\n+  tmp.label = label;\n+  slot = (struct ehl_map_entry **)\n+    htab_find_slot (exception_handler_label_map, &tmp, NO_INSERT);\n+  if (! slot)\n+    abort ();\n \n-  *pl = XEXP (l, 1);\n-  free_EXPR_LIST_node (l);\n+  htab_clear_slot (exception_handler_label_map, (void **) slot);\n }\n \n /* Splice REGION from the region tree etc.  */\n@@ -2462,16 +2575,29 @@ remove_eh_handler (region)\n {\n   struct eh_region **pp, *p;\n   rtx lab;\n-  int i;\n \n   /* For the benefit of efficiently handling REG_EH_REGION notes,\n      replace this region in the region array with its containing\n      region.  Note that previous region deletions may result in\n-     multiple copies of this region in the array, so we have to\n-     search the whole thing.  */\n-  for (i = cfun->eh->last_region_number; i > 0; --i)\n-    if (cfun->eh->region_array[i] == region)\n-      cfun->eh->region_array[i] = region->outer;\n+     multiple copies of this region in the array, so we have a\n+     list of alternate numbers by which we are known.  */\n+\n+  cfun->eh->region_array[region->region_number] = region->outer;\n+  if (region->aka)\n+    {\n+      int i;\n+      EXECUTE_IF_SET_IN_BITMAP (region->aka, 0, i,\n+\t{ cfun->eh->region_array[i] = region->outer; });\n+    }\n+\n+  if (region->outer)\n+    {\n+      if (!region->outer->aka)\n+        region->outer->aka = BITMAP_XMALLOC ();\n+      if (region->aka)\n+\tbitmap_a_or_b (region->outer->aka, region->outer->aka, region->aka);\n+      bitmap_set_bit (region->outer->aka, region->region_number);\n+    }\n \n   if (cfun->eh->built_landing_pads)\n     lab = region->landing_pad;\n@@ -2526,7 +2652,7 @@ remove_eh_handler (region)\n \t}\n     }\n \n-  free (region);\n+  free_region (region);\n }\n \n /* LABEL heads a basic block that is about to be deleted.  If this\n@@ -2537,7 +2663,8 @@ void\n maybe_remove_eh_handler (label)\n      rtx label;\n {\n-  int i;\n+  struct ehl_map_entry **slot, tmp;\n+  struct eh_region *region;\n \n   /* ??? After generating landing pads, it's not so simple to determine\n      if the region data is completely unused.  One must examine the\n@@ -2546,27 +2673,50 @@ maybe_remove_eh_handler (label)\n   if (cfun->eh->built_landing_pads)\n     return;\n \n-  for (i = cfun->eh->last_region_number; i > 0; --i)\n+  tmp.label = label;\n+  slot = (struct ehl_map_entry **)\n+    htab_find_slot (exception_handler_label_map, &tmp, NO_INSERT);\n+  if (! slot)\n+    return;\n+  region = (*slot)->region;\n+  if (! region)\n+    return;\n+\n+  /* Flow will want to remove MUST_NOT_THROW regions as unreachable\n+     because there is no path to the fallback call to terminate.\n+     But the region continues to affect call-site data until there\n+     are no more contained calls, which we don't see here.  */\n+  if (region->type == ERT_MUST_NOT_THROW)\n     {\n-      struct eh_region *region = cfun->eh->region_array[i];\n-      if (region && region->label == label)\n-\t{\n-\t  /* Flow will want to remove MUST_NOT_THROW regions as unreachable\n-\t     because there is no path to the fallback call to terminate.\n-\t     But the region continues to affect call-site data until there\n-\t     are no more contained calls, which we don't see here.  */\n-\t  if (region->type == ERT_MUST_NOT_THROW)\n-\t    {\n-\t      remove_exception_handler_label (region->label);\n-\t      region->label = NULL_RTX;\n-\t    }\n-\t  else\n-\t    remove_eh_handler (region);\n-\t  break;\n-\t}\n+      htab_clear_slot (exception_handler_label_map, (void **) slot);\n+      region->label = NULL_RTX;\n     }\n+  else\n+    remove_eh_handler (region);\n+}\n+\n+/* Invokes CALLBACK for every exception handler label.  Only used by old\n+   loop hackery; should not be used by new code.  */\n+\n+void\n+for_each_eh_label (callback)\n+     void (*callback) PARAMS ((rtx));\n+{\n+  htab_traverse (exception_handler_label_map, for_each_eh_label_1,\n+\t\t (void *)callback);\n }\n \n+static int\n+for_each_eh_label_1 (pentry, data)\n+     PTR *pentry;\n+     PTR data;\n+{\n+  struct ehl_map_entry *entry = *(struct ehl_map_entry **)pentry;\n+  void (*callback) PARAMS ((rtx)) = (void (*) PARAMS ((rtx))) data;\n+\n+  (*callback) (entry->label);\n+  return 1;\n+}\n \f\n /* This section describes CFG exception edges for flow.  */\n "}, {"sha": "ce91051d5b1637ab551b14a5627092b91794d171", "filename": "gcc/except.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -1,5 +1,5 @@\n /* Exception Handling interface routines.\n-   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001\n+   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002\n    Free Software Foundation, Inc.\n    Contributed by Mike Stump <mrs@cygnus.com>.\n \n@@ -83,8 +83,9 @@ extern void expand_eh_region_end_throw\t\tPARAMS ((tree));\n    destroying an object twice.  */\n extern void expand_eh_region_end_fixup\t\tPARAMS ((tree));\n \n-/* A list of labels used for exception handlers.  */\n-extern rtx exception_handler_labels;\n+/* Invokes CALLBACK for every exception handler label.  Only used by old\n+   loop hackery; should not be used by new code.  */\n+extern void for_each_eh_label\t\t\tPARAMS ((void (*) (rtx)));\n \n /* Determine if the given INSN can throw an exception.  */\n extern bool can_throw_internal\t\t\tPARAMS ((rtx));"}, {"sha": "f32b831c6dfb1c22dca59559bd19f4c625e20762", "filename": "gcc/jump.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -91,13 +91,6 @@ rebuild_jump_labels (f)\n   for (insn = forced_labels; insn; insn = XEXP (insn, 1))\n     if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n       LABEL_NUSES (XEXP (insn, 0))++;\n-\n-  /* Keep track of labels used for marking handlers for exception\n-     regions; they cannot usually be deleted.  */\n-\n-  for (insn = exception_handler_labels; insn; insn = XEXP (insn, 1))\n-    if (GET_CODE (XEXP (insn, 0)) == CODE_LABEL)\n-      LABEL_NUSES (XEXP (insn, 0))++;\n }\n \f\n /* Some old code expects exactly one BARRIER as the NEXT_INSN of a"}, {"sha": "53b9caa3aa06b38319ed33236f3fc6435dca7175", "filename": "gcc/loop.c", "status": "modified", "additions": 15, "deletions": 18, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -235,6 +235,7 @@ FILE *loop_dump_stream;\n \n /* Forward declarations.  */\n \n+static void invalidate_loops_containing_label PARAMS ((rtx));\n static void find_and_verify_loops PARAMS ((rtx, struct loops *));\n static void mark_loop_jump PARAMS ((rtx, struct loop *));\n static void prescan_loop PARAMS ((struct loop *));\n@@ -2609,6 +2610,17 @@ prescan_loop (loop)\n     }\n }\n \f\n+/* Invalidate all loops containing LABEL.  */\n+\n+static void\n+invalidate_loops_containing_label (label)\n+     rtx label;\n+{\n+  struct loop *loop;\n+  for (loop = uid_loop[INSN_UID (label)]; loop; loop = loop->outer)\n+    loop->invalid = 1;\n+}\n+\n /* Scan the function looking for loops.  Record the start and end of each loop.\n    Also mark as invalid loops any loops that contain a setjmp or are branched\n    to from outside the loop.  */\n@@ -2695,23 +2707,12 @@ find_and_verify_loops (f, loops)\n \n   /* Any loop containing a label used in an initializer must be invalidated,\n      because it can be jumped into from anywhere.  */\n-\n   for (label = forced_labels; label; label = XEXP (label, 1))\n-    {\n-      for (loop = uid_loop[INSN_UID (XEXP (label, 0))];\n-\t   loop; loop = loop->outer)\n-\tloop->invalid = 1;\n-    }\n+    invalidate_loops_containing_label (XEXP (label, 0));\n \n   /* Any loop containing a label used for an exception handler must be\n      invalidated, because it can be jumped into from anywhere.  */\n-\n-  for (label = exception_handler_labels; label; label = XEXP (label, 1))\n-    {\n-      for (loop = uid_loop[INSN_UID (XEXP (label, 0))];\n-\t   loop; loop = loop->outer)\n-\tloop->invalid = 1;\n-    }\n+  for_each_eh_label (invalidate_loops_containing_label);\n \n   /* Now scan all insn's in the function.  If any JUMP_INSN branches into a\n      loop that it is not contained within, that loop is marked invalid.\n@@ -2735,11 +2736,7 @@ find_and_verify_loops (f, loops)\n \t  {\n \t    rtx note = find_reg_note (insn, REG_LABEL, NULL_RTX);\n \t    if (note)\n-\t      {\n-\t\tfor (loop = uid_loop[INSN_UID (XEXP (note, 0))];\n-\t\t     loop; loop = loop->outer)\n-\t\t  loop->invalid = 1;\n-\t      }\n+\t      invalidate_loops_containing_label (XEXP (note, 0));\n \t  }\n \n \tif (GET_CODE (insn) != JUMP_INSN)"}, {"sha": "ab65e2cec5e04b8c3c664e7334deb94441f2ac57", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a58eee93d2902617dd413fece780497fa03b4b3/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=6a58eee93d2902617dd413fece780497fa03b4b3", "patch": "@@ -339,7 +339,7 @@ is_cfg_nonregular ()\n   /* If we have exception handlers, then we consider the cfg not well\n      structured.  ?!?  We should be able to handle this now that flow.c\n      computes an accurate cfg for EH.  */\n-  if (exception_handler_labels)\n+  if (current_function_has_exception_handlers ())\n     return 1;\n \n   /* If we have non-jumping insns which refer to labels, then we consider"}]}