{"sha": "9858cd1a6827ee7a928318acb5e86389f79b4012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTg1OGNkMWE2ODI3ZWU3YTkyODMxOGFjYjVlODYzODlmNzliNDAxMg==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-07T17:18:55Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-06-07T21:31:01Z"}, "message": "Implement a sparse bitmap representation for Rangers on-entry cache.\n\nUse a sparse representation for the on entry cache, and utilize it when\nthe number of basic blocks in the function exceeds param_evrp_sparse_threshold.\n\n\tPR tree-optimization/PR100299\n\t* gimple-range-cache.cc (class sbr_sparse_bitmap): New.\n\t(sbr_sparse_bitmap::sbr_sparse_bitmap): New.\n\t(sbr_sparse_bitmap::bitmap_set_quad): New.\n\t(sbr_sparse_bitmap::bitmap_get_quad): New.\n\t(sbr_sparse_bitmap::set_bb_range): New.\n\t(sbr_sparse_bitmap::get_bb_range): New.\n\t(sbr_sparse_bitmap::bb_range_p): New.\n\t(block_range_cache::block_range_cache): initialize bitmap obstack.\n\t(block_range_cache::~block_range_cache): Destruct obstack.\n\t(block_range_cache::set_bb_range): Decide when to utilze the\n\tsparse on entry cache.\n\t* gimple-range-cache.h (block_range_cache): Add bitmap obstack.\n\t* params.opt (-param=evrp-sparse-threshold): New.", "tree": {"sha": "25e179d4dd5e22ee1d570f29325f836fc53f39ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25e179d4dd5e22ee1d570f29325f836fc53f39ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9858cd1a6827ee7a928318acb5e86389f79b4012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9858cd1a6827ee7a928318acb5e86389f79b4012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9858cd1a6827ee7a928318acb5e86389f79b4012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9858cd1a6827ee7a928318acb5e86389f79b4012/comments", "author": null, "committer": null, "parents": [{"sha": "5ad089a3c946aec655436fa3b0b50d6574b78197", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ad089a3c946aec655436fa3b0b50d6574b78197", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ad089a3c946aec655436fa3b0b50d6574b78197"}], "stats": {"total": 152, "additions": 149, "deletions": 3}, "files": [{"sha": "249515fbaf5bad29f1e5fd0c457b1fe1b48781a8", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 144, "deletions": 3, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=9858cd1a6827ee7a928318acb5e86389f79b4012", "patch": "@@ -235,12 +235,140 @@ sbr_vector::bb_range_p (const basic_block bb)\n   return m_tab[bb->index] != NULL;\n }\n \n+// This class implements the on entry cache via a sparse bitmap.\n+// It uses the quad bit routines to access 4 bits at a time.\n+// A value of 0 (the default) means there is no entry, and a value of\n+// 1 thru SBR_NUM represents an element in the m_range vector.\n+// Varying is given the first value (1) and pre-cached.\n+// SBR_NUM + 1 represents the value of UNDEFINED, and is never stored.\n+// SBR_NUM is the number of values that can be cached.\n+// Indexes are 1..SBR_NUM and are stored locally at m_range[0..SBR_NUM-1]\n+\n+#define SBR_NUM\t\t14\n+#define SBR_UNDEF\tSBR_NUM + 1\n+#define SBR_VARYING\t1\n+\n+class sbr_sparse_bitmap : public ssa_block_ranges\n+{\n+public:\n+  sbr_sparse_bitmap (tree t, irange_allocator *allocator, bitmap_obstack *bm);\n+  virtual void set_bb_range (const basic_block bb, const irange &r) OVERRIDE;\n+  virtual bool get_bb_range (irange &r, const basic_block bb) OVERRIDE;\n+  virtual bool bb_range_p (const basic_block bb) OVERRIDE;\n+private:\n+  void bitmap_set_quad (bitmap head, int quad, int quad_value);\n+  int bitmap_get_quad (const_bitmap head, int quad);\n+  irange_allocator *m_irange_allocator;\n+  irange *m_range[SBR_NUM];\n+  bitmap bitvec;\n+  tree m_type;\n+};\n+\n+// Initialize a block cache for an ssa_name of type T.\n+\n+sbr_sparse_bitmap::sbr_sparse_bitmap (tree t, irange_allocator *allocator,\n+\t\t\t\tbitmap_obstack *bm)\n+{\n+  gcc_checking_assert (TYPE_P (t));\n+  m_type = t;\n+  bitvec = BITMAP_ALLOC (bm);\n+  m_irange_allocator = allocator;\n+  // Pre-cache varying.\n+  m_range[0] = m_irange_allocator->allocate (2);\n+  m_range[0]->set_varying (t);\n+  // Pre-cache zero and non-zero values for pointers.\n+  if (POINTER_TYPE_P (t))\n+    {\n+      m_range[1] = m_irange_allocator->allocate (2);\n+      m_range[1]->set_nonzero (t);\n+      m_range[2] = m_irange_allocator->allocate (2);\n+      m_range[2]->set_zero (t);\n+    }\n+  else\n+    m_range[1] = m_range[2] = NULL;\n+  // Clear SBR_NUM entries.\n+  for (int x = 3; x < SBR_NUM; x++)\n+    m_range[x] = 0;\n+}\n+\n+// Set 4 bit values in a sparse bitmap. This allows a bitmap to\n+// function as a sparse array of 4 bit values.\n+// QUAD is the index, QUAD_VALUE is the 4 bit value to set.\n+\n+inline void\n+sbr_sparse_bitmap::bitmap_set_quad (bitmap head, int quad, int quad_value)\n+{\n+  bitmap_set_aligned_chunk (head, quad, 4, (BITMAP_WORD) quad_value);\n+}\n+\n+// Get a 4 bit value from a sparse bitmap. This allows a bitmap to\n+// function as a sparse array of 4 bit values.\n+// QUAD is the index.\n+inline int\n+sbr_sparse_bitmap::bitmap_get_quad (const_bitmap head, int quad)\n+{\n+  return (int) bitmap_get_aligned_chunk (head, quad, 4);\n+}\n+\n+// Set the range on entry to basic block BB to R.\n+\n+void\n+sbr_sparse_bitmap::set_bb_range (const basic_block bb, const irange &r)\n+{\n+  if (r.undefined_p ())\n+    {\n+      bitmap_set_quad (bitvec, bb->index, SBR_UNDEF);\n+      return;\n+    }\n+\n+  // Loop thru the values to see if R is already present.\n+  for (int x = 0; x < SBR_NUM; x++)\n+    if (!m_range[x] || r == *(m_range[x]))\n+      {\n+\tif (!m_range[x])\n+\t  m_range[x] = m_irange_allocator->allocate (r);\n+\tbitmap_set_quad (bitvec, bb->index, x + 1);\n+\treturn;\n+      }\n+  // All values are taken, default to VARYING.\n+  bitmap_set_quad (bitvec, bb->index, SBR_VARYING);\n+  return;\n+}\n+\n+// Return the range associated with block BB in R.  Return false if\n+// there is no range.\n+\n+bool\n+sbr_sparse_bitmap::get_bb_range (irange &r, const basic_block bb)\n+{\n+  int value = bitmap_get_quad (bitvec, bb->index);\n+\n+  if (!value)\n+    return false;\n+\n+  gcc_checking_assert (value <= SBR_UNDEF);\n+  if (value == SBR_UNDEF)\n+    r.set_undefined ();\n+  else\n+    r = *(m_range[value - 1]);\n+  return true;\n+}\n+\n+// Return true if a range is present.\n+\n+bool\n+sbr_sparse_bitmap::bb_range_p (const basic_block bb)\n+{\n+  return (bitmap_get_quad (bitvec, bb->index) != 0);\n+}\n+\n // -------------------------------------------------------------------------\n \n // Initialize the block cache.\n \n block_range_cache::block_range_cache ()\n {\n+  bitmap_obstack_initialize (&m_bitmaps);\n   m_ssa_ranges.create (0);\n   m_ssa_ranges.safe_grow_cleared (num_ssa_names);\n   m_irange_allocator = new irange_allocator;\n@@ -253,6 +381,7 @@ block_range_cache::~block_range_cache ()\n   delete m_irange_allocator;\n   // Release the vector itself.\n   m_ssa_ranges.release ();\n+  bitmap_obstack_release (&m_bitmaps);\n }\n \n // Set the range for NAME on entry to block BB to R.\n@@ -268,9 +397,21 @@ block_range_cache::set_bb_range (tree name, const basic_block bb,\n \n   if (!m_ssa_ranges[v])\n     {\n-      void *r = m_irange_allocator->get_memory (sizeof (sbr_vector));\n-      m_ssa_ranges[v] = new (r) sbr_vector (TREE_TYPE (name),\n-\t\t\t\t\t    m_irange_allocator);\n+      // Use sparse representation if there are too many basic blocks.\n+      if (last_basic_block_for_fn (cfun) > param_evrp_sparse_threshold)\n+\t{\n+\t  void *r = m_irange_allocator->get_memory (sizeof (sbr_sparse_bitmap));\n+\t  m_ssa_ranges[v] = new (r) sbr_sparse_bitmap (TREE_TYPE (name),\n+\t\t\t\t\t\t       m_irange_allocator,\n+\t\t\t\t\t\t       &m_bitmaps);\n+\t}\n+      else\n+\t{\n+\t  // Otherwise use the default vector implemntation.\n+\t  void *r = m_irange_allocator->get_memory (sizeof (sbr_vector));\n+\t  m_ssa_ranges[v] = new (r) sbr_vector (TREE_TYPE (name),\n+\t\t\t\t\t\tm_irange_allocator);\n+\t}\n     }\n   m_ssa_ranges[v]->set_bb_range (bb, r);\n }"}, {"sha": "ce4449a08db1f746d93c3fcba4d127da53d1f033", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=9858cd1a6827ee7a928318acb5e86389f79b4012", "patch": "@@ -61,6 +61,7 @@ class block_range_cache\n   ssa_block_ranges &get_block_ranges (tree name);\n   ssa_block_ranges *query_block_ranges (tree name);\n   irange_allocator *m_irange_allocator;\n+  bitmap_obstack m_bitmaps;\n };\n \n // This global cache is used with the range engine as markers for what"}, {"sha": "18e6036c4f425eaceb8da8d3dee4e91d0e4452c2", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9858cd1a6827ee7a928318acb5e86389f79b4012/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=9858cd1a6827ee7a928318acb5e86389f79b4012", "patch": "@@ -126,6 +126,10 @@ Maximum size (in bytes) of objects tracked bytewise by dead store elimination.\n Common Joined UInteger Var(param_early_inlining_insns) Init(6) Optimization Param\n Maximal estimated growth of function body caused by early inlining of single call.\n \n+-param=evrp-sparse-threshold=\n+Common Joined UInteger Var(param_evrp_sparse_threshold) Init(800) Optimization Param\n+Maximum number of basic blocks before EVRP uses a sparse cache.\n+\n -param=evrp-mode=\n Common Joined Var(param_evrp_mode) Enum(evrp_mode) Init(EVRP_MODE_EVRP_FIRST) Param Optimization\n --param=evrp-mode=[legacy|ranger|legacy-first|ranger-first|ranger-trace|ranger-debug|trace|debug] Specifies the mode Early VRP should operate in."}]}