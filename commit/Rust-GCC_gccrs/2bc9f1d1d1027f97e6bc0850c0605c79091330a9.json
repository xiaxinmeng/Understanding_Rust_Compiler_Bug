{"sha": "2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJjOWYxZDFkMTAyN2Y5N2U2YmMwODUwYzA2MDVjNzkwOTEzMzBhOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-05-15T01:31:45Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-05-15T01:31:45Z"}, "message": "except.c (check_handlers): New fn.\n\n        * except.c (check_handlers): New fn.\n        * cp-tree.h: Declare it.\n        * semantics.c (finish_handler_sequence): Call it.\n        (finish_function_handler_sequence): Likewise.\n        (finish_handler_parms): Set TREE_TYPE on the handler.\n        * cp-tree.h (PUBLICLY_UNIQUELY_DERIVED_P): New macro.\n        * search.c (get_base_distance_recursive): If protect>1, ignore\n        special access.\n        (get_base_distance): Don't reduce watch_access.\n\nFrom-SVN: r33904", "tree": {"sha": "fdcb7402c43aec74d3459daa95e59e5de36da6f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fdcb7402c43aec74d3459daa95e59e5de36da6f9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/comments", "author": null, "committer": null, "parents": [{"sha": "c2b2bca6360e429bccc10d083edfb72618b3a658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2b2bca6360e429bccc10d083edfb72618b3a658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2b2bca6360e429bccc10d083edfb72618b3a658"}], "stats": {"total": 135, "additions": 124, "deletions": 11}, "files": [{"sha": "a9a8684a6459b888148406ec4700c6223c7b815a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "patch": "@@ -1,3 +1,15 @@\n+2000-05-14  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* except.c (check_handlers): New fn.\n+\t* cp-tree.h: Declare it.\n+\t* semantics.c (finish_handler_sequence): Call it.\n+\t(finish_function_handler_sequence): Likewise.\n+\t(finish_handler_parms): Set TREE_TYPE on the handler.\n+\t* cp-tree.h (PUBLICLY_UNIQUELY_DERIVED_P): New macro.\n+\t* search.c (get_base_distance_recursive): If protect>1, ignore\n+\tspecial access.\n+\t(get_base_distance): Don't reduce watch_access.\n+\n 2000-05-13  Gabriel Dos Reis <gdr@codesourcery.com>\n \n \t* lex.c: #include diagnostic.h."}, {"sha": "7961eb326e394a9799f883d2c0631ba3197f0c0f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "patch": "@@ -1314,6 +1314,7 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n #define UNIQUELY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) >= 0)\n #define ACCESSIBLY_DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, -1, (tree *)0) >= 0)\n #define ACCESSIBLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 1, (tree *)0) >= 0)\n+#define PUBLICLY_UNIQUELY_DERIVED_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 2, (tree *)0) >= 0)\n #define DERIVED_FROM_P(PARENT, TYPE) (get_base_distance (PARENT, TYPE, 0, (tree *)0) != -1)\n \f\n /* This structure provides additional information above and beyond\n@@ -4114,6 +4115,7 @@ extern void expand_exception_blocks\t\tPARAMS ((void));\n extern tree build_throw\t\t\t\tPARAMS ((tree));\n extern void mark_all_runtime_matches            PARAMS ((void));\n extern int nothrow_libfn_p\t\t\tPARAMS ((tree));\n+extern void check_handlers\t\t\tPARAMS ((tree));\n \n /* in expr.c */\n extern void init_cplus_expand\t\t\tPARAMS ((void));"}, {"sha": "ce8535a86229b948f516e3319c89c779df45ad50", "filename": "gcc/cp/except.c", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "patch": "@@ -1106,3 +1106,87 @@ nothrow_libfn_p (fn)\n   id = DECL_ASSEMBLER_NAME (fn);\n   return !!libc_name_p (IDENTIFIER_POINTER (id), IDENTIFIER_LENGTH (id));\n }\n+\n+/* Returns nonzero if an exception of type FROM will be caught by a\n+   handler for type TO, as per [except.handle].  */\n+\n+static int\n+can_convert_eh (to, from)\n+     tree to, from;\n+{\n+  if (TREE_CODE (to) == REFERENCE_TYPE)\n+    to = TREE_TYPE (to);\n+  if (TREE_CODE (from) == REFERENCE_TYPE)\n+    from = TREE_TYPE (from);\n+\n+  if (TREE_CODE (to) == POINTER_TYPE && TREE_CODE (from) == POINTER_TYPE)\n+    {\n+      to = TREE_TYPE (to);\n+      from = TREE_TYPE (from);\n+\n+      if (! at_least_as_qualified_p (to, from))\n+\treturn 0;\n+\n+      if (TREE_CODE (to) == VOID_TYPE)\n+\treturn 1;\n+\n+      /* else fall through */\n+    }\n+\n+  if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+      && PUBLICLY_UNIQUELY_DERIVED_P (to, from))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Check whether any of HANDLERS are shadowed by another handler accepting\n+   TYPE.  Note that the shadowing may not be complete; even if an exception\n+   of type B would be caught by a handler for A, there could be a derived\n+   class C for which A is an ambiguous base but B is not, so the handler\n+   for B would catch an exception of type C.  */\n+\n+static void\n+check_handlers_1 (master, handlers)\n+     tree master;\n+     tree handlers;\n+{\n+  tree type = TREE_TYPE (master);\n+  tree handler;\n+\n+  for (handler = handlers; handler; handler = TREE_CHAIN (handler))\n+    if (TREE_TYPE (handler)\n+\t&& can_convert_eh (type, TREE_TYPE (handler)))\n+      {\n+\tlineno = STMT_LINENO (handler);\n+\tcp_warning (\"exception of type `%T' will be caught\",\n+\t\t    TREE_TYPE (handler));\n+\tlineno = STMT_LINENO (master);\n+\tcp_warning (\"   by earlier handler for `%T'\", type);\n+\tbreak;\n+      }\n+}\n+\n+/* Given a chain of HANDLERs, make sure that they're OK.  */\n+\n+void\n+check_handlers (handlers)\n+     tree handlers;\n+{\n+  tree handler;\n+  int save_line = lineno;\n+  for (handler = handlers; handler; handler = TREE_CHAIN (handler))\n+    {\n+      if (TREE_CHAIN (handler) == NULL_TREE)\n+\t/* No more handlers; nothing to shadow.  */;\n+      else if (TREE_TYPE (handler) == NULL_TREE)\n+\t{\n+\t  lineno = STMT_LINENO (handler);\n+\t  cp_pedwarn\n+\t    (\"`...' handler must be the last handler for its try block\");\n+\t}\n+      else\n+\tcheck_handlers_1 (handler, TREE_CHAIN (handler));\n+    }\n+  lineno = save_line;\n+}"}, {"sha": "69d073947eb13a51cc05bc4a216c635f9cd835e0", "filename": "gcc/cp/search.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "patch": "@@ -327,7 +327,7 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n   tree binfos;\n   int i, n_baselinks;\n \n-  if (protect\n+  if (protect == 1\n       && !current_scope_in_chain\n       && is_friend (BINFO_TYPE (binfo), current_scope ()))\n     current_scope_in_chain = 1;\n@@ -383,12 +383,15 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n       tree base_binfo = TREE_VEC_ELT (binfos, i);\n \n       int via_private\n-\t= (protect\n-\t   && (is_private\n-\t       || (!TREE_VIA_PUBLIC (base_binfo)\n-\t\t   && !(TREE_VIA_PROTECTED (base_binfo)\n-\t\t\t&& current_scope_in_chain)\n-\t\t   && !is_friend (BINFO_TYPE (binfo), current_scope ()))));\n+\t= ((protect == 1\n+\t    && (is_private\n+\t\t|| (!TREE_VIA_PUBLIC (base_binfo)\n+\t\t    && !(TREE_VIA_PROTECTED (base_binfo)\n+\t\t\t && current_scope_in_chain)\n+\t\t    && !is_friend (BINFO_TYPE (binfo), current_scope ()))))\n+\t   || (protect > 1\n+\t       && (is_private || !TREE_VIA_PUBLIC (base_binfo))));\n+\n       int this_virtual = via_virtual || TREE_VIA_VIRTUAL (base_binfo);\n \n       rval = get_base_distance_recursive (base_binfo, depth, via_private,\n@@ -415,12 +418,15 @@ get_base_distance_recursive (binfo, depth, is_private, rval,\n    Return -1 if TYPE is not derived from PARENT.\n    Return -2 if PARENT is an ambiguous base class of TYPE, and PROTECT is\n     non-negative.\n-   Return -3 if PARENT is private to TYPE, and PROTECT is non-zero.\n+   Return -3 if PARENT is not accessible in TYPE, and PROTECT is non-zero.\n \n    If PATH_PTR is non-NULL, then also build the list of types\n    from PARENT to TYPE, with TREE_VIA_VIRTUAL and TREE_VIA_PUBLIC\n    set.\n \n+   If PROTECT is greater than 1, ignore any special access the current\n+   scope might have when determining whether PARENT is inaccessible.\n+\n    PARENT can also be a binfo, in which case that exact parent is found\n    and no other.  convert_pointer_to_real uses this functionality.\n \n@@ -468,7 +474,7 @@ get_base_distance (parent, binfo, protect, path_ptr)\n       return 0;\n     }\n \n-  if (path_ptr)\n+  if (path_ptr && watch_access == 0)\n     watch_access = 1;\n \n   rval = get_base_distance_recursive (binfo, 0, 0, -1,"}, {"sha": "ca0704c07006b07e79298140026b10220ba501e1", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bc9f1d1d1027f97e6bc0850c0605c79091330a9/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2bc9f1d1d1027f97e6bc0850c0605c79091330a9", "patch": "@@ -838,7 +838,10 @@ finish_handler_sequence (try_block)\n      tree try_block;\n {\n   if (building_stmt_tree ())\n-    RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+    {\n+      RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+      check_handlers (TRY_HANDLERS (try_block));\n+    }\n   else\n     expand_end_all_catch ();\n }\n@@ -852,7 +855,10 @@ finish_function_handler_sequence (try_block)\n   in_function_try_handler = 0;\n \n   if (building_stmt_tree ())\n-    RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+    {\n+      RECHAIN_STMTS (try_block, TRY_HANDLERS (try_block));\n+      check_handlers (TRY_HANDLERS (try_block));\n+    }\n   else\n     expand_end_all_catch ();\n }\n@@ -901,6 +907,9 @@ finish_handler_parms (decl, handler)\n   else if (building_stmt_tree ())\n     blocks = expand_start_catch_block (decl);\n \n+  if (decl)\n+    TREE_TYPE (handler) = TREE_TYPE (decl);\n+\n   return blocks;\n }\n "}]}