{"sha": "ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWUyYmNkOThmYTZkMGUzODk2MzhlMmMzY2Y0Y2Y4YTZjNzk4MDliNA==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-03-14T22:26:14Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-03-14T22:26:14Z"}, "message": "alias.c (get_alias_set): Replace calls via (*lang_hooks.foo) () with lang_hooks.foo ().\n\n\n\t* alias.c (get_alias_set): Replace calls via (*lang_hooks.foo) ()\n\twith lang_hooks.foo ().\n\t* builtins.c (expand_builtin_va_arg): Likewise.\n\t* c-common.c (fname_as_string, c_common_truthvalue_conversion,\n\tc_common_type_for_mode, c_common_nodes_and_builtins,\n\thandle_mode_attribute, handle_vector_size_attribute): Likewise.\n\t* c-convert.c (convert): Likewise.\n\t* c-format.c (check_format_types): Likewise.\n\t* c-objc-common.c (c_tree_printer): Likewise.\n\t* c-typeck.c (build_unary_op, build_conditional_expr,\n\tbuild_binary_op): Likewise.\n\t* calls.c (try_to_integrate, expand_call,\n\temit_library_call_value_1): Likewise.\n\t* cgraph.c (cgraph_node_name, cgraph_function_possibly_inlined_p):\n\tLikewise.\n\t* cgraphunit.c (record_call_1, cgraph_analyze_function,\n\tcgraph_expand_function): Likewise.\n\t* convert.c (convert_to_pointer, convert_to_integer): Likewise.\n\t* coverage.c (build_fn_info_type, build_ctr_info_type,\n\tbuild_gcov_info, create_coverage): Likewise.\n\t* dbxout.c (dbxout_init): Likewise.\n\t* diagnostic.c (diagnostic_report_current_function): Likewise.\n\t* dojump.c (do_jump): Likewise.\n\t* dwarf2out.c (dwarf2_name): Likewise.\n\t* except.c (init_eh): Likewise.\n\t* explow.c (expr_size, int_expr_size): Likewise.\n\t* expmed.c (make_tree, const_mult_add_overflow_p, expand_mult_add):\n\tLikewise.\n\t* expr.c (store_expr, store_constructor, safe_from_p,\n\texpand_expr_real, do_store_flag, try_casesi): Likewise.\n\t* function.c (push_function_context_to, pop_function_context_from,\n\tfree_after_parsing, assign_stack_local_1, assign_stack_temp_for_type,\n\tput_var_into_stack, allocate_struct_function, current_function_name):\n\tLikewise.\n\t* integrate.c (copy_decl_for_inlining, expand_inline_function):\n\tLikewise.\n\t* langhooks.c (lhd_clear_binding_stack, write_global_declarations,\n\tlhd_print_error_function): Likewise.\n\t* opts.c (handle_option, decode_options): Likewise.\n\t* passes.c (open_dump_file): Likewise.\n\t* print-tree.c (print_node): Likewise.\n\t* stmt.c (expand_fixup, fixup_gotos, expand_asm_operands,\n\texpand_decl_cleanup, emit_case_nodes): Likewise.\n\t* stor-layout.c (variable_size): Likewise.\n\t* toplev.c (announce_function, wrapup_global_declarations,\n\tcheck_global_declarations, compile_file, default_tree_printer,\n\tprocess_options, lang_dependent_init, finalize): Likewise.\n\t* tree-dump.c (dequeue_and_dump): Likewise.\n\t* tree-inline.c (remap_decl, remap_block, copy_body_r,\n\tinitialize_inlined_parameters, declare_return_variable,\n\tinlinable_function_p, expand_call_inline, optimize_inline_calls,\n\twalk_tree, copy_tree_r): Likewise.\n\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n\t* tree.c (decl_assembler_name, tree_size, size_in_bytes, staticp,\n\tunsafe_for_reeval, get_unwidened, get_narrower, get_callee_fndecl,\n\tvariably_modified_type_p, dump_tree_statistics): Likewise.\n\t* varasm.c (assemble_variable, compare_constant, copy_constant,\n\tforce_const_mem, compute_reloc_for_constant, output_constant,\n\toutput_addressed_constants, initializer_constant_valid_p): Likewise.\n\nFrom-SVN: r79481", "tree": {"sha": "0e3d992e1d5de0e7bb1692b921740b6575918627", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0e3d992e1d5de0e7bb1692b921740b6575918627"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/comments", "author": null, "committer": null, "parents": [{"sha": "89acbae0bce29e5f7168deb51e5f86ffdbe28d5f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89acbae0bce29e5f7168deb51e5f86ffdbe28d5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89acbae0bce29e5f7168deb51e5f86ffdbe28d5f"}], "stats": {"total": 529, "additions": 297, "deletions": 232}, "files": [{"sha": "eacd78a37e668c9786848294a845539854a75465", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1,3 +1,65 @@\n+2004-03-14  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* alias.c (get_alias_set): Replace calls via (*lang_hooks.foo) ()\n+\twith lang_hooks.foo ().\n+\t* builtins.c (expand_builtin_va_arg): Likewise.\n+\t* c-common.c (fname_as_string, c_common_truthvalue_conversion,\n+\tc_common_type_for_mode, c_common_nodes_and_builtins,\n+\thandle_mode_attribute, handle_vector_size_attribute): Likewise.\n+\t* c-convert.c (convert): Likewise.\n+\t* c-format.c (check_format_types): Likewise.\n+\t* c-objc-common.c (c_tree_printer): Likewise.\n+\t* c-typeck.c (build_unary_op, build_conditional_expr,\n+\tbuild_binary_op): Likewise.\n+\t* calls.c (try_to_integrate, expand_call,\n+\temit_library_call_value_1): Likewise.\n+\t* cgraph.c (cgraph_node_name, cgraph_function_possibly_inlined_p):\n+\tLikewise.\n+\t* cgraphunit.c (record_call_1, cgraph_analyze_function,\n+\tcgraph_expand_function): Likewise.\n+\t* convert.c (convert_to_pointer, convert_to_integer): Likewise.\n+\t* coverage.c (build_fn_info_type, build_ctr_info_type,\n+\tbuild_gcov_info, create_coverage): Likewise.\n+\t* dbxout.c (dbxout_init): Likewise.\n+\t* diagnostic.c (diagnostic_report_current_function): Likewise.\n+\t* dojump.c (do_jump): Likewise.\n+\t* dwarf2out.c (dwarf2_name): Likewise.\n+\t* except.c (init_eh): Likewise.\n+\t* explow.c (expr_size, int_expr_size): Likewise.\n+\t* expmed.c (make_tree, const_mult_add_overflow_p, expand_mult_add):\n+\tLikewise.\n+\t* expr.c (store_expr, store_constructor, safe_from_p,\n+\texpand_expr_real, do_store_flag, try_casesi): Likewise.\n+\t* function.c (push_function_context_to, pop_function_context_from,\n+\tfree_after_parsing, assign_stack_local_1, assign_stack_temp_for_type,\n+\tput_var_into_stack, allocate_struct_function, current_function_name):\n+\tLikewise.\n+\t* integrate.c (copy_decl_for_inlining, expand_inline_function):\n+\tLikewise.\n+\t* langhooks.c (lhd_clear_binding_stack, write_global_declarations,\n+\tlhd_print_error_function): Likewise.\n+\t* opts.c (handle_option, decode_options): Likewise.\n+\t* passes.c (open_dump_file): Likewise.\n+\t* print-tree.c (print_node): Likewise.\n+\t* stmt.c (expand_fixup, fixup_gotos, expand_asm_operands,\n+\texpand_decl_cleanup, emit_case_nodes): Likewise.\n+\t* stor-layout.c (variable_size): Likewise.\n+\t* toplev.c (announce_function, wrapup_global_declarations,\n+\tcheck_global_declarations, compile_file, default_tree_printer,\n+\tprocess_options, lang_dependent_init, finalize): Likewise.\n+\t* tree-dump.c (dequeue_and_dump): Likewise.\n+\t* tree-inline.c (remap_decl, remap_block, copy_body_r,\n+\tinitialize_inlined_parameters, declare_return_variable,\n+\tinlinable_function_p, expand_call_inline, optimize_inline_calls,\n+\twalk_tree, copy_tree_r): Likewise.\n+\t* tree-optimize.c (tree_rest_of_compilation): Likewise.\n+\t* tree.c (decl_assembler_name, tree_size, size_in_bytes, staticp,\n+\tunsafe_for_reeval, get_unwidened, get_narrower, get_callee_fndecl,\n+\tvariably_modified_type_p, dump_tree_statistics): Likewise.\n+\t* varasm.c (assemble_variable, compare_constant, copy_constant,\n+\tforce_const_mem, compute_reloc_for_constant, output_constant,\n+\toutput_addressed_constants, initializer_constant_valid_p): Likewise.\n+\n 2004-03-14  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* doc/install.texi: Make autoconf 2.13 the exception, not the rule."}, {"sha": "f317a5720aa5df87126a97ad1304b02ec67ed568", "filename": "gcc/alias.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -486,7 +486,7 @@ get_alias_set (tree t)\n       /* Remove any nops, then give the language a chance to do\n \t something with this tree before we look at it.  */\n       STRIP_NOPS (t);\n-      set = (*lang_hooks.get_alias_set) (t);\n+      set = lang_hooks.get_alias_set (t);\n       if (set != -1)\n \treturn set;\n \n@@ -577,7 +577,7 @@ get_alias_set (tree t)\n     return TYPE_ALIAS_SET (t);\n \n   /* See if the language has special handling for this type.  */\n-  set = (*lang_hooks.get_alias_set) (t);\n+  set = lang_hooks.get_alias_set (t);\n   if (set != -1)\n     return set;\n "}, {"sha": "a206b7c18f56bd7b10595d9ba37c1c6c47134c9c", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -4090,7 +4090,7 @@ expand_builtin_va_arg (tree valist, tree type)\n \n   /* Generate a diagnostic for requesting data of a type that cannot\n      be passed through `...' due to type promotion at the call site.  */\n-  else if ((promoted_type = (*lang_hooks.types.type_promotes_to) (type))\n+  else if ((promoted_type = lang_hooks.types.type_promotes_to (type))\n \t   != type)\n     {\n       const char *name = \"<anonymous type>\", *pname = 0;"}, {"sha": "3e0b5393a7098913699ef8f9bbe6a9475bf21266", "filename": "gcc/c-common.c", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1086,7 +1086,7 @@ fname_as_string (int pretty_p)\n     }\n \n   if (current_function_decl)\n-    name = (*lang_hooks.decl_printable_name) (current_function_decl, vrb);\n+    name = lang_hooks.decl_printable_name (current_function_decl, vrb);\n \n   return name;\n }\n@@ -2646,31 +2646,31 @@ c_common_truthvalue_conversion (tree expr)\n     case COMPLEX_EXPR:\n       return build_binary_op ((TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1))\n \t\t\t       ? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n-\t\t(*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 0)),\n-\t\t(*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 1)),\n+\t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0)),\n+\t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 1)),\n \t\t\t      0);\n \n     case NEGATE_EXPR:\n     case ABS_EXPR:\n     case FLOAT_EXPR:\n       /* These don't change whether an object is nonzero or zero.  */\n-      return (*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 0));\n+      return lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0));\n \n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n       /* These don't change whether an object is zero or nonzero, but\n \t we can't ignore them if their second arg has side-effects.  */\n       if (TREE_SIDE_EFFECTS (TREE_OPERAND (expr, 1)))\n \treturn build (COMPOUND_EXPR, truthvalue_type_node, TREE_OPERAND (expr, 1),\n-\t\t      (*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 0)));\n+\t\t      lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0)));\n       else\n-\treturn (*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 0));\n+\treturn lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0));\n \n     case COND_EXPR:\n       /* Distribute the conversion into the arms of a COND_EXPR.  */\n       return fold (build (COND_EXPR, truthvalue_type_node, TREE_OPERAND (expr, 0),\n-\t\t(*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 1)),\n-\t\t(*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 2))));\n+\t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 1)),\n+\t\tlang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 2))));\n \n     case CONVERT_EXPR:\n       /* Don't cancel the effect of a CONVERT_EXPR from a REFERENCE_TYPE,\n@@ -2683,7 +2683,7 @@ c_common_truthvalue_conversion (tree expr)\n       /* If this is widening the argument, we can ignore it.  */\n       if (TYPE_PRECISION (TREE_TYPE (expr))\n \t  >= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (expr, 0))))\n-\treturn (*lang_hooks.truthvalue_conversion) (TREE_OPERAND (expr, 0));\n+\treturn lang_hooks.truthvalue_conversion (TREE_OPERAND (expr, 0));\n       break;\n \n     case MINUS_EXPR:\n@@ -2732,8 +2732,8 @@ c_common_truthvalue_conversion (tree expr)\n       return (build_binary_op\n \t      ((TREE_SIDE_EFFECTS (expr)\n \t\t? TRUTH_OR_EXPR : TRUTH_ORIF_EXPR),\n-\t(*lang_hooks.truthvalue_conversion) (build_unary_op (REALPART_EXPR, t, 0)),\n-\t(*lang_hooks.truthvalue_conversion) (build_unary_op (IMAGPART_EXPR, t, 0)),\n+\tlang_hooks.truthvalue_conversion (build_unary_op (REALPART_EXPR, t, 0)),\n+\tlang_hooks.truthvalue_conversion (build_unary_op (IMAGPART_EXPR, t, 0)),\n \t       0));\n     }\n \n@@ -3099,43 +3099,43 @@ c_common_nodes_and_builtins (void)\n \n   /* These are types that c_common_type_for_size and\n      c_common_type_for_mode use.  */\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    intQI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    intHI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    intSI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    intDI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t intQI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t intHI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t intSI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t    get_identifier (\"__int128_t\"),\n-\t\t\t\t\t    intTI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t get_identifier (\"__int128_t\"),\n+\t\t\t\t\t intTI_type_node));\n #endif\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    unsigned_intQI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    unsigned_intHI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    unsigned_intSI_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    unsigned_intDI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t unsigned_intQI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t unsigned_intHI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t unsigned_intSI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t unsigned_intDI_type_node));\n #if HOST_BITS_PER_WIDE_INT >= 64\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t    get_identifier (\"__uint128_t\"),\n-\t\t\t\t\t    unsigned_intTI_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t get_identifier (\"__uint128_t\"),\n+\t\t\t\t\t unsigned_intTI_type_node));\n #endif\n \n   /* Create the widest literal types.  */\n   widest_integer_literal_type_node\n     = make_signed_type (HOST_BITS_PER_WIDE_INT * 2);\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    widest_integer_literal_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t widest_integer_literal_type_node));\n \n   widest_unsigned_literal_type_node\n     = make_unsigned_type (HOST_BITS_PER_WIDE_INT * 2);\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL, NULL_TREE,\n-\t\t\t\t\t    widest_unsigned_literal_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL, NULL_TREE,\n+\t\t\t\t\t widest_unsigned_literal_type_node));\n \n   /* `unsigned long' is the standard type for sizeof.\n      Note that stddef.h uses `unsigned long',\n@@ -3151,16 +3151,16 @@ c_common_nodes_and_builtins (void)\n   record_builtin_type (RID_DOUBLE, NULL, double_type_node);\n   record_builtin_type (RID_MAX, \"long double\", long_double_type_node);\n \n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t    get_identifier (\"complex int\"),\n-\t\t\t\t\t    complex_integer_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t    get_identifier (\"complex float\"),\n-\t\t\t\t\t    complex_float_type_node));\n-  (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t    get_identifier (\"complex double\"),\n-\t\t\t\t\t    complex_double_type_node));\n-  (*lang_hooks.decls.pushdecl)\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t get_identifier (\"complex int\"),\n+\t\t\t\t\t complex_integer_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t get_identifier (\"complex float\"),\n+\t\t\t\t\t complex_float_type_node));\n+  lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t get_identifier (\"complex double\"),\n+\t\t\t\t\t complex_double_type_node));\n+  lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"complex long double\"),\n \t\t complex_long_double_type_node));\n \n@@ -3184,12 +3184,12 @@ c_common_nodes_and_builtins (void)\n \n   if (g77_integer_type_node != NULL_TREE)\n     {\n-      (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t\tget_identifier (\"__g77_integer\"),\n-\t\t\t\t\t\tg77_integer_type_node));\n-      (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t\tget_identifier (\"__g77_uinteger\"),\n-\t\t\t\t\t\tg77_uinteger_type_node));\n+      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t     get_identifier (\"__g77_integer\"),\n+\t\t\t\t\t     g77_integer_type_node));\n+      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t     get_identifier (\"__g77_uinteger\"),\n+\t\t\t\t\t     g77_uinteger_type_node));\n     }\n \n   if (TYPE_PRECISION (float_type_node) * 2\n@@ -3209,12 +3209,12 @@ c_common_nodes_and_builtins (void)\n \n   if (g77_longint_type_node != NULL_TREE)\n     {\n-      (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t\tget_identifier (\"__g77_longint\"),\n-\t\t\t\t\t\tg77_longint_type_node));\n-      (*lang_hooks.decls.pushdecl) (build_decl (TYPE_DECL,\n-\t\t\t\t\t\tget_identifier (\"__g77_ulongint\"),\n-\t\t\t\t\t\tg77_ulongint_type_node));\n+      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t     get_identifier (\"__g77_longint\"),\n+\t\t\t\t\t     g77_longint_type_node));\n+      lang_hooks.decls.pushdecl (build_decl (TYPE_DECL,\n+\t\t\t\t\t     get_identifier (\"__g77_ulongint\"),\n+\t\t\t\t\t     g77_ulongint_type_node));\n     }\n \n   record_builtin_type (RID_VOID, NULL, void_type_node);\n@@ -3281,15 +3281,15 @@ c_common_nodes_and_builtins (void)\n     = TREE_TYPE (identifier_global_value (get_identifier (PTRDIFF_TYPE)));\n   unsigned_ptrdiff_type_node = c_common_unsigned_type (ptrdiff_type_node);\n \n-  (*lang_hooks.decls.pushdecl)\n+  lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_va_list\"),\n \t\t va_list_type_node));\n \n-  (*lang_hooks.decls.pushdecl)\n+  lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_ptrdiff_t\"),\n \t\t ptrdiff_type_node));\n \n-  (*lang_hooks.decls.pushdecl)\n+  lang_hooks.decls.pushdecl\n     (build_decl (TYPE_DECL, get_identifier (\"__builtin_size_t\"),\n \t\t sizetype));\n \n@@ -4629,7 +4629,7 @@ handle_mode_attribute (tree *node, tree name, tree args ATTRIBUTE_UNUSED,\n \n       if (mode == VOIDmode)\n \terror (\"unknown machine mode `%s'\", p);\n-      else if (0 == (typefm = (*lang_hooks.types.type_for_mode)\n+      else if (0 == (typefm = lang_hooks.types.type_for_mode\n \t\t     (mode, TREE_UNSIGNED (type))))\n \terror (\"no data type for mode `%s'\", p);\n       else if ((TREE_CODE (type) == POINTER_TYPE\n@@ -5194,8 +5194,8 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n     {\n       tree index, array, rt, list_node;\n \n-      new_type = (*lang_hooks.types.type_for_mode) (new_mode,\n-\t\t\t\t\t\t    TREE_UNSIGNED (type));\n+      new_type = lang_hooks.types.type_for_mode (new_mode,\n+\t\t\t\t\t\t TREE_UNSIGNED (type));\n \n       if (!new_type)\n \t{"}, {"sha": "582ec8bfe34d03c07ec45586651d614f7f81677a", "filename": "gcc/c-convert.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -95,7 +95,7 @@ convert (tree type, tree expr)\n     return fold (convert_to_integer (type, e));\n   if (code == BOOLEAN_TYPE)\n     {\n-      tree t = (*lang_hooks.truthvalue_conversion) (expr);\n+      tree t = lang_hooks.truthvalue_conversion (expr);\n       if (TREE_CODE (t) == ERROR_MARK)\n \treturn t;\n "}, {"sha": "9da4200d3b44842bdccb6b46f5e81e6378fce25f", "filename": "gcc/c-format.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1,6 +1,6 @@\n /* Check calls to formatted I/O functions (-Wformat).\n    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,\n-   2001, 2002, 2003 Free Software Foundation, Inc.\n+   2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -2286,7 +2286,7 @@ check_format_types (int *status, format_wanted_type *types)\n \tabort ();\n \n       if (types->pointer_count == 0)\n-\twanted_type = (*lang_hooks.types.type_promotes_to) (wanted_type);\n+\twanted_type = lang_hooks.types.type_promotes_to (wanted_type);\n \n       STRIP_NOPS (cur_param);\n "}, {"sha": "3bc89ee12d406bc2f62218744ec82acefcb1d4a2", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -290,14 +290,14 @@ c_tree_printer (pretty_printer *pp, text_info *text)\n     case 'D':\n     case 'F':\n       if (DECL_NAME (t))\n-\tn = (*lang_hooks.decl_printable_name) (t, 2);\n+\tn = lang_hooks.decl_printable_name (t, 2);\n       break;\n \n     case 'T':\n       if (TREE_CODE (t) == TYPE_DECL)\n \t{\n \t  if (DECL_NAME (t))\n-\t    n = (*lang_hooks.decl_printable_name) (t, 2);\n+\t    n = lang_hooks.decl_printable_name (t, 2);\n \t}\n       else\n \t{"}, {"sha": "bb9cdd37d5aad4a19fd6cbf2799b814d94e409b4", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -2285,7 +2285,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \t  error (\"wrong type argument to unary exclamation mark\");\n \t  return error_mark_node;\n \t}\n-      arg = (*lang_hooks.truthvalue_conversion) (arg);\n+      arg = lang_hooks.truthvalue_conversion (arg);\n       return invert_truthvalue (arg);\n \n     case NOP_EXPR:\n@@ -2658,7 +2658,7 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n   tree result_type = NULL;\n   tree orig_op1 = op1, orig_op2 = op2;\n \n-  ifexp = (*lang_hooks.truthvalue_conversion) (default_conversion (ifexp));\n+  ifexp = lang_hooks.truthvalue_conversion (default_conversion (ifexp));\n \n   /* Promote both alternatives.  */\n \n@@ -6566,8 +6566,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t     but that does not mean the operands should be\n \t     converted to ints!  */\n \t  result_type = integer_type_node;\n-\t  op0 = (*lang_hooks.truthvalue_conversion) (op0);\n-\t  op1 = (*lang_hooks.truthvalue_conversion) (op1);\n+\t  op0 = lang_hooks.truthvalue_conversion (op0);\n+\t  op1 = lang_hooks.truthvalue_conversion (op1);\n \t  converted = 1;\n \t}\n       break;"}, {"sha": "04e167130f3276ed3603bfdc72734a2a0bc2d55c", "filename": "gcc/calls.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1829,7 +1829,7 @@ try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n       warning (\"%Jinlining failed in call to '%F'\", fndecl, fndecl);\n       warning (\"called from here\");\n     }\n-  (*lang_hooks.mark_addressable) (fndecl);\n+  lang_hooks.mark_addressable (fndecl);\n   return (rtx) (size_t) - 1;\n }\n \n@@ -2201,7 +2201,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t      warning (\"%Jcan't inline call to '%F'\", fndecl, fndecl);\n \t      warning (\"called from here\");\n \t    }\n-\t  (*lang_hooks.mark_addressable) (fndecl);\n+\t  lang_hooks.mark_addressable (fndecl);\n \t}\n \n       if (ignore\n@@ -2284,7 +2284,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t    /* In case this is a static function, note that it has been\n \t       used.  */\n \t    if (! TREE_ADDRESSABLE (fndecl))\n-\t      (*lang_hooks.mark_addressable) (fndecl);\n+\t      lang_hooks.mark_addressable (fndecl);\n \t    is_integrable = 0;\n \t  }\n       }\n@@ -2532,7 +2532,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t  != RETURN_POPS_ARGS (current_function_decl,\n \t\t\t       TREE_TYPE (current_function_decl),\n \t\t\t       current_function_args_size))\n-      || !(*lang_hooks.decls.ok_for_sibcall) (fndecl))\n+      || !lang_hooks.decls.ok_for_sibcall (fndecl))\n     try_tail_call = 0;\n \n   if (try_tail_call || try_tail_recursion)\n@@ -3751,7 +3751,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      decide where in memory it should come back.  */\n   if (outmode != VOIDmode)\n     {\n-      tfom = (*lang_hooks.types.type_for_mode) (outmode, 0);\n+      tfom = lang_hooks.types.type_for_mode (outmode, 0);\n       if (aggregate_value_p (tfom, 0))\n \t{\n #ifdef PCC_STATIC_STRUCT_RETURN\n@@ -3896,13 +3896,13 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n \t    slot = val;\n \t  else if (must_copy)\n \t    {\n-\t      slot = assign_temp ((*lang_hooks.types.type_for_mode) (mode, 0),\n+\t      slot = assign_temp (lang_hooks.types.type_for_mode (mode, 0),\n \t\t\t\t  0, 1, 1);\n \t      emit_move_insn (slot, val);\n \t    }\n \t  else\n \t    {\n-\t      tree type = (*lang_hooks.types.type_for_mode) (mode, 0);\n+\t      tree type = lang_hooks.types.type_for_mode (mode, 0);\n \n \t      slot\n \t\t= gen_rtx_MEM (mode,"}, {"sha": "c45b3396f2adcf15f69eb03ecd091c664121a4cd", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -353,7 +353,7 @@ cgraph_rtl_info (tree decl)\n const char *\n cgraph_node_name (struct cgraph_node *node)\n {\n-  return (*lang_hooks.decl_printable_name) (node->decl, 2);\n+  return lang_hooks.decl_printable_name (node->decl, 2);\n }\n \n /* Dump the callgraph.  */\n@@ -628,7 +628,7 @@ cgraph_function_possibly_inlined_p (tree decl)\n   if (!cgraph_global_info_ready)\n     return (DECL_INLINE (decl)\n \t    && (!flag_really_no_inline\n-\t\t|| (*lang_hooks.tree_inlining.disregard_inline_limits) (decl)));\n+\t\t|| lang_hooks.tree_inlining.disregard_inline_limits (decl)));\n   return cgraph_node (decl)->global.inlined;\n }\n "}, {"sha": "2ebc4d777836e410f5ecf86e536ac13af2b54800", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -293,7 +293,7 @@ record_call_1 (tree *tp, int *walk_subtrees, void *data)\n \t}\n \n       if ((unsigned int) TREE_CODE (t) >= LAST_AND_UNUSED_TREE_CODE)\n-\treturn (*lang_hooks.callgraph.analyze_expr) (tp, walk_subtrees, data);\n+\treturn lang_hooks.callgraph.analyze_expr (tp, walk_subtrees, data);\n       break;\n     }\n \n@@ -329,10 +329,10 @@ cgraph_analyze_function (struct cgraph_node *node)\n   node->local.inlinable = tree_inlinable_function_p (decl);\n   if (!node->local.self_insns)\n     node->local.self_insns\n-      = (*lang_hooks.tree_inlining.estimate_num_insns) (decl);\n+      = lang_hooks.tree_inlining.estimate_num_insns (decl);\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n-      = (*lang_hooks.tree_inlining.disregard_inline_limits) (decl);\n+      = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n   for (e = node->callers; e; e = e->next_caller)\n     if (e->inline_failed)\n       {\n@@ -530,7 +530,7 @@ cgraph_expand_function (struct cgraph_node *node)\n \n   /* Generate RTL for the body of DECL.  Nested functions are expanded\n      via lang_expand_decl_stmt.  */\n-  (*lang_hooks.callgraph.expand_function) (decl);\n+  lang_hooks.callgraph.expand_function (decl);\n   if (DECL_DEFER_OUTPUT (decl))\n     abort ();\n "}, {"sha": "3a834450eb1f0b6e05c8fc238ab740fb66108627", "filename": "gcc/convert.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -63,7 +63,7 @@ convert_to_pointer (tree type, tree expr)\n \n       return\n \tconvert_to_pointer (type,\n-\t\t\t    convert ((*lang_hooks.types.type_for_size)\n+\t\t\t    convert (lang_hooks.types.type_for_size\n \t\t\t\t     (POINTER_SIZE, 0), expr));\n \n     default:\n@@ -304,8 +304,9 @@ convert_to_integer (tree type, tree expr)\n       if (integer_zerop (expr))\n \texpr = integer_zero_node;\n       else\n-\texpr = fold (build1 (CONVERT_EXPR, (*lang_hooks.types.type_for_size)\n-\t\t\t     (POINTER_SIZE, 0), expr));\n+\texpr = fold (build1 (CONVERT_EXPR,\n+\t\t\t     lang_hooks.types.type_for_size (POINTER_SIZE, 0),\n+\t\t\t     expr));\n \n       return convert_to_integer (type, expr);\n \n@@ -378,7 +379,7 @@ convert_to_integer (tree type, tree expr)\n       else if (TREE_CODE (type) == ENUMERAL_TYPE\n \t       || outprec != GET_MODE_BITSIZE (TYPE_MODE (type)))\n \treturn build1 (NOP_EXPR, type,\n-\t\t       convert ((*lang_hooks.types.type_for_mode)\n+\t\t       convert (lang_hooks.types.type_for_mode\n \t\t\t\t(TYPE_MODE (type), TREE_UNSIGNED (type)),\n \t\t\t\texpr));\n \n@@ -490,7 +491,7 @@ convert_to_integer (tree type, tree expr)\n \t\t/* Can't do arithmetic in enumeral types\n \t\t   so use an integer type that will hold the values.  */\n \t\tif (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t\t  typex = (*lang_hooks.types.type_for_size)\n+\t\t  typex = lang_hooks.types.type_for_size\n \t\t    (TYPE_PRECISION (typex), TREE_UNSIGNED (typex));\n \n \t\t/* But now perhaps TYPEX is as wide as INPREC.\n@@ -517,9 +518,9 @@ convert_to_integer (tree type, tree expr)\n \t\t\t\t|| ex_form == LROTATE_EXPR\n \t\t\t\t|| ex_form == RROTATE_EXPR))\n \t\t\t|| ex_form == LSHIFT_EXPR)\n-\t\t      typex = (*lang_hooks.types.unsigned_type) (typex);\n+\t\t      typex = lang_hooks.types.unsigned_type (typex);\n \t\t    else\n-\t\t      typex = (*lang_hooks.types.signed_type) (typex);\n+\t\t      typex = lang_hooks.types.signed_type (typex);\n \t\t    return convert (type,\n \t\t\t\t    fold (build (ex_form, typex,\n \t\t\t\t\t\t convert (typex, arg0),\n@@ -539,7 +540,7 @@ convert_to_integer (tree type, tree expr)\n \t    /* Can't do arithmetic in enumeral types\n \t       so use an integer type that will hold the values.  */\n \t    if (TREE_CODE (typex) == ENUMERAL_TYPE)\n-\t      typex = (*lang_hooks.types.type_for_size)\n+\t      typex = lang_hooks.types.type_for_size\n \t\t(TYPE_PRECISION (typex), TREE_UNSIGNED (typex));\n \n \t    /* But now perhaps TYPEX is as wide as INPREC.\n@@ -550,9 +551,9 @@ convert_to_integer (tree type, tree expr)\n \t\t/* Don't do unsigned arithmetic where signed was wanted,\n \t\t   or vice versa.  */\n \t\tif (TREE_UNSIGNED (TREE_TYPE (expr)))\n-\t\t  typex = (*lang_hooks.types.unsigned_type) (typex);\n+\t\t  typex = lang_hooks.types.unsigned_type (typex);\n \t\telse\n-\t\t  typex = (*lang_hooks.types.signed_type) (typex);\n+\t\t  typex = lang_hooks.types.signed_type (typex);\n \t\treturn convert (type,\n \t\t\t\tfold (build1 (ex_form, typex,\n \t\t\t\t\t      convert (typex,"}, {"sha": "27643fa6c500f912205118ae730fb0c0799dc59b", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -560,7 +560,7 @@ coverage_end_function (void)\n static tree\n build_fn_info_type (unsigned int counters)\n {\n-  tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  tree type = lang_hooks.types.make_type (RECORD_TYPE);\n   tree field, fields;\n   tree array_type;\n \n@@ -634,7 +634,7 @@ build_fn_info_value (const struct function_list *function, tree type)\n static tree\n build_ctr_info_type (void)\n {\n-  tree type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  tree type = lang_hooks.types.make_type (RECORD_TYPE);\n   tree field, fields = NULL_TREE;\n   tree gcov_ptr_type = build_pointer_type (GCOV_TYPE_NODE);\n   tree gcov_merge_fn_type;\n@@ -744,7 +744,7 @@ build_gcov_info (void)\n     if (prg_ctr_mask & (1 << ix))\n       n_ctr_types++;\n \n-  type = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+  type = lang_hooks.types.make_type (RECORD_TYPE);\n   const_type = build_qualified_type (type, TYPE_QUAL_CONST);\n \n   /* Version ident */\n@@ -902,7 +902,7 @@ create_coverage (void)\n   DECL_RESULT (ctor) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n   DECL_UNINLINABLE (ctor) = 1;\n \n-  ctor = (*lang_hooks.decls.pushdecl) (ctor);\n+  ctor = lang_hooks.decls.pushdecl (ctor);\n   rest_of_decl_compilation (ctor, 0, 1, 0);\n   announce_function (ctor);\n   current_function_decl = ctor;"}, {"sha": "1729b4ecbc6e72915951a7ca81826b5fc0519732", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -476,7 +476,7 @@ static void\n dbxout_init (const char *input_file_name)\n {\n   char ltext_label_name[100];\n-  tree syms = (*lang_hooks.decls.getdecls) ();\n+  tree syms = lang_hooks.decls.getdecls ();\n \n   asmfile = asm_out_file;\n "}, {"sha": "b495d6451c36759757d374059a5f5e7bafaead3b", "filename": "gcc/diagnostic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdiagnostic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdiagnostic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -293,7 +293,7 @@ void\n diagnostic_report_current_function (diagnostic_context *context)\n {\n   diagnostic_report_current_module (context);\n-  (*lang_hooks.print_error_function) (context, input_filename);\n+  lang_hooks.print_error_function (context, input_filename);\n }\n \n void"}, {"sha": "d0cc13c45f349fbe97f08ced3c9579bce43f738f", "filename": "gcc/dojump.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1,6 +1,6 @@\n /* Convert tree expression to rtl instructions, for GNU compiler.\n    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,\n-   2000, 2001, 2002, 2003 Free Software Foundation, Inc.\n+   2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -151,7 +151,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n     case UNSAVE_EXPR:\n       do_jump (TREE_OPERAND (exp, 0), if_false_label, if_true_label);\n       TREE_OPERAND (exp, 0)\n-\t= (*lang_hooks.unsave_expr_now) (TREE_OPERAND (exp, 0));\n+\t= lang_hooks.unsave_expr_now (TREE_OPERAND (exp, 0));\n       break;\n \n     case NOP_EXPR:\n@@ -218,7 +218,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n           && TYPE_PRECISION (TREE_TYPE (exp)) <= HOST_BITS_PER_WIDE_INT\n           && (i = tree_floor_log2 (TREE_OPERAND (exp, 1))) >= 0\n           && (mode = mode_for_size (i + 1, MODE_INT, 0)) != BLKmode\n-          && (type = (*lang_hooks.types.type_for_mode) (mode, 1)) != 0\n+          && (type = lang_hooks.types.type_for_mode (mode, 1)) != 0\n           && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))\n           && (cmp_optab->handlers[(int) TYPE_MODE (type)].insn_code\n               != CODE_FOR_nothing))\n@@ -278,7 +278,7 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n         get_inner_reference (exp, &bitsize, &bitpos, &offset, &mode,\n                              &unsignedp, &volatilep);\n \n-        type = (*lang_hooks.types.type_for_size) (bitsize, unsignedp);\n+        type = lang_hooks.types.type_for_size (bitsize, unsignedp);\n         if (! SLOW_BYTE_ACCESS\n             && type != 0 && bitsize >= 0\n             && TYPE_PRECISION (type) < TYPE_PRECISION (TREE_TYPE (exp))"}, {"sha": "a9639c3f4a99189febe71693683bef4c50759ffc", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -6983,7 +6983,7 @@ output_comp_unit (dw_die_ref die, int output_if_empty)\n static const char *\n dwarf2_name (tree decl, int scope)\n {\n-  return (*lang_hooks.decl_printable_name) (decl, scope ? 1 : 0);\n+  return lang_hooks.decl_printable_name (decl, scope ? 1 : 0);\n }\n \n /* Add a new entry to .debug_pubnames if appropriate.  */"}, {"sha": "4e38df26db0db7339f823626b152e70594db3ce1", "filename": "gcc/except.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -377,7 +377,7 @@ init_eh (void)\n     {\n       tree f_jbuf, f_per, f_lsda, f_prev, f_cs, f_data, tmp;\n \n-      sjlj_fc_type_node = (*lang_hooks.types.make_type) (RECORD_TYPE);\n+      sjlj_fc_type_node = lang_hooks.types.make_type (RECORD_TYPE);\n \n       f_prev = build_decl (FIELD_DECL, get_identifier (\"__prev\"),\n \t\t\t   build_pointer_type (sjlj_fc_type_node));\n@@ -388,7 +388,7 @@ init_eh (void)\n       DECL_FIELD_CONTEXT (f_cs) = sjlj_fc_type_node;\n \n       tmp = build_index_type (build_int_2 (4 - 1, 0));\n-      tmp = build_array_type ((*lang_hooks.types.type_for_mode) (word_mode, 1),\n+      tmp = build_array_type (lang_hooks.types.type_for_mode (word_mode, 1),\n \t\t\t      tmp);\n       f_data = build_decl (FIELD_DECL, get_identifier (\"__data\"), tmp);\n       DECL_FIELD_CONTEXT (f_data) = sjlj_fc_type_node;"}, {"sha": "0655f24ded3a1bb7cc218494b958b58f07450371", "filename": "gcc/explow.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -240,7 +240,7 @@ eliminate_constant_term (rtx x, rtx *constptr)\n rtx\n expr_size (tree exp)\n {\n-  tree size = (*lang_hooks.expr_size) (exp);\n+  tree size = lang_hooks.expr_size (exp);\n \n   if (CONTAINS_PLACEHOLDER_P (size))\n     size = build (WITH_RECORD_EXPR, sizetype, size, exp);\n@@ -254,7 +254,7 @@ expr_size (tree exp)\n HOST_WIDE_INT\n int_expr_size (tree exp)\n {\n-  tree t = (*lang_hooks.expr_size) (exp);\n+  tree t = lang_hooks.expr_size (exp);\n \n   if (t == 0\n       || TREE_CODE (t) != INTEGER_CST"}, {"sha": "8586f403e92ebe0043cc4f966e5589f1dd1af96e", "filename": "gcc/expmed.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -4180,22 +4180,22 @@ make_tree (tree type, rtx x)\n \t\t\t  make_tree (type, XEXP (x, 1))));\n \n     case LSHIFTRT:\n-      t = (*lang_hooks.types.unsigned_type) (type);\n+      t = lang_hooks.types.unsigned_type (type);\n       return fold (convert (type,\n \t\t\t    build (RSHIFT_EXPR, t,\n \t\t\t\t   make_tree (t, XEXP (x, 0)),\n \t\t\t\t   make_tree (type, XEXP (x, 1)))));\n \n     case ASHIFTRT:\n-      t = (*lang_hooks.types.signed_type) (type);\n+      t = lang_hooks.types.signed_type (type);\n       return fold (convert (type,\n \t\t\t    build (RSHIFT_EXPR, t,\n \t\t\t\t   make_tree (t, XEXP (x, 0)),\n \t\t\t\t   make_tree (type, XEXP (x, 1)))));\n \n     case DIV:\n       if (TREE_CODE (type) != REAL_TYPE)\n-\tt = (*lang_hooks.types.signed_type) (type);\n+\tt = lang_hooks.types.signed_type (type);\n       else\n \tt = type;\n \n@@ -4204,16 +4204,16 @@ make_tree (tree type, rtx x)\n \t\t\t\t   make_tree (t, XEXP (x, 0)),\n \t\t\t\t   make_tree (t, XEXP (x, 1)))));\n     case UDIV:\n-      t = (*lang_hooks.types.unsigned_type) (type);\n+      t = lang_hooks.types.unsigned_type (type);\n       return fold (convert (type,\n \t\t\t    build (TRUNC_DIV_EXPR, t,\n \t\t\t\t   make_tree (t, XEXP (x, 0)),\n \t\t\t\t   make_tree (t, XEXP (x, 1)))));\n \n     case SIGN_EXTEND:\n     case ZERO_EXTEND:\n-      t = (*lang_hooks.types.type_for_mode) (GET_MODE (XEXP (x, 0)),\n-\t\t\t\t\t     GET_CODE (x) == ZERO_EXTEND);\n+      t = lang_hooks.types.type_for_mode (GET_MODE (XEXP (x, 0)),\n+\t\t\t\t\t  GET_CODE (x) == ZERO_EXTEND);\n       return fold (convert (type, make_tree (t, XEXP (x, 0))));\n \n    default:\n@@ -4245,7 +4245,7 @@ const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int\n {\n   tree type, mult_type, add_type, result;\n \n-  type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n+  type = lang_hooks.types.type_for_mode (mode, unsignedp);\n \n   /* In order to get a proper overflow indication from an unsigned\n      type, we have to pretend that it's a sizetype.  */\n@@ -4257,7 +4257,7 @@ const_mult_add_overflow_p (rtx x, rtx mult, rtx add, enum machine_mode mode, int\n     }\n \n   add_type = (GET_MODE (add) == VOIDmode ? mult_type\n-\t      : (*lang_hooks.types.type_for_mode) (GET_MODE (add), unsignedp));\n+\t      : lang_hooks.types.type_for_mode (GET_MODE (add), unsignedp));\n \n   result = fold (build (PLUS_EXPR, mult_type,\n \t\t\tfold (build (MULT_EXPR, mult_type,\n@@ -4280,10 +4280,10 @@ rtx\n expand_mult_add (rtx x, rtx target, rtx mult, rtx add, enum machine_mode mode,\n \t\t int unsignedp)\n {\n-  tree type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n+  tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n   tree add_type = (GET_MODE (add) == VOIDmode\n-\t\t   ? type: (*lang_hooks.types.type_for_mode) (GET_MODE (add),\n-\t\t\t\t\t\t\t      unsignedp));\n+\t\t   ? type: lang_hooks.types.type_for_mode (GET_MODE (add),\n+\t\t\t\t\t\t\t   unsignedp));\n   tree result =  fold (build (PLUS_EXPR, type,\n \t\t\t      fold (build (MULT_EXPR, type,\n \t\t\t\t\t   make_tree (type, x),"}, {"sha": "b909c7c7b8fcfd3e332daf5f8ad0ef008de2d04c", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -4128,10 +4128,10 @@ store_expr (tree exp, rtx target, int want_value)\n \t  if (TREE_UNSIGNED (TREE_TYPE (exp))\n \t      != SUBREG_PROMOTED_UNSIGNED_P (target))\n \t    exp = convert\n-\t      ((*lang_hooks.types.signed_or_unsigned_type)\n+\t      (lang_hooks.types.signed_or_unsigned_type\n \t       (SUBREG_PROMOTED_UNSIGNED_P (target), TREE_TYPE (exp)), exp);\n \n-\t  exp = convert ((*lang_hooks.types.type_for_mode)\n+\t  exp = convert (lang_hooks.types.type_for_mode\n \t\t\t (GET_MODE (SUBREG_REG (target)),\n \t\t\t  SUBREG_PROMOTED_UNSIGNED_P (target)),\n \t\t\t exp);\n@@ -4655,7 +4655,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \n \t      if (TYPE_PRECISION (type) < BITS_PER_WORD)\n \t\t{\n-\t\t  type = (*lang_hooks.types.type_for_size)\n+\t\t  type = lang_hooks.types.type_for_size\n \t\t    (BITS_PER_WORD, TREE_UNSIGNED (type));\n \t\t  value = convert (type, value);\n \t\t}\n@@ -5122,7 +5122,7 @@ store_constructor (tree exp, rtx target, int cleared, HOST_WIDE_INT size)\n \t    {\n \t      targetx\n \t\t= assign_temp\n-\t\t  ((build_qualified_type ((*lang_hooks.types.type_for_mode)\n+\t\t  ((build_qualified_type (lang_hooks.types.type_for_mode\n \t\t\t\t\t  (GET_MODE (target), 0),\n \t\t\t\t\t  TYPE_QUAL_CONST)),\n \t\t   0, 1, 1);\n@@ -5937,7 +5937,7 @@ safe_from_p (rtx x, tree exp, int top_p)\n \t special handling.  */\n       if ((unsigned int) TREE_CODE (exp)\n \t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE\n-\t  && !(*lang_hooks.safe_from_p) (x, exp))\n+\t  && !lang_hooks.safe_from_p (x, exp))\n \treturn 0;\n     }\n \n@@ -6386,7 +6386,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t  DECL_NONLOCAL (exp) = 1;\n \t  if (DECL_NO_STATIC_CHAIN (current_function_decl))\n \t    abort ();\n-\t  (*lang_hooks.mark_addressable) (exp);\n+\t  lang_hooks.mark_addressable (exp);\n \t  if (GET_CODE (DECL_RTL (exp)) != MEM)\n \t    abort ();\n \t  addr = XEXP (DECL_RTL (exp), 0);\n@@ -6649,7 +6649,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \trtx temp;\n \ttemp = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n \tTREE_OPERAND (exp, 0)\n-\t  = (*lang_hooks.unsave_expr_now) (TREE_OPERAND (exp, 0));\n+\t  = lang_hooks.unsave_expr_now (TREE_OPERAND (exp, 0));\n \treturn temp;\n       }\n \n@@ -6724,7 +6724,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t/* Mark the corresponding BLOCK for output in its proper place.  */\n \tif (TREE_OPERAND (exp, 2) != 0\n \t    && ! TREE_USED (TREE_OPERAND (exp, 2)))\n-\t  (*lang_hooks.decls.insert_block) (TREE_OPERAND (exp, 2));\n+\t  lang_hooks.decls.insert_block (TREE_OPERAND (exp, 2));\n \n \t/* If VARS have not yet been expanded, expand them now.  */\n \twhile (vars)\n@@ -7484,6 +7484,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \t{\n \t  if (DECL_BUILT_IN_CLASS (TREE_OPERAND (TREE_OPERAND (exp, 0), 0))\n \t      == BUILT_IN_FRONTEND)\n+\t  /* ??? Use (*fun) form because expand_expr is a macro.  */\n \t    return (*lang_hooks.expand_expr) (exp, original_target,\n \t\t\t\t\t      tmode, modifier,\n \t\t\t\t\t      alt_rtl);\n@@ -8613,7 +8614,7 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n \n \t\tif (TREE_OPERAND (exp, 2) == 0)\n \t\t  TREE_OPERAND (exp, 2)\n-\t\t    = (*lang_hooks.maybe_build_cleanup) (slot);\n+\t\t    = lang_hooks.maybe_build_cleanup (slot);\n \t\tcleanups = TREE_OPERAND (exp, 2);\n \t      }\n \t  }\n@@ -9067,8 +9068,9 @@ expand_expr_real (tree exp, rtx target, enum machine_mode tmode,\n       abort ();\n \n     default:\n-      return (*lang_hooks.expand_expr) (exp, original_target, tmode, modifier,\n-\t\t\t\t\talt_rtl);\n+      /* ??? Use (*fun) form because expand_expr is a macro.  */\n+      return (*lang_hooks.expand_expr) (exp, original_target, tmode,\n+\t\t\t\t\tmodifier, alt_rtl);\n     }\n \n   /* Here to do an ordinary binary operator, generating an instruction\n@@ -9539,7 +9541,7 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n       && TREE_CODE (arg0) == BIT_AND_EXPR && integer_zerop (arg1)\n       && integer_pow2p (TREE_OPERAND (arg0, 1)))\n     {\n-      tree type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n+      tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n       return expand_expr (fold_single_bit_test (code == NE ? NE_EXPR : EQ_EXPR,\n \t\t\t\t\t\targ0, arg1, type),\n \t\t\t  target, VOIDmode, EXPAND_NORMAL);\n@@ -9683,7 +9685,7 @@ try_casesi (tree index_type, tree index_expr, tree minval, tree range,\n     {\n       if (TYPE_MODE (index_type) != index_mode)\n \t{\n-\t  index_expr = convert ((*lang_hooks.types.type_for_size)\n+\t  index_expr = convert (lang_hooks.types.type_for_size\n \t\t\t\t(index_bits, 0), index_expr);\n \t  index_type = TREE_TYPE (index_expr);\n \t}"}, {"sha": "4236d156bb9d21b8eaa21d0038a15eb57b99cb6a", "filename": "gcc/function.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -345,7 +345,7 @@ push_function_context_to (tree context)\n   outer_function_chain = p;\n   p->fixup_var_refs_queue = 0;\n \n-  (*lang_hooks.function.enter_nested) (p);\n+  lang_hooks.function.enter_nested (p);\n \n   cfun = 0;\n }\n@@ -373,7 +373,7 @@ pop_function_context_from (tree context ATTRIBUTE_UNUSED)\n \n   restore_emit_status (p);\n \n-  (*lang_hooks.function.leave_nested) (p);\n+  lang_hooks.function.leave_nested (p);\n \n   /* Finish doing put_var_into_stack for any of our variables which became\n      addressable during the nested function.  If only one entry has to be\n@@ -425,7 +425,7 @@ free_after_parsing (struct function *f)\n   /* f->varasm is used by code generation.  */\n   /* f->eh->eh_return_stub_label is used by code generation.  */\n \n-  (*lang_hooks.function.final) (f);\n+  lang_hooks.function.final (f);\n   f->stmt = NULL;\n }\n \n@@ -532,7 +532,7 @@ assign_stack_local_1 (enum machine_mode mode, HOST_WIDE_INT size, int align,\n \n       /* Allow the target to (possibly) increase the alignment of this\n \t stack slot.  */\n-      type = (*lang_hooks.types.type_for_mode) (mode, 0);\n+      type = lang_hooks.types.type_for_mode (mode, 0);\n       if (type)\n \talignment = LOCAL_ALIGNMENT (type, alignment);\n \n@@ -660,7 +660,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size, int keep\n     align = GET_MODE_ALIGNMENT (mode);\n \n   if (! type)\n-    type = (*lang_hooks.types.type_for_mode) (mode, 0);\n+    type = lang_hooks.types.type_for_mode (mode, 0);\n \n   if (type)\n     align = LOCAL_ALIGNMENT (type, align);\n@@ -1375,7 +1375,7 @@ put_var_into_stack (tree decl, int rescan)\n \t to the whole CONCAT, lest we do double fixups for the latter\n \t references.  */\n       enum machine_mode part_mode = GET_MODE (XEXP (reg, 0));\n-      tree part_type = (*lang_hooks.types.type_for_mode) (part_mode, 0);\n+      tree part_type = lang_hooks.types.type_for_mode (part_mode, 0);\n       rtx lopart = XEXP (reg, 0);\n       rtx hipart = XEXP (reg, 1);\n #ifdef FRAME_GROWS_DOWNWARD\n@@ -6422,7 +6422,7 @@ allocate_struct_function (tree fndecl)\n   init_stmt_for_function ();\n   init_eh_for_function ();\n \n-  (*lang_hooks.function.init) (cfun);\n+  lang_hooks.function.init (cfun);\n   if (init_machine_status)\n     cfun->machine = (*init_machine_status) ();\n \n@@ -8131,7 +8131,7 @@ init_function_once (void)\n const char *\n current_function_name (void)\n {\n-  return (*lang_hooks.decl_printable_name) (cfun->decl, 2);\n+  return lang_hooks.decl_printable_name (cfun->decl, 2);\n }\n \n #include \"gt-function.h\""}, {"sha": "d7136c36e0d54a884a6cca765af43327e39cb11b", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -373,7 +373,7 @@ copy_decl_for_inlining (tree decl, tree from_fn, tree to_fn)\n       copy = copy_node (decl);\n       /* The COPY is not abstract; it will be generated in TO_FN.  */\n       DECL_ABSTRACT (copy) = 0;\n-      (*lang_hooks.dup_lang_specific_decl) (copy);\n+      lang_hooks.dup_lang_specific_decl (copy);\n \n       /* TREE_ADDRESSABLE isn't used to indicate that a label's\n \t address has been taken; it's for internal bookkeeping in\n@@ -1256,7 +1256,7 @@ expand_inline_function (tree fndecl, tree parms, rtx target, int ignore,\n        this block to the list of blocks at this binding level.  We\n        can't do it the way it's done for function-at-a-time mode the\n        superblocks have not been created yet.  */\n-    (*lang_hooks.decls.insert_block) (block);\n+    lang_hooks.decls.insert_block (block);\n   else\n     {\n       BLOCK_CHAIN (block)"}, {"sha": "4e9c3e983becbb20a3b2d96f98aa590ffb671f2e", "filename": "gcc/langhooks.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -215,7 +215,7 @@ lhd_can_use_bit_fields_p (void)\n void\n lhd_clear_binding_stack (void)\n {\n-  while (! (*lang_hooks.decls.global_bindings_p) ())\n+  while (! lang_hooks.decls.global_bindings_p ())\n     poplevel (0, 0, 0);\n }\n \n@@ -495,7 +495,7 @@ write_global_declarations (void)\n      Really output inline functions that must actually be callable\n      and have not been output so far.  */\n \n-  tree globals = (*lang_hooks.decls.getdecls) ();\n+  tree globals = lang_hooks.decls.getdecls ();\n   int len = list_length (globals);\n   tree *vec = xmalloc (sizeof (tree) * len);\n   int i;\n@@ -540,11 +540,11 @@ lhd_print_error_function (diagnostic_context *context, const char *file)\n \t  if (TREE_CODE (TREE_TYPE (current_function_decl)) == METHOD_TYPE)\n \t    pp_printf\n \t      (context->printer, \"In member function `%s':\",\n-\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n+\t       lang_hooks.decl_printable_name (current_function_decl, 2));\n \t  else\n \t    pp_printf\n \t      (context->printer, \"In function `%s':\",\n-\t       (*lang_hooks.decl_printable_name) (current_function_decl, 2));\n+\t       lang_hooks.decl_printable_name (current_function_decl, 2));\n \t}\n \n       diagnostic_set_last_function (context);"}, {"sha": "f21cf250d21e4489ffe8d7dad163846813894402", "filename": "gcc/opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -403,7 +403,7 @@ handle_option (const char **argv, unsigned int lang_mask)\n \n   if (arg == NULL && (option->flags & (CL_JOINED | CL_SEPARATE)))\n     {\n-      if (!(*lang_hooks.missing_argument) (opt, opt_index))\n+      if (!lang_hooks.missing_argument (opt, opt_index))\n \terror (\"missing argument to \\\"%s\\\"\", opt);\n       goto done;\n     }\n@@ -421,7 +421,7 @@ handle_option (const char **argv, unsigned int lang_mask)\n     }\n \n   if (option->flags & lang_mask)\n-    if ((*lang_hooks.handle_option) (opt_index, arg, value) == 0)\n+    if (lang_hooks.handle_option (opt_index, arg, value) == 0)\n       result = 0;\n \n   if (result && (option->flags & CL_COMMON))\n@@ -483,7 +483,7 @@ decode_options (unsigned int argc, const char **argv)\n   unsigned int i, lang_mask;\n \n   /* Perform language-specific options initialization.  */\n-  lang_mask = (*lang_hooks.init_options) (argc, argv);\n+  lang_mask = lang_hooks.init_options (argc, argv);\n \n   lang_hooks.initialize_diagnostics (global_dc);\n "}, {"sha": "c730949bcf939fa126222e6491e9e6c5fd57d97a", "filename": "gcc/passes.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -270,7 +270,7 @@ open_dump_file (enum dump_file_index index, tree decl)\n \n   if (decl)\n     fprintf (dump_file, \"\\n;; Function %s%s\\n\\n\",\n-\t     (*lang_hooks.decl_printable_name) (decl, 2),\n+\t     lang_hooks.decl_printable_name (decl, 2),\n \t     cfun->function_frequency == FUNCTION_FREQUENCY_HOT\n \t     ? \" (hot)\"\n \t     : cfun->function_frequency == FUNCTION_FREQUENCY_UNLIKELY_EXECUTED"}, {"sha": "14a70218fc61e6497bdfb20b6e208235a269dd4c", "filename": "gcc/print-tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -418,7 +418,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       print_node (file, \"result\", DECL_RESULT_FLD (node), indent + 4);\n       print_node_brief (file, \"initial\", DECL_INITIAL (node), indent + 4);\n \n-      (*lang_hooks.print_decl) (file, node, indent);\n+      lang_hooks.print_decl (file, node, indent);\n \n       if (DECL_RTL_SET_P (node))\n \t{\n@@ -549,7 +549,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n       if (TYPE_CONTEXT (node))\n \tprint_node_brief (file, \"context\", TYPE_CONTEXT (node), indent + 4);\n \n-      (*lang_hooks.print_type) (file, node, indent);\n+      lang_hooks.print_type (file, node, indent);\n \n       if (TYPE_POINTER_TO (node) || TREE_CHAIN (node))\n \tindent_to (file, indent + 3);\n@@ -708,7 +708,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \t  break;\n \n \tcase IDENTIFIER_NODE:\n-\t  (*lang_hooks.print_identifier) (file, node, indent);\n+\t  lang_hooks.print_identifier (file, node, indent);\n \t  break;\n \n \tcase TREE_LIST:\n@@ -731,7 +731,7 @@ print_node (FILE *file, const char *prefix, tree node, int indent)\n \n \tdefault:\n \t  if (TREE_CODE_CLASS (TREE_CODE (node)) == 'x')\n-\t    (*lang_hooks.print_xnode) (file, node, indent);\n+\t    lang_hooks.print_xnode (file, node, indent);\n \t  break;\n \t}\n "}, {"sha": "3d5da37e8ccaf015217ac5551de2dfc222b14029", "filename": "gcc/stmt.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -868,7 +868,7 @@ expand_fixup (tree tree_label, rtx rtl_label, rtx last_insn)\n \tTREE_USED (block) = 1;\n \n \tif (!cfun->x_whole_function_mode_p)\n-\t  (*lang_hooks.decls.insert_block) (block);\n+\t  lang_hooks.decls.insert_block (block);\n \telse\n \t  {\n \t    BLOCK_CHAIN (block)\n@@ -985,8 +985,8 @@ fixup_gotos (struct nesting *thisblock, rtx stack_level,\n \t     logically be inserting the fixup code.  We do this for the\n \t     sake of getting the debugging information right.  */\n \n-\t  (*lang_hooks.decls.pushlevel) (0);\n-\t  (*lang_hooks.decls.set_block) (f->context);\n+\t  lang_hooks.decls.pushlevel (0);\n+\t  lang_hooks.decls.set_block (f->context);\n \n \t  /* Expand the cleanups for blocks this jump exits.  */\n \t  if (f->cleanup_list_list)\n@@ -1025,7 +1025,7 @@ fixup_gotos (struct nesting *thisblock, rtx stack_level,\n \t     destructed are still \"in scope\".  */\n \n \t  cleanup_insns = get_insns ();\n-\t  (*lang_hooks.decls.poplevel) (1, 0, 0);\n+\t  lang_hooks.decls.poplevel (1, 0, 0);\n \n \t  end_sequence ();\n \t  emit_insn_after (cleanup_insns, f->before_jump);\n@@ -1059,12 +1059,12 @@ fixup_gotos (struct nesting *thisblock, rtx stack_level,\n \t  if (TREE_CHAIN (lists) == thisblock->data.block.outer_cleanups)\n \t    {\n \t      start_sequence ();\n-\t      (*lang_hooks.decls.pushlevel) (0);\n-\t      (*lang_hooks.decls.set_block) (f->context);\n+\t      lang_hooks.decls.pushlevel (0);\n+\t      lang_hooks.decls.set_block (f->context);\n \t      expand_cleanups (TREE_VALUE (lists), 1, 1);\n \t      do_pending_stack_adjust ();\n \t      cleanup_insns = get_insns ();\n-\t      (*lang_hooks.decls.poplevel) (1, 0, 0);\n+\t      lang_hooks.decls.poplevel (1, 0, 0);\n \t      end_sequence ();\n \t      if (cleanup_insns != 0)\n \t\tf->before_jump\n@@ -1552,7 +1552,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t      || (DECL_P (val)\n \t\t  && GET_CODE (DECL_RTL (val)) == REG\n \t\t  && GET_MODE (DECL_RTL (val)) != TYPE_MODE (type))))\n-\t(*lang_hooks.mark_addressable) (val);\n+\tlang_hooks.mark_addressable (val);\n \n       if (is_inout)\n \tninout++;\n@@ -1581,7 +1581,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \treturn;\n \n       if (! allows_reg && allows_mem)\n-\t(*lang_hooks.mark_addressable) (TREE_VALUE (tail));\n+\tlang_hooks.mark_addressable (TREE_VALUE (tail));\n     }\n \n   /* Second pass evaluates arguments.  */\n@@ -4138,12 +4138,12 @@ expand_decl_cleanup (tree decl, tree cleanup)\n \t  emit_move_insn (flag, const1_rtx);\n \n \t  cond = build_decl (VAR_DECL, NULL_TREE,\n-\t\t\t     (*lang_hooks.types.type_for_mode) (word_mode, 1));\n+\t\t\t     lang_hooks.types.type_for_mode (word_mode, 1));\n \t  SET_DECL_RTL (cond, flag);\n \n \t  /* Conditionalize the cleanup.  */\n \t  cleanup = build (COND_EXPR, void_type_node,\n-\t\t\t   (*lang_hooks.truthvalue_conversion) (cond),\n+\t\t\t   lang_hooks.truthvalue_conversion (cond),\n \t\t\t   cleanup, integer_zero_node);\n \t  cleanup = fold (cleanup);\n \n@@ -6464,7 +6464,7 @@ emit_case_nodes (rtx index, case_node_ptr node, rtx default_label,\n \t  else if (!low_bound && !high_bound)\n \t    {\n \t      /* Widen LOW and HIGH to the same width as INDEX.  */\n-\t      tree type = (*lang_hooks.types.type_for_mode) (mode, unsignedp);\n+\t      tree type = lang_hooks.types.type_for_mode (mode, unsignedp);\n \t      tree low = build1 (CONVERT_EXPR, type, node->low);\n \t      tree high = build1 (CONVERT_EXPR, type, node->high);\n \t      rtx low_rtx, new_index, new_bound;"}, {"sha": "792349291718f9dd2e2c05cfddcfcc34bff25f81", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -142,7 +142,7 @@ variable_size (tree size)\n      just return SIZE unchanged.  Likewise for self-referential sizes and\n      constant sizes.  */\n   if (TREE_CONSTANT (size)\n-      || (*lang_hooks.decls.global_bindings_p) () < 0\n+      || lang_hooks.decls.global_bindings_p () < 0\n       || CONTAINS_PLACEHOLDER_P (size))\n     return size;\n \n@@ -164,7 +164,7 @@ variable_size (tree size)\n   if (TREE_CODE (save) == SAVE_EXPR)\n     SAVE_EXPR_PERSISTENT_P (save) = 1;\n \n-  if ((*lang_hooks.decls.global_bindings_p) ())\n+  if (lang_hooks.decls.global_bindings_p ())\n     {\n       if (TREE_CONSTANT (size))\n \terror (\"type size can't be explicitly evaluated\");"}, {"sha": "13bd98e7f8b47ee9b3a5fb04180462ffb11c9f5f", "filename": "gcc/toplev.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1085,7 +1085,7 @@ announce_function (tree decl)\n       if (rtl_dump_and_exit)\n \tverbatim (\"%s \", IDENTIFIER_POINTER (DECL_NAME (decl)));\n       else\n-\tverbatim (\" %s\", (*lang_hooks.decl_printable_name) (decl, 2));\n+\tverbatim (\" %s\", lang_hooks.decl_printable_name (decl, 2));\n       fflush (stderr);\n       pp_needs_newline (global_dc->printer) = true;\n       diagnostic_set_last_function (global_dc);\n@@ -1322,7 +1322,7 @@ wrapup_global_declarations (tree *vec, int len)\n \tDECL_DEFER_OUTPUT (decl) = 0;\n \n       if (TREE_CODE (decl) == VAR_DECL && DECL_SIZE (decl) == 0)\n-\t(*lang_hooks.finish_incomplete_decl) (decl);\n+\tlang_hooks.finish_incomplete_decl (decl);\n     }\n \n   /* Now emit any global variables or functions that we have been\n@@ -1471,7 +1471,7 @@ check_global_declarations (tree *vec, int len)\n \t  /* Global register variables must be declared to reserve them.  */\n \t  && ! (TREE_CODE (decl) == VAR_DECL && DECL_REGISTER (decl))\n \t  /* Otherwise, ask the language.  */\n-\t  && (*lang_hooks.decls.warn_unused_global) (decl))\n+\t  && lang_hooks.decls.warn_unused_global (decl))\n \twarning (\"%J'%D' defined but not used\", decl, decl);\n \n       /* Avoid confusing the debug information machinery when there are\n@@ -1572,11 +1572,11 @@ compile_file (void)\n \n   /* Call the parser, which parses the entire file (calling\n      rest_of_compilation for each function).  */\n-  (*lang_hooks.parse_file) (set_yydebug);\n+  lang_hooks.parse_file (set_yydebug);\n \n   /* In case there were missing block closers,\n      get us back to the global binding level.  */\n-  (*lang_hooks.clear_binding_stack) ();\n+  lang_hooks.clear_binding_stack ();\n \n   /* Compilation is now finished except for writing\n      what's left of the symbol table output.  */\n@@ -1585,7 +1585,7 @@ compile_file (void)\n   if (flag_syntax_only)\n     return;\n \n-  (*lang_hooks.decls.final_write_globals)();\n+  lang_hooks.decls.final_write_globals ();\n \n   cgraph_varpool_assemble_pending_decls ();\n \n@@ -2115,7 +2115,7 @@ default_tree_printer (pretty_printer * pp, text_info *text)\n       {\n         tree t = va_arg (*text->args_ptr, tree);\n         const char *n = DECL_NAME (t)\n-          ? (*lang_hooks.decl_printable_name) (t, 2)\n+          ? lang_hooks.decl_printable_name (t, 2)\n           : \"<anonymous>\";\n         pp_string (pp, n);\n       }\n@@ -2200,7 +2200,7 @@ process_options (void)\n      initialization based on the command line options.  This hook also\n      sets the original filename if appropriate (e.g. foo.i -> foo.c)\n      so we can correctly initialize debug output.  */\n-  no_backend = (*lang_hooks.post_options) (&main_input_filename);\n+  no_backend = lang_hooks.post_options (&main_input_filename);\n   input_filename = main_input_filename;\n \n #ifdef OVERRIDE_OPTIONS\n@@ -2462,7 +2462,7 @@ lang_dependent_init (const char *name)\n     dump_base_name = name ? name : \"gccdump\";\n \n   /* Other front-end initialization.  */\n-  if ((*lang_hooks.init) () == 0)\n+  if (lang_hooks.init () == 0)\n     return 0;\n \n   init_asm_output (name);\n@@ -2538,7 +2538,7 @@ finalize (void)\n   free_reg_info ();\n \n   /* Language-specific end of compilation actions.  */\n-  (*lang_hooks.finish) ();\n+  lang_hooks.finish ();\n }\n \n /* Initialize the compiler, and compile the input file.  */"}, {"sha": "c00cc5fe2eb6b0dc852e755949099b890c8f18d2", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1,5 +1,5 @@\n /* Tree-dumping functionality for intermediate representation.\n-   Copyright (C) 1999, 2000, 2002, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 1999, 2000, 2002, 2003, 2004 Free Software Foundation, Inc.\n    Written by Mark Mitchell <mark@codesourcery.com>\n \n This file is part of GCC.\n@@ -346,7 +346,7 @@ dequeue_and_dump (dump_info_p di)\n   else if (code_class == 't')\n     {\n       /* All types have qualifiers.  */\n-      int quals = (*lang_hooks.tree_dump.type_quals) (t);\n+      int quals = lang_hooks.tree_dump.type_quals (t);\n \n       if (quals != TYPE_UNQUALIFIED)\n \t{\n@@ -377,7 +377,7 @@ dequeue_and_dump (dump_info_p di)\n   /* Give the language-specific code a chance to print something.  If\n      it's completely taken care of things, don't bother printing\n      anything more ourselves.  */\n-  if ((*lang_hooks.tree_dump.dump_tree) (di, t))\n+  if (lang_hooks.tree_dump.dump_tree (di, t))\n     goto done;\n \n   /* Now handle the various kinds of nodes.  */"}, {"sha": "1d410af400f1e719608df9b252c63daec9b49ec4", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -154,7 +154,7 @@ remap_decl (tree decl, inline_data *id)\n \n   /* We only remap local variables in the current function.  */\n   fn = VARRAY_TOP_TREE (id->fns);\n-  if (! (*lang_hooks.tree_inlining.auto_var_in_fn_p) (decl, fn))\n+  if (! lang_hooks.tree_inlining.auto_var_in_fn_p (decl, fn))\n     return NULL_TREE;\n \n   /* See if we have remapped this declaration.  */\n@@ -183,7 +183,7 @@ remap_decl (tree decl, inline_data *id)\n \n #ifndef INLINER_FOR_JAVA\n       if (! DECL_NAME (t) && TREE_TYPE (t)\n-\t  && (*lang_hooks.tree_inlining.anon_aggr_type_p) (TREE_TYPE (t)))\n+\t  && lang_hooks.tree_inlining.anon_aggr_type_p (TREE_TYPE (t)))\n \t{\n \t  /* For a VAR_DECL of anonymous type, we must also copy the\n \t     member VAR_DECLS here and rechain the DECL_ANON_UNION_ELEMS.  */\n@@ -390,7 +390,7 @@ remap_block (tree *block, tree decls, inline_data *id)\n \t/* We're building a clone; DECL_INITIAL is still\n \t   error_mark_node, and current_binding_level is the parm\n \t   binding level.  */\n-\t(*lang_hooks.decls.insert_block) (new_block);\n+\tlang_hooks.decls.insert_block (new_block);\n       else\n \t{\n \t  /* Attach this new block after the DECL_INITIAL block for the\n@@ -588,7 +588,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n      variables.  We don't want to copy static variables; there's only\n      one of those, no matter how many times we inline the containing\n      function.  */\n-  else if ((*lang_hooks.tree_inlining.auto_var_in_fn_p) (*tp, fn))\n+  else if (lang_hooks.tree_inlining.auto_var_in_fn_p (*tp, fn))\n     {\n       tree new_decl;\n \n@@ -648,7 +648,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n     {\n       if (TREE_CODE (*tp) == MODIFY_EXPR\n \t  && TREE_OPERAND (*tp, 0) == TREE_OPERAND (*tp, 1)\n-\t  && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n+\t  && (lang_hooks.tree_inlining.auto_var_in_fn_p\n \t      (TREE_OPERAND (*tp, 0), fn)))\n \t{\n \t  /* Some assignments VAR = VAR; don't generate any rtl code\n@@ -670,7 +670,7 @@ copy_body_r (tree *tp, int *walk_subtrees, void *data)\n \t    }\n \t}\n       else if (TREE_CODE (*tp) == ADDR_EXPR\n-\t       && ((*lang_hooks.tree_inlining.auto_var_in_fn_p)\n+\t       && (lang_hooks.tree_inlining.auto_var_in_fn_p\n \t\t   (TREE_OPERAND (*tp, 0), fn)))\n \t{\n \t  /* Get rid of &* from inline substitutions.  It can occur when\n@@ -764,7 +764,7 @@ DECL_ARGUMENTS (fn);\n       ++argnum;\n \n       /* Find the initializer.  */\n-      value = (*lang_hooks.tree_inlining.convert_parm_for_inlining)\n+      value = lang_hooks.tree_inlining.convert_parm_for_inlining\n \t      (p, a ? TREE_VALUE (a) : NULL_TREE, fn, argnum);\n \n       /* If the parameter is never assigned to, we may not need to\n@@ -860,7 +860,7 @@ DECL_ARGUMENTS (fn);\n \t}\n \n       /* See if we need to clean up the declaration.  */\n-      cleanup = (*lang_hooks.maybe_build_cleanup) (var);\n+      cleanup = lang_hooks.maybe_build_cleanup (var);\n       if (cleanup)\n \t{\n \t  tree cleanup_stmt;\n@@ -946,7 +946,7 @@ declare_return_variable (struct inline_data *id, tree return_slot_addr,\n     }\n \n #ifndef INLINER_FOR_JAVA\n-  var = ((*lang_hooks.tree_inlining.copy_res_decl_for_inlining)\n+  var = (lang_hooks.tree_inlining.copy_res_decl_for_inlining\n \t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n \t  &need_return_decl, return_slot_addr));\n \n@@ -970,7 +970,7 @@ declare_return_variable (struct inline_data *id, tree return_slot_addr,\n   if (need_return_decl)\n     return build_stmt (DECL_STMT, var);\n #else /* INLINER_FOR_JAVA */\n-  *var = ((*lang_hooks.tree_inlining.copy_res_decl_for_inlining)\n+  *var = (lang_hooks.tree_inlining.copy_res_decl_for_inlining\n \t (result, fn, VARRAY_TREE (id->fns, 0), id->decl_map,\n \t  &need_return_decl, return_slot_addr));\n \n@@ -1170,7 +1170,7 @@ inlinable_function_p (tree fn)\n      in C++ it may result in template instantiation.)\n      If the function is not inlinable for language-specific reasons,\n      it is left up to the langhook to explain why.  */\n-  inlinable = !(*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn);\n+  inlinable = !lang_hooks.tree_inlining.cannot_inline_tree_fn (&fn);\n \n   /* If we don't have the function body available, we can't inline it.\n      However, this should not be recorded since we also get here for\n@@ -1352,7 +1352,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n       return NULL_TREE;\n     }\n \n-  if (! (*lang_hooks.tree_inlining.start_inlining) (fn))\n+  if (! lang_hooks.tree_inlining.start_inlining (fn))\n     return NULL_TREE;\n \n   /* Set the current filename and line number to the function we are\n@@ -1592,7 +1592,7 @@ expand_call_inline (tree *tp, int *walk_subtrees, void *data)\n   /* Don't walk into subtrees.  We've already handled them above.  */\n   *walk_subtrees = 0;\n \n-  (*lang_hooks.tree_inlining.end_inlining) (fn);\n+  lang_hooks.tree_inlining.end_inlining (fn);\n \n   /* Keep iterating.  */\n   return NULL_TREE;\n@@ -1642,7 +1642,7 @@ optimize_inline_calls (tree fn)\n       prev_fn = current_function_decl;\n     }\n \n-  prev_fn = ((*lang_hooks.tree_inlining.add_pending_fn_decls)\n+  prev_fn = (lang_hooks.tree_inlining.add_pending_fn_decls\n \t     (&id.fns, prev_fn));\n \n   /* Create the list of functions this call will inline.  */\n@@ -1763,7 +1763,7 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n   if (!walk_subtrees)\n     {\n       if (STATEMENT_CODE_P (code) || code == TREE_LIST\n-\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n+\t  || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n \t/* But we still need to check our siblings.  */\n \tWALK_SUBTREE_TAIL (TREE_CHAIN (*tp));\n       else\n@@ -1838,8 +1838,8 @@ walk_tree (tree *tp, walk_tree_fn func, void *data, void *htab_)\n       /* Also examine various special fields, below.  */\n     }\n \n-  result = (*lang_hooks.tree_inlining.walk_subtrees) (tp, &walk_subtrees, func,\n-\t\t\t\t\t\t      data, htab);\n+  result = lang_hooks.tree_inlining.walk_subtrees (tp, &walk_subtrees, func,\n+\t\t\t\t\t\t   data, htab);\n   if (result || ! walk_subtrees)\n     return result;\n \n@@ -1973,7 +1973,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       || TREE_CODE_CLASS (code) == 'c'\n       || code == TREE_LIST\n       || code == TREE_VEC\n-      || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n+      || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n     {\n       /* Because the chain gets clobbered when we make a copy, we save it\n \t here.  */\n@@ -1986,7 +1986,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n \t walk_tree to walk into the chain as well.  */\n       if (code == PARM_DECL || code == TREE_LIST\n #ifndef INLINER_FOR_JAVA\n-\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp)\n+\t  || lang_hooks.tree_inlining.tree_chain_matters_p (*tp)\n \t  || STATEMENT_CODE_P (code))\n \tTREE_CHAIN (*tp) = chain;\n \n@@ -1995,7 +1995,7 @@ copy_tree_r (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n       if (TREE_CODE (*tp) == SCOPE_STMT)\n \tSCOPE_STMT_BLOCK (*tp) = NULL_TREE;\n #else /* INLINER_FOR_JAVA */\n-\t  || (*lang_hooks.tree_inlining.tree_chain_matters_p) (*tp))\n+\t  || lang_hooks.tree_inlining.tree_chain_matters_p (*tp))\n \tTREE_CHAIN (*tp) = chain;\n #endif /* INLINER_FOR_JAVA */\n     }"}, {"sha": "b1be8b0270bc95460a86228d6af2f54c7f0be1a8", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -131,7 +131,7 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n   expand_function_start (fndecl, 0);\n \n   /* Allow language dialects to perform special processing.  */\n-  (*lang_hooks.rtl_expand.start) ();\n+  lang_hooks.rtl_expand.start ();\n \n   /* If this function is `main', emit a call to `__main'\n      to run global initializers, etc.  */\n@@ -141,7 +141,7 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n     expand_main_function ();\n \n   /* Generate the RTL for this function.  */\n-  (*lang_hooks.rtl_expand.stmt) (DECL_SAVED_TREE (fndecl));\n+  lang_hooks.rtl_expand.stmt (DECL_SAVED_TREE (fndecl));\n \n   /* We hard-wired immediate_size_expand to zero above.\n      expand_function_end will decrement this variable.  So, we set the\n@@ -150,7 +150,7 @@ tree_rest_of_compilation (tree fndecl, bool nested_p)\n   immediate_size_expand = 1;\n \n   /* Allow language dialects to perform special processing.  */\n-  (*lang_hooks.rtl_expand.end) ();\n+  lang_hooks.rtl_expand.end ();\n \n   /* Generate rtl for function exit.  */\n   expand_function_end ();"}, {"sha": "8238ea407abf0c893dda915414bb6e1eea63a73e", "filename": "gcc/tree.c", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -131,7 +131,7 @@ tree\n decl_assembler_name (tree decl)\n {\n   if (!DECL_ASSEMBLER_NAME_SET_P (decl))\n-    (*lang_hooks.set_decl_assembler_name) (decl);\n+    lang_hooks.set_decl_assembler_name (decl);\n   return DECL_CHECK (decl)->decl.assembler_name;\n }\n \n@@ -171,7 +171,7 @@ tree_size (tree node)\n \tcase VECTOR_CST:\treturn sizeof (struct tree_vector);\n \tcase STRING_CST:\treturn sizeof (struct tree_string);\n \tdefault:\n-\t  return (*lang_hooks.tree_size) (code);\n+\t  return lang_hooks.tree_size (code);\n \t}\n \n     case 'x':  /* something random, like an identifier.  */\n@@ -187,7 +187,7 @@ tree_size (tree node)\n \tcase PLACEHOLDER_EXPR:\treturn sizeof (struct tree_common);\n \n \tdefault:\n-\t  return (*lang_hooks.tree_size) (code);\n+\t  return lang_hooks.tree_size (code);\n \t}\n \n     default:\n@@ -1119,7 +1119,7 @@ size_in_bytes (tree type)\n \n   if (t == 0)\n     {\n-      (*lang_hooks.types.incomplete_type_error) (NULL_TREE, type);\n+      lang_hooks.types.incomplete_type_error (NULL_TREE, type);\n       return size_zero_node;\n     }\n \n@@ -1313,7 +1313,7 @@ staticp (tree arg)\n     default:\n       if ((unsigned int) TREE_CODE (arg)\n \t  >= (unsigned int) LAST_AND_UNUSED_TREE_CODE)\n-\treturn (*lang_hooks.staticp) (arg);\n+\treturn lang_hooks.staticp (arg);\n       else\n \treturn 0;\n     }\n@@ -1653,7 +1653,7 @@ unsafe_for_reeval (tree expr)\n       return exp ? unsafe_for_reeval (exp) : 0;\n \n     default:\n-      tmp = (*lang_hooks.unsafe_for_reeval) (expr);\n+      tmp = lang_hooks.unsafe_for_reeval (expr);\n       if (tmp >= 0)\n \treturn tmp;\n       break;\n@@ -4290,7 +4290,7 @@ get_unwidened (tree op, tree for_type)\n \t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n       int unsignedp = (TREE_UNSIGNED (TREE_OPERAND (op, 1))\n \t\t       || TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n-      type = (*lang_hooks.types.type_for_size) (innerprec, unsignedp);\n+      type = lang_hooks.types.type_for_size (innerprec, unsignedp);\n \n       /* We can get this structure field in the narrowest type it fits in.\n \t If FOR_TYPE is 0, do this only for a field that matches the\n@@ -4375,7 +4375,7 @@ get_narrower (tree op, int *unsignedp_ptr)\n \t= tree_low_cst (DECL_SIZE (TREE_OPERAND (op, 1)), 1);\n       int unsignedp = (TREE_UNSIGNED (TREE_OPERAND (op, 1))\n \t\t       || TREE_UNSIGNED (TREE_TYPE (TREE_OPERAND (op, 1))));\n-      tree type = (*lang_hooks.types.type_for_size) (innerprec, unsignedp);\n+      tree type = lang_hooks.types.type_for_size (innerprec, unsignedp);\n \n       /* We can get this structure field in a narrower type that fits it,\n \t but the resulting extension to its nominal type (a fullword type)\n@@ -4539,7 +4539,7 @@ variably_modified_type_p (tree type)\n \n   /* The current language may have other cases to check, but in general,\n      all other types are not variably modified.  */\n-  return (*lang_hooks.tree_inlining.var_mod_type_p) (type);\n+  return lang_hooks.tree_inlining.var_mod_type_p (type);\n }\n \n /* Given a DECL or TYPE, return the scope in which it was declared, or\n@@ -4660,7 +4660,7 @@ get_callee_fndecl (tree call)\n   \n   /* We couldn't figure out what was being called.  Maybe the front\n      end has some idea.  */\n-  return (*lang_hooks.lang_get_callee_fndecl) (call);\n+  return lang_hooks.lang_get_callee_fndecl (call);\n }\n \n /* Print debugging information about tree nodes generated during the compile,\n@@ -4693,7 +4693,7 @@ dump_tree_statistics (void)\n   fprintf (stderr, \"(No per-node statistics)\\n\");\n #endif\n   print_type_hash_statistics ();\n-  (*lang_hooks.print_statistics) ();\n+  lang_hooks.print_statistics ();\n }\n \f\n #define FILE_FUNCTION_FORMAT \"_GLOBAL__%s_%s\""}, {"sha": "9cf8b94f15aadfca2eb4b813f6afbe34a3905cf1", "filename": "gcc/varasm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ae2bcd98fa6d0e389638e2c3cf4cf8a6c79809b4", "patch": "@@ -1297,7 +1297,7 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n   rtx decl_rtl;\n \n   if (lang_hooks.decls.prepare_assemble_variable)\n-    (*lang_hooks.decls.prepare_assemble_variable) (decl);\n+    lang_hooks.decls.prepare_assemble_variable (decl);\n \n   last_assemble_variable_decl = 0;\n \n@@ -2250,8 +2250,8 @@ compare_constant (const tree t1, const tree t2)\n     default:\n       {\n \ttree nt1, nt2;\n-\tnt1 = (*lang_hooks.expand_constant) (t1);\n-\tnt2 = (*lang_hooks.expand_constant) (t2);\n+\tnt1 = lang_hooks.expand_constant (t1);\n+\tnt2 = lang_hooks.expand_constant (t2);\n \tif (nt1 != t1 || nt2 != t2)\n \t  return compare_constant (nt1, nt2);\n \telse\n@@ -2322,7 +2322,7 @@ copy_constant (tree exp)\n     default:\n       {\n \ttree t;\n-\tt = (*lang_hooks.expand_constant) (exp);\n+\tt = lang_hooks.expand_constant (exp);\n \tif (t != exp)\n \t  return copy_constant (t);\n \telse\n@@ -2745,7 +2745,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n   align = GET_MODE_ALIGNMENT (mode == VOIDmode ? word_mode : mode);\n #ifdef CONSTANT_ALIGNMENT\n   {\n-    tree type = (*lang_hooks.types.type_for_mode) (mode, 0);\n+    tree type = lang_hooks.types.type_for_mode (mode, 0);\n     if (type != NULL_TREE)\n       align = CONSTANT_ALIGNMENT (make_tree (type, x), align);\n   }\n@@ -2789,7 +2789,7 @@ force_const_mem (enum machine_mode mode, rtx x)\n \n   /* Construct the MEM.  */\n   desc->mem = def = gen_rtx_MEM (mode, symbol);\n-  set_mem_attributes (def, (*lang_hooks.types.type_for_mode) (mode, 0), 1);\n+  set_mem_attributes (def, lang_hooks.types.type_for_mode (mode, 0), 1);\n   RTX_UNCHANGING_P (def) = 1;\n \n   /* If we're dropping a label to the constant pool, make sure we\n@@ -3113,7 +3113,7 @@ compute_reloc_for_constant (tree exp)\n \n   /* Give the front-end a chance to convert VALUE to something that\n      looks more like a constant to the back-end.  */\n-  exp = (*lang_hooks.expand_constant) (exp);\n+  exp = lang_hooks.expand_constant (exp);\n \n   switch (TREE_CODE (exp))\n     {\n@@ -3177,7 +3177,7 @@ output_addressed_constants (tree exp)\n \n   /* Give the front-end a chance to convert VALUE to something that\n      looks more like a constant to the back-end.  */\n-  exp = (*lang_hooks.expand_constant) (exp);\n+  exp = lang_hooks.expand_constant (exp);\n \n   switch (TREE_CODE (exp))\n     {\n@@ -3233,7 +3233,7 @@ initializer_constant_valid_p (tree value, tree endtype)\n {\n   /* Give the front-end a chance to convert VALUE to something that\n      looks more like a constant to the back-end.  */\n-  value = (*lang_hooks.expand_constant) (value);\n+  value = lang_hooks.expand_constant (value);\n \n   switch (TREE_CODE (value))\n     {\n@@ -3461,7 +3461,7 @@ output_constant (tree exp, unsigned HOST_WIDE_INT size, unsigned int align)\n   /* Some front-ends use constants other than the standard language-independent\n      varieties, but which may still be output directly.  Give the front-end a\n      chance to convert EXP to a language-independent representation.  */\n-  exp = (*lang_hooks.expand_constant) (exp);\n+  exp = lang_hooks.expand_constant (exp);\n \n   if (size == 0 || flag_syntax_only)\n     return;"}]}