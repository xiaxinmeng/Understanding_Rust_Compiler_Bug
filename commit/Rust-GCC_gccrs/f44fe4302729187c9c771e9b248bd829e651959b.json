{"sha": "f44fe4302729187c9c771e9b248bd829e651959b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ0ZmU0MzAyNzI5MTg3YzljNzcxZTliMjQ4YmQ4MjllNjUxOTU5Yg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-03-15T16:00:26Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-03-15T16:00:26Z"}, "message": "re PR ada/19900 (ACATS c391002 c432002 ICE categorize_ctor_elements_1)\n\n2005-03-08  Robert Dewar  <dewar@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\t    Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\tPR ada/19900\n\n\t* exp_pakd.adb (Create_Packed_Array_Type): Do not set\n\tMust_Be_Byte_Aligned for cases where we do not need to use a\n\tSystem.Pack_nn unit.\n\n\t* exp_ch6.adb (Expand_Call): Call Expand_Actuals for functions as well\n\tas procedures.\n\tNeeded now that we do some processing for IN parameters as well. This\n\tmay well fix some unrelated errors.\n\t(Expand_Call): Handle case of unaligned objects (in particular those\n\tthat come from packed arrays).\n\t(Expand_Inlined_Call): If the subprogram is a renaming as body, and the\n\trenamed entity is an inherited operation, re-expand the call using the\n\toriginal operation, which is the one to call.\n\tDetect attempt to inline parameterless recursive subprogram.\n\t(Represented_As_Scalar): Fix to work properly with private types\n\t(Is_Possibly_Unaligned_Object): Major rewrite to get a much more\n\taccurate estimate. Yields True in far fewer cases than before,\n\timproving the quality of code that depends on this test.\n\t(Remove_Side_Effects): Properly test for Expansion_Delayed and handle\n\tcase when it's inside an N_Qualified_Expression.\n\n\t* exp_util.adb (Kill_Dead_Code): For a package declaration, iterate\n\tover both visible and private declarations to remove them from tree,\n\tand mark subprograms declared in package as eliminated, to prevent\n\tspurious use in subsequent compilation of generic units in the context.\n\n\t* exp_util.ads: Minor cleanup in variable names\n\n\t* sem_eval.ads, sem_eval.adb: Minor reformatting\n\t(Compile_Time_Known_Bounds): New function\n\nFrom-SVN: r96493", "tree": {"sha": "5be40e694aeb8be74ad16390f5abbfdfd79db33d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5be40e694aeb8be74ad16390f5abbfdfd79db33d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f44fe4302729187c9c771e9b248bd829e651959b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44fe4302729187c9c771e9b248bd829e651959b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f44fe4302729187c9c771e9b248bd829e651959b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f44fe4302729187c9c771e9b248bd829e651959b/comments", "author": null, "committer": null, "parents": [{"sha": "c6823a20b27d6a03efb122e7e20153adb2d805ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6823a20b27d6a03efb122e7e20153adb2d805ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6823a20b27d6a03efb122e7e20153adb2d805ed"}], "stats": {"total": 523, "additions": 369, "deletions": 154}, "files": [{"sha": "d0ccfb28cdc31fac6a0c75112dd1a006fbed4423", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 120, "deletions": 65, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -123,6 +123,9 @@ package body Exp_Ch6 is\n    --\n    --  For all parameter modes, actuals that denote components and slices\n    --  of packed arrays are expanded into suitable temporaries.\n+   --\n+   --  For non-scalar objects that are possibly unaligned, add call by copy\n+   --  code (copy in for IN and IN OUT, copy out for OUT and IN OUT).\n \n    procedure Expand_Inlined_Call\n     (N         : Node_Id;\n@@ -501,11 +504,10 @@ package body Exp_Ch6 is\n       --  also takes care of any constraint checks required for the type\n       --  conversion case (on both the way in and the way out).\n \n-      procedure Add_Packed_Call_By_Copy_Code;\n-      --  This is used when the actual involves a reference to an element\n-      --  of a packed array, where we can appropriately use a simpler\n-      --  approach than the full call by copy code. We just copy the value\n-      --  in and out of an appropriate temporary.\n+      procedure Add_Simple_Call_By_Copy_Code;\n+      --  This is similar to the above, but is used in cases where we know\n+      --  that all that is needed is to simply create a temporary and copy\n+      --  the value in and out of the temporary.\n \n       procedure Check_Fortran_Logical;\n       --  A value of type Logical that is passed through a formal parameter\n@@ -532,7 +534,7 @@ package body Exp_Ch6 is\n          Expr  : Node_Id;\n          Init  : Node_Id;\n          Temp  : Entity_Id;\n-         Indic : Node_Id := New_Occurrence_Of (Etype (Formal), Loc);\n+         Indic : Node_Id;\n          Var   : Entity_Id;\n          F_Typ : constant Entity_Id := Etype (Formal);\n          V_Typ : Entity_Id;\n@@ -541,6 +543,17 @@ package body Exp_Ch6 is\n       begin\n          Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n \n+         --  Use formal type for temp, unless formal type is an unconstrained\n+         --  array, in which case we don't have to worry about bounds checks,\n+         --  and we use the actual type, since that has appropriate bonds.\n+\n+         if Is_Array_Type (F_Typ) and then not Is_Constrained (F_Typ) then\n+            Indic := New_Occurrence_Of (Etype (Actual), Loc);\n+         else\n+            Indic := New_Occurrence_Of (Etype (Formal), Loc);\n+         end if;\n+\n+\n          if Nkind (Actual) = N_Type_Conversion then\n             V_Typ := Etype (Expression (Actual));\n \n@@ -584,7 +597,7 @@ package body Exp_Ch6 is\n             then\n                --  Actual is a one-dimensional array or slice, and the type\n                --  requires no initialization. Create a temporary of the\n-               --  right size, but do copy actual into it (optimization).\n+               --  right size, but do not copy actual into it (optimization).\n \n                Init := Empty;\n                Indic :=\n@@ -621,11 +634,9 @@ package body Exp_Ch6 is\n                      Is_Bit_Packed_Array (Etype (Expression (Actual))))\n          then\n             if Conversion_OK (Actual) then\n-               Init :=\n-                 OK_Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n+               Init := OK_Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n             else\n-               Init :=\n-                 Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n+               Init := Convert_To (F_Typ, New_Occurrence_Of (Var, Loc));\n             end if;\n \n          elsif Ekind (Formal) = E_In_Parameter then\n@@ -639,7 +650,7 @@ package body Exp_Ch6 is\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n              Object_Definition   => Indic,\n-             Expression => Init);\n+             Expression          => Init);\n          Set_Assignment_OK (N_Node);\n          Insert_Action (N, N_Node);\n \n@@ -700,21 +711,33 @@ package body Exp_Ch6 is\n       end Add_Call_By_Copy_Code;\n \n       ----------------------------------\n-      -- Add_Packed_Call_By_Copy_Code --\n+      -- Add_Simple_Call_By_Copy_Code --\n       ----------------------------------\n \n-      procedure Add_Packed_Call_By_Copy_Code is\n+      procedure Add_Simple_Call_By_Copy_Code is\n          Temp   : Entity_Id;\n          Incod  : Node_Id;\n          Outcod : Node_Id;\n          Lhs    : Node_Id;\n          Rhs    : Node_Id;\n+         Indic  : Node_Id;\n+         F_Typ  : constant Entity_Id := Etype (Formal);\n \n       begin\n-         Reset_Packed_Prefix;\n+         --  Use formal type for temp, unless formal type is an unconstrained\n+         --  array, in which case we don't have to worry about bounds checks,\n+         --  and we use the actual type, since that has appropriate bonds.\n+\n+         if Is_Array_Type (F_Typ) and then not Is_Constrained (F_Typ) then\n+            Indic := New_Occurrence_Of (Etype (Actual), Loc);\n+         else\n+            Indic := New_Occurrence_Of (Etype (Formal), Loc);\n+         end if;\n \n          --  Prepare to generate code\n \n+         Reset_Packed_Prefix;\n+\n          Temp := Make_Defining_Identifier (Loc, New_Internal_Name ('T'));\n          Incod  := Relocate_Node (Actual);\n          Outcod := New_Copy_Tree (Incod);\n@@ -729,9 +752,8 @@ package body Exp_Ch6 is\n          Insert_Action (N,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Temp,\n-             Object_Definition   =>\n-               New_Occurrence_Of (Etype (Formal), Loc),\n-             Expression => Incod));\n+             Object_Definition   => Indic,\n+             Expression          => Incod));\n \n          --  The actual is simply a reference to the temporary\n \n@@ -754,8 +776,9 @@ package body Exp_Ch6 is\n               Make_Assignment_Statement (Loc,\n                 Name       => Lhs,\n                 Expression => Rhs));\n+            Set_Assignment_OK (Name (Last (Post_Call)));\n          end if;\n-      end Add_Packed_Call_By_Copy_Code;\n+      end Add_Simple_Call_By_Copy_Code;\n \n       ---------------------------\n       -- Check_Fortran_Logical --\n@@ -930,7 +953,14 @@ package body Exp_Ch6 is\n             --  [in] out parameters.\n \n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n-               Add_Packed_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code;\n+\n+            --  If a non-scalar actual is possibly unaligned, we need a copy\n+\n+            elsif Is_Possibly_Unaligned_Object (Actual)\n+              and then not Represented_As_Scalar (Etype (Formal))\n+            then\n+               Add_Simple_Call_By_Copy_Code;\n \n             --  References to slices of bit packed arrays are expanded\n \n@@ -983,7 +1013,7 @@ package body Exp_Ch6 is\n             --  the special processing above for the OUT and IN OUT cases\n             --  could be performed. We could make the test in Exp_Ch4 more\n             --  complex and have it detect the parameter mode, but it is\n-            --  easier simply to handle all cases here.\n+            --  easier simply to handle all cases here.)\n \n             if Nkind (Actual) = N_Indexed_Component\n               and then Is_Packed (Etype (Prefix (Actual)))\n@@ -997,7 +1027,14 @@ package body Exp_Ch6 is\n             --  Is this really necessary in all cases???\n \n             elsif Is_Ref_To_Bit_Packed_Array (Actual) then\n-               Add_Packed_Call_By_Copy_Code;\n+               Add_Simple_Call_By_Copy_Code;\n+\n+            --  If a non-scalar actual is possibly unaligned, we need a copy\n+\n+            elsif Is_Possibly_Unaligned_Object (Actual)\n+              and then not Represented_As_Scalar (Etype (Formal))\n+            then\n+               Add_Simple_Call_By_Copy_Code;\n \n             --  Similarly, we have to expand slices of packed arrays here\n             --  because the result must be byte aligned.\n@@ -1768,13 +1805,10 @@ package body Exp_Ch6 is\n          end loop;\n       end if;\n \n-      if Ekind (Subp) = E_Procedure\n-         or else (Ekind (Subp) = E_Subprogram_Type\n-                   and then Etype (Subp) = Standard_Void_Type)\n-         or else Is_Entry (Subp)\n-      then\n-         Expand_Actuals (N, Subp);\n-      end if;\n+      --  At this point we have all the actuals, so this is the point at\n+      --  which the various expansion activities for actuals is carried out.\n+\n+      Expand_Actuals (N, Subp);\n \n       --  If the subprogram is a renaming, or if it is inherited, replace it\n       --  in the call with the name of the actual subprogram being called.\n@@ -1924,14 +1958,17 @@ package body Exp_Ch6 is\n                        Designated_Type (Base_Type (Etype (Ptr)));\n \n             begin\n-               Obj := Make_Selected_Component (Loc,\n-                 Prefix => Unchecked_Convert_To (T, Ptr),\n-                 Selector_Name => New_Occurrence_Of (First_Entity (T), Loc));\n-\n-               Nam := Make_Selected_Component (Loc,\n-                 Prefix => Unchecked_Convert_To (T, Ptr),\n-                 Selector_Name => New_Occurrence_Of (\n-                   Next_Entity (First_Entity (T)), Loc));\n+               Obj :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => Unchecked_Convert_To (T, Ptr),\n+                   Selector_Name =>\n+                     New_Occurrence_Of (First_Entity (T), Loc));\n+\n+               Nam :=\n+                 Make_Selected_Component (Loc,\n+                   Prefix        => Unchecked_Convert_To (T, Ptr),\n+                   Selector_Name =>\n+                     New_Occurrence_Of (Next_Entity (First_Entity (T)), Loc));\n \n                Nam := Make_Explicit_Dereference (Loc, Nam);\n \n@@ -2621,11 +2658,11 @@ package body Exp_Ch6 is\n    --  Start of processing for Expand_Inlined_Call\n \n    begin\n-      --  Check for special case of To_Address call, and if so, just\n-      --  do an unchecked conversion instead of expanding the call.\n-      --  Not only is this more efficient, but it also avoids a\n-      --  problem with order of elaboration when address clauses\n-      --  are inlined (address expr elaborated at wrong point).\n+      --  Check for special case of To_Address call, and if so, just do an\n+      --  unchecked conversion instead of expanding the call. Not only is this\n+      --  more efficient, but it also avoids problem with order of elaboration\n+      --  when address clauses are inlined (address expr elaborated at wrong\n+      --  point).\n \n       if Subp = RTE (RE_To_Address) then\n          Rewrite (N,\n@@ -2635,13 +2672,31 @@ package body Exp_Ch6 is\n          return;\n       end if;\n \n+      --  Check for an illegal attempt to inline a recursive procedure. If the\n+      --  subprogram has parameters this is detected when trying to supply a\n+      --  binding for parameters that already have one. For parameterless\n+      --  subprograms this must be done explicitly.\n+\n+      if In_Open_Scopes (Subp) then\n+         Error_Msg_N (\"call to recursive subprogram cannot be inlined?\", N);\n+         Set_Is_Inlined (Subp, False);\n+         return;\n+      end if;\n+\n       if Nkind (Orig_Bod) = N_Defining_Identifier then\n \n          --  Subprogram is a renaming_as_body. Calls appearing after the\n          --  renaming can be replaced with calls to the renamed entity\n-         --  directly, because the subprograms are subtype conformant.\n+         --  directly, because the subprograms are subtype conformant. If\n+         --  the renamed subprogram is an inherited operation, we must redo\n+         --  the expansion because implicit conversions may be needed.\n \n          Set_Name (N, New_Occurrence_Of (Orig_Bod, Loc));\n+\n+         if Present (Alias (Orig_Bod)) then\n+            Expand_Call (N);\n+         end if;\n+\n          return;\n       end if;\n \n@@ -2685,10 +2740,10 @@ package body Exp_Ch6 is\n          end if;\n \n          --  If the argument may be a controlling argument in a call within\n-         --  the inlined body, we must preserve its classwide nature to\n-         --  insure that dynamic dispatching take place subsequently.\n-         --  If the formal has a constraint it must be preserved to retain\n-         --  the semantics of the body.\n+         --  the inlined body, we must preserve its classwide nature to insure\n+         --  that dynamic dispatching take place subsequently. If the formal\n+         --  has a constraint it must be preserved to retain the semantics of\n+         --  the body.\n \n          if Is_Class_Wide_Type (Etype (F))\n            or else (Is_Access_Type (Etype (F))\n@@ -2847,7 +2902,7 @@ package body Exp_Ch6 is\n       end if;\n \n       --  Analyze Blk with In_Inlined_Body set, to avoid spurious errors on\n-      --  conflicting private views that Gigi would ignore. If this is a\n+      --  conflicting private views that Gigi would ignore. If this is\n       --  predefined unit, analyze with checks off, as is done in the non-\n       --  inlined run-time units.\n \n@@ -2924,8 +2979,8 @@ package body Exp_Ch6 is\n \n          elsif Requires_Transient_Scope (Typ) then\n \n-            --  Verify that the return type of the enclosing function has\n-            --  the same constrained status as that of the expression.\n+            --  Verify that the return type of the enclosing function has the\n+            --  same constrained status as that of the expression.\n \n             while Ekind (S) /= E_Function loop\n                S := Scope (S);\n@@ -2968,16 +3023,16 @@ package body Exp_Ch6 is\n \n    begin\n       --  A special check. If stack checking is enabled, and the return type\n-      --  might generate a large temporary, and the call is not the right\n-      --  side of an assignment, then generate an explicit temporary. We do\n-      --  this because otherwise gigi may generate a large temporary on the\n-      --  fly and this can cause trouble with stack checking.\n+      --  might generate a large temporary, and the call is not the right side\n+      --  of an assignment, then generate an explicit temporary. We do this\n+      --  because otherwise gigi may generate a large temporary on the fly and\n+      --  this can cause trouble with stack checking.\n \n       --  This is unecessary if the call is the expression in an object\n-      --  declaration, or if it appears outside of any library unit. This\n-      --  can only happen if it appears as an actual in a library-level\n-      --  instance, in which case a temporary will be generated for it once\n-      --  the instance itself is installed.\n+      --  declaration, or if it appears outside of any library unit. This can\n+      --  only happen if it appears as an actual in a library-level instance,\n+      --  in which case a temporary will be generated for it once the instance\n+      --  itself is installed.\n \n       if May_Generate_Large_Temp (Typ)\n         and then not Rhs_Of_Assign_Or_Decl (N)\n@@ -2986,10 +3041,10 @@ package body Exp_Ch6 is\n       then\n          if Stack_Checking_Enabled then\n \n-            --  Note: it might be thought that it would be OK to use a call\n-            --  to Force_Evaluation here, but that's not good enough, because\n-            --  that can results in a 'Reference construct that may still\n-            --  need a temporary.\n+            --  Note: it might be thought that it would be OK to use a call to\n+            --  Force_Evaluation here, but that's not good enough, because\n+            --  that can results in a 'Reference construct that may still need\n+            --  a temporary.\n \n             declare\n                Loc      : constant Source_Ptr := Sloc (N);\n@@ -3086,9 +3141,9 @@ package body Exp_Ch6 is\n    --  Add poll call if ATC polling is enabled, unless the body will be\n    --  inlined by the back-end.\n \n-   --  Add return statement if last statement in body is not a return\n-   --  statement (this makes things easier on Gigi which does not want\n-   --  to have to handle a missing return).\n+   --  Add return statement if last statement in body is not a return statement\n+   --  (this makes things easier on Gigi which does not want to have to handle\n+   --  a missing return).\n \n    --  Add call to Activate_Tasks if body is a task activator\n "}, {"sha": "a8b010c9a823f65d6ba33437b5377107ac0d710e", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2004 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2005 Free Software Foundation, Inc.          --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1219,9 +1219,13 @@ package body Exp_Pakd is\n \n          --  Currently the code in this unit requires that packed arrays\n          --  represented by non-modular arrays of bytes be on a byte\n-         --  boundary.\n+         --  boundary for bit sizes handled by System.Pack_nn units.\n+         --  That's because these units assume the array being accessed\n+         --  starts on a byte boundary.\n \n-         Set_Must_Be_On_Byte_Boundary (Typ);\n+         if Get_Id (UI_To_Int (Csize)) /= RE_Null then\n+            Set_Must_Be_On_Byte_Boundary (Typ);\n+         end if;\n       end if;\n    end Create_Packed_Array_Type;\n "}, {"sha": "5ef5bae5138af1313021f2de256604415af25391", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 187, "deletions": 59, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -29,6 +29,7 @@ with Checks;   use Checks;\n with Einfo;    use Einfo;\n with Elists;   use Elists;\n with Errout;   use Errout;\n+with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch7;  use Exp_Ch7;\n with Exp_Ch11; use Exp_Ch11;\n with Exp_Tss;  use Exp_Tss;\n@@ -2323,50 +2324,135 @@ package body Exp_Util is\n    -- Is_Possibly_Unaligned_Object --\n    ----------------------------------\n \n-   function Is_Possibly_Unaligned_Object (P : Node_Id) return Boolean is\n+   function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean is\n+      T  : constant Entity_Id := Etype (N);\n+\n    begin\n-      --  If target does not have strict alignment, result is always\n-      --  False, since correctness of code does no depend on alignment.\n+      --  If renamed object, apply test to underlying object\n \n-      if not Target_Strict_Alignment then\n-         return False;\n+      if Is_Entity_Name (N)\n+        and then Is_Object (Entity (N))\n+        and then Present (Renamed_Object (Entity (N)))\n+      then\n+         return Is_Possibly_Unaligned_Object (Renamed_Object (Entity (N)));\n       end if;\n \n-      --  If renamed object, apply test to underlying object\n+      --  Tagged and controlled types and aliased types are always aligned,\n+      --  as are concurrent types.\n \n-      if Is_Entity_Name (P)\n-        and then Is_Object (Entity (P))\n-        and then Present (Renamed_Object (Entity (P)))\n+      if Is_Aliased (T)\n+        or else Has_Controlled_Component (T)\n+        or else Is_Concurrent_Type (T)\n+        or else Is_Tagged_Type (T)\n+        or else Is_Controlled (T)\n       then\n-         return Is_Possibly_Unaligned_Object (Renamed_Object (Entity (P)));\n+         return False;\n       end if;\n \n       --  If this is an element of a packed array, may be unaligned\n \n-      if Is_Ref_To_Bit_Packed_Array (P) then\n+      if Is_Ref_To_Bit_Packed_Array (N) then\n          return True;\n       end if;\n \n       --  Case of component reference\n \n-      if Nkind (P) = N_Selected_Component then\n+      if Nkind (N) = N_Selected_Component then\n+         declare\n+            P : constant Node_Id   := Prefix (N);\n+            C : constant Entity_Id := Entity (Selector_Name (N));\n+            M : Nat;\n+            S : Nat;\n \n-         --  If component reference is for a record that is bit packed\n-         --  or has a specified alignment (that might be too small) or\n-         --  the component reference has a component clause, then the\n-         --  object may be unaligned.\n+         begin\n+            --  If component reference is for an array with non-static bounds,\n+            --  then it is always aligned, we can only unaligned arrays with\n+            --  static bounds (more accurately bounds known at compile time)\n \n-         if Is_Packed (Etype (Prefix (P)))\n-           or else Known_Alignment (Etype (Prefix (P)))\n-           or else Present (Component_Clause (Entity (Selector_Name (P))))\n-         then\n-            return True;\n+            if Is_Array_Type (T)\n+              and then not Compile_Time_Known_Bounds (T)\n+            then\n+               return False;\n+            end if;\n \n-         --  Otherwise, for a component reference, test prefix\n+            --  If component is aliased, it is definitely properly aligned\n \n-         else\n-            return Is_Possibly_Unaligned_Object (Prefix (P));\n-         end if;\n+            if Is_Aliased (C) then\n+               return False;\n+            end if;\n+\n+            --  If component is for a type implemented as a scalar, and the\n+            --  record is packed, and the component is other than the first\n+            --  component of the record, then the component may be unaligned.\n+\n+            if Is_Packed (Etype (P))\n+              and then Represented_As_Scalar (Etype (P))\n+              and then First_Entity (Etype (Entity (P))) /= C\n+            then\n+               return True;\n+            end if;\n+\n+            --  Compute maximum possible alignment for T\n+\n+            --  If alignment is known, then that settles things\n+\n+            if Known_Alignment (T) then\n+               M := UI_To_Int (Alignment (T));\n+\n+            --  If alignment is not known, tentatively set max alignment\n+\n+            else\n+               M := Ttypes.Maximum_Alignment;\n+\n+               --  We can reduce this if the Esize is known since the default\n+               --  alignment will never be more than the smallest power of 2\n+               --  that does not exceed this Esize value.\n+\n+               if Known_Esize (T) then\n+                  S := UI_To_Int (Esize (T));\n+\n+                  while (M / 2) >= S loop\n+                     M := M / 2;\n+                  end loop;\n+               end if;\n+            end if;\n+\n+            --  If the component reference is for a record that has a specified\n+            --  alignment, and we either know it is too small, or cannot tell,\n+            --  then the component may be unaligned\n+\n+            if Known_Alignment (Etype (P))\n+              and then Alignment (Etype (P)) < Ttypes.Maximum_Alignment\n+              and then M > Alignment (Etype (P))\n+            then\n+               return True;\n+            end if;\n+\n+            --  Case of component clause present which may specify an\n+            --  unaligned position.\n+\n+            if Present (Component_Clause (C)) then\n+\n+               --  Otherwise we can do a test to make sure that the actual\n+               --  start position in the record, and the length, are both\n+               --  consistent with the required alignment. If not, we know\n+               --  that we are unaligned.\n+\n+               declare\n+                  Align_In_Bits : constant Nat := M * System_Storage_Unit;\n+               begin\n+                  if Component_Bit_Offset (C) mod Align_In_Bits /= 0\n+                    or else Esize (C) mod Align_In_Bits /= 0\n+                  then\n+                     return True;\n+                  end if;\n+               end;\n+            end if;\n+\n+            --  Otherwise, for a component reference, test prefix\n+\n+            return Is_Possibly_Unaligned_Object (P);\n+         end;\n \n       --  If not a component reference, must be aligned\n \n@@ -2379,7 +2465,7 @@ package body Exp_Util is\n    -- Is_Possibly_Unaligned_Slice --\n    ---------------------------------\n \n-   function Is_Possibly_Unaligned_Slice (P : Node_Id) return Boolean is\n+   function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean is\n    begin\n       --  ??? GCC3 will eventually handle strings with arbitrary alignments,\n       --  but for now the following check must be disabled.\n@@ -2390,27 +2476,27 @@ package body Exp_Util is\n \n       --  For renaming case, go to renamed object\n \n-      if Is_Entity_Name (P)\n-        and then Is_Object (Entity (P))\n-        and then Present (Renamed_Object (Entity (P)))\n+      if Is_Entity_Name (N)\n+        and then Is_Object (Entity (N))\n+        and then Present (Renamed_Object (Entity (N)))\n       then\n-         return Is_Possibly_Unaligned_Slice (Renamed_Object (Entity (P)));\n+         return Is_Possibly_Unaligned_Slice (Renamed_Object (Entity (N)));\n       end if;\n \n       --  The reference must be a slice\n \n-      if Nkind (P) /= N_Slice then\n+      if Nkind (N) /= N_Slice then\n          return False;\n       end if;\n \n       --  Always assume the worst for a nested record component with a\n       --  component clause, which gigi/gcc does not appear to handle well.\n       --  It is not clear why this special test is needed at all ???\n \n-      if Nkind (Prefix (P)) = N_Selected_Component\n-        and then Nkind (Prefix (Prefix (P))) = N_Selected_Component\n+      if Nkind (Prefix (N)) = N_Selected_Component\n+        and then Nkind (Prefix (Prefix (N))) = N_Selected_Component\n         and then\n-          Present (Component_Clause (Entity (Selector_Name (Prefix (P)))))\n+          Present (Component_Clause (Entity (Selector_Name (Prefix (N)))))\n       then\n          return True;\n       end if;\n@@ -2424,10 +2510,10 @@ package body Exp_Util is\n       --  If it is a slice, then look at the array type being sliced\n \n       declare\n-         Sarr : constant Node_Id := Prefix (P);\n+         Sarr : constant Node_Id := Prefix (N);\n          --  Prefix of the slice, i.e. the array being sliced\n \n-         Styp : constant Entity_Id := Etype (Prefix (P));\n+         Styp : constant Entity_Id := Etype (Prefix (N));\n          --  Type of the array being sliced\n \n          Pref : Node_Id;\n@@ -2519,30 +2605,30 @@ package body Exp_Util is\n    -- Is_Ref_To_Bit_Packed_Array --\n    --------------------------------\n \n-   function Is_Ref_To_Bit_Packed_Array (P : Node_Id) return Boolean is\n+   function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean is\n       Result : Boolean;\n       Expr   : Node_Id;\n \n    begin\n-      if Is_Entity_Name (P)\n-        and then Is_Object (Entity (P))\n-        and then Present (Renamed_Object (Entity (P)))\n+      if Is_Entity_Name (N)\n+        and then Is_Object (Entity (N))\n+        and then Present (Renamed_Object (Entity (N)))\n       then\n-         return Is_Ref_To_Bit_Packed_Array (Renamed_Object (Entity (P)));\n+         return Is_Ref_To_Bit_Packed_Array (Renamed_Object (Entity (N)));\n       end if;\n \n-      if Nkind (P) = N_Indexed_Component\n+      if Nkind (N) = N_Indexed_Component\n            or else\n-         Nkind (P) = N_Selected_Component\n+         Nkind (N) = N_Selected_Component\n       then\n-         if Is_Bit_Packed_Array (Etype (Prefix (P))) then\n+         if Is_Bit_Packed_Array (Etype (Prefix (N))) then\n             Result := True;\n          else\n-            Result := Is_Ref_To_Bit_Packed_Array (Prefix (P));\n+            Result := Is_Ref_To_Bit_Packed_Array (Prefix (N));\n          end if;\n \n-         if Result and then Nkind (P) = N_Indexed_Component then\n-            Expr := First (Expressions (P));\n+         if Result and then Nkind (N) = N_Indexed_Component then\n+            Expr := First (Expressions (N));\n             while Present (Expr) loop\n                Force_Evaluation (Expr);\n                Next (Expr);\n@@ -2560,25 +2646,25 @@ package body Exp_Util is\n    -- Is_Ref_To_Bit_Packed_Slice --\n    --------------------------------\n \n-   function Is_Ref_To_Bit_Packed_Slice (P : Node_Id) return Boolean is\n+   function Is_Ref_To_Bit_Packed_Slice (N : Node_Id) return Boolean is\n    begin\n-      if Is_Entity_Name (P)\n-        and then Is_Object (Entity (P))\n-        and then Present (Renamed_Object (Entity (P)))\n+      if Is_Entity_Name (N)\n+        and then Is_Object (Entity (N))\n+        and then Present (Renamed_Object (Entity (N)))\n       then\n-         return Is_Ref_To_Bit_Packed_Slice (Renamed_Object (Entity (P)));\n+         return Is_Ref_To_Bit_Packed_Slice (Renamed_Object (Entity (N)));\n       end if;\n \n-      if Nkind (P) = N_Slice\n-        and then Is_Bit_Packed_Array (Etype (Prefix (P)))\n+      if Nkind (N) = N_Slice\n+        and then Is_Bit_Packed_Array (Etype (Prefix (N)))\n       then\n          return True;\n \n-      elsif Nkind (P) = N_Indexed_Component\n+      elsif Nkind (N) = N_Indexed_Component\n            or else\n-         Nkind (P) = N_Selected_Component\n+         Nkind (N) = N_Selected_Component\n       then\n-         return Is_Ref_To_Bit_Packed_Slice (Prefix (P));\n+         return Is_Ref_To_Bit_Packed_Slice (Prefix (N));\n \n       else\n          return False;\n@@ -2646,6 +2732,22 @@ package body Exp_Util is\n                Set_Is_Eliminated (Defining_Entity (N));\n             end if;\n \n+         elsif Nkind (N) = N_Package_Declaration then\n+            Kill_Dead_Code (Visible_Declarations (Specification (N)));\n+            Kill_Dead_Code (Private_Declarations (Specification (N)));\n+\n+            declare\n+               E : Entity_Id := First_Entity (Defining_Entity (N));\n+            begin\n+               while Present (E) loop\n+                  if Ekind (E) = E_Operator then\n+                     Set_Is_Eliminated (E);\n+                  end if;\n+\n+                  Next_Entity (E);\n+               end loop;\n+            end;\n+\n          --  Recurse into composite statement to kill individual statements,\n          --  in particular instantiations.\n \n@@ -3706,8 +3808,22 @@ package body Exp_Util is\n             New_Exp := Make_Reference (Loc, E);\n          end if;\n \n-         if Nkind (E) = N_Aggregate and then Expansion_Delayed (E) then\n-            Set_Expansion_Delayed (E, False);\n+         if Is_Delayed_Aggregate (E) then\n+\n+            --  The expansion of nested aggregates is delayed until the\n+            --  enclosing aggregate is expanded. As aggregates are often\n+            --  qualified, the predicate applies to qualified expressions\n+            --  as well, indicating that the enclosing aggregate has not\n+            --  been expanded yet. At this point the aggregate is part of\n+            --  a stand-alone declaration, and must be fully expanded.\n+\n+            if Nkind (E) = N_Qualified_Expression then\n+               Set_Expansion_Delayed (Expression (E), False);\n+               Set_Analyzed (Expression (E), False);\n+            else\n+               Set_Expansion_Delayed (E, False);\n+            end if;\n+\n             Set_Analyzed (E, False);\n          end if;\n \n@@ -3731,6 +3847,18 @@ package body Exp_Util is\n       Scope_Suppress := Svg_Suppress;\n    end Remove_Side_Effects;\n \n+   ---------------------------\n+   -- Represented_As_Scalar --\n+   ---------------------------\n+\n+   function Represented_As_Scalar (T : Entity_Id) return Boolean is\n+      UT : constant Entity_Id := Underlying_Type (T);\n+   begin\n+      return Is_Scalar_Type (UT)\n+        or else (Is_Bit_Packed_Array (UT)\n+                   and then Is_Scalar_Type (Packed_Array_Type (UT)));\n+   end Represented_As_Scalar;\n+\n    ------------------------------------\n    -- Safe_Unchecked_Type_Conversion --\n    ------------------------------------"}, {"sha": "da3b1335b7d311542f7d2dc2031581203846af33", "filename": "gcc/ada/exp_util.ads", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fexp_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.ads?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -417,26 +417,26 @@ package Exp_Util is\n    --  nodes. False otherwise. True for an empty list. It is an error\n    --  to call this routine with No_List as the argument.\n \n-   function Is_Ref_To_Bit_Packed_Array (P : Node_Id) return Boolean;\n+   function Is_Ref_To_Bit_Packed_Array (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed\n    --  array, i.e. whether the designated object is a component of\n    --  a bit packed array, or a subcomponent of such a component.\n    --  If so, then all subscripts in P are evaluated with a call\n    --  to Force_Evaluation, and True is returned. Otherwise False\n    --  is returned, and P is not affected.\n \n-   function Is_Ref_To_Bit_Packed_Slice (P : Node_Id) return Boolean;\n+   function Is_Ref_To_Bit_Packed_Slice (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a reference to a bit packed\n    --  slice, i.e. whether the designated object is bit packed slice\n    --  or a component of a bit packed slice. Return True if so.\n \n-   function Is_Possibly_Unaligned_Slice (P : Node_Id) return Boolean;\n+   function Is_Possibly_Unaligned_Slice (N : Node_Id) return Boolean;\n    --  Determine whether the node P is a slice of an array where the slice\n    --  result may cause alignment problems because it has an alignment that\n    --  is not compatible with the type. Return True if so.\n \n-   function Is_Possibly_Unaligned_Object (P : Node_Id) return Boolean;\n-   --  Node P is an object reference. This function returns True if it\n+   function Is_Possibly_Unaligned_Object (N : Node_Id) return Boolean;\n+   --  Node N is an object reference. This function returns True if it\n    --  is possible that the object may not be aligned according to the\n    --  normal default alignment requirement for its type (e.g. if it\n    --  appears in a packed record, or as part of a component that has\n@@ -511,6 +511,11 @@ package Exp_Util is\n    --  call to Remove_Side_Effects, it is safe to call New_Copy_Tree to\n    --  obtain a copy of the resulting expression.\n \n+   function Represented_As_Scalar (T : Entity_Id) return Boolean;\n+   --  Returns True iff the implementation of this type in code generation\n+   --  terms is scalar. This is true for scalars in the Ada sense, and for\n+   --  packed arrays which are represented by a scalar (modular) type.\n+\n    function Safe_Unchecked_Type_Conversion (Exp : Node_Id) return Boolean;\n    --  Given the node for an N_Unchecked_Type_Conversion, return True\n    --  if this is an unchecked conversion that Gigi can handle directly."}, {"sha": "442ca6e296553d10e43d3314670eff6e64fb8ced", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 34, "deletions": 11, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -377,8 +377,7 @@ package body Sem_Eval is\n \n    function Compile_Time_Compare\n      (L, R : Node_Id;\n-      Rec  : Boolean := False)\n-      return Compare_Result\n+      Rec  : Boolean := False) return Compare_Result\n    is\n       Ltyp : constant Entity_Id := Etype (L);\n       Rtyp : constant Entity_Id := Etype (R);\n@@ -795,6 +794,34 @@ package body Sem_Eval is\n       end if;\n    end Compile_Time_Compare;\n \n+   -------------------------------\n+   -- Compile_Time_Known_Bounds --\n+   -------------------------------\n+\n+   function Compile_Time_Known_Bounds (T : Entity_Id) return Boolean is\n+      Indx : Node_Id;\n+      Typ  : Entity_Id;\n+\n+   begin\n+      if not Is_Array_Type (T) then\n+         return False;\n+      end if;\n+\n+      Indx := First_Index (T);\n+      while Present (Indx) loop\n+         Typ := Underlying_Type (Etype (Indx));\n+         if not Compile_Time_Known_Value (Type_Low_Bound (Typ)) then\n+            return False;\n+         elsif not Compile_Time_Known_Value (Type_High_Bound (Typ)) then\n+            return False;\n+         else\n+            Next_Index (Indx);\n+         end if;\n+      end loop;\n+\n+      return True;\n+   end Compile_Time_Known_Bounds;\n+\n    ------------------------------\n    -- Compile_Time_Known_Value --\n    ------------------------------\n@@ -3116,8 +3143,7 @@ package body Sem_Eval is\n    function In_Subrange_Of\n      (T1        : Entity_Id;\n       T2        : Entity_Id;\n-      Fixed_Int : Boolean := False)\n-      return      Boolean\n+      Fixed_Int : Boolean := False) return Boolean\n    is\n       L1 : Node_Id;\n       H1 : Node_Id;\n@@ -3219,8 +3245,7 @@ package body Sem_Eval is\n      (N         : Node_Id;\n       Typ       : Entity_Id;\n       Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False)\n-      return      Boolean\n+      Int_Real  : Boolean := False) return Boolean\n    is\n       Val  : Uint;\n       Valr : Ureal;\n@@ -3400,8 +3425,7 @@ package body Sem_Eval is\n      (N         : Node_Id;\n       Typ       : Entity_Id;\n       Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False)\n-      return      Boolean\n+      Int_Real  : Boolean := False) return Boolean\n    is\n       Val  : Uint;\n       Valr : Ureal;\n@@ -3691,9 +3715,8 @@ package body Sem_Eval is\n    ------------------------------------\n \n    function Subtypes_Statically_Compatible\n-     (T1   : Entity_Id;\n-      T2   : Entity_Id)\n-      return Boolean\n+     (T1 : Entity_Id;\n+      T2 : Entity_Id) return Boolean\n    is\n    begin\n       if Is_Scalar_Type (T1) then"}, {"sha": "04f7e97bb25c75d15a72148b55814975d88fa47e", "filename": "gcc/ada/sem_eval.ads", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fsem_eval.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f44fe4302729187c9c771e9b248bd829e651959b/gcc%2Fada%2Fsem_eval.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.ads?ref=f44fe4302729187c9c771e9b248bd829e651959b", "patch": "@@ -137,8 +137,7 @@ package Sem_Eval is\n    subtype Compare_LE is Compare_Result range LT .. EQ;\n    function Compile_Time_Compare\n      (L, R : Node_Id;\n-      Rec  : Boolean := False)\n-      return Compare_Result;\n+      Rec  : Boolean := False) return Compare_Result;\n    --  Given two expression nodes, finds out whether it can be determined\n    --  at compile time how the runtime values will compare. An Unknown\n    --  result means that the result of a comparison cannot be determined at\n@@ -194,9 +193,8 @@ package Sem_Eval is\n    --  range is not static, or because one or the other bound raises CE).\n \n    function Subtypes_Statically_Compatible\n-     (T1   : Entity_Id;\n-      T2   : Entity_Id)\n-      return Boolean;\n+     (T1 : Entity_Id;\n+      T2 : Entity_Id) return Boolean;\n    --  Returns true if the subtypes are unconstrained or the constraint on\n    --  on T1 is statically compatible with T2 (as defined by 4.9.1(4)).\n    --  Otherwise returns false.\n@@ -222,6 +220,11 @@ package Sem_Eval is\n    --  whose constituent expressions are either compile time known values\n    --  or compile time known aggregates.\n \n+   function Compile_Time_Known_Bounds (T : Entity_Id) return Boolean;\n+   --  If T is an array whose index bounds are all known at compile time,\n+   --  then True is returned, if T is not an array, or one or more of its\n+   --  index bounds is not known at compile time, then False is returned.\n+\n    function Expr_Value (N : Node_Id) return Uint;\n    --  Returns the folded value of the expression N. This function is called\n    --  in instances where it has already been determined that the expression\n@@ -330,8 +333,7 @@ package Sem_Eval is\n      (N         : Node_Id;\n       Typ       : Entity_Id;\n       Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False)\n-      return      Boolean;\n+      Int_Real  : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression\n    --  N is known to be in range of the subtype Typ. If the values of N or\n    --  of either bouds of Type are unknown at compile time, False will\n@@ -353,8 +355,7 @@ package Sem_Eval is\n      (N         : Node_Id;\n       Typ       : Entity_Id;\n       Fixed_Int : Boolean := False;\n-      Int_Real  : Boolean := False)\n-      return      Boolean;\n+      Int_Real  : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that expression\n    --  N is known to be out of range of the subtype Typ.  True is returned\n    --  if Typ is a scalar type, at least one of whose bounds is known at\n@@ -367,8 +368,7 @@ package Sem_Eval is\n    function In_Subrange_Of\n      (T1        : Entity_Id;\n       T2        : Entity_Id;\n-      Fixed_Int : Boolean := False)\n-      return      Boolean;\n+      Fixed_Int : Boolean := False) return Boolean;\n    --  Returns True if it can be guaranteed at compile time that the range\n    --  of values for scalar type T1 are always in the range of scalar type\n    --  T2.  A result of False does not mean that T1 is not in T2's subrange,"}]}