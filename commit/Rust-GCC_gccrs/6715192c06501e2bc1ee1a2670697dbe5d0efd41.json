{"sha": "6715192c06501e2bc1ee1a2670697dbe5d0efd41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjcxNTE5MmMwNjUwMWUyYmMxZWUxYTI2NzA2OTdkYmU1ZDBlZmQ0MQ==", "commit": {"author": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-30T08:30:32Z"}, "committer": {"name": "Manuel L\u00f3pez-Ib\u00e1\u00f1ez", "email": "manu@gcc.gnu.org", "date": "2008-07-30T08:30:32Z"}, "message": "re PR c/34389 (-Wconversion produces wrong warning)\n\n2008-07-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n\n\tPR 34389\n\t* c-typeck.c (build_binary_op): Encapsulate code into...\n\t* c-common.c (shorten_binary_op): ...this new function.\n\t(conversion_warning): Use the new function. Handle non-negative\n\tconstant in bitwise-and.\n\t* c-common.h (shorten_binary_op): Declare.\ncp/\n\t* typeck.c (build_binary_op): Encapsulate code into\n\tshorten_binary_op.\ntestsuite/\n\t* gcc.dg/Wconversion-pr34389.c: New.\n\t* g++.dg/warn/Wconversion-pr34389.C: New.\n\nFrom-SVN: r138296", "tree": {"sha": "9f9fa0bd313bb28619e5203904c17f871a84a669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9f9fa0bd313bb28619e5203904c17f871a84a669"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6715192c06501e2bc1ee1a2670697dbe5d0efd41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6715192c06501e2bc1ee1a2670697dbe5d0efd41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6715192c06501e2bc1ee1a2670697dbe5d0efd41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6715192c06501e2bc1ee1a2670697dbe5d0efd41/comments", "author": null, "committer": null, "parents": [{"sha": "473e10621f06ef6cfd82f3875224c4b82c2eb7cf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/473e10621f06ef6cfd82f3875224c4b82c2eb7cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/473e10621f06ef6cfd82f3875224c4b82c2eb7cf"}], "stats": {"total": 435, "additions": 282, "deletions": 153}, "files": [{"sha": "671b794cf25fe2d3d0d11cf6318b95254b7c854b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -1,3 +1,12 @@\n+2008-07-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 34389\n+\t* c-typeck.c (build_binary_op): Encapsulate code into...\n+\t* c-common.c (shorten_binary_op): ...this new function.\n+\t(conversion_warning): Use the new function. Handle non-negative\n+\tconstant in bitwise-and.\n+\t* c-common.h (shorten_binary_op): Declare.\n+\t\n 2008-07-30  Olivier Hainque  <hainque@adacore.com>\n \n \t* scan.c (make_sstring_space): Add explicit conversions of"}, {"sha": "dac29ea2c7e8397eef0a2a432de83ae56a188855", "filename": "gcc/c-common.c", "status": "modified", "additions": 148, "deletions": 13, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -1447,6 +1447,110 @@ vector_types_convertible_p (const_tree t1, const_tree t2, bool emit_lax_note)\n   return false;\n }\n \n+/* This is a helper function of build_binary_op.\n+\n+   For certain operations if both args were extended from the same\n+   smaller type, do the arithmetic in that type and then extend.\n+\n+   BITWISE indicates a bitwise operation.\n+   For them, this optimization is safe only if\n+   both args are zero-extended or both are sign-extended.\n+   Otherwise, we might change the result.\n+   Eg, (short)-1 | (unsigned short)-1 is (int)-1\n+   but calculated in (unsigned short) it would be (unsigned short)-1.  \n+*/\n+tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise)\n+{\n+  int unsigned0, unsigned1;\n+  tree arg0, arg1;\n+  int uns;\n+  tree type;\n+\n+  /* Cast OP0 and OP1 to RESULT_TYPE.  Doing so prevents\n+     excessive narrowing when we call get_narrower below.  For\n+     example, suppose that OP0 is of unsigned int extended\n+     from signed char and that RESULT_TYPE is long long int.\n+     If we explicitly cast OP0 to RESULT_TYPE, OP0 would look\n+     like\n+     \n+     (long long int) (unsigned int) signed_char\n+\n+     which get_narrower would narrow down to\n+     \n+     (unsigned int) signed char\n+     \n+     If we do not cast OP0 first, get_narrower would return\n+     signed_char, which is inconsistent with the case of the\n+     explicit cast.  */\n+  op0 = convert (result_type, op0);\n+  op1 = convert (result_type, op1);\n+\n+  arg0 = get_narrower (op0, &unsigned0);\n+  arg1 = get_narrower (op1, &unsigned1);\n+\n+  /* UNS is 1 if the operation to be done is an unsigned one.  */\n+  uns = TYPE_UNSIGNED (result_type);\n+\n+  /* Handle the case that OP0 (or OP1) does not *contain* a conversion\n+     but it *requires* conversion to FINAL_TYPE.  */\n+  \n+  if ((TYPE_PRECISION (TREE_TYPE (op0))\n+       == TYPE_PRECISION (TREE_TYPE (arg0)))\n+      && TREE_TYPE (op0) != result_type)\n+    unsigned0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n+  if ((TYPE_PRECISION (TREE_TYPE (op1))\n+       == TYPE_PRECISION (TREE_TYPE (arg1)))\n+      && TREE_TYPE (op1) != result_type)\n+    unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n+  \n+  /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n+  \n+  /* For bitwise operations, signedness of nominal type\n+     does not matter.  Consider only how operands were extended.  */\n+  if (bitwise)\n+    uns = unsigned0;\n+  \n+  /* Note that in all three cases below we refrain from optimizing\n+     an unsigned operation on sign-extended args.\n+     That would not be valid.  */\n+  \n+  /* Both args variable: if both extended in same way\n+     from same width, do it in that width.\n+     Do it unsigned if args were zero-extended.  */\n+  if ((TYPE_PRECISION (TREE_TYPE (arg0))\n+       < TYPE_PRECISION (result_type))\n+      && (TYPE_PRECISION (TREE_TYPE (arg1))\n+\t  == TYPE_PRECISION (TREE_TYPE (arg0)))\n+      && unsigned0 == unsigned1\n+      && (unsigned0 || !uns))\n+    return c_common_signed_or_unsigned_type\n+      (unsigned0, common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n+\n+  else if (TREE_CODE (arg0) == INTEGER_CST\n+\t   && (unsigned1 || !uns)\n+\t   && (TYPE_PRECISION (TREE_TYPE (arg1))\n+\t       < TYPE_PRECISION (result_type))\n+\t   && (type\n+\t       = c_common_signed_or_unsigned_type (unsigned1,\n+\t\t\t\t\t\t   TREE_TYPE (arg1)))\n+\t   && !POINTER_TYPE_P (type)\n+\t   && int_fits_type_p (arg0, type))\n+    return type;\n+\n+  else if (TREE_CODE (arg1) == INTEGER_CST\n+\t   && (unsigned0 || !uns)\n+\t   && (TYPE_PRECISION (TREE_TYPE (arg0))\n+\t       < TYPE_PRECISION (result_type))\n+\t   && (type\n+\t       = c_common_signed_or_unsigned_type (unsigned0,\n+\t\t\t\t\t\t   TREE_TYPE (arg0)))\n+\t   && !POINTER_TYPE_P (type)\n+\t   && int_fits_type_p (arg1, type))\n+    return type;\n+\n+  return result_type;\n+}\n+\n /* Warns if the conversion of EXPR to TYPE may alter a value.\n    This is a helper function for warnings_for_convert_and_check.  */\n \n@@ -1511,42 +1615,73 @@ conversion_warning (tree type, tree expr)\n     }\n   else /* 'expr' is not a constant.  */\n     {\n+      tree expr_type = TREE_TYPE (expr);\n+\n       /* Warn for real types converted to integer types.  */\n-      if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+      if (TREE_CODE (expr_type) == REAL_TYPE\n           && TREE_CODE (type) == INTEGER_TYPE)\n         give_warning = true;\n \n-      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+      else if (TREE_CODE (expr_type) == INTEGER_TYPE\n                && TREE_CODE (type) == INTEGER_TYPE)\n         {\n \t  /* Don't warn about unsigned char y = 0xff, x = (int) y;  */\n \t  expr = get_unwidened (expr, 0);\n+\t  expr_type = TREE_TYPE (expr);\n \n+\t  /* Don't warn for short y; short x = ((int)y & 0xff);  */\n+\t  if (TREE_CODE (expr) == BIT_AND_EXPR \n+\t      || TREE_CODE (expr) == BIT_IOR_EXPR \n+\t      || TREE_CODE (expr) == BIT_XOR_EXPR)\n+\t    {\n+\t    /* It both args were extended from a shortest type, use\n+\t       that type if that is safe.  */\n+\t      expr_type = shorten_binary_op (expr_type, \n+\t\t\t\t\t     TREE_OPERAND (expr, 0), \n+\t\t\t\t\t     TREE_OPERAND (expr, 1), \n+\t\t\t\t\t     /* bitwise */1);\n+\n+\t      /* If one of the operands is a non-negative constant\n+\t\t that fits in the target type, then the type of the\n+\t\t other operand does not matter. */\n+\t      if (TREE_CODE (expr) == BIT_AND_EXPR)\n+\t\t{\n+\t\t  tree op0 = TREE_OPERAND (expr, 0);\n+\t\t  tree op1 = TREE_OPERAND (expr, 1);\n+\t\t  if ((TREE_CODE (op0) == INTEGER_CST\n+\t\t       && int_fits_type_p (op0, c_common_signed_type (type))\n+\t\t       && int_fits_type_p (op0, c_common_unsigned_type (type)))\n+\t\t      || (TREE_CODE (op1) == INTEGER_CST\n+\t\t       && int_fits_type_p (op1, c_common_signed_type (type))\n+\t\t       && int_fits_type_p (op1, c_common_unsigned_type (type))))\n+\t\t    return;\n+\t\t}\n+\t    }\n           /* Warn for integer types converted to smaller integer types.  */\n-          if (formal_prec < TYPE_PRECISION (TREE_TYPE (expr))) \n+          if (formal_prec < TYPE_PRECISION (expr_type)) \n \t    give_warning = true;\n \n \t  /* When they are the same width but different signedness,\n \t     then the value may change.  */\n-\t  else if ((formal_prec == TYPE_PRECISION (TREE_TYPE (expr))\n-\t\t    && TYPE_UNSIGNED (TREE_TYPE (expr)) != TYPE_UNSIGNED (type))\n+\t  else if ((formal_prec == TYPE_PRECISION (expr_type)\n+\t\t    && TYPE_UNSIGNED (expr_type) != TYPE_UNSIGNED (type))\n \t\t   /* Even when converted to a bigger type, if the type is\n \t\t      unsigned but expr is signed, then negative values\n \t\t      will be changed.  */\n-\t\t   || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (TREE_TYPE (expr))))\n+\t\t   || (TYPE_UNSIGNED (type) && !TYPE_UNSIGNED (expr_type)))\n \t    warning (OPT_Wsign_conversion,\n \t\t     \"conversion to %qT from %qT may change the sign of the result\",\n-\t\t     type, TREE_TYPE (expr));\n+\t\t     type, expr_type);\n         }\n \n       /* Warn for integer types converted to real types if and only if\n          all the range of values of the integer type cannot be\n          represented by the real type.  */\n-      else if (TREE_CODE (TREE_TYPE (expr)) == INTEGER_TYPE\n+      else if (TREE_CODE (expr_type) == INTEGER_TYPE\n                && TREE_CODE (type) == REAL_TYPE)\n         {\n-          tree type_low_bound = TYPE_MIN_VALUE (TREE_TYPE (expr));\n-          tree type_high_bound = TYPE_MAX_VALUE (TREE_TYPE (expr));\n+          tree type_low_bound = TYPE_MIN_VALUE (expr_type);\n+          tree type_high_bound = TYPE_MAX_VALUE (expr_type);\n           REAL_VALUE_TYPE real_low_bound = real_value_from_int_cst (0, type_low_bound);\n           REAL_VALUE_TYPE real_high_bound = real_value_from_int_cst (0, type_high_bound);\n \n@@ -1556,16 +1691,16 @@ conversion_warning (tree type, tree expr)\n         }\n \n       /* Warn for real types converted to smaller real types.  */\n-      else if (TREE_CODE (TREE_TYPE (expr)) == REAL_TYPE\n+      else if (TREE_CODE (expr_type) == REAL_TYPE\n                && TREE_CODE (type) == REAL_TYPE\n-               && formal_prec < TYPE_PRECISION (TREE_TYPE (expr)))\n+               && formal_prec < TYPE_PRECISION (expr_type))\n         give_warning = true;\n \n \n       if (give_warning)\n         warning (OPT_Wconversion,\n                  \"conversion to %qT from %qT may alter its value\",\n-                 type, TREE_TYPE (expr));\n+                 type, expr_type);\n     }\n }\n "}, {"sha": "f600751f0c0851ce7c4742db96ffbd496b3d6ea7", "filename": "gcc/c-common.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -743,6 +743,9 @@ extern bool same_scalar_type_ignoring_signedness (tree, tree);\n #define c_sizeof(T)  c_sizeof_or_alignof_type (T, true, 1)\n #define c_alignof(T) c_sizeof_or_alignof_type (T, false, 1)\n \n+/* Subroutine of build_binary_op, used for certain operations.  */\n+extern tree shorten_binary_op (tree result_type, tree op0, tree op1, bool bitwise);\n+\n /* Subroutine of build_binary_op, used for comparison operations.\n    See if the operands have both been converted from subword integer types\n    and, if so, perhaps change them both back to their original type.  */"}, {"sha": "4756e256f387ef34caa61cb70a0e8391dd50e0fa", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -8316,93 +8316,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n       if (shorten && none_complex)\n \t{\n-\t  int unsigned0, unsigned1;\n-\t  tree arg0, arg1;\n-\t  int uns;\n-\t  tree type;\n-\n-\t  /* Cast OP0 and OP1 to RESULT_TYPE.  Doing so prevents\n-\t     excessive narrowing when we call get_narrower below.  For\n-\t     example, suppose that OP0 is of unsigned int extended\n-\t     from signed char and that RESULT_TYPE is long long int.\n-\t     If we explicitly cast OP0 to RESULT_TYPE, OP0 would look\n-\t     like\n-\n-\t       (long long int) (unsigned int) signed_char\n-\n-\t     which get_narrower would narrow down to\n-\n-\t       (unsigned int) signed char\n-\n-\t     If we do not cast OP0 first, get_narrower would return\n-\t     signed_char, which is inconsistent with the case of the\n-\t     explicit cast.  */\n-\t  op0 = convert (result_type, op0);\n-\t  op1 = convert (result_type, op1);\n-\n-\t  arg0 = get_narrower (op0, &unsigned0);\n-\t  arg1 = get_narrower (op1, &unsigned1);\n-\n-\t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n-\t  uns = TYPE_UNSIGNED (result_type);\n-\n \t  final_type = result_type;\n-\n-\t  /* Handle the case that OP0 (or OP1) does not *contain* a conversion\n-\t     but it *requires* conversion to FINAL_TYPE.  */\n-\n-\t  if ((TYPE_PRECISION (TREE_TYPE (op0))\n-\t       == TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t      && TREE_TYPE (op0) != final_type)\n-\t    unsigned0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n-\t  if ((TYPE_PRECISION (TREE_TYPE (op1))\n-\t       == TYPE_PRECISION (TREE_TYPE (arg1)))\n-\t      && TREE_TYPE (op1) != final_type)\n-\t    unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n-\n-\t  /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n-\n-\t  /* For bitwise operations, signedness of nominal type\n-\t     does not matter.  Consider only how operands were extended.  */\n-\t  if (shorten == -1)\n-\t    uns = unsigned0;\n-\n-\t  /* Note that in all three cases below we refrain from optimizing\n-\t     an unsigned operation on sign-extended args.\n-\t     That would not be valid.  */\n-\n-\t  /* Both args variable: if both extended in same way\n-\t     from same width, do it in that width.\n-\t     Do it unsigned if args were zero-extended.  */\n-\t  if ((TYPE_PRECISION (TREE_TYPE (arg0))\n-\t       < TYPE_PRECISION (result_type))\n-\t      && (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t      && unsigned0 == unsigned1\n-\t      && (unsigned0 || !uns))\n-\t    result_type\n-\t      = c_common_signed_or_unsigned_type\n-\t      (unsigned0, common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n-\t  else if (TREE_CODE (arg0) == INTEGER_CST\n-\t\t   && (unsigned1 || !uns)\n-\t\t   && (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t       < TYPE_PRECISION (result_type))\n-\t\t   && (type\n-\t\t       = c_common_signed_or_unsigned_type (unsigned1,\n-\t\t\t\t\t\t\t   TREE_TYPE (arg1)))\n-\t\t   && !POINTER_TYPE_P (type)\n-\t\t   && int_fits_type_p (arg0, type))\n-\t    result_type = type;\n-\t  else if (TREE_CODE (arg1) == INTEGER_CST\n-\t\t   && (unsigned0 || !uns)\n-\t\t   && (TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t       < TYPE_PRECISION (result_type))\n-\t\t   && (type\n-\t\t       = c_common_signed_or_unsigned_type (unsigned0,\n-\t\t\t\t\t\t\t   TREE_TYPE (arg0)))\n-\t\t   && !POINTER_TYPE_P (type)\n-\t\t   && int_fits_type_p (arg1, type))\n-\t    result_type = type;\n+\t  result_type = shorten_binary_op (result_type, op0, op1, \n+\t\t\t\t\t   shorten == -1);\n \t}\n \n       /* Shifts can be shortened if shifting right.  */"}, {"sha": "0e236b1ef3bd254779152d5e50faed0820cbeb3a", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -1,3 +1,9 @@\n+2008-07-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 34389\n+\t* typeck.c (build_binary_op): Encapsulate code into\n+\tshorten_binary_op.\n+\t\n 2008-07-29  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/36852"}, {"sha": "ba1d02860790fc1c708cb0a4d9913e01527317f1", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 54, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -3810,61 +3810,9 @@ cp_build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n       if (shorten && none_complex)\n \t{\n-\t  int unsigned0, unsigned1;\n-\t  tree arg0 = get_narrower (op0, &unsigned0);\n-\t  tree arg1 = get_narrower (op1, &unsigned1);\n-\t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n-\t  int uns = TYPE_UNSIGNED (result_type);\n-\t  tree type;\n-\n \t  final_type = result_type;\n-\n-\t  /* Handle the case that OP0 does not *contain* a conversion\n-\t     but it *requires* conversion to FINAL_TYPE.  */\n-\n-\t  if (op0 == arg0 && TREE_TYPE (op0) != final_type)\n-\t    unsigned0 = TYPE_UNSIGNED (TREE_TYPE (op0));\n-\t  if (op1 == arg1 && TREE_TYPE (op1) != final_type)\n-\t    unsigned1 = TYPE_UNSIGNED (TREE_TYPE (op1));\n-\n-\t  /* Now UNSIGNED0 is 1 if ARG0 zero-extends to FINAL_TYPE.  */\n-\n-\t  /* For bitwise operations, signedness of nominal type\n-\t     does not matter.  Consider only how operands were extended.  */\n-\t  if (shorten == -1)\n-\t    uns = unsigned0;\n-\n-\t  /* Note that in all three cases below we refrain from optimizing\n-\t     an unsigned operation on sign-extended args.\n-\t     That would not be valid.  */\n-\n-\t  /* Both args variable: if both extended in same way\n-\t     from same width, do it in that width.\n-\t     Do it unsigned if args were zero-extended.  */\n-\t  if ((TYPE_PRECISION (TREE_TYPE (arg0))\n-\t       < TYPE_PRECISION (result_type))\n-\t      && (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t  == TYPE_PRECISION (TREE_TYPE (arg0)))\n-\t      && unsigned0 == unsigned1\n-\t      && (unsigned0 || !uns))\n-\t    result_type = c_common_signed_or_unsigned_type\n-\t      (unsigned0, common_type (TREE_TYPE (arg0), TREE_TYPE (arg1)));\n-\t  else if (TREE_CODE (arg0) == INTEGER_CST\n-\t\t   && (unsigned1 || !uns)\n-\t\t   && (TYPE_PRECISION (TREE_TYPE (arg1))\n-\t\t       < TYPE_PRECISION (result_type))\n-\t\t   && (type = c_common_signed_or_unsigned_type\n-\t\t       (unsigned1, TREE_TYPE (arg1)),\n-\t\t       int_fits_type_p (arg0, type)))\n-\t    result_type = type;\n-\t  else if (TREE_CODE (arg1) == INTEGER_CST\n-\t\t   && (unsigned0 || !uns)\n-\t\t   && (TYPE_PRECISION (TREE_TYPE (arg0))\n-\t\t       < TYPE_PRECISION (result_type))\n-\t\t   && (type = c_common_signed_or_unsigned_type\n-\t\t       (unsigned0, TREE_TYPE (arg0)),\n-\t\t       int_fits_type_p (arg1, type)))\n-\t    result_type = type;\n+\t  result_type = shorten_binary_op (result_type, op0, op1, \n+\t\t\t\t\t   shorten == -1);\n \t}\n \n       /* Comparison operations are shortened too but differently."}, {"sha": "46820ff4535cfeed2e93da8dcb0d14ce32fae0b4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -1,3 +1,9 @@\n+2008-07-30  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n+\n+\tPR 34389\n+\t* gcc.dg/Wconversion-pr34389.c: New.\n+\t* g++.dg/warn/Wconversion-pr34389.C: New.\n+\t\n 2008-07-29  Steve Ellcey  <sje@cup.hp.com>\n \n \t* gcc.dg/pr32370.c: Force 64 bits on IA64."}, {"sha": "f3cd310538690a7a88fc8f8867bab4f27103c4e9", "filename": "gcc/testsuite/g++.dg/warn/Wconversion-pr34389.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-pr34389.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-pr34389.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWconversion-pr34389.C?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -0,0 +1,53 @@\n+/* PR 34389 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wconversion -Wsign-conversion\" } */\n+\n+short  mask1(short x)\n+{\n+  short y = 0x7fff;\n+  return x & y; /* { dg-bogus \"conversion\" \"conversion\" { xfail *-*-* } 8 } */\n+}\n+\n+short  mask2(short ssx)\n+{\n+  short ssy;\n+  short ssz;\n+\n+  ssz = ((int)ssx) & 0x7fff;\n+  ssy = ((int)ssx) | 0x7fff;\n+  ssz = ((int)ssx) ^ 0x7fff;\n+  return ssx & 0x7fff;\n+}\n+\n+short  mask3(int si, unsigned int ui)\n+{\n+  short ss;\n+  unsigned short us;\n+\n+  ss = si & 0x7fff;\n+  ss = si & 0xAAAA; /* { dg-warning \"conversion\" } */\n+  ss = ui & 0x7fff;\n+  ss = ui & 0xAAAA; /* { dg-warning \"conversion\" } */\n+\n+  us = si & 0x7fff;\n+  us = si & 0xAAAA; /* { dg-warning \"conversion\" } */\n+  us = ui & 0x7fff;\n+  us = ui & 0xAAAA; /* { dg-warning \"conversion\" } */\n+\n+  return ss;\n+}\n+\n+short  mask4(int x, int y)\n+{\n+  return x & y; /* { dg-warning \"conversion\" } */\n+}\n+\n+short  mask5(int x)\n+{\n+  return x & -1; /* { dg-warning \"conversion\" } */\n+}\n+\n+short  mask6(short x)\n+{\n+  return x & -1;\n+}"}, {"sha": "45cdf19ef711bb010dfbe8a734a3a7721bbc1e03", "filename": "gcc/testsuite/gcc.dg/Wconversion-pr34389.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-pr34389.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6715192c06501e2bc1ee1a2670697dbe5d0efd41/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-pr34389.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWconversion-pr34389.c?ref=6715192c06501e2bc1ee1a2670697dbe5d0efd41", "patch": "@@ -0,0 +1,53 @@\n+/* PR 34389 */\n+/* { dg-do compile } */\n+/* { dg-options \"-Wconversion -Wsign-conversion\" } */\n+\n+short  mask1(short x)\n+{\n+  short y = 0x7fff;\n+  return x & y;\n+}\n+\n+short  mask2(short ssx)\n+{\n+  short ssy;\n+  short ssz;\n+\n+  ssz = ((int)ssx) & 0x7fff;\n+  ssy = ((int)ssx) | 0x7fff;\n+  ssz = ((int)ssx) ^ 0x7fff;\n+  return ssx & 0x7fff;\n+}\n+\n+short  mask3(int si, unsigned int ui)\n+{\n+  short ss;\n+  unsigned short us;\n+\n+  ss = si & 0x7fff;\n+  ss = si & 0xAAAA; /* { dg-warning \"conversion\" } */\n+  ss = ui & 0x7fff;\n+  ss = ui & 0xAAAA; /* { dg-warning \"conversion\" } */\n+\n+  us = si & 0x7fff;\n+  us = si & 0xAAAA; /* { dg-warning \"conversion\" } */\n+  us = ui & 0x7fff;\n+  us = ui & 0xAAAA; /* { dg-warning \"conversion\" } */\n+\n+  return ss;\n+}\n+\n+short  mask4(int x, int y)\n+{\n+  return x & y; /* { dg-warning \"conversion\" } */\n+}\n+\n+short  mask5(int x)\n+{\n+  return x & -1; /* { dg-warning \"conversion\" } */\n+}\n+\n+short  mask6(short x)\n+{\n+  return x & -1;\n+}"}]}