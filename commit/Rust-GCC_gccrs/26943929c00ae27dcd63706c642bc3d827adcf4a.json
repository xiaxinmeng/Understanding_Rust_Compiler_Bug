{"sha": "26943929c00ae27dcd63706c642bc3d827adcf4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjY5NDM5MjljMDBhZTI3ZGNkNjM3MDZjNjQyYmMzZDgyN2FkY2Y0YQ==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-15T22:08:07Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2012-10-15T22:08:07Z"}, "message": "re PR target/51244 ([SH] Inefficient conditional branch and code around T bit)\n\n\tPR target/51244\n\t* config/sh/sh-protos.h (set_of_reg): New struct.\n\t(sh_find_set_of_reg, sh_is_logical_t_store_expr,\n\tsh_try_omit_signzero_extend):  Declare...\n\t* config/sh/sh.c (sh_find_set_of_reg, sh_is_logical_t_store_expr,\n\tsh_try_omit_signzero_extend): ...these new functions.\n\t* config/sh/sh.md (*logical_op_t): New insn_and_split.\n\t(*zero_extend<mode>si2_compact): Use sh_try_omit_signzero_extend\n\tin splitter.\n\t(*extend<mode>si2_compact_reg): Convert to insn_and_split.\n\tUse sh_try_omit_signzero_extend in splitter.\n\t(*mov<mode>_reg_reg): Disallow t_reg_operand as operand 1.\n\t(*cbranch_t): Rewrite combine part in splitter using new\n\tsh_find_set_of_reg function.\n\n\tPR target/51244\n\t* gcc.target/sh/pr51244-17.c: New.\n\nFrom-SVN: r192481", "tree": {"sha": "4345633a0ae1c37863cf324ef3c7e80f33d28125", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4345633a0ae1c37863cf324ef3c7e80f33d28125"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/26943929c00ae27dcd63706c642bc3d827adcf4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26943929c00ae27dcd63706c642bc3d827adcf4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26943929c00ae27dcd63706c642bc3d827adcf4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26943929c00ae27dcd63706c642bc3d827adcf4a/comments", "author": null, "committer": null, "parents": [{"sha": "14df3f361e5aaa4145ab242886e3a857d4ae078c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14df3f361e5aaa4145ab242886e3a857d4ae078c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14df3f361e5aaa4145ab242886e3a857d4ae078c"}], "stats": {"total": 616, "additions": 526, "deletions": 90}, "files": [{"sha": "3a2af81f4249c97a546c865d5a39cbdb9894a00a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -1,3 +1,20 @@\n+2012-10-15  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* config/sh/sh-protos.h (set_of_reg): New struct.\n+\t(sh_find_set_of_reg, sh_is_logical_t_store_expr,\n+\tsh_try_omit_signzero_extend):  Declare...\n+\t* config/sh/sh.c (sh_find_set_of_reg, sh_is_logical_t_store_expr,\n+\tsh_try_omit_signzero_extend): ...these new functions.\n+\t* config/sh/sh.md (*logical_op_t): New insn_and_split.\n+\t(*zero_extend<mode>si2_compact): Use sh_try_omit_signzero_extend\n+\tin splitter.\n+\t(*extend<mode>si2_compact_reg): Convert to insn_and_split.\n+\tUse sh_try_omit_signzero_extend in splitter.\n+\t(*mov<mode>_reg_reg): Disallow t_reg_operand as operand 1.\n+\t(*cbranch_t): Rewrite combine part in splitter using new\n+\tsh_find_set_of_reg function.\n+\n 2012-10-15  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54760"}, {"sha": "d4e97db89023ee7f1f743b523cb381624db62db6", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -163,6 +163,25 @@ extern void sh_canonicalize_comparison (enum rtx_code&, rtx&, rtx&,\n \t\t\t\t\tenum machine_mode mode = VOIDmode);\n extern rtx sh_find_equiv_gbr_addr (rtx cur_insn, rtx mem);\n extern int sh_eval_treg_value (rtx op);\n+\n+/* Result value of sh_find_set_of_reg.  */\n+struct set_of_reg\n+{\n+  /* The insn where sh_find_set_of_reg stopped looking.\n+     Can be NULL_RTX if the end of the insn list was reached.  */\n+  rtx insn;\n+\n+  /* The set rtx of the specified reg if found, NULL_RTX otherwise.  */\n+  const_rtx set_rtx;\n+\n+  /* The set source rtx of the specified reg if found, NULL_RTX otherwise.\n+     Usually, this is the most interesting return value.  */\n+  rtx set_src;\n+};\n+\n+extern set_of_reg sh_find_set_of_reg (rtx reg, rtx insn, rtx(*stepfunc)(rtx));\n+extern bool sh_is_logical_t_store_expr (rtx op, rtx insn);\n+extern rtx sh_try_omit_signzero_extend (rtx extended_op, rtx insn);\n #endif /* RTX_CODE */\n \n extern void sh_cpu_cpp_builtins (cpp_reader* pfile);"}, {"sha": "df5b4e519b35f2eaa31e38840551cd2c33a57b5f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -13466,4 +13466,114 @@ sh_find_equiv_gbr_addr (rtx insn, rtx mem)\n   return NULL_RTX;\n }\n \n+/*------------------------------------------------------------------------------\n+  Manual insn combine support code.\n+*/\n+\n+/* Given a reg rtx and a start insn, try to find the insn that sets the\n+   specified reg by using the specified insn stepping function, such as \n+   'prev_nonnote_insn_bb'.  When the insn is found, try to extract the rtx\n+   of the reg set.  */\n+set_of_reg\n+sh_find_set_of_reg (rtx reg, rtx insn, rtx(*stepfunc)(rtx))\n+{\n+  set_of_reg result;\n+  result.insn = insn;\n+  result.set_rtx = NULL_RTX;\n+  result.set_src = NULL_RTX;\n+\n+  if (!REG_P (reg) || insn == NULL_RTX)\n+    return result;\n+\n+  for (result.insn = stepfunc (insn); result.insn != NULL_RTX;\n+       result.insn = stepfunc (result.insn))\n+    {\n+      if (LABEL_P (result.insn) || BARRIER_P (result.insn))\n+\treturn result;\n+      if (!NONJUMP_INSN_P (result.insn))\n+\tcontinue;\n+      if (reg_set_p (reg, result.insn))\n+\t{\n+\t  result.set_rtx = set_of (reg, result.insn);\n+\n+\t  if (result.set_rtx == NULL_RTX || GET_CODE (result.set_rtx) != SET)\n+\t    return result;\n+\n+\t  result.set_src = XEXP (result.set_rtx, 1);\n+\t  return result;\n+\t}\n+    }\n+\n+  return result;\n+}\n+\n+/* Given an op rtx and an insn, try to find out whether the result of the\n+   specified op consists only of logical operations on T bit stores.  */\n+bool\n+sh_is_logical_t_store_expr (rtx op, rtx insn)\n+{\n+  if (!logical_operator (op, SImode))\n+    return false;\n+\n+  rtx ops[2] = { XEXP (op, 0), XEXP (op, 1) };\n+  int op_is_t_count = 0;\n+\n+  for (int i = 0; i < 2; ++i)\n+    {\n+      if (t_reg_operand (ops[i], VOIDmode)\n+\t  || negt_reg_operand (ops[i], VOIDmode))\n+\top_is_t_count++;\n+\n+      else\n+\t{\n+\t  set_of_reg op_set = sh_find_set_of_reg (ops[i], insn,\n+\t\t\t\t\t\t  prev_nonnote_insn_bb);\n+\t  if (op_set.set_src == NULL_RTX)\n+\t    continue;\n+\n+\t  if (t_reg_operand (op_set.set_src, VOIDmode)\n+\t      || negt_reg_operand (op_set.set_src, VOIDmode)\n+\t      || sh_is_logical_t_store_expr (op_set.set_src, op_set.insn))\n+\t      op_is_t_count++;\n+\t}\n+    }\n+  \n+  return op_is_t_count == 2;\n+}\n+\n+/* Given the operand that is extended in a sign/zero extend insn, and the\n+   insn, try to figure out whether the sign/zero extension can be replaced\n+   by a simple reg-reg copy.  If so, the replacement reg rtx is returned,\n+   NULL_RTX otherwise.  */\n+rtx\n+sh_try_omit_signzero_extend (rtx extended_op, rtx insn)\n+{\n+  if (REG_P (extended_op))\n+    extended_op = extended_op;\n+  else if (GET_CODE (extended_op) == SUBREG && REG_P (SUBREG_REG (extended_op)))\n+    extended_op = SUBREG_REG (extended_op);\n+  else\n+    return NULL_RTX;\n+\n+  /* Reg moves must be of the same mode.  */\n+  if (GET_MODE (extended_op) != SImode)\n+    return NULL_RTX;\n+\n+  set_of_reg s = sh_find_set_of_reg (extended_op, insn, prev_nonnote_insn_bb);\n+  if (s.set_src == NULL_RTX)\n+    return NULL_RTX;\n+\n+  if (t_reg_operand (s.set_src, VOIDmode)\n+      || negt_reg_operand (s.set_src, VOIDmode))\n+    return extended_op;\n+\n+  /* If the zero extended reg was formed by a logical operation, check the\n+     operands of the logical operation.  If both originated from T bit\n+     stores the zero extension can be eliminated.  */\n+  else if (sh_is_logical_t_store_expr (s.set_src, s.insn))\n+    return extended_op;\n+\n+  return NULL_RTX;\n+}\n+\n #include \"gt-sh.h\""}, {"sha": "6e6394504f69a438d74f6f95bc9c91d2a8c72b1f", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 78, "deletions": 90, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -3708,6 +3708,26 @@ label:\n   \"xor\t%2,%0\"\n   [(set_attr \"type\" \"arith\")])\n \n+;; The *logical_op_t pattern helps combine eliminating sign/zero extensions\n+;; of results where one of the inputs is a T bit store.  Notice that this\n+;; pattern must not match during reload.  If reload picks this pattern it\n+;; will be impossible to split it afterwards.\n+(define_insn_and_split \"*logical_op_t\"\n+  [(set (match_operand:SI 0 \"arith_reg_dest\")\n+\t(match_operator:SI 3 \"logical_operator\"\n+\t  [(match_operand:SI 1 \"arith_reg_operand\")\n+\t   (match_operand:SI 2 \"t_reg_operand\")]))]\n+  \"TARGET_SH1 && can_create_pseudo_p ()\"\n+  \"#\"\n+  \"&& 1\"\n+  [(set (match_dup 4) (reg:SI T_REG))\n+   (set (match_dup 0) (match_dup 3))]\n+{\n+  operands[4] = gen_reg_rtx (SImode);\n+  operands[3] = gen_rtx_fmt_ee (GET_CODE (operands[3]), SImode,\n+\t\t\t\toperands[1], operands[4]);\n+})\n+\n (define_insn \"*xorsi3_media\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r,r\")\n \t(xor:SI (match_operand:SI 1 \"logical_reg_operand\" \"%r,r\")\n@@ -5590,39 +5610,7 @@ label:\n      eliminated.  Notice that this also helps the *cbranch_t splitter when\n      it tries to post-combine tests and conditional branches, as it does not\n      check for zero extensions.  */\n-  rtx ext_reg;\n-  if (REG_P (operands[1]))\n-    ext_reg = operands[1];\n-  else if (GET_CODE (operands[1]) == SUBREG && REG_P (SUBREG_REG (operands[1])))\n-    ext_reg = SUBREG_REG (operands[1]);\n-  else\n-    FAIL;\n-\n-  /* Reg moves must be of the same mode.  */\n-  if (GET_MODE (ext_reg) != SImode)\n-    FAIL;\n-\n-  operands[2] = NULL_RTX;\n-  for (rtx i = prev_nonnote_insn_bb (curr_insn); i != NULL_RTX;\n-       i = prev_nonnote_insn_bb (i))\n-    {\n-      if (LABEL_P (i) || BARRIER_P (i))\n-\tbreak;\n-      if (!NONJUMP_INSN_P (i))\n-\tcontinue;\n-\n-      if (reg_set_p (ext_reg, i))\n-\t{\n-\t  rtx set_op = XEXP (set_of (ext_reg, i), 1);\n-\t  if (set_op == NULL_RTX)\n-\t    break;\n-\t  if (t_reg_operand (set_op, VOIDmode)\n-\t      || negt_reg_operand (set_op, VOIDmode))\n-\t    operands[2] = ext_reg;\n-\t  break;\n-\t}\n-    }\n-\n+  operands[2] = sh_try_omit_signzero_extend (operands[1], curr_insn);\n   if (operands[2] == NULL_RTX)\n     FAIL;\n }\n@@ -5850,11 +5838,23 @@ label:\n \t\t\t   subreg_lowpart_offset (SImode, GET_MODE (op1)));\n })\n \n-(define_insn \"*extend<mode>si2_compact_reg\"\n+(define_insn_and_split \"*extend<mode>si2_compact_reg\"\n   [(set (match_operand:SI 0 \"arith_reg_dest\" \"=r\")\n \t(sign_extend:SI (match_operand:QIHI 1 \"arith_reg_operand\" \"r\")))]\n   \"TARGET_SH1\"\n   \"exts.<bw>\t%1,%0\"\n+  \"&& can_create_pseudo_p ()\"\n+  [(set (match_dup 0) (match_dup 2))]\n+{\n+  /* Sometimes combine fails to combine a T bit or negated T bit store to a\n+     reg with a following sign extension.  In the split pass after combine,\n+     try to figure the extended reg was set.  If it originated from the T\n+     bit we can replace the sign extension with a reg move, which will be\n+     eliminated.  */\n+  operands[2] = sh_try_omit_signzero_extend (operands[1], curr_insn);\n+  if (operands[2] == NULL_RTX)\n+    FAIL;\n+}\n   [(set_attr \"type\" \"arith\")])\n \n ;; FIXME: Fold non-SH2A and SH2A alternatives with \"enabled\" attribute.\n@@ -6629,10 +6629,19 @@ label:\n ;; picked to load/store regs.  If the regs regs are on the stack reload will\n ;; try other insns and not stick to movqi_reg_reg.\n ;; The same applies to the movhi variants.\n+;;\n+;; Notice, that T bit is not allowed as a mov src operand here.  This is to\n+;; avoid things like (set (reg:QI) (subreg:QI (reg:SI T_REG) 0)), which\n+;; introduces zero extensions after T bit stores and redundant reg copies.\n+;;\n+;; FIXME: We can't use 'arith_reg_operand' (which disallows T_REG) as a\n+;; predicate for the mov src operand because reload will have trouble\n+;; reloading MAC subregs otherwise.  For that probably special patterns\n+;; would be required.\n (define_insn \"*mov<mode>_reg_reg\"\n   [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=r\")\n \t(match_operand:QIHI 1 \"register_operand\" \"r\"))]\n-  \"TARGET_SH1\"\n+  \"TARGET_SH1 && !t_reg_operand (operands[1], VOIDmode)\"\n   \"mov\t%1,%0\"\n   [(set_attr \"type\" \"move\")])\n \n@@ -8178,28 +8187,17 @@ label:\n   rtx testing_insn = NULL_RTX;\n   rtx tested_reg = NULL_RTX;\n \n-  for (rtx i = prev_nonnote_insn_bb (curr_insn); i != NULL_RTX;\n-       i = prev_nonnote_insn_bb (i))\n+  set_of_reg s0 = sh_find_set_of_reg (get_t_reg_rtx (), curr_insn,\n+\t\t\t\t      prev_nonnote_insn_bb);\n+  if (s0.set_src != NULL_RTX\n+      && GET_CODE (s0.set_src) == EQ\n+      && REG_P (XEXP (s0.set_src, 0))\n+      && satisfies_constraint_Z (XEXP (s0.set_src, 1)))\n     {\n-      if (LABEL_P (i) || BARRIER_P (i))\n-\tbreak;\n-      if (!NONJUMP_INSN_P (i))\n-\tcontinue;\n-\n-      rtx p = PATTERN (i);\n-      if (p != NULL_RTX\n-\t  && GET_CODE (p) == SET && t_reg_operand (XEXP (p, 0), VOIDmode)\n-\t  && GET_CODE (XEXP (p, 1)) == EQ\n-\t  && REG_P (XEXP (XEXP (p, 1), 0))\n-\t  && satisfies_constraint_Z (XEXP (XEXP (p, 1), 1)))\n-\t{\n-\t  testing_insn = i;\n-\t  tested_reg = XEXP (XEXP (p, 1), 0);\n-\t  break;\n-\t}\n+      testing_insn = s0.insn;\n+      tested_reg = XEXP (s0.set_src, 0);\n     }\n-\n-  if (testing_insn == NULL_RTX)\n+  else\n     FAIL;\n \n   /* Continue scanning the insns backwards and try to find the insn that\n@@ -8213,47 +8211,37 @@ label:\n   if (reg_used_between_p (get_t_reg_rtx (), testing_insn, curr_insn))\n     FAIL;\n \n-  for (rtx i = prev_nonnote_insn_bb (testing_insn); i != NULL_RTX;\n-       i = prev_nonnote_insn_bb (i))\n+  while (true)\n     {\n-      if (LABEL_P (i) || BARRIER_P (i))\n+      set_of_reg s1 = sh_find_set_of_reg (tested_reg, s0.insn,\n+\t\t\t\t\t  prev_nonnote_insn_bb);\n+      if (s1.set_src == NULL_RTX)\n \tbreak;\n-      if (!NONJUMP_INSN_P (i))\n-\tcontinue;\n \n-      if (reg_set_p (tested_reg, i))\n+      if (t_reg_operand (s1.set_src, VOIDmode))\n+\toperands[2] = GEN_INT (treg_value ^ 1);\n+      else if (negt_reg_operand (s1.set_src, VOIDmode))\n+\toperands[2] = GEN_INT (treg_value);\n+      else if (REG_P (s1.set_src))\n \t{\n-\t  const_rtx tested_reg_set = set_of (tested_reg, i);\n-\n-\t  /* It could also be a clobber...  */\n-\t  if (tested_reg_set == NULL_RTX || GET_CODE (tested_reg_set) != SET)\n-\t    break;\n-\n-\t  rtx set_op1 = XEXP (tested_reg_set, 1);\n-\t  if (t_reg_operand (set_op1, VOIDmode))\n-\t    operands[2] = GEN_INT (treg_value ^ 1);\n-\t  else if (negt_reg_operand (set_op1, VOIDmode))\n-\t    operands[2] = GEN_INT (treg_value);\n-\t  else if (REG_P (set_op1))\n-\t    {\n-\t      /* If it's a reg-reg copy follow the copied reg.  This can\n-\t\t happen e.g. when T bit store zero-extensions are\n-\t\t eliminated.  */\n-\t      tested_reg = set_op1;\n-\t      continue;\n-\t    }\n+\t   /* If it's a reg-reg copy follow the copied reg.  This can\n+\t      happen e.g. when T bit store zero-extensions are\n+\t      eliminated.  */\n+\t  tested_reg = s1.set_src;\n+\t  s0.insn = s1.insn;\n+\t  continue;\n+\t}\n \n-\t  /* It's only safe to remove the testing insn if the T bit is not\n-\t     modified between the testing insn and the insn that stores the\n-\t     T bit.  Notice that some T bit stores such as negc also modify\n-\t     the T bit.  */\n-\t  if (modified_between_p (get_t_reg_rtx (), i, testing_insn)\n-\t      || modified_in_p (get_t_reg_rtx (), i))\n-\t    operands[2] = NULL_RTX;\n+\t/* It's only safe to remove the testing insn if the T bit is not\n+\t   modified between the testing insn and the insn that stores the\n+\t   T bit.  Notice that some T bit stores such as negc also modify\n+\t   the T bit.  */\n+\tif (modified_between_p (get_t_reg_rtx (), s1.insn, testing_insn)\n+\t    || modified_in_p (get_t_reg_rtx (), s1.insn))\n+\t  operands[2] = NULL_RTX;\n \n-\t  break;\n-\t}\n-    }\n+\tbreak;\n+      }\n \n   if (operands[2] == NULL_RTX)\n     FAIL;"}, {"sha": "31292eab9bedb6d001b952b2ee9b9a15a70ba8d8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -1,3 +1,8 @@\n+2012-10-15  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/51244\n+\t* gcc.target/sh/pr51244-17.c: New.\n+\n 2012-10-15  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/54760"}, {"sha": "e7d1ddd2ad0fa4e162c19d5f24e73f9ddae2cabd", "filename": "gcc/testsuite/gcc.target/sh/pr51244-17.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/26943929c00ae27dcd63706c642bc3d827adcf4a/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr51244-17.c?ref=26943929c00ae27dcd63706c642bc3d827adcf4a", "patch": "@@ -0,0 +1,297 @@\n+/* Check that no unnecessary zero extensions are done on values that are\n+   results of arithmetic with T bit inputs.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O1\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"extu|exts\" } } */\n+\n+int\n+test00 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x == y;\n+}\n+\n+int\n+test01 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == d;\n+  return x == y;\n+}\n+\n+int\n+test02 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c == d;\n+  return x == y;\n+}\n+\n+int\n+test03 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != d;\n+  return x == y;\n+}\n+\n+int\n+test04 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != d;\n+  return x == y;\n+}\n+\n+int\n+test05 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x != y;\n+}\n+\n+int\n+test06 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x ^ y;\n+}\n+\n+int\n+test07 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x | y;\n+}\n+\n+int\n+test08 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x & y;\n+}\n+\n+int\n+test09 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == d;\n+  return x != y;\n+}\n+\n+int\n+test10 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c == d;\n+  return x != y;\n+}\n+\n+int\n+test11 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != d;\n+  return x != y;\n+}\n+\n+int\n+test12 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != d;\n+  return x != y;\n+}\n+\n+int\n+test13 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  int z = d == e;\n+  return x == y || x == z;\n+}\n+\n+int\n+test14 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  int z = d == e;\n+  return x == y && x == z;\n+}\n+\n+int\n+test15 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c == 0;\n+  int z = d == e;\n+  return x == y || x == z;\n+}\n+\n+int\n+test16 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c == 0;\n+  int z = d == e;\n+  return x == y && x == z;\n+}\n+\n+int\n+test17 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  int z = d == e;\n+  return x == y || x == z;\n+}\n+\n+int\n+test18 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  int z = d == e;\n+  return x == y && x == z;\n+}\n+\n+int\n+test19 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  int z = d == e;\n+  return x == y || x == z;\n+}\n+\n+int\n+test20 (int a, int b, int c, int d, int e, int f)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  int z = d != e;\n+  return x == y && x == z;\n+}\n+\n+int\n+test21 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x + y;\n+}\n+\n+int\n+test22 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c == 0;\n+  return x + y;\n+}\n+\n+int\n+test23 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  return x + y;\n+}\n+\n+int\n+test24 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x - y;\n+}\n+\n+int\n+test25 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c == 0;\n+  return x - y;\n+}\n+\n+int\n+test26 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  return x - y;\n+}\n+\n+int\n+test27 (int a, int b, int c, int d)\n+{\n+  int x = a == b;\n+  int y = c == 0;\n+  return x * y;\n+}\n+\n+int\n+test28 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c == 0;\n+  return x * y;\n+}\n+\n+int\n+test29 (int a, int b, int c, int d)\n+{\n+  int x = a != b;\n+  int y = c != 0;\n+  return x * y;\n+}\n+\n+int\n+test30 (int a, int b)\n+{\n+  return ((a & 0x7F) == 1)\n+\t  | ((a & 0xFF00) == 0x0200)\n+\t  | ((a & 0xFF0000) == 0x030000);\n+}\n+\n+int\n+test31 (int a, int b)\n+{\n+  return ((a & 0x7F) == 1)\n+\t  | ((a & 0xFF00) == 0x0200)\n+\t  | ((a & 0xFF0000) == 0x030000)\n+\t  | ((a & 0xFF000000) == 0x04000000);\n+}\n+\n+int\n+test32 (int* a, int b, int c, volatile char* d)\n+{\n+  d[1] = a[0] != 0;\n+  return b;\n+}\n+\n+int\n+test33 (int* a, int b, int c, volatile char* d)\n+{\n+  d[1] = a[0] == 0;\n+  return b;\n+}\n+\n+char\n+test34 (int a, int* b)\n+{\n+  return (b[4] & b[0] & a) == a;\n+}\n+\n+unsigned char\n+test35 (int a, int* b)\n+{\n+  return (b[4] & b[0] & a) == a;\n+}"}]}