{"sha": "f4eafc3059ff40a88fc11bf734f544c57ab31d19", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjRlYWZjMzA1OWZmNDBhODhmYzExYmY3MzRmNTQ0YzU3YWIzMWQxOQ==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2012-10-29T21:56:35Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2012-10-29T21:56:35Z"}, "message": "Remove trailing white spaces\n\n\t* lra-assigns.c: Remove trailing white spaces.\n\t* lra-coalesce.c: Likewise.\n\t* lra-constraints.c: Likewise.\n\t* lra-eliminations.c: Likewise.\n\t* lra-int.h: Likewise.\n\t* lra-spills.c: Likewise.\n\t* lra.c: Likewise.\n\nFrom-SVN: r192966", "tree": {"sha": "cab472b4bdf7dfabadec5c05af91eb3f7dd11f46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cab472b4bdf7dfabadec5c05af91eb3f7dd11f46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4eafc3059ff40a88fc11bf734f544c57ab31d19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4eafc3059ff40a88fc11bf734f544c57ab31d19", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4eafc3059ff40a88fc11bf734f544c57ab31d19", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4eafc3059ff40a88fc11bf734f544c57ab31d19/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1ea58d3499b2362e735218eea1ca9f3f213534c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ea58d3499b2362e735218eea1ca9f3f213534c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ea58d3499b2362e735218eea1ca9f3f213534c4"}], "stats": {"total": 326, "additions": 168, "deletions": 158}, "files": [{"sha": "33f3497da424890e7227c5e680807d7c25bb64a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -1,3 +1,13 @@\n+2012-10-29  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\t* lra-assigns.c: Remove trailing white spaces.\n+\t* lra-coalesce.c: Likewise.\n+\t* lra-constraints.c: Likewise.\n+\t* lra-eliminations.c: Likewise.\n+\t* lra-int.h: Likewise.\n+\t* lra-spills.c: Likewise.\n+\t* lra.c: Likewise.\n+\n 2012-10-29  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \tPR c/53066"}, {"sha": "c558a4d2ca37bb7d3f0f09b57caa78432c414983", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -149,7 +149,7 @@ init_regno_assign_info (void)\n {\n   int i, regno1, regno2, max_regno = max_reg_num ();\n   lra_copy_t cp;\n-  \n+\n   regno_assign_info = XNEWVEC (struct regno_assign_info, max_regno);\n   for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n     {\n@@ -185,10 +185,10 @@ reload_pseudo_compare_func (const void *v1p, const void *v2p)\n   enum reg_class cl1 = regno_allocno_class_array[r1];\n   enum reg_class cl2 = regno_allocno_class_array[r2];\n   int diff;\n-  \n+\n   lra_assert (r1 >= lra_constraint_new_regno_start\n \t      && r2 >= lra_constraint_new_regno_start);\n-  \n+\n   /* Prefer to assign reload registers with smaller classes first to\n      guarantee assignment to all reload registers.  */\n   if ((diff = (ira_class_hard_regs_num[cl1]\n@@ -217,7 +217,7 @@ pseudo_compare_func (const void *v1p, const void *v2p)\n   /* Prefer to assign more frequently used registers first.  */\n   if ((diff = lra_reg_info[r2].freq - lra_reg_info[r1].freq) != 0)\n     return diff;\n-  \n+\n   /* If regs are equally good, sort by their numbers, so that the\n      results of qsort leave nothing to chance.\t*/\n   return r1 - r2;\n@@ -378,7 +378,7 @@ init_live_reload_and_inheritance_pseudos (void)\n {\n   int i, p, max_regno = max_reg_num ();\n   lra_live_range_t r;\n-  \n+\n   conflict_reload_and_inheritance_pseudos = sparseset_alloc (max_regno);\n   live_reload_and_inheritance_pseudos = XNEWVEC (bitmap_head, lra_live_max_point);\n   bitmap_obstack_initialize (&live_reload_and_inheritance_pseudos_bitmap_obstack);\n@@ -470,7 +470,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n       for (p = r->start + 1; p <= r->finish; p++)\n \t{\n \t  lra_live_range_t r2;\n-\t  \n+\n \t  for (r2 = start_point_ranges[p];\n \t       r2 != NULL;\n \t       r2 = r2->start_next)\n@@ -511,7 +511,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n \t\t [lra_reg_info[conflict_regno].biggest_mode]);\n \t/* Remember about multi-register pseudos.  For example, 2 hard\n \t   register pseudos can start on the same hard register but can\n-\t   not start on HR and HR+1/HR-1.  */ \n+\t   not start on HR and HR+1/HR-1.  */\n \tfor (hr = conflict_hr + 1;\n \t     hr < FIRST_PSEUDO_REGISTER && hr < conflict_hr + nregs;\n \t     hr++)\n@@ -810,7 +810,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n   EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi)\n     {\n       struct lra_insn_reg *ir;\n-      \n+\n       for (ir = lra_get_insn_regs (uid); ir != NULL; ir = ir->next)\n \tif (ir->regno >= FIRST_PSEUDO_REGISTER)\n \t  bitmap_set_bit (&insn_conflict_pseudos, ir->regno);\n@@ -867,7 +867,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \t      for (p = r->start; p <= r->finish; p++)\n \t\t{\n \t\t  lra_live_range_t r2;\n-\t\t  \n+\n \t\t  for (r2 = start_point_ranges[p];\n \t\t       r2 != NULL;\n \t\t       r2 = r2->start_next)\n@@ -913,7 +913,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap)\n \t  EXECUTE_IF_SET_IN_BITMAP (&spill_pseudos_bitmap, 0, spill_regno, bi)\n \t    {\n \t      rtx x;\n-\t      \n+\n \t      cost += lra_reg_info[spill_regno].freq;\n \t      if (ira_reg_equiv[spill_regno].memory != NULL\n \t\t  || ira_reg_equiv[spill_regno].constant != NULL)\n@@ -1038,7 +1038,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n \t  for (p = r->start + 1; p <= r->finish; p++)\n \t    {\n \t      lra_live_range_t r2;\n-\t      \n+\n \t      for (r2 = start_point_ranges[p];\n \t\t   r2 != NULL;\n \t\t   r2 = r2->start_next)\n@@ -1239,7 +1239,7 @@ assign_by_spills (void)\n \t  {\n \t    lra_insn_recog_data_t data;\n \t    struct lra_insn_reg *r;\n-\t      \n+\n \t    data = lra_get_insn_recog_data (insn);\n \t    for (r = data->regs; r != NULL; r = r->next)\n \t      {"}, {"sha": "6b5c3f0800c450ba6f7062b70d20b25e77f273f9", "filename": "gcc/lra-coalesce.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-coalesce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-coalesce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-coalesce.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -79,7 +79,7 @@ move_freq_compare_func (const void *v1p, const void *v2p)\n   rtx mv1 = *(const rtx *) v1p;\n   rtx mv2 = *(const rtx *) v2p;\n   int pri1, pri2;\n-  \n+\n   pri1 = BLOCK_FOR_INSN (mv1)->frequency;\n   pri2 = BLOCK_FOR_INSN (mv2)->frequency;\n   if (pri2 - pri1)"}, {"sha": "3eabab88019de02eacdcbd9925168b098eda4f7a", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 94, "deletions": 94, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -87,7 +87,7 @@\n \n        r <- ... or ... <- r\t\t r <- ... or ... <- r\n        ...\t\t\t\t s <- r (new insn -- save)\n-       ...\t\t\t  => \n+       ...\t\t\t  =>\n        ...\t\t\t\t r <- s (new insn -- restore)\n        ... <- r\t\t\t\t ... <- r\n \n@@ -250,14 +250,14 @@ in_class_p (rtx reg, enum reg_class cl, enum reg_class *new_class)\n   enum machine_mode reg_mode;\n   int class_size, hard_regno, nregs, i, j;\n   int regno = REGNO (reg);\n-  \n+\n   if (new_class != NULL)\n     *new_class = NO_REGS;\n   if (regno < FIRST_PSEUDO_REGISTER)\n     {\n       rtx final_reg = reg;\n       rtx *final_loc = &final_reg;\n-      \n+\n       lra_eliminate_reg_if_possible (final_loc);\n       return TEST_HARD_REG_BIT (reg_class_contents[cl], REGNO (*final_loc));\n     }\n@@ -447,7 +447,7 @@ static inline bool\n ok_for_index_p_nonstrict (rtx reg)\n {\n   unsigned regno = REGNO (reg);\n-  \n+\n   return regno >= FIRST_PSEUDO_REGISTER || REGNO_OK_FOR_INDEX_P (regno);\n }\n \n@@ -510,7 +510,7 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n       && (REG_P (y) || (GET_CODE (y) == SUBREG && REG_P (SUBREG_REG (y)))))\n     {\n       int j;\n-      \n+\n       i = get_hard_regno (x);\n       if (i < 0)\n \tgoto slow;\n@@ -538,7 +538,7 @@ operands_match_p (rtx x, rtx y, int y_hard_regno)\n   if (GET_CODE (y) == PRE_DEC || GET_CODE (y) == PRE_INC\n       || GET_CODE (y) == PRE_MODIFY)\n     return operands_match_p (x, XEXP (y, 0), -1);\n-  \n+\n  slow:\n \n   if (code == REG && GET_CODE (y) == SUBREG && REG_P (SUBREG_REG (y))\n@@ -711,13 +711,13 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t pseudo which is wrong when the input pseudo lives after the\n \t insn and as the new pseudo value is changed by the insn\n \t output.  Therefore we create the new pseudo from the output.\n-\t \n+\n \t We cannot reuse the current output register because we might\n \t have a situation like \"a <- a op b\", where the constraints\n \t force the second input operand (\"b\") to match the output\n \t operand (\"a\").  \"b\" must then be copied into a new register\n \t so that it doesn't clobber the current value of \"a\".  */\n-\t \n+\n       new_in_reg = new_out_reg\n \t= lra_create_new_reg_with_unique_value (outmode, out_rtx,\n \t\t\t\t\t\tgoal_class, \"\");\n@@ -773,12 +773,12 @@ reg_class_from_constraints (const char *p)\n \t\t    [op_class][base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t\t       ADDRESS, SCRATCH)]);\n \tbreak;\n-\t\n+\n       case 'g':\n       case 'r':\n \top_class = reg_class_subunion[op_class][GENERAL_REGS];\n \tbreak;\n-\t\n+\n       default:\n \tif (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n \t  {\n@@ -791,7 +791,7 @@ reg_class_from_constraints (const char *p)\n #endif\n \t    break;\n \t  }\n-\t\n+\n \top_class\n \t  = reg_class_subunion[op_class][REG_CLASS_FROM_CONSTRAINT (c, p)];\n \tbreak;\n@@ -1127,7 +1127,7 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n \n   if (GET_CODE (operand) != SUBREG)\n     return false;\n-  \n+\n   mode = GET_MODE (operand);\n   reg = SUBREG_REG (operand);\n   /* If we change address for paradoxical subreg of memory, the\n@@ -1219,7 +1219,7 @@ uses_hard_regs_p (rtx x, HARD_REG_SET set)\n       if (GET_MODE_SIZE (GET_MODE (x)) > GET_MODE_SIZE (mode))\n \tmode = GET_MODE (x);\n     }\n-  \n+\n   if (REG_P (x))\n     {\n       x_hard_regno = get_hard_regno (x);\n@@ -1329,7 +1329,7 @@ process_alt_operands (int only_alternative)\n       op = no_subreg_reg_operand[nop] = *curr_id->operand_loc[nop];\n       /* The real hard regno of the operand after the allocation.  */\n       hard_regno[nop] = get_hard_regno (op);\n-      \n+\n       operand_reg[nop] = op;\n       biggest_mode[nop] = GET_MODE (operand_reg[nop]);\n       if (GET_CODE (operand_reg[nop]) == SUBREG)\n@@ -1402,16 +1402,16 @@ process_alt_operands (int only_alternative)\n \t      curr_alt_matches[nop] = -1;\n \t      continue;\n \t    }\n-      \n+\n \t  op = no_subreg_reg_operand[nop];\n \t  mode = curr_operand_mode[nop];\n \n \t  win = did_match = winreg = offmemok = constmemok = false;\n \t  badop = true;\n-      \n+\n \t  early_clobber_p = false;\n \t  p = curr_static_id->operand_alternative[opalt_num].constraint;\n-      \n+\n \t  this_costly_alternative = this_alternative = NO_REGS;\n \t  /* We update set of possible hard regs besides its class\n \t     because reg class might be inaccurate.  For example,\n@@ -1424,11 +1424,11 @@ process_alt_operands (int only_alternative)\n \t  this_alternative_match_win = false;\n \t  this_alternative_offmemok = false;\n \t  this_alternative_matches = -1;\n-  \n+\n \t  /* An empty constraint should be excluded by the fast\n \t     track.  */\n \t  lra_assert (*p != 0 && *p != ',');\n-  \n+\n \t  /* Scan this alternative's specs for this operand; set WIN\n \t     if the operand fits any letter in this alternative.\n \t     Otherwise, clear BADOP if this operand could fit some\n@@ -1446,36 +1446,36 @@ process_alt_operands (int only_alternative)\n \t\tcase ',':\n \t\t  c = '\\0';\n \t\t  break;\n-\t\n+\n \t\tcase '=':  case '+': case '?': case '*': case '!':\n \t\tcase ' ': case '\\t':\n \t\t  break;\n-\t\t  \n+\n \t\tcase '%':\n \t\t  /* We only support one commutative marker, the first\n \t\t     one.  We already set commutative above.  */\n \t\t  break;\n-\t\t  \n+\n \t\tcase '&':\n \t\t  early_clobber_p = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase '#':\n \t\t  /* Ignore rest of this alternative.  */\n \t\t  c = '\\0';\n \t\t  break;\n-\t\t  \n+\n \t\tcase '0':  case '1':  case '2':\t case '3':  case '4':\n \t\tcase '5':  case '6':  case '7':\t case '8':  case '9':\n \t\t  {\n \t\t    int m_hregno;\n \t\t    bool match_p;\n-\t\t    \n+\n \t\t    m = strtoul (p, &end, 10);\n \t\t    p = end;\n \t\t    len = 0;\n \t\t    lra_assert (nop > m);\n-\t\t    \n+\n \t\t    this_alternative_matches = m;\n \t\t    m_hregno = get_hard_regno (*curr_id->operand_loc[m]);\n \t\t    /* We are supposed to match a previous operand.\n@@ -1511,7 +1511,7 @@ process_alt_operands (int only_alternative)\n \t\t\t    && MEM_P (*curr_id->operand_loc[m])\n \t\t\t    && curr_alt[m] == NO_REGS && ! curr_alt_win[m])\n \t\t\t  continue;\n-\t\t\t\n+\n \t\t      }\n \t\t    else\n \t\t      {\n@@ -1533,7 +1533,7 @@ process_alt_operands (int only_alternative)\n \t\t\t      += (ira_reg_class_max_nregs[curr_alt[m]]\n \t\t\t\t  [GET_MODE (*curr_id->operand_loc[m])]);\n \t\t\t  }\n-\t\t\t\n+\n \t\t\t/* We prefer no matching alternatives because\n \t\t\t   it gives more freedom in RA.\t */\n \t\t\tif (operand_reg[nop] == NULL_RTX\n@@ -1556,7 +1556,7 @@ process_alt_operands (int only_alternative)\n \t\t      }\n \t\t    else\n \t\t      did_match = true;\n-\t\t    \n+\n \t\t    /* This can be fixed with reloads if the operand\n \t\t       we are supposed to match can be fixed with\n \t\t       reloads. */\n@@ -1565,7 +1565,7 @@ process_alt_operands (int only_alternative)\n \t\t    COPY_HARD_REG_SET (this_alternative_set, curr_alt_set[m]);\n \t\t    break;\n \t\t  }\n-\t\t  \n+\n \t\tcase 'p':\n \t\t  cl = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n \t\t\t\t       ADDRESS, SCRATCH);\n@@ -1582,36 +1582,36 @@ process_alt_operands (int only_alternative)\n \t\t  win = true;\n \t\t  badop = false;\n \t\t  break;\n-\t\t  \n+\n \t\tcase TARGET_MEM_CONSTRAINT:\n \t\t  if (MEM_P (op) || spilled_pseudo_p (op))\n \t\t    win = true;\n \t\t  if (CONST_POOL_OK_P (mode, op))\n \t\t    badop = false;\n \t\t  constmemok = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase '<':\n \t\t  if (MEM_P (op)\n \t\t      && (GET_CODE (XEXP (op, 0)) == PRE_DEC\n \t\t\t  || GET_CODE (XEXP (op, 0)) == POST_DEC))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase '>':\n \t\t  if (MEM_P (op)\n \t\t      && (GET_CODE (XEXP (op, 0)) == PRE_INC\n \t\t\t  || GET_CODE (XEXP (op, 0)) == POST_INC))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\t  /* Memory op whose address is not offsettable.  */\n \t\tcase 'V':\n \t\t  if (MEM_P (op)\n \t\t      && ! offsettable_nonstrict_memref_p (op))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\t  /* Memory operand whose address is offsettable.  */\n \t\tcase 'o':\n \t\t  if ((MEM_P (op)\n@@ -1623,22 +1623,22 @@ process_alt_operands (int only_alternative)\n \t\t  constmemok = true;\n \t\t  offmemok = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase 'E':\n \t\tcase 'F':\n \t\t  if (GET_CODE (op) == CONST_DOUBLE\n \t\t      || (GET_CODE (op) == CONST_VECTOR\n \t\t\t  && (GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase 'G':\n \t\tcase 'H':\n \t\t  if (GET_CODE (op) == CONST_DOUBLE\n \t\t      && CONST_DOUBLE_OK_FOR_CONSTRAINT_P (op, c, p))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase 's':\n \t\t  if (CONST_INT_P (op)\n \t\t      || (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode))\n@@ -1647,13 +1647,13 @@ process_alt_operands (int only_alternative)\n \t\t  if (general_constant_p (op))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase 'n':\n \t\t  if (CONST_INT_P (op)\n \t\t      || (GET_CODE (op) == CONST_DOUBLE && mode == VOIDmode))\n \t\t    win = true;\n \t\t  break;\n-\t\n+\n \t\tcase 'I':\n \t\tcase 'J':\n \t\tcase 'K':\n@@ -1666,20 +1666,20 @@ process_alt_operands (int only_alternative)\n \t\t      && CONST_OK_FOR_CONSTRAINT_P (INTVAL (op), c, p))\n \t\t    win = true;\n \t\t  break;\n-\t\t  \n+\n \t\tcase 'X':\n \t\t  /* This constraint should be excluded by the fast\n \t\t     track.  */\n \t\t  gcc_unreachable ();\n \t\t  break;\n-\t\t  \n+\n \t\tcase 'g':\n \t\t  if (MEM_P (op)\n \t\t      || general_constant_p (op)\n \t\t      || spilled_pseudo_p (op))\n \t\t    win = true;\n \t\t  /* Drop through into 'r' case.  */\n-\t\t  \n+\n \t\tcase 'r':\n \t\t  this_alternative\n \t\t    = reg_class_subunion[this_alternative][GENERAL_REGS];\n@@ -1694,7 +1694,7 @@ process_alt_operands (int only_alternative)\n \t\t\t\t\treg_class_contents[GENERAL_REGS]);\n \t\t    }\n \t\t  goto reg;\n-\t\t  \n+\n \t\tdefault:\n \t\t  if (REG_CLASS_FROM_CONSTRAINT (c, p) == NO_REGS)\n \t\t    {\n@@ -1705,7 +1705,7 @@ process_alt_operands (int only_alternative)\n \t\t\t    win = true;\n \t\t\t  else if (spilled_pseudo_p (op))\n \t\t\t    win = true;\n-\t\t\t  \n+\n \t\t\t  /* If we didn't already win, we can reload\n \t\t\t     constants via force_const_mem, and other\n \t\t\t     MEMs by reloading the address like for\n@@ -1720,7 +1720,7 @@ process_alt_operands (int only_alternative)\n \t\t\t{\n \t\t\t  if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t\t    win = true;\n-\t\t\t  \n+\n \t\t\t  /* If we didn't already win, we can reload\n \t\t\t     the address into a base register.\t*/\n \t\t\t  cl = base_reg_class (VOIDmode, ADDR_SPACE_GENERIC,\n@@ -1740,13 +1740,13 @@ process_alt_operands (int only_alternative)\n \t\t\t  badop = false;\n \t\t\t  break;\n \t\t\t}\n-\t\t      \n+\n \t\t      if (EXTRA_CONSTRAINT_STR (op, c, p))\n \t\t\twin = true;\n #endif\n \t\t      break;\n \t\t    }\n-\t\t  \n+\n \t\t  cl = REG_CLASS_FROM_CONSTRAINT (c, p);\n \t\t  this_alternative = reg_class_subunion[this_alternative][cl];\n \t\t  IOR_HARD_REG_SET (this_alternative_set,\n@@ -1778,7 +1778,7 @@ process_alt_operands (int only_alternative)\n \t\tcostly_p = c == '*';\n \t    }\n \t  while ((p += len), c);\n-  \n+\n \t  /* Record which operands fit this alternative.  */\n \t  if (win)\n \t    {\n@@ -1827,7 +1827,7 @@ process_alt_operands (int only_alternative)\n \t\t then this operand can be reloaded.  */\n \t      if (winreg && !no_regs_p)\n \t\tbadop = false;\n-\t      \n+\n \t      if (badop)\n \t\tgoto fail;\n \n@@ -1880,7 +1880,7 @@ process_alt_operands (int only_alternative)\n \t\t  if (! no_regs_p)\n \t\t    losers++;\n \t\t}\n-      \n+\n \t      /* Alternative loses if it requires a type of reload not\n \t\t permitted for this insn.  We can always reload\n \t\t objects with a REG_UNUSED note.  */\n@@ -1890,7 +1890,7 @@ process_alt_operands (int only_alternative)\n \t\t  || (curr_static_id->operand[nop].type != OP_OUT\n \t\t      && no_input_reloads_p && ! const_to_mem))\n \t\tgoto fail;\n-      \n+\n \t      /* If we can't reload this value at all, reject this\n \t\t alternative.  Note that we could also lose due to\n \t\t LIMIT_RELOAD_CLASS, but we don't check that here.  */\n@@ -1899,13 +1899,13 @@ process_alt_operands (int only_alternative)\n \t\t  if (targetm.preferred_reload_class\n \t\t      (op, this_alternative) == NO_REGS)\n \t\t    reject = MAX_OVERALL_COST_BOUND;\n-\t  \n+\n \t\t  if (curr_static_id->operand[nop].type == OP_OUT\n \t\t      && (targetm.preferred_output_reload_class\n \t\t\t  (op, this_alternative) == NO_REGS))\n \t\t    reject = MAX_OVERALL_COST_BOUND;\n \t\t}\n-      \n+\n \t      if (! ((const_to_mem && constmemok)\n \t\t     || (MEM_P (op) && offmemok)))\n \t\t{\n@@ -1918,7 +1918,7 @@ process_alt_operands (int only_alternative)\n \t\t     match then.  */\n \t\t  if (! (REG_P (op) && REGNO (op) >= FIRST_PSEUDO_REGISTER))\n \t\t    reject += 2;\n-\t\t  \n+\n \t\t  if (! no_regs_p)\n \t\t    reload_nregs\n \t\t      += ira_reg_class_max_nregs[this_alternative][mode];\n@@ -1930,7 +1930,7 @@ process_alt_operands (int only_alternative)\n \t      if (!REG_P (op) || curr_static_id->operand[nop].type != OP_IN)\n \t\treject++;\n \t    }\n-  \n+\n \t  if (early_clobber_p)\n \t    reject++;\n \t  /* ??? We check early clobbers after processing all operands\n@@ -1948,11 +1948,11 @@ process_alt_operands (int only_alternative)\n \t  curr_alt_match_win[nop] = this_alternative_match_win;\n \t  curr_alt_offmemok[nop] = this_alternative_offmemok;\n \t  curr_alt_matches[nop] = this_alternative_matches;\n-  \n+\n \t  if (this_alternative_matches >= 0\n \t      && !did_match && !this_alternative_win)\n \t    curr_alt_win[this_alternative_matches] = false;\n-  \n+\n \t  if (early_clobber_p && operand_reg[nop] != NULL_RTX)\n \t    early_clobbered_nops[early_clobbered_regs_num++] = nop;\n \t}\n@@ -2054,7 +2054,7 @@ process_alt_operands (int only_alternative)\n \t}\n       if (losers == 0)\n \t/* Everything is satisfied.  Do not process alternatives\n-\t   anymore.  */ \n+\t   anymore.  */\n \tbreak;\n     fail:\n       ;\n@@ -2073,7 +2073,7 @@ valid_address_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n   lra_assert (ADDR_SPACE_GENERIC_P (as));\n   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);\n   return 0;\n-  \n+\n  win:\n   return 1;\n #else\n@@ -2660,7 +2660,7 @@ curr_insn_transform (void)\n \tchange_p = true;\n \tlra_update_dup (curr_id, i);\n       }\n-  \n+\n   if (change_p)\n     /* If we've changed the instruction then any alternative that\n        we chose previously may no longer be valid.  */\n@@ -2798,7 +2798,7 @@ curr_insn_transform (void)\n   /* Right now, for any pair of operands I and J that are required to\n      match, with J < I, goal_alt_matches[I] is J.  Add I to\n      goal_alt_matched[J].  */\n-  \n+\n   for (i = 0; i < n_operands; i++)\n     if ((j = goal_alt_matches[i]) >= 0)\n       {\n@@ -2814,10 +2814,10 @@ curr_insn_transform (void)\n \tgoal_alt_matched[j][k] = i;\n \tgoal_alt_matched[j][k + 1] = -1;\n       }\n-  \n+\n   for (i = 0; i < n_operands; i++)\n     goal_alt_win[i] |= goal_alt_match_win[i];\n-  \n+\n   /* Any constants that aren't allowed and can't be reloaded into\n      registers are here changed into memory references.\t */\n   for (i = 0; i < n_operands; i++)\n@@ -2829,7 +2829,7 @@ curr_insn_transform (void)\n \n \tif (GET_CODE (reg) == SUBREG)\n \t  reg = SUBREG_REG (reg);\n-\t    \n+\n \tif (REG_P (reg) && (regno = REGNO (reg)) >= FIRST_PSEUDO_REGISTER)\n \t  {\n \t    bool ok_p = in_class_p (reg, goal_alt[i], &new_class);\n@@ -2848,29 +2848,29 @@ curr_insn_transform (void)\n \trtx op = *curr_id->operand_loc[i];\n \trtx subreg = NULL_RTX;\n \tenum machine_mode mode = curr_operand_mode[i];\n-\t\n+\n \tif (GET_CODE (op) == SUBREG)\n \t  {\n \t    subreg = op;\n \t    op = SUBREG_REG (op);\n \t    mode = GET_MODE (op);\n \t  }\n-\t\n+\n \tif (CONST_POOL_OK_P (mode, op)\n \t    && ((targetm.preferred_reload_class\n \t\t (op, (enum reg_class) goal_alt[i]) == NO_REGS)\n \t\t|| no_input_reloads_p))\n \t  {\n \t    rtx tem = force_const_mem (mode, op);\n-\t    \n+\n \t    change_p = true;\n \t    if (subreg != NULL_RTX)\n \t      tem = gen_rtx_SUBREG (mode, tem, SUBREG_BYTE (subreg));\n-\t    \n+\n \t    *curr_id->operand_loc[i] = tem;\n \t    lra_update_dup (curr_id, i);\n \t    process_address (i, &before, &after);\n-\t    \n+\n \t    /* If the alternative accepts constant pool refs directly\n \t       there will be no reload needed at all.  */\n \t    if (subreg != NULL_RTX)\n@@ -2892,11 +2892,11 @@ curr_insn_transform (void)\n \t      }\n \t    if (c == '\\0' || c == ',' || c == '#')\n \t      continue;\n-\t    \n+\n \t    goal_alt_win[i] = true;\n \t  }\n       }\n-  \n+\n   for (i = 0; i < n_operands; i++)\n     {\n       rtx old, new_reg;\n@@ -2915,7 +2915,7 @@ curr_insn_transform (void)\n \t    change_class (REGNO (op), NO_REGS, \"      Change\", true);\n \t  continue;\n \t}\n-      \n+\n       /* Operands that match previous ones have already been handled.  */\n       if (goal_alt_matches[i] >= 0)\n \tcontinue;\n@@ -3172,10 +3172,10 @@ multi_block_pseudo_p (int regno)\n   basic_block bb = NULL;\n   unsigned int uid;\n   bitmap_iterator bi;\n-  \n+\n   if (regno < FIRST_PSEUDO_REGISTER)\n     return false;\n-  \n+\n     EXECUTE_IF_SET_IN_BITMAP (&lra_reg_info[regno].insn_bitmap, 0, uid, bi)\n       if (bb == NULL)\n \tbb = BLOCK_FOR_INSN (lra_insn_recog_data[uid]->insn);\n@@ -3273,7 +3273,7 @@ lra_constraints (bool first_p)\n \tif ((hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n \t  {\n \t    int j, nregs = hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (i)];\n-\t    \n+\n \t    for (j = 0; j < nregs; j++)\n \t      df_set_regs_ever_live (hard_regno + j, true);\n \t  }\n@@ -3326,7 +3326,7 @@ lra_constraints (bool first_p)\n     {\n       curr_insn = lra_pop_insn ();\n       --new_min_len;\n-      curr_bb = BLOCK_FOR_INSN (curr_insn); \n+      curr_bb = BLOCK_FOR_INSN (curr_insn);\n       if (curr_bb != last_bb)\n \t{\n \t  last_bb = curr_bb;\n@@ -3366,7 +3366,7 @@ lra_constraints (bool first_p)\n \t\t      can not be changed.  Such insns might be not in\n \t\t      init_insns because we don't update equiv data\n \t\t      during insn transformations.\n-\t\t\t  \n+\n \t\t      As an example, let suppose that a pseudo got\n \t\t      hard register and on the 1st pass was not\n \t\t      changed to equivalent constant.  We generate an\n@@ -3420,7 +3420,7 @@ lra_constraints (bool first_p)\n \t    && (hard_regno = lra_get_regno_hard_regno (i)) >= 0)\n \t  {\n \t    int j, nregs = hard_regno_nregs[hard_regno][PSEUDO_REGNO_MODE (i)];\n-\t    \n+\n \t    for (j = 0; j < nregs; j++)\n \t      lra_assert (df_regs_ever_live_p (hard_regno + j));\n \t  }\n@@ -3504,7 +3504,7 @@ static void\n add_next_usage_insn (int regno, rtx insn, int reloads_num)\n {\n   rtx next_usage_insns;\n-  \n+\n   if (usage_insns[regno].check == curr_usage_insns_check\n       && (next_usage_insns = usage_insns[regno].insns) != NULL_RTX\n       && DEBUG_INSN_P (insn))\n@@ -3521,7 +3521,7 @@ add_next_usage_insn (int regno, rtx insn, int reloads_num)\n   else\n     usage_insns[regno].check = 0;\n }\n-  \n+\n /* Replace all references to register OLD_REGNO in *LOC with pseudo\n    register NEW_REG.  Return true if any change was made.  */\n static bool\n@@ -3637,8 +3637,8 @@ static bitmap_head check_only_regs;\n      ...\t     =>\n      <- ... p ...\t  <- ... i ...\n    where p is a spilled original pseudo and i is a new inheritance pseudo.\n-   \n-   \n+\n+\n    The inheritance pseudo has the smallest class of two classes CL and\n    class of ORIGINAL REGNO.  */\n static bool\n@@ -3677,7 +3677,7 @@ inherit_reload_reg (bool def_p, int original_regno,\n       if (lra_dump_file != NULL)\n \tfprintf (lra_dump_file, \"    Use smallest class of %s and %s\\n\",\n \t\t reg_class_names[cl], reg_class_names[rclass]);\n-      \n+\n       rclass = cl;\n     }\n   if (check_secondary_memory_needed_p (cl, next_usage_insns))\n@@ -3857,7 +3857,7 @@ choose_split_class (enum reg_class allocno_class,\n   int i;\n   enum reg_class cl, best_cl = NO_REGS;\n   enum reg_class hard_reg_class = REGNO_REG_CLASS (hard_regno);\n-  \n+\n   if (! SECONDARY_MEMORY_NEEDED (allocno_class, allocno_class, mode)\n       && TEST_HARD_REG_BIT (reg_class_contents[allocno_class], hard_regno))\n     return allocno_class;\n@@ -3928,7 +3928,7 @@ split_reg (bool before_p, int original_regno, rtx insn, rtx next_usage_insns)\n   if (call_save_p)\n     {\n       enum machine_mode sec_mode;\n-      \n+\n #ifdef SECONDARY_MEMORY_NEEDED_MODE\n       sec_mode = SECONDARY_MEMORY_NEEDED_MODE (GET_MODE (original_reg));\n #else\n@@ -4088,7 +4088,7 @@ update_ebb_live_info (rtx head, rtx tail)\n   edge e;\n   edge_iterator ei;\n \n-  last_bb = BLOCK_FOR_INSN (tail); \n+  last_bb = BLOCK_FOR_INSN (tail);\n   prev_bb = NULL;\n   for (curr_insn = tail;\n        curr_insn != PREV_INSN (head);\n@@ -4236,7 +4236,7 @@ get_live_on_other_edges (basic_block from, basic_block to, bitmap res)\n     if (reg->type != OP_IN)\n       bitmap_set_bit (res, reg->regno);\n }\n-\t\n+\n /* Used as a temporary results of some bitmap calculations.  */\n static bitmap_head temp_bitmap;\n \n@@ -4287,7 +4287,7 @@ inherit_in_ebb (rtx head, rtx tail)\n \t     pseudos for potential splitting.  */\n \t  to_process = df_get_live_out (curr_bb);\n \t  if (last_processed_bb != NULL)\n-\t    {\t\n+\t    {\n \t      /* We are somewhere in the middle of EBB.\t */\n \t      get_live_on_other_edges (curr_bb, last_processed_bb,\n \t\t\t\t       &temp_bitmap);\n@@ -4388,7 +4388,7 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t\t= usage_insns[dst_regno].insns) != NULL_RTX)\n \t\t  {\n \t\t    struct lra_insn_reg *r;\n-\t\t    \n+\n \t\t    for (r = curr_id->regs; r != NULL; r = r->next)\n \t\t      if (r->type != OP_OUT && r->regno == dst_regno)\n \t\t\tbreak;\n@@ -4407,7 +4407,7 @@ inherit_in_ebb (rtx head, rtx tail)\n \t\t    && ! reg->subreg_p && reg->type == OP_OUT)\n \t\t  {\n \t\t    HARD_REG_SET s;\n-\t\t    \n+\n \t\t    if (split_if_necessary (dst_regno, reg->biggest_mode,\n \t\t\t\t\t    potential_reload_hard_regs,\n \t\t\t\t\t    false, curr_insn, max_uid))\n@@ -4554,7 +4554,7 @@ inherit_in_ebb (rtx head, rtx tail)\n \t     rest of spliting in the current BB.  */\n \t  to_process = df_get_live_in (curr_bb);\n \t  if (BLOCK_FOR_INSN (head) != curr_bb)\n-\t    {\t\n+\t    {\n \t      /* We are somewhere in the middle of EBB.\t */\n \t      get_live_on_other_edges (EDGE_PRED (curr_bb, 0)->src,\n \t\t\t\t       curr_bb, &temp_bitmap);\n@@ -4591,7 +4591,7 @@ inherit_in_ebb (rtx head, rtx tail)\n \n /* This value affects EBB forming.  If probability of edge from EBB to\n    a BB is not greater than the following value, we don't add the BB\n-   to EBB.  */ \n+   to EBB.  */\n #define EBB_PROBABILITY_CUTOFF (REG_BR_PROB_BASE / 2)\n \n /* Current number of inheritance/split iteration.  */\n@@ -4734,7 +4734,7 @@ remove_inheritance_pseudos (bitmap remove_pseudos)\n \t      dregno = get_regno (SET_DEST (set));\n \t      sregno = get_regno (SET_SRC (set));\n \t    }\n-\t  \n+\n \t  if (sregno >= 0 && dregno >= 0)\n \t    {\n \t      if ((bitmap_bit_p (remove_pseudos, sregno)"}, {"sha": "5f8a8c8d41f7e97f9c2a135ea7c67834c69907f3", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -81,25 +81,25 @@ along with GCC; see the file COPYING3.\tIf not see\n struct elim_table\n {\n   /* Hard register number to be eliminated.  */\n-  int from;\t\t\t\n+  int from;\n   /* Hard register number used as replacement.\t*/\n-  int to;\t\t\t\n+  int to;\n   /* Difference between values of the two hard registers above on\n      previous iteration.  */\n   HOST_WIDE_INT previous_offset;\n   /* Difference between the values on the current iteration.  */\n-  HOST_WIDE_INT offset;\t\t\n+  HOST_WIDE_INT offset;\n   /* Nonzero if this elimination can be done.  */\n-  bool can_eliminate;\t\t\n+  bool can_eliminate;\n   /* CAN_ELIMINATE since the last check.  */\n   bool prev_can_eliminate;\n   /* REG rtx for the register to be eliminated.\t We cannot simply\n      compare the number since we might then spuriously replace a hard\n      register corresponding to a pseudo assigned to the reg to be\n      eliminated.  */\n-  rtx from_rtx;\t\t\t\n+  rtx from_rtx;\n   /* REG rtx for the replacement.  */\n-  rtx to_rtx;\t\t\t\n+  rtx to_rtx;\n };\n \n /* The elimination table.  Each array entry describes one possible way\n@@ -335,7 +335,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n       if ((ep = get_elimination (x)) != NULL)\n \t{\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n-\t  \n+\n \t  if (update_p)\n \t    return plus_constant (Pmode, to, ep->offset - ep->previous_offset);\n \t  else if (full_p)\n@@ -354,10 +354,10 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t    {\n \t      HOST_WIDE_INT offset;\n \t      rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n-\t      \n+\n \t      if (! update_p && ! full_p)\n \t\treturn gen_rtx_PLUS (Pmode, to, XEXP (x, 1));\n-\t      \n+\n \t      offset = (update_p\n \t\t\t? ep->offset - ep->previous_offset : ep->offset);\n \t      if (CONST_INT_P (XEXP (x, 1))\n@@ -405,7 +405,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t  && (ep = get_elimination (XEXP (x, 0))) != NULL)\n \t{\n \t  rtx to = subst_p ? ep->to_rtx : ep->from_rtx;\n-\t  \n+\n \t  if (update_p)\n \t    return\n \t      plus_constant (Pmode,\n@@ -420,7 +420,7 @@ lra_eliminate_regs_1 (rtx x, enum machine_mode mem_mode,\n \t  else\n \t    return gen_rtx_MULT (Pmode, to, XEXP (x, 1));\n \t}\n-      \n+\n       /* ... fall through ...  */\n \n     case CALL:\n@@ -777,7 +777,7 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n       && (ep = get_elimination (SET_DEST (old_set))) != NULL)\n     {\n       bool delete_p = replace_p;\n-      \n+\n #ifdef HARD_FRAME_POINTER_REGNUM\n       /* If this is setting the frame pointer register to the hardware\n \t frame pointer register and this is an elimination that will\n@@ -798,11 +798,11 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t      rtx base = SET_SRC (old_set);\n \t      HOST_WIDE_INT offset = 0;\n \t      rtx base_insn = insn;\n-\t      \n+\n \t      while (base != ep->to_rtx)\n \t\t{\n \t\t  rtx prev_insn, prev_set;\n-\t\t  \n+\n \t\t  if (GET_CODE (base) == PLUS && CONST_INT_P (XEXP (base, 1)))\n \t\t    {\n \t\t      offset += INTVAL (XEXP (base, 1));\n@@ -818,14 +818,14 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t\t  else\n \t\t    break;\n \t\t}\n-\t      \n+\n \t      if (base == ep->to_rtx)\n \t\t{\n \t\t  rtx src;\n-\t\t  \n+\n \t\t  offset -= (ep->offset - ep->previous_offset);\n \t\t  src = plus_constant (Pmode, ep->to_rtx, offset);\n-\t\t  \n+\n \t\t  /* First see if this insn remains valid when we make\n \t\t     the change.  If not, keep the INSN_CODE the same\n \t\t     and let the constraint pass fit it up.  */\n@@ -841,14 +841,14 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t\t  return;\n \t\t}\n \t    }\n-\t  \n-\t  \n+\n+\n \t  /* We can't delete this insn, but needn't process it\n \t     since it won't be used unless something changes.  */\n \t  delete_p = false;\n \t}\n #endif\n-      \n+\n       /* This insn isn't serving a useful purpose.  We delete it\n \t when REPLACE is set.  */\n       if (delete_p)\n@@ -892,13 +892,13 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n       if (REG_P (reg) && (ep = get_elimination (reg)) != NULL)\n \t{\n \t  rtx to_rtx = replace_p ? ep->to_rtx : ep->from_rtx;\n-\t  \n+\n \t  if (! replace_p)\n \t    {\n \t      offset += (ep->offset - ep->previous_offset);\n \t      offset = trunc_int_for_mode (offset, GET_MODE (plus_cst_src));\n \t    }\n-\t  \n+\n \t  if (GET_CODE (XEXP (plus_cst_src, 0)) == SUBREG)\n \t    to_rtx = gen_lowpart (GET_MODE (XEXP (plus_cst_src, 0)), to_rtx);\n \t  /* If we have a nonzero offset, and the source is already a\n@@ -909,7 +909,7 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t  if (offset == 0 || plus_src)\n \t    {\n \t      rtx new_src = plus_constant (GET_MODE (to_rtx), to_rtx, offset);\n-\t      \n+\n \t      old_set = single_set (insn);\n \n \t      /* First see if this insn remains valid when we make the\n@@ -923,7 +923,7 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t\t{\n \t\t  rtx new_pat = gen_rtx_SET (VOIDmode,\n \t\t\t\t\t     SET_DEST (old_set), new_src);\n-\t\t  \n+\n \t\t  if (! validate_change (insn, &PATTERN (insn), new_pat, 0))\n \t\t    SET_SRC (old_set) = new_src;\n \t\t}\n@@ -1153,7 +1153,7 @@ init_elim_table (void)\n       ep->to = ep1->to;\n       value_p = (targetm.can_eliminate (ep->from, ep->to)\n \t\t && ! (ep->to == STACK_POINTER_REGNUM\n-\t\t       && frame_pointer_needed \n+\t\t       && frame_pointer_needed\n \t\t       && (! SUPPORTS_STACK_ALIGNMENT\n \t\t\t   || ! stack_realign_fp)));\n       setup_can_eliminate (ep, value_p);"}, {"sha": "ffb56bb824b362abb3c7ecf524d5d99ef4b44536", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -390,7 +390,7 @@ lra_update_operator_dups (lra_insn_recog_data_t id)\n   for (i = 0; i < static_id->n_dups; i++)\n     {\n       int ndup = static_id->dup_num[i];\n-      \n+\n       if (static_id->operand[ndup].is_operator)\n \t*id->dup_loc[i] = *id->operand_loc[ndup];\n     }"}, {"sha": "8b666499fe957e2e2300c7303d2662c68e01ab58", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -34,7 +34,7 @@ along with GCC; see the file COPYING3.\tIf not see\n      end\n      create new stack slot S and assign P to S\n    end\n- \n+\n    The actual algorithm is bit more complicated because of different\n    pseudo sizes.\n \n@@ -143,9 +143,9 @@ assign_mem_slot (int i)\n \n   lra_assert (regno_reg_rtx[i] != NULL_RTX && REG_P (regno_reg_rtx[i])\n \t      && lra_reg_info[i].nrefs != 0 && reg_renumber[i] < 0);\n-  \n+\n   x = slots[pseudo_slots[i].slot_num].mem;\n-  \n+\n   /* We can use a slot already allocated because it is guaranteed the\n      slot provides both enough inherent space and enough total\n      space.  */\n@@ -181,14 +181,14 @@ assign_mem_slot (int i)\n \t}\n       slots[pseudo_slots[i].slot_num].mem = stack_slot;\n     }\n-      \n+\n   /* On a big endian machine, the \"address\" of the slot is the address\n      of the low part that fits its inherent mode.  */\n   if (BYTES_BIG_ENDIAN && inherent_size < total_size)\n     adjust += (total_size - inherent_size);\n-  \n+\n   x = adjust_address_nv (x, GET_MODE (regno_reg_rtx[i]), adjust);\n-  \n+\n   /* Set all of the memory attributes as appropriate for a spill.  */\n   set_mem_attrs_for_spill (x);\n   pseudo_slots[i].mem = x;\n@@ -265,7 +265,7 @@ assign_spill_hard_regs (int *pseudo_regnos, int n)\n   bitmap setjump_crosses = regstat_get_setjmp_crosses ();\n   /* Hard registers which can not be used for any purpose at given\n      program point because they are unallocatable or already allocated\n-     for other pseudos.\t */ \n+     for other pseudos.\t */\n   HARD_REG_SET *reserved_hard_regs;\n \n   if (! lra_reg_spill_p)\n@@ -604,7 +604,7 @@ alter_subregs (rtx *loc, bool final_p)\n       else if (fmt[i] == 'E')\n \t{\n \t  int j;\n-\t  \n+\n \t  for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n \t    if (alter_subregs (&XVECEXP (x, i, j), final_p))\n \t      res = true;"}, {"sha": "33f48d5d4e47d9e17c5c4634b53afded35f26395", "filename": "gcc/lra.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4eafc3059ff40a88fc11bf734f544c57ab31d19/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=f4eafc3059ff40a88fc11bf734f544c57ab31d19", "patch": "@@ -44,12 +44,12 @@ along with GCC; see the file COPYING3.\tIf not see\n \n    Here is block diagram of LRA passes:\n \n-\t  ---------------------\t\t\t\t    \n-\t | Undo inheritance    |      ---------------\t     --------------- \n+\t  ---------------------\n+\t | Undo inheritance    |      ---------------\t     ---------------\n \t | for spilled pseudos)|     | Memory-memory |\t    | New (and old) |\n \t | and splits (for     |<----| move coalesce |<-----|\t pseudos    |\n \t | pseudos got the     |      ---------------\t    |\tassignment  |\n-  Start\t |  same  hard regs)   |\t\t\t     --------------- \n+  Start\t |  same  hard regs)   |\t\t\t     ---------------\n     |\t  ---------------------\t\t\t\t\t    ^\n     V\t\t  |\t\t ----------------\t\t    |\n  -----------\t  V\t\t| Update virtual |\t\t    |\n@@ -63,7 +63,7 @@ along with GCC; see the file COPYING3.\tIf not see\n \t|    to memory\t |<-------|    RTL     |--------->|  transformations  |\n \t|  substitution\t |\t  | transfor-  |\t  |    in EBB scope   |\n \t ----------------\t  |  mations   |\t   -------------------\n-\t\t|\t\t    ------------ \n+\t\t|\t\t    ------------\n \t\tV\n     -------------------------\n    | Hard regs substitution, |\n@@ -958,7 +958,7 @@ collect_non_operand_hard_regs (rtx *x, lra_insn_recog_data_t data,\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early\n-\t clobber (the behavior is expected from asm).  */ \n+\t clobber (the behavior is expected from asm).  */\n       list = collect_non_operand_hard_regs (&XEXP (op, 0), data,\n \t\t\t\t\t    list, OP_OUT, true);\n       break;\n@@ -1055,7 +1055,7 @@ lra_set_insn_recog_data (rtx insn)\n \t  if (nop > 0)\n \t    {\n \t      const char *p =  recog_data.constraints[0];\n-\t      \n+\n \t      for (p =\tconstraints[0]; *p; p++)\n \t\tn += *p == ',';\n \t    }\n@@ -1241,7 +1241,7 @@ lra_update_insn_recog_data (rtx insn)\n   int n;\n   unsigned int uid = INSN_UID (insn);\n   struct lra_static_insn_data *insn_static_data;\n-  \n+\n   check_and_expand_insn_recog_data (uid);\n   if ((data = lra_insn_recog_data[uid]) != NULL\n       && data->icode != INSN_CODE (insn))\n@@ -1310,7 +1310,7 @@ lra_update_insn_recog_data (rtx insn)\n       {\n \tint i;\n \tbool *bp;\n-\t\n+\n \tn = insn_static_data->n_alternatives;\n \tbp = data->alternative_enabled_p;\n \tlra_assert (n >= 0 && bp != NULL);\n@@ -1578,7 +1578,7 @@ add_regs_to_insn_regno_info (lra_insn_recog_data_t data, rtx x, int uid,\n       break;\n     case CLOBBER:\n       /* We treat clobber of non-operand hard registers as early\n-\t clobber (the behavior is expected from asm).  */ \n+\t clobber (the behavior is expected from asm).  */\n       add_regs_to_insn_regno_info (data, XEXP (x, 0), uid, OP_OUT, true);\n       break;\n     case PRE_INC: case PRE_DEC: case POST_INC: case POST_DEC:\n@@ -2026,7 +2026,7 @@ check_rtl (bool final_p)\n \tfor (i = 0; i < id->insn_static_data->n_operands; i++)\n \t  {\n \t    rtx op = *id->operand_loc[i];\n-\t      \n+\n \t    if (MEM_P (op)\n \t\t&& (GET_MODE (op) != BLKmode\n \t\t    || GET_CODE (XEXP (op, 0)) != SCRATCH)\n@@ -2055,7 +2055,7 @@ has_nonexceptional_receiver (void)\n   /* If we're not optimizing, then just err on the safe side.  */\n   if (!optimize)\n     return true;\n-  \n+\n   /* First determine which blocks can reach exit via normal paths.  */\n   tos = worklist = XNEWVEC (basic_block, n_basic_blocks + 1);\n \n@@ -2065,7 +2065,7 @@ has_nonexceptional_receiver (void)\n   /* Place the exit block on our worklist.  */\n   EXIT_BLOCK_PTR->flags |= BB_REACHABLE;\n   *tos++ = EXIT_BLOCK_PTR;\n-  \n+\n   /* Iterate: find everything reachable from what we've already seen.  */\n   while (tos != worklist)\n     {\n@@ -2155,17 +2155,17 @@ update_inc_notes (void)\n /* Set to 1 while in lra.  */\n int lra_in_progress;\n \n-/* Start of reload pseudo regnos before the new spill pass.  */ \n+/* Start of reload pseudo regnos before the new spill pass.  */\n int lra_constraint_new_regno_start;\n \n-/* Inheritance pseudo regnos before the new spill pass.\t */ \n+/* Inheritance pseudo regnos before the new spill pass.\t */\n bitmap_head lra_inheritance_pseudos;\n \n-/* Split regnos before the new spill pass.  */ \n+/* Split regnos before the new spill pass.  */\n bitmap_head lra_split_regs;\n \n /* Reload pseudo regnos before the new assign pass which still can be\n-   spilled after the assinment pass.  */ \n+   spilled after the assinment pass.  */\n bitmap_head lra_optional_reload_pseudos;\n \n /* First UID of insns generated before a new spill pass.  */\n@@ -2307,7 +2307,7 @@ lra (FILE *f)\n \t  else\n \t    {\n \t      /* Do coalescing only for regular algorithms.  */\n-\t      if (! lra_assign () && lra_coalesce ())\t\n+\t      if (! lra_assign () && lra_coalesce ())\n \t\tlive_p = false;\n \t      if (lra_undo_inheritance ())\n \t\tlive_p = false;"}]}