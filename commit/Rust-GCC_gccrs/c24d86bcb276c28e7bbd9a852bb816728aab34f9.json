{"sha": "c24d86bcb276c28e7bbd9a852bb816728aab34f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzI0ZDg2YmNiMjc2YzI4ZTdiYmQ5YTg1MmJiODE2NzI4YWFiMzRmOQ==", "commit": {"author": {"name": "Gary Benson", "email": "gbenson@redhat.com", "date": "2013-10-25T13:56:51Z"}, "committer": {"name": "Gary Benson", "email": "gary@gcc.gnu.org", "date": "2013-10-25T13:56:51Z"}, "message": "cp-demangle.c (struct d_saved_scope): New structure.\n\nlibiberty/\n2013-10-25  Gary Benson  <gbenson@redhat.com>\n\n\t* cp-demangle.c (struct d_saved_scope): New structure.\n\t(struct d_print_info): New fields saved_scopes and\n\tnum_saved_scopes.\n\t(d_print_init): Initialize the above.\n\t(d_print_free): New function.\n\t(cplus_demangle_print_callback): Call the above.\n\t(d_copy_templates): New function.\n\t(d_print_comp): New variables saved_templates and\n\tneed_template_restore.\n\t[DEMANGLE_COMPONENT_REFERENCE,\n\tDEMANGLE_COMPONENT_RVALUE_REFERENCE]: Capture scope the first\n\ttime the component is traversed, and use the captured scope for\n\tsubsequent traversals.\n\t* testsuite/demangle-expected: Add regression test.\n\nFrom-SVN: r204068", "tree": {"sha": "df929d3e5b0a21e524d9bcdfeeb9f821b3b53b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df929d3e5b0a21e524d9bcdfeeb9f821b3b53b76"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c24d86bcb276c28e7bbd9a852bb816728aab34f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24d86bcb276c28e7bbd9a852bb816728aab34f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c24d86bcb276c28e7bbd9a852bb816728aab34f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c24d86bcb276c28e7bbd9a852bb816728aab34f9/comments", "author": null, "committer": null, "parents": [{"sha": "bb362135e2d0fa4bf0290d0b403a3c1fc591da9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb362135e2d0fa4bf0290d0b403a3c1fc591da9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb362135e2d0fa4bf0290d0b403a3c1fc591da9e"}], "stats": {"total": 151, "additions": 149, "deletions": 2}, "files": [{"sha": "19d28771d022c2c2529aa72fbfc4ede3ae39e9c3", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=c24d86bcb276c28e7bbd9a852bb816728aab34f9", "patch": "@@ -1,3 +1,20 @@\n+2013-10-25  Gary Benson  <gbenson@redhat.com>\n+\n+\t* cp-demangle.c (struct d_saved_scope): New structure.\n+\t(struct d_print_info): New fields saved_scopes and\n+\tnum_saved_scopes.\n+\t(d_print_init): Initialize the above.\n+\t(d_print_free): New function.\n+\t(cplus_demangle_print_callback): Call the above.\n+\t(d_copy_templates): New function.\n+\t(d_print_comp): New variables saved_templates and\n+\tneed_template_restore.\n+\t[DEMANGLE_COMPONENT_REFERENCE,\n+\tDEMANGLE_COMPONENT_RVALUE_REFERENCE]: Capture scope the first\n+\ttime the component is traversed, and use the captured scope for\n+\tsubsequent traversals.\n+\t* testsuite/demangle-expected: Add regression test.\n+\n 2013-10-23  Gerald Pfeifer  <gerald@pfeifer.com>\n \n \t* testsuite/test-expandargv.c: Include unistd.h."}, {"sha": "7be98048565930b12dd4e903c985e71077f6261d", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 129, "deletions": 2, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=c24d86bcb276c28e7bbd9a852bb816728aab34f9", "patch": "@@ -275,6 +275,18 @@ struct d_growable_string\n   int allocation_failure;\n };\n \n+/* A demangle component and some scope captured when it was first\n+   traversed.  */\n+\n+struct d_saved_scope\n+{\n+  /* The component whose scope this is.  */\n+  const struct demangle_component *container;\n+  /* The list of templates, if any, that was current when this\n+     scope was captured.  */\n+  struct d_print_template *templates;\n+};\n+\n enum { D_PRINT_BUFFER_LENGTH = 256 };\n struct d_print_info\n {\n@@ -302,6 +314,10 @@ struct d_print_info\n   int pack_index;\n   /* Number of d_print_flush calls so far.  */\n   unsigned long int flush_count;\n+  /* Array of saved scopes for evaluating substitutions.  */\n+  struct d_saved_scope *saved_scopes;\n+  /* Number of saved scopes in the above array.  */\n+  int num_saved_scopes;\n };\n \n #ifdef CP_DEMANGLE_DEBUG\n@@ -3665,6 +3681,30 @@ d_print_init (struct d_print_info *dpi, demangle_callbackref callback,\n   dpi->opaque = opaque;\n \n   dpi->demangle_failure = 0;\n+\n+  dpi->saved_scopes = NULL;\n+  dpi->num_saved_scopes = 0;\n+}\n+\n+/* Free a print information structure.  */\n+\n+static void\n+d_print_free (struct d_print_info *dpi)\n+{\n+  int i;\n+\n+  for (i = 0; i < dpi->num_saved_scopes; i++)\n+    {\n+      struct d_print_template *ts, *tn;\n+\n+      for (ts = dpi->saved_scopes[i].templates; ts != NULL; ts = tn)\n+\t{\n+\t  tn = ts->next;\n+\t  free (ts);\n+\t}\n+    }\n+\n+  free (dpi->saved_scopes);\n }\n \n /* Indicate that an error occurred during printing, and test for error.  */\n@@ -3749,14 +3789,17 @@ cplus_demangle_print_callback (int options,\n                                demangle_callbackref callback, void *opaque)\n {\n   struct d_print_info dpi;\n+  int success;\n \n   d_print_init (&dpi, callback, opaque);\n \n   d_print_comp (&dpi, options, dc);\n \n   d_print_flush (&dpi);\n \n-  return ! d_print_saw_error (&dpi);\n+  success = ! d_print_saw_error (&dpi);\n+  d_print_free (&dpi);\n+  return success;\n }\n \n /* Turn components into a human readable string.  OPTIONS is the\n@@ -3913,6 +3956,36 @@ d_print_subexpr (struct d_print_info *dpi, int options,\n     d_append_char (dpi, ')');\n }\n \n+/* Return a shallow copy of the current list of templates.\n+   On error d_print_error is called and a partial list may\n+   be returned.  Whatever is returned must be freed.  */\n+\n+static struct d_print_template *\n+d_copy_templates (struct d_print_info *dpi)\n+{\n+  struct d_print_template *src, *result, **link = &result;\n+\n+  for (src = dpi->templates; src != NULL; src = src->next)\n+    {\n+      struct d_print_template *dst =\n+\tmalloc (sizeof (struct d_print_template));\n+\n+      if (dst == NULL)\n+\t{\n+\t  d_print_error (dpi);\n+\t  break;\n+\t}\n+\n+      dst->template_decl = src->template_decl;\n+      *link = dst;\n+      link = &dst->next;\n+    }\n+\n+  *link = NULL;\n+\n+  return result;\n+}\n+\n /* Subroutine to handle components.  */\n \n static void\n@@ -3923,6 +3996,13 @@ d_print_comp (struct d_print_info *dpi, int options,\n      without needing to modify *dc.  */\n   const struct demangle_component *mod_inner = NULL;\n \n+  /* Variable used to store the current templates while a previously\n+     captured scope is used.  */\n+  struct d_print_template *saved_templates;\n+\n+  /* Nonzero if templates have been stored in the above variable.  */\n+  int need_template_restore = 0;\n+\n   if (dc == NULL)\n     {\n       d_print_error (dpi);\n@@ -4291,12 +4371,56 @@ d_print_comp (struct d_print_info *dpi, int options,\n \tconst struct demangle_component *sub = d_left (dc);\n \tif (sub->type == DEMANGLE_COMPONENT_TEMPLATE_PARAM)\n \t  {\n-\t    struct demangle_component *a = d_lookup_template_argument (dpi, sub);\n+\t    struct demangle_component *a;\n+\t    struct d_saved_scope *scope = NULL, *scopes;\n+\t    int i;\n+\n+\t    for (i = 0; i < dpi->num_saved_scopes; i++)\n+\t      if (dpi->saved_scopes[i].container == sub)\n+\t\tscope = &dpi->saved_scopes[i];\n+\n+\t    if (scope == NULL)\n+\t      {\n+\t\t/* This is the first time SUB has been traversed.\n+\t\t   We need to capture the current templates so\n+\t\t   they can be restored if SUB is reentered as a\n+\t\t   substitution.  */\n+\t\t++dpi->num_saved_scopes;\n+\t\tscopes = realloc (dpi->saved_scopes,\n+\t\t\t\t  sizeof (struct d_saved_scope)\n+\t\t\t\t  * dpi->num_saved_scopes);\n+\t\tif (scopes == NULL)\n+\t\t  {\n+\t\t    d_print_error (dpi);\n+\t\t    return;\n+\t\t  }\n+\n+\t\tdpi->saved_scopes = scopes;\n+\t\tscope = dpi->saved_scopes + (dpi->num_saved_scopes - 1);\n+\n+\t\tscope->container = sub;\n+\t\tscope->templates = d_copy_templates (dpi);\n+\t\tif (d_print_saw_error (dpi))\n+\t\t  return;\n+\t      }\n+\t    else\n+\t      {\n+\t\t/* This traversal is reentering SUB as a substition.\n+\t\t   Restore the original templates temporarily.  */\n+\t\tsaved_templates = dpi->templates;\n+\t\tdpi->templates = scope->templates;\n+\t\tneed_template_restore = 1;\n+\t      }\n+\n+\t    a = d_lookup_template_argument (dpi, sub);\n \t    if (a && a->type == DEMANGLE_COMPONENT_TEMPLATE_ARGLIST)\n \t      a = d_index_template_argument (a, dpi->pack_index);\n \n \t    if (a == NULL)\n \t      {\n+\t\tif (need_template_restore)\n+\t\t  dpi->templates = saved_templates;\n+\n \t\td_print_error (dpi);\n \t\treturn;\n \t      }\n@@ -4344,6 +4468,9 @@ d_print_comp (struct d_print_info *dpi, int options,\n \n \tdpi->modifiers = dpm.next;\n \n+\tif (need_template_restore)\n+\t  dpi->templates = saved_templates;\n+\n \treturn;\n       }\n "}, {"sha": "ae872078d9152713e04241e11bbdc9263b82a144", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c24d86bcb276c28e7bbd9a852bb816728aab34f9/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=c24d86bcb276c28e7bbd9a852bb816728aab34f9", "patch": "@@ -4294,3 +4294,6 @@ void n<void (A::*)() const &>(void (A::*)() const &)\n --format=gnu-v3\n _ZL1fIiEvv\n void f<int>()\n+--format=gnu-v3\n+_ZSt7forwardIRN1x14refobjiteratorINS0_3refINS0_4mime30multipart_section_processorObjIZ15get_body_parserIZZN14mime_processor21make_section_iteratorERKNS2_INS3_10sectionObjENS0_10ptrrefBaseEEEbENKUlvE_clEvEUlSB_bE_ZZNS6_21make_section_iteratorESB_bENKSC_clEvEUlSB_E0_ENS1_INS2_INS0_20outputrefiteratorObjIiEES8_EEEERKSsSB_OT_OT0_EUlmE_NS3_32make_multipart_default_discarderISP_EEEES8_EEEEEOT_RNSt16remove_referenceISW_E4typeE\n+x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >& std::forward<x::refobjiterator<x::ref<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> >, x::ptrrefBase> >&>(std::remove_reference<x::mime::multipart_section_processorObj<x::refobjiterator<x::ref<x::outputrefiteratorObj<int>, x::ptrrefBase> > get_body_parser<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}>(std::string const&, x::ref<x::mime::sectionObj, x::ptrrefBase> const&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&, mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&)#2}&&)::{lambda(unsigned long)#1}, x::mime::make_multipart_default_discarder<mime_processor::make_section_iterator(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)::{lambda()#1}::operator()() const::{lambda(x::ref<x::mime::sectionObj, x::ptrrefBase> const&, bool)#1}&&> > >::type&)"}]}