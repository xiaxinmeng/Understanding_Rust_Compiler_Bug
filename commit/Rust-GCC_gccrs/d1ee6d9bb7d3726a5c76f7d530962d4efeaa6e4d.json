{"sha": "d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDFlZTZkOWJiN2QzNzI2YTVjNzZmN2Q1MzA5NjJkNGVmZWFhNmU0ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-12-20T17:01:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-12-20T17:01:26Z"}, "message": "cfgcleanup.c (flow_find_cross_jump): Avoid incrementing of ninsns if one of block does not contain jump.\n\n\t* cfgcleanup.c (flow_find_cross_jump): Avoid incrementing of ninsns\n\tif one of block does not contain jump.\n\t(outgoing_edge_math): Revert last path; require edges to be noncomplex\n\tnonfake to match single exit edge; require conditional jumps to not\n\thave side effect.\n\nFrom-SVN: r48203", "tree": {"sha": "ffbeb41028154325e873af71d0e57a9a277fe352", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ffbeb41028154325e873af71d0e57a9a277fe352"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d/comments", "author": null, "committer": null, "parents": [{"sha": "37bef19770233ab36b2a61ce3c33febf83f17734", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/37bef19770233ab36b2a61ce3c33febf83f17734", "html_url": "https://github.com/Rust-GCC/gccrs/commit/37bef19770233ab36b2a61ce3c33febf83f17734"}], "stats": {"total": 28, "additions": 20, "deletions": 8}, "files": [{"sha": "7ed306ee27ea63031667daafd0e5fc3053415b2a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "patch": "@@ -1,3 +1,11 @@\n+Thu Dec 20 16:58:46 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cfgcleanup.c (flow_find_cross_jump): Avoid incrementing of ninsns\n+\tif one of block does not contain jump.\n+\t(outgoing_edge_math): Revert last path; require edges to be noncomplex\n+\tnonfake to match single exit edge; require conditional jumps to not\n+\thave side effect.\n+\n 2001-12-20  Turly O'Connor  <turly@apple.com>\n \n \t* tm.texi (ASM_OUTPUT_OPERAND): Change documentation references to"}, {"sha": "abb0217711c624de913782e9d2887051291cf21b", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=d1ee6d9bb7d3726a5c76f7d530962d4efeaa6e4d", "patch": "@@ -855,16 +855,16 @@ flow_find_cross_jump (mode, bb1, bb2, f1, f2)\n       || (returnjump_p (i1) && !side_effects_p (PATTERN (i1))))\n     {\n       last1 = i1;\n-      /* Count everything except for unconditional jump as insn.  */\n-      if (!simplejump_p (i1) && !returnjump_p (i1))\n-\tninsns++;\n       i1 = PREV_INSN (i1);\n     }\n   i2 = bb2->end;\n   if (onlyjump_p (i2)\n       || (returnjump_p (i2) && !side_effects_p (PATTERN (i2))))\n     {\n       last2 = i2;\n+      /* Count everything except for unconditional jump as insn.  */\n+      if (!simplejump_p (i2) && !returnjump_p (i2) && last1)\n+\tninsns++;\n       i2 = PREV_INSN (i2);\n     }\n \n@@ -958,19 +958,22 @@ outgoing_edges_match (mode, bb1, bb2)\n \n   /* If BB1 has only one successor, we may be looking at either an\n      unconditional jump, or a fake edge to exit.  */\n-  if (bb1->succ && !bb1->succ->succ_next)\n+  if (bb1->succ && !bb1->succ->succ_next\n+      && !(bb1->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n     {\n-      if (! bb2->succ || bb2->succ->succ_next)\n+      if (! bb2->succ || bb2->succ->succ_next\n+\t  || (bb2->succ->flags & (EDGE_COMPLEX | EDGE_FAKE)))\n \treturn false;\n-      return insns_match_p (mode, bb1->end, bb2->end);\n+      return true;\n     }\n \n   /* Match conditional jumps - this may get tricky when fallthru and branch\n      edges are crossed.  */\n   if (bb1->succ\n       && bb1->succ->succ_next\n       && !bb1->succ->succ_next->succ_next\n-      && any_condjump_p (bb1->end))\n+      && any_condjump_p (bb1->end)\n+      && onlyjump_p (bb1->end))\n     {\n       edge b1, f1, b2, f2;\n       bool reverse, match;\n@@ -980,7 +983,8 @@ outgoing_edges_match (mode, bb1, bb2)\n       if (!bb2->succ\n           || !bb2->succ->succ_next\n \t  || bb1->succ->succ_next->succ_next\n-\t  || !any_condjump_p (bb2->end))\n+\t  || !any_condjump_p (bb2->end)\n+\t  || !onlyjump_p (bb1->end))\n \treturn false;\n \n       b1 = BRANCH_EDGE (bb1);"}]}