{"sha": "880dabb586a7da7a9198319daef82bf87df7422c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwZGFiYjU4NmE3ZGE3YTkxOTgzMTlkYWVmODJiZjg3ZGY3NDIyYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T13:00:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-10-26T13:00:05Z"}, "message": "[multiple changes]\n\n2010-10-26  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.ads: Comment fix.\n\t* sem_cat.adb: Treat categorization errors as warnings in GNAT Mode.\n\t* switch-c.adb: GNAT Mode does not set\n\tTreat_Categorization_Errors_As_Warnings.\n\n2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Improve warning when an\n\toperator renames another one with a different name.\n\n2010-10-26  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch4.adb, exp_pakd.adb: Minor reformatting.\n\nFrom-SVN: r165956", "tree": {"sha": "a00f59d391906e9e2674b5607e6baf48f833deec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a00f59d391906e9e2674b5607e6baf48f833deec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880dabb586a7da7a9198319daef82bf87df7422c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880dabb586a7da7a9198319daef82bf87df7422c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880dabb586a7da7a9198319daef82bf87df7422c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880dabb586a7da7a9198319daef82bf87df7422c/comments", "author": null, "committer": null, "parents": [{"sha": "392314047357798f0dffb3e5582f890489a3204f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/392314047357798f0dffb3e5582f890489a3204f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/392314047357798f0dffb3e5582f890489a3204f"}], "stats": {"total": 240, "additions": 125, "deletions": 115}, "files": [{"sha": "896a17ca14af6574d042237e8c3aee05b6946d63", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -1,3 +1,19 @@\n+2010-10-26  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.ads: Comment fix.\n+\t* sem_cat.adb: Treat categorization errors as warnings in GNAT Mode.\n+\t* switch-c.adb: GNAT Mode does not set\n+\tTreat_Categorization_Errors_As_Warnings.\n+\n+2010-10-26  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch8.adb (Analyze_Subprogram_Renaming): Improve warning when an\n+\toperator renames another one with a different name.\n+\n+2010-10-26  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch4.adb, exp_pakd.adb: Minor reformatting.\n+\n 2010-10-26  Bob Duff  <duff@adacore.com>\n \n \t* namet.adb: Improve hash function."}, {"sha": "5f4cb6a268b0c910bba09a1aee141a73277eacb6", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -6987,8 +6987,8 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n-      --  For the VMS \"not\" on signed integer types, use conversion to and\n-      --  from a predefined modular type.\n+      --  For the VMS \"not\" on signed integer types, use conversion to and from\n+      --  a predefined modular type.\n \n       if Is_VMS_Operator (Entity (N)) then\n          declare"}, {"sha": "4d3ea06881942ed9c17182ef51914f6763a2dbea", "filename": "gcc/ada/exp_pakd.adb", "status": "modified", "additions": 89, "deletions": 97, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fexp_pakd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fexp_pakd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_pakd.adb?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -67,23 +67,22 @@ package body Exp_Pakd is\n    --    For big-endian machines, element zero is at the left hand end\n    --    (high order end) of a bit field.\n \n-   --  The shifts that are used to right justify a field therefore differ\n-   --  in the two cases. For the little-endian case, we can simply use the\n-   --  bit number (i.e. the element number * element size) as the count for\n-   --  a right shift. For the big-endian case, we have to subtract the shift\n-   --  count from an appropriate constant to use in the right shift. We use\n-   --  rotates instead of shifts (which is necessary in the store case to\n-   --  preserve other fields), and we expect that the backend will be able\n-   --  to change the right rotate into a left rotate, avoiding the subtract,\n-   --  if the architecture provides such an instruction.\n+   --  The shifts that are used to right justify a field therefore differ in\n+   --  the two cases. For the little-endian case, we can simply use the bit\n+   --  number (i.e. the element number * element size) as the count for a right\n+   --  shift. For the big-endian case, we have to subtract the shift count from\n+   --  an appropriate constant to use in the right shift. We use rotates\n+   --  instead of shifts (which is necessary in the store case to preserve\n+   --  other fields), and we expect that the backend will be able to change the\n+   --  right rotate into a left rotate, avoiding the subtract, if the machine\n+   --  architecture provides such an instruction.\n \n    ----------------------------------------------\n    -- Entity Tables for Packed Access Routines --\n    ----------------------------------------------\n \n-   --  For the cases of component size = 3,5-7,9-15,17-31,33-63 we call\n-   --  library routines. This table is used to obtain the entity for the\n-   --  proper routine.\n+   --  For the cases of component size = 3,5-7,9-15,17-31,33-63 we call library\n+   --  routines. This table provides the entity for the proper routine.\n \n    type E_Array is array (Int range 01 .. 63) of RE_Id;\n \n@@ -157,10 +156,10 @@ package body Exp_Pakd is\n       62 => RE_Bits_62,\n       63 => RE_Bits_63);\n \n-   --  Array of Get routine entities. These are used to obtain an element\n-   --  from a packed array. The N'th entry is used to obtain elements from\n-   --  a packed array whose component size is N. RE_Null is used as a null\n-   --  entry, for the cases where a library routine is not used.\n+   --  Array of Get routine entities. These are used to obtain an element from\n+   --  a packed array. The N'th entry is used to obtain elements from a packed\n+   --  array whose component size is N. RE_Null is used as a null entry, for\n+   --  the cases where a library routine is not used.\n \n    Get_Id : constant E_Array :=\n      (01 => RE_Null,\n@@ -228,9 +227,9 @@ package body Exp_Pakd is\n       63 => RE_Get_63);\n \n    --  Array of Get routine entities to be used in the case where the packed\n-   --  array is itself a component of a packed structure, and therefore may\n-   --  not be fully aligned. This only affects the even sizes, since for the\n-   --  odd sizes, we do not get any fixed alignment in any case.\n+   --  array is itself a component of a packed structure, and therefore may not\n+   --  be fully aligned. This only affects the even sizes, since for the odd\n+   --  sizes, we do not get any fixed alignment in any case.\n \n    GetU_Id : constant E_Array :=\n      (01 => RE_Null,\n@@ -297,10 +296,10 @@ package body Exp_Pakd is\n       62 => RE_GetU_62,\n       63 => RE_Get_63);\n \n-   --  Array of Set routine entities. These are used to assign an element\n-   --  of a packed array. The N'th entry is used to assign elements for\n-   --  a packed array whose component size is N. RE_Null is used as a null\n-   --  entry, for the cases where a library routine is not used.\n+   --  Array of Set routine entities. These are used to assign an element of a\n+   --  packed array. The N'th entry is used to assign elements for a packed\n+   --  array whose component size is N. RE_Null is used as a null entry, for\n+   --  the cases where a library routine is not used.\n \n    Set_Id : constant E_Array :=\n      (01 => RE_Null,\n@@ -368,9 +367,9 @@ package body Exp_Pakd is\n       63 => RE_Set_63);\n \n    --  Array of Set routine entities to be used in the case where the packed\n-   --  array is itself a component of a packed structure, and therefore may\n-   --  not be fully aligned. This only affects the even sizes, since for the\n-   --  odd sizes, we do not get any fixed alignment in any case.\n+   --  array is itself a component of a packed structure, and therefore may not\n+   --  be fully aligned. This only affects the even sizes, since for the odd\n+   --  sizes, we do not get any fixed alignment in any case.\n \n    SetU_Id : constant E_Array :=\n      (01 => RE_Null,\n@@ -445,10 +444,10 @@ package body Exp_Pakd is\n      (Atyp   : Entity_Id;\n       N      : Node_Id;\n       Subscr : out Node_Id);\n-   --  Given a constrained array type Atyp, and an indexed component node\n-   --  N referencing an array object of this type, build an expression of\n-   --  type Standard.Integer representing the zero-based linear subscript\n-   --  value. This expression includes any required range checks.\n+   --  Given a constrained array type Atyp, and an indexed component node N\n+   --  referencing an array object of this type, build an expression of type\n+   --  Standard.Integer representing the zero-based linear subscript value.\n+   --  This expression includes any required range checks.\n \n    procedure Convert_To_PAT_Type (Aexp : Node_Id);\n    --  Given an expression of a packed array type, builds a corresponding\n@@ -1412,9 +1411,9 @@ package body Exp_Pakd is\n \n          --  The statement to be generated is:\n \n-         --    Obj := atyp!((Obj and Mask1) or (shift_left (rhs, shift)))\n+         --    Obj := atyp!((Obj and Mask1) or (shift_left (rhs, Shift)))\n \n-         --      where mask1 is obtained by shifting Cmask left Shift bits\n+         --      where Mask1 is obtained by shifting Cmask left Shift bits\n          --      and then complementing the result.\n \n          --      the \"and Mask1\" is omitted if rhs is constant and all 1 bits\n@@ -1447,21 +1446,21 @@ package body Exp_Pakd is\n             Rhs_Val_Known := False;\n          end if;\n \n-         --  Some special checks for the case where the right hand value\n-         --  is known at compile time. Basically we have to take care of\n-         --  the implicit conversion to the subtype of the component object.\n+         --  Some special checks for the case where the right hand value is\n+         --  known at compile time. Basically we have to take care of the\n+         --  implicit conversion to the subtype of the component object.\n \n          if Rhs_Val_Known then\n \n-            --  If we have a biased component type then we must manually do\n-            --  the biasing, since we are taking responsibility in this case\n-            --  for constructing the exact bit pattern to be used.\n+            --  If we have a biased component type then we must manually do the\n+            --  biasing, since we are taking responsibility in this case for\n+            --  constructing the exact bit pattern to be used.\n \n             if Has_Biased_Representation (Ctyp) then\n                Rhs_Val := Rhs_Val - Expr_Rep_Value (Type_Low_Bound (Ctyp));\n             end if;\n \n-            --  For a negative value, we manually convert the twos complement\n+            --  For a negative value, we manually convert the two's complement\n             --  value to a corresponding unsigned value, so that the proper\n             --  field width is maintained. If we did not do this, we would\n             --  get too many leading sign bits later on.\n@@ -1544,8 +1543,8 @@ package body Exp_Pakd is\n                      Rhs := Unchecked_Convert_To (RTE (Bits_Id (Csiz)), Rhs);\n                   end if;\n \n-                  --  Set Etype, since it can be referenced before the\n-                  --  node is completely analyzed.\n+                  --  Set Etype, since it can be referenced before the node is\n+                  --  completely analyzed.\n \n                   Set_Etype (Rhs, Etyp);\n \n@@ -1999,8 +1998,7 @@ package body Exp_Pakd is\n          Set_Parent (Arg, Parent (N));\n          Analyze_And_Resolve (Arg);\n \n-         Rewrite (N,\n-           RJ_Unchecked_Convert_To (Ctyp, Arg));\n+         Rewrite (N, RJ_Unchecked_Convert_To (Ctyp, Arg));\n \n       --  All other component sizes for non-modular case\n \n@@ -2177,14 +2175,14 @@ package body Exp_Pakd is\n       Convert_To_PAT_Type (Opnd);\n       PAT := Etype (Opnd);\n \n-      --  For the case where the packed array type is a modular type,\n-      --  not A expands simply into:\n+      --  For the case where the packed array type is a modular type, \"not A\"\n+      --  expands simply into:\n \n-      --     rtyp!(PAT!(A) xor mask)\n+      --     Rtyp!(PAT!(A) xor Mask)\n \n-      --  where PAT is the packed array type, and mask is a mask of all\n-      --  one bits of length equal to the size of this packed type and\n-      --  rtyp is the actual subtype of the operand\n+      --  where PAT is the packed array type, Mask is a mask of all 1 bits of\n+      --  length equal to the size of this packed type, and Rtyp is the actual\n+      --  actual subtype of the operand.\n \n       Lit := Make_Integer_Literal (Loc, 2 ** RM_Size (PAT) - 1);\n       Set_Print_In_Hex (Lit);\n@@ -2202,28 +2200,26 @@ package body Exp_Pakd is\n \n       --    System.Bit_Ops.Bit_Not\n       --     (Opnd'Address,\n-      --      Typ'Length * Typ'Component_Size;\n+      --      Typ'Length * Typ'Component_Size,\n       --      Result'Address);\n \n-      --  where Opnd is the Packed_Bytes{1,2,4} operand and the second\n-      --  argument is the length of the operand in bits. Then we replace\n-      --  the expression by a reference to Result.\n+      --  where Opnd is the Packed_Bytes{1,2,4} operand and the second argument\n+      --  is the length of the operand in bits. We then replace the expression\n+      --  with a reference to Result.\n \n       else\n          declare\n             Result_Ent : constant Entity_Id := Make_Temporary (Loc, 'T');\n \n          begin\n             Insert_Actions (N, New_List (\n-\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Result_Ent,\n-                Object_Definition => New_Occurrence_Of (Rtyp, Loc)),\n+                Object_Definition   => New_Occurrence_Of (Rtyp, Loc)),\n \n               Make_Procedure_Call_Statement (Loc,\n                 Name => New_Occurrence_Of (RTE (RE_Bit_Not), Loc),\n                   Parameter_Associations => New_List (\n-\n                     Make_Byte_Aligned_Attribute_Reference (Loc,\n                       Prefix         => Opnd,\n                       Attribute_Name => Name_Address),\n@@ -2240,16 +2236,14 @@ package body Exp_Pakd is\n                         Make_Integer_Literal (Loc, Component_Size (Rtyp))),\n \n                     Make_Byte_Aligned_Attribute_Reference (Loc,\n-                      Prefix => New_Occurrence_Of (Result_Ent, Loc),\n+                      Prefix         => New_Occurrence_Of (Result_Ent, Loc),\n                       Attribute_Name => Name_Address)))));\n \n-            Rewrite (N,\n-              New_Occurrence_Of (Result_Ent, Loc));\n+            Rewrite (N, New_Occurrence_Of (Result_Ent, Loc));\n          end;\n       end if;\n \n       Analyze_And_Resolve (N, Typ, Suppress => All_Checks);\n-\n    end Expand_Packed_Not;\n \n    -----------------------------\n@@ -2519,27 +2513,27 @@ package body Exp_Pakd is\n       Source_Siz := UI_To_Int (RM_Size (Source_Typ));\n       Target_Siz := UI_To_Int (RM_Size (Target_Typ));\n \n-      --  First step, if the source type is not a discrete type, then we\n-      --  first convert to a modular type of the source length, since\n-      --  otherwise, on a big-endian machine, we get left-justification.\n-      --  We do it for little-endian machines as well, because there might\n-      --  be junk bits that are not cleared if the type is not numeric.\n+      --  First step, if the source type is not a discrete type, then we first\n+      --  convert to a modular type of the source length, since otherwise, on\n+      --  a big-endian machine, we get left-justification. We do it for little-\n+      --  endian machines as well, because there might be junk bits that are\n+      --  not cleared if the type is not numeric.\n \n       if Source_Siz /= Target_Siz\n-        and then  not Is_Discrete_Type (Source_Typ)\n+        and then not Is_Discrete_Type (Source_Typ)\n       then\n          Src := Unchecked_Convert_To (RTE (Bits_Id (Source_Siz)), Src);\n       end if;\n \n-      --  In the big endian case, if the lengths of the two types differ,\n-      --  then we must worry about possible left justification in the\n-      --  conversion, and avoiding that is what this is all about.\n+      --  In the big endian case, if the lengths of the two types differ, then\n+      --  we must worry about possible left justification in the conversion,\n+      --  and avoiding that is what this is all about.\n \n       if Bytes_Big_Endian and then Source_Siz /= Target_Siz then\n \n          --  Next step. If the target is not a discrete type, then we first\n-         --  convert to a modular type of the target length, since\n-         --  otherwise, on a big-endian machine, we get left-justification.\n+         --  convert to a modular type of the target length, since otherwise,\n+         --  on a big-endian machine, we get left-justification.\n \n          if not Is_Discrete_Type (Target_Typ) then\n             Src := Unchecked_Convert_To (RTE (Bits_Id (Target_Siz)), Src);\n@@ -2555,16 +2549,16 @@ package body Exp_Pakd is\n    -- Setup_Enumeration_Packed_Array_Reference --\n    ----------------------------------------------\n \n-   --  All we have to do here is to find the subscripts that correspond\n-   --  to the index positions that have non-standard enumeration types\n-   --  and insert a Pos attribute to get the proper subscript value.\n+   --  All we have to do here is to find the subscripts that correspond to the\n+   --  index positions that have non-standard enumeration types and insert a\n+   --  Pos attribute to get the proper subscript value.\n \n-   --  Finally the prefix must be uncheck converted to the corresponding\n-   --  packed array type.\n+   --  Finally the prefix must be uncheck-converted to the corresponding packed\n+   --  array type.\n \n-   --  Note that the component type is unchanged, so we do not need to\n-   --  fiddle with the types (Gigi always automatically takes the packed\n-   --  array type if it is set, as it will be in this case).\n+   --  Note that the component type is unchanged, so we do not need to fiddle\n+   --  with the types (Gigi always automatically takes the packed array type if\n+   --  it is set, as it will be in this case).\n \n    procedure Setup_Enumeration_Packed_Array_Reference (N : Node_Id) is\n       Pfx   : constant Node_Id   := Prefix (N);\n@@ -2573,9 +2567,9 @@ package body Exp_Pakd is\n       Expr  : Node_Id;\n \n    begin\n-      --  If the array is unconstrained, then we replace the array\n-      --  reference with its actual subtype. This actual subtype will\n-      --  have a packed array type with appropriate bounds.\n+      --  If the array is unconstrained, then we replace the array reference\n+      --  with its actual subtype. This actual subtype will have a packed array\n+      --  type with appropriate bounds.\n \n       if not Is_Constrained (Packed_Array_Type (Etype (Pfx))) then\n          Convert_To_Actual_Subtype (Pfx);\n@@ -2610,7 +2604,6 @@ package body Exp_Pakd is\n           Expressions => Exprs));\n \n       Analyze_And_Resolve (N, Typ);\n-\n    end Setup_Enumeration_Packed_Array_Reference;\n \n    -----------------------------------------\n@@ -2657,8 +2650,8 @@ package body Exp_Pakd is\n \n       Compute_Linear_Subscript (Atyp, N, Shift);\n \n-      --  If the component size is not 1, then the subscript must be\n-      --  multiplied by the component size to get the shift count.\n+      --  If the component size is not 1, then the subscript must be multiplied\n+      --  by the component size to get the shift count.\n \n       if Csiz /= 1 then\n          Shift :=\n@@ -2667,8 +2660,8 @@ package body Exp_Pakd is\n              Right_Opnd => Shift);\n       end if;\n \n-      --  If we have the array case, then this shift count must be broken\n-      --  down into a byte subscript, and a shift within the byte.\n+      --  If we have the array case, then this shift count must be broken down\n+      --  into a byte subscript, and a shift within the byte.\n \n       if Is_Array_Type (PAT) then\n \n@@ -2704,9 +2697,9 @@ package body Exp_Pakd is\n             Shift := New_Shift;\n          end;\n \n-      --  For the modular integer case, the object to be manipulated is\n-      --  the entire array, so Obj is unchanged. Note that we will reset\n-      --  its type to PAT before returning to the caller.\n+      --  For the modular integer case, the object to be manipulated is the\n+      --  entire array, so Obj is unchanged. Note that we will reset its type\n+      --  to PAT before returning to the caller.\n \n       else\n          null;\n@@ -2722,14 +2715,13 @@ package body Exp_Pakd is\n \n       --  Here we have the case of 2-bit fields\n \n-      --  For the little-endian case, we already have the proper shift\n-      --  count set, e.g. for element 2, the shift count is 2*2 = 4.\n+      --  For the little-endian case, we already have the proper shift count\n+      --  set, e.g. for element 2, the shift count is 2*2 = 4.\n \n-      --  For the big endian case, we have to adjust the shift count,\n-      --  computing it as (N - F) - shift, where N is the number of bits\n-      --  in an element of the array used to implement the packed array,\n-      --  F is the number of bits in a source level array element, and\n-      --  shift is the count so far computed.\n+      --  For the big endian case, we have to adjust the shift count, computing\n+      --  it as (N - F) - Shift, where N is the number of bits in an element of\n+      --  the array used to implement the packed array, F is the number of bits\n+      --  in a source array element, and Shift is the count so far computed.\n \n       if Bytes_Big_Endian then\n          Shift :="}, {"sha": "b31a66e9e69d47c0402346238ad7a00bd86d673e", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -1233,7 +1233,7 @@ package Opt is\n    Treat_Categorization_Errors_As_Warnings : Boolean := False;\n    --  Normally categorization errors are true illegalities. If this switch\n    --  is set, then such errors result in warning messages rather than error\n-   --  messages. Set True by -gnatg or -gnateP (P for Pure/Preelaborate).\n+   --  messages. Set True by -gnateP (P for Pure/Preelaborate).\n \n    Treat_Restrictions_As_Warnings : Boolean := False;\n    --  GNAT"}, {"sha": "9311beb99db86eae8aceedb51a14eb32fbc0d998", "filename": "gcc/ada/sem_cat.adb", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fsem_cat.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fsem_cat.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_cat.adb?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -226,10 +226,19 @@ package body Sem_Cat is\n \n       if Err then\n \n-         --  These messages are warnings in GNAT mode or if the -gnateC switch\n+         --  These messages are warnings in GNAT mode or if the -gnateP switch\n          --  was set. Otherwise these are real errors for real illegalities.\n \n-         Error_Msg_Warn := Treat_Categorization_Errors_As_Warnings;\n+         --  The reason we suppress these errors in GNAT mode is that the run-\n+         --  time has several instances of violations of the categorization\n+         --  errors (e.g. Pure units withing Preelaborate units. All these\n+         --  violations are harmless in the cases where we intend them, and\n+         --  we suppress the warnings with Warnings (Off). In cases where we\n+         --  do not intend the violation, warnings are errors in GNAT mode\n+         --  anyway, so we will still get an error.\n+\n+         Error_Msg_Warn :=\n+           Treat_Categorization_Errors_As_Warnings or GNAT_Mode;\n \n          --  Don't give error if main unit is not an internal unit, and the\n          --  unit generating the message is an internal unit. This is the"}, {"sha": "2a23afa3d2eaf37107611f92f69209d1190842c7", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -2480,16 +2480,19 @@ package body Sem_Ch8 is\n \n       --  A useful warning, suggested by Ada Bug Finder (Ada-Europe 2005)\n       --  is to warn if an operator is being renamed as a different operator.\n+      --  If the operator is predefined, examine the kind of the entity, not\n+      --  the abbreviated declaration in Standard.\n \n       if Comes_From_Source (N)\n         and then Present (Old_S)\n-        and then Nkind (Old_S) = N_Defining_Operator_Symbol\n+        and then\n+          (Nkind (Old_S) = N_Defining_Operator_Symbol\n+            or else Ekind (Old_S) = E_Operator)\n         and then Nkind (New_S) = N_Defining_Operator_Symbol\n         and then Chars (Old_S) /= Chars (New_S)\n       then\n          Error_Msg_NE\n-           (\"?& is being renamed as a different operator\",\n-             New_S, Old_S);\n+           (\"?& is being renamed as a different operator\", N, Old_S);\n       end if;\n \n       --  Check for renaming of obsolescent subprogram"}, {"sha": "a4423dc3143083fe6b46493c1052cfe1b53a8382", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880dabb586a7da7a9198319daef82bf87df7422c/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=880dabb586a7da7a9198319daef82bf87df7422c", "patch": "@@ -567,16 +567,6 @@ package body Switch.C is\n                Set_GNAT_Mode_Warnings;\n                Set_GNAT_Style_Check_Options;\n \n-               --  Suppress categorization errors. The run-time has several\n-               --  instances of violations of the categorization errors (e.g.\n-               --  Pure units withing Preelaborate units. These violations are\n-               --  harmless in the cases where we intend them, and we suppress\n-               --  the warnings with Warnings (Off). In cases where we do not\n-               --  intend the violation, warnings are errors in -gnatg mode\n-               --  anyway, so we will still get an error.\n-\n-               Treat_Categorization_Errors_As_Warnings := True;\n-\n             --  Processing for G switch\n \n             when 'G' =>"}]}