{"sha": "cad055a4ba2356bb1cde958dfe41de705e39bfea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FkMDU1YTRiYTIzNTZiYjFjZGU5NThkZmU0MWRlNzA1ZTM5YmZlYQ==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2013-09-17T08:15:03Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2013-09-17T08:15:03Z"}, "message": "msp430-protos.h: Add prototypes for new functions.\n\n\t* config/msp430/msp430-protos.h: Add prototypes for new functions.\n\t* config/msp430/msp430.c (msp430_preserve_reg_p): Add support for\n\tinterrupt handlers.\n\t(is_attr_func): New function.\n\t(msp430_is_interrupt_func): New function.\n\t(is_naked_func): New function.\n\t(is_reentrant_func): New function.\n\t(is_critical_func): New function.\n\t(msp430_start_function): Add annotations for function attributes.\n\t(msp430_attr): New function.\n\t(msp430_attribute_table): New.\n\t(msp430_function_section): New function.\n\t(TARGET_ASM_FUNCTION_SECTION): Define.\n\t(msp430_builtin): New enum.\n\t(msp430_init_builtins): New function.\n\t(msp430_builtin_devl): New function.\n\t(msp430_expand_builtin): New function.\n\t(TARGET_INIT_BUILTINS): Define.\n\t(TARGET_EXPAND_BUILTINS): Define.\n\t(TARGET_BUILTIN_DECL): Define.\n\t(msp430_expand_prologue): Add support for naked, interrupt,\n\tcritical and reentrant functions.\n\t(msp430_expand_epilogue): Likewise.\n\t(msp430_print_operand): Handle 'O' character.\n\t* config/msp430/msp430.h (TARGET_CPU_CPP_BUILTINS): Define\n\tNO_TRAMPOLINES.\n\t* config/msp430/msp430.md (unspec): Add UNS_DINT, UNS_EINT,\n\tUNS_PUSH_INTR, UNS_POP_INTR, UNS_BIC_SR, UNS_BIS_SR.\n\t(pushm): Use a 'n' rather than an 'i' constraint.\n\t(msp_return): Add generation of the interrupt return instruction.\n\t(disable_interrupts): New pattern.\n\t(enable_interrupts): New pattern.\n\t(push_intr_state): New pattern.\n\t(pop_intr_state): New pattern.\n\t(bic_SR): New pattern.\n\t(bis_SR): New pattern.\n\t* doc/extend.texi: Document MSP430 function attributes and builtin\n\tfunctions.\n\nFrom-SVN: r202645", "tree": {"sha": "3bb014e5f02dba3bcadfe141ef501c948e46ba81", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bb014e5f02dba3bcadfe141ef501c948e46ba81"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cad055a4ba2356bb1cde958dfe41de705e39bfea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad055a4ba2356bb1cde958dfe41de705e39bfea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cad055a4ba2356bb1cde958dfe41de705e39bfea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cad055a4ba2356bb1cde958dfe41de705e39bfea/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "deb6c11a73e8d651d367950b5ea35ee5f60c3a85", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/deb6c11a73e8d651d367950b5ea35ee5f60c3a85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/deb6c11a73e8d651d367950b5ea35ee5f60c3a85"}], "stats": {"total": 482, "additions": 459, "deletions": 23}, "files": [{"sha": "e63347b2497792b0e9670f3fcb21f9135dae1a09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -1,3 +1,44 @@\n+2013-09-17  Nick Clifton  <nickc@redhat.com>\n+\n+\t* config/msp430/msp430-protos.h: Add prototypes for new functions.\n+\t* config/msp430/msp430.c (msp430_preserve_reg_p): Add support for\n+\tinterrupt handlers.\n+\t(is_attr_func): New function.\n+\t(msp430_is_interrupt_func): New function.\n+\t(is_naked_func): New function.\n+\t(is_reentrant_func): New function.\n+\t(is_critical_func): New function.\n+\t(msp430_start_function): Add annotations for function attributes.\n+\t(msp430_attr): New function.\n+\t(msp430_attribute_table): New.\n+\t(msp430_function_section): New function.\n+\t(TARGET_ASM_FUNCTION_SECTION): Define.\n+\t(msp430_builtin): New enum.\n+\t(msp430_init_builtins): New function.\n+\t(msp430_builtin_devl): New function.\n+\t(msp430_expand_builtin): New function.\n+\t(TARGET_INIT_BUILTINS): Define.\n+\t(TARGET_EXPAND_BUILTINS): Define.\n+\t(TARGET_BUILTIN_DECL): Define.\n+\t(msp430_expand_prologue): Add support for naked, interrupt,\n+\tcritical and reentrant functions.\n+\t(msp430_expand_epilogue): Likewise.\n+\t(msp430_print_operand): Handle 'O' character.\n+\t* config/msp430/msp430.h (TARGET_CPU_CPP_BUILTINS): Define\n+\tNO_TRAMPOLINES.\n+\t* config/msp430/msp430.md (unspec): Add UNS_DINT, UNS_EINT,\n+\tUNS_PUSH_INTR, UNS_POP_INTR, UNS_BIC_SR, UNS_BIS_SR.\n+\t(pushm): Use a 'n' rather than an 'i' constraint.\n+\t(msp_return): Add generation of the interrupt return instruction.\n+\t(disable_interrupts): New pattern.\n+\t(enable_interrupts): New pattern.\n+\t(push_intr_state): New pattern.\n+\t(pop_intr_state): New pattern.\n+\t(bic_SR): New pattern.\n+\t(bis_SR): New pattern.\n+\t* doc/extend.texi: Document MSP430 function attributes and builtin\n+\tfunctions.\n+\n 2013-09-17  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/58432"}, {"sha": "ea53481bfdb9759f3e3c7c7f0416568a1c518f16", "filename": "gcc/config/msp430/constraints.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fconstraints.md?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -70,5 +70,3 @@\n \t\t  (match_test (\"IN_RANGE (INTVAL (XEXP (XEXP (op, 0), 1)), -1 << 15, (1 << 15)-1)\"))))\n \t(match_code \"reg\" \"0\")\n \t)))\n-  \n-"}, {"sha": "f116855ecae2f0746dfb6c5274427e0ad2c875dd", "filename": "gcc/config/msp430/msp430-protos.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430-protos.h?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -21,6 +21,7 @@\n #ifndef GCC_MSP430_PROTOS_H\n #define GCC_MSP430_PROTOS_H\n \n+rtx\tmsp430_eh_return_stackadj_rtx (void);\n void\tmsp430_expand_eh_return (rtx);\n void\tmsp430_expand_epilogue (int);\n void\tmsp430_expand_helper (rtx *operands, const char *, bool);\n@@ -32,13 +33,14 @@ int\tmsp430_hard_regno_nregs (int, enum machine_mode);\n rtx\tmsp430_incoming_return_addr_rtx (void);\n void\tmsp430_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree, int);\n int\tmsp430_initial_elimination_offset (int, int);\n+bool    msp430_is_interrupt_func (void);\n const char * msp430x_logical_shift_right (rtx);\n+bool\tmsp430_modes_tieable_p (enum machine_mode, enum machine_mode);\n void\tmsp430_output_labelref (FILE *, const char *);\n void\tmsp430_register_pragmas (void);\n rtx\tmsp430_return_addr_rtx (int);\n void\tmsp430_split_movsi (rtx *);\n rtx\tmsp430_subreg (enum machine_mode, rtx, enum machine_mode, int);\n-rtx\tmsp430_eh_return_stackadj_rtx (void);\n-bool\tmsp430_modes_tieable_p (enum machine_mode, enum machine_mode);\n+void    msp430_start_function (FILE *, const char *, tree);\n \n #endif /* GCC_MSP430_PROTOS_H */"}, {"sha": "9384d32457a4608f8698a3997c16ad2a01077b4b", "filename": "gcc/config/msp430/msp430.c", "status": "modified", "additions": 308, "deletions": 10, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.c?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -120,7 +120,7 @@ msp430_option_override (void)\n     msp430x = true;\n \n   if (TARGET_LARGE && !msp430x)\n-    error (\"-mlarge requires a 430X-compatible -mcpu=\");\n+    error (\"-mlarge requires a 430X-compatible -mmcu=\");\n \n   if (flag_exceptions || flag_non_call_exceptions\n       || flag_unwind_tables || flag_asynchronous_unwind_tables)\n@@ -208,10 +208,9 @@ msp430_can_eliminate (const int from_reg ATTRIBUTE_UNUSED,\n \n /* Implements INITIAL_ELIMINATION_OFFSET.  */\n int\n-msp430_initial_elimination_offset (int from ATTRIBUTE_UNUSED,\n-\t\t\t\t   int to ATTRIBUTE_UNUSED)\n+msp430_initial_elimination_offset (int from, int to)\n {\n-  int rv = 0; /* as if arg to arg */\n+  int rv = 0; /* As if arg to arg.  */\n \n   msp430_compute_frame_info ();\n \n@@ -763,6 +762,10 @@ static bool msp430_rtx_costs (rtx   x ATTRIBUTE_UNUSED,\n    |                    |\n    | PC from call       |  (2 bytes for 430, 4 for TARGET_LARGE)\n    |                    |\n+   +--------------------+\n+   | SR if this func has|\n+   | been called via an |\n+   | interrupt.         |\n    +--------------------+  <-- SP before prologue, also AP\n    |                    |\n    | Saved Regs         |  (2 bytes per reg for 430, 4 per for TARGET_LARGE)\n@@ -806,6 +809,12 @@ msp430_preserve_reg_p (int regno)\n   if (fixed_regs [regno])\n     return false;\n \n+  /* Interrupt handlers save all registers they use, even\n+     ones which are call saved.  If they call other functions\n+     then *every* register is saved.  */\n+  if (msp430_is_interrupt_func ())\n+    return ! crtl->is_leaf || df_regs_ever_live_p (regno);\n+\n   if (!call_used_regs [regno]\n       && df_regs_ever_live_p (regno))\n     return true;\n@@ -825,7 +834,7 @@ msp430_compute_frame_info (void)\n   cfun->machine->framesize_locals = get_frame_size ();\n   cfun->machine->framesize_outgoing = crtl->outgoing_args_size;\n \n-  for (i = 0; i < 16; i ++)\n+  for (i = 0; i < ARG_POINTER_REGNUM; i ++)\n     if (msp430_preserve_reg_p (i))\n       {\n \tcfun->machine->need_to_save [i] = 1;\n@@ -842,6 +851,38 @@ msp430_compute_frame_info (void)\n \t\t\t      + cfun->machine->framesize_outgoing);\n }\n \n+static inline bool\n+is_attr_func (const char * attr)\n+{\n+  return lookup_attribute (attr, DECL_ATTRIBUTES (current_function_decl)) != NULL_TREE;\n+}\n+\n+/* Returns true if the current function has the \"interrupt\" attribute.  */\n+\n+bool\n+msp430_is_interrupt_func (void)\n+{\n+  return is_attr_func (\"interrupt\");\n+}\n+\n+static inline bool\n+is_naked_func (void)\n+{\n+  return is_attr_func (\"naked\");\n+}\n+\n+static inline bool\n+is_reentrant_func (void)\n+{\n+  return is_attr_func (\"reentrant\");\n+}\n+\n+static inline bool\n+is_critical_func (void)\n+{\n+  return is_attr_func (\"critical\");\n+}\n+\n #undef  TARGET_ASM_FUNCTION_PROLOGUE\n #define TARGET_ASM_FUNCTION_PROLOGUE\tmsp430_start_function\n \n@@ -851,6 +892,21 @@ msp430_start_function (FILE *outfile, HOST_WIDE_INT hwi_local ATTRIBUTE_UNUSED)\n   int r, n;\n \n   fprintf (outfile, \"; start of function\\n\");\n+\n+  if (DECL_ATTRIBUTES (current_function_decl) != NULL_TREE)\n+    {\n+      fprintf (outfile, \"; attributes: \");\n+      if (is_naked_func ())\n+\tfprintf (outfile, \"naked \");\n+      if (msp430_is_interrupt_func ())\n+\tfprintf (outfile, \"interrupt \");\n+      if (is_reentrant_func ())\n+\tfprintf (outfile, \"reentrant \");\n+      if (is_critical_func ())\n+\tfprintf (outfile, \"critical \");\n+      fprintf (outfile, \"\\n\");\n+    }\n+\n   fprintf (outfile, \"; framesize_regs:     %d\\n\", cfun->machine->framesize_regs);\n   fprintf (outfile, \"; framesize_locals:   %d\\n\", cfun->machine->framesize_locals);\n   fprintf (outfile, \"; framesize_outgoing: %d\\n\", cfun->machine->framesize_outgoing);\n@@ -860,7 +916,7 @@ msp430_start_function (FILE *outfile, HOST_WIDE_INT hwi_local ATTRIBUTE_UNUSED)\n \n   n = 0;\n   fprintf (outfile, \"; saved regs:\");\n-  for (r = 0; r < 16; r++)\n+  for (r = 0; r < ARG_POINTER_REGNUM; r++)\n     if (cfun->machine->need_to_save [r])\n       {\n \tfprintf (outfile, \" %s\", reg_names [r]);\n@@ -899,6 +955,215 @@ increment_stack (HOST_WIDE_INT amount)\n     }\n }\n \n+/* Verify MSP430 specific attributes.  */\n+\n+static tree\n+msp430_attr (tree * node,\n+\t     tree   name,\n+\t     tree   args,\n+\t     int    flags ATTRIBUTE_UNUSED,\n+\t     bool * no_add_attrs)\n+{\n+  gcc_assert (DECL_P (* node));\n+\n+  if (args != NULL)\n+    {\n+      tree value = TREE_VALUE (args);\n+\n+      switch (TREE_CODE (value))\n+\t{\n+\tcase STRING_CST:\n+\t  if (   strcmp (TREE_STRING_POINTER (value), \"reset\")\n+\t      && strcmp (TREE_STRING_POINTER (value), \"nmi\")\n+\t      && strcmp (TREE_STRING_POINTER (value), \"watchdog\"))\n+\t    /* Allow the attribute to be added - the linker script\n+\t       being used may still recognise this name.  */\n+\t    warning (OPT_Wattributes,\n+\t\t     \"unrecognised interrupt vector argument of %qE attribute\",\n+\t\t     name);\n+\t  break;\n+\n+\tcase INTEGER_CST:\n+\t  if (TREE_INT_CST_LOW (value) > 31)\n+\t    /* Allow the attribute to be added - the linker script\n+\t       being used may still recognise this value.  */\n+\t    warning (OPT_Wattributes,\n+\t\t     \"numeric argument of %qE attribute must be in range 0..31\",\n+\t\t     name);\n+\t  break;\n+\n+\tdefault:\n+\t  warning (OPT_Wattributes,\n+\t\t   \"argument of %qE attribute is not a string constant or number\",\n+\t\t   name);\n+\t  *no_add_attrs = true;\n+\t  break;\n+\t}\n+    }\n+\n+  if (TREE_CODE (* node) != FUNCTION_DECL)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute only applies to functions\",\n+\t       name);\n+      * no_add_attrs = true;\n+    }\n+\n+  /* FIXME: We ought to check that the interrupt handler\n+     attribute has been applied to a void function.  */\n+  /* FIXME: We should check that reentrant and critical\n+     functions are not naked and that critical functions\n+     are not reentrant.  */\n+\n+  return NULL_TREE;\n+}\n+\n+#undef  TARGET_ATTRIBUTE_TABLE\n+#define TARGET_ATTRIBUTE_TABLE\t\tmsp430_attribute_table\n+\n+/* Table of MSP430-specific attributes.  */\n+const struct attribute_spec msp430_attribute_table[] =\n+{\n+  /* Name          min_len  decl_req,    fn_type_req,    affects_type_identity\n+                       max_len,  type_req,        handler.  */\n+  { \"interrupt\",      0, 1, true,  false, false, msp430_attr, false },\n+  { \"naked\",          0, 0, true,  false, false, msp430_attr, false },\n+  { \"reentrant\",      0, 0, true,  false, false, msp430_attr, false },\n+  { \"critical\",       0, 0, true,  false, false, msp430_attr, false },\n+  { NULL,             0, 0, false, false, false, NULL,        false }\n+};\n+\n+void\n+msp430_start_function (FILE *file, const char *name, tree decl)\n+{\n+  tree int_attr;\n+\n+  int_attr = lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (decl));\n+  if (int_attr != NULL_TREE)\n+    {\n+      tree intr_vector = TREE_VALUE (int_attr);\n+\n+      if (intr_vector != NULL_TREE)\n+\t{\n+\t  char buf[101];\n+\n+\t  intr_vector = TREE_VALUE (intr_vector);\n+\n+\t  /* The interrupt attribute has a vector value.  Turn this into a\n+\t     section name, switch to that section and put the address of\n+\t     the current function into that vector slot.  Note msp430_attr()\n+\t     has already verified the vector name for us.  */\n+\t  if (TREE_CODE (intr_vector) == STRING_CST)\n+\t    sprintf (buf, \"__interrupt_vector_%.80s\",\n+\t\t     TREE_STRING_POINTER (intr_vector));\n+\t  else /* TREE_CODE (intr_vector) == INTEGER_CST */\n+\t    sprintf (buf, \"__interrupt_vector_%u\",\n+\t\t     (unsigned int) TREE_INT_CST_LOW (intr_vector));\n+\n+\t  switch_to_section (get_section (buf, SECTION_CODE, decl));\n+\t  fputs (\"\\t.word\\t\", file);\n+\t  assemble_name (file, name);\n+\t  fputc ('\\n', file);\n+\t  fputc ('\\t', file);\n+\t}\n+    }\n+\n+  switch_to_section (function_section (decl));\n+  ASM_OUTPUT_FUNCTION_LABEL (file, name, decl);\n+}\n+\n+static section *\n+msp430_function_section (tree decl, enum node_frequency freq, bool startup, bool exit)\n+{\n+  /* In large mode we must make sure that interrupt handlers are put into\n+     low memory as the vector table only accepts 16-bit addresses.  */\n+  if (TARGET_LARGE\n+      && lookup_attribute (\"interrupt\", DECL_ATTRIBUTES (decl)))\n+    return get_section (\".lowtext\", SECTION_CODE | SECTION_WRITE , decl);\n+\n+  /* Otherwise, use the default function section.  */\n+  return default_function_section (decl, freq, startup, exit);\n+}\n+\n+#undef  TARGET_ASM_FUNCTION_SECTION\n+#define TARGET_ASM_FUNCTION_SECTION msp430_function_section\n+\n+enum msp430_builtin\n+{\n+  MSP430_BUILTIN_BIC_SR,\n+  MSP430_BUILTIN_BIS_SR,\n+  MSP430_BUILTIN_max\n+};\n+\n+static GTY(()) tree msp430_builtins [(int) MSP430_BUILTIN_max];\n+\n+static void\n+msp430_init_builtins (void)\n+{\n+  tree void_ftype_int = build_function_type_list (void_type_node, integer_type_node, NULL);\n+\n+  msp430_builtins[MSP430_BUILTIN_BIC_SR] =\n+    add_builtin_function ( \"__bic_SR_register_on_exit\", void_ftype_int,\n+\t\t\t   MSP430_BUILTIN_BIC_SR, BUILT_IN_MD, NULL, NULL_TREE);\n+\n+  msp430_builtins[MSP430_BUILTIN_BIS_SR] =\n+    add_builtin_function ( \"__bis_SR_register_on_exit\", void_ftype_int,\n+\t\t\t   MSP430_BUILTIN_BIS_SR, BUILT_IN_MD, NULL, NULL_TREE);\n+}\n+\n+static tree\n+msp430_builtin_decl (unsigned code, bool initialize ATTRIBUTE_UNUSED)\n+{\n+  switch (code)\n+    {\n+    case MSP430_BUILTIN_BIC_SR:\n+    case MSP430_BUILTIN_BIS_SR:\n+      return msp430_builtins[code];\n+    default:\n+      return error_mark_node;\n+    }\n+}\n+\n+static rtx\n+msp430_expand_builtin (tree exp,\n+\t\t       rtx target ATTRIBUTE_UNUSED,\n+\t\t       rtx subtarget ATTRIBUTE_UNUSED,\n+\t\t       enum machine_mode mode ATTRIBUTE_UNUSED,\n+\t\t       int ignore ATTRIBUTE_UNUSED)\n+{\n+  tree fndecl = TREE_OPERAND (CALL_EXPR_FN (exp), 0);\n+  unsigned int fcode = DECL_FUNCTION_CODE (fndecl);\n+  rtx arg1 = expand_normal (CALL_EXPR_ARG (exp, 0));\n+\n+  if (! msp430_is_interrupt_func ())\n+    {\n+      error (\"MSP430 builtin functions only work inside interrupt handlers\");\n+      return NULL_RTX;\n+    }\n+\n+  if (! REG_P (arg1) && ! CONSTANT_P (arg1))\n+    arg1 = force_reg (mode, arg1);\n+\n+  switch (fcode)\n+    {\n+    case MSP430_BUILTIN_BIC_SR:  emit_insn (gen_bic_SR (arg1)); break;\n+    case MSP430_BUILTIN_BIS_SR:  emit_insn (gen_bis_SR (arg1)); break;\n+    default:\n+      internal_error (\"bad builtin code\");\n+      break;\n+    }\n+  return NULL_RTX;\n+}\n+\n+#undef  TARGET_INIT_BUILTINS\n+#define TARGET_INIT_BUILTINS  msp430_init_builtins\n+\n+#undef  TARGET_EXPAND_BUILTIN\n+#define TARGET_EXPAND_BUILTIN msp430_expand_builtin\n+\n+#undef  TARGET_BUILTIN_DECL\n+#define TARGET_BUILTIN_DECL   msp430_builtin_decl\n+\n void\n msp430_expand_prologue (void)\n {\n@@ -911,8 +1176,19 @@ msp430_expand_prologue (void)\n   rtx sp = stack_pointer_rtx;\n   rtx p;\n \n+  if (is_naked_func ())\n+    return;\n+\n   emit_insn (gen_prologue_start_marker ());\n \n+  if (is_critical_func ())\n+    {\n+      emit_insn (gen_push_intr_state ());\n+      emit_insn (gen_disable_interrupts ());\n+    }\n+  else if (is_reentrant_func ())\n+    emit_insn (gen_disable_interrupts ());\n+\n   if (!cfun->machine->computed)\n     msp430_compute_frame_info ();\n \n@@ -1009,6 +1285,9 @@ msp430_expand_epilogue (int is_eh)\n   int fs;\n   int helper_n = 0;\n \n+  if (is_naked_func ())\n+    return;\n+\n   if (cfun->machine->need_to_save [10])\n     {\n       /* Check for a helper function.  */\n@@ -1070,6 +1349,9 @@ msp430_expand_epilogue (int is_eh)\n \t    i += count - 1;\n \t  }\n \telse if (i == 11 - helper_n\n+\t\t && ! msp430_is_interrupt_func ()\n+\t\t && ! is_reentrant_func ()\n+\t\t && ! is_critical_func ()\n \t\t && crtl->args.pretend_args_size == 0\n \t\t /* Calling the helper takes as many bytes as the POP;RET sequence.  */\n \t\t && helper_n != 1\n@@ -1092,7 +1374,12 @@ msp430_expand_epilogue (int is_eh)\n \n   if (crtl->args.pretend_args_size)\n     emit_insn (gen_swap_and_shrink ());\n-    \n+\n+  if (is_critical_func ())\n+    emit_insn (gen_pop_intr_state ());\n+  else if (is_reentrant_func ())\n+    emit_insn (gen_enable_interrupts ());\n+\n   emit_jump_insn (gen_msp_return ());\n }\n \n@@ -1131,12 +1418,15 @@ msp430_expand_eh_return (rtx eh_handler)\n }\n \n /* This is a list of MD patterns that implement fixed-count shifts.  */\n-static struct {\n+static struct\n+{\n   const char *name;\n   int count;\n   int need_430x;\n   rtx (*genfunc)(rtx,rtx);\n-} const_shift_helpers[] = {\n+}\n+  const_shift_helpers[] =\n+{\n #define CSH(N,C,X,G) { \"__mspabi_\"N, C, X, gen_##G }\n \n   CSH (\"slli\", 1, 1, slli_1),\n@@ -1329,7 +1619,6 @@ msp430_split_movsi (rtx *operands)\n }\n \n \f\n-\n /* The MSPABI specifies the names of various helper functions, many of\n    which are compatible with GCC's helpers.  This table maps the GCC\n    name to the MSPABI name.  */\n@@ -1600,6 +1889,15 @@ msp430_print_operand (FILE * file, rtx op, int letter)\n       if (TARGET_LARGE)\n \tfprintf (file, \"A\");\n       return;\n+\n+    case 'O':\n+      /* Computes the offset to the top of the stack for the current frame.\n+\t This has to be done here rather than in, say, msp430_expand_builtin()\n+\t because builtins are expanded before the frame layout is determined.  */\n+      fprintf (file, \"%d\",\n+\t       msp430_initial_elimination_offset (ARG_POINTER_REGNUM, STACK_POINTER_REGNUM)\n+\t        - 2);\n+      return ;\n     }\n \n   switch (GET_CODE (op))"}, {"sha": "0b77c4abb451318b99070ecc369972c5f85e5dfd", "filename": "gcc/config/msp430/msp430.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.h?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -1,5 +1,5 @@\n /* GCC backend definitions for the TI MSP430 Processor\n-   Copyright (C) 2012 Free Software Foundation, Inc.\n+   Copyright (C) 2012-2013 Free Software Foundation, Inc.\n    Contributed by Red Hat.\n \n    This file is part of GCC.\n@@ -29,6 +29,7 @@ extern bool msp430x;\n #define TARGET_CPU_CPP_BUILTINS()               \\\n   do                                            \\\n     {                                           \\\n+      builtin_define (\"NO_TRAMPOLINES\");        \\\n       builtin_define (\"__MSP430__\"); \t\t\\\n       if (msp430x)\t\t\t\t\\\n \t{\t\t\t\t\t\\\n@@ -281,7 +282,8 @@ enum reg_class\n \n \f\n \n-typedef struct {\n+typedef struct\n+{\n   /* These two are the current argument status.  */\n   char reg_used[4];\n #define CA_FIRST_REG 12"}, {"sha": "a258867e53238843b5a6891ef7bde3c324152735", "filename": "gcc/config/msp430/msp430.md", "status": "modified", "additions": 49, "deletions": 4, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fconfig%2Fmsp430%2Fmsp430.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmsp430%2Fmsp430.md?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -38,6 +38,13 @@\n \n    UNS_GROW_AND_SWAP\n    UNS_SWAP_AND_SHRINK\n+   \n+   UNS_DINT\n+   UNS_EINT\n+   UNS_PUSH_INTR\n+   UNS_POP_INTR\n+   UNS_BIC_SR\n+   UNS_BIS_SR\n   ])\n   \n (include \"predicates.md\")\n@@ -78,7 +85,7 @@\n \n (define_insn \"pushm\"\n   [(unspec_volatile [(match_operand 0 \"register_operand\" \"r\")\n-\t\t     (match_operand 1 \"immediate_operand\" \"i\")] UNS_PUSHM)]\n+\t\t     (match_operand 1 \"immediate_operand\" \"n\")] UNS_PUSHM)]\n   \"\"\n   \"PUSHM%B0\\t%1, %0\"\n   )\n@@ -950,7 +957,7 @@\n (define_insn \"msp_return\"\n   [(return)]\n   \"\"\n-  { return TARGET_LARGE ? \"RETA\" : \"RET\"; }\n+  { return msp430_is_interrupt_func () ? \"RETI\" : (TARGET_LARGE ? \"RETA\" : \"RET\"); }\n )\n \n ;; This pattern is NOT, as expected, a return pattern.  It's called\n@@ -1102,7 +1109,6 @@\n    CMP%X0.W\\t%1, %2 { J%R0\\t%l3\"\n   )\n \n-\n (define_insn \"*bitbranch<mode>4\"\n   [(set (pc) (if_then_else\n \t      (ne (and:QHI (match_operand:QHI 0 \"msp_nonimmediate_operand\" \"rYs,rm\")\n@@ -1158,7 +1164,7 @@\n   )\n \n ;;------------------------------------------------------------\n-;; zero-extend versions of the above\n+;; zero-extract versions of the above\n \n (define_insn \"*bitbranch<mode>4_z\"\n   [(set (pc) (if_then_else\n@@ -1227,3 +1233,42 @@\n   \"NOP\"\n )\n   \n+(define_insn \"disable_interrupts\"\n+  [(unspec_volatile [(const_int 0)] UNS_DINT)]\n+  \"\"\n+  \"DINT\"\n+  )\n+\n+(define_insn \"enable_interrupts\"\n+  [(unspec_volatile [(const_int 0)] UNS_EINT)]\n+  \"\"\n+  \"EINT\"\n+  )\n+\n+(define_insn \"push_intr_state\"\n+  [(unspec_volatile [(const_int 0)] UNS_PUSH_INTR)]\n+  \"\"\n+  \"PUSH\\tSR\"\n+  )\n+\n+(define_insn \"pop_intr_state\"\n+  [(unspec_volatile [(const_int 0)] UNS_POP_INTR)]\n+  \"\"\n+  \"POP\\tSR\"\n+  )\n+\n+;; Clear bits in the copy of the status register that is currently\n+;; saved on the stack at the top of the interrupt handler.\n+(define_insn \"bic_SR\"\n+  [(unspec_volatile [(match_operand 0 \"nonmemory_operand\" \"ir\")] UNS_BIC_SR)]\n+  \"\"\n+  \"BIC.W\\t%0, %O0(SP)\"\n+  )\n+\n+;; Set bits in the copy of the status register that is currently\n+;; saved on the stack at the top of the interrupt handler.\n+(define_insn \"bis_SR\"\n+  [(unspec_volatile [(match_operand 0 \"nonmemory_operand\" \"ir\")] UNS_BIS_SR)]\n+  \"\"\n+  \"BIS.W\\t%0, %O0(SP)\"\n+  )"}, {"sha": "cb0306b72b99414763d914093d67bbd1f13aa05c", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 53, "deletions": 3, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cad055a4ba2356bb1cde958dfe41de705e39bfea/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=cad055a4ba2356bb1cde958dfe41de705e39bfea", "patch": "@@ -30,7 +30,7 @@ extensions, accepted by GCC in C90 mode and in C++.\n * Constructing Calls::  Dispatching a call to another function.\n * Typeof::              @code{typeof}: referring to the type of an expression.\n * Conditionals::        Omitting the middle operand of a @samp{?:} expression.\n-* __int128::\t\t\t128-bit integers---@code{__int128}.\n+* __int128::\t\t128-bit integers---@code{__int128}.\n * Long Long::           Double-word integers---@code{long long int}.\n * Complex::             Data types for complex numbers.\n * Floating Types::      Additional Floating Types.\n@@ -2813,7 +2813,7 @@ least version 2.20.1), and GNU C library (at least version 2.11.1).\n @item interrupt\n @cindex interrupt handler functions\n Use this attribute on the ARM, AVR, CR16, Epiphany, M32C, M32R/D, m68k, MeP, MIPS,\n-RL78, RX and Xstormy16 ports to indicate that the specified function is an\n+MSP430, RL78, RX and Xstormy16 ports to indicate that the specified function is an\n interrupt handler.  The compiler generates function entry and exit\n sequences suitable for use in an interrupt handler when this attribute\n is present.  With Epiphany targets it may also generate a special section with\n@@ -2844,6 +2844,35 @@ Permissible values for this parameter are: @code{IRQ}, @code{FIQ},\n On ARMv7-M the interrupt type is ignored, and the attribute means the function\n may be called with a word-aligned stack pointer.\n \n+Note, for the MSP430 you can provide an argument to the interrupt\n+attribute which specifies a name or number.  If the argument is a\n+number it indicates the slot in the interrupt vector table (0 - 31) to\n+which this handler should be assigned.  If the argument is a name it\n+is treated as a symbolic name for the vector slot.  These names should\n+match up with appropriate entries in the linker script.  By default\n+the names @code{watchdog} for vector 26, @code{nmi} for vector 30 and\n+@code{reset} for vector 31 are recognised.\n+\n+You can also use the following function attributes to modify how\n+normal functions interact with interrupt functions:\n+\n+@table @code\n+@item critical\n+@cindex @code{critical} attribute\n+Critical functions disable interrupts upon entry and restore the\n+previous interrupt state upon exit.  Critical functions cannot also\n+have the @code{naked} or @code{reentrant} attributes.  They can have\n+the @code{interrupt} attribute.\n+\n+@item reentrant\n+@cindex @code{reentrant} attribute\n+Reentrant functions disable interrupts upon entry and enable them\n+upon exit.  Reentrant functions cannot also have the @code{naked}\n+or @code{critical} attributes.  They can have the @code{interrupt}\n+attribute.\n+\n+@end table\n+\n On Epiphany targets one or more optional parameters can be added like this:\n \n @smallexample\n@@ -3143,7 +3172,7 @@ and newer.\n \n @item naked\n @cindex function without a prologue/epilogue code\n-Use this attribute on the ARM, AVR, MCORE, RL78, RX and SPU ports to indicate that\n+Use this attribute on the ARM, AVR, MCORE, MSP430, RL78, RX and SPU ports to indicate that\n the specified function does not need prologue/epilogue sequences generated by\n the compiler.  It is up to the programmer to provide these sequences. The\n only statements that can be safely included in naked functions are\n@@ -8844,6 +8873,7 @@ instructions, but allow the compiler to schedule those calls.\n * MIPS Paired-Single Support::\n * MIPS Loongson Built-in Functions::\n * Other MIPS Built-in Functions::\n+* MSP430 Built-in Functions::\n * picoChip Built-in Functions::\n * PowerPC Built-in Functions::\n * PowerPC AltiVec/VSX Built-in Functions::\n@@ -11853,6 +11883,26 @@ GCC defines the preprocessor macro @code{___GCC_HAVE_BUILTIN_MIPS_CACHE}\n when this function is available.\n @end table\n \n+@node MSP430 Built-in Functions\n+@subsection MSP430 Built-in Functions\n+\n+GCC provides a couple of special builtin functions to aid in the\n+writing of interrupt handlers in C.\n+\n+@table @code\n+@item __bic_SR_register_on_exit (int @var{mask})\n+This clears the indicated bits in the saved copy of the status register\n+currently residing on the stack.  This only works inside interrupt\n+handlers and the changes to the status register will only take affect\n+once the handler returns.\n+\n+@item __bis_SR_register_on_exit (int @var{mask})\n+This sets the indicated bits in the saved copy of the status register\n+currently residing on the stack.  This only works inside interrupt\n+handlers and the changes to the status register will only take affect\n+once the handler returns.\n+@end table\n+\n @node picoChip Built-in Functions\n @subsection picoChip Built-in Functions\n "}]}