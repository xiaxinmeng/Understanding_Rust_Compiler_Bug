{"sha": "b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUzOTc4YTNlZTM5OTg4NjNjMGY5NDJiOWI0YzQwZDBlMzZkMmJjNw==", "commit": {"author": {"name": "Jeffrey Oldham", "email": "oldham@codesourcery.com", "date": "2000-08-02T04:21:27Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-08-02T04:21:27Z"}, "message": "Makefile.in (OBJS): Added dce.o.\n\n\t* Makefile.in (OBJS): Added dce.o.\n\t(ssa.o): Updated target to include ssa.h.\n\t(flow.o): Likewise.\n\t(toplev.o): Likewise.\n\t(dce.o): Created target.\n\t* basic-block.h: Added comments.\n\t(INVALID_BLOCK): Added definition.\n\t(connect_infinite_loops_to_exit): Added declaration.\n\tMoved SSA declarations to ssa.h.\n\t* flow.c: Added inclusion of ssa.h.\n\t(struct depth_first_search_dsS, depth_first_search_ds):\n\tAdded definitions.\n\t(compute_immediate_postdominators): Added definition.\n\t(connect_infinite_loops_to_exit): Likewise.\n\t(flow_dfs_compute_reverse_init): Likewise.\n\t(flow_dfs_compute_reverse_add_bb): Likewise.\n\t(flow_dfs_compute_reverse_execute): Likewise.\n\t(flow_dfs_compute_reverse_finish): Likewise.\n\t* rtl.h (rtx/in_struct): Added use to determine insn necessity.\n\t(LABEL_P): Added definition.\n\t(JUMP_P): Likewise.\n\t(NOTE_P): Likewise.\n\t(BARRIER_P): Likewise.\n\t(JUMP_TABLE_DATA_P): Likewise.\n\t(INSN_DEAD_CODE_P): Likewise.\n\t* ssa.c: Replaced inclusions with ssa.h inclusion.\n\t(CONVERT_HARD_REGISTER_TO_SSA_P): Moved to ssa.h.\n\t(rename_registers): Removed unnecessary variables.\n\t* ssa.h: Created by moving declarations from ssa.c and\n\tbasic-block.h.\n\t* timevar.def: Defined TV_DEAD_CODE_ELIM.\n\t* toplev.c: Added ssa.h inclusion.\n\t(dump_file_index): Added DFI_dce.\n\t(dump_file): Added \"dce\" entry.\n\tDefined flag_ssa.\n\t(f_options): Added dce entry.\n\t* invoke.texi: Document -fdce.  Emphasize experimental status of\n\t-fssa.\n\nCo-Authored-By: Mark Mitchell <mark@codesourcery.com>\n\nFrom-SVN: r35419", "tree": {"sha": "effa31090707b8e4d80bb9f56140fd2884c53bc1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/effa31090707b8e4d80bb9f56140fd2884c53bc1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/comments", "author": null, "committer": null, "parents": [{"sha": "79c2c6da2c5621208eec12f608b672856d38f6a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79c2c6da2c5621208eec12f608b672856d38f6a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79c2c6da2c5621208eec12f608b672856d38f6a3"}], "stats": {"total": 1055, "additions": 990, "deletions": 65}, "files": [{"sha": "2d7522426988075f07c820b442325ce07dfc989b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -1,3 +1,45 @@\n+2000-08-01  Jeffrey Oldham  <oldham@codesourcery.com>\n+            Mark Mitchell <mark@codesourcery.com>\n+\t\n+\t* Makefile.in (OBJS): Added dce.o.\n+\t(ssa.o): Updated target to include ssa.h.\n+\t(flow.o): Likewise.\n+\t(toplev.o): Likewise.\n+\t(dce.o): Created target.\n+\t* basic-block.h: Added comments.\n+\t(INVALID_BLOCK): Added definition.\n+\t(connect_infinite_loops_to_exit): Added declaration.\n+\tMoved SSA declarations to ssa.h.\t\n+\t* flow.c: Added inclusion of ssa.h.\n+\t(struct depth_first_search_dsS, depth_first_search_ds):\n+\tAdded definitions.\n+\t(compute_immediate_postdominators): Added definition.\n+\t(connect_infinite_loops_to_exit): Likewise.\n+\t(flow_dfs_compute_reverse_init): Likewise.\n+\t(flow_dfs_compute_reverse_add_bb): Likewise.\n+\t(flow_dfs_compute_reverse_execute): Likewise.\n+\t(flow_dfs_compute_reverse_finish): Likewise.\n+\t* rtl.h (rtx/in_struct): Added use to determine insn necessity.\n+\t(LABEL_P): Added definition.\n+\t(JUMP_P): Likewise.\n+\t(NOTE_P): Likewise.\n+\t(BARRIER_P): Likewise.\n+\t(JUMP_TABLE_DATA_P): Likewise.\n+\t(INSN_DEAD_CODE_P): Likewise.\n+\t* ssa.c: Replaced inclusions with ssa.h inclusion.\n+\t(CONVERT_HARD_REGISTER_TO_SSA_P): Moved to ssa.h.\n+\t(rename_registers): Removed unnecessary variables.\n+\t* ssa.h: Created by moving declarations from ssa.c and\n+\tbasic-block.h.\n+\t* timevar.def: Defined TV_DEAD_CODE_ELIM.\n+\t* toplev.c: Added ssa.h inclusion.\n+\t(dump_file_index): Added DFI_dce.\n+\t(dump_file): Added \"dce\" entry.\n+\tDefined flag_ssa.\n+\t(f_options): Added dce entry.\n+\t* invoke.texi: Document -fdce.  Emphasize experimental status of\n+\t-fssa. \n+\t\n 2000-08-01  Zack Weinberg  <zack@wolery.cumb.org>\n \n \t* cpperror.c (v_message): Split into _cpp_begin_message and"}, {"sha": "31ab344f9d18258b6feb165da775ff5acce21933", "filename": "gcc/Makefile.in", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -696,7 +696,7 @@ OBJS = diagnostic.o\t\t\t\t\t\t\t      \\\n  profile.o insn-attrtab.o $(out_object_file) $(EXTRA_OBJS) convert.o\t      \\\n  mbchar.o splay-tree.o graph.o sbitmap.o resource.o hash.o predict.o\t      \\\n  lists.o ggc-common.o $(GGC) simplify-rtx.o ssa.o bb-reorder.o\t\t      \\\n- sibcall.o conflict.o timevar.o ifcvt.o\n+ sibcall.o conflict.o timevar.o ifcvt.o dce.o\n \n # GEN files are listed separately, so they can be built before doing parallel\n #  makes for cc1 or cc1plus.  Otherwise sequent parallel make attempts to load\n@@ -1242,7 +1242,7 @@ toplev.o : toplev.c $(CONFIG_H) system.h $(TREE_H) $(RTL_H) function.h \\\n    flags.h input.h $(INSN_ATTR_H) xcoffout.h defaults.h output.h diagnostic.h \\\n    insn-codes.h insn-config.h intl.h $(RECOG_H) Makefile toplev.h dwarfout.h \\\n    dwarf2out.h sdbout.h dbxout.h $(EXPR_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n-   graph.h loop.h  except.h regs.h $(TIMEVAR_H) $(lang_options_files)\n+   graph.h loop.h  except.h regs.h $(TIMEVAR_H) $(lang_options_files) ssa.h\n \t$(CC) $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $(MAYBE_USE_COLLECT2) \\\n \t  -DTARGET_NAME=\\\"$(target_alias)\\\" \\\n \t  -c `echo $(srcdir)/toplev.c | sed 's,^\\./,,'`\n@@ -1326,10 +1326,11 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h system.h \\\n    $(INSN_ATTR_H) except.h\n lcm.o : lcm.c $(CONFIG_H) system.h $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H)\n-ssa.o : ssa.c $(CONFIG_H) system.h $(RTL_H) varray.h sbitmap.h\t\t\\\n-   $(HASHTAB_H) $(REGS_H) hard-reg-set.h flags.h function.h real.h\t\\\n-   insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)\t\t\t\t\\\n-   output.h\n+ssa.o : ssa.c $(CONFIG_H) system.h $(REGS_H) varray.h\t\t\t\\\n+   hard-reg-set.h flags.h function.h real.h insn-config.h $(RECOG_H)\t\\\n+   $(BASIC_BLOCK_H) output.h ssa.h\n+dce.o : dce.c $(CONFIG_H) system.h $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H) \\\n+   ssa.h insn-config.h $(RECOG_H) output.h\n conflict.o : conflict.c $(CONFIG_H) system.h $(OBSTACK_H) $(HASHTAB_H) \\\n    $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h \\\n@@ -1345,7 +1346,7 @@ unroll.o : unroll.c $(CONFIG_H) system.h $(RTL_H) insn-config.h function.h \\\n    hard-reg-set.h varray.h $(BASIC_BLOCK_H)\n flow.o : flow.c $(CONFIG_H) system.h $(RTL_H) $(TREE_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n-   insn-flags.h function.h except.h $(EXPR_H)\n+   insn-flags.h function.h except.h $(EXPR_H) ssa.h\n combine.o : combine.c $(CONFIG_H) system.h $(RTL_H) flags.h function.h \\\n    insn-config.h insn-flags.h insn-codes.h $(INSN_ATTR_H) $(REGS_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(RECOG_H) real.h hard-reg-set.h toplev.h"}, {"sha": "a018f23770b481f6533ea28a64ed67d0611d75eb", "filename": "gcc/basic-block.h", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -141,6 +141,18 @@ typedef struct edge_def {\n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n \n+/* Basic blocks need not start with a label nor end with a jump insn.\n+   For example, a previous basic block may just \"conditionally fall\"\n+   into the succeeding basic block, and the last basic block need not\n+   end with a jump insn.  Block 0 is a descendant of the entry block.\n+\n+   A basic block beginning with two labels cannot have notes between\n+   the labels.\n+\n+   Data for jump tables are stored in jump_insns that occur in no\n+   basic block even though these insns can follow or precede insns in\n+   basic blocks.  */\n+\n /* Basic block information indexed by block number.  */\n typedef struct basic_block_def {\n   /* The first and last insns of the block.  */\n@@ -210,6 +222,9 @@ extern regset regs_live_at_setjmp;\n #define ENTRY_BLOCK (-1)\n #define EXIT_BLOCK (-2)\n \n+/* Special block number not valid for any block. */\n+#define INVALID_BLOCK (-3)\n+\n /* Similarly, block pointers for the edge list.  */\n extern struct basic_block_def entry_exit_blocks[2];\n #define ENTRY_BLOCK_PTR\t(&entry_exit_blocks[0])\n@@ -230,6 +245,7 @@ extern void insert_insn_on_edge\t\tPARAMS ((rtx, edge));\n extern void commit_edge_insertions\tPARAMS ((void));\n extern void remove_fake_edges\t\tPARAMS ((void));\n extern void add_noreturn_fake_exit_edges\tPARAMS ((void));\n+extern void connect_infinite_loops_to_exit\tPARAMS ((void));\n extern rtx flow_delete_insn\t\tPARAMS ((rtx));\n extern void flow_delete_insn_chain\tPARAMS ((rtx, rtx));\n extern void make_edge\t\t\tPARAMS ((sbitmap *, basic_block,\n@@ -514,13 +530,4 @@ extern conflict_graph conflict_graph_compute\n                                         PARAMS ((regset,\n \t\t\t\t\t\t partition));\n \n-/* In ssa.c */\n-extern void convert_to_ssa\t\tPARAMS ((void));\n-extern void convert_from_ssa\t\tPARAMS ((void));\n-typedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\n-extern int for_each_successor_phi       PARAMS ((basic_block bb,\n-\t\t\t\t\t\t successor_phi_fn,\n-\t\t\t\t\t\t void *));\n-extern int in_ssa_form;\n-\n #endif /* _BASIC_BLOCK_H */"}, {"sha": "f385afd31ea3012c42938796fb53bd67ce96d53e", "filename": "gcc/dce.c", "status": "added", "additions": 620, "deletions": 0, "changes": 620, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fdce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fdce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdce.c?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -0,0 +1,620 @@\n+/* Dead-code elimination pass for the GNU compiler.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+GNU CC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* Dead-code elimination is the removal of instructions which have no\n+   impact on the program's output.  \"Dead instructions\" have no impact\n+   on the program's output, while \"necessary instructions\" may have\n+   impact on the output.\n+\n+   The algorithm consists of three phases:\n+   1) marking as necessary all instructions known to be necessary,\n+      e.g., writing a value to memory,\n+   2) propagating necessary instructions, e.g., the instructions\n+      giving values to operands in necessary instructions, and\n+   3) removing dead instructions (except replacing dead conditionals\n+      with unconditional jumps).\n+\n+   Side Effects:\n+   The last step can require adding labels, deleting insns, and\n+   modifying basic block structures.  Some conditional jumps may be\n+   converted to unconditional jumps so the control-flow graph may be\n+   out-of-date.  \n+\n+   Edges from some infinite loops to the exit block can be added to\n+   the control-flow graph.\n+\n+   It Does Not Perform:\n+   We decided to not simultaneously perform jump optimization and dead\n+   loop removal during dead-code elimination.  Thus, all jump\n+   instructions originally present remain after dead-code elimination\n+   but 1) unnecessary conditional jump instructions are changed to\n+   unconditional jump instructions and 2) all unconditional jump\n+   instructions remain.\n+\n+   Assumptions:\n+   1) SSA has been performed.\n+   2) The basic block and control-flow graph structures are accurate.\n+   3) The flow graph permits constructing an edge_list.\n+   4) note rtxes should be saved.\n+\n+   Unfinished:\n+   When replacing unnecessary conditional jumps with unconditional\n+   jumps, the control-flow graph is not updated.  It should be.\n+\n+   References:\n+   Building an Optimizing Compiler\n+   Robert Morgan\n+   Butterworth-Heinemann, 1998\n+   Section 8.9\n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+\n+#include \"rtl.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"ssa.h\"\n+#include \"insn-config.h\"\n+#include \"recog.h\"\n+#include \"output.h\"\n+\n+/* We cannot use <assert.h> in GCC source, since that would include\n+   GCC's assert.h, which may not be compatible with the host compiler.  */\n+#undef assert\n+#ifdef NDEBUG\n+# define assert(e)\n+#else\n+# define assert(e) do { if (! (e)) abort (); } while (0)\n+#endif\n+\f\n+/* A map from blocks to the edges on which they are control dependent.  */\n+typedef struct {\n+  /* An dynamically allocated array.  The Nth element corresponds to\n+     the block with index N + 2.  The Ith bit in the bitmap is set if\n+     that block is dependent on the Ith edge.  */\n+  bitmap *data;\n+  /* The number of elements in the array.  */\n+  int length;\n+} control_dependent_block_to_edge_map_s, *control_dependent_block_to_edge_map;\n+\n+/* Local function prototypes.  */\n+static control_dependent_block_to_edge_map control_dependent_block_to_edge_map_create\n+  PARAMS((size_t num_basic_blocks));\n+static void set_control_dependent_block_to_edge_map_bit\n+  PARAMS ((control_dependent_block_to_edge_map c, basic_block bb,\n+\t   int edge_index));\n+static void control_dependent_block_to_edge_map_free\n+  PARAMS ((control_dependent_block_to_edge_map c));\n+static void find_all_control_dependences\n+  PARAMS ((struct edge_list *el, int *pdom,\n+\t   control_dependent_block_to_edge_map cdbte));\n+static void find_control_dependence\n+  PARAMS ((struct edge_list *el, int edge_index, int *pdom,\n+\t   control_dependent_block_to_edge_map cdbte));\n+static basic_block find_pdom\n+  PARAMS ((int *pdom, basic_block block));\n+static int inherently_necessary_register_1\n+  PARAMS ((rtx *current_rtx, void *data));\n+static int inherently_necessary_register\n+  PARAMS ((rtx current_rtx));\n+static int find_inherently_necessary\n+  PARAMS ((rtx current_rtx));\n+static int propagate_necessity_through_operand\n+  PARAMS ((rtx *current_rtx, void *data));\n+\f\n+/* Unnecessary insns are indicated using insns' in_struct bit.  */\n+\n+/* Indicate INSN is dead-code; returns nothing.  */\n+#define KILL_INSN(INSN)\t\tINSN_DEAD_CODE_P(INSN) = 1\n+/* Indicate INSN is necessary, i.e., not dead-code; returns nothing.  */\n+#define RESURRECT_INSN(INSN)\tINSN_DEAD_CODE_P(INSN) = 0\n+/* Return nonzero if INSN is unnecessary.  */\n+#define UNNECESSARY_P(INSN)\tINSN_DEAD_CODE_P(INSN)\n+static void mark_all_insn_unnecessary\n+  PARAMS ((void));\n+/* Execute CODE with free variable INSN for all unnecessary insns in\n+   an unspecified order, producing no output.  */\n+#define EXECUTE_IF_UNNECESSARY(INSN, CODE)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  rtx INSN;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+  for (INSN = get_insns (); INSN != NULL_RTX; INSN = NEXT_INSN (INSN))\t\\\n+    if (INSN_DEAD_CODE_P (INSN)) {\t\t\t\t\\\n+      CODE;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+/* Find the label beginning block BB.  */\n+static rtx find_block_label\n+  PARAMS ((basic_block bb));\n+/* Remove INSN, updating its basic block structure.  */\n+static void delete_insn_bb\n+  PARAMS ((rtx insn));\n+\f\n+/* Recording which blocks are control dependent on which edges.  We\n+   expect each block to be control dependent on very few edges so we\n+   use a bitmap for each block recording its edges.  An array holds\n+   the bitmap.  Its position 0 entry holds the bitmap for block\n+   INVALID_BLOCK+1 so that all blocks, including the entry and exit\n+   blocks can participate in the data structure.  */\n+\n+/* Create a control_dependent_block_to_edge_map, given the number\n+   NUM_BASIC_BLOCKS of non-entry, non-exit basic blocks, e.g.,\n+   n_basic_blocks.  This memory must be released using\n+   control_dependent_block_to_edge_map_free ().  */\n+\n+static control_dependent_block_to_edge_map\n+control_dependent_block_to_edge_map_create (num_basic_blocks)\n+     size_t num_basic_blocks;\n+{\n+  int i;\n+  control_dependent_block_to_edge_map c\n+    = xmalloc (sizeof (control_dependent_block_to_edge_map_s));\n+  c->length = num_basic_blocks - (INVALID_BLOCK+1);\n+  c->data = xmalloc ((size_t) c->length*sizeof (bitmap));\n+  for (i = 0; i < c->length; ++i)\n+    c->data[i] = BITMAP_XMALLOC ();\n+\n+  return c;\n+}\n+\n+/* Indicate block BB is control dependent on an edge with index\n+   EDGE_INDEX in the mapping C of blocks to edges on which they are\n+   control-dependent.  */\n+\n+static void\n+set_control_dependent_block_to_edge_map_bit (c, bb, edge_index)\n+     control_dependent_block_to_edge_map c;\n+     basic_block bb;\n+     int edge_index;\n+{\n+  assert(bb->index - (INVALID_BLOCK+1) < c->length);\n+  bitmap_set_bit (c->data[bb->index - (INVALID_BLOCK+1)],\n+\t\t  edge_index);\n+}\n+\n+/* Execute CODE for each edge (given number EDGE_NUMBER within the\n+   CODE) for which the block containing INSN is control dependent,\n+   returning no output.  CDBTE is the mapping of blocks to edges on\n+   which they are control-dependent.  */\n+\n+#define EXECUTE_IF_CONTROL_DEPENDENT(CDBTE, INSN, EDGE_NUMBER, CODE) \\\n+\tEXECUTE_IF_SET_IN_BITMAP \\\n+\t  (CDBTE->data[BLOCK_NUM (INSN) - (INVALID_BLOCK+1)], 0, \\\n+\t  EDGE_NUMBER, CODE)\n+\n+/* Destroy a control_dependent_block_to_edge_map C.  */\n+\n+static void\n+control_dependent_block_to_edge_map_free (c)\n+     control_dependent_block_to_edge_map c;\n+{\n+  int i;\n+  for (i = 0; i < c->length; ++i)\n+    BITMAP_XFREE (c->data[i]);\n+  free ((PTR) c);\n+}\n+\n+/* Record all blocks' control dependences on all edges in the edge\n+   list EL, ala Morgan, Section 3.6.  The mapping PDOM of blocks to\n+   their postdominators are used, and results are stored in CDBTE,\n+   which should be empty.  */\n+\n+static void\n+find_all_control_dependences (el, pdom, cdbte)\n+   struct edge_list *el;\n+   int *pdom;\n+   control_dependent_block_to_edge_map cdbte;\n+{\n+  int i;\n+\n+  for (i = 0; i < NUM_EDGES (el); ++i)\n+    find_control_dependence (el, i, pdom, cdbte);\n+}\n+\n+/* Determine all blocks' control dependences on the given edge with\n+   edge_list EL index EDGE_INDEX, ala Morgan, Section 3.6.  The\n+   mapping PDOM of blocks to their postdominators are used, and\n+   results are stored in CDBTE, which is assumed to be initialized\n+   with zeros in each (block b', edge) position.  */\n+\n+static void\n+find_control_dependence (el, edge_index, pdom, cdbte)\n+   struct edge_list *el;\n+   int edge_index;\n+   int *pdom;\n+   control_dependent_block_to_edge_map cdbte;\n+{\n+  basic_block current_block;\n+  basic_block ending_block;\n+\n+  assert (INDEX_EDGE_PRED_BB (el, edge_index) != EXIT_BLOCK_PTR);\n+  ending_block = \n+    (INDEX_EDGE_PRED_BB (el, edge_index) == ENTRY_BLOCK_PTR) \n+    ? BASIC_BLOCK (0) \n+    : find_pdom (pdom, INDEX_EDGE_PRED_BB (el, edge_index));\n+\n+  for (current_block = INDEX_EDGE_SUCC_BB (el, edge_index);\n+       current_block != ending_block && current_block != EXIT_BLOCK_PTR;\n+       current_block = find_pdom (pdom, current_block))\n+    {\n+      set_control_dependent_block_to_edge_map_bit (cdbte,\n+\t\t\t\t\t\t   current_block,\n+\t\t\t\t\t\t   edge_index);\n+    }\n+}\n+\f\n+/* Find the immediate postdominator PDOM of the specified basic block\n+   BLOCK.  This function is necessary because some blocks have\n+   negative numbers.  */\n+\n+static basic_block\n+find_pdom (pdom, block)\n+     int *pdom;\n+     basic_block block;\n+{\n+  assert (block != NULL);\n+  assert (block->index != INVALID_BLOCK);\n+  if (block == ENTRY_BLOCK_PTR)\n+    return BASIC_BLOCK (0);\n+  else if (block == EXIT_BLOCK_PTR || pdom[block->index] == EXIT_BLOCK)\n+    return EXIT_BLOCK_PTR;\n+  else\n+    return BASIC_BLOCK (pdom[block->index]);\n+}\n+\n+/* Determine if the given CURRENT_RTX uses a hard register not\n+   converted to SSA.  Returns nonzero only if it uses such a hard\n+   register.  DATA is not used.\n+\n+   The program counter (PC) is not considered inherently necessary\n+   since code should be position-independent and thus not depend on\n+   particular PC values.  */\n+\n+static int\n+inherently_necessary_register_1 (current_rtx, data)\n+     rtx *current_rtx;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  rtx x = *current_rtx;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+  switch (GET_CODE (x))\n+    {\n+    case CLOBBER:\n+      /* Do not traverse the rest of the clobber.  */\n+      return -1;\t\t\n+      break;\n+    case PC:\n+      return 0;\n+      break;\n+    case REG:\n+      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)) || x == pc_rtx)\n+\treturn 0;\n+      else\n+\treturn !0;\n+      break;\n+    default:\n+      return 0;\n+      break;\n+    }\n+}\n+\n+/* Return nonzero if the insn CURRENT_RTX is inherently necessary.  */\n+\n+static int\n+inherently_necessary_register (current_rtx)\n+     rtx current_rtx;\n+{\n+  return for_each_rtx (&current_rtx,\n+\t\t       &inherently_necessary_register_1, NULL);\n+}\n+\n+/* Mark X as inherently necessary if appropriate.  For example,\n+   function calls and storing values into memory are inherently\n+   necessary.  This function is to be used with for_each_rtx ().\n+   Return nonzero iff inherently necessary.  */\n+\n+static int\n+find_inherently_necessary (x)\n+     rtx x;\n+{\n+  rtx pattern;\n+  if (x == NULL_RTX)\n+    return 0;\n+  else if (inherently_necessary_register (x))\n+    return !0;\n+  else\n+    switch (GET_CODE (x))\n+      {  \n+      case CALL_INSN:\n+      case CODE_LABEL:\n+      case NOTE:\n+      case BARRIER:\n+\treturn !0;\n+\tbreak;\n+      case JUMP_INSN:\n+\treturn JUMP_TABLE_DATA_P (x) || computed_jump_p (x) != 0;\n+\tbreak;\n+      case INSN:\n+\tpattern = PATTERN (x);\n+\tswitch (GET_CODE (pattern))\n+\t  {\n+\t  case SET:\n+\t  case PRE_DEC:\n+\t  case PRE_INC:\n+\t  case POST_DEC:\n+\t  case POST_INC:\n+\t    return GET_CODE (SET_DEST (pattern)) == MEM;\n+\t  case CALL:\n+\t  case RETURN:\n+\t  case USE:\n+\t  case CLOBBER:\n+\t    return !0;\n+\t    break;\n+\t  case ASM_INPUT:\n+\t    /* We treat assembler instructions as inherently\n+\t       necessary, and we hope that its operands do not need to\n+\t       be propagated.  */\n+\t    return !0;\n+\t    break;\n+\t  default:\n+\t    return 0;\n+\t  }\n+      default:\n+\t/* Found an impossible insn type.  */\n+\tabort();\n+\tbreak;\n+      }\n+}\n+\n+/* Propagate necessity through REG and SUBREG operands of CURRENT_RTX.\n+   This function is called with for_each_rtx () on necessary\n+   instructions.  The DATA must be a varray of unprocessed\n+   instructions.  */\n+\n+static int\n+propagate_necessity_through_operand (current_rtx, data)\n+     rtx *current_rtx;\n+     void *data;\n+{\n+  rtx x = *current_rtx;\n+  varray_type *unprocessed_instructions = (varray_type *) data;\n+\n+  if (x == NULL_RTX)\n+    return 0;\n+  switch ( GET_CODE (x))\n+    {\n+    case REG:\n+      if (CONVERT_REGISTER_TO_SSA_P (REGNO (x)))\n+\t{\n+\t  rtx insn = VARRAY_RTX (ssa_definition, REGNO (x));\n+\t  if (insn != NULL_RTX && UNNECESSARY_P (insn))\n+\t    {\n+\t      RESURRECT_INSN (insn);\n+\t      VARRAY_PUSH_RTX (*unprocessed_instructions, insn);\n+\t    }\n+\t}\n+      return 0;\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Indicate all insns initially assumed to be unnecessary.  */\n+\n+static void\n+mark_all_insn_unnecessary ()\n+{\n+  rtx insn;\n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    KILL_INSN (insn);\n+}\n+\n+/* Find the label beginning block BB, adding one if necessary.  */\n+\n+static rtx\n+find_block_label (bb)\n+     basic_block bb;\n+{\n+  rtx insn = bb->head;\n+  if (LABEL_P (insn))\n+    return insn;\n+  else\n+    {\n+      rtx new_label = emit_label_before (gen_label_rtx (), insn);\n+      if (insn == bb->head)\n+\tbb->head = new_label;\n+      return new_label;\n+    }\n+}\n+\n+/* Remove INSN, updating its basic block structure.  */\n+\n+static void\n+delete_insn_bb (insn)\n+     rtx insn;\n+{\n+  basic_block bb;\n+  assert (insn != NULL_RTX);\n+  bb = BLOCK_FOR_INSN (insn);\n+  assert (bb != 0);\n+  if (bb->head == bb->end)\n+    {\n+      /* Delete the insn by converting it to a note.  */\n+      PUT_CODE (insn, NOTE);\n+      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+      return;\n+    }\n+  else if (insn == bb->head)\n+    bb->head = NEXT_INSN (insn);\n+  else if (insn == bb->end)\n+    bb->end = PREV_INSN (insn);\n+  delete_insn (insn);\n+}\n+\f\n+/* Perform the dead-code elimination.  */\n+\n+void\n+eliminate_dead_code ()\n+{\n+  int i;\n+  rtx insn;\n+  /* Necessary instructions with operands to explore.  */\n+  varray_type unprocessed_instructions;\n+  /* Map element (b,e) is nonzero if the block is control dependent on\n+     edge.  \"cdbte\" abbreviates control dependent block to edge.  */\n+  control_dependent_block_to_edge_map cdbte;\n+  sbitmap *postdominators;\n+ /* Element I is the immediate postdominator of block I.  */\n+  int *pdom;\n+  struct edge_list *el;\n+\n+  int max_insn_uid = get_max_uid ();\n+\n+  /* Initialize the data structures.  */\n+  mark_all_insn_unnecessary ();\n+  VARRAY_RTX_INIT (unprocessed_instructions, 64,\n+\t\t   \"unprocessed instructions\");\n+  cdbte = control_dependent_block_to_edge_map_create (n_basic_blocks);\n+\n+  /* Prepare for use of BLOCK_NUM ().  */\n+  connect_infinite_loops_to_exit ();\n+   /* Be careful not to clear the added edges.  */\n+  compute_bb_for_insn (max_insn_uid);\n+\n+  /* Compute control dependence.  */\n+  postdominators = sbitmap_vector_alloc (n_basic_blocks, n_basic_blocks);\n+  compute_flow_dominators (NULL, postdominators);\n+  pdom = (int *) xmalloc (n_basic_blocks * sizeof (int));\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    pdom[i] = INVALID_BLOCK;\n+  compute_immediate_postdominators (pdom, postdominators);\n+  /* Assume there is a path from each node to the exit block.  */\n+  for (i = 0; i < n_basic_blocks; ++i)\n+    if (pdom[i] == INVALID_BLOCK)\n+      pdom[i] = EXIT_BLOCK;\n+  sbitmap_vector_free (postdominators);\n+  el = create_edge_list();\n+  find_all_control_dependences (el, pdom, cdbte);\n+\n+  /* Find inherently necessary instructions.  */\n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    if (find_inherently_necessary (insn))\n+      {\n+\tRESURRECT_INSN (insn);\n+\tVARRAY_PUSH_RTX (unprocessed_instructions, insn);\n+      }\n+\n+  /* Propagate necessity using the operands of necessary instructions.  */\n+  while (VARRAY_ACTIVE_SIZE (unprocessed_instructions) > 0)\n+    {\n+      rtx current_instruction;\n+      int edge_number;\n+\n+      current_instruction = VARRAY_TOP_RTX (unprocessed_instructions);\n+      VARRAY_POP (unprocessed_instructions);\n+\n+      /* Make corresponding control dependent edges necessary.  */\n+      /* Assume the only JUMP_INSN is the block's last insn.  It appears\n+\t that the last instruction of the program need not be a\n+\t JUMP_INSN.  */\n+\n+      if (INSN_P (current_instruction)\n+\t  && !JUMP_TABLE_DATA_P (current_instruction))\n+\t{\n+\t  /* Notes and labels contain no interesting operands.  */\n+\t  EXECUTE_IF_CONTROL_DEPENDENT\n+\t    (cdbte, current_instruction, edge_number,\n+\t    {\n+\t      rtx jump_insn = (INDEX_EDGE_PRED_BB (el, edge_number))->end;\n+\t      if (GET_CODE (jump_insn) == JUMP_INSN &&\n+\t\t  UNNECESSARY_P (jump_insn)) {\n+\t\tRESURRECT_INSN (jump_insn);\n+\t\tVARRAY_PUSH_RTX (unprocessed_instructions, jump_insn);\n+\t      }\n+\t    });\n+\n+\t  /* Propagate through the operands.  */\n+\t  for_each_rtx (&current_instruction,\n+\t\t\t&propagate_necessity_through_operand,\n+\t\t\t(PTR) &unprocessed_instructions);\n+\n+\t}\n+    }\n+\n+  /* Remove the unnecessary instructions.  */\n+  EXECUTE_IF_UNNECESSARY (insn,\n+  {\n+    if (any_condjump_p (insn))\n+      {\n+      /* Convert unnecessary conditional insn to an unconditional\n+\t jump to immediate postdominator block.  */\n+\trtx old_label = JUMP_LABEL (insn);\n+\tint pdom_block_number =\n+\t  find_pdom (pdom, BLOCK_FOR_INSN (insn))->index;\n+\n+\t/* Prevent the conditional jump's label from being deleted so\n+\t   we do not have to modify the basic block structure.  */\n+\t++LABEL_NUSES (old_label);\n+\n+\tif (pdom_block_number != EXIT_BLOCK\n+\t    && pdom_block_number != INVALID_BLOCK)\n+\t  {\n+\t    rtx lbl = find_block_label (BASIC_BLOCK (pdom_block_number));\n+\t    rtx new_jump = emit_jump_insn_before (gen_jump (lbl), insn);\n+\t    \n+\t    /* Let jump know that label is in use.  */\n+\t    JUMP_LABEL (new_jump) = lbl;\n+\t    ++LABEL_NUSES (lbl);\n+\n+\t    delete_insn_bb (insn);\n+\n+\t    /* A conditional branch is unnecessary if and only if any\n+\t       block control-dependent on it is unnecessary.  Thus,\n+\t       any phi nodes in these unnecessary blocks are also\n+\t       removed and these nodes need not be updated.  */\n+\n+\t    /* A barrier must follow any unconditional jump.  Barriers\n+\t       are not in basic blocks so this must occur after\n+\t       deleting the conditional jump.  */\n+\t    emit_barrier_after (new_jump);\n+\t  }\n+\telse\n+\t  /* The block drops off the end of the function and the\n+\t     ending conditional jump is not needed.  */\n+\t  delete_insn_bb (insn);\n+      }\n+    else if (!JUMP_P (insn))\n+      delete_insn_bb (insn);\n+  });\n+  \n+  /* Release allocated memory.  */\n+  for (insn = get_insns (); insn != NULL_RTX; insn = NEXT_INSN (insn))\n+    RESURRECT_INSN (insn);\n+  assert (VARRAY_ACTIVE_SIZE(unprocessed_instructions) == 0);\n+  VARRAY_FREE (unprocessed_instructions);\n+  control_dependent_block_to_edge_map_free (cdbte);\n+  free ((PTR) pdom);\n+  free_edge_list (el);\n+}"}, {"sha": "3b5539e83192137cc427fc043ee361ac0e0bc46a", "filename": "gcc/flow.c", "status": "modified", "additions": 170, "deletions": 5, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -136,6 +136,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"recog.h\"\n #include \"insn-flags.h\"\n #include \"expr.h\"\n+#include \"ssa.h\"\n \n #include \"obstack.h\"\n #include \"splay-tree.h\"\n@@ -308,6 +309,20 @@ struct propagate_block_info\n   int flags;\n };\n \n+/* Store the data structures necessary for depth-first search. */\n+struct depth_first_search_dsS {\n+  /* stack for backtracking during the algorithm */\n+  basic_block *stack;\n+\n+  /* number of edges in the stack.  That is, positions 0, ..., sp-1\n+     have edges. */\n+  unsigned int sp;\n+\n+  /* record of basic blocks already seen by depth-first search */\n+  sbitmap visited_blocks;\n+};\n+typedef struct depth_first_search_dsS *depth_first_search_ds;\n+\n /* Forward declarations */\n static int count_basic_blocks\t\tPARAMS ((rtx));\n static void find_basic_blocks_1\t\tPARAMS ((rtx));\n@@ -398,6 +413,14 @@ static int flow_loop_nested_p\t\tPARAMS ((struct loop *, struct loop *));\n static int flow_loop_exits_find\t\tPARAMS ((const sbitmap, edge **));\n static int flow_loop_nodes_find\tPARAMS ((basic_block, basic_block, sbitmap));\n static int flow_depth_first_order_compute PARAMS ((int *, int *));\n+static void flow_dfs_compute_reverse_init\n+  PARAMS ((depth_first_search_ds));\n+static void flow_dfs_compute_reverse_add_bb\n+  PARAMS ((depth_first_search_ds, basic_block));\n+static basic_block flow_dfs_compute_reverse_execute\n+  PARAMS ((depth_first_search_ds));\n+static void flow_dfs_compute_reverse_finish\n+  PARAMS ((depth_first_search_ds));\n static basic_block flow_loop_pre_header_find PARAMS ((basic_block, const sbitmap *));\n static void flow_loop_tree_node_add\tPARAMS ((struct loop *, struct loop *));\n static void flow_loops_tree_build\tPARAMS ((struct loops *));\n@@ -3741,7 +3764,7 @@ init_propagate_block_info (bb, live, local_set, flags)\n \t    && GET_CODE (SET_DEST (PATTERN (insn))) == MEM)\n \t  {\n \t    rtx mem = SET_DEST (PATTERN (insn));\n-\n+\t    \n \t    if (XEXP (mem, 0) == frame_pointer_rtx\n \t\t|| (GET_CODE (XEXP (mem, 0)) == PLUS\n \t\t    && XEXP (XEXP (mem, 0), 0) == frame_pointer_rtx\n@@ -6254,7 +6277,6 @@ compute_immediate_postdominators (idom, postdominators)\n      sbitmap *postdominators;\n {\n   compute_immediate_dominators (idom, postdominators);\n-  return;\n }\n \n /* Recompute register set/reference counts immediately prior to register\n@@ -6888,7 +6910,6 @@ verify_edge_list (f, elist)\n \n /* This routine will determine what, if any, edge there is between\n    a specified predecessor and successor.  */\n-\n int\n find_edge_index (edge_list, pred, succ)\n      struct edge_list *edge_list;\n@@ -6984,8 +7005,44 @@ add_noreturn_fake_exit_edges ()\n       make_edge (NULL, BASIC_BLOCK (x), EXIT_BLOCK_PTR, EDGE_FAKE);\n }\n \n-/* Redirect an edge's successor from one block to another.  */\n+/* This function adds a fake edge between any infinite loops to the\n+   exit block.  Some optimizations require a path from each node to\n+   the exit node.\n \n+   See also Morgan, Figure 3.10, pp. 82-83.\n+\n+   The current implementation is ugly, not attempting to minimize the\n+   number of inserted fake edges.  To reduce the number of fake edges\n+   to insert, add fake edges from _innermost_ loops containing only\n+   nodes not reachable from the exit block. */\n+void\n+connect_infinite_loops_to_exit ()\n+{\n+  basic_block unvisited_block;\n+\n+  /* Perform depth-first search in the reverse graph to find nodes\n+     reachable from the exit block. */\n+  struct depth_first_search_dsS dfs_ds;\n+\n+  flow_dfs_compute_reverse_init (&dfs_ds);\n+  flow_dfs_compute_reverse_add_bb (&dfs_ds, EXIT_BLOCK_PTR);\n+  \n+  /* Repeatedly add fake edges, updating the unreachable nodes. */\n+  while (1)\n+    {\n+      unvisited_block = flow_dfs_compute_reverse_execute (&dfs_ds);\n+      if (!unvisited_block)\n+\tbreak;\n+      make_edge (NULL, unvisited_block, EXIT_BLOCK_PTR, EDGE_FAKE);\n+      flow_dfs_compute_reverse_add_bb (&dfs_ds, unvisited_block);\n+    }\n+\n+  flow_dfs_compute_reverse_finish (&dfs_ds);\n+\n+  return;\n+}\n+\n+/* Redirect an edge's successor from one block to another.  */\n void\n redirect_edge_succ (e, new_succ)\n      edge e;\n@@ -7005,7 +7062,6 @@ redirect_edge_succ (e, new_succ)\n }\n \n /* Redirect an edge's predecessor from one block to another.  */\n-\n void\n redirect_edge_pred (e, new_pred)\n      edge e;\n@@ -7427,6 +7483,115 @@ flow_depth_first_order_compute (dfs_order, rc_order)\n }\n \n \n+/* Compute the depth first search order on the _reverse_ graph and\n+   store in the array DFS_ORDER, marking the nodes visited in VISITED.\n+   Returns the number of nodes visited.\n+\n+   The computation is split into three pieces:\n+\n+   flow_dfs_compute_reverse_init () creates the necessary data\n+   structures.\n+\n+   flow_dfs_compute_reverse_add_bb () adds a basic block to the data\n+   structures.  The block will start the search.\n+\n+   flow_dfs_compute_reverse_execute () continues (or starts) the\n+   search using the block on the top of the stack, stopping when the\n+   stack is empty.\n+\n+   flow_dfs_compute_reverse_finish () destroys the necessary data\n+   structures.\n+\n+   Thus, the user will probably call ..._init(), call ..._add_bb() to\n+   add a beginning basic block to the stack, call ..._execute(),\n+   possibly add another bb to the stack and again call ..._execute(),\n+   ..., and finally call _finish(). */\n+\n+/* Initialize the data structures used for depth-first search on the\n+   reverse graph.  If INITIALIZE_STACK is nonzero, the exit block is\n+   added to the basic block stack.  DATA is the current depth-first\n+   search context.  If INITIALIZE_STACK is non-zero, there is an\n+   element on the stack.  */\n+\n+static void\n+flow_dfs_compute_reverse_init (data)\n+     depth_first_search_ds data;\n+{\n+  /* Allocate stack for back-tracking up CFG.  */\n+  data->stack =\n+    (basic_block *) xmalloc ((n_basic_blocks - (INVALID_BLOCK+1)) \n+\t\t\t     * sizeof (basic_block));\n+  data->sp = 0;\n+\n+  /* Allocate bitmap to track nodes that have been visited.  */\n+  data->visited_blocks \n+    = sbitmap_alloc (n_basic_blocks - (INVALID_BLOCK + 1));\n+\n+  /* None of the nodes in the CFG have been visited yet.  */\n+  sbitmap_zero (data->visited_blocks);\n+\n+  return;\n+}\n+\n+/* Add the specified basic block to the top of the dfs data\n+   structures.  When the search continues, it will start at the\n+   block. */\n+\n+static void\n+flow_dfs_compute_reverse_add_bb (data, bb)\n+     depth_first_search_ds data;\n+     basic_block bb;\n+{\n+  data->stack[data->sp++] = bb;\n+  return;\n+}\n+\n+/* Continue the depth-first search through the reverse graph starting\n+   with the block at the stack's top and ending when the stack is\n+   empty.  Visited nodes are marked.  Returns an unvisited basic\n+   block, or NULL if there is none available.  */\n+static basic_block\n+flow_dfs_compute_reverse_execute (data)\n+     depth_first_search_ds data;\n+{\n+  basic_block bb;\n+  edge e;\n+  int i;\n+\n+  while (data->sp > 0)\n+    {\n+      bb = data->stack[--data->sp];\n+\n+      /* Mark that we have visited this node. */\n+      if (!TEST_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK+1)))\n+\t{\n+\t  SET_BIT (data->visited_blocks, bb->index - (INVALID_BLOCK+1));\n+\n+\t  /* Perform depth-first search on adjacent vertices. */\n+\t  for (e = bb->pred; e; e = e->pred_next)\n+\t    flow_dfs_compute_reverse_add_bb (data, e->src);\n+\t}\n+    }\n+\n+  /* Determine if there are unvisited basic blocks. */\n+  for (i = n_basic_blocks - (INVALID_BLOCK+1); --i >= 0; )\n+    if (!TEST_BIT (data->visited_blocks, i))\n+      return BASIC_BLOCK (i + (INVALID_BLOCK+1));\n+  return NULL;\n+}\n+\n+/* Destroy the data structures needed for depth-first search on the\n+   reverse graph. */\n+\n+static void\n+flow_dfs_compute_reverse_finish (data)\n+     depth_first_search_ds data;\n+{\n+  free (data->stack);\n+  sbitmap_free (data->visited_blocks);\n+  return;\n+}\n+\n /* Return the block for the pre-header of the loop with header\n    HEADER where DOM specifies the dominator information.  Return NULL if\n    there is no pre-header.  */"}, {"sha": "912428ba9eef9cf97b47ceb579ce1eae54b2576e", "filename": "gcc/invoke.texi", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -168,7 +168,7 @@ in the following sections.\n -falign-functions=@var{n}  -falign-labels=@var{n}  -falign-loops=@var{n} \n -falign-jumps=@var{n}  -fbranch-probabilities  \n -fcaller-saves  -fcse-follow-jumps  -fcse-skip-blocks\n--fdelayed-branch  -fdelete-null-pointer-checks -fexpensive-optimizations\n+-fdce -fdelayed-branch  -fdelete-null-pointer-checks -fexpensive-optimizations\n -ffast-math  -ffloat-store  -fforce-addr  -fforce-mem -fno-math-errno\n -fdata-sections  -ffunction-sections  -fgcse \n -finline-functions  -finline-limit=@var{n}  -fkeep-inline-functions\n@@ -2900,9 +2900,12 @@ If @var{n} is not specified, use a machine-dependent default.\n @item -fssa\n Perform optimizations in static single assignment form.  Each function's\n flow graph is translated into SSA form, optimizations are performed, and\n-the flow graph is translated back from SSA form.  (Currently, no\n-SSA-based optimizations are implemented, but converting into and out of\n-SSA form is not an invariant operation, and generated code may differ.)\n+the flow graph is translated back from SSA form.  User's should not\n+specify this option, since it is not yet ready for production use.\n+\n+@item -fdce\n+Perform dead-code elimination in SSA form.  Requires @samp{-fssa}.  Like\n+@samp{-fssa}, this is an experimental feature.\n \n @item -fsingle-precision-constant\n Treat floating point constant as single precision constant instead of"}, {"sha": "41caa802be6b9187f9e85f691d4ea4ee2214fe44", "filename": "gcc/rtl.h", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -148,7 +148,9 @@ typedef struct rtx_def\n      together with the preceding insn.  Valid only within sched.\n      1 in an INSN, JUMP_INSN, or CALL_INSN if insn is in a delay slot and\n      from the target of a branch.  Valid from reorg until end of compilation;\n-     cleared before used.  */\n+     cleared before used.\n+     1 in an INSN if this insn is dead code.  Valid only during\n+     dead-code elimination phase; cleared before use. */\n   unsigned int in_struct : 1;\n   /* 1 if this rtx is used.  This is used for copying shared structure.\n      See `unshare_all_rtl'.\n@@ -202,10 +204,26 @@ typedef struct rtvec_def{\n #define GET_NUM_ELEM(RTVEC)\t\t((RTVEC)->num_elem)\n #define PUT_NUM_ELEM(RTVEC, NUM)\t((RTVEC)->num_elem = (NUM))\n \n-/* 1 if X is a REG.  */\n-\n+/* Predicate yielding nonzero iff X is an rtl for a register.  */\n #define REG_P(X) (GET_CODE (X) == REG)\n \n+/* Predicate yielding nonzero iff X is a label insn.  */\n+#define LABEL_P(X) (GET_CODE (X) == CODE_LABEL)\n+\n+/* Predicate yielding nonzero iff X is a jump insn.  */\n+#define JUMP_P(X) (GET_CODE (X) == JUMP_INSN)\n+\n+/* Predicate yielding nonzero iff X is a note insn.  */\n+#define NOTE_P(X) (GET_CODE (X) == NOTE)\n+\n+/* Predicate yielding nonzero iff X is a barrier insn.  */\n+#define BARRIER_P(X) (GET_CODE (X) == BARRIER)\n+\n+/* Predicate yielding nonzero iff X is a data for a jump table.  */\n+#define JUMP_TABLE_DATA_P(INSN) \\\n+  (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n+\t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n+\n /* 1 if X is a constant value that is an integer.  */\n \n #define CONSTANT_P(X)   \\\n@@ -374,6 +392,9 @@ extern void rtvec_check_failed_bounds PARAMS ((rtvec, int,\n    delay slots, i.e., it is an annulled branch.   */\n #define INSN_ANNULLED_BRANCH_P(INSN) ((INSN)->unchanging)\n \n+/* 1 if insn is a dead code.  Valid only for dead-code elimination phase. */\n+#define INSN_DEAD_CODE_P(INSN) ((INSN)->in_struct)\n+\n /* 1 if insn is in a delay slot and is from the target of the branch.  If\n    the branch insn has INSN_ANNULLED_BRANCH_P set, this insn should only be\n    executed if the branch is taken.  For annulled branches with this bit"}, {"sha": "bb4bda71aab2ef71a02f0ddb498f0cb85217471e", "filename": "gcc/ssa.c", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.c?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -46,6 +46,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n+#include \"ssa.h\"\n \n /* We cannot use <assert.h> in GCC source, since that would include\n    GCC's assert.h, which may not be compatible with the host compiler.  */\n@@ -91,24 +92,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    left in for a limited time only, as a debugging tool until the\n    coalescing algorithm is validated.  */\n \n-/* All pseudo-registers (having register number >=\n-   FIRST_PSEUDO_REGISTER) and hard registers satisfying\n-   CONVERT_HARD_REGISTER_TO_SSA_P are converted to SSA form.  */\n-\n-/* Given a hard register number REG_NO, return nonzero if and only if\n-   the register should be converted to SSA.  */\n-\n-#ifndef CONVERT_HARD_REGISTER_TO_SSA_P\n-#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) (0) /* default of no hard registers */\n-#endif /* CONVERT_HARD_REGISTER_TO_SSA_P  */\n-\n-/* Given a register number REG_NO, return nonzero if and only if the\n-   register should be converted to SSA.  */\n-\n-#define CONVERT_REGISTER_TO_SSA_P(REG_NO)\t\\\n-\t((!HARD_REGISTER_NUM_P (REG_NO)) || \\\n-\t (CONVERT_HARD_REGISTER_TO_SSA_P (REG_NO)))\n-\n static int conservative_reg_partition;\n \n /* This flag is set when the CFG is in SSA form.  */\n@@ -152,20 +135,20 @@ struct ssa_rename_from_hash_table_data {\n   partition reg_partition;\n };\n \n-void ssa_rename_from_initialize\n+static void ssa_rename_from_initialize\n   PARAMS ((void));\n-rtx ssa_rename_from_lookup\n+static rtx ssa_rename_from_lookup\n   PARAMS ((int reg));\n-unsigned int original_register\n+static unsigned int original_register\n   PARAMS ((unsigned int regno));\n-void ssa_rename_from_insert\n+static void ssa_rename_from_insert\n   PARAMS ((unsigned int reg, rtx r));\n-void ssa_rename_from_free\n+static void ssa_rename_from_free\n   PARAMS ((void));\n typedef int (*srf_trav) PARAMS ((int regno, rtx r, sbitmap canonical_elements, partition reg_partition));\n static void ssa_rename_from_traverse\n   PARAMS ((htab_trav callback_function, sbitmap canonical_elements, partition reg_partition));\n-static void ssa_rename_from_print\n+/*static Avoid warnign message.  */ void ssa_rename_from_print\n   PARAMS ((void));\n static int ssa_rename_from_print_1\n   PARAMS ((void **slot, void *data));\n@@ -299,7 +282,7 @@ ssa_rename_to_insert(reg, r)\n \n /* Prepare ssa_rename_from for use.  */\n \n-void\n+static void\n ssa_rename_from_initialize ()\n {\n   /* We use an arbitrary initial hash table size of 64.  */\n@@ -312,7 +295,7 @@ ssa_rename_from_initialize ()\n /* Find the REG entry in ssa_rename_from.  Return NULL_RTX if no entry is\n    found.  */\n \n-rtx\n+static rtx\n ssa_rename_from_lookup (reg)\n      int reg;\n {\n@@ -329,7 +312,7 @@ ssa_rename_from_lookup (reg)\n    the register is a pseudo, return the original register's number.\n    Otherwise, return this register number REGNO.  */\n \n-unsigned int\n+static unsigned int\n original_register (regno)\n      unsigned int regno;\n {\n@@ -339,7 +322,7 @@ original_register (regno)\n \n /* Add mapping from R to REG to ssa_rename_from even if already present.  */\n \n-void\n+static void\n ssa_rename_from_insert (reg, r)\n      unsigned int reg;\n      rtx r;\n@@ -359,7 +342,7 @@ ssa_rename_from_insert (reg, r)\n    CANONICAL_ELEMENTS and REG_PARTITION pass data needed by the only\n    current use of this function.  */\n \n-void\n+static void\n ssa_rename_from_traverse (callback_function,\n \t\t\t  canonical_elements, reg_partition)\n      htab_trav callback_function;\n@@ -374,15 +357,16 @@ ssa_rename_from_traverse (callback_function,\n \n /* Destroy ssa_rename_from.  */\n \n-void\n+static void\n ssa_rename_from_free ()\n {\n   htab_delete (ssa_rename_from_ht);\n }\n \n /* Print the contents of ssa_rename_from.  */\n \n-static void\n+/* static  Avoid erroneous error message.  */\n+void\n ssa_rename_from_print ()\n {\n   printf (\"ssa_rename_from's hash table contents:\\n\");\n@@ -1146,9 +1130,6 @@ rename_registers (nregs, idom)\n      int nregs;\n      int *idom;\n {\n-  int reg;\n-  int mach_mode;\n-\n   VARRAY_RTX_INIT (ssa_definition, nregs * 3, \"ssa_definition\");\n   VARRAY_RTX_INIT (ssa_uses, nregs * 3, \"ssa_uses\");\n   ssa_rename_from_initialize ();"}, {"sha": "463fef8b60cabde1f2d86e57448e73a1626aea88", "filename": "gcc/ssa.h", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Fssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fssa.h?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -0,0 +1,64 @@\n+/* Static Single Assignment (SSA) definitions for GNU C-Compiler\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Written by Jeffrey D. Oldham <oldham@codesourcery.com>.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* Main SSA routines.  */\n+extern void convert_to_ssa\t\tPARAMS ((void));\n+extern void convert_from_ssa\t\tPARAMS ((void));\n+typedef int (*successor_phi_fn)         PARAMS ((rtx, int, int, void *));\n+extern int for_each_successor_phi       PARAMS ((basic_block bb,\n+\t\t\t\t\t\t successor_phi_fn,\n+\t\t\t\t\t\t void *));\n+\n+/* Optimizations.  */\n+/* In dce.c */\n+extern void eliminate_dead_code\t\tPARAMS ((void));\n+\n+/* SSA definitions and uses.  */\n+/* This flag is set when the CFG is in SSA form.  */\n+extern int in_ssa_form;\n+\n+/* Element I is the single instruction that sets register I.  */\n+extern varray_type ssa_definition;\n+\n+/* Element I is an INSN_LIST of instructions that use register I.  */\n+extern varray_type ssa_uses;\n+\n+\n+/* Specify which hard registers should be converted.  */\n+\n+/* All pseudo-registers (having register number >=\n+   FIRST_PSEUDO_REGISTER) and hard registers satisfying\n+   CONVERT_HARD_REGISTER_TO_SSA_P are converted to SSA form.  */\n+\n+/* Given a hard register number REG_NO, return nonzero if and only if\n+   the register should be converted to SSA.  */\n+\n+#ifndef CONVERT_HARD_REGISTER_TO_SSA_P\n+#define CONVERT_HARD_REGISTER_TO_SSA_P(REG_NO) (0) /* default of no hard registers */\n+#endif /* CONVERT_HARD_REGISTER_TO_SSA_P  */\n+\n+/* Given a register number REG_NO, return nonzero if and only if the\n+   register should be converted to SSA.  */\n+\n+#define CONVERT_REGISTER_TO_SSA_P(REG_NO)\t\\\n+\t((!HARD_REGISTER_NUM_P (REG_NO)) || \\\n+\t (CONVERT_HARD_REGISTER_TO_SSA_P (REG_NO)))"}, {"sha": "19a3bb26e3bd4d8389105c7f02bf8e6c8f4a7705", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -68,6 +68,7 @@ DEFTIMEVAR (TV_REORDER_BLOCKS        , \"reorder blocks\")\n DEFTIMEVAR (TV_SHORTEN_BRANCH        , \"shorten branches\")\n DEFTIMEVAR (TV_REG_STACK             , \"reg stack\")\n DEFTIMEVAR (TV_TO_SSA                , \"convert to SSA\")\n+DEFTIMEVAR (TV_DEAD_CODE_ELIM        , \"eliminate dead code\")\n DEFTIMEVAR (TV_FROM_SSA              , \"convert from SSA\")\n DEFTIMEVAR (TV_FINAL                 , \"final\")\n DEFTIMEVAR (TV_SYMOUT                , \"symout\")"}, {"sha": "b13e580ce59141c50c0a8a8d522b1dad5ba0731c", "filename": "gcc/toplev.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b53978a3ee3998863c0f942b9b4c40d0e36d2bc7/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=b53978a3ee3998863c0f942b9b4c40d0e36d2bc7", "patch": "@@ -63,6 +63,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"regs.h\"\n #include \"timevar.h\"\n #include \"diagnostic.h\"\n+#include \"ssa.h\"\n \n #ifndef ACCUMULATE_OUTGOING_ARGS\n #define ACCUMULATE_OUTGOING_ARGS 0\n@@ -259,6 +260,7 @@ enum dump_file_index\n   DFI_cse,\n   DFI_addressof,\n   DFI_ssa,\n+  DFI_dce,\n   DFI_ussa,\n   DFI_gcse,\n   DFI_loop,\n@@ -291,7 +293,7 @@ enum dump_file_index\n    Remaining -d letters:\n \n \t\"       h      o q   u     \"\n-\t\"       H  K   OPQ  TUVWXYZ\"\n+\t\"       H  K   OPQ  TUVW YZ\"\n */\n \n struct dump_file_info dump_file[DFI_MAX] = \n@@ -302,6 +304,7 @@ struct dump_file_info dump_file[DFI_MAX] =\n   { \"cse\",\t's', 0, 0, 0 },\n   { \"addressof\", 'F', 0, 0, 0 },\n   { \"ssa\",\t'e', 1, 0, 0 },\n+  { \"dce\",\t'X', 1, 0, 0 },\n   { \"ussa\",\t'e', 1, 0, 0 },\t/* Yes, duplicate enable switch.  */\n   { \"gcse\",\t'G', 1, 0, 0 },\n   { \"loop\",\t'L', 1, 0, 0 },\n@@ -786,6 +789,9 @@ int flag_gnu_linker = 1;\n /* Enable SSA.  */\n int flag_ssa = 0;\n \n+/* Enable dead code elimination. */\n+int flag_dce = 0;\n+\n /* Tag all structures with __attribute__(packed) */\n int flag_pack_struct = 0;\n \n@@ -1094,6 +1100,8 @@ lang_independent_options f_options[] =\n    \"Instrument function entry/exit with profiling calls\"},\n   {\"ssa\", &flag_ssa, 1,\n    \"Enable SSA optimizations\" },\n+  {\"dce\", &flag_dce, 1,\n+   \"Enable dead code elimination\" },\n   {\"leading-underscore\", &flag_leading_underscore, 1,\n    \"External symbols have a leading underscore\" },\n   {\"ident\", &flag_no_ident, 0,\n@@ -2976,13 +2984,25 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_ssa, print_rtl_with_bb, insns);\n       timevar_pop (TV_TO_SSA);\n \n-      /* Currently, there's nothing to do in SSA form.  */\n-\n       /* The SSA implementation uses basic block numbers in its phi\n \t nodes.  Thus, changing the control-flow graph or the basic\n \t blocks, e.g., calling find_basic_blocks () or cleanup_cfg (),\n \t may cause problems.  */\n \n+      if (flag_dce)\n+\t{\n+\t  /* Remove dead code. */\n+\n+\t  timevar_push (TV_DEAD_CODE_ELIM);\n+\t  open_dump_file (DFI_dce, decl);\n+\n+\t  insns = get_insns ();\n+\t  eliminate_dead_code();\n+  \n+\t  close_dump_file (DFI_dce, print_rtl_with_bb, insns);\n+\t  timevar_pop (TV_DEAD_CODE_ELIM);\n+\t}\n+\n       /* Convert from SSA form.  */\n \n       timevar_push (TV_FROM_SSA);"}]}