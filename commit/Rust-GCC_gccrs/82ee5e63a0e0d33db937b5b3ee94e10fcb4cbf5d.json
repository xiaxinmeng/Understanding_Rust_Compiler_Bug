{"sha": "82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJlZTVlNjNhMGUwZDMzZGI5MzdiNWIzZWU5NGUxMGZjYjRjYmY1ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-19T12:45:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-19T12:45:50Z"}, "message": "Fix lossage caused by applying old version of my previous patch.\n\nFrom-SVN: r33254", "tree": {"sha": "ef8167d399bcefb98ccb39e50f46c63d3d94878a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef8167d399bcefb98ccb39e50f46c63d3d94878a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d/comments", "author": null, "committer": null, "parents": [{"sha": "b9297e70ac910e77013c5700a56f652881da29bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9297e70ac910e77013c5700a56f652881da29bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9297e70ac910e77013c5700a56f652881da29bd"}], "stats": {"total": 17, "additions": 9, "deletions": 8}, "files": [{"sha": "91da78b3f954d98d0f97d10816cb47281ce3fd60", "filename": "gcc/loop.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "patch": "@@ -308,8 +308,8 @@ static int replace_loop_reg PARAMS ((rtx *, void *));\n static void note_reg_stored PARAMS ((rtx, rtx, void *));\n static void try_copy_prop PARAMS ((const struct loop *, rtx, unsigned int));\n static int replace_label PARAMS ((rtx *, void *));\n-static void check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n-static void check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n+static rtx check_insn_for_givs PARAMS((struct loop *, rtx, int, int));\n+static rtx check_insn_for_bivs PARAMS((struct loop *, rtx, int, int));\n \n typedef struct rtx_and_int {\n   rtx r;\n@@ -3730,7 +3730,7 @@ for_each_insn_in_loop (loop, fncall)\n        p != NULL_RTX;\n        p = next_insn_in_loop (loop, p))\n     {\n-      fncall (loop, p, maybe_multiple, not_every_iteration);\n+      p = fncall (loop, p, not_every_iteration, not_every_iteration);\n \n       /* Past CODE_LABEL, we get to insns that may be executed multiple\n          times.  The only way we can be sure that they can't is if every\n@@ -5068,7 +5068,7 @@ strength_reduce (loop, insn_count, unroll_p, bct_p)\n }\n \f\n /*Record all basic induction variables calculated in the insn.  */\n-static void\n+static rtx\n check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n      struct loop *loop;\n      rtx p;\n@@ -5112,12 +5112,13 @@ check_insn_for_bivs (loop, p, not_every_iteration, maybe_multiple)\n \t    REG_IV_TYPE (REGNO (dest_reg)) = NOT_BASIC_INDUCT;\n \t}\n     }\n+  return p;\n }\n \f\n /* Record all givs calculated in the insn.  \n    A register is a giv if: it is only set once, it is a function of a\n    biv and a constant (or invariant), and it is not a biv.  */\n-static void\n+static rtx\n check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n      struct loop *loop;\n      rtx p;\n@@ -5141,7 +5142,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n \n       dest_reg = SET_DEST (set);\n       if (REGNO (dest_reg) < FIRST_PSEUDO_REGISTER)\n-\treturn;\n+\treturn p;\n \n       if (/* SET_SRC is a giv.  */\n \t  (general_induction_var (loop, SET_SRC (set), &src_reg, &add_val,\n@@ -5196,7 +5197,7 @@ check_insn_for_givs (loop, p, not_every_iteration, maybe_multiple)\n   if (GET_CODE (p) == INSN || GET_CODE (p) == JUMP_INSN\n     || GET_CODE (p) == CODE_LABEL)\n     update_giv_derive (loop, p);\n-\n+  return p;\n }\n \f\n /* Return 1 if X is a valid source for an initial value (or as value being"}, {"sha": "9c4affb84429443de544cb6fa49a54e3f61aaa74", "filename": "gcc/loop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=82ee5e63a0e0d33db937b5b3ee94e10fcb4cbf5d", "patch": "@@ -247,6 +247,6 @@ void emit_unrolled_add PARAMS ((rtx, rtx, rtx));\n int back_branch_in_range_p PARAMS ((const struct loop *, rtx));\n \n int loop_insn_first_p PARAMS ((rtx, rtx));\n-typedef void (*loop_insn_callback ) PARAMS ((struct loop *, rtx, int, int));\n+typedef rtx (*loop_insn_callback ) PARAMS ((struct loop *, rtx, int, int));\n void for_each_insn_in_loop PARAMS ((struct loop *, loop_insn_callback));\n "}]}