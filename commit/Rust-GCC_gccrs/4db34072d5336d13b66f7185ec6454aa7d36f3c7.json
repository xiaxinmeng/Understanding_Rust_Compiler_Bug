{"sha": "4db34072d5336d13b66f7185ec6454aa7d36f3c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRiMzQwNzJkNTMzNmQxM2I2NmY3MTg1ZWM2NDU0YWE3ZDM2ZjNjNw==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-06-08T03:10:33Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2021-06-08T05:27:47Z"}, "message": "predcom: Enabled by loop vect at O2 [PR100794]\n\nAs PR100794 shows, in the current implementation PRE bypasses\nsome optimization to avoid introducing loop carried dependence\nwhich stops loop vectorizer to vectorize the loop.  At -O2,\nthere is no downstream pass to re-catch this kind of opportunity\nif loop vectorizer fails to vectorize that loop.\n\nThis patch follows Richi's suggestion in the PR, if predcom flag\nisn't set and loop vectorization will enable predcom without any\nunrolling implicitly.  The Power9 SPEC2017 evaluation showed it\ncan speed up 521.wrf_r 3.30% and 554.roms_r 1.08% at very-cheap\ncost model, no remarkable impact at cheap cost model, the build\ntime and size impact is fine (see the PR for the details).\n\nBy the way, I tested another proposal to guard PRE not skip the\noptimization for cheap and very-cheap vect cost models, the\nevaluation results showed it's fine with very cheap cost model,\nbut it can degrade some bmks like 521.wrf_r -9.17% and\n549.fotonik3d_r -2.07% etc.\n\nBootstrapped/regtested on powerpc64le-linux-gnu P9,\nx86_64-redhat-linux and aarch64-linux-gnu.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/100794\n\t* tree-predcom.c (tree_predictive_commoning_loop): Add parameter\n\tallow_unroll_p and only allow unrolling when it's true.\n\t(tree_predictive_commoning): Add parameter allow_unroll_p and\n\tadjust for it.\n\t(run_tree_predictive_commoning): Likewise.\n\t(pass_predcom::gate): Check flag_tree_loop_vectorize and\n\tglobal_options_set.x_flag_predictive_commoning.\n\t(pass_predcom::execute): Adjust for allow_unroll_p.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/100794\n\t* gcc.dg/tree-ssa/pr100794.c: New test.", "tree": {"sha": "39d39c9bbb76efb5359f025fec82787b4fb0fd8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39d39c9bbb76efb5359f025fec82787b4fb0fd8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4db34072d5336d13b66f7185ec6454aa7d36f3c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db34072d5336d13b66f7185ec6454aa7d36f3c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4db34072d5336d13b66f7185ec6454aa7d36f3c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4db34072d5336d13b66f7185ec6454aa7d36f3c7/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "774686d48234401187247ac7f5df41879d8dc34c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/774686d48234401187247ac7f5df41879d8dc34c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/774686d48234401187247ac7f5df41879d8dc34c"}], "stats": {"total": 70, "additions": 54, "deletions": 16}, "files": [{"sha": "6f707ae7fba30826ea69757e7b04ca390eee8de4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr100794.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db34072d5336d13b66f7185ec6454aa7d36f3c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100794.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db34072d5336d13b66f7185ec6454aa7d36f3c7/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100794.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100794.c?ref=4db34072d5336d13b66f7185ec6454aa7d36f3c7", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-vectorize -fdump-tree-pcom-details -fdisable-tree-vect\" } */\n+\n+extern double arr[100];\n+extern double foo (double, double);\n+extern double sum;\n+\n+void\n+test (int i_0, int i_n)\n+{\n+  int i;\n+  for (i = i_0; i < i_n - 1; i++)\n+    {\n+      double a = arr[i];\n+      double b = arr[i + 1];\n+      sum += a * b;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Executing predictive commoning without unrolling\" \"pcom\" } } */"}, {"sha": "ac1674d54861e6dac7ec23469daa2dcc80e99464", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 34, "deletions": 16, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4db34072d5336d13b66f7185ec6454aa7d36f3c7/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4db34072d5336d13b66f7185ec6454aa7d36f3c7/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=4db34072d5336d13b66f7185ec6454aa7d36f3c7", "patch": "@@ -3178,13 +3178,13 @@ insert_init_seqs (class loop *loop, vec<chain_p> chains)\n    applied to this loop.  */\n \n static unsigned\n-tree_predictive_commoning_loop (class loop *loop)\n+tree_predictive_commoning_loop (class loop *loop, bool allow_unroll_p)\n {\n   vec<data_reference_p> datarefs;\n   vec<ddr_p> dependences;\n   struct component *components;\n   vec<chain_p> chains = vNULL;\n-  unsigned unroll_factor;\n+  unsigned unroll_factor = 0;\n   class tree_niter_desc desc;\n   bool unroll = false, loop_closed_ssa = false;\n \n@@ -3272,11 +3272,13 @@ tree_predictive_commoning_loop (class loop *loop)\n       dump_chains (dump_file, chains);\n     }\n \n-  /* Determine the unroll factor, and if the loop should be unrolled, ensure\n-     that its number of iterations is divisible by the factor.  */\n-  unroll_factor = determine_unroll_factor (chains);\n-  unroll = (unroll_factor > 1\n-\t    && can_unroll_loop_p (loop, unroll_factor, &desc));\n+  if (allow_unroll_p)\n+    /* Determine the unroll factor, and if the loop should be unrolled, ensure\n+       that its number of iterations is divisible by the factor.  */\n+    unroll_factor = determine_unroll_factor (chains);\n+\n+  if (unroll_factor > 1)\n+    unroll = can_unroll_loop_p (loop, unroll_factor, &desc);\n \n   /* Execute the predictive commoning transformations, and possibly unroll the\n      loop.  */\n@@ -3319,7 +3321,7 @@ tree_predictive_commoning_loop (class loop *loop)\n /* Runs predictive commoning.  */\n \n unsigned\n-tree_predictive_commoning (void)\n+tree_predictive_commoning (bool allow_unroll_p)\n {\n   class loop *loop;\n   unsigned ret = 0, changed = 0;\n@@ -3328,7 +3330,7 @@ tree_predictive_commoning (void)\n   FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n     if (optimize_loop_for_speed_p (loop))\n       {\n-\tchanged |= tree_predictive_commoning_loop (loop);\n+\tchanged |= tree_predictive_commoning_loop (loop, allow_unroll_p);\n       }\n   free_original_copy_tables ();\n \n@@ -3355,12 +3357,12 @@ tree_predictive_commoning (void)\n /* Predictive commoning Pass.  */\n \n static unsigned\n-run_tree_predictive_commoning (struct function *fun)\n+run_tree_predictive_commoning (struct function *fun, bool allow_unroll_p)\n {\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n-  return tree_predictive_commoning ();\n+  return tree_predictive_commoning (allow_unroll_p);\n }\n \n namespace {\n@@ -3386,11 +3388,27 @@ class pass_predcom : public gimple_opt_pass\n   {}\n \n   /* opt_pass methods: */\n-  virtual bool gate (function *) { return flag_predictive_commoning != 0; }\n-  virtual unsigned int execute (function *fun)\n-    {\n-      return run_tree_predictive_commoning (fun);\n-    }\n+  virtual bool\n+  gate (function *)\n+  {\n+    if (flag_predictive_commoning != 0)\n+      return true;\n+    /* Loop vectorization enables predictive commoning implicitly\n+       only if predictive commoning isn't set explicitly, and it\n+       doesn't allow unrolling.  */\n+    if (flag_tree_loop_vectorize\n+\t&& !global_options_set.x_flag_predictive_commoning)\n+      return true;\n+\n+    return false;\n+  }\n+\n+  virtual unsigned int\n+  execute (function *fun)\n+  {\n+    bool allow_unroll_p = flag_predictive_commoning != 0;\n+    return run_tree_predictive_commoning (fun, allow_unroll_p);\n+  }\n \n }; // class pass_predcom\n "}]}