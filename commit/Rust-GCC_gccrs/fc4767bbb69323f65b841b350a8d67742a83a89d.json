{"sha": "fc4767bbb69323f65b841b350a8d67742a83a89d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM0NzY3YmJiNjkzMjNmNjViODQxYjM1MGE4ZDY3NzQyYTgzYTg5ZA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-07-16T11:52:55Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-07-16T11:52:55Z"}, "message": "unwind-dw2.c (MD_FROB_UPDATE_CONTEXT): Define.\n\n\t* unwind-dw2.c (MD_FROB_UPDATE_CONTEXT): Define.\n\t(uw_update_context_1): Use it.\n\t* config/rs6000/rs6000.c (insn_after_throw): Remove.\n\t(rs6000_aix_emit_builtin_unwind_init): Save $r2 to its location\n\tin parent frame if _Unwind_* called directly instead of through\n\t.plt.\n\t(rs6000_emit_eh_toc_restore): Remove.\n\t(rs6000_emit_prologue): Update stack pointer before doing any saving\n\tif current_function_calls_eh_return.  Generate unwind info for $r2.\n\t(rs6000_emit_epilogue): Restore stack pointer after doing all\n\trestoring if current_function_calls_eh_return.  Restore $r2.\n\t* config/rs6000/rs6000-protos.h (rs6000_emit_eh_toc_restore): Remove.\n\t* config/rs6000/rs6000.md (eh_return): Remove call to\n\trs6000_emit_eh_toc_restore.\n\t* config/rs6000/linux64.h (MD_FROB_UPDATE_CONTEXT): Define.\n\t* config/rs6000/aix.h (MD_FROB_UPDATE_CONTEXT): Define.\n\n\t* gcc.dg/cleanup-8.c: New test.\n\t* gcc.dg/cleanup-9.c: New test.\n\nFrom-SVN: r69450", "tree": {"sha": "da08a4ceb1400ad593f6a055dc2999c204a77e07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da08a4ceb1400ad593f6a055dc2999c204a77e07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc4767bbb69323f65b841b350a8d67742a83a89d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4767bbb69323f65b841b350a8d67742a83a89d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc4767bbb69323f65b841b350a8d67742a83a89d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc4767bbb69323f65b841b350a8d67742a83a89d/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6972c506d47a918744940e9af28a85d67e446090", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6972c506d47a918744940e9af28a85d67e446090", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6972c506d47a918744940e9af28a85d67e446090"}], "stats": {"total": 448, "additions": 332, "deletions": 116}, "files": [{"sha": "027a53f74060ce1f47fb59be081b00f52330c093", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -1,3 +1,22 @@\n+2003-07-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* unwind-dw2.c (MD_FROB_UPDATE_CONTEXT): Define.\n+\t(uw_update_context_1): Use it.\n+\t* config/rs6000/rs6000.c (insn_after_throw): Remove.\n+\t(rs6000_aix_emit_builtin_unwind_init): Save $r2 to its location\n+\tin parent frame if _Unwind_* called directly instead of through\n+\t.plt.\n+\t(rs6000_emit_eh_toc_restore): Remove.\n+\t(rs6000_emit_prologue): Update stack pointer before doing any saving\n+\tif current_function_calls_eh_return.  Generate unwind info for $r2.\n+\t(rs6000_emit_epilogue): Restore stack pointer after doing all\n+\trestoring if current_function_calls_eh_return.  Restore $r2.\n+\t* config/rs6000/rs6000-protos.h (rs6000_emit_eh_toc_restore): Remove.\n+\t* config/rs6000/rs6000.md (eh_return): Remove call to\n+\trs6000_emit_eh_toc_restore.\n+\t* config/rs6000/linux64.h (MD_FROB_UPDATE_CONTEXT): Define.\n+\t* config/rs6000/aix.h (MD_FROB_UPDATE_CONTEXT): Define.\n+\n 2003-07-15  Jakub Jelinek  <jakub@redhat.com>\n \n \t* expr.c (emit_block_move): Don't move anything if size is const 0."}, {"sha": "ec6a350f157a24744a8f3fc91a910625fd500f55", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -209,6 +209,38 @@\n    So we have to squirrel it away with this.  */\n #define SETUP_FRAME_ADDRESSES() rs6000_aix_emit_builtin_unwind_init ()\n \n+/* If the current unwind info (FS) does not contain explicit info\n+   saving R2, then we have to do a minor amount of code reading to\n+   figure out if it was saved.  The big problem here is that the\n+   code that does the save/restore is generated by the linker, so\n+   we have no good way to determine at compile time what to do.  */\n+\n+#ifdef __powerpc64__\n+#define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunsigned int *insn\t\t\t\t\t\t\\\n+\t  = (unsigned int *)\t\t\t\t\t\t\\\n+\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n+\tif (*insn == 0xE8410028)\t\t\t\t\t\\\n+\t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#else\n+#define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunsigned int *insn\t\t\t\t\t\t\\\n+\t  = (unsigned int *)\t\t\t\t\t\t\\\n+\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n+\tif (*insn == 0x80410014)\t\t\t\t\t\\\n+\t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 20);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+#endif\n+\n #define PROFILE_HOOK(LABEL)   output_profile_hook (LABEL)\n \n /* Print subsidiary information on the compiler version in use.  */"}, {"sha": "5d7c74df266cd4f83c81f181d019e88b8a24b82c", "filename": "gcc/config/rs6000/linux64.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Flinux64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Flinux64.h?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -553,6 +553,24 @@ enum { SIGNAL_FRAMESIZE = 64 };\n \n #ifdef __powerpc64__\n \n+/* If the current unwind info (FS) does not contain explicit info\n+   saving R2, then we have to do a minor amount of code reading to\n+   figure out if it was saved.  The big problem here is that the\n+   code that does the save/restore is generated by the linker, so\n+   we have no good way to determine at compile time what to do.  */\n+\n+#define MD_FROB_UPDATE_CONTEXT(CTX, FS)\t\t\t\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if ((FS)->regs.reg[2].how == REG_UNSAVED)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tunsigned int *insn\t\t\t\t\t\t\\\n+\t  = (unsigned int *)\t\t\t\t\t\t\\\n+\t    _Unwind_GetGR ((CTX), LINK_REGISTER_REGNUM);\t\t\\\n+\tif (*insn == 0xE8410028)\t\t\t\t\t\\\n+\t  _Unwind_SetGRPtr ((CTX), 2, (CTX)->cfa + 40);\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  } while (0)\n+\n #define MD_FALLBACK_FRAME_STATE_FOR(CONTEXT, FS, SUCCESS)\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     unsigned char *pc_ = (CONTEXT)->ra;\t\t\t\t\t\\"}, {"sha": "bbdaa6ac6f069193cc16e1c47b3b80215a303648", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -126,7 +126,6 @@ extern int mfcr_operation PARAMS ((rtx, enum machine_mode));\n extern int mtcrf_operation PARAMS ((rtx, enum machine_mode));\n extern int lmw_operation PARAMS ((rtx, enum machine_mode));\n extern struct rtx_def *create_TOC_reference PARAMS ((rtx));\n-extern void rs6000_emit_eh_toc_restore PARAMS ((rtx));\n extern void rs6000_split_altivec_in_gprs (rtx *);\n extern void rs6000_emit_move PARAMS ((rtx, rtx, enum machine_mode));\n extern rtx rs6000_legitimize_address PARAMS ((rtx, rtx, enum machine_mode));"}, {"sha": "8f268974aa5d178a6e7453f603089db4cf99c02d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 53, "deletions": 113, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -10800,132 +10800,40 @@ create_TOC_reference (symbol)\n \t\t gen_rtx_SYMBOL_REF (Pmode, toc_label_name))));\n }\n \n-/* __throw will restore its own return address to be the same as the\n-   return address of the function that the throw is being made to.\n-   This is unfortunate, because we want to check the original\n-   return address to see if we need to restore the TOC.\n-   So we have to squirrel it away here.  \n-   This is used only in compiling __throw and __rethrow. \n+/* If _Unwind_* has been called from within the same module,\n+   toc register is not guaranteed to be saved to 40(1) on function\n+   entry.  Save it there in that case.  */\n \n-   Most of this code should be removed by CSE.  */\n-static rtx insn_after_throw;\n-\n-/* This does the saving...  */\n void\n rs6000_aix_emit_builtin_unwind_init ()\n {\n   rtx mem;\n   rtx stack_top = gen_reg_rtx (Pmode);\n   rtx opcode_addr = gen_reg_rtx (Pmode);\n-\n-  insn_after_throw = gen_reg_rtx (SImode);\n+  rtx opcode = gen_reg_rtx (SImode);\n+  rtx tocompare = gen_reg_rtx (SImode);\n+  rtx no_toc_save_needed = gen_label_rtx ();\n \n   mem = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n   emit_move_insn (stack_top, mem);\n \n-  mem = gen_rtx_MEM (Pmode, \n-\t\t     gen_rtx_PLUS (Pmode, stack_top, \n+  mem = gen_rtx_MEM (Pmode,\n+\t\t     gen_rtx_PLUS (Pmode, stack_top,\n \t\t\t\t   GEN_INT (2 * GET_MODE_SIZE (Pmode))));\n   emit_move_insn (opcode_addr, mem);\n-  emit_move_insn (insn_after_throw, gen_rtx_MEM (SImode, opcode_addr));\n-}\n-\n-/* Emit insns to _restore_ the TOC register, at runtime (specifically\n-   in _eh.o).  Only used on AIX.\n-\n-   The idea is that on AIX, function calls look like this:\n-\tbl  somefunction-trampoline\n-\tlwz r2,20(sp)\n-\n-   and later,\n-\tsomefunction-trampoline:\n-\tstw r2,20(sp)\n-\t ... load function address in the count register ...\n-\tbctr\n-   or like this, if the linker determines that this is not a cross-module call\n-   and so the TOC need not be restored:\n-\tbl  somefunction\n-\tnop\n-   or like this, if the compiler could determine that this is not a\n-   cross-module call:\n-\tbl  somefunction\n-   now, the tricky bit here is that register 2 is saved and restored\n-   by the _linker_, so we can't readily generate debugging information\n-   for it.  So we need to go back up the call chain looking at the\n-   insns at return addresses to see which calls saved the TOC register\n-   and so see where it gets restored from.\n-\n-   Oh, and all this gets done in RTL inside the eh_epilogue pattern,\n-   just before the actual epilogue.\n-\n-   On the bright side, this incurs no space or time overhead unless an\n-   exception is thrown, except for the extra code in libgcc.a.  \n-\n-   The parameter STACKSIZE is a register containing (at runtime)\n-   the amount to be popped off the stack in addition to the stack frame\n-   of this routine (which will be __throw or __rethrow, and so is\n-   guaranteed to have a stack frame).  */\n-\n-void\n-rs6000_emit_eh_toc_restore (stacksize)\n-     rtx stacksize;\n-{\n-  rtx top_of_stack;\n-  rtx bottom_of_stack = gen_reg_rtx (Pmode);\n-  rtx tocompare = gen_reg_rtx (SImode);\n-  rtx opcode = gen_reg_rtx (SImode);\n-  rtx opcode_addr = gen_reg_rtx (Pmode);\n-  rtx mem;\n-  rtx loop_start = gen_label_rtx ();\n-  rtx no_toc_restore_needed = gen_label_rtx ();\n-  rtx loop_exit = gen_label_rtx ();\n-  \n-  mem = gen_rtx_MEM (Pmode, hard_frame_pointer_rtx);\n-  set_mem_alias_set (mem, rs6000_sr_alias_set);\n-  emit_move_insn (bottom_of_stack, mem);\n-\n-  top_of_stack = expand_binop (Pmode, add_optab, \n-\t\t\t       bottom_of_stack, stacksize,\n-\t\t\t       NULL_RTX, 1, OPTAB_WIDEN);\n-\n-  emit_move_insn (tocompare, gen_int_mode (TARGET_32BIT ? 0x80410014 \n+  emit_move_insn (opcode, gen_rtx_MEM (SImode, opcode_addr));\n+  emit_move_insn (tocompare, gen_int_mode (TARGET_32BIT ? 0x80410014\n \t\t\t\t\t   : 0xE8410028, SImode));\n \n-  if (insn_after_throw == NULL_RTX)\n-    abort ();\n-  emit_move_insn (opcode, insn_after_throw);\n-  \n-  emit_note (NOTE_INSN_LOOP_BEG);\n-  emit_label (loop_start);\n-  \n-  do_compare_rtx_and_jump (opcode, tocompare, NE, 1,\n+  do_compare_rtx_and_jump (opcode, tocompare, EQ, 1,\n \t\t\t   SImode, NULL_RTX, NULL_RTX,\n-\t\t\t   no_toc_restore_needed);\n-  \n-  mem = gen_rtx_MEM (Pmode, \n-\t\t     gen_rtx_PLUS (Pmode, bottom_of_stack, \n-\t\t\t\t   GEN_INT (5 * GET_MODE_SIZE (Pmode))));\n-  emit_move_insn (gen_rtx_REG (Pmode, 2), mem);\n-\n-  emit_label (no_toc_restore_needed);\n-  do_compare_rtx_and_jump (top_of_stack, bottom_of_stack, EQ, 1,\n-\t\t\t   Pmode, NULL_RTX, NULL_RTX,\n-\t\t\t   loop_exit);\n-\n-  mem = gen_rtx_MEM (Pmode, bottom_of_stack);\n-  set_mem_alias_set (mem, rs6000_sr_alias_set);\n-  emit_move_insn (bottom_of_stack, mem);\n-  \n-  mem = gen_rtx_MEM (Pmode, \n-\t\t     gen_rtx_PLUS (Pmode, bottom_of_stack, \n-\t\t\t\t   GEN_INT (2 * GET_MODE_SIZE (Pmode))));\n-  emit_move_insn (opcode_addr, mem);\n-  emit_move_insn (opcode, gen_rtx_MEM (SImode, opcode_addr));\n+\t\t\t   no_toc_save_needed);\n \n-  emit_note (NOTE_INSN_LOOP_CONT);\n-  emit_jump (loop_start);\n-  emit_note (NOTE_INSN_LOOP_END);\n-  emit_label (loop_exit);\n+  mem = gen_rtx_MEM (Pmode,\n+\t\t     gen_rtx_PLUS (Pmode, stack_top,\n+\t\t\t\t   GEN_INT (5 * GET_MODE_SIZE (Pmode))));\n+  emit_move_insn (mem, gen_rtx_REG (Pmode, 2));\n+  emit_label (no_toc_save_needed);\n }\n \f\n /* This ties together stack memory (MEM with an alias set of\n@@ -11347,7 +11255,8 @@ rs6000_emit_prologue ()\n \t\t\t|| FP_SAVE_INLINE (info->first_fp_reg_save));\n \n   /* For V.4, update stack before we do any saving and set back pointer.  */\n-  if (info->push_p && DEFAULT_ABI == ABI_V4)\n+  if (info->push_p\n+      && (DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n     {\n       if (info->total_size < 32767)\n \tsp_offset = info->total_size;\n@@ -11575,6 +11484,23 @@ rs6000_emit_prologue ()\n     {\n       unsigned int i, regno;\n \n+      /* In AIX ABI we need to pretend we save r2 here.  */\n+      if (TARGET_AIX)\n+\t{\n+\t  rtx addr, reg, mem;\n+\n+\t  reg = gen_rtx_REG (reg_mode, 2);\n+\t  addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t       GEN_INT (sp_offset + 5 * reg_size));\n+\t  mem = gen_rtx_MEM (reg_mode, addr);\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  insn = emit_move_insn (mem, reg);\n+\t  rs6000_frame_related (insn, frame_ptr_rtx, info->total_size, \n+\t\t\t\tNULL_RTX, NULL_RTX);\n+\t  PATTERN (insn) = gen_blockage ();\n+\t}\n+\n       for (i = 0; ; ++i)\n \t{\n \t  regno = EH_RETURN_DATA_REGNO (i);\n@@ -11633,7 +11559,8 @@ rs6000_emit_prologue ()\n \n   /* Update stack and set back pointer unless this is V.4, \n      for which it was done previously.  */\n-  if (info->push_p && DEFAULT_ABI != ABI_V4)\n+  if (info->push_p\n+      && !(DEFAULT_ABI == ABI_V4 || current_function_calls_eh_return))\n     rs6000_emit_allocate_stack (info->total_size, FALSE);\n \n   /* Set frame pointer, if needed.  */\n@@ -11812,7 +11739,8 @@ rs6000_emit_epilogue (sibcall)\n     }\n   else if (info->push_p)\n     {\n-      if (DEFAULT_ABI == ABI_V4)\n+      if (DEFAULT_ABI == ABI_V4\n+\t  || current_function_calls_eh_return)\n \tsp_offset = info->total_size;\n       else\n \t{\n@@ -11897,6 +11825,17 @@ rs6000_emit_epilogue (sibcall)\n     {\n       unsigned int i, regno;\n \n+      if (TARGET_AIX)\n+\t{\n+\t  rtx addr = gen_rtx_PLUS (Pmode, frame_reg_rtx,\n+\t\t\t\t   GEN_INT (sp_offset + 5 * reg_size));\n+\t  rtx mem = gen_rtx_MEM (reg_mode, addr);\n+\n+\t  set_mem_alias_set (mem, rs6000_sr_alias_set);\n+\n+\t  emit_move_insn (gen_rtx_REG (reg_mode, 2), mem);\n+\t}\n+\n       for (i = 0; ; ++i)\n \t{\n \t  rtx mem;\n@@ -12048,7 +11987,8 @@ rs6000_emit_epilogue (sibcall)\n      (which may not have any obvious dependency on the stack).  This\n      doesn't hurt performance, because there is no scheduling that can\n      be done after this point.  */\n-  if (DEFAULT_ABI == ABI_V4)\n+  if (DEFAULT_ABI == ABI_V4\n+      || current_function_calls_eh_return)\n     {\n       if (frame_reg_rtx != sp_reg_rtx)\n \t  rs6000_emit_stack_tie ();"}, {"sha": "f39e849628ac4be83ef87caebae617e5c92482ff", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -14637,8 +14637,6 @@\n   \"\"\n   \"\n {\n-  if (TARGET_AIX)\n-    rs6000_emit_eh_toc_restore (EH_RETURN_STACKADJ_RTX);\n   if (TARGET_32BIT)\n     emit_insn (gen_eh_set_lr_si (operands[0]));\n   else"}, {"sha": "ab2deeb4fe64e71fd491e274c9c7c609d707cc7b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -1,3 +1,8 @@\n+2003-07-16  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/cleanup-8.c: New test.\n+\t* gcc.dg/cleanup-9.c: New test.\n+\n 2003-07-16  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* g++.dg/ext/dll-MI1.h: New file."}, {"sha": "91e387ce799e51642b71c8c64d89edc4af942b6d", "filename": "gcc/testsuite/gcc.dg/cleanup-8.c", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-8.c?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -0,0 +1,97 @@\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* } } */\n+/* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through signal\n+   frames.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  signal (SIGSEGV, fn4);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "0c17f25f63de3e6ccdde5ba6e52f9d734f14b97c", "filename": "gcc/testsuite/gcc.dg/cleanup-9.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-9.c?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* } } */\n+/* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through realtime\n+   signal frames.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  struct sigaction s;\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_ONESHOT | SA_SIGINFO;\n+  sigaction (SIGSEGV, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "3e58be6cb693b594339d87a0ee9c4e3c5f3d93a2", "filename": "gcc/unwind-dw2.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Funwind-dw2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc4767bbb69323f65b841b350a8d67742a83a89d/gcc%2Funwind-dw2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Funwind-dw2.c?ref=fc4767bbb69323f65b841b350a8d67742a83a89d", "patch": "@@ -54,6 +54,11 @@\n #define DWARF_REG_TO_UNWIND_COLUMN(REGNO) (REGNO)\n #endif\n \n+/* A target can do some update context frobbing.  */\n+#ifndef MD_FROB_UPDATE_CONTEXT\n+#define MD_FROB_UPDATE_CONTEXT(CTX, FS) do { } while (0)\n+#endif\n+\n /* This is the register and unwind state for a particular frame.  This\n    provides the information necessary to unwind up past a frame and return\n    to its caller.  */\n@@ -1203,6 +1208,8 @@ uw_update_context_1 (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n \t}\n \tbreak;\n       }\n+\n+  MD_FROB_UPDATE_CONTEXT (context, fs);\n }\n \n /* CONTEXT describes the unwind state for a frame, and FS describes the FDE"}]}