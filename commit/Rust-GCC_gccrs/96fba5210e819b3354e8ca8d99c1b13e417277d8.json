{"sha": "96fba5210e819b3354e8ca8d99c1b13e417277d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZmYmE1MjEwZTgxOWIzMzU0ZThjYThkOTljMWIxM2U0MTcyNzdkOA==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-16T06:24:47Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-04-16T06:24:47Z"}, "message": "re PR middle-end/43631 (var-tracking inserts notes with non-NULL BLOCK_FOR_INSN in between basic blocks)\n\n\n\tPR middle-end/43631\n\t* emit-rtl.c (make_note_raw): New function.\n\t(link_insn_into_chain): New static inline function.\n\t(add_insn): Use it.\n\t(add_insn_before, add_insn_after): Factor insn chain linking code...\n\t(add_insn_before_nobb, add_insn_after_nobb): ...here, new functions\n\tusing link_insn_into_chain.\n\t(note_outside_basic_block_p): New helper function for emit_note_after\n\tand emit_note_before.\n\t(emit_note_after): Use nobb variant of add_insn_after if the note\n\tshould not be contained in a basic block.\n\t(emit_note_before): Use nobb variant of add_insn_before if the note\n\tshould not be contained in a basic block.\n\t(emit_note_copy): Use make_note_raw.\n\t(emit_note): Likewise.\n\t* bb-reorder.c (insert_section_boundary_note): Remove hack to set\n\tBLOCK_FOR_INSN to NULL manually for NOTE_INSN_SWITCH_TEXT_SECTIONS.\n\t* jump.c (cleanup_barriers): Use reorder_insns_nobb to avoid making\n\tthe moved barrier the tail of the basic block it follows.\n\t* var-tracking.c (pass_variable_tracking): Add TODO_verify_flow.\n\nFrom-SVN: r197994", "tree": {"sha": "e33803d286079623c109356f39eb59a4ec4cadeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e33803d286079623c109356f39eb59a4ec4cadeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96fba5210e819b3354e8ca8d99c1b13e417277d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fba5210e819b3354e8ca8d99c1b13e417277d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fba5210e819b3354e8ca8d99c1b13e417277d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fba5210e819b3354e8ca8d99c1b13e417277d8/comments", "author": null, "committer": null, "parents": [{"sha": "996943bea7a61c5583bf504b31d600b11159b6ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/996943bea7a61c5583bf504b31d600b11159b6ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/996943bea7a61c5583bf504b31d600b11159b6ed"}], "stats": {"total": 320, "additions": 197, "deletions": 123}, "files": [{"sha": "31c21e035d744f1d6be72b2b749359acdbc852da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96fba5210e819b3354e8ca8d99c1b13e417277d8", "patch": "@@ -1,3 +1,26 @@\n+2013-04-16  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR middle-end/43631\n+\t* emit-rtl.c (make_note_raw): New function.\n+\t(link_insn_into_chain): New static inline function.\n+\t(add_insn): Use it.\n+\t(add_insn_before, add_insn_after): Factor insn chain linking code...\n+\t(add_insn_before_nobb, add_insn_after_nobb): ...here, new functions\n+\tusing link_insn_into_chain.\n+\t(note_outside_basic_block_p): New helper function for emit_note_after\n+\tand emit_note_before.\n+\t(emit_note_after): Use nobb variant of add_insn_after if the note\n+\tshould not be contained in a basic block.\n+\t(emit_note_before): Use nobb variant of add_insn_before if the note\n+\tshould not be contained in a basic block.\n+\t(emit_note_copy): Use make_note_raw.\n+\t(emit_note): Likewise.\n+\t* bb-reorder.c (insert_section_boundary_note): Remove hack to set\n+\tBLOCK_FOR_INSN to NULL manually for NOTE_INSN_SWITCH_TEXT_SECTIONS.\n+\t* jump.c (cleanup_barriers): Use reorder_insns_nobb to avoid making\n+\tthe moved barrier the tail of the basic block it follows.\n+\t* var-tracking.c (pass_variable_tracking): Add TODO_verify_flow.\n+\n 2013-04-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR tree-optimization/56962"}, {"sha": "abb2e391983d7b88dedd91a9e7204970ca729106", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=96fba5210e819b3354e8ca8d99c1b13e417277d8", "patch": "@@ -2173,7 +2173,6 @@ static void\n insert_section_boundary_note (void)\n {\n   basic_block bb;\n-  rtx new_note;\n   int first_partition = 0;\n \n   if (!flag_reorder_blocks_and_partition)\n@@ -2185,11 +2184,7 @@ insert_section_boundary_note (void)\n \tfirst_partition = BB_PARTITION (bb);\n       if (BB_PARTITION (bb) != first_partition)\n \t{\n-\t  new_note = emit_note_before (NOTE_INSN_SWITCH_TEXT_SECTIONS,\n-\t\t\t\t       BB_HEAD (bb));\n-\t  /* ??? This kind of note always lives between basic blocks,\n-\t     but add_insn_before will set BLOCK_FOR_INSN anyway.  */\n-\t  BLOCK_FOR_INSN (new_note) = NULL;\n+\t  emit_note_before (NOTE_INSN_SWITCH_TEXT_SECTIONS, BB_HEAD (bb));\n \t  break;\n \t}\n     }"}, {"sha": "c8efb5ca4c5cb58426ce8a75175cbbe441f85baf", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 170, "deletions": 115, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=96fba5210e819b3354e8ca8d99c1b13e417277d8", "patch": "@@ -3763,62 +3763,135 @@ make_call_insn_raw (rtx pattern)\n \n   return insn;\n }\n+\n+/* Like `make_insn_raw' but make a NOTE instead of an insn.  */\n+\n+static rtx\n+make_note_raw (enum insn_note subtype)\n+{\n+  /* Some notes are never created this way at all.  These notes are\n+     only created by patching out insns.  */\n+  gcc_assert (subtype != NOTE_INSN_DELETED_LABEL\n+\t      && subtype != NOTE_INSN_DELETED_DEBUG_LABEL);\n+\n+  rtx note = rtx_alloc (NOTE);\n+  INSN_UID (note) = cur_insn_uid++;\n+  NOTE_KIND (note) = subtype;\n+  BLOCK_FOR_INSN (note) = NULL;\n+  memset (&NOTE_DATA (note), 0, sizeof (NOTE_DATA (note)));\n+  return note;\n+}\n \f\n+/* Add INSN to the end of the doubly-linked list, between PREV and NEXT.\n+   INSN may be any object that can appear in the chain: INSN_P and NOTE_P objects,\n+   but also BARRIERs and JUMP_TABLE_DATAs.  PREV and NEXT may be NULL.  */\n+\n+static inline void\n+link_insn_into_chain (rtx insn, rtx prev, rtx next)\n+{\n+  PREV_INSN (insn) = prev;\n+  NEXT_INSN (insn) = next;\n+  if (prev != NULL)\n+    {\n+      NEXT_INSN (prev) = insn;\n+      if (NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\t{\n+\t  rtx sequence = PATTERN (prev);\n+\t  NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n+\t}\n+    }\n+  if (next != NULL)\n+    {\n+      PREV_INSN (next) = insn;\n+      if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n+\tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = insn;\n+    }\n+}\n+\n /* Add INSN to the end of the doubly-linked list.\n    INSN may be an INSN, JUMP_INSN, CALL_INSN, CODE_LABEL, BARRIER or NOTE.  */\n \n void\n add_insn (rtx insn)\n {\n-  PREV_INSN (insn) = get_last_insn();\n-  NEXT_INSN (insn) = 0;\n-\n-  if (NULL != get_last_insn())\n-    NEXT_INSN (get_last_insn ()) = insn;\n-\n+  rtx prev = get_last_insn ();\n+  link_insn_into_chain (insn, prev, NULL);\n   if (NULL == get_insns ())\n     set_first_insn (insn);\n-\n   set_last_insn (insn);\n }\n \n-/* Add INSN into the doubly-linked list after insn AFTER.  This and\n-   the next should be the only functions called to insert an insn once\n-   delay slots have been filled since only they know how to update a\n-   SEQUENCE.  */\n+/* Add INSN into the doubly-linked list after insn AFTER.  */\n \n-void\n-add_insn_after (rtx insn, rtx after, basic_block bb)\n+static void\n+add_insn_after_nobb (rtx insn, rtx after)\n {\n   rtx next = NEXT_INSN (after);\n \n   gcc_assert (!optimize || !INSN_DELETED_P (after));\n \n-  NEXT_INSN (insn) = next;\n-  PREV_INSN (insn) = after;\n+  link_insn_into_chain (insn, after, next);\n \n-  if (next)\n+  if (next == NULL)\n     {\n-      PREV_INSN (next) = insn;\n-      if (NONJUMP_INSN_P (next) && GET_CODE (PATTERN (next)) == SEQUENCE)\n-\tPREV_INSN (XVECEXP (PATTERN (next), 0, 0)) = insn;\n+      if (get_last_insn () == after)\n+\tset_last_insn (insn);\n+      else\n+\t{\n+\t  struct sequence_stack *stack = seq_stack;\n+\t  /* Scan all pending sequences too.  */\n+\t  for (; stack; stack = stack->next)\n+\t    if (after == stack->last)\n+\t      {\n+\t\tstack->last = insn;\n+\t\tbreak;\n+\t      }\n+\t}\n     }\n-  else if (get_last_insn () == after)\n-    set_last_insn (insn);\n-  else\n+}\n+\n+/* Add INSN into the doubly-linked list before insn BEFORE.  */\n+\n+static void\n+add_insn_before_nobb (rtx insn, rtx before)\n+{\n+  rtx prev = PREV_INSN (before);\n+\n+  gcc_assert (!optimize || !INSN_DELETED_P (before));\n+\n+  link_insn_into_chain (insn, prev, before);\n+\n+  if (prev == NULL)\n     {\n-      struct sequence_stack *stack = seq_stack;\n-      /* Scan all pending sequences too.  */\n-      for (; stack; stack = stack->next)\n-\tif (after == stack->last)\n-\t  {\n-\t    stack->last = insn;\n-\t    break;\n-\t  }\n+      if (get_insns () == before)\n+\tset_first_insn (insn);\n+      else\n+\t{\n+\t  struct sequence_stack *stack = seq_stack;\n+\t  /* Scan all pending sequences too.  */\n+\t  for (; stack; stack = stack->next)\n+\t    if (before == stack->first)\n+\t      {\n+\t\tstack->first = insn;\n+\t\tbreak;\n+\t      }\n \n-      gcc_assert (stack);\n+\t  gcc_assert (stack);\n+\t}\n     }\n+}\n \n+/* Like add_insn_after_nobb, but try to set BLOCK_FOR_INSN.\n+   If BB is NULL, an attempt is made to infer the bb from before.\n+\n+   This and the next function should be the only functions called\n+   to insert an insn once delay slots have been filled since only\n+   they know how to update a SEQUENCE. */\n+\n+void\n+add_insn_after (rtx insn, rtx after, basic_block bb)\n+{\n+  add_insn_after_nobb (insn, after);\n   if (!BARRIER_P (after)\n       && !BARRIER_P (insn)\n       && (bb = BLOCK_FOR_INSN (after)))\n@@ -3834,55 +3907,19 @@ add_insn_after (rtx insn, rtx after, basic_block bb)\n \t  && !NOTE_INSN_BASIC_BLOCK_P (insn))\n \tBB_END (bb) = insn;\n     }\n-\n-  NEXT_INSN (after) = insn;\n-  if (NONJUMP_INSN_P (after) && GET_CODE (PATTERN (after)) == SEQUENCE)\n-    {\n-      rtx sequence = PATTERN (after);\n-      NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n-    }\n }\n \n-/* Add INSN into the doubly-linked list before insn BEFORE.  This and\n-   the previous should be the only functions called to insert an insn\n-   once delay slots have been filled since only they know how to\n-   update a SEQUENCE.  If BB is NULL, an attempt is made to infer the\n-   bb from before.  */\n+/* Like add_insn_before_nobb, but try to set BLOCK_FOR_INSN.\n+   If BB is NULL, an attempt is made to infer the bb from before.\n+\n+   This and the previous function should be the only functions called\n+   to insert an insn once delay slots have been filled since only\n+   they know how to update a SEQUENCE. */\n \n void\n add_insn_before (rtx insn, rtx before, basic_block bb)\n {\n-  rtx prev = PREV_INSN (before);\n-\n-  gcc_assert (!optimize || !INSN_DELETED_P (before));\n-\n-  PREV_INSN (insn) = prev;\n-  NEXT_INSN (insn) = before;\n-\n-  if (prev)\n-    {\n-      NEXT_INSN (prev) = insn;\n-      if (NONJUMP_INSN_P (prev) && GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\t{\n-\t  rtx sequence = PATTERN (prev);\n-\t  NEXT_INSN (XVECEXP (sequence, 0, XVECLEN (sequence, 0) - 1)) = insn;\n-\t}\n-    }\n-  else if (get_insns () == before)\n-    set_first_insn (insn);\n-  else\n-    {\n-      struct sequence_stack *stack = seq_stack;\n-      /* Scan all pending sequences too.  */\n-      for (; stack; stack = stack->next)\n-\tif (before == stack->first)\n-\t  {\n-\t    stack->first = insn;\n-\t    break;\n-\t  }\n-\n-      gcc_assert (stack);\n-    }\n+  add_insn_before_nobb (insn, before);\n \n   if (!bb\n       && !BARRIER_P (before)\n@@ -3901,13 +3938,8 @@ add_insn_before (rtx insn, rtx before, basic_block bb)\n \t\t  || BARRIER_P (insn)\n \t\t  || NOTE_INSN_BASIC_BLOCK_P (insn));\n     }\n-\n-  PREV_INSN (before) = insn;\n-  if (NONJUMP_INSN_P (before) && GET_CODE (PATTERN (before)) == SEQUENCE)\n-    PREV_INSN (XVECEXP (PATTERN (before), 0, 0)) = insn;\n }\n \n-\n /* Replace insn with an deleted instruction note.  */\n \n void\n@@ -4251,21 +4283,6 @@ emit_label_before (rtx label, rtx before)\n   add_insn_before (label, before, NULL);\n   return label;\n }\n-\n-/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n-\n-rtx\n-emit_note_before (enum insn_note subtype, rtx before)\n-{\n-  rtx note = rtx_alloc (NOTE);\n-  INSN_UID (note) = cur_insn_uid++;\n-  NOTE_KIND (note) = subtype;\n-  BLOCK_FOR_INSN (note) = NULL;\n-  memset (&NOTE_DATA (note), 0, sizeof (NOTE_DATA (note)));\n-\n-  add_insn_before (note, before, NULL);\n-  return note;\n-}\n \f\n /* Helper for emit_insn_after, handles lists of instructions\n    efficiently.  */\n@@ -4412,18 +4429,68 @@ emit_label_after (rtx label, rtx after)\n   add_insn_after (label, after, NULL);\n   return label;\n }\n+\f\n+/* Notes require a bit of special handling: Some notes need to have their\n+   BLOCK_FOR_INSN set, others should never have it set, and some should\n+   have it set or clear depending on the context.   */\n+\n+/* Return true iff a note of kind SUBTYPE should be emitted with routines\n+   that never set BLOCK_FOR_INSN on NOTE.  BB_BOUNDARY is true if the\n+   caller is asked to emit a note before BB_HEAD, or after BB_END.  */\n+\n+static bool\n+note_outside_basic_block_p (enum insn_note subtype, bool on_bb_boundary_p)\n+{\n+  switch (subtype)\n+    {\n+      /* NOTE_INSN_SWITCH_TEXT_SECTIONS only appears between basic blocks.  */\n+      case NOTE_INSN_SWITCH_TEXT_SECTIONS:\n+\treturn true;\n+\n+      /* Notes for var tracking and EH region markers can appear between or\n+\t inside basic blocks.  If the caller is emitting on the basic block\n+\t boundary, do not set BLOCK_FOR_INSN on the new note.  */\n+      case NOTE_INSN_VAR_LOCATION:\n+      case NOTE_INSN_CALL_ARG_LOCATION:\n+      case NOTE_INSN_EH_REGION_BEG:\n+      case NOTE_INSN_EH_REGION_END:\n+\treturn on_bb_boundary_p;\n+\n+      /* Otherwise, BLOCK_FOR_INSN must be set.  */\n+      default:\n+\treturn false;\n+    }\n+}\n \n /* Emit a note of subtype SUBTYPE after the insn AFTER.  */\n \n rtx\n emit_note_after (enum insn_note subtype, rtx after)\n {\n-  rtx note = rtx_alloc (NOTE);\n-  INSN_UID (note) = cur_insn_uid++;\n-  NOTE_KIND (note) = subtype;\n-  BLOCK_FOR_INSN (note) = NULL;\n-  memset (&NOTE_DATA (note), 0, sizeof (NOTE_DATA (note)));\n-  add_insn_after (note, after, NULL);\n+  rtx note = make_note_raw (subtype);\n+  basic_block bb = BARRIER_P (after) ? NULL : BLOCK_FOR_INSN (after);\n+  bool on_bb_boundary_p = (bb != NULL && BB_END (bb) == after);\n+\n+  if (note_outside_basic_block_p (subtype, on_bb_boundary_p))\n+    add_insn_after_nobb (note, after);\n+  else\n+    add_insn_after (note, after, bb);\n+  return note;\n+}\n+\n+/* Emit a note of subtype SUBTYPE before the insn BEFORE.  */\n+\n+rtx\n+emit_note_before (enum insn_note subtype, rtx before)\n+{\n+  rtx note = make_note_raw (subtype);\n+  basic_block bb = BARRIER_P (before) ? NULL : BLOCK_FOR_INSN (before);\n+  bool on_bb_boundary_p = (bb != NULL && BB_HEAD (bb) == before);\n+\n+  if (note_outside_basic_block_p (subtype, on_bb_boundary_p))\n+    add_insn_before_nobb (note, before);\n+  else\n+    add_insn_before (note, before, bb);\n   return note;\n }\n \f\n@@ -4866,16 +4933,10 @@ emit_barrier (void)\n rtx\n emit_note_copy (rtx orig)\n {\n-  rtx note;\n-\n-  note = rtx_alloc (NOTE);\n-\n-  INSN_UID (note) = cur_insn_uid++;\n+  enum insn_note kind = (enum insn_note) NOTE_KIND (orig);\n+  rtx note = make_note_raw (kind);\n   NOTE_DATA (note) = NOTE_DATA (orig);\n-  NOTE_KIND (note) = NOTE_KIND (orig);\n-  BLOCK_FOR_INSN (note) = NULL;\n   add_insn (note);\n-\n   return note;\n }\n \n@@ -4885,13 +4946,7 @@ emit_note_copy (rtx orig)\n rtx\n emit_note (enum insn_note kind)\n {\n-  rtx note;\n-\n-  note = rtx_alloc (NOTE);\n-  INSN_UID (note) = cur_insn_uid++;\n-  NOTE_KIND (note) = kind;\n-  memset (&NOTE_DATA (note), 0, sizeof (NOTE_DATA (note)));\n-  BLOCK_FOR_INSN (note) = NULL;\n+  rtx note = make_note_raw (kind);\n   add_insn (note);\n   return note;\n }"}, {"sha": "9a171f4a9d93f37a56802fc3475fd925d2ab0ea3", "filename": "gcc/jump.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=96fba5210e819b3354e8ca8d99c1b13e417277d8", "patch": "@@ -133,7 +133,7 @@ cleanup_barriers (void)\n \t  if (BARRIER_P (prev))\n \t    delete_insn (insn);\n \t  else if (prev != PREV_INSN (insn))\n-\t    reorder_insns (insn, insn, prev);\n+\t    reorder_insns_nobb (insn, insn, prev);\n \t}\n     }\n   return 0;"}, {"sha": "337af5a5fdc7658d3d0f21670ffe751704753e9b", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96fba5210e819b3354e8ca8d99c1b13e417277d8/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=96fba5210e819b3354e8ca8d99c1b13e417277d8", "patch": "@@ -10238,6 +10238,7 @@ struct rtl_opt_pass pass_variable_tracking =\n   0,                                    /* properties_provided */\n   0,                                    /* properties_destroyed */\n   0,                                    /* todo_flags_start */\n-  TODO_verify_rtl_sharing               /* todo_flags_finish */\n+  TODO_verify_rtl_sharing\n+   | TODO_verify_flow                   /* todo_flags_finish */\n  }\n };"}]}