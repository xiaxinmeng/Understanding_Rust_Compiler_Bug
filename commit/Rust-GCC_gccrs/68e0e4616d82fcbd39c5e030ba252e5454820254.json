{"sha": "68e0e4616d82fcbd39c5e030ba252e5454820254", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhlMGU0NjE2ZDgyZmNiZDM5YzVlMDMwYmEyNTJlNTQ1NDgyMDI1NA==", "commit": {"author": {"name": "Wei Guozhi", "email": "carrot@google.com", "date": "2009-09-13T15:06:47Z"}, "committer": {"name": "Wei Guozhi", "email": "carrot@gcc.gnu.org", "date": "2009-09-13T15:06:47Z"}, "message": "optimize.c (build_delete_destructor_body): New function.\n\n\t* cp/optimize.c (build_delete_destructor_body): New function.\n\t(maybe_clone_body): Call build_delete_destructor_body for\n\tdeleting destructor.\n\nFrom-SVN: r151673", "tree": {"sha": "c33161e4390d228cbf153604c37cea1ed8022aba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c33161e4390d228cbf153604c37cea1ed8022aba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68e0e4616d82fcbd39c5e030ba252e5454820254", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e0e4616d82fcbd39c5e030ba252e5454820254", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68e0e4616d82fcbd39c5e030ba252e5454820254", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68e0e4616d82fcbd39c5e030ba252e5454820254/comments", "author": {"login": "weiguozhi", "id": 57237827, "node_id": "MDQ6VXNlcjU3MjM3ODI3", "avatar_url": "https://avatars.githubusercontent.com/u/57237827?v=4", "gravatar_id": "", "url": "https://api.github.com/users/weiguozhi", "html_url": "https://github.com/weiguozhi", "followers_url": "https://api.github.com/users/weiguozhi/followers", "following_url": "https://api.github.com/users/weiguozhi/following{/other_user}", "gists_url": "https://api.github.com/users/weiguozhi/gists{/gist_id}", "starred_url": "https://api.github.com/users/weiguozhi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/weiguozhi/subscriptions", "organizations_url": "https://api.github.com/users/weiguozhi/orgs", "repos_url": "https://api.github.com/users/weiguozhi/repos", "events_url": "https://api.github.com/users/weiguozhi/events{/privacy}", "received_events_url": "https://api.github.com/users/weiguozhi/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "933608b7607a84e6d7cce601d9cf2d7666c53682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/933608b7607a84e6d7cce601d9cf2d7666c53682", "html_url": "https://github.com/Rust-GCC/gccrs/commit/933608b7607a84e6d7cce601d9cf2d7666c53682"}], "stats": {"total": 168, "additions": 114, "deletions": 54}, "files": [{"sha": "d6befec64991b9978729fe962881c3ebe56742c6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e0e4616d82fcbd39c5e030ba252e5454820254/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e0e4616d82fcbd39c5e030ba252e5454820254/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=68e0e4616d82fcbd39c5e030ba252e5454820254", "patch": "@@ -1,3 +1,10 @@\n+2009-09-13  Wei Guozhi  <carrot@google.com>\n+\n+\tPR c++/3187\n+\t* cp/optimize.c (build_delete_destructor_body): New function.\n+\t(maybe_clone_body): Call build_delete_destructor_body for\n+\tdeleting destructor.\n+\n 2009-09-10  Jason Merrill  <jason@redhat.com>\n \n \t* repo.c (extract_string, get_base_filename, init_repo): constify."}, {"sha": "abd38f8666cdcd2e62787cb00f777d660a7f49e5", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 107, "deletions": 54, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68e0e4616d82fcbd39c5e030ba252e5454820254/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68e0e4616d82fcbd39c5e030ba252e5454820254/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=68e0e4616d82fcbd39c5e030ba252e5454820254", "patch": "@@ -1,5 +1,5 @@\n /* Perform optimizations on tree structure.\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004, 2005, 2007, 2008, 2009\n    Free Software Foundation, Inc.\n    Written by Mark Michell (mark@codesourcery.com).\n \n@@ -106,6 +106,41 @@ clone_body (tree clone, tree fn, void *arg_map)\n   append_to_statement_list_force (stmts, &DECL_SAVED_TREE (clone));\n }\n \n+/* DELETE_DTOR is a delete destructor whose body will be built.\n+   COMPLETE_DTOR is the corresponding complete destructor.  */\n+\n+static void\n+build_delete_destructor_body (tree delete_dtor, tree complete_dtor)\n+{\n+  tree call_dtor, call_delete;\n+  tree parm = DECL_ARGUMENTS (delete_dtor);\n+  tree virtual_size = cxx_sizeof (current_class_type);\n+\n+  /* Call the corresponding complete destructor.  */\n+  gcc_assert (complete_dtor);\n+  call_dtor = build_cxx_call (complete_dtor, 1, &parm);\n+  add_stmt (call_dtor);\n+\n+  add_stmt (build_stmt (0, LABEL_EXPR, cdtor_label));\n+\n+  /* Call the delete function.  */\n+  call_delete = build_op_delete_call (DELETE_EXPR, current_class_ptr,\n+                                      virtual_size,\n+                                      /*global_p=*/false,\n+                                      /*placement=*/NULL_TREE,\n+                                      /*alloc_fn=*/NULL_TREE);\n+  add_stmt (call_delete);\n+\n+  /* Return the address of the object.  */\n+  if (targetm.cxx.cdtor_returns_this ())\n+    {\n+      tree val = DECL_ARGUMENTS (delete_dtor);\n+      val = build2 (MODIFY_EXPR, TREE_TYPE (val),\n+                    DECL_RESULT (delete_dtor), val);\n+      add_stmt (build_stmt (0, RETURN_EXPR, val));\n+    }\n+}\n+\n /* FN is a function that has a complete body.  Clone the body as\n    necessary.  Returns nonzero if there's no longer any need to\n    process the main body.  */\n@@ -114,6 +149,7 @@ bool\n maybe_clone_body (tree fn)\n {\n   tree clone;\n+  tree complete_dtor = NULL_TREE;\n   bool first = true;\n \n   /* We only clone constructors and destructors.  */\n@@ -124,6 +160,15 @@ maybe_clone_body (tree fn)\n   /* Emit the DWARF1 abstract instance.  */\n   (*debug_hooks->deferred_inline_function) (fn);\n \n+  /* Look for the complete destructor which may be used to build the\n+     delete destructor.  */\n+  FOR_EACH_CLONE (clone, fn)\n+    if (DECL_NAME (clone) == complete_dtor_identifier)\n+      {\n+        complete_dtor = clone;\n+        break;\n+      }\n+\n   /* We know that any clones immediately follow FN in the TYPE_METHODS\n      list.  */\n   push_to_top_level ();\n@@ -176,59 +221,67 @@ maybe_clone_body (tree fn)\n       /* Start processing the function.  */\n       start_preparsed_function (clone, NULL_TREE, SF_PRE_PARSED);\n \n-      /* Remap the parameters.  */\n-      decl_map = pointer_map_create ();\n-      for (parmno = 0,\n-\t     parm = DECL_ARGUMENTS (fn),\n-\t     clone_parm = DECL_ARGUMENTS (clone);\n-\t   parm;\n-\t   ++parmno,\n-\t     parm = TREE_CHAIN (parm))\n-\t{\n-\t  /* Map the in-charge parameter to an appropriate constant.  */\n-\t  if (DECL_HAS_IN_CHARGE_PARM_P (fn) && parmno == 1)\n-\t    {\n-\t      tree in_charge;\n-\t      in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n-\t      *pointer_map_insert (decl_map, parm) = in_charge;\n-\t    }\n-\t  else if (DECL_ARTIFICIAL (parm)\n-\t\t   && DECL_NAME (parm) == vtt_parm_identifier)\n-\t    {\n-\t      /* For a subobject constructor or destructor, the next\n-\t\t argument is the VTT parameter.  Remap the VTT_PARM\n-\t\t from the CLONE to this parameter.  */\n-\t      if (DECL_HAS_VTT_PARM_P (clone))\n-\t\t{\n-\t\t  DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n-\t\t  *pointer_map_insert (decl_map, parm) = clone_parm;\n-\t\t  clone_parm = TREE_CHAIN (clone_parm);\n-\t\t}\n-\t      /* Otherwise, map the VTT parameter to `NULL'.  */\n-\t      else\n-\t\t*pointer_map_insert (decl_map, parm)\n-\t\t   = fold_convert (TREE_TYPE (parm), null_pointer_node);\n-\t    }\n-\t  /* Map other parameters to their equivalents in the cloned\n-\t     function.  */\n-\t  else\n-\t    {\n-\t      *pointer_map_insert (decl_map, parm) = clone_parm;\n-\t      clone_parm = TREE_CHAIN (clone_parm);\n-\t    }\n-\t}\n-\n-      if (targetm.cxx.cdtor_returns_this ())\n-\t{\n-\t  parm = DECL_RESULT (fn);\n-\t  clone_parm = DECL_RESULT (clone);\n-\t  *pointer_map_insert (decl_map, parm) = clone_parm;\n-\t}\n-      /* Clone the body.  */\n-      clone_body (clone, fn, decl_map);\n-\n-      /* Clean up.  */\n-      pointer_map_destroy (decl_map);\n+      /* Build the delete destructor by calling complete destructor\n+         and delete function.  */\n+      if (DECL_NAME (clone) == deleting_dtor_identifier)\n+        build_delete_destructor_body (clone, complete_dtor);\n+      else\n+        {\n+          /* Remap the parameters.  */\n+          decl_map = pointer_map_create ();\n+          for (parmno = 0,\n+                parm = DECL_ARGUMENTS (fn),\n+                clone_parm = DECL_ARGUMENTS (clone);\n+              parm;\n+              ++parmno,\n+                parm = TREE_CHAIN (parm))\n+            {\n+              /* Map the in-charge parameter to an appropriate constant.  */\n+              if (DECL_HAS_IN_CHARGE_PARM_P (fn) && parmno == 1)\n+                {\n+                  tree in_charge;\n+                  in_charge = in_charge_arg_for_name (DECL_NAME (clone));\n+                  *pointer_map_insert (decl_map, parm) = in_charge;\n+                }\n+              else if (DECL_ARTIFICIAL (parm)\n+                       && DECL_NAME (parm) == vtt_parm_identifier)\n+                {\n+                  /* For a subobject constructor or destructor, the next\n+                     argument is the VTT parameter.  Remap the VTT_PARM\n+                     from the CLONE to this parameter.  */\n+                  if (DECL_HAS_VTT_PARM_P (clone))\n+                    {\n+                      DECL_ABSTRACT_ORIGIN (clone_parm) = parm;\n+                      *pointer_map_insert (decl_map, parm) = clone_parm;\n+                      clone_parm = TREE_CHAIN (clone_parm);\n+                    }\n+                  /* Otherwise, map the VTT parameter to `NULL'.  */\n+                  else\n+                    *pointer_map_insert (decl_map, parm)\n+                       = fold_convert (TREE_TYPE (parm), null_pointer_node);\n+                }\n+              /* Map other parameters to their equivalents in the cloned\n+                 function.  */\n+              else\n+                {\n+                  *pointer_map_insert (decl_map, parm) = clone_parm;\n+                  clone_parm = TREE_CHAIN (clone_parm);\n+                }\n+            }\n+\n+          if (targetm.cxx.cdtor_returns_this ())\n+            {\n+              parm = DECL_RESULT (fn);\n+              clone_parm = DECL_RESULT (clone);\n+              *pointer_map_insert (decl_map, parm) = clone_parm;\n+            }\n+\n+          /* Clone the body.  */\n+          clone_body (clone, fn, decl_map);\n+\n+          /* Clean up.  */\n+          pointer_map_destroy (decl_map);\n+        }\n \n       /* The clone can throw iff the original function can throw.  */\n       cp_function_chain->can_throw = !TREE_NOTHROW (fn);"}]}