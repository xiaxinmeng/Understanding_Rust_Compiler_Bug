{"sha": "0fc6c49280e515d2c1041919eae90b0bca864c81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZjNmM0OTI4MGU1MTVkMmMxMDQxOTE5ZWFlOTBiMGJjYTg2NGM4MQ==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-01-30T19:08:37Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2005-01-30T19:08:37Z"}, "message": "re PR tree-optimization/19624 (PRE pessimizes ivopts)\n\n2005-01-30  Daniel Berlin  <dberlin@dberlin.org>\n\n\tFix PR tree-optimization/19624\n\n\t* Makefile.in (tree-ssa-pre.o): Add CFGLOOP_H.\n\t* tree-ssa-pre.c: Add cfgloop.h.\n\tUpdate comment.\n\t(pre_stats): New member, constified.\n\t(inserted_exprs): New static variable.\n\t(NECESSARY): New macro.\n\t(create_expression_by_pieces): Fold the expression, and\n\tmark it as defaulting to not necessary. Also put in\n\tinserted_exprs.\n\t(fully_constant_expression): New function.\n\t(insert_into_preds_of_block): Modify to not insert phis when we\n\tare playing with induction variables.\n\tPush phis onto the inserted_exprs vector, and mark them as not\n\tnecessary by default.\n\t(insert_aux): Call fully_constant_expression on eprime.\n\tIf all edges produce the same value, mark it constant.\n\t(mark_operand_necessary): New function.\n\t(remove_dead_inserted_code): New function.\n\t(init_pre): Init loop optimizer to get loop info.\n\t(fini_pre): Free loop_optimizer, and inserted_exprs vec.\n\t(execute_pre): Commit edge inserts, then remove dead code.\n\nFrom-SVN: r94448", "tree": {"sha": "0a91c97f68df2f3505e7df5458a6291a47382478", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0a91c97f68df2f3505e7df5458a6291a47382478"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fc6c49280e515d2c1041919eae90b0bca864c81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc6c49280e515d2c1041919eae90b0bca864c81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fc6c49280e515d2c1041919eae90b0bca864c81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fc6c49280e515d2c1041919eae90b0bca864c81/comments", "author": null, "committer": null, "parents": [{"sha": "61e067ccd8ae13ecb20fda63a7c1d94bb28ec71f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e067ccd8ae13ecb20fda63a7c1d94bb28ec71f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61e067ccd8ae13ecb20fda63a7c1d94bb28ec71f"}], "stats": {"total": 279, "additions": 254, "deletions": 25}, "files": [{"sha": "288c269cfe89d9b63c148c2c5998536dafc20417", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0fc6c49280e515d2c1041919eae90b0bca864c81", "patch": "@@ -1663,7 +1663,7 @@ tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n    $(GGC_H) output.h diagnostic.h errors.h toplev.h $(TIMEVAR_H) \\\n-   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H)\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h $(FLAGS_H) $(CFGLOOP_H)\n tree-vn.o : tree-vn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) \\\n    $(TREE_H) $(TREE_FLOW_H) $(HASHTAB_H) langhooks.h tree-pass.h \\\n    $(TREE_DUMP_H) diagnostic.h"}, {"sha": "adf4ed00ad54f1d746a62303f21fecfa0a028943", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-4.c?ref=0fc6c49280e515d2c1041919eae90b0bca864c81", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(void)\n+{\n+\tint x, c, y;\n+\tx = 3;\n+\tif (c)\n+\t\tx = 2;\n+\ty = x + 1;\n+\treturn y;\n+}\n+/* We should eliminate the x+1 computation from this routine, replacing\n+   it with a phi of 3, 4 */\n+/* { dg-final { scan-tree-dump-times \"Eliminated:1\" 1 \"pre\"} } */"}, {"sha": "a5ae701358eacb3c22f2af9409c403bbfc046940", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-5.c?ref=0fc6c49280e515d2c1041919eae90b0bca864c81", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int \n+foo (int i)\n+{\n+\tint a, b;\n+\tif (i)\n+\t\ta = 3, b = 2;\n+\telse\n+\t\ta = 2, b = 3;\n+\treturn a + b;\n+}\n+/* We should detect that a+b is the same along both edges, and replace it with\n+   5  */\n+/* { dg-final { scan-tree-dump-times \"Constified:1\" 1 \"pre\"} } */"}, {"sha": "23bde5930c8f2bde826ca32be5875e39f8a82275", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-pre-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-pre-6.c?ref=0fc6c49280e515d2c1041919eae90b0bca864c81", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */ \n+/* { dg-options \"-O2 -fdump-tree-pre-stats\" } */\n+int main(int x)\n+{\n+\tint c, y;\n+\tif (c)\n+\t\tx = 2;\n+\ty = x + 1;\n+\treturn y;\n+}\n+/* We should eliminate one evaluation of x + 1 along the x = 2 path,\n+   causing one elimination.  */\n+/* { dg-final { scan-tree-dump-times \"Eliminated:1\" 1 \"pre\"} } */"}, {"sha": "b9e1510e05df3a6cd257758c5fb545271585f995", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 211, "deletions": 24, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fc6c49280e515d2c1041919eae90b0bca864c81/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=0fc6c49280e515d2c1041919eae90b0bca864c81", "patch": "@@ -43,6 +43,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"flags.h\"\n #include \"bitmap.h\"\n #include \"langhooks.h\"\n+#include \"cfgloop.h\"\n \n /* TODO:\n    \n@@ -55,13 +56,8 @@ Boston, MA 02111-1307, USA.  */\n       a new value every time we see a statement with a vuse.\n    3. Strength reduction can be performed by anticipating expressions\n       we can repair later on.\n-   4. Our canonicalization of expressions during lookups don't take\n-      constants into account very well.  In particular, we don't fold\n-      anywhere, so we can get situations where we stupidly think\n-      something is a new value (a + 1 + 1 vs a + 2).  This is somewhat\n-      expensive to fix, but it does expose a lot more eliminations.\n-      It may or not be worth it, depending on how critical you\n-      consider PRE vs just plain GRE.\n+   4. We can do back-substitution or smarter value numbering to catch\n+      commutative expressions split up over multiple statements.\n */   \n \n /* For ease of terminology, \"expression node\" in the below refers to\n@@ -279,6 +275,10 @@ static struct\n \n   /* The number of new PHI nodes added by PRE.  */\n   int phis;\n+  \n+  /* The number of values found constant.  */\n+  int constified;\n+  \n } pre_stats;\n \n \n@@ -1282,7 +1282,7 @@ compute_antic (void)\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n \n-\n+static VEC(tree_on_heap) *inserted_exprs;\n /* Find a leader for an expression, or generate one using\n    create_expression_by_pieces if it's ANTIC but\n    complex.  \n@@ -1311,7 +1311,7 @@ find_or_generate_expression (basic_block block, tree expr, tree stmts)\n   return genop;\n }\n \n-  \n+#define NECESSARY(stmt)\t\tstmt->common.asm_written_flag  \n /* Create an expression in pieces, so that we can handle very complex\n    expressions that may be ANTIC, but not necessary GIMPLE.  \n    BLOCK is the basic block the expression will be inserted into,\n@@ -1346,14 +1346,16 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tgenop2 = find_or_generate_expression (block, op2, stmts);\n \ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n \tadd_referenced_tmp_var (temp);\n-\tnewexpr = build (TREE_CODE (expr), TREE_TYPE (expr), \n-\t\t\t genop1, genop2);\n+\tnewexpr = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t       genop1, genop2));\n \tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n \t\t\t temp, newexpr);\n+\tNECESSARY (newexpr) = 0;\n \tname = make_ssa_name (temp, newexpr);\n \tTREE_OPERAND (newexpr, 0) = name;\n \ttsi = tsi_last (stmts);\n \ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n+\tVEC_safe_push (tree_on_heap, inserted_exprs, newexpr);\n \tpre_stats.insertions++;\n \tbreak;\n       }\n@@ -1366,14 +1368,16 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n \tgenop1 = find_or_generate_expression (block, op1, stmts);\n \ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n \tadd_referenced_tmp_var (temp);\n-\tnewexpr = build (TREE_CODE (expr), TREE_TYPE (expr), \n-\t\t\t genop1);\n+\tnewexpr = fold (build (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t       genop1));\n \tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n \t\t\t temp, newexpr);\n \tname = make_ssa_name (temp, newexpr);\n \tTREE_OPERAND (newexpr, 0) = name;\n+\tNECESSARY (newexpr) = 0;\n \ttsi = tsi_last (stmts);\n \ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n+\tVEC_safe_push (tree_on_heap, inserted_exprs, newexpr);\n \tpre_stats.insertions++;\n \n \tbreak;\n@@ -1400,17 +1404,32 @@ create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n   return name;\n }\n \n+/* Return the folded version of T if T, when folded, is a gimple\n+   min_invariant.  Otherwise, return T. */ \n+\n+static tree\n+fully_constant_expression (tree t)\n+{  \n+  tree folded;\n+  folded = fold (t);\n+  if (folded && is_gimple_min_invariant (folded))\n+    return folded;\n+  return t;\n+}\n+\n /* Insert the to-be-made-available values of NODE for each predecessor, stored\n    in AVAIL, into the predecessors of BLOCK, and merge the result with a phi\n    node, given the same value handle as NODE.  The prefix of the phi node is\n-   given with TMPNAME*/\n+   given with TMPNAME.  Return true if we have inserted new stuff.  */\n \n static bool\n insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t\t\t    tree *avail, const char *tmpname)\n {\n   tree val = get_value_handle (node->expr);\n   edge pred;\n+  bool insertions = false;\n+  bool nophi = false;\n   basic_block bprime;\n   tree eprime;\n   edge_iterator ei;\n@@ -1424,6 +1443,25 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n       fprintf (dump_file, \"\\n\");\n     }\n \n+  /* Make sure we aren't creating an induction variable.  */\n+  if (block->loop_depth > 0 && EDGE_COUNT (block->preds) == 2)\n+    {\n+      bool firstinsideloop = false;\n+      bool secondinsideloop = false;\n+      firstinsideloop = flow_bb_inside_loop_p (block->loop_father, \n+\t\t\t\t\t       EDGE_PRED (block, 0)->src);\n+      secondinsideloop = flow_bb_inside_loop_p (block->loop_father,\n+\t\t\t\t\t\tEDGE_PRED (block, 1)->src);\n+      /* Induction variables only have one edge inside the loop.  */\n+      if (firstinsideloop ^ secondinsideloop)\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Skipping insertion of phi for partial redundancy: Looks like an induction variable\\n\");\n+\t  nophi = true;\n+\t}\n+    }\n+\t  \n+\n   /* Make the necessary insertions.  */\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     {\n@@ -1439,13 +1477,24 @@ insert_into_preds_of_block (basic_block block, value_set_node_t node,\n \t\t\t\t\t\t   stmts);\n \t  bsi_insert_on_edge (pred, stmts);\n \t  avail[bprime->index] = builtexpr;\n+\t  insertions = true;\n \t}\t\t\t      \n     }\n+  /* If we didn't want a phi node, and we made insertions, we still have\n+     inserted new stuff, and thus return true.  If we didn't want a phi node,\n+     and didn't make insertions, we haven't added anything new, so return\n+     false.  */\n+  if (nophi && insertions)\n+    return true;\n+  else if (nophi && !insertions)\n+    return false;\n+\n   /* Now build a phi for the new variable.  */\n   temp = create_tmp_var (type, tmpname);\n   add_referenced_tmp_var (temp);\n   temp = create_phi_node (temp, block);\n- \n+  NECESSARY (temp) = 0; \n+  VEC_safe_push (tree_on_heap, inserted_exprs, temp);\n   FOR_EACH_EDGE (pred, ei, block->preds)\n     add_phi_arg (temp, avail[pred->src->index], pred);\n   \n@@ -1591,6 +1640,7 @@ insert_aux (basic_block block)\n \t\t\t      break;\n \t\t\t    }\n \n+\t\t\t  eprime = fully_constant_expression (eprime);\n \t\t\t  vprime = get_value_handle (eprime);\n \t\t\t  gcc_assert (vprime);\n \t\t\t  edoubleprime = bitmap_find_leader (AVAIL_OUT (bprime),\n@@ -1621,7 +1671,24 @@ insert_aux (basic_block block)\n  \t\t\t\t\t\t\t  \"prephitmp\"))\n  \t\t\t    new_stuff = true;\n \t\t\t}\n-\n+\t\t      /* If all edges produce the same value and that value is\n+\t\t\t an invariant, then the PHI has the same value on all\n+\t\t\t edges.  Note this.  */\n+\t\t      else if (all_same && eprime \n+\t\t\t       && is_gimple_min_invariant (eprime)\n+\t\t\t       && !is_gimple_min_invariant (val))\n+\t\t\t{\n+\t\t\t  value_set_t exprset = VALUE_HANDLE_EXPR_SET (val);\n+\t\t\t  value_set_node_t node;\n+\t\t\t  for (node = exprset->head; node; node = node->next)\n+ \t\t\t    {\n+\t\t\t      if (TREE_CODE (node->expr) == SSA_NAME)\n+\t\t\t\t{\t\t\t\t  \n+\t\t\t\t  vn_add (node->expr, eprime, NULL);\n+\t\t\t\t  pre_stats.constified++;\n+\t\t\t\t}\n+ \t\t\t    }\n+\t\t\t}\n \t\t      free (avail);\n \t\t    }\n \t\t}\n@@ -1944,6 +2011,8 @@ eliminate (void)\n \t\t      fprintf (dump_file, \" in \");\n \t\t      print_generic_stmt (dump_file, stmt, 0);\n \t\t    }\n+\t\t  if (TREE_CODE (sprime) == SSA_NAME) \n+\t\t    NECESSARY (SSA_NAME_DEF_STMT (sprime)) = 1;\n \t\t  pre_stats.eliminations++;\n \t\t  propagate_tree_value (rhs_p, sprime);\n \t\t  modify_stmt (stmt);\n@@ -1963,16 +2032,124 @@ eliminate (void)\n     }\n }\n \n+/* Borrow a bit of tree-ssa-dce.c for the moment.\n+   XXX: In 4.1, we should be able to just run a DCE pass after PRE, though\n+   this may be a bit faster, and we may want critical edges kept split.  */\n+\n+/* If OP's defining statement has not already been determined to be necessary,\n+   mark that statement necessary. and place it on the WORKLIST.  */ \n+\n+static inline void\n+mark_operand_necessary (tree op, VEC(tree_on_heap) **worklist)\n+{\n+  tree stmt;\n+  int ver;\n+\n+  gcc_assert (op);\n+\n+  ver = SSA_NAME_VERSION (op);\n+\n+  stmt = SSA_NAME_DEF_STMT (op);\n+  gcc_assert (stmt);\n+\n+  if (NECESSARY (stmt)\n+      || IS_EMPTY_STMT (stmt))\n+    return;\n+\n+  NECESSARY (stmt) = 1;\n+  VEC_safe_push (tree_on_heap, *worklist, stmt);\n+}\n+\n+/* Because we don't follow exactly the standard PRE algorithm, and decide not\n+   to insert PHI nodes sometimes, and because value numbering of casts isn't\n+   perfect, we sometimes end up inserting dead code.   This simple DCE-like\n+   pass removes any insertions we made that weren't actually used.  */\n+\n+static void\n+remove_dead_inserted_code (void)\n+{\n+  VEC (tree_on_heap) *worklist = NULL;\n+  int i;\n+  tree t;\n+\n+  for (i = 0; VEC_iterate (tree_on_heap, inserted_exprs, i, t); i++)\n+    {\n+      if (NECESSARY (t))\n+\tVEC_safe_push (tree_on_heap, worklist, t);\n+    }\n+  while (VEC_length (tree_on_heap, worklist) > 0)\n+    {\n+      t = VEC_pop (tree_on_heap, worklist);\n+      if (TREE_CODE (t) == PHI_NODE)\n+\t{\n+\t  /* PHI nodes are somewhat special in that each PHI alternative has\n+\t     data and control dependencies.  All the statements feeding the\n+\t     PHI node's arguments are always necessary.  In aggressive mode,\n+\t     we also consider the control dependent edges leading to the\n+\t     predecessor block associated with each PHI alternative as\n+\t     necessary.  */\n+\t  int k;\n+\t  for (k = 0; k < PHI_NUM_ARGS (t); k++)\n+            {\n+\t      tree arg = PHI_ARG_DEF (t, k);\n+\t      if (TREE_CODE (arg) == SSA_NAME)\n+\t\tmark_operand_necessary (arg, &worklist);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Propagate through the operands.  Examine all the USE, VUSE and\n+\t     V_MAY_DEF operands in this statement.  Mark all the statements \n+\t     which feed this statement's uses as necessary.  */\n+\t  ssa_op_iter iter;\n+\t  tree use;\n+\n+\t  get_stmt_operands (t);\n+\n+\t  /* The operands of V_MAY_DEF expressions are also needed as they\n+\t     represent potential definitions that may reach this\n+\t     statement (V_MAY_DEF operands allow us to follow def-def \n+\t     links).  */\n \n+\t  FOR_EACH_SSA_TREE_OPERAND (use, t, iter, SSA_OP_ALL_USES)\n+\t    mark_operand_necessary (use, &worklist);\n+\t}\n+    }\n+  for (i = 0; VEC_iterate (tree_on_heap, inserted_exprs, i, t); i++)\n+    {\n+      if (!NECESSARY (t))\n+\t{\n+\t  block_stmt_iterator bsi;\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    {\n+\t      fprintf (dump_file, \"Removing unnecessary insertion:\");\n+\t      print_generic_stmt (dump_file, t, 0);\n+\t    }\n+\t  if (TREE_CODE (t) == PHI_NODE)\n+\t    {\n+\t      remove_phi_node (t, NULL, bb_for_stmt (t));\n+\t    }\n+\t  else\n+\t    {\n+\t      bsi = bsi_for_stmt (t);\n+\t      bsi_remove (&bsi);\n+\t    }\n+\t}\n+    }\n+  VEC_free (tree_on_heap, worklist);\n+}\n /* Initialize data structures used by PRE.  */\n \n static void\n-init_pre (void)\n+init_pre (bool do_fre)\n {\n   basic_block bb;\n \n-  connect_infinite_loops_to_exit ();\n+  inserted_exprs = NULL;\n   vn_init ();\n+  if (!do_fre)\n+    current_loops = loop_optimizer_init (dump_file);\n+  connect_infinite_loops_to_exit ();\n   memset (&pre_stats, 0, sizeof (pre_stats));\n \n   /* If block 0 has more than one predecessor, it means that its PHI\n@@ -2021,13 +2198,12 @@ init_pre (void)\n /* Deallocate data structures used by PRE.  */\n \n static void\n-fini_pre (void)\n+fini_pre (bool do_fre)\n {\n   basic_block bb;\n   unsigned int i;\n \n-  bsi_commit_edge_inserts ();\n-\n+  VEC_free (tree_on_heap, inserted_exprs);\n   bitmap_obstack_release (&grand_bitmap_obstack);\n   free_alloc_pool (value_set_pool);\n   free_alloc_pool (bitmap_set_pool);\n@@ -2068,6 +2244,11 @@ fini_pre (void)\n \t  && TREE_CODE (SSA_NAME_VALUE (name)) == VALUE_HANDLE)\n \tSSA_NAME_VALUE (name) = NULL;\n     }\n+  if (!do_fre && current_loops)\n+    {\n+      loop_optimizer_finalize (current_loops, dump_file);\n+      current_loops = NULL;\n+    }\n }\n \n \n@@ -2077,7 +2258,7 @@ fini_pre (void)\n static void\n execute_pre (bool do_fre)\n {\n-  init_pre ();\n+  init_pre (do_fre);\n \n   /* Collect and value number expressions computed in each basic block.  */\n   compute_avail ();\n@@ -2109,15 +2290,21 @@ execute_pre (bool do_fre)\n \n   /* Remove all the redundant expressions.  */\n   eliminate ();\n-  \n+\n+\n   if (dump_file && (dump_flags & TDF_STATS))\n     {\n       fprintf (dump_file, \"Insertions:%d\\n\", pre_stats.insertions);\n       fprintf (dump_file, \"New PHIs:%d\\n\", pre_stats.phis);\n       fprintf (dump_file, \"Eliminated:%d\\n\", pre_stats.eliminations);\n+      fprintf (dump_file, \"Constified:%d\\n\", pre_stats.constified);\n     }\n+  \n+  bsi_commit_edge_inserts ();\n+  if (!do_fre)\n+    remove_dead_inserted_code ();\n+  fini_pre (do_fre);\n \n-  fini_pre ();\n }\n \n "}]}