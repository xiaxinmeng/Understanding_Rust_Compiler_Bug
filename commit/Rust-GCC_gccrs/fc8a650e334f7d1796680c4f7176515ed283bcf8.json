{"sha": "fc8a650e334f7d1796680c4f7176515ed283bcf8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM4YTY1MGUzMzRmN2QxNzk2NjgwYzRmNzE3NjUxNWVkMjgzYmNmOA==", "commit": {"author": {"name": "Sharad Singhai", "email": "singhai@google.com", "date": "2013-06-20T05:20:09Z"}, "committer": {"name": "Sharad Singhai", "email": "singhai@gcc.gnu.org", "date": "2013-06-20T05:20:09Z"}, "message": "gcov.c (print_usage): Handle new option.\n\n2013-06-19    <singhai@google.com>\n\n\t* gcov.c (print_usage): Handle new option.\n\t(process_args): Ditto.\n\t(get_gcov_intermediate_filename): New function.\n\t(output_intermediate_file): New function.\n\t(output_gcov_file): New function\n\t(generate_results): Handle new option.\n\t(release_function): Relase demangled name.\n\t(read_graph_file): Handle demangled name.\n\t(output_lines): Ditto.\n\t* doc/gcov.texi: Document gcov intermediate format.\n\ntestsuite/ChangeLog:\n\n\t* g++.dg/gcov/gcov-8.C: New testcase.\n\t* lib/gcov.exp: Handle intermediate format.\n\nFrom-SVN: r200232", "tree": {"sha": "63175e109fb12072daaca597a7f8a48920384521", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63175e109fb12072daaca597a7f8a48920384521"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc8a650e334f7d1796680c4f7176515ed283bcf8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8a650e334f7d1796680c4f7176515ed283bcf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc8a650e334f7d1796680c4f7176515ed283bcf8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc8a650e334f7d1796680c4f7176515ed283bcf8/comments", "author": null, "committer": null, "parents": [{"sha": "39c31476d33966c74f1595e2a08a546f74f0ee13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39c31476d33966c74f1595e2a08a546f74f0ee13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39c31476d33966c74f1595e2a08a546f74f0ee13"}], "stats": {"total": 431, "additions": 385, "deletions": 46}, "files": [{"sha": "1a950c88ee4a8e35fb2e239d2e1c430b594386a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -1,3 +1,16 @@\n+2013-06-19    <singhai@google.com>\n+\n+\t* gcov.c (print_usage): Handle new option.\n+\t(process_args): Ditto.\n+\t(get_gcov_intermediate_filename): New function.\n+\t(output_intermediate_file): New function.\n+\t(output_gcov_file): New function\n+\t(generate_results): Handle new option.\n+\t(release_function): Relase demangled name.\n+\t(read_graph_file): Handle demangled name.\n+\t(output_lines): Ditto.\n+\t* doc/gcov.texi: Document gcov intermediate format.\n+\n 2013-06-19  Vladimir Makarov  <vmakarov@redhat.com>\n \n \tPR bootstrap/57604"}, {"sha": "2b675277790a99c96157d8c4991d4375a44bba95", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 51, "deletions": 5, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -122,15 +122,17 @@ gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n      [@option{-a}|@option{--all-blocks}]\n      [@option{-b}|@option{--branch-probabilities}]\n      [@option{-c}|@option{--branch-counts}]\n-     [@option{-u}|@option{--unconditional-branches}]\n-     [@option{-n}|@option{--no-output}]\n+     [@option{-d}|@option{--display-progress}]\n+     [@option{-f}|@option{--function-summaries}]\n+     [@option{-i}|@option{--intermediate-format}]\n      [@option{-l}|@option{--long-file-names}]\n+     [@option{-m}|@option{--demangled-names}]\n+     [@option{-n}|@option{--no-output}]\n+     [@option{-o}|@option{--object-directory} @var{directory|file}]\n      [@option{-p}|@option{--preserve-paths}]\n      [@option{-r}|@option{--relative-only}]\n-     [@option{-f}|@option{--function-summaries}]\n-     [@option{-o}|@option{--object-directory} @var{directory|file}]\n      [@option{-s}|@option{--source-prefix} @var{directory}]\n-     [@option{-d}|@option{--display-progress}]\n+     [@option{-u}|@option{--unconditional-branches}]\n      @var{files}\n @c man end\n @c man begin SEEALSO\n@@ -232,6 +234,50 @@ Unconditional branches are normally not interesting.\n @itemx --display-progress\n Display the progress on the standard output.\n \n+@item -i\n+@itemx --intermediate-format\n+Output gcov file in an easy-to-parse intermediate text format that can\n+be used by @command{lcov} or other tools. The output is a single\n+@file{.gcov} file per @file{.gcda} file. No source code is required.\n+\n+The format of the intermediate @file{.gcov} file is plain text with\n+one entry per line\n+\n+@smallexample\n+file:@var{source_file_name}\n+function:@var{line_number},@var{execution_count},@var{function_name}\n+lcount:@var{line number},@var{execution_count}\n+branch:@var{line_number},@var{branch_coverage_type}\n+\n+Where the @var{branch_coverage_type} is\n+   notexec (Branch not executed)\n+   taken (Branch executed and taken)\n+   nottaken (Branch executed, but not taken)\n+\n+There can be multiple @var{file} entries in an intermediate gcov\n+file. All entries following a @var{file} pertain to that source file\n+until the next @var{file} entry.\n+@end smallexample\n+\n+Here is a sample when @option{-i} is used in conjuction with @option{-b} option:\n+\n+@smallexample\n+file:array.cc\n+function:11,1,_Z3sumRKSt6vectorIPiSaIS0_EE\n+function:22,1,main\n+lcount:11,1\n+lcount:12,1\n+lcount:14,1\n+branch:14,taken\n+lcount:26,1\n+branch:28,nottaken\n+@end smallexample\n+\n+@item -m\n+@itemx --demangled-names\n+Display demangled function names in output. The default is to show\n+mangled function names.\n+\n @end table\n \n @command{gcov} should be run with the current directory the same as that"}, {"sha": "6aa48fd26c23a5e0342d0f36f421ea71f537ba19", "filename": "gcc/gcov.c", "status": "modified", "additions": 205, "deletions": 38, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -37,6 +37,7 @@ along with Gcov; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"diagnostic.h\"\n #include \"version.h\"\n+#include \"demangle.h\"\n \n #include <getopt.h>\n \n@@ -168,6 +169,7 @@ typedef struct function_info\n {\n   /* Name of function.  */\n   char *name;\n+  char *demangled_name;\n   unsigned ident;\n   unsigned lineno_checksum;\n   unsigned cfg_checksum;\n@@ -325,6 +327,14 @@ static int flag_gcov_file = 1;\n \n static int flag_display_progress = 0;\n \n+/* Output *.gcov file in intermediate format used by 'lcov'.  */\n+\n+static int flag_intermediate_format = 0;\n+\n+/* Output demangled function names.  */\n+\n+static int flag_demangled_names = 0;\n+\n /* For included files, make the gcov output file name include the name\n    of the input source file.  For example, if x.h is included in a.c,\n    then the output file name is a.c##x.h.gcov instead of x.h.gcov.  */\n@@ -388,6 +398,7 @@ static void executed_summary (unsigned, unsigned);\n static void function_summary (const coverage_t *, const char *);\n static const char *format_gcov (gcov_type, gcov_type, int);\n static void accumulate_line_counts (source_t *);\n+static void output_gcov_file(const char *, source_t *);\n static int output_branch_count (FILE *, int, const arc_t *);\n static void output_lines (FILE *, const source_t *);\n static char *make_gcov_file_name (const char *, const char *);\n@@ -461,21 +472,23 @@ print_usage (int error_p)\n   fnotice (file, \"Usage: gcov [OPTION]... SOURCE|OBJ...\\n\\n\");\n   fnotice (file, \"Print code coverage information.\\n\\n\");\n   fnotice (file, \"  -h, --help                      Print this help, then exit\\n\");\n-  fnotice (file, \"  -v, --version                   Print version number, then exit\\n\");\n   fnotice (file, \"  -a, --all-blocks                Show information for every basic block\\n\");\n   fnotice (file, \"  -b, --branch-probabilities      Include branch probabilities in output\\n\");\n-  fnotice (file, \"  -c, --branch-counts             Given counts of branches taken\\n\\\n+  fnotice (file, \"  -c, --branch-counts             Output counts of branches taken\\n\\\n                                     rather than percentages\\n\");\n-  fnotice (file, \"  -n, --no-output                 Do not create an output file\\n\");\n+  fnotice (file, \"  -d, --display-progress          Display progress information\\n\");\n+  fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n+  fnotice (file, \"  -i, --intermediate-format       Output .gcov file in intermediate text format\\n\");\n   fnotice (file, \"  -l, --long-file-names           Use long output file names for included\\n\\\n                                     source files\\n\");\n-  fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n+  fnotice (file, \"  -m, --demangled-names           Output demangled function names\\n\");\n+  fnotice (file, \"  -n, --no-output                 Do not create an output file\\n\");\n   fnotice (file, \"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\\n\");\n-  fnotice (file, \"  -s, --source-prefix DIR         Source prefix to elide\\n\");\n-  fnotice (file, \"  -r, --relative-only             Only show data for relative sources\\n\");\n   fnotice (file, \"  -p, --preserve-paths            Preserve all pathname components\\n\");\n+  fnotice (file, \"  -r, --relative-only             Only show data for relative sources\\n\");\n+  fnotice (file, \"  -s, --source-prefix DIR         Source prefix to elide\\n\");\n   fnotice (file, \"  -u, --unconditional-branches    Show unconditional branch counts too\\n\");\n-  fnotice (file, \"  -d, --display-progress          Display progress information\\n\");\n+  fnotice (file, \"  -v, --version                   Print version number, then exit\\n\");\n   fnotice (file, \"\\nFor bug reporting instructions, please see:\\n%s.\\n\",\n \t   bug_report_url);\n   exit (status);\n@@ -503,9 +516,11 @@ static const struct option options[] =\n   { \"all-blocks\",           no_argument,       NULL, 'a' },\n   { \"branch-probabilities\", no_argument,       NULL, 'b' },\n   { \"branch-counts\",        no_argument,       NULL, 'c' },\n+  { \"intermediate-format\",  no_argument,       NULL, 'i' },\n   { \"no-output\",            no_argument,       NULL, 'n' },\n   { \"long-file-names\",      no_argument,       NULL, 'l' },\n   { \"function-summaries\",   no_argument,       NULL, 'f' },\n+  { \"demangled-names\",      no_argument,       NULL, 'm' },\n   { \"preserve-paths\",       no_argument,       NULL, 'p' },\n   { \"relative-only\",        no_argument,       NULL, 'r' },\n   { \"object-directory\",     required_argument, NULL, 'o' },\n@@ -523,7 +538,8 @@ process_args (int argc, char **argv)\n {\n   int opt;\n \n-  while ((opt = getopt_long (argc, argv, \"abcdfhlno:s:pruv\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"abcdfhilmno:s:pruv\", options, NULL)) !=\n+         -1)\n     {\n       switch (opt)\n \t{\n@@ -545,6 +561,9 @@ process_args (int argc, char **argv)\n \tcase 'l':\n \t  flag_long_names = 1;\n \t  break;\n+\tcase 'm':\n+\t  flag_demangled_names = 1;\n+\t  break;\n \tcase 'n':\n \t  flag_gcov_file = 0;\n \t  break;\n@@ -564,6 +583,10 @@ process_args (int argc, char **argv)\n \tcase 'u':\n \t  flag_unconditional = 1;\n \t  break;\n+\tcase 'i':\n+          flag_intermediate_format = 1;\n+          flag_gcov_file = 1;\n+          break;\n         case 'd':\n           flag_display_progress = 1;\n           break;\n@@ -579,6 +602,110 @@ process_args (int argc, char **argv)\n   return optind;\n }\n \n+/* Get the name of the gcov file.  The return value must be free'd.\n+\n+   It appends the '.gcov' extension to the *basename* of the file.\n+   The resulting file name will be in PWD.\n+\n+   e.g.,\n+   input: foo.da,       output: foo.da.gcov\n+   input: a/b/foo.cc,   output: foo.cc.gcov  */\n+\n+static char *\n+get_gcov_intermediate_filename (const char *file_name)\n+{\n+  const char *gcov = \".gcov\";\n+  char *result;\n+  const char *cptr;\n+\n+  /* Find the 'basename'.  */\n+  cptr = lbasename (file_name);\n+\n+  result = XNEWVEC(char, strlen (cptr) + strlen (gcov) + 1);\n+  sprintf (result, \"%s%s\", cptr, gcov);\n+\n+  return result;\n+}\n+\n+/* Output the result in intermediate format used by 'lcov'.\n+\n+The intermediate format contains a single file named 'foo.cc.gcov',\n+with no source code included. A sample output is\n+\n+file:foo.cc\n+function:5,1,_Z3foov\n+function:13,1,main\n+function:19,1,_GLOBAL__sub_I__Z3foov\n+function:19,1,_Z41__static_initialization_and_destruction_0ii\n+lcount:5,1\n+lcount:7,9\n+lcount:9,8\n+lcount:11,1\n+file:/.../iostream\n+lcount:74,1\n+file:/.../basic_ios.h\n+file:/.../ostream\n+file:/.../ios_base.h\n+function:157,0,_ZStorSt12_Ios_IostateS_\n+lcount:157,0\n+file:/.../char_traits.h\n+function:258,0,_ZNSt11char_traitsIcE6lengthEPKc\n+lcount:258,0\n+...\n+\n+The default gcov outputs multiple files: 'foo.cc.gcov',\n+'iostream.gcov', 'ios_base.h.gcov', etc. with source code\n+included. Instead the intermediate format here outputs only a single\n+file 'foo.cc.gcov' similar to the above example. */\n+\n+static void\n+output_intermediate_file (FILE *gcov_file, source_t *src)\n+{\n+  unsigned line_num;    /* current line number.  */\n+  const line_t *line;   /* current line info ptr.  */\n+  function_t *fn;       /* current function info ptr. */\n+\n+  fprintf (gcov_file, \"file:%s\\n\", src->name);    /* source file name */\n+\n+  for (fn = src->functions; fn; fn = fn->line_next)\n+    {\n+      /* function:<name>,<line_number>,<execution_count> */\n+      fprintf (gcov_file, \"function:%d,%s,%s\\n\", fn->line,\n+               format_gcov (fn->blocks[0].count, 0, -1),\n+               flag_demangled_names ? fn->demangled_name : fn->name);\n+    }\n+\n+  for (line_num = 1, line = &src->lines[line_num];\n+       line_num < src->num_lines;\n+       line_num++, line++)\n+    {\n+      arc_t *arc;\n+      if (line->exists)\n+        fprintf (gcov_file, \"lcount:%u,%s\\n\", line_num,\n+                 format_gcov (line->count, 0, -1));\n+      if (flag_branches)\n+        for (arc = line->u.branches; arc; arc = arc->line_next)\n+          {\n+            if (!arc->is_unconditional && !arc->is_call_non_return)\n+              {\n+                const char *branch_type;\n+                /* branch:<line_num>,<branch_coverage_type>\n+                   branch_coverage_type\n+                     : notexec (Branch not executed)\n+                     : taken (Branch executed and taken)\n+                     : nottaken (Branch executed, but not taken)\n+                */\n+                if (arc->src->count)\n+                  branch_type = (arc->count > 0) ? \"taken\" : \"nottaken\";\n+                else\n+                  branch_type = \"notexec\";\n+                fprintf(gcov_file, \"branch:%d,%s\\n\", line_num, branch_type);\n+              }\n+          }\n+    }\n+}\n+\n+\n /* Process a single input file.  */\n \n static void\n@@ -654,12 +781,41 @@ process_file (const char *file_name)\n     }\n }\n \n+static void\n+output_gcov_file(const char *file_name, source_t *src)\n+{\n+  char *gcov_file_name = make_gcov_file_name (file_name, src->coverage.name);\n+\n+  if (src->coverage.lines)\n+    {\n+      FILE *gcov_file = fopen (gcov_file_name, \"w\");\n+      if (gcov_file)\n+        {\n+          fnotice (stdout, \"Creating '%s'\\n\", gcov_file_name);\n+          output_lines (gcov_file, src);\n+          if (ferror (gcov_file))\n+            fnotice (stderr, \"Error writing output file '%s'\\n\", gcov_file_name);\n+          fclose (gcov_file);\n+        }\n+      else\n+        fnotice (stderr, \"Could not open output file '%s'\\n\", gcov_file_name);\n+    }\n+  else\n+    {\n+      unlink (gcov_file_name);\n+      fnotice (stdout, \"Removing '%s'\\n\", gcov_file_name);\n+    }\n+  free (gcov_file_name);\n+}\n+\n static void\n generate_results (const char *file_name)\n {\n   unsigned ix;\n   source_t *src;\n   function_t *fn;\n+  FILE *gcov_intermediate_file = NULL;\n+  char *gcov_intermediate_filename = NULL;\n \n   for (ix = n_sources, src = sources; ix--; src++)\n     if (src->num_lines)\n@@ -670,7 +826,7 @@ generate_results (const char *file_name)\n       coverage_t coverage;\n \n       memset (&coverage, 0, sizeof (coverage));\n-      coverage.name = fn->name;\n+      coverage.name = flag_demangled_names ? fn->demangled_name : fn->name;\n       add_line_counts (flag_function_summary ? &coverage : NULL, fn);\n       if (flag_function_summary)\n \t{\n@@ -688,7 +844,21 @@ generate_results (const char *file_name)\n       else\n \tfile_name = canonicalize_name (file_name);\n     }\n-  \n+\n+  if (flag_gcov_file && flag_intermediate_format)\n+    {\n+      /* Open the intermediate file.  */\n+      gcov_intermediate_filename =\n+        get_gcov_intermediate_filename (file_name);\n+      gcov_intermediate_file = fopen (gcov_intermediate_filename, \"w\");\n+      if (!gcov_intermediate_file)\n+        {\n+          fnotice (stderr, \"Cannot open intermediate output file %s\\n\",\n+                   gcov_intermediate_filename);\n+          return;\n+        }\n+    }\n+\n   for (ix = n_sources, src = sources; ix--; src++)\n     {\n       if (flag_relative_only)\n@@ -711,34 +881,21 @@ generate_results (const char *file_name)\n       total_executed += src->coverage.lines_executed;\n       if (flag_gcov_file)\n \t{\n-\t  char *gcov_file_name\n-\t    = make_gcov_file_name (file_name, src->coverage.name);\n-\n-\t  if (src->coverage.lines)\n-\t    {\n-\t      FILE *gcov_file = fopen (gcov_file_name, \"w\");\n+          if (flag_intermediate_format)\n+            /* Output the intermediate format without requiring source\n+               files.  This outputs a section to a *single* file.  */\n+            output_intermediate_file (gcov_intermediate_file, src);\n+          else\n+            output_gcov_file (file_name, src);\n+          fnotice (stdout, \"\\n\");\n+        }\n+    }\n \n-\t      if (gcov_file)\n-\t\t{\n-\t\t  fnotice (stdout, \"Creating '%s'\\n\", gcov_file_name);\n-\t\t  output_lines (gcov_file, src);\n-\t\t  if (ferror (gcov_file))\n-\t\t    fnotice (stderr, \"Error writing output file '%s'\\n\",\n-\t\t\t     gcov_file_name);\n-\t\t  fclose (gcov_file);\n-\t\t}\n-\t      else\n-\t\tfnotice (stderr, \"Could not open output file '%s'\\n\",\n-\t\t\t gcov_file_name);\n-\t    }\n-\t  else\n-\t    {\n-\t      unlink (gcov_file_name);\n-\t      fnotice (stdout, \"Removing '%s'\\n\", gcov_file_name);\n-\t    }\n-\t  free (gcov_file_name);\n-\t}\n-      fnotice (stdout, \"\\n\");\n+  if (flag_gcov_file && flag_intermediate_format)\n+    {\n+      /* Now we've finished writing the intermediate file.  */\n+      fclose (gcov_intermediate_file);\n+      XDELETEVEC (gcov_intermediate_filename);\n     }\n \n   if (!file_name)\n@@ -765,6 +922,9 @@ release_function (function_t *fn)\n     }\n   free (fn->blocks);\n   free (fn->counts);\n+  if (flag_demangled_names && fn->demangled_name != fn->name)\n+    free (fn->demangled_name);\n+  free (fn->name);\n }\n \n /* Release all memory used.  */\n@@ -1050,6 +1210,12 @@ read_graph_file (void)\n \n \t  fn = XCNEW (function_t);\n \t  fn->name = function_name;\n+          if (flag_demangled_names)\n+            {\n+              fn->demangled_name = cplus_demangle (fn->name, DMGL_PARAMS);\n+              if (!fn->demangled_name)\n+                fn->demangled_name = fn->name;\n+            }\n \t  fn->ident = ident;\n \t  fn->lineno_checksum = lineno_checksum;\n \t  fn->cfg_checksum = cfg_checksum;\n@@ -2277,7 +2443,8 @@ output_lines (FILE *gcov_file, const source_t *src)\n \t    if (arc->fake)\n \t      return_count -= arc->count;\n \n-\t  fprintf (gcov_file, \"function %s\", fn->name);\n+\t  fprintf (gcov_file, \"function %s\", flag_demangled_names ?\n+                   fn->demangled_name : fn->name);\n \t  fprintf (gcov_file, \" called %s\",\n \t\t   format_gcov (called_count, 0, -1));\n \t  fprintf (gcov_file, \" returned %s\","}, {"sha": "93308ea07f238bc4a5c1b8747989b86517795a75", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -1,3 +1,8 @@\n+2013-06-19    <singhai@google.com>\n+\n+\t* g++.dg/gcov/gcov-8.C: New testcase.\n+\t* lib/gcov.exp: Handle intermediate format.\n+\n 2013-06-19  Wei Mi  <wmi@google.com>\n \n \tPR rtl-optimization/57518"}, {"sha": "7acab4672ff50d0a52d58bfe8ef5454ecf8abe8a", "filename": "gcc/testsuite/g++.dg/gcov/gcov-8.C", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgcov%2Fgcov-8.C?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -0,0 +1,35 @@\n+/* Verify that intermediate coverage format can be generated for simple code. */\n+\n+/* { dg-options \"-fprofile-arcs -ftest-coverage\" } */\n+/* { dg-do run { target native } } */\n+\n+class C {\n+public:\n+  C()\n+  {\n+    i = 0;\n+  }\n+  ~C() {}\n+  void seti (int j)\n+  {\n+    if (j > 0)\n+      i = j;\n+    else\n+      i = 0;\n+  }\n+private:\n+  int i;\n+};\n+\n+void foo()\n+{\n+  C c;\n+  c.seti (1);\n+}\n+\n+int main()\n+{\n+  foo();\n+}\n+\n+/* { dg-final { run-gcov intermediate { -i -b gcov-8.C } } } */"}, {"sha": "0527a706544c230f5a9e6edacb343b24aba21d7b", "filename": "gcc/testsuite/lib/gcov.exp", "status": "modified", "additions": 76, "deletions": 3, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc8a650e334f7d1796680c4f7176515ed283bcf8/gcc%2Ftestsuite%2Flib%2Fgcov.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcov.exp?ref=fc8a650e334f7d1796680c4f7176515ed283bcf8", "patch": "@@ -70,6 +70,61 @@ proc verify-lines { testname testcase file } {\n     return $failed\n }\n \n+\n+#\n+# verify-intermediate -- check that intermediate file has certain lines\n+#\n+# TESTNAME is the name of the test, including unique flags.\n+# TESTCASE is the name of the test.\n+# FILE is the name of the gcov output file.\n+#\n+# Checks are very loose, they are based on certain tags being present\n+# in the output. They do not check for exact expected execution\n+# counts. For that the regular gcov format should be checked.\n+#\n+proc verify-intermediate { testname testcase file } {\n+    set failed 0\n+    set srcfile 0\n+    set function 0\n+    set lcount 0\n+    set branch 0\n+    set fd [open $file r]\n+    while { [gets $fd line] >= 0 } {\n+\tif [regexp \"^file:\" $line] {\n+\t    incr srcfile\n+\t}\n+\tif [regexp \"^function:(\\[0-9\\]+),(\\[0-9\\]+),.*\" $line] {\n+\t    incr function\n+\t}\n+\tif [regexp \"^lcount:(\\[0-9\\]+),(\\[0-9\\]+)\" $line] {\n+\t    incr lcount\n+\t}\n+\tif [regexp \"^branch:(\\[0-9\\]+),(taken|nottaken|notexec)\" $line] {\n+\t    incr branch\n+\t}\n+    }\n+\n+    # We should see at least one tag of each type\n+    if {$srcfile == 0} {\n+\tfail \"$testname expected 'file:' tag not found\"\n+\tincr failed\n+    }\n+    if {$function == 0} {\n+\tfail \"$testname expected 'function:' tag not found\"\n+\tincr failed\n+    }\n+    if {$lcount == 0} {\n+\tfail \"$testname expected 'lcount:' tag not found\"\n+\tincr failed\n+    }\n+    if {$branch == 0} {\n+\tfail \"$testname expected 'branch:' tag not found\"\n+\tincr failed\n+    }\n+    return $failed\n+}\n+\n+\n #\n # verify-branches -- check that branch percentages are as expected\n #\n@@ -248,13 +303,20 @@ proc run-gcov { args } {\n     set gcov_args \"\"\n     set gcov_verify_calls 0\n     set gcov_verify_branches 0\n+    set gcov_verify_lines 1\n+    set gcov_verify_intermediate 0\n     set xfailed 0\n \n     foreach a $args {\n \tif { $a == \"calls\" } {\n \t  set gcov_verify_calls 1\n \t} elseif { $a == \"branches\" } {\n \t  set gcov_verify_branches 1\n+\t} elseif { $a == \"intermediate\" } {\n+\t  set gcov_verify_intermediate 1\n+\t  set gcov_verify_calls 0\n+\t  set gcov_verify_branches 0\n+\t  set gcov_verify_lines 0\n \t} elseif { $gcov_args == \"\" } {\n \t    set gcov_args $a\n \t} else {\n@@ -295,7 +357,12 @@ proc run-gcov { args } {\n     remote_upload host $testcase.gcov $testcase.gcov\n \n     # Check that line execution counts are as expected.\n-    set lfailed [verify-lines $testname $testcase $testcase.gcov]\n+    if { $gcov_verify_lines } {\n+\t# Check that line execution counts are as expected.\n+\tset lfailed [verify-lines $testname $testcase $testcase.gcov]\n+    } else {\n+\tset lfailed 0\n+    }\n \n     # If requested via the .x file, check that branch and call information\n     # is correct.\n@@ -309,15 +376,21 @@ proc run-gcov { args } {\n     } else {\n \tset cfailed 0\n     }\n+    if { $gcov_verify_intermediate } {\n+\t# Check that intermediate format has the expected format\n+\tset ifailed [verify-intermediate $testname $testcase $testcase.gcov]\n+    } else {\n+\tset ifailed 0\n+    }\n \n     # Report whether the gcov test passed or failed.  If there were\n     # multiple failures then the message is a summary.\n-    set tfailed [expr $lfailed + $bfailed + $cfailed]\n+    set tfailed [expr $lfailed + $bfailed + $cfailed + $ifailed]\n     if { $xfailed } {\n \tsetup_xfail \"*-*-*\"\n     }\n     if { $tfailed > 0 } {\n-\tfail \"$testname gcov: $lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages\"\n+\tfail \"$testname gcov: $lfailed failures in line counts, $bfailed in branch percentages, $cfailed in return percentages, $ifailed in intermediate format\"\n     } else {\n \tpass \"$testname gcov\"\n \tclean-gcov $testcase"}]}