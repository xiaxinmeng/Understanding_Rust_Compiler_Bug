{"sha": "28531dd03ee0eb214fe946e6500964c7d7f4d021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1MzFkZDAzZWUwZWIyMTRmZTk0NmU2NTAwOTY0YzdkN2Y0ZDAyMQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-01-31T04:03:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-01-31T04:03:01Z"}, "message": "class.c (build_vtable): Rename to build_primary_vtable.\n\n\t* cp/class.c (build_vtable): Rename to build_primary_vtable.\n\t(prepare_fresh_vtable): Rename to build_secondary_vtable.\n\t(make_new_vtable): New function.\n\t(modify_vtable_entry): Handle generation of new vtables correctly.\n\t(modify_one_vtable): Remove unused parameter.\n\t(dfs_fixup_vtable_deltas): Likewise.\n\t(override_one_vtable): Use build_secondary_vtable.\n\t(finish_struct_1): Use build_primary_vtable and\n\tbuild_secondary_vtable.\n\nFrom-SVN: r31707", "tree": {"sha": "f27e6628ae5ae35dae3e393efa320b936964ad07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f27e6628ae5ae35dae3e393efa320b936964ad07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28531dd03ee0eb214fe946e6500964c7d7f4d021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28531dd03ee0eb214fe946e6500964c7d7f4d021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28531dd03ee0eb214fe946e6500964c7d7f4d021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28531dd03ee0eb214fe946e6500964c7d7f4d021/comments", "author": null, "committer": null, "parents": [{"sha": "1d682cca6ec62698ace4bf6808048eeb71c77f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d682cca6ec62698ace4bf6808048eeb71c77f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d682cca6ec62698ace4bf6808048eeb71c77f03"}], "stats": {"total": 158, "additions": 105, "deletions": 53}, "files": [{"sha": "b5198b3daa4b6eaa2673be71d05d91f5ee643a07", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=28531dd03ee0eb214fe946e6500964c7d7f4d021", "patch": "@@ -1,3 +1,15 @@\n+2000-01-30  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp/class.c (build_vtable): Rename to build_primary_vtable.\n+\t(prepare_fresh_vtable): Rename to build_secondary_vtable.\n+\t(make_new_vtable): New function.\n+\t(modify_vtable_entry): Handle generation of new vtables correctly.\n+\t(modify_one_vtable): Remove unused parameter.\n+\t(dfs_fixup_vtable_deltas): Likewise.\n+\t(override_one_vtable): Use build_secondary_vtable.\n+\t(finish_struct_1): Use build_primary_vtable and\n+\tbuild_secondary_vtable.\n+\t\n 2000-01-28  Ulrich Drepper  <drepper@redhat.com>\n \n \t* cp/decl.c: Adjust variable names, comments, help strings."}, {"sha": "81692f2520846baf6c96b6694f91a4710f5747a2", "filename": "gcc/cp/class.c", "status": "modified", "additions": 76, "deletions": 53, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=28531dd03ee0eb214fe946e6500964c7d7f4d021", "patch": "@@ -80,12 +80,12 @@ static tree get_vtable_name PARAMS ((tree));\n static tree get_derived_offset PARAMS ((tree, tree));\n static tree get_basefndecls PARAMS ((tree, tree));\n static void set_rtti_entry PARAMS ((tree, tree, tree));\n-static void build_vtable PARAMS ((tree, tree));\n-static void prepare_fresh_vtable PARAMS ((tree, tree));\n+static int build_primary_vtable PARAMS ((tree, tree));\n+static int build_secondary_vtable PARAMS ((tree, tree));\n static tree dfs_fixup_vtable_deltas PARAMS ((tree, void *));\n static tree dfs_finish_vtbls PARAMS ((tree, void *));\n static void finish_vtbls PARAMS ((tree));\n-static void modify_vtable_entry PARAMS ((tree, tree, tree, tree));\n+static void modify_vtable_entry PARAMS ((tree, tree, tree, tree *));\n static void add_virtual_function PARAMS ((tree *, tree *, int *, tree, tree));\n static tree delete_duplicate_fields_1 PARAMS ((tree, tree));\n static void delete_duplicate_fields PARAMS ((tree));\n@@ -151,6 +151,7 @@ static tree dfs_count_virtuals PARAMS ((tree, void *));\n static void start_vtable PARAMS ((tree, int *));\n static void layout_vtable_decl PARAMS ((tree, int));\n static int num_vfun_entries PARAMS ((tree));\n+static int make_new_vtable PARAMS ((tree, tree));\n \n /* Variables shared between class.c and call.c.  */\n \n@@ -903,7 +904,7 @@ get_vtable_name (type)\n   int i;\n   for (i = 0; ptr[i] == OPERATOR_TYPENAME_FORMAT[i]; i++) ;\n #if 0\n-  /* We don't take off the numbers; prepare_fresh_vtable uses the\n+  /* We don't take off the numbers; build_secondary_vtable uses the\n      DECL_ASSEMBLER_NAME for the type, which includes the number\n      in `3foo'.  If we were to pull them off here, we'd end up with\n      something like `_vt.foo.3bar', instead of a uniform definition.  */\n@@ -1042,13 +1043,14 @@ tree get_vtable_decl (type, complete)\n   return decl;\n }\n \n-/* Build a virtual function for type TYPE.\n-   If BINFO is non-NULL, build the vtable starting with the initial\n-   approximation that it is the same as the one which is the head of\n-   the association list.  */\n+/* Build the primary virtual function table for TYPE.  If BINFO is\n+   non-NULL, build the vtable starting with the initial approximation\n+   that it is the same as the one which is the head of the association\n+   list.  Returns a non-zero value if a new vtable is actually\n+   created.  */\n \n-static void\n-build_vtable (binfo, type)\n+static int\n+build_primary_vtable (binfo, type)\n      tree binfo, type;\n {\n   tree virtuals, decl;\n@@ -1062,8 +1064,8 @@ build_vtable (binfo, type)\n       if (BINFO_NEW_VTABLE_MARKED (binfo))\n \t/* We have already created a vtable for this base, so there's\n \t   no need to do it again.  */\n-\treturn;\n-\n+\treturn 0;\n+      \n       virtuals = copy_list (BINFO_VIRTUALS (binfo));\n       TREE_TYPE (decl) = TREE_TYPE (BINFO_VTABLE (binfo));\n       DECL_SIZE (decl) = TYPE_SIZE (TREE_TYPE (BINFO_VTABLE (binfo)));\n@@ -1092,6 +1094,7 @@ build_vtable (binfo, type)\n \n   binfo = TYPE_BINFO (type);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  return 1;\n }\n \n /* Give TYPE a new virtual function table which is initialized\n@@ -1108,8 +1111,8 @@ build_vtable (binfo, type)\n    an object must remain the same, otherwise a binary incompatibility\n    can result.  */\n \n-static void\n-prepare_fresh_vtable (binfo, for_type)\n+static int\n+build_secondary_vtable (binfo, for_type)\n      tree binfo, for_type;\n {\n   tree basetype;\n@@ -1129,7 +1132,7 @@ prepare_fresh_vtable (binfo, for_type)\n   if (BINFO_NEW_VTABLE_MARKED (binfo))\n     /* We already created a vtable for this base.  There's no need to\n        do it again.  */\n-    return;\n+    return 0;\n \n   basetype = TYPE_MAIN_VARIANT (BINFO_TYPE (binfo));\n \n@@ -1259,24 +1262,51 @@ prepare_fresh_vtable (binfo, for_type)\n \t\t\t\t\t\t  current_class_type),\n \t\t\t170);\n   SET_BINFO_NEW_VTABLE_MARKED (binfo);\n+  return 1;\n+}\n+\n+/* Create a new vtable for BINFO which is the hierarchy dominated by\n+   T.  */\n+\n+static int\n+make_new_vtable (t, binfo)\n+     tree t;\n+     tree binfo;\n+{\n+  if (binfo == TYPE_BINFO (t))\n+    /* In this case, it is *type*'s vtable we are modifying.  We start\n+       with the approximation that it's vtable is that of the\n+       immediate base class.  */\n+    return build_primary_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), \n+\t\t\t\t t);\n+  else\n+    /* This is our very own copy of `basetype' to play with.  Later,\n+       we will fill in all the virtual functions that override the\n+       virtual functions in these base classes which are not defined\n+       by the current type.  */\n+    return build_secondary_vtable (binfo, t);\n }\n \n-/* Make V, an entry on the BINFO_VIRTUALS list for BINFO (which is in\n-   the hierarchy dominated by T) list FNDECL as its BF_FN.  */\n+/* Make *VIRTUALS, an entry on the BINFO_VIRTUALS list for BINFO\n+   (which is in the hierarchy dominated by T) list FNDECL as its\n+   BF_FN.  */\n \n static void\n-modify_vtable_entry (t, binfo, fndecl, v)\n+modify_vtable_entry (t, binfo, fndecl, virtuals)\n      tree t;\n      tree binfo;\n      tree fndecl;\n-     tree v;\n+     tree *virtuals;\n {\n-  tree base_offset, offset;\n-  tree context = DECL_CLASS_CONTEXT (fndecl);\n-  tree vfield = TYPE_VFIELD (t);\n+  tree base_offset;\n+  tree offset;\n+  tree context;\n   tree this_offset;\n   tree vcall_index;\n+  tree v;\n \n+  v = *virtuals;\n+  context = DECL_CLASS_CONTEXT (fndecl);\n   offset = get_class_offset (context, t, binfo, fndecl);\n \n   /* Find the right offset for ythe this pointer based on the\n@@ -1300,18 +1330,17 @@ modify_vtable_entry (t, binfo, fndecl, v)\n     {\n       tree base_fndecl;\n \n-      /* Make sure we can modify the derived association with immunity.  */\n-      if (binfo == TYPE_BINFO (t))\n-\t/* In this case, it is *type*'s vtable we are modifying.  We\n-\t   start with the approximation that it's vtable is that of\n-\t   the immediate base class.  */\n-\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (vfield)), t);\n-      else\n-\t/* This is our very own copy of `basetype' to play with.\n-\t   Later, we will fill in all the virtual functions that\n-\t   override the virtual functions in these base classes which\n-\t   are not defined by the current type.  */\n-\tprepare_fresh_vtable (binfo, t);\n+      /* We need a new vtable for BINFO.  */\n+      if (make_new_vtable (t, binfo))\n+\t{\n+\t  /* If we really did make a new vtable, we also made a copy\n+\t     of the BINFO_VIRTUALS list.  Now, we have to find the\n+\t     corresponding entry in that list.  */\n+\t  *virtuals = BINFO_VIRTUALS (binfo);\n+\t  while (BF_FN (*virtuals) != BF_FN (v))\n+\t    *virtuals = TREE_CHAIN (*virtuals);\n+\t  v = *virtuals;\n+\t}\n \n       base_fndecl = BF_FN (v);\n       BF_DELTA (v) = this_offset;\n@@ -2948,24 +2977,19 @@ modify_one_vtable (binfo, t, fndecl)\n      tree binfo, t, fndecl;\n {\n   tree virtuals;\n-  unsigned HOST_WIDE_INT n;\n   \n   /* If we're support RTTI then we always need a new vtable to point\n      to the RTTI information.  Under the new ABI we may need a new\n      vtable to contain vcall and vbase offsets.  */\n   if (flag_rtti || flag_new_abi)\n-    {\n-      if (binfo == TYPE_BINFO (t))\n-\tbuild_vtable (TYPE_BINFO (DECL_CONTEXT (TYPE_VFIELD (t))), t);\n-      else\n-\tprepare_fresh_vtable (binfo, t);\n-    }\n+    make_new_vtable (t, binfo);\n+\n   if (fndecl == NULL_TREE)\n     return;\n \n-  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n+  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n        virtuals;\n-       virtuals = TREE_CHAIN (virtuals), ++n)\n+       virtuals = TREE_CHAIN (virtuals))\n     {\n       tree current_fndecl = BF_FN (virtuals);\n \n@@ -2977,7 +3001,7 @@ modify_one_vtable (binfo, t, fndecl)\n \t\t\t  19990727);\n \n       if (current_fndecl && overrides (fndecl, current_fndecl))\n-\tmodify_vtable_entry (t, binfo, fndecl, virtuals);\n+\tmodify_vtable_entry (t, binfo, fndecl, &virtuals);\n     }\n }\n \n@@ -3088,7 +3112,6 @@ dfs_fixup_vtable_deltas (binfo, data)\n      void *data;\n {\n   tree virtuals;\n-  unsigned HOST_WIDE_INT n;\n   tree t = (tree) data;\n \n   while (BINFO_PRIMARY_MARKED_P (binfo))\n@@ -3099,14 +3122,14 @@ dfs_fixup_vtable_deltas (binfo, data)\n \treturn NULL_TREE;\n     }\n \n-  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), &n);\n+  for (virtuals = skip_rtti_stuff (binfo, BINFO_TYPE (binfo), NULL);\n        virtuals;\n-       virtuals = TREE_CHAIN (virtuals), ++n)\n+       virtuals = TREE_CHAIN (virtuals))\n     {\n       tree fndecl = BF_FN (virtuals);\n \n       if (fndecl)\n-\tmodify_vtable_entry (t, binfo, fndecl, virtuals);\n+\tmodify_vtable_entry (t, binfo, fndecl, &virtuals);\n     }\n \n   return NULL_TREE;\n@@ -3194,7 +3217,7 @@ override_one_vtable (binfo, old, t)\n \t      choose = NEITHER;\n \t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n \t\t{\n-\t\t  prepare_fresh_vtable (binfo, t);\n+\t\t  build_secondary_vtable (binfo, t);\n \t\t  override_one_vtable (binfo, old, t);\n \t\t  return;\n \t\t}\n@@ -3209,7 +3232,7 @@ override_one_vtable (binfo, old, t)\n \t      choose = NEITHER;\n \t      if (! BINFO_NEW_VTABLE_MARKED (binfo))\n \t\t{\n-\t\t  prepare_fresh_vtable (binfo, t);\n+\t\t  build_secondary_vtable (binfo, t);\n \t\t  override_one_vtable (binfo, old, t);\n \t\t  return;\n \t\t}\n@@ -3225,7 +3248,7 @@ override_one_vtable (binfo, old, t)\n \t  choose = NEITHER;\n \t  if (! BINFO_NEW_VTABLE_MARKED (binfo))\n \t    {\n-\t      prepare_fresh_vtable (binfo, t);\n+\t      build_secondary_vtable (binfo, t);\n \t      override_one_vtable (binfo, old, t);\n \t      return;\n \t    }\n@@ -5146,12 +5169,12 @@ finish_struct_1 (t)\n \t      set_rtti_entry (new_virtuals,\n \t\t\t      convert (ssizetype, integer_zero_node), t);\n \t    }\n-\t  build_vtable (NULL_TREE, t);\n+\t  build_primary_vtable (NULL_TREE, t);\n \t}\n       else if (! BINFO_NEW_VTABLE_MARKED (TYPE_BINFO (t)))\n \t/* Here we know enough to change the type of our virtual\n \t   function table, but we will wait until later this function.  */\n-\tbuild_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n+\tbuild_primary_vtable (CLASSTYPE_PRIMARY_BINFO (t), t);\n \n       /* If this type has basetypes with constructors, then those\n \t constructors might clobber the virtual function table.  But"}, {"sha": "8b5338efd15d1f985a86d2aa85a3973ccb06bbe9", "filename": "gcc/testsuite/g++.old-deja/g++.other/virtual7.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28531dd03ee0eb214fe946e6500964c7d7f4d021/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fvirtual7.C?ref=28531dd03ee0eb214fe946e6500964c7d7f4d021", "patch": "@@ -0,0 +1,17 @@\n+// Build don't link:\n+// Special g++ Options: -fno-rtti\n+// Origin: Anthony Green <green@cygnus.com>\n+\n+class _JvObjectPrefix\n+{\n+protected:\n+  virtual void finalize (void) = 0;\n+};\n+\n+class Object : public _JvObjectPrefix\n+{\n+protected:\n+  virtual void finalize (void);\n+};\n+\n+Object x;"}]}