{"sha": "b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjJlMWJlYjNmNmI3ZTM3YmE3OTUwZTdkNzM0ODk1MTc2OGVhMmY3Mg==", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2007-08-14T08:39:00Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-14T08:39:00Z"}, "message": "exp_disp.ads, [...] (Build_Dispatch_Tables): Handle tagged types declared in the declarative part of a nested package body...\n\n2007-08-14  Ed Schonberg  <schonberg@adacore.com>\n\t    Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.ads, exp_disp.adb (Build_Dispatch_Tables): Handle tagged\n\ttypes declared in the declarative part of a nested package body or in\n\tthe proper body of a stub.\n\t(Set_All_DT_Position): Add missing check to avoid wrong assignation\n\tof the same dispatch table slot to renamed primitives.\n\t(Make_Select_Specific_Data_Table): Handle private types.\n\t(Tagged_Kind): Handle private types.\n\t(Make_Tags, Make_DT): Set tag entity as internal to ensure proper dg\n\toutput of implicit importation and exportation.\n\t(Expand_Interface_Thunk): Fix bug in the expansion assuming that the\n\tfirst formal of the thunk is always associated with the controlling\n\ttype. In addition perform the following code cleanup: remove formal\n\tThunk_Alias which is no longer required, cleanup evaluation of the\n\tthe controlling type, and update the documentation.\n\tReplace occurrence of Default_Prim_Op_Count by\n\tMax_Predef_Prims. Addition of compile-time check to verify\n\tthat the value of Max_Predef_Prims is correct.\n\t(Check_Premature_Freezing): Apply check in Ada95 mode as well.\n\t(Make_DT): Add parameter to indicate when type has been frozen by an\n\tobject declaration, for diagnostic purposes.\n\t(Build_Static_Dispatch_Tables): New subprogram that takes care of the\n\tconstruction of statically allocated dispatch tables.\n\t(Make_DT): In case of library-level tagged types export the declaration\n\tof the primary tag. Remove generation of tags (now done by Make_Tags).\n\tAdditional modifications to handle non-static generation of dispatch\n\ttables. Take care of building tables for asynchronous interface types\n\t(Make_Tags): New subprogram that generates the entities associated with\n\tthe primary and secondary tags of Typ and fills the contents of Access_\n\tDisp_Table. In case of library-level tagged types imports the forward\n\tdeclaration of the primary tag that will be declared later by Make_DT.\n\t(Expand_Interface_Conversion): In case of access types to interfaces\n\treplace an itype declaration by an explicit type declaration to avoid\n\tproblems associated with the scope of such itype in transient blocks.\n\nFrom-SVN: r127418", "tree": {"sha": "d4efd163d6df2c16952d272ae73419ac96fdf0e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d4efd163d6df2c16952d272ae73419ac96fdf0e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "04df6250f65043292762291a9e5d8092f8117318", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04df6250f65043292762291a9e5d8092f8117318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04df6250f65043292762291a9e5d8092f8117318"}], "stats": {"total": 1718, "additions": 1050, "deletions": 668}, "files": [{"sha": "1eb0624c287ce2fd3c0ac192975be71496d6665d", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 1010, "deletions": 644, "changes": 1654, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "patch": "@@ -37,7 +37,6 @@ with Exp_Tss;  use Exp_Tss;\n with Exp_Util; use Exp_Util;\n with Freeze;   use Freeze;\n with Itypes;   use Itypes;\n-with Lib;      use Lib;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Namet;    use Namet;\n@@ -91,6 +90,148 @@ package body Exp_Disp is\n    --  Ada 2005 (AI-345): Determine the tagged kind of T and return a reference\n    --  to an RE_Tagged_Kind enumeration value.\n \n+   ----------------------------------\n+   -- Build_Static_Dispatch_Tables --\n+   ----------------------------------\n+\n+   procedure Build_Static_Dispatch_Tables (N : Entity_Id) is\n+      Target_List : List_Id;\n+\n+      procedure Build_Dispatch_Tables (List : List_Id);\n+      --  Build the static dispatch table of tagged types found in the list of\n+      --  declarations. The generated nodes are added at the end of Target_List\n+\n+      procedure Build_Package_Dispatch_Tables (N : Node_Id);\n+      --  Build static dispatch tables associated with package declaration N\n+\n+      ---------------------------\n+      -- Build_Dispatch_Tables --\n+      ---------------------------\n+\n+      procedure Build_Dispatch_Tables (List : List_Id) is\n+         D : Node_Id;\n+\n+      begin\n+         D := First (List);\n+         while Present (D) loop\n+\n+            --  Handle nested packages and package bodies recursively. The\n+            --  generated code is placed on the Target_List established for\n+            --  the enclosing compilation unit.\n+\n+            if Nkind (D) = N_Package_Declaration then\n+               Build_Package_Dispatch_Tables (D);\n+\n+            elsif Nkind (D) = N_Package_Body then\n+               Build_Dispatch_Tables (Declarations (D));\n+\n+            elsif Nkind (D) = N_Package_Body_Stub\n+              and then Present (Library_Unit (D))\n+            then\n+               Build_Dispatch_Tables\n+                 (Declarations (Proper_Body (Unit (Library_Unit (D)))));\n+\n+            --  Handle full type declarations and derivations of library\n+            --  level tagged types\n+\n+            elsif (Nkind (D) = N_Full_Type_Declaration\n+                     or else Nkind (D) = N_Derived_Type_Definition)\n+              and then Is_Library_Level_Tagged_Type (Defining_Entity (D))\n+              and then Ekind (Defining_Entity (D)) /= E_Record_Subtype\n+              and then not Is_Private_Type (Defining_Entity (D))\n+            then\n+               Insert_List_After_And_Analyze (Last (Target_List),\n+                 Make_DT (Defining_Entity (D)));\n+\n+            --  Handle private types of library level tagged types. We must\n+            --  exchange the private and full-view to ensure the correct\n+            --  expansion.\n+\n+            elsif (Nkind (D) = N_Private_Type_Declaration\n+                     or else Nkind (D) = N_Private_Extension_Declaration)\n+               and then Present (Full_View (Defining_Entity (D)))\n+               and then Is_Library_Level_Tagged_Type\n+                          (Full_View (Defining_Entity (D)))\n+               and then Ekind (Full_View (Defining_Entity (D)))\n+                          /= E_Record_Subtype\n+            then\n+               declare\n+                  E1, E2 : Entity_Id;\n+               begin\n+                  E1 := Defining_Entity (D);\n+                  E2 := Full_View (Defining_Entity (D));\n+                  Exchange_Entities (E1, E2);\n+                  Insert_List_After_And_Analyze (Last (Target_List),\n+                    Make_DT (E1));\n+                  Exchange_Entities (E1, E2);\n+               end;\n+            end if;\n+\n+            Next (D);\n+         end loop;\n+      end Build_Dispatch_Tables;\n+\n+      -----------------------------------\n+      -- Build_Package_Dispatch_Tables --\n+      -----------------------------------\n+\n+      procedure Build_Package_Dispatch_Tables (N : Node_Id) is\n+         Spec       : constant Node_Id   := Specification (N);\n+         Id         : constant Entity_Id := Defining_Entity (N);\n+         Vis_Decls  : constant List_Id   := Visible_Declarations (Spec);\n+         Priv_Decls : constant List_Id   := Private_Declarations (Spec);\n+\n+      begin\n+         Push_Scope (Id);\n+\n+         if Present (Priv_Decls) then\n+            Build_Dispatch_Tables (Vis_Decls);\n+            Build_Dispatch_Tables (Priv_Decls);\n+\n+         elsif Present (Vis_Decls) then\n+            Build_Dispatch_Tables (Vis_Decls);\n+         end if;\n+\n+         Pop_Scope;\n+      end Build_Package_Dispatch_Tables;\n+\n+   --  Start of processing for Build_Static_Dispatch_Tables\n+\n+   begin\n+      if not Expander_Active\n+        or else VM_Target /= No_VM\n+      then\n+         return;\n+      end if;\n+\n+      if Nkind (N) = N_Package_Declaration then\n+         declare\n+            Spec       : constant Node_Id := Specification (N);\n+            Vis_Decls  : constant List_Id := Visible_Declarations (Spec);\n+            Priv_Decls : constant List_Id := Private_Declarations (Spec);\n+\n+         begin\n+            if Present (Priv_Decls)\n+              and then Is_Non_Empty_List (Priv_Decls)\n+            then\n+               Target_List := Priv_Decls;\n+\n+            elsif not Present (Vis_Decls) then\n+               Target_List := New_List;\n+               Set_Private_Declarations (Spec, Target_List);\n+            else\n+               Target_List := Vis_Decls;\n+            end if;\n+\n+            Build_Package_Dispatch_Tables (N);\n+         end;\n+\n+      else pragma Assert (Nkind (N) = N_Package_Body);\n+         Target_List := Declarations (N);\n+         Build_Dispatch_Tables (Target_List);\n+      end if;\n+   end Build_Static_Dispatch_Tables;\n+\n    ------------------------------\n    -- Default_Prim_Op_Position --\n    ------------------------------\n@@ -573,12 +714,9 @@ package body Exp_Disp is\n       Etyp        : constant Entity_Id  := Etype (N);\n       Operand     : constant Node_Id    := Expression (N);\n       Operand_Typ : Entity_Id           := Etype (Operand);\n-      Fent        : Entity_Id;\n       Func        : Node_Id;\n       Iface_Typ   : Entity_Id           := Etype (N);\n       Iface_Tag   : Entity_Id;\n-      New_Itype   : Entity_Id;\n-      Stats       : List_Id;\n \n    begin\n       --  Ada 2005 (AI-345): Handle synchronized interface type derivations\n@@ -672,19 +810,25 @@ package body Exp_Disp is\n          --  data returned by IW_Convert to indicate that this is a dispatching\n          --  call.\n \n-         New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n-         Set_Etype       (New_Itype, New_Itype);\n-         Init_Esize      (New_Itype);\n-         Init_Size_Align (New_Itype);\n-         Set_Directly_Designated_Type (New_Itype, Etyp);\n+         declare\n+            New_Itype : Entity_Id;\n \n-         Rewrite (N, Make_Explicit_Dereference (Loc,\n-                          Unchecked_Convert_To (New_Itype,\n-                            Relocate_Node (N))));\n-         Analyze (N);\n-         Freeze_Itype (New_Itype, N);\n+         begin\n+            New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n+            Set_Etype       (New_Itype, New_Itype);\n+            Init_Esize      (New_Itype);\n+            Init_Size_Align (New_Itype);\n+            Set_Directly_Designated_Type (New_Itype, Etyp);\n \n-         return;\n+            Rewrite (N,\n+              Make_Explicit_Dereference (Loc,\n+                Prefix =>\n+                  Unchecked_Convert_To (New_Itype, Relocate_Node (N))));\n+            Analyze (N);\n+            Freeze_Itype (New_Itype, N);\n+\n+            return;\n+         end;\n       end if;\n \n       Iface_Tag := Find_Interface_Tag (Operand_Typ, Iface_Typ);\n@@ -709,118 +853,152 @@ package body Exp_Disp is\n          --  the value of the displaced actual. That is:\n \n          --     function Func (O : Address) return Iface_Typ is\n+         --        type Op_Typ is access all Operand_Typ;\n+         --        Aux : Op_Typ := To_Op_Typ (O);\n          --     begin\n          --        if O = Null_Address then\n          --           return null;\n          --        else\n-         --           return Iface_Typ!(Operand_Typ!(O).Iface_Tag'Address);\n+         --           return Iface_Typ!(Aux.Iface_Tag'Address);\n          --        end if;\n          --     end Func;\n \n-         Fent := Make_Defining_Identifier (Loc, New_Internal_Name ('F'));\n-\n          declare\n-            Desig_Typ : Entity_Id;\n+            Decls        : List_Id;\n+            Desig_Typ    : Entity_Id;\n+            Fent         : Entity_Id;\n+            New_Typ_Decl : Node_Id;\n+            New_Obj_Decl : Node_Id;\n+            Stats        : List_Id;\n+\n          begin\n             Desig_Typ := Etype (Expression (N));\n \n             if Is_Access_Type (Desig_Typ) then\n                Desig_Typ := Directly_Designated_Type (Desig_Typ);\n             end if;\n \n-            New_Itype := Create_Itype (E_Anonymous_Access_Type, N);\n-            Set_Etype       (New_Itype, New_Itype);\n-            Set_Scope       (New_Itype, Fent);\n-            Init_Size_Align (New_Itype);\n-            Set_Directly_Designated_Type (New_Itype, Desig_Typ);\n-         end;\n+            New_Typ_Decl :=\n+              Make_Full_Type_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc, New_Internal_Name ('T')),\n+                Type_Definition =>\n+                  Make_Access_To_Object_Definition (Loc,\n+                    All_Present            => True,\n+                    Null_Exclusion_Present => False,\n+                    Constant_Present       => False,\n+                    Subtype_Indication     =>\n+                      New_Reference_To (Desig_Typ, Loc)));\n \n-         Stats := New_List (\n-           Make_Return_Statement (Loc,\n-             Unchecked_Convert_To (Etype (N),\n-               Make_Attribute_Reference (Loc,\n-                 Prefix =>\n-                   Make_Selected_Component (Loc,\n-                     Prefix => Unchecked_Convert_To (New_Itype,\n-                                 Make_Identifier (Loc, Name_uO)),\n-                     Selector_Name =>\n-                       New_Occurrence_Of (Iface_Tag, Loc)),\n-                 Attribute_Name => Name_Address))));\n+            New_Obj_Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier =>\n+                  Make_Defining_Identifier (Loc,\n+                    New_Internal_Name ('S')),\n+                Constant_Present => True,\n+                Object_Definition =>\n+                  New_Reference_To (Defining_Identifier (New_Typ_Decl), Loc),\n+                Expression =>\n+                  Unchecked_Convert_To (Defining_Identifier (New_Typ_Decl),\n+                    Make_Identifier (Loc, Name_uO)));\n \n-         --  If the type is null-excluding, no need for the null branch.\n-         --  Otherwise we need to check for it and return null.\n+            Decls := New_List (\n+              New_Typ_Decl,\n+              New_Obj_Decl);\n \n-         if not Can_Never_Be_Null (Etype (N)) then\n             Stats := New_List (\n-              Make_If_Statement (Loc,\n-               Condition       =>\n-                 Make_Op_Eq (Loc,\n-                    Left_Opnd  => Make_Identifier (Loc, Name_uO),\n-                    Right_Opnd => New_Reference_To\n-                                    (RTE (RE_Null_Address), Loc)),\n-\n-              Then_Statements => New_List (\n-                Make_Return_Statement (Loc,\n-                  Make_Null (Loc))),\n-              Else_Statements => Stats));\n-         end if;\n+              Make_Simple_Return_Statement (Loc,\n+                Unchecked_Convert_To (Etype (N),\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      Make_Selected_Component (Loc,\n+                        Prefix =>\n+                          New_Reference_To\n+                            (Defining_Identifier (New_Obj_Decl),\n+                             Loc),\n+                        Selector_Name =>\n+                          New_Occurrence_Of (Iface_Tag, Loc)),\n+                    Attribute_Name => Name_Address))));\n \n-         Func :=\n-           Make_Subprogram_Body (Loc,\n-             Specification =>\n-               Make_Function_Specification (Loc,\n-                 Defining_Unit_Name       => Fent,\n+            --  If the type is null-excluding, no need for the null branch.\n+            --  Otherwise we need to check for it and return null.\n+\n+            if not Can_Never_Be_Null (Etype (N)) then\n+               Stats := New_List (\n+                 Make_If_Statement (Loc,\n+                  Condition       =>\n+                    Make_Op_Eq (Loc,\n+                       Left_Opnd  => Make_Identifier (Loc, Name_uO),\n+                       Right_Opnd => New_Reference_To\n+                                       (RTE (RE_Null_Address), Loc)),\n+\n+                 Then_Statements => New_List (\n+                   Make_Simple_Return_Statement (Loc,\n+                     Make_Null (Loc))),\n+                 Else_Statements => Stats));\n+            end if;\n \n-                 Parameter_Specifications => New_List (\n-                   Make_Parameter_Specification (Loc,\n-                     Defining_Identifier =>\n-                       Make_Defining_Identifier (Loc, Name_uO),\n-                     Parameter_Type =>\n-                       New_Reference_To (RTE (RE_Address), Loc))),\n+            Fent :=\n+              Make_Defining_Identifier (Loc,\n+                New_Internal_Name ('F'));\n \n-                 Result_Definition =>\n-                   New_Reference_To (Etype (N), Loc)),\n+            Func :=\n+              Make_Subprogram_Body (Loc,\n+                Specification =>\n+                  Make_Function_Specification (Loc,\n+                    Defining_Unit_Name => Fent,\n \n-             Declarations => Empty_List,\n+                    Parameter_Specifications => New_List (\n+                      Make_Parameter_Specification (Loc,\n+                        Defining_Identifier =>\n+                          Make_Defining_Identifier (Loc, Name_uO),\n+                        Parameter_Type =>\n+                          New_Reference_To (RTE (RE_Address), Loc))),\n \n-             Handled_Statement_Sequence =>\n-               Make_Handled_Sequence_Of_Statements (Loc, Stats));\n+                    Result_Definition =>\n+                      New_Reference_To (Etype (N), Loc)),\n \n-         --  Place function body before the expression containing the\n-         --  conversion. We suppress all checks because the body of the\n-         --  internally generated function already takes care of the case\n-         --  in which the actual is null; therefore there is no need to\n-         --  double check that the pointer is not null when the program\n-         --  executes the alternative that performs the type conversion).\n+                Declarations => Decls,\n \n-         Insert_Action (N, Func, Suppress => All_Checks);\n+                Handled_Statement_Sequence =>\n+                  Make_Handled_Sequence_Of_Statements (Loc, Stats));\n \n-         if Is_Access_Type (Etype (Expression (N))) then\n+            --  Place function body before the expression containing the\n+            --  conversion. We suppress all checks because the body of the\n+            --  internally generated function already takes care of the case\n+            --  in which the actual is null; therefore there is no need to\n+            --  double check that the pointer is not null when the program\n+            --  executes the alternative that performs the type conversion).\n \n-            --  Generate: Operand_Typ!(Expression.all)'Address\n+            Insert_Action (N, Func, Suppress => All_Checks);\n \n-            Rewrite (N,\n-              Make_Function_Call (Loc,\n-                Name => New_Reference_To (Fent, Loc),\n-                Parameter_Associations => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix  => Unchecked_Convert_To (Operand_Typ,\n-                                 Make_Explicit_Dereference (Loc,\n-                                   Relocate_Node (Expression (N)))),\n-                    Attribute_Name => Name_Address))));\n+            if Is_Access_Type (Etype (Expression (N))) then\n \n-         else\n-            --  Generate: Operand_Typ!(Expression)'Address\n+               --  Generate: Operand_Typ!(Expression.all)'Address\n \n-            Rewrite (N,\n-              Make_Function_Call (Loc,\n-                Name => New_Reference_To (Fent, Loc),\n-                Parameter_Associations => New_List (\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix  => Unchecked_Convert_To (Operand_Typ,\n-                                 Relocate_Node (Expression (N))),\n-                    Attribute_Name => Name_Address))));\n-         end if;\n+               Rewrite (N,\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (Fent, Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix  => Unchecked_Convert_To (Operand_Typ,\n+                                    Make_Explicit_Dereference (Loc,\n+                                      Relocate_Node (Expression (N)))),\n+                       Attribute_Name => Name_Address))));\n+\n+            else\n+               --  Generate: Operand_Typ!(Expression)'Address\n+\n+               Rewrite (N,\n+                 Make_Function_Call (Loc,\n+                   Name => New_Reference_To (Fent, Loc),\n+                   Parameter_Associations => New_List (\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix  => Unchecked_Convert_To (Operand_Typ,\n+                                    Relocate_Node (Expression (N))),\n+                       Attribute_Name => Name_Address))));\n+            end if;\n+         end;\n       end if;\n \n       Analyze (N);\n@@ -1014,12 +1192,11 @@ package body Exp_Disp is\n    ----------------------------\n \n    procedure Expand_Interface_Thunk\n-     (N           : Node_Id;\n-      Thunk_Alias : Entity_Id;\n-      Thunk_Id    : out Entity_Id;\n-      Thunk_Code  : out Node_Id)\n+     (Prim       : Node_Id;\n+      Thunk_Id   : out Entity_Id;\n+      Thunk_Code : out Node_Id)\n    is\n-      Loc             : constant Source_Ptr := Sloc (N);\n+      Loc             : constant Source_Ptr := Sloc (Prim);\n       Actuals         : constant List_Id    := New_List;\n       Decl            : constant List_Id    := New_List;\n       Formals         : constant List_Id    := New_List;\n@@ -1038,13 +1215,13 @@ package body Exp_Disp is\n       --  Give message if configurable run-time and Offset_To_Top unavailable\n \n       if not RTE_Available (RE_Offset_To_Top) then\n-         Error_Msg_CRT (\"abstract interface types\", N);\n+         Error_Msg_CRT (\"abstract interface types\", Prim);\n          return;\n       end if;\n \n       --  Traverse the list of alias to find the final target\n \n-      Target := Thunk_Alias;\n+      Target := Prim;\n       while Present (Alias (Target)) loop\n          Target := Alias (Target);\n       end loop;\n@@ -1076,15 +1253,7 @@ package body Exp_Disp is\n          Next_Formal (Formal);\n       end loop;\n \n-      if Ekind (First_Formal (Target)) = E_In_Parameter\n-        and then Ekind (Etype (First_Formal (Target)))\n-                  = E_Anonymous_Access_Type\n-      then\n-         Controlling_Typ :=\n-           Directly_Designated_Type (Etype (First_Formal (Target)));\n-      else\n-         Controlling_Typ := Etype (First_Formal (Target));\n-      end if;\n+      Controlling_Typ := Find_Dispatching_Type (Target);\n \n       Target_Formal := First_Formal (Target);\n       Formal        := First (Formals);\n@@ -1096,11 +1265,9 @@ package body Exp_Disp is\n          then\n             --  Generate:\n \n-            --     type T is access all <<type of the first formal>>\n-            --     S1 := Storage_Offset!(formal)\n-            --           - Offset_To_Top (Formal.Tag)\n-\n-            --  ... and the first actual of the call is generated as T!(S1)\n+            --     type T is access all <<type of the target formal>>\n+            --     S : Storage_Offset := Storage_Offset!(Formal)\n+            --                            - Offset_To_Top (address!(Formal))\n \n             Decl_2 :=\n               Make_Full_Type_Declaration (Loc,\n@@ -1144,7 +1311,8 @@ package body Exp_Disp is\n             Append_To (Decl, Decl_2);\n             Append_To (Decl, Decl_1);\n \n-            --  Reference the new first actual\n+            --  Reference the new actual. Generate:\n+            --    T!(S)\n \n             Append_To (Actuals,\n               Unchecked_Convert_To\n@@ -1154,9 +1322,9 @@ package body Exp_Disp is\n          elsif Etype (Target_Formal) = Controlling_Typ then\n             --  Generate:\n \n-            --     S1 := Storage_Offset!(Formal'Address)\n-            --           - Offset_To_Top (Formal.Tag)\n-            --     S2 := Tag_Ptr!(S3)\n+            --     S1 : Storage_Offset := Storage_Offset!(Formal'Address)\n+            --                             - Offset_To_Top (Formal'Address)\n+            --     S2 : Addr_Ptr := Addr_Ptr!(S1)\n \n             Decl_1 :=\n               Make_Object_Declaration (Loc,\n@@ -1200,11 +1368,12 @@ package body Exp_Disp is\n             Append_To (Decl, Decl_1);\n             Append_To (Decl, Decl_2);\n \n-            --  Reference the new first actual\n+            --  Reference the new actual. Generate:\n+            --    Target_Formal (S2.all)\n \n             Append_To (Actuals,\n               Unchecked_Convert_To\n-                (Etype (First_Entity (Target)),\n+                (Etype (Target_Formal),\n                  Make_Explicit_Dereference (Loc,\n                    New_Reference_To (Defining_Identifier (Decl_2), Loc))));\n \n@@ -1252,7 +1421,7 @@ package body Exp_Disp is\n               Handled_Statement_Sequence =>\n                 Make_Handled_Sequence_Of_Statements (Loc,\n                   Statements => New_List (\n-                    Make_Return_Statement (Loc,\n+                    Make_Simple_Return_Statement (Loc,\n                       Make_Function_Call (Loc,\n                         Name => New_Occurrence_Of (Target, Loc),\n                         Parameter_Associations => Actuals)))));\n@@ -1919,7 +2088,7 @@ package body Exp_Disp is\n          --    return To_Address (_T._task_id);\n \n          Ret :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression =>\n                Make_Unchecked_Type_Conversion (Loc,\n                  Subtype_Mark =>\n@@ -1938,7 +2107,7 @@ package body Exp_Disp is\n          --    return Null_Address;\n \n          Ret :=\n-           Make_Return_Statement (Loc,\n+           Make_Simple_Return_Statement (Loc,\n              Expression =>\n                New_Reference_To (RTE (RE_Null_Address), Loc));\n       end if;\n@@ -2262,30 +2431,71 @@ package body Exp_Disp is\n    --     ...\n    --     end;\n \n-   function Make_DT (Typ : Entity_Id) return List_Id is\n-      Loc              : constant Source_Ptr := Sloc (Typ);\n-      Is_Local_DT      : constant Boolean :=\n-                           Ekind (Cunit_Entity (Get_Source_Unit (Typ)))\n-                             /= E_Package;\n+   function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id is\n+      Loc : constant Source_Ptr := Sloc (Typ);\n+\n+      Has_DT : constant Boolean :=\n+                 not Is_Interface (Typ)\n+               and then not Restriction_Active (No_Dispatching_Calls);\n+\n+      Build_Static_DT : constant Boolean :=\n+                          Static_Dispatch_Tables\n+                            and then Is_Library_Level_Tagged_Type (Typ);\n+\n       Max_Predef_Prims : constant Int :=\n                            UI_To_Int\n                              (Intval\n                                (Expression\n-                                 (Parent (RTE (RE_Default_Prim_Op_Count)))));\n+                                 (Parent (RTE (RE_Max_Predef_Prims)))));\n+\n+      procedure Check_Premature_Freezing (Subp : Entity_Id; Typ : Entity_Id);\n+      --  Verify that all non-tagged types in the profile of a subprogram\n+      --  are frozen at the point the subprogram is frozen. This enforces\n+      --  the rule on RM 13.14 (14) as modified by AI05-019. At the point a\n+      --  subprogram is frozen, enough must be known about it to build the\n+      --  activation record for it, which requires at least that the size of\n+      --  all parameters be known. Controlling arguments are by-reference,\n+      --  and therefore the rule only applies to non-tagged types.\n+      --  Typical violation of the rule involves an object declaration that\n+      --  freezes a tagged type, when one of its primitive operations has a\n+      --  type in its profile whose full view has not been analyzed yet.\n \n       procedure Make_Secondary_DT\n-        (Typ             : Entity_Id;\n-         Iface           : Entity_Id;\n-         AI_Tag          : Entity_Id;\n-         Iface_DT_Ptr    : Entity_Id;\n-         Result          : List_Id);\n+        (Typ          : Entity_Id;\n+         Iface        : Entity_Id;\n+         AI_Tag       : Entity_Id;\n+         Iface_DT_Ptr : Entity_Id;\n+         Result       : List_Id);\n       --  Ada 2005 (AI-251): Expand the declarations for the Secondary Dispatch\n       --  Table of Typ associated with Iface (each abstract interface of Typ\n       --  has a secondary dispatch table). The arguments Typ, Ancestor_Typ\n       --  and Suffix_Index are used to generate an unique external name which\n       --  is added at the end of Acc_Disp_Tables; this external name will be\n       --  used later by the subprogram Exp_Ch3.Build_Init_Procedure.\n \n+      ------------------------------\n+      -- Check_Premature_Freezing --\n+      ------------------------------\n+\n+      procedure Check_Premature_Freezing (Subp : Entity_Id; Typ : Entity_Id) is\n+      begin\n+         if Present (N)\n+           and then  Is_Private_Type (Typ)\n+           and then No (Full_View (Typ))\n+           and then not Is_Generic_Type (Typ)\n+           and then not Is_Tagged_Type (Typ)\n+           and then not Is_Frozen (Typ)\n+         then\n+            Error_Msg_Sloc := Sloc (Subp);\n+            Error_Msg_NE\n+              (\"declaration must appear after completion of type &\", N, Typ);\n+            Error_Msg_NE\n+              (\"\\which is an untagged type in the profile of\"\n+               & \" primitive operation & declared#\",\n+               N, Subp);\n+         end if;\n+      end Check_Premature_Freezing;\n+\n       -----------------------\n       -- Make_Secondary_DT --\n       -----------------------\n@@ -2299,7 +2509,6 @@ package body Exp_Disp is\n       is\n          Loc                : constant Source_Ptr := Sloc (Typ);\n          Generalized_Tag    : constant Entity_Id := RTE (RE_Interface_Tag);\n-\n          Name_DT            : constant Name_Id := New_Internal_Name ('T');\n          Iface_DT           : constant Entity_Id :=\n                                 Make_Defining_Identifier (Loc, Name_DT);\n@@ -2321,12 +2530,10 @@ package body Exp_Disp is\n          Prim_Ops_Aggr_List : List_Id;\n \n       begin\n-         --  Handle the case where the backend does not support statically\n-         --  allocated dispatch tables.\n+         --  Handle cases in which we do not generate statically allocated\n+         --  dispatch tables.\n \n-         if not Static_Dispatch_Tables\n-           or else Is_Local_DT\n-         then\n+         if not Build_Static_DT then\n             Set_Ekind (Predef_Prims, E_Variable);\n             Set_Is_Statically_Allocated (Predef_Prims);\n \n@@ -2369,7 +2576,7 @@ package body Exp_Disp is\n \n          --  Stage 1: Calculate the number of predefined primitives\n \n-         if not Static_Dispatch_Tables then\n+         if not Build_Static_DT then\n             Nb_Predef_Prims := Max_Predef_Prims;\n          else\n             Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n@@ -2415,11 +2622,7 @@ package body Exp_Disp is\n                      Prim := Alias (Prim);\n                   end loop;\n \n-                  Expand_Interface_Thunk\n-                    (N           => Prim,\n-                     Thunk_Alias => Prim,\n-                     Thunk_Id    => Thunk_Id,\n-                     Thunk_Code  => Thunk_Code);\n+                  Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n                   if Present (Thunk_Id) then\n                      Append_To (Result, Thunk_Code);\n@@ -2447,7 +2650,7 @@ package body Exp_Disp is\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => Predef_Prims,\n-                Constant_Present    => Static_Dispatch_Tables,\n+                Constant_Present    => Build_Static_DT,\n                 Aliased_Present     => True,\n                 Object_Definition   =>\n                   New_Reference_To (RTE (RE_Address_Array), Loc),\n@@ -2627,6 +2830,16 @@ package body Exp_Disp is\n                       Expression => Make_Aggregate (Loc,\n                         Component_Associations => OSD_Aggr_List))))));\n \n+            Append_To (Result,\n+              Make_Attribute_Definition_Clause (Loc,\n+                Name       => New_Reference_To (OSD, Loc),\n+                Chars      => Name_Alignment,\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                    Attribute_Name => Name_Alignment)));\n+\n             --  In secondary dispatch tables the Typeinfo component contains\n             --  the address of the Object Specific Data (see a-tags.ads)\n \n@@ -2645,7 +2858,7 @@ package body Exp_Disp is\n               New_Reference_To (RTE (RE_Null_Address), Loc));\n \n          elsif Is_Abstract_Type (Typ)\n-           or else not Static_Dispatch_Tables\n+           or else not Build_Static_DT\n          then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List,\n@@ -2680,11 +2893,7 @@ package body Exp_Disp is\n \n                     and then not Is_Parent (Iface, Typ)\n                   then\n-                     Expand_Interface_Thunk\n-                       (N           => Prim,\n-                        Thunk_Alias => Alias (Prim),\n-                        Thunk_Id    => Thunk_Id,\n-                        Thunk_Code  => Thunk_Code);\n+                     Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n                      if Present (Thunk_Id) then\n                         Pos :=\n@@ -2733,6 +2942,16 @@ package body Exp_Disp is\n              Expression => Make_Aggregate (Loc,\n                Expressions => DT_Aggr_List)));\n \n+         Append_To (Result,\n+           Make_Attribute_Definition_Clause (Loc,\n+             Name       => New_Reference_To (Iface_DT, Loc),\n+             Chars      => Name_Alignment,\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix =>\n+                   New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                 Attribute_Name => Name_Alignment)));\n+\n          --  Generate code to create the pointer to the dispatch table\n \n          --    Iface_DT_Ptr : Tag := Tag!(DT'Address);\n@@ -2758,35 +2977,16 @@ package body Exp_Disp is\n \n       --  Local variables\n \n-      --  Seems a huge list, shouldn't some of these be commented???\n-      --  Seems like we are counting too much on guessing from names here???\n-\n       Elab_Code          : constant List_Id   := New_List;\n       Generalized_Tag    : constant Entity_Id := RTE (RE_Tag);\n-      Result             : constant List_Id := New_List;\n-      Tname              : constant Name_Id := Chars (Typ);\n-      Name_DT            : constant Name_Id := New_External_Name (Tname, 'T');\n-      Name_Exname        : constant Name_Id := New_External_Name (Tname, 'E');\n-      Name_Predef_Prims  : constant Name_Id := New_External_Name (Tname, 'R');\n-      Name_SSD           : constant Name_Id := New_External_Name (Tname, 'S');\n-      Name_TSD           : constant Name_Id := New_External_Name (Tname, 'B');\n-      DT                 : constant Entity_Id :=\n-                             Make_Defining_Identifier (Loc, Name_DT);\n-      Exname             : constant Entity_Id :=\n-                             Make_Defining_Identifier (Loc, Name_Exname);\n-      Predef_Prims       : constant Entity_Id :=\n-                             Make_Defining_Identifier (Loc, Name_Predef_Prims);\n-      SSD                : constant Entity_Id :=\n-                             Make_Defining_Identifier (Loc, Name_SSD);\n-      TSD                : constant Entity_Id :=\n-                             Make_Defining_Identifier (Loc, Name_TSD);\n+      Result             : constant List_Id   := New_List;\n+      Tname              : constant Name_Id   := Chars (Typ);\n       AI                 : Elmt_Id;\n       AI_Tag_Comp        : Elmt_Id;\n       AI_Ptr_Elmt        : Elmt_Id;\n       DT_Constr_List     : List_Id;\n       DT_Aggr_List       : List_Id;\n       DT_Ptr             : Entity_Id;\n-      Has_Dispatch_Table : Boolean := True;\n       ITable             : Node_Id;\n       I_Depth            : Nat := 0;\n       Iface_Table_Node   : Node_Id;\n@@ -2803,137 +3003,66 @@ package body Exp_Disp is\n       Prim               : Entity_Id;\n       Prim_Elmt          : Elmt_Id;\n       Prim_Ops_Aggr_List : List_Id;\n-      Transportable      : Entity_Id;\n-      RC_Offset_Node     : Node_Id;\n       Suffix_Index       : Int;\n       Typ_Comps          : Elist_Id;\n       Typ_Ifaces         : Elist_Id;\n       TSD_Aggr_List      : List_Id;\n       TSD_Tags_List      : List_Id;\n-      TSD_Ifaces_List    : List_Id;\n+\n+      --  The following name entries are used by Make_DT to generate a number\n+      --  of entities related to a tagged type. These entities may be generated\n+      --  in a scope other than that of the tagged type declaration, and if\n+      --  the entities for two tagged types with the same name happen to be\n+      --  generated in the same scope, we have to take care to use different\n+      --  names. This is achieved by means of a unique serial number appended\n+      --  to each generated entity name.\n+\n+      Name_DT           : constant Name_Id :=\n+                            New_External_Name (Tname, 'T', Suffix_Index => -1);\n+      Name_Exname       : constant Name_Id :=\n+                            New_External_Name (Tname, 'E', Suffix_Index => -1);\n+      Name_Predef_Prims : constant Name_Id :=\n+                            New_External_Name (Tname, 'R', Suffix_Index => -1);\n+      Name_SSD          : constant Name_Id :=\n+                            New_External_Name (Tname, 'S', Suffix_Index => -1);\n+      Name_TSD          : constant Name_Id :=\n+                            New_External_Name (Tname, 'B', Suffix_Index => -1);\n+\n+      --  Entities built with above names\n+\n+      DT           : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, Name_DT);\n+      Exname       : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, Name_Exname);\n+      Predef_Prims : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, Name_Predef_Prims);\n+      SSD          : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, Name_SSD);\n+      TSD          : constant Entity_Id :=\n+                       Make_Defining_Identifier (Loc, Name_TSD);\n \n    --  Start of processing for Make_DT\n \n    begin\n-      --  Fill the contents of Access_Disp_Table\n-\n-      --  1) Generate the primary and secondary tag entities\n-\n-      declare\n-         DT_Ptr       : Node_Id;\n-         Name_DT_Ptr  : Name_Id;\n-         Typ_Name     : Name_Id;\n-         Iface_DT_Ptr : Node_Id;\n-         Suffix_Index : Int;\n-         AI_Tag_Comp  : Elmt_Id;\n-\n-      begin\n-         --  Collect the components associated with secondary dispatch tables\n-\n-         if Has_Abstract_Interfaces (Typ) then\n-            Collect_Interface_Components (Typ, Typ_Comps);\n-         end if;\n-\n-         --  Generate the primary tag entity\n-\n-         Name_DT_Ptr := New_External_Name (Tname, 'P');\n-         DT_Ptr      := Make_Defining_Identifier (Loc, Name_DT_Ptr);\n-         Set_Ekind (DT_Ptr, E_Constant);\n-         Set_Is_Statically_Allocated (DT_Ptr);\n-         Set_Is_True_Constant (DT_Ptr);\n-\n-         pragma Assert (No (Access_Disp_Table (Typ)));\n-         Set_Access_Disp_Table (Typ, New_Elmt_List);\n-         Append_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n-\n-         --  Generate the secondary tag entities\n-\n-         if Has_Abstract_Interfaces (Typ) then\n-            Suffix_Index := 0;\n-\n-            --  For each interface type we build an unique external name\n-            --  associated with its corresponding secondary dispatch table.\n-            --  This external name will be used to declare an object that\n-            --  references this secondary dispatch table, value that will be\n-            --  used for the elaboration of Typ's objects and also for the\n-            --  elaboration of objects of derivations of Typ that do not\n-            --  override the primitive operation of this interface type.\n-\n-            AI_Tag_Comp := First_Elmt (Typ_Comps);\n-            while Present (AI_Tag_Comp) loop\n-               Get_Secondary_DT_External_Name\n-                 (Typ, Related_Interface (Node (AI_Tag_Comp)), Suffix_Index);\n-\n-               Typ_Name     := Name_Find;\n-               Name_DT_Ptr  := New_External_Name (Typ_Name, \"P\");\n-               Iface_DT_Ptr := Make_Defining_Identifier (Loc, Name_DT_Ptr);\n-\n-               Set_Ekind (Iface_DT_Ptr, E_Constant);\n-               Set_Is_Statically_Allocated (Iface_DT_Ptr);\n-               Set_Is_True_Constant (Iface_DT_Ptr);\n-               Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n-\n-               Next_Elmt (AI_Tag_Comp);\n-            end loop;\n-         end if;\n-      end;\n-\n-      --  2) At the end of Access_Disp_Table we add the entity of an access\n-      --     type declaration. It is used by Build_Get_Prim_Op_Address to\n-      --     expand dispatching calls through the primary dispatch table.\n-\n-      --     Generate:\n-      --       type Typ_DT is array (1 .. Nb_Prims) of Address;\n-      --       type Typ_DT_Acc is access Typ_DT;\n-\n-      declare\n-         Name_DT_Prims     : constant Name_Id :=\n-                               New_External_Name (Tname, 'G');\n-         Name_DT_Prims_Acc : constant Name_Id :=\n-                               New_External_Name (Tname, 'H');\n-         DT_Prims          : constant Entity_Id :=\n-                               Make_Defining_Identifier (Loc, Name_DT_Prims);\n-         DT_Prims_Acc      : constant Entity_Id :=\n-                               Make_Defining_Identifier (Loc,\n-                                 Name_DT_Prims_Acc);\n-      begin\n-         Append_To (Result,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => DT_Prims,\n-             Type_Definition =>\n-               Make_Constrained_Array_Definition (Loc,\n-                 Discrete_Subtype_Definitions => New_List (\n-                   Make_Range (Loc,\n-                     Low_Bound  => Make_Integer_Literal (Loc, 1),\n-                     High_Bound => Make_Integer_Literal (Loc,\n-                                    DT_Entry_Count\n-                                      (First_Tag_Component (Typ))))),\n-                 Component_Definition =>\n-                   Make_Component_Definition (Loc,\n-                     Subtype_Indication =>\n-                       New_Reference_To (RTE (RE_Address), Loc)))));\n-\n-         Append_To (Result,\n-           Make_Full_Type_Declaration (Loc,\n-             Defining_Identifier => DT_Prims_Acc,\n-             Type_Definition =>\n-                Make_Access_To_Object_Definition (Loc,\n-                  Subtype_Indication =>\n-                    New_Occurrence_Of (DT_Prims, Loc))));\n+      pragma Assert (Is_Frozen (Typ));\n \n-         Append_Elmt (DT_Prims_Acc, Access_Disp_Table (Typ));\n-      end;\n+      --  Handle cases in which there is no need to build the dispatch table\n \n-      if Is_CPP_Class (Typ) then\n+      if Has_Dispatch_Table (Typ)\n+        or else No (Access_Disp_Table (Typ))\n+        or else Is_CPP_Class (Typ)\n+      then\n          return Result;\n-      end if;\n \n-      if No_Run_Time_Mode or else not RTE_Available (RE_Tag) then\n-         DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n+      elsif No_Run_Time_Mode then\n+         Error_Msg_CRT (\"tagged types\", Typ);\n+         return Result;\n \n+      elsif not RTE_Available (RE_Tag) then\n          Append_To (Result,\n            Make_Object_Declaration (Loc,\n-             Defining_Identifier => DT_Ptr,\n+             Defining_Identifier => Node (First_Elmt\n+                                           (Access_Disp_Table (Typ))),\n              Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc),\n              Constant_Present    => True,\n              Expression =>\n@@ -2945,64 +3074,143 @@ package body Exp_Disp is\n          return Result;\n       end if;\n \n-      if not Static_Dispatch_Tables\n-        or else Is_Local_DT\n-      then\n-         Set_Ekind (DT, E_Variable);\n-         Set_Is_Statically_Allocated (DT);\n+      --  Ensure that the value of Max_Predef_Prims defined in a-tags is\n+      --  correct. Valid values are 10 under configurable runtime or 15\n+      --  with full runtime.\n+\n+      if RTE_Available (RE_Interface_Data) then\n+         if Max_Predef_Prims /= 15 then\n+            Error_Msg_N (\"run-time library configuration error\", Typ);\n+            return Result;\n+         end if;\n       else\n-         Set_Ekind (DT, E_Constant);\n-         Set_Is_Statically_Allocated (DT);\n-         Set_Is_True_Constant (DT);\n+         if Max_Predef_Prims /= 10 then\n+            Error_Msg_N (\"run-time library configuration error\", Typ);\n+            Error_Msg_CRT (\"tagged types\", Typ);\n+            return Result;\n+         end if;\n       end if;\n \n-      pragma Assert (Present (Access_Disp_Table (Typ)));\n-      DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n+      --  Ensure that all the primitives are frozen. This is only required when\n+      --  building static dispatch tables --- the primitives must be frozen to\n+      --  be referenced (otherwise we have problems with the backend). It is\n+      --  not a requirement with nonstatic dispatch tables because in this case\n+      --  we generate now an empty dispatch table; the extra code required to\n+      --  register the primitive in the slot will be generated later --- when\n+      --  each primitive is frozen (see Freeze_Subprogram).\n \n-      --  Ada 2005 (AI-251): Build the secondary dispatch tables\n+      if Build_Static_DT\n+        and then not Is_CPP_Class (Typ)\n+      then\n+         declare\n+            Save      : constant Boolean := Freezing_Library_Level_Tagged_Type;\n+            Prim_Elmt : Elmt_Id;\n+            Frnodes   : List_Id;\n \n-      if Has_Abstract_Interfaces (Typ) then\n-         Suffix_Index := 0;\n-         AI_Ptr_Elmt  := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+         begin\n+            Freezing_Library_Level_Tagged_Type := True;\n+            Prim_Elmt := First_Elmt (Primitive_Operations (Typ));\n+            while Present (Prim_Elmt) loop\n+               Frnodes := Freeze_Entity (Node (Prim_Elmt), Loc);\n \n-         AI_Tag_Comp := First_Elmt (Typ_Comps);\n-         while Present (AI_Tag_Comp) loop\n-            Make_Secondary_DT\n-              (Typ          => Typ,\n-               Iface        => Base_Type\n-                                 (Related_Interface (Node (AI_Tag_Comp))),\n-               AI_Tag       => Node (AI_Tag_Comp),\n-               Iface_DT_Ptr => Node (AI_Ptr_Elmt),\n-               Result       => Result);\n+               declare\n+                  Subp : constant Entity_Id := Node (Prim_Elmt);\n+                  F : Entity_Id;\n \n-            Suffix_Index := Suffix_Index + 1;\n-            Next_Elmt (AI_Ptr_Elmt);\n-            Next_Elmt (AI_Tag_Comp);\n-         end loop;\n-      end if;\n+               begin\n+                  F := First_Formal (Subp);\n+                  while Present (F) loop\n+                     Check_Premature_Freezing (Subp, Etype (F));\n+                     Next_Formal (F);\n+                  end loop;\n+\n+                  Check_Premature_Freezing (Subp, Etype (Subp));\n+               end;\n+\n+               if Present (Frnodes) then\n+                  Append_List_To (Result, Frnodes);\n+               end if;\n+\n+               Next_Elmt (Prim_Elmt);\n+            end loop;\n+            Freezing_Library_Level_Tagged_Type := Save;\n+         end;\n+      end if;\n \n-      --  Evaluate if we generate the dispatch table\n+      --  In case of locally defined tagged type we declare the object\n+      --  contanining the dispatch table by means of a variable. Its\n+      --  initialization is done later by means of an assignment. This is\n+      --  required to generate its External_Tag.\n+\n+      if not Build_Static_DT then\n+         DT_Ptr := Node (First_Elmt (Access_Disp_Table (Typ)));\n+         Set_Ekind (DT, E_Variable);\n+\n+      --  Export the declaration of the tag previously generated and imported\n+      --  by Make_Tags.\n+\n+      else\n+         DT_Ptr :=\n+           Make_Defining_Identifier (Loc,\n+             Chars => New_External_Name (Tname, 'C', Suffix_Index => -1));\n+         Set_Ekind (DT_Ptr, E_Constant);\n+         Set_Is_Statically_Allocated (DT_Ptr);\n+         Set_Is_True_Constant (DT_Ptr);\n+\n+         Set_Is_Exported (DT_Ptr);\n+         Get_External_Name (Node (First_Elmt (Access_Disp_Table (Typ))), True);\n+         Set_Interface_Name (DT_Ptr,\n+           Make_String_Literal (Loc,\n+             Strval => String_From_Name_Buffer));\n+\n+         --  Set tag as internal to ensure proper Sprint output of its implicit\n+         --  exportation.\n+\n+         Set_Is_Internal (DT_Ptr);\n+\n+         Set_Ekind (DT, E_Constant);\n+         Set_Is_True_Constant (DT);\n+\n+         --  The tag is made public to ensure its availability to the linker\n+         --  (to handle the forward reference). This is required to handle\n+         --  tagged types defined in library level package bodies.\n+\n+         Set_Is_Public (DT_Ptr);\n+      end if;\n+\n+      Set_Is_Statically_Allocated (DT);\n+\n+      --  Ada 2005 (AI-251): Build the secondary dispatch tables\n+\n+      if Has_Abstract_Interfaces (Typ) then\n+         Collect_Interface_Components (Typ, Typ_Comps);\n+\n+         Suffix_Index := 0;\n+         AI_Ptr_Elmt  := Next_Elmt (First_Elmt (Access_Disp_Table (Typ)));\n+\n+         AI_Tag_Comp := First_Elmt (Typ_Comps);\n+         while Present (AI_Tag_Comp) loop\n+            Make_Secondary_DT\n+              (Typ          => Typ,\n+               Iface        => Base_Type\n+                                 (Related_Interface (Node (AI_Tag_Comp))),\n+               AI_Tag       => Node (AI_Tag_Comp),\n+               Iface_DT_Ptr => Node (AI_Ptr_Elmt),\n+               Result       => Result);\n \n-      Has_Dispatch_Table :=\n-        not Is_Interface (Typ)\n-          and then not Restriction_Active (No_Dispatching_Calls);\n+            Suffix_Index := Suffix_Index + 1;\n+            Next_Elmt (AI_Ptr_Elmt);\n+            Next_Elmt (AI_Tag_Comp);\n+         end loop;\n+      end if;\n \n       --  Calculate the number of primitives of the dispatch table and the\n       --  size of the Type_Specific_Data record.\n \n-      if Has_Dispatch_Table then\n+      if Has_DT then\n          Nb_Prim := UI_To_Int (DT_Entry_Count (First_Tag_Component (Typ)));\n       end if;\n \n-      if not Static_Dispatch_Tables then\n-         Set_Ekind (Predef_Prims, E_Variable);\n-         Set_Is_Statically_Allocated (Predef_Prims);\n-      else\n-         Set_Ekind (Predef_Prims, E_Constant);\n-         Set_Is_Statically_Allocated (Predef_Prims);\n-         Set_Is_True_Constant (Predef_Prims);\n-      end if;\n-\n       Set_Ekind (SSD, E_Constant);\n       Set_Is_Statically_Allocated (SSD);\n       Set_Is_True_Constant (SSD);\n@@ -3020,7 +3228,7 @@ package body Exp_Disp is\n       --  multiple-called scopes.\n \n       if not Is_Interface (Typ) then\n-         Name_No_Reg := New_External_Name (Tname, 'F');\n+         Name_No_Reg := New_External_Name (Tname, 'F', Suffix_Index => -1);\n          No_Reg      := Make_Defining_Identifier (Loc, Name_No_Reg);\n \n          Set_Ekind (No_Reg, E_Variable);\n@@ -3038,13 +3246,14 @@ package body Exp_Disp is\n       --  initialization is done later by means of an assignment. This is\n       --  required to generate its External_Tag.\n \n-      if Is_Local_DT then\n+      if not Build_Static_DT then\n \n          --  Generate:\n          --    DT     : No_Dispatch_Table_Wrapper;\n+         --    for DT'Alignment use Address'Alignment;\n          --    DT_Ptr : Tag := !Tag (DT.NDT_Prims_Ptr'Address);\n \n-         if not Has_Dispatch_Table then\n+         if not Has_DT then\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT,\n@@ -3054,6 +3263,16 @@ package body Exp_Disp is\n                   New_Reference_To\n                     (RTE (RE_No_Dispatch_Table_Wrapper), Loc)));\n \n+            Append_To (Result,\n+              Make_Attribute_Definition_Clause (Loc,\n+                Name       => New_Reference_To (DT, Loc),\n+                Chars      => Name_Alignment,\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                    Attribute_Name => Name_Alignment)));\n+\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT_Ptr,\n@@ -3187,36 +3406,24 @@ package body Exp_Disp is\n       end;\n \n       Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of (RTE_Record_Component (RE_Idepth), Loc)),\n-          Expression =>\n-            Make_Integer_Literal (Loc, I_Depth)));\n+        Make_Integer_Literal (Loc, I_Depth));\n \n       --  Access_Level\n \n       Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of (RTE_Record_Component (RE_Access_Level), Loc)),\n-          Expression =>\n-            Make_Integer_Literal (Loc, Type_Access_Level (Typ))));\n+        Make_Integer_Literal (Loc, Type_Access_Level (Typ)));\n \n       --  Expanded_Name\n \n       Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of (RTE_Record_Component (RE_Expanded_Name), Loc)),\n-          Expression =>\n-            Unchecked_Convert_To (RTE (RE_Cstring_Ptr),\n-              Make_Attribute_Reference (Loc,\n-                Prefix => New_Reference_To (Exname, Loc),\n-                Attribute_Name => Name_Address))));\n+        Unchecked_Convert_To (RTE (RE_Cstring_Ptr),\n+          Make_Attribute_Reference (Loc,\n+            Prefix => New_Reference_To (Exname, Loc),\n+            Attribute_Name => Name_Address)));\n \n       --  External_Tag of a local tagged type\n \n-      --     Exname : constant String :=\n+      --     <typ>A : constant String :=\n       --                \"Internal tag at 16#tag-addr#: <full-name-of-typ>\";\n \n       --  The reason we generate this strange name is that we do not want to\n@@ -3237,63 +3444,42 @@ package body Exp_Disp is\n       --  in scope, but it clearly must be erroneous to compute the internal\n       --  tag of a tagged type that is out of scope!\n \n-      if Is_Local_DT then\n+      --  We don't do this processing if an explicit external tag has been\n+      --  specified. That's an odd case for which we have already issued a\n+      --  warning, where we will not be able to compute the internal tag.\n+\n+      if not Is_Library_Level_Entity (Typ)\n+        and then not Has_External_Tag_Rep_Clause (Typ)\n+      then\n          declare\n-            Name_Exname : constant Name_Id := New_External_Name (Tname, 'L');\n-            Name_Str1   : constant Name_Id := New_Internal_Name ('I');\n-            Name_Str2   : constant Name_Id := New_Internal_Name ('I');\n-            Name_Str3   : constant Name_Id := New_Internal_Name ('I');\n             Exname      : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc, Name_Exname);\n-            Str1        : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc, Name_Str1);\n-            Str2        : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc, Name_Str2);\n-            Str3        : constant Entity_Id :=\n-                            Make_Defining_Identifier (Loc, Name_Str3);\n+                            Make_Defining_Identifier (Loc,\n+                              New_External_Name (Tname, 'A'));\n+\n             Full_Name   : constant String_Id :=\n                             Full_Qualified_Name (First_Subtype (Typ));\n             Str1_Id     : String_Id;\n             Str2_Id     : String_Id;\n-            Str3_Id     : String_Id;\n \n          begin\n             --  Generate:\n-            --    Str1 : constant String := \"Internal tag at 16#\";\n-\n-            Set_Ekind (Str1, E_Constant);\n-            Set_Is_Statically_Allocated (Str1);\n-            Set_Is_True_Constant (Str1);\n+            --    Str1 = \"Internal tag at 16#\";\n \n             Start_String;\n             Store_String_Chars (\"Internal tag at 16#\");\n             Str1_Id := End_String;\n \n             --  Generate:\n-            --    Str2 : constant String := \"#: \";\n-\n-            Set_Ekind (Str2, E_Constant);\n-            Set_Is_Statically_Allocated (Str2);\n-            Set_Is_True_Constant (Str2);\n+            --    Str2 = \"#: <type-full-name>\";\n \n             Start_String;\n             Store_String_Chars (\"#: \");\n-            Str2_Id := End_String;\n-\n-            --  Generate:\n-            --    Str3 : constant String := <full-name-of-typ>;\n-\n-            Set_Ekind (Str3, E_Constant);\n-            Set_Is_Statically_Allocated (Str3);\n-            Set_Is_True_Constant (Str3);\n-\n-            Start_String;\n             Store_String_Chars (Full_Name);\n-            Str3_Id := End_String;\n+            Str2_Id := End_String;\n \n             --  Generate:\n             --    Exname : constant String :=\n-            --               Str1 & Address_Image (Tag) & Str2 & Str3;\n+            --               Str1 & Address_Image (Tag) & Str2;\n \n             if RTE_Available (RE_Address_Image) then\n                Append_To (Result,\n@@ -3317,11 +3503,8 @@ package body Exp_Disp is\n                                  Unchecked_Convert_To (RTE (RE_Address),\n                                    New_Reference_To (DT_Ptr, Loc)))),\n                            Right_Opnd =>\n-                             Make_Op_Concat (Loc,\n-                               Left_Opnd =>\n-                                 Make_String_Literal (Loc, Str2_Id),\n-                               Right_Opnd =>\n-                                 Make_String_Literal (Loc, Str3_Id))))));\n+                             Make_String_Literal (Loc, Str2_Id)))));\n+\n             else\n                Append_To (Result,\n                  Make_Object_Declaration (Loc,\n@@ -3334,11 +3517,7 @@ package body Exp_Disp is\n                        Left_Opnd =>\n                          Make_String_Literal (Loc, Str1_Id),\n                        Right_Opnd =>\n-                         Make_Op_Concat (Loc,\n-                           Left_Opnd =>\n-                             Make_String_Literal (Loc, Str2_Id),\n-                           Right_Opnd =>\n-                             Make_String_Literal (Loc, Str3_Id)))));\n+                         Make_String_Literal (Loc, Str2_Id))));\n             end if;\n \n             New_Node :=\n@@ -3372,11 +3551,12 @@ package body Exp_Disp is\n             else\n                Old_Val := Strval (Expr_Value_S (Expression (Def)));\n \n-               --  For the rep clause \"for x'external_tag use y\" generate:\n+               --  For the rep clause \"for <typ>'external_tag use y\" generate:\n \n-               --     xV : constant string := y;\n-               --     Set_External_Tag (x'tag, xV'Address);\n-               --     Register_Tag (x'tag);\n+               --     <typ>A : constant string := y;\n+               --\n+               --  <typ>A'Address is used to set the External_Tag component\n+               --  of the TSD\n \n                --  Create a new nul terminated string if it is not already\n \n@@ -3412,43 +3592,34 @@ package body Exp_Disp is\n          end;\n       end if;\n \n-      Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of\n-              (RTE_Record_Component (RE_External_Tag), Loc)),\n-          Expression => New_Node));\n+      Append_To (TSD_Aggr_List, New_Node);\n \n       --  HT_Link\n \n       Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of\n-              (RTE_Record_Component (RE_HT_Link), Loc)),\n-          Expression =>\n-            Unchecked_Convert_To (RTE (RE_Tag),\n-              New_Reference_To (RTE (RE_Null_Address), Loc))));\n+        Unchecked_Convert_To (RTE (RE_Tag),\n+          New_Reference_To (RTE (RE_Null_Address), Loc)));\n \n       --  Transportable: Set for types that can be used in remote calls\n       --  with respect to E.4(18) legality rules.\n \n-      Transportable :=\n-        Boolean_Literals\n-          (Is_Pure (Typ)\n-             or else Is_Shared_Passive (Typ)\n-             or else\n-               ((Is_Remote_Types (Typ)\n-                   or else Is_Remote_Call_Interface (Typ))\n-                and then Original_View_In_Visible_Part (Typ))\n-             or else not Comes_From_Source (Typ));\n+      declare\n+         Transportable : Entity_Id;\n \n-      Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of\n-             (RTE_Record_Component (RE_Transportable), Loc)),\n-          Expression => New_Occurrence_Of (Transportable, Loc)));\n+      begin\n+         Transportable :=\n+           Boolean_Literals\n+             (Is_Pure (Typ)\n+                or else Is_Shared_Passive (Typ)\n+                or else\n+                  ((Is_Remote_Types (Typ)\n+                      or else Is_Remote_Call_Interface (Typ))\n+                   and then Original_View_In_Visible_Part (Typ))\n+                or else not Comes_From_Source (Typ));\n+\n+         Append_To (TSD_Aggr_List,\n+            New_Occurrence_Of (Transportable, Loc));\n+      end;\n \n       --  RC_Offset: These are the valid values and their meaning:\n \n@@ -3465,47 +3636,48 @@ package body Exp_Disp is\n       --   -2: There are no controlled components at this level. We need to\n       --       get the position from the parent.\n \n-      if not Has_Controlled_Component (Typ) then\n-         RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n+      declare\n+         RC_Offset_Node : Node_Id;\n \n-      elsif Etype (Typ) /= Typ\n-        and then Has_Discriminants (Etype (Typ))\n-      then\n-         if Has_New_Controlled_Component (Typ) then\n-            RC_Offset_Node := Make_Integer_Literal (Loc, -1);\n+      begin\n+         if not Has_Controlled_Component (Typ) then\n+            RC_Offset_Node := Make_Integer_Literal (Loc, 0);\n+\n+         elsif Etype (Typ) /= Typ\n+           and then Has_Discriminants (Etype (Typ))\n+         then\n+            if Has_New_Controlled_Component (Typ) then\n+               RC_Offset_Node := Make_Integer_Literal (Loc, -1);\n+            else\n+               RC_Offset_Node := Make_Integer_Literal (Loc, -2);\n+            end if;\n          else\n-            RC_Offset_Node := Make_Integer_Literal (Loc, -2);\n+            RC_Offset_Node :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix =>\n+                  Make_Selected_Component (Loc,\n+                    Prefix => New_Reference_To (Typ, Loc),\n+                    Selector_Name =>\n+                      New_Reference_To (Controller_Component (Typ), Loc)),\n+                Attribute_Name => Name_Position);\n+\n+            --  This is not proper Ada code to use the attribute 'Position\n+            --  on something else than an object but this is supported by\n+            --  the back end (see comment on the Bit_Component attribute in\n+            --  sem_attr). So we avoid semantic checking here.\n+\n+            --  Is this documented in sinfo.ads??? it should be!\n+\n+            Set_Analyzed (RC_Offset_Node);\n+            Set_Etype (Prefix (RC_Offset_Node), RTE (RE_Record_Controller));\n+            Set_Etype (Prefix (Prefix (RC_Offset_Node)), Typ);\n+            Set_Etype (Selector_Name (Prefix (RC_Offset_Node)),\n+              RTE (RE_Record_Controller));\n+            Set_Etype (RC_Offset_Node, RTE (RE_Storage_Offset));\n          end if;\n-      else\n-         RC_Offset_Node :=\n-           Make_Attribute_Reference (Loc,\n-             Prefix =>\n-               Make_Selected_Component (Loc,\n-                 Prefix => New_Reference_To (Typ, Loc),\n-                 Selector_Name =>\n-                   New_Reference_To (Controller_Component (Typ), Loc)),\n-             Attribute_Name => Name_Position);\n-\n-         --  This is not proper Ada code to use the attribute 'Position\n-         --  on something else than an object but this is supported by\n-         --  the back end (see comment on the Bit_Component attribute in\n-         --  sem_attr). So we avoid semantic checking here.\n-\n-         --  Is this documented in sinfo.ads??? it should be!\n-\n-         Set_Analyzed (RC_Offset_Node);\n-         Set_Etype (Prefix (RC_Offset_Node), RTE (RE_Record_Controller));\n-         Set_Etype (Prefix (Prefix (RC_Offset_Node)), Typ);\n-         Set_Etype (Selector_Name (Prefix (RC_Offset_Node)),\n-           RTE (RE_Record_Controller));\n-         Set_Etype (RC_Offset_Node, RTE (RE_Storage_Offset));\n-      end if;\n \n-      Append_To (TSD_Aggr_List,\n-        Make_Component_Association (Loc,\n-          Choices => New_List (\n-            New_Occurrence_Of (RTE_Record_Component (RE_RC_Offset), Loc)),\n-          Expression => RC_Offset_Node));\n+         Append_To (TSD_Aggr_List, RC_Offset_Node);\n+      end;\n \n       --  Interfaces_Table (required for AI-405)\n \n@@ -3527,98 +3699,86 @@ package body Exp_Disp is\n          --  Generate the Interface_Table object\n \n          else\n-            TSD_Ifaces_List := New_List;\n-\n             declare\n-               Pos       : Nat := 1;\n-               Aggr_List : List_Id;\n+               TSD_Ifaces_List : constant List_Id := New_List;\n \n             begin\n                AI := First_Elmt (Typ_Ifaces);\n                while Present (AI) loop\n-                  Aggr_List := New_List (\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        New_Occurrence_Of\n-                          (RTE_Record_Component (RE_Iface_Tag), Loc)),\n-                      Expression =>\n+                  Append_To (TSD_Ifaces_List,\n+                     Make_Aggregate (Loc,\n+                       Expressions => New_List (\n+\n+                        --  Iface_Tag\n+\n                         Unchecked_Convert_To (Generalized_Tag,\n                           New_Reference_To\n                             (Node (First_Elmt (Access_Disp_Table (Node (AI)))),\n-                             Loc))),\n+                             Loc)),\n \n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        New_Occurrence_Of\n-                          (RTE_Record_Component (RE_Static_Offset_To_Top),\n-                           Loc)),\n-                      Expression =>\n-                        New_Reference_To (Standard_True, Loc)),\n+                        --  Static_Offset_To_Top\n \n-                    Make_Component_Association (Loc,\n-                      Choices     => New_List (Make_Others_Choice (Loc)),\n-                      Expression  => Empty,\n-                      Box_Present => True));\n+                        New_Reference_To (Standard_True, Loc),\n \n-                  Append_To (TSD_Ifaces_List,\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        Make_Integer_Literal (Loc, Pos)),\n-                      Expression => Make_Aggregate (Loc,\n-                        Component_Associations => Aggr_List)));\n+                        --  Offset_To_Top_Value\n+\n+                        Make_Integer_Literal (Loc, 0),\n+\n+                        --  Offset_To_Top_Func\n+\n+                        Make_Null (Loc))));\n \n-                  Pos := Pos + 1;\n                   Next_Elmt (AI);\n                end loop;\n-            end;\n \n-            Name_ITable := New_External_Name (Tname, 'I');\n-            ITable      := Make_Defining_Identifier (Loc, Name_ITable);\n+               Name_ITable := New_External_Name (Tname, 'I');\n+               ITable      := Make_Defining_Identifier (Loc, Name_ITable);\n+               Set_Is_Statically_Allocated (ITable);\n \n-            Set_Ekind (ITable, E_Constant);\n-            Set_Is_Statically_Allocated (ITable);\n-            Set_Is_True_Constant (ITable);\n+               --  The table of interfaces is not constant; its slots are\n+               --  filled at run-time by the IP routine using attribute\n+               --  'Position to know the location of the tag components\n+               --  (and this attribute cannot be safely used before the\n+               --  object is initialized).\n \n-            Append_To (Result,\n-              Make_Object_Declaration (Loc,\n-                Defining_Identifier => ITable,\n-                Aliased_Present     => True,\n-                Object_Definition   =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Reference_To (RTE (RE_Interface_Data), Loc),\n-                    Constraint => Make_Index_Or_Discriminant_Constraint (Loc,\n-                      Constraints => New_List (\n-                        Make_Integer_Literal (Loc, Num_Ifaces)))),\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => ITable,\n+                   Aliased_Present     => True,\n+                   Constant_Present    => False,\n+                   Object_Definition   =>\n+                     Make_Subtype_Indication (Loc,\n+                       Subtype_Mark =>\n+                         New_Reference_To (RTE (RE_Interface_Data), Loc),\n+                       Constraint => Make_Index_Or_Discriminant_Constraint\n+                         (Loc,\n+                          Constraints => New_List (\n+                            Make_Integer_Literal (Loc, Num_Ifaces)))),\n \n-                Expression => Make_Aggregate (Loc,\n-                  Component_Associations => New_List (\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        New_Occurrence_Of\n-                          (RTE_Record_Component (RE_Nb_Ifaces), Loc)),\n-                      Expression =>\n-                        Make_Integer_Literal (Loc, Num_Ifaces)),\n+                   Expression => Make_Aggregate (Loc,\n+                     Expressions => New_List (\n+                       Make_Integer_Literal (Loc, Num_Ifaces),\n+                       Make_Aggregate (Loc,\n+                         Expressions => TSD_Ifaces_List)))));\n \n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        New_Occurrence_Of\n-                          (RTE_Record_Component (RE_Ifaces_Table), Loc)),\n-                      Expression => Make_Aggregate (Loc,\n-                        Component_Associations => TSD_Ifaces_List))))));\n+               Append_To (Result,\n+                 Make_Attribute_Definition_Clause (Loc,\n+                   Name       => New_Reference_To (ITable, Loc),\n+                   Chars      => Name_Alignment,\n+                   Expression =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix =>\n+                         New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                       Attribute_Name => Name_Alignment)));\n \n-            Iface_Table_Node :=\n-              Make_Attribute_Reference (Loc,\n-                Prefix         => New_Reference_To (ITable, Loc),\n-                Attribute_Name => Name_Unchecked_Access);\n+               Iface_Table_Node :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Reference_To (ITable, Loc),\n+                   Attribute_Name => Name_Unchecked_Access);\n+            end;\n          end if;\n \n-         Append_To (TSD_Aggr_List,\n-           Make_Component_Association (Loc,\n-             Choices => New_List (\n-               New_Occurrence_Of\n-                (RTE_Record_Component (RE_Interfaces_Table), Loc)),\n-             Expression => Iface_Table_Node));\n+         Append_To (TSD_Aggr_List, Iface_Table_Node);\n       end if;\n \n       --  Generate the Select Specific Data table for synchronized types that\n@@ -3627,7 +3787,7 @@ package body Exp_Disp is\n \n       if RTE_Record_Component_Available (RE_SSD) then\n          if Ada_Version >= Ada_05\n-           and then Has_Dispatch_Table\n+           and then Has_DT\n            and then Is_Concurrent_Record_Type (Typ)\n            and then Has_Abstract_Interfaces (Typ)\n            and then Nb_Prim > 0\n@@ -3648,117 +3808,135 @@ package body Exp_Disp is\n                         Constraints => New_List (\n                           Make_Integer_Literal (Loc, Nb_Prim))))));\n \n+            Append_To (Result,\n+              Make_Attribute_Definition_Clause (Loc,\n+                Name       => New_Reference_To (SSD, Loc),\n+                Chars      => Name_Alignment,\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                    Attribute_Name => Name_Alignment)));\n+\n             --  This table is initialized by Make_Select_Specific_Data_Table,\n             --  which calls Set_Entry_Index and Set_Prim_Op_Kind.\n \n             Append_To (TSD_Aggr_List,\n-              Make_Component_Association (Loc,\n-                Choices => New_List (\n-                  New_Occurrence_Of\n-                   (RTE_Record_Component (RE_SSD), Loc)),\n-                Expression =>\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix => New_Reference_To (SSD, Loc),\n-                    Attribute_Name => Name_Unchecked_Access)));\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Reference_To (SSD, Loc),\n+                Attribute_Name => Name_Unchecked_Access));\n          else\n-            Append_To (TSD_Aggr_List,\n-              Make_Component_Association (Loc,\n-                Choices => New_List (\n-                  New_Occurrence_Of\n-                   (RTE_Record_Component (RE_SSD), Loc)),\n-                Expression => Make_Null (Loc)));\n+            Append_To (TSD_Aggr_List, Make_Null (Loc));\n          end if;\n       end if;\n \n       --  Initialize the table of ancestor tags. In case of interface types\n       --  this table is not needed.\n \n-      if Is_Interface (Typ) then\n-         Append_To (TSD_Aggr_List,\n-           Make_Component_Association (Loc,\n-             Choices     => New_List (Make_Others_Choice (Loc)),\n-             Expression  => Empty,\n-             Box_Present => True));\n-      else\n-         declare\n-            Current_Typ : Entity_Id;\n-            Parent_Typ  : Entity_Id;\n-            Pos         : Nat;\n+      declare\n+         Current_Typ : Entity_Id;\n+         Parent_Typ  : Entity_Id;\n+         Pos         : Nat;\n \n-         begin\n-            TSD_Tags_List := New_List;\n+      begin\n+         TSD_Tags_List := New_List;\n \n-            --  Fill position 0 with null because we still have not generated\n-            --  the tag of Typ.\n+         --  If we are not statically allocating the dispatch table then we\n+         --  must fill position 0 with null because we still have not\n+         --  generated the tag of Typ.\n \n+         if not Build_Static_DT\n+           or else Is_Interface (Typ)\n+         then\n             Append_To (TSD_Tags_List,\n-              Make_Component_Association (Loc,\n-                Choices => New_List (\n-                  Make_Integer_Literal (Loc, 0)),\n-                Expression =>\n-                  Unchecked_Convert_To (RTE (RE_Tag),\n-                    New_Reference_To (RTE (RE_Null_Address), Loc))));\n+              Unchecked_Convert_To (RTE (RE_Tag),\n+                New_Reference_To (RTE (RE_Null_Address), Loc)));\n \n-            --  Fill the rest of the table with the tags of the ancestors\n+         --  Otherwise we can safely import the tag. The name must be unique\n+         --  over the compilation unit, to avoid conflicts when types of the\n+         --  same name appear in different nested packages. We don't need to\n+         --  use an external name because this name is only locally used.\n \n-            Pos := 1;\n-            Current_Typ := Typ;\n+         else\n+            declare\n+               Imported_DT_Ptr : constant Entity_Id :=\n+                                   Make_Defining_Identifier (Loc,\n+                                     Chars => New_Internal_Name ('D'));\n \n-            loop\n-               Parent_Typ := Etype (Current_Typ);\n+            begin\n+               Set_Is_Imported (Imported_DT_Ptr);\n+               Set_Is_Statically_Allocated (Imported_DT_Ptr);\n+               Set_Is_True_Constant (Imported_DT_Ptr);\n+               Get_External_Name\n+                 (Node (First_Elmt (Access_Disp_Table (Typ))), True);\n+               Set_Interface_Name (Imported_DT_Ptr,\n+                 Make_String_Literal (Loc, String_From_Name_Buffer));\n \n-               if Is_Private_Type (Parent_Typ) then\n-                  Parent_Typ := Full_View (Base_Type (Parent_Typ));\n-               end if;\n+               --  Set tag as internal to ensure proper Sprint output of its\n+               --  implicit importation.\n \n-               exit when Parent_Typ = Current_Typ;\n+               Set_Is_Internal (Imported_DT_Ptr);\n \n-               if Is_CPP_Class (Parent_Typ) then\n+               Append_To (Result,\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => Imported_DT_Ptr,\n+                   Constant_Present    => True,\n+                   Object_Definition   => New_Reference_To (RTE (RE_Tag),\n+                                            Loc)));\n \n-                  --  The tags defined in the C++ side will be inherited when\n-                  --  the object is constructed.\n-                  --  (see Exp_Ch3.Build_Init_Procedure)\n+               Append_To (TSD_Tags_List,\n+                 New_Reference_To (Imported_DT_Ptr, Loc));\n+            end;\n+         end if;\n \n-                  Append_To (TSD_Tags_List,\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        Make_Integer_Literal (Loc, Pos)),\n-                      Expression =>\n-                        Unchecked_Convert_To (RTE (RE_Tag),\n-                          New_Reference_To (RTE (RE_Null_Address), Loc))));\n-               else\n-                  Append_To (TSD_Tags_List,\n-                    Make_Component_Association (Loc,\n-                      Choices => New_List (\n-                        Make_Integer_Literal (Loc, Pos)),\n-                      Expression =>\n-                        New_Reference_To\n-                         (Node (First_Elmt (Access_Disp_Table (Parent_Typ))),\n-                          Loc)));\n-               end if;\n+         --  Fill the rest of the table with the tags of the ancestors\n \n-               Pos := Pos + 1;\n-               Current_Typ := Parent_Typ;\n-            end loop;\n+         Pos := 1;\n+         Current_Typ := Typ;\n \n-            pragma Assert (Pos = I_Depth + 1);\n-         end;\n+         loop\n+            Parent_Typ := Etype (Current_Typ);\n \n-         Append_To (TSD_Aggr_List,\n-           Make_Component_Association (Loc,\n-             Choices => New_List (\n-               New_Occurrence_Of\n-                 (RTE_Record_Component (RE_Tags_Table), Loc)),\n-             Expression => Make_Aggregate (Loc,\n-               Component_Associations => TSD_Tags_List)));\n-      end if;\n+            if Is_Private_Type (Parent_Typ) then\n+               Parent_Typ := Full_View (Base_Type (Parent_Typ));\n+            end if;\n+\n+            exit when Parent_Typ = Current_Typ;\n+\n+            if Is_CPP_Class (Parent_Typ)\n+              or else Is_Interface (Typ)\n+            then\n+               --  The tags defined in the C++ side will be inherited when\n+               --  the object is constructed (Exp_Ch3.Build_Init_Procedure)\n+\n+               Append_To (TSD_Tags_List,\n+                 Unchecked_Convert_To (RTE (RE_Tag),\n+                   New_Reference_To (RTE (RE_Null_Address), Loc)));\n+            else\n+               Append_To (TSD_Tags_List,\n+                 New_Reference_To\n+                   (Node (First_Elmt (Access_Disp_Table (Parent_Typ))),\n+                    Loc));\n+            end if;\n+\n+            Pos := Pos + 1;\n+            Current_Typ := Parent_Typ;\n+         end loop;\n+\n+         pragma Assert (Pos = I_Depth + 1);\n+      end;\n+\n+      Append_To (TSD_Aggr_List,\n+        Make_Aggregate (Loc,\n+          Expressions => TSD_Tags_List));\n \n       --  Build the TSD object\n \n       Append_To (Result,\n         Make_Object_Declaration (Loc,\n           Defining_Identifier => TSD,\n           Aliased_Present     => True,\n+          Constant_Present    => Build_Static_DT,\n           Object_Definition   =>\n             Make_Subtype_Indication (Loc,\n               Subtype_Mark => New_Reference_To (\n@@ -3769,7 +3947,7 @@ package body Exp_Disp is\n                     Make_Integer_Literal (Loc, I_Depth)))),\n \n           Expression => Make_Aggregate (Loc,\n-            Component_Associations => TSD_Aggr_List)));\n+            Expressions => TSD_Aggr_List)));\n \n       Append_To (Result,\n         Make_Attribute_Definition_Clause (Loc,\n@@ -3786,8 +3964,9 @@ package body Exp_Disp is\n       --   DT : No_Dispatch_Table :=\n       --          (NDT_TSD       => TSD'Address;\n       --           NDT_Prims_Ptr => 0);\n+      --   for DT'Alignment use Address'Alignment\n \n-      if not Has_Dispatch_Table then\n+      if not Has_DT then\n          DT_Constr_List := New_List;\n          DT_Aggr_List   := New_List;\n \n@@ -3806,7 +3985,7 @@ package body Exp_Disp is\n          --  and uninitialized object for the dispatch table, which is now\n          --  initialized by means of an assignment.\n \n-         if Is_Local_DT then\n+         if not Build_Static_DT then\n             Append_To (Result,\n               Make_Assignment_Statement (Loc,\n                 Name => New_Reference_To (DT, Loc),\n@@ -3821,12 +4000,22 @@ package body Exp_Disp is\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT,\n                 Aliased_Present     => True,\n-                Constant_Present    => Static_Dispatch_Tables,\n+                Constant_Present    => True,\n                 Object_Definition   =>\n                   New_Reference_To (RTE (RE_No_Dispatch_Table_Wrapper), Loc),\n                 Expression => Make_Aggregate (Loc,\n                   Expressions => DT_Aggr_List)));\n \n+            Append_To (Result,\n+              Make_Attribute_Definition_Clause (Loc,\n+                Name       => New_Reference_To (DT, Loc),\n+                Chars      => Name_Alignment,\n+                Expression =>\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix =>\n+                      New_Reference_To (RTE (RE_Integer_Address), Loc),\n+                    Attribute_Name => Name_Alignment)));\n+\n             Append_To (Result,\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT_Ptr,\n@@ -3865,13 +4054,14 @@ package body Exp_Disp is\n       --                             prim-op-2'address,\n       --                             ...\n       --                             prim-op-n'address));\n+      --   for DT'Alignment use Address'Alignment\n \n       else\n          declare\n             Pos : Nat;\n \n          begin\n-            if not Static_Dispatch_Tables then\n+            if not Build_Static_DT then\n                Nb_Predef_Prims := Max_Predef_Prims;\n \n             else\n@@ -3902,11 +4092,12 @@ package body Exp_Disp is\n                Prim_Ops_Aggr_List := New_List;\n \n                Prim_Table := (others => Empty);\n+\n                Prim_Elmt  := First_Elmt (Primitive_Operations (Typ));\n                while Present (Prim_Elmt) loop\n                   Prim := Node (Prim_Elmt);\n \n-                  if Static_Dispatch_Tables\n+                  if Build_Static_DT\n                     and then Is_Predefined_Dispatching_Operation (Prim)\n                     and then not Is_Abstract_Subprogram (Prim)\n                     and then not Present (Prim_Table\n@@ -3941,7 +4132,7 @@ package body Exp_Disp is\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Predef_Prims,\n                    Aliased_Present     => True,\n-                   Constant_Present    => Static_Dispatch_Tables,\n+                   Constant_Present    => Build_Static_DT,\n                    Object_Definition   =>\n                      New_Reference_To (RTE (RE_Address_Array), Loc),\n                    Expression => Make_Aggregate (Loc,\n@@ -4017,7 +4208,7 @@ package body Exp_Disp is\n             Append_To (Prim_Ops_Aggr_List,\n               New_Reference_To (RTE (RE_Null_Address), Loc));\n \n-         elsif not Static_Dispatch_Tables then\n+         elsif not Build_Static_DT then\n             for J in 1 .. Nb_Prim loop\n                Append_To (Prim_Ops_Aggr_List,\n                  New_Reference_To (RTE (RE_Null_Address), Loc));\n@@ -4059,10 +4250,6 @@ package body Exp_Disp is\n                           (UI_To_Int (DT_Position (Prim)) <= Nb_Prim);\n \n                         Prim_Table (UI_To_Int (DT_Position (Prim))) := E;\n-\n-                        --  There is no need to set Has_Delayed_Freeze here\n-                        --  because the analysis of 'Address and 'Code_Address\n-                        --  takes care of it.\n                      end if;\n                   end if;\n \n@@ -4092,7 +4279,7 @@ package body Exp_Disp is\n          --  and uninitialized object for the dispatch table, which is now\n          --  initialized by means of an assignment.\n \n-         if Is_Local_DT then\n+         if not Build_Static_DT then\n             Append_To (Result,\n               Make_Assignment_Statement (Loc,\n                 Name => New_Reference_To (DT, Loc),\n@@ -4107,7 +4294,7 @@ package body Exp_Disp is\n               Make_Object_Declaration (Loc,\n                 Defining_Identifier => DT,\n                 Aliased_Present     => True,\n-                Constant_Present    => Static_Dispatch_Tables,\n+                Constant_Present    => True,\n                 Object_Definition   =>\n                   Make_Subtype_Indication (Loc,\n                     Subtype_Mark => New_Reference_To\n@@ -4147,7 +4334,8 @@ package body Exp_Disp is\n \n       --  Initialize the table of ancestor tags\n \n-      if not Is_Interface (Typ)\n+      if not Build_Static_DT\n+        and then not Is_Interface (Typ)\n         and then not Is_CPP_Class (Typ)\n       then\n          Append_To (Result,\n@@ -4169,7 +4357,7 @@ package body Exp_Disp is\n                  (Node (First_Elmt (Access_Disp_Table (Typ))), Loc)));\n       end if;\n \n-      if Static_Dispatch_Tables then\n+      if Build_Static_DT then\n          null;\n \n       --  If the ancestor is a CPP_Class type we inherit the dispatch tables\n@@ -4225,6 +4413,7 @@ package body Exp_Disp is\n                      if Nb_Prims /= 0 then\n                         Append_To (Elab_Code,\n                           Build_Inherit_Prims (Loc,\n+                            Typ          => Typ,\n                             Old_Tag_Node => Old_Tag2,\n                             New_Tag_Node => New_Reference_To (DT_Ptr, Loc),\n                             Num_Prims    => Nb_Prims));\n@@ -4304,6 +4493,7 @@ package body Exp_Disp is\n                                     if Num_Prims /= 0 then\n                                        Append_To (Elab_Code,\n                                          Build_Inherit_Prims (Loc,\n+                                           Typ          => Node (Iface),\n                                            Old_Tag_Node =>\n                                              Unchecked_Convert_To\n                                                (RTE (RE_Tag),\n@@ -4315,7 +4505,7 @@ package body Exp_Disp is\n                                               (RTE (RE_Tag),\n                                                New_Reference_To\n                                                  (Node (Sec_DT_Typ), Loc)),\n-                                           Num_Prims => Num_Prims));\n+                                           Num_Prims    => Num_Prims));\n                                     end if;\n                                  end;\n                               end if;\n@@ -4370,7 +4560,7 @@ package body Exp_Disp is\n \n       if not Is_Interface (Typ) then\n          if not No_Run_Time_Mode\n-           and then not Is_Local_DT\n+           and then Is_Library_Level_Entity (Typ)\n            and then RTE_Available (RE_Register_Tag)\n          then\n             Append_To (Elab_Code,\n@@ -4391,7 +4581,21 @@ package body Exp_Disp is\n              Then_Statements => Elab_Code));\n       end if;\n \n+      --  Populate the two auxiliary tables used for dispatching\n+      --  asynchronous, conditional and timed selects for synchronized\n+      --  types that implement a limited interface.\n+\n+      if Ada_Version >= Ada_05\n+        and then Is_Concurrent_Record_Type (Typ)\n+        and then Has_Abstract_Interfaces (Typ)\n+      then\n+         Append_List_To (Result,\n+           Make_Select_Specific_Data_Table (Typ));\n+      end if;\n+\n       Analyze_List (Result, Suppress => All_Checks);\n+      Set_Has_Dispatch_Table (Typ);\n+\n       return Result;\n    end Make_DT;\n \n@@ -4459,6 +4663,10 @@ package body Exp_Disp is\n       if Present (Corresponding_Concurrent_Type (Typ)) then\n          Conc_Typ := Corresponding_Concurrent_Type (Typ);\n \n+         if Present (Full_View (Conc_Typ)) then\n+            Conc_Typ := Full_View (Conc_Typ);\n+         end if;\n+\n          if Ekind (Conc_Typ) = E_Protected_Type then\n             Decls := Visible_Declarations (Protected_Definition (\n                        Parent (Conc_Typ)));\n@@ -4549,6 +4757,159 @@ package body Exp_Disp is\n       return Assignments;\n    end Make_Select_Specific_Data_Table;\n \n+   ---------------\n+   -- Make_Tags --\n+   ---------------\n+\n+   function Make_Tags (Typ : Entity_Id) return List_Id is\n+      Loc             : constant Source_Ptr := Sloc (Typ);\n+      Build_Static_DT : constant Boolean :=\n+                          Static_Dispatch_Tables\n+                            and then Is_Library_Level_Tagged_Type (Typ);\n+      Tname           : constant Name_Id := Chars (Typ);\n+      Result          : constant List_Id := New_List;\n+      AI_Tag_Comp     : Elmt_Id;\n+      DT_Ptr          : Node_Id;\n+      Iface_DT_Ptr    : Node_Id;\n+      Suffix_Index    : Int;\n+      Typ_Name        : Name_Id;\n+      Typ_Comps       : Elist_Id;\n+\n+   begin\n+      --  1) Generate the primary and secondary tag entities\n+\n+      --  Collect the components associated with secondary dispatch tables\n+\n+      if Has_Abstract_Interfaces (Typ) then\n+         Collect_Interface_Components (Typ, Typ_Comps);\n+      end if;\n+\n+      --  1) Generate the primary tag entity\n+\n+      DT_Ptr := Make_Defining_Identifier (Loc,\n+                  New_External_Name (Tname, 'P'));\n+      Set_Etype (DT_Ptr, RTE (RE_Tag));\n+      Set_Ekind (DT_Ptr, E_Variable);\n+\n+      --  Import the forward declaration of the tag (Make_DT will take care of\n+      --  its exportation)\n+\n+      if Build_Static_DT then\n+         Set_Is_Imported (DT_Ptr);\n+         Set_Is_True_Constant (DT_Ptr);\n+         Set_Scope (DT_Ptr, Current_Scope);\n+         Get_External_Name (DT_Ptr, True);\n+         Set_Interface_Name (DT_Ptr,\n+           Make_String_Literal (Loc,\n+             Strval => String_From_Name_Buffer));\n+\n+         --  Set tag entity as internal to ensure proper Sprint output of its\n+         --  implicit importation.\n+\n+         Set_Is_Internal (DT_Ptr);\n+\n+         Append_To (Result,\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => DT_Ptr,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (RTE (RE_Tag), Loc)));\n+      end if;\n+\n+      pragma Assert (No (Access_Disp_Table (Typ)));\n+      Set_Access_Disp_Table (Typ, New_Elmt_List);\n+      Append_Elmt (DT_Ptr, Access_Disp_Table (Typ));\n+\n+      --  2) Generate the secondary tag entities\n+\n+      if Has_Abstract_Interfaces (Typ) then\n+         Suffix_Index := 0;\n+\n+         --  For each interface type we build an unique external name\n+         --  associated with its corresponding secondary dispatch table.\n+         --  This external name will be used to declare an object that\n+         --  references this secondary dispatch table, value that will be\n+         --  used for the elaboration of Typ's objects and also for the\n+         --  elaboration of objects of derivations of Typ that do not\n+         --  override the primitive operation of this interface type.\n+\n+         AI_Tag_Comp := First_Elmt (Typ_Comps);\n+         while Present (AI_Tag_Comp) loop\n+            Get_Secondary_DT_External_Name\n+              (Typ, Related_Interface (Node (AI_Tag_Comp)), Suffix_Index);\n+\n+            Typ_Name     := Name_Find;\n+            Iface_DT_Ptr :=\n+              Make_Defining_Identifier (Loc,\n+                Chars => New_External_Name (Typ_Name, 'P'));\n+            Set_Etype (Iface_DT_Ptr, RTE (RE_Interface_Tag));\n+            Set_Ekind (Iface_DT_Ptr, E_Constant);\n+            Set_Is_Statically_Allocated (Iface_DT_Ptr);\n+            Set_Is_True_Constant (Iface_DT_Ptr);\n+            Set_Related_Interface\n+              (Iface_DT_Ptr, Related_Interface (Node (AI_Tag_Comp)));\n+            Append_Elmt (Iface_DT_Ptr, Access_Disp_Table (Typ));\n+\n+            Next_Elmt (AI_Tag_Comp);\n+         end loop;\n+      end if;\n+\n+      --  3) At the end of Access_Disp_Table we add the entity of an access\n+      --     type declaration. It is used by Build_Get_Prim_Op_Address to\n+      --     expand dispatching calls through the primary dispatch table.\n+\n+      --     Generate:\n+      --       type Typ_DT is array (1 .. Nb_Prims) of Address;\n+      --       type Typ_DT_Acc is access Typ_DT;\n+\n+      declare\n+         Name_DT_Prims     : constant Name_Id :=\n+                               New_External_Name (Tname, 'G');\n+         Name_DT_Prims_Acc : constant Name_Id :=\n+                               New_External_Name (Tname, 'H');\n+         DT_Prims          : constant Entity_Id :=\n+                               Make_Defining_Identifier (Loc, Name_DT_Prims);\n+         DT_Prims_Acc      : constant Entity_Id :=\n+                               Make_Defining_Identifier (Loc,\n+                                 Name_DT_Prims_Acc);\n+      begin\n+         Append_To (Result,\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => DT_Prims,\n+             Type_Definition =>\n+               Make_Constrained_Array_Definition (Loc,\n+                 Discrete_Subtype_Definitions => New_List (\n+                   Make_Range (Loc,\n+                     Low_Bound  => Make_Integer_Literal (Loc, 1),\n+                     High_Bound => Make_Integer_Literal (Loc,\n+                                    DT_Entry_Count\n+                                      (First_Tag_Component (Typ))))),\n+                 Component_Definition =>\n+                   Make_Component_Definition (Loc,\n+                     Subtype_Indication =>\n+                       New_Reference_To (RTE (RE_Address), Loc)))));\n+\n+         Append_To (Result,\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => DT_Prims_Acc,\n+             Type_Definition =>\n+                Make_Access_To_Object_Definition (Loc,\n+                  Subtype_Indication =>\n+                    New_Occurrence_Of (DT_Prims, Loc))));\n+\n+         Append_Elmt (DT_Prims_Acc, Access_Disp_Table (Typ));\n+\n+         --  Analyze the resulting list and suppress the generation of the\n+         --  Init_Proc associated with the above array declaration because\n+         --  we never use such type in object declarations; this type is only\n+         --  used to simplify the expansion associated with dispatching calls.\n+\n+         Analyze_List (Result);\n+         Set_Suppress_Init_Proc (Base_Type (DT_Prims));\n+      end;\n+\n+      return Result;\n+   end Make_Tags;\n+\n    -----------------------------------\n    -- Original_View_In_Visible_Part --\n    -----------------------------------\n@@ -4730,15 +5091,15 @@ package body Exp_Disp is\n \n          pragma Assert (Is_Interface (Iface_Typ));\n \n-         Expand_Interface_Thunk\n-           (N           => Prim,\n-            Thunk_Alias => Alias (Prim),\n-            Thunk_Id    => Thunk_Id,\n-            Thunk_Code  => Thunk_Code);\n+         Expand_Interface_Thunk (Prim, Thunk_Id, Thunk_Code);\n \n          if not Is_Parent (Iface_Typ, Typ)\n            and then Present (Thunk_Code)\n          then\n+            --  Comment needed on why checks are suppressed. This is not just\n+            --  efficiency, but fundamental functionality (see 1.295 RH, which\n+            --  still does not answer this question) ???\n+\n             Insert_Action (Ins_Nod, Thunk_Code, Suppress => All_Checks);\n \n             --  Generate the code necessary to fill the appropriate entry of\n@@ -5075,6 +5436,7 @@ package body Exp_Disp is\n \n             elsif not Present (Abstract_Interface_Alias (Prim))\n               and then Present (Alias (Prim))\n+              and then Chars (Prim) = Chars (Alias (Prim))\n               and then Find_Dispatching_Type (Alias (Prim)) /= Typ\n               and then Is_Parent\n                          (Find_Dispatching_Type (Alias (Prim)), Typ)\n@@ -5245,7 +5607,7 @@ package body Exp_Disp is\n             then\n                Error_Msg_NE\n                  (\"abstract inherited private operation&\" &\n-                  \" must be overridden ('R'M 3.9.3(10))\",\n+                  \" must be overridden (RM 3.9.3(10))\",\n                  Parent (Typ), Prim);\n             end if;\n          end if;\n@@ -5384,6 +5746,10 @@ package body Exp_Disp is\n       elsif Is_Concurrent_Record_Type (T) then\n          Conc_Typ := Corresponding_Concurrent_Type (T);\n \n+         if Present (Full_View (Conc_Typ)) then\n+            Conc_Typ := Full_View (Conc_Typ);\n+         end if;\n+\n          if Ekind (Conc_Typ) = E_Protected_Type then\n             return New_Reference_To (RTE (RE_TK_Protected), Loc);\n          else\n@@ -5414,7 +5780,7 @@ package body Exp_Disp is\n       --  Protect this procedure against wrong usage. Required because it will\n       --  be used directly from GDB\n \n-      if not (Typ in First_Node_Id .. Last_Node_Id)\n+      if not (Typ <= Last_Node_Id)\n         or else not Is_Tagged_Type (Typ)\n       then\n          Write_Str (\"wrong usage: Write_DT must be used with tagged types\");"}, {"sha": "498b9f05763416e08139a0b9b64223b3eca62d13", "filename": "gcc/ada/exp_disp.ads", "status": "modified", "additions": 40, "deletions": 24, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72/gcc%2Fada%2Fexp_disp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b2e1beb3f6b7e37ba7950e7d7348951768ea2f72/gcc%2Fada%2Fexp_disp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.ads?ref=b2e1beb3f6b7e37ba7950e7d7348951768ea2f72", "patch": "@@ -122,20 +122,20 @@ package Exp_Disp is\n    --      PPOs are collected and added to the Primitive_Operations list of\n    --      a type by the regular analysis mechanism.\n \n-   --      PPOs are frozen by Exp_Ch3.Predefined_Primitive_Freeze.\n+   --      PPOs are frozen by Exp_Ch3.Predefined_Primitive_Freeze\n \n-   --      Thunks for PPOs are created by Make_DT.\n+   --      Thunks for PPOs are created by Make_DT\n \n-   --      Dispatch table positions of PPOs are set by Set_All_DT_Position.\n+   --      Dispatch table positions of PPOs are set by Set_All_DT_Position\n \n    --      Calls to PPOs proceed as regular dispatching calls. If the PPO\n    --      has a thunk, a call proceeds as a regular dispatching call with\n    --      a thunk.\n \n    --  Guidelines for addition of new predefined primitive operations\n \n-   --      Update the value of constant Default_Prim_Op_Count in A-Tags.ads\n-   --      to reflect the new number of PPOs.\n+   --      Update the value of constant Max_Predef_Prims in a-tags.ads to\n+   --      indicate the new number of PPOs.\n \n    --      Introduce a new predefined name for the new PPO in Snames.ads and\n    --      Snames.adb.\n@@ -161,10 +161,19 @@ package Exp_Disp is\n    --  for a tagged type. If more predefined primitive operations are\n    --  added, the following items must be changed:\n \n-   --    Ada.Tags.Defailt_Prim_Op_Count    - indirect use\n+   --    Ada.Tags.Max_Predef_Prims         - indirect use\n    --    Exp_Disp.Default_Prim_Op_Position - indirect use\n    --    Exp_Disp.Set_All_DT_Position      - direct   use\n \n+   procedure Build_Static_Dispatch_Tables (N : Node_Id);\n+   --  N is a library level package declaration or package body. Build the\n+   --  static dispatch table of the tagged types defined at library level. In\n+   --  case of package declarations with private part the generated nodes are\n+   --  added at the end of the list of private declarations. Otherwise they are\n+   --  added to the end of the list of public declarations. In case of package\n+   --  bodies they are added to the end of the list of declarations of the\n+   --  package body.\n+\n    procedure Expand_Dispatching_Call (Call_Node : Node_Id);\n    --  Expand the call to the operation through the dispatch table and perform\n    --  the required tag checks when appropriate. For CPP types tag checks are\n@@ -182,21 +191,23 @@ package Exp_Disp is\n    --  secondary dispatch table.\n \n    procedure Expand_Interface_Thunk\n-     (N           : Node_Id;\n-      Thunk_Alias : Node_Id;\n-      Thunk_Id    : out Entity_Id;\n-      Thunk_Code  : out Node_Id);\n+     (Prim       : Node_Id;\n+      Thunk_Id   : out Entity_Id;\n+      Thunk_Code : out Node_Id);\n    --  Ada 2005 (AI-251): When a tagged type implements abstract interfaces we\n-   --  generate additional subprograms (thunks) to have a layout compatible\n-   --  with the C++ ABI. The thunk modifies the value of the first actual of\n-   --  the call (that is, the pointer to the object) before transferring\n-   --  control to the target function.\n-   --\n-   --  Required in 3.4 case, why ??? giant comment needed for any gcc\n-   --  specific code ???\n-\n-   function Make_DT (Typ : Entity_Id) return List_Id;\n-   --  Expand the declarations for the Dispatch Table.\n+   --  generate additional subprograms (thunks) associated with each primitive\n+   --  Prim to have a layout compatible with the C++ ABI. The thunk displaces\n+   --  the pointers to the actuals that depend on the controlling type before\n+   --  transferring control to the target subprogram. If there is no need to\n+   --  generate the thunk then Thunk_Id and Thunk_Code are set to Empty.\n+   --  Otherwise they are set to the defining identifier and the subprogram\n+   --  body of the generated thunk.\n+\n+   function Make_DT (Typ : Entity_Id; N : Node_Id := Empty) return List_Id;\n+   --  Expand the declarations for the Dispatch Table. The node N is the\n+   --  declaration that forces the generation of the table. It is used to place\n+   --  error messages when the declaration leads to the freezing of a given\n+   --  primitive operation that has an incomplete non- tagged formal.\n \n    function Make_Disp_Asynchronous_Select_Body\n      (Typ : Entity_Id) return Node_Id;\n@@ -234,10 +245,9 @@ package Exp_Disp is\n \n    function Make_Disp_Get_Task_Id_Body\n      (Typ : Entity_Id) return Node_Id;\n-   --  Ada 2005 (AI-345): Generate the body of the primitive operation of type\n-   --  Typ used for retrieving the _task_id field of a task interface class-\n-   --  wide type. Generate a null body if Typ is an interface or a non-task\n-   --  type.\n+   --  Ada 2005 (AI-345): Generate body of the primitive operation of type Typ\n+   --  used for retrieving the _task_id field of a task interface class- wide\n+   --  type. Generate a null body if Typ is an interface or a non-task type.\n \n    function Make_Disp_Get_Task_Id_Spec\n      (Typ : Entity_Id) return Node_Id;\n@@ -263,6 +273,12 @@ package Exp_Disp is\n    --  selects. Generate code to set the primitive operation kinds and entry\n    --  indices of primitive operations and primitive wrappers.\n \n+   function Make_Tags (Typ : Entity_Id) return List_Id;\n+   --  Generate the entities associated with the primary and secondary tags of\n+   --  Typ and fill the contents of Access_Disp_Table. In case of library level\n+   --  tagged types this routine imports the forward declaration of the tag\n+   --  entity, that will be declared and exported by Make_DT.\n+\n    procedure Register_Primitive\n      (Loc     : Source_Ptr;\n       Prim    : Entity_Id;"}]}