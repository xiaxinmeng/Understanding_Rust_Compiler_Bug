{"sha": "4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGEyYmI3ZmNiMGM4NTA3Yjk1OGFmYjNkMjJkZGZlZWJhNDk0MTQ4YQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2016-09-21T20:58:51Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-09-21T20:58:51Z"}, "message": "compiler, runtime: replace hashmap code with Go 1.7 hashmap\n    \n    This change removes the gccgo-specific hashmap code and replaces it with\n    the hashmap code from the Go 1.7 runtime.  The Go 1.7 hashmap code is\n    more efficient, does a better job on details like when to update a key,\n    and provides some support against denial-of-service attacks.\n    \n    The compiler is changed to call the new hashmap functions instead of the\n    old ones.\n    \n    The compiler now tracks which types are reflexive and which require\n    updating when used as a map key, and records the information in map type\n    descriptors.\n    \n    Map_index_expression is simplified.  The special case for a map index on\n    the right hand side of a tuple expression has been unnecessary for some\n    time, and is removed.  The support for specially marking a map index as\n    an lvalue is removed, in favor of lowering an assignment to a map index\n    into a function call.  The long-obsolete support for a map index of a\n    pointer to a map is removed.\n    \n    The __go_new_map_big function (known to the compiler as\n    Runtime::MAKEMAPBIG) is no longer needed, as the new runtime.makemap\n    function takes an int64 hint argument.\n    \n    The old map descriptor type and supporting expression is removed.\n    \n    The compiler was still supporting the long-obsolete syntax `m[k] = 0,\n    false` to delete a value from a map.  That is now removed, requiring a\n    change to one of the gccgo-specific tests.\n    \n    The builtin len function applied to a map or channel p is now compiled\n    as `p == nil ? 0 : *(*int)(p)`.  The __go_chan_len function (known to\n    the compiler as Runtime::CHAN_LEN) is removed.\n    \n    Support for a shared zero value for maps to large value types is\n    introduced, along the lines of the gc compiler.  The zero value is\n    handled as a common variable.\n    \n    The hash function is changed to take a seed argument, changing the\n    runtime hash functions and the compiler-generated hash functions.\n    Unlike the gc compiler, both the hash and equal functions continue to\n    take the type length.\n    \n    Types that can not be compared now store nil for the hash and equal\n    functions, rather than pointing to functions that throw.  Interface hash\n    and comparison functions now check explicitly for nil.  This matches the\n    gc compiler and permits a simple implementation for ismapkey.\n    \n    The compiler is changed to permit marking struct and array types as\n    incomparable, meaning that they have no hash or equal function.  We use\n    this for thunk types, removing the existing special code to avoid\n    generating hash/equal functions for them.\n    \n    The C runtime code adds memclr, memequal, and memmove functions.\n    \n    The hashmap code uses go:linkname comments to make the functions\n    visible, as otherwise the compiler would discard them.\n    \n    The hashmap code comments out the unused reference to the address of the\n    first parameter in the race code, as otherwise the compiler thinks that\n    the parameter escapes and copies it onto the heap.  This is probably not\n    needed when we enable escape analysis.\n    \n    Several runtime map tests that ere previously skipped for gccgo are now\n    run.\n    \n    The Go runtime picks up type kind information and stubs.  The type kind\n    information causes the generated runtime header file to define some\n    constants, including `empty`, and the C code is adjusted accordingly.\n    \n    A Go-callable version of runtime.throw, that takes a Go string, is\n    added to be called from the hashmap code.\n    \n    Reviewed-on: https://go-review.googlesource.com/29447\n\n\t* go.go-torture/execute/map-1.go: Replace old map deletion syntax\n\twith call to builtin delete function.\n\nFrom-SVN: r240334", "tree": {"sha": "843fadb26050988a8c6037662e2d090533437044", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/843fadb26050988a8c6037662e2d090533437044"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "812b1403a88cea3257e120f3234576f236c0921d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/812b1403a88cea3257e120f3234576f236c0921d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/812b1403a88cea3257e120f3234576f236c0921d"}], "stats": {"total": 5095, "additions": 3226, "deletions": 1869}, "files": [{"sha": "73645de171fc8a0d1211b483e151dd35df8a2603", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -1,4 +1,4 @@\n-259b4fe81436a3836308f6c96e058edad07be338\n+69668416034247ac6c7228c9dcbf6719af05b6ca\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "ea4978bb5550b53963f9dfe76d4279abc28df76a", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -294,7 +294,6 @@ Node::op_format() const\n \t\tcase Runtime::MAKECHAN:\n \t\tcase Runtime::MAKECHANBIG:\n \t\tcase Runtime::MAKEMAP:\n-\t\tcase Runtime::MAKEMAPBIG:\n \t\tcase Runtime::MAKESLICE1:\n \t\tcase Runtime::MAKESLICE2:\n \t\tcase Runtime::MAKESLICE1BIG:\n@@ -1231,7 +1230,6 @@ Escape_analysis_assign::expression(Expression** pexpr)\n \t      case Runtime::MAKECHAN:\n \t      case Runtime::MAKECHANBIG:\n \t      case Runtime::MAKEMAP:\n-\t      case Runtime::MAKEMAPBIG:\n \t      case Runtime::MAKESLICE1:\n \t      case Runtime::MAKESLICE2:\n \t      case Runtime::MAKESLICE1BIG:\n@@ -1839,7 +1837,6 @@ Escape_analysis_assign::assign(Node* dst, Node* src)\n \t\t  case Runtime::MAKECHAN:\n \t\t  case Runtime::MAKECHANBIG:\n \t\t  case Runtime::MAKEMAP:\n-\t\t  case Runtime::MAKEMAPBIG:\n \t\t  case Runtime::MAKESLICE1:\n \t\t  case Runtime::MAKESLICE2:\n \t\t  case Runtime::MAKESLICE1BIG:\n@@ -2582,7 +2579,6 @@ Escape_analysis_flood::flood(Level level, Node* dst, Node* src,\n \t\t    case Runtime::MAKECHAN:\n \t\t    case Runtime::MAKECHANBIG:\n \t\t    case Runtime::MAKEMAP:\n-\t\t    case Runtime::MAKEMAPBIG:\n \t\t    case Runtime::MAKESLICE1:\n \t\t    case Runtime::MAKESLICE2:\n \t\t    case Runtime::MAKESLICE1BIG:"}, {"sha": "70853abcd787a85a726590026dce8f7c8648fcb5", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 70, "deletions": 141, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -6998,13 +6998,14 @@ Builtin_call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t      Statement::make_temporary(mt->key_type(), args->back(), loc);\n \t    inserter->insert(key_temp);\n \n-\t    Expression* e1 = Expression::make_temporary_reference(map_temp,\n+\t    Expression* e1 = Expression::make_type_descriptor(mt, loc);\n+\t    Expression* e2 = Expression::make_temporary_reference(map_temp,\n \t\t\t\t\t\t\t\t  loc);\n-\t    Expression* e2 = Expression::make_temporary_reference(key_temp,\n+\t    Expression* e3 = Expression::make_temporary_reference(key_temp,\n \t\t\t\t\t\t\t\t  loc);\n-\t    e2 = Expression::make_unary(OPERATOR_AND, e2, loc);\n+\t    e3 = Expression::make_unary(OPERATOR_AND, e3, loc);\n \t    return Runtime::make_call(Runtime::MAPDELETE, this->location(),\n-\t\t\t\t      2, e1, e2);\n+\t\t\t\t      3, e1, e2, e3);\n \t  }\n       }\n       break;\n@@ -7065,6 +7066,18 @@ Builtin_call_expression::do_flatten(Gogo*, Named_object*,\n \t      *pa = Expression::make_temporary_reference(temp, loc);\n \t    }\n \t}\n+\n+    case BUILTIN_LEN:\n+      Expression_list::iterator pa = this->args()->begin();\n+      if (!(*pa)->is_variable()\n+\t  && ((*pa)->type()->map_type() != NULL\n+\t      || (*pa)->type()->channel_type() != NULL))\n+\t{\n+\t  Temporary_statement* temp =\n+\t    Statement::make_temporary(NULL, *pa, loc);\n+\t  inserter->insert(temp);\n+\t  *pa = Expression::make_temporary_reference(temp, loc);\n+\t}\n     }\n \n   return this;\n@@ -7174,13 +7187,7 @@ Builtin_call_expression::lower_make()\n     }\n \n   Location type_loc = first_arg->location();\n-  Expression* type_arg;\n-  if (is_slice || is_chan)\n-    type_arg = Expression::make_type_descriptor(type, type_loc);\n-  else if (is_map)\n-    type_arg = Expression::make_map_descriptor(type->map_type(), type_loc);\n-  else\n-    go_unreachable();\n+  Expression* type_arg = Expression::make_type_descriptor(type, type_loc);\n \n   Expression* call;\n   if (is_slice)\n@@ -7197,10 +7204,9 @@ Builtin_call_expression::lower_make()\n \t\t\t\t  loc, 3, type_arg, len_arg, cap_arg);\n     }\n   else if (is_map)\n-    call = Runtime::make_call((have_big_args\n-\t\t\t       ? Runtime::MAKEMAPBIG\n-\t\t\t       : Runtime::MAKEMAP),\n-\t\t\t      loc, 2, type_arg, len_arg);\n+    call = Runtime::make_call(Runtime::MAKEMAP, loc, 4, type_arg, len_arg,\n+\t\t\t      Expression::make_nil(loc),\n+\t\t\t      Expression::make_nil(loc));\n   else if (is_chan)\n     call = Runtime::make_call((have_big_args\n \t\t\t       ? Runtime::MAKECHANBIG\n@@ -8250,10 +8256,23 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n \t        val = arg_type->array_type()->get_length(gogo, arg);\n \t\tthis->seen_ = false;\n \t      }\n-\t    else if (arg_type->map_type() != NULL)\n-              val = Runtime::make_call(Runtime::MAP_LEN, location, 1, arg);\n-\t    else if (arg_type->channel_type() != NULL)\n-              val = Runtime::make_call(Runtime::CHAN_LEN, location, 1, arg);\n+\t    else if (arg_type->map_type() != NULL\n+\t\t     || arg_type->channel_type() != NULL)\n+\t      {\n+\t\t// The first field is the length.  If the pointer is\n+\t\t// nil, the length is zero.\n+\t\tType* pint_type = Type::make_pointer_type(int_type);\n+\t\targ = Expression::make_unsafe_cast(pint_type, arg, location);\n+\t\tExpression* nil = Expression::make_nil(location);\n+\t\tnil = Expression::make_cast(pint_type, nil, location);\n+\t\tExpression* cmp = Expression::make_binary(OPERATOR_EQEQ,\n+\t\t\t\t\t\t\t  arg, nil, location);\n+\t\tExpression* zero = Expression::make_integer_ul(0, int_type,\n+\t\t\t\t\t\t\t       location);\n+\t\tExpression* indir = Expression::make_unary(OPERATOR_MULT,\n+\t\t\t\t\t\t\t   arg, location);\n+\t\tval = Expression::make_conditional(cmp, zero, indir, location);\n+\t      }\n \t    else\n \t      go_unreachable();\n \t  }\n@@ -9866,11 +9885,7 @@ Index_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n \t  error_at(location, \"invalid slice of map\");\n \t  return Expression::make_error(location);\n \t}\n-      Map_index_expression* ret = Expression::make_map_index(left, start,\n-\t\t\t\t\t\t\t     location);\n-      if (this->is_lvalue_)\n-\tret->set_is_lvalue();\n-      return ret;\n+      return Expression::make_map_index(left, start, location);\n     }\n   else\n     {\n@@ -10666,7 +10681,7 @@ Expression::make_string_index(Expression* string, Expression* start,\n Map_type*\n Map_index_expression::get_map_type() const\n {\n-  Map_type* mt = this->map_->type()->deref()->map_type();\n+  Map_type* mt = this->map_->type()->map_type();\n   if (mt == NULL)\n     go_assert(saw_errors());\n   return mt;\n@@ -10724,7 +10739,7 @@ Map_index_expression::do_flatten(Gogo* gogo, Named_object*,\n     }\n \n   if (this->value_pointer_ == NULL)\n-    this->get_value_pointer(this->is_lvalue_);\n+    this->get_value_pointer(gogo);\n   if (this->value_pointer_->is_error_expression()\n       || this->value_pointer_->type()->is_error_type())\n     return Expression::make_error(loc);\n@@ -10747,14 +10762,7 @@ Map_index_expression::do_type()\n   Map_type* mt = this->get_map_type();\n   if (mt == NULL)\n     return Type::make_error_type();\n-  Type* type = mt->val_type();\n-  // If this map index is in a tuple assignment, we actually return a\n-  // pointer to the value type.  Tuple_map_assignment_statement is\n-  // responsible for handling this correctly.  We need to get the type\n-  // right in case this gets assigned to a temporary variable.\n-  if (this->is_in_tuple_assignment_)\n-    type = Type::make_pointer_type(type);\n-  return type;\n+  return mt->val_type();\n }\n \n // Fix the type of a map index.\n@@ -10806,47 +10814,17 @@ Map_index_expression::do_get_backend(Translate_context* context)\n   go_assert(this->value_pointer_ != NULL\n             && this->value_pointer_->is_variable());\n \n-  Bexpression* ret;\n-  if (this->is_lvalue_)\n-    {\n-      Expression* val =\n-          Expression::make_unary(OPERATOR_MULT, this->value_pointer_,\n-                                 this->location());\n-      ret = val->get_backend(context);\n-    }\n-  else if (this->is_in_tuple_assignment_)\n-    {\n-      // Tuple_map_assignment_statement is responsible for using this\n-      // appropriately.\n-      ret = this->value_pointer_->get_backend(context);\n-    }\n-  else\n-    {\n-      Location loc = this->location();\n-\n-      Expression* nil_check =\n-          Expression::make_binary(OPERATOR_EQEQ, this->value_pointer_,\n-                                  Expression::make_nil(loc), loc);\n-      Bexpression* bnil_check = nil_check->get_backend(context);\n-      Expression* val =\n-          Expression::make_unary(OPERATOR_MULT, this->value_pointer_, loc);\n-      Bexpression* bval = val->get_backend(context);\n-\n-      Gogo* gogo = context->gogo();\n-      Btype* val_btype = type->val_type()->get_backend(gogo);\n-      Bexpression* val_zero = gogo->backend()->zero_expression(val_btype);\n-      ret = gogo->backend()->conditional_expression(val_btype, bnil_check,\n-                                                    val_zero, bval, loc);\n-    }\n-  return ret;\n+  Expression* val = Expression::make_unary(OPERATOR_MULT, this->value_pointer_,\n+\t\t\t\t\t   this->location());\n+  return val->get_backend(context);\n }\n \n-// Get an expression for the map index.  This returns an expression which\n-// evaluates to a pointer to a value.  The pointer will be NULL if the key is\n-// not in the map.\n+// Get an expression for the map index.  This returns an expression\n+// that evaluates to a pointer to a value.  If the key is not in the\n+// map, the pointer will point to a zero value.\n \n Expression*\n-Map_index_expression::get_value_pointer(bool insert)\n+Map_index_expression::get_value_pointer(Gogo* gogo)\n {\n   if (this->value_pointer_ == NULL)\n     {\n@@ -10859,21 +10837,32 @@ Map_index_expression::get_value_pointer(bool insert)\n \n       Location loc = this->location();\n       Expression* map_ref = this->map_;\n-      if (this->map_->type()->points_to() != NULL)\n-        map_ref = Expression::make_unary(OPERATOR_MULT, map_ref, loc);\n \n-      Expression* index_ptr = Expression::make_unary(OPERATOR_AND, this->index_,\n+      Expression* index_ptr = Expression::make_unary(OPERATOR_AND,\n+\t\t\t\t\t\t     this->index_,\n                                                      loc);\n-      Expression* map_index =\n-          Runtime::make_call(Runtime::MAP_INDEX, loc, 3,\n-                             map_ref, index_ptr,\n-                             Expression::make_boolean(insert, loc));\n+\n+      Expression* zero = type->fat_zero_value(gogo);\n+\n+      Expression* map_index;\n+\n+      if (zero == NULL)\n+\tmap_index =\n+          Runtime::make_call(Runtime::MAPACCESS1, loc, 3,\n+\t\t\t     Expression::make_type_descriptor(type, loc),\n+                             map_ref, index_ptr);\n+      else\n+\tmap_index =\n+\t  Runtime::make_call(Runtime::MAPACCESS1_FAT, loc, 4,\n+\t\t\t     Expression::make_type_descriptor(type, loc),\n+\t\t\t     map_ref, index_ptr, zero);\n \n       Type* val_type = type->val_type();\n       this->value_pointer_ =\n           Expression::make_unsafe_cast(Type::make_pointer_type(val_type),\n                                        map_index, this->location());\n     }\n+\n   return this->value_pointer_;\n }\n \n@@ -12583,7 +12572,7 @@ Map_construction_expression::do_get_backend(Translate_context* context)\n           Type::make_builtin_struct_type(2,\n                                          \"__key\", mt->key_type(),\n                                          \"__val\", mt->val_type());\n-  Expression* descriptor = Expression::make_map_descriptor(mt, loc);\n+  Expression* descriptor = Expression::make_type_descriptor(mt, loc);\n \n   Type* uintptr_t = Type::lookup_integer_type(\"uintptr\");\n   Expression* count = Expression::make_integer_ul(i, uintptr_t, loc);\n@@ -12596,12 +12585,10 @@ Map_construction_expression::do_get_backend(Translate_context* context)\n       this->element_type_->find_local_field(\"__val\", &field_index);\n   Expression* val_offset =\n       Expression::make_struct_field_offset(this->element_type_, valfield);\n-  Expression* val_size =\n-      Expression::make_type_info(mt->val_type(), TYPE_INFO_SIZE);\n \n   Expression* map_ctor =\n-      Runtime::make_call(Runtime::CONSTRUCT_MAP, loc, 6, descriptor, count,\n-                         entry_size, val_offset, val_size, ventries);\n+      Runtime::make_call(Runtime::CONSTRUCT_MAP, loc, 5, descriptor, count,\n+                         entry_size, val_offset, ventries);\n   return map_ctor->get_backend(context);\n }\n \n@@ -14608,64 +14595,6 @@ Expression::make_struct_field_offset(Struct_type* type,\n   return new Struct_field_offset_expression(type, field);\n }\n \n-// An expression which evaluates to a pointer to the map descriptor of\n-// a map type.\n-\n-class Map_descriptor_expression : public Expression\n-{\n- public:\n-  Map_descriptor_expression(Map_type* type, Location location)\n-    : Expression(EXPRESSION_MAP_DESCRIPTOR, location),\n-      type_(type)\n-  { }\n-\n- protected:\n-  Type*\n-  do_type()\n-  { return Type::make_pointer_type(Map_type::make_map_descriptor_type()); }\n-\n-  void\n-  do_determine_type(const Type_context*)\n-  { }\n-\n-  Expression*\n-  do_copy()\n-  { return this; }\n-\n-  Bexpression*\n-  do_get_backend(Translate_context* context)\n-  {\n-    return this->type_->map_descriptor_pointer(context->gogo(),\n-\t\t\t\t\t       this->location());\n-  }\n-\n-  void\n-  do_dump_expression(Ast_dump_context*) const;\n- \n- private:\n-  // The type for which this is the descriptor.\n-  Map_type* type_;\n-};\n-\n-// Dump ast representation for a map descriptor expression.\n-\n-void\n-Map_descriptor_expression::do_dump_expression(\n-    Ast_dump_context* ast_dump_context) const\n-{\n-  ast_dump_context->ostream() << \"map_descriptor(\";\n-  ast_dump_context->dump_type(this->type_);\n-  ast_dump_context->ostream() << \")\";\n-}\n-\n-// Make a map descriptor expression.\n-\n-Expression*\n-Expression::make_map_descriptor(Map_type* type, Location location)\n-{\n-  return new Map_descriptor_expression(type, location);\n-}\n-\n // An expression which evaluates to the address of an unnamed label.\n \n class Label_addr_expression : public Expression"}, {"sha": "8ecc11afd7ffd1f66d774d3c689786a6081eb545", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 7, "deletions": 45, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -133,7 +133,6 @@ class Expression\n     EXPRESSION_INTERFACE_VALUE,\n     EXPRESSION_INTERFACE_MTABLE,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n-    EXPRESSION_MAP_DESCRIPTOR,\n     EXPRESSION_LABEL_ADDR,\n     EXPRESSION_CONDITIONAL,\n     EXPRESSION_COMPOUND\n@@ -467,11 +466,6 @@ class Expression\n   static Expression*\n   make_struct_field_offset(Struct_type*, const Struct_field*);\n \n-  // Make an expression which evaluates to the address of the map\n-  // descriptor for TYPE.\n-  static Expression*\n-  make_map_descriptor(Map_type* type, Location);\n-\n   // Make an expression which evaluates to the address of an unnamed\n   // label.\n   static Expression*\n@@ -2449,14 +2443,9 @@ class Index_expression : public Parser_expression\n   Index_expression(Expression* left, Expression* start, Expression* end,\n                    Expression* cap, Location location)\n     : Parser_expression(EXPRESSION_INDEX, location),\n-      left_(left), start_(start), end_(end), cap_(cap), is_lvalue_(false)\n+      left_(left), start_(start), end_(end), cap_(cap)\n   { }\n \n-  // Record that this expression is an lvalue.\n-  void\n-  set_is_lvalue()\n-  { this->is_lvalue_ = true; }\n-\n   // Dump an index expression, i.e. an expression of the form\n   // expr[expr], expr[expr:expr], or expr[expr:expr:expr] to a dump context.\n   static void\n@@ -2509,9 +2498,6 @@ class Index_expression : public Parser_expression\n   // default capacity, non-NULL for indices and slices that specify the\n   // capacity.\n   Expression* cap_;\n-  // Whether this is being used as an l-value.  We set this during the\n-  // parse because map index expressions need to know.\n-  bool is_lvalue_;\n };\n \n // An array index.  This is used for both indexing and slicing.\n@@ -2677,8 +2663,7 @@ class Map_index_expression : public Expression\n   Map_index_expression(Expression* map, Expression* index,\n \t\t       Location location)\n     : Expression(EXPRESSION_MAP_INDEX, location),\n-      map_(map), index_(index), is_lvalue_(false),\n-      is_in_tuple_assignment_(false), value_pointer_(NULL)\n+      map_(map), index_(index), value_pointer_(NULL)\n   { }\n \n   // Return the map.\n@@ -2703,31 +2688,12 @@ class Map_index_expression : public Expression\n   Map_type*\n   get_map_type() const;\n \n-  // Record that this map expression is an lvalue.  The difference is\n-  // that an lvalue always inserts the key.\n-  void\n-  set_is_lvalue()\n-  { this->is_lvalue_ = true; }\n-\n-  // Return whether this map expression occurs in an assignment to a\n-  // pair of values.\n-  bool\n-  is_in_tuple_assignment() const\n-  { return this->is_in_tuple_assignment_; }\n-\n-  // Record that this map expression occurs in an assignment to a pair\n-  // of values.\n-  void\n-  set_is_in_tuple_assignment()\n-  { this->is_in_tuple_assignment_ = true; }\n-\n-  // Return an expression for the map index.  This returns an expression which\n-  // evaluates to a pointer to a value in the map.  If INSERT is true,\n-  // the key will be inserted if not present, and the value pointer\n-  // will be zero initialized.  If INSERT is false, and the key is not\n-  // present in the map, the pointer will be NULL.\n+  // Return an expression for the map index.  This returns an\n+  // expression that evaluates to a pointer to a value in the map.  If\n+  // the key is not present in the map, this will return a pointer to\n+  // the zero value.\n   Expression*\n-  get_value_pointer(bool insert);\n+  get_value_pointer(Gogo*);\n \n  protected:\n   int\n@@ -2773,10 +2739,6 @@ class Map_index_expression : public Expression\n   Expression* map_;\n   // The index.\n   Expression* index_;\n-  // Whether this is an lvalue.\n-  bool is_lvalue_;\n-  // Whether this is in a tuple assignment to a pair of values.\n-  bool is_in_tuple_assignment_;\n   // A pointer to the value at this index.\n   Expression* value_pointer_;\n };"}, {"sha": "a3afdcb7b9ad3eaf184dd47441b00a6e4a3a1bc7", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -4614,7 +4614,6 @@ Gogo::convert_named_types()\n   Array_type::make_array_type_descriptor_type();\n   Array_type::make_slice_type_descriptor_type();\n   Map_type::make_map_type_descriptor_type();\n-  Map_type::make_map_descriptor_type();\n   Channel_type::make_chan_type_descriptor_type();\n   Interface_type::make_interface_type_descriptor_type();\n   Expression::make_func_descriptor_type();\n@@ -6547,7 +6546,9 @@ Variable::get_backend_variable(Gogo* gogo, Named_object* function,\n \t  Btype* btype = type->get_backend(gogo);\n \n \t  Bvariable* bvar;\n-\t  if (this->is_global_)\n+\t  if (Map_type::is_zero_value(this))\n+\t    bvar = Map_type::backend_zero_value(gogo);\n+\t  else if (this->is_global_)\n \t    bvar = backend->global_variable((package == NULL\n \t\t\t\t\t     ? gogo->package_name()\n \t\t\t\t\t     : package->package_name()),"}, {"sha": "6b45ebf4fd07b32e178a074936b4eb9dfa3a6d65", "filename": "gcc/go/gofrontend/parse.cc", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fparse.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -4039,11 +4039,6 @@ void\n Parse::inc_dec_stat(Expression* exp)\n {\n   const Token* token = this->peek_token();\n-\n-  // Lvalue maps require special handling.\n-  if (exp->index_expression() != NULL)\n-    exp->index_expression()->set_is_lvalue();\n-\n   if (token->is_op(OPERATOR_PLUSPLUS))\n     this->gogo_->add_statement(Statement::make_inc_statement(exp));\n   else if (token->is_op(OPERATOR_MINUSMINUS))\n@@ -4120,13 +4115,6 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n   if (lhs == NULL)\n     return;\n \n-  // Map expressions act differently when they are lvalues.\n-  for (Expression_list::iterator plv = lhs->begin();\n-       plv != lhs->end();\n-       ++plv)\n-    if ((*plv)->index_expression() != NULL)\n-      (*plv)->index_expression()->set_is_lvalue();\n-\n   if (p_range_clause != NULL && token->is_keyword(KEYWORD_RANGE))\n     {\n       if (op != OPERATOR_EQ)\n@@ -4209,18 +4197,6 @@ Parse::tuple_assignment(Expression_list* lhs, bool may_be_composite_lit,\n \t\t\t\t\t\t\t  map_index, location);\n       this->gogo_->add_statement(s);\n     }\n-  else if (lhs->size() == 1\n-\t   && vals->size() == 2\n-\t   && (map_index = lhs->front()->index_expression()) != NULL)\n-    {\n-      if (op != OPERATOR_EQ)\n-\terror_at(location, \"assigning tuple to map index requires %<=%>\");\n-      Expression* val = vals->front();\n-      Expression* should_set = vals->back();\n-      Statement* s = Statement::make_map_assignment(map_index, val, should_set,\n-\t\t\t\t\t\t    location);\n-      this->gogo_->add_statement(s);\n-    }\n   else if (lhs->size() == 2\n \t   && vals->size() == 1\n \t   && (receive = (*vals->begin())->receive_expression()) != NULL)\n@@ -4952,13 +4928,6 @@ Parse::comm_clause(Select_clauses* clauses, bool* saw_default)\n   bool got_case = this->comm_case(&is_send, &channel, &val, &closed,\n \t\t\t\t  &varname, &closedname, &is_default);\n \n-  if (!is_send\n-      && varname.empty()\n-      && closedname.empty()\n-      && val != NULL\n-      && val->index_expression() != NULL)\n-    val->index_expression()->set_is_lvalue();\n-\n   if (this->peek_token()->is_op(OPERATOR_COLON))\n     this->advance_token();\n   else"}, {"sha": "98678f4adea47ef6d7f0a84da089937481a2b7d7", "filename": "gcc/go/gofrontend/runtime.cc", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -54,8 +54,6 @@ enum Runtime_function_type\n   RFT_SLICE,\n   // Go type map[any]any, C type struct __go_map *.\n   RFT_MAP,\n-  // Pointer to map iteration type.\n-  RFT_MAPITER,\n   // Go type chan any, C type struct __go_channel *.\n   RFT_CHAN,\n   // Go type non-empty interface, C type struct __go_interface.\n@@ -66,8 +64,6 @@ enum Runtime_function_type\n   RFT_FUNC_PTR,\n   // Pointer to Go type descriptor.\n   RFT_TYPE,\n-  // Pointer to map descriptor.\n-  RFT_MAPDESCRIPTOR,\n \n   NUMBER_OF_RUNTIME_FUNCTION_TYPES\n };\n@@ -153,10 +149,6 @@ runtime_function_type(Runtime_function_type bft)\n \t  t = Type::make_map_type(any, any, bloc);\n \t  break;\n \n-\tcase RFT_MAPITER:\n-\t  t = Type::make_pointer_type(Runtime::map_iteration_type());\n-\t  break;\n-\n \tcase RFT_CHAN:\n \t  t = Type::make_channel_type(true, true, any);\n \t  break;\n@@ -188,10 +180,6 @@ runtime_function_type(Runtime_function_type bft)\n \tcase RFT_TYPE:\n \t  t = Type::make_type_descriptor_ptr_type();\n \t  break;\n-\n-\tcase RFT_MAPDESCRIPTOR:\n-\t  t = Type::make_pointer_type(Map_type::make_map_descriptor_type());\n-\t  break;\n \t}\n \n       runtime_function_types[bft] = t;\n@@ -225,7 +213,6 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_COMPLEX128:\n     case RFT_STRING:\n     case RFT_POINTER:\n-    case RFT_MAPITER:\n     case RFT_FUNC_PTR:\n       {\n \tType* t = runtime_function_type(bft);\n@@ -244,11 +231,6 @@ convert_to_runtime_function_type(Runtime_function_type bft, Expression* e,\n     case RFT_TYPE:\n       go_assert(e->type() == Type::make_type_descriptor_ptr_type());\n       return e;\n-\n-    case RFT_MAPDESCRIPTOR:\n-      go_assert(e->type()->points_to()\n-\t\t== Map_type::make_map_descriptor_type());\n-      return e;\n     }\n }\n \n@@ -389,21 +371,6 @@ Runtime::make_call(Runtime::Function code, Location loc,\n   return Expression::make_call(func, args, false, loc);\n }\n \n-// The type we use for a map iteration.  This is really a struct which\n-// is four pointers long.  This must match the runtime struct\n-// __go_hash_iter.\n-\n-Type*\n-Runtime::map_iteration_type()\n-{\n-  const unsigned long map_iteration_size = 4;\n-  Expression* iexpr =\n-    Expression::make_integer_ul(map_iteration_size, NULL,\n-\t\t\t\tLinemap::predeclared_location());\n-  return Type::make_array_type(runtime_function_type(RFT_POINTER), iexpr);\n-}\n-\n-\n // Get the runtime code for a named builtin function.  This is used as a helper\n // when creating function references for call expressions.  Every reference to\n // a builtin runtime function should have the associated runtime code.  If the"}, {"sha": "2be772bc9506f3a027d797a2b60ba0a656e499a4", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -85,54 +85,51 @@ DEF_GO_RUNTIME(MAKESLICE2BIG, \"__go_make_slice2_big\", P3(TYPE, UINT64, UINT64),\n \n \n // Make a map.\n-DEF_GO_RUNTIME(MAKEMAP, \"__go_new_map\", P2(MAPDESCRIPTOR, UINTPTR), R1(MAP))\n-DEF_GO_RUNTIME(MAKEMAPBIG, \"__go_new_map_big\", P2(MAPDESCRIPTOR, UINT64),\n+DEF_GO_RUNTIME(MAKEMAP, \"runtime.makemap\", P4(TYPE, INT64, POINTER, POINTER),\n \t       R1(MAP))\n \n // Build a map from a composite literal.\n DEF_GO_RUNTIME(CONSTRUCT_MAP, \"__go_construct_map\",\n-\t       P6(POINTER, UINTPTR, UINTPTR, UINTPTR, UINTPTR, POINTER),\n+\t       P5(POINTER, UINTPTR, UINTPTR, UINTPTR, POINTER),\n \t       R1(MAP))\n \n-// Get the length of a map (the number of entries).\n-DEF_GO_RUNTIME(MAP_LEN, \"__go_map_len\", P1(MAP), R1(INT))\n-\n // Look up a key in a map.\n-DEF_GO_RUNTIME(MAP_INDEX, \"__go_map_index\", P3(MAP, POINTER, BOOL),\n+DEF_GO_RUNTIME(MAPACCESS1, \"runtime.mapaccess1\", P3(TYPE, MAP, POINTER),\n \t       R1(POINTER))\n \n-// Look up a key in a map returning whether it is present.\n-DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\",\n-\t       P4(TYPE, MAP, POINTER, POINTER), R1(BOOL))\n+// Look up a key in a map when the value is large.\n+DEF_GO_RUNTIME(MAPACCESS1_FAT, \"runtime.mapaccess1_fat\",\n+\t       P4(TYPE, MAP, POINTER, POINTER), R1(POINTER))\n \n-// Tuple assignment to a map element.\n-DEF_GO_RUNTIME(MAPASSIGN2, \"runtime.mapassign2\",\n-\t       P4(MAP, POINTER, POINTER, BOOL), R0())\n+// Look up a key in a map returning the value and whether it is\n+// present.\n+DEF_GO_RUNTIME(MAPACCESS2, \"runtime.mapaccess2\", P3(TYPE, MAP, POINTER),\n+\t       R2(POINTER, BOOL))\n \n-// Delete a key from a map.\n-DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P2(MAP, POINTER), R0())\n+// Look up a key in a map, returning the value and whether it is\n+// present, when the value is large.\n+DEF_GO_RUNTIME(MAPACCESS2_FAT, \"runtime.mapaccess2_fat\",\n+\t       P4(TYPE, MAP, POINTER, POINTER), R2(POINTER, BOOL))\n \n-// Begin a range over a map.\n-DEF_GO_RUNTIME(MAPITERINIT, \"runtime.mapiterinit\", P2(MAP, MAPITER), R0())\n+// Assignment to a key in a map.\n+DEF_GO_RUNTIME(MAPASSIGN, \"runtime.mapassign1\",\n+\t       P4(TYPE, MAP, POINTER, POINTER), R0())\n \n-// Range over a map, returning the next key.\n-DEF_GO_RUNTIME(MAPITER1, \"runtime.mapiter1\", P2(MAPITER, POINTER), R0())\n+// Delete a key from a map.\n+DEF_GO_RUNTIME(MAPDELETE, \"runtime.mapdelete\", P3(TYPE, MAP, POINTER), R0())\n \n-// Range over a map, returning the next key and value.\n-DEF_GO_RUNTIME(MAPITER2, \"runtime.mapiter2\", P3(MAPITER, POINTER, POINTER),\n+// Begin a range over a map.\n+DEF_GO_RUNTIME(MAPITERINIT, \"runtime.mapiterinit\", P3(TYPE, MAP, POINTER),\n \t       R0())\n \n // Range over a map, moving to the next map entry.\n-DEF_GO_RUNTIME(MAPITERNEXT, \"runtime.mapiternext\", P1(MAPITER), R0())\n+DEF_GO_RUNTIME(MAPITERNEXT, \"runtime.mapiternext\", P1(POINTER), R0())\n \n \n // Make a channel.\n DEF_GO_RUNTIME(MAKECHAN, \"__go_new_channel\", P2(TYPE, UINTPTR), R1(CHAN))\n DEF_GO_RUNTIME(MAKECHANBIG, \"__go_new_channel_big\", P2(TYPE, UINT64), R1(CHAN))\n \n-// Get the length of a channel (the number of unread values).\n-DEF_GO_RUNTIME(CHAN_LEN, \"__go_chan_len\", P1(CHAN), R1(INT))\n-\n // Get the capacity of a channel (the size of the buffer).\n DEF_GO_RUNTIME(CHAN_CAP, \"__go_chan_cap\", P1(CHAN), R1(INT))\n "}, {"sha": "e92510b33db0b42e8e59c9b663c04f95bcc459ca", "filename": "gcc/go/gofrontend/runtime.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -39,10 +39,6 @@ class Runtime\n   static void\n   convert_types(Gogo*);\n \n-  // Return the type used for iterations over maps.\n-  static Type*\n-  map_iteration_type();\n-\n   // Return the runtime code for a named builtin function.\n   static Function\n   name_to_code(const std::string&);"}, {"sha": "9e481741ad6152427f36850dd176cd9a311ecc99", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 221, "deletions": 293, "changes": 514, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -544,6 +544,106 @@ Statement::make_temporary(Type* type, Expression* init,\n   return new Temporary_statement(type, init, location);\n }\n \n+// The Move_subexpressions class is used to move all top-level\n+// subexpressions of an expression.  This is used for things like\n+// index expressions in which we must evaluate the index value before\n+// it can be changed by a multiple assignment.\n+\n+class Move_subexpressions : public Traverse\n+{\n+ public:\n+  Move_subexpressions(int skip, Block* block)\n+    : Traverse(traverse_expressions),\n+      skip_(skip), block_(block)\n+  { }\n+\n+ protected:\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The number of subexpressions to skip moving.  This is used to\n+  // avoid moving the array itself, as we only need to move the index.\n+  int skip_;\n+  // The block where new temporary variables should be added.\n+  Block* block_;\n+};\n+\n+int\n+Move_subexpressions::expression(Expression** pexpr)\n+{\n+  if (this->skip_ > 0)\n+    --this->skip_;\n+  else if ((*pexpr)->temporary_reference_expression() == NULL\n+\t   && !(*pexpr)->is_nil_expression()\n+           && !(*pexpr)->is_constant())\n+    {\n+      Location loc = (*pexpr)->location();\n+      Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n+      this->block_->add_statement(temp);\n+      *pexpr = Expression::make_temporary_reference(temp, loc);\n+    }\n+  // We only need to move top-level subexpressions.\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n+// The Move_ordered_evals class is used to find any subexpressions of\n+// an expression that have an evaluation order dependency.  It creates\n+// temporary variables to hold them.\n+\n+class Move_ordered_evals : public Traverse\n+{\n+ public:\n+  Move_ordered_evals(Block* block)\n+    : Traverse(traverse_expressions),\n+      block_(block)\n+  { }\n+\n+ protected:\n+  int\n+  expression(Expression**);\n+\n+ private:\n+  // The block where new temporary variables should be added.\n+  Block* block_;\n+};\n+\n+int\n+Move_ordered_evals::expression(Expression** pexpr)\n+{\n+  // We have to look at subexpressions first.\n+  if ((*pexpr)->traverse_subexpressions(this) == TRAVERSE_EXIT)\n+    return TRAVERSE_EXIT;\n+\n+  int i;\n+  if ((*pexpr)->must_eval_subexpressions_in_order(&i))\n+    {\n+      Move_subexpressions ms(i, this->block_);\n+      if ((*pexpr)->traverse_subexpressions(&ms) == TRAVERSE_EXIT)\n+\treturn TRAVERSE_EXIT;\n+    }\n+\n+  if ((*pexpr)->must_eval_in_order())\n+    {\n+      Call_expression* call = (*pexpr)->call_expression();\n+      if (call != NULL && call->is_multi_value_arg())\n+\t{\n+\t  // A call expression which returns multiple results as an argument\n+\t  // to another call must be handled specially.  We can't create a\n+\t  // temporary because there is no type to give it.  Instead, group\n+\t  // the caller and this multi-valued call argument and use a temporary\n+\t  // variable to hold them.\n+\t  return TRAVERSE_SKIP_COMPONENTS;\n+\t}\n+\n+      Location loc = (*pexpr)->location();\n+      Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n+      this->block_->add_statement(temp);\n+      *pexpr = Expression::make_temporary_reference(temp, loc);\n+    }\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n // Class Assignment_statement.\n \n // Traversal.\n@@ -563,6 +663,66 @@ Assignment_statement::do_traverse_assignments(Traverse_assignments* tassign)\n   return true;\n }\n \n+// Lower an assignment to a map index expression to a runtime function\n+// call.\n+\n+Statement*\n+Assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n+\t\t\t       Statement_inserter*)\n+{\n+  Map_index_expression* mie = this->lhs_->map_index_expression();\n+  if (mie != NULL)\n+    {\n+      Location loc = this->location();\n+\n+      Expression* map = mie->map();\n+      Map_type* mt = map->type()->map_type();\n+      if (mt == NULL)\n+\t{\n+\t  go_assert(saw_errors());\n+\t  return Statement::make_error_statement(loc);\n+\t}\n+\n+      Block* b = new Block(enclosing, loc);\n+\n+      // Move out any subexpressions on the left hand side to make\n+      // sure that functions are called in the required order.\n+      Move_ordered_evals moe(b);\n+      mie->traverse_subexpressions(&moe);\n+\n+      // Copy key and value into temporaries so that we can take their\n+      // address without pushing the value onto the heap.\n+\n+      // var key_temp KEY_TYPE = MAP_INDEX\n+      Temporary_statement* key_temp = Statement::make_temporary(mt->key_type(),\n+\t\t\t\t\t\t\t\tmie->index(),\n+\t\t\t\t\t\t\t\tloc);\n+      b->add_statement(key_temp);\n+\n+      // var val_temp VAL_TYPE = RHS\n+      Temporary_statement* val_temp = Statement::make_temporary(mt->val_type(),\n+\t\t\t\t\t\t\t\tthis->rhs_,\n+\t\t\t\t\t\t\t\tloc);\n+      b->add_statement(val_temp);\n+\n+      // mapassign1(TYPE, MAP, &key_temp, &val_temp)\n+      Expression* a1 = Expression::make_type_descriptor(mt, loc);\n+      Expression* a2 = mie->map();\n+      Temporary_reference_expression* ref =\n+\tExpression::make_temporary_reference(key_temp, loc);\n+      Expression* a3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      ref = Expression::make_temporary_reference(val_temp, loc);\n+      Expression* a4 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+      Expression* call = Runtime::make_call(Runtime::MAPASSIGN, loc, 4,\n+\t\t\t\t\t    a1, a2, a3, a4);\n+      b->add_statement(Statement::make_statement(call, false));\n+\n+      return Statement::make_block_statement(b, loc);\n+    }\n+\n+  return this;\n+}\n+\n // Set types for the assignment.\n \n void\n@@ -690,106 +850,6 @@ Statement::make_assignment(Expression* lhs, Expression* rhs,\n   return new Assignment_statement(lhs, rhs, location);\n }\n \n-// The Move_subexpressions class is used to move all top-level\n-// subexpressions of an expression.  This is used for things like\n-// index expressions in which we must evaluate the index value before\n-// it can be changed by a multiple assignment.\n-\n-class Move_subexpressions : public Traverse\n-{\n- public:\n-  Move_subexpressions(int skip, Block* block)\n-    : Traverse(traverse_expressions),\n-      skip_(skip), block_(block)\n-  { }\n-\n- protected:\n-  int\n-  expression(Expression**);\n-\n- private:\n-  // The number of subexpressions to skip moving.  This is used to\n-  // avoid moving the array itself, as we only need to move the index.\n-  int skip_;\n-  // The block where new temporary variables should be added.\n-  Block* block_;\n-};\n-\n-int\n-Move_subexpressions::expression(Expression** pexpr)\n-{\n-  if (this->skip_ > 0)\n-    --this->skip_;\n-  else if ((*pexpr)->temporary_reference_expression() == NULL\n-\t   && !(*pexpr)->is_nil_expression()\n-           && !(*pexpr)->is_constant())\n-    {\n-      Location loc = (*pexpr)->location();\n-      Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n-      this->block_->add_statement(temp);\n-      *pexpr = Expression::make_temporary_reference(temp, loc);\n-    }\n-  // We only need to move top-level subexpressions.\n-  return TRAVERSE_SKIP_COMPONENTS;\n-}\n-\n-// The Move_ordered_evals class is used to find any subexpressions of\n-// an expression that have an evaluation order dependency.  It creates\n-// temporary variables to hold them.\n-\n-class Move_ordered_evals : public Traverse\n-{\n- public:\n-  Move_ordered_evals(Block* block)\n-    : Traverse(traverse_expressions),\n-      block_(block)\n-  { }\n-\n- protected:\n-  int\n-  expression(Expression**);\n-\n- private:\n-  // The block where new temporary variables should be added.\n-  Block* block_;\n-};\n-\n-int\n-Move_ordered_evals::expression(Expression** pexpr)\n-{\n-  // We have to look at subexpressions first.\n-  if ((*pexpr)->traverse_subexpressions(this) == TRAVERSE_EXIT)\n-    return TRAVERSE_EXIT;\n-\n-  int i;\n-  if ((*pexpr)->must_eval_subexpressions_in_order(&i))\n-    {\n-      Move_subexpressions ms(i, this->block_);\n-      if ((*pexpr)->traverse_subexpressions(&ms) == TRAVERSE_EXIT)\n-\treturn TRAVERSE_EXIT;\n-    }\n-\n-  if ((*pexpr)->must_eval_in_order())\n-    {\n-      Call_expression* call = (*pexpr)->call_expression();\n-      if (call != NULL && call->is_multi_value_arg())\n-\t{\n-\t  // A call expression which returns multiple results as an argument\n-\t  // to another call must be handled specially.  We can't create a\n-\t  // temporary because there is no type to give it.  Instead, group\n-\t  // the caller and this multi-valued call argument and use a temporary\n-\t  // variable to hold them.\n-\t  return TRAVERSE_SKIP_COMPONENTS;\n-\t}\n-\n-      Location loc = (*pexpr)->location();\n-      Temporary_statement* temp = Statement::make_temporary(NULL, *pexpr, loc);\n-      this->block_->add_statement(temp);\n-      *pexpr = Expression::make_temporary_reference(temp, loc);\n-    }\n-  return TRAVERSE_SKIP_COMPONENTS;\n-}\n-\n // An assignment operation statement.\n \n class Assignment_operation_statement : public Statement\n@@ -1131,7 +1191,7 @@ Tuple_map_assignment_statement::do_traverse(Traverse* traverse)\n // Lower a tuple map assignment.\n \n Statement*\n-Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n+Tuple_map_assignment_statement::do_lower(Gogo* gogo, Named_object*,\n \t\t\t\t\t Block* enclosing, Statement_inserter*)\n {\n   Location loc = this->location();\n@@ -1162,10 +1222,11 @@ Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n     Statement::make_temporary(map_type->key_type(), map_index->index(), loc);\n   b->add_statement(key_temp);\n \n-  // var val_temp VAL_TYPE\n-  Temporary_statement* val_temp =\n-    Statement::make_temporary(map_type->val_type(), NULL, loc);\n-  b->add_statement(val_temp);\n+  // var val_ptr_temp *VAL_TYPE\n+  Type* val_ptr_type = Type::make_pointer_type(map_type->val_type());\n+  Temporary_statement* val_ptr_temp = Statement::make_temporary(val_ptr_type,\n+\t\t\t\t\t\t\t\tNULL, loc);\n+  b->add_statement(val_ptr_temp);\n \n   // var present_temp bool\n   Temporary_statement* present_temp =\n@@ -1175,24 +1236,34 @@ Tuple_map_assignment_statement::do_lower(Gogo*, Named_object*,\n \t\t\t      NULL, loc);\n   b->add_statement(present_temp);\n \n-  // present_temp = mapaccess2(DESCRIPTOR, MAP, &key_temp, &val_temp)\n+  // val_ptr_temp, present_temp = mapaccess2(DESCRIPTOR, MAP, &key_temp)\n   Expression* a1 = Expression::make_type_descriptor(map_type, loc);\n   Expression* a2 = map_index->map();\n   Temporary_reference_expression* ref =\n     Expression::make_temporary_reference(key_temp, loc);\n   Expression* a3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  ref = Expression::make_temporary_reference(val_temp, loc);\n-  Expression* a4 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  Expression* call = Runtime::make_call(Runtime::MAPACCESS2, loc, 4,\n-\t\t\t\t\ta1, a2, a3, a4);\n+  Expression* a4 = map_type->fat_zero_value(gogo);\n+  Call_expression* call;\n+  if (a4 == NULL)\n+    call = Runtime::make_call(Runtime::MAPACCESS2, loc, 3, a1, a2, a3);\n+  else\n+    call = Runtime::make_call(Runtime::MAPACCESS2_FAT, loc, 4, a1, a2, a3, a4);\n+  ref = Expression::make_temporary_reference(val_ptr_temp, loc);\n+  ref->set_is_lvalue();\n+  Expression* res = Expression::make_call_result(call, 0);\n+  res = Expression::make_unsafe_cast(val_ptr_type, res, loc);\n+  Statement* s = Statement::make_assignment(ref, res, loc);\n+  b->add_statement(s);\n   ref = Expression::make_temporary_reference(present_temp, loc);\n   ref->set_is_lvalue();\n-  Statement* s = Statement::make_assignment(ref, call, loc);\n+  res = Expression::make_call_result(call, 1);\n+  s = Statement::make_assignment(ref, res, loc);\n   b->add_statement(s);\n \n-  // val = val_temp\n-  ref = Expression::make_temporary_reference(val_temp, loc);\n-  s = Statement::make_assignment(this->val_, ref, loc);\n+  // val = *val__ptr_temp\n+  ref = Expression::make_temporary_reference(val_ptr_temp, loc);\n+  Expression* ind = Expression::make_unary(OPERATOR_MULT, ref, loc);\n+  s = Statement::make_assignment(this->val_, ind, loc);\n   b->add_statement(s);\n \n   // present = present_temp\n@@ -1228,140 +1299,6 @@ Statement::make_tuple_map_assignment(Expression* val, Expression* present,\n   return new Tuple_map_assignment_statement(val, present, map_index, location);\n }\n \n-// Assign a pair of entries to a map.\n-//   m[k] = v, p\n-\n-class Map_assignment_statement : public Statement\n-{\n- public:\n-  Map_assignment_statement(Expression* map_index,\n-\t\t\t   Expression* val, Expression* should_set,\n-\t\t\t   Location location)\n-    : Statement(STATEMENT_MAP_ASSIGNMENT, location),\n-      map_index_(map_index), val_(val), should_set_(should_set)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse);\n-\n-  bool\n-  do_traverse_assignments(Traverse_assignments*)\n-  { go_unreachable(); }\n-\n-  Statement*\n-  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n-\n-  Bstatement*\n-  do_get_backend(Translate_context*)\n-  { go_unreachable(); }\n-\n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n-\n- private:\n-  // A reference to the map index which should be set or deleted.\n-  Expression* map_index_;\n-  // The value to add to the map.\n-  Expression* val_;\n-  // Whether or not to add the value.\n-  Expression* should_set_;\n-};\n-\n-// Traverse a map assignment.\n-\n-int\n-Map_assignment_statement::do_traverse(Traverse* traverse)\n-{\n-  if (this->traverse_expression(traverse, &this->map_index_) == TRAVERSE_EXIT\n-      || this->traverse_expression(traverse, &this->val_) == TRAVERSE_EXIT)\n-    return TRAVERSE_EXIT;\n-  return this->traverse_expression(traverse, &this->should_set_);\n-}\n-\n-// Lower a map assignment to a function call.\n-\n-Statement*\n-Map_assignment_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n-\t\t\t\t   Statement_inserter*)\n-{\n-  Location loc = this->location();\n-\n-  Map_index_expression* map_index = this->map_index_->map_index_expression();\n-  if (map_index == NULL)\n-    {\n-      this->report_error(_(\"expected map index on left hand side\"));\n-      return Statement::make_error_statement(loc);\n-    }\n-  Map_type* map_type = map_index->get_map_type();\n-  if (map_type == NULL)\n-    return Statement::make_error_statement(loc);\n-\n-  Block* b = new Block(enclosing, loc);\n-\n-  // Evaluate the map first to get order of evaluation right.\n-  // map_temp := m // we are evaluating m[k] = v, p\n-  Temporary_statement* map_temp = Statement::make_temporary(map_type,\n-\t\t\t\t\t\t\t    map_index->map(),\n-\t\t\t\t\t\t\t    loc);\n-  b->add_statement(map_temp);\n-\n-  // var key_temp MAP_KEY_TYPE = k\n-  Temporary_statement* key_temp =\n-    Statement::make_temporary(map_type->key_type(), map_index->index(), loc);\n-  b->add_statement(key_temp);\n-\n-  // var val_temp MAP_VAL_TYPE = v\n-  Temporary_statement* val_temp =\n-    Statement::make_temporary(map_type->val_type(), this->val_, loc);\n-  b->add_statement(val_temp);\n-\n-  // var insert_temp bool = p\n-  Temporary_statement* insert_temp =\n-    Statement::make_temporary(Type::lookup_bool_type(), this->should_set_,\n-\t\t\t      loc);\n-  b->add_statement(insert_temp);\n-\n-  // mapassign2(map_temp, &key_temp, &val_temp, p)\n-  Expression* p1 = Expression::make_temporary_reference(map_temp, loc);\n-  Expression* ref = Expression::make_temporary_reference(key_temp, loc);\n-  Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  ref = Expression::make_temporary_reference(val_temp, loc);\n-  Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  Expression* p4 = Expression::make_temporary_reference(insert_temp, loc);\n-  Expression* call = Runtime::make_call(Runtime::MAPASSIGN2, loc, 4,\n-\t\t\t\t\tp1, p2, p3, p4);\n-  Statement* s = Statement::make_statement(call, true);\n-  b->add_statement(s);\n-\n-  return Statement::make_block_statement(b, loc);\n-}\n-\n-// Dump the AST representation for a map assignment statement.\n-\n-void\n-Map_assignment_statement::do_dump_statement(\n-    Ast_dump_context* ast_dump_context) const\n-{\n-  ast_dump_context->print_indent();\n-  ast_dump_context->dump_expression(this->map_index_);\n-  ast_dump_context->ostream() << \" = \";\n-  ast_dump_context->dump_expression(this->val_);\n-  ast_dump_context->ostream() << \", \";\n-  ast_dump_context->dump_expression(this->should_set_);\n-  ast_dump_context->ostream() << std::endl;\n-}\n-\n-// Make a statement which assigns a pair of entries to a map.\n-\n-Statement*\n-Statement::make_map_assignment(Expression* map_index,\n-\t\t\t       Expression* val, Expression* should_set,\n-\t\t\t       Location location)\n-{\n-  return new Map_assignment_statement(map_index, val, should_set, location);\n-}\n-\n // A tuple assignment from a receive statement.\n \n class Tuple_receive_assignment_statement : public Statement\n@@ -1894,8 +1831,6 @@ Statement::make_dec_statement(Expression* expr)\n // Class Thunk_statement.  This is the base class for go and defer\n // statements.\n \n-Unordered_set(const Struct_type*) Thunk_statement::thunk_types;\n-\n // Constructor.\n \n Thunk_statement::Thunk_statement(Statement_classification classification,\n@@ -2278,21 +2213,10 @@ Thunk_statement::build_struct(Function_type* fntype)\n     }\n \n   Struct_type *st = Type::make_struct_type(fields, location);\n-\n-  Thunk_statement::thunk_types.insert(st);\n-\n+  st->set_is_struct_incomparable();\n   return st;\n }\n \n-// Return whether ST is a type created to hold thunk parameters.\n-\n-bool\n-Thunk_statement::is_thunk_struct(const Struct_type* st)\n-{\n-  return (Thunk_statement::thunk_types.find(st)\n-\t  != Thunk_statement::thunk_types.end());\n-}\n-\n // Build the thunk we are going to call.  This is a brand new, albeit\n // artificial, function.\n \n@@ -5356,9 +5280,9 @@ For_range_statement::do_lower(Gogo* gogo, Named_object*, Block* enclosing,\n \t\t\t     index_temp, value_temp, &init, &cond, &iter_init,\n \t\t\t     &post);\n   else if (range_type->map_type() != NULL)\n-    this->lower_range_map(gogo, temp_block, body, range_object, range_temp,\n-\t\t\t  index_temp, value_temp, &init, &cond, &iter_init,\n-\t\t\t  &post);\n+    this->lower_range_map(gogo, range_type->map_type(), temp_block, body,\n+\t\t\t  range_object, range_temp, index_temp, value_temp,\n+\t\t\t  &init, &cond, &iter_init, &post);\n   else if (range_type->channel_type() != NULL)\n     this->lower_range_channel(gogo, temp_block, body, range_object, range_temp,\n \t\t\t      index_temp, value_temp, &init, &cond, &iter_init,\n@@ -5753,7 +5677,8 @@ For_range_statement::lower_range_string(Gogo*,\n // Lower a for range over a map.\n \n void\n-For_range_statement::lower_range_map(Gogo*,\n+For_range_statement::lower_range_map(Gogo* gogo,\n+\t\t\t\t     Map_type* map_type,\n \t\t\t\t     Block* enclosing,\n \t\t\t\t     Block* body_block,\n \t\t\t\t     Named_object* range_object,\n@@ -5768,68 +5693,71 @@ For_range_statement::lower_range_map(Gogo*,\n   Location loc = this->location();\n \n   // The runtime uses a struct to handle ranges over a map.  The\n-  // struct is four pointers long.  The first pointer is NULL when we\n-  // have completed the iteration.\n+  // struct is built by Map_type::hiter_type for a specific map type.\n \n   // The loop we generate:\n   //   var hiter map_iteration_struct\n-  //   for mapiterinit(range, &hiter); hiter[0] != nil; mapiternext(&hiter) {\n-  //           mapiter2(hiter, &index_temp, &value_temp)\n+  //   for mapiterinit(type, range, &hiter); hiter.key != nil; mapiternext(&hiter) {\n+  //           index_temp = *hiter.key\n+  //           value_temp = *hiter.val\n   //           index = index_temp\n   //           value = value_temp\n   //           original body\n   //   }\n \n   // Set *PINIT to\n   //   var hiter map_iteration_struct\n-  //   runtime.mapiterinit(range, &hiter)\n+  //   runtime.mapiterinit(type, range, &hiter)\n \n   Block* init = new Block(enclosing, loc);\n \n-  Type* map_iteration_type = Runtime::map_iteration_type();\n+  Type* map_iteration_type = map_type->hiter_type(gogo);\n   Temporary_statement* hiter = Statement::make_temporary(map_iteration_type,\n \t\t\t\t\t\t\t NULL, loc);\n   init->add_statement(hiter);\n \n-  Expression* p1 = this->make_range_ref(range_object, range_temp, loc);\n+  Expression* p1 = Expression::make_type_descriptor(map_type, loc);\n+  Expression* p2 = this->make_range_ref(range_object, range_temp, loc);\n   Expression* ref = Expression::make_temporary_reference(hiter, loc);\n-  Expression* p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  Expression* call = Runtime::make_call(Runtime::MAPITERINIT, loc, 2, p1, p2);\n+  Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n+  Expression* call = Runtime::make_call(Runtime::MAPITERINIT, loc, 3,\n+\t\t\t\t\tp1, p2, p3);\n   init->add_statement(Statement::make_statement(call, true));\n \n   *pinit = init;\n \n   // Set *PCOND to\n-  //   hiter[0] != nil\n+  //   hiter.key != nil\n \n   ref = Expression::make_temporary_reference(hiter, loc);\n-  Expression* zexpr = Expression::make_integer_ul(0, NULL, loc);\n-  Expression* index = Expression::make_index(ref, zexpr, NULL, NULL, loc);\n-  Expression* ne = Expression::make_binary(OPERATOR_NOTEQ, index,\n+  ref = Expression::make_field_reference(ref, 0, loc);\n+  Expression* ne = Expression::make_binary(OPERATOR_NOTEQ, ref,\n \t\t\t\t\t   Expression::make_nil(loc),\n \t\t\t\t\t   loc);\n   *pcond = ne;\n \n   // Set *PITER_INIT to\n-  //   mapiter1(hiter, &index_temp)\n-  // or\n-  //   mapiter2(hiter, &index_temp, &value_temp)\n+  //   index_temp = *hiter.key\n+  //   value_temp = *hiter.val\n \n   Block* iter_init = new Block(body_block, loc);\n \n-  ref = Expression::make_temporary_reference(hiter, loc);\n-  p1 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  ref = Expression::make_temporary_reference(index_temp, loc);\n-  p2 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-  if (value_temp == NULL)\n-    call = Runtime::make_call(Runtime::MAPITER1, loc, 2, p1, p2);\n-  else\n+  Expression* lhs = Expression::make_temporary_reference(index_temp, loc);\n+  Expression* rhs = Expression::make_temporary_reference(hiter, loc);\n+  rhs = Expression::make_field_reference(ref, 0, loc);\n+  rhs = Expression::make_unary(OPERATOR_MULT, ref, loc);\n+  Statement* set = Statement::make_assignment(lhs, rhs, loc);\n+  iter_init->add_statement(set);\n+\n+  if (value_temp != NULL)\n     {\n-      ref = Expression::make_temporary_reference(value_temp, loc);\n-      Expression* p3 = Expression::make_unary(OPERATOR_AND, ref, loc);\n-      call = Runtime::make_call(Runtime::MAPITER2, loc, 3, p1, p2, p3);\n+      lhs = Expression::make_temporary_reference(value_temp, loc);\n+      rhs = Expression::make_temporary_reference(hiter, loc);\n+      rhs = Expression::make_field_reference(rhs, 1, loc);\n+      rhs = Expression::make_unary(OPERATOR_MULT, rhs, loc);\n+      set = Statement::make_assignment(lhs, rhs, loc);\n+      iter_init->add_statement(set);\n     }\n-  iter_init->add_statement(Statement::make_statement(call, true));\n \n   *piter_init = iter_init;\n "}, {"sha": "9ed8d7272ecccc8fbfdcd9e6ef601aec2765dc84", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -120,7 +120,6 @@ class Statement\n     STATEMENT_ASSIGNMENT_OPERATION,\n     STATEMENT_TUPLE_ASSIGNMENT,\n     STATEMENT_TUPLE_MAP_ASSIGNMENT,\n-    STATEMENT_MAP_ASSIGNMENT,\n     STATEMENT_TUPLE_RECEIVE_ASSIGNMENT,\n     STATEMENT_TUPLE_TYPE_GUARD_ASSIGNMENT,\n     STATEMENT_INCDEC,\n@@ -166,11 +165,6 @@ class Statement\n   make_tuple_map_assignment(Expression* val, Expression* present,\n \t\t\t    Expression*, Location);\n \n-  // Make a statement which assigns a pair of values to a map.\n-  static Statement*\n-  make_map_assignment(Expression*, Expression* val,\n-\t\t      Expression* should_set, Location);\n-\n   // Make an assignment from a nonblocking receive to a pair of\n   // variables.\n   static Statement*\n@@ -586,6 +580,9 @@ class Assignment_statement : public Statement\n   bool\n   do_traverse_assignments(Traverse_assignments*);\n \n+  virtual Statement*\n+  do_lower(Gogo*, Named_object*, Block*, Statement_inserter*);\n+\n   void\n   do_determine_types();\n \n@@ -1144,10 +1141,6 @@ class Thunk_statement : public Statement\n   bool\n   simplify_statement(Gogo*, Named_object*, Block*);\n \n-  // Return whether ST is a type created to hold thunk parameters.\n-  static bool\n-  is_thunk_struct(const Struct_type *st);\n-\n  protected:\n   int\n   do_traverse(Traverse* traverse);\n@@ -1186,9 +1179,6 @@ class Thunk_statement : public Statement\n   void\n   thunk_field_param(int n, char* buf, size_t buflen);\n \n-  // A list of all the struct types created for thunk statements.\n-  static Unordered_set(const Struct_type*) thunk_types;\n-\n   // The function call to be executed in a separate thread (go) or\n   // later (defer).\n   Expression* call_;\n@@ -1529,9 +1519,10 @@ class For_range_statement : public Statement\n \t\t     Block**, Expression**, Block**, Block**);\n \n   void\n-  lower_range_map(Gogo*, Block*, Block*, Named_object*, Temporary_statement*,\n+  lower_range_map(Gogo*, Map_type*, Block*, Block*, Named_object*,\n \t\t  Temporary_statement*, Temporary_statement*,\n-\t\t  Block**, Expression**, Block**, Block**);\n+\t\t  Temporary_statement*, Block**, Expression**, Block**,\n+\t\t  Block**);\n \n   void\n   lower_range_channel(Gogo*, Block*, Block*, Named_object*,"}, {"sha": "db5655ba06a0f410ac929973faa5364d655c0900", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 550, "deletions": 141, "changes": 691, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -567,6 +567,12 @@ Type::are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n \treturn t2->named_type()->named_type_is_comparable(reason);\n       else if (t1->struct_type() != NULL)\n \t{\n+\t  if (t1->struct_type()->is_struct_incomparable())\n+\t    {\n+\t      if (reason != NULL)\n+\t\t*reason = _(\"invalid comparison of generated struct\");\n+\t      return false;\n+\t    }\n \t  const Struct_field_list* fields = t1->struct_type()->fields();\n \t  for (Struct_field_list::const_iterator p = fields->begin();\n \t       p != fields->end();\n@@ -582,6 +588,12 @@ Type::are_compatible_for_comparison(bool is_equality_op, const Type *t1,\n \t}\n       else if (t1->array_type() != NULL)\n \t{\n+\t  if (t1->array_type()->is_array_incomparable())\n+\t    {\n+\t      if (reason != NULL)\n+\t\t*reason = _(\"invalid comparison of generated array\");\n+\t      return false;\n+\t    }\n \t  if (t1->array_type()->length()->is_nil_expression()\n \t      || !t1->array_type()->element_type()->is_comparable())\n \t    {\n@@ -1478,6 +1490,7 @@ Type::make_type_descriptor_type()\n \n       Typed_identifier_list *params = new Typed_identifier_list();\n       params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n+      params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n       params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n       Typed_identifier_list* results = new Typed_identifier_list();\n@@ -1579,6 +1592,13 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t\t     Function_type* equal_fntype, Named_object** hash_fn,\n \t\t     Named_object** equal_fn)\n {\n+  if (!this->is_comparable())\n+    {\n+      *hash_fn = NULL;\n+      *equal_fn = NULL;\n+      return;\n+    }\n+\n   if (hash_fntype == NULL || equal_fntype == NULL)\n     {\n       Location bloc = Linemap::predeclared_location();\n@@ -1592,6 +1612,7 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t  Typed_identifier_list* params = new Typed_identifier_list();\n \t  params->push_back(Typed_identifier(\"key\", unsafe_pointer_type,\n \t\t\t\t\t     bloc));\n+\t  params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n \t  params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n \t  Typed_identifier_list* results = new Typed_identifier_list();\n@@ -1623,13 +1644,6 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n       hash_fnname = \"__go_type_hash_identity\";\n       equal_fnname = \"__go_type_equal_identity\";\n     }\n-  else if (!this->is_comparable() ||\n-\t   (this->struct_type() != NULL\n-\t    && Thunk_statement::is_thunk_struct(this->struct_type())))\n-    {\n-      hash_fnname = \"__go_type_hash_error\";\n-      equal_fnname = \"__go_type_equal_error\";\n-    }\n   else\n     {\n       switch (this->base()->classification())\n@@ -1844,6 +1858,8 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n       return;\n     }\n \n+  go_assert(this->is_comparable());\n+\n   Named_object* hash_fn = gogo->start_function(hash_name, hash_fntype, false,\n \t\t\t\t\t       bloc);\n   hash_fn->func_value()->set_is_type_specific_function();\n@@ -1909,6 +1925,10 @@ Type::write_named_hash(Gogo* gogo, Named_type* name,\n   Named_object* key_arg = gogo->lookup(\"key\", NULL);\n   go_assert(key_arg != NULL);\n \n+  // The seed argument to the hash function.\n+  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n+  go_assert(seed_arg != NULL);\n+\n   // The size of the type we are going to hash.\n   Named_object* keysz_arg = gogo->lookup(\"key_size\", NULL);\n   go_assert(keysz_arg != NULL);\n@@ -1920,9 +1940,11 @@ Type::write_named_hash(Gogo* gogo, Named_type* name,\n \n   // Call the hash function for the base type.\n   Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n+  Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n   Expression* keysz_ref = Expression::make_var_reference(keysz_arg, bloc);\n   Expression_list* args = new Expression_list();\n   args->push_back(key_ref);\n+  args->push_back(seed_ref);\n   args->push_back(keysz_ref);\n   Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n   Expression* call = Expression::make_call(func, args, false, bloc);\n@@ -2044,8 +2066,18 @@ Type::type_descriptor_constructor(Gogo* gogo, int runtime_type_kind,\n   Named_object* equal_fn;\n   this->type_functions(gogo, name, hash_fntype, equal_fntype, &hash_fn,\n \t\t       &equal_fn);\n-  vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n-  vals->push_back(Expression::make_func_reference(equal_fn, NULL, bloc));\n+  if (hash_fn == NULL)\n+    vals->push_back(Expression::make_cast(hash_fntype,\n+\t\t\t\t\t  Expression::make_nil(bloc),\n+\t\t\t\t\t  bloc));\n+  else\n+    vals->push_back(Expression::make_func_reference(hash_fn, NULL, bloc));\n+  if (equal_fn == NULL)\n+    vals->push_back(Expression::make_cast(equal_fntype,\n+\t\t\t\t\t  Expression::make_nil(bloc),\n+\t\t\t\t\t  bloc));\n+  else\n+    vals->push_back(Expression::make_func_reference(equal_fn, NULL, bloc));\n \n   ++p;\n   go_assert(p->is_field_name(\"gc\"));\n@@ -4842,6 +4874,44 @@ Struct_type::do_compare_is_identity(Gogo* gogo)\n   return true;\n }\n \n+// Return whether this struct type is reflexive--whether a value of\n+// this type is always equal to itself.\n+\n+bool\n+Struct_type::do_is_reflexive()\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL)\n+    return true;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      if (!pf->type()->is_reflexive())\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n+// Return whether this struct type needs a key update when used as a\n+// map key.\n+\n+bool\n+Struct_type::do_needs_key_update()\n+{\n+  const Struct_field_list* fields = this->fields_;\n+  if (fields == NULL)\n+    return false;\n+  for (Struct_field_list::const_iterator pf = fields->begin();\n+       pf != fields->end();\n+       ++pf)\n+    {\n+      if (pf->type()->needs_key_update())\n+\treturn true;\n+    }\n+  return false;\n+}\n+\n // Build identity and hash functions for this struct.\n \n // Hash code.\n@@ -5310,18 +5380,20 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n   go_assert(key_arg != NULL);\n   Type* key_arg_type = key_arg->var_value()->type();\n \n-  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  // The seed argument to the hash function.\n+  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n+  go_assert(seed_arg != NULL);\n \n-  // Get a 0.\n-  Expression* zero = Expression::make_integer_ul(0, uintptr_type, bloc);\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n \n-  // Make a temporary to hold the return value, initialized to 0.\n-  Temporary_statement* retval = Statement::make_temporary(uintptr_type, zero,\n+  // Make a temporary to hold the return value, initialized to the seed.\n+  Expression* ref = Expression::make_var_reference(seed_arg, bloc);\n+  Temporary_statement* retval = Statement::make_temporary(uintptr_type, ref,\n \t\t\t\t\t\t\t  bloc);\n   gogo->add_statement(retval);\n \n   // Make a temporary to hold the key as a uintptr.\n-  Expression* ref = Expression::make_var_reference(key_arg, bloc);\n+  ref = Expression::make_var_reference(key_arg, bloc);\n   ref = Expression::make_cast(uintptr_type, ref, bloc);\n   Temporary_statement* key = Statement::make_temporary(uintptr_type, ref,\n \t\t\t\t\t\t       bloc);\n@@ -5367,19 +5439,20 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n       pf->type()->type_functions(gogo, pf->type()->named_type(), hash_fntype,\n \t\t\t\t equal_fntype, &hash_fn, &equal_fn);\n \n-      // Call the hash function for the field.\n+      // Call the hash function for the field, passing retval as the seed.\n+      ref = Expression::make_temporary_reference(retval, bloc);\n       Expression_list* args = new Expression_list();\n       args->push_back(subkey);\n+      args->push_back(ref);\n       args->push_back(size);\n       Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n       Expression* call = Expression::make_call(func, args, false, bloc);\n \n-      // Add the field's hash value to retval.\n+      // Set retval to the result.\n       Temporary_reference_expression* tref =\n \tExpression::make_temporary_reference(retval, bloc);\n       tref->set_is_lvalue();\n-      Statement* s = Statement::make_assignment_operation(OPERATOR_PLUSEQ,\n-\t\t\t\t\t\t\t  tref, call, bloc);\n+      Statement* s = Statement::make_assignment(tref, call, bloc);\n       gogo->add_statement(s);\n     }\n \n@@ -5733,6 +5806,11 @@ Struct_type::can_write_type_to_c_header(\n       return true;\n \n     case TYPE_POINTER:\n+      // Don't try to handle a pointer to an array.\n+      if (t->points_to()->array_type() != NULL\n+\t  && !t->points_to()->is_slice_type())\n+\treturn false;\n+\n       if (t->points_to()->named_type() != NULL\n \t  && t->points_to()->struct_type() != NULL)\n \tdeclare->push_back(t->points_to()->named_type()->named_object());\n@@ -6157,18 +6235,20 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n   go_assert(key_arg != NULL);\n   Type* key_arg_type = key_arg->var_value()->type();\n \n-  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  // The seed argument to the hash function.\n+  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n+  go_assert(seed_arg != NULL);\n \n-  // Get a 0.\n-  Expression* zero = Expression::make_integer_ul(0, uintptr_type, bloc);\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n \n-  // Make a temporary to hold the return value, initialized to 0.\n-  Temporary_statement* retval = Statement::make_temporary(uintptr_type, zero,\n+  // Make a temporary to hold the return value, initialized to the seed.\n+  Expression* ref = Expression::make_var_reference(seed_arg, bloc);\n+  Temporary_statement* retval = Statement::make_temporary(uintptr_type, ref,\n \t\t\t\t\t\t\t  bloc);\n   gogo->add_statement(retval);\n \n   // Make a temporary to hold the key as a uintptr.\n-  Expression* ref = Expression::make_var_reference(key_arg, bloc);\n+  ref = Expression::make_var_reference(key_arg, bloc);\n   ref = Expression::make_cast(uintptr_type, ref, bloc);\n   Temporary_statement* key = Statement::make_temporary(uintptr_type, ref,\n \t\t\t\t\t\t       bloc);\n@@ -6216,18 +6296,20 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n   Expression* ele_size = Expression::make_type_info(this->element_type_,\n \t\t\t\t\t\t    Expression::TYPE_INFO_SIZE);\n \n-  // Get the hash of this element.\n+  // Get the hash of this element, passing retval as the seed.\n+  ref = Expression::make_temporary_reference(retval, bloc);\n   Expression_list* args = new Expression_list();\n   args->push_back(subkey);\n+  args->push_back(ref);\n   args->push_back(ele_size);\n   Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n   Expression* call = Expression::make_call(func, args, false, bloc);\n \n-  // Add the element's hash value to retval.\n+  // Set retval to the result.\n   Temporary_reference_expression* tref =\n     Expression::make_temporary_reference(retval, bloc);\n   tref->set_is_lvalue();\n-  s = Statement::make_assignment_operation(OPERATOR_PLUSEQ, tref, call, bloc);\n+  s = Statement::make_assignment(tref, call, bloc);\n   gogo->add_statement(s);\n \n   // Increase the element pointer.\n@@ -6846,6 +6928,100 @@ Type::make_array_type(Type* element_type, Expression* length)\n \n // Class Map_type.\n \n+Named_object* Map_type::zero_value;\n+int64_t Map_type::zero_value_size;\n+int64_t Map_type::zero_value_align;\n+\n+// If this map requires the \"fat\" functions, return the pointer to\n+// pass as the zero value to those functions.  Otherwise, in the\n+// normal case, return NULL.  The map requires the \"fat\" functions if\n+// the value size is larger than max_zero_size bytes.  max_zero_size\n+// must match maxZero in libgo/go/runtime/hashmap.go.\n+\n+Expression*\n+Map_type::fat_zero_value(Gogo* gogo)\n+{\n+  int64_t valsize;\n+  if (!this->val_type_->backend_type_size(gogo, &valsize))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n+  if (valsize <= Map_type::max_zero_size)\n+    return NULL;\n+\n+  if (Map_type::zero_value_size < valsize)\n+    Map_type::zero_value_size = valsize;\n+\n+  int64_t valalign;\n+  if (!this->val_type_->backend_type_align(gogo, &valalign))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n+\n+  if (Map_type::zero_value_align < valalign)\n+    Map_type::zero_value_align = valalign;\n+\n+  Location bloc = Linemap::predeclared_location();\n+\n+  if (Map_type::zero_value == NULL)\n+    {\n+      // The final type will be set in backend_zero_value.\n+      Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+      Expression* size = Expression::make_integer_ul(0, NULL, bloc);\n+      Type* array_type = Type::make_array_type(uint8_type, size);\n+      Variable* var = new Variable(array_type, NULL, true, false, false, bloc);\n+      Map_type::zero_value = Named_object::make_variable(\"go$zerovalue\", NULL,\n+\t\t\t\t\t\t\t var);\n+    }\n+\n+  Expression* z = Expression::make_var_reference(Map_type::zero_value, bloc);\n+  z = Expression::make_unary(OPERATOR_AND, z, bloc);\n+  Type* unsafe_ptr_type = Type::make_pointer_type(Type::make_void_type());\n+  z = Expression::make_cast(unsafe_ptr_type, z, bloc);\n+  return z;\n+}\n+\n+// Return whether VAR is the map zero value.\n+\n+bool\n+Map_type::is_zero_value(Variable* var)\n+{\n+  return (Map_type::zero_value != NULL\n+\t  && Map_type::zero_value->var_value() == var);\n+}\n+\n+// Return the backend representation for the zero value.\n+\n+Bvariable*\n+Map_type::backend_zero_value(Gogo* gogo)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  go_assert(Map_type::zero_value != NULL);\n+\n+  Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Btype* buint8_type = uint8_type->get_backend(gogo);\n+\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+\n+  Expression* e = Expression::make_integer_int64(Map_type::zero_value_size,\n+\t\t\t\t\t\t int_type, bloc);\n+  Translate_context context(gogo, NULL, NULL, NULL);\n+  Bexpression* blength = e->get_backend(&context);\n+\n+  Btype* barray_type = gogo->backend()->array_type(buint8_type, blength);\n+\n+  std::string zname = Map_type::zero_value->name();\n+  Bvariable* zvar =\n+    gogo->backend()->implicit_variable(zname, barray_type, false, true, true,\n+\t\t\t\t       Map_type::zero_value_align);\n+  gogo->backend()->implicit_variable_set_init(zvar, zname, barray_type,\n+\t\t\t\t\t      false, true, true, NULL);\n+  return zvar;\n+}\n+\n // Traversal.\n \n int\n@@ -6890,42 +7066,59 @@ Map_type::do_hash_for_method(Gogo* gogo) const\n }\n \n // Get the backend representation for a map type.  A map type is\n-// represented as a pointer to a struct.  The struct is __go_map in\n-// libgo/map.h.\n+// represented as a pointer to a struct.  The struct is hmap in\n+// runtime/hashmap.go.\n \n Btype*\n Map_type::do_get_backend(Gogo* gogo)\n {\n   static Btype* backend_map_type;\n   if (backend_map_type == NULL)\n     {\n-      std::vector<Backend::Btyped_identifier> bfields(4);\n+      std::vector<Backend::Btyped_identifier> bfields(8);\n \n       Location bloc = Linemap::predeclared_location();\n \n-      Type* pdt = Type::make_type_descriptor_ptr_type();\n-      bfields[0].name = \"__descriptor\";\n-      bfields[0].btype = pdt->get_backend(gogo);\n+      Type* int_type = Type::lookup_integer_type(\"int\");\n+      bfields[0].name = \"count\";\n+      bfields[0].btype = int_type->get_backend(gogo);\n       bfields[0].location = bloc;\n \n-      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-      bfields[1].name = \"__element_count\";\n-      bfields[1].btype = uintptr_type->get_backend(gogo);\n+      Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+      bfields[1].name = \"flags\";\n+      bfields[1].btype = uint8_type->get_backend(gogo);\n       bfields[1].location = bloc;\n \n-      bfields[2].name = \"__bucket_count\";\n+      bfields[2].name = \"B\";\n       bfields[2].btype = bfields[1].btype;\n       bfields[2].location = bloc;\n \n+      Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+      bfields[3].name = \"hash0\";\n+      bfields[3].btype = uint32_type->get_backend(gogo);\n+      bfields[3].location = bloc;\n+\n       Btype* bvt = gogo->backend()->void_type();\n       Btype* bpvt = gogo->backend()->pointer_type(bvt);\n-      Btype* bppvt = gogo->backend()->pointer_type(bpvt);\n-      bfields[3].name = \"__buckets\";\n-      bfields[3].btype = bppvt;\n-      bfields[3].location = bloc;\n+      bfields[4].name = \"buckets\";\n+      bfields[4].btype = bpvt;\n+      bfields[4].location = bloc;\n+\n+      bfields[5].name = \"oldbuckets\";\n+      bfields[5].btype = bpvt;\n+      bfields[5].location = bloc;\n+\n+      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+      bfields[6].name = \"nevacuate\";\n+      bfields[6].btype = uintptr_type->get_backend(gogo);\n+      bfields[6].location = bloc;\n+\n+      bfields[7].name = \"overflow\";\n+      bfields[7].btype = bpvt;\n+      bfields[7].location = bloc;\n \n       Btype *bt = gogo->backend()->struct_type(bfields);\n-      bt = gogo->backend()->named_type(\"__go_map\", bt, bloc);\n+      bt = gogo->backend()->named_type(\"runtime.hmap\", bt, bloc);\n       backend_map_type = gogo->backend()->pointer_type(bt);\n     }\n   return backend_map_type;\n@@ -6941,12 +7134,24 @@ Map_type::make_map_type_descriptor_type()\n     {\n       Type* tdt = Type::make_type_descriptor_type();\n       Type* ptdt = Type::make_type_descriptor_ptr_type();\n+      Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+      Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+      Type* bool_type = Type::lookup_bool_type();\n \n       Struct_type* sf =\n-\tType::make_builtin_struct_type(3,\n+\tType::make_builtin_struct_type(12,\n \t\t\t\t       \"\", tdt,\n \t\t\t\t       \"key\", ptdt,\n-\t\t\t\t       \"elem\", ptdt);\n+\t\t\t\t       \"elem\", ptdt,\n+\t\t\t\t       \"bucket\", ptdt,\n+\t\t\t\t       \"hmap\", ptdt,\n+\t\t\t\t       \"keysize\", uint8_type,\n+\t\t\t\t       \"indirectkey\", bool_type,\n+\t\t\t\t       \"valuesize\", uint8_type,\n+\t\t\t\t       \"indirectvalue\", bool_type,\n+\t\t\t\t       \"bucketsize\", uint16_type,\n+\t\t\t\t       \"reflexivekey\", bool_type,\n+\t\t\t\t       \"needkeyupdate\", bool_type);\n \n       ret = Type::make_builtin_named_type(\"MapType\", sf);\n     }\n@@ -6962,11 +7167,48 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   Location bloc = Linemap::predeclared_location();\n \n   Type* mtdt = Map_type::make_map_type_descriptor_type();\n+  Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Type* uint16_type = Type::lookup_integer_type(\"uint16\");\n+\n+  int64_t keysize;\n+  if (!this->key_type_->backend_type_size(gogo, &keysize))\n+    {\n+      error_at(this->location_, \"error determining map key type size\");\n+      return Expression::make_error(this->location_);\n+    }\n+\n+  int64_t valsize;\n+  if (!this->val_type_->backend_type_size(gogo, &valsize))\n+    {\n+      error_at(this->location_, \"error determining map value type size\");\n+      return Expression::make_error(this->location_);\n+    }\n+\n+  int64_t ptrsize;\n+  if (!Type::make_pointer_type(uint8_type)->backend_type_size(gogo, &ptrsize))\n+    {\n+      go_assert(saw_errors());\n+      return Expression::make_error(this->location_);\n+    }\n+\n+  Type* bucket_type = this->bucket_type(gogo, keysize, valsize);\n+  if (bucket_type == NULL)\n+    {\n+      go_assert(saw_errors());\n+      return Expression::make_error(this->location_);\n+    }\n+\n+  int64_t bucketsize;\n+  if (!bucket_type->backend_type_size(gogo, &bucketsize))\n+    {\n+      go_assert(saw_errors());\n+      return Expression::make_error(this->location_);\n+    }\n \n   const Struct_field_list* fields = mtdt->struct_type()->fields();\n \n   Expression_list* vals = new Expression_list();\n-  vals->reserve(3);\n+  vals->reserve(12);\n \n   Struct_field_list::const_iterator p = fields->begin();\n   go_assert(p->is_field_name(\"commonType\"));\n@@ -6983,130 +7225,270 @@ Map_type::do_type_descriptor(Gogo* gogo, Named_type* name)\n   vals->push_back(Expression::make_type_descriptor(this->val_type_, bloc));\n \n   ++p;\n-  go_assert(p == fields->end());\n-\n-  return Expression::make_struct_composite_literal(mtdt, vals, bloc);\n-}\n-\n-// A mapping from map types to map descriptors.\n-\n-Map_type::Map_descriptors Map_type::map_descriptors;\n-\n-// Build a map descriptor for this type.  Return a pointer to it.\n+  go_assert(p->is_field_name(\"bucket\"));\n+  vals->push_back(Expression::make_type_descriptor(bucket_type, bloc));\n \n-Bexpression*\n-Map_type::map_descriptor_pointer(Gogo* gogo, Location location)\n-{\n-  Bvariable* bvar = this->map_descriptor(gogo);\n-  Bexpression* var_expr = gogo->backend()->var_expression(bvar, location);\n-  return gogo->backend()->address_expression(var_expr, location);\n-}\n+  ++p;\n+  go_assert(p->is_field_name(\"hmap\"));\n+  Type* hmap_type = this->hmap_type(bucket_type);\n+  vals->push_back(Expression::make_type_descriptor(hmap_type, bloc));\n \n-// Build a map descriptor for this type.\n+  ++p;\n+  go_assert(p->is_field_name(\"keysize\"));\n+  if (keysize > Map_type::max_key_size)\n+    vals->push_back(Expression::make_integer_int64(ptrsize, uint8_type, bloc));\n+  else\n+    vals->push_back(Expression::make_integer_int64(keysize, uint8_type, bloc));\n \n-Bvariable*\n-Map_type::map_descriptor(Gogo* gogo)\n-{\n-  std::pair<Map_type*, Bvariable*> val(this, NULL);\n-  std::pair<Map_type::Map_descriptors::iterator, bool> ins =\n-    Map_type::map_descriptors.insert(val);\n-  if (!ins.second)\n-    return ins.first->second;\n+  ++p;\n+  go_assert(p->is_field_name(\"indirectkey\"));\n+  vals->push_back(Expression::make_boolean(keysize > Map_type::max_key_size,\n+\t\t\t\t\t   bloc));\n \n-  Type* key_type = this->key_type_;\n-  Type* val_type = this->val_type_;\n+  ++p;\n+  go_assert(p->is_field_name(\"valuesize\"));\n+  if (valsize > Map_type::max_val_size)\n+    vals->push_back(Expression::make_integer_int64(ptrsize, uint8_type, bloc));\n+  else\n+    vals->push_back(Expression::make_integer_int64(valsize, uint8_type, bloc));\n \n-  // The map entry type is a struct with three fields.  Build that\n-  // struct so that we can get the offsets of the key and value within\n-  // a map entry.  The first field should technically be a pointer to\n-  // this type itself, but since we only care about field offsets we\n-  // just use pointer to bool.\n-  Type* pbool = Type::make_pointer_type(Type::make_boolean_type());\n-  Struct_type* map_entry_type =\n-    Type::make_builtin_struct_type(3,\n-\t\t\t\t   \"__next\", pbool,\n-\t\t\t\t   \"__key\", key_type,\n-\t\t\t\t   \"__val\", val_type);\n+  ++p;\n+  go_assert(p->is_field_name(\"indirectvalue\"));\n+  vals->push_back(Expression::make_boolean(valsize > Map_type::max_val_size,\n+\t\t\t\t\t   bloc));\n \n-  Type* map_descriptor_type = Map_type::make_map_descriptor_type();\n+  ++p;\n+  go_assert(p->is_field_name(\"bucketsize\"));\n+  vals->push_back(Expression::make_integer_int64(bucketsize, uint16_type,\n+\t\t\t\t\t\t bloc));\n \n-  const Struct_field_list* fields =\n-    map_descriptor_type->struct_type()->fields();\n+  ++p;\n+  go_assert(p->is_field_name(\"reflexivekey\"));\n+  vals->push_back(Expression::make_boolean(this->key_type_->is_reflexive(),\n+\t\t\t\t\t   bloc));\n \n-  Expression_list* vals = new Expression_list();\n-  vals->reserve(4);\n+  ++p;\n+  go_assert(p->is_field_name(\"needkeyupdate\"));\n+  vals->push_back(Expression::make_boolean(this->key_type_->needs_key_update(),\n+\t\t\t\t\t   bloc));\n \n-  Location bloc = Linemap::predeclared_location();\n+  ++p;\n+  go_assert(p == fields->end());\n \n-  Struct_field_list::const_iterator p = fields->begin();\n+  return Expression::make_struct_composite_literal(mtdt, vals, bloc);\n+}\n \n-  go_assert(p->is_field_name(\"__map_descriptor\"));\n-  vals->push_back(Expression::make_type_descriptor(this, bloc));\n+// Return the bucket type to use for a map type.  This must correspond\n+// to libgo/go/runtime/hashmap.go.\n \n-  ++p;\n-  go_assert(p->is_field_name(\"__entry_size\"));\n-  Expression::Type_info type_info = Expression::TYPE_INFO_SIZE;\n-  vals->push_back(Expression::make_type_info(map_entry_type, type_info));\n+Type*\n+Map_type::bucket_type(Gogo* gogo, int64_t keysize, int64_t valsize)\n+{\n+  if (this->bucket_type_ != NULL)\n+    return this->bucket_type_;\n \n-  Struct_field_list::const_iterator pf = map_entry_type->fields()->begin();\n-  ++pf;\n-  go_assert(pf->is_field_name(\"__key\"));\n+  Type* key_type = this->key_type_;\n+  if (keysize > Map_type::max_key_size)\n+    key_type = Type::make_pointer_type(key_type);\n \n-  ++p;\n-  go_assert(p->is_field_name(\"__key_offset\"));\n-  vals->push_back(Expression::make_struct_field_offset(map_entry_type, &*pf));\n+  Type* val_type = this->val_type_;\n+  if (valsize > Map_type::max_val_size)\n+    val_type = Type::make_pointer_type(val_type);\n+\n+  Expression* bucket_size = Expression::make_integer_ul(Map_type::bucket_size,\n+\t\t\t\t\t\t\tNULL, this->location_);\n+\n+  Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Array_type* topbits_type = Type::make_array_type(uint8_type, bucket_size);\n+  topbits_type->set_is_array_incomparable();\n+  Array_type* keys_type = Type::make_array_type(key_type, bucket_size);\n+  keys_type->set_is_array_incomparable();\n+  Array_type* values_type = Type::make_array_type(val_type, bucket_size);\n+  values_type->set_is_array_incomparable();\n+\n+  // If keys and values have no pointers, the map implementation can\n+  // keep a list of overflow pointers on the side so that buckets can\n+  // be marked as having no pointers.  Arrange for the bucket to have\n+  // no pointers by changing the type of the overflow field to uintptr\n+  // in this case.  See comment on the hmap.overflow field in\n+  // libgo/go/runtime/hashmap.go.\n+  Type* overflow_type;\n+  if (!key_type->has_pointer() && !val_type->has_pointer())\n+    overflow_type = Type::lookup_integer_type(\"uintptr\");\n+  else\n+    {\n+      // This should really be a pointer to the bucket type itself,\n+      // but that would require us to construct a Named_type for it to\n+      // give it a way to refer to itself.  Since nothing really cares\n+      // (except perhaps for someone using a debugger) just use an\n+      // unsafe pointer.\n+      overflow_type = Type::make_pointer_type(Type::make_void_type());\n+    }\n+\n+  // Make sure the overflow pointer is the last memory in the struct,\n+  // because the runtime assumes it can use size-ptrSize as the offset\n+  // of the overflow pointer.  We double-check that property below\n+  // once the offsets and size are computed.\n+\n+  int64_t topbits_field_size, topbits_field_align;\n+  int64_t keys_field_size, keys_field_align;\n+  int64_t values_field_size, values_field_align;\n+  int64_t overflow_field_size, overflow_field_align;\n+  if (!topbits_type->backend_type_size(gogo, &topbits_field_size)\n+      || !topbits_type->backend_type_field_align(gogo, &topbits_field_align)\n+      || !keys_type->backend_type_size(gogo, &keys_field_size)\n+      || !keys_type->backend_type_field_align(gogo, &keys_field_align)\n+      || !values_type->backend_type_size(gogo, &values_field_size)\n+      || !values_type->backend_type_field_align(gogo, &values_field_align)\n+      || !overflow_type->backend_type_size(gogo, &overflow_field_size)\n+      || !overflow_type->backend_type_field_align(gogo, &overflow_field_align))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n \n-  ++pf;\n-  go_assert(pf->is_field_name(\"__val\"));\n+  Struct_type* ret;\n+  int64_t max_align = std::max(std::max(topbits_field_align, keys_field_align),\n+\t\t\t       values_field_align);\n+  if (max_align <= overflow_field_align)\n+    ret =  make_builtin_struct_type(4,\n+\t\t\t\t    \"topbits\", topbits_type,\n+\t\t\t\t    \"keys\", keys_type,\n+\t\t\t\t    \"values\", values_type,\n+\t\t\t\t    \"overflow\", overflow_type);\n+  else\n+    {\n+      size_t off = topbits_field_size;\n+      off = ((off + keys_field_align - 1)\n+\t     &~ static_cast<size_t>(keys_field_align - 1));\n+      off += keys_field_size;\n+      off = ((off + values_field_align - 1)\n+\t     &~ static_cast<size_t>(values_field_align - 1));\n+      off += values_field_size;\n+\n+      int64_t padded_overflow_field_size =\n+\t((overflow_field_size + max_align - 1)\n+\t &~ static_cast<size_t>(max_align - 1));\n+\n+      size_t ovoff = off;\n+      ovoff = ((ovoff + max_align - 1)\n+\t       &~ static_cast<size_t>(max_align - 1));\n+      size_t pad = (ovoff - off\n+\t\t    + padded_overflow_field_size - overflow_field_size);\n+\n+      Expression* pad_expr = Expression::make_integer_ul(pad, NULL,\n+\t\t\t\t\t\t\t this->location_);\n+      Type* pad_type = Type::make_array_type(uint8_type, pad_expr);\n+\n+      ret = make_builtin_struct_type(5,\n+\t\t\t\t     \"topbits\", topbits_type,\n+\t\t\t\t     \"keys\", keys_type,\n+\t\t\t\t     \"values\", values_type,\n+\t\t\t\t     \"pad\", pad_type,\n+\t\t\t\t     \"overflow\", overflow_type);\n+    }\n+\n+  // Verify that the overflow field is just before the end of the\n+  // bucket type.\n+\n+  Btype* btype = ret->get_backend(gogo);\n+  int64_t offset = gogo->backend()->type_field_offset(btype,\n+\t\t\t\t\t\t      ret->field_count() - 1);\n+  int64_t size;\n+  if (!ret->backend_type_size(gogo, &size))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n \n-  ++p;\n-  go_assert(p->is_field_name(\"__val_offset\"));\n-  vals->push_back(Expression::make_struct_field_offset(map_entry_type, &*pf));\n+  int64_t ptr_size;\n+  if (!Type::make_pointer_type(uint8_type)->backend_type_size(gogo, &ptr_size))\n+    {\n+      go_assert(saw_errors());\n+      return NULL;\n+    }\n \n-  ++p;\n-  go_assert(p == fields->end());\n+  go_assert(offset + ptr_size == size);\n \n-  Expression* initializer =\n-    Expression::make_struct_composite_literal(map_descriptor_type, vals, bloc);\n+  ret->set_is_struct_incomparable();\n \n-  std::string mangled_name = \"__go_map_\" + this->mangled_name(gogo);\n-  Btype* map_descriptor_btype = map_descriptor_type->get_backend(gogo);\n-  Bvariable* bvar = gogo->backend()->immutable_struct(mangled_name, false,\n-\t\t\t\t\t\t      true,\n-\t\t\t\t\t\t      map_descriptor_btype,\n-\t\t\t\t\t\t      bloc);\n+  this->bucket_type_ = ret;\n+  return ret;\n+}\n \n-  Translate_context context(gogo, NULL, NULL, NULL);\n-  context.set_is_const();\n-  Bexpression* binitializer = initializer->get_backend(&context);\n+// Return the hashmap type for a map type.\n \n-  gogo->backend()->immutable_struct_set_init(bvar, mangled_name, false, true,\n-\t\t\t\t\t     map_descriptor_btype, bloc,\n-\t\t\t\t\t     binitializer);\n+Type*\n+Map_type::hmap_type(Type* bucket_type)\n+{\n+  if (this->hmap_type_ != NULL)\n+    return this->hmap_type_;\n \n-  ins.first->second = bvar;\n-  return bvar;\n+  Type* int_type = Type::lookup_integer_type(\"int\");\n+  Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Type* uint32_type = Type::lookup_integer_type(\"uint32\");\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  Type* void_ptr_type = Type::make_pointer_type(Type::make_void_type());\n+\n+  Type* ptr_bucket_type = Type::make_pointer_type(bucket_type);\n+\n+  Struct_type* ret = make_builtin_struct_type(8,\n+\t\t\t\t\t      \"count\", int_type,\n+\t\t\t\t\t      \"flags\", uint8_type,\n+\t\t\t\t\t      \"B\", uint8_type,\n+\t\t\t\t\t      \"hash0\", uint32_type,\n+\t\t\t\t\t      \"buckets\", ptr_bucket_type,\n+\t\t\t\t\t      \"oldbuckets\", ptr_bucket_type,\n+\t\t\t\t\t      \"nevacuate\", uintptr_type,\n+\t\t\t\t\t      \"overflow\", void_ptr_type);\n+  ret->set_is_struct_incomparable();\n+  this->hmap_type_ = ret;\n+  return ret;\n }\n \n-// Build the type of a map descriptor.  This must match the struct\n-// __go_map_descriptor in libgo/runtime/map.h.\n+// Return the iterator type for a map type.  This is the type of the\n+// value used when doing a range over a map.\n \n Type*\n-Map_type::make_map_descriptor_type()\n+Map_type::hiter_type(Gogo* gogo)\n {\n-  static Type* ret;\n-  if (ret == NULL)\n+  if (this->hiter_type_ != NULL)\n+    return this->hiter_type_;\n+\n+  int64_t keysize, valsize;\n+  if (!this->key_type_->backend_type_size(gogo, &keysize)\n+      || !this->val_type_->backend_type_size(gogo, &valsize))\n     {\n-      Type* ptdt = Type::make_type_descriptor_ptr_type();\n-      Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n-      Struct_type* sf =\n-\tType::make_builtin_struct_type(4,\n-\t\t\t\t       \"__map_descriptor\", ptdt,\n-\t\t\t\t       \"__entry_size\", uintptr_type,\n-\t\t\t\t       \"__key_offset\", uintptr_type,\n-\t\t\t\t       \"__val_offset\", uintptr_type);\n-      ret = Type::make_builtin_named_type(\"__go_map_descriptor\", sf);\n+      go_assert(saw_errors());\n+      return NULL;\n     }\n+\n+  Type* key_ptr_type = Type::make_pointer_type(this->key_type_);\n+  Type* val_ptr_type = Type::make_pointer_type(this->val_type_);\n+  Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n+  Type* uint8_ptr_type = Type::make_pointer_type(uint8_type);\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+  Type* bucket_type = this->bucket_type(gogo, keysize, valsize);\n+  Type* bucket_ptr_type = Type::make_pointer_type(bucket_type);\n+  Type* hmap_type = this->hmap_type(bucket_type);\n+  Type* hmap_ptr_type = Type::make_pointer_type(hmap_type);\n+  Type* void_ptr_type = Type::make_pointer_type(Type::make_void_type());\n+\n+  Struct_type* ret = make_builtin_struct_type(12,\n+\t\t\t\t\t      \"key\", key_ptr_type,\n+\t\t\t\t\t      \"val\", val_ptr_type,\n+\t\t\t\t\t      \"t\", uint8_ptr_type,\n+\t\t\t\t\t      \"h\", hmap_ptr_type,\n+\t\t\t\t\t      \"buckets\", bucket_ptr_type,\n+\t\t\t\t\t      \"bptr\", bucket_ptr_type,\n+\t\t\t\t\t      \"overflow0\", void_ptr_type,\n+\t\t\t\t\t      \"overflow1\", void_ptr_type,\n+\t\t\t\t\t      \"startBucket\", uintptr_type,\n+\t\t\t\t\t      \"stuff\", uintptr_type,\n+\t\t\t\t\t      \"bucket\", uintptr_type,\n+\t\t\t\t\t      \"checkBucket\", uintptr_type);\n+  ret->set_is_struct_incomparable();\n+  this->hiter_type_ = ret;\n   return ret;\n }\n \n@@ -9016,6 +9398,33 @@ Named_type::do_compare_is_identity(Gogo* gogo)\n   return ret;\n }\n \n+// Return whether this type is reflexive--whether it is always equal\n+// to itself.\n+\n+bool\n+Named_type::do_is_reflexive()\n+{\n+  if (this->seen_in_compare_is_identity_)\n+    return false;\n+  this->seen_in_compare_is_identity_ = true;\n+  bool ret = this->type_->is_reflexive();\n+  this->seen_in_compare_is_identity_ = false;\n+  return ret;\n+}\n+\n+// Return whether this type needs a key update when used as a map key.\n+\n+bool\n+Named_type::do_needs_key_update()\n+{\n+  if (this->seen_in_compare_is_identity_)\n+    return true;\n+  this->seen_in_compare_is_identity_ = true;\n+  bool ret = this->type_->needs_key_update();\n+  this->seen_in_compare_is_identity_ = false;\n+  return ret;\n+}\n+\n // Return a hash code.  This is used for method lookup.  We simply\n // hash on the name itself.\n "}, {"sha": "3d9a3c47fae1500595876ce4d77b3fb9d25d99e7", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 169, "deletions": 18, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -14,6 +14,7 @@\n \n class Gogo;\n class Package;\n+class Variable;\n class Traverse;\n class Typed_identifier;\n class Typed_identifier_list;\n@@ -629,6 +630,18 @@ class Type\n   compare_is_identity(Gogo* gogo)\n   { return this->do_compare_is_identity(gogo); }\n \n+  // Return whether values of this type are reflexive: if a comparison\n+  // of a value with itself always returns true.\n+  bool\n+  is_reflexive()\n+  { return this->do_is_reflexive(); }\n+\n+  // Return whether values of this, when used as a key in map,\n+  // requires the key to be updated when an assignment is made.\n+  bool\n+  needs_key_update()\n+  { return this->do_needs_key_update(); }\n+\n   // Return a hash code for this type for the method hash table.\n   // Types which are equivalent according to are_identical will have\n   // the same hash code.\n@@ -1006,6 +1019,14 @@ class Type\n   virtual bool\n   do_compare_is_identity(Gogo*) = 0;\n \n+  virtual bool\n+  do_is_reflexive()\n+  { return true; }\n+\n+  virtual bool\n+  do_needs_key_update()\n+  { return false; }\n+\n   virtual unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1639,6 +1660,15 @@ class Float_type : public Type\n   do_compare_is_identity(Gogo*)\n   { return false; }\n \n+  bool\n+  do_is_reflexive()\n+  { return false; }\n+\n+  // Distinction between +0 and -0 requires a key update.\n+  bool\n+  do_needs_key_update()\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1712,6 +1742,15 @@ class Complex_type : public Type\n   do_compare_is_identity(Gogo*)\n   { return false; }\n \n+  bool\n+  do_is_reflexive()\n+  { return false; }\n+\n+  // Distinction between +0 and -0 requires a key update.\n+  bool\n+  do_needs_key_update()\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -1768,6 +1807,11 @@ class String_type : public Type\n   do_compare_is_identity(Gogo*)\n   { return false; }\n \n+  // New string might have a smaller backing store.\n+  bool\n+  do_needs_key_update()\n+  { return true; }\n+\n   Btype*\n   do_get_backend(Gogo*);\n \n@@ -2218,7 +2262,8 @@ class Struct_type : public Type\n  public:\n   Struct_type(Struct_field_list* fields, Location location)\n     : Type(TYPE_STRUCT),\n-      fields_(fields), location_(location), all_methods_(NULL)\n+      fields_(fields), location_(location), all_methods_(NULL),\n+      is_struct_incomparable_(false)\n   { }\n \n   // Return the field NAME.  This only looks at local fields, not at\n@@ -2323,6 +2368,16 @@ class Struct_type : public Type\n   static Type*\n   make_struct_type_descriptor_type();\n \n+  // Return whether this is a generated struct that is not comparable.\n+  bool\n+  is_struct_incomparable() const\n+  { return this->is_struct_incomparable_; }\n+\n+  // Record that this is a generated struct that is not comparable.\n+  void\n+  set_is_struct_incomparable()\n+  { this->is_struct_incomparable_ = true; }\n+\n   // Write the hash function for this type.\n   void\n   write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n@@ -2354,6 +2409,12 @@ class Struct_type : public Type\n   bool\n   do_compare_is_identity(Gogo*);\n \n+  bool\n+  do_is_reflexive();\n+\n+  bool\n+  do_needs_key_update();\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2418,6 +2479,9 @@ class Struct_type : public Type\n   Location location_;\n   // If this struct is unnamed, a list of methods.\n   Methods* all_methods_;\n+  // True if this is a generated struct that is not considered to be\n+  // comparable.\n+  bool is_struct_incomparable_;\n };\n \n // The type of an array.\n@@ -2428,7 +2492,7 @@ class Array_type : public Type\n   Array_type(Type* element_type, Expression* length)\n     : Type(TYPE_ARRAY),\n       element_type_(element_type), length_(length), blength_(NULL),\n-      issued_length_error_(false)\n+      issued_length_error_(false), is_array_incomparable_(false)\n   { }\n \n   // Return the element type.\n@@ -2479,6 +2543,16 @@ class Array_type : public Type\n   static Type*\n   make_slice_type_descriptor_type();\n \n+  // Return whether this is a generated array that is not comparable.\n+  bool\n+  is_array_incomparable() const\n+  { return this->is_array_incomparable_; }\n+\n+  // Record that this is a generated array that is not comparable.\n+  void\n+  set_is_array_incomparable()\n+  { this->is_array_incomparable_ = true; }\n+\n   // Write the hash function for this type.\n   void\n   write_hash_function(Gogo*, Named_type*, Function_type*, Function_type*);\n@@ -2503,6 +2577,16 @@ class Array_type : public Type\n   bool\n   do_compare_is_identity(Gogo*);\n \n+  bool\n+  do_is_reflexive()\n+  {\n+    return this->length_ != NULL && this->element_type_->is_reflexive();\n+  }\n+\n+  bool\n+  do_needs_key_update()\n+  { return this->element_type_->needs_key_update(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2550,6 +2634,9 @@ class Array_type : public Type\n   // Whether or not an invalid length error has been issued for this type,\n   // to avoid knock-on errors.\n   mutable bool issued_length_error_;\n+  // True if this is a generated array that is not considered to be\n+  // comparable.\n+  bool is_array_incomparable_;\n };\n \n // The type of a map.\n@@ -2559,7 +2646,8 @@ class Map_type : public Type\n  public:\n   Map_type(Type* key_type, Type* val_type, Location location)\n     : Type(TYPE_MAP),\n-      key_type_(key_type), val_type_(val_type), location_(location)\n+      key_type_(key_type), val_type_(val_type), hmap_type_(NULL),\n+      bucket_type_(NULL), hiter_type_(NULL), location_(location)\n   { }\n \n   // Return the key type.\n@@ -2572,6 +2660,24 @@ class Map_type : public Type\n   val_type() const\n   { return this->val_type_; }\n \n+  // Return the type used for an iteration over this map.\n+  Type*\n+  hiter_type(Gogo*);\n+\n+  // If this map requires the \"fat\" functions, returns the pointer to\n+  // pass as the zero value to those functions.  Otherwise, in the\n+  // normal case, returns NULL.\n+  Expression*\n+  fat_zero_value(Gogo*);\n+\n+  // Return whether VAR is the map zero value.\n+  static bool\n+  is_zero_value(Variable* var);\n+\n+  // Return the backend representation of the map zero value.\n+  static Bvariable*\n+  backend_zero_value(Gogo*);\n+\n   // Whether this type is identical with T.\n   bool\n   is_identical(const Map_type* t, bool errors_are_identical) const;\n@@ -2583,15 +2689,6 @@ class Map_type : public Type\n   static Type*\n   make_map_type_descriptor_type();\n \n-  static Type*\n-  make_map_descriptor_type();\n-\n-  // Build a map descriptor for this type.  Return a pointer to it.\n-  // The location is the location which causes us to need the\n-  // descriptor.\n-  Bexpression*\n-  map_descriptor_pointer(Gogo* gogo, Location);\n-\n  protected:\n   int\n   do_traverse(Traverse*);\n@@ -2607,6 +2704,12 @@ class Map_type : public Type\n   do_compare_is_identity(Gogo*)\n   { return false; }\n \n+  bool\n+  do_is_reflexive()\n+  {\n+    return this->key_type_->is_reflexive() && this->val_type_->is_reflexive();\n+  }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -2629,18 +2732,41 @@ class Map_type : public Type\n   do_export(Export*) const;\n \n  private:\n-  // Mapping from map types to map descriptors.\n-  typedef Unordered_map_hash(const Map_type*, Bvariable*, Type_hash_identical,\n-\t\t\t     Type_identical) Map_descriptors;\n-  static Map_descriptors map_descriptors;\n+  // These must be in sync with libgo/go/runtime/hashmap.go.\n+  static const int bucket_size = 8;\n+  static const int max_key_size = 128;\n+  static const int max_val_size = 128;\n+  static const int max_zero_size = 1024;\n+\n+  // Maps with value types larger than max_zero_size require passing a\n+  // zero value pointer to the map functions.\n+\n+  // The zero value variable.\n+  static Named_object* zero_value;\n \n-  Bvariable*\n-  map_descriptor(Gogo*);\n+  // The current size of the zero value.\n+  static int64_t zero_value_size;\n+\n+  // The current alignment of the zero value.\n+  static int64_t zero_value_align;\n+\n+  Type*\n+  bucket_type(Gogo*, int64_t, int64_t);\n+\n+  Type*\n+  hmap_type(Type*);\n \n   // The key type.\n   Type* key_type_;\n   // The value type.\n   Type* val_type_;\n+  // The hashmap type.  At run time a map is represented as a pointer\n+  // to this type.\n+  Type* hmap_type_;\n+  // The bucket type, the type used to hold keys and values at run time.\n+  Type* bucket_type_;\n+  // The iterator type.\n+  Type* hiter_type_;\n   // Where the type was defined.\n   Location location_;\n };\n@@ -2832,6 +2958,17 @@ class Interface_type : public Type\n   do_compare_is_identity(Gogo*)\n   { return false; }\n \n+  // Not reflexive if it contains a float.\n+  bool\n+  do_is_reflexive()\n+  { return false; }\n+\n+  // Distinction between +0 and -0 requires a key update if it\n+  // contains a float.\n+  bool\n+  do_needs_key_update()\n+  { return true; }\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -3121,6 +3258,12 @@ class Named_type : public Type\n   bool\n   do_compare_is_identity(Gogo*);\n \n+  bool\n+  do_is_reflexive();\n+\n+  bool\n+  do_needs_key_update();\n+\n   unsigned int\n   do_hash_for_method(Gogo*) const;\n \n@@ -3268,6 +3411,14 @@ class Forward_declaration_type : public Type\n   do_compare_is_identity(Gogo* gogo)\n   { return this->real_type()->compare_is_identity(gogo); }\n \n+  bool\n+  do_is_reflexive()\n+  { return this->real_type()->is_reflexive(); }\n+\n+  bool\n+  do_needs_key_update()\n+  { return this->real_type()->needs_key_update(); }\n+\n   unsigned int\n   do_hash_for_method(Gogo* gogo) const\n   { return this->real_type()->hash_for_method(gogo); }"}, {"sha": "6a1dae9cf3cf4ae5ad2530edd12e86f918867b8a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -1,3 +1,8 @@\n+2016-09-21  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go.go-torture/execute/map-1.go: Replace old map deletion syntax\n+\twith call to builtin delete function.\n+\n 2016-09-21  Joseph Myers  <joseph@codesourcery.com>\n \n \t* gcc.dg/torture/float128-tg-3.c, gcc.dg/torture/float128x-tg-3.c,"}, {"sha": "2054c6c413b6315390e53d89c8b9c183bfc6c08e", "filename": "gcc/testsuite/go.go-torture/execute/map-1.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgo.go-torture%2Fexecute%2Fmap-1.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -26,7 +26,7 @@ func main() {\n   if len(v) != 2 {\n     panic(6)\n   }\n-  v[0] = 0, false;\n+  delete(v, 0)\n   if len(v) != 1 {\n     panic(7)\n   }"}, {"sha": "bd75dd3e02ffb56a304dab74d730e74d9a3b260b", "filename": "libgo/Makefile.am", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -464,22 +464,19 @@ runtime_files = \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n \truntime/go-make-slice.c \\\n-\truntime/go-map-delete.c \\\n-\truntime/go-map-index.c \\\n-\truntime/go-map-len.c \\\n-\truntime/go-map-range.c \\\n \truntime/go-matherr.c \\\n+\truntime/go-memclr.c \\\n \truntime/go-memcmp.c \\\n+\truntime/go-memequal.c \\\n+\truntime/go-memmove.c \\\n \truntime/go-nanotime.c \\\n \truntime/go-now.c \\\n-\truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-nosys.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n@@ -492,7 +489,6 @@ runtime_files = \\\n \truntime/go-traceback.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n-\truntime/go-type-error.c \\\n \truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n \truntime/go-type-interface.c \\\n@@ -529,7 +525,6 @@ runtime_files = \\\n \tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\tmap.c \\\n \tmprof.c \\\n \tnetpoll.c \\\n \trdebug.c \\"}, {"sha": "78771c6f258e1a1273ec40230e7156a7ff6980b7", "filename": "libgo/Makefile.in", "status": "modified", "additions": 42, "deletions": 82, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -248,26 +248,24 @@ am__objects_6 = go-append.lo go-assert.lo go-assert-interface.lo \\\n \tgo-eface-val-compare.lo go-ffi.lo go-fieldtrack.lo \\\n \tgo-int-array-to-string.lo go-int-to-string.lo \\\n \tgo-interface-compare.lo go-interface-eface-compare.lo \\\n-\tgo-interface-val-compare.lo go-make-slice.lo go-map-delete.lo \\\n-\tgo-map-index.lo go-map-len.lo go-map-range.lo go-matherr.lo \\\n-\tgo-memcmp.lo go-nanotime.lo go-now.lo go-new-map.lo go-new.lo \\\n-\tgo-nosys.lo go-panic.lo go-print.lo go-recover.lo \\\n-\tgo-reflect-call.lo go-reflect-map.lo go-rune.lo \\\n+\tgo-interface-val-compare.lo go-make-slice.lo go-matherr.lo \\\n+\tgo-memclr.lo go-memcmp.lo go-memequal.lo go-memmove.lo \\\n+\tgo-nanotime.lo go-now.lo go-new.lo go-nosys.lo go-panic.lo \\\n+\tgo-print.lo go-recover.lo go-reflect-call.lo go-rune.lo \\\n \tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strcmp.lo \\\n \tgo-string-to-byte-array.lo go-string-to-int-array.lo \\\n \tgo-strplus.lo go-strslice.lo go-traceback.lo \\\n-\tgo-type-complex.lo go-type-eface.lo go-type-error.lo \\\n-\tgo-type-float.lo go-type-identity.lo go-type-interface.lo \\\n-\tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n-\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unsetenv.lo \\\n-\tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo \\\n-\t$(am__objects_1) mcache.lo mcentral.lo $(am__objects_2) \\\n-\tmfixalloc.lo mgc0.lo mheap.lo msize.lo $(am__objects_3) \\\n-\tpanic.lo parfor.lo print.lo proc.lo runtime.lo signal_unix.lo \\\n-\tthread.lo yield.lo $(am__objects_4) chan.lo cpuprof.lo \\\n-\tgo-iface.lo lfstack.lo malloc.lo map.lo mprof.lo netpoll.lo \\\n-\trdebug.lo reflect.lo runtime1.lo sema.lo sigqueue.lo string.lo \\\n-\ttime.lo $(am__objects_5)\n+\tgo-type-complex.lo go-type-eface.lo go-type-float.lo \\\n+\tgo-type-identity.lo go-type-interface.lo go-type-string.lo \\\n+\tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n+\tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n+\tenv_posix.lo heapdump.lo $(am__objects_1) mcache.lo \\\n+\tmcentral.lo $(am__objects_2) mfixalloc.lo mgc0.lo mheap.lo \\\n+\tmsize.lo $(am__objects_3) panic.lo parfor.lo print.lo proc.lo \\\n+\truntime.lo signal_unix.lo thread.lo yield.lo $(am__objects_4) \\\n+\tchan.lo cpuprof.lo go-iface.lo lfstack.lo malloc.lo mprof.lo \\\n+\tnetpoll.lo rdebug.lo reflect.lo runtime1.lo sema.lo \\\n+\tsigqueue.lo string.lo time.lo $(am__objects_5)\n am_libgo_llgo_la_OBJECTS = $(am__objects_6)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n libgo_llgo_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \\\n@@ -867,22 +865,19 @@ runtime_files = \\\n \truntime/go-interface-eface-compare.c \\\n \truntime/go-interface-val-compare.c \\\n \truntime/go-make-slice.c \\\n-\truntime/go-map-delete.c \\\n-\truntime/go-map-index.c \\\n-\truntime/go-map-len.c \\\n-\truntime/go-map-range.c \\\n \truntime/go-matherr.c \\\n+\truntime/go-memclr.c \\\n \truntime/go-memcmp.c \\\n+\truntime/go-memequal.c \\\n+\truntime/go-memmove.c \\\n \truntime/go-nanotime.c \\\n \truntime/go-now.c \\\n-\truntime/go-new-map.c \\\n \truntime/go-new.c \\\n \truntime/go-nosys.c \\\n \truntime/go-panic.c \\\n \truntime/go-print.c \\\n \truntime/go-recover.c \\\n \truntime/go-reflect-call.c \\\n-\truntime/go-reflect-map.c \\\n \truntime/go-rune.c \\\n \truntime/go-runtime-error.c \\\n \truntime/go-setenv.c \\\n@@ -895,7 +890,6 @@ runtime_files = \\\n \truntime/go-traceback.c \\\n \truntime/go-type-complex.c \\\n \truntime/go-type-eface.c \\\n-\truntime/go-type-error.c \\\n \truntime/go-type-float.c \\\n \truntime/go-type-identity.c \\\n \truntime/go-type-interface.c \\\n@@ -932,7 +926,6 @@ runtime_files = \\\n \tgo-iface.c \\\n \tlfstack.c \\\n \tmalloc.c \\\n-\tmap.c \\\n \tmprof.c \\\n \tnetpoll.c \\\n \trdebug.c \\\n@@ -1594,22 +1587,19 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-eface-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-interface-val-compare.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-make-slice.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-delete.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-index.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-len.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-map-range.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-matherr.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memclr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memcmp.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memequal.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-memmove.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-nanotime.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-nosys.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-now.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-panic.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-print.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-recover.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-call.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-reflect-map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-rune.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-runtime-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n@@ -1622,7 +1612,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-traceback.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-eface.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-error.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-float.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-identity.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-interface.Plo@am__quote@\n@@ -1642,7 +1631,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_futex.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lock_sema.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/malloc.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/map.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcache.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mcentral.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mem.Plo@am__quote@\n@@ -1920,48 +1908,41 @@ go-make-slice.lo: runtime/go-make-slice.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-make-slice.lo `test -f 'runtime/go-make-slice.c' || echo '$(srcdir)/'`runtime/go-make-slice.c\n \n-go-map-delete.lo: runtime/go-map-delete.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-map-delete.lo -MD -MP -MF $(DEPDIR)/go-map-delete.Tpo -c -o go-map-delete.lo `test -f 'runtime/go-map-delete.c' || echo '$(srcdir)/'`runtime/go-map-delete.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-map-delete.Tpo $(DEPDIR)/go-map-delete.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-map-delete.c' object='go-map-delete.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-map-delete.lo `test -f 'runtime/go-map-delete.c' || echo '$(srcdir)/'`runtime/go-map-delete.c\n-\n-go-map-index.lo: runtime/go-map-index.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-map-index.lo -MD -MP -MF $(DEPDIR)/go-map-index.Tpo -c -o go-map-index.lo `test -f 'runtime/go-map-index.c' || echo '$(srcdir)/'`runtime/go-map-index.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-map-index.Tpo $(DEPDIR)/go-map-index.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-map-index.c' object='go-map-index.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-map-index.lo `test -f 'runtime/go-map-index.c' || echo '$(srcdir)/'`runtime/go-map-index.c\n-\n-go-map-len.lo: runtime/go-map-len.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-map-len.lo -MD -MP -MF $(DEPDIR)/go-map-len.Tpo -c -o go-map-len.lo `test -f 'runtime/go-map-len.c' || echo '$(srcdir)/'`runtime/go-map-len.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-map-len.Tpo $(DEPDIR)/go-map-len.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-map-len.c' object='go-map-len.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-map-len.lo `test -f 'runtime/go-map-len.c' || echo '$(srcdir)/'`runtime/go-map-len.c\n-\n-go-map-range.lo: runtime/go-map-range.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-map-range.lo -MD -MP -MF $(DEPDIR)/go-map-range.Tpo -c -o go-map-range.lo `test -f 'runtime/go-map-range.c' || echo '$(srcdir)/'`runtime/go-map-range.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-map-range.Tpo $(DEPDIR)/go-map-range.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-map-range.c' object='go-map-range.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-map-range.lo `test -f 'runtime/go-map-range.c' || echo '$(srcdir)/'`runtime/go-map-range.c\n-\n go-matherr.lo: runtime/go-matherr.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-matherr.lo -MD -MP -MF $(DEPDIR)/go-matherr.Tpo -c -o go-matherr.lo `test -f 'runtime/go-matherr.c' || echo '$(srcdir)/'`runtime/go-matherr.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-matherr.Tpo $(DEPDIR)/go-matherr.Plo\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-matherr.c' object='go-matherr.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-matherr.lo `test -f 'runtime/go-matherr.c' || echo '$(srcdir)/'`runtime/go-matherr.c\n \n+go-memclr.lo: runtime/go-memclr.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-memclr.lo -MD -MP -MF $(DEPDIR)/go-memclr.Tpo -c -o go-memclr.lo `test -f 'runtime/go-memclr.c' || echo '$(srcdir)/'`runtime/go-memclr.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-memclr.Tpo $(DEPDIR)/go-memclr.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-memclr.c' object='go-memclr.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-memclr.lo `test -f 'runtime/go-memclr.c' || echo '$(srcdir)/'`runtime/go-memclr.c\n+\n go-memcmp.lo: runtime/go-memcmp.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-memcmp.lo -MD -MP -MF $(DEPDIR)/go-memcmp.Tpo -c -o go-memcmp.lo `test -f 'runtime/go-memcmp.c' || echo '$(srcdir)/'`runtime/go-memcmp.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-memcmp.Tpo $(DEPDIR)/go-memcmp.Plo\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-memcmp.c' object='go-memcmp.lo' libtool=yes @AMDEPBACKSLASH@\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-memcmp.lo `test -f 'runtime/go-memcmp.c' || echo '$(srcdir)/'`runtime/go-memcmp.c\n \n+go-memequal.lo: runtime/go-memequal.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-memequal.lo -MD -MP -MF $(DEPDIR)/go-memequal.Tpo -c -o go-memequal.lo `test -f 'runtime/go-memequal.c' || echo '$(srcdir)/'`runtime/go-memequal.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-memequal.Tpo $(DEPDIR)/go-memequal.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-memequal.c' object='go-memequal.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-memequal.lo `test -f 'runtime/go-memequal.c' || echo '$(srcdir)/'`runtime/go-memequal.c\n+\n+go-memmove.lo: runtime/go-memmove.c\n+@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-memmove.lo -MD -MP -MF $(DEPDIR)/go-memmove.Tpo -c -o go-memmove.lo `test -f 'runtime/go-memmove.c' || echo '$(srcdir)/'`runtime/go-memmove.c\n+@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-memmove.Tpo $(DEPDIR)/go-memmove.Plo\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-memmove.c' object='go-memmove.lo' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-memmove.lo `test -f 'runtime/go-memmove.c' || echo '$(srcdir)/'`runtime/go-memmove.c\n+\n go-nanotime.lo: runtime/go-nanotime.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-nanotime.lo -MD -MP -MF $(DEPDIR)/go-nanotime.Tpo -c -o go-nanotime.lo `test -f 'runtime/go-nanotime.c' || echo '$(srcdir)/'`runtime/go-nanotime.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-nanotime.Tpo $(DEPDIR)/go-nanotime.Plo\n@@ -1976,13 +1957,6 @@ go-now.lo: runtime/go-now.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-now.lo `test -f 'runtime/go-now.c' || echo '$(srcdir)/'`runtime/go-now.c\n \n-go-new-map.lo: runtime/go-new-map.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-new-map.lo -MD -MP -MF $(DEPDIR)/go-new-map.Tpo -c -o go-new-map.lo `test -f 'runtime/go-new-map.c' || echo '$(srcdir)/'`runtime/go-new-map.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-new-map.Tpo $(DEPDIR)/go-new-map.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-new-map.c' object='go-new-map.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-new-map.lo `test -f 'runtime/go-new-map.c' || echo '$(srcdir)/'`runtime/go-new-map.c\n-\n go-new.lo: runtime/go-new.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-new.lo -MD -MP -MF $(DEPDIR)/go-new.Tpo -c -o go-new.lo `test -f 'runtime/go-new.c' || echo '$(srcdir)/'`runtime/go-new.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-new.Tpo $(DEPDIR)/go-new.Plo\n@@ -2025,13 +1999,6 @@ go-reflect-call.lo: runtime/go-reflect-call.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect-call.lo `test -f 'runtime/go-reflect-call.c' || echo '$(srcdir)/'`runtime/go-reflect-call.c\n \n-go-reflect-map.lo: runtime/go-reflect-map.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-reflect-map.lo -MD -MP -MF $(DEPDIR)/go-reflect-map.Tpo -c -o go-reflect-map.lo `test -f 'runtime/go-reflect-map.c' || echo '$(srcdir)/'`runtime/go-reflect-map.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-reflect-map.Tpo $(DEPDIR)/go-reflect-map.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-reflect-map.c' object='go-reflect-map.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-reflect-map.lo `test -f 'runtime/go-reflect-map.c' || echo '$(srcdir)/'`runtime/go-reflect-map.c\n-\n go-rune.lo: runtime/go-rune.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-rune.lo -MD -MP -MF $(DEPDIR)/go-rune.Tpo -c -o go-rune.lo `test -f 'runtime/go-rune.c' || echo '$(srcdir)/'`runtime/go-rune.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-rune.Tpo $(DEPDIR)/go-rune.Plo\n@@ -2116,13 +2083,6 @@ go-type-eface.lo: runtime/go-type-eface.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-eface.lo `test -f 'runtime/go-type-eface.c' || echo '$(srcdir)/'`runtime/go-type-eface.c\n \n-go-type-error.lo: runtime/go-type-error.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-error.lo -MD -MP -MF $(DEPDIR)/go-type-error.Tpo -c -o go-type-error.lo `test -f 'runtime/go-type-error.c' || echo '$(srcdir)/'`runtime/go-type-error.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-error.Tpo $(DEPDIR)/go-type-error.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-error.c' object='go-type-error.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-error.lo `test -f 'runtime/go-type-error.c' || echo '$(srcdir)/'`runtime/go-type-error.c\n-\n go-type-float.lo: runtime/go-type-float.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-float.lo -MD -MP -MF $(DEPDIR)/go-type-float.Tpo -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-float.Tpo $(DEPDIR)/go-type-float.Plo"}, {"sha": "13b326f5a8de3c907732a7806973db8ca8ae3447", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 79, "deletions": 78, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -16,7 +16,6 @@\n package reflect\n \n import (\n-\t\"runtime\"\n \t\"strconv\"\n \t\"sync\"\n \t\"unsafe\"\n@@ -255,7 +254,7 @@ type rtype struct {\n \tsize       uintptr\n \thash       uint32 // hash of type; avoids computation in hash tables\n \n-\thashfn  func(unsafe.Pointer, uintptr) uintptr              // hash function\n+\thashfn  func(unsafe.Pointer, uintptr, uintptr) uintptr     // hash function\n \tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool // equality function\n \n \tgc            unsafe.Pointer // garbage collection data\n@@ -330,9 +329,18 @@ type interfaceType struct {\n \n // mapType represents a map type.\n type mapType struct {\n-\trtype `reflect:\"map\"`\n-\tkey   *rtype // map key type\n-\telem  *rtype // map element (value) type\n+\trtype         `reflect:\"map\"`\n+\tkey           *rtype // map key type\n+\telem          *rtype // map element (value) type\n+\tbucket        *rtype // internal bucket structure\n+\thmap          *rtype // internal map header\n+\tkeysize       uint8  // size of key slot\n+\tindirectkey   uint8  // store ptr to key instead of key itself\n+\tvaluesize     uint8  // size of value slot\n+\tindirectvalue uint8  // store ptr to value instead of value itself\n+\tbucketsize    uint16 // size of bucket\n+\treflexivekey  bool   // true if k==k for all keys\n+\tneedkeyupdate bool   // true if we need to update key on an overwrite\n }\n \n // ptrType represents a pointer type.\n@@ -1606,20 +1614,25 @@ func MapOf(key, elem Type) Type {\n \tmt.elem = etyp\n \tmt.uncommonType = nil\n \tmt.ptrToThis = nil\n-\t// mt.gc = unsafe.Pointer(&ptrGC{\n-\t// \twidth:  unsafe.Sizeof(uintptr(0)),\n-\t// \top:     _GC_PTR,\n-\t// \toff:    0,\n-\t// \telemgc: nil,\n-\t// \tend:    _GC_END,\n-\t// })\n \n-\t// TODO(cmang): Generate GC data for Map elements.\n-\tmt.gc = unsafe.Pointer(&ptrDataGCProg)\n-\n-\t// INCORRECT. Uncomment to check that TestMapOfGC and TestMapOfGCValues\n-\t// fail when mt.gc is wrong.\n-\t//mt.gc = unsafe.Pointer(&badGC{width: mt.size, end: _GC_END})\n+\tmt.bucket = bucketOf(ktyp, etyp)\n+\tif ktyp.size > maxKeySize {\n+\t\tmt.keysize = uint8(ptrSize)\n+\t\tmt.indirectkey = 1\n+\t} else {\n+\t\tmt.keysize = uint8(ktyp.size)\n+\t\tmt.indirectkey = 0\n+\t}\n+\tif etyp.size > maxValSize {\n+\t\tmt.valuesize = uint8(ptrSize)\n+\t\tmt.indirectvalue = 1\n+\t} else {\n+\t\tmt.valuesize = uint8(etyp.size)\n+\t\tmt.indirectvalue = 0\n+\t}\n+\tmt.bucketsize = uint16(mt.bucket.size)\n+\tmt.reflexivekey = isReflexive(ktyp)\n+\tmt.needkeyupdate = needKeyUpdate(ktyp)\n \n \treturn cachePut(ckey, &mt.rtype)\n }\n@@ -1824,72 +1837,60 @@ func bucketOf(ktyp, etyp *rtype) *rtype {\n \t// Note that since the key and value are known to be <= 128 bytes,\n \t// they're guaranteed to have bitmaps instead of GC programs.\n \t// var gcdata *byte\n-\tvar ptrdata uintptr\n-\tvar overflowPad uintptr\n+\t// var ptrdata uintptr\n \n-\t// On NaCl, pad if needed to make overflow end at the proper struct alignment.\n-\t// On other systems, align > ptrSize is not possible.\n-\tif runtime.GOARCH == \"amd64p32\" && (ktyp.align > ptrSize || etyp.align > ptrSize) {\n-\t\toverflowPad = ptrSize\n+\tsize := bucketSize\n+\tsize = align(size, uintptr(ktyp.fieldAlign))\n+\tsize += bucketSize * ktyp.size\n+\tsize = align(size, uintptr(etyp.fieldAlign))\n+\tsize += bucketSize * etyp.size\n+\n+\tmaxAlign := uintptr(ktyp.fieldAlign)\n+\tif maxAlign < uintptr(etyp.fieldAlign) {\n+\t\tmaxAlign = uintptr(etyp.fieldAlign)\n \t}\n-\tsize := bucketSize*(1+ktyp.size+etyp.size) + overflowPad + ptrSize\n-\tif size&uintptr(ktyp.align-1) != 0 || size&uintptr(etyp.align-1) != 0 {\n-\t\tpanic(\"reflect: bad size computation in MapOf\")\n+\tif maxAlign > ptrSize {\n+\t\tsize = align(size, maxAlign)\n+\t\tsize += align(ptrSize, maxAlign) - ptrSize\n \t}\n \n-\tif kind != kindNoPointers {\n-\t\tnptr := (bucketSize*(1+ktyp.size+etyp.size) + ptrSize) / ptrSize\n-\t\tmask := make([]byte, (nptr+7)/8)\n-\t\tbase := bucketSize / ptrSize\n+\tovoff := size\n+\tsize += ptrSize\n+\tif maxAlign < ptrSize {\n+\t\tmaxAlign = ptrSize\n+\t}\n \n+\tvar gcPtr unsafe.Pointer\n+\tif kind != kindNoPointers {\n+\t\tgc := []uintptr{size}\n+\t\tbase := bucketSize\n+\t\tbase = align(base, uintptr(ktyp.fieldAlign))\n \t\tif ktyp.kind&kindNoPointers == 0 {\n-\t\t\tif ktyp.kind&kindGCProg != 0 {\n-\t\t\t\tpanic(\"reflect: unexpected GC program in MapOf\")\n-\t\t\t}\n-\t\t\tkmask := (*[16]byte)(unsafe.Pointer( /*ktyp.gcdata*/ nil))\n-\t\t\tfor i := uintptr(0); i < ktyp.size/ptrSize; i++ {\n-\t\t\t\tif (kmask[i/8]>>(i%8))&1 != 0 {\n-\t\t\t\t\tfor j := uintptr(0); j < bucketSize; j++ {\n-\t\t\t\t\t\tword := base + j*ktyp.size/ptrSize + i\n-\t\t\t\t\t\tmask[word/8] |= 1 << (word % 8)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\tgc = append(gc, _GC_ARRAY_START, base, bucketSize, ktyp.size)\n+\t\t\tgc = appendGCProgram(gc, ktyp, 0)\n+\t\t\tgc = append(gc, _GC_ARRAY_NEXT)\n \t\t}\n-\t\tbase += bucketSize * ktyp.size / ptrSize\n-\n+\t\tbase += ktyp.size * bucketSize\n+\t\tbase = align(base, uintptr(etyp.fieldAlign))\n \t\tif etyp.kind&kindNoPointers == 0 {\n-\t\t\tif etyp.kind&kindGCProg != 0 {\n-\t\t\t\tpanic(\"reflect: unexpected GC program in MapOf\")\n-\t\t\t}\n-\t\t\temask := (*[16]byte)(unsafe.Pointer( /*etyp.gcdata*/ nil))\n-\t\t\tfor i := uintptr(0); i < etyp.size/ptrSize; i++ {\n-\t\t\t\tif (emask[i/8]>>(i%8))&1 != 0 {\n-\t\t\t\t\tfor j := uintptr(0); j < bucketSize; j++ {\n-\t\t\t\t\t\tword := base + j*etyp.size/ptrSize + i\n-\t\t\t\t\t\tmask[word/8] |= 1 << (word % 8)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\tbase += bucketSize * etyp.size / ptrSize\n-\t\tbase += overflowPad / ptrSize\n-\n-\t\tword := base\n-\t\tmask[word/8] |= 1 << (word % 8)\n-\t\t// gcdata = &mask[0]\n-\t\tptrdata = (word + 1) * ptrSize\n-\n-\t\t// overflow word must be last\n-\t\tif ptrdata != size {\n-\t\t\tpanic(\"reflect: bad layout computation in MapOf\")\n+\t\t\tgc = append(gc, _GC_ARRAY_START, base, bucketSize, etyp.size)\n+\t\t\tgc = appendGCProgram(gc, etyp, 0)\n+\t\t\tgc = append(gc, _GC_ARRAY_NEXT)\n \t\t}\n+\t\tgc = append(gc, _GC_APTR, ovoff, _GC_END)\n+\t\tgcPtr = unsafe.Pointer(&gc[0])\n+\t} else {\n+\t\t// No pointers in bucket.\n+\t\tgc := [...]uintptr{size, _GC_END}\n+\t\tgcPtr = unsafe.Pointer(&gc[0])\n \t}\n \n \tb := new(rtype)\n-\t// b.size = gc.size\n-\t// b.gc[0], _ = gc.finalize()\n-\tb.kind |= kindGCProg\n+\tb.align = int8(maxAlign)\n+\tb.fieldAlign = uint8(maxAlign)\n+\tb.size = size\n+\tb.kind = kind\n+\tb.gc = gcPtr\n \ts := \"bucket(\" + *ktyp.string + \",\" + *etyp.string + \")\"\n \tb.string = &s\n \treturn b\n@@ -2202,14 +2203,14 @@ func StructOf(fields []StructField) Type {\n \t\ttyp.gc = unsafe.Pointer(&gc[0])\n \t}\n \n-\ttyp.hashfn = func(p unsafe.Pointer, size uintptr) uintptr {\n-\t\tret := uintptr(0)\n+\ttyp.hashfn = func(p unsafe.Pointer, seed, size uintptr) uintptr {\n+\t\tret := seed\n \t\tfor i, ft := range typ.fields {\n \t\t\tif i > 0 {\n \t\t\t\tret *= 33\n \t\t\t}\n \t\t\to := unsafe.Pointer(uintptr(p) + ft.offset)\n-\t\t\tret += ft.typ.hashfn(o, ft.typ.size)\n+\t\t\tret = ft.typ.hashfn(o, ret, ft.typ.size)\n \t\t}\n \t\treturn ret\n \t}\n@@ -2347,11 +2348,11 @@ func ArrayOf(count int, elem Type) Type {\n \n \tarray.kind &^= kindDirectIface\n \n-\tarray.hashfn = func(p unsafe.Pointer, size uintptr) uintptr {\n-\t\tret := uintptr(0)\n+\tarray.hashfn = func(p unsafe.Pointer, seed, size uintptr) uintptr {\n+\t\tret := seed\n \t\tfor i := 0; i < count; i++ {\n \t\t\tret *= 33\n-\t\t\tret += typ.hashfn(p, typ.size)\n+\t\t\tret = typ.hashfn(p, ret, typ.size)\n \t\t\tp = unsafe.Pointer(uintptr(p) + typ.size)\n \t\t}\n \t\treturn ret"}, {"sha": "2b1a9b72211d61143b519db33847134270468dcb", "filename": "libgo/go/runtime/export_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fexport_test.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -90,7 +90,7 @@ func GCMask(x interface{}) (ret []byte) {\n //var IfaceHash = ifaceHash\n //var MemclrBytes = memclrBytes\n \n-// var HashLoad = &hashLoad\n+var HashLoad = &hashLoad\n \n // entry point for testing\n //func GostringW(w []uint16) (s string) {"}, {"sha": "aaf4fb4d6e336146c621a6c7bc91123c0ffc8c4f", "filename": "libgo/go/runtime/hashmap.go", "status": "added", "additions": 1081, "deletions": 0, "changes": 1081, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fhashmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fhashmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,1081 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+// This file contains the implementation of Go's map type.\n+//\n+// A map is just a hash table. The data is arranged\n+// into an array of buckets. Each bucket contains up to\n+// 8 key/value pairs. The low-order bits of the hash are\n+// used to select a bucket. Each bucket contains a few\n+// high-order bits of each hash to distinguish the entries\n+// within a single bucket.\n+//\n+// If more than 8 keys hash to a bucket, we chain on\n+// extra buckets.\n+//\n+// When the hashtable grows, we allocate a new array\n+// of buckets twice as big. Buckets are incrementally\n+// copied from the old bucket array to the new bucket array.\n+//\n+// Map iterators walk through the array of buckets and\n+// return the keys in walk order (bucket #, then overflow\n+// chain order, then bucket index).  To maintain iteration\n+// semantics, we never move keys within their bucket (if\n+// we did, keys might be returned 0 or 2 times).  When\n+// growing the table, iterators remain iterating through the\n+// old table and must check the new table if the bucket\n+// they are iterating through has been moved (\"evacuated\")\n+// to the new table.\n+\n+// Picking loadFactor: too large and we have lots of overflow\n+// buckets, too small and we waste a lot of space. I wrote\n+// a simple program to check some stats for different loads:\n+// (64-bit, 8 byte keys and values)\n+//  loadFactor    %overflow  bytes/entry     hitprobe    missprobe\n+//        4.00         2.13        20.77         3.00         4.00\n+//        4.50         4.05        17.30         3.25         4.50\n+//        5.00         6.85        14.77         3.50         5.00\n+//        5.50        10.55        12.94         3.75         5.50\n+//        6.00        15.27        11.67         4.00         6.00\n+//        6.50        20.90        10.79         4.25         6.50\n+//        7.00        27.14        10.15         4.50         7.00\n+//        7.50        34.03         9.73         4.75         7.50\n+//        8.00        41.10         9.40         5.00         8.00\n+//\n+// %overflow   = percentage of buckets which have an overflow bucket\n+// bytes/entry = overhead bytes used per key/value pair\n+// hitprobe    = # of entries to check when looking up a present key\n+// missprobe   = # of entries to check when looking up an absent key\n+//\n+// Keep in mind this data is for maximally loaded tables, i.e. just\n+// before the table grows. Typical tables will be somewhat less loaded.\n+\n+import (\n+\t\"runtime/internal/atomic\"\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+// For gccgo, use go:linkname to rename compiler-called functions to\n+// themselves, so that the compiler will export them.\n+//\n+//go:linkname makemap runtime.makemap\n+//go:linkname mapaccess1 runtime.mapaccess1\n+//go:linkname mapaccess2 runtime.mapaccess2\n+//go:linkname mapaccess1_fat runtime.mapaccess1_fat\n+//go:linkname mapaccess2_fat runtime.mapaccess2_fat\n+//go:linkname mapassign1 runtime.mapassign1\n+//go:linkname mapdelete runtime.mapdelete\n+//go:linkname mapiterinit runtime.mapiterinit\n+//go:linkname mapiternext runtime.mapiternext\n+\n+const (\n+\t// Maximum number of key/value pairs a bucket can hold.\n+\tbucketCntBits = 3\n+\tbucketCnt     = 1 << bucketCntBits\n+\n+\t// Maximum average load of a bucket that triggers growth.\n+\tloadFactor = 6.5\n+\n+\t// Maximum key or value size to keep inline (instead of mallocing per element).\n+\t// Must fit in a uint8.\n+\t// Fast versions cannot handle big values - the cutoff size for\n+\t// fast versions in ../../cmd/internal/gc/walk.go must be at most this value.\n+\tmaxKeySize   = 128\n+\tmaxValueSize = 128\n+\n+\t// data offset should be the size of the bmap struct, but needs to be\n+\t// aligned correctly. For amd64p32 this means 64-bit alignment\n+\t// even though pointers are 32 bit.\n+\tdataOffset = unsafe.Offsetof(struct {\n+\t\tb bmap\n+\t\tv int64\n+\t}{}.v)\n+\n+\t// Possible tophash values. We reserve a few possibilities for special marks.\n+\t// Each bucket (including its overflow buckets, if any) will have either all or none of its\n+\t// entries in the evacuated* states (except during the evacuate() method, which only happens\n+\t// during map writes and thus no one else can observe the map during that time).\n+\tempty          = 0 // cell is empty\n+\tevacuatedEmpty = 1 // cell is empty, bucket is evacuated.\n+\tevacuatedX     = 2 // key/value is valid.  Entry has been evacuated to first half of larger table.\n+\tevacuatedY     = 3 // same as above, but evacuated to second half of larger table.\n+\tminTopHash     = 4 // minimum tophash for a normal filled cell.\n+\n+\t// flags\n+\titerator    = 1 // there may be an iterator using buckets\n+\toldIterator = 2 // there may be an iterator using oldbuckets\n+\thashWriting = 4 // a goroutine is writing to the map\n+\n+\t// sentinel bucket ID for iterator checks\n+\tnoCheck = 1<<(8*sys.PtrSize) - 1\n+)\n+\n+// A header for a Go map.\n+type hmap struct {\n+\t// Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and\n+\t// ../reflect/type.go. Don't change this structure without also changing that code!\n+\tcount int // # live cells == size of map.  Must be first (used by len() builtin)\n+\tflags uint8\n+\tB     uint8  // log_2 of # of buckets (can hold up to loadFactor * 2^B items)\n+\thash0 uint32 // hash seed\n+\n+\tbuckets    unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.\n+\toldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing\n+\tnevacuate  uintptr        // progress counter for evacuation (buckets less than this have been evacuated)\n+\n+\t// If both key and value do not contain pointers and are inline, then we mark bucket\n+\t// type as containing no pointers. This avoids scanning such maps.\n+\t// However, bmap.overflow is a pointer. In order to keep overflow buckets\n+\t// alive, we store pointers to all overflow buckets in hmap.overflow.\n+\t// Overflow is used only if key and value do not contain pointers.\n+\t// overflow[0] contains overflow buckets for hmap.buckets.\n+\t// overflow[1] contains overflow buckets for hmap.oldbuckets.\n+\t// The first indirection allows us to reduce static size of hmap.\n+\t// The second indirection allows to store a pointer to the slice in hiter.\n+\toverflow *[2]*[]*bmap\n+}\n+\n+// A bucket for a Go map.\n+type bmap struct {\n+\ttophash [bucketCnt]uint8\n+\t// Followed by bucketCnt keys and then bucketCnt values.\n+\t// NOTE: packing all the keys together and then all the values together makes the\n+\t// code a bit more complicated than alternating key/value/key/value/... but it allows\n+\t// us to eliminate padding which would be needed for, e.g., map[int64]int8.\n+\t// Followed by an overflow pointer.\n+}\n+\n+// A hash iteration structure.\n+// If you modify hiter, also change cmd/internal/gc/reflect.go to indicate\n+// the layout of this structure.\n+type hiter struct {\n+\tkey         unsafe.Pointer // Must be in first position.  Write nil to indicate iteration end (see cmd/internal/gc/range.go).\n+\tvalue       unsafe.Pointer // Must be in second position (see cmd/internal/gc/range.go).\n+\tt           *maptype\n+\th           *hmap\n+\tbuckets     unsafe.Pointer // bucket ptr at hash_iter initialization time\n+\tbptr        *bmap          // current bucket\n+\toverflow    [2]*[]*bmap    // keeps overflow buckets alive\n+\tstartBucket uintptr        // bucket iteration started at\n+\toffset      uint8          // intra-bucket offset to start from during iteration (should be big enough to hold bucketCnt-1)\n+\twrapped     bool           // already wrapped around from end of bucket array to beginning\n+\tB           uint8\n+\ti           uint8\n+\tbucket      uintptr\n+\tcheckBucket uintptr\n+}\n+\n+func evacuated(b *bmap) bool {\n+\th := b.tophash[0]\n+\treturn h > empty && h < minTopHash\n+}\n+\n+func (b *bmap) overflow(t *maptype) *bmap {\n+\treturn *(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize))\n+}\n+\n+func (h *hmap) setoverflow(t *maptype, b, ovf *bmap) {\n+\tif t.bucket.kind&kindNoPointers != 0 {\n+\t\th.createOverflow()\n+\t\t*h.overflow[0] = append(*h.overflow[0], ovf)\n+\t}\n+\t*(**bmap)(add(unsafe.Pointer(b), uintptr(t.bucketsize)-sys.PtrSize)) = ovf\n+}\n+\n+func (h *hmap) createOverflow() {\n+\tif h.overflow == nil {\n+\t\th.overflow = new([2]*[]*bmap)\n+\t}\n+\tif h.overflow[0] == nil {\n+\t\th.overflow[0] = new([]*bmap)\n+\t}\n+}\n+\n+// makemap implements a Go map creation make(map[k]v, hint)\n+// If the compiler has determined that the map or the first bucket\n+// can be created on the stack, h and/or bucket may be non-nil.\n+// If h != nil, the map can be created directly in h.\n+// If bucket != nil, bucket can be used as the first bucket.\n+func makemap(t *maptype, hint int64, h *hmap, bucket unsafe.Pointer) *hmap {\n+\tif sz := unsafe.Sizeof(hmap{}); sz > 48 || sz != t.hmap.size {\n+\t\tprintln(\"runtime: sizeof(hmap) =\", sz, \", t.hmap.size =\", t.hmap.size)\n+\t\tthrow(\"bad hmap size\")\n+\t}\n+\n+\tif hint < 0 || int64(int32(hint)) != hint {\n+\t\tpanic(plainError(\"makemap: size out of range\"))\n+\t\t// TODO: make hint an int, then none of this nonsense\n+\t}\n+\n+\tif !ismapkey(t.key) {\n+\t\tthrow(\"runtime.makemap: unsupported map key type\")\n+\t}\n+\n+\t// check compiler's and reflect's math\n+\tif t.key.size > maxKeySize && (!t.indirectkey || t.keysize != uint8(sys.PtrSize)) ||\n+\t\tt.key.size <= maxKeySize && (t.indirectkey || t.keysize != uint8(t.key.size)) {\n+\t\tthrow(\"key size wrong\")\n+\t}\n+\tif t.elem.size > maxValueSize && (!t.indirectvalue || t.valuesize != uint8(sys.PtrSize)) ||\n+\t\tt.elem.size <= maxValueSize && (t.indirectvalue || t.valuesize != uint8(t.elem.size)) {\n+\t\tthrow(\"value size wrong\")\n+\t}\n+\n+\t// invariants we depend on. We should probably check these at compile time\n+\t// somewhere, but for now we'll do it here.\n+\tif t.key.align > bucketCnt {\n+\t\tthrow(\"key align too big\")\n+\t}\n+\tif t.elem.align > bucketCnt {\n+\t\tthrow(\"value align too big\")\n+\t}\n+\tif t.key.size%uintptr(t.key.align) != 0 {\n+\t\tthrow(\"key size not a multiple of key align\")\n+\t}\n+\tif t.elem.size%uintptr(t.elem.align) != 0 {\n+\t\tthrow(\"value size not a multiple of value align\")\n+\t}\n+\tif bucketCnt < 8 {\n+\t\tthrow(\"bucketsize too small for proper alignment\")\n+\t}\n+\tif dataOffset%uintptr(t.key.align) != 0 {\n+\t\tthrow(\"need padding in bucket (key)\")\n+\t}\n+\tif dataOffset%uintptr(t.elem.align) != 0 {\n+\t\tthrow(\"need padding in bucket (value)\")\n+\t}\n+\n+\t// find size parameter which will hold the requested # of elements\n+\tB := uint8(0)\n+\tfor ; hint > bucketCnt && float32(hint) > loadFactor*float32(uintptr(1)<<B); B++ {\n+\t}\n+\n+\t// allocate initial hash table\n+\t// if B == 0, the buckets field is allocated lazily later (in mapassign)\n+\t// If hint is large zeroing this memory could take a while.\n+\tbuckets := bucket\n+\tif B != 0 {\n+\t\tbuckets = newarray(t.bucket, 1<<B)\n+\t}\n+\n+\t// initialize Hmap\n+\tif h == nil {\n+\t\th = (*hmap)(newobject(t.hmap))\n+\t}\n+\th.count = 0\n+\th.B = B\n+\th.flags = 0\n+\th.hash0 = fastrand1()\n+\th.buckets = buckets\n+\th.oldbuckets = nil\n+\th.nevacuate = 0\n+\n+\treturn h\n+}\n+\n+// mapaccess1 returns a pointer to h[key].  Never returns nil, instead\n+// it will return a reference to the zero object for the value type if\n+// the key is not in the map.\n+// NOTE: The returned pointer may keep the whole map live, so don't\n+// hold onto it for very long.\n+func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tpc := funcPC(mapaccess1)\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, pc)\n+\t\traceReadObjectPC(t.key, key, callerpc, pc)\n+\t}\n+\tif msanenabled && h != nil {\n+\t\tmsanread(key, t.key.size)\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\tm := uintptr(1)<<h.B - 1\n+\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\tif c := h.oldbuckets; c != nil {\n+\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\tif !evacuated(oldb) {\n+\t\t\tb = oldb\n+\t\t}\n+\t}\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tif b.tophash[i] != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\tif t.indirectkey {\n+\t\t\t\tk = *((*unsafe.Pointer)(k))\n+\t\t\t}\n+\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n+\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n+\t\t\t\t}\n+\t\t\t\treturn v\n+\t\t\t}\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool) {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tpc := funcPC(mapaccess2)\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, pc)\n+\t\traceReadObjectPC(t.key, key, callerpc, pc)\n+\t}\n+\tif msanenabled && h != nil {\n+\t\tmsanread(key, t.key.size)\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\tm := uintptr(1)<<h.B - 1\n+\tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n+\tif c := h.oldbuckets; c != nil {\n+\t\toldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\tif !evacuated(oldb) {\n+\t\t\tb = oldb\n+\t\t}\n+\t}\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tif b.tophash[i] != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\tif t.indirectkey {\n+\t\t\t\tk = *((*unsafe.Pointer)(k))\n+\t\t\t}\n+\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n+\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n+\t\t\t\t}\n+\t\t\t\treturn v, true\n+\t\t\t}\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t\t}\n+\t}\n+}\n+\n+// returns both key and value. Used by map iterator\n+func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe.Pointer) {\n+\tif h == nil || h.count == 0 {\n+\t\treturn nil, nil\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\tm := uintptr(1)<<h.B - 1\n+\tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n+\tif c := h.oldbuckets; c != nil {\n+\t\toldb := (*bmap)(unsafe.Pointer(uintptr(c) + (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\tif !evacuated(oldb) {\n+\t\t\tb = oldb\n+\t\t}\n+\t}\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tif b.tophash[i] != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\tif t.indirectkey {\n+\t\t\t\tk = *((*unsafe.Pointer)(k))\n+\t\t\t}\n+\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n+\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n+\t\t\t\t}\n+\t\t\t\treturn k, v\n+\t\t\t}\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn nil, nil\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess1_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) unsafe.Pointer {\n+\tv := mapaccess1(t, h, key)\n+\tif v == unsafe.Pointer(&zeroVal[0]) {\n+\t\treturn zero\n+\t}\n+\treturn v\n+}\n+\n+func mapaccess2_fat(t *maptype, h *hmap, key, zero unsafe.Pointer) (unsafe.Pointer, bool) {\n+\tv := mapaccess1(t, h, key)\n+\tif v == unsafe.Pointer(&zeroVal[0]) {\n+\t\treturn zero, false\n+\t}\n+\treturn v, true\n+}\n+\n+func mapassign1(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer) {\n+\tif h == nil {\n+\t\tpanic(plainError(\"assignment to entry in nil map\"))\n+\t}\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tpc := funcPC(mapassign1)\n+\t\tracewritepc(unsafe.Pointer(h), callerpc, pc)\n+\t\traceReadObjectPC(t.key, key, callerpc, pc)\n+\t\traceReadObjectPC(t.elem, val, callerpc, pc)\n+\t}\n+\tif msanenabled {\n+\t\tmsanread(key, t.key.size)\n+\t\tmsanread(val, t.elem.size)\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map writes\")\n+\t}\n+\th.flags |= hashWriting\n+\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\n+\tif h.buckets == nil {\n+\t\th.buckets = newarray(t.bucket, 1)\n+\t}\n+\n+again:\n+\tbucket := hash & (uintptr(1)<<h.B - 1)\n+\tif h.oldbuckets != nil {\n+\t\tgrowWork(t, h, bucket)\n+\t}\n+\tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\n+\tvar inserti *uint8\n+\tvar insertk unsafe.Pointer\n+\tvar insertv unsafe.Pointer\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tif b.tophash[i] != top {\n+\t\t\t\tif b.tophash[i] == empty && inserti == nil {\n+\t\t\t\t\tinserti = &b.tophash[i]\n+\t\t\t\t\tinsertk = add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\t\t\tinsertv = add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\tk2 := k\n+\t\t\tif t.indirectkey {\n+\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n+\t\t\t}\n+\t\t\tif !equalfn(key, k2, uintptr(t.keysize)) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// already have a mapping for key. Update it.\n+\t\t\tif t.needkeyupdate {\n+\t\t\t\ttypedmemmove(t.key, k2, key)\n+\t\t\t}\n+\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n+\t\t\tv2 := v\n+\t\t\tif t.indirectvalue {\n+\t\t\t\tv2 = *((*unsafe.Pointer)(v2))\n+\t\t\t}\n+\t\t\ttypedmemmove(t.elem, v2, val)\n+\t\t\tgoto done\n+\t\t}\n+\t\tovf := b.overflow(t)\n+\t\tif ovf == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tb = ovf\n+\t}\n+\n+\t// did not find mapping for key. Allocate new cell & add entry.\n+\tif float32(h.count) >= loadFactor*float32((uintptr(1)<<h.B)) && h.count >= bucketCnt {\n+\t\thashGrow(t, h)\n+\t\tgoto again // Growing the table invalidates everything, so try again\n+\t}\n+\n+\tif inserti == nil {\n+\t\t// all current buckets are full, allocate a new one.\n+\t\tnewb := (*bmap)(newobject(t.bucket))\n+\t\th.setoverflow(t, b, newb)\n+\t\tinserti = &newb.tophash[0]\n+\t\tinsertk = add(unsafe.Pointer(newb), dataOffset)\n+\t\tinsertv = add(insertk, bucketCnt*uintptr(t.keysize))\n+\t}\n+\n+\t// store new key/value at insert position\n+\tif t.indirectkey {\n+\t\tkmem := newobject(t.key)\n+\t\t*(*unsafe.Pointer)(insertk) = kmem\n+\t\tinsertk = kmem\n+\t}\n+\tif t.indirectvalue {\n+\t\tvmem := newobject(t.elem)\n+\t\t*(*unsafe.Pointer)(insertv) = vmem\n+\t\tinsertv = vmem\n+\t}\n+\ttypedmemmove(t.key, insertk, key)\n+\ttypedmemmove(t.elem, insertv, val)\n+\t*inserti = top\n+\th.count++\n+\n+done:\n+\tif h.flags&hashWriting == 0 {\n+\t\tthrow(\"concurrent map writes\")\n+\t}\n+\th.flags &^= hashWriting\n+}\n+\n+func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tpc := funcPC(mapdelete)\n+\t\tracewritepc(unsafe.Pointer(h), callerpc, pc)\n+\t\traceReadObjectPC(t.key, key, callerpc, pc)\n+\t}\n+\tif msanenabled && h != nil {\n+\t\tmsanread(key, t.key.size)\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map writes\")\n+\t}\n+\th.flags |= hashWriting\n+\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\tbucket := hash & (uintptr(1)<<h.B - 1)\n+\tif h.oldbuckets != nil {\n+\t\tgrowWork(t, h, bucket)\n+\t}\n+\tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + bucket*uintptr(t.bucketsize)))\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tif b.tophash[i] != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset+i*uintptr(t.keysize))\n+\t\t\tk2 := k\n+\t\t\tif t.indirectkey {\n+\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n+\t\t\t}\n+\t\t\tif !equalfn(key, k2, uintptr(t.keysize)) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tmemclr(k, uintptr(t.keysize))\n+\t\t\tv := unsafe.Pointer(uintptr(unsafe.Pointer(b)) + dataOffset + bucketCnt*uintptr(t.keysize) + i*uintptr(t.valuesize))\n+\t\t\tmemclr(v, uintptr(t.valuesize))\n+\t\t\tb.tophash[i] = empty\n+\t\t\th.count--\n+\t\t\tgoto done\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\tgoto done\n+\t\t}\n+\t}\n+\n+done:\n+\tif h.flags&hashWriting == 0 {\n+\t\tthrow(\"concurrent map writes\")\n+\t}\n+\th.flags &^= hashWriting\n+}\n+\n+func mapiterinit(t *maptype, h *hmap, it *hiter) {\n+\t// Clear pointer fields so garbage collector does not complain.\n+\tit.key = nil\n+\tit.value = nil\n+\tit.t = nil\n+\tit.h = nil\n+\tit.buckets = nil\n+\tit.bptr = nil\n+\tit.overflow[0] = nil\n+\tit.overflow[1] = nil\n+\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiterinit))\n+\t}\n+\n+\tif h == nil || h.count == 0 {\n+\t\tit.key = nil\n+\t\tit.value = nil\n+\t\treturn\n+\t}\n+\n+\tif unsafe.Sizeof(hiter{})/sys.PtrSize != 12 {\n+\t\tthrow(\"hash_iter size incorrect\") // see ../../cmd/internal/gc/reflect.go\n+\t}\n+\tit.t = t\n+\tit.h = h\n+\n+\t// grab snapshot of bucket state\n+\tit.B = h.B\n+\tit.buckets = h.buckets\n+\tif t.bucket.kind&kindNoPointers != 0 {\n+\t\t// Allocate the current slice and remember pointers to both current and old.\n+\t\t// This preserves all relevant overflow buckets alive even if\n+\t\t// the table grows and/or overflow buckets are added to the table\n+\t\t// while we are iterating.\n+\t\th.createOverflow()\n+\t\tit.overflow = *h.overflow\n+\t}\n+\n+\t// decide where to start\n+\tr := uintptr(fastrand1())\n+\tif h.B > 31-bucketCntBits {\n+\t\tr += uintptr(fastrand1()) << 31\n+\t}\n+\tit.startBucket = r & (uintptr(1)<<h.B - 1)\n+\tit.offset = uint8(r >> h.B & (bucketCnt - 1))\n+\n+\t// iterator state\n+\tit.bucket = it.startBucket\n+\tit.wrapped = false\n+\tit.bptr = nil\n+\n+\t// Remember we have an iterator.\n+\t// Can run concurrently with another hash_iter_init().\n+\tif old := h.flags; old&(iterator|oldIterator) != iterator|oldIterator {\n+\t\tatomic.Or8(&h.flags, iterator|oldIterator)\n+\t}\n+\n+\tmapiternext(it)\n+}\n+\n+func mapiternext(it *hiter) {\n+\th := it.h\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &it */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapiternext))\n+\t}\n+\tt := it.t\n+\tbucket := it.bucket\n+\tb := it.bptr\n+\ti := it.i\n+\tcheckBucket := it.checkBucket\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\n+next:\n+\tif b == nil {\n+\t\tif bucket == it.startBucket && it.wrapped {\n+\t\t\t// end of iteration\n+\t\t\tit.key = nil\n+\t\t\tit.value = nil\n+\t\t\treturn\n+\t\t}\n+\t\tif h.oldbuckets != nil && it.B == h.B {\n+\t\t\t// Iterator was started in the middle of a grow, and the grow isn't done yet.\n+\t\t\t// If the bucket we're looking at hasn't been filled in yet (i.e. the old\n+\t\t\t// bucket hasn't been evacuated) then we need to iterate through the old\n+\t\t\t// bucket and only return the ones that will be migrated to this bucket.\n+\t\t\toldbucket := bucket & (uintptr(1)<<(it.B-1) - 1)\n+\t\t\tb = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n+\t\t\tif !evacuated(b) {\n+\t\t\t\tcheckBucket = bucket\n+\t\t\t} else {\n+\t\t\t\tb = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\n+\t\t\t\tcheckBucket = noCheck\n+\t\t\t}\n+\t\t} else {\n+\t\t\tb = (*bmap)(add(it.buckets, bucket*uintptr(t.bucketsize)))\n+\t\t\tcheckBucket = noCheck\n+\t\t}\n+\t\tbucket++\n+\t\tif bucket == uintptr(1)<<it.B {\n+\t\t\tbucket = 0\n+\t\t\tit.wrapped = true\n+\t\t}\n+\t\ti = 0\n+\t}\n+\tfor ; i < bucketCnt; i++ {\n+\t\toffi := (i + it.offset) & (bucketCnt - 1)\n+\t\tk := add(unsafe.Pointer(b), dataOffset+uintptr(offi)*uintptr(t.keysize))\n+\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+uintptr(offi)*uintptr(t.valuesize))\n+\t\tif b.tophash[offi] != empty && b.tophash[offi] != evacuatedEmpty {\n+\t\t\tif checkBucket != noCheck {\n+\t\t\t\t// Special case: iterator was started during a grow and the\n+\t\t\t\t// grow is not done yet. We're working on a bucket whose\n+\t\t\t\t// oldbucket has not been evacuated yet. Or at least, it wasn't\n+\t\t\t\t// evacuated when we started the bucket. So we're iterating\n+\t\t\t\t// through the oldbucket, skipping any keys that will go\n+\t\t\t\t// to the other new bucket (each oldbucket expands to two\n+\t\t\t\t// buckets during a grow).\n+\t\t\t\tk2 := k\n+\t\t\t\tif t.indirectkey {\n+\t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n+\t\t\t\t}\n+\t\t\t\tif t.reflexivekey || equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\t\t// If the item in the oldbucket is not destined for\n+\t\t\t\t\t// the current new bucket in the iteration, skip it.\n+\t\t\t\t\thash := hashfn(k2, uintptr(h.hash0), uintptr(t.keysize))\n+\t\t\t\t\tif hash&(uintptr(1)<<it.B-1) != checkBucket {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\t// Hash isn't repeatable if k != k (NaNs).  We need a\n+\t\t\t\t\t// repeatable and randomish choice of which direction\n+\t\t\t\t\t// to send NaNs during evacuation. We'll use the low\n+\t\t\t\t\t// bit of tophash to decide which way NaNs go.\n+\t\t\t\t\t// NOTE: this case is why we need two evacuate tophash\n+\t\t\t\t\t// values, evacuatedX and evacuatedY, that differ in\n+\t\t\t\t\t// their low bit.\n+\t\t\t\t\tif checkBucket>>(it.B-1) != uintptr(b.tophash[offi]&1) {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif b.tophash[offi] != evacuatedX && b.tophash[offi] != evacuatedY {\n+\t\t\t\t// this is the golden data, we can return it.\n+\t\t\t\tif t.indirectkey {\n+\t\t\t\t\tk = *((*unsafe.Pointer)(k))\n+\t\t\t\t}\n+\t\t\t\tit.key = k\n+\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n+\t\t\t\t}\n+\t\t\t\tit.value = v\n+\t\t\t} else {\n+\t\t\t\t// The hash table has grown since the iterator was started.\n+\t\t\t\t// The golden data for this key is now somewhere else.\n+\t\t\t\tk2 := k\n+\t\t\t\tif t.indirectkey {\n+\t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n+\t\t\t\t}\n+\t\t\t\tif t.reflexivekey || equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\t\t// Check the current hash table for the data.\n+\t\t\t\t\t// This code handles the case where the key\n+\t\t\t\t\t// has been deleted, updated, or deleted and reinserted.\n+\t\t\t\t\t// NOTE: we need to regrab the key as it has potentially been\n+\t\t\t\t\t// updated to an equal() but not identical key (e.g. +0.0 vs -0.0).\n+\t\t\t\t\trk, rv := mapaccessK(t, h, k2)\n+\t\t\t\t\tif rk == nil {\n+\t\t\t\t\t\tcontinue // key has been deleted\n+\t\t\t\t\t}\n+\t\t\t\t\tit.key = rk\n+\t\t\t\t\tit.value = rv\n+\t\t\t\t} else {\n+\t\t\t\t\t// if key!=key then the entry can't be deleted or\n+\t\t\t\t\t// updated, so we can just return it. That's lucky for\n+\t\t\t\t\t// us because when key!=key we can't look it up\n+\t\t\t\t\t// successfully in the current table.\n+\t\t\t\t\tit.key = k2\n+\t\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\t\tv = *((*unsafe.Pointer)(v))\n+\t\t\t\t\t}\n+\t\t\t\t\tit.value = v\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tit.bucket = bucket\n+\t\t\tif it.bptr != b { // avoid unnecessary write barrier; see issue 14921\n+\t\t\t\tit.bptr = b\n+\t\t\t}\n+\t\t\tit.i = i + 1\n+\t\t\tit.checkBucket = checkBucket\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tb = b.overflow(t)\n+\ti = 0\n+\tgoto next\n+}\n+\n+func hashGrow(t *maptype, h *hmap) {\n+\tif h.oldbuckets != nil {\n+\t\tthrow(\"evacuation not done in time\")\n+\t}\n+\toldbuckets := h.buckets\n+\tnewbuckets := newarray(t.bucket, 1<<(h.B+1))\n+\tflags := h.flags &^ (iterator | oldIterator)\n+\tif h.flags&iterator != 0 {\n+\t\tflags |= oldIterator\n+\t}\n+\t// commit the grow (atomic wrt gc)\n+\th.B++\n+\th.flags = flags\n+\th.oldbuckets = oldbuckets\n+\th.buckets = newbuckets\n+\th.nevacuate = 0\n+\n+\tif h.overflow != nil {\n+\t\t// Promote current overflow buckets to the old generation.\n+\t\tif h.overflow[1] != nil {\n+\t\t\tthrow(\"overflow is not nil\")\n+\t\t}\n+\t\th.overflow[1] = h.overflow[0]\n+\t\th.overflow[0] = nil\n+\t}\n+\n+\t// the actual copying of the hash table data is done incrementally\n+\t// by growWork() and evacuate().\n+}\n+\n+func growWork(t *maptype, h *hmap, bucket uintptr) {\n+\tnoldbuckets := uintptr(1) << (h.B - 1)\n+\n+\t// make sure we evacuate the oldbucket corresponding\n+\t// to the bucket we're about to use\n+\tevacuate(t, h, bucket&(noldbuckets-1))\n+\n+\t// evacuate one more oldbucket to make progress on growing\n+\tif h.oldbuckets != nil {\n+\t\tevacuate(t, h, h.nevacuate)\n+\t}\n+}\n+\n+func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n+\tb := (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n+\tnewbit := uintptr(1) << (h.B - 1)\n+\thashfn := t.key.hashfn\n+\tequalfn := t.key.equalfn\n+\tif !evacuated(b) {\n+\t\t// TODO: reuse overflow buckets instead of using new ones, if there\n+\t\t// is no iterator using the old buckets.  (If !oldIterator.)\n+\n+\t\tx := (*bmap)(add(h.buckets, oldbucket*uintptr(t.bucketsize)))\n+\t\ty := (*bmap)(add(h.buckets, (oldbucket+newbit)*uintptr(t.bucketsize)))\n+\t\txi := 0\n+\t\tyi := 0\n+\t\txk := add(unsafe.Pointer(x), dataOffset)\n+\t\tyk := add(unsafe.Pointer(y), dataOffset)\n+\t\txv := add(xk, bucketCnt*uintptr(t.keysize))\n+\t\tyv := add(yk, bucketCnt*uintptr(t.keysize))\n+\t\tfor ; b != nil; b = b.overflow(t) {\n+\t\t\tk := add(unsafe.Pointer(b), dataOffset)\n+\t\t\tv := add(k, bucketCnt*uintptr(t.keysize))\n+\t\t\tfor i := 0; i < bucketCnt; i, k, v = i+1, add(k, uintptr(t.keysize)), add(v, uintptr(t.valuesize)) {\n+\t\t\t\ttop := b.tophash[i]\n+\t\t\t\tif top == empty {\n+\t\t\t\t\tb.tophash[i] = evacuatedEmpty\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif top < minTopHash {\n+\t\t\t\t\tthrow(\"bad map state\")\n+\t\t\t\t}\n+\t\t\t\tk2 := k\n+\t\t\t\tif t.indirectkey {\n+\t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n+\t\t\t\t}\n+\t\t\t\t// Compute hash to make our evacuation decision (whether we need\n+\t\t\t\t// to send this key/value to bucket x or bucket y).\n+\t\t\t\thash := hashfn(k2, uintptr(h.hash0), uintptr(t.keysize))\n+\t\t\t\tif h.flags&iterator != 0 {\n+\t\t\t\t\tif !t.reflexivekey && !equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\t\t\t// If key != key (NaNs), then the hash could be (and probably\n+\t\t\t\t\t\t// will be) entirely different from the old hash. Moreover,\n+\t\t\t\t\t\t// it isn't reproducible. Reproducibility is required in the\n+\t\t\t\t\t\t// presence of iterators, as our evacuation decision must\n+\t\t\t\t\t\t// match whatever decision the iterator made.\n+\t\t\t\t\t\t// Fortunately, we have the freedom to send these keys either\n+\t\t\t\t\t\t// way. Also, tophash is meaningless for these kinds of keys.\n+\t\t\t\t\t\t// We let the low bit of tophash drive the evacuation decision.\n+\t\t\t\t\t\t// We recompute a new random tophash for the next level so\n+\t\t\t\t\t\t// these keys will get evenly distributed across all buckets\n+\t\t\t\t\t\t// after multiple grows.\n+\t\t\t\t\t\tif (top & 1) != 0 {\n+\t\t\t\t\t\t\thash |= newbit\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\thash &^= newbit\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\ttop = uint8(hash >> (sys.PtrSize*8 - 8))\n+\t\t\t\t\t\tif top < minTopHash {\n+\t\t\t\t\t\t\ttop += minTopHash\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif (hash & newbit) == 0 {\n+\t\t\t\t\tb.tophash[i] = evacuatedX\n+\t\t\t\t\tif xi == bucketCnt {\n+\t\t\t\t\t\tnewx := (*bmap)(newobject(t.bucket))\n+\t\t\t\t\t\th.setoverflow(t, x, newx)\n+\t\t\t\t\t\tx = newx\n+\t\t\t\t\t\txi = 0\n+\t\t\t\t\t\txk = add(unsafe.Pointer(x), dataOffset)\n+\t\t\t\t\t\txv = add(xk, bucketCnt*uintptr(t.keysize))\n+\t\t\t\t\t}\n+\t\t\t\t\tx.tophash[xi] = top\n+\t\t\t\t\tif t.indirectkey {\n+\t\t\t\t\t\t*(*unsafe.Pointer)(xk) = k2 // copy pointer\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttypedmemmove(t.key, xk, k) // copy value\n+\t\t\t\t\t}\n+\t\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\t\t*(*unsafe.Pointer)(xv) = *(*unsafe.Pointer)(v)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttypedmemmove(t.elem, xv, v)\n+\t\t\t\t\t}\n+\t\t\t\t\txi++\n+\t\t\t\t\txk = add(xk, uintptr(t.keysize))\n+\t\t\t\t\txv = add(xv, uintptr(t.valuesize))\n+\t\t\t\t} else {\n+\t\t\t\t\tb.tophash[i] = evacuatedY\n+\t\t\t\t\tif yi == bucketCnt {\n+\t\t\t\t\t\tnewy := (*bmap)(newobject(t.bucket))\n+\t\t\t\t\t\th.setoverflow(t, y, newy)\n+\t\t\t\t\t\ty = newy\n+\t\t\t\t\t\tyi = 0\n+\t\t\t\t\t\tyk = add(unsafe.Pointer(y), dataOffset)\n+\t\t\t\t\t\tyv = add(yk, bucketCnt*uintptr(t.keysize))\n+\t\t\t\t\t}\n+\t\t\t\t\ty.tophash[yi] = top\n+\t\t\t\t\tif t.indirectkey {\n+\t\t\t\t\t\t*(*unsafe.Pointer)(yk) = k2\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttypedmemmove(t.key, yk, k)\n+\t\t\t\t\t}\n+\t\t\t\t\tif t.indirectvalue {\n+\t\t\t\t\t\t*(*unsafe.Pointer)(yv) = *(*unsafe.Pointer)(v)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\ttypedmemmove(t.elem, yv, v)\n+\t\t\t\t\t}\n+\t\t\t\t\tyi++\n+\t\t\t\t\tyk = add(yk, uintptr(t.keysize))\n+\t\t\t\t\tyv = add(yv, uintptr(t.valuesize))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\t// Unlink the overflow buckets & clear key/value to help GC.\n+\t\tif h.flags&oldIterator == 0 {\n+\t\t\tb = (*bmap)(add(h.oldbuckets, oldbucket*uintptr(t.bucketsize)))\n+\t\t\tmemclr(add(unsafe.Pointer(b), dataOffset), uintptr(t.bucketsize)-dataOffset)\n+\t\t}\n+\t}\n+\n+\t// Advance evacuation mark\n+\tif oldbucket == h.nevacuate {\n+\t\th.nevacuate = oldbucket + 1\n+\t\tif oldbucket+1 == newbit { // newbit == # of oldbuckets\n+\t\t\t// Growing is all done. Free old main bucket array.\n+\t\t\th.oldbuckets = nil\n+\t\t\t// Can discard old overflow buckets as well.\n+\t\t\t// If they are still referenced by an iterator,\n+\t\t\t// then the iterator holds a pointers to the slice.\n+\t\t\tif h.overflow != nil {\n+\t\t\t\th.overflow[1] = nil\n+\t\t\t}\n+\t\t}\n+\t}\n+}\n+\n+func ismapkey(t *_type) bool {\n+\treturn t.hashfn != nil\n+}\n+\n+// Reflect stubs. Called from ../reflect/asm_*.s\n+\n+//go:linkname reflect_makemap reflect.makemap\n+func reflect_makemap(t *maptype) *hmap {\n+\treturn makemap(t, 0, nil, nil)\n+}\n+\n+//go:linkname reflect_mapaccess reflect.mapaccess\n+func reflect_mapaccess(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n+\tval, ok := mapaccess2(t, h, key)\n+\tif !ok {\n+\t\t// reflect wants nil for a missing element\n+\t\tval = nil\n+\t}\n+\treturn val\n+}\n+\n+//go:linkname reflect_mapassign reflect.mapassign\n+func reflect_mapassign(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer) {\n+\tmapassign1(t, h, key, val)\n+}\n+\n+//go:linkname reflect_mapdelete reflect.mapdelete\n+func reflect_mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n+\tmapdelete(t, h, key)\n+}\n+\n+//go:linkname reflect_mapiterinit reflect.mapiterinit\n+func reflect_mapiterinit(t *maptype, h *hmap) *hiter {\n+\tit := new(hiter)\n+\tmapiterinit(t, h, it)\n+\treturn it\n+}\n+\n+//go:linkname reflect_mapiternext reflect.mapiternext\n+func reflect_mapiternext(it *hiter) {\n+\tmapiternext(it)\n+}\n+\n+//go:linkname reflect_mapiterkey reflect.mapiterkey\n+func reflect_mapiterkey(it *hiter) unsafe.Pointer {\n+\treturn it.key\n+}\n+\n+//go:linkname reflect_maplen reflect.maplen\n+func reflect_maplen(h *hmap) int {\n+\tif h == nil {\n+\t\treturn 0\n+\t}\n+\tif raceenabled {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &h */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(reflect_maplen))\n+\t}\n+\treturn h.count\n+}\n+\n+//go:linkname reflect_ismapkey reflect.ismapkey\n+func reflect_ismapkey(t *_type) bool {\n+\treturn ismapkey(t)\n+}\n+\n+const maxZero = 1024 // must match value in ../cmd/compile/internal/gc/walk.go\n+var zeroVal [maxZero]byte"}, {"sha": "4850b168f1c8a8155a87391f24847b4c630e55c1", "filename": "libgo/go/runtime/hashmap_fast.go", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,398 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess1_fast32))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tvar b *bmap\n+\tif h.B == 0 {\n+\t\t// One-bucket table. No need to hash.\n+\t\tb = (*bmap)(h.buckets)\n+\t} else {\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\tm := uintptr(1)<<h.B - 1\n+\t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\t\tif c := h.oldbuckets; c != nil {\n+\t\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\t\tif !evacuated(oldb) {\n+\t\t\t\tb = oldb\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tk := *((*uint32)(add(unsafe.Pointer(b), dataOffset+i*4)))\n+\t\t\tif k != key {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize))\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess2_fast32))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tvar b *bmap\n+\tif h.B == 0 {\n+\t\t// One-bucket table. No need to hash.\n+\t\tb = (*bmap)(h.buckets)\n+\t} else {\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\tm := uintptr(1)<<h.B - 1\n+\t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\t\tif c := h.oldbuckets; c != nil {\n+\t\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\t\tif !evacuated(oldb) {\n+\t\t\t\tb = oldb\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tk := *((*uint32)(add(unsafe.Pointer(b), dataOffset+i*4)))\n+\t\t\tif k != key {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*4+i*uintptr(t.valuesize)), true\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess1_fast64))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tvar b *bmap\n+\tif h.B == 0 {\n+\t\t// One-bucket table. No need to hash.\n+\t\tb = (*bmap)(h.buckets)\n+\t} else {\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\tm := uintptr(1)<<h.B - 1\n+\t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\t\tif c := h.oldbuckets; c != nil {\n+\t\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\t\tif !evacuated(oldb) {\n+\t\t\t\tb = oldb\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tk := *((*uint64)(add(unsafe.Pointer(b), dataOffset+i*8)))\n+\t\t\tif k != key {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*8+i*uintptr(t.valuesize))\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess2_fast64))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tvar b *bmap\n+\tif h.B == 0 {\n+\t\t// One-bucket table. No need to hash.\n+\t\tb = (*bmap)(h.buckets)\n+\t} else {\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\tm := uintptr(1)<<h.B - 1\n+\t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\t\tif c := h.oldbuckets; c != nil {\n+\t\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\t\tif !evacuated(oldb) {\n+\t\t\t\tb = oldb\n+\t\t\t}\n+\t\t}\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tk := *((*uint64)(add(unsafe.Pointer(b), dataOffset+i*8)))\n+\t\t\tif k != key {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*8+i*uintptr(t.valuesize)), true\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess1_faststr))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tkey := stringStructOf(&ky)\n+\tif h.B == 0 {\n+\t\t// One-bucket table.\n+\t\tb := (*bmap)(h.buckets)\n+\t\tif key.len < 32 {\n+\t\t\t// short key, doing lots of comparisons is ok\n+\t\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\t\tif x == empty {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\t\tif k.len != key.len {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif k.str == key.str || memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize))\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t\t}\n+\t\t// long key, try not to do more comparisons than necessary\n+\t\tkeymaybe := uintptr(bucketCnt)\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\tif k.len != key.len {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k.str == key.str {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize))\n+\t\t\t}\n+\t\t\t// check first 4 bytes\n+\t\t\t// TODO: on amd64/386 at least, make this compile to one 4-byte comparison instead of\n+\t\t\t// four 1-byte comparisons.\n+\t\t\tif *((*[4]byte)(key.str)) != *((*[4]byte)(k.str)) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// check last 4 bytes\n+\t\t\tif *((*[4]byte)(add(key.str, uintptr(key.len)-4))) != *((*[4]byte)(add(k.str, uintptr(key.len)-4))) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif keymaybe != bucketCnt {\n+\t\t\t\t// Two keys are potential matches. Use hash to distinguish them.\n+\t\t\t\tgoto dohash\n+\t\t\t}\n+\t\t\tkeymaybe = i\n+\t\t}\n+\t\tif keymaybe != bucketCnt {\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+keymaybe*2*sys.PtrSize))\n+\t\t\tif memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+keymaybe*uintptr(t.valuesize))\n+\t\t\t}\n+\t\t}\n+\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t}\n+dohash:\n+\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0), uintptr(t.keysize))\n+\tm := uintptr(1)<<h.B - 1\n+\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\tif c := h.oldbuckets; c != nil {\n+\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\tif !evacuated(oldb) {\n+\t\t\tb = oldb\n+\t\t}\n+\t}\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\tif k.len != key.len {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k.str == key.str || memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize))\n+\t\t\t}\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0])\n+\t\t}\n+\t}\n+}\n+\n+func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) {\n+\tif raceenabled && h != nil {\n+\t\tcallerpc := getcallerpc(unsafe.Pointer( /* &t */ nil))\n+\t\tracereadpc(unsafe.Pointer(h), callerpc, funcPC(mapaccess2_faststr))\n+\t}\n+\tif h == nil || h.count == 0 {\n+\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t}\n+\tif h.flags&hashWriting != 0 {\n+\t\tthrow(\"concurrent map read and map write\")\n+\t}\n+\tkey := stringStructOf(&ky)\n+\tif h.B == 0 {\n+\t\t// One-bucket table.\n+\t\tb := (*bmap)(h.buckets)\n+\t\tif key.len < 32 {\n+\t\t\t// short key, doing lots of comparisons is ok\n+\t\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\t\tif x == empty {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\t\tif k.len != key.len {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tif k.str == key.str || memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)), true\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t\t}\n+\t\t// long key, try not to do more comparisons than necessary\n+\t\tkeymaybe := uintptr(bucketCnt)\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x == empty {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\tif k.len != key.len {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k.str == key.str {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)), true\n+\t\t\t}\n+\t\t\t// check first 4 bytes\n+\t\t\tif *((*[4]byte)(key.str)) != *((*[4]byte)(k.str)) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\t// check last 4 bytes\n+\t\t\tif *((*[4]byte)(add(key.str, uintptr(key.len)-4))) != *((*[4]byte)(add(k.str, uintptr(key.len)-4))) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif keymaybe != bucketCnt {\n+\t\t\t\t// Two keys are potential matches. Use hash to distinguish them.\n+\t\t\t\tgoto dohash\n+\t\t\t}\n+\t\t\tkeymaybe = i\n+\t\t}\n+\t\tif keymaybe != bucketCnt {\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+keymaybe*2*sys.PtrSize))\n+\t\t\tif memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+keymaybe*uintptr(t.valuesize)), true\n+\t\t\t}\n+\t\t}\n+\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t}\n+dohash:\n+\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0), uintptr(t.keysize))\n+\tm := uintptr(1)<<h.B - 1\n+\tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n+\tif c := h.oldbuckets; c != nil {\n+\t\toldb := (*bmap)(add(c, (hash&(m>>1))*uintptr(t.bucketsize)))\n+\t\tif !evacuated(oldb) {\n+\t\t\tb = oldb\n+\t\t}\n+\t}\n+\ttop := uint8(hash >> (sys.PtrSize*8 - 8))\n+\tif top < minTopHash {\n+\t\ttop += minTopHash\n+\t}\n+\tfor {\n+\t\tfor i := uintptr(0); i < bucketCnt; i++ {\n+\t\t\tx := *((*uint8)(add(unsafe.Pointer(b), i))) // b.topbits[i] without the bounds check\n+\t\t\tif x != top {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tk := (*stringStruct)(add(unsafe.Pointer(b), dataOffset+i*2*sys.PtrSize))\n+\t\t\tif k.len != key.len {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif k.str == key.str || memequal(k.str, key.str, uintptr(key.len)) {\n+\t\t\t\treturn add(unsafe.Pointer(b), dataOffset+bucketCnt*2*sys.PtrSize+i*uintptr(t.valuesize)), true\n+\t\t\t}\n+\t\t}\n+\t\tb = b.overflow(t)\n+\t\tif b == nil {\n+\t\t\treturn unsafe.Pointer(&zeroVal[0]), false\n+\t\t}\n+\t}\n+}"}, {"sha": "77affdfda12010e9a2cc8f37eeed3ffebbb74c0f", "filename": "libgo/go/runtime/map_test.go", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fmap_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fmap_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmap_test.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -30,13 +30,11 @@ func TestNegativeZero(t *testing.T) {\n \t\tt.Error(\"length wrong\")\n \t}\n \n-\t/* gccgo fails this test; this is not required by the spec.\n \tfor k := range m {\n \t\tif math.Copysign(1.0, k) > 0 {\n \t\t\tt.Error(\"wrong sign\")\n \t\t}\n \t}\n-\t*/\n \n \tm = make(map[float64]bool, 0)\n \tm[math.Copysign(0.0, -1.0)] = true\n@@ -46,13 +44,11 @@ func TestNegativeZero(t *testing.T) {\n \t\tt.Error(\"length wrong\")\n \t}\n \n-\t/* gccgo fails this test; this is not required by the spec.\n \tfor k := range m {\n \t\tif math.Copysign(1.0, k) < 0 {\n \t\t\tt.Error(\"wrong sign\")\n \t\t}\n \t}\n-\t*/\n }\n \n // nan is a good test because nan != nan, and nan has\n@@ -93,7 +89,6 @@ func TestAlias(t *testing.T) {\n }\n \n func TestGrowWithNaN(t *testing.T) {\n-\tt.Skip(\"fails with gccgo\")\n \tm := make(map[float64]int, 4)\n \tnan := math.NaN()\n \tm[nan] = 1\n@@ -115,7 +110,6 @@ func TestGrowWithNaN(t *testing.T) {\n \t\t\ts |= v\n \t\t}\n \t}\n-\tt.Log(\"cnt:\", cnt, \"s:\", s)\n \tif cnt != 3 {\n \t\tt.Error(\"NaN keys lost during grow\")\n \t}\n@@ -130,7 +124,6 @@ type FloatInt struct {\n }\n \n func TestGrowWithNegativeZero(t *testing.T) {\n-\tt.Skip(\"fails with gccgo\")\n \tnegzero := math.Copysign(0.0, -1.0)\n \tm := make(map[FloatInt]int, 4)\n \tm[FloatInt{0.0, 0}] = 1\n@@ -407,7 +400,7 @@ func TestMapNanGrowIterator(t *testing.T) {\n \tnan := math.NaN()\n \tconst nBuckets = 16\n \t// To fill nBuckets buckets takes LOAD * nBuckets keys.\n-\tnKeys := int(nBuckets * /* *runtime.HashLoad */ 6.5)\n+\tnKeys := int(nBuckets * *runtime.HashLoad)\n \n \t// Get map to full point with nan keys.\n \tfor i := 0; i < nKeys; i++ {\n@@ -439,10 +432,6 @@ func TestMapNanGrowIterator(t *testing.T) {\n }\n \n func TestMapIterOrder(t *testing.T) {\n-\tif runtime.Compiler == \"gccgo\" {\n-\t\tt.Skip(\"skipping for gccgo\")\n-\t}\n-\n \tfor _, n := range [...]int{3, 7, 9, 15} {\n \t\tfor i := 0; i < 1000; i++ {\n \t\t\t// Make m be {0: true, 1: true, ..., n-1: true}.\n@@ -478,9 +467,6 @@ func TestMapIterOrder(t *testing.T) {\n func TestMapSparseIterOrder(t *testing.T) {\n \t// Run several rounds to increase the probability\n \t// of failure. One is not enough.\n-\tif runtime.Compiler == \"gccgo\" {\n-\t\tt.Skip(\"skipping for gccgo\")\n-\t}\n NextRound:\n \tfor round := 0; round < 10; round++ {\n \t\tm := make(map[int]bool)\n@@ -514,9 +500,6 @@ NextRound:\n }\n \n func TestMapStringBytesLookup(t *testing.T) {\n-\tif runtime.Compiler == \"gccgo\" {\n-\t\tt.Skip(\"skipping for gccgo\")\n-\t}\n \t// Use large string keys to avoid small-allocation coalescing,\n \t// which can cause AllocsPerRun to report lower counts than it should.\n \tm := map[string]int{\n@@ -532,6 +515,8 @@ func TestMapStringBytesLookup(t *testing.T) {\n \t\tt.Errorf(`m[string([]byte(\"2\"))] = %d, want 2`, x)\n \t}\n \n+\tt.Skip(\"does not work on gccgo without better escape analysis\")\n+\n \tvar x int\n \tn := testing.AllocsPerRun(100, func() {\n \t\tx += m[string(buf)]"}, {"sha": "117c5e5789cb51e9224a58ec14bebbebb86bbe15", "filename": "libgo/go/runtime/msan0.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fmsan0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fmsan0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmsan0.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -2,7 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build ignore\n // +build !msan\n \n // Dummy MSan support API, used when not built with -msan."}, {"sha": "f1d3706231779887e50d83400fed2ce2c47872cb", "filename": "libgo/go/runtime/race0.go", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Frace0.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Frace0.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Frace0.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build !race\n+\n+// Dummy race detection API, used when not built with -race.\n+\n+package runtime\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+const raceenabled = false\n+\n+// Because raceenabled is false, none of these functions should be called.\n+\n+func raceReadObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr)  { throw(\"race\") }\n+func raceWriteObjectPC(t *_type, addr unsafe.Pointer, callerpc, pc uintptr) { throw(\"race\") }\n+func raceinit() (uintptr, uintptr)                                          { throw(\"race\"); return 0, 0 }\n+func racefini()                                                             { throw(\"race\") }\n+func raceproccreate() uintptr                                               { throw(\"race\"); return 0 }\n+func raceprocdestroy(ctx uintptr)                                           { throw(\"race\") }\n+func racemapshadow(addr unsafe.Pointer, size uintptr)                       { throw(\"race\") }\n+func racewritepc(addr unsafe.Pointer, callerpc, pc uintptr)                 { throw(\"race\") }\n+func racereadpc(addr unsafe.Pointer, callerpc, pc uintptr)                  { throw(\"race\") }\n+func racereadrangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)         { throw(\"race\") }\n+func racewriterangepc(addr unsafe.Pointer, sz, callerpc, pc uintptr)        { throw(\"race\") }\n+func raceacquire(addr unsafe.Pointer)                                       { throw(\"race\") }\n+func raceacquireg(gp *g, addr unsafe.Pointer)                               { throw(\"race\") }\n+func racerelease(addr unsafe.Pointer)                                       { throw(\"race\") }\n+func racereleaseg(gp *g, addr unsafe.Pointer)                               { throw(\"race\") }\n+func racereleasemerge(addr unsafe.Pointer)                                  { throw(\"race\") }\n+func racereleasemergeg(gp *g, addr unsafe.Pointer)                          { throw(\"race\") }\n+func racefingo()                                                            { throw(\"race\") }\n+func racemalloc(p unsafe.Pointer, sz uintptr)                               { throw(\"race\") }\n+func racefree(p unsafe.Pointer, sz uintptr)                                 { throw(\"race\") }\n+func racegostart(pc uintptr) uintptr                                        { throw(\"race\"); return 0 }\n+func racegoend()                                                            { throw(\"race\") }"}, {"sha": "48abbfa889fcbe0858f95854c72c781a33ceab63", "filename": "libgo/go/runtime/stubs.go", "status": "added", "additions": 253, "deletions": 0, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fstubs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Fstubs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fstubs.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,253 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import (\n+\t\"runtime/internal/sys\"\n+\t\"unsafe\"\n+)\n+\n+// Should be a built-in for unsafe.Pointer?\n+//go:nosplit\n+func add(p unsafe.Pointer, x uintptr) unsafe.Pointer {\n+\treturn unsafe.Pointer(uintptr(p) + x)\n+}\n+\n+// getg returns the pointer to the current g.\n+// The compiler rewrites calls to this function into instructions\n+// that fetch the g directly (from TLS or from the dedicated register).\n+func getg() *g\n+\n+// mcall switches from the g to the g0 stack and invokes fn(g),\n+// where g is the goroutine that made the call.\n+// mcall saves g's current PC/SP in g->sched so that it can be restored later.\n+// It is up to fn to arrange for that later execution, typically by recording\n+// g in a data structure, causing something to call ready(g) later.\n+// mcall returns to the original goroutine g later, when g has been rescheduled.\n+// fn must not return at all; typically it ends by calling schedule, to let the m\n+// run other goroutines.\n+//\n+// mcall can only be called from g stacks (not g0, not gsignal).\n+//\n+// This must NOT be go:noescape: if fn is a stack-allocated closure,\n+// fn puts g on a run queue, and g executes before fn returns, the\n+// closure will be invalidated while it is still executing.\n+func mcall(fn func(*g))\n+\n+// systemstack runs fn on a system stack.\n+// If systemstack is called from the per-OS-thread (g0) stack, or\n+// if systemstack is called from the signal handling (gsignal) stack,\n+// systemstack calls fn directly and returns.\n+// Otherwise, systemstack is being called from the limited stack\n+// of an ordinary goroutine. In this case, systemstack switches\n+// to the per-OS-thread stack, calls fn, and switches back.\n+// It is common to use a func literal as the argument, in order\n+// to share inputs and outputs with the code around the call\n+// to system stack:\n+//\n+//\t... set up y ...\n+//\tsystemstack(func() {\n+//\t\tx = bigcall(y)\n+//\t})\n+//\t... use x ...\n+//\n+//go:noescape\n+func systemstack(fn func())\n+\n+func badsystemstack() {\n+\tthrow(\"systemstack called from unexpected goroutine\")\n+}\n+\n+// memclr clears n bytes starting at ptr.\n+// in memclr_*.s\n+//go:noescape\n+func memclr(ptr unsafe.Pointer, n uintptr)\n+\n+//go:linkname reflect_memclr reflect.memclr\n+func reflect_memclr(ptr unsafe.Pointer, n uintptr) {\n+\tmemclr(ptr, n)\n+}\n+\n+// memmove copies n bytes from \"from\" to \"to\".\n+// in memmove_*.s\n+//go:noescape\n+func memmove(to, from unsafe.Pointer, n uintptr)\n+\n+//go:linkname reflect_memmove reflect.memmove\n+func reflect_memmove(to, from unsafe.Pointer, n uintptr) {\n+\tmemmove(to, from, n)\n+}\n+\n+// exported value for testing\n+var hashLoad = loadFactor\n+\n+// in asm_*.s\n+func fastrand1() uint32\n+\n+// in asm_*.s\n+//go:noescape\n+func memequal(a, b unsafe.Pointer, size uintptr) bool\n+\n+// noescape hides a pointer from escape analysis.  noescape is\n+// the identity function but escape analysis doesn't think the\n+// output depends on the input.  noescape is inlined and currently\n+// compiles down to a single xor instruction.\n+// USE CAREFULLY!\n+//go:nosplit\n+func noescape(p unsafe.Pointer) unsafe.Pointer {\n+\tx := uintptr(p)\n+\treturn unsafe.Pointer(x ^ 0)\n+}\n+\n+func mincore(addr unsafe.Pointer, n uintptr, dst *byte) int32\n+\n+//go:noescape\n+func jmpdefer(fv *funcval, argp uintptr)\n+func exit1(code int32)\n+func asminit()\n+func setg(gg *g)\n+func breakpoint()\n+\n+// reflectcall calls fn with a copy of the n argument bytes pointed at by arg.\n+// After fn returns, reflectcall copies n-retoffset result bytes\n+// back into arg+retoffset before returning. If copying result bytes back,\n+// the caller should pass the argument frame type as argtype, so that\n+// call can execute appropriate write barriers during the copy.\n+// Package reflect passes a frame type. In package runtime, there is only\n+// one call that copies results back, in cgocallbackg1, and it does NOT pass a\n+// frame type, meaning there are no write barriers invoked. See that call\n+// site for justification.\n+func reflectcall(argtype *_type, fn, arg unsafe.Pointer, argsize uint32, retoffset uint32)\n+\n+func procyield(cycles uint32)\n+\n+type neverCallThisFunction struct{}\n+\n+// goexit is the return stub at the top of every goroutine call stack.\n+// Each goroutine stack is constructed as if goexit called the\n+// goroutine's entry point function, so that when the entry point\n+// function returns, it will return to goexit, which will call goexit1\n+// to perform the actual exit.\n+//\n+// This function must never be called directly. Call goexit1 instead.\n+// gentraceback assumes that goexit terminates the stack. A direct\n+// call on the stack will cause gentraceback to stop walking the stack\n+// prematurely and if there are leftover stack barriers it may panic.\n+func goexit(neverCallThisFunction)\n+\n+// publicationBarrier performs a store/store barrier (a \"publication\"\n+// or \"export\" barrier). Some form of synchronization is required\n+// between initializing an object and making that object accessible to\n+// another processor. Without synchronization, the initialization\n+// writes and the \"publication\" write may be reordered, allowing the\n+// other processor to follow the pointer and observe an uninitialized\n+// object. In general, higher-level synchronization should be used,\n+// such as locking or an atomic pointer write. publicationBarrier is\n+// for when those aren't an option, such as in the implementation of\n+// the memory manager.\n+//\n+// There's no corresponding barrier for the read side because the read\n+// side naturally has a data dependency order. All architectures that\n+// Go supports or seems likely to ever support automatically enforce\n+// data dependency ordering.\n+func publicationBarrier()\n+\n+//go:noescape\n+func setcallerpc(argp unsafe.Pointer, pc uintptr)\n+\n+// getcallerpc returns the program counter (PC) of its caller's caller.\n+// getcallersp returns the stack pointer (SP) of its caller's caller.\n+// For both, the argp must be a pointer to the caller's first function argument.\n+// The implementation may or may not use argp, depending on\n+// the architecture.\n+//\n+// For example:\n+//\n+//\tfunc f(arg1, arg2, arg3 int) {\n+//\t\tpc := getcallerpc(unsafe.Pointer(&arg1))\n+//\t\tsp := getcallersp(unsafe.Pointer(&arg1))\n+//\t}\n+//\n+// These two lines find the PC and SP immediately following\n+// the call to f (where f will return).\n+//\n+// The call to getcallerpc and getcallersp must be done in the\n+// frame being asked about. It would not be correct for f to pass &arg1\n+// to another function g and let g call getcallerpc/getcallersp.\n+// The call inside g might return information about g's caller or\n+// information about f's caller or complete garbage.\n+//\n+// The result of getcallersp is correct at the time of the return,\n+// but it may be invalidated by any subsequent call to a function\n+// that might relocate the stack in order to grow or shrink it.\n+// A general rule is that the result of getcallersp should be used\n+// immediately and can only be passed to nosplit functions.\n+\n+//go:noescape\n+func getcallerpc(argp unsafe.Pointer) uintptr\n+\n+//go:noescape\n+func getcallersp(argp unsafe.Pointer) uintptr\n+\n+// argp used in Defer structs when there is no argp.\n+const _NoArgs = ^uintptr(0)\n+\n+// //go:linkname time_now time.now\n+// func time_now() (sec int64, nsec int32)\n+\n+/*\n+func unixnanotime() int64 {\n+\tsec, nsec := time_now()\n+\treturn sec*1e9 + int64(nsec)\n+}\n+*/\n+\n+// round n up to a multiple of a.  a must be a power of 2.\n+func round(n, a uintptr) uintptr {\n+\treturn (n + a - 1) &^ (a - 1)\n+}\n+\n+/*\n+// checkASM returns whether assembly runtime checks have passed.\n+func checkASM() bool\n+*/\n+\n+// throw crashes the program.\n+// For gccgo unless and until we port panic.go.\n+func throw(string)\n+\n+// newobject allocates a new object.\n+// For gccgo unless and until we port malloc.go.\n+func newobject(*_type) unsafe.Pointer\n+\n+// newarray allocates a new array of objects.\n+// For gccgo unless and until we port malloc.go.\n+func newarray(*_type, int) unsafe.Pointer\n+\n+// funcPC returns the entry PC of the function f.\n+// It assumes that f is a func value. Otherwise the behavior is undefined.\n+// For gccgo here unless and until we port proc.go.\n+//go:nosplit\n+func funcPC(f interface{}) uintptr {\n+\treturn **(**uintptr)(add(unsafe.Pointer(&f), sys.PtrSize))\n+}\n+\n+// typedmemmove copies a typed value.\n+// For gccgo for now.\n+//go:nosplit\n+func typedmemmove(typ *_type, dst, src unsafe.Pointer) {\n+\tmemmove(dst, src, typ.size)\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+type stringStruct struct {\n+\tstr unsafe.Pointer\n+\tlen int\n+}\n+\n+// Here for gccgo unless and until we port string.go.\n+func stringStructOf(sp *string) *stringStruct {\n+\treturn (*stringStruct)(unsafe.Pointer(sp))\n+}"}, {"sha": "d9b0b5590d2bf579a63fb2037a8d5724b305314b", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -16,12 +16,12 @@ type _type struct {\n \tsize       uintptr\n \thash       uint32\n \n-\thashfn  func(unsafe.Pointer, uintptr) uintptr\n+\thashfn  func(unsafe.Pointer, uintptr, uintptr) uintptr\n \tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool\n \n \tgc     unsafe.Pointer\n \tstring *string\n-\t*uncommonType\n+\t*uncommontype\n \tptrToThis *_type\n }\n \n@@ -33,7 +33,7 @@ type method struct {\n \ttfn     unsafe.Pointer\n }\n \n-type uncommonType struct {\n+type uncommontype struct {\n \tname    *string\n \tpkgPath *string\n \tmethods []method\n@@ -45,25 +45,34 @@ type imethod struct {\n \ttyp     *_type\n }\n \n-type interfaceType struct {\n+type interfacetype struct {\n \ttyp     _type\n \tmethods []imethod\n }\n \n-type mapType struct {\n-\ttyp  _type\n-\tkey  *_type\n-\telem *_type\n+type maptype struct {\n+\ttyp           _type\n+\tkey           *_type\n+\telem          *_type\n+\tbucket        *_type // internal type representing a hash bucket\n+\thmap          *_type // internal type representing a hmap\n+\tkeysize       uint8  // size of key slot\n+\tindirectkey   bool   // store ptr to key instead of key itself\n+\tvaluesize     uint8  // size of value slot\n+\tindirectvalue bool   // store ptr to value instead of value itself\n+\tbucketsize    uint16 // size of bucket\n+\treflexivekey  bool   // true if k==k for all keys\n+\tneedkeyupdate bool   // true if we need to update key on an overwrite\n }\n \n-type arrayType struct {\n+type arraytype struct {\n \ttyp   _type\n \telem  *_type\n \tslice *_type\n \tlen   uintptr\n }\n \n-type chanType struct {\n+type chantype struct {\n \ttyp  _type\n \telem *_type\n \tdir  uintptr"}, {"sha": "abb27777fe9a601911c3c8cc3d91720dd0263bc1", "filename": "libgo/go/runtime/typekind.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Ftypekind.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fgo%2Fruntime%2Ftypekind.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftypekind.go?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2014 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+const (\n+\tkindBool = 1 + iota\n+\tkindInt\n+\tkindInt8\n+\tkindInt16\n+\tkindInt32\n+\tkindInt64\n+\tkindUint\n+\tkindUint8\n+\tkindUint16\n+\tkindUint32\n+\tkindUint64\n+\tkindUintptr\n+\tkindFloat32\n+\tkindFloat64\n+\tkindComplex64\n+\tkindComplex128\n+\tkindArray\n+\tkindChan\n+\tkindFunc\n+\tkindInterface\n+\tkindMap\n+\tkindPtr\n+\tkindSlice\n+\tkindString\n+\tkindStruct\n+\tkindUnsafePointer\n+\n+\tkindDirectIface = 1 << 5\n+\tkindGCProg      = 1 << 6\n+\tkindNoPointers  = 1 << 7\n+\tkindMask        = (1 << 5) - 1\n+)\n+\n+// isDirectIface reports whether t is stored directly in an interface value.\n+func isDirectIface(t *_type) bool {\n+\treturn t.kind&kindDirectIface != 0\n+}"}, {"sha": "6e4c8fd89203fe85b2a11c5c8211de99e0ab48b7", "filename": "libgo/runtime/chan.goc", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fchan.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fchan.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchan.goc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -1064,12 +1064,6 @@ func reflect.chanlen(c *Hchan) (len int) {\n \t\tlen = c->qcount;\n }\n \n-intgo\n-__go_chan_len(Hchan *c)\n-{\n-\treturn reflect_chanlen(c);\n-}\n-\n func reflect.chancap(c *Hchan) (cap int) {\n \tif(c == nil)\n \t\tcap = 0;"}, {"sha": "c1a8bb72efac157a2c0095be18c57ac717d27a9c", "filename": "libgo/runtime/go-construct-map.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-construct-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-construct-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-construct-map.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -9,25 +9,30 @@\n #include <stdlib.h>\n \n #include \"runtime.h\"\n-#include \"map.h\"\n \n-struct __go_map *\n-__go_construct_map (const struct __go_map_descriptor *descriptor,\n+extern void *makemap (const struct __go_map_type *, int64_t hint,\n+\t\t      void *, void *)\n+  __asm__ (GOSYM_PREFIX \"runtime.makemap\");\n+\n+extern void mapassign1 (const struct __go_map_type *, void *hmap,\n+\t\t\tconst void *key, const void *val)\n+  __asm__ (GOSYM_PREFIX \"runtime.mapassign1\");\n+\n+void *\n+__go_construct_map (const struct __go_map_type *type,\n \t\t    uintptr_t count, uintptr_t entry_size,\n-\t\t    uintptr_t val_offset, uintptr_t val_size,\n-\t\t    const void *ventries)\n+\t\t    uintptr_t val_offset, const void *ventries)\n {\n-  struct __go_map *ret;\n+  void *ret;\n   const unsigned char *entries;\n   uintptr_t i;\n \n-  ret = __go_new_map (descriptor, count);\n+  ret = makemap(type, (int64_t) count, NULL, NULL);\n \n   entries = (const unsigned char *) ventries;\n   for (i = 0; i < count; ++i)\n     {\n-      void *val = __go_map_index (ret, entries, 1);\n-      __builtin_memcpy (val, entries + val_offset, val_size);\n+      mapassign1 (type, ret, entries, entries + val_offset);\n       entries += entry_size;\n     }\n "}, {"sha": "62302b5ebe2c45400e0da6dfe28976dabf9e047e", "filename": "libgo/runtime/go-eface-compare.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-eface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-eface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-eface-compare.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -26,6 +26,8 @@ __go_empty_interface_compare (struct __go_empty_interface left,\n   if (!__go_type_descriptors_equal (left_descriptor,\n \t\t\t\t    right.__type_descriptor))\n     return 1;\n+  if (left_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (left_descriptor))\n     return left.__object == right.__object ? 0 : 1;\n   if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,"}, {"sha": "839d18916231441baddafb8dddb956d60d2a995a", "filename": "libgo/runtime/go-eface-val-compare.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-eface-val-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-eface-val-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-eface-val-compare.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -24,6 +24,8 @@ __go_empty_interface_value_compare (\n     return 1;\n   if (!__go_type_descriptors_equal (left_descriptor, right_descriptor))\n     return 1;\n+  if (left_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (left_descriptor))\n     return left.__object == val ? 0 : 1;\n   if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object, val,"}, {"sha": "2b3ac325c10e4264ae465ab181ef9fa05754bea6", "filename": "libgo/runtime/go-fieldtrack.c", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-fieldtrack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-fieldtrack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-fieldtrack.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -6,7 +6,6 @@\n \n #include \"runtime.h\"\n #include \"go-type.h\"\n-#include \"map.h\"\n \n /* The compiler will track fields that have the tag go:\"track\".  Any\n    function that refers to such a field will call this function with a\n@@ -34,16 +33,26 @@ extern const char _edata[] __attribute__ ((weak));\n extern const char __edata[] __attribute__ ((weak));\n extern const char __bss_start[] __attribute__ ((weak));\n \n-void runtime_Fieldtrack (struct __go_map *) __asm__ (GOSYM_PREFIX \"runtime.Fieldtrack\");\n+extern void mapassign1 (const struct __go_map_type *, void *hmap,\n+\t\t\tconst void *key, const void *val)\n+  __asm__ (GOSYM_PREFIX \"runtime.mapassign1\");\n+\n+// The type descriptor for map[string] bool.  */\n+extern const char __go_td_MN6_string__N4_bool[] __attribute__ ((weak));\n+\n+void runtime_Fieldtrack (void *) __asm__ (GOSYM_PREFIX \"runtime.Fieldtrack\");\n \n void\n-runtime_Fieldtrack (struct __go_map *m)\n+runtime_Fieldtrack (void *m)\n {\n   const char *p;\n   const char *pend;\n   const char *prefix;\n   size_t prefix_len;\n \n+  if (__go_td_MN6_string__N4_bool == NULL)\n+    return;\n+\n   p = __data_start;\n   if (p == NULL)\n     p = __etext;\n@@ -86,14 +95,12 @@ runtime_Fieldtrack (struct __go_map *m)\n       if (__builtin_memchr (q1, '\\0', q2 - q1) == NULL)\n \t{\n \t  String s;\n-\t  void *v;\n-\t  _Bool *pb;\n+\t  _Bool b;\n \n \t  s.str = (const byte *) q1;\n \t  s.len = q2 - q1;\n-\t  v = __go_map_index (m, &s, 1);\n-\t  pb = (_Bool *) v;\n-\t  *pb = 1;\n+\t  b = 1;\n+\t  mapassign1((const void*) __go_td_MN6_string__N4_bool, m, &s, &b);\n \t}\n \n       p = q2;"}, {"sha": "14999df1dd1d097ecf4493c155f3c26e29d848d4", "filename": "libgo/runtime/go-interface-compare.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-compare.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -26,6 +26,8 @@ __go_interface_compare (struct __go_interface left,\n   left_descriptor = left.__methods[0];\n   if (!__go_type_descriptors_equal (left_descriptor, right.__methods[0]))\n     return 1;\n+  if (left_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (left_descriptor))\n     return left.__object == right.__object ? 0 : 1;\n   if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,"}, {"sha": "4c47b7cf04d5789e1b6792fb0406efab1e7f2971", "filename": "libgo/runtime/go-interface-eface-compare.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-eface-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-eface-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-eface-compare.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -25,6 +25,8 @@ __go_interface_empty_compare (struct __go_interface left,\n   left_descriptor = left.__methods[0];\n   if (!__go_type_descriptors_equal (left_descriptor, right.__type_descriptor))\n     return 1;\n+  if (left_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (left_descriptor))\n     return left.__object == right.__object ? 0 : 1;\n   if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object,"}, {"sha": "5dc91d0330f1cfa278c5d963784b49253650ea75", "filename": "libgo/runtime/go-interface-val-compare.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-val-compare.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-interface-val-compare.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-interface-val-compare.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -24,6 +24,8 @@ __go_interface_value_compare (\n   left_descriptor = left.__methods[0];\n   if (!__go_type_descriptors_equal (left_descriptor, right_descriptor))\n     return 1;\n+  if (left_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (left_descriptor))\n     return left.__object == val ? 0 : 1;\n   if (!__go_call_equalfn (left_descriptor->__equalfn, left.__object, val,"}, {"sha": "fb7c331856ed44b1802127c3a60e2f1c5d78afcb", "filename": "libgo/runtime/go-map-delete.c", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-delete.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-delete.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-delete.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,61 +0,0 @@\n-/* go-map-delete.c -- delete an entry from a map.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-#include <stdlib.h>\n-\n-#include \"runtime.h\"\n-#include \"malloc.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"map.h\"\n-\n-/* Delete the entry matching KEY from MAP.  */\n-\n-void\n-__go_map_delete (struct __go_map *map, const void *key)\n-{\n-  const struct __go_map_descriptor *descriptor;\n-  const struct __go_type_descriptor *key_descriptor;\n-  uintptr_t key_offset;\n-  const FuncVal *equalfn;\n-  size_t key_hash;\n-  size_t key_size;\n-  size_t bucket_index;\n-  void **pentry;\n-\n-  if (map == NULL)\n-    return;\n-\n-  descriptor = map->__descriptor;\n-\n-  key_descriptor = descriptor->__map_descriptor->__key_type;\n-  key_offset = descriptor->__key_offset;\n-  key_size = key_descriptor->__size;\n-  if (key_size == 0)\n-    return;\n-\n-  __go_assert (key_size != -1UL);\n-  equalfn = key_descriptor->__equalfn;\n-\n-  key_hash = __go_call_hashfn (key_descriptor->__hashfn, key, key_size);\n-  bucket_index = key_hash % map->__bucket_count;\n-\n-  pentry = map->__buckets + bucket_index;\n-  while (*pentry != NULL)\n-    {\n-      char *entry = (char *) *pentry;\n-      if (__go_call_equalfn (equalfn, key, entry + key_offset, key_size))\n-\t{\n-\t  *pentry = *(void **) entry;\n-\t  if (descriptor->__entry_size >= TinySize)\n-\t    __go_free (entry);\n-\t  map->__element_count -= 1;\n-\t  break;\n-\t}\n-      pentry = (void **) entry;\n-    }\n-}"}, {"sha": "353041db6c472db16d8482aab6a7d2b521a5041b", "filename": "libgo/runtime/go-map-index.c", "status": "removed", "additions": 0, "deletions": 137, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-index.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-index.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-index.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,137 +0,0 @@\n-/* go-map-index.c -- find or insert an entry in a map.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-#include <stdlib.h>\n-\n-#include \"runtime.h\"\n-#include \"malloc.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"map.h\"\n-\n-/* Rehash MAP to a larger size.  */\n-\n-static void\n-__go_map_rehash (struct __go_map *map)\n-{\n-  const struct __go_map_descriptor *descriptor;\n-  const struct __go_type_descriptor *key_descriptor;\n-  uintptr_t key_offset;\n-  size_t key_size;\n-  const FuncVal *hashfn;\n-  uintptr_t old_bucket_count;\n-  void **old_buckets;\n-  uintptr_t new_bucket_count;\n-  void **new_buckets;\n-  uintptr_t i;\n-\n-  descriptor = map->__descriptor;\n-\n-  key_descriptor = descriptor->__map_descriptor->__key_type;\n-  key_offset = descriptor->__key_offset;\n-  key_size = key_descriptor->__size;\n-  hashfn = key_descriptor->__hashfn;\n-\n-  old_bucket_count = map->__bucket_count;\n-  old_buckets = map->__buckets;\n-\n-  new_bucket_count = __go_map_next_prime (old_bucket_count * 2);\n-  new_buckets = (void **) __go_alloc (new_bucket_count * sizeof (void *));\n-  __builtin_memset (new_buckets, 0, new_bucket_count * sizeof (void *));\n-\n-  for (i = 0; i < old_bucket_count; ++i)\n-    {\n-      char* entry;\n-      char* next;\n-\n-      for (entry = old_buckets[i]; entry != NULL; entry = next)\n-\t{\n-\t  size_t key_hash;\n-\t  size_t new_bucket_index;\n-\n-\t  /* We could speed up rehashing at the cost of memory space\n-\t     by caching the hash code.  */\n-\t  key_hash = __go_call_hashfn (hashfn, entry + key_offset, key_size);\n-\t  new_bucket_index = key_hash % new_bucket_count;\n-\n-\t  next = *(char **) entry;\n-\t  *(char **) entry = new_buckets[new_bucket_index];\n-\t  new_buckets[new_bucket_index] = entry;\n-\t}\n-    }\n-\n-  if (old_bucket_count * sizeof (void *) >= TinySize)\n-    __go_free (old_buckets);\n-\n-  map->__bucket_count = new_bucket_count;\n-  map->__buckets = new_buckets;\n-}\n-\n-/* Find KEY in MAP, return a pointer to the value.  If KEY is not\n-   present, then if INSERT is false, return NULL, and if INSERT is\n-   true, insert a new value and zero-initialize it before returning a\n-   pointer to it.  */\n-\n-void *\n-__go_map_index (struct __go_map *map, const void *key, _Bool insert)\n-{\n-  const struct __go_map_descriptor *descriptor;\n-  const struct __go_type_descriptor *key_descriptor;\n-  uintptr_t key_offset;\n-  const FuncVal *equalfn;\n-  size_t key_hash;\n-  size_t key_size;\n-  size_t bucket_index;\n-  char *entry;\n-\n-  if (map == NULL)\n-    {\n-      if (insert)\n-\truntime_panicstring (\"assignment to entry in nil map\");\n-      return NULL;\n-    }\n-\n-  descriptor = map->__descriptor;\n-\n-  key_descriptor = descriptor->__map_descriptor->__key_type;\n-  key_offset = descriptor->__key_offset;\n-  key_size = key_descriptor->__size;\n-  __go_assert (key_size != -1UL);\n-  equalfn = key_descriptor->__equalfn;\n-\n-  key_hash = __go_call_hashfn (key_descriptor->__hashfn, key, key_size);\n-  bucket_index = key_hash % map->__bucket_count;\n-\n-  entry = (char *) map->__buckets[bucket_index];\n-  while (entry != NULL)\n-    {\n-      if (__go_call_equalfn (equalfn, key, entry + key_offset, key_size))\n-\treturn entry + descriptor->__val_offset;\n-      entry = *(char **) entry;\n-    }\n-\n-  if (!insert)\n-    return NULL;\n-\n-  if (map->__element_count >= map->__bucket_count)\n-    {\n-      __go_map_rehash (map);\n-      bucket_index = key_hash % map->__bucket_count;\n-    }\n-\n-  entry = (char *) __go_alloc (descriptor->__entry_size);\n-  __builtin_memset (entry, 0, descriptor->__entry_size);\n-\n-  __builtin_memcpy (entry + key_offset, key, key_size);\n-\n-  *(char **) entry = map->__buckets[bucket_index];\n-  map->__buckets[bucket_index] = entry;\n-\n-  map->__element_count += 1;\n-\n-  return entry + descriptor->__val_offset;\n-}"}, {"sha": "7da10c249437216aa3950f0febb31c38ac9b437a", "filename": "libgo/runtime/go-map-len.c", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-len.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-len.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-len.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,25 +0,0 @@\n-/* go-map-len.c -- return the length of a map.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"map.h\"\n-\n-/* Return the length of a map.  This could be done inline, of course,\n-   but I'm doing it as a function for now to make it easy to change\n-   the map structure.  */\n-\n-intgo\n-__go_map_len (struct __go_map *map)\n-{\n-  if (map == NULL)\n-    return 0;\n-  __go_assert (map->__element_count\n-\t       == (uintptr_t) (intgo) map->__element_count);\n-  return map->__element_count;\n-}"}, {"sha": "5dbb92ccb89aade9ed3ac11c6a13836b89ec3de2", "filename": "libgo/runtime/go-map-range.c", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-range.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-map-range.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-map-range.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,103 +0,0 @@\n-/* go-map-range.c -- implement a range clause over a map.\n-\n-   Copyright 2009, 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-assert.h\"\n-#include \"map.h\"\n-\n-/* Initialize a range over a map.  */\n-\n-void\n-__go_mapiterinit (const struct __go_map *h, struct __go_hash_iter *it)\n-{\n-  it->entry = NULL;\n-  if (h != NULL)\n-    {\n-      it->map = h;\n-      it->next_entry = NULL;\n-      it->bucket = 0;\n-      --it->bucket;\n-      __go_mapiternext(it);\n-    }\n-}\n-\n-/* Move to the next iteration, updating *HITER.  */\n-\n-void\n-__go_mapiternext (struct __go_hash_iter *it)\n-{\n-  const void *entry;\n-\n-  entry = it->next_entry;\n-  if (entry == NULL)\n-    {\n-      const struct __go_map *map;\n-      uintptr_t bucket;\n-\n-      map = it->map;\n-      bucket = it->bucket;\n-      while (1)\n-\t{\n-\t  ++bucket;\n-\t  if (bucket >= map->__bucket_count)\n-\t    {\n-\t      /* Map iteration is complete.  */\n-\t      it->entry = NULL;\n-\t      return;\n-\t    }\n-\t  entry = map->__buckets[bucket];\n-\t  if (entry != NULL)\n-\t    break;\n-\t}\n-      it->bucket = bucket;\n-    }\n-  it->entry = entry;\n-  it->next_entry = *(const void * const *) entry;\n-}\n-\n-/* Get the key of the current iteration.  */\n-\n-void\n-__go_mapiter1 (struct __go_hash_iter *it, unsigned char *key)\n-{\n-  const struct __go_map *map;\n-  const struct __go_map_descriptor *descriptor;\n-  const struct __go_type_descriptor *key_descriptor;\n-  const char *p;\n-\n-  map = it->map;\n-  descriptor = map->__descriptor;\n-  key_descriptor = descriptor->__map_descriptor->__key_type;\n-  p = it->entry;\n-  __go_assert (p != NULL);\n-  __builtin_memcpy (key, p + descriptor->__key_offset, key_descriptor->__size);\n-}\n-\n-/* Get the key and value of the current iteration.  */\n-\n-void\n-__go_mapiter2 (struct __go_hash_iter *it, unsigned char *key,\n-\t       unsigned char *val)\n-{\n-  const struct __go_map *map;\n-  const struct __go_map_descriptor *descriptor;\n-  const struct __go_map_type *map_descriptor;\n-  const struct __go_type_descriptor *key_descriptor;\n-  const struct __go_type_descriptor *val_descriptor;\n-  const char *p;\n-\n-  map = it->map;\n-  descriptor = map->__descriptor;\n-  map_descriptor = descriptor->__map_descriptor;\n-  key_descriptor = map_descriptor->__key_type;\n-  val_descriptor = map_descriptor->__val_type;\n-  p = it->entry;\n-  __go_assert (p != NULL);\n-  __builtin_memcpy (key, p + descriptor->__key_offset,\n-\t\t    key_descriptor->__size);\n-  __builtin_memcpy (val, p + descriptor->__val_offset,\n-\t\t    val_descriptor->__size);\n-}"}, {"sha": "de6f39a6b1e501a7ddec228360c85fa7f01e932e", "filename": "libgo/runtime/go-memclr.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memclr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memclr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-memclr.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,16 @@\n+/* go-memclr.c -- clear a memory buffer\n+\n+   Copyright 2016 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"runtime.h\"\n+\n+void memclr(void *, uintptr)\n+  __asm__ (GOSYM_PREFIX \"runtime.memclr\");\n+\n+void\n+memclr (void *p1, uintptr len)\n+{\n+  __builtin_memset (p1, 0, len);\n+}"}, {"sha": "5f514aaae09d7bf2a0ebbb34fa50b68c6d452e49", "filename": "libgo/runtime/go-memequal.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memequal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memequal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-memequal.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,16 @@\n+/* go-memequal.c -- compare memory buffers for equality\n+\n+   Copyright 2016 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"runtime.h\"\n+\n+_Bool memequal (void *, void *, uintptr)\n+  __asm__ (GOSYM_PREFIX \"runtime.memequal\");\n+\n+_Bool\n+memequal (void *p1, void *p2, uintptr len)\n+{\n+  return __builtin_memcmp (p1, p2, len) == 0;\n+}"}, {"sha": "a6fda08c47def2d5dde9c4686e4a4df6f2ab84f6", "filename": "libgo/runtime/go-memmove.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-memmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-memmove.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -0,0 +1,16 @@\n+/* go-memmove.c -- move one memory buffer to another\n+\n+   Copyright 2016 The Go Authors. All rights reserved.\n+   Use of this source code is governed by a BSD-style\n+   license that can be found in the LICENSE file.  */\n+\n+#include \"runtime.h\"\n+\n+void move(void *, void *, uintptr)\n+  __asm__ (GOSYM_PREFIX \"runtime.memmove\");\n+\n+void\n+move (void *p1, void *p2, uintptr len)\n+{\n+  __builtin_memmove (p1, p2, len);\n+}"}, {"sha": "c289bc0bea05f6d891b77cfb292e76fd0e140768", "filename": "libgo/runtime/go-new-map.c", "status": "removed", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-new-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-new-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-new-map.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,142 +0,0 @@\n-/* go-new-map.c -- allocate a new map.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"map.h\"\n-\n-/* List of prime numbers, copied from libstdc++/src/hashtable.c.  */\n-\n-static const unsigned long prime_list[] = /* 256 + 1 or 256 + 48 + 1 */\n-{\n-  2ul, 3ul, 5ul, 7ul, 11ul, 13ul, 17ul, 19ul, 23ul, 29ul, 31ul,\n-  37ul, 41ul, 43ul, 47ul, 53ul, 59ul, 61ul, 67ul, 71ul, 73ul, 79ul,\n-  83ul, 89ul, 97ul, 103ul, 109ul, 113ul, 127ul, 137ul, 139ul, 149ul,\n-  157ul, 167ul, 179ul, 193ul, 199ul, 211ul, 227ul, 241ul, 257ul,\n-  277ul, 293ul, 313ul, 337ul, 359ul, 383ul, 409ul, 439ul, 467ul,\n-  503ul, 541ul, 577ul, 619ul, 661ul, 709ul, 761ul, 823ul, 887ul,\n-  953ul, 1031ul, 1109ul, 1193ul, 1289ul, 1381ul, 1493ul, 1613ul,\n-  1741ul, 1879ul, 2029ul, 2179ul, 2357ul, 2549ul, 2753ul, 2971ul,\n-  3209ul, 3469ul, 3739ul, 4027ul, 4349ul, 4703ul, 5087ul, 5503ul,\n-  5953ul, 6427ul, 6949ul, 7517ul, 8123ul, 8783ul, 9497ul, 10273ul,\n-  11113ul, 12011ul, 12983ul, 14033ul, 15173ul, 16411ul, 17749ul,\n-  19183ul, 20753ul, 22447ul, 24281ul, 26267ul, 28411ul, 30727ul,\n-  33223ul, 35933ul, 38873ul, 42043ul, 45481ul, 49201ul, 53201ul,\n-  57557ul, 62233ul, 67307ul, 72817ul, 78779ul, 85229ul, 92203ul,\n-  99733ul, 107897ul, 116731ul, 126271ul, 136607ul, 147793ul,\n-  159871ul, 172933ul, 187091ul, 202409ul, 218971ul, 236897ul,\n-  256279ul, 277261ul, 299951ul, 324503ul, 351061ul, 379787ul,\n-  410857ul, 444487ul, 480881ul, 520241ul, 562841ul, 608903ul,\n-  658753ul, 712697ul, 771049ul, 834181ul, 902483ul, 976369ul,\n-  1056323ul, 1142821ul, 1236397ul, 1337629ul, 1447153ul, 1565659ul,\n-  1693859ul, 1832561ul, 1982627ul, 2144977ul, 2320627ul, 2510653ul,\n-  2716249ul, 2938679ul, 3179303ul, 3439651ul, 3721303ul, 4026031ul,\n-  4355707ul, 4712381ul, 5098259ul, 5515729ul, 5967347ul, 6456007ul,\n-  6984629ul, 7556579ul, 8175383ul, 8844859ul, 9569143ul, 10352717ul,\n-  11200489ul, 12117689ul, 13109983ul, 14183539ul, 15345007ul,\n-  16601593ul, 17961079ul, 19431899ul, 21023161ul, 22744717ul,\n-  24607243ul, 26622317ul, 28802401ul, 31160981ul, 33712729ul,\n-  36473443ul, 39460231ul, 42691603ul, 46187573ul, 49969847ul,\n-  54061849ul, 58488943ul, 63278561ul, 68460391ul, 74066549ul,\n-  80131819ul, 86693767ul, 93793069ul, 101473717ul, 109783337ul,\n-  118773397ul, 128499677ul, 139022417ul, 150406843ul, 162723577ul,\n-  176048909ul, 190465427ul, 206062531ul, 222936881ul, 241193053ul,\n-  260944219ul, 282312799ul, 305431229ul, 330442829ul, 357502601ul,\n-  386778277ul, 418451333ul, 452718089ul, 489790921ul, 529899637ul,\n-  573292817ul, 620239453ul, 671030513ul, 725980837ul, 785430967ul,\n-  849749479ul, 919334987ul, 994618837ul, 1076067617ul, 1164186217ul,\n-  1259520799ul, 1362662261ul, 1474249943ul, 1594975441ul, 1725587117ul,\n-  1866894511ul, 2019773507ul, 2185171673ul, 2364114217ul, 2557710269ul,\n-  2767159799ul, 2993761039ul, 3238918481ul, 3504151727ul, 3791104843ul,\n-  4101556399ul, 4294967291ul,\n-#if __SIZEOF_LONG__ >= 8\n-  6442450933ul, 8589934583ul, 12884901857ul, 17179869143ul,\n-  25769803693ul, 34359738337ul, 51539607367ul, 68719476731ul,\n-  103079215087ul, 137438953447ul, 206158430123ul, 274877906899ul,\n-  412316860387ul, 549755813881ul, 824633720731ul, 1099511627689ul,\n-  1649267441579ul, 2199023255531ul, 3298534883309ul, 4398046511093ul,\n-  6597069766607ul, 8796093022151ul, 13194139533241ul, 17592186044399ul,\n-  26388279066581ul, 35184372088777ul, 52776558133177ul, 70368744177643ul,\n-  105553116266399ul, 140737488355213ul, 211106232532861ul, 281474976710597ul,\n-  562949953421231ul, 1125899906842597ul, 2251799813685119ul,\n-  4503599627370449ul, 9007199254740881ul, 18014398509481951ul,\n-  36028797018963913ul, 72057594037927931ul, 144115188075855859ul,\n-  288230376151711717ul, 576460752303423433ul,\n-  1152921504606846883ul, 2305843009213693951ul,\n-  4611686018427387847ul, 9223372036854775783ul,\n-  18446744073709551557ul\n-#endif\n-};\n-\n-/* Return the next number from PRIME_LIST >= N.  */\n-\n-uintptr_t\n-__go_map_next_prime (uintptr_t n)\n-{\n-  size_t low;\n-  size_t high;\n-\n-  low = 0;\n-  high = sizeof prime_list / sizeof prime_list[0];\n-  while (low < high)\n-    {\n-      size_t mid;\n-\n-      mid = (low + high) / 2;\n-\n-      /* Here LOW <= MID < HIGH.  */\n-\n-      if (prime_list[mid] < n)\n-\tlow = mid + 1;\n-      else if (prime_list[mid] > n)\n-\thigh = mid;\n-      else\n-\treturn n;\n-    }\n-  if (low >= sizeof prime_list / sizeof prime_list[0])\n-    return n;\n-  return prime_list[low];\n-}\n-\n-/* Allocate a new map.  */\n-\n-struct __go_map *\n-__go_new_map (const struct __go_map_descriptor *descriptor, uintptr_t entries)\n-{\n-  int32 ientries;\n-  struct __go_map *ret;\n-\n-  /* The master library limits map entries to int32, so we do too.  */\n-  ientries = (int32) entries;\n-  if (ientries < 0 || (uintptr_t) ientries != entries)\n-    runtime_panicstring (\"map size out of range\");\n-\n-  if (entries == 0)\n-    entries = 5;\n-  else\n-    entries = __go_map_next_prime (entries);\n-  ret = (struct __go_map *) __go_alloc (sizeof (struct __go_map));\n-  ret->__descriptor = descriptor;\n-  ret->__element_count = 0;\n-  ret->__bucket_count = entries;\n-  ret->__buckets = (void **) __go_alloc (entries * sizeof (void *));\n-  __builtin_memset (ret->__buckets, 0, entries * sizeof (void *));\n-  return ret;\n-}\n-\n-/* Allocate a new map when the argument to make is a large type.  */\n-\n-struct __go_map *\n-__go_new_map_big (const struct __go_map_descriptor *descriptor,\n-\t\t  uint64_t entries)\n-{\n-  uintptr_t sentries;\n-\n-  sentries = (uintptr_t) entries;\n-  if ((uint64_t) sentries != entries)\n-    runtime_panicstring (\"map size out of range\");\n-  return __go_new_map (descriptor, sentries);\n-}"}, {"sha": "36f31025d301295abf2798e30a58f015b7d8d5ed", "filename": "libgo/runtime/go-reflect-map.c", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-reflect-map.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-reflect-map.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-map.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,156 +0,0 @@\n-/* go-reflect-map.c -- map reflection support for Go.\n-\n-   Copyright 2009, 2010 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stdlib.h>\n-#include <stdint.h>\n-\n-#include \"runtime.h\"\n-#include \"go-alloc.h\"\n-#include \"go-assert.h\"\n-#include \"go-type.h\"\n-#include \"map.h\"\n-\n-/* This file implements support for reflection on maps.  These\n-   functions are called from reflect/value.go.  */\n-\n-extern void *mapaccess (struct __go_map_type *, void *, void *)\n-  __asm__ (GOSYM_PREFIX \"reflect.mapaccess\");\n-\n-void *\n-mapaccess (struct __go_map_type *mt, void *m, void *key)\n-{\n-  struct __go_map *map = (struct __go_map *) m;\n-\n-  __go_assert ((mt->__common.__code & GO_CODE_MASK) == GO_MAP);\n-  if (map == NULL)\n-    return NULL;\n-  else\n-    return __go_map_index (map, key, 0);\n-}\n-\n-extern void mapassign (struct __go_map_type *, void *, void *, void *)\n-  __asm__ (GOSYM_PREFIX \"reflect.mapassign\");\n-\n-void\n-mapassign (struct __go_map_type *mt, void *m, void *key, void *val)\n-{\n-  struct __go_map *map = (struct __go_map *) m;\n-  void *p;\n-\n-  __go_assert ((mt->__common.__code & GO_CODE_MASK) == GO_MAP);\n-  if (map == NULL)\n-    runtime_panicstring (\"assignment to entry in nil map\");\n-  p = __go_map_index (map, key, 1);\n-  __builtin_memcpy (p, val, mt->__val_type->__size);\n-}\n-\n-extern void mapdelete (struct __go_map_type *, void *, void *)\n-  __asm__ (GOSYM_PREFIX \"reflect.mapdelete\");\n-\n-void\n-mapdelete (struct __go_map_type *mt, void *m, void *key)\n-{\n-  struct __go_map *map = (struct __go_map *) m;\n-\n-  __go_assert ((mt->__common.__code & GO_CODE_MASK) == GO_MAP);\n-  if (map == NULL)\n-    return;\n-  __go_map_delete (map, key);\n-}\n-\n-extern int32_t maplen (void *) __asm__ (GOSYM_PREFIX \"reflect.maplen\");\n-\n-int32_t\n-maplen (void *m)\n-{\n-  struct __go_map *map = (struct __go_map *) m;\n-\n-  if (map == NULL)\n-    return 0;\n-  return (int32_t) map->__element_count;\n-}\n-\n-extern unsigned char *mapiterinit (struct __go_map_type *, void *)\n-  __asm__ (GOSYM_PREFIX \"reflect.mapiterinit\");\n-\n-unsigned char *\n-mapiterinit (struct __go_map_type *mt, void *m)\n-{\n-  struct __go_hash_iter *it;\n-\n-  __go_assert ((mt->__common.__code & GO_CODE_MASK) == GO_MAP);\n-  it = __go_alloc (sizeof (struct __go_hash_iter));\n-  __go_mapiterinit ((struct __go_map *) m, it);\n-  return (unsigned char *) it;\n-}\n-\n-extern void mapiternext (void *) __asm__ (GOSYM_PREFIX \"reflect.mapiternext\");\n-\n-void\n-mapiternext (void *it)\n-{\n-  __go_mapiternext ((struct __go_hash_iter *) it);\n-}\n-\n-extern void *mapiterkey (void *) __asm__ (GOSYM_PREFIX \"reflect.mapiterkey\");\n-\n-void *\n-mapiterkey (void *ita)\n-{\n-  struct __go_hash_iter *it = (struct __go_hash_iter *) ita;\n-  const struct __go_type_descriptor *key_descriptor;\n-  void *key;\n-\n-  if (it->entry == NULL)\n-    return NULL;\n-\n-  key_descriptor = it->map->__descriptor->__map_descriptor->__key_type;\n-  key = __go_alloc (key_descriptor->__size);\n-  __go_mapiter1 (it, key);\n-  return key;\n-}\n-\n-/* Make a new map.  We have to build our own map descriptor.  */\n-\n-extern struct __go_map *makemap (const struct __go_map_type *)\n-  __asm__ (GOSYM_PREFIX \"reflect.makemap\");\n-\n-struct __go_map *\n-makemap (const struct __go_map_type *t)\n-{\n-  struct __go_map_descriptor *md;\n-  unsigned int o;\n-  const struct __go_type_descriptor *kt;\n-  const struct __go_type_descriptor *vt;\n-\n-  md = (struct __go_map_descriptor *) __go_alloc (sizeof (*md));\n-  md->__map_descriptor = t;\n-  o = sizeof (void *);\n-  kt = t->__key_type;\n-  o = (o + kt->__field_align - 1) & ~ (kt->__field_align - 1);\n-  md->__key_offset = o;\n-  o += kt->__size;\n-  vt = t->__val_type;\n-  o = (o + vt->__field_align - 1) & ~ (vt->__field_align - 1);\n-  md->__val_offset = o;\n-  o += vt->__size;\n-  o = (o + sizeof (void *) - 1) & ~ (sizeof (void *) - 1);\n-  o = (o + kt->__field_align - 1) & ~ (kt->__field_align - 1);\n-  o = (o + vt->__field_align - 1) & ~ (vt->__field_align - 1);\n-  md->__entry_size = o;\n-\n-  return __go_new_map (md, 0);\n-}\n-\n-extern _Bool ismapkey (const struct __go_type_descriptor *)\n-  __asm__ (GOSYM_PREFIX \"reflect.ismapkey\");\n-\n-_Bool\n-ismapkey (const struct __go_type_descriptor *typ)\n-{\n-  return (typ != NULL\n-\t  && (void *) typ->__hashfn->fn != (void *) __go_type_hash_error);\n-}"}, {"sha": "829572b7bee921134c5446f3c1993d74cae4ea4d", "filename": "libgo/runtime/go-type-complex.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-complex.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -14,7 +14,7 @@\n /* Hash function for float types.  */\n \n uintptr_t\n-__go_type_hash_complex (const void *vkey, uintptr_t key_size)\n+__go_type_hash_complex (const void *vkey, uintptr_t seed, uintptr_t key_size)\n {\n   if (key_size == 8)\n     {\n@@ -31,7 +31,7 @@ __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n       cfi = cimagf (cf);\n \n       if (isinf (cfr) || isinf (cfi))\n-\treturn 0;\n+\treturn seed;\n \n       /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n \t random so that not all NaNs wind up in the same place.  */\n@@ -40,14 +40,14 @@ __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n \n       /* Avoid negative zero.  */\n       if (cfr == 0 && cfi == 0)\n-\treturn 0;\n+\treturn seed;\n       else if (cfr == 0)\n \tcf = cfi * I;\n       else if (cfi == 0)\n \tcf = cfr;\n \n       memcpy (&fi, &cf, 8);\n-      return (uintptr_t) cfi;\n+      return (uintptr_t) cfi ^ seed;\n     }\n   else if (key_size == 16)\n     {\n@@ -64,21 +64,21 @@ __go_type_hash_complex (const void *vkey, uintptr_t key_size)\n       cdi = cimag (cd);\n \n       if (isinf (cdr) || isinf (cdi))\n-\treturn 0;\n+\treturn seed;\n \n       if (isnan (cdr) || isnan (cdi))\n \treturn runtime_fastrand1 ();\n \n       /* Avoid negative zero.  */\n       if (cdr == 0 && cdi == 0)\n-\treturn 0;\n+\treturn seed;\n       else if (cdr == 0)\n \tcd = cdi * I;\n       else if (cdi == 0)\n \tcd = cdr;\n \n       memcpy (&di, &cd, 16);\n-      return di[0] ^ di[1];\n+      return di[0] ^ di[1] ^ seed;\n     }\n   else\n     runtime_throw (\"__go_type_hash_complex: invalid complex size\");"}, {"sha": "a98bceaac84686f6537aa76f3579d64f267b3d08", "filename": "libgo/runtime/go-type-eface.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-eface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-eface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-eface.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -11,7 +11,7 @@\n /* A hash function for an empty interface.  */\n \n uintptr_t\n-__go_type_hash_empty_interface (const void *vval,\n+__go_type_hash_empty_interface (const void *vval, uintptr_t seed,\n \t\t\t\tuintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_empty_interface *val;\n@@ -22,11 +22,13 @@ __go_type_hash_empty_interface (const void *vval,\n   descriptor = val->__type_descriptor;\n   if (descriptor == NULL)\n     return 0;\n+  if (descriptor->__hashfn == NULL)\n+    runtime_panicstring (\"hash of unhashable type\");\n   size = descriptor->__size;\n   if (__go_is_pointer_type (descriptor))\n-    return __go_call_hashfn (descriptor->__hashfn, &val->__object, size);\n+    return __go_call_hashfn (descriptor->__hashfn, &val->__object, seed, size);\n   else\n-    return __go_call_hashfn (descriptor->__hashfn, val->__object, size);\n+    return __go_call_hashfn (descriptor->__hashfn, val->__object, seed, size);\n }\n \n const FuncVal __go_type_hash_empty_interface_descriptor =\n@@ -51,6 +53,8 @@ __go_type_equal_empty_interface (const void *vv1, const void *vv2,\n     return v1_descriptor == v2_descriptor;\n   if (!__go_type_descriptors_equal (v1_descriptor, v2_descriptor))\n     return 0;\n+  if (v1_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (v1_descriptor))\n     return v1->__object == v2->__object;\n   else"}, {"sha": "8881a86f6e09b9bf083fd8f1918908793ca15de0", "filename": "libgo/runtime/go-type-error.c", "status": "removed", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-type-error.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fgo-type-error.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-error.c?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,34 +0,0 @@\n-/* go-type-error.c -- invalid hash and equality functions.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-\n-/* A hash function used for a type which does not support hash\n-   functions.  */\n-\n-uintptr_t\n-__go_type_hash_error (const void *val __attribute__ ((unused)),\n-\t\t      uintptr_t key_size __attribute__ ((unused)))\n-{\n-  runtime_panicstring (\"hash of unhashable type\");\n-}\n-\n-const FuncVal __go_type_hash_error_descriptor =\n-  { (void *) __go_type_hash_error };\n-\n-/* An equality function for an interface.  */\n-\n-_Bool\n-__go_type_equal_error (const void *v1 __attribute__ ((unused)),\n-\t\t       const void *v2 __attribute__ ((unused)),\n-\t\t       uintptr_t key_size __attribute__ ((unused)))\n-{\n-  runtime_panicstring (\"comparing uncomparable types\");\n-}\n-\n-const FuncVal __go_type_equal_error_descriptor =\n-  { (void *) __go_type_equal_error };"}, {"sha": "ae0e3367c2122cb5c8ae86acf5c102892e47663a", "filename": "libgo/runtime/go-type-float.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-float.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -12,7 +12,7 @@\n /* Hash function for float types.  */\n \n uintptr_t\n-__go_type_hash_float (const void *vkey, uintptr_t key_size)\n+__go_type_hash_float (const void *vkey, uintptr_t seed, uintptr_t key_size)\n {\n   if (key_size == 4)\n     {\n@@ -24,15 +24,15 @@ __go_type_hash_float (const void *vkey, uintptr_t key_size)\n       f = *fp;\n \n       if (isinf (f) || f == 0)\n-\treturn 0;\n+\treturn seed;\n \n       /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n \t random so that not all NaNs wind up in the same place.  */\n       if (isnan (f))\n \treturn runtime_fastrand1 ();\n \n       memcpy (&si, vkey, 4);\n-      return (uintptr_t) si;\n+      return (uintptr_t) si ^ seed;\n     }\n   else if (key_size == 8)\n     {\n@@ -44,13 +44,13 @@ __go_type_hash_float (const void *vkey, uintptr_t key_size)\n       d = *dp;\n \n       if (isinf (d) || d == 0)\n-\treturn 0;\n+\treturn seed;\n \n       if (isnan (d))\n \treturn runtime_fastrand1 ();\n \n       memcpy (&di, vkey, 8);\n-      return (uintptr_t) di;\n+      return (uintptr_t) di ^ seed;\n     }\n   else\n     runtime_throw (\"__go_type_hash_float: invalid float size\");"}, {"sha": "d58aa75e5ed2cfb39f0feb635b2266c52d3d3c11", "filename": "libgo/runtime/go-type-identity.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-identity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-identity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-identity.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -14,7 +14,7 @@\n    true of, e.g., integers and pointers.  */\n \n uintptr_t\n-__go_type_hash_identity (const void *key, uintptr_t key_size)\n+__go_type_hash_identity (const void *key, uintptr_t seed, uintptr_t key_size)\n {\n   uintptr_t ret;\n   uintptr_t i;\n@@ -34,12 +34,12 @@ __go_type_hash_identity (const void *key, uintptr_t key_size)\n       __builtin_memcpy (&u.a[0], key, key_size);\n #endif\n       if (sizeof (uintptr_t) >= 8)\n-\treturn (uintptr_t) u.v;\n+\treturn (uintptr_t) u.v ^ seed;\n       else\n-\treturn (uintptr_t) ((u.v >> 32) ^ (u.v & 0xffffffff));\n+\treturn (uintptr_t) ((u.v >> 32) ^ (u.v & 0xffffffff)) ^ seed;\n     }\n \n-  ret = 5381;\n+  ret = seed;\n   for (i = 0, p = (const unsigned char *) key; i < key_size; i++, p++)\n     ret = ret * 33 + *p;\n   return ret;"}, {"sha": "ffba7b28a3566c76e5e19d9a566e34f11174c46d", "filename": "libgo/runtime/go-type-interface.c", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-interface.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -11,7 +11,7 @@\n /* A hash function for an interface.  */\n \n uintptr_t\n-__go_type_hash_interface (const void *vval,\n+__go_type_hash_interface (const void *vval, uintptr_t seed,\n \t\t\t  uintptr_t key_size __attribute__ ((unused)))\n {\n   const struct __go_interface *val;\n@@ -22,11 +22,13 @@ __go_type_hash_interface (const void *vval,\n   if (val->__methods == NULL)\n     return 0;\n   descriptor = (const struct __go_type_descriptor *) val->__methods[0];\n+  if (descriptor->__hashfn == NULL)\n+    runtime_panicstring (\"hash of unhashable type\");\n   size = descriptor->__size;\n   if (__go_is_pointer_type (descriptor))\n-    return __go_call_hashfn (descriptor->__hashfn, &val->__object, size);\n+    return __go_call_hashfn (descriptor->__hashfn, &val->__object, seed, size);\n   else\n-    return __go_call_hashfn (descriptor->__hashfn, val->__object, size);\n+    return __go_call_hashfn (descriptor->__hashfn, val->__object, seed, size);\n }\n \n const FuncVal __go_type_hash_interface_descriptor =\n@@ -51,6 +53,8 @@ __go_type_equal_interface (const void *vv1, const void *vv2,\n   v2_descriptor = (const struct __go_type_descriptor *) v2->__methods[0];\n   if (!__go_type_descriptors_equal (v1_descriptor, v2_descriptor))\n     return 0;\n+  if (v1_descriptor->__equalfn == NULL)\n+    runtime_panicstring (\"comparing uncomparable types\");\n   if (__go_is_pointer_type (v1_descriptor))\n     return v1->__object == v2->__object;\n   else"}, {"sha": "c7277ddb646e59e993ad9cb71a937a3acd8b8ce7", "filename": "libgo/runtime/go-type-string.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-string.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -11,7 +11,7 @@\n /* A string hash function for a map.  */\n \n uintptr_t\n-__go_type_hash_string (const void *vkey,\n+__go_type_hash_string (const void *vkey, uintptr_t seed,\n \t\t       uintptr_t key_size __attribute__ ((unused)))\n {\n   uintptr_t ret;\n@@ -20,7 +20,7 @@ __go_type_hash_string (const void *vkey,\n   intgo i;\n   const byte *p;\n \n-  ret = 5381;\n+  ret = seed;\n   key = (const String *) vkey;\n   len = key->len;\n   for (i = 0, p = key->str; i < len; i++, p++)"}, {"sha": "7c3149badc741575a778ed342321e446a588c3a3", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -257,6 +257,33 @@ struct __go_map_type\n \n   /* The map value type.  */\n   const struct __go_type_descriptor *__val_type;\n+\n+  /* The map bucket type.  */\n+  const struct __go_type_descriptor *__bucket_type;\n+\n+  /* The map header type.  */\n+  const struct __go_type_descriptor *__hmap_type;\n+\n+  /* The size of the key slot.  */\n+  uint8_t __key_size;\n+\n+  /* Whether to store a pointer to key rather than the key itself.  */\n+  uint8_t __indirect_key;\n+\n+  /* The size of the value slot.  */\n+  uint8_t __value_size;\n+\n+  /* Whether to store a pointer to value rather than the value itself.  */\n+  uint8_t __indirect_value;\n+\n+  /* The size of a bucket.  */\n+  uint16_t __bucket_size;\n+\n+  /* Whether the key type is reflexive--whether k==k for all keys.  */\n+  _Bool __reflexive_key;\n+\n+  /* Whether we should update the key when overwriting an entry.  */\n+  _Bool __need_key_update;\n };\n \n /* A pointer type.  */\n@@ -314,10 +341,11 @@ __go_is_pointer_type (const struct __go_type_descriptor *td)\n /* Call a type hash function, given the __hashfn value.  */\n \n static inline uintptr_t\n-__go_call_hashfn (const FuncVal *hashfn, const void *p, uintptr_t size)\n+__go_call_hashfn (const FuncVal *hashfn, const void *p, uintptr_t seed,\n+\t\t  uintptr_t size)\n {\n-  uintptr_t (*h) (const void *, uintptr_t) = (void *) hashfn->fn;\n-  return __builtin_call_with_static_chain (h (p, size), hashfn);\n+  uintptr_t (*h) (const void *, uintptr_t, uintptr_t) = (void *) hashfn->fn;\n+  return __builtin_call_with_static_chain (h (p, seed, size), hashfn);\n }\n \n /* Call a type equality function, given the __equalfn value.  */\n@@ -334,29 +362,25 @@ extern _Bool\n __go_type_descriptors_equal(const struct __go_type_descriptor*,\n \t\t\t    const struct __go_type_descriptor*);\n \n-extern uintptr_t __go_type_hash_identity (const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_identity (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_identity_descriptor;\n extern _Bool __go_type_equal_identity (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_identity_descriptor;\n-extern uintptr_t __go_type_hash_string (const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_string (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_string_descriptor;\n extern _Bool __go_type_equal_string (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_string_descriptor;\n-extern uintptr_t __go_type_hash_float (const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_float (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_float_descriptor;\n extern _Bool __go_type_equal_float (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_float_descriptor;\n-extern uintptr_t __go_type_hash_complex (const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_complex (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_complex_descriptor;\n extern _Bool __go_type_equal_complex (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_complex_descriptor;\n-extern uintptr_t __go_type_hash_interface (const void *, uintptr_t);\n+extern uintptr_t __go_type_hash_interface (const void *, uintptr_t, uintptr_t);\n extern const FuncVal __go_type_hash_interface_descriptor;\n extern _Bool __go_type_equal_interface (const void *, const void *, uintptr_t);\n extern const FuncVal __go_type_equal_interface_descriptor;\n-extern uintptr_t __go_type_hash_error (const void *, uintptr_t);\n-extern const FuncVal __go_type_hash_error_descriptor;\n-extern _Bool __go_type_equal_error (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_error_descriptor;\n \n #endif /* !defined(LIBGO_GO_TYPE_H) */"}, {"sha": "591d06a7f59fcc453ceb2cc53c674e9678d853ad", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -23,9 +23,6 @@ package runtime\n // Type aka __go_type_descriptor\n #define kind __code\n #define string __reflection\n-#define KindPtr GO_PTR\n-#define KindNoPointers GO_NO_POINTERS\n-#define kindMask GO_CODE_MASK\n \n // GCCGO SPECIFIC CHANGE\n //\n@@ -893,7 +890,7 @@ runtime_mal(uintptr n)\n }\n \n func new(typ *Type) (ret *uint8) {\n-\tret = runtime_mallocgc(typ->__size, (uintptr)typ | TypeInfo_SingleObject, typ->kind&KindNoPointers ? FlagNoScan : 0);\n+\tret = runtime_mallocgc(typ->__size, (uintptr)typ | TypeInfo_SingleObject, typ->kind&kindNoPointers ? FlagNoScan : 0);\n }\n \n static void*\n@@ -903,7 +900,7 @@ cnew(const Type *typ, intgo n, int32 objtyp)\n \t\truntime_throw(\"runtime: invalid objtyp\");\n \tif(n < 0 || (typ->__size > 0 && (uintptr)n > (MaxMem/typ->__size)))\n \t\truntime_panicstring(\"runtime: allocation size out of range\");\n-\treturn runtime_mallocgc(typ->__size*n, (uintptr)typ | objtyp, typ->kind&KindNoPointers ? FlagNoScan : 0);\n+\treturn runtime_mallocgc(typ->__size*n, (uintptr)typ | objtyp, typ->kind&kindNoPointers ? FlagNoScan : 0);\n }\n \n // same as runtime_new, but callable from C\n@@ -955,7 +952,7 @@ func SetFinalizer(obj Eface, finalizer Eface) {\n \tif(!runtime_mlookup(obj.__object, &base, &size, nil) || obj.__object != base) {\n \t\t// As an implementation detail we allow to set finalizers for an inner byte\n \t\t// of an object if it could come from tiny alloc (see mallocgc for details).\n-\t\tif(ot->__element_type == nil || (ot->__element_type->kind&KindNoPointers) == 0 || ot->__element_type->__size >= TinySize) {\n+\t\tif(ot->__element_type == nil || (ot->__element_type->kind&kindNoPointers) == 0 || ot->__element_type->__size >= TinySize) {\n \t\t\truntime_printf(\"runtime.SetFinalizer: pointer not at beginning of allocated block (%p)\\n\", obj.__object);\n \t\t\tgoto throw;\n \t\t}"}, {"sha": "1efbbbeb1021e493c962840d7bf1fdd4d3756462", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -391,7 +391,7 @@ struct MCentral\n \tLock;\n \tint32 sizeclass;\n \tMSpan nonempty;\t// list of spans with a free object\n-\tMSpan empty;\t// list of spans with no free objects (or cached in an MCache)\n+\tMSpan mempty;\t// list of spans with no free objects (or cached in an MCache)\n \tint32 nfree;\t// # of objects available in nonempty spans\n };\n \n@@ -478,8 +478,10 @@ extern\tint32\truntime_checking;\n void\truntime_markspan(void *v, uintptr size, uintptr n, bool leftover);\n void\truntime_unmarkspan(void *v, uintptr size);\n void\truntime_purgecachedstats(MCache*);\n-void*\truntime_cnew(const Type*);\n-void*\truntime_cnewarray(const Type*, intgo);\n+void*\truntime_cnew(const Type*)\n+\t  __asm__(GOSYM_PREFIX \"runtime.newobject\");\n+void*\truntime_cnewarray(const Type*, intgo)\n+\t  __asm__(GOSYM_PREFIX \"runtime.newarray\");\n void\truntime_tracealloc(void*, uintptr, uintptr);\n void\truntime_tracefree(void*, uintptr);\n void\truntime_tracegc(void);"}, {"sha": "e4b8456dc363a69f163b12cd2733db743e7f13e3", "filename": "libgo/runtime/map.goc", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fmap.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fmap.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmap.goc?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,72 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package runtime\n-#include \"runtime.h\"\n-#include \"map.h\"\n-\n-typedef struct __go_map Hmap;\n-typedef struct __go_hash_iter hiter;\n-\n-/* Access a value in a map, returning a value and a presence indicator.  */\n-\n-func mapaccess2(t *MapType, h *Hmap, key *byte, val *byte) (present bool) {\n-\tbyte *mapval;\n-\tsize_t valsize;\n-\n-\tmapval = __go_map_index(h, key, 0);\n-\tvalsize = t->__val_type->__size;\n-\tif (mapval == nil) {\n-\t\t__builtin_memset(val, 0, valsize);\n-\t\tpresent = 0;\n-\t} else {\n-\t\t__builtin_memcpy(val, mapval, valsize);\n-\t\tpresent = 1;\n-\t}\n-}\n-\n-/* Optionally assign a value to a map (m[k] = v, p).  */\n-\n-func mapassign2(h *Hmap, key *byte, val *byte, p bool) {\n-\tif (!p) {\n-\t\t__go_map_delete(h, key);\n-\t} else {\n-\t\tbyte *mapval;\n-\t\tsize_t valsize;\n-\n-\t\tmapval = __go_map_index(h, key, 1);\n-\t\tvalsize = h->__descriptor->__map_descriptor->__val_type->__size;\n-\t\t__builtin_memcpy(mapval, val, valsize);\n-\t}\n-}\n-\n-/* Delete a key from a map.  */\n-\n-func mapdelete(h *Hmap, key *byte) {\n-\t__go_map_delete(h, key);\n-}\n-\n-/* Initialize a range over a map.  */\n-\n-func mapiterinit(h *Hmap, it *hiter) {\n-\t__go_mapiterinit(h, it);\n-}\n-\n-/* Move to the next iteration, updating *HITER.  */\n-\n-func mapiternext(it *hiter) {\n-\t__go_mapiternext(it);\n-}\n-\n-/* Get the key of the current iteration.  */\n-\n-func mapiter1(it *hiter, key *byte) {\n-\t__go_mapiter1(it, key);\n-}\n-\n-/* Get the key and value of the current iteration.  */\n-\n-func mapiter2(it *hiter, key *byte, val *byte) {\n-\t__go_mapiter2(it, key, val);\n-}"}, {"sha": "0c587bb2afac96e2b12ee40bfb5a1cffae73c0de", "filename": "libgo/runtime/map.h", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/812b1403a88cea3257e120f3234576f236c0921d/libgo%2Fruntime%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmap.h?ref=812b1403a88cea3257e120f3234576f236c0921d", "patch": "@@ -1,87 +0,0 @@\n-/* map.h -- the map type for Go.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-#include <stdint.h>\n-\n-#include \"go-type.h\"\n-\n-/* A map descriptor is what we need to manipulate the map.  This is\n-   constant for a given map type.  */\n-\n-struct __go_map_descriptor\n-{\n-  /* A pointer to the type descriptor for the type of the map itself.  */\n-  const struct __go_map_type *__map_descriptor;\n-\n-  /* A map entry is a struct with three fields:\n-       map_entry_type *next_entry;\n-       key_type key;\n-       value_type value;\n-     This is the size of that struct.  */\n-  uintptr_t __entry_size;\n-\n-  /* The offset of the key field in a map entry struct.  */\n-  uintptr_t __key_offset;\n-\n-  /* The offset of the value field in a map entry struct (the value\n-     field immediately follows the key field, but there may be some\n-     bytes inserted for alignment).  */\n-  uintptr_t __val_offset;\n-};\n-\n-struct __go_map\n-{\n-  /* The constant descriptor for this map.  */\n-  const struct __go_map_descriptor *__descriptor;\n-\n-  /* The number of elements in the hash table.  */\n-  uintptr_t __element_count;\n-\n-  /* The number of entries in the __buckets array.  */\n-  uintptr_t __bucket_count;\n-\n-  /* Each bucket is a pointer to a linked list of map entries.  */\n-  void **__buckets;\n-};\n-\n-/* For a map iteration the compiled code will use a pointer to an\n-   iteration structure.  The iteration structure will be allocated on\n-   the stack.  The Go code must allocate at least enough space.  */\n-\n-struct __go_hash_iter\n-{\n-  /* A pointer to the current entry.  This will be set to NULL when\n-     the range has completed.  The Go will test this field, so it must\n-     be the first one in the structure.  */\n-  const void *entry;\n-  /* The map we are iterating over.  */\n-  const struct __go_map *map;\n-  /* A pointer to the next entry in the current bucket.  This permits\n-     deleting the current entry.  This will be NULL when we have seen\n-     all the entries in the current bucket.  */\n-  const void *next_entry;\n-  /* The bucket index of the current and next entry.  */\n-  uintptr_t bucket;\n-};\n-\n-extern struct __go_map *__go_new_map (const struct __go_map_descriptor *,\n-\t\t\t\t      uintptr_t);\n-\n-extern uintptr_t __go_map_next_prime (uintptr_t);\n-\n-extern void *__go_map_index (struct __go_map *, const void *, _Bool);\n-\n-extern void __go_map_delete (struct __go_map *, const void *);\n-\n-extern void __go_mapiterinit (const struct __go_map *, struct __go_hash_iter *);\n-\n-extern void __go_mapiternext (struct __go_hash_iter *);\n-\n-extern void __go_mapiter1 (struct __go_hash_iter *it, unsigned char *key);\n-\n-extern void __go_mapiter2 (struct __go_hash_iter *it, unsigned char *key,\n-\t\t\t   unsigned char *val);"}, {"sha": "491cac5330f10375314211a8f6458e799e150619", "filename": "libgo/runtime/mcentral.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmcentral.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmcentral.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmcentral.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -8,7 +8,7 @@\n //\n // The MCentral doesn't actually contain the list of free objects; the MSpan does.\n // Each MCentral is two lists of MSpans: those with free objects (c->nonempty)\n-// and those that are completely allocated (c->empty).\n+// and those that are completely allocated (c->mempty).\n //\n // TODO(rsc): tcmalloc uses a \"transfer cache\" to split the list\n // into sections of class_to_transfercount[sizeclass] objects\n@@ -28,7 +28,7 @@ runtime_MCentral_Init(MCentral *c, int32 sizeclass)\n {\n \tc->sizeclass = sizeclass;\n \truntime_MSpanList_Init(&c->nonempty);\n-\truntime_MSpanList_Init(&c->empty);\n+\truntime_MSpanList_Init(&c->mempty);\n }\n \n // Allocate a span to use in an MCache.\n@@ -58,13 +58,13 @@ runtime_MCentral_CacheSpan(MCentral *c)\n \t\tgoto havespan;\n \t}\n \n-\tfor(s = c->empty.next; s != &c->empty; s = s->next) {\n+\tfor(s = c->mempty.next; s != &c->mempty; s = s->next) {\n \t\tif(s->sweepgen == sg-2 && runtime_cas(&s->sweepgen, sg-2, sg-1)) {\n \t\t\t// we have an empty span that requires sweeping,\n \t\t\t// sweep it and see if we can free some space in it\n \t\t\truntime_MSpanList_Remove(s);\n \t\t\t// swept spans are at the end of the list\n-\t\t\truntime_MSpanList_InsertBack(&c->empty, s);\n+\t\t\truntime_MSpanList_InsertBack(&c->mempty, s);\n \t\t\truntime_unlock(c);\n \t\t\truntime_MSpan_Sweep(s);\n \t\t\truntime_lock(c);\n@@ -96,7 +96,7 @@ runtime_MCentral_CacheSpan(MCentral *c)\n \t\truntime_throw(\"freelist empty\");\n \tc->nfree -= n;\n \truntime_MSpanList_Remove(s);\n-\truntime_MSpanList_InsertBack(&c->empty, s);\n+\truntime_MSpanList_InsertBack(&c->mempty, s);\n \ts->incache = true;\n \truntime_unlock(c);\n \treturn s;"}, {"sha": "341544cb97064a3c3046ed43ce41a0275aaeabe5", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 14, "deletions": 17, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -69,9 +69,6 @@\n typedef struct __go_map Hmap;\n // Type aka __go_type_descriptor\n #define string __reflection\n-#define KindPtr GO_PTR\n-#define KindNoPointers GO_NO_POINTERS\n-#define kindMask GO_CODE_MASK\n // PtrType aka __go_ptr_type\n #define elem __element_type\n \n@@ -216,7 +213,7 @@ static void\taddstackroots(G *gp, Workbuf **wbufp);\n \n static struct {\n \tuint64\tfull;  // lock-free list of full blocks\n-\tuint64\tempty; // lock-free list of empty blocks\n+\tuint64\twempty; // lock-free list of empty blocks\n \tbyte\tpad0[CacheLineSize]; // prevents false-sharing between full/empty and nproc/nwait\n \tuint32\tnproc;\n \tint64\ttstart;\n@@ -943,16 +940,16 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t// eface->__object\n \t\t\tif((byte*)eface->__object >= arena_start && (byte*)eface->__object < arena_used) {\n \t\t\t\tif(__go_is_pointer_type(t)) {\n-\t\t\t\t\tif((t->__code & KindNoPointers))\n+\t\t\t\t\tif((t->__code & kindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobj = eface->__object;\n-\t\t\t\t\tif((t->__code & kindMask) == KindPtr) {\n+\t\t\t\t\tif((t->__code & kindMask) == kindPtr) {\n \t\t\t\t\t\t// Only use type information if it is a pointer-containing type.\n \t\t\t\t\t\t// This matches the GC programs written by cmd/gc/reflect.c's\n \t\t\t\t\t\t// dgcsym1 in case TPTR32/case TPTR64. See rationale there.\n \t\t\t\t\t\tet = ((const PtrType*)t)->elem;\n-\t\t\t\t\t\tif(!(et->__code & KindNoPointers))\n+\t\t\t\t\t\tif(!(et->__code & kindNoPointers))\n \t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n@@ -981,16 +978,16 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\tif((byte*)iface->__object >= arena_start && (byte*)iface->__object < arena_used) {\n \t\t\t\tt = (const Type*)iface->tab[0];\n \t\t\t\tif(__go_is_pointer_type(t)) {\n-\t\t\t\t\tif((t->__code & KindNoPointers))\n+\t\t\t\t\tif((t->__code & kindNoPointers))\n \t\t\t\t\t\tcontinue;\n \n \t\t\t\t\tobj = iface->__object;\n-\t\t\t\t\tif((t->__code & kindMask) == KindPtr) {\n+\t\t\t\t\tif((t->__code & kindMask) == kindPtr) {\n \t\t\t\t\t\t// Only use type information if it is a pointer-containing type.\n \t\t\t\t\t\t// This matches the GC programs written by cmd/gc/reflect.c's\n \t\t\t\t\t\t// dgcsym1 in case TPTR32/case TPTR64. See rationale there.\n \t\t\t\t\t\tet = ((const PtrType*)t)->elem;\n-\t\t\t\t\t\tif(!(et->__code & KindNoPointers))\n+\t\t\t\t\t\tif(!(et->__code & kindNoPointers))\n \t\t\t\t\t\t\tobjti = (uintptr)((const PtrType*)t)->elem->__gc;\n \t\t\t\t\t}\n \t\t\t\t} else {\n@@ -1101,7 +1098,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\t\t}\n \t\t\tif(markonly(chan)) {\n \t\t\t\tchantype = (ChanType*)pc[2];\n-\t\t\t\tif(!(chantype->elem->__code & KindNoPointers)) {\n+\t\t\t\tif(!(chantype->elem->__code & kindNoPointers)) {\n \t\t\t\t\t// Start chanProg.\n \t\t\t\t\tchan_ret = pc+3;\n \t\t\t\t\tpc = chanProg+1;\n@@ -1114,7 +1111,7 @@ scanblock(Workbuf *wbuf, bool keepworking)\n \t\tcase GC_CHAN:\n \t\t\t// There are no heap pointers in struct Hchan,\n \t\t\t// so we can ignore the leading sizeof(Hchan) bytes.\n-\t\t\tif(!(chantype->elem->__code & KindNoPointers)) {\n+\t\t\tif(!(chantype->elem->__code & kindNoPointers)) {\n \t\t\t\t// Channel's buffer follows Hchan immediately in memory.\n \t\t\t\t// Size of buffer (cap(c)) is second int in the chan struct.\n \t\t\t\tchancap = ((uintgo*)chan)[1];\n@@ -1377,7 +1374,7 @@ getempty(Workbuf *b)\n {\n \tif(b != nil)\n \t\truntime_lfstackpush(&work.full, &b->node);\n-\tb = (Workbuf*)runtime_lfstackpop(&work.empty);\n+\tb = (Workbuf*)runtime_lfstackpop(&work.wempty);\n \tif(b == nil) {\n \t\t// Need to allocate.\n \t\truntime_lock(&work);\n@@ -1402,7 +1399,7 @@ putempty(Workbuf *b)\n \tif(CollectStats)\n \t\truntime_xadd64(&gcstats.putempty, 1);\n \n-\truntime_lfstackpush(&work.empty, &b->node);\n+\truntime_lfstackpush(&work.wempty, &b->node);\n }\n \n // Get a full work buffer off the work.full list, or return nil.\n@@ -1416,7 +1413,7 @@ getfull(Workbuf *b)\n \t\truntime_xadd64(&gcstats.getfull, 1);\n \n \tif(b != nil)\n-\t\truntime_lfstackpush(&work.empty, &b->node);\n+\t\truntime_lfstackpush(&work.wempty, &b->node);\n \tb = (Workbuf*)runtime_lfstackpop(&work.full);\n \tif(b != nil || work.nproc == 1)\n \t\treturn b;\n@@ -2129,7 +2126,7 @@ runtime_gc(int32 force)\n \t// The atomic operations are not atomic if the uint64s\n \t// are not aligned on uint64 boundaries. This has been\n \t// a problem in the past.\n-\tif((((uintptr)&work.empty) & 7) != 0)\n+\tif((((uintptr)&work.wempty) & 7) != 0)\n \t\truntime_throw(\"runtime: gc work buffer is misaligned\");\n \tif((((uintptr)&work.full) & 7) != 0)\n \t\truntime_throw(\"runtime: gc work buffer is misaligned\");\n@@ -2522,7 +2519,7 @@ runfinq(void* dummy __attribute__ ((unused)))\n \n \t\t\t\tf = &fb->fin[i];\n \t\t\t\tfint = ((const Type**)f->ft->__in.array)[0];\n-\t\t\t\tif((fint->__code & kindMask) == KindPtr) {\n+\t\t\t\tif((fint->__code & kindMask) == kindPtr) {\n \t\t\t\t\t// direct use of pointer\n \t\t\t\t\tparam = &f->arg;\n \t\t\t\t} else if(((const InterfaceType*)fint)->__methods.__count == 0) {"}, {"sha": "04a5b98772c543f65314791b647536f24837e507", "filename": "libgo/runtime/mheap.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmheap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fmheap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmheap.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -878,7 +878,7 @@ runtime_MHeap_SplitSpan(MHeap *h, MSpan *s)\n \n \t// remove the span from whatever list it is in now\n \tif(s->sizeclass > 0) {\n-\t\t// must be in h->central[x].empty\n+\t\t// must be in h->central[x].mempty\n \t\tc = &h->central[s->sizeclass];\n \t\truntime_lock(c);\n \t\truntime_MSpanList_Remove(s);\n@@ -937,7 +937,7 @@ runtime_MHeap_SplitSpan(MHeap *h, MSpan *s)\n \t\tc = &h->central[s->sizeclass];\n \t\truntime_lock(c);\n \t\t// swept spans are at the end of the list\n-\t\truntime_MSpanList_InsertBack(&c->empty, s);\n+\t\truntime_MSpanList_InsertBack(&c->mempty, s);\n \t\truntime_unlock(c);\n \t} else {\n \t\t// Swept spans are at the end of lists."}, {"sha": "d493b54a5093d3314fe02eeb4d3fa571475c5623", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -194,6 +194,22 @@ runtime_throw(const char *s)\n \truntime_exit(1);\t// even more not reached\n }\n \n+void throw(String) __asm__ (GOSYM_PREFIX \"runtime.throw\");\n+void\n+throw(String s)\n+{\n+\tM *mp;\n+\n+\tmp = runtime_m();\n+\tif(mp->throwing == 0)\n+\t\tmp->throwing = 1;\n+\truntime_startpanic();\n+\truntime_printf(\"fatal error: %S\\n\", s);\n+\truntime_dopanic(0);\n+\t*(int32*)0 = 0;\t// not reached\n+\truntime_exit(1);\t// even more not reached\n+}\n+\n void\n runtime_panicstring(const char *s)\n {"}, {"sha": "32d0fb2a7be7c2c8a5f17490be290ba90c552b76", "filename": "libgo/runtime/proc.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fproc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fproc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fproc.c?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -546,9 +546,9 @@ static struct __go_channel_type chan_bool_type_descriptor =\n       /* __hash */\n       0, /* This value doesn't matter.  */\n       /* __hashfn */\n-      &__go_type_hash_error_descriptor,\n+      NULL,\n       /* __equalfn */\n-      &__go_type_equal_error_descriptor,\n+      NULL,\n       /* __gc */\n       NULL, /* This value doesn't matter */\n       /* __reflection */\n@@ -2753,7 +2753,7 @@ static void\n procresize(int32 new)\n {\n \tint32 i, old;\n-\tbool empty;\n+\tbool pempty;\n \tG *gp;\n \tP *p;\n \n@@ -2781,14 +2781,14 @@ procresize(int32 new)\n \t// collect all runnable goroutines in global queue preserving FIFO order\n \t// FIFO order is required to ensure fairness even during frequent GCs\n \t// see http://golang.org/issue/7126\n-\tempty = false;\n-\twhile(!empty) {\n-\t\tempty = true;\n+\tpempty = false;\n+\twhile(!pempty) {\n+\t\tpempty = true;\n \t\tfor(i = 0; i < old; i++) {\n \t\t\tp = runtime_allp[i];\n \t\t\tif(p->runqhead == p->runqtail)\n \t\t\t\tcontinue;\n-\t\t\tempty = false;\n+\t\t\tpempty = false;\n \t\t\t// pop from tail of local queue\n \t\t\tp->runqtail--;\n \t\t\tgp = (G*)p->runq[p->runqtail%nelem(p->runq)];"}, {"sha": "dc00b421f996c4976793ee7f794e12a56b6debe6", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4a2bb7fcb0c8507b958afb3d22ddfeeba494148a/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=4a2bb7fcb0c8507b958afb3d22ddfeeba494148a", "patch": "@@ -376,7 +376,7 @@ void\truntime_mprofinit(void);\n int32\truntime_mcount(void);\n int32\truntime_gcount(void);\n void\truntime_mcall(void(*)(G*));\n-uint32\truntime_fastrand1(void);\n+uint32\truntime_fastrand1(void) __asm__ (GOSYM_PREFIX \"runtime.fastrand1\");\n int32\truntime_timediv(int64, int32, int32*);\n int32\truntime_round2(int32 x); // round x up to a power of 2.\n "}]}