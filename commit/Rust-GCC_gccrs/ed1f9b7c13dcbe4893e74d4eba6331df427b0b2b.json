{"sha": "ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQxZjliN2MxM2RjYmU0ODkzZTc0ZDRlYmE2MzMxZGY0MjdiMGIyYg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-24T11:07:23Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-24T11:07:23Z"}, "message": "2003-06-24  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/SocketImpl.java\n\t(shutdownInput): Made it non-abstract method throwing an exception\n\tlike in SUNs JRE.\n\t(shutdownOutput): Likewise.\n\t* java/net/SocketInputStream.java,\n\tjava/net/SocketOutputStream.java:\n\tNew files from classpath.\n\nFrom-SVN: r68416", "tree": {"sha": "25cb46e9206c0022e8522131fb3ad4f7e8db3ad5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25cb46e9206c0022e8522131fb3ad4f7e8db3ad5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/comments", "author": null, "committer": null, "parents": [{"sha": "59b8aa7e50e650fd4d0fd7b7af991ca7a5d5ca67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59b8aa7e50e650fd4d0fd7b7af991ca7a5d5ca67", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59b8aa7e50e650fd4d0fd7b7af991ca7a5d5ca67"}], "stats": {"total": 389, "additions": 387, "deletions": 2}, "files": [{"sha": "e7ec7dc6084f71b8ceda0c4a8a5a23c175146215", "filename": "libjava/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "patch": "@@ -1,3 +1,13 @@\n+2003-06-24  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/SocketImpl.java\n+\t(shutdownInput): Made it non-abstract method throwing an exception\n+\tlike in SUNs JRE.\n+\t(shutdownOutput): Likewise.\n+\t* java/net/SocketInputStream.java,\n+\tjava/net/SocketOutputStream.java:\n+\tNew files from classpath.\n+\n 2003-06-24  Michael Koch  <konqueror@gmx.de>\n \n \t* java/awt/Font.java,"}, {"sha": "14101513e0999541232d4d24b4ccdf9cdb4a023f", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "patch": "@@ -287,13 +287,19 @@ public String toString()\n    *\n    * @exception IOException if an error occurs\n    */\n-  protected abstract void shutdownInput () throws IOException;\n+  protected void shutdownInput () throws IOException\n+  {\n+    throw new IOException (\"Not implemented in this socket class\");\n+  }\n \n   /**\n    * Shut down the output side of this socket.  Subsequent writes will\n    * fail with an IOException.\n    *\n    * @exception IOException if an error occurs\n    */\n-  protected abstract void shutdownOutput () throws IOException;\n+  protected void shutdownOutput () throws IOException\n+  {\n+    throw new IOException (\"Not implemented in this socket class\");\n+  }\n }"}, {"sha": "f2d4d399218b89d49c75c86a24a6cbf656876627", "filename": "libjava/java/net/SocketInputStream.java", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketInputStream.java?ref=ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "patch": "@@ -0,0 +1,204 @@\n+/* SocketInputStream.java -- An InputStream for Sockets\n+   Copyright (C) 1998, 2000, 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package java.net;\n+\n+import java.io.InputStream;\n+import java.io.IOException;\n+\n+/**\n+  * This class contains an implementation of <code>InputStream</code> for \n+  * sockets.  It in an internal only class used by <code>PlainSocketImpl</code>.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+class SocketInputStream extends InputStream\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * The PlainSocketImpl object this stream is associated with\n+  */\n+private PlainSocketImpl impl;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Builds an instance of this class from a PlainSocketImpl object\n+  */\n+protected\n+SocketInputStream(PlainSocketImpl impl)\n+{\n+  this.impl = impl;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * Returns the number of bytes available to be read before blocking\n+  */\n+public int\n+available() throws IOException\n+{\n+  return(impl.available());\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Determines if \"mark\" functionality is supported on this stream.  For\n+  * sockets, this is always false.  Note that the superclass default is\n+  * false, but it is overridden out of safety concerns and/or paranoia.\n+  */\n+public boolean\n+markSupported()\n+{\n+  return(false);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Do nothing mark method since we don't support this functionality.  Again,\n+  * overriding out of paranoia.\n+  *\n+  * @param readlimit In theory, the number of bytes we can read before the mark becomes invalid\n+  */\n+public void\n+mark(int readlimit)\n+{\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Since we don't support mark, this method always throws an exception\n+  *\n+  * @exception IOException Everytime since we don't support this functionality\n+  */\n+public void\n+reset() throws IOException\n+{\n+  throw new IOException(\"Socket InputStreams do not support mark/reset\");\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * This method not only closes the stream, it closes the underlying socket\n+  * (and thus any connection) and invalidates any other Input/Output streams\n+  * for the underlying impl object\n+  */\n+public void\n+close() throws IOException\n+{\n+  impl.close();\n+} \n+\n+/*************************************************************************/\n+\n+/**\n+  * Reads the next byte of data and returns it as an int.  \n+  *\n+  * @return The byte read (as an int) or -1 if end of stream);\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public int\n+read() throws IOException\n+{\n+  byte buf[] = new byte[1];\n+\n+  int bytes_read = read(buf, 0, buf.length);\n+ \n+  if (bytes_read != -1)\n+    return(buf[0] & 0xFF);\n+  else\n+    return(-1);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Reads up to buf.length bytes of data into the caller supplied buffer.\n+  *\n+  * @return The actual number of bytes read or -1 if end of stream\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public int\n+read(byte[] buf) throws IOException\n+{\n+  return(read(buf, 0, buf.length));\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Reads up to len bytes of data into the caller supplied buffer starting\n+  * at offset bytes from the start of the buffer\n+  *\n+  * @return The number of bytes actually read or -1 if end of stream\n+  *\n+  * @exception IOException If an error occurs.\n+  */\n+public int\n+read(byte[] buf, int offset, int len) throws IOException\n+{\n+  int bytes_read = impl.read(buf, offset, len);\n+  if (bytes_read == 0)\n+    return(-1);\n+\n+  return(bytes_read);\n+}\n+\n+} // class SocketInputStream\n+"}, {"sha": "7ce19ae0ef6e3e958250dafefdcd64c702b10d1b", "filename": "libjava/java/net/SocketOutputStream.java", "status": "added", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketOutputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b/libjava%2Fjava%2Fnet%2FSocketOutputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketOutputStream.java?ref=ed1f9b7c13dcbe4893e74d4eba6331df427b0b2b", "patch": "@@ -0,0 +1,165 @@\n+/* SocketOutputStream.java -- OutputStream for PlainSocketImpl\n+   Copyright (C) 1998,2000 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.net;\n+\n+import java.io.OutputStream;\n+import java.io.IOException;\n+\n+/**\n+  * This class is used internally by <code>PlainSocketImpl</code> to be the \n+  * <code>OutputStream</code> subclass returned by its \n+  * <code>getOutputStream method</code>.  It expects only to  be used in that \n+  * context.\n+  *\n+  * @author Aaron M. Renn (arenn@urbanophile.com)\n+  */\n+class SocketOutputStream extends OutputStream\n+{\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Variables\n+ */\n+\n+/**\n+  * The PlainSocketImpl object this stream is associated with\n+  */\n+private PlainSocketImpl impl;\n+\n+/*************************************************************************/\n+\n+/*\n+ * Constructors\n+ */\n+\n+/**\n+  * Build an instance of this class from a PlainSocketImpl object\n+  */\n+protected\n+SocketOutputStream(PlainSocketImpl impl)\n+{\n+  this.impl = impl;\n+}\n+\n+/*************************************************************************/\n+\n+/*\n+ * Instance Methods\n+ */\n+\n+/**\n+  * This method closes the stream and the underlying socket connection.  This\n+  * action also effectively closes any other InputStream or OutputStream\n+  * object associated with the connection.\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+close() throws IOException\n+{\n+  impl.close();\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Hmmm, we don't seem to have a flush() method in Socket impl, so just\n+  * return for now, but this might need to be looked at later.\n+  *\n+  * @exception IOException Can't happen\n+  */\n+public void\n+flush() throws IOException\n+{\n+  return;\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Writes a byte (passed in as an int) to the given output stream\n+  * \n+  * @param b The byte to write\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+write(int b) throws IOException\n+{\n+  byte buf[] = new byte[1];\n+\n+  Integer i = new Integer(b);\n+  buf[0] = i.byteValue();\n+\n+  write(buf, 0, buf.length);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Write an array of bytes to the output stream\n+  *\n+  * @param buf The array of bytes to write\n+  *\n+  * @exception IOException If an error occurs\n+  */\n+public void\n+write(byte[] buf) throws IOException\n+{\n+  write(buf, 0, buf.length);\n+}\n+\n+/*************************************************************************/\n+\n+/**\n+  * Writes len number of bytes from the array buf to the stream starting\n+  * at offset bytes into the buffer.\n+  *\n+  * @param buf The buffer\n+  * @param offset Offset into the buffer to start writing from\n+  * @param len The number of bytes to write\n+  */\n+public void\n+write(byte[] buf, int offset, int len) throws IOException\n+{\n+  impl.write(buf, offset, len);\n+}\n+\n+} // class SocketOutputStream\n+"}]}