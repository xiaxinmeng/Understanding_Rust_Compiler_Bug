{"sha": "7da92c086fa7008497a8f959418c7ce05e048d24", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhOTJjMDg2ZmE3MDA4NDk3YThmOTU5NDE4YzdjZTA1ZTA0OGQyNA==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-08-10T15:21:18Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-08-10T15:21:18Z"}, "message": "c-lex.c (parse_float, yylex): For -Wtraditional, issue a warning about non-traditional numeric constant suffixes.\n\n\t* c-lex.c (parse_float, yylex): For -Wtraditional, issue a\n\twarning about non-traditional numeric constant suffixes.\n\n\t* cppexp.c (parse_number): Likewise.\n\n\t* invoke.texi: (-Wtraditional): Document new behavior.\n\nFrom-SVN: r35607", "tree": {"sha": "30a07535a16520798c29038412313aa0bf2aecde", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/30a07535a16520798c29038412313aa0bf2aecde"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7da92c086fa7008497a8f959418c7ce05e048d24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da92c086fa7008497a8f959418c7ce05e048d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da92c086fa7008497a8f959418c7ce05e048d24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da92c086fa7008497a8f959418c7ce05e048d24/comments", "author": null, "committer": null, "parents": [{"sha": "b498d041faed872eb206182e619ebcc22327a2c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b498d041faed872eb206182e619ebcc22327a2c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b498d041faed872eb206182e619ebcc22327a2c9"}], "stats": {"total": 26, "additions": 26, "deletions": 0}, "files": [{"sha": "01468781b4cdf887c854de0d5c49cdc50cd64366", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7da92c086fa7008497a8f959418c7ce05e048d24", "patch": "@@ -1,3 +1,12 @@\n+2000-08-10  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* c-lex.c (parse_float, yylex): For -Wtraditional, issue a\n+\twarning about non-traditional numeric constant suffixes.\n+\n+\t* cppexp.c (parse_number): Likewise.\n+\n+\t* invoke.texi: (-Wtraditional): Document new behavior.\n+\n Thu Aug 10 00:11:04 2000  Ovidiu Predescu  <ovidiu@cup.hp.com>\n \n \t* gthr-posix.h: Include auto-host.h. Conditionally include"}, {"sha": "77442e3164870b32bcd4df15a70c4fdb6cc1cda5", "filename": "gcc/c-lex.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=7da92c086fa7008497a8f959418c7ce05e048d24", "patch": "@@ -1109,12 +1109,16 @@ parse_float (data)\n \tcase 'f': case 'F':\n \t  if (fflag)\n \t    error (\"more than one `f' in numeric constant\");\n+\t  else if (warn_traditional && !in_system_header)\n+\t    warning (\"traditional C rejects the `%c' suffix\", args->c);\n \t  fflag = 1;\n \t  break;\n \n \tcase 'l': case 'L':\n \t  if (lflag)\n \t    error (\"more than one `l' in numeric constant\");\n+\t  else if (warn_traditional && !in_system_header)\n+\t    warning (\"traditional C rejects the `%c' suffix\", args->c);\n \t  lflag = 1;\n \t  break;\n \n@@ -1773,6 +1777,8 @@ yylex ()\n \t\t  {\n \t\t    if (spec_unsigned)\n \t\t      error (\"two `u's in integer constant\");\n+ \t\t    else if (warn_traditional && !in_system_header)\n+ \t\t      warning (\"traditional C rejects the `%c' suffix\", c);\n \t\t    spec_unsigned = 1;\n \t\t    if (spec_long)\n \t\t      suffix_lu = 1;"}, {"sha": "9631526b18ed51c109cf83a94b2bd4d6a5f280dd", "filename": "gcc/cppexp.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=7da92c086fa7008497a8f959418c7ce05e048d24", "patch": "@@ -218,6 +218,8 @@ parse_number (pfile, tok)\n \tgoto invalid_suffix;\n       op.unsignedp = sufftab[i].u;\n \n+      if (CPP_WTRADITIONAL (pfile) && sufftab[i].u)\n+\tcpp_warning (pfile, \"traditional C rejects the `U' suffix\");\n       if (CPP_OPTION (pfile, c89) && sufftab[i].l == 2)\n \tSYNTAX_ERROR (\"too many 'l' suffixes in integer constant\");\n     }"}, {"sha": "14dd1096b0251264cb3dab6988f4768418541721", "filename": "gcc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7da92c086fa7008497a8f959418c7ce05e048d24/gcc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finvoke.texi?ref=7da92c086fa7008497a8f959418c7ce05e048d24", "patch": "@@ -1838,6 +1838,15 @@ omitted.  This is done under the assumption that the zero initializer in\n user code appears conditioned on e.g. @code{__STDC__} to avoid missing\n initializer warnings and relies on default initialization to zero in the\n traditional C case.\n+\n+@item\n+The `U' integer constant suffix, or the `F' or `L' floating point\n+constant suffixes.  (Traditonal C does support the `L' suffix on integer\n+constants.)  Note, these suffixes appear in macros defined in the system\n+headers of most modern systems, e.g. the _MIN/_MAX macros in limits.h.\n+Use of these macros can lead to spurious warnings as they do not\n+necessarily reflect whether the code in question is any less portable to\n+traditional C given that suitable backup definitions are provided.\n @end itemize\n \n @item -Wundef"}]}