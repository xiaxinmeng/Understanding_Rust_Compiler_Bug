{"sha": "1d88851ce9576ee755b9a47f076d434e8e1057cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQ4ODg1MWNlOTU3NmVlNzU1YjlhNDdmMDc2ZDQzNGU4ZTEwNTdjZg==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2019-07-01T13:35:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2019-07-01T13:35:07Z"}, "message": "[Ada] Clean up of GNAT.Sets\n\n------------\n-- Source --\n------------\n\n--  operations.adb\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith GNAT;        use GNAT;\nwith GNAT.Sets;   use GNAT.Sets;\n\nprocedure Operations is\n   function Hash (Key : Integer) return Bucket_Range_Type;\n\n   package Integer_Sets is new Membership_Sets\n     (Element_Type => Integer,\n      \"=\"          => \"=\",\n      Hash         => Hash);\n   use Integer_Sets;\n\n   procedure Check_Empty\n     (Caller    : String;\n      S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n   --  present in set S, and that the set's length is 0.\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      S      : in out Membership_Set);\n   --  Ensure that all mutation operations of set S are locked\n\n   procedure Check_Present\n     (Caller    : String;\n      S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n   --  in set S.\n\n   procedure Check_Unlocked_Mutations\n     (Caller : String;\n      S      : in out Membership_Set);\n   --  Ensure that all mutation operations of set S are unlocked\n\n   procedure Populate\n     (S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer);\n   --  Add elements in the range Low_Elem .. High_Elem in set S\n\n   procedure Test_Contains\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive);\n   --  Verify that Contains properly identifies that elements in the range\n   --  Low_Elem .. High_Elem are within a set. Init_Size denotes the initial\n   --  size of the set.\n\n   procedure Test_Create;\n   --  Verify that all set operations fail on a non-created set\n\n   procedure Test_Delete\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive);\n   --  Verify that Delete properly removes elements in the range Low_Elem ..\n   --  High_Elem from a set. Init_Size denotes the initial size of the set.\n\n   procedure Test_Is_Empty;\n   --  Verify that Is_Empty properly returns this status of a set\n\n   procedure Test_Iterate;\n   --  Verify that iterators properly manipulate mutation operations\n\n   procedure Test_Iterate_Empty;\n   --  Verify that iterators properly manipulate mutation operations of an\n   --  empty set.\n\n   procedure Test_Iterate_Forced\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive);\n   --  Verify that an iterator that is forcefully advanced by Next properly\n   --  unlocks the mutation operations of a set. Init_Size denotes the initial\n   --  size of the set.\n\n   procedure Test_Size;\n   --  Verify that Size returns the correct size of a set\n\n   -----------------\n   -- Check_Empty --\n   -----------------\n\n   procedure Check_Empty\n     (Caller    : String;\n      S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Siz : constant Natural := Size (S);\n\n   begin\n      for Elem in Low_Elem .. High_Elem loop\n         if Contains (S, Elem) then\n            Put_Line (\"ERROR: \" & Caller & \": extra element\" & Elem'Img);\n         end if;\n      end loop;\n\n      if Siz /= 0 then\n         Put_Line (\"ERROR: \" & Caller & \": wrong size\");\n         Put_Line (\"expected: 0\");\n         Put_Line (\"got     :\" & Siz'Img);\n      end if;\n   end Check_Empty;\n\n   ----------------------------\n   -- Check_Locked_Mutations --\n   ----------------------------\n\n   procedure Check_Locked_Mutations\n     (Caller : String;\n      S      : in out Membership_Set)\n   is\n   begin\n      begin\n         Delete (S, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Delete: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Delete: unexpected exception\");\n      end;\n\n      begin\n         Destroy (S);\n         Put_Line (\"ERROR: \" & Caller & \": Destroy: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Destroy: unexpected exception\");\n      end;\n\n      begin\n         Insert (S, 1);\n         Put_Line (\"ERROR: \" & Caller & \": Insert: no exception raised\");\n      exception\n         when Iterated =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: \" & Caller & \": Insert: unexpected exception\");\n      end;\n   end Check_Locked_Mutations;\n\n   -------------------\n   -- Check_Present --\n   -------------------\n\n   procedure Check_Present\n     (Caller    : String;\n      S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n      Elem : Integer;\n      Iter : Iterator;\n\n   begin\n      Iter := Iterate (S);\n      for Exp_Elem in Low_Elem .. High_Elem loop\n         Next (Iter, Elem);\n\n         if Elem /= Exp_Elem then\n            Put_Line (\"ERROR: \" & Caller & \": Check_Present: wrong element\");\n            Put_Line (\"expected:\" & Exp_Elem'Img);\n            Put_Line (\"got     :\" & Elem'Img);\n         end if;\n      end loop;\n\n      --  At this point all elements should have been accounted for. Check for\n      --  extra elements.\n\n      while Has_Next (Iter) loop\n         Next (Iter, Elem);\n         Put_Line\n           (\"ERROR: \" & Caller & \": Check_Present: extra element\" & Elem'Img);\n      end loop;\n\n   exception\n      when Iterator_Exhausted =>\n         Put_Line\n           (\"ERROR: \"\n            & Caller\n            & \"Check_Present: incorrect number of elements\");\n   end Check_Present;\n\n   ------------------------------\n   -- Check_Unlocked_Mutations --\n   ------------------------------\n\n   procedure Check_Unlocked_Mutations\n     (Caller : String;\n      S      : in out Membership_Set)\n   is\n   begin\n      Delete (S, 1);\n      Insert (S, 1);\n   end Check_Unlocked_Mutations;\n\n   ----------\n   -- Hash --\n   ----------\n\n   function Hash (Key : Integer) return Bucket_Range_Type is\n   begin\n      return Bucket_Range_Type (Key);\n   end Hash;\n\n   --------------\n   -- Populate --\n   --------------\n\n   procedure Populate\n     (S         : Membership_Set;\n      Low_Elem  : Integer;\n      High_Elem : Integer)\n   is\n   begin\n      for Elem in Low_Elem .. High_Elem loop\n         Insert (S, Elem);\n      end loop;\n   end Populate;\n\n   -------------------\n   -- Test_Contains --\n   -------------------\n\n   procedure Test_Contains\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive)\n   is\n      Low_Bogus  : constant Integer := Low_Elem  - 1;\n      High_Bogus : constant Integer := High_Elem + 1;\n\n      S : Membership_Set := Create (Init_Size);\n\n   begin\n      Populate (S, Low_Elem, High_Elem);\n\n      --  Ensure that the elements are contained in the set\n\n      for Elem in Low_Elem .. High_Elem loop\n         if not Contains (S, Elem) then\n            Put_Line\n              (\"ERROR: Test_Contains: element\" & Elem'Img & \" not in set\");\n         end if;\n      end loop;\n\n      --  Ensure that arbitrary elements which were not inserted in the set are\n      --  not contained in the set.\n\n      if Contains (S, Low_Bogus) then\n         Put_Line\n           (\"ERROR: Test_Contains: element\" & Low_Bogus'Img & \" in set\");\n      end if;\n\n      if Contains (S, High_Bogus) then\n         Put_Line\n           (\"ERROR: Test_Contains: element\" & High_Bogus'Img & \" in set\");\n      end if;\n\n      Destroy (S);\n   end Test_Contains;\n\n   -----------------\n   -- Test_Create --\n   -----------------\n\n   procedure Test_Create is\n      Count : Natural;\n      Flag  : Boolean;\n      Iter  : Iterator;\n      S     : Membership_Set;\n\n   begin\n      --  Ensure that every routine defined in the API fails on a set which\n      --  has not been created yet.\n\n      begin\n         Flag := Contains (S, 1);\n         Put_Line (\"ERROR: Test_Create: Contains: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Contains: unexpected exception\");\n      end;\n\n      begin\n         Delete (S, 1);\n         Put_Line (\"ERROR: Test_Create: Delete: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Delete: unexpected exception\");\n      end;\n\n      begin\n         Insert (S, 1);\n         Put_Line (\"ERROR: Test_Create: Insert: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Insert: unexpected exception\");\n      end;\n\n      begin\n         Flag := Is_Empty (S);\n         Put_Line (\"ERROR: Test_Create: Is_Empty: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Is_Empty: unexpected exception\");\n      end;\n\n      begin\n         Iter := Iterate (S);\n         Put_Line (\"ERROR: Test_Create: Iterate: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Iterate: unexpected exception\");\n      end;\n\n      begin\n         Count := Size (S);\n         Put_Line (\"ERROR: Test_Create: Size: no exception raised\");\n      exception\n         when Not_Created =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Create: Size: unexpected exception\");\n      end;\n   end Test_Create;\n\n   -----------------\n   -- Test_Delete --\n   -----------------\n\n   procedure Test_Delete\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive)\n   is\n      Iter : Iterator;\n      S    : Membership_Set := Create (Init_Size);\n\n   begin\n      Populate (S, Low_Elem, High_Elem);\n\n      --  Delete all even elements\n\n      for Elem in Low_Elem .. High_Elem loop\n         if Elem mod 2 = 0 then\n            Delete (S, Elem);\n         end if;\n      end loop;\n\n      --  Ensure that all remaining odd elements are present in the set\n\n      for Elem in Low_Elem .. High_Elem loop\n         if Elem mod 2 /= 0 and then not Contains (S, Elem) then\n            Put_Line (\"ERROR: Test_Delete: missing element\" & Elem'Img);\n         end if;\n      end loop;\n\n      --  Delete all odd elements\n\n      for Elem in Low_Elem .. High_Elem loop\n         if Elem mod 2 /= 0 then\n            Delete (S, Elem);\n         end if;\n      end loop;\n\n      --  At this point the set should be completely empty\n\n      Check_Empty\n        (Caller    => \"Test_Delete\",\n         S         => S,\n         Low_Elem  => Low_Elem,\n         High_Elem => High_Elem);\n\n      Destroy (S);\n   end Test_Delete;\n\n   -------------------\n   -- Test_Is_Empty --\n   -------------------\n\n   procedure Test_Is_Empty is\n      S : Membership_Set := Create (8);\n\n   begin\n      if not Is_Empty (S) then\n         Put_Line (\"ERROR: Test_Is_Empty: set is not empty\");\n      end if;\n\n      Insert (S, 1);\n\n      if Is_Empty (S) then\n         Put_Line (\"ERROR: Test_Is_Empty: set is empty\");\n      end if;\n\n      Delete (S, 1);\n\n      if not Is_Empty (S) then\n         Put_Line (\"ERROR: Test_Is_Empty: set is not empty\");\n      end if;\n\n      Destroy (S);\n   end Test_Is_Empty;\n\n   ------------------\n   -- Test_Iterate --\n   ------------------\n\n   procedure Test_Iterate is\n      Elem   : Integer;\n      Iter_1 : Iterator;\n      Iter_2 : Iterator;\n      S      : Membership_Set := Create (5);\n\n   begin\n      Populate (S, 1, 5);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the set.\n\n      Iter_1 := Iterate (S);\n\n      --  Ensure that every mutation routine defined in the API fails on a set\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         S      => S);\n\n      --  Obtain another iterator\n\n      Iter_2 := Iterate (S);\n\n      --  Ensure that every mutation is still locked\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         S      => S);\n\n      --  Exhaust the first itertor\n\n      while Has_Next (Iter_1) loop\n         Next (Iter_1, Elem);\n      end loop;\n\n      --  Ensure that every mutation is still locked\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate\",\n         S      => S);\n\n      --  Exhaust the second itertor\n\n      while Has_Next (Iter_2) loop\n         Next (Iter_2, Elem);\n      end loop;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate\",\n         S      => S);\n\n      Destroy (S);\n   end Test_Iterate;\n\n   ------------------------\n   -- Test_Iterate_Empty --\n   ------------------------\n\n   procedure Test_Iterate_Empty is\n      Elem : Integer;\n      Iter : Iterator;\n      S    : Membership_Set := Create (5);\n\n   begin\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the set.\n\n      Iter := Iterate (S);\n\n      --  Ensure that every mutation routine defined in the API fails on a set\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Empty\",\n         S      => S);\n\n      --  Attempt to iterate over the elements\n\n      while Has_Next (Iter) loop\n         Next (Iter, Elem);\n\n         Put_Line\n           (\"ERROR: Test_Iterate_Empty: element\" & Elem'Img & \" exists\");\n      end loop;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate_Empty\",\n         S      => S);\n\n      Destroy (S);\n   end Test_Iterate_Empty;\n\n   -------------------------\n   -- Test_Iterate_Forced --\n   -------------------------\n\n   procedure Test_Iterate_Forced\n     (Low_Elem  : Integer;\n      High_Elem : Integer;\n      Init_Size : Positive)\n   is\n      Elem : Integer;\n      Iter : Iterator;\n      S    : Membership_Set := Create (Init_Size);\n\n   begin\n      Populate (S, Low_Elem, High_Elem);\n\n      --  Obtain an iterator. This action must lock all mutation operations of\n      --  the set.\n\n      Iter := Iterate (S);\n\n      --  Ensure that every mutation routine defined in the API fails on a set\n      --  with at least one outstanding iterator.\n\n      Check_Locked_Mutations\n        (Caller => \"Test_Iterate_Forced\",\n         S      => S);\n\n      --  Forcibly advance the iterator until it raises an exception\n\n      begin\n         for Guard in Low_Elem .. High_Elem + 1 loop\n            Next (Iter, Elem);\n         end loop;\n\n         Put_Line\n           (\"ERROR: Test_Iterate_Forced: Iterator_Exhausted not raised\");\n      exception\n         when Iterator_Exhausted =>\n            null;\n         when others =>\n            Put_Line (\"ERROR: Test_Iterate_Forced: unexpected exception\");\n      end;\n\n      --  Ensure that all mutation operations are once again callable\n\n      Check_Unlocked_Mutations\n        (Caller => \"Test_Iterate_Forced\",\n         S      => S);\n\n      Destroy (S);\n   end Test_Iterate_Forced;\n\n   ---------------\n   -- Test_Size --\n   ---------------\n\n   procedure Test_Size is\n      S   : Membership_Set := Create (6);\n      Siz : Natural;\n\n   begin\n      Siz := Size (S);\n\n      if Siz /= 0 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 0\");\n         Put_Line (\"got     :\" & Siz'Img);\n      end if;\n\n      Populate (S, 1, 2);\n      Siz := Size (S);\n\n      if Siz /= 2 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 2\");\n         Put_Line (\"got     :\" & Siz'Img);\n      end if;\n\n      Populate (S, 3, 6);\n      Siz := Size (S);\n\n      if Siz /= 6 then\n         Put_Line (\"ERROR: Test_Size: wrong size\");\n         Put_Line (\"expected: 6\");\n         Put_Line (\"got     :\" & Siz'Img);\n      end if;\n\n      Destroy (S);\n   end Test_Size;\n\n--  Start of processing for Operations\n\nbegin\n   Test_Contains\n     (Low_Elem  => 1,\n      High_Elem => 5,\n      Init_Size => 5);\n\n   Test_Create;\n\n   Test_Delete\n     (Low_Elem  => 1,\n      High_Elem => 10,\n      Init_Size => 10);\n\n   Test_Is_Empty;\n   Test_Iterate;\n   Test_Iterate_Empty;\n\n   Test_Iterate_Forced\n     (Low_Elem  => 1,\n      High_Elem => 5,\n      Init_Size => 5);\n\n   Test_Size;\nend Operations;\n\n----------------------------\n-- Compilation and output --\n----------------------------\n\n$ gnatmake -q operations.adb -largs -lgmem\n$ ./operations\n$ gnatmem operations > leaks.txt\n$ grep -c \"non freed allocations\" leaks.txt\n0\n\n2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n\ngcc/ada/\n\n\t* libgnat/g-sets.adb: Use type Membership_Set rathern than\n\tInstance in various routines.\n\t* libgnat/g-sets.ads: Change type Instance to Membership_Set.\n\tUpdate various routines that mention the type.\n\ngcc/testsuite/\n\n\t* gnat.dg/sets1.adb: Update.\n\nFrom-SVN: r272862", "tree": {"sha": "747084b74e3b8148e6bbdb5b94e820ab1717cd9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/747084b74e3b8148e6bbdb5b94e820ab1717cd9b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d88851ce9576ee755b9a47f076d434e8e1057cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d88851ce9576ee755b9a47f076d434e8e1057cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d88851ce9576ee755b9a47f076d434e8e1057cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d88851ce9576ee755b9a47f076d434e8e1057cf/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "02fd808ca20ce82ad63e5a760b5835b87342ba6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02fd808ca20ce82ad63e5a760b5835b87342ba6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02fd808ca20ce82ad63e5a760b5835b87342ba6f"}], "stats": {"total": 163, "additions": 100, "deletions": 63}, "files": [{"sha": "05aaf2315b65d4213d2b36dc3da2041c99c3cd53", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=1d88851ce9576ee755b9a47f076d434e8e1057cf", "patch": "@@ -1,3 +1,10 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* libgnat/g-sets.adb: Use type Membership_Set rathern than\n+\tInstance in various routines.\n+\t* libgnat/g-sets.ads: Change type Instance to Membership_Set.\n+\tUpdate various routines that mention the type.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* libgnat/g-lists.adb: Use type Doubly_Linked_List rather than"}, {"sha": "149018165dd02410775af7f779622baedb5bdb8e", "filename": "gcc/ada/libgnat/g-sets.adb", "status": "modified", "additions": 36, "deletions": 26, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2Flibgnat%2Fg-sets.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.adb?ref=1d88851ce9576ee755b9a47f076d434e8e1057cf", "patch": "@@ -31,37 +31,40 @@\n \n package body GNAT.Sets is\n \n-   --------------------\n-   -- Membership_Set --\n-   --------------------\n+   ---------------------\n+   -- Membership_Sets --\n+   ---------------------\n \n-   package body Membership_Set is\n+   package body Membership_Sets is\n \n       --------------\n       -- Contains --\n       --------------\n \n-      function Contains (S : Instance; Elem : Element_Type) return Boolean is\n+      function Contains\n+        (S    : Membership_Set;\n+         Elem : Element_Type) return Boolean\n+      is\n       begin\n-         return Hashed_Set.Get (Hashed_Set.Instance (S), Elem);\n+         return Hashed_Set.Get (Hashed_Set.Dynamic_Hash_Table (S), Elem);\n       end Contains;\n \n       ------------\n       -- Create --\n       ------------\n \n-      function Create (Initial_Size : Positive) return Instance is\n+      function Create (Initial_Size : Positive) return Membership_Set is\n       begin\n-         return Instance (Hashed_Set.Create (Initial_Size));\n+         return Membership_Set (Hashed_Set.Create (Initial_Size));\n       end Create;\n \n       ------------\n       -- Delete --\n       ------------\n \n-      procedure Delete (S : Instance; Elem : Element_Type) is\n+      procedure Delete (S : Membership_Set; Elem : Element_Type) is\n       begin\n-         Hashed_Set.Delete (Hashed_Set.Instance (S), Elem);\n+         Hashed_Set.Delete (Hashed_Set.Dynamic_Hash_Table (S), Elem);\n       end Delete;\n \n       -------------\n@@ -78,9 +81,9 @@ package body GNAT.Sets is\n       -- Destroy --\n       -------------\n \n-      procedure Destroy (S : in out Instance) is\n+      procedure Destroy (S : in out Membership_Set) is\n       begin\n-         Hashed_Set.Destroy (Hashed_Set.Instance (S));\n+         Hashed_Set.Destroy (Hashed_Set.Dynamic_Hash_Table (S));\n       end Destroy;\n \n       --------------\n@@ -96,34 +99,41 @@ package body GNAT.Sets is\n       -- Insert --\n       ------------\n \n-      procedure Insert (S : Instance; Elem : Element_Type) is\n+      procedure Insert\n+        (S    : Membership_Set;\n+         Elem : Element_Type)\n+      is\n       begin\n-         Hashed_Set.Put (Hashed_Set.Instance (S), Elem, True);\n+         Hashed_Set.Put (Hashed_Set.Dynamic_Hash_Table (S), Elem, True);\n       end Insert;\n \n       --------------\n       -- Is_Empty --\n       --------------\n \n-      function Is_Empty (S : Instance) return Boolean is\n+      function Is_Empty (S : Membership_Set) return Boolean is\n       begin\n-         return Hashed_Set.Is_Empty (Hashed_Set.Instance (S));\n+         return Hashed_Set.Is_Empty (Hashed_Set.Dynamic_Hash_Table (S));\n       end Is_Empty;\n \n       -------------\n       -- Iterate --\n       -------------\n \n-      function Iterate (S : Instance) return Iterator is\n+      function Iterate (S : Membership_Set) return Iterator is\n       begin\n-         return Iterator (Hashed_Set.Iterate (Hashed_Set.Instance (S)));\n+         return\n+           Iterator (Hashed_Set.Iterate (Hashed_Set.Dynamic_Hash_Table (S)));\n       end Iterate;\n \n       ----------\n       -- Next --\n       ----------\n \n-      procedure Next (Iter : in out Iterator; Elem : out Element_Type) is\n+      procedure Next\n+        (Iter : in out Iterator;\n+         Elem : out Element_Type)\n+      is\n       begin\n          Hashed_Set.Next (Hashed_Set.Iterator (Iter), Elem);\n       end Next;\n@@ -132,28 +142,28 @@ package body GNAT.Sets is\n       -- Present --\n       -------------\n \n-      function Present (S : Instance) return Boolean is\n+      function Present (S : Membership_Set) return Boolean is\n       begin\n-         return Hashed_Set.Present (Hashed_Set.Instance (S));\n+         return Hashed_Set.Present (Hashed_Set.Dynamic_Hash_Table (S));\n       end Present;\n \n       -----------\n       -- Reset --\n       -----------\n \n-      procedure Reset (S : Instance) is\n+      procedure Reset (S : Membership_Set) is\n       begin\n-         Hashed_Set.Reset (Hashed_Set.Instance (S));\n+         Hashed_Set.Reset (Hashed_Set.Dynamic_Hash_Table (S));\n       end Reset;\n \n       ----------\n       -- Size --\n       ----------\n \n-      function Size (S : Instance) return Natural is\n+      function Size (S : Membership_Set) return Natural is\n       begin\n-         return Hashed_Set.Size (Hashed_Set.Instance (S));\n+         return Hashed_Set.Size (Hashed_Set.Dynamic_Hash_Table (S));\n       end Size;\n-   end Membership_Set;\n+   end Membership_Sets;\n \n end GNAT.Sets;"}, {"sha": "1898e2686e7fef950cba3ee50726889482ec13b6", "filename": "gcc/ada/libgnat/g-sets.ads", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Fada%2Flibgnat%2Fg-sets.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-sets.ads?ref=1d88851ce9576ee755b9a47f076d434e8e1057cf", "patch": "@@ -47,7 +47,7 @@ package GNAT.Sets is\n    --\n    --  The following use pattern must be employed with this set:\n    --\n-   --    Set : Instance := Create (<some size>);\n+   --    Set : Membership_Set := Create (<some size>);\n    --\n    --    <various operations>\n    --\n@@ -65,7 +65,7 @@ package GNAT.Sets is\n       with function Hash (Key : Element_Type) return Bucket_Range_Type;\n       --  Map an arbitrary key into the range of buckets\n \n-   package Membership_Set is\n+   package Membership_Sets is\n \n       --------------------\n       -- Set operations --\n@@ -74,44 +74,50 @@ package GNAT.Sets is\n       --  The following type denotes a membership set handle. Each instance\n       --  must be created using routine Create.\n \n-      type Instance is private;\n-      Nil : constant Instance;\n+      type Membership_Set is private;\n+      Nil : constant Membership_Set;\n \n-      function Contains (S : Instance; Elem : Element_Type) return Boolean;\n+      function Contains\n+        (S    : Membership_Set;\n+         Elem : Element_Type) return Boolean;\n       --  Determine whether membership set S contains element Elem\n \n-      function Create (Initial_Size : Positive) return Instance;\n+      function Create (Initial_Size : Positive) return Membership_Set;\n       --  Create a new membership set with bucket capacity Initial_Size. This\n       --  routine must be called at the start of the membership set's lifetime.\n \n-      procedure Delete (S : Instance; Elem : Element_Type);\n+      procedure Delete\n+        (S    : Membership_Set;\n+         Elem : Element_Type);\n       --  Delete element Elem from membership set S. The routine has no effect\n       --  if the element is not present in the membership set. This action will\n       --  raise Iterated if the membership set has outstanding iterators.\n \n-      procedure Destroy (S : in out Instance);\n+      procedure Destroy (S : in out Membership_Set);\n       --  Destroy the contents of membership set S, rendering it unusable. This\n       --  routine must be called at the end of the membership set's lifetime.\n       --  This action will raise Iterated if the hash table has outstanding\n       --  iterators.\n \n-      procedure Insert (S : Instance; Elem : Element_Type);\n+      procedure Insert\n+        (S    : Membership_Set;\n+         Elem : Element_Type);\n       --  Insert element Elem in membership set S. The routine has no effect\n       --  if the element is already present in the membership set. This action\n       --  will raise Iterated if the membership set has outstanding iterators.\n \n-      function Is_Empty (S : Instance) return Boolean;\n+      function Is_Empty (S : Membership_Set) return Boolean;\n       --  Determine whether set S is empty\n \n-      function Present (S : Instance) return Boolean;\n+      function Present (S : Membership_Set) return Boolean;\n       --  Determine whether set S exists\n \n-      procedure Reset (S : Instance);\n+      procedure Reset (S : Membership_Set);\n       --  Destroy the contents of membership set S, and reset it to its initial\n       --  created state. This action will raise Iterated if the membership set\n       --  has outstanding iterators.\n \n-      function Size (S : Instance) return Natural;\n+      function Size (S : Membership_Set) return Natural;\n       --  Obtain the number of elements in membership set S\n \n       -------------------------\n@@ -132,7 +138,7 @@ package GNAT.Sets is\n \n       type Iterator is private;\n \n-      function Iterate (S : Instance) return Iterator;\n+      function Iterate (S : Membership_Set) return Iterator;\n       --  Obtain an iterator over the elements of membership set S. This action\n       --  locks all mutation functionality of the associated membership set.\n \n@@ -152,7 +158,7 @@ package GNAT.Sets is\n       procedure Destroy (B : in out Boolean);\n       --  Destroy boolean B\n \n-      package Hashed_Set is new Dynamic_HTable\n+      package Hashed_Set is new Dynamic_Hash_Tables\n         (Key_Type              => Element_Type,\n          Value_Type            => Boolean,\n          No_Value              => False,\n@@ -164,10 +170,10 @@ package GNAT.Sets is\n          Destroy_Value         => Destroy,\n          Hash                  => Hash);\n \n-      type Instance is new Hashed_Set.Instance;\n-      Nil : constant Instance := Instance (Hashed_Set.Nil);\n+      type Membership_Set is new Hashed_Set.Dynamic_Hash_Table;\n+      Nil : constant Membership_Set := Membership_Set (Hashed_Set.Nil);\n \n       type Iterator is new Hashed_Set.Iterator;\n-   end Membership_Set;\n+   end Membership_Sets;\n \n end GNAT.Sets;"}, {"sha": "7e5f38c91134e54206cfed56a906afe9f318c899", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d88851ce9576ee755b9a47f076d434e8e1057cf", "patch": "@@ -1,3 +1,7 @@\n+2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* gnat.dg/sets1.adb: Update.\n+\n 2019-07-01  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* gnat.dg/linkedlist.adb: Update."}, {"sha": "42bad38210b9ea8707d302a328ed019a2a436cce", "filename": "gcc/testsuite/gnat.dg/sets1.adb", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d88851ce9576ee755b9a47f076d434e8e1057cf/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsets1.adb?ref=1d88851ce9576ee755b9a47f076d434e8e1057cf", "patch": "@@ -7,36 +7,40 @@ with GNAT.Sets;   use GNAT.Sets;\n procedure Sets1 is\n    function Hash (Key : Integer) return Bucket_Range_Type;\n \n-   package Integer_Sets is new Membership_Set\n+   package Integer_Sets is new Membership_Sets\n      (Element_Type => Integer,\n       \"=\"          => \"=\",\n       Hash         => Hash);\n    use Integer_Sets;\n \n    procedure Check_Empty\n      (Caller    : String;\n-      S         : Instance;\n+      S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Ensure that none of the elements in the range Low_Elem .. High_Elem are\n    --  present in set S, and that the set's length is 0.\n \n-   procedure Check_Locked_Mutations (Caller : String; S : in out Instance);\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      S      : in out Membership_Set);\n    --  Ensure that all mutation operations of set S are locked\n \n    procedure Check_Present\n      (Caller    : String;\n-      S         : Instance;\n+      S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Ensure that all elements in the range Low_Elem .. High_Elem are present\n    --  in set S.\n \n-   procedure Check_Unlocked_Mutations (Caller : String; S : in out Instance);\n+   procedure Check_Unlocked_Mutations\n+     (Caller : String;\n+      S      : in out Membership_Set);\n    --  Ensure that all mutation operations of set S are unlocked\n \n    procedure Populate\n-     (S         : Instance;\n+     (S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer);\n    --  Add elements in the range Low_Elem .. High_Elem in set S\n@@ -86,7 +90,7 @@ procedure Sets1 is\n \n    procedure Check_Empty\n      (Caller    : String;\n-      S         : Instance;\n+      S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -110,7 +114,10 @@ procedure Sets1 is\n    -- Check_Locked_Mutations --\n    ----------------------------\n \n-   procedure Check_Locked_Mutations (Caller : String; S : in out Instance) is\n+   procedure Check_Locked_Mutations\n+     (Caller : String;\n+      S      : in out Membership_Set)\n+   is\n    begin\n       begin\n          Delete (S, 1);\n@@ -149,7 +156,7 @@ procedure Sets1 is\n \n    procedure Check_Present\n      (Caller    : String;\n-      S         : Instance;\n+      S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -189,7 +196,10 @@ procedure Sets1 is\n    -- Check_Unlocked_Mutations --\n    ------------------------------\n \n-   procedure Check_Unlocked_Mutations (Caller : String; S : in out Instance) is\n+   procedure Check_Unlocked_Mutations\n+     (Caller : String;\n+      S      : in out Membership_Set)\n+   is\n    begin\n       Delete (S, 1);\n       Insert (S, 1);\n@@ -209,7 +219,7 @@ procedure Sets1 is\n    --------------\n \n    procedure Populate\n-     (S         : Instance;\n+     (S         : Membership_Set;\n       Low_Elem  : Integer;\n       High_Elem : Integer)\n    is\n@@ -231,7 +241,7 @@ procedure Sets1 is\n       Low_Bogus  : constant Integer := Low_Elem  - 1;\n       High_Bogus : constant Integer := High_Elem + 1;\n \n-      S : Instance := Create (Init_Size);\n+      S : Membership_Set := Create (Init_Size);\n \n    begin\n       Populate (S, Low_Elem, High_Elem);\n@@ -269,7 +279,7 @@ procedure Sets1 is\n       Count : Natural;\n       Flag  : Boolean;\n       Iter  : Iterator;\n-      S     : Instance;\n+      S     : Membership_Set;\n \n    begin\n       --  Ensure that every routine defined in the API fails on a set which\n@@ -346,7 +356,7 @@ procedure Sets1 is\n       Init_Size : Positive)\n    is\n       Iter : Iterator;\n-      S    : Instance := Create (Init_Size);\n+      S    : Membership_Set := Create (Init_Size);\n \n    begin\n       Populate (S, Low_Elem, High_Elem);\n@@ -391,7 +401,7 @@ procedure Sets1 is\n    -------------------\n \n    procedure Test_Is_Empty is\n-      S : Instance := Create (8);\n+      S : Membership_Set := Create (8);\n \n    begin\n       if not Is_Empty (S) then\n@@ -421,7 +431,7 @@ procedure Sets1 is\n       Elem   : Integer;\n       Iter_1 : Iterator;\n       Iter_2 : Iterator;\n-      S      : Instance := Create (5);\n+      S      : Membership_Set := Create (5);\n \n    begin\n       Populate (S, 1, 5);\n@@ -482,7 +492,7 @@ procedure Sets1 is\n    procedure Test_Iterate_Empty is\n       Elem : Integer;\n       Iter : Iterator;\n-      S    : Instance := Create (5);\n+      S    : Membership_Set := Create (5);\n \n    begin\n       --  Obtain an iterator. This action must lock all mutation operations of\n@@ -526,7 +536,7 @@ procedure Sets1 is\n    is\n       Elem : Integer;\n       Iter : Iterator;\n-      S    : Instance := Create (Init_Size);\n+      S    : Membership_Set := Create (Init_Size);\n \n    begin\n       Populate (S, Low_Elem, High_Elem);\n@@ -573,7 +583,7 @@ procedure Sets1 is\n    ---------------\n \n    procedure Test_Size is\n-      S   : Instance := Create (6);\n+      S   : Membership_Set := Create (6);\n       Siz : Natural;\n \n    begin"}]}