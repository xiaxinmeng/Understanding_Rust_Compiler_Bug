{"sha": "abf96035efcd29f72edbed125a2ac426f370a22c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWJmOTYwMzVlZmNkMjlmNzJlZGJlZDEyNWEyYWM0MjZmMzcwYTIyYw==", "commit": {"author": {"name": "Prachi Godbole", "email": "prachigodbole@gcc.gnu.org", "date": "2015-05-19T05:06:03Z"}, "committer": {"name": "Prachi Godbole", "email": "prachigodbole@gcc.gnu.org", "date": "2015-05-19T05:06:03Z"}, "message": "mips.md (JOIN_MODE): New mode iterator.\n\ngcc/\n\t* config/mips/mips.md (JOIN_MODE): New mode iterator.\n\t(join2_load_Store<JOIN_MODE:mode>): New pattern.\n\t(join2_loadhi): Likewise.\n\t(define_peehole2): Add peephole2 patterns to join 2 HI/SI/SF/DF-mode\n\tload-load and store-stores.\n\t* config/mips/mips.opt (mload-store-pairs): New option.\n\t(TARGET_LOAD_STORE_PAIRS): New macro.\n\t* config/mips/mips.h (ENABLE_LD_ST_PAIRS): Likewise.\n\t* config/mips/mips-protos.h (mips_load_store_bonding_p): New prototype.\n\t* config/mips/mips.c (mips_load_store_bonding_p): New function.\n\ngcc/testsuite/\n\t* gcc.target/mips/p5600-bonding.c : New file.\n\nFrom-SVN: r223334", "tree": {"sha": "e51744c3c32fd1034653e5178845f10919db4250", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e51744c3c32fd1034653e5178845f10919db4250"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/abf96035efcd29f72edbed125a2ac426f370a22c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf96035efcd29f72edbed125a2ac426f370a22c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abf96035efcd29f72edbed125a2ac426f370a22c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abf96035efcd29f72edbed125a2ac426f370a22c/comments", "author": null, "committer": null, "parents": [{"sha": "fab27f52895115e2986e7bc6a3c376411f847df7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fab27f52895115e2986e7bc6a3c376411f847df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fab27f52895115e2986e7bc6a3c376411f847df7"}], "stats": {"total": 220, "additions": 220, "deletions": 0}, "files": [{"sha": "b36ce1d9593066981a6ddfe8c3bc4e76c6b19bec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -1,3 +1,16 @@\n+2015-05-19  Sameera Deshpande  <Sameera.Deshpande@imgtec.com>\n+\n+\t* config/mips/mips.md (JOIN_MODE): New mode iterator.\n+\t(join2_load_Store<JOIN_MODE:mode>): New pattern.\n+\t(join2_loadhi): Likewise.\n+\t(define_peehole2): Add peephole2 patterns to join 2 HI/SI/SF/DF-mode\n+\tload-load and store-stores.\n+\t* config/mips/mips.opt (mload-store-pairs): New option.\n+\t(TARGET_LOAD_STORE_PAIRS): New macro.\n+\t* config/mips/mips.h (ENABLE_LD_ST_PAIRS): Likewise.\n+\t* config/mips/mips-protos.h (mips_load_store_bonding_p): New prototype.\n+\t* config/mips/mips.c (mips_load_store_bonding_p): New function.\n+\n 2015-05-19  Mikhail Maltsev  <maltsevm@gmail.com>\n \n \t* bb-reorder.c (fix_up_fall_thru_edges): Use std::swap instead of"}, {"sha": "244eb8d51cba0fb8bfcfb69316769ceae0903491", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -360,6 +360,7 @@ extern bool mips_epilogue_uses (unsigned int);\n extern void mips_final_prescan_insn (rtx_insn *, rtx *, int);\n extern int mips_trampoline_code_size (void);\n extern void mips_function_profiler (FILE *);\n+extern bool mips_load_store_bonding_p (rtx *, machine_mode, bool);\n \n typedef rtx (*mulsidi3_gen_fn) (rtx, rtx, rtx);\n #ifdef RTX_CODE"}, {"sha": "a3165cad8c69643e9e2e291ca49f462ac2ecc4de", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -18231,6 +18231,66 @@ umips_load_store_pair_p_1 (bool load_p, bool swap_p,\n   return true;\n }\n \n+bool\n+mips_load_store_bonding_p (rtx *operands, machine_mode mode, bool load_p)\n+{\n+  rtx reg1, reg2, mem1, mem2, base1, base2;\n+  enum reg_class rc1, rc2;\n+  HOST_WIDE_INT offset1, offset2;\n+\n+  if (load_p)\n+    {\n+      reg1 = operands[0];\n+      reg2 = operands[2];\n+      mem1 = operands[1];\n+      mem2 = operands[3];\n+    }\n+  else\n+    {\n+      reg1 = operands[1];\n+      reg2 = operands[3];\n+      mem1 = operands[0];\n+      mem2 = operands[2];\n+    }\n+\n+  if (mips_address_insns (XEXP (mem1, 0), mode, false) == 0\n+      || mips_address_insns (XEXP (mem2, 0), mode, false) == 0)\n+    return false;\n+\n+  mips_split_plus (XEXP (mem1, 0), &base1, &offset1);\n+  mips_split_plus (XEXP (mem2, 0), &base2, &offset2);\n+\n+  /* Base regs do not match.  */\n+  if (!REG_P (base1) || !rtx_equal_p (base1, base2))\n+    return false;\n+\n+  /* Either of the loads is clobbering base register.  It is legitimate to bond\n+     loads if second load clobbers base register.  However, hardware does not\n+     support such bonding.  */\n+  if (load_p\n+      && (REGNO (reg1) == REGNO (base1)\n+\t  || (REGNO (reg2) == REGNO (base1))))\n+    return false;\n+\n+  /* Loading in same registers.  */\n+  if (load_p\n+      && REGNO (reg1) == REGNO (reg2))\n+    return false;\n+\n+  /* The loads/stores are not of same type.  */\n+  rc1 = REGNO_REG_CLASS (REGNO (reg1));\n+  rc2 = REGNO_REG_CLASS (REGNO (reg2));\n+  if (rc1 != rc2\n+      && !reg_class_subset_p (rc1, rc2)\n+      && !reg_class_subset_p (rc2, rc1))\n+    return false;\n+\n+  if (abs (offset1 - offset2) != GET_MODE_SIZE (mode))\n+    return false;\n+\n+  return true;\n+}\n+\n /* OPERANDS describes the operands to a pair of SETs, in the order\n    dest1, src1, dest2, src2.  Return true if the operands can be used\n    in an LWP or SWP instruction; LOAD_P says which.  */"}, {"sha": "2fa47249b5463cfbcc747a2c0a9732d1a1f787d2", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -3162,3 +3162,10 @@ extern GTY(()) struct target_globals *mips16_globals;\n #define STANDARD_STARTFILE_PREFIX_1 \"/lib64/\"\n #define STANDARD_STARTFILE_PREFIX_2 \"/usr/lib64/\"\n #endif\n+\n+/* Load store bonding is not supported by micromips and fix_24k.  The\n+   performance can be degraded for those targets.  Hence, do not bond for\n+   micromips or fix_24k.  */\n+#define ENABLE_LD_ST_PAIRS \\\n+  (TARGET_LOAD_STORE_PAIRS && TUNE_P5600 \\\n+   && !TARGET_MICROMIPS && !TARGET_FIX_24K)"}, {"sha": "0a23fa214b0ef489ef138bd8dda989f7b2511c1a", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -754,6 +754,11 @@\n \n (define_mode_iterator MOVEP1 [SI SF])\n (define_mode_iterator MOVEP2 [SI SF])\n+(define_mode_iterator JOIN_MODE [HI\n+\t\t\t\t SI\n+\t\t\t\t (SF \"TARGET_HARD_FLOAT\")\n+\t\t\t\t (DF \"TARGET_HARD_FLOAT\n+\t\t\t\t      && TARGET_DOUBLE_FLOAT\")])\n \n ;; This mode iterator allows :HILO to be used as the mode of the\n ;; concatenated HI and LO registers.\n@@ -7404,6 +7409,112 @@\n   { return MIPS_CALL (\"jal\", operands, 0, -1); }\n   [(set_attr \"type\" \"call\")\n    (set_attr \"insn_count\" \"3\")])\n+\n+;; Match paired HI/SI/SF/DFmode load/stores.\n+(define_insn \"*join2_load_store<JOIN_MODE:mode>\"\n+  [(set (match_operand:JOIN_MODE 0 \"nonimmediate_operand\" \"=d,f,m,m\")\n+\t(match_operand:JOIN_MODE 1 \"nonimmediate_operand\" \"m,m,d,f\"))\n+   (set (match_operand:JOIN_MODE 2 \"nonimmediate_operand\" \"=d,f,m,m\")\n+\t(match_operand:JOIN_MODE 3 \"nonimmediate_operand\" \"m,m,d,f\"))]\n+  \"ENABLE_LD_ST_PAIRS && reload_completed\"\n+  {\n+    bool load_p = (which_alternative == 0 || which_alternative == 1);\n+    /* Reg-renaming pass reuses base register if it is dead after bonded loads.\n+       Hardware does not bond those loads, even when they are consecutive.\n+       However, order of the loads need to be checked for correctness.  */\n+    if (!load_p || !reg_overlap_mentioned_p (operands[0], operands[1]))\n+      {\n+\toutput_asm_insn (mips_output_move (operands[0], operands[1]),\n+\t\t\t operands);\n+\toutput_asm_insn (mips_output_move (operands[2], operands[3]),\n+\t\t\t &operands[2]);\n+      }\n+    else\n+      {\n+\toutput_asm_insn (mips_output_move (operands[2], operands[3]),\n+\t\t\t &operands[2]);\n+\toutput_asm_insn (mips_output_move (operands[0], operands[1]),\n+\t\t\t operands);\n+      }\n+    return \"\";\n+  }\n+  [(set_attr \"move_type\" \"load,fpload,store,fpstore\")\n+   (set_attr \"insn_count\" \"2,2,2,2\")])\n+\n+;; 2 HI/SI/SF/DF loads are joined.\n+;; P5600 does not support bonding of two LBs, hence QI mode is not included.\n+;; The loads must be non-volatile as they might be reordered at the time of asm\n+;; generation.\n+(define_peephole2\n+  [(set (match_operand:JOIN_MODE 0 \"register_operand\")\n+\t(match_operand:JOIN_MODE 1 \"non_volatile_mem_operand\"))\n+   (set (match_operand:JOIN_MODE 2 \"register_operand\")\n+\t(match_operand:JOIN_MODE 3 \"non_volatile_mem_operand\"))]\n+  \"ENABLE_LD_ST_PAIRS\n+   && mips_load_store_bonding_p (operands, <JOIN_MODE:MODE>mode, true)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_dup 1))\n+\t      (set (match_dup 2)\n+\t\t   (match_dup 3))])]\n+  \"\")\n+\n+;; 2 HI/SI/SF/DF stores are joined.\n+;; P5600 does not support bonding of two SBs, hence QI mode is not included.\n+(define_peephole2\n+  [(set (match_operand:JOIN_MODE 0 \"memory_operand\")\n+\t(match_operand:JOIN_MODE 1 \"register_operand\"))\n+   (set (match_operand:JOIN_MODE 2 \"memory_operand\")\n+\t(match_operand:JOIN_MODE 3 \"register_operand\"))]\n+  \"ENABLE_LD_ST_PAIRS\n+   && mips_load_store_bonding_p (operands, <JOIN_MODE:MODE>mode, false)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (match_dup 1))\n+\t      (set (match_dup 2)\n+\t\t   (match_dup 3))])]\n+  \"\")\n+\n+;; Match paired HImode loads.\n+(define_insn \"*join2_loadhi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(any_extend:SI (match_operand:HI 1 \"non_volatile_mem_operand\" \"m\")))\n+   (set (match_operand:SI 2 \"register_operand\" \"=r\")\n+\t(any_extend:SI (match_operand:HI 3 \"non_volatile_mem_operand\" \"m\")))]\n+  \"ENABLE_LD_ST_PAIRS && reload_completed\"\n+  {\n+    /* Reg-renaming pass reuses base register if it is dead after bonded loads.\n+       Hardware does not bond those loads, even when they are consecutive.\n+       However, order of the loads need to be checked for correctness.  */\n+    if (!reg_overlap_mentioned_p (operands[0], operands[1]))\n+      {\n+\toutput_asm_insn (\"lh<u>\\t%0,%1\", operands);\n+\toutput_asm_insn (\"lh<u>\\t%2,%3\", operands);\n+      }\n+    else\n+      {\n+\toutput_asm_insn (\"lh<u>\\t%2,%3\", operands);\n+\toutput_asm_insn (\"lh<u>\\t%0,%1\", operands);\n+      }\n+\n+    return \"\";\n+  }\n+  [(set_attr \"move_type\" \"load\")\n+   (set_attr \"insn_count\" \"2\")])\n+\n+\n+;; 2 HI loads are joined.\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(any_extend:SI (match_operand:HI 1 \"non_volatile_mem_operand\")))\n+   (set (match_operand:SI 2 \"register_operand\")\n+\t(any_extend:SI (match_operand:HI 3 \"non_volatile_mem_operand\")))]\n+  \"ENABLE_LD_ST_PAIRS\n+   && mips_load_store_bonding_p (operands, HImode, true)\"\n+  [(parallel [(set (match_dup 0)\n+\t\t   (any_extend:SI (match_dup 1)))\n+\t      (set (match_dup 2)\n+\t\t   (any_extend:SI (match_dup 3)))])]\n+  \"\")\n+\n \f\n ;; Synchronization instructions.\n "}, {"sha": "a9baebe6a44d6e79064ba18a624c6e5b038d69cc", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -418,3 +418,7 @@ Enable use of odd-numbered single-precision registers\n \n noasmopt\n Driver\n+\n+mload-store-pairs\n+Target Report Var(TARGET_LOAD_STORE_PAIRS) Init(1)\n+Enable load/store bonding."}, {"sha": "7987859653e68c34fedc45daebf2cc45db8a9770", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -1,3 +1,7 @@\n+2015-05-19  Sameera Deshpande  <sameera.deshpande@imgtec.com>\n+\n+\t* gcc.target/mips/p5600-bonding.c : New file.\n+\n 2015-05-18  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/66106"}, {"sha": "0890ffa9215a5b9658ceff73927dd5ac2320c039", "filename": "gcc/testsuite/gcc.target/mips/p5600-bonding.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fp5600-bonding.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/abf96035efcd29f72edbed125a2ac426f370a22c/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fp5600-bonding.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fp5600-bonding.c?ref=abf96035efcd29f72edbed125a2ac426f370a22c", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-dp -mtune=p5600  -mno-micromips -mno-mips16\" } */\n+/* { dg-skip-if \"Bonding needs peephole optimization.\" { *-*-* } { \"-O0\" \"-O1\" } { \"\" } } */\n+typedef int VINT32 __attribute__ ((vector_size((16))));\n+\n+void\n+memory_operation (void * __restrict src, void * __restrict dest, int num)\n+{\n+  VINT32 *vsrc = (VINT32 *) src;\n+  VINT32 *vdest = (VINT32 *) dest;\n+  int i;\n+\n+  for (i = 0; i < num - 1; i += 2)\n+  {\n+    vdest[i] = vdest[i] + vsrc[i];\n+    vdest[i + 1] = vdest[i + 1] + vsrc[i + 1];\n+  }\n+}\n+/* { dg-final { scan-assembler \"join2_\" } }  */\n+"}]}