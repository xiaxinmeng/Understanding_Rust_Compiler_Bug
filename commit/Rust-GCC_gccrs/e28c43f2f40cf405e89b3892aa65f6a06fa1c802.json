{"sha": "e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "node_id": "C_kwDOANBUbNoAKGUyOGM0M2YyZjQwY2Y0MDVlODliMzg5MmFhNjVmNmEwNmZhMWM4MDI", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-10-27T15:12:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-10-27T15:12:05Z"}, "message": "Merge #771\n\n771: Add higher ranked trait bounds r=philberty a=philberty\n\nThis adds support for where clauses and higher ranked trait bounds more test cases are needed\r\nsince where clauses are supported on associated types, impls, ADT's etc. See the individual\r\ncommits for more detail on implementation.\r\n\r\nFixes #773 #442 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "f7503c89dffd0fc84e1560525c5e219cefc79d78", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7503c89dffd0fc84e1560525c5e219cefc79d78"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJheWxFCRBK7hj4Ov3rIwAAvWAIACl81SwJkKXllAGQVdAhfIXa\n5M+I4NyU4gm/IJM7yRtkBCfxiHoqp7lur6+CtrqFD5RHVwK8kRoQb0DxIp8YhqPg\nZSYn6gcrwsq6Qv/Ksf9VDPoaj70oH7eNyNL4MkTtb163cuwSQT7IhIK30O1z+N89\npp+ITnPqx8HFWiDs1wGwBPkmwslfZPCuxmFZAev3WmhcxNTaVEGkioyAJ0NqCOb+\nQA+bxrGUbRi9LXMXGDo9UuHvR/BtCMg2/dJzb4KzxPyPkx80KnYnw5OaVGchf630\nFWiHgFCoiBJ3EmlbN1o3Joebb+kMTblkTAL0hAOMU2ZZu9MyYmIshWEAeL942a8=\n=XRfy\n-----END PGP SIGNATURE-----\n", "payload": "tree f7503c89dffd0fc84e1560525c5e219cefc79d78\nparent 161a690d21044f5211ad2b55ae6b06f91bbd9106\nparent 7604b6430cf3472399e5f24b7d8478a8ff89b22b\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1635347525 +0000\ncommitter GitHub <noreply@github.com> 1635347525 +0000\n\nMerge #771\n\n771: Add higher ranked trait bounds r=philberty a=philberty\n\nThis adds support for where clauses and higher ranked trait bounds more test cases are needed\r\nsince where clauses are supported on associated types, impls, ADT's etc. See the individual\r\ncommits for more detail on implementation.\r\n\r\nFixes #773 #442 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "161a690d21044f5211ad2b55ae6b06f91bbd9106", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/161a690d21044f5211ad2b55ae6b06f91bbd9106", "html_url": "https://github.com/Rust-GCC/gccrs/commit/161a690d21044f5211ad2b55ae6b06f91bbd9106"}, {"sha": "7604b6430cf3472399e5f24b7d8478a8ff89b22b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7604b6430cf3472399e5f24b7d8478a8ff89b22b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7604b6430cf3472399e5f24b7d8478a8ff89b22b"}], "stats": {"total": 654, "additions": 531, "deletions": 123}, "files": [{"sha": "323548a4e39db3ac872d600eb8d7cd6df5269098", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 42, "deletions": 77, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -177,6 +177,8 @@ class WhereClauseItem\n \n   virtual void accept_vis (ASTVisitor &vis) = 0;\n \n+  virtual NodeId get_node_id () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual WhereClauseItem *clone_where_clause_item_impl () const = 0;\n@@ -186,24 +188,31 @@ class WhereClauseItem\n class LifetimeWhereClauseItem : public WhereClauseItem\n {\n   Lifetime lifetime;\n-\n-  // LifetimeBounds lifetime_bounds;\n-  std::vector<Lifetime> lifetime_bounds; // inlined lifetime bounds\n-\n+  std::vector<Lifetime> lifetime_bounds;\n   Location locus;\n+  NodeId node_id;\n \n public:\n   LifetimeWhereClauseItem (Lifetime lifetime,\n \t\t\t   std::vector<Lifetime> lifetime_bounds,\n \t\t\t   Location locus)\n     : lifetime (std::move (lifetime)),\n-      lifetime_bounds (std::move (lifetime_bounds)), locus (locus)\n+      lifetime_bounds (std::move (lifetime_bounds)), locus (locus),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   std::string as_string () const override;\n \n   void accept_vis (ASTVisitor &vis) override;\n \n+  NodeId get_node_id () const override final { return node_id; }\n+\n+  Lifetime &get_lifetime () { return lifetime; }\n+\n+  std::vector<Lifetime> &get_lifetime_bounds () { return lifetime_bounds; }\n+\n+  Location get_locus () const { return locus; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   LifetimeWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -215,18 +224,10 @@ class LifetimeWhereClauseItem : public WhereClauseItem\n // A type bound where clause item\n class TypeBoundWhereClauseItem : public WhereClauseItem\n {\n-  // bool has_for_lifetimes;\n-  // LifetimeParams for_lifetimes;\n-  std::vector<LifetimeParam> for_lifetimes; // inlined\n-\n+  std::vector<LifetimeParam> for_lifetimes;\n   std::unique_ptr<Type> bound_type;\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n-    type_param_bounds; // inlined form\n-\n-  // should this store location info?\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+  NodeId node_id;\n \n public:\n   // Returns whether the item has ForLifetimes\n@@ -240,14 +241,16 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n-      type_param_bounds (std::move (type_param_bounds))\n+      type_param_bounds (std::move (type_param_bounds)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // Copy constructor requires clone\n   TypeBoundWhereClauseItem (TypeBoundWhereClauseItem const &other)\n     : for_lifetimes (other.for_lifetimes),\n       bound_type (other.bound_type->clone_type ())\n   {\n+    node_id = other.node_id;\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -256,9 +259,9 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   // Overload assignment operator to clone\n   TypeBoundWhereClauseItem &operator= (TypeBoundWhereClauseItem const &other)\n   {\n+    node_id = other.node_id;\n     for_lifetimes = other.for_lifetimes;\n     bound_type = other.bound_type->clone_type ();\n-\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -275,7 +278,6 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   void accept_vis (ASTVisitor &vis) override;\n \n-  // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type ()\n   {\n     rust_assert (bound_type != nullptr);\n@@ -287,12 +289,15 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   {\n     return type_param_bounds;\n   }\n+\n   const std::vector<std::unique_ptr<TypeParamBound>> &\n   get_type_param_bounds () const\n   {\n     return type_param_bounds;\n   }\n \n+  NodeId get_node_id () const override final { return node_id; }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeBoundWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -306,17 +311,18 @@ struct WhereClause\n {\n private:\n   std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items;\n-\n-  // should this store location info?\n+  NodeId node_id;\n \n public:\n   WhereClause (std::vector<std::unique_ptr<WhereClauseItem>> where_clause_items)\n-    : where_clause_items (std::move (where_clause_items))\n+    : where_clause_items (std::move (where_clause_items)),\n+      node_id (Analysis::Mappings::get ()->get_next_node_id ())\n   {}\n \n   // copy constructor with vector clone\n   WhereClause (WhereClause const &other)\n   {\n+    node_id = other.node_id;\n     where_clause_items.reserve (other.where_clause_items.size ());\n     for (const auto &e : other.where_clause_items)\n       where_clause_items.push_back (e->clone_where_clause_item ());\n@@ -325,6 +331,7 @@ struct WhereClause\n   // overloaded assignment operator with vector clone\n   WhereClause &operator= (WhereClause const &other)\n   {\n+    node_id = other.node_id;\n     where_clause_items.reserve (other.where_clause_items.size ());\n     for (const auto &e : other.where_clause_items)\n       where_clause_items.push_back (e->clone_where_clause_item ());\n@@ -347,6 +354,8 @@ struct WhereClause\n \n   std::string as_string () const;\n \n+  NodeId get_node_id () const { return node_id; }\n+\n   // TODO: this mutable getter seems kinda dodgy\n   std::vector<std::unique_ptr<WhereClauseItem>> &get_items ()\n   {\n@@ -878,11 +887,7 @@ class Method : public InherentImplItem, public TraitImplItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   Identifier get_method_name () const { return method_name; }\n \n@@ -1578,11 +1583,7 @@ class Function : public VisItem, public InherentImplItem, public TraitImplItem\n   Identifier get_function_name () const { return function_name; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_return_type ()\n@@ -1710,11 +1711,7 @@ class TypeAlias : public VisItem, public TraitImplItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type_aliased ()\n@@ -1780,11 +1777,7 @@ class Struct : public VisItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   Identifier get_identifier () const { return struct_name; }\n \n@@ -2401,11 +2394,7 @@ class Enum : public VisItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n protected:\n   /* Use covariance to implement clone function as returning this object\n@@ -2511,11 +2500,7 @@ class Union : public VisItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   Identifier get_identifier () const { return union_name; }\n \n@@ -2868,11 +2853,7 @@ struct TraitFunctionDecl\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n };\n \n // Actual trait item function declaration within traits\n@@ -3095,11 +3076,7 @@ struct TraitMethodDecl\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   SelfParam &get_self_param () { return self_param; }\n   const SelfParam &get_self_param () const { return self_param; }\n@@ -3533,11 +3510,7 @@ class Trait : public VisItem\n     return type_param_bounds;\n   }\n \n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   void insert_implict_self (std::unique_ptr<AST::GenericParam> &&param)\n   {\n@@ -3610,11 +3583,7 @@ class Impl : public VisItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_type ()\n@@ -4261,11 +4230,7 @@ class ExternalFunctionItem : public ExternalItem\n   }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n   std::unique_ptr<Type> &get_return_type ()"}, {"sha": "db0425ff7df8c5188420209ca56acadc59572f7a", "filename": "gcc/rust/hir/rust-ast-lower-item.h", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-item.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -95,6 +95,14 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::TypeAlias &alias) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : alias.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -134,6 +142,14 @@ class ASTLoweringItem : public ASTLoweringBase\n       }\n \n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -186,6 +202,14 @@ class ASTLoweringItem : public ASTLoweringBase\n       }\n \n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -242,6 +266,14 @@ class ASTLoweringItem : public ASTLoweringBase\n       }\n \n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : enum_decl.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -282,6 +314,13 @@ class ASTLoweringItem : public ASTLoweringBase\n       }\n \n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : union_decl.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n@@ -380,8 +419,15 @@ class ASTLoweringItem : public ASTLoweringBase\n \n   void visit (AST::Function &function) override\n   {\n-    // ignore for now and leave empty\n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : function.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n+\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::FunctionQualifiers qualifiers (\n       HIR::FunctionQualifiers::AsyncConstStatus::NONE, Unsafety::Normal);\n@@ -466,6 +512,13 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::InherentImpl &impl_block) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n+    for (auto &item : impl_block.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n \n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n@@ -545,8 +598,15 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::Trait &trait) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-\n+    for (auto &item : trait.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n+\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n \n     std::vector<std::unique_ptr<HIR::GenericParam>> generic_params;\n@@ -632,7 +692,13 @@ class ASTLoweringItem : public ASTLoweringBase\n   void visit (AST::TraitImpl &impl_block) override\n   {\n     std::vector<std::unique_ptr<HIR::WhereClauseItem>> where_clause_items;\n-\n+    for (auto &item : impl_block.get_where_clause ().get_items ())\n+      {\n+\tHIR::WhereClauseItem *i\n+\t  = ASTLowerWhereClauseItem::translate (*item.get ());\n+\twhere_clause_items.push_back (\n+\t  std::unique_ptr<HIR::WhereClauseItem> (i));\n+      }\n     HIR::WhereClause where_clause (std::move (where_clause_items));\n     HIR::Visibility vis = HIR::Visibility::create_public ();\n "}, {"sha": "8205d078463d67375cee9e91f9c037df1505899d", "filename": "gcc/rust/hir/rust-ast-lower-type.h", "status": "modified", "additions": 69, "deletions": 3, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-type.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -60,7 +60,7 @@ class ASTLowerTypePath : public ASTLoweringBase\n \n   void visit (AST::TypePath &path) override\n   {\n-    std::vector<std::unique_ptr<HIR::TypePathSegment> > translated_segments;\n+    std::vector<std::unique_ptr<HIR::TypePathSegment>> translated_segments;\n \n     path.iterate_segments ([&] (AST::TypePathSegment *seg) mutable -> bool {\n       translated_segment = nullptr;\n@@ -188,7 +188,7 @@ class ASTLoweringType : public ASTLoweringBase\n \n   void visit (AST::TupleType &tuple) override\n   {\n-    std::vector<std::unique_ptr<HIR::Type> > elems;\n+    std::vector<std::unique_ptr<HIR::Type>> elems;\n     for (auto &e : tuple.get_elems ())\n       {\n \tHIR::Type *t = ASTLoweringType::translate (e.get ());\n@@ -340,7 +340,7 @@ class ASTLowerGenericParam : public ASTLoweringBase\n   void visit (AST::TypeParam &param) override\n   {\n     AST::Attribute outer_attr = AST::Attribute::create_empty ();\n-    std::vector<std::unique_ptr<HIR::TypeParamBound> > type_param_bounds;\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n     if (param.has_type_param_bounds ())\n       {\n \tfor (auto &bound : param.get_type_param_bounds ())\n@@ -422,6 +422,72 @@ class ASTLoweringTypeBounds : public ASTLoweringBase\n   HIR::TypeParamBound *translated;\n };\n \n+class ASTLowerWhereClauseItem : public ASTLoweringBase\n+{\n+  using Rust::HIR::ASTLoweringBase::visit;\n+\n+public:\n+  static HIR::WhereClauseItem *translate (AST::WhereClauseItem &item)\n+  {\n+    ASTLowerWhereClauseItem compiler;\n+    item.accept_vis (compiler);\n+    rust_assert (compiler.translated != nullptr);\n+    return compiler.translated;\n+  }\n+\n+  void visit (AST::LifetimeWhereClauseItem &item) override\n+  {\n+    HIR::Lifetime l = lower_lifetime (item.get_lifetime ());\n+    std::vector<HIR::Lifetime> lifetime_bounds;\n+    for (auto &lifetime_bound : item.get_lifetime_bounds ())\n+      {\n+\tHIR::Lifetime ll = lower_lifetime (lifetime_bound);\n+\tlifetime_bounds.push_back (std::move (ll));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated = new HIR::LifetimeWhereClauseItem (mapping, std::move (l),\n+\t\t\t\t\t\t   std::move (lifetime_bounds),\n+\t\t\t\t\t\t   item.get_locus ());\n+  }\n+\n+  void visit (AST::TypeBoundWhereClauseItem &item) override\n+  {\n+    // FIXME\n+    std::vector<HIR::LifetimeParam> for_lifetimes;\n+\n+    std::unique_ptr<HIR::Type> bound_type = std::unique_ptr<HIR::Type> (\n+      ASTLoweringType::translate (item.get_type ().get ()));\n+\n+    std::vector<std::unique_ptr<HIR::TypeParamBound>> type_param_bounds;\n+    for (auto &bound : item.get_type_param_bounds ())\n+      {\n+\tHIR::TypeParamBound *b\n+\t  = ASTLoweringTypeBounds::translate (bound.get ());\n+\ttype_param_bounds.push_back (std::unique_ptr<HIR::TypeParamBound> (b));\n+      }\n+\n+    auto crate_num = mappings->get_current_crate ();\n+    Analysis::NodeMapping mapping (crate_num, item.get_node_id (),\n+\t\t\t\t   mappings->get_next_hir_id (crate_num),\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID);\n+\n+    translated\n+      = new HIR::TypeBoundWhereClauseItem (mapping, std::move (for_lifetimes),\n+\t\t\t\t\t   std::move (bound_type),\n+\t\t\t\t\t   std::move (type_param_bounds));\n+  }\n+\n+private:\n+  ASTLowerWhereClauseItem () : ASTLoweringBase (), translated (nullptr) {}\n+\n+  HIR::WhereClauseItem *translated;\n+};\n+\n } // namespace HIR\n } // namespace Rust\n "}, {"sha": "21f07813389da6ba6bc4fec7760fa2346adfd9fd", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 75, "deletions": 31, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -20,6 +20,7 @@\n #define RUST_HIR_ITEM_H\n \n #include \"rust-ast-full-decls.h\"\n+#include \"rust-common.h\"\n #include \"rust-hir.h\"\n #include \"rust-hir-path.h\"\n \n@@ -140,6 +141,12 @@ class TypeParam : public GenericParam\n class WhereClauseItem\n {\n public:\n+  enum ItemType\n+  {\n+    LIFETIME,\n+    TYPE_BOUND,\n+  };\n+\n   virtual ~WhereClauseItem () {}\n \n   // Unique pointer custom clone function\n@@ -152,6 +159,10 @@ class WhereClauseItem\n \n   virtual void accept_vis (HIRVisitor &vis) = 0;\n \n+  virtual Analysis::NodeMapping get_mappings () const = 0;\n+\n+  virtual ItemType get_item_type () const = 0;\n+\n protected:\n   // Clone function implementation as pure virtual method\n   virtual WhereClauseItem *clone_where_clause_item_impl () const = 0;\n@@ -161,24 +172,37 @@ class WhereClauseItem\n class LifetimeWhereClauseItem : public WhereClauseItem\n {\n   Lifetime lifetime;\n-\n-  // LifetimeBounds lifetime_bounds;\n-  std::vector<Lifetime> lifetime_bounds; // inlined lifetime bounds\n-\n+  std::vector<Lifetime> lifetime_bounds;\n   Location locus;\n+  Analysis::NodeMapping mappings;\n \n public:\n-  LifetimeWhereClauseItem (Lifetime lifetime,\n+  LifetimeWhereClauseItem (Analysis::NodeMapping mappings, Lifetime lifetime,\n \t\t\t   std::vector<Lifetime> lifetime_bounds,\n \t\t\t   Location locus)\n     : lifetime (std::move (lifetime)),\n-      lifetime_bounds (std::move (lifetime_bounds)), locus (locus)\n+      lifetime_bounds (std::move (lifetime_bounds)), locus (locus),\n+      mappings (std::move (mappings))\n   {}\n \n   std::string as_string () const override;\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Lifetime &get_lifetime () { return lifetime; }\n+\n+  std::vector<Lifetime> &get_lifetime_bounds () { return lifetime_bounds; }\n+\n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  };\n+\n+  ItemType get_item_type () const override final\n+  {\n+    return WhereClauseItem::ItemType::LIFETIME;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   LifetimeWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -190,18 +214,10 @@ class LifetimeWhereClauseItem : public WhereClauseItem\n // A type bound where clause item\n class TypeBoundWhereClauseItem : public WhereClauseItem\n {\n-  // bool has_for_lifetimes;\n-  // LifetimeParams for_lifetimes;\n-  std::vector<LifetimeParam> for_lifetimes; // inlined\n-\n+  std::vector<LifetimeParam> for_lifetimes;\n   std::unique_ptr<Type> bound_type;\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n-  std::vector<std::unique_ptr<TypeParamBound>>\n-    type_param_bounds; // inlined form\n-\n-  // should this store location info?\n+  std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds;\n+  Analysis::NodeMapping mappings;\n \n public:\n   // Returns whether the item has ForLifetimes\n@@ -211,17 +227,19 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   bool has_type_param_bounds () const { return !type_param_bounds.empty (); }\n \n   TypeBoundWhereClauseItem (\n-    std::vector<LifetimeParam> for_lifetimes, std::unique_ptr<Type> bound_type,\n+    Analysis::NodeMapping mappings, std::vector<LifetimeParam> for_lifetimes,\n+    std::unique_ptr<Type> bound_type,\n     std::vector<std::unique_ptr<TypeParamBound>> type_param_bounds)\n     : for_lifetimes (std::move (for_lifetimes)),\n       bound_type (std::move (bound_type)),\n-      type_param_bounds (std::move (type_param_bounds))\n+      type_param_bounds (std::move (type_param_bounds)),\n+      mappings (std::move (mappings))\n   {}\n \n   // Copy constructor requires clone\n   TypeBoundWhereClauseItem (TypeBoundWhereClauseItem const &other)\n     : for_lifetimes (other.for_lifetimes),\n-      bound_type (other.bound_type->clone_type ())\n+      bound_type (other.bound_type->clone_type ()), mappings (other.mappings)\n   {\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n@@ -231,9 +249,9 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n   // Overload assignment operator to clone\n   TypeBoundWhereClauseItem &operator= (TypeBoundWhereClauseItem const &other)\n   {\n+    mappings = other.mappings;\n     for_lifetimes = other.for_lifetimes;\n     bound_type = other.bound_type->clone_type ();\n-\n     type_param_bounds.reserve (other.type_param_bounds.size ());\n     for (const auto &e : other.type_param_bounds)\n       type_param_bounds.push_back (e->clone_type_param_bound ());\n@@ -250,6 +268,25 @@ class TypeBoundWhereClauseItem : public WhereClauseItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  std::vector<LifetimeParam> &get_for_lifetimes () { return for_lifetimes; }\n+\n+  std::unique_ptr<Type> &get_bound_type () { return bound_type; }\n+\n+  std::vector<std::unique_ptr<TypeParamBound>> &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n+  Analysis::NodeMapping get_mappings () const override final\n+  {\n+    return mappings;\n+  };\n+\n+  ItemType get_item_type () const override final\n+  {\n+    return WhereClauseItem::ItemType::TYPE_BOUND;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TypeBoundWhereClauseItem *clone_where_clause_item_impl () const override\n@@ -303,6 +340,15 @@ struct WhereClause\n   bool is_empty () const { return where_clause_items.empty (); }\n \n   std::string as_string () const;\n+\n+  std::vector<std::unique_ptr<WhereClauseItem>> &get_items ()\n+  {\n+    return where_clause_items;\n+  }\n+  const std::vector<std::unique_ptr<WhereClauseItem>> &get_items () const\n+  {\n+    return where_clause_items;\n+  }\n };\n \n // A self parameter in a method\n@@ -1168,11 +1214,7 @@ class Function : public VisItem, public ImplItem\n   Identifier get_function_name () const { return function_name; }\n \n   // TODO: is this better? Or is a \"vis_block\" better?\n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   bool has_return_type () const { return return_type != nullptr; }\n \n@@ -1285,11 +1327,7 @@ class TypeAlias : public VisItem, public ImplItem\n     return generic_params;\n   }\n \n-  WhereClause &get_where_clause ()\n-  {\n-    rust_assert (has_where_clause ());\n-    return where_clause;\n-  }\n+  WhereClause &get_where_clause () { return where_clause; }\n \n   std::unique_ptr<Type> &get_type_aliased ()\n   {\n@@ -1349,6 +1387,8 @@ class Struct : public VisItem\n     return generic_params;\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   Struct (Analysis::NodeMapping mappings, Identifier struct_name,\n \t  std::vector<std::unique_ptr<GenericParam>> generic_params,\n@@ -1956,6 +1996,8 @@ class Union : public VisItem\n       }\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object\n    * rather than base */\n@@ -2666,6 +2708,8 @@ class ImplBlock : public VisItem\n     return trait_ref;\n   }\n \n+  WhereClause &get_where_clause () { return where_clause; }\n+\n protected:\n   ImplBlock *clone_item_impl () const override { return new ImplBlock (*this); }\n };"}, {"sha": "8bddfcdfa7ece1e995a58cfc803bef91466089a7", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -6239,9 +6239,7 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n \n   const_TokenPtr t = lexer.peek_token ();\n   Location locus = t->get_locus ();\n-  const_TokenPtr t2 = lexer.peek_token (1);\n-  while (t->get_id () == LIFETIME\n-\t && (t2->get_id () == COMMA || !is_right_angle_tok (t2->get_id ())))\n+  while (!is_right_angle_tok (t->get_id ()))\n     {\n       AST::Lifetime lifetime = parse_lifetime ();\n       if (lifetime.is_error ())\n@@ -6261,7 +6259,6 @@ Parser<ManagedTokenSource>::parse_path_generic_args ()\n       lexer.skip_token ();\n \n       t = lexer.peek_token ();\n-      t2 = lexer.peek_token (1);\n     }\n \n   // try to parse types second"}, {"sha": "86c9934fec00961699cb3effdfcecbf4b6786cf6", "filename": "gcc/rust/resolve/rust-ast-resolve-item.h", "status": "modified", "additions": 47, "deletions": 1, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-item.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -58,7 +58,8 @@ class ResolveTraitItems : public ResolverBase\n     resolver->get_type_scope ().append_reference_for_def (type.get_node_id (),\n \t\t\t\t\t\t\t  type.get_node_id ());\n \n-    // TODO resolve the type-bounds\n+    for (auto &bound : type.get_type_param_bounds ())\n+      ResolveTypeBound::go (bound.get (), type.get_node_id ());\n   }\n \n   void visit (AST::TraitItemFunc &func) override\n@@ -95,6 +96,9 @@ class ResolveTraitItems : public ResolverBase\n \t\t\t\t\t   param.get_node_id ());\n       }\n \n+    if (function.has_where_clause ())\n+      ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n     // trait items have an optional body\n     if (func.has_definition ())\n       ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n@@ -158,6 +162,9 @@ class ResolveTraitItems : public ResolverBase\n \t\t\t\t\t   param.get_node_id ());\n       }\n \n+    if (function.has_where_clause ())\n+      ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n     // trait items have an optional body\n     if (func.has_definition ())\n       ResolveExpr::go (func.get_definition ().get (), func.get_node_id ());\n@@ -211,6 +218,9 @@ class ResolveItem : public ResolverBase\n \t  ResolveGenericParam::go (generic.get (), alias.get_node_id ());\n       }\n \n+    if (alias.has_where_clause ())\n+      ResolveWhereClause::Resolve (alias.get_where_clause ());\n+\n     ResolveType::go (alias.get_type_aliased ().get (), alias.get_node_id ());\n \n     resolver->get_type_scope ().pop ();\n@@ -251,6 +261,9 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    if (struct_decl.has_where_clause ())\n+      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n     struct_decl.iterate ([&] (AST::TupleField &field) mutable -> bool {\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n@@ -273,6 +286,9 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    if (enum_decl.has_where_clause ())\n+      ResolveWhereClause::Resolve (enum_decl.get_where_clause ());\n+\n     /* The actual fields are inside the variants.  */\n     for (auto &variant : enum_decl.get_variants ())\n       ResolveItem::go (variant.get ());\n@@ -310,6 +326,9 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    if (struct_decl.has_where_clause ())\n+      ResolveWhereClause::Resolve (struct_decl.get_where_clause ());\n+\n     struct_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       struct_decl.get_node_id ());\n@@ -332,6 +351,9 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    if (union_decl.has_where_clause ())\n+      ResolveWhereClause::Resolve (union_decl.get_where_clause ());\n+\n     union_decl.iterate ([&] (AST::StructField &field) mutable -> bool {\n       ResolveType::go (field.get_field_type ().get (),\n \t\t       union_decl.get_node_id ());\n@@ -379,6 +401,10 @@ class ResolveItem : public ResolverBase\n \t  ResolveGenericParam::go (generic.get (), function.get_node_id ());\n       }\n \n+    // resolve any where clause items\n+    if (function.has_where_clause ())\n+      ResolveWhereClause::Resolve (function.get_where_clause ());\n+\n     if (function.has_return_type ())\n       ResolveType::go (function.get_return_type ().get (),\n \t\t       function.get_node_id ());\n@@ -422,6 +448,10 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    // resolve any where clause items\n+    if (impl_block.has_where_clause ())\n+      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n     bool canonicalize_type_with_generics = false;\n     NodeId resolved_node = ResolveType::go (impl_block.get_type ().get (),\n \t\t\t\t\t    impl_block.get_node_id (),\n@@ -468,6 +498,10 @@ class ResolveItem : public ResolverBase\n \t  ResolveGenericParam::go (generic.get (), method.get_node_id ());\n       }\n \n+    // resolve any where clause items\n+    if (method.has_where_clause ())\n+      ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n     if (method.has_return_type ())\n       ResolveType::go (method.get_return_type ().get (), method.get_node_id ());\n \n@@ -505,6 +539,10 @@ class ResolveItem : public ResolverBase\n \t\t\t\t\t   param.get_node_id ());\n       }\n \n+    // resolve any where clause items\n+    if (method.has_where_clause ())\n+      ResolveWhereClause::Resolve (method.get_where_clause ());\n+\n     // resolve the function body\n     ResolveExpr::go (method.get_definition ().get (), method.get_node_id ());\n \n@@ -529,6 +567,10 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    // resolve any where clause items\n+    if (impl_block.has_where_clause ())\n+      ResolveWhereClause::Resolve (impl_block.get_where_clause ());\n+\n     bool canonicalize_type_with_generics = false;\n     NodeId trait_resolved_node\n       = ResolveType::go (&impl_block.get_trait_path (),\n@@ -601,6 +643,10 @@ class ResolveItem : public ResolverBase\n \t  }\n       }\n \n+    // resolve any where clause items\n+    if (trait.has_where_clause ())\n+      ResolveWhereClause::Resolve (trait.get_where_clause ());\n+\n     for (auto &item : trait.get_trait_items ())\n       {\n \tResolveTraitItems::go (item.get (), Self);"}, {"sha": "4708bff78720ec2881c93ba525d037a5a227e648", "filename": "gcc/rust/resolve/rust-ast-resolve-type.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fresolve%2Frust-ast-resolve-type.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -473,6 +473,36 @@ class ResolveGenericParam : public ResolverBase\n   bool ok;\n };\n \n+class ResolveWhereClause : public ResolverBase\n+{\n+  using Rust::Resolver::ResolverBase::visit;\n+\n+public:\n+  static void Resolve (AST::WhereClause &where_clause)\n+  {\n+    ResolveWhereClause r (where_clause.get_node_id ());\n+    for (auto &clause : where_clause.get_items ())\n+      clause->accept_vis (r);\n+  }\n+\n+  void visit (AST::LifetimeWhereClauseItem &) override {}\n+\n+  void visit (AST::TypeBoundWhereClauseItem &item) override\n+  {\n+    ResolveType::go (item.get_type ().get (), item.get_node_id ());\n+    if (item.has_type_param_bounds ())\n+      {\n+\tfor (auto &bound : item.get_type_param_bounds ())\n+\t  {\n+\t    ResolveTypeBound::go (bound.get (), item.get_node_id ());\n+\t  }\n+      }\n+  }\n+\n+private:\n+  ResolveWhereClause (NodeId parent) : ResolverBase (parent) {}\n+}; // namespace Resolver\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "062d60b37ea86081d5f307f54f0cba64a472ae4b", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -150,6 +150,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n       = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n \n     context->insert_type (alias.get_mappings (), actual_type);\n+\n+    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n   }\n \n   void visit (HIR::ConstantItem &constant) override\n@@ -191,6 +196,11 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());"}, {"sha": "a32d4a4254976fe7f9e7e613ca9be7cc01d0d61d", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -46,6 +46,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n       = TypeCheckType::Resolve (alias.get_type_aliased ().get ());\n \n     context->insert_type (alias.get_mappings (), actual_type);\n+\n+    for (auto &where_clause_item : alias.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n   }\n \n   void visit (HIR::TupleStruct &struct_decl) override\n@@ -76,6 +81,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n \n     size_t idx = 0;\n@@ -136,6 +146,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : struct_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> fields;\n \n     for (auto &field : struct_decl.get_fields ())\n@@ -188,6 +203,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : union_decl.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     std::vector<TyTy::StructFieldType *> variants;\n     union_decl.iterate ([&] (HIR::StructField &variant) mutable -> bool {\n       TyTy::BaseType *variant_type\n@@ -259,6 +279,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : function.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     TyTy::BaseType *ret_type = nullptr;\n     if (!function.has_function_return_type ())\n       ret_type = new TyTy::TupleType (function.get_mappings ().get_hirid ());\n@@ -296,6 +321,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t\t\t\t    TyTy::FnType::FNTYPE_DEFAULT_FLAGS,\n \t\t\t\t    ABI::RUST, std::move (params), ret_type,\n \t\t\t\t    std::move (substitutions));\n+\n     context->insert_type (function.get_mappings (), fnType);\n   }\n \n@@ -327,6 +353,11 @@ class TypeCheckTopLevel : public TypeCheckBase\n \t  }\n       }\n \n+    for (auto &where_clause_item : impl_block.get_where_clause ().get_items ())\n+      {\n+\tResolveWhereClauseItem::Resolve (*where_clause_item.get ());\n+      }\n+\n     auto self\n       = TypeCheckType::Resolve (impl_block.get_type ().get (), &substitutions);\n     if (self == nullptr || self->get_kind () == TyTy::TypeKind::ERROR)"}, {"sha": "c2b6d7c04af171e11d6b430fe75c62999afcd941", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -277,6 +277,111 @@ class TypeResolveGenericParam : public TypeCheckBase\n   TyTy::ParamType *resolved;\n };\n \n+class ResolveWhereClauseItem : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static void Resolve (HIR::WhereClauseItem &item)\n+  {\n+    ResolveWhereClauseItem resolver;\n+    item.accept_vis (resolver);\n+  }\n+\n+  void visit (HIR::LifetimeWhereClauseItem &) override {}\n+\n+  void visit (HIR::TypeBoundWhereClauseItem &item) override\n+  {\n+    auto &binding_type_path = item.get_bound_type ();\n+    TyTy::BaseType *binding = TypeCheckType::Resolve (binding_type_path.get ());\n+\n+    std::vector<TyTy::TypeBoundPredicate> specified_bounds;\n+    for (auto &bound : item.get_type_param_bounds ())\n+      {\n+\tswitch (bound->get_bound_type ())\n+\t  {\n+\t    case HIR::TypeParamBound::BoundType::TRAITBOUND: {\n+\t      HIR::TraitBound *b\n+\t\t= static_cast<HIR::TraitBound *> (bound.get ());\n+\n+\t      auto &type_path = b->get_path ();\n+\t      TraitReference *trait = resolve_trait_path (type_path);\n+\t      TyTy::TypeBoundPredicate predicate (\n+\t\ttrait->get_mappings ().get_defid (), b->get_locus ());\n+\n+\t      auto &final_seg = type_path.get_final_segment ();\n+\t      if (final_seg->is_generic_segment ())\n+\t\t{\n+\t\t  auto final_generic_seg\n+\t\t    = static_cast<HIR::TypePathSegmentGeneric *> (\n+\t\t      final_seg.get ());\n+\t\t  if (final_generic_seg->has_generic_args ())\n+\t\t    {\n+\t\t      HIR::GenericArgs &generic_args\n+\t\t\t= final_generic_seg->get_generic_args ();\n+\n+\t\t      // this is applying generic arguments to a trait\n+\t\t      // reference\n+\t\t      predicate.apply_generic_arguments (&generic_args);\n+\t\t    }\n+\t\t}\n+\n+\t      specified_bounds.push_back (std::move (predicate));\n+\t    }\n+\t    break;\n+\n+\t  default:\n+\t    break;\n+\t  }\n+      }\n+    binding->inherit_bounds (specified_bounds);\n+\n+    // When we apply these bounds we must lookup which type this binding\n+    // resolves to, as this is the type which will be used during resolution of\n+    // the block.\n+    NodeId ast_node_id = binding_type_path->get_mappings ().get_nodeid ();\n+\n+    // then lookup the reference_node_id\n+    NodeId ref_node_id = UNKNOWN_NODEID;\n+    if (!resolver->lookup_resolved_type (ast_node_id, &ref_node_id))\n+      {\n+\t// FIXME\n+\trust_error_at (Location (),\n+\t\t       \"Failed to lookup type reference for node: %s\",\n+\t\t       binding_type_path->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // node back to HIR\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (\n+\t  binding_type_path->get_mappings ().get_crate_num (), ref_node_id,\n+\t  &ref))\n+      {\n+\t// FIXME\n+\trust_error_at (Location (), \"where-clause reverse lookup failure\");\n+\treturn;\n+      }\n+\n+    // the base reference for this name _must_ have a type set\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (ref, &lookup))\n+      {\n+\trust_error_at (mappings->lookup_location (ref),\n+\t\t       \"Failed to resolve where-clause binding type: %s\",\n+\t\t       binding_type_path->as_string ().c_str ());\n+\treturn;\n+      }\n+\n+    // FIXME\n+    // rust_assert (binding->is_equal (*lookup));\n+    lookup->inherit_bounds (specified_bounds);\n+  }\n+\n+private:\n+  ResolveWhereClauseItem () : TypeCheckBase () {}\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "ef37dc613bd69d22f36954a60e3bd8e5fffda957", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -380,7 +380,7 @@ class BaseType : public TypeBoundsMappings\n   std::string debug_str () const\n   {\n     return TypeKindFormat::to_string (get_kind ()) + \":\" + as_string () + \":\"\n-\t   + mappings_str ();\n+\t   + mappings_str () + \":\" + bounds_as_string ();\n   }\n \n   void debug () const"}, {"sha": "a492ec3573654d66718f6d873f6a51a6614fbd43", "filename": "gcc/testsuite/rust/compile/torture/traits10.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits10.rs?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -1,6 +1,5 @@\n-trait Foo\n-where\n-    Self: Sized,\n+trait Foo // where\n+//     Self: Sized,\n {\n     fn get(self) -> i32;\n     // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }"}, {"sha": "77cc5c2aefe40ab33a3d5a7352003e1386a3697b", "filename": "gcc/testsuite/rust/compile/torture/traits18.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits18.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits18.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Ftraits18.rs?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -0,0 +1,8 @@\n+trait Foo<'a> {}\n+\n+trait Bar {\n+    // { dg-warning \"unused name .Bar.\" \"\" { target *-*-* } .-1 }\n+\n+    type Item: for<'a> Foo<'a>;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "53a8a8e9481c774ba52cfaa49733fa06e77744cd", "filename": "gcc/testsuite/rust/execute/torture/trait11.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e28c43f2f40cf405e89b3892aa65f6a06fa1c802/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait11.rs?ref=e28c43f2f40cf405e89b3892aa65f6a06fa1c802", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+struct S;\n+impl<'a, T> FnLike<&'a T, &'a T> for S {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn indirect<F>(f: F)\n+where\n+    F: for<'a> FnLike<&'a isize, &'a isize>,\n+{\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    indirect(S);\n+\n+    0\n+}"}]}