{"sha": "62e39334a08066c17ead2da37ccb9209b2cc8e14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJlMzkzMzRhMDgwNjZjMTdlYWQyZGEzN2NjYjkyMDliMmNjOGUxNA==", "commit": {"author": {"name": "David Billinghurst", "email": "David.Billinghurst@riotinto.com", "date": "2004-07-12T12:49:11Z"}, "committer": {"name": "David Billinghurst", "email": "billingd@gcc.gnu.org", "date": "2004-07-12T12:49:11Z"}, "message": "004-07-12  David Billinghurst (David.Billinghurst@riotinto.com)\n\n        * gfortran.dg/g77/12002.f: Copy from g77.f-torture/compile.\n        Add {dg-do compile} directive.\n        * gfortran.dg/g77/13060.f: Likewise\n        * gfortran.dg/g77/19990218-0.f: Likewise\n        * gfortran.dg/g77/19990305-0.f: Likewise\n        * gfortran.dg/g77/19990419-0.f: Likewise\n        * gfortran.dg/g77/19990502-0.f: Likewise\n        * gfortran.dg/g77/19990502-1.f: Likewise\n        * gfortran.dg/g77/19990525-0.f: Likewise\n        * gfortran.dg/g77/19990826-1.f: Likewise\n        * gfortran.dg/g77/19990826-3.f: Likewise\n        * gfortran.dg/g77/19990905-2.f: Likewise\n        * gfortran.dg/g77/20000412-1.f: Likewise\n        * gfortran.dg/g77/20000511-1.f: Likewise\n        * gfortran.dg/g77/20000511-2.f: Likewise\n        * gfortran.dg/g77/20000518.f: Likewise\n        * gfortran.dg/g77/20000601-1.f: Likewise\n        * gfortran.dg/g77/20000601-2.f: Likewise\n        * gfortran.dg/g77/20000629-1.f: Likewise\n        * gfortran.dg/g77/20000630-2.f: Likewise\n        * gfortran.dg/g77/20010115.f: Likewise\n        * gfortran.dg/g77/20010321-1.f: Likewise\n        * gfortran.dg/g77/20010426.f: Likewise\n        * gfortran.dg/g77/20020307-1.f: Likewise\n        * gfortran.dg/g77/8485.f: Likewise\n        * gfortran.dg/g77/960317-1.f: Likewise\n        * gfortran.dg/g77/970915-0.f: Likewise\n        * gfortran.dg/g77/980310-1.f: Likewise\n        * gfortran.dg/g77/980310-2.f: Likewise\n        * gfortran.dg/g77/980310-3.f: Likewise\n        * gfortran.dg/g77/980310-4.f: Likewise\n        * gfortran.dg/g77/980310-6.f: Likewise\n        * gfortran.dg/g77/980310-7.f: Likewise\n        * gfortran.dg/g77/980310-8.f: Likewise\n        * gfortran.dg/g77/980419-2.f: Likewise\n        * gfortran.dg/g77/980424-0.f: Likewise\n        * gfortran.dg/g77/980427-0.f: Likewise\n        * gfortran.dg/g77/980729-0.f: Likewise\n        * gfortran.dg/g77/981117-1.f: Likewise\n        * gfortran.dg/g77/toon_1.f: Likewise\n\nFrom-SVN: r84553", "tree": {"sha": "5d54cf67d22510888477cff45d8b50ca97ef734b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d54cf67d22510888477cff45d8b50ca97ef734b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62e39334a08066c17ead2da37ccb9209b2cc8e14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e39334a08066c17ead2da37ccb9209b2cc8e14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62e39334a08066c17ead2da37ccb9209b2cc8e14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62e39334a08066c17ead2da37ccb9209b2cc8e14/comments", "author": null, "committer": null, "parents": [{"sha": "7fb213d8e955ed3f21defe0d28ab63fe576574bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fb213d8e955ed3f21defe0d28ab63fe576574bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fb213d8e955ed3f21defe0d28ab63fe576574bd"}], "stats": {"total": 2158, "additions": 2158, "deletions": 0}, "files": [{"sha": "08a38d8930081925212e8135574c14ecf547de4a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -1,3 +1,46 @@\n+2004-07-12  David Billinghurst (David.Billinghurst@riotinto.com)\n+ \n+\t* gfortran.dg/g77/12002.f: Copy from g77.f-torture/compile .\n+\tAdd {dg-do compile} directive.\n+\t* gfortran.dg/g77/13060.f: Likewise\n+\t* gfortran.dg/g77/19990218-0.f: Likewise\n+\t* gfortran.dg/g77/19990305-0.f: Likewise\n+\t* gfortran.dg/g77/19990419-0.f: Likewise\n+\t* gfortran.dg/g77/19990502-0.f: Likewise\n+\t* gfortran.dg/g77/19990502-1.f: Likewise\n+\t* gfortran.dg/g77/19990525-0.f: Likewise\n+\t* gfortran.dg/g77/19990826-1.f: Likewise\n+\t* gfortran.dg/g77/19990826-3.f: Likewise\n+\t* gfortran.dg/g77/19990905-2.f: Likewise\n+\t* gfortran.dg/g77/20000412-1.f: Likewise\n+\t* gfortran.dg/g77/20000511-1.f: Likewise\n+\t* gfortran.dg/g77/20000511-2.f: Likewise\n+\t* gfortran.dg/g77/20000518.f: Likewise\n+\t* gfortran.dg/g77/20000601-1.f: Likewise\n+\t* gfortran.dg/g77/20000601-2.f: Likewise\n+\t* gfortran.dg/g77/20000629-1.f: Likewise\n+\t* gfortran.dg/g77/20000630-2.f: Likewise\n+\t* gfortran.dg/g77/20010115.f: Likewise\n+\t* gfortran.dg/g77/20010321-1.f: Likewise\n+\t* gfortran.dg/g77/20010426.f: Likewise\n+\t* gfortran.dg/g77/20020307-1.f: Likewise\n+\t* gfortran.dg/g77/8485.f: Likewise\n+\t* gfortran.dg/g77/960317-1.f: Likewise\n+\t* gfortran.dg/g77/970915-0.f: Likewise\n+\t* gfortran.dg/g77/980310-1.f: Likewise\n+\t* gfortran.dg/g77/980310-2.f: Likewise\n+\t* gfortran.dg/g77/980310-3.f: Likewise\n+\t* gfortran.dg/g77/980310-4.f: Likewise\n+\t* gfortran.dg/g77/980310-6.f: Likewise\n+\t* gfortran.dg/g77/980310-7.f: Likewise\n+\t* gfortran.dg/g77/980310-8.f: Likewise\n+\t* gfortran.dg/g77/980419-2.f: Likewise\n+\t* gfortran.dg/g77/980424-0.f: Likewise\n+\t* gfortran.dg/g77/980427-0.f: Likewise\n+\t* gfortran.dg/g77/980729-0.f: Likewise\n+\t* gfortran.dg/g77/981117-1.f: Likewise\n+\t* gfortran.dg/g77/toon_1.f: Likewise\n+\n 2004-07-12  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/2204"}, {"sha": "609573f4a62c99f13662cb4d8b718177075a70cf", "filename": "gcc/testsuite/gfortran.dg/g77/12002.f", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F12002.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F12002.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F12002.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,6 @@\n+C      PR middle-end/12002\n+C {dg-do compile }\n+       COMPLEX TE1\n+       TE1=-2.\n+       TE1=TE1+TE1\n+       END"}, {"sha": "4c1b3e7236322ccd1ea58495e0958ebd172351c7", "filename": "gcc/testsuite/gfortran.dg/g77/13060.f", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F13060.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F13060.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F13060.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,14 @@\n+c { dg-do compile }\n+      subroutine geo2()\n+      implicit none\n+\n+      integer ms,n,ne(2)\n+\n+      ne(1) = 1\n+      ne(2) = 2\n+      ms = 1\n+\n+      call call_me(ne(1)*ne(1))\n+\n+      n = ne(ms)\n+      end"}, {"sha": "631e74195eadc997c7fd20222e25d5899ec4296a", "filename": "gcc/testsuite/gfortran.dg/g77/19990218-0.f", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990218-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990218-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990218-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,14 @@\n+c { dg-do compile }\n+        program test\n+        double precision a,b,c\n+        data a,b/1.0d-46,1.0d0/\n+        c=fun(a,b)\n+        print*,'in main: fun=',c\n+        end\n+        double precision function fun(a,b)\n+        double precision a,b\n+        print*,'in sub: a,b=',a,b\n+        fun=a*b\n+        print*,'in sub: fun=',fun\n+        return\n+        end"}, {"sha": "9895c7bcc6b403f5fa05d765e4a301456928a23f", "filename": "gcc/testsuite/gfortran.dg/g77/19990305-0.f", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990305-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990305-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990305-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,56 @@\n+c { dg-do compile }\n+* Date: Fri, 5 Mar 1999 00:35:44 -0500 (EST)\n+* From: Denes Molnar <molnard@phys.columbia.edu>\n+* To: fortran@gnu.org\n+* Subject: f771 gets fatal signal 6\n+* Content-Type: TEXT/PLAIN; charset=US-ASCII\n+* X-UIDL: 8d81e9cbdcc96209c6e9b298d966ba7f\n+*\n+* Hi,\n+*\n+*\n+* Comiling object from the source code below WORKS FINE with\n+*   'g77 -o hwuci2 -c hwuci2.F'\n+* but FAILS with fatal signal 6\n+*   'g77 -o hwuci2 -O -c hwuci2.F'\n+*\n+* Any explanations?\n+*\n+* I am running GNU Fortran 0.5.23 with GCC 2.8.1 (glibc1).\n+*\n+*\n+* Denes Molnar\n+*\n+* %%%%%%%%%%%%%%%%%%%%%%%%%\n+* %the source:\n+* %%%%%%%%%%%%%%%%%%%%%%%%%\n+*\n+CDECK  ID>, HWUCI2.\n+*CMZ :-        -23/08/94  13.22.29  by  Mike Seymour\n+*-- Author :    Ulrich Baur & Nigel Glover, adapted by Ian Knowles\n+C-----------------------------------------------------------------------\n+      FUNCTION HWUCI2(A,B,Y0)\n+C-----------------------------------------------------------------------\n+C     Integral  LOG(A-EPSI-BY(1-Y))/(Y-Y0)\n+C-----------------------------------------------------------------------\n+      IMPLICIT NONE\n+      DOUBLE COMPLEX HWUCI2,HWULI2,EPSI,Y1,Y2,Z1,Z2,Z3,Z4\n+      DOUBLE PRECISION A,B,Y0,ZERO,ONE,FOUR,HALF\n+      EXTERNAL HWULI2\n+      COMMON/SMALL/EPSI\n+      PARAMETER (ZERO=0.D0, ONE =1.D0, FOUR= 4.D0, HALF=0.5D0)\n+      IF(B.EQ.ZERO)THEN\n+         HWUCI2=CMPLX(ZERO,ZERO)\n+      ELSE\n+         Y1=HALF*(ONE+SQRT(ONE-FOUR*(A+EPSI)/B))\n+         Y2=ONE-Y1\n+         Z1=Y0/(Y0-Y1)\n+         Z2=(Y0-ONE)/(Y0-Y1)\n+         Z3=Y0/(Y0-Y2)\n+         Z4=(Y0-ONE)/(Y0-Y2)\n+         HWUCI2=HWULI2(Z1)-HWULI2(Z2)+HWULI2(Z3)-HWULI2(Z4)\n+      ENDIF\n+      RETURN\n+      END\n+*\n+* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%"}, {"sha": "68f4ddabe97e33df61b3667bc968cf6b9eeb7217", "filename": "gcc/testsuite/gfortran.dg/g77/19990419-0.f", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990419-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990419-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990419-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,8 @@\n+c { dg-do compile }\n+* Test case Toon submitted, cut down to expose the one bug.\n+* Belongs in compile/.\n+      SUBROUTINE INIERS1\n+      IMPLICIT   LOGICAL(L)\n+      COMMON/COMIOD/ NHIERS1, LERS1\n+      inquire(nhiers1, exist=lers1)\n+      END"}, {"sha": "a82f8838db1ba32c874abfffa1cf38a657ccb03a", "filename": "gcc/testsuite/gfortran.dg/g77/19990502-0.f", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,67 @@\n+c { dg-do compile }\n+* Mailing-List: contact egcs-bugs-help@egcs.cygnus.com; run by ezmlm\n+* Precedence: bulk\n+* Sender: owner-egcs-bugs@egcs.cygnus.com\n+* From: Norbert Conrad <Norbert.Conrad@hrz.uni-giessen.de>\n+* Subject: egcs g77 19990524pre Internal compiler error in `print_operand'\n+* To: egcs-bugs@egcs.cygnus.com\n+* Date: Mon, 31 May 1999 11:46:52 +0200 (CET)\n+* Content-Type: text/plain; charset=US-ASCII\n+* X-UIDL: 9a00095a5fe4d774b7223de071157374\n+* \n+* Hi,\n+* \n+* I ./configure --prefix=/opt and bootstrapped egcs g77 snapshot 19990524\n+* on an i686-pc-linux-gnu. The program below gives an internal compiler error.\n+* \n+* \n+* Script started on Mon May 31 11:30:01 1999\n+* lx{g010}:/tmp>/opt/bin/g77 -v -O3 -malign-double -c e3.f\n+* g77 version gcc-2.95 19990524 (prerelease) (from FSF-g77 version 0.5.24-19990515)\n+* Reading specs from /opt/lib/gcc-lib/i686-pc-linux-gnu/gcc-2.95/specs\n+* gcc version gcc-2.95 19990524 (prerelease)\n+*  /opt/lib/gcc-lib/i686-pc-linux-gnu/gcc-2.95/f771 e3.f -quiet -dumpbase e3.f -malign-double -O3 -version -fversion -o /tmp/ccQgeaaa.s\n+* GNU F77 version gcc-2.95 19990524 (prerelease) (i686-pc-linux-gnu) compiled by GNU C version gcc-2.95 19990524 (prerelease).\n+* GNU Fortran Front End version 0.5.24-19990515\n+* e3.f:25: Internal compiler error in `print_operand', at ./config/i386/i386.c:3405\n+* Please submit a full bug report to `egcs-bugs@egcs.cygnus.com'.\n+* See <URL:http://egcs.cygnus.com/faq.html#bugreport> for details.\n+* lx{g010}:/tmp>cat e3.f\n+      SUBROUTINE DLASQ2( QQ, EE,  TOL2, SMALL2 )\n+      DOUBLE PRECISION   SMALL2, TOL2\n+      DOUBLE PRECISION   EE( * ), QQ( * )\n+      INTEGER            ICONV,  N, OFF\n+      DOUBLE PRECISION   QEMAX, XINF\n+      EXTERNAL           DLASQ3\n+      INTRINSIC          MAX, SQRT\n+      XINF = 0.0D0\n+      ICONV = 0\n+      IF( EE( N ).LE.MAX( QQ( N ), XINF, SMALL2 )*TOL2 ) THEN\n+      END IF\n+      IF( EE( N-2 ).LE.MAX( XINF, SMALL2,\n+     $    ( QQ( N ) / ( QQ( N )+EE( N-1 ) ) )* QQ( N-1 ))*TOL2 ) THEN\n+         QEMAX = MAX( QQ( N ), QQ( N-1 ), EE( N-1 ) )\n+      END IF\n+      IF( N.EQ.0 ) THEN\n+         IF( OFF.EQ.0 ) THEN\n+            RETURN\n+         ELSE\n+            XINF =0.0D0 \n+         END IF\n+      ELSE IF( N.EQ.2 ) THEN\n+      END IF\n+      CALL DLASQ3(ICONV)\n+      END\n+* lx{g010}:/tmp>exit\n+* \n+* Script done on Mon May 31 11:30:23 1999\n+* \n+* Best regards,\n+* \n+* Norbert.\n+* -- \n+* Norbert Conrad                             phone: ++49 641 9913021\n+* Hochschulrechenzentrum                     email: conrad@hrz.uni-giessen.de\n+* Heinrich-Buff-Ring 44\n+* 35392 Giessen\n+* Germany"}, {"sha": "ce5343db9bfaac983cc186fc5fd3199fd2071edf", "filename": "gcc/testsuite/gfortran.dg/g77/19990502-1.f", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990502-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,7 @@\n+c { dg-do compile }\n+      SUBROUTINE G(IGAMS,IWRK,NADC,NCellsInY)\n+      INTEGER*2 IGAMS(2,NADC)\n+      in = 1\n+      do while (in.le.nadc.and.IGAMS(2,in).le.in)\n+      enddo\n+      END"}, {"sha": "0baa802b66a23c5af23f3d222a9bde5d80fc2363", "filename": "gcc/testsuite/gfortran.dg/g77/19990525-0.f", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990525-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990525-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990525-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,51 @@\n+c { dg-do compile }\n+* Mailing-List: contact egcs-bugs-help@egcs.cygnus.com; run by ezmlm\n+* Precedence: bulk\n+* Sender: owner-egcs-bugs@egcs.cygnus.com\n+* From: \"Bjorn R. Bjornsson\" <brb@halo.hi.is>\n+* Subject: g77 char expr. as arg to subroutine bug\n+* To: egcs-bugs@egcs.cygnus.com\n+* Date: Tue, 25 May 1999 14:45:56 +0000 (GMT)\n+* Content-Type: text/plain; charset=US-ASCII\n+* X-UIDL: 06000c94269ed6dfe826493e52a818b9\n+* \n+* The following bug is in all snapshots starting\n+* from April 18.  I have only tested this on Alpha linux,\n+* and with FFECOM_FASTER_ARRAY_REFS set to 1.\n+* \n+* Run the following through g77:\n+* \n+\tsubroutine\ta\n+\tcharacter*2\tstring1\n+\tcharacter*2\tstring2\n+\tcharacter*4\tstring3\n+\tstring1 = 's1'\n+\tstring2 = 's2'\n+c\n+c the next 2 lines are ok.\n+\tstring3 = (string1 // string2)\n+\tcall b(string1//string2)\n+c\n+c this line gives gcc/f/com.c:10660: failed assertion `hook'\n+\tcall b((string1//string2))\n+\tend\n+* \n+* the output from:\n+* \n+* \t/usr/local/egcs-19990418/bin/g77 --verbose -c D.f\n+* \n+* is:\n+* \n+* on egcs-2.93.19 19990418 (gcc2 ss-980929 experimental) (from FSF-g77 version 0.5.24-19990418)\n+* Reading specs from /usr/local/egcs-19990418/lib/gcc-lib/alphaev56-unknown-linux-gnu/egcs-2.93.19/specs\n+* gcc version egcs-2.93.19 19990418 (gcc2 ss-980929 experimental)\n+*  /usr/local/egcs-19990418/lib/gcc-lib/alphaev56-unknown-linux-gnu/egcs-2.93.19/f771 D.f -quiet -dumpbase D.f -version -fversion -o /tmp/ccNpaaaa.s\n+* GNU F77 version egcs-2.93.19 19990418 (gcc2 ss-980929 experimental) (alphaev56-unknown-linux-gnu) compiled by GNU C version egcs-2.93.19 19990418 (gcc2 ss-980929 experimental).\n+* GNU Fortran Front End version 0.5.24-19990418\n+* ../../../egcs-19990418/gcc/f/com.c:10351: failed assertion `hook'\n+* g77: Internal compiler error: program f771 got fatal signal 6\n+* \n+* Yours,\n+* \n+* Bjorn R. Bjornsson\n+* brb@halo.hi.is"}, {"sha": "d9dd70b882ab7abbb6f51569efbc900cfe0d29a1", "filename": "gcc/testsuite/gfortran.dg/g77/19990826-1.f", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,287 @@\n+c { dg-do compile }\n+* Date: Tue, 24 Aug 1999 12:25:41 +1200 (NZST)\n+* From: Jonathan Ravens <ravens@whio.gns.cri.nz>\n+* To: gcc-bugs@gcc.gnu.org\n+* Subject: g77 bug report\n+* X-UIDL: a0bf5ecc21487cde48d9104983ab04d6\n+\n+! This fortran source will not compile - if the penultimate elseif block is 0\n+! included then the message appears :\n+!\n+!   /usr/src/egcs//gcc-2.95.1/gcc/f/stw.c:308: failed assertion `b->uses_ > 0'\n+!   g77: Internal compiler error: program f771 got fatal signal 6\n+!\n+! The command was : g77 -c <prog.f>\n+!\n+! The OS is Red Hat 6, and the output from uname -a is \n+!   Linux grfw1452.gns.cri.nz 2.2.5-15 #1 Mon Apr 19 23:00:46 EDT 1999 i686 unknown\n+!\n+! The configure script I used was \n+!   /usr/src/egcs/gcc/gcc-2.95.1/configure --enable-languages=f77 i585-unknown-linux\n+!\n+! I was installing 2.95 because under EGCS 2.1.1 none of my code was working\n+! with optimisation turned on, and there were still bugs with no optimisation\n+! (all of which code works fine under g77 0.5.21 and Sun/IBM/Dec/HP fortrans).\n+!\n+! The version of g77 is :\n+!\n+!g77 version 2.95.1 19990816 (release) (from FSF-g77 version 0.5.25 19990816 (release))\n+\n+        program main\n+        if (i.eq.1) then\n+            call abc(1)\n+        else if (i.eq. 1) then\n+            call abc( 1)\n+        else if (i.eq. 2) then\n+            call abc( 2)\n+        else if (i.eq. 3) then\n+            call abc( 3)\n+        else if (i.eq. 4) then\n+            call abc( 4)\n+        else if (i.eq. 5) then\n+            call abc( 5)\n+        else if (i.eq. 6) then\n+            call abc( 6)\n+        else if (i.eq. 7) then\n+            call abc( 7)\n+        else if (i.eq. 8) then\n+            call abc( 8)\n+        else if (i.eq. 9) then\n+            call abc( 9)\n+        else if (i.eq. 10) then\n+            call abc( 10)\n+        else if (i.eq. 11) then\n+            call abc( 11)\n+        else if (i.eq. 12) then\n+            call abc( 12)\n+        else if (i.eq. 13) then\n+            call abc( 13)\n+        else if (i.eq. 14) then\n+            call abc( 14)\n+        else if (i.eq. 15) then\n+            call abc( 15)\n+        else if (i.eq. 16) then\n+            call abc( 16)\n+        else if (i.eq. 17) then\n+            call abc( 17)\n+        else if (i.eq. 18) then\n+            call abc( 18)\n+        else if (i.eq. 19) then\n+            call abc( 19)\n+        else if (i.eq. 20) then\n+            call abc( 20)\n+        else if (i.eq. 21) then\n+            call abc( 21)\n+        else if (i.eq. 22) then\n+            call abc( 22)\n+        else if (i.eq. 23) then\n+            call abc( 23)\n+        else if (i.eq. 24) then\n+            call abc( 24)\n+        else if (i.eq. 25) then\n+            call abc( 25)\n+        else if (i.eq. 26) then\n+            call abc( 26)\n+        else if (i.eq. 27) then\n+            call abc( 27)\n+        else if (i.eq. 28) then\n+            call abc( 28)\n+        else if (i.eq. 29) then\n+            call abc( 29)\n+        else if (i.eq. 30) then\n+            call abc( 30)\n+        else if (i.eq. 31) then\n+            call abc( 31)\n+        else if (i.eq. 32) then\n+            call abc( 32)\n+        else if (i.eq. 33) then\n+            call abc( 33)\n+        else if (i.eq. 34) then\n+            call abc( 34)\n+        else if (i.eq. 35) then\n+            call abc( 35)\n+        else if (i.eq. 36) then\n+            call abc( 36)\n+        else if (i.eq. 37) then\n+            call abc( 37)\n+        else if (i.eq. 38) then\n+            call abc( 38)\n+        else if (i.eq. 39) then\n+            call abc( 39)\n+        else if (i.eq. 40) then\n+            call abc( 40)\n+        else if (i.eq. 41) then\n+            call abc( 41)\n+        else if (i.eq. 42) then\n+            call abc( 42)\n+        else if (i.eq. 43) then\n+            call abc( 43)\n+        else if (i.eq. 44) then\n+            call abc( 44)\n+        else if (i.eq. 45) then\n+            call abc( 45)\n+        else if (i.eq. 46) then\n+            call abc( 46)\n+        else if (i.eq. 47) then\n+            call abc( 47)\n+        else if (i.eq. 48) then\n+            call abc( 48)\n+        else if (i.eq. 49) then\n+            call abc( 49)\n+        else if (i.eq. 50) then\n+            call abc( 50)\n+        else if (i.eq. 51) then\n+            call abc( 51)\n+        else if (i.eq. 52) then\n+            call abc( 52)\n+        else if (i.eq. 53) then\n+            call abc( 53)\n+        else if (i.eq. 54) then\n+            call abc( 54)\n+        else if (i.eq. 55) then\n+            call abc( 55)\n+        else if (i.eq. 56) then\n+            call abc( 56)\n+        else if (i.eq. 57) then\n+            call abc( 57)\n+        else if (i.eq. 58) then\n+            call abc( 58)\n+        else if (i.eq. 59) then\n+            call abc( 59)\n+        else if (i.eq. 60) then\n+            call abc( 60)\n+        else if (i.eq. 61) then\n+            call abc( 61)\n+        else if (i.eq. 62) then\n+            call abc( 62)\n+        else if (i.eq. 63) then\n+            call abc( 63)\n+        else if (i.eq. 64) then\n+            call abc( 64)\n+        else if (i.eq. 65) then\n+            call abc( 65)\n+        else if (i.eq. 66) then\n+            call abc( 66)\n+        else if (i.eq. 67) then\n+            call abc( 67)\n+        else if (i.eq. 68) then\n+            call abc( 68)\n+        else if (i.eq. 69) then\n+            call abc( 69)\n+        else if (i.eq. 70) then\n+            call abc( 70)\n+        else if (i.eq. 71) then\n+            call abc( 71)\n+        else if (i.eq. 72) then\n+            call abc( 72)\n+        else if (i.eq. 73) then\n+            call abc( 73)\n+        else if (i.eq. 74) then\n+            call abc( 74)\n+        else if (i.eq. 75) then\n+            call abc( 75)\n+        else if (i.eq. 76) then\n+            call abc( 76)\n+        else if (i.eq. 77) then\n+            call abc( 77)\n+        else if (i.eq. 78) then\n+            call abc( 78)\n+        else if (i.eq. 79) then\n+            call abc( 79)\n+        else if (i.eq. 80) then\n+            call abc( 80)\n+        else if (i.eq. 81) then\n+            call abc( 81)\n+        else if (i.eq. 82) then\n+            call abc( 82)\n+        else if (i.eq. 83) then\n+            call abc( 83)\n+        else if (i.eq. 84) then\n+            call abc( 84)\n+        else if (i.eq. 85) then\n+            call abc( 85)\n+        else if (i.eq. 86) then\n+            call abc( 86)\n+        else if (i.eq. 87) then\n+            call abc( 87)\n+        else if (i.eq. 88) then\n+            call abc( 88)\n+        else if (i.eq. 89) then\n+            call abc( 89)\n+        else if (i.eq. 90) then\n+            call abc( 90)\n+        else if (i.eq. 91) then\n+            call abc( 91)\n+        else if (i.eq. 92) then\n+            call abc( 92)\n+        else if (i.eq. 93) then\n+            call abc( 93)\n+        else if (i.eq. 94) then\n+            call abc( 94)\n+        else if (i.eq. 95) then\n+            call abc( 95)\n+        else if (i.eq. 96) then\n+            call abc( 96)\n+        else if (i.eq. 97) then\n+            call abc( 97)\n+        else if (i.eq. 98) then\n+            call abc( 98)\n+        else if (i.eq. 99) then\n+            call abc( 99)\n+        else if (i.eq. 100) then\n+            call abc( 100)\n+        else if (i.eq. 101) then\n+            call abc( 101)\n+        else if (i.eq. 102) then\n+            call abc( 102)\n+        else if (i.eq. 103) then\n+            call abc( 103)\n+        else if (i.eq. 104) then\n+            call abc( 104)\n+        else if (i.eq. 105) then\n+            call abc( 105)\n+        else if (i.eq. 106) then\n+            call abc( 106)\n+        else if (i.eq. 107) then\n+            call abc( 107)\n+        else if (i.eq. 108) then\n+            call abc( 108)\n+        else if (i.eq. 109) then\n+            call abc( 109)\n+        else if (i.eq. 110) then\n+            call abc( 110)\n+        else if (i.eq. 111) then\n+            call abc( 111)\n+        else if (i.eq. 112) then\n+            call abc( 112)\n+        else if (i.eq. 113) then\n+            call abc( 113)\n+        else if (i.eq. 114) then\n+            call abc( 114)\n+        else if (i.eq. 115) then\n+            call abc( 115)\n+        else if (i.eq. 116) then\n+            call abc( 116)\n+        else if (i.eq. 117) then\n+            call abc( 117)\n+        else if (i.eq. 118) then\n+            call abc( 118)\n+        else if (i.eq. 119) then\n+            call abc( 119)\n+        else if (i.eq. 120) then\n+            call abc( 120)\n+        else if (i.eq. 121) then\n+            call abc( 121)\n+        else if (i.eq. 122) then\n+            call abc( 122)\n+        else if (i.eq. 123) then\n+            call abc( 123)\n+        else if (i.eq. 124) then\n+            call abc( 124)\n+        else if (i.eq. 125) then           !< Miscompiles if present\n+            call abc( 125)                 !<\n+\n+c        else if (i.eq. 126) then\n+c            call abc( 126)\n+        endif\n+        end"}, {"sha": "aeaf443999687879b78636aac4366250a3f7d4c5", "filename": "gcc/testsuite/gfortran.dg/g77/19990826-3.f", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990826-3.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,321 @@\n+c { dg-do compile }\n+* Date: Thu, 19 Aug 1999 10:02:32 +0200\n+* From: Frederic Devernay <devernay@istar.fr>\n+* Organization: ISTAR\n+* X-Accept-Language: French, fr, en\n+* To: gcc-bugs@gcc.gnu.org\n+* Subject: g77 2.95 bug (Internal compiler error in `final_scan_insn')\n+* X-UIDL: 08443f5c374ffa382a05573281482f4f\n+\n+* Here's a bug that happens only when I compile with -O (disappears with\n+* -O2)\n+\n+* > g77 -v --save-temps -O -c  pcapop.f\n+* g77 version 2.95 19990728 (release) (from FSF-g77 version 0.5.25\n+* 19990728 (release))\n+* Reading specs from\n+* /usr/local/lib/gcc-lib/sparc-sun-solaris2.6/2.95/specs\n+* gcc version 2.95 19990728 (release)\n+*  /usr/local/lib/gcc-lib/sparc-sun-solaris2.6/2.95/f771 pcapop.f -quiet\n+* -dumpbase pcapop.f -O -version -fversion -o pcapop.s\n+* GNU F77 version 2.95 19990728 (release) (sparc-sun-solaris2.6) compiled\n+* by GNU C version 2.95 19990728 (release).\n+* GNU Fortran Front End version 0.5.25 19990728 (release)\n+* pcapop.f: In subroutine `pcapop':\n+* pcapop.f:291: Internal compiler error in `final_scan_insn', at\n+* final.c:2920\n+* Please submit a full bug report.\n+* See <URL:http://egcs.cygnus.com/faq.html#bugreport> for instructions.\n+\n+C* PCAPOP\n+\tSUBROUTINE PCAPOP(M1,M2,L1,L2,NMEM,N1,N2,IB,IBB,K3,TF,TS,TC,TTO)\n+\tDIMENSION NVA(6),C(6),I(6)\n+C\n+C CALCUL DES PARAMETRES OPTIMAUX N1 N2 IB IBB\n+C\n+\tTACC=.035\n+\tTTRANS=.000004\n+\tRAD=.000001\n+\tRMI=.000001\n+\tRMU=.0000015\n+\tRDI=.000003\n+\tRTE=.000003\n+\tREQ=.000005\n+\tVY1=3*RTE+RDI+8*REQ+3*(RAD+RMI+RMU)\n+\tVY2=REQ+2*RAD\n+\tAR2=M2*(2*(REQ+RMI)+3*RMU+M1*(2*RAD+REQ))\n+C     VARIATION DE L1,L2,\n+C\n+\tTTOTOP=1.E+10\n+\tN1CO=0\n+\tN2CO=0\n+\tIBCO=0\n+\tIBBCO=0\n+\tK3CO=0\n+\tTESOP=0.\n+\tTCOP=0.\n+\tTFOP=0.\n+\t INUN=7\n+\t INDE=7\n+\t IF(M1.LT.128)INUN=6\n+\t IF(M1.LT.64)INUN=5\n+\t IF(M1.LT.32)INUN=4\n+\t IF(M2.LT.128)INDE=6\n+\t IF(M2.LT.64)INDE=5\n+\t IF(M2.LT.32)INDE=4\n+\tDO 3 NUN =3,INUN\n+\tDO 3 NDE=3,INDE\n+\tN10=2**NUN\n+\tN20=2**NDE\n+\tNDIF=(N10-N20)\n+\tNDIF=IABS(NDIF)\n+C POUR AVOIR CES RESULTATS FAIRE TOURNER LE PROGRAMME VEFFT1\n+\t TCFFTU=0.\n+\tIF(N10.EQ.128.AND.N20.EQ.128)TCFFTU=3.35\n+\tIF(N10.EQ.64.AND.N20.EQ.64)TCFFTU=.70\n+\tIF(N10.EQ.32.AND.N20.EQ.32)TCFFTU=.138\n+\tIF(N10.EQ.16.AND.N20.EQ.16)TCFFTU=.0332\n+\tIF(N10.EQ.8.AND.N20.EQ.8)TCFFTU=.00688\n+\tIF(NDIF.EQ.64)TCFFTU=1.566\n+\tIF(NDIF.EQ.96)TCFFTU=.709\n+\tIF(NDIF.EQ.112)TCFFTU=.349\n+\tIF(NDIF.EQ.120)TCFFTU=.160\n+\tIF(NDIF.EQ.32)TCFFTU=.315\n+\tIF(NDIF.EQ.48)TCFFTU=.154\n+\tIF(NDIF.EQ.56)TCFFTU=.07\n+\tIF(NDIF.EQ.16)TCFFTU=.067\n+\tIF(NDIF.EQ.24)TCFFTU=.030\n+\tIF(NDIF.EQ.8)TCFFTU=.016\n+\tN30=N10-L1+1\n+\tN40=N20-L2+1\n+\tWW=VY1+N30*VY2\n+\tNDOU=2*N10*N20\n+\tIF((N10.LT.L1).OR.(N20.LT.L2)) GOTO 3\n+\tNB=NMEM-NDOU-N20*(L1-1)\n+\tNVC=2*N10*(N20-1)+M1\n+\tIF(NB.LT.(NVC)) GOTO 3\n+\tCALL VALENT(M1,N30,K1)\n+\tCALL VALENT(M2,N40,K2)\n+\tIS=K1/2\n+\tIF((2*IS).NE.K1)K1=K1+1\n+\t    TFF=TCFFTU*K1*K2\n+\tCALL VALENT(M2,N40,JOFI)\n+\tIF(NB.GE.(K1*N20*N30+2*N20*(L1-1))) GOTO 4\n+\tTIOOP=1.E+10\n+\tIC=1\n+18    IB1=2*IC\n+\tMAX=(NB-2*N20*(L1-1))/(N20*N30)\n+\tIN=MAX/2\n+\tIF(MAX.NE.2*IN) MAX=MAX-1\n+\tK3=K1/IB1\n+\tIBB1=K1-K3*IB1\n+\tIOFI=M1/(IB1*N30)\n+\tIRZ=0\n+\tIF(IOFI*IB1*N30.EQ.M1) GOTO1234\n+\tIRZ=1\n+\tIOFI=IOFI+1\n+\tIF(IBB1.EQ.0) GOTO 1234\n+\tIF(M1.EQ.((IOFI-1)*IB1*N30+IBB1*N30)) GOTO 1233\n+\tIRZ=2\n+\tGOTO 1234\n+1233  IRZ=3\n+1234  IBX1=IBB1\n+\tIF(IBX1.EQ.0)IBX1=IB1\n+\tAR1=M2*(2*(RAD+RMI+RMU+REQ)+(M1-(IOFI-1)*IB1*N30)*2*(REQ+RAD))\n+     %+M2*(3*(REQ+RMU+RAD)+4*RMI+(M1-(IOFI-1)*IB1*N30)*(2*RAD+REQ)\n+     %+(IOFI-1)*IB1*N30*(2*RMI+REQ+RAD))\n+\tAR5=(JOFI-1)*(N20-L2)*(M1-(IOFI-1)*IB1*N30)*(2*(RAD+RMU)+REQ)\n+     %*IOFI+(M2-(JOFI-1)*N40+L2-2)*(M1-(IOFI-1)*IB1*N30)*(2*(RAD+RMU\n+     %)+REQ)*IOFI\n+\tWQ=((IOFI-1)*IB1+IBX1)*JOFI*WW\n+\tAT1=N20*WQ\n+\tAT2=N40*WQ\n+\tQW=JOFI*(VY1+VY2*IB1*N30)\n+\tAT3=IOFI*N40*QW\n+\tAT4=(IOFI-1)*N40*QW\n+\tAT5=JOFI*((IOFI-1)*N40*(IB1/IBX1)*(VY1+IBX1*N30*VY2)\n+     %+N40*((IB1/IBX1)*(IOFI-1)+1)*(VY1+IBX1*N30*VY2))\n+\tAT6=JOFI*((IOFI-1)*N40*(IB1/2)*(VY1+2*N30*VY2)+N40*(\n+     %IB1*(IOFI-1)/2+IBX1/2)*(VY1+2*N30*VY2))\n+\tT1=JOFI*N20*(L1-1)*REQ\n+\tT2=M1*(L2-1)*REQ\n+\tT3=JOFI*N20*IBX1*N30*(RAD+REQ)\n+\tT4=JOFI*((IOFI-1)*IB1*N30*N20*(2*RMI+REQ)+IBX1*N30*N20*(2*RMI+R\n+     %EQ))\n+\tT5=JOFI*((IOFI-1)*IB1/2+IBX1/2)*N20*N30*(2*RAD+REQ)\n+\tT6=2*JOFI*(((IOFI-1)*IB1+IBX1)*N20)*((5*(RMI+RMU)+4*RAD\n+     %)+(L1-1)*(2*RAD+REQ)+N30*(2*RAD+REQ))\n+\tT7=JOFI*2*((IOFI-1)*IB1+IBX1)*(L1-1)*(2*RAD+REQ)\n+\tT8=JOFI*N10*N20*((IOFI-1)*IB1/2+IBX1/2)*(3*REQ+9*RAD+4*RMU+RMI)\n+\tT9=N10*N20*JOFI*((IOFI-1)*IB1/2+IBX1/2)*(REQ+RMI)+M1*M2*(REQ+R\n+     %DI+2*RAD)\n+\tT10=JOFI*((IOFI-1)*IB1/2+IBX1/2)*2*(3*RMU+2*(RMI+RAD)+N40*(3*RMI\n+     %+4*RMU+3*(RAD+REQ)+N30*(2*RAD+REQ)))\n+\tPOI=JOFI\n+\tIF(POI.LE.2)POI=2\n+\tTNRAN=(N40+(POI-2)*N20+(M2-(JOFI-1)*N40+L2-1))*(RMI+RMU+RAD\n+     %+REQ+N30*(2*RAD+2*REQ)*(IB1*(IOFI-1)+IBX1))\n+\tIF(TNRAN.LT.0.)TNRAN=0.\n+\tTCPU=T1+T2+T3+T4+T5+T6+T7+T8+T9+T10+TNRAN\n+\tNVA(1)=N40\n+\tNVA(2)=N40\n+\tNVA(3)=N20\n+\tNVA(4)=N20\n+\tNVA(5)=M2-(JOFI-1)*N40\n+\tNVA(6)=NVA(5)\n+\tC(1)=FLOAT(IB1*N30)/FLOAT(M1)\n+\tC(2)=FLOAT(M1-(IOFI-1)*IB1*N30)/FLOAT(M1)\n+\tC(3)=C(1)\n+\tC(4)=C(2)\n+\tC(5)=C(1)\n+\tC(6)=C(2)\n+\tK=1\n+\tP1=FLOAT(NB)/FLOAT(M1)\n+10    IP1=P1\n+\tI(K)=1\n+\tIF(IP1.GE.NVA(K)) GOTO 7\n+\tP2=P1\n+\tIP2=P2\n+8     P2=P2-FLOAT(IP2)*C(K)\n+\tIP2=P2\n+\tIF(IP2.EQ.0) GOTO 3\n+\tIP1=IP1+IP2\n+\tI(K)=I(K)+1\n+\tIF(IP1.GE.NVA(K))GOTO 7\n+\tGOTO 8\n+7     IF(K.EQ.6) GOTO 11\n+\tK=K+1\n+\tGOTO 10\n+11    IP1=0\n+\tIP2=0\n+\tIP3=0\n+\tPOFI=JOFI\n+\tIF(POFI.LE.2)POFI=2\n+\tTIOL=(I(2)+(IOFI-1)*I(1)+(POFI-2)*(IOFI-1)*I(3)+(POFI-\n+     %2)*I(4)+(IOFI-1)*I(5)+I(6))*TACC+(IOFI*M1*N40+(POFI-2)*IOFI*\n+     %M1*N20+(M2-(JOFI-1)*N40+L2-1)*M1*IOFI)*TTRANS\n+\tIF(IBB1.EQ.0) GOTO 33\n+\tIF(IB1.EQ.IBB1) GOTO 33\n+\tIF(IBB1.EQ.2)GOTO 34\n+\tIP3=1\n+\tINL=NMEM/((IOFI-1)*IB1*N30+IBB1*N30)\n+55    IF(INL.GT.N40)INL=N40\n+\tGOTO 35\n+33    IF(IB1.GT.2) GOTO 36\n+\tIF((M1-(IOFI-1)*IB1*N30).GE.N30) GOTO 36\n+34    IP1=1\n+\tINL=NMEM/(2*M1-(IOFI-1)*IB1*N30)\n+\tGOTO 55\n+36    IP2=1\n+\tINL=NMEM/(IOFI*IB1*N30)\n+\tIF(INL.GT.N40)INL=N40\n+35    CALL VALENT(N40,INL,KN1)\n+\tCALL VALENT(M2-(JOFI-1)*N40,INL,KN2)\n+\tCALL VALENT(INL*IBB1,IB1,KN3)\n+\tCALL VALENT((N40-(KN1-1)*INL)*IBB1,IB1,KN4)\n+\tIF((IP1+IP2+IP3).NE.1) CALL ERMESF(14)\n+\tTIO1=0.\n+\tIF(IP3.EQ.1)TIO1=N30*M2*TTRANS*(IB1*(IOFI-1)+IBB1)\n+\tIF(IP1.EQ.1)TIO1=M1*M2*TTRANS\n+\tIF(IP2.EQ.1) TIO1=(IB1*N30*M2*IOFI*TTRANS)\n+\tTTIO=2.*TIO1+(KN1*IOFI*(JOFI-1)+KN2*IOFI+(KN1-1)*(\n+     %JOFI-1)+IOFI*(JOFI-1)+KN2-1.+IOFI+(KN1*(JOFI-1)+KN2))*TACC\n+     %+M1*M2*TTRANS+TIOL\n+\tIF((IP1.EQ.1).AND.(IRZ.EQ.0))TCPU=TCPU+AT1+AT2+AT3\n+\tIF((IP1.EQ.1).AND.(IRZ.NE.0))TCPU=TCPU+AT1+AT2+AT4+AR1\n+\tIF((IP2.EQ.1).AND.(IRZ.EQ.0))TCPU=TCPU+AT1+AT2+AT3\n+\tIF((IP2.EQ.1).AND.(IRZ.NE.0))TCPU=TCPU+AT1+AT2+AT3+AR2\n+\tIFOIS=IB1/IBX1\n+\tIF((IP3.EQ.1).AND.(IFOIS*IBX1.EQ.IB1))TCPU=TCPU+AT1+AT2+AT5+AR2\n+\tIF((IP3.EQ.1).AND.(IFOIS*IBX1.NE.IB1))TCPU=TCPU+AT1+AT2+AT6+AR2\n+\tIF((IP1.EQ.1).AND.(IRZ.EQ.1))TCPU=TCPU+AR5\n+\tIF((IP1.EQ.1).AND.(IRZ.EQ.2))TCPU=TCPU+AR5\n+\tTTIOG=TTIO+TCPU\n+\tIF(TTIOG.LE.0.) GOTO 99\n+\tIF(TTIOG.GE.TIOOP) GOTO 99\n+\tIBOP=IB1\n+\tIBBOP=IBB1\n+\tK3OP=K3\n+\tTIOOP=TTIOG\n+\tTIOOP1=TTIO\n+\tTIOOP2=TCPU\n+99    IF(IB1.GE.MAX)GOTO17\n+\tIC=IC+1\n+\tGOTO 18\n+4     T1=JOFI*N20*(L1-1)*REQ\n+\tT2=M1*(L2-1)*REQ\n+\tT3=JOFI*N20*N30*(RAD+REQ)*K1\n+\tT4=JOFI*(K1*N30*N20*(2*RMI+REQ))\n+\tT5=JOFI*N20*N30*(2*RAD+REQ)*K1/2\n+\tT6=2*JOFI*(K1*N20)*((5*RMI+RMU)+4*RAD+(L1-1)*(2*RAD+REQ)+N30*2*\n+     %RAD+REQ)\n+\tT7=JOFI*2*K1*(L1-1)*(2*RAD+REQ)\n+\tT9=JOFI*N10*N20*K1*(REQ+RMI)/2+M1*M2*(REQ+RDI+2*RAD)\n+\tT8=JOFI*N10*N20*K1*(3*REQ+9*RAD+4*RMU+RMI)/2\n+\tT10=JOFI*K1*(3*RMU+2*(RMI+RAD)+N40*(3*RMI\n+     %+4*RMU+3*(RAD+REQ)+N30*(2*RAD+REQ)))\n+\tPIO=JOFI\n+\tIF(PIO.LE.2)PIO=2\n+\tTNR=(N40+(PIO-2)*N20+(M2-(JOFI-1)*N40+L2-1))*(RMU+RMI+RAD+REQ+\n+     %N30*(2*RAD+2*REQ)*K1)\n+\tIF(TNR.LE.0.)TNR=0.\n+\tBT1=JOFI*N20*WW*K1\n+\tBT2=JOFI*N40*WW*K1\n+\tBT3=JOFI*N40*(VY1+K1*N30*VY2)\n+\tBR1=M2*(2*(RAD+RMI+RMU+REQ)+(M1*2*(REQ+RAD)))+M2*(3*(\n+     $REQ+RAD+RMU)+4*(RMI)+M1*(2*(RAD)+REQ))\n+\tBR2=M2*(2*(REQ+RMI)+3*RMU+M1*(2*RAD+REQ))\n+\tTCPU=T1+T2+T3+T4+T5+T6+T7+T8+T9+T10\n+\tTCPU=TCPU+TNR+BT1+BT2\n+\tLIOF=M1/(N30)\n+\tIRZ=0\n+\tIF(LIOF*N30.EQ.M1) GOTO 2344\n+\tIRZ=1\n+2344  IF(IRZ.EQ.0)TCPU=TCPU+BT3\n+\tIF(IRZ.NE.0)TCPU=TCPU+BT3+BR2\n+\tTIOOP=2.*FLOAT(M1)*FLOAT(M2)*TTRANS+2.*FLOAT(K2)*TACC+TCPU\n+\tIBOP=1\n+\tIBBOP=0\n+\tK3OP=1\n+\tTIOOP2=TCPU\n+\tTIOOP1=TIOOP-TCPU\n+17    TTOT=TIOOP+TFF\n+\tIF(TTOT.LE.0.) GOTO 3\n+\tIF(TTOT.GE.TTOTOP)GOTO3\n+\tN1CO=N10\n+\tN2CO=N20\n+\tIBCO=IBOP\n+\tIBBCO=IBBOP\n+\tK3CO=K3OP\n+\tTTOTOP=TTOT\n+\tTESOP=TIOOP1\n+\tTCOP=TIOOP2\n+\tTFOP=TFF\n+3     CONTINUE\n+ \n+C\n+\tN1=N1CO\n+\tN2=N2CO\n+\tTTO=TTOTOP\n+\tIB=IBCO\n+\tIBB=IBBCO\n+\tK3=K3CO\n+\tTC=TCOP\n+\tTS=TESOP\n+\tTF=TFOP\n+\t   TT=TCOP+TFOP\n+\t  TWER=TTO-TT\n+\tIF(N1.EQ.0.OR.N2.EQ.0) CALL OUTSTR(0,'PAS DE PLACE MEMOIRE SUFFISA\n+     $NTE POUR UNE MISE EN OEUVRE PAR BLOCS$')\n+\t IF(IB.NE.1)RETURN\n+\t IHJ=(M1/(N1-L1+1))\n+\t IF(IHJ*(N1-L1+1).NE.M1)IHJ=IHJ+1\n+\t  IHJ1=IHJ/2\n+\t IF(IHJ1*2.NE.IHJ)GOTO7778\n+\t IB=IHJ\n+\t IBB=0\n+\t    RETURN\n+7778   IB=IHJ+1\n+\t IBB=0\n+\t   RETURN\n+\t END"}, {"sha": "7acfb099fb1770387b90f97a3170d1b664edbf0c", "filename": "gcc/testsuite/gfortran.dg/g77/19990905-2.f", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F19990905-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,23 @@\n+c { dg-do compile }\n+* =watson11.f in Burley's g77 test suite.\n+* Probably originally submitted by Ian Watson.\n+* Too small to worry about copyright issues, IMO, since it\n+* doesn't do anything substantive.\n+      SUBROUTINE OUTDNS(A,B,LCONV)\n+      IMPLICIT REAL*8(A-H,O-Z),INTEGER*4(I-N)\n+      COMMON/ARRAYS/Z(64,8),AB(30,30),PAIRS(9,9),T(9,9),TEMP(9,9),C1(3),\n+     >  C2(3),AA(30),BB(30)\n+      EQUIVALENCE (X1,C1(1)),(Y1,C1(2)),(Z1,C1(3))\n+      EQUIVALENCE (X2,C2(1)),(Y2,C2(2)),(Z2,C2(3))\n+      COMMON /CONTRL/\n+     >  SHIFT,CONV,SCION,DIVERG,\n+     >  IOPT,KCNDO,KINDO,KMINDO,I2EINT,KOHNO,KSLATE,\n+     >  N,NG,NUMAT,NSEK,NELECS,NIT,OCCA,OCCB,NOLDAT,NOLDFN\n+      INTEGER*4 OCCA,OCCB\n+      DIMENSION W(N),A(N,N),B(N,N)\n+      DIMENSION BUF(100)\n+      occb=5\n+      ENTRY INDNS (A,B)\n+   40 READ(IREAD) BUF\n+      STOP\n+      END"}, {"sha": "af403ef9b8aa9e4220bc3b265270b7352fad1d63", "filename": "gcc/testsuite/gfortran.dg/g77/20000412-1.f", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000412-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000412-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000412-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,6 @@\n+c { dg-do compile }\n+      subroutine aap(k)\n+      equivalence (i,r)\n+      i = k\n+      print*,r\n+      end"}, {"sha": "fca4bf94080884ea370c31d0eb1c79dc3807c918", "filename": "gcc/testsuite/gfortran.dg/g77/20000511-1.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,22 @@\n+c { dg-do compile }\n+      subroutine saxpy(n,sa,sx,incx,sy,incy)\n+C\n+C     constant times a vector plus a vector.\n+C     uses unrolled loop for increments equal to one.\n+C     jack dongarra, linpack, 3/11/78.\n+C     modified 12/3/93, array(1) declarations changed to array(*)\n+C\n+      real sx(*),sy(*),sa\n+      integer i,incx,incy,ix,iy,m,mp1,n\n+C\n+C  -ffast-math ICE provoked by this conditional\n+      if(sa /= 0.0)then\n+C\n+C        code for both increments equal to 1\n+C\n+\t      do i= 1,n\n+\t\tsy(i)= sy(i)+sa*sx(i)\n+\t\tenddo\n+\tendif\n+      return\n+      end"}, {"sha": "b3a3ca3dfd46f7c2e743cb74f96be34df18d81f9", "filename": "gcc/testsuite/gfortran.dg/g77/20000511-2.f", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000511-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,62 @@\n+c { dg-do compile }\n+      subroutine sgbcon(norm,n,kl,ku,ab,ldab,ipiv,anorm,rcond,work,iwork\n+     &,info)\n+C\n+C  -- LAPACK routine (version 3.0) --\n+C     Univ. of Tennessee, Univ. of California Berkeley, NAG Ltd.,\n+C     Courant Institute, Argonne National Lab, and Rice University\n+C     September 30, 1994\n+C\n+C     .. Scalar Arguments ..\n+      character norm\n+      integer info,kl,ku,ldab,n\n+      real anorm,rcond\n+C     ..\n+C     .. Array Arguments ..\n+      integer ipiv(n),iwork(n)\n+      real ab(ldab,n),work(n)\n+C     ..\n+C\n+C  Purpose\n+C  =======\n+C demonstrate g77 bug at -O -funroll-loops\n+C  =====================================================================\n+C\n+C     .. Parameters ..\n+      real one,zero\n+      parameter(one= 1.0e+0,zero= 0.0e+0)\n+C     ..\n+C     .. Local Scalars ..\n+      logical lnoti,onenrm\n+      character normin\n+      integer ix,j,jp,kase,kase1,kd,lm\n+      real ainvnm,scale,smlnum,t\n+C     ..\n+C     .. External Functions ..\n+      logical lsame\n+      integer isamax\n+      real sdot,slamch\n+      externallsame,isamax,sdot,slamch\n+C     ..\n+C     .. External Subroutines ..\n+      externalsaxpy,slacon,slatbs,srscl,xerbla\n+C     ..\n+C     .. Executable Statements ..\n+C\n+C           Multiply by inv(L).\n+C\n+      do j= 1,n-1\n+C the following min() intrinsic provokes this bug\n+\t  lm= min(kl,n-j)\n+\t  jp= ipiv(j)\n+\t  t= work(jp)\n+\t  if(jp.ne.j)then\n+C but only when combined with this if block\n+\t      work(jp)= work(j)\n+\t      work(j)= t\n+\t    endif\n+C and this subroutine call\n+\t  call saxpy(lm,-t,ab(kd+1,j),1,work(j+1),1)\n+\tenddo\n+      return\n+      end"}, {"sha": "ac25f25ac54298c2e72e5d1290933b7d7e9a04c8", "filename": "gcc/testsuite/gfortran.dg/g77/20000518.f", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000518.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000518.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000518.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,17 @@\n+c { dg-do compile }\n+      SUBROUTINE SORG2R( K, A, N, LDA )\n+*  ICE in `verify_wide_reg_1', at flow.c:2605 at -O2\n+*  g77 version 2.96 20000515 (experimental) on i686-pc-linux-gnu\n+*\n+*  Originally derived from LAPACK 3.0 test suite failure.\n+*\n+*  David Billinghurst, (David.Billinghurst@riotinto.com.au)\n+*  18 May 2000\n+      INTEGER            I, K, LDA, N\n+      REAL               A( LDA, * )\n+      DO I = K, 1, -1\n+         IF( I.LT.N ) A( I, I ) = 1.0\n+         A( I, I ) = 1.0\n+      END DO\n+      RETURN\n+      END"}, {"sha": "d0c05ec2e75fd4af67b55dac3d3fad06719e6862", "filename": "gcc/testsuite/gfortran.dg/g77/20000601-1.f", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,29 @@\n+c { dg-do compile }\n+      SUBROUTINE SGBTRF( M, KL, KU, AB, LDAB )\n+\n+*  PR fortran/275\n+*  ICE in `change_address', at emit-rtl.c:1589 with -O1 and above\n+*  g77 version 2.96 20000530 (experimental) on mips-sgi-irix6.5/-mabi=64\n+*\n+*  Originally derived from LAPACK 3.0 test suite failure.\n+*\n+*  David Billinghurst, (David.Billinghurst@riotinto.com.au)\n+*  1 June 2000\n+\n+      INTEGER   KL, KU, LDAB, M\n+      REAL      AB( LDAB, * )\n+\n+      INTEGER   J, JB, JJ, JP, KV, KM\n+      REAL      WORK13(65,64), WORK31(65,64)\n+      KV = KU + KL\n+      DO J = 1, M\n+         JB = MIN( 1, M-J+1 )\n+         DO JJ = J, J + JB - 1\n+            KM = MIN( KL, M-JJ )\n+            JP = KM+1\n+            CALL SSWAP( JB, AB( KV+1+JJ-J, J ), LDAB-1,\n+     $           AB( KV+JP+JJ-J, J ), LDAB-1 )\n+         END DO\n+      END DO\n+      RETURN\n+      END"}, {"sha": "e5b9db70d2aa8db6894bae93ca05b917ad8f4fe7", "filename": "gcc/testsuite/gfortran.dg/g77/20000601-2.f", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000601-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,28 @@\n+c { dg-do compile }\n+      SUBROUTINE SGBTRF( M, KL, KU, AB, LDAB )\n+\n+*  Slightly modified version of 20000601-1.f that still ICES with\n+*  CVS 20010118 g77 on mips-sgi-irix6.5/-mabi=64.\n+*\n+*  Originally derived from LAPACK 3.0 test suite failure.\n+*\n+*  David Billinghurst, (David.Billinghurst@riotinto.com.au)\n+*  18 January 2001\n+\n+      INTEGER   KL, KU, LDAB, M\n+      REAL      AB( LDAB, * )\n+\n+      INTEGER   J, JB, JJ, JP, KV, KM, F\n+      REAL      WORK13(65,64), WORK31(65,64)\n+      KV = KU + KL\n+      DO J = 1, M\n+         JB = MIN( 1, M-J+1 )\n+         DO JJ = J, J + JB - 1\n+            KM = MIN( KL, M-JJ )\n+            JP = F( KM+1, AB( KV+1, JJ ) )\n+            CALL SSWAP( JB, AB( KV+1+JJ-J, J ), LDAB-1,\n+     $           AB( KV+JP+JJ-J, J ), LDAB-1 )\n+         END DO\n+      END DO\n+      RETURN\n+      END"}, {"sha": "dc6414435ff03f21ec8d30a4fd3c98fd199c459a", "filename": "gcc/testsuite/gfortran.dg/g77/20000629-1.f", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000629-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000629-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000629-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,12 @@\n+c { dg-do compile }\n+      SUBROUTINE MIST(N, BETA)\n+      IMPLICIT REAL*8 (A-H,O-Z)\n+      INTEGER  IA, IQ, M1\n+      DIMENSION BETA(N)\n+      DO 80 IQ=1,M1\n+         IF (BETA(IQ).EQ.0.0D0) GO TO 120\n+   80 CONTINUE\n+  120 IF (IQ.NE.1) GO TO 160\n+  160 M1 = IA(IQ)\n+      RETURN\n+      END"}, {"sha": "b2776bf6bed096c493e7f410dee2eb8c94bdce4e", "filename": "gcc/testsuite/gfortran.dg/g77/20000630-2.f", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000630-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000630-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20000630-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,10 @@\n+c { dg-do compile }\n+      SUBROUTINE CHOUT(CHR,ICNT)\n+C ICE: failed assertion `expr != NULL'\n+C Reduced version of GNATS PR fortran/329 from trond.bo@dnmi.no\n+      INTEGER CHR(ICNT)\n+      CHARACTER*255 BUF\n+      BUF(1:1)=CHAR(CHR(1))\n+      CALL FPUTC(1,BUF(1:1))\n+      RETURN\n+      END"}, {"sha": "cce8dbce7c87080ccf3625c5b1c2be7b17dbf0e0", "filename": "gcc/testsuite/gfortran.dg/g77/20010115.f", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010115.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010115.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010115.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,10 @@\n+c { dg-do compile }\n+* GNATS PR Fortran/1636\n+      PRINT 42, 'HELLO'\n+   42 FORMAT(A)\n+      CALL WORLD\n+      END\n+      SUBROUTINE WORLD\n+      PRINT 42, 'WORLD'\n+   42 FORMAT(A)\n+      END"}, {"sha": "df003190cd2920f58811e7a77885a0650503d4ee", "filename": "gcc/testsuite/gfortran.dg/g77/20010321-1.f", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010321-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010321-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010321-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,9 @@\n+c { dg-do compile }\n+# 1 \"20010321-1.f\"\n+      SUBROUTINE TWOEXP\n+# 1 \"include/implicit.h\" 1 3\n+      IMPLICIT DOUBLE PRECISION (A-H)\n+# 3 \"20010321-1.f\" 2 3\n+      LOGICAL ANTI\n+      ANTI = .FALSE.\n+      END"}, {"sha": "e4a160c7b9910a5a6d9f49d930a2da20a120d5f2", "filename": "gcc/testsuite/gfortran.dg/g77/20010426.f", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010426.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010426.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20010426.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,7 @@\n+c { dg-do compile }\n+      function f(c)\n+      implicit none\n+      real*8 c, f\n+      f = sqrt(c)\n+      return\n+      end"}, {"sha": "e675f2c33fbd0d0b2cd99c7da5e2373fbe29431e", "filename": "gcc/testsuite/gfortran.dg/g77/20020307-1.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20020307-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20020307-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F20020307-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,22 @@\n+c { dg-do compile }\n+      SUBROUTINE SWEEP\n+      PARAMETER(MAXDIM=4,MAXVEC=4**3*8,MAXT=20)\n+      REAL*8 B,W1,W2,BNORM,BINV,WT,W0,C1,C2,R1,R2\n+      DIMENSION B(MAXVEC,0:3),W1(MAXVEC,0:3),W2(MAXVEC,0:3)\n+      DIMENSION BNORM(MAXVEC),BINV(MAXVEC),WT(MAXVEC),W0(MAXVEC)\n+      DIMENSION C1(MAXVEC),C2(MAXVEC),R1(MAXVEC),R2(MAXVEC)\n+      DO 200 ILAT=1,2**IDIM\n+      DO 200 I1=1,IDIM\n+      DO 220 I2=1,IDIM\n+      CALL INTACT(ILAT,I1,I1,W1)\n+220   CONTINUE\n+      DO 310 IATT=1,IDIM\n+      DO 311 I=1,100\n+      WT(I)=ONE + C1(I)*LOG(EPS+R1(I))\n+      IF( R2(I)**2 .LE. (ONE-WT(I)**2) )THEN\n+      W0(I)=WT(I)\n+      ENDIF\n+311   CONTINUE\n+310   CONTINUE\n+200   CONTINUE\n+      END"}, {"sha": "205f164b8e4694456606a2c6a986cd99cda40322", "filename": "gcc/testsuite/gfortran.dg/g77/8485.f", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F8485.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F8485.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F8485.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,9 @@\n+c { dg-do compile }\n+C      Extracted from PR fortran/8485\n+       PARAMETER (PPMULT = 1.0E5)\n+       INTEGER*8 NWRONG\n+       PARAMETER (NWRONG = 8)\n+       PARAMETER (DDMULT = PPMULT * NWRONG)\n+       PRINT 10, DDMULT\n+10     FORMAT (F10.3)\n+       END"}, {"sha": "f9a3ef2ce7a19363f382ec07025c47fd7ba39b8e", "filename": "gcc/testsuite/gfortran.dg/g77/960317-1.f", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F960317-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F960317-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F960317-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,104 @@\n+c { dg-do compile }\n+* Date: Sat, 16 Mar 1996 19:58:37 -0500 (EST)\n+* From: Kate Hedstrom <kate@ahab.Rutgers.EDU>\n+* To: burley@gnu.ai.mit.edu\n+* Subject: g77 bug in assign\n+* \n+* I found some files in the NCAR graphics source code which used to\n+* compile with g77 and now don't.  All contain the following combination\n+* of \"save\" and \"assign\".  It fails on a Sun running SunOS 4.1.3 and a\n+* Sun running SunOS 5.5 (slightly older g77), but compiles on an\n+* IBM/RS6000:\n+* \n+C\n+      SUBROUTINE QUICK\n+      SAVE\n+C\n+      ASSIGN 101 TO JUMP ! { dg-warning \"Obsolete: ASSIGN\" \"\" }\n+  101 Continue\n+C\n+      RETURN\n+      END\n+* \n+* Everything else in the NCAR distribution compiled, including quite a\n+* few C routines.\n+* \n+* Kate\n+* \n+* \n+* nemo% g77 -v -c quick.f\n+*  gcc -v -c -xf77 quick.f\n+* Reading specs from /usr/local/lib/gcc-lib/sparc-sun-sunos4.1.3/2.7.2/specs\n+* gcc version 2.7.2\n+*  /usr/local/lib/gcc-lib/sparc-sun-sunos4.1.3/2.7.2/f771 quick.f -fset-g77-defaults -quiet -dumpbase quick.f -version -fversion -o /usr/tmp/cca24166.s\n+* GNU F77 version 2.7.2 (sparc) compiled by GNU C version 2.7.1.\n+* GNU Fortran Front End version 0.5.18-960314 compiled: Mar 16 1996 14:28:11\n+* gcc: Internal compiler error: program f771 got fatal signal 11\n+* \n+* \n+* nemo% gdb /usr/local/lib/gcc-lib/*/*/f771 core\n+* GDB is free software and you are welcome to distribute copies of it\n+*  under certain conditions; type \"show copying\" to see the conditions.\n+* There is absolutely no warranty for GDB; type \"show warranty\" for details.\n+* GDB 4.14 (sparc-sun-sunos4.1.3), \n+* Copyright 1995 Free Software Foundation, Inc...\n+* Core was generated by `f771'.\n+* Program terminated with signal 11, Segmentation fault.\n+* Couldn't read input and local registers from core file\n+* find_solib: Can't read pathname for load map: I/O error\n+* \n+* Couldn't read input and local registers from core file\n+* #0  0x21aa4 in ffecom_sym_transform_assign_ (s=???) at f/com.c:7881\n+* 7881          if ((ffesymbol_save (s) || ffe_is_saveall ())\n+* (gdb) where\n+* #0  0x21aa4 in ffecom_sym_transform_assign_ (s=???) at f/com.c:7881\n+* Error accessing memory address 0xefffefcc: Invalid argument.\n+* (gdb) \n+* \n+* \n+* ahab% g77 -v -c quick.f\n+*  gcc -v -c -xf77 quick.f\n+* Reading specs from /usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/specs\n+* gcc version 2.7.2\n+*  /usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/f771 quick.f -quiet -dumpbase quick.f -version -fversion -o /var/tmp/cca003D2.s\n+* GNU F77 version 2.7.2 (sparc) compiled by GNU C version 2.7.2.\n+* GNU Fortran Front End version 0.5.18-960304 compiled: Mar  5 1996 16:12:46\n+* gcc: Internal compiler error: program f771 got fatal signal 11\n+* \n+* \n+* ahab% !gdb\n+* gdb /usr/local/lib/gcc-lib/*/*/f771 core\n+* GDB is free software and you are welcome to distribute copies of it\n+*  under certain conditions; type \"show copying\" to see the conditions.\n+* There is absolutely no warranty for GDB; type \"show warranty\" for details.\n+* GDB 4.15.1 (sparc-sun-solaris2.4), \n+* Copyright 1995 Free Software Foundation, Inc...\n+* Core was generated by\n+* `/usr/local/lib/gcc-lib/sparc-sun-solaris2.5/2.7.2/f771 quick.f -quiet -dumpbase'.\n+* Program terminated with signal 11, Segmentation fault.\n+* Reading symbols from /usr/lib/libc.so.1...done.\n+* Reading symbols from /usr/lib/libdl.so.1...done.\n+* #0  0x43e04 in ffecom_sym_transform_assign_ (s=0x3a22f8) at f/com.c:7963\n+* Source file is more recent than executable.\n+* 7963      assert (st != NULL);\n+* (gdb) where\n+* #0  0x43e04 in ffecom_sym_transform_assign_ (s=0x3a22f8) at f/com.c:7963\n+* #1  0x38044 in ffecom_expr_ (expr=0x3a23c0, dest_tree=0x0, dest=0x0, dest_used=0x0, assignp=true) at f/com.c:2100\n+* #2  0x489c8 in ffecom_expr_assign_w (expr=0x3a23c0) at f/com.c:10238\n+* #3  0xe9228 in ffeste_R838 (label=0x3a1ba8, target=0x3a23c0) at f/ste.c:2769\n+* #4  0xdae60 in ffestd_stmt_pass_ () at f/std.c:840\n+* #5  0xdc090 in ffestd_exec_end () at f/std.c:1405\n+* #6  0xcb534 in ffestc_shriek_subroutine_ (ok=true) at f/stc.c:4849\n+* #7  0xd8f00 in ffestc_R1225 (name=0x0) at f/stc.c:12307\n+* #8  0xcc808 in ffestc_end () at f/stc.c:5572\n+* #9  0x9fa84 in ffestb_end3_ (t=0x3a19c8) at f/stb.c:3216\n+* #10 0x9f30c in ffestb_end (t=0x3a19c8) at f/stb.c:2995\n+* #11 0x98414 in ffesta_save_ (t=0x3a19c8) at f/sta.c:453\n+* #12 0x997ec in ffesta_second_ (t=0x3a19c8) at f/sta.c:1178\n+* #13 0x8ed84 in ffelex_send_token_ () at f/lex.c:1614\n+* #14 0x8cab8 in ffelex_finish_statement_ () at f/lex.c:946\n+* #15 0x91684 in ffelex_file_fixed (wf=0x397780, f=0x37a560) at f/lex.c:2946\n+* #16 0x107a94 in ffe_file (wf=0x397780, f=0x37a560) at f/top.c:456\n+* #17 0x96218 in yyparse () at f/parse.c:77\n+* #18 0x10beac in compile_file (name=0xdffffaf7 \"quick.f\") at toplev.c:2239\n+* #19 0x110dc0 in main (argc=9, argv=0xdffff994, envp=0xdffff9bc) at toplev.c:3927"}, {"sha": "228248e2afa497a97fc3231377cc026755ec9eac", "filename": "gcc/testsuite/gfortran.dg/g77/970915-0.f", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F970915-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F970915-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F970915-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,21 @@\n+c { dg-do compile }\n+* fixed by patch to safe_from_p to avoid visiting any SAVE_EXPR\n+* node twice in a given top-level call to it.\n+* (JCB com.c patch of 1998-06-04.)\n+\n+      SUBROUTINE TSTSIG11\n+      IMPLICIT COMPLEX (A-Z)\n+      EXTERNAL gzi1,gzi2\n+      branch3 =  sw2 / cw\n+     .     * (  rdw * (epsh*gzi1(A,B)-gzi2(A,B))\n+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B)) )\n+     .     + (-1./2. + 2.*sw2/3.) / (sw*cw)\n+     .     * rdw * (epsh*gzi1(A,B)-gzi2(A,B)\n+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B))\n+     .     + rdw * (epsh*gzi1(A,B)-gzi2(A,B)) )\n+     .     * rup * (epsh*gzi1(A,B)-gzi2(A,B)\n+     .     + rup * (epsh*gzi1(A,B)-gzi2(A,B)) )\n+     .     * 4.*(3.-tw**2) * gzi2(A,B)\n+     .     + ((1.+2./tauw)*tw**2-(5.+2./tauw))* gzi1(A,B)\n+      RETURN\n+      END"}, {"sha": "30301333747b389afd0ec9a9579e3d3366de8ba9", "filename": "gcc/testsuite/gfortran.dg/g77/980310-1.f", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,29 @@\n+c { dg-do compile }\n+C Causes internal compiler error on egcs 1.0.1 on i586-pc-sco3.2v5.0.4\n+C To: egcs-bugs@cygnus.com\n+C Subject: backend case range problem/fix\n+C From: Dave Love <d.love@dl.ac.uk>\n+C Date: 02 Dec 1997 18:11:35 +0000\n+C Message-ID: <rzqpvnfboo8.fsf@djlvig.dl.ac.uk>\n+C \n+C The following Fortran test case aborts the compiler because\n+C tree_int_cst_lt dereferences a null tree; this is a regression from\n+C gcc 2.7.\n+\n+      INTEGER N\n+      READ(*,*) N\n+      SELECT CASE (N)\n+        CASE (1:)\n+           WRITE(*,*) 'case 1'\n+        CASE (0)\n+           WRITE(*,*) 'case 0'\n+      END SELECT\n+      END\n+\n+C The relevant change to cure this is:\n+C\n+C Thu Dec  4 06:34:40 1997  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+C\n+C       * stmt.c (pushcase_range): Clean up handling of \"infinite\" values.\n+C\n+"}, {"sha": "829706a9e623986eeac3d83e611f479783ecdd5c", "filename": "gcc/testsuite/gfortran.dg/g77/980310-2.f", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,44 @@\n+c { dg-do compile }\n+C unable to confirm this bug on egcs 1.0.1 for i586-pc-sco3.2v5.0.4 robertl\n+C\n+C Date: Sat, 23 Aug 1997 00:47:53 -0400 (EDT)\n+C From: David Bristow <dbristow@lynx.dac.neu.edu>\n+C To: egcs-bugs@cygnus.com\n+C Subject: g77 crashes compiling Dungeon\n+C Message-ID: <Pine.OSF.3.91.970823003521.11281A-100000@lynx.dac.neu.edu>\n+C\n+C The following small segment of Dungeon (the adventure that became the \n+C commercial hit Zork) causes an internal error in f771.  The platform is \n+C i586-pc-linux-gnulibc1, the compiler is egcs-ss-970821 (g77-GNU Fortran \n+C 0.5.21-19970811)\n+C \n+C --cut here--cut here--cut here--cut here--cut here--cut here--\n+C g77 --verbose -fugly -fvxt -c subr_.f\n+C g77 version 0.5.21-19970811\n+C  gcc --verbose -fugly -fvxt -xf77 subr_.f -xnone -lf2c -lm\n+C Reading specs from /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/specs\n+C gcc version egcs-2.90.01 970821 (gcc2-970802 experimental)\n+C  /usr/lib/gcc-lib/i586-pc-linux-gnulibc1/egcs-2.90.01/f771 subr_.f -fset-g77-defaults -quiet -dumpbase subr_.f -version -fversion -fugly -fvxt -o /tmp/cca23974.s\n+C f771: warning: -fugly is overloaded with meanings and likely to be removed;\n+C f771: warning: use only the specific -fugly-* options you need\n+C GNU F77 version egcs-2.90.01 970821 (gcc2-970802 experimental) (i586-pc-linux-gnulibc1) compiled by GNU C version egcs-2.90.01 970821 (gcc2-970802 experimental).\n+C GNU Fortran Front End version 0.5.21-19970811\n+C f/com.c:941: failed assertion `TYPE_PRECISION (type) <= TYPE_PRECISION (TREE_TYPE (e))'\n+C gcc: Internal compiler error: program f771 got fatal signal 6\n+C --cut here--cut here--cut here--cut here--cut here--cut here--\n+C \n+C Here's the FORTRAN code, it's basically a single subroutine from subr.f \n+C in the Dungeon source, slightly altered (the original calls RAN(), which \n+C doesn't exist in the g77 runtime)\n+C \n+C RND - Return a random integer mod n\n+C\n+\tINTEGER FUNCTION RND (N)\n+\tIMPLICIT INTEGER (A-Z)\n+\tREAL RAND\n+\tCOMMON /SEED/ RNSEED\n+\n+\tRND = RAND(RNSEED)*FLOAT(N)\n+\tRETURN\n+\n+\tEND"}, {"sha": "e7e9523558abad9310df303e475dd051325d1549", "filename": "gcc/testsuite/gfortran.dg/g77/980310-3.f", "status": "added", "additions": 260, "deletions": 0, "changes": 260, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-3.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-3.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-3.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,260 @@\n+c { dg-do compile }\n+c\n+c\tThis demonstrates a problem with g77 and pic on x86 where \n+c \tegcs 1.0.1 and earlier will generate bogus assembler output.\n+c\tunfortunately, gas accepts the bogus acssembler output and \n+c\tgenerates code that almost works.\n+c\n+\n+\n+C Date: Wed, 17 Dec 1997 23:20:29 +0000\n+C From: Joao Cardoso <jcardoso@inescn.pt>\n+C To: egcs-bugs@cygnus.com\n+C Subject: egcs-1.0 f77 bug on OSR5\n+C When trying to compile the Fortran file that I enclose bellow,\n+C I got an assembler error:\n+C \n+C ./g77 -B./ -fpic -O -c scaleg.f\n+C /usr/tmp/cca002D8.s:123:syntax error at (\n+C \n+C ./g77 -B./ -fpic -O0 -c scaleg.f \n+C /usr/tmp/cca002EW.s:246:invalid operand combination: leal\n+C \n+C Compiling without the -fpic flag runs OK.\n+\n+      subroutine scaleg (n,ma,a,mb,b,low,igh,cscale,cperm,wk)\n+c\n+c     *****parameters:\n+      integer igh,low,ma,mb,n\n+      double precision a(ma,n),b(mb,n),cperm(n),cscale(n),wk(n,6)\n+c\n+c     *****local variables:\n+      integer i,ir,it,j,jc,kount,nr,nrp2\n+      double precision alpha,basl,beta,cmax,coef,coef2,coef5,cor,\n+     *                 ew,ewc,fi,fj,gamma,pgamma,sum,t,ta,tb,tc\n+c\n+c     *****fortran functions:\n+      double precision dabs, dlog10, dsign\n+c     float\n+c\n+c     *****subroutines called:\n+c     none\n+c\n+c     ---------------------------------------------------------------\n+c\n+c     *****purpose:\n+c     scales the matrices a and b in the generalized eigenvalue\n+c     problem a*x = (lambda)*b*x such that the magnitudes of the\n+c     elements of the submatrices of a and b (as specified by low\n+c     and igh) are close to unity in the least squares sense.\n+c     ref.:  ward, r. c., balancing the generalized eigenvalue\n+c     problem, siam j. sci. stat. comput., vol. 2, no. 2, june 1981,\n+c     141-152.\n+c\n+c     *****parameter description:\n+c\n+c     on input:\n+c\n+c       ma,mb   integer\n+c               row dimensions of the arrays containing matrices\n+c               a and b respectively, as declared in the main calling\n+c               program dimension statement;\n+c\n+c       n       integer\n+c               order of the matrices a and b;\n+c\n+c       a       real(ma,n)\n+c               contains the a matrix of the generalized eigenproblem\n+c               defined above;\n+c\n+c       b       real(mb,n)\n+c               contains the b matrix of the generalized eigenproblem\n+c               defined above;\n+c\n+c       low     integer\n+c               specifies the beginning -1 for the rows and\n+c               columns of a and b to be scaled;\n+c\n+c       igh     integer\n+c               specifies the ending -1 for the rows and columns\n+c               of a and b to be scaled;\n+c\n+c       cperm   real(n)\n+c               work array.  only locations low through igh are\n+c               referenced and altered by this subroutine;\n+c\n+c       wk      real(n,6)\n+c               work array that must contain at least 6*n locations.\n+c               only locations low through igh, n+low through n+igh,\n+c               ..., 5*n+low through 5*n+igh are referenced and\n+c               altered by this subroutine.\n+c\n+c     on output:\n+c\n+c       a,b     contain the scaled a and b matrices;\n+c\n+c       cscale  real(n)\n+c               contains in its low through igh locations the integer\n+c               exponents of 2 used for the column scaling factors.\n+c               the other locations are not referenced;\n+c\n+c       wk      contains in its low through igh locations the integer\n+c               exponents of 2 used for the row scaling factors.\n+c\n+c     *****algorithm notes:\n+c     none.\n+c\n+c     *****history:\n+c     written by r. c. ward.......\n+c     modified 8/86 by bobby bodenheimer so that if\n+c       sum = 0 (corresponding to the case where the matrix\n+c       doesn't need to be scaled) the routine returns.\n+c\n+c     ---------------------------------------------------------------\n+c\n+      if (low .eq. igh) go to 410\n+      do 210 i = low,igh\n+         wk(i,1) = 0.0d0\n+         wk(i,2) = 0.0d0\n+         wk(i,3) = 0.0d0\n+         wk(i,4) = 0.0d0\n+         wk(i,5) = 0.0d0\n+         wk(i,6) = 0.0d0\n+         cscale(i) = 0.0d0\n+         cperm(i) = 0.0d0\n+  210 continue\n+c\n+c     compute right side vector in resulting linear equations\n+c\n+      basl = dlog10(2.0d0)\n+      do 240 i = low,igh\n+         do 240 j = low,igh\n+            tb = b(i,j)\n+            ta = a(i,j)\n+            if (ta .eq. 0.0d0) go to 220\n+            ta = dlog10(dabs(ta)) / basl\n+  220       continue\n+            if (tb .eq. 0.0d0) go to 230\n+            tb = dlog10(dabs(tb)) / basl\n+  230       continue\n+            wk(i,5) = wk(i,5) - ta - tb\n+            wk(j,6) = wk(j,6) - ta - tb\n+  240 continue\n+      nr = igh-low+1\n+      coef = 1.0d0/float(2*nr)\n+      coef2 = coef*coef\n+      coef5 = 0.5d0*coef2\n+      nrp2 = nr+2\n+      beta = 0.0d0\n+      it = 1\n+c\n+c     start generalized conjugate gradient iteration\n+c\n+  250 continue\n+      ew = 0.0d0\n+      ewc = 0.0d0\n+      gamma = 0.0d0\n+      do 260 i = low,igh\n+         gamma = gamma + wk(i,5)*wk(i,5) + wk(i,6)*wk(i,6)\n+         ew = ew + wk(i,5)\n+         ewc = ewc + wk(i,6)\n+  260 continue\n+      gamma = coef*gamma - coef2*(ew**2 + ewc**2)\n+     +        - coef5*(ew - ewc)**2\n+      if (it .ne. 1) beta = gamma / pgamma\n+      t = coef5*(ewc - 3.0d0*ew)\n+      tc = coef5*(ew - 3.0d0*ewc)\n+      do 270 i = low,igh\n+         wk(i,2) = beta*wk(i,2) + coef*wk(i,5) + t\n+         cperm(i) = beta*cperm(i) + coef*wk(i,6) + tc\n+  270 continue\n+c\n+c     apply matrix to vector\n+c\n+      do 300 i = low,igh\n+         kount = 0\n+         sum = 0.0d0\n+         do 290 j = low,igh\n+            if (a(i,j) .eq. 0.0d0) go to 280\n+            kount = kount+1\n+            sum = sum + cperm(j)\n+  280       continue\n+            if (b(i,j) .eq. 0.0d0) go to 290\n+            kount = kount+1\n+            sum = sum + cperm(j)\n+  290    continue\n+         wk(i,3) = float(kount)*wk(i,2) + sum\n+  300 continue\n+      do 330 j = low,igh\n+         kount = 0\n+         sum = 0.0d0\n+         do 320 i = low,igh\n+            if (a(i,j) .eq. 0.0d0) go to 310\n+            kount = kount+1\n+            sum = sum + wk(i,2)\n+  310       continue\n+            if (b(i,j) .eq. 0.0d0) go to 320\n+            kount = kount+1\n+            sum = sum + wk(i,2)\n+  320    continue\n+         wk(j,4) = float(kount)*cperm(j) + sum\n+  330 continue\n+      sum = 0.0d0\n+      do 340 i = low,igh\n+         sum = sum + wk(i,2)*wk(i,3) + cperm(i)*wk(i,4)\n+  340 continue\n+      if(sum.eq.0.0d0) return\n+      alpha = gamma / sum\n+c\n+c     determine correction to current iterate\n+c\n+      cmax = 0.0d0\n+      do 350 i = low,igh\n+         cor = alpha * wk(i,2)\n+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)\n+         wk(i,1) = wk(i,1) + cor\n+         cor = alpha * cperm(i)\n+         if (dabs(cor) .gt. cmax) cmax = dabs(cor)\n+         cscale(i) = cscale(i) + cor\n+  350 continue\n+      if (cmax .lt. 0.5d0) go to 370\n+      do 360 i = low,igh\n+         wk(i,5) = wk(i,5) - alpha*wk(i,3)\n+         wk(i,6) = wk(i,6) - alpha*wk(i,4)\n+  360 continue\n+      pgamma = gamma\n+      it = it+1\n+      if (it .le. nrp2) go to 250\n+c\n+c     end generalized conjugate gradient iteration\n+c\n+  370 continue\n+      do 380 i = low,igh\n+         ir = wk(i,1) + dsign(0.5d0,wk(i,1))\n+         wk(i,1) = ir\n+         jc = cscale(i) + dsign(0.5d0,cscale(i))\n+         cscale(i) = jc\n+  380 continue\n+c\n+c     scale a and b\n+c\n+      do 400 i = 1,igh\n+         ir = wk(i,1)\n+         fi = 2.0d0**ir\n+         if (i .lt. low) fi = 1.0d0\n+         do 400 j =low,n\n+            jc = cscale(j)\n+            fj = 2.0d0**jc\n+            if (j .le. igh) go to 390\n+            if (i .lt. low) go to 400\n+            fj = 1.0d0\n+  390       continue\n+            a(i,j) = a(i,j)*fi*fj\n+            b(i,j) = b(i,j)*fi*fj\n+  400 continue\n+  410 continue\n+      return\n+c\n+c     last line of scaleg\n+c\n+      end"}, {"sha": "ee50bc6b45904ff54c4aae651309f7984d2e0a96", "filename": "gcc/testsuite/gfortran.dg/g77/980310-4.f", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-4.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,348 @@\n+c { dg-do compile }\n+C To: egcs-bugs@cygnus.com\n+C Subject: -fPIC problem showing up with fortran on x86\n+C From: Dave Love <d.love@dl.ac.uk>\n+C Date: 19 Dec 1997 19:31:41 +0000\n+C \n+C \n+C This illustrates a long-standing problem noted at the end of the g77\n+C `Actual Bugs' info node and thought to be in the back end.  Although\n+C the report is against gcc 2.7 I can reproduce it (specifically on\n+C redhat 4.2) with the 971216 egcs snapshot.\n+C \n+C g77 version 0.5.21\n+C  gcc -v -fnull-version -o /tmp/gfa00415 -xf77-cpp-input /tmp/gfa00415.f -xnone\n+C -lf2c -lm\n+C\n+\n+C ------------\n+      subroutine dqage(f,a,b,epsabs,epsrel,limit,result,abserr,\n+     *   neval,ier,alist,blist,rlist,elist,iord,last)\n+C     --------------------------------------------------\n+C\n+C     Modified Feb 1989 by Barry W. Brown to eliminate key\n+C     as argument (use key=1) and to eliminate all Fortran\n+C     output.\n+C\n+C     Purpose: to make this routine usable from within S.\n+C\n+C     --------------------------------------------------\n+c***begin prologue  dqage\n+c***date written   800101   (yymmdd)\n+c***revision date  830518   (yymmdd)\n+c***category no.  h2a1a1\n+c***keywords  automatic integrator, general-purpose,\n+c             integrand examinator, globally adaptive,\n+c             gauss-kronrod\n+c***author  piessens,robert,appl. math. & progr. div. - k.u.leuven\n+c           de doncker,elise,appl. math. & progr. div. - k.u.leuven\n+c***purpose  the routine calculates an approximation result to a given\n+c            definite integral   i = integral of f over (a,b),\n+c            hopefully satisfying following claim for accuracy\n+c            abs(i-reslt).le.max(epsabs,epsrel*abs(i)).\n+c***description\n+c\n+c        computation of a definite integral\n+c        standard fortran subroutine\n+c        double precision version\n+c\n+c        parameters\n+c         on entry\n+c            f      - double precision\n+c                     function subprogram defining the integrand\n+c                     function f(x). the actual name for f needs to be\n+c                     declared e x t e r n a l in the driver program.\n+c\n+c            a      - double precision\n+c                     lower limit of integration\n+c\n+c            b      - double precision\n+c                     upper limit of integration\n+c\n+c            epsabs - double precision\n+c                     absolute accuracy requested\n+c            epsrel - double precision\n+c                     relative accuracy requested\n+c                     if  epsabs.le.0\n+c                     and epsrel.lt.max(50*rel.mach.acc.,0.5d-28),\n+c                     the routine will end with ier = 6.\n+c\n+c            key    - integer\n+c                     key for choice of local integration rule\n+c                     a gauss-kronrod pair is used with\n+c                          7 - 15 points if key.lt.2,\n+c                         10 - 21 points if key = 2,\n+c                         15 - 31 points if key = 3,\n+c                         20 - 41 points if key = 4,\n+c                         25 - 51 points if key = 5,\n+c                         30 - 61 points if key.gt.5.\n+c\n+c            limit  - integer\n+c                     gives an upperbound on the number of subintervals\n+c                     in the partition of (a,b), limit.ge.1.\n+c\n+c         on return\n+c            result - double precision\n+c                     approximation to the integral\n+c\n+c            abserr - double precision\n+c                     estimate of the modulus of the absolute error,\n+c                     which should equal or exceed abs(i-result)\n+c\n+c            neval  - integer\n+c                     number of integrand evaluations\n+c\n+c            ier    - integer\n+c                     ier = 0 normal and reliable termination of the\n+c                             routine. it is assumed that the requested\n+c                             accuracy has been achieved.\n+c                     ier.gt.0 abnormal termination of the routine\n+c                             the estimates for result and error are\n+c                             less reliable. it is assumed that the\n+c                             requested accuracy has not been achieved.\n+c            error messages\n+c                     ier = 1 maximum number of subdivisions allowed\n+c                             has been achieved. one can allow more\n+c                             subdivisions by increasing the value\n+c                             of limit.\n+c                             however, if this yields no improvement it\n+c                             is rather advised to analyze the integrand\n+c                             in order to determine the integration\n+c                             difficulties. if the position of a local\n+c                             difficulty can be determined(e.g.\n+c                             singularity, discontinuity within the\n+c                             interval) one will probably gain from\n+c                             splitting up the interval at this point\n+c                             and calling the integrator on the\n+c                             subranges. if possible, an appropriate\n+c                             special-purpose integrator should be used\n+c                             which is designed for handling the type of\n+c                             difficulty involved.\n+c                         = 2 the occurrence of roundoff error is\n+c                             detected, which prevents the requested\n+c                             tolerance from being achieved.\n+c                         = 3 extremely bad integrand behavior occurs\n+c                             at some points of the integration\n+c                             interval.\n+c                         = 6 the input is invalid, because\n+c                             (epsabs.le.0 and\n+c                              epsrel.lt.max(50*rel.mach.acc.,0.5d-28),\n+c                             result, abserr, neval, last, rlist(1) ,\n+c                             elist(1) and iord(1) are set to zero.\n+c                             alist(1) and blist(1) are set to a and b\n+c                             respectively.\n+c\n+c            alist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the left\n+c                      end points of the subintervals in the partition\n+c                      of the given integration range (a,b)\n+c\n+c            blist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the right\n+c                      end points of the subintervals in the partition\n+c                      of the given integration range (a,b)\n+c\n+c            rlist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the\n+c                      integral approximations on the subintervals\n+c\n+c            elist   - double precision\n+c                      vector of dimension at least limit, the first\n+c                       last  elements of which are the moduli of the\n+c                      absolute error estimates on the subintervals\n+c\n+c            iord    - integer\n+c                      vector of dimension at least limit, the first k\n+c                      elements of which are pointers to the\n+c                      error estimates over the subintervals,\n+c                      such that elist(iord(1)), ...,\n+c                      elist(iord(k)) form a decreasing sequence,\n+c                      with k = last if last.le.(limit/2+2), and\n+c                      k = limit+1-last otherwise\n+c\n+c            last    - integer\n+c                      number of subintervals actually produced in the\n+c                      subdivision process\n+c\n+c***references  (none)\n+c***routines called  d1mach,dqk15,dqk21,dqk31,\n+c                    dqk41,dqk51,dqk61,dqpsrt\n+c***end prologue  dqage\n+c\n+      double precision a,abserr,alist,area,area1,area12,area2,a1,a2,b,\n+     *  blist,b1,b2,dabs,defabs,defab1,defab2,dmax1,d1mach,elist,epmach,\n+     *  epsabs,epsrel,errbnd,errmax,error1,error2,erro12,errsum,f,\n+     *  resabs,result,rlist,uflow\n+      integer ier,iord,iroff1,iroff2,k,last,limit,maxerr,neval,\n+     *  nrmax\n+c\n+      dimension alist(limit),blist(limit),elist(limit),iord(limit),\n+     *  rlist(limit)\n+c\n+      external f\n+c\n+c            list of major variables\n+c            -----------------------\n+c\n+c           alist     - list of left end points of all subintervals\n+c                       considered up to now\n+c           blist     - list of right end points of all subintervals\n+c                       considered up to now\n+c           rlist(i)  - approximation to the integral over\n+c                      (alist(i),blist(i))\n+c           elist(i)  - error estimate applying to rlist(i)\n+c           maxerr    - pointer to the interval with largest\n+c                       error estimate\n+c           errmax    - elist(maxerr)\n+c           area      - sum of the integrals over the subintervals\n+c           errsum    - sum of the errors over the subintervals\n+c           errbnd    - requested accuracy max(epsabs,epsrel*\n+c                       abs(result))\n+c           *****1    - variable for the left subinterval\n+c           *****2    - variable for the right subinterval\n+c           last      - index for subdivision\n+c\n+c\n+c           machine dependent constants\n+c           ---------------------------\n+c\n+c           epmach  is the largest relative spacing.\n+c           uflow  is the smallest positive magnitude.\n+c\n+c***first executable statement  dqage\n+      epmach = d1mach(4)\n+      uflow = d1mach(1)\n+c\n+c           test on validity of parameters\n+c           ------------------------------\n+c\n+      ier = 0\n+      neval = 0\n+      last = 0\n+      result = 0.0d+00\n+      abserr = 0.0d+00\n+      alist(1) = a\n+      blist(1) = b\n+      rlist(1) = 0.0d+00\n+      elist(1) = 0.0d+00\n+      iord(1) = 0\n+      if(epsabs.le.0.0d+00.and.\n+     *  epsrel.lt.dmax1(0.5d+02*epmach,0.5d-28)) ier = 6\n+      if(ier.eq.6) go to 999\n+c\n+c           first approximation to the integral\n+c           -----------------------------------\n+c\n+      neval = 0\n+      call dqk15(f,a,b,result,abserr,defabs,resabs)\n+      last = 1\n+      rlist(1) = result\n+      elist(1) = abserr\n+      iord(1) = 1\n+c\n+c           test on accuracy.\n+c\n+      errbnd = dmax1(epsabs,epsrel*dabs(result))\n+      if(abserr.le.0.5d+02*epmach*defabs.and.abserr.gt.errbnd) ier = 2\n+      if(limit.eq.1) ier = 1\n+      if(ier.ne.0.or.(abserr.le.errbnd.and.abserr.ne.resabs)\n+     *  .or.abserr.eq.0.0d+00) go to 60\n+c\n+c           initialization\n+c           --------------\n+c\n+c\n+      errmax = abserr\n+      maxerr = 1\n+      area = result\n+      errsum = abserr\n+      nrmax = 1\n+      iroff1 = 0\n+      iroff2 = 0\n+c\n+c           main do-loop\n+c           ------------\n+c\n+      do 30 last = 2,limit\n+c\n+c           bisect the subinterval with the largest error estimate.\n+c\n+        a1 = alist(maxerr)\n+        b1 = 0.5d+00*(alist(maxerr)+blist(maxerr))\n+        a2 = b1\n+        b2 = blist(maxerr)\n+        call dqk15(f,a1,b1,area1,error1,resabs,defab1)\n+        call dqk15(f,a2,b2,area2,error2,resabs,defab2)\n+c\n+c           improve previous approximations to integral\n+c           and error and test for accuracy.\n+c\n+        neval = neval+1\n+        area12 = area1+area2\n+        erro12 = error1+error2\n+        errsum = errsum+erro12-errmax\n+        area = area+area12-rlist(maxerr)\n+        if(defab1.eq.error1.or.defab2.eq.error2) go to 5\n+        if(dabs(rlist(maxerr)-area12).le.0.1d-04*dabs(area12)\n+     *  .and.erro12.ge.0.99d+00*errmax) iroff1 = iroff1+1\n+        if(last.gt.10.and.erro12.gt.errmax) iroff2 = iroff2+1\n+    5   rlist(maxerr) = area1\n+        rlist(last) = area2\n+        errbnd = dmax1(epsabs,epsrel*dabs(area))\n+        if(errsum.le.errbnd) go to 8\n+c\n+c           test for roundoff error and eventually set error flag.\n+c\n+        if(iroff1.ge.6.or.iroff2.ge.20) ier = 2\n+c\n+c           set error flag in the case that the number of subintervals\n+c           equals limit.\n+c\n+        if(last.eq.limit) ier = 1\n+c\n+c           set error flag in the case of bad integrand behavior\n+c           at a point of the integration range.\n+c\n+        if(dmax1(dabs(a1),dabs(b2)).le.(0.1d+01+0.1d+03*\n+     *  epmach)*(dabs(a2)+0.1d+04*uflow)) ier = 3\n+c\n+c           append the newly-created intervals to the list.\n+c\n+    8   if(error2.gt.error1) go to 10\n+        alist(last) = a2\n+        blist(maxerr) = b1\n+        blist(last) = b2\n+        elist(maxerr) = error1\n+        elist(last) = error2\n+        go to 20\n+   10   alist(maxerr) = a2\n+        alist(last) = a1\n+        blist(last) = b1\n+        rlist(maxerr) = area2\n+        rlist(last) = area1\n+        elist(maxerr) = error2\n+        elist(last) = error1\n+c\n+c           call subroutine dqpsrt to maintain the descending ordering\n+c           in the list of error estimates and select the subinterval\n+c           with the largest error estimate (to be bisected next).\n+c\n+   20   call dqpsrt(limit,last,maxerr,errmax,elist,iord,nrmax)\n+c ***jump out of do-loop\n+        if(ier.ne.0.or.errsum.le.errbnd) go to 40\n+   30 continue\n+c\n+c           compute final result.\n+c           ---------------------\n+c\n+   40 result = 0.0d+00\n+      do 50 k=1,last\n+        result = result+rlist(k)\n+   50 continue\n+      abserr = errsum\n+   60 neval = 30*neval+15\n+  999 return\n+      end"}, {"sha": "b4b2f1d1e760dd55a68807d51866e15ed55a7acb", "filename": "gcc/testsuite/gfortran.dg/g77/980310-6.f", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-6.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-6.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-6.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,22 @@\n+c { dg-do compile }\n+C From: Norbert Conrad <Norbert.Conrad@hrz.uni-giessen.de>\n+C Message-Id: <199711131008.LAA12272@marvin.hrz.uni-giessen.de>\n+C Subject: 971105  g77 bug\n+C To: egcs-bugs@cygnus.com\n+C Date: Thu, 13 Nov 1997 11:08:19 +0100 (CET)\n+\n+C I found a bug in g77 in snapshot 971105\n+\n+      subroutine ai (a)\n+      dimension a(-1:*)\n+      return\n+      end\n+C ai.f: In subroutine `ai':\n+C ai.f:1: \n+C          subroutine ai (a)\n+C                         ^\n+C Array `a' at (^) is too large to handle\n+C \n+C This happens whenever the lower index boundary is negative and the upper index\n+C boundary is '*'. \n+"}, {"sha": "3cbcbe9ca77edb295cb370ba0a7625e721463cd0", "filename": "gcc/testsuite/gfortran.dg/g77/980310-7.f", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-7.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-7.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-7.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,51 @@\n+c { dg-do compile }\n+C From: \"David C. Doherty\" <doherty@networkcs.com>\n+C Message-Id: <199711171846.MAA27947@uh.msc.edu>\n+C Subject: g77: auto arrays + goto = no go\n+C To: egcs-bugs@cygnus.com\n+C Date: Mon, 17 Nov 1997 12:46:27 -0600 (CST)\n+\n+C I sent the following to fortran@gnu.ai.mit.edu, and Dave Love\n+C replied that he was able to reproduce it on rs6000-aix; not on\n+C others. He suggested that I send it to egcs-bugs. \n+\n+C Hi - I've observed the following behavior regarding \n+C automatic arrays and gotos.  Seems similar to what I found\n+C in the docs about computed gotos (but not exactly the same).\n+C \n+C I suspect from the nature of the error msg that it's in the GBE.\n+C \n+C I'm using egcs-971105, under linux-ppc.\n+C \n+C I also observed the same in g77-0.5.19 (and gcc 2.7.2?).\n+C \n+C I'd appreciate any advice on this.  thanks for the great work.\n+C --\n+C >cat testg77.f\n+      subroutine testg77(n, a)\n+c\n+      implicit none\n+c\n+      integer n\n+      real a(n)\n+      real b(n)\n+      integer i\n+c\n+      do i = 1, 10\n+        if (i .gt. 4) goto 100\n+        write(0, '(i2)')i\n+      enddo\n+c\n+      goto 200\n+100   continue\n+200   continue\n+c\n+      return\n+      end\n+C >g77 -c testg77.f\n+C testg77.f: In subroutine `testg77':\n+C testg77.f:19: label `200' used before containing binding contour\n+C testg77.f:18: label `100' used before containing binding contour\n+C --\n+C If I comment out the b(n) line or replace it with, e.g., b(10),\n+C it compiles fine."}, {"sha": "bafb470d3406df731b05cd2bad925aaa7fba779d", "filename": "gcc/testsuite/gfortran.dg/g77/980310-8.f", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-8.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-8.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980310-8.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,40 @@\n+c { dg-do compile }\n+C To: egcs-bugs@cygnus.com\n+C Subject: egcs-g77 and array indexing\n+C Reply-To: etseidl@jutland.ca.sandia.gov\n+C Date: Wed, 26 Nov 1997 10:38:27 -0800\n+C From: Edward Seidl <etseidl@jutland.ca.sandia.gov>\n+C\t\n+C\tI have some horrible spaghetti code I'm trying compile with egcs-g77,\n+C\tbut it's puking on code like the example below.  I have no idea if it's\n+C\tlegal fortran or not, and I'm in no position to change it.  All I do know\n+C\tis it compiles with a number of other compilers, including f2c and\n+C\tg77-0.5.19.1/gcc-2.7.2.1.  When I try to compile with egcs-2.90.18 971122\n+C\tI get the following (on both i686-pc-linux-gnu and alphaev56-unknown-linux-gnu):\n+C\t\n+C\tfoo.f: In subroutine `foobar':\n+C\tfoo.f:11: \n+C\t         subroutine foobar(norb,nnorb)\n+C\t                           ^\n+C\tArray `norb' at (^) is too large to handle\n+\n+      program foo\n+      implicit integer(A-Z)\n+      dimension norb(6)\n+      nnorb=6\n+\n+      call foobar(norb,nnorb)\n+\n+      stop\n+      end\n+\n+      subroutine foobar(norb,nnorb)\n+      implicit integer(A-Z)\n+      dimension norb(-1:*)\n+\n+      do 10 i=-1,nnorb-2\n+        norb(i) = i+999\n+  10  continue\n+\n+      return\n+      end"}, {"sha": "defda413eb78068b2d19dbdf3b5c0c019d9c7797", "filename": "gcc/testsuite/gfortran.dg/g77/980419-2.f", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980419-2.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980419-2.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980419-2.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,49 @@\n+c { dg-do compile }\n+c     SEGVs in loop.c with -O2.\n+\n+      character*80 function nxtlin(lun,ierr,itok)\n+      character onechr*1,twochr*2,thrchr*3\n+      itok=0\n+      do while (.true.)\n+         read (lun,'(a)',iostat=ierr) nxtlin\n+         if (nxtlin(1:1).ne.'#') then\n+            ito=0\n+            do 10 it=1,79\n+               if (nxtlin(it:it).ne.' ' .and. nxtlin(it+1:it+1).eq.' ')\n+     $              then\n+                  itast=0\n+                  itstrt=0\n+                  do itt=ito+1,it\n+                     if (nxtlin(itt:itt).eq.'*') itast=itt\n+                  enddo\n+                  itstrt=ito+1\n+                  do while (nxtlin(itstrt:itstrt).eq.' ')\n+                     itstrt=itstrt+1\n+                  enddo\n+                  if (itast.gt.0) then\n+                     nchrs=itast-itstrt\n+                     if (nchrs.eq.1) then\n+                        onechr=nxtlin(itstrt:itstrt)\n+                        read (onechr,*) itokn\n+                     elseif (nchrs.eq.2) then\n+                        twochr=nxtlin(itstrt:itstrt+1)\n+                        read (twochr,*) itokn\n+                     elseif (nchrs.eq.3) then\n+                        thrchr=nxtlin(itstrt:itstrt+2)\n+                        read (thrchr,*) itokn\n+                     elseif (nchrs.eq.4) then\n+                        thrchr=nxtlin(itstrt:itstrt+3)\n+                        read (thrchr,*) itokn\n+                     endif\n+                     itok=itok+itokn\n+                  else\n+                     itok=itok+1\n+                  endif\n+                  ito=it+1\n+               endif\n+ 10         continue\n+            return\n+         endif\n+      enddo\n+      return\n+      end"}, {"sha": "dd6e7a858c5d5731ee309f7d1275ddc1f4899dec", "filename": "gcc/testsuite/gfortran.dg/g77/980424-0.f", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980424-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980424-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980424-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,7 @@\n+c { dg-do compile }\n+C     crashes in subst_stack_regs_pat on x86-linux, in the \"abort();\"\n+C     within the switch statement.\n+      SUBROUTINE C(A)\n+      COMPLEX A\n+      WRITE(*,*) A.NE.CMPLX(0.0D0)\n+      END"}, {"sha": "c5c3ade00a9cd8fc1e994caf26db0728fd223a87", "filename": "gcc/testsuite/gfortran.dg/g77/980427-0.f", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980427-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980427-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980427-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,9 @@\n+c { dg-do compile }\n+c ../../egcs/gcc/f/com.c:938: failed assertion `TREE_CODE (TREE_TYPE (e)) == REAL_TYPE'\n+c     Fixed by 28-04-1998 global.c (ffeglobal_ref_progunit_) change.\n+      external b\n+      call y(b)\n+      end\n+      subroutine x\n+      a = b()\n+      end"}, {"sha": "f0ca9da665c4f95c1d1e361e8211ddef8b6940db", "filename": "gcc/testsuite/gfortran.dg/g77/980729-0.f", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980729-0.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980729-0.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F980729-0.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,6 @@\n+c { dg-do compile }\n+c     Got ICE on Alpha only with -mieee (currently not tested).\n+c     Fixed by rth 1998-07-30 alpha.md change.\n+      subroutine a(b,c)\n+      b = max(b,c)\n+      end"}, {"sha": "705a5da40d15f4465ab106d30954b84ea3ae6b3d", "filename": "gcc/testsuite/gfortran.dg/g77/981117-1.f", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F981117-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F981117-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2F981117-1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,24 @@\n+c { dg-do compile }\n+* egcs-bugs:\n+* From: Martin Kahlert <martin.kahlert@mchp.siemens.de>\n+* Subject: ICE in g77 from egcs-19981109\n+* Message-Id: <199811101134.MAA29838@keksy.mchp.siemens.de>\n+\n+* As of 1998-11-17, fails -O2 -fomit-frame-pointer with \n+* egcs/gcc/testsuite/g77.f-torture/compile/981117-1.f:8: internal error--insn does not satisfy its constraints:\n+* (insn 31 83 32 (set (reg:SF 8 %st(0))\n+*         (mult:SF (reg:SF 8 %st(0))\n+*             (const_double:SF (mem/u:SF (symbol_ref/u:SI (\"*.LC1\")) 0) 0 0 1073643520))) 350 {strlensi-3} (nil)\n+*     (nil))\n+* ../../egcs/gcc/toplev.c:1390: Internal compiler error in function fatal_insn\n+\n+* Fixed sometime before 1998-11-21 -- don't know by which change.\n+\n+      SUBROUTINE SSPTRD\n+      PARAMETER (HALF = 0.5 )\n+      DO I = 1, N\n+         CALL SSPMV(TAUI)\n+         ALPHA = -HALF*TAUI\n+         CALL SAXPY(ALPHA)\n+      ENDDO\n+      END"}, {"sha": "fcdeb427dee1aa4573de147cfb662bad1f1acc35", "filename": "gcc/testsuite/gfortran.dg/g77/toon_1.f", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ftoon_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62e39334a08066c17ead2da37ccb9209b2cc8e14/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ftoon_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fg77%2Ftoon_1.f?ref=62e39334a08066c17ead2da37ccb9209b2cc8e14", "patch": "@@ -0,0 +1,4 @@\n+c { dg-do compile }\n+      SUBROUTINE AAP(NOOT)\n+      DIMENSION NOOT(*)\n+      END"}]}