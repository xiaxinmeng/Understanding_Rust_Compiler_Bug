{"sha": "3db5773f7083637c9adb2481d35389495309bc05", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RiNTc3M2Y3MDgzNjM3YzlhZGIyNDgxZDM1Mzg5NDk1MzA5YmMwNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-06-14T04:29:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-06-14T04:29:43Z"}, "message": "escape: Implement assign phase.\n\n    \n    Implementation of the assign/connect phase.\n    Statements containing expressions which alias local, parameter,\n    and global objects are analyzed and the alias relationship between\n    objects containing pointers are captured in a connection graph to\n    summarize the assignments within a function.\n    \n    Reviewed-on: https://go-review.googlesource.com/18302\n\nFrom-SVN: r237424", "tree": {"sha": "fe13269bac2b31707c096e57f7a2dd574c440285", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe13269bac2b31707c096e57f7a2dd574c440285"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3db5773f7083637c9adb2481d35389495309bc05", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db5773f7083637c9adb2481d35389495309bc05", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3db5773f7083637c9adb2481d35389495309bc05", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3db5773f7083637c9adb2481d35389495309bc05/comments", "author": null, "committer": null, "parents": [{"sha": "c8aa46d6b2deed1a3d9c89bead4f75577c946c90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8aa46d6b2deed1a3d9c89bead4f75577c946c90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8aa46d6b2deed1a3d9c89bead4f75577c946c90"}], "stats": {"total": 1688, "additions": 1566, "deletions": 122}, "files": [{"sha": "66ce65298ce044a4d99d98474e346248c86cc506", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -1,4 +1,4 @@\n-054ff1ece3dd5888a445efeaf3ae197b16d4186f\n+f768153eb2a7a72587c9c0997955cdbbc70322d0\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "cd0c459b032435bb34a080b04279ff73180b0c3a", "filename": "gcc/go/gofrontend/escape.cc", "status": "modified", "additions": 1328, "deletions": 4, "changes": 1332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fescape.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.cc?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -87,6 +87,55 @@ Node::set_encoding(int enc)\n     }\n }\n \n+bool\n+Node::is_big(Escape_context* context) const\n+{\n+  Type* t = this->type();\n+  if (t == NULL\n+      || t->is_call_multiple_result_type()\n+      || t->is_sink_type()\n+      || t->is_void_type()\n+      || t->is_abstract())\n+    return false;\n+\n+  int64_t size;\n+  bool ok = t->backend_type_size(context->gogo(), &size);\n+  bool big = ok && (size < 0 || size > 10 * 1024 * 1024);\n+\n+  if (this->expr() != NULL)\n+    {\n+      if (this->expr()->allocation_expression() != NULL)\n+\t{\n+\t  ok = t->deref()->backend_type_size(context->gogo(), &size);\n+\t  big = big || size <= 0 || size >= (1 << 16);\n+\t}\n+      else if (this->expr()->call_expression() != NULL)\n+\t{\n+\t  Call_expression* call = this->expr()->call_expression();\n+\t  Func_expression* fn = call->fn()->func_expression();\n+\t  if (fn != NULL\n+\t      && fn->is_runtime_function()\n+\t      && (fn->runtime_code() == Runtime::MAKESLICE1\n+\t\t  || fn->runtime_code() == Runtime::MAKESLICE2\n+\t\t  || fn->runtime_code() == Runtime::MAKESLICE1BIG\n+\t\t  || fn->runtime_code() == Runtime::MAKESLICE2BIG))\n+\t    {\n+\t      // Second argument is length.\n+\t      Expression_list::iterator p = call->args()->begin();\n+\t      ++p;\n+\n+\t      Numeric_constant nc;\n+\t      unsigned long v;\n+\t      if ((*p)->numeric_constant_value(&nc)\n+\t\t  && nc.to_unsigned_long(&v) == Numeric_constant::NC_UL_VALID)\n+\t\tbig = big || v >= (1 << 16);\n+\t    }\n+\t}\n+    }\n+\n+  return big;\n+}\n+\n bool\n Node::is_sink() const\n {\n@@ -161,6 +210,37 @@ Node::max_encoding(int e, int etype)\n // Return a modified encoding for an input parameter that flows into an\n // output parameter.\n \n+int\n+Node::note_inout_flows(int e, int index, Level level)\n+{\n+  // Flow+level is encoded in two bits.\n+  // 00 = not flow, xx = level+1 for 0 <= level <= maxEncodedLevel.\n+  // 16 bits for Esc allows 6x2bits or 4x3bits or 3x4bits if additional\n+  // information would be useful.\n+  if (level.value() <= 0 && level.suffix_value() > 0)\n+    return Node::max_encoding(e|ESCAPE_CONTENT_ESCAPES, Node::ESCAPE_NONE);\n+  if (level.value() < 0)\n+    return Node::ESCAPE_HEAP;\n+  if (level.value() >  ESCAPE_MAX_ENCODED_LEVEL)\n+    level = Level::From(ESCAPE_MAX_ENCODED_LEVEL);\n+\n+  int encoded = level.value() + 1;\n+  int shift = ESCAPE_BITS_PER_OUTPUT_IN_TAG * index + ESCAPE_RETURN_BITS;\n+  int old = (e >> shift) & ESCAPE_BITS_MASK_FOR_TAG;\n+  if (old == 0\n+      || (encoded != 0 && encoded < old))\n+    old = encoded;\n+\n+  int encoded_flow = old << shift;\n+  if (((encoded_flow >> shift) & ESCAPE_BITS_MASK_FOR_TAG) != old)\n+    {\n+      // Failed to encode.  Put this on the heap.\n+      return Node::ESCAPE_HEAP;\n+    }\n+\n+  return (e & ~(ESCAPE_BITS_MASK_FOR_TAG << shift)) | encoded_flow;\n+}\n+\n // Class Escape_context.\n \n Escape_context::Escape_context(Gogo* gogo, bool recursive)\n@@ -493,14 +573,1258 @@ Gogo::discover_analysis_sets()\n   this->traverse(&ead);\n }\n \n+// Traverse all label and goto statements and mark the underlying label\n+// as looping or not looping.\n+\n+class Escape_analysis_loop : public Traverse\n+{\n+ public:\n+  Escape_analysis_loop()\n+    : Traverse(traverse_statements)\n+  { }\n+\n+  int\n+  statement(Block*, size_t*, Statement*);\n+};\n+\n+int\n+Escape_analysis_loop::statement(Block*, size_t*, Statement* s)\n+{\n+  if (s->label_statement() != NULL)\n+    s->label_statement()->label()->set_nonlooping();\n+  else if (s->goto_statement() != NULL)\n+    {\n+      if (s->goto_statement()->label()->nonlooping())\n+        s->goto_statement()->label()->set_looping();\n+    }\n+  return TRAVERSE_CONTINUE;\n+}\n+\n+// Traversal class used to look at all interesting statements within a function\n+// in order to build a connectivity graph between all nodes within a context's\n+// scope.\n+\n+class Escape_analysis_assign : public Traverse\n+{\n+public:\n+  Escape_analysis_assign(Escape_context* context, Named_object* fn)\n+    : Traverse(traverse_statements\n+\t       | traverse_expressions),\n+      context_(context), fn_(fn)\n+  { }\n+\n+  // Model statements within a function as assignments and flows between nodes.\n+  int\n+  statement(Block*, size_t*, Statement*);\n+\n+  // Model expressions within a function as assignments and flows between nodes.\n+  int\n+  expression(Expression**);\n+\n+  // Model calls within a function as assignments and flows between arguments\n+  // and results.\n+  void\n+  call(Call_expression* call);\n+\n+  // Model the assignment of DST to SRC.\n+  void\n+  assign(Node* dst, Node* src);\n+\n+  // Model the assignment of DST to dereference of SRC.\n+  void\n+  assign_deref(Node* dst, Node* src);\n+\n+  // Model the input-to-output assignment flow of one of a function call's\n+  // arguments, where the flow is encoding in NOTE.\n+  int\n+  assign_from_note(std::string* note, const std::vector<Node*>& dsts,\n+\t\t   Node* src);\n+\n+  // Record the flow of SRC to DST in DST.\n+  void\n+  flows(Node* dst, Node* src);\n+\n+private:\n+  // The escape context for this set of functions.\n+  Escape_context* context_;\n+  // The current function being analyzed.\n+  Named_object* fn_;\n+};\n+\n+// Model statements within a function as assignments and flows between nodes.\n+\n+int\n+Escape_analysis_assign::statement(Block*, size_t*, Statement* s)\n+{\n+  // Adjust the loop depth as we enter/exit blocks related to for statements.\n+  bool is_for_statement = (s->is_block_statement()\n+                           && s->block_statement()->is_lowered_for_statement());\n+  if (is_for_statement)\n+    this->context_->increase_loop_depth();\n+\n+  s->traverse_contents(this);\n+\n+  if (is_for_statement)\n+    this->context_->decrease_loop_depth();\n+\n+  switch (s->classification())\n+    {\n+    case Statement::STATEMENT_VARIABLE_DECLARATION:\n+      {\n+\tNamed_object* var = s->variable_declaration_statement()->var();\n+\tNode* var_node = Node::make_node(var);\n+\tNode::Escape_state* state = var_node->state(this->context_, NULL);\n+\tstate->loop_depth = this->context_->loop_depth();\n+\n+\t// Set the loop depth for this declaration.\n+\tif (var->is_variable()\n+\t    && var->var_value()->init() != NULL)\n+\t  {\n+\t    Node* init_node = Node::make_node(var->var_value()->init());\n+\t    this->assign(var_node, init_node);\n+\t  }\n+      }\n+      break;\n+\n+    case Statement::STATEMENT_LABEL:\n+      {\n+\tif (s->label_statement()->label()->looping())\n+\t  this->context_->increase_loop_depth();\n+      }\n+      break;\n+\n+    case Statement::STATEMENT_SWITCH:\n+    case Statement::STATEMENT_TYPE_SWITCH:\n+      // Want to model the assignment of each case variable to the switched upon\n+      // variable.  This should be lowered into assignment statements; nothing\n+      // to here if that's the case.\n+      // TODO(cmang): Verify.\n+      break;\n+\n+    case Statement::STATEMENT_ASSIGNMENT:\n+      {\n+\tAssignment_statement* assn = s->assignment_statement();\n+\tNode* lhs = Node::make_node(assn->lhs());\n+\tNode* rhs = Node::make_node(assn->rhs());\n+\n+\t// TODO(cmang): Add special case for escape analysis no-op:\n+\t// func (b *Buffer) Foo() {\n+\t// \tn, m := ...\n+\t//\tb.buf = b.buf[n:m]\n+\t// }\n+\t// This is okay for now, it just means b escapes; it is conservative.\n+\tthis->assign(lhs, rhs);\n+      }\n+      break;\n+\n+    case Statement::STATEMENT_SEND:\n+      {\n+\tNode* sent_node = Node::make_node(s->send_statement()->val());\n+\tthis->assign(this->context_->sink(), sent_node);\n+      }\n+      break;\n+\n+    case Statement::STATEMENT_DEFER:\n+      if (this->context_->loop_depth() == 1)\n+\tbreak;\n+      // fallthrough\n+\n+    case Statement::STATEMENT_GO:\n+      {\n+\t// Defer f(x) or go f(x).\n+\t// Both f and x escape to the heap.\n+\tThunk_statement* thunk = s->thunk_statement();\n+\tif (thunk->call()->call_expression() == NULL)\n+\t  break;\n+\n+\tCall_expression* call = thunk->call()->call_expression();\n+\tNode* func_node = Node::make_node(call->fn());\n+\tthis->assign(this->context_->sink(), func_node);\n+\tif (call->args() != NULL)\n+\t  {\n+\t    for (Expression_list::const_iterator p = call->args()->begin();\n+\t\t p != call->args()->end();\n+\t\t ++p)\n+\t      {\n+\t\tNode* arg_node = Node::make_node(*p);\n+\t\tthis->assign(this->context_->sink(), arg_node);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+      // TODO(cmang): Associate returned values with dummy return nodes.\n+\n+    default:\n+      break;\n+    }\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n+// Model expressions within a function as assignments and flows between nodes.\n+\n+int\n+Escape_analysis_assign::expression(Expression** pexpr)\n+{\n+  // Big stuff escapes unconditionally.\n+  Node* n = Node::make_node(*pexpr);\n+  if ((n->encoding() & ESCAPE_MASK) != int(Node::ESCAPE_HEAP)\n+      && n->is_big(this->context_))\n+    {\n+      n->set_encoding(Node::ESCAPE_HEAP);\n+      (*pexpr)->address_taken(true);\n+      this->assign(this->context_->sink(), n);\n+    }\n+\n+  if ((*pexpr)->func_expression() == NULL)\n+    (*pexpr)->traverse_subexpressions(this);\n+\n+  switch ((*pexpr)->classification())\n+    {\n+    case Expression::EXPRESSION_CALL:\n+      {\n+\tCall_expression* call = (*pexpr)->call_expression();\n+\tthis->call(call);\n+\n+\tFunc_expression* fe = call->fn()->func_expression();\n+\tif (fe != NULL && fe->is_runtime_function())\n+\t  {\n+\t    switch (fe->runtime_code())\n+\t      {\n+\t      case Runtime::PANIC:\n+\t\t{\n+\t\t  // Argument could leak through recover.\n+\t\t  Node* panic_arg = Node::make_node(call->args()->front());\n+\t\t  this->assign(this->context_->sink(), panic_arg);\n+\t\t}\n+\t\tbreak;\n+\n+\t      case Runtime::APPEND:\n+\t\t{\n+\t\t  // Unlike gc/esc.go, a call to append has already had its\n+\t\t  // varargs lowered into a slice of arguments.\n+\t\t  // The content of the appended slice leaks.\n+\t\t  Node* appended = Node::make_node(call->args()->back());\n+\t\t  this->assign_deref(this->context_->sink(), appended);\n+\n+\t\t  // The content of the original slice leaks as well.\n+\t\t  Node* appendee = Node::make_node(call->args()->back());\n+\t\t  this->assign_deref(this->context_->sink(), appendee);\n+\t\t}\n+\t\tbreak;\n+\n+\t      case Runtime::COPY:\n+\t\t{\n+\t\t  // Lose track of the copied content.\n+\t\t  Node* copied = Node::make_node(call->args()->back());\n+\t\t  this->assign_deref(this->context_->sink(), copied);\n+\t\t}\n+\t\tbreak;\n+\n+\t      case Runtime::MAKECHAN:\n+\t      case Runtime::MAKECHANBIG:\n+\t      case Runtime::MAKEMAP:\n+\t      case Runtime::MAKEMAPBIG:\n+\t      case Runtime::MAKESLICE1:\n+\t      case Runtime::MAKESLICE2:\n+\t      case Runtime::MAKESLICE1BIG:\n+\t      case Runtime::MAKESLICE2BIG:\n+\t      case Runtime::BYTE_ARRAY_TO_STRING:\n+\t      case Runtime::INT_ARRAY_TO_STRING:\n+\t      case Runtime::STRING_TO_BYTE_ARRAY:\n+\t      case Runtime::STRING_TO_INT_ARRAY:\n+\t      case Runtime::STRING_PLUS:\n+\t      case Runtime::CONSTRUCT_MAP:\n+\t      case Runtime::INT_TO_STRING:\n+\t\t{\n+\t\t  Node* runtime_node = Node::make_node(fe);\n+\t\t  this->context_->track(runtime_node);\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_ALLOCATION:\n+      {\n+\t// Same as above; this is Runtime::NEW.\n+\tNode* alloc_node = Node::make_node(*pexpr);\n+\tthis->context_->track(alloc_node);\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_CONVERSION:\n+      {\n+\tType_conversion_expression* tce = (*pexpr)->conversion_expression();\n+\tNode* tce_node = Node::make_node(tce);\n+\tNode* converted = Node::make_node(tce->expr());\n+\tthis->context_->track(tce_node);\n+\n+\tthis->assign(tce_node, converted);\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n+    case Expression::EXPRESSION_SLICE_CONSTRUCTION:\n+      {\n+\tNode* array_node = Node::make_node(*pexpr);\n+\tif ((*pexpr)->slice_literal() != NULL)\n+\t  this->context_->track(array_node);\n+\n+\tExpression_list* vals = ((*pexpr)->slice_literal() != NULL\n+\t\t\t\t ? (*pexpr)->slice_literal()->vals()\n+\t\t\t\t : (*pexpr)->array_literal()->vals());\n+\n+\tif (vals != NULL)\n+\t  {\n+\t    // Connect the array to its values.\n+\t    for (Expression_list::const_iterator p = vals->begin();\n+\t\t p != vals->end();\n+\t\t ++p)\n+\t      if ((*p) != NULL)\n+\t\tthis->assign(array_node, Node::make_node(*p));\n+\t  }\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n+      {\n+\tNode* struct_node = Node::make_node(*pexpr);\n+\tExpression_list* vals = (*pexpr)->struct_literal()->vals();\n+\tif (vals != NULL)\n+\t  {\n+\t    // Connect the struct to its values.\n+\t    for (Expression_list::const_iterator p = vals->begin();\n+\t\t p != vals->end();\n+\t\t ++p)\n+\t      {\n+\t\tif ((*p) != NULL)\n+\t\t  this->assign(struct_node, Node::make_node(*p));\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_HEAP:\n+      {\n+\tNode* pointer_node = Node::make_node(*pexpr);\n+\tNode* lit_node = Node::make_node((*pexpr)->heap_expression()->expr());\n+\tthis->context_->track(pointer_node);\n+\n+\t// Connect pointer node to literal node; if the pointer node escapes, so\n+\t// does the literal node.\n+\tthis->assign(pointer_node, lit_node);\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_BOUND_METHOD:\n+      {\n+\tNode* bound_node = Node::make_node(*pexpr);\n+\tthis->context_->track(bound_node);\n+\n+\tExpression* obj = (*pexpr)->bound_method_expression()->first_argument();\n+\tNode* obj_node = Node::make_node(obj);\n+\n+\t// A bound method implies the receiver will be used outside of the\n+\t// lifetime of the method in some way.  We lose track of the receiver.\n+\tthis->assign(this->context_->sink(), obj_node);\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_MAP_CONSTRUCTION:\n+      {\n+\tMap_construction_expression* mce = (*pexpr)->map_literal();\n+\tNode* map_node = Node::make_node(mce);\n+\tthis->context_->track(map_node);\n+\n+\t// All keys and values escape to memory.\n+\tif (mce->vals() != NULL)\n+\t  {\n+\t    for (Expression_list::const_iterator p = mce->vals()->begin();\n+\t\t p != mce->vals()->end();\n+\t\t ++p)\n+\t      {\n+\t\tif ((*p) != NULL)\n+\t\t  this->assign(this->context_->sink(), Node::make_node(*p));\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_FUNC_REFERENCE:\n+      {\n+\tFunc_expression* fe = (*pexpr)->func_expression();\n+\tif (fe->closure() != NULL)\n+\t  {\n+\t    // Connect captured variables to the closure.\n+\t    Node* closure_node = Node::make_node(fe);\n+\t    this->context_->track(closure_node);\n+\n+\t    // A closure expression already exists as the heap expression:\n+\t    // &struct{f func_code, v []*Variable}{...}.\n+\t    // Link closure to the addresses of the variables enclosed.\n+\t    Heap_expression* he = fe->closure()->heap_expression();\n+\t    Struct_construction_expression* sce = he->expr()->struct_literal();\n+\n+\t    // First field is function code, other fields are variable\n+\t    // references.\n+\t    Expression_list::const_iterator p = sce->vals()->begin();\n+\t    ++p;\n+\t    for (; p != sce->vals()->end(); ++p)\n+\t      {\n+\t\tNode* enclosed_node = Node::make_node(*p);\n+\t\tNode::Escape_state* state =\n+\t\t  enclosed_node->state(this->context_, NULL);\n+\t\tstate->loop_depth = this->context_->loop_depth();\n+\t\tthis->assign(closure_node, enclosed_node);\n+\t      }\n+\t  }\n+      }\n+      break;\n+\n+    case Expression::EXPRESSION_UNARY:\n+      {\n+\tif ((*pexpr)->unary_expression()->op() != OPERATOR_AND)\n+\t  break;\n+\n+\tNode* addr_node = Node::make_node(*pexpr);\n+\tthis->context_->track(addr_node);\n+\n+\tExpression* operand = (*pexpr)->unary_expression()->operand();\n+\tNamed_object* var = NULL;\n+\tif (operand->var_expression() != NULL)\n+\t  var = operand->var_expression()->named_object();\n+\telse if (operand->enclosed_var_expression() != NULL)\n+\t  var = operand->enclosed_var_expression()->variable();\n+\telse if (operand->temporary_reference_expression() != NULL)\n+\t  {\n+\t    // Found in runtime/chanbarrier_test.go.  The address of a struct\n+\t    // reference is usually a heap expression, except when it is a part\n+\t    // of a case statement.  In that case, it is lowered into a\n+\t    // temporary reference and never linked to the heap expression that\n+\t    // initializes it.  In general, when taking the address of some\n+\t    // temporary, the analysis should really be looking at the initial\n+\t    // value of that temporary.\n+\t    Temporary_reference_expression* tre =\n+\t      operand->temporary_reference_expression();\n+\t    if (tre->statement() != NULL\n+\t\t&& tre->statement()->temporary_statement()->init() != NULL)\n+\t      {\n+\t\tExpression* init =\n+\t\t  tre->statement()->temporary_statement()->init();\n+\t\tNode* init_node = Node::make_node(init);\n+\t\tthis->assign(addr_node, init_node);\n+\t      }\n+\t  }\n+\n+\tif (var == NULL)\n+\t  break;\n+\n+\tif (var->is_variable()\n+\t    && !var->var_value()->is_parameter())\n+\t  {\n+\t    // For &x, use the loop depth of x if known.\n+\t    Node::Escape_state* addr_state =\n+\t      addr_node->state(this->context_, NULL);\n+\t    Node* operand_node = Node::make_node(operand);\n+\t    Node::Escape_state* operand_state =\n+\t      operand_node->state(this->context_, NULL);\n+\t    if (operand_state->loop_depth != 0)\n+\t      addr_state->loop_depth = operand_state->loop_depth;\n+\t  }\n+\telse if ((var->is_variable()\n+\t\t  && var->var_value()->is_parameter())\n+\t\t || var->is_result_variable())\n+\t  {\n+\t    Node::Escape_state* addr_state =\n+\t      addr_node->state(this->context_, NULL);\n+\t    addr_state->loop_depth = 1;\n+\t  }\n+      }\n+      break;\n+\n+    default:\n+      break;\n+    }\n+  return TRAVERSE_SKIP_COMPONENTS;\n+}\n+\n+// Model calls within a function as assignments and flows between arguments\n+// and results.\n+\n+void\n+Escape_analysis_assign::call(Call_expression* call)\n+{\n+  Func_expression* fn = call->fn()->func_expression();\n+  Function_type* fntype = call->get_function_type();\n+  bool indirect = false;\n+\n+  // Interface method calls or closure calls are indirect calls.\n+  if (fntype == NULL\n+      || (fntype->is_method()\n+\t  && fntype->receiver()->type()->interface_type() != NULL)\n+      || fn == NULL\n+      || (fn->named_object()->is_function()\n+\t  && fn->named_object()->func_value()->enclosing() != NULL))\n+    indirect = true;\n+\n+  Node* call_node = Node::make_node(call);\n+  std::vector<Node*> arg_nodes;\n+  if (call->fn()->interface_field_reference_expression() != NULL)\n+    {\n+      Interface_field_reference_expression* ifre =\n+\tcall->fn()->interface_field_reference_expression();\n+      Node* field_node = Node::make_node(ifre->expr());\n+      arg_nodes.push_back(field_node);\n+    }\n+\n+  if (call->args() != NULL)\n+    {\n+      for (Expression_list::const_iterator p = call->args()->begin();\n+\t   p != call->args()->end();\n+\t   ++p)\n+\targ_nodes.push_back(Node::make_node(*p));\n+    }\n+\n+  if (indirect)\n+    {\n+      // We don't know what happens to the parameters through indirect calls.\n+      // Be conservative and assume they all flow to theSink.\n+      for (std::vector<Node*>::iterator p = arg_nodes.begin();\n+           p != arg_nodes.end();\n+           ++p)\n+\t{\n+\t  this->assign(this->context_->sink(), *p);\n+\t}\n+\n+      this->context_->init_retvals(call_node, fntype);\n+      return;\n+    }\n+\n+  // If FN is an untagged function.\n+  if (fn != NULL\n+      && fn->named_object()->is_function()\n+      && !fntype->is_tagged())\n+    {\n+      Function* f = fn->named_object()->func_value();\n+      const Bindings* callee_bindings = f->block()->bindings();\n+\n+      const Typed_identifier_list* results = fntype->results();\n+      if (results != NULL)\n+\t{\n+\t  // Setup output list on this call node.\n+\t  Node::Escape_state* state = call_node->state(this->context_, NULL);\n+\t  for (Typed_identifier_list::const_iterator p1 = results->begin();\n+\t       p1 != results->end();\n+\t       ++p1)\n+\t    {\n+\t      if (p1->name().empty() || Gogo::is_sink_name(p1->name()))\n+\t\tcontinue;\n+\n+\t      Named_object* result_no =\n+\t\tcallee_bindings->lookup_local(p1->name());\n+\t      go_assert(result_no != NULL);\n+\t      Node* result_node = Node::make_node(result_no);\n+\t      state->retvals.push_back(result_node);\n+\t    }\n+\t}\n+\n+      std::vector<Node*>::iterator p = arg_nodes.begin();\n+      if (fntype->is_method()\n+\t  && fntype->receiver()->type()->has_pointer())\n+\t{\n+\t  std::string rcvr_name = fntype->receiver()->name();\n+\t  if (rcvr_name.empty() || Gogo::is_sink_name(rcvr_name))\n+\t    ;\n+\t  else\n+\t    {\n+\t      Named_object* rcvr_no =\n+\t\tcallee_bindings->lookup_local(fntype->receiver()->name());\n+\t      go_assert(rcvr_no != NULL);\n+\t      Node* rcvr_node = Node::make_node(rcvr_no);\n+\t      this->assign(rcvr_node, *p);\n+\t    }\n+\t  ++p;\n+\t}\n+\n+      const Typed_identifier_list* til = fntype->parameters();\n+      if (til != NULL)\n+\t{\n+\t  for (Typed_identifier_list::const_iterator p1 = til->begin();\n+\t       p1 != til->end();\n+\t       ++p1, ++p)\n+\t    {\n+\t      if (p1->name().empty() || Gogo::is_sink_name(p1->name()))\n+\t\tcontinue;\n+\n+\t      Named_object* param_no =\n+\t\tcallee_bindings->lookup_local(p1->name());\n+\t      go_assert(param_no != NULL);\n+\t      Expression* arg = (*p)->expr();\n+\t      if (arg->var_expression() != NULL\n+\t\t  && arg->var_expression()->named_object() == param_no)\n+\t\tcontinue;\n+\n+\t      Node* param_node = Node::make_node(param_no);\n+\t      this->assign(param_node, *p);\n+\t    }\n+\n+\t  for (; p != arg_nodes.end(); ++p)\n+\t    {\n+\t      this->assign(this->context_->sink(), *p);\n+\t    }\n+\t}\n+\n+      return;\n+    }\n+\n+  Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n+  this->context_->init_retvals(call_node, fntype);\n+\n+  // Receiver.\n+  std::vector<Node*>::iterator p = arg_nodes.begin();\n+  if (fntype->is_method()\n+      && fntype->receiver()->type()->has_pointer()\n+      && p != arg_nodes.end())\n+    {\n+      // First argument to call will be the receiver.\n+      std::string* note = fntype->receiver()->note();\n+      if (fntype->receiver()->type()->points_to() == NULL\n+\t  && (*p)->expr()->unary_expression() != NULL\n+\t  && (*p)->expr()->unary_expression()->op() == OPERATOR_AND)\n+\t{\n+\t  // This is a call to a value method that has been lowered into a call\n+\t  // to a pointer method.  Gccgo generates a pointer method for all\n+\t  // method calls and takes the address of the value passed as the\n+\t  // receiver then immediately dereferences it within the function.\n+\t  // In this case, the receiver does not escape.\n+\t}\n+      else\n+\t{\n+\t  if (!Type::are_identical(fntype->receiver()->type(),\n+\t\t\t       (*p)->expr()->type(), true, NULL))\n+\t    {\n+\t      // This will be converted later, preemptively track it instead\n+\t      // of its conversion expression which will show up in a later pass.\n+\t      this->context_->track(*p);\n+\t    }\n+\t  this->assign_from_note(note, call_state->retvals, *p);\n+\t}\n+      p++;\n+    }\n+\n+  const Typed_identifier_list* til = fntype->parameters();\n+  if (til != NULL)\n+    {\n+      for (Typed_identifier_list::const_iterator pn = til->begin();\n+\t   pn != til->end() && p != arg_nodes.end();\n+\t   ++pn, ++p)\n+\t{\n+\t  if (!Type::are_identical(pn->type(), (*p)->expr()->type(),\n+\t\t\t\t   true, NULL))\n+\t    {\n+\t      // This will be converted later, preemptively track it instead\n+\t      // of its conversion expression which will show up in a later pass.\n+\t      this->context_->track(*p);\n+\t    }\n+\n+\t  // TODO(cmang): Special care for varargs parameter?\n+\t  Type* t = pn->type();\n+\t  if (t != NULL\n+\t      && t->has_pointer())\n+\t    {\n+\t      std::string* note = pn->note();\n+\t      int enc = this->assign_from_note(note, call_state->retvals, *p);\n+\t      if (enc == Node::ESCAPE_NONE\n+\t\t  && (call->is_deferred()\n+\t\t      || call->is_concurrent()))\n+\t\t{\n+\t\t  // TODO(cmang): Mark the argument as strictly non-escaping.\n+\t\t}\n+\t    }\n+\t}\n+\n+      for (; p != arg_nodes.end(); ++p)\n+\t{\n+\t  this->assign(this->context_->sink(), *p);\n+\t}\n+    }\n+}\n+\n+// Model the assignment of DST to SRC.\n+// Assert that SRC somehow gets assigned to DST.\n+// DST might need to be examined for evaluations that happen inside of it.\n+// For example, in [DST]*f(x) = [SRC]y, we lose track of the indirection and\n+// DST becomes the sink in our model.\n+\n+void\n+Escape_analysis_assign::assign(Node* dst, Node* src)\n+{\n+  if (dst->expr() != NULL)\n+    {\n+      // Analyze the lhs of the assignment.\n+      // Replace DST with this->context_->sink() if we can't track it.\n+      Expression* e = dst->expr();\n+      switch (e->classification())\n+        {\n+\tcase Expression::EXPRESSION_VAR_REFERENCE:\n+\t  {\n+\t    // If DST is a global variable, we have no way to track it.\n+\t    Named_object* var = e->var_expression()->named_object();\n+\t    if (var->is_variable() && var->var_value()->is_global())\n+\t      dst = this->context_->sink();\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_FIELD_REFERENCE:\n+\t  {\n+\t    Expression* strct = e->field_reference_expression()->expr();\n+\t    if (strct->heap_expression() != NULL)\n+\t      {\n+\t\t// When accessing the field of a struct reference, we lose\n+\t\t// track of the indirection.\n+\t\tdst = this->context_->sink();\n+\t\tbreak;\n+\t      }\n+\n+\t    // Treat DST.x = SRC as if it were DST = SRC.\n+\t    Node* struct_node = Node::make_node(strct);\n+\t    this->assign(struct_node, src);\n+\t    return;\n+\t  }\n+\n+\tcase Expression::EXPRESSION_ARRAY_INDEX:\n+\t  {\n+\t    Array_index_expression* are = e->array_index_expression();\n+\t    if (!are->array()->type()->is_slice_type())\n+\t      {\n+\t\t// Treat DST[i] = SRC as if it were DST = SRC if DST if a fixed\n+\t\t// array.\n+\t\tNode* array_node = Node::make_node(are->array());\n+\t\tthis->assign(array_node, src);\n+\t\treturn;\n+\t      }\n+\n+\t    // Lose track of the slice dereference.\n+\t    dst = this->context_->sink();\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_UNARY:\n+\t  // Lose track of the dereference.\n+\t  if (e->unary_expression()->op() == OPERATOR_MULT)\n+\t    dst = this->context_->sink();\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_MAP_INDEX:\n+\t  {\n+\t    // Lose track of the map's key and value.\n+\t    Expression* index = e->map_index_expression()->index();\n+\t    Node* index_node = Node::make_node(index);\n+\t    this->assign(this->context_->sink(), index_node);\n+\n+\t    dst = this->context_->sink();\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  // TODO(cmang): Add debugging info here: only a few expressions\n+\t  // should leave DST unmodified.\n+\t  break;\n+        }\n+    }\n+\n+  if (src->expr() != NULL)\n+    {\n+      Expression* e = src->expr();\n+      switch (e->classification())\n+        {\n+\tcase Expression::EXPRESSION_VAR_REFERENCE:\n+\t  // DST = var\n+\tcase Expression::EXPRESSION_HEAP:\n+\t  // DST = &T{...}.\n+\tcase Expression::EXPRESSION_FIXED_ARRAY_CONSTRUCTION:\n+\tcase Expression::EXPRESSION_SLICE_CONSTRUCTION:\n+\t  // DST = [...]T{...}.\n+\tcase Expression::EXPRESSION_MAP_CONSTRUCTION:\n+\t  // DST = map[T]V{...}.\n+\tcase Expression::EXPRESSION_STRUCT_CONSTRUCTION:\n+\t  // DST = T{...}.\n+\tcase Expression::EXPRESSION_ALLOCATION:\n+\t  // DST = new(T).\n+\tcase Expression::EXPRESSION_BOUND_METHOD:\n+\t  // DST = x.M.\n+\t  this->flows(dst, src);\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_UNSAFE_CONVERSION:\n+\t  {\n+\t    Expression* underlying = e->unsafe_conversion_expression()->expr();\n+\t    Node* underlying_node = Node::make_node(underlying);\n+\t    this->assign(dst, underlying_node);\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_ENCLOSED_VAR_REFERENCE:\n+\t  {\n+\t    Named_object* var = e->enclosed_var_expression()->variable();\n+\t    Node* var_node = Node::make_node(var);\n+\t    this->flows(dst, var_node);\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_CALL:\n+\t  {\n+\t    Call_expression* call = e->call_expression();\n+\t    Func_expression* fe = call->fn()->func_expression();\n+\t    if (fe != NULL && fe->is_runtime_function())\n+\t      {\n+\t\tswitch (fe->runtime_code())\n+\t\t  {\n+\t\t  case Runtime::APPEND:\n+\t\t    {\n+\t\t      // Append returns the first argument.\n+\t\t      // The subsequent arguments are already leaked because\n+\t\t      // they are operands to append.\n+\t\t      Node* appendee = Node::make_node(call->args()->front());\n+\t\t      this->assign(dst, appendee);\n+\t\t      break;\n+\t\t    }\n+\n+\t\t  case Runtime::MAKECHAN:\n+\t\t  case Runtime::MAKECHANBIG:\n+\t\t  case Runtime::MAKEMAP:\n+\t\t  case Runtime::MAKEMAPBIG:\n+\t\t  case Runtime::MAKESLICE1:\n+\t\t  case Runtime::MAKESLICE2:\n+\t\t  case Runtime::MAKESLICE1BIG:\n+\t\t  case Runtime::MAKESLICE2BIG:\n+\t\t    // DST = make(...).\n+\t\t  case Runtime::BYTE_ARRAY_TO_STRING:\n+\t\t    // DST = string([]byte{...}).\n+\t\t  case Runtime::INT_ARRAY_TO_STRING:\n+\t\t    // DST = string([]int{...}).\n+\t\t  case Runtime::STRING_TO_BYTE_ARRAY:\n+\t\t    // DST = []byte(str).\n+\t\t  case Runtime::STRING_TO_INT_ARRAY:\n+\t\t    // DST = []int(str).\n+\t\t  case Runtime::STRING_PLUS:\n+\t\t    // DST = str1 + str2\n+\t\t  case Runtime::CONSTRUCT_MAP:\n+\t\t    // When building a map literal's backend representation.\n+\t\t    // Likely never seen here and covered in\n+\t\t    // Expression::EXPRESSION_MAP_CONSTRUCTION.\n+\t\t  case Runtime::INT_TO_STRING:\n+\t\t    // DST = string(i).\n+\t\t  case Runtime::IFACEE2E2:\n+\t\t  case Runtime::IFACEI2E2:\n+\t\t  case Runtime::IFACEE2I2:\n+\t\t  case Runtime::IFACEI2I2:\n+\t\t  case Runtime::IFACEE2T2P:\n+\t\t  case Runtime::IFACEI2T2P:\n+\t\t  case Runtime::IFACEE2T2:\n+\t\t  case Runtime::IFACEI2T2:\n+\t\t  case Runtime::CONVERT_INTERFACE:\n+\t\t    // All versions of interface conversion that might result\n+\t\t    // from a type assertion.  Some of these are the result of\n+\t\t    // a tuple type assertion statement and may not be covered\n+\t\t    // by the case in Expression::EXPRESSION_CONVERSION or\n+\t\t    // Expression::EXPRESSION_TYPE_GUARD.\n+\t\t    this->flows(dst, src);\n+\t\t    break;\n+\n+\t\t  default:\n+\t\t    break;\n+\t\t  }\n+\t\tbreak;\n+\t      }\n+\t    else if (fe != NULL\n+\t\t     && fe->named_object()->is_function()\n+\t\t     && fe->named_object()->func_value()->is_method()\n+\t\t     && (call->is_deferred()\n+\t\t\t || call->is_concurrent()))\n+\t      {\n+\t\t// For a method call thunk, lose track of the call and treat it\n+\t\t// as if DST = RECEIVER.\n+\t\tNode* rcvr_node = Node::make_node(call->args()->front());\n+\t\tthis->assign(dst, rcvr_node);\n+\t\tbreak;\n+\t      }\n+\n+\t    // TODO(cmang): Handle case from issue 4529.\n+\t    // Node* call_node = Node::make_node(e);\n+\t    // Node::Escape_state* call_state = call_node->state(this->context_, NULL);\n+\t    // std::vector<Node*> retvals = call_state->retvals;\n+\t    // for (std::vector<Node*>::const_iterator p = retvals.begin();\n+\t    //\t    p != retvals.end();\n+\t    //\t    ++p)\n+\t    //\t this->flows(dst, *p);\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_FUNC_REFERENCE:\n+\t  if (e->func_expression()->closure() != NULL)\n+\t    {\n+\t      // If SRC is a reference to a function closure, DST flows into\n+\t      // the underyling closure variable.\n+\t      Expression* closure = e->func_expression()->closure();\n+\t      Node* closure_node = Node::make_node(closure);\n+\t      this->flows(dst, closure_node);\n+\t    }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_FIELD_REFERENCE:\n+\t  {\n+\t    // A non-pointer can't escape from a struct.\n+\t    if (!e->type()->has_pointer())\n+\t      break;\n+\t  }\n+\n+\tcase Expression::EXPRESSION_CONVERSION:\n+\tcase Expression::EXPRESSION_TYPE_GUARD:\n+\tcase Expression::EXPRESSION_ARRAY_INDEX:\n+\tcase Expression::EXPRESSION_STRING_INDEX:\n+\t  {\n+\t    Expression* left = NULL;\n+\t    if (e->field_reference_expression() != NULL)\n+\t      {\n+\t\tleft = e->field_reference_expression()->expr();\n+\t\tif (left->unary_expression() != NULL\n+\t\t    && left->unary_expression()->op() == OPERATOR_MULT)\n+\t\t  {\n+\t\t    // DST = (*x).f\n+\t\t    this->flows(dst, src);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    else if (e->conversion_expression() != NULL)\n+\t      left = e->conversion_expression()->expr();\n+\t    else if (e->type_guard_expression() != NULL)\n+\t      left = e->type_guard_expression()->expr();\n+\t    else if (e->array_index_expression() != NULL)\n+\t      {\n+\t\tArray_index_expression* aie = e->array_index_expression();\n+\t\tif (e->type()->is_slice_type())\n+\t\t  left = aie->array();\n+\t\telse if (!aie->array()->type()->is_slice_type())\n+\t\t  {\n+\t\t    // Indexing an array preserves the input value.\n+\t\t    Node* array_node = Node::make_node(aie->array());\n+\t\t    this->assign(dst, array_node);\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    this->flows(dst, src);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    else if (e->string_index_expression() != NULL)\n+\t      {\n+\t\tString_index_expression* sie = e->string_index_expression();\n+\t\tif (e->type()->is_slice_type())\n+\t\t  left = sie->string();\n+\t\telse if (!sie->string()->type()->is_slice_type())\n+\t\t  {\n+\t\t    // Indexing a string preserves the input value.\n+\t\t    Node* string_node = Node::make_node(sie->string());\n+\t\t    this->assign(dst, string_node);\n+\t\t    break;\n+\t\t  }\n+\t\telse\n+\t\t  {\n+\t\t    this->flows(dst, src);\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    go_assert(left != NULL);\n+\n+\t    // Conversions, field access, and slicing all preserve the input\n+\t    // value.\n+\t    Node* left_node = Node::make_node(left);\n+\t    this->assign(dst, left_node);\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_BINARY:\n+\t  {\n+\t    switch (e->binary_expression()->op())\n+\t      {\n+\t      case OPERATOR_PLUS:\n+\t      case OPERATOR_MINUS:\n+\t      case OPERATOR_XOR:\n+\t      case OPERATOR_MULT:\n+\t      case OPERATOR_DIV:\n+\t      case OPERATOR_MOD:\n+\t      case OPERATOR_LSHIFT:\n+\t      case OPERATOR_RSHIFT:\n+\t      case OPERATOR_AND:\n+\t      case OPERATOR_BITCLEAR:\n+\t\t{\n+\t\t  Node* left = Node::make_node(e->binary_expression()->left());\n+\t\t  this->assign(dst, left);\n+\t\t  Node* right = Node::make_node(e->binary_expression()->right());\n+\t\t  this->assign(dst, right);\n+\t\t}\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_UNARY:\n+\t  {\n+\t    switch (e->unary_expression()->op())\n+\t      {\n+\t      case OPERATOR_PLUS:\n+\t      case OPERATOR_MINUS:\n+\t      case OPERATOR_XOR:\n+\t\t{\n+\t\t    Node* op_node =\n+\t\t      Node::make_node(e->unary_expression()->operand());\n+\t\t    this->assign(dst, op_node);\n+\t\t}\n+\t\tbreak;\n+\n+\t      case OPERATOR_MULT:\n+\t\t// DST = *x\n+\t      case OPERATOR_AND:\n+\t\t// DST = &x\n+\t\tthis->flows(dst, src);\n+\t\tbreak;\n+\n+\t      default:\n+\t\tbreak;\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tcase Expression::EXPRESSION_TEMPORARY_REFERENCE:\n+\t  {\n+\t    Statement* temp = e->temporary_reference_expression()->statement();\n+\t    if (temp != NULL\n+\t\t&& temp->temporary_statement()->init() != NULL)\n+\t      {\n+\t\tExpression* init = temp->temporary_statement()->init();\n+\t\tNode* init_node = Node::make_node(init);\n+\t\tthis->assign(dst, init_node);\n+\t      }\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  // TODO(cmang): Add debug info here; this should not be reachable.\n+\t  // For now, just to be conservative, we'll just say dst flows to src.\n+\t  break;\n+\t}\n+    }\n+}\n+\n+// Model the assignment of DST to an indirection of SRC.\n+\n+void\n+Escape_analysis_assign::assign_deref(Node* dst, Node* src)\n+{\n+  if (src->expr() != NULL)\n+    {\n+      switch (src->expr()->classification())\n+        {\n+\tcase Expression::EXPRESSION_BOOLEAN:\n+\tcase Expression::EXPRESSION_STRING:\n+\tcase Expression::EXPRESSION_INTEGER:\n+\tcase Expression::EXPRESSION_FLOAT:\n+\tcase Expression::EXPRESSION_COMPLEX:\n+\tcase Expression::EXPRESSION_NIL:\n+\tcase Expression::EXPRESSION_IOTA:\n+\t  // No need to try indirections on literal values\n+\t  // or numeric constants.\n+\t  return;\n+\n+\tdefault:\n+\t  break;\n+        }\n+    }\n+\n+  this->assign(dst, this->context_->add_dereference(src));\n+}\n+\n+// Model the input-to-output assignment flow of one of a function call's\n+// arguments, where the flow is encoded in NOTE.\n+\n+int\n+Escape_analysis_assign::assign_from_note(std::string* note,\n+\t\t\t\t\t const std::vector<Node*>& dsts,\n+\t\t\t\t\t Node* src)\n+{\n+  int enc = Escape_note::parse_tag(note);\n+  if (src->expr() != NULL)\n+    {\n+      switch (src->expr()->classification())\n+        {\n+\tcase Expression::EXPRESSION_BOOLEAN:\n+\tcase Expression::EXPRESSION_STRING:\n+\tcase Expression::EXPRESSION_INTEGER:\n+\tcase Expression::EXPRESSION_FLOAT:\n+\tcase Expression::EXPRESSION_COMPLEX:\n+\tcase Expression::EXPRESSION_NIL:\n+\tcase Expression::EXPRESSION_IOTA:\n+\t  // There probably isn't a note for a literal value.  Literal values\n+\t  // usually don't escape unless we lost track of the value some how.\n+\t  return enc;\n+\n+\tdefault:\n+\t  break;\n+        }\n+    }\n+\n+  if (enc == Node::ESCAPE_UNKNOWN)\n+    {\n+      // Lost track of the value.\n+      this->assign(this->context_->sink(), src);\n+      return enc;\n+    }\n+  else if (enc == Node::ESCAPE_NONE)\n+    return enc;\n+\n+  // If the content inside a parameter (reached via indirection) escapes to\n+  // the heap, mark it.\n+  if ((enc & ESCAPE_CONTENT_ESCAPES) != 0)\n+    this->assign(this->context_->sink(), this->context_->add_dereference(src));\n+\n+  int save_enc = enc;\n+  enc >>= ESCAPE_RETURN_BITS;\n+  for (std::vector<Node*>::const_iterator p = dsts.begin();\n+       enc != 0 && p != dsts.end();\n+       ++p)\n+    {\n+      // Prefer the lowest-level path to the reference (for escape purposes).\n+      // Two-bit encoding (for example. 1, 3, and 4 bits are other options)\n+      //  01 = 0-level\n+      //  10 = 1-level, (content escapes),\n+      //  11 = 2-level, (content of content escapes).\n+      int bits = enc & ESCAPE_BITS_MASK_FOR_TAG;\n+      if (bits > 0)\n+\t{\n+\t  Node* n = src;\n+\t  for (int i = 0; i < bits - 1; ++i)\n+\t    {\n+\t      // Encode level > 0 as indirections.\n+\t      n = this->context_->add_dereference(n);\n+\t    }\n+\t  this->assign(*p, n);\n+\t}\n+      enc >>= ESCAPE_BITS_PER_OUTPUT_IN_TAG;\n+    }\n+\n+  // If there are too many outputs to fit in the tag, that is handled on the\n+  // encoding end as ESCAPE_HEAP, so there is no need to check here.\n+  return save_enc;\n+}\n+\n+// Record the flow of SRC to DST in DST.\n+\n+void\n+Escape_analysis_assign::flows(Node* dst, Node* src)\n+{\n+  // Don't bother capturing the flow from scalars.\n+  if (src->expr() != NULL\n+      && !src->expr()->type()->has_pointer())\n+    return;\n+\n+  // Don't confuse a blank identifier with the sink.\n+  if (dst->is_sink() && dst != this->context_->sink())\n+    return;\n+\n+  Node::Escape_state* dst_state = dst->state(this->context_, NULL);\n+  Node::Escape_state* src_state = src->state(this->context_, NULL);\n+  if (dst == src\n+      || dst_state == src_state\n+      || dst_state->flows.find(src) != dst_state->flows.end()\n+      || src_state->flows.find(dst) != src_state->flows.end())\n+    return;\n+\n+  if (dst_state->flows.empty())\n+    this->context_->add_dst(dst);\n+\n+  dst_state->flows.insert(src);\n+}\n+\n // Build a connectivity graph between nodes in the function being analyzed.\n \n void\n-Gogo::assign_connectivity(Escape_context*, Named_object*)\n+Gogo::assign_connectivity(Escape_context* context, Named_object* fn)\n {\n-  // TODO(cmang): Model the flow analysis of input parameters and results for a\n-  // function.\n-  // TODO(cmang): Analyze the current function's body.\n+  // Must be defined outside of this package.\n+  if (!fn->is_function())\n+    return;\n+\n+  int save_depth = context->loop_depth();\n+  context->set_loop_depth(1);\n+\n+  Escape_analysis_assign ea(context, fn);\n+  Function::Results* res = fn->func_value()->result_variables();\n+  if (res != NULL)\n+    {\n+      for (Function::Results::const_iterator p = res->begin();\n+\t   p != res->end();\n+\t   ++p)\n+\t{\n+\t  Node* res_node = Node::make_node(*p);\n+\t  Node::Escape_state* res_state = res_node->state(context, fn);\n+\t  res_state->loop_depth = 0;\n+\n+\t  // If this set of functions is recursive, we lose track of the return values.\n+\t  // Just say that the result flows to the sink.\n+\t  if (context->recursive())\n+\t    ea.flows(context->sink(), res_node);\n+\t}\n+    }\n+\n+  const Bindings* callee_bindings = fn->func_value()->block()->bindings();\n+  Function_type* fntype = fn->func_value()->type();\n+  Typed_identifier_list* params = (fntype->parameters() != NULL\n+\t\t\t\t   ? fntype->parameters()->copy()\n+\t\t\t\t   : new Typed_identifier_list);\n+  if (fntype->receiver() != NULL)\n+    params->push_back(*fntype->receiver());\n+\n+  for (Typed_identifier_list::const_iterator p = params->begin();\n+       p != params->end();\n+       ++p)\n+    {\n+      if (p->name().empty() || Gogo::is_sink_name(p->name()))\n+\tcontinue;\n+\n+      Named_object* param_no = callee_bindings->lookup_local(p->name());\n+      go_assert(param_no != NULL);\n+      Node* param_node = Node::make_node(param_no);\n+      Node::Escape_state* param_state = param_node->state(context, fn);\n+      param_state->loop_depth = 1;\n+\n+      if (!p->type()->has_pointer())\n+        continue;\n+\n+      // External function?  Parameters must escape unless //go:noescape is set.\n+      // TODO(cmang): Implement //go:noescape directive.\n+      if (fn->package() != NULL)\n+\tparam_node->set_encoding(Node::ESCAPE_HEAP);\n+      else\n+\tparam_node->set_encoding(Node::ESCAPE_NONE);\n+\n+      // TODO(cmang): Track this node in no_escape list.\n+    }\n+\n+  Escape_analysis_loop el;\n+  fn->func_value()->traverse(&el);\n+\n+  fn->func_value()->traverse(&ea);\n+  context->set_loop_depth(save_depth);\n }\n \n // Propagate escape information across the nodes modeled in this Analysis_set."}, {"sha": "2278c47300776af8f061538ddce1fad936b5ea42", "filename": "gcc/go/gofrontend/escape.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fescape.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fescape.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fescape.h?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -206,7 +206,9 @@ class Node\n   void\n   set_encoding(int enc);\n \n-  // Is this node a sink?\n+  bool\n+  is_big(Escape_context*) const;\n+\n   bool\n   is_sink() const;\n \n@@ -250,6 +252,11 @@ class Node\n   static int\n   max_encoding(int e, int etype);\n \n+  // Return a modified encoding for an input parameter that flows into an\n+  // output parameter.\n+  static int\n+  note_inout_flows(int e, int index, Level level);\n+\n  private:\n   // The classification of this Node.\n   Node_classification classification_;"}, {"sha": "765792b06c56818538ff93a5597a2f27d2e84808", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -2578,7 +2578,7 @@ class Label\n  public:\n   Label(const std::string& name)\n     : name_(name), location_(Linemap::unknown_location()), snapshot_(NULL),\n-      refs_(), is_used_(false), blabel_(NULL)\n+      refs_(), is_used_(false), blabel_(NULL), depth_(DEPTH_UNKNOWN)\n   { }\n \n   // Return the label's name.\n@@ -2601,6 +2601,26 @@ class Label\n   set_is_used()\n   { this->is_used_ = true; }\n \n+  // Return whether this label is looping.\n+  bool\n+  looping() const\n+  { return this->depth_ == DEPTH_LOOPING; }\n+\n+  // Set this label as looping.\n+  void\n+  set_looping()\n+  { this->depth_ = DEPTH_LOOPING; }\n+\n+  // Return whether this label is nonlooping.\n+  bool\n+  nonlooping() const\n+  { return this->depth_ == DEPTH_NONLOOPING; }\n+\n+  // Set this label as nonlooping.\n+  void\n+  set_nonlooping()\n+  { this->depth_ = DEPTH_NONLOOPING; }\n+\n   // Return the location of the definition.\n   Location\n   location() const\n@@ -2660,6 +2680,16 @@ class Label\n   is_dummy_label() const\n   { return this->name_ == \"_\"; }\n \n+  // A classification of a label's looping depth.\n+  enum Loop_depth\n+  {\n+    DEPTH_UNKNOWN,\n+    // A label never jumped to.\n+    DEPTH_NONLOOPING,\n+    // A label jumped to.\n+    DEPTH_LOOPING\n+  };\n+\n  private:\n   // The name of the label.\n   std::string name_;\n@@ -2675,6 +2705,8 @@ class Label\n   bool is_used_;\n   // The backend representation.\n   Blabel* blabel_;\n+  // The looping depth of this label, for escape analysis.\n+  Loop_depth depth_;\n };\n \n // An unnamed label.  These are used when lowering loops."}, {"sha": "0fd871f51ad8abe84ee72a10eeab4a00935978e2", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 35, "deletions": 110, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -1793,40 +1793,6 @@ Statement::make_statement(Expression* expr, bool is_ignored)\n   return new Expression_statement(expr, is_ignored);\n }\n \n-// A block statement--a list of statements which may include variable\n-// definitions.\n-\n-class Block_statement : public Statement\n-{\n- public:\n-  Block_statement(Block* block, Location location)\n-    : Statement(STATEMENT_BLOCK, location),\n-      block_(block)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse* traverse)\n-  { return this->block_->traverse(traverse); }\n-\n-  void\n-  do_determine_types()\n-  { this->block_->determine_types(); }\n-\n-  bool\n-  do_may_fall_through() const\n-  { return this->block_->may_fall_through(); }\n-\n-  Bstatement*\n-  do_get_backend(Translate_context* context);\n-\n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n-\n- private:\n-  Block* block_;\n-};\n-\n // Convert a block to the backend representation of a statement.\n \n Bstatement*\n@@ -2944,37 +2910,13 @@ Statement::make_continue_statement(Unnamed_label* label,\n   return new Bc_statement(false, label, location);\n }\n \n-// A goto statement.\n+// Class Goto_statement.\n \n-class Goto_statement : public Statement\n+int\n+Goto_statement::do_traverse(Traverse*)\n {\n- public:\n-  Goto_statement(Label* label, Location location)\n-    : Statement(STATEMENT_GOTO, location),\n-      label_(label)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*)\n-  { return TRAVERSE_CONTINUE; }\n-\n-  void\n-  do_check_types(Gogo*);\n-\n-  bool\n-  do_may_fall_through() const\n-  { return false; }\n-\n-  Bstatement*\n-  do_get_backend(Translate_context*);\n-\n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n-\n- private:\n-  Label* label_;\n-};\n+  return TRAVERSE_CONTINUE;\n+}\n \n // Check types for a label.  There aren't any types per se, but we use\n // this to give an error if the label was never defined.\n@@ -3016,35 +2958,21 @@ Statement::make_goto_statement(Label* label, Location location)\n   return new Goto_statement(label, location);\n }\n \n-// A goto statement to an unnamed label.\n+// Class Goto_unnamed_statement.\n \n-class Goto_unnamed_statement : public Statement\n+int\n+Goto_unnamed_statement::do_traverse(Traverse*)\n {\n- public:\n-  Goto_unnamed_statement(Unnamed_label* label, Location location)\n-    : Statement(STATEMENT_GOTO_UNNAMED, location),\n-      label_(label)\n-  { }\n-\n- protected:\n-  int\n-  do_traverse(Traverse*)\n-  { return TRAVERSE_CONTINUE; }\n-\n-  bool\n-  do_may_fall_through() const\n-  { return false; }\n-\n-  Bstatement*\n-  do_get_backend(Translate_context* context)\n-  { return this->label_->get_goto(context, this->location()); }\n+  return TRAVERSE_CONTINUE;\n+}\n \n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n+// Convert the goto unnamed statement to the backend representation.\n \n- private:\n-  Unnamed_label* label_;\n-};\n+Bstatement*\n+Goto_unnamed_statement::do_get_backend(Translate_context* context)\n+{\n+  return this->label_->get_goto(context, this->location());\n+}\n \n // Dump the AST representation for an unnamed goto statement\n \n@@ -3109,32 +3037,27 @@ Statement::make_label_statement(Label* label, Location location)\n   return new Label_statement(label, location);\n }\n \n-// An unnamed label statement.\n+// Class Unnamed_label_statement.\n \n-class Unnamed_label_statement : public Statement\n-{\n- public:\n-  Unnamed_label_statement(Unnamed_label* label)\n-    : Statement(STATEMENT_UNNAMED_LABEL, label->location()),\n-      label_(label)\n-  { }\n+Unnamed_label_statement::Unnamed_label_statement(Unnamed_label* label)\n+  : Statement(STATEMENT_UNNAMED_LABEL, label->location()),\n+    label_(label)\n+{ }\n \n- protected:\n-  int\n-  do_traverse(Traverse*)\n-  { return TRAVERSE_CONTINUE; }\n+int\n+Unnamed_label_statement::do_traverse(Traverse*)\n+{\n+  return TRAVERSE_CONTINUE;\n+}\n \n-  Bstatement*\n-  do_get_backend(Translate_context* context)\n-  { return this->label_->get_definition(context); }\n+// Get the backend definition for this unnamed label statement.\n \n-  void\n-  do_dump_statement(Ast_dump_context*) const;\n+Bstatement*\n+Unnamed_label_statement::do_get_backend(Translate_context* context)\n+{\n+  return this->label_->get_definition(context);\n+}\n \n- private:\n-  // The label.\n-  Unnamed_label* label_;\n-};\n \n // Dump the AST representation for an unnamed label definition statement.\n \n@@ -5209,7 +5132,9 @@ For_statement::do_lower(Gogo*, Named_object*, Block* enclosing,\n \n   b->set_end_location(end_loc);\n \n-  return Statement::make_block_statement(b, loc);\n+  Statement* bs = Statement::make_block_statement(b, loc);\n+  bs->block_statement()->set_is_lowered_for_statement();\n+  return bs;\n }\n \n // Return the break label, creating it if necessary."}, {"sha": "c949dda599f11c819a4808f2facbf2376a0d4554", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 160, "deletions": 1, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -19,9 +19,13 @@ class Assignment_statement;\n class Temporary_statement;\n class Variable_declaration_statement;\n class Expression_statement;\n+class Block_statement;\n class Return_statement;\n class Thunk_statement;\n+class Goto_statement;\n+class Goto_unnamed_statement;\n class Label_statement;\n+class Unnamed_label_statement;\n class If_statement;\n class For_statement;\n class For_range_statement;\n@@ -366,6 +370,12 @@ class Statement\n     return this->convert<Expression_statement, STATEMENT_EXPRESSION>();\n   }\n \n+  // If this is an block statement, return it.  Otherwise return\n+  // NULL.\n+  Block_statement*\n+  block_statement()\n+  { return this->convert<Block_statement, STATEMENT_BLOCK>(); }\n+\n   // If this is a return statement, return it.  Otherwise return NULL.\n   Return_statement*\n   return_statement()\n@@ -376,11 +386,26 @@ class Statement\n   Thunk_statement*\n   thunk_statement();\n \n+  // If this is a goto statement, return it.  Otherwise return NULL.\n+  Goto_statement*\n+  goto_statement()\n+  { return this->convert<Goto_statement, STATEMENT_GOTO>(); }\n+\n+  // If this is a goto_unnamed statement, return it.  Otherwise return NULL.\n+  Goto_unnamed_statement*\n+  goto_unnamed_statement()\n+  { return this->convert<Goto_unnamed_statement, STATEMENT_GOTO_UNNAMED>(); }\n+\n   // If this is a label statement, return it.  Otherwise return NULL.\n   Label_statement*\n   label_statement()\n   { return this->convert<Label_statement, STATEMENT_LABEL>(); }\n \n+  // If this is an unnamed_label statement, return it.  Otherwise return NULL.\n+  Unnamed_label_statement*\n+  unnamed_label_statement()\n+  { return this->convert<Unnamed_label_statement, STATEMENT_UNNAMED_LABEL>(); }\n+\n   // If this is an if statement, return it.  Otherwise return NULL.\n   If_statement*\n   if_statement()\n@@ -762,6 +787,50 @@ class Expression_statement : public Statement\n   bool is_ignored_;\n };\n \n+// A block statement--a list of statements which may include variable\n+// definitions.\n+\n+class Block_statement : public Statement\n+{\n+ public:\n+  Block_statement(Block* block, Location location)\n+    : Statement(STATEMENT_BLOCK, location),\n+      block_(block), is_lowered_for_statement_(false)\n+  { }\n+\n+  void\n+  set_is_lowered_for_statement()\n+  { this->is_lowered_for_statement_ = true; }\n+\n+  bool\n+  is_lowered_for_statement()\n+  { return this->is_lowered_for_statement_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse* traverse)\n+  { return this->block_->traverse(traverse); }\n+\n+  void\n+  do_determine_types()\n+  { this->block_->determine_types(); }\n+\n+  bool\n+  do_may_fall_through() const\n+  { return this->block_->may_fall_through(); }\n+\n+  Bstatement*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  Block* block_;\n+  // True if this block statement represents a lowered for statement.\n+  bool is_lowered_for_statement_;\n+};\n+\n // A send statement.\n \n class Send_statement : public Statement\n@@ -1162,6 +1231,74 @@ class Defer_statement : public Thunk_statement\n   do_dump_statement(Ast_dump_context*) const;\n };\n \n+// A goto statement.\n+\n+class Goto_statement : public Statement\n+{\n+ public:\n+  Goto_statement(Label* label, Location location)\n+    : Statement(STATEMENT_GOTO, location),\n+      label_(label)\n+  { }\n+\n+  // Return the label being jumped to.\n+  Label*\n+  label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  void\n+  do_check_types(Gogo*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  Bstatement*\n+  do_get_backend(Translate_context*);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  Label* label_;\n+};\n+\n+// A goto statement to an unnamed label.\n+\n+class Goto_unnamed_statement : public Statement\n+{\n+ public:\n+  Goto_unnamed_statement(Unnamed_label* label, Location location)\n+    : Statement(STATEMENT_GOTO_UNNAMED, location),\n+      label_(label)\n+  { }\n+\n+  Unnamed_label*\n+  unnamed_label() const\n+  { return this->label_; }\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  bool\n+  do_may_fall_through() const\n+  { return false; }\n+\n+  Bstatement*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  Unnamed_label* label_;\n+};\n+\n // A label statement.\n \n class Label_statement : public Statement\n@@ -1173,7 +1310,7 @@ class Label_statement : public Statement\n   { }\n \n   // Return the label itself.\n-  const Label*\n+  Label*\n   label() const\n   { return this->label_; }\n \n@@ -1192,6 +1329,28 @@ class Label_statement : public Statement\n   Label* label_;\n };\n \n+// An unnamed label statement.\n+\n+class Unnamed_label_statement : public Statement\n+{\n+ public:\n+  Unnamed_label_statement(Unnamed_label* label);\n+\n+ protected:\n+  int\n+  do_traverse(Traverse*);\n+\n+  Bstatement*\n+  do_get_backend(Translate_context* context);\n+\n+  void\n+  do_dump_statement(Ast_dump_context*) const;\n+\n+ private:\n+  // The label.\n+  Unnamed_label* label_;\n+};\n+\n // An if statement.\n \n class If_statement : public Statement"}, {"sha": "1b764c0d2512f7dd639855ebfaaf715cb2a9709e", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3db5773f7083637c9adb2481d35389495309bc05/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=3db5773f7083637c9adb2481d35389495309bc05", "patch": "@@ -4502,10 +4502,7 @@ class Call_multiple_result_type : public Type\n  protected:\n   bool\n   do_has_pointer() const\n-  {\n-    go_assert(saw_errors());\n-    return false;\n-  }\n+  { return false; }\n \n   bool\n   do_compare_is_identity(Gogo*)"}]}