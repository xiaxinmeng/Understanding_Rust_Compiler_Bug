{"sha": "a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YThlZmU0MGQzZmQwNTk0YWFlNDQyNTNkOWZmNmZmYzQ2NmQyZjIxMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:58:02Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-01-15T21:58:02Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r192", "tree": {"sha": "d6512fbd06ee1244603b7c69b713c38dbe35bd4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d6512fbd06ee1244603b7c69b713c38dbe35bd4c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/comments", "author": null, "committer": null, "parents": [{"sha": "c66e0741f8dfaa31c50aad9821d149023eb85cbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c66e0741f8dfaa31c50aad9821d149023eb85cbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c66e0741f8dfaa31c50aad9821d149023eb85cbf"}], "stats": {"total": 227, "additions": 152, "deletions": 75}, "files": [{"sha": "67bcb355fd38d62ac72c4a668092a4d5532be083", "filename": "gcc/machmode.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Machine mode definitions for GNU C-Compiler; included by rtl.h and tree.h.\n-   Copyright (C) 1990-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1991  Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "edf68ffed34c8821c2be4f214e146b131aa64c7f", "filename": "gcc/output.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,6 +1,6 @@\n /* Declarations for insn-output.c.  These functions are defined in recog.c,\n    final.c, and varasm.c.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "ca048d66a2eebdb86e6dd737f3d20302d5912821", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Print RTL for GNU C Compiler.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "c347bdf19241e7e689835e9daddfa03bc3e222af", "filename": "gcc/recog.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines used by or related to instruction recognition.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "76df1e486ef8b7866db72b53bcf772180c996522", "filename": "gcc/regclass.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Compute register class preferences for pseudo-registers.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -327,7 +327,7 @@ fix_register (name, fixed, call_used)\n      the register info.  */\n \n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n-    if (!strcmp (reg_names[i], name))\n+    if (reg_names[i][0] && ! strcmp (reg_names[i], name))\n       {\n \tfixed_regs[i] = fixed;\n \tcall_used_regs[i] = call_used;"}, {"sha": "b4f6fa3ac756c00fb1005d3bc49a84def7b92d2a", "filename": "gcc/reload1.c", "status": "modified", "additions": 131, "deletions": 53, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Reload pseudo regs into hard regs for insns that require hard regs.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1989, 1992 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -266,6 +266,7 @@ static struct elim_table\n   int can_eliminate_previous;\t/* Value of CAN_ELIMINATE in previous scan over\n \t\t\t\t   insns made by reload. */\n   int offset;\t\t\t/* Current offset between the two regs. */\n+  int max_offset;\t\t/* Maximum offset between the two regs. */\n   int previous_offset;\t\t/* Offset at end of previous insn. */\n   int ref_outside_mem;\t\t/* \"to\" has been referenced outside a MEM. */\n   rtx from_rtx;\t\t\t/* REG rtx for the register to be eliminated.\n@@ -493,7 +494,8 @@ reload (first, global, dumpfile)\n   int something_needs_reloads;\n   int something_needs_elimination;\n   int new_basic_block_needs;\n-  int caller_save_needs_spill;\n+  enum reg_class caller_save_spill_class = NO_REGS;\n+  int caller_save_group_size = 1;\n \n   /* The basic block number currently being processed for INSN.  */\n   int this_block;\n@@ -516,9 +518,9 @@ reload (first, global, dumpfile)\n   bzero (spill_stack_slot, sizeof spill_stack_slot);\n   bzero (spill_stack_slot_width, sizeof spill_stack_slot_width);\n \n-  /* If caller-saves are requested, initialize the required save areas.  */\n-  if (flag_caller_saves)\n-    init_save_areas ();\n+  /* Initialize the save area information for caller-save, in case some\n+     are needed.  */\n+  init_save_areas ();\n     \n   /* Compute which hard registers are now in use\n      as homes for pseudo registers.\n@@ -566,7 +568,12 @@ reload (first, global, dumpfile)\n       if (set != 0 && GET_CODE (SET_DEST (set)) == REG)\n \t{\n \t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n-\t  if (note)\n+\t  if (note\n+#ifdef LEGITIMATE_PIC_OPERAND_P\n+\t      && (! CONSTANT_P (XEXP (note, 0)) || ! flag_pic \n+\t\t  || LEGITIMATE_PIC_OPERAND_P (XEXP (note, 0)))\n+#endif\n+\t      )\n \t    {\n \t      rtx x = XEXP (note, 0);\n \t      i = REGNO (SET_DEST (set));\n@@ -792,7 +799,8 @@ reload (first, global, dumpfile)\n       for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n \t{\n \t  INITIAL_ELIMINATION_OFFSET (ep->from, ep->to, ep->initial_offset);\n-\t  ep->previous_offset = ep->offset = ep->initial_offset;\n+\t  ep->previous_offset = ep->offset\n+\t    = ep->max_offset = ep->initial_offset;\n \t}\n #else\n #ifdef INITIAL_FRAME_POINTER_OFFSET\n@@ -802,7 +810,7 @@ reload (first, global, dumpfile)\n \tabort ();\n       reg_eliminate[0].initial_offset = 0;\n #endif\n-      reg_eliminate[0].previous_offset\n+      reg_eliminate[0].previous_offset = reg_eliminate[0].max_offset\n \t= reg_eliminate[0].offset = reg_eliminate[0].initial_offset;\n #endif\n \n@@ -877,6 +885,15 @@ reload (first, global, dumpfile)\n       if (something_changed)\n \tcontinue;\n \n+      /* If caller-saves needs a group, initialize the group to include\n+\t the size and mode required for caller-saves.  */\n+\n+      if (caller_save_group_size > 1)\n+\t{\n+\t  group_mode[(int) caller_save_spill_class] = Pmode;\n+\t  group_size[(int) caller_save_spill_class] = caller_save_group_size;\n+\t}\n+\n       /* Compute the most additional registers needed by any instruction.\n \t Collect information separately for each class of regs.  */\n \n@@ -927,14 +944,6 @@ reload (first, global, dumpfile)\n \t      int insn_groups_for_operands[N_REG_CLASSES];\n \t      int insn_total_groups_for_operands = 0;\n \n-\t      for (i = 0; i < N_REG_CLASSES; i++)\n-\t\t{\n-\t\t  insn_needs[i] = 0, insn_groups[i] = 0;\n-\t\t  insn_needs_for_inputs[i] = 0, insn_groups_for_inputs[i] = 0;\n-\t\t  insn_needs_for_outputs[i] = 0, insn_groups_for_outputs[i] = 0;\n-\t\t  insn_needs_for_operands[i] = 0, insn_groups_for_operands[i] = 0;\n-\t\t}\n-\n #if 0  /* This wouldn't work nowadays, since optimize_bit_field\n \t  looks for non-strict memory addresses.  */\n \t      /* Optimization: a bit-field instruction whose field\n@@ -1014,11 +1023,25 @@ reload (first, global, dumpfile)\n \t\t  something_needs_elimination = 1;\n \t\t}\n \n-\t      if (n_reloads == 0)\n+\t      /* If this insn has no reloads, we need not do anything except\n+\t\t in the case of a CALL_INSN when we have caller-saves and \n+\t\t caller-save needs reloads.  */\n+\n+\t      if (n_reloads == 0\n+\t\t  && ! (GET_CODE (insn) == CALL_INSN\n+\t\t\t&& caller_save_spill_class != NO_REGS))\n \t\tcontinue;\n \n \t      something_needs_reloads = 1;\n \n+\t      for (i = 0; i < N_REG_CLASSES; i++)\n+\t\t{\n+\t\t  insn_needs[i] = 0, insn_groups[i] = 0;\n+\t\t  insn_needs_for_inputs[i] = 0, insn_groups_for_inputs[i] = 0;\n+\t\t  insn_needs_for_outputs[i] = 0, insn_groups_for_outputs[i] = 0;\n+\t\t  insn_needs_for_operands[i] = 0, insn_groups_for_operands[i] = 0;\n+\t\t}\n+\n \t      /* Count each reload once in every class\n \t\t containing the reload's own class.  */\n \n@@ -1145,18 +1168,59 @@ reload (first, global, dumpfile)\n \t\t  if (insn_groups_for_operands[i] > this_max)\n \t\t    this_max = insn_groups_for_operands[i];\n \t\t  insn_groups[i] += this_max;\n-\n-\t\t  if (global && (insn_needs[i] || insn_groups[i])\n-\t\t      && ! basic_block_needs[i][this_block])\n-\t\t    {\n-\t\t      new_basic_block_needs = 1;\n-\t\t      basic_block_needs[i][this_block] = 1;\n-\t\t    }\n \t\t}\n+\n \t      insn_total_groups += MAX (insn_total_groups_for_inputs,\n \t\t\t\t\tMAX (insn_total_groups_for_outputs,\n \t\t\t\t\t     insn_total_groups_for_operands));\n \n+\t      /* If this is a CALL_INSN and caller-saves will need\n+\t\t a spill register, act as if the spill register is\n+\t\t needed for this insn.   However, the spill register\n+\t\t can be used by any reload of this insn, so we only\n+\t\t need do something if no need for that class has\n+\t\t been recorded. \n+\n+\t\t The assumption that every CALL_INSN will trigger a\n+\t\t caller-save is highly conservative, however, the number\n+\t\t of cases where caller-saves will need a spill register but\n+\t\t a block containing a CALL_INSN won't need a spill register\n+\t\t of that class should be quite rare.\n+\n+\t\t If a group is needed, the size and mode of the group will\n+\t\t have been set up at the begining of this loop.  */\n+\n+\t      if (GET_CODE (insn) == CALL_INSN\n+\t\t  && caller_save_spill_class != NO_REGS)\n+\t\t{\n+\t\t  int *caller_save_needs\n+\t\t    = (caller_save_group_size > 1 ? insn_groups : insn_needs);\n+\n+\t\t  if (caller_save_needs[(int) caller_save_spill_class] == 0)\n+\t\t    {\n+\t\t      register enum reg_class *p\n+\t\t\t= reg_class_superclasses[(int) caller_save_spill_class];\n+\n+\t\t      caller_save_needs[(int) caller_save_spill_class]++;\n+\n+\t\t      while (*p != LIM_REG_CLASSES)\n+\t\t\tcaller_save_needs[*p++] += 1;\n+\t\t    }\n+\n+\t\t  if (caller_save_group_size > 1)\n+\t\t    insn_total_groups = MAX (insn_total_groups, 1);\n+\t\t}\n+\n+\t      /* Update the basic block needs.  */\n+\n+\t      for (i = 0; i < N_REG_CLASSES; i++)\n+\t\tif (global && (insn_needs[i] || insn_groups[i])\n+\t\t    && ! basic_block_needs[i][this_block])\n+\t\t  {\n+\t\t    new_basic_block_needs = 1;\n+\t\t    basic_block_needs[i][this_block] = 1;\n+\t\t  }\n+\n #ifdef SMALL_REGISTER_CLASSES\n \t      /* If this insn stores the value of a function call,\n \t\t and that value is in a register that has been spilled,\n@@ -1205,20 +1269,21 @@ reload (first, global, dumpfile)\n \t}\n \n       /* If we have caller-saves, set up the save areas and see if caller-save\n-\t will need a spill register.  If it will and we don't already have a\n-\t need of class BASE_REG_CLASS, create such a need.  */\n+\t will need a spill register.  */\n \n       if (caller_save_needed\n-\t  && 0 != (caller_save_needs_spill\n-\t\t   = ! setup_save_areas (&something_changed))\n-\t  && max_needs[(int) BASE_REG_CLASS] == 0)\n+\t  && ! setup_save_areas (&something_changed)\n+\t  && caller_save_spill_class  == NO_REGS)\n \t{\n-\t  register enum reg_class *p\n-\t    = reg_class_superclasses[(int) BASE_REG_CLASS];\n-\n-\t  max_needs[(int) BASE_REG_CLASS] = 1;\n-\t  while (*p != LIM_REG_CLASSES)\n-\t    max_needs[(int) *p++] += 1;\n+\t  /* The class we will need depends on whether the machine\n+\t     supports the sum of two registers for an address; see\n+\t     find_address_reloads for details.  */\n+\n+\t  caller_save_spill_class \n+\t    = double_reg_address_ok ? INDEX_REG_CLASS : BASE_REG_CLASS;\n+\t  caller_save_group_size\n+\t    = CLASS_MAX_NREGS (caller_save_spill_class, Pmode);\n+\t  something_changed = 1;\n \t}\n \n       /* Now deduct from the needs for the registers already\n@@ -1569,22 +1634,13 @@ reload (first, global, dumpfile)\n   reload_in_progress = 1;\n \n   /* Insert code to save and restore call-clobbered hard regs\n-     around calls.  If caller-save needs a spill register, find one\n-     for it to use.  */\n+     around calls.  Tell if what mode to use so that we will process\n+     those insns in reload_as_needed if we have to.  */\n \n   if (caller_save_needed)\n-    {\n-      register int regno = -1;\n-\n-      if (caller_save_needs_spill)\n-\tfor (i = 0; i < n_spills; i++)\n-\t  if (TEST_HARD_REG_BIT (reg_class_contents[(int) BASE_REG_CLASS],\n-\t\t\t\tspill_regs[i])\n-\t      && HARD_REGNO_MODE_OK (spill_regs[i], Pmode))\n-\t    regno = spill_regs[i];\n-\n-      save_call_clobbered_regs (regno);\n-    }\n+    save_call_clobbered_regs (num_eliminable ? QImode\n+\t\t\t      : caller_save_spill_class != NO_REGS ? HImode\n+\t\t\t      : VOIDmode);\n \n   /* If a pseudo has no hard reg, delete the insns that made the equivalence.\n      If that insn didn't set the register (i.e., it copied the register to\n@@ -1611,7 +1667,9 @@ reload (first, global, dumpfile)\n      by generating move instructions to move the must-be-register\n      values into or out of the reload registers.  */\n \n-  if (something_needs_reloads || something_needs_elimination)\n+  if (something_needs_reloads || something_needs_elimination\n+      || (caller_save_needed && num_eliminable)\n+      || caller_save_spill_class != NO_REGS)\n     reload_as_needed (first, global);\n \n   reload_in_progress = 0;\n@@ -2765,6 +2823,9 @@ eliminate_regs_in_insn (insn, replace)\n   /* Loop through all elimination pairs.  See if any have changed and\n      recalculate the number not at initial offset.\n \n+     Compute the maximum offset (minimum offset if the stack does not\n+     grow downward) for each elimination pair.\n+\n      We also detect a cases where register elimination cannot be done,\n      namely, if a register would be both changed and referenced outside a MEM\n      in the resulting insn since such an insn is often undefined and, even if\n@@ -2788,6 +2849,12 @@ eliminate_regs_in_insn (insn, replace)\n       ep->previous_offset = ep->offset;\n       if (ep->can_eliminate && ep->offset != ep->initial_offset)\n \tnum_not_at_initial_offset++;\n+\n+#ifdef STACK_GROWS_DOWNWARD\n+      ep->max_offset = MAX (ep->max_offset, ep->offset);\n+#else\n+      ep->max_offset = MIN (ep->max_offset, ep->offset);\n+#endif\n     }\n \n  done:\n@@ -4362,13 +4429,24 @@ emit_reload_insns (insn)\n {\n   register int j;\n   rtx following_insn = NEXT_INSN (insn);\n+  rtx before_insn = insn;\n   rtx first_output_reload_insn = NEXT_INSN (insn);\n   rtx first_other_reload_insn = insn;\n   rtx first_operand_address_reload_insn = insn;\n   int special;\n   /* Values to be put in spill_reg_store are put here first.  */\n   rtx new_spill_reg_store[FIRST_PSEUDO_REGISTER];\n \n+  /* If this is a CALL_INSN preceeded by USE insns, any reload insns\n+     must go in front of the first USE insn, not in front of INSN.  */\n+\n+  if (GET_CODE (insn) == CALL_INSN && GET_CODE (PREV_INSN (insn)) == INSN\n+      && GET_CODE (PATTERN (PREV_INSN (insn))) == USE)\n+    while (GET_CODE (PREV_INSN (before_insn)) == INSN\n+\t   && GET_CODE (PATTERN (PREV_INSN (before_insn))) == USE)\n+      first_other_reload_insn = first_operand_address_reload_insn\n+\t= before_insn = PREV_INSN (before_insn);\n+\n   /* Now output the instructions to copy the data into and out of the\n      reload registers.  Do these in the order that the reloads were reported,\n      since reloads of base and index registers precede reloads of operands\n@@ -4520,7 +4598,7 @@ emit_reload_insns (insn)\n \t      where = first_output_reload_insn;\n \t      break;\n \t    case RELOAD_FOR_OPERAND_ADDRESS:\n-\t      where = insn;\n+\t      where = before_insn;\n \t    }\n \n \t  special = 0;\n@@ -4761,9 +4839,9 @@ emit_reload_insns (insn)\n \t\t  first_other_reload_insn = this_reload_insn;\n \t\tbreak;\n \t      case RELOAD_FOR_OPERAND_ADDRESS:\n-\t\tif (first_operand_address_reload_insn == insn)\n+\t\tif (first_operand_address_reload_insn == before_insn)\n \t\t  first_operand_address_reload_insn = this_reload_insn;\n-\t\tif (first_other_reload_insn == insn)\n+\t\tif (first_other_reload_insn == before_insn)\n \t\t  first_other_reload_insn = this_reload_insn;\n \t      }\n "}, {"sha": "b82e5f139688d0869f39af167840181618c7bd99", "filename": "gcc/rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Allocate and read RTL for GNU C Compiler.\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1988, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n "}, {"sha": "814068d7e0d4e19194561f5af70a8457ad08a524", "filename": "gcc/rtl.h", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8efe40d3fd0594aae44253d9ff6ffc466d2f210/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=a8efe40d3fd0594aae44253d9ff6ffc466d2f210", "patch": "@@ -1,5 +1,5 @@\n /* Register Transfer Language (RTL) definitions for GNU C-Compiler\n-   Copyright (C) 1987-1991 Free Software Foundation, Inc.\n+   Copyright (C) 1987, 1991 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -649,22 +649,21 @@ extern rtx pc_rtx;\n extern rtx cc0_rtx;\n extern rtx const0_rtx;\n extern rtx const1_rtx;\n+extern rtx const2_rtx;\n extern rtx constm1_rtx;\n extern rtx const_true_rtx;\n-extern rtx fconst0_rtx;\n-extern rtx fconst1_rtx;\n-extern rtx fconst2_rtx;\n-extern rtx dconst0_rtx;\n-extern rtx dconst1_rtx;\n-extern rtx dconst2_rtx;\n-\n-/* Returns a constant 0 rtx in mode MODE.  */\n-\n-#define CONST0_RTX(MODE) \\\n- ((MODE == SFmode) ? fconst0_rtx\t\t\t\\\n-  : ((MODE == DFmode) ? dconst0_rtx\t\t\t\\\n-     : ((GET_MODE_CLASS (MODE) == MODE_INT) ? const0_rtx\t\\\n-        : (abort (), NULL_RTX))))\n+\n+extern rtx const_tiny_rtx[3][(int) MAX_MACHINE_MODE];\n+\n+/* Returns a constant 0 rtx in mode MODE.  Integer modes are treated the \n+   same as VOIDmode.  */\n+\n+#define CONST0_RTX(MODE) (const_tiny_rtx[0][(int) (MODE)])\n+\n+/* Likewise, for the constants 1 and 2.  */\n+\n+#define CONST1_RTX(MODE) (const_tiny_rtx[1][(int) (MODE)])\n+#define CONST2_RTX(MODE) (const_tiny_rtx[2][(int) (MODE)])\n \n /* All references to certain hard regs, except those created\n    by allocating pseudo regs into them (when that's possible),"}]}