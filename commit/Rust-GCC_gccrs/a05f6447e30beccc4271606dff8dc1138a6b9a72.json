{"sha": "a05f6447e30beccc4271606dff8dc1138a6b9a72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTA1ZjY0NDdlMzBiZWNjYzQyNzE2MDZkZmY4ZGMxMTM4YTZiOWE3Mg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-19T15:08:22Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-19T15:08:22Z"}, "message": "HttpURLConnection.java, [...]: Reworked import statements.\n\n2003-06-19  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/HttpURLConnection.java,\n\tjava/net/Inet4Address.java,\n\tjava/net/Inet6Address.java,\n\tjava/net/SocketImpl.java,\n\tjava/net/URLClassLoader.java:\n\tReworked import statements.\n\t* java/net/InetAddress.java\n\t(getByAddress): Simplified.\n\t* java/net/ServerSocket.java\n\t(ServerSocket): Moved special handling during bind operation to\n\tbind().\n\t(bind): Handle different cases when trying to bind a socket.\n\t* java/net/URLConnection.java\n\t(getHeaderFieldDate): Merged with classpath.\n\t(getHeaderFieldInt): Likewise.\n\nFrom-SVN: r68198", "tree": {"sha": "79455d0849bdbde550daa14a232718f903499cff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79455d0849bdbde550daa14a232718f903499cff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a05f6447e30beccc4271606dff8dc1138a6b9a72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05f6447e30beccc4271606dff8dc1138a6b9a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a05f6447e30beccc4271606dff8dc1138a6b9a72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a05f6447e30beccc4271606dff8dc1138a6b9a72/comments", "author": null, "committer": null, "parents": [{"sha": "3580a7d58578ad416172c22400df81b1702c47ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3580a7d58578ad416172c22400df81b1702c47ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3580a7d58578ad416172c22400df81b1702c47ae"}], "stats": {"total": 296, "additions": 155, "deletions": 141}, "files": [{"sha": "245e855aec672e9749c9fede48544d44ded45053", "filename": "libjava/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -1,3 +1,21 @@\n+2003-06-19  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/HttpURLConnection.java,\n+\tjava/net/Inet4Address.java,\n+\tjava/net/Inet6Address.java,\n+\tjava/net/SocketImpl.java,\n+\tjava/net/URLClassLoader.java:\n+\tReworked import statements.\n+\t* java/net/InetAddress.java\n+\t(getByAddress): Simplified.\n+\t* java/net/ServerSocket.java\n+\t(ServerSocket): Moved special handling during bind operation to\n+\tbind().\n+\t(bind): Handle different cases when trying to bind a socket.\n+\t* java/net/URLConnection.java\n+\t(getHeaderFieldDate): Merged with classpath.\n+\t(getHeaderFieldInt): Likewise.\n+\n 2003-06-19  Michael Koch  <konqueror@gmx.de>\n \n \t* java/util/zip/InflaterInputStream.java"}, {"sha": "2f12fe57d469e27b860fdfcc361e2f6d07b21ce3", "filename": "libjava/java/net/HttpURLConnection.java", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FHttpURLConnection.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -1,7 +1,6 @@\n-// HttpURLConnection.java - Subclass of communications links using\n-//\t\t\tHypertext Transfer Protocol.\n-\n-/* Copyright (C) 1998, 1999, 2000, 2002 Free Software Foundation\n+/* HttpURLConnection.java - Subclass of communications links using\n+                            Hypertext Transfer Protocol.\n+   Copyright (C) 1998, 1999, 2000, 2002, 2003  Free Software Foundation\n \n This file is part of GNU Classpath.\n \n@@ -37,9 +36,12 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n-import java.io.*;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.PushbackInputStream;\n import java.security.Permission;\n \n /*"}, {"sha": "bcfc46ed8bfb3d694d2d0cf6989c144266ffc020", "filename": "libjava/java/net/Inet4Address.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInet4Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInet4Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet4Address.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -35,9 +35,9 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n-import java.io.IOException;\n import java.io.ObjectStreamException;\n import java.util.Arrays;\n "}, {"sha": "5514f67d14a972b5b45d0aa8b755c09f7d447c71", "filename": "libjava/java/net/Inet6Address.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInet6Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInet6Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet6Address.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -35,9 +35,9 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n-import java.io.IOException;\n import java.util.Arrays;\n \n /**"}, {"sha": "8ef63668a55a32df480c2d065a01ddebd1cd5b1b", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 55, "deletions": 61, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -92,15 +92,15 @@ private void readResolve () throws ObjectStreamException\n     // FIXME: implement this\n   }\n \t  \n-  private void readObject(ObjectInputStream ois)\n+  private void readObject (ObjectInputStream ois)\n     throws IOException, ClassNotFoundException\n   {\n-    ois.defaultReadObject();\n-    addr = new byte[4];\n-    addr[3] = (byte) address;\n+    ois.defaultReadObject ();\n+    addr = new byte [4];\n+    addr [3] = (byte) address;\n     \n     for (int i = 2; i >= 0; --i)\n-      addr[i] = (byte) (address >>= 8);\n+      addr [i] = (byte) (address >>= 8);\n     \n     // Ignore family from serialized data.  Since the saved address is 32 bits\n     // the deserialized object will have an IPv4 address i.e. AF_INET family.\n@@ -110,17 +110,17 @@ private void readObject(ObjectInputStream ois)\n     family = getFamily (addr);\n   }\n \n-  private void writeObject(ObjectOutputStream oos) throws IOException\n+  private void writeObject (ObjectOutputStream oos) throws IOException\n   {\n     // Build a 32 bit address from the last 4 bytes of a 4 byte IPv4 address\n     // or a 16 byte IPv6 address.\n     int len = addr.length;\n     int i = len - 4;\n     \n     for (; i < len; i++)\n-      address = address << 8 | (((int) addr[i]) & 0xFF);\n+      address = address << 8 | (((int) addr [i]) & 0xFF);\n     \n-    oos.defaultWriteObject();\n+    oos.defaultWriteObject ();\n   }\n \n   private static native int getFamily (byte[] address);\n@@ -144,10 +144,10 @@ public boolean isMulticastAddress ()\n     int len = addr.length;\n     \n     if (len == 4)\n-      return (addr[0] & 0xF0) == 0xE0;\n+      return (addr [0] & 0xF0) == 0xE0;\n     \n     if (len == 16)\n-      return addr[0] == (byte) 0xFF;\n+      return addr [0] == (byte) 0xFF;\n     \n     return false;\n   }\n@@ -174,7 +174,7 @@ public boolean isLoopbackAddress ()\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n     \n-    return addr[0] == 0x7F;\n+    return addr [0] == 0x7F;\n   }\n \n   /**\n@@ -202,7 +202,7 @@ public boolean isSiteLocalAddress ()\n     // Any class derived from InetAddress should override this.\n \n     // 10.0.0.0/8\n-    if (addr[0] == 0x0A)\n+    if (addr [0] == 0x0A)\n       return true;\n \n     // XXX: Suns JDK 1.4.1 (on Linux) seems to have a bug here:\n@@ -263,9 +263,9 @@ public boolean isMCLinkLocal ()\n     if (!isMulticastAddress ())\n       return false;\n \n-    return (addr[0] == 0xE0\n-\t    && addr[1] == 0x00\n-\t    && addr[2] == 0x00);\n+    return (addr [0] == 0xE0\n+\t    && addr [1] == 0x00\n+\t    && addr [2] == 0x00);\n   }\n \n   /**\n@@ -340,26 +340,26 @@ public byte[] getAddress ()\n   {\n     // An experiment shows that JDK1.2 returns a different byte array each\n     // time.  This makes sense, in terms of security.\n-    return (byte[]) addr.clone();\n+    return (byte[]) addr.clone ();\n   }\n \n   /* Helper function due to a CNI limitation.  */\n   private static InetAddress[] allocArray (int count)\n   {\n-    return new InetAddress[count];\n+    return new InetAddress [count];\n   }\n \n   /* Helper function due to a CNI limitation.  */\n   private static SecurityException checkConnect (String hostname)\n   {\n-    SecurityManager s = System.getSecurityManager();\n+    SecurityManager s = System.getSecurityManager ();\n     \n     if (s == null)\n       return null;\n     \n     try\n       {\n-\ts.checkConnect(hostname, -1);\n+\ts.checkConnect (hostname, -1);\n \treturn null;\n       }\n     catch (SecurityException ex)\n@@ -375,45 +375,45 @@ private static SecurityException checkConnect (String hostname)\n    */\n   public String getHostAddress ()\n   {\n-    StringBuffer sbuf = new StringBuffer(40);\n+    StringBuffer sbuf = new StringBuffer (40);\n     int len = addr.length;\n     int i = 0;\n     if (len == 16)\n       { // An IPv6 address.\n \tfor (;  ;  i += 2)\n \t  {\n \t    if (i >= 16)\n-\t      return sbuf.toString();\n-\t    int x = ((addr[i] & 0xFF) << 8) | (addr[i+1] & 0xFF);\n-\t    boolean empty = sbuf.length() == 0;\n+\t      return sbuf.toString ();\n+\t    int x = ((addr [i] & 0xFF) << 8) | (addr [i + 1] & 0xFF);\n+\t    boolean empty = sbuf.length () == 0;\n \t    if (empty)\n \t      {\n \t\tif (i == 10 && x == 0xFFFF)\n \t\t  { // IPv4-mapped IPv6 address.\n-\t\t    sbuf.append(\":FFFF:\");\n+\t\t    sbuf.append (\":FFFF:\");\n \t\t    break;  // Continue as IPv4 address;\n \t\t  }\n \t\telse if (i == 12)\n \t\t  { // IPv4-compatible IPv6 address.\n-\t\t    sbuf.append(':');\n+\t\t    sbuf.append (':');\n \t\t    break;  // Continue as IPv4 address.\n \t\t  }\n \t\telse if (i > 0)\n-\t\t  sbuf.append(\"::\");\n+\t\t  sbuf.append (\"::\");\n \t      }\n \t    else\n-\t      sbuf.append(':');\n+\t      sbuf.append (':');\n \t    if (x != 0 || i >= 14)\n-\t      sbuf.append(Integer.toHexString(x).toUpperCase());\n+\t      sbuf.append (Integer.toHexString (x).toUpperCase ());\n \t  }\n       }\n     for ( ;  ; )\n       {\n-\tsbuf.append(addr[i] & 0xFF);\n+\tsbuf.append (addr[i] & 0xFF);\n \ti++;\n \tif (i == len)\n \t  break;\n-\tsbuf.append('.');\n+\tsbuf.append ('.');\n       }\n     \n     return sbuf.toString();\n@@ -422,7 +422,7 @@ else if (i > 0)\n   /**\n    * Returns a hashcode of the InetAddress\n    */\n-  public int hashCode()\n+  public int hashCode ()\n   {\n     // There hashing algorithm is not specified, but a simple experiment\n     // shows that it is equal to the address, as a 32-bit big-endian integer.\n@@ -467,10 +467,10 @@ public boolean equals (Object obj)\n   /**\n    * Returns then <code>InetAddress</code> as string\n    */\n-  public String toString()\n+  public String toString ()\n   {\n     String result;\n-    String address = getHostAddress();\n+    String address = getHostAddress ();\n     \n     if (hostName != null)\n       result = hostName + \"/\" + address;\n@@ -492,16 +492,10 @@ public String toString()\n    *\n    * @since 1.4\n    */\n-  public static InetAddress getByAddress(byte[] addr)\n+  public static InetAddress getByAddress (byte[] addr)\n     throws UnknownHostException\n   {\n-    if (addr.length != 4 && addr.length != 16)\n-      throw new UnknownHostException (\"IP address has illegal length\");\n-\n-    if (addr.length == 4)\n-      return new Inet4Address (addr, null);\n-      \n-    return new Inet6Address (addr, null);\n+    return getByAddress (null, addr);\n   }\n \n   /**\n@@ -553,7 +547,7 @@ public static InetAddress getByName (String hostname)\n    \n     // Default to current host if necessary\n     if (hostname == null)\n-      return getLocalHost();\n+      return getLocalHost ();\n \n     // Assume that the host string is an IP address\n     byte[] address = aton (hostname);\n@@ -563,13 +557,13 @@ public static InetAddress getByName (String hostname)\n           return new Inet4Address (address, null);\n         else if (address.length == 16)\n           {\n-\t    if ((address[10] == 0xFF) && (address[11] == 0xFF))\n+\t    if ((address [10] == 0xFF) && (address [11] == 0xFF))\n \t      {\n-\t\tbyte[] ip4addr = new byte[4];\n-\t\tip4addr[0] = address[12];\n-\t\tip4addr[1] = address[13];\n-\t\tip4addr[2] = address[14];\n-\t\tip4addr[3] = address[15];\n+\t\tbyte[] ip4addr = new byte [4];\n+\t\tip4addr [0] = address [12];\n+\t\tip4addr [1] = address [13];\n+\t\tip4addr [2] = address [14];\n+\t\tip4addr [3] = address [15];\n \t\treturn new Inet4Address (ip4addr, null);\n \t      }\n             return new Inet6Address (address, null);\n@@ -580,7 +574,7 @@ else if (address.length == 16)\n    \n     // Try to resolve the host by DNS\n     InetAddress[] addresses = getAllByName (hostname);\n-    return addresses[0];\n+    return addresses [0];\n   }\n \n   /**\n@@ -603,19 +597,19 @@ public static InetAddress[] getAllByName (String hostname)\n     byte[] address = aton (hostname);\n     if (address != null)\n       {\n-\tInetAddress[] result = new InetAddress[1];\n-\tresult[0] = new InetAddress(address, null);\n+\tInetAddress[] result = new InetAddress [1];\n+\tresult [0] = new InetAddress (address, null);\n \treturn result;\n       }\n    \n     // Try to resolve the hostname by DNS\n     return lookup (hostname, null, true);\n   }\n \n-  static final byte[] zeros = {0,0,0,0};\n+  static final byte[] zeros = { 0, 0, 0, 0 };\n   \n   /* dummy InetAddress, used to bind socket to any (all) network interfaces */\n-  static final InetAddress ANY_IF = new InetAddress(zeros, null);\n+  static final InetAddress ANY_IF = new InetAddress (zeros, null);\n     \n   private static final byte[] localhostAddress = { 127, 0, 0, 1 };\n \n@@ -629,28 +623,28 @@ public static InetAddress[] getAllByName (String hostname)\n    * @exception UnknownHostException If no IP address for the host could\n    * be found\n    */\n-  public static InetAddress getLocalHost() throws UnknownHostException\n+  public static InetAddress getLocalHost () throws UnknownHostException\n   {\n-    SecurityManager s = System.getSecurityManager();\n+    SecurityManager s = System.getSecurityManager ();\n     \n     // Experimentation shows that JDK1.2 does cache the result.\n     // However, if there is a security manager, and the cached result\n     // is other than \"localhost\", we need to check again.\n     if (localhost == null\n \t|| (s != null && localhost.addr != localhostAddress))\n-      getLocalHost(s);\n+      getLocalHost (s);\n     \n     return localhost;\n   }\n \n-  private static synchronized void getLocalHost(SecurityManager s)\n+  private static synchronized void getLocalHost (SecurityManager s)\n     throws UnknownHostException\n   {\n     // Check the localhost cache again, now that we've synchronized.\n     if (s == null && localhost != null)\n       return;\n     \n-    String hostname = getLocalHostname();\n+    String hostname = getLocalHostname ();\n     \n     if (s != null)\n       {\n@@ -664,7 +658,7 @@ private static synchronized void getLocalHost(SecurityManager s)\n \t  {\n \t    // This is wrong, if the name returned from getLocalHostname()\n \t    // is not a fully qualified name.  FIXME.\n-\t    s.checkConnect(hostname, -1);\n+\t    s.checkConnect (hostname, -1);\n \t  }\n \tcatch (SecurityException ex)\n \t  {\n@@ -676,8 +670,8 @@ private static synchronized void getLocalHost(SecurityManager s)\n       {\n \ttry\n \t  {\n-\t    localhost = new InetAddress(null, null);\n-\t    lookup(hostname, localhost, false);\n+\t    localhost = new InetAddress (null, null);\n+\t    lookup (hostname, localhost, false);\n \t  }\n \tcatch (Exception ex)\n \t  {"}, {"sha": "8dd420bbd3b76f23ae94ac8972a4e2084baeb945", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 41, "deletions": 48, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -157,57 +157,11 @@ public ServerSocket (int port, int backlog, InetAddress bindAddr)\n     if (impl == null)\n       throw new IOException(\"Cannot initialize Socket implementation\");\n \n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkListen(port);\n-\n-    if (bindAddr == null)\n-      bindAddr = InetAddress.ANY_IF;\n-\n     // create socket\n     impl.create(true);\n \n-    // bind to address/port\n-    try\n-      {\n-        impl.bind(bindAddr, port);\n-      }\n-    catch (IOException exception)\n-      {\n-        impl.close();\n-        throw exception;\n-      }\n-    catch (RuntimeException exception)\n-      {\n-        impl.close();\n-        throw exception;\n-      }\n-    catch (Error error)\n-      {\n-        impl.close();\n-        throw error;\n-      }\n-\n-    // listen on socket\n-    try\n-      {\n-        impl.listen(backlog);\n-      }\n-    catch (IOException exception)\n-      {\n-        impl.close();\n-        throw exception;\n-      }\n-    catch (RuntimeException exception)\n-      {\n-        impl.close();\n-        throw exception;\n-      }\n-    catch (Error error)\n-      {\n-        impl.close();\n-        throw error;\n-      }\n+    // bind/listen socket\n+    bind (new InetSocketAddress (bindAddr, port), backlog);\n   }\n \n   /**\n@@ -258,9 +212,48 @@ public void bind (SocketAddress endpoint, int backlog) throws IOException\n     if (s != null)\n       s.checkListen (tmp.getPort ());\n \n+    // bind to address/port\n+    try\n+      {\n     impl.bind (tmp.getAddress (), tmp.getPort ());\n+      }\n+    catch (IOException exception)\n+      {\n+        impl.close();\n+        throw exception;\n+      }\n+    catch (RuntimeException exception)\n+      {\n+        impl.close();\n+        throw exception;\n+      }\n+    catch (Error error)\n+      {\n+        impl.close();\n+        throw error;\n+      }\n+\n+    // listen on socket\n+    try\n+      {\n     impl.listen(backlog);\n   }\n+    catch (IOException exception)\n+      {\n+        impl.close();\n+        throw exception;\n+      }\n+    catch (RuntimeException exception)\n+      {\n+        impl.close();\n+        throw exception;\n+      }\n+    catch (Error error)\n+      {\n+        impl.close();\n+        throw error;\n+      }\n+  }\n   \n   /**\n    * This method returns the local address to which this socket is bound"}, {"sha": "d380d8caae410415cfb6911879dd5ef384bee047", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -1,5 +1,6 @@\n /* SocketImpl.java -- Abstract socket implementation class\n-   Copyright (C) 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003\n+   Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -35,9 +36,13 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n-import java.io.*;\n+import java.io.FileDescriptor;\n+import java.io.InputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n \n /* Written using on-line Java Platform 1.2 API Specification.\n  * Believed complete and correct."}, {"sha": "10b67352f044b4a99e2c1548bac20981c51693db", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -35,14 +35,13 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n+\n package java.net;\n \n import java.io.ByteArrayOutputStream;\n import java.io.EOFException;\n import java.io.File;\n import java.io.FileInputStream;\n-import java.io.FileNotFoundException;\n-import java.io.FilterInputStream;\n import java.io.FilePermission;\n import java.io.InputStream;\n import java.io.IOException;\n@@ -60,7 +59,6 @@\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n import java.util.jar.Manifest;\n-import java.util.zip.ZipException;\n \n /**\n  * A secure class loader that can load classes and resources from"}, {"sha": "3b8a85be13998d301321ecf80df2ac8a7eaf574b", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 24, "deletions": 20, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a05f6447e30beccc4271606dff8dc1138a6b9a72/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=a05f6447e30beccc4271606dff8dc1138a6b9a72", "patch": "@@ -331,20 +331,19 @@ public Map getHeaderFields()\n    */\n   public int getHeaderFieldInt(String name, int defaultValue)\n   {\n-    String str = getHeaderField(name);\n-    int result = defaultValue;\n+    String value = getHeaderField (name);\n     \n+    if (value == null)\n+      return defaultValue;\n+\n     try\n       {\n-\tif (str != null)\n-\t  result = Integer.parseInt (str);\n+        return Integer.parseInt (value);\n       }\n     catch (NumberFormatException e) \n       { \n-\t; // Do nothing; defaultValue is the default.\n+        return defaultValue;\n       }\n-    \n-    return result;\n   }\n \n   /**\n@@ -353,27 +352,32 @@ public int getHeaderFieldInt(String name, int defaultValue)\n    * value if the field is not present or cannot be converted to a date.\n    *\n    * @param name The name of the header field\n-   * @param val The dafault date\n+   * @param defaultValue The default date if the header field is not found\n+   * or can't be converted.\n    *\n    * @return Returns the date value of the header filed or the default value\n    * if the field is missing or malformed\n    */\n-  public long getHeaderFieldDate(String name, long val)\n+  public long getHeaderFieldDate (String name, long defaultValue)\n   {\n     if (! dateformats_initialized)\n-      initializeDateFormats();\n-    String str = getHeaderField(name);\n+      initializeDateFormats ();\n+    \n+    long result = defaultValue;\n+    String str = getHeaderField (name);\n+    \n     if (str != null)\n       {\n-        Date date;\n-\tif ((date = dateFormat1.parse(str, new ParsePosition(0))) != null)\n-\t  val = date.getTime();\n-\telse if ((date = dateFormat2.parse(str, new ParsePosition(0))) != null)\n-\t  val = date.getTime();\n-\telse if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)\n-\t  val = date.getTime();\n+\tDate date;\n+\tif ((date = dateFormat1.parse (str, new ParsePosition (0))) != null)\n+\t  result = date.getTime ();\n+\telse if ((date = dateFormat2.parse (str, new ParsePosition (0))) != null)\n+\t  result = date.getTime ();\n+\telse if ((date = dateFormat3.parse (str, new ParsePosition (0))) != null)\n+\t  result = date.getTime ();\n       }\n-    return val;\n+    \n+    return result;\n   }\n \n   /**\n@@ -387,7 +391,7 @@ else if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)\n    * @return The header field key or null if index is past the end\n    * of the headers.\n    */\n-  public String getHeaderFieldKey(int index)\n+  public String getHeaderFieldKey (int index)\n   {\n     // Subclasses for specific protocols override this.\n     return null;"}]}