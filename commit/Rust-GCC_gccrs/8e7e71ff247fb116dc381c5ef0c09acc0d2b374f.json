{"sha": "8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3ZTcxZmYyNDdmYjExNmRjMzgxYzVlZjBjMDlhY2MwZDJiMzc0Zg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2019-12-20T01:20:30Z"}, "committer": {"name": "Julian Brown", "email": "jules@gcc.gnu.org", "date": "2019-12-20T01:20:30Z"}, "message": "OpenACC 2.6 deep copy: libgomp parts\n\n\tinclude/\n\t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_4, GOMP_MAP_DEEP_COPY):\n\tDefine.\n\t(gomp_map_kind): Add GOMP_MAP_ATTACH, GOMP_MAP_DETACH,\n\tGOMP_MAP_FORCE_DETACH.\n\n\tlibgomp/\n\t* libgomp.h (struct target_var_desc): Add do_detach flag.\n\t* oacc-init.c (acc_shutdown_1): Free aux block if present.\n\t* oacc-mem.c (find_group_last): Add SIZES parameter. Support\n\tstruct components.  Tidy up and add some new checks.\n\t(goacc_enter_data_internal): Update call to find_group_last.\n\t(goacc_exit_data_internal): Support detach operations and\n\tGOMP_MAP_STRUCT.\n\t(GOACC_enter_exit_data): Handle initial GOMP_MAP_STRUCT or\n\tGOMP_MAP_FORCE_PRESENT in finalization detection code.  Handle\n\tattach/detach in enter/exit data detection code.\n\t* target.c (gomp_map_vars_existing): Initialise do_detach field of\n\ttgt_var_desc.\n\t(gomp_map_vars_internal): Support attach.\n\t(gomp_unmap_vars_internal): Support detach.\n\nFrom-SVN: r279625", "tree": {"sha": "9658797bbde5c04da496ffedb8f577b2ba553c98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9658797bbde5c04da496ffedb8f577b2ba553c98"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d5be7bfb56358feed3fd137d4e3994fcf17f543", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d5be7bfb56358feed3fd137d4e3994fcf17f543", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d5be7bfb56358feed3fd137d4e3994fcf17f543"}], "stats": {"total": 215, "additions": 196, "deletions": 19}, "files": [{"sha": "793efe3287027a29bdcad45566af28913c959aef", "filename": "include/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -1,3 +1,10 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* gomp-constants.h (GOMP_MAP_FLAG_SPECIAL_4, GOMP_MAP_DEEP_COPY):\n+\tDefine.\n+\t(gomp_map_kind): Add GOMP_MAP_ATTACH, GOMP_MAP_DETACH,\n+\tGOMP_MAP_FORCE_DETACH.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Tobias Burnus  <tobias@codesourcery.com>"}, {"sha": "e8edfa1e22b7080f92ddc64a7a24bee00b973b98", "filename": "include/gomp-constants.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -40,8 +40,11 @@\n #define GOMP_MAP_FLAG_SPECIAL_0\t\t(1 << 2)\n #define GOMP_MAP_FLAG_SPECIAL_1\t\t(1 << 3)\n #define GOMP_MAP_FLAG_SPECIAL_2\t\t(1 << 4)\n+#define GOMP_MAP_FLAG_SPECIAL_4\t\t(1 << 6)\n #define GOMP_MAP_FLAG_SPECIAL\t\t(GOMP_MAP_FLAG_SPECIAL_1 \\\n \t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_0)\n+#define GOMP_MAP_DEEP_COPY\t\t(GOMP_MAP_FLAG_SPECIAL_4 \\\n+\t\t\t\t\t | GOMP_MAP_FLAG_SPECIAL_2)\n /* Flag to force a specific behavior (or else, trigger a run-time error).  */\n #define GOMP_MAP_FLAG_FORCE\t\t(1 << 7)\n \n@@ -129,6 +132,13 @@ enum gomp_map_kind\n     /* Decrement usage count and deallocate if zero.  */\n     GOMP_MAP_RELEASE =\t\t\t(GOMP_MAP_FLAG_SPECIAL_2\n \t\t\t\t\t | GOMP_MAP_DELETE),\n+    /* In OpenACC, attach a pointer to a mapped struct field.  */\n+    GOMP_MAP_ATTACH =\t\t\t(GOMP_MAP_DEEP_COPY | 0),\n+    /* In OpenACC, detach a pointer to a mapped struct field.  */\n+    GOMP_MAP_DETACH =\t\t\t(GOMP_MAP_DEEP_COPY | 1),\n+    /* In OpenACC, detach a pointer to a mapped struct field.  */\n+    GOMP_MAP_FORCE_DETACH =\t\t(GOMP_MAP_DEEP_COPY\n+\t\t\t\t\t | GOMP_MAP_FLAG_FORCE | 1),\n \n     /* Internal to GCC, not used in libgomp.  */\n     /* Do not map, but pointer assign a pointer instead.  */"}, {"sha": "17ed66df226ffad451aa02d60e5bfcc9dc2d65fe", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -1,3 +1,20 @@\n+2019-12-19  Julian Brown  <julian@codesourcery.com>\n+\n+\t* libgomp.h (struct target_var_desc): Add do_detach flag.\n+\t* oacc-init.c (acc_shutdown_1): Free aux block if present.\n+\t* oacc-mem.c (find_group_last): Add SIZES parameter. Support\n+\tstruct components.  Tidy up and add some new checks.\n+\t(goacc_enter_data_internal): Update call to find_group_last.\n+\t(goacc_exit_data_internal): Support detach operations and\n+\tGOMP_MAP_STRUCT.\n+\t(GOACC_enter_exit_data): Handle initial GOMP_MAP_STRUCT or\n+\tGOMP_MAP_FORCE_PRESENT in finalization detection code.  Handle\n+\tattach/detach in enter/exit data detection code.\n+\t* target.c (gomp_map_vars_existing): Initialise do_detach field of\n+\ttgt_var_desc.\n+\t(gomp_map_vars_internal): Support attach.\n+\t(gomp_unmap_vars_internal): Support detach.\n+\n 2019-12-19  Julian Brown  <julian@codesourcery.com>\n \t    Thomas Schwinge  <thomas@codesourcery.com>\n "}, {"sha": "c9653575208876064dfaf284d9ccdbafb3f0d84e", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -948,6 +948,8 @@ struct target_var_desc {\n   bool copy_from;\n   /* True if data always should be copied from device to host at the end.  */\n   bool always_copy_from;\n+  /* True if variable should be detached at end of region.  */\n+  bool do_detach;\n   /* Relative offset against key host_start.  */\n   uintptr_t offset;\n   /* Actual length.  */"}, {"sha": "6d4c4982282ae58033bd1ce7b496cf0dc2172c36", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 110, "deletions": 18, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -957,33 +957,48 @@ acc_detach_finalize_async (void **hostaddr, int async)\n    mappings.  */\n \n static int\n-find_group_last (int pos, size_t mapnum, unsigned short *kinds)\n+find_group_last (int pos, size_t mapnum, size_t *sizes, unsigned short *kinds)\n {\n   unsigned char kind0 = kinds[pos] & 0xff;\n-  int first_pos = pos, last_pos = pos;\n+  int first_pos = pos;\n \n-  if (kind0 == GOMP_MAP_TO_PSET)\n+  switch (kind0)\n     {\n+    case GOMP_MAP_TO_PSET:\n       while (pos + 1 < mapnum && (kinds[pos + 1] & 0xff) == GOMP_MAP_POINTER)\n-\tlast_pos = ++pos;\n+\tpos++;\n       /* We expect at least one GOMP_MAP_POINTER after a GOMP_MAP_TO_PSET.  */\n-      assert (last_pos > first_pos);\n-    }\n-  else\n-    {\n+      assert (pos > first_pos);\n+      break;\n+\n+    case GOMP_MAP_STRUCT:\n+      pos += sizes[pos];\n+      break;\n+\n+    case GOMP_MAP_POINTER:\n+    case GOMP_MAP_ALWAYS_POINTER:\n+      /* These mappings are only expected after some other mapping.  If we\n+\t see one by itself, something has gone wrong.  */\n+      gomp_fatal (\"unexpected mapping\");\n+      break;\n+\n+    default:\n       /* GOMP_MAP_ALWAYS_POINTER can only appear directly after some other\n \t mapping.  */\n-      if (pos + 1 < mapnum\n-\t  && (kinds[pos + 1] & 0xff) == GOMP_MAP_ALWAYS_POINTER)\n-\treturn pos + 1;\n+      if (pos + 1 < mapnum)\n+\t{\n+\t  unsigned char kind1 = kinds[pos + 1] & 0xff;\n+\t  if (kind1 == GOMP_MAP_ALWAYS_POINTER)\n+\t    return pos + 1;\n+\t}\n \n-      /* We can have one or several GOMP_MAP_POINTER mappings after a to/from\n+      /* We can have zero or more GOMP_MAP_POINTER mappings after a to/from\n \t (etc.) mapping.  */\n       while (pos + 1 < mapnum && (kinds[pos + 1] & 0xff) == GOMP_MAP_POINTER)\n-\tlast_pos = ++pos;\n+\tpos++;\n     }\n \n-  return last_pos;\n+  return pos;\n }\n \n /* Map variables for OpenACC \"enter data\".  We can't just call\n@@ -997,7 +1012,7 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n {\n   for (size_t i = 0; i < mapnum; i++)\n     {\n-      int group_last = find_group_last (i, mapnum, kinds);\n+      int group_last = find_group_last (i, mapnum, sizes, kinds);\n \n       gomp_map_vars_async (acc_dev, aq,\n \t\t\t   (group_last - i) + 1,\n@@ -1018,14 +1033,46 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n {\n   gomp_mutex_lock (&acc_dev->lock);\n \n+  /* Handle \"detach\" before copyback/deletion of mapped data.  */\n+  for (size_t i = 0; i < mapnum; ++i)\n+    {\n+      unsigned char kind = kinds[i] & 0xff;\n+      bool finalize = false;\n+      switch (kind)\n+\t{\n+\tcase GOMP_MAP_FORCE_DETACH:\n+\t  finalize = true;\n+\t  /* Fallthrough.  */\n+\n+\tcase GOMP_MAP_DETACH:\n+\t  {\n+\t    struct splay_tree_key_s cur_node;\n+\t    uintptr_t hostaddr = (uintptr_t) hostaddrs[i];\n+\t    cur_node.host_start = hostaddr;\n+\t    cur_node.host_end = cur_node.host_start + sizeof (void *);\n+\t    splay_tree_key n\n+\t      = splay_tree_lookup (&acc_dev->mem_map, &cur_node);\n+\n+\t    if (n == NULL)\n+\t      gomp_fatal (\"struct not mapped for detach operation\");\n+\n+\t    gomp_detach_pointer (acc_dev, aq, n, hostaddr, finalize, NULL);\n+\t  }\n+\t  break;\n+\tdefault:\n+\t  ;\n+\t}\n+    }\n+\n   for (size_t i = 0; i < mapnum; ++i)\n     {\n       unsigned char kind = kinds[i] & 0xff;\n       bool copyfrom = false;\n       bool finalize = false;\n \n       if (kind == GOMP_MAP_FORCE_FROM\n-\t  || kind == GOMP_MAP_DELETE)\n+\t  || kind == GOMP_MAP_DELETE\n+\t  || kind == GOMP_MAP_FORCE_DETACH)\n \tfinalize = true;\n \n       switch (kind)\n@@ -1040,10 +1087,14 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \tcase GOMP_MAP_POINTER:\n \tcase GOMP_MAP_DELETE:\n \tcase GOMP_MAP_RELEASE:\n+\tcase GOMP_MAP_DETACH:\n+\tcase GOMP_MAP_FORCE_DETACH:\n \t  {\n \t    struct splay_tree_key_s cur_node;\n \t    size_t size;\n-\t    if (kind == GOMP_MAP_POINTER)\n+\t    if (kind == GOMP_MAP_POINTER\n+\t\t|| kind == GOMP_MAP_DETACH\n+\t\t|| kind == GOMP_MAP_FORCE_DETACH)\n \t      size = sizeof (void *);\n \t    else\n \t      size = sizes[i];\n@@ -1083,6 +1134,42 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t      gomp_remove_var_async (acc_dev, n, aq);\n \t  }\n \t  break;\n+\n+\tcase GOMP_MAP_STRUCT:\n+\t  {\n+\t    int elems = sizes[i];\n+\t    for (int j = 1; j <= elems; j++)\n+\t      {\n+\t\tstruct splay_tree_key_s k;\n+\t\tk.host_start = (uintptr_t) hostaddrs[i + j];\n+\t\tk.host_end = k.host_start + sizes[i + j];\n+\t\tsplay_tree_key str;\n+\t\tstr = splay_tree_lookup (&acc_dev->mem_map, &k);\n+\t\tif (str)\n+\t\t  {\n+\t\t    if (finalize)\n+\t\t      {\n+\t\t\tif (str->refcount != REFCOUNT_INFINITY)\n+\t\t\t  str->refcount -= str->virtual_refcount;\n+\t\t\tstr->virtual_refcount = 0;\n+\t\t      }\n+\t\t    if (str->virtual_refcount > 0)\n+\t\t      {\n+\t\t\tif (str->refcount != REFCOUNT_INFINITY)\n+\t\t\t  str->refcount--;\n+\t\t\tstr->virtual_refcount--;\n+\t\t      }\n+\t\t    else if (str->refcount > 0\n+\t\t\t     && str->refcount != REFCOUNT_INFINITY)\n+\t\t      str->refcount--;\n+\t\t    if (str->refcount == 0)\n+\t\t      gomp_remove_var_async (acc_dev, str, aq);\n+\t\t  }\n+\t      }\n+\t    i += elems;\n+\t  }\n+\t  break;\n+\n \tdefault:\n \t  gomp_fatal (\">>>> goacc_exit_data_internal UNHANDLED kind 0x%.2x\",\n \t\t\t  kind);\n@@ -1114,11 +1201,14 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n     {\n       unsigned char kind = kinds[i] & 0xff;\n \n-      if (kind == GOMP_MAP_POINTER || kind == GOMP_MAP_TO_PSET)\n+      if (kind == GOMP_MAP_POINTER\n+\t  || kind == GOMP_MAP_TO_PSET\n+\t  || kind == GOMP_MAP_STRUCT)\n \tcontinue;\n \n       if (kind == GOMP_MAP_FORCE_ALLOC\n \t  || kind == GOMP_MAP_FORCE_PRESENT\n+\t  || kind == GOMP_MAP_ATTACH\n \t  || kind == GOMP_MAP_FORCE_TO\n \t  || kind == GOMP_MAP_TO\n \t  || kind == GOMP_MAP_ALLOC)\n@@ -1129,6 +1219,8 @@ GOACC_enter_exit_data (int flags_m, size_t mapnum, void **hostaddrs,\n \n       if (kind == GOMP_MAP_RELEASE\n \t  || kind == GOMP_MAP_DELETE\n+\t  || kind == GOMP_MAP_DETACH\n+\t  || kind == GOMP_MAP_FORCE_DETACH\n \t  || kind == GOMP_MAP_FROM\n \t  || kind == GOMP_MAP_FORCE_FROM)\n \tbreak;"}, {"sha": "50a9c2b1df3fd978e68f6fbef1da5134dcf1825f", "filename": "libgomp/target.c", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7e71ff247fb116dc381c5ef0c09acc0d2b374f/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=8e7e71ff247fb116dc381c5ef0c09acc0d2b374f", "patch": "@@ -360,6 +360,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n   tgt_var->key = oldn;\n   tgt_var->copy_from = GOMP_MAP_COPY_FROM_P (kind);\n   tgt_var->always_copy_from = GOMP_MAP_ALWAYS_FROM_P (kind);\n+  tgt_var->do_detach = kind == GOMP_MAP_ATTACH;\n   tgt_var->offset = newn->host_start - oldn->host_start;\n   tgt_var->length = newn->host_end - newn->host_start;\n \n@@ -798,8 +799,15 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t  has_firstprivate = true;\n \t  continue;\n \t}\n+      else if ((kind & typemask) == GOMP_MAP_ATTACH)\n+\t{\n+\t  tgt->list[i].key = NULL;\n+\t  has_firstprivate = true;\n+\t  continue;\n+\t}\n       cur_node.host_start = (uintptr_t) hostaddrs[i];\n-      if (!GOMP_MAP_POINTER_P (kind & typemask))\n+      if (!GOMP_MAP_POINTER_P (kind & typemask)\n+\t  && (kind & typemask) != GOMP_MAP_ATTACH)\n \tcur_node.host_end = cur_node.host_start + sizes[i];\n       else\n \tcur_node.host_end = cur_node.host_start + sizeof (void *);\n@@ -1046,6 +1054,32 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t== GOMP_MAP_POINTER))\n \t\t  ++i;\n \t\tcontinue;\n+\t      case GOMP_MAP_ATTACH:\n+\t\t{\n+\t\t  cur_node.host_start = (uintptr_t) hostaddrs[i];\n+\t\t  cur_node.host_end = cur_node.host_start + sizeof (void *);\n+\t\t  splay_tree_key n = splay_tree_lookup (mem_map, &cur_node);\n+\t\t  if (n != NULL)\n+\t\t    {\n+\t\t      tgt->list[i].key = n;\n+\t\t      tgt->list[i].offset = cur_node.host_start - n->host_start;\n+\t\t      tgt->list[i].length = n->host_end - n->host_start;\n+\t\t      tgt->list[i].copy_from = false;\n+\t\t      tgt->list[i].always_copy_from = false;\n+\t\t      tgt->list[i].do_detach\n+\t\t\t= (pragma_kind != GOMP_MAP_VARS_OPENACC_ENTER_DATA);\n+\t\t      n->refcount++;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      gomp_mutex_unlock (&devicep->lock);\n+\t\t      gomp_fatal (\"outer struct not mapped for attach\");\n+\t\t    }\n+\t\t  gomp_attach_pointer (devicep, aq, mem_map, n,\n+\t\t\t\t       (uintptr_t) hostaddrs[i], sizes[i],\n+\t\t\t\t       cbufp);\n+\t\t  continue;\n+\t\t}\n \t      default:\n \t\tbreak;\n \t      }\n@@ -1090,10 +1124,12 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\ttgt->list[i].copy_from = GOMP_MAP_COPY_FROM_P (kind & typemask);\n \t\ttgt->list[i].always_copy_from\n \t\t  = GOMP_MAP_ALWAYS_FROM_P (kind & typemask);\n+\t\ttgt->list[i].do_detach = false;\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n \t\tk->refcount = 1;\n \t\tk->virtual_refcount = 0;\n+\t\tk->aux = NULL;\n \t\ttgt->refcount++;\n \t\tarray->left = NULL;\n \t\tarray->right = NULL;\n@@ -1144,6 +1180,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t  tgt->list[j].key = k;\n \t\t\t  tgt->list[j].copy_from = false;\n \t\t\t  tgt->list[j].always_copy_from = false;\n+\t\t\t  tgt->list[j].do_detach = false;\n \t\t\t  if (k->refcount != REFCOUNT_INFINITY)\n \t\t\t    k->refcount++;\n \t\t\t  gomp_map_pointer (tgt, aq,\n@@ -1377,6 +1414,18 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n     }\n \n   size_t i;\n+\n+  /* We must perform detachments before any copies back to the host.  */\n+  for (i = 0; i < tgt->list_count; i++)\n+    {\n+      splay_tree_key k = tgt->list[i].key;\n+\n+      if (k != NULL && tgt->list[i].do_detach)\n+\tgomp_detach_pointer (devicep, aq, k, tgt->list[i].key->host_start\n+\t\t\t\t\t     + tgt->list[i].offset,\n+\t\t\t     k->refcount == 1, NULL);\n+    }\n+\n   for (i = 0; i < tgt->list_count; i++)\n     {\n       splay_tree_key k = tgt->list[i].key;"}]}