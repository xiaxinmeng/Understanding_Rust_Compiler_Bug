{"sha": "a89992356b0fb31b723a5ca80c450912ff09d881", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTg5OTkyMzU2YjBmYjMxYjcyM2E1Y2E4MGM0NTA5MTJmZjA5ZDg4MQ==", "commit": {"author": {"name": "Thomas Koenig", "email": "Thomas.Koenig@online.de", "date": "2006-02-04T22:11:57Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2006-02-04T22:11:57Z"}, "message": "re PR fortran/25075 ([4.1 only] array size mismatch in DOT_PRODUCT)\n\n2006-02-04  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/25075\n\tcheck.c (identical_dimen_shape):  New function.\n\t(check_dot_product):  Use identical_dimen_shape() to check sizes\n\tfor dot_product.\n\t(gfc_check_matmul):  Likewise.\n\t(gfc_check_merge):  Check conformance between tsource and fsource\n\tand between tsource and mask.\n\t(gfc_check_pack):  Check conformance between array and mask.\n\n2006-02-04  Thomas Koenig  <Thomas.Koenig@online.de>\n\n\tPR fortran/25075\n\tintrinsic_argument_conformance_1.f90:  New test.\n\nFrom-SVN: r110596", "tree": {"sha": "33b1a15e38e3c7bc298d8665900f8b6ff2fe4d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/33b1a15e38e3c7bc298d8665900f8b6ff2fe4d70"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a89992356b0fb31b723a5ca80c450912ff09d881", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89992356b0fb31b723a5ca80c450912ff09d881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a89992356b0fb31b723a5ca80c450912ff09d881", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89992356b0fb31b723a5ca80c450912ff09d881/comments", "author": null, "committer": null, "parents": [{"sha": "3a3315f7cc629449dd06d3d0f40409f98b446393", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a3315f7cc629449dd06d3d0f40409f98b446393", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a3315f7cc629449dd06d3d0f40409f98b446393"}], "stats": {"total": 123, "additions": 111, "deletions": 12}, "files": [{"sha": "2ea8316293a03fc0fb0be9ffb7b0b378c5dc87c2", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=a89992356b0fb31b723a5ca80c450912ff09d881", "patch": "@@ -1,3 +1,14 @@\n+2006-02-04  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/25075\n+\tcheck.c (identical_dimen_shape):  New function.\n+\t(check_dot_product):  Use identical_dimen_shape() to check sizes\n+\tfor dot_product.\n+\t(gfc_check_matmul):  Likewise.\n+\t(gfc_check_merge):  Check conformance between tsource and fsource\n+\tand between tsource and mask.\n+\t(gfc_check_pack):  Check conformance between array and mask.\n+\n 2006-02-03  Steven G. Kargl  <kargls@comcast>\n \t    Paul Thomas  <pault@gcc.gnu.org>\n "}, {"sha": "dc6541c85980ddd103a3f700764660bdb14f3173", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 85, "deletions": 12, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=a89992356b0fb31b723a5ca80c450912ff09d881", "patch": "@@ -354,6 +354,34 @@ dim_rank_check (gfc_expr * dim, gfc_expr * array, int allow_assumed)\n   return SUCCESS;\n }\n \n+/* Compare the size of a along dimension ai with the size of b along\n+   dimension bi, returning 0 if they are known not to be identical,\n+   and 1 if they are identical, or if this cannot be determined.  */\n+\n+static int\n+identical_dimen_shape (gfc_expr *a, int ai, gfc_expr *b, int bi)\n+{\n+  mpz_t a_size, b_size;\n+  int ret;\n+\n+  gcc_assert (a->rank > ai);\n+  gcc_assert (b->rank > bi);\n+\n+  ret = 1;\n+\n+  if (gfc_array_dimen_size (a, ai, &a_size) == SUCCESS)\n+    {\n+      if (gfc_array_dimen_size (b, bi, &b_size) == SUCCESS)\n+\t{\n+\t  if (mpz_cmp (a_size, b_size) != 0)\n+\t    ret = 0;\n+  \n+\t  mpz_clear (b_size);\n+\t}\n+      mpz_clear (a_size);\n+    }\n+  return ret;\n+}\n \n /***** Check functions *****/\n \n@@ -802,6 +830,16 @@ gfc_check_dot_product (gfc_expr * vector_a, gfc_expr * vector_b)\n   if (rank_check (vector_b, 1, 1) == FAILURE)\n     return FAILURE;\n \n+  if (! identical_dimen_shape (vector_a, 0, vector_b, 0))\n+    {\n+      gfc_error (\"different shape for arguments '%s' and '%s' \"\n+\t\t \"at %L for intrinsic 'dot_product'\",\n+\t\t gfc_current_intrinsic_arg[0],\n+\t\t gfc_current_intrinsic_arg[1],\n+\t\t &vector_a->where);\n+      return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -1461,13 +1499,35 @@ gfc_check_matmul (gfc_expr * matrix_a, gfc_expr * matrix_b)\n     case 1:\n       if (rank_check (matrix_b, 1, 2) == FAILURE)\n \treturn FAILURE;\n+      /* Check for case matrix_a has shape(m), matrix_b has shape (m, k).  */\n+      if (! identical_dimen_shape (matrix_a, 0, matrix_b, 0))\n+\t{\n+\t  gfc_error (\"different shape on dimension 1 for arguments '%s' \"\n+\t\t     \"and '%s' at %L for intrinsic matmul\",\n+\t\t     gfc_current_intrinsic_arg[0],\n+\t\t     gfc_current_intrinsic_arg[1],\n+\t\t     &matrix_a->where);\n+\t  return FAILURE;\n+\t}\n       break;\n \n     case 2:\n-      if (matrix_b->rank == 2)\n-\tbreak;\n-      if (rank_check (matrix_b, 1, 1) == FAILURE)\n-\treturn FAILURE;\n+      if (matrix_b->rank != 2)\n+\t{\n+\t  if (rank_check (matrix_b, 1, 1) == FAILURE)\n+\t    return FAILURE;\n+\t}\n+      /* matrix_b has rank 1 or 2 here. Common check for the cases\n+\t - matrix_a has shape (n,m) and matrix_b has shape (m, k)\n+\t - matrix_a has shape (n,m) and matrix_b has shape (m).  */\n+      if (! identical_dimen_shape (matrix_a, 1, matrix_b, 0))\n+\t{\n+\t  gfc_error (\"different shape on dimension 2 for argument '%s' and \"\n+\t\t     \"dimension 1 for argument '%s' at %L for intrinsic \"\n+\t\t     \"matmul\", gfc_current_intrinsic_arg[0],\n+\t\t     gfc_current_intrinsic_arg[1], &matrix_a->where);\n+\t  return FAILURE;\n+\t}\n       break;\n \n     default:\n@@ -1621,12 +1681,26 @@ gfc_check_product_sum (gfc_actual_arglist * ap)\n try\n gfc_check_merge (gfc_expr * tsource, gfc_expr * fsource, gfc_expr * mask)\n {\n+  char buffer[80];\n+\n   if (same_type_check (tsource, 0, fsource, 1) == FAILURE)\n     return FAILURE;\n \n   if (type_check (mask, 2, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n+  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n+\t   gfc_current_intrinsic);\n+  if (gfc_check_conformance (buffer, tsource, fsource) == FAILURE)\n+    return FAILURE;\n+\n+  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[2],\n+\t   gfc_current_intrinsic);\n+  if (gfc_check_conformance (buffer, tsource, mask) == FAILURE)\n+    return FAILURE;\n+\n   return SUCCESS;\n }\n \n@@ -1672,20 +1746,19 @@ gfc_check_null (gfc_expr * mold)\n try\n gfc_check_pack (gfc_expr * array, gfc_expr * mask, gfc_expr * vector)\n {\n+  char buffer[80];\n+\n   if (array_check (array, 0) == FAILURE)\n     return FAILURE;\n \n   if (type_check (mask, 1, BT_LOGICAL) == FAILURE)\n     return FAILURE;\n \n-  if (mask->rank != 0 && mask->rank != array->rank)\n-    {\n-      gfc_error (\"'%s' argument of '%s' intrinsic at %L must be conformable \"\n-\t\t \"with '%s' argument\", gfc_current_intrinsic_arg[0],\n-\t\t gfc_current_intrinsic, &array->where,\n-\t\t gfc_current_intrinsic_arg[1]);\n-      return FAILURE;\n-    }\n+  snprintf(buffer, sizeof(buffer), \"arguments '%s' and '%s' for intrinsic '%s'\",\n+\t   gfc_current_intrinsic_arg[0], gfc_current_intrinsic_arg[1],\n+\t   gfc_current_intrinsic);\n+  if (gfc_check_conformance (buffer, array, mask) == FAILURE)\n+    return FAILURE;\n \n   if (vector != NULL)\n     {"}, {"sha": "d35cfa1ab105184b34188c76d48225a8542c3c81", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a89992356b0fb31b723a5ca80c450912ff09d881", "patch": "@@ -1,3 +1,8 @@\n+2006-02-04  Thomas Koenig  <Thomas.Koenig@online.de>\n+\n+\tPR fortran/25075\n+\tintrinsic_argument_conformance_1.f90:  New test.\n+\n 2006-02-03  Steven G. Kargl  <kargls@comcast.net>\n \n \tPR fortran/20845"}, {"sha": "bfdcf429ebbe464968311af26b50b16809f74e9d", "filename": "gcc/testsuite/gfortran.dg/intrinsic_argument_conformance_1.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a89992356b0fb31b723a5ca80c450912ff09d881/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fintrinsic_argument_conformance_1.f90?ref=a89992356b0fb31b723a5ca80c450912ff09d881", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+program main\n+  real :: av(2), bv(4)\n+  real :: a(2,2)\n+  logical :: lo(3,2)\n+  print *,dot_product(av, bv) ! { dg-error \"different shape\" }\n+  print *,pack(a, lo) ! { dg-error \"different shape\" }\n+  print *,merge(av, bv, lo(1,:)) ! { dg-error \"different shape\" }\n+  print *,matmul(bv,a) ! { dg-error \"different shape\" }\n+end program main"}]}