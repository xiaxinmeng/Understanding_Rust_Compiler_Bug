{"sha": "ab2789ec507a94f1a75a6534bca51c7b39037ce0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWIyNzg5ZWM1MDdhOTRmMWE3NWE2NTM0YmNhNTFjN2IzOTAzN2NlMA==", "commit": {"author": {"name": "Marco Elver", "email": "elver@google.com", "date": "2020-06-09T13:15:39Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-06-09T19:22:24Z"}, "message": "tsan: Add optional support for distinguishing volatiles\n\nAdd support to optionally emit different instrumentation for accesses to\nvolatile variables. While the default TSAN runtime likely will never\nrequire this feature, other runtimes for different environments that\nhave subtly different memory models or assumptions may require\ndistinguishing volatiles.\n\nOne such environment are OS kernels, where volatile is still used in\nvarious places, and often declare volatile to be appropriate even in\nmulti-threaded contexts. One such example is the Linux kernel, which\nimplements various synchronization primitives using volatile\n(READ_ONCE(), WRITE_ONCE()).\n\nHere the Kernel Concurrency Sanitizer (KCSAN), is a runtime that uses\nTSAN instrumentation but otherwise implements a very different approach\nto race detection from TSAN:\n\n\thttps://github.com/google/ktsan/wiki/KCSAN\n\nDue to recent changes in requirements by the Linux kernel, KCSAN\nrequires that the compiler supports tsan-distinguish-volatile (among\nseveral new requirements):\n\n\thttps://lore.kernel.org/lkml/20200521142047.169334-7-elver@google.com/\n\ngcc/\n\t* params.opt: Define --param=tsan-distinguish-volatile=[0,1].\n\t* sanitizer.def (BUILT_IN_TSAN_VOLATILE_READ1): Define new\n\tbuiltin for volatile instrumentation of reads/writes.\n\t(BUILT_IN_TSAN_VOLATILE_READ2): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ4): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ8): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ16): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE1): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE2): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE4): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE8): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE16): Likewise.\n\t* tsan.c (get_memory_access_decl): Argument if access is\n\tvolatile. If param tsan-distinguish-volatile is non-zero, and\n\taccess if volatile, return volatile instrumentation decl.\n\t(instrument_expr): Check if access is volatile.\n\ngcc/testsuite/\n\t* c-c++-common/tsan/volatile.c: New test.", "tree": {"sha": "7b9e508583db3280549c554e3cbb51ceb877ccdb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b9e508583db3280549c554e3cbb51ceb877ccdb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ab2789ec507a94f1a75a6534bca51c7b39037ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl7f4XQACgkQTcGC3A+n\nN4WpwQgAnsWgkiTz3QR/5Cz2tVysHShhE0IeqpHig1H8zrZCapymKqTam7fZ5KFL\nUAjI0CDfNqz9R/grUiBxDDMRX1w0allg1eCje2OjFWEEjN3hrHWT4M7KOzjAEE1+\nL8j4iArfpOVUspHlO6dFPeGq0U2zedCG6IZerubDdASvbHK8N8ZDTqBca4yxGKa7\nzXZ95jYGjp9D4CkwHbktTzFJwlENJSe8vETUksdCVRpcJtmB7nj9qkusG2jUZc5w\nzUJpRAgIcZiUmINz25X0CBaqiPY3XzVFgSpUz0M+J2jwNgCaHqQY4+FkKiaiOmld\nZGcMUDjr6MbiUV1u2qX6PxqW6HkFPQ==\n=6cRG\n-----END PGP SIGNATURE-----", "payload": "tree 7b9e508583db3280549c554e3cbb51ceb877ccdb\nparent 6e52b2297ecce1243c00d76b3f079b71016b8ffa\nauthor Marco Elver <elver@google.com> 1591708539 +0200\ncommitter Martin Liska <mliska@suse.cz> 1591730544 +0200\n\ntsan: Add optional support for distinguishing volatiles\n\nAdd support to optionally emit different instrumentation for accesses to\nvolatile variables. While the default TSAN runtime likely will never\nrequire this feature, other runtimes for different environments that\nhave subtly different memory models or assumptions may require\ndistinguishing volatiles.\n\nOne such environment are OS kernels, where volatile is still used in\nvarious places, and often declare volatile to be appropriate even in\nmulti-threaded contexts. One such example is the Linux kernel, which\nimplements various synchronization primitives using volatile\n(READ_ONCE(), WRITE_ONCE()).\n\nHere the Kernel Concurrency Sanitizer (KCSAN), is a runtime that uses\nTSAN instrumentation but otherwise implements a very different approach\nto race detection from TSAN:\n\n\thttps://github.com/google/ktsan/wiki/KCSAN\n\nDue to recent changes in requirements by the Linux kernel, KCSAN\nrequires that the compiler supports tsan-distinguish-volatile (among\nseveral new requirements):\n\n\thttps://lore.kernel.org/lkml/20200521142047.169334-7-elver@google.com/\n\ngcc/\n\t* params.opt: Define --param=tsan-distinguish-volatile=[0,1].\n\t* sanitizer.def (BUILT_IN_TSAN_VOLATILE_READ1): Define new\n\tbuiltin for volatile instrumentation of reads/writes.\n\t(BUILT_IN_TSAN_VOLATILE_READ2): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ4): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ8): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_READ16): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE1): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE2): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE4): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE8): Likewise.\n\t(BUILT_IN_TSAN_VOLATILE_WRITE16): Likewise.\n\t* tsan.c (get_memory_access_decl): Argument if access is\n\tvolatile. If param tsan-distinguish-volatile is non-zero, and\n\taccess if volatile, return volatile instrumentation decl.\n\t(instrument_expr): Check if access is volatile.\n\ngcc/testsuite/\n\t* c-c++-common/tsan/volatile.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2789ec507a94f1a75a6534bca51c7b39037ce0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab2789ec507a94f1a75a6534bca51c7b39037ce0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab2789ec507a94f1a75a6534bca51c7b39037ce0/comments", "author": {"login": "melver", "id": 795549, "node_id": "MDQ6VXNlcjc5NTU0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/795549?v=4", "gravatar_id": "", "url": "https://api.github.com/users/melver", "html_url": "https://github.com/melver", "followers_url": "https://api.github.com/users/melver/followers", "following_url": "https://api.github.com/users/melver/following{/other_user}", "gists_url": "https://api.github.com/users/melver/gists{/gist_id}", "starred_url": "https://api.github.com/users/melver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/melver/subscriptions", "organizations_url": "https://api.github.com/users/melver/orgs", "repos_url": "https://api.github.com/users/melver/repos", "events_url": "https://api.github.com/users/melver/events{/privacy}", "received_events_url": "https://api.github.com/users/melver/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e52b2297ecce1243c00d76b3f079b71016b8ffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e52b2297ecce1243c00d76b3f079b71016b8ffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e52b2297ecce1243c00d76b3f079b71016b8ffa"}], "stats": {"total": 121, "additions": 109, "deletions": 12}, "files": [{"sha": "9b564bb046c5d129e0dce0a769382f8b6e4b0569", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=ab2789ec507a94f1a75a6534bca51c7b39037ce0", "patch": "@@ -908,6 +908,10 @@ Stop reverse growth if the reverse probability of best edge is less than this th\n Common Joined UInteger Var(param_tree_reassoc_width) Param Optimization\n Set the maximum number of instructions executed in parallel in reassociated tree.  If 0, use the target dependent heuristic.\n \n+-param=tsan-distinguish-volatile=\n+Common Joined UInteger Var(param_tsan_distinguish_volatile) IntegerRange(0, 1) Param\n+Emit special instrumentation for accesses to volatiles.\n+\n -param=uninit-control-dep-attempts=\n Common Joined UInteger Var(param_uninit_control_dep_attempts) Init(1000) IntegerRange(1, 65536) Param Optimization\n Maximum number of nested calls to search for control dependencies during uninitialized variable analysis."}, {"sha": "a32715ddb92e69b7ca7be28a8f17a369b891bd76", "filename": "gcc/sanitizer.def", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Fsanitizer.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Fsanitizer.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanitizer.def?ref=ab2789ec507a94f1a75a6534bca51c7b39037ce0", "patch": "@@ -214,6 +214,27 @@ DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_READ_RANGE, \"__tsan_read_range\",\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_WRITE_RANGE, \"__tsan_write_range\",\n \t\t      BT_FN_VOID_PTR_PTRMODE, ATTR_NOTHROW_LEAF_LIST)\n \n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_READ1, \"__tsan_volatile_read1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_READ2, \"__tsan_volatile_read2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_READ4, \"__tsan_volatile_read4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_READ8, \"__tsan_volatile_read8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_READ16, \"__tsan_volatile_read16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_WRITE1, \"__tsan_volatile_write1\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_WRITE2, \"__tsan_volatile_write2\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_WRITE4, \"__tsan_volatile_write4\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_WRITE8, \"__tsan_volatile_write8\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_VOLATILE_WRITE16, \"__tsan_volatile_write16\",\n+\t\t      BT_FN_VOID_PTR, ATTR_NOTHROW_LEAF_LIST)\n+\n DEF_SANITIZER_BUILTIN(BUILT_IN_TSAN_ATOMIC8_LOAD,\n \t\t      \"__tsan_atomic8_load\",\n \t\t      BT_FN_I1_CONST_VPTR_INT, ATTR_NOTHROW_LEAF_LIST)"}, {"sha": "68379921685de7d390fdea73efdd3771c47592d1", "filename": "gcc/testsuite/c-c++-common/tsan/volatile.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fvolatile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fvolatile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Ftsan%2Fvolatile.c?ref=ab2789ec507a94f1a75a6534bca51c7b39037ce0", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-options \"--param=tsan-distinguish-volatile=1 -fdump-tree-optimized\" } */\n+\n+#include <assert.h>\n+#include <stdint.h>\n+#include <stdio.h>\n+\n+int32_t Global4;\n+volatile int32_t VolatileGlobal4;\n+volatile int64_t VolatileGlobal8;\n+\n+static int nvolatile_reads;\n+static int nvolatile_writes;\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+__attribute__((no_sanitize_thread))\n+void __tsan_volatile_read4(void *addr) {\n+  assert(addr == &VolatileGlobal4);\n+  nvolatile_reads++;\n+}\n+__attribute__((no_sanitize_thread))\n+void __tsan_volatile_write4(void *addr) {\n+  assert(addr == &VolatileGlobal4);\n+  nvolatile_writes++;\n+}\n+__attribute__((no_sanitize_thread))\n+void __tsan_volatile_read8(void *addr) {\n+  assert(addr == &VolatileGlobal8);\n+  nvolatile_reads++;\n+}\n+__attribute__((no_sanitize_thread))\n+void __tsan_volatile_write8(void *addr) {\n+  assert(addr == &VolatileGlobal8);\n+  nvolatile_writes++;\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+__attribute__((no_sanitize_thread))\n+static void check() {\n+  assert(nvolatile_reads == 4);\n+  assert(nvolatile_writes == 4);\n+}\n+\n+int main() {\n+  Global4 = 1;\n+\n+  VolatileGlobal4 = 1;\n+  Global4 = VolatileGlobal4;\n+  VolatileGlobal4 = 1 + VolatileGlobal4;\n+\n+  VolatileGlobal8 = 1;\n+  Global4 = (int32_t)VolatileGlobal8;\n+  VolatileGlobal8 = 1 + VolatileGlobal8;\n+\n+  check();\n+  return 0;\n+}\n+\n+// { dg-final { scan-tree-dump-times \"__tsan_volatile_read4 \\\\(&VolatileGlobal4\" 2 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"__tsan_volatile_read8 \\\\(&VolatileGlobal8\" 2 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"__tsan_volatile_write4 \\\\(&VolatileGlobal4\" 2 \"optimized\" } }\n+// { dg-final { scan-tree-dump-times \"__tsan_volatile_write8 \\\\(&VolatileGlobal8\" 2 \"optimized\" } }"}, {"sha": "447acccfafdce75c06f6b5e51b5e2334921c7edd", "filename": "gcc/tsan.c", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Ftsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ab2789ec507a94f1a75a6534bca51c7b39037ce0/gcc%2Ftsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftsan.c?ref=ab2789ec507a94f1a75a6534bca51c7b39037ce0", "patch": "@@ -52,25 +52,29 @@ along with GCC; see the file COPYING3.  If not see\n    void __tsan_read/writeX (void *addr);  */\n \n static tree\n-get_memory_access_decl (bool is_write, unsigned size)\n+get_memory_access_decl (bool is_write, unsigned size, bool volatilep)\n {\n   enum built_in_function fcode;\n+  int pos;\n \n   if (size <= 1)\n-    fcode = is_write ? BUILT_IN_TSAN_WRITE1\n-\t\t     : BUILT_IN_TSAN_READ1;\n+    pos = 0;\n   else if (size <= 3)\n-    fcode = is_write ? BUILT_IN_TSAN_WRITE2\n-\t\t     : BUILT_IN_TSAN_READ2;\n+    pos = 1;\n   else if (size <= 7)\n-    fcode = is_write ? BUILT_IN_TSAN_WRITE4\n-\t\t     : BUILT_IN_TSAN_READ4;\n+    pos = 2;\n   else if (size <= 15)\n-    fcode = is_write ? BUILT_IN_TSAN_WRITE8\n-\t\t     : BUILT_IN_TSAN_READ8;\n+    pos = 3;\n+  else\n+    pos = 4;\n+\n+  if (param_tsan_distinguish_volatile && volatilep)\n+    fcode = is_write ? BUILT_IN_TSAN_VOLATILE_WRITE1\n+\t\t     : BUILT_IN_TSAN_VOLATILE_READ1;\n   else\n-    fcode = is_write ? BUILT_IN_TSAN_WRITE16\n-\t\t     : BUILT_IN_TSAN_READ16;\n+    fcode = is_write ? BUILT_IN_TSAN_WRITE1\n+\t\t     : BUILT_IN_TSAN_READ1;\n+  fcode = (built_in_function)(fcode + pos);\n \n   return builtin_decl_implicit (fcode);\n }\n@@ -204,7 +208,8 @@ instrument_expr (gimple_stmt_iterator gsi, tree expr, bool is_write)\n       g = gimple_build_call (builtin_decl, 2, expr_ptr, size_int (size));\n     }\n   else if (rhs == NULL)\n-    g = gimple_build_call (get_memory_access_decl (is_write, size),\n+    g = gimple_build_call (get_memory_access_decl (is_write, size,\n+\t\t\t\t\t\t   TREE_THIS_VOLATILE (expr)),\n \t\t\t   1, expr_ptr);\n   else\n     {"}]}