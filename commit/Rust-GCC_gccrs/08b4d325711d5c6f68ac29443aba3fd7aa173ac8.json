{"sha": "08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDhiNGQzMjU3MTFkNWM2ZjY4YWMyOTQ0M2FiYTNmZDdhYTE3M2FjOA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-19T21:07:06Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-11-19T21:07:06Z"}, "message": "libstdc++: Avoid calling undefined __gthread_self weak symbol [PR 95989]\n\nSince glibc 2.27 the pthread_self symbol has been defined in libc rather\nthan libpthread. Because we only call pthread_self through a weak alias\nit's possible for statically linked executables to end up without a\ndefinition of pthread_self. This crashes when trying to call an\nundefined weak symbol.\n\nWe can use the __GLIBC_PREREQ version check to detect the version of\nglibc where pthread_self is no longer in libpthread, and call it\ndirectly rather than through the weak reference.\n\nIt would be better to check for pthread_self in libc during configure\ninstead of hardcoding the __GLIBC_PREREQ check. That would be\ncomplicated by the fact that prior to glibc 2.27 libc.a didn't have the\npthread_self symbol, but libc.so.6 did.  The configure checks would need\nto try to link both statically and dynamically, and the result would\ndepend on whether the static libc.a happens to be installed during\nconfigure (which could vary between different systems using the same\nversion of glibc). Doing it properly is left for a future date, as that\nwill be needed anyway after glibc moves all pthread symbols from\nlibpthread to libc. When that happens we should revisit the whole\napproach of using weak symbols for pthread symbols.\n\nFor the purposes of std::this_thread::get_id() we call\npthread_self() directly when using glibc 2.27 or later. Otherwise, if\n__gthread_active_p() is true then we know the libpthread symbol is\navailable so we call that. Otherwise, we are single-threaded and just\nuse ((__gthread_t)1) as the thread ID.\n\nAn undesirable consequence of this change is that code compiled prior to\nthe change might inline the old definition of this_thread::get_id()\nwhich always returns (__gthread_t)1 in a program that isn't linked to\nlibpthread. Code compiled after the change will use pthread_self() and\nso get a real TID. That could result in the main thread having different\nthread::id values in different translation units. This seems acceptable,\nas there are not expected to be many uses of thread::id in programs\nthat aren't linked to libpthread.\n\nAn earlier version of this patch also changed __gthread_self() to use\n__GLIBC_PREREQ(2, 27) and only use the weak symbol for older glibc. Tha\nmight still make sense to do, but isn't needed by libstdc++ now.\n\nlibstdc++-v3/ChangeLog:\n\n\tPR libstdc++/95989\n\t* config/os/gnu-linux/os_defines.h (_GLIBCXX_NATIVE_THREAD_ID):\n\tDefine new macro to get reliable thread ID.\n\t* include/bits/std_thread.h: (this_thread::get_id): Use new\n\tmacro if it's defined.\n\t* testsuite/30_threads/jthread/95989.cc: New test.\n\t* testsuite/30_threads/this_thread/95989.cc: New test.", "tree": {"sha": "d8540f3b2b22cd8430ff28175a91d5f2bbca787f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8540f3b2b22cd8430ff28175a91d5f2bbca787f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfc139e2b190187cb8478f8858cbce6ab9c5d4e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfc139e2b190187cb8478f8858cbce6ab9c5d4e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfc139e2b190187cb8478f8858cbce6ab9c5d4e7"}], "stats": {"total": 141, "additions": 122, "deletions": 19}, "files": [{"sha": "01bfa9ddd4f28419f41e6106249e3cecb8fe76a6", "filename": "libstdc++-v3/config/os/gnu-linux/os_defines.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fos%2Fgnu-linux%2Fos_defines.h?ref=08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "patch": "@@ -49,4 +49,16 @@\n // version dynamically in case it has changed since libstdc++ was configured.\n #define _GLIBCXX_NO_OBSOLETE_ISINF_ISNAN_DYNAMIC __GLIBC_PREREQ(2,23)\n \n+#if __GLIBC_PREREQ(2, 27)\n+// Since glibc 2.27 pthread_self() is usable without linking to libpthread.\n+# define _GLIBCXX_NATIVE_THREAD_ID pthread_self()\n+#else\n+// Before then it was in libc.so.6 but not libc.a, and always returns 0,\n+// which breaks the invariant this_thread::get_id() != thread::id{}.\n+// So only use it if we know the libpthread version is available.\n+// Otherwise use (__gthread_t)1 as the ID of the main (and only) thread.\n+# define _GLIBCXX_NATIVE_THREAD_ID \\\n+  (__gthread_active_p() ? __gthread_self() : (__gthread_t)1)\n+#endif\n+\n #endif"}, {"sha": "24bd5fbd44e8e8f1c6970a88c1242d21398c8694", "filename": "libstdc++-v3/include/bits/std_thread.h", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_thread.h?ref=08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "patch": "@@ -294,26 +294,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     inline thread::id\n     get_id() noexcept\n     {\n-#ifdef _GLIBCXX_HAS_GTHREADS\n-\n-#ifdef __GLIBC__\n-      // For the GNU C library pthread_self() is usable without linking to\n-      // libpthread, but prior to version 2.27 the version in libc returns 0,\n-      // which breaks the invariant this_thread::get_id() != thread::id{}.\n-      //\n-      // We know that pthread_t is a scalar type in the GNU C library,\n-      // so just use (__gthread_t)1 as the ID of the main (and only) thread.\n-      //\n-      // This uses __gthread_active_p not __gnu_cxx::__is_single_threaded\n-      // because we don't want the thread::id of the main thread to change\n-      // if additional threads are created later.\n-      if (!__gthread_active_p())\n-\treturn thread::id((__gthread_t)1);\n-#endif\n-\n-      return thread::id(__gthread_self());\n-#else\n+#ifndef _GLIBCXX_HAS_GTHREADS\n       return thread::id(1);\n+#elif defined _GLIBCXX_NATIVE_THREAD_ID\n+      return thread::id(_GLIBCXX_NATIVE_THREAD_ID);\n+#else\n+      return thread::id(__gthread_self());\n #endif\n     }\n "}, {"sha": "46444b5ccabcaffd468431084c8786743cb601b8", "filename": "libstdc++-v3/testsuite/30_threads/jthread/95989.cc", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F95989.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F95989.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fjthread%2F95989.cc?ref=08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "patch": "@@ -0,0 +1,54 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++2a\" }\n+// { dg-do run { target c++2a } }\n+// { dg-require-gthreads {} }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-additional-options \"-static\" { target static } }\n+\n+#include <thread>\n+\n+// PR libstdc++/95989\n+// Segfault compiling with static libraries and using jthread::request_stop\n+\n+void\n+test01()\n+{\n+  std::jthread t{ [] () {} };\n+}\n+\n+void\n+test02()\n+{\n+  std::jthread t{ [] () {} };\n+  t.request_stop();\n+}\n+\n+void\n+test03()\n+{\n+  std::jthread t{ [] {} };\n+  std::stop_callback cb(t.get_stop_token(), [] () {});\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  test01();\n+}"}, {"sha": "16535af8b7432944726ea8420d77a5d7f443993a", "filename": "libstdc++-v3/testsuite/30_threads/this_thread/95989.cc", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F95989.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/08b4d325711d5c6f68ac29443aba3fd7aa173ac8/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F95989.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fthis_thread%2F95989.cc?ref=08b4d325711d5c6f68ac29443aba3fd7aa173ac8", "patch": "@@ -0,0 +1,51 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-do run { target c++11 } }\n+// { dg-require-gthreads {} }\n+// { dg-additional-options \"-pthread\" { target pthread } }\n+// { dg-additional-options \"-static\" { target static } }\n+\n+#include <thread>\n+#include <testsuite_hooks.h>\n+\n+__attribute__((noinline,noipa))\n+void\n+join(std::thread& t)\n+{\n+  if (!t.joinable())\n+    return;\n+\n+  // Using thread::join() creates a dependency on libpthread symbols\n+  // so that __gthread_active_p is true, and we use pthread_self.\n+  t.join();\n+}\n+\n+void\n+test01()\n+{\n+  std::thread t;\n+  // PR libstdc++/95989\n+  auto id = std::this_thread::get_id();\n+  VERIFY (t.get_id() != id );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+}"}]}