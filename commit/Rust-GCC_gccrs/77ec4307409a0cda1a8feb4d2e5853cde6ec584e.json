{"sha": "77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzdlYzQzMDc0MDlhMGNkYTFhOGZlYjRkMmU1ODUzY2RlNmVjNTg0ZQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-06-02T22:05:45Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2010-06-02T22:05:45Z"}, "message": "mkconfig.sh: Include insn-flags.h and insn-constants.h before defaults.h.\n\n\t* mkconfig.sh: Include insn-flags.h and insn-constants.h before\n\tdefaults.h.\n\t* except.h: Move MUST_USE_SJLJ_EXCEPTIONS and USING_SJLJ_EXCEPTIONS\n\tto defaults.h\n\t* expr.h (BRANCH_COST, MOVE_RATIO, CLEAR_RATIO, SET_RATIO,\n\tDEFAULT_FUNCTION_ARG_PADDING, FUNCTION_ARG_PADDING,\n\tFUNCTION_ARG_BOUNDARY, STACK_SAVEAREA_MODE, STACK_SIZE_MODE,\n\tSTACK_CHECK_BUILTIN, STACK_CHECK_STATIC_BUILTIN,\n\tSTACK_CHECK_PROBE_INTERVAL_EXP, STACK_CHECK_MOVING_SP,\n\tSTACK_OLD_CHECK_PROTECT, STACK_CHECK_PROTECT,\n\tSTACK_CHECK_MAX_FRAME_SIZE, STACK_CHECK_FIXED_FRAME_SIZE,\n\tSTACK_CHECK_MAX_VAR_SIZE): Move target macro defaults to defaults.h.\n\t* defaults.h: Updated for above mentioned changes.\n\nFrom-SVN: r160195", "tree": {"sha": "c1c77f65435de36762d2a4bc8d60a37fd1060319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c1c77f65435de36762d2a4bc8d60a37fd1060319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/comments", "author": null, "committer": null, "parents": [{"sha": "3f7c0b1bc39daf8a1ba4c3d306ab8832ff967a93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f7c0b1bc39daf8a1ba4c3d306ab8832ff967a93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f7c0b1bc39daf8a1ba4c3d306ab8832ff967a93"}], "stats": {"total": 412, "additions": 231, "deletions": 181}, "files": [{"sha": "fbb1c2acab72f8d97e1e2d2f15dfb27b4e74cace", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "patch": "@@ -1,3 +1,19 @@\n+2010-06-02  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* mkconfig.sh: Include insn-flags.h and insn-constants.h before\n+\tdefaults.h.\n+\t* except.h: Move MUST_USE_SJLJ_EXCEPTIONS and USING_SJLJ_EXCEPTIONS\n+\tto defaults.h\n+\t* expr.h (BRANCH_COST, MOVE_RATIO, CLEAR_RATIO, SET_RATIO,\n+\tDEFAULT_FUNCTION_ARG_PADDING, FUNCTION_ARG_PADDING,\n+\tFUNCTION_ARG_BOUNDARY, STACK_SAVEAREA_MODE, STACK_SIZE_MODE,\n+\tSTACK_CHECK_BUILTIN, STACK_CHECK_STATIC_BUILTIN,\n+\tSTACK_CHECK_PROBE_INTERVAL_EXP, STACK_CHECK_MOVING_SP,\n+\tSTACK_OLD_CHECK_PROTECT, STACK_CHECK_PROTECT,\n+\tSTACK_CHECK_MAX_FRAME_SIZE, STACK_CHECK_FIXED_FRAME_SIZE,\n+\tSTACK_CHECK_MAX_VAR_SIZE): Move target macro defaults to defaults.h.\n+\t* defaults.h: Updated for above mentioned changes.\n+\n 2010-06-02  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* c-common.c: Remove header include of tm_p.h."}, {"sha": "97fdcdd7ce42232f096472456a9d7709a3d1c27c", "filename": "gcc/defaults.h", "status": "modified", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "patch": "@@ -1165,4 +1165,205 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define CONSTANT_ADDRESS_P(X)   (CONSTANT_P (X) && GET_CODE (X) != CONST_DOUBLE)\n #endif\n \n+\n+#ifdef GCC_INSN_FLAGS_H\n+/* Dependent default target macro definitions\n+\n+   This section of defaults.h defines target macros that depend on generated\n+   headers.  This is a bit awkward:  We want to put all default definitions\n+   for target macros in defaults.h, but some of the defaults depend on the\n+   HAVE_* flags defines of insn-flags.h.  But insn-flags.h is not always\n+   included by files that do include defaults.h.\n+\n+   Fortunately, the default macro definitions that depend on the HAVE_*\n+   macros are also the ones that will only be used inside GCC itself, i.e.\n+   not in the gen* programs or in target objects like libgcc.\n+\n+   Obviously, it would be best to keep this section of defaults.h as small\n+   as possible, by converting the macros defined below to target hooks or\n+   functions.\n+*/\n+\n+/* Just because the user configured --with-sjlj-exceptions=no doesn't\n+   mean that we can use call frame exceptions.  Detect that the target\n+   has appropriate support.  */\n+\n+#ifndef MUST_USE_SJLJ_EXCEPTIONS\n+# if defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n+       && (defined (TARGET_UNWIND_INFO)\t\t\t\\\n+\t   || (DWARF2_UNWIND_INFO\t\t\t\\\n+\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n+\t\t   || defined (HAVE_eh_return))))\n+#  define MUST_USE_SJLJ_EXCEPTIONS\t0\n+# else\n+#  define MUST_USE_SJLJ_EXCEPTIONS\t1\n+# endif\n+#endif\n+\n+#ifdef CONFIG_SJLJ_EXCEPTIONS\n+# if CONFIG_SJLJ_EXCEPTIONS == 1\n+#  define USING_SJLJ_EXCEPTIONS\t\t1\n+# endif\n+# if CONFIG_SJLJ_EXCEPTIONS == 0\n+#  define USING_SJLJ_EXCEPTIONS\t\t0\n+#  if !defined(EH_RETURN_DATA_REGNO)\n+    #error \"EH_RETURN_DATA_REGNO required\"\n+#  endif\n+#  if ! (defined(TARGET_UNWIND_INFO) || DWARF2_UNWIND_INFO)\n+    #error \"{DWARF2,TARGET}_UNWIND_INFO required\"\n+#  endif\n+#  if !defined(TARGET_UNWIND_INFO) \\\n+\t&& !(defined(EH_RETURN_HANDLER_RTX) || defined(HAVE_eh_return))\n+    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n+#  endif\n+/* Usually the above error checks will have already triggered an\n+   error, but backends may set MUST_USE_SJLJ_EXCEPTIONS for their own\n+   reasons.  */\n+#  if MUST_USE_SJLJ_EXCEPTIONS\n+    #error \"Must use SJLJ exceptions but configured not to\"\n+#  endif\n+# endif\n+#else\n+# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n+#endif\n+\n+/* The default branch cost is 1.  */\n+#ifndef BRANCH_COST\n+#define BRANCH_COST(speed_p, predictable_p) 1\n+#endif\n+\n+/* If a memory-to-memory move would take MOVE_RATIO or more simple\n+   move-instruction sequences, we will do a movmem or libcall instead.  */\n+\n+#ifndef MOVE_RATIO\n+#if defined (HAVE_movmemqi) || defined (HAVE_movmemhi) || defined (HAVE_movmemsi) || defined (HAVE_movmemdi) || defined (HAVE_movmemti)\n+#define MOVE_RATIO(speed) 2\n+#else\n+/* If we are optimizing for space (-Os), cut down the default move ratio.  */\n+#define MOVE_RATIO(speed) ((speed) ? 15 : 3)\n+#endif\n+#endif\n+\n+/* If a clear memory operation would take CLEAR_RATIO or more simple\n+   move-instruction sequences, we will do a setmem or libcall instead.  */\n+\n+#ifndef CLEAR_RATIO\n+#if defined (HAVE_setmemqi) || defined (HAVE_setmemhi) || defined (HAVE_setmemsi) || defined (HAVE_setmemdi) || defined (HAVE_setmemti)\n+#define CLEAR_RATIO(speed) 2\n+#else\n+/* If we are optimizing for space, cut down the default clear ratio.  */\n+#define CLEAR_RATIO(speed) ((speed) ? 15 :3)\n+#endif\n+#endif\n+\n+/* If a memory set (to value other than zero) operation would take\n+   SET_RATIO or more simple move-instruction sequences, we will do a movmem\n+   or libcall instead.  */\n+#ifndef SET_RATIO\n+#define SET_RATIO(speed) MOVE_RATIO(speed)\n+#endif\n+\n+/* Supply a default definition for FUNCTION_ARG_PADDING:\n+   usually pad upward, but pad short args downward on\n+   big-endian machines.  */\n+\n+#define DEFAULT_FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\\\n+  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n+   ? upward\t\t\t\t\t\t\t\t\\\n+   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n+       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n+\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n+       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n+      ? downward : upward))\n+\n+#ifndef FUNCTION_ARG_PADDING\n+#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\\\n+  DEFAULT_FUNCTION_ARG_PADDING ((MODE), (TYPE))\n+#endif\n+\n+/* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n+   FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n+   alignment.  */\n+\n+#ifndef FUNCTION_ARG_BOUNDARY\n+#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n+#endif\n+\n+/* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n+   Normally move_insn, so Pmode stack pointer.  */\n+\n+#ifndef STACK_SAVEAREA_MODE\n+#define STACK_SAVEAREA_MODE(LEVEL) Pmode\n+#endif\n+\n+/* Supply a default definition of STACK_SIZE_MODE for\n+   allocate_dynamic_stack_space.  Normally PLUS/MINUS, so word_mode.  */\n+\n+#ifndef STACK_SIZE_MODE\n+#define STACK_SIZE_MODE word_mode\n+#endif\n+\n+/* Provide default values for the macros controlling stack checking.  */\n+\n+/* The default is neither full builtin stack checking...  */\n+#ifndef STACK_CHECK_BUILTIN\n+#define STACK_CHECK_BUILTIN 0\n+#endif\n+\n+/* ...nor static builtin stack checking.  */\n+#ifndef STACK_CHECK_STATIC_BUILTIN\n+#define STACK_CHECK_STATIC_BUILTIN 0\n+#endif\n+\n+/* The default interval is one page (4096 bytes).  */\n+#ifndef STACK_CHECK_PROBE_INTERVAL_EXP\n+#define STACK_CHECK_PROBE_INTERVAL_EXP 12\n+#endif\n+\n+/* The default is not to move the stack pointer.  */\n+#ifndef STACK_CHECK_MOVING_SP\n+#define STACK_CHECK_MOVING_SP 0\n+#endif\n+\n+/* This is a kludge to try to capture the discrepancy between the old\n+   mechanism (generic stack checking) and the new mechanism (static\n+   builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped\n+   for the latter because part of the protection area is effectively\n+   included in STACK_CHECK_MAX_FRAME_SIZE for the former.  */\n+#ifdef STACK_CHECK_PROTECT\n+#define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT\n+#else\n+#define STACK_OLD_CHECK_PROTECT \\\n+ (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)\n+#endif\n+\n+/* Minimum amount of stack required to recover from an anticipated stack\n+   overflow detection.  The default value conveys an estimate of the amount\n+   of stack required to propagate an exception.  */\n+#ifndef STACK_CHECK_PROTECT\n+#define STACK_CHECK_PROTECT \\\n+ (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)\n+#endif\n+\n+/* Make the maximum frame size be the largest we can and still only need\n+   one probe per function.  */\n+#ifndef STACK_CHECK_MAX_FRAME_SIZE\n+#define STACK_CHECK_MAX_FRAME_SIZE \\\n+  ((1 << STACK_CHECK_PROBE_INTERVAL_EXP) - UNITS_PER_WORD)\n+#endif\n+\n+/* This is arbitrary, but should be large enough everywhere.  */\n+#ifndef STACK_CHECK_FIXED_FRAME_SIZE\n+#define STACK_CHECK_FIXED_FRAME_SIZE (4 * UNITS_PER_WORD)\n+#endif\n+\n+/* Provide a reasonable default for the maximum size of an object to\n+   allocate in the fixed frame.  We may need to be able to make this\n+   controllable by the user at some point.  */\n+#ifndef STACK_CHECK_MAX_VAR_SIZE\n+#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n+#endif\n+\n+#endif /* GCC_INSN_FLAGS_H  */\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "068a444c9b1425946768cced468672071f5bd8d0", "filename": "gcc/except.h", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "patch": "@@ -295,50 +295,6 @@ extern eh_landing_pad get_eh_landing_pad_from_rtx (const_rtx);\n    FUNCTION_DECL for `std::terminate'.  */\n extern tree (*lang_protect_cleanup_actions) (void);\n \n-\n-/* Just because the user configured --with-sjlj-exceptions=no doesn't\n-   mean that we can use call frame exceptions.  Detect that the target\n-   has appropriate support.  */\n-\n-#ifndef MUST_USE_SJLJ_EXCEPTIONS\n-# if defined (EH_RETURN_DATA_REGNO)\t\t\t\\\n-       && (defined (TARGET_UNWIND_INFO)\t\t\t\\\n-\t   || (DWARF2_UNWIND_INFO\t\t\t\\\n-\t       && (defined (EH_RETURN_HANDLER_RTX)\t\\\n-\t\t   || defined (HAVE_eh_return))))\n-#  define MUST_USE_SJLJ_EXCEPTIONS\t0\n-# else\n-#  define MUST_USE_SJLJ_EXCEPTIONS\t1\n-# endif\n-#endif\n-\n-#ifdef CONFIG_SJLJ_EXCEPTIONS\n-# if CONFIG_SJLJ_EXCEPTIONS == 1\n-#  define USING_SJLJ_EXCEPTIONS\t\t1\n-# endif\n-# if CONFIG_SJLJ_EXCEPTIONS == 0\n-#  define USING_SJLJ_EXCEPTIONS\t\t0\n-#  if !defined(EH_RETURN_DATA_REGNO)\n-    #error \"EH_RETURN_DATA_REGNO required\"\n-#  endif\n-#  if ! (defined(TARGET_UNWIND_INFO) || DWARF2_UNWIND_INFO)\n-    #error \"{DWARF2,TARGET}_UNWIND_INFO required\"\n-#  endif\n-#  if !defined(TARGET_UNWIND_INFO) \\\n-\t&& !(defined(EH_RETURN_HANDLER_RTX) || defined(HAVE_eh_return))\n-    #error \"EH_RETURN_HANDLER_RTX or eh_return required\"\n-#  endif\n-/* Usually the above error checks will have already triggered an\n-   error, but backends may set MUST_USE_SJLJ_EXCEPTIONS for their own\n-   reasons.  */\n-#  if MUST_USE_SJLJ_EXCEPTIONS\n-    #error \"Must use SJLJ exceptions but configured not to\"\n-#  endif\n-# endif\n-#else\n-# define USING_SJLJ_EXCEPTIONS\t\tMUST_USE_SJLJ_EXCEPTIONS\n-#endif\n-\n struct GTY(()) throw_stmt_node {\n   gimple stmt;\n   int lp_nr;"}, {"sha": "6ee964a39f4176d3a2eace725b8f1decb81641f1", "filename": "gcc/expr.h", "status": "modified", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "patch": "@@ -34,11 +34,6 @@ along with GCC; see the file COPYING3.  If not see\n /* For GET_MODE_BITSIZE, word_mode */\n #include \"machmode.h\"\n \n-/* The default branch cost is 1.  */\n-#ifndef BRANCH_COST\n-#define BRANCH_COST(speed_p, predictable_p) 1\n-#endif\n-\n /* This is the 4th arg to `expand_expr'.\n    EXPAND_STACK_PARM means we are possibly expanding a call param onto\n    the stack.\n@@ -61,37 +56,6 @@ enum expand_modifier {EXPAND_NORMAL = 0, EXPAND_STACK_PARM, EXPAND_SUM,\n    more information.  */\n #define OK_DEFER_POP (inhibit_defer_pop -= 1)\n \f\n-/* If a memory-to-memory move would take MOVE_RATIO or more simple\n-   move-instruction sequences, we will do a movmem or libcall instead.  */\n-\n-#ifndef MOVE_RATIO\n-#if defined (HAVE_movmemqi) || defined (HAVE_movmemhi) || defined (HAVE_movmemsi) || defined (HAVE_movmemdi) || defined (HAVE_movmemti)\n-#define MOVE_RATIO(speed) 2\n-#else\n-/* If we are optimizing for space (-Os), cut down the default move ratio.  */\n-#define MOVE_RATIO(speed) ((speed) ? 15 : 3)\n-#endif\n-#endif\n-\n-/* If a clear memory operation would take CLEAR_RATIO or more simple\n-   move-instruction sequences, we will do a setmem or libcall instead.  */\n-\n-#ifndef CLEAR_RATIO\n-#if defined (HAVE_setmemqi) || defined (HAVE_setmemhi) || defined (HAVE_setmemsi) || defined (HAVE_setmemdi) || defined (HAVE_setmemti)\n-#define CLEAR_RATIO(speed) 2\n-#else\n-/* If we are optimizing for space, cut down the default clear ratio.  */\n-#define CLEAR_RATIO(speed) ((speed) ? 15 :3)\n-#endif\n-#endif\n-\n-/* If a memory set (to value other than zero) operation would take\n-   SET_RATIO or more simple move-instruction sequences, we will do a movmem\n-   or libcall instead.  */\n-#ifndef SET_RATIO\n-#define SET_RATIO(speed) MOVE_RATIO(speed)\n-#endif\n-\f\n enum direction {none, upward, downward};\n \n /* Structure to record the size of a sequence of arguments\n@@ -166,106 +130,6 @@ do {\t\t\t\t\t\t\t\t\\\n ((SIZE).var == 0 ? GEN_INT ((SIZE).constant)\t\t\t\\\n  : expand_normal (ARGS_SIZE_TREE (SIZE)))\n \n-/* Supply a default definition for FUNCTION_ARG_PADDING:\n-   usually pad upward, but pad short args downward on\n-   big-endian machines.  */\n-\n-#define DEFAULT_FUNCTION_ARG_PADDING(MODE, TYPE)\t\t\t\\\n-  (! BYTES_BIG_ENDIAN\t\t\t\t\t\t\t\\\n-   ? upward\t\t\t\t\t\t\t\t\\\n-   : (((MODE) == BLKmode\t\t\t\t\t\t\\\n-       ? ((TYPE) && TREE_CODE (TYPE_SIZE (TYPE)) == INTEGER_CST\t\t\\\n-\t  && int_size_in_bytes (TYPE) < (PARM_BOUNDARY / BITS_PER_UNIT)) \\\n-       : GET_MODE_BITSIZE (MODE) < PARM_BOUNDARY)\t\t\t\\\n-      ? downward : upward))\n-\n-#ifndef FUNCTION_ARG_PADDING\n-#define FUNCTION_ARG_PADDING(MODE, TYPE)\t\\\n-  DEFAULT_FUNCTION_ARG_PADDING ((MODE), (TYPE))\n-#endif\n-\n-/* Supply a default definition for FUNCTION_ARG_BOUNDARY.  Normally, we let\n-   FUNCTION_ARG_PADDING, which also pads the length, handle any needed\n-   alignment.  */\n-\n-#ifndef FUNCTION_ARG_BOUNDARY\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\tPARM_BOUNDARY\n-#endif\n-\n-/* Supply a default definition of STACK_SAVEAREA_MODE for emit_stack_save.\n-   Normally move_insn, so Pmode stack pointer.  */\n-\n-#ifndef STACK_SAVEAREA_MODE\n-#define STACK_SAVEAREA_MODE(LEVEL) Pmode\n-#endif\n-\n-/* Supply a default definition of STACK_SIZE_MODE for\n-   allocate_dynamic_stack_space.  Normally PLUS/MINUS, so word_mode.  */\n-\n-#ifndef STACK_SIZE_MODE\n-#define STACK_SIZE_MODE word_mode\n-#endif\n-\n-/* Provide default values for the macros controlling stack checking.  */\n-\n-/* The default is neither full builtin stack checking...  */\n-#ifndef STACK_CHECK_BUILTIN\n-#define STACK_CHECK_BUILTIN 0\n-#endif\n-\n-/* ...nor static builtin stack checking.  */\n-#ifndef STACK_CHECK_STATIC_BUILTIN\n-#define STACK_CHECK_STATIC_BUILTIN 0\n-#endif\n-\n-/* The default interval is one page (4096 bytes).  */\n-#ifndef STACK_CHECK_PROBE_INTERVAL_EXP\n-#define STACK_CHECK_PROBE_INTERVAL_EXP 12\n-#endif\n-\n-/* The default is not to move the stack pointer.  */\n-#ifndef STACK_CHECK_MOVING_SP\n-#define STACK_CHECK_MOVING_SP 0\n-#endif\n-\n-/* This is a kludge to try to capture the discrepancy between the old\n-   mechanism (generic stack checking) and the new mechanism (static\n-   builtin stack checking).  STACK_CHECK_PROTECT needs to be bumped\n-   for the latter because part of the protection area is effectively\n-   included in STACK_CHECK_MAX_FRAME_SIZE for the former.  */\n-#ifdef STACK_CHECK_PROTECT\n-#define STACK_OLD_CHECK_PROTECT STACK_CHECK_PROTECT\n-#else\n-#define STACK_OLD_CHECK_PROTECT \\\n- (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 8 * 1024)\n-#endif\n-\n-/* Minimum amount of stack required to recover from an anticipated stack\n-   overflow detection.  The default value conveys an estimate of the amount\n-   of stack required to propagate an exception.  */\n-#ifndef STACK_CHECK_PROTECT\n-#define STACK_CHECK_PROTECT \\\n- (USING_SJLJ_EXCEPTIONS ? 75 * UNITS_PER_WORD : 12 * 1024)\n-#endif\n-\n-/* Make the maximum frame size be the largest we can and still only need\n-   one probe per function.  */\n-#ifndef STACK_CHECK_MAX_FRAME_SIZE\n-#define STACK_CHECK_MAX_FRAME_SIZE \\\n-  ((1 << STACK_CHECK_PROBE_INTERVAL_EXP) - UNITS_PER_WORD)\n-#endif\n-\n-/* This is arbitrary, but should be large enough everywhere.  */\n-#ifndef STACK_CHECK_FIXED_FRAME_SIZE\n-#define STACK_CHECK_FIXED_FRAME_SIZE (4 * UNITS_PER_WORD)\n-#endif\n-\n-/* Provide a reasonable default for the maximum size of an object to\n-   allocate in the fixed frame.  We may need to be able to make this\n-   controllable by the user at some point.  */\n-#ifndef STACK_CHECK_MAX_VAR_SIZE\n-#define STACK_CHECK_MAX_VAR_SIZE (STACK_CHECK_MAX_FRAME_SIZE / 100)\n-#endif\n \f\n /* This structure is used to pass around information about exploded\n    unary, binary and trinary expressions between expand_expr_real_1 and"}, {"sha": "c9d35cce2a629341c7003adfedc811e2afe726c0", "filename": "gcc/mkconfig.sh", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fmkconfig.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/77ec4307409a0cda1a8feb4d2e5853cde6ec584e/gcc%2Fmkconfig.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmkconfig.sh?ref=77ec4307409a0cda1a8feb4d2e5853cde6ec584e", "patch": "@@ -63,6 +63,10 @@ done\n \n # The first entry in HEADERS may be auto-FOO.h ;\n # it wants to be included even when not -DIN_GCC.\n+# Postpone including defaults.h until after the insn-*\n+# headers, so that the HAVE_* flags are available\n+# when defaults.h gets included.\n+postpone_defaults_h=\"no\"\n if [ -n \"$HEADERS\" ]; then\n     set $HEADERS\n     case \"$1\" in auto-* )\n@@ -73,7 +77,11 @@ if [ -n \"$HEADERS\" ]; then\n     if [ $# -ge 1 ]; then\n \techo '#ifdef IN_GCC' >> ${output}T\n \tfor file in \"$@\"; do\n-\t    echo \"# include \\\"$file\\\"\" >> ${output}T\n+\t    if test x\"$file\" = x\"defaults.h\"; then\n+\t\tpostpone_defaults_h=\"yes\"\n+\t    else\n+\t\techo \"# include \\\"$file\\\"\" >> ${output}T\n+\t    fi\n \tdone\n \techo '#endif' >> ${output}T\n     fi\n@@ -94,6 +102,11 @@ EOF\n     ;;\n esac\n \n+# If we postponed including defaults.h, add the #include now.\n+if test x\"$postpone_defaults_h\" = x\"yes\"; then\n+    echo \"# include \\\"defaults.h\\\"\" >> ${output}T\n+fi\n+\n # Add multiple inclusion protection guard, part two.\n echo \"#endif /* ${header_guard} */\" >> ${output}T\n "}]}