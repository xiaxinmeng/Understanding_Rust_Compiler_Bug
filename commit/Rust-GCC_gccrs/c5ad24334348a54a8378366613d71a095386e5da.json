{"sha": "c5ad24334348a54a8378366613d71a095386e5da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhZDI0MzM0MzQ4YTU0YTgzNzgzNjY2MTNkNzFhMDk1Mzg2ZTVkYQ==", "commit": {"author": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-03-28T11:37:22Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2017-03-28T11:37:22Z"}, "message": "Handle PHI nodes w/o a argument (PR ipa/80205).\n\n2017-03-28  Martin Liska  <mliska@suse.cz>\n\n\tPR ipa/80205\n\t* g++.dg/ipa/pr80205.C: New test.\n2017-03-28  Richard Biener  <rguenther@suse.de>\n\n\tPR ipa/80205\n\t* tree-inline.c (copy_phis_for_bb): Do not create PHI node\n\twithout arguments, generate default definition of a SSA name.\n\nFrom-SVN: r246530", "tree": {"sha": "ba4975babde9f783968283e700435904bbaaf893", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba4975babde9f783968283e700435904bbaaf893"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5ad24334348a54a8378366613d71a095386e5da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ad24334348a54a8378366613d71a095386e5da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ad24334348a54a8378366613d71a095386e5da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ad24334348a54a8378366613d71a095386e5da/comments", "author": null, "committer": null, "parents": [{"sha": "17722fb9e6f8c79c7016c68ea359d6fe2dd5aadd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17722fb9e6f8c79c7016c68ea359d6fe2dd5aadd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17722fb9e6f8c79c7016c68ea359d6fe2dd5aadd"}], "stats": {"total": 137, "additions": 96, "deletions": 41}, "files": [{"sha": "f15a8a882bb0b93cb6b3495a8345392eba0126ce", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ad24334348a54a8378366613d71a095386e5da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ad24334348a54a8378366613d71a095386e5da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5ad24334348a54a8378366613d71a095386e5da", "patch": "@@ -1,3 +1,9 @@\n+2017-03-28  Richard Biener  <rguenther@suse.de>\n+\n+\tPR ipa/80205\n+\t* tree-inline.c (copy_phis_for_bb): Do not create PHI node\n+\twithout arguments, generate default definition of a SSA name.\n+\n 2017-03-28  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/80222"}, {"sha": "b3a54711f2405d35115f8c12ce564c1d572bed5f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c5ad24334348a54a8378366613d71a095386e5da", "patch": "@@ -1,3 +1,8 @@\n+2017-03-28  Martin Liska  <mliska@suse.cz>\n+\n+\tPR ipa/80205\n+\t* g++.dg/ipa/pr80205.C: New test.\n+\n 2017-03-28  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.c-torture/execute/pr79121.c:Use __{U}INT32_TYPE__ for targets"}, {"sha": "460bdcb02ca5c515c546a517e83086065254cd70", "filename": "gcc/testsuite/g++.dg/ipa/pr80205.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr80205.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr80205.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr80205.C?ref=c5ad24334348a54a8378366613d71a095386e5da", "patch": "@@ -0,0 +1,34 @@\n+// PR ipa/80205\n+// { dg-options \"-fnon-call-exceptions --param early-inlining-insns=100 -O2\" }\n+\n+class a\n+{\n+public:\n+  virtual ~a ();\n+};\n+class b\n+{\n+public:\n+  template <typename c> b (c);\n+  ~b () { delete d; }\n+  void\n+  operator= (b e)\n+  {\n+    b (e).f (*this);\n+  }\n+  void\n+  f (b &e)\n+  {\n+    a g;\n+    d = e.d;\n+    e.d = &g;\n+  }\n+  a *d;\n+};\n+void\n+h ()\n+{\n+  b i = int();\n+  void j ();\n+  i = j;\n+}"}, {"sha": "09e80e6a5bcb7d4889b44b86d810007d1583b479", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 51, "deletions": 41, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ad24334348a54a8378366613d71a095386e5da/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=c5ad24334348a54a8378366613d71a095386e5da", "patch": "@@ -2344,50 +2344,60 @@ copy_phis_for_bb (basic_block bb, copy_body_data *id)\n       if (!virtual_operand_p (res))\n \t{\n \t  walk_tree (&new_res, copy_tree_body_r, id, NULL);\n-\t  new_phi = create_phi_node (new_res, new_bb);\n-\t  FOR_EACH_EDGE (new_edge, ei, new_bb->preds)\n+\t  if (EDGE_COUNT (new_bb->preds) == 0)\n \t    {\n-\t      edge old_edge = find_edge ((basic_block) new_edge->src->aux, bb);\n-\t      tree arg;\n-\t      tree new_arg;\n-\t      edge_iterator ei2;\n-\t      location_t locus;\n-\n-\t      /* When doing partial cloning, we allow PHIs on the entry block\n-\t\t as long as all the arguments are the same.  Find any input\n-\t\t edge to see argument to copy.  */\n-\t      if (!old_edge)\n-\t\tFOR_EACH_EDGE (old_edge, ei2, bb->preds)\n-\t\t  if (!old_edge->src->aux)\n-\t\t    break;\n-\n-\t      arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n-\t      new_arg = arg;\n-\t      walk_tree (&new_arg, copy_tree_body_r, id, NULL);\n-\t      gcc_assert (new_arg);\n-\t      /* With return slot optimization we can end up with\n-\t         non-gimple (foo *)&this->m, fix that here.  */\n-\t      if (TREE_CODE (new_arg) != SSA_NAME\n-\t\t  && TREE_CODE (new_arg) != FUNCTION_DECL\n-\t\t  && !is_gimple_val (new_arg))\n-\t\t{\n-\t\t  gimple_seq stmts = NULL;\n-\t\t  new_arg = force_gimple_operand (new_arg, &stmts, true, NULL);\n-\t\t  gsi_insert_seq_on_edge (new_edge, stmts);\n-\t\t  inserted = true;\n-\t\t}\n-\t      locus = gimple_phi_arg_location_from_edge (phi, old_edge);\n-\t      if (LOCATION_BLOCK (locus))\n+\t      /* Technically we'd want a SSA_DEFAULT_DEF here... */\n+\t      SSA_NAME_DEF_STMT (new_res) = gimple_build_nop ();\n+\t    }\n+\t  else\n+\t    {\n+\t      new_phi = create_phi_node (new_res, new_bb);\n+\t      FOR_EACH_EDGE (new_edge, ei, new_bb->preds)\n \t\t{\n-\t\t  tree *n;\n-\t\t  n = id->decl_map->get (LOCATION_BLOCK (locus));\n-\t\t  gcc_assert (n);\n-\t\t  locus = set_block (locus, *n);\n-\t\t}\n-\t      else\n-\t\tlocus = LOCATION_LOCUS (locus);\n+\t\t  edge old_edge = find_edge ((basic_block) new_edge->src->aux,\n+\t\t\t\t\t     bb);\n+\t\t  tree arg;\n+\t\t  tree new_arg;\n+\t\t  edge_iterator ei2;\n+\t\t  location_t locus;\n+\n+\t\t  /* When doing partial cloning, we allow PHIs on the entry\n+\t\t     block as long as all the arguments are the same.\n+\t\t     Find any input edge to see argument to copy.  */\n+\t\t  if (!old_edge)\n+\t\t    FOR_EACH_EDGE (old_edge, ei2, bb->preds)\n+\t\t      if (!old_edge->src->aux)\n+\t\t\tbreak;\n+\n+\t\t  arg = PHI_ARG_DEF_FROM_EDGE (phi, old_edge);\n+\t\t  new_arg = arg;\n+\t\t  walk_tree (&new_arg, copy_tree_body_r, id, NULL);\n+\t\t  gcc_assert (new_arg);\n+\t\t  /* With return slot optimization we can end up with\n+\t\t     non-gimple (foo *)&this->m, fix that here.  */\n+\t\t  if (TREE_CODE (new_arg) != SSA_NAME\n+\t\t      && TREE_CODE (new_arg) != FUNCTION_DECL\n+\t\t      && !is_gimple_val (new_arg))\n+\t\t    {\n+\t\t      gimple_seq stmts = NULL;\n+\t\t      new_arg = force_gimple_operand (new_arg, &stmts, true,\n+\t\t\t\t\t\t      NULL);\n+\t\t      gsi_insert_seq_on_edge (new_edge, stmts);\n+\t\t      inserted = true;\n+\t\t    }\n+\t\t  locus = gimple_phi_arg_location_from_edge (phi, old_edge);\n+\t\t  if (LOCATION_BLOCK (locus))\n+\t\t    {\n+\t\t      tree *n;\n+\t\t      n = id->decl_map->get (LOCATION_BLOCK (locus));\n+\t\t      gcc_assert (n);\n+\t\t      locus = set_block (locus, *n);\n+\t\t    }\n+\t\t  else\n+\t\t    locus = LOCATION_LOCUS (locus);\n \n-\t      add_phi_arg (new_phi, new_arg, new_edge, locus);\n+\t\t  add_phi_arg (new_phi, new_arg, new_edge, locus);\n+\t\t}\n \t    }\n \t}\n     }"}]}