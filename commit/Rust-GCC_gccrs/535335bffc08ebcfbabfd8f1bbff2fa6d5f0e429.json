{"sha": "535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTM1MzM1YmZmYzA4ZWJjZmJhYmZkOGYxYmJmZjJmYTZkNWYwZTQyOQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2010-07-14T17:01:03Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2010-07-14T17:01:03Z"}, "message": "init.c (sort_mem_initializers): Rename \"field_type\" to \"ctx\".\n\n\t* init.c (sort_mem_initializers): Rename \"field_type\" to \"ctx\".\n\t(build_field_list): Cache field type.\n\nFrom-SVN: r162188", "tree": {"sha": "7e0d15d22f642156e721ae21c33d2dc89e38117a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e0d15d22f642156e721ae21c33d2dc89e38117a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "html_url": "https://github.com/Rust-GCC/gccrs/commit/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "57ece2583335d663e2787df4f6fe3804ec921ea9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ece2583335d663e2787df4f6fe3804ec921ea9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ece2583335d663e2787df4f6fe3804ec921ea9"}], "stats": {"total": 45, "additions": 25, "deletions": 20}, "files": [{"sha": "ea3e9b51d1fd7ac98cd5835257282b145b6555c1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "patch": "@@ -1,5 +1,8 @@\n 2010-07-14  Jason Merrill  <jason@redhat.com>\n \n+\t* init.c (sort_mem_initializers): Rename \"field_type\" to \"ctx\".\n+\t(build_field_list): Cache field type.\n+\n \tImplement C++0x unrestricted unions (N2544)\n \t* class.c (check_field_decl): Loosen union handling in C++0x.\n \t* method.c (walk_field_subobs): Split out from..."}, {"sha": "98a45cd41b2e87e63e4fb533a4353073c4a2ff09", "filename": "gcc/cp/init.c", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=535335bffc08ebcfbabfd8f1bbff2fa6d5f0e429", "patch": "@@ -564,25 +564,27 @@ build_field_list (tree t, tree list, int *uses_unions_p)\n \n   for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n     {\n+      tree fieldtype;\n+\n       /* Skip CONST_DECLs for enumeration constants and so forth.  */\n       if (TREE_CODE (fields) != FIELD_DECL || DECL_ARTIFICIAL (fields))\n \tcontinue;\n \n+      fieldtype = TREE_TYPE (fields);\n       /* Keep track of whether or not any fields are unions.  */\n-      if (TREE_CODE (TREE_TYPE (fields)) == UNION_TYPE)\n+      if (TREE_CODE (fieldtype) == UNION_TYPE)\n \t*uses_unions_p = 1;\n \n       /* For an anonymous struct or union, we must recursively\n \t consider the fields of the anonymous type.  They can be\n \t directly initialized from the constructor.  */\n-      if (ANON_AGGR_TYPE_P (TREE_TYPE (fields)))\n+      if (ANON_AGGR_TYPE_P (fieldtype))\n \t{\n \t  /* Add this field itself.  Synthesized copy constructors\n \t     initialize the entire aggregate.  */\n \t  list = tree_cons (fields, NULL_TREE, list);\n \t  /* And now add the fields in the anonymous aggregate.  */\n-\t  list = build_field_list (TREE_TYPE (fields), list,\n-\t\t\t\t   uses_unions_p);\n+\t  list = build_field_list (fieldtype, list, uses_unions_p);\n \t}\n       /* Add this field.  */\n       else if (DECL_NAME (fields))\n@@ -718,7 +720,7 @@ sort_mem_initializers (tree t, tree mem_inits)\n       for (p = &sorted_inits; *p; )\n \t{\n \t  tree field;\n-\t  tree field_type;\n+\t  tree ctx;\n \t  int done;\n \n \t  init = *p;\n@@ -736,13 +738,13 @@ sort_mem_initializers (tree t, tree mem_inits)\n \n \t  /* See if this field is a member of a union, or a member of a\n \t     structure contained in a union, etc.  */\n-\t  for (field_type = DECL_CONTEXT (field);\n-\t       !same_type_p (field_type, t);\n-\t       field_type = TYPE_CONTEXT (field_type))\n-\t    if (TREE_CODE (field_type) == UNION_TYPE)\n+\t  for (ctx = DECL_CONTEXT (field);\n+\t       !same_type_p (ctx, t);\n+\t       ctx = TYPE_CONTEXT (ctx))\n+\t    if (TREE_CODE (ctx) == UNION_TYPE)\n \t      break;\n \t  /* If this field is not a member of a union, skip it.  */\n-\t  if (TREE_CODE (field_type) != UNION_TYPE)\n+\t  if (TREE_CODE (ctx) != UNION_TYPE)\n \t    goto next;\n \n \t  /* If this union member has no explicit initializer, splice\n@@ -766,37 +768,37 @@ sort_mem_initializers (tree t, tree mem_inits)\n \t       union { struct { int i; int j; }; };\n \n \t     initializing both `i' and `j' makes sense.  */\n-\t  field_type = DECL_CONTEXT (field);\n+\t  ctx = DECL_CONTEXT (field);\n \t  done = 0;\n \t  do\n \t    {\n-\t      tree last_field_type;\n+\t      tree last_ctx;\n \n-\t      last_field_type = DECL_CONTEXT (last_field);\n+\t      last_ctx = DECL_CONTEXT (last_field);\n \t      while (1)\n \t\t{\n-\t\t  if (same_type_p (last_field_type, field_type))\n+\t\t  if (same_type_p (last_ctx, ctx))\n \t\t    {\n-\t\t      if (TREE_CODE (field_type) == UNION_TYPE)\n+\t\t      if (TREE_CODE (ctx) == UNION_TYPE)\n \t\t\terror_at (DECL_SOURCE_LOCATION (current_function_decl),\n \t\t\t\t  \"initializations for multiple members of %qT\",\n-\t\t\t\t  last_field_type);\n+\t\t\t\t  last_ctx);\n \t\t      done = 1;\n \t\t      break;\n \t\t    }\n \n-\t\t  if (same_type_p (last_field_type, t))\n+\t\t  if (same_type_p (last_ctx, t))\n \t\t    break;\n \n-\t\t  last_field_type = TYPE_CONTEXT (last_field_type);\n+\t\t  last_ctx = TYPE_CONTEXT (last_ctx);\n \t\t}\n \n \t      /* If we've reached the outermost class, then we're\n \t\t done.  */\n-\t      if (same_type_p (field_type, t))\n+\t      if (same_type_p (ctx, t))\n \t\tbreak;\n \n-\t      field_type = TYPE_CONTEXT (field_type);\n+\t      ctx = TYPE_CONTEXT (ctx);\n \t    }\n \t  while (!done);\n "}]}