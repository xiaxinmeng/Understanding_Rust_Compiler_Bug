{"sha": "6bbf39b789101366bccacda4f912b05636f03887", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJiZjM5Yjc4OTEwMTM2NmJjY2FjZGE0ZjkxMmIwNTYzNmYwMzg4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-08T18:44:02Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-08T18:44:02Z"}, "message": "cgraph.c (thunk_adjust): Export.\n\n\n\t* cgraph.c (thunk_adjust): Export.\n\t* cgraphclones.c (cgraph_node::create_clone): Clone thunk info.\n\t* cgraphunit.c (thunk_adjust): Export.\n\t(cgraph_node::assemble_thunks_and_aliases): Do not assemble inlined\n\tthunks.\n\t* ipa-inline-analyssi.c (compute_inline_parameters): Thunks are\n\tinlinable.\n\t* tree-inline.c (expand_call_inline): Expand thunks inline.\n\nFrom-SVN: r236012", "tree": {"sha": "6fd631ddca25c1c6908f1589de9b99b80f6a38b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6fd631ddca25c1c6908f1589de9b99b80f6a38b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bbf39b789101366bccacda4f912b05636f03887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbf39b789101366bccacda4f912b05636f03887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bbf39b789101366bccacda4f912b05636f03887", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bbf39b789101366bccacda4f912b05636f03887/comments", "author": null, "committer": null, "parents": [{"sha": "3b695ba657799e3723a892a5fec1a1fb2061c63c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b695ba657799e3723a892a5fec1a1fb2061c63c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b695ba657799e3723a892a5fec1a1fb2061c63c"}], "stats": {"total": 161, "additions": 106, "deletions": 55}, "files": [{"sha": "1f985ce00e55eff036dc24ccb99660a1a99c8617", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -1,3 +1,14 @@\n+2016-05-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cgraph.c (thunk_adjust): Export.\n+\t* cgraphclones.c (cgraph_node::create_clone): Clone thunk info.\n+\t* cgraphunit.c (thunk_adjust): Export.\n+\t(cgraph_node::assemble_thunks_and_aliases): Do not assemble inlined\n+\tthunks.\n+\t* ipa-inline-analyssi.c (compute_inline_parameters): Thunks are\n+\tinlinable.\n+\t* tree-inline.c (expand_call_inline): Expand thunks inline.\n+\n 2016-05-08  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/70998"}, {"sha": "8ad9f456a22e57767e92b5c04787087bc8227535", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -2299,6 +2299,7 @@ void cgraphunit_c_finalize (void);\n     IN_SSA is true if the gimple is in SSA.  */\n basic_block init_lowered_empty_function (tree, bool, gcov_type);\n \n+tree thunk_adjust (gimple_stmt_iterator *, tree, bool, HOST_WIDE_INT, tree);\n /* In cgraphclones.c  */\n \n tree clone_function_name_1 (const char *, const char *);"}, {"sha": "43ee7352e5b09ae086672629b0352071a8947698", "filename": "gcc/cgraphclones.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraphclones.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraphclones.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphclones.c?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -436,6 +436,7 @@ cgraph_node::create_clone (tree new_decl, gcov_type gcov_count, int freq,\n   new_node->tm_clone = tm_clone;\n   new_node->icf_merged = icf_merged;\n   new_node->merged_comdat = merged_comdat;\n+  new_node->thunk = thunk;\n \n   new_node->clone.tree_map = NULL;\n   new_node->clone.args_to_skip = args_to_skip;"}, {"sha": "4bfcad78f59865e50f533d1547b69fd0e56b94df", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -1471,7 +1471,7 @@ init_lowered_empty_function (tree decl, bool in_ssa, gcov_type count)\n    non-null. THIS_ADJUSTING is nonzero for a this adjusting thunk and\n    zero for a result adjusting thunk.  */\n \n-static tree\n+tree\n thunk_adjust (gimple_stmt_iterator * bsi,\n \t      tree ptr, bool this_adjusting,\n \t      HOST_WIDE_INT fixed_offset, tree virtual_offset)\n@@ -1907,6 +1907,7 @@ cgraph_node::assemble_thunks_and_aliases (void)\n \n   for (e = callers; e;)\n     if (e->caller->thunk.thunk_p\n+\t&& !e->caller->global.inlined_to\n \t&& !e->caller->thunk.add_pointer_bounds_args)\n       {\n \tcgraph_node *thunk = e->caller;"}, {"sha": "17b21d17c5f41187712c10f04d095eefdd92618b", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -2920,67 +2920,70 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info = inline_summaries->get (node);\n   reset_inline_summary (node, info);\n \n-  /* FIXME: Thunks are inlinable, but tree-inline don't know how to do that.\n-     Once this happen, we will need to more curefully predict call\n-     statement size.  */\n+  /* Estimate the stack size for the function if we're optimizing.  */\n+  self_stack_size = optimize && !node->thunk.thunk_p\n+\t\t    ? estimated_stack_frame_size (node) : 0;\n+  info->estimated_self_stack_size = self_stack_size;\n+  info->estimated_stack_size = self_stack_size;\n+  info->stack_frame_offset = 0;\n+\n   if (node->thunk.thunk_p)\n     {\n       struct inline_edge_summary *es = inline_edge_summary (node->callees);\n       struct predicate t = true_predicate ();\n \n-      info->inlinable = 0;\n       node->callees->inline_failed = CIF_THUNK;\n       node->local.can_change_signature = false;\n-      es->call_stmt_time = 1;\n-      es->call_stmt_size = 1;\n-      account_size_time (info, 0, 0, &t);\n-      return;\n+      es->call_stmt_size = INLINE_SIZE_SCALE;\n+      es->call_stmt_time = INLINE_TIME_SCALE;\n+      account_size_time (info, INLINE_SIZE_SCALE * 2, INLINE_TIME_SCALE * 2, &t);\n+      inline_update_overall_summary (node);\n+      info->self_size = info->size;\n+      info->self_time = info->time;\n+      /* We can not inline instrumetnation clones.  */\n+      info->inlinable = !node->thunk.add_pointer_bounds_args;\n     }\n-\n-  /* Even is_gimple_min_invariant rely on current_function_decl.  */\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\n-  /* Estimate the stack size for the function if we're optimizing.  */\n-  self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n-  info->estimated_self_stack_size = self_stack_size;\n-  info->estimated_stack_size = self_stack_size;\n-  info->stack_frame_offset = 0;\n-\n-  /* Can this function be inlined at all?  */\n-  if (!opt_for_fn (node->decl, optimize)\n-      && !lookup_attribute (\"always_inline\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)))\n-    info->inlinable = false;\n-  else\n-    info->inlinable = tree_inlinable_function_p (node->decl);\n-\n-  info->contains_cilk_spawn = fn_contains_cilk_spawn_p (cfun);\n-\n-  /* Type attributes can use parameter indices to describe them.  */\n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n-    node->local.can_change_signature = false;\n   else\n     {\n-      /* Otherwise, inlinable functions always can change signature.  */\n-      if (info->inlinable)\n-\tnode->local.can_change_signature = true;\n-      else\n-\t{\n-\t  /* Functions calling builtin_apply can not change signature.  */\n-\t  for (e = node->callees; e; e = e->next_callee)\n-\t    {\n-\t      tree cdecl = e->callee->decl;\n-\t      if (DECL_BUILT_IN (cdecl)\n-\t\t  && DECL_BUILT_IN_CLASS (cdecl) == BUILT_IN_NORMAL\n-\t\t  && (DECL_FUNCTION_CODE (cdecl) == BUILT_IN_APPLY_ARGS\n-\t\t      || DECL_FUNCTION_CODE (cdecl) == BUILT_IN_VA_START))\n-\t\tbreak;\n-\t    }\n-\t  node->local.can_change_signature = !e;\n-\t}\n-    }\n-  estimate_function_body_sizes (node, early);\n-\n+       /* Even is_gimple_min_invariant rely on current_function_decl.  */\n+       push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\n+       /* Can this function be inlined at all?  */\n+       if (!opt_for_fn (node->decl, optimize)\n+\t   && !lookup_attribute (\"always_inline\",\n+\t\t\t\t DECL_ATTRIBUTES (node->decl)))\n+\t info->inlinable = false;\n+       else\n+\t info->inlinable = tree_inlinable_function_p (node->decl);\n+\n+       info->contains_cilk_spawn = fn_contains_cilk_spawn_p (cfun);\n+\n+       /* Type attributes can use parameter indices to describe them.  */\n+       if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n+\t node->local.can_change_signature = false;\n+       else\n+\t {\n+\t   /* Otherwise, inlinable functions always can change signature.  */\n+\t   if (info->inlinable)\n+\t     node->local.can_change_signature = true;\n+\t   else\n+\t     {\n+\t       /* Functions calling builtin_apply can not change signature.  */\n+\t       for (e = node->callees; e; e = e->next_callee)\n+\t\t {\n+\t\t   tree cdecl = e->callee->decl;\n+\t\t   if (DECL_BUILT_IN (cdecl)\n+\t\t       && DECL_BUILT_IN_CLASS (cdecl) == BUILT_IN_NORMAL\n+\t\t       && (DECL_FUNCTION_CODE (cdecl) == BUILT_IN_APPLY_ARGS\n+\t\t\t   || DECL_FUNCTION_CODE (cdecl) == BUILT_IN_VA_START))\n+\t\t     break;\n+\t\t }\n+\t       node->local.can_change_signature = !e;\n+\t     }\n+\t }\n+       estimate_function_body_sizes (node, early);\n+       pop_cfun ();\n+     }\n   for (e = node->callees; e; e = e->next_callee)\n     if (e->callee->comdat_local_p ())\n       break;\n@@ -2997,8 +3000,6 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n       gcc_assert (info->time == info->self_time\n \t\t  && info->size == info->self_size);\n     }\n-\n-  pop_cfun ();\n }\n \n "}, {"sha": "2ee3f630b147e31db1fb42343ba0e24f655804b2", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 37, "deletions": 1, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bbf39b789101366bccacda4f912b05636f03887/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=6bbf39b789101366bccacda4f912b05636f03887", "patch": "@@ -4450,6 +4450,43 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \t}\n       goto egress;\n     }\n+  id->src_node = cg_edge->callee;\n+\n+  /* If callee is thunk, all we need is to adjust the THIS pointer\n+     and redirect to function being thunked.  */\n+  if (id->src_node->thunk.thunk_p)\n+    {\n+      cgraph_edge *edge;\n+      tree virtual_offset = NULL;\n+      int freq = cg_edge->frequency;\n+      gcov_type count = cg_edge->count;\n+      tree op;\n+      gimple_stmt_iterator iter = gsi_for_stmt (stmt);\n+\n+      cg_edge->remove ();\n+      edge = id->src_node->callees->clone (id->dst_node, call_stmt,\n+\t\t   \t\t           gimple_uid (stmt),\n+\t\t\t\t   \t   REG_BR_PROB_BASE, CGRAPH_FREQ_BASE,\n+\t\t\t\t           true);\n+      edge->frequency = freq;\n+      edge->count = count;\n+      if (id->src_node->thunk.virtual_offset_p)\n+        virtual_offset = size_int (id->src_node->thunk.virtual_value);\n+      op = create_tmp_reg_fn (cfun, TREE_TYPE (gimple_call_arg (stmt, 0)),\n+\t\t\t      NULL);\n+      gsi_insert_before (&iter, gimple_build_assign (op,\n+\t\t\t\t\t\t    gimple_call_arg (stmt, 0)),\n+\t\t\t GSI_NEW_STMT);\n+      gcc_assert (id->src_node->thunk.this_adjusting);\n+      op = thunk_adjust (&iter, op, 1, id->src_node->thunk.fixed_offset,\n+\t\t\t virtual_offset);\n+\n+      gimple_call_set_arg (stmt, 0, op);\n+      gimple_call_set_fndecl (stmt, edge->callee->decl);\n+      update_stmt (stmt);\n+      id->src_node->remove ();\n+      return true;\n+    }\n   fn = cg_edge->callee->decl;\n   cg_edge->callee->get_untransformed_body ();\n \n@@ -4523,7 +4560,6 @@ expand_call_inline (basic_block bb, gimple *stmt, copy_body_data *id)\n \n   /* Record the function we are about to inline.  */\n   id->src_fn = fn;\n-  id->src_node = cg_edge->callee;\n   id->src_cfun = DECL_STRUCT_FUNCTION (fn);\n   id->call_stmt = stmt;\n "}]}