{"sha": "f4668ee7ead955ead1e9b9171e661e1c0409cb81", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQ2NjhlZTdlYWQ5NTVlYWQxZTliOTE3MWU2NjFlMWMwNDA5Y2I4MQ==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-06-27T22:24:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-27T22:24:13Z"}, "message": "Merge #502\n\n502: Trait Obligations building block r=philberty a=philberty\n\nThis is a building block for actually enforcing the obligations of a trait.\r\nIt includes a query-based lookup of the trait to avoid reloading it so\r\nwe only do the hard work once. Then provides the enforcement for\r\nbasic functions. Constants, methods and associated types are still\r\nWIP.\r\n\r\nAddresses: #440 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "299df85ce4b7b41f7c6bdc6d6f0c1609bde63d2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/299df85ce4b7b41f7c6bdc6d6f0c1609bde63d2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4668ee7ead955ead1e9b9171e661e1c0409cb81", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg2PqNCRBK7hj4Ov3rIwAA6p0IAA2YAtPpRkdxUGUqF7/AtGA0\nzGKepJVvjN7TQlTzjWkYa6Ks+L9khD8qH05yB0urOcf2Uzo0bfUBmzYnyfhp9M5+\nCKToywCFba7G1XgmNkofDS/4S7GksiWw4oNUbpotnQIoZZygDoLFjxmyQx/O+8m+\nssZ32xY/RkkqdXuQnVbl+3Wm2Kqd509lJx+v83C0d156MEG9va/GfpnLZkgRwZnD\nPNmLzxbxhcdxGF2U9cPxwPH1oM7fKZRRg8IRgopNjE8LWm1vhsICMRpaa1tGXvzs\njvDnaDGmJERMZrm7CKrqTNH7jfVh9n9hb8F9KgOh4av908wv2V/nkVA2rkxWJKI=\n=r5FO\n-----END PGP SIGNATURE-----\n", "payload": "tree 299df85ce4b7b41f7c6bdc6d6f0c1609bde63d2f\nparent 54e0d0171932b7c43e69f685e5fe41d473ddf5bf\nparent b81ef441b896d734489bb434014dc028e45a3f90\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1624832653 +0000\ncommitter GitHub <noreply@github.com> 1624832653 +0000\n\nMerge #502\n\n502: Trait Obligations building block r=philberty a=philberty\n\nThis is a building block for actually enforcing the obligations of a trait.\r\nIt includes a query-based lookup of the trait to avoid reloading it so\r\nwe only do the hard work once. Then provides the enforcement for\r\nbasic functions. Constants, methods and associated types are still\r\nWIP.\r\n\r\nAddresses: #440 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4668ee7ead955ead1e9b9171e661e1c0409cb81", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4668ee7ead955ead1e9b9171e661e1c0409cb81", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4668ee7ead955ead1e9b9171e661e1c0409cb81/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54e0d0171932b7c43e69f685e5fe41d473ddf5bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54e0d0171932b7c43e69f685e5fe41d473ddf5bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54e0d0171932b7c43e69f685e5fe41d473ddf5bf"}, {"sha": "b81ef441b896d734489bb434014dc028e45a3f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81ef441b896d734489bb434014dc028e45a3f90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81ef441b896d734489bb434014dc028e45a3f90"}], "stats": {"total": 672, "additions": 653, "deletions": 19}, "files": [{"sha": "0cf71e72850dd594420da402220c544100ed245a", "filename": "gcc/rust/hir/tree/rust-hir-item.h", "status": "modified", "additions": 50, "deletions": 8, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-item.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -2423,6 +2423,21 @@ struct TraitFunctionDecl\n     rust_assert (is_method ());\n     return self;\n   }\n+\n+  Identifier get_function_name () const { return function_name; }\n+\n+  std::vector<std::unique_ptr<GenericParam> > &get_generic_params ()\n+  {\n+    return generic_params;\n+  }\n+\n+  std::unique_ptr<Type> &get_return_type ()\n+  {\n+    rust_assert (has_return_type ());\n+    return return_type;\n+  }\n+\n+  std::vector<FunctionParam> &get_function_params () { return function_params; }\n };\n \n // Actual trait item function declaration within traits\n@@ -2478,7 +2493,15 @@ class TraitItemFunc : public TraitItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n-  std::unique_ptr<Expr> &get_block_expr () { return block_expr; }\n+  TraitFunctionDecl &get_decl () { return decl; }\n+\n+  bool has_block_defined () const { return block_expr != nullptr; }\n+\n+  std::unique_ptr<Expr> &get_block_expr ()\n+  {\n+    rust_assert (has_block_defined ());\n+    return block_expr;\n+  }\n \n protected:\n   // Clone function implementation as (not pure) virtual method\n@@ -2494,10 +2517,7 @@ class TraitItemConst : public TraitItem\n   AST::AttrVec outer_attrs;\n   Identifier name;\n   std::unique_ptr<Type> type;\n-\n-  // bool has_expression;\n   std::unique_ptr<Expr> expr;\n-\n   Location locus;\n \n public:\n@@ -2543,6 +2563,18 @@ class TraitItemConst : public TraitItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_name () const { return name; }\n+\n+  bool has_expr () const { return expr != nullptr; }\n+\n+  std::unique_ptr<Type> &get_type () { return type; }\n+\n+  std::unique_ptr<Expr> &get_expr ()\n+  {\n+    rust_assert (has_expr ());\n+    return expr;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemConst *clone_trait_item_impl () const override\n@@ -2557,12 +2589,8 @@ class TraitItemType : public TraitItem\n   AST::AttrVec outer_attrs;\n \n   Identifier name;\n-\n-  // bool has_type_param_bounds;\n-  // TypeParamBounds type_param_bounds;\n   std::vector<std::unique_ptr<TypeParamBound> >\n     type_param_bounds; // inlined form\n-\n   Location locus;\n \n public:\n@@ -2614,6 +2642,13 @@ class TraitItemType : public TraitItem\n \n   void accept_vis (HIRVisitor &vis) override;\n \n+  Identifier get_name () const { return name; }\n+\n+  std::vector<std::unique_ptr<TypeParamBound> > &get_type_param_bounds ()\n+  {\n+    return type_param_bounds;\n+  }\n+\n protected:\n   // Clone function implementation as (not pure) virtual method\n   TraitItemType *clone_trait_item_impl () const override\n@@ -2661,6 +2696,13 @@ class Trait : public VisItem\n   // Returns whether trait has trait items.\n   bool has_trait_items () const { return !trait_items.empty (); }\n \n+  std::vector<std::unique_ptr<TraitItem> > &get_trait_items ()\n+  {\n+    return trait_items;\n+  }\n+\n+  Identifier get_name () const { return name; }\n+\n   // Mega-constructor\n   Trait (Analysis::NodeMapping mappings, Identifier name, bool is_unsafe,\n \t std::vector<std::unique_ptr<GenericParam> > generic_params,"}, {"sha": "96498a5bb2c8c8d8172b57f841a92ca8ab779658", "filename": "gcc/rust/typecheck/rust-hir-trait-ref.h", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-ref.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -0,0 +1,198 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TRAIT_REF_H\n+#define RUST_HIR_TRAIT_REF_H\n+\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+// Data Objects for the associated trait items in a structure we can work with\n+// https://doc.rust-lang.org/edition-guide/rust-2018/trait-system/associated-constants.html\n+class TraitItemReference\n+{\n+public:\n+  enum TraitItemType\n+  {\n+    FN,\n+    CONST,\n+    TYPE,\n+    ERROR\n+  };\n+\n+  TraitItemReference (std::string identifier, bool optional, TraitItemType type,\n+\t\t      const HIR::TraitItem *hir_trait_item, TyTy::BaseType *ty,\n+\t\t      Location locus)\n+    : identifier (identifier), optional_flag (optional), type (type),\n+      hir_trait_item (hir_trait_item), ty (ty), locus (locus)\n+  {}\n+\n+  TraitItemReference (TraitItemReference const &other)\n+    : identifier (other.identifier), optional_flag (other.optional_flag),\n+      type (other.type), hir_trait_item (other.hir_trait_item), ty (other.ty),\n+      locus (other.locus)\n+  {}\n+\n+  TraitItemReference &operator= (TraitItemReference const &other)\n+  {\n+    identifier = other.identifier;\n+    optional_flag = other.optional_flag;\n+    type = other.type;\n+    hir_trait_item = other.hir_trait_item;\n+    ty = other.ty;\n+    locus = other.locus;\n+\n+    return *this;\n+  }\n+\n+  TraitItemReference (TraitItemReference &&other) = default;\n+  TraitItemReference &operator= (TraitItemReference &&other) = default;\n+\n+  static TraitItemReference error ()\n+  {\n+    return TraitItemReference (\"\", false, ERROR, nullptr, nullptr, Location ());\n+  }\n+\n+  static TraitItemReference &error_node ()\n+  {\n+    static TraitItemReference error = TraitItemReference::error ();\n+    return error;\n+  }\n+\n+  bool is_error () const { return type == ERROR; }\n+\n+  std::string as_string () const\n+  {\n+    return \"(\" + trait_item_type_as_string (type) + \" \" + identifier + \" \"\n+\t   + ty->as_string () + \")\";\n+  }\n+\n+  static std::string trait_item_type_as_string (TraitItemType ty)\n+  {\n+    switch (ty)\n+      {\n+      case FN:\n+\treturn \"FN\";\n+      case CONST:\n+\treturn \"CONST\";\n+      case TYPE:\n+\treturn \"TYPE\";\n+      case ERROR:\n+\treturn \"ERROR\";\n+      }\n+    return \"ERROR\";\n+  }\n+\n+  bool is_optional () const { return optional_flag; }\n+\n+  std::string get_identifier () const { return identifier; }\n+\n+  TraitItemType get_trait_item_type () const { return type; }\n+\n+  const HIR::TraitItem *get_hir_trait_item () const { return hir_trait_item; }\n+\n+  TyTy::BaseType *get_tyty () const { return ty; }\n+\n+  Location get_locus () const { return locus; }\n+\n+private:\n+  std::string identifier;\n+  bool optional_flag;\n+  TraitItemType type;\n+  const HIR::TraitItem *hir_trait_item;\n+  TyTy::BaseType *ty;\n+  Location locus;\n+};\n+\n+class TraitReference\n+{\n+public:\n+  TraitReference (const HIR::Trait *hir_trait_ref,\n+\t\t  std::vector<TraitItemReference> item_refs)\n+    : hir_trait_ref (hir_trait_ref), item_refs (item_refs)\n+  {}\n+\n+  TraitReference (TraitReference const &other)\n+    : hir_trait_ref (other.hir_trait_ref), item_refs (other.item_refs)\n+  {}\n+\n+  TraitReference &operator= (TraitReference const &other)\n+  {\n+    hir_trait_ref = other.hir_trait_ref;\n+    item_refs = other.item_refs;\n+\n+    return *this;\n+  }\n+\n+  TraitReference (TraitReference &&other) = default;\n+  TraitReference &operator= (TraitReference &&other) = default;\n+\n+  static TraitReference error () { return TraitReference (nullptr, {}); }\n+\n+  bool is_error () const { return hir_trait_ref == nullptr; }\n+\n+  Location get_locus () const { return hir_trait_ref->get_locus (); }\n+\n+  std::string get_name () const\n+  {\n+    rust_assert (!is_error ());\n+    return hir_trait_ref->get_name ();\n+  }\n+\n+  std::string as_string () const\n+  {\n+    if (is_error ())\n+      return \"<trait-ref-error-node>\";\n+\n+    std::string item_buf;\n+    for (auto &item : item_refs)\n+      {\n+\titem_buf += item.as_string () + \", \";\n+      }\n+    return \"HIR Trait: \" + get_name () + \"->\"\n+\t   + hir_trait_ref->get_mappings ().as_string () + \" [\" + item_buf\n+\t   + \"]\";\n+  }\n+\n+  const TraitItemReference &\n+  lookup_trait_item (const std::string &ident,\n+\t\t     TraitItemReference::TraitItemType type) const\n+  {\n+    for (auto &item : item_refs)\n+      {\n+\tif (item.get_trait_item_type () != type)\n+\t  continue;\n+\n+\tif (ident.compare (item.get_identifier ()) == 0)\n+\t  return item;\n+      }\n+    return TraitItemReference::error_node ();\n+  }\n+\n+private:\n+  const HIR::Trait *hir_trait_ref;\n+  std::vector<TraitItemReference> item_refs;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TRAIT_REF_H"}, {"sha": "2e358d3dcc045d56d6e25690d71a73d2652633a0", "filename": "gcc/rust/typecheck/rust-hir-trait-resolve.h", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-trait-resolve.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -0,0 +1,256 @@\n+// Copyright (C) 2021 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_HIR_TRAIT_RESOLVE_H\n+#define RUST_HIR_TRAIT_RESOLVE_H\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-type-check-type.h\"\n+#include \"rust-hir-trait-ref.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class ResolveTraitItemToRef : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static TraitItemReference Resolve (HIR::TraitItem &item)\n+  {\n+    ResolveTraitItemToRef resolver;\n+    item.accept_vis (resolver);\n+    return resolver.resolved;\n+  }\n+\n+  void visit (HIR::TraitItemType &type) override\n+  {\n+    // associated types are not typed and only support bounds\n+    TyTy::BaseType *ty = nullptr;\n+\n+    // create trait-item-ref\n+    Location locus = type.get_locus ();\n+    bool is_optional = false;\n+    std::string identifier = type.get_name ();\n+\n+    resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t   TraitItemReference::TraitItemType::TYPE,\n+\t\t\t\t   &type, ty, locus);\n+  }\n+\n+  void visit (HIR::TraitItemConst &cst) override\n+  {\n+    // attempt to lookup the type of the trait item function\n+    TyTy::BaseType *ty = nullptr;\n+    if (!context->lookup_type (cst.get_mappings ().get_hirid (), &ty))\n+      {\n+\tauto resolved = TypeCheckType::Resolve (cst.get_type ().get ());\n+\tif (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t  {\n+\t    rust_error_at (cst.get_locus (),\n+\t\t\t   \"failed to resolve trait constant type\");\n+\t    return;\n+\t  }\n+      }\n+\n+    // create trait-item-ref\n+    Location locus = cst.get_locus ();\n+    bool is_optional = cst.has_expr ();\n+    std::string identifier = cst.get_name ();\n+\n+    resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t   TraitItemReference::TraitItemType::CONST,\n+\t\t\t\t   &cst, ty, locus);\n+  }\n+\n+  void visit (HIR::TraitItemFunc &fn) override\n+  {\n+    // FIXME this is duplicated in a few places and could be refactored\n+\n+    // attempt to lookup the type of the trait item function\n+    TyTy::BaseType *ty = nullptr;\n+    if (!context->lookup_type (fn.get_mappings ().get_hirid (), &ty))\n+      {\n+\tHIR::TraitFunctionDecl &function = fn.get_decl ();\n+\tstd::vector<TyTy::SubstitutionParamMapping> substitutions;\n+\tif (function.has_generics ())\n+\t  {\n+\t    for (auto &generic_param : function.get_generic_params ())\n+\t      {\n+\t\tswitch (generic_param.get ()->get_kind ())\n+\t\t  {\n+\t\t  case HIR::GenericParam::GenericKind::LIFETIME:\n+\t\t    // Skipping Lifetime completely until better handling.\n+\t\t    break;\n+\n+\t\t    case HIR::GenericParam::GenericKind::TYPE: {\n+\t\t      auto param_type = TypeResolveGenericParam::Resolve (\n+\t\t\tgeneric_param.get ());\n+\t\t      context->insert_type (generic_param->get_mappings (),\n+\t\t\t\t\t    param_type);\n+\n+\t\t      substitutions.push_back (TyTy::SubstitutionParamMapping (\n+\t\t\tstatic_cast<HIR::TypeParam &> (*generic_param),\n+\t\t\tparam_type));\n+\t\t    }\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t  }\n+\n+\tTyTy::BaseType *ret_type = nullptr;\n+\tif (!function.has_return_type ())\n+\t  ret_type = new TyTy::TupleType (fn.get_mappings ().get_hirid ());\n+\telse\n+\t  {\n+\t    auto resolved\n+\t      = TypeCheckType::Resolve (function.get_return_type ().get ());\n+\t    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+\t      {\n+\t\trust_error_at (fn.get_locus (),\n+\t\t\t       \"failed to resolve return type\");\n+\t\treturn;\n+\t      }\n+\n+\t    ret_type = resolved->clone ();\n+\t    ret_type->set_ref (\n+\t      function.get_return_type ()->get_mappings ().get_hirid ());\n+\t  }\n+\n+\tstd::vector<std::pair<HIR::Pattern *, TyTy::BaseType *> > params;\n+\tfor (auto &param : function.get_function_params ())\n+\t  {\n+\t    // get the name as well required for later on\n+\t    auto param_tyty = TypeCheckType::Resolve (param.get_type ());\n+\t    params.push_back (std::pair<HIR::Pattern *, TyTy::BaseType *> (\n+\t      param.get_param_name (), param_tyty));\n+\n+\t    context->insert_type (param.get_mappings (), param_tyty);\n+\t  }\n+\n+\tty = new TyTy::FnType (fn.get_mappings ().get_hirid (),\n+\t\t\t       function.get_function_name (), false,\n+\t\t\t       std::move (params), ret_type,\n+\t\t\t       std::move (substitutions));\n+\tcontext->insert_type (fn.get_mappings (), ty);\n+      }\n+\n+    // create trait-item-ref\n+    Location locus = fn.get_locus ();\n+    bool is_optional = fn.has_block_defined ();\n+    std::string identifier = fn.get_decl ().get_function_name ();\n+\n+    resolved = TraitItemReference (identifier, is_optional,\n+\t\t\t\t   TraitItemReference::TraitItemType::FN, &fn,\n+\t\t\t\t   ty, locus);\n+  }\n+\n+private:\n+  ResolveTraitItemToRef ()\n+    : TypeCheckBase (), resolved (TraitItemReference::error ())\n+  {}\n+\n+  TraitItemReference resolved;\n+};\n+\n+class TraitResolver : public TypeCheckBase\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static TraitReference &Resolve (HIR::TypePath &path)\n+  {\n+    TraitResolver resolver;\n+    return resolver.go (path);\n+  }\n+\n+  static TraitReference &error_node ()\n+  {\n+    static TraitReference trait_error_node = TraitReference::error ();\n+    return trait_error_node;\n+  }\n+\n+private:\n+  TraitResolver () : TypeCheckBase () {}\n+\n+  TraitReference &go (HIR::TypePath &path)\n+  {\n+    NodeId ref;\n+    if (!resolver->lookup_resolved_type (path.get_mappings ().get_nodeid (),\n+\t\t\t\t\t &ref))\n+      {\n+\trust_fatal_error (path.get_locus (),\n+\t\t\t  \"Failed to resolve path to node-id\");\n+\treturn error_node ();\n+      }\n+\n+    HirId hir_node = UNKNOWN_HIRID;\n+    if (!mappings->lookup_node_to_hir (mappings->get_current_crate (), ref,\n+\t\t\t\t       &hir_node))\n+      {\n+\trust_fatal_error (path.get_locus (),\n+\t\t\t  \"Failed to resolve path to hir-id\");\n+\treturn error_node ();\n+      }\n+\n+    HIR::Item *resolved_item\n+      = mappings->lookup_hir_item (mappings->get_current_crate (), hir_node);\n+\n+    rust_assert (resolved_item != nullptr);\n+    resolved_item->accept_vis (*this);\n+    rust_assert (trait_reference != nullptr);\n+\n+    TraitReference &tref = error_node ();\n+    if (context->lookup_trait_reference (\n+\t  trait_reference->get_mappings ().get_defid (), tref))\n+      {\n+\treturn tref;\n+      }\n+\n+    std::vector<TraitItemReference> item_refs;\n+    for (auto &item : trait_reference->get_trait_items ())\n+      {\n+\tTraitItemReference trait_item_ref\n+\t  = ResolveTraitItemToRef::Resolve (*item.get ());\n+\titem_refs.push_back (std::move (trait_item_ref));\n+      }\n+\n+    tref = TraitReference (trait_reference, item_refs);\n+    context->insert_trait_reference (\n+      trait_reference->get_mappings ().get_defid (), std::move (tref));\n+\n+    tref = error_node ();\n+    bool ok = context->lookup_trait_reference (\n+      trait_reference->get_mappings ().get_defid (), tref);\n+    rust_assert (ok);\n+\n+    return tref;\n+  }\n+\n+  HIR::Trait *trait_reference;\n+\n+public:\n+  void visit (HIR::Trait &trait) override { trait_reference = &trait; }\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_HIR_TRAIT_RESOLVE_H"}, {"sha": "e06b10d358a4d755c79d6ff7189a17bf3668d287", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -915,7 +915,9 @@ class TypeCheckExpr : public TypeCheckBase\n \tauto candidates = PathProbeType::Probe (tyseg, seg.get_segment ());\n \tif (candidates.size () == 0)\n \t  {\n-\t    rust_error_at (seg.get_locus (), \"failed to resolve path segment\");\n+\t    rust_error_at (\n+\t      seg.get_locus (),\n+\t      \"failed to resolve path segment using an impl Probe\");\n \t    return;\n \t  }\n \telse if (candidates.size () > 1)"}, {"sha": "75ba0956606e0767b38d3511136673f4a43f7971", "filename": "gcc/rust/typecheck/rust-hir-type-check-implitem.h", "status": "modified", "additions": 83, "deletions": 5, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-implitem.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -207,13 +207,13 @@ class TypeCheckTopLevelImplItem : public TypeCheckBase\n \n   TyTy::BaseType *self;\n   std::vector<TyTy::SubstitutionParamMapping> substitutions;\n-}; // namespace Resolver\n+};\n \n class TypeCheckImplItem : public TypeCheckBase\n {\n+public:\n   using Rust::Resolver::TypeCheckBase::visit;\n \n-public:\n   static void Resolve (HIR::ImplItem *item, TyTy::BaseType *self)\n   {\n     TypeCheckImplItem resolver (self);\n@@ -238,15 +238,14 @@ class TypeCheckImplItem : public TypeCheckBase\n       }\n \n     // need to get the return type from this\n-    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    TyTy::FnType *resolve_fn_type = static_cast<TyTy::FnType *> (lookup);\n     auto expected_ret_tyty = resolve_fn_type->get_return_type ();\n     context->push_return_type (expected_ret_tyty);\n \n     auto block_expr_ty\n       = TypeCheckExpr::Resolve (function.get_definition ().get (), false);\n \n     context->pop_return_type ();\n-\n     expected_ret_tyty->unify (block_expr_ty);\n   }\n \n@@ -280,12 +279,91 @@ class TypeCheckImplItem : public TypeCheckBase\n     expected_ret_tyty->unify (block_expr_ty);\n   }\n \n-private:\n+protected:\n   TypeCheckImplItem (TyTy::BaseType *self) : TypeCheckBase (), self (self) {}\n \n   TyTy::BaseType *self;\n };\n \n+class TypeCheckImplItemWithTrait : public TypeCheckImplItem\n+{\n+  using Rust::Resolver::TypeCheckBase::visit;\n+\n+public:\n+  static const TraitItemReference &Resolve (HIR::ImplItem *item,\n+\t\t\t\t\t    TyTy::BaseType *self,\n+\t\t\t\t\t    TraitReference &trait_reference)\n+  {\n+    TypeCheckImplItemWithTrait resolver (self, trait_reference);\n+    item->accept_vis (resolver);\n+    return resolver.resolved_trait_item;\n+  }\n+\n+  void visit (HIR::ConstantItem &constant) override { gcc_unreachable (); }\n+\n+  void visit (HIR::TypeAlias &type) override { gcc_unreachable (); }\n+\n+  void visit (HIR::Method &method) override { gcc_unreachable (); }\n+\n+  void visit (HIR::Function &function) override\n+  {\n+    TypeCheckImplItem::visit (function);\n+\n+    // we get the error checking from the base method here\n+    TyTy::BaseType *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n+      return;\n+\n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      return;\n+\n+    TyTy::FnType *fntype = static_cast<TyTy::FnType *> (lookup);\n+    const TraitItemReference &trait_item_ref\n+      = trait_reference.lookup_trait_item (\n+\tfntype->get_identifier (), TraitItemReference::TraitItemType::FN);\n+\n+    // unknown trait item\n+    if (trait_item_ref.is_error ())\n+      {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (trait_reference.get_locus ());\n+\trust_error_at (r, \"method %<%s%> is not a member of trait %<%s%>\",\n+\t\t       fntype->get_identifier ().c_str (),\n+\t\t       trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    // check the types are compatible\n+    if (!trait_item_ref.get_tyty ()->can_eq (fntype))\n+      {\n+\tRichLocation r (function.get_locus ());\n+\tr.add_range (trait_item_ref.get_locus ());\n+\n+\trust_error_at (\n+\t  r, \"method %<%s%> has an incompatible type for trait %<%s%>\",\n+\t  fntype->get_identifier ().c_str (),\n+\t  trait_reference.get_name ().c_str ());\n+\treturn;\n+      }\n+\n+    resolved_trait_item = trait_item_ref;\n+  }\n+\n+private:\n+  TypeCheckImplItemWithTrait (TyTy::BaseType *self,\n+\t\t\t      TraitReference &trait_reference)\n+    : TypeCheckImplItem (self), trait_reference (trait_reference),\n+      resolved_trait_item (TraitItemReference::error_node ())\n+  {\n+    rust_assert (is_trait_impl_block ());\n+  }\n+\n+  bool is_trait_impl_block () const { return !trait_reference.is_error (); }\n+\n+  TraitReference &trait_reference;\n+  TraitItemReference &resolved_trait_item;\n+};\n+\n } // namespace Resolver\n } // namespace Rust\n "}, {"sha": "0126ded0f0c72a5ff8a03af6ae5e16c9e3a81574", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -24,6 +24,7 @@\n #include \"rust-hir-type-check-implitem.h\"\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n+#include \"rust-hir-trait-resolve.h\"\n #include \"rust-tyty-visitor.h\"\n \n namespace Rust {\n@@ -42,6 +43,14 @@ class TypeCheckItem : public TypeCheckBase\n \n   void visit (HIR::ImplBlock &impl_block) override\n   {\n+    TraitReference &trait_reference = TraitResolver::error_node ();\n+    if (impl_block.has_trait_ref ())\n+      {\n+\tstd::unique_ptr<HIR::TypePath> &ref = impl_block.get_trait_ref ();\n+\ttrait_reference = TraitResolver::Resolve (*ref.get ());\n+\trust_assert (!trait_reference.is_error ());\n+      }\n+\n     TyTy::BaseType *self = nullptr;\n     if (!context->lookup_type (\n \t  impl_block.get_type ()->get_mappings ().get_hirid (), &self))\n@@ -52,7 +61,13 @@ class TypeCheckItem : public TypeCheckBase\n       }\n \n     for (auto &impl_item : impl_block.get_impl_items ())\n-      TypeCheckImplItem::Resolve (impl_item.get (), self);\n+      {\n+\tif (trait_reference.is_error ())\n+\t  TypeCheckImplItem::Resolve (impl_item.get (), self);\n+\telse\n+\t  TypeCheckImplItemWithTrait::Resolve (impl_item.get (), self,\n+\t\t\t\t\t       trait_reference);\n+      }\n   }\n \n   void visit (HIR::Function &function) override"}, {"sha": "02980685dc291374854b4d33ad28d673d74f45fe", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-hir-full-decls.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-hir-trait-ref.h\"\n \n namespace Rust {\n namespace Resolver {\n@@ -85,14 +86,31 @@ class TypeCheckContext\n     loop_type_stack.push_back (val);\n   }\n \n+  void insert_trait_reference (DefId id, TraitReference &&ref)\n+  {\n+    rust_assert (trait_context.find (id) == trait_context.end ());\n+    trait_context.emplace (id, std::move (ref));\n+  }\n+\n+  bool lookup_trait_reference (DefId id, TraitReference &ref)\n+  {\n+    auto it = trait_context.find (id);\n+    if (it == trait_context.end ())\n+      return false;\n+\n+    ref = it->second;\n+    return true;\n+  }\n+\n private:\n   TypeCheckContext ();\n \n   std::map<NodeId, HirId> node_id_refs;\n   std::map<HirId, TyTy::BaseType *> resolved;\n-  std::vector<std::unique_ptr<TyTy::BaseType> > builtins;\n+  std::vector<std::unique_ptr<TyTy::BaseType>> builtins;\n   std::vector<TyTy::BaseType *> return_type_stack;\n   std::vector<TyTy::BaseType *> loop_type_stack;\n+  std::map<DefId, TraitReference> trait_context;\n };\n \n class TypeResolution"}, {"sha": "c3a974259b4d4868b609df72267280d87c5ab3bf", "filename": "gcc/rust/typecheck/rust-tyty-cmp.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-cmp.h?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -349,7 +349,7 @@ class FnCmp : public BaseCmp\n \tauto b = type.param_at (i).second;\n \n \tauto unified_param = a->unify (b);\n-\tif (unified_param == nullptr)\n+\tif (unified_param->get_kind () == TypeKind::ERROR)\n \t  {\n \t    BaseCmp::visit (type);\n \t    return;\n@@ -358,7 +358,7 @@ class FnCmp : public BaseCmp\n \n     auto unified_return\n       = base->get_return_type ()->unify (type.get_return_type ());\n-    if (unified_return == nullptr)\n+    if (unified_return->get_kind () == TypeKind::ERROR)\n       {\n \tBaseCmp::visit (type);\n \treturn;\n@@ -477,7 +477,7 @@ class ArrayCmp : public BaseCmp\n     // check base type\n     auto base_resolved\n       = base->get_element_type ()->unify (type.get_element_type ());\n-    if (base_resolved == nullptr)\n+    if (base_resolved->get_kind () == TypeKind::ERROR)\n       {\n \tBaseCmp::visit (type);\n \treturn;"}, {"sha": "30483b161e99ac40b8bb07fe7687e390b299a2ed", "filename": "gcc/testsuite/rust/compile/traits1.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits1.rs?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -0,0 +1,12 @@\n+trait Foo {\n+    fn Bar() -> i32 {}\n+}\n+\n+struct Baz;\n+\n+impl Foo for Baz {\n+    fn Barrr() {}\n+    // { dg-error \"method .Barrr. is not a member of trait .Foo.\" \"\" { target *-*-* } .-1 }\n+}\n+\n+fn main() {}"}, {"sha": "08e6bd375cf942c34fa7e5e792d7bdc5c69ccc3d", "filename": "gcc/testsuite/rust/compile/traits2.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4668ee7ead955ead1e9b9171e661e1c0409cb81/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftraits2.rs?ref=f4668ee7ead955ead1e9b9171e661e1c0409cb81", "patch": "@@ -0,0 +1,13 @@\n+trait Foo {\n+    fn Bar() -> i32 {}\n+}\n+\n+struct Baz;\n+\n+impl Foo for Baz {\n+    fn Bar() {}\n+    // { dg-error \"expected .i32. got .().\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"method .Bar. has an incompatible type for trait .Foo.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+fn main() {}"}]}