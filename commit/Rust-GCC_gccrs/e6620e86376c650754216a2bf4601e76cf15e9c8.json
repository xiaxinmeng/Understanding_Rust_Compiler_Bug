{"sha": "e6620e86376c650754216a2bf4601e76cf15e9c8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY2MjBlODYzNzZjNjUwNzU0MjE2YTJiZjQ2MDFlNzZjZjE1ZTljOA==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2006-01-28T05:19:44Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2006-01-28T05:19:44Z"}, "message": "re PR c/19606 (wrong code for arith.expr: (((unsigned int)(signed int) a ) / 2LL) with signed char a=-4)\n\ngcc/\n\tPR c/19606.\n\t* c-typeck.c (build_binary_op): Perform implicit casts of\n\toperands before shortening them.\n\ngcc/testsuite/\n\tPR c/19606.\n\t* gcc.c-torture/execute/pr19606.c: New.\n\nFrom-SVN: r110321", "tree": {"sha": "4ddc98ebd807edb66fa95964e68d043ebfd32d12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ddc98ebd807edb66fa95964e68d043ebfd32d12"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e6620e86376c650754216a2bf4601e76cf15e9c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6620e86376c650754216a2bf4601e76cf15e9c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e6620e86376c650754216a2bf4601e76cf15e9c8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e6620e86376c650754216a2bf4601e76cf15e9c8/comments", "author": null, "committer": null, "parents": [{"sha": "dadd8a3feb939f977b30b02e781133b315b117d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dadd8a3feb939f977b30b02e781133b315b117d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dadd8a3feb939f977b30b02e781133b315b117d4"}], "stats": {"total": 76, "additions": 72, "deletions": 4}, "files": [{"sha": "7c1baa3bd637fbdb6fbfa8fe41c743084e29204d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e6620e86376c650754216a2bf4601e76cf15e9c8", "patch": "@@ -1,3 +1,9 @@\n+2006-01-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR c/19606.\n+\t* c-typeck.c (build_binary_op): Perform implicit casts of\n+\toperands before shortening them.\n+\n 2006-01-27  H.J. Lu  <hongjiu.lu@intel.com>\n \n \t* df-scan.c (df_record_entry_block_defs): Check if"}, {"sha": "ef518951c52f385b4664286b320d8f9db57f4b39", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=e6620e86376c650754216a2bf4601e76cf15e9c8", "patch": "@@ -8101,12 +8101,35 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       if (shorten && none_complex)\n \t{\n \t  int unsigned0, unsigned1;\n-\t  tree arg0 = get_narrower (op0, &unsigned0);\n-\t  tree arg1 = get_narrower (op1, &unsigned1);\n-\t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n-\t  int uns = TYPE_UNSIGNED (result_type);\n+\t  tree arg0, arg1;\n+\t  int uns;\n \t  tree type;\n \n+\t  /* Cast OP0 and OP1 to RESULT_TYPE.  Doing so prevents\n+\t     excessive narrowing when we call get_narrower below.  For\n+\t     example, suppose that OP0 is of unsigned int extended\n+\t     from signed char and that RESULT_TYPE is long long int.\n+\t     If we explicitly cast OP0 to RESULT_TYPE, OP0 would look\n+\t     like\n+\n+\t       (long long int) (unsigned int) signed_char\n+\n+\t     which get_narrower would narrow down to\n+\n+\t       (unsigned int) signed char\n+\n+\t     If we do not cast OP0 first, get_narrower would return\n+\t     signed_char, which is inconsistent with the case of the\n+\t     explicit cast.  */\n+\t  op0 = convert (result_type, op0);\n+\t  op1 = convert (result_type, op1);\n+\n+\t  arg0 = get_narrower (op0, &unsigned0);\n+\t  arg1 = get_narrower (op1, &unsigned1);\n+\n+\t  /* UNS is 1 if the operation to be done is an unsigned one.  */\n+\t  uns = TYPE_UNSIGNED (result_type);\n+\n \t  final_type = result_type;\n \n \t  /* Handle the case that OP0 (or OP1) does not *contain* a conversion"}, {"sha": "2f2f8c67727cf475d90b9ba89734681c125365ef", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e6620e86376c650754216a2bf4601e76cf15e9c8", "patch": "@@ -1,3 +1,8 @@\n+2006-01-28  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\tPR c/19606.\n+\t* gcc.c-torture/execute/pr19606.c: New.\n+\n 2006-01-27  Carlos O'Donell  <carlos@codesourcery.com>\n \n \t* gcc.dg/pragma-re-4.c: New test."}, {"sha": "d1e836fa028a46ecbda2a195dfc467bb31601bdf", "filename": "gcc/testsuite/gcc.c-torture/execute/pr19606.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19606.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e6620e86376c650754216a2bf4601e76cf15e9c8/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19606.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fpr19606.c?ref=e6620e86376c650754216a2bf4601e76cf15e9c8", "patch": "@@ -0,0 +1,34 @@\n+/* PR c/19606\n+   The C front end used to shorten the type of a division to a type\n+   that does not preserve the semantics of the original computation.\n+   Make sure that won't happen.  */\n+\n+signed char a = -4;\n+\n+int\n+foo (void)\n+{\n+  return ((unsigned int) (signed int) a) / 2LL;\n+}\n+\n+int\n+bar (void)\n+{\n+  return ((unsigned int) (signed int) a) % 5LL;\n+}\n+\n+int\n+main (void)\n+{\n+  int r;\n+\n+  r = foo ();\n+  if (r != ((unsigned int) (signed int) (signed char) -4) / 2LL)\n+    abort ();\n+\n+  r = bar ();\n+  if (r != ((unsigned int) (signed int) (signed char) -4) % 5LL)\n+    abort ();\n+\n+  exit (0);\n+}"}]}