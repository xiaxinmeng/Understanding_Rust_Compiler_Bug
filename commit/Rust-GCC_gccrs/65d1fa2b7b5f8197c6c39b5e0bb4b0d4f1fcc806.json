{"sha": "65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkMWZhMmI3YjVmODE5N2M2YzM5YjVlMGJiNGIwZDRmMWZjYzgwNg==", "commit": {"author": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-04-04T13:23:40Z"}, "committer": {"name": "Charles Hannum", "email": "mycroft@gnu.org", "date": "1992-04-04T13:23:40Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r681", "tree": {"sha": "3d9fa19edb00d930eec1e610e7c9388afeeb80de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d9fa19edb00d930eec1e610e7c9388afeeb80de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806/comments", "author": null, "committer": null, "parents": [{"sha": "717702e6ae295db205aa7d8d72e79e05e37dbe3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/717702e6ae295db205aa7d8d72e79e05e37dbe3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/717702e6ae295db205aa7d8d72e79e05e37dbe3b"}], "stats": {"total": 16, "additions": 8, "deletions": 8}, "files": [{"sha": "803c4a2bc144241d0482e1fc7537d38f473f6eb4", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=65d1fa2b7b5f8197c6c39b5e0bb4b0d4f1fcc806", "patch": "@@ -1358,7 +1358,7 @@ output_epilog (file, size)\n     fprintf (file, \"\\t.long 0\\n\");\n \n     /* Tbtab format type.  Use format type 0.  */\n-    fprintf (file, \"\\t.byte 0\\n\");\n+    fprintf (file, \"\\t.byte 0,\");\n \n     /* Language type.  Unfortunately, there doesn't seem to be any official way\n        to get this info, so we use language_string.  C is 0.  C++ is 9.\n@@ -1370,32 +1370,32 @@ output_epilog (file, size)\n       i = 9;\n     else\n       abort ();\n-    fprintf (file, \"\\t.byte %d\\n\", i);\n+    fprintf (file, \"%d,\", i);\n \n     /* 8 single bit fields: global linkage (not set for C extern linkage,\n        apparently a PL/I convention?), out-of-line epilogue/prologue, offset\n        from start of procedure stored in tbtab, internal function, function\n        has controlled storage, function has no toc, function uses fp,\n        function logs/aborts fp operations.  */\n     /* Assume that fp operations are used if any fp reg must be saved.  */\n-    fprintf (file, \"\\t.byte %d\\n\", (1 << 5) | ((first_fp_reg != 64) << 1));\n+    fprintf (file, \"%d,\", (1 << 5) | ((first_fp_reg != 64) << 1));\n \n     /* 6 bitfields: function is interrupt handler, name present in proc table,\n        function calls alloca, on condition directives (controls stack walks,\n        3 bits), saves condition reg, saves link reg.  */\n     /* The `function calls alloca' bit seems to be set whenever reg 31 is\n        set up as a frame pointer, even when there is no alloca call.  */\n-    fprintf (file, \"\\t.byte %d\\n\",\n+    fprintf (file, \"%d,\",\n \t     ((1 << 6) | (frame_pointer_needed << 5)\n \t      | (must_save_cr () << 1) | (regs_ever_live[65])));\n \n     /* 3 bitfields: saves backchain, spare bit, number of fpr saved\n        (6 bits).  */\n-    fprintf (file, \"\\t.byte %d\\n\",\n+    fprintf (file, \"%d,\",\n \t     (must_push << 7) | (64 - first_fp_reg_to_save ()));\n \n     /* 2 bitfields: spare bits (2 bits), number of gpr saved (6 bits).  */\n-    fprintf (file, \"\\t.byte %d\\n\", (32 - first_reg_to_save ()));\n+    fprintf (file, \"%d,\", (32 - first_reg_to_save ()));\n \n     {\n       /* Compute the parameter info from the function decl argument list.  */\n@@ -1446,7 +1446,7 @@ output_epilog (file, size)\n     /* Number of fixed point parameters.  */\n     /* This is actually the number of words of fixed point parameters; thus\n        an 8 byte struct counts as 2; and thus the maximum value is 8.  */\n-    fprintf (file, \"\\t.byte %d\\n\", fixed_parms);\n+    fprintf (file, \"%d,\", fixed_parms);\n \n     /* 2 bitfields: number of floating point parameters (7 bits), parameters\n        all on stack.  */\n@@ -1455,7 +1455,7 @@ output_epilog (file, size)\n     /* Set parameters on stack bit if parameters are not in their original\n        registers, irregardless of whether they are on the stack?  Xlc\n        seems to set the bit when not optimizing.  */\n-    fprintf (file, \"\\t.byte %d\\n\", ((float_parms << 1) | (! optimize)));\n+    fprintf (file, \"%d\\n\", ((float_parms << 1) | (! optimize)));\n \n     /* Optional fields follow.  Some are variable length.  */\n "}]}